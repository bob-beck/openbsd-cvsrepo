head	1.94;
access;
symbols
	OPENBSD_6_2:1.94.0.4
	OPENBSD_6_2_BASE:1.94
	OPENBSD_6_1:1.93.0.4
	OPENBSD_6_1_BASE:1.93
	OPENBSD_6_0:1.91.0.6
	OPENBSD_6_0_BASE:1.91
	OPENBSD_5_9:1.91.0.2
	OPENBSD_5_9_BASE:1.91
	OPENBSD_5_8:1.87.0.4
	OPENBSD_5_8_BASE:1.87
	OPENBSD_5_7:1.82.0.4
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.80.0.4
	OPENBSD_5_6_BASE:1.80
	OPENBSD_5_5:1.77.0.4
	OPENBSD_5_5_BASE:1.77
	OPENBSD_5_4:1.72.0.2
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.71.0.2
	OPENBSD_5_3_BASE:1.71
	OPENBSD_5_2:1.69.0.2
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.68
	OPENBSD_5_1:1.68.0.2
	OPENBSD_5_0:1.65.0.2
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.56.0.2
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.36.0.4
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.1
	SMP:1.1.0.8
	OPENBSD_3_3:1.1.0.6
	OPENBSD_3_3_BASE:1.1
	UBC:1.1.0.4
	UBC_SYNC_B:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.94
date	2017.08.12.16.40.54;	author sf;	state Exp;
branches;
next	1.93;
commitid	NjJ5SMCA2U7qU3sg;

1.93
date	2017.03.19.11.09.26;	author jsg;	state Exp;
branches;
next	1.92;
commitid	C8KxFzCXnnd7g2hA;

1.92
date	2016.08.23.04.04.23;	author jsg;	state Exp;
branches;
next	1.91;
commitid	vzFGJLcohtB13TXT;

1.91
date	2016.02.18.14.24.39;	author bluhm;	state Exp;
branches;
next	1.90;
commitid	byf6gliq76JeDmXn;

1.90
date	2015.12.14.03.04.10;	author mmcc;	state Exp;
branches;
next	1.89;
commitid	QRx2J32q7BBN5PYO;

1.89
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.88;
commitid	5gdEnqVoJuTuwdTu;

1.88
date	2015.09.12.02.38.14;	author jsg;	state Exp;
branches;
next	1.87;
commitid	NaxaxLwZucETBhrG;

1.87
date	2015.08.05.18.31.14;	author sf;	state Exp;
branches;
next	1.86;
commitid	kMHvsPboZ0OcYfUL;

1.86
date	2015.07.17.16.56.34;	author yuo;	state Exp;
branches;
next	1.85;
commitid	4zUh21dsIYyTIxYF;

1.85
date	2015.06.04.18.33.41;	author dms;	state Exp;
branches;
next	1.84;
commitid	KGqt9GuXdcKKj76A;

1.84
date	2015.05.12.02.33.39;	author jsg;	state Exp;
branches;
next	1.83;
commitid	tSo3dk97sZVrtqBm;

1.83
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.82;
commitid	p4LJxGKbi0BU2cG6;

1.82
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.81;
commitid	yM2VFFhpDTeFQlve;

1.81
date	2014.11.05.15.30.17;	author claudio;	state Exp;
branches;
next	1.80;
commitid	qjAWexfO9LNS8Qo2;

1.80
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.79;
commitid	TGHgrLxu6sxZoiFt;

1.79
date	2014.03.10.04.09.53;	author jsg;	state Exp;
branches;
next	1.78;

1.78
date	2014.03.10.03.08.34;	author jsg;	state Exp;
branches;
next	1.77;

1.77
date	2014.02.22.04.41.31;	author chris;	state Exp;
branches;
next	1.76;

1.76
date	2014.02.17.07.02.45;	author jsg;	state Exp;
branches;
next	1.75;

1.75
date	2013.11.27.01.13.10;	author jsg;	state Exp;
branches;
next	1.74;

1.74
date	2013.11.21.14.44.37;	author jsg;	state Exp;
branches;
next	1.73;

1.73
date	2013.08.07.01.06.34;	author bluhm;	state Exp;
branches;
next	1.72;

1.72
date	2013.04.30.07.07.50;	author jsg;	state Exp;
branches;
next	1.71;

1.71
date	2012.12.05.23.20.20;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2012.11.26.01.17.41;	author jsg;	state Exp;
branches;
next	1.69;

1.69
date	2012.05.17.10.45.17;	author jsg;	state Exp;
branches;
next	1.68;

1.68
date	2011.11.29.04.10.59;	author jsg;	state Exp;
branches;
next	1.67;

1.67
date	2011.10.19.07.29.42;	author jsg;	state Exp;
branches;
next	1.66;

1.66
date	2011.10.05.02.52.10;	author jsg;	state Exp;
branches;
next	1.65;

1.65
date	2011.05.02.18.16.58;	author dhill;	state Exp;
branches;
next	1.64;

1.64
date	2011.05.02.12.25.42;	author jsg;	state Exp;
branches;
next	1.63;

1.63
date	2011.04.22.10.09.57;	author jsg;	state Exp;
branches;
next	1.62;

1.62
date	2011.04.14.21.14.28;	author jsg;	state Exp;
branches;
next	1.61;

1.61
date	2011.04.04.03.49.32;	author william;	state Exp;
branches;
next	1.60;

1.60
date	2011.02.15.19.15.25;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2011.02.06.23.47.14;	author dlg;	state Exp;
branches;
next	1.58;

1.58
date	2010.09.19.13.10.21;	author yasuoka;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.19.11.29.27;	author jsg;	state Exp;
branches;
next	1.56;

1.56
date	2010.08.03.16.39.33;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.13.21.55.52;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.02.21.41.59;	author jsg;	state Exp;
branches;
next	1.53;

1.53
date	2010.06.29.19.14.09;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2010.06.28.20.24.39;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.27.20.13.04;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.26.18.32.38;	author jsg;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.21.21.11.52;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.21.20.43.44;	author jsg;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.18.21.51.10;	author jsg;	state Exp;
branches;
next	1.46;

1.46
date	2010.03.02.22.09.57;	author dms;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.09.22.56.24;	author dms;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.27.13.12.58;	author fkr;	state Exp;
branches;
next	1.43;

1.43
date	2009.11.25.18.47.36;	author dms;	state Exp;
branches;
next	1.42;

1.42
date	2009.11.25.13.28.13;	author dms;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.11.23.54.49;	author dms;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.11.00.18.37;	author dms;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.06.02.01.04;	author dms;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.04.22.13.51;	author dms;	state Exp;
branches;
next	1.37;

1.37
date	2009.08.21.22.54.10;	author dms;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.03.06.54.39;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.26.14.30.35;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.23.14.09.51;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.04.05.08.43;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.03.17.39.44;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.04.02.36.52;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.24.19.12.59;	author chl;	state Exp;
branches;
next	1.29;

1.29
date	2008.03.21.00.20.55;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2008.02.20.00.00.06;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2008.02.04.00.30.01;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.09.18.02.46;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.16.00.07.37;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.06.03.52.37;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.03.06.39.10;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.09.04.44.06;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.07.02.56.18;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.05.01.15.30;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2006.07.03.20.55.55;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.17.20.45.52;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.18.19.06.02;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.28.05.33.03;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.07.09.21.55;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.26.14.31.26;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.08.01.33.19;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.07.23.38.09;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.07.23.24.42;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.11.23.54.31;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.02.06.15.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.27.16.38.13;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.19.18.18.14;	author jolan;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.17.18.07.36;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.16.14.39.14;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.18.04.15.00;	author henric;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.09.23.37.03;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.13.19.21.21;	author henric;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.18.56.02;	author nate;	state Exp;
branches
	1.1.4.1
	1.1.8.1;
next	;

1.1.4.1
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	;

1.1.8.1
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2004.06.05.23.12.50;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.94
log
@em: Disable ultra-low-power mode on boot

With i219V, it sometimes happens that em fails to attach with this error:

  em0: Hardware Initialization Failed
  em0: Unable to initialize the hardware

This happens always if booting native Windows 10 first and then rebooting into
openbsd without switching the laptop off. But it has also been seen in other
cases.

This change ports the e1000_disable_ulp_lpt_lp() logic from the FreeBSD driver
to disable ultra-low-power (ULP) mode.  This seems to fix the problem in many
(but not all) cases.

The code has been merged in a way to make the diff from FreeBSD minimal.  For
example, the SWFW register is called H2ME on newer chips, so a new define is
introduced. Also, the em_toggle_lanphypc_pch_lpt() function is left as separate
function even if only used in one place at the moment.

ok tom@@
"commit it" deraadt@@
@
text
@/*******************************************************************************

  Copyright (c) 2001-2005, Intel Corporation
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

   3. Neither the name of the Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

*******************************************************************************/

/* $OpenBSD: if_em_hw.c,v 1.93 2017/03/19 11:09:26 jsg Exp $ */
/*
 * if_em_hw.c Shared functions for accessing and configuring the MAC
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <uvm/uvm_extern.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <dev/pci/if_em_hw.h>
#include <dev/pci/if_em_soc.h>

#include <dev/mii/rgephyreg.h>

#define STATIC

static int32_t	em_swfw_sync_acquire(struct em_hw *, uint16_t);
static void	em_swfw_sync_release(struct em_hw *, uint16_t);
static int32_t	em_read_kmrn_reg(struct em_hw *, uint32_t, uint16_t *);
static int32_t	em_write_kmrn_reg(struct em_hw *hw, uint32_t, uint16_t);
static int32_t	em_get_software_semaphore(struct em_hw *);
static void	em_release_software_semaphore(struct em_hw *);

static int32_t	em_check_downshift(struct em_hw *);
static void	em_clear_vfta(struct em_hw *);
void		em_clear_vfta_i350(struct em_hw *);
static int32_t	em_commit_shadow_ram(struct em_hw *);
static int32_t	em_config_dsp_after_link_change(struct em_hw *, boolean_t);
static int32_t	em_config_fc_after_link_up(struct em_hw *);
static int32_t	em_match_gig_phy(struct em_hw *);
static int32_t	em_detect_gig_phy(struct em_hw *);
static int32_t	em_erase_ich8_4k_segment(struct em_hw *, uint32_t);
static int32_t	em_get_auto_rd_done(struct em_hw *);
static int32_t	em_get_cable_length(struct em_hw *, uint16_t *, uint16_t *);
static int32_t	em_get_hw_eeprom_semaphore(struct em_hw *);
static int32_t	em_get_phy_cfg_done(struct em_hw *);
static int32_t	em_get_software_flag(struct em_hw *);
static int32_t	em_ich8_cycle_init(struct em_hw *);
static int32_t	em_ich8_flash_cycle(struct em_hw *, uint32_t);
static int32_t	em_id_led_init(struct em_hw *);
static int32_t	em_init_lcd_from_nvm_config_region(struct em_hw *,  uint32_t,
		    uint32_t);
static int32_t	em_init_lcd_from_nvm(struct em_hw *);
static int32_t	em_phy_no_cable_workaround(struct em_hw *);
static void	em_init_rx_addrs(struct em_hw *);
static void	em_initialize_hardware_bits(struct em_hw *);
static void	em_toggle_lanphypc_pch_lpt(struct em_hw *);
static int	em_disable_ulp_lpt_lp(struct em_hw *hw, bool force);
static boolean_t em_is_onboard_nvm_eeprom(struct em_hw *);
static int32_t	em_kumeran_lock_loss_workaround(struct em_hw *);
static int32_t	em_mng_enable_host_if(struct em_hw *);
static int32_t	em_read_eeprom_eerd(struct em_hw *, uint16_t, uint16_t, 
		    uint16_t *);
static int32_t	em_write_eeprom_eewr(struct em_hw *, uint16_t, uint16_t,
		    uint16_t *data);
static int32_t	em_poll_eerd_eewr_done(struct em_hw *, int);
static void	em_put_hw_eeprom_semaphore(struct em_hw *);
static int32_t	em_read_ich8_byte(struct em_hw *, uint32_t, uint8_t *);
static int32_t	em_verify_write_ich8_byte(struct em_hw *, uint32_t, uint8_t);
static int32_t	em_write_ich8_byte(struct em_hw *, uint32_t, uint8_t);
static int32_t	em_read_ich8_word(struct em_hw *, uint32_t, uint16_t *);
static int32_t	em_read_ich8_dword(struct em_hw *, uint32_t, uint32_t *);
static int32_t	em_read_ich8_data(struct em_hw *, uint32_t, uint32_t,
		    uint16_t *);
static int32_t	em_write_ich8_data(struct em_hw *, uint32_t, uint32_t,
		    uint16_t);
static int32_t	em_read_eeprom_ich8(struct em_hw *, uint16_t, uint16_t,
		    uint16_t *);
static int32_t	em_write_eeprom_ich8(struct em_hw *, uint16_t, uint16_t,
		    uint16_t *);
static int32_t	em_read_invm_i210(struct em_hw *, uint16_t, uint16_t,
		    uint16_t *);
static int32_t	em_read_invm_word_i210(struct em_hw *, uint16_t, uint16_t *);
static void	em_release_software_flag(struct em_hw *);
static int32_t	em_set_d3_lplu_state(struct em_hw *, boolean_t);
static int32_t	em_set_d0_lplu_state(struct em_hw *, boolean_t);
static int32_t	em_set_lplu_state_pchlan(struct em_hw *, boolean_t);
static int32_t	em_set_pci_ex_no_snoop(struct em_hw *, uint32_t);
static void	em_set_pci_express_master_disable(struct em_hw *);
static int32_t	em_wait_autoneg(struct em_hw *);
static void	em_write_reg_io(struct em_hw *, uint32_t, uint32_t);
static int32_t	em_set_phy_type(struct em_hw *);
static void	em_phy_init_script(struct em_hw *);
static int32_t	em_setup_copper_link(struct em_hw *);
static int32_t	em_setup_fiber_serdes_link(struct em_hw *);
static int32_t	em_adjust_serdes_amplitude(struct em_hw *);
static int32_t	em_phy_force_speed_duplex(struct em_hw *);
static int32_t	em_config_mac_to_phy(struct em_hw *);
static void	em_raise_mdi_clk(struct em_hw *, uint32_t *);
static void	em_lower_mdi_clk(struct em_hw *, uint32_t *);
static void	em_shift_out_mdi_bits(struct em_hw *, uint32_t, uint16_t);
static uint16_t	em_shift_in_mdi_bits(struct em_hw *);
static int32_t	em_phy_reset_dsp(struct em_hw *);
static int32_t	em_write_eeprom_spi(struct em_hw *, uint16_t, uint16_t,
		    uint16_t *);
static int32_t	em_write_eeprom_microwire(struct em_hw *, uint16_t, uint16_t,
		    uint16_t *);
static int32_t	em_spi_eeprom_ready(struct em_hw *);
static void	em_raise_ee_clk(struct em_hw *, uint32_t *);
static void	em_lower_ee_clk(struct em_hw *, uint32_t *);
static void	em_shift_out_ee_bits(struct em_hw *, uint16_t, uint16_t);
static int32_t	em_write_phy_reg_ex(struct em_hw *, uint32_t, uint16_t);
static int32_t	em_read_phy_reg_ex(struct em_hw *, uint32_t, uint16_t *);
static uint16_t	em_shift_in_ee_bits(struct em_hw *, uint16_t);
static int32_t	em_acquire_eeprom(struct em_hw *);
static void	em_release_eeprom(struct em_hw *);
static void	em_standby_eeprom(struct em_hw *);
static int32_t	em_set_vco_speed(struct em_hw *);
static int32_t	em_polarity_reversal_workaround(struct em_hw *);
static int32_t	em_set_phy_mode(struct em_hw *);
static int32_t	em_host_if_read_cookie(struct em_hw *, uint8_t *);
static uint8_t	em_calculate_mng_checksum(char *, uint32_t);
static int32_t	em_configure_kmrn_for_10_100(struct em_hw *, uint16_t);
static int32_t	em_configure_kmrn_for_1000(struct em_hw *);
static int32_t	em_set_pciex_completion_timeout(struct em_hw *hw);
static int32_t	em_set_mdio_slow_mode_hv(struct em_hw *);
int32_t		em_hv_phy_workarounds_ich8lan(struct em_hw *);
int32_t		em_lv_phy_workarounds_ich8lan(struct em_hw *);
int32_t		em_link_stall_workaround_hv(struct em_hw *);
int32_t		em_k1_gig_workaround_hv(struct em_hw *, boolean_t);
int32_t		em_k1_workaround_lv(struct em_hw *);
int32_t		em_k1_workaround_lpt_lp(struct em_hw *, boolean_t);
int32_t		em_configure_k1_ich8lan(struct em_hw *, boolean_t);
void		em_gate_hw_phy_config_ich8lan(struct em_hw *, boolean_t);
int32_t		em_access_phy_wakeup_reg_bm(struct em_hw *, uint32_t,
		    uint16_t *, boolean_t);
int32_t		em_access_phy_debug_regs_hv(struct em_hw *, uint32_t,
		    uint16_t *, boolean_t);
int32_t		em_access_phy_reg_hv(struct em_hw *, uint32_t, uint16_t *,
		    boolean_t);
int32_t		em_oem_bits_config_pchlan(struct em_hw *, boolean_t);
void		em_power_up_serdes_link_82575(struct em_hw *);
int32_t		em_get_pcs_speed_and_duplex_82575(struct em_hw *, uint16_t *,
    uint16_t *);
int32_t		em_set_eee_i350(struct em_hw *);
int32_t		em_set_eee_pchlan(struct em_hw *);
int32_t		em_valid_nvm_bank_detect_ich8lan(struct em_hw *, uint32_t *);
int32_t		em_initialize_M88E1512_phy(struct em_hw *);

/* IGP cable length table */
static const uint16_t 
em_igp_cable_length_table[IGP01E1000_AGC_LENGTH_TABLE_SIZE] =
    {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 10, 10, 10, 10, 10, 10, 10, 20, 20, 20, 20, 20, 25, 25, 25,
    25, 25, 25, 25, 30, 30, 30, 30, 40, 40, 40, 40, 40, 40, 40, 40,
    40, 50, 50, 50, 50, 50, 50, 50, 60, 60, 60, 60, 60, 60, 60, 60,
    60, 70, 70, 70, 70, 70, 70, 80, 80, 80, 80, 80, 80, 90, 90, 90,
    90, 90, 90, 90, 90, 90, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
    100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
    110,
    110, 110, 110, 110, 110, 110, 120, 120, 120, 120, 120, 120, 120, 120, 120,
    120};

static const uint16_t 
em_igp_2_cable_length_table[IGP02E1000_AGC_LENGTH_TABLE_SIZE] =
    {0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 8, 11, 13, 16, 18, 21,
    0, 0, 0, 3, 6, 10, 13, 16, 19, 23, 26, 29, 32, 35, 38, 41,
    6, 10, 14, 18, 22, 26, 30, 33, 37, 41, 44, 48, 51, 54, 58, 61,
    21, 26, 31, 35, 40, 44, 49, 53, 57, 61, 65, 68, 72, 75, 79, 82,
    40, 45, 51, 56, 61, 66, 70, 75, 79, 83, 87, 91, 94, 98, 101, 104,
    60, 66, 72, 77, 82, 87, 92, 96, 100, 104, 108, 111, 114, 117, 119, 121,
    83, 89, 95, 100, 105, 109, 113, 116, 119, 122, 124, 104, 109, 114, 118,
    121, 124};

/******************************************************************************
 * Set the phy type member in the hw struct.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
STATIC int32_t
em_set_phy_type(struct em_hw *hw)
{
	DEBUGFUNC("em_set_phy_type");

	if (hw->mac_type == em_undefined)
		return -E1000_ERR_PHY_TYPE;

	switch (hw->phy_id) {
	case M88E1000_E_PHY_ID:
	case M88E1000_I_PHY_ID:
	case M88E1011_I_PHY_ID:
	case M88E1111_I_PHY_ID:
	case M88E1112_E_PHY_ID:
	case M88E1543_E_PHY_ID:
	case M88E1512_E_PHY_ID:
	case I210_I_PHY_ID:
	case I347AT4_E_PHY_ID:
		hw->phy_type = em_phy_m88;
		break;
	case IGP01E1000_I_PHY_ID:
		if (hw->mac_type == em_82541 ||
		    hw->mac_type == em_82541_rev_2 ||
		    hw->mac_type == em_82547 ||
		    hw->mac_type == em_82547_rev_2) {
			hw->phy_type = em_phy_igp;
			break;
		}
	case IGP03E1000_E_PHY_ID:
	case IGP04E1000_E_PHY_ID:
		hw->phy_type = em_phy_igp_3;
		break;
	case IFE_E_PHY_ID:
	case IFE_PLUS_E_PHY_ID:
	case IFE_C_E_PHY_ID:
		hw->phy_type = em_phy_ife;
		break;
	case M88E1141_E_PHY_ID:
		hw->phy_type = em_phy_oem;
		break;
	case I82577_E_PHY_ID:
		hw->phy_type = em_phy_82577;
		break;
	case I82578_E_PHY_ID:
		hw->phy_type = em_phy_82578;
		break;
	case I82579_E_PHY_ID:
		hw->phy_type = em_phy_82579;
		break;
	case I217_E_PHY_ID:
		hw->phy_type = em_phy_i217;
		break;
	case I82580_I_PHY_ID:
	case I350_I_PHY_ID:
		hw->phy_type = em_phy_82580;
		break;
	case RTL8211_E_PHY_ID:
		hw->phy_type = em_phy_rtl8211;
		break;
	case BME1000_E_PHY_ID:
		if (hw->phy_revision == 1) {
			hw->phy_type = em_phy_bm;
			break;
		}
		/* FALLTHROUGH */
	case GG82563_E_PHY_ID:
		if (hw->mac_type == em_80003es2lan) {
			hw->phy_type = em_phy_gg82563;
			break;
		}
		/* FALLTHROUGH */
	default:
		/* Should never have loaded on this device */
		hw->phy_type = em_phy_undefined;
		return -E1000_ERR_PHY_TYPE;
	}

	return E1000_SUCCESS;
}

/******************************************************************************
 * IGP phy init script - initializes the GbE PHY
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static void
em_phy_init_script(struct em_hw *hw)
{
	uint16_t phy_saved_data;
	DEBUGFUNC("em_phy_init_script");

	if (hw->phy_init_script) {
		msec_delay(20);
		/*
		 * Save off the current value of register 0x2F5B to be
		 * restored at the end of this routine.
		 */
		em_read_phy_reg(hw, 0x2F5B, &phy_saved_data);

		/* Disabled the PHY transmitter */
		em_write_phy_reg(hw, 0x2F5B, 0x0003);
		msec_delay(20);
		em_write_phy_reg(hw, 0x0000, 0x0140);
		msec_delay(5);

		switch (hw->mac_type) {
		case em_82541:
		case em_82547:
			em_write_phy_reg(hw, 0x1F95, 0x0001);
			em_write_phy_reg(hw, 0x1F71, 0xBD21);
			em_write_phy_reg(hw, 0x1F79, 0x0018);
			em_write_phy_reg(hw, 0x1F30, 0x1600);
			em_write_phy_reg(hw, 0x1F31, 0x0014);
			em_write_phy_reg(hw, 0x1F32, 0x161C);
			em_write_phy_reg(hw, 0x1F94, 0x0003);
			em_write_phy_reg(hw, 0x1F96, 0x003F);
			em_write_phy_reg(hw, 0x2010, 0x0008);
			break;
		case em_82541_rev_2:
		case em_82547_rev_2:
			em_write_phy_reg(hw, 0x1F73, 0x0099);
			break;
		default:
			break;
		}

		em_write_phy_reg(hw, 0x0000, 0x3300);
		msec_delay(20);

		/* Now enable the transmitter */
		em_write_phy_reg(hw, 0x2F5B, phy_saved_data);

		if (hw->mac_type == em_82547) {
			uint16_t fused, fine, coarse;
			/* Move to analog registers page */
			em_read_phy_reg(hw, 
			    IGP01E1000_ANALOG_SPARE_FUSE_STATUS, &fused);

			if (!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
				em_read_phy_reg(hw, 
				    IGP01E1000_ANALOG_FUSE_STATUS, &fused);

				fine = fused &
				    IGP01E1000_ANALOG_FUSE_FINE_MASK;
				coarse = fused &
				    IGP01E1000_ANALOG_FUSE_COARSE_MASK;

				if (coarse > 
				    IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {
					coarse -= 
					    IGP01E1000_ANALOG_FUSE_COARSE_10;
					fine -= 
					    IGP01E1000_ANALOG_FUSE_FINE_1;
				} else if (coarse == 
				    IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
					fine -= IGP01E1000_ANALOG_FUSE_FINE_10;

				fused = (fused & 
				    IGP01E1000_ANALOG_FUSE_POLY_MASK) |
				    (fine & 
				    IGP01E1000_ANALOG_FUSE_FINE_MASK) |
				    (coarse & 
				    IGP01E1000_ANALOG_FUSE_COARSE_MASK);

				em_write_phy_reg(hw, 
				    IGP01E1000_ANALOG_FUSE_CONTROL, 
				    fused);

				em_write_phy_reg(hw, 
				    IGP01E1000_ANALOG_FUSE_BYPASS,
				    IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL);
			}
		}
	}
}

/******************************************************************************
 * Set the mac type member in the hw struct.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_set_mac_type(struct em_hw *hw)
{
	DEBUGFUNC("em_set_mac_type");

	switch (hw->device_id) {
	case E1000_DEV_ID_82542:
		switch (hw->revision_id) {
		case E1000_82542_2_0_REV_ID:
			hw->mac_type = em_82542_rev2_0;
			break;
		case E1000_82542_2_1_REV_ID:
			hw->mac_type = em_82542_rev2_1;
			break;
		default:
			/* Invalid 82542 revision ID */
			return -E1000_ERR_MAC_TYPE;
		}
		break;
	case E1000_DEV_ID_82543GC_FIBER:
	case E1000_DEV_ID_82543GC_COPPER:
		hw->mac_type = em_82543;
		break;
	case E1000_DEV_ID_82544EI_COPPER:
	case E1000_DEV_ID_82544EI_FIBER:
	case E1000_DEV_ID_82544GC_COPPER:
	case E1000_DEV_ID_82544GC_LOM:
		hw->mac_type = em_82544;
		break;
	case E1000_DEV_ID_82540EM:
	case E1000_DEV_ID_82540EM_LOM:
	case E1000_DEV_ID_82540EP:
	case E1000_DEV_ID_82540EP_LOM:
	case E1000_DEV_ID_82540EP_LP:
		hw->mac_type = em_82540;
		break;
	case E1000_DEV_ID_82545EM_COPPER:
	case E1000_DEV_ID_82545EM_FIBER:
		hw->mac_type = em_82545;
		break;
	case E1000_DEV_ID_82545GM_COPPER:
	case E1000_DEV_ID_82545GM_FIBER:
	case E1000_DEV_ID_82545GM_SERDES:
		hw->mac_type = em_82545_rev_3;
		break;
	case E1000_DEV_ID_82546EB_COPPER:
	case E1000_DEV_ID_82546EB_FIBER:
	case E1000_DEV_ID_82546EB_QUAD_COPPER:
		hw->mac_type = em_82546;
		break;
	case E1000_DEV_ID_82546GB_COPPER:
	case E1000_DEV_ID_82546GB_FIBER:
	case E1000_DEV_ID_82546GB_SERDES:
	case E1000_DEV_ID_82546GB_PCIE:
	case E1000_DEV_ID_82546GB_QUAD_COPPER:
	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
	case E1000_DEV_ID_82546GB_2:
		hw->mac_type = em_82546_rev_3;
		break;
	case E1000_DEV_ID_82541EI:
	case E1000_DEV_ID_82541EI_MOBILE:
	case E1000_DEV_ID_82541ER_LOM:
		hw->mac_type = em_82541;
		break;
	case E1000_DEV_ID_82541ER:
	case E1000_DEV_ID_82541GI:
	case E1000_DEV_ID_82541GI_LF:
	case E1000_DEV_ID_82541GI_MOBILE:
		hw->mac_type = em_82541_rev_2;
		break;
	case E1000_DEV_ID_82547EI:
	case E1000_DEV_ID_82547EI_MOBILE:
		hw->mac_type = em_82547;
		break;
	case E1000_DEV_ID_82547GI:
		hw->mac_type = em_82547_rev_2;
		break;
	case E1000_DEV_ID_82571EB_AF:
	case E1000_DEV_ID_82571EB_AT:
	case E1000_DEV_ID_82571EB_COPPER:
	case E1000_DEV_ID_82571EB_FIBER:
	case E1000_DEV_ID_82571EB_SERDES:
	case E1000_DEV_ID_82571EB_QUAD_COPPER:
	case E1000_DEV_ID_82571EB_QUAD_FIBER:
	case E1000_DEV_ID_82571EB_QUAD_COPPER_LP:
	case E1000_DEV_ID_82571EB_SERDES_DUAL:
	case E1000_DEV_ID_82571EB_SERDES_QUAD:
	case E1000_DEV_ID_82571PT_QUAD_COPPER:
		hw->mac_type = em_82571;
		break;
	case E1000_DEV_ID_82572EI_COPPER:
	case E1000_DEV_ID_82572EI_FIBER:
	case E1000_DEV_ID_82572EI_SERDES:
	case E1000_DEV_ID_82572EI:
		hw->mac_type = em_82572;
		break;
	case E1000_DEV_ID_82573E:
	case E1000_DEV_ID_82573E_IAMT:
	case E1000_DEV_ID_82573E_PM:
	case E1000_DEV_ID_82573L:
	case E1000_DEV_ID_82573L_PL_1:
	case E1000_DEV_ID_82573L_PL_2:
	case E1000_DEV_ID_82573V_PM:
		hw->mac_type = em_82573;
		break;
	case E1000_DEV_ID_82574L:
	case E1000_DEV_ID_82574LA:
	case E1000_DEV_ID_82583V:
		hw->mac_type = em_82574;
		break;
	case E1000_DEV_ID_82575EB_PT:
	case E1000_DEV_ID_82575EB_PF:
	case E1000_DEV_ID_82575GB_QP:
	case E1000_DEV_ID_82575GB_QP_PM:
	case E1000_DEV_ID_82576:
	case E1000_DEV_ID_82576_FIBER:
	case E1000_DEV_ID_82576_SERDES:
	case E1000_DEV_ID_82576_QUAD_COPPER:
	case E1000_DEV_ID_82576_QUAD_CU_ET2:
	case E1000_DEV_ID_82576_NS:
	case E1000_DEV_ID_82576_NS_SERDES:
	case E1000_DEV_ID_82576_SERDES_QUAD:
		hw->mac_type = em_82575;
		hw->initialize_hw_bits_disable = 1;
		break;
	case E1000_DEV_ID_82580_COPPER:
	case E1000_DEV_ID_82580_FIBER:
	case E1000_DEV_ID_82580_QUAD_FIBER:
	case E1000_DEV_ID_82580_SERDES:
	case E1000_DEV_ID_82580_SGMII:
	case E1000_DEV_ID_82580_COPPER_DUAL:
	case E1000_DEV_ID_DH89XXCC_SGMII:
	case E1000_DEV_ID_DH89XXCC_SERDES:
	case E1000_DEV_ID_DH89XXCC_BACKPLANE:
	case E1000_DEV_ID_DH89XXCC_SFP:
		hw->mac_type = em_82580;
		hw->initialize_hw_bits_disable = 1;
		break;
	case E1000_DEV_ID_I210_COPPER:
	case E1000_DEV_ID_I210_FIBER:
	case E1000_DEV_ID_I210_SERDES:
	case E1000_DEV_ID_I210_SGMII:
	case E1000_DEV_ID_I210_COPPER_FLASHLESS:
	case E1000_DEV_ID_I210_SERDES_FLASHLESS:
	case E1000_DEV_ID_I211_COPPER:
		hw->mac_type = em_i210;
		hw->initialize_hw_bits_disable = 1;
		hw->eee_enable = 1;
		break;
	case E1000_DEV_ID_I350_COPPER:
	case E1000_DEV_ID_I350_FIBER:
	case E1000_DEV_ID_I350_SERDES:
	case E1000_DEV_ID_I350_SGMII:
	case E1000_DEV_ID_I350_DA4:
	case E1000_DEV_ID_I354_BACKPLANE_1GBPS:
	case E1000_DEV_ID_I354_SGMII:
	case E1000_DEV_ID_I354_BACKPLANE_2_5GBPS:
		hw->mac_type = em_i350;
		hw->initialize_hw_bits_disable = 1;
		hw->eee_enable = 1;
		break;
	case E1000_DEV_ID_80003ES2LAN_COPPER_SPT:
	case E1000_DEV_ID_80003ES2LAN_SERDES_SPT:
	case E1000_DEV_ID_80003ES2LAN_COPPER_DPT:
	case E1000_DEV_ID_80003ES2LAN_SERDES_DPT:
		hw->mac_type = em_80003es2lan;
		break;
	case E1000_DEV_ID_ICH8_IFE:
	case E1000_DEV_ID_ICH8_IFE_G:
	case E1000_DEV_ID_ICH8_IFE_GT:
	case E1000_DEV_ID_ICH8_IGP_AMT:
	case E1000_DEV_ID_ICH8_IGP_C:
	case E1000_DEV_ID_ICH8_IGP_M:
	case E1000_DEV_ID_ICH8_IGP_M_AMT:
	case E1000_DEV_ID_ICH8_82567V_3:
		hw->mac_type = em_ich8lan;
		break;
	case E1000_DEV_ID_ICH9_BM:
	case E1000_DEV_ID_ICH9_IFE:
	case E1000_DEV_ID_ICH9_IFE_G:
	case E1000_DEV_ID_ICH9_IFE_GT:
	case E1000_DEV_ID_ICH9_IGP_AMT:
	case E1000_DEV_ID_ICH9_IGP_C:
	case E1000_DEV_ID_ICH9_IGP_M:
	case E1000_DEV_ID_ICH9_IGP_M_AMT:
	case E1000_DEV_ID_ICH9_IGP_M_V:
	case E1000_DEV_ID_ICH10_R_BM_LF:
	case E1000_DEV_ID_ICH10_R_BM_LM:
	case E1000_DEV_ID_ICH10_R_BM_V:
		hw->mac_type = em_ich9lan;
		break;
	case E1000_DEV_ID_ICH10_D_BM_LF:
	case E1000_DEV_ID_ICH10_D_BM_LM:
		hw->mac_type = em_ich10lan;
		break;
	case E1000_DEV_ID_PCH_M_HV_LC:
	case E1000_DEV_ID_PCH_M_HV_LM:
	case E1000_DEV_ID_PCH_D_HV_DC:
	case E1000_DEV_ID_PCH_D_HV_DM:
		hw->mac_type = em_pchlan;
		hw->eee_enable = 1;
		break;
	case E1000_DEV_ID_PCH2_LV_LM:
	case E1000_DEV_ID_PCH2_LV_V:
		hw->mac_type = em_pch2lan;
		break;
	case E1000_DEV_ID_PCH_LPT_I217_LM:
	case E1000_DEV_ID_PCH_LPT_I217_V:
	case E1000_DEV_ID_PCH_LPTLP_I218_LM:
	case E1000_DEV_ID_PCH_LPTLP_I218_V:
	case E1000_DEV_ID_PCH_I218_LM2:
	case E1000_DEV_ID_PCH_I218_V2:
	case E1000_DEV_ID_PCH_I218_LM3:
	case E1000_DEV_ID_PCH_I218_V3:
		hw->mac_type = em_pch_lpt;
		break;
	case E1000_DEV_ID_PCH_SPT_I219_LM:
	case E1000_DEV_ID_PCH_SPT_I219_V:
	case E1000_DEV_ID_PCH_SPT_I219_LM2:
	case E1000_DEV_ID_PCH_SPT_I219_V2:
	case E1000_DEV_ID_PCH_LBG_I219_LM3:
	case E1000_DEV_ID_PCH_SPT_I219_LM4:
	case E1000_DEV_ID_PCH_SPT_I219_V4:
	case E1000_DEV_ID_PCH_SPT_I219_LM5:
	case E1000_DEV_ID_PCH_SPT_I219_V5:
		hw->mac_type = em_pch_spt;
		break;
	case E1000_DEV_ID_EP80579_LAN_1:
		hw->mac_type = em_icp_xxxx;
		hw->icp_xxxx_port_num = 0;
		break;
	case E1000_DEV_ID_EP80579_LAN_2:
	case E1000_DEV_ID_EP80579_LAN_4:
		hw->mac_type = em_icp_xxxx;
		hw->icp_xxxx_port_num = 1;
		break;
	case E1000_DEV_ID_EP80579_LAN_3:
	case E1000_DEV_ID_EP80579_LAN_5:
		hw->mac_type = em_icp_xxxx;
		hw->icp_xxxx_port_num = 2;
		break;
	case E1000_DEV_ID_EP80579_LAN_6:
		hw->mac_type = em_icp_xxxx;
		hw->icp_xxxx_port_num = 3;
		break;
	default:
		/* Should never have loaded on this device */
		return -E1000_ERR_MAC_TYPE;
	}

	switch (hw->mac_type) {
	case em_ich8lan:
	case em_ich9lan:
	case em_ich10lan:
	case em_pchlan:
	case em_pch2lan:
	case em_pch_lpt:
	case em_pch_spt:
		hw->swfwhw_semaphore_present = TRUE;
		hw->asf_firmware_present = TRUE;
		break;
	case em_80003es2lan:
	case em_82575:
	case em_82580:
	case em_i210:
	case em_i350:
		hw->swfw_sync_present = TRUE;
		/* FALLTHROUGH */
	case em_82571:
	case em_82572:
	case em_82573:
	case em_82574:
		hw->eeprom_semaphore_present = TRUE;
		/* FALLTHROUGH */
	case em_82541:
	case em_82547:
	case em_82541_rev_2:
	case em_82547_rev_2:
		hw->asf_firmware_present = TRUE;
		break;
	default:
		break;
	}

	return E1000_SUCCESS;
}
/*****************************************************************************
 * Set media type and TBI compatibility.
 *
 * hw - Struct containing variables accessed by shared code
 * **************************************************************************/
void
em_set_media_type(struct em_hw *hw)
{
	uint32_t status, ctrl_ext;
	DEBUGFUNC("em_set_media_type");

	if (hw->mac_type != em_82543) {
		/* tbi_compatibility is only valid on 82543 */
		hw->tbi_compatibility_en = FALSE;
	}

	if (hw->mac_type == em_82575 || hw->mac_type == em_82580 ||
	    hw->mac_type == em_i210 || hw->mac_type == em_i350) {
		hw->media_type = em_media_type_copper;
	
		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
		switch (ctrl_ext & E1000_CTRL_EXT_LINK_MODE_MASK) {
		case E1000_CTRL_EXT_LINK_MODE_SGMII:
			ctrl_ext |= E1000_CTRL_I2C_ENA;
			break;
		case E1000_CTRL_EXT_LINK_MODE_1000BASE_KX:
		case E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES:
			hw->media_type = em_media_type_internal_serdes;
			ctrl_ext |= E1000_CTRL_I2C_ENA;
			break;
		default:
			ctrl_ext &= ~E1000_CTRL_I2C_ENA;
			break;
		}
		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
		return;
	}

	switch (hw->device_id) {
	case E1000_DEV_ID_82545GM_SERDES:
	case E1000_DEV_ID_82546GB_SERDES:
	case E1000_DEV_ID_82571EB_SERDES:
	case E1000_DEV_ID_82571EB_SERDES_DUAL:
	case E1000_DEV_ID_82571EB_SERDES_QUAD:
	case E1000_DEV_ID_82572EI_SERDES:
	case E1000_DEV_ID_80003ES2LAN_SERDES_DPT:
		hw->media_type = em_media_type_internal_serdes;
		break;
	case E1000_DEV_ID_EP80579_LAN_1:
	case E1000_DEV_ID_EP80579_LAN_2:
	case E1000_DEV_ID_EP80579_LAN_3:
	case E1000_DEV_ID_EP80579_LAN_4:
	case E1000_DEV_ID_EP80579_LAN_5:
	case E1000_DEV_ID_EP80579_LAN_6:
		hw->media_type = em_media_type_copper;
		break;
	default:
		switch (hw->mac_type) {
		case em_82542_rev2_0:
		case em_82542_rev2_1:
			hw->media_type = em_media_type_fiber;
			break;
		case em_ich8lan:
		case em_ich9lan:
		case em_ich10lan:
		case em_pchlan:
		case em_pch2lan:
		case em_pch_lpt:
		case em_pch_spt:
		case em_82573:
		case em_82574:
			/*
			 * The STATUS_TBIMODE bit is reserved or reused for
			 * the this device.
			 */
			hw->media_type = em_media_type_copper;
			break;
		default:
			status = E1000_READ_REG(hw, STATUS);
			if (status & E1000_STATUS_TBIMODE) {
				hw->media_type = em_media_type_fiber;
				/* tbi_compatibility not valid on fiber */
				hw->tbi_compatibility_en = FALSE;
			} else {
				hw->media_type = em_media_type_copper;
			}
			break;
		}
	}
}
/******************************************************************************
 * Reset the transmit and receive units; mask and clear all interrupts.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_reset_hw(struct em_hw *hw)
{
	uint32_t ctrl;
	uint32_t ctrl_ext;
	uint32_t icr;
	uint32_t manc;
	uint32_t led_ctrl;
	uint32_t timeout;
	uint32_t extcnf_ctrl;
	int32_t  ret_val;
	DEBUGFUNC("em_reset_hw");

	/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
	if (hw->mac_type == em_82542_rev2_0) {
		DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
		em_pci_clear_mwi(hw);
	}
	if (hw->bus_type == em_bus_type_pci_express) {
		/*
		 * Prevent the PCI-E bus from sticking if there is no TLP
		 * connection on the last TLP read/write transaction when MAC
		 * is reset.
		 */
		if (em_disable_pciex_master(hw) != E1000_SUCCESS) {
			DEBUGOUT("PCI-E Master disable polling has failed.\n");
		}
	}

        /* Set the completion timeout for 82575 chips */
        if (hw->mac_type == em_82575 || hw->mac_type == em_82580 ||
	    hw->mac_type == em_i210 || hw->mac_type == em_i350) {
                ret_val = em_set_pciex_completion_timeout(hw);
                if (ret_val) {              
                        DEBUGOUT("PCI-E Set completion timeout has failed.\n");
                }
        }

	/* Clear interrupt mask to stop board from generating interrupts */
	DEBUGOUT("Masking off all interrupts\n");
	E1000_WRITE_REG(hw, IMC, 0xffffffff);
	/*
	 * Disable the Transmit and Receive units.  Then delay to allow any
	 * pending transactions to complete before we hit the MAC with the
	 * global reset.
	 */
	E1000_WRITE_REG(hw, RCTL, 0);
	E1000_WRITE_REG(hw, TCTL, E1000_TCTL_PSP);
	E1000_WRITE_FLUSH(hw);
	/*
	 * The tbi_compatibility_on Flag must be cleared when Rctl is
	 * cleared.
	 */
	hw->tbi_compatibility_on = FALSE;
	/*
	 * Delay to allow any outstanding PCI transactions to complete before
	 * resetting the device
	 */
	msec_delay(10);

	ctrl = E1000_READ_REG(hw, CTRL);

	/* Must reset the PHY before resetting the MAC */
	if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
		E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
		msec_delay(5);
	}
	/*
	 * Must acquire the MDIO ownership before MAC reset. Ownership
	 * defaults to firmware after a reset.
	 */
	if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
		timeout = 10;

		extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);
		extcnf_ctrl |= E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP;

		do {
			E1000_WRITE_REG(hw, EXTCNF_CTRL, extcnf_ctrl);
			extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);

			if (extcnf_ctrl & E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP)
				break;
			else
				extcnf_ctrl |= 
				    E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP;

			msec_delay(2);
			timeout--;
		} while (timeout);
	}
	/* Workaround for ICH8 bit corruption issue in FIFO memory */
	if (hw->mac_type == em_ich8lan) {
		/* Set Tx and Rx buffer allocation to 8k apiece. */
		E1000_WRITE_REG(hw, PBA, E1000_PBA_8K);
		/* Set Packet Buffer Size to 16k. */
		E1000_WRITE_REG(hw, PBS, E1000_PBS_16K);
	}
	/*
	 * Issue a global reset to the MAC.  This will reset the chip's
	 * transmit, receive, DMA, and link units.  It will not effect the
	 * current PCI configuration.  The global reset bit is self-
	 * clearing, and should clear within a microsecond.
	 */
	DEBUGOUT("Issuing a global reset to MAC\n");

	switch (hw->mac_type) {
	case em_82544:
	case em_82540:
	case em_82545:
	case em_82546:
	case em_82541:
	case em_82541_rev_2:
		/*
		 * These controllers can't ack the 64-bit write when issuing
		 * the reset, so use IO-mapping as a workaround to issue the
		 * reset
		 */
		E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
		break;
	case em_82545_rev_3:
	case em_82546_rev_3:
		/* Reset is performed on a shadow of the control register */
		E1000_WRITE_REG(hw, CTRL_DUP, (ctrl | E1000_CTRL_RST));
		break;
	case em_ich8lan:
	case em_ich9lan:
	case em_ich10lan:
	case em_pchlan:
	case em_pch2lan:
	case em_pch_lpt:
	case em_pch_spt:
		if (!hw->phy_reset_disable &&
		    em_check_phy_reset_block(hw) == E1000_SUCCESS) {
			/*
			 * PHY HW reset requires MAC CORE reset at the same
			 * time to make sure the interface between MAC and
			 * the external PHY is reset.
			 */
			ctrl |= E1000_CTRL_PHY_RST;
			/*
			 * Gate automatic PHY configuration by hardware on
			 * non-managed 82579
			 */
			if ((hw->mac_type == em_pch2lan) &&
				!(E1000_READ_REG(hw, FWSM) & E1000_FWSM_FW_VALID)) {
				em_gate_hw_phy_config_ich8lan(hw, TRUE);
			}
		}
		em_get_software_flag(hw);
		E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
		msec_delay(5);

		/* Ungate automatic PHY configuration on non-managed 82579 */
		if (hw->mac_type == em_pch2lan && !hw->phy_reset_disable &&
		    !(E1000_READ_REG(hw, FWSM) & E1000_FWSM_FW_VALID)) {
			msec_delay(10);
			em_gate_hw_phy_config_ich8lan(hw, FALSE);
		}
 		break;
	default:
		E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
		break;
	}

	if (em_check_phy_reset_block(hw) == E1000_SUCCESS) {
		if (hw->mac_type == em_pchlan) {
			ret_val = em_hv_phy_workarounds_ich8lan(hw);
			if (ret_val)
				return ret_val;
		}
		else if (hw->mac_type == em_pch2lan) {
			ret_val = em_lv_phy_workarounds_ich8lan(hw);
			if (ret_val)
				return ret_val;
		}
	}

	/*
	 * After MAC reset, force reload of EEPROM to restore power-on
	 * settings to device.  Later controllers reload the EEPROM
	 * automatically, so just wait for reload to complete.
	 */
	switch (hw->mac_type) {
	case em_82542_rev2_0:
	case em_82542_rev2_1:
	case em_82543:
	case em_82544:
		/* Wait for reset to complete */
		usec_delay(10);
		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
		ctrl_ext |= E1000_CTRL_EXT_EE_RST;
		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
		E1000_WRITE_FLUSH(hw);
		/* Wait for EEPROM reload */
		msec_delay(2);
		break;
	case em_82541:
	case em_82541_rev_2:
	case em_82547:
	case em_82547_rev_2:
		/* Wait for EEPROM reload */
		msec_delay(20);
		break;
	case em_82573:
	case em_82574:
		if (em_is_onboard_nvm_eeprom(hw) == FALSE) {
			usec_delay(10);
			ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
			ctrl_ext |= E1000_CTRL_EXT_EE_RST;
			E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
			E1000_WRITE_FLUSH(hw);
		}
		/* FALLTHROUGH */

		/* Auto read done will delay 5ms or poll based on mac type */
		ret_val = em_get_auto_rd_done(hw);
		if (ret_val)
			return ret_val;
		break;
	default:
		/* Wait for EEPROM reload (it happens automatically) */
		msec_delay(5);
		break;
	}

	/* Disable HW ARPs on ASF enabled adapters */
	if (hw->mac_type >= em_82540 && hw->mac_type <= em_82547_rev_2 &&
	    hw->mac_type != em_icp_xxxx) {
		manc = E1000_READ_REG(hw, MANC);
		manc &= ~(E1000_MANC_ARP_EN);
		E1000_WRITE_REG(hw, MANC, manc);
	}
	if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
		em_phy_init_script(hw);

		/* Configure activity LED after PHY reset */
		led_ctrl = E1000_READ_REG(hw, LEDCTL);
		led_ctrl &= IGP_ACTIVITY_LED_MASK;
		led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
		E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
	}

	/*
	 * For PCH, this write will make sure that any noise
	 * will be detected as a CRC error and be dropped rather than show up
	 * as a bad packet to the DMA engine.
	 */
	if (hw->mac_type == em_pchlan)
		E1000_WRITE_REG(hw, CRC_OFFSET, 0x65656565);
	
	/* Clear interrupt mask to stop board from generating interrupts */
	DEBUGOUT("Masking off all interrupts\n");
	E1000_WRITE_REG(hw, IMC, 0xffffffff);

	/* Clear any pending interrupt events. */
	icr = E1000_READ_REG(hw, ICR);

	/* If MWI was previously enabled, reenable it. */
	if (hw->mac_type == em_82542_rev2_0) {
		if (hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
			em_pci_set_mwi(hw);
	}
	if (IS_ICH8(hw->mac_type)) {
		uint32_t kab = E1000_READ_REG(hw, KABGTXD);
		kab |= E1000_KABGTXD_BGSQLBIAS;
		E1000_WRITE_REG(hw, KABGTXD, kab);
	}

	if (hw->mac_type == em_82580 || hw->mac_type == em_i350) {
		uint32_t mdicnfg;
		uint16_t nvm_data;

		/* clear global device reset status bit */
		EM_WRITE_REG(hw, E1000_STATUS, E1000_STATUS_DEV_RST_SET);

		em_read_eeprom(hw, EEPROM_INIT_CONTROL3_PORT_A +
		    NVM_82580_LAN_FUNC_OFFSET(hw->bus_func), 1,
		    &nvm_data);

		mdicnfg = EM_READ_REG(hw, E1000_MDICNFG);
		if (nvm_data & NVM_WORD24_EXT_MDIO)
			mdicnfg |= E1000_MDICNFG_EXT_MDIO;
		if (nvm_data & NVM_WORD24_COM_MDIO)
			mdicnfg |= E1000_MDICNFG_COM_MDIO;
		EM_WRITE_REG(hw, E1000_MDICNFG, mdicnfg);
	}

	if (hw->mac_type == em_i210 || hw->mac_type == em_i350)
		em_set_eee_i350(hw);

	return E1000_SUCCESS;
}

/******************************************************************************
 *
 * Initialize a number of hardware-dependent bits
 *
 * hw: Struct containing variables accessed by shared code
 *
 *****************************************************************************/
STATIC void
em_initialize_hardware_bits(struct em_hw *hw)
{
	DEBUGFUNC("em_initialize_hardware_bits");

	if ((hw->mac_type >= em_82571) && (!hw->initialize_hw_bits_disable)) {
		/* Settings common to all silicon */
		uint32_t reg_ctrl, reg_ctrl_ext;
		uint32_t reg_tarc0, reg_tarc1;
		uint32_t reg_tctl;
		uint32_t reg_txdctl, reg_txdctl1;
		reg_tarc0 = E1000_READ_REG(hw, TARC0);
		reg_tarc0 &= ~0x78000000;	/* Clear bits 30, 29, 28, and
						 * 27 */

		reg_txdctl = E1000_READ_REG(hw, TXDCTL);
		reg_txdctl |= E1000_TXDCTL_COUNT_DESC;	/* Set bit 22 */
		E1000_WRITE_REG(hw, TXDCTL, reg_txdctl);

		reg_txdctl1 = E1000_READ_REG(hw, TXDCTL1);
		reg_txdctl1 |= E1000_TXDCTL_COUNT_DESC;	/* Set bit 22 */
		E1000_WRITE_REG(hw, TXDCTL1, reg_txdctl1);

		switch (hw->mac_type) {
		case em_82571:
		case em_82572:
			reg_tarc1 = E1000_READ_REG(hw, TARC1);
			reg_tctl = E1000_READ_REG(hw, TCTL);

			/* Set the phy Tx compatible mode bits */
			reg_tarc1 &= ~0x60000000; /* Clear bits 30 and 29 */

			reg_tarc0 |= 0x07800000; /* Set TARC0 bits 23-26 */
			reg_tarc1 |= 0x07000000; /* Set TARC1 bits 24-26 */

			if (reg_tctl & E1000_TCTL_MULR)
				/* Clear bit 28 if MULR is 1b */ 
				reg_tarc1 &= ~0x10000000;
			else
				/* Set bit 28 if MULR is 0b */
				reg_tarc1 |= 0x10000000;

			E1000_WRITE_REG(hw, TARC1, reg_tarc1);
			break;
		case em_82573:
		case em_82574:
			reg_ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
			reg_ctrl = E1000_READ_REG(hw, CTRL);

			reg_ctrl_ext &= ~0x00800000;	/* Clear bit 23 */
			reg_ctrl_ext |= 0x00400000;	/* Set bit 22 */
			reg_ctrl &= ~0x20000000;	/* Clear bit 29 */

			E1000_WRITE_REG(hw, CTRL_EXT, reg_ctrl_ext);
			E1000_WRITE_REG(hw, CTRL, reg_ctrl);
			break;
		case em_80003es2lan:
			if ((hw->media_type == em_media_type_fiber) ||
			(hw->media_type == em_media_type_internal_serdes)) {
				/* Clear bit 20 */
				reg_tarc0 &= ~0x00100000;
			}
			reg_tctl = E1000_READ_REG(hw, TCTL);
			reg_tarc1 = E1000_READ_REG(hw, TARC1);
			if (reg_tctl & E1000_TCTL_MULR)
				/* Clear bit 28 if MULR is 1b */
				reg_tarc1 &= ~0x10000000;
			else
				/* Set bit 28 if MULR is 0b */
				reg_tarc1 |= 0x10000000;

			E1000_WRITE_REG(hw, TARC1, reg_tarc1);
			break;
		case em_ich8lan:
		case em_ich9lan:
		case em_ich10lan:
		case em_pchlan:
		case em_pch2lan:
		case em_pch_lpt:
		case em_pch_spt:
			if (hw->mac_type == em_ich8lan)
				/* Set TARC0 bits 29 and 28 */
				reg_tarc0 |= 0x30000000;

			reg_ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
			reg_ctrl_ext |= 0x00400000;	/* Set bit 22 */
			/* Enable PHY low-power state when MAC is at D3 w/o WoL */
			if (hw->mac_type >= em_pchlan)
				reg_ctrl_ext |= E1000_CTRL_EXT_PHYPDEN;
			E1000_WRITE_REG(hw, CTRL_EXT, reg_ctrl_ext);

			reg_tarc0 |= 0x0d800000;	/* Set TARC0 bits 23,
							 * 24, 26, 27 */

			reg_tarc1 = E1000_READ_REG(hw, TARC1);
			reg_tctl = E1000_READ_REG(hw, TCTL);

			if (reg_tctl & E1000_TCTL_MULR)
				/* Clear bit 28 if MULR is 1b */
				reg_tarc1 &= ~0x10000000;
			else
				/* Set bit 28 if MULR is 0b */
				reg_tarc1 |= 0x10000000;

			reg_tarc1 |= 0x45000000;	/* Set bit 24, 26 and 
							 * 30 */

			E1000_WRITE_REG(hw, TARC1, reg_tarc1);
			break;
		default:
			break;
		}

		E1000_WRITE_REG(hw, TARC0, reg_tarc0);
	}
}

/**
 *  e1000_toggle_lanphypc_pch_lpt - toggle the LANPHYPC pin value
 *  @@hw: pointer to the HW structure
 *
 *  Toggling the LANPHYPC pin value fully power-cycles the PHY and is
 *  used to reset the PHY to a quiescent state when necessary.
 **/
static void
em_toggle_lanphypc_pch_lpt(struct em_hw *hw)
{
	uint32_t mac_reg;

	DEBUGFUNC("e1000_toggle_lanphypc_pch_lpt");

	/* Set Phy Config Counter to 50msec */
	mac_reg = E1000_READ_REG(hw, FEXTNVM3);
	mac_reg &= ~E1000_FEXTNVM3_PHY_CFG_COUNTER_MASK;
	mac_reg |= E1000_FEXTNVM3_PHY_CFG_COUNTER_50MSEC;
	E1000_WRITE_REG(hw, FEXTNVM3, mac_reg);

	/* Toggle LANPHYPC Value bit */
	mac_reg = E1000_READ_REG(hw, CTRL);
	mac_reg |= E1000_CTRL_LANPHYPC_OVERRIDE;
	mac_reg &= ~E1000_CTRL_LANPHYPC_VALUE;
	E1000_WRITE_REG(hw, CTRL, mac_reg);
	E1000_WRITE_FLUSH(hw);
	msec_delay(1);
	mac_reg &= ~E1000_CTRL_LANPHYPC_OVERRIDE;
	E1000_WRITE_REG(hw, CTRL, mac_reg);
	E1000_WRITE_FLUSH(hw);

	if (hw->mac_type < em_pch_lpt) {
		msec_delay(50);
	} else {
		uint16_t count = 20;

		do {
			msec_delay(5);
		} while (!(E1000_READ_REG(hw, CTRL_EXT) &
		    E1000_CTRL_EXT_LPCD) && count--);

		msec_delay(30);
	}
}

/**
 *  em_disable_ulp_lpt_lp - unconfigure Ultra Low Power mode for LynxPoint-LP
 *  @@hw: pointer to the HW structure
 *  @@force: boolean indicating whether or not to force disabling ULP
 *
 *  Un-configure ULP mode when link is up, the system is transitioned from
 *  Sx or the driver is unloaded.  If on a Manageability Engine (ME) enabled
 *  system, poll for an indication from ME that ULP has been un-configured.
 *  If not on an ME enabled system, un-configure the ULP mode by software.
 *
 *  During nominal operation, this function is called when link is acquired
 *  to disable ULP mode (force=FALSE); otherwise, for example when unloading
 *  the driver or during Sx->S0 transitions, this is called with force=TRUE
 *  to forcibly disable ULP.
 */
static int
em_disable_ulp_lpt_lp(struct em_hw *hw, bool force)
{
	int ret_val = E1000_SUCCESS;
	uint32_t mac_reg;
	uint16_t phy_reg;
	int i = 0;

	if ((hw->mac_type < em_pch_lpt) ||
	    (hw->device_id == E1000_DEV_ID_PCH_LPT_I217_LM) ||
	    (hw->device_id == E1000_DEV_ID_PCH_LPT_I217_V) ||
	    (hw->device_id == E1000_DEV_ID_PCH_I218_LM2) ||
	    (hw->device_id == E1000_DEV_ID_PCH_I218_V2))
		return 0;

	if (E1000_READ_REG(hw, FWSM) & E1000_FWSM_FW_VALID) {
		if (force) {
			/* Request ME un-configure ULP mode in the PHY */
			mac_reg = E1000_READ_REG(hw, H2ME);
			mac_reg &= ~E1000_H2ME_ULP;
			mac_reg |= E1000_H2ME_ENFORCE_SETTINGS;
			E1000_WRITE_REG(hw, H2ME, mac_reg);
		}

		/* Poll up to 300msec for ME to clear ULP_CFG_DONE. */
		while (E1000_READ_REG(hw, FWSM) & E1000_FWSM_ULP_CFG_DONE) {
			if (i++ == 30) {
				ret_val = -E1000_ERR_PHY;
				goto out;
			}

			msec_delay(10);
		}
		DEBUGOUT1("ULP_CONFIG_DONE cleared after %dmsec\n", i * 10);

		if (force) {
			mac_reg = E1000_READ_REG(hw, H2ME);
			mac_reg &= ~E1000_H2ME_ENFORCE_SETTINGS;
			E1000_WRITE_REG(hw, H2ME, mac_reg);
		} else {
			/* Clear H2ME.ULP after ME ULP configuration */
			mac_reg = E1000_READ_REG(hw, H2ME);
			mac_reg &= ~E1000_H2ME_ULP;
			E1000_WRITE_REG(hw, H2ME, mac_reg);
		}

		goto out;
	}

	ret_val = em_get_software_flag(hw);
	if (ret_val)
		goto out;

	if (force)
		/* Toggle LANPHYPC Value bit */
		em_toggle_lanphypc_pch_lpt(hw);

	/* Unforce SMBus mode in PHY */
	ret_val = em_read_phy_reg(hw, CV_SMB_CTRL, &phy_reg);
	if (ret_val) {
		/* The MAC might be in PCIe mode, so temporarily force to
		 * SMBus mode in order to access the PHY.
		 */
		mac_reg = E1000_READ_REG(hw, CTRL_EXT);
		mac_reg |= E1000_CTRL_EXT_FORCE_SMBUS;
		E1000_WRITE_REG(hw, CTRL_EXT, mac_reg);

		msec_delay(50);

		ret_val = em_read_phy_reg(hw, CV_SMB_CTRL, &phy_reg);
		if (ret_val)
			goto release;
	}
	phy_reg &= ~CV_SMB_CTRL_FORCE_SMBUS;
	em_write_phy_reg(hw, CV_SMB_CTRL, phy_reg);

	/* Unforce SMBus mode in MAC */
	mac_reg = E1000_READ_REG(hw, CTRL_EXT);
	mac_reg &= ~E1000_CTRL_EXT_FORCE_SMBUS;
	E1000_WRITE_REG(hw, CTRL_EXT, mac_reg);

	/* When ULP mode was previously entered, K1 was disabled by the
	 * hardware.  Re-Enable K1 in the PHY when exiting ULP.
	 */
	ret_val = em_read_phy_reg(hw, HV_PM_CTRL, &phy_reg);
	if (ret_val)
		goto release;
	phy_reg |= HV_PM_CTRL_K1_ENABLE;
	em_write_phy_reg(hw, HV_PM_CTRL, phy_reg);

	/* Clear ULP enabled configuration */
	ret_val = em_read_phy_reg(hw, I218_ULP_CONFIG1, &phy_reg);
	if (ret_val)
		goto release;
	phy_reg &= ~(I218_ULP_CONFIG1_IND |
		     I218_ULP_CONFIG1_STICKY_ULP |
		     I218_ULP_CONFIG1_RESET_TO_SMBUS |
		     I218_ULP_CONFIG1_WOL_HOST |
		     I218_ULP_CONFIG1_INBAND_EXIT |
		     I218_ULP_CONFIG1_EN_ULP_LANPHYPC |
		     I218_ULP_CONFIG1_DIS_CLR_STICKY_ON_PERST |
		     I218_ULP_CONFIG1_DISABLE_SMB_PERST);
	em_write_phy_reg(hw, I218_ULP_CONFIG1, phy_reg);

	/* Commit ULP changes by starting auto ULP configuration */
	phy_reg |= I218_ULP_CONFIG1_START;
	em_write_phy_reg(hw, I218_ULP_CONFIG1, phy_reg);

	/* Clear Disable SMBus Release on PERST# in MAC */
	mac_reg = E1000_READ_REG(hw, FEXTNVM7);
	mac_reg &= ~E1000_FEXTNVM7_DISABLE_SMB_PERST;
	E1000_WRITE_REG(hw, FEXTNVM7, mac_reg);

release:
	em_release_software_flag(hw);
	if (force) {
		em_phy_reset(hw);
		msec_delay(50);
	}
out:
	if (ret_val)
		DEBUGOUT1("Error in ULP disable flow: %d\n", ret_val);

	return ret_val;
}

/******************************************************************************
 * Performs basic configuration of the adapter.
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Assumes that the controller has previously been reset and is in a
 * post-reset uninitialized state. Initializes the receive address registers,
 * multicast table, and VLAN filter table. Calls routines to setup link
 * configuration and flow control settings. Clears all on-chip counters. Leaves
 * the transmit and receive units disabled and uninitialized.
 *****************************************************************************/
int32_t
em_init_hw(struct em_hw *hw)
{
	uint32_t ctrl;
	uint32_t i;
	int32_t  ret_val;
	uint16_t pcix_cmd_word;
	uint16_t pcix_stat_hi_word;
	uint16_t cmd_mmrbc;
	uint16_t stat_mmrbc;
	uint32_t mta_size;
	uint32_t reg_data;
	uint32_t ctrl_ext;
	uint32_t snoop;
	uint32_t fwsm;
	DEBUGFUNC("em_init_hw");

	/* force full DMA clock frequency for ICH8 */
	if (hw->mac_type == em_ich8lan) {
		reg_data = E1000_READ_REG(hw, STATUS);
		reg_data &= ~0x80000000;
		E1000_WRITE_REG(hw, STATUS, reg_data);
	}

	if (hw->mac_type == em_pchlan ||
		hw->mac_type == em_pch2lan ||
		hw->mac_type == em_pch_lpt ||
		hw->mac_type == em_pch_spt) {
		/*
		 * The MAC-PHY interconnect may still be in SMBus mode
		 * after Sx->S0.  Toggle the LANPHYPC Value bit to force
		 * the interconnect to PCIe mode, but only if there is no
		 * firmware present otherwise firmware will have done it.
		 */
		fwsm = E1000_READ_REG(hw, FWSM);
		if ((fwsm & E1000_FWSM_FW_VALID) == 0) {
			ctrl = E1000_READ_REG(hw, CTRL);
			ctrl |=  E1000_CTRL_LANPHYPC_OVERRIDE;
			ctrl &= ~E1000_CTRL_LANPHYPC_VALUE;
			E1000_WRITE_REG(hw, CTRL, ctrl);
			usec_delay(10);
			ctrl &= ~E1000_CTRL_LANPHYPC_OVERRIDE;
			E1000_WRITE_REG(hw, CTRL, ctrl);
			msec_delay(50);
		}

		/* Gate automatic PHY configuration on non-managed 82579 */
		if (hw->mac_type == em_pch2lan)
			em_gate_hw_phy_config_ich8lan(hw, TRUE);

		em_disable_ulp_lpt_lp(hw, TRUE);
		/*
		 * Reset the PHY before any acccess to it.  Doing so,
		 * ensures that the PHY is in a known good state before
		 * we read/write PHY registers.  The generic reset is
		 * sufficient here, because we haven't determined
		 * the PHY type yet.
		 */
		em_phy_reset(hw);

		/* Ungate automatic PHY configuration on non-managed 82579 */
		if (hw->mac_type == em_pch2lan &&
			(fwsm & E1000_FWSM_FW_VALID) == 0)
			em_gate_hw_phy_config_ich8lan(hw, FALSE);

		/* Set MDIO slow mode before any other MDIO access */
		ret_val = em_set_mdio_slow_mode_hv(hw);
		if (ret_val)
			return ret_val;
	}

	/* Initialize Identification LED */
	ret_val = em_id_led_init(hw);
	if (ret_val) {
		DEBUGOUT("Error Initializing Identification LED\n");
		return ret_val;
	}
	/* Set the media type and TBI compatibility */
	em_set_media_type(hw);

	/* Must be called after em_set_media_type because media_type is used */
	em_initialize_hardware_bits(hw);

	/* Disabling VLAN filtering. */
	DEBUGOUT("Initializing the IEEE VLAN\n");
	/* VET hardcoded to standard value and VFTA removed in ICH8/ICH9 LAN */
	if (!IS_ICH8(hw->mac_type)) {
		if (hw->mac_type < em_82545_rev_3)
			E1000_WRITE_REG(hw, VET, 0);
		if (hw->mac_type == em_i350)
			em_clear_vfta_i350(hw);
		else
			em_clear_vfta(hw);
	}
	/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
	if (hw->mac_type == em_82542_rev2_0) {
		DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
		em_pci_clear_mwi(hw);
		E1000_WRITE_REG(hw, RCTL, E1000_RCTL_RST);
		E1000_WRITE_FLUSH(hw);
		msec_delay(5);
	}
	/*
	 * Setup the receive address. This involves initializing all of the
	 * Receive Address Registers (RARs 0 - 15).
	 */
	em_init_rx_addrs(hw);

	/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI*/
	if (hw->mac_type == em_82542_rev2_0) {
		E1000_WRITE_REG(hw, RCTL, 0);
		E1000_WRITE_FLUSH(hw);
		msec_delay(1);
		if (hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
			em_pci_set_mwi(hw);
	}
	/* Zero out the Multicast HASH table */
	DEBUGOUT("Zeroing the MTA\n");
	mta_size = E1000_MC_TBL_SIZE;
	if (IS_ICH8(hw->mac_type))
		mta_size = E1000_MC_TBL_SIZE_ICH8LAN;
	for (i = 0; i < mta_size; i++) {
		E1000_WRITE_REG_ARRAY(hw, MTA, i, 0);
		/*
		 * use write flush to prevent Memory Write Block (MWB) from
		 * occuring when accessing our register space
		 */
		E1000_WRITE_FLUSH(hw);
	}
	/*
	 * Set the PCI priority bit correctly in the CTRL register.  This
	 * determines if the adapter gives priority to receives, or if it
	 * gives equal priority to transmits and receives.  Valid only on
	 * 82542 and 82543 silicon.
	 */
	if (hw->dma_fairness && hw->mac_type <= em_82543) {
		ctrl = E1000_READ_REG(hw, CTRL);
		E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PRIOR);
	}
	switch (hw->mac_type) {
	case em_82545_rev_3:
	case em_82546_rev_3:
		break;
	default:
		/*
		 * Workaround for PCI-X problem when BIOS sets MMRBC
		 * incorrectly.
		 */
		if (hw->bus_type == em_bus_type_pcix) {
			em_read_pci_cfg(hw, PCIX_COMMAND_REGISTER, 
			    &pcix_cmd_word);
			em_read_pci_cfg(hw, PCIX_STATUS_REGISTER_HI,
			    &pcix_stat_hi_word);
			cmd_mmrbc = (pcix_cmd_word & PCIX_COMMAND_MMRBC_MASK) 
			    >> PCIX_COMMAND_MMRBC_SHIFT;
			stat_mmrbc = (pcix_stat_hi_word & 
			    PCIX_STATUS_HI_MMRBC_MASK) >> 
			    PCIX_STATUS_HI_MMRBC_SHIFT;

			if (stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
				stat_mmrbc = PCIX_STATUS_HI_MMRBC_2K;
			if (cmd_mmrbc > stat_mmrbc) {
				pcix_cmd_word &= ~PCIX_COMMAND_MMRBC_MASK;
				pcix_cmd_word |= stat_mmrbc << 
				    PCIX_COMMAND_MMRBC_SHIFT;
				em_write_pci_cfg(hw, PCIX_COMMAND_REGISTER,
				    &pcix_cmd_word);
			}
		}
		break;
	}

	/* More time needed for PHY to initialize */
	if (IS_ICH8(hw->mac_type))
		msec_delay(15);

        /*
	 * The 82578 Rx buffer will stall if wakeup is enabled in host and
	 * the ME.  Reading the BM_WUC register will clear the host wakeup bit.
	 * Reset the phy after disabling host wakeup to reset the Rx buffer.
	 */
	if (hw->phy_type == em_phy_82578) {
		em_read_phy_reg(hw, PHY_REG(BM_WUC_PAGE, 1),
		    (uint16_t *)&reg_data);
		ret_val = em_phy_reset(hw);
		if (ret_val)
			return ret_val;
	}

	/* Call a subroutine to configure the link and setup flow control. */
	ret_val = em_setup_link(hw);

	/* Set the transmit descriptor write-back policy */
	if (hw->mac_type > em_82544) {
		ctrl = E1000_READ_REG(hw, TXDCTL);
		ctrl = (ctrl & ~E1000_TXDCTL_WTHRESH) | 
		    E1000_TXDCTL_FULL_TX_DESC_WB;
		E1000_WRITE_REG(hw, TXDCTL, ctrl);
	}
	if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
		em_enable_tx_pkt_filtering(hw);
	}
	switch (hw->mac_type) {
	default:
		break;
	case em_80003es2lan:
		/* Enable retransmit on late collisions */
		reg_data = E1000_READ_REG(hw, TCTL);
		reg_data |= E1000_TCTL_RTLC;
		E1000_WRITE_REG(hw, TCTL, reg_data);

		/* Configure Gigabit Carry Extend Padding */
		reg_data = E1000_READ_REG(hw, TCTL_EXT);
		reg_data &= ~E1000_TCTL_EXT_GCEX_MASK;
		reg_data |= DEFAULT_80003ES2LAN_TCTL_EXT_GCEX;
		E1000_WRITE_REG(hw, TCTL_EXT, reg_data);

		/* Configure Transmit Inter-Packet Gap */
		reg_data = E1000_READ_REG(hw, TIPG);
		reg_data &= ~E1000_TIPG_IPGT_MASK;
		reg_data |= DEFAULT_80003ES2LAN_TIPG_IPGT_1000;
		E1000_WRITE_REG(hw, TIPG, reg_data);

		reg_data = E1000_READ_REG_ARRAY(hw, FFLT, 0x0001);
		reg_data &= ~0x00100000;
		E1000_WRITE_REG_ARRAY(hw, FFLT, 0x0001, reg_data);
		/* FALLTHROUGH */
	case em_82571:
	case em_82572:
	case em_82575:
	case em_82580:
	case em_i210:
	case em_i350:
	case em_ich8lan:
	case em_ich9lan:
	case em_ich10lan:
	case em_pchlan:
	case em_pch2lan:
	case em_pch_lpt:
	case em_pch_spt:
		ctrl = E1000_READ_REG(hw, TXDCTL1);
		ctrl = (ctrl & ~E1000_TXDCTL_WTHRESH) | 
		    E1000_TXDCTL_FULL_TX_DESC_WB;
		E1000_WRITE_REG(hw, TXDCTL1, ctrl);
		break;
	}

	if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
		uint32_t gcr = E1000_READ_REG(hw, GCR);
		gcr |= E1000_GCR_L1_ACT_WITHOUT_L0S_RX;
		E1000_WRITE_REG(hw, GCR, gcr);
	}
	/*
	 * Clear all of the statistics registers (clear on read).  It is
	 * important that we do this after we have tried to establish link
	 * because the symbol error count will increment wildly if there is
	 * no link.
	 */
	em_clear_hw_cntrs(hw);
	/*
	 * ICH8 No-snoop bits are opposite polarity. Set to snoop by default
	 * after reset.
	 */
	if (IS_ICH8(hw->mac_type)) {
		if (hw->mac_type == em_ich8lan)
			snoop = PCI_EX_82566_SNOOP_ALL;
		else
			snoop = (u_int32_t) ~ (PCI_EX_NO_SNOOP_ALL);
			
		em_set_pci_ex_no_snoop(hw, snoop);
	}

	if (hw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER ||
	    hw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3) {
		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
		/*
		 * Relaxed ordering must be disabled to avoid a parity error
		 * crash in a PCI slot.
		 */
		ctrl_ext |= E1000_CTRL_EXT_RO_DIS;
		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
	}
	return ret_val;
}

/******************************************************************************
 * Adjust SERDES output amplitude based on EEPROM setting.
 *
 * hw - Struct containing variables accessed by shared code.
 *****************************************************************************/
static int32_t
em_adjust_serdes_amplitude(struct em_hw *hw)
{
	uint16_t eeprom_data;
	int32_t  ret_val;
	DEBUGFUNC("em_adjust_serdes_amplitude");

	if (hw->media_type != em_media_type_internal_serdes ||
	    hw->mac_type >= em_82575)
		return E1000_SUCCESS;

	switch (hw->mac_type) {
	case em_82545_rev_3:
	case em_82546_rev_3:
		break;
	default:
		return E1000_SUCCESS;
	}

	ret_val = em_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1, &eeprom_data);
	if (ret_val) {
		return ret_val;
	}
	if (eeprom_data != EEPROM_RESERVED_WORD) {
		/* Adjust SERDES output amplitude only. */
		eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK;
		ret_val = em_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL, 
		    eeprom_data);
		if (ret_val)
			return ret_val;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Configures flow control and link settings.
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Determines which flow control settings to use. Calls the appropriate media-
 * specific link configuration function. Configures the flow control settings.
 * Assuming the adapter has a valid link partner, a valid link should be
 * established. Assumes the hardware has previously been reset and the
 * transmitter and receiver are not enabled.
 *****************************************************************************/
int32_t
em_setup_link(struct em_hw *hw)
{
	uint32_t ctrl_ext;
	int32_t  ret_val;
	uint16_t eeprom_data;
	uint16_t eeprom_control2_reg_offset;
	DEBUGFUNC("em_setup_link");

	eeprom_control2_reg_offset =
	    (hw->mac_type != em_icp_xxxx)
	    ? EEPROM_INIT_CONTROL2_REG
	    : EEPROM_INIT_CONTROL3_ICP_xxxx(hw->icp_xxxx_port_num);
	/*
	 * In the case of the phy reset being blocked, we already have a
	 * link. We do not have to set it up again.
	 */
	if (em_check_phy_reset_block(hw))
		return E1000_SUCCESS;
	/*
	 * Read and store word 0x0F of the EEPROM. This word contains bits
	 * that determine the hardware's default PAUSE (flow control) mode, a
	 * bit that determines whether the HW defaults to enabling or
	 * disabling auto-negotiation, and the direction of the SW defined
	 * pins. If there is no SW over-ride of the flow control setting,
	 * then the variable hw->fc will be initialized based on a value in
	 * the EEPROM.
	 */
	if (hw->fc == E1000_FC_DEFAULT) {
		switch (hw->mac_type) {
		case em_ich8lan:
		case em_ich9lan:
		case em_ich10lan:
		case em_pchlan:
		case em_pch2lan:
		case em_pch_lpt:
		case em_pch_spt:
		case em_82573:
		case em_82574:
			hw->fc = E1000_FC_FULL;
			break;
		default:
			ret_val = em_read_eeprom(hw, 
			    eeprom_control2_reg_offset, 1, &eeprom_data);
			if (ret_val) {
				DEBUGOUT("EEPROM Read Error\n");
				return -E1000_ERR_EEPROM;
			}
			if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)
				hw->fc = E1000_FC_NONE;
			else if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) ==
			    EEPROM_WORD0F_ASM_DIR)
				hw->fc = E1000_FC_TX_PAUSE;
			else
				hw->fc = E1000_FC_FULL;
			break;
		}
	}
	/*
	 * We want to save off the original Flow Control configuration just
	 * in case we get disconnected and then reconnected into a different
	 * hub or switch with different Flow Control capabilities.
	 */
	if (hw->mac_type == em_82542_rev2_0)
		hw->fc &= (~E1000_FC_TX_PAUSE);

	if ((hw->mac_type < em_82543) && (hw->report_tx_early == 1))
		hw->fc &= (~E1000_FC_RX_PAUSE);

	hw->original_fc = hw->fc;

	DEBUGOUT1("After fix-ups FlowControl is now = %x\n", hw->fc);
	/*
	 * Take the 4 bits from EEPROM word 0x0F that determine the initial
	 * polarity value for the SW controlled pins, and setup the Extended
	 * Device Control reg with that info. This is needed because one of
	 * the SW controlled pins is used for signal detection.  So this
	 * should be done before em_setup_pcs_link() or em_phy_setup() is
	 * called.
	 */
	if (hw->mac_type == em_82543) {
		ret_val = em_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,
		    1, &eeprom_data);
		if (ret_val) {
			DEBUGOUT("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		ctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) <<
		    SWDPIO__EXT_SHIFT);
		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
	}
	/* Make sure we have a valid PHY */
	ret_val = em_detect_gig_phy(hw);
	if (ret_val) {
		DEBUGOUT("Error, did not detect valid phy.\n");
		if (hw->mac_type == em_icp_xxxx)
			return E1000_DEFER_INIT;
		else
			return ret_val;
	}
	DEBUGOUT1("Phy ID = %x \n", hw->phy_id);

	/* Call the necessary subroutine to configure the link. */
	switch (hw->media_type) {
	case em_media_type_copper:
	case em_media_type_oem:
		ret_val = em_setup_copper_link(hw);
		break;
	default:
		ret_val = em_setup_fiber_serdes_link(hw);
		break;
	}
	/*
	 * Initialize the flow control address, type, and PAUSE timer
	 * registers to their default values.  This is done even if flow
	 * control is disabled, because it does not hurt anything to
	 * initialize these registers.
	 */
	DEBUGOUT("Initializing the Flow Control address, type and timer regs\n"
	    );

	/*
         * FCAL/H and FCT are hardcoded to standard values in
         * em_ich8lan / em_ich9lan / em_ich10lan.
         */
	if (!IS_ICH8(hw->mac_type)) {
		E1000_WRITE_REG(hw, FCT, FLOW_CONTROL_TYPE);
		E1000_WRITE_REG(hw, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
		E1000_WRITE_REG(hw, FCAL, FLOW_CONTROL_ADDRESS_LOW);
	}
	E1000_WRITE_REG(hw, FCTTV, hw->fc_pause_time);

	if (hw->phy_type == em_phy_82577 ||
	    hw->phy_type == em_phy_82578 ||
	    hw->phy_type == em_phy_82579 ||
	    hw->phy_type == em_phy_i217) {
		E1000_WRITE_REG(hw, FCRTV_PCH, 0x1000);
		em_write_phy_reg(hw, PHY_REG(BM_PORT_CTRL_PAGE, 27),
		    hw->fc_pause_time);
	}

	/*
	 * Set the flow control receive threshold registers.  Normally, these
	 * registers will be set to a default threshold that may be adjusted
	 * later by the driver's runtime code.  However, if the ability to
	 * transmit pause frames in not enabled, then these registers will be
	 * set to 0.
	 */
	if (!(hw->fc & E1000_FC_TX_PAUSE)) {
		E1000_WRITE_REG(hw, FCRTL, 0);
		E1000_WRITE_REG(hw, FCRTH, 0);
	} else {
		/*
		 * We need to set up the Receive Threshold high and low water
		 * marks as well as (optionally) enabling the transmission of
		 * XON frames.
		 */
		if (hw->fc_send_xon) {
			E1000_WRITE_REG(hw, FCRTL, (hw->fc_low_water 
			    | E1000_FCRTL_XONE));
			E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
		} else {
			E1000_WRITE_REG(hw, FCRTL, hw->fc_low_water);
			E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
		}
	}
	return ret_val;
}

void
em_power_up_serdes_link_82575(struct em_hw *hw)
{
	uint32_t reg;

	/* Enable PCS to turn on link */
	reg = E1000_READ_REG(hw, PCS_CFG0);
	reg |= E1000_PCS_CFG_PCS_EN;
	E1000_WRITE_REG(hw, PCS_CFG0, reg);

	/* Power up the laser */
	reg = E1000_READ_REG(hw, CTRL_EXT);
	reg &= ~E1000_CTRL_EXT_SDP3_DATA;
	E1000_WRITE_REG(hw, CTRL_EXT, reg);

	/* flush the write to verify completion */
	E1000_WRITE_FLUSH(hw);
	delay(5);
}

/******************************************************************************
 * Sets up link for a fiber based or serdes based adapter
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Manipulates Physical Coding Sublayer functions in order to configure
 * link. Assumes the hardware has been previously reset and the transmitter
 * and receiver are not enabled.
 *****************************************************************************/
static int32_t
em_setup_fiber_serdes_link(struct em_hw *hw)
{
	uint32_t ctrl, ctrl_ext, reg;
	uint32_t status;
	uint32_t txcw = 0;
	uint32_t i;
	uint32_t signal = 0;
	int32_t  ret_val;
	DEBUGFUNC("em_setup_fiber_serdes_link");
	/*
	 * On 82571 and 82572 Fiber connections, SerDes loopback mode
	 * persists until explicitly turned off or a power cycle is
	 * performed.  A read to the register does not indicate its status.
	 * Therefore, we ensure loopback mode is disabled during
	 * initialization.
	 */
	if (hw->mac_type == em_82571 || hw->mac_type == em_82572 ||
	    hw->mac_type >= em_82575)
		E1000_WRITE_REG(hw, SCTL, E1000_DISABLE_SERDES_LOOPBACK);

	if (hw->mac_type >= em_82575)
		em_power_up_serdes_link_82575(hw);
		
	/*
	 * On adapters with a MAC newer than 82544, SWDP 1 will be set when
	 * the optics detect a signal. On older adapters, it will be cleared
	 * when there is a signal.  This applies to fiber media only. If
	 * we're on serdes media, adjust the output amplitude to value set in
	 * the EEPROM.
	 */
	ctrl = E1000_READ_REG(hw, CTRL);
	if (hw->media_type == em_media_type_fiber)
		signal = (hw->mac_type > em_82544) ? E1000_CTRL_SWDPIN1 : 0;

	ret_val = em_adjust_serdes_amplitude(hw);
	if (ret_val)
		return ret_val;

	/* Take the link out of reset */
	ctrl &= ~(E1000_CTRL_LRST);

	if (hw->mac_type >= em_82575) {
		/* set both sw defined pins on 82575/82576*/
		ctrl |= E1000_CTRL_SWDPIN0 | E1000_CTRL_SWDPIN1;

		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
		switch (ctrl_ext & E1000_CTRL_EXT_LINK_MODE_MASK) {
		case E1000_CTRL_EXT_LINK_MODE_1000BASE_KX:
		case E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES:
			/* the backplane is always connected */
			reg = E1000_READ_REG(hw, PCS_LCTL);
			reg |= E1000_PCS_LCTL_FORCE_FCTRL;
			reg |= E1000_PCS_LCTL_FSV_1000 | E1000_PCS_LCTL_FDV_FULL;
			reg |= E1000_PCS_LCTL_FSD;        /* Force Speed */
			DEBUGOUT("Configuring Forced Link\n");
			E1000_WRITE_REG(hw, PCS_LCTL, reg);
			em_force_mac_fc(hw);
			hw->autoneg_failed = 0;
			return E1000_SUCCESS;
			break;
		default:
			/* Set switch control to serdes energy detect */
			reg = E1000_READ_REG(hw, CONNSW);
			reg |= E1000_CONNSW_ENRGSRC;
			E1000_WRITE_REG(hw, CONNSW, reg);
			break;
		}
	}

	/* Adjust VCO speed to improve BER performance */
	ret_val = em_set_vco_speed(hw);
	if (ret_val)
		return ret_val;

	em_config_collision_dist(hw);
	/*
	 * Check for a software override of the flow control settings, and
	 * setup the device accordingly.  If auto-negotiation is enabled,
	 * then software will have to set the "PAUSE" bits to the correct
	 * value in the Tranmsit Config Word Register (TXCW) and re-start
	 * auto-negotiation.  However, if auto-negotiation is disabled, then
	 * software will have to manually configure the two flow control
	 * enable bits in the CTRL register.
	 *
	 * The possible values of the "fc" parameter are: 0:  Flow control is
	 * completely disabled 1:  Rx flow control is enabled (we can receive
	 * pause frames, but not send pause frames). 2:  Tx flow control is
	 * enabled (we can send pause frames but we do not support receiving
	 * pause frames). 3:  Both Rx and TX flow control (symmetric) are
	 * enabled.
	 */
	switch (hw->fc) {
	case E1000_FC_NONE:
		/*
		 * Flow control is completely disabled by a software
		 * over-ride.
		 */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD);
		break;
	case E1000_FC_RX_PAUSE:
		/*
		 * RX Flow control is enabled and TX Flow control is disabled
		 * by a software over-ride. Since there really isn't a way to
		 * advertise that we are capable of RX Pause ONLY, we will
		 * advertise that we support both symmetric and asymmetric RX
		 * PAUSE. Later, we will disable the adapter's ability to
		 * send PAUSE frames.
		 */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | 
		    E1000_TXCW_PAUSE_MASK);
		break;
	case E1000_FC_TX_PAUSE:
		/*
		 * TX Flow control is enabled, and RX Flow control is
		 * disabled, by a software over-ride.
		 */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);
		break;
	case E1000_FC_FULL:
		/*
		 * Flow control (both RX and TX) is enabled by a software
		 * over-ride.
		 */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | 
		    E1000_TXCW_PAUSE_MASK);
		break;
	default:
		DEBUGOUT("Flow control param set incorrectly\n");
		return -E1000_ERR_CONFIG;
		break;
	}
	/*
	 * Since auto-negotiation is enabled, take the link out of reset (the
	 * link will be in reset, because we previously reset the chip). This
	 * will restart auto-negotiation.  If auto-neogtiation is successful
	 * then the link-up status bit will be set and the flow control
	 * enable bits (RFCE and TFCE) will be set according to their
	 * negotiated value.
	 */
	DEBUGOUT("Auto-negotiation enabled\n");

	E1000_WRITE_REG(hw, TXCW, txcw);
	E1000_WRITE_REG(hw, CTRL, ctrl);
	E1000_WRITE_FLUSH(hw);

	hw->txcw = txcw;
	msec_delay(1);
	/*
	 * If we have a signal (the cable is plugged in) then poll for a
	 * "Link-Up" indication in the Device Status Register.  Time-out if a
	 * link isn't seen in 500 milliseconds seconds (Auto-negotiation
	 * should complete in less than 500 milliseconds even if the other
	 * end is doing it in SW). For internal serdes, we just assume a
	 * signal is present, then poll.
	 */
	if (hw->media_type == em_media_type_internal_serdes ||
	    (E1000_READ_REG(hw, CTRL) & E1000_CTRL_SWDPIN1) == signal) {
		DEBUGOUT("Looking for Link\n");
		for (i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
			msec_delay(10);
			status = E1000_READ_REG(hw, STATUS);
			if (status & E1000_STATUS_LU)
				break;
		}
		if (i == (LINK_UP_TIMEOUT / 10)) {
			DEBUGOUT("Never got a valid link from auto-neg!!!\n");
			hw->autoneg_failed = 1;
			/*
			 * AutoNeg failed to achieve a link, so we'll call
			 * em_check_for_link. This routine will force the
			 * link up if we detect a signal. This will allow us
			 * to communicate with non-autonegotiating link
			 * partners.
			 */
			ret_val = em_check_for_link(hw);
			if (ret_val) {
				DEBUGOUT("Error while checking for link\n");
				return ret_val;
			}
			hw->autoneg_failed = 0;
		} else {
			hw->autoneg_failed = 0;
			DEBUGOUT("Valid Link Found\n");
		}
	} else {
		DEBUGOUT("No Signal Detected\n");
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Make sure we have a valid PHY and change PHY mode before link setup.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_copper_link_preconfig(struct em_hw *hw)
{
	uint32_t ctrl;
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_copper_link_preconfig");

	ctrl = E1000_READ_REG(hw, CTRL);
	/*
	 * With 82543, we need to force speed and duplex on the MAC equal to
	 * what the PHY speed and duplex configuration is. In addition, we
	 * need to perform a hardware reset on the PHY to take it out of
	 * reset.
	 */
	if (hw->mac_type > em_82543) {
		ctrl |= E1000_CTRL_SLU;
		ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
		E1000_WRITE_REG(hw, CTRL, ctrl);
	} else {
		ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | 
		    E1000_CTRL_SLU);
		E1000_WRITE_REG(hw, CTRL, ctrl);
		ret_val = em_phy_hw_reset(hw);
		if (ret_val)
			return ret_val;
	}

	/* Set PHY to class A mode (if necessary) */
	ret_val = em_set_phy_mode(hw);
	if (ret_val)
		return ret_val;

	if ((hw->mac_type == em_82545_rev_3) ||
	    (hw->mac_type == em_82546_rev_3)) {
		ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, 
		    &phy_data);
		phy_data |= 0x00000008;
		ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, 
		    phy_data);
	}
	if (hw->mac_type <= em_82543 ||
	    hw->mac_type == em_82541 || hw->mac_type == em_82547 ||
	    hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2)
		hw->phy_reset_disable = FALSE;

	return E1000_SUCCESS;
}

/******************************************************************************
 * Copper link setup for em_phy_igp series.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_copper_link_igp_setup(struct em_hw *hw)
{
	uint32_t led_ctrl;
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_copper_link_igp_setup");

	if (hw->phy_reset_disable)
		return E1000_SUCCESS;

	ret_val = em_phy_reset(hw);
	if (ret_val) {
		DEBUGOUT("Error Resetting the PHY\n");
		return ret_val;
	}
	/* Wait 15ms for MAC to configure PHY from eeprom settings */
	msec_delay(15);
	if (hw->mac_type != em_ich8lan &&
	    hw->mac_type != em_ich9lan &&
	    hw->mac_type != em_ich10lan) {
		/* Configure activity LED after PHY reset */
		led_ctrl = E1000_READ_REG(hw, LEDCTL);
		led_ctrl &= IGP_ACTIVITY_LED_MASK;
		led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
		E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
	}
	/* The NVM settings will configure LPLU in D3 for IGP2 and IGP3 PHYs */
	if (hw->phy_type == em_phy_igp) {
		/* disable lplu d3 during driver init */
		ret_val = em_set_d3_lplu_state(hw, FALSE);
		if (ret_val) {
			DEBUGOUT("Error Disabling LPLU D3\n");
			return ret_val;
		}
	}
	/* disable lplu d0 during driver init */
	if (hw->mac_type == em_pchlan ||
		hw->mac_type == em_pch2lan ||
		hw->mac_type == em_pch_lpt ||
		hw->mac_type == em_pch_spt)
		ret_val = em_set_lplu_state_pchlan(hw, FALSE);
	else
		ret_val = em_set_d0_lplu_state(hw, FALSE);
	if (ret_val) {
		DEBUGOUT("Error Disabling LPLU D0\n");
		return ret_val;
	}
	/* Configure mdi-mdix settings */
	ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
	if (ret_val)
		return ret_val;

	if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
		hw->dsp_config_state = em_dsp_config_disabled;
		/* Force MDI for earlier revs of the IGP PHY */
		phy_data &= ~(IGP01E1000_PSCR_AUTO_MDIX | 
		    IGP01E1000_PSCR_FORCE_MDI_MDIX);
		hw->mdix = 1;

	} else {
		hw->dsp_config_state = em_dsp_config_enabled;
		phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;

		switch (hw->mdix) {
		case 1:
			phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
			break;
		case 2:
			phy_data |= IGP01E1000_PSCR_FORCE_MDI_MDIX;
			break;
		case 0:
		default:
			phy_data |= IGP01E1000_PSCR_AUTO_MDIX;
			break;
		}
	}
	ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);
	if (ret_val)
		return ret_val;

	/* set auto-master slave resolution settings */
	if (hw->autoneg) {
		em_ms_type phy_ms_setting = hw->master_slave;
		if (hw->ffe_config_state == em_ffe_config_active)
			hw->ffe_config_state = em_ffe_config_enabled;

		if (hw->dsp_config_state == em_dsp_config_activated)
			hw->dsp_config_state = em_dsp_config_enabled;
		/*
		 * when autonegotiation advertisement is only 1000Mbps then
		 * we should disable SmartSpeed and enable Auto MasterSlave
		 * resolution as hardware default.
		 */
		if (hw->autoneg_advertised == ADVERTISE_1000_FULL) {
			/* Disable SmartSpeed */
			ret_val = em_read_phy_reg(hw, 
			    IGP01E1000_PHY_PORT_CONFIG, &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
			ret_val = em_write_phy_reg(hw, 
			    IGP01E1000_PHY_PORT_CONFIG, phy_data);
			if (ret_val)
				return ret_val;
			/* Set auto Master/Slave resolution process */
			ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, 
			    &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= ~CR_1000T_MS_ENABLE;
			ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, 
			    phy_data);
			if (ret_val)
				return ret_val;
		}
		ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
		if (ret_val)
			return ret_val;

		/* load defaults for future use */
		hw->original_master_slave = (phy_data & CR_1000T_MS_ENABLE) ?
		    ((phy_data & CR_1000T_MS_VALUE) ? em_ms_force_master : 
		    em_ms_force_slave) : em_ms_auto;

		switch (phy_ms_setting) {
		case em_ms_force_master:
			phy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);
			break;
		case em_ms_force_slave:
			phy_data |= CR_1000T_MS_ENABLE;
			phy_data &= ~(CR_1000T_MS_VALUE);
			break;
		case em_ms_auto:
			phy_data &= ~CR_1000T_MS_ENABLE;
			break;
		default:
			break;
		}
		ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
		if (ret_val)
			return ret_val;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Copper link setup for em_phy_gg82563 series.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_copper_link_ggp_setup(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t phy_data;
	uint32_t reg_data;
	DEBUGFUNC("em_copper_link_ggp_setup");

	if (!hw->phy_reset_disable) {

		/* Enable CRS on TX for half-duplex operation. */
		ret_val = em_read_phy_reg(hw, GG82563_PHY_MAC_SPEC_CTRL,
		    &phy_data);
		if (ret_val)
			return ret_val;

		phy_data |= GG82563_MSCR_ASSERT_CRS_ON_TX;
		/* Use 25MHz for both link down and 1000BASE-T for Tx clock */
		phy_data |= GG82563_MSCR_TX_CLK_1000MBPS_25MHZ;

		ret_val = em_write_phy_reg(hw, GG82563_PHY_MAC_SPEC_CTRL,
		    phy_data);
		if (ret_val)
			return ret_val;
		/*
		 * Options: MDI/MDI-X = 0 (default) 0 - Auto for all speeds 1
		 * - MDI mode 2 - MDI-X mode 3 - Auto for 1000Base-T only
		 * (MDI-X for 10/100Base-T modes)
		 */
		ret_val = em_read_phy_reg(hw, GG82563_PHY_SPEC_CTRL,
		    &phy_data);

		if (ret_val)
			return ret_val;

		phy_data &= ~GG82563_PSCR_CROSSOVER_MODE_MASK;

		switch (hw->mdix) {
		case 1:
			phy_data |= GG82563_PSCR_CROSSOVER_MODE_MDI;
			break;
		case 2:
			phy_data |= GG82563_PSCR_CROSSOVER_MODE_MDIX;
			break;
		case 0:
		default:
			phy_data |= GG82563_PSCR_CROSSOVER_MODE_AUTO;
			break;
		}
		/*
		 * Options: disable_polarity_correction = 0 (default)
		 * Automatic Correction for Reversed Cable Polarity 0 -
		 * Disabled 1 - Enabled
		 */
		phy_data &= ~GG82563_PSCR_POLARITY_REVERSAL_DISABLE;
		if (hw->disable_polarity_correction == 1)
			phy_data |= GG82563_PSCR_POLARITY_REVERSAL_DISABLE;
		ret_val = em_write_phy_reg(hw, GG82563_PHY_SPEC_CTRL,
		    phy_data);

		if (ret_val)
			return ret_val;

		/* SW Reset the PHY so all changes take effect */
		ret_val = em_phy_reset(hw);
		if (ret_val) {
			DEBUGOUT("Error Resetting the PHY\n");
			return ret_val;
		}
	}			/* phy_reset_disable */
	if (hw->mac_type == em_80003es2lan) {
		/* Bypass RX and TX FIFO's */
		ret_val = em_write_kmrn_reg(hw, 
		    E1000_KUMCTRLSTA_OFFSET_FIFO_CTRL,
		    E1000_KUMCTRLSTA_FIFO_CTRL_RX_BYPASS |
		    E1000_KUMCTRLSTA_FIFO_CTRL_TX_BYPASS);
		if (ret_val)
			return ret_val;

		ret_val = em_read_phy_reg(hw, GG82563_PHY_SPEC_CTRL_2, 
		    &phy_data);
		if (ret_val)
			return ret_val;

		phy_data &= ~GG82563_PSCR2_REVERSE_AUTO_NEG;
		ret_val = em_write_phy_reg(hw, GG82563_PHY_SPEC_CTRL_2, 
		    phy_data);

		if (ret_val)
			return ret_val;

		reg_data = E1000_READ_REG(hw, CTRL_EXT);
		reg_data &= ~(E1000_CTRL_EXT_LINK_MODE_MASK);
		E1000_WRITE_REG(hw, CTRL_EXT, reg_data);

		ret_val = em_read_phy_reg(hw, GG82563_PHY_PWR_MGMT_CTRL,
		    &phy_data);
		if (ret_val)
			return ret_val;
		/*
		 * Do not init these registers when the HW is in IAMT mode,
		 * since the firmware will have already initialized them. We
		 * only initialize them if the HW is not in IAMT mode.
		 */
		if (em_check_mng_mode(hw) == FALSE) {
			/* Enable Electrical Idle on the PHY */
			phy_data |= GG82563_PMCR_ENABLE_ELECTRICAL_IDLE;
			ret_val = em_write_phy_reg(hw, 
			    GG82563_PHY_PWR_MGMT_CTRL, phy_data);
			if (ret_val)
				return ret_val;

			ret_val = em_read_phy_reg(hw, 
			    GG82563_PHY_KMRN_MODE_CTRL, &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= ~GG82563_KMCR_PASS_FALSE_CARRIER;
			ret_val = em_write_phy_reg(hw, 
			    GG82563_PHY_KMRN_MODE_CTRL, phy_data);

			if (ret_val)
				return ret_val;
		}
		/*
		 * Workaround: Disable padding in Kumeran interface in the
		 * MAC and in the PHY to avoid CRC errors.
		 */
		ret_val = em_read_phy_reg(hw, GG82563_PHY_INBAND_CTRL,
		    &phy_data);
		if (ret_val)
			return ret_val;
		phy_data |= GG82563_ICR_DIS_PADDING;
		ret_val = em_write_phy_reg(hw, GG82563_PHY_INBAND_CTRL, 
		    phy_data);
		if (ret_val)
			return ret_val;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Copper link setup for em_phy_m88 series.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_copper_link_mgp_setup(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_copper_link_mgp_setup");

	if (hw->phy_reset_disable)
		return E1000_SUCCESS;

	/* disable lplu d0 during driver init */
	if (hw->mac_type == em_pchlan ||
		hw->mac_type == em_pch2lan ||
		hw->mac_type == em_pch_lpt ||
		hw->mac_type == em_pch_spt)
		ret_val = em_set_lplu_state_pchlan(hw, FALSE);

	/* Enable CRS on TX. This must be set for half-duplex operation. */
	ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
	if (ret_val)
		return ret_val;

	if (hw->phy_id == M88E1141_E_PHY_ID) {
		phy_data |= 0x00000008;
		ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, 
		    phy_data);
		if (ret_val)
			return ret_val;

		ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, 
		    &phy_data);
		if (ret_val)
			return ret_val;

		phy_data &= ~M88E1000_PSCR_ASSERT_CRS_ON_TX;

	}
	/* For BM PHY this bit is downshift enable */
	else if (hw->phy_type != em_phy_bm)
		phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
	/*
	 * Options: MDI/MDI-X = 0 (default) 0 - Auto for all speeds 1 - MDI
	 * mode 2 - MDI-X mode 3 - Auto for 1000Base-T only (MDI-X for
	 * 10/100Base-T modes)
	 */
	phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;

	switch (hw->mdix) {
	case 1:
		phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
		break;
	case 2:
		phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
		break;
	case 3:
		phy_data |= M88E1000_PSCR_AUTO_X_1000T;
		break;
	case 0:
	default:
		phy_data |= M88E1000_PSCR_AUTO_X_MODE;
		break;
	}
	/*
	 * Options: disable_polarity_correction = 0 (default) Automatic
	 * Correction for Reversed Cable Polarity 0 - Disabled 1 - Enabled
	 */
	phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
	if (hw->disable_polarity_correction == 1)
		phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;

	/* Enable downshift on BM (disabled by default) */
	if (hw->phy_type == em_phy_bm)
		phy_data |= BME1000_PSCR_ENABLE_DOWNSHIFT;

	ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
	if (ret_val)
		return ret_val;

	if (((hw->phy_type == em_phy_m88) &&
	    (hw->phy_revision < M88E1011_I_REV_4) &&
	    (hw->phy_id != BME1000_E_PHY_ID)) ||
	    (hw->phy_type == em_phy_oem)) {
		/*
		 * Force TX_CLK in the Extended PHY Specific Control Register
		 * to 25MHz clock.
		 */
		ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
		    &phy_data);
		if (ret_val)
			return ret_val;

		if (hw->phy_type == em_phy_oem) {
			phy_data |= M88E1000_EPSCR_TX_TIME_CTRL;
			phy_data |= M88E1000_EPSCR_RX_TIME_CTRL;
		}
		phy_data |= M88E1000_EPSCR_TX_CLK_25;

		if ((hw->phy_revision == E1000_REVISION_2) &&
		    (hw->phy_id == M88E1111_I_PHY_ID)) {
			/* Vidalia Phy, set the downshift counter to 5x */
			phy_data &= ~(M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK);
			phy_data |= M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X;
			ret_val = em_write_phy_reg(hw,
			    M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
			if (ret_val)
				return ret_val;
		} else {
			/* Configure Master and Slave downshift values */
			phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
			    M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
			phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
			    M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
			ret_val = em_write_phy_reg(hw,
			    M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
			if (ret_val)
				return ret_val;
		}
	}
	if ((hw->phy_type == em_phy_bm) && (hw->phy_revision == 1)) {
		/*
	    	 * Set PHY page 0, register 29 to 0x0003
	         * The next two writes are supposed to lower BER for gig
	         * conection
		 */
		ret_val = em_write_phy_reg(hw, BM_REG_BIAS1, 0x0003);
		if (ret_val)
			return ret_val;

		/* Set PHY page 0, register 30 to 0x0000 */
		ret_val = em_write_phy_reg(hw, BM_REG_BIAS2, 0x0000);
		if (ret_val)
			return ret_val;
	}
	if (hw->phy_type == em_phy_82578) {
		ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
		    &phy_data);
		if (ret_val)
			return ret_val;

		/* 82578 PHY - set the downshift count to 1x. */
		phy_data |= I82578_EPSCR_DOWNSHIFT_ENABLE;
		phy_data &= ~I82578_EPSCR_DOWNSHIFT_COUNTER_MASK;
		ret_val = em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
		    phy_data);
		if (ret_val)
			return ret_val;
	}
	/* SW Reset the PHY so all changes take effect */
	ret_val = em_phy_reset(hw);
	if (ret_val) {
		DEBUGOUT("Error Resetting the PHY\n");
		return ret_val;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Copper link setup for em_phy_82577 series.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_copper_link_82577_setup(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t phy_data;
	uint32_t led_ctl;
	DEBUGFUNC("em_copper_link_82577_setup");

	if (hw->phy_reset_disable)
		return E1000_SUCCESS;

	/* Enable CRS on TX for half-duplex operation. */
	ret_val = em_read_phy_reg(hw, I82577_PHY_CFG_REG, &phy_data);
	if (ret_val)
		return ret_val;

	phy_data |= I82577_PHY_CFG_ENABLE_CRS_ON_TX |
	    I82577_PHY_CFG_ENABLE_DOWNSHIFT;

	ret_val = em_write_phy_reg(hw, I82577_PHY_CFG_REG, phy_data);
	if (ret_val)
		return ret_val;

	/* Wait 15ms for MAC to configure PHY from eeprom settings */
	msec_delay(15);
	led_ctl = hw->ledctl_mode1;

	/* disable lplu d0 during driver init */
	ret_val = em_set_lplu_state_pchlan(hw, FALSE);
	if (ret_val) {
		DEBUGOUT("Error Disabling LPLU D0\n");
		return ret_val;
	}

	E1000_WRITE_REG(hw, LEDCTL, led_ctl);

	return E1000_SUCCESS;
}

static int32_t
em_copper_link_82580_setup(struct em_hw *hw)
{
	int32_t ret_val;
	uint16_t phy_data;

	if (hw->phy_reset_disable)
		return E1000_SUCCESS;

	ret_val = em_phy_reset(hw);
	if (ret_val)
		goto out;

	/* Enable CRS on TX. This must be set for half-duplex operation. */
	ret_val = em_read_phy_reg(hw, I82580_CFG_REG, &phy_data);
	if (ret_val)
		goto out;

	phy_data |= I82580_CFG_ASSERT_CRS_ON_TX |
	    I82580_CFG_ENABLE_DOWNSHIFT;

	ret_val = em_write_phy_reg(hw, I82580_CFG_REG, phy_data);

out:
	return ret_val;
}

static int32_t
em_copper_link_rtl8211_setup(struct em_hw *hw)
{
	int32_t ret_val;
	uint16_t phy_data;

	DEBUGFUNC("em_copper_link_rtl8211_setup: begin");

	if (!hw) {
		return -1;
	}
	/* SW Reset the PHY so all changes take effect */
	em_phy_hw_reset(hw);

	/* Enable CRS on TX. This must be set for half-duplex operation. */
	phy_data = 0;

	ret_val = em_read_phy_reg_ex(hw, RGEPHY_CR, &phy_data);
	if (ret_val) {
		printf("Unable to read RGEPHY_CR register\n");
		return ret_val;
	}
	DEBUGOUT3("RTL8211: Rx phy_id=%X addr=%X SPEC_CTRL=%X\n", hw->phy_id,
	    hw->phy_addr, phy_data);
	phy_data |= RGEPHY_CR_ASSERT_CRS;

	ret_val = em_write_phy_reg_ex(hw, RGEPHY_CR, phy_data);
	if (ret_val) {
		printf("Unable to write RGEPHY_CR register\n");
		return ret_val;
	}

	phy_data = 0; /* LED Control Register 0x18 */
	ret_val = em_read_phy_reg_ex(hw, RGEPHY_LC, &phy_data);
	if (ret_val) {
		printf("Unable to read RGEPHY_LC register\n");
		return ret_val;
	}

	phy_data &= 0x80FF; /* bit-15=0 disable, clear bit 8-10 */
	ret_val = em_write_phy_reg_ex(hw, RGEPHY_LC, phy_data);
	if (ret_val) {
		printf("Unable to write RGEPHY_LC register\n");
		return ret_val;
	}
	/* LED Control and Definition Register 0x11, PHY spec status reg */
	phy_data = 0;
	ret_val = em_read_phy_reg_ex(hw, RGEPHY_SR, &phy_data);
	if (ret_val) {
		printf("Unable to read RGEPHY_SR register\n");
		return ret_val;
	}

	phy_data |= 0x0010; /* LED active Low */
	ret_val = em_write_phy_reg_ex(hw, RGEPHY_SR, phy_data);
	if (ret_val) {
		printf("Unable to write RGEPHY_SR register\n");
		return ret_val;
	}

	phy_data = 0;
	ret_val = em_read_phy_reg_ex(hw, RGEPHY_SR, &phy_data);
	if (ret_val) {
		printf("Unable to read RGEPHY_SR register\n");
		return ret_val;
	}

	/* Switch to Page2 */
	phy_data = RGEPHY_PS_PAGE_2;
	ret_val = em_write_phy_reg_ex(hw, RGEPHY_PS, phy_data);
	if (ret_val) {
		printf("Unable to write PHY RGEPHY_PS register\n");
		return ret_val;
	}

	phy_data = 0x0000;
	ret_val = em_write_phy_reg_ex(hw, RGEPHY_LC_P2, phy_data);
	if (ret_val) {
		printf("Unable to write RGEPHY_LC_P2 register\n");
		return ret_val;
	}
	usec_delay(5);


	/* LED Configuration Control Reg for setting for 0x1A Register */
	phy_data = 0;
	ret_val = em_read_phy_reg_ex(hw, RGEPHY_LC_P2, &phy_data);
	if (ret_val) {
		printf("Unable to read RGEPHY_LC_P2 register\n");
		return ret_val;
	}

	phy_data &= 0xF000;
	phy_data |= 0x0F24;
	ret_val = em_write_phy_reg_ex(hw, RGEPHY_LC_P2, phy_data);
	if (ret_val) {
		printf("Unable to write RGEPHY_LC_P2 register\n");
		return ret_val;
	}
	phy_data = 0;
	ret_val= em_read_phy_reg_ex(hw, RGEPHY_LC_P2, &phy_data);
	if (ret_val) {
		printf("Unable to read RGEPHY_LC_P2 register\n");
		return ret_val;
	}
	DEBUGOUT1("RTL8211:ReadBack for check, LED_CFG->data=%X\n", phy_data);


	/* After setting Page2, go back to Page 0 */
	phy_data = 0;
	ret_val = em_write_phy_reg_ex(hw, RGEPHY_PS, phy_data);
	if (ret_val) {
		printf("Unable to write PHY RGEPHY_PS register\n");
		return ret_val;
	}

	/* pulse streching= 42-84ms, blink rate=84mm */
	phy_data = 0x140 | RGEPHY_LC_PULSE_42MS | RGEPHY_LC_LINK | 
	    RGEPHY_LC_DUPLEX | RGEPHY_LC_RX;

	ret_val = em_write_phy_reg_ex(hw, RGEPHY_LC, phy_data);
	if (ret_val) {
		printf("Unable to write RGEPHY_LC register\n");
		return ret_val;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Setup auto-negotiation and flow control advertisements,
 * and then perform auto-negotiation.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_copper_link_autoneg(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_copper_link_autoneg");
	/*
	 * Perform some bounds checking on the hw->autoneg_advertised
	 * parameter.  If this variable is zero, then set it to the default.
	 */
	hw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;
	/*
	 * If autoneg_advertised is zero, we assume it was not defaulted by
	 * the calling code so we set to advertise full capability.
	 */
	if (hw->autoneg_advertised == 0)
		hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;

	/* IFE phy only supports 10/100 */
	if (hw->phy_type == em_phy_ife)
		hw->autoneg_advertised &= AUTONEG_ADVERTISE_10_100_ALL;

	DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
	ret_val = em_phy_setup_autoneg(hw);
	if (ret_val) {
		DEBUGOUT("Error Setting up Auto-Negotiation\n");
		return ret_val;
	}
	DEBUGOUT("Restarting Auto-Neg\n");
	/*
	 * Restart auto-negotiation by setting the Auto Neg Enable bit and
	 * the Auto Neg Restart bit in the PHY control register.
	 */
	ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
	ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data);
	if (ret_val)
		return ret_val;
	/*
	 * Does the user want to wait for Auto-Neg to complete here, or check
	 * at a later time (for example, callback routine).
	 */
	if (hw->wait_autoneg_complete) {
		ret_val = em_wait_autoneg(hw);
		if (ret_val) {
			DEBUGOUT("Error while waiting for autoneg to complete\n"
			    );
			return ret_val;
		}
	}
	hw->get_link_status = TRUE;

	return E1000_SUCCESS;
}

/******************************************************************************
 * Config the MAC and the PHY after link is up.
 *   1) Set up the MAC to the current PHY speed/duplex
 *      if we are on 82543.  If we
 *      are on newer silicon, we only need to configure
 *      collision distance in the Transmit Control Register.
 *   2) Set up flow control on the MAC to that established with
 *      the link partner.
 *   3) Config DSP to improve Gigabit link quality for some PHY revisions.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_copper_link_postconfig(struct em_hw *hw)
{
	int32_t ret_val;
	DEBUGFUNC("em_copper_link_postconfig");

	if (hw->mac_type >= em_82544 &&
	    hw->mac_type != em_icp_xxxx) {
		em_config_collision_dist(hw);
	} else {
		ret_val = em_config_mac_to_phy(hw);
		if (ret_val) {
			DEBUGOUT("Error configuring MAC to PHY settings\n");
			return ret_val;
		}
	}
	ret_val = em_config_fc_after_link_up(hw);
	if (ret_val) {
		DEBUGOUT("Error Configuring Flow Control\n");
		return ret_val;
	}
	/* Config DSP to improve Giga link quality */
	if (hw->phy_type == em_phy_igp) {
		ret_val = em_config_dsp_after_link_change(hw, TRUE);
		if (ret_val) {
			DEBUGOUT("Error Configuring DSP after link up\n");
			return ret_val;
		}
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Detects which PHY is present and setup the speed and duplex
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_setup_copper_link(struct em_hw *hw)
{
	int32_t         ret_val;
	uint16_t        i;
	uint16_t        phy_data;
	uint16_t        reg_data;
	DEBUGFUNC("em_setup_copper_link");

	switch (hw->mac_type) {
	case em_80003es2lan:
	case em_ich8lan:
	case em_ich9lan:
	case em_ich10lan:
	case em_pchlan:
	case em_pch2lan:
	case em_pch_lpt:
	case em_pch_spt:
		/*
		 * Set the mac to wait the maximum time between each
		 * iteration and increase the max iterations when polling the
		 * phy; this fixes erroneous timeouts at 10Mbps.
		 */
		ret_val = em_write_kmrn_reg(hw, GG82563_REG(0x34, 4), 0xFFFF);
		if (ret_val)
			return ret_val;
		ret_val = em_read_kmrn_reg(hw, GG82563_REG(0x34, 9), 
		    &reg_data);
		if (ret_val)
			return ret_val;
		reg_data |= 0x3F;
		ret_val = em_write_kmrn_reg(hw, GG82563_REG(0x34, 9), 
		    reg_data);
		if (ret_val)
			return ret_val;
	default:
		break;
	}

	/* Check if it is a valid PHY and set PHY mode if necessary. */
	ret_val = em_copper_link_preconfig(hw);
	if (ret_val)
		return ret_val;

	switch (hw->mac_type) {
	case em_80003es2lan:
		/* Kumeran registers are written-only */
		reg_data = 
		    E1000_KUMCTRLSTA_INB_CTRL_LINK_STATUS_TX_TIMEOUT_DEFAULT;
		reg_data |= E1000_KUMCTRLSTA_INB_CTRL_DIS_PADDING;
		ret_val = em_write_kmrn_reg(hw, 
		    E1000_KUMCTRLSTA_OFFSET_INB_CTRL, reg_data);
		if (ret_val)
			return ret_val;
		break;
	default:
		break;
	}

	if (hw->phy_type == em_phy_igp ||
	    hw->phy_type == em_phy_igp_3 ||
	    hw->phy_type == em_phy_igp_2) {
		ret_val = em_copper_link_igp_setup(hw);
		if (ret_val)
			return ret_val;
	} else if (hw->phy_type == em_phy_m88 ||
	    hw->phy_type == em_phy_bm ||
	    hw->phy_type == em_phy_oem ||
	    hw->phy_type == em_phy_82578) {
		ret_val = em_copper_link_mgp_setup(hw);
		if (ret_val)
			return ret_val;
	} else if (hw->phy_type == em_phy_gg82563) {
		ret_val = em_copper_link_ggp_setup(hw);
		if (ret_val)
			return ret_val;
	} else if (hw->phy_type == em_phy_82577 ||
		hw->phy_type == em_phy_82579 ||
		hw->phy_type == em_phy_i217) {
		ret_val = em_copper_link_82577_setup(hw);
		if (ret_val)
			return ret_val;
	} else if (hw->phy_type == em_phy_82580) {
		ret_val = em_copper_link_82580_setup(hw);
		if (ret_val)
			return ret_val;
	} else if (hw->phy_type == em_phy_rtl8211) {
		ret_val = em_copper_link_rtl8211_setup(hw);
		if (ret_val)
			return ret_val;
	}
	if (hw->autoneg) {
		/*
		 * Setup autoneg and flow control advertisement and perform
		 * autonegotiation
		 */
		ret_val = em_copper_link_autoneg(hw);
		if (ret_val)
			return ret_val;
	} else {
		/*
		 * PHY will be set to 10H, 10F, 100H,or 100F depending on
		 * value from forced_speed_duplex.
		 */
		DEBUGOUT("Forcing speed and duplex\n");
		ret_val = em_phy_force_speed_duplex(hw);
		if (ret_val) {
			DEBUGOUT("Error Forcing Speed and Duplex\n");
			return ret_val;
		}
	}
	/*
	 * Check link status. Wait up to 100 microseconds for link to become
	 * valid.
	 */
	for (i = 0; i < 10; i++) {
		ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;
		ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		hw->icp_xxxx_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;

		if (phy_data & MII_SR_LINK_STATUS) {
			/* Config the MAC and PHY after link is up */
			ret_val = em_copper_link_postconfig(hw);
			if (ret_val)
				return ret_val;

			DEBUGOUT("Valid link established!!!\n");
			return E1000_SUCCESS;
		}
		usec_delay(10);
	}

	DEBUGOUT("Unable to establish link!!!\n");
	return E1000_SUCCESS;
}

/******************************************************************************
 * Configure the MAC-to-PHY interface for 10/100Mbps
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_configure_kmrn_for_10_100(struct em_hw *hw, uint16_t duplex)
{
	int32_t  ret_val = E1000_SUCCESS;
	uint32_t tipg;
	uint16_t reg_data;
	DEBUGFUNC("em_configure_kmrn_for_10_100");

	reg_data = E1000_KUMCTRLSTA_HD_CTRL_10_100_DEFAULT;
	ret_val = em_write_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_HD_CTRL,
	    reg_data);
	if (ret_val)
		return ret_val;

	/* Configure Transmit Inter-Packet Gap */
	tipg = E1000_READ_REG(hw, TIPG);
	tipg &= ~E1000_TIPG_IPGT_MASK;
	tipg |= DEFAULT_80003ES2LAN_TIPG_IPGT_10_100;
	E1000_WRITE_REG(hw, TIPG, tipg);

	ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data);

	if (ret_val)
		return ret_val;

	if (duplex == HALF_DUPLEX)
		reg_data |= GG82563_KMCR_PASS_FALSE_CARRIER;
	else
		reg_data &= ~GG82563_KMCR_PASS_FALSE_CARRIER;

	ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, reg_data);

	return ret_val;
}

static int32_t
em_configure_kmrn_for_1000(struct em_hw *hw)
{
	int32_t  ret_val = E1000_SUCCESS;
	uint16_t reg_data;
	uint32_t tipg;
	DEBUGFUNC("em_configure_kmrn_for_1000");

	reg_data = E1000_KUMCTRLSTA_HD_CTRL_1000_DEFAULT;
	ret_val = em_write_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_HD_CTRL,
	    reg_data);
	if (ret_val)
		return ret_val;

	/* Configure Transmit Inter-Packet Gap */
	tipg = E1000_READ_REG(hw, TIPG);
	tipg &= ~E1000_TIPG_IPGT_MASK;
	tipg |= DEFAULT_80003ES2LAN_TIPG_IPGT_1000;
	E1000_WRITE_REG(hw, TIPG, tipg);

	ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data);

	if (ret_val)
		return ret_val;

	reg_data &= ~GG82563_KMCR_PASS_FALSE_CARRIER;
	ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, reg_data);

	return ret_val;
}

/******************************************************************************
 * Configures PHY autoneg and flow control advertisement settings
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_phy_setup_autoneg(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t mii_autoneg_adv_reg;
	uint16_t mii_1000t_ctrl_reg;
	DEBUGFUNC("em_phy_setup_autoneg");

	/* Read the MII Auto-Neg Advertisement Register (Address 4). */
	ret_val = em_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);
	if (ret_val)
		return ret_val;

	if (hw->phy_type != em_phy_ife) {
		/* Read the MII 1000Base-T Control Register (Address 9). */
		ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, 
		    &mii_1000t_ctrl_reg);
		if (ret_val)
			return ret_val;
	} else
		mii_1000t_ctrl_reg = 0;
	/*
	 * Need to parse both autoneg_advertised and fc and set up the
	 * appropriate PHY registers.  First we will parse for
	 * autoneg_advertised software override.  Since we can advertise a
	 * plethora of combinations, we need to check each bit individually.
	 */
	/*
	 * First we clear all the 10/100 mb speed bits in the Auto-Neg
	 * Advertisement Register (Address 4) and the 1000 mb speed bits in
	 * the  1000Base-T Control Register (Address 9).
	 */
	mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
	mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;

	DEBUGOUT1("autoneg_advertised %x\n", hw->autoneg_advertised);

	/* Do we want to advertise 10 Mb Half Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_10_HALF) {
		DEBUGOUT("Advertise 10mb Half duplex\n");
		mii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;
	}
	/* Do we want to advertise 10 Mb Full Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_10_FULL) {
		DEBUGOUT("Advertise 10mb Full duplex\n");
		mii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;
	}
	/* Do we want to advertise 100 Mb Half Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_100_HALF) {
		DEBUGOUT("Advertise 100mb Half duplex\n");
		mii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;
	}
	/* Do we want to advertise 100 Mb Full Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_100_FULL) {
		DEBUGOUT("Advertise 100mb Full duplex\n");
		mii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;
	}
	/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
	if (hw->autoneg_advertised & ADVERTISE_1000_HALF) {
		DEBUGOUT("Advertise 1000mb Half duplex requested, request"
		    " denied!\n");
	}
	/* Do we want to advertise 1000 Mb Full Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_1000_FULL) {
		DEBUGOUT("Advertise 1000mb Full duplex\n");
		mii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;
		if (hw->phy_type == em_phy_ife) {
			DEBUGOUT("em_phy_ife is a 10/100 PHY. Gigabit speed is"
			    " not supported.\n");
		}
	}
	/*
	 * Check for a software override of the flow control settings, and
	 * setup the PHY advertisement registers accordingly.  If
	 * auto-negotiation is enabled, then software will have to set the
	 * "PAUSE" bits to the correct value in the Auto-Negotiation
	 * Advertisement Register (PHY_AUTONEG_ADV) and re-start
	 * auto-negotiation.
	 *
	 * The possible values of the "fc" parameter are: 0:  Flow control is
	 * completely disabled 1:  Rx flow control is enabled (we can receive
	 * pause frames but not send pause frames). 2:  Tx flow control is
	 * enabled (we can send pause frames but we do not support receiving
	 * pause frames). 3:  Both Rx and TX flow control (symmetric) are
	 * enabled. other:  No software override.  The flow control
	 * configuration in the EEPROM is used.
	 */
	switch (hw->fc) {
	case E1000_FC_NONE:	/* 0 */
		/*
		 * Flow control (RX & TX) is completely disabled by a
		 * software over-ride.
		 */
		mii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
		break;
	case E1000_FC_RX_PAUSE:/* 1 */
		/*
		 * RX Flow control is enabled, and TX Flow control is
		 * disabled, by a software over-ride.
		 */
		/*
		 * Since there really isn't a way to advertise that we are
		 * capable of RX Pause ONLY, we will advertise that we
		 * support both symmetric and asymmetric RX PAUSE.  Later (in
		 * em_config_fc_after_link_up) we will disable the hw's
		 * ability to send PAUSE frames.
		 */
		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
		break;
	case E1000_FC_TX_PAUSE:/* 2 */
		/*
		 * TX Flow control is enabled, and RX Flow control is
		 * disabled, by a software over-ride.
		 */
		mii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;
		mii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;
		break;
	case E1000_FC_FULL:	/* 3 */
		/*
		 * Flow control (both RX and TX) is enabled by a software
		 * over-ride.
		 */
		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
		break;
	default:
		DEBUGOUT("Flow control param set incorrectly\n");
		return -E1000_ERR_CONFIG;
	}

	ret_val = em_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);
	if (ret_val)
		return ret_val;

	DEBUGOUT1("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);

	if (hw->phy_type != em_phy_ife) {
		ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL,
		    mii_1000t_ctrl_reg);
		if (ret_val)
			return ret_val;
	}
	return E1000_SUCCESS;
}
/******************************************************************************
 * Force PHY speed and duplex settings to hw->forced_speed_duplex
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_phy_force_speed_duplex(struct em_hw *hw)
{
	uint32_t ctrl;
	int32_t  ret_val;
	uint16_t mii_ctrl_reg;
	uint16_t mii_status_reg;
	uint16_t phy_data;
	uint16_t i;
	DEBUGFUNC("em_phy_force_speed_duplex");

	/* Turn off Flow control if we are forcing speed and duplex. */
	hw->fc = E1000_FC_NONE;

	DEBUGOUT1("hw->fc = %d\n", hw->fc);

	/* Read the Device Control Register. */
	ctrl = E1000_READ_REG(hw, CTRL);

	/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
	ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
	ctrl &= ~(DEVICE_SPEED_MASK);

	/* Clear the Auto Speed Detect Enable bit. */
	ctrl &= ~E1000_CTRL_ASDE;

	/* Read the MII Control Register. */
	ret_val = em_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg);
	if (ret_val)
		return ret_val;

	/* We need to disable autoneg in order to force link and duplex. */

	mii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;

	/* Are we forcing Full or Half Duplex? */
	if (hw->forced_speed_duplex == em_100_full ||
	    hw->forced_speed_duplex == em_10_full) {
		/*
		 * We want to force full duplex so we SET the full duplex
		 * bits in the Device and MII Control Registers.
		 */
		ctrl |= E1000_CTRL_FD;
		mii_ctrl_reg |= MII_CR_FULL_DUPLEX;
		DEBUGOUT("Full Duplex\n");
	} else {
		/*
		 * We want to force half duplex so we CLEAR the full duplex
		 * bits in the Device and MII Control Registers.
		 */
		ctrl &= ~E1000_CTRL_FD;
		mii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;
		DEBUGOUT("Half Duplex\n");
	}

	/* Are we forcing 100Mbps??? */
	if (hw->forced_speed_duplex == em_100_full ||
	    hw->forced_speed_duplex == em_100_half) {
		/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
		ctrl |= E1000_CTRL_SPD_100;
		mii_ctrl_reg |= MII_CR_SPEED_100;
		mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);
		DEBUGOUT("Forcing 100mb ");
	} else {
		/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
		ctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
		mii_ctrl_reg |= MII_CR_SPEED_10;
		mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);
		DEBUGOUT("Forcing 10mb ");
	}

	em_config_collision_dist(hw);

	/* Write the configured values back to the Device Control Reg. */
	E1000_WRITE_REG(hw, CTRL, ctrl);

	if ((hw->phy_type == em_phy_m88) ||
	    (hw->phy_type == em_phy_gg82563) ||
	    (hw->phy_type == em_phy_bm) ||
	    (hw->phy_type == em_phy_oem ||
	    (hw->phy_type == em_phy_82578))) {
		ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
		    &phy_data);
		if (ret_val)
			return ret_val;
		/*
		 * Clear Auto-Crossover to force MDI manually. M88E1000
		 * requires MDI forced whenever speed are duplex are forced.
		 */
		phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
		ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
		    phy_data);
		if (ret_val)
			return ret_val;

		DEBUGOUT1("M88E1000 PSCR: %x \n", phy_data);

		/* Need to reset the PHY or these changes will be ignored */
		mii_ctrl_reg |= MII_CR_RESET;

	}
	else if (hw->phy_type == em_phy_rtl8211) {
		ret_val = em_read_phy_reg_ex(hw, RGEPHY_CR, &phy_data);
		if(ret_val) {
			printf("Unable to read RGEPHY_CR register\n"
			    );
			return ret_val;
		}

		/*
		 * Clear Auto-Crossover to force MDI manually. RTL8211 requires
		 * MDI forced whenever speed are duplex are forced.
		 */

		phy_data |= RGEPHY_CR_MDI_MASK;  // enable MDIX
		ret_val = em_write_phy_reg_ex(hw, RGEPHY_CR, phy_data);
		if(ret_val) {
			printf("Unable to write RGEPHY_CR register\n");
			return ret_val;
		}
		mii_ctrl_reg |= MII_CR_RESET;

	}
	/* Disable MDI-X support for 10/100 */
	else if (hw->phy_type == em_phy_ife) {
		ret_val = em_read_phy_reg(hw, IFE_PHY_MDIX_CONTROL, &phy_data);
		if (ret_val)
			return ret_val;

		phy_data &= ~IFE_PMC_AUTO_MDIX;
		phy_data &= ~IFE_PMC_FORCE_MDIX;

		ret_val = em_write_phy_reg(hw, IFE_PHY_MDIX_CONTROL, phy_data);
		if (ret_val)
			return ret_val;
	} else {
		/*
		 * Clear Auto-Crossover to force MDI manually.  IGP requires
		 * MDI forced whenever speed or duplex are forced.
		 */
		ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
		    &phy_data);
		if (ret_val)
			return ret_val;

		phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
		phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;

		ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
		    phy_data);
		if (ret_val)
			return ret_val;
	}

	/* Write back the modified PHY MII control register. */
	ret_val = em_write_phy_reg(hw, PHY_CTRL, mii_ctrl_reg);
	if (ret_val)
		return ret_val;

	usec_delay(1);
	/*
	 * The wait_autoneg_complete flag may be a little misleading here.
	 * Since we are forcing speed and duplex, Auto-Neg is not enabled.
	 * But we do want to delay for a period while forcing only so we
	 * don't generate false No Link messages.  So we will wait here only
	 * if the user has set wait_autoneg_complete to 1, which is the
	 * default.
	 */
	if (hw->wait_autoneg_complete) {
		/* We will wait for autoneg to complete. */
		DEBUGOUT("Waiting for forced speed/duplex link.\n");
		mii_status_reg = 0;
		/*
		 * We will wait for autoneg to complete or 4.5 seconds to
		 * expire.
		 */
		for (i = PHY_FORCE_TIME; i > 0; i--) {
			/*
			 * Read the MII Status Register and wait for Auto-Neg
			 * Complete bit to be set.
			 */
			ret_val = em_read_phy_reg(hw, PHY_STATUS,
			    &mii_status_reg);
			if (ret_val)
				return ret_val;

			ret_val = em_read_phy_reg(hw, PHY_STATUS,
			    &mii_status_reg);
			if (ret_val)
				return ret_val;

			if (mii_status_reg & MII_SR_LINK_STATUS)
				break;
			msec_delay(100);
		}
		if ((i == 0) &&
		    ((hw->phy_type == em_phy_m88) ||
		    (hw->phy_type == em_phy_gg82563) ||
		    (hw->phy_type == em_phy_bm))) {
			/*
			 * We didn't get link.  Reset the DSP and wait again
			 * for link.
			 */
			ret_val = em_phy_reset_dsp(hw);
			if (ret_val) {
				DEBUGOUT("Error Resetting PHY DSP\n");
				return ret_val;
			}
		}
		/*
		 * This loop will early-out if the link condition has been
		 * met.
		 */
		for (i = PHY_FORCE_TIME; i > 0; i--) {
			if (mii_status_reg & MII_SR_LINK_STATUS)
				break;
			msec_delay(100);
			/*
			 * Read the MII Status Register and wait for Auto-Neg
			 * Complete bit to be set.
			 */
			ret_val = em_read_phy_reg(hw, PHY_STATUS,
			    &mii_status_reg);
			if (ret_val)
				return ret_val;

			ret_val = em_read_phy_reg(hw, PHY_STATUS,
			    &mii_status_reg);
			if (ret_val)
				return ret_val;
		}
	}
	if (hw->phy_type == em_phy_m88 ||
	    hw->phy_type == em_phy_bm ||
	    hw->phy_type == em_phy_oem) {
		/*
		 * Because we reset the PHY above, we need to re-force TX_CLK
		 * in the Extended PHY Specific Control Register to 25MHz
		 * clock.  This value defaults back to a 2.5MHz clock when
		 * the PHY is reset.
		 */
		ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
		    &phy_data);
		if (ret_val)
			return ret_val;

		phy_data |= M88E1000_EPSCR_TX_CLK_25;
		ret_val = em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
		    phy_data);
		if (ret_val)
			return ret_val;
		/*
		 * In addition, because of the s/w reset above, we need to
		 * enable CRS on TX.  This must be set for both full and half
		 * duplex operation.
		 */
		ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
		    &phy_data);
		if (ret_val)
			return ret_val;

		if (hw->phy_id == M88E1141_E_PHY_ID)
			phy_data &= ~M88E1000_PSCR_ASSERT_CRS_ON_TX;
		else
			phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;

		ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
		    phy_data);
		if (ret_val)
			return ret_val;

		if ((hw->mac_type == em_82544 || hw->mac_type == em_82543) &&
		    (!hw->autoneg) && (hw->forced_speed_duplex == em_10_full ||
		    hw->forced_speed_duplex == em_10_half)) {
			ret_val = em_polarity_reversal_workaround(hw);
			if (ret_val)
				return ret_val;
		}
	} else if (hw->phy_type == em_phy_rtl8211) {
		/*
		* In addition, because of the s/w reset above, we need to enable
		* CRX on TX.  This must be set for both full and half duplex
		* operation.
		*/

		ret_val = em_read_phy_reg_ex(hw, RGEPHY_CR, &phy_data);
		if(ret_val) {
			printf("Unable to read RGEPHY_CR register\n");
			return ret_val;
		}

		phy_data &= ~RGEPHY_CR_ASSERT_CRS;
		ret_val = em_write_phy_reg_ex(hw, RGEPHY_CR, phy_data);
		if(ret_val) {
			printf("Unable to write RGEPHY_CR register\n");
			return ret_val;
		}
	} else if (hw->phy_type == em_phy_gg82563) {
		/*
		 * The TX_CLK of the Extended PHY Specific Control Register
		 * defaults to 2.5MHz on a reset.  We need to re-force it
		 * back to 25MHz, if we're not in a forced 10/duplex
		 * configuration.
		 */
		ret_val = em_read_phy_reg(hw, GG82563_PHY_MAC_SPEC_CTRL,
		    &phy_data);
		if (ret_val)
			return ret_val;

		phy_data &= ~GG82563_MSCR_TX_CLK_MASK;
		if ((hw->forced_speed_duplex == em_10_full) ||
		    (hw->forced_speed_duplex == em_10_half))
			phy_data |= GG82563_MSCR_TX_CLK_10MBPS_2_5MHZ;
		else
			phy_data |= GG82563_MSCR_TX_CLK_100MBPS_25MHZ;

		/* Also due to the reset, we need to enable CRS on Tx. */
		phy_data |= GG82563_MSCR_ASSERT_CRS_ON_TX;

		ret_val = em_write_phy_reg(hw, GG82563_PHY_MAC_SPEC_CTRL,
		    phy_data);
		if (ret_val)
			return ret_val;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Sets the collision distance in the Transmit Control register
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Link should have been established previously. Reads the speed and duplex
 * information from the Device Status register.
 *****************************************************************************/
void
em_config_collision_dist(struct em_hw *hw)
{
	uint32_t tctl, coll_dist;
	DEBUGFUNC("em_config_collision_dist");

	if (hw->mac_type < em_82543)
		coll_dist = E1000_COLLISION_DISTANCE_82542;
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = E1000_READ_REG(hw, TCTL);

	tctl &= ~E1000_TCTL_COLD;
	tctl |= coll_dist << E1000_COLD_SHIFT;

	E1000_WRITE_REG(hw, TCTL, tctl);
	E1000_WRITE_FLUSH(hw);
}

/******************************************************************************
 * Sets MAC speed and duplex settings to reflect the those in the PHY
 *
 * hw - Struct containing variables accessed by shared code
 * mii_reg - data to write to the MII control register
 *
 * The contents of the PHY register containing the needed information need to
 * be passed in.
 *****************************************************************************/
static int32_t
em_config_mac_to_phy(struct em_hw *hw)
{
	uint32_t ctrl;
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_config_mac_to_phy");
	/*
	 * 82544 or newer MAC, Auto Speed Detection takes care of MAC
	 * speed/duplex configuration.
	 */
	if (hw->mac_type >= em_82544
	    && hw->mac_type != em_icp_xxxx)
		return E1000_SUCCESS;
	/*
	 * Read the Device Control Register and set the bits to Force Speed
	 * and Duplex.
	 */
	ctrl = E1000_READ_REG(hw, CTRL);
	ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
	ctrl &= ~(E1000_CTRL_SPD_SEL | E1000_CTRL_ILOS);
	/*
	 * Set up duplex in the Device Control and Transmit Control registers
	 * depending on negotiated values.
	 */
	ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
	if (ret_val)
		return ret_val;

	if (phy_data & M88E1000_PSSR_DPLX)
		ctrl |= E1000_CTRL_FD;
	else
		ctrl &= ~E1000_CTRL_FD;

	em_config_collision_dist(hw);
	/*
	 * Set up speed in the Device Control register depending on
	 * negotiated values.
	 */
	if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
		ctrl |= E1000_CTRL_SPD_1000;
	else if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
		ctrl |= E1000_CTRL_SPD_100;

	/* Write the configured values back to the Device Control Reg. */
	E1000_WRITE_REG(hw, CTRL, ctrl);
	return E1000_SUCCESS;
}

/******************************************************************************
 * Forces the MAC's flow control settings.
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Sets the TFCE and RFCE bits in the device control register to reflect
 * the adapter settings. TFCE and RFCE need to be explicitly set by
 * software when a Copper PHY is used because autonegotiation is managed
 * by the PHY rather than the MAC. Software must also configure these
 * bits when link is forced on a fiber connection.
 *****************************************************************************/
int32_t
em_force_mac_fc(struct em_hw *hw)
{
	uint32_t ctrl;
	DEBUGFUNC("em_force_mac_fc");

	/* Get the current configuration of the Device Control Register */
	ctrl = E1000_READ_REG(hw, CTRL);
	/*
	 * Because we didn't get link via the internal auto-negotiation
	 * mechanism (we either forced link or we got link via PHY auto-neg),
	 * we have to manually enable/disable transmit an receive flow
	 * control.
	 *
	 * The "Case" statement below enables/disable flow control according to
	 * the "hw->fc" parameter.
	 *
	 * The possible values of the "fc" parameter are: 0:  Flow control is
	 * completely disabled 1:  Rx flow control is enabled (we can receive
	 * pause frames but not send pause frames). 2:  Tx flow control is
	 * enabled (we can send pause frames frames but we do not receive
	 * pause frames). 3:  Both Rx and TX flow control (symmetric) is
	 * enabled. other:  No other values should be possible at this point.
	 */

	switch (hw->fc) {
	case E1000_FC_NONE:
		ctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));
		break;
	case E1000_FC_RX_PAUSE:
		ctrl &= (~E1000_CTRL_TFCE);
		ctrl |= E1000_CTRL_RFCE;
		break;
	case E1000_FC_TX_PAUSE:
		ctrl &= (~E1000_CTRL_RFCE);
		ctrl |= E1000_CTRL_TFCE;
		break;
	case E1000_FC_FULL:
		ctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);
		break;
	default:
		DEBUGOUT("Flow control param set incorrectly\n");
		return -E1000_ERR_CONFIG;
	}

	/* Disable TX Flow Control for 82542 (rev 2.0) */
	if (hw->mac_type == em_82542_rev2_0)
		ctrl &= (~E1000_CTRL_TFCE);

	E1000_WRITE_REG(hw, CTRL, ctrl);
	return E1000_SUCCESS;
}
/******************************************************************************
 * Configures flow control settings after link is established
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Should be called immediately after a valid link has been established.
 * Forces MAC flow control settings if link was forced. When in MII/GMII mode
 * and autonegotiation is enabled, the MAC flow control settings will be set
 * based on the flow control negotiated by the PHY. In TBI mode, the TFCE
 * and RFCE bits will be automaticaly set to the negotiated flow control mode.
 *****************************************************************************/
STATIC int32_t
em_config_fc_after_link_up(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t mii_status_reg;
	uint16_t mii_nway_adv_reg;
	uint16_t mii_nway_lp_ability_reg;
	uint16_t speed;
	uint16_t duplex;
	DEBUGFUNC("em_config_fc_after_link_up");
	/*
	 * Check for the case where we have fiber media and auto-neg failed
	 * so we had to force link.  In this case, we need to force the
	 * configuration of the MAC to match the "fc" parameter.
	 */
	if (((hw->media_type == em_media_type_fiber) && (hw->autoneg_failed))
	    || ((hw->media_type == em_media_type_internal_serdes) &&
	    (hw->autoneg_failed)) ||
	    ((hw->media_type == em_media_type_copper) && (!hw->autoneg)) ||
	    ((hw->media_type == em_media_type_oem) && (!hw->autoneg))) {
		ret_val = em_force_mac_fc(hw);
		if (ret_val) {
			DEBUGOUT("Error forcing flow control settings\n");
			return ret_val;
		}
	}
	/*
	 * Check for the case where we have copper media and auto-neg is
	 * enabled.  In this case, we need to check and see if Auto-Neg has
	 * completed, and if so, how the PHY and link partner has flow
	 * control configured.
	 */
	if ((hw->media_type == em_media_type_copper ||
	    (hw->media_type == em_media_type_oem)) &&
	    hw->autoneg) {
		/*
		 * Read the MII Status Register and check to see if AutoNeg
		 * has completed.  We read this twice because this reg has
		 * some "sticky" (latched) bits.
		 */
		ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
		if (ret_val)
			return ret_val;
		ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
		if (ret_val)
			return ret_val;

		if (mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
			/*
			 * The AutoNeg process has completed, so we now need
			 * to read both the Auto Negotiation Advertisement
			 * Register (Address 4) and the Auto_Negotiation Base
			 * Page Ability Register (Address 5) to determine how
			 * flow control was negotiated.
			 */
			ret_val = em_read_phy_reg(hw, PHY_AUTONEG_ADV,
			    &mii_nway_adv_reg);
			if (ret_val)
				return ret_val;
			ret_val = em_read_phy_reg(hw, PHY_LP_ABILITY,
			    &mii_nway_lp_ability_reg);
			if (ret_val)
				return ret_val;
			/*
			 * Two bits in the Auto Negotiation Advertisement
			 * Register (Address 4) and two bits in the Auto
			 * Negotiation Base Page Ability Register (Address 5)
			 * determine flow control for both the PHY and the
			 * link partner.  The following table, taken out of
			 * the IEEE 802.3ab/D6.0 dated March 25, 1999,
			 * describes these PAUSE resolution bits and how flow
			 * control is determined based upon these settings.
			 * NOTE:  DC = Don't Care
			 *
			 *   LOCAL DEVICE   |   LINK PARTNER  |
			 *  PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution
			 * -------|---------|-------|---------|---------------
			 *    0   |    0    |  DC   |   DC    | em_fc_none
 			 *    0   |    1    |   0   |   DC    | em_fc_none
			 *    0   |    1    |   1   |    0    | em_fc_none
			 *    0   |    1    |   1   |    1    | em_fc_tx_pause
			 *    1   |    0    |   0   |   DC    | em_fc_none
			 *    1   |   DC    |   1   |   DC    | em_fc_full
			 *    1   |    1    |   0   |    0    | em_fc_none
			 *    1   |    1    |   0   |    1    | em_fc_rx_pause
			 *
			 */
			/*
			 * Are both PAUSE bits set to 1?  If so, this implies
			 * Symmetric Flow Control is enabled at both ends.
			 * The ASM_DIR bits are irrelevant per the spec.
			 *
			 * For Symmetric Flow Control:
			 *
			 *   LOCAL DEVICE  |   LINK PARTNER
			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
			 * -------|---------|-------|---------|---------------
			 *    1   |   DC    |   1   |   DC    | em_fc_full
			 *
			 */
			if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
			    (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {
				/*
				 * Now we need to check if the user selected
				 * RX ONLY of pause frames.  In this case, we
				 * had to advertise FULL flow control because
				 * we could not advertise RX ONLY. Hence, we
				 * must now check to see if we need to turn
				 * OFF  the TRANSMISSION of PAUSE frames.
				 */
				if (hw->original_fc == E1000_FC_FULL) {
					hw->fc = E1000_FC_FULL;
					DEBUGOUT("Flow Control = FULL.\n");
				} else {
					hw->fc = E1000_FC_RX_PAUSE;
					DEBUGOUT("Flow Control = RX PAUSE"
					    " frames only.\n");
				}
			}
			/*
			 * For receiving PAUSE frames ONLY.
			 *
			 * LOCAL DEVICE  |   LINK PARTNER PAUSE | ASM_DIR |
			 * PAUSE | ASM_DIR | Result
			 * -------|---------|-------|---------|---------------
			 * ----- 0   |    1    |   1   |    1    |
			 * em_fc_tx_pause
			 *
			 */
			else if (!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
			    (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
			    (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
			    (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
				hw->fc = E1000_FC_TX_PAUSE;
				DEBUGOUT("Flow Control = TX PAUSE frames only."
				    "\n");
			}
			/*
			 * For transmitting PAUSE frames ONLY.
			 *
			 *    LOCAL DEVICE  |   LINK PARTNER
			 *  PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
			 * -------|---------|-------|---------|---------------
			 *    1   |    1    |   0   |    1    | em_fc_rx_pause
			 *
			 */
			else if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
			    (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
			    !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
			    (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
				hw->fc = E1000_FC_RX_PAUSE;
				DEBUGOUT("Flow Control = RX PAUSE frames only."
				    "\n");
			}
			/*
			 * Per the IEEE spec, at this point flow control
			 * should be disabled.  However, we want to consider
			 * that we could be connected to a legacy switch that
			 * doesn't advertise desired flow control, but can be
			 * forced on the link partner.  So if we advertised
			 * no flow control, that is what we will resolve to.
			 * If we advertised some kind of receive capability
			 * (Rx Pause Only or Full Flow Control) and the link
			 * partner advertised none, we will configure
			 * ourselves to enable Rx Flow Control only.  We can
			 * do this safely for two reasons:  If the link
			 * partner really didn't want flow control enabled,
			 * and we enable Rx, no harm done since we won't be
			 * receiving any PAUSE frames anyway.  If the intent
			 * on the link partner was to have flow control
			 * enabled, then by us enabling RX only, we can at
			 * least receive pause frames and process them. This
			 * is a good idea because in most cases, since we are
			 * predominantly a server NIC, more times than not we
			 * will be asked to delay transmission of packets
			 * than asking our link partner to pause transmission
			 * of frames.
			 */
			else if ((hw->original_fc == E1000_FC_NONE ||
			    hw->original_fc == E1000_FC_TX_PAUSE) ||
			    hw->fc_strict_ieee) {
				hw->fc = E1000_FC_NONE;
				DEBUGOUT("Flow Control = NONE.\n");
			} else {
				hw->fc = E1000_FC_RX_PAUSE;
				DEBUGOUT("Flow Control = RX PAUSE frames only."
				    "\n");
			}
			/*
			 * Now we need to do one last check...  If we auto-
			 * negotiated to HALF DUPLEX, flow control should not
			 * be enabled per IEEE 802.3 spec.
			 */
			ret_val = em_get_speed_and_duplex(hw, &speed, &duplex);
			if (ret_val) {
				DEBUGOUT("Error getting link speed and duplex"
				    "\n");
				return ret_val;
			}
			if (duplex == HALF_DUPLEX)
				hw->fc = E1000_FC_NONE;
			/*
			 * Now we call a subroutine to actually force the MAC
			 * controller to use the correct flow control
			 * settings.
			 */
			ret_val = em_force_mac_fc(hw);
			if (ret_val) {
				DEBUGOUT("Error forcing flow control settings"
				    "\n");
				return ret_val;
			}
		} else {
			DEBUGOUT("Copper PHY and Auto Neg has not completed."
			    "\n");
		}
	}
	return E1000_SUCCESS;
}
/******************************************************************************
 * Checks to see if the link status of the hardware has changed.
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Called by any function that needs to check the link status of the adapter.
 *****************************************************************************/
int32_t
em_check_for_link(struct em_hw *hw)
{
	uint32_t rxcw = 0;
	uint32_t ctrl;
	uint32_t status;
	uint32_t rctl;
	uint32_t icr;
	uint32_t signal = 0;
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_check_for_link");
	uint16_t speed, duplex;

	if (hw->mac_type >= em_82575 &&
	    hw->media_type != em_media_type_copper) {
		ret_val = em_get_pcs_speed_and_duplex_82575(hw, &speed,
		    &duplex);
		hw->get_link_status = hw->serdes_link_down;

		return (ret_val);
	}

	ctrl = E1000_READ_REG(hw, CTRL);
	status = E1000_READ_REG(hw, STATUS);
	/*
	 * On adapters with a MAC newer than 82544, SW Defineable pin 1 will
	 * be set when the optics detect a signal. On older adapters, it will
	 * be cleared when there is a signal.  This applies to fiber media
	 * only.
	 */
	if ((hw->media_type == em_media_type_fiber) ||
	    (hw->media_type == em_media_type_internal_serdes)) {
		rxcw = E1000_READ_REG(hw, RXCW);

		if (hw->media_type == em_media_type_fiber) {
			signal = (hw->mac_type > em_82544) ? 
			    E1000_CTRL_SWDPIN1 : 0;
			if (status & E1000_STATUS_LU)
				hw->get_link_status = FALSE;
		}
	}
	/*
	 * If we have a copper PHY then we only want to go out to the PHY
	 * registers to see if Auto-Neg has completed and/or if our link
	 * status has changed.  The get_link_status flag will be set if we
	 * receive a Link Status Change interrupt or we have Rx Sequence
	 * Errors.
	 */
	if ((hw->media_type == em_media_type_copper ||
	    (hw->media_type == em_media_type_oem)) &&
	    hw->get_link_status) {
		/*
		 * First we want to see if the MII Status Register reports
		 * link.  If so, then we want to get the current speed/duplex
		 * of the PHY. Read the register twice since the link bit is
		 * sticky.
		 */
		ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;
		ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		hw->icp_xxxx_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;

		if (hw->mac_type == em_pchlan) {
			ret_val = em_k1_gig_workaround_hv(hw,
			    hw->icp_xxxx_is_link_up);
			if (ret_val)
				return ret_val;
		}

		if (phy_data & MII_SR_LINK_STATUS) {
			hw->get_link_status = FALSE;

			if (hw->phy_type == em_phy_82578) {
				ret_val = em_link_stall_workaround_hv(hw);
				if (ret_val)
					return ret_val;
			}

			if (hw->mac_type == em_pch2lan) {
				ret_val = em_k1_workaround_lv(hw);
				if (ret_val)
					return ret_val;
			}
			/* Work-around I218 hang issue */
			if ((hw->device_id == E1000_DEV_ID_PCH_LPTLP_I218_LM) ||
			    (hw->device_id == E1000_DEV_ID_PCH_LPTLP_I218_V) ||
			    (hw->device_id == E1000_DEV_ID_PCH_I218_LM3) ||
			    (hw->device_id == E1000_DEV_ID_PCH_I218_V3)) {
				ret_val = em_k1_workaround_lpt_lp(hw,
				    hw->icp_xxxx_is_link_up);
				if (ret_val)
					return ret_val;
			}

			/*
			 * Check if there was DownShift, must be checked
			 * immediately after link-up
			 */
			em_check_downshift(hw);

			/* Enable/Disable EEE after link up */
			if (hw->mac_type == em_pch2lan ||
			    hw->mac_type == em_pch_lpt ||
			    hw->mac_type == em_pch_spt) {
				ret_val = em_set_eee_pchlan(hw);
				if (ret_val)
					return ret_val;
			}

			/*
			 * If we are on 82544 or 82543 silicon and
			 * speed/duplex are forced to 10H or 10F, then we
			 * will implement the polarity reversal workaround.
			 * We disable interrupts first, and upon returning,
			 * place the devices interrupt state to its previous
			 * value except for the link status change interrupt
			 * which will happen due to the execution of this
			 * workaround.
			 */
			if ((hw->mac_type == em_82544 ||
			    hw->mac_type == em_82543) && (!hw->autoneg) &&
			    (hw->forced_speed_duplex == em_10_full ||
			    hw->forced_speed_duplex == em_10_half)) {
				E1000_WRITE_REG(hw, IMC, 0xffffffff);
				ret_val = em_polarity_reversal_workaround(hw);
				icr = E1000_READ_REG(hw, ICR);
				E1000_WRITE_REG(hw, ICS, 
				    (icr & ~E1000_ICS_LSC));
				E1000_WRITE_REG(hw, IMS, IMS_ENABLE_MASK);
			}
		} else {
			/* No link detected */
			em_config_dsp_after_link_change(hw, FALSE);
			return 0;
		}
		/*
		 * If we are forcing speed/duplex, then we simply return
		 * since we have already determined whether we have link or
		 * not.
		 */
		if (!hw->autoneg)
			return -E1000_ERR_CONFIG;

		/* optimize the dsp settings for the igp phy */
		em_config_dsp_after_link_change(hw, TRUE);
		/*
		 * We have a M88E1000 PHY and Auto-Neg is enabled.  If we
		 * have Si on board that is 82544 or newer, Auto Speed
		 * Detection takes care of MAC speed/duplex configuration.
		 * So we only need to configure Collision Distance in the
		 * MAC.  Otherwise, we need to force speed/duplex on the MAC
		 * to the current PHY speed/duplex settings.
		 */
		if (hw->mac_type >= em_82544 && hw->mac_type != em_icp_xxxx) {
			em_config_collision_dist(hw);
		} else {
			ret_val = em_config_mac_to_phy(hw);
			if (ret_val) {
				DEBUGOUT("Error configuring MAC to PHY"
				    " settings\n");
				return ret_val;
			}
		}
		/*
		 * Configure Flow Control now that Auto-Neg has completed.
		 * First, we need to restore the desired flow control
		 * settings because we may have had to re-autoneg with a
		 * different link partner.
		 */
		ret_val = em_config_fc_after_link_up(hw);
		if (ret_val) {
			DEBUGOUT("Error configuring flow control\n");
			return ret_val;
		}
		/*
		 * At this point we know that we are on copper and we have
		 * auto-negotiated link.  These are conditions for checking
		 * the link partner capability register.  We use the link
		 * speed to determine if TBI compatibility needs to be turned
		 * on or off.  If the link is not at gigabit speed, then TBI
		 * compatibility is not needed.  If we are at gigabit speed,
		 * we turn on TBI compatibility.
		 */
		if (hw->tbi_compatibility_en) {
			uint16_t speed, duplex;
			ret_val = em_get_speed_and_duplex(hw, &speed, &duplex);
			if (ret_val) {
				DEBUGOUT("Error getting link speed and duplex"
				    "\n");
				return ret_val;
			}
			if (speed != SPEED_1000) {
				/*
				 * If link speed is not set to gigabit speed,
				 * we do not need to enable TBI
				 * compatibility.
				 */
				if (hw->tbi_compatibility_on) {
					/*
					 * If we previously were in the mode,
					 * turn it off.
					 */
					rctl = E1000_READ_REG(hw, RCTL);
					rctl &= ~E1000_RCTL_SBP;
					E1000_WRITE_REG(hw, RCTL, rctl);
					hw->tbi_compatibility_on = FALSE;
				}
			} else {
				/*
				 * If TBI compatibility is was previously
				 * off, turn it on. For compatibility with a
				 * TBI link partner, we will store bad
				 * packets. Some frames have an additional
				 * byte on the end and will look like CRC
				 * errors to to the hardware.
				 */
				if (!hw->tbi_compatibility_on) {
					hw->tbi_compatibility_on = TRUE;
					rctl = E1000_READ_REG(hw, RCTL);
					rctl |= E1000_RCTL_SBP;
					E1000_WRITE_REG(hw, RCTL, rctl);
				}
			}
		}
	}
	/*
	 * If we don't have link (auto-negotiation failed or link partner
	 * cannot auto-negotiate), the cable is plugged in (we have signal),
	 * and our link partner is not trying to auto-negotiate with us (we
	 * are receiving idles or data), we need to force link up. We also
	 * need to give auto-negotiation time to complete, in case the cable
	 * was just plugged in. The autoneg_failed flag does this.
	 */
	else if ((((hw->media_type == em_media_type_fiber) &&
	    ((ctrl & E1000_CTRL_SWDPIN1) == signal)) ||
	    (hw->media_type == em_media_type_internal_serdes)) &&
	    (!(status & E1000_STATUS_LU)) && (!(rxcw & E1000_RXCW_C))) {
		if (hw->autoneg_failed == 0) {
			hw->autoneg_failed = 1;
			return 0;
		}
		DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\n");

		/* Disable auto-negotiation in the TXCW register */
		E1000_WRITE_REG(hw, TXCW, (hw->txcw & ~E1000_TXCW_ANE));

		/* Force link-up and also force full-duplex. */
		ctrl = E1000_READ_REG(hw, CTRL);
		ctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);
		E1000_WRITE_REG(hw, CTRL, ctrl);

		/* Configure Flow Control after forcing link up. */
		ret_val = em_config_fc_after_link_up(hw);
		if (ret_val) {
			DEBUGOUT("Error configuring flow control\n");
			return ret_val;
		}
	}
	/*
	 * If we are forcing link and we are receiving /C/ ordered sets,
	 * re-enable auto-negotiation in the TXCW register and disable forced
	 * link in the Device Control register in an attempt to
	 * auto-negotiate with our link partner.
	 */
	else if (((hw->media_type == em_media_type_fiber) ||
	    (hw->media_type == em_media_type_internal_serdes)) &&
	    (ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {
		DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\n");
		E1000_WRITE_REG(hw, TXCW, hw->txcw);
		E1000_WRITE_REG(hw, CTRL, (ctrl & ~E1000_CTRL_SLU));

		hw->serdes_link_down = FALSE;
	}
	/*
	 * If we force link for non-auto-negotiation switch, check link
	 * status based on MAC synchronization for internal serdes media
	 * type.
	 */
	else if ((hw->media_type == em_media_type_internal_serdes) &&
	    !(E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
		/* SYNCH bit and IV bit are sticky. */
		usec_delay(10);
		if (E1000_RXCW_SYNCH & E1000_READ_REG(hw, RXCW)) {
			if (!(rxcw & E1000_RXCW_IV)) {
				hw->serdes_link_down = FALSE;
				DEBUGOUT("SERDES: Link is up.\n");
			}
		} else {
			hw->serdes_link_down = TRUE;
			DEBUGOUT("SERDES: Link is down.\n");
		}
	}
	if ((hw->media_type == em_media_type_internal_serdes) &&
	    (E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
		hw->serdes_link_down = !(E1000_STATUS_LU & 
		    E1000_READ_REG(hw, STATUS));
	}
	return E1000_SUCCESS;
}

int32_t
em_get_pcs_speed_and_duplex_82575(struct em_hw *hw, uint16_t *speed,
    uint16_t *duplex)
{
	uint32_t pcs;

	hw->serdes_link_down = TRUE;
	*speed = 0;
	*duplex = 0;

	/*
	 * Read the PCS Status register for link state. For non-copper mode,
	 * the status register is not accurate. The PCS status register is
	 * used instead.
	 */
	pcs = E1000_READ_REG(hw, PCS_LSTAT);

	/*
	 * The link up bit determines when link is up on autoneg. The sync ok
	 * gets set once both sides sync up and agree upon link. Stable link
	 * can be determined by checking for both link up and link sync ok
	 */
	if ((pcs & E1000_PCS_LSTS_LINK_OK) && (pcs & E1000_PCS_LSTS_SYNK_OK)) {
		hw->serdes_link_down = FALSE;
	
		/* Detect and store PCS speed */
		if (pcs & E1000_PCS_LSTS_SPEED_1000) {
			*speed = SPEED_1000;
		} else if (pcs & E1000_PCS_LSTS_SPEED_100) {
			*speed = SPEED_100;
		} else {
			*speed = SPEED_10;
		}

		/* Detect and store PCS duplex */
		if (pcs & E1000_PCS_LSTS_DUPLEX_FULL) {
			*duplex = FULL_DUPLEX;
		} else {
			*duplex = HALF_DUPLEX;
		}
	}

	return (0);
}


/******************************************************************************
 * Detects the current speed and duplex settings of the hardware.
 *
 * hw - Struct containing variables accessed by shared code
 * speed - Speed of the connection
 * duplex - Duplex setting of the connection
 *****************************************************************************/
int32_t
em_get_speed_and_duplex(struct em_hw *hw, uint16_t *speed, uint16_t *duplex)
{
	uint32_t status;
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_get_speed_and_duplex");

	if (hw->mac_type >= em_82575 && hw->media_type != em_media_type_copper)
		return em_get_pcs_speed_and_duplex_82575(hw, speed, duplex);

	if (hw->mac_type >= em_82543) {
		status = E1000_READ_REG(hw, STATUS);
		if (status & E1000_STATUS_SPEED_1000) {
			*speed = SPEED_1000;
			DEBUGOUT("1000 Mbs, ");
		} else if (status & E1000_STATUS_SPEED_100) {
			*speed = SPEED_100;
			DEBUGOUT("100 Mbs, ");
		} else {
			*speed = SPEED_10;
			DEBUGOUT("10 Mbs, ");
		}

		if (status & E1000_STATUS_FD) {
			*duplex = FULL_DUPLEX;
			DEBUGOUT("Full Duplex\n");
		} else {
			*duplex = HALF_DUPLEX;
			DEBUGOUT(" Half Duplex\n");
		}
	} else {
		DEBUGOUT("1000 Mbs, Full Duplex\n");
		*speed = SPEED_1000;
		*duplex = FULL_DUPLEX;
	}
	/*
	 * IGP01 PHY may advertise full duplex operation after speed
	 * downgrade even if it is operating at half duplex.  Here we set the
	 * duplex settings to match the duplex in the link partner's
	 * capabilities.
	 */
	if (hw->phy_type == em_phy_igp && hw->speed_downgraded) {
		ret_val = em_read_phy_reg(hw, PHY_AUTONEG_EXP, &phy_data);
		if (ret_val)
			return ret_val;

		if (!(phy_data & NWAY_ER_LP_NWAY_CAPS))
			*duplex = HALF_DUPLEX;
		else {
			ret_val = em_read_phy_reg(hw, PHY_LP_ABILITY,
			    &phy_data);
			if (ret_val)
				return ret_val;
			if ((*speed == SPEED_100 && 
			    !(phy_data & NWAY_LPAR_100TX_FD_CAPS)) ||
			    (*speed == SPEED_10 && 
			    !(phy_data & NWAY_LPAR_10T_FD_CAPS)))
				*duplex = HALF_DUPLEX;
		}
	}
	if ((hw->mac_type == em_80003es2lan) &&
	    (hw->media_type == em_media_type_copper)) {
		if (*speed == SPEED_1000)
			ret_val = em_configure_kmrn_for_1000(hw);
		else
			ret_val = em_configure_kmrn_for_10_100(hw, *duplex);
		if (ret_val)
			return ret_val;
	}
	if ((hw->mac_type == em_ich8lan) &&
	    (hw->phy_type == em_phy_igp_3) &&
	    (*speed == SPEED_1000)) {
		ret_val = em_kumeran_lock_loss_workaround(hw);
		if (ret_val)
			return ret_val;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Blocks until autoneg completes or times out (~4.5 seconds)
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
STATIC int32_t
em_wait_autoneg(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t i;
	uint16_t phy_data;
	DEBUGFUNC("em_wait_autoneg");
	DEBUGOUT("Waiting for Auto-Neg to complete.\n");

	/* We will wait for autoneg to complete or 4.5 seconds to expire. */
	for (i = PHY_AUTO_NEG_TIME; i > 0; i--) {
		/*
		 * Read the MII Status Register and wait for Auto-Neg
		 * Complete bit to be set.
		 */
		ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;
		ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;
		if (phy_data & MII_SR_AUTONEG_COMPLETE) {
			return E1000_SUCCESS;
		}
		msec_delay(100);
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Raises the Management Data Clock
 *
 * hw - Struct containing variables accessed by shared code
 * ctrl - Device control register's current value
 *****************************************************************************/
static void
em_raise_mdi_clk(struct em_hw *hw, uint32_t *ctrl)
{
	/*
	 * Raise the clock input to the Management Data Clock (by setting the
	 * MDC bit), and then delay 10 microseconds.
	 */
	E1000_WRITE_REG(hw, CTRL, (*ctrl | E1000_CTRL_MDC));
	E1000_WRITE_FLUSH(hw);
	usec_delay(10);
}

/******************************************************************************
 * Lowers the Management Data Clock
 *
 * hw - Struct containing variables accessed by shared code
 * ctrl - Device control register's current value
 *****************************************************************************/
static void
em_lower_mdi_clk(struct em_hw *hw, uint32_t *ctrl)
{
	/*
	 * Lower the clock input to the Management Data Clock (by clearing
	 * the MDC bit), and then delay 10 microseconds.
	 */
	E1000_WRITE_REG(hw, CTRL, (*ctrl & ~E1000_CTRL_MDC));
	E1000_WRITE_FLUSH(hw);
	usec_delay(10);
}

/******************************************************************************
 * Shifts data bits out to the PHY
 *
 * hw - Struct containing variables accessed by shared code
 * data - Data to send out to the PHY
 * count - Number of bits to shift out
 *
 * Bits are shifted out in MSB to LSB order.
 *****************************************************************************/
static void
em_shift_out_mdi_bits(struct em_hw *hw, uint32_t data, uint16_t count)
{
	uint32_t ctrl;
	uint32_t mask;
	/*
	 * We need to shift "count" number of bits out to the PHY. So, the
	 * value in the "data" parameter will be shifted out to the PHY one
	 * bit at a time. In order to do this, "data" must be broken down
	 * into bits.
	 */
	mask = 0x01;
	mask <<= (count - 1);

	ctrl = E1000_READ_REG(hw, CTRL);

	/* Set MDIO_DIR and MDC_DIR direction bits to be used as output 
	 * pins. 
	 */
	ctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);

	while (mask) {
		/*
		 * A "1" is shifted out to the PHY by setting the MDIO bit to
		 * "1" and then raising and lowering the Management Data
		 * Clock. A "0" is shifted out to the PHY by setting the MDIO
		 * bit to "0" and then raising and lowering the clock.
		 */
		if (data & mask)
			ctrl |= E1000_CTRL_MDIO;
		else
			ctrl &= ~E1000_CTRL_MDIO;

		E1000_WRITE_REG(hw, CTRL, ctrl);
		E1000_WRITE_FLUSH(hw);

		usec_delay(10);

		em_raise_mdi_clk(hw, &ctrl);
		em_lower_mdi_clk(hw, &ctrl);

		mask = mask >> 1;
	}
}

/******************************************************************************
 * Shifts data bits in from the PHY
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Bits are shifted in in MSB to LSB order.
 *****************************************************************************/
static uint16_t
em_shift_in_mdi_bits(struct em_hw *hw)
{
	uint32_t ctrl;
	uint16_t data = 0;
	uint8_t  i;
	/*
	 * In order to read a register from the PHY, we need to shift in a
	 * total of 18 bits from the PHY. The first two bit (turnaround)
	 * times are used to avoid contention on the MDIO pin when a read
	 * operation is performed. These two bits are ignored by us and
	 * thrown away. Bits are "shifted in" by raising the input to the
	 * Management Data Clock (setting the MDC bit), and then reading the
	 * value of the MDIO bit.
	 */
	ctrl = E1000_READ_REG(hw, CTRL);
	/*
	 * Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as
	 * input.
	 */
	ctrl &= ~E1000_CTRL_MDIO_DIR;
	ctrl &= ~E1000_CTRL_MDIO;

	E1000_WRITE_REG(hw, CTRL, ctrl);
	E1000_WRITE_FLUSH(hw);
	/*
	 * Raise and Lower the clock before reading in the data. This
	 * accounts for the turnaround bits. The first clock occurred when we
	 * clocked out the last bit of the Register Address.
	 */
	em_raise_mdi_clk(hw, &ctrl);
	em_lower_mdi_clk(hw, &ctrl);

	for (data = 0, i = 0; i < 16; i++) {
		data = data << 1;
		em_raise_mdi_clk(hw, &ctrl);
		ctrl = E1000_READ_REG(hw, CTRL);
		/* Check to see if we shifted in a "1". */
		if (ctrl & E1000_CTRL_MDIO)
			data |= 1;
		em_lower_mdi_clk(hw, &ctrl);
	}

	em_raise_mdi_clk(hw, &ctrl);
	em_lower_mdi_clk(hw, &ctrl);

	return data;
}

STATIC int32_t
em_swfw_sync_acquire(struct em_hw *hw, uint16_t mask)
{
	uint32_t swfw_sync = 0;
	uint32_t swmask = mask;
	uint32_t fwmask = mask << 16;
	int32_t  timeout = 200;
	DEBUGFUNC("em_swfw_sync_acquire");

	if (hw->swfwhw_semaphore_present)
		return em_get_software_flag(hw);

	if (!hw->swfw_sync_present)
		return em_get_hw_eeprom_semaphore(hw);

	while (timeout) {
		if (em_get_hw_eeprom_semaphore(hw))
			return -E1000_ERR_SWFW_SYNC;

		swfw_sync = E1000_READ_REG(hw, SW_FW_SYNC);
		if (!(swfw_sync & (fwmask | swmask))) {
			break;
		}
		/* 
		 * firmware currently using resource (fwmask)
		 * or other software thread currently using resource (swmask)
		 */
		em_put_hw_eeprom_semaphore(hw);
		msec_delay_irq(5);
		timeout--;
	}

	if (!timeout) {
		DEBUGOUT("Driver can't access resource, SW_FW_SYNC timeout."
		    "\n");
		return -E1000_ERR_SWFW_SYNC;
	}
	swfw_sync |= swmask;
	E1000_WRITE_REG(hw, SW_FW_SYNC, swfw_sync);

	em_put_hw_eeprom_semaphore(hw);
	return E1000_SUCCESS;
}

STATIC void
em_swfw_sync_release(struct em_hw *hw, uint16_t mask)
{
	uint32_t swfw_sync;
	uint32_t swmask = mask;
	DEBUGFUNC("em_swfw_sync_release");

	if (hw->swfwhw_semaphore_present) {
		em_release_software_flag(hw);
		return;
	}
	if (!hw->swfw_sync_present) {
		em_put_hw_eeprom_semaphore(hw);
		return;
	}
	/*
	 * if (em_get_hw_eeprom_semaphore(hw)) return -E1000_ERR_SWFW_SYNC;
	 */
	while (em_get_hw_eeprom_semaphore(hw) != E1000_SUCCESS);
	/* empty */

	swfw_sync = E1000_READ_REG(hw, SW_FW_SYNC);
	swfw_sync &= ~swmask;
	E1000_WRITE_REG(hw, SW_FW_SYNC, swfw_sync);

	em_put_hw_eeprom_semaphore(hw);
}

/****************************************************************************
 *  Read BM PHY wakeup register.  It works as such:
 *  1) Set page 769, register 17, bit 2 = 1
 *  2) Set page to 800 for host (801 if we were manageability)
 *  3) Write the address using the address opcode (0x11)
 *  4) Read or write the data using the data opcode (0x12)
 *  5) Restore 769_17.2 to its original value
 ****************************************************************************/
int32_t
em_access_phy_wakeup_reg_bm(struct em_hw *hw, uint32_t reg_addr,
    uint16_t *phy_data, boolean_t read)
{
	int32_t ret_val;
	uint16_t reg = BM_PHY_REG_NUM(reg_addr);
	uint16_t phy_reg = 0;

	/* All operations in this function are phy address 1 */
	hw->phy_addr = 1;

	/* Set page 769 */
	em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
	    (BM_WUC_ENABLE_PAGE << PHY_PAGE_SHIFT));

	ret_val = em_read_phy_reg_ex(hw, BM_WUC_ENABLE_REG, &phy_reg);
	if (ret_val)
		goto out;

	/* First clear bit 4 to avoid a power state change */
	phy_reg &= ~(BM_WUC_HOST_WU_BIT);
	ret_val = em_write_phy_reg_ex(hw, BM_WUC_ENABLE_REG, phy_reg);
	if (ret_val)
		goto out;

	/* Write bit 2 = 1, and clear bit 4 to 769_17 */
	ret_val = em_write_phy_reg_ex(hw, BM_WUC_ENABLE_REG,
	    phy_reg | BM_WUC_ENABLE_BIT);
	if (ret_val)
		goto out;

	/* Select page 800 */
	ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
	    (BM_WUC_PAGE << PHY_PAGE_SHIFT));

	/* Write the page 800 offset value using opcode 0x11 */
	ret_val = em_write_phy_reg_ex(hw, BM_WUC_ADDRESS_OPCODE, reg);
	if (ret_val)
		goto out;

	if (read)
	        /* Read the page 800 value using opcode 0x12 */
		ret_val = em_read_phy_reg_ex(hw, BM_WUC_DATA_OPCODE,
		    phy_data);
	else
	        /* Write the page 800 value using opcode 0x12 */
		ret_val = em_write_phy_reg_ex(hw, BM_WUC_DATA_OPCODE,
		    *phy_data);

	if (ret_val)
		goto out;

	/*
	 * Restore 769_17.2 to its original value
	 * Set page 769
	 */
	em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
	    (BM_WUC_ENABLE_PAGE << PHY_PAGE_SHIFT));

	/* Clear 769_17.2 */
	ret_val = em_write_phy_reg_ex(hw, BM_WUC_ENABLE_REG, phy_reg);
	if (ret_val)
		goto out;

out:
	return ret_val;
}

/***************************************************************************
 *  Read HV PHY vendor specific high registers
 ***************************************************************************/
int32_t
em_access_phy_debug_regs_hv(struct em_hw *hw, uint32_t reg_addr,
    uint16_t *phy_data, boolean_t read)
{
	int32_t ret_val;
	uint32_t addr_reg = 0;
	uint32_t data_reg = 0;

	/* This takes care of the difference with desktop vs mobile phy */
	addr_reg = (hw->phy_type == em_phy_82578) ?
	           I82578_PHY_ADDR_REG : I82577_PHY_ADDR_REG;
	data_reg = addr_reg + 1;

	/* All operations in this function are phy address 2 */
	hw->phy_addr = 2;

	/* masking with 0x3F to remove the page from offset */
	ret_val = em_write_phy_reg_ex(hw, addr_reg, (uint16_t)reg_addr & 0x3F);
	if (ret_val) {
		printf("Could not write PHY the HV address register\n");
		goto out;
	}

	/* Read or write the data value next */
	if (read)
		ret_val = em_read_phy_reg_ex(hw, data_reg, phy_data);
	else
		ret_val = em_write_phy_reg_ex(hw, data_reg, *phy_data);

	if (ret_val) {
		printf("Could not read data value from HV data register\n");
		goto out;
	}

out:
	return ret_val;
}

/******************************************************************************
 * Reads or writes the value from a PHY register, if the value is on a specific
 * non zero page, sets the page first.
 * hw - Struct containing variables accessed by shared code
 * reg_addr - address of the PHY register to read
 *****************************************************************************/
int32_t
em_access_phy_reg_hv(struct em_hw *hw, uint32_t reg_addr, uint16_t *phy_data,
    boolean_t read)
{
	uint32_t ret_val;
	uint16_t swfw;
	uint16_t page = BM_PHY_REG_PAGE(reg_addr);
	uint16_t reg = BM_PHY_REG_NUM(reg_addr);

	DEBUGFUNC("em_access_phy_reg_hv");

	swfw = E1000_SWFW_PHY0_SM;

	if (em_swfw_sync_acquire(hw, swfw))
		return -E1000_ERR_SWFW_SYNC;

	if (page == BM_WUC_PAGE) {
		ret_val = em_access_phy_wakeup_reg_bm(hw, reg_addr,
		    phy_data, read);
		goto release;
	}

	if (page >= HV_INTC_FC_PAGE_START)
		hw->phy_addr = 1;
	else
		hw->phy_addr = 2;

	if (page == HV_INTC_FC_PAGE_START)
		page = 0;

	/*
	 * Workaround MDIO accesses being disabled after entering IEEE Power
	 * Down (whenever bit 11 of the PHY Control register is set)
	 */
	if (!read &&
	    (hw->phy_type == em_phy_82578) &&
	    (hw->phy_revision >= 1) &&
	    (hw->phy_addr == 2) &&
	    ((MAX_PHY_REG_ADDRESS & reg) == 0) &&
	    (*phy_data & (1 << 11))) {
		uint16_t data2 = 0x7EFF;

		ret_val = em_access_phy_debug_regs_hv(hw, (1 << 6) | 0x3,
		    &data2, FALSE);
		if (ret_val)
			return ret_val;
	}

	if (reg_addr > MAX_PHY_MULTI_PAGE_REG) {
		ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
		    (page << PHY_PAGE_SHIFT));
		if (ret_val)
			return ret_val;
	}
	if (read)
		ret_val = em_read_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg,
		    phy_data);
	else
		ret_val = em_write_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg,
		    *phy_data);
release:
	em_swfw_sync_release(hw, swfw);
	return ret_val;
}

/******************************************************************************
 * Reads the value from a PHY register, if the value is on a specific non zero
 * page, sets the page first.
 * hw - Struct containing variables accessed by shared code
 * reg_addr - address of the PHY register to read
 *****************************************************************************/
int32_t
em_read_phy_reg(struct em_hw *hw, uint32_t reg_addr, uint16_t *phy_data)
{
	uint32_t ret_val;
	uint16_t swfw;
	DEBUGFUNC("em_read_phy_reg");

	if (hw->mac_type == em_pchlan ||
		hw->mac_type == em_pch2lan ||
		hw->mac_type == em_pch_lpt ||
		hw->mac_type == em_pch_spt)
		return (em_access_phy_reg_hv(hw, reg_addr, phy_data, TRUE));

	if (((hw->mac_type == em_80003es2lan) || (hw->mac_type == em_82575)) &&
	    (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
		swfw = E1000_SWFW_PHY1_SM;
	} else {
		swfw = E1000_SWFW_PHY0_SM;
	}
	if (em_swfw_sync_acquire(hw, swfw))
		return -E1000_ERR_SWFW_SYNC;

	if ((hw->phy_type == em_phy_igp ||
	    hw->phy_type == em_phy_igp_3 ||
	    hw->phy_type == em_phy_igp_2) &&
	    (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
		ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
		    (uint16_t) reg_addr);
		if (ret_val) {
			em_swfw_sync_release(hw, swfw);
			return ret_val;
		}
	} else if (hw->phy_type == em_phy_gg82563) {
		if (((reg_addr & MAX_PHY_REG_ADDRESS) > MAX_PHY_MULTI_PAGE_REG) ||
		    (hw->mac_type == em_80003es2lan)) {
			/* Select Configuration Page */
			if ((reg_addr & MAX_PHY_REG_ADDRESS) <
			    GG82563_MIN_ALT_REG) {
				ret_val = em_write_phy_reg_ex(hw,
				    GG82563_PHY_PAGE_SELECT, 
				    (uint16_t) ((uint16_t) reg_addr >> 
				    GG82563_PAGE_SHIFT));
			} else {
				/*
				 * Use Alternative Page Select register to
				 * access registers 30 and 31
				 */
				ret_val = em_write_phy_reg_ex(hw,
				    GG82563_PHY_PAGE_SELECT_ALT,
				    (uint16_t) ((uint16_t) reg_addr >> 
				    GG82563_PAGE_SHIFT));
			}

			if (ret_val) {
				em_swfw_sync_release(hw, swfw);
				return ret_val;
			}
		}
	} else if ((hw->phy_type == em_phy_bm) && (hw->phy_revision == 1)) {
		if (reg_addr > MAX_PHY_MULTI_PAGE_REG) {
			ret_val = em_write_phy_reg_ex(hw, BM_PHY_PAGE_SELECT,
			    (uint16_t) ((uint16_t) reg_addr >> 
			    PHY_PAGE_SHIFT));
			if (ret_val)
				return ret_val;
		}
	}
	ret_val = em_read_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,
	    phy_data);

	em_swfw_sync_release(hw, swfw);
	return ret_val;
}

STATIC int32_t
em_read_phy_reg_ex(struct em_hw *hw, uint32_t reg_addr, uint16_t *phy_data)
{
	uint32_t i;
	uint32_t mdic = 0;
	DEBUGFUNC("em_read_phy_reg_ex");

	if (reg_addr > MAX_PHY_REG_ADDRESS) {
		DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
		return -E1000_ERR_PARAM;
	}
	if (hw->mac_type == em_icp_xxxx) {
		*phy_data = gcu_miibus_readreg(hw, hw->icp_xxxx_port_num,
		    reg_addr);
		return E1000_SUCCESS;
	}
	if (hw->mac_type > em_82543) {
		/*
		 * Set up Op-code, Phy Address, and register address in the
		 * MDI Control register.  The MAC will take care of
		 * interfacing with the PHY to retrieve the desired data.
		 */
		mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
		    (hw->phy_addr << E1000_MDIC_PHY_SHIFT) |
		    (E1000_MDIC_OP_READ));

		E1000_WRITE_REG(hw, MDIC, mdic);

		/*
		 * Poll the ready bit to see if the MDI read completed
		 * Increasing the time out as testing showed failures with
		 * the lower time out (from FreeBSD driver)
		 */
		for (i = 0; i < 1960; i++) {
			usec_delay(50);
			mdic = E1000_READ_REG(hw, MDIC);
			if (mdic & E1000_MDIC_READY)
				break;
		}
		if (!(mdic & E1000_MDIC_READY)) {
			DEBUGOUT("MDI Read did not complete\n");
			return -E1000_ERR_PHY;
		}
		if (mdic & E1000_MDIC_ERROR) {
			DEBUGOUT("MDI Error\n");
			return -E1000_ERR_PHY;
		}
		*phy_data = (uint16_t) mdic;

		if (hw->mac_type == em_pch2lan || hw->mac_type == em_pch_lpt || hw->mac_type == em_pch_spt)
			usec_delay(100);
	} else {
		/*
		 * We must first send a preamble through the MDIO pin to
		 * signal the beginning of an MII instruction.  This is done
		 * by sending 32 consecutive "1" bits.
		 */
		em_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
		/*
		 * Now combine the next few fields that are required for a
		 * read operation.  We use this method instead of calling the
		 * em_shift_out_mdi_bits routine five different times. The
		 * format of a MII read instruction consists of a shift out
		 * of 14 bits and is defined as follows: <Preamble><SOF><Op
		 * Code><Phy Addr><Reg Addr> followed by a shift in of 18
		 * bits.  This first two bits shifted in are TurnAround bits
		 * used to avoid contention on the MDIO pin when a READ
		 * operation is performed.  These two bits are thrown away
		 * followed by a shift in of 16 bits which contains the
		 * desired data.
		 */
		mdic = ((reg_addr) | (hw->phy_addr << 5) |
		    (PHY_OP_READ << 10) | (PHY_SOF << 12));

		em_shift_out_mdi_bits(hw, mdic, 14);
		/*
		 * Now that we've shifted out the read command to the MII, we
		 * need to "shift in" the 16-bit value (18 total bits) of the
		 * requested PHY register address.
		 */
		*phy_data = em_shift_in_mdi_bits(hw);
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Writes a value to a PHY register
 *
 * hw - Struct containing variables accessed by shared code
 * reg_addr - address of the PHY register to write
 * data - data to write to the PHY
 *****************************************************************************/
int32_t
em_write_phy_reg(struct em_hw *hw, uint32_t reg_addr, uint16_t phy_data)
{
	uint32_t ret_val;
	DEBUGFUNC("em_write_phy_reg");

	if (hw->mac_type == em_pchlan ||
		hw->mac_type == em_pch2lan ||
		hw->mac_type == em_pch_lpt ||
		hw->mac_type == em_pch_spt)
		return (em_access_phy_reg_hv(hw, reg_addr, &phy_data, FALSE));

	if (em_swfw_sync_acquire(hw, hw->swfw))
		return -E1000_ERR_SWFW_SYNC;

	if ((hw->phy_type == em_phy_igp ||
	    hw->phy_type == em_phy_igp_3 ||
	    hw->phy_type == em_phy_igp_2) &&
	    (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
		ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
		    (uint16_t) reg_addr);
		if (ret_val) {
			em_swfw_sync_release(hw, hw->swfw);
			return ret_val;
		}
	} else if (hw->phy_type == em_phy_gg82563) {
		if (((reg_addr & MAX_PHY_REG_ADDRESS) > MAX_PHY_MULTI_PAGE_REG) ||
		    (hw->mac_type == em_80003es2lan)) {
			/* Select Configuration Page */
			if ((reg_addr & MAX_PHY_REG_ADDRESS) < 
			    GG82563_MIN_ALT_REG) {
				ret_val = em_write_phy_reg_ex(hw, 
				    GG82563_PHY_PAGE_SELECT,
				    (uint16_t) ((uint16_t) reg_addr >> 
				    GG82563_PAGE_SHIFT));
			} else {
				/*
				 * Use Alternative Page Select register to
				 * access registers 30 and 31
				 */
				ret_val = em_write_phy_reg_ex(hw,
				    GG82563_PHY_PAGE_SELECT_ALT,
				    (uint16_t) ((uint16_t) reg_addr >> 
				    GG82563_PAGE_SHIFT));
			}

			if (ret_val) {
				em_swfw_sync_release(hw, hw->swfw);
				return ret_val;
			}
		}
	} else if ((hw->phy_type == em_phy_bm) && (hw->phy_revision == 1)) {
		if (reg_addr > MAX_PHY_MULTI_PAGE_REG) {
			ret_val = em_write_phy_reg_ex(hw, BM_PHY_PAGE_SELECT,
			    (uint16_t) ((uint16_t) reg_addr >> 
			    PHY_PAGE_SHIFT));
			if (ret_val)
				return ret_val;
		}
	}
	ret_val = em_write_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,
	    phy_data);

	em_swfw_sync_release(hw, hw->swfw);
	return ret_val;
}

STATIC int32_t
em_write_phy_reg_ex(struct em_hw *hw, uint32_t reg_addr, uint16_t phy_data)
{
	uint32_t i;
	uint32_t mdic = 0;
	DEBUGFUNC("em_write_phy_reg_ex");

	if (reg_addr > MAX_PHY_REG_ADDRESS) {
		DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
		return -E1000_ERR_PARAM;
	}
	if (hw->mac_type == em_icp_xxxx) {
		gcu_miibus_writereg(hw, hw->icp_xxxx_port_num,
		    reg_addr, phy_data);
		return E1000_SUCCESS;
	}
	if (hw->mac_type > em_82543) {
		/*
		 * Set up Op-code, Phy Address, register address, and data
		 * intended for the PHY register in the MDI Control register.
		 * The MAC will take care of interfacing with the PHY to send
		 * the desired data.
		 */
		mdic = (((uint32_t) phy_data) |
			(reg_addr << E1000_MDIC_REG_SHIFT) |
			(hw->phy_addr << E1000_MDIC_PHY_SHIFT) |
			(E1000_MDIC_OP_WRITE));

		E1000_WRITE_REG(hw, MDIC, mdic);

		/* Poll the ready bit to see if the MDI read completed */
		for (i = 0; i < 641; i++) {
			usec_delay(5);
			mdic = E1000_READ_REG(hw, MDIC);
			if (mdic & E1000_MDIC_READY)
				break;
		}
		if (!(mdic & E1000_MDIC_READY)) {
			DEBUGOUT("MDI Write did not complete\n");
			return -E1000_ERR_PHY;
		}

		if (hw->mac_type == em_pch2lan || hw->mac_type == em_pch_lpt || hw->mac_type == em_pch_spt)
			usec_delay(100);
	} else {
		/*
		 * We'll need to use the SW defined pins to shift the write
		 * command out to the PHY. We first send a preamble to the
		 * PHY to signal the beginning of the MII instruction.  This
		 * is done by sending 32 consecutive "1" bits.
		 */
		em_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
		/*
		 * Now combine the remaining required fields that will
		 * indicate a write operation. We use this method instead of
		 * calling the em_shift_out_mdi_bits routine for each field
		 * in the command. The format of a MII write instruction is
		 * as follows: <Preamble><SOF><Op Code><Phy Addr><Reg
		 * Addr><Turnaround><Data>.
		 */
		mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | 
		    (hw->phy_addr << 7) | (PHY_OP_WRITE << 12) | 
		    (PHY_SOF << 14));
		mdic <<= 16;
		mdic |= (uint32_t) phy_data;

		em_shift_out_mdi_bits(hw, mdic, 32);
	}

	return E1000_SUCCESS;
}

STATIC int32_t
em_read_kmrn_reg(struct em_hw *hw, uint32_t reg_addr, uint16_t *data)
{
	uint32_t reg_val;
	DEBUGFUNC("em_read_kmrn_reg");

	if (em_swfw_sync_acquire(hw, hw->swfw))
		return -E1000_ERR_SWFW_SYNC;

	/* Write register address */
	reg_val = ((reg_addr << E1000_KUMCTRLSTA_OFFSET_SHIFT) &
	    E1000_KUMCTRLSTA_OFFSET) |
	    E1000_KUMCTRLSTA_REN;

	E1000_WRITE_REG(hw, KUMCTRLSTA, reg_val);
	usec_delay(2);

	/* Read the data returned */
	reg_val = E1000_READ_REG(hw, KUMCTRLSTA);
	*data = (uint16_t) reg_val;

	em_swfw_sync_release(hw, hw->swfw);
	return E1000_SUCCESS;
}

STATIC int32_t
em_write_kmrn_reg(struct em_hw *hw, uint32_t reg_addr, uint16_t data)
{
	uint32_t reg_val;
	DEBUGFUNC("em_write_kmrn_reg");

	if (em_swfw_sync_acquire(hw, hw->swfw))
		return -E1000_ERR_SWFW_SYNC;

	reg_val = ((reg_addr << E1000_KUMCTRLSTA_OFFSET_SHIFT) &
	    E1000_KUMCTRLSTA_OFFSET) | data;

	E1000_WRITE_REG(hw, KUMCTRLSTA, reg_val);
	usec_delay(2);

	em_swfw_sync_release(hw, hw->swfw);
	return E1000_SUCCESS;
}

/******************************************************************************
 * Returns the PHY to the power-on reset state
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_phy_hw_reset(struct em_hw *hw)
{
	uint32_t ctrl, ctrl_ext;
	uint32_t led_ctrl;
	int32_t  ret_val;
	DEBUGFUNC("em_phy_hw_reset");
	/*
	 * In the case of the phy reset being blocked, it's not an error, we
	 * simply return success without performing the reset.
	 */
	ret_val = em_check_phy_reset_block(hw);
	if (ret_val)
		return E1000_SUCCESS;

	DEBUGOUT("Resetting Phy...\n");

	if (hw->mac_type > em_82543 && hw->mac_type != em_icp_xxxx) {
		if (em_swfw_sync_acquire(hw, hw->swfw)) {
			DEBUGOUT("Unable to acquire swfw sync\n");
			return -E1000_ERR_SWFW_SYNC;
		}
		/*
		 * Read the device control register and assert the
		 * E1000_CTRL_PHY_RST bit. Then, take it out of reset. For
		 * pre-em_82571 hardware, we delay for 10ms between the
		 * assert and deassert.  For em_82571 hardware and later, we
		 * instead delay for 50us between and 10ms after the
		 * deassertion.
		 */
		ctrl = E1000_READ_REG(hw, CTRL);
		E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PHY_RST);
		E1000_WRITE_FLUSH(hw);

		if (hw->mac_type < em_82571)
			msec_delay(10);
		else
			usec_delay(100);

		E1000_WRITE_REG(hw, CTRL, ctrl);
		E1000_WRITE_FLUSH(hw);

		if (hw->mac_type >= em_82571)
			msec_delay_irq(10);
		em_swfw_sync_release(hw, hw->swfw);
		/*
		 * the M88E1141_E_PHY_ID might need reset here, but nothing
		 * proves it
		 */
	} else {
		/*
		 * Read the Extended Device Control Register, assert the
		 * PHY_RESET_DIR bit to put the PHY into reset. Then, take it
		 * out of reset.
		 */
		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
		ctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;
		ctrl_ext &= ~E1000_CTRL_EXT_SDP4_DATA;
		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
		E1000_WRITE_FLUSH(hw);
		msec_delay(10);
		ctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;
		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
		E1000_WRITE_FLUSH(hw);
	}
	usec_delay(150);

	if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
		/* Configure activity LED after PHY reset */
		led_ctrl = E1000_READ_REG(hw, LEDCTL);
		led_ctrl &= IGP_ACTIVITY_LED_MASK;
		led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
		E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
	}
	/* Wait for FW to finish PHY configuration. */
	ret_val = em_get_phy_cfg_done(hw);
	if (ret_val != E1000_SUCCESS)
		return ret_val;
	em_release_software_semaphore(hw);

	if ((hw->mac_type == em_ich8lan) && (hw->phy_type == em_phy_igp_3))
		ret_val = em_init_lcd_from_nvm(hw);

	return ret_val;
}

/*****************************************************************************
 *  SW-based LCD Configuration.
 *  SW will configure Gbe Disable and LPLU based on the NVM. The four bits are
 *  collectively called OEM bits.  The OEM Write Enable bit and SW Config bit
 *  in NVM determines whether HW should configure LPLU and Gbe Disable.
 *****************************************************************************/
int32_t
em_oem_bits_config_pchlan(struct em_hw *hw, boolean_t d0_state)
{
	int32_t  ret_val = E1000_SUCCESS;
	uint32_t mac_reg;
	uint16_t oem_reg;
	uint16_t swfw = E1000_SWFW_PHY0_SM;

	if (hw->mac_type < em_pchlan)
		return ret_val;

	ret_val = em_swfw_sync_acquire(hw, swfw);
	if (ret_val)
		return ret_val;

	if (hw->mac_type == em_pchlan) {
		mac_reg = E1000_READ_REG(hw, EXTCNF_CTRL);
		if (mac_reg & E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE)
			goto out;
	}

	mac_reg = E1000_READ_REG(hw, FEXTNVM);
	if (!(mac_reg & FEXTNVM_SW_CONFIG_ICH8M))
		goto out;

	mac_reg = E1000_READ_REG(hw, PHY_CTRL);

	ret_val = em_read_phy_reg(hw, HV_OEM_BITS, &oem_reg);
	if (ret_val)
		goto out;

	oem_reg &= ~(HV_OEM_BITS_GBE_DIS | HV_OEM_BITS_LPLU);

	if (d0_state) {
		if (mac_reg & E1000_PHY_CTRL_GBE_DISABLE)
			oem_reg |= HV_OEM_BITS_GBE_DIS;

		if (mac_reg & E1000_PHY_CTRL_D0A_LPLU)
			oem_reg |= HV_OEM_BITS_LPLU;
		/* Restart auto-neg to activate the bits */
		if (!em_check_phy_reset_block(hw))
			oem_reg |= HV_OEM_BITS_RESTART_AN;

	} else {
		if (mac_reg & (E1000_PHY_CTRL_GBE_DISABLE |
		    E1000_PHY_CTRL_NOND0A_GBE_DISABLE))
			oem_reg |= HV_OEM_BITS_GBE_DIS;

		if (mac_reg & (E1000_PHY_CTRL_D0A_LPLU |
		    E1000_PHY_CTRL_NOND0A_LPLU))
			oem_reg |= HV_OEM_BITS_LPLU;
	}

	ret_val = em_write_phy_reg(hw, HV_OEM_BITS, oem_reg);

out:
	em_swfw_sync_release(hw, swfw);

	return ret_val;
}


/******************************************************************************
 * Resets the PHY
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Sets bit 15 of the MII Control regiser
 *****************************************************************************/
int32_t
em_phy_reset(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_phy_reset");
	/*
	 * In the case of the phy reset being blocked, it's not an error, we
	 * simply return success without performing the reset.
	 */
	ret_val = em_check_phy_reset_block(hw);
	if (ret_val)
		return E1000_SUCCESS;

	switch (hw->phy_type) {
	case em_phy_igp:
	case em_phy_igp_2:
	case em_phy_igp_3:
	case em_phy_ife:
		ret_val = em_phy_hw_reset(hw);
		if (ret_val)
			return ret_val;
		break;
	default:
		ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data);
		if (ret_val)
			return ret_val;

		phy_data |= MII_CR_RESET;
		ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data);
		if (ret_val)
			return ret_val;

		usec_delay(1);
		break;
	}

	/* Allow time for h/w to get to a quiescent state after reset */
	msec_delay(10);

	if (hw->phy_type == em_phy_igp || hw->phy_type == em_phy_igp_2)
		em_phy_init_script(hw);

	if (hw->mac_type == em_pchlan) {
		ret_val = em_hv_phy_workarounds_ich8lan(hw);
		if (ret_val)
			return ret_val;
	} else if (hw->mac_type == em_pch2lan) {
		ret_val = em_lv_phy_workarounds_ich8lan(hw);
		if (ret_val)
			return ret_val;
	}
	
	if (hw->mac_type >= em_pchlan) {
		ret_val = em_oem_bits_config_pchlan(hw, TRUE);
		if (ret_val)
			return ret_val;
	}

	/* Ungate automatic PHY configuration on non-managed 82579 */
	if ((hw->mac_type == em_pch2lan) &&
	    !(E1000_READ_REG(hw, FWSM) & E1000_FWSM_FW_VALID)) {
		msec_delay(10);
		em_gate_hw_phy_config_ich8lan(hw, FALSE);
	}

	if (hw->phy_id == M88E1512_E_PHY_ID) {
		ret_val = em_initialize_M88E1512_phy(hw);
		if (ret_val)
			return ret_val;
	}

	return E1000_SUCCESS;
}

/******************************************************************************
 * Work-around for 82566 Kumeran PCS lock loss:
 * On link status change (i.e. PCI reset, speed change) and link is up and
 * speed is gigabit-
 * 0) if workaround is optionally disabled do nothing
 * 1) wait 1ms for Kumeran link to come up
 * 2) check Kumeran Diagnostic register PCS lock loss bit
 * 3) if not set the link is locked (all is good), otherwise...
 * 4) reset the PHY
 * 5) repeat up to 10 times
 * Note: this is only called for IGP3 copper when speed is 1gb.
 *
 * hw - struct containing variables accessed by shared code
 *****************************************************************************/
STATIC int32_t
em_kumeran_lock_loss_workaround(struct em_hw *hw)
{
	int32_t  ret_val;
	int32_t  reg;
	int32_t  cnt;
	uint16_t phy_data;
	if (hw->kmrn_lock_loss_workaround_disabled)
		return E1000_SUCCESS;
	/*
	 * Make sure link is up before proceeding.  If not just return.
	 * Attempting this while link is negotiating fouled up link stability
	 */
	ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
	ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);

	if (phy_data & MII_SR_LINK_STATUS) {
		for (cnt = 0; cnt < 10; cnt++) {
			/* read once to clear */
			ret_val = em_read_phy_reg(hw, IGP3_KMRN_DIAG,
			    &phy_data);
			if (ret_val)
				return ret_val;
			/* and again to get new status */
			ret_val = em_read_phy_reg(hw, IGP3_KMRN_DIAG, &phy_data);
			if (ret_val)
				return ret_val;

			/* check for PCS lock */
			if (!(phy_data & IGP3_KMRN_DIAG_PCS_LOCK_LOSS))
				return E1000_SUCCESS;

			/* Issue PHY reset */
			em_phy_hw_reset(hw);
			msec_delay_irq(5);
		}
		/* Disable GigE link negotiation */
		reg = E1000_READ_REG(hw, PHY_CTRL);
		E1000_WRITE_REG(hw, PHY_CTRL, reg | E1000_PHY_CTRL_GBE_DISABLE
		    | E1000_PHY_CTRL_NOND0A_GBE_DISABLE);

		/* unable to acquire PCS lock */
		return E1000_ERR_PHY;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Reads and matches the expected PHY address for known PHY IDs
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
STATIC int32_t
em_match_gig_phy(struct em_hw *hw)
{
	int32_t   phy_init_status, ret_val;
	uint16_t  phy_id_high, phy_id_low;
	boolean_t match = FALSE;
	DEBUGFUNC("em_match_gig_phy");

	ret_val = em_read_phy_reg(hw, PHY_ID1, &phy_id_high);
	if (ret_val)
		return ret_val;

	hw->phy_id = (uint32_t) (phy_id_high << 16);
	usec_delay(20);
	ret_val = em_read_phy_reg(hw, PHY_ID2, &phy_id_low);
	if (ret_val)
		return ret_val;

	hw->phy_id |= (uint32_t) (phy_id_low & PHY_REVISION_MASK);
	hw->phy_revision = (uint32_t) phy_id_low & ~PHY_REVISION_MASK;

	switch (hw->mac_type) {
	case em_82543:
		if (hw->phy_id == M88E1000_E_PHY_ID)
			match = TRUE;
		break;
	case em_82544:
		if (hw->phy_id == M88E1000_I_PHY_ID)
			match = TRUE;
		break;
	case em_82540:
	case em_82545:
	case em_82545_rev_3:
	case em_82546:
	case em_82546_rev_3:
		if (hw->phy_id == M88E1011_I_PHY_ID)
			match = TRUE;
		break;
	case em_82541:
	case em_82541_rev_2:
	case em_82547:
	case em_82547_rev_2:
		if (hw->phy_id == IGP01E1000_I_PHY_ID)
			match = TRUE;
		break;
	case em_82573:
		if (hw->phy_id == M88E1111_I_PHY_ID)
			match = TRUE;
		break;
	case em_82574:
		if (hw->phy_id == BME1000_E_PHY_ID)
			match = TRUE;
		break;
	case em_82575:
		if (hw->phy_id == M88E1000_E_PHY_ID)
			match = TRUE;
		if (hw->phy_id == IGP01E1000_I_PHY_ID)
			match = TRUE;
		if (hw->phy_id == IGP03E1000_E_PHY_ID)
			match = TRUE;
		break;
	case em_82580:
	case em_i210:
	case em_i350:
		if (hw->phy_id == I82580_I_PHY_ID ||
		    hw->phy_id == I210_I_PHY_ID ||
		    hw->phy_id == I347AT4_E_PHY_ID ||
		    hw->phy_id == I350_I_PHY_ID ||
		    hw->phy_id == M88E1112_E_PHY_ID ||
		    hw->phy_id == M88E1543_E_PHY_ID ||
		    hw->phy_id == M88E1512_E_PHY_ID) {
			uint32_t mdic;

			mdic = EM_READ_REG(hw, E1000_MDICNFG);
			mdic &= E1000_MDICNFG_PHY_MASK;
			hw->phy_addr = mdic >> E1000_MDICNFG_PHY_SHIFT;
			DEBUGOUT1("MDICNFG PHY ADDR %d",
			    mdic >> E1000_MDICNFG_PHY_SHIFT);
			match = TRUE;
		}
		break;
	case em_80003es2lan:
		if (hw->phy_id == GG82563_E_PHY_ID)
			match = TRUE;
		break;
	case em_ich8lan:
	case em_ich9lan:
	case em_ich10lan:
	case em_pchlan:
	case em_pch2lan:
		if (hw->phy_id == IGP03E1000_E_PHY_ID)
			match = TRUE;
		if (hw->phy_id == IFE_E_PHY_ID)
			match = TRUE;
		if (hw->phy_id == IFE_PLUS_E_PHY_ID)
			match = TRUE;
		if (hw->phy_id == IFE_C_E_PHY_ID)
			match = TRUE;
		if (hw->phy_id == BME1000_E_PHY_ID)
			match = TRUE;
		if (hw->phy_id == I82577_E_PHY_ID)
			match = TRUE;
		if (hw->phy_id == I82578_E_PHY_ID)
			match = TRUE;
		if (hw->phy_id == I82579_E_PHY_ID)
			match = TRUE;
		break;
	case em_pch_lpt:
	case em_pch_spt:
		if (hw->phy_id == I217_E_PHY_ID)
			match = TRUE;
		break;
	case em_icp_xxxx:
		if (hw->phy_id == M88E1141_E_PHY_ID)
			match = TRUE;
		if (hw->phy_id == RTL8211_E_PHY_ID)
			match = TRUE;
		break;
	default:
		DEBUGOUT1("Invalid MAC type %d\n", hw->mac_type);
		return -E1000_ERR_CONFIG;
	}
	phy_init_status = em_set_phy_type(hw);

	if ((match) && (phy_init_status == E1000_SUCCESS)) {
		DEBUGOUT1("PHY ID 0x%X detected\n", hw->phy_id);
		return E1000_SUCCESS;
	}
	DEBUGOUT1("Invalid PHY ID 0x%X\n", hw->phy_id);
	return -E1000_ERR_PHY;
}

/******************************************************************************
 * Probes the expected PHY address for known PHY IDs
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
STATIC int32_t
em_detect_gig_phy(struct em_hw *hw)
{
	int32_t ret_val;
	DEBUGFUNC("em_detect_gig_phy");

	if (hw->phy_id != 0)
		return E1000_SUCCESS;

	/* default phy address, most phys reside here, but not all (ICH10) */
	if (hw->mac_type != em_icp_xxxx)
		hw->phy_addr = 1;
	else
		hw->phy_addr = 0; /* There is a phy at phy_addr 0 on EP80579 */

	/*
	 * The 82571 firmware may still be configuring the PHY.  In this
	 * case, we cannot access the PHY until the configuration is done.
	 * So we explicitly set the PHY values.
	 */
	if (hw->mac_type == em_82571 ||
	    hw->mac_type == em_82572) {
		hw->phy_id = IGP01E1000_I_PHY_ID;
		hw->phy_type = em_phy_igp_2;
		return E1000_SUCCESS;
	}

	/*
	 * Some of the fiber cards dont have a phy, so we must exit cleanly
	 * here
	 */
	if ((hw->media_type == em_media_type_fiber) &&
	    (hw->mac_type == em_82542_rev2_0 ||
	    hw->mac_type == em_82542_rev2_1 ||
	    hw->mac_type == em_82543 ||
	    hw->mac_type == em_82573 ||
	    hw->mac_type == em_82574 ||
	    hw->mac_type == em_80003es2lan)) {
		hw->phy_type = em_phy_undefined;
		return E1000_SUCCESS;
	}

	if ((hw->media_type == em_media_type_internal_serdes ||
	    hw->media_type == em_media_type_fiber) &&
	    hw->mac_type >= em_82575) {
		hw->phy_type = em_phy_undefined;
		return E1000_SUCCESS;
	}

	/*
	 * Up to 82543 (incl), we need reset the phy, or it might not get
	 * detected
	 */
	if (hw->mac_type <= em_82543) {
		ret_val = em_phy_hw_reset(hw);
		if (ret_val)
			return ret_val;
	}
	/*
	 * ESB-2 PHY reads require em_phy_gg82563 to be set because of a
	 * work- around that forces PHY page 0 to be set or the reads fail.
	 * The rest of the code in this routine uses em_read_phy_reg to read
	 * the PHY ID. So for ESB-2 we need to have this set so our reads
	 * won't fail.  If the attached PHY is not a em_phy_gg82563, the
	 * routines below will figure this out as well.
	 */
	if (hw->mac_type == em_80003es2lan)
		hw->phy_type = em_phy_gg82563;

	/* Power on SGMII phy if it is disabled */
	if (hw->mac_type == em_82580 || hw->mac_type == em_i210 ||
	    hw->mac_type == em_i350) {
		uint32_t ctrl_ext = EM_READ_REG(hw, E1000_CTRL_EXT);
		EM_WRITE_REG(hw, E1000_CTRL_EXT,
		    ctrl_ext & ~E1000_CTRL_EXT_SDP3_DATA);
		delay(300);
	}

	/* Read the PHY ID Registers to identify which PHY is onboard. */
	for (hw->phy_addr = 1; (hw->phy_addr < 4); hw->phy_addr++) {
		ret_val = em_match_gig_phy(hw);
		if (ret_val == E1000_SUCCESS)
			return E1000_SUCCESS;
	}
	return -E1000_ERR_PHY;
}

/******************************************************************************
 * Resets the PHY's DSP
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_phy_reset_dsp(struct em_hw *hw)
{
	int32_t ret_val;
	DEBUGFUNC("em_phy_reset_dsp");

	do {
		if (hw->phy_type != em_phy_gg82563) {
			ret_val = em_write_phy_reg(hw, 29, 0x001d);
			if (ret_val)
				break;
		}
		ret_val = em_write_phy_reg(hw, 30, 0x00c1);
		if (ret_val)
			break;
		ret_val = em_write_phy_reg(hw, 30, 0x0000);
		if (ret_val)
			break;
		ret_val = E1000_SUCCESS;
	} while (0);

	return ret_val;
}

/******************************************************************************
 * Sets up eeprom variables in the hw struct.  Must be called after mac_type
 * is configured.  Additionally, if this is ICH8, the flash controller GbE
 * registers must be mapped, or this will crash.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_init_eeprom_params(struct em_hw *hw)
{
	struct em_eeprom_info *eeprom = &hw->eeprom;
	uint32_t eecd = E1000_READ_REG(hw, EECD);
	int32_t  ret_val = E1000_SUCCESS;
	uint16_t eeprom_size;
	DEBUGFUNC("em_init_eeprom_params");

	switch (hw->mac_type) {
	case em_82542_rev2_0:
	case em_82542_rev2_1:
	case em_82543:
	case em_82544:
		eeprom->type = em_eeprom_microwire;
		eeprom->word_size = 64;
		eeprom->opcode_bits = 3;
		eeprom->address_bits = 6;
		eeprom->delay_usec = 50;
		eeprom->use_eerd = FALSE;
		eeprom->use_eewr = FALSE;
		break;
	case em_82540:
	case em_82545:
	case em_82545_rev_3:
	case em_icp_xxxx:
	case em_82546:
	case em_82546_rev_3:
		eeprom->type = em_eeprom_microwire;
		eeprom->opcode_bits = 3;
		eeprom->delay_usec = 50;
		if (eecd & E1000_EECD_SIZE) {
			eeprom->word_size = 256;
			eeprom->address_bits = 8;
		} else {
			eeprom->word_size = 64;
			eeprom->address_bits = 6;
		}
		eeprom->use_eerd = FALSE;
		eeprom->use_eewr = FALSE;
		break;
	case em_82541:
	case em_82541_rev_2:
	case em_82547:
	case em_82547_rev_2:
		if (eecd & E1000_EECD_TYPE) {
			eeprom->type = em_eeprom_spi;
			eeprom->opcode_bits = 8;
			eeprom->delay_usec = 1;
			if (eecd & E1000_EECD_ADDR_BITS) {
				eeprom->page_size = 32;
				eeprom->address_bits = 16;
			} else {
				eeprom->page_size = 8;
				eeprom->address_bits = 8;
			}
		} else {
			eeprom->type = em_eeprom_microwire;
			eeprom->opcode_bits = 3;
			eeprom->delay_usec = 50;
			if (eecd & E1000_EECD_ADDR_BITS) {
				eeprom->word_size = 256;
				eeprom->address_bits = 8;
			} else {
				eeprom->word_size = 64;
				eeprom->address_bits = 6;
			}
		}
		eeprom->use_eerd = FALSE;
		eeprom->use_eewr = FALSE;
		break;
	case em_82571:
	case em_82572:
		eeprom->type = em_eeprom_spi;
		eeprom->opcode_bits = 8;
		eeprom->delay_usec = 1;
		if (eecd & E1000_EECD_ADDR_BITS) {
			eeprom->page_size = 32;
			eeprom->address_bits = 16;
		} else {
			eeprom->page_size = 8;
			eeprom->address_bits = 8;
		}
		eeprom->use_eerd = FALSE;
		eeprom->use_eewr = FALSE;
		break;
	case em_82573:
	case em_82574:
	case em_82575:
	case em_82580:
	case em_i210:
	case em_i350:
		eeprom->type = em_eeprom_spi;
		eeprom->opcode_bits = 8;
		eeprom->delay_usec = 1;
		if (eecd & E1000_EECD_ADDR_BITS) {
			eeprom->page_size = 32;
			eeprom->address_bits = 16;
		} else {
			eeprom->page_size = 8;
			eeprom->address_bits = 8;
		}
		eeprom->use_eerd = TRUE;
		eeprom->use_eewr = TRUE;
		if (em_is_onboard_nvm_eeprom(hw) == FALSE) {
			eeprom->type = em_eeprom_flash;
			eeprom->word_size = 2048;
			/*
			 * Ensure that the Autonomous FLASH update bit is
			 * cleared due to Flash update issue on parts which
			 * use a FLASH for NVM.
			 */
			eecd &= ~E1000_EECD_AUPDEN;
			E1000_WRITE_REG(hw, EECD, eecd);
		}
		if (em_get_flash_presence_i210(hw) == FALSE) {
			eeprom->type = em_eeprom_invm;
			eeprom->word_size = INVM_SIZE;
			eeprom->use_eerd = FALSE;
			eeprom->use_eewr = FALSE;
		}
		break;
	case em_80003es2lan:
		eeprom->type = em_eeprom_spi;
		eeprom->opcode_bits = 8;
		eeprom->delay_usec = 1;
		if (eecd & E1000_EECD_ADDR_BITS) {
			eeprom->page_size = 32;
			eeprom->address_bits = 16;
		} else {
			eeprom->page_size = 8;
			eeprom->address_bits = 8;
		}
		eeprom->use_eerd = TRUE;
		eeprom->use_eewr = FALSE;
		break;
	case em_ich8lan:
	case em_ich9lan:
	case em_ich10lan:
	case em_pchlan:
	case em_pch2lan:
	case em_pch_lpt:
		{
		int32_t         i = 0;
		uint32_t        flash_size = 
		    E1000_READ_ICH_FLASH_REG(hw, ICH_FLASH_GFPREG);
			eeprom->type = em_eeprom_ich8;
			eeprom->use_eerd = FALSE;
			eeprom->use_eewr = FALSE;
			eeprom->word_size = E1000_SHADOW_RAM_WORDS;
			/*
			 * Zero the shadow RAM structure. But don't load it
			 * from NVM so as to save time for driver init
			 */
			if (hw->eeprom_shadow_ram != NULL) {
				for (i = 0; i < E1000_SHADOW_RAM_WORDS; i++) {
					hw->eeprom_shadow_ram[i].modified = 
					    FALSE;
					hw->eeprom_shadow_ram[i].eeprom_word = 
					    0xFFFF;
				}
			}
			hw->flash_base_addr = (flash_size & 
			    ICH_GFPREG_BASE_MASK) * ICH_FLASH_SECTOR_SIZE;

			hw->flash_bank_size = ((flash_size >> 16) & 
			    ICH_GFPREG_BASE_MASK) + 1;
			hw->flash_bank_size -= (flash_size &
			    ICH_GFPREG_BASE_MASK);

			hw->flash_bank_size *= ICH_FLASH_SECTOR_SIZE;

			hw->flash_bank_size /= 2 * sizeof(uint16_t);

			break;
		}
	case em_pch_spt:
		{
			int32_t         i = 0;
			uint32_t        flash_size = EM_READ_REG(hw, 0xc /* STRAP */);

			eeprom->type = em_eeprom_ich8;
			eeprom->use_eerd = FALSE;
			eeprom->use_eewr = FALSE;
			eeprom->word_size = E1000_SHADOW_RAM_WORDS;
			/*
			 * Zero the shadow RAM structure. But don't load it
			 * from NVM so as to save time for driver init
			 */
			if (hw->eeprom_shadow_ram != NULL) {
				for (i = 0; i < E1000_SHADOW_RAM_WORDS; i++) {
					hw->eeprom_shadow_ram[i].modified = 
					    FALSE;
					hw->eeprom_shadow_ram[i].eeprom_word = 
					    0xFFFF;
				}
			}
			hw->flash_base_addr = 0;
			flash_size = ((flash_size >> 1) & 0x1f) + 1;
			flash_size *= 4096;
			hw->flash_bank_size = flash_size / 4;
		}
		break;
	default:
		break;
	}

	if (eeprom->type == em_eeprom_spi) {
		/*
		 * eeprom_size will be an enum [0..8] that maps to eeprom
		 * sizes 128B to 32KB (incremented by powers of 2).
		 */
		if (hw->mac_type <= em_82547_rev_2) {
			/* Set to default value for initial eeprom read. */
			eeprom->word_size = 64;
			ret_val = em_read_eeprom(hw, EEPROM_CFG, 1,
			    &eeprom_size);
			if (ret_val)
				return ret_val;
			eeprom_size = (eeprom_size & EEPROM_SIZE_MASK) >> 
			    EEPROM_SIZE_SHIFT;
			/*
			 * 256B eeprom size was not supported in earlier
			 * hardware, so we bump eeprom_size up one to ensure
			 * that "1" (which maps to 256B) is never the result
			 * used in the shifting logic below.
			 */
			if (eeprom_size)
				eeprom_size++;
		} else {
			eeprom_size = (uint16_t) (
			    (eecd & E1000_EECD_SIZE_EX_MASK) >>
			    E1000_EECD_SIZE_EX_SHIFT);
		}

		/* EEPROM access above 16k is unsupported */
		if (eeprom_size + EEPROM_WORD_SIZE_SHIFT >
		    EEPROM_WORD_SIZE_SHIFT_MAX) {
			eeprom->word_size = 1 << EEPROM_WORD_SIZE_SHIFT_MAX;
		} else {
			eeprom->word_size = 1 << 
			    (eeprom_size + EEPROM_WORD_SIZE_SHIFT);
		}
	}
	return ret_val;
}

/******************************************************************************
 * Raises the EEPROM's clock input.
 *
 * hw - Struct containing variables accessed by shared code
 * eecd - EECD's current value
 *****************************************************************************/
static void
em_raise_ee_clk(struct em_hw *hw, uint32_t *eecd)
{
	/*
	 * Raise the clock input to the EEPROM (by setting the SK bit), and
	 * then wait <delay> microseconds.
	 */
	*eecd = *eecd | E1000_EECD_SK;
	E1000_WRITE_REG(hw, EECD, *eecd);
	E1000_WRITE_FLUSH(hw);
	usec_delay(hw->eeprom.delay_usec);
}

/******************************************************************************
 * Lowers the EEPROM's clock input.
 *
 * hw - Struct containing variables accessed by shared code
 * eecd - EECD's current value
 *****************************************************************************/
static void
em_lower_ee_clk(struct em_hw *hw, uint32_t *eecd)
{
	/*
	 * Lower the clock input to the EEPROM (by clearing the SK bit), and
	 * then wait 50 microseconds.
	 */
	*eecd = *eecd & ~E1000_EECD_SK;
	E1000_WRITE_REG(hw, EECD, *eecd);
	E1000_WRITE_FLUSH(hw);
	usec_delay(hw->eeprom.delay_usec);
}

/******************************************************************************
 * Shift data bits out to the EEPROM.
 *
 * hw - Struct containing variables accessed by shared code
 * data - data to send to the EEPROM
 * count - number of bits to shift out
 *****************************************************************************/
static void
em_shift_out_ee_bits(struct em_hw *hw, uint16_t data, uint16_t count)
{
	struct em_eeprom_info *eeprom = &hw->eeprom;
	uint32_t eecd;
	uint32_t mask;
	/*
	 * We need to shift "count" bits out to the EEPROM. So, value in the
	 * "data" parameter will be shifted out to the EEPROM one bit at a
	 * time. In order to do this, "data" must be broken down into bits.
	 */
	mask = 0x01 << (count - 1);
	eecd = E1000_READ_REG(hw, EECD);
	if (eeprom->type == em_eeprom_microwire) {
		eecd &= ~E1000_EECD_DO;
	} else if (eeprom->type == em_eeprom_spi) {
		eecd |= E1000_EECD_DO;
	}
	do {
		/*
		 * A "1" is shifted out to the EEPROM by setting bit "DI" to
		 * a "1", and then raising and then lowering the clock (the
		 * SK bit controls the clock input to the EEPROM).  A "0" is
		 * shifted out to the EEPROM by setting "DI" to "0" and then
		 * raising and then lowering the clock.
		 */
		eecd &= ~E1000_EECD_DI;

		if (data & mask)
			eecd |= E1000_EECD_DI;

		E1000_WRITE_REG(hw, EECD, eecd);
		E1000_WRITE_FLUSH(hw);

		usec_delay(eeprom->delay_usec);

		em_raise_ee_clk(hw, &eecd);
		em_lower_ee_clk(hw, &eecd);

		mask = mask >> 1;

	} while (mask);

	/* We leave the "DI" bit set to "0" when we leave this routine. */
	eecd &= ~E1000_EECD_DI;
	E1000_WRITE_REG(hw, EECD, eecd);
}

/******************************************************************************
 * Shift data bits in from the EEPROM
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static uint16_t
em_shift_in_ee_bits(struct em_hw *hw, uint16_t count)
{
	uint32_t eecd;
	uint32_t i;
	uint16_t data;
	/*
	 * In order to read a register from the EEPROM, we need to shift
	 * 'count' bits in from the EEPROM. Bits are "shifted in" by raising
	 * the clock input to the EEPROM (setting the SK bit), and then
	 * reading the value of the "DO" bit.  During this "shifting in"
	 * process the "DI" bit should always be clear.
	 */

	eecd = E1000_READ_REG(hw, EECD);

	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
	data = 0;

	for (i = 0; i < count; i++) {
		data = data << 1;
		em_raise_ee_clk(hw, &eecd);

		eecd = E1000_READ_REG(hw, EECD);

		eecd &= ~(E1000_EECD_DI);
		if (eecd & E1000_EECD_DO)
			data |= 1;

		em_lower_ee_clk(hw, &eecd);
	}

	return data;
}
/******************************************************************************
 * Prepares EEPROM for access
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This
 * function should be called before issuing a command to the EEPROM.
 *****************************************************************************/
static int32_t
em_acquire_eeprom(struct em_hw *hw)
{
	struct em_eeprom_info *eeprom = &hw->eeprom;
	uint32_t eecd, i = 0;
	DEBUGFUNC("em_acquire_eeprom");

	if (em_swfw_sync_acquire(hw, E1000_SWFW_EEP_SM))
		return -E1000_ERR_SWFW_SYNC;
	eecd = E1000_READ_REG(hw, EECD);

	if ((hw->mac_type != em_82573) && (hw->mac_type != em_82574)) {
		/* Request EEPROM Access */
		if (hw->mac_type > em_82544) {
			eecd |= E1000_EECD_REQ;
			E1000_WRITE_REG(hw, EECD, eecd);
			eecd = E1000_READ_REG(hw, EECD);
			while ((!(eecd & E1000_EECD_GNT)) &&
			    (i < E1000_EEPROM_GRANT_ATTEMPTS)) {
				i++;
				usec_delay(5);
				eecd = E1000_READ_REG(hw, EECD);
			}
			if (!(eecd & E1000_EECD_GNT)) {
				eecd &= ~E1000_EECD_REQ;
				E1000_WRITE_REG(hw, EECD, eecd);
				DEBUGOUT("Could not acquire EEPROM grant\n");
				em_swfw_sync_release(hw, E1000_SWFW_EEP_SM);
				return -E1000_ERR_EEPROM;
			}
		}
	}

	/* Setup EEPROM for Read/Write */
	if (eeprom->type == em_eeprom_microwire) {
		/* Clear SK and DI */
		eecd &= ~(E1000_EECD_DI | E1000_EECD_SK);
		E1000_WRITE_REG(hw, EECD, eecd);

		/* Set CS */
		eecd |= E1000_EECD_CS;
		E1000_WRITE_REG(hw, EECD, eecd);
	} else if (eeprom->type == em_eeprom_spi) {
		/* Clear SK and CS */
		eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
		E1000_WRITE_REG(hw, EECD, eecd);
		usec_delay(1);
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Returns EEPROM to a "standby" state
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static void
em_standby_eeprom(struct em_hw *hw)
{
	struct em_eeprom_info *eeprom = &hw->eeprom;
	uint32_t eecd;
	eecd = E1000_READ_REG(hw, EECD);

	if (eeprom->type == em_eeprom_microwire) {
		eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
		E1000_WRITE_REG(hw, EECD, eecd);
		E1000_WRITE_FLUSH(hw);
		usec_delay(eeprom->delay_usec);

		/* Clock high */
		eecd |= E1000_EECD_SK;
		E1000_WRITE_REG(hw, EECD, eecd);
		E1000_WRITE_FLUSH(hw);
		usec_delay(eeprom->delay_usec);

		/* Select EEPROM */
		eecd |= E1000_EECD_CS;
		E1000_WRITE_REG(hw, EECD, eecd);
		E1000_WRITE_FLUSH(hw);
		usec_delay(eeprom->delay_usec);

		/* Clock low */
		eecd &= ~E1000_EECD_SK;
		E1000_WRITE_REG(hw, EECD, eecd);
		E1000_WRITE_FLUSH(hw);
		usec_delay(eeprom->delay_usec);
	} else if (eeprom->type == em_eeprom_spi) {
		/* Toggle CS to flush commands */
		eecd |= E1000_EECD_CS;
		E1000_WRITE_REG(hw, EECD, eecd);
		E1000_WRITE_FLUSH(hw);
		usec_delay(eeprom->delay_usec);
		eecd &= ~E1000_EECD_CS;
		E1000_WRITE_REG(hw, EECD, eecd);
		E1000_WRITE_FLUSH(hw);
		usec_delay(eeprom->delay_usec);
	}
}

/******************************************************************************
 * Terminates a command by inverting the EEPROM's chip select pin
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static void
em_release_eeprom(struct em_hw *hw)
{
	uint32_t eecd;
	DEBUGFUNC("em_release_eeprom");

	eecd = E1000_READ_REG(hw, EECD);

	if (hw->eeprom.type == em_eeprom_spi) {
		eecd |= E1000_EECD_CS;	/* Pull CS high */
		eecd &= ~E1000_EECD_SK;	/* Lower SCK */

		E1000_WRITE_REG(hw, EECD, eecd);

		usec_delay(hw->eeprom.delay_usec);
	} else if (hw->eeprom.type == em_eeprom_microwire) {
		/* cleanup eeprom */

		/* CS on Microwire is active-high */
		eecd &= ~(E1000_EECD_CS | E1000_EECD_DI);

		E1000_WRITE_REG(hw, EECD, eecd);

		/* Rising edge of clock */
		eecd |= E1000_EECD_SK;
		E1000_WRITE_REG(hw, EECD, eecd);
		E1000_WRITE_FLUSH(hw);
		usec_delay(hw->eeprom.delay_usec);

		/* Falling edge of clock */
		eecd &= ~E1000_EECD_SK;
		E1000_WRITE_REG(hw, EECD, eecd);
		E1000_WRITE_FLUSH(hw);
		usec_delay(hw->eeprom.delay_usec);
	}
	/* Stop requesting EEPROM access */
	if (hw->mac_type > em_82544) {
		eecd &= ~E1000_EECD_REQ;
		E1000_WRITE_REG(hw, EECD, eecd);
	}
	em_swfw_sync_release(hw, E1000_SWFW_EEP_SM);
}

/******************************************************************************
 * Reads a 16 bit word from the EEPROM.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
STATIC int32_t
em_spi_eeprom_ready(struct em_hw *hw)
{
	uint16_t retry_count = 0;
	uint8_t  spi_stat_reg;
	DEBUGFUNC("em_spi_eeprom_ready");
	/*
	 * Read "Status Register" repeatedly until the LSB is cleared.  The
	 * EEPROM will signal that the command has been completed by clearing
	 * bit 0 of the internal status register.  If it's not cleared within
	 * 5 milliseconds, then error out.
	 */
	retry_count = 0;
	do {
		em_shift_out_ee_bits(hw, EEPROM_RDSR_OPCODE_SPI,
		    hw->eeprom.opcode_bits);
		spi_stat_reg = (uint8_t) em_shift_in_ee_bits(hw, 8);
		if (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))
			break;

		usec_delay(5);
		retry_count += 5;

		em_standby_eeprom(hw);
	} while (retry_count < EEPROM_MAX_RETRY_SPI);
	/*
	 * ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
	 * only 0-5mSec on 5V devices)
	 */
	if (retry_count >= EEPROM_MAX_RETRY_SPI) {
		DEBUGOUT("SPI EEPROM Status error\n");
		return -E1000_ERR_EEPROM;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Reads a 16 bit word from the EEPROM.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset of  word in the EEPROM to read
 * data - word read from the EEPROM
 * words - number of words to read
 *****************************************************************************/
int32_t
em_read_eeprom(struct em_hw *hw, uint16_t offset, uint16_t words,
    uint16_t *data)
{
	struct em_eeprom_info *eeprom = &hw->eeprom;
	uint32_t i = 0;
	DEBUGFUNC("em_read_eeprom");

	/* If eeprom is not yet detected, do so now */
	if (eeprom->word_size == 0)
		em_init_eeprom_params(hw);
	/*
	 * A check for invalid values:  offset too large, too many words, and
	 * not enough words.
	 */
	if ((offset >= eeprom->word_size) || 
	    (words > eeprom->word_size - offset) ||
	    (words == 0)) {
		DEBUGOUT2("\"words\" parameter out of bounds. Words = %d,"
		    " size = %d\n", offset, eeprom->word_size);
		return -E1000_ERR_EEPROM;
	}
	/*
	 * EEPROM's that don't use EERD to read require us to bit-bang the
	 * SPI directly. In this case, we need to acquire the EEPROM so that
	 * FW or other port software does not interrupt.
	 */
	if (em_is_onboard_nvm_eeprom(hw) == TRUE &&
	    em_get_flash_presence_i210(hw) == TRUE &&
	    hw->eeprom.use_eerd == FALSE) {
		/* Prepare the EEPROM for bit-bang reading */
		if (em_acquire_eeprom(hw) != E1000_SUCCESS)
			return -E1000_ERR_EEPROM;
	}
	/* Eerd register EEPROM access requires no eeprom aquire/release */
	if (eeprom->use_eerd == TRUE)
		return em_read_eeprom_eerd(hw, offset, words, data);

	/* ICH EEPROM access is done via the ICH flash controller */
	if (eeprom->type == em_eeprom_ich8)
		return em_read_eeprom_ich8(hw, offset, words, data);

	/* Some i210/i211 have a special OTP chip */
	if (eeprom->type == em_eeprom_invm)
		return em_read_invm_i210(hw, offset, words, data);

	/*
	 * Set up the SPI or Microwire EEPROM for bit-bang reading.  We have
	 * acquired the EEPROM at this point, so any returns should relase it
	 */
	if (eeprom->type == em_eeprom_spi) {
		uint16_t word_in;
		uint8_t  read_opcode = EEPROM_READ_OPCODE_SPI;
		if (em_spi_eeprom_ready(hw)) {
			em_release_eeprom(hw);
			return -E1000_ERR_EEPROM;
		}
		em_standby_eeprom(hw);
		/*
		 * Some SPI eeproms use the 8th address bit embedded in the
		 * opcode
		 */
		if ((eeprom->address_bits == 8) && (offset >= 128))
			read_opcode |= EEPROM_A8_OPCODE_SPI;

		/* Send the READ command (opcode + addr)  */
		em_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);
		em_shift_out_ee_bits(hw, (uint16_t) (offset * 2), 
		    eeprom->address_bits);
		/*
		 * Read the data.  The address of the eeprom internally
		 * increments with each byte (spi) being read, saving on the
		 * overhead of eeprom setup and tear-down.  The address
		 * counter will roll over if reading beyond the size of the
		 * eeprom, thus allowing the entire memory to be read
		 * starting from any offset.
		 */
		for (i = 0; i < words; i++) {
			word_in = em_shift_in_ee_bits(hw, 16);
			data[i] = (word_in >> 8) | (word_in << 8);
		}
	} else if (eeprom->type == em_eeprom_microwire) {
		for (i = 0; i < words; i++) {
			/* Send the READ command (opcode + addr)  */
			em_shift_out_ee_bits(hw, EEPROM_READ_OPCODE_MICROWIRE,
			    eeprom->opcode_bits);
			em_shift_out_ee_bits(hw, (uint16_t) (offset + i),
			    eeprom->address_bits);
			/*
			 * Read the data.  For microwire, each word requires
			 * the overhead of eeprom setup and tear-down.
			 */
			data[i] = em_shift_in_ee_bits(hw, 16);
			em_standby_eeprom(hw);
		}
	}
	/* End this read operation */
	em_release_eeprom(hw);

	return E1000_SUCCESS;
}

/******************************************************************************
 * Reads a 16 bit word from the EEPROM using the EERD register.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset of  word in the EEPROM to read
 * data - word read from the EEPROM
 * words - number of words to read
 *****************************************************************************/
STATIC int32_t
em_read_eeprom_eerd(struct em_hw *hw, uint16_t offset, uint16_t words,
    uint16_t *data)
{
	uint32_t i, eerd = 0;
	int32_t  error = 0;
	for (i = 0; i < words; i++) {
		eerd = ((offset + i) << E1000_EEPROM_RW_ADDR_SHIFT) +
		    E1000_EEPROM_RW_REG_START;

		E1000_WRITE_REG(hw, EERD, eerd);
		error = em_poll_eerd_eewr_done(hw, E1000_EEPROM_POLL_READ);

		if (error) {
			break;
		}
		data[i] = (E1000_READ_REG(hw, EERD) >> 
		    E1000_EEPROM_RW_REG_DATA);

	}

	return error;
}

/******************************************************************************
 * Writes a 16 bit word from the EEPROM using the EEWR register.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset of  word in the EEPROM to read
 * data - word read from the EEPROM
 * words - number of words to read
 *****************************************************************************/
STATIC int32_t
em_write_eeprom_eewr(struct em_hw *hw, uint16_t offset, uint16_t words,
    uint16_t *data)
{
	uint32_t register_value = 0;
	uint32_t i = 0;
	int32_t  error = 0;
	if (em_swfw_sync_acquire(hw, E1000_SWFW_EEP_SM))
		return -E1000_ERR_SWFW_SYNC;

	for (i = 0; i < words; i++) {
		register_value = (data[i] << E1000_EEPROM_RW_REG_DATA) |
		    ((offset + i) << E1000_EEPROM_RW_ADDR_SHIFT) |
		    E1000_EEPROM_RW_REG_START;

		error = em_poll_eerd_eewr_done(hw, E1000_EEPROM_POLL_WRITE);
		if (error) {
			break;
		}
		E1000_WRITE_REG(hw, EEWR, register_value);

		error = em_poll_eerd_eewr_done(hw, E1000_EEPROM_POLL_WRITE);

		if (error) {
			break;
		}
	}

	em_swfw_sync_release(hw, E1000_SWFW_EEP_SM);
	return error;
}

/******************************************************************************
 * Polls the status bit (bit 1) of the EERD to determine when the read is done.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
STATIC int32_t
em_poll_eerd_eewr_done(struct em_hw *hw, int eerd)
{
	uint32_t attempts = 100000;
	uint32_t i, reg = 0;
	int32_t  done = E1000_ERR_EEPROM;
	for (i = 0; i < attempts; i++) {
		if (eerd == E1000_EEPROM_POLL_READ)
			reg = E1000_READ_REG(hw, EERD);
		else
			reg = E1000_READ_REG(hw, EEWR);

		if (reg & E1000_EEPROM_RW_REG_DONE) {
			done = E1000_SUCCESS;
			break;
		}
		usec_delay(5);
	}

	return done;
}

/******************************************************************************
 * Description:     Determines if the onboard NVM is FLASH or EEPROM.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
STATIC boolean_t
em_is_onboard_nvm_eeprom(struct em_hw *hw)
{
	uint32_t eecd = 0;
	DEBUGFUNC("em_is_onboard_nvm_eeprom");

	if (IS_ICH8(hw->mac_type))
		return FALSE;

	if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
		eecd = E1000_READ_REG(hw, EECD);

		/* Isolate bits 15 & 16 */
		eecd = ((eecd >> 15) & 0x03);

		/* If both bits are set, device is Flash type */
		if (eecd == 0x03) {
			return FALSE;
		}
	}
	return TRUE;
}

/******************************************************************************
 * Check if flash device is detected.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
boolean_t
em_get_flash_presence_i210(struct em_hw *hw)
{
	uint32_t eecd;
	DEBUGFUNC("em_get_flash_presence_i210");

	if (hw->mac_type != em_i210)
		return TRUE;

	eecd = E1000_READ_REG(hw, EECD);

	if (eecd & E1000_EECD_FLUPD)
		return TRUE;

	return FALSE;
}

/******************************************************************************
 * Verifies that the EEPROM has a valid checksum
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Reads the first 64 16 bit words of the EEPROM and sums the values read.
 * If the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is
 * valid.
 *****************************************************************************/
int32_t
em_validate_eeprom_checksum(struct em_hw *hw)
{
	uint16_t checksum = 0;
	uint16_t i, eeprom_data;
	uint16_t checksum_reg;
	DEBUGFUNC("em_validate_eeprom_checksum");

	checksum_reg = hw->mac_type != em_icp_xxxx ? 
	    EEPROM_CHECKSUM_REG : 
	    EEPROM_CHECKSUM_REG_ICP_xxxx;

	if (((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) &&
	    (em_is_onboard_nvm_eeprom(hw) == FALSE)) {
		/*
		 * Check bit 4 of word 10h.  If it is 0, firmware is done
		 * updating 10h-12h.  Checksum may need to be fixed.
		 */
		em_read_eeprom(hw, 0x10, 1, &eeprom_data);
		if ((eeprom_data & 0x10) == 0) {
			/*
			 * Read 0x23 and check bit 15.  This bit is a 1 when
			 * the checksum has already been fixed.  If the
			 * checksum is still wrong and this bit is a 1, we
			 * need to return bad checksum.  Otherwise, we need
			 * to set this bit to a 1 and update the checksum.
			 */
			em_read_eeprom(hw, 0x23, 1, &eeprom_data);
			if ((eeprom_data & 0x8000) == 0) {
				eeprom_data |= 0x8000;
				em_write_eeprom(hw, 0x23, 1, &eeprom_data);
				em_update_eeprom_checksum(hw);
			}
		}
	}
	if (IS_ICH8(hw->mac_type)) {
		uint16_t word;
		uint16_t valid_csum_mask;
		
		/*
		 * Drivers must allocate the shadow ram structure for the
		 * EEPROM checksum to be updated.  Otherwise, this bit as
		 * well as the checksum must both be set correctly for this
		 * validation to pass.
		 */
		switch (hw->mac_type) {
		case em_pch_lpt:
		case em_pch_spt:
			word = EEPROM_COMPAT;
			valid_csum_mask = EEPROM_COMPAT_VALID_CSUM;
			break;
		default:
			word = EEPROM_FUTURE_INIT_WORD1;
			valid_csum_mask = EEPROM_FUTURE_INIT_WORD1_VALID_CSUM;
			break;
		}
		em_read_eeprom(hw, word, 1, &eeprom_data);
		if ((eeprom_data & valid_csum_mask) == 0) {
			eeprom_data |= valid_csum_mask;
			em_write_eeprom(hw, word, 1, &eeprom_data);
			em_update_eeprom_checksum(hw);
		}
	}
	for (i = 0; i < (checksum_reg + 1); i++) {
		if (em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
			DEBUGOUT("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		checksum += eeprom_data;
	}

	if (checksum == (uint16_t) EEPROM_SUM)
		return E1000_SUCCESS;
	else {
		DEBUGOUT("EEPROM Checksum Invalid\n");
		return -E1000_ERR_EEPROM;
	}
}

/******************************************************************************
 * Calculates the EEPROM checksum and writes it to the EEPROM
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.
 * Writes the difference to word offset 63 of the EEPROM.
 *****************************************************************************/
int32_t
em_update_eeprom_checksum(struct em_hw *hw)
{
	uint32_t ctrl_ext;
	uint16_t checksum = 0;
	uint16_t i, eeprom_data;
	DEBUGFUNC("em_update_eeprom_checksum");

	for (i = 0; i < EEPROM_CHECKSUM_REG; i++) {
		if (em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
			DEBUGOUT("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		checksum += eeprom_data;
	}
	checksum = (uint16_t) EEPROM_SUM - checksum;
	if (em_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
		DEBUGOUT("EEPROM Write Error\n");
		return -E1000_ERR_EEPROM;
	} else if (hw->eeprom.type == em_eeprom_flash) {
		em_commit_shadow_ram(hw);
	} else if (hw->eeprom.type == em_eeprom_ich8) {
		em_commit_shadow_ram(hw);
		/*
		 * Reload the EEPROM, or else modifications will not appear
		 * until after next adapter reset.
		 */
		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
		ctrl_ext |= E1000_CTRL_EXT_EE_RST;
		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
		msec_delay(10);
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Parent function for writing words to the different EEPROM types.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset within the EEPROM to be written to
 * words - number of words to write
 * data - 16 bit word to be written to the EEPROM
 *
 * If em_update_eeprom_checksum is not called after this function, the
 * EEPROM will most likely contain an invalid checksum.
 *****************************************************************************/
int32_t
em_write_eeprom(struct em_hw *hw, uint16_t offset, uint16_t words,
    uint16_t *data)
{
	struct em_eeprom_info *eeprom = &hw->eeprom;
	int32_t status = 0;
	DEBUGFUNC("em_write_eeprom");

	/* If eeprom is not yet detected, do so now */
	if (eeprom->word_size == 0)
		em_init_eeprom_params(hw);
	/*
	 * A check for invalid values:  offset too large, too many words, and
	 * not enough words.
	 */
	if ((offset >= eeprom->word_size) ||
	    (words > eeprom->word_size - offset) ||
	    (words == 0)) {
		DEBUGOUT("\"words\" parameter out of bounds\n");
		return -E1000_ERR_EEPROM;
	}
	/* 82573/4 writes only through eewr */
	if (eeprom->use_eewr == TRUE)
		return em_write_eeprom_eewr(hw, offset, words, data);

	if (eeprom->type == em_eeprom_ich8)
		return em_write_eeprom_ich8(hw, offset, words, data);

	/* Prepare the EEPROM for writing  */
	if (em_acquire_eeprom(hw) != E1000_SUCCESS)
		return -E1000_ERR_EEPROM;

	if (eeprom->type == em_eeprom_microwire) {
		status = em_write_eeprom_microwire(hw, offset, words, data);
	} else {
		status = em_write_eeprom_spi(hw, offset, words, data);
		msec_delay(10);
	}

	/* Done with writing */
	em_release_eeprom(hw);

	return status;
}

/******************************************************************************
 * Writes a 16 bit word to a given offset in an SPI EEPROM.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset within the EEPROM to be written to
 * words - number of words to write
 * data - pointer to array of 8 bit words to be written to the EEPROM
 *
 *****************************************************************************/
STATIC int32_t
em_write_eeprom_spi(struct em_hw *hw, uint16_t offset, uint16_t words,
    uint16_t *data)
{
	struct em_eeprom_info *eeprom = &hw->eeprom;
	uint16_t widx = 0;
	DEBUGFUNC("em_write_eeprom_spi");

	while (widx < words) {
		uint8_t write_opcode = EEPROM_WRITE_OPCODE_SPI;
		if (em_spi_eeprom_ready(hw))
			return -E1000_ERR_EEPROM;

		em_standby_eeprom(hw);

		/* Send the WRITE ENABLE command (8 bit opcode )  */
		em_shift_out_ee_bits(hw, EEPROM_WREN_OPCODE_SPI,
		    eeprom->opcode_bits);

		em_standby_eeprom(hw);
		/*
		 * Some SPI eeproms use the 8th address bit embedded in the
		 * opcode
		 */
		if ((eeprom->address_bits == 8) && (offset >= 128))
			write_opcode |= EEPROM_A8_OPCODE_SPI;

		/* Send the Write command (8-bit opcode + addr) */
		em_shift_out_ee_bits(hw, write_opcode, eeprom->opcode_bits);

		em_shift_out_ee_bits(hw, (uint16_t) ((offset + widx) * 2),
		    eeprom->address_bits);

		/* Send the data */
		/*
		 * Loop to allow for up to whole page write (32 bytes) of
		 * eeprom
		 */
		while (widx < words) {
			uint16_t word_out = data[widx];
			word_out = (word_out >> 8) | (word_out << 8);
			em_shift_out_ee_bits(hw, word_out, 16);
			widx++;
			/*
			 * Some larger eeprom sizes are capable of a 32-byte
			 * PAGE WRITE operation, while the smaller eeproms
			 * are capable of an 8-byte PAGE WRITE operation.
			 * Break the inner loop to pass new address
			 */
			if ((((offset + widx) * 2) % eeprom->page_size) == 0) {
				em_standby_eeprom(hw);
				break;
			}
		}
	}

	return E1000_SUCCESS;
}

/******************************************************************************
 * Writes a 16 bit word to a given offset in a Microwire EEPROM.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset within the EEPROM to be written to
 * words - number of words to write
 * data - pointer to array of 16 bit words to be written to the EEPROM
 *
 *****************************************************************************/
STATIC int32_t
em_write_eeprom_microwire(struct em_hw *hw, uint16_t offset, uint16_t words,
    uint16_t *data)
{
	struct em_eeprom_info *eeprom = &hw->eeprom;
	uint32_t eecd;
	uint16_t words_written = 0;
	uint16_t i = 0;
	DEBUGFUNC("em_write_eeprom_microwire");
	/*
	 * Send the write enable command to the EEPROM (3-bit opcode plus
	 * 6/8-bit dummy address beginning with 11).  It's less work to
	 * include the 11 of the dummy address as part of the opcode than it
	 * is to shift it over the correct number of bits for the address.
	 * This puts the EEPROM into write/erase mode.
	 */
	em_shift_out_ee_bits(hw, EEPROM_EWEN_OPCODE_MICROWIRE,
	    (uint16_t) (eeprom->opcode_bits + 2));

	em_shift_out_ee_bits(hw, 0, (uint16_t) (eeprom->address_bits - 2));

	/* Prepare the EEPROM */
	em_standby_eeprom(hw);

	while (words_written < words) {
		/* Send the Write command (3-bit opcode + addr) */
		em_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE_MICROWIRE,
		    eeprom->opcode_bits);

		em_shift_out_ee_bits(hw, (uint16_t) (offset + words_written),
		    eeprom->address_bits);

		/* Send the data */
		em_shift_out_ee_bits(hw, data[words_written], 16);
		/*
		 * Toggle the CS line.  This in effect tells the EEPROM to
		 * execute the previous command.
		 */
		em_standby_eeprom(hw);
		/*
		 * Read DO repeatedly until it is high (equal to '1').  The
		 * EEPROM will signal that the command has been completed by
		 * raising the DO signal. If DO does not go high in 10
		 * milliseconds, then error out.
		 */
		for (i = 0; i < 200; i++) {
			eecd = E1000_READ_REG(hw, EECD);
			if (eecd & E1000_EECD_DO)
				break;
			usec_delay(50);
		}
		if (i == 200) {
			DEBUGOUT("EEPROM Write did not complete\n");
			return -E1000_ERR_EEPROM;
		}
		/* Recover from write */
		em_standby_eeprom(hw);

		words_written++;
	}
	/*
	 * Send the write disable command to the EEPROM (3-bit opcode plus
	 * 6/8-bit dummy address beginning with 10).  It's less work to
	 * include the 10 of the dummy address as part of the opcode than it
	 * is to shift it over the correct number of bits for the address.
	 * This takes the EEPROM out of write/erase mode.
	 */
	em_shift_out_ee_bits(hw, EEPROM_EWDS_OPCODE_MICROWIRE,
	    (uint16_t) (eeprom->opcode_bits + 2));

	em_shift_out_ee_bits(hw, 0, (uint16_t) (eeprom->address_bits - 2));

	return E1000_SUCCESS;
}

/******************************************************************************
 * Flushes the cached eeprom to NVM. This is done by saving the modified values
 * in the eeprom cache and the non modified values in the currently active bank
 * to the new bank.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset of  word in the EEPROM to read
 * data - word read from the EEPROM
 * words - number of words to read
 *****************************************************************************/
STATIC int32_t
em_commit_shadow_ram(struct em_hw *hw)
{
	uint32_t  attempts = 100000;
	uint32_t  eecd = 0;
	uint32_t  flop = 0;
	uint32_t  i = 0;
	int32_t   error = E1000_SUCCESS;
	uint32_t  old_bank_offset = 0;
	uint32_t  new_bank_offset = 0;
	uint8_t   low_byte = 0;
	uint8_t   high_byte = 0;
	boolean_t sector_write_failed = FALSE;
	if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
		/*
		 * The flop register will be used to determine if flash type
		 * is STM
		 */
		flop = E1000_READ_REG(hw, FLOP);
		for (i = 0; i < attempts; i++) {
			eecd = E1000_READ_REG(hw, EECD);
			if ((eecd & E1000_EECD_FLUPD) == 0) {
				break;
			}
			usec_delay(5);
		}

		if (i == attempts) {
			return -E1000_ERR_EEPROM;
		}
		/* 
		 * If STM opcode located in bits 15:8 of flop, reset firmware
		 */
		if ((flop & 0xFF00) == E1000_STM_OPCODE) {
			E1000_WRITE_REG(hw, HICR, E1000_HICR_FW_RESET);
		}
		/* Perform the flash update */
		E1000_WRITE_REG(hw, EECD, eecd | E1000_EECD_FLUPD);

		for (i = 0; i < attempts; i++) {
			eecd = E1000_READ_REG(hw, EECD);
			if ((eecd & E1000_EECD_FLUPD) == 0) {
				break;
			}
			usec_delay(5);
		}

		if (i == attempts) {
			return -E1000_ERR_EEPROM;
		}
	}
	if ((hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) &&
	    hw->eeprom_shadow_ram != NULL) {
		/*
		 * We're writing to the opposite bank so if we're on bank 1,
		 * write to bank 0 etc.  We also need to erase the segment
		 * that is going to be written
		 */
		if (!(E1000_READ_REG(hw, EECD) & E1000_EECD_SEC1VAL)) {
			new_bank_offset = hw->flash_bank_size * 2;
			old_bank_offset = 0;
			em_erase_ich8_4k_segment(hw, 1);
		} else {
			old_bank_offset = hw->flash_bank_size * 2;
			new_bank_offset = 0;
			em_erase_ich8_4k_segment(hw, 0);
		}

		sector_write_failed = FALSE;
		/*
		 * Loop for every byte in the shadow RAM, which is in units
		 * of words.
		 */
		for (i = 0; i < E1000_SHADOW_RAM_WORDS; i++) {
			/*
			 * Determine whether to write the value stored in the
			 * other NVM bank or a modified value stored in the
			 * shadow RAM
			 */
			if (hw->eeprom_shadow_ram[i].modified == TRUE) {
				low_byte = (uint8_t) 
				    hw->eeprom_shadow_ram[i].eeprom_word;
				usec_delay(100);
				error = em_verify_write_ich8_byte(hw,
				    (i << 1) + new_bank_offset, low_byte);

				if (error != E1000_SUCCESS)
					sector_write_failed = TRUE;
				else {
					high_byte = (uint8_t)
					    (hw->eeprom_shadow_ram
					    [i].eeprom_word >> 8);
					usec_delay(100);
				}
			} else {
				em_read_ich8_byte(hw, (i << 1) + 
				    old_bank_offset, &low_byte);
				usec_delay(100);
				error = em_verify_write_ich8_byte(hw,
				      (i << 1) + new_bank_offset, low_byte);

				if (error != E1000_SUCCESS)
					sector_write_failed = TRUE;
				else {
					em_read_ich8_byte(hw, (i << 1) +
					    old_bank_offset + 1, &high_byte);
					usec_delay(100);
				}
			}
			/*
			 * If the write of the low byte was successful, go
			 * ahread and write the high byte while checking to
			 * make sure that if it is the signature byte, then
			 * it is handled properly
			 */
			if (sector_write_failed == FALSE) {
				/*
				 * If the word is 0x13, then make sure the
				 * signature bits (15:14) are 11b until the
				 * commit has completed. This will allow us
				 * to write 10b which indicates the signature
				 * is valid.  We want to do this after the
				 * write has completed so that we don't mark
				 * the segment valid while the write is still
				 * in progress
				 */
				if (i == E1000_ICH_NVM_SIG_WORD)
					high_byte = E1000_ICH_NVM_VALID_SIG_MASK |
					    high_byte;

				error = em_verify_write_ich8_byte(hw, (i << 1)
				    + new_bank_offset + 1, high_byte);
				if (error != E1000_SUCCESS)
					sector_write_failed = TRUE;

			} else {
				/*
				 * If the write failed then break from the
				 * loop and return an error
				 */
				break;
			}
		}
		/*
		 * Don't bother writing the segment valid bits if sector
		 * programming failed.
		 */
		if (sector_write_failed == FALSE) {
			/*
			 * Finally validate the new segment by setting bit
			 * 15:14 to 10b in word 0x13 , this can be done
			 * without an erase as well since these bits are 11
			 * to start with and we need to change bit 14 to 0b
			 */
			em_read_ich8_byte(hw, E1000_ICH_NVM_SIG_WORD * 2 + 1 +
			    new_bank_offset, &high_byte);
			high_byte &= 0xBF;
			error = em_verify_write_ich8_byte(hw,
			    E1000_ICH_NVM_SIG_WORD * 2 + 1 + new_bank_offset,
			    high_byte);
			/*
			 * And invalidate the previously valid segment by
			 * setting its signature word (0x13) high_byte to 0b.
			 * This can be done without an erase because flash
			 * erase sets all bits to 1's. We can write 1's to
			 * 0's without an erase
			 */
			if (error == E1000_SUCCESS) {
				error = em_verify_write_ich8_byte(hw,
				    E1000_ICH_NVM_SIG_WORD * 2 + 1 +
				    old_bank_offset, 0);
			}
			/* Clear the now not used entry in the cache */
			for (i = 0; i < E1000_SHADOW_RAM_WORDS; i++) {
				hw->eeprom_shadow_ram[i].modified = FALSE;
				hw->eeprom_shadow_ram[i].eeprom_word = 0xFFFF;
			}
		}
	}
	return error;
}

/******************************************************************************
 * Reads the adapter's part number from the EEPROM
 *
 * hw - Struct containing variables accessed by shared code
 * part_num - Adapter's part number
 *****************************************************************************/
int32_t
em_read_part_num(struct em_hw *hw, uint32_t *part_num)
{
	uint16_t offset = EEPROM_PBA_BYTE_1;
	uint16_t eeprom_data;
	DEBUGFUNC("em_read_part_num");

	/* Get word 0 from EEPROM */
	if (em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
		DEBUGOUT("EEPROM Read Error\n");
		return -E1000_ERR_EEPROM;
	}
	/* Save word 0 in upper half of part_num */
	*part_num = (uint32_t) (eeprom_data << 16);

	/* Get word 1 from EEPROM */
	if (em_read_eeprom(hw, ++offset, 1, &eeprom_data) < 0) {
		DEBUGOUT("EEPROM Read Error\n");
		return -E1000_ERR_EEPROM;
	}
	/* Save word 1 in lower half of part_num */
	*part_num |= eeprom_data;

	return E1000_SUCCESS;
}

/******************************************************************************
 * Reads the adapter's MAC address from the EEPROM and inverts the LSB for the
 * second function of dual function devices
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_read_mac_addr(struct em_hw *hw)
{
	uint16_t offset;
	uint16_t eeprom_data, i;
	uint16_t ia_base_addr = 0;
	DEBUGFUNC("em_read_mac_addr");

	if (hw->mac_type == em_icp_xxxx) {
		ia_base_addr = (uint16_t)
		EEPROM_IA_START_ICP_xxxx(hw->icp_xxxx_port_num);
	} else if (hw->mac_type == em_82580 || hw->mac_type == em_i350) {
		ia_base_addr = NVM_82580_LAN_FUNC_OFFSET(hw->bus_func);
	}
	for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
		offset = i >> 1;
		if (em_read_eeprom(hw, offset + ia_base_addr, 1, &eeprom_data)
		    < 0) {
			DEBUGOUT("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		hw->perm_mac_addr[i] = (uint8_t) (eeprom_data & 0x00FF);
		hw->perm_mac_addr[i + 1] = (uint8_t) (eeprom_data >> 8);
	}

	switch (hw->mac_type) {
	default:
		break;
	case em_82546:
	case em_82546_rev_3:
	case em_82571:
	case em_82575:
	case em_80003es2lan:
		if (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)
			hw->perm_mac_addr[5] ^= 0x01;
		break;
	}

	for (i = 0; i < NODE_ADDRESS_SIZE; i++)
		hw->mac_addr[i] = hw->perm_mac_addr[i];
	return E1000_SUCCESS;
}

/******************************************************************************
 * Explicitly disables jumbo frames and resets some PHY registers back to hw-
 * defaults. This is necessary in case the ethernet cable was inserted AFTER
 * the firmware initialized the PHY. Otherwise it is left in a state where
 * it is possible to transmit but not receive packets. Observed on I217-LM and
 * fixed in FreeBSD's sys/dev/e1000/e1000_ich8lan.c.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
STATIC int32_t
em_phy_no_cable_workaround(struct em_hw *hw) {
	int32_t ret_val, dft_ret_val;
	uint32_t mac_reg;
	uint16_t data, phy_reg;

	/* disable Rx path while enabling workaround */
	em_read_phy_reg(hw, I2_DFT_CTRL, &phy_reg);
	ret_val = em_write_phy_reg(hw, I2_DFT_CTRL, phy_reg | (1 << 14));
	if (ret_val)
		return ret_val;

	/* Write MAC register values back to h/w defaults */
	mac_reg = E1000_READ_REG(hw, FFLT_DBG);
	mac_reg &= ~(0xF << 14);
	E1000_WRITE_REG(hw, FFLT_DBG, mac_reg);

	mac_reg = E1000_READ_REG(hw, RCTL);
	mac_reg &= ~E1000_RCTL_SECRC;
	E1000_WRITE_REG(hw, RCTL, mac_reg);

	ret_val = em_read_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_CTRL, &data);
	if (ret_val)
		goto out;
	ret_val = em_write_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_CTRL,
	    data & ~(1 << 0));
	if (ret_val)
		goto out;

	ret_val = em_read_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_HD_CTRL, &data);
	if (ret_val)
		goto out;

	data &= ~(0xF << 8);
	data |= (0xB << 8);
	ret_val = em_write_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_HD_CTRL, data);
	if (ret_val)
		goto out;

	/* Write PHY register values back to h/w defaults */
	em_read_phy_reg(hw, I2_SMBUS_CTRL, &data);
	data &= ~(0x7F << 5);
	ret_val = em_write_phy_reg(hw, I2_SMBUS_CTRL, data);
	if (ret_val)
		goto out;

	em_read_phy_reg(hw, I2_MODE_CTRL, &data);
	data |= (1 << 13);
	ret_val = em_write_phy_reg(hw, I2_MODE_CTRL, data);
	if (ret_val)
		goto out;

	/*
	 * 776.20 and 776.23 are not documented in
	 * i217-ethernet-controller-datasheet.pdf...
	 */
	em_read_phy_reg(hw, PHY_REG(776, 20), &data);
	data &= ~(0x3FF << 2);
	data |= (0x8 << 2);
	ret_val = em_write_phy_reg(hw, PHY_REG(776, 20), data);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, PHY_REG(776, 23), 0x7E00);
	if (ret_val)
		goto out;

	em_read_phy_reg(hw, I2_PCIE_POWER_CTRL, &data);
	ret_val = em_write_phy_reg(hw, I2_PCIE_POWER_CTRL, data & ~(1 << 10));
	if (ret_val)
		goto out;

out:
	/* re-enable Rx path after enabling workaround */
	dft_ret_val = em_write_phy_reg(hw, I2_DFT_CTRL, phy_reg & ~(1 << 14));
	if (ret_val)
		return ret_val;
	else
		return dft_ret_val;
}

/******************************************************************************
 * Initializes receive address filters.
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Places the MAC address in receive address register 0 and clears the rest
 * of the receive addresss registers. Clears the multicast table. Assumes
 * the receiver is in reset when the routine is called.
 *****************************************************************************/
STATIC void
em_init_rx_addrs(struct em_hw *hw)
{
	uint32_t i;
	uint32_t rar_num;
	DEBUGFUNC("em_init_rx_addrs");

	if (hw->mac_type == em_pch_lpt || hw->mac_type == em_pch_spt || hw->mac_type == em_pch2lan)
		if (em_phy_no_cable_workaround(hw))
			printf(" ...failed to apply em_phy_no_cable_"
			    "workaround.\n");

	/* Setup the receive address. */
	DEBUGOUT("Programming MAC Address into RAR[0]\n");

	em_rar_set(hw, hw->mac_addr, 0);

	rar_num = E1000_RAR_ENTRIES;
	/*
	 * Reserve a spot for the Locally Administered Address to work around
	 * an 82571 issue in which a reset on one port will reload the MAC on
	 * the other port.
	 */
	if ((hw->mac_type == em_82571) && (hw->laa_is_present == TRUE))
		rar_num -= 1;
	if (IS_ICH8(hw->mac_type))
		rar_num = E1000_RAR_ENTRIES_ICH8LAN;
	if (hw->mac_type == em_ich8lan)
		rar_num -= 1;
	if (hw->mac_type == em_82580)
		rar_num = E1000_RAR_ENTRIES_82580;
	if (hw->mac_type == em_i210)
		rar_num = E1000_RAR_ENTRIES_82575;
	if (hw->mac_type == em_i350)
		rar_num = E1000_RAR_ENTRIES_I350;

	/* Zero out the other 15 receive addresses. */
	DEBUGOUT("Clearing RAR[1-15]\n");
	for (i = 1; i < rar_num; i++) {
		E1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);
		E1000_WRITE_FLUSH(hw);
		E1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);
		E1000_WRITE_FLUSH(hw);
	}
}

/******************************************************************************
 * Updates the MAC's list of multicast addresses.
 *
 * hw - Struct containing variables accessed by shared code
 * mc_addr_list - the list of new multicast addresses
 * mc_addr_count - number of addresses
 * pad - number of bytes between addresses in the list
 * rar_used_count - offset where to start adding mc addresses into the RAR's
 *
 * The given list replaces any existing list. Clears the last 15 receive
 * address registers and the multicast table. Uses receive address registers
 * for the first 15 multicast addresses, and hashes the rest into the
 * multicast table.
 *****************************************************************************/
void
em_mc_addr_list_update(struct em_hw *hw, uint8_t *mc_addr_list,
    uint32_t mc_addr_count, uint32_t pad, uint32_t rar_used_count)
{
	uint32_t hash_value;
	uint32_t i;
	uint32_t num_rar_entry;
	uint32_t num_mta_entry;
	DEBUGFUNC("em_mc_addr_list_update");
	/*
	 * Set the new number of MC addresses that we are being requested to
	 * use.
	 */
	hw->num_mc_addrs = mc_addr_count;

	/* Clear RAR[1-15] */
	DEBUGOUT(" Clearing RAR[1-15]\n");
	num_rar_entry = E1000_RAR_ENTRIES;
	if (IS_ICH8(hw->mac_type))
		num_rar_entry = E1000_RAR_ENTRIES_ICH8LAN;
	if (hw->mac_type == em_ich8lan)
		num_rar_entry -= 1;
	/*
	 * Reserve a spot for the Locally Administered Address to work around
	 * an 82571 issue in which a reset on one port will reload the MAC on
	 * the other port.
	 */
	if ((hw->mac_type == em_82571) && (hw->laa_is_present == TRUE))
		num_rar_entry -= 1;

	for (i = rar_used_count; i < num_rar_entry; i++) {
		E1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);
		E1000_WRITE_FLUSH(hw);
		E1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);
		E1000_WRITE_FLUSH(hw);
	}

	/* Clear the MTA */
	DEBUGOUT(" Clearing MTA\n");
	num_mta_entry = E1000_NUM_MTA_REGISTERS;
	if (IS_ICH8(hw->mac_type))
		num_mta_entry = E1000_NUM_MTA_REGISTERS_ICH8LAN;

	for (i = 0; i < num_mta_entry; i++) {
		E1000_WRITE_REG_ARRAY(hw, MTA, i, 0);
		E1000_WRITE_FLUSH(hw);
	}

	/* Add the new addresses */
	for (i = 0; i < mc_addr_count; i++) {
		DEBUGOUT(" Adding the multicast addresses:\n");
		DEBUGOUT7(" MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X\n", i,
		    mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad)],
		    mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 1],
		    mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 2],
		    mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 3],
		    mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 4],
		    mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 5]);

		hash_value = em_hash_mc_addr(hw, mc_addr_list +
		    (i * (ETH_LENGTH_OF_ADDRESS + pad)));

		DEBUGOUT1(" Hash value = 0x%03X\n", hash_value);
		/*
		 * Place this multicast address in the RAR if there is room, *
		 * else put it in the MTA
		 */
		if (rar_used_count < num_rar_entry) {
			em_rar_set(hw, mc_addr_list + 
			    (i * (ETH_LENGTH_OF_ADDRESS + pad)),
			    rar_used_count);
			rar_used_count++;
		} else {
			em_mta_set(hw, hash_value);
		}
	}
	DEBUGOUT("MC Update Complete\n");
}

/******************************************************************************
 * Hashes an address to determine its location in the multicast table
 *
 * hw - Struct containing variables accessed by shared code
 * mc_addr - the multicast address to hash
 *****************************************************************************/
uint32_t
em_hash_mc_addr(struct em_hw *hw, uint8_t *mc_addr)
{
	uint32_t hash_value = 0;
	/*
	 * The portion of the address that is used for the hash table is
	 * determined by the mc_filter_type setting.
	 */
	switch (hw->mc_filter_type) {
		/*
		 * [0] [1] [2] [3] [4] [5] 01  AA  00  12  34  56 LSB
		 * MSB
		 */
	case 0:
		if (IS_ICH8(hw->mac_type)) {
			/* [47:38] i.e. 0x158 for above example address */
			hash_value = ((mc_addr[4] >> 6) | 
			    (((uint16_t) mc_addr[5]) << 2));
		} else {
			/* [47:36] i.e. 0x563 for above example address */
			hash_value = ((mc_addr[4] >> 4) | 
			    (((uint16_t) mc_addr[5]) << 4));
		}
		break;
	case 1:
		if (IS_ICH8(hw->mac_type)) {
			/* [46:37] i.e. 0x2B1 for above example address */
			hash_value = ((mc_addr[4] >> 5) |
			    (((uint16_t) mc_addr[5]) << 3));
		} else {
			/* [46:35] i.e. 0xAC6 for above example address */
			hash_value = ((mc_addr[4] >> 3) |
			    (((uint16_t) mc_addr[5]) << 5));
		}
		break;
	case 2:
		if (IS_ICH8(hw->mac_type)) {
			/* [45:36] i.e. 0x163 for above example address */
			hash_value = ((mc_addr[4] >> 4) |
			    (((uint16_t) mc_addr[5]) << 4));
		} else {
			/* [45:34] i.e. 0x5D8 for above example address */
			hash_value = ((mc_addr[4] >> 2) |
			    (((uint16_t) mc_addr[5]) << 6));
		}
		break;
	case 3:
		if (IS_ICH8(hw->mac_type)) {
			/* [43:34] i.e. 0x18D for above example address */
			hash_value = ((mc_addr[4] >> 2) |
			    (((uint16_t) mc_addr[5]) << 6));
		} else {
			/* [43:32] i.e. 0x634 for above example address */
			hash_value = ((mc_addr[4]) |
			    (((uint16_t) mc_addr[5]) << 8));
		}
		break;
	}

	hash_value &= 0xFFF;
	if (IS_ICH8(hw->mac_type))
		hash_value &= 0x3FF;

	return hash_value;
}

/******************************************************************************
 * Sets the bit in the multicast table corresponding to the hash value.
 *
 * hw - Struct containing variables accessed by shared code
 * hash_value - Multicast address hash value
 *****************************************************************************/
void
em_mta_set(struct em_hw *hw, uint32_t hash_value)
{
	uint32_t hash_bit, hash_reg;
	uint32_t mta;
	uint32_t temp;
	/*
	 * The MTA is a register array of 128 32-bit registers. It is treated
	 * like an array of 4096 bits.  We want to set bit
	 * BitArray[hash_value]. So we figure out what register the bit is
	 * in, read it, OR in the new bit, then write back the new value.
	 * The register is determined by the upper 7 bits of the hash value
	 * and the bit within that register are determined by the lower 5
	 * bits of the value.
	 */
	hash_reg = (hash_value >> 5) & 0x7F;
	if (IS_ICH8(hw->mac_type))
		hash_reg &= 0x1F;

	hash_bit = hash_value & 0x1F;

	mta = E1000_READ_REG_ARRAY(hw, MTA, hash_reg);

	mta |= (1 << hash_bit);
	/*
	 * If we are on an 82544 and we are trying to write an odd offset in
	 * the MTA, save off the previous entry before writing and restore
	 * the old value after writing.
	 */
	if ((hw->mac_type == em_82544) && ((hash_reg & 0x1) == 1)) {
		temp = E1000_READ_REG_ARRAY(hw, MTA, (hash_reg - 1));
		E1000_WRITE_REG_ARRAY(hw, MTA, hash_reg, mta);
		E1000_WRITE_FLUSH(hw);
		E1000_WRITE_REG_ARRAY(hw, MTA, (hash_reg - 1), temp);
		E1000_WRITE_FLUSH(hw);
	} else {
		E1000_WRITE_REG_ARRAY(hw, MTA, hash_reg, mta);
		E1000_WRITE_FLUSH(hw);
	}
}

/******************************************************************************
 * Puts an ethernet address into a receive address register.
 *
 * hw - Struct containing variables accessed by shared code
 * addr - Address to put into receive address register
 * index - Receive address register to write
 *****************************************************************************/
void
em_rar_set(struct em_hw *hw, uint8_t *addr, uint32_t index)
{
	uint32_t rar_low, rar_high;
	/*
	 * HW expects these in little endian so we reverse the byte order
	 * from network order (big endian) to little endian
	 */
	rar_low = ((uint32_t) addr[0] | ((uint32_t) addr[1] << 8) |
	    ((uint32_t) addr[2] << 16) | ((uint32_t) addr[3] << 24));
	rar_high = ((uint32_t) addr[4] | ((uint32_t) addr[5] << 8));
	/*
	 * Disable Rx and flush all Rx frames before enabling RSS to avoid Rx
	 * unit hang.
	 *
	 * Description: If there are any Rx frames queued up or otherwise
	 * present in the HW before RSS is enabled, and then we enable RSS,
	 * the HW Rx unit will hang.  To work around this issue, we have to
	 * disable receives and flush out all Rx frames before we enable RSS.
	 * To do so, we modify we redirect all Rx traffic to manageability
	 * and then reset the HW. This flushes away Rx frames, and (since the
	 * redirections to manageability persists across resets) keeps new
	 * ones from coming in while we work.  Then, we clear the Address
	 * Valid AV bit for all MAC addresses and undo the re-direction to
	 * manageability. Now, frames are coming in again, but the MAC won't
	 * accept them, so far so good.  We now proceed to initialize RSS (if
	 * necessary) and configure the Rx unit.  Last, we re-enable the AV
	 * bits and continue on our merry way.
	 */
	switch (hw->mac_type) {
	case em_82571:
	case em_82572:
	case em_80003es2lan:
		if (hw->leave_av_bit_off == TRUE)
			break;
	default:
		/* Indicate to hardware the Address is Valid. */
		rar_high |= E1000_RAH_AV;
		break;
	}

	E1000_WRITE_REG_ARRAY(hw, RA, (index << 1), rar_low);
	E1000_WRITE_FLUSH(hw);
	E1000_WRITE_REG_ARRAY(hw, RA, ((index << 1) + 1), rar_high);
	E1000_WRITE_FLUSH(hw);
}

/******************************************************************************
 * Clears the VLAN filer table
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
STATIC void
em_clear_vfta(struct em_hw *hw)
{
	uint32_t offset;
	uint32_t vfta_value = 0;
	uint32_t vfta_offset = 0;
	uint32_t vfta_bit_in_reg = 0;
	if (IS_ICH8(hw->mac_type))
		return;

	if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
		if (hw->mng_cookie.vlan_id != 0) {
			/*
			 * The VFTA is a 4096b bit-field, each identifying a
			 * single VLAN ID.  The following operations
			 * determine which 32b entry (i.e. offset) into the
			 * array we want to set the VLAN ID (i.e. bit) of the
			 * manageability unit.
			 */
			vfta_offset = (hw->mng_cookie.vlan_id >>
			    E1000_VFTA_ENTRY_SHIFT) & E1000_VFTA_ENTRY_MASK;

			vfta_bit_in_reg = 1 << (hw->mng_cookie.vlan_id &
			    E1000_VFTA_ENTRY_BIT_SHIFT_MASK);
		}
	}
	for (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {
		/*
		 * If the offset we want to clear is the same offset of the
		 * manageability VLAN ID, then clear all bits except that of
		 * the manageability unit
		 */
		vfta_value = (offset == vfta_offset) ? vfta_bit_in_reg : 0;
		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, vfta_value);
		E1000_WRITE_FLUSH(hw);
	}
}

/*
 * Due to hw errata, if the host tries to configure the VFTA register
 * while performing queries from the BMC or DMA, then the VFTA in some
 * cases won't be written.
 */
void
em_clear_vfta_i350(struct em_hw *hw)
{
	uint32_t offset;
	int i;
	
	for (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {
		for (i = 0; i < 10; i++)
			E1000_WRITE_REG_ARRAY(hw, VFTA, offset, 0);
		E1000_WRITE_FLUSH(hw);
	}
}

STATIC int32_t
em_id_led_init(struct em_hw *hw)
{
	uint32_t       ledctl;
	const uint32_t ledctl_mask = 0x000000FF;
	const uint32_t ledctl_on = E1000_LEDCTL_MODE_LED_ON;
	const uint32_t ledctl_off = E1000_LEDCTL_MODE_LED_OFF;
	uint16_t       eeprom_data, i, temp;
	const uint16_t led_mask = 0x0F;
	DEBUGFUNC("em_id_led_init");

	if (hw->mac_type < em_82540 || hw->mac_type == em_icp_xxxx) {
		/* Nothing to do */
		return E1000_SUCCESS;
	}
	ledctl = E1000_READ_REG(hw, LEDCTL);
	hw->ledctl_default = ledctl;
	hw->ledctl_mode1 = hw->ledctl_default;
	hw->ledctl_mode2 = hw->ledctl_default;

	if (em_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {
		DEBUGOUT("EEPROM Read Error\n");
		return -E1000_ERR_EEPROM;
	}
	if ((hw->mac_type == em_82573) &&
	    (eeprom_data == ID_LED_RESERVED_82573))
		eeprom_data = ID_LED_DEFAULT_82573;
	else if ((eeprom_data == ID_LED_RESERVED_0000) ||
	    (eeprom_data == ID_LED_RESERVED_FFFF)) {
		if (hw->mac_type == em_ich8lan ||
		    hw->mac_type == em_ich9lan ||
		    hw->mac_type == em_ich10lan) // XXX
			eeprom_data = ID_LED_DEFAULT_ICH8LAN;
		else
			eeprom_data = ID_LED_DEFAULT;
	}
	for (i = 0; i < 4; i++) {
		temp = (eeprom_data >> (i << 2)) & led_mask;
		switch (temp) {
		case ID_LED_ON1_DEF2:
		case ID_LED_ON1_ON2:
		case ID_LED_ON1_OFF2:
			hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
			hw->ledctl_mode1 |= ledctl_on << (i << 3);
			break;
		case ID_LED_OFF1_DEF2:
		case ID_LED_OFF1_ON2:
		case ID_LED_OFF1_OFF2:
			hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
			hw->ledctl_mode1 |= ledctl_off << (i << 3);
			break;
		default:
			/* Do nothing */
			break;
		}
		switch (temp) {
		case ID_LED_DEF1_ON2:
		case ID_LED_ON1_ON2:
		case ID_LED_OFF1_ON2:
			hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
			hw->ledctl_mode2 |= ledctl_on << (i << 3);
			break;
		case ID_LED_DEF1_OFF2:
		case ID_LED_ON1_OFF2:
		case ID_LED_OFF1_OFF2:
			hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
			hw->ledctl_mode2 |= ledctl_off << (i << 3);
			break;
		default:
			/* Do nothing */
			break;
		}
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Clears all hardware statistics counters.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
void
em_clear_hw_cntrs(struct em_hw *hw)
{
	volatile uint32_t temp;
	temp = E1000_READ_REG(hw, CRCERRS);
	temp = E1000_READ_REG(hw, SYMERRS);
	temp = E1000_READ_REG(hw, MPC);
	temp = E1000_READ_REG(hw, SCC);
	temp = E1000_READ_REG(hw, ECOL);
	temp = E1000_READ_REG(hw, MCC);
	temp = E1000_READ_REG(hw, LATECOL);
	temp = E1000_READ_REG(hw, COLC);
	temp = E1000_READ_REG(hw, DC);
	temp = E1000_READ_REG(hw, SEC);
	temp = E1000_READ_REG(hw, RLEC);
	temp = E1000_READ_REG(hw, XONRXC);
	temp = E1000_READ_REG(hw, XONTXC);
	temp = E1000_READ_REG(hw, XOFFRXC);
	temp = E1000_READ_REG(hw, XOFFTXC);
	temp = E1000_READ_REG(hw, FCRUC);

	if (!IS_ICH8(hw->mac_type)) {
		temp = E1000_READ_REG(hw, PRC64);
		temp = E1000_READ_REG(hw, PRC127);
		temp = E1000_READ_REG(hw, PRC255);
		temp = E1000_READ_REG(hw, PRC511);
		temp = E1000_READ_REG(hw, PRC1023);
		temp = E1000_READ_REG(hw, PRC1522);
	}
	temp = E1000_READ_REG(hw, GPRC);
	temp = E1000_READ_REG(hw, BPRC);
	temp = E1000_READ_REG(hw, MPRC);
	temp = E1000_READ_REG(hw, GPTC);
	temp = E1000_READ_REG(hw, GORCL);
	temp = E1000_READ_REG(hw, GORCH);
	temp = E1000_READ_REG(hw, GOTCL);
	temp = E1000_READ_REG(hw, GOTCH);
	temp = E1000_READ_REG(hw, RNBC);
	temp = E1000_READ_REG(hw, RUC);
	temp = E1000_READ_REG(hw, RFC);
	temp = E1000_READ_REG(hw, ROC);
	temp = E1000_READ_REG(hw, RJC);
	temp = E1000_READ_REG(hw, TORL);
	temp = E1000_READ_REG(hw, TORH);
	temp = E1000_READ_REG(hw, TOTL);
	temp = E1000_READ_REG(hw, TOTH);
	temp = E1000_READ_REG(hw, TPR);
	temp = E1000_READ_REG(hw, TPT);

	if (!IS_ICH8(hw->mac_type)) {
		temp = E1000_READ_REG(hw, PTC64);
		temp = E1000_READ_REG(hw, PTC127);
		temp = E1000_READ_REG(hw, PTC255);
		temp = E1000_READ_REG(hw, PTC511);
		temp = E1000_READ_REG(hw, PTC1023);
		temp = E1000_READ_REG(hw, PTC1522);
	}
	temp = E1000_READ_REG(hw, MPTC);
	temp = E1000_READ_REG(hw, BPTC);

	if (hw->mac_type < em_82543)
		return;

	temp = E1000_READ_REG(hw, ALGNERRC);
	temp = E1000_READ_REG(hw, RXERRC);
	temp = E1000_READ_REG(hw, TNCRS);
	temp = E1000_READ_REG(hw, CEXTERR);
	temp = E1000_READ_REG(hw, TSCTC);
	temp = E1000_READ_REG(hw, TSCTFC);

	if (hw->mac_type <= em_82544
	    || hw->mac_type == em_icp_xxxx)
		return;

	temp = E1000_READ_REG(hw, MGTPRC);
	temp = E1000_READ_REG(hw, MGTPDC);
	temp = E1000_READ_REG(hw, MGTPTC);

	if (hw->mac_type <= em_82547_rev_2)
		return;

	temp = E1000_READ_REG(hw, IAC);
	temp = E1000_READ_REG(hw, ICRXOC);

	if (hw->phy_type == em_phy_82577 ||
	    hw->phy_type == em_phy_82578 ||
	    hw->phy_type == em_phy_82579 ||
	    hw->phy_type == em_phy_i217) {
		uint16_t phy_data;

		em_read_phy_reg(hw, HV_SCC_UPPER, &phy_data);
		em_read_phy_reg(hw, HV_SCC_LOWER, &phy_data);
		em_read_phy_reg(hw, HV_ECOL_UPPER, &phy_data);
		em_read_phy_reg(hw, HV_ECOL_LOWER, &phy_data);
		em_read_phy_reg(hw, HV_MCC_UPPER, &phy_data);
		em_read_phy_reg(hw, HV_MCC_LOWER, &phy_data);
		em_read_phy_reg(hw, HV_LATECOL_UPPER, &phy_data);
		em_read_phy_reg(hw, HV_LATECOL_LOWER, &phy_data);
		em_read_phy_reg(hw, HV_COLC_UPPER, &phy_data);
		em_read_phy_reg(hw, HV_COLC_LOWER, &phy_data);
		em_read_phy_reg(hw, HV_DC_UPPER, &phy_data);
		em_read_phy_reg(hw, HV_DC_LOWER, &phy_data);
		em_read_phy_reg(hw, HV_TNCRS_UPPER, &phy_data);
		em_read_phy_reg(hw, HV_TNCRS_LOWER, &phy_data);
	}

	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    (hw->mac_type != em_pch2lan && hw->mac_type != em_pch_lpt && hw->mac_type != em_pch_spt))
		return;

	temp = E1000_READ_REG(hw, ICRXPTC);
	temp = E1000_READ_REG(hw, ICRXATC);
	temp = E1000_READ_REG(hw, ICTXPTC);
	temp = E1000_READ_REG(hw, ICTXATC);
	temp = E1000_READ_REG(hw, ICTXQEC);
	temp = E1000_READ_REG(hw, ICTXQMTC);
	temp = E1000_READ_REG(hw, ICRXDMTC);
}

#ifndef SMALL_KERNEL
/******************************************************************************
 * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT
 *
 * hw - Struct containing variables accessed by shared code
 * frame_len - The length of the frame in question
 * mac_addr - The Ethernet destination address of the frame in question
 *****************************************************************************/
void
em_tbi_adjust_stats(struct em_hw *hw, struct em_hw_stats *stats,
    uint32_t frame_len, uint8_t *mac_addr)
{
	uint64_t carry_bit;
	/* First adjust the frame length. */
	frame_len--;
	/*
	 * We need to adjust the statistics counters, since the hardware
	 * counters overcount this packet as a CRC error and undercount the
	 * packet as a good packet
	 */
	/* This packet should not be counted as a CRC error.    */
	stats->crcerrs--;
	/* This packet does count as a Good Packet Received.    */
	stats->gprc++;

	/* Adjust the Good Octets received counters             */
	carry_bit = 0x80000000 & stats->gorcl;
	stats->gorcl += frame_len;
	/*
	 * If the high bit of Gorcl (the low 32 bits of the Good Octets
	 * Received Count) was one before the addition, AND it is zero after,
	 * then we lost the carry out, need to add one to Gorch (Good Octets
	 * Received Count High). This could be simplified if all environments
	 * supported 64-bit integers.
	 */
	if (carry_bit && ((stats->gorcl & 0x80000000) == 0))
		stats->gorch++;
	/*
	 * Is this a broadcast or multicast?  Check broadcast first, since
	 * the test for a multicast frame will test positive on a broadcast
	 * frame.
	 */
	if ((mac_addr[0] == (uint8_t) 0xff) && (mac_addr[1] == (uint8_t) 0xff))
		/* Broadcast packet */
		stats->bprc++;
	else if (*mac_addr & 0x01)
		/* Multicast packet */
		stats->mprc++;

	if (frame_len == hw->max_frame_size) {
		/*
		 * In this case, the hardware has overcounted the number of
		 * oversize frames.
		 */
		if (stats->roc > 0)
			stats->roc--;
	}
	/*
	 * Adjust the bin counters when the extra byte put the frame in the
	 * wrong bin. Remember that the frame_len was adjusted above.
	 */
	if (frame_len == 64) {
		stats->prc64++;
		stats->prc127--;
	} else if (frame_len == 127) {
		stats->prc127++;
		stats->prc255--;
	} else if (frame_len == 255) {
		stats->prc255++;
		stats->prc511--;
	} else if (frame_len == 511) {
		stats->prc511++;
		stats->prc1023--;
	} else if (frame_len == 1023) {
		stats->prc1023++;
		stats->prc1522--;
	} else if (frame_len == 1522) {
		stats->prc1522++;
	}
}
#endif	/* !SMALL_KERNEL */

/******************************************************************************
 * Gets the current PCI bus type, speed, and width of the hardware
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
void
em_get_bus_info(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t pci_ex_link_status;
	uint32_t status;
	switch (hw->mac_type) {
	case em_82542_rev2_0:
	case em_82542_rev2_1:
		hw->bus_type = em_bus_type_unknown;
		hw->bus_speed = em_bus_speed_unknown;
		hw->bus_width = em_bus_width_unknown;
		break;
	case em_icp_xxxx:
		hw->bus_type = em_bus_type_cpp;
		hw->bus_speed = em_bus_speed_unknown;
		hw->bus_width = em_bus_width_unknown;
		break;
	case em_82571:
	case em_82572:
	case em_82573:
	case em_82574:
	case em_82575:
	case em_82580:
	case em_80003es2lan:
	case em_i210:
	case em_i350:
		hw->bus_type = em_bus_type_pci_express;
		hw->bus_speed = em_bus_speed_2500;
		ret_val = em_read_pcie_cap_reg(hw, PCI_EX_LINK_STATUS,
		    &pci_ex_link_status);
		if (ret_val)
			hw->bus_width = em_bus_width_unknown;
		else
			hw->bus_width = (pci_ex_link_status & 
			    PCI_EX_LINK_WIDTH_MASK) >> PCI_EX_LINK_WIDTH_SHIFT;
		break;
	case em_ich8lan:
	case em_ich9lan:
	case em_ich10lan:
	case em_pchlan:
	case em_pch2lan:
	case em_pch_lpt:
	case em_pch_spt:
		hw->bus_type = em_bus_type_pci_express;
		hw->bus_speed = em_bus_speed_2500;
		hw->bus_width = em_bus_width_pciex_1;
		break;
	default:
		status = E1000_READ_REG(hw, STATUS);
		hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
		    em_bus_type_pcix : em_bus_type_pci;

		if (hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
			hw->bus_speed = (hw->bus_type == em_bus_type_pci) ?
			    em_bus_speed_66 : em_bus_speed_120;
		} else if (hw->bus_type == em_bus_type_pci) {
			hw->bus_speed = (status & E1000_STATUS_PCI66) ?
			    em_bus_speed_66 : em_bus_speed_33;
		} else {
			switch (status & E1000_STATUS_PCIX_SPEED) {
			case E1000_STATUS_PCIX_SPEED_66:
				hw->bus_speed = em_bus_speed_66;
				break;
			case E1000_STATUS_PCIX_SPEED_100:
				hw->bus_speed = em_bus_speed_100;
				break;
			case E1000_STATUS_PCIX_SPEED_133:
				hw->bus_speed = em_bus_speed_133;
				break;
			default:
				hw->bus_speed = em_bus_speed_reserved;
				break;
			}
		}
		hw->bus_width = (status & E1000_STATUS_BUS64) ?
		    em_bus_width_64 : em_bus_width_32;
		break;
	}
}

/******************************************************************************
 * Writes a value to one of the devices registers using port I/O (as opposed to
 * memory mapped I/O). Only 82544 and newer devices support port I/O.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset to write to
 * value - value to write
 *****************************************************************************/
STATIC void
em_write_reg_io(struct em_hw *hw, uint32_t offset, uint32_t value)
{
	unsigned long io_addr = hw->io_base;
	unsigned long io_data = hw->io_base + 4;
	em_io_write(hw, io_addr, offset);
	em_io_write(hw, io_data, value);
}

/******************************************************************************
 * Estimates the cable length.
 *
 * hw - Struct containing variables accessed by shared code
 * min_length - The estimated minimum length
 * max_length - The estimated maximum length
 *
 * returns: - E1000_ERR_XXX
 *            E1000_SUCCESS
 *
 * This function always returns a ranged length (minimum & maximum).
 * So for M88 phy's, this function interprets the one value returned from the
 * register to the minimum and maximum range.
 * For IGP phy's, the function calculates the range by the AGC registers.
 *****************************************************************************/
STATIC int32_t
em_get_cable_length(struct em_hw *hw, uint16_t *min_length,
    uint16_t *max_length)
{
	int32_t  ret_val;
	uint16_t agc_value = 0;
	uint16_t i, phy_data;
	uint16_t cable_length;
	DEBUGFUNC("em_get_cable_length");

	*min_length = *max_length = 0;

	/* Use old method for Phy older than IGP */
	if (hw->phy_type == em_phy_m88 ||
	    hw->phy_type == em_phy_oem ||
	    hw->phy_type == em_phy_82578) {

		ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
		    &phy_data);
		if (ret_val)
			return ret_val;
		cable_length = (phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
		    M88E1000_PSSR_CABLE_LENGTH_SHIFT;

		/* Convert the enum value to ranged values */
		switch (cable_length) {
		case em_cable_length_50:
			*min_length = 0;
			*max_length = em_igp_cable_length_50;
			break;
		case em_cable_length_50_80:
			*min_length = em_igp_cable_length_50;
			*max_length = em_igp_cable_length_80;
			break;
		case em_cable_length_80_110:
			*min_length = em_igp_cable_length_80;
			*max_length = em_igp_cable_length_110;
			break;
		case em_cable_length_110_140:
			*min_length = em_igp_cable_length_110;
			*max_length = em_igp_cable_length_140;
			break;
		case em_cable_length_140:
			*min_length = em_igp_cable_length_140;
			*max_length = em_igp_cable_length_170;
			break;
		default:
			return -E1000_ERR_PHY;
			break;
		}
	} else if (hw->phy_type == em_phy_rtl8211) {
		/* no cable length info on RTL8211, fake */
		*min_length = 0;
		*max_length = em_igp_cable_length_50;
	} else if (hw->phy_type == em_phy_gg82563) {
		ret_val = em_read_phy_reg(hw, GG82563_PHY_DSP_DISTANCE,
		    &phy_data);
		if (ret_val)
			return ret_val;
		cable_length = phy_data & GG82563_DSPD_CABLE_LENGTH;

		switch (cable_length) {
		case em_gg_cable_length_60:
			*min_length = 0;
			*max_length = em_igp_cable_length_60;
			break;
		case em_gg_cable_length_60_115:
			*min_length = em_igp_cable_length_60;
			*max_length = em_igp_cable_length_115;
			break;
		case em_gg_cable_length_115_150:
			*min_length = em_igp_cable_length_115;
			*max_length = em_igp_cable_length_150;
			break;
		case em_gg_cable_length_150:
			*min_length = em_igp_cable_length_150;
			*max_length = em_igp_cable_length_180;
			break;
		default:
			return -E1000_ERR_PHY;
			break;
		}
	} else if (hw->phy_type == em_phy_igp) {	/* For IGP PHY */
		uint16_t        cur_agc_value;
		uint16_t        min_agc_value = 
		    IGP01E1000_AGC_LENGTH_TABLE_SIZE;
		uint16_t        agc_reg_array[IGP01E1000_PHY_CHANNEL_NUM] =
		    {IGP01E1000_PHY_AGC_A, IGP01E1000_PHY_AGC_B,
		    IGP01E1000_PHY_AGC_C, IGP01E1000_PHY_AGC_D};

		/* Read the AGC registers for all channels */
		for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
			ret_val = em_read_phy_reg(hw, agc_reg_array[i], 
			    &phy_data);
			if (ret_val)
				return ret_val;

			cur_agc_value = phy_data >>
			    IGP01E1000_AGC_LENGTH_SHIFT;

			/* Value bound check. */
			if ((cur_agc_value >= 
			    IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1) ||
			    (cur_agc_value == 0))
				return -E1000_ERR_PHY;

			agc_value += cur_agc_value;

			/* Update minimal AGC value. */
			if (min_agc_value > cur_agc_value)
				min_agc_value = cur_agc_value;
		}

		/* Remove the minimal AGC result for length < 50m */
		if (agc_value < IGP01E1000_PHY_CHANNEL_NUM * 
		    em_igp_cable_length_50) {
			agc_value -= min_agc_value;

			/*
			 * Get the average length of the remaining 3 channels
			 */
			agc_value /= (IGP01E1000_PHY_CHANNEL_NUM - 1);
		} else {
			/* Get the average length of all the 4 channels. */
			agc_value /= IGP01E1000_PHY_CHANNEL_NUM;
		}

		/* Set the range of the calculated length. */
		*min_length = ((em_igp_cable_length_table[agc_value] -
		    IGP01E1000_AGC_RANGE) > 0) ?
		    (em_igp_cable_length_table[agc_value] -
		    IGP01E1000_AGC_RANGE) : 0;
		*max_length = em_igp_cable_length_table[agc_value] +
		    IGP01E1000_AGC_RANGE;
	} else if (hw->phy_type == em_phy_igp_2 ||
	    hw->phy_type == em_phy_igp_3) {
		uint16_t cur_agc_index, max_agc_index = 0;
		uint16_t min_agc_index = IGP02E1000_AGC_LENGTH_TABLE_SIZE - 1;
		uint16_t agc_reg_array[IGP02E1000_PHY_CHANNEL_NUM] =
		    {IGP02E1000_PHY_AGC_A, IGP02E1000_PHY_AGC_B,
		    IGP02E1000_PHY_AGC_C, IGP02E1000_PHY_AGC_D};
		/* Read the AGC registers for all channels */
		for (i = 0; i < IGP02E1000_PHY_CHANNEL_NUM; i++) {
			ret_val = em_read_phy_reg(hw, agc_reg_array[i],
			    &phy_data);
			if (ret_val)
				return ret_val;
			/*
			 * Getting bits 15:9, which represent the combination
			 * of course and fine gain values.  The result is a
			 * number that can be put into the lookup table to
			 * obtain the approximate cable length.
			 */
			cur_agc_index = (phy_data >>
			    IGP02E1000_AGC_LENGTH_SHIFT) &
			    IGP02E1000_AGC_LENGTH_MASK;

			/* Array index bound check. */
			if ((cur_agc_index >= IGP02E1000_AGC_LENGTH_TABLE_SIZE)
			    || (cur_agc_index == 0))
				return -E1000_ERR_PHY;

			/* Remove min & max AGC values from calculation. */
			if (em_igp_2_cable_length_table[min_agc_index] >
			    em_igp_2_cable_length_table[cur_agc_index])
				min_agc_index = cur_agc_index;
			if (em_igp_2_cable_length_table[max_agc_index] <
			    em_igp_2_cable_length_table[cur_agc_index])
				max_agc_index = cur_agc_index;

			agc_value += em_igp_2_cable_length_table
			    [cur_agc_index];
		}

		agc_value -= (em_igp_2_cable_length_table[min_agc_index] +
		    em_igp_2_cable_length_table[max_agc_index]);
		agc_value /= (IGP02E1000_PHY_CHANNEL_NUM - 2);
		/*
		 * Calculate cable length with the error range of +/- 10
		 * meters.
		 */
		*min_length = ((agc_value - IGP02E1000_AGC_RANGE) > 0) ?
		    (agc_value - IGP02E1000_AGC_RANGE) : 0;
		*max_length = agc_value + IGP02E1000_AGC_RANGE;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 * Check if Downshift occured
 *
 * hw - Struct containing variables accessed by shared code
 * downshift - output parameter : 0 - No Downshift ocured.
 *                                1 - Downshift ocured.
 *
 * returns: - E1000_ERR_XXX
 *            E1000_SUCCESS
 *
 * For phy's older then IGP, this function reads the Downshift bit in the Phy
 * Specific Status register.  For IGP phy's, it reads the Downgrade bit in the
 * Link Health register.  In IGP this bit is latched high, so the driver must
 * read it immediately after link is established.
 *****************************************************************************/
STATIC int32_t
em_check_downshift(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_check_downshift");

	if (hw->phy_type == em_phy_igp ||
	    hw->phy_type == em_phy_igp_3 ||
	    hw->phy_type == em_phy_igp_2) {
		ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH,
		    &phy_data);
		if (ret_val)
			return ret_val;

		hw->speed_downgraded = (phy_data &
		    IGP01E1000_PLHR_SS_DOWNGRADE) ? 1 : 0;
	} else if ((hw->phy_type == em_phy_m88) ||
	    (hw->phy_type == em_phy_gg82563) ||
	    (hw->phy_type == em_phy_oem) ||
	    (hw->phy_type == em_phy_82578)) {
		ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
		    &phy_data);
		if (ret_val)
			return ret_val;

		hw->speed_downgraded = (phy_data & M88E1000_PSSR_DOWNSHIFT) >>
		    M88E1000_PSSR_DOWNSHIFT_SHIFT;
	} else if (hw->phy_type == em_phy_ife) {
		/* em_phy_ife supports 10/100 speed only */
		hw->speed_downgraded = FALSE;
	}
	return E1000_SUCCESS;
}

/*****************************************************************************
 *
 * 82541_rev_2 & 82547_rev_2 have the capability to configure the DSP when a
 * gigabit link is achieved to improve link quality.
 *
 * hw: Struct containing variables accessed by shared code
 *
 * returns: - E1000_ERR_PHY if fail to read/write the PHY
 *            E1000_SUCCESS at any other case.
 *
 ****************************************************************************/
STATIC int32_t
em_config_dsp_after_link_change(struct em_hw *hw, boolean_t link_up)
{
	int32_t  ret_val;
	uint16_t phy_data, phy_saved_data, speed, duplex, i;
	uint16_t dsp_reg_array[IGP01E1000_PHY_CHANNEL_NUM] =
	    {IGP01E1000_PHY_AGC_PARAM_A, IGP01E1000_PHY_AGC_PARAM_B,
	    IGP01E1000_PHY_AGC_PARAM_C, IGP01E1000_PHY_AGC_PARAM_D};
	uint16_t min_length, max_length;
	DEBUGFUNC("em_config_dsp_after_link_change");

	if (hw->phy_type != em_phy_igp)
		return E1000_SUCCESS;

	if (link_up) {
		ret_val = em_get_speed_and_duplex(hw, &speed, &duplex);
		if (ret_val) {
			DEBUGOUT("Error getting link speed and duplex\n");
			return ret_val;
		}
		if (speed == SPEED_1000) {

			ret_val = em_get_cable_length(hw, &min_length, &max_length);
			if (ret_val)
				return ret_val;

			if ((hw->dsp_config_state == em_dsp_config_enabled) &&
			    min_length >= em_igp_cable_length_50) {

				for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM;
				    i++) {
					ret_val = em_read_phy_reg(hw,
					    dsp_reg_array[i], &phy_data);
					if (ret_val)
						return ret_val;

					phy_data &=
					    ~IGP01E1000_PHY_EDAC_MU_INDEX;

					ret_val = em_write_phy_reg(hw,
					    dsp_reg_array[i], phy_data);
					if (ret_val)
						return ret_val;
				}
				hw->dsp_config_state = em_dsp_config_activated;
			}
			if ((hw->ffe_config_state == em_ffe_config_enabled) &&
			    (min_length < em_igp_cable_length_50)) {

				uint16_t ffe_idle_err_timeout =
				    FFE_IDLE_ERR_COUNT_TIMEOUT_20;
				uint32_t idle_errs = 0;
				/* clear previous idle error counts */
				ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS,
				    &phy_data);
				if (ret_val)
					return ret_val;

				for (i = 0; i < ffe_idle_err_timeout; i++) {
					usec_delay(1000);
					ret_val = em_read_phy_reg(hw,
					    PHY_1000T_STATUS, &phy_data);
					if (ret_val)
						return ret_val;

					idle_errs += (phy_data &
					    SR_1000T_IDLE_ERROR_CNT);
					if (idle_errs >
					    SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {
						hw->ffe_config_state =
						    em_ffe_config_active;

						ret_val = em_write_phy_reg(hw,
						    IGP01E1000_PHY_DSP_FFE,
						    IGP01E1000_PHY_DSP_FFE_CM_CP);
						if (ret_val)
							return ret_val;
						break;
					}
					if (idle_errs)
						ffe_idle_err_timeout =
						    FFE_IDLE_ERR_COUNT_TIMEOUT_100;
				}
			}
		}
	} else {
		if (hw->dsp_config_state == em_dsp_config_activated) {
			/*
			 * Save off the current value of register 0x2F5B to
			 * be restored at the end of the routines.
			 */
			ret_val = em_read_phy_reg(hw, 0x2F5B, &phy_saved_data);

			if (ret_val)
				return ret_val;

			/* Disable the PHY transmitter */
			ret_val = em_write_phy_reg(hw, 0x2F5B, 0x0003);

			if (ret_val)
				return ret_val;

			msec_delay_irq(20);

			ret_val = em_write_phy_reg(hw, 0x0000,
			    IGP01E1000_IEEE_FORCE_GIGA);
			if (ret_val)
				return ret_val;
			for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
				ret_val = em_read_phy_reg(hw, dsp_reg_array[i],
				    &phy_data);
				if (ret_val)
					return ret_val;

				phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
				phy_data |=
				    IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS;

				ret_val = em_write_phy_reg(hw,
				    dsp_reg_array[i], phy_data);
				if (ret_val)
					return ret_val;
			}

			ret_val = em_write_phy_reg(hw, 0x0000,
			    IGP01E1000_IEEE_RESTART_AUTONEG);
			if (ret_val)
				return ret_val;

			msec_delay_irq(20);

			/* Now enable the transmitter */
			ret_val = em_write_phy_reg(hw, 0x2F5B, phy_saved_data);

			if (ret_val)
				return ret_val;

			hw->dsp_config_state = em_dsp_config_enabled;
		}
		if (hw->ffe_config_state == em_ffe_config_active) {
			/*
			 * Save off the current value of register 0x2F5B to
			 * be restored at the end of the routines.
			 */
			ret_val = em_read_phy_reg(hw, 0x2F5B, &phy_saved_data);

			if (ret_val)
				return ret_val;

			/* Disable the PHY transmitter */
			ret_val = em_write_phy_reg(hw, 0x2F5B, 0x0003);

			if (ret_val)
				return ret_val;

			msec_delay_irq(20);

			ret_val = em_write_phy_reg(hw, 0x0000,
			    IGP01E1000_IEEE_FORCE_GIGA);
			if (ret_val)
				return ret_val;
			ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_DSP_FFE,
			    IGP01E1000_PHY_DSP_FFE_DEFAULT);
			if (ret_val)
				return ret_val;

			ret_val = em_write_phy_reg(hw, 0x0000,
			    IGP01E1000_IEEE_RESTART_AUTONEG);
			if (ret_val)
				return ret_val;

			msec_delay_irq(20);

			/* Now enable the transmitter */
			ret_val = em_write_phy_reg(hw, 0x2F5B, phy_saved_data);

			if (ret_val)
				return ret_val;

			hw->ffe_config_state = em_ffe_config_enabled;
		}
	}
	return E1000_SUCCESS;
}

/*****************************************************************************
 * Set PHY to class A mode
 * Assumes the following operations will follow to enable the new class mode.
 *  1. Do a PHY soft reset
 *  2. Restart auto-negotiation or force link.
 *
 * hw - Struct containing variables accessed by shared code
 ****************************************************************************/
static int32_t
em_set_phy_mode(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t eeprom_data;
	DEBUGFUNC("em_set_phy_mode");

	if ((hw->mac_type == em_82545_rev_3) &&
	    (hw->media_type == em_media_type_copper)) {
		ret_val = em_read_eeprom(hw, EEPROM_PHY_CLASS_WORD, 1,
		    &eeprom_data);
		if (ret_val) {
			return ret_val;
		}
		if ((eeprom_data != EEPROM_RESERVED_WORD) &&
		    (eeprom_data & EEPROM_PHY_CLASS_A)) {
			ret_val = em_write_phy_reg(hw,
			    M88E1000_PHY_PAGE_SELECT, 0x000B);
			if (ret_val)
				return ret_val;
			ret_val = em_write_phy_reg(hw,
			    M88E1000_PHY_GEN_CONTROL, 0x8104);
			if (ret_val)
				return ret_val;

			hw->phy_reset_disable = FALSE;
		}
	}
	return E1000_SUCCESS;
}

/*****************************************************************************
 *
 * This function sets the lplu state according to the active flag.  When
 * activating lplu this function also disables smart speed and vise versa.
 * lplu will not be activated unless the device autonegotiation advertisement
 * meets standards of either 10 or 10/100 or 10/100/1000 at all duplexes.
 * hw: Struct containing variables accessed by shared code
 * active - true to enable lplu false to disable lplu.
 *
 * returns: - E1000_ERR_PHY if fail to read/write the PHY
 *            E1000_SUCCESS at any other case.
 *
 ****************************************************************************/
STATIC int32_t
em_set_d3_lplu_state(struct em_hw *hw, boolean_t active)
{
	uint32_t phy_ctrl = 0;
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_set_d3_lplu_state");

	if (hw->phy_type != em_phy_igp && hw->phy_type != em_phy_igp_2
	    && hw->phy_type != em_phy_igp_3)
		return E1000_SUCCESS;
	/*
	 * During driver activity LPLU should not be used or it will attain
	 * link from the lowest speeds starting from 10Mbps. The capability
	 * is used for Dx transitions and states
	 */
	if (hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2) {
		ret_val = em_read_phy_reg(hw, IGP01E1000_GMII_FIFO, &phy_data);
		if (ret_val)
			return ret_val;
	} else if (IS_ICH8(hw->mac_type)) {
		/*
		 * MAC writes into PHY register based on the state transition
		 * and start auto-negotiation. SW driver can overwrite the
		 * settings in CSR PHY power control E1000_PHY_CTRL register.
		 */
		phy_ctrl = E1000_READ_REG(hw, PHY_CTRL);
	} else {
		ret_val = em_read_phy_reg(hw, IGP02E1000_PHY_POWER_MGMT,
		    &phy_data);
		if (ret_val)
			return ret_val;
	}

	if (!active) {
		if (hw->mac_type == em_82541_rev_2 ||
		    hw->mac_type == em_82547_rev_2) {
			phy_data &= ~IGP01E1000_GMII_FLEX_SPD;
			ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
			    phy_data);
			if (ret_val)
				return ret_val;
		} else {
			if (IS_ICH8(hw->mac_type)) {
				phy_ctrl &= ~E1000_PHY_CTRL_NOND0A_LPLU;
				E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
			} else {
				phy_data &= ~IGP02E1000_PM_D3_LPLU;
				ret_val = em_write_phy_reg(hw,
				    IGP02E1000_PHY_POWER_MGMT, phy_data);
				if (ret_val)
					return ret_val;
			}
		}
		/*
		 * LPLU and SmartSpeed are mutually exclusive.  LPLU is used
		 * during Dx states where the power conservation is most
		 * important.  During driver activity we should enable
		 * SmartSpeed, so performance is maintained.
		 */
		if (hw->smart_speed == em_smart_speed_on) {
			ret_val = em_read_phy_reg(hw,
			    IGP01E1000_PHY_PORT_CONFIG, &phy_data);
			if (ret_val)
				return ret_val;

			phy_data |= IGP01E1000_PSCFR_SMART_SPEED;
			ret_val = em_write_phy_reg(hw,
			    IGP01E1000_PHY_PORT_CONFIG, phy_data);
			if (ret_val)
				return ret_val;
		} else if (hw->smart_speed == em_smart_speed_off) {
			ret_val = em_read_phy_reg(hw,
			    IGP01E1000_PHY_PORT_CONFIG, &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
			ret_val = em_write_phy_reg(hw,
			    IGP01E1000_PHY_PORT_CONFIG, phy_data);
			if (ret_val)
				return ret_val;
		}
	} else if ((hw->autoneg_advertised == AUTONEG_ADVERTISE_SPEED_DEFAULT)
	    || (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_ALL) ||
	    (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_100_ALL)) {

		if (hw->mac_type == em_82541_rev_2 ||
		    hw->mac_type == em_82547_rev_2) {
			phy_data |= IGP01E1000_GMII_FLEX_SPD;
			ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
			    phy_data);
			if (ret_val)
				return ret_val;
		} else {
			if (IS_ICH8(hw->mac_type)) {
				phy_ctrl |= E1000_PHY_CTRL_NOND0A_LPLU;
				E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
			} else {
				phy_data |= IGP02E1000_PM_D3_LPLU;
				ret_val = em_write_phy_reg(hw,
				    IGP02E1000_PHY_POWER_MGMT, phy_data);
				if (ret_val)
					return ret_val;
			}
		}

		/* When LPLU is enabled we should disable SmartSpeed */
		ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
		    &phy_data);
		if (ret_val)
			return ret_val;

		phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
		ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
		    phy_data);
		if (ret_val)
			return ret_val;

	}
	return E1000_SUCCESS;
}

/*****************************************************************************
 *
 * This function sets the lplu d0 state according to the active flag.  When
 * activating lplu this function also disables smart speed and vise versa.
 * lplu will not be activated unless the device autonegotiation advertisement
 * meets standards of either 10 or 10/100 or 10/100/1000 at all duplexes.
 * hw: Struct containing variables accessed by shared code
 * active - true to enable lplu false to disable lplu.
 *
 * returns: - E1000_ERR_PHY if fail to read/write the PHY
 *            E1000_SUCCESS at any other case.
 *
 ****************************************************************************/
STATIC int32_t
em_set_d0_lplu_state(struct em_hw *hw, boolean_t active)
{
	uint32_t phy_ctrl = 0;
	int32_t  ret_val;
	uint16_t phy_data;
	DEBUGFUNC("em_set_d0_lplu_state");

	if (hw->mac_type <= em_82547_rev_2)
		return E1000_SUCCESS;

	if (IS_ICH8(hw->mac_type)) {
		phy_ctrl = E1000_READ_REG(hw, PHY_CTRL);
	} else {
		ret_val = em_read_phy_reg(hw, IGP02E1000_PHY_POWER_MGMT,
		    &phy_data);
		if (ret_val)
			return ret_val;
	}

	if (!active) {
		if (IS_ICH8(hw->mac_type)) {
			phy_ctrl &= ~E1000_PHY_CTRL_D0A_LPLU;
			E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
		} else {
			phy_data &= ~IGP02E1000_PM_D0_LPLU;
			ret_val = em_write_phy_reg(hw,
			    IGP02E1000_PHY_POWER_MGMT, phy_data);
			if (ret_val)
				return ret_val;
		}
		/*
		 * LPLU and SmartSpeed are mutually exclusive.  LPLU is used
		 * during Dx states where the power conservation is most
		 * important.  During driver activity we should enable
		 * SmartSpeed, so performance is maintained.
		 */
		if (hw->smart_speed == em_smart_speed_on) {
			ret_val = em_read_phy_reg(hw,
			    IGP01E1000_PHY_PORT_CONFIG, &phy_data);
			if (ret_val)
				return ret_val;

			phy_data |= IGP01E1000_PSCFR_SMART_SPEED;
			ret_val = em_write_phy_reg(hw,
			    IGP01E1000_PHY_PORT_CONFIG, phy_data);
			if (ret_val)
				return ret_val;
		} else if (hw->smart_speed == em_smart_speed_off) {
			ret_val = em_read_phy_reg(hw,
			    IGP01E1000_PHY_PORT_CONFIG, &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
			ret_val = em_write_phy_reg(hw,
			    IGP01E1000_PHY_PORT_CONFIG, phy_data);
			if (ret_val)
				return ret_val;
		}
	} else {
		if (IS_ICH8(hw->mac_type)) {
			phy_ctrl |= E1000_PHY_CTRL_D0A_LPLU;
			E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
		} else {
			phy_data |= IGP02E1000_PM_D0_LPLU;
			ret_val = em_write_phy_reg(hw,
			    IGP02E1000_PHY_POWER_MGMT, phy_data);
			if (ret_val)
				return ret_val;
		}

		/* When LPLU is enabled we should disable SmartSpeed */
		ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
		    &phy_data);
		if (ret_val)
			return ret_val;

		phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
		ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
		    phy_data);
		if (ret_val)
			return ret_val;

	}
	return E1000_SUCCESS;
}

/***************************************************************************
 *  Set Low Power Link Up state
 *
 *  Sets the LPLU state according to the active flag.  For PCH, if OEM write
 *  bit are disabled in the NVM, writing the LPLU bits in the MAC will not set
 *  the phy speed. This function will manually set the LPLU bit and restart
 *  auto-neg as hw would do. D3 and D0 LPLU will call the same function
 *  since it configures the same bit.
 ***************************************************************************/
int32_t
em_set_lplu_state_pchlan(struct em_hw *hw, boolean_t active)
{
	int32_t ret_val = E1000_SUCCESS;
	uint16_t oem_reg;

	DEBUGFUNC("e1000_set_lplu_state_pchlan");

	ret_val = em_read_phy_reg(hw, HV_OEM_BITS, &oem_reg);
	if (ret_val)
		goto out;

	if (active)
		oem_reg |= HV_OEM_BITS_LPLU;
	else
		oem_reg &= ~HV_OEM_BITS_LPLU;

	oem_reg |= HV_OEM_BITS_RESTART_AN;
	ret_val = em_write_phy_reg(hw, HV_OEM_BITS, oem_reg);

out:
	return ret_val;
}

/******************************************************************************
 * Change VCO speed register to improve Bit Error Rate performance of SERDES.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_set_vco_speed(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t default_page = 0;
	uint16_t phy_data;
	DEBUGFUNC("em_set_vco_speed");

	switch (hw->mac_type) {
	case em_82545_rev_3:
	case em_82546_rev_3:
		break;
	default:
		return E1000_SUCCESS;
	}

	/* Set PHY register 30, page 5, bit 8 to 0 */

	ret_val = em_read_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, &default_page);
	if (ret_val)
		return ret_val;

	ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0005);
	if (ret_val)
		return ret_val;

	ret_val = em_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_data &= ~M88E1000_PHY_VCO_REG_BIT8;
	ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
	if (ret_val)
		return ret_val;

	/* Set PHY register 30, page 4, bit 11 to 1 */

	ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0004);
	if (ret_val)
		return ret_val;

	ret_val = em_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_data |= M88E1000_PHY_VCO_REG_BIT11;
	ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
	if (ret_val)
		return ret_val;

	ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, default_page);
	if (ret_val)
		return ret_val;

	return E1000_SUCCESS;
}

/*****************************************************************************
 * This function reads the cookie from ARC ram.
 *
 * returns: - E1000_SUCCESS .
 ****************************************************************************/
STATIC int32_t
em_host_if_read_cookie(struct em_hw *hw, uint8_t *buffer)
{
	uint8_t  i;
	uint32_t offset = E1000_MNG_DHCP_COOKIE_OFFSET;
	uint8_t  length = E1000_MNG_DHCP_COOKIE_LENGTH;
	length = (length >> 2);
	offset = (offset >> 2);

	for (i = 0; i < length; i++) {
		*((uint32_t *) buffer + i) =
		    E1000_READ_REG_ARRAY_DWORD(hw, HOST_IF, offset + i);
	}
	return E1000_SUCCESS;
}

/*****************************************************************************
 * This function checks whether the HOST IF is enabled for command operaton
 * and also checks whether the previous command is completed.
 * It busy waits in case of previous command is not completed.
 *
 * returns: - E1000_ERR_HOST_INTERFACE_COMMAND in case if is not ready or
 *            timeout
 *          - E1000_SUCCESS for success.
 ****************************************************************************/
STATIC int32_t
em_mng_enable_host_if(struct em_hw *hw)
{
	uint32_t hicr;
	uint8_t  i;
	/* Check that the host interface is enabled. */
	hicr = E1000_READ_REG(hw, HICR);
	if ((hicr & E1000_HICR_EN) == 0) {
		DEBUGOUT("E1000_HOST_EN bit disabled.\n");
		return -E1000_ERR_HOST_INTERFACE_COMMAND;
	}
	/* check the previous command is completed */
	for (i = 0; i < E1000_MNG_DHCP_COMMAND_TIMEOUT; i++) {
		hicr = E1000_READ_REG(hw, HICR);
		if (!(hicr & E1000_HICR_C))
			break;
		msec_delay_irq(1);
	}

	if (i == E1000_MNG_DHCP_COMMAND_TIMEOUT) {
		DEBUGOUT("Previous command timeout failed .\n");
		return -E1000_ERR_HOST_INTERFACE_COMMAND;
	}
	return E1000_SUCCESS;
}

/*****************************************************************************
 * This function checks the mode of the firmware.
 *
 * returns  - TRUE when the mode is IAMT or FALSE.
 ****************************************************************************/
boolean_t
em_check_mng_mode(struct em_hw *hw)
{
	uint32_t fwsm;
	fwsm = E1000_READ_REG(hw, FWSM);

	if (IS_ICH8(hw->mac_type)) {
		if ((fwsm & E1000_FWSM_MODE_MASK) ==
		    (E1000_MNG_ICH_IAMT_MODE << E1000_FWSM_MODE_SHIFT))
			return TRUE;
	} else if ((fwsm & E1000_FWSM_MODE_MASK) ==
	    (E1000_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT))
		return TRUE;

	return FALSE;
}

/*****************************************************************************
 * This function calculates the checksum.
 *
 * returns  - checksum of buffer contents.
 ****************************************************************************/
STATIC uint8_t
em_calculate_mng_checksum(char *buffer, uint32_t length)
{
	uint8_t  sum = 0;
	uint32_t i;
	if (!buffer)
		return 0;

	for (i = 0; i < length; i++)
		sum += buffer[i];

	return (uint8_t) (0 - sum);
}

/*****************************************************************************
 * This function checks whether tx pkt filtering needs to be enabled or not.
 *
 * returns  - TRUE for packet filtering or FALSE.
 ****************************************************************************/
boolean_t
em_enable_tx_pkt_filtering(struct em_hw *hw)
{
	/* called in init as well as watchdog timer functions */
	int32_t   ret_val, checksum;
	boolean_t tx_filter = FALSE;
	struct em_host_mng_dhcp_cookie *hdr = &(hw->mng_cookie);
	uint8_t   *buffer = (uint8_t *) & (hw->mng_cookie);
	if (em_check_mng_mode(hw)) {
		ret_val = em_mng_enable_host_if(hw);
		if (ret_val == E1000_SUCCESS) {
			ret_val = em_host_if_read_cookie(hw, buffer);
			if (ret_val == E1000_SUCCESS) {
				checksum = hdr->checksum;
				hdr->checksum = 0;
				if ((hdr->signature == E1000_IAMT_SIGNATURE) &&
				    checksum == em_calculate_mng_checksum(
				    (char *) buffer, 
				    E1000_MNG_DHCP_COOKIE_LENGTH)) {
					if (hdr->status &
					    E1000_MNG_DHCP_COOKIE_STATUS_PARSING_SUPPORT)
						tx_filter = TRUE;
				} else
					tx_filter = TRUE;
			} else
				tx_filter = TRUE;
		}
	}
	hw->tx_pkt_filtering = tx_filter;
	return tx_filter;
}

static int32_t
em_polarity_reversal_workaround(struct em_hw *hw)
{
	int32_t  ret_val;
	uint16_t mii_status_reg;
	uint16_t i;
	/* Polarity reversal workaround for forced 10F/10H links. */

	/* Disable the transmitter on the PHY */
	ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);
	if (ret_val)
		return ret_val;
	ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFFF);
	if (ret_val)
		return ret_val;

	ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);
	if (ret_val)
		return ret_val;

	/* This loop will early-out if the NO link condition has been met. */
	for (i = PHY_FORCE_TIME; i > 0; i--) {
		/*
		 * Read the MII Status Register and wait for Link Status bit
		 * to be clear.
		 */

		ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
		if (ret_val)
			return ret_val;

		ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
		if (ret_val)
			return ret_val;

		if ((mii_status_reg & ~MII_SR_LINK_STATUS) == 0)
			break;
		msec_delay_irq(100);
	}

	/* Recommended delay time after link has been lost */
	msec_delay_irq(1000);

	/* Now we will re-enable the transmitter on the PHY */

	ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);
	if (ret_val)
		return ret_val;
	msec_delay_irq(50);
	ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFF0);
	if (ret_val)
		return ret_val;
	msec_delay_irq(50);
	ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFF00);
	if (ret_val)
		return ret_val;
	msec_delay_irq(50);
	ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0x0000);
	if (ret_val)
		return ret_val;

	ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);
	if (ret_val)
		return ret_val;

	/* This loop will early-out if the link condition has been met. */
	for (i = PHY_FORCE_TIME; i > 0; i--) {
		/*
		 * Read the MII Status Register and wait for Link Status bit
		 * to be set.
		 */

		ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
		if (ret_val)
			return ret_val;

		ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
		if (ret_val)
			return ret_val;

		if (mii_status_reg & MII_SR_LINK_STATUS)
			break;
		msec_delay_irq(100);
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 *
 * Disables PCI-Express master access.
 *
 * hw: Struct containing variables accessed by shared code
 *
 * returns: - none.
 *
 *****************************************************************************/
STATIC void
em_set_pci_express_master_disable(struct em_hw *hw)
{
	uint32_t ctrl;
	DEBUGFUNC("em_set_pci_express_master_disable");

	if (hw->bus_type != em_bus_type_pci_express)
		return;

	ctrl = E1000_READ_REG(hw, CTRL);
	ctrl |= E1000_CTRL_GIO_MASTER_DISABLE;
	E1000_WRITE_REG(hw, CTRL, ctrl);
}

/******************************************************************************
 *
 * Disables PCI-Express master access and verifies there are no pending 
 * requests
 *
 * hw: Struct containing variables accessed by shared code
 *
 * returns: - E1000_ERR_MASTER_REQUESTS_PENDING if master disable bit hasn't
 *            caused the master requests to be disabled.
 *            E1000_SUCCESS master requests disabled.
 *
 ******************************************************************************/
int32_t
em_disable_pciex_master(struct em_hw *hw)
{
	int32_t timeout = MASTER_DISABLE_TIMEOUT;	/* 80ms */
	DEBUGFUNC("em_disable_pciex_master");

	if (hw->bus_type != em_bus_type_pci_express)
		return E1000_SUCCESS;

	em_set_pci_express_master_disable(hw);

	while (timeout) {
		if (!(E1000_READ_REG(hw, STATUS) & 
		    E1000_STATUS_GIO_MASTER_ENABLE))
			break;
		else
			usec_delay(100);
		timeout--;
	}

	if (!timeout) {
		DEBUGOUT("Master requests are pending.\n");
		return -E1000_ERR_MASTER_REQUESTS_PENDING;
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 *
 * Check for EEPROM Auto Read bit done.
 *
 * hw: Struct containing variables accessed by shared code
 *
 * returns: - E1000_ERR_RESET if fail to reset MAC
 *            E1000_SUCCESS at any other case.
 *
 ******************************************************************************/
STATIC int32_t
em_get_auto_rd_done(struct em_hw *hw)
{
	int32_t timeout = AUTO_READ_DONE_TIMEOUT;
	DEBUGFUNC("em_get_auto_rd_done");

	switch (hw->mac_type) {
	default:
		msec_delay(5);
		break;
	case em_82571:
	case em_82572:
	case em_82573:
	case em_82574:
	case em_82575:
	case em_82580:
	case em_80003es2lan:
	case em_i210:
	case em_i350:
	case em_ich8lan:
	case em_ich9lan:
	case em_ich10lan:
	case em_pchlan:
	case em_pch2lan:
	case em_pch_lpt:
	case em_pch_spt:
		while (timeout) {
			if (E1000_READ_REG(hw, EECD) & E1000_EECD_AUTO_RD)
				break;
			else
				msec_delay(1);
			timeout--;
		}

		if (!timeout) {
			DEBUGOUT("Auto read by HW from EEPROM has not"
			    " completed.\n");
			return -E1000_ERR_RESET;
		}
		break;
	}
	/*
	 * PHY configuration from NVM just starts after EECD_AUTO_RD sets to
	 * high. Need to wait for PHY configuration completion before
	 * accessing NVM and PHY.
	 */
	if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574))
		msec_delay(25);

	return E1000_SUCCESS;
}

/***************************************************************************
 * Checks if the PHY configuration is done
 *
 * hw: Struct containing variables accessed by shared code
 *
 * returns: - E1000_ERR_RESET if fail to reset MAC
 *            E1000_SUCCESS at any other case.
 *
 ***************************************************************************/
STATIC int32_t
em_get_phy_cfg_done(struct em_hw *hw)
{
	int32_t  timeout = PHY_CFG_TIMEOUT;
	uint32_t cfg_mask = E1000_NVM_CFG_DONE_PORT_0;
	DEBUGFUNC("em_get_phy_cfg_done");

	switch (hw->mac_type) {
	default:
		msec_delay_irq(10);
		break;
	case em_80003es2lan:
	case em_82575:
	case em_82580:
	case em_i350:
		switch (hw->bus_func) {
		case 1:
			cfg_mask = E1000_NVM_CFG_DONE_PORT_1;
			break;
		case 2:
			cfg_mask = E1000_NVM_CFG_DONE_PORT_2;
			break;
		case 3:
			cfg_mask = E1000_NVM_CFG_DONE_PORT_3;
			break;
		}
		/* FALLTHROUGH */
	case em_82571:
	case em_82572:
		while (timeout) {
			if (E1000_READ_REG(hw, EEMNGCTL) & cfg_mask)
				break;
			else
				msec_delay(1);
			timeout--;
		}
		if (!timeout) {
			DEBUGOUT("MNG configuration cycle has not completed."
			    "\n");
		}
		break;
	}

	return E1000_SUCCESS;
}

/***************************************************************************
 *
 * Using the combination of SMBI and SWESMBI semaphore bits when resetting
 * adapter or Eeprom access.
 *
 * hw: Struct containing variables accessed by shared code
 *
 * returns: - E1000_ERR_EEPROM if fail to access EEPROM.
 *            E1000_SUCCESS at any other case.
 *
 ***************************************************************************/
STATIC int32_t
em_get_hw_eeprom_semaphore(struct em_hw *hw)
{
	int32_t  timeout;
	uint32_t swsm;
	DEBUGFUNC("em_get_hw_eeprom_semaphore");

	if (!hw->eeprom_semaphore_present)
		return E1000_SUCCESS;

	if (hw->mac_type == em_80003es2lan) {
		/* Get the SW semaphore. */
		if (em_get_software_semaphore(hw) != E1000_SUCCESS)
			return -E1000_ERR_EEPROM;
	}
	/* Get the FW semaphore. */
	timeout = hw->eeprom.word_size + 1;
	while (timeout) {
		swsm = E1000_READ_REG(hw, SWSM);
		swsm |= E1000_SWSM_SWESMBI;
		E1000_WRITE_REG(hw, SWSM, swsm);
		/* if we managed to set the bit we got the semaphore. */
		swsm = E1000_READ_REG(hw, SWSM);
		if (swsm & E1000_SWSM_SWESMBI)
			break;

		usec_delay(50);
		timeout--;
	}

	if (!timeout) {
		/* Release semaphores */
		em_put_hw_eeprom_semaphore(hw);
		DEBUGOUT("Driver can't access the Eeprom - SWESMBI bit is set."
		    "\n");
		return -E1000_ERR_EEPROM;
	}
	return E1000_SUCCESS;
}

/***************************************************************************
 * This function clears HW semaphore bits.
 *
 * hw: Struct containing variables accessed by shared code
 *
 * returns: - None.
 *
 ***************************************************************************/
STATIC void
em_put_hw_eeprom_semaphore(struct em_hw *hw)
{
	uint32_t swsm;
	DEBUGFUNC("em_put_hw_eeprom_semaphore");

	if (!hw->eeprom_semaphore_present)
		return;

	swsm = E1000_READ_REG(hw, SWSM);
	if (hw->mac_type == em_80003es2lan) {
		/* Release both semaphores. */
		swsm &= ~(E1000_SWSM_SMBI | E1000_SWSM_SWESMBI);
	} else
		swsm &= ~(E1000_SWSM_SWESMBI);
	E1000_WRITE_REG(hw, SWSM, swsm);
}

/***************************************************************************
 *
 * Obtaining software semaphore bit (SMBI) before resetting PHY.
 *
 * hw: Struct containing variables accessed by shared code
 *
 * returns: - E1000_ERR_RESET if fail to obtain semaphore.
 *            E1000_SUCCESS at any other case.
 *
 ***************************************************************************/
STATIC int32_t
em_get_software_semaphore(struct em_hw *hw)
{
	int32_t  timeout = hw->eeprom.word_size + 1;
	uint32_t swsm;
	DEBUGFUNC("em_get_software_semaphore");

	if (hw->mac_type != em_80003es2lan)
		return E1000_SUCCESS;

	while (timeout) {
		swsm = E1000_READ_REG(hw, SWSM);
		/*
		 * If SMBI bit cleared, it is now set and we hold the
		 * semaphore
		 */
		if (!(swsm & E1000_SWSM_SMBI))
			break;
		msec_delay_irq(1);
		timeout--;
	}

	if (!timeout) {
		DEBUGOUT("Driver can't access device - SMBI bit is set.\n");
		return -E1000_ERR_RESET;
	}
	return E1000_SUCCESS;
}

/***************************************************************************
 *
 * Release semaphore bit (SMBI).
 *
 * hw: Struct containing variables accessed by shared code
 *
 ***************************************************************************/
STATIC void
em_release_software_semaphore(struct em_hw *hw)
{
	uint32_t swsm;
	DEBUGFUNC("em_release_software_semaphore");

	if (hw->mac_type != em_80003es2lan)
		return;

	swsm = E1000_READ_REG(hw, SWSM);
	/* Release the SW semaphores. */
	swsm &= ~E1000_SWSM_SMBI;
	E1000_WRITE_REG(hw, SWSM, swsm);
}

/******************************************************************************
 * Checks if PHY reset is blocked due to SOL/IDER session, for example.
 * Returning E1000_BLK_PHY_RESET isn't necessarily an error.  But it's up to
 * the caller to figure out how to deal with it.
 *
 * hw - Struct containing variables accessed by shared code
 *
 * returns: - E1000_BLK_PHY_RESET
 *            E1000_SUCCESS
 *
 *****************************************************************************/
int32_t
em_check_phy_reset_block(struct em_hw *hw)
{
	uint32_t manc = 0;
	uint32_t fwsm = 0;
	DEBUGFUNC("em_check_phy_reset_block\n");

	if (IS_ICH8(hw->mac_type)) {
		fwsm = E1000_READ_REG(hw, FWSM);
		return (fwsm & E1000_FWSM_RSPCIPHY) ? E1000_SUCCESS :
		    E1000_BLK_PHY_RESET;
	}
	if (hw->mac_type > em_82547_rev_2)
		manc = E1000_READ_REG(hw, MANC);
	return (manc & E1000_MANC_BLK_PHY_RST_ON_IDE) ?
	    E1000_BLK_PHY_RESET : E1000_SUCCESS;
}

/******************************************************************************
 * Configure PCI-Ex no-snoop
 *
 * hw - Struct containing variables accessed by shared code.
 * no_snoop - Bitmap of no-snoop events.
 *
 * returns: E1000_SUCCESS
 *
 *****************************************************************************/
STATIC int32_t
em_set_pci_ex_no_snoop(struct em_hw *hw, uint32_t no_snoop)
{
	uint32_t gcr_reg = 0;
	DEBUGFUNC("em_set_pci_ex_no_snoop");

	if (hw->bus_type == em_bus_type_unknown)
		em_get_bus_info(hw);

	if (hw->bus_type != em_bus_type_pci_express)
		return E1000_SUCCESS;

	if (no_snoop) {
		gcr_reg = E1000_READ_REG(hw, GCR);
		gcr_reg &= ~(PCI_EX_NO_SNOOP_ALL);
		gcr_reg |= no_snoop;
		E1000_WRITE_REG(hw, GCR, gcr_reg);
	}
	if (IS_ICH8(hw->mac_type)) {
		uint32_t ctrl_ext;
		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
		ctrl_ext |= E1000_CTRL_EXT_RO_DIS;
		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
	}
	return E1000_SUCCESS;
}

/***************************************************************************
 *
 * Get software semaphore FLAG bit (SWFLAG).
 * SWFLAG is used to synchronize the access to all shared resource between
 * SW, FW and HW.
 *
 * hw: Struct containing variables accessed by shared code
 *
 ***************************************************************************/
STATIC int32_t
em_get_software_flag(struct em_hw *hw)
{
	int32_t  timeout = PHY_CFG_TIMEOUT;
	uint32_t extcnf_ctrl;
	DEBUGFUNC("em_get_software_flag");

	if (IS_ICH8(hw->mac_type)) {
		while (timeout) {
			extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);
			extcnf_ctrl |= E1000_EXTCNF_CTRL_SWFLAG;
			E1000_WRITE_REG(hw, EXTCNF_CTRL, extcnf_ctrl);

			extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);
			if (extcnf_ctrl & E1000_EXTCNF_CTRL_SWFLAG)
				break;
			msec_delay_irq(1);
			timeout--;
		}

		if (!timeout) {
			DEBUGOUT("FW or HW locks the resource too long.\n");
			return -E1000_ERR_CONFIG;
		}
	}
	return E1000_SUCCESS;
}

/***************************************************************************
 *
 * Release software semaphore FLAG bit (SWFLAG).
 * SWFLAG is used to synchronize the access to all shared resource between
 * SW, FW and HW.
 *
 * hw: Struct containing variables accessed by shared code
 *
 ***************************************************************************/
STATIC void
em_release_software_flag(struct em_hw *hw)
{
	uint32_t extcnf_ctrl;
	DEBUGFUNC("em_release_software_flag");

	if (IS_ICH8(hw->mac_type)) {
		extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);
		extcnf_ctrl &= ~E1000_EXTCNF_CTRL_SWFLAG;
		E1000_WRITE_REG(hw, EXTCNF_CTRL, extcnf_ctrl);
	}
	return;
}

/**
 *  em_valid_nvm_bank_detect_ich8lan - finds out the valid bank 0 or 1
 *  @@hw: pointer to the HW structure
 *  @@bank:  pointer to the variable that returns the active bank
 *
 *  Reads signature byte from the NVM using the flash access registers.
 *  Word 0x13 bits 15:14 = 10b indicate a valid signature for that bank.
 **/
int32_t
em_valid_nvm_bank_detect_ich8lan(struct em_hw *hw, uint32_t *bank)
{
	uint32_t eecd;
	uint32_t bank1_offset = hw->flash_bank_size * sizeof(uint16_t);
	uint32_t act_offset = E1000_ICH_NVM_SIG_WORD * 2 + 1;
	uint32_t nvm_dword = 0;
	uint8_t sig_byte = 0;
	int32_t ret_val;

	DEBUGFUNC("em_valid_nvm_bank_detect_ich8lan");

	switch (hw->mac_type) {
	case em_pch_spt:
		bank1_offset = hw->flash_bank_size * 2;
		act_offset = E1000_ICH_NVM_SIG_WORD * 2;

		/* set bank to 0 in case flash read fails. */
		*bank = 0;

		/* Check bank 0 */
		ret_val = em_read_ich8_dword(hw, act_offset, &nvm_dword);
		if (ret_val)
			return ret_val;
		sig_byte = (uint8_t)((nvm_dword & 0xFF00) >> 8);
		if ((sig_byte & E1000_ICH_NVM_VALID_SIG_MASK) ==
		    E1000_ICH_NVM_SIG_VALUE) {
			*bank = 0;
			return 0;
		}

		/* Check bank 1 */
		ret_val = em_read_ich8_dword(hw, act_offset + bank1_offset,
		    &nvm_dword);
		if (ret_val)
			return ret_val;
		sig_byte = (uint8_t)((nvm_dword & 0xFF00) >> 8);
		if ((sig_byte & E1000_ICH_NVM_VALID_SIG_MASK) ==
		    E1000_ICH_NVM_SIG_VALUE) {
			*bank = 1;
			return 0;
		}

		DEBUGOUT("ERROR: No valid NVM bank present\n");
		return -1;
	case em_ich8lan:
	case em_ich9lan:
		eecd = E1000_READ_REG(hw, EECD);
		if ((eecd & E1000_EECD_SEC1VAL_VALID_MASK) ==
		    E1000_EECD_SEC1VAL_VALID_MASK) {
			if (eecd & E1000_EECD_SEC1VAL)
				*bank = 1;
			else
				*bank = 0;

			return E1000_SUCCESS;
		}
		DEBUGOUT("Unable to determine valid NVM bank via EEC - reading flash signature\n");
		/* fall-thru */
	default:
		/* set bank to 0 in case flash read fails */
		*bank = 0;

		/* Check bank 0 */
		ret_val = em_read_ich8_byte(hw, act_offset,
							&sig_byte);
		if (ret_val)
			return ret_val;
		if ((sig_byte & E1000_ICH_NVM_VALID_SIG_MASK) ==
		    E1000_ICH_NVM_SIG_VALUE) {
			*bank = 0;
			return E1000_SUCCESS;
		}

		/* Check bank 1 */
		ret_val = em_read_ich8_byte(hw, act_offset +
							bank1_offset,
							&sig_byte);
		if (ret_val)
			return ret_val;
		if ((sig_byte & E1000_ICH_NVM_VALID_SIG_MASK) ==
		    E1000_ICH_NVM_SIG_VALUE) {
			*bank = 1;
			return E1000_SUCCESS;
		}

		DEBUGOUT("ERROR: No valid NVM bank present\n");
		return -1;
	}
}

STATIC int32_t
em_read_eeprom_spt(struct em_hw *hw, uint16_t offset, uint16_t words,
    uint16_t *data)
{
	int32_t  error = E1000_SUCCESS;
	uint32_t flash_bank = 0;
	uint32_t act_offset = 0;
	uint32_t bank_offset = 0;
	uint32_t dword = 0;
	uint16_t i = 0, add;

	/*
	 * We need to know which is the valid flash bank.  In the event that
	 * we didn't allocate eeprom_shadow_ram, we may not be managing
	 * flash_bank.  So it cannot be trusted and needs to be updated with
	 * each read.
	 */

	if (hw->mac_type != em_pch_spt)
		return -E1000_ERR_EEPROM;

	error = em_get_software_flag(hw);
	if (error != E1000_SUCCESS)
		return error;

	error = em_valid_nvm_bank_detect_ich8lan(hw, &flash_bank);
	if (error != E1000_SUCCESS) {
		DEBUGOUT("Could not detect valid bank, assuming bank 0\n");
		flash_bank = 0;
	}

	/*
	 * Adjust offset appropriately if we're on bank 1 - adjust for word
	 * size
	 */
	bank_offset = flash_bank * (hw->flash_bank_size * 2);

	for (i = add = 0; i < words; i += add) {
		if ((offset + i) % 2) {
			add = 1;
			if (hw->eeprom_shadow_ram != NULL
			    && hw->eeprom_shadow_ram[offset + i].modified) {
				data[i] =
				    hw->eeprom_shadow_ram[offset+i].eeprom_word;
				continue;
			}
			act_offset = bank_offset + (offset + i - 1) * 2;
		} else {
			add = 2;
			if (hw->eeprom_shadow_ram != NULL
			    && hw->eeprom_shadow_ram[offset+i].modified
			    && hw->eeprom_shadow_ram[offset+i+1].modified) {
				data[i] = hw->eeprom_shadow_ram[offset+i].eeprom_word;
				data[i+1] = hw->eeprom_shadow_ram[offset+i+1].eeprom_word;
				continue;
			}
			act_offset = bank_offset + (offset + i) * 2;
		}
		error = em_read_ich8_dword(hw, act_offset, &dword);
		if (error != E1000_SUCCESS)
			break;
		if (hw->eeprom_shadow_ram != NULL
		    && hw->eeprom_shadow_ram[offset+i].modified) {
			data[i] = hw->eeprom_shadow_ram[offset+i].eeprom_word;
		} else {
			if (add == 1)
				data[i] = dword >> 16;
			else
				data[i] = dword & 0xFFFFUL;
		}
		if (add == 1 || words-i == 1)
			continue;
		if (hw->eeprom_shadow_ram != NULL
		    && hw->eeprom_shadow_ram[offset+i+1].modified) {
			data[i+1] =
			    hw->eeprom_shadow_ram[offset+i+1].eeprom_word;
		} else {
			data[i+1] = dword >> 16;
		}
	}

	em_release_software_flag(hw);

	return error;
}

/******************************************************************************
 * Reads a 16 bit word or words from the EEPROM using the ICH8's flash access
 * register.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset of word in the EEPROM to read
 * data - word read from the EEPROM
 * words - number of words to read
 *****************************************************************************/
STATIC int32_t
em_read_eeprom_ich8(struct em_hw *hw, uint16_t offset, uint16_t words,
    uint16_t *data)
{
	int32_t  error = E1000_SUCCESS;
	uint32_t flash_bank = 0;
	uint32_t act_offset = 0;
	uint32_t bank_offset = 0;
	uint16_t word = 0;
	uint16_t i = 0;
	/*
	 * We need to know which is the valid flash bank.  In the event that
	 * we didn't allocate eeprom_shadow_ram, we may not be managing
	 * flash_bank.  So it cannot be trusted and needs to be updated with
	 * each read.
	 */

	if (hw->mac_type == em_pch_spt)
		return em_read_eeprom_spt(hw, offset, words, data);

	error = em_get_software_flag(hw);
	if (error != E1000_SUCCESS)
		return error;

	error = em_valid_nvm_bank_detect_ich8lan(hw, &flash_bank);
	if (error != E1000_SUCCESS) {
		DEBUGOUT("Could not detect valid bank, assuming bank 0\n");
		flash_bank = 0;
	}

	/*
	 * Adjust offset appropriately if we're on bank 1 - adjust for word
	 * size
	 */
	bank_offset = flash_bank * (hw->flash_bank_size * 2);

	for (i = 0; i < words; i++) {
		if (hw->eeprom_shadow_ram != NULL &&
		    hw->eeprom_shadow_ram[offset + i].modified == TRUE) {
			data[i] =
			    hw->eeprom_shadow_ram[offset + i].eeprom_word;
		} else {
			/* The NVM part needs a byte offset, hence * 2 */
			act_offset = bank_offset + ((offset + i) * 2);
			error = em_read_ich8_word(hw, act_offset, &word);
			if (error != E1000_SUCCESS)
				break;
			data[i] = word;
		}
	}

	em_release_software_flag(hw);

	return error;
}

/******************************************************************************
 * Writes a 16 bit word or words to the EEPROM using the ICH8's flash access
 * register.  Actually, writes are written to the shadow ram cache in the hw
 * structure hw->em_shadow_ram.  em_commit_shadow_ram flushes this to
 * the NVM, which occurs when the NVM checksum is updated.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset of word in the EEPROM to write
 * words - number of words to write
 * data - words to write to the EEPROM
 *****************************************************************************/
STATIC int32_t
em_write_eeprom_ich8(struct em_hw *hw, uint16_t offset, uint16_t words,
    uint16_t *data)
{
	uint32_t i = 0;
	int32_t  error = E1000_SUCCESS;
	error = em_get_software_flag(hw);
	if (error != E1000_SUCCESS)
		return error;
	/*
	 * A driver can write to the NVM only if it has eeprom_shadow_ram
	 * allocated.  Subsequent reads to the modified words are read from
	 * this cached structure as well.  Writes will only go into this
	 * cached structure unless it's followed by a call to
	 * em_update_eeprom_checksum() where it will commit the changes and
	 * clear the "modified" field.
	 */
	if (hw->eeprom_shadow_ram != NULL) {
		for (i = 0; i < words; i++) {
			if ((offset + i) < E1000_SHADOW_RAM_WORDS) {
				hw->eeprom_shadow_ram[offset + i].modified =
				    TRUE;
				hw->eeprom_shadow_ram[offset + i].eeprom_word =
				    data[i];
			} else {
				error = -E1000_ERR_EEPROM;
				break;
			}
		}
	} else {
		/*
		 * Drivers have the option to not allocate eeprom_shadow_ram
		 * as long as they don't perform any NVM writes.  An attempt
		 * in doing so will result in this error.
		 */
		error = -E1000_ERR_EEPROM;
	}

	em_release_software_flag(hw);

	return error;
}

/******************************************************************************
 * This function does initial flash setup so that a new read/write/erase cycle
 * can be started.
 *
 * hw - The pointer to the hw structure
 ****************************************************************************/
STATIC int32_t
em_ich8_cycle_init(struct em_hw *hw)
{
	union ich8_hws_flash_status hsfsts;
	int32_t error = E1000_ERR_EEPROM;
	int32_t i = 0;
	DEBUGFUNC("em_ich8_cycle_init");

	if (hw->mac_type == em_pch_spt)
		hsfsts.regval = E1000_READ_ICH_FLASH_REG32(hw,
		    ICH_FLASH_HSFSTS) & 0xFFFFUL;
	else
		hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw,
		    ICH_FLASH_HSFSTS);

	/* May be check the Flash Des Valid bit in Hw status */
	if (hsfsts.hsf_status.fldesvalid == 0) {
		DEBUGOUT("Flash descriptor invalid.  SW Sequencing must be"
		    " used.");
		return error;
	}
	/* Clear FCERR in Hw status by writing 1 */
	/* Clear DAEL in Hw status by writing a 1 */
	hsfsts.hsf_status.flcerr = 1;
	hsfsts.hsf_status.dael = 1;
	if (hw->mac_type == em_pch_spt)
		E1000_WRITE_ICH_FLASH_REG32(hw, ICH_FLASH_HSFSTS,
		    hsfsts.regval & 0xFFFFUL);
	else
		E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS,
		    hsfsts.regval);
	/*
	 * Either we should have a hardware SPI cycle in progress bit to
	 * check against, in order to start a new cycle or FDONE bit should
	 * be changed in the hardware so that it is 1 after hardware reset,
	 * which can then be used as an indication whether a cycle is in
	 * progress or has been completed .. we should also have some
	 * software semaphore mechanism to guard FDONE or the cycle in
	 * progress bit so that two threads access to those bits can be
	 * sequentiallized or a way so that 2 threads dont start the cycle at
	 * the same time
	 */

	if (hsfsts.hsf_status.flcinprog == 0) {
		/*
		 * There is no cycle running at present, so we can start a
		 * cycle
		 */
		/* Begin by setting Flash Cycle Done. */
		hsfsts.hsf_status.flcdone = 1;
		if (hw->mac_type == em_pch_spt)
			E1000_WRITE_ICH_FLASH_REG32(hw, ICH_FLASH_HSFSTS,
			    hsfsts.regval & 0xFFFFUL);
		else
			E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS,
			    hsfsts.regval);
		error = E1000_SUCCESS;
	} else {
		/*
		 * otherwise poll for sometime so the current cycle has a
		 * chance to end before giving up.
		 */
		for (i = 0; i < ICH_FLASH_COMMAND_TIMEOUT; i++) {
			if (hw->mac_type == em_pch_spt)
				hsfsts.regval = E1000_READ_ICH_FLASH_REG32(
				    hw, ICH_FLASH_HSFSTS) & 0xFFFFUL;
			else
				hsfsts.regval = E1000_READ_ICH_FLASH_REG16(
				    hw, ICH_FLASH_HSFSTS);
			if (hsfsts.hsf_status.flcinprog == 0) {
				error = E1000_SUCCESS;
				break;
			}
			usec_delay(1);
		}
		if (error == E1000_SUCCESS) {
			/*
			 * Successful in waiting for previous cycle to
			 * timeout, now set the Flash Cycle Done.
			 */
			hsfsts.hsf_status.flcdone = 1;
			if (hw->mac_type == em_pch_spt)
				E1000_WRITE_ICH_FLASH_REG32(hw,
				    ICH_FLASH_HSFSTS, hsfsts.regval & 0xFFFFUL);
			else
				E1000_WRITE_ICH_FLASH_REG16(hw,
				    ICH_FLASH_HSFSTS, hsfsts.regval);
		} else {
			DEBUGOUT("Flash controller busy, cannot get access");
		}
	}
	return error;
}

/******************************************************************************
 * This function starts a flash cycle and waits for its completion
 *
 * hw - The pointer to the hw structure
 *****************************************************************************/
STATIC int32_t
em_ich8_flash_cycle(struct em_hw *hw, uint32_t timeout)
{
	union ich8_hws_flash_ctrl hsflctl;
	union ich8_hws_flash_status hsfsts;
	int32_t  error = E1000_ERR_EEPROM;
	uint32_t i = 0;

	/* Start a cycle by writing 1 in Flash Cycle Go in Hw Flash Control */
	if (hw->mac_type == em_pch_spt)
		hsflctl.regval = E1000_READ_ICH_FLASH_REG32(hw,
		    ICH_FLASH_HSFSTS) >> 16;
	else
		hsflctl.regval = E1000_READ_ICH_FLASH_REG16(hw,
		    ICH_FLASH_HSFCTL);
	hsflctl.hsf_ctrl.flcgo = 1;

	if (hw->mac_type == em_pch_spt)
		E1000_WRITE_ICH_FLASH_REG32(hw, ICH_FLASH_HSFSTS,
		    (uint32_t)hsflctl.regval << 16);
	else
		E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL,
		    hsflctl.regval);

	/* wait till FDONE bit is set to 1 */
	do {
		if (hw->mac_type == em_pch_spt)
			hsfsts.regval = E1000_READ_ICH_FLASH_REG32(hw,
			    ICH_FLASH_HSFSTS) & 0xFFFFUL;
		else
			hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw,
			    ICH_FLASH_HSFSTS);
		if (hsfsts.hsf_status.flcdone == 1)
			break;
		usec_delay(1);
		i++;
	} while (i < timeout);
	if (hsfsts.hsf_status.flcdone == 1 && hsfsts.hsf_status.flcerr == 0) {
		error = E1000_SUCCESS;
	}
	return error;
}

/******************************************************************************
 * Reads a byte or word from the NVM using the ICH8 flash access registers.
 *
 * hw - The pointer to the hw structure
 * index - The index of the byte or word to read.
 * size - Size of data to read, 1=byte 2=word
 * data - Pointer to the word to store the value read.
 *****************************************************************************/
STATIC int32_t
em_read_ich8_data(struct em_hw *hw, uint32_t index, uint32_t size,
    uint16_t *data)
{
	union ich8_hws_flash_status hsfsts;
	union ich8_hws_flash_ctrl hsflctl;
	uint32_t flash_linear_address;
	uint32_t flash_data = 0;
	int32_t  error = -E1000_ERR_EEPROM;
	int32_t  count = 0;
	DEBUGFUNC("em_read_ich8_data");

	if (size < 1 || size > 2 || data == 0x0 ||
	    index > ICH_FLASH_LINEAR_ADDR_MASK)
		return error;

	flash_linear_address = (ICH_FLASH_LINEAR_ADDR_MASK & index) +
	    hw->flash_base_addr;

	do {
		usec_delay(1);
		/* Steps */
		error = em_ich8_cycle_init(hw);
		if (error != E1000_SUCCESS)
			break;

		hsflctl.regval = E1000_READ_ICH_FLASH_REG16(hw,
		    ICH_FLASH_HSFCTL);
		/* 0b/1b corresponds to 1 or 2 byte size, respectively. */
		hsflctl.hsf_ctrl.fldbcount = size - 1;
		hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_READ;
		E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL,
		    hsflctl.regval);
		/*
		 * Write the last 24 bits of index into Flash Linear address
		 * field in Flash Address
		 */
		/* TODO: TBD maybe check the index against the size of flash */

		E1000_WRITE_ICH_FLASH_REG32(hw, ICH_FLASH_FADDR,
		    flash_linear_address);

		error = em_ich8_flash_cycle(hw, ICH_FLASH_COMMAND_TIMEOUT);
		/*
		 * Check if FCERR is set to 1, if set to 1, clear it and try
		 * the whole sequence a few more times, else read in (shift
		 * in) the Flash Data0, the order is least significant byte
		 * first msb to lsb
		 */
		if (error == E1000_SUCCESS) {
			flash_data = E1000_READ_ICH_FLASH_REG(hw,
			    ICH_FLASH_FDATA0);
			if (size == 1) {
				*data = (uint8_t) (flash_data & 0x000000FF);
			} else if (size == 2) {
				*data = (uint16_t) (flash_data & 0x0000FFFF);
			}
			break;
		} else {
			/*
			 * If we've gotten here, then things are probably
			 * completely hosed, but if the error condition is
			 * detected, it won't hurt to give it another
			 * try...ICH_FLASH_CYCLE_REPEAT_COUNT times.
			 */
			hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw,
			    ICH_FLASH_HSFSTS);
			if (hsfsts.hsf_status.flcerr == 1) {
				/* Repeat for some time before giving up. */
				continue;
			} else if (hsfsts.hsf_status.flcdone == 0) {
				DEBUGOUT("Timeout error - flash cycle did not"
				    " complete.");
				break;
			}
		}
	} while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);

	return error;
}

STATIC int32_t
em_read_ich8_data32(struct em_hw *hw, uint32_t offset, uint32_t *data)
{
	union ich8_hws_flash_status hsfsts;
	union ich8_hws_flash_ctrl hsflctl;
	uint32_t flash_linear_address;
	int32_t  error = -E1000_ERR_EEPROM;
	uint32_t  count = 0;
	DEBUGFUNC("em_read_ich8_data32");

	if (hw->mac_type != em_pch_spt)
		return error;
	if (offset > ICH_FLASH_LINEAR_ADDR_MASK)
		return error;
	flash_linear_address = (ICH_FLASH_LINEAR_ADDR_MASK & offset) +
	    hw->flash_base_addr;

	do {
		usec_delay(1);
		/* Steps */
		error = em_ich8_cycle_init(hw);
		if (error != E1000_SUCCESS)
			break;

		/* 32 bit accesses in SPT. */
		hsflctl.regval = E1000_READ_ICH_FLASH_REG32(hw,
		    ICH_FLASH_HSFSTS) >> 16;

		hsflctl.hsf_ctrl.fldbcount = sizeof(uint32_t) - 1;
		hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_READ;

		E1000_WRITE_ICH_FLASH_REG32(hw, ICH_FLASH_HSFSTS,
		    (uint32_t)hsflctl.regval << 16);
		/*
		 * Write the last 24 bits of offset into Flash Linear address
		 * field in Flash Address
		 */
		/* TODO: TBD maybe check the offset against the size of flash */

		E1000_WRITE_ICH_FLASH_REG32(hw, ICH_FLASH_FADDR,
		    flash_linear_address);

		error = em_ich8_flash_cycle(hw, ICH_FLASH_COMMAND_TIMEOUT);
		/*
		 * Check if FCERR is set to 1, if set to 1, clear it and try
		 * the whole sequence a few more times, else read in (shift
		 * in) the Flash Data0, the order is least significant byte
		 * first msb to lsb
		 */
		if (error == E1000_SUCCESS) {
			(*data) = (uint32_t)E1000_READ_ICH_FLASH_REG32(hw,
			    ICH_FLASH_FDATA0);
			break;
		} else {
			/*
			 * If we've gotten here, then things are probably
			 * completely hosed, but if the error condition is
			 * detected, it won't hurt to give it another
			 * try...ICH_FLASH_CYCLE_REPEAT_COUNT times.
			 */
			hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw,
			    ICH_FLASH_HSFSTS);
			if (hsfsts.hsf_status.flcerr == 1) {
				/* Repeat for some time before giving up. */
				continue;
			} else if (hsfsts.hsf_status.flcdone == 0) {
				DEBUGOUT("Timeout error - flash cycle did not"
				    " complete.");
				break;
			}
		}
	} while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);

	return error;
}


/******************************************************************************
 * Writes One /two bytes to the NVM using the ICH8 flash access registers.
 *
 * hw - The pointer to the hw structure
 * index - The index of the byte/word to write.
 * size - Size of data to read, 1=byte 2=word
 * data - The byte(s) to write to the NVM.
 *****************************************************************************/
STATIC int32_t
em_write_ich8_data(struct em_hw *hw, uint32_t index, uint32_t size,
    uint16_t data)
{
	union ich8_hws_flash_status hsfsts;
	union ich8_hws_flash_ctrl hsflctl;
	uint32_t flash_linear_address;
	uint32_t flash_data = 0;
	int32_t  error = -E1000_ERR_EEPROM;
	int32_t  count = 0;
	DEBUGFUNC("em_write_ich8_data");

	if (hw->mac_type == em_pch_spt)
		return -E1000_ERR_EEPROM;
	if (size < 1 || size > 2 || data > size * 0xff ||
	    index > ICH_FLASH_LINEAR_ADDR_MASK)
		return error;

	flash_linear_address = (ICH_FLASH_LINEAR_ADDR_MASK & index) +
	    hw->flash_base_addr;

	do {
		usec_delay(1);
		/* Steps */
		error = em_ich8_cycle_init(hw);
		if (error != E1000_SUCCESS)
			break;

		hsflctl.regval = E1000_READ_ICH_FLASH_REG16(hw,
		    ICH_FLASH_HSFCTL);
		/* 0b/1b corresponds to 1 or 2 byte size, respectively. */
		hsflctl.hsf_ctrl.fldbcount = size - 1;
		hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_WRITE;
		E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL,
		    hsflctl.regval);
		/*
		 * Write the last 24 bits of index into Flash Linear address
		 * field in Flash Address
		 */
		E1000_WRITE_ICH_FLASH_REG32(hw, ICH_FLASH_FADDR,
		    flash_linear_address);

		if (size == 1)
			flash_data = (uint32_t) data & 0x00FF;
		else
			flash_data = (uint32_t) data;

		E1000_WRITE_ICH_FLASH_REG32(hw, ICH_FLASH_FDATA0, flash_data);
		/*
		 * check if FCERR is set to 1 , if set to 1, clear it and try
		 * the whole sequence a few more times else done
		 */
		error = em_ich8_flash_cycle(hw, ICH_FLASH_COMMAND_TIMEOUT);
		if (error == E1000_SUCCESS) {
			break;
		} else {
			/*
			 * If we're here, then things are most likely
			 * completely hosed, but if the error condition is
			 * detected, it won't hurt to give it another
			 * try...ICH_FLASH_CYCLE_REPEAT_COUNT times.
			 */
			hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw,
			    ICH_FLASH_HSFSTS);
			if (hsfsts.hsf_status.flcerr == 1) {
				/* Repeat for some time before giving up. */
				continue;
			} else if (hsfsts.hsf_status.flcdone == 0) {
				DEBUGOUT("Timeout error - flash cycle did not"
				    " complete.");
				break;
			}
		}
	} while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);

	return error;
}

/******************************************************************************
 * Reads a single byte from the NVM using the ICH8 flash access registers.
 *
 * hw - pointer to em_hw structure
 * index - The index of the byte to read.
 * data - Pointer to a byte to store the value read.
 *****************************************************************************/
STATIC int32_t
em_read_ich8_byte(struct em_hw *hw, uint32_t index, uint8_t *data)
{
	int32_t  status = E1000_SUCCESS;
	uint16_t word = 0;

	if (hw->mac_type == em_pch_spt)
		return -E1000_ERR_EEPROM;
	else
		status = em_read_ich8_data(hw, index, 1, &word);
	if (status == E1000_SUCCESS) {
		*data = (uint8_t) word;
	}
	return status;
}

/******************************************************************************
 * Writes a single byte to the NVM using the ICH8 flash access registers.
 * Performs verification by reading back the value and then going through
 * a retry algorithm before giving up.
 *
 * hw - pointer to em_hw structure
 * index - The index of the byte to write.
 * byte - The byte to write to the NVM.
 *****************************************************************************/
STATIC int32_t
em_verify_write_ich8_byte(struct em_hw *hw, uint32_t index, uint8_t byte)
{
	int32_t error = E1000_SUCCESS;
	int32_t program_retries = 0;
	DEBUGOUT2("Byte := %2.2X Offset := %d\n", byte, index);

	error = em_write_ich8_byte(hw, index, byte);

	if (error != E1000_SUCCESS) {
		for (program_retries = 0; program_retries < 100;
		    program_retries++) {
			DEBUGOUT2("Retrying \t Byte := %2.2X Offset := %d\n",
			    byte, index);
			error = em_write_ich8_byte(hw, index, byte);
			usec_delay(100);
			if (error == E1000_SUCCESS)
				break;
		}
	}
	if (program_retries == 100)
		error = E1000_ERR_EEPROM;

	return error;
}

/******************************************************************************
 * Writes a single byte to the NVM using the ICH8 flash access registers.
 *
 * hw - pointer to em_hw structure
 * index - The index of the byte to read.
 * data - The byte to write to the NVM.
 *****************************************************************************/
STATIC int32_t
em_write_ich8_byte(struct em_hw *hw, uint32_t index, uint8_t data)
{
	int32_t  status = E1000_SUCCESS;
	uint16_t word = (uint16_t) data;
	status = em_write_ich8_data(hw, index, 1, word);

	return status;
}

/******************************************************************************
 * Reads a dword from the NVM using the ICH8 flash access registers.
 *
 * hw - pointer to em_hw structure
 * index - The starting BYTE index of the word to read.
 * data - Pointer to a word to store the value read.
 *****************************************************************************/
STATIC int32_t
em_read_ich8_dword(struct em_hw *hw, uint32_t index, uint32_t *data)
{
	int32_t status = E1000_SUCCESS;
	status = em_read_ich8_data32(hw, index, data);
	return status;
}

/******************************************************************************
 * Reads a word from the NVM using the ICH8 flash access registers.
 *
 * hw - pointer to em_hw structure
 * index - The starting byte index of the word to read.
 * data - Pointer to a word to store the value read.
 *****************************************************************************/
STATIC int32_t
em_read_ich8_word(struct em_hw *hw, uint32_t index, uint16_t *data)
{
	int32_t status = E1000_SUCCESS;
	status = em_read_ich8_data(hw, index, 2, data);
	return status;
}

/******************************************************************************
 * Erases the bank specified. Each bank may be a 4, 8 or 64k block. Banks are 0
 * based.
 *
 * hw - pointer to em_hw structure
 * bank - 0 for first bank, 1 for second bank
 *
 * Note that this function may actually erase as much as 8 or 64 KBytes.  The
 * amount of NVM used in each bank is a *minimum* of 4 KBytes, but in fact the
 * bank size may be 4, 8 or 64 KBytes
 *****************************************************************************/
int32_t
em_erase_ich8_4k_segment(struct em_hw *hw, uint32_t bank)
{
	union ich8_hws_flash_status hsfsts;
	union ich8_hws_flash_ctrl hsflctl;
	uint32_t flash_linear_address;
	int32_t  count = 0;
	int32_t  error = E1000_ERR_EEPROM;
	int32_t  iteration;
	int32_t  sub_sector_size = 0;
	int32_t  bank_size;
	int32_t  j = 0;
	int32_t  error_flag = 0;
	hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS);
	/*
	 * Determine HW Sector size: Read BERASE bits of Hw flash Status
	 * register
	 */
	/*
	 * 00: The Hw sector is 256 bytes, hence we need to erase 16
	 * consecutive sectors.  The start index for the nth Hw sector can be
	 * calculated as bank * 4096 + n * 256 01: The Hw sector is 4K bytes,
	 * hence we need to erase 1 sector. The start index for the nth Hw
	 * sector can be calculated as bank * 4096 10: The HW sector is 8K
	 * bytes 11: The Hw sector size is 64K bytes
	 */
	if (hsfsts.hsf_status.berasesz == 0x0) {
		/* Hw sector size 256 */
		sub_sector_size = ICH_FLASH_SEG_SIZE_256;
		bank_size = ICH_FLASH_SECTOR_SIZE;
		iteration = ICH_FLASH_SECTOR_SIZE / ICH_FLASH_SEG_SIZE_256;
	} else if (hsfsts.hsf_status.berasesz == 0x1) {
		bank_size = ICH_FLASH_SEG_SIZE_4K;
		iteration = 1;
	} else if (hsfsts.hsf_status.berasesz == 0x2) {
		if (hw->mac_type == em_ich9lan) {
			uint32_t gfpreg, sector_base_addr, sector_end_addr;
			gfpreg = E1000_READ_ICH_FLASH_REG(hw,
			    ICH_FLASH_GFPREG);
			/*
		         * sector_X_addr is a "sector"-aligned address (4096 bytes)
		         * Add 1 to sector_end_addr since this sector is included in
		         * the overall size.
		         */
			sector_base_addr = gfpreg & ICH_GFPREG_BASE_MASK;
			sector_end_addr = 
			    ((gfpreg >> 16) & ICH_GFPREG_BASE_MASK) + 1;

			/*
		         * find total size of the NVM, then cut in half since the total
		         * size represents two separate NVM banks.
		         */
			bank_size = (sector_end_addr - sector_base_addr)
			    << ICH_FLASH_SECT_ADDR_SHIFT;
			bank_size /= 2;
			/* Word align */
			bank_size = 
			    (bank_size / sizeof(uint16_t)) * sizeof(uint16_t);

			sub_sector_size = ICH_FLASH_SEG_SIZE_8K;
			iteration = bank_size / ICH_FLASH_SEG_SIZE_8K;
		} else {
			return error;
		}
	} else if (hsfsts.hsf_status.berasesz == 0x3) {
		bank_size = ICH_FLASH_SEG_SIZE_64K;
		iteration = 1;
	} else {
		return error;
	}

	for (j = 0; j < iteration; j++) {
		do {
			count++;
			/* Steps */
			error = em_ich8_cycle_init(hw);
			if (error != E1000_SUCCESS) {
				error_flag = 1;
				break;
			}
			/*
			 * Write a value 11 (block Erase) in Flash Cycle
			 * field in Hw flash Control
			 */
			hsflctl.regval = E1000_READ_ICH_FLASH_REG16(hw,
			    ICH_FLASH_HSFCTL);
			hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_ERASE;
			E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL,
			    hsflctl.regval);
			/*
			 * Write the last 24 bits of an index within the
			 * block into Flash Linear address field in Flash
			 * Address.  This probably needs to be calculated
			 * here based off the on-chip erase sector size and
			 * the software bank size (4, 8 or 64 KBytes)
			 */
			flash_linear_address = 
			    bank * bank_size + j * sub_sector_size;
			flash_linear_address += hw->flash_base_addr;
			flash_linear_address &= ICH_FLASH_LINEAR_ADDR_MASK;

			E1000_WRITE_ICH_FLASH_REG32(hw, ICH_FLASH_FADDR,
			    flash_linear_address);

			error =
			    em_ich8_flash_cycle(hw, ICH_FLASH_ERASE_TIMEOUT);
			/*
			 * Check if FCERR is set to 1.  If 1, clear it and
			 * try the whole sequence a few more times else Done
			 */
			if (error == E1000_SUCCESS) {
				break;
			} else {
				hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw,
				    ICH_FLASH_HSFSTS);
				if (hsfsts.hsf_status.flcerr == 1) {
					/*
					 * repeat for some time before giving
					 * up
					 */
					continue;
				} else if (hsfsts.hsf_status.flcdone == 0) {
					error_flag = 1;
					break;
				}
			}
		} while ((count < ICH_FLASH_CYCLE_REPEAT_COUNT) && !error_flag);
		if (error_flag == 1)
			break;
	}
	if (error_flag != 1)
		error = E1000_SUCCESS;
	return error;
}

/******************************************************************************
 * Reads 16-bit words from the OTP. Return error when the word is not
 * stored in OTP.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset of word in the OTP to read
 * data - word read from the OTP
 * words - number of words to read
 *****************************************************************************/
STATIC int32_t
em_read_invm_i210(struct em_hw *hw, uint16_t offset, uint16_t words,
    uint16_t *data)
{
	int32_t  ret_val = E1000_SUCCESS;

	switch (offset)
	{
	case EEPROM_MAC_ADDR_WORD0:
	case EEPROM_MAC_ADDR_WORD1:
	case EEPROM_MAC_ADDR_WORD2:
		/* Generate random MAC address if there's none. */
		ret_val = em_read_invm_word_i210(hw, offset, data);
		if (ret_val != E1000_SUCCESS) {
			DEBUGOUT("MAC Addr not found in iNVM\n");
			*data = 0xFFFF;
			ret_val = E1000_SUCCESS;
		}
		break;
	case EEPROM_INIT_CONTROL2_REG:
		ret_val = em_read_invm_word_i210(hw, offset, data);
		if (ret_val != E1000_SUCCESS) {
			*data = NVM_INIT_CTRL_2_DEFAULT_I211;
			ret_val = E1000_SUCCESS;
		}
		break;
	case EEPROM_INIT_CONTROL4_REG:
		ret_val = em_read_invm_word_i210(hw, offset, data);
		if (ret_val != E1000_SUCCESS) {
			*data = NVM_INIT_CTRL_4_DEFAULT_I211;
			ret_val = E1000_SUCCESS;
		}
		break;
	case EEPROM_LED_1_CFG:
		ret_val = em_read_invm_word_i210(hw, offset, data);
		if (ret_val != E1000_SUCCESS) {
			*data = NVM_LED_1_CFG_DEFAULT_I211;
			ret_val = E1000_SUCCESS;
		}
		break;
	case EEPROM_LED_0_2_CFG:
		ret_val = em_read_invm_word_i210(hw, offset, data);
		if (ret_val != E1000_SUCCESS) {
			*data = NVM_LED_0_2_CFG_DEFAULT_I211;
			ret_val = E1000_SUCCESS;
		}
		break;
	case EEPROM_ID_LED_SETTINGS:
		ret_val = em_read_invm_word_i210(hw, offset, data);
		if (ret_val != E1000_SUCCESS) {
			*data = ID_LED_RESERVED_FFFF;
			ret_val = E1000_SUCCESS;
		}
		break;
	default:
		DEBUGOUT1("NVM word 0x%02x is not mapped.\n", offset);
		*data = NVM_RESERVED_WORD;
		break;
	}

	return ret_val;
}

/******************************************************************************
 * Reads 16-bit words from the OTP. Return error when the word is not
 * stored in OTP.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset of word in the OTP to read
 * data - word read from the OTP
 *****************************************************************************/
STATIC int32_t
em_read_invm_word_i210(struct em_hw *hw, uint16_t address, uint16_t *data)
{
	int32_t  error = -E1000_NOT_IMPLEMENTED;
	uint32_t invm_dword;
	uint16_t i;
	uint8_t record_type, word_address;

	for (i = 0; i < INVM_SIZE; i++) {
		invm_dword = EM_READ_REG(hw, E1000_INVM_DATA_REG(i));
		/* Get record type */
		record_type = INVM_DWORD_TO_RECORD_TYPE(invm_dword);
		if (record_type == INVM_UNINITIALIZED_STRUCTURE)
			break;
		if (record_type == INVM_CSR_AUTOLOAD_STRUCTURE)
			i += INVM_CSR_AUTOLOAD_DATA_SIZE_IN_DWORDS;
		if (record_type == INVM_RSA_KEY_SHA256_STRUCTURE)
			i += INVM_RSA_KEY_SHA256_DATA_SIZE_IN_DWORDS;
		if (record_type == INVM_WORD_AUTOLOAD_STRUCTURE) {
			word_address = INVM_DWORD_TO_WORD_ADDRESS(invm_dword);
			if (word_address == address) {
				*data = INVM_DWORD_TO_WORD_DATA(invm_dword);
				error = E1000_SUCCESS;
				break;
			}
		}
	}

	return error;
}

STATIC int32_t
em_init_lcd_from_nvm_config_region(struct em_hw *hw, uint32_t cnf_base_addr,
    uint32_t cnf_size)
{
	uint32_t ret_val = E1000_SUCCESS;
	uint16_t word_addr, reg_data, reg_addr;
	uint16_t i;
	/* cnf_base_addr is in DWORD */
	word_addr = (uint16_t) (cnf_base_addr << 1);

	/* cnf_size is returned in size of dwords */
	for (i = 0; i < cnf_size; i++) {
		ret_val =
		    em_read_eeprom(hw, (word_addr + i * 2), 1, &reg_data);
		if (ret_val)
			return ret_val;

		ret_val =
		    em_read_eeprom(hw, (word_addr + i * 2 + 1), 1, &reg_addr);
		if (ret_val)
			return ret_val;

		ret_val = em_get_software_flag(hw);
		if (ret_val != E1000_SUCCESS)
			return ret_val;

		ret_val =
		    em_write_phy_reg_ex(hw, (uint32_t) reg_addr, reg_data);

		em_release_software_flag(hw);
	}

	return ret_val;
}

/******************************************************************************
 * This function initializes the PHY from the NVM on ICH8 platforms. This
 * is needed due to an issue where the NVM configuration is not properly
 * autoloaded after power transitions. Therefore, after each PHY reset, we
 * will load the configuration data out of the NVM manually.
 *
 * hw: Struct containing variables accessed by shared code
 *****************************************************************************/
STATIC int32_t
em_init_lcd_from_nvm(struct em_hw *hw)
{
	uint32_t reg_data, cnf_base_addr, cnf_size, ret_val, loop, sw_cfg_mask;
	if (hw->phy_type != em_phy_igp_3)
		return E1000_SUCCESS;

	/* Check if SW needs configure the PHY */
	if (hw->device_id == E1000_DEV_ID_ICH8_IGP_M_AMT ||
	    hw->device_id == E1000_DEV_ID_ICH8_IGP_M ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt ||
	    hw->mac_type == em_pch_spt)
		sw_cfg_mask = FEXTNVM_SW_CONFIG_ICH8M;
	else
		sw_cfg_mask = FEXTNVM_SW_CONFIG;

	reg_data = E1000_READ_REG(hw, FEXTNVM);
	if (!(reg_data & sw_cfg_mask))
		return E1000_SUCCESS;

	/* Wait for basic configuration completes before proceeding */
	loop = 0;
	do {
		reg_data =
		    E1000_READ_REG(hw, STATUS) & E1000_STATUS_LAN_INIT_DONE;
		usec_delay(100);
		loop++;
	} while ((!reg_data) && (loop < 50));

	/* Clear the Init Done bit for the next init event */
	reg_data = E1000_READ_REG(hw, STATUS);
	reg_data &= ~E1000_STATUS_LAN_INIT_DONE;
	E1000_WRITE_REG(hw, STATUS, reg_data);
	/*
	 * Make sure HW does not configure LCD from PHY extended
	 * configuration before SW configuration
	 */
	reg_data = E1000_READ_REG(hw, EXTCNF_CTRL);
	if ((reg_data & E1000_EXTCNF_CTRL_LCD_WRITE_ENABLE) == 0x0000) {
		reg_data = E1000_READ_REG(hw, EXTCNF_SIZE);
		cnf_size = reg_data & E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH;
		cnf_size >>= 16;
		if (cnf_size) {
			reg_data = E1000_READ_REG(hw, EXTCNF_CTRL);
			cnf_base_addr = reg_data & E1000_EXTCNF_CTRL_EXT_CNF_POINTER;
			/* cnf_base_addr is in DWORD */
			cnf_base_addr >>= 16;

			/* Configure LCD from extended configuration region. */
			ret_val = em_init_lcd_from_nvm_config_region(hw,
			    cnf_base_addr, cnf_size);
			if (ret_val)
				return ret_val;
		}
	}
	return E1000_SUCCESS;
}

/******************************************************************************
 *  em_set_pciex_completion_timeout - set pci-e completion timeout
 *
 *  The defaults for 82575 and 82576 should be in the range of 50us to 50ms,
 *  however the hardware default for these parts is 500us to 1ms which is less
 *  than the 10ms recommended by the pci-e spec.  To address this we need to
 *  increase the value to either 10ms to 200ms for capability version 1 config,
 *  or 16ms to 55ms for version 2.
 *
 *  * hw - pointer to em_hw structure
 *****************************************************************************/
int32_t
em_set_pciex_completion_timeout(struct em_hw *hw)
{
	uint32_t gcr = E1000_READ_REG(hw, GCR);
	int32_t ret_val = E1000_SUCCESS;

	/* Only take action if timeout value is not set by system BIOS */
	if (gcr & E1000_GCR_CMPL_TMOUT_MASK)
		goto out;

	DEBUGOUT("PCIe completion timeout not set by system BIOS.");

	/*
	 * If capababilities version is type 1 we can write the
	 * timeout of 10ms to 200ms through the GCR register
	 */

	if (!(gcr & E1000_GCR_CAP_VER2)) {
		gcr |= E1000_GCR_CMPL_TMOUT_10ms;
		DEBUGOUT("PCIe capability version 1 detected, setting \
		    completion timeout to 10ms.");
		goto out;
	}

	/*
	 * For version 2 capabilities we need to write the config space
	 * directly in order to set the completion timeout value for
	 * 16ms to 55ms
	 *
	 * XXX: Implement em_*_pcie_cap_reg() first.
	 */
#if 0
	ret_val = em_read_pcie_cap_reg(hw, PCIE_DEVICE_CONTROL2,
	    &pciex_devctl2);

	if (ret_val)
		goto out;

	pciex_devctl2 |= PCIE_DEVICE_CONTROL2_16ms;

	ret_val = em_write_pcie_cap_reg(hw, PCIE_DEVICE_CONTROL2,
	    &pciex_devctl2); 
#endif

out:

	/* Disable completion timeout resend */
	gcr &= ~E1000_GCR_CMPL_TMOUT_RESEND;

	DEBUGOUT("PCIe completion timeout resend disabled.");

	E1000_WRITE_REG(hw, GCR, gcr);
	return ret_val;
}

/***************************************************************************
 *  Set slow MDIO access mode
 ***************************************************************************/
static int32_t
em_set_mdio_slow_mode_hv(struct em_hw *hw)
{
	int32_t ret_val;
	uint16_t data;
	DEBUGFUNC("em_set_mdio_slow_mode_hv");

	ret_val = em_read_phy_reg(hw, HV_KMRN_MODE_CTRL, &data);
	if (ret_val)
		return ret_val;

	data |= HV_KMRN_MDIO_SLOW;

	ret_val = em_write_phy_reg(hw, HV_KMRN_MODE_CTRL, data);

	return ret_val;
}

/***************************************************************************
 *  A series of Phy workarounds to be done after every PHY reset.
 ***************************************************************************/
int32_t
em_hv_phy_workarounds_ich8lan(struct em_hw *hw)
{
	int32_t ret_val = E1000_SUCCESS;
	uint16_t phy_data;
	uint16_t swfw;
	DEBUGFUNC("em_hv_phy_workarounds_ich8lan");

	if (hw->mac_type != em_pchlan)
		goto out;

	swfw = E1000_SWFW_PHY0_SM;

	/* Set MDIO slow mode before any other MDIO access */
	if (hw->phy_type == em_phy_82577 ||
	    hw->phy_type == em_phy_82578) {
		ret_val = em_set_mdio_slow_mode_hv(hw);
		if (ret_val)
			goto out;
	}

	/* Hanksville M Phy init for IEEE. */
	if ((hw->revision_id == 2) &&
	    (hw->phy_type == em_phy_82577) &&
	    ((hw->phy_revision == 2) || (hw->phy_revision == 3))) {
		em_write_phy_reg(hw, 0x10, 0x8823);
		em_write_phy_reg(hw, 0x11, 0x0018);
		em_write_phy_reg(hw, 0x10, 0x8824);
		em_write_phy_reg(hw, 0x11, 0x0016);
		em_write_phy_reg(hw, 0x10, 0x8825);
		em_write_phy_reg(hw, 0x11, 0x001A);
		em_write_phy_reg(hw, 0x10, 0x888C);
		em_write_phy_reg(hw, 0x11, 0x0007);
		em_write_phy_reg(hw, 0x10, 0x888D);
		em_write_phy_reg(hw, 0x11, 0x0007);
		em_write_phy_reg(hw, 0x10, 0x888E);
		em_write_phy_reg(hw, 0x11, 0x0007);
		em_write_phy_reg(hw, 0x10, 0x8827);
		em_write_phy_reg(hw, 0x11, 0x0001);
		em_write_phy_reg(hw, 0x10, 0x8835);
		em_write_phy_reg(hw, 0x11, 0x0001);
		em_write_phy_reg(hw, 0x10, 0x8834);
		em_write_phy_reg(hw, 0x11, 0x0001);
		em_write_phy_reg(hw, 0x10, 0x8833);
		em_write_phy_reg(hw, 0x11, 0x0002);
	}

	if (((hw->phy_type == em_phy_82577) &&
	     ((hw->phy_revision == 1) || (hw->phy_revision == 2))) ||
	    ((hw->phy_type == em_phy_82578) && (hw->phy_revision == 1))) {
		/* Disable generation of early preamble */
		ret_val = em_write_phy_reg(hw, PHY_REG(769, 25), 0x4431);
		if (ret_val)
			goto out;

		/* Preamble tuning for SSC */
		ret_val = em_write_phy_reg(hw, PHY_REG(770, 16), 0xA204);
		if (ret_val)
			goto out;
	}

	if (hw->phy_type == em_phy_82578) {
		/*
		 * Return registers to default by doing a soft reset then
		 * writing 0x3140 to the control register.
		 */
		if (hw->phy_revision < 2) {
			em_phy_reset(hw);
			ret_val = em_write_phy_reg(hw, PHY_CTRL, 0x3140);
		}
	}

	if ((hw->revision_id == 2) &&
	    (hw->phy_type == em_phy_82577) &&
	    ((hw->phy_revision == 2) || (hw->phy_revision == 3))) {
		/*
		 * Workaround for OEM (GbE) not operating after reset -
		 * restart AN (twice)
		 */
		ret_val = em_write_phy_reg(hw, PHY_REG(0, 25), 0x0400);
		if (ret_val)
			goto out;
		ret_val = em_write_phy_reg(hw, PHY_REG(0, 25), 0x0400);
		if (ret_val)
			goto out;
	}

	/* Select page 0 */
	ret_val = em_swfw_sync_acquire(hw, swfw);
	if (ret_val)
		goto out;

	hw->phy_addr = 1;
	ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0);
	em_swfw_sync_release(hw, swfw);
	if (ret_val)
		goto out;

	/* Workaround for link disconnects on a busy hub in half duplex */
	ret_val = em_read_phy_reg(hw,
	                                      PHY_REG(BM_PORT_CTRL_PAGE, 17),
	                                      &phy_data);
	if (ret_val)
		goto release;
	ret_val = em_write_phy_reg(hw,
	                                       PHY_REG(BM_PORT_CTRL_PAGE, 17),
	                                       phy_data & 0x00FF);
release:
out:
	return ret_val;
}


/***************************************************************************
 *  Si workaround
 *
 *  This function works around a Si bug where the link partner can get
 *  a link up indication before the PHY does.  If small packets are sent
 *  by the link partner they can be placed in the packet buffer without
 *  being properly accounted for by the PHY and will stall preventing
 *  further packets from being received.  The workaround is to clear the
 *  packet buffer after the PHY detects link up.
 ***************************************************************************/
int32_t
em_link_stall_workaround_hv(struct em_hw *hw)
{
	int32_t ret_val = E1000_SUCCESS;
	uint16_t phy_data;

	if (hw->phy_type != em_phy_82578)
		goto out;

	/* Do not apply workaround if in PHY loopback bit 14 set */
	em_read_phy_reg(hw, PHY_CTRL, &phy_data);
	if (phy_data & E1000_PHY_CTRL_LOOPBACK)
		goto out;

	/* check if link is up and at 1Gbps */
	ret_val = em_read_phy_reg(hw, BM_CS_STATUS, &phy_data);
	if (ret_val)
		goto out;

	phy_data &= BM_CS_STATUS_LINK_UP |
		    BM_CS_STATUS_RESOLVED |
		    BM_CS_STATUS_SPEED_MASK;

	if (phy_data != (BM_CS_STATUS_LINK_UP |
			 BM_CS_STATUS_RESOLVED |
			 BM_CS_STATUS_SPEED_1000))
		goto out;

	msec_delay(200);

	/* flush the packets in the fifo buffer */
	ret_val = em_write_phy_reg(hw, HV_MUX_DATA_CTRL,
	    HV_MUX_DATA_CTRL_GEN_TO_MAC | HV_MUX_DATA_CTRL_FORCE_SPEED);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, HV_MUX_DATA_CTRL,
	    HV_MUX_DATA_CTRL_GEN_TO_MAC);

out:
	return ret_val;
}

/****************************************************************************
 *  K1 Si workaround
 *
 *  If K1 is enabled for 1Gbps, the MAC might stall when transitioning
 *  from a lower speed.  This workaround disables K1 whenever link is at 1Gig.
 *  If link is down, the function will restore the default K1 setting located
 *  in the NVM.
 ****************************************************************************/
int32_t
em_k1_gig_workaround_hv(struct em_hw *hw, boolean_t link)
{
	int32_t ret_val;
	uint16_t phy_data;
	boolean_t k1_enable;

	DEBUGFUNC("em_k1_gig_workaround_hv");

	if (hw->mac_type != em_pchlan)
		return E1000_SUCCESS;

	ret_val = em_read_eeprom_ich8(hw, E1000_NVM_K1_CONFIG, 1, &phy_data);
	if (ret_val)
		return ret_val;

	k1_enable = phy_data & E1000_NVM_K1_ENABLE ? TRUE : FALSE;

	/* Disable K1 when link is 1Gbps, otherwise use the NVM setting */
	if (link) {
		if (hw->phy_type == em_phy_82578) {
			ret_val = em_read_phy_reg(hw, BM_CS_STATUS,
			    &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= BM_CS_STATUS_LINK_UP |
				    BM_CS_STATUS_RESOLVED |
				    BM_CS_STATUS_SPEED_MASK;

			if (phy_data == (BM_CS_STATUS_LINK_UP |
					 BM_CS_STATUS_RESOLVED |
					 BM_CS_STATUS_SPEED_1000))
				k1_enable = FALSE;
		}

		if (hw->phy_type == em_phy_82577) {
			ret_val = em_read_phy_reg(hw, HV_M_STATUS,
			    &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= HV_M_STATUS_LINK_UP |
				    HV_M_STATUS_AUTONEG_COMPLETE |
				    HV_M_STATUS_SPEED_MASK;

			if (phy_data == (HV_M_STATUS_LINK_UP |
					 HV_M_STATUS_AUTONEG_COMPLETE |
					 HV_M_STATUS_SPEED_1000))
				k1_enable = FALSE;
		}

		/* Link stall fix for link up */
		ret_val = em_write_phy_reg(hw, PHY_REG(770, 19),
		    0x0100);
		if (ret_val)
			return ret_val;

	} else {
		/* Link stall fix for link down */
		ret_val = em_write_phy_reg(hw, PHY_REG(770, 19),
		    0x4100);
		if (ret_val)
			return ret_val;
	}

	ret_val = em_configure_k1_ich8lan(hw, k1_enable);

	return ret_val;
}

/* Workaround to set the K1 beacon duration for 82579 parts */
int32_t
em_k1_workaround_lv(struct em_hw *hw)
{
	int32_t ret_val;
	uint16_t phy_data;
	uint32_t mac_reg;

	ret_val = em_read_phy_reg(hw, BM_CS_STATUS, &phy_data);
	if (ret_val)
		return ret_val;

	if ((phy_data & (HV_M_STATUS_LINK_UP | HV_M_STATUS_AUTONEG_COMPLETE))
	    == (HV_M_STATUS_LINK_UP | HV_M_STATUS_AUTONEG_COMPLETE)) {
		mac_reg = E1000_READ_REG(hw, FEXTNVM4);
		mac_reg &= ~E1000_FEXTNVM4_BEACON_DURATION_MASK;

		if (phy_data & HV_M_STATUS_SPEED_1000)
			mac_reg |= E1000_FEXTNVM4_BEACON_DURATION_8USEC;
		else
			mac_reg |= E1000_FEXTNVM4_BEACON_DURATION_16USEC;

		E1000_WRITE_REG(hw, FEXTNVM4, mac_reg);
	}
	
	return E1000_SUCCESS;
}

/**
 *  em_k1_workaround_lpt_lp - K1 workaround on Lynxpoint-LP
 *
 *  When K1 is enabled for 1Gbps, the MAC can miss 2 DMA completion indications
 *  preventing further DMA write requests.  Workaround the issue by disabling
 *  the de-assertion of the clock request when in 1Gbps mode.
 *  Also, set appropriate Tx re-transmission timeouts for 10 and 100Half link
 *  speeds in order to avoid Tx hangs.
 **/
int32_t
em_k1_workaround_lpt_lp(struct em_hw *hw, boolean_t link)
{
	uint32_t fextnvm6 = E1000_READ_REG(hw, FEXTNVM6);
	uint32_t status = E1000_READ_REG(hw, STATUS);
	int32_t ret_val = E1000_SUCCESS;
	uint16_t reg;

	if (link && (status & E1000_STATUS_SPEED_1000)) {
		ret_val = em_read_kmrn_reg(hw, E1000_KMRNCTRLSTA_K1_CONFIG,
		    &reg);
		if (ret_val)
			return ret_val;

		ret_val = em_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_K1_CONFIG,
		    reg & ~E1000_KMRNCTRLSTA_K1_ENABLE);
		if (ret_val)
			return ret_val;

		usec_delay(10);

		E1000_WRITE_REG(hw, FEXTNVM6,
				fextnvm6 | E1000_FEXTNVM6_REQ_PLL_CLK);

		ret_val = em_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_K1_CONFIG,
		    reg);
	} else {
		/* clear FEXTNVM6 bit 8 on link down or 10/100 */
		fextnvm6 &= ~E1000_FEXTNVM6_REQ_PLL_CLK;

		if (!link || ((status & E1000_STATUS_SPEED_100) &&
			      (status & E1000_STATUS_FD)))
			goto update_fextnvm6;

		ret_val = em_read_phy_reg(hw, I217_INBAND_CTRL, &reg);
		if (ret_val)
			return ret_val;

		/* Clear link status transmit timeout */
		reg &= ~I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_MASK;

		if (status & E1000_STATUS_SPEED_100) {
			/* Set inband Tx timeout to 5x10us for 100Half */
			reg |= 5 << I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_SHIFT;

			/* Do not extend the K1 entry latency for 100Half */
			fextnvm6 &= ~E1000_FEXTNVM6_ENABLE_K1_ENTRY_CONDITION;
		} else {
			/* Set inband Tx timeout to 50x10us for 10Full/Half */
			reg |= 50 <<
			       I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_SHIFT;

			/* Extend the K1 entry latency for 10 Mbps */
			fextnvm6 |= E1000_FEXTNVM6_ENABLE_K1_ENTRY_CONDITION;
		}

		ret_val = em_write_phy_reg(hw, I217_INBAND_CTRL, reg);
		if (ret_val)
			return ret_val;

update_fextnvm6:
		E1000_WRITE_REG(hw, FEXTNVM6, fextnvm6);
	}

	return ret_val;

}


/***************************************************************************
 *  e1000_gate_hw_phy_config_ich8lan - disable PHY config via hardware
 *  @@hw:   pointer to the HW structure
 *  @@gate: boolean set to TRUE to gate, FALSE to ungate
 *
 *  Gate/ungate the automatic PHY configuration via hardware; perform
 *  the configuration via software instead.
 ***************************************************************************/
void
em_gate_hw_phy_config_ich8lan(struct em_hw *hw, boolean_t gate)
{
       uint32_t extcnf_ctrl;

       DEBUGFUNC("em_gate_hw_phy_config_ich8lan");

       if (hw->mac_type != em_pch2lan)
               return;

       extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);

       if (gate)
               extcnf_ctrl |= E1000_EXTCNF_CTRL_GATE_PHY_CFG;
       else
               extcnf_ctrl &= ~E1000_EXTCNF_CTRL_GATE_PHY_CFG;

       E1000_WRITE_REG(hw, EXTCNF_CTRL, extcnf_ctrl);
}

/***************************************************************************
 *  Configure K1 power state
 *
 *  Configure the K1 power state based on the provided parameter.
 *  Assumes semaphore already acquired.
 *
 *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)
 ***************************************************************************/
int32_t
em_configure_k1_ich8lan(struct em_hw *hw, boolean_t k1_enable)
{
	int32_t ret_val = E1000_SUCCESS;
	uint32_t ctrl_reg = 0;
	uint32_t ctrl_ext = 0;
	uint32_t reg = 0;
	uint16_t kmrn_reg = 0;

	ret_val = em_read_kmrn_reg(hw, E1000_KMRNCTRLSTA_K1_CONFIG,
	    &kmrn_reg);
	if (ret_val)
		goto out;

	if (k1_enable)
		kmrn_reg |= E1000_KMRNCTRLSTA_K1_ENABLE;
	else
		kmrn_reg &= ~E1000_KMRNCTRLSTA_K1_ENABLE;

	ret_val = em_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_K1_CONFIG,
	    kmrn_reg);
	if (ret_val)
		goto out;

	usec_delay(20);
	ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
	ctrl_reg = E1000_READ_REG(hw, CTRL);

	reg = ctrl_reg & ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
	reg |= E1000_CTRL_FRCSPD;
	E1000_WRITE_REG(hw, CTRL, reg);

	E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext | E1000_CTRL_EXT_SPD_BYPS);
	usec_delay(20);
	E1000_WRITE_REG(hw, CTRL, ctrl_reg);
	E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
	usec_delay(20);

out:
	return ret_val;
}

/***************************************************************************
 *  em_lv_phy_workarounds_ich8lan - A series of Phy workarounds to be
 *  done after every PHY reset.
 ***************************************************************************/
int32_t
em_lv_phy_workarounds_ich8lan(struct em_hw *hw)
{
       int32_t ret_val = E1000_SUCCESS;
       uint16_t swfw;

       DEBUGFUNC("e1000_lv_phy_workarounds_ich8lan");

       if (hw->mac_type != em_pch2lan)
               goto out;

       /* Set MDIO slow mode before any other MDIO access */
       ret_val = em_set_mdio_slow_mode_hv(hw);

       swfw = E1000_SWFW_PHY0_SM;
       ret_val = em_swfw_sync_acquire(hw, swfw);
       if (ret_val)
               goto out;
       ret_val = em_write_phy_reg(hw, I82579_EMI_ADDR,
                                              I82579_MSE_THRESHOLD);
       if (ret_val)
               goto release;
       /* set MSE higher to enable link to stay up when noise is high */
       ret_val = em_write_phy_reg(hw, I82579_EMI_DATA,
                                              0x0034);
       if (ret_val)
               goto release;
       ret_val = em_write_phy_reg(hw, I82579_EMI_ADDR,
                                              I82579_MSE_LINK_DOWN);
       if (ret_val)
               goto release;
       /* drop link after 5 times MSE threshold was reached */
       ret_val = em_write_phy_reg(hw, I82579_EMI_DATA,
                                              0x0005);
release:
       em_swfw_sync_release(hw, swfw);

out:
       return ret_val;
}

int32_t
em_set_eee_i350(struct em_hw *hw) 
{
	int32_t ret_val = E1000_SUCCESS;
	uint32_t ipcnfg, eeer;

	if ((hw->mac_type < em_i350) ||
	    (hw->media_type != em_media_type_copper))
		goto out;
	ipcnfg = EM_READ_REG(hw, E1000_IPCNFG);
	eeer = EM_READ_REG(hw, E1000_EEER);

	if (hw->eee_enable) {
		ipcnfg |= (E1000_IPCNFG_EEE_1G_AN | E1000_IPCNFG_EEE_100M_AN);
		eeer |= (E1000_EEER_TX_LPI_EN | E1000_EEER_RX_LPI_EN |
		    E1000_EEER_LPI_FC);
	} else {
		ipcnfg &= ~(E1000_IPCNFG_EEE_1G_AN | E1000_IPCNFG_EEE_100M_AN);
		eeer &= ~(E1000_EEER_TX_LPI_EN | E1000_EEER_RX_LPI_EN |
		    E1000_EEER_LPI_FC);
	}
	EM_WRITE_REG(hw, E1000_IPCNFG, ipcnfg);
	EM_WRITE_REG(hw, E1000_EEER, eeer);
	EM_READ_REG(hw, E1000_IPCNFG);
	EM_READ_REG(hw, E1000_EEER);
out:
	return ret_val;
}

/***************************************************************************
 *  em_set_eee_pchlan - Enable/disable EEE support
 *  @@hw: pointer to the HW structure
 *
 *  Enable/disable EEE based on setting in dev_spec structure.  The bits in
 *  the LPI Control register will remain set only if/when link is up.
 ***************************************************************************/
int32_t
em_set_eee_pchlan(struct em_hw *hw)
{
       int32_t ret_val = E1000_SUCCESS;
       uint16_t phy_reg;

       DEBUGFUNC("em_set_eee_pchlan");

       if (hw->phy_type != em_phy_82579 &&
	   hw->phy_type != em_phy_i217)
               goto out;

       ret_val = em_read_phy_reg(hw, I82579_LPI_CTRL, &phy_reg);
       if (ret_val)
               goto out;

       if (hw->eee_enable)
               phy_reg &= ~I82579_LPI_CTRL_ENABLE_MASK;
       else
               phy_reg |= I82579_LPI_CTRL_ENABLE_MASK;

       ret_val = em_write_phy_reg(hw, I82579_LPI_CTRL, phy_reg);
out:
       return ret_val;
}

/**
 *  em_initialize_M88E1512_phy - Initialize M88E1512 PHY
 *  @@hw: pointer to the HW structure
 *
 *  Initialize Marvell 1512 to work correctly with Avoton.
 **/
int32_t
em_initialize_M88E1512_phy(struct em_hw *hw)
{
	int32_t ret_val = E1000_SUCCESS;

	DEBUGFUNC("e1000_initialize_M88E1512_phy");

	/* Check if this is correct PHY. */
	if (hw->phy_id != M88E1512_E_PHY_ID)
		goto out;

	/* Switch to PHY page 0xFF. */
	ret_val = em_write_phy_reg(hw, M88E1543_PAGE_ADDR, 0x00FF);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, M88E1512_CFG_REG_2, 0x214B);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, M88E1512_CFG_REG_1, 0x2144);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, M88E1512_CFG_REG_2, 0x0C28);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, M88E1512_CFG_REG_1, 0x2146);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, M88E1512_CFG_REG_2, 0xB233);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, M88E1512_CFG_REG_1, 0x214D);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, M88E1512_CFG_REG_2, 0xCC0C);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, M88E1512_CFG_REG_1, 0x2159);
	if (ret_val)
		goto out;

	/* Switch to PHY page 0xFB. */
	ret_val = em_write_phy_reg(hw, M88E1543_PAGE_ADDR, 0x00FB);
	if (ret_val)
		goto out;

	ret_val = em_write_phy_reg(hw, M88E1512_CFG_REG_3, 0x000D);
	if (ret_val)
		goto out;

	/* Switch to PHY page 0x12. */
	ret_val = em_write_phy_reg(hw, M88E1543_PAGE_ADDR, 0x12);
	if (ret_val)
		goto out;

	/* Change mode to SGMII-to-Copper */
	ret_val = em_write_phy_reg(hw, M88E1512_MODE, 0x8001);
	if (ret_val)
		goto out;

	/* Return the PHY to page 0. */
	ret_val = em_write_phy_reg(hw, M88E1543_PAGE_ADDR, 0);
	if (ret_val)
		goto out;

	ret_val = em_phy_hw_reset(hw);
	if (ret_val) {
		DEBUGOUT("Error committing the PHY changes\n");
		return ret_val;
	}

	msec_delay(1000);
out:
	return ret_val;
}

@


1.93
log
@Match the Kaby Lake and Lewisburg (Skylake-EP PCH) MACs with I219 PHYs.
Expanded version of a diff from claudio@@ who tested on x270 ok kettenis@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.92 2016/08/23 04:04:23 jsg Exp $ */
d96 2
d1199 186
d1446 1
@


1.92
log
@remove duplicated test for em_82574
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.91 2016/02/18 14:24:39 bluhm Exp $ */
d618 5
@


1.91
log
@Add support for the Intel i219 network chip to the em(4) driver.
from Christian Ehrhardt; input jsg@@; OK deraadt@@ sthen@@ mpi@@ jsg@@
tested by sthen@@ jca@@ benno@@ bluhm@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.90 2015/12/14 03:04:10 mmcc Exp $ */
a5541 1
	    hw->mac_type == em_82574 ||
@


1.90
log
@"harware" -> "hardware"
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.89 2015/11/24 17:11:39 mpi Exp $ */
d109 1
d614 6
d650 1
d747 1
d905 1
d1154 1
d1229 2
a1230 1
		hw->mac_type == em_pch_lpt) {
d1441 1
d1573 1
d2024 2
a2025 1
		hw->mac_type == em_pch_lpt)
d2297 2
a2298 1
		hw->mac_type == em_pch_lpt)
d2769 1
d3937 2
a3938 1
			    hw->mac_type == em_pch_lpt) {
d4723 2
a4724 1
		hw->mac_type == em_pch_lpt)
d4837 1
a4837 1
		if (hw->mac_type == em_pch2lan || hw->mac_type == em_pch_lpt)
d4888 2
a4889 1
		hw->mac_type == em_pch_lpt)
d4989 1
a4989 1
		if (hw->mac_type == em_pch2lan || hw->mac_type == em_pch_lpt)
d5478 1
d5807 27
d6521 1
d7183 1
a7183 1
	if (hw->mac_type == em_pch_lpt || hw->mac_type == em_pch2lan)
d7740 1
a7740 1
	    (hw->mac_type != em_pch2lan && hw->mac_type != em_pch_lpt))
d7882 1
d9075 1
d9434 1
d9441 32
d9519 86
d9631 3
d9738 6
a9743 1
	hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS);
d9755 6
a9760 2

	E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS, hsfsts.regval);
d9780 6
a9785 2
		E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS,
		    hsfsts.regval);
d9793 6
a9798 2
			hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw,
			    ICH_FLASH_HSFSTS);
d9811 6
a9816 2
			E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS,
			    hsfsts.regval);
d9836 1
d9838 6
a9843 1
	hsflctl.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL);
d9845 7
a9851 1
	E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL, hsflctl.regval);
d9855 6
a9860 2
		hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw,
		    ICH_FLASH_HSFSTS);
d9919 1
a9919 1
		E1000_WRITE_ICH_FLASH_REG(hw, ICH_FLASH_FADDR,
d9961 77
d10042 1
a10042 1
 * index - The index of the byte/word to read.
d10058 2
d10085 1
a10085 1
		E1000_WRITE_ICH_FLASH_REG(hw, ICH_FLASH_FADDR,
d10093 1
a10093 1
		E1000_WRITE_ICH_FLASH_REG(hw, ICH_FLASH_FDATA0, flash_data);
d10136 5
a10140 1
	status = em_read_ich8_data(hw, index, 1, &word);
d10200 15
d10341 1
a10341 1
			E1000_WRITE_ICH_FLASH_REG(hw, ICH_FLASH_FADDR,
d10541 2
a10542 1
	    hw->mac_type == em_pch_lpt)
@


1.89
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.88 2015/09/12 02:38:14 jsg Exp $ */
d9582 1
a9582 1
	 * be changed in the hardware so that it is 1 after harware reset,
@


1.88
log
@Add support for the 88E1512/88E1514 phys using the 1512 init sequence
from the Intel code in FreeBSD.

Tested by Paul Levlin on a machine with I354.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.87 2015/08/05 18:31:14 sf Exp $ */
a48 1
#include <net/if_dl.h>
@


1.87
log
@Fix i217 PHY initialization

Add a workaround for a hardware bug were receiving of packets would stop
until the battery of the laptop was removed. The problem could be
triggered if the LAN cable was plugged in after the PHY had already been
initialized.

The workaround is already present in FreeBSD (e1000_ich8lan.c:
e1000_lv_jumbo_workaround_ich8lan()) and Linux. The commit messages of
b20a7744 and da1e2046 in Linux have some more details.

Found and ported from FreeBSD by Valentin Dornauer.

Tested by many.

ok deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.86 2015/07/17 16:56:34 yuo Exp $ */
d185 1
a185 1

d232 1
d5276 6
d5420 2
a5421 1
		    hw->phy_id == M88E1543_E_PHY_ID) {
d10905 89
@


1.86
log
@fix typo.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.85 2015/06/04 18:33:41 dms Exp $ */
d94 1
d7022 90
d7126 5
@


1.85
log
@Add support for em(4) on Teak 3020, a Tolopai (EP80579)
based devices. This introduces Realtek PHY into em driver
code and is only a temporary solution to the problem.

OK deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.84 2015/05/12 02:33:39 jsg Exp $ */
d2536 1
a2536 1
		printf("Unable to write RGEPHY_CR register\n");
d2543 1
a2543 1
		printf("Unable to read RGEPHY_SRregister\n");
@


1.84
log
@The i211 does not support an external EEPROM only a OTP
Internal Non-Volatile Memory (iNVM).  Add support for reading
words out of it instead of an EEPROM.

From Patrick Wildt with some more offsets added.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.83 2015/03/14 03:38:48 jsg Exp $ */
d63 2
d271 3
d617 1
d622 1
d626 4
d721 4
a724 1
		hw->media_type = em_media_type_oem;
d2494 128
d2820 4
d3200 22
d3377 19
d3969 1
a3969 1
		if (hw->mac_type >= em_82544 && hw->mac_type != em_icp_xxxx)
d3971 1
a3971 1
		else {
d5456 2
d7849 4
d9157 2
@


1.83
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.82 2014/12/22 02:28:52 tedu Exp $ */
d115 3
d5528 6
d5997 1
d6010 5
d6199 22
d9766 111
@


1.82
log
@unifdef INET
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.81 2014/11/05 15:30:17 claudio Exp $ */
a58 1
#include <dev/pci/pcidevs.h>
@


1.81
log
@Implement yet another workaround for the k1 em(4)'s. This time for
the i218 which is used in many modern laptops like the X240. This
seems to stop the watchdog timeouts triggered by heavy traffic on
such systems.
Tested by myself, phessler, blambert and Donovan Watteau
OK deraadt, brad
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.80 2014/07/22 13:12:11 mpi Exp $ */
a51 1
#ifdef INET
a53 1
#endif
@


1.80
log
@Fewer <netinet/in_systm.h>
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.79 2014/03/10 04:09:53 jsg Exp $ */
d166 1
d3713 10
d10199 78
@


1.79
log
@match on 82580 quad fiber and add untested support for
DH89XX/Cave Creek PCH which seem to function like a 82580 with some
external Marvell PHYs.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.78 2014/03/10 03:08:34 jsg Exp $ */
a53 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.78
log
@match on more i217/i218 variants
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.77 2014/02/22 04:41:31 chris Exp $ */
d228 1
d231 1
d519 1
d523 4
d5213 1
d5215 1
@


1.77
log
@basic i210/i211 support (improved after looking at gollo@@ i210 diff on misc)

tested on Supermicro X10SLL

ok jsg@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.76 2014/02/17 07:02:45 jsg Exp $ */
d595 4
@


1.76
log
@Add initial support for i354 MAC and M88E1543 PHY.
Currently treated the same as i350, i354 specific EEE settings
and 2.5Gb backplane connections not properly handled yet.

Tested by Andrew Lester on a Supermicro A1SRi-2758F.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.75 2013/11/27 01:13:10 jsg Exp $ */
d229 1
d523 11
d627 1
d666 1
a666 1
	    hw->mac_type == em_i350) {
d771 1
a771 1
	    hw->mac_type == em_i350) {
d1027 1
a1027 1
	if (hw->mac_type == em_i350)
d1396 1
d5198 1
d5201 1
d5338 2
a5339 1
	if (hw->mac_type == em_82580 || hw->mac_type == em_i350) {
d5481 1
d6810 2
d7467 1
d8665 1
@


1.75
log
@use a macro when testing for an ich8 family mac type
no binary change
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.74 2013/11/21 14:44:37 jsg Exp $ */
d228 1
d527 3
d5185 3
a5187 1
		if (hw->phy_id == I82580_I_PHY_ID || hw->phy_id == I350_I_PHY_ID) {
@


1.74
log
@Initial support for the integrated Lynx Point and Lynx Point LP Ethernet
with external i217 and i218 PHYs.
Requires a changed way of detecting the eeprom flash bank from FreeBSD
as suggested by Masanobu SAITOH.  Thanks to everyone who tested.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.73 2013/08/07 01:06:34 bluhm Exp $ */
d985 1
a985 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt) {
d1234 1
a1234 6
	if (hw->mac_type != em_ich8lan &&
	    hw->mac_type != em_ich9lan &&
	    hw->mac_type != em_ich10lan &&
	    hw->mac_type != em_pchlan &&
	    hw->mac_type != em_pch2lan &&
	    hw->mac_type != em_pch_lpt) {
d1267 1
a1267 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt)
d1321 1
a1321 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt)
d1409 1
a1409 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt) {
d1605 1
a1605 6
	if (hw->mac_type != em_ich8lan &&
	    hw->mac_type != em_ich9lan &&
	    hw->mac_type != em_ich10lan &&
	    hw->mac_type != em_pchlan &&
	    hw->mac_type != em_pch2lan &&
	    hw->mac_type != em_pch_lpt) {
d6123 1
a6123 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt)
d6184 1
a6184 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt) {
d6780 1
a6780 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt)
d6831 1
a6831 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt)
d6853 1
a6853 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt)
d6912 1
a6912 6
		if (hw->mac_type == em_ich8lan ||
		    hw->mac_type == em_ich9lan ||
		    hw->mac_type == em_ich10lan ||
		    hw->mac_type == em_pchlan ||
		    hw->mac_type == em_pch2lan ||
		    hw->mac_type == em_pch_lpt) {
d6923 1
a6923 6
		if (hw->mac_type == em_ich8lan ||
		    hw->mac_type == em_ich9lan ||
		    hw->mac_type == em_ich10lan ||
		    hw->mac_type == em_pchlan ||
		    hw->mac_type == em_pch2lan ||
		    hw->mac_type == em_pch_lpt) {
d6934 1
a6934 6
		if (hw->mac_type == em_ich8lan ||
		    hw->mac_type == em_ich9lan ||
		    hw->mac_type == em_ich10lan ||
		    hw->mac_type == em_pchlan ||
		    hw->mac_type == em_pch2lan ||
		    hw->mac_type == em_pch_lpt) {
d6945 1
a6945 6
		if (hw->mac_type == em_ich8lan ||
		    hw->mac_type == em_ich9lan ||
		    hw->mac_type == em_ich10lan ||
		    hw->mac_type == em_pchlan ||
		    hw->mac_type == em_pch2lan ||
		    hw->mac_type == em_pch_lpt) {
d6958 1
a6958 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt)
d6986 1
a6986 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt)
d7077 1
a7077 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt)
d7228 1
a7228 6
	if (hw->mac_type != em_ich8lan &&
	    hw->mac_type != em_ich9lan &&
	    hw->mac_type != em_ich10lan &&
	    hw->mac_type != em_pchlan &&
	    hw->mac_type != em_pch2lan &&
	    hw->mac_type != em_pch_lpt) {
d7256 1
a7256 6
	if (hw->mac_type != em_ich8lan &&
	    hw->mac_type != em_ich9lan &&
	    hw->mac_type != em_ich10lan &&
	    hw->mac_type != em_pchlan &&
	    hw->mac_type != em_pch2lan &&
	    hw->mac_type != em_pch_lpt) {
d8029 1
a8029 6
	} else if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt) {
d8052 1
a8052 6
			if (hw->mac_type == em_ich8lan ||
			    hw->mac_type == em_ich9lan ||
			    hw->mac_type == em_ich10lan ||
			    hw->mac_type == em_pchlan ||
			    hw->mac_type == em_pch2lan ||
			    hw->mac_type == em_pch_lpt) {
d8104 1
a8104 6
			if (hw->mac_type == em_ich8lan ||
			    hw->mac_type == em_ich9lan ||
			    hw->mac_type == em_ich10lan ||
			    hw->mac_type == em_pchlan ||
			    hw->mac_type == em_pch2lan ||
			    hw->mac_type == em_pch_lpt) {
d8156 1
a8156 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt) {
d8166 1
a8166 6
		if (hw->mac_type == em_ich8lan ||
		    hw->mac_type == em_ich9lan ||
		    hw->mac_type == em_ich10lan ||
		    hw->mac_type == em_pchlan ||
		    hw->mac_type == em_pch2lan ||
		    hw->mac_type == em_pch_lpt) {
d8206 1
a8206 6
		if (hw->mac_type == em_ich8lan ||
		    hw->mac_type == em_ich9lan ||
		    hw->mac_type == em_ich10lan ||
		    hw->mac_type == em_pchlan ||
		    hw->mac_type == em_pch2lan ||
		    hw->mac_type == em_pch_lpt) {
d8395 1
a8395 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt) {
d8880 1
a8880 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt) {
d8918 1
a8918 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt) {
d8943 1
a8943 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt) {
d8979 1
a8979 6
	if (hw->mac_type == em_ich8lan ||
	    hw->mac_type == em_ich9lan ||
	    hw->mac_type == em_ich10lan ||
	    hw->mac_type == em_pchlan ||
	    hw->mac_type == em_pch2lan ||
	    hw->mac_type == em_pch_lpt) {
@


1.73
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.72 2013/04/30 07:07:50 jsg Exp $ */
d182 1
d259 3
d575 6
d604 1
d696 1
d853 1
d989 2
a990 1
	    hw->mac_type == em_pch2lan) {
d1106 1
d1180 2
a1181 1
		hw->mac_type == em_pch2lan) {
d1243 2
a1244 1
	    hw->mac_type != em_pch2lan) {
d1281 2
a1282 1
	    hw->mac_type == em_pch2lan)
d1340 2
a1341 1
	    hw->mac_type == em_pch2lan)
d1405 1
d1433 2
a1434 1
	    hw->mac_type == em_pch2lan) {
d1541 1
d1634 2
a1635 1
	    hw->mac_type != em_pch2lan) {
d1644 2
a1645 1
	    hw->phy_type == em_phy_82579) {
d1996 2
a1997 1
		hw->mac_type == em_pch2lan)
d2268 2
a2269 1
		hw->mac_type == em_pch2lan)
d2611 1
d2671 2
a2672 1
		hw->phy_type == em_phy_82579) {
d3723 2
a3724 1
			if (hw->mac_type == em_pch2lan) {
d4508 2
a4509 1
		hw->mac_type == em_pch2lan)
d4622 1
a4622 1
		if (hw->mac_type == em_pch2lan)
d4672 2
a4673 1
		hw->mac_type == em_pch2lan)
d4773 1
a4773 1
		if (hw->mac_type == em_pch2lan)
d4952 1
a4952 1
	if ((hw->mac_type != em_pchlan) && (hw->mac_type != em_pch2lan))
d4959 1
a4959 1
	if (hw->mac_type != em_pch2lan) {
d5053 1
a5053 1
	if (hw->phy_type == em_phy_igp || hw->phy_type == em_phy_igp_2) {
d5055 2
a5056 1
	} else if (hw->mac_type == em_pchlan) {
a5059 5

		ret_val = em_oem_bits_config_pchlan(hw, TRUE);
		if (ret_val)
			return ret_val;

d5064 3
a5066 1

d5070 1
d5072 5
a5076 5
		/* Ungate automatic PHY configuration on non-managed 82579 */
		if  (!(E1000_READ_REG(hw, FWSM) & E1000_FWSM_FW_VALID)) {
			msec_delay(10);
			em_gate_hw_phy_config_ich8lan(hw, FALSE);
		}
d5248 4
d5532 1
d6157 2
a6158 1
	    hw->mac_type == em_pch2lan)
d6223 5
a6227 1
	    hw->mac_type == em_pch2lan) {
d6234 14
a6247 4
		em_read_eeprom(hw, 0x19, 1, &eeprom_data);
		if ((eeprom_data & 0x40) == 0) {
			eeprom_data |= 0x40;
			em_write_eeprom(hw, 0x19, 1, &eeprom_data);
d6655 1
a6655 1
					high_byte = E1000_ICH_NVM_SIG_MASK |
d6824 2
a6825 1
	    hw->mac_type == em_pch2lan)
d6880 2
a6881 1
	    hw->mac_type == em_pch2lan)
d6907 2
a6908 1
	    hw->mac_type == em_pch2lan)
d6971 2
a6972 1
		    hw->mac_type == em_pch2lan) {
d6987 2
a6988 1
		    hw->mac_type == em_pch2lan) {
d7003 2
a7004 1
		    hw->mac_type == em_pch2lan) {
d7019 2
a7020 1
		    hw->mac_type == em_pch2lan) {
d7037 2
a7038 1
	    hw->mac_type == em_pch2lan)
d7070 2
a7071 1
	    hw->mac_type == em_pch2lan)
d7166 2
a7167 1
	    hw->mac_type == em_pch2lan)
d7322 2
a7323 1
	    hw->mac_type != em_pch2lan) {
d7355 2
a7356 1
	    hw->mac_type != em_pch2lan) {
d7393 2
a7394 1
	    hw->phy_type == em_phy_82579) {
d7417 1
a7417 1
	    hw->mac_type != em_pch2lan)
d7557 1
d8133 2
a8134 1
	    hw->mac_type == em_pch2lan) {
d8161 2
a8162 1
			    hw->mac_type == em_pch2lan) {
d8218 2
a8219 1
			    hw->mac_type == em_pch2lan) {
d8275 2
a8276 1
	    hw->mac_type == em_pch2lan) {
d8290 2
a8291 1
		    hw->mac_type == em_pch2lan) {
d8335 2
a8336 1
		    hw->mac_type == em_pch2lan) {
d8529 2
a8530 1
	    hw->mac_type == em_pch2lan) {
d8779 1
d9019 2
a9020 1
	    hw->mac_type == em_pch2lan) {
d9062 2
a9063 1
	    hw->mac_type == em_pch2lan) {
d9092 2
a9093 1
	    hw->mac_type == em_pch2lan) {
d9133 2
a9134 1
	    hw->mac_type == em_pch2lan) {
d9142 66
d9233 11
a9243 2
	/* Value of bit 22 corresponds to the flash bank we're on. */
	flash_bank = (E1000_READ_REG(hw, EECD) & E1000_EECD_SEC1VAL) ? 1 : 0;
a9249 4
	error = em_get_software_flag(hw);
	if (error != E1000_SUCCESS)
		return error;

d9894 2
a9895 1
	    hw->mac_type == em_pch2lan)
d10472 2
a10473 1
       if (hw->phy_type != em_phy_82579)
@


1.72
log
@Handle newer fiber adapters the same way as 82575/82576,
required to make 82580(i340) and i350 based adapters work.

Tested by Rogier Krieger on an i350-F2.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.71 2012/12/05 23:20:20 deraadt Exp $ */
a54 1
#include <netinet/in_var.h>
@


1.71
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.70 2012/11/26 01:17:41 jsg Exp $ */
d1449 1
a1449 1
	    hw->mac_type == em_82575)
d1703 1
a1703 1
	    hw->mac_type == em_82575)
d1706 1
a1706 1
	if (hw->mac_type == em_82575)
d1727 1
a1727 1
	if (hw->mac_type == em_82575) {
d3614 1
a3614 1
	if (hw->mac_type == em_82575 &&
d3954 1
a3954 1
	if (hw->mac_type == em_82575 && hw->media_type != em_media_type_copper)
d5287 1
a5287 1
	    hw->mac_type == em_82575) {
@


1.70
log
@Bring in some more pch2/82579 bits from the Intel code in FreeBSD:

- modify em_oem_bits_config_pchlan for pch2
- sync pch2 use of gating/ungating hardware phy config
- add 82579 phy workarounds
- enable Energy Efficient Ethernet on 82579

From Yoshihisa Matsushita based on an earlier diff of mine.
Fixes problems some people were seeing with gigabit autoneg on pch2.

tested by naddy@@ & jasper@@, ok mikeb@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.69 2012/05/17 10:45:17 jsg Exp $ */
a37 5

#if 0
#include <sys/cdefs.h>
__FBSDID("$FreeBSD: if_em_hw.c,v 1.16 2005/05/26 23:32:02 tackerman Exp $");
#endif
@


1.69
log
@Add support for i350 based devices, based in part on Intel code
in FreeBSD.  Workaround the apparently undocumented errata where the
CRC is always stripped whether asked to or not, and take the FreeBSD
workaround for a known errata when clearing the vlan filter.

Thanks to Jens A. Griepentrog for donating a card.

ok dlg@@ mikeb@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.68 2011/11/29 04:10:59 jsg Exp $ */
a161 1
static void em_pch2lan_disable_hw_config(struct em_hw *, boolean_t);
d170 1
d175 1
d186 3
a188 1
int32_t		em_set_eee_i350(struct em_hw *); 
d571 1
d855 4
a858 1

d861 1
a861 1
				em_pch2lan_disable_hw_config(hw, TRUE);
d867 8
a874 1
		break;
d887 1
a887 1
			ret_val = em_set_mdio_slow_mode_hv(hw);
d1190 1
d1192 1
a1192 1
			em_pch2lan_disable_hw_config(hw, TRUE);
d1203 1
d1206 1
a1206 1
			em_pch2lan_disable_hw_config(hw, FALSE);
d3700 7
d4927 1
a4927 1
	if (hw->mac_type != em_pchlan)
d4934 5
a4938 3
	mac_reg = E1000_READ_REG(hw, EXTCNF_CTRL);
	if (mac_reg & E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE)
		goto out;
d4958 4
d4963 2
a4964 1
		if (mac_reg & E1000_PHY_CTRL_NOND0A_GBE_DISABLE)
d4967 2
a4968 1
		if (mac_reg & E1000_PHY_CTRL_NOND0A_LPLU)
d4971 1
a4971 3
	/* Restart auto-neg to activate the bits */
	if (!em_check_phy_reset_block(hw))
		oem_reg |= HV_OEM_BITS_RESTART_AN;
d5028 1
a5028 1
	if (hw->phy_type == em_phy_igp || hw->phy_type == em_phy_igp_2)
d5030 1
a5030 1
	else if (hw->mac_type == em_pchlan) {
d5038 7
a5044 3
	}
	else if (hw->mac_type == em_pch2lan) {
		ret_val = em_set_mdio_slow_mode_hv(hw);
d5047 6
a8618 18
/*
 *  Set whether the PHY self-configures itself in hardware
 */
static void em_pch2lan_disable_hw_config(struct em_hw *hw, boolean_t sc)
{
	uint32_t ctrl_ext;
	DEBUGFUNC("em_pch2lan_disable_hw_config");

	ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);

	if (sc)
		ctrl_ext |= E1000_CTRL_EXT_SDP3_DATA;
	else
		ctrl_ext &= ~E1000_CTRL_EXT_SDP3_DATA;

	E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
}

d10164 28
d10241 45
d10314 33
@


1.68
log
@Limit the kumeran errata to a specific mac/phy combo as done in the Intel
code instead of testing only the phy.  Fixes autoneg on ich9.

From Jonathan Perkin
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.67 2011/10/19 07:29:42 jsg Exp $ */
d85 1
d185 1
d262 1
d520 9
d602 1
d639 2
a640 1
	if (hw->mac_type == em_82575 || hw->mac_type == em_82580) {
d743 2
a744 1
        if (hw->mac_type == em_82575 || hw->mac_type == em_82580) {
d974 1
a974 1
	if (hw->mac_type == em_82580) {
d993 3
d1220 4
a1223 1
		em_clear_vfta(hw);
d1370 1
d5147 2
a5148 1
		if (hw->phy_id == I82580_I_PHY_ID) {
d5279 1
a5279 1
	if (hw->mac_type == em_82580) {
d5421 1
d6676 1
a6676 1
	} else if (hw->mac_type == em_82580) {
d6747 2
d7105 18
d7445 1
d8687 1
d8742 1
d10188 29
@


1.67
log
@A missing part of an if statement meant we were writing out
garbage when changing snoop related registers on pch2.
Rework the code to remove the duplication and hopefully make
this sort of thing less likely in future.

Found and debugged by pedro. ok markus@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.66 2011/10/05 02:52:10 jsg Exp $ */
d3976 3
a3978 1
	if ((hw->phy_type == em_phy_igp_3) && (*speed == SPEED_1000)) {
@


1.66
log
@Add the remaining parts of support for 82580 based devices such as
the Intel I340-T4 and HP NC365T and simplify some of the multi port
handling while here.

Thanks to fredrik danerklint for donating a card, Linden Varley
for setting up a test system and everyone who made sure this
didn't break their existing em setups.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.65 2011/05/02 18:16:58 dhill Exp $ */
a1376 6
	if (hw->mac_type == em_ich8lan)
		snoop = PCI_EX_82566_SNOOP_ALL;
	else if (hw->mac_type == em_ich9lan ||
		 hw->mac_type == em_ich10lan ||
		 hw->mac_type == em_pchlan)
		snoop = (u_int32_t) ~ (PCI_EX_NO_SNOOP_ALL);
d1381 6
a1386 1
	    hw->mac_type == em_pch2lan)
d1388 1
@


1.65
log
@remove workaround found in FreeBSD driver but not in Intel's official
driver.

Fixes 82578DC from only being able to negotiate at 10baseT.

ok jsg@@
please commit mikeb@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.64 2011/05/02 12:25:42 jsg Exp $ */
d958 20
a4597 1
	uint16_t swfw;
d4604 1
a4604 7
	if (((hw->mac_type == em_80003es2lan) || (hw->mac_type == em_82575)) &&
	    (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
		swfw = E1000_SWFW_PHY1_SM;
	} else {
		swfw = E1000_SWFW_PHY0_SM;
	}
	if (em_swfw_sync_acquire(hw, swfw))
d4614 1
a4614 1
			em_swfw_sync_release(hw, swfw);
d4639 1
a4639 1
				em_swfw_sync_release(hw, swfw);
d4655 1
a4655 1
	em_swfw_sync_release(hw, swfw);
a4734 1
	uint16_t swfw;
d4737 1
a4737 7
	if ((hw->mac_type == em_80003es2lan) &&
	    (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
		swfw = E1000_SWFW_PHY1_SM;
	} else {
		swfw = E1000_SWFW_PHY0_SM;
	}
	if (em_swfw_sync_acquire(hw, swfw))
d4752 1
a4752 1
	em_swfw_sync_release(hw, swfw);
a4759 1
	uint16_t swfw;
d4762 1
a4762 8
	if ((hw->mac_type == em_80003es2lan) &&
	    (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
		swfw = E1000_SWFW_PHY1_SM;
	} else {
		swfw = E1000_SWFW_PHY0_SM;
	}

	if (em_swfw_sync_acquire(hw, swfw))
d4771 1
a4771 1
	em_swfw_sync_release(hw, swfw);
a4785 1
	uint16_t swfw;
d4798 1
a4798 8
		if (((hw->mac_type == em_80003es2lan) ||
			(hw->mac_type == em_82575)) &&
		    (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
			swfw = E1000_SWFW_PHY1_SM;
		} else {
			swfw = E1000_SWFW_PHY0_SM;
		}
		if (em_swfw_sync_acquire(hw, swfw)) {
d4824 1
a4824 1
		em_swfw_sync_release(hw, swfw);
d5123 8
a5130 1
		if (hw->phy_id == I82580_I_PHY_ID)
d5132 1
d5253 8
d6650 2
a6670 1
	case em_82580:
d8684 1
a8684 1
	uint32_t cfg_mask = E1000_EEPROM_CFG_DONE;
d8693 12
a8704 3
		/* Separate *_CFG_DONE_* bit for each port */
		if (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)
			cfg_mask = E1000_EEPROM_CFG_DONE_PORT_1;
@


1.64
log
@Add a workaround for an 82579 hardware bug that can result in
lost rx packets between the mac and phy.

From Laurence Tratt
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.63 2011/04/22 10:09:57 jsg Exp $ */
a9865 14
		if (hw->revision_id < 3) {
			/* PHY config */
			ret_val = em_write_phy_reg(hw, (1 << 6) | 0x29,
						   0x66C0);
			if (ret_val)
				goto out;

			/* PHY config */
			ret_val = em_write_phy_reg(hw, (1 << 6) | 0x1E,
						   0xFFFF);
			if (ret_val)
				goto out;
		}

@


1.63
log
@Add support for PCH2 (Sandy Bridge) MAC with 82579 PHY.
From Laurence Tratt.

ok claudio@@ deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.62 2011/04/14 21:14:28 jsg Exp $ */
d172 1
d3630 6
d10061 28
@


1.62
log
@the mechanical part of 82580 support, more to come
ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.61 2011/04/04 03:49:32 william Exp $ */
d161 1
d255 3
d556 4
d582 1
d671 1
d826 1
d835 5
d850 11
a860 2
	if (hw->mac_type == em_pchlan) {
		em_hv_phy_workarounds_ich8lan(hw);
d951 2
a952 1
	    hw->mac_type == em_pchlan) {
d970 2
d1044 1
d1107 1
d1117 2
a1118 1
	if (hw->mac_type == em_pchlan) {
d1125 2
a1126 1
		if ((E1000_READ_REG(hw, FWSM) & E1000_FWSM_FW_VALID) == 0) {
d1136 4
d1149 4
d1177 2
a1178 1
	    hw->mac_type != em_pchlan) {
d1211 2
a1212 1
	    hw->mac_type == em_pchlan)
d1269 2
a1270 1
	    hw->mac_type == em_pchlan)
d1332 1
d1365 2
a1366 1
	    hw->mac_type == em_pchlan)
d1466 1
d1558 2
a1559 1
	    hw->mac_type != em_pchlan) {
d1567 2
a1568 1
	    hw->phy_type == em_phy_82578) {
d1918 2
a1919 1
	if (hw->mac_type == em_pchlan)
d2189 2
a2190 1
	if (hw->mac_type == em_pchlan)
d2531 1
d2590 2
a2591 1
	} else if (hw->phy_type == em_phy_82577) {
d4410 2
a4411 1
	if (hw->mac_type == em_pchlan)
d4523 3
d4574 2
a4575 1
	if (hw->mac_type == em_pchlan)
d4680 3
d4989 5
d5137 1
d5152 2
d5425 1
d6049 2
a6050 1
	    hw->mac_type == em_pchlan)
d6114 2
a6115 1
	    hw->mac_type == em_pchlan) {
d6700 2
a6701 1
	    hw->mac_type == em_pchlan)
d6753 2
a6754 1
	    hw->mac_type == em_pchlan)
d6779 2
a6780 1
	    hw->mac_type == em_pchlan)
d6842 2
a6843 1
		    hw->mac_type == em_pchlan) {
d6857 2
a6858 1
		    hw->mac_type == em_pchlan) {
d6872 2
a6873 1
		    hw->mac_type == em_pchlan) {
d6887 2
a6888 1
		    hw->mac_type == em_pchlan) {
d6904 2
a6905 1
	    hw->mac_type == em_pchlan)
d6936 2
a6937 1
	    hw->mac_type == em_pchlan)
d7031 2
a7032 1
	    hw->mac_type == em_pchlan)
d7168 2
a7169 1
	    hw->mac_type != em_pchlan) {
d7200 2
a7201 1
	    hw->mac_type != em_pchlan) {
d7237 2
a7238 1
	    hw->phy_type == em_phy_82578) {
d7260 2
a7261 1
	    hw->mac_type == em_pchlan)
d7399 1
d7974 2
a7975 1
	    hw->mac_type == em_pchlan) {
d8001 2
a8002 1
			    hw->mac_type == em_pchlan) {
d8057 2
a8058 1
			    hw->mac_type == em_pchlan) {
d8113 2
a8114 1
	    hw->mac_type == em_pchlan) {
d8127 2
a8128 1
		    hw->mac_type == em_pchlan) {
d8171 2
a8172 1
		    hw->mac_type == em_pchlan) {
d8364 2
a8365 1
	    hw->mac_type == em_pchlan) {
d8519 18
d8630 1
d8859 2
a8860 1
	    hw->mac_type == em_pchlan) {
d8901 2
a8902 1
	    hw->mac_type == em_pchlan) {
d8930 2
a8931 1
	    hw->mac_type == em_pchlan) {
d8970 2
a8971 1
	    hw->mac_type == em_pchlan) {
d9657 4
a9660 3
	if ((hw->device_id == E1000_DEV_ID_ICH8_IGP_M_AMT) ||
	    (hw->device_id == E1000_DEV_ID_ICH8_IGP_M) ||
	    (hw->mac_type == em_pchlan))
d9781 1
d9803 1
@


1.61
log
@The backplane version of the 82575EB has no link state -- it's always
up.  From FreeBSD.

ok jsg claudio
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.60 2011/02/15 19:15:25 miod Exp $ */
d254 3
d504 8
d579 1
d616 1
a616 1
	if (hw->mac_type == em_82575) {
d718 1
a718 1
        if (hw->mac_type == em_82575) {
d1284 1
d2326 27
d2543 4
d5060 4
d5314 1
d6585 1
d6633 2
d7298 1
d8513 1
@


1.60
log
@Do not compile statistics counters code if defined(SMALL_KERNEL). Makes i386
RAMDISKA breathe a bit better.
(file forgotten in yesterday's if_em.c commit)
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.59 2011/02/06 23:47:14 dlg Exp $ */
d1573 1
a1573 1
	uint32_t ctrl, reg;
d1616 22
a1637 4
		/* Set switch control to serdes energy detect */
		reg = E1000_READ_REG(hw, CONNSW);
		reg |= E1000_CONNSW_ENRGSRC;
		E1000_WRITE_REG(hw, CONNSW, reg);
@


1.59
log
@cap the max size of the eeprom to 16k, as per the linux and freebsd
drivers.

fix found by jonathan matthew and tested on an "Intel PRO/1000
(82576)" rev 0x01  which didnt work before this change.

tested by jsg on the following chips:

"Intel PRO/1000MT (82540EP)" rev 0x03
"Intel PRO/1000MT (82541GI)" rev 0x05
"Intel PRO/1000 MT (82574L)" rev 0x00
"Intel EP80579 LAN" rev 0x01
"Intel PRO/1000 PT (82572EI)" rev 0x06
"Intel PRO/1000 (82576)" rev 0x01
"Intel 82578DM" rev 0x06
"Intel I340-T4 (82580)" rev 0x01

some style issues are still being discussed which can be fixed in tree if
necessary.
ok jsg@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.58 2010/09/19 13:10:21 yasuoka Exp $ */
d7118 1
d7198 1
@


1.58
log
@add support for 82583V.  Confirmed to work on Portwell CAD-0205.

ok jsg@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.57 2010/09/19 11:29:27 jsg Exp $ */
d5356 8
a5363 2
		eeprom->word_size = 1 << 
		    (eeprom_size + EEPROM_WORD_SIZE_SHIFT);
@


1.57
log
@Check the right mask for additional functions in phy code for 82575
and don't treat a MNG read timeout as fatal as per the Intel code
in FreeBSD.

With these changes Peter Bisroev no longer sees problems with phy
initialisation across reboots on ET quad 82575 cards.

ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.56 2010/08/03 16:39:33 jsg Exp $ */
d483 1
@


1.56
log
@Add support for 82576 fiber adapters based on Intel code in FreeBSD.
Thanks to Frdric URBAN for setting up a test network to develop this on.
Tested by various people on copper adapters and fiber support
also tested by mickey.

ok deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.55 2010/07/13 21:55:52 jsg Exp $ */
d8485 1
a8491 1
	case em_82575:
a8501 1
			return -E1000_ERR_RESET;
@


1.55
log
@use PHY semaphore on 8275/82576 adapters in addition to 80003es2lan.
From SAITOH Masanobu.
Confirmed to fix pr 6427, and should fix 6301 as well.

Tested by a bunch of people, and discussed with claudio
during c2k10.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.54 2010/07/02 21:41:59 jsg Exp $ */
d179 3
a181 1

d595 1
a595 1
	uint32_t status;
d602 22
d1335 2
a1336 1
	if (hw->media_type != em_media_type_internal_serdes)
d1540 20
d1572 1
a1572 1
	uint32_t ctrl;
d1586 2
a1587 1
	if (hw->mac_type == em_82571 || hw->mac_type == em_82572)
d1589 4
d1611 10
d3443 10
d3711 46
d3772 3
d5085 8
@


1.54
log
@Yet another workaround for PCH devices adapted from Intel code in
FreeBSD by Mike Belopuhov.  Makes the 82578 in dlg's dell desktop work.

tested on 82577 by mlarkin@@, ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.53 2010/06/29 19:14:09 jsg Exp $ */
d564 1
d4179 1
a4179 1
	if ((hw->mac_type == em_80003es2lan) &&
d4339 1
a4339 1
	if ((hw->mac_type == em_80003es2lan) &&
d4552 2
a4553 1
		if ((hw->mac_type == em_80003es2lan) &&
@


1.53
log
@More workarounds adapted from FreeBSD to make the 82577/82578 happy,
from Mike Belopuhov and me.

looks good reyk@@ ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.52 2010/06/28 20:24:39 jsg Exp $ */
d170 1
d3427 3
a3429 2
		if (hw->phy_type == em_phy_82578) {
			ret_val = em_link_stall_workaround_hv(hw);
d3436 7
d3448 1
a3458 1

d3974 8
a3989 5
	/* Gig must be disabled for MDIO accesses to page 800 */
	if ((hw->mac_type == em_pchlan) &&
	    (!(E1000_READ_REG(hw, PHY_CTRL) & E1000_PHY_CTRL_GBE_DISABLE)))
		printf("Attempting to access page 800 while gig enabled.\n");

d3998 1
a3998 2
	if (ret_val) {
		printf("Could not read PHY page 769\n");
a3999 1
	}
d4004 1
a4004 2
	if (ret_val) {
		printf("Could not clear PHY page 769 bit 4\n");
a4005 1
	}
d4010 1
a4010 2
	if (ret_val) {
		printf("Could not write PHY page 769 bit 2\n");
a4011 1
	}
d4019 1
a4019 2
	if (ret_val) {
		printf("Could not write address opcode to page 800\n");
a4020 1
	}
d4031 1
a4031 2
	if (ret_val) {
		printf("Could not access data value from page 800\n");
a4032 1
	}
d4043 1
a4043 2
	if (ret_val) {
		printf("Could not clear PHY page 769 bit 2\n");
a4044 1
	}
d4050 3
d4625 6
d7898 2
a7899 4
/**
 *  em_set_lplu_state_pchlan - Set Low Power Link Up state
 *  @@hw: pointer to the HW structure
 *  @@active: TRUE to enable LPLU, FALSE to disable
d7906 1
a7906 1
 **/
d9447 3
a9449 4
/**
 *  e1000_set_mdio_slow_mode_hv - Set slow MDIO access mode
 *  @@hw:   pointer to the HW structure
 **/
d9467 3
a9469 4
/**
 *  em_hv_phy_workarounds_ich8lan - A series of Phy workarounds to be
 *  done after every PHY reset.
 **/
d9596 2
a9597 3
/**
 *  em_link_stall_workaround_hv - Si workaround
 *  @@hw: pointer to the HW structure
d9605 1
a9605 1
 **/
d9649 81
a9729 4
/**
 *  e1000_configure_k1_ich8lan - Configure K1 power state
 *  @@hw: pointer to the HW structure
 *  @@enable: K1 state to configure
d9735 1
a9735 1
 **/
d9745 2
a9746 3
	ret_val = em_read_kmrn_reg(hw,
	                                     E1000_KMRNCTRLSTA_K1_CONFIG,
	                                     &kmrn_reg);
d9755 2
a9756 3
	ret_val = em_write_kmrn_reg(hw,
	                                      E1000_KMRNCTRLSTA_K1_CONFIG,
	                                      kmrn_reg);
a9776 2


@


1.52
log
@Initial 82578 support from Mike Belopuhov.

ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.51 2010/06/27 20:13:04 jsg Exp $ */
d167 12
a178 2
int32_t em_hv_phy_workarounds_ich8lan(struct em_hw *);
int32_t em_configure_k1_ich8lan(struct em_hw *, boolean_t);
d1047 33
d1191 13
d1480 1
d3426 6
d3964 195
d4172 3
d4332 3
d4621 57
d4722 3
d4727 9
d6938 20
d9478 2
a9479 1
	if (hw->phy_type == em_phy_82577) {
d9557 1
a9557 1
		ret_val = em_write_phy_reg(hw, PHY_REG(768, 25), 0x0400);
d9560 1
a9560 1
		ret_val = em_write_phy_reg(hw, PHY_REG(768, 25), 0x0400);
d9586 55
@


1.51
log
@More PCH/82577 bits from FreeBSD, this does not include
all the workarounds but is enough to make things run at
faster than 10 Mbit speeds, though these aren't always
reflecting in ifmedia properly just yet.

ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.50 2010/06/26 18:32:38 jsg Exp $ */
a167 1
void em_initialize_hw_bits_ich8lan(struct em_hw *);
d238 3
d523 2
d1421 3
a1423 2
	
	if (hw->phy_type == em_phy_82577) {
d1988 4
d2108 14
d2352 2
a2353 1
	    hw->phy_type == em_phy_oem) {
d2719 2
a2720 1
	    (hw->phy_type == em_phy_oem)) {
d4554 2
d6826 2
a6827 1
	    hw->phy_type == em_phy_oem) {
d7030 2
a7031 1
	    (hw->phy_type == em_phy_oem)) {
d9158 2
a9159 1
	     ((hw->phy_revision == 1) || (hw->phy_revision == 2)))) {
d9169 25
@


1.50
log
@PCH needs its own Low Power Link Up code as it it is configured
in the PHY instead of the MAC like ICH8.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.49 2010/06/21 21:11:52 jsg Exp $ */
d167 3
d780 5
d969 3
d1417 6
d2135 1
a2135 1
	
d2139 8
d2148 1
d7518 1
a7518 1
STATIC int32_t
d8944 2
a8945 1
	    (hw->device_id == E1000_DEV_ID_ICH8_IGP_M))
d9057 179
@


1.49
log
@Initial support for PCH based em adapters with 82577 PHY,
from Laurence Tratt based on FreeBSD code.  Confirmed to
work on lenovo t410i/t410s/x201.

Desktop machines with PCH tend to be paired with a 82578 PHY,
these will at some point be supported but not yet.

ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.48 2010/06/21 20:43:44 jsg Exp $ */
d128 1
d1697 4
a1700 1
	ret_val = em_set_d0_lplu_state(hw, FALSE);
d7479 35
@


1.48
log
@Add some more ids for existing mac and phy types found
in the FreeBSD driver.

ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.47 2010/05/18 21:51:10 jsg Exp $ */
d232 3
d515 4
d540 1
d604 1
d758 1
d840 9
d863 2
a864 1
	    hw->mac_type == em_ich10lan) {
d953 1
d1038 2
a1039 1
	    hw->mac_type != em_ich10lan) {
d1071 2
a1072 1
	    hw->mac_type == em_ich10lan)
d1128 2
a1129 1
	    hw->mac_type == em_ich10lan)
d1176 1
d1203 2
a1204 1
		 hw->mac_type == em_ich10lan)
d1208 2
a1209 1
	    hw->mac_type == em_ich10lan)
d1307 1
d1398 2
a1399 1
	    hw->mac_type != em_ich10lan) {
d2088 35
d2249 1
d2307 4
d4486 1
d4497 2
d4760 1
d5377 2
a5378 1
	    hw->mac_type == em_ich10lan)
d5441 2
a5442 1
	    hw->mac_type == em_ich10lan) {
d6025 2
a6026 1
	    hw->mac_type == em_ich10lan)
d6075 2
a6076 1
	    hw->mac_type == em_ich10lan)
d6100 2
a6101 1
	    hw->mac_type == em_ich10lan)
d6162 2
a6163 1
		    hw->mac_type == em_ich10lan) {
d6176 2
a6177 1
		    hw->mac_type == em_ich10lan) {
d6190 2
a6191 1
		    hw->mac_type == em_ich10lan) {
d6204 2
a6205 1
		    hw->mac_type == em_ich10lan) {
d6220 2
a6221 1
	    hw->mac_type == em_ich10lan)
d6251 2
a6252 1
	    hw->mac_type == em_ich10lan)
d6345 2
a6346 1
	    hw->mac_type == em_ich10lan)
d6408 1
a6408 1
		    hw->mac_type == em_ich10lan)
d6481 2
a6482 1
	    hw->mac_type != em_ich10lan) {
d6512 2
a6513 1
	    hw->mac_type != em_ich10lan) {
d6550 2
a6551 1
	    hw->mac_type == em_ich10lan)
d6685 1
d7257 2
a7258 1
	    hw->mac_type == em_ich10lan) {
d7283 2
a7284 1
			    hw->mac_type == em_ich10lan) {
d7338 2
a7339 1
			    hw->mac_type == em_ich10lan) {
d7393 2
a7394 1
	    hw->mac_type == em_ich10lan) {
d7406 2
a7407 1
		    hw->mac_type == em_ich10lan) {
d7449 2
a7450 1
		    hw->mac_type == em_ich10lan) {
d7608 2
a7609 1
	    hw->mac_type == em_ich10lan) {
d7854 1
d8083 2
a8084 1
	    hw->mac_type == em_ich10lan) {
d8124 2
a8125 1
	    hw->mac_type == em_ich10lan) {
d8152 2
a8153 1
	    hw->mac_type == em_ich10lan) {
d8191 2
a8192 1
	    hw->mac_type == em_ich10lan) {
@


1.47
log
@Add as yet untested support for the 82576 quad copper ET2
based on information in the linux driver.

ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.46 2010/03/02 22:09:57 dms Exp $ */
d221 1
d460 1
d466 1
d473 2
d491 1
@


1.46
log
@Fix support for Intel PRO/1000 QP 82575-based devices. This changes the way
PHY is recognized on 82575 based cards, now they are autodetected.

Patch originaly form Atte Peltomaki, minor changes by me.

ok by sthen@@, claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.45 2010/01/09 22:56:24 dms Exp $ */
d468 1
@


1.45
log
@a lot of knf loving. hudge diff, no binary change.

ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.42 2009/11/25 13:28:13 dms Exp $ */
d165 1
d643 9
d3872 6
a3877 2
		/* Poll the ready bit to see if the MDI read completed */
		for (i = 0; i < 64; i++) {
d4395 8
d4465 1
a4465 2
	    hw->mac_type == em_82572 ||
	    hw->mac_type == em_82575) {
d4470 1
a4623 1
	case em_82575:
d4639 1
d8816 66
@


1.44
log
@spacing.

ok bluhm@@
@
text
@d3 1
a3 1
  Copyright (c) 2001-2005, Intel Corporation 
d5 2
a6 2
  
  Redistribution and use in source and binary forms, with or without 
d8 2
a9 2
  
   1. Redistributions of source code must retain the above copyright notice, 
d11 3
a13 3
  
   2. Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
d15 3
a17 3
  
   3. Neither the name of the Intel Corporation nor the names of its 
      contributors may be used to endorse or promote products derived from 
d19 1
a19 1
  
d21 8
a28 8
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
d34 3
a36 4
/* $OpenBSD: if_em_hw.c,v 1.43 2009/11/25 18:47:36 dms Exp $ */

/* if_em_hw.c
 * Shared functions for accessing and configuring the MAC
d76 89
a164 88
static int32_t em_swfw_sync_acquire(struct em_hw *hw, uint16_t mask);
static void em_swfw_sync_release(struct em_hw *hw, uint16_t mask);
static int32_t em_read_kmrn_reg(struct em_hw *hw, uint32_t reg_addr, uint16_t *data);
static int32_t em_write_kmrn_reg(struct em_hw *hw, uint32_t reg_addr, uint16_t data);
static int32_t em_get_software_semaphore(struct em_hw *hw);
static void em_release_software_semaphore(struct em_hw *hw);

static int32_t em_check_downshift(struct em_hw *hw);
static void em_clear_vfta(struct em_hw *hw);
static int32_t em_commit_shadow_ram(struct em_hw *hw);
static int32_t em_config_dsp_after_link_change(struct em_hw *hw, boolean_t link_up);
static int32_t em_config_fc_after_link_up(struct em_hw *hw);
static int32_t em_match_gig_phy(struct em_hw *hw);
static int32_t em_detect_gig_phy(struct em_hw *hw);
static int32_t em_erase_ich8_4k_segment(struct em_hw *hw, uint32_t bank);
static int32_t em_get_auto_rd_done(struct em_hw *hw);
static int32_t em_get_cable_length(struct em_hw *hw, uint16_t *min_length, uint16_t *max_length);
static int32_t em_get_hw_eeprom_semaphore(struct em_hw *hw);
static int32_t em_get_phy_cfg_done(struct em_hw *hw);
static int32_t em_get_software_flag(struct em_hw *hw);
static int32_t em_ich8_cycle_init(struct em_hw *hw);
static int32_t em_ich8_flash_cycle(struct em_hw *hw, uint32_t timeout);
static int32_t em_id_led_init(struct em_hw *hw);
static int32_t em_init_lcd_from_nvm_config_region(struct em_hw *hw, uint32_t cnf_base_addr, uint32_t cnf_size);
static int32_t em_init_lcd_from_nvm(struct em_hw *hw);
static void em_init_rx_addrs(struct em_hw *hw);
static void em_initialize_hardware_bits(struct em_hw *hw);
static boolean_t em_is_onboard_nvm_eeprom(struct em_hw *hw);
static int32_t em_kumeran_lock_loss_workaround(struct em_hw *hw);
static int32_t em_mng_enable_host_if(struct em_hw *hw);
static int32_t em_read_eeprom_eerd(struct em_hw *hw, uint16_t offset, uint16_t words, uint16_t *data);
static int32_t em_write_eeprom_eewr(struct em_hw *hw, uint16_t offset, uint16_t words, uint16_t *data);
static int32_t em_poll_eerd_eewr_done(struct em_hw *hw, int eerd);
static void em_put_hw_eeprom_semaphore(struct em_hw *hw);
static int32_t em_read_ich8_byte(struct em_hw *hw, uint32_t index, uint8_t *data);
static int32_t em_verify_write_ich8_byte(struct em_hw *hw, uint32_t index, uint8_t byte);
static int32_t em_write_ich8_byte(struct em_hw *hw, uint32_t index, uint8_t byte);
static int32_t em_read_ich8_word(struct em_hw *hw, uint32_t index, uint16_t *data);
static int32_t em_read_ich8_data(struct em_hw *hw, uint32_t index, uint32_t size, uint16_t *data);
static int32_t em_write_ich8_data(struct em_hw *hw, uint32_t index, uint32_t size, uint16_t data);
static int32_t em_read_eeprom_ich8(struct em_hw *hw, uint16_t offset, uint16_t words, uint16_t *data);
static int32_t em_write_eeprom_ich8(struct em_hw *hw, uint16_t offset, uint16_t words, uint16_t *data);
static void em_release_software_flag(struct em_hw *hw);
static int32_t em_set_d3_lplu_state(struct em_hw *hw, boolean_t active);
static int32_t em_set_d0_lplu_state(struct em_hw *hw, boolean_t active);
static int32_t em_set_pci_ex_no_snoop(struct em_hw *hw, uint32_t no_snoop);
static void em_set_pci_express_master_disable(struct em_hw *hw);
static int32_t em_wait_autoneg(struct em_hw *hw);
static void em_write_reg_io(struct em_hw *hw, uint32_t offset, uint32_t value);
static int32_t em_set_phy_type(struct em_hw *hw);
static void em_phy_init_script(struct em_hw *hw);
static int32_t em_setup_copper_link(struct em_hw *hw);
static int32_t em_setup_fiber_serdes_link(struct em_hw *hw);
static int32_t em_adjust_serdes_amplitude(struct em_hw *hw);
static int32_t em_phy_force_speed_duplex(struct em_hw *hw);
static int32_t em_config_mac_to_phy(struct em_hw *hw);
static void em_raise_mdi_clk(struct em_hw *hw, uint32_t *ctrl);
static void em_lower_mdi_clk(struct em_hw *hw, uint32_t *ctrl);
static void em_shift_out_mdi_bits(struct em_hw *hw, uint32_t data,
                                     uint16_t count);
static uint16_t em_shift_in_mdi_bits(struct em_hw *hw);
static int32_t em_phy_reset_dsp(struct em_hw *hw);
static int32_t em_write_eeprom_spi(struct em_hw *hw, uint16_t offset,
                                      uint16_t words, uint16_t *data);
static int32_t em_write_eeprom_microwire(struct em_hw *hw,
                                            uint16_t offset, uint16_t words,
                                            uint16_t *data);
static int32_t em_spi_eeprom_ready(struct em_hw *hw);
static void em_raise_ee_clk(struct em_hw *hw, uint32_t *eecd);
static void em_lower_ee_clk(struct em_hw *hw, uint32_t *eecd);
static void em_shift_out_ee_bits(struct em_hw *hw, uint16_t data,
                                    uint16_t count);
static int32_t em_write_phy_reg_ex(struct em_hw *hw, uint32_t reg_addr,
                                      uint16_t phy_data);
static int32_t em_read_phy_reg_ex(struct em_hw *hw,uint32_t reg_addr,
                                     uint16_t *phy_data);
static uint16_t em_shift_in_ee_bits(struct em_hw *hw, uint16_t count);
static int32_t em_acquire_eeprom(struct em_hw *hw);
static void em_release_eeprom(struct em_hw *hw);
static void em_standby_eeprom(struct em_hw *hw);
static int32_t em_set_vco_speed(struct em_hw *hw);
static int32_t em_polarity_reversal_workaround(struct em_hw *hw);
static int32_t em_set_phy_mode(struct em_hw *hw);
static int32_t em_host_if_read_cookie(struct em_hw *hw, uint8_t *buffer);
static uint8_t em_calculate_mng_checksum(char *buffer, uint32_t length);
static int32_t em_configure_kmrn_for_10_100(struct em_hw *hw,
                                               uint16_t duplex);
static int32_t em_configure_kmrn_for_1000(struct em_hw *hw);
d167 23
a189 21
static const
uint16_t em_igp_cable_length_table[IGP01E1000_AGC_LENGTH_TABLE_SIZE] =
    { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 10, 10, 10, 10, 10, 10, 10, 20, 20, 20, 20, 20, 25, 25, 25,
      25, 25, 25, 25, 30, 30, 30, 30, 40, 40, 40, 40, 40, 40, 40, 40,
      40, 50, 50, 50, 50, 50, 50, 50, 60, 60, 60, 60, 60, 60, 60, 60,
      60, 70, 70, 70, 70, 70, 70, 80, 80, 80, 80, 80, 80, 90, 90, 90,
      90, 90, 90, 90, 90, 90, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
      100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
      110, 110, 110, 110, 110, 110, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120};

static const
uint16_t em_igp_2_cable_length_table[IGP02E1000_AGC_LENGTH_TABLE_SIZE] =
    { 0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 8, 11, 13, 16, 18, 21,
      0, 0, 0, 3, 6, 10, 13, 16, 19, 23, 26, 29, 32, 35, 38, 41,
      6, 10, 14, 18, 22, 26, 30, 33, 37, 41, 44, 48, 51, 54, 58, 61,
      21, 26, 31, 35, 40, 44, 49, 53, 57, 61, 65, 68, 72, 75, 79, 82,
      40, 45, 51, 56, 61, 66, 70, 75, 79, 83, 87, 91, 94, 98, 101, 104,
      60, 66, 72, 77, 82, 87, 92, 96, 100, 104, 108, 111, 114, 117, 119, 121,
      83, 89, 95, 100, 105, 109, 113, 116, 119, 122, 124,
      104, 109, 114, 118, 121, 124};
d199 1
a199 1
    DEBUGFUNC("em_set_phy_type");
d201 2
a202 2
    if (hw->mac_type == em_undefined)
        return -E1000_ERR_PHY_TYPE;
d204 43
a246 43
    switch (hw->phy_id) {
    case M88E1000_E_PHY_ID:
    case M88E1000_I_PHY_ID:
    case M88E1011_I_PHY_ID:
    case M88E1111_I_PHY_ID:
        hw->phy_type = em_phy_m88;
        break;
    case IGP01E1000_I_PHY_ID:
        if (hw->mac_type == em_82541 ||
            hw->mac_type == em_82541_rev_2 ||
            hw->mac_type == em_82547 ||
            hw->mac_type == em_82547_rev_2) {
            hw->phy_type = em_phy_igp;
            break;
        }
    case IGP03E1000_E_PHY_ID:
        hw->phy_type = em_phy_igp_3;
        break;
    case IFE_E_PHY_ID:
    case IFE_PLUS_E_PHY_ID:
    case IFE_C_E_PHY_ID:
        hw->phy_type = em_phy_ife;
        break;
    case M88E1141_E_PHY_ID:
        hw->phy_type = em_phy_oem;
        break;
    case BME1000_E_PHY_ID:
        if (hw->phy_revision == 1) {
            hw->phy_type = em_phy_bm;
            break;
        }
        /* FALLTHROUGH */
    case GG82563_E_PHY_ID:
        if (hw->mac_type == em_80003es2lan) {
            hw->phy_type = em_phy_gg82563;
            break;
        }
        /* FALLTHROUGH */
    default:
        /* Should never have loaded on this device */
        hw->phy_type = em_phy_undefined;
        return -E1000_ERR_PHY_TYPE;
    }
d248 1
a248 1
    return E1000_SUCCESS;
d259 2
a260 78
    uint16_t phy_saved_data;

    DEBUGFUNC("em_phy_init_script");

    if (hw->phy_init_script) {
        msec_delay(20);

        /* Save off the current value of register 0x2F5B to be restored at
         * the end of this routine. */
        em_read_phy_reg(hw, 0x2F5B, &phy_saved_data);

        /* Disabled the PHY transmitter */
        em_write_phy_reg(hw, 0x2F5B, 0x0003);

        msec_delay(20);

        em_write_phy_reg(hw,0x0000,0x0140);

        msec_delay(5);

        switch (hw->mac_type) {
        case em_82541:
        case em_82547:
            em_write_phy_reg(hw, 0x1F95, 0x0001);

            em_write_phy_reg(hw, 0x1F71, 0xBD21);

            em_write_phy_reg(hw, 0x1F79, 0x0018);

            em_write_phy_reg(hw, 0x1F30, 0x1600);

            em_write_phy_reg(hw, 0x1F31, 0x0014);

            em_write_phy_reg(hw, 0x1F32, 0x161C);

            em_write_phy_reg(hw, 0x1F94, 0x0003);

            em_write_phy_reg(hw, 0x1F96, 0x003F);

            em_write_phy_reg(hw, 0x2010, 0x0008);
            break;

        case em_82541_rev_2:
        case em_82547_rev_2:
            em_write_phy_reg(hw, 0x1F73, 0x0099);
            break;
        default:
            break;
        }

        em_write_phy_reg(hw, 0x0000, 0x3300);

        msec_delay(20);

        /* Now enable the transmitter */
        em_write_phy_reg(hw, 0x2F5B, phy_saved_data);

        if (hw->mac_type == em_82547) {
            uint16_t fused, fine, coarse;

            /* Move to analog registers page */
            em_read_phy_reg(hw, IGP01E1000_ANALOG_SPARE_FUSE_STATUS, &fused);

            if (!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
                em_read_phy_reg(hw, IGP01E1000_ANALOG_FUSE_STATUS, &fused);

                fine = fused & IGP01E1000_ANALOG_FUSE_FINE_MASK;
                coarse = fused & IGP01E1000_ANALOG_FUSE_COARSE_MASK;

                if (coarse > IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {
                    coarse -= IGP01E1000_ANALOG_FUSE_COARSE_10;
                    fine -= IGP01E1000_ANALOG_FUSE_FINE_1;
                } else if (coarse == IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
                    fine -= IGP01E1000_ANALOG_FUSE_FINE_10;

                fused = (fused & IGP01E1000_ANALOG_FUSE_POLY_MASK) |
                        (fine & IGP01E1000_ANALOG_FUSE_FINE_MASK) |
                        (coarse & IGP01E1000_ANALOG_FUSE_COARSE_MASK);
d262 83
a344 6
                em_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_CONTROL, fused);
                em_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_BYPASS,
                                    IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL);
            }
        }
    }
d355 1
a355 1
    DEBUGFUNC("em_set_mac_type");
d357 189
a545 189
    switch (hw->device_id) {
    case E1000_DEV_ID_82542:
        switch (hw->revision_id) {
        case E1000_82542_2_0_REV_ID:
            hw->mac_type = em_82542_rev2_0;
            break;
        case E1000_82542_2_1_REV_ID:
            hw->mac_type = em_82542_rev2_1;
            break;
        default:
            /* Invalid 82542 revision ID */
            return -E1000_ERR_MAC_TYPE;
        }
        break;
    case E1000_DEV_ID_82543GC_FIBER:
    case E1000_DEV_ID_82543GC_COPPER:
        hw->mac_type = em_82543;
        break;
    case E1000_DEV_ID_82544EI_COPPER:
    case E1000_DEV_ID_82544EI_FIBER:
    case E1000_DEV_ID_82544GC_COPPER:
    case E1000_DEV_ID_82544GC_LOM:
        hw->mac_type = em_82544;
        break;
    case E1000_DEV_ID_82540EM:
    case E1000_DEV_ID_82540EM_LOM:
    case E1000_DEV_ID_82540EP:
    case E1000_DEV_ID_82540EP_LOM:
    case E1000_DEV_ID_82540EP_LP:
        hw->mac_type = em_82540;
        break;
    case E1000_DEV_ID_82545EM_COPPER:
    case E1000_DEV_ID_82545EM_FIBER:
        hw->mac_type = em_82545;
        break;
    case E1000_DEV_ID_82545GM_COPPER:
    case E1000_DEV_ID_82545GM_FIBER:
    case E1000_DEV_ID_82545GM_SERDES:
        hw->mac_type = em_82545_rev_3;
        break;
    case E1000_DEV_ID_82546EB_COPPER:
    case E1000_DEV_ID_82546EB_FIBER:
    case E1000_DEV_ID_82546EB_QUAD_COPPER:
        hw->mac_type = em_82546;
        break;
    case E1000_DEV_ID_82546GB_COPPER:
    case E1000_DEV_ID_82546GB_FIBER:
    case E1000_DEV_ID_82546GB_SERDES:
    case E1000_DEV_ID_82546GB_PCIE:
    case E1000_DEV_ID_82546GB_QUAD_COPPER:
    case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
    case E1000_DEV_ID_82546GB_2:
        hw->mac_type = em_82546_rev_3;
        break;
    case E1000_DEV_ID_82541EI:
    case E1000_DEV_ID_82541EI_MOBILE:
    case E1000_DEV_ID_82541ER_LOM:
        hw->mac_type = em_82541;
        break;
    case E1000_DEV_ID_82541ER:
    case E1000_DEV_ID_82541GI:
    case E1000_DEV_ID_82541GI_LF:
    case E1000_DEV_ID_82541GI_MOBILE:
        hw->mac_type = em_82541_rev_2;
        break;
    case E1000_DEV_ID_82547EI:
    case E1000_DEV_ID_82547EI_MOBILE:
        hw->mac_type = em_82547;
        break;
    case E1000_DEV_ID_82547GI:
	hw->mac_type = em_82547_rev_2;
	break;
    case E1000_DEV_ID_82571EB_AF:
    case E1000_DEV_ID_82571EB_AT:
    case E1000_DEV_ID_82571EB_COPPER:
    case E1000_DEV_ID_82571EB_FIBER:
    case E1000_DEV_ID_82571EB_SERDES:
    case E1000_DEV_ID_82571EB_QUAD_COPPER:
    case E1000_DEV_ID_82571EB_QUAD_FIBER:
    case E1000_DEV_ID_82571EB_QUAD_COPPER_LP:
    case E1000_DEV_ID_82571EB_SERDES_DUAL:
    case E1000_DEV_ID_82571EB_SERDES_QUAD:
    case E1000_DEV_ID_82571PT_QUAD_COPPER:
	hw->mac_type = em_82571;
	break;
    case E1000_DEV_ID_82572EI_COPPER:
    case E1000_DEV_ID_82572EI_FIBER:
    case E1000_DEV_ID_82572EI_SERDES:
    case E1000_DEV_ID_82572EI:
        hw->mac_type = em_82572;
        break;
    case E1000_DEV_ID_82573E:
    case E1000_DEV_ID_82573E_IAMT:
    case E1000_DEV_ID_82573E_PM:
    case E1000_DEV_ID_82573L:
    case E1000_DEV_ID_82573L_PL_1:
    case E1000_DEV_ID_82573L_PL_2:
    case E1000_DEV_ID_82573V_PM:
        hw->mac_type = em_82573;
        break;
    case E1000_DEV_ID_82574L:
        hw->mac_type = em_82574;
        break;
    case E1000_DEV_ID_82575EB_PT:
    case E1000_DEV_ID_82575EB_PF:
    case E1000_DEV_ID_82575GB_QP:
    case E1000_DEV_ID_82576:
    case E1000_DEV_ID_82576_FIBER:
    case E1000_DEV_ID_82576_SERDES:
    case E1000_DEV_ID_82576_QUAD_COPPER:
    case E1000_DEV_ID_82576_NS:
	hw->mac_type = em_82575;
	hw->initialize_hw_bits_disable = 1;
	break;
    case E1000_DEV_ID_80003ES2LAN_COPPER_SPT:
    case E1000_DEV_ID_80003ES2LAN_SERDES_SPT:
    case E1000_DEV_ID_80003ES2LAN_COPPER_DPT:
    case E1000_DEV_ID_80003ES2LAN_SERDES_DPT:
        hw->mac_type = em_80003es2lan;
        break;
    case E1000_DEV_ID_ICH8_IFE:
    case E1000_DEV_ID_ICH8_IFE_G:
    case E1000_DEV_ID_ICH8_IFE_GT:
    case E1000_DEV_ID_ICH8_IGP_AMT:
    case E1000_DEV_ID_ICH8_IGP_C:
    case E1000_DEV_ID_ICH8_IGP_M:
    case E1000_DEV_ID_ICH8_IGP_M_AMT:
        hw->mac_type = em_ich8lan;
        break;
    case E1000_DEV_ID_ICH9_BM:
    case E1000_DEV_ID_ICH9_IFE:
    case E1000_DEV_ID_ICH9_IFE_G:
    case E1000_DEV_ID_ICH9_IFE_GT:
    case E1000_DEV_ID_ICH9_IGP_AMT:
    case E1000_DEV_ID_ICH9_IGP_C:
    case E1000_DEV_ID_ICH9_IGP_M:
    case E1000_DEV_ID_ICH9_IGP_M_AMT:
    case E1000_DEV_ID_ICH9_IGP_M_V:
    case E1000_DEV_ID_ICH10_R_BM_LF:
    case E1000_DEV_ID_ICH10_R_BM_LM:
    case E1000_DEV_ID_ICH10_R_BM_V:
        hw->mac_type = em_ich9lan;
        break;
    case E1000_DEV_ID_ICH10_D_BM_LF:
    case E1000_DEV_ID_ICH10_D_BM_LM:
        hw->mac_type = em_ich10lan;
        break;
    case E1000_DEV_ID_EP80579_LAN_1:
        hw->mac_type = em_icp_xxxx;
        hw->icp_xxxx_port_num = 0;
        break; 
    case E1000_DEV_ID_EP80579_LAN_2:
        hw->mac_type = em_icp_xxxx;
        hw->icp_xxxx_port_num = 1;
        break; 
    case E1000_DEV_ID_EP80579_LAN_3:
        hw->mac_type = em_icp_xxxx;
        hw->icp_xxxx_port_num = 2;
        break; 
    default:
        /* Should never have loaded on this device */
        return -E1000_ERR_MAC_TYPE;
    }

    switch (hw->mac_type) {
    case em_ich8lan:
    case em_ich9lan:
    case em_ich10lan:
        hw->swfwhw_semaphore_present = TRUE;
        hw->asf_firmware_present = TRUE;
        break;
    case em_80003es2lan:
        hw->swfw_sync_present = TRUE;
        /* FALLTHROUGH */
    case em_82571:
    case em_82572:
    case em_82573:
    case em_82574:
        hw->eeprom_semaphore_present = TRUE;
        /* FALLTHROUGH */
    case em_82541:
    case em_82547:
    case em_82541_rev_2:
    case em_82547_rev_2:
        hw->asf_firmware_present = TRUE;
        break;
    default:
        break;
    }
d547 1
a547 1
    return E1000_SUCCESS;
a548 1

d557 2
a558 3
    uint32_t status;

    DEBUGFUNC("em_set_media_type");
d560 48
a607 48
    if (hw->mac_type != em_82543) {
        /* tbi_compatibility is only valid on 82543 */
        hw->tbi_compatibility_en = FALSE;
    }

    switch (hw->device_id) {
    case E1000_DEV_ID_82545GM_SERDES:
    case E1000_DEV_ID_82546GB_SERDES:
    case E1000_DEV_ID_82571EB_SERDES:
    case E1000_DEV_ID_82571EB_SERDES_DUAL:
    case E1000_DEV_ID_82571EB_SERDES_QUAD:
    case E1000_DEV_ID_82572EI_SERDES:
    case E1000_DEV_ID_80003ES2LAN_SERDES_DPT:
        hw->media_type = em_media_type_internal_serdes;
        break;
    case E1000_DEV_ID_EP80579_LAN_1:
    case E1000_DEV_ID_EP80579_LAN_2:
    case E1000_DEV_ID_EP80579_LAN_3:
        hw->media_type = em_media_type_oem;
        break; 
    default:
        switch (hw->mac_type) {
        case em_82542_rev2_0:
        case em_82542_rev2_1:
            hw->media_type = em_media_type_fiber;
            break;
        case em_ich8lan:
        case em_ich9lan:
        case em_ich10lan:
        case em_82573:
        case em_82574:
            /* The STATUS_TBIMODE bit is reserved or reused for the this
             * device.
             */
            hw->media_type = em_media_type_copper;
            break;
        default:
            status = E1000_READ_REG(hw, STATUS);
            if (status & E1000_STATUS_TBIMODE) {
                hw->media_type = em_media_type_fiber;
                /* tbi_compatibility not valid on fiber */
                hw->tbi_compatibility_en = FALSE;
            } else {
                hw->media_type = em_media_type_copper;
            }
            break;
        }
    }
a608 1

d617 92
a708 213
    uint32_t ctrl;
    uint32_t ctrl_ext;
    uint32_t icr;
    uint32_t manc;
    uint32_t led_ctrl;
    uint32_t timeout;
    uint32_t extcnf_ctrl;
    int32_t ret_val;

    DEBUGFUNC("em_reset_hw");

    /* For 82542 (rev 2.0), disable MWI before issuing a device reset */
    if (hw->mac_type == em_82542_rev2_0) {
        DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
        em_pci_clear_mwi(hw);
    }

    if (hw->bus_type == em_bus_type_pci_express) {
        /* Prevent the PCI-E bus from sticking if there is no TLP connection
         * on the last TLP read/write transaction when MAC is reset.
         */
        if (em_disable_pciex_master(hw) != E1000_SUCCESS) {
            DEBUGOUT("PCI-E Master disable polling has failed.\n");
        }
    }

    /* Clear interrupt mask to stop board from generating interrupts */
    DEBUGOUT("Masking off all interrupts\n");
    E1000_WRITE_REG(hw, IMC, 0xffffffff);

    /* Disable the Transmit and Receive units.  Then delay to allow
     * any pending transactions to complete before we hit the MAC with
     * the global reset.
     */
    E1000_WRITE_REG(hw, RCTL, 0);
    E1000_WRITE_REG(hw, TCTL, E1000_TCTL_PSP);
    E1000_WRITE_FLUSH(hw);

    /* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
    hw->tbi_compatibility_on = FALSE;

    /* Delay to allow any outstanding PCI transactions to complete before
     * resetting the device
     */
    msec_delay(10);

    ctrl = E1000_READ_REG(hw, CTRL);

    /* Must reset the PHY before resetting the MAC */
    if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
        E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
        msec_delay(5);
    }

    /* Must acquire the MDIO ownership before MAC reset.
     * Ownership defaults to firmware after a reset. */
    if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
        timeout = 10;

        extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);
        extcnf_ctrl |= E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP;

        do {
            E1000_WRITE_REG(hw, EXTCNF_CTRL, extcnf_ctrl);
            extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);

            if (extcnf_ctrl & E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP)
                break;
            else
                extcnf_ctrl |= E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP;

            msec_delay(2);
            timeout--;
        } while (timeout);
    }

    /* Workaround for ICH8 bit corruption issue in FIFO memory */
    if (hw->mac_type == em_ich8lan) {
        /* Set Tx and Rx buffer allocation to 8k apiece. */
        E1000_WRITE_REG(hw, PBA, E1000_PBA_8K);
        /* Set Packet Buffer Size to 16k. */
        E1000_WRITE_REG(hw, PBS, E1000_PBS_16K);
    }

    /* Issue a global reset to the MAC.  This will reset the chip's
     * transmit, receive, DMA, and link units.  It will not effect
     * the current PCI configuration.  The global reset bit is self-
     * clearing, and should clear within a microsecond.
     */
    DEBUGOUT("Issuing a global reset to MAC\n");

    switch (hw->mac_type) {
        case em_82544:
        case em_82540:
        case em_82545:
        case em_82546:
        case em_82541:
        case em_82541_rev_2:
            /* These controllers can't ack the 64-bit write when issuing the
             * reset, so use IO-mapping as a workaround to issue the reset */
            E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
            break;
        case em_82545_rev_3:
        case em_82546_rev_3:
            /* Reset is performed on a shadow of the control register */
            E1000_WRITE_REG(hw, CTRL_DUP, (ctrl | E1000_CTRL_RST));
            break;
        case em_ich8lan:
        case em_ich9lan:
        case em_ich10lan:
            if (!hw->phy_reset_disable &&
                em_check_phy_reset_block(hw) == E1000_SUCCESS) {
                /* PHY HW reset requires MAC CORE reset at the same
                 * time to make sure the interface between MAC and the
                 * external PHY is reset.
                 */
                ctrl |= E1000_CTRL_PHY_RST;
            }

            em_get_software_flag(hw);
            E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
            msec_delay(5);
            break;
        default:
            E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
            break;
    }

    /* After MAC reset, force reload of EEPROM to restore power-on settings to
     * device.  Later controllers reload the EEPROM automatically, so just wait
     * for reload to complete.
     */
    switch (hw->mac_type) {
        case em_82542_rev2_0:
        case em_82542_rev2_1:
        case em_82543:
        case em_82544:
            /* Wait for reset to complete */
            usec_delay(10);
            ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
            ctrl_ext |= E1000_CTRL_EXT_EE_RST;
            E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
            E1000_WRITE_FLUSH(hw);
            /* Wait for EEPROM reload */
            msec_delay(2);
            break;
        case em_82541:
        case em_82541_rev_2:
        case em_82547:
        case em_82547_rev_2:
            /* Wait for EEPROM reload */
            msec_delay(20);
            break;
        case em_82573:
        case em_82574:
            if (em_is_onboard_nvm_eeprom(hw) == FALSE) {
                usec_delay(10);
                ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
                ctrl_ext |= E1000_CTRL_EXT_EE_RST;
                E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
                E1000_WRITE_FLUSH(hw);
            }
            /* FALLTHROUGH */

            /* Auto read done will delay 5ms or poll based on mac type */
            ret_val = em_get_auto_rd_done(hw);
            if (ret_val)
                return ret_val;
            break;
        default:
            /* Wait for EEPROM reload (it happens automatically) */
            msec_delay(5);
            break;
    }

    /* Disable HW ARPs on ASF enabled adapters */
    if (hw->mac_type >= em_82540 && hw->mac_type <= em_82547_rev_2 &&
    	 hw->mac_type != em_icp_xxxx) {
        manc = E1000_READ_REG(hw, MANC);
        manc &= ~(E1000_MANC_ARP_EN);
        E1000_WRITE_REG(hw, MANC, manc);
    }

    if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
        em_phy_init_script(hw);

        /* Configure activity LED after PHY reset */
        led_ctrl = E1000_READ_REG(hw, LEDCTL);
        led_ctrl &= IGP_ACTIVITY_LED_MASK;
        led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
        E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
    }

    /* Clear interrupt mask to stop board from generating interrupts */
    DEBUGOUT("Masking off all interrupts\n");
    E1000_WRITE_REG(hw, IMC, 0xffffffff);

    /* Clear any pending interrupt events. */
    icr = E1000_READ_REG(hw, ICR);

    /* If MWI was previously enabled, reenable it. */
    if (hw->mac_type == em_82542_rev2_0) {
        if (hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
            em_pci_set_mwi(hw);
    }

    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
        uint32_t kab = E1000_READ_REG(hw, KABGTXD);
        kab |= E1000_KABGTXD_BGSQLBIAS;
        E1000_WRITE_REG(hw, KABGTXD, kab);
    }
d710 123
a832 1
    return E1000_SUCCESS;
d845 100
a944 90
    if ((hw->mac_type >= em_82571) && (!hw->initialize_hw_bits_disable)) {
        /* Settings common to all silicon */
        uint32_t reg_ctrl, reg_ctrl_ext;
        uint32_t reg_tarc0, reg_tarc1;
        uint32_t reg_tctl;
        uint32_t reg_txdctl, reg_txdctl1;

        reg_tarc0 = E1000_READ_REG(hw, TARC0);
        reg_tarc0 &= ~0x78000000;           /* Clear bits 30, 29, 28, and 27 */

        reg_txdctl = E1000_READ_REG(hw, TXDCTL);
        reg_txdctl |= E1000_TXDCTL_COUNT_DESC;       /* Set bit 22 */
        E1000_WRITE_REG(hw, TXDCTL, reg_txdctl);

        reg_txdctl1 = E1000_READ_REG(hw, TXDCTL1);
        reg_txdctl1 |= E1000_TXDCTL_COUNT_DESC;      /* Set bit 22 */
        E1000_WRITE_REG(hw, TXDCTL1, reg_txdctl1);

        switch (hw->mac_type) {
            case em_82571:
            case em_82572:
                reg_tarc1 = E1000_READ_REG(hw, TARC1);
                reg_tctl = E1000_READ_REG(hw, TCTL);

                /* Set the phy Tx compatible mode bits */
                reg_tarc1 &= ~0x60000000;   /* Clear bits 30 and 29 */

                reg_tarc0 |= 0x07800000;    /* Set TARC0 bits 23-26 */
                reg_tarc1 |= 0x07000000;    /* Set TARC1 bits 24-26 */

                if (reg_tctl & E1000_TCTL_MULR)
                    reg_tarc1 &= ~0x10000000;   /* Clear bit 28 if MULR is 1b */
                else
                    reg_tarc1 |= 0x10000000;    /* Set bit 28 if MULR is 0b */

                E1000_WRITE_REG(hw, TARC1, reg_tarc1);
                break;
            case em_82573:
            case em_82574:
                reg_ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
                reg_ctrl = E1000_READ_REG(hw, CTRL);

                reg_ctrl_ext &= ~0x00800000;    /* Clear bit 23 */
                reg_ctrl_ext |= 0x00400000;     /* Set bit 22 */
                reg_ctrl &= ~0x20000000;        /* Clear bit 29 */

                E1000_WRITE_REG(hw, CTRL_EXT, reg_ctrl_ext);
                E1000_WRITE_REG(hw, CTRL, reg_ctrl);
                break;
            case em_80003es2lan:
                if ((hw->media_type == em_media_type_fiber) ||
                    (hw->media_type == em_media_type_internal_serdes)) {
                    reg_tarc0 &= ~0x00100000;   /* Clear bit 20 */
                }

                reg_tctl = E1000_READ_REG(hw, TCTL);
                reg_tarc1 = E1000_READ_REG(hw, TARC1);
                if (reg_tctl & E1000_TCTL_MULR)
                    reg_tarc1 &= ~0x10000000;   /* Clear bit 28 if MULR is 1b */
                else
                    reg_tarc1 |= 0x10000000;    /* Set bit 28 if MULR is 0b */

                E1000_WRITE_REG(hw, TARC1, reg_tarc1);
                break;
            case em_ich8lan:
            case em_ich9lan:
            case em_ich10lan:
                if (hw->mac_type == em_ich8lan)
                    reg_tarc0 |= 0x30000000;    /* Set TARC0 bits 29 and 28 */
                reg_ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
                reg_ctrl_ext |= 0x00400000;     /* Set bit 22 */
                E1000_WRITE_REG(hw, CTRL_EXT, reg_ctrl_ext);

                reg_tarc0 |= 0x0d800000;    /* Set TARC0 bits 23, 24, 26, 27 */

                reg_tarc1 = E1000_READ_REG(hw, TARC1);
                reg_tctl = E1000_READ_REG(hw, TCTL);

                if (reg_tctl & E1000_TCTL_MULR)
                    reg_tarc1 &= ~0x10000000;   /* Clear bit 28 if MULR is 1b */
                else
                    reg_tarc1 |= 0x10000000;    /* Set bit 28 if MULR is 0b */

                reg_tarc1 |= 0x45000000;        /* Set bit 24, 26 and 30 */

                E1000_WRITE_REG(hw, TARC1, reg_tarc1);
                break;
            default:
                break;
        }
d946 2
a947 2
        E1000_WRITE_REG(hw, TARC0, reg_tarc0);
    }
d964 54
a1017 208
    uint32_t ctrl;
    uint32_t i;
    int32_t ret_val;
    uint16_t pcix_cmd_word;
    uint16_t pcix_stat_hi_word;
    uint16_t cmd_mmrbc;
    uint16_t stat_mmrbc;
    uint32_t mta_size;
    uint32_t reg_data;
    uint32_t ctrl_ext;
    uint32_t snoop;

    DEBUGFUNC("em_init_hw");

    /* force full DMA clock frequency for ICH8 */
    if (hw->mac_type == em_ich8lan) {
            reg_data = E1000_READ_REG(hw, STATUS);
            reg_data &= ~0x80000000;
            E1000_WRITE_REG(hw, STATUS, reg_data);
    }

    /* Initialize Identification LED */
    ret_val = em_id_led_init(hw);
    if (ret_val) {
        DEBUGOUT("Error Initializing Identification LED\n");
        return ret_val;
    }

    /* Set the media type and TBI compatibility */
    em_set_media_type(hw);

    /* Must be called after em_set_media_type because media_type is used */
    em_initialize_hardware_bits(hw);

    /* Disabling VLAN filtering. */
    DEBUGOUT("Initializing the IEEE VLAN\n");
    /* VET hardcoded to standard value and VFTA removed in ICH8/ICH9 LAN */
    if (hw->mac_type != em_ich8lan &&
        hw->mac_type != em_ich9lan &&
        hw->mac_type != em_ich10lan) {
        if (hw->mac_type < em_82545_rev_3)
            E1000_WRITE_REG(hw, VET, 0);
        em_clear_vfta(hw);
    }

    /* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
    if (hw->mac_type == em_82542_rev2_0) {
        DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
        em_pci_clear_mwi(hw);
        E1000_WRITE_REG(hw, RCTL, E1000_RCTL_RST);
        E1000_WRITE_FLUSH(hw);
        msec_delay(5);
    }

    /* Setup the receive address. This involves initializing all of the Receive
     * Address Registers (RARs 0 - 15).
     */
    em_init_rx_addrs(hw);

    /* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
    if (hw->mac_type == em_82542_rev2_0) {
        E1000_WRITE_REG(hw, RCTL, 0);
        E1000_WRITE_FLUSH(hw);
        msec_delay(1);
        if (hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
            em_pci_set_mwi(hw);
    }

    /* Zero out the Multicast HASH table */
    DEBUGOUT("Zeroing the MTA\n");
    mta_size = E1000_MC_TBL_SIZE;
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        mta_size = E1000_MC_TBL_SIZE_ICH8LAN;
    for (i = 0; i < mta_size; i++) {
        E1000_WRITE_REG_ARRAY(hw, MTA, i, 0);
        /* use write flush to prevent Memory Write Block (MWB) from
         * occuring when accessing our register space */
        E1000_WRITE_FLUSH(hw);
    }

    /* Set the PCI priority bit correctly in the CTRL register.  This
     * determines if the adapter gives priority to receives, or if it
     * gives equal priority to transmits and receives.  Valid only on
     * 82542 and 82543 silicon.
     */
    if (hw->dma_fairness && hw->mac_type <= em_82543) {
        ctrl = E1000_READ_REG(hw, CTRL);
        E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PRIOR);
    }

    switch (hw->mac_type) {
    case em_82545_rev_3:
    case em_82546_rev_3:
        break;
    default:
        /* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
        if (hw->bus_type == em_bus_type_pcix) {
            em_read_pci_cfg(hw, PCIX_COMMAND_REGISTER, &pcix_cmd_word);
            em_read_pci_cfg(hw, PCIX_STATUS_REGISTER_HI,
                &pcix_stat_hi_word);
            cmd_mmrbc = (pcix_cmd_word & PCIX_COMMAND_MMRBC_MASK) >>
                PCIX_COMMAND_MMRBC_SHIFT;
            stat_mmrbc = (pcix_stat_hi_word & PCIX_STATUS_HI_MMRBC_MASK) >>
                PCIX_STATUS_HI_MMRBC_SHIFT;
            if (stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
                stat_mmrbc = PCIX_STATUS_HI_MMRBC_2K;
            if (cmd_mmrbc > stat_mmrbc) {
                pcix_cmd_word &= ~PCIX_COMMAND_MMRBC_MASK;
                pcix_cmd_word |= stat_mmrbc << PCIX_COMMAND_MMRBC_SHIFT;
                em_write_pci_cfg(hw, PCIX_COMMAND_REGISTER,
                    &pcix_cmd_word);
            }
        }
        break;
    }

    /* More time needed for PHY to initialize */
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        msec_delay(15);

    /* Call a subroutine to configure the link and setup flow control. */
    ret_val = em_setup_link(hw);

    /* Set the transmit descriptor write-back policy */
    if (hw->mac_type > em_82544) {
        ctrl = E1000_READ_REG(hw, TXDCTL);
        ctrl = (ctrl & ~E1000_TXDCTL_WTHRESH) | E1000_TXDCTL_FULL_TX_DESC_WB;
        E1000_WRITE_REG(hw, TXDCTL, ctrl);
    }

    if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) { 
        em_enable_tx_pkt_filtering(hw);
    }

    switch (hw->mac_type) {
    default:
        break;
    case em_80003es2lan:
        /* Enable retransmit on late collisions */
        reg_data = E1000_READ_REG(hw, TCTL);
        reg_data |= E1000_TCTL_RTLC;
        E1000_WRITE_REG(hw, TCTL, reg_data);

        /* Configure Gigabit Carry Extend Padding */
        reg_data = E1000_READ_REG(hw, TCTL_EXT);
        reg_data &= ~E1000_TCTL_EXT_GCEX_MASK;
        reg_data |= DEFAULT_80003ES2LAN_TCTL_EXT_GCEX;
        E1000_WRITE_REG(hw, TCTL_EXT, reg_data);

        /* Configure Transmit Inter-Packet Gap */
        reg_data = E1000_READ_REG(hw, TIPG);
        reg_data &= ~E1000_TIPG_IPGT_MASK;
        reg_data |= DEFAULT_80003ES2LAN_TIPG_IPGT_1000;
        E1000_WRITE_REG(hw, TIPG, reg_data);

        reg_data = E1000_READ_REG_ARRAY(hw, FFLT, 0x0001);
        reg_data &= ~0x00100000;
        E1000_WRITE_REG_ARRAY(hw, FFLT, 0x0001, reg_data);
        /* FALLTHROUGH */
    case em_82571:
    case em_82572:
    case em_82575:
    case em_ich8lan:
    case em_ich9lan:
    case em_ich10lan:
        ctrl = E1000_READ_REG(hw, TXDCTL1);
        ctrl = (ctrl & ~E1000_TXDCTL_WTHRESH) | E1000_TXDCTL_FULL_TX_DESC_WB;
        E1000_WRITE_REG(hw, TXDCTL1, ctrl);
        break;
    }

    if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
        uint32_t gcr = E1000_READ_REG(hw, GCR);
        gcr |= E1000_GCR_L1_ACT_WITHOUT_L0S_RX;
        E1000_WRITE_REG(hw, GCR, gcr);
    }

    /* Clear all of the statistics registers (clear on read).  It is
     * important that we do this after we have tried to establish link
     * because the symbol error count will increment wildly if there
     * is no link.
     */
    em_clear_hw_cntrs(hw);

    /* ICH8 No-snoop bits are opposite polarity.
     * Set to snoop by default after reset. */
    if (hw->mac_type == em_ich8lan)
        snoop = PCI_EX_82566_SNOOP_ALL;
    else if (hw->mac_type == em_ich9lan ||
             hw->mac_type == em_ich10lan)
        snoop = (u_int32_t)~(PCI_EX_NO_SNOOP_ALL);
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        em_set_pci_ex_no_snoop(hw, snoop);

    if (hw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER ||
        hw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3) {
        ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
        /* Relaxed ordering must be disabled to avoid a parity
         * error crash in a PCI slot. */
        ctrl_ext |= E1000_CTRL_EXT_RO_DIS;
        E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
    }
d1019 160
a1178 1
    return ret_val;
d1189 28
a1216 30
    uint16_t eeprom_data;
    int32_t  ret_val;

    DEBUGFUNC("em_adjust_serdes_amplitude");

    if (hw->media_type != em_media_type_internal_serdes)
        return E1000_SUCCESS;

    switch (hw->mac_type) {
    case em_82545_rev_3:
    case em_82546_rev_3:
        break;
    default:
        return E1000_SUCCESS;
    }

    ret_val = em_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1, &eeprom_data);
    if (ret_val) {
        return ret_val;
    }

    if (eeprom_data != EEPROM_RESERVED_WORD) {
        /* Adjust SERDES output amplitude only. */
        eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK;
        ret_val = em_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL, eeprom_data);
        if (ret_val)
            return ret_val;
    }

    return E1000_SUCCESS;
d1233 152
a1384 150
    uint32_t ctrl_ext;
    int32_t ret_val;
    uint16_t eeprom_data;
    uint16_t eeprom_control2_reg_offset;

    DEBUGFUNC("em_setup_link");

    eeprom_control2_reg_offset = 
        (hw->mac_type != em_icp_xxxx)   
        ? EEPROM_INIT_CONTROL2_REG
        : EEPROM_INIT_CONTROL3_ICP_xxxx(hw->icp_xxxx_port_num);

    /* In the case of the phy reset being blocked, we already have a link.
     * We do not have to set it up again. */
    if (em_check_phy_reset_block(hw))
        return E1000_SUCCESS;

    /* Read and store word 0x0F of the EEPROM. This word contains bits
     * that determine the hardware's default PAUSE (flow control) mode,
     * a bit that determines whether the HW defaults to enabling or
     * disabling auto-negotiation, and the direction of the
     * SW defined pins. If there is no SW over-ride of the flow
     * control setting, then the variable hw->fc will
     * be initialized based on a value in the EEPROM.
     */
    if (hw->fc == E1000_FC_DEFAULT) {
        switch (hw->mac_type) {
        case em_ich8lan:
        case em_ich9lan:
        case em_ich10lan:
        case em_82573:
        case em_82574:
            hw->fc = E1000_FC_FULL;
            break;
        default:
            ret_val = em_read_eeprom(hw, eeprom_control2_reg_offset,
                                        1, &eeprom_data);
            if (ret_val) {
                DEBUGOUT("EEPROM Read Error\n");
                return -E1000_ERR_EEPROM;
            }
            if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)
                hw->fc = E1000_FC_NONE;
            else if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) ==
                    EEPROM_WORD0F_ASM_DIR)
                hw->fc = E1000_FC_TX_PAUSE;
            else
                hw->fc = E1000_FC_FULL;
            break;
        }
    }

    /* We want to save off the original Flow Control configuration just
     * in case we get disconnected and then reconnected into a different
     * hub or switch with different Flow Control capabilities.
     */
    if (hw->mac_type == em_82542_rev2_0)
        hw->fc &= (~E1000_FC_TX_PAUSE);

    if ((hw->mac_type < em_82543) && (hw->report_tx_early == 1))
        hw->fc &= (~E1000_FC_RX_PAUSE);

    hw->original_fc = hw->fc;

    DEBUGOUT1("After fix-ups FlowControl is now = %x\n", hw->fc);

    /* Take the 4 bits from EEPROM word 0x0F that determine the initial
     * polarity value for the SW controlled pins, and setup the
     * Extended Device Control reg with that info.
     * This is needed because one of the SW controlled pins is used for
     * signal detection.  So this should be done before em_setup_pcs_link()
     * or em_phy_setup() is called.
     */
    if (hw->mac_type == em_82543) {
        ret_val = em_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,
                                    1, &eeprom_data);
        if (ret_val) {
            DEBUGOUT("EEPROM Read Error\n");
            return -E1000_ERR_EEPROM;
        }
        ctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) <<
                    SWDPIO__EXT_SHIFT);
        E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
    }

    /* Make sure we have a valid PHY */
    ret_val = em_detect_gig_phy(hw);
    if (ret_val) {
        DEBUGOUT("Error, did not detect valid phy.\n");
        if (hw->mac_type == em_icp_xxxx)
            return E1000_DEFER_INIT;
        else
            return ret_val;
    }
    DEBUGOUT1("Phy ID = %x \n", hw->phy_id);

    /* Call the necessary subroutine to configure the link. */
    switch (hw->media_type) {
    case em_media_type_copper:
    case em_media_type_oem:
        ret_val = em_setup_copper_link(hw);
        break;
    default:
        ret_val = em_setup_fiber_serdes_link(hw);
        break;
    }

    /* Initialize the flow control address, type, and PAUSE timer
     * registers to their default values.  This is done even if flow
     * control is disabled, because it does not hurt anything to
     * initialize these registers.
     */
    DEBUGOUT("Initializing the Flow Control address, type and timer regs\n");

    /*
     * FCAL/H and FCT are hardcoded to standard values in
     * em_ich8lan / em_ich9lan / em_ich10lan.
     */
    if (hw->mac_type != em_ich8lan &&
        hw->mac_type != em_ich9lan &&
        hw->mac_type != em_ich10lan) {
        E1000_WRITE_REG(hw, FCT, FLOW_CONTROL_TYPE);
        E1000_WRITE_REG(hw, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
        E1000_WRITE_REG(hw, FCAL, FLOW_CONTROL_ADDRESS_LOW);
    }

    E1000_WRITE_REG(hw, FCTTV, hw->fc_pause_time);

    /* Set the flow control receive threshold registers.  Normally,
     * these registers will be set to a default threshold that may be
     * adjusted later by the driver's runtime code.  However, if the
     * ability to transmit pause frames in not enabled, then these
     * registers will be set to 0.
     */
    if (!(hw->fc & E1000_FC_TX_PAUSE)) {
        E1000_WRITE_REG(hw, FCRTL, 0);
        E1000_WRITE_REG(hw, FCRTH, 0);
    } else {
        /* We need to set up the Receive Threshold high and low water marks
         * as well as (optionally) enabling the transmission of XON frames.
         */
        if (hw->fc_send_xon) {
            E1000_WRITE_REG(hw, FCRTL, (hw->fc_low_water | E1000_FCRTL_XONE));
            E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
        } else {
            E1000_WRITE_REG(hw, FCRTL, hw->fc_low_water);
            E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
        }
    }
    return ret_val;
d1399 160
a1558 144
    uint32_t ctrl;
    uint32_t status;
    uint32_t txcw = 0;
    uint32_t i;
    uint32_t signal = 0;
    int32_t ret_val;

    DEBUGFUNC("em_setup_fiber_serdes_link");

    /* On 82571 and 82572 Fiber connections, SerDes loopback mode persists
     * until explicitly turned off or a power cycle is performed.  A read to
     * the register does not indicate its status.  Therefore, we ensure
     * loopback mode is disabled during initialization.
     */
    if (hw->mac_type == em_82571 || hw->mac_type == em_82572)
        E1000_WRITE_REG(hw, SCTL, E1000_DISABLE_SERDES_LOOPBACK);

    /* On adapters with a MAC newer than 82544, SWDP 1 will be
     * set when the optics detect a signal. On older adapters, it will be
     * cleared when there is a signal.  This applies to fiber media only.
     * If we're on serdes media, adjust the output amplitude to value
     * set in the EEPROM.
     */
    ctrl = E1000_READ_REG(hw, CTRL);
    if (hw->media_type == em_media_type_fiber)
        signal = (hw->mac_type > em_82544) ? E1000_CTRL_SWDPIN1 : 0;

    ret_val = em_adjust_serdes_amplitude(hw);
    if (ret_val)
        return ret_val;

    /* Take the link out of reset */
    ctrl &= ~(E1000_CTRL_LRST);

    /* Adjust VCO speed to improve BER performance */
    ret_val = em_set_vco_speed(hw);
    if (ret_val)
        return ret_val;

    em_config_collision_dist(hw);

    /* Check for a software override of the flow control settings, and setup
     * the device accordingly.  If auto-negotiation is enabled, then software
     * will have to set the "PAUSE" bits to the correct value in the Tranmsit
     * Config Word Register (TXCW) and re-start auto-negotiation.  However, if
     * auto-negotiation is disabled, then software will have to manually
     * configure the two flow control enable bits in the CTRL register.
     *
     * The possible values of the "fc" parameter are:
     *      0:  Flow control is completely disabled
     *      1:  Rx flow control is enabled (we can receive pause frames, but
     *          not send pause frames).
     *      2:  Tx flow control is enabled (we can send pause frames but we do
     *          not support receiving pause frames).
     *      3:  Both Rx and TX flow control (symmetric) are enabled.
     */
    switch (hw->fc) {
    case E1000_FC_NONE:
        /* Flow control is completely disabled by a software over-ride. */
        txcw = (E1000_TXCW_ANE | E1000_TXCW_FD);
        break;
    case E1000_FC_RX_PAUSE:
        /* RX Flow control is enabled and TX Flow control is disabled by a
         * software over-ride. Since there really isn't a way to advertise
         * that we are capable of RX Pause ONLY, we will advertise that we
         * support both symmetric and asymmetric RX PAUSE. Later, we will
         *  disable the adapter's ability to send PAUSE frames.
         */
        txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
        break;
    case E1000_FC_TX_PAUSE:
        /* TX Flow control is enabled, and RX Flow control is disabled, by a
         * software over-ride.
         */
        txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);
        break;
    case E1000_FC_FULL:
        /* Flow control (both RX and TX) is enabled by a software over-ride. */
        txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
        break;
    default:
        DEBUGOUT("Flow control param set incorrectly\n");
        return -E1000_ERR_CONFIG;
        break;
    }

    /* Since auto-negotiation is enabled, take the link out of reset (the link
     * will be in reset, because we previously reset the chip). This will
     * restart auto-negotiation.  If auto-neogtiation is successful then the
     * link-up status bit will be set and the flow control enable bits (RFCE
     * and TFCE) will be set according to their negotiated value.
     */
    DEBUGOUT("Auto-negotiation enabled\n");

    E1000_WRITE_REG(hw, TXCW, txcw);
    E1000_WRITE_REG(hw, CTRL, ctrl);
    E1000_WRITE_FLUSH(hw);

    hw->txcw = txcw;
    msec_delay(1);

    /* If we have a signal (the cable is plugged in) then poll for a "Link-Up"
     * indication in the Device Status Register.  Time-out if a link isn't
     * seen in 500 milliseconds seconds (Auto-negotiation should complete in
     * less than 500 milliseconds even if the other end is doing it in SW).
     * For internal serdes, we just assume a signal is present, then poll.
     */
    if (hw->media_type == em_media_type_internal_serdes ||
       (E1000_READ_REG(hw, CTRL) & E1000_CTRL_SWDPIN1) == signal) {
        DEBUGOUT("Looking for Link\n");
        for (i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
            msec_delay(10);
            status = E1000_READ_REG(hw, STATUS);
            if (status & E1000_STATUS_LU) break;
        }
        if (i == (LINK_UP_TIMEOUT / 10)) {
            DEBUGOUT("Never got a valid link from auto-neg!!!\n");
            hw->autoneg_failed = 1;
            /* AutoNeg failed to achieve a link, so we'll call
             * em_check_for_link. This routine will force the link up if
             * we detect a signal. This will allow us to communicate with
             * non-autonegotiating link partners.
             */
            ret_val = em_check_for_link(hw);
            if (ret_val) {
                DEBUGOUT("Error while checking for link\n");
                return ret_val;
            }
            hw->autoneg_failed = 0;
        } else {
            hw->autoneg_failed = 0;
            DEBUGOUT("Valid Link Found\n");
        }
    } else {
        DEBUGOUT("No Signal Detected\n");
    }
    return E1000_SUCCESS;
}

/******************************************************************************
* Make sure we have a valid PHY and change PHY mode before link setup.
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d1562 44
a1605 41
    uint32_t ctrl;
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_copper_link_preconfig");

    ctrl = E1000_READ_REG(hw, CTRL);
    /* With 82543, we need to force speed and duplex on the MAC equal to what
     * the PHY speed and duplex configuration is. In addition, we need to
     * perform a hardware reset on the PHY to take it out of reset.
     */
    if (hw->mac_type > em_82543) {
        ctrl |= E1000_CTRL_SLU;
        ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
        E1000_WRITE_REG(hw, CTRL, ctrl);
    } else {
        ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | E1000_CTRL_SLU);
        E1000_WRITE_REG(hw, CTRL, ctrl);
        ret_val = em_phy_hw_reset(hw);
        if (ret_val)
            return ret_val;
    }

    /* Set PHY to class A mode (if necessary) */
    ret_val = em_set_phy_mode(hw);
    if (ret_val)
        return ret_val;

    if ((hw->mac_type == em_82545_rev_3) ||
       (hw->mac_type == em_82546_rev_3)) {
        ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
        phy_data |= 0x00000008;
        ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
    }

    if (hw->mac_type <= em_82543 ||
        hw->mac_type == em_82541 || hw->mac_type == em_82547 ||
        hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2)
        hw->phy_reset_disable = FALSE;

   return E1000_SUCCESS;
d1608 5
a1612 6

/********************************************************************
* Copper link setup for em_phy_igp series.
*
* hw - Struct containing variables accessed by shared code
*********************************************************************/
d1616 144
a1759 147
    uint32_t led_ctrl;
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_copper_link_igp_setup");

    if (hw->phy_reset_disable)
        return E1000_SUCCESS;

    ret_val = em_phy_reset(hw);
    if (ret_val) {
        DEBUGOUT("Error Resetting the PHY\n");
        return ret_val;
    }

    /* Wait 15ms for MAC to configure PHY from eeprom settings */
    msec_delay(15);
    if (hw->mac_type != em_ich8lan &&
        hw->mac_type != em_ich9lan &&
        hw->mac_type != em_ich10lan) {
        /* Configure activity LED after PHY reset */
        led_ctrl = E1000_READ_REG(hw, LEDCTL);
        led_ctrl &= IGP_ACTIVITY_LED_MASK;
        led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
        E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
    }

    /* The NVM settings will configure LPLU in D3 for IGP2 and IGP3 PHYs */
    if (hw->phy_type == em_phy_igp) {
        /* disable lplu d3 during driver init */
        ret_val = em_set_d3_lplu_state(hw, FALSE);
        if (ret_val) {
            DEBUGOUT("Error Disabling LPLU D3\n");
            return ret_val;
        }
    }

    /* disable lplu d0 during driver init */
    ret_val = em_set_d0_lplu_state(hw, FALSE);
    if (ret_val) {
        DEBUGOUT("Error Disabling LPLU D0\n");
        return ret_val;
    }
    /* Configure mdi-mdix settings */
    ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
    if (ret_val)
        return ret_val;

    if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
        hw->dsp_config_state = em_dsp_config_disabled;
        /* Force MDI for earlier revs of the IGP PHY */
        phy_data &= ~(IGP01E1000_PSCR_AUTO_MDIX | IGP01E1000_PSCR_FORCE_MDI_MDIX);
        hw->mdix = 1;

    } else {
        hw->dsp_config_state = em_dsp_config_enabled;
        phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;

        switch (hw->mdix) {
        case 1:
            phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
            break;
        case 2:
            phy_data |= IGP01E1000_PSCR_FORCE_MDI_MDIX;
            break;
        case 0:
        default:
            phy_data |= IGP01E1000_PSCR_AUTO_MDIX;
            break;
        }
    }
    ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);
    if (ret_val)
        return ret_val;

    /* set auto-master slave resolution settings */
    if (hw->autoneg) {
        em_ms_type phy_ms_setting = hw->master_slave;

        if (hw->ffe_config_state == em_ffe_config_active)
            hw->ffe_config_state = em_ffe_config_enabled;

        if (hw->dsp_config_state == em_dsp_config_activated)
            hw->dsp_config_state = em_dsp_config_enabled;

        /* when autonegotiation advertisement is only 1000Mbps then we
          * should disable SmartSpeed and enable Auto MasterSlave
          * resolution as hardware default. */
        if (hw->autoneg_advertised == ADVERTISE_1000_FULL) {
            /* Disable SmartSpeed */
            ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                         &phy_data);
            if (ret_val)
                return ret_val;
            phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
            ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                          phy_data);
            if (ret_val)
                return ret_val;
            /* Set auto Master/Slave resolution process */
            ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
            if (ret_val)
                return ret_val;
            phy_data &= ~CR_1000T_MS_ENABLE;
            ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
            if (ret_val)
                return ret_val;
        }

        ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
        if (ret_val)
            return ret_val;

        /* load defaults for future use */
        hw->original_master_slave = (phy_data & CR_1000T_MS_ENABLE) ?
                                        ((phy_data & CR_1000T_MS_VALUE) ?
                                         em_ms_force_master :
                                         em_ms_force_slave) :
                                         em_ms_auto;

        switch (phy_ms_setting) {
        case em_ms_force_master:
            phy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);
            break;
        case em_ms_force_slave:
            phy_data |= CR_1000T_MS_ENABLE;
            phy_data &= ~(CR_1000T_MS_VALUE);
            break;
        case em_ms_auto:
            phy_data &= ~CR_1000T_MS_ENABLE;
            break;
        default:
            break;
        }
        ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
        if (ret_val)
            return ret_val;
    }

    return E1000_SUCCESS;
}

/********************************************************************
* Copper link setup for em_phy_gg82563 series.
*
* hw - Struct containing variables accessed by shared code
*********************************************************************/
d1763 137
a1899 122
    int32_t ret_val;
    uint16_t phy_data;
    uint32_t reg_data;

    DEBUGFUNC("em_copper_link_ggp_setup");

    if (!hw->phy_reset_disable) {

        /* Enable CRS on TX for half-duplex operation. */
        ret_val = em_read_phy_reg(hw, GG82563_PHY_MAC_SPEC_CTRL,
                                     &phy_data);
        if (ret_val)
            return ret_val;

        phy_data |= GG82563_MSCR_ASSERT_CRS_ON_TX;
        /* Use 25MHz for both link down and 1000BASE-T for Tx clock */
        phy_data |= GG82563_MSCR_TX_CLK_1000MBPS_25MHZ;

        ret_val = em_write_phy_reg(hw, GG82563_PHY_MAC_SPEC_CTRL,
                                      phy_data);
        if (ret_val)
            return ret_val;

        /* Options:
         *   MDI/MDI-X = 0 (default)
         *   0 - Auto for all speeds
         *   1 - MDI mode
         *   2 - MDI-X mode
         *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
         */
        ret_val = em_read_phy_reg(hw, GG82563_PHY_SPEC_CTRL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data &= ~GG82563_PSCR_CROSSOVER_MODE_MASK;

        switch (hw->mdix) {
        case 1:
            phy_data |= GG82563_PSCR_CROSSOVER_MODE_MDI;
            break;
        case 2:
            phy_data |= GG82563_PSCR_CROSSOVER_MODE_MDIX;
            break;
        case 0:
        default:
            phy_data |= GG82563_PSCR_CROSSOVER_MODE_AUTO;
            break;
        }

        /* Options:
         *   disable_polarity_correction = 0 (default)
         *       Automatic Correction for Reversed Cable Polarity
         *   0 - Disabled
         *   1 - Enabled
         */
        phy_data &= ~GG82563_PSCR_POLARITY_REVERSAL_DISABLE;
        if (hw->disable_polarity_correction == 1)
            phy_data |= GG82563_PSCR_POLARITY_REVERSAL_DISABLE;
        ret_val = em_write_phy_reg(hw, GG82563_PHY_SPEC_CTRL, phy_data);

        if (ret_val)
            return ret_val;

        /* SW Reset the PHY so all changes take effect */
        ret_val = em_phy_reset(hw);
        if (ret_val) {
            DEBUGOUT("Error Resetting the PHY\n");
            return ret_val;
        }
    } /* phy_reset_disable */

    if (hw->mac_type == em_80003es2lan) {
        /* Bypass RX and TX FIFO's */
        ret_val = em_write_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_FIFO_CTRL,
                                       E1000_KUMCTRLSTA_FIFO_CTRL_RX_BYPASS |
                                       E1000_KUMCTRLSTA_FIFO_CTRL_TX_BYPASS);
        if (ret_val)
            return ret_val;

        ret_val = em_read_phy_reg(hw, GG82563_PHY_SPEC_CTRL_2, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data &= ~GG82563_PSCR2_REVERSE_AUTO_NEG;
        ret_val = em_write_phy_reg(hw, GG82563_PHY_SPEC_CTRL_2, phy_data);

        if (ret_val)
            return ret_val;

        reg_data = E1000_READ_REG(hw, CTRL_EXT);
        reg_data &= ~(E1000_CTRL_EXT_LINK_MODE_MASK);
        E1000_WRITE_REG(hw, CTRL_EXT, reg_data);

        ret_val = em_read_phy_reg(hw, GG82563_PHY_PWR_MGMT_CTRL,
                                          &phy_data);
        if (ret_val)
            return ret_val;

        /* Do not init these registers when the HW is in IAMT mode, since the
         * firmware will have already initialized them.  We only initialize
         * them if the HW is not in IAMT mode.
         */
        if (em_check_mng_mode(hw) == FALSE) {
            /* Enable Electrical Idle on the PHY */
            phy_data |= GG82563_PMCR_ENABLE_ELECTRICAL_IDLE;
            ret_val = em_write_phy_reg(hw, GG82563_PHY_PWR_MGMT_CTRL,
                                          phy_data);
            if (ret_val)
                return ret_val;

            ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL,
                                         &phy_data);
            if (ret_val)
                return ret_val;

            phy_data &= ~GG82563_KMCR_PASS_FALSE_CARRIER;
            ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL,
                                          phy_data);

            if (ret_val)
                return ret_val;
        }
d1901 5
a1905 22
        /* Workaround: Disable padding in Kumeran interface in the MAC
         * and in the PHY to avoid CRC errors.
         */
        ret_val = em_read_phy_reg(hw, GG82563_PHY_INBAND_CTRL,
                                     &phy_data);
        if (ret_val)
            return ret_val;
        phy_data |= GG82563_ICR_DIS_PADDING;
        ret_val = em_write_phy_reg(hw, GG82563_PHY_INBAND_CTRL,
                                      phy_data);
        if (ret_val)
            return ret_val;
    }

    return E1000_SUCCESS;
}

/********************************************************************
* Copper link setup for em_phy_m88 series.
*
* hw - Struct containing variables accessed by shared code
*********************************************************************/
d1909 36
a1944 2
    int32_t ret_val;
    uint16_t phy_data;
d1946 94
a2039 1
    DEBUGFUNC("em_copper_link_mgp_setup");
d2041 6
a2046 141
    if (hw->phy_reset_disable)
        return E1000_SUCCESS;

    /* Enable CRS on TX. This must be set for half-duplex operation. */
    ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
    if (ret_val)
        return ret_val;

    if (hw->phy_id == M88E1141_E_PHY_ID) {
        phy_data |= 0x00000008;
        ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
        if (ret_val)
            return ret_val;
            
        ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
        if (ret_val)
            return ret_val;
    	            
        phy_data &= ~M88E1000_PSCR_ASSERT_CRS_ON_TX;

    } 
    /* For BM PHY this bit is downshift enable */
    else if (hw->phy_type != em_phy_bm)
        phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;

    /* Options:
     *   MDI/MDI-X = 0 (default)
     *   0 - Auto for all speeds
     *   1 - MDI mode
     *   2 - MDI-X mode
     *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
     */
    phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;

    switch (hw->mdix) {
    case 1:
        phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
        break;
    case 2:
        phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
        break;
    case 3:
        phy_data |= M88E1000_PSCR_AUTO_X_1000T;
        break;
    case 0:
    default:
        phy_data |= M88E1000_PSCR_AUTO_X_MODE;
        break;
    }

    /* Options:
     *   disable_polarity_correction = 0 (default)
     *       Automatic Correction for Reversed Cable Polarity
     *   0 - Disabled
     *   1 - Enabled
     */
    phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
    if (hw->disable_polarity_correction == 1)
        phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;

    /* Enable downshift on BM (disabled by default) */
    if (hw->phy_type == em_phy_bm)
        phy_data |= BME1000_PSCR_ENABLE_DOWNSHIFT;

    ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
    if (ret_val)
        return ret_val;

    if (((hw->phy_type == em_phy_m88) &&
        (hw->phy_revision < M88E1011_I_REV_4) &&
        (hw->phy_id != BME1000_E_PHY_ID)) ||
        (hw->phy_type == em_phy_oem)) {

        /* Force TX_CLK in the Extended PHY Specific Control Register
         * to 25MHz clock.
         */
        ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);
        if (ret_val)
            return ret_val;

        if (hw->phy_type == em_phy_oem) {
            phy_data |= M88E1000_EPSCR_TX_TIME_CTRL;
            phy_data |= M88E1000_EPSCR_RX_TIME_CTRL;
        }
	
        phy_data |= M88E1000_EPSCR_TX_CLK_25;

        if ((hw->phy_revision == E1000_REVISION_2) &&
            (hw->phy_id == M88E1111_I_PHY_ID)) {
            /* Vidalia Phy, set the downshift counter to 5x */
            phy_data &= ~(M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK);
            phy_data |= M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X;
            ret_val = em_write_phy_reg(hw,
                                        M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
            if (ret_val)
                return ret_val;
        } else {
            /* Configure Master and Slave downshift values */
            phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
                              M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
            phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
                             M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
            ret_val = em_write_phy_reg(hw,
                                        M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
            if (ret_val)
               return ret_val;
        }
    }

    if ((hw->phy_type == em_phy_bm) && (hw->phy_revision == 1)) {
        /*
    	 * Set PHY page 0, register 29 to 0x0003
         * The next two writes are supposed to lower BER for gig
         * conection
	 */
        ret_val = em_write_phy_reg(hw, BM_REG_BIAS1, 0x0003);
      	if (ret_val)
            return ret_val;

        /* Set PHY page 0, register 30 to 0x0000 */
        ret_val = em_write_phy_reg(hw, BM_REG_BIAS2, 0x0000);
        if (ret_val)
            return ret_val;
    }

    /* SW Reset the PHY so all changes take effect */
    ret_val = em_phy_reset(hw);
    if (ret_val) {
        DEBUGOUT("Error Resetting the PHY\n");
        return ret_val;
    }

   return E1000_SUCCESS;
}

/********************************************************************
* Setup auto-negotiation and flow control advertisements,
* and then perform auto-negotiation.
*
* hw - Struct containing variables accessed by shared code
*********************************************************************/
d2050 14
a2063 2
    int32_t ret_val;
    uint16_t phy_data;
d2065 39
a2103 1
    DEBUGFUNC("em_copper_link_autoneg");
d2105 12
a2116 63
    /* Perform some bounds checking on the hw->autoneg_advertised
     * parameter.  If this variable is zero, then set it to the default.
     */
    hw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;

    /* If autoneg_advertised is zero, we assume it was not defaulted
     * by the calling code so we set to advertise full capability.
     */
    if (hw->autoneg_advertised == 0)
        hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;

    /* IFE phy only supports 10/100 */
    if (hw->phy_type == em_phy_ife)
        hw->autoneg_advertised &= AUTONEG_ADVERTISE_10_100_ALL;

    DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
    ret_val = em_phy_setup_autoneg(hw);
    if (ret_val) {
        DEBUGOUT("Error Setting up Auto-Negotiation\n");
        return ret_val;
    }
    DEBUGOUT("Restarting Auto-Neg\n");

    /* Restart auto-negotiation by setting the Auto Neg Enable bit and
     * the Auto Neg Restart bit in the PHY control register.
     */
    ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data);
    if (ret_val)
        return ret_val;

    phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
    ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data);
    if (ret_val)
        return ret_val;

    /* Does the user want to wait for Auto-Neg to complete here, or
     * check at a later time (for example, callback routine).
     */
    if (hw->wait_autoneg_complete) {
        ret_val = em_wait_autoneg(hw);
        if (ret_val) {
            DEBUGOUT("Error while waiting for autoneg to complete\n");
            return ret_val;
        }
    }

    hw->get_link_status = TRUE;

    return E1000_SUCCESS;
}

/******************************************************************************
* Config the MAC and the PHY after link is up.
*   1) Set up the MAC to the current PHY speed/duplex
*      if we are on 82543.  If we
*      are on newer silicon, we only need to configure
*      collision distance in the Transmit Control Register.
*   2) Set up flow control on the MAC to that established with
*      the link partner.
*   3) Config DSP to improve Gigabit link quality for some PHY revisions.
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d2120 2
a2121 2
    int32_t ret_val;
    DEBUGFUNC("em_copper_link_postconfig");
d2123 24
a2146 26
    if (hw->mac_type >= em_82544 &&
	hw->mac_type != em_icp_xxxx) {
        em_config_collision_dist(hw);
    } else {
        ret_val = em_config_mac_to_phy(hw);
        if (ret_val) {
            DEBUGOUT("Error configuring MAC to PHY settings\n");
            return ret_val;
        }
    }
    ret_val = em_config_fc_after_link_up(hw);
    if (ret_val) {
        DEBUGOUT("Error Configuring Flow Control\n");
        return ret_val;
    }

    /* Config DSP to improve Giga link quality */
    if (hw->phy_type == em_phy_igp) {
        ret_val = em_config_dsp_after_link_change(hw, TRUE);
        if (ret_val) {
            DEBUGOUT("Error Configuring DSP after link up\n");
            return ret_val;
        }
    }

    return E1000_SUCCESS;
d2150 4
a2153 4
* Detects which PHY is present and setup the speed and duplex
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d2157 124
a2280 117
    int32_t ret_val;
    uint16_t i;
    uint16_t phy_data;
    uint16_t reg_data;

    DEBUGFUNC("em_setup_copper_link");

    switch (hw->mac_type) {
    case em_80003es2lan:
    case em_ich8lan:
    case em_ich9lan:
    case em_ich10lan:
        /* Set the mac to wait the maximum time between each
         * iteration and increase the max iterations when
         * polling the phy; this fixes erroneous timeouts at 10Mbps. */
        ret_val = em_write_kmrn_reg(hw, GG82563_REG(0x34, 4), 0xFFFF);
        if (ret_val)
            return ret_val;
        ret_val = em_read_kmrn_reg(hw, GG82563_REG(0x34, 9), &reg_data);
        if (ret_val)
            return ret_val;
        reg_data |= 0x3F;
        ret_val = em_write_kmrn_reg(hw, GG82563_REG(0x34, 9), reg_data);
        if (ret_val)
            return ret_val;
    default:
        break;
    }

    /* Check if it is a valid PHY and set PHY mode if necessary. */
    ret_val = em_copper_link_preconfig(hw);
    if (ret_val)
        return ret_val;

    switch (hw->mac_type) {
    case em_80003es2lan:
        /* Kumeran registers are written-only */
        reg_data = E1000_KUMCTRLSTA_INB_CTRL_LINK_STATUS_TX_TIMEOUT_DEFAULT;
        reg_data |= E1000_KUMCTRLSTA_INB_CTRL_DIS_PADDING;
        ret_val = em_write_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_INB_CTRL,
                                       reg_data);
        if (ret_val)
            return ret_val;
        break;
    default:
        break;
    }

    if (hw->phy_type == em_phy_igp ||
        hw->phy_type == em_phy_igp_3 ||
        hw->phy_type == em_phy_igp_2) {
        ret_val = em_copper_link_igp_setup(hw);
        if (ret_val)
            return ret_val;
    } else if (hw->phy_type == em_phy_m88 ||
               hw->phy_type == em_phy_bm ||
               hw->phy_type == em_phy_oem) {
        ret_val = em_copper_link_mgp_setup(hw);
        if (ret_val)
            return ret_val;
    } else if (hw->phy_type == em_phy_gg82563) {
        ret_val = em_copper_link_ggp_setup(hw);
        if (ret_val)
            return ret_val;
    }

    if (hw->autoneg) {
        /* Setup autoneg and flow control advertisement
          * and perform autonegotiation */
        ret_val = em_copper_link_autoneg(hw);
        if (ret_val)
            return ret_val;
    } else {
        /* PHY will be set to 10H, 10F, 100H,or 100F
          * depending on value from forced_speed_duplex. */
        DEBUGOUT("Forcing speed and duplex\n");
        ret_val = em_phy_force_speed_duplex(hw);
        if (ret_val) {
            DEBUGOUT("Error Forcing Speed and Duplex\n");
            return ret_val;
        }
    }

    /* Check link status. Wait up to 100 microseconds for link to become
     * valid.
     */
    for (i = 0; i < 10; i++) {
        ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
        if (ret_val)
            return ret_val;
        ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
        if (ret_val)
            return ret_val;

        hw->icp_xxxx_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;
         
        if (phy_data & MII_SR_LINK_STATUS) {
            /* Config the MAC and PHY after link is up */
            ret_val = em_copper_link_postconfig(hw);
            if (ret_val)
                return ret_val;

            DEBUGOUT("Valid link established!!!\n");
            return E1000_SUCCESS;
        }
        usec_delay(10);
    }

    DEBUGOUT("Unable to establish link!!!\n");
    return E1000_SUCCESS;
}

/******************************************************************************
* Configure the MAC-to-PHY interface for 10/100Mbps
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d2284 26
a2309 11
    int32_t ret_val = E1000_SUCCESS;
    uint32_t tipg;
    uint16_t reg_data;

    DEBUGFUNC("em_configure_kmrn_for_10_100");

    reg_data = E1000_KUMCTRLSTA_HD_CTRL_10_100_DEFAULT;
    ret_val = em_write_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_HD_CTRL,
                                   reg_data);
    if (ret_val)
        return ret_val;
d2311 1
a2311 5
    /* Configure Transmit Inter-Packet Gap */
    tipg = E1000_READ_REG(hw, TIPG);
    tipg &= ~E1000_TIPG_IPGT_MASK;
    tipg |= DEFAULT_80003ES2LAN_TIPG_IPGT_10_100;
    E1000_WRITE_REG(hw, TIPG, tipg);
d2313 1
a2313 13
    ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data);

    if (ret_val)
        return ret_val;

    if (duplex == HALF_DUPLEX)
        reg_data |= GG82563_KMCR_PASS_FALSE_CARRIER;
    else
        reg_data &= ~GG82563_KMCR_PASS_FALSE_CARRIER;

    ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, reg_data);

    return ret_val;
d2319 4
a2322 3
    int32_t ret_val = E1000_SUCCESS;
    uint16_t reg_data;
    uint32_t tipg;
d2324 5
a2328 1
    DEBUGFUNC("em_configure_kmrn_for_1000");
d2330 5
a2334 5
    reg_data = E1000_KUMCTRLSTA_HD_CTRL_1000_DEFAULT;
    ret_val = em_write_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_HD_CTRL,
                                   reg_data);
    if (ret_val)
        return ret_val;
d2336 1
a2336 5
    /* Configure Transmit Inter-Packet Gap */
    tipg = E1000_READ_REG(hw, TIPG);
    tipg &= ~E1000_TIPG_IPGT_MASK;
    tipg |= DEFAULT_80003ES2LAN_TIPG_IPGT_1000;
    E1000_WRITE_REG(hw, TIPG, tipg);
d2338 2
a2339 1
    ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data);
d2341 2
a2342 2
    if (ret_val)
        return ret_val;
d2344 1
a2344 4
    reg_data &= ~GG82563_KMCR_PASS_FALSE_CARRIER;
    ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, reg_data);

    return ret_val;
d2348 4
a2351 4
* Configures PHY autoneg and flow control advertisement settings
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d2355 31
a2385 125
    int32_t ret_val;
    uint16_t mii_autoneg_adv_reg;
    uint16_t mii_1000t_ctrl_reg;

    DEBUGFUNC("em_phy_setup_autoneg");

    /* Read the MII Auto-Neg Advertisement Register (Address 4). */
    ret_val = em_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);
    if (ret_val)
        return ret_val;

    if (hw->phy_type != em_phy_ife) {
        /* Read the MII 1000Base-T Control Register (Address 9). */
        ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);
        if (ret_val)
            return ret_val;
    } else
        mii_1000t_ctrl_reg=0;

    /* Need to parse both autoneg_advertised and fc and set up
     * the appropriate PHY registers.  First we will parse for
     * autoneg_advertised software override.  Since we can advertise
     * a plethora of combinations, we need to check each bit
     * individually.
     */

    /* First we clear all the 10/100 mb speed bits in the Auto-Neg
     * Advertisement Register (Address 4) and the 1000 mb speed bits in
     * the  1000Base-T Control Register (Address 9).
     */
    mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
    mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;

    DEBUGOUT1("autoneg_advertised %x\n", hw->autoneg_advertised);

    /* Do we want to advertise 10 Mb Half Duplex? */
    if (hw->autoneg_advertised & ADVERTISE_10_HALF) {
        DEBUGOUT("Advertise 10mb Half duplex\n");
        mii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;
    }

    /* Do we want to advertise 10 Mb Full Duplex? */
    if (hw->autoneg_advertised & ADVERTISE_10_FULL) {
        DEBUGOUT("Advertise 10mb Full duplex\n");
        mii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;
    }

    /* Do we want to advertise 100 Mb Half Duplex? */
    if (hw->autoneg_advertised & ADVERTISE_100_HALF) {
        DEBUGOUT("Advertise 100mb Half duplex\n");
        mii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;
    }

    /* Do we want to advertise 100 Mb Full Duplex? */
    if (hw->autoneg_advertised & ADVERTISE_100_FULL) {
        DEBUGOUT("Advertise 100mb Full duplex\n");
        mii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;
    }

    /* We do not allow the Phy to advertise 1000 Mb Half Duplex */
    if (hw->autoneg_advertised & ADVERTISE_1000_HALF) {
        DEBUGOUT("Advertise 1000mb Half duplex requested, request denied!\n");
    }

    /* Do we want to advertise 1000 Mb Full Duplex? */
    if (hw->autoneg_advertised & ADVERTISE_1000_FULL) {
        DEBUGOUT("Advertise 1000mb Full duplex\n");
        mii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;
        if (hw->phy_type == em_phy_ife) {
            DEBUGOUT("em_phy_ife is a 10/100 PHY. Gigabit speed is not supported.\n");
        }
    }

    /* Check for a software override of the flow control settings, and
     * setup the PHY advertisement registers accordingly.  If
     * auto-negotiation is enabled, then software will have to set the
     * "PAUSE" bits to the correct value in the Auto-Negotiation
     * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.
     *
     * The possible values of the "fc" parameter are:
     *      0:  Flow control is completely disabled
     *      1:  Rx flow control is enabled (we can receive pause frames
     *          but not send pause frames).
     *      2:  Tx flow control is enabled (we can send pause frames
     *          but we do not support receiving pause frames).
     *      3:  Both Rx and TX flow control (symmetric) are enabled.
     *  other:  No software override.  The flow control configuration
     *          in the EEPROM is used.
     */
    switch (hw->fc) {
    case E1000_FC_NONE: /* 0 */
        /* Flow control (RX & TX) is completely disabled by a
         * software over-ride.
         */
        mii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
        break;
    case E1000_FC_RX_PAUSE: /* 1 */
        /* RX Flow control is enabled, and TX Flow control is
         * disabled, by a software over-ride.
         */
        /* Since there really isn't a way to advertise that we are
         * capable of RX Pause ONLY, we will advertise that we
         * support both symmetric and asymmetric RX PAUSE.  Later
         * (in em_config_fc_after_link_up) we will disable the
         *hw's ability to send PAUSE frames.
         */
        mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
        break;
    case E1000_FC_TX_PAUSE: /* 2 */
        /* TX Flow control is enabled, and RX Flow control is
         * disabled, by a software over-ride.
         */
        mii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;
        mii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;
        break;
    case E1000_FC_FULL: /* 3 */
        /* Flow control (both RX and TX) is enabled by a software
         * over-ride.
         */
        mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
        break;
    default:
        DEBUGOUT("Flow control param set incorrectly\n");
        return -E1000_ERR_CONFIG;
    }
d2387 1
a2387 3
    ret_val = em_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);
    if (ret_val)
        return ret_val;
d2389 105
a2493 9
    DEBUGOUT1("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);

    if (hw->phy_type != em_phy_ife) {
        ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg);
        if (ret_val)
            return ret_val;
    }

    return E1000_SUCCESS;
a2494 1

d2496 4
a2499 4
* Force PHY speed and duplex settings to hw->forced_speed_duplex
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d2503 280
a2782 249
    uint32_t ctrl;
    int32_t ret_val;
    uint16_t mii_ctrl_reg;
    uint16_t mii_status_reg;
    uint16_t phy_data;
    uint16_t i;

    DEBUGFUNC("em_phy_force_speed_duplex");

    /* Turn off Flow control if we are forcing speed and duplex. */
    hw->fc = E1000_FC_NONE;

    DEBUGOUT1("hw->fc = %d\n", hw->fc);

    /* Read the Device Control Register. */
    ctrl = E1000_READ_REG(hw, CTRL);

    /* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
    ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
    ctrl &= ~(DEVICE_SPEED_MASK);

    /* Clear the Auto Speed Detect Enable bit. */
    ctrl &= ~E1000_CTRL_ASDE;

    /* Read the MII Control Register. */
    ret_val = em_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg);
    if (ret_val)
        return ret_val;

    /* We need to disable autoneg in order to force link and duplex. */

    mii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;

    /* Are we forcing Full or Half Duplex? */
    if (hw->forced_speed_duplex == em_100_full ||
        hw->forced_speed_duplex == em_10_full) {
        /* We want to force full duplex so we SET the full duplex bits in the
         * Device and MII Control Registers.
         */
        ctrl |= E1000_CTRL_FD;
        mii_ctrl_reg |= MII_CR_FULL_DUPLEX;
        DEBUGOUT("Full Duplex\n");
    } else {
        /* We want to force half duplex so we CLEAR the full duplex bits in
         * the Device and MII Control Registers.
         */
        ctrl &= ~E1000_CTRL_FD;
        mii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;
        DEBUGOUT("Half Duplex\n");
    }

    /* Are we forcing 100Mbps??? */
    if (hw->forced_speed_duplex == em_100_full ||
       hw->forced_speed_duplex == em_100_half) {
        /* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
        ctrl |= E1000_CTRL_SPD_100;
        mii_ctrl_reg |= MII_CR_SPEED_100;
        mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);
        DEBUGOUT("Forcing 100mb ");
    } else {
        /* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
        ctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
        mii_ctrl_reg |= MII_CR_SPEED_10;
        mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);
        DEBUGOUT("Forcing 10mb ");
    }

    em_config_collision_dist(hw);

    /* Write the configured values back to the Device Control Reg. */
    E1000_WRITE_REG(hw, CTRL, ctrl);

    if ((hw->phy_type == em_phy_m88) ||
        (hw->phy_type == em_phy_gg82563) ||
        (hw->phy_type == em_phy_bm) ||
        (hw->phy_type == em_phy_oem)) {
        ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
        if (ret_val)
            return ret_val;

        /* Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI
         * forced whenever speed are duplex are forced.
         */
        phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
        ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
        if (ret_val)
            return ret_val;

        DEBUGOUT1("M88E1000 PSCR: %x \n", phy_data);

        /* Need to reset the PHY or these changes will be ignored */
        mii_ctrl_reg |= MII_CR_RESET;

    }

    /* Disable MDI-X support for 10/100 */
    else if (hw->phy_type == em_phy_ife) {
        ret_val = em_read_phy_reg(hw, IFE_PHY_MDIX_CONTROL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data &= ~IFE_PMC_AUTO_MDIX;
        phy_data &= ~IFE_PMC_FORCE_MDIX;

        ret_val = em_write_phy_reg(hw, IFE_PHY_MDIX_CONTROL, phy_data);
        if (ret_val)
            return ret_val;
    } else {
        /* Clear Auto-Crossover to force MDI manually.  IGP requires MDI
         * forced whenever speed or duplex are forced.
         */
        ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
        phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;

        ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);
        if (ret_val)
            return ret_val;
    }

    /* Write back the modified PHY MII control register. */
    ret_val = em_write_phy_reg(hw, PHY_CTRL, mii_ctrl_reg);
    if (ret_val)
        return ret_val;

    usec_delay(1);

    /* The wait_autoneg_complete flag may be a little misleading here.
     * Since we are forcing speed and duplex, Auto-Neg is not enabled.
     * But we do want to delay for a period while forcing only so we
     * don't generate false No Link messages.  So we will wait here
     * only if the user has set wait_autoneg_complete to 1, which is
     * the default.
     */
    if (hw->wait_autoneg_complete) {
        /* We will wait for autoneg to complete. */
        DEBUGOUT("Waiting for forced speed/duplex link.\n");
        mii_status_reg = 0;

        /* We will wait for autoneg to complete or 4.5 seconds to expire. */
        for (i = PHY_FORCE_TIME; i > 0; i--) {
            /* Read the MII Status Register and wait for Auto-Neg Complete bit
             * to be set.
             */
            ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
            if (ret_val)
                return ret_val;

            ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
            if (ret_val)
                return ret_val;

            if (mii_status_reg & MII_SR_LINK_STATUS) break;
            msec_delay(100);
        }
        if ((i == 0) &&
           ((hw->phy_type == em_phy_m88) ||
            (hw->phy_type == em_phy_gg82563) ||
            (hw->phy_type == em_phy_bm))) {
            /* We didn't get link.  Reset the DSP and wait again for link. */
            ret_val = em_phy_reset_dsp(hw);
            if (ret_val) {
                DEBUGOUT("Error Resetting PHY DSP\n");
                return ret_val;
            }
        }

        /* This loop will early-out if the link condition has been met.  */
        for (i = PHY_FORCE_TIME; i > 0; i--) {
            if (mii_status_reg & MII_SR_LINK_STATUS) break;
            msec_delay(100);
            /* Read the MII Status Register and wait for Auto-Neg Complete bit
             * to be set.
             */
            ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
            if (ret_val)
                return ret_val;

            ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
            if (ret_val)
                return ret_val;
        }
    }

    if (hw->phy_type == em_phy_m88 ||
        hw->phy_type == em_phy_bm ||
        hw->phy_type == em_phy_oem) {
        /* Because we reset the PHY above, we need to re-force TX_CLK in the
         * Extended PHY Specific Control Register to 25MHz clock.  This value
         * defaults back to a 2.5MHz clock when the PHY is reset.
         */
        ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data |= M88E1000_EPSCR_TX_CLK_25;
        ret_val = em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
        if (ret_val)
            return ret_val;

        /* In addition, because of the s/w reset above, we need to enable CRS on
         * TX.  This must be set for both full and half duplex operation.
         */
        ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
        if (ret_val)
            return ret_val;

        if ( hw->phy_id == M88E1141_E_PHY_ID)
            phy_data &= ~M88E1000_PSCR_ASSERT_CRS_ON_TX;
        else
            phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;

        ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
        if (ret_val)
            return ret_val;

        if ((hw->mac_type == em_82544 || hw->mac_type == em_82543) &&
            (!hw->autoneg) && (hw->forced_speed_duplex == em_10_full ||
             hw->forced_speed_duplex == em_10_half)) {
            ret_val = em_polarity_reversal_workaround(hw);
            if (ret_val)
                return ret_val;
        }
    } else if (hw->phy_type == em_phy_gg82563) {
        /* The TX_CLK of the Extended PHY Specific Control Register defaults
         * to 2.5MHz on a reset.  We need to re-force it back to 25MHz, if
         * we're not in a forced 10/duplex configuration. */
        ret_val = em_read_phy_reg(hw, GG82563_PHY_MAC_SPEC_CTRL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data &= ~GG82563_MSCR_TX_CLK_MASK;
        if ((hw->forced_speed_duplex == em_10_full) ||
            (hw->forced_speed_duplex == em_10_half))
            phy_data |= GG82563_MSCR_TX_CLK_10MBPS_2_5MHZ;
        else
            phy_data |= GG82563_MSCR_TX_CLK_100MBPS_25MHZ;

        /* Also due to the reset, we need to enable CRS on Tx. */
        phy_data |= GG82563_MSCR_ASSERT_CRS_ON_TX;

        ret_val = em_write_phy_reg(hw, GG82563_PHY_MAC_SPEC_CTRL, phy_data);
        if (ret_val)
            return ret_val;
    }
    return E1000_SUCCESS;
d2786 7
a2792 7
* Sets the collision distance in the Transmit Control register
*
* hw - Struct containing variables accessed by shared code
*
* Link should have been established previously. Reads the speed and duplex
* information from the Device Status register.
******************************************************************************/
d2796 2
a2797 3
    uint32_t tctl, coll_dist;

    DEBUGFUNC("em_config_collision_dist");
d2799 4
a2802 4
    if (hw->mac_type < em_82543)
        coll_dist = E1000_COLLISION_DISTANCE_82542;
    else
        coll_dist = E1000_COLLISION_DISTANCE;
d2804 1
a2804 1
    tctl = E1000_READ_REG(hw, TCTL);
d2806 2
a2807 2
    tctl &= ~E1000_TCTL_COLD;
    tctl |= coll_dist << E1000_COLD_SHIFT;
d2809 2
a2810 2
    E1000_WRITE_REG(hw, TCTL, tctl);
    E1000_WRITE_FLUSH(hw);
d2814 8
a2821 8
* Sets MAC speed and duplex settings to reflect the those in the PHY
*
* hw - Struct containing variables accessed by shared code
* mii_reg - data to write to the MII control register
*
* The contents of the PHY register containing the needed information need to
* be passed in.
******************************************************************************/
d2825 44
a2868 44
    uint32_t ctrl;
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_config_mac_to_phy");

    /* 82544 or newer MAC, Auto Speed Detection takes care of
    * MAC speed/duplex configuration.*/
    if (hw->mac_type >= em_82544
	&& hw->mac_type != em_icp_xxxx)
        return E1000_SUCCESS;

    /* Read the Device Control Register and set the bits to Force Speed
     * and Duplex.
     */
    ctrl = E1000_READ_REG(hw, CTRL);
    ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
    ctrl &= ~(E1000_CTRL_SPD_SEL | E1000_CTRL_ILOS);

    /* Set up duplex in the Device Control and Transmit Control
     * registers depending on negotiated values.
     */
    ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
    if (ret_val)
        return ret_val;

    if (phy_data & M88E1000_PSSR_DPLX)
        ctrl |= E1000_CTRL_FD;
    else
        ctrl &= ~E1000_CTRL_FD;

    em_config_collision_dist(hw);

    /* Set up speed in the Device Control register depending on
     * negotiated values.
     */
    if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
        ctrl |= E1000_CTRL_SPD_1000;
    else if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
        ctrl |= E1000_CTRL_SPD_100;

    /* Write the configured values back to the Device Control Reg. */
    E1000_WRITE_REG(hw, CTRL, ctrl);
    return E1000_SUCCESS;
d2885 2
a2886 1
    uint32_t ctrl;
d2888 18
a2905 1
    DEBUGFUNC("em_force_mac_fc");
d2907 23
a2929 2
    /* Get the current configuration of the Device Control Register */
    ctrl = E1000_READ_REG(hw, CTRL);
d2931 2
a2932 44
    /* Because we didn't get link via the internal auto-negotiation
     * mechanism (we either forced link or we got link via PHY
     * auto-neg), we have to manually enable/disable transmit an
     * receive flow control.
     *
     * The "Case" statement below enables/disable flow control
     * according to the "hw->fc" parameter.
     *
     * The possible values of the "fc" parameter are:
     *      0:  Flow control is completely disabled
     *      1:  Rx flow control is enabled (we can receive pause
     *          frames but not send pause frames).
     *      2:  Tx flow control is enabled (we can send pause frames
     *          frames but we do not receive pause frames).
     *      3:  Both Rx and TX flow control (symmetric) is enabled.
     *  other:  No other values should be possible at this point.
     */

    switch (hw->fc) {
    case E1000_FC_NONE:
        ctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));
        break;
    case E1000_FC_RX_PAUSE:
        ctrl &= (~E1000_CTRL_TFCE);
        ctrl |= E1000_CTRL_RFCE;
        break;
    case E1000_FC_TX_PAUSE:
        ctrl &= (~E1000_CTRL_RFCE);
        ctrl |= E1000_CTRL_TFCE;
        break;
    case E1000_FC_FULL:
        ctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);
        break;
    default:
        DEBUGOUT("Flow control param set incorrectly\n");
        return -E1000_ERR_CONFIG;
    }

    /* Disable TX Flow Control for 82542 (rev 2.0) */
    if (hw->mac_type == em_82542_rev2_0)
        ctrl &= (~E1000_CTRL_TFCE);

    E1000_WRITE_REG(hw, CTRL, ctrl);
    return E1000_SUCCESS;
a2933 1

d2948 215
a3162 197
    int32_t ret_val;
    uint16_t mii_status_reg;
    uint16_t mii_nway_adv_reg;
    uint16_t mii_nway_lp_ability_reg;
    uint16_t speed;
    uint16_t duplex;

    DEBUGFUNC("em_config_fc_after_link_up");

    /* Check for the case where we have fiber media and auto-neg failed
     * so we had to force link.  In this case, we need to force the
     * configuration of the MAC to match the "fc" parameter.
     */
    if (((hw->media_type == em_media_type_fiber) && (hw->autoneg_failed)) ||
        ((hw->media_type == em_media_type_internal_serdes) &&
         (hw->autoneg_failed)) ||
        ((hw->media_type == em_media_type_copper) && (!hw->autoneg)) ||
        ((hw->media_type == em_media_type_oem) && (!hw->autoneg))
	) {
        ret_val = em_force_mac_fc(hw);
        if (ret_val) {
            DEBUGOUT("Error forcing flow control settings\n");
            return ret_val;
        }
    }

    /* Check for the case where we have copper media and auto-neg is
     * enabled.  In this case, we need to check and see if Auto-Neg
     * has completed, and if so, how the PHY and link partner has
     * flow control configured.
     */
    if ((hw->media_type == em_media_type_copper || 
        (hw->media_type == em_media_type_oem)) && 
        hw->autoneg) {
        /* Read the MII Status Register and check to see if AutoNeg
         * has completed.  We read this twice because this reg has
         * some "sticky" (latched) bits.
         */
        ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
        if (ret_val)
            return ret_val;
        ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
        if (ret_val)
            return ret_val;

        if (mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
            /* The AutoNeg process has completed, so we now need to
             * read both the Auto Negotiation Advertisement Register
             * (Address 4) and the Auto_Negotiation Base Page Ability
             * Register (Address 5) to determine how flow control was
             * negotiated.
             */
            ret_val = em_read_phy_reg(hw, PHY_AUTONEG_ADV,
                                         &mii_nway_adv_reg);
            if (ret_val)
                return ret_val;
            ret_val = em_read_phy_reg(hw, PHY_LP_ABILITY,
                                         &mii_nway_lp_ability_reg);
            if (ret_val)
                return ret_val;

            /* Two bits in the Auto Negotiation Advertisement Register
             * (Address 4) and two bits in the Auto Negotiation Base
             * Page Ability Register (Address 5) determine flow control
             * for both the PHY and the link partner.  The following
             * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,
             * 1999, describes these PAUSE resolution bits and how flow
             * control is determined based upon these settings.
             * NOTE:  DC = Don't Care
             *
             *   LOCAL DEVICE  |   LINK PARTNER
             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution
             *-------|---------|-------|---------|--------------------
             *   0   |    0    |  DC   |   DC    | em_fc_none
             *   0   |    1    |   0   |   DC    | em_fc_none
             *   0   |    1    |   1   |    0    | em_fc_none
             *   0   |    1    |   1   |    1    | em_fc_tx_pause
             *   1   |    0    |   0   |   DC    | em_fc_none
             *   1   |   DC    |   1   |   DC    | em_fc_full
             *   1   |    1    |   0   |    0    | em_fc_none
             *   1   |    1    |   0   |    1    | em_fc_rx_pause
             *
             */
            /* Are both PAUSE bits set to 1?  If so, this implies
             * Symmetric Flow Control is enabled at both ends.  The
             * ASM_DIR bits are irrelevant per the spec.
             *
             * For Symmetric Flow Control:
             *
             *   LOCAL DEVICE  |   LINK PARTNER
             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
             *-------|---------|-------|---------|--------------------
             *   1   |   DC    |   1   |   DC    | em_fc_full
             *
             */
            if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
                (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {
                /* Now we need to check if the user selected RX ONLY
                 * of pause frames.  In this case, we had to advertise
                 * FULL flow control because we could not advertise RX
                 * ONLY. Hence, we must now check to see if we need to
                 * turn OFF  the TRANSMISSION of PAUSE frames.
                 */
                if (hw->original_fc == E1000_FC_FULL) {
                    hw->fc = E1000_FC_FULL;
                    DEBUGOUT("Flow Control = FULL.\n");
                } else {
                    hw->fc = E1000_FC_RX_PAUSE;
                    DEBUGOUT("Flow Control = RX PAUSE frames only.\n");
                }
            }
            /* For receiving PAUSE frames ONLY.
             *
             *   LOCAL DEVICE  |   LINK PARTNER
             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
             *-------|---------|-------|---------|--------------------
             *   0   |    1    |   1   |    1    | em_fc_tx_pause
             *
             */
            else if (!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
                     (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
                     (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
                     (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
                hw->fc = E1000_FC_TX_PAUSE;
                DEBUGOUT("Flow Control = TX PAUSE frames only.\n");
            }
            /* For transmitting PAUSE frames ONLY.
             *
             *   LOCAL DEVICE  |   LINK PARTNER
             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
             *-------|---------|-------|---------|--------------------
             *   1   |    1    |   0   |    1    | em_fc_rx_pause
             *
             */
            else if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
                     (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
                     !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
                     (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
                hw->fc = E1000_FC_RX_PAUSE;
                DEBUGOUT("Flow Control = RX PAUSE frames only.\n");
            }
            /* Per the IEEE spec, at this point flow control should be
             * disabled.  However, we want to consider that we could
             * be connected to a legacy switch that doesn't advertise
             * desired flow control, but can be forced on the link
             * partner.  So if we advertised no flow control, that is
             * what we will resolve to.  If we advertised some kind of
             * receive capability (Rx Pause Only or Full Flow Control)
             * and the link partner advertised none, we will configure
             * ourselves to enable Rx Flow Control only.  We can do
             * this safely for two reasons:  If the link partner really
             * didn't want flow control enabled, and we enable Rx, no
             * harm done since we won't be receiving any PAUSE frames
             * anyway.  If the intent on the link partner was to have
             * flow control enabled, then by us enabling RX only, we
             * can at least receive pause frames and process them.
             * This is a good idea because in most cases, since we are
             * predominantly a server NIC, more times than not we will
             * be asked to delay transmission of packets than asking
             * our link partner to pause transmission of frames.
             */
            else if ((hw->original_fc == E1000_FC_NONE||
                      hw->original_fc == E1000_FC_TX_PAUSE) ||
                      hw->fc_strict_ieee) {
                hw->fc = E1000_FC_NONE;
                DEBUGOUT("Flow Control = NONE.\n");
            } else {
                hw->fc = E1000_FC_RX_PAUSE;
                DEBUGOUT("Flow Control = RX PAUSE frames only.\n");
            }

            /* Now we need to do one last check...  If we auto-
             * negotiated to HALF DUPLEX, flow control should not be
             * enabled per IEEE 802.3 spec.
             */
            ret_val = em_get_speed_and_duplex(hw, &speed, &duplex);
            if (ret_val) {
                DEBUGOUT("Error getting link speed and duplex\n");
                return ret_val;
            }

            if (duplex == HALF_DUPLEX)
                hw->fc = E1000_FC_NONE;

            /* Now we call a subroutine to actually force the MAC
             * controller to use the correct flow control settings.
             */
            ret_val = em_force_mac_fc(hw);
            if (ret_val) {
                DEBUGOUT("Error forcing flow control settings\n");
                return ret_val;
            }
        } else {
            DEBUGOUT("Copper PHY and Auto Neg has not completed.\n");
        }
    }
    return E1000_SUCCESS;
a3163 1

d3174 251
a3424 228
    uint32_t rxcw = 0;
    uint32_t ctrl;
    uint32_t status;
    uint32_t rctl;
    uint32_t icr;
    uint32_t signal = 0;
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_check_for_link");

    ctrl = E1000_READ_REG(hw, CTRL);
    status = E1000_READ_REG(hw, STATUS);

    /* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be
     * set when the optics detect a signal. On older adapters, it will be
     * cleared when there is a signal.  This applies to fiber media only.
     */
    if ((hw->media_type == em_media_type_fiber) ||
        (hw->media_type == em_media_type_internal_serdes)) {
        rxcw = E1000_READ_REG(hw, RXCW);

        if (hw->media_type == em_media_type_fiber) {
            signal = (hw->mac_type > em_82544) ? E1000_CTRL_SWDPIN1 : 0;
            if (status & E1000_STATUS_LU)
                hw->get_link_status = FALSE;
        }
    }

    /* If we have a copper PHY then we only want to go out to the PHY
     * registers to see if Auto-Neg has completed and/or if our link
     * status has changed.  The get_link_status flag will be set if we
     * receive a Link Status Change interrupt or we have Rx Sequence
     * Errors.
     */
    if ((hw->media_type == em_media_type_copper || 
    	(hw->media_type == em_media_type_oem)) && 
    	hw->get_link_status) {
        /* First we want to see if the MII Status Register reports
         * link.  If so, then we want to get the current speed/duplex
         * of the PHY.
         * Read the register twice since the link bit is sticky.
         */
        ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
        if (ret_val)
            return ret_val;
        ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
        if (ret_val)
            return ret_val;

        hw->icp_xxxx_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;

        if (phy_data & MII_SR_LINK_STATUS) {
            hw->get_link_status = FALSE;
            /* Check if there was DownShift, must be checked immediately after
             * link-up */
            em_check_downshift(hw);

            /* If we are on 82544 or 82543 silicon and speed/duplex
             * are forced to 10H or 10F, then we will implement the polarity
             * reversal workaround.  We disable interrupts first, and upon
             * returning, place the devices interrupt state to its previous
             * value except for the link status change interrupt which will
             * happen due to the execution of this workaround.
             */

            if ((hw->mac_type == em_82544 || hw->mac_type == em_82543) &&
                (!hw->autoneg) &&
                (hw->forced_speed_duplex == em_10_full ||
                 hw->forced_speed_duplex == em_10_half)) {
                E1000_WRITE_REG(hw, IMC, 0xffffffff);
                ret_val = em_polarity_reversal_workaround(hw);
                icr = E1000_READ_REG(hw, ICR);
                E1000_WRITE_REG(hw, ICS, (icr & ~E1000_ICS_LSC));
                E1000_WRITE_REG(hw, IMS, IMS_ENABLE_MASK);
            }

        } else {
            /* No link detected */
            em_config_dsp_after_link_change(hw, FALSE);
            return 0;
        }

        /* If we are forcing speed/duplex, then we simply return since
         * we have already determined whether we have link or not.
         */
        if (!hw->autoneg) return -E1000_ERR_CONFIG;

        /* optimize the dsp settings for the igp phy */
        em_config_dsp_after_link_change(hw, TRUE);

        /* We have a M88E1000 PHY and Auto-Neg is enabled.  If we
         * have Si on board that is 82544 or newer, Auto
         * Speed Detection takes care of MAC speed/duplex
         * configuration.  So we only need to configure Collision
         * Distance in the MAC.  Otherwise, we need to force
         * speed/duplex on the MAC to the current PHY speed/duplex
         * settings.
         */
        if (hw->mac_type >= em_82544 && hw->mac_type != em_icp_xxxx)
            em_config_collision_dist(hw);
        else {
            ret_val = em_config_mac_to_phy(hw);
            if (ret_val) {
                DEBUGOUT("Error configuring MAC to PHY settings\n");
                return ret_val;
            }
        }

        /* Configure Flow Control now that Auto-Neg has completed. First, we
         * need to restore the desired flow control settings because we may
         * have had to re-autoneg with a different link partner.
         */
        ret_val = em_config_fc_after_link_up(hw);
        if (ret_val) {
            DEBUGOUT("Error configuring flow control\n");
            return ret_val;
        }

        /* At this point we know that we are on copper and we have
         * auto-negotiated link.  These are conditions for checking the link
         * partner capability register.  We use the link speed to determine if
         * TBI compatibility needs to be turned on or off.  If the link is not
         * at gigabit speed, then TBI compatibility is not needed.  If we are
         * at gigabit speed, we turn on TBI compatibility.
         */
        if (hw->tbi_compatibility_en) {
            uint16_t speed, duplex;
            ret_val = em_get_speed_and_duplex(hw, &speed, &duplex);
            if (ret_val) {
                DEBUGOUT("Error getting link speed and duplex\n");
                return ret_val;
            }
            if (speed != SPEED_1000) {
                /* If link speed is not set to gigabit speed, we do not need
                 * to enable TBI compatibility.
                 */
                if (hw->tbi_compatibility_on) {
                    /* If we previously were in the mode, turn it off. */
                    rctl = E1000_READ_REG(hw, RCTL);
                    rctl &= ~E1000_RCTL_SBP;
                    E1000_WRITE_REG(hw, RCTL, rctl);
                    hw->tbi_compatibility_on = FALSE;
                }
            } else {
                /* If TBI compatibility is was previously off, turn it on. For
                 * compatibility with a TBI link partner, we will store bad
                 * packets. Some frames have an additional byte on the end and
                 * will look like CRC errors to to the hardware.
                 */
                if (!hw->tbi_compatibility_on) {
                    hw->tbi_compatibility_on = TRUE;
                    rctl = E1000_READ_REG(hw, RCTL);
                    rctl |= E1000_RCTL_SBP;
                    E1000_WRITE_REG(hw, RCTL, rctl);
                }
            }
        }
    }
    /* If we don't have link (auto-negotiation failed or link partner cannot
     * auto-negotiate), the cable is plugged in (we have signal), and our
     * link partner is not trying to auto-negotiate with us (we are receiving
     * idles or data), we need to force link up. We also need to give
     * auto-negotiation time to complete, in case the cable was just plugged
     * in. The autoneg_failed flag does this.
     */
    else if ((((hw->media_type == em_media_type_fiber) &&
              ((ctrl & E1000_CTRL_SWDPIN1) == signal)) ||
              (hw->media_type == em_media_type_internal_serdes)) &&
              (!(status & E1000_STATUS_LU)) &&
              (!(rxcw & E1000_RXCW_C))) {
        if (hw->autoneg_failed == 0) {
            hw->autoneg_failed = 1;
            return 0;
        }
        DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\n");

        /* Disable auto-negotiation in the TXCW register */
        E1000_WRITE_REG(hw, TXCW, (hw->txcw & ~E1000_TXCW_ANE));

        /* Force link-up and also force full-duplex. */
        ctrl = E1000_READ_REG(hw, CTRL);
        ctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);
        E1000_WRITE_REG(hw, CTRL, ctrl);

        /* Configure Flow Control after forcing link up. */
        ret_val = em_config_fc_after_link_up(hw);
        if (ret_val) {
            DEBUGOUT("Error configuring flow control\n");
            return ret_val;
        }
    }
    /* If we are forcing link and we are receiving /C/ ordered sets, re-enable
     * auto-negotiation in the TXCW register and disable forced link in the
     * Device Control register in an attempt to auto-negotiate with our link
     * partner.
     */
    else if (((hw->media_type == em_media_type_fiber) ||
              (hw->media_type == em_media_type_internal_serdes)) &&
              (ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {
        DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\n");
        E1000_WRITE_REG(hw, TXCW, hw->txcw);
        E1000_WRITE_REG(hw, CTRL, (ctrl & ~E1000_CTRL_SLU));

        hw->serdes_link_down = FALSE;
    }
    /* If we force link for non-auto-negotiation switch, check link status
     * based on MAC synchronization for internal serdes media type.
     */
    else if ((hw->media_type == em_media_type_internal_serdes) &&
             !(E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
        /* SYNCH bit and IV bit are sticky. */
        usec_delay(10);
        if (E1000_RXCW_SYNCH & E1000_READ_REG(hw, RXCW)) {
            if (!(rxcw & E1000_RXCW_IV)) {
                hw->serdes_link_down = FALSE;
                DEBUGOUT("SERDES: Link is up.\n");
            }
        } else {
            hw->serdes_link_down = TRUE;
            DEBUGOUT("SERDES: Link is down.\n");
        }
    }
    if ((hw->media_type == em_media_type_internal_serdes) &&
        (E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
        hw->serdes_link_down = !(E1000_STATUS_LU & E1000_READ_REG(hw, STATUS));
    }
    return E1000_SUCCESS;
d3435 79
a3513 81
em_get_speed_and_duplex(struct em_hw *hw,
                           uint16_t *speed,
                           uint16_t *duplex)
{
    uint32_t status;
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_get_speed_and_duplex");

    if (hw->mac_type >= em_82543) {
        status = E1000_READ_REG(hw, STATUS);
        if (status & E1000_STATUS_SPEED_1000) {
            *speed = SPEED_1000;
            DEBUGOUT("1000 Mbs, ");
        } else if (status & E1000_STATUS_SPEED_100) {
            *speed = SPEED_100;
            DEBUGOUT("100 Mbs, ");
        } else {
            *speed = SPEED_10;
            DEBUGOUT("10 Mbs, ");
        }

        if (status & E1000_STATUS_FD) {
            *duplex = FULL_DUPLEX;
            DEBUGOUT("Full Duplex\n");
        } else {
            *duplex = HALF_DUPLEX;
            DEBUGOUT(" Half Duplex\n");
        }
    } else {
        DEBUGOUT("1000 Mbs, Full Duplex\n");
        *speed = SPEED_1000;
        *duplex = FULL_DUPLEX;
    }

    /* IGP01 PHY may advertise full duplex operation after speed downgrade even
     * if it is operating at half duplex.  Here we set the duplex settings to
     * match the duplex in the link partner's capabilities.
     */
    if (hw->phy_type == em_phy_igp && hw->speed_downgraded) {
        ret_val = em_read_phy_reg(hw, PHY_AUTONEG_EXP, &phy_data);
        if (ret_val)
            return ret_val;

        if (!(phy_data & NWAY_ER_LP_NWAY_CAPS))
            *duplex = HALF_DUPLEX;
        else {
            ret_val = em_read_phy_reg(hw, PHY_LP_ABILITY, &phy_data);
            if (ret_val)
                return ret_val;
            if ((*speed == SPEED_100 && !(phy_data & NWAY_LPAR_100TX_FD_CAPS)) ||
               (*speed == SPEED_10 && !(phy_data & NWAY_LPAR_10T_FD_CAPS)))
                *duplex = HALF_DUPLEX;
        }
    }

    if ((hw->mac_type == em_80003es2lan) &&
        (hw->media_type == em_media_type_copper)) {
        if (*speed == SPEED_1000)
            ret_val = em_configure_kmrn_for_1000(hw);
        else
            ret_val = em_configure_kmrn_for_10_100(hw, *duplex);
        if (ret_val)
            return ret_val;
    }

    if ((hw->phy_type == em_phy_igp_3) && (*speed == SPEED_1000)) {
        ret_val = em_kumeran_lock_loss_workaround(hw);
        if (ret_val)
            return ret_val;
    }

    return E1000_SUCCESS;
}

/******************************************************************************
* Blocks until autoneg completes or times out (~4.5 seconds)
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d3517 24
a3540 24
    int32_t ret_val;
    uint16_t i;
    uint16_t phy_data;

    DEBUGFUNC("em_wait_autoneg");
    DEBUGOUT("Waiting for Auto-Neg to complete.\n");

    /* We will wait for autoneg to complete or 4.5 seconds to expire. */
    for (i = PHY_AUTO_NEG_TIME; i > 0; i--) {
        /* Read the MII Status Register and wait for Auto-Neg
         * Complete bit to be set.
         */
        ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
        if (ret_val)
            return ret_val;
        ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
        if (ret_val)
            return ret_val;
        if (phy_data & MII_SR_AUTONEG_COMPLETE) {
            return E1000_SUCCESS;
        }
        msec_delay(100);
    }
    return E1000_SUCCESS;
d3544 5
a3548 5
* Raises the Management Data Clock
*
* hw - Struct containing variables accessed by shared code
* ctrl - Device control register's current value
******************************************************************************/
d3550 1
a3550 2
em_raise_mdi_clk(struct em_hw *hw,
                    uint32_t *ctrl)
d3552 7
a3558 6
    /* Raise the clock input to the Management Data Clock (by setting the MDC
     * bit), and then delay 10 microseconds.
     */
    E1000_WRITE_REG(hw, CTRL, (*ctrl | E1000_CTRL_MDC));
    E1000_WRITE_FLUSH(hw);
    usec_delay(10);
d3562 5
a3566 5
* Lowers the Management Data Clock
*
* hw - Struct containing variables accessed by shared code
* ctrl - Device control register's current value
******************************************************************************/
d3568 1
a3568 2
em_lower_mdi_clk(struct em_hw *hw,
                    uint32_t *ctrl)
d3570 7
a3576 6
    /* Lower the clock input to the Management Data Clock (by clearing the MDC
     * bit), and then delay 10 microseconds.
     */
    E1000_WRITE_REG(hw, CTRL, (*ctrl & ~E1000_CTRL_MDC));
    E1000_WRITE_FLUSH(hw);
    usec_delay(10);
d3580 8
a3587 8
* Shifts data bits out to the PHY
*
* hw - Struct containing variables accessed by shared code
* data - Data to send out to the PHY
* count - Number of bits to shift out
*
* Bits are shifted out in MSB to LSB order.
******************************************************************************/
d3589 31
a3619 29
em_shift_out_mdi_bits(struct em_hw *hw,
                         uint32_t data,
                         uint16_t count)
{
    uint32_t ctrl;
    uint32_t mask;

    /* We need to shift "count" number of bits out to the PHY. So, the value
     * in the "data" parameter will be shifted out to the PHY one bit at a
     * time. In order to do this, "data" must be broken down into bits.
     */
    mask = 0x01;
    mask <<= (count - 1);

    ctrl = E1000_READ_REG(hw, CTRL);

    /* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
    ctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);

    while (mask) {
        /* A "1" is shifted out to the PHY by setting the MDIO bit to "1" and
         * then raising and lowering the Management Data Clock. A "0" is
         * shifted out to the PHY by setting the MDIO bit to "0" and then
         * raising and lowering the clock.
         */
        if (data & mask)
            ctrl |= E1000_CTRL_MDIO;
        else
            ctrl &= ~E1000_CTRL_MDIO;
d3621 2
a3622 2
        E1000_WRITE_REG(hw, CTRL, ctrl);
        E1000_WRITE_FLUSH(hw);
d3624 1
a3624 1
        usec_delay(10);
d3626 2
a3627 2
        em_raise_mdi_clk(hw, &ctrl);
        em_lower_mdi_clk(hw, &ctrl);
d3629 2
a3630 2
        mask = mask >> 1;
    }
d3634 6
a3639 6
* Shifts data bits in from the PHY
*
* hw - Struct containing variables accessed by shared code
*
* Bits are shifted in in MSB to LSB order.
******************************************************************************/
d3643 29
a3671 36
    uint32_t ctrl;
    uint16_t data = 0;
    uint8_t i;

    /* In order to read a register from the PHY, we need to shift in a total
     * of 18 bits from the PHY. The first two bit (turnaround) times are used
     * to avoid contention on the MDIO pin when a read operation is performed.
     * These two bits are ignored by us and thrown away. Bits are "shifted in"
     * by raising the input to the Management Data Clock (setting the MDC bit),
     * and then reading the value of the MDIO bit.
     */
    ctrl = E1000_READ_REG(hw, CTRL);

    /* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as input. */
    ctrl &= ~E1000_CTRL_MDIO_DIR;
    ctrl &= ~E1000_CTRL_MDIO;

    E1000_WRITE_REG(hw, CTRL, ctrl);
    E1000_WRITE_FLUSH(hw);

    /* Raise and Lower the clock before reading in the data. This accounts for
     * the turnaround bits. The first clock occurred when we clocked out the
     * last bit of the Register Address.
     */
    em_raise_mdi_clk(hw, &ctrl);
    em_lower_mdi_clk(hw, &ctrl);

    for (data = 0, i = 0; i < 16; i++) {
        data = data << 1;
        em_raise_mdi_clk(hw, &ctrl);
        ctrl = E1000_READ_REG(hw, CTRL);
        /* Check to see if we shifted in a "1". */
        if (ctrl & E1000_CTRL_MDIO)
            data |= 1;
        em_lower_mdi_clk(hw, &ctrl);
    }
d3673 9
a3681 2
    em_raise_mdi_clk(hw, &ctrl);
    em_lower_mdi_clk(hw, &ctrl);
d3683 4
a3686 1
    return data;
d3692 36
a3727 36
    uint32_t swfw_sync = 0;
    uint32_t swmask = mask;
    uint32_t fwmask = mask << 16;
    int32_t timeout = 200;

    DEBUGFUNC("em_swfw_sync_acquire");

    if (hw->swfwhw_semaphore_present)
        return em_get_software_flag(hw);

    if (!hw->swfw_sync_present)
        return em_get_hw_eeprom_semaphore(hw);

    while (timeout) {
            if (em_get_hw_eeprom_semaphore(hw))
                return -E1000_ERR_SWFW_SYNC;

            swfw_sync = E1000_READ_REG(hw, SW_FW_SYNC);
            if (!(swfw_sync & (fwmask | swmask))) {
                break;
            }

            /* firmware currently using resource (fwmask) */
            /* or other software thread currently using resource (swmask) */
            em_put_hw_eeprom_semaphore(hw);
            msec_delay_irq(5);
            timeout--;
    }

    if (!timeout) {
        DEBUGOUT("Driver can't access resource, SW_FW_SYNC timeout.\n");
        return -E1000_ERR_SWFW_SYNC;
    }

    swfw_sync |= swmask;
    E1000_WRITE_REG(hw, SW_FW_SYNC, swfw_sync);
d3729 2
a3730 2
    em_put_hw_eeprom_semaphore(hw);
    return E1000_SUCCESS;
d3736 17
a3752 4
    uint32_t swfw_sync;
    uint32_t swmask = mask;

    DEBUGFUNC("em_swfw_sync_release");
d3754 3
a3756 18
    if (hw->swfwhw_semaphore_present) {
        em_release_software_flag(hw);
        return;
    }

    if (!hw->swfw_sync_present) {
        em_put_hw_eeprom_semaphore(hw);
        return;
    }

    /* if (em_get_hw_eeprom_semaphore(hw))
     *    return -E1000_ERR_SWFW_SYNC; */
    while (em_get_hw_eeprom_semaphore(hw) != E1000_SUCCESS);
        /* empty */

    swfw_sync = E1000_READ_REG(hw, SW_FW_SYNC);
    swfw_sync &= ~swmask;
    E1000_WRITE_REG(hw, SW_FW_SYNC, swfw_sync);
d3758 1
a3758 1
    em_put_hw_eeprom_semaphore(hw);
d3760 6
a3765 7

/*****************************************************************************
* Reads the value from a PHY register, if the value is on a specific non zero
* page, sets the page first.
* hw - Struct containing variables accessed by shared code
* reg_addr - address of the PHY register to read
******************************************************************************/
d3767 143
a3909 142
em_read_phy_reg(struct em_hw *hw,
                   uint32_t reg_addr,
                   uint16_t *phy_data)
{
    uint32_t ret_val;
    uint16_t swfw;

    DEBUGFUNC("em_read_phy_reg");

    if ((hw->mac_type == em_80003es2lan) &&
        (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
        swfw = E1000_SWFW_PHY1_SM;
    } else {
        swfw = E1000_SWFW_PHY0_SM;
    }
    if (em_swfw_sync_acquire(hw, swfw))
        return -E1000_ERR_SWFW_SYNC;

    if ((hw->phy_type == em_phy_igp ||
        hw->phy_type == em_phy_igp_3 ||
        hw->phy_type == em_phy_igp_2) &&
       (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
        ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
                                         (uint16_t)reg_addr);
        if (ret_val) {
            em_swfw_sync_release(hw, swfw);
            return ret_val;
        }
    } else if (hw->phy_type == em_phy_gg82563) {
        if (((reg_addr & MAX_PHY_REG_ADDRESS) > MAX_PHY_MULTI_PAGE_REG) ||
            (hw->mac_type == em_80003es2lan)) {
            /* Select Configuration Page */
            if ((reg_addr & MAX_PHY_REG_ADDRESS) < GG82563_MIN_ALT_REG) {
                ret_val = em_write_phy_reg_ex(hw, GG82563_PHY_PAGE_SELECT,
                          (uint16_t)((uint16_t)reg_addr >> GG82563_PAGE_SHIFT));
            } else {
                /* Use Alternative Page Select register to access
                 * registers 30 and 31
                 */
                ret_val = em_write_phy_reg_ex(hw,
                                                 GG82563_PHY_PAGE_SELECT_ALT,
                          (uint16_t)((uint16_t)reg_addr >> GG82563_PAGE_SHIFT));
            }

            if (ret_val) {
                em_swfw_sync_release(hw, swfw);
                return ret_val;
            }
        }
    } else if ((hw->phy_type == em_phy_bm) && (hw->phy_revision == 1)) {
        if (reg_addr > MAX_PHY_MULTI_PAGE_REG) {
            ret_val = em_write_phy_reg_ex(hw, BM_PHY_PAGE_SELECT,
                              (uint16_t)((uint16_t)reg_addr >> PHY_PAGE_SHIFT));
            if (ret_val)
                return ret_val;
        }
    } 


    ret_val = em_read_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,
                                    phy_data);

    em_swfw_sync_release(hw, swfw);
    return ret_val;
}

STATIC int32_t
em_read_phy_reg_ex(struct em_hw *hw, uint32_t reg_addr,
                      uint16_t *phy_data)
{
    uint32_t i;
    uint32_t mdic = 0;

    DEBUGFUNC("em_read_phy_reg_ex");

    if (reg_addr > MAX_PHY_REG_ADDRESS) {
        DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
        return -E1000_ERR_PARAM;
    }

    if(hw->mac_type == em_icp_xxxx) {
        *phy_data = gcu_miibus_readreg(hw, hw->icp_xxxx_port_num, 
            reg_addr);
  	return E1000_SUCCESS;
    }

    if (hw->mac_type > em_82543) {
        /* Set up Op-code, Phy Address, and register address in the MDI
         * Control register.  The MAC will take care of interfacing with the
         * PHY to retrieve the desired data.
         */
        mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
                (hw->phy_addr << E1000_MDIC_PHY_SHIFT) |
                (E1000_MDIC_OP_READ));

        E1000_WRITE_REG(hw, MDIC, mdic);

        /* Poll the ready bit to see if the MDI read completed */
        for (i = 0; i < 64; i++) {
            usec_delay(50);
            mdic = E1000_READ_REG(hw, MDIC);
            if (mdic & E1000_MDIC_READY) break;
        }
        if (!(mdic & E1000_MDIC_READY)) {
            DEBUGOUT("MDI Read did not complete\n");
            return -E1000_ERR_PHY;
        }
        if (mdic & E1000_MDIC_ERROR) {
            DEBUGOUT("MDI Error\n");
            return -E1000_ERR_PHY;
        }
        *phy_data = (uint16_t) mdic;
    } else {
        /* We must first send a preamble through the MDIO pin to signal the
         * beginning of an MII instruction.  This is done by sending 32
         * consecutive "1" bits.
         */
        em_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);

        /* Now combine the next few fields that are required for a read
         * operation.  We use this method instead of calling the
         * em_shift_out_mdi_bits routine five different times. The format of
         * a MII read instruction consists of a shift out of 14 bits and is
         * defined as follows:
         *    <Preamble><SOF><Op Code><Phy Addr><Reg Addr>
         * followed by a shift in of 18 bits.  This first two bits shifted in
         * are TurnAround bits used to avoid contention on the MDIO pin when a
         * READ operation is performed.  These two bits are thrown away
         * followed by a shift in of 16 bits which contains the desired data.
         */
        mdic = ((reg_addr) | (hw->phy_addr << 5) |
                (PHY_OP_READ << 10) | (PHY_SOF << 12));

        em_shift_out_mdi_bits(hw, mdic, 14);

        /* Now that we've shifted out the read command to the MII, we need to
         * "shift in" the 16-bit value (18 total bits) of the requested PHY
         * register address.
         */
        *phy_data = em_shift_in_mdi_bits(hw);
    }
    return E1000_SUCCESS;
d3913 6
a3918 6
* Writes a value to a PHY register
*
* hw - Struct containing variables accessed by shared code
* reg_addr - address of the PHY register to write
* data - data to write to the PHY
******************************************************************************/
d3920 1
a3920 134
em_write_phy_reg(struct em_hw *hw, uint32_t reg_addr,
                    uint16_t phy_data)
{
    uint32_t ret_val;
    uint16_t swfw;

    DEBUGFUNC("em_write_phy_reg");

    if ((hw->mac_type == em_80003es2lan) &&
        (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
        swfw = E1000_SWFW_PHY1_SM;
    } else {
        swfw = E1000_SWFW_PHY0_SM;
    }
    if (em_swfw_sync_acquire(hw, swfw))
        return -E1000_ERR_SWFW_SYNC;

    if ((hw->phy_type == em_phy_igp ||
        hw->phy_type == em_phy_igp_3 ||
        hw->phy_type == em_phy_igp_2) &&
       (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
        ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
                                         (uint16_t)reg_addr);
        if (ret_val) {
            em_swfw_sync_release(hw, swfw);
            return ret_val;
        }
    } else if (hw->phy_type == em_phy_gg82563) {
        if (((reg_addr & MAX_PHY_REG_ADDRESS) > MAX_PHY_MULTI_PAGE_REG) ||
            (hw->mac_type == em_80003es2lan)) {
            /* Select Configuration Page */
            if ((reg_addr & MAX_PHY_REG_ADDRESS) < GG82563_MIN_ALT_REG) {
                ret_val = em_write_phy_reg_ex(hw, GG82563_PHY_PAGE_SELECT,
                          (uint16_t)((uint16_t)reg_addr >> GG82563_PAGE_SHIFT));
            } else {
                /* Use Alternative Page Select register to access
                 * registers 30 and 31
                 */
                ret_val = em_write_phy_reg_ex(hw,
                                                 GG82563_PHY_PAGE_SELECT_ALT,
                          (uint16_t)((uint16_t)reg_addr >> GG82563_PAGE_SHIFT));
            }

            if (ret_val) {
                em_swfw_sync_release(hw, swfw);
                return ret_val;
            }
        }
    } else if ((hw->phy_type == em_phy_bm) && (hw->phy_revision == 1)) {
        if (reg_addr > MAX_PHY_MULTI_PAGE_REG) { 
            ret_val = em_write_phy_reg_ex(hw, BM_PHY_PAGE_SELECT,
        		      (uint16_t)((uint16_t)reg_addr >> PHY_PAGE_SHIFT));
            if (ret_val)
                return ret_val;
        }
    } 

    ret_val = em_write_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,
                                     phy_data);

    em_swfw_sync_release(hw, swfw);
    return ret_val;
}

STATIC int32_t
em_write_phy_reg_ex(struct em_hw *hw, uint32_t reg_addr,
                       uint16_t phy_data)
{
    uint32_t i;
    uint32_t mdic = 0;

    DEBUGFUNC("em_write_phy_reg_ex");

    if (reg_addr > MAX_PHY_REG_ADDRESS) {
        DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
        return -E1000_ERR_PARAM;
    }

    if(hw->mac_type == em_icp_xxxx) {
        gcu_miibus_writereg(hw, hw->icp_xxxx_port_num, 
            reg_addr, phy_data);
        return E1000_SUCCESS;
    }
    if (hw->mac_type > em_82543) {
        /* Set up Op-code, Phy Address, register address, and data intended
         * for the PHY register in the MDI Control register.  The MAC will take
         * care of interfacing with the PHY to send the desired data.
         */
        mdic = (((uint32_t) phy_data) |
                (reg_addr << E1000_MDIC_REG_SHIFT) |
                (hw->phy_addr << E1000_MDIC_PHY_SHIFT) |
                (E1000_MDIC_OP_WRITE));

        E1000_WRITE_REG(hw, MDIC, mdic);

        /* Poll the ready bit to see if the MDI read completed */
        for (i = 0; i < 641; i++) {
            usec_delay(5);
            mdic = E1000_READ_REG(hw, MDIC);
            if (mdic & E1000_MDIC_READY) break;
        }
        if (!(mdic & E1000_MDIC_READY)) {
            DEBUGOUT("MDI Write did not complete\n");
            return -E1000_ERR_PHY;
        }
    } else {
        /* We'll need to use the SW defined pins to shift the write command
         * out to the PHY. We first send a preamble to the PHY to signal the
         * beginning of the MII instruction.  This is done by sending 32
         * consecutive "1" bits.
         */
        em_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);

        /* Now combine the remaining required fields that will indicate a
         * write operation. We use this method instead of calling the
         * em_shift_out_mdi_bits routine for each field in the command. The
         * format of a MII write instruction is as follows:
         * <Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>.
         */
        mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (hw->phy_addr << 7) |
                (PHY_OP_WRITE << 12) | (PHY_SOF << 14));
        mdic <<= 16;
        mdic |= (uint32_t) phy_data;

        em_shift_out_mdi_bits(hw, mdic, 32);
    }

    return E1000_SUCCESS;
}

STATIC int32_t
em_read_kmrn_reg(struct em_hw *hw,
                    uint32_t reg_addr,
                    uint16_t *data)
d3922 188
a4109 23
    uint32_t reg_val;
    uint16_t swfw;
    DEBUGFUNC("em_read_kmrn_reg");

    if ((hw->mac_type == em_80003es2lan) &&
        (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
        swfw = E1000_SWFW_PHY1_SM;
    } else {
        swfw = E1000_SWFW_PHY0_SM;
    }
    if (em_swfw_sync_acquire(hw, swfw))
        return -E1000_ERR_SWFW_SYNC;

    /* Write register address */
    reg_val = ((reg_addr << E1000_KUMCTRLSTA_OFFSET_SHIFT) &
              E1000_KUMCTRLSTA_OFFSET) |
              E1000_KUMCTRLSTA_REN;
    E1000_WRITE_REG(hw, KUMCTRLSTA, reg_val);
    usec_delay(2);

    /* Read the data returned */
    reg_val = E1000_READ_REG(hw, KUMCTRLSTA);
    *data = (uint16_t)reg_val;
d4111 2
a4112 29
    em_swfw_sync_release(hw, swfw);
    return E1000_SUCCESS;
}

STATIC int32_t
em_write_kmrn_reg(struct em_hw *hw,
                     uint32_t reg_addr,
                     uint16_t data)
{
    uint32_t reg_val;
    uint16_t swfw;
    DEBUGFUNC("em_write_kmrn_reg");

    if ((hw->mac_type == em_80003es2lan) &&
        (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
        swfw = E1000_SWFW_PHY1_SM;
    } else {
        swfw = E1000_SWFW_PHY0_SM;
    }
    if (em_swfw_sync_acquire(hw, swfw))
        return -E1000_ERR_SWFW_SYNC;

    reg_val = ((reg_addr << E1000_KUMCTRLSTA_OFFSET_SHIFT) &
              E1000_KUMCTRLSTA_OFFSET) | data;
    E1000_WRITE_REG(hw, KUMCTRLSTA, reg_val);
    usec_delay(2);

    em_swfw_sync_release(hw, swfw);
    return E1000_SUCCESS;
d4116 4
a4119 4
* Returns the PHY to the power-on reset state
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d4123 88
a4210 82
    uint32_t ctrl, ctrl_ext;
    uint32_t led_ctrl;
    int32_t ret_val;
    uint16_t swfw;

    DEBUGFUNC("em_phy_hw_reset");

    /* In the case of the phy reset being blocked, it's not an error, we
     * simply return success without performing the reset. */
    ret_val = em_check_phy_reset_block(hw);
    if (ret_val)
        return E1000_SUCCESS;

    DEBUGOUT("Resetting Phy...\n");

    if (hw->mac_type > em_82543 && hw->mac_type != em_icp_xxxx ) {
        if ((hw->mac_type == em_80003es2lan) &&
            (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
            swfw = E1000_SWFW_PHY1_SM;
        } else {
            swfw = E1000_SWFW_PHY0_SM;
        }
        if (em_swfw_sync_acquire(hw, swfw)) {
            DEBUGOUT("Unable to acquire swfw sync\n");
            return -E1000_ERR_SWFW_SYNC;
        }
        /* Read the device control register and assert the E1000_CTRL_PHY_RST
         * bit. Then, take it out of reset.
         * For pre-em_82571 hardware, we delay for 10ms between the assert
         * and deassert.  For em_82571 hardware and later, we instead delay
         * for 50us between and 10ms after the deassertion.
         */
        ctrl = E1000_READ_REG(hw, CTRL);
        E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PHY_RST);
        E1000_WRITE_FLUSH(hw);

        if (hw->mac_type < em_82571)
            msec_delay(10);
        else
            usec_delay(100);

        E1000_WRITE_REG(hw, CTRL, ctrl);
        E1000_WRITE_FLUSH(hw);

        if (hw->mac_type >= em_82571)
            msec_delay_irq(10);
        em_swfw_sync_release(hw, swfw);
    /* the M88E1141_E_PHY_ID might need reset here, but nothing proves it */
    } else {
        /* Read the Extended Device Control Register, assert the PHY_RESET_DIR
         * bit to put the PHY into reset. Then, take it out of reset.
         */
        ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
        ctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;
        ctrl_ext &= ~E1000_CTRL_EXT_SDP4_DATA;
        E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
        E1000_WRITE_FLUSH(hw);
        msec_delay(10);
        ctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;
        E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
        E1000_WRITE_FLUSH(hw);
    }
    usec_delay(150);

    if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
        /* Configure activity LED after PHY reset */
        led_ctrl = E1000_READ_REG(hw, LEDCTL);
        led_ctrl &= IGP_ACTIVITY_LED_MASK;
        led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
        E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
    }

    /* Wait for FW to finish PHY configuration. */
    ret_val = em_get_phy_cfg_done(hw);
    if (ret_val != E1000_SUCCESS)
        return ret_val;
    em_release_software_semaphore(hw);

    if ((hw->mac_type == em_ich8lan) && (hw->phy_type == em_phy_igp_3))
        ret_val = em_init_lcd_from_nvm(hw);

    return ret_val;
a4211 1

d4213 6
a4218 6
* Resets the PHY
*
* hw - Struct containing variables accessed by shared code
*
* Sets bit 15 of the MII Control regiser
******************************************************************************/
d4222 38
a4259 38
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_phy_reset");

    /* In the case of the phy reset being blocked, it's not an error, we
     * simply return success without performing the reset. */
    ret_val = em_check_phy_reset_block(hw);
    if (ret_val)
        return E1000_SUCCESS;

    switch (hw->phy_type) {
    case em_phy_igp:
    case em_phy_igp_2:
    case em_phy_igp_3:
    case em_phy_ife:
        ret_val = em_phy_hw_reset(hw);
        if (ret_val)
            return ret_val;
        break;
    default:
        ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data |= MII_CR_RESET;
        ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data);
        if (ret_val)
            return ret_val;

        usec_delay(1);
        break;
    }

    if (hw->phy_type == em_phy_igp || hw->phy_type == em_phy_igp_2)
        em_phy_init_script(hw);

    return E1000_SUCCESS;
d4263 13
a4275 13
* Work-around for 82566 Kumeran PCS lock loss:
* On link status change (i.e. PCI reset, speed change) and link is up and
* speed is gigabit-
* 0) if workaround is optionally disabled do nothing
* 1) wait 1ms for Kumeran link to come up
* 2) check Kumeran Diagnostic register PCS lock loss bit
* 3) if not set the link is locked (all is good), otherwise...
* 4) reset the PHY
* 5) repeat up to 10 times
* Note: this is only called for IGP3 copper when speed is 1gb.
*
* hw - struct containing variables accessed by shared code
******************************************************************************/
d4279 42
a4320 43
    int32_t ret_val;
    int32_t reg;
    int32_t cnt;
    uint16_t phy_data;

    if (hw->kmrn_lock_loss_workaround_disabled)
        return E1000_SUCCESS;

    /* Make sure link is up before proceeding.  If not just return.
     * Attempting this while link is negotiating fouled up link
     * stability */
    ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
    ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);

    if (phy_data & MII_SR_LINK_STATUS) {
        for (cnt = 0; cnt < 10; cnt++) {
            /* read once to clear */
            ret_val = em_read_phy_reg(hw, IGP3_KMRN_DIAG, &phy_data);
            if (ret_val)
                return ret_val;
            /* and again to get new status */
            ret_val = em_read_phy_reg(hw, IGP3_KMRN_DIAG, &phy_data);
            if (ret_val)
                return ret_val;

            /* check for PCS lock */
            if (!(phy_data & IGP3_KMRN_DIAG_PCS_LOCK_LOSS))
                return E1000_SUCCESS;

            /* Issue PHY reset */
            em_phy_hw_reset(hw);
            msec_delay_irq(5);
        }
        /* Disable GigE link negotiation */
        reg = E1000_READ_REG(hw, PHY_CTRL);
        E1000_WRITE_REG(hw, PHY_CTRL, reg | E1000_PHY_CTRL_GBE_DISABLE |
                        E1000_PHY_CTRL_NOND0A_GBE_DISABLE);

        /* unable to acquire PCS lock */
        return E1000_ERR_PHY;
    }

    return E1000_SUCCESS;
d4324 4
a4327 4
* Reads and matches the expected PHY address for known PHY IDs
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d4331 91
a4421 79
    int32_t phy_init_status, ret_val;
    uint16_t phy_id_high, phy_id_low;
    boolean_t match = FALSE;

    DEBUGFUNC("em_match_gig_phy");

    ret_val = em_read_phy_reg(hw, PHY_ID1, &phy_id_high);
    if (ret_val)
        return ret_val;

    hw->phy_id = (uint32_t) (phy_id_high << 16);
    usec_delay(20);
    ret_val = em_read_phy_reg(hw, PHY_ID2, &phy_id_low);
    if (ret_val)
        return ret_val;

    hw->phy_id |= (uint32_t) (phy_id_low & PHY_REVISION_MASK);
    hw->phy_revision = (uint32_t) phy_id_low & ~PHY_REVISION_MASK;

    switch (hw->mac_type) {
    case em_82543:
            if (hw->phy_id == M88E1000_E_PHY_ID) match = TRUE;
            break;
    case em_82544:
            if (hw->phy_id == M88E1000_I_PHY_ID) match = TRUE;
            break;
    case em_82540:
    case em_82545:
    case em_82545_rev_3:
    case em_82546:
    case em_82546_rev_3:
            if (hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
            break;
    case em_82541:
    case em_82541_rev_2:
    case em_82547:
    case em_82547_rev_2:
            if (hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
            break;
    case em_82573:
            if (hw->phy_id == M88E1111_I_PHY_ID) match = TRUE;
            break;
    case em_82574:
            if (hw->phy_id == BME1000_E_PHY_ID) match = TRUE;
            break;
    case em_80003es2lan:
            if (hw->phy_id == GG82563_E_PHY_ID) match = TRUE;
            break;
    case em_ich8lan:
    case em_ich9lan:
    case em_ich10lan:
            if (hw->phy_id == IGP03E1000_E_PHY_ID) match = TRUE;
            if (hw->phy_id == IFE_E_PHY_ID) match = TRUE;
            if (hw->phy_id == IFE_PLUS_E_PHY_ID) match = TRUE;
            if (hw->phy_id == IFE_C_E_PHY_ID) match = TRUE;
            if (hw->phy_id == BME1000_E_PHY_ID) match = TRUE;
            break;
    case em_icp_xxxx:
	    if (hw->phy_id == M88E1141_E_PHY_ID) match = TRUE;
	    break;
    default:
            DEBUGOUT1("Invalid MAC type %d\n", hw->mac_type);
            return -E1000_ERR_CONFIG;
    }
    phy_init_status = em_set_phy_type(hw);

    if ((match) && (phy_init_status == E1000_SUCCESS)) {
            DEBUGOUT1("PHY ID 0x%X detected\n", hw->phy_id);
            return E1000_SUCCESS;
    }
    DEBUGOUT1("Invalid PHY ID 0x%X\n", hw->phy_id);
    return -E1000_ERR_PHY;
}

/******************************************************************************
* Probes the expected PHY address for known PHY IDs
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d4425 2
a4426 1
    int32_t ret_val;
d4428 2
a4429 1
    DEBUGFUNC("em_detect_gig_phy");
d4431 52
a4482 2
    if (hw->phy_id != 0)
        return E1000_SUCCESS;
d4484 14
a4497 61
    /* default phy address, most phys reside here, but not all (ICH10) */
    if (hw->mac_type != em_icp_xxxx)
        hw->phy_addr = 1;
    else
        hw->phy_addr = 0; /* There is a phy at phy_addr 0 on EP80579 */

    /* The 82571 firmware may still be configuring the PHY.  In this
     * case, we cannot access the PHY until the configuration is done.  So
     * we explicitly set the PHY values. */
    if (hw->mac_type == em_82571 ||
        hw->mac_type == em_82572 ||
	hw->mac_type == em_82575) {
        hw->phy_id = IGP01E1000_I_PHY_ID;
        hw->phy_type = em_phy_igp_2;
        return E1000_SUCCESS;
    }
    
    /* Some of the fiber cards dont have a phy, so we must exit cleanly here */
    if ((hw->media_type == em_media_type_fiber) && 
        (hw->mac_type == em_82542_rev2_0 ||
        hw->mac_type == em_82542_rev2_1 ||
        hw->mac_type == em_82543 ||
        hw->mac_type == em_82574 ||
        hw->mac_type == em_82573 ||
        hw->mac_type == em_82574 ||
        hw->mac_type == em_80003es2lan)) {
        hw->phy_type = em_phy_undefined;
        return E1000_SUCCESS;
    }

    /* Up to 82543 (incl), we need reset the phy, or it might not get 
     * detected */
    if (hw->mac_type <= em_82543) {
        ret_val = em_phy_hw_reset(hw);
        if (ret_val)
            return ret_val;
    }

    /* ESB-2 PHY reads require em_phy_gg82563 to be set because of a work-
     * around that forces PHY page 0 to be set or the reads fail.  The rest of
     * the code in this routine uses em_read_phy_reg to read the PHY ID.
     * So for ESB-2 we need to have this set so our reads won't fail.  If the
     * attached PHY is not a em_phy_gg82563, the routines below will figure
     * this out as well. */
    if (hw->mac_type == em_80003es2lan)
        hw->phy_type = em_phy_gg82563;

    /* Read the PHY ID Registers to identify which PHY is onboard. */
    for (hw->phy_addr = 1; (hw->phy_addr < 4); hw->phy_addr++) {
        ret_val = em_match_gig_phy(hw);
        if (ret_val == E1000_SUCCESS)
            return E1000_SUCCESS;
    }
    return -E1000_ERR_PHY;
}

/******************************************************************************
* Resets the PHY's DSP
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
d4501 2
a4502 2
    int32_t ret_val;
    DEBUGFUNC("em_phy_reset_dsp");
d4504 14
a4517 11
    do {
        if (hw->phy_type != em_phy_gg82563) {
            ret_val = em_write_phy_reg(hw, 29, 0x001d);
            if (ret_val) break;
        }
        ret_val = em_write_phy_reg(hw, 30, 0x00c1);
        if (ret_val) break;
        ret_val = em_write_phy_reg(hw, 30, 0x0000);
        if (ret_val) break;
        ret_val = E1000_SUCCESS;
    } while (0);
d4519 1
a4519 1
    return ret_val;
d4532 197
a4728 184
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint32_t eecd = E1000_READ_REG(hw, EECD);
    int32_t ret_val = E1000_SUCCESS;
    uint16_t eeprom_size;

    DEBUGFUNC("em_init_eeprom_params");

    switch (hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
    case em_82543:
    case em_82544:
        eeprom->type = em_eeprom_microwire;
        eeprom->word_size = 64;
        eeprom->opcode_bits = 3;
        eeprom->address_bits = 6;
        eeprom->delay_usec = 50;
        eeprom->use_eerd = FALSE;
        eeprom->use_eewr = FALSE;
        break;
    case em_82540:
    case em_82545:
    case em_82545_rev_3:
    case em_icp_xxxx:
    case em_82546:
    case em_82546_rev_3:
        eeprom->type = em_eeprom_microwire;
        eeprom->opcode_bits = 3;
        eeprom->delay_usec = 50;
        if (eecd & E1000_EECD_SIZE) {
            eeprom->word_size = 256;
            eeprom->address_bits = 8;
        } else {
            eeprom->word_size = 64;
            eeprom->address_bits = 6;
        }
        eeprom->use_eerd = FALSE;
        eeprom->use_eewr = FALSE;
        break;
    case em_82541:
    case em_82541_rev_2:
    case em_82547:
    case em_82547_rev_2:
        if (eecd & E1000_EECD_TYPE) {
            eeprom->type = em_eeprom_spi;
            eeprom->opcode_bits = 8;
            eeprom->delay_usec = 1;
            if (eecd & E1000_EECD_ADDR_BITS) {
                eeprom->page_size = 32;
                eeprom->address_bits = 16;
            } else {
                eeprom->page_size = 8;
                eeprom->address_bits = 8;
            }
        } else {
            eeprom->type = em_eeprom_microwire;
            eeprom->opcode_bits = 3;
            eeprom->delay_usec = 50;
            if (eecd & E1000_EECD_ADDR_BITS) {
                eeprom->word_size = 256;
                eeprom->address_bits = 8;
            } else {
                eeprom->word_size = 64;
                eeprom->address_bits = 6;
            }
        }
        eeprom->use_eerd = FALSE;
        eeprom->use_eewr = FALSE;
        break;
    case em_82571:
    case em_82572:
    case em_82575:
        eeprom->type = em_eeprom_spi;
        eeprom->opcode_bits = 8;
        eeprom->delay_usec = 1;
        if (eecd & E1000_EECD_ADDR_BITS) {
            eeprom->page_size = 32;
            eeprom->address_bits = 16;
        } else {
            eeprom->page_size = 8;
            eeprom->address_bits = 8;
        }
        eeprom->use_eerd = FALSE;
        eeprom->use_eewr = FALSE;
        break;
    case em_82573:
    case em_82574:
        eeprom->type = em_eeprom_spi;
        eeprom->opcode_bits = 8;
        eeprom->delay_usec = 1;
        if (eecd & E1000_EECD_ADDR_BITS) {
            eeprom->page_size = 32;
            eeprom->address_bits = 16;
        } else {
            eeprom->page_size = 8;
            eeprom->address_bits = 8;
        }
        eeprom->use_eerd = TRUE;
        eeprom->use_eewr = TRUE;
        if (em_is_onboard_nvm_eeprom(hw) == FALSE) {
            eeprom->type = em_eeprom_flash;
            eeprom->word_size = 2048;

            /* Ensure that the Autonomous FLASH update bit is cleared due to
             * Flash update issue on parts which use a FLASH for NVM. */
            eecd &= ~E1000_EECD_AUPDEN;
            E1000_WRITE_REG(hw, EECD, eecd);
        }
        break;
    case em_80003es2lan:
        eeprom->type = em_eeprom_spi;
        eeprom->opcode_bits = 8;
        eeprom->delay_usec = 1;
        if (eecd & E1000_EECD_ADDR_BITS) {
            eeprom->page_size = 32;
            eeprom->address_bits = 16;
        } else {
            eeprom->page_size = 8;
            eeprom->address_bits = 8;
        }
        eeprom->use_eerd = TRUE;
        eeprom->use_eewr = FALSE;
        break;
    case em_ich8lan:
    case em_ich9lan:
    case em_ich10lan:
    {
        int32_t  i = 0;
        uint32_t flash_size = E1000_READ_ICH_FLASH_REG(hw, ICH_FLASH_GFPREG);

        eeprom->type = em_eeprom_ich8;
        eeprom->use_eerd = FALSE;
        eeprom->use_eewr = FALSE;
        eeprom->word_size = E1000_SHADOW_RAM_WORDS;

        /* Zero the shadow RAM structure. But don't load it from NVM
         * so as to save time for driver init */
        if (hw->eeprom_shadow_ram != NULL) {
            for (i = 0; i < E1000_SHADOW_RAM_WORDS; i++) {
                hw->eeprom_shadow_ram[i].modified = FALSE;
                hw->eeprom_shadow_ram[i].eeprom_word = 0xFFFF;
            }
        }

        hw->flash_base_addr = (flash_size & ICH_GFPREG_BASE_MASK) *
                              ICH_FLASH_SECTOR_SIZE;

        hw->flash_bank_size = ((flash_size >> 16) & ICH_GFPREG_BASE_MASK) + 1;
        hw->flash_bank_size -= (flash_size & ICH_GFPREG_BASE_MASK);

        hw->flash_bank_size *= ICH_FLASH_SECTOR_SIZE;

        hw->flash_bank_size /= 2 * sizeof(uint16_t);

        break;
    }
    default:
        break;
    }

    if (eeprom->type == em_eeprom_spi) {
        /* eeprom_size will be an enum [0..8] that maps to eeprom sizes 128B to
         * 32KB (incremented by powers of 2).
         */
        if (hw->mac_type <= em_82547_rev_2) {
            /* Set to default value for initial eeprom read. */
            eeprom->word_size = 64;
            ret_val = em_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size);
            if (ret_val)
                return ret_val;
            eeprom_size = (eeprom_size & EEPROM_SIZE_MASK) >> EEPROM_SIZE_SHIFT;
            /* 256B eeprom size was not supported in earlier hardware, so we
             * bump eeprom_size up one to ensure that "1" (which maps to 256B)
             * is never the result used in the shifting logic below. */
            if (eeprom_size)
                eeprom_size++;
        } else {
            eeprom_size = (uint16_t)((eecd & E1000_EECD_SIZE_EX_MASK) >>
                          E1000_EECD_SIZE_EX_SHIFT);
        }

        eeprom->word_size = 1 << (eeprom_size + EEPROM_WORD_SIZE_SHIFT);
    }
    return ret_val;
d4738 1
a4738 2
em_raise_ee_clk(struct em_hw *hw,
                   uint32_t *eecd)
d4740 8
a4747 7
    /* Raise the clock input to the EEPROM (by setting the SK bit), and then
     * wait <delay> microseconds.
     */
    *eecd = *eecd | E1000_EECD_SK;
    E1000_WRITE_REG(hw, EECD, *eecd);
    E1000_WRITE_FLUSH(hw);
    usec_delay(hw->eeprom.delay_usec);
d4757 1
a4757 2
em_lower_ee_clk(struct em_hw *hw,
                   uint32_t *eecd)
d4759 8
a4766 7
    /* Lower the clock input to the EEPROM (by clearing the SK bit), and then
     * wait 50 microseconds.
     */
    *eecd = *eecd & ~E1000_EECD_SK;
    E1000_WRITE_REG(hw, EECD, *eecd);
    E1000_WRITE_FLUSH(hw);
    usec_delay(hw->eeprom.delay_usec);
d4777 45
a4821 45
em_shift_out_ee_bits(struct em_hw *hw,
                        uint16_t data,
                        uint16_t count)
{
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint32_t eecd;
    uint32_t mask;

    /* We need to shift "count" bits out to the EEPROM. So, value in the
     * "data" parameter will be shifted out to the EEPROM one bit at a time.
     * In order to do this, "data" must be broken down into bits.
     */
    mask = 0x01 << (count - 1);
    eecd = E1000_READ_REG(hw, EECD);
    if (eeprom->type == em_eeprom_microwire) {
        eecd &= ~E1000_EECD_DO;
    } else if (eeprom->type == em_eeprom_spi) {
        eecd |= E1000_EECD_DO;
    }
    do {
        /* A "1" is shifted out to the EEPROM by setting bit "DI" to a "1",
         * and then raising and then lowering the clock (the SK bit controls
         * the clock input to the EEPROM).  A "0" is shifted out to the EEPROM
         * by setting "DI" to "0" and then raising and then lowering the clock.
         */
        eecd &= ~E1000_EECD_DI;

        if (data & mask)
            eecd |= E1000_EECD_DI;

        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);

        usec_delay(eeprom->delay_usec);

        em_raise_ee_clk(hw, &eecd);
        em_lower_ee_clk(hw, &eecd);

        mask = mask >> 1;

    } while (mask);

    /* We leave the "DI" bit set to "0" when we leave this routine. */
    eecd &= ~E1000_EECD_DI;
    E1000_WRITE_REG(hw, EECD, eecd);
d4830 1
a4830 2
em_shift_in_ee_bits(struct em_hw *hw,
                       uint16_t count)
d4832 10
a4841 3
    uint32_t eecd;
    uint32_t i;
    uint16_t data;
d4843 1
a4843 6
    /* In order to read a register from the EEPROM, we need to shift 'count'
     * bits in from the EEPROM. Bits are "shifted in" by raising the clock
     * input to the EEPROM (setting the SK bit), and then reading the value of
     * the "DO" bit.  During this "shifting in" process the "DI" bit should
     * always be clear.
     */
d4845 2
a4846 1
    eecd = E1000_READ_REG(hw, EECD);
d4848 3
a4850 2
    eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
    data = 0;
d4852 1
a4852 3
    for (i = 0; i < count; i++) {
        data = data << 1;
        em_raise_ee_clk(hw, &eecd);
d4854 3
a4856 1
        eecd = E1000_READ_REG(hw, EECD);
d4858 2
a4859 3
        eecd &= ~(E1000_EECD_DI);
        if (eecd & E1000_EECD_DO)
            data |= 1;
d4861 1
a4861 4
        em_lower_ee_clk(hw, &eecd);
    }

    return data;
a4862 1

d4874 46
a4919 49
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint32_t eecd, i=0;

    DEBUGFUNC("em_acquire_eeprom");

    if (em_swfw_sync_acquire(hw, E1000_SWFW_EEP_SM))
        return -E1000_ERR_SWFW_SYNC;
    eecd = E1000_READ_REG(hw, EECD);

    if ((hw->mac_type != em_82573) && (hw->mac_type != em_82574)) {
        /* Request EEPROM Access */
        if (hw->mac_type > em_82544) {
            eecd |= E1000_EECD_REQ;
            E1000_WRITE_REG(hw, EECD, eecd);
            eecd = E1000_READ_REG(hw, EECD);
            while ((!(eecd & E1000_EECD_GNT)) &&
                  (i < E1000_EEPROM_GRANT_ATTEMPTS)) {
                i++;
                usec_delay(5);
                eecd = E1000_READ_REG(hw, EECD);
            }
            if (!(eecd & E1000_EECD_GNT)) {
                eecd &= ~E1000_EECD_REQ;
                E1000_WRITE_REG(hw, EECD, eecd);
                DEBUGOUT("Could not acquire EEPROM grant\n");
                em_swfw_sync_release(hw, E1000_SWFW_EEP_SM);
                return -E1000_ERR_EEPROM;
            }
        }
    }

    /* Setup EEPROM for Read/Write */

    if (eeprom->type == em_eeprom_microwire) {
        /* Clear SK and DI */
        eecd &= ~(E1000_EECD_DI | E1000_EECD_SK);
        E1000_WRITE_REG(hw, EECD, eecd);

        /* Set CS */
        eecd |= E1000_EECD_CS;
        E1000_WRITE_REG(hw, EECD, eecd);
    } else if (eeprom->type == em_eeprom_spi) {
        /* Clear SK and CS */
        eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
        E1000_WRITE_REG(hw, EECD, eecd);
        usec_delay(1);
    }

    return E1000_SUCCESS;
d4930 38
a4967 39
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint32_t eecd;

    eecd = E1000_READ_REG(hw, EECD);

    if (eeprom->type == em_eeprom_microwire) {
        eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);

        /* Clock high */
        eecd |= E1000_EECD_SK;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);

        /* Select EEPROM */
        eecd |= E1000_EECD_CS;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);

        /* Clock low */
        eecd &= ~E1000_EECD_SK;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);
    } else if (eeprom->type == em_eeprom_spi) {
        /* Toggle CS to flush commands */
        eecd |= E1000_EECD_CS;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);
        eecd &= ~E1000_EECD_CS;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);
    }
d4978 2
a4979 1
    uint32_t eecd;
d4981 1
a4981 1
    DEBUGFUNC("em_release_eeprom");
d4983 33
a5015 37
    eecd = E1000_READ_REG(hw, EECD);

    if (hw->eeprom.type == em_eeprom_spi) {
        eecd |= E1000_EECD_CS;  /* Pull CS high */
        eecd &= ~E1000_EECD_SK; /* Lower SCK */

        E1000_WRITE_REG(hw, EECD, eecd);

        usec_delay(hw->eeprom.delay_usec);
    } else if (hw->eeprom.type == em_eeprom_microwire) {
        /* cleanup eeprom */

        /* CS on Microwire is active-high */
        eecd &= ~(E1000_EECD_CS | E1000_EECD_DI);

        E1000_WRITE_REG(hw, EECD, eecd);

        /* Rising edge of clock */
        eecd |= E1000_EECD_SK;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(hw->eeprom.delay_usec);

        /* Falling edge of clock */
        eecd &= ~E1000_EECD_SK;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(hw->eeprom.delay_usec);
    }

    /* Stop requesting EEPROM access */
    if (hw->mac_type > em_82544) {
        eecd &= ~E1000_EECD_REQ;
        E1000_WRITE_REG(hw, EECD, eecd);
    }

    em_swfw_sync_release(hw, E1000_SWFW_EEP_SM);
d5026 31
a5056 33
    uint16_t retry_count = 0;
    uint8_t spi_stat_reg;

    DEBUGFUNC("em_spi_eeprom_ready");

    /* Read "Status Register" repeatedly until the LSB is cleared.  The
     * EEPROM will signal that the command has been completed by clearing
     * bit 0 of the internal status register.  If it's not cleared within
     * 5 milliseconds, then error out.
     */
    retry_count = 0;
    do {
        em_shift_out_ee_bits(hw, EEPROM_RDSR_OPCODE_SPI,
                                hw->eeprom.opcode_bits);
        spi_stat_reg = (uint8_t)em_shift_in_ee_bits(hw, 8);
        if (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))
            break;

        usec_delay(5);
        retry_count += 5;

        em_standby_eeprom(hw);
    } while (retry_count < EEPROM_MAX_RETRY_SPI);

    /* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
     * only 0-5mSec on 5V devices)
     */
    if (retry_count >= EEPROM_MAX_RETRY_SPI) {
        DEBUGOUT("SPI EEPROM Status error\n");
        return -E1000_ERR_EEPROM;
    }

    return E1000_SUCCESS;
d5068 91
a5158 86
em_read_eeprom(struct em_hw *hw,
                  uint16_t offset,
                  uint16_t words,
                  uint16_t *data)
{
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint32_t i = 0;

    DEBUGFUNC("em_read_eeprom");

    /* If eeprom is not yet detected, do so now */
    if (eeprom->word_size == 0)
        em_init_eeprom_params(hw);

    /* A check for invalid values:  offset too large, too many words, and not
     * enough words.
     */
    if ((offset >= eeprom->word_size) || (words > eeprom->word_size - offset) ||
       (words == 0)) {
        DEBUGOUT2("\"words\" parameter out of bounds. Words = %d, size = %d\n", offset, eeprom->word_size);
        return -E1000_ERR_EEPROM;
    }

    /* EEPROM's that don't use EERD to read require us to bit-bang the SPI
     * directly. In this case, we need to acquire the EEPROM so that
     * FW or other port software does not interrupt.
     */
    if (em_is_onboard_nvm_eeprom(hw) == TRUE &&
        hw->eeprom.use_eerd == FALSE) {
        /* Prepare the EEPROM for bit-bang reading */
        if (em_acquire_eeprom(hw) != E1000_SUCCESS)
            return -E1000_ERR_EEPROM;
    }

    /* Eerd register EEPROM access requires no eeprom aquire/release */
    if (eeprom->use_eerd == TRUE)
        return em_read_eeprom_eerd(hw, offset, words, data);

    /* ICH EEPROM access is done via the ICH flash controller */
    if (eeprom->type == em_eeprom_ich8)
        return em_read_eeprom_ich8(hw, offset, words, data);

    /* Set up the SPI or Microwire EEPROM for bit-bang reading.  We have
     * acquired the EEPROM at this point, so any returns should relase it */
    if (eeprom->type == em_eeprom_spi) {
        uint16_t word_in;
        uint8_t read_opcode = EEPROM_READ_OPCODE_SPI;

        if (em_spi_eeprom_ready(hw)) {
            em_release_eeprom(hw);
            return -E1000_ERR_EEPROM;
        }

        em_standby_eeprom(hw);

        /* Some SPI eeproms use the 8th address bit embedded in the opcode */
        if ((eeprom->address_bits == 8) && (offset >= 128))
            read_opcode |= EEPROM_A8_OPCODE_SPI;

        /* Send the READ command (opcode + addr)  */
        em_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);
        em_shift_out_ee_bits(hw, (uint16_t)(offset*2), eeprom->address_bits);

        /* Read the data.  The address of the eeprom internally increments with
         * each byte (spi) being read, saving on the overhead of eeprom setup
         * and tear-down.  The address counter will roll over if reading beyond
         * the size of the eeprom, thus allowing the entire memory to be read
         * starting from any offset. */
        for (i = 0; i < words; i++) {
            word_in = em_shift_in_ee_bits(hw, 16);
            data[i] = (word_in >> 8) | (word_in << 8);
        }
    } else if (eeprom->type == em_eeprom_microwire) {
        for (i = 0; i < words; i++) {
            /* Send the READ command (opcode + addr)  */
            em_shift_out_ee_bits(hw, EEPROM_READ_OPCODE_MICROWIRE,
                                    eeprom->opcode_bits);
            em_shift_out_ee_bits(hw, (uint16_t)(offset + i),
                                    eeprom->address_bits);

            /* Read the data.  For microwire, each word requires the overhead
             * of eeprom setup and tear-down. */
            data[i] = em_shift_in_ee_bits(hw, 16);
            em_standby_eeprom(hw);
        }
    }
d5160 1
a5160 4
    /* End this read operation */
    em_release_eeprom(hw);

    return E1000_SUCCESS;
d5172 2
a5173 4
em_read_eeprom_eerd(struct em_hw *hw,
                  uint16_t offset,
                  uint16_t words,
                  uint16_t *data)
d5175 14
a5188 6
    uint32_t i, eerd = 0;
    int32_t error = 0;

    for (i = 0; i < words; i++) {
        eerd = ((offset+i) << E1000_EEPROM_RW_ADDR_SHIFT) +
                         E1000_EEPROM_RW_REG_START;
d5190 1
a5190 2
        E1000_WRITE_REG(hw, EERD, eerd);
        error = em_poll_eerd_eewr_done(hw, E1000_EEPROM_POLL_READ);
d5192 1
a5192 8
        if (error) {
            break;
        }
        data[i] = (E1000_READ_REG(hw, EERD) >> E1000_EEPROM_RW_REG_DATA);

    }

    return error;
d5204 26
a5229 30
em_write_eeprom_eewr(struct em_hw *hw,
                   uint16_t offset,
                   uint16_t words,
                   uint16_t *data)
{
    uint32_t    register_value = 0;
    uint32_t    i              = 0;
    int32_t     error          = 0;

    if (em_swfw_sync_acquire(hw, E1000_SWFW_EEP_SM))
        return -E1000_ERR_SWFW_SYNC;

    for (i = 0; i < words; i++) {
        register_value = (data[i] << E1000_EEPROM_RW_REG_DATA) |
                         ((offset+i) << E1000_EEPROM_RW_ADDR_SHIFT) |
                         E1000_EEPROM_RW_REG_START;

        error = em_poll_eerd_eewr_done(hw, E1000_EEPROM_POLL_WRITE);
        if (error) {
            break;
        }

        E1000_WRITE_REG(hw, EEWR, register_value);

        error = em_poll_eerd_eewr_done(hw, E1000_EEPROM_POLL_WRITE);

        if (error) {
            break;
        }
    }
d5231 2
a5232 2
    em_swfw_sync_release(hw, E1000_SWFW_EEP_SM);
    return error;
d5243 15
a5257 16
    uint32_t attempts = 100000;
    uint32_t i, reg = 0;
    int32_t done = E1000_ERR_EEPROM;

    for (i = 0; i < attempts; i++) {
        if (eerd == E1000_EEPROM_POLL_READ)
            reg = E1000_READ_REG(hw, EERD);
        else
            reg = E1000_READ_REG(hw, EEWR);

        if (reg & E1000_EEPROM_RW_REG_DONE) {
            done = E1000_SUCCESS;
            break;
        }
        usec_delay(5);
    }
d5259 1
a5259 1
    return done;
d5262 5
a5266 5
/***************************************************************************
* Description:     Determines if the onboard NVM is FLASH or EEPROM.
*
* hw - Struct containing variables accessed by shared code
****************************************************************************/
d5270 2
a5271 1
    uint32_t eecd = 0;
d5273 17
a5289 19
    DEBUGFUNC("em_is_onboard_nvm_eeprom");

    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        return FALSE;

    if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
        eecd = E1000_READ_REG(hw, EECD);

        /* Isolate bits 15 & 16 */
        eecd = ((eecd >> 15) & 0x03);

        /* If both bits are set, device is Flash type */
        if (eecd == 0x03) {
            return FALSE;
        }
    }
    return TRUE;
d5304 62
a5365 59
    uint16_t checksum = 0;
    uint16_t i, eeprom_data;
    uint16_t checksum_reg;

    DEBUGFUNC("em_validate_eeprom_checksum");

    checksum_reg = hw->mac_type != em_icp_xxxx
                   ? EEPROM_CHECKSUM_REG
                   : EEPROM_CHECKSUM_REG_ICP_xxxx;

    if (((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) &&
        (em_is_onboard_nvm_eeprom(hw) == FALSE)) {
        /* Check bit 4 of word 10h.  If it is 0, firmware is done updating
         * 10h-12h.  Checksum may need to be fixed. */
        em_read_eeprom(hw, 0x10, 1, &eeprom_data);
        if ((eeprom_data & 0x10) == 0) {
            /* Read 0x23 and check bit 15.  This bit is a 1 when the checksum
             * has already been fixed.  If the checksum is still wrong and this
             * bit is a 1, we need to return bad checksum.  Otherwise, we need
             * to set this bit to a 1 and update the checksum. */
            em_read_eeprom(hw, 0x23, 1, &eeprom_data);
            if ((eeprom_data & 0x8000) == 0) {
                eeprom_data |= 0x8000;
                em_write_eeprom(hw, 0x23, 1, &eeprom_data);
                em_update_eeprom_checksum(hw);
            }
        }
    }

    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
        /* Drivers must allocate the shadow ram structure for the
         * EEPROM checksum to be updated.  Otherwise, this bit as well
         * as the checksum must both be set correctly for this
         * validation to pass.
         */
        em_read_eeprom(hw, 0x19, 1, &eeprom_data);
        if ((eeprom_data & 0x40) == 0) {
            eeprom_data |= 0x40;
            em_write_eeprom(hw, 0x19, 1, &eeprom_data);
            em_update_eeprom_checksum(hw);
        }
    }

    for (i = 0; i < (checksum_reg + 1); i++) {
        if (em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
            DEBUGOUT("EEPROM Read Error\n");
            return -E1000_ERR_EEPROM;
        }
        checksum += eeprom_data;
    }

    if (checksum == (uint16_t) EEPROM_SUM)
        return E1000_SUCCESS;
    else {
        DEBUGOUT("EEPROM Checksum Invalid\n");
        return -E1000_ERR_EEPROM;
    }
d5379 30
a5408 29
    uint32_t ctrl_ext;
    uint16_t checksum = 0;
    uint16_t i, eeprom_data;

    DEBUGFUNC("em_update_eeprom_checksum");

    for (i = 0; i < EEPROM_CHECKSUM_REG; i++) {
        if (em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
            DEBUGOUT("EEPROM Read Error\n");
            return -E1000_ERR_EEPROM;
        }
        checksum += eeprom_data;
    }
    checksum = (uint16_t) EEPROM_SUM - checksum;
    if (em_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
        DEBUGOUT("EEPROM Write Error\n");
        return -E1000_ERR_EEPROM;
    } else if (hw->eeprom.type == em_eeprom_flash) {
        em_commit_shadow_ram(hw);
    } else if (hw->eeprom.type == em_eeprom_ich8) {
        em_commit_shadow_ram(hw);
        /* Reload the EEPROM, or else modifications will not appear
         * until after next adapter reset. */
        ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
        ctrl_ext |= E1000_CTRL_EXT_EE_RST;
        E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
        msec_delay(10);
    }
    return E1000_SUCCESS;
d5423 37
a5459 40
em_write_eeprom(struct em_hw *hw,
                   uint16_t offset,
                   uint16_t words,
                   uint16_t *data)
{
    struct em_eeprom_info *eeprom = &hw->eeprom;
    int32_t status = 0;

    DEBUGFUNC("em_write_eeprom");

    /* If eeprom is not yet detected, do so now */
    if (eeprom->word_size == 0)
        em_init_eeprom_params(hw);

    /* A check for invalid values:  offset too large, too many words, and not
     * enough words.
     */
    if ((offset >= eeprom->word_size) || (words > eeprom->word_size - offset) ||
       (words == 0)) {
        DEBUGOUT("\"words\" parameter out of bounds\n");
        return -E1000_ERR_EEPROM;
    }

    /* 82573/4 writes only through eewr */
    if (eeprom->use_eewr == TRUE)
        return em_write_eeprom_eewr(hw, offset, words, data);

    if (eeprom->type == em_eeprom_ich8)
        return em_write_eeprom_ich8(hw, offset, words, data);

    /* Prepare the EEPROM for writing  */
    if (em_acquire_eeprom(hw) != E1000_SUCCESS)
        return -E1000_ERR_EEPROM;

    if (eeprom->type == em_eeprom_microwire) {
        status = em_write_eeprom_microwire(hw, offset, words, data);
    } else {
        status = em_write_eeprom_spi(hw, offset, words, data);
        msec_delay(10);
    }
d5461 2
a5462 2
    /* Done with writing */
    em_release_eeprom(hw);
d5464 1
a5464 1
    return status;
d5477 2
a5478 4
em_write_eeprom_spi(struct em_hw *hw,
                       uint16_t offset,
                       uint16_t words,
                       uint16_t *data)
d5480 51
a5530 21
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint16_t widx = 0;

    DEBUGFUNC("em_write_eeprom_spi");

    while (widx < words) {
        uint8_t write_opcode = EEPROM_WRITE_OPCODE_SPI;

        if (em_spi_eeprom_ready(hw)) return -E1000_ERR_EEPROM;

        em_standby_eeprom(hw);

        /*  Send the WRITE ENABLE command (8 bit opcode )  */
        em_shift_out_ee_bits(hw, EEPROM_WREN_OPCODE_SPI,
                                    eeprom->opcode_bits);

        em_standby_eeprom(hw);

        /* Some SPI eeproms use the 8th address bit embedded in the opcode */
        if ((eeprom->address_bits == 8) && (offset >= 128))
            write_opcode |= EEPROM_A8_OPCODE_SPI;
d5532 1
a5532 27
        /* Send the Write command (8-bit opcode + addr) */
        em_shift_out_ee_bits(hw, write_opcode, eeprom->opcode_bits);

        em_shift_out_ee_bits(hw, (uint16_t)((offset + widx)*2),
                                eeprom->address_bits);

        /* Send the data */

        /* Loop to allow for up to whole page write (32 bytes) of eeprom */
        while (widx < words) {
            uint16_t word_out = data[widx];
            word_out = (word_out >> 8) | (word_out << 8);
            em_shift_out_ee_bits(hw, word_out, 16);
            widx++;

            /* Some larger eeprom sizes are capable of a 32-byte PAGE WRITE
             * operation, while the smaller eeproms are capable of an 8-byte
             * PAGE WRITE operation.  Break the inner loop to pass new address
             */
            if ((((offset + widx)*2) % eeprom->page_size) == 0) {
                em_standby_eeprom(hw);
                break;
            }
        }
    }

    return E1000_SUCCESS;
d5545 17
a5561 30
em_write_eeprom_microwire(struct em_hw *hw,
                             uint16_t offset,
                             uint16_t words,
                             uint16_t *data)
{
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint32_t eecd;
    uint16_t words_written = 0;
    uint16_t i = 0;

    DEBUGFUNC("em_write_eeprom_microwire");

    /* Send the write enable command to the EEPROM (3-bit opcode plus
     * 6/8-bit dummy address beginning with 11).  It's less work to include
     * the 11 of the dummy address as part of the opcode than it is to shift
     * it over the correct number of bits for the address.  This puts the
     * EEPROM into write/erase mode.
     */
    em_shift_out_ee_bits(hw, EEPROM_EWEN_OPCODE_MICROWIRE,
                            (uint16_t)(eeprom->opcode_bits + 2));

    em_shift_out_ee_bits(hw, 0, (uint16_t)(eeprom->address_bits - 2));

    /* Prepare the EEPROM */
    em_standby_eeprom(hw);

    while (words_written < words) {
        /* Send the Write command (3-bit opcode + addr) */
        em_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE_MICROWIRE,
                                eeprom->opcode_bits);
d5563 1
a5563 2
        em_shift_out_ee_bits(hw, (uint16_t)(offset + words_written),
                                eeprom->address_bits);
d5565 2
a5566 2
        /* Send the data */
        em_shift_out_ee_bits(hw, data[words_written], 16);
d5568 45
a5612 33
        /* Toggle the CS line.  This in effect tells the EEPROM to execute
         * the previous command.
         */
        em_standby_eeprom(hw);

        /* Read DO repeatedly until it is high (equal to '1').  The EEPROM will
         * signal that the command has been completed by raising the DO signal.
         * If DO does not go high in 10 milliseconds, then error out.
         */
        for (i = 0; i < 200; i++) {
            eecd = E1000_READ_REG(hw, EECD);
            if (eecd & E1000_EECD_DO) break;
            usec_delay(50);
        }
        if (i == 200) {
            DEBUGOUT("EEPROM Write did not complete\n");
            return -E1000_ERR_EEPROM;
        }

        /* Recover from write */
        em_standby_eeprom(hw);

        words_written++;
    }

    /* Send the write disable command to the EEPROM (3-bit opcode plus
     * 6/8-bit dummy address beginning with 10).  It's less work to include
     * the 10 of the dummy address as part of the opcode than it is to shift
     * it over the correct number of bits for the address.  This takes the
     * EEPROM out of write/erase mode.
     */
    em_shift_out_ee_bits(hw, EEPROM_EWDS_OPCODE_MICROWIRE,
                            (uint16_t)(eeprom->opcode_bits + 2));
d5614 1
a5614 1
    em_shift_out_ee_bits(hw, 0, (uint16_t)(eeprom->address_bits - 2));
d5616 1
a5616 1
    return E1000_SUCCESS;
d5632 177
a5808 154
    uint32_t attempts = 100000;
    uint32_t eecd = 0;
    uint32_t flop = 0;
    uint32_t i = 0;
    int32_t error = E1000_SUCCESS;
    uint32_t old_bank_offset = 0;
    uint32_t new_bank_offset = 0;
    uint8_t low_byte = 0;
    uint8_t high_byte = 0;
    boolean_t sector_write_failed = FALSE;

    if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
        /* The flop register will be used to determine if flash type is STM */
        flop = E1000_READ_REG(hw, FLOP);
        for (i=0; i < attempts; i++) {
            eecd = E1000_READ_REG(hw, EECD);
            if ((eecd & E1000_EECD_FLUPD) == 0) {
                break;
            }
            usec_delay(5);
        }

        if (i == attempts) {
            return -E1000_ERR_EEPROM;
        }

        /* If STM opcode located in bits 15:8 of flop, reset firmware */
        if ((flop & 0xFF00) == E1000_STM_OPCODE) {
            E1000_WRITE_REG(hw, HICR, E1000_HICR_FW_RESET);
        }

        /* Perform the flash update */
        E1000_WRITE_REG(hw, EECD, eecd | E1000_EECD_FLUPD);

        for (i=0; i < attempts; i++) {
            eecd = E1000_READ_REG(hw, EECD);
            if ((eecd & E1000_EECD_FLUPD) == 0) {
                break;
            }
            usec_delay(5);
        }

        if (i == attempts) {
            return -E1000_ERR_EEPROM;
        }
    }

    if ((hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) &&
        hw->eeprom_shadow_ram != NULL) {
        /* We're writing to the opposite bank so if we're on bank 1,
         * write to bank 0 etc.  We also need to erase the segment that
         * is going to be written */
        if (!(E1000_READ_REG(hw, EECD) & E1000_EECD_SEC1VAL)) {
            new_bank_offset = hw->flash_bank_size * 2;
            old_bank_offset = 0;
            em_erase_ich8_4k_segment(hw, 1);
        } else {
            old_bank_offset = hw->flash_bank_size * 2;
            new_bank_offset = 0;
            em_erase_ich8_4k_segment(hw, 0);
        }

        sector_write_failed = FALSE;
        /* Loop for every byte in the shadow RAM,
         * which is in units of words. */
        for (i = 0; i < E1000_SHADOW_RAM_WORDS; i++) {
            /* Determine whether to write the value stored
             * in the other NVM bank or a modified value stored
             * in the shadow RAM */
            if (hw->eeprom_shadow_ram[i].modified == TRUE) {
                low_byte = (uint8_t)hw->eeprom_shadow_ram[i].eeprom_word;
                usec_delay(100);
                error = em_verify_write_ich8_byte(hw,
                            (i << 1) + new_bank_offset, low_byte);

                if (error != E1000_SUCCESS)
                    sector_write_failed = TRUE;
                else {
                    high_byte =
                        (uint8_t)(hw->eeprom_shadow_ram[i].eeprom_word >> 8);
                    usec_delay(100);
                }
            } else {
                em_read_ich8_byte(hw, (i << 1) + old_bank_offset,
                                     &low_byte);
                usec_delay(100);
                error = em_verify_write_ich8_byte(hw,
                            (i << 1) + new_bank_offset, low_byte);

                if (error != E1000_SUCCESS)
                    sector_write_failed = TRUE;
                else {
                    em_read_ich8_byte(hw, (i << 1) + old_bank_offset + 1,
                                         &high_byte);
                    usec_delay(100);
                }
            }

            /* If the write of the low byte was successful, go ahread and
             * write the high byte while checking to make sure that if it
             * is the signature byte, then it is handled properly */
            if (sector_write_failed == FALSE) {
                /* If the word is 0x13, then make sure the signature bits
                 * (15:14) are 11b until the commit has completed.
                 * This will allow us to write 10b which indicates the
                 * signature is valid.  We want to do this after the write
                 * has completed so that we don't mark the segment valid
                 * while the write is still in progress */
                if (i == E1000_ICH_NVM_SIG_WORD)
                    high_byte = E1000_ICH_NVM_SIG_MASK | high_byte;

                error = em_verify_write_ich8_byte(hw,
                            (i << 1) + new_bank_offset + 1, high_byte);
                if (error != E1000_SUCCESS)
                    sector_write_failed = TRUE;

            } else {
                /* If the write failed then break from the loop and
                 * return an error */
                break;
            }
        }

        /* Don't bother writing the segment valid bits if sector
         * programming failed. */
        if (sector_write_failed == FALSE) {
            /* Finally validate the new segment by setting bit 15:14
             * to 10b in word 0x13 , this can be done without an
             * erase as well since these bits are 11 to start with
             * and we need to change bit 14 to 0b */
            em_read_ich8_byte(hw,
                                 E1000_ICH_NVM_SIG_WORD * 2 + 1 + new_bank_offset,
                                 &high_byte);
            high_byte &= 0xBF;
            error = em_verify_write_ich8_byte(hw,
                        E1000_ICH_NVM_SIG_WORD * 2 + 1 + new_bank_offset, high_byte);
            /* And invalidate the previously valid segment by setting
             * its signature word (0x13) high_byte to 0b. This can be
             * done without an erase because flash erase sets all bits
             * to 1's. We can write 1's to 0's without an erase */
            if (error == E1000_SUCCESS) {
                error = em_verify_write_ich8_byte(hw,
                            E1000_ICH_NVM_SIG_WORD * 2 + 1 + old_bank_offset, 0);
            }

            /* Clear the now not used entry in the cache */
            for (i = 0; i < E1000_SHADOW_RAM_WORDS; i++) {
                hw->eeprom_shadow_ram[i].modified = FALSE;
                hw->eeprom_shadow_ram[i].eeprom_word = 0xFFFF;
            }
        }
    }

    return error;
d5818 1
a5818 2
em_read_part_num(struct em_hw *hw,
                    uint32_t *part_num)
d5820 19
a5838 2
    uint16_t offset = EEPROM_PBA_BYTE_1;
    uint16_t eeprom_data;
d5840 1
a5840 19
    DEBUGFUNC("em_read_part_num");

    /* Get word 0 from EEPROM */
    if (em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
        DEBUGOUT("EEPROM Read Error\n");
        return -E1000_ERR_EEPROM;
    }
    /* Save word 0 in upper half of part_num */
    *part_num = (uint32_t) (eeprom_data << 16);

    /* Get word 1 from EEPROM */
    if (em_read_eeprom(hw, ++offset, 1, &eeprom_data) < 0) {
        DEBUGOUT("EEPROM Read Error\n");
        return -E1000_ERR_EEPROM;
    }
    /* Save word 1 in lower half of part_num */
    *part_num |= eeprom_data;

    return E1000_SUCCESS;
d5850 1
a5850 1
em_read_mac_addr(struct em_hw * hw)
d5852 36
a5887 37
    uint16_t offset;
    uint16_t eeprom_data, i;
    uint16_t ia_base_addr = 0;

    DEBUGFUNC("em_read_mac_addr");

    if(hw->mac_type == em_icp_xxxx) {
        ia_base_addr = (uint16_t) 
            EEPROM_IA_START_ICP_xxxx(hw->icp_xxxx_port_num);
    }

    for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
        offset = i >> 1;
        if (em_read_eeprom(hw, offset + ia_base_addr, 1, &eeprom_data) < 0) {
            DEBUGOUT("EEPROM Read Error\n");
            return -E1000_ERR_EEPROM;
        }
        hw->perm_mac_addr[i] = (uint8_t) (eeprom_data & 0x00FF);
        hw->perm_mac_addr[i+1] = (uint8_t) (eeprom_data >> 8);
    }

    switch (hw->mac_type) {
    default:
        break;
    case em_82546:
    case em_82546_rev_3:
    case em_82571:
    case em_82575:
    case em_80003es2lan:
        if (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)
            hw->perm_mac_addr[5] ^= 0x01;
        break;
    }

    for (i = 0; i < NODE_ADDRESS_SIZE; i++)
        hw->mac_addr[i] = hw->perm_mac_addr[i];
    return E1000_SUCCESS;
d5902 32
a5933 32
    uint32_t i;
    uint32_t rar_num;

    DEBUGFUNC("em_init_rx_addrs");

    /* Setup the receive address. */
    DEBUGOUT("Programming MAC Address into RAR[0]\n");

    em_rar_set(hw, hw->mac_addr, 0);

    rar_num = E1000_RAR_ENTRIES;

    /* Reserve a spot for the Locally Administered Address to work around
     * an 82571 issue in which a reset on one port will reload the MAC on
     * the other port. */
    if ((hw->mac_type == em_82571) && (hw->laa_is_present == TRUE))
        rar_num -= 1;
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        rar_num = E1000_RAR_ENTRIES_ICH8LAN;
    if (hw->mac_type == em_ich8lan)
        rar_num -= 1;

    /* Zero out the other 15 receive addresses. */
    DEBUGOUT("Clearing RAR[1-15]\n");
    for (i = 1; i < rar_num; i++) {
        E1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);
        E1000_WRITE_FLUSH(hw);
        E1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);
        E1000_WRITE_FLUSH(hw);
    }
d5951 13
a5963 66
em_mc_addr_list_update(struct em_hw *hw,
                          uint8_t *mc_addr_list,
                          uint32_t mc_addr_count,
                          uint32_t pad,
                          uint32_t rar_used_count)
{
    uint32_t hash_value;
    uint32_t i;
    uint32_t num_rar_entry;
    uint32_t num_mta_entry;

    DEBUGFUNC("em_mc_addr_list_update");

    /* Set the new number of MC addresses that we are being requested to use. */
    hw->num_mc_addrs = mc_addr_count;

    /* Clear RAR[1-15] */
    DEBUGOUT(" Clearing RAR[1-15]\n");
    num_rar_entry = E1000_RAR_ENTRIES;
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        num_rar_entry = E1000_RAR_ENTRIES_ICH8LAN;
    if (hw->mac_type == em_ich8lan)
        num_rar_entry -= 1;

    /* Reserve a spot for the Locally Administered Address to work around
     * an 82571 issue in which a reset on one port will reload the MAC on
     * the other port. */
    if ((hw->mac_type == em_82571) && (hw->laa_is_present == TRUE))
        num_rar_entry -= 1;

    for (i = rar_used_count; i < num_rar_entry; i++) {
        E1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);
        E1000_WRITE_FLUSH(hw);
        E1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);
        E1000_WRITE_FLUSH(hw);
    }

    /* Clear the MTA */
    DEBUGOUT(" Clearing MTA\n");
    num_mta_entry = E1000_NUM_MTA_REGISTERS;
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        num_mta_entry = E1000_NUM_MTA_REGISTERS_ICH8LAN;

    for (i = 0; i < num_mta_entry; i++) {
        E1000_WRITE_REG_ARRAY(hw, MTA, i, 0);
        E1000_WRITE_FLUSH(hw);
    }

    /* Add the new addresses */
    for (i = 0; i < mc_addr_count; i++) {
        DEBUGOUT(" Adding the multicast addresses:\n");
        DEBUGOUT7(" MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X\n", i,
                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad)],
                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 1],
                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 2],
                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 3],
                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 4],
                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 5]);

        hash_value = em_hash_mc_addr(hw,
                                        mc_addr_list +
                                        (i * (ETH_LENGTH_OF_ADDRESS + pad)));
d5965 16
a5980 1
        DEBUGOUT1(" Hash value = 0x%03X\n", hash_value);
d5982 49
a6030 13
        /* Place this multicast address in the RAR if there is room, *
         * else put it in the MTA
         */
        if (rar_used_count < num_rar_entry) {
            em_rar_set(hw,
                          mc_addr_list + (i * (ETH_LENGTH_OF_ADDRESS + pad)),
                          rar_used_count);
            rar_used_count++;
        } else {
            em_mta_set(hw, hash_value);
        }
    }
    DEBUGOUT("MC Update Complete\n");
d6040 1
a6040 2
em_hash_mc_addr(struct em_hw *hw,
                   uint8_t *mc_addr)
d6042 69
a6110 61
    uint32_t hash_value = 0;

    /* The portion of the address that is used for the hash table is
     * determined by the mc_filter_type setting.
     */
    switch (hw->mc_filter_type) {
    /* [0] [1] [2] [3] [4] [5]
     * 01  AA  00  12  34  56
     * LSB                 MSB
     */
    case 0:
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
            /* [47:38] i.e. 0x158 for above example address */
            hash_value = ((mc_addr[4] >> 6) | (((uint16_t) mc_addr[5]) << 2));
        } else {
            /* [47:36] i.e. 0x563 for above example address */
            hash_value = ((mc_addr[4] >> 4) | (((uint16_t) mc_addr[5]) << 4));
        }
        break;
    case 1:
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
            /* [46:37] i.e. 0x2B1 for above example address */
            hash_value = ((mc_addr[4] >> 5) | (((uint16_t) mc_addr[5]) << 3));
        } else {
            /* [46:35] i.e. 0xAC6 for above example address */
            hash_value = ((mc_addr[4] >> 3) | (((uint16_t) mc_addr[5]) << 5));
        }
        break;
    case 2:
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
            /*[45:36] i.e. 0x163 for above example address */
            hash_value = ((mc_addr[4] >> 4) | (((uint16_t) mc_addr[5]) << 4));
        } else {
            /* [45:34] i.e. 0x5D8 for above example address */
            hash_value = ((mc_addr[4] >> 2) | (((uint16_t) mc_addr[5]) << 6));
        }
        break;
    case 3:
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
            /* [43:34] i.e. 0x18D for above example address */
            hash_value = ((mc_addr[4] >> 2) | (((uint16_t) mc_addr[5]) << 6));
        } else {
            /* [43:32] i.e. 0x634 for above example address */
            hash_value = ((mc_addr[4]) | (((uint16_t) mc_addr[5]) << 8));
        }
        break;
    }

    hash_value &= 0xFFF;
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        hash_value &= 0x3FF;
d6112 1
a6112 1
    return hash_value;
d6122 1
a6122 2
em_mta_set(struct em_hw *hw,
              uint32_t hash_value)
d6124 38
a6161 38
    uint32_t hash_bit, hash_reg;
    uint32_t mta;
    uint32_t temp;

    /* The MTA is a register array of 128 32-bit registers.
     * It is treated like an array of 4096 bits.  We want to set
     * bit BitArray[hash_value]. So we figure out what register
     * the bit is in, read it, OR in the new bit, then write
     * back the new value.  The register is determined by the
     * upper 7 bits of the hash value and the bit within that
     * register are determined by the lower 5 bits of the value.
     */
    hash_reg = (hash_value >> 5) & 0x7F;
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        hash_reg &= 0x1F;

    hash_bit = hash_value & 0x1F;

    mta = E1000_READ_REG_ARRAY(hw, MTA, hash_reg);

    mta |= (1 << hash_bit);

    /* If we are on an 82544 and we are trying to write an odd offset
     * in the MTA, save off the previous entry before writing and
     * restore the old value after writing.
     */
    if ((hw->mac_type == em_82544) && ((hash_reg & 0x1) == 1)) {
        temp = E1000_READ_REG_ARRAY(hw, MTA, (hash_reg - 1));
        E1000_WRITE_REG_ARRAY(hw, MTA, hash_reg, mta);
        E1000_WRITE_FLUSH(hw);
        E1000_WRITE_REG_ARRAY(hw, MTA, (hash_reg - 1), temp);
        E1000_WRITE_FLUSH(hw);
    } else {
        E1000_WRITE_REG_ARRAY(hw, MTA, hash_reg, mta);
        E1000_WRITE_FLUSH(hw);
    }
d6172 44
a6215 48
em_rar_set(struct em_hw *hw,
              uint8_t *addr,
              uint32_t index)
{
    uint32_t rar_low, rar_high;

    /* HW expects these in little endian so we reverse the byte order
     * from network order (big endian) to little endian
     */
    rar_low = ((uint32_t) addr[0] |
               ((uint32_t) addr[1] << 8) |
               ((uint32_t) addr[2] << 16) | ((uint32_t) addr[3] << 24));
    rar_high = ((uint32_t) addr[4] | ((uint32_t) addr[5] << 8));

    /* Disable Rx and flush all Rx frames before enabling RSS to avoid Rx
     * unit hang.
     *
     * Description:
     * If there are any Rx frames queued up or otherwise present in the HW
     * before RSS is enabled, and then we enable RSS, the HW Rx unit will
     * hang.  To work around this issue, we have to disable receives and
     * flush out all Rx frames before we enable RSS. To do so, we modify we
     * redirect all Rx traffic to manageability and then reset the HW.
     * This flushes away Rx frames, and (since the redirections to
     * manageability persists across resets) keeps new ones from coming in
     * while we work.  Then, we clear the Address Valid AV bit for all MAC
     * addresses and undo the re-direction to manageability.
     * Now, frames are coming in again, but the MAC won't accept them, so
     * far so good.  We now proceed to initialize RSS (if necessary) and
     * configure the Rx unit.  Last, we re-enable the AV bits and continue
     * on our merry way.
     */
    switch (hw->mac_type) {
    case em_82571:
    case em_82572:
    case em_80003es2lan:
        if (hw->leave_av_bit_off == TRUE)
            break;
    default:
        /* Indicate to hardware the Address is Valid. */
        rar_high |= E1000_RAH_AV;
        break;
    }

    E1000_WRITE_REG_ARRAY(hw, RA, (index << 1), rar_low);
    E1000_WRITE_FLUSH(hw);
    E1000_WRITE_REG_ARRAY(hw, RA, ((index << 1) + 1), rar_high);
    E1000_WRITE_FLUSH(hw);
d6226 111
a6336 111
    uint32_t offset;
    uint32_t vfta_value = 0;
    uint32_t vfta_offset = 0;
    uint32_t vfta_bit_in_reg = 0;

    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        return;

    if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) {
        if (hw->mng_cookie.vlan_id != 0) {
            /* The VFTA is a 4096b bit-field, each identifying a single VLAN
             * ID.  The following operations determine which 32b entry
             * (i.e. offset) into the array we want to set the VLAN ID
             * (i.e. bit) of the manageability unit. */
            vfta_offset = (hw->mng_cookie.vlan_id >>
                           E1000_VFTA_ENTRY_SHIFT) &
                          E1000_VFTA_ENTRY_MASK;
            vfta_bit_in_reg = 1 << (hw->mng_cookie.vlan_id &
                                    E1000_VFTA_ENTRY_BIT_SHIFT_MASK);
        }
    }
    for (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {
        /* If the offset we want to clear is the same offset of the
         * manageability VLAN ID, then clear all bits except that of the
         * manageability unit */
        vfta_value = (offset == vfta_offset) ? vfta_bit_in_reg : 0;
        E1000_WRITE_REG_ARRAY(hw, VFTA, offset, vfta_value);
        E1000_WRITE_FLUSH(hw);
    }
}

STATIC int32_t
em_id_led_init(struct em_hw * hw)
{
    uint32_t ledctl;
    const uint32_t ledctl_mask = 0x000000FF;
    const uint32_t ledctl_on = E1000_LEDCTL_MODE_LED_ON;
    const uint32_t ledctl_off = E1000_LEDCTL_MODE_LED_OFF;
    uint16_t eeprom_data, i, temp;
    const uint16_t led_mask = 0x0F;

    DEBUGFUNC("em_id_led_init");

    if (hw->mac_type < em_82540 || hw->mac_type == em_icp_xxxx) {
        /* Nothing to do */
        return E1000_SUCCESS;
    }

    ledctl = E1000_READ_REG(hw, LEDCTL);
    hw->ledctl_default = ledctl;
    hw->ledctl_mode1 = hw->ledctl_default;
    hw->ledctl_mode2 = hw->ledctl_default;

    if (em_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {
        DEBUGOUT("EEPROM Read Error\n");
        return -E1000_ERR_EEPROM;
    }

    if ((hw->mac_type == em_82573) &&
        (eeprom_data == ID_LED_RESERVED_82573))
        eeprom_data = ID_LED_DEFAULT_82573;
    else if ((eeprom_data == ID_LED_RESERVED_0000) ||
            (eeprom_data == ID_LED_RESERVED_FFFF)) {
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan)
            eeprom_data = ID_LED_DEFAULT_ICH8LAN;
        else
            eeprom_data = ID_LED_DEFAULT;
    }

    for (i = 0; i < 4; i++) {
        temp = (eeprom_data >> (i << 2)) & led_mask;
        switch (temp) {
        case ID_LED_ON1_DEF2:
        case ID_LED_ON1_ON2:
        case ID_LED_ON1_OFF2:
            hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
            hw->ledctl_mode1 |= ledctl_on << (i << 3);
            break;
        case ID_LED_OFF1_DEF2:
        case ID_LED_OFF1_ON2:
        case ID_LED_OFF1_OFF2:
            hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
            hw->ledctl_mode1 |= ledctl_off << (i << 3);
            break;
        default:
            /* Do nothing */
            break;
        }
        switch (temp) {
        case ID_LED_DEF1_ON2:
        case ID_LED_ON1_ON2:
        case ID_LED_OFF1_ON2:
            hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
            hw->ledctl_mode2 |= ledctl_on << (i << 3);
            break;
        case ID_LED_DEF1_OFF2:
        case ID_LED_ON1_OFF2:
        case ID_LED_OFF1_OFF2:
            hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
            hw->ledctl_mode2 |= ledctl_off << (i << 3);
            break;
        default:
            /* Do nothing */
            break;
        }
    }
    return E1000_SUCCESS;
d6347 97
a6443 97
    volatile uint32_t temp;

    temp = E1000_READ_REG(hw, CRCERRS);
    temp = E1000_READ_REG(hw, SYMERRS);
    temp = E1000_READ_REG(hw, MPC);
    temp = E1000_READ_REG(hw, SCC);
    temp = E1000_READ_REG(hw, ECOL);
    temp = E1000_READ_REG(hw, MCC);
    temp = E1000_READ_REG(hw, LATECOL);
    temp = E1000_READ_REG(hw, COLC);
    temp = E1000_READ_REG(hw, DC);
    temp = E1000_READ_REG(hw, SEC);
    temp = E1000_READ_REG(hw, RLEC);
    temp = E1000_READ_REG(hw, XONRXC);
    temp = E1000_READ_REG(hw, XONTXC);
    temp = E1000_READ_REG(hw, XOFFRXC);
    temp = E1000_READ_REG(hw, XOFFTXC);
    temp = E1000_READ_REG(hw, FCRUC);

    if (hw->mac_type != em_ich8lan &&
        hw->mac_type != em_ich9lan &&
        hw->mac_type != em_ich10lan) {
    temp = E1000_READ_REG(hw, PRC64);
    temp = E1000_READ_REG(hw, PRC127);
    temp = E1000_READ_REG(hw, PRC255);
    temp = E1000_READ_REG(hw, PRC511);
    temp = E1000_READ_REG(hw, PRC1023);
    temp = E1000_READ_REG(hw, PRC1522);
    }

    temp = E1000_READ_REG(hw, GPRC);
    temp = E1000_READ_REG(hw, BPRC);
    temp = E1000_READ_REG(hw, MPRC);
    temp = E1000_READ_REG(hw, GPTC);
    temp = E1000_READ_REG(hw, GORCL);
    temp = E1000_READ_REG(hw, GORCH);
    temp = E1000_READ_REG(hw, GOTCL);
    temp = E1000_READ_REG(hw, GOTCH);
    temp = E1000_READ_REG(hw, RNBC);
    temp = E1000_READ_REG(hw, RUC);
    temp = E1000_READ_REG(hw, RFC);
    temp = E1000_READ_REG(hw, ROC);
    temp = E1000_READ_REG(hw, RJC);
    temp = E1000_READ_REG(hw, TORL);
    temp = E1000_READ_REG(hw, TORH);
    temp = E1000_READ_REG(hw, TOTL);
    temp = E1000_READ_REG(hw, TOTH);
    temp = E1000_READ_REG(hw, TPR);
    temp = E1000_READ_REG(hw, TPT);

    if (hw->mac_type != em_ich8lan &&
        hw->mac_type != em_ich9lan &&
        hw->mac_type != em_ich10lan) {
    temp = E1000_READ_REG(hw, PTC64);
    temp = E1000_READ_REG(hw, PTC127);
    temp = E1000_READ_REG(hw, PTC255);
    temp = E1000_READ_REG(hw, PTC511);
    temp = E1000_READ_REG(hw, PTC1023);
    temp = E1000_READ_REG(hw, PTC1522);
    }

    temp = E1000_READ_REG(hw, MPTC);
    temp = E1000_READ_REG(hw, BPTC);

    if (hw->mac_type < em_82543) return;

    temp = E1000_READ_REG(hw, ALGNERRC);
    temp = E1000_READ_REG(hw, RXERRC);
    temp = E1000_READ_REG(hw, TNCRS);
    temp = E1000_READ_REG(hw, CEXTERR);
    temp = E1000_READ_REG(hw, TSCTC);
    temp = E1000_READ_REG(hw, TSCTFC);

    if (hw->mac_type <= em_82544
	|| hw->mac_type == em_icp_xxxx) return;

    temp = E1000_READ_REG(hw, MGTPRC);
    temp = E1000_READ_REG(hw, MGTPDC);
    temp = E1000_READ_REG(hw, MGTPTC);

    if (hw->mac_type <= em_82547_rev_2) return;

    temp = E1000_READ_REG(hw, IAC);
    temp = E1000_READ_REG(hw, ICRXOC);

    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
        return;

    temp = E1000_READ_REG(hw, ICRXPTC);
    temp = E1000_READ_REG(hw, ICRXATC);
    temp = E1000_READ_REG(hw, ICTXPTC);
    temp = E1000_READ_REG(hw, ICTXATC);
    temp = E1000_READ_REG(hw, ICTXQEC);
    temp = E1000_READ_REG(hw, ICTXQMTC);
    temp = E1000_READ_REG(hw, ICRXDMTC);
d6454 70
a6523 70
em_tbi_adjust_stats(struct em_hw *hw,
                       struct em_hw_stats *stats,
                       uint32_t frame_len,
                       uint8_t *mac_addr)
{
    uint64_t carry_bit;

    /* First adjust the frame length. */
    frame_len--;
    /* We need to adjust the statistics counters, since the hardware
     * counters overcount this packet as a CRC error and undercount
     * the packet as a good packet
     */
    /* This packet should not be counted as a CRC error.    */
    stats->crcerrs--;
    /* This packet does count as a Good Packet Received.    */
    stats->gprc++;

    /* Adjust the Good Octets received counters             */
    carry_bit = 0x80000000 & stats->gorcl;
    stats->gorcl += frame_len;
    /* If the high bit of Gorcl (the low 32 bits of the Good Octets
     * Received Count) was one before the addition,
     * AND it is zero after, then we lost the carry out,
     * need to add one to Gorch (Good Octets Received Count High).
     * This could be simplified if all environments supported
     * 64-bit integers.
     */
    if (carry_bit && ((stats->gorcl & 0x80000000) == 0))
        stats->gorch++;
    /* Is this a broadcast or multicast?  Check broadcast first,
     * since the test for a multicast frame will test positive on
     * a broadcast frame.
     */
    if ((mac_addr[0] == (uint8_t) 0xff) && (mac_addr[1] == (uint8_t) 0xff))
        /* Broadcast packet */
        stats->bprc++;
    else if (*mac_addr & 0x01)
        /* Multicast packet */
        stats->mprc++;

    if (frame_len == hw->max_frame_size) {
        /* In this case, the hardware has overcounted the number of
         * oversize frames.
         */
        if (stats->roc > 0)
            stats->roc--;
    }

    /* Adjust the bin counters when the extra byte put the frame in the
     * wrong bin. Remember that the frame_len was adjusted above.
     */
    if (frame_len == 64) {
        stats->prc64++;
        stats->prc127--;
    } else if (frame_len == 127) {
        stats->prc127++;
        stats->prc255--;
    } else if (frame_len == 255) {
        stats->prc255++;
        stats->prc511--;
    } else if (frame_len == 511) {
        stats->prc511++;
        stats->prc1023--;
    } else if (frame_len == 1023) {
        stats->prc1023++;
        stats->prc1522--;
    } else if (frame_len == 1522) {
        stats->prc1522++;
    }
d6534 69
a6602 71
    int32_t ret_val;
    uint16_t pci_ex_link_status;
    uint32_t status;

    switch (hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
        hw->bus_type = em_bus_type_unknown;
        hw->bus_speed = em_bus_speed_unknown;
        hw->bus_width = em_bus_width_unknown;
        break;
    case em_icp_xxxx:
        hw->bus_type = em_bus_type_cpp;
        hw->bus_speed = em_bus_speed_unknown;
        hw->bus_width = em_bus_width_unknown;
        break;
    case em_82571:
    case em_82572:
    case em_82573:
    case em_82574:
    case em_82575:
    case em_80003es2lan:
        hw->bus_type = em_bus_type_pci_express;
        hw->bus_speed = em_bus_speed_2500;
        ret_val = em_read_pcie_cap_reg(hw,
                                      PCI_EX_LINK_STATUS,
                                      &pci_ex_link_status);
        if (ret_val)
            hw->bus_width = em_bus_width_unknown;
        else
            hw->bus_width = (pci_ex_link_status & PCI_EX_LINK_WIDTH_MASK) >>
                          PCI_EX_LINK_WIDTH_SHIFT;
        break;
    case em_ich8lan:
    case em_ich9lan:
    case em_ich10lan:
        hw->bus_type = em_bus_type_pci_express;
        hw->bus_speed = em_bus_speed_2500;
        hw->bus_width = em_bus_width_pciex_1;
        break;
    default:
        status = E1000_READ_REG(hw, STATUS);
        hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
                       em_bus_type_pcix : em_bus_type_pci;

        if (hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
            hw->bus_speed = (hw->bus_type == em_bus_type_pci) ?
                            em_bus_speed_66 : em_bus_speed_120;
        } else if (hw->bus_type == em_bus_type_pci) {
            hw->bus_speed = (status & E1000_STATUS_PCI66) ?
                            em_bus_speed_66 : em_bus_speed_33;
        } else {
            switch (status & E1000_STATUS_PCIX_SPEED) {
            case E1000_STATUS_PCIX_SPEED_66:
                hw->bus_speed = em_bus_speed_66;
                break;
            case E1000_STATUS_PCIX_SPEED_100:
                hw->bus_speed = em_bus_speed_100;
                break;
            case E1000_STATUS_PCIX_SPEED_133:
                hw->bus_speed = em_bus_speed_133;
                break;
            default:
                hw->bus_speed = em_bus_speed_reserved;
                break;
            }
        }
        hw->bus_width = (status & E1000_STATUS_BUS64) ?
                        em_bus_width_64 : em_bus_width_32;
        break;
    }
d6614 1
a6614 3
em_write_reg_io(struct em_hw *hw,
                   uint32_t offset,
                   uint32_t value)
d6616 4
a6619 5
    unsigned long io_addr = hw->io_base;
    unsigned long io_data = hw->io_base + 4;

    em_io_write(hw, io_addr, offset);
    em_io_write(hw, io_data, value);
d6638 180
a6817 173
em_get_cable_length(struct em_hw *hw,
                       uint16_t *min_length,
                       uint16_t *max_length)
{
    int32_t ret_val;
    uint16_t agc_value = 0;
    uint16_t i, phy_data;
    uint16_t cable_length;

    DEBUGFUNC("em_get_cable_length");

    *min_length = *max_length = 0;

    /* Use old method for Phy older than IGP */
    if (hw->phy_type == em_phy_m88 ||
	hw->phy_type == em_phy_oem) {

        ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                     &phy_data);
        if (ret_val)
            return ret_val;
        cable_length = (phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
                       M88E1000_PSSR_CABLE_LENGTH_SHIFT;

        /* Convert the enum value to ranged values */
        switch (cable_length) {
        case em_cable_length_50:
            *min_length = 0;
            *max_length = em_igp_cable_length_50;
            break;
        case em_cable_length_50_80:
            *min_length = em_igp_cable_length_50;
            *max_length = em_igp_cable_length_80;
            break;
        case em_cable_length_80_110:
            *min_length = em_igp_cable_length_80;
            *max_length = em_igp_cable_length_110;
            break;
        case em_cable_length_110_140:
            *min_length = em_igp_cable_length_110;
            *max_length = em_igp_cable_length_140;
            break;
        case em_cable_length_140:
            *min_length = em_igp_cable_length_140;
            *max_length = em_igp_cable_length_170;
            break;
        default:
            return -E1000_ERR_PHY;
            break;
        }
    } else if (hw->phy_type == em_phy_gg82563) {
        ret_val = em_read_phy_reg(hw, GG82563_PHY_DSP_DISTANCE,
                                     &phy_data);
        if (ret_val)
            return ret_val;
        cable_length = phy_data & GG82563_DSPD_CABLE_LENGTH;

        switch (cable_length) {
        case em_gg_cable_length_60:
            *min_length = 0;
            *max_length = em_igp_cable_length_60;
            break;
        case em_gg_cable_length_60_115:
            *min_length = em_igp_cable_length_60;
            *max_length = em_igp_cable_length_115;
            break;
        case em_gg_cable_length_115_150:
            *min_length = em_igp_cable_length_115;
            *max_length = em_igp_cable_length_150;
            break;
        case em_gg_cable_length_150:
            *min_length = em_igp_cable_length_150;
            *max_length = em_igp_cable_length_180;
            break;
        default:
            return -E1000_ERR_PHY;
            break;
        }
    } else if (hw->phy_type == em_phy_igp) { /* For IGP PHY */
        uint16_t cur_agc_value;
        uint16_t min_agc_value = IGP01E1000_AGC_LENGTH_TABLE_SIZE;
        uint16_t agc_reg_array[IGP01E1000_PHY_CHANNEL_NUM] =
                                                         {IGP01E1000_PHY_AGC_A,
                                                          IGP01E1000_PHY_AGC_B,
                                                          IGP01E1000_PHY_AGC_C,
                                                          IGP01E1000_PHY_AGC_D};
        /* Read the AGC registers for all channels */
        for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {

            ret_val = em_read_phy_reg(hw, agc_reg_array[i], &phy_data);
            if (ret_val)
                return ret_val;

            cur_agc_value = phy_data >> IGP01E1000_AGC_LENGTH_SHIFT;

            /* Value bound check. */
            if ((cur_agc_value >= IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1) ||
                (cur_agc_value == 0))
                return -E1000_ERR_PHY;

            agc_value += cur_agc_value;

            /* Update minimal AGC value. */
            if (min_agc_value > cur_agc_value)
                min_agc_value = cur_agc_value;
        }

        /* Remove the minimal AGC result for length < 50m */
        if (agc_value < IGP01E1000_PHY_CHANNEL_NUM * em_igp_cable_length_50) {
            agc_value -= min_agc_value;

            /* Get the average length of the remaining 3 channels */
            agc_value /= (IGP01E1000_PHY_CHANNEL_NUM - 1);
        } else {
            /* Get the average length of all the 4 channels. */
            agc_value /= IGP01E1000_PHY_CHANNEL_NUM;
        }

        /* Set the range of the calculated length. */
        *min_length = ((em_igp_cable_length_table[agc_value] -
                       IGP01E1000_AGC_RANGE) > 0) ?
                       (em_igp_cable_length_table[agc_value] -
                       IGP01E1000_AGC_RANGE) : 0;
        *max_length = em_igp_cable_length_table[agc_value] +
                      IGP01E1000_AGC_RANGE;
    } else if (hw->phy_type == em_phy_igp_2 ||
               hw->phy_type == em_phy_igp_3) {
        uint16_t cur_agc_index, max_agc_index = 0;
        uint16_t min_agc_index = IGP02E1000_AGC_LENGTH_TABLE_SIZE - 1;
        uint16_t agc_reg_array[IGP02E1000_PHY_CHANNEL_NUM] =
                                                         {IGP02E1000_PHY_AGC_A,
                                                          IGP02E1000_PHY_AGC_B,
                                                          IGP02E1000_PHY_AGC_C,
                                                          IGP02E1000_PHY_AGC_D};
        /* Read the AGC registers for all channels */
        for (i = 0; i < IGP02E1000_PHY_CHANNEL_NUM; i++) {
            ret_val = em_read_phy_reg(hw, agc_reg_array[i], &phy_data);
            if (ret_val)
                return ret_val;

            /* Getting bits 15:9, which represent the combination of course and
             * fine gain values.  The result is a number that can be put into
             * the lookup table to obtain the approximate cable length. */
            cur_agc_index = (phy_data >> IGP02E1000_AGC_LENGTH_SHIFT) &
                            IGP02E1000_AGC_LENGTH_MASK;

            /* Array index bound check. */
            if ((cur_agc_index >= IGP02E1000_AGC_LENGTH_TABLE_SIZE) ||
                (cur_agc_index == 0))
                return -E1000_ERR_PHY;

            /* Remove min & max AGC values from calculation. */
            if (em_igp_2_cable_length_table[min_agc_index] >
                em_igp_2_cable_length_table[cur_agc_index])
                min_agc_index = cur_agc_index;
            if (em_igp_2_cable_length_table[max_agc_index] <
                em_igp_2_cable_length_table[cur_agc_index])
                max_agc_index = cur_agc_index;

            agc_value += em_igp_2_cable_length_table[cur_agc_index];
        }

        agc_value -= (em_igp_2_cable_length_table[min_agc_index] +
                      em_igp_2_cable_length_table[max_agc_index]);
        agc_value /= (IGP02E1000_PHY_CHANNEL_NUM - 2);

        /* Calculate cable length with the error range of +/- 10 meters. */
        *min_length = ((agc_value - IGP02E1000_AGC_RANGE) > 0) ?
                       (agc_value - IGP02E1000_AGC_RANGE) : 0;
        *max_length = agc_value + IGP02E1000_AGC_RANGE;
    }

    return E1000_SUCCESS;
d6838 29
a6866 30
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_check_downshift");

    if (hw->phy_type == em_phy_igp ||
        hw->phy_type == em_phy_igp_3 ||
        hw->phy_type == em_phy_igp_2) {
        ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH,
                                     &phy_data);
        if (ret_val)
            return ret_val;

        hw->speed_downgraded = (phy_data & IGP01E1000_PLHR_SS_DOWNGRADE) ? 1 : 0;
    } else if ((hw->phy_type == em_phy_m88) ||
               (hw->phy_type == em_phy_gg82563) ||
               (hw->phy_type == em_phy_oem)) {
        ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                     &phy_data);
        if (ret_val)
            return ret_val;

        hw->speed_downgraded = (phy_data & M88E1000_PSSR_DOWNSHIFT) >>
                               M88E1000_PSSR_DOWNSHIFT_SHIFT;
    } else if (hw->phy_type == em_phy_ife) {
        /* em_phy_ife supports 10/100 speed only */
        hw->speed_downgraded = FALSE;
    }

    return E1000_SUCCESS;
a6879 1

d6881 1
a6881 2
em_config_dsp_after_link_change(struct em_hw *hw,
                                   boolean_t link_up)
d6883 180
a7062 174
    int32_t ret_val;
    uint16_t phy_data, phy_saved_data, speed, duplex, i;
    uint16_t dsp_reg_array[IGP01E1000_PHY_CHANNEL_NUM] =
                                        {IGP01E1000_PHY_AGC_PARAM_A,
                                        IGP01E1000_PHY_AGC_PARAM_B,
                                        IGP01E1000_PHY_AGC_PARAM_C,
                                        IGP01E1000_PHY_AGC_PARAM_D};
    uint16_t min_length, max_length;

    DEBUGFUNC("em_config_dsp_after_link_change");

    if (hw->phy_type != em_phy_igp)
        return E1000_SUCCESS;

    if (link_up) {
        ret_val = em_get_speed_and_duplex(hw, &speed, &duplex);
        if (ret_val) {
            DEBUGOUT("Error getting link speed and duplex\n");
            return ret_val;
        }

        if (speed == SPEED_1000) {

            ret_val = em_get_cable_length(hw, &min_length, &max_length);
            if (ret_val)
                return ret_val;

            if ((hw->dsp_config_state == em_dsp_config_enabled) &&
                min_length >= em_igp_cable_length_50) {

                for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
                    ret_val = em_read_phy_reg(hw, dsp_reg_array[i],
                                                 &phy_data);
                    if (ret_val)
                        return ret_val;

                    phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;

                    ret_val = em_write_phy_reg(hw, dsp_reg_array[i],
                                                  phy_data);
                    if (ret_val)
                        return ret_val;
                }
                hw->dsp_config_state = em_dsp_config_activated;
            }

            if ((hw->ffe_config_state == em_ffe_config_enabled) &&
               (min_length < em_igp_cable_length_50)) {

                uint16_t ffe_idle_err_timeout = FFE_IDLE_ERR_COUNT_TIMEOUT_20;
                uint32_t idle_errs = 0;

                /* clear previous idle error counts */
                ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS,
                                             &phy_data);
                if (ret_val)
                    return ret_val;

                for (i = 0; i < ffe_idle_err_timeout; i++) {
                    usec_delay(1000);
                    ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS,
                                                 &phy_data);
                    if (ret_val)
                        return ret_val;

                    idle_errs += (phy_data & SR_1000T_IDLE_ERROR_CNT);
                    if (idle_errs > SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {
                        hw->ffe_config_state = em_ffe_config_active;

                        ret_val = em_write_phy_reg(hw,
                                    IGP01E1000_PHY_DSP_FFE,
                                    IGP01E1000_PHY_DSP_FFE_CM_CP);
                        if (ret_val)
                            return ret_val;
                        break;
                    }

                    if (idle_errs)
                        ffe_idle_err_timeout = FFE_IDLE_ERR_COUNT_TIMEOUT_100;
                }
            }
        }
    } else {
        if (hw->dsp_config_state == em_dsp_config_activated) {
            /* Save off the current value of register 0x2F5B to be restored at
             * the end of the routines. */
            ret_val = em_read_phy_reg(hw, 0x2F5B, &phy_saved_data);

            if (ret_val)
                return ret_val;

            /* Disable the PHY transmitter */
            ret_val = em_write_phy_reg(hw, 0x2F5B, 0x0003);

            if (ret_val)
                return ret_val;

            msec_delay_irq(20);

            ret_val = em_write_phy_reg(hw, 0x0000,
                                          IGP01E1000_IEEE_FORCE_GIGA);
            if (ret_val)
                return ret_val;
            for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
                ret_val = em_read_phy_reg(hw, dsp_reg_array[i], &phy_data);
                if (ret_val)
                    return ret_val;

                phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
                phy_data |=  IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS;

                ret_val = em_write_phy_reg(hw,dsp_reg_array[i], phy_data);
                if (ret_val)
                    return ret_val;
            }

            ret_val = em_write_phy_reg(hw, 0x0000,
                                          IGP01E1000_IEEE_RESTART_AUTONEG);
            if (ret_val)
                return ret_val;

            msec_delay_irq(20);

            /* Now enable the transmitter */
            ret_val = em_write_phy_reg(hw, 0x2F5B, phy_saved_data);

            if (ret_val)
                return ret_val;

            hw->dsp_config_state = em_dsp_config_enabled;
        }

        if (hw->ffe_config_state == em_ffe_config_active) {
            /* Save off the current value of register 0x2F5B to be restored at
             * the end of the routines. */
            ret_val = em_read_phy_reg(hw, 0x2F5B, &phy_saved_data);

            if (ret_val)
                return ret_val;

            /* Disable the PHY transmitter */
            ret_val = em_write_phy_reg(hw, 0x2F5B, 0x0003);

            if (ret_val)
                return ret_val;

            msec_delay_irq(20);

            ret_val = em_write_phy_reg(hw, 0x0000,
                                          IGP01E1000_IEEE_FORCE_GIGA);
            if (ret_val)
                return ret_val;
            ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_DSP_FFE,
                                          IGP01E1000_PHY_DSP_FFE_DEFAULT);
            if (ret_val)
                return ret_val;

            ret_val = em_write_phy_reg(hw, 0x0000,
                                          IGP01E1000_IEEE_RESTART_AUTONEG);
            if (ret_val)
                return ret_val;

            msec_delay_irq(20);

            /* Now enable the transmitter */
            ret_val = em_write_phy_reg(hw, 0x2F5B, phy_saved_data);

            if (ret_val)
                return ret_val;

            hw->ffe_config_state = em_ffe_config_enabled;
        }
    }
    return E1000_SUCCESS;
d7076 26
a7101 26
    int32_t ret_val;
    uint16_t eeprom_data;

    DEBUGFUNC("em_set_phy_mode");

    if ((hw->mac_type == em_82545_rev_3) &&
        (hw->media_type == em_media_type_copper)) {
        ret_val = em_read_eeprom(hw, EEPROM_PHY_CLASS_WORD, 1, &eeprom_data);
        if (ret_val) {
            return ret_val;
        }

        if ((eeprom_data != EEPROM_RESERVED_WORD) &&
            (eeprom_data & EEPROM_PHY_CLASS_A)) {
            ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x000B);
            if (ret_val)
                return ret_val;
            ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0x8104);
            if (ret_val)
                return ret_val;

            hw->phy_reset_disable = FALSE;
        }
    }

    return E1000_SUCCESS;
a7116 1

d7118 1
a7118 2
em_set_d3_lplu_state(struct em_hw *hw,
                        boolean_t active)
d7120 121
a7240 113
    uint32_t phy_ctrl = 0;
    int32_t ret_val;
    uint16_t phy_data;
    DEBUGFUNC("em_set_d3_lplu_state");

    if (hw->phy_type != em_phy_igp && hw->phy_type != em_phy_igp_2
        && hw->phy_type != em_phy_igp_3)
        return E1000_SUCCESS;

    /* During driver activity LPLU should not be used or it will attain link
     * from the lowest speeds starting from 10Mbps. The capability is used for
     * Dx transitions and states */
    if (hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2) {
        ret_val = em_read_phy_reg(hw, IGP01E1000_GMII_FIFO, &phy_data);
        if (ret_val)
            return ret_val;
    } else if (hw->mac_type == em_ich8lan ||
               hw->mac_type == em_ich9lan ||
               hw->mac_type == em_ich10lan) {
        /* MAC writes into PHY register based on the state transition
         * and start auto-negotiation. SW driver can overwrite the settings
         * in CSR PHY power control E1000_PHY_CTRL register. */
        phy_ctrl = E1000_READ_REG(hw, PHY_CTRL);
    } else {
        ret_val = em_read_phy_reg(hw, IGP02E1000_PHY_POWER_MGMT, &phy_data);
        if (ret_val)
            return ret_val;
    }

    if (!active) {
        if (hw->mac_type == em_82541_rev_2 ||
            hw->mac_type == em_82547_rev_2) {
            phy_data &= ~IGP01E1000_GMII_FLEX_SPD;
            ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data);
            if (ret_val)
                return ret_val;
        } else {
            if (hw->mac_type == em_ich8lan ||
                hw->mac_type == em_ich9lan ||
                hw->mac_type == em_ich10lan) {
                phy_ctrl &= ~E1000_PHY_CTRL_NOND0A_LPLU;
                E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
            } else {
                phy_data &= ~IGP02E1000_PM_D3_LPLU;
                ret_val = em_write_phy_reg(hw, IGP02E1000_PHY_POWER_MGMT,
                                              phy_data);
                if (ret_val)
                    return ret_val;
            }
        }

        /* LPLU and SmartSpeed are mutually exclusive.  LPLU is used during
         * Dx states where the power conservation is most important.  During
         * driver activity we should enable SmartSpeed, so performance is
         * maintained. */
        if (hw->smart_speed == em_smart_speed_on) {
            ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                         &phy_data);
            if (ret_val)
                return ret_val;

            phy_data |= IGP01E1000_PSCFR_SMART_SPEED;
            ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                          phy_data);
            if (ret_val)
                return ret_val;
        } else if (hw->smart_speed == em_smart_speed_off) {
            ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                         &phy_data);
            if (ret_val)
                return ret_val;

            phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
            ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                          phy_data);
            if (ret_val)
                return ret_val;
        }

    } else if ((hw->autoneg_advertised == AUTONEG_ADVERTISE_SPEED_DEFAULT) ||
               (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_ALL ) ||
               (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_100_ALL)) {

        if (hw->mac_type == em_82541_rev_2 ||
            hw->mac_type == em_82547_rev_2) {
            phy_data |= IGP01E1000_GMII_FLEX_SPD;
            ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data);
            if (ret_val)
                return ret_val;
        } else {
            if (hw->mac_type == em_ich8lan ||
                hw->mac_type == em_ich9lan ||
                hw->mac_type == em_ich10lan) {
                phy_ctrl |= E1000_PHY_CTRL_NOND0A_LPLU;
                E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
            } else {
                phy_data |= IGP02E1000_PM_D3_LPLU;
                ret_val = em_write_phy_reg(hw, IGP02E1000_PHY_POWER_MGMT,
                                              phy_data);
                if (ret_val)
                    return ret_val;
            }
        }

        /* When LPLU is enabled we should disable SmartSpeed */
        ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
        ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, phy_data);
        if (ret_val)
            return ret_val;
d7242 2
a7243 2
    }
    return E1000_SUCCESS;
a7258 1

d7260 1
a7260 2
em_set_d0_lplu_state(struct em_hw *hw,
                        boolean_t active)
d7262 86
a7347 83
    uint32_t phy_ctrl = 0;
    int32_t ret_val;
    uint16_t phy_data;
    DEBUGFUNC("em_set_d0_lplu_state");

    if (hw->mac_type <= em_82547_rev_2)
        return E1000_SUCCESS;

    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
        phy_ctrl = E1000_READ_REG(hw, PHY_CTRL);
    } else {
        ret_val = em_read_phy_reg(hw, IGP02E1000_PHY_POWER_MGMT, &phy_data);
        if (ret_val)
            return ret_val;
    }

    if (!active) {
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
            phy_ctrl &= ~E1000_PHY_CTRL_D0A_LPLU;
            E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
        } else {
            phy_data &= ~IGP02E1000_PM_D0_LPLU;
            ret_val = em_write_phy_reg(hw, IGP02E1000_PHY_POWER_MGMT, phy_data);
            if (ret_val)
                return ret_val;
        }

        /* LPLU and SmartSpeed are mutually exclusive.  LPLU is used during
         * Dx states where the power conservation is most important.  During
         * driver activity we should enable SmartSpeed, so performance is
         * maintained. */
        if (hw->smart_speed == em_smart_speed_on) {
            ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                         &phy_data);
            if (ret_val)
                return ret_val;

            phy_data |= IGP01E1000_PSCFR_SMART_SPEED;
            ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                          phy_data);
            if (ret_val)
                return ret_val;
        } else if (hw->smart_speed == em_smart_speed_off) {
            ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                         &phy_data);
            if (ret_val)
                return ret_val;

            phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
            ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                          phy_data);
            if (ret_val)
                return ret_val;
        }


    } else {

        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
            phy_ctrl |= E1000_PHY_CTRL_D0A_LPLU;
            E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
        } else {
            phy_data |= IGP02E1000_PM_D0_LPLU;
            ret_val = em_write_phy_reg(hw, IGP02E1000_PHY_POWER_MGMT, phy_data);
            if (ret_val)
                return ret_val;
        }

        /* When LPLU is enabled we should disable SmartSpeed */
        ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
        ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, phy_data);
        if (ret_val)
            return ret_val;
d7349 2
a7350 2
    }
    return E1000_SUCCESS;
d7361 50
a7410 51
    int32_t  ret_val;
    uint16_t default_page = 0;
    uint16_t phy_data;

    DEBUGFUNC("em_set_vco_speed");

    switch (hw->mac_type) {
    case em_82545_rev_3:
    case em_82546_rev_3:
       break;
    default:
        return E1000_SUCCESS;
    }

    /* Set PHY register 30, page 5, bit 8 to 0 */

    ret_val = em_read_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, &default_page);
    if (ret_val)
        return ret_val;

    ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0005);
    if (ret_val)
        return ret_val;

    ret_val = em_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
    if (ret_val)
        return ret_val;

    phy_data &= ~M88E1000_PHY_VCO_REG_BIT8;
    ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
    if (ret_val)
        return ret_val;

    /* Set PHY register 30, page 4, bit 11 to 1 */

    ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0004);
    if (ret_val)
        return ret_val;

    ret_val = em_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
    if (ret_val)
        return ret_val;

    phy_data |= M88E1000_PHY_VCO_REG_BIT11;
    ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
    if (ret_val)
        return ret_val;

    ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, default_page);
    if (ret_val)
        return ret_val;
d7412 1
a7412 1
    return E1000_SUCCESS;
a7414 1

d7421 1
a7421 1
em_host_if_read_cookie(struct em_hw * hw, uint8_t *buffer)
d7423 11
a7433 12
    uint8_t i;
    uint32_t offset = E1000_MNG_DHCP_COOKIE_OFFSET;
    uint8_t length = E1000_MNG_DHCP_COOKIE_LENGTH;

    length = (length >> 2);
    offset = (offset >> 2);

    for (i = 0; i < length; i++) {
        *((uint32_t *) buffer + i) =
            E1000_READ_REG_ARRAY_DWORD(hw, HOST_IF, offset + i);
    }
    return E1000_SUCCESS;
a7435 1

d7446 1
a7446 1
em_mng_enable_host_if(struct em_hw * hw)
d7448 21
a7468 22
    uint32_t hicr;
    uint8_t i;

    /* Check that the host interface is enabled. */
    hicr = E1000_READ_REG(hw, HICR);
    if ((hicr & E1000_HICR_EN) == 0) {
        DEBUGOUT("E1000_HOST_EN bit disabled.\n");
        return -E1000_ERR_HOST_INTERFACE_COMMAND;
    }
    /* check the previous command is completed */
    for (i = 0; i < E1000_MNG_DHCP_COMMAND_TIMEOUT; i++) {
        hicr = E1000_READ_REG(hw, HICR);
        if (!(hicr & E1000_HICR_C))
            break;
        msec_delay_irq(1);
    }

    if (i == E1000_MNG_DHCP_COMMAND_TIMEOUT) {
        DEBUGOUT("Previous command timeout failed .\n");
        return -E1000_ERR_HOST_INTERFACE_COMMAND;
    }
    return E1000_SUCCESS;
d7479 2
a7480 1
    uint32_t fwsm;
d7482 9
a7490 1
    fwsm = E1000_READ_REG(hw, FWSM);
d7492 1
a7492 11
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
        if ((fwsm & E1000_FWSM_MODE_MASK) ==
            (E1000_MNG_ICH_IAMT_MODE << E1000_FWSM_MODE_SHIFT))
            return TRUE;
    } else if ((fwsm & E1000_FWSM_MODE_MASK) ==
               (E1000_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT))
        return TRUE;

    return FALSE;
d7503 4
a7506 5
    uint8_t sum = 0;
    uint32_t i;

    if (!buffer)
        return 0;
d7508 2
a7509 2
    for (i=0; i < length; i++)
        sum += buffer[i];
d7511 1
a7511 1
    return (uint8_t) (0 - sum);
d7522 27
a7548 29
    /* called in init as well as watchdog timer functions */

    int32_t ret_val, checksum;
    boolean_t tx_filter = FALSE;
    struct em_host_mng_dhcp_cookie *hdr = &(hw->mng_cookie);
    uint8_t *buffer = (uint8_t *) &(hw->mng_cookie);

    if (em_check_mng_mode(hw)) {
        ret_val = em_mng_enable_host_if(hw);
        if (ret_val == E1000_SUCCESS) {
            ret_val = em_host_if_read_cookie(hw, buffer);
            if (ret_val == E1000_SUCCESS) {
                checksum = hdr->checksum;
                hdr->checksum = 0;
                if ((hdr->signature == E1000_IAMT_SIGNATURE) &&
                    checksum == em_calculate_mng_checksum((char *)buffer,
                                               E1000_MNG_DHCP_COOKIE_LENGTH)) {
                    if (hdr->status &
                        E1000_MNG_DHCP_COOKIE_STATUS_PARSING_SUPPORT)
                        tx_filter = TRUE;
                } else
                    tx_filter = TRUE;
            } else
                tx_filter = TRUE;
        }
    }

    hw->tx_pkt_filtering = tx_filter;
    return tx_filter;
a7550 1

d7554 82
a7635 80
    int32_t ret_val;
    uint16_t mii_status_reg;
    uint16_t i;

    /* Polarity reversal workaround for forced 10F/10H links. */

    /* Disable the transmitter on the PHY */

    ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);
    if (ret_val)
        return ret_val;
    ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFFF);
    if (ret_val)
        return ret_val;

    ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);
    if (ret_val)
        return ret_val;

    /* This loop will early-out if the NO link condition has been met. */
    for (i = PHY_FORCE_TIME; i > 0; i--) {
        /* Read the MII Status Register and wait for Link Status bit
         * to be clear.
         */

        ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
        if (ret_val)
            return ret_val;

        ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
        if (ret_val)
            return ret_val;

        if ((mii_status_reg & ~MII_SR_LINK_STATUS) == 0) break;
        msec_delay_irq(100);
    }

    /* Recommended delay time after link has been lost */
    msec_delay_irq(1000);

    /* Now we will re-enable the transmitter on the PHY */

    ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);
    if (ret_val)
        return ret_val;
    msec_delay_irq(50);
    ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFF0);
    if (ret_val)
        return ret_val;
    msec_delay_irq(50);
    ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFF00);
    if (ret_val)
        return ret_val;
    msec_delay_irq(50);
    ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0x0000);
    if (ret_val)
        return ret_val;

    ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);
    if (ret_val)
        return ret_val;

    /* This loop will early-out if the link condition has been met. */
    for (i = PHY_FORCE_TIME; i > 0; i--) {
        /* Read the MII Status Register and wait for Link Status bit
         * to be set.
         */

        ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
        if (ret_val)
            return ret_val;

        ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
        if (ret_val)
            return ret_val;

        if (mii_status_reg & MII_SR_LINK_STATUS) break;
        msec_delay_irq(100);
    }
    return E1000_SUCCESS;
d7638 1
a7638 1
/***************************************************************************
d7646 1
a7646 1
 ***************************************************************************/
d7650 2
a7651 1
    uint32_t ctrl;
d7653 2
a7654 1
    DEBUGFUNC("em_set_pci_express_master_disable");
d7656 3
a7658 6
    if (hw->bus_type != em_bus_type_pci_express)
        return;

    ctrl = E1000_READ_REG(hw, CTRL);
    ctrl |= E1000_CTRL_GIO_MASTER_DISABLE;
    E1000_WRITE_REG(hw, CTRL, ctrl);
d7661 1
a7661 1
/*******************************************************************************
d7663 2
a7664 1
 * Disables PCI-Express master access and verifies there are no pending requests
d7676 2
a7677 1
    int32_t timeout = MASTER_DISABLE_TIMEOUT;   /* 80ms */
d7679 2
a7680 1
    DEBUGFUNC("em_disable_pciex_master");
d7682 1
a7682 2
    if (hw->bus_type != em_bus_type_pci_express)
        return E1000_SUCCESS;
d7684 14
a7697 16
    em_set_pci_express_master_disable(hw);

    while (timeout) {
        if (!(E1000_READ_REG(hw, STATUS) & E1000_STATUS_GIO_MASTER_ENABLE))
            break;
        else
            usec_delay(100);
        timeout--;
    }

    if (!timeout) {
        DEBUGOUT("Master requests are pending.\n");
        return -E1000_ERR_MASTER_REQUESTS_PENDING;
    }

    return E1000_SUCCESS;
d7700 1
a7700 1
/*******************************************************************************
d7713 2
a7714 1
    int32_t timeout = AUTO_READ_DONE_TIMEOUT;
d7716 35
a7750 34
    DEBUGFUNC("em_get_auto_rd_done");

    switch (hw->mac_type) {
    default:
        msec_delay(5);
        break;
    case em_82571:
    case em_82572:
    case em_82573:
    case em_82574:
    case em_82575:
    case em_80003es2lan:
    case em_ich8lan:
    case em_ich9lan:
    case em_ich10lan:
        while (timeout) {
            if (E1000_READ_REG(hw, EECD) & E1000_EECD_AUTO_RD)
                break;
            else msec_delay(1);
            timeout--;
        }

        if (!timeout) {
            DEBUGOUT("Auto read by HW from EEPROM has not completed.\n");
            return -E1000_ERR_RESET;
        }
        break;
    }

    /* PHY configuration from NVM just starts after EECD_AUTO_RD sets to high.
     * Need to wait for PHY configuration completion before accessing NVM
     * and PHY. */
    if ((hw->mac_type == em_82573) || (hw->mac_type == em_82574)) 
        msec_delay(25);
d7752 1
a7752 1
    return E1000_SUCCESS;
d7767 30
a7796 30
    int32_t timeout = PHY_CFG_TIMEOUT;
    uint32_t cfg_mask = E1000_EEPROM_CFG_DONE;

    DEBUGFUNC("em_get_phy_cfg_done");

    switch (hw->mac_type) {
    default:
        msec_delay_irq(10);
        break;
    case em_80003es2lan:
        /* Separate *_CFG_DONE_* bit for each port */
        if (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)
            cfg_mask = E1000_EEPROM_CFG_DONE_PORT_1;
        /* FALLTHROUGH */
    case em_82571:
    case em_82572:
    case em_82575:
        while (timeout) {
            if (E1000_READ_REG(hw, EEMNGCTL) & cfg_mask)
                break;
            else
                msec_delay(1);
            timeout--;
        }
        if (!timeout) {
            DEBUGOUT("MNG configuration cycle has not completed.\n");
            return -E1000_ERR_RESET;
        }
        break;
    }
d7798 1
a7798 1
    return E1000_SUCCESS;
d7815 35
a7849 37
    int32_t timeout;
    uint32_t swsm;

    DEBUGFUNC("em_get_hw_eeprom_semaphore");

    if (!hw->eeprom_semaphore_present)
        return E1000_SUCCESS;

    if (hw->mac_type == em_80003es2lan) {
        /* Get the SW semaphore. */
        if (em_get_software_semaphore(hw) != E1000_SUCCESS)
            return -E1000_ERR_EEPROM;
    }

    /* Get the FW semaphore. */
    timeout = hw->eeprom.word_size + 1;
    while (timeout) {
        swsm = E1000_READ_REG(hw, SWSM);
        swsm |= E1000_SWSM_SWESMBI;
        E1000_WRITE_REG(hw, SWSM, swsm);
        /* if we managed to set the bit we got the semaphore. */
        swsm = E1000_READ_REG(hw, SWSM);
        if (swsm & E1000_SWSM_SWESMBI)
            break;

        usec_delay(50);
        timeout--;
    }

    if (!timeout) {
        /* Release semaphores */
        em_put_hw_eeprom_semaphore(hw);
        DEBUGOUT("Driver can't access the Eeprom - SWESMBI bit is set.\n");
        return -E1000_ERR_EEPROM;
    }

    return E1000_SUCCESS;
d7863 2
a7864 1
    uint32_t swsm;
d7866 2
a7867 1
    DEBUGFUNC("em_put_hw_eeprom_semaphore");
d7869 7
a7875 10
    if (!hw->eeprom_semaphore_present)
        return;

    swsm = E1000_READ_REG(hw, SWSM);
    if (hw->mac_type == em_80003es2lan) {
        /* Release both semaphores. */
        swsm &= ~(E1000_SWSM_SMBI | E1000_SWSM_SWESMBI);
    } else
        swsm &= ~(E1000_SWSM_SWESMBI);
    E1000_WRITE_REG(hw, SWSM, swsm);
d7891 24
a7914 23
    int32_t timeout = hw->eeprom.word_size + 1;
    uint32_t swsm;

    DEBUGFUNC("em_get_software_semaphore");

    if (hw->mac_type != em_80003es2lan)
        return E1000_SUCCESS;

    while (timeout) {
        swsm = E1000_READ_REG(hw, SWSM);
        /* If SMBI bit cleared, it is now set and we hold the semaphore */
        if (!(swsm & E1000_SWSM_SMBI))
            break;
        msec_delay_irq(1);
        timeout--;
    }

    if (!timeout) {
        DEBUGOUT("Driver can't access device - SMBI bit is set.\n");
        return -E1000_ERR_RESET;
    }

    return E1000_SUCCESS;
d7927 2
a7928 3
    uint32_t swsm;

    DEBUGFUNC("em_release_software_semaphore");
d7930 2
a7931 2
    if (hw->mac_type != em_80003es2lan)
        return;
d7933 4
a7936 4
    swsm = E1000_READ_REG(hw, SWSM);
    /* Release the SW semaphores.*/
    swsm &= ~E1000_SWSM_SMBI;
    E1000_WRITE_REG(hw, SWSM, swsm);
d7953 13
a7965 15
    uint32_t manc = 0;
    uint32_t fwsm = 0;

    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
        fwsm = E1000_READ_REG(hw, FWSM);
        return (fwsm & E1000_FWSM_RSPCIPHY) ? E1000_SUCCESS
                                            : E1000_BLK_PHY_RESET;
    }

    if (hw->mac_type > em_82547_rev_2)
        manc = E1000_READ_REG(hw, MANC);
    return (manc & E1000_MANC_BLK_PHY_RST_ON_IDE) ?
        E1000_BLK_PHY_RESET : E1000_SUCCESS;
d7980 2
a7981 1
    uint32_t gcr_reg = 0;
d7983 2
a7984 1
    DEBUGFUNC("em_set_pci_ex_no_snoop");
d7986 2
a7987 2
    if (hw->bus_type == em_bus_type_unknown)
        em_get_bus_info(hw);
d7989 15
a8003 21
    if (hw->bus_type != em_bus_type_pci_express)
        return E1000_SUCCESS;

    if (no_snoop) {
        gcr_reg = E1000_READ_REG(hw, GCR);
        gcr_reg &= ~(PCI_EX_NO_SNOOP_ALL);
        gcr_reg |= no_snoop;
        E1000_WRITE_REG(hw, GCR, gcr_reg);
    }

    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
        uint32_t ctrl_ext;

        ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
        ctrl_ext |= E1000_CTRL_EXT_RO_DIS;
        E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
    }

    return E1000_SUCCESS;
d8018 25
a8042 27
    int32_t timeout = PHY_CFG_TIMEOUT;
    uint32_t extcnf_ctrl;

    DEBUGFUNC("em_get_software_flag");

    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
        while (timeout) {
            extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);
            extcnf_ctrl |= E1000_EXTCNF_CTRL_SWFLAG;
            E1000_WRITE_REG(hw, EXTCNF_CTRL, extcnf_ctrl);

            extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);
            if (extcnf_ctrl & E1000_EXTCNF_CTRL_SWFLAG)
                break;
            msec_delay_irq(1);
            timeout--;
        }

        if (!timeout) {
            DEBUGOUT("FW or HW locks the resource too long.\n");
            return -E1000_ERR_CONFIG;
        }
    }

    return E1000_SUCCESS;
d8057 2
a8058 1
    uint32_t extcnf_ctrl;
d8060 8
a8067 11
    DEBUGFUNC("em_release_software_flag");

    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
        extcnf_ctrl= E1000_READ_REG(hw, EXTCNF_CTRL);
        extcnf_ctrl &= ~E1000_EXTCNF_CTRL_SWFLAG;
        E1000_WRITE_REG(hw, EXTCNF_CTRL, extcnf_ctrl);
    }

    return;
a8069 1

d8081 1
a8081 1
                       uint16_t *data)
d8083 38
a8120 35
    int32_t  error = E1000_SUCCESS;
    uint32_t flash_bank = 0;
    uint32_t act_offset = 0;
    uint32_t bank_offset = 0;
    uint16_t word = 0;
    uint16_t i = 0;

    /* We need to know which is the valid flash bank.  In the event
     * that we didn't allocate eeprom_shadow_ram, we may not be
     * managing flash_bank.  So it cannot be trusted and needs
     * to be updated with each read.
     */
    /* Value of bit 22 corresponds to the flash bank we're on. */
    flash_bank = (E1000_READ_REG(hw, EECD) & E1000_EECD_SEC1VAL) ? 1 : 0;

    /* Adjust offset appropriately if we're on bank 1 - adjust for word size */
    bank_offset = flash_bank * (hw->flash_bank_size * 2);

    error = em_get_software_flag(hw);
    if (error != E1000_SUCCESS)
        return error;

    for (i = 0; i < words; i++) {
        if (hw->eeprom_shadow_ram != NULL &&
            hw->eeprom_shadow_ram[offset+i].modified == TRUE) {
            data[i] = hw->eeprom_shadow_ram[offset+i].eeprom_word;
        } else {
            /* The NVM part needs a byte offset, hence * 2 */
            act_offset = bank_offset + ((offset + i) * 2);
            error = em_read_ich8_word(hw, act_offset, &word);
            if (error != E1000_SUCCESS)
                break;
            data[i] = word;
        }
    }
d8122 1
a8122 1
    em_release_software_flag(hw);
d8124 1
a8124 1
    return error;
d8140 1
a8140 1
                        uint16_t *data)
d8142 33
a8174 31
    uint32_t i = 0;
    int32_t error = E1000_SUCCESS;

    error = em_get_software_flag(hw);
    if (error != E1000_SUCCESS)
        return error;

    /* A driver can write to the NVM only if it has eeprom_shadow_ram
     * allocated.  Subsequent reads to the modified words are read from
     * this cached structure as well.  Writes will only go into this
     * cached structure unless it's followed by a call to
     * em_update_eeprom_checksum() where it will commit the changes
     * and clear the "modified" field.
     */
    if (hw->eeprom_shadow_ram != NULL) {
        for (i = 0; i < words; i++) {
            if ((offset + i) < E1000_SHADOW_RAM_WORDS) {
                hw->eeprom_shadow_ram[offset+i].modified = TRUE;
                hw->eeprom_shadow_ram[offset+i].eeprom_word = data[i];
            } else {
                error = -E1000_ERR_EEPROM;
                break;
            }
        }
    } else {
        /* Drivers have the option to not allocate eeprom_shadow_ram as long
         * as they don't perform any NVM writes.  An attempt in doing so
         * will result in this error.
         */
        error = -E1000_ERR_EEPROM;
    }
d8176 1
a8176 1
    em_release_software_flag(hw);
d8178 1
a8178 1
    return error;
d8190 68
a8257 57
    union ich8_hws_flash_status hsfsts;
    int32_t error = E1000_ERR_EEPROM;
    int32_t i     = 0;

    DEBUGFUNC("em_ich8_cycle_init");

    hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS);

    /* May be check the Flash Des Valid bit in Hw status */
    if (hsfsts.hsf_status.fldesvalid == 0) {
        DEBUGOUT("Flash descriptor invalid.  SW Sequencing must be used.");
        return error;
    }

    /* Clear FCERR in Hw status by writing 1 */
    /* Clear DAEL in Hw status by writing a 1 */
    hsfsts.hsf_status.flcerr = 1;
    hsfsts.hsf_status.dael = 1;

    E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS, hsfsts.regval);

    /* Either we should have a hardware SPI cycle in progress bit to check
     * against, in order to start a new cycle or FDONE bit should be changed
     * in the hardware so that it is 1 after harware reset, which can then be
     * used as an indication whether a cycle is in progress or has been
     * completed .. we should also have some software semaphore mechanism to
     * guard FDONE or the cycle in progress bit so that two threads access to
     * those bits can be sequentiallized or a way so that 2 threads dont
     * start the cycle at the same time */

    if (hsfsts.hsf_status.flcinprog == 0) {
        /* There is no cycle running at present, so we can start a cycle */
        /* Begin by setting Flash Cycle Done. */
        hsfsts.hsf_status.flcdone = 1;
        E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS, hsfsts.regval);
        error = E1000_SUCCESS;
    } else {
        /* otherwise poll for sometime so the current cycle has a chance
         * to end before giving up. */
        for (i = 0; i < ICH_FLASH_COMMAND_TIMEOUT; i++) {
            hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS);
            if (hsfsts.hsf_status.flcinprog == 0) {
                error = E1000_SUCCESS;
                break;
            }
            usec_delay(1);
        }
        if (error == E1000_SUCCESS) {
            /* Successful in waiting for previous cycle to timeout,
             * now set the Flash Cycle Done. */
            hsfsts.hsf_status.flcdone = 1;
            E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS, hsfsts.regval);
        } else {
            DEBUGOUT("Flash controller busy, cannot get access");
        }
    }
    return error;
d8264 1
a8264 1
 ****************************************************************************/
d8268 22
a8289 22
    union ich8_hws_flash_ctrl hsflctl;
    union ich8_hws_flash_status hsfsts;
    int32_t error = E1000_ERR_EEPROM;
    uint32_t i = 0;

    /* Start a cycle by writing 1 in Flash Cycle Go in Hw Flash Control */
    hsflctl.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL);
    hsflctl.hsf_ctrl.flcgo = 1;
    E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL, hsflctl.regval);

    /* wait till FDONE bit is set to 1 */
    do {
        hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS);
        if (hsfsts.hsf_status.flcdone == 1)
            break;
        usec_delay(1);
        i++;
    } while (i < timeout);
    if (hsfsts.hsf_status.flcdone == 1 && hsfsts.hsf_status.flcerr == 0) {
        error = E1000_SUCCESS;
    }
    return error;
d8301 2
a8302 2
em_read_ich8_data(struct em_hw *hw, uint32_t index,
                     uint32_t size, uint16_t* data)
d8304 73
a8376 63
    union ich8_hws_flash_status hsfsts;
    union ich8_hws_flash_ctrl hsflctl;
    uint32_t flash_linear_address;
    uint32_t flash_data = 0;
    int32_t error = -E1000_ERR_EEPROM;
    int32_t count = 0;

    DEBUGFUNC("em_read_ich8_data");

    if (size < 1  || size > 2 || data == 0x0 ||
        index > ICH_FLASH_LINEAR_ADDR_MASK)
        return error;

    flash_linear_address = (ICH_FLASH_LINEAR_ADDR_MASK & index) +
                           hw->flash_base_addr;

    do {
        usec_delay(1);
        /* Steps */
        error = em_ich8_cycle_init(hw);
        if (error != E1000_SUCCESS)
            break;

        hsflctl.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL);
        /* 0b/1b corresponds to 1 or 2 byte size, respectively. */
        hsflctl.hsf_ctrl.fldbcount = size - 1;
        hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_READ;
        E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL, hsflctl.regval);

        /* Write the last 24 bits of index into Flash Linear address field in
         * Flash Address */
        /* TODO: TBD maybe check the index against the size of flash */

        E1000_WRITE_ICH_FLASH_REG(hw, ICH_FLASH_FADDR, flash_linear_address);

        error = em_ich8_flash_cycle(hw, ICH_FLASH_COMMAND_TIMEOUT);

        /* Check if FCERR is set to 1, if set to 1, clear it and try the whole
         * sequence a few more times, else read in (shift in) the Flash Data0,
         * the order is least significant byte first msb to lsb */
        if (error == E1000_SUCCESS) {
            flash_data = E1000_READ_ICH_FLASH_REG(hw, ICH_FLASH_FDATA0);
            if (size == 1) {
                *data = (uint8_t)(flash_data & 0x000000FF);
            } else if (size == 2) {
                *data = (uint16_t)(flash_data & 0x0000FFFF);
            }
            break;
        } else {
            /* If we've gotten here, then things are probably completely hosed,
             * but if the error condition is detected, it won't hurt to give
             * it another try...ICH_FLASH_CYCLE_REPEAT_COUNT times.
             */
            hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS);
            if (hsfsts.hsf_status.flcerr == 1) {
                /* Repeat for some time before giving up. */
                continue;
            } else if (hsfsts.hsf_status.flcdone == 0) {
                DEBUGOUT("Timeout error - flash cycle did not complete.");
                break;
            }
        }
    } while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);
d8378 1
a8378 1
    return error;
d8391 1
a8391 1
                      uint16_t data)
d8393 68
a8460 60
    union ich8_hws_flash_status hsfsts;
    union ich8_hws_flash_ctrl hsflctl;
    uint32_t flash_linear_address;
    uint32_t flash_data = 0;
    int32_t error = -E1000_ERR_EEPROM;
    int32_t count = 0;

    DEBUGFUNC("em_write_ich8_data");

    if (size < 1  || size > 2 || data > size * 0xff ||
        index > ICH_FLASH_LINEAR_ADDR_MASK)
        return error;

    flash_linear_address = (ICH_FLASH_LINEAR_ADDR_MASK & index) +
                           hw->flash_base_addr;

    do {
        usec_delay(1);
        /* Steps */
        error = em_ich8_cycle_init(hw);
        if (error != E1000_SUCCESS)
            break;

        hsflctl.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL);
        /* 0b/1b corresponds to 1 or 2 byte size, respectively. */
        hsflctl.hsf_ctrl.fldbcount = size -1;
        hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_WRITE;
        E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL, hsflctl.regval);

        /* Write the last 24 bits of index into Flash Linear address field in
         * Flash Address */
        E1000_WRITE_ICH_FLASH_REG(hw, ICH_FLASH_FADDR, flash_linear_address);

        if (size == 1)
            flash_data = (uint32_t)data & 0x00FF;
        else
            flash_data = (uint32_t)data;

        E1000_WRITE_ICH_FLASH_REG(hw, ICH_FLASH_FDATA0, flash_data);

        /* check if FCERR is set to 1 , if set to 1, clear it and try the whole
         * sequence a few more times else done */
        error = em_ich8_flash_cycle(hw, ICH_FLASH_COMMAND_TIMEOUT);
        if (error == E1000_SUCCESS) {
            break;
        } else {
            /* If we're here, then things are most likely completely hosed,
             * but if the error condition is detected, it won't hurt to give
             * it another try...ICH_FLASH_CYCLE_REPEAT_COUNT times.
             */
            hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS);
            if (hsfsts.hsf_status.flcerr == 1) {
                /* Repeat for some time before giving up. */
                continue;
            } else if (hsfsts.hsf_status.flcdone == 0) {
                DEBUGOUT("Timeout error - flash cycle did not complete.");
                break;
            }
        }
    } while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);
d8462 1
a8462 1
    return error;
d8473 1
a8473 1
em_read_ich8_byte(struct em_hw *hw, uint32_t index, uint8_t* data)
d8475 7
a8481 9
    int32_t status = E1000_SUCCESS;
    uint16_t word = 0;

    status = em_read_ich8_data(hw, index, 1, &word);
    if (status == E1000_SUCCESS) {
        *data = (uint8_t)word;
    }

    return status;
d8496 19
a8514 4
    int32_t error = E1000_SUCCESS;
    int32_t program_retries = 0;

    DEBUGOUT2("Byte := %2.2X Offset := %d\n", byte, index);
d8516 1
a8516 16
    error = em_write_ich8_byte(hw, index, byte);

    if (error != E1000_SUCCESS) {
        for (program_retries = 0; program_retries < 100; program_retries++) {
            DEBUGOUT2("Retrying \t Byte := %2.2X Offset := %d\n", byte, index);
            error = em_write_ich8_byte(hw, index, byte);
            usec_delay(100);
            if (error == E1000_SUCCESS)
                break;
        }
    }

    if (program_retries == 100)
        error = E1000_ERR_EEPROM;

    return error;
d8529 3
a8531 4
    int32_t status = E1000_SUCCESS;
    uint16_t word = (uint16_t)data;

    status = em_write_ich8_data(hw, index, 1, word);
d8533 1
a8533 1
    return status;
d8546 3
a8548 3
    int32_t status = E1000_SUCCESS;
    status = em_read_ich8_data(hw, index, 2, data);
    return status;
a8550 1

d8565 157
a8721 141
    union ich8_hws_flash_status hsfsts;
    union ich8_hws_flash_ctrl hsflctl;
    uint32_t flash_linear_address;
    int32_t  count = 0;
    int32_t  error = E1000_ERR_EEPROM;
    int32_t  iteration;
    int32_t  sub_sector_size = 0;
    int32_t  bank_size;
    int32_t  j = 0;
    int32_t  error_flag = 0;

    hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS);

    /* Determine HW Sector size: Read BERASE bits of Hw flash Status register */
    /* 00: The Hw sector is 256 bytes, hence we need to erase 16
     *     consecutive sectors.  The start index for the nth Hw sector can be
     *     calculated as bank * 4096 + n * 256
     * 01: The Hw sector is 4K bytes, hence we need to erase 1 sector.
     *     The start index for the nth Hw sector can be calculated
     *     as bank * 4096
     * 10: The HW sector is 8K bytes
     * 11: The Hw sector size is 64K bytes */
    if (hsfsts.hsf_status.berasesz == 0x0) {
        /* Hw sector size 256 */
        sub_sector_size = ICH_FLASH_SEG_SIZE_256;
        bank_size = ICH_FLASH_SECTOR_SIZE;
        iteration = ICH_FLASH_SECTOR_SIZE / ICH_FLASH_SEG_SIZE_256;
    } else if (hsfsts.hsf_status.berasesz == 0x1) {
        bank_size = ICH_FLASH_SEG_SIZE_4K;
        iteration = 1;
    } else if (hsfsts.hsf_status.berasesz == 0x2) {
        if (hw->mac_type == em_ich9lan) {
	    uint32_t gfpreg, sector_base_addr, sector_end_addr;

	    gfpreg = E1000_READ_ICH_FLASH_REG(hw, ICH_FLASH_GFPREG);

	    /*
	     * sector_X_addr is a "sector"-aligned address (4096 bytes)
	     * Add 1 to sector_end_addr since this sector is included in
	     * the overall size.
	     */
	    sector_base_addr = gfpreg & ICH_GFPREG_BASE_MASK;
	    sector_end_addr = ((gfpreg >> 16) & ICH_GFPREG_BASE_MASK) + 1;

	    /*
	     * find total size of the NVM, then cut in half since the total
	     * size represents two separate NVM banks.
	     */
	    bank_size = (sector_end_addr - sector_base_addr)
	    		<< ICH_FLASH_SECT_ADDR_SHIFT;
	    bank_size /= 2;
	    /* Word align */
	    bank_size = (bank_size / sizeof(uint16_t)) * sizeof(uint16_t);

            sub_sector_size = ICH_FLASH_SEG_SIZE_8K;
            iteration = bank_size / ICH_FLASH_SEG_SIZE_8K;
        } else {
            return error;
        }
    } else if (hsfsts.hsf_status.berasesz == 0x3) {
        bank_size = ICH_FLASH_SEG_SIZE_64K;
        iteration = 1;
    } else {
        return error;
    }

    for (j = 0; j < iteration ; j++) {
        do {
            count++;
            /* Steps */
            error = em_ich8_cycle_init(hw);
            if (error != E1000_SUCCESS) {
                error_flag = 1;
                break;
            }

            /* Write a value 11 (block Erase) in Flash Cycle field in Hw flash
             * Control */
            hsflctl.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL);
            hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_ERASE;
            E1000_WRITE_ICH_FLASH_REG16(hw, ICH_FLASH_HSFCTL, hsflctl.regval);

            /* Write the last 24 bits of an index within the block into Flash
             * Linear address field in Flash Address.  This probably needs to
             * be calculated here based off the on-chip erase sector size and
             * the software bank size (4, 8 or 64 KBytes) */
            flash_linear_address = bank * bank_size + j * sub_sector_size;
            flash_linear_address += hw->flash_base_addr;
            flash_linear_address &= ICH_FLASH_LINEAR_ADDR_MASK;

            E1000_WRITE_ICH_FLASH_REG(hw, ICH_FLASH_FADDR, flash_linear_address);

            error = em_ich8_flash_cycle(hw, ICH_FLASH_ERASE_TIMEOUT);
            /* Check if FCERR is set to 1.  If 1, clear it and try the whole
             * sequence a few more times else Done */
            if (error == E1000_SUCCESS) {
                break;
            } else {
                hsfsts.regval = E1000_READ_ICH_FLASH_REG16(hw, ICH_FLASH_HSFSTS);
                if (hsfsts.hsf_status.flcerr == 1) {
                    /* repeat for some time before giving up */
                    continue;
                } else if (hsfsts.hsf_status.flcdone == 0) {
                    error_flag = 1;
                    break;
                }
            }
        } while ((count < ICH_FLASH_CYCLE_REPEAT_COUNT) && !error_flag);
        if (error_flag == 1)
            break;
    }
    if (error_flag != 1)
        error = E1000_SUCCESS;
    return error;
}


STATIC int32_t
em_init_lcd_from_nvm_config_region(struct em_hw *hw,
                                      uint32_t cnf_base_addr, uint32_t cnf_size)
{
    uint32_t ret_val = E1000_SUCCESS;
    uint16_t word_addr, reg_data, reg_addr;
    uint16_t i;

    /* cnf_base_addr is in DWORD */
    word_addr = (uint16_t)(cnf_base_addr << 1);

    /* cnf_size is returned in size of dwords */
    for (i = 0; i < cnf_size; i++) {
        ret_val = em_read_eeprom(hw, (word_addr + i*2), 1, &reg_data);
        if (ret_val)
            return ret_val;

        ret_val = em_read_eeprom(hw, (word_addr + i*2 + 1), 1, &reg_addr);
        if (ret_val)
            return ret_val;

        ret_val = em_get_software_flag(hw);
        if (ret_val != E1000_SUCCESS)
            return ret_val;
d8723 2
a8724 1
        ret_val = em_write_phy_reg_ex(hw, (uint32_t)reg_addr, reg_data);
d8726 2
a8727 2
        em_release_software_flag(hw);
    }
d8729 1
a8729 1
    return ret_val;
d8743 51
a8793 51
    uint32_t reg_data, cnf_base_addr, cnf_size, ret_val, loop, sw_cfg_mask;

    if (hw->phy_type != em_phy_igp_3)
          return E1000_SUCCESS;

    /* Check if SW needs configure the PHY */
    if ((hw->device_id == E1000_DEV_ID_ICH8_IGP_M_AMT) ||
        (hw->device_id == E1000_DEV_ID_ICH8_IGP_M))
           sw_cfg_mask = FEXTNVM_SW_CONFIG_ICH8M;
    else
           sw_cfg_mask = FEXTNVM_SW_CONFIG;

    reg_data = E1000_READ_REG(hw, FEXTNVM);
    if (!(reg_data & sw_cfg_mask))
        return E1000_SUCCESS;

    /* Wait for basic configuration completes before proceeding*/
    loop = 0;
    do {
        reg_data = E1000_READ_REG(hw, STATUS) & E1000_STATUS_LAN_INIT_DONE;
        usec_delay(100);
        loop++;
    } while ((!reg_data) && (loop < 50));

    /* Clear the Init Done bit for the next init event */
    reg_data = E1000_READ_REG(hw, STATUS);
    reg_data &= ~E1000_STATUS_LAN_INIT_DONE;
    E1000_WRITE_REG(hw, STATUS, reg_data);

    /* Make sure HW does not configure LCD from PHY extended configuration
       before SW configuration */
    reg_data = E1000_READ_REG(hw, EXTCNF_CTRL);
    if ((reg_data & E1000_EXTCNF_CTRL_LCD_WRITE_ENABLE) == 0x0000) {
        reg_data = E1000_READ_REG(hw, EXTCNF_SIZE);
        cnf_size = reg_data & E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH;
        cnf_size >>= 16;
        if (cnf_size) {
            reg_data = E1000_READ_REG(hw, EXTCNF_CTRL);
            cnf_base_addr = reg_data & E1000_EXTCNF_CTRL_EXT_CNF_POINTER;
            /* cnf_base_addr is in DWORD */
            cnf_base_addr >>= 16;

            /* Configure LCD from extended configuration region. */
            ret_val = em_init_lcd_from_nvm_config_region(hw, cnf_base_addr,
                                                            cnf_size);
            if (ret_val)
                return ret_val;
        }
    }

    return E1000_SUCCESS;
@


1.43
log
@fix default phy_addr makes 82545 work again

ok claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.42 2009/11/25 13:28:13 dms Exp $ */
d4754 1
a4754 1
    if ((hw->mac_type != em_82573) &&(hw->mac_type != em_82574)) {
@


1.42
log
@Add support for em(4) interfaces found on intel EP80579 SoC. The MAC part is
basicly 82545, but the PHY's are separated form the chip and they are accessed
through a special PCI device called GCU which has the MDIO interface. Since
there is no direct relationship between MAC and PHY, so for the moment they
are assigned to each other the way its done on Axiomtek NA-200, that was
danted to us by them.

This also adds a device driver for the GCU.

tested by me on Axiomtek board
reviewed by claudio@@, kettenis@@, deraadt@@
'commit that as is' deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.41 2009/10/11 23:54:49 dms Exp $ */
d4323 4
a4326 1
    hw->phy_addr = 0;
@


1.41
log
@fix support for 82543GC. as per intel driver acrds <=82543 need to have their
phy reset before detection. problem spotted by merdely@@, fixed thanks to
deraadt@@ sending me his 82543GC :)

tested by merdely@@, claudio@@ and me
ok by claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.40 2009/10/11 00:18:37 dms Exp $ */
d73 1
d225 3
d501 12
d574 5
d780 1
a780 1
        default:
d786 4
d793 2
a794 1
    if (hw->mac_type >= em_82540 && hw->mac_type <= em_82547_rev_2) {
d1222 1
d1226 5
d1254 1
a1254 1
            ret_val = em_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,
d1308 4
a1311 1
        return ret_val;
d1316 9
a1324 3
    ret_val = (hw->media_type == em_media_type_copper) ?
              em_setup_copper_link(hw) :
              em_setup_fiber_serdes_link(hw);
d1893 13
d1907 1
a1907 1
    if (hw->phy_type != em_phy_bm)
d1909 1
a1909 1
                                
d1953 1
a1953 1
    if ((hw->phy_type == em_phy_m88) &&
d1955 3
a1957 1
        (hw->phy_id != BME1000_E_PHY_ID)) {
d1965 5
d2026 1
a2026 1
static int32_t
d2097 1
a2097 1
static int32_t
d2103 2
a2104 1
    if (hw->mac_type >= em_82544) {
d2194 2
a2195 1
               hw->phy_type == em_phy_bm) {
d2233 2
d2555 2
a2556 1
        (hw->phy_type == em_phy_bm)) {
d2573 3
d2577 1
a2577 1
    } else if (hw->phy_type == em_phy_ife) {
d2650 1
d2669 2
a2670 1
        hw->phy_type == em_phy_bm) {
d2691 5
a2695 1
        phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
d2781 2
a2782 1
    if (hw->mac_type >= em_82544)
d2916 3
a2918 1
        ((hw->media_type == em_media_type_copper) && (!hw->autoneg))) {
d2931 3
a2933 1
    if ((hw->media_type == em_media_type_copper) && hw->autoneg) {
d3144 3
a3146 1
    if ((hw->media_type == em_media_type_copper) && hw->get_link_status) {
d3159 2
d3208 1
a3208 1
        if (hw->mac_type >= em_82544)
d3759 6
d3909 5
d4044 1
a4044 1
    if (hw->mac_type > em_82543) {
d4076 1
d4290 3
d4323 1
a4323 1
    hw->phy_addr = 1;
d4434 1
d5189 1
d5193 4
d5232 1
a5232 1
    for (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
d5715 1
d5719 5
d5726 1
a5726 1
        if (em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
d6133 1
a6133 1
    if (hw->mac_type < em_82540) {
d6282 2
a6283 1
    if (hw->mac_type <= em_82544) return;
d6407 5
d6519 2
a6520 1
    if (hw->phy_type == em_phy_m88) {
d6713 2
a6714 1
               (hw->phy_type == em_phy_gg82563)) {
@


1.40
log
@add support for ICH9 M V chipset, from brad.

ok by claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.39 2009/10/06 02:01:04 dms Exp $ */
d4249 9
a4257 1
    
@


1.39
log
@Remove hack that helped us to work on Lenovo X200, as of last commit the phy
gets detected properly.

tested by ckuethe@@ and jdixon@@
ok by claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.38 2009/09/04 22:13:51 dms Exp $ */
d487 1
@


1.38
log
@Bring back support for iCH10 based chips. This time support for fiber cards
seems to be fixed, thanks to tests done by mpf at mailq dot de.
Also support for older fiber cards that have no PHY seems to be working,
thanks to claudio@@
The code includes all the changes that i backed out, plus two tweaks:
1. em_detect_gig_phy() gets called in em_setup_link() instead of
em_copper_link_preconfig(), this enables phy detection on fiber cards.
2. em_detect_gig_phy() gets a condition to look for old fiber cards, that
have no PHY.

ok by claudio@@, prodded by deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.37 2009/08/21 22:54:10 dms Exp $ */
a4245 9
        return E1000_SUCCESS;
    }
    
    /* until something better comes along... makes the Lenovo X200 work */
    if (hw->mac_type == em_ich9lan &&
        (hw->device_id == E1000_DEV_ID_ICH9_IGP_M ||
         hw->device_id == E1000_DEV_ID_ICH9_IGP_M_AMT)) {
        hw->phy_id = IGP03E1000_E_PHY_ID;
        hw->phy_type = em_phy_igp_3;
@


1.37
log
@Back-out support for iCH10 chips from em(4).
It seems that new phy detection code breaks
some of the newer fiber cards.

found by Brad, ok by claudio@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.36 2009/07/03 06:54:39 markus Exp $ */
d88 1
d479 1
d487 3
d492 4
d504 1
d565 1
d704 1
d796 3
a798 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d883 1
d963 3
a965 1
    if (hw->mac_type != em_ich8lan && hw->mac_type != em_ich9lan) {
d997 3
a999 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d1045 3
a1047 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d1094 1
d1118 2
a1119 1
    else if (hw->mac_type == em_ich9lan)
d1121 3
a1123 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d1215 1
d1271 8
d1291 7
a1297 2
    /* FCAL/H and FCT are hardcoded to standard values in em_ich8lan/em_ich9lan. */
    if (hw->mac_type != em_ich8lan && hw->mac_type != em_ich9lan) {
a1510 8
    /* Make sure we have a valid PHY */
    ret_val = em_detect_gig_phy(hw);
    if (ret_val) {
        DEBUGOUT("Error, did not detect valid phy.\n");
        return ret_val;
    }
    DEBUGOUT1("Phy ID = %x \n", hw->phy_id);

d1557 3
a1559 1
    if (hw->mac_type != em_ich8lan && hw->mac_type != em_ich9lan) {
d1899 2
a1900 1
        (hw->phy_revision < M88E1011_I_REV_4)) {
d2087 1
a3665 1
    const uint32_t phy_addr = 1;
d3680 1
a3680 1
                (phy_addr << E1000_MDIC_PHY_SHIFT) |
d3718 1
a3718 1
        mdic = ((reg_addr) | (phy_addr << 5) |
a3809 1
    const uint32_t phy_addr = 1;
d3825 1
a3825 1
                (phy_addr << E1000_MDIC_PHY_SHIFT) |
d3854 1
a3854 1
        mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (phy_addr << 7) |
d4129 1
a4129 1
* Probes the expected PHY address for known PHY IDs
d4134 1
a4134 1
em_detect_gig_phy(struct em_hw *hw)
d4140 1
a4140 4
    DEBUGFUNC("em_detect_gig_phy");

    if (hw->phy_id != 0)
        return E1000_SUCCESS;
a4141 30
    /* The 82571 firmware may still be configuring the PHY.  In this
     * case, we cannot access the PHY until the configuration is done.  So
     * we explicitly set the PHY values. */
    if (hw->mac_type == em_82571 ||
        hw->mac_type == em_82572 ||
	hw->mac_type == em_82575) {
        hw->phy_id = IGP01E1000_I_PHY_ID;
        hw->phy_type = em_phy_igp_2;
        return E1000_SUCCESS;
    }

    /* until something better comes along... makes the Lenovo X200 work */
    if (hw->mac_type == em_ich9lan &&
        (hw->device_id == E1000_DEV_ID_ICH9_IGP_M ||
         hw->device_id == E1000_DEV_ID_ICH9_IGP_M_AMT)) {
        hw->phy_id = IGP03E1000_E_PHY_ID;
        hw->phy_type = em_phy_igp_3;
        return E1000_SUCCESS;
    }

    /* ESB-2 PHY reads require em_phy_gg82563 to be set because of a work-
     * around that forces PHY page 0 to be set or the reads fail.  The rest of
     * the code in this routine uses em_read_phy_reg to read the PHY ID.
     * So for ESB-2 we need to have this set so our reads won't fail.  If the
     * attached PHY is not a em_phy_gg82563, the routines below will figure
     * this out as well. */
    if (hw->mac_type == em_80003es2lan)
        hw->phy_type = em_phy_gg82563;

    /* Read the PHY ID Registers to identify which PHY is onboard. */
d4157 2
a4158 2
        if (hw->phy_id == M88E1000_E_PHY_ID) match = TRUE;
        break;
d4160 2
a4161 2
        if (hw->phy_id == M88E1000_I_PHY_ID) match = TRUE;
        break;
d4167 2
a4168 2
        if (hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
        break;
d4173 2
a4174 2
        if (hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
        break;
d4176 2
a4177 2
        if (hw->phy_id == M88E1111_I_PHY_ID) match = TRUE;
        break;
d4179 2
a4180 2
        if (hw->phy_id == BME1000_E_PHY_ID) match = TRUE;
        break;
d4182 2
a4183 2
        if (hw->phy_id == GG82563_E_PHY_ID) match = TRUE;
        break;
d4186 7
a4192 5
        if (hw->phy_id == IGP03E1000_E_PHY_ID) match = TRUE;
        if (hw->phy_id == IFE_E_PHY_ID) match = TRUE;
        if (hw->phy_id == IFE_PLUS_E_PHY_ID) match = TRUE;
        if (hw->phy_id == IFE_C_E_PHY_ID) match = TRUE;
        break;
d4194 2
a4195 2
        DEBUGOUT1("Invalid MAC type %d\n", hw->mac_type);
        return -E1000_ERR_CONFIG;
d4200 46
a4245 1
        DEBUGOUT1("PHY ID 0x%X detected\n", hw->phy_id);
d4248 25
a4272 1
    DEBUGOUT1("Invalid PHY ID 0x%X\n", hw->phy_id);
d4436 1
d5056 3
a5058 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5111 3
a5113 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d5670 3
a5672 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5721 3
a5723 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5744 3
a5746 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5807 3
a5809 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d5818 3
a5820 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d5829 3
a5831 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d5840 3
a5842 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d5853 3
a5855 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5884 3
a5886 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5982 3
a5984 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d6042 3
a6044 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d6117 3
a6119 1
    if (hw->mac_type != em_ich8lan && hw->mac_type != em_ich9lan) {
d6148 3
a6150 1
    if (hw->mac_type != em_ich8lan && hw->mac_type != em_ich9lan) {
d6182 3
a6184 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d6314 1
d6876 3
a6878 1
    } else if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d6897 3
a6899 1
            if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d6950 3
a6952 1
            if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7004 3
a7006 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7015 3
a7017 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7058 3
a7060 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7219 3
a7221 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7469 1
d7697 3
a7699 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7740 3
a7742 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7770 3
a7772 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7810 3
a7812 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
@


1.36
log
@fix mac address for dual-port 8257[56] cards; ok claudio, kettenis, deraadt
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.35 2009/06/26 14:30:35 claudio Exp $ */
a87 1
static int32_t em_match_gig_phy(struct em_hw *hw);
a477 1
    case E1000_DEV_ID_ICH9_BM:
a484 3
    case E1000_DEV_ID_ICH10_R_BM_LF:
    case E1000_DEV_ID_ICH10_R_BM_LM:
    case E1000_DEV_ID_ICH10_R_BM_V:
a486 4
    case E1000_DEV_ID_ICH10_D_BM_LF:
    case E1000_DEV_ID_ICH10_D_BM_LM:
        hw->mac_type = em_ich10lan;
        break;
a494 1
    case em_ich10lan:
a554 1
        case em_ich10lan:
a692 1
        case em_ich10lan:
d784 1
a784 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
a868 1
            case em_ich10lan:
d948 1
a948 3
    if (hw->mac_type != em_ich8lan &&
        hw->mac_type != em_ich9lan &&
        hw->mac_type != em_ich10lan) {
d980 1
a980 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
d1026 1
a1026 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
a1072 1
    case em_ich10lan:
d1096 1
a1096 2
    else if (hw->mac_type == em_ich9lan ||
             hw->mac_type == em_ich10lan)
d1098 1
a1098 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
a1189 1
        case em_ich10lan:
d1257 2
a1258 7
    /*
     * FCAL/H and FCT are hardcoded to standard values in
     * em_ich8lan / em_ich9lan / em_ich10lan.
     */
    if (hw->mac_type != em_ich8lan &&
        hw->mac_type != em_ich9lan &&
        hw->mac_type != em_ich10lan) {
d1526 1
a1526 3
    if (hw->mac_type != em_ich8lan &&
        hw->mac_type != em_ich9lan &&
        hw->mac_type != em_ich10lan) {
d1866 1
a1866 2
        (hw->phy_revision < M88E1011_I_REV_4) &&
        (hw->phy_id != BME1000_E_PHY_ID)) {
a2052 1
    case em_ich10lan:
d3631 1
d3646 1
a3646 1
                (hw->phy_addr << E1000_MDIC_PHY_SHIFT) |
d3684 1
a3684 1
        mdic = ((reg_addr) | (hw->phy_addr << 5) |
d3776 1
d3792 1
a3792 1
                (hw->phy_addr << E1000_MDIC_PHY_SHIFT) |
d3821 1
a3821 1
        mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (hw->phy_addr << 7) |
d4096 1
a4096 1
* Reads and matches the expected PHY address for known PHY IDs
d4101 1
a4101 1
em_match_gig_phy(struct em_hw *hw)
d4107 33
a4139 1
    DEBUGFUNC("em_match_gig_phy");
d4141 1
d4157 2
a4158 2
            if (hw->phy_id == M88E1000_E_PHY_ID) match = TRUE;
            break;
d4160 2
a4161 2
            if (hw->phy_id == M88E1000_I_PHY_ID) match = TRUE;
            break;
d4167 2
a4168 2
            if (hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
            break;
d4173 2
a4174 2
            if (hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
            break;
d4176 2
a4177 2
            if (hw->phy_id == M88E1111_I_PHY_ID) match = TRUE;
            break;
d4179 2
a4180 2
            if (hw->phy_id == BME1000_E_PHY_ID) match = TRUE;
            break;
d4182 2
a4183 2
            if (hw->phy_id == GG82563_E_PHY_ID) match = TRUE;
            break;
d4186 5
a4190 7
    case em_ich10lan:
            if (hw->phy_id == IGP03E1000_E_PHY_ID) match = TRUE;
            if (hw->phy_id == IFE_E_PHY_ID) match = TRUE;
            if (hw->phy_id == IFE_PLUS_E_PHY_ID) match = TRUE;
            if (hw->phy_id == IFE_C_E_PHY_ID) match = TRUE;
            if (hw->phy_id == BME1000_E_PHY_ID) match = TRUE;
            break;
d4192 2
a4193 2
            DEBUGOUT1("Invalid MAC type %d\n", hw->mac_type);
            return -E1000_ERR_CONFIG;
d4198 2
a4199 2
            DEBUGOUT1("PHY ID 0x%X detected\n", hw->phy_id);
            return E1000_SUCCESS;
a4205 56
* Probes the expected PHY address for known PHY IDs
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
STATIC int32_t
em_detect_gig_phy(struct em_hw *hw)
{
    int32_t ret_val;

    DEBUGFUNC("em_detect_gig_phy");

    if (hw->phy_id != 0)
        return E1000_SUCCESS;

    /* default phy address, most phys reside here, but not all (ICH10) */
    hw->phy_addr = 1;

    /* The 82571 firmware may still be configuring the PHY.  In this
     * case, we cannot access the PHY until the configuration is done.  So
     * we explicitly set the PHY values. */
    if (hw->mac_type == em_82571 ||
        hw->mac_type == em_82572 ||
	hw->mac_type == em_82575) {
        hw->phy_id = IGP01E1000_I_PHY_ID;
        hw->phy_type = em_phy_igp_2;
        return E1000_SUCCESS;
    }

    /* until something better comes along... makes the Lenovo X200 work */
    if (hw->mac_type == em_ich9lan &&
        (hw->device_id == E1000_DEV_ID_ICH9_IGP_M ||
         hw->device_id == E1000_DEV_ID_ICH9_IGP_M_AMT)) {
        hw->phy_id = IGP03E1000_E_PHY_ID;
        hw->phy_type = em_phy_igp_3;
        return E1000_SUCCESS;
    }

    /* ESB-2 PHY reads require em_phy_gg82563 to be set because of a work-
     * around that forces PHY page 0 to be set or the reads fail.  The rest of
     * the code in this routine uses em_read_phy_reg to read the PHY ID.
     * So for ESB-2 we need to have this set so our reads won't fail.  If the
     * attached PHY is not a em_phy_gg82563, the routines below will figure
     * this out as well. */
    if (hw->mac_type == em_80003es2lan)
        hw->phy_type = em_phy_gg82563;

    /* Read the PHY ID Registers to identify which PHY is onboard. */
    for (hw->phy_addr = 1; (hw->phy_addr < 4); hw->phy_addr++) {
        ret_val = em_match_gig_phy(hw);
        if (ret_val == E1000_SUCCESS)
            return E1000_SUCCESS;
    }
    return -E1000_ERR_PHY;
}

/******************************************************************************
a4364 1
    case em_ich10lan:
d4984 1
a4984 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
d5037 1
a5037 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
d5594 1
a5594 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
d5643 1
a5643 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
d5664 1
a5664 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
d5725 1
a5725 3
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
d5734 1
a5734 3
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
d5743 1
a5743 3
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
d5752 1
a5752 3
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
d5763 1
a5763 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
d5792 1
a5792 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
d5888 1
a5888 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
d5946 1
a5946 3
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan)
d6019 1
a6019 3
    if (hw->mac_type != em_ich8lan &&
        hw->mac_type != em_ich9lan &&
        hw->mac_type != em_ich10lan) {
d6048 1
a6048 3
    if (hw->mac_type != em_ich8lan &&
        hw->mac_type != em_ich9lan &&
        hw->mac_type != em_ich10lan) {
d6080 1
a6080 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan)
a6209 1
    case em_ich10lan:
d6771 1
a6771 3
    } else if (hw->mac_type == em_ich8lan ||
               hw->mac_type == em_ich9lan ||
               hw->mac_type == em_ich10lan) {
d6790 1
a6790 3
            if (hw->mac_type == em_ich8lan ||
                hw->mac_type == em_ich9lan ||
                hw->mac_type == em_ich10lan) {
d6841 1
a6841 3
            if (hw->mac_type == em_ich8lan ||
                hw->mac_type == em_ich9lan ||
                hw->mac_type == em_ich10lan) {
d6893 1
a6893 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
d6902 1
a6902 3
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
d6943 1
a6943 3
        if (hw->mac_type == em_ich8lan ||
            hw->mac_type == em_ich9lan ||
            hw->mac_type == em_ich10lan) {
d7102 1
a7102 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
a7349 1
    case em_ich10lan:
d7577 1
a7577 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
d7618 1
a7618 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
d7646 1
a7646 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
d7684 1
a7684 3
    if (hw->mac_type == em_ich8lan ||
        hw->mac_type == em_ich9lan ||
        hw->mac_type == em_ich10lan) {
@


1.35
log
@Support the ICH10 variants of em(4). All the work done by Dariusz Swiderski
with help from Brad. OK deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.34 2009/06/23 14:09:51 claudio Exp $ */
d5616 1
@


1.34
log
@Add support for the 82574L chips and the bme1000 phy which is also used on
some newer ICH* chips. All the hard work done by Dariusz Swiderski
sfires (at) sfires.net, tested by myself, sthen@@ and many more.
Eyeballed and OK dlg@@ kettenis@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.33 2009/06/04 05:08:43 claudio Exp $ */
d88 1
d479 1
d487 3
d492 4
d504 1
d565 1
d704 1
d796 3
a798 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d883 1
d963 3
a965 1
    if (hw->mac_type != em_ich8lan && hw->mac_type != em_ich9lan) {
d997 3
a999 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d1045 3
a1047 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d1094 1
d1118 2
a1119 1
    else if (hw->mac_type == em_ich9lan)
d1121 3
a1123 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d1215 1
d1283 7
a1289 2
    /* FCAL/H and FCT are hardcoded to standard values in em_ich8lan/em_ich9lan. */
    if (hw->mac_type != em_ich8lan && hw->mac_type != em_ich9lan) {
d1557 3
a1559 1
    if (hw->mac_type != em_ich8lan && hw->mac_type != em_ich9lan) {
d1899 2
a1900 1
        (hw->phy_revision < M88E1011_I_REV_4)) {
d2087 1
a3665 1
    const uint32_t phy_addr = 1;
d3680 1
a3680 1
                (phy_addr << E1000_MDIC_PHY_SHIFT) |
d3718 1
a3718 1
        mdic = ((reg_addr) | (phy_addr << 5) |
a3809 1
    const uint32_t phy_addr = 1;
d3825 1
a3825 1
                (phy_addr << E1000_MDIC_PHY_SHIFT) |
d3854 1
a3854 1
        mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (phy_addr << 7) |
d4129 1
a4129 1
* Probes the expected PHY address for known PHY IDs
d4134 1
a4134 1
em_detect_gig_phy(struct em_hw *hw)
d4140 1
a4140 33
    DEBUGFUNC("em_detect_gig_phy");

    if (hw->phy_id != 0)
        return E1000_SUCCESS;

    /* The 82571 firmware may still be configuring the PHY.  In this
     * case, we cannot access the PHY until the configuration is done.  So
     * we explicitly set the PHY values. */
    if (hw->mac_type == em_82571 ||
        hw->mac_type == em_82572 ||
	hw->mac_type == em_82575) {
        hw->phy_id = IGP01E1000_I_PHY_ID;
        hw->phy_type = em_phy_igp_2;
        return E1000_SUCCESS;
    }

    /* until something better comes along... makes the Lenovo X200 work */
    if (hw->mac_type == em_ich9lan &&
        (hw->device_id == E1000_DEV_ID_ICH9_IGP_M ||
         hw->device_id == E1000_DEV_ID_ICH9_IGP_M_AMT)) {
        hw->phy_id = IGP03E1000_E_PHY_ID;
        hw->phy_type = em_phy_igp_3;
        return E1000_SUCCESS;
    }

    /* ESB-2 PHY reads require em_phy_gg82563 to be set because of a work-
     * around that forces PHY page 0 to be set or the reads fail.  The rest of
     * the code in this routine uses em_read_phy_reg to read the PHY ID.
     * So for ESB-2 we need to have this set so our reads won't fail.  If the
     * attached PHY is not a em_phy_gg82563, the routines below will figure
     * this out as well. */
    if (hw->mac_type == em_80003es2lan)
        hw->phy_type = em_phy_gg82563;
a4141 1
    /* Read the PHY ID Registers to identify which PHY is onboard. */
d4157 2
a4158 2
        if (hw->phy_id == M88E1000_E_PHY_ID) match = TRUE;
        break;
d4160 2
a4161 2
        if (hw->phy_id == M88E1000_I_PHY_ID) match = TRUE;
        break;
d4167 2
a4168 2
        if (hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
        break;
d4173 2
a4174 2
        if (hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
        break;
d4176 2
a4177 2
        if (hw->phy_id == M88E1111_I_PHY_ID) match = TRUE;
        break;
d4179 2
a4180 2
        if (hw->phy_id == BME1000_E_PHY_ID) match = TRUE;
        break;
d4182 2
a4183 2
        if (hw->phy_id == GG82563_E_PHY_ID) match = TRUE;
        break;
d4186 7
a4192 5
        if (hw->phy_id == IGP03E1000_E_PHY_ID) match = TRUE;
        if (hw->phy_id == IFE_E_PHY_ID) match = TRUE;
        if (hw->phy_id == IFE_PLUS_E_PHY_ID) match = TRUE;
        if (hw->phy_id == IFE_C_E_PHY_ID) match = TRUE;
        break;
d4194 2
a4195 2
        DEBUGOUT1("Invalid MAC type %d\n", hw->mac_type);
        return -E1000_ERR_CONFIG;
d4200 42
a4241 1
        DEBUGOUT1("PHY ID 0x%X detected\n", hw->phy_id);
d4244 16
a4259 1
    DEBUGOUT1("Invalid PHY ID 0x%X\n", hw->phy_id);
d4423 1
d5043 3
a5045 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5098 3
a5100 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d5656 3
a5658 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5707 3
a5709 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5730 3
a5732 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5793 3
a5795 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d5804 3
a5806 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d5815 3
a5817 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d5826 3
a5828 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d5839 3
a5841 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5870 3
a5872 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d5968 3
a5970 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d6028 3
a6030 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d6103 3
a6105 1
    if (hw->mac_type != em_ich8lan && hw->mac_type != em_ich9lan) {
d6134 3
a6136 1
    if (hw->mac_type != em_ich8lan && hw->mac_type != em_ich9lan) {
d6168 3
a6170 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan)
d6300 1
d6862 3
a6864 1
    } else if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d6883 3
a6885 1
            if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d6936 3
a6938 1
            if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d6990 3
a6992 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7001 3
a7003 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7044 3
a7046 1
        if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7205 3
a7207 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7455 1
d7683 3
a7685 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7726 3
a7728 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7756 3
a7758 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
d7796 3
a7798 1
    if (hw->mac_type == em_ich8lan || hw->mac_type == em_ich9lan) {
@


1.33
log
@Match em(4) against all the newer chips (82575/6) and treat them all the
same. Not sure if the 82576 is 100% compatible to the 82575 but only when
enabled it will be possible to test them. OK jsg@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.32 2009/06/03 17:39:44 claudio Exp $ */
d223 6
d449 3
d504 1
d556 1
d640 1
a640 1
    if (hw->mac_type == em_82573) {
d737 1
d841 1
d1039 1
a1039 1
    if (hw->mac_type == em_82573) {
d1079 1
a1079 1
    if (hw->mac_type == em_82573) {
d1191 1
d1818 4
a1821 2
    phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;

d1856 5
d1865 2
a1866 1
    if (hw->phy_revision < M88E1011_I_REV_4) {
d1898 16
d2095 2
a2096 1
    } else if (hw->phy_type == em_phy_m88) {
d2453 2
a2454 1
        (hw->phy_type == em_phy_gg82563)) {
d2536 2
a2537 1
            (hw->phy_type == em_phy_gg82563))) {
d2562 2
a2563 1
    if (hw->phy_type == em_phy_m88) {
d3608 9
a3616 1
    }
d3754 8
a3761 1
    }
d4178 3
d4326 1
d4579 1
a4579 1
    if (hw->mac_type != em_82573) {
d4987 1
a4987 1
    if (hw->mac_type == em_82573) {
d5018 1
a5018 1
    if ((hw->mac_type == em_82573) &&
d5144 1
a5144 1
    /* 82573 writes only through eewr */
d5344 1
a5344 1
    if (hw->mac_type == em_82573) {
d5890 1
a5890 1
    if (hw->mac_type == em_82573) {
d6193 1
d7344 1
d7366 1
a7366 1
    if (hw->mac_type == em_82573)
@


1.32
log
@Add support for the newer 82575 and maybe 82576 chips. The cards work more
or less out of the box if one explicitly enables the TX DMA engine.
Only tested with 82575, people with 82576 cards may contact me for a diff.
OK kettenis@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.31 2008/12/04 02:36:52 brad Exp $ */
d445 6
@


1.31
log
@Add initial support for the ICH9 IGP M and ICH9 IGP M AMT chipsets.

For now the chunk in em_detect_gig_phy() is a hack to get things going
until it can be figured out why exactly the PHY id is not probed
properly.

Based on a diff from jcs@@ via ckuethe@@
ok kettenis@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.30 2008/09/24 19:12:59 chl Exp $ */
d413 2
a414 2
        hw->mac_type = em_82547_rev_2;
        break;
d426 2
a427 2
            hw->mac_type = em_82571;
        break;
d443 5
d1051 1
d4053 2
a4054 1
        hw->mac_type == em_82572) {
d4245 1
d6126 1
d7276 1
d7331 1
@


1.30
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ brad@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.29 2008/03/21 00:20:55 brad Exp $ */
d463 2
d4050 9
@


1.29
log
@Some additional changes to deal with the ICH8 and ICH9 chipsets.

Some bits from FreeBSD

Tested by Mike Belopuhov <mkb at crypt dot org dot ru>,
          Henry Precheur <henry at precheur dot org>,
          Alexander Hall <alexander at beard dot se>,
          Matthew L. Shobe <mshobe at gmail dot com>
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.28 2008/02/20 00:00:06 brad Exp $ */
a245 1
    uint32_t ret_val;
d255 1
a255 1
        ret_val = em_read_phy_reg(hw, 0x2F5B, &phy_saved_data);
@


1.28
log
@Add support for the Intel ICH9 chipsets.

Initial diff from Henry Precheur based on a commit from matthias@@dragonflybsd
which was derived from the FreeBSD driver. Additional Flash changes from
sephe@@dragonflybsd which was derived from the FreeBSD driver. Typo fixes
in Henry's diff and a few other improvements from the FreeBSD driver from
brad@@.

Tested on a variety of different em(4) adapters in addition to ICH8/9.

ok dlg@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.27 2008/02/04 00:30:01 brad Exp $ */
d672 3
a674 3
                /* em_ich8lan PHY HW reset requires MAC CORE reset
                 * at the same time to make sure the interface between
                 * MAC and the external PHY is reset.
d900 2
a901 5
    /* force full DMA clock frequency for 10/100 on ICH8 A0-B0 */
    if ((hw->mac_type == em_ich8lan) &&
        ((hw->revision_id < 3) ||
         ((hw->device_id != E1000_DEV_ID_ICH8_IGP_M_AMT) &&
          (hw->device_id != E1000_DEV_ID_ICH8_IGP_M)))) {
d922 2
a923 2
    /* VET hardcoded to standard value and VFTA removed in ICH8 LAN */
    if (hw->mac_type != em_ich8lan) {
d1230 2
a1231 2
    /* FCAL/H and FCT are hardcoded to standard values in em_ich8lan. */
    if (hw->mac_type != em_ich8lan) {
d8229 1
a8229 1
    uint32_t reg_data, cnf_base_addr, cnf_size, ret_val, loop;
d8235 6
d8242 1
a8242 1
    if (!(reg_data & FEXTNVM_SW_CONFIG))
@


1.27
log
@Add PCI ids for some 82571 based multi port adapters.

From FreeBSD

ok dlg@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.26 2007/05/09 18:02:46 deraadt Exp $ */
d450 3
a452 1
    case E1000_DEV_ID_ICH8_IGP_M_AMT:
a454 3
    case E1000_DEV_ID_ICH8_IFE:
    case E1000_DEV_ID_ICH8_IFE_GT:
    case E1000_DEV_ID_ICH8_IFE_G:
d456 1
d459 7
d473 1
d532 1
d669 1
d760 1
a760 1
    if (hw->mac_type == em_ich8lan) {
d843 2
a844 3
                if ((hw->revision_id < 3) ||
                    ((hw->device_id != E1000_DEV_ID_ICH8_IGP_M_AMT) &&
                     (hw->device_id != E1000_DEV_ID_ICH8_IGP_M)))
d896 1
d958 1
a958 1
    if (hw->mac_type == em_ich8lan)
d1004 1
a1004 1
    if (hw->mac_type == em_ich8lan)
d1049 1
d1072 5
a1076 1
        em_set_pci_ex_no_snoop(hw, PCI_EX_82566_SNOOP_ALL);
d1166 1
d1502 6
a1507 6
    if (hw->mac_type != em_ich8lan) {
    /* Configure activity LED after PHY reset */
    led_ctrl = E1000_READ_REG(hw, LEDCTL);
    led_ctrl &= IGP_ACTIVITY_LED_MASK;
    led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
    E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
d2004 1
d4105 1
d4282 1
d4902 1
a4902 1
    if (hw->mac_type == em_ich8lan)
d4955 1
a4955 1
    if (hw->mac_type == em_ich8lan) {
d5298 2
a5299 1
    if (hw->mac_type == em_ich8lan && hw->eeprom_shadow_ram != NULL) {
d5511 2
d5514 1
a5514 1
        rar_num = E1000_RAR_ENTRIES_ICH8LAN;
d5560 2
d5563 1
a5563 1
        num_rar_entry = E1000_RAR_ENTRIES_ICH8LAN;
d5581 1
a5581 1
    if (hw->mac_type == em_ich8lan)
d5642 1
a5642 1
        if (hw->mac_type == em_ich8lan) {
d5651 1
a5651 1
        if (hw->mac_type == em_ich8lan) {
d5660 1
a5660 1
        if (hw->mac_type == em_ich8lan) {
d5669 1
a5669 1
        if (hw->mac_type == em_ich8lan) {
d5680 1
a5680 1
    if (hw->mac_type == em_ich8lan)
d5709 1
a5709 1
    if (hw->mac_type == em_ich8lan)
d5805 1
a5805 1
    if (hw->mac_type == em_ich8lan)
d5863 1
a5863 1
        if (hw->mac_type == em_ich8lan)
d5936 1
a5936 1
    if (hw->mac_type != em_ich8lan) {
d5965 1
a5965 1
    if (hw->mac_type != em_ich8lan) {
d5997 2
a5998 1
    if (hw->mac_type == em_ich8lan) return;
d6124 1
d6686 1
a6686 1
    } else if (hw->mac_type == em_ich8lan) {
d6705 1
a6705 1
            if (hw->mac_type == em_ich8lan) {
d6756 1
a6756 1
            if (hw->mac_type == em_ich8lan) {
d6808 1
a6808 1
    if (hw->mac_type == em_ich8lan) {
d6817 1
a6817 1
        if (hw->mac_type == em_ich8lan) {
d6858 1
a6858 1
        if (hw->mac_type == em_ich8lan) {
d7017 1
a7017 1
    if (hw->mac_type == em_ich8lan) {
d7262 1
d7489 1
a7489 1
    if (hw->mac_type == em_ich8lan) {
d7529 2
a7530 1
    if (hw->mac_type == em_ich8lan) {
a7532 2
        E1000_WRITE_REG(hw, GCR, PCI_EX_82566_SNOOP_ALL);

d7558 1
a7558 1
    if (hw->mac_type == em_ich8lan) {
d7596 1
a7596 1
    if (hw->mac_type == em_ich8lan) {
d8101 29
@


1.26
log
@delete unused functions.  typical vendor garbage driver..; ok kettenis
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.25 2007/03/16 00:07:37 reyk Exp $ */
d423 4
a426 1
    case E1000_DEV_ID_82571EB_QUAD_COPPER_LOWPROFILE:
d511 2
@


1.25
log
@A new PCI id for Intel's PCIe quad port fiber adapter.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.24 2006/11/06 03:52:37 brad Exp $ */
a82 1
static uint8_t em_arc_subsystem_valid(struct em_hw *hw);
a83 1
static int32_t em_check_polarity(struct em_hw *hw, em_rev_polarity *polarity);
a104 5
static int32_t em_mng_host_if_write(struct em_hw *hw, uint8_t *buffer, uint16_t length, uint16_t offset, uint8_t *sum);
static int32_t em_mng_write_cmd_header(struct em_hw* hw, struct em_host_mng_command_header* hdr);
static int32_t em_mng_write_commit(struct em_hw *hw);
static int32_t em_phy_ife_get_info(struct em_hw *hw, struct em_phy_info *phy_info);
static int32_t em_phy_igp_get_info(struct em_hw *hw, struct em_phy_info *phy_info);
a107 1
static int32_t em_phy_m88_get_info(struct em_hw *hw, struct em_phy_info *phy_info);
a3944 48
* Work-around for 82566 power-down: on D3 entry-
* 1) disable gigabit link
* 2) write VR power-down enable
* 3) read it back
* if successful continue, else issue LCD reset and repeat
*
* hw - struct containing variables accessed by shared code
******************************************************************************/
void
em_phy_powerdown_workaround(struct em_hw *hw)
{
    int32_t reg;
    uint16_t phy_data;
    int32_t retry = 0;

    DEBUGFUNC("em_phy_powerdown_workaround");

    if (hw->phy_type != em_phy_igp_3)
        return;

    do {
        /* Disable link */
        reg = E1000_READ_REG(hw, PHY_CTRL);
        E1000_WRITE_REG(hw, PHY_CTRL, reg | E1000_PHY_CTRL_GBE_DISABLE |
                        E1000_PHY_CTRL_NOND0A_GBE_DISABLE);

        /* Write VR power-down enable - bits 9:8 should be 10b */
        em_read_phy_reg(hw, IGP3_VR_CTRL, &phy_data);
        phy_data |= (1 << 9);
        phy_data &= ~(1 << 8);
        em_write_phy_reg(hw, IGP3_VR_CTRL, phy_data);

        /* Read it back and test */
        em_read_phy_reg(hw, IGP3_VR_CTRL, &phy_data);
        if (((phy_data & IGP3_VR_CTRL_MODE_MASK) == IGP3_VR_CTRL_MODE_SHUT) || retry)
            break;

        /* Issue PHY reset and repeat at most one more time */
        reg = E1000_READ_REG(hw, CTRL);
        E1000_WRITE_REG(hw, CTRL, reg | E1000_CTRL_PHY_RST);
        retry++;
    } while (retry);

    return;

}

/******************************************************************************
a4128 271
* Get PHY information from various PHY registers for igp PHY only.
*
* hw - Struct containing variables accessed by shared code
* phy_info - PHY information structure
******************************************************************************/
STATIC int32_t
em_phy_igp_get_info(struct em_hw *hw,
                       struct em_phy_info *phy_info)
{
    int32_t ret_val;
    uint16_t phy_data, min_length, max_length, average;
    em_rev_polarity polarity;

    DEBUGFUNC("em_phy_igp_get_info");

    /* The downshift status is checked only once, after link is established,
     * and it stored in the hw->speed_downgraded parameter. */
    phy_info->downshift = (em_downshift)hw->speed_downgraded;

    /* IGP01E1000 does not need to support it. */
    phy_info->extended_10bt_distance = em_10bt_ext_dist_enable_normal;

    /* IGP01E1000 always correct polarity reversal */
    phy_info->polarity_correction = em_polarity_reversal_enabled;

    /* Check polarity status */
    ret_val = em_check_polarity(hw, &polarity);
    if (ret_val)
        return ret_val;

    phy_info->cable_polarity = polarity;

    ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data);
    if (ret_val)
        return ret_val;

    phy_info->mdix_mode = (em_auto_x_mode)((phy_data & IGP01E1000_PSSR_MDIX) >>
                          IGP01E1000_PSSR_MDIX_SHIFT);

    if ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
       IGP01E1000_PSSR_SPEED_1000MBPS) {
        /* Local/Remote Receiver Information are only valid at 1000 Mbps */
        ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
        if (ret_val)
            return ret_val;

        phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
                             SR_1000T_LOCAL_RX_STATUS_SHIFT) ?
                             em_1000t_rx_status_ok : em_1000t_rx_status_not_ok;
        phy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>
                              SR_1000T_REMOTE_RX_STATUS_SHIFT) ?
                              em_1000t_rx_status_ok : em_1000t_rx_status_not_ok;

        /* Get cable length */
        ret_val = em_get_cable_length(hw, &min_length, &max_length);
        if (ret_val)
            return ret_val;

        /* Translate to old method */
        average = (max_length + min_length) / 2;

        if (average <= em_igp_cable_length_50)
            phy_info->cable_length = em_cable_length_50;
        else if (average <= em_igp_cable_length_80)
            phy_info->cable_length = em_cable_length_50_80;
        else if (average <= em_igp_cable_length_110)
            phy_info->cable_length = em_cable_length_80_110;
        else if (average <= em_igp_cable_length_140)
            phy_info->cable_length = em_cable_length_110_140;
        else
            phy_info->cable_length = em_cable_length_140;
    }

    return E1000_SUCCESS;
}

/******************************************************************************
* Get PHY information from various PHY registers for ife PHY only.
*
* hw - Struct containing variables accessed by shared code
* phy_info - PHY information structure
******************************************************************************/
STATIC int32_t
em_phy_ife_get_info(struct em_hw *hw,
                       struct em_phy_info *phy_info)
{
    int32_t ret_val;
    uint16_t phy_data;
    em_rev_polarity polarity;

    DEBUGFUNC("em_phy_ife_get_info");

    phy_info->downshift = (em_downshift)hw->speed_downgraded;
    phy_info->extended_10bt_distance = em_10bt_ext_dist_enable_normal;

    ret_val = em_read_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL, &phy_data);
    if (ret_val)
        return ret_val;
    phy_info->polarity_correction =
                        ((phy_data & IFE_PSC_AUTO_POLARITY_DISABLE) >>
                        IFE_PSC_AUTO_POLARITY_DISABLE_SHIFT) ?
                        em_polarity_reversal_disabled : em_polarity_reversal_enabled;

    if (phy_info->polarity_correction == em_polarity_reversal_enabled) {
        ret_val = em_check_polarity(hw, &polarity);
        if (ret_val)
            return ret_val;
    } else {
        /* Polarity is forced. */
        polarity = ((phy_data & IFE_PSC_FORCE_POLARITY) >>
                     IFE_PSC_FORCE_POLARITY_SHIFT) ?
                     em_rev_polarity_reversed : em_rev_polarity_normal;
    }
    phy_info->cable_polarity = polarity;

    ret_val = em_read_phy_reg(hw, IFE_PHY_MDIX_CONTROL, &phy_data);
    if (ret_val)
        return ret_val;

    phy_info->mdix_mode = (em_auto_x_mode)
                     ((phy_data & (IFE_PMC_AUTO_MDIX | IFE_PMC_FORCE_MDIX)) >>
                     IFE_PMC_MDIX_MODE_SHIFT);

    return E1000_SUCCESS;
}

/******************************************************************************
* Get PHY information from various PHY registers fot m88 PHY only.
*
* hw - Struct containing variables accessed by shared code
* phy_info - PHY information structure
******************************************************************************/
STATIC int32_t
em_phy_m88_get_info(struct em_hw *hw,
                       struct em_phy_info *phy_info)
{
    int32_t ret_val;
    uint16_t phy_data;
    em_rev_polarity polarity;

    DEBUGFUNC("em_phy_m88_get_info");

    /* The downshift status is checked only once, after link is established,
     * and it stored in the hw->speed_downgraded parameter. */
    phy_info->downshift = (em_downshift)hw->speed_downgraded;

    ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
    if (ret_val)
        return ret_val;

    phy_info->extended_10bt_distance =
        ((phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
        M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT) ?
        em_10bt_ext_dist_enable_lower : em_10bt_ext_dist_enable_normal;

    phy_info->polarity_correction =
        ((phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>
        M88E1000_PSCR_POLARITY_REVERSAL_SHIFT) ?
        em_polarity_reversal_disabled : em_polarity_reversal_enabled;

    /* Check polarity status */
    ret_val = em_check_polarity(hw, &polarity);
    if (ret_val)
        return ret_val;
    phy_info->cable_polarity = polarity;

    ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
    if (ret_val)
        return ret_val;

    phy_info->mdix_mode = (em_auto_x_mode)((phy_data & M88E1000_PSSR_MDIX) >>
                          M88E1000_PSSR_MDIX_SHIFT);

    if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) {
        /* Cable Length Estimation and Local/Remote Receiver Information
         * are only valid at 1000 Mbps.
         */
        if (hw->phy_type != em_phy_gg82563) {
            phy_info->cable_length = (em_cable_length)((phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
                                      M88E1000_PSSR_CABLE_LENGTH_SHIFT);
        } else {
            ret_val = em_read_phy_reg(hw, GG82563_PHY_DSP_DISTANCE,
                                         &phy_data);
            if (ret_val)
                return ret_val;

            phy_info->cable_length = (em_cable_length)(phy_data & GG82563_DSPD_CABLE_LENGTH);
        }

        ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
        if (ret_val)
            return ret_val;

        phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
                             SR_1000T_LOCAL_RX_STATUS_SHIFT) ?
                             em_1000t_rx_status_ok : em_1000t_rx_status_not_ok;
        phy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>
                              SR_1000T_REMOTE_RX_STATUS_SHIFT) ?
                              em_1000t_rx_status_ok : em_1000t_rx_status_not_ok;
    }

    return E1000_SUCCESS;
}

/******************************************************************************
* Get PHY information from various PHY registers
*
* hw - Struct containing variables accessed by shared code
* phy_info - PHY information structure
******************************************************************************/
int32_t
em_phy_get_info(struct em_hw *hw,
                   struct em_phy_info *phy_info)
{
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_phy_get_info");

    phy_info->cable_length = em_cable_length_undefined;
    phy_info->extended_10bt_distance = em_10bt_ext_dist_enable_undefined;
    phy_info->cable_polarity = em_rev_polarity_undefined;
    phy_info->downshift = em_downshift_undefined;
    phy_info->polarity_correction = em_polarity_reversal_undefined;
    phy_info->mdix_mode = em_auto_x_mode_undefined;
    phy_info->local_rx = em_1000t_rx_status_undefined;
    phy_info->remote_rx = em_1000t_rx_status_undefined;

    if (hw->media_type != em_media_type_copper) {
        DEBUGOUT("PHY info is only valid for copper media\n");
        return -E1000_ERR_CONFIG;
    }

    ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
    if (ret_val)
        return ret_val;

    ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
    if (ret_val)
        return ret_val;

    if ((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {
        DEBUGOUT("PHY info is only valid if link is up\n");
        return -E1000_ERR_CONFIG;
    }

    if (hw->phy_type == em_phy_igp ||
        hw->phy_type == em_phy_igp_3 ||
        hw->phy_type == em_phy_igp_2)
        return em_phy_igp_get_info(hw, phy_info);
    else if (hw->phy_type == em_phy_ife)
        return em_phy_ife_get_info(hw, phy_info);
    else
        return em_phy_m88_get_info(hw, phy_info);
}

int32_t
em_validate_mdi_setting(struct em_hw *hw)
{
    DEBUGFUNC("em_validate_mdi_settings");

    if (!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {
        DEBUGOUT("Invalid MDI setting detected\n");
        hw->mdix = 1;
        return -E1000_ERR_CONFIG;
    }
    return E1000_SUCCESS;
}


/******************************************************************************
a5763 29
 * Writes a value to the specified offset in the VLAN filter table.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - Offset in VLAN filer table to write
 * value - Value to write into VLAN filter table
 *****************************************************************************/
void
em_write_vfta(struct em_hw *hw,
                 uint32_t offset,
                 uint32_t value)
{
    uint32_t temp;

    if (hw->mac_type == em_ich8lan)
        return;

    if ((hw->mac_type == em_82544) && ((offset & 0x1) == 1)) {
        temp = E1000_READ_REG_ARRAY(hw, VFTA, (offset - 1));
        E1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);
        E1000_WRITE_FLUSH(hw);
        E1000_WRITE_REG_ARRAY(hw, VFTA, (offset - 1), temp);
        E1000_WRITE_FLUSH(hw);
    } else {
        E1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);
        E1000_WRITE_FLUSH(hw);
    }
}

/******************************************************************************
a5880 238
 * Prepares SW controlable LED for use and saves the current state of the LED.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_setup_led(struct em_hw *hw)
{
    uint32_t ledctl;
    int32_t ret_val = E1000_SUCCESS;

    DEBUGFUNC("em_setup_led");

    switch (hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
    case em_82543:
    case em_82544:
        /* No setup necessary */
        break;
    case em_82541:
    case em_82547:
    case em_82541_rev_2:
    case em_82547_rev_2:
        /* Turn off PHY Smart Power Down (if enabled) */
        ret_val = em_read_phy_reg(hw, IGP01E1000_GMII_FIFO,
                                     &hw->phy_spd_default);
        if (ret_val)
            return ret_val;
        ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
                                      (uint16_t)(hw->phy_spd_default &
                                      ~IGP01E1000_GMII_SPD));
        if (ret_val)
            return ret_val;
        /* FALLTHROUGH */
    default:
        if (hw->media_type == em_media_type_fiber) {
            ledctl = E1000_READ_REG(hw, LEDCTL);
            /* Save current LEDCTL settings */
            hw->ledctl_default = ledctl;
            /* Turn off LED0 */
            ledctl &= ~(E1000_LEDCTL_LED0_IVRT |
                        E1000_LEDCTL_LED0_BLINK |
                        E1000_LEDCTL_LED0_MODE_MASK);
            ledctl |= (E1000_LEDCTL_MODE_LED_OFF <<
                       E1000_LEDCTL_LED0_MODE_SHIFT);
            E1000_WRITE_REG(hw, LEDCTL, ledctl);
        } else if (hw->media_type == em_media_type_copper)
            E1000_WRITE_REG(hw, LEDCTL, hw->ledctl_mode1);
        break;
    }

    return E1000_SUCCESS;
}


/******************************************************************************
 * Used on 82571 and later Si that has LED blink bits.
 * Callers must use their own timer and should have already called
 * em_id_led_init()
 * Call em_cleanup led() to stop blinking
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_blink_led_start(struct em_hw *hw)
{
    int16_t  i;
    uint32_t ledctl_blink = 0;

    DEBUGFUNC("em_id_led_blink_on");

    if (hw->mac_type < em_82571) {
        /* Nothing to do */
        return E1000_SUCCESS;
    }
    if (hw->media_type == em_media_type_fiber) {
        /* always blink LED0 for PCI-E fiber */
        ledctl_blink = E1000_LEDCTL_LED0_BLINK |
                     (E1000_LEDCTL_MODE_LED_ON << E1000_LEDCTL_LED0_MODE_SHIFT);
    } else {
        /* set the blink bit for each LED that's "on" (0x0E) in ledctl_mode2 */
        ledctl_blink = hw->ledctl_mode2;
        for (i=0; i < 4; i++)
            if (((hw->ledctl_mode2 >> (i * 8)) & 0xFF) ==
                E1000_LEDCTL_MODE_LED_ON)
                ledctl_blink |= (E1000_LEDCTL_LED0_BLINK << (i * 8));
    }

    E1000_WRITE_REG(hw, LEDCTL, ledctl_blink);

    return E1000_SUCCESS;
}

/******************************************************************************
 * Restores the saved state of the SW controlable LED.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_cleanup_led(struct em_hw *hw)
{
    int32_t ret_val = E1000_SUCCESS;

    DEBUGFUNC("em_cleanup_led");

    switch (hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
    case em_82543:
    case em_82544:
        /* No cleanup necessary */
        break;
    case em_82541:
    case em_82547:
    case em_82541_rev_2:
    case em_82547_rev_2:
        /* Turn on PHY Smart Power Down (if previously enabled) */
        ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
                                      hw->phy_spd_default);
        if (ret_val)
            return ret_val;
        /* FALLTHROUGH */
    default:
        if (hw->phy_type == em_phy_ife) {
            em_write_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL_LED, 0);
            break;
        }
        /* Restore LEDCTL settings */
        E1000_WRITE_REG(hw, LEDCTL, hw->ledctl_default);
        break;
    }

    return E1000_SUCCESS;
}

/******************************************************************************
 * Turns on the software controllable LED
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_led_on(struct em_hw *hw)
{
    uint32_t ctrl = E1000_READ_REG(hw, CTRL);

    DEBUGFUNC("em_led_on");

    switch (hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
    case em_82543:
        /* Set SW Defineable Pin 0 to turn on the LED */
        ctrl |= E1000_CTRL_SWDPIN0;
        ctrl |= E1000_CTRL_SWDPIO0;
        break;
    case em_82544:
        if (hw->media_type == em_media_type_fiber) {
            /* Set SW Defineable Pin 0 to turn on the LED */
            ctrl |= E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        } else {
            /* Clear SW Defineable Pin 0 to turn on the LED */
            ctrl &= ~E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        }
        break;
    default:
        if (hw->media_type == em_media_type_fiber) {
            /* Clear SW Defineable Pin 0 to turn on the LED */
            ctrl &= ~E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        } else if (hw->phy_type == em_phy_ife) {
            em_write_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL_LED,
                 (IFE_PSCL_PROBE_MODE | IFE_PSCL_PROBE_LEDS_ON));
        } else if (hw->media_type == em_media_type_copper) {
            E1000_WRITE_REG(hw, LEDCTL, hw->ledctl_mode2);
            return E1000_SUCCESS;
        }
        break;
    }

    E1000_WRITE_REG(hw, CTRL, ctrl);

    return E1000_SUCCESS;
}

/******************************************************************************
 * Turns off the software controllable LED
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_led_off(struct em_hw *hw)
{
    uint32_t ctrl = E1000_READ_REG(hw, CTRL);

    DEBUGFUNC("em_led_off");

    switch (hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
    case em_82543:
        /* Clear SW Defineable Pin 0 to turn off the LED */
        ctrl &= ~E1000_CTRL_SWDPIN0;
        ctrl |= E1000_CTRL_SWDPIO0;
        break;
    case em_82544:
        if (hw->media_type == em_media_type_fiber) {
            /* Clear SW Defineable Pin 0 to turn off the LED */
            ctrl &= ~E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        } else {
            /* Set SW Defineable Pin 0 to turn off the LED */
            ctrl |= E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        }
        break;
    default:
        if (hw->media_type == em_media_type_fiber) {
            /* Set SW Defineable Pin 0 to turn off the LED */
            ctrl |= E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        } else if (hw->phy_type == em_phy_ife) {
            em_write_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL_LED,
                 (IFE_PSCL_PROBE_MODE | IFE_PSCL_PROBE_LEDS_OFF));
        } else if (hw->media_type == em_media_type_copper) {
            E1000_WRITE_REG(hw, LEDCTL, hw->ledctl_mode1);
            return E1000_SUCCESS;
        }
        break;
    }

    E1000_WRITE_REG(hw, CTRL, ctrl);

    return E1000_SUCCESS;
}

/******************************************************************************
a5979 67
 * Resets Adaptive IFS to its default state.
 *
 * hw - Struct containing variables accessed by shared code
 *
 * Call this after em_init_hw. You may override the IFS defaults by setting
 * hw->ifs_params_forced to TRUE. However, you must initialize hw->
 * current_ifs_val, ifs_min_val, ifs_max_val, ifs_step_size, and ifs_ratio
 * before calling this function.
 *****************************************************************************/
void
em_reset_adaptive(struct em_hw *hw)
{
    DEBUGFUNC("em_reset_adaptive");

    if (hw->adaptive_ifs) {
        if (!hw->ifs_params_forced) {
            hw->current_ifs_val = 0;
            hw->ifs_min_val = IFS_MIN;
            hw->ifs_max_val = IFS_MAX;
            hw->ifs_step_size = IFS_STEP;
            hw->ifs_ratio = IFS_RATIO;
        }
        hw->in_ifs_mode = FALSE;
        E1000_WRITE_REG(hw, AIT, 0);
    } else {
        DEBUGOUT("Not in Adaptive IFS mode!\n");
    }
}

/******************************************************************************
 * Called during the callback/watchdog routine to update IFS value based on
 * the ratio of transmits to collisions.
 *
 * hw - Struct containing variables accessed by shared code
 * tx_packets - Number of transmits since last callback
 * total_collisions - Number of collisions since last callback
 *****************************************************************************/
void
em_update_adaptive(struct em_hw *hw)
{
    DEBUGFUNC("em_update_adaptive");

    if (hw->adaptive_ifs) {
        if ((hw->collision_delta * hw->ifs_ratio) > hw->tx_packet_delta) {
            if (hw->tx_packet_delta > MIN_NUM_XMITS) {
                hw->in_ifs_mode = TRUE;
                if (hw->current_ifs_val < hw->ifs_max_val) {
                    if (hw->current_ifs_val == 0)
                        hw->current_ifs_val = hw->ifs_min_val;
                    else
                        hw->current_ifs_val += hw->ifs_step_size;
                    E1000_WRITE_REG(hw, AIT, hw->current_ifs_val);
                }
            }
        } else {
            if (hw->in_ifs_mode && (hw->tx_packet_delta <= MIN_NUM_XMITS)) {
                hw->current_ifs_val = 0;
                hw->in_ifs_mode = FALSE;
                E1000_WRITE_REG(hw, AIT, 0);
            }
        }
    } else {
        DEBUGOUT("Not in Adaptive IFS mode!\n");
    }
}

/******************************************************************************
a6341 77
 * Check the cable polarity
 *
 * hw - Struct containing variables accessed by shared code
 * polarity - output parameter : 0 - Polarity is not reversed
 *                               1 - Polarity is reversed.
 *
 * returns: - E1000_ERR_XXX
 *            E1000_SUCCESS
 *
 * For phy's older then IGP, this function simply reads the polarity bit in the
 * Phy Status register.  For IGP phy's, this bit is valid only if link speed is
 * 10 Mbps.  If the link speed is 100 Mbps there is no polarity so this bit will
 * return 0.  If the link speed is 1000 Mbps the polarity status is in the
 * IGP01E1000_PHY_PCS_INIT_REG.
 *****************************************************************************/
STATIC int32_t
em_check_polarity(struct em_hw *hw,
                     em_rev_polarity *polarity)
{
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_check_polarity");

    if ((hw->phy_type == em_phy_m88) ||
        (hw->phy_type == em_phy_gg82563)) {
        /* return the Polarity bit in the Status register. */
        ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                     &phy_data);
        if (ret_val)
            return ret_val;
        *polarity = ((phy_data & M88E1000_PSSR_REV_POLARITY) >>
                     M88E1000_PSSR_REV_POLARITY_SHIFT) ?
                     em_rev_polarity_reversed : em_rev_polarity_normal;

    } else if (hw->phy_type == em_phy_igp ||
              hw->phy_type == em_phy_igp_3 ||
              hw->phy_type == em_phy_igp_2) {
        /* Read the Status register to check the speed */
        ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
                                     &phy_data);
        if (ret_val)
            return ret_val;

        /* If speed is 1000 Mbps, must read the IGP01E1000_PHY_PCS_INIT_REG to
         * find the polarity status */
        if ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
           IGP01E1000_PSSR_SPEED_1000MBPS) {

            /* Read the GIG initialization PCS register (0x00B4) */
            ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG,
                                         &phy_data);
            if (ret_val)
                return ret_val;

            /* Check the polarity bits */
            *polarity = (phy_data & IGP01E1000_PHY_POLARITY_MASK) ?
                         em_rev_polarity_reversed : em_rev_polarity_normal;
        } else {
            /* For 10 Mbps, read the polarity bit in the status register. (for
             * 100 Mbps this bit is always 0) */
            *polarity = (phy_data & IGP01E1000_PSSR_POLARITY_REVERSED) ?
                         em_rev_polarity_reversed : em_rev_polarity_normal;
        }
    } else if (hw->phy_type == em_phy_ife) {
        ret_val = em_read_phy_reg(hw, IFE_PHY_EXTENDED_STATUS_CONTROL,
                                     &phy_data);
        if (ret_val)
            return ret_val;
        *polarity = ((phy_data & IFE_PESC_POLARITY_REVERSED) >>
                     IFE_PESC_POLARITY_REVERSED_SHIFT) ?
                     em_rev_polarity_reversed : em_rev_polarity_normal;
    }
    return E1000_SUCCESS;
}

/******************************************************************************
a6974 128
 * This function writes the buffer content at the offset given on the host if.
 * It also does alignment considerations to do the writes in most efficient way.
 * Also fills up the sum of the buffer in *buffer parameter.
 *
 * returns  - E1000_SUCCESS for success.
 ****************************************************************************/
STATIC int32_t
em_mng_host_if_write(struct em_hw * hw, uint8_t *buffer,
                        uint16_t length, uint16_t offset, uint8_t *sum)
{
    uint8_t *tmp;
    uint8_t *bufptr = buffer;
    uint32_t data = 0;
    uint16_t remaining, i, j, prev_bytes;

    /* sum = only sum of the data and it is not checksum */

    if (length == 0 || offset + length > E1000_HI_MAX_MNG_DATA_LENGTH) {
        return -E1000_ERR_PARAM;
    }

    tmp = (uint8_t *)&data;
    prev_bytes = offset & 0x3;
    offset &= 0xFFFC;
    offset >>= 2;

    if (prev_bytes) {
        data = E1000_READ_REG_ARRAY_DWORD(hw, HOST_IF, offset);
        for (j = prev_bytes; j < sizeof(uint32_t); j++) {
            *(tmp + j) = *bufptr++;
            *sum += *(tmp + j);
        }
        E1000_WRITE_REG_ARRAY_DWORD(hw, HOST_IF, offset, data);
        length -= j - prev_bytes;
        offset++;
    }

    remaining = length & 0x3;
    length -= remaining;

    /* Calculate length in DWORDs */
    length >>= 2;

    /* The device driver writes the relevant command block into the
     * ram area. */
    for (i = 0; i < length; i++) {
        for (j = 0; j < sizeof(uint32_t); j++) {
            *(tmp + j) = *bufptr++;
            *sum += *(tmp + j);
        }

        E1000_WRITE_REG_ARRAY_DWORD(hw, HOST_IF, offset + i, data);
    }
    if (remaining) {
        for (j = 0; j < sizeof(uint32_t); j++) {
            if (j < remaining)
                *(tmp + j) = *bufptr++;
            else
                *(tmp + j) = 0;

            *sum += *(tmp + j);
        }
        E1000_WRITE_REG_ARRAY_DWORD(hw, HOST_IF, offset + i, data);
    }

    return E1000_SUCCESS;
}


/*****************************************************************************
 * This function writes the command header after does the checksum calculation.
 *
 * returns  - E1000_SUCCESS for success.
 ****************************************************************************/
STATIC int32_t
em_mng_write_cmd_header(struct em_hw * hw,
                           struct em_host_mng_command_header * hdr)
{
    uint16_t i;
    uint8_t sum;
    uint8_t *buffer;

    /* Write the whole command header structure which includes sum of
     * the buffer */

    uint16_t length = sizeof(struct em_host_mng_command_header);

    sum = hdr->checksum;
    hdr->checksum = 0;

    buffer = (uint8_t *) hdr;
    i = length;
    while (i--)
        sum += buffer[i];

    hdr->checksum = 0 - sum;

    length >>= 2;
    /* The device driver writes the relevant command block into the ram area. */
    for (i = 0; i < length; i++) {
        E1000_WRITE_REG_ARRAY_DWORD(hw, HOST_IF, i, *((uint32_t *) hdr + i));
        E1000_WRITE_FLUSH(hw);
    }

    return E1000_SUCCESS;
}


/*****************************************************************************
 * This function indicates to ARC that a new command is pending which completes
 * one write operation by the driver.
 *
 * returns  - E1000_SUCCESS for success.
 ****************************************************************************/
STATIC int32_t
em_mng_write_commit(struct em_hw * hw)
{
    uint32_t hicr;

    hicr = E1000_READ_REG(hw, HICR);
    /* Setting this bit tells the ARC that a new command is pending. */
    E1000_WRITE_REG(hw, HICR, hicr | E1000_HICR_C);

    return E1000_SUCCESS;
}


/*****************************************************************************
a6996 31

/*****************************************************************************
 * This function writes the dhcp info .
 ****************************************************************************/
int32_t
em_mng_write_dhcp_info(struct em_hw * hw, uint8_t *buffer,
                          uint16_t length)
{
    int32_t ret_val;
    struct em_host_mng_command_header hdr;

    hdr.command_id = E1000_MNG_DHCP_TX_PAYLOAD_CMD;
    hdr.command_length = length;
    hdr.reserved1 = 0;
    hdr.reserved2 = 0;
    hdr.checksum = 0;

    ret_val = em_mng_enable_host_if(hw);
    if (ret_val == E1000_SUCCESS) {
        ret_val = em_mng_host_if_write(hw, buffer, length, sizeof(hdr),
                                          &(hdr.checksum));
        if (ret_val == E1000_SUCCESS) {
            ret_val = em_mng_write_cmd_header(hw, &hdr);
            if (ret_val == E1000_SUCCESS)
                ret_val = em_mng_write_commit(hw);
        }
    }
    return ret_val;
}


a7055 34
/******************************************************************************
 * Verifies the hardware needs to allow ARPs to be processed by the host
 *
 * hw - Struct containing variables accessed by shared code
 *
 * returns: - TRUE/FALSE
 *
 *****************************************************************************/
uint32_t
em_enable_mng_pass_thru(struct em_hw *hw)
{
    uint32_t manc;
    uint32_t fwsm, factps;

    if (hw->asf_firmware_present) {
        manc = E1000_READ_REG(hw, MANC);

        if (!(manc & E1000_MANC_RCV_TCO_EN) ||
            !(manc & E1000_MANC_EN_MAC_ADDR_FILTER))
            return FALSE;
        if (em_arc_subsystem_valid(hw) == TRUE) {
            fwsm = E1000_READ_REG(hw, FWSM);
            factps = E1000_READ_REG(hw, FACTPS);

            if (((fwsm & E1000_FWSM_MODE_MASK) ==
                (em_mng_mode_pt << E1000_FWSM_MODE_SHIFT)) &&
                (factps & E1000_FACTPS_MNGCG))
                return TRUE;
        } else
            if ((manc & E1000_MANC_SMBUS_EN) && !(manc & E1000_MANC_ASF_EN))
                return TRUE;
    }
    return FALSE;
}
a7467 28

STATIC uint8_t
em_arc_subsystem_valid(struct em_hw *hw)
{
    uint32_t fwsm;

    /* On 8257x silicon, registers in the range of 0x8800 - 0x8FFC
     * may not be provided a DMA clock when no manageability features are
     * enabled.  We do not want to perform any reads/writes to these registers
     * if this is the case.  We read FWSM to determine the manageability mode.
     */
    switch (hw->mac_type) {
    case em_82571:
    case em_82572:
    case em_82573:
    case em_80003es2lan:
        fwsm = E1000_READ_REG(hw, FWSM);
        if ((fwsm & E1000_FWSM_MODE_MASK) != 0)
            return TRUE;
        break;
    case em_ich8lan:
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

@


1.24
log
@Sync up to Intel's latest FreeBSD em driver (6.2.9). Adds support
for a few newer Intel PCIe boards, some code removal and cleaning
and a few bug fixes.

From: Jack Vogel@@Intel

Tested by mk@@ wilfried@@ brad@@ dlg@@, Marc Winiger, Gabriel Kihlman,
Jason Dixon, Johan Mson Lindman, and a few other end users.

Tested with 82543, 82544, 82540, 82545, 82541, 82547, 82546 and 82573.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.23 2006/11/03 06:39:10 brad Exp $ */
d430 1
@


1.23
log
@the 8257E KCS PCI id is not the MAC but an IPMI interface being provided
from the chipset, so remove it.
@
text
@d3 28
a30 28
Copyright (c) 2001-2005, Intel Corporation 
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the Intel Corporation nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.22 2006/08/09 04:44:06 brad Exp $ */
d44 1
a44 1
 
d67 1
a67 1
 
d74 58
d200 1
a200 1
int32_t
d430 1
d458 2
d714 2
a715 4
        case em_82571:
        case em_82572:
        case em_ich8lan:
        case em_80003es2lan:
a717 1
                /* We don't want to continue accessing MAC registers. */
a719 4
        default:
            /* Wait for EEPROM reload (it happens automatically) */
            msec_delay(5);
            break;
d762 104
d892 8
a899 8
    if (hw->mac_type == em_ich8lan) {
        reg_data = E1000_READ_REG(hw, TARC0);
        reg_data |= 0x30000000;
        E1000_WRITE_REG(hw, TARC0, reg_data);

        reg_data = E1000_READ_REG(hw, STATUS);
        reg_data &= ~0x80000000;
        E1000_WRITE_REG(hw, STATUS, reg_data);
d912 3
a1005 11
        switch (hw->mac_type) {
        default:
            break;
        case em_82571:
        case em_82572:
        case em_82573:
        case em_ich8lan:
        case em_80003es2lan:
            ctrl |= E1000_TXDCTL_COUNT_DESC;
            break;
        }
a1042 2
        if (hw->mac_type >= em_82571)
            ctrl |= E1000_TXDCTL_COUNT_DESC;
d1150 1
a1150 1
    if (hw->fc == em_fc_default) {
d1154 1
a1154 1
            hw->fc = em_fc_full;
d1164 1
a1164 1
                hw->fc = em_fc_none;
d1167 1
a1167 1
                hw->fc = em_fc_tx_pause;
d1169 1
a1169 1
                hw->fc = em_fc_full;
d1179 1
a1179 1
        hw->fc &= (~em_fc_tx_pause);
d1182 1
a1182 1
        hw->fc &= (~em_fc_rx_pause);
d1234 1
a1234 1
    if (!(hw->fc & em_fc_tx_pause)) {
d1281 1
a1281 1
    /* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be
d1284 2
a1285 2
     * If we're on serdes media, adjust the output amplitude to value set in
     * the EEPROM.
d1321 1
a1321 1
    case em_fc_none:
d1325 1
a1325 1
    case em_fc_rx_pause:
d1334 1
a1334 1
    case em_fc_tx_pause:
d1340 1
a1340 1
    case em_fc_full:
d2257 1
a2257 1
    case em_fc_none: /* 0 */
d2263 1
a2263 1
    case em_fc_rx_pause: /* 1 */
d2275 1
a2275 1
    case em_fc_tx_pause: /* 2 */
d2282 1
a2282 1
    case em_fc_full: /* 3 */
d2326 1
a2326 1
    hw->fc = em_fc_none;
d2680 1
a2680 1
    case em_fc_none:
d2683 1
a2683 1
    case em_fc_rx_pause:
d2687 1
a2687 1
    case em_fc_tx_pause:
d2691 1
a2691 1
    case em_fc_full:
d2718 1
a2718 1
int32_t
d2820 2
a2821 2
                if (hw->original_fc == em_fc_full) {
                    hw->fc = em_fc_full;
d2824 1
a2824 1
                    hw->fc = em_fc_rx_pause;
d2840 1
a2840 1
                hw->fc = em_fc_tx_pause;
d2855 1
a2855 1
                hw->fc = em_fc_rx_pause;
d2878 2
a2879 2
            else if ((hw->original_fc == em_fc_none ||
                      hw->original_fc == em_fc_tx_pause) ||
d2881 1
a2881 1
                hw->fc = em_fc_none;
d2884 1
a2884 1
                hw->fc = em_fc_rx_pause;
d2899 1
a2899 1
                hw->fc = em_fc_none;
d3241 1
a3241 1
int32_t
d3411 1
a3411 1
int32_t
d3455 1
a3455 1
void
d3550 2
a3551 3
int32_t
em_read_phy_reg_ex(struct em_hw *hw,
                      uint32_t reg_addr,
d3631 1
a3631 2
em_write_phy_reg(struct em_hw *hw,
                    uint32_t reg_addr,
d3688 3
a3690 4
int32_t
em_write_phy_reg_ex(struct em_hw *hw,
                    uint32_t reg_addr,
                    uint16_t phy_data)
d3750 1
a3750 1
int32_t
d3783 1
a3783 1
int32_t
d3841 1
a3841 1
            em_release_software_semaphore(hw);
d3922 5
a3926 5
    switch (hw->mac_type) {
    case em_82541_rev_2:
    case em_82571:
    case em_82572:
    case em_ich8lan:
a3929 1

d3978 1
a3978 1
        /* Write VR power-down enable */
d3980 3
a3982 2
        em_write_phy_reg(hw, IGP3_VR_CTRL, phy_data |
                            IGP3_VR_CTRL_MODE_SHUT);
d3986 1
a3986 1
        if ((phy_data & IGP3_VR_CTRL_MODE_SHUT) || retry)
d4013 1
a4013 1
int32_t
d4066 1
a4066 1
int32_t
d4075 3
d4189 1
a4189 1
int32_t
d4194 2
a4195 1
    uint16_t phy_data, polarity, min_length, max_length, average;
d4220 2
a4221 2
    phy_info->mdix_mode = (phy_data & IGP01E1000_PSSR_MDIX) >>
                          IGP01E1000_PSSR_MDIX_SHIFT;
d4230 6
a4235 4
        phy_info->local_rx = (phy_data & SR_1000T_LOCAL_RX_STATUS) >>
                             SR_1000T_LOCAL_RX_STATUS_SHIFT;
        phy_info->remote_rx = (phy_data & SR_1000T_REMOTE_RX_STATUS) >>
                              SR_1000T_REMOTE_RX_STATUS_SHIFT;
d4266 1
a4266 1
int32_t
d4271 2
a4272 1
    uint16_t phy_data, polarity;
d4283 3
a4285 2
                        (phy_data & IFE_PSC_AUTO_POLARITY_DISABLE) >>
                        IFE_PSC_AUTO_POLARITY_DISABLE_SHIFT;
d4293 3
a4295 2
        polarity = (phy_data & IFE_PSC_FORCE_POLARITY) >>
                       IFE_PSC_FORCE_POLARITY_SHIFT;
d4303 3
a4305 3
    phy_info->mdix_mode =
                     (phy_data & (IFE_PMC_AUTO_MDIX | IFE_PMC_FORCE_MDIX)) >>
                     IFE_PMC_MDIX_MODE_SHIFT;
d4316 1
a4316 1
int32_t
d4321 2
a4322 1
    uint16_t phy_data, polarity;
d4335 4
a4338 2
        (phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
        M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT;
d4340 3
a4342 2
        (phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>
        M88E1000_PSCR_POLARITY_REVERSAL_SHIFT;
d4354 2
a4355 2
    phy_info->mdix_mode = (phy_data & M88E1000_PSSR_MDIX) >>
                          M88E1000_PSSR_MDIX_SHIFT;
d4362 1
a4362 1
            phy_info->cable_length = ((phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
d4370 1
a4370 1
            phy_info->cable_length = phy_data & GG82563_DSPD_CABLE_LENGTH;
d4377 6
a4382 5
        phy_info->local_rx = (phy_data & SR_1000T_LOCAL_RX_STATUS) >>
                             SR_1000T_LOCAL_RX_STATUS_SHIFT;

        phy_info->remote_rx = (phy_data & SR_1000T_REMOTE_RX_STATUS) >>
                              SR_1000T_REMOTE_RX_STATUS_SHIFT;
d4587 1
a4587 1
        uint32_t flash_size = E1000_READ_ICH8_REG(hw, ICH8_FLASH_GFPREG);
d4603 7
a4609 2
        hw->flash_base_addr = (flash_size & ICH8_GFPREG_BASE_MASK) *
                              ICH8_FLASH_SECTOR_SIZE;
a4610 3
        hw->flash_bank_size = ((flash_size >> 16) & ICH8_GFPREG_BASE_MASK) + 1;
        hw->flash_bank_size -= (flash_size & ICH8_GFPREG_BASE_MASK);
        hw->flash_bank_size *= ICH8_FLASH_SECTOR_SIZE;
d4946 1
a4946 1
int32_t
a4999 1
    int32_t ret_val;
d5003 4
d5012 1
a5012 1
        DEBUGOUT("\"words\" parameter out of bounds\n");
d5016 4
a5019 1
    /* FLASH reads without acquiring the semaphore are safe */
d5022 3
a5024 9
        switch (hw->mac_type) {
        case em_80003es2lan:
            break;
        default:
            /* Prepare the EEPROM for reading  */
            if (em_acquire_eeprom(hw) != E1000_SUCCESS)
                return -E1000_ERR_EEPROM;
            break;
        }
d5027 3
a5029 7
    if (eeprom->use_eerd == TRUE) {
        ret_val = em_read_eeprom_eerd(hw, offset, words, data);
        if ((em_is_onboard_nvm_eeprom(hw) == TRUE) ||
            (hw->mac_type != em_82573))
            em_release_eeprom(hw);
        return ret_val;
    }
d5031 1
d5035 2
d5094 1
a5094 1
int32_t
d5128 1
a5128 1
int32_t
d5169 1
a5169 1
int32_t
d5197 1
a5197 1
boolean_t
d5351 4
d5397 1
a5397 1
int32_t
d5463 1
a5463 1
int32_t
d5550 1
a5550 1
int32_t
a5559 1
    uint32_t sector_retries = 0;
a5561 1
    uint8_t temp_byte = 0;
d5614 16
a5629 18
        do {
            sector_write_failed = FALSE;
            /* Loop for every byte in the shadow RAM,
             * which is in units of words. */
            for (i = 0; i < E1000_SHADOW_RAM_WORDS; i++) {
                /* Determine whether to write the value stored
                 * in the other NVM bank or a modified value stored
                 * in the shadow RAM */
                if (hw->eeprom_shadow_ram[i].modified == TRUE) {
                    low_byte = (uint8_t)hw->eeprom_shadow_ram[i].eeprom_word;
                    em_read_ich8_byte(hw, (i << 1) + old_bank_offset,
                                         &temp_byte);
                    usec_delay(100);
                    error = em_verify_write_ich8_byte(hw,
                                                 (i << 1) + new_bank_offset,
                                                 low_byte);
                    if (error != E1000_SUCCESS)
                        sector_write_failed = TRUE;
a5631 2
                    em_read_ich8_byte(hw, (i << 1) + old_bank_offset + 1,
                                         &temp_byte);
d5633 11
a5643 8
                } else {
                    em_read_ich8_byte(hw, (i << 1) + old_bank_offset,
                                         &low_byte);
                    usec_delay(100);
                    error = em_verify_write_ich8_byte(hw,
                                 (i << 1) + new_bank_offset, low_byte);
                    if (error != E1000_SUCCESS)
                        sector_write_failed = TRUE;
d5646 1
d5648 1
d5650 4
d5660 2
a5661 2
                if (i == E1000_ICH8_NVM_SIG_WORD)
                    high_byte = E1000_ICH8_NVM_SIG_MASK | high_byte;
d5664 1
a5664 1
                             (i << 1) + new_bank_offset + 1, high_byte);
d5668 4
a5671 5
                if (sector_write_failed == FALSE) {
                    /* Clear the now not used entry in the cache */
                    hw->eeprom_shadow_ram[i].modified = FALSE;
                    hw->eeprom_shadow_ram[i].eeprom_word = 0xFFFF;
                }
d5673 1
d5675 18
a5692 11
            /* Don't bother writing the segment valid bits if sector
             * programming failed. */
            if (sector_write_failed == FALSE) {
                /* Finally validate the new segment by setting bit 15:14
                 * to 10b in word 0x13 , this can be done without an
                 * erase as well since these bits are 11 to start with
                 * and we need to change bit 14 to 0b */
                em_read_ich8_byte(hw,
                    E1000_ICH8_NVM_SIG_WORD * 2 + 1 + new_bank_offset,
                    &high_byte);
                high_byte &= 0xBF;
d5694 2
a5695 4
                            E1000_ICH8_NVM_SIG_WORD * 2 + 1 + new_bank_offset,
                            high_byte);
                if (error != E1000_SUCCESS)
                    sector_write_failed = TRUE;
d5697 4
a5700 9
                /* And invalidate the previously valid segment by setting
                 * its signature word (0x13) high_byte to 0b. This can be
                 * done without an erase because flash erase sets all bits
                 * to 1's. We can write 1's to 0's without an erase */
                error = em_verify_write_ich8_byte(hw,
                            E1000_ICH8_NVM_SIG_WORD * 2 + 1 + old_bank_offset,
                            0);
                if (error != E1000_SUCCESS)
                    sector_write_failed = TRUE;
d5702 1
a5702 1
        } while (++sector_retries < 10 && sector_write_failed == TRUE);
d5792 1
a5792 1
void
d5861 1
d5880 1
d6008 1
d6123 1
a6123 1
void
d6157 1
a6157 1
int32_t
d6194 1
d6727 2
d6738 1
d6741 1
d6744 8
a6751 1
        hw->bus_width = em_bus_width_pciex_1;
a6752 1
    case em_82571:
a6753 1
    case em_80003es2lan:
d6756 1
a6756 1
        hw->bus_width = em_bus_width_pciex_4;
a6789 17
/******************************************************************************
 * Reads a value from one of the devices registers using port I/O (as opposed
 * memory mapped I/O). Only 82544 and newer devices support port I/O.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset to read from
 *****************************************************************************/
uint32_t
em_read_reg_io(struct em_hw *hw,
                  uint32_t offset)
{
    unsigned long io_addr = hw->io_base;
    unsigned long io_data = hw->io_base + 4;

    em_io_write(hw, io_addr, offset);
    return em_io_read(hw, io_data);
}
d6799 1
a6799 1
void
a6810 1

d6826 1
a6826 1
int32_t
d7017 1
a7017 1
int32_t
d7019 1
a7019 1
                     uint16_t *polarity)
d7033 4
a7036 2
        *polarity = (phy_data & M88E1000_PSSR_REV_POLARITY) >>
                    M88E1000_PSSR_REV_POLARITY_SHIFT;
d7058 2
a7059 1
            *polarity = (phy_data & IGP01E1000_PHY_POLARITY_MASK) ? 1 : 0;
d7063 2
a7064 1
            *polarity = phy_data & IGP01E1000_PSSR_POLARITY_REVERSED;
d7071 3
a7073 2
        *polarity = (phy_data & IFE_PESC_POLARITY_REVERSED) >>
                           IFE_PESC_POLARITY_REVERSED_SHIFT;
d7093 1
a7093 1
int32_t
d7139 1
a7139 1
int32_t
d7372 1
a7372 1
int32_t
d7441 1
a7441 1
	    if (ret_val)
d7502 1
a7502 1
int32_t
d7551 1
a7551 1
	    if (ret_val)
d7657 1
a7657 1
int32_t
d7684 1
a7684 1
int32_t
d7718 1
a7718 1
int32_t
d7786 1
a7786 1
int32_t
d7826 1
a7826 1
int32_t
d7868 1
a7868 1
			  uint16_t length)
d7898 1
a7898 1
uint8_t
d8081 1
a8081 1
void
a8095 24
/***************************************************************************
 *
 * Enables PCI-Express master access.
 *
 * hw: Struct containing variables accessed by shared code
 *
 * returns: - none.
 *
 ***************************************************************************/
void
em_enable_pciex_master(struct em_hw *hw)
{
    uint32_t ctrl;

    DEBUGFUNC("em_enable_pciex_master");

    if (hw->bus_type != em_bus_type_pci_express)
        return;

    ctrl = E1000_READ_REG(hw, CTRL);
    ctrl &= ~E1000_CTRL_GIO_MASTER_DISABLE;
    E1000_WRITE_REG(hw, CTRL, ctrl);
}

d8145 1
a8145 1
int32_t
d8193 1
a8193 1
int32_t
a8218 1

d8240 1
a8240 1
int32_t
d8290 1
a8290 1
void
d8319 1
a8319 1
int32_t
d8354 1
a8354 1
void
d8396 1
a8396 1
	    E1000_BLK_PHY_RESET : E1000_SUCCESS;
d8399 1
a8399 1
uint8_t
d8436 1
a8436 1
int32_t
d8477 1
a8477 1
int32_t
d8516 1
a8516 1
void
a8531 55
/***************************************************************************
 *
 * Disable dynamic power down mode in ife PHY.
 * It can be used to workaround band-gap problem.
 *
 * hw: Struct containing variables accessed by shared code
 *
 ***************************************************************************/
int32_t
em_ife_disable_dynamic_power_down(struct em_hw *hw)
{
    uint16_t phy_data;
    int32_t ret_val = E1000_SUCCESS;

    DEBUGFUNC("em_ife_disable_dynamic_power_down");

    if (hw->phy_type == em_phy_ife) {
        ret_val = em_read_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data |=  IFE_PSC_DISABLE_DYNAMIC_POWER_DOWN;
        ret_val = em_write_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL, phy_data);
    }

    return ret_val;
}

/***************************************************************************
 *
 * Enable dynamic power down mode in ife PHY.
 * It can be used to workaround band-gap problem.
 *
 * hw: Struct containing variables accessed by shared code
 *
 ***************************************************************************/
int32_t
em_ife_enable_dynamic_power_down(struct em_hw *hw)
{
    uint16_t phy_data;
    int32_t ret_val = E1000_SUCCESS;

    DEBUGFUNC("em_ife_enable_dynamic_power_down");

    if (hw->phy_type == em_phy_ife) {
        ret_val = em_read_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data &=  ~IFE_PSC_DISABLE_DYNAMIC_POWER_DOWN;
        ret_val = em_write_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL, phy_data);
    }

    return ret_val;
}
d8542 1
a8542 1
int32_t
d8598 1
a8598 1
int32_t
d8645 1
a8645 1
int32_t
d8654 1
a8654 1
    hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
d8667 1
a8667 1
    E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFSTS, hsfsts.regval);
d8682 1
a8682 1
        E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFSTS, hsfsts.regval);
d8687 2
a8688 2
        for (i = 0; i < ICH8_FLASH_COMMAND_TIMEOUT; i++) {
            hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
d8699 1
a8699 1
            E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFSTS, hsfsts.regval);
d8712 1
a8712 1
int32_t
d8721 1
a8721 1
    hsflctl.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFCTL);
d8723 1
a8723 1
    E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFCTL, hsflctl.regval);
d8727 1
a8727 1
        hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
d8747 1
a8747 1
int32_t
d8761 1
a8761 1
        index > ICH8_FLASH_LINEAR_ADDR_MASK)
d8764 1
a8764 1
    flash_linear_address = (ICH8_FLASH_LINEAR_ADDR_MASK & index) +
d8774 1
a8774 1
        hsflctl.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFCTL);
d8777 2
a8778 2
        hsflctl.hsf_ctrl.flcycle = ICH8_CYCLE_READ;
        E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFCTL, hsflctl.regval);
d8784 1
a8784 1
        E1000_WRITE_ICH8_REG(hw, ICH8_FLASH_FADDR, flash_linear_address);
d8786 1
a8786 1
        error = em_ich8_flash_cycle(hw, ICH8_FLASH_COMMAND_TIMEOUT);
d8792 1
a8792 1
            flash_data = E1000_READ_ICH8_REG(hw, ICH8_FLASH_FDATA0);
d8802 1
a8802 1
             * it another try...ICH8_FLASH_CYCLE_REPEAT_COUNT times.
d8804 1
a8804 1
            hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
d8813 1
a8813 1
    } while (count++ < ICH8_FLASH_CYCLE_REPEAT_COUNT);
d8826 1
a8826 1
int32_t
d8840 1
a8840 1
        index > ICH8_FLASH_LINEAR_ADDR_MASK)
d8843 1
a8843 1
    flash_linear_address = (ICH8_FLASH_LINEAR_ADDR_MASK & index) +
d8853 1
a8853 1
        hsflctl.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFCTL);
d8856 2
a8857 2
        hsflctl.hsf_ctrl.flcycle = ICH8_CYCLE_WRITE;
        E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFCTL, hsflctl.regval);
d8861 1
a8861 1
        E1000_WRITE_ICH8_REG(hw, ICH8_FLASH_FADDR, flash_linear_address);
d8868 1
a8868 1
        E1000_WRITE_ICH8_REG(hw, ICH8_FLASH_FDATA0, flash_data);
d8872 1
a8872 1
        error = em_ich8_flash_cycle(hw, ICH8_FLASH_COMMAND_TIMEOUT);
d8878 1
a8878 1
             * it another try...ICH8_FLASH_CYCLE_REPEAT_COUNT times.
d8880 1
a8880 1
            hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
d8889 1
a8889 1
    } while (count++ < ICH8_FLASH_CYCLE_REPEAT_COUNT);
d8901 1
a8901 1
int32_t
d8924 1
a8924 1
int32_t
d8928 3
a8930 2
    int32_t program_retries;
    uint8_t temp_byte;
d8932 1
a8932 2
    em_write_ich8_byte(hw, index, byte);
    usec_delay(100);
d8934 8
a8941 7
    for (program_retries = 0; program_retries < 100; program_retries++) {
        em_read_ich8_byte(hw, index, &temp_byte);
        if (temp_byte == byte)
            break;
        usec_delay(10);
        em_write_ich8_byte(hw, index, byte);
        usec_delay(100);
d8943 1
d8957 1
a8957 1
int32_t
d8975 1
a8975 1
int32_t
d8983 1
d8985 2
a8986 1
 * Writes a word to the NVM using the ICH8 flash access registers.
d8989 1
a8989 14
 * index - The starting byte index of the word to read.
 * data - The word to write to the NVM.
 *****************************************************************************/
int32_t
em_write_ich8_word(struct em_hw *hw, uint32_t index, uint16_t data)
{
    int32_t status = E1000_SUCCESS;
    status = em_write_ich8_data(hw, index, 2, data);
    return status;
}

/******************************************************************************
 * Erases the bank specified. Each bank is a 4k block. Segments are 0 based.
 * segment N is 4096 * N + flash_reg_addr.
d8991 3
a8993 2
 * hw - pointer to em_hw structure
 * segment - 0 for first segment, 1 for second segment, etc.
d8996 1
a8996 1
em_erase_ich8_4k_segment(struct em_hw *hw, uint32_t segment)
d9003 3
a9005 2
    int32_t  iteration, seg_size;
    int32_t  sector_size;
d9009 1
a9009 1
    hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
d9014 1
a9014 1
     *     calculated as = segment * 4096 + n * 256
d9017 3
a9019 4
     *     as = segment * 4096
     * 10: Error condition
     * 11: The Hw sector size is much bigger than the size asked to
     *     erase...error condition */
d9022 3
a9024 2
        sector_size = seg_size = ICH8_FLASH_SEG_SIZE_256;
        iteration = ICH8_FLASH_SECTOR_SIZE / ICH8_FLASH_SEG_SIZE_256;
d9026 1
a9026 1
        sector_size = seg_size = ICH8_FLASH_SEG_SIZE_4K;
d9029 1
a9029 1
        sector_size = seg_size = ICH8_FLASH_SEG_SIZE_64K;
d9047 3
a9049 3
            hsflctl.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFCTL);
            hsflctl.hsf_ctrl.flcycle = ICH8_CYCLE_ERASE;
            E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFCTL, hsflctl.regval);
d9053 3
a9055 5
             * be calculated here based off the on-chip segment size and the
             * software segment size assumed (4K) */
            /* TBD */
            flash_linear_address = segment * sector_size + j * seg_size;
            flash_linear_address &= ICH8_FLASH_LINEAR_ADDR_MASK;
d9057 1
d9059 1
a9059 1
            E1000_WRITE_ICH8_REG(hw, ICH8_FLASH_FADDR, flash_linear_address);
d9061 1
a9061 1
            error = em_ich8_flash_cycle(hw, 1000000);
d9067 1
a9067 1
                hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
d9076 1
a9076 1
        } while ((count < ICH8_FLASH_CYCLE_REPEAT_COUNT) && !error_flag);
a9084 25
/******************************************************************************
 *
 * Reverse duplex setting without breaking the link.
 *
 * hw: Struct containing variables accessed by shared code
 *
 *****************************************************************************/
int32_t
em_duplex_reversal(struct em_hw *hw)
{
    int32_t ret_val;
    uint16_t phy_data;

    if (hw->phy_type != em_phy_igp_3)
        return E1000_SUCCESS;

    ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data);
    if (ret_val)
        return ret_val;

    phy_data ^= MII_CR_FULL_DUPLEX;

    ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data);
    if (ret_val)
        return ret_val;
d9086 1
a9086 11
    ret_val = em_read_phy_reg(hw, IGP3E1000_PHY_MISC_CTRL, &phy_data);
    if (ret_val)
        return ret_val;

    phy_data |= IGP3_PHY_MISC_DUPLEX_MANUAL_SET;
    ret_val = em_write_phy_reg(hw, IGP3E1000_PHY_MISC_CTRL, phy_data);

    return ret_val;
}

int32_t
d9127 1
a9127 1
int32_t
@


1.22
log
@Sync up to Intel's latest FreeBSD em driver (6.1.4). Adds PCI id for the PCIe
quad port copper adapter, improvements for media support with fiber adapters,
and some fixes for the ICH8 support.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.21 2006/07/07 02:56:18 brad Exp $ */
a381 1
    case E1000_DEV_ID_82573E_KCS:
@


1.21
log
@Sync up to Intel's latest FreeBSD em driver (6.0.5). Adds support
for new chipset revisions embedded in the ESB2 and ICH8 core logic
chipsets.

The previous attempt at commiting this included an unrelated change
to how the I/O base address was being set and this was the cause of
the breakage.

From: Intel's web-site
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.20 2006/07/05 01:15:30 brad Exp $ */
d371 1
d735 10
d913 1
a913 1
    /* ICH8/Nahum No-snoop bits are opposite polarity.
d1349 8
a1356 5
    /* disable lplu d3 during driver init */
    ret_val = em_set_d3_lplu_state(hw, FALSE);
    if (ret_val) {
        DEBUGOUT("Error Disabling LPLU D3\n");
        return ret_val;
a1779 13
/********************************************************************
* Copper link setup for em_phy_ife (Fast Ethernet PHY) series.
*
* hw - Struct containing variables accessed by shared code
*********************************************************************/
static int32_t
em_copper_link_ife_setup(struct em_hw *hw)
{
    if (hw->phy_reset_disable)
        return E1000_SUCCESS;
    return E1000_SUCCESS;
}

a1892 4
    } else if (hw->phy_type == em_phy_ife) {
        ret_val = em_copper_link_ife_setup(hw);
        if (ret_val)
            return ret_val;
d3747 2
d3751 3
a3753 6
        if ((hw->mac_type == em_ich8lan) &&
            (hw->phy_type == em_phy_igp_3)) {
            ret_val = em_init_lcd_from_nvm(hw);
            if (ret_val)
                return ret_val;
        }
d3880 2
a3881 2
    /* Make sure link is up before proceeding. If not just return. 
     * Attempting this while link is negotiating fouls up link
d9076 8
@


1.20
log
@revert back to the older driver as this causes some breakage.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.18 2006/05/17 20:45:52 brad Exp $ */
d44 1
a44 1

d67 1
a67 1

d110 3
a112 2
static int32_t em_configure_kmrn_for_10_100(struct em_hw *hw, uint16_t duplex);
static int32_t em_configure_kmrn_for_1000(struct em_hw *hw, uint16_t duplex);
d147 1
a147 1
    if(hw->mac_type == em_undefined)
d150 1
a150 1
    switch(hw->phy_id) {
d158 4
a161 4
        if(hw->mac_type == em_82541 ||
           hw->mac_type == em_82541_rev_2 ||
           hw->mac_type == em_82547 ||
           hw->mac_type == em_82547_rev_2) {
d165 8
d201 1
a201 1
    if(hw->phy_init_script) {
d217 1
a217 1
        switch(hw->mac_type) {
d254 1
a254 1
        if(hw->mac_type == em_82547) {
d260 1
a260 1
            if(!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
d266 1
a266 1
                if(coarse > IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {
d269 1
a269 1
                } else if(coarse == IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
d349 1
a350 1
    case E1000_DEV_ID_82541EI_MOBILE:
d389 2
d395 7
d407 5
a411 1
    switch(hw->mac_type) {
d445 1
a445 1
    if(hw->mac_type != em_82543) {
d464 1
d505 1
a505 1
    if(hw->mac_type == em_82542_rev2_0) {
d510 1
a510 1
    if(hw->bus_type == em_bus_type_pci_express) {
d514 1
a514 1
        if(em_disable_pciex_master(hw) != E1000_SUCCESS) {
d542 1
a542 1
    if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
d549 1
a549 1
    if(hw->mac_type == em_82573) {
d559 1
a559 1
            if(extcnf_ctrl & E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP)
d566 9
a574 1
        } while(timeout);
d584 1
a584 1
    switch(hw->mac_type) {
d600 14
d623 1
a623 1
    switch(hw->mac_type) {
d655 1
d658 1
a658 1
            if(ret_val)
d669 1
a669 1
    if(hw->mac_type >= em_82540 && hw->mac_type <= em_82547_rev_2) {
d675 1
a675 1
    if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
d693 2
a694 2
    if(hw->mac_type == em_82542_rev2_0) {
        if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
d698 6
d736 1
a736 1
    if(ret_val) {
d746 6
a751 3
    if (hw->mac_type < em_82545_rev_3)
        E1000_WRITE_REG(hw, VET, 0);
    em_clear_vfta(hw);
d754 1
a754 1
    if(hw->mac_type == em_82542_rev2_0) {
d768 1
a768 1
    if(hw->mac_type == em_82542_rev2_0) {
d772 1
a772 1
        if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
d779 3
a781 1
    for(i = 0; i < mta_size; i++)
d783 4
d793 1
a793 1
    if(hw->dma_fairness && hw->mac_type <= em_82543) {
d798 1
a798 1
    switch(hw->mac_type) {
d804 1
a804 1
        if(hw->bus_type == em_bus_type_pcix) {
d812 1
a812 1
            if(stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
d814 1
a814 1
            if(cmd_mmrbc > stat_mmrbc) {
d824 4
d832 1
a832 1
    if(hw->mac_type > em_82544) {
d841 1
d850 1
a850 1
        em_enable_tx_pkt_filtering(hw); 
d880 1
d883 1
a883 1
        if(hw->mac_type >= em_82571)
d902 5
d932 1
a932 1
    if(hw->media_type != em_media_type_internal_serdes)
d935 1
a935 1
    switch(hw->mac_type) {
d948 1
a948 1
    if(eeprom_data != EEPROM_RESERVED_WORD) {
d950 1
a950 1
        eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK; 
d952 1
a952 1
        if(ret_val)
d994 1
d1020 1
a1020 1
    if(hw->mac_type == em_82542_rev2_0)
d1023 1
a1023 1
    if((hw->mac_type < em_82543) && (hw->report_tx_early == 1))
d1037 7
a1043 1
    if(hw->mac_type == em_82543) {
d1061 6
a1066 3
    E1000_WRITE_REG(hw, FCAL, FLOW_CONTROL_ADDRESS_LOW);
    E1000_WRITE_REG(hw, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
    E1000_WRITE_REG(hw, FCT, FLOW_CONTROL_TYPE);
d1076 1
a1076 1
    if(!(hw->fc & em_fc_tx_pause)) {
d1083 1
a1083 1
        if(hw->fc_send_xon) {
d1130 1
a1130 1
    if(hw->media_type == em_media_type_fiber)
d1134 1
a1134 1
    if(ret_val)
d1142 1
a1142 1
    if(ret_val)
d1213 1
a1213 1
    if(hw->media_type == em_media_type_internal_serdes ||
d1216 1
a1216 1
        for(i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
d1219 1
a1219 1
            if(status & E1000_STATUS_LU) break;
d1221 1
a1221 1
        if(i == (LINK_UP_TIMEOUT / 10)) {
d1230 1
a1230 1
            if(ret_val) {
d1264 1
a1264 1
    if(hw->mac_type > em_82543) {
d1272 1
a1272 1
        if(ret_val)
d1278 1
a1278 1
    if(ret_val) {
d1286 1
a1286 1
    if(ret_val)
d1289 1
a1289 1
    if((hw->mac_type == em_82545_rev_3) ||
d1296 3
a1298 3
    if(hw->mac_type <= em_82543 ||
       hw->mac_type == em_82541 || hw->mac_type == em_82547 ||
       hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2)
d1321 1
a1321 1
    
d1328 1
a1328 1
    /* Wait 10ms for MAC to configure PHY from eeprom settings */
d1330 1
a1330 1

d1336 1
d1380 1
a1380 1
    if(ret_val)
d1384 1
a1384 1
    if(hw->autoneg) {
d1387 1
a1387 1
        if(hw->ffe_config_state == em_ffe_config_active)
d1390 1
a1390 1
        if(hw->dsp_config_state == em_dsp_config_activated)
d1396 1
a1396 1
        if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
d1398 3
a1400 2
            ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, &phy_data);
            if(ret_val)
d1403 3
a1405 4
            ret_val = em_write_phy_reg(hw,
                                                  IGP01E1000_PHY_PORT_CONFIG,
                                                  phy_data);
            if(ret_val)
d1409 1
a1409 1
            if(ret_val)
d1413 1
a1413 1
            if(ret_val)
d1418 1
a1418 1
        if(ret_val)
d1443 1
a1443 1
        if(ret_val)
d1464 2
a1465 2
    if(!hw->phy_reset_disable) {
        
d1469 1
a1469 1
        if(ret_val)
d1478 1
a1478 1
        if(ret_val)
d1489 1
a1489 1
        if(ret_val)
d1514 1
a1514 1
        if(hw->disable_polarity_correction == 1)
d1518 1
a1518 1
        if(ret_val)
a1572 1
            /* Disable Pass False Carrier on the PHY */
a1573 1

d1576 1
d1611 1
a1611 1
    if(hw->phy_reset_disable)
d1613 1
a1613 1
    
d1616 1
a1616 1
    if(ret_val)
d1653 1
a1653 1
    if(hw->disable_polarity_correction == 1)
d1655 10
a1664 2
        ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
        if(ret_val)
d1667 1
a1667 6
    /* Force TX_CLK in the Extended PHY Specific Control Register
     * to 25MHz clock.
     */
    ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);
    if(ret_val)
        return ret_val;
d1669 12
a1680 5
    phy_data |= M88E1000_EPSCR_TX_CLK_25;

    if (hw->phy_revision < M88E1011_I_REV_4) {
        /* Configure Master and Slave downshift values */
        phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
d1682 1
a1682 1
        phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
d1684 5
a1688 3
        ret_val = em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
        if(ret_val)
            return ret_val;
d1693 1
a1693 1
    if(ret_val) {
d1723 1
a1723 1
    if(hw->autoneg_advertised == 0)
d1726 4
d1732 1
a1732 1
    if(ret_val) {
d1742 1
a1742 1
    if(ret_val)
d1747 1
a1747 1
    if(ret_val)
d1753 1
a1753 1
    if(hw->wait_autoneg_complete) {
d1755 1
a1755 1
        if(ret_val) {
d1766 12
d1787 1
a1787 1
*   3) Config DSP to improve Gigabit link quality for some PHY revisions.    
d1796 2
a1797 2
    
    if(hw->mac_type >= em_82544) {
d1801 1
a1801 1
        if(ret_val) {
d1807 1
a1807 1
    if(ret_val) {
d1813 1
a1813 1
    if(hw->phy_type == em_phy_igp) {
d1815 1
a1815 1
        if(ret_val) {
d1820 1
a1820 1
                
d1841 1
d1861 1
a1861 1
    if(ret_val)
d1866 2
a1867 4
        ret_val = em_read_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_INB_CTRL,
                                      &reg_data);
        if (ret_val)
            return ret_val;
d1879 1
d1882 1
a1882 1
        if(ret_val)
d1886 1
a1886 1
        if(ret_val)
d1890 5
a1894 1
        if(ret_val)
d1898 3
a1900 3
    if(hw->autoneg) {
        /* Setup autoneg and flow control advertisement 
          * and perform autonegotiation */   
d1902 2
a1903 2
        if(ret_val)
            return ret_val;           
d1909 1
a1909 1
        if(ret_val) {
d1918 1
a1918 1
    for(i = 0; i < 10; i++) {
d1920 1
a1920 1
        if(ret_val)
d1923 1
a1923 1
        if(ret_val)
d1926 1
a1926 1
        if(phy_data & MII_SR_LINK_STATUS) {
d1929 1
a1929 1
            if(ret_val)
d1931 1
a1931 1
            
d1968 2
a1969 2
    ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL,
                                 &reg_data);
a1972 1
    /* Enable pass false carrier when in half duplex mode. */
d1978 1
a1979 3
    ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL,
                                  reg_data);
    
d1984 1
a1984 1
em_configure_kmrn_for_1000(struct em_hw *hw, uint16_t duplex)
d2004 1
a2005 2
    ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL,
                                 &reg_data);
a2008 1
    /* Disable Pass False Carrier on the PHY */
d2010 1
a2011 3
    ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL,
                                  reg_data);
    
d2031 1
a2031 1
    if(ret_val)
d2034 7
a2040 4
    /* Read the MII 1000Base-T Control Register (Address 9). */
    ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);
    if(ret_val)
        return ret_val;
d2059 1
a2059 1
    if(hw->autoneg_advertised & ADVERTISE_10_HALF) {
d2065 1
a2065 1
    if(hw->autoneg_advertised & ADVERTISE_10_FULL) {
d2071 1
a2071 1
    if(hw->autoneg_advertised & ADVERTISE_100_HALF) {
d2077 1
a2077 1
    if(hw->autoneg_advertised & ADVERTISE_100_FULL) {
d2083 1
a2083 1
    if(hw->autoneg_advertised & ADVERTISE_1000_HALF) {
d2088 1
a2088 1
    if(hw->autoneg_advertised & ADVERTISE_1000_FULL) {
d2091 3
d2150 1
a2150 1
    if(ret_val)
d2155 5
a2159 3
    ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg);    
    if(ret_val)
        return ret_val;
d2198 1
a2198 1
    if(ret_val)
d2206 2
a2207 2
    if(hw->forced_speed_duplex == em_100_full ||
       hw->forced_speed_duplex == em_10_full) {
d2224 1
a2224 1
    if(hw->forced_speed_duplex == em_100_full ||
d2247 1
a2247 1
        if(ret_val)
d2255 1
a2255 1
        if(ret_val)
d2262 12
d2279 1
a2279 1
        if(ret_val)
d2286 1
a2286 1
        if(ret_val)
d2292 1
a2292 1
    if(ret_val)
d2304 1
a2304 1
    if(hw->wait_autoneg_complete) {
d2310 1
a2310 1
        for(i = PHY_FORCE_TIME; i > 0; i--) {
d2315 1
a2315 1
            if(ret_val)
d2319 1
a2319 1
            if(ret_val)
d2322 1
a2322 1
            if(mii_status_reg & MII_SR_LINK_STATUS) break;
d2325 1
a2325 1
        if((i == 0) &&
d2330 1
a2330 1
            if(ret_val) {
d2336 2
a2337 2
        for(i = PHY_FORCE_TIME; i > 0; i--) {
            if(mii_status_reg & MII_SR_LINK_STATUS) break;
d2343 1
a2343 1
            if(ret_val)
d2347 1
a2347 1
            if(ret_val)
d2358 1
a2358 1
        if(ret_val)
d2363 1
a2363 1
        if(ret_val)
d2370 1
a2370 1
        if(ret_val)
d2375 1
a2375 1
        if(ret_val)
d2378 3
a2380 4
        if((hw->mac_type == em_82544 || hw->mac_type == em_82543) &&
           (!hw->autoneg) &&
           (hw->forced_speed_duplex == em_10_full ||
            hw->forced_speed_duplex == em_10_half)) {
d2382 1
a2382 1
            if(ret_val)
d2457 1
a2457 1
    /* 82544 or newer MAC, Auto Speed Detection takes care of 
d2473 1
a2473 1
    if(ret_val)
d2476 1
a2476 1
    if(phy_data & M88E1000_PSSR_DPLX) 
d2478 1
a2478 1
    else 
d2486 1
a2486 1
    if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
d2488 1
a2488 1
    else if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
d2556 1
a2556 1
    if(hw->mac_type == em_82542_rev2_0)
d2590 4
a2593 3
    if(((hw->media_type == em_media_type_fiber) && (hw->autoneg_failed)) ||
       ((hw->media_type == em_media_type_internal_serdes) && (hw->autoneg_failed)) ||
       ((hw->media_type == em_media_type_copper) && (!hw->autoneg))) {
d2595 1
a2595 1
        if(ret_val) {
d2606 1
a2606 1
    if((hw->media_type == em_media_type_copper) && hw->autoneg) {
d2612 1
a2612 1
        if(ret_val)
d2615 1
a2615 1
        if(ret_val)
d2618 1
a2618 1
        if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
d2627 1
a2627 1
            if(ret_val)
d2631 1
a2631 1
            if(ret_val)
d2668 2
a2669 2
            if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
               (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {
d2676 1
a2676 1
                if(hw->original_fc == em_fc_full) {
d2692 4
a2695 4
            else if(!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
                    (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
                    (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
                    (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
d2707 4
a2710 4
            else if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
                    (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
                    !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
                    (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
d2734 3
a2736 3
            else if((hw->original_fc == em_fc_none ||
                     hw->original_fc == em_fc_tx_pause) ||
                    hw->fc_strict_ieee) {
d2749 1
a2749 1
            if(ret_val) {
d2754 1
a2754 1
            if(duplex == HALF_DUPLEX)
d2761 1
a2761 1
            if(ret_val) {
d2800 2
a2801 2
    if((hw->media_type == em_media_type_fiber) ||
       (hw->media_type == em_media_type_internal_serdes)) {
d2804 1
a2804 1
        if(hw->media_type == em_media_type_fiber) {
d2806 1
a2806 1
            if(status & E1000_STATUS_LU)
d2817 1
a2817 1
    if((hw->media_type == em_media_type_copper) && hw->get_link_status) {
d2824 1
a2824 1
        if(ret_val)
d2827 1
a2827 1
        if(ret_val)
d2830 1
a2830 1
        if(phy_data & MII_SR_LINK_STATUS) {
d2844 4
a2847 4
            if((hw->mac_type == em_82544 || hw->mac_type == em_82543) &&
               (!hw->autoneg) &&
               (hw->forced_speed_duplex == em_10_full ||
                hw->forced_speed_duplex == em_10_half)) {
d2864 1
a2864 1
        if(!hw->autoneg) return -E1000_ERR_CONFIG;
d2877 1
a2877 1
        if(hw->mac_type >= em_82544)
d2881 1
a2881 1
            if(ret_val) {
d2892 1
a2892 1
        if(ret_val) {
d2904 1
a2904 1
        if(hw->tbi_compatibility_en) {
d2906 6
a2911 2
            em_get_speed_and_duplex(hw, &speed, &duplex);
            if(speed != SPEED_1000) {
d2915 1
a2915 1
                if(hw->tbi_compatibility_on) {
d2928 1
a2928 1
                if(!hw->tbi_compatibility_on) {
d2944 1
a2944 1
    else if((((hw->media_type == em_media_type_fiber) &&
d2946 4
a2949 4
             (hw->media_type == em_media_type_internal_serdes)) &&
            (!(status & E1000_STATUS_LU)) &&
            (!(rxcw & E1000_RXCW_C))) {
        if(hw->autoneg_failed == 0) {
d2965 1
a2965 1
        if(ret_val) {
d2975 3
a2977 3
    else if(((hw->media_type == em_media_type_fiber) ||
             (hw->media_type == em_media_type_internal_serdes)) &&
            (ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {
d2987 2
a2988 2
    else if((hw->media_type == em_media_type_internal_serdes) &&
            !(E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
d2991 2
a2992 2
        if(E1000_RXCW_SYNCH & E1000_READ_REG(hw, RXCW)) {
            if(!(rxcw & E1000_RXCW_IV)) {
d3001 2
a3002 2
    if((hw->media_type == em_media_type_internal_serdes) &&
       (E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
d3026 1
a3026 1
    if(hw->mac_type >= em_82543) {
d3028 1
a3028 1
        if(status & E1000_STATUS_SPEED_1000) {
d3031 1
a3031 1
        } else if(status & E1000_STATUS_SPEED_100) {
d3039 1
a3039 1
        if(status & E1000_STATUS_FD) {
d3056 1
a3056 1
    if(hw->phy_type == em_phy_igp && hw->speed_downgraded) {
d3058 1
a3058 1
        if(ret_val)
d3061 1
a3061 1
        if(!(phy_data & NWAY_ER_LP_NWAY_CAPS))
d3065 1
a3065 1
            if(ret_val)
d3067 1
a3067 1
            if((*speed == SPEED_100 && !(phy_data & NWAY_LPAR_100TX_FD_CAPS)) ||
d3073 1
a3073 1
    if ((hw->mac_type == em_80003es2lan) && 
d3076 1
a3076 1
            ret_val = em_configure_kmrn_for_1000(hw, *duplex);
d3083 6
d3108 1
a3108 1
    for(i = PHY_AUTO_NEG_TIME; i > 0; i--) {
d3113 1
a3113 1
        if(ret_val)
d3116 1
a3116 1
        if(ret_val)
d3118 1
a3118 1
        if(phy_data & MII_SR_AUTONEG_COMPLETE) {
d3191 1
a3191 1
    while(mask) {
d3197 4
a3200 2
        if(data & mask) ctrl |= E1000_CTRL_MDIO;
        else ctrl &= ~E1000_CTRL_MDIO;
d3251 1
a3251 1
    for(data = 0, i = 0; i < 16; i++) {
d3256 2
a3257 1
        if(ctrl & E1000_CTRL_MDIO) data |= 1;
d3277 3
d3283 1
a3283 1
    while(timeout) {
d3319 5
d3366 2
a3367 1
    if((hw->phy_type == em_phy_igp || 
d3372 1
a3372 1
        if(ret_val) {
d3417 1
a3417 1
    if(reg_addr > MAX_PHY_REG_ADDRESS) {
d3422 1
a3422 1
    if(hw->mac_type > em_82543) {
d3434 1
a3434 1
        for(i = 0; i < 64; i++) {
d3437 1
a3437 1
            if(mdic & E1000_MDIC_READY) break;
d3439 1
a3439 1
        if(!(mdic & E1000_MDIC_READY)) {
d3443 1
a3443 1
        if(mdic & E1000_MDIC_ERROR) {
d3506 2
a3507 1
    if((hw->phy_type == em_phy_igp || 
d3512 1
a3512 1
        if(ret_val) {
d3557 1
a3557 1
    if(reg_addr > MAX_PHY_REG_ADDRESS) {
d3562 1
a3562 1
    if(hw->mac_type > em_82543) {
d3575 1
a3575 1
        for(i = 0; i < 641; i++) {
d3578 1
a3578 1
            if(mdic & E1000_MDIC_READY) break;
d3580 1
a3580 1
        if(!(mdic & E1000_MDIC_READY)) {
d3692 1
a3692 1
    if(hw->mac_type > em_82543) {
d3705 1
a3705 1
         * For pre-em_82571 hardware, we delay for 10ms between the assert 
d3712 2
a3713 2
        
        if (hw->mac_type < em_82571) 
d3717 1
a3717 1
        
d3720 1
a3720 1
        
d3722 1
a3722 1
            msec_delay(10);
d3740 1
a3740 1
    if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
d3752 6
d3786 1
d3788 1
a3788 1
        if(ret_val)
d3790 1
d3794 1
a3794 1
        if(ret_val)
d3799 1
a3799 1
        if(ret_val)
d3806 1
a3806 1
    if(hw->phy_type == em_phy_igp || hw->phy_type == em_phy_igp_2)
d3813 57
a3869 1
* Probes the expected PHY address for known PHY IDs
d3871 1
a3871 1
* hw - Struct containing variables accessed by shared code
d3874 1
a3874 1
em_detect_gig_phy(struct em_hw *hw)
d3876 4
a3879 5
    int32_t phy_init_status, ret_val;
    uint16_t phy_id_high, phy_id_low;
    boolean_t match = FALSE;

    DEBUGFUNC("em_detect_gig_phy");
d3881 1
a3881 7
    /* The 82571 firmware may still be configuring the PHY.  In this
     * case, we cannot access the PHY until the configuration is done.  So
     * we explicitly set the PHY values. */
    if(hw->mac_type == em_82571 ||
       hw->mac_type == em_82572) {
        hw->phy_id = IGP01E1000_I_PHY_ID;
        hw->phy_type = em_phy_igp_2;
a3882 1
    }
d3884 69
a3952 8
    /* ESB-2 PHY reads require em_phy_gg82563 to be set because of a work-
     * around that forces PHY page 0 to be set or the reads fail.  The rest of
     * the code in this routine uses em_read_phy_reg to read the PHY ID.
     * So for ESB-2 we need to have this set so our reads won't fail.  If the
     * attached PHY is not a em_phy_gg82563, the routines below will figure
     * this out as well. */
    if (hw->mac_type == em_80003es2lan)
        hw->phy_type = em_phy_gg82563;
d3956 1
a3956 1
    if(ret_val)
d3962 1
a3962 1
    if(ret_val)
d3968 1
a3968 1
    switch(hw->mac_type) {
d3970 1
a3970 1
        if(hw->phy_id == M88E1000_E_PHY_ID) match = TRUE;
d3973 1
a3973 1
        if(hw->phy_id == M88E1000_I_PHY_ID) match = TRUE;
d3980 1
a3980 1
        if(hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
d3986 1
a3986 1
        if(hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
d3989 1
a3989 1
        if(hw->phy_id == M88E1111_I_PHY_ID) match = TRUE;
d3994 6
d4028 1
a4028 1
            if(ret_val) break;
d4031 1
a4031 1
        if(ret_val) break;
d4033 1
a4033 1
        if(ret_val) break;
d4035 1
a4035 1
    } while(0);
d4067 1
a4067 1
    if(ret_val)
d4073 1
a4073 1
    if(ret_val)
d4079 1
a4079 1
    if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
d4083 1
a4083 1
        if(ret_val)
d4093 1
a4093 1
        if(ret_val)
d4099 1
a4099 1
        if(average <= em_igp_cable_length_50)
d4101 1
a4101 1
        else if(average <= em_igp_cable_length_80)
d4103 1
a4103 1
        else if(average <= em_igp_cable_length_110)
d4105 1
a4105 1
        else if(average <= em_igp_cable_length_140)
d4115 47
d4181 1
a4181 1
    if(ret_val)
d4193 2
a4194 2
    if(ret_val)
        return ret_val; 
d4198 1
a4198 1
    if(ret_val)
d4221 1
a4221 1
        if(ret_val)
d4258 1
a4258 1
    if(hw->media_type != em_media_type_copper) {
d4264 1
a4264 1
    if(ret_val)
d4268 1
a4268 1
    if(ret_val)
d4271 1
a4271 1
    if((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {
d4276 2
a4277 1
    if(hw->phy_type == em_phy_igp ||
d4280 2
d4291 1
a4291 1
    if(!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {
d4338 1
a4338 1
        if(eecd & E1000_EECD_SIZE) {
d4406 1
a4406 1
        if(em_is_onboard_nvm_eeprom(hw) == FALSE) {
d4430 29
d4467 1
a4467 1
        if(hw->mac_type <= em_82547_rev_2) {
d4471 1
a4471 1
            if(ret_val)
d4477 1
a4477 1
            if(eeprom_size)
d4562 1
a4562 1
        if(data & mask)
d4575 1
a4575 1
    } while(mask);
d4607 1
a4607 1
    for(i = 0; i < count; i++) {
d4614 1
a4614 1
        if(eecd & E1000_EECD_DO)
d4645 1
a4645 1
        if(hw->mac_type > em_82544) {
d4649 1
a4649 1
            while((!(eecd & E1000_EECD_GNT)) &&
d4655 1
a4655 1
            if(!(eecd & E1000_EECD_GNT)) {
d4698 1
a4698 1
    if(eeprom->type == em_eeprom_microwire) {
d4721 1
a4721 1
    } else if(eeprom->type == em_eeprom_spi) {
d4755 1
a4755 1
    } else if(hw->eeprom.type == em_eeprom_microwire) {
d4777 1
a4777 1
    if(hw->mac_type > em_82544) {
d4815 1
a4815 1
    } while(retry_count < EEPROM_MAX_RETRY_SPI);
d4820 1
a4820 1
    if(retry_count >= EEPROM_MAX_RETRY_SPI) {
d4851 1
a4851 1
    if((offset >= eeprom->word_size) || (words > eeprom->word_size - offset) ||
d4859 1
a4859 1
	hw->eeprom.use_eerd == FALSE) {
d4879 4
a4882 1
    if(eeprom->type == em_eeprom_spi) {
d4886 1
a4886 1
        if(em_spi_eeprom_ready(hw)) {
d4894 1
a4894 1
        if((eeprom->address_bits == 8) && (offset >= 128))
d4910 1
a4910 1
    } else if(eeprom->type == em_eeprom_microwire) {
d4954 2
a4955 2
        
        if(error) {
d4959 1
a4959 1
      
d4961 1
a4961 1
    
d4987 2
a4988 2
        register_value = (data[i] << E1000_EEPROM_RW_REG_DATA) | 
                         ((offset+i) << E1000_EEPROM_RW_ADDR_SHIFT) | 
d4992 1
a4992 1
        if(error) {
d4994 1
a4994 1
        }       
d4997 1
a4997 1
        
d4999 2
a5000 2
        
        if(error) {
d5002 1
a5002 1
        }       
d5004 1
a5004 1
    
d5021 2
a5022 2
    for(i = 0; i < attempts; i++) {
        if(eerd == E1000_EEPROM_POLL_READ)
d5024 1
a5024 1
        else 
d5027 1
a5027 1
        if(reg & E1000_EEPROM_RW_REG_DONE) {
d5049 4
a5052 1
    if(hw->mac_type == em_82573) {
d5059 1
a5059 1
        if(eecd == 0x03) {
d5102 16
a5117 2
    for(i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
        if(em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
d5124 1
a5124 1
    if(checksum == (uint16_t) EEPROM_SUM)
d5143 1
d5149 2
a5150 2
    for(i = 0; i < EEPROM_CHECKSUM_REG; i++) {
        if(em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
d5157 1
a5157 1
    if(em_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
d5162 8
d5199 1
a5199 1
    if((offset >= eeprom->word_size) || (words > eeprom->word_size - offset) ||
d5206 1
a5206 1
    if(eeprom->use_eewr == TRUE)
d5209 3
d5216 1
a5216 1
    if(eeprom->type == em_eeprom_microwire) {
d5252 1
a5252 1
        if(em_spi_eeprom_ready(hw)) return -E1000_ERR_EEPROM;
d5263 1
a5263 1
        if((eeprom->address_bits == 8) && (offset >= 128))
d5285 1
a5285 1
            if((((offset + widx)*2) % eeprom->page_size) == 0) {
d5351 1
a5351 1
        for(i = 0; i < 200; i++) {
d5353 1
a5353 1
            if(eecd & E1000_EECD_DO) break;
d5356 1
a5356 1
        if(i == 200) {
d5399 7
a5405 3

    /* The flop register will be used to determine if flash type is STM */
    flop = E1000_READ_REG(hw, FLOP);
d5408 2
d5443 100
d5562 1
a5562 1
    if(em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
d5570 1
a5570 1
    if(em_read_eeprom(hw, ++offset, 1, &eeprom_data) < 0) {
d5594 1
a5594 1
    for(i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
d5596 1
a5596 1
        if(em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
d5611 1
a5611 1
        if(E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)
d5616 1
a5616 1
    for(i = 0; i < NODE_ADDRESS_SIZE; i++)
d5650 3
d5655 1
a5655 1
    for(i = 1; i < rar_num; i++) {
d5657 1
d5659 1
d5688 1
a5688 1
    
d5697 2
d5705 1
a5705 1
    for(i = rar_used_count; i < num_rar_entry; i++) {
d5707 1
d5709 1
d5715 3
a5717 1
    for(i = 0; i < num_mta_entry; i++) {
d5719 1
d5723 1
a5723 1
    for(i = 0; i < mc_addr_count; i++) {
d5775 7
a5781 2
        /* [47:36] i.e. 0x563 for above example address */
        hash_value = ((mc_addr[4] >> 4) | (((uint16_t) mc_addr[5]) << 4));
d5784 7
a5790 2
        /* [46:35] i.e. 0xAC6 for above example address */
        hash_value = ((mc_addr[4] >> 3) | (((uint16_t) mc_addr[5]) << 5));
d5793 7
a5799 2
        /* [45:34] i.e. 0x5D8 for above example address */
        hash_value = ((mc_addr[4] >> 2) | (((uint16_t) mc_addr[5]) << 6));
d5802 7
a5808 2
        /* [43:32] i.e. 0x634 for above example address */
        hash_value = ((mc_addr[4]) | (((uint16_t) mc_addr[5]) << 8));
d5813 2
d5842 2
d5854 1
a5854 1
    if((hw->mac_type == em_82544) && ((hash_reg & 0x1) == 1)) {
d5857 1
d5859 1
d5862 1
d5919 1
d5921 1
d5938 4
a5941 1
    if((hw->mac_type == em_82544) && ((offset & 0x1) == 1)) {
d5944 1
d5946 1
d5949 1
d5966 3
d5988 1
d6004 1
a6004 1
    if(hw->mac_type < em_82540) {
d6014 1
a6014 1
    if(em_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {
d6018 12
a6029 3
    if((eeprom_data== ID_LED_RESERVED_0000) ||
       (eeprom_data == ID_LED_RESERVED_FFFF)) eeprom_data = ID_LED_DEFAULT;
    for(i = 0; i < 4; i++) {
d6031 1
a6031 1
        switch(temp) {
d6048 1
a6048 1
        switch(temp) {
d6082 1
a6082 1
    switch(hw->mac_type) {
d6096 1
a6096 1
        if(ret_val)
d6101 1
a6101 1
        if(ret_val)
d6103 1
a6103 1
        /* Fall Through */
d6105 1
a6105 1
        if(hw->media_type == em_media_type_fiber) {
d6116 1
a6116 1
        } else if(hw->media_type == em_media_type_copper)
d6124 39
d6175 1
a6175 1
    switch(hw->mac_type) {
d6189 1
a6189 1
        if(ret_val)
d6191 1
a6191 1
        /* Fall Through */
d6193 4
d6217 1
a6217 1
    switch(hw->mac_type) {
d6226 1
a6226 1
        if(hw->media_type == em_media_type_fiber) {
d6237 1
a6237 1
        if(hw->media_type == em_media_type_fiber) {
d6241 4
a6244 1
        } else if(hw->media_type == em_media_type_copper) {
d6268 1
a6268 1
    switch(hw->mac_type) {
d6277 1
a6277 1
        if(hw->media_type == em_media_type_fiber) {
d6288 1
a6288 1
        if(hw->media_type == em_media_type_fiber) {
d6292 4
a6295 1
        } else if(hw->media_type == em_media_type_copper) {
d6333 2
d6341 2
d6362 2
d6370 2
d6375 1
a6375 1
    if(hw->mac_type < em_82543) return;
d6384 1
a6384 1
    if(hw->mac_type <= em_82544) return;
d6390 1
a6390 1
    if(hw->mac_type <= em_82547_rev_2) return;
d6394 3
d6421 2
a6422 2
    if(hw->adaptive_ifs) {
        if(!hw->ifs_params_forced) {
d6449 3
a6451 3
    if(hw->adaptive_ifs) {
        if((hw->collision_delta * hw->ifs_ratio) > hw->tx_packet_delta) {
            if(hw->tx_packet_delta > MIN_NUM_XMITS) {
d6453 2
a6454 2
                if(hw->current_ifs_val < hw->ifs_max_val) {
                    if(hw->current_ifs_val == 0)
d6462 1
a6462 1
            if(hw->in_ifs_mode && (hw->tx_packet_delta <= MIN_NUM_XMITS)) {
d6509 1
a6509 1
    if(carry_bit && ((stats->gorcl & 0x80000000) == 0))
d6515 1
a6515 1
    if((mac_addr[0] == (uint8_t) 0xff) && (mac_addr[1] == (uint8_t) 0xff))
d6518 1
a6518 1
    else if(*mac_addr & 0x01)
d6522 1
a6522 1
    if(frame_len == hw->max_frame_size) {
d6526 1
a6526 1
        if(stats->roc > 0)
d6533 1
a6533 1
    if(frame_len == 64) {
d6536 1
a6536 1
    } else if(frame_len == 127) {
d6539 1
a6539 1
    } else if(frame_len == 255) {
d6542 1
a6542 1
    } else if(frame_len == 511) {
d6545 1
a6545 1
    } else if(frame_len == 1023) {
d6548 1
a6548 1
    } else if(frame_len == 1522) {
d6577 1
d6588 1
a6588 1
        if(hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
d6591 1
a6591 1
        } else if(hw->bus_type == em_bus_type_pci) {
a6675 2
    uint16_t cur_agc, min_agc = IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1;
    uint16_t max_agc = 0;
d6684 1
a6684 1
    if(hw->phy_type == em_phy_m88) {
d6688 1
a6688 1
        if(ret_val)
d6747 3
a6749 1
    } else if(hw->phy_type == em_phy_igp) { /* For IGP PHY */
d6756 1
a6756 1
        for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
d6759 1
a6759 1
            if(ret_val)
d6762 1
a6762 1
            cur_agc = phy_data >> IGP01E1000_AGC_LENGTH_SHIFT;
d6764 3
a6766 3
            /* Array bound check. */
            if((cur_agc >= IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1) ||
               (cur_agc == 0))
d6769 1
a6769 1
            agc_value += cur_agc;
d6772 2
a6773 2
            if(min_agc > cur_agc)
                min_agc = cur_agc;
d6777 2
a6778 2
        if(agc_value < IGP01E1000_PHY_CHANNEL_NUM * em_igp_cable_length_50) {
            agc_value -= min_agc;
d6794 4
a6797 1
    } else if (hw->phy_type == em_phy_igp_2) {
d6809 1
a6809 1
	    /* Getting bits 15:9, which represent the combination of course and
d6812 7
a6818 2
            cur_agc = (phy_data >> IGP02E1000_AGC_LENGTH_SHIFT) &
                      IGP02E1000_AGC_LENGTH_MASK;
d6821 6
a6826 4
            if (em_igp_2_cable_length_table[min_agc] > em_igp_2_cable_length_table[cur_agc])
                min_agc = cur_agc;
	    if (em_igp_2_cable_length_table[max_agc] < em_igp_2_cable_length_table[cur_agc])
                max_agc = cur_agc;
d6828 1
a6828 1
            agc_value += em_igp_2_cable_length_table[cur_agc];
d6831 2
a6832 1
        agc_value -= (em_igp_2_cable_length_table[min_agc] + em_igp_2_cable_length_table[max_agc]);
d6874 1
a6874 1
        if(ret_val)
d6878 2
a6879 1
    } else if(hw->phy_type == em_phy_igp ||
d6884 1
a6884 1
        if(ret_val)
d6889 1
a6889 1
        if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
d6895 1
a6895 1
            if(ret_val)
d6905 7
d6924 1
a6924 1
 *            E1000_SUCCESS 
d6939 2
a6940 1
    if(hw->phy_type == em_phy_igp || 
d6944 1
a6944 1
        if(ret_val)
d6952 1
a6952 1
        if(ret_val)
d6957 3
d6992 1
a6992 1
    if(hw->phy_type != em_phy_igp)
d6995 1
a6995 1
    if(link_up) {
d6997 1
a6997 1
        if(ret_val) {
d7002 1
a7002 1
        if(speed == SPEED_1000) {
d7004 3
a7006 1
            em_get_cable_length(hw, &min_length, &max_length);
d7008 1
a7008 1
            if((hw->dsp_config_state == em_dsp_config_enabled) &&
d7011 1
a7011 1
                for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
d7014 1
a7014 1
                    if(ret_val)
d7021 1
a7021 1
                    if(ret_val)
d7027 1
a7027 1
            if((hw->ffe_config_state == em_ffe_config_enabled) &&
d7036 1
a7036 1
                if(ret_val)
d7039 1
a7039 1
                for(i = 0; i < ffe_idle_err_timeout; i++) {
d7043 1
a7043 1
                    if(ret_val)
d7047 1
a7047 1
                    if(idle_errs > SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {
d7053 1
a7053 1
                        if(ret_val)
d7058 1
a7058 1
                    if(idle_errs)
d7064 1
a7064 1
        if(hw->dsp_config_state == em_dsp_config_activated) {
d7069 1
a7069 1
            if(ret_val)
d7075 1
a7075 1
            if(ret_val)
d7082 1
a7082 1
            if(ret_val)
d7084 1
a7084 1
            for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
d7086 1
a7086 1
                if(ret_val)
d7093 1
a7093 1
                if(ret_val)
d7099 1
a7099 1
            if(ret_val)
d7107 1
a7107 1
            if(ret_val)
d7113 1
a7113 1
        if(hw->ffe_config_state == em_ffe_config_active) {
d7118 1
a7118 1
            if(ret_val)
d7124 1
a7124 1
            if(ret_val)
d7131 1
a7131 1
            if(ret_val)
d7135 1
a7135 1
            if(ret_val)
d7140 1
a7140 1
            if(ret_val)
d7148 1
a7148 1
            if(ret_val)
d7173 2
a7174 2
    if((hw->mac_type == em_82545_rev_3) &&
       (hw->media_type == em_media_type_copper)) {
d7176 1
a7176 1
        if(ret_val) {
d7180 2
a7181 2
        if((eeprom_data != EEPROM_RESERVED_WORD) &&
           (eeprom_data & EEPROM_PHY_CLASS_A)) {
d7183 1
a7183 1
            if(ret_val)
d7186 1
a7186 1
            if(ret_val)
d7214 1
d7219 2
a7220 1
    if(hw->phy_type != em_phy_igp && hw->phy_type != em_phy_igp_2)
d7226 1
a7226 1
    if(hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2) {
d7228 1
a7228 1
        if(ret_val)
d7230 5
d7237 1
a7237 1
        if(ret_val)
d7241 3
a7243 3
    if(!active) {
        if(hw->mac_type == em_82541_rev_2 ||
           hw->mac_type == em_82547_rev_2) {
d7246 1
a7246 1
            if(ret_val)
d7249 4
d7258 1
d7268 1
a7268 1
            if(ret_val)
d7274 1
a7274 1
            if(ret_val)
d7285 1
a7285 1
            if(ret_val)
d7289 3
a7291 3
    } else if((hw->autoneg_advertised == AUTONEG_ADVERTISE_SPEED_DEFAULT) ||
              (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_ALL ) ||
              (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_100_ALL)) {
d7293 2
a7294 2
        if(hw->mac_type == em_82541_rev_2 ||
           hw->mac_type == em_82547_rev_2) {
d7297 1
a7297 1
            if(ret_val)
d7300 4
d7309 1
d7314 1
a7314 1
        if(ret_val)
d7319 1
a7319 1
        if(ret_val)
d7344 1
d7349 1
a7349 1
    if(hw->mac_type <= em_82547_rev_2)
d7352 3
d7356 1
a7356 1
        if(ret_val)
d7358 1
d7361 4
d7369 1
d7378 1
a7378 1
            if(ret_val)
d7384 1
a7384 1
            if(ret_val)
d7395 1
a7395 1
            if(ret_val)
d7401 6
a7406 2
 
            phy_data |= IGP02E1000_PM_D0_LPLU;   
d7410 1
d7414 1
a7414 1
        if(ret_val)
d7419 1
a7419 1
        if(ret_val)
d7440 1
a7440 1
    switch(hw->mac_type) {
d7451 1
a7451 1
    if(ret_val)
d7455 1
a7455 1
    if(ret_val)
d7459 1
a7459 1
    if(ret_val)
d7464 1
a7464 1
    if(ret_val)
d7470 1
a7470 1
    if(ret_val)
d7474 1
a7474 1
    if(ret_val)
d7479 1
a7479 1
    if(ret_val)
d7483 1
a7483 1
    if(ret_val)
d7499 1
a7499 1
    uint32_t offset = E1000_MNG_DHCP_COOKIE_OFFSET; 
d7518 1
a7518 1
 * returns: - E1000_ERR_HOST_INTERFACE_COMMAND in case if is not ready or 
d7542 1
a7542 1
    if (i == E1000_MNG_DHCP_COMMAND_TIMEOUT) { 
d7562 1
a7562 1
    uint32_t data;
d7642 1
a7642 1
    while(i--)
d7649 1
a7649 1
    for (i = 0; i < length; i++)
d7651 2
d7665 1
a7665 2
em_mng_write_commit(
    struct em_hw * hw)
d7683 1
a7683 2
em_check_mng_mode(
    struct em_hw *hw)
d7689 6
a7694 2
    if((fwsm & E1000_FWSM_MODE_MASK) ==
        (E1000_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT))
d7837 1
a7837 1
    if(ret_val)
d7840 1
a7840 1
    if(ret_val)
d7844 1
a7844 1
    if(ret_val)
d7848 1
a7848 1
    for(i = PHY_FORCE_TIME; i > 0; i--) {
d7854 1
a7854 1
        if(ret_val)
d7858 1
a7858 1
        if(ret_val)
d7861 1
a7861 1
        if((mii_status_reg & ~MII_SR_LINK_STATUS) == 0) break;
d7871 1
a7871 1
    if(ret_val)
d7875 1
a7875 1
    if(ret_val)
d7879 1
a7879 1
    if(ret_val)
d7883 1
a7883 1
    if(ret_val)
d7887 1
a7887 1
    if(ret_val)
d7891 1
a7891 1
    for(i = PHY_FORCE_TIME; i > 0; i--) {
d7897 1
a7897 1
        if(ret_val)
d7901 1
a7901 1
        if(ret_val)
d7904 1
a7904 1
        if(mii_status_reg & MII_SR_LINK_STATUS) break;
d7981 2
a7982 2
    while(timeout) {
        if(!(E1000_READ_REG(hw, STATUS) & E1000_STATUS_GIO_MASTER_ENABLE))
d7989 1
a7989 1
    if(!timeout) {
d8022 4
a8025 2
        while(timeout) {
            if (E1000_READ_REG(hw, EECD) & E1000_EECD_AUTO_RD) break;
d8030 1
a8030 1
        if(!timeout) {
d8065 1
a8065 1
        msec_delay(10);
d8071 1
a8071 1
        /* Fall Through */
d8111 1
a8111 1
    if(!hw->eeprom_semaphore_present)
d8122 1
a8122 1
    while(timeout) {
d8128 1
a8128 1
        if(swsm & E1000_SWSM_SWESMBI)
d8135 1
a8135 1
    if(!timeout) {
d8160 1
a8160 1
    if(!hw->eeprom_semaphore_present)
d8193 1
a8193 1
    while(timeout) {
d8196 1
a8196 1
        if(!(swsm & E1000_SWSM_SMBI))
d8202 1
a8202 1
    if(!timeout) {
d8248 7
d8278 1
a8278 1
        if((fwsm & E1000_FWSM_MODE_MASK) != 0)
d8281 2
d8287 841
@


1.19
log
@Sync up to Intel's latest FreeBSD em driver (6.0.5). Adds support
for new chipset revisions embedded in the ESB2 and ICH8 core logic
chipsets.

From: Intel's web-site
@
text
@d44 1
a44 1
 
d67 1
a67 1
 
d110 2
a111 3
static int32_t em_configure_kmrn_for_10_100(struct em_hw *hw,
                                               uint16_t duplex);
static int32_t em_configure_kmrn_for_1000(struct em_hw *hw);
d146 1
a146 1
    if (hw->mac_type == em_undefined)
d149 1
a149 1
    switch (hw->phy_id) {
d157 4
a160 4
        if (hw->mac_type == em_82541 ||
            hw->mac_type == em_82541_rev_2 ||
            hw->mac_type == em_82547 ||
            hw->mac_type == em_82547_rev_2) {
a163 8
    case IGP03E1000_E_PHY_ID:
        hw->phy_type = em_phy_igp_3;
        break;
    case IFE_E_PHY_ID:
    case IFE_PLUS_E_PHY_ID:
    case IFE_C_E_PHY_ID:
        hw->phy_type = em_phy_ife;
        break;
d192 1
a192 1
    if (hw->phy_init_script) {
d208 1
a208 1
        switch (hw->mac_type) {
d245 1
a245 1
        if (hw->mac_type == em_82547) {
d251 1
a251 1
            if (!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
d257 1
a257 1
                if (coarse > IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {
d260 1
a260 1
                } else if (coarse == IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
d340 1
a341 1
    case E1000_DEV_ID_82541ER_LOM:
a379 2
    case E1000_DEV_ID_80003ES2LAN_COPPER_SPT:
    case E1000_DEV_ID_80003ES2LAN_SERDES_SPT:
a383 7
    case E1000_DEV_ID_ICH8_IGP_M_AMT:
    case E1000_DEV_ID_ICH8_IGP_AMT:
    case E1000_DEV_ID_ICH8_IGP_C:
    case E1000_DEV_ID_ICH8_IFE:
    case E1000_DEV_ID_ICH8_IGP_M:
        hw->mac_type = em_ich8lan;
        break;
d389 1
a389 5
    switch (hw->mac_type) {
    case em_ich8lan:
        hw->swfwhw_semaphore_present = TRUE;
        hw->asf_firmware_present = TRUE;
        break;
d423 1
a423 1
    if (hw->mac_type != em_82543) {
a441 1
        case em_ich8lan:
d482 1
a482 1
    if (hw->mac_type == em_82542_rev2_0) {
d487 1
a487 1
    if (hw->bus_type == em_bus_type_pci_express) {
d491 1
a491 1
        if (em_disable_pciex_master(hw) != E1000_SUCCESS) {
d519 1
a519 1
    if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
d526 1
a526 1
    if (hw->mac_type == em_82573) {
d536 1
a536 1
            if (extcnf_ctrl & E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP)
d543 1
a543 9
        } while (timeout);
    }

    /* Workaround for ICH8 bit corruption issue in FIFO memory */
    if (hw->mac_type == em_ich8lan) {
        /* Set Tx and Rx buffer allocation to 8k apiece. */
        E1000_WRITE_REG(hw, PBA, E1000_PBA_8K);
        /* Set Packet Buffer Size to 16k. */
        E1000_WRITE_REG(hw, PBS, E1000_PBS_16K);
d553 1
a553 1
    switch (hw->mac_type) {
a568 14
        case em_ich8lan:
            if (!hw->phy_reset_disable &&
                em_check_phy_reset_block(hw) == E1000_SUCCESS) {
                /* em_ich8lan PHY HW reset requires MAC CORE reset
                 * at the same time to make sure the interface between
                 * MAC and the external PHY is reset.
                 */
                ctrl |= E1000_CTRL_PHY_RST;
            }

            em_get_software_flag(hw);
            E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
            msec_delay(5);
            break;
d578 1
a578 1
    switch (hw->mac_type) {
a609 1
        case em_ich8lan:
d612 1
a612 1
            if (ret_val)
d623 1
a623 1
    if (hw->mac_type >= em_82540 && hw->mac_type <= em_82547_rev_2) {
d629 1
a629 1
    if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
d647 2
a648 2
    if (hw->mac_type == em_82542_rev2_0) {
        if (hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
a651 6
    if (hw->mac_type == em_ich8lan) {
        uint32_t kab = E1000_READ_REG(hw, KABGTXD);
        kab |= E1000_KABGTXD_BGSQLBIAS;
        E1000_WRITE_REG(hw, KABGTXD, kab);
    }

d684 1
a684 1
    if (ret_val) {
d694 3
a696 6
    /* VET hardcoded to standard value and VFTA removed in ICH8 LAN */
    if (hw->mac_type != em_ich8lan) {
        if (hw->mac_type < em_82545_rev_3)
            E1000_WRITE_REG(hw, VET, 0);
        em_clear_vfta(hw);
    }
d699 1
a699 1
    if (hw->mac_type == em_82542_rev2_0) {
d713 1
a713 1
    if (hw->mac_type == em_82542_rev2_0) {
d717 1
a717 1
        if (hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
d724 1
a724 3
    if (hw->mac_type == em_ich8lan)
        mta_size = E1000_MC_TBL_SIZE_ICH8LAN;
    for (i = 0; i < mta_size; i++) {
a725 4
        /* use write flush to prevent Memory Write Block (MWB) from
         * occuring when accessing our register space */
        E1000_WRITE_FLUSH(hw);
    }
d732 1
a732 1
    if (hw->dma_fairness && hw->mac_type <= em_82543) {
d737 1
a737 1
    switch (hw->mac_type) {
d743 1
a743 1
        if (hw->bus_type == em_bus_type_pcix) {
d751 1
a751 1
            if (stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
d753 1
a753 1
            if (cmd_mmrbc > stat_mmrbc) {
a762 4
    /* More time needed for PHY to initialize */
    if (hw->mac_type == em_ich8lan)
        msec_delay(15);

d767 1
a767 1
    if (hw->mac_type > em_82544) {
a775 1
        case em_ich8lan:
d784 1
a784 1
        em_enable_tx_pkt_filtering(hw);
a813 1
    case em_ich8lan:
d816 1
a816 1
        if (hw->mac_type >= em_82571)
a834 5
    /* ICH8/Nahum No-snoop bits are opposite polarity.
     * Set to snoop by default after reset. */
    if (hw->mac_type == em_ich8lan)
        em_set_pci_ex_no_snoop(hw, PCI_EX_82566_SNOOP_ALL);

d860 1
a860 1
    if (hw->media_type != em_media_type_internal_serdes)
d863 1
a863 1
    switch (hw->mac_type) {
d876 1
a876 1
    if (eeprom_data != EEPROM_RESERVED_WORD) {
d878 1
a878 1
        eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK;
d880 1
a880 1
        if (ret_val)
a921 1
        case em_ich8lan:
d947 1
a947 1
    if (hw->mac_type == em_82542_rev2_0)
d950 1
a950 1
    if ((hw->mac_type < em_82543) && (hw->report_tx_early == 1))
d964 1
a964 7
    if (hw->mac_type == em_82543) {
        ret_val = em_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,
                                    1, &eeprom_data);
        if (ret_val) {
            DEBUGOUT("EEPROM Read Error\n");
            return -E1000_ERR_EEPROM;
        }
d982 3
a984 6
    /* FCAL/H and FCT are hardcoded to standard values in em_ich8lan. */
    if (hw->mac_type != em_ich8lan) {
        E1000_WRITE_REG(hw, FCT, FLOW_CONTROL_TYPE);
        E1000_WRITE_REG(hw, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
        E1000_WRITE_REG(hw, FCAL, FLOW_CONTROL_ADDRESS_LOW);
    }
d994 1
a994 1
    if (!(hw->fc & em_fc_tx_pause)) {
d1001 1
a1001 1
        if (hw->fc_send_xon) {
d1048 1
a1048 1
    if (hw->media_type == em_media_type_fiber)
d1052 1
a1052 1
    if (ret_val)
d1060 1
a1060 1
    if (ret_val)
d1131 1
a1131 1
    if (hw->media_type == em_media_type_internal_serdes ||
d1134 1
a1134 1
        for (i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
d1137 1
a1137 1
            if (status & E1000_STATUS_LU) break;
d1139 1
a1139 1
        if (i == (LINK_UP_TIMEOUT / 10)) {
d1148 1
a1148 1
            if (ret_val) {
d1182 1
a1182 1
    if (hw->mac_type > em_82543) {
d1190 1
a1190 1
        if (ret_val)
d1196 1
a1196 1
    if (ret_val) {
d1204 1
a1204 1
    if (ret_val)
d1207 1
a1207 1
    if ((hw->mac_type == em_82545_rev_3) ||
d1214 3
a1216 3
    if (hw->mac_type <= em_82543 ||
        hw->mac_type == em_82541 || hw->mac_type == em_82547 ||
        hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2)
d1239 1
a1239 1

d1246 1
a1246 1
    /* Wait 15ms for MAC to configure PHY from eeprom settings */
d1248 1
a1248 1
    if (hw->mac_type != em_ich8lan) {
a1253 1
    }
d1297 1
a1297 1
    if (ret_val)
d1301 1
a1301 1
    if (hw->autoneg) {
d1304 1
a1304 1
        if (hw->ffe_config_state == em_ffe_config_active)
d1307 1
a1307 1
        if (hw->dsp_config_state == em_dsp_config_activated)
d1313 1
a1313 1
        if (hw->autoneg_advertised == ADVERTISE_1000_FULL) {
d1315 2
a1316 3
            ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                         &phy_data);
            if (ret_val)
d1319 4
a1322 3
            ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                          phy_data);
            if (ret_val)
d1326 1
a1326 1
            if (ret_val)
d1330 1
a1330 1
            if (ret_val)
d1335 1
a1335 1
        if (ret_val)
d1360 1
a1360 1
        if (ret_val)
d1381 2
a1382 2
    if (!hw->phy_reset_disable) {

d1386 1
a1386 1
        if (ret_val)
d1395 1
a1395 1
        if (ret_val)
d1406 1
a1406 1
        if (ret_val)
d1431 1
a1431 1
        if (hw->disable_polarity_correction == 1)
d1435 1
a1435 1
        if (ret_val)
d1490 1
d1492 1
a1494 1

d1529 1
a1529 1
    if (hw->phy_reset_disable)
d1531 1
a1531 1

d1534 1
a1534 1
    if (ret_val)
d1571 1
a1571 1
    if (hw->disable_polarity_correction == 1)
d1573 9
a1581 2
    ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
    if (ret_val)
d1584 2
d1587 2
a1588 21
        /* Force TX_CLK in the Extended PHY Specific Control Register
         * to 25MHz clock.
         */
        ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data |= M88E1000_EPSCR_TX_CLK_25;

        if ((hw->phy_revision == E1000_REVISION_2) &&
            (hw->phy_id == M88E1111_I_PHY_ID)) {
            /* Vidalia Phy, set the downshift counter to 5x */
            phy_data &= ~(M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK);
            phy_data |= M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X;
            ret_val = em_write_phy_reg(hw,
                                        M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
            if (ret_val)
                return ret_val;
        } else {
            /* Configure Master and Slave downshift values */
            phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
d1590 1
a1590 1
            phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
d1592 3
a1594 5
            ret_val = em_write_phy_reg(hw,
                                        M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
            if (ret_val)
               return ret_val;
        }
d1599 1
a1599 1
    if (ret_val) {
d1629 1
a1629 1
    if (hw->autoneg_advertised == 0)
a1631 4
    /* IFE phy only supports 10/100 */
    if (hw->phy_type == em_phy_ife)
        hw->autoneg_advertised &= AUTONEG_ADVERTISE_10_100_ALL;

d1634 1
a1634 1
    if (ret_val) {
d1644 1
a1644 1
    if (ret_val)
d1649 1
a1649 1
    if (ret_val)
d1655 1
a1655 1
    if (hw->wait_autoneg_complete) {
d1657 1
a1657 1
        if (ret_val) {
a1667 12
/********************************************************************
* Copper link setup for em_phy_ife (Fast Ethernet PHY) series.
*
* hw - Struct containing variables accessed by shared code
*********************************************************************/
static int32_t
em_copper_link_ife_setup(struct em_hw *hw)
{
    if (hw->phy_reset_disable)
        return E1000_SUCCESS;
    return E1000_SUCCESS;
}
d1677 1
a1677 1
*   3) Config DSP to improve Gigabit link quality for some PHY revisions.
d1686 2
a1687 2

    if (hw->mac_type >= em_82544) {
d1691 1
a1691 1
        if (ret_val) {
d1697 1
a1697 1
    if (ret_val) {
d1703 1
a1703 1
    if (hw->phy_type == em_phy_igp) {
d1705 1
a1705 1
        if (ret_val) {
d1710 1
a1710 1

a1730 1
    case em_ich8lan:
d1750 1
a1750 1
    if (ret_val)
d1755 4
a1758 2
        /* Kumeran registers are written-only */
        reg_data = E1000_KUMCTRLSTA_INB_CTRL_LINK_STATUS_TX_TIMEOUT_DEFAULT;
a1769 1
        hw->phy_type == em_phy_igp_3 ||
d1772 1
a1772 1
        if (ret_val)
d1776 1
a1776 1
        if (ret_val)
d1780 1
a1780 5
        if (ret_val)
            return ret_val;
    } else if (hw->phy_type == em_phy_ife) {
        ret_val = em_copper_link_ife_setup(hw);
        if (ret_val)
d1784 3
a1786 3
    if (hw->autoneg) {
        /* Setup autoneg and flow control advertisement
          * and perform autonegotiation */
d1788 2
a1789 2
        if (ret_val)
            return ret_val;
d1795 1
a1795 1
        if (ret_val) {
d1804 1
a1804 1
    for (i = 0; i < 10; i++) {
d1806 1
a1806 1
        if (ret_val)
d1809 1
a1809 1
        if (ret_val)
d1812 1
a1812 1
        if (phy_data & MII_SR_LINK_STATUS) {
d1815 1
a1815 1
            if (ret_val)
d1817 1
a1817 1

d1854 2
a1855 2
    ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data);

d1859 1
a1864 1
    ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, reg_data);
d1866 3
d1873 1
a1873 1
em_configure_kmrn_for_1000(struct em_hw *hw)
a1892 1
    ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data);
d1894 2
d1899 1
a1900 1
    ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL, reg_data);
d1902 3
d1924 1
a1924 1
    if (ret_val)
d1927 4
a1930 7
    if (hw->phy_type != em_phy_ife) {
        /* Read the MII 1000Base-T Control Register (Address 9). */
        ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);
        if (ret_val)
            return ret_val;
    } else
        mii_1000t_ctrl_reg=0;
d1949 1
a1949 1
    if (hw->autoneg_advertised & ADVERTISE_10_HALF) {
d1955 1
a1955 1
    if (hw->autoneg_advertised & ADVERTISE_10_FULL) {
d1961 1
a1961 1
    if (hw->autoneg_advertised & ADVERTISE_100_HALF) {
d1967 1
a1967 1
    if (hw->autoneg_advertised & ADVERTISE_100_FULL) {
d1973 1
a1973 1
    if (hw->autoneg_advertised & ADVERTISE_1000_HALF) {
d1978 1
a1978 1
    if (hw->autoneg_advertised & ADVERTISE_1000_FULL) {
a1980 3
        if (hw->phy_type == em_phy_ife) {
            DEBUGOUT("em_phy_ife is a 10/100 PHY. Gigabit speed is not supported.\n");
        }
d2037 1
a2037 1
    if (ret_val)
d2042 3
a2044 5
    if (hw->phy_type != em_phy_ife) {
        ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg);
        if (ret_val)
            return ret_val;
    }
d2083 1
a2083 1
    if (ret_val)
d2091 2
a2092 2
    if (hw->forced_speed_duplex == em_100_full ||
        hw->forced_speed_duplex == em_10_full) {
d2109 1
a2109 1
    if (hw->forced_speed_duplex == em_100_full ||
d2132 1
a2132 1
        if (ret_val)
d2140 1
a2140 1
        if (ret_val)
a2146 12
    /* Disable MDI-X support for 10/100 */
    } else if (hw->phy_type == em_phy_ife) {
        ret_val = em_read_phy_reg(hw, IFE_PHY_MDIX_CONTROL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data &= ~IFE_PMC_AUTO_MDIX;
        phy_data &= ~IFE_PMC_FORCE_MDIX;

        ret_val = em_write_phy_reg(hw, IFE_PHY_MDIX_CONTROL, phy_data);
        if (ret_val)
            return ret_val;
d2152 1
a2152 1
        if (ret_val)
d2159 1
a2159 1
        if (ret_val)
d2165 1
a2165 1
    if (ret_val)
d2177 1
a2177 1
    if (hw->wait_autoneg_complete) {
d2183 1
a2183 1
        for (i = PHY_FORCE_TIME; i > 0; i--) {
d2188 1
a2188 1
            if (ret_val)
d2192 1
a2192 1
            if (ret_val)
d2195 1
a2195 1
            if (mii_status_reg & MII_SR_LINK_STATUS) break;
d2198 1
a2198 1
        if ((i == 0) &&
d2203 1
a2203 1
            if (ret_val) {
d2209 2
a2210 2
        for (i = PHY_FORCE_TIME; i > 0; i--) {
            if (mii_status_reg & MII_SR_LINK_STATUS) break;
d2216 1
a2216 1
            if (ret_val)
d2220 1
a2220 1
            if (ret_val)
d2231 1
a2231 1
        if (ret_val)
d2236 1
a2236 1
        if (ret_val)
d2243 1
a2243 1
        if (ret_val)
d2248 1
a2248 1
        if (ret_val)
d2251 4
a2254 3
        if ((hw->mac_type == em_82544 || hw->mac_type == em_82543) &&
            (!hw->autoneg) && (hw->forced_speed_duplex == em_10_full ||
             hw->forced_speed_duplex == em_10_half)) {
d2256 1
a2256 1
            if (ret_val)
d2331 1
a2331 1
    /* 82544 or newer MAC, Auto Speed Detection takes care of
d2347 1
a2347 1
    if (ret_val)
d2350 1
a2350 1
    if (phy_data & M88E1000_PSSR_DPLX)
d2352 1
a2352 1
    else
d2360 1
a2360 1
    if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
d2362 1
a2362 1
    else if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
d2430 1
a2430 1
    if (hw->mac_type == em_82542_rev2_0)
d2464 3
a2466 4
    if (((hw->media_type == em_media_type_fiber) && (hw->autoneg_failed)) ||
        ((hw->media_type == em_media_type_internal_serdes) &&
         (hw->autoneg_failed)) ||
        ((hw->media_type == em_media_type_copper) && (!hw->autoneg))) {
d2468 1
a2468 1
        if (ret_val) {
d2479 1
a2479 1
    if ((hw->media_type == em_media_type_copper) && hw->autoneg) {
d2485 1
a2485 1
        if (ret_val)
d2488 1
a2488 1
        if (ret_val)
d2491 1
a2491 1
        if (mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
d2500 1
a2500 1
            if (ret_val)
d2504 1
a2504 1
            if (ret_val)
d2541 2
a2542 2
            if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
                (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {
d2549 1
a2549 1
                if (hw->original_fc == em_fc_full) {
d2565 4
a2568 4
            else if (!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
                     (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
                     (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
                     (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
d2580 4
a2583 4
            else if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
                     (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
                     !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
                     (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
d2607 3
a2609 3
            else if ((hw->original_fc == em_fc_none ||
                      hw->original_fc == em_fc_tx_pause) ||
                      hw->fc_strict_ieee) {
d2622 1
a2622 1
            if (ret_val) {
d2627 1
a2627 1
            if (duplex == HALF_DUPLEX)
d2634 1
a2634 1
            if (ret_val) {
d2673 2
a2674 2
    if ((hw->media_type == em_media_type_fiber) ||
        (hw->media_type == em_media_type_internal_serdes)) {
d2677 1
a2677 1
        if (hw->media_type == em_media_type_fiber) {
d2679 1
a2679 1
            if (status & E1000_STATUS_LU)
d2690 1
a2690 1
    if ((hw->media_type == em_media_type_copper) && hw->get_link_status) {
d2697 1
a2697 1
        if (ret_val)
d2700 1
a2700 1
        if (ret_val)
d2703 1
a2703 1
        if (phy_data & MII_SR_LINK_STATUS) {
d2717 4
a2720 4
            if ((hw->mac_type == em_82544 || hw->mac_type == em_82543) &&
                (!hw->autoneg) &&
                (hw->forced_speed_duplex == em_10_full ||
                 hw->forced_speed_duplex == em_10_half)) {
d2737 1
a2737 1
        if (!hw->autoneg) return -E1000_ERR_CONFIG;
d2750 1
a2750 1
        if (hw->mac_type >= em_82544)
d2754 1
a2754 1
            if (ret_val) {
d2765 1
a2765 1
        if (ret_val) {
d2777 1
a2777 1
        if (hw->tbi_compatibility_en) {
d2779 2
a2780 6
            ret_val = em_get_speed_and_duplex(hw, &speed, &duplex);
            if (ret_val) {
                DEBUGOUT("Error getting link speed and duplex\n");
                return ret_val;
            }
            if (speed != SPEED_1000) {
d2784 1
a2784 1
                if (hw->tbi_compatibility_on) {
d2797 1
a2797 1
                if (!hw->tbi_compatibility_on) {
d2813 1
a2813 1
    else if ((((hw->media_type == em_media_type_fiber) &&
d2815 4
a2818 4
              (hw->media_type == em_media_type_internal_serdes)) &&
              (!(status & E1000_STATUS_LU)) &&
              (!(rxcw & E1000_RXCW_C))) {
        if (hw->autoneg_failed == 0) {
d2834 1
a2834 1
        if (ret_val) {
d2844 3
a2846 3
    else if (((hw->media_type == em_media_type_fiber) ||
              (hw->media_type == em_media_type_internal_serdes)) &&
              (ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {
d2856 2
a2857 2
    else if ((hw->media_type == em_media_type_internal_serdes) &&
             !(E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
d2860 2
a2861 2
        if (E1000_RXCW_SYNCH & E1000_READ_REG(hw, RXCW)) {
            if (!(rxcw & E1000_RXCW_IV)) {
d2870 2
a2871 2
    if ((hw->media_type == em_media_type_internal_serdes) &&
        (E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
d2895 1
a2895 1
    if (hw->mac_type >= em_82543) {
d2897 1
a2897 1
        if (status & E1000_STATUS_SPEED_1000) {
d2900 1
a2900 1
        } else if (status & E1000_STATUS_SPEED_100) {
d2908 1
a2908 1
        if (status & E1000_STATUS_FD) {
d2925 1
a2925 1
    if (hw->phy_type == em_phy_igp && hw->speed_downgraded) {
d2927 1
a2927 1
        if (ret_val)
d2930 1
a2930 1
        if (!(phy_data & NWAY_ER_LP_NWAY_CAPS))
d2934 1
a2934 1
            if (ret_val)
d2936 1
a2936 1
            if ((*speed == SPEED_100 && !(phy_data & NWAY_LPAR_100TX_FD_CAPS)) ||
d2942 1
a2942 1
    if ((hw->mac_type == em_80003es2lan) &&
d2945 1
a2945 1
            ret_val = em_configure_kmrn_for_1000(hw);
a2951 6
    if ((hw->phy_type == em_phy_igp_3) && (*speed == SPEED_1000)) {
        ret_val = em_kumeran_lock_loss_workaround(hw);
        if (ret_val)
            return ret_val;
    }

d2971 1
a2971 1
    for (i = PHY_AUTO_NEG_TIME; i > 0; i--) {
d2976 1
a2976 1
        if (ret_val)
d2979 1
a2979 1
        if (ret_val)
d2981 1
a2981 1
        if (phy_data & MII_SR_AUTONEG_COMPLETE) {
d3054 1
a3054 1
    while (mask) {
d3060 2
a3061 4
        if (data & mask)
            ctrl |= E1000_CTRL_MDIO;
        else
            ctrl &= ~E1000_CTRL_MDIO;
d3112 1
a3112 1
    for (data = 0, i = 0; i < 16; i++) {
d3117 1
a3117 2
        if (ctrl & E1000_CTRL_MDIO)
            data |= 1;
a3136 3
    if (hw->swfwhw_semaphore_present)
        return em_get_software_flag(hw);

d3140 1
a3140 1
    while (timeout) {
a3175 5
    if (hw->swfwhw_semaphore_present) {
        em_release_software_flag(hw);
        return;
    }

d3218 1
a3218 2
    if ((hw->phy_type == em_phy_igp ||
        hw->phy_type == em_phy_igp_3 ||
d3223 1
a3223 1
        if (ret_val) {
d3268 1
a3268 1
    if (reg_addr > MAX_PHY_REG_ADDRESS) {
d3273 1
a3273 1
    if (hw->mac_type > em_82543) {
d3285 1
a3285 1
        for (i = 0; i < 64; i++) {
d3288 1
a3288 1
            if (mdic & E1000_MDIC_READY) break;
d3290 1
a3290 1
        if (!(mdic & E1000_MDIC_READY)) {
d3294 1
a3294 1
        if (mdic & E1000_MDIC_ERROR) {
d3357 1
a3357 2
    if ((hw->phy_type == em_phy_igp ||
        hw->phy_type == em_phy_igp_3 ||
d3362 1
a3362 1
        if (ret_val) {
d3407 1
a3407 1
    if (reg_addr > MAX_PHY_REG_ADDRESS) {
d3412 1
a3412 1
    if (hw->mac_type > em_82543) {
d3425 1
a3425 1
        for (i = 0; i < 641; i++) {
d3428 1
a3428 1
            if (mdic & E1000_MDIC_READY) break;
d3430 1
a3430 1
        if (!(mdic & E1000_MDIC_READY)) {
d3542 1
a3542 1
    if (hw->mac_type > em_82543) {
d3555 1
a3555 1
         * For pre-em_82571 hardware, we delay for 10ms between the assert
d3562 2
a3563 2

        if (hw->mac_type < em_82571)
d3567 1
a3567 1

d3570 1
a3570 1

d3572 1
a3572 1
            msec_delay_irq(10);
d3590 1
a3590 1
    if ((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
a3601 6
        if ((hw->mac_type == em_ich8lan) &&
            (hw->phy_type == em_phy_igp_3)) {
            ret_val = em_init_lcd_from_nvm(hw);
            if (ret_val)
                return ret_val;
        }
a3629 1
    case em_ich8lan:
d3631 1
a3631 1
        if (ret_val)
a3632 1

d3636 1
a3636 1
        if (ret_val)
d3641 1
a3641 1
        if (ret_val)
d3648 1
a3648 1
    if (hw->phy_type == em_phy_igp || hw->phy_type == em_phy_igp_2)
d3655 1
a3655 5
* Work-around for 82566 power-down: on D3 entry-
* 1) disable gigabit link
* 2) write VR power-down enable
* 3) read it back
* if successful continue, else issue LCD reset and repeat
d3657 1
a3657 1
* hw - struct containing variables accessed by shared code
d3659 2
a3660 2
void
em_phy_powerdown_workaround(struct em_hw *hw)
d3662 15
a3676 3
    int32_t reg;
    uint16_t phy_data;
    int32_t retry = 0;
d3678 8
a3685 1
    DEBUGFUNC("em_phy_powerdown_workaround");
d3687 4
a3690 2
    if (hw->phy_type != em_phy_igp_3)
        return;
d3692 5
a3696 23
    do {
        /* Disable link */
        reg = E1000_READ_REG(hw, PHY_CTRL);
        E1000_WRITE_REG(hw, PHY_CTRL, reg | E1000_PHY_CTRL_GBE_DISABLE |
                        E1000_PHY_CTRL_NOND0A_GBE_DISABLE);

        /* Write VR power-down enable */
        em_read_phy_reg(hw, IGP3_VR_CTRL, &phy_data);
        em_write_phy_reg(hw, IGP3_VR_CTRL, phy_data |
                            IGP3_VR_CTRL_MODE_SHUT);

        /* Read it back and test */
        em_read_phy_reg(hw, IGP3_VR_CTRL, &phy_data);
        if ((phy_data & IGP3_VR_CTRL_MODE_SHUT) || retry)
            break;

        /* Issue PHY reset and repeat at most one more time */
        reg = E1000_READ_REG(hw, CTRL);
        E1000_WRITE_REG(hw, CTRL, reg | E1000_CTRL_PHY_RST);
        retry++;
    } while (retry);

    return;
d3698 2
a3699 1
}
d3701 3
a3703 112
/******************************************************************************
* Work-around for 82566 Kumeran PCS lock loss:
* On link status change (i.e. PCI reset, speed change) and link is up and
* speed is gigabit-
* 0) if workaround is optionally disabled do nothing
* 1) wait 1ms for Kumeran link to come up
* 2) check Kumeran Diagnostic register PCS lock loss bit
* 3) if not set the link is locked (all is good), otherwise...
* 4) reset the PHY
* 5) repeat up to 10 times
* Note: this is only called for IGP3 copper when speed is 1gb.
*
* hw - struct containing variables accessed by shared code
******************************************************************************/
int32_t
em_kumeran_lock_loss_workaround(struct em_hw *hw)
{
    int32_t ret_val;
    int32_t reg;
    int32_t cnt;
    uint16_t phy_data;

    if (hw->kmrn_lock_loss_workaround_disabled)
        return E1000_SUCCESS;

    /* Make sure link is up before proceeding. If not just return. 
     * Attempting this while link is negotiating fouls up link
     * stability */
    ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
    ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);

    if (phy_data & MII_SR_LINK_STATUS) {
        for (cnt = 0; cnt < 10; cnt++) {
            /* read once to clear */
            ret_val = em_read_phy_reg(hw, IGP3_KMRN_DIAG, &phy_data);
            if (ret_val)
                return ret_val;
            /* and again to get new status */
            ret_val = em_read_phy_reg(hw, IGP3_KMRN_DIAG, &phy_data);
            if (ret_val)
                return ret_val;

            /* check for PCS lock */
            if (!(phy_data & IGP3_KMRN_DIAG_PCS_LOCK_LOSS))
                return E1000_SUCCESS;

            /* Issue PHY reset */
            em_phy_hw_reset(hw);
            msec_delay_irq(5);
        }
        /* Disable GigE link negotiation */
        reg = E1000_READ_REG(hw, PHY_CTRL);
        E1000_WRITE_REG(hw, PHY_CTRL, reg | E1000_PHY_CTRL_GBE_DISABLE |
                        E1000_PHY_CTRL_NOND0A_GBE_DISABLE);

        /* unable to acquire PCS lock */
        return E1000_ERR_PHY;
    }

    return E1000_SUCCESS;
}

/******************************************************************************
* Probes the expected PHY address for known PHY IDs
*
* hw - Struct containing variables accessed by shared code
******************************************************************************/
int32_t
em_detect_gig_phy(struct em_hw *hw)
{
    int32_t phy_init_status, ret_val;
    uint16_t phy_id_high, phy_id_low;
    boolean_t match = FALSE;

    DEBUGFUNC("em_detect_gig_phy");

    /* The 82571 firmware may still be configuring the PHY.  In this
     * case, we cannot access the PHY until the configuration is done.  So
     * we explicitly set the PHY values. */
    if (hw->mac_type == em_82571 ||
        hw->mac_type == em_82572) {
        hw->phy_id = IGP01E1000_I_PHY_ID;
        hw->phy_type = em_phy_igp_2;
        return E1000_SUCCESS;
    }

    /* ESB-2 PHY reads require em_phy_gg82563 to be set because of a work-
     * around that forces PHY page 0 to be set or the reads fail.  The rest of
     * the code in this routine uses em_read_phy_reg to read the PHY ID.
     * So for ESB-2 we need to have this set so our reads won't fail.  If the
     * attached PHY is not a em_phy_gg82563, the routines below will figure
     * this out as well. */
    if (hw->mac_type == em_80003es2lan)
        hw->phy_type = em_phy_gg82563;

    /* Read the PHY ID Registers to identify which PHY is onboard. */
    ret_val = em_read_phy_reg(hw, PHY_ID1, &phy_id_high);
    if (ret_val)
        return ret_val;

    hw->phy_id = (uint32_t) (phy_id_high << 16);
    usec_delay(20);
    ret_val = em_read_phy_reg(hw, PHY_ID2, &phy_id_low);
    if (ret_val)
        return ret_val;

    hw->phy_id |= (uint32_t) (phy_id_low & PHY_REVISION_MASK);
    hw->phy_revision = (uint32_t) phy_id_low & ~PHY_REVISION_MASK;

    switch (hw->mac_type) {
    case em_82543:
        if (hw->phy_id == M88E1000_E_PHY_ID) match = TRUE;
d3706 1
a3706 1
        if (hw->phy_id == M88E1000_I_PHY_ID) match = TRUE;
d3713 1
a3713 1
        if (hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
d3719 1
a3719 1
        if (hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
d3722 1
a3722 1
        if (hw->phy_id == M88E1111_I_PHY_ID) match = TRUE;
a3726 6
    case em_ich8lan:
        if (hw->phy_id == IGP03E1000_E_PHY_ID) match = TRUE;
        if (hw->phy_id == IFE_E_PHY_ID) match = TRUE;
        if (hw->phy_id == IFE_PLUS_E_PHY_ID) match = TRUE;
        if (hw->phy_id == IFE_C_E_PHY_ID) match = TRUE;
        break;
d3755 1
a3755 1
            if (ret_val) break;
d3758 1
a3758 1
        if (ret_val) break;
d3760 1
a3760 1
        if (ret_val) break;
d3762 1
a3762 1
    } while (0);
d3794 1
a3794 1
    if (ret_val)
d3800 1
a3800 1
    if (ret_val)
d3806 1
a3806 1
    if ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
d3810 1
a3810 1
        if (ret_val)
d3820 1
a3820 1
        if (ret_val)
d3826 1
a3826 1
        if (average <= em_igp_cable_length_50)
d3828 1
a3828 1
        else if (average <= em_igp_cable_length_80)
d3830 1
a3830 1
        else if (average <= em_igp_cable_length_110)
d3832 1
a3832 1
        else if (average <= em_igp_cable_length_140)
a3841 47
* Get PHY information from various PHY registers for ife PHY only.
*
* hw - Struct containing variables accessed by shared code
* phy_info - PHY information structure
******************************************************************************/
int32_t
em_phy_ife_get_info(struct em_hw *hw,
                       struct em_phy_info *phy_info)
{
    int32_t ret_val;
    uint16_t phy_data, polarity;

    DEBUGFUNC("em_phy_ife_get_info");

    phy_info->downshift = (em_downshift)hw->speed_downgraded;
    phy_info->extended_10bt_distance = em_10bt_ext_dist_enable_normal;

    ret_val = em_read_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL, &phy_data);
    if (ret_val)
        return ret_val;
    phy_info->polarity_correction =
                        (phy_data & IFE_PSC_AUTO_POLARITY_DISABLE) >>
                        IFE_PSC_AUTO_POLARITY_DISABLE_SHIFT;

    if (phy_info->polarity_correction == em_polarity_reversal_enabled) {
        ret_val = em_check_polarity(hw, &polarity);
        if (ret_val)
            return ret_val;
    } else {
        /* Polarity is forced. */
        polarity = (phy_data & IFE_PSC_FORCE_POLARITY) >>
                       IFE_PSC_FORCE_POLARITY_SHIFT;
    }
    phy_info->cable_polarity = polarity;

    ret_val = em_read_phy_reg(hw, IFE_PHY_MDIX_CONTROL, &phy_data);
    if (ret_val)
        return ret_val;

    phy_info->mdix_mode =
                     (phy_data & (IFE_PMC_AUTO_MDIX | IFE_PMC_FORCE_MDIX)) >>
                     IFE_PMC_MDIX_MODE_SHIFT;

    return E1000_SUCCESS;
}

/******************************************************************************
d3861 1
a3861 1
    if (ret_val)
d3873 2
a3874 2
    if (ret_val)
        return ret_val;
d3878 1
a3878 1
    if (ret_val)
d3901 1
a3901 1
        if (ret_val)
d3938 1
a3938 1
    if (hw->media_type != em_media_type_copper) {
d3944 1
a3944 1
    if (ret_val)
d3948 1
a3948 1
    if (ret_val)
d3951 1
a3951 1
    if ((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {
d3956 1
a3956 2
    if (hw->phy_type == em_phy_igp ||
        hw->phy_type == em_phy_igp_3 ||
a3958 2
    else if (hw->phy_type == em_phy_ife)
        return em_phy_ife_get_info(hw, phy_info);
d3968 1
a3968 1
    if (!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {
d4015 1
a4015 1
        if (eecd & E1000_EECD_SIZE) {
d4083 1
a4083 1
        if (em_is_onboard_nvm_eeprom(hw) == FALSE) {
a4106 29
    case em_ich8lan:
    {
        int32_t  i = 0;
        uint32_t flash_size = E1000_READ_ICH8_REG(hw, ICH8_FLASH_GFPREG);

        eeprom->type = em_eeprom_ich8;
        eeprom->use_eerd = FALSE;
        eeprom->use_eewr = FALSE;
        eeprom->word_size = E1000_SHADOW_RAM_WORDS;

        /* Zero the shadow RAM structure. But don't load it from NVM
         * so as to save time for driver init */
        if (hw->eeprom_shadow_ram != NULL) {
            for (i = 0; i < E1000_SHADOW_RAM_WORDS; i++) {
                hw->eeprom_shadow_ram[i].modified = FALSE;
                hw->eeprom_shadow_ram[i].eeprom_word = 0xFFFF;
            }
        }

        hw->flash_base_addr = (flash_size & ICH8_GFPREG_BASE_MASK) *
                              ICH8_FLASH_SECTOR_SIZE;

        hw->flash_bank_size = ((flash_size >> 16) & ICH8_GFPREG_BASE_MASK) + 1;
        hw->flash_bank_size -= (flash_size & ICH8_GFPREG_BASE_MASK);
        hw->flash_bank_size *= ICH8_FLASH_SECTOR_SIZE;
        hw->flash_bank_size /= 2 * sizeof(uint16_t);

        break;
    }
d4115 1
a4115 1
        if (hw->mac_type <= em_82547_rev_2) {
d4119 1
a4119 1
            if (ret_val)
d4125 1
a4125 1
            if (eeprom_size)
d4210 1
a4210 1
        if (data & mask)
d4223 1
a4223 1
    } while (mask);
d4255 1
a4255 1
    for (i = 0; i < count; i++) {
d4262 1
a4262 1
        if (eecd & E1000_EECD_DO)
d4293 1
a4293 1
        if (hw->mac_type > em_82544) {
d4297 1
a4297 1
            while ((!(eecd & E1000_EECD_GNT)) &&
d4303 1
a4303 1
            if (!(eecd & E1000_EECD_GNT)) {
d4346 1
a4346 1
    if (eeprom->type == em_eeprom_microwire) {
d4369 1
a4369 1
    } else if (eeprom->type == em_eeprom_spi) {
d4403 1
a4403 1
    } else if (hw->eeprom.type == em_eeprom_microwire) {
d4425 1
a4425 1
    if (hw->mac_type > em_82544) {
d4463 1
a4463 1
    } while (retry_count < EEPROM_MAX_RETRY_SPI);
d4468 1
a4468 1
    if (retry_count >= EEPROM_MAX_RETRY_SPI) {
d4499 1
a4499 1
    if ((offset >= eeprom->word_size) || (words > eeprom->word_size - offset) ||
d4507 1
a4507 1
        hw->eeprom.use_eerd == FALSE) {
d4527 1
a4527 4
    if (eeprom->type == em_eeprom_ich8)
        return em_read_eeprom_ich8(hw, offset, words, data);

    if (eeprom->type == em_eeprom_spi) {
d4531 1
a4531 1
        if (em_spi_eeprom_ready(hw)) {
d4539 1
a4539 1
        if ((eeprom->address_bits == 8) && (offset >= 128))
d4555 1
a4555 1
    } else if (eeprom->type == em_eeprom_microwire) {
d4599 2
a4600 2

        if (error) {
d4604 1
a4604 1

d4606 1
a4606 1

d4632 2
a4633 2
        register_value = (data[i] << E1000_EEPROM_RW_REG_DATA) |
                         ((offset+i) << E1000_EEPROM_RW_ADDR_SHIFT) |
d4637 1
a4637 1
        if (error) {
d4639 1
a4639 1
        }
d4642 1
a4642 1

d4644 2
a4645 2

        if (error) {
d4647 1
a4647 1
        }
d4649 1
a4649 1

d4666 2
a4667 2
    for (i = 0; i < attempts; i++) {
        if (eerd == E1000_EEPROM_POLL_READ)
d4669 1
a4669 1
        else
d4672 1
a4672 1
        if (reg & E1000_EEPROM_RW_REG_DONE) {
d4694 1
a4694 4
    if (hw->mac_type == em_ich8lan)
        return FALSE;

    if (hw->mac_type == em_82573) {
d4701 1
a4701 1
        if (eecd == 0x03) {
d4744 2
a4745 16
    if (hw->mac_type == em_ich8lan) {
        /* Drivers must allocate the shadow ram structure for the
         * EEPROM checksum to be updated.  Otherwise, this bit as well
         * as the checksum must both be set correctly for this
         * validation to pass.
         */
        em_read_eeprom(hw, 0x19, 1, &eeprom_data);
        if ((eeprom_data & 0x40) == 0) {
            eeprom_data |= 0x40;
            em_write_eeprom(hw, 0x19, 1, &eeprom_data);
            em_update_eeprom_checksum(hw);
        }
    }

    for (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
        if (em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
d4752 1
a4752 1
    if (checksum == (uint16_t) EEPROM_SUM)
a4770 1
    uint32_t ctrl_ext;
d4776 2
a4777 2
    for (i = 0; i < EEPROM_CHECKSUM_REG; i++) {
        if (em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
d4784 1
a4784 1
    if (em_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
a4788 8
    } else if (hw->eeprom.type == em_eeprom_ich8) {
        em_commit_shadow_ram(hw);
        /* Reload the EEPROM, or else modifications will not appear
         * until after next adapter reset. */
        ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
        ctrl_ext |= E1000_CTRL_EXT_EE_RST;
        E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
        msec_delay(10);
d4818 1
a4818 1
    if ((offset >= eeprom->word_size) || (words > eeprom->word_size - offset) ||
d4825 1
a4825 1
    if (eeprom->use_eewr == TRUE)
a4827 3
    if (eeprom->type == em_eeprom_ich8)
        return em_write_eeprom_ich8(hw, offset, words, data);

d4832 1
a4832 1
    if (eeprom->type == em_eeprom_microwire) {
d4868 1
a4868 1
        if (em_spi_eeprom_ready(hw)) return -E1000_ERR_EEPROM;
d4879 1
a4879 1
        if ((eeprom->address_bits == 8) && (offset >= 128))
d4901 1
a4901 1
            if ((((offset + widx)*2) % eeprom->page_size) == 0) {
d4967 1
a4967 1
        for (i = 0; i < 200; i++) {
d4969 1
a4969 1
            if (eecd & E1000_EECD_DO) break;
d4972 1
a4972 1
        if (i == 200) {
d5015 3
a5017 7
    uint32_t old_bank_offset = 0;
    uint32_t new_bank_offset = 0;
    uint32_t sector_retries = 0;
    uint8_t low_byte = 0;
    uint8_t high_byte = 0;
    uint8_t temp_byte = 0;
    boolean_t sector_write_failed = FALSE;
a5019 2
        /* The flop register will be used to determine if flash type is STM */
        flop = E1000_READ_REG(hw, FLOP);
a5052 100
    if (hw->mac_type == em_ich8lan && hw->eeprom_shadow_ram != NULL) {
        /* We're writing to the opposite bank so if we're on bank 1,
         * write to bank 0 etc.  We also need to erase the segment that
         * is going to be written */
        if (!(E1000_READ_REG(hw, EECD) & E1000_EECD_SEC1VAL)) {
            new_bank_offset = hw->flash_bank_size * 2;
            old_bank_offset = 0;
            em_erase_ich8_4k_segment(hw, 1);
        } else {
            old_bank_offset = hw->flash_bank_size * 2;
            new_bank_offset = 0;
            em_erase_ich8_4k_segment(hw, 0);
        }

        do {
            sector_write_failed = FALSE;
            /* Loop for every byte in the shadow RAM,
             * which is in units of words. */
            for (i = 0; i < E1000_SHADOW_RAM_WORDS; i++) {
                /* Determine whether to write the value stored
                 * in the other NVM bank or a modified value stored
                 * in the shadow RAM */
                if (hw->eeprom_shadow_ram[i].modified == TRUE) {
                    low_byte = (uint8_t)hw->eeprom_shadow_ram[i].eeprom_word;
                    em_read_ich8_byte(hw, (i << 1) + old_bank_offset,
                                         &temp_byte);
                    usec_delay(100);
                    error = em_verify_write_ich8_byte(hw,
                                                 (i << 1) + new_bank_offset,
                                                 low_byte);
                    if (error != E1000_SUCCESS)
                        sector_write_failed = TRUE;
                    high_byte =
                        (uint8_t)(hw->eeprom_shadow_ram[i].eeprom_word >> 8);
                    em_read_ich8_byte(hw, (i << 1) + old_bank_offset + 1,
                                         &temp_byte);
                    usec_delay(100);
                } else {
                    em_read_ich8_byte(hw, (i << 1) + old_bank_offset,
                                         &low_byte);
                    usec_delay(100);
                    error = em_verify_write_ich8_byte(hw,
                                 (i << 1) + new_bank_offset, low_byte);
                    if (error != E1000_SUCCESS)
                        sector_write_failed = TRUE;
                    em_read_ich8_byte(hw, (i << 1) + old_bank_offset + 1,
                                         &high_byte);
                }

                /* If the word is 0x13, then make sure the signature bits
                 * (15:14) are 11b until the commit has completed.
                 * This will allow us to write 10b which indicates the
                 * signature is valid.  We want to do this after the write
                 * has completed so that we don't mark the segment valid
                 * while the write is still in progress */
                if (i == E1000_ICH8_NVM_SIG_WORD)
                    high_byte = E1000_ICH8_NVM_SIG_MASK | high_byte;

                error = em_verify_write_ich8_byte(hw,
                             (i << 1) + new_bank_offset + 1, high_byte);
                if (error != E1000_SUCCESS)
                    sector_write_failed = TRUE;

                if (sector_write_failed == FALSE) {
                    /* Clear the now not used entry in the cache */
                    hw->eeprom_shadow_ram[i].modified = FALSE;
                    hw->eeprom_shadow_ram[i].eeprom_word = 0xFFFF;
                }
            }

            /* Don't bother writing the segment valid bits if sector
             * programming failed. */
            if (sector_write_failed == FALSE) {
                /* Finally validate the new segment by setting bit 15:14
                 * to 10b in word 0x13 , this can be done without an
                 * erase as well since these bits are 11 to start with
                 * and we need to change bit 14 to 0b */
                em_read_ich8_byte(hw,
                    E1000_ICH8_NVM_SIG_WORD * 2 + 1 + new_bank_offset,
                    &high_byte);
                high_byte &= 0xBF;
                error = em_verify_write_ich8_byte(hw,
                            E1000_ICH8_NVM_SIG_WORD * 2 + 1 + new_bank_offset,
                            high_byte);
                if (error != E1000_SUCCESS)
                    sector_write_failed = TRUE;

                /* And invalidate the previously valid segment by setting
                 * its signature word (0x13) high_byte to 0b. This can be
                 * done without an erase because flash erase sets all bits
                 * to 1's. We can write 1's to 0's without an erase */
                error = em_verify_write_ich8_byte(hw,
                            E1000_ICH8_NVM_SIG_WORD * 2 + 1 + old_bank_offset,
                            0);
                if (error != E1000_SUCCESS)
                    sector_write_failed = TRUE;
            }
        } while (++sector_retries < 10 && sector_write_failed == TRUE);
    }

d5072 1
a5072 1
    if (em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
d5080 1
a5080 1
    if (em_read_eeprom(hw, ++offset, 1, &eeprom_data) < 0) {
d5104 1
a5104 1
    for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
d5106 1
a5106 1
        if (em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
d5121 1
a5121 1
        if (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)
d5126 1
a5126 1
    for (i = 0; i < NODE_ADDRESS_SIZE; i++)
a5159 3
    if (hw->mac_type == em_ich8lan)
        rar_num = E1000_RAR_ENTRIES_ICH8LAN;

d5162 1
a5162 1
    for (i = 1; i < rar_num; i++) {
a5163 1
        E1000_WRITE_FLUSH(hw);
a5164 1
        E1000_WRITE_FLUSH(hw);
d5193 1
a5193 1

a5201 2
    if (hw->mac_type == em_ich8lan)
        num_rar_entry = E1000_RAR_ENTRIES_ICH8LAN;
d5208 1
a5208 1
    for (i = rar_used_count; i < num_rar_entry; i++) {
a5209 1
        E1000_WRITE_FLUSH(hw);
a5210 1
        E1000_WRITE_FLUSH(hw);
d5216 1
a5216 3
    if (hw->mac_type == em_ich8lan)
        num_mta_entry = E1000_NUM_MTA_REGISTERS_ICH8LAN;
    for (i = 0; i < num_mta_entry; i++) {
a5217 1
        E1000_WRITE_FLUSH(hw);
d5221 1
a5221 1
    for (i = 0; i < mc_addr_count; i++) {
d5273 2
a5274 7
        if (hw->mac_type == em_ich8lan) {
            /* [47:38] i.e. 0x158 for above example address */
            hash_value = ((mc_addr[4] >> 6) | (((uint16_t) mc_addr[5]) << 2));
        } else {
            /* [47:36] i.e. 0x563 for above example address */
            hash_value = ((mc_addr[4] >> 4) | (((uint16_t) mc_addr[5]) << 4));
        }
d5277 2
a5278 7
        if (hw->mac_type == em_ich8lan) {
            /* [46:37] i.e. 0x2B1 for above example address */
            hash_value = ((mc_addr[4] >> 5) | (((uint16_t) mc_addr[5]) << 3));
        } else {
            /* [46:35] i.e. 0xAC6 for above example address */
            hash_value = ((mc_addr[4] >> 3) | (((uint16_t) mc_addr[5]) << 5));
        }
d5281 2
a5282 7
        if (hw->mac_type == em_ich8lan) {
            /*[45:36] i.e. 0x163 for above example address */
            hash_value = ((mc_addr[4] >> 4) | (((uint16_t) mc_addr[5]) << 4));
        } else {
            /* [45:34] i.e. 0x5D8 for above example address */
            hash_value = ((mc_addr[4] >> 2) | (((uint16_t) mc_addr[5]) << 6));
        }
d5285 2
a5286 7
        if (hw->mac_type == em_ich8lan) {
            /* [43:34] i.e. 0x18D for above example address */
            hash_value = ((mc_addr[4] >> 2) | (((uint16_t) mc_addr[5]) << 6));
        } else {
            /* [43:32] i.e. 0x634 for above example address */
            hash_value = ((mc_addr[4]) | (((uint16_t) mc_addr[5]) << 8));
        }
a5290 2
    if (hw->mac_type == em_ich8lan)
        hash_value &= 0x3FF;
a5317 2
    if (hw->mac_type == em_ich8lan)
        hash_reg &= 0x1F;
d5328 1
a5328 1
    if ((hw->mac_type == em_82544) && ((hash_reg & 0x1) == 1)) {
a5330 1
        E1000_WRITE_FLUSH(hw);
a5331 1
        E1000_WRITE_FLUSH(hw);
a5333 1
        E1000_WRITE_FLUSH(hw);
a5389 1
    E1000_WRITE_FLUSH(hw);
a5390 1
    E1000_WRITE_FLUSH(hw);
d5407 1
a5407 4
    if (hw->mac_type == em_ich8lan)
        return;

    if ((hw->mac_type == em_82544) && ((offset & 0x1) == 1)) {
a5409 1
        E1000_WRITE_FLUSH(hw);
a5410 1
        E1000_WRITE_FLUSH(hw);
a5412 1
        E1000_WRITE_FLUSH(hw);
a5428 3
    if (hw->mac_type == em_ich8lan)
        return;

a5447 1
        E1000_WRITE_FLUSH(hw);
d5463 1
a5463 1
    if (hw->mac_type < em_82540) {
d5473 1
a5473 1
    if (em_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {
d5477 3
a5479 12

    if ((hw->mac_type == em_82573) &&
        (eeprom_data == ID_LED_RESERVED_82573))
        eeprom_data = ID_LED_DEFAULT_82573;
    else if ((eeprom_data == ID_LED_RESERVED_0000) ||
            (eeprom_data == ID_LED_RESERVED_FFFF)) {
        if (hw->mac_type == em_ich8lan)
            eeprom_data = ID_LED_DEFAULT_ICH8LAN;
        else
            eeprom_data = ID_LED_DEFAULT;
    }
    for (i = 0; i < 4; i++) {
d5481 1
a5481 1
        switch (temp) {
d5498 1
a5498 1
        switch (temp) {
d5532 1
a5532 1
    switch (hw->mac_type) {
d5546 1
a5546 1
        if (ret_val)
d5551 1
a5551 1
        if (ret_val)
d5553 1
a5553 1
        /* FALLTHROUGH */
d5555 1
a5555 1
        if (hw->media_type == em_media_type_fiber) {
d5566 1
a5566 1
        } else if (hw->media_type == em_media_type_copper)
a5573 39

/******************************************************************************
 * Used on 82571 and later Si that has LED blink bits.
 * Callers must use their own timer and should have already called
 * em_id_led_init()
 * Call em_cleanup led() to stop blinking
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_blink_led_start(struct em_hw *hw)
{
    int16_t  i;
    uint32_t ledctl_blink = 0;

    DEBUGFUNC("em_id_led_blink_on");

    if (hw->mac_type < em_82571) {
        /* Nothing to do */
        return E1000_SUCCESS;
    }
    if (hw->media_type == em_media_type_fiber) {
        /* always blink LED0 for PCI-E fiber */
        ledctl_blink = E1000_LEDCTL_LED0_BLINK |
                     (E1000_LEDCTL_MODE_LED_ON << E1000_LEDCTL_LED0_MODE_SHIFT);
    } else {
        /* set the blink bit for each LED that's "on" (0x0E) in ledctl_mode2 */
        ledctl_blink = hw->ledctl_mode2;
        for (i=0; i < 4; i++)
            if (((hw->ledctl_mode2 >> (i * 8)) & 0xFF) ==
                E1000_LEDCTL_MODE_LED_ON)
                ledctl_blink |= (E1000_LEDCTL_LED0_BLINK << (i * 8));
    }

    E1000_WRITE_REG(hw, LEDCTL, ledctl_blink);

    return E1000_SUCCESS;
}

d5586 1
a5586 1
    switch (hw->mac_type) {
d5600 1
a5600 1
        if (ret_val)
d5602 1
a5602 1
        /* FALLTHROUGH */
a5603 4
        if (hw->phy_type == em_phy_ife) {
            em_write_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL_LED, 0);
            break;
        }
d5624 1
a5624 1
    switch (hw->mac_type) {
d5633 1
a5633 1
        if (hw->media_type == em_media_type_fiber) {
d5644 1
a5644 1
        if (hw->media_type == em_media_type_fiber) {
d5648 1
a5648 4
        } else if (hw->phy_type == em_phy_ife) {
            em_write_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL_LED,
                 (IFE_PSCL_PROBE_MODE | IFE_PSCL_PROBE_LEDS_ON));
        } else if (hw->media_type == em_media_type_copper) {
d5672 1
a5672 1
    switch (hw->mac_type) {
d5681 1
a5681 1
        if (hw->media_type == em_media_type_fiber) {
d5692 1
a5692 1
        if (hw->media_type == em_media_type_fiber) {
d5696 1
a5696 4
        } else if (hw->phy_type == em_phy_ife) {
            em_write_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL_LED,
                 (IFE_PSCL_PROBE_MODE | IFE_PSCL_PROBE_LEDS_OFF));
        } else if (hw->media_type == em_media_type_copper) {
a5733 2

    if (hw->mac_type != em_ich8lan) {
a5739 2
    }

a5758 2

    if (hw->mac_type != em_ich8lan) {
a5764 2
    }

d5768 1
a5768 1
    if (hw->mac_type < em_82543) return;
d5777 1
a5777 1
    if (hw->mac_type <= em_82544) return;
d5783 1
a5783 1
    if (hw->mac_type <= em_82547_rev_2) return;
a5786 3

    if (hw->mac_type == em_ich8lan) return;

d5811 2
a5812 2
    if (hw->adaptive_ifs) {
        if (!hw->ifs_params_forced) {
d5839 3
a5841 3
    if (hw->adaptive_ifs) {
        if ((hw->collision_delta * hw->ifs_ratio) > hw->tx_packet_delta) {
            if (hw->tx_packet_delta > MIN_NUM_XMITS) {
d5843 2
a5844 2
                if (hw->current_ifs_val < hw->ifs_max_val) {
                    if (hw->current_ifs_val == 0)
d5852 1
a5852 1
            if (hw->in_ifs_mode && (hw->tx_packet_delta <= MIN_NUM_XMITS)) {
d5899 1
a5899 1
    if (carry_bit && ((stats->gorcl & 0x80000000) == 0))
d5905 1
a5905 1
    if ((mac_addr[0] == (uint8_t) 0xff) && (mac_addr[1] == (uint8_t) 0xff))
d5908 1
a5908 1
    else if (*mac_addr & 0x01)
d5912 1
a5912 1
    if (frame_len == hw->max_frame_size) {
d5916 1
a5916 1
        if (stats->roc > 0)
d5923 1
a5923 1
    if (frame_len == 64) {
d5926 1
a5926 1
    } else if (frame_len == 127) {
d5929 1
a5929 1
    } else if (frame_len == 255) {
d5932 1
a5932 1
    } else if (frame_len == 511) {
d5935 1
a5935 1
    } else if (frame_len == 1023) {
d5938 1
a5938 1
    } else if (frame_len == 1522) {
a5966 1
    case em_ich8lan:
d5977 1
a5977 1
        if (hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
d5980 1
a5980 1
        } else if (hw->bus_type == em_bus_type_pci) {
d6065 2
d6075 1
a6075 1
    if (hw->phy_type == em_phy_m88) {
d6079 1
a6079 1
        if (ret_val)
d6138 1
a6138 3
    } else if (hw->phy_type == em_phy_igp) { /* For IGP PHY */
        uint16_t cur_agc_value;
        uint16_t min_agc_value = IGP01E1000_AGC_LENGTH_TABLE_SIZE;
d6145 1
a6145 1
        for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
d6148 1
a6148 1
            if (ret_val)
d6151 1
a6151 1
            cur_agc_value = phy_data >> IGP01E1000_AGC_LENGTH_SHIFT;
d6153 3
a6155 3
            /* Value bound check. */
            if ((cur_agc_value >= IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1) ||
                (cur_agc_value == 0))
d6158 1
a6158 1
            agc_value += cur_agc_value;
d6161 2
a6162 2
            if (min_agc_value > cur_agc_value)
                min_agc_value = cur_agc_value;
d6166 2
a6167 2
        if (agc_value < IGP01E1000_PHY_CHANNEL_NUM * em_igp_cable_length_50) {
            agc_value -= min_agc_value;
d6183 1
a6183 4
    } else if (hw->phy_type == em_phy_igp_2 ||
               hw->phy_type == em_phy_igp_3) {
        uint16_t cur_agc_index, max_agc_index = 0;
        uint16_t min_agc_index = IGP02E1000_AGC_LENGTH_TABLE_SIZE - 1;
d6195 1
a6195 1
            /* Getting bits 15:9, which represent the combination of course and
d6198 2
a6199 7
            cur_agc_index = (phy_data >> IGP02E1000_AGC_LENGTH_SHIFT) &
                            IGP02E1000_AGC_LENGTH_MASK;

            /* Array index bound check. */
            if ((cur_agc_index >= IGP02E1000_AGC_LENGTH_TABLE_SIZE) ||
                (cur_agc_index == 0))
                return -E1000_ERR_PHY;
d6202 4
a6205 6
            if (em_igp_2_cable_length_table[min_agc_index] >
                em_igp_2_cable_length_table[cur_agc_index])
                min_agc_index = cur_agc_index;
            if (em_igp_2_cable_length_table[max_agc_index] <
                em_igp_2_cable_length_table[cur_agc_index])
                max_agc_index = cur_agc_index;
d6207 1
a6207 1
            agc_value += em_igp_2_cable_length_table[cur_agc_index];
d6210 1
a6210 2
        agc_value -= (em_igp_2_cable_length_table[min_agc_index] +
                      em_igp_2_cable_length_table[max_agc_index]);
d6252 1
a6252 1
        if (ret_val)
d6256 1
a6256 2
    } else if (hw->phy_type == em_phy_igp ||
              hw->phy_type == em_phy_igp_3 ||
d6261 1
a6261 1
        if (ret_val)
d6266 1
a6266 1
        if ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
d6272 1
a6272 1
            if (ret_val)
a6281 7
    } else if (hw->phy_type == em_phy_ife) {
        ret_val = em_read_phy_reg(hw, IFE_PHY_EXTENDED_STATUS_CONTROL,
                                     &phy_data);
        if (ret_val)
            return ret_val;
        *polarity = (phy_data & IFE_PESC_POLARITY_REVERSED) >>
                           IFE_PESC_POLARITY_REVERSED_SHIFT;
d6294 1
a6294 1
 *            E1000_SUCCESS
d6309 1
a6309 2
    if (hw->phy_type == em_phy_igp ||
        hw->phy_type == em_phy_igp_3 ||
d6313 1
a6313 1
        if (ret_val)
d6321 1
a6321 1
        if (ret_val)
a6325 3
    } else if (hw->phy_type == em_phy_ife) {
        /* em_phy_ife supports 10/100 speed only */
        hw->speed_downgraded = FALSE;
d6358 1
a6358 1
    if (hw->phy_type != em_phy_igp)
d6361 1
a6361 1
    if (link_up) {
d6363 1
a6363 1
        if (ret_val) {
d6368 1
a6368 1
        if (speed == SPEED_1000) {
d6370 1
a6370 3
            ret_val = em_get_cable_length(hw, &min_length, &max_length);
            if (ret_val)
                return ret_val;
d6372 1
a6372 1
            if ((hw->dsp_config_state == em_dsp_config_enabled) &&
d6375 1
a6375 1
                for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
d6378 1
a6378 1
                    if (ret_val)
d6385 1
a6385 1
                    if (ret_val)
d6391 1
a6391 1
            if ((hw->ffe_config_state == em_ffe_config_enabled) &&
d6400 1
a6400 1
                if (ret_val)
d6403 1
a6403 1
                for (i = 0; i < ffe_idle_err_timeout; i++) {
d6407 1
a6407 1
                    if (ret_val)
d6411 1
a6411 1
                    if (idle_errs > SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {
d6417 1
a6417 1
                        if (ret_val)
d6422 1
a6422 1
                    if (idle_errs)
d6428 1
a6428 1
        if (hw->dsp_config_state == em_dsp_config_activated) {
d6433 1
a6433 1
            if (ret_val)
d6439 1
a6439 1
            if (ret_val)
d6446 1
a6446 1
            if (ret_val)
d6448 1
a6448 1
            for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
d6450 1
a6450 1
                if (ret_val)
d6457 1
a6457 1
                if (ret_val)
d6463 1
a6463 1
            if (ret_val)
d6471 1
a6471 1
            if (ret_val)
d6477 1
a6477 1
        if (hw->ffe_config_state == em_ffe_config_active) {
d6482 1
a6482 1
            if (ret_val)
d6488 1
a6488 1
            if (ret_val)
d6495 1
a6495 1
            if (ret_val)
d6499 1
a6499 1
            if (ret_val)
d6504 1
a6504 1
            if (ret_val)
d6512 1
a6512 1
            if (ret_val)
d6537 2
a6538 2
    if ((hw->mac_type == em_82545_rev_3) &&
        (hw->media_type == em_media_type_copper)) {
d6540 1
a6540 1
        if (ret_val) {
d6544 2
a6545 2
        if ((eeprom_data != EEPROM_RESERVED_WORD) &&
            (eeprom_data & EEPROM_PHY_CLASS_A)) {
d6547 1
a6547 1
            if (ret_val)
d6550 1
a6550 1
            if (ret_val)
a6577 1
    uint32_t phy_ctrl = 0;
d6582 1
a6582 2
    if (hw->phy_type != em_phy_igp && hw->phy_type != em_phy_igp_2
        && hw->phy_type != em_phy_igp_3)
d6588 1
a6588 1
    if (hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2) {
d6590 1
a6590 1
        if (ret_val)
a6591 5
    } else if (hw->mac_type == em_ich8lan) {
        /* MAC writes into PHY register based on the state transition
         * and start auto-negotiation. SW driver can overwrite the settings
         * in CSR PHY power control E1000_PHY_CTRL register. */
        phy_ctrl = E1000_READ_REG(hw, PHY_CTRL);
d6594 1
a6594 1
        if (ret_val)
d6598 3
a6600 3
    if (!active) {
        if (hw->mac_type == em_82541_rev_2 ||
            hw->mac_type == em_82547_rev_2) {
d6603 1
a6603 1
            if (ret_val)
a6605 4
            if (hw->mac_type == em_ich8lan) {
                phy_ctrl &= ~E1000_PHY_CTRL_NOND0A_LPLU;
                E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
            } else {
a6610 1
            }
d6620 1
a6620 1
            if (ret_val)
d6626 1
a6626 1
            if (ret_val)
d6637 1
a6637 1
            if (ret_val)
d6641 3
a6643 3
    } else if ((hw->autoneg_advertised == AUTONEG_ADVERTISE_SPEED_DEFAULT) ||
               (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_ALL ) ||
               (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_100_ALL)) {
d6645 2
a6646 2
        if (hw->mac_type == em_82541_rev_2 ||
            hw->mac_type == em_82547_rev_2) {
d6649 1
a6649 1
            if (ret_val)
a6651 4
            if (hw->mac_type == em_ich8lan) {
                phy_ctrl |= E1000_PHY_CTRL_NOND0A_LPLU;
                E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
            } else {
a6656 1
            }
d6661 1
a6661 1
        if (ret_val)
d6666 1
a6666 1
        if (ret_val)
a6690 1
    uint32_t phy_ctrl = 0;
d6695 1
a6695 1
    if (hw->mac_type <= em_82547_rev_2)
a6697 3
    if (hw->mac_type == em_ich8lan) {
        phy_ctrl = E1000_READ_REG(hw, PHY_CTRL);
    } else {
d6699 1
a6699 1
        if (ret_val)
a6700 1
    }
a6702 4
        if (hw->mac_type == em_ich8lan) {
            phy_ctrl &= ~E1000_PHY_CTRL_D0A_LPLU;
            E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
        } else {
a6706 1
        }
d6715 1
a6715 1
            if (ret_val)
d6721 1
a6721 1
            if (ret_val)
d6732 1
a6732 1
            if (ret_val)
d6738 2
a6739 6

        if (hw->mac_type == em_ich8lan) {
            phy_ctrl |= E1000_PHY_CTRL_D0A_LPLU;
            E1000_WRITE_REG(hw, PHY_CTRL, phy_ctrl);
        } else {
            phy_data |= IGP02E1000_PM_D0_LPLU;
a6742 1
        }
d6746 1
a6746 1
        if (ret_val)
d6751 1
a6751 1
        if (ret_val)
d6772 1
a6772 1
    switch (hw->mac_type) {
d6783 1
a6783 1
    if (ret_val)
d6787 1
a6787 1
    if (ret_val)
d6791 1
a6791 1
    if (ret_val)
d6796 1
a6796 1
    if (ret_val)
d6802 1
a6802 1
    if (ret_val)
d6806 1
a6806 1
    if (ret_val)
d6811 1
a6811 1
    if (ret_val)
d6815 1
a6815 1
    if (ret_val)
d6831 1
a6831 1
    uint32_t offset = E1000_MNG_DHCP_COOKIE_OFFSET;
d6850 1
a6850 1
 * returns: - E1000_ERR_HOST_INTERFACE_COMMAND in case if is not ready or
d6874 1
a6874 1
    if (i == E1000_MNG_DHCP_COMMAND_TIMEOUT) {
d6894 1
a6894 1
    uint32_t data = 0;
d6974 1
a6974 1
    while (i--)
d6981 1
a6981 1
    for (i = 0; i < length; i++) {
a6982 2
        E1000_WRITE_FLUSH(hw);
    }
d6995 2
a6996 1
em_mng_write_commit(struct em_hw * hw)
d7014 2
a7015 1
em_check_mng_mode(struct em_hw *hw)
d7021 2
a7022 6
    if (hw->mac_type == em_ich8lan) {
        if ((fwsm & E1000_FWSM_MODE_MASK) ==
            (E1000_MNG_ICH_IAMT_MODE << E1000_FWSM_MODE_SHIFT))
            return TRUE;
    } else if ((fwsm & E1000_FWSM_MODE_MASK) ==
               (E1000_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT))
d7165 1
a7165 1
    if (ret_val)
d7168 1
a7168 1
    if (ret_val)
d7172 1
a7172 1
    if (ret_val)
d7176 1
a7176 1
    for (i = PHY_FORCE_TIME; i > 0; i--) {
d7182 1
a7182 1
        if (ret_val)
d7186 1
a7186 1
        if (ret_val)
d7189 1
a7189 1
        if ((mii_status_reg & ~MII_SR_LINK_STATUS) == 0) break;
d7199 1
a7199 1
    if (ret_val)
d7203 1
a7203 1
    if (ret_val)
d7207 1
a7207 1
    if (ret_val)
d7211 1
a7211 1
    if (ret_val)
d7215 1
a7215 1
    if (ret_val)
d7219 1
a7219 1
    for (i = PHY_FORCE_TIME; i > 0; i--) {
d7225 1
a7225 1
        if (ret_val)
d7229 1
a7229 1
        if (ret_val)
d7232 1
a7232 1
        if (mii_status_reg & MII_SR_LINK_STATUS) break;
d7309 2
a7310 2
    while (timeout) {
        if (!(E1000_READ_REG(hw, STATUS) & E1000_STATUS_GIO_MASTER_ENABLE))
d7317 1
a7317 1
    if (!timeout) {
d7350 2
a7351 4
    case em_ich8lan:
        while (timeout) {
            if (E1000_READ_REG(hw, EECD) & E1000_EECD_AUTO_RD)
                break;
d7356 1
a7356 1
        if (!timeout) {
d7391 1
a7391 1
        msec_delay_irq(10);
d7397 1
a7397 1
        /* FALLTHROUGH */
d7437 1
a7437 1
    if (!hw->eeprom_semaphore_present)
d7448 1
a7448 1
    while (timeout) {
d7454 1
a7454 1
        if (swsm & E1000_SWSM_SWESMBI)
d7461 1
a7461 1
    if (!timeout) {
d7486 1
a7486 1
    if (!hw->eeprom_semaphore_present)
d7519 1
a7519 1
    while (timeout) {
d7522 1
a7522 1
        if (!(swsm & E1000_SWSM_SMBI))
d7528 1
a7528 1
    if (!timeout) {
a7573 7
    uint32_t fwsm = 0;

    if (hw->mac_type == em_ich8lan) {
        fwsm = E1000_READ_REG(hw, FWSM);
        return (fwsm & E1000_FWSM_RSPCIPHY) ? E1000_SUCCESS
                                            : E1000_BLK_PHY_RESET;
    }
d7597 1
a7597 1
        if ((fwsm & E1000_FWSM_MODE_MASK) != 0)
a7599 2
    case em_ich8lan:
        return TRUE;
a7603 841
}


/******************************************************************************
 * Configure PCI-Ex no-snoop
 *
 * hw - Struct containing variables accessed by shared code.
 * no_snoop - Bitmap of no-snoop events.
 *
 * returns: E1000_SUCCESS
 *
 *****************************************************************************/
int32_t
em_set_pci_ex_no_snoop(struct em_hw *hw, uint32_t no_snoop)
{
    uint32_t gcr_reg = 0;

    DEBUGFUNC("em_set_pci_ex_no_snoop");

    if (hw->bus_type == em_bus_type_unknown)
        em_get_bus_info(hw);

    if (hw->bus_type != em_bus_type_pci_express)
        return E1000_SUCCESS;

    if (no_snoop) {
        gcr_reg = E1000_READ_REG(hw, GCR);
        gcr_reg &= ~(PCI_EX_NO_SNOOP_ALL);
        gcr_reg |= no_snoop;
        E1000_WRITE_REG(hw, GCR, gcr_reg);
    }
    if (hw->mac_type == em_ich8lan) {
        uint32_t ctrl_ext;

        E1000_WRITE_REG(hw, GCR, PCI_EX_82566_SNOOP_ALL);

        ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
        ctrl_ext |= E1000_CTRL_EXT_RO_DIS;
        E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
    }

    return E1000_SUCCESS;
}

/***************************************************************************
 *
 * Get software semaphore FLAG bit (SWFLAG).
 * SWFLAG is used to synchronize the access to all shared resource between
 * SW, FW and HW.
 *
 * hw: Struct containing variables accessed by shared code
 *
 ***************************************************************************/
int32_t
em_get_software_flag(struct em_hw *hw)
{
    int32_t timeout = PHY_CFG_TIMEOUT;
    uint32_t extcnf_ctrl;

    DEBUGFUNC("em_get_software_flag");

    if (hw->mac_type == em_ich8lan) {
        while (timeout) {
            extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);
            extcnf_ctrl |= E1000_EXTCNF_CTRL_SWFLAG;
            E1000_WRITE_REG(hw, EXTCNF_CTRL, extcnf_ctrl);

            extcnf_ctrl = E1000_READ_REG(hw, EXTCNF_CTRL);
            if (extcnf_ctrl & E1000_EXTCNF_CTRL_SWFLAG)
                break;
            msec_delay_irq(1);
            timeout--;
        }

        if (!timeout) {
            DEBUGOUT("FW or HW locks the resource too long.\n");
            return -E1000_ERR_CONFIG;
        }
    }

    return E1000_SUCCESS;
}

/***************************************************************************
 *
 * Release software semaphore FLAG bit (SWFLAG).
 * SWFLAG is used to synchronize the access to all shared resource between
 * SW, FW and HW.
 *
 * hw: Struct containing variables accessed by shared code
 *
 ***************************************************************************/
void
em_release_software_flag(struct em_hw *hw)
{
    uint32_t extcnf_ctrl;

    DEBUGFUNC("em_release_software_flag");

    if (hw->mac_type == em_ich8lan) {
        extcnf_ctrl= E1000_READ_REG(hw, EXTCNF_CTRL);
        extcnf_ctrl &= ~E1000_EXTCNF_CTRL_SWFLAG;
        E1000_WRITE_REG(hw, EXTCNF_CTRL, extcnf_ctrl);
    }

    return;
}

/***************************************************************************
 *
 * Disable dynamic power down mode in ife PHY.
 * It can be used to workaround band-gap problem.
 *
 * hw: Struct containing variables accessed by shared code
 *
 ***************************************************************************/
int32_t
em_ife_disable_dynamic_power_down(struct em_hw *hw)
{
    uint16_t phy_data;
    int32_t ret_val = E1000_SUCCESS;

    DEBUGFUNC("em_ife_disable_dynamic_power_down");

    if (hw->phy_type == em_phy_ife) {
        ret_val = em_read_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data |=  IFE_PSC_DISABLE_DYNAMIC_POWER_DOWN;
        ret_val = em_write_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL, phy_data);
    }

    return ret_val;
}

/***************************************************************************
 *
 * Enable dynamic power down mode in ife PHY.
 * It can be used to workaround band-gap problem.
 *
 * hw: Struct containing variables accessed by shared code
 *
 ***************************************************************************/
int32_t
em_ife_enable_dynamic_power_down(struct em_hw *hw)
{
    uint16_t phy_data;
    int32_t ret_val = E1000_SUCCESS;

    DEBUGFUNC("em_ife_enable_dynamic_power_down");

    if (hw->phy_type == em_phy_ife) {
        ret_val = em_read_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL, &phy_data);
        if (ret_val)
            return ret_val;

        phy_data &=  ~IFE_PSC_DISABLE_DYNAMIC_POWER_DOWN;
        ret_val = em_write_phy_reg(hw, IFE_PHY_SPECIAL_CONTROL, phy_data);
    }

    return ret_val;
}

/******************************************************************************
 * Reads a 16 bit word or words from the EEPROM using the ICH8's flash access
 * register.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset of word in the EEPROM to read
 * data - word read from the EEPROM
 * words - number of words to read
 *****************************************************************************/
int32_t
em_read_eeprom_ich8(struct em_hw *hw, uint16_t offset, uint16_t words,
                       uint16_t *data)
{
    int32_t  error = E1000_SUCCESS;
    uint32_t flash_bank = 0;
    uint32_t act_offset = 0;
    uint32_t bank_offset = 0;
    uint16_t word = 0;
    uint16_t i = 0;

    /* We need to know which is the valid flash bank.  In the event
     * that we didn't allocate eeprom_shadow_ram, we may not be
     * managing flash_bank.  So it cannot be trusted and needs
     * to be updated with each read.
     */
    /* Value of bit 22 corresponds to the flash bank we're on. */
    flash_bank = (E1000_READ_REG(hw, EECD) & E1000_EECD_SEC1VAL) ? 1 : 0;

    /* Adjust offset appropriately if we're on bank 1 - adjust for word size */
    bank_offset = flash_bank * (hw->flash_bank_size * 2);

    error = em_get_software_flag(hw);
    if (error != E1000_SUCCESS)
        return error;

    for (i = 0; i < words; i++) {
        if (hw->eeprom_shadow_ram != NULL &&
            hw->eeprom_shadow_ram[offset+i].modified == TRUE) {
            data[i] = hw->eeprom_shadow_ram[offset+i].eeprom_word;
        } else {
            /* The NVM part needs a byte offset, hence * 2 */
            act_offset = bank_offset + ((offset + i) * 2);
            error = em_read_ich8_word(hw, act_offset, &word);
            if (error != E1000_SUCCESS)
                break;
            data[i] = word;
        }
    }

    em_release_software_flag(hw);

    return error;
}

/******************************************************************************
 * Writes a 16 bit word or words to the EEPROM using the ICH8's flash access
 * register.  Actually, writes are written to the shadow ram cache in the hw
 * structure hw->em_shadow_ram.  em_commit_shadow_ram flushes this to
 * the NVM, which occurs when the NVM checksum is updated.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset of word in the EEPROM to write
 * words - number of words to write
 * data - words to write to the EEPROM
 *****************************************************************************/
int32_t
em_write_eeprom_ich8(struct em_hw *hw, uint16_t offset, uint16_t words,
                        uint16_t *data)
{
    uint32_t i = 0;
    int32_t error = E1000_SUCCESS;

    error = em_get_software_flag(hw);
    if (error != E1000_SUCCESS)
        return error;

    /* A driver can write to the NVM only if it has eeprom_shadow_ram
     * allocated.  Subsequent reads to the modified words are read from
     * this cached structure as well.  Writes will only go into this
     * cached structure unless it's followed by a call to
     * em_update_eeprom_checksum() where it will commit the changes
     * and clear the "modified" field.
     */
    if (hw->eeprom_shadow_ram != NULL) {
        for (i = 0; i < words; i++) {
            if ((offset + i) < E1000_SHADOW_RAM_WORDS) {
                hw->eeprom_shadow_ram[offset+i].modified = TRUE;
                hw->eeprom_shadow_ram[offset+i].eeprom_word = data[i];
            } else {
                error = -E1000_ERR_EEPROM;
                break;
            }
        }
    } else {
        /* Drivers have the option to not allocate eeprom_shadow_ram as long
         * as they don't perform any NVM writes.  An attempt in doing so
         * will result in this error.
         */
        error = -E1000_ERR_EEPROM;
    }

    em_release_software_flag(hw);

    return error;
}

/******************************************************************************
 * This function does initial flash setup so that a new read/write/erase cycle
 * can be started.
 *
 * hw - The pointer to the hw structure
 ****************************************************************************/
int32_t
em_ich8_cycle_init(struct em_hw *hw)
{
    union ich8_hws_flash_status hsfsts;
    int32_t error = E1000_ERR_EEPROM;
    int32_t i     = 0;

    DEBUGFUNC("em_ich8_cycle_init");

    hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);

    /* May be check the Flash Des Valid bit in Hw status */
    if (hsfsts.hsf_status.fldesvalid == 0) {
        DEBUGOUT("Flash descriptor invalid.  SW Sequencing must be used.");
        return error;
    }

    /* Clear FCERR in Hw status by writing 1 */
    /* Clear DAEL in Hw status by writing a 1 */
    hsfsts.hsf_status.flcerr = 1;
    hsfsts.hsf_status.dael = 1;

    E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFSTS, hsfsts.regval);

    /* Either we should have a hardware SPI cycle in progress bit to check
     * against, in order to start a new cycle or FDONE bit should be changed
     * in the hardware so that it is 1 after harware reset, which can then be
     * used as an indication whether a cycle is in progress or has been
     * completed .. we should also have some software semaphore mechanism to
     * guard FDONE or the cycle in progress bit so that two threads access to
     * those bits can be sequentiallized or a way so that 2 threads dont
     * start the cycle at the same time */

    if (hsfsts.hsf_status.flcinprog == 0) {
        /* There is no cycle running at present, so we can start a cycle */
        /* Begin by setting Flash Cycle Done. */
        hsfsts.hsf_status.flcdone = 1;
        E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFSTS, hsfsts.regval);
        error = E1000_SUCCESS;
    } else {
        /* otherwise poll for sometime so the current cycle has a chance
         * to end before giving up. */
        for (i = 0; i < ICH8_FLASH_COMMAND_TIMEOUT; i++) {
            hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
            if (hsfsts.hsf_status.flcinprog == 0) {
                error = E1000_SUCCESS;
                break;
            }
            usec_delay(1);
        }
        if (error == E1000_SUCCESS) {
            /* Successful in waiting for previous cycle to timeout,
             * now set the Flash Cycle Done. */
            hsfsts.hsf_status.flcdone = 1;
            E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFSTS, hsfsts.regval);
        } else {
            DEBUGOUT("Flash controller busy, cannot get access");
        }
    }
    return error;
}

/******************************************************************************
 * This function starts a flash cycle and waits for its completion
 *
 * hw - The pointer to the hw structure
 ****************************************************************************/
int32_t
em_ich8_flash_cycle(struct em_hw *hw, uint32_t timeout)
{
    union ich8_hws_flash_ctrl hsflctl;
    union ich8_hws_flash_status hsfsts;
    int32_t error = E1000_ERR_EEPROM;
    uint32_t i = 0;

    /* Start a cycle by writing 1 in Flash Cycle Go in Hw Flash Control */
    hsflctl.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFCTL);
    hsflctl.hsf_ctrl.flcgo = 1;
    E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFCTL, hsflctl.regval);

    /* wait till FDONE bit is set to 1 */
    do {
        hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
        if (hsfsts.hsf_status.flcdone == 1)
            break;
        usec_delay(1);
        i++;
    } while (i < timeout);
    if (hsfsts.hsf_status.flcdone == 1 && hsfsts.hsf_status.flcerr == 0) {
        error = E1000_SUCCESS;
    }
    return error;
}

/******************************************************************************
 * Reads a byte or word from the NVM using the ICH8 flash access registers.
 *
 * hw - The pointer to the hw structure
 * index - The index of the byte or word to read.
 * size - Size of data to read, 1=byte 2=word
 * data - Pointer to the word to store the value read.
 *****************************************************************************/
int32_t
em_read_ich8_data(struct em_hw *hw, uint32_t index,
                     uint32_t size, uint16_t* data)
{
    union ich8_hws_flash_status hsfsts;
    union ich8_hws_flash_ctrl hsflctl;
    uint32_t flash_linear_address;
    uint32_t flash_data = 0;
    int32_t error = -E1000_ERR_EEPROM;
    int32_t count = 0;

    DEBUGFUNC("em_read_ich8_data");

    if (size < 1  || size > 2 || data == 0x0 ||
        index > ICH8_FLASH_LINEAR_ADDR_MASK)
        return error;

    flash_linear_address = (ICH8_FLASH_LINEAR_ADDR_MASK & index) +
                           hw->flash_base_addr;

    do {
        usec_delay(1);
        /* Steps */
        error = em_ich8_cycle_init(hw);
        if (error != E1000_SUCCESS)
            break;

        hsflctl.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFCTL);
        /* 0b/1b corresponds to 1 or 2 byte size, respectively. */
        hsflctl.hsf_ctrl.fldbcount = size - 1;
        hsflctl.hsf_ctrl.flcycle = ICH8_CYCLE_READ;
        E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFCTL, hsflctl.regval);

        /* Write the last 24 bits of index into Flash Linear address field in
         * Flash Address */
        /* TODO: TBD maybe check the index against the size of flash */

        E1000_WRITE_ICH8_REG(hw, ICH8_FLASH_FADDR, flash_linear_address);

        error = em_ich8_flash_cycle(hw, ICH8_FLASH_COMMAND_TIMEOUT);

        /* Check if FCERR is set to 1, if set to 1, clear it and try the whole
         * sequence a few more times, else read in (shift in) the Flash Data0,
         * the order is least significant byte first msb to lsb */
        if (error == E1000_SUCCESS) {
            flash_data = E1000_READ_ICH8_REG(hw, ICH8_FLASH_FDATA0);
            if (size == 1) {
                *data = (uint8_t)(flash_data & 0x000000FF);
            } else if (size == 2) {
                *data = (uint16_t)(flash_data & 0x0000FFFF);
            }
            break;
        } else {
            /* If we've gotten here, then things are probably completely hosed,
             * but if the error condition is detected, it won't hurt to give
             * it another try...ICH8_FLASH_CYCLE_REPEAT_COUNT times.
             */
            hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
            if (hsfsts.hsf_status.flcerr == 1) {
                /* Repeat for some time before giving up. */
                continue;
            } else if (hsfsts.hsf_status.flcdone == 0) {
                DEBUGOUT("Timeout error - flash cycle did not complete.");
                break;
            }
        }
    } while (count++ < ICH8_FLASH_CYCLE_REPEAT_COUNT);

    return error;
}

/******************************************************************************
 * Writes One /two bytes to the NVM using the ICH8 flash access registers.
 *
 * hw - The pointer to the hw structure
 * index - The index of the byte/word to read.
 * size - Size of data to read, 1=byte 2=word
 * data - The byte(s) to write to the NVM.
 *****************************************************************************/
int32_t
em_write_ich8_data(struct em_hw *hw, uint32_t index, uint32_t size,
                      uint16_t data)
{
    union ich8_hws_flash_status hsfsts;
    union ich8_hws_flash_ctrl hsflctl;
    uint32_t flash_linear_address;
    uint32_t flash_data = 0;
    int32_t error = -E1000_ERR_EEPROM;
    int32_t count = 0;

    DEBUGFUNC("em_write_ich8_data");

    if (size < 1  || size > 2 || data > size * 0xff ||
        index > ICH8_FLASH_LINEAR_ADDR_MASK)
        return error;

    flash_linear_address = (ICH8_FLASH_LINEAR_ADDR_MASK & index) +
                           hw->flash_base_addr;

    do {
        usec_delay(1);
        /* Steps */
        error = em_ich8_cycle_init(hw);
        if (error != E1000_SUCCESS)
            break;

        hsflctl.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFCTL);
        /* 0b/1b corresponds to 1 or 2 byte size, respectively. */
        hsflctl.hsf_ctrl.fldbcount = size -1;
        hsflctl.hsf_ctrl.flcycle = ICH8_CYCLE_WRITE;
        E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFCTL, hsflctl.regval);

        /* Write the last 24 bits of index into Flash Linear address field in
         * Flash Address */
        E1000_WRITE_ICH8_REG(hw, ICH8_FLASH_FADDR, flash_linear_address);

        if (size == 1)
            flash_data = (uint32_t)data & 0x00FF;
        else
            flash_data = (uint32_t)data;

        E1000_WRITE_ICH8_REG(hw, ICH8_FLASH_FDATA0, flash_data);

        /* check if FCERR is set to 1 , if set to 1, clear it and try the whole
         * sequence a few more times else done */
        error = em_ich8_flash_cycle(hw, ICH8_FLASH_COMMAND_TIMEOUT);
        if (error == E1000_SUCCESS) {
            break;
        } else {
            /* If we're here, then things are most likely completely hosed,
             * but if the error condition is detected, it won't hurt to give
             * it another try...ICH8_FLASH_CYCLE_REPEAT_COUNT times.
             */
            hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
            if (hsfsts.hsf_status.flcerr == 1) {
                /* Repeat for some time before giving up. */
                continue;
            } else if (hsfsts.hsf_status.flcdone == 0) {
                DEBUGOUT("Timeout error - flash cycle did not complete.");
                break;
            }
        }
    } while (count++ < ICH8_FLASH_CYCLE_REPEAT_COUNT);

    return error;
}

/******************************************************************************
 * Reads a single byte from the NVM using the ICH8 flash access registers.
 *
 * hw - pointer to em_hw structure
 * index - The index of the byte to read.
 * data - Pointer to a byte to store the value read.
 *****************************************************************************/
int32_t
em_read_ich8_byte(struct em_hw *hw, uint32_t index, uint8_t* data)
{
    int32_t status = E1000_SUCCESS;
    uint16_t word = 0;

    status = em_read_ich8_data(hw, index, 1, &word);
    if (status == E1000_SUCCESS) {
        *data = (uint8_t)word;
    }

    return status;
}

/******************************************************************************
 * Writes a single byte to the NVM using the ICH8 flash access registers.
 * Performs verification by reading back the value and then going through
 * a retry algorithm before giving up.
 *
 * hw - pointer to em_hw structure
 * index - The index of the byte to write.
 * byte - The byte to write to the NVM.
 *****************************************************************************/
int32_t
em_verify_write_ich8_byte(struct em_hw *hw, uint32_t index, uint8_t byte)
{
    int32_t error = E1000_SUCCESS;
    int32_t program_retries;
    uint8_t temp_byte;

    em_write_ich8_byte(hw, index, byte);
    usec_delay(100);

    for (program_retries = 0; program_retries < 100; program_retries++) {
        em_read_ich8_byte(hw, index, &temp_byte);
        if (temp_byte == byte)
            break;
        usec_delay(10);
        em_write_ich8_byte(hw, index, byte);
        usec_delay(100);
    }
    if (program_retries == 100)
        error = E1000_ERR_EEPROM;

    return error;
}

/******************************************************************************
 * Writes a single byte to the NVM using the ICH8 flash access registers.
 *
 * hw - pointer to em_hw structure
 * index - The index of the byte to read.
 * data - The byte to write to the NVM.
 *****************************************************************************/
int32_t
em_write_ich8_byte(struct em_hw *hw, uint32_t index, uint8_t data)
{
    int32_t status = E1000_SUCCESS;
    uint16_t word = (uint16_t)data;

    status = em_write_ich8_data(hw, index, 1, word);

    return status;
}

/******************************************************************************
 * Reads a word from the NVM using the ICH8 flash access registers.
 *
 * hw - pointer to em_hw structure
 * index - The starting byte index of the word to read.
 * data - Pointer to a word to store the value read.
 *****************************************************************************/
int32_t
em_read_ich8_word(struct em_hw *hw, uint32_t index, uint16_t *data)
{
    int32_t status = E1000_SUCCESS;
    status = em_read_ich8_data(hw, index, 2, data);
    return status;
}

/******************************************************************************
 * Writes a word to the NVM using the ICH8 flash access registers.
 *
 * hw - pointer to em_hw structure
 * index - The starting byte index of the word to read.
 * data - The word to write to the NVM.
 *****************************************************************************/
int32_t
em_write_ich8_word(struct em_hw *hw, uint32_t index, uint16_t data)
{
    int32_t status = E1000_SUCCESS;
    status = em_write_ich8_data(hw, index, 2, data);
    return status;
}

/******************************************************************************
 * Erases the bank specified. Each bank is a 4k block. Segments are 0 based.
 * segment N is 4096 * N + flash_reg_addr.
 *
 * hw - pointer to em_hw structure
 * segment - 0 for first segment, 1 for second segment, etc.
 *****************************************************************************/
int32_t
em_erase_ich8_4k_segment(struct em_hw *hw, uint32_t segment)
{
    union ich8_hws_flash_status hsfsts;
    union ich8_hws_flash_ctrl hsflctl;
    uint32_t flash_linear_address;
    int32_t  count = 0;
    int32_t  error = E1000_ERR_EEPROM;
    int32_t  iteration, seg_size;
    int32_t  sector_size;
    int32_t  j = 0;
    int32_t  error_flag = 0;

    hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);

    /* Determine HW Sector size: Read BERASE bits of Hw flash Status register */
    /* 00: The Hw sector is 256 bytes, hence we need to erase 16
     *     consecutive sectors.  The start index for the nth Hw sector can be
     *     calculated as = segment * 4096 + n * 256
     * 01: The Hw sector is 4K bytes, hence we need to erase 1 sector.
     *     The start index for the nth Hw sector can be calculated
     *     as = segment * 4096
     * 10: Error condition
     * 11: The Hw sector size is much bigger than the size asked to
     *     erase...error condition */
    if (hsfsts.hsf_status.berasesz == 0x0) {
        /* Hw sector size 256 */
        sector_size = seg_size = ICH8_FLASH_SEG_SIZE_256;
        iteration = ICH8_FLASH_SECTOR_SIZE / ICH8_FLASH_SEG_SIZE_256;
    } else if (hsfsts.hsf_status.berasesz == 0x1) {
        sector_size = seg_size = ICH8_FLASH_SEG_SIZE_4K;
        iteration = 1;
    } else if (hsfsts.hsf_status.berasesz == 0x3) {
        sector_size = seg_size = ICH8_FLASH_SEG_SIZE_64K;
        iteration = 1;
    } else {
        return error;
    }

    for (j = 0; j < iteration ; j++) {
        do {
            count++;
            /* Steps */
            error = em_ich8_cycle_init(hw);
            if (error != E1000_SUCCESS) {
                error_flag = 1;
                break;
            }

            /* Write a value 11 (block Erase) in Flash Cycle field in Hw flash
             * Control */
            hsflctl.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFCTL);
            hsflctl.hsf_ctrl.flcycle = ICH8_CYCLE_ERASE;
            E1000_WRITE_ICH8_REG16(hw, ICH8_FLASH_HSFCTL, hsflctl.regval);

            /* Write the last 24 bits of an index within the block into Flash
             * Linear address field in Flash Address.  This probably needs to
             * be calculated here based off the on-chip segment size and the
             * software segment size assumed (4K) */
            /* TBD */
            flash_linear_address = segment * sector_size + j * seg_size;
            flash_linear_address &= ICH8_FLASH_LINEAR_ADDR_MASK;
            flash_linear_address += hw->flash_base_addr;

            E1000_WRITE_ICH8_REG(hw, ICH8_FLASH_FADDR, flash_linear_address);

            error = em_ich8_flash_cycle(hw, 1000000);
            /* Check if FCERR is set to 1.  If 1, clear it and try the whole
             * sequence a few more times else Done */
            if (error == E1000_SUCCESS) {
                break;
            } else {
                hsfsts.regval = E1000_READ_ICH8_REG16(hw, ICH8_FLASH_HSFSTS);
                if (hsfsts.hsf_status.flcerr == 1) {
                    /* repeat for some time before giving up */
                    continue;
                } else if (hsfsts.hsf_status.flcdone == 0) {
                    error_flag = 1;
                    break;
                }
            }
        } while ((count < ICH8_FLASH_CYCLE_REPEAT_COUNT) && !error_flag);
        if (error_flag == 1)
            break;
    }
    if (error_flag != 1)
        error = E1000_SUCCESS;
    return error;
}

/******************************************************************************
 *
 * Reverse duplex setting without breaking the link.
 *
 * hw: Struct containing variables accessed by shared code
 *
 *****************************************************************************/
int32_t
em_duplex_reversal(struct em_hw *hw)
{
    int32_t ret_val;
    uint16_t phy_data;

    if (hw->phy_type != em_phy_igp_3)
        return E1000_SUCCESS;

    ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data);
    if (ret_val)
        return ret_val;

    phy_data ^= MII_CR_FULL_DUPLEX;

    ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data);
    if (ret_val)
        return ret_val;

    ret_val = em_read_phy_reg(hw, IGP3E1000_PHY_MISC_CTRL, &phy_data);
    if (ret_val)
        return ret_val;

    phy_data |= IGP3_PHY_MISC_DUPLEX_MANUAL_SET;
    ret_val = em_write_phy_reg(hw, IGP3E1000_PHY_MISC_CTRL, phy_data);

    return ret_val;
}

int32_t
em_init_lcd_from_nvm_config_region(struct em_hw *hw,
                                      uint32_t cnf_base_addr, uint32_t cnf_size)
{
    uint32_t ret_val = E1000_SUCCESS;
    uint16_t word_addr, reg_data, reg_addr;
    uint16_t i;

    /* cnf_base_addr is in DWORD */
    word_addr = (uint16_t)(cnf_base_addr << 1);

    /* cnf_size is returned in size of dwords */
    for (i = 0; i < cnf_size; i++) {
        ret_val = em_read_eeprom(hw, (word_addr + i*2), 1, &reg_data);
        if (ret_val)
            return ret_val;

        ret_val = em_read_eeprom(hw, (word_addr + i*2 + 1), 1, &reg_addr);
        if (ret_val)
            return ret_val;

        ret_val = em_get_software_flag(hw);
        if (ret_val != E1000_SUCCESS)
            return ret_val;

        ret_val = em_write_phy_reg_ex(hw, (uint32_t)reg_addr, reg_data);

        em_release_software_flag(hw);
    }

    return ret_val;
}

int32_t
em_init_lcd_from_nvm(struct em_hw *hw)
{
    uint32_t reg_data, cnf_base_addr, cnf_size, ret_val, loop;

    if (hw->phy_type != em_phy_igp_3)
          return E1000_SUCCESS;

    /* Check if SW needs configure the PHY */
    reg_data = E1000_READ_REG(hw, FEXTNVM);
    if (!(reg_data & FEXTNVM_SW_CONFIG))
        return E1000_SUCCESS;

    /* Wait for basic configuration completes before proceeding*/
    loop = 0;
    do {
        reg_data = E1000_READ_REG(hw, STATUS) & E1000_STATUS_LAN_INIT_DONE;
        usec_delay(100);
        loop++;
    } while ((!reg_data) && (loop < 50));

    /* Clear the Init Done bit for the next init event */
    reg_data = E1000_READ_REG(hw, STATUS);
    reg_data &= ~E1000_STATUS_LAN_INIT_DONE;
    E1000_WRITE_REG(hw, STATUS, reg_data);

    /* Make sure HW does not configure LCD from PHY extended configuration
       before SW configuration */
    reg_data = E1000_READ_REG(hw, EXTCNF_CTRL);
    if ((reg_data & E1000_EXTCNF_CTRL_LCD_WRITE_ENABLE) == 0x0000) {
        reg_data = E1000_READ_REG(hw, EXTCNF_SIZE);
        cnf_size = reg_data & E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH;
        cnf_size >>= 16;
        if (cnf_size) {
            reg_data = E1000_READ_REG(hw, EXTCNF_CTRL);
            cnf_base_addr = reg_data & E1000_EXTCNF_CTRL_EXT_CNF_POINTER;
            /* cnf_base_addr is in DWORD */
            cnf_base_addr >>= 16;

            /* Configure LCD from extended configuration region. */
            ret_val = em_init_lcd_from_nvm_config_region(hw, cnf_base_addr,
                                                            cnf_size);
            if (ret_val)
                return ret_val;
        }
    }

    return E1000_SUCCESS;
@


1.18
log
@Fix static array overrun.

Coverity ID:	916

From FreeBSD
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.17 2006/04/18 19:06:02 brad Exp $ */
d44 1
a44 1

d67 1
a67 1

d110 3
a112 2
static int32_t em_configure_kmrn_for_10_100(struct em_hw *hw, uint16_t duplex);
static int32_t em_configure_kmrn_for_1000(struct em_hw *hw, uint16_t duplex);
d147 1
a147 1
    if(hw->mac_type == em_undefined)
d150 1
a150 1
    switch(hw->phy_id) {
d158 4
a161 4
        if(hw->mac_type == em_82541 ||
           hw->mac_type == em_82541_rev_2 ||
           hw->mac_type == em_82547 ||
           hw->mac_type == em_82547_rev_2) {
d165 8
d201 1
a201 1
    if(hw->phy_init_script) {
d217 1
a217 1
        switch(hw->mac_type) {
d254 1
a254 1
        if(hw->mac_type == em_82547) {
d260 1
a260 1
            if(!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
d266 1
a266 1
                if(coarse > IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {
d269 1
a269 1
                } else if(coarse == IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
d349 1
a350 1
    case E1000_DEV_ID_82541EI_MOBILE:
d389 2
d395 7
d407 5
a411 1
    switch(hw->mac_type) {
d445 1
a445 1
    if(hw->mac_type != em_82543) {
d464 1
d505 1
a505 1
    if(hw->mac_type == em_82542_rev2_0) {
d510 1
a510 1
    if(hw->bus_type == em_bus_type_pci_express) {
d514 1
a514 1
        if(em_disable_pciex_master(hw) != E1000_SUCCESS) {
d542 1
a542 1
    if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
d549 1
a549 1
    if(hw->mac_type == em_82573) {
d559 1
a559 1
            if(extcnf_ctrl & E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP)
d566 9
a574 1
        } while(timeout);
d584 1
a584 1
    switch(hw->mac_type) {
d600 14
d623 1
a623 1
    switch(hw->mac_type) {
d655 1
d658 1
a658 1
            if(ret_val)
d669 1
a669 1
    if(hw->mac_type >= em_82540 && hw->mac_type <= em_82547_rev_2) {
d675 1
a675 1
    if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
d693 2
a694 2
    if(hw->mac_type == em_82542_rev2_0) {
        if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
d698 6
d736 1
a736 1
    if(ret_val) {
d746 6
a751 3
    if (hw->mac_type < em_82545_rev_3)
        E1000_WRITE_REG(hw, VET, 0);
    em_clear_vfta(hw);
d754 1
a754 1
    if(hw->mac_type == em_82542_rev2_0) {
d768 1
a768 1
    if(hw->mac_type == em_82542_rev2_0) {
d772 1
a772 1
        if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
d779 3
a781 1
    for(i = 0; i < mta_size; i++)
d783 4
d793 1
a793 1
    if(hw->dma_fairness && hw->mac_type <= em_82543) {
d798 1
a798 1
    switch(hw->mac_type) {
d804 1
a804 1
        if(hw->bus_type == em_bus_type_pcix) {
d812 1
a812 1
            if(stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
d814 1
a814 1
            if(cmd_mmrbc > stat_mmrbc) {
d824 4
d832 1
a832 1
    if(hw->mac_type > em_82544) {
d841 1
d850 1
a850 1
        em_enable_tx_pkt_filtering(hw); 
d880 1
d883 1
a883 1
        if(hw->mac_type >= em_82571)
d902 5
d932 1
a932 1
    if(hw->media_type != em_media_type_internal_serdes)
d935 1
a935 1
    switch(hw->mac_type) {
d948 1
a948 1
    if(eeprom_data != EEPROM_RESERVED_WORD) {
d950 1
a950 1
        eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK; 
d952 1
a952 1
        if(ret_val)
d994 1
d1020 1
a1020 1
    if(hw->mac_type == em_82542_rev2_0)
d1023 1
a1023 1
    if((hw->mac_type < em_82543) && (hw->report_tx_early == 1))
d1037 7
a1043 1
    if(hw->mac_type == em_82543) {
d1061 6
a1066 3
    E1000_WRITE_REG(hw, FCAL, FLOW_CONTROL_ADDRESS_LOW);
    E1000_WRITE_REG(hw, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
    E1000_WRITE_REG(hw, FCT, FLOW_CONTROL_TYPE);
d1076 1
a1076 1
    if(!(hw->fc & em_fc_tx_pause)) {
d1083 1
a1083 1
        if(hw->fc_send_xon) {
d1130 1
a1130 1
    if(hw->media_type == em_media_type_fiber)
d1134 1
a1134 1
    if(ret_val)
d1142 1
a1142 1
    if(ret_val)
d1213 1
a1213 1
    if(hw->media_type == em_media_type_internal_serdes ||
d1216 1
a1216 1
        for(i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
d1219 1
a1219 1
            if(status & E1000_STATUS_LU) break;
d1221 1
a1221 1
        if(i == (LINK_UP_TIMEOUT / 10)) {
d1230 1
a1230 1
            if(ret_val) {
d1264 1
a1264 1
    if(hw->mac_type > em_82543) {
d1272 1
a1272 1
        if(ret_val)
d1278 1
a1278 1
    if(ret_val) {
d1286 1
a1286 1
    if(ret_val)
d1289 1
a1289 1
    if((hw->mac_type == em_82545_rev_3) ||
d1296 3
a1298 3
    if(hw->mac_type <= em_82543 ||
       hw->mac_type == em_82541 || hw->mac_type == em_82547 ||
       hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2)
d1321 1
a1321 1
    
d1328 1
a1328 1
    /* Wait 10ms for MAC to configure PHY from eeprom settings */
d1330 1
a1330 1

d1336 1
d1380 1
a1380 1
    if(ret_val)
d1384 1
a1384 1
    if(hw->autoneg) {
d1387 1
a1387 1
        if(hw->ffe_config_state == em_ffe_config_active)
d1390 1
a1390 1
        if(hw->dsp_config_state == em_dsp_config_activated)
d1396 1
a1396 1
        if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
d1398 3
a1400 2
            ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, &phy_data);
            if(ret_val)
d1403 3
a1405 4
            ret_val = em_write_phy_reg(hw,
                                                  IGP01E1000_PHY_PORT_CONFIG,
                                                  phy_data);
            if(ret_val)
d1409 1
a1409 1
            if(ret_val)
d1413 1
a1413 1
            if(ret_val)
d1418 1
a1418 1
        if(ret_val)
d1443 1
a1443 1
        if(ret_val)
d1464 2
a1465 2
    if(!hw->phy_reset_disable) {
        
d1469 1
a1469 1
        if(ret_val)
d1478 1
a1478 1
        if(ret_val)
d1489 1
a1489 1
        if(ret_val)
d1514 1
a1514 1
        if(hw->disable_polarity_correction == 1)
d1518 1
a1518 1
        if(ret_val)
a1572 1
            /* Disable Pass False Carrier on the PHY */
a1573 1

d1576 1
d1611 1
a1611 1
    if(hw->phy_reset_disable)
d1613 1
a1613 1
    
d1616 1
a1616 1
    if(ret_val)
d1653 1
a1653 1
    if(hw->disable_polarity_correction == 1)
d1655 10
a1664 2
        ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
        if(ret_val)
d1667 1
a1667 6
    /* Force TX_CLK in the Extended PHY Specific Control Register
     * to 25MHz clock.
     */
    ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);
    if(ret_val)
        return ret_val;
d1669 12
a1680 5
    phy_data |= M88E1000_EPSCR_TX_CLK_25;

    if (hw->phy_revision < M88E1011_I_REV_4) {
        /* Configure Master and Slave downshift values */
        phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
d1682 1
a1682 1
        phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
d1684 5
a1688 3
        ret_val = em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
        if(ret_val)
            return ret_val;
d1693 1
a1693 1
    if(ret_val) {
d1723 1
a1723 1
    if(hw->autoneg_advertised == 0)
d1726 4
d1732 1
a1732 1
    if(ret_val) {
d1742 1
a1742 1
    if(ret_val)
d1747 1
a1747 1
    if(ret_val)
d1753 1
a1753 1
    if(hw->wait_autoneg_complete) {
d1755 1
a1755 1
        if(ret_val) {
d1766 12
d1787 1
a1787 1
*   3) Config DSP to improve Gigabit link quality for some PHY revisions.    
d1796 2
a1797 2
    
    if(hw->mac_type >= em_82544) {
d1801 1
a1801 1
        if(ret_val) {
d1807 1
a1807 1
    if(ret_val) {
d1813 1
a1813 1
    if(hw->phy_type == em_phy_igp) {
d1815 1
a1815 1
        if(ret_val) {
d1820 1
a1820 1
                
d1841 1
d1861 1
a1861 1
    if(ret_val)
d1866 2
a1867 4
        ret_val = em_read_kmrn_reg(hw, E1000_KUMCTRLSTA_OFFSET_INB_CTRL,
                                      &reg_data);
        if (ret_val)
            return ret_val;
d1879 1
d1882 1
a1882 1
        if(ret_val)
d1886 1
a1886 1
        if(ret_val)
d1890 5
a1894 1
        if(ret_val)
d1898 3
a1900 3
    if(hw->autoneg) {
        /* Setup autoneg and flow control advertisement 
          * and perform autonegotiation */   
d1902 2
a1903 2
        if(ret_val)
            return ret_val;           
d1909 1
a1909 1
        if(ret_val) {
d1918 1
a1918 1
    for(i = 0; i < 10; i++) {
d1920 1
a1920 1
        if(ret_val)
d1923 1
a1923 1
        if(ret_val)
d1926 1
a1926 1
        if(phy_data & MII_SR_LINK_STATUS) {
d1929 1
a1929 1
            if(ret_val)
d1931 1
a1931 1
            
d1968 2
a1969 2
    ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL,
                                 &reg_data);
a1972 1
    /* Enable pass false carrier when in half duplex mode. */
d1978 1
a1979 3
    ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL,
                                  reg_data);
    
d1984 1
a1984 1
em_configure_kmrn_for_1000(struct em_hw *hw, uint16_t duplex)
d2004 1
a2005 2
    ret_val = em_read_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL,
                                 &reg_data);
a2008 1
    /* Disable Pass False Carrier on the PHY */
d2010 1
a2011 3
    ret_val = em_write_phy_reg(hw, GG82563_PHY_KMRN_MODE_CTRL,
                                  reg_data);
    
d2031 1
a2031 1
    if(ret_val)
d2034 7
a2040 4
    /* Read the MII 1000Base-T Control Register (Address 9). */
    ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);
    if(ret_val)
        return ret_val;
d2059 1
a2059 1
    if(hw->autoneg_advertised & ADVERTISE_10_HALF) {
d2065 1
a2065 1
    if(hw->autoneg_advertised & ADVERTISE_10_FULL) {
d2071 1
a2071 1
    if(hw->autoneg_advertised & ADVERTISE_100_HALF) {
d2077 1
a2077 1
    if(hw->autoneg_advertised & ADVERTISE_100_FULL) {
d2083 1
a2083 1
    if(hw->autoneg_advertised & ADVERTISE_1000_HALF) {
d2088 1
a2088 1
    if(hw->autoneg_advertised & ADVERTISE_1000_FULL) {
d2091 3
d2150 1
a2150 1
    if(ret_val)
d2155 5
a2159 3
    ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg);    
    if(ret_val)
        return ret_val;
d2198 1
a2198 1
    if(ret_val)
d2206 2
a2207 2
    if(hw->forced_speed_duplex == em_100_full ||
       hw->forced_speed_duplex == em_10_full) {
d2224 1
a2224 1
    if(hw->forced_speed_duplex == em_100_full ||
d2247 1
a2247 1
        if(ret_val)
d2255 1
a2255 1
        if(ret_val)
d2262 12
d2279 1
a2279 1
        if(ret_val)
d2286 1
a2286 1
        if(ret_val)
d2292 1
a2292 1
    if(ret_val)
d2304 1
a2304 1
    if(hw->wait_autoneg_complete) {
d2310 1
a2310 1
        for(i = PHY_FORCE_TIME; i > 0; i--) {
d2315 1
a2315 1
            if(ret_val)
d2319 1
a2319 1
            if(ret_val)
d2322 1
a2322 1
            if(mii_status_reg & MII_SR_LINK_STATUS) break;
d2325 1
a2325 1
        if((i == 0) &&
d2330 1
a2330 1
            if(ret_val) {
d2336 2
a2337 2
        for(i = PHY_FORCE_TIME; i > 0; i--) {
            if(mii_status_reg & MII_SR_LINK_STATUS) break;
d2343 1
a2343 1
            if(ret_val)
d2347 1
a2347 1
            if(ret_val)
d2358 1
a2358 1
        if(ret_val)
d2363 1
a2363 1
        if(ret_val)
d2370 1
a2370 1
        if(ret_val)
d2375 1
a2375 1
        if(ret_val)
d2378 3
a2380 4
        if((hw->mac_type == em_82544 || hw->mac_type == em_82543) &&
           (!hw->autoneg) &&
           (hw->forced_speed_duplex == em_10_full ||
            hw->forced_speed_duplex == em_10_half)) {
d2382 1
a2382 1
            if(ret_val)
d2457 1
a2457 1
    /* 82544 or newer MAC, Auto Speed Detection takes care of 
d2473 1
a2473 1
    if(ret_val)
d2476 1
a2476 1
    if(phy_data & M88E1000_PSSR_DPLX) 
d2478 1
a2478 1
    else 
d2486 1
a2486 1
    if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
d2488 1
a2488 1
    else if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
d2556 1
a2556 1
    if(hw->mac_type == em_82542_rev2_0)
d2590 4
a2593 3
    if(((hw->media_type == em_media_type_fiber) && (hw->autoneg_failed)) ||
       ((hw->media_type == em_media_type_internal_serdes) && (hw->autoneg_failed)) ||
       ((hw->media_type == em_media_type_copper) && (!hw->autoneg))) {
d2595 1
a2595 1
        if(ret_val) {
d2606 1
a2606 1
    if((hw->media_type == em_media_type_copper) && hw->autoneg) {
d2612 1
a2612 1
        if(ret_val)
d2615 1
a2615 1
        if(ret_val)
d2618 1
a2618 1
        if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
d2627 1
a2627 1
            if(ret_val)
d2631 1
a2631 1
            if(ret_val)
d2668 2
a2669 2
            if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
               (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {
d2676 1
a2676 1
                if(hw->original_fc == em_fc_full) {
d2692 4
a2695 4
            else if(!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
                    (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
                    (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
                    (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
d2707 4
a2710 4
            else if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
                    (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
                    !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
                    (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
d2734 3
a2736 3
            else if((hw->original_fc == em_fc_none ||
                     hw->original_fc == em_fc_tx_pause) ||
                    hw->fc_strict_ieee) {
d2749 1
a2749 1
            if(ret_val) {
d2754 1
a2754 1
            if(duplex == HALF_DUPLEX)
d2761 1
a2761 1
            if(ret_val) {
d2800 2
a2801 2
    if((hw->media_type == em_media_type_fiber) ||
       (hw->media_type == em_media_type_internal_serdes)) {
d2804 1
a2804 1
        if(hw->media_type == em_media_type_fiber) {
d2806 1
a2806 1
            if(status & E1000_STATUS_LU)
d2817 1
a2817 1
    if((hw->media_type == em_media_type_copper) && hw->get_link_status) {
d2824 1
a2824 1
        if(ret_val)
d2827 1
a2827 1
        if(ret_val)
d2830 1
a2830 1
        if(phy_data & MII_SR_LINK_STATUS) {
d2844 4
a2847 4
            if((hw->mac_type == em_82544 || hw->mac_type == em_82543) &&
               (!hw->autoneg) &&
               (hw->forced_speed_duplex == em_10_full ||
                hw->forced_speed_duplex == em_10_half)) {
d2864 1
a2864 1
        if(!hw->autoneg) return -E1000_ERR_CONFIG;
d2877 1
a2877 1
        if(hw->mac_type >= em_82544)
d2881 1
a2881 1
            if(ret_val) {
d2892 1
a2892 1
        if(ret_val) {
d2904 1
a2904 1
        if(hw->tbi_compatibility_en) {
d2906 6
a2911 2
            em_get_speed_and_duplex(hw, &speed, &duplex);
            if(speed != SPEED_1000) {
d2915 1
a2915 1
                if(hw->tbi_compatibility_on) {
d2928 1
a2928 1
                if(!hw->tbi_compatibility_on) {
d2944 1
a2944 1
    else if((((hw->media_type == em_media_type_fiber) &&
d2946 4
a2949 4
             (hw->media_type == em_media_type_internal_serdes)) &&
            (!(status & E1000_STATUS_LU)) &&
            (!(rxcw & E1000_RXCW_C))) {
        if(hw->autoneg_failed == 0) {
d2965 1
a2965 1
        if(ret_val) {
d2975 3
a2977 3
    else if(((hw->media_type == em_media_type_fiber) ||
             (hw->media_type == em_media_type_internal_serdes)) &&
            (ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {
d2987 2
a2988 2
    else if((hw->media_type == em_media_type_internal_serdes) &&
            !(E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
d2991 2
a2992 2
        if(E1000_RXCW_SYNCH & E1000_READ_REG(hw, RXCW)) {
            if(!(rxcw & E1000_RXCW_IV)) {
d3001 2
a3002 2
    if((hw->media_type == em_media_type_internal_serdes) &&
       (E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
d3026 1
a3026 1
    if(hw->mac_type >= em_82543) {
d3028 1
a3028 1
        if(status & E1000_STATUS_SPEED_1000) {
d3031 1
a3031 1
        } else if(status & E1000_STATUS_SPEED_100) {
d3039 1
a3039 1
        if(status & E1000_STATUS_FD) {
d3056 1
a3056 1
    if(hw->phy_type == em_phy_igp && hw->speed_downgraded) {
d3058 1
a3058 1
        if(ret_val)
d3061 1
a3061 1
        if(!(phy_data & NWAY_ER_LP_NWAY_CAPS))
d3065 1
a3065 1
            if(ret_val)
d3067 1
a3067 1
            if((*speed == SPEED_100 && !(phy_data & NWAY_LPAR_100TX_FD_CAPS)) ||
d3073 1
a3073 1
    if ((hw->mac_type == em_80003es2lan) && 
d3076 1
a3076 1
            ret_val = em_configure_kmrn_for_1000(hw, *duplex);
d3083 6
d3108 1
a3108 1
    for(i = PHY_AUTO_NEG_TIME; i > 0; i--) {
d3113 1
a3113 1
        if(ret_val)
d3116 1
a3116 1
        if(ret_val)
d3118 1
a3118 1
        if(phy_data & MII_SR_AUTONEG_COMPLETE) {
d3191 1
a3191 1
    while(mask) {
d3197 4
a3200 2
        if(data & mask) ctrl |= E1000_CTRL_MDIO;
        else ctrl &= ~E1000_CTRL_MDIO;
d3251 1
a3251 1
    for(data = 0, i = 0; i < 16; i++) {
d3256 2
a3257 1
        if(ctrl & E1000_CTRL_MDIO) data |= 1;
d3277 3
d3283 1
a3283 1
    while(timeout) {
d3319 5
d3366 2
a3367 1
    if((hw->phy_type == em_phy_igp || 
d3372 1
a3372 1
        if(ret_val) {
d3417 1
a3417 1
    if(reg_addr > MAX_PHY_REG_ADDRESS) {
d3422 1
a3422 1
    if(hw->mac_type > em_82543) {
d3434 1
a3434 1
        for(i = 0; i < 64; i++) {
d3437 1
a3437 1
            if(mdic & E1000_MDIC_READY) break;
d3439 1
a3439 1
        if(!(mdic & E1000_MDIC_READY)) {
d3443 1
a3443 1
        if(mdic & E1000_MDIC_ERROR) {
d3506 2
a3507 1
    if((hw->phy_type == em_phy_igp || 
d3512 1
a3512 1
        if(ret_val) {
d3557 1
a3557 1
    if(reg_addr > MAX_PHY_REG_ADDRESS) {
d3562 1
a3562 1
    if(hw->mac_type > em_82543) {
d3575 1
a3575 1
        for(i = 0; i < 641; i++) {
d3578 1
a3578 1
            if(mdic & E1000_MDIC_READY) break;
d3580 1
a3580 1
        if(!(mdic & E1000_MDIC_READY)) {
d3692 1
a3692 1
    if(hw->mac_type > em_82543) {
d3705 1
a3705 1
         * For pre-em_82571 hardware, we delay for 10ms between the assert 
d3712 2
a3713 2
        
        if (hw->mac_type < em_82571) 
d3717 1
a3717 1
        
d3720 1
a3720 1
        
d3722 1
a3722 1
            msec_delay(10);
d3740 1
a3740 1
    if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
d3752 6
d3786 1
d3788 1
a3788 1
        if(ret_val)
d3790 1
d3794 1
a3794 1
        if(ret_val)
d3799 1
a3799 1
        if(ret_val)
d3806 1
a3806 1
    if(hw->phy_type == em_phy_igp || hw->phy_type == em_phy_igp_2)
d3813 57
a3869 1
* Probes the expected PHY address for known PHY IDs
d3871 1
a3871 1
* hw - Struct containing variables accessed by shared code
d3874 1
a3874 1
em_detect_gig_phy(struct em_hw *hw)
d3876 4
a3879 5
    int32_t phy_init_status, ret_val;
    uint16_t phy_id_high, phy_id_low;
    boolean_t match = FALSE;

    DEBUGFUNC("em_detect_gig_phy");
d3881 1
a3881 7
    /* The 82571 firmware may still be configuring the PHY.  In this
     * case, we cannot access the PHY until the configuration is done.  So
     * we explicitly set the PHY values. */
    if(hw->mac_type == em_82571 ||
       hw->mac_type == em_82572) {
        hw->phy_id = IGP01E1000_I_PHY_ID;
        hw->phy_type = em_phy_igp_2;
a3882 1
    }
d3884 69
a3952 8
    /* ESB-2 PHY reads require em_phy_gg82563 to be set because of a work-
     * around that forces PHY page 0 to be set or the reads fail.  The rest of
     * the code in this routine uses em_read_phy_reg to read the PHY ID.
     * So for ESB-2 we need to have this set so our reads won't fail.  If the
     * attached PHY is not a em_phy_gg82563, the routines below will figure
     * this out as well. */
    if (hw->mac_type == em_80003es2lan)
        hw->phy_type = em_phy_gg82563;
d3956 1
a3956 1
    if(ret_val)
d3962 1
a3962 1
    if(ret_val)
d3968 1
a3968 1
    switch(hw->mac_type) {
d3970 1
a3970 1
        if(hw->phy_id == M88E1000_E_PHY_ID) match = TRUE;
d3973 1
a3973 1
        if(hw->phy_id == M88E1000_I_PHY_ID) match = TRUE;
d3980 1
a3980 1
        if(hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
d3986 1
a3986 1
        if(hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
d3989 1
a3989 1
        if(hw->phy_id == M88E1111_I_PHY_ID) match = TRUE;
d3994 6
d4028 1
a4028 1
            if(ret_val) break;
d4031 1
a4031 1
        if(ret_val) break;
d4033 1
a4033 1
        if(ret_val) break;
d4035 1
a4035 1
    } while(0);
d4067 1
a4067 1
    if(ret_val)
d4073 1
a4073 1
    if(ret_val)
d4079 1
a4079 1
    if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
d4083 1
a4083 1
        if(ret_val)
d4093 1
a4093 1
        if(ret_val)
d4099 1
a4099 1
        if(average <= em_igp_cable_length_50)
d4101 1
a4101 1
        else if(average <= em_igp_cable_length_80)
d4103 1
a4103 1
        else if(average <= em_igp_cable_length_110)
d4105 1
a4105 1
        else if(average <= em_igp_cable_length_140)
d4115 47
d4181 1
a4181 1
    if(ret_val)
d4193 2
a4194 2
    if(ret_val)
        return ret_val; 
d4198 1
a4198 1
    if(ret_val)
d4221 1
a4221 1
        if(ret_val)
d4258 1
a4258 1
    if(hw->media_type != em_media_type_copper) {
d4264 1
a4264 1
    if(ret_val)
d4268 1
a4268 1
    if(ret_val)
d4271 1
a4271 1
    if((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {
d4276 2
a4277 1
    if(hw->phy_type == em_phy_igp ||
d4280 2
d4291 1
a4291 1
    if(!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {
d4338 1
a4338 1
        if(eecd & E1000_EECD_SIZE) {
d4406 1
a4406 1
        if(em_is_onboard_nvm_eeprom(hw) == FALSE) {
d4430 29
d4467 1
a4467 1
        if(hw->mac_type <= em_82547_rev_2) {
d4471 1
a4471 1
            if(ret_val)
d4477 1
a4477 1
            if(eeprom_size)
d4562 1
a4562 1
        if(data & mask)
d4575 1
a4575 1
    } while(mask);
d4607 1
a4607 1
    for(i = 0; i < count; i++) {
d4614 1
a4614 1
        if(eecd & E1000_EECD_DO)
d4645 1
a4645 1
        if(hw->mac_type > em_82544) {
d4649 1
a4649 1
            while((!(eecd & E1000_EECD_GNT)) &&
d4655 1
a4655 1
            if(!(eecd & E1000_EECD_GNT)) {
d4698 1
a4698 1
    if(eeprom->type == em_eeprom_microwire) {
d4721 1
a4721 1
    } else if(eeprom->type == em_eeprom_spi) {
d4755 1
a4755 1
    } else if(hw->eeprom.type == em_eeprom_microwire) {
d4777 1
a4777 1
    if(hw->mac_type > em_82544) {
d4815 1
a4815 1
    } while(retry_count < EEPROM_MAX_RETRY_SPI);
d4820 1
a4820 1
    if(retry_count >= EEPROM_MAX_RETRY_SPI) {
d4851 1
a4851 1
    if((offset >= eeprom->word_size) || (words > eeprom->word_size - offset) ||
d4859 1
a4859 1
	hw->eeprom.use_eerd == FALSE) {
d4879 4
a4882 1
    if(eeprom->type == em_eeprom_spi) {
d4886 1
a4886 1
        if(em_spi_eeprom_ready(hw)) {
d4894 1
a4894 1
        if((eeprom->address_bits == 8) && (offset >= 128))
d4910 1
a4910 1
    } else if(eeprom->type == em_eeprom_microwire) {
d4954 2
a4955 2
        
        if(error) {
d4959 1
a4959 1
      
d4961 1
a4961 1
    
d4987 2
a4988 2
        register_value = (data[i] << E1000_EEPROM_RW_REG_DATA) | 
                         ((offset+i) << E1000_EEPROM_RW_ADDR_SHIFT) | 
d4992 1
a4992 1
        if(error) {
d4994 1
a4994 1
        }       
d4997 1
a4997 1
        
d4999 2
a5000 2
        
        if(error) {
d5002 1
a5002 1
        }       
d5004 1
a5004 1
    
d5021 2
a5022 2
    for(i = 0; i < attempts; i++) {
        if(eerd == E1000_EEPROM_POLL_READ)
d5024 1
a5024 1
        else 
d5027 1
a5027 1
        if(reg & E1000_EEPROM_RW_REG_DONE) {
d5049 4
a5052 1
    if(hw->mac_type == em_82573) {
d5059 1
a5059 1
        if(eecd == 0x03) {
d5102 16
a5117 2
    for(i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
        if(em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
d5124 1
a5124 1
    if(checksum == (uint16_t) EEPROM_SUM)
d5143 1
d5149 2
a5150 2
    for(i = 0; i < EEPROM_CHECKSUM_REG; i++) {
        if(em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
d5157 1
a5157 1
    if(em_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
d5162 8
d5199 1
a5199 1
    if((offset >= eeprom->word_size) || (words > eeprom->word_size - offset) ||
d5206 1
a5206 1
    if(eeprom->use_eewr == TRUE)
d5209 3
d5216 1
a5216 1
    if(eeprom->type == em_eeprom_microwire) {
d5252 1
a5252 1
        if(em_spi_eeprom_ready(hw)) return -E1000_ERR_EEPROM;
d5263 1
a5263 1
        if((eeprom->address_bits == 8) && (offset >= 128))
d5285 1
a5285 1
            if((((offset + widx)*2) % eeprom->page_size) == 0) {
d5351 1
a5351 1
        for(i = 0; i < 200; i++) {
d5353 1
a5353 1
            if(eecd & E1000_EECD_DO) break;
d5356 1
a5356 1
        if(i == 200) {
d5399 7
a5405 3

    /* The flop register will be used to determine if flash type is STM */
    flop = E1000_READ_REG(hw, FLOP);
d5408 2
d5443 100
d5562 1
a5562 1
    if(em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
d5570 1
a5570 1
    if(em_read_eeprom(hw, ++offset, 1, &eeprom_data) < 0) {
d5594 1
a5594 1
    for(i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
d5596 1
a5596 1
        if(em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
d5611 1
a5611 1
        if(E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)
d5616 1
a5616 1
    for(i = 0; i < NODE_ADDRESS_SIZE; i++)
d5650 3
d5655 1
a5655 1
    for(i = 1; i < rar_num; i++) {
d5657 1
d5659 1
d5688 1
a5688 1
    
d5697 2
d5705 1
a5705 1
    for(i = rar_used_count; i < num_rar_entry; i++) {
d5707 1
d5709 1
d5715 3
a5717 1
    for(i = 0; i < num_mta_entry; i++) {
d5719 1
d5723 1
a5723 1
    for(i = 0; i < mc_addr_count; i++) {
d5775 7
a5781 2
        /* [47:36] i.e. 0x563 for above example address */
        hash_value = ((mc_addr[4] >> 4) | (((uint16_t) mc_addr[5]) << 4));
d5784 7
a5790 2
        /* [46:35] i.e. 0xAC6 for above example address */
        hash_value = ((mc_addr[4] >> 3) | (((uint16_t) mc_addr[5]) << 5));
d5793 7
a5799 2
        /* [45:34] i.e. 0x5D8 for above example address */
        hash_value = ((mc_addr[4] >> 2) | (((uint16_t) mc_addr[5]) << 6));
d5802 7
a5808 2
        /* [43:32] i.e. 0x634 for above example address */
        hash_value = ((mc_addr[4]) | (((uint16_t) mc_addr[5]) << 8));
d5813 2
d5842 2
d5854 1
a5854 1
    if((hw->mac_type == em_82544) && ((hash_reg & 0x1) == 1)) {
d5857 1
d5859 1
d5862 1
d5919 1
d5921 1
d5938 4
a5941 1
    if((hw->mac_type == em_82544) && ((offset & 0x1) == 1)) {
d5944 1
d5946 1
d5949 1
d5966 3
d5988 1
d6004 1
a6004 1
    if(hw->mac_type < em_82540) {
d6014 1
a6014 1
    if(em_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {
d6018 12
a6029 3
    if((eeprom_data== ID_LED_RESERVED_0000) ||
       (eeprom_data == ID_LED_RESERVED_FFFF)) eeprom_data = ID_LED_DEFAULT;
    for(i = 0; i < 4; i++) {
d6031 1
a6031 1
        switch(temp) {
d6048 1
a6048 1
        switch(temp) {
d6082 1
a6082 1
    switch(hw->mac_type) {
d6096 1
a6096 1
        if(ret_val)
d6101 1
a6101 1
        if(ret_val)
d6103 1
a6103 1
        /* Fall Through */
d6105 1
a6105 1
        if(hw->media_type == em_media_type_fiber) {
d6116 1
a6116 1
        } else if(hw->media_type == em_media_type_copper)
d6124 39
d6175 1
a6175 1
    switch(hw->mac_type) {
d6189 1
a6189 1
        if(ret_val)
d6191 1
a6191 1
        /* Fall Through */
d6193 4
d6217 1
a6217 1
    switch(hw->mac_type) {
d6226 1
a6226 1
        if(hw->media_type == em_media_type_fiber) {
d6237 1
a6237 1
        if(hw->media_type == em_media_type_fiber) {
d6241 4
a6244 1
        } else if(hw->media_type == em_media_type_copper) {
d6268 1
a6268 1
    switch(hw->mac_type) {
d6277 1
a6277 1
        if(hw->media_type == em_media_type_fiber) {
d6288 1
a6288 1
        if(hw->media_type == em_media_type_fiber) {
d6292 4
a6295 1
        } else if(hw->media_type == em_media_type_copper) {
d6333 2
d6341 2
d6362 2
d6370 2
d6375 1
a6375 1
    if(hw->mac_type < em_82543) return;
d6384 1
a6384 1
    if(hw->mac_type <= em_82544) return;
d6390 1
a6390 1
    if(hw->mac_type <= em_82547_rev_2) return;
d6394 3
d6421 2
a6422 2
    if(hw->adaptive_ifs) {
        if(!hw->ifs_params_forced) {
d6449 3
a6451 3
    if(hw->adaptive_ifs) {
        if((hw->collision_delta * hw->ifs_ratio) > hw->tx_packet_delta) {
            if(hw->tx_packet_delta > MIN_NUM_XMITS) {
d6453 2
a6454 2
                if(hw->current_ifs_val < hw->ifs_max_val) {
                    if(hw->current_ifs_val == 0)
d6462 1
a6462 1
            if(hw->in_ifs_mode && (hw->tx_packet_delta <= MIN_NUM_XMITS)) {
d6509 1
a6509 1
    if(carry_bit && ((stats->gorcl & 0x80000000) == 0))
d6515 1
a6515 1
    if((mac_addr[0] == (uint8_t) 0xff) && (mac_addr[1] == (uint8_t) 0xff))
d6518 1
a6518 1
    else if(*mac_addr & 0x01)
d6522 1
a6522 1
    if(frame_len == hw->max_frame_size) {
d6526 1
a6526 1
        if(stats->roc > 0)
d6533 1
a6533 1
    if(frame_len == 64) {
d6536 1
a6536 1
    } else if(frame_len == 127) {
d6539 1
a6539 1
    } else if(frame_len == 255) {
d6542 1
a6542 1
    } else if(frame_len == 511) {
d6545 1
a6545 1
    } else if(frame_len == 1023) {
d6548 1
a6548 1
    } else if(frame_len == 1522) {
d6577 1
d6588 1
a6588 1
        if(hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
d6591 1
a6591 1
        } else if(hw->bus_type == em_bus_type_pci) {
a6675 2
    uint16_t cur_agc, min_agc = IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1;
    uint16_t max_agc = 0;
d6684 1
a6684 1
    if(hw->phy_type == em_phy_m88) {
d6688 1
a6688 1
        if(ret_val)
d6747 3
a6749 1
    } else if(hw->phy_type == em_phy_igp) { /* For IGP PHY */
d6756 1
a6756 1
        for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
d6759 1
a6759 1
            if(ret_val)
d6762 1
a6762 1
            cur_agc = phy_data >> IGP01E1000_AGC_LENGTH_SHIFT;
d6764 3
a6766 3
            /* Array bound check. */
            if((cur_agc >= IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1) ||
               (cur_agc == 0))
d6769 1
a6769 1
            agc_value += cur_agc;
d6772 2
a6773 2
            if(min_agc > cur_agc)
                min_agc = cur_agc;
d6777 2
a6778 2
        if(agc_value < IGP01E1000_PHY_CHANNEL_NUM * em_igp_cable_length_50) {
            agc_value -= min_agc;
d6794 4
a6797 1
    } else if (hw->phy_type == em_phy_igp_2) {
d6809 1
a6809 1
	    /* Getting bits 15:9, which represent the combination of course and
d6812 7
a6818 2
            cur_agc = (phy_data >> IGP02E1000_AGC_LENGTH_SHIFT) &
                      IGP02E1000_AGC_LENGTH_MASK;
d6821 6
a6826 4
            if (em_igp_2_cable_length_table[min_agc] > em_igp_2_cable_length_table[cur_agc])
                min_agc = cur_agc;
	    if (em_igp_2_cable_length_table[max_agc] < em_igp_2_cable_length_table[cur_agc])
                max_agc = cur_agc;
d6828 1
a6828 1
            agc_value += em_igp_2_cable_length_table[cur_agc];
d6831 2
a6832 1
        agc_value -= (em_igp_2_cable_length_table[min_agc] + em_igp_2_cable_length_table[max_agc]);
d6874 1
a6874 1
        if(ret_val)
d6878 2
a6879 1
    } else if(hw->phy_type == em_phy_igp ||
d6884 1
a6884 1
        if(ret_val)
d6889 1
a6889 1
        if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
d6895 1
a6895 1
            if(ret_val)
d6905 7
d6924 1
a6924 1
 *            E1000_SUCCESS 
d6939 2
a6940 1
    if(hw->phy_type == em_phy_igp || 
d6944 1
a6944 1
        if(ret_val)
d6952 1
a6952 1
        if(ret_val)
d6957 3
d6992 1
a6992 1
    if(hw->phy_type != em_phy_igp)
d6995 1
a6995 1
    if(link_up) {
d6997 1
a6997 1
        if(ret_val) {
d7002 1
a7002 1
        if(speed == SPEED_1000) {
d7004 3
a7006 1
            em_get_cable_length(hw, &min_length, &max_length);
d7008 1
a7008 1
            if((hw->dsp_config_state == em_dsp_config_enabled) &&
d7011 1
a7011 1
                for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
d7014 1
a7014 1
                    if(ret_val)
d7021 1
a7021 1
                    if(ret_val)
d7027 1
a7027 1
            if((hw->ffe_config_state == em_ffe_config_enabled) &&
d7036 1
a7036 1
                if(ret_val)
d7039 1
a7039 1
                for(i = 0; i < ffe_idle_err_timeout; i++) {
d7043 1
a7043 1
                    if(ret_val)
d7047 1
a7047 1
                    if(idle_errs > SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {
d7053 1
a7053 1
                        if(ret_val)
d7058 1
a7058 1
                    if(idle_errs)
d7064 1
a7064 1
        if(hw->dsp_config_state == em_dsp_config_activated) {
d7069 1
a7069 1
            if(ret_val)
d7075 1
a7075 1
            if(ret_val)
d7082 1
a7082 1
            if(ret_val)
d7084 1
a7084 1
            for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
d7086 1
a7086 1
                if(ret_val)
d7093 1
a7093 1
                if(ret_val)
d7099 1
a7099 1
            if(ret_val)
d7107 1
a7107 1
            if(ret_val)
d7113 1
a7113 1
        if(hw->ffe_config_state == em_ffe_config_active) {
d7118 1
a7118 1
            if(ret_val)
d7124 1
a7124 1
            if(ret_val)
d7131 1
a7131 1
            if(ret_val)
d7135 1
a7135 1
            if(ret_val)
d7140 1
a7140 1
            if(ret_val)
d7148 1
a7148 1
            if(ret_val)
d7173 2
a7174 2
    if((hw->mac_type == em_82545_rev_3) &&
       (hw->media_type == em_media_type_copper)) {
d7176 1
a7176 1
        if(ret_val) {
d7180 2
a7181 2
        if((eeprom_data != EEPROM_RESERVED_WORD) &&
           (eeprom_data & EEPROM_PHY_CLASS_A)) {
d7183 1
a7183 1
            if(ret_val)
d7186 1
a7186 1
            if(ret_val)
d7214 1
d7219 2
a7220 1
    if(hw->phy_type != em_phy_igp && hw->phy_type != em_phy_igp_2)
d7226 1
a7226 1
    if(hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2) {
d7228 1
a7228 1
        if(ret_val)
d7230 5
d7237 1
a7237 1
        if(ret_val)
d7241 3
a7243 3
    if(!active) {
        if(hw->mac_type == em_82541_rev_2 ||
           hw->mac_type == em_82547_rev_2) {
d7246 1
a7246 1
            if(ret_val)
d7249 4
d7258 1
d7268 1
a7268 1
            if(ret_val)
d7274 1
a7274 1
            if(ret_val)
d7285 1
a7285 1
            if(ret_val)
d7289 3
a7291 3
    } else if((hw->autoneg_advertised == AUTONEG_ADVERTISE_SPEED_DEFAULT) ||
              (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_ALL ) ||
              (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_100_ALL)) {
d7293 2
a7294 2
        if(hw->mac_type == em_82541_rev_2 ||
           hw->mac_type == em_82547_rev_2) {
d7297 1
a7297 1
            if(ret_val)
d7300 4
d7309 1
d7314 1
a7314 1
        if(ret_val)
d7319 1
a7319 1
        if(ret_val)
d7344 1
d7349 1
a7349 1
    if(hw->mac_type <= em_82547_rev_2)
d7352 3
d7356 1
a7356 1
        if(ret_val)
d7358 1
d7361 4
d7369 1
d7378 1
a7378 1
            if(ret_val)
d7384 1
a7384 1
            if(ret_val)
d7395 1
a7395 1
            if(ret_val)
d7401 6
a7406 2
 
            phy_data |= IGP02E1000_PM_D0_LPLU;   
d7410 1
d7414 1
a7414 1
        if(ret_val)
d7419 1
a7419 1
        if(ret_val)
d7440 1
a7440 1
    switch(hw->mac_type) {
d7451 1
a7451 1
    if(ret_val)
d7455 1
a7455 1
    if(ret_val)
d7459 1
a7459 1
    if(ret_val)
d7464 1
a7464 1
    if(ret_val)
d7470 1
a7470 1
    if(ret_val)
d7474 1
a7474 1
    if(ret_val)
d7479 1
a7479 1
    if(ret_val)
d7483 1
a7483 1
    if(ret_val)
d7499 1
a7499 1
    uint32_t offset = E1000_MNG_DHCP_COOKIE_OFFSET; 
d7518 1
a7518 1
 * returns: - E1000_ERR_HOST_INTERFACE_COMMAND in case if is not ready or 
d7542 1
a7542 1
    if (i == E1000_MNG_DHCP_COMMAND_TIMEOUT) { 
d7562 1
a7562 1
    uint32_t data;
d7642 1
a7642 1
    while(i--)
d7649 1
a7649 1
    for (i = 0; i < length; i++)
d7651 2
d7665 1
a7665 2
em_mng_write_commit(
    struct em_hw * hw)
d7683 1
a7683 2
em_check_mng_mode(
    struct em_hw *hw)
d7689 6
a7694 2
    if((fwsm & E1000_FWSM_MODE_MASK) ==
        (E1000_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT))
d7837 1
a7837 1
    if(ret_val)
d7840 1
a7840 1
    if(ret_val)
d7844 1
a7844 1
    if(ret_val)
d7848 1
a7848 1
    for(i = PHY_FORCE_TIME; i > 0; i--) {
d7854 1
a7854 1
        if(ret_val)
d7858 1
a7858 1
        if(ret_val)
d7861 1
a7861 1
        if((mii_status_reg & ~MII_SR_LINK_STATUS) == 0) break;
d7871 1
a7871 1
    if(ret_val)
d7875 1
a7875 1
    if(ret_val)
d7879 1
a7879 1
    if(ret_val)
d7883 1
a7883 1
    if(ret_val)
d7887 1
a7887 1
    if(ret_val)
d7891 1
a7891 1
    for(i = PHY_FORCE_TIME; i > 0; i--) {
d7897 1
a7897 1
        if(ret_val)
d7901 1
a7901 1
        if(ret_val)
d7904 1
a7904 1
        if(mii_status_reg & MII_SR_LINK_STATUS) break;
d7981 2
a7982 2
    while(timeout) {
        if(!(E1000_READ_REG(hw, STATUS) & E1000_STATUS_GIO_MASTER_ENABLE))
d7989 1
a7989 1
    if(!timeout) {
d8022 4
a8025 2
        while(timeout) {
            if (E1000_READ_REG(hw, EECD) & E1000_EECD_AUTO_RD) break;
d8030 1
a8030 1
        if(!timeout) {
d8065 1
a8065 1
        msec_delay(10);
d8071 1
a8071 1
        /* Fall Through */
d8111 1
a8111 1
    if(!hw->eeprom_semaphore_present)
d8122 1
a8122 1
    while(timeout) {
d8128 1
a8128 1
        if(swsm & E1000_SWSM_SWESMBI)
d8135 1
a8135 1
    if(!timeout) {
d8160 1
a8160 1
    if(!hw->eeprom_semaphore_present)
d8193 1
a8193 1
    while(timeout) {
d8196 1
a8196 1
        if(!(swsm & E1000_SWSM_SMBI))
d8202 1
a8202 1
    if(!timeout) {
d8248 7
d8278 1
a8278 1
        if((fwsm & E1000_FWSM_MODE_MASK) != 0)
d8281 2
d8287 841
@


1.17
log
@add a few more Intel Gig PCI ids.

Some of these are from jason@@ and the rest are from the Linux PCI ids page.
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.16 2006/03/28 05:33:03 brad Exp $ */
d6065 1
a6065 1
    uint16_t cur_agc, min_agc = IGP01E1000_AGC_LENGTH_TABLE_SIZE;
@


1.16
log
@Sync up to Intel's latest FreeBSD em driver (5.1.5). Adds support
for the 82563 PCI Express chipset and a few fixes.

From: Intel's web-site
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.15 2006/03/07 09:21:55 jmc Exp $ */
d336 1
d357 2
d372 2
d375 3
@


1.15
log
@advertisment -> advertisement; from leonardo chiquitto filho
@
text
@d34 2
a35 1
/* $OpenBSD: if_em_hw.c,v 1.14 2005/11/26 14:31:26 krw Exp $ */
d110 2
d164 5
d335 1
d364 1
d372 4
d382 3
d425 1
d602 1
d669 2
a766 1
            ctrl |= (1 << 22);
d768 1
d782 22
d807 3
a809 3
        ctrl &= ~E1000_TXDCTL_WTHRESH;
        ctrl |= E1000_TXDCTL_COUNT_DESC | E1000_TXDCTL_FULL_TX_DESC_WB;
        ctrl |= (1 << 22);
d827 9
d1347 1
a1347 1
	    break;
d1359 148
d1717 1
d1721 19
d1745 16
d1770 4
d1821 80
d1919 4
a1922 4
        /* Read the MII 1000Base-T Control Register (Address 9). */
        ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);
        if(ret_val)
            return ret_val;
d2121 2
a2122 1
    if (hw->phy_type == em_phy_m88) {
d2191 2
a2192 1
           (hw->phy_type == em_phy_m88)) {
d2251 21
d2287 1
a2287 1
    uint32_t tctl;
d2291 5
d2299 1
a2299 1
    tctl |= E1000_COLLISION_DISTANCE << E1000_COLD_SHIFT;
d2543 1
a2543 1
                    DEBUGOUT("Flow Control = FULL.\r\n");
d2546 1
a2546 1
                    DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
d2562 1
a2562 1
                DEBUGOUT("Flow Control = TX PAUSE frames only.\r\n");
d2577 1
a2577 1
                DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
d2603 1
a2603 1
                DEBUGOUT("Flow Control = NONE.\r\n");
d2606 1
a2606 1
                DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
d2631 1
a2631 1
            DEBUGOUT("Copper PHY and Auto Neg has not completed.\r\n");
d2814 1
a2814 1
        DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\r\n");
d2839 1
a2839 1
        DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\r\n");
d2902 1
a2902 1
            DEBUGOUT("Full Duplex\r\n");
d2905 1
a2905 1
            DEBUGOUT(" Half Duplex\r\n");
d2908 1
a2908 1
        DEBUGOUT("1000 Mbs, Full Duplex\r\n");
d2934 10
d3119 66
d3197 1
d3201 9
d3216 1
d3219 21
d3245 1
d3336 1
d3340 9
d3355 1
d3358 21
d3384 1
d3417 1
a3417 1
        for(i = 0; i < 640; i++) {
d3451 59
d3522 1
d3535 10
d3549 1
a3549 1
         * for 10ms after the deassertion.
d3557 2
d3565 1
d3592 1
d3670 9
d3716 3
d3745 4
a3748 2
        ret_val = em_write_phy_reg(hw, 29, 0x001d);
        if(ret_val) break;
d3880 11
a3890 2
        phy_info->cable_length = ((phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
                                  M88E1000_PSSR_CABLE_LENGTH_SHIFT);
d3971 2
a3972 1
 * is configured.
d4085 14
d4279 2
a4280 3
    if(em_get_hw_eeprom_semaphore(hw))
        return -E1000_ERR_EEPROM;

d4299 1
a4299 1
                em_put_hw_eeprom_semaphore(hw);
d4422 1
a4422 1
    em_put_hw_eeprom_semaphore(hw);
d4497 12
a4508 8
    /* FLASH reads without acquiring the semaphore are safe in 82573-based
     * controllers.
     */
    if ((em_is_onboard_nvm_eeprom(hw) == TRUE) ||
        (hw->mac_type != em_82573)) {
        /* Prepare the EEPROM for reading  */
        if(em_acquire_eeprom(hw) != E1000_SUCCESS)
            return -E1000_ERR_EEPROM;
d4511 1
a4511 1
    if(eeprom->use_eerd == TRUE) {
d4620 3
d4642 1
d4684 2
d5024 1
a5024 1
	/* If STM opcode located in bits 15:8 of flop, reset firmware */
d5032 1
a5032 1
	for (i=0; i < attempts; i++) {
d5112 1
d5349 1
d5351 29
a5379 1
    rar_high = ((uint32_t) addr[4] | ((uint32_t) addr[5] << 8) | E1000_RAH_AV);
d5545 1
a5545 1
        /* FALLTHROUGH */
d5594 1
a5594 1
        /* FALLTHROUGH */
d5959 1
d6102 28
d6239 2
a6240 1
    if(hw->phy_type == em_phy_m88) {
d6309 2
a6310 1
    } else if(hw->phy_type == em_phy_m88) {
d7341 1
d7385 5
d7432 5
d7482 4
d7490 61
d7587 1
@


1.14
log
@Add some missing 'break;'s in auich and auixp that lint spotted. While
here, use FALLTHRU or FALLTHROUGH to make lint even happier.

ok marco@@ miod@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.13 2005/11/08 01:33:19 brad Exp $ */
d1250 1
a1250 1
        /* when autonegotiation advertisment is only 1000Mbps then we
d5884 1
a5884 1
 * lplu will not be activated unless the device autonegotiation advertisment
d5997 1
a5997 1
 * lplu will not be activated unless the device autonegotiation advertisment
@


1.13
log
@Sync up to Intel's latest FreeBSD em driver (3.2.18). A few fixes
for the new PCI Express chips.

From: Intel's web-site
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.12 2005/10/07 23:38:09 brad Exp $ */
d161 1
a161 1
        /* Fall Through */
d372 1
a372 1
        /* fall through */
d581 1
a581 1
            /* fall through */
d1295 2
a1296 1
            default:
d4904 1
a4904 1
        /* Fall Through */
d4953 1
a4953 1
        /* Fall Through */
@


1.12
log
@remove some whitespace
@
text
@d3 2
a4 2
  Copyright (c) 2001-2005, Intel Corporation 
  All rights reserved.
d6 2
a7 2
  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met:
d9 2
a10 2
   1. Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
d12 19
a30 19
   2. Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.

   3. Neither the name of the Intel Corporation nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.11 2005/10/07 23:24:42 brad Exp $ */
d574 7
a580 5
            usec_delay(10);
            ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
            ctrl_ext |= E1000_CTRL_EXT_EE_RST;
            E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
            E1000_WRITE_FLUSH(hw);
d847 5
d860 3
a862 12
    if(em_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG, 1, &eeprom_data)) {
        DEBUGOUT("EEPROM Read Error\n");
        return -E1000_ERR_EEPROM;
    }

    if(hw->fc == em_fc_default) {
        if((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)
            hw->fc = em_fc_none;
        else if((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) ==
                EEPROM_WORD0F_ASM_DIR)
            hw->fc = em_fc_tx_pause;
        else
d864 17
d2986 3
d2993 4
a2996 1
        msec_delay(10);
d2999 3
d4493 1
a5309 1
    case em_82571:
d5314 5
d6681 6
a6845 23
}

int32_t
em_phy_misctst_get_info(struct em_hw *hw, uint16_t *enabled)
{
    int32_t ret_val;
    uint16_t misctst_reg;

    DEBUGFUNC("em_phy_misctst_get_info");

    ret_val = em_read_phy_reg(hw, 0x0FF0, &misctst_reg);
    if (ret_val)
        return ret_val;

    if (misctst_reg & 0x0002) {
        DEBUGOUT("L1 ASPM disabled");
        *enabled = FALSE;
    } else {
        DEBUGOUT("L1 ASPM enabled");
        *enabled = TRUE;
    }

    return E1000_SUCCESS;
@


1.11
log
@Sync up to Intel's latest FreeBSD em driver which adds
support for the 82571 and 82572 PCI Express chips.

From: Intel's web-site

ok krw@@ pedro@@ deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.10 2005/09/11 23:54:31 brad Exp $ */
a767 2


@


1.10
log
@typo, th -> the
@
text
@d5 1
a5 1
  
d8 1
a8 1
  
d11 1
a11 1
  
d15 1
a15 1
  
d19 1
a19 1
  
d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.9 2005/07/02 06:15:44 deraadt Exp $ */
d124 8
a131 8
    { 8, 13, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43,
      22, 24, 27, 30, 32, 35, 37, 40, 42, 44, 47, 49, 51, 54, 56, 58,
      32, 35, 38, 41, 44, 47, 50, 53, 55, 58, 61, 63, 66, 69, 71, 74,
      43, 47, 51, 54, 58, 61, 64, 67, 71, 74, 77, 80, 82, 85, 88, 90,
      57, 62, 66, 70, 74, 77, 81, 85, 88, 91, 94, 97, 100, 103, 106, 108,
      73, 78, 82, 87, 91, 95, 98, 102, 105, 109, 112, 114, 117, 119, 122, 124,
      91, 96, 101, 105, 109, 113, 116, 119, 122, 125, 127, 128, 128, 128, 128, 128,
      108, 113, 117, 121, 124, 127, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128};
d347 10
d359 1
d368 2
d406 2
d411 12
a422 1
        if(hw->mac_type >= em_82543) {
d424 1
a424 1
            if(status & E1000_STATUS_TBIMODE) {
d431 1
a431 3
        } else {
            /* This is an 82542 (fiber only) */
            hw->media_type = em_media_type_fiber;
d580 2
d742 3
d756 21
d960 8
d1288 1
a1288 1
        }
d1290 1
a1290 1
   return E1000_SUCCESS;
d3033 2
d3073 10
d3436 15
d3660 4
a3663 9
    /* Request EEPROM Access */
    if(hw->mac_type > em_82544) {
        eecd |= E1000_EECD_REQ;
        E1000_WRITE_REG(hw, EECD, eecd);
        eecd = E1000_READ_REG(hw, EECD);
        while((!(eecd & E1000_EECD_GNT)) &&
              (i < E1000_EEPROM_GRANT_ATTEMPTS)) {
            i++;
            usec_delay(5);
d3665 13
a3677 6
        }
        if(!(eecd & E1000_EECD_GNT)) {
            eecd &= ~E1000_EECD_REQ;
            E1000_WRITE_REG(hw, EECD, eecd);
            DEBUGOUT("Could not acquire EEPROM grant\n");
            return -E1000_ERR_EEPROM;
a3679 1
    }
d4182 1
a4182 1
    /* 82573 reads only through eerd */
d4471 7
a4477 2
    if(((hw->mac_type == em_82546) || (hw->mac_type == em_82546_rev_3)) &&
       (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1))
d4479 2
d4510 6
d4558 6
a5120 1

d5287 2
d5388 1
d5477 34
d6638 2
d6669 3
d6674 20
a6693 2
    /* Simply wait for 10ms */
    msec_delay(10);
d6765 1
a6765 2
    /* Release both semaphores. */
    swsm &= ~(E1000_SWSM_SMBI | E1000_SWSM_SWESMBI);
d6784 2
a6785 1
    if(hw->mac_type > em_82547_rev_2)
d6802 2
d6813 23
@


1.9
log
@sync
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.8 2005/03/27 16:38:13 brad Exp $ */
d6347 1
a6347 1
    /* Now we will re-enable th transmitter on the PHY */
@


1.8
log
@remove FreeBSD ifdef bloat.

ok krw@@
@
text
@d3 1
a3 1
  Copyright (c) 2001-2003, Intel Corporation 
d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.7 2005/02/19 18:18:14 jolan Exp $ */
d41 1
a41 1
__FBSDID("$FreeBSD: if_em_hw.c,v 1.15 2004/09/23 22:57:53 cognet Exp $");
a43 3
#include "bpfilter.h"
#include "vlan.h"

a64 9
#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

a103 1
static int32_t em_id_led_init(struct em_hw * hw);
d105 1
d107 2
d122 10
d143 3
d150 1
d179 3
d187 9
d200 3
a202 1
        if(hw->mac_type == em_82541 || hw->mac_type == em_82547) {
d220 4
a223 1
        } else {
d225 3
d232 5
d325 2
d330 1
d341 1
d347 4
d356 14
d425 3
d437 9
d470 1
a470 1
        E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
d474 22
d549 12
d568 1
a568 1
    if(hw->mac_type >= em_82540) {
d621 2
d637 2
a638 2
    E1000_WRITE_REG(hw, VET, 0);

d666 2
a667 1
    for(i = 0; i < E1000_MC_TBL_SIZE; i++)
d672 2
a673 1
     * gives equal priority to transmits and receives.
d675 1
a675 1
    if(hw->dma_fairness) {
d713 7
d723 4
d805 1
a805 1
    if(em_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG, 1, &eeprom_data) < 0) {
d862 1
d1033 1
a1033 1
* Detects which PHY is present and the speed and duplex
d1038 1
a1038 1
em_setup_copper_link(struct em_hw *hw)
a1040 1
    uint32_t led_ctrl;
a1041 1
    uint16_t i;
d1044 1
a1044 1
    DEBUGFUNC("em_setup_copper_link");
d1058 3
a1060 1
        em_phy_hw_reset(hw);
d1088 2
a1089 2
    if(!hw->phy_reset_disable) {
        if (hw->phy_type == em_phy_igp) {
a1090 5
            ret_val = em_phy_reset(hw);
            if(ret_val) {
                DEBUGOUT("Error Resetting the PHY\n");
                return ret_val;
            }
d1092 11
a1102 2
            /* Wait 10ms for MAC to configure PHY from eeprom settings */
            msec_delay(15);
d1104 1
a1104 5
            /* Configure activity LED after PHY reset */
            led_ctrl = E1000_READ_REG(hw, LEDCTL);
            led_ctrl &= IGP_ACTIVITY_LED_MASK;
            led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
            E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
d1106 8
a1113 6
            /* disable lplu d3 during driver init */
            ret_val = em_set_d3_lplu_state(hw, FALSE);
            if(ret_val) {
                DEBUGOUT("Error Disabling LPLU D3\n");
                return ret_val;
            }
d1115 2
a1116 5
            /* Configure mdi-mdix settings */
            ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
                                         &phy_data);
            if(ret_val)
                return ret_val;
d1118 5
a1122 6
            if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
                hw->dsp_config_state = em_dsp_config_disabled;
                /* Force MDI for IGP B-0 PHY */
                phy_data &= ~(IGP01E1000_PSCR_AUTO_MDIX |
                              IGP01E1000_PSCR_FORCE_MDI_MDIX);
                hw->mdix = 1;
d1124 6
a1129 3
            } else {
                hw->dsp_config_state = em_dsp_config_enabled;
                phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
d1131 10
a1140 17
                switch (hw->mdix) {
                case 1:
                    phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
                    break;
                case 2:
                    phy_data |= IGP01E1000_PSCR_FORCE_MDI_MDIX;
                    break;
                case 0:
                default:
                    phy_data |= IGP01E1000_PSCR_AUTO_MDIX;
                    break;
                }
            }
            ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
                                          phy_data);
            if(ret_val)
                return ret_val;
d1142 5
a1146 34
            /* set auto-master slave resolution settings */
            if(hw->autoneg) {
                em_ms_type phy_ms_setting = hw->master_slave;

                if(hw->ffe_config_state == em_ffe_config_active)
                    hw->ffe_config_state = em_ffe_config_enabled;

                if(hw->dsp_config_state == em_dsp_config_activated)
                    hw->dsp_config_state = em_dsp_config_enabled;

                /* when autonegotiation advertisment is only 1000Mbps then we
                 * should disable SmartSpeed and enable Auto MasterSlave
                 * resolution as hardware default. */
                if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
                    /* Disable SmartSpeed */
                    ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                                 &phy_data);
                    if(ret_val)
                        return ret_val;
                    phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
                    ret_val = em_write_phy_reg(hw,
                                                  IGP01E1000_PHY_PORT_CONFIG,
                                                  phy_data);
                    if(ret_val)
                        return ret_val;
                    /* Set auto Master/Slave resolution process */
                    ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
                    if(ret_val)
                        return ret_val;
                    phy_data &= ~CR_1000T_MS_ENABLE;
                    ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
                    if(ret_val)
                        return ret_val;
                }
d1148 3
a1150 3
                ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
                if(ret_val)
                    return ret_val;
d1152 16
a1167 30
                /* load defaults for future use */
                hw->original_master_slave = (phy_data & CR_1000T_MS_ENABLE) ?
                                            ((phy_data & CR_1000T_MS_VALUE) ?
                                             em_ms_force_master :
                                             em_ms_force_slave) :
                                             em_ms_auto;

                switch (phy_ms_setting) {
                case em_ms_force_master:
                    phy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);
                    break;
                case em_ms_force_slave:
                    phy_data |= CR_1000T_MS_ENABLE;
                    phy_data &= ~(CR_1000T_MS_VALUE);
                    break;
                case em_ms_auto:
                    phy_data &= ~CR_1000T_MS_ENABLE;
                default:
                    break;
                }
                ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
                if(ret_val)
                    return ret_val;
            }
        } else {
            /* Enable CRS on TX. This must be set for half-duplex operation. */
            ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                         &phy_data);
            if(ret_val)
                return ret_val;
d1169 3
a1171 1
            phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
d1173 2
a1174 8
            /* Options:
             *   MDI/MDI-X = 0 (default)
             *   0 - Auto for all speeds
             *   1 - MDI mode
             *   2 - MDI-X mode
             *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
             */
            phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
d1176 2
a1177 15
            switch (hw->mdix) {
            case 1:
                phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
                break;
            case 2:
                phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
                break;
            case 3:
                phy_data |= M88E1000_PSCR_AUTO_X_1000T;
                break;
            case 0:
            default:
                phy_data |= M88E1000_PSCR_AUTO_X_MODE;
                break;
            }
d1179 6
a1184 11
            /* Options:
             *   disable_polarity_correction = 0 (default)
             *       Automatic Correction for Reversed Cable Polarity
             *   0 - Disabled
             *   1 - Enabled
             */
            phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
            if(hw->disable_polarity_correction == 1)
                phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;
            ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                          phy_data);
d1187 4
a1190 6

            /* Force TX_CLK in the Extended PHY Specific Control Register
             * to 25MHz clock.
             */
            ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
                                         &phy_data);
d1193 2
a1194 62

            phy_data |= M88E1000_EPSCR_TX_CLK_25;

            if (hw->phy_revision < M88E1011_I_REV_4) {
                /* Configure Master and Slave downshift values */
                phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
                              M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
                phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
                             M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
                ret_val = em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
                                              phy_data);
                if(ret_val)
                    return ret_val;
            }

            /* SW Reset the PHY so all changes take effect */
            ret_val = em_phy_reset(hw);
            if(ret_val) {
                DEBUGOUT("Error Resetting the PHY\n");
                return ret_val;
            }
        }

        /* Options:
         *   autoneg = 1 (default)
         *      PHY will advertise value(s) parsed from
         *      autoneg_advertised and fc
         *   autoneg = 0
         *      PHY will be set to 10H, 10F, 100H, or 100F
         *      depending on value parsed from forced_speed_duplex.
         */

        /* Is autoneg enabled?  This is enabled by default or by software
         * override.  If so, call em_phy_setup_autoneg routine to parse the
         * autoneg_advertised and fc options. If autoneg is NOT enabled, then
         * the user should have provided a speed/duplex override.  If so, then
         * call em_phy_force_speed_duplex to parse and set this up.
         */
        if(hw->autoneg) {
            /* Perform some bounds checking on the hw->autoneg_advertised
             * parameter.  If this variable is zero, then set it to the default.
             */
            hw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;

            /* If autoneg_advertised is zero, we assume it was not defaulted
             * by the calling code so we set to advertise full capability.
             */
            if(hw->autoneg_advertised == 0)
                hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;

            DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
            ret_val = em_phy_setup_autoneg(hw);
            if(ret_val) {
                DEBUGOUT("Error Setting up Auto-Negotiation\n");
                return ret_val;
            }
            DEBUGOUT("Restarting Auto-Neg\n");

            /* Restart auto-negotiation by setting the Auto Neg Enable bit and
             * the Auto Neg Restart bit in the PHY control register.
             */
            ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data);
d1197 2
a1198 3

            phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
            ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data);
a1200 19

            /* Does the user want to wait for Auto-Neg to complete here, or
             * check at a later time (for example, callback routine).
             */
            if(hw->wait_autoneg_complete) {
                ret_val = em_wait_autoneg(hw);
                if(ret_val) {
                    DEBUGOUT("Error while waiting for autoneg to complete\n");
                    return ret_val;
                }
            }
            hw->get_link_status = TRUE;
        } else {
            DEBUGOUT("Forcing speed and duplex\n");
            ret_val = em_phy_force_speed_duplex(hw);
            if(ret_val) {
                DEBUGOUT("Error Forcing Speed and Duplex\n");
                return ret_val;
            }
a1201 1
    } /* !hw->phy_reset_disable */
d1203 1
a1203 5
    /* Check link status. Wait up to 100 microseconds for link to become
     * valid.
     */
    for(i = 0; i < 10; i++) {
        ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
d1206 22
a1227 1
        ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data);
a1229 35

        if(phy_data & MII_SR_LINK_STATUS) {
            /* We have link, so we need to finish the config process:
             *   1) Set up the MAC to the current PHY speed/duplex
             *      if we are on 82543.  If we
             *      are on newer silicon, we only need to configure
             *      collision distance in the Transmit Control Register.
             *   2) Set up flow control on the MAC to that established with
             *      the link partner.
             */
            if(hw->mac_type >= em_82544) {
                em_config_collision_dist(hw);
            } else {
                ret_val = em_config_mac_to_phy(hw);
                if(ret_val) {
                    DEBUGOUT("Error configuring MAC to PHY settings\n");
                    return ret_val;
                }
            }
            ret_val = em_config_fc_after_link_up(hw);
            if(ret_val) {
                DEBUGOUT("Error Configuring Flow Control\n");
                return ret_val;
            }
            DEBUGOUT("Valid link established!!!\n");

            if(hw->phy_type == em_phy_igp) {
                ret_val = em_config_dsp_after_link_change(hw, TRUE);
                if(ret_val) {
                    DEBUGOUT("Error Configuring DSP after link up\n");
                    return ret_val;
                }
            }
            DEBUGOUT("Valid link established!!!\n");
            return E1000_SUCCESS;
a1230 2
        usec_delay(10);
    }
d1232 1
a1232 2
    DEBUGOUT("Unable to establish link!!!\n");
    return E1000_SUCCESS;
d1235 3
a1237 2
/******************************************************************************
* Configures PHY autoneg and flow control advertisement settings
d1240 3
a1242 3
******************************************************************************/
int32_t
em_phy_setup_autoneg(struct em_hw *hw)
d1245 1
a1245 2
    uint16_t mii_autoneg_adv_reg;
    uint16_t mii_1000t_ctrl_reg;
d1247 1
a1247 1
    DEBUGFUNC("em_phy_setup_autoneg");
d1249 5
a1253 2
    /* Read the MII Auto-Neg Advertisement Register (Address 4). */
    ret_val = em_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);
d1257 44
a1300 2
    /* Read the MII 1000Base-T Control Register (Address 9). */
    ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);
d1304 228
d1642 1
a1642 1
    ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg);
d1730 2
a1731 2
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                         &phy_data)))
d1738 2
a1739 2
        if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                          phy_data)))
d1750 2
a1751 2
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
                                         &phy_data)))
d1757 2
a1758 2
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
                                          phy_data)))
d1763 2
a1764 1
    if((ret_val = em_write_phy_reg(hw, PHY_CTRL, mii_ctrl_reg)))
d1797 2
a1798 1
        if((i == 0) && (hw->phy_type == em_phy_m88)) {
d1848 9
d1903 5
d1918 3
a1920 5
    if (hw->phy_type == em_phy_igp) {
        ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
                                     &phy_data);
        if(ret_val)
            return ret_val;
d1922 4
a1925 2
        if(phy_data & IGP01E1000_PSSR_FULL_DUPLEX) ctrl |= E1000_CTRL_FD;
        else ctrl &= ~E1000_CTRL_FD;
d1927 1
a1927 1
        em_config_collision_dist(hw);
d1929 7
a1935 19
        /* Set up speed in the Device Control register depending on
         * negotiated values.
         */
        if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
           IGP01E1000_PSSR_SPEED_1000MBPS)
            ctrl |= E1000_CTRL_SPD_1000;
        else if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
                IGP01E1000_PSSR_SPEED_100MBPS)
            ctrl |= E1000_CTRL_SPD_100;
    } else {
        ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                     &phy_data);
        if(ret_val)
            return ret_val;

        if(phy_data & M88E1000_PSSR_DPLX) ctrl |= E1000_CTRL_FD;
        else ctrl &= ~E1000_CTRL_FD;

        em_config_collision_dist(hw);
a1936 8
        /* Set up speed in the Device Control register depending on
         * negotiated values.
         */
        if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
            ctrl |= E1000_CTRL_SPD_1000;
        else if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
            ctrl |= E1000_CTRL_SPD_100;
    }
d2231 1
d2281 19
d2349 1
a2349 1
	if(hw->tbi_compatibility_en) {
d2704 2
a2705 1
    if(hw->phy_type == em_phy_igp &&
d2709 1
a2709 1
        if(ret_val)
d2711 1
d2714 1
a2714 1
    ret_val = em_read_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT & reg_addr,
d2810 2
a2811 1
    if(hw->phy_type == em_phy_igp &&
d2815 1
a2815 1
        if(ret_val)
d2817 1
d2820 1
a2820 1
    ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT & reg_addr,
d2889 1
d2895 1
a2895 1
void
d2900 1
d2904 6
d2945 5
d2967 13
a2979 1
    if(hw->mac_type != em_82541_rev_2) {
d2990 2
a2991 1
    } else em_phy_hw_reset(hw);
d2993 1
a2993 1
    if(hw->phy_type == em_phy_igp)
d3047 3
d3105 1
a3105 1
    phy_info->downshift = hw->speed_downgraded;
d3144 1
a3144 1
        /* transalte to old method */
d3179 1
a3179 1
    phy_info->downshift = hw->speed_downgraded;
d3195 1
a3195 2
        return ret_val;

d3205 3
a3207 3
    if(phy_data & M88E1000_PSSR_1000MBS) {
        /* Cable Length Estimation and Local/Remote Receiver Informatoion
         * are only valid at 1000 Mbps
d3268 2
a3269 1
    if(hw->phy_type == em_phy_igp)
d3295 1
a3295 1
void
d3300 1
d3315 2
d3333 2
d3363 2
d3366 1
a3366 1
    default:
d3377 13
d3394 19
a3412 3
        eeprom->word_size = 64;
        if (em_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size) == 0) {
            eeprom_size &= EEPROM_SIZE_MASK;
d3414 1
a3414 25
            switch (eeprom_size) {
            case EEPROM_SIZE_16KB:
                eeprom->word_size = 8192;
                break;
            case EEPROM_SIZE_8KB:
                eeprom->word_size = 4096;
                break;
            case EEPROM_SIZE_4KB:
                eeprom->word_size = 2048;
                break;
            case EEPROM_SIZE_2KB:
                eeprom->word_size = 1024;
                break;
            case EEPROM_SIZE_1KB:
                eeprom->word_size = 512;
                break;
            case EEPROM_SIZE_512B:
                eeprom->word_size = 256;
                break;
            case EEPROM_SIZE_128B:
            default:
                eeprom->word_size = 64;
                break;
            }
        }
d3416 1
d3569 3
d3574 1
d3593 1
d3711 2
d3774 1
d3781 1
a3781 1
    if((offset > eeprom->word_size) || (words > eeprom->word_size - offset) ||
d3787 17
a3803 3
    /* Prepare the EEPROM for reading  */
    if(em_acquire_eeprom(hw) != E1000_SUCCESS)
        return -E1000_ERR_EEPROM;
d3855 126
d3997 19
d4059 2
d4090 1
a4090 1
    if((offset > eeprom->word_size) || (words > eeprom->word_size - offset) ||
d4096 4
d4270 59
d4407 1
d4416 1
d4419 1
a4419 1
    for(i = 1; i < E1000_RAR_ENTRIES; i++) {
d4448 3
a4450 1

d4458 2
a4459 1
    for(i = rar_used_count; i < E1000_RAR_ENTRIES; i++) {
d4466 2
a4467 1
    for(i = 0; i < E1000_NUM_MTA_REGISTERS; i++) {
d4491 1
a4491 1
        if(rar_used_count < E1000_RAR_ENTRIES) {
d4542 1
d4647 24
a4670 3

    for(offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++)
        E1000_WRITE_REG_ARRAY(hw, VFTA, offset, 0);
d4673 1
a4673 1
static int32_t
d5004 13
d5176 3
a5178 1
    if(hw->mac_type < em_82543) {
d5182 10
a5191 2
        return;
    }
d5193 21
a5213 24
    status = E1000_READ_REG(hw, STATUS);
    hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
                   em_bus_type_pcix : em_bus_type_pci;

    if(hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
        hw->bus_speed = (hw->bus_type == em_bus_type_pci) ?
                        em_bus_speed_66 : em_bus_speed_120;
    } else if(hw->bus_type == em_bus_type_pci) {
        hw->bus_speed = (status & E1000_STATUS_PCI66) ?
                        em_bus_speed_66 : em_bus_speed_33;
    } else {
        switch (status & E1000_STATUS_PCIX_SPEED) {
        case E1000_STATUS_PCIX_SPEED_66:
            hw->bus_speed = em_bus_speed_66;
            break;
        case E1000_STATUS_PCIX_SPEED_100:
            hw->bus_speed = em_bus_speed_100;
            break;
        case E1000_STATUS_PCIX_SPEED_133:
            hw->bus_speed = em_bus_speed_133;
            break;
        default:
            hw->bus_speed = em_bus_speed_reserved;
            break;
d5215 3
a5218 2
    hw->bus_width = (status & E1000_STATUS_BUS64) ?
                    em_bus_width_64 : em_bus_width_32;
d5283 1
d5291 1
d5296 2
d5300 1
a5300 2
        switch((phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
               M88E1000_PSSR_CABLE_LENGTH_SHIFT) {
d5408 2
a5409 1
    } else if(hw->phy_type == em_phy_igp) {
d5461 2
a5462 1
    if(hw->phy_type == em_phy_igp) {
d5469 1
a5469 2
    }
    else if(hw->phy_type == em_phy_m88) {
d5478 1
d5499 1
a5499 1
    uint16_t phy_data, speed, duplex, i;
d5580 15
d5617 8
d5629 15
d5657 9
d5733 1
a5733 2
    if(!((hw->mac_type == em_82541_rev_2) ||
         (hw->mac_type == em_82547_rev_2)))
d5739 9
a5747 3
    ret_val = em_read_phy_reg(hw, IGP01E1000_GMII_FIFO, &phy_data);
    if(ret_val)
        return ret_val;
d5750 13
a5762 4
        phy_data &= ~IGP01E1000_GMII_FLEX_SPD;
        ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data);
        if(ret_val)
            return ret_val;
d5768 16
a5783 3
        ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, &phy_data);
        if(ret_val)
            return ret_val;
d5785 6
a5790 4
        phy_data |= IGP01E1000_PSCFR_SMART_SPEED;
        ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, phy_data);
        if(ret_val)
            return ret_val;
d5796 13
a5808 4
        phy_data |= IGP01E1000_GMII_FLEX_SPD;
        ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data);
        if(ret_val)
            return ret_val;
d5824 11
a5834 2
/******************************************************************************
 * Change VCO speed register to improve Bit Error Rate performance of SERDES.
d5836 5
a5840 4
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_set_vco_speed(struct em_hw *hw)
d5842 1
a5842 2
    int32_t  ret_val;
    uint16_t default_page = 0;
d5844 1
d5846 2
a5847 1
    DEBUGFUNC("em_set_vco_speed");
d5849 3
a5851 7
    switch(hw->mac_type) {
    case em_82545_rev_3:
    case em_82546_rev_3:
       break;
    default:
        return E1000_SUCCESS;
    }
d5853 79
a5931 1
    /* Set PHY register 30, page 5, bit 8 to 0 */
d5972 676
@


1.7
log
@spelling in comment
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.6 2005/02/17 18:07:36 jfb Exp $ */
d39 1
a39 1
#ifdef __FreeBSD__
a421 1
#if defined(__FreeBSD__) && !defined(__arm__)
a422 1
#endif
@


1.6
log
@miscellaneous typo fixes:
- sturct -> struct (spotted by pedro)
- elimination of consecutive 'the' words

ok jmc@@, henning@@, krw@@, robert@@, some whining by jolan@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.5 2004/11/16 14:39:14 brad Exp $ */
d672 1
a672 1
 * Determines which flow control settings to use. Calls the apropriate media-
@


1.5
log
@- Added fix for 82547 which corrects an issue with Jumbo frames larger than 10k.
- Corrected TBI workaround.
- Corrected incorrect LED operation issues.

From FreeBSD

ok deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.4 2004/04/18 04:15:00 henric Exp $ */
d3567 1
a3567 1
 * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is
@


1.4
log
@Sync with FreeBSD's "em".
@
text
@d34 1
a34 1
/* $OpenBSD: if_em_hw.c,v 1.3 2003/12/09 23:37:03 henning Exp $ */
d41 1
a41 1
__FBSDID("$FreeBSD: if_em_hw.c,v 1.13 2004/02/10 21:31:09 pdeuskar Exp $");
d43 1
a43 1
 
d118 1
d304 1
d422 1
d424 1
a525 1

d529 2
a530 1
    if((ret_val = em_id_led_init(hw))) {
d651 2
a652 2
    if ((ret_val = em_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1,
                                     &eeprom_data))) {
d659 2
a660 2
        if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL,
                                          eeprom_data)))
d809 2
a810 1
    if((ret_val = em_adjust_serdes_amplitude(hw)))
d817 2
a818 1
    if((ret_val = em_set_vco_speed(hw)))
d905 2
a906 1
            if((ret_val = em_check_for_link(hw))) {
d953 2
a954 1
    if((ret_val = em_detect_gig_phy(hw))) {
d960 12
d980 2
a981 1
            if((ret_val = em_phy_reset(hw))) {
d996 2
a997 1
            if((ret_val = em_set_d3_lplu_state(hw, FALSE))) {
d1003 3
a1005 2
            if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
                                             &phy_data)))
d1032 3
a1034 2
            if((ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
                                              phy_data)))
d1052 3
a1054 3
                    if((ret_val = em_read_phy_reg(hw,
                                                    IGP01E1000_PHY_PORT_CONFIG,
                                                    &phy_data)))
d1057 4
a1060 3
                    if((ret_val = em_write_phy_reg(hw,
                                                     IGP01E1000_PHY_PORT_CONFIG,
                                                     phy_data)))
d1063 2
a1064 2
                    if((ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL,
                                                     &phy_data)))
d1067 2
a1068 2
                    if((ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL,
                                                      phy_data)))
d1072 2
a1073 2
                if((ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL,
                                                 &phy_data)))
d1096 2
a1097 2
                if((ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL,
                                                  phy_data)))
d1102 3
a1104 2
            if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                             &phy_data)))
d1143 3
a1145 2
            if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                              phy_data)))
d1151 3
a1153 2
            if((ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
                                             &phy_data)))
d1164 3
a1166 3
                if((ret_val = em_write_phy_reg(hw,
                                                  M88E1000_EXT_PHY_SPEC_CTRL,
                                                  phy_data)))
d1171 2
a1172 1
            if((ret_val = em_phy_reset(hw))) {
d1206 2
a1207 1
            if((ret_val = em_phy_setup_autoneg(hw))) {
d1216 2
a1217 1
            if((ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data)))
d1221 2
a1222 1
            if((ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data)))
d1229 2
a1230 1
                if((ret_val = em_wait_autoneg(hw))) {
d1238 2
a1239 1
            if((ret_val = em_phy_force_speed_duplex(hw))) {
d1250 2
a1251 1
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
d1253 2
a1254 1
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
d1269 2
a1270 1
                if((ret_val = em_config_mac_to_phy(hw))) {
d1275 2
a1276 1
            if((ret_val = em_config_fc_after_link_up(hw))) {
d1283 2
a1284 1
                if((ret_val = em_config_dsp_after_link_change(hw, TRUE))) {
d1314 2
a1315 2
    if((ret_val = em_read_phy_reg(hw, PHY_AUTONEG_ADV,
                                     &mii_autoneg_adv_reg)))
d1319 2
a1320 1
    if((ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg)))
d1427 2
a1428 2
    if((ret_val = em_write_phy_reg(hw, PHY_AUTONEG_ADV,
                                      mii_autoneg_adv_reg)))
d1433 2
a1434 1
    if((ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg)))
d1473 2
a1474 1
    if((ret_val = em_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg)))
d1576 2
a1577 1
            if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
d1580 2
a1581 1
            if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
d1589 2
a1590 1
            if((ret_val = em_phy_reset_dsp(hw))) {
d1602 2
a1603 1
            if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
d1606 2
a1607 1
            if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
d1617 2
a1618 2
        if((ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
                                         &phy_data)))
d1622 2
a1623 2
        if((ret_val = em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
                                          phy_data)))
d1629 2
a1630 2
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                         &phy_data)))
d1634 2
a1635 2
        if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                          phy_data)))
a1636 20

        /* Polarity reversal workaround for forced 10F/10H links. */
        if(hw->mac_type <= em_82544 &&
           (hw->forced_speed_duplex == em_10_full ||
            hw->forced_speed_duplex == em_10_half)) {
            if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
                                              0x0019)))
                return ret_val;
            if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL,
                                              0x8F0F)))
                return ret_val;
            /* IEEE requirement is 150ms */
            msec_delay(200);
            if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
                                              0x0019)))
                return ret_val;
            if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL,
                                              0x8F00)))
                return ret_val;
        }
d1694 3
a1696 2
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
                                         &phy_data)))
d1714 3
a1716 2
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                         &phy_data)))
d1834 2
a1835 1
        if((ret_val = em_force_mac_fc(hw))) {
d1851 2
a1852 1
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
d1854 2
a1855 1
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
d1865 3
a1867 2
            if((ret_val = em_read_phy_reg(hw, PHY_AUTONEG_ADV,
                                             &mii_nway_adv_reg)))
d1869 3
a1871 2
            if((ret_val = em_read_phy_reg(hw, PHY_LP_ABILITY,
                                             &mii_nway_lp_ability_reg)))
d1988 2
a1989 1
            if((ret_val = em_get_speed_and_duplex(hw, &speed, &duplex))) {
d2000 2
a2001 1
            if((ret_val = em_force_mac_fc(hw))) {
d2022 1
a2022 1
    uint32_t rxcw;
d2032 3
d2039 3
a2041 2
    if(hw->media_type == em_media_type_fiber)
        signal = (hw->mac_type > em_82544) ? E1000_CTRL_SWDPIN1 : 0;
d2043 6
a2048 3
    ctrl = E1000_READ_REG(hw, CTRL);
    status = E1000_READ_REG(hw, STATUS);
    rxcw = E1000_READ_REG(hw, RXCW);
d2062 2
a2063 1
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
d2065 2
a2066 1
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
d2100 2
a2101 1
            if((ret_val = em_config_mac_to_phy(hw))) {
d2111 2
a2112 1
        if((ret_val = em_config_fc_after_link_up(hw))) {
d2124 1
a2124 1
        if(hw->tbi_compatibility_en) {
d2161 2
a2162 2
            ((ctrl & E1000_CTRL_SWDPIN1) == signal)) ||
            (hw->media_type == em_media_type_internal_serdes)) &&
d2180 2
a2181 1
        if((ret_val = em_config_fc_after_link_up(hw))) {
d2193 1
a2193 2
              (ctrl & E1000_CTRL_SLU) &&
              (rxcw & E1000_RXCW_C)) {
d2273 2
a2274 1
        if((ret_val = em_read_phy_reg(hw, PHY_AUTONEG_EXP, &phy_data)))
d2280 2
a2281 1
            if((ret_val == em_read_phy_reg(hw, PHY_LP_ABILITY, &phy_data)))
d2312 2
a2313 1
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
d2315 2
a2316 1
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
d2481 3
a2483 2
        if((ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
                                             (uint16_t)reg_addr)))
d2585 3
a2587 2
        if((ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
                                             (uint16_t)reg_addr)))
d2726 2
a2727 1
        if((ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data)))
d2731 2
a2732 1
        if((ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data)))
d2759 2
a2760 1
    if((ret_val = em_read_phy_reg(hw, PHY_ID1, &phy_id_high)))
d2765 2
a2766 1
    if((ret_val = em_read_phy_reg(hw, PHY_ID2, &phy_id_low)))
d2818 6
a2823 3
        if((ret_val = em_write_phy_reg(hw, 29, 0x001d))) break;
        if((ret_val = em_write_phy_reg(hw, 30, 0x00c1))) break;
        if((ret_val = em_write_phy_reg(hw, 30, 0x0000))) break;
d2856 2
a2857 1
    if((ret_val = em_check_polarity(hw, &polarity)))
d2862 2
a2863 2
    if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
                                     &phy_data)))
d2872 2
a2873 1
        if((ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data)))
d2882 2
a2883 1
        if((ret_val = em_get_cable_length(hw, &min_length, &max_length)))
d2923 2
a2924 1
    if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data)))
d2935 2
a2936 1
    if((ret_val = em_check_polarity(hw, &polarity)))
d2941 2
a2942 1
    if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data)))
d2955 2
a2956 1
        if((ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data)))
d2998 2
a2999 1
    if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
d3002 2
a3003 1
    if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
d3466 1
d4235 8
a4242 6
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_GMII_FIFO,
                                         &hw->phy_spd_default)))
            return ret_val;
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
                                          (uint16_t)(hw->phy_spd_default &
                                          ~IGP01E1000_GMII_SPD))))
d4289 3
a4291 2
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
                                          hw->phy_spd_default)))
d4738 3
a4740 2
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                         &phy_data)))
d4779 2
a4780 1
            if((ret_val = em_read_phy_reg(hw, agc_reg_array[i], &phy_data)))
d4847 3
a4849 2
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                         &phy_data)))
d4855 3
a4857 2
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
                                         &phy_data)))
d4866 3
a4868 2
            if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG,
                                             &phy_data)))
d4906 3
a4908 2
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH,
                                         &phy_data)))
d4914 3
a4916 2
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                         &phy_data)))
d4956 2
a4957 1
        if((ret_val = em_get_speed_and_duplex(hw, &speed, &duplex))) {
d4970 3
a4972 2
                    if((ret_val = em_read_phy_reg(hw, dsp_reg_array[i],
                                                     &phy_data)))
d4977 3
a4979 2
                    if((ret_val = em_write_phy_reg(hw, dsp_reg_array[i],
                                                      phy_data)))
d4992 3
a4994 2
                if((ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS,
                                                 &phy_data)))
d4999 3
a5001 2
                    if((ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS,
                                                     &phy_data)))
d5008 1
a5008 1
                        if((ret_val = em_write_phy_reg(hw,
d5010 2
a5011 1
                                    IGP01E1000_PHY_DSP_FFE_CM_CP)))
d5023 3
a5025 2
            if((ret_val = em_write_phy_reg(hw, 0x0000,
                IGP01E1000_IEEE_FORCE_GIGA)))
d5028 2
a5029 2
                if((ret_val = em_read_phy_reg(hw, dsp_reg_array[i],
                                                 &phy_data)))
d5035 2
a5036 2
                if((ret_val = em_write_phy_reg(hw,dsp_reg_array[i],
                                                  phy_data)))
d5040 3
a5042 2
            if((ret_val = em_write_phy_reg(hw, 0x0000,
                                              IGP01E1000_IEEE_RESTART_AUTONEG)))
d5049 3
a5051 2
            if((ret_val = em_write_phy_reg(hw, 0x0000,
                                              IGP01E1000_IEEE_FORCE_GIGA)))
d5053 8
a5060 2
            if((ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_DSP_FFE,
                                              IGP01E1000_PHY_DSP_FFE_DEFAULT)))
d5062 28
d5091 7
a5097 2
            if((ret_val = em_write_phy_reg(hw, 0x0000,
                                              IGP01E1000_IEEE_RESTART_AUTONEG)))
d5099 2
a5100 1
        hw->ffe_config_state = em_ffe_config_enabled;
d5103 1
d5136 2
a5137 1
    if((ret_val = em_read_phy_reg(hw, IGP01E1000_GMII_FIFO, &phy_data)))
d5142 2
a5143 1
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data)))
d5150 2
a5151 2
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                         &phy_data)))
d5155 2
a5156 2
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                          phy_data)))
d5164 2
a5165 1
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data)))
d5169 2
a5170 2
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                         &phy_data)))
d5174 2
a5175 2
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                          phy_data)))
d5206 2
a5207 2
    if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
                                     &default_page)))
d5210 2
a5211 1
    if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0005)))
d5214 2
a5215 1
    if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data)))
d5219 2
a5220 1
    if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data)))
d5225 2
a5226 1
    if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0004)))
d5229 2
a5230 1
    if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data)))
d5234 2
a5235 1
    if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data)))
d5238 2
a5239 2
    if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
                                      default_page)))
@


1.3
log
@sync with FreeBSD
allow for support of several newer chips that apparently are all sold as
PROO/1000 and PRO/1000MT
tested by naddy@@ and ho@@
ok deraadt@@
@
text
@d34 1
a34 2
/* $FreeBSD: if_em_hw.c,v 1.12 2003/11/14 18:02:24 pdeuskar Exp $ */
/* $OpenBSD: if_em_hw.c,v 1.2 2003/06/13 19:21:21 henric Exp $ */
d38 5
d149 8
a156 2
        hw->phy_type = em_phy_igp;
        break;
a206 1

d1543 2
a1544 2
        if(i == 0) { /* We didn't get link */
            /* Reset the DSP and wait again for link. */
d1591 19
a1992 1
    uint16_t lp_capability;
d2072 4
a2075 6
         * parter capability register.  We use the link partner capability to
         * determine if TBI Compatibility needs to be turned on or off.  If
         * the link partner advertises any speed in addition to Gigabit, then
         * we assume that they are GMII-based, and TBI compatibility is not
         * needed. If no other speeds are advertised, we assume the link
         * partner is TBI-based, and we turn on TBI Compatibility.
d2078 5
a2082 10
            if((ret_val = em_read_phy_reg(hw, PHY_LP_ABILITY,
                                             &lp_capability)))
                return ret_val;
            if(lp_capability & (NWAY_LPAR_10T_HD_CAPS |
                                NWAY_LPAR_10T_FD_CAPS |
                                NWAY_LPAR_100TX_HD_CAPS |
                                NWAY_LPAR_100TX_FD_CAPS |
                                NWAY_LPAR_100T4_CAPS)) {
                /* If our link partner advertises anything in addition to
                 * gigabit, we do not need to enable TBI compatibility.
d2150 23
d2573 2
a2574 2
        for(i = 0; i < 64; i++) {
            usec_delay(50);
d3590 1
a3590 1
    if(eeprom->type == em_eeprom_microwire)
d3592 1
a3592 1
    else
d3594 2
d3813 3
a3815 6
       (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
        if(hw->perm_mac_addr[5] & 0x01)
            hw->perm_mac_addr[5] &= ~(0x01);
        else
            hw->perm_mac_addr[5] |= 0x01;
    }
a3833 2
    uint32_t addr_low;
    uint32_t addr_high;
a3838 6
    addr_low = (hw->mac_addr[0] |
                (hw->mac_addr[1] << 8) |
                (hw->mac_addr[2] << 16) | (hw->mac_addr[3] << 24));

    addr_high = (hw->mac_addr[4] |
                 (hw->mac_addr[5] << 8) | E1000_RAH_AV);
d3840 1
a3840 2
    E1000_WRITE_REG_ARRAY(hw, RA, 0, addr_low);
    E1000_WRITE_REG_ARRAY(hw, RA, 1, addr_high);
d3857 1
d3868 2
a3869 1
                          uint32_t pad)
a3872 1
    uint32_t rar_used_count = 1; /* RAR[0] is used for our MAC address */
d4606 2
a4607 2
    uint32_t io_addr = hw->io_base;
    uint32_t io_data = hw->io_base + 4;
d4626 2
a4627 2
    uint32_t io_addr = hw->io_base;
    uint32_t io_data = hw->io_base + 4;
@


1.2
log
@Sync with FreeBSD's "em".

ok deraadt@@
@
text
@d34 2
a35 2
/*$FreeBSD: if_em_hw.c,v 1.9 2003/06/05 17:51:38 pdeuskar Exp $*/
/* $OpenBSD: $ */
d39 1
a39 1

a82 1
static int32_t em_setup_fiber_link(struct em_hw *hw);
d84 2
a87 1
static int32_t em_force_mac_fc(struct em_hw *hw);
d90 2
a91 1
static void em_shift_out_mdi_bits(struct em_hw *hw, uint32_t data, uint16_t count);
d102 6
a107 1
static void em_shift_out_ee_bits(struct em_hw *hw, uint16_t data, uint16_t count);
d113 1
d115 11
d167 1
a167 1
        msec_delay(10);
a168 1
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x0000);
a171 2
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F95);
        em_write_phy_reg(hw,0x0015,0x0001);
d173 14
a186 2
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F71);
        em_write_phy_reg(hw,0x0011,0xBD21);
d188 8
a195 2
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F79);
        em_write_phy_reg(hw,0x0019,0x0018);
a196 2
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F30);
        em_write_phy_reg(hw,0x0010,0x1600);
d198 2
a199 2
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F31);
        em_write_phy_reg(hw,0x0011,0x0014);
d201 2
a202 2
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F32);
        em_write_phy_reg(hw,0x0012,0x161C);
d204 2
a205 2
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F94);
        em_write_phy_reg(hw,0x0014,0x0003);
d207 2
a208 2
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F96);
        em_write_phy_reg(hw,0x0016,0x003F);
d210 5
a214 2
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x2010);
        em_write_phy_reg(hw,0x0010,0x0008);
d216 9
a224 2
        em_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x0000);
        em_write_phy_reg(hw,0x0000,0x3300);
d273 5
d283 5
d289 1
a289 1
    case E1000_DEV_ID_82541EP:
d292 5
d300 3
d308 19
d328 20
a347 1
    return E1000_SUCCESS;
d349 1
d355 1
a355 1
void
d392 8
a405 7
    ctrl = E1000_READ_REG(hw, CTRL);

    /* Must reset the PHY before resetting the MAC */
    if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
        E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
	msec_delay(5);
    }
d413 1
d418 5
d428 33
a460 14
    /* Force a reload from the EEPROM if necessary */
    if(hw->mac_type < em_82540) {
        /* Wait for reset to complete */
        usec_delay(10);
        ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
        ctrl_ext |= E1000_CTRL_EXT_EE_RST;
        E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
        E1000_WRITE_FLUSH(hw);
        /* Wait for EEPROM reload */
        msec_delay(2);
    } else {
        /* Wait for EEPROM reload (it happens automatically) */
        msec_delay(5);
        /* Dissable HW ARPs on ASF enabled adapters */
d488 2
d506 1
a506 1
    uint32_t ctrl, status;
d517 1
a517 2
    ret_val = em_id_led_init(hw);
    if(ret_val < 0) {
d522 2
a523 19
    /* Set the Media Type and exit with error if it is not valid. */
    if(hw->mac_type != em_82543) {
        /* tbi_compatibility is only valid on 82543 */
        hw->tbi_compatibility_en = FALSE;
    }

    if(hw->mac_type >= em_82543) {
        status = E1000_READ_REG(hw, STATUS);
        if(status & E1000_STATUS_TBIMODE) {
            hw->media_type = em_media_type_fiber;
            /* tbi_compatibility not valid on fiber */
            hw->tbi_compatibility_en = FALSE;
        } else {
            hw->media_type = em_media_type_copper;
        }
    } else {
        /* This is an 82542 (fiber only) */
        hw->media_type = em_media_type_fiber;
    }
d568 22
a589 14
    /* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
    if(hw->bus_type == em_bus_type_pcix) {
        em_read_pci_cfg(hw, PCIX_COMMAND_REGISTER, &pcix_cmd_word);
        em_read_pci_cfg(hw, PCIX_STATUS_REGISTER_HI, &pcix_stat_hi_word);
        cmd_mmrbc = (pcix_cmd_word & PCIX_COMMAND_MMRBC_MASK) >>
            PCIX_COMMAND_MMRBC_SHIFT;
        stat_mmrbc = (pcix_stat_hi_word & PCIX_STATUS_HI_MMRBC_MASK) >>
            PCIX_STATUS_HI_MMRBC_SHIFT;
        if(stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
            stat_mmrbc = PCIX_STATUS_HI_MMRBC_2K;
        if(cmd_mmrbc > stat_mmrbc) {
            pcix_cmd_word &= ~PCIX_COMMAND_MMRBC_MASK;
            pcix_cmd_word |= stat_mmrbc << PCIX_COMMAND_MMRBC_SHIFT;
            em_write_pci_cfg(hw, PCIX_COMMAND_REGISTER, &pcix_cmd_word);
d591 1
d615 40
d725 3
a727 3
    ret_val = (hw->media_type == em_media_type_fiber) ?
              em_setup_fiber_link(hw) :
              em_setup_copper_link(hw);
d766 1
a766 1
 * Sets up link for a fiber based adapter
d775 1
a775 1
em_setup_fiber_link(struct em_hw *hw)
d781 1
a781 1
    uint32_t signal;
d784 1
a784 1
    DEBUGFUNC("em_setup_fiber_link");
d786 1
a786 1
    /* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be
d788 3
a790 1
     * cleared when there is a signal
d793 5
a797 2
    if(hw->mac_type > em_82544) signal = E1000_CTRL_SWDPIN1;
    else signal = 0;
d802 4
d872 1
d874 2
a875 1
    if((E1000_READ_REG(hw, CTRL) & E1000_CTRL_SWDPIN1) == signal) {
d883 2
d886 2
a887 2
             * em_check_for_link. This routine will force the link up if we
             * detect a signal. This will allow us to communicate with
d890 1
a890 4
            DEBUGOUT("Never got a valid link from auto-neg!!!\n");
            hw->autoneg_failed = 1;
            ret_val = em_check_for_link(hw);
            if(ret_val < 0) {
d902 1
a902 1
    return 0;
d937 1
a937 2
    ret_val = em_detect_gig_phy(hw);
    if(ret_val < 0) {
d943 15
a957 1
    if (hw->phy_type == em_phy_igp) {
d959 11
a969 5
        ret_val = em_phy_reset(hw);
        if(ret_val < 0) {
            DEBUGOUT("Error Resetting the PHY\n");
            return ret_val;
        }
d971 4
a974 2
        /* Wait 10ms for MAC to configure PHY from eeprom settings */
        msec_delay(15);
d976 6
a981 4
        if(em_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0000) < 0) {
            DEBUGOUT("PHY Write Error\n");
            return -E1000_ERR_PHY;
        }
d983 3
a985 5
        /* Configure activity LED after PHY reset */
        led_ctrl = E1000_READ_REG(hw, LEDCTL);
        led_ctrl &= IGP_ACTIVITY_LED_MASK;
        led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
        E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
d987 12
a998 6
        if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
            /* Disable SmartSpeed */
            if(em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                  &phy_data) < 0) {
                DEBUGOUT("PHY Read Error\n");
                return -E1000_ERR_PHY;
d1000 3
a1002 17
            phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
            if(em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                   phy_data) < 0) {
                DEBUGOUT("PHY Write Error\n");
                return -E1000_ERR_PHY;
            }
            /* Set auto Master/Slave resolution process */
            if(em_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data) < 0) {
                DEBUGOUT("PHY Read Error\n");
                return -E1000_ERR_PHY;
            }
            phy_data &= ~CR_1000T_MS_ENABLE;
            if(em_write_phy_reg(hw, PHY_1000T_CTRL, phy_data) < 0) {
                DEBUGOUT("PHY Write Error\n");
                return -E1000_ERR_PHY;
            }
        }
d1004 33
a1036 4
        if(em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d1038 3
a1040 3
        /* Force MDI for IGP PHY */
        phy_data &= ~(IGP01E1000_PSCR_AUTO_MDIX |
                      IGP01E1000_PSCR_FORCE_MDI_MDIX);
d1042 29
a1070 1
        hw->mdix = 1;
d1072 1
a1072 4
        if(em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data) < 0) {
            DEBUGOUT("PHY Write Error\n");
            return -E1000_ERR_PHY;
        }
d1074 8
a1081 7
    } else {
        /* Enable CRS on TX. This must be set for half-duplex operation. */
        if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
        phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
d1083 15
a1097 8
        /* Options:
         *   MDI/MDI-X = 0 (default)
         *   0 - Auto for all speeds
         *   1 - MDI mode
         *   2 - MDI-X mode
         *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
         */
        phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
d1099 12
a1110 15
        switch (hw->mdix) {
        case 1:
            phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
            break;
        case 2:
            phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
            break;
        case 3:
            phy_data |= M88E1000_PSCR_AUTO_X_1000T;
            break;
        case 0:
        default:
            phy_data |= M88E1000_PSCR_AUTO_X_MODE;
            break;
        }
d1112 6
a1117 13
        /* Options:
         *   disable_polarity_correction = 0 (default)
         *       Automatic Correction for Reversed Cable Polarity
         *   0 - Disabled
         *   1 - Enabled
         */
        phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
        if(hw->disable_polarity_correction == 1)
            phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;
        if(em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data) < 0) {
            DEBUGOUT("PHY Write Error\n");
            return -E1000_ERR_PHY;
        }
d1119 1
a1119 8
        /* Force TX_CLK in the Extended PHY Specific Control Register
         * to 25MHz clock.
         */
        if(em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
        phy_data |= M88E1000_EPSCR_TX_CLK_25;
d1121 10
a1130 10
        if (hw->phy_revision < M88E1011_I_REV_4) {
            /* Configure Master and Slave downshift values */
            phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
                          M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
            phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
                         M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
            if(em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
                                   phy_data) < 0) {
                DEBUGOUT("PHY Write Error\n");
                return -E1000_ERR_PHY;
a1131 1
        }
d1133 5
a1137 5
        /* SW Reset the PHY so all changes take effect */
        ret_val = em_phy_reset(hw);
        if(ret_val < 0) {
            DEBUGOUT("Error Resetting the PHY\n");
            return ret_val;
a1138 1
    }
d1140 20
a1159 8
    /* Options:
     *   autoneg = 1 (default)
     *      PHY will advertise value(s) parsed from
     *      autoneg_advertised and fc
     *   autoneg = 0
     *      PHY will be set to 10H, 10F, 100H, or 100F
     *      depending on value parsed from forced_speed_duplex.
     */
d1161 5
a1165 11
    /* Is autoneg enabled?  This is enabled by default or by software override.
     * If so, call em_phy_setup_autoneg routine to parse the
     * autoneg_advertised and fc options. If autoneg is NOT enabled, then the
     * user should have provided a speed/duplex override.  If so, then call
     * em_phy_force_speed_duplex to parse and set this up.
     */
    if(hw->autoneg) {
        /* Perform some bounds checking on the hw->autoneg_advertised
         * parameter.  If this variable is zero, then set it to the default.
         */
        hw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;
d1167 6
a1172 5
        /* If autoneg_advertised is zero, we assume it was not defaulted
         * by the calling code so we set to advertise full capability.
         */
        if(hw->autoneg_advertised == 0)
            hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;
d1174 5
a1178 7
        DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
        ret_val = em_phy_setup_autoneg(hw);
        if(ret_val < 0) {
            DEBUGOUT("Error Setting up Auto-Negotiation\n");
            return ret_val;
        }
        DEBUGOUT("Restarting Auto-Neg\n");
d1180 3
a1182 12
        /* Restart auto-negotiation by setting the Auto Neg Enable bit and
         * the Auto Neg Restart bit in the PHY control register.
         */
        if(em_read_phy_reg(hw, PHY_CTRL, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
        phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
        if(em_write_phy_reg(hw, PHY_CTRL, phy_data) < 0) {
            DEBUGOUT("PHY Write Error\n");
            return -E1000_ERR_PHY;
        }
d1184 14
a1197 7
        /* Does the user want to wait for Auto-Neg to complete here, or
         * check at a later time (for example, callback routine).
         */
        if(hw->wait_autoneg_complete) {
            ret_val = em_wait_autoneg(hw);
            if(ret_val < 0) {
                DEBUGOUT("Error while waiting for autoneg to complete\n");
d1201 1
a1201 9
        hw->get_link_status = TRUE;
    } else {
        DEBUGOUT("Forcing speed and duplex\n");
        ret_val = em_phy_force_speed_duplex(hw);
        if(ret_val < 0) {
            DEBUGOUT("Error Forcing Speed and Duplex\n");
            return ret_val;
        }
    }
d1207 5
a1211 8
        if(em_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
        if(em_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d1224 1
a1224 2
                ret_val = em_config_mac_to_phy(hw);
                if(ret_val < 0) {
d1227 1
a1227 1
                  }
d1229 1
a1229 2
            ret_val = em_config_fc_after_link_up(hw);
            if(ret_val < 0) {
d1234 9
a1242 1
            return 0;
d1248 1
a1248 1
    return 0;
d1259 1
d1266 3
a1268 4
    if(em_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
d1271 2
a1272 4
    if(em_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
d1378 3
a1380 4
    if(em_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg) < 0) {
        DEBUGOUT("PHY Write Error\n");
        return -E1000_ERR_PHY;
    }
d1384 4
a1387 5
    if(em_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg) < 0) {
        DEBUGOUT("PHY Write Error\n");
        return -E1000_ERR_PHY;
    }
    return 0;
d1423 2
a1424 4
    if(em_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
d1470 3
a1472 4
        if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d1478 4
a1481 4
        if(em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data) < 0) {
            DEBUGOUT("PHY Write Error\n");
            return -E1000_ERR_PHY;
        }
d1490 3
a1492 4
        if(em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d1497 3
a1499 4
        if(em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data) < 0) {
            DEBUGOUT("PHY Write Error\n");
            return -E1000_ERR_PHY;
        }
d1503 3
a1505 4
    if(em_write_phy_reg(hw, PHY_CTRL, mii_ctrl_reg) < 0) {
        DEBUGOUT("PHY Write Error\n");
        return -E1000_ERR_PHY;
    }
d1525 6
a1530 8
            if(em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
                DEBUGOUT("PHY Read Error\n");
                return -E1000_ERR_PHY;
            }
            if(em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
                DEBUGOUT("PHY Read Error\n");
                return -E1000_ERR_PHY;
            }
d1536 1
a1536 3

            ret_val = em_phy_reset_dsp(hw);
            if(ret_val < 0) {
d1548 5
a1552 8
            if(em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
                DEBUGOUT("PHY Read Error\n");
                return -E1000_ERR_PHY;
            }
            if(em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
                DEBUGOUT("PHY Read Error\n");
                return -E1000_ERR_PHY;
            }
d1561 4
a1564 4
        if(em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d1566 3
a1568 4
        if(em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data) < 0) {
            DEBUGOUT("PHY Write Error\n");
            return -E1000_ERR_PHY;
        }
d1573 4
a1576 4
        if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d1578 4
a1581 4
        if(em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data) < 0) {
            DEBUGOUT("PHY Write Error\n");
            return -E1000_ERR_PHY;
        }
d1583 1
a1583 1
    return 0;
d1623 1
d1639 4
a1642 4
        if(em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d1658 4
a1661 4
        if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d1677 1
a1677 1
    return 0;
d1691 1
a1691 1
static int32_t
d1744 1
a1744 1
    return 0;
d1775 1
d1777 1
a1777 2
        ret_val = em_force_mac_fc(hw);
        if(ret_val < 0) {
d1793 4
a1796 8
        if(em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
            DEBUGOUT("PHY Read Error \n");
            return -E1000_ERR_PHY;
        }
        if(em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
            DEBUGOUT("PHY Read Error \n");
            return -E1000_ERR_PHY;
        }
d1805 6
a1810 8
            if(em_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_nway_adv_reg) < 0) {
                DEBUGOUT("PHY Read Error\n");
                return -E1000_ERR_PHY;
            }
            if(em_read_phy_reg(hw, PHY_LP_ABILITY, &mii_nway_lp_ability_reg) < 0) {
                DEBUGOUT("PHY Read Error\n");
                return -E1000_ERR_PHY;
            }
d1912 3
a1914 2
            else if(hw->original_fc == em_fc_none ||
                    hw->original_fc == em_fc_tx_pause) {
d1926 4
a1929 1
            em_get_speed_and_duplex(hw, &speed, &duplex);
d1937 1
a1937 2
            ret_val = em_force_mac_fc(hw);
            if(ret_val < 0) {
d1940 1
a1940 1
             }
d1945 1
a1945 1
    return 0;
d1962 1
a1962 1
    uint32_t signal;
d1969 1
a1969 1
    /* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be
d1971 1
a1971 1
     * cleared when there is a signal
d1973 2
a1974 2
    if(hw->mac_type > em_82544) signal = E1000_CTRL_SWDPIN1;
    else signal = 0;
d1992 4
a1995 8
        if(em_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
        if(em_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d2005 1
d2014 3
d2028 1
a2028 2
            ret_val = em_config_mac_to_phy(hw);
            if(ret_val < 0) {
d2038 1
a2038 2
        ret_val = em_config_fc_after_link_up(hw);
        if(ret_val < 0) {
d2053 3
a2055 4
            if(em_read_phy_reg(hw, PHY_LP_ABILITY, &lp_capability) < 0) {
                DEBUGOUT("PHY Read Error\n");
                return -E1000_ERR_PHY;
            }
d2093 3
a2095 1
    else if((hw->media_type == em_media_type_fiber) &&
a2096 1
            ((ctrl & E1000_CTRL_SWDPIN1) == signal) &&
d2113 1
a2113 2
        ret_val = em_config_fc_after_link_up(hw);
        if(ret_val < 0) {
d2123 2
a2124 1
    else if((hw->media_type == em_media_type_fiber) &&
d2131 1
a2131 1
    return 0;
d2141 1
a2141 1
void
d2147 2
d2177 21
d2208 1
d2220 4
a2223 8
        if(em_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
        if(em_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d2225 1
a2225 1
            return 0;
d2229 1
a2229 1
    return 0;
d2243 1
a2243 1
     * bit), and then delay 2 microseconds.
d2247 1
a2247 1
    usec_delay(2);
d2261 1
a2261 1
     * bit), and then delay 2 microseconds.
d2265 1
a2265 1
    usec_delay(2);
d2309 1
a2309 1
        usec_delay(2);
d2371 2
a2372 2
* Reads the value from a PHY register
*
d2381 22
d2407 1
a2407 1
    DEBUGFUNC("em_read_phy_reg");
d2427 1
a2427 1
            usec_delay(10);
d2469 1
a2469 1
    return 0;
d2484 22
d2510 1
a2510 1
    DEBUGFUNC("em_write_phy_reg");
d2531 1
a2531 1
            usec_delay(10);
d2561 1
a2561 1
    return 0;
a2605 5
        if(em_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0000) < 0) {
            DEBUGOUT("PHY Write Error\n");
            return;
        }

d2624 1
d2629 12
a2640 11
    if(em_read_phy_reg(hw, PHY_CTRL, &phy_data) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
    phy_data |= MII_CR_RESET;
    if(em_write_phy_reg(hw, PHY_CTRL, phy_data) < 0) {
        DEBUGOUT("PHY Write Error\n");
        return -E1000_ERR_PHY;
    }
    usec_delay(1);
    if (hw->phy_type == em_phy_igp) {
d2642 2
a2643 2
    }
    return 0;
d2654 1
a2656 1
    int32_t phy_init_status;
d2661 3
a2663 4
    if(em_read_phy_reg(hw, PHY_ID1, &phy_id_high) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
d2666 3
a2668 4
    if(em_read_phy_reg(hw, PHY_ID2, &phy_id_low) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
d2681 1
d2683 1
d2687 1
d2689 1
d2700 1
a2700 1
        return 0;
d2714 1
a2714 1
    int32_t ret_val = -E1000_ERR_PHY;
d2718 4
a2721 4
        if(em_write_phy_reg(hw, 29, 0x001d) < 0) break;
        if(em_write_phy_reg(hw, 30, 0x00c1) < 0) break;
        if(em_write_phy_reg(hw, 30, 0x0000) < 0) break;
        ret_val = 0;
a2723 1
    if(ret_val < 0) DEBUGOUT("PHY Write Error\n");
d2734 2
a2735 1
em_phy_igp_get_info(struct em_hw *hw, struct em_phy_info *phy_info)
d2737 1
d2753 2
a2754 2
    if(em_check_polarity(hw, &polarity) < 0)
        return -E1000_ERR_PHY;
d2758 3
a2760 2
    if(em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data) < 0)
        return -E1000_ERR_PHY;
d2768 2
a2769 2
        if(em_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data) < 0)
            return -E1000_ERR_PHY;
d2777 2
a2778 2
        if(em_get_cable_length(hw, &min_length, &max_length) < 0)
            return -E1000_ERR_PHY;
d2805 2
a2806 1
em_phy_m88_get_info(struct em_hw *hw, struct em_phy_info *phy_info)
d2808 1
d2817 2
a2818 2
    if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0)
        return -E1000_ERR_PHY;
d2828 2
a2829 2
    if(em_check_polarity(hw, &polarity) < 0)
        return -E1000_ERR_PHY;
d2833 2
a2834 2
    if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data) < 0)
        return -E1000_ERR_PHY;
d2846 2
a2847 2
        if(em_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data) < 0)
            return -E1000_ERR_PHY;
d2869 1
d2888 6
a2893 8
    if(em_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
    if(em_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
d2899 1
a2899 1
    if (hw->phy_type == em_phy_igp)
d2915 1
a2915 1
    return 0;
d2947 1
d2949 1
d2962 1
d2964 1
a2964 1
    default:
d2989 12
d3009 22
a3030 22
                case EEPROM_SIZE_16KB:
                    eeprom->word_size = 8192;
                    break;
                case EEPROM_SIZE_8KB:
                    eeprom->word_size = 4096;
                    break;
                case EEPROM_SIZE_4KB:
                    eeprom->word_size = 2048;
                    break;
                case EEPROM_SIZE_2KB:
                    eeprom->word_size = 1024;
                    break;
                case EEPROM_SIZE_1KB:
                    eeprom->word_size = 512;
                    break;
                case EEPROM_SIZE_512B:
                    eeprom->word_size = 256;
                    break;
                case EEPROM_SIZE_128B:
                default:
                    eeprom->word_size = 64;
                    break;
d3135 2
a3136 1
em_shift_in_ee_bits(struct em_hw *hw, uint16_t count)
d3396 1
a3396 1
    if (em_acquire_eeprom(hw) != E1000_SUCCESS)
d3400 1
d3403 4
a3406 1
        if(em_spi_eeprom_ready(hw)) return -E1000_ERR_EEPROM;
a3416 7
    }
    else if(eeprom->type == em_eeprom_microwire) {
        /* Send the READ command (opcode + addr)  */
        em_shift_out_ee_bits(hw, EEPROM_READ_OPCODE_MICROWIRE,
                                eeprom->opcode_bits);
        em_shift_out_ee_bits(hw, offset, eeprom->address_bits);
    }
d3418 22
a3439 10
    /* Read the data.  The address of the eeprom internally increments with
     * each word (microwire) or byte (spi) being read, saving on the overhead
     * of eeprom setup and tear-down.  The address counter will roll over if
     * reading beyond the size of the eeprom, thus allowing the entire memory
     * to be read starting from any offset. */
    for (i = 0; i < words; i++) {
        uint16_t word_in = em_shift_in_ee_bits(hw, 16);
        if (eeprom->type == em_eeprom_spi)
            word_in = (word_in >> 8) | (word_in << 8);
        data[i] = word_in;
d3445 1
a3445 1
    return 0;
d3473 3
a3475 3
    if(checksum == (uint16_t) EEPROM_SUM) {
        return 0;
    } else {
d3509 1
a3509 1
    return 0;
d3707 1
a3707 1
    return 0;
d3741 1
a3741 1
    return 0;
d3767 1
a3767 1
    if((hw->mac_type == em_82546) &&
d3776 1
a3776 1
    return 0;
d4052 1
a4052 1
        return 0;
d4103 1
a4103 1
    return 0;
d4115 1
d4119 5
a4123 8
    switch(hw->device_id) {
    case E1000_DEV_ID_82542:
    case E1000_DEV_ID_82543GC_FIBER:
    case E1000_DEV_ID_82543GC_COPPER:
    case E1000_DEV_ID_82544EI_COPPER:
    case E1000_DEV_ID_82544EI_FIBER:
    case E1000_DEV_ID_82544GC_COPPER:
    case E1000_DEV_ID_82544GC_LOM:
d4126 27
a4152 24
    case E1000_DEV_ID_82545EM_FIBER:
    case E1000_DEV_ID_82546EB_FIBER:
        ledctl = E1000_READ_REG(hw, LEDCTL);
        /* Save current LEDCTL settings */
        hw->ledctl_default = ledctl;
        /* Turn off LED0 */
        ledctl &= ~(E1000_LEDCTL_LED0_IVRT |
                    E1000_LEDCTL_LED0_BLINK |
                    E1000_LEDCTL_LED0_MODE_MASK);
        ledctl |= (E1000_LEDCTL_MODE_LED_OFF << E1000_LEDCTL_LED0_MODE_SHIFT);
        E1000_WRITE_REG(hw, LEDCTL, ledctl);
        break;
    case E1000_DEV_ID_82540EP:
    case E1000_DEV_ID_82540EP_LOM:
    case E1000_DEV_ID_82540EP_LP:
    case E1000_DEV_ID_82540EM:
    case E1000_DEV_ID_82540EM_LOM:
    case E1000_DEV_ID_82545EM_COPPER:
    case E1000_DEV_ID_82546EB_COPPER:
    case E1000_DEV_ID_82546EB_QUAD_COPPER:
    case E1000_DEV_ID_82541EI:
    case E1000_DEV_ID_82541EP:
    case E1000_DEV_ID_82547EI:
        E1000_WRITE_REG(hw, LEDCTL, hw->ledctl_mode1);
a4153 3
    default:
        DEBUGOUT("Invalid device ID\n");
        return -E1000_ERR_CONFIG;
d4155 2
a4156 1
    return 0;
d4167 2
d4171 5
a4175 8
    switch(hw->device_id) {
    case E1000_DEV_ID_82542:
    case E1000_DEV_ID_82543GC_FIBER:
    case E1000_DEV_ID_82543GC_COPPER:
    case E1000_DEV_ID_82544EI_COPPER:
    case E1000_DEV_ID_82544EI_FIBER:
    case E1000_DEV_ID_82544GC_COPPER:
    case E1000_DEV_ID_82544GC_LOM:
d4178 10
a4187 13
    case E1000_DEV_ID_82540EP:
    case E1000_DEV_ID_82540EP_LOM:
    case E1000_DEV_ID_82540EP_LP:
    case E1000_DEV_ID_82540EM:
    case E1000_DEV_ID_82540EM_LOM:
    case E1000_DEV_ID_82545EM_COPPER:
    case E1000_DEV_ID_82545EM_FIBER:
    case E1000_DEV_ID_82546EB_COPPER:
    case E1000_DEV_ID_82546EB_FIBER:
    case E1000_DEV_ID_82546EB_QUAD_COPPER:
    case E1000_DEV_ID_82541EI:
    case E1000_DEV_ID_82541EP:
    case E1000_DEV_ID_82547EI:
a4190 3
    default:
        DEBUGOUT("Invalid device ID\n");
        return -E1000_ERR_CONFIG;
d4192 2
a4193 1
    return 0;
d4204 1
a4204 1
    uint32_t ctrl;
d4208 4
a4211 6
    switch(hw->device_id) {
    case E1000_DEV_ID_82542:
    case E1000_DEV_ID_82543GC_FIBER:
    case E1000_DEV_ID_82543GC_COPPER:
    case E1000_DEV_ID_82544EI_FIBER:
        ctrl = E1000_READ_REG(hw, CTRL);
a4214 1
        E1000_WRITE_REG(hw, CTRL, ctrl);
d4216 10
a4225 10
    case E1000_DEV_ID_82544EI_COPPER:
    case E1000_DEV_ID_82544GC_COPPER:
    case E1000_DEV_ID_82544GC_LOM:
    case E1000_DEV_ID_82545EM_FIBER:
    case E1000_DEV_ID_82546EB_FIBER:
        ctrl = E1000_READ_REG(hw, CTRL);
        /* Clear SW Defineable Pin 0 to turn on the LED */
        ctrl &= ~E1000_CTRL_SWDPIN0;
        ctrl |= E1000_CTRL_SWDPIO0;
        E1000_WRITE_REG(hw, CTRL, ctrl);
d4227 9
a4235 12
    case E1000_DEV_ID_82540EP:
    case E1000_DEV_ID_82540EP_LOM:
    case E1000_DEV_ID_82540EP_LP:
    case E1000_DEV_ID_82540EM:
    case E1000_DEV_ID_82540EM_LOM:
    case E1000_DEV_ID_82545EM_COPPER:
    case E1000_DEV_ID_82546EB_COPPER:
    case E1000_DEV_ID_82546EB_QUAD_COPPER:
    case E1000_DEV_ID_82541EI:
    case E1000_DEV_ID_82541EP:
    case E1000_DEV_ID_82547EI:
        E1000_WRITE_REG(hw, LEDCTL, hw->ledctl_mode2);
a4236 3
    default:
        DEBUGOUT("Invalid device ID\n");
        return -E1000_ERR_CONFIG;
d4238 4
a4241 1
    return 0;
d4252 1
a4252 1
    uint32_t ctrl;
d4256 4
a4259 6
    switch(hw->device_id) {
    case E1000_DEV_ID_82542:
    case E1000_DEV_ID_82543GC_FIBER:
    case E1000_DEV_ID_82543GC_COPPER:
    case E1000_DEV_ID_82544EI_FIBER:
        ctrl = E1000_READ_REG(hw, CTRL);
a4262 1
        E1000_WRITE_REG(hw, CTRL, ctrl);
d4264 10
a4273 10
    case E1000_DEV_ID_82544EI_COPPER:
    case E1000_DEV_ID_82544GC_COPPER:
    case E1000_DEV_ID_82544GC_LOM:
    case E1000_DEV_ID_82545EM_FIBER:
    case E1000_DEV_ID_82546EB_FIBER:
        ctrl = E1000_READ_REG(hw, CTRL);
        /* Set SW Defineable Pin 0 to turn off the LED */
        ctrl |= E1000_CTRL_SWDPIN0;
        ctrl |= E1000_CTRL_SWDPIO0;
        E1000_WRITE_REG(hw, CTRL, ctrl);
d4275 9
a4283 12
    case E1000_DEV_ID_82540EP:
    case E1000_DEV_ID_82540EP_LOM:
    case E1000_DEV_ID_82540EP_LP:
    case E1000_DEV_ID_82540EM:
    case E1000_DEV_ID_82540EM_LOM:
    case E1000_DEV_ID_82545EM_COPPER:
    case E1000_DEV_ID_82546EB_COPPER:
    case E1000_DEV_ID_82546EB_QUAD_COPPER:
    case E1000_DEV_ID_82541EI:
    case E1000_DEV_ID_82541EP:
    case E1000_DEV_ID_82547EI:
        E1000_WRITE_REG(hw, LEDCTL, hw->ledctl_mode1);
a4284 3
    default:
        DEBUGOUT("Invalid device ID\n");
        return -E1000_ERR_CONFIG;
d4286 4
a4289 1
    return 0;
d4412 1
a4412 2
        if((hw->collision_delta * hw->ifs_ratio) >
           hw->tx_packet_delta) {
d4424 1
a4424 2
            if((hw->in_ifs_mode == TRUE) &&
               (hw->tx_packet_delta <= MIN_NUM_XMITS)) {
d4607 2
a4608 1
 * returns: E1000_SUCCESS / -E1000_ERR_XXX
d4616 2
a4617 1
em_get_cable_length(struct em_hw *hw, uint16_t *min_length,
d4620 1
d4631 3
a4633 2
        if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data) < 0)
            return -E1000_ERR_PHY;
d4663 2
a4664 1
        uint16_t agc_reg_array[IGP01E1000_PHY_AGC_NUM] = {IGP01E1000_PHY_AGC_A,
d4669 4
a4672 8
        for(i = 0; i < IGP01E1000_PHY_AGC_NUM; i++) {
            if(em_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
                                   agc_reg_array[i]) != E1000_SUCCESS)
                return -E1000_ERR_PHY;
            if(em_read_phy_reg(hw, agc_reg_array[i] &
                                  IGP01E1000_PHY_PAGE_SELECT, &phy_data) !=
                                  E1000_SUCCESS)
                return -E1000_ERR_PHY;
a4687 5
        /* Return to page 0 */
        if(em_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0) !=
           E1000_SUCCESS)
            return -E1000_ERR_PHY;

d4689 1
a4689 1
        if(agc_value < IGP01E1000_PHY_AGC_NUM * em_igp_cable_length_50) {
d4693 1
a4693 1
            agc_value /= (IGP01E1000_PHY_AGC_NUM - 1);
d4696 1
a4696 1
            agc_value /= IGP01E1000_PHY_AGC_NUM;
d4718 2
a4719 1
 * returns: E1000_SUCCESS / -E1000_ERR_XXX
d4728 2
a4729 1
em_check_polarity(struct em_hw *hw, uint16_t *polarity)
d4731 1
d4738 3
a4740 2
        if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data) < 0)
            return -E1000_ERR_PHY;
d4745 3
a4747 2
        if(em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data) < 0)
            return -E1000_ERR_PHY;
d4755 3
a4757 12
            if(em_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
                                   IGP01E1000_PHY_PCS_INIT_REG) < 0)
                return -E1000_ERR_PHY;

            if(em_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG &
                                  IGP01E1000_PHY_PAGE_SELECT, &phy_data) < 0)
                return -E1000_ERR_PHY;

            /* Return to page 0 */
            if(em_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0) !=
               E1000_SUCCESS)
                return -E1000_ERR_PHY;
d4777 2
a4778 1
 * returns: E1000_SUCCESS / -E1000_ERR_XXX
d4788 1
d4794 4
a4797 4
        if(em_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
        }
d4801 137
a4937 3
        if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data) < 0) {
            DEBUGOUT("PHY Read Error\n");
            return -E1000_ERR_PHY;
a4938 2
        hw->speed_downgraded = (phy_data & M88E1000_PSSR_DOWNSHIFT) >>
                                M88E1000_PSSR_DOWNSHIFT_SHIFT;
d4940 129
@


1.1
log
@Driver for Intel PRO/1000 gigabit ethernet adapters.
This driver should work with all current models of gigabit ethernet adapters.

Driver written by Intel
Ported from FreeBSD by Henric Jungheim <henric@@attbi.com>
bus_dma and endian support by me.
@
text
@d1 1
a1 1
/**************************************************************************
d3 28
a30 2
Copyright (c) 2001-2002 Intel Corporation
All rights reserved.
d32 1
a32 27
Redistribution and use in source and binary forms of the Software, with or
without modification, are permitted provided that the following conditions
are met:

 1. Redistributions of source code of the Software may retain the above
    copyright notice, this list of conditions and the following disclaimer.

 2. Redistributions in binary form of the Software may reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

 3. Neither the name of the Intel Corporation nor the names of its
    contributors shall be used to endorse or promote products derived from
    this Software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR ITS CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
d34 2
a35 3
***************************************************************************/

/*$FreeBSD$*/
d81 2
d93 6
d102 3
a104 2
static uint16_t em_shift_in_ee_bits(struct em_hw *hw);
static void em_setup_eeprom(struct em_hw *hw);
d108 144
d264 1
a264 1
    uint16_t pci_cmd_word;
d267 1
a267 1
    
d270 2
a271 5
        if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
            DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
            pci_cmd_word = hw->pci_cmd_word & ~CMD_MEM_WRT_INVALIDATE;
            em_write_pci_cfg(hw, PCI_COMMAND_REGISTER, &pci_cmd_word);
        }
d284 1
d291 1
a291 1
     */ 
d302 20
a321 4
    if(hw->mac_type > em_82543)
        E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
    else
        E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
d330 1
d335 1
a335 1
        msec_delay(4);
d341 11
a351 1
    
d362 1
a362 1
            em_write_pci_cfg(hw, PCI_COMMAND_REGISTER, &hw->pci_cmd_word);
d370 2
a371 2
 * 
 * Assumes that the controller has previously been reset and is in a 
a382 1
    uint16_t pci_cmd_word;
d396 1
a396 1
    
d425 2
a426 5
        if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
            DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
            pci_cmd_word = hw->pci_cmd_word & ~CMD_MEM_WRT_INVALIDATE;
            em_write_pci_cfg(hw, PCI_COMMAND_REGISTER, &pci_cmd_word);
        }
d428 1
d440 1
d443 1
a443 1
            em_write_pci_cfg(hw, PCI_COMMAND_REGISTER, &hw->pci_cmd_word);
d468 2
d480 7
d499 1
a499 1
 * 
d501 1
a501 1
 * 
d505 1
a505 1
 * established. Assumes the hardware has previously been reset and the 
d525 1
a525 1
    if(em_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG, &eeprom_data) < 0) {
d533 1
a533 1
        else if((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 
d562 1
a562 1
        ctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) << 
d588 1
a588 1
     * registers will be set to 0. 
a611 1
 * ctrl - Current value of the device control register
d617 1
a617 1
static int32_t 
d629 2
a630 2
    /* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be 
     * set when the optics detect a signal. On older adapters, it will be 
d636 1
a636 1
   
d639 1
a639 1
    
d646 1
a646 1
     * auto-negotiation is disabled, then software will have to manually 
d651 1
a651 1
     *      1:  Rx flow control is enabled (we can receive pause frames, but 
d663 2
a664 2
        /* RX Flow control is enabled and TX Flow control is disabled by a 
         * software over-ride. Since there really isn't a way to advertise 
d672 1
a672 1
        /* TX Flow control is enabled, and RX Flow control is disabled, by a 
d697 1
d703 2
a704 2
     * indication in the Device Status Register.  Time-out if a link isn't 
     * seen in 500 milliseconds seconds (Auto-negotiation should complete in 
d715 1
a715 1
            /* AutoNeg failed to achieve a link, so we'll call 
a741 1
* ctrl - current value of the device control register
d743 1
a743 1
static int32_t 
d747 1
d777 95
a871 6
    /* Enable CRS on TX. This must be set for half-duplex operation. */
    if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
    phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
d873 13
a885 8
    /* Options:
     *   MDI/MDI-X = 0 (default)
     *   0 - Auto for all speeds
     *   1 - MDI mode
     *   2 - MDI-X mode
     *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
     */
    phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
d887 8
a894 15
    switch (hw->mdix) {
    case 1:
        phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
        break;
    case 2:
        phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
        break;
    case 3:
        phy_data |= M88E1000_PSCR_AUTO_X_1000T;
        break;
    case 0:
    default:
        phy_data |= M88E1000_PSCR_AUTO_X_MODE;
        break;
    }
d896 12
a907 13
    /* Options:
     *   disable_polarity_correction = 0 (default)
     *       Automatic Correction for Reversed Cable Polarity
     *   0 - Disabled
     *   1 - Enabled
     */
    phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
    if(hw->disable_polarity_correction == 1)
        phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;
    if(em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data) < 0) {
        DEBUGOUT("PHY Write Error\n");
        return -E1000_ERR_PHY;
    }
d909 6
a914 16
    /* Force TX_CLK in the Extended PHY Specific Control Register
     * to 25MHz clock.
     */
    if(em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
    phy_data |= M88E1000_EPSCR_TX_CLK_25;
    /* Configure Master and Slave downshift values */
    phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
                  M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
    phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
                 M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
    if(em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data) < 0) {
        DEBUGOUT("PHY Write Error\n");
        return -E1000_ERR_PHY;
a916 7
    /* SW Reset the PHY so all changes take effect */
    ret_val = em_phy_reset(hw);
    if(ret_val < 0) {
        DEBUGOUT("Error Resetting the PHY\n");
        return ret_val;
    }
    
d975 1
d1254 34
a1287 4
    /* Write the MII Control Register with the new PHY configuration. */
    if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
d1290 1
a1290 12
    /* Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI
     * forced whenever speed are duplex are forced.
     */
    phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
    if(em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data) < 0) {
        DEBUGOUT("PHY Write Error\n");
        return -E1000_ERR_PHY;
    }
    DEBUGOUT1("M88E1000 PSCR: %x \n", phy_data);
    
    /* Need to reset the PHY or these changes will be ignored */
    mii_ctrl_reg |= MII_CR_RESET;
d1327 1
a1327 1
            
a1350 14
    
    /* Because we reset the PHY above, we need to re-force TX_CLK in the
     * Extended PHY Specific Control Register to 25MHz clock.  This value
     * defaults back to a 2.5MHz clock when the PHY is reset.
     */
    if(em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
    phy_data |= M88E1000_EPSCR_TX_CLK_25;
    if(em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data) < 0) {
        DEBUGOUT("PHY Write Error\n");
        return -E1000_ERR_PHY;
    }
d1352 27
a1378 11
    /* In addition, because of the s/w reset above, we need to enable CRS on
     * TX.  This must be set for both full and half duplex operation.
     */
    if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
    phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
    if(em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data) < 0) {
        DEBUGOUT("PHY Write Error\n");
        return -E1000_ERR_PHY;
d1396 2
d1404 1
d1434 26
a1459 6
    if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data) < 0) {
        DEBUGOUT("PHY Read Error\n");
        return -E1000_ERR_PHY;
    }
    if(phy_data & M88E1000_PSSR_DPLX) ctrl |= E1000_CTRL_FD;
    else ctrl &= ~E1000_CTRL_FD;
d1461 1
a1461 1
    em_config_collision_dist(hw);
d1463 8
a1470 7
    /* Set up speed in the Device Control register depending on
     * negotiated values.
     */
    if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
        ctrl |= E1000_CTRL_SPD_1000;
    else if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
        ctrl |= E1000_CTRL_SPD_100;
d1478 1
a1478 1
 * 
d1545 1
a1545 1
 * 
d1767 3
a1769 3
    
    /* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be 
     * set when the optics detect a signal. On older adapters, it will be 
d1802 4
d1834 1
a1834 1
        /* Configure Flow Control now that Auto-Neg has completed. First, we 
d1863 1
a1863 1
                /* If our link partner advertises anything in addition to 
d2027 1
d2045 1
d2067 1
a2067 1
     * in the "data" parameter will be shifted out to the PHY one bit at a 
d2088 1
a2096 3

    /* Clear the data bit just before leaving this routine. */
    ctrl &= ~E1000_CTRL_MDIO;
d2104 1
a2104 1
* Bits are shifted in in MSB to LSB order. 
d2119 1
a2119 1
     */ 
d2127 1
a2147 3
    /* Clear the MDIO bit just before leaving this routine. */
    ctrl &= ~E1000_CTRL_MDIO;

d2179 1
a2179 1
                (phy_addr << E1000_MDIC_PHY_SHIFT) | 
d2217 1
a2217 1
        mdic = ((reg_addr) | (phy_addr << 5) | 
d2261 1
a2261 1
                (phy_addr << E1000_MDIC_PHY_SHIFT) | 
d2279 1
a2279 1
         * beginning of the MII instruction.  This is done by sending 32 
d2284 1
a2284 1
        /* Now combine the remaining required fields that will indicate a 
d2297 1
d2309 2
a2310 2
    uint32_t ctrl;
    uint32_t ctrl_ext;
d2322 1
d2325 1
d2334 1
d2338 1
d2341 13
d2380 3
d2396 1
d2406 1
a2406 1
    usec_delay(2);
d2412 2
a2413 1
    
d2426 4
d2434 3
a2436 1
    if(match) {
d2454 1
a2454 1
    
d2467 127
a2602 1
    int32_t ret_val = -E1000_ERR_PHY;
d2610 1
d2621 12
a2632 7
    do {
        if(em_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) break;
        if(em_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) break;
        if((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {
            DEBUGOUT("PHY info is only valid if link is up\n");
            return -E1000_ERR_CONFIG;
        }
d2634 4
a2637 33
        if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0)
            break;
        phy_info->extended_10bt_distance =
            (phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
            M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT;
        phy_info->polarity_correction =
            (phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>
            M88E1000_PSCR_POLARITY_REVERSAL_SHIFT;

        if(em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data) < 0)
            break;
        phy_info->cable_polarity = (phy_data & M88E1000_PSSR_REV_POLARITY) >>
            M88E1000_PSSR_REV_POLARITY_SHIFT;
        phy_info->mdix_mode = (phy_data & M88E1000_PSSR_MDIX) >>
            M88E1000_PSSR_MDIX_SHIFT;
        if(phy_data & M88E1000_PSSR_1000MBS) {
            /* Cable Length Estimation and Local/Remote Receiver Informatoion
             * are only valid at 1000 Mbps
             */
            phy_info->cable_length = ((phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
                                      M88E1000_PSSR_CABLE_LENGTH_SHIFT);
            if(em_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data) < 0) 
                break;
            phy_info->local_rx = (phy_data & SR_1000T_LOCAL_RX_STATUS) >>
                SR_1000T_LOCAL_RX_STATUS_SHIFT;
            phy_info->remote_rx = (phy_data & SR_1000T_REMOTE_RX_STATUS) >>
                SR_1000T_REMOTE_RX_STATUS_SHIFT;
        }
        ret_val = 0;
    } while(0);

    if(ret_val < 0) DEBUGOUT("PHY Read Error\n");
    return ret_val;
d2653 103
d2767 1
a2767 1
     * wait 50 microseconds.
d2771 2
a2772 1
    usec_delay(50);
d2778 1
a2778 1
 * hw - Struct containing variables accessed by shared code 
d2785 2
a2786 2
    /* Lower the clock input to the EEPROM (by clearing the SK bit), and then 
     * wait 50 microseconds. 
d2790 2
a2791 1
    usec_delay(50);
d2806 1
d2812 1
a2812 1
     * In order to do this, "data" must be broken down into bits. 
d2816 5
a2820 1
    eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
d2833 1
d2835 1
a2835 1
        usec_delay(50);
d2855 1
a2855 1
em_shift_in_ee_bits(struct em_hw *hw)
d2861 5
a2865 5
    /* In order to read a register from the EEPROM, we need to shift 16 bits 
     * in from the EEPROM. Bits are "shifted in" by raising the clock input to
     * the EEPROM (setting the SK bit), and then reading the value of the "DO"
     * bit.  During this "shifting in" process the "DI" bit should always be 
     * clear..
d2873 1
a2873 1
    for(i = 0; i < 16; i++) {
d2894 1
a2894 1
 * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This 
d2897 54
d2952 1
a2952 1
em_setup_eeprom(struct em_hw *hw)
d2954 1
d2959 17
a2975 3
    /* Clear SK and DI */
    eecd &= ~(E1000_EECD_SK | E1000_EECD_DI);
    E1000_WRITE_REG(hw, EECD, eecd);
d2977 16
a2992 3
    /* Set CS */
    eecd |= E1000_EECD_CS;
    E1000_WRITE_REG(hw, EECD, eecd);
d2996 2
a2997 2
 * Returns EEPROM to a "standby" state
 * 
d3001 1
a3001 1
em_standby_eeprom(struct em_hw *hw)
d3005 2
d3009 14
a3022 4
    /* Deselct EEPROM */
    eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
    E1000_WRITE_REG(hw, EECD, eecd);
    usec_delay(50);
d3024 5
a3028 4
    /* Clock high */
    eecd |= E1000_EECD_SK;
    E1000_WRITE_REG(hw, EECD, eecd);
    usec_delay(50);
d3030 6
a3035 4
    /* Select EEPROM */
    eecd |= E1000_EECD_CS;
    E1000_WRITE_REG(hw, EECD, eecd);
    usec_delay(50);
d3037 5
a3041 4
    /* Clock low */
    eecd &= ~E1000_EECD_SK;
    E1000_WRITE_REG(hw, EECD, eecd);
    usec_delay(50);
d3045 1
a3045 1
 * Raises then lowers the EEPROM's clock pin
d3049 2
a3050 2
static void
em_clock_eeprom(struct em_hw *hw)
d3052 2
a3053 1
    uint32_t eecd;
d3055 1
a3055 1
    eecd = E1000_READ_REG(hw, EECD);
d3057 12
a3068 20
    /* Rising edge of clock */
    eecd |= E1000_EECD_SK;
    E1000_WRITE_REG(hw, EECD, eecd);
    usec_delay(50);

    /* Falling edge of clock */
    eecd &= ~E1000_EECD_SK;
    E1000_WRITE_REG(hw, EECD, eecd);
    usec_delay(50);
}

/******************************************************************************
 * Terminates a command by lowering the EEPROM's chip select pin
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static void
em_cleanup_eeprom(struct em_hw *hw)
{
    uint32_t eecd;
d3070 2
a3071 1
    eecd = E1000_READ_REG(hw, EECD);
d3073 1
a3073 1
    eecd &= ~(E1000_EECD_CS | E1000_EECD_DI);
d3075 7
a3081 1
    E1000_WRITE_REG(hw, EECD, eecd);
d3083 1
a3083 1
    em_clock_eeprom(hw);
d3091 2
a3092 1
 * data - word read from the EEPROM 
d3097 1
d3100 1
a3100 1
    uint32_t eecd;
a3101 1
    boolean_t large_eeprom = FALSE;
d3105 7
a3111 18
    /* Request EEPROM Access */
    if(hw->mac_type > em_82544) {
        eecd = E1000_READ_REG(hw, EECD);
        if(eecd & E1000_EECD_SIZE) large_eeprom = TRUE;
        eecd |= E1000_EECD_REQ;
        E1000_WRITE_REG(hw, EECD, eecd);
        eecd = E1000_READ_REG(hw, EECD);
        while((!(eecd & E1000_EECD_GNT)) && (i < 100)) {
            i++;
            usec_delay(5);
            eecd = E1000_READ_REG(hw, EECD);
        }
        if(!(eecd & E1000_EECD_GNT)) {
            eecd &= ~E1000_EECD_REQ;
            E1000_WRITE_REG(hw, EECD, eecd);
            DEBUGOUT("Could not acquire EEPROM grant\n");
            return -E1000_ERR_EEPROM;
        }
d3114 3
a3116 2
    /*  Prepare the EEPROM for reading  */
    em_setup_eeprom(hw);
d3118 2
a3119 9
    /*  Send the READ command (opcode + addr)  */
    em_shift_out_ee_bits(hw, EEPROM_READ_OPCODE, 3);
    if(large_eeprom) {
        /* If we have a 256 word EEPROM, there are 8 address bits */
        em_shift_out_ee_bits(hw, offset, 8);
    } else {
        /* If we have a 64 word EEPROM, there are 6 address bits */
        em_shift_out_ee_bits(hw, offset, 6);
    }
d3121 1
a3121 2
    /* Read the data */
    *data = em_shift_in_ee_bits(hw);
d3123 1
a3123 2
    /* End this read operation */
    em_standby_eeprom(hw);
d3125 25
a3149 5
    /* Stop requesting EEPROM access */
    if(hw->mac_type > em_82544) {
        eecd = E1000_READ_REG(hw, EECD);
        eecd &= ~E1000_EECD_REQ;
        E1000_WRITE_REG(hw, EECD, eecd);
d3152 3
d3160 1
a3160 1
 * 
d3176 1
a3176 1
        if(em_read_eeprom(hw, i, &eeprom_data) < 0) {
d3186 1
a3186 1
        DEBUGOUT("EEPROM Checksum Invalid\n");    
d3208 1
a3208 1
        if(em_read_eeprom(hw, i, &eeprom_data) < 0) {
d3215 1
a3215 1
    if(em_write_eeprom(hw, EEPROM_CHECKSUM_REG, checksum) < 0) {
d3223 1
a3223 1
 * Writes a 16 bit word to a given offset in the EEPROM.
d3227 2
a3228 1
 * data - 16 bit word to be writen to the EEPROM
d3230 1
a3230 1
 * If em_update_eeprom_checksum is not called after this function, the 
d3236 2
a3237 1
                   uint16_t data)
d3239 1
a3239 2
    uint32_t eecd;
    uint32_t i = 0;
a3240 1
    boolean_t large_eeprom = FALSE;
d3244 7
a3250 18
    /* Request EEPROM Access */
    if(hw->mac_type > em_82544) {
        eecd = E1000_READ_REG(hw, EECD);
        if(eecd & E1000_EECD_SIZE) large_eeprom = TRUE;
        eecd |= E1000_EECD_REQ;
        E1000_WRITE_REG(hw, EECD, eecd);
        eecd = E1000_READ_REG(hw, EECD);
        while((!(eecd & E1000_EECD_GNT)) && (i < 100)) {
            i++;
            usec_delay(5);
            eecd = E1000_READ_REG(hw, EECD);
        }
        if(!(eecd & E1000_EECD_GNT)) {
            eecd &= ~E1000_EECD_REQ;
            E1000_WRITE_REG(hw, EECD, eecd);
            DEBUGOUT("Could not acquire EEPROM grant\n");
            return -E1000_ERR_EEPROM;
        }
d3254 2
a3255 1
    em_setup_eeprom(hw);
d3257 2
a3258 7
    /* Send the 9-bit (or 11-bit on large EEPROM) EWEN (write enable) command
     * to the EEPROM (5-bit opcode plus 4/6-bit dummy). This puts the EEPROM
     * into write/erase mode. 
     */
    em_shift_out_ee_bits(hw, EEPROM_EWEN_OPCODE, 5);
    if(large_eeprom) 
        em_shift_out_ee_bits(hw, 0, 6);
d3260 70
a3329 1
        em_shift_out_ee_bits(hw, 0, 4);
d3331 2
a3332 2
    /* Prepare the EEPROM */
    em_standby_eeprom(hw);
d3334 19
a3352 8
    /* Send the Write command (3-bit opcode + addr) */
    em_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE, 3);
    if(large_eeprom) 
        /* If we have a 256 word EEPROM, there are 8 address bits */
        em_shift_out_ee_bits(hw, offset, 8);
    else
        /* If we have a 64 word EEPROM, there are 6 address bits */
        em_shift_out_ee_bits(hw, offset, 6);
d3354 1
a3354 2
    /* Send the data */
    em_shift_out_ee_bits(hw, data, 16);
d3356 5
a3360 2
    /* Toggle the CS line.  This in effect tells to EEPROM to actually execute 
     * the command in question.
d3362 6
d3370 10
a3379 13
    /* Now read DO repeatedly until is high (equal to '1').  The EEEPROM will
     * signal that the command has been completed by raising the DO signal.
     * If DO does not go high in 10 milliseconds, then error out.
     */
    for(i = 0; i < 200; i++) {
        eecd = E1000_READ_REG(hw, EECD);
        if(eecd & E1000_EECD_DO) break;
        usec_delay(50);
    }
    if(i == 200) {
        DEBUGOUT("EEPROM Write did not complete\n");
        status = -E1000_ERR_EEPROM;
    }
d3381 4
a3384 2
    /* Recover from write */
    em_standby_eeprom(hw);
d3386 13
a3398 9
    /* Send the 9-bit (or 11-bit on large EEPROM) EWDS (write disable) command
     * to the EEPROM (5-bit opcode plus 4/6-bit dummy). This takes the EEPROM
     * out of write/erase mode.
     */
    em_shift_out_ee_bits(hw, EEPROM_EWDS_OPCODE, 5);
    if(large_eeprom) 
        em_shift_out_ee_bits(hw, 0, 6);
    else
        em_shift_out_ee_bits(hw, 0, 4);
d3400 2
a3401 2
    /* Done with writing */
    em_cleanup_eeprom(hw);
d3403 1
a3403 5
    /* Stop requesting EEPROM access */
    if(hw->mac_type > em_82544) {
        eecd = E1000_READ_REG(hw, EECD);
        eecd &= ~E1000_EECD_REQ;
        E1000_WRITE_REG(hw, EECD, eecd);
d3406 12
a3417 1
    return status;
d3436 1
a3436 1
    if(em_read_eeprom(hw, offset, &eeprom_data) < 0) {
d3444 1
a3444 1
    if(em_read_eeprom(hw, ++offset, &eeprom_data) < 0) {
d3470 1
a3470 1
        if(em_read_eeprom(hw, offset, &eeprom_data) < 0) {
d3492 1
a3492 1
 * hw - Struct containing variables accessed by shared code 
d3537 1
a3537 1
 * for the first 15 multicast addresses, and hashes the rest into the 
d3586 1
a3586 1
         * else put it in the MTA            
d3604 1
a3604 1
 * mc_addr - the multicast address to hash 
d3613 1
a3613 1
     * determined by the mc_filter_type setting.  
d3656 2
a3657 2
    /* The MTA is a register array of 128 32-bit registers.  
     * It is treated like an array of 4096 bits.  We want to set 
d3660 2
a3661 2
     * back the new value.  The register is determined by the 
     * upper 7 bits of the hash value and the bit within that 
d3699 1
a3699 1
     * from network order (big endian) to little endian              
d3757 1
a3757 1
        
d3759 1
a3759 1
    
d3764 1
a3764 1
    
d3769 2
a3770 2
        
    if(em_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, &eeprom_data) < 0) {
d3774 1
a3774 1
    if((eeprom_data== ID_LED_RESERVED_0000) || 
d3825 1
a3825 1
 
d3827 1
a3827 1
   
d3845 1
a3845 1
                    E1000_LEDCTL_LED0_BLINK | 
d3850 3
d3857 4
d3890 3
d3899 4
d3912 1
a3912 1
    
d3947 3
d3954 4
d4001 3
d4008 4
d4022 1
a4022 1
 * Clears all hardware statistics counters. 
d4141 1
a4141 1
        if((hw->collision_delta * hw->ifs_ratio) > 
d4154 1
a4154 1
            if((hw->in_ifs_mode == TRUE) && 
d4168 1
a4168 1
 * 
d4196 2
a4197 2
     * Received Count) was one before the addition, 
     * AND it is zero after, then we lost the carry out, 
d4199 1
a4199 1
     * This could be simplified if all environments supported 
d4205 1
a4205 1
     * since the test for a multicast frame will test positive on 
d4266 5
a4270 1
    if(hw->bus_type == em_bus_type_pci) {
d4328 218
@


1.1.8.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*******************************************************************************
d3 2
a4 28
  Copyright (c) 2001-2003, Intel Corporation 
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met:
  
   1. Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
  
   2. Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
  
   3. Neither the name of the Intel Corporation nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
d6 27
a32 1
*******************************************************************************/
d34 3
a36 2
/* $FreeBSD: if_em_hw.c,v 1.12 2003/11/14 18:02:24 pdeuskar Exp $ */
/* $OpenBSD$ */
d40 1
a40 1
 
d82 1
a82 2
static int32_t em_set_phy_type(struct em_hw *hw);
static void em_phy_init_script(struct em_hw *hw);
a83 2
static int32_t em_setup_fiber_serdes_link(struct em_hw *hw);
static int32_t em_adjust_serdes_amplitude(struct em_hw *hw);
d86 1
d89 1
a89 2
static void em_shift_out_mdi_bits(struct em_hw *hw, uint32_t data,
                                     uint16_t count);
a91 6
static int32_t em_write_eeprom_spi(struct em_hw *hw, uint16_t offset,
                                      uint16_t words, uint16_t *data);
static int32_t em_write_eeprom_microwire(struct em_hw *hw,
                                            uint16_t offset, uint16_t words,
                                            uint16_t *data);
static int32_t em_spi_eeprom_ready(struct em_hw *hw);
d94 3
a96 9
static void em_shift_out_ee_bits(struct em_hw *hw, uint16_t data,
                                    uint16_t count);
static int32_t em_write_phy_reg_ex(struct em_hw *hw, uint32_t reg_addr,
                                      uint16_t phy_data);
static int32_t em_read_phy_reg_ex(struct em_hw *hw,uint32_t reg_addr,
                                     uint16_t *phy_data);
static uint16_t em_shift_in_ee_bits(struct em_hw *hw, uint16_t count);
static int32_t em_acquire_eeprom(struct em_hw *hw);
static void em_release_eeprom(struct em_hw *hw);
a98 14
static int32_t em_set_vco_speed(struct em_hw *hw);

/* IGP cable length table */
static const
uint16_t em_igp_cable_length_table[IGP01E1000_AGC_LENGTH_TABLE_SIZE] =
    { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 10, 10, 10, 10, 10, 10, 10, 20, 20, 20, 20, 20, 25, 25, 25,
      25, 25, 25, 25, 30, 30, 30, 30, 40, 40, 40, 40, 40, 40, 40, 40,
      40, 50, 50, 50, 50, 50, 50, 50, 60, 60, 60, 60, 60, 60, 60, 60,
      60, 70, 70, 70, 70, 70, 70, 80, 80, 80, 80, 80, 80, 90, 90, 90,
      90, 90, 90, 90, 90, 90, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
      100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
      110, 110, 110, 110, 110, 110, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120};

d101 1
a101 101
 * Set the phy type member in the hw struct.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
em_set_phy_type(struct em_hw *hw)
{
    DEBUGFUNC("em_set_phy_type");

    switch(hw->phy_id) {
    case M88E1000_E_PHY_ID:
    case M88E1000_I_PHY_ID:
    case M88E1011_I_PHY_ID:
        hw->phy_type = em_phy_m88;
        break;
    case IGP01E1000_I_PHY_ID:
        hw->phy_type = em_phy_igp;
        break;
    default:
        /* Should never have loaded on this device */
        hw->phy_type = em_phy_undefined;
        return -E1000_ERR_PHY_TYPE;
    }

    return E1000_SUCCESS;
}

/******************************************************************************
 * IGP phy init script - initializes the GbE PHY
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static void
em_phy_init_script(struct em_hw *hw)
{
    DEBUGFUNC("em_phy_init_script");

    if(hw->phy_init_script) {
        msec_delay(20);

        em_write_phy_reg(hw,0x0000,0x0140);

        msec_delay(5);

        if(hw->mac_type == em_82541 || hw->mac_type == em_82547) {
            em_write_phy_reg(hw, 0x1F95, 0x0001);

            em_write_phy_reg(hw, 0x1F71, 0xBD21);

            em_write_phy_reg(hw, 0x1F79, 0x0018);

            em_write_phy_reg(hw, 0x1F30, 0x1600);

            em_write_phy_reg(hw, 0x1F31, 0x0014);

            em_write_phy_reg(hw, 0x1F32, 0x161C);

            em_write_phy_reg(hw, 0x1F94, 0x0003);

            em_write_phy_reg(hw, 0x1F96, 0x003F);

            em_write_phy_reg(hw, 0x2010, 0x0008);
        } else {
            em_write_phy_reg(hw, 0x1F73, 0x0099);
        }

        em_write_phy_reg(hw, 0x0000, 0x3300);


        if(hw->mac_type == em_82547) {
            uint16_t fused, fine, coarse;

            /* Move to analog registers page */
            em_read_phy_reg(hw, IGP01E1000_ANALOG_SPARE_FUSE_STATUS, &fused);

            if(!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
                em_read_phy_reg(hw, IGP01E1000_ANALOG_FUSE_STATUS, &fused);

                fine = fused & IGP01E1000_ANALOG_FUSE_FINE_MASK;
                coarse = fused & IGP01E1000_ANALOG_FUSE_COARSE_MASK;

                if(coarse > IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {
                    coarse -= IGP01E1000_ANALOG_FUSE_COARSE_10;
                    fine -= IGP01E1000_ANALOG_FUSE_FINE_1;
                } else if(coarse == IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
                    fine -= IGP01E1000_ANALOG_FUSE_FINE_10;

                fused = (fused & IGP01E1000_ANALOG_FUSE_POLY_MASK) |
                        (fine & IGP01E1000_ANALOG_FUSE_FINE_MASK) |
                        (coarse & IGP01E1000_ANALOG_FUSE_COARSE_MASK);

                em_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_CONTROL, fused);
                em_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_BYPASS,
                                    IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL);
            }
        }
    }
}

/******************************************************************************
 * Set the mac type member in the hw struct.
a104 83
int32_t
em_set_mac_type(struct em_hw *hw)
{
    DEBUGFUNC("em_set_mac_type");

    switch (hw->device_id) {
    case E1000_DEV_ID_82542:
        switch (hw->revision_id) {
        case E1000_82542_2_0_REV_ID:
            hw->mac_type = em_82542_rev2_0;
            break;
        case E1000_82542_2_1_REV_ID:
            hw->mac_type = em_82542_rev2_1;
            break;
        default:
            /* Invalid 82542 revision ID */
            return -E1000_ERR_MAC_TYPE;
        }
        break;
    case E1000_DEV_ID_82543GC_FIBER:
    case E1000_DEV_ID_82543GC_COPPER:
        hw->mac_type = em_82543;
        break;
    case E1000_DEV_ID_82544EI_COPPER:
    case E1000_DEV_ID_82544EI_FIBER:
    case E1000_DEV_ID_82544GC_COPPER:
    case E1000_DEV_ID_82544GC_LOM:
        hw->mac_type = em_82544;
        break;
    case E1000_DEV_ID_82540EM:
    case E1000_DEV_ID_82540EM_LOM:
    case E1000_DEV_ID_82540EP:
    case E1000_DEV_ID_82540EP_LOM:
    case E1000_DEV_ID_82540EP_LP:
        hw->mac_type = em_82540;
        break;
    case E1000_DEV_ID_82545EM_COPPER:
    case E1000_DEV_ID_82545EM_FIBER:
        hw->mac_type = em_82545;
        break;
    case E1000_DEV_ID_82545GM_COPPER:
    case E1000_DEV_ID_82545GM_FIBER:
    case E1000_DEV_ID_82545GM_SERDES:
        hw->mac_type = em_82545_rev_3;
        break;
    case E1000_DEV_ID_82546EB_COPPER:
    case E1000_DEV_ID_82546EB_FIBER:
    case E1000_DEV_ID_82546EB_QUAD_COPPER:
        hw->mac_type = em_82546;
        break;
    case E1000_DEV_ID_82546GB_COPPER:
    case E1000_DEV_ID_82546GB_FIBER:
    case E1000_DEV_ID_82546GB_SERDES:
        hw->mac_type = em_82546_rev_3;
        break;
    case E1000_DEV_ID_82541EI:
    case E1000_DEV_ID_82541EI_MOBILE:
        hw->mac_type = em_82541;
        break;
    case E1000_DEV_ID_82541ER:
    case E1000_DEV_ID_82541GI:
    case E1000_DEV_ID_82541GI_MOBILE:
        hw->mac_type = em_82541_rev_2;
        break;
    case E1000_DEV_ID_82547EI:
        hw->mac_type = em_82547;
        break;
    case E1000_DEV_ID_82547GI:
        hw->mac_type = em_82547_rev_2;
        break;
    default:
        /* Should never have loaded on this device */
        return -E1000_ERR_MAC_TYPE;
    }

    return E1000_SUCCESS;
}

/*****************************************************************************
 * Set media type and TBI compatibility.
 *
 * hw - Struct containing variables accessed by shared code
 * **************************************************************************/
a105 39
em_set_media_type(struct em_hw *hw)
{
    uint32_t status;

    DEBUGFUNC("em_set_media_type");

    if(hw->mac_type != em_82543) {
        /* tbi_compatibility is only valid on 82543 */
        hw->tbi_compatibility_en = FALSE;
    }

    switch (hw->device_id) {
    case E1000_DEV_ID_82545GM_SERDES:
    case E1000_DEV_ID_82546GB_SERDES:
        hw->media_type = em_media_type_internal_serdes;
        break;
    default:
        if(hw->mac_type >= em_82543) {
            status = E1000_READ_REG(hw, STATUS);
            if(status & E1000_STATUS_TBIMODE) {
                hw->media_type = em_media_type_fiber;
                /* tbi_compatibility not valid on fiber */
                hw->tbi_compatibility_en = FALSE;
            } else {
                hw->media_type = em_media_type_copper;
            }
        } else {
            /* This is an 82542 (fiber only) */
            hw->media_type = em_media_type_fiber;
        }
    }
}

/******************************************************************************
 * Reset the transmit and receive units; mask and clear all interrupts.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
int32_t
d112 1
a112 1
    uint32_t led_ctrl;
d115 1
a115 1

d118 5
a122 2
        DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
        em_pci_clear_mwi(hw);
a134 1
    E1000_WRITE_FLUSH(hw);
d141 1
a141 1
     */
a143 8
    ctrl = E1000_READ_REG(hw, CTRL);

    /* Must reset the PHY before resetting the MAC */
    if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
        E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
        msec_delay(5);
    }

d150 1
d152 4
a155 20
    switch(hw->mac_type) {
        case em_82544:
        case em_82540:
        case em_82545:
        case em_82546:
        case em_82541:
        case em_82541_rev_2:
            /* These controllers can't ack the 64-bit write when issuing the
             * reset, so use IO-mapping as a workaround to issue the reset */
            E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
            break;
        case em_82545_rev_3:
        case em_82546_rev_3:
            /* Reset is performed on a shadow of the control register */
            E1000_WRITE_REG(hw, CTRL_DUP, (ctrl | E1000_CTRL_RST));
            break;
        default:
            E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
            break;
    }
d157 13
a169 33
    /* After MAC reset, force reload of EEPROM to restore power-on settings to
     * device.  Later controllers reload the EEPROM automatically, so just wait
     * for reload to complete.
     */
    switch(hw->mac_type) {
        case em_82542_rev2_0:
        case em_82542_rev2_1:
        case em_82543:
        case em_82544:
            /* Wait for reset to complete */
            usec_delay(10);
            ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
            ctrl_ext |= E1000_CTRL_EXT_EE_RST;
            E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
            E1000_WRITE_FLUSH(hw);
            /* Wait for EEPROM reload */
            msec_delay(2);
            break;
        case em_82541:
        case em_82541_rev_2:
        case em_82547:
        case em_82547_rev_2:
            /* Wait for EEPROM reload */
            msec_delay(20);
            break;
        default:
            /* Wait for EEPROM reload (it happens automatically) */
            msec_delay(5);
            break;
    }

    /* Disable HW ARPs on ASF enabled adapters */
    if(hw->mac_type >= em_82540) {
d174 1
a174 11

    if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
        em_phy_init_script(hw);

        /* Configure activity LED after PHY reset */
        led_ctrl = E1000_READ_REG(hw, LEDCTL);
        led_ctrl &= IGP_ACTIVITY_LED_MASK;
        led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
        E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
    }

d185 1
a185 1
            em_pci_set_mwi(hw);
a186 2

    return E1000_SUCCESS;
d193 2
a194 2
 *
 * Assumes that the controller has previously been reset and is in a
d203 1
a203 1
    uint32_t ctrl;
d206 1
d215 2
a216 1
    if((ret_val = em_id_led_init(hw))) {
d220 6
d227 13
a239 2
    /* Set the media type and TBI compatibility */
    em_set_media_type(hw);
d249 5
a253 2
        DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
        em_pci_clear_mwi(hw);
a254 1
        E1000_WRITE_FLUSH(hw);
a265 1
        E1000_WRITE_FLUSH(hw);
d268 1
a268 1
            em_pci_set_mwi(hw);
d285 12
a296 22
    switch(hw->mac_type) {
    case em_82545_rev_3:
    case em_82546_rev_3:
        break;
    default:
        /* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
        if(hw->bus_type == em_bus_type_pcix) {
            em_read_pci_cfg(hw, PCIX_COMMAND_REGISTER, &pcix_cmd_word);
            em_read_pci_cfg(hw, PCIX_STATUS_REGISTER_HI,
                &pcix_stat_hi_word);
            cmd_mmrbc = (pcix_cmd_word & PCIX_COMMAND_MMRBC_MASK) >>
                PCIX_COMMAND_MMRBC_SHIFT;
            stat_mmrbc = (pcix_stat_hi_word & PCIX_STATUS_HI_MMRBC_MASK) >>
                PCIX_STATUS_HI_MMRBC_SHIFT;
            if(stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
                stat_mmrbc = PCIX_STATUS_HI_MMRBC_2K;
            if(cmd_mmrbc > stat_mmrbc) {
                pcix_cmd_word &= ~PCIX_COMMAND_MMRBC_MASK;
                pcix_cmd_word |= stat_mmrbc << PCIX_COMMAND_MMRBC_SHIFT;
                em_write_pci_cfg(hw, PCIX_COMMAND_REGISTER,
                    &pcix_cmd_word);
            }
a297 1
        break;
a302 7
    /* Set the transmit descriptor write-back policy */
    if(hw->mac_type > em_82544) {
        ctrl = E1000_READ_REG(hw, TXDCTL);
        ctrl = (ctrl & ~E1000_TXDCTL_WTHRESH) | E1000_TXDCTL_FULL_TX_DESC_WB;
        E1000_WRITE_REG(hw, TXDCTL, ctrl);
    }

a313 40
 * Adjust SERDES output amplitude based on EEPROM setting.
 *
 * hw - Struct containing variables accessed by shared code.
 *****************************************************************************/
static int32_t
em_adjust_serdes_amplitude(struct em_hw *hw)
{
    uint16_t eeprom_data;
    int32_t  ret_val;

    DEBUGFUNC("em_adjust_serdes_amplitude");

    if(hw->media_type != em_media_type_internal_serdes)
        return E1000_SUCCESS;

    switch(hw->mac_type) {
    case em_82545_rev_3:
    case em_82546_rev_3:
        break;
    default:
        return E1000_SUCCESS;
    }

    if ((ret_val = em_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1,
                                     &eeprom_data))) {
        return ret_val;
    }

    if(eeprom_data != EEPROM_RESERVED_WORD) {
        /* Adjust SERDES output amplitude only. */
        eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK; 
        if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL,
                                          eeprom_data)))
            return ret_val;
    }

    return E1000_SUCCESS;
}

/******************************************************************************
d315 1
a315 1
 *
d317 1
a317 1
 *
d321 1
a321 1
 * established. Assumes the hardware has previously been reset and the
d341 1
a341 1
    if(em_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG, 1, &eeprom_data) < 0) {
d349 1
a349 1
        else if((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) ==
d378 1
a378 1
        ctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) <<
d384 3
a386 3
    ret_val = (hw->media_type == em_media_type_copper) ?
              em_setup_copper_link(hw) :
              em_setup_fiber_serdes_link(hw);
d404 1
a404 1
     * registers will be set to 0.
d425 1
a425 1
 * Sets up link for a fiber based or serdes based adapter
d428 1
d434 2
a435 2
static int32_t
em_setup_fiber_serdes_link(struct em_hw *hw)
d441 1
a441 1
    uint32_t signal = 0;
d444 1
a444 1
    DEBUGFUNC("em_setup_fiber_serdes_link");
d446 3
a448 5
    /* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be
     * set when the optics detect a signal. On older adapters, it will be
     * cleared when there is a signal.  This applies to fiber media only.
     * If we're on serdes media, adjust the output amplitude to value set in
     * the EEPROM.
d451 3
a453 6
    if(hw->media_type == em_media_type_fiber)
        signal = (hw->mac_type > em_82544) ? E1000_CTRL_SWDPIN1 : 0;

    if((ret_val = em_adjust_serdes_amplitude(hw)))
        return ret_val;

d456 1
a456 5

    /* Adjust VCO speed to improve BER performance */
    if((ret_val = em_set_vco_speed(hw)))
        return ret_val;

d463 1
a463 1
     * auto-negotiation is disabled, then software will have to manually
d468 1
a468 1
     *      1:  Rx flow control is enabled (we can receive pause frames, but
d480 2
a481 2
        /* RX Flow control is enabled and TX Flow control is disabled by a
         * software over-ride. Since there really isn't a way to advertise
d489 1
a489 1
        /* TX Flow control is enabled, and RX Flow control is disabled, by a
a513 1
    E1000_WRITE_FLUSH(hw);
d519 2
a520 2
     * indication in the Device Status Register.  Time-out if a link isn't
     * seen in 500 milliseconds seconds (Auto-negotiation should complete in
a521 1
     * For internal serdes, we just assume a signal is present, then poll.
d523 1
a523 2
    if(hw->media_type == em_media_type_internal_serdes ||
       (E1000_READ_REG(hw, CTRL) & E1000_CTRL_SWDPIN1) == signal) {
d531 5
d538 2
a539 6
            /* AutoNeg failed to achieve a link, so we'll call
             * em_check_for_link. This routine will force the link up if
             * we detect a signal. This will allow us to communicate with
             * non-autonegotiating link partners.
             */
            if((ret_val = em_check_for_link(hw))) {
d551 1
a551 1
    return E1000_SUCCESS;
d558 1
d560 1
a560 1
static int32_t
a563 1
    uint32_t led_ctrl;
d586 2
a587 1
    if((ret_val = em_detect_gig_phy(hw))) {
d593 31
a623 4
    if(hw->mac_type <= em_82543 ||
       hw->mac_type == em_82541 || hw->mac_type == em_82547 ||
       hw->mac_type == em_82541_rev_2 || hw->mac_type == em_82547_rev_2)
        hw->phy_reset_disable = FALSE;
d625 13
a637 2
    if(!hw->phy_reset_disable) {
        if (hw->phy_type == em_phy_igp) {
d639 17
a655 4
            if((ret_val = em_phy_reset(hw))) {
                DEBUGOUT("Error Resetting the PHY\n");
                return ret_val;
            }
d657 15
a671 2
            /* Wait 10ms for MAC to configure PHY from eeprom settings */
            msec_delay(15);
d673 11
a683 11
            /* Configure activity LED after PHY reset */
            led_ctrl = E1000_READ_REG(hw, LEDCTL);
            led_ctrl &= IGP_ACTIVITY_LED_MASK;
            led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
            E1000_WRITE_REG(hw, LEDCTL, led_ctrl);

            /* disable lplu d3 during driver init */
            if((ret_val = em_set_d3_lplu_state(hw, FALSE))) {
                DEBUGOUT("Error Disabling LPLU D3\n");
                return ret_val;
            }
d685 5
a689 4
            /* Configure mdi-mdix settings */
            if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
                                             &phy_data)))
                return ret_val;
d691 7
a697 6
            if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
                hw->dsp_config_state = em_dsp_config_disabled;
                /* Force MDI for IGP B-0 PHY */
                phy_data &= ~(IGP01E1000_PSCR_AUTO_MDIX |
                              IGP01E1000_PSCR_FORCE_MDI_MDIX);
                hw->mdix = 1;
d699 12
a710 3
            } else {
                hw->dsp_config_state = em_dsp_config_enabled;
                phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
d712 8
a719 150
                switch (hw->mdix) {
                case 1:
                    phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
                    break;
                case 2:
                    phy_data |= IGP01E1000_PSCR_FORCE_MDI_MDIX;
                    break;
                case 0:
                default:
                    phy_data |= IGP01E1000_PSCR_AUTO_MDIX;
                    break;
                }
            }
            if((ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
                                              phy_data)))
                return ret_val;

            /* set auto-master slave resolution settings */
            if(hw->autoneg) {
                em_ms_type phy_ms_setting = hw->master_slave;

                if(hw->ffe_config_state == em_ffe_config_active)
                    hw->ffe_config_state = em_ffe_config_enabled;

                if(hw->dsp_config_state == em_dsp_config_activated)
                    hw->dsp_config_state = em_dsp_config_enabled;

                /* when autonegotiation advertisment is only 1000Mbps then we
                 * should disable SmartSpeed and enable Auto MasterSlave
                 * resolution as hardware default. */
                if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
                    /* Disable SmartSpeed */
                    if((ret_val = em_read_phy_reg(hw,
                                                    IGP01E1000_PHY_PORT_CONFIG,
                                                    &phy_data)))
                        return ret_val;
                    phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
                    if((ret_val = em_write_phy_reg(hw,
                                                     IGP01E1000_PHY_PORT_CONFIG,
                                                     phy_data)))
                        return ret_val;
                    /* Set auto Master/Slave resolution process */
                    if((ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL,
                                                     &phy_data)))
                        return ret_val;
                    phy_data &= ~CR_1000T_MS_ENABLE;
                    if((ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL,
                                                      phy_data)))
                        return ret_val;
                }

                if((ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL,
                                                 &phy_data)))
                    return ret_val;

                /* load defaults for future use */
                hw->original_master_slave = (phy_data & CR_1000T_MS_ENABLE) ?
                                            ((phy_data & CR_1000T_MS_VALUE) ?
                                             em_ms_force_master :
                                             em_ms_force_slave) :
                                             em_ms_auto;

                switch (phy_ms_setting) {
                case em_ms_force_master:
                    phy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);
                    break;
                case em_ms_force_slave:
                    phy_data |= CR_1000T_MS_ENABLE;
                    phy_data &= ~(CR_1000T_MS_VALUE);
                    break;
                case em_ms_auto:
                    phy_data &= ~CR_1000T_MS_ENABLE;
                default:
                    break;
                }
                if((ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL,
                                                  phy_data)))
                    return ret_val;
            }
        } else {
            /* Enable CRS on TX. This must be set for half-duplex operation. */
            if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                             &phy_data)))
                return ret_val;

            phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;

            /* Options:
             *   MDI/MDI-X = 0 (default)
             *   0 - Auto for all speeds
             *   1 - MDI mode
             *   2 - MDI-X mode
             *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
             */
            phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;

            switch (hw->mdix) {
            case 1:
                phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
                break;
            case 2:
                phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
                break;
            case 3:
                phy_data |= M88E1000_PSCR_AUTO_X_1000T;
                break;
            case 0:
            default:
                phy_data |= M88E1000_PSCR_AUTO_X_MODE;
                break;
            }

            /* Options:
             *   disable_polarity_correction = 0 (default)
             *       Automatic Correction for Reversed Cable Polarity
             *   0 - Disabled
             *   1 - Enabled
             */
            phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
            if(hw->disable_polarity_correction == 1)
                phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;
            if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                              phy_data)))
                return ret_val;

            /* Force TX_CLK in the Extended PHY Specific Control Register
             * to 25MHz clock.
             */
            if((ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
                                             &phy_data)))
                return ret_val;

            phy_data |= M88E1000_EPSCR_TX_CLK_25;

            if (hw->phy_revision < M88E1011_I_REV_4) {
                /* Configure Master and Slave downshift values */
                phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
                              M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
                phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
                             M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
                if((ret_val = em_write_phy_reg(hw,
                                                  M88E1000_EXT_PHY_SPEC_CTRL,
                                                  phy_data)))
                    return ret_val;
            }

            /* SW Reset the PHY so all changes take effect */
            if((ret_val = em_phy_reset(hw))) {
                DEBUGOUT("Error Resetting the PHY\n");
                return ret_val;
d722 8
a729 63

        /* Options:
         *   autoneg = 1 (default)
         *      PHY will advertise value(s) parsed from
         *      autoneg_advertised and fc
         *   autoneg = 0
         *      PHY will be set to 10H, 10F, 100H, or 100F
         *      depending on value parsed from forced_speed_duplex.
         */

        /* Is autoneg enabled?  This is enabled by default or by software
         * override.  If so, call em_phy_setup_autoneg routine to parse the
         * autoneg_advertised and fc options. If autoneg is NOT enabled, then
         * the user should have provided a speed/duplex override.  If so, then
         * call em_phy_force_speed_duplex to parse and set this up.
         */
        if(hw->autoneg) {
            /* Perform some bounds checking on the hw->autoneg_advertised
             * parameter.  If this variable is zero, then set it to the default.
             */
            hw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;

            /* If autoneg_advertised is zero, we assume it was not defaulted
             * by the calling code so we set to advertise full capability.
             */
            if(hw->autoneg_advertised == 0)
                hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;

            DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
            if((ret_val = em_phy_setup_autoneg(hw))) {
                DEBUGOUT("Error Setting up Auto-Negotiation\n");
                return ret_val;
            }
            DEBUGOUT("Restarting Auto-Neg\n");

            /* Restart auto-negotiation by setting the Auto Neg Enable bit and
             * the Auto Neg Restart bit in the PHY control register.
             */
            if((ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data)))
                return ret_val;

            phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
            if((ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data)))
                return ret_val;

            /* Does the user want to wait for Auto-Neg to complete here, or
             * check at a later time (for example, callback routine).
             */
            if(hw->wait_autoneg_complete) {
                if((ret_val = em_wait_autoneg(hw))) {
                    DEBUGOUT("Error while waiting for autoneg to complete\n");
                    return ret_val;
                }
            }
            hw->get_link_status = TRUE;
        } else {
            DEBUGOUT("Forcing speed and duplex\n");
            if((ret_val = em_phy_force_speed_duplex(hw))) {
                DEBUGOUT("Error Forcing Speed and Duplex\n");
                return ret_val;
            }
        }
    } /* !hw->phy_reset_disable */
d735 8
a742 5
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
            return ret_val;
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
            return ret_val;

d755 2
a756 1
                if((ret_val = em_config_mac_to_phy(hw))) {
d759 1
a759 1
                }
d761 2
a762 1
            if((ret_val = em_config_fc_after_link_up(hw))) {
d767 1
a767 9

            if(hw->phy_type == em_phy_igp) {
                if((ret_val = em_config_dsp_after_link_change(hw, TRUE))) {
                    DEBUGOUT("Error Configuring DSP after link up\n");
                    return ret_val;
                }
            }
            DEBUGOUT("Valid link established!!!\n");
            return E1000_SUCCESS;
d773 1
a773 1
    return E1000_SUCCESS;
a783 1
    int32_t ret_val;
d790 4
a793 3
    if((ret_val = em_read_phy_reg(hw, PHY_AUTONEG_ADV,
                                     &mii_autoneg_adv_reg)))
        return ret_val;
d796 4
a799 2
    if((ret_val = em_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg)))
        return ret_val;
d905 4
a908 3
    if((ret_val = em_write_phy_reg(hw, PHY_AUTONEG_ADV,
                                      mii_autoneg_adv_reg)))
        return ret_val;
d912 5
a916 4
    if((ret_val = em_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg)))
        return ret_val;

    return E1000_SUCCESS;
d952 4
a955 2
    if((ret_val = em_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg)))
        return ret_val;
d1000 21
a1020 31
    if (hw->phy_type == em_phy_m88) {
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                         &phy_data)))
            return ret_val;

        /* Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI
         * forced whenever speed are duplex are forced.
         */
        phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
        if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                          phy_data)))
            return ret_val;

        DEBUGOUT1("M88E1000 PSCR: %x \n", phy_data);

        /* Need to reset the PHY or these changes will be ignored */
        mii_ctrl_reg |= MII_CR_RESET;
    } else {
        /* Clear Auto-Crossover to force MDI manually.  IGP requires MDI
         * forced whenever speed or duplex are forced.
         */
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
                                         &phy_data)))
            return ret_val;

        phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
        phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;

        if((ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
                                          phy_data)))
            return ret_val;
a1021 5

    /* Write back the modified PHY MII control register. */
    if((ret_val = em_write_phy_reg(hw, PHY_CTRL, mii_ctrl_reg)))
        return ret_val;

d1041 8
a1048 6
            if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
                return ret_val;

            if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
                return ret_val;

d1054 3
a1056 1
            if((ret_val = em_phy_reset_dsp(hw))) {
d1068 8
a1075 5
            if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
                return ret_val;

            if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
                return ret_val;
d1078 26
a1103 27

    if (hw->phy_type == em_phy_m88) {
        /* Because we reset the PHY above, we need to re-force TX_CLK in the
         * Extended PHY Specific Control Register to 25MHz clock.  This value
         * defaults back to a 2.5MHz clock when the PHY is reset.
         */
        if((ret_val = em_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
                                         &phy_data)))
            return ret_val;

        phy_data |= M88E1000_EPSCR_TX_CLK_25;
        if((ret_val = em_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
                                          phy_data)))
            return ret_val;

        /* In addition, because of the s/w reset above, we need to enable CRS on
         * TX.  This must be set for both full and half duplex operation.
         */
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                         &phy_data)))
            return ret_val;

        phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
        if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
                                          phy_data)))
            return ret_val;

d1105 1
a1105 1
    return E1000_SUCCESS;
a1120 2
    DEBUGFUNC("em_config_collision_dist");

a1126 1
    E1000_WRITE_FLUSH(hw);
a1141 1
    int32_t ret_val;
d1156 6
a1161 4
    if (hw->phy_type == em_phy_igp) {
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
                                         &phy_data)))
            return ret_val;
d1163 1
a1163 2
        if(phy_data & IGP01E1000_PSSR_FULL_DUPLEX) ctrl |= E1000_CTRL_FD;
        else ctrl &= ~E1000_CTRL_FD;
d1165 7
a1171 29
        em_config_collision_dist(hw);

        /* Set up speed in the Device Control register depending on
         * negotiated values.
         */
        if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
           IGP01E1000_PSSR_SPEED_1000MBPS)
            ctrl |= E1000_CTRL_SPD_1000;
        else if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
                IGP01E1000_PSSR_SPEED_100MBPS)
            ctrl |= E1000_CTRL_SPD_100;
    } else {
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                         &phy_data)))
            return ret_val;

        if(phy_data & M88E1000_PSSR_DPLX) ctrl |= E1000_CTRL_FD;
        else ctrl &= ~E1000_CTRL_FD;

        em_config_collision_dist(hw);

        /* Set up speed in the Device Control register depending on
         * negotiated values.
         */
        if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
            ctrl |= E1000_CTRL_SPD_1000;
        else if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
            ctrl |= E1000_CTRL_SPD_100;
    }
d1174 1
a1174 1
    return E1000_SUCCESS;
d1179 1
a1179 1
 *
d1188 1
a1188 1
int32_t
d1241 1
a1241 1
    return E1000_SUCCESS;
d1246 1
a1246 1
 *
a1271 1
       ((hw->media_type == em_media_type_internal_serdes) && (hw->autoneg_failed)) ||
d1273 2
a1274 1
        if((ret_val = em_force_mac_fc(hw))) {
d1290 8
a1297 4
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
            return ret_val;
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
            return ret_val;
d1306 8
a1313 6
            if((ret_val = em_read_phy_reg(hw, PHY_AUTONEG_ADV,
                                             &mii_nway_adv_reg)))
                return ret_val;
            if((ret_val = em_read_phy_reg(hw, PHY_LP_ABILITY,
                                             &mii_nway_lp_ability_reg)))
                return ret_val;
d1415 2
a1416 3
            else if((hw->original_fc == em_fc_none ||
                     hw->original_fc == em_fc_tx_pause) ||
                    hw->fc_strict_ieee) {
d1428 1
a1428 4
            if((ret_val = em_get_speed_and_duplex(hw, &speed, &duplex))) {
                DEBUGOUT("Error getting link speed and duplex\n");
                return ret_val;
            }
d1436 2
a1437 1
            if((ret_val = em_force_mac_fc(hw))) {
d1440 1
a1440 1
            }
d1445 1
a1445 1
    return E1000_SUCCESS;
d1462 1
a1462 1
    uint32_t signal = 0;
d1468 4
a1471 4

    /* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be
     * set when the optics detect a signal. On older adapters, it will be
     * cleared when there is a signal.  This applies to fiber media only.
d1473 2
a1474 2
    if(hw->media_type == em_media_type_fiber)
        signal = (hw->mac_type > em_82544) ? E1000_CTRL_SWDPIN1 : 0;
d1492 8
a1499 4
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
            return ret_val;
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
            return ret_val;
a1502 4
            /* Check if there was DownShift, must be checked immediately after
             * link-up */
            em_check_downshift(hw);

a1504 1
            em_config_dsp_after_link_change(hw, FALSE);
a1512 3
        /* optimize the dsp settings for the igp phy */
        em_config_dsp_after_link_change(hw, TRUE);

d1524 2
a1525 1
            if((ret_val = em_config_mac_to_phy(hw))) {
d1531 1
a1531 1
        /* Configure Flow Control now that Auto-Neg has completed. First, we
d1535 2
a1536 1
        if((ret_val = em_config_fc_after_link_up(hw))) {
d1551 4
a1554 3
            if((ret_val = em_read_phy_reg(hw, PHY_LP_ABILITY,
                                             &lp_capability)))
                return ret_val;
d1560 1
a1560 1
                /* If our link partner advertises anything in addition to
d1592 1
a1592 3
    else if((((hw->media_type == em_media_type_fiber) &&
            ((ctrl & E1000_CTRL_SWDPIN1) == signal)) ||
            (hw->media_type == em_media_type_internal_serdes)) &&
d1594 1
d1611 2
a1612 1
        if((ret_val = em_config_fc_after_link_up(hw))) {
d1622 1
a1622 2
    else if(((hw->media_type == em_media_type_fiber) ||
             (hw->media_type == em_media_type_internal_serdes)) &&
d1629 1
a1629 1
    return E1000_SUCCESS;
d1639 1
a1639 1
int32_t
a1644 2
    int32_t ret_val;
    uint16_t phy_data;
a1672 21

    /* IGP01 PHY may advertise full duplex operation after speed downgrade even
     * if it is operating at half duplex.  Here we set the duplex settings to
     * match the duplex in the link partner's capabilities.
     */
    if(hw->phy_type == em_phy_igp && hw->speed_downgraded) {
        if((ret_val = em_read_phy_reg(hw, PHY_AUTONEG_EXP, &phy_data)))
            return ret_val;

        if(!(phy_data & NWAY_ER_LP_NWAY_CAPS))
            *duplex = HALF_DUPLEX;
        else {
            if((ret_val == em_read_phy_reg(hw, PHY_LP_ABILITY, &phy_data)))
                return ret_val;
            if((*speed == SPEED_100 && !(phy_data & NWAY_LPAR_100TX_FD_CAPS)) ||
               (*speed == SPEED_10 && !(phy_data & NWAY_LPAR_10T_FD_CAPS)))
                *duplex = HALF_DUPLEX;
        }
    }

    return E1000_SUCCESS;
a1682 1
    int32_t ret_val;
d1694 8
a1701 4
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
            return ret_val;
        if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
            return ret_val;
d1703 1
a1703 1
            return E1000_SUCCESS;
d1707 1
a1707 1
    return E1000_SUCCESS;
d1721 1
a1721 1
     * bit), and then delay 10 microseconds.
d1724 1
a1724 2
    E1000_WRITE_FLUSH(hw);
    usec_delay(10);
d1738 1
a1738 1
     * bit), and then delay 10 microseconds.
d1741 1
a1741 2
    E1000_WRITE_FLUSH(hw);
    usec_delay(10);
d1762 1
a1762 1
     * in the "data" parameter will be shifted out to the PHY one bit at a
a1782 1
        E1000_WRITE_FLUSH(hw);
d1784 1
a1784 1
        usec_delay(10);
d1791 3
d1801 1
a1801 1
* Bits are shifted in in MSB to LSB order.
d1816 1
a1816 1
     */
a1823 1
    E1000_WRITE_FLUSH(hw);
d1844 3
d1851 2
a1852 2
* Reads the value from a PHY register, if the value is on a specific non zero
* page, sets the page first.
a1860 22
    uint32_t ret_val;

    DEBUGFUNC("em_read_phy_reg");

    if(hw->phy_type == em_phy_igp &&
       (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
        if((ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
                                             (uint16_t)reg_addr)))
            return ret_val;
    }

    ret_val = em_read_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT & reg_addr,
                                    phy_data);

    return ret_val;
}

int32_t
em_read_phy_reg_ex(struct em_hw *hw,
                      uint32_t reg_addr,
                      uint16_t *phy_data)
{
d1865 1
a1865 1
    DEBUGFUNC("em_read_phy_reg_ex");
d1878 1
a1878 1
                (phy_addr << E1000_MDIC_PHY_SHIFT) |
d1885 1
a1885 1
            usec_delay(50);
d1916 1
a1916 1
        mdic = ((reg_addr) | (phy_addr << 5) |
d1927 1
a1927 1
    return E1000_SUCCESS;
a1941 22
    uint32_t ret_val;

    DEBUGFUNC("em_write_phy_reg");

    if(hw->phy_type == em_phy_igp &&
       (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
        if((ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
                                             (uint16_t)reg_addr)))
            return ret_val;
    }

    ret_val = em_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT & reg_addr,
                                     phy_data);

    return ret_val;
}

int32_t
em_write_phy_reg_ex(struct em_hw *hw,
                    uint32_t reg_addr,
                    uint16_t phy_data)
{
d1946 1
a1946 1
    DEBUGFUNC("em_write_phy_reg_ex");
d1960 1
a1960 1
                (phy_addr << E1000_MDIC_PHY_SHIFT) |
d1967 1
a1967 1
            usec_delay(50);
d1978 1
a1978 1
         * beginning of the MII instruction.  This is done by sending 32
d1983 1
a1983 1
        /* Now combine the remaining required fields that will indicate a
d1996 1
a1996 2

    return E1000_SUCCESS;
d2007 2
a2008 2
    uint32_t ctrl, ctrl_ext;
    uint32_t led_ctrl;
a2019 1
        E1000_WRITE_FLUSH(hw);
a2021 1
        E1000_WRITE_FLUSH(hw);
a2029 1
        E1000_WRITE_FLUSH(hw);
a2032 1
        E1000_WRITE_FLUSH(hw);
a2034 8

    if((hw->mac_type == em_82541) || (hw->mac_type == em_82547)) {
        /* Configure activity LED after PHY reset */
        led_ctrl = E1000_READ_REG(hw, LEDCTL);
        led_ctrl &= IGP_ACTIVITY_LED_MASK;
        led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
        E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
    }
a2046 1
    int32_t ret_val;
d2051 11
a2061 15
    if(hw->mac_type != em_82541_rev_2) {
        if((ret_val = em_read_phy_reg(hw, PHY_CTRL, &phy_data)))
            return ret_val;

        phy_data |= MII_CR_RESET;
        if((ret_val = em_write_phy_reg(hw, PHY_CTRL, phy_data)))
            return ret_val;

        usec_delay(1);
    } else em_phy_hw_reset(hw);

    if(hw->phy_type == em_phy_igp)
        em_phy_init_script(hw);

    return E1000_SUCCESS;
a2071 1
    int32_t phy_init_status, ret_val;
d2078 4
a2081 3
    if((ret_val = em_read_phy_reg(hw, PHY_ID1, &phy_id_high)))
        return ret_val;

d2083 5
a2087 4
    usec_delay(20);
    if((ret_val = em_read_phy_reg(hw, PHY_ID2, &phy_id_low)))
        return ret_val;

d2089 1
a2089 2
    hw->phy_revision = (uint32_t) phy_id_low & ~PHY_REVISION_MASK;

a2098 1
    case em_82545_rev_3:
a2099 1
    case em_82546_rev_3:
a2101 6
    case em_82541:
    case em_82541_rev_2:
    case em_82547:
    case em_82547_rev_2:
        if(hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
        break;
d2106 1
a2106 3
    phy_init_status = em_set_phy_type(hw);

    if ((match) && (phy_init_status == E1000_SUCCESS)) {
d2108 1
a2108 1
        return E1000_SUCCESS;
d2122 1
a2122 1
    int32_t ret_val;
d2124 1
a2124 1

d2126 4
a2129 4
        if((ret_val = em_write_phy_reg(hw, 29, 0x001d))) break;
        if((ret_val = em_write_phy_reg(hw, 30, 0x00c1))) break;
        if((ret_val = em_write_phy_reg(hw, 30, 0x0000))) break;
        ret_val = E1000_SUCCESS;
d2132 1
a2136 132
* Get PHY information from various PHY registers for igp PHY only.
*
* hw - Struct containing variables accessed by shared code
* phy_info - PHY information structure
******************************************************************************/
int32_t
em_phy_igp_get_info(struct em_hw *hw,
                       struct em_phy_info *phy_info)
{
    int32_t ret_val;
    uint16_t phy_data, polarity, min_length, max_length, average;

    DEBUGFUNC("em_phy_igp_get_info");

    /* The downshift status is checked only once, after link is established,
     * and it stored in the hw->speed_downgraded parameter. */
    phy_info->downshift = hw->speed_downgraded;

    /* IGP01E1000 does not need to support it. */
    phy_info->extended_10bt_distance = em_10bt_ext_dist_enable_normal;

    /* IGP01E1000 always correct polarity reversal */
    phy_info->polarity_correction = em_polarity_reversal_enabled;

    /* Check polarity status */
    if((ret_val = em_check_polarity(hw, &polarity)))
        return ret_val;

    phy_info->cable_polarity = polarity;

    if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
                                     &phy_data)))
        return ret_val;

    phy_info->mdix_mode = (phy_data & IGP01E1000_PSSR_MDIX) >>
                          IGP01E1000_PSSR_MDIX_SHIFT;

    if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
       IGP01E1000_PSSR_SPEED_1000MBPS) {
        /* Local/Remote Receiver Information are only valid at 1000 Mbps */
        if((ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data)))
            return ret_val;

        phy_info->local_rx = (phy_data & SR_1000T_LOCAL_RX_STATUS) >>
                             SR_1000T_LOCAL_RX_STATUS_SHIFT;
        phy_info->remote_rx = (phy_data & SR_1000T_REMOTE_RX_STATUS) >>
                              SR_1000T_REMOTE_RX_STATUS_SHIFT;

        /* Get cable length */
        if((ret_val = em_get_cable_length(hw, &min_length, &max_length)))
            return ret_val;

        /* transalte to old method */
        average = (max_length + min_length) / 2;

        if(average <= em_igp_cable_length_50)
            phy_info->cable_length = em_cable_length_50;
        else if(average <= em_igp_cable_length_80)
            phy_info->cable_length = em_cable_length_50_80;
        else if(average <= em_igp_cable_length_110)
            phy_info->cable_length = em_cable_length_80_110;
        else if(average <= em_igp_cable_length_140)
            phy_info->cable_length = em_cable_length_110_140;
        else
            phy_info->cable_length = em_cable_length_140;
    }

    return E1000_SUCCESS;
}

/******************************************************************************
* Get PHY information from various PHY registers fot m88 PHY only.
*
* hw - Struct containing variables accessed by shared code
* phy_info - PHY information structure
******************************************************************************/
int32_t
em_phy_m88_get_info(struct em_hw *hw,
                       struct em_phy_info *phy_info)
{
    int32_t ret_val;
    uint16_t phy_data, polarity;

    DEBUGFUNC("em_phy_m88_get_info");

    /* The downshift status is checked only once, after link is established,
     * and it stored in the hw->speed_downgraded parameter. */
    phy_info->downshift = hw->speed_downgraded;

    if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data)))
        return ret_val;

    phy_info->extended_10bt_distance =
        (phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
        M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT;
    phy_info->polarity_correction =
        (phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>
        M88E1000_PSCR_POLARITY_REVERSAL_SHIFT;

    /* Check polarity status */
    if((ret_val = em_check_polarity(hw, &polarity)))
        return ret_val;

    phy_info->cable_polarity = polarity;

    if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data)))
        return ret_val;

    phy_info->mdix_mode = (phy_data & M88E1000_PSSR_MDIX) >>
                          M88E1000_PSSR_MDIX_SHIFT;

    if(phy_data & M88E1000_PSSR_1000MBS) {
        /* Cable Length Estimation and Local/Remote Receiver Informatoion
         * are only valid at 1000 Mbps
         */
        phy_info->cable_length = ((phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
                                  M88E1000_PSSR_CABLE_LENGTH_SHIFT);

        if((ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data)))
            return ret_val;

        phy_info->local_rx = (phy_data & SR_1000T_LOCAL_RX_STATUS) >>
                             SR_1000T_LOCAL_RX_STATUS_SHIFT;

        phy_info->remote_rx = (phy_data & SR_1000T_REMOTE_RX_STATUS) >>
                              SR_1000T_REMOTE_RX_STATUS_SHIFT;
    }

    return E1000_SUCCESS;
}

/******************************************************************************
d2146 1
a2146 1
    int32_t ret_val;
a2153 1
    phy_info->downshift = em_downshift_undefined;
d2164 38
a2201 2
    if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
        return ret_val;
d2203 2
a2204 12
    if((ret_val = em_read_phy_reg(hw, PHY_STATUS, &phy_data)))
        return ret_val;

    if((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {
        DEBUGOUT("PHY info is only valid if link is up\n");
        return -E1000_ERR_CONFIG;
    }

    if(hw->phy_type == em_phy_igp)
        return em_phy_igp_get_info(hw, phy_info);
    else
        return em_phy_m88_get_info(hw, phy_info);
d2217 1
a2217 119
    return E1000_SUCCESS;
}


/******************************************************************************
 * Sets up eeprom variables in the hw struct.  Must be called after mac_type
 * is configured.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
void
em_init_eeprom_params(struct em_hw *hw)
{
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint32_t eecd = E1000_READ_REG(hw, EECD);
    uint16_t eeprom_size;

    DEBUGFUNC("em_init_eeprom_params");

    switch (hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
    case em_82543:
    case em_82544:
        eeprom->type = em_eeprom_microwire;
        eeprom->word_size = 64;
        eeprom->opcode_bits = 3;
        eeprom->address_bits = 6;
        eeprom->delay_usec = 50;
        break;
    case em_82540:
    case em_82545:
    case em_82545_rev_3:
    case em_82546:
    case em_82546_rev_3:
        eeprom->type = em_eeprom_microwire;
        eeprom->opcode_bits = 3;
        eeprom->delay_usec = 50;
        if(eecd & E1000_EECD_SIZE) {
            eeprom->word_size = 256;
            eeprom->address_bits = 8;
        } else {
            eeprom->word_size = 64;
            eeprom->address_bits = 6;
        }
        break;
    case em_82541:
    case em_82541_rev_2:
    case em_82547:
    case em_82547_rev_2:
        if (eecd & E1000_EECD_TYPE) {
            eeprom->type = em_eeprom_spi;
            eeprom->opcode_bits = 8;
            eeprom->delay_usec = 1;
            if (eecd & E1000_EECD_ADDR_BITS) {
                eeprom->page_size = 32;
                eeprom->address_bits = 16;
            } else {
                eeprom->page_size = 8;
                eeprom->address_bits = 8;
            }
        } else {
            eeprom->type = em_eeprom_microwire;
            eeprom->opcode_bits = 3;
            eeprom->delay_usec = 50;
            if (eecd & E1000_EECD_ADDR_BITS) {
                eeprom->word_size = 256;
                eeprom->address_bits = 8;
            } else {
                eeprom->word_size = 64;
                eeprom->address_bits = 6;
            }
        }
        break;
    default:
        eeprom->type = em_eeprom_spi;
        eeprom->opcode_bits = 8;
        eeprom->delay_usec = 1;
        if (eecd & E1000_EECD_ADDR_BITS) {
            eeprom->page_size = 32;
            eeprom->address_bits = 16;
        } else {
            eeprom->page_size = 8;
            eeprom->address_bits = 8;
        }
        break;
    }

    if (eeprom->type == em_eeprom_spi) {
        eeprom->word_size = 64;
        if (em_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size) == 0) {
            eeprom_size &= EEPROM_SIZE_MASK;

            switch (eeprom_size) {
            case EEPROM_SIZE_16KB:
                eeprom->word_size = 8192;
                break;
            case EEPROM_SIZE_8KB:
                eeprom->word_size = 4096;
                break;
            case EEPROM_SIZE_4KB:
                eeprom->word_size = 2048;
                break;
            case EEPROM_SIZE_2KB:
                eeprom->word_size = 1024;
                break;
            case EEPROM_SIZE_1KB:
                eeprom->word_size = 512;
                break;
            case EEPROM_SIZE_512B:
                eeprom->word_size = 256;
                break;
            case EEPROM_SIZE_128B:
            default:
                eeprom->word_size = 64;
                break;
            }
        }
    }
d2231 1
a2231 1
     * wait <delay> microseconds.
d2235 1
a2235 2
    E1000_WRITE_FLUSH(hw);
    usec_delay(hw->eeprom.delay_usec);
d2241 1
a2241 1
 * hw - Struct containing variables accessed by shared code
d2248 2
a2249 2
    /* Lower the clock input to the EEPROM (by clearing the SK bit), and then
     * wait 50 microseconds.
d2253 1
a2253 2
    E1000_WRITE_FLUSH(hw);
    usec_delay(hw->eeprom.delay_usec);
a2267 1
    struct em_eeprom_info *eeprom = &hw->eeprom;
d2273 1
a2273 1
     * In order to do this, "data" must be broken down into bits.
d2277 1
a2277 5
    if (eeprom->type == em_eeprom_microwire) {
        eecd &= ~E1000_EECD_DO;
    } else if (eeprom->type == em_eeprom_spi) {
        eecd |= E1000_EECD_DO;
    }
a2289 1
        E1000_WRITE_FLUSH(hw);
d2291 1
a2291 1
        usec_delay(eeprom->delay_usec);
d2311 1
a2311 2
em_shift_in_ee_bits(struct em_hw *hw,
                       uint16_t count)
d2317 5
a2321 5
    /* In order to read a register from the EEPROM, we need to shift 'count'
     * bits in from the EEPROM. Bits are "shifted in" by raising the clock
     * input to the EEPROM (setting the SK bit), and then reading the value of
     * the "DO" bit.  During this "shifting in" process the "DI" bit should
     * always be clear.
d2329 1
a2329 1
    for(i = 0; i < count; i++) {
d2350 1
a2350 1
 * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This
d2353 2
a2354 2
static int32_t
em_acquire_eeprom(struct em_hw *hw)
d2356 1
a2356 4
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint32_t eecd, i=0;

    DEBUGFUNC("em_acquire_eeprom");
d2360 3
a2362 18
    /* Request EEPROM Access */
    if(hw->mac_type > em_82544) {
        eecd |= E1000_EECD_REQ;
        E1000_WRITE_REG(hw, EECD, eecd);
        eecd = E1000_READ_REG(hw, EECD);
        while((!(eecd & E1000_EECD_GNT)) &&
              (i < E1000_EEPROM_GRANT_ATTEMPTS)) {
            i++;
            usec_delay(5);
            eecd = E1000_READ_REG(hw, EECD);
        }
        if(!(eecd & E1000_EECD_GNT)) {
            eecd &= ~E1000_EECD_REQ;
            E1000_WRITE_REG(hw, EECD, eecd);
            DEBUGOUT("Could not acquire EEPROM grant\n");
            return -E1000_ERR_EEPROM;
        }
    }
d2364 3
a2366 18
    /* Setup EEPROM for Read/Write */

    if (eeprom->type == em_eeprom_microwire) {
        /* Clear SK and DI */
        eecd &= ~(E1000_EECD_DI | E1000_EECD_SK);
        E1000_WRITE_REG(hw, EECD, eecd);

        /* Set CS */
        eecd |= E1000_EECD_CS;
        E1000_WRITE_REG(hw, EECD, eecd);
    } else if (eeprom->type == em_eeprom_spi) {
        /* Clear SK and CS */
        eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
        E1000_WRITE_REG(hw, EECD, eecd);
        usec_delay(1);
    }

    return E1000_SUCCESS;
d2371 1
a2371 1
 *
a2376 1
    struct em_eeprom_info *eeprom = &hw->eeprom;
d2381 4
a2384 5
    if(eeprom->type == em_eeprom_microwire) {
        eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);
d2386 4
a2389 5
        /* Clock high */
        eecd |= E1000_EECD_SK;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);
d2391 4
a2394 5
        /* Select EEPROM */
        eecd |= E1000_EECD_CS;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);
d2396 4
a2399 16
        /* Clock low */
        eecd &= ~E1000_EECD_SK;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);
    } else if(eeprom->type == em_eeprom_spi) {
        /* Toggle CS to flush commands */
        eecd |= E1000_EECD_CS;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);
        eecd &= ~E1000_EECD_CS;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(eeprom->delay_usec);
    }
d2403 1
a2403 1
 * Terminates a command by inverting the EEPROM's chip select pin
d2408 1
a2408 1
em_release_eeprom(struct em_hw *hw)
a2411 2
    DEBUGFUNC("em_release_eeprom");

d2414 4
a2417 3
    if (hw->eeprom.type == em_eeprom_spi) {
        eecd |= E1000_EECD_CS;  /* Pull CS high */
        eecd &= ~E1000_EECD_SK; /* Lower SCK */
d2419 4
a2422 29
        E1000_WRITE_REG(hw, EECD, eecd);

        usec_delay(hw->eeprom.delay_usec);
    } else if(hw->eeprom.type == em_eeprom_microwire) {
        /* cleanup eeprom */

        /* CS on Microwire is active-high */
        eecd &= ~(E1000_EECD_CS | E1000_EECD_DI);

        E1000_WRITE_REG(hw, EECD, eecd);

        /* Rising edge of clock */
        eecd |= E1000_EECD_SK;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(hw->eeprom.delay_usec);

        /* Falling edge of clock */
        eecd &= ~E1000_EECD_SK;
        E1000_WRITE_REG(hw, EECD, eecd);
        E1000_WRITE_FLUSH(hw);
        usec_delay(hw->eeprom.delay_usec);
    }

    /* Stop requesting EEPROM access */
    if(hw->mac_type > em_82544) {
        eecd &= ~E1000_EECD_REQ;
        E1000_WRITE_REG(hw, EECD, eecd);
    }
d2426 1
a2426 1
 * Reads a 16 bit word from the EEPROM.
d2430 2
a2431 2
int32_t
em_spi_eeprom_ready(struct em_hw *hw)
d2433 1
a2433 2
    uint16_t retry_count = 0;
    uint8_t spi_stat_reg;
d2435 1
a2435 14
    DEBUGFUNC("em_spi_eeprom_ready");

    /* Read "Status Register" repeatedly until the LSB is cleared.  The
     * EEPROM will signal that the command has been completed by clearing
     * bit 0 of the internal status register.  If it's not cleared within
     * 5 milliseconds, then error out.
     */
    retry_count = 0;
    do {
        em_shift_out_ee_bits(hw, EEPROM_RDSR_OPCODE_SPI,
                                hw->eeprom.opcode_bits);
        spi_stat_reg = (uint8_t)em_shift_in_ee_bits(hw, 8);
        if (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))
            break;
d2437 1
a2437 2
        usec_delay(5);
        retry_count += 5;
d2439 1
a2439 9
    } while(retry_count < EEPROM_MAX_RETRY_SPI);

    /* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
     * only 0-5mSec on 5V devices)
     */
    if(retry_count >= EEPROM_MAX_RETRY_SPI) {
        DEBUGOUT("SPI EEPROM Status error\n");
        return -E1000_ERR_EEPROM;
    }
d2441 1
a2441 1
    return E1000_SUCCESS;
d2449 1
a2449 2
 * data - word read from the EEPROM
 * words - number of words to read
a2453 1
                  uint16_t words,
d2456 1
a2456 1
    struct em_eeprom_info *eeprom = &hw->eeprom;
d2458 1
d2462 18
a2479 7
    /* A check for invalid values:  offset too large, too many words, and not
     * enough words.
     */
    if((offset > eeprom->word_size) || (words > eeprom->word_size - offset) ||
       (words == 0)) {
        DEBUGOUT("\"words\" parameter out of bounds\n");
        return -E1000_ERR_EEPROM;
d2482 2
a2483 3
    /* Prepare the EEPROM for reading  */
    if(em_acquire_eeprom(hw) != E1000_SUCCESS)
        return -E1000_ERR_EEPROM;
d2485 9
a2493 3
    if(eeprom->type == em_eeprom_spi) {
        uint16_t word_in;
        uint8_t read_opcode = EEPROM_READ_OPCODE_SPI;
d2495 2
a2496 4
        if(em_spi_eeprom_ready(hw)) {
            em_release_eeprom(hw);
            return -E1000_ERR_EEPROM;
        }
d2498 2
a2499 1
        em_standby_eeprom(hw);
d2501 5
a2505 30
        /* Some SPI eeproms use the 8th address bit embedded in the opcode */
        if((eeprom->address_bits == 8) && (offset >= 128))
            read_opcode |= EEPROM_A8_OPCODE_SPI;

        /* Send the READ command (opcode + addr)  */
        em_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);
        em_shift_out_ee_bits(hw, (uint16_t)(offset*2), eeprom->address_bits);

        /* Read the data.  The address of the eeprom internally increments with
         * each byte (spi) being read, saving on the overhead of eeprom setup
         * and tear-down.  The address counter will roll over if reading beyond
         * the size of the eeprom, thus allowing the entire memory to be read
         * starting from any offset. */
        for (i = 0; i < words; i++) {
            word_in = em_shift_in_ee_bits(hw, 16);
            data[i] = (word_in >> 8) | (word_in << 8);
        }
    } else if(eeprom->type == em_eeprom_microwire) {
        for (i = 0; i < words; i++) {
            /* Send the READ command (opcode + addr)  */
            em_shift_out_ee_bits(hw, EEPROM_READ_OPCODE_MICROWIRE,
                                    eeprom->opcode_bits);
            em_shift_out_ee_bits(hw, (uint16_t)(offset + i),
                                    eeprom->address_bits);

            /* Read the data.  For microwire, each word requires the overhead
             * of eeprom setup and tear-down. */
            data[i] = em_shift_in_ee_bits(hw, 16);
            em_standby_eeprom(hw);
        }
d2508 1
a2508 4
    /* End this read operation */
    em_release_eeprom(hw);

    return E1000_SUCCESS;
d2513 1
a2513 1
 *
d2529 1
a2529 1
        if(em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
d2536 4
a2539 4
    if(checksum == (uint16_t) EEPROM_SUM)
        return E1000_SUCCESS;
    else {
        DEBUGOUT("EEPROM Checksum Invalid\n");
d2561 1
a2561 1
        if(em_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
d2568 1
a2568 1
    if(em_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
d2572 1
a2572 1
    return E1000_SUCCESS;
d2576 1
a2576 1
 * Parent function for writing words to the different EEPROM types.
d2580 1
a2580 2
 * words - number of words to write
 * data - 16 bit word to be written to the EEPROM
d2582 1
a2582 1
 * If em_update_eeprom_checksum is not called after this function, the
d2588 1
a2588 2
                   uint16_t words,
                   uint16_t *data)
d2590 2
a2591 1
    struct em_eeprom_info *eeprom = &hw->eeprom;
d2593 1
d2597 18
a2614 7
    /* A check for invalid values:  offset too large, too many words, and not
     * enough words.
     */
    if((offset > eeprom->word_size) || (words > eeprom->word_size - offset) ||
       (words == 0)) {
        DEBUGOUT("\"words\" parameter out of bounds\n");
        return -E1000_ERR_EEPROM;
d2618 1
a2618 2
    if (em_acquire_eeprom(hw) != E1000_SUCCESS)
        return -E1000_ERR_EEPROM;
d2620 7
a2626 2
    if(eeprom->type == em_eeprom_microwire)
        status = em_write_eeprom_microwire(hw, offset, words, data);
d2628 1
a2628 1
        status = em_write_eeprom_spi(hw, offset, words, data);
d2630 2
a2631 2
    /* Done with writing */
    em_release_eeprom(hw);
d2633 8
a2640 2
    return status;
}
d2642 2
a2643 17
/******************************************************************************
 * Writes a 16 bit word to a given offset in an SPI EEPROM.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset within the EEPROM to be written to
 * words - number of words to write
 * data - pointer to array of 8 bit words to be written to the EEPROM
 *
 *****************************************************************************/
int32_t
em_write_eeprom_spi(struct em_hw *hw,
                       uint16_t offset,
                       uint16_t words,
                       uint16_t *data)
{
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint16_t widx = 0;
d2645 4
a2648 1
    DEBUGFUNC("em_write_eeprom_spi");
d2650 12
a2661 41
    while (widx < words) {
        uint8_t write_opcode = EEPROM_WRITE_OPCODE_SPI;

        if(em_spi_eeprom_ready(hw)) return -E1000_ERR_EEPROM;

        em_standby_eeprom(hw);

        /*  Send the WRITE ENABLE command (8 bit opcode )  */
        em_shift_out_ee_bits(hw, EEPROM_WREN_OPCODE_SPI,
                                    eeprom->opcode_bits);

        em_standby_eeprom(hw);

        /* Some SPI eeproms use the 8th address bit embedded in the opcode */
        if((eeprom->address_bits == 8) && (offset >= 128))
            write_opcode |= EEPROM_A8_OPCODE_SPI;

        /* Send the Write command (8-bit opcode + addr) */
        em_shift_out_ee_bits(hw, write_opcode, eeprom->opcode_bits);

        em_shift_out_ee_bits(hw, (uint16_t)((offset + widx)*2),
                                eeprom->address_bits);

        /* Send the data */

        /* Loop to allow for up to whole page write (32 bytes) of eeprom */
        while (widx < words) {
            uint16_t word_out = data[widx];
            word_out = (word_out >> 8) | (word_out << 8);
            em_shift_out_ee_bits(hw, word_out, 16);
            widx++;

            /* Some larger eeprom sizes are capable of a 32-byte PAGE WRITE
             * operation, while the smaller eeproms are capable of an 8-byte
             * PAGE WRITE operation.  Break the inner loop to pass new address
             */
            if((((offset + widx)*2) % eeprom->page_size) == 0) {
                em_standby_eeprom(hw);
                break;
            }
        }
d2664 1
a2664 37
    return E1000_SUCCESS;
}

/******************************************************************************
 * Writes a 16 bit word to a given offset in a Microwire EEPROM.
 *
 * hw - Struct containing variables accessed by shared code
 * offset - offset within the EEPROM to be written to
 * words - number of words to write
 * data - pointer to array of 16 bit words to be written to the EEPROM
 *
 *****************************************************************************/
int32_t
em_write_eeprom_microwire(struct em_hw *hw,
                             uint16_t offset,
                             uint16_t words,
                             uint16_t *data)
{
    struct em_eeprom_info *eeprom = &hw->eeprom;
    uint32_t eecd;
    uint16_t words_written = 0;
    uint16_t i = 0;

    DEBUGFUNC("em_write_eeprom_microwire");

    /* Send the write enable command to the EEPROM (3-bit opcode plus
     * 6/8-bit dummy address beginning with 11).  It's less work to include
     * the 11 of the dummy address as part of the opcode than it is to shift
     * it over the correct number of bits for the address.  This puts the
     * EEPROM into write/erase mode.
     */
    em_shift_out_ee_bits(hw, EEPROM_EWEN_OPCODE_MICROWIRE,
                            (uint16_t)(eeprom->opcode_bits + 2));

    em_shift_out_ee_bits(hw, 0, (uint16_t)(eeprom->address_bits - 2));

    /* Prepare the EEPROM */
d2667 9
a2675 4
    while (words_written < words) {
        /* Send the Write command (3-bit opcode + addr) */
        em_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE_MICROWIRE,
                                eeprom->opcode_bits);
d2677 2
a2678 2
        em_shift_out_ee_bits(hw, (uint16_t)(offset + words_written),
                                eeprom->address_bits);
d2680 5
a2684 26
        /* Send the data */
        em_shift_out_ee_bits(hw, data[words_written], 16);

        /* Toggle the CS line.  This in effect tells the EEPROM to execute
         * the previous command.
         */
        em_standby_eeprom(hw);

        /* Read DO repeatedly until it is high (equal to '1').  The EEPROM will
         * signal that the command has been completed by raising the DO signal.
         * If DO does not go high in 10 milliseconds, then error out.
         */
        for(i = 0; i < 200; i++) {
            eecd = E1000_READ_REG(hw, EECD);
            if(eecd & E1000_EECD_DO) break;
            usec_delay(50);
        }
        if(i == 200) {
            DEBUGOUT("EEPROM Write did not complete\n");
            return -E1000_ERR_EEPROM;
        }

        /* Recover from write */
        em_standby_eeprom(hw);

        words_written++;
d2687 1
a2687 12
    /* Send the write disable command to the EEPROM (3-bit opcode plus
     * 6/8-bit dummy address beginning with 10).  It's less work to include
     * the 10 of the dummy address as part of the opcode than it is to shift
     * it over the correct number of bits for the address.  This takes the
     * EEPROM out of write/erase mode.
     */
    em_shift_out_ee_bits(hw, EEPROM_EWDS_OPCODE_MICROWIRE,
                            (uint16_t)(eeprom->opcode_bits + 2));

    em_shift_out_ee_bits(hw, 0, (uint16_t)(eeprom->address_bits - 2));

    return E1000_SUCCESS;
d2706 1
a2706 1
    if(em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
d2714 1
a2714 1
    if(em_read_eeprom(hw, ++offset, 1, &eeprom_data) < 0) {
d2721 1
a2721 1
    return E1000_SUCCESS;
d2740 1
a2740 1
        if(em_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
d2747 1
a2747 1
    if(((hw->mac_type == em_82546) || (hw->mac_type == em_82546_rev_3)) &&
d2756 1
a2756 1
    return E1000_SUCCESS;
d2762 1
a2762 1
 * hw - Struct containing variables accessed by shared code
d2807 1
a2807 1
 * for the first 15 multicast addresses, and hashes the rest into the
d2856 1
a2856 1
         * else put it in the MTA
d2874 1
a2874 1
 * mc_addr - the multicast address to hash
d2883 1
a2883 1
     * determined by the mc_filter_type setting.
d2926 2
a2927 2
    /* The MTA is a register array of 128 32-bit registers.
     * It is treated like an array of 4096 bits.  We want to set
d2930 2
a2931 2
     * back the new value.  The register is determined by the
     * upper 7 bits of the hash value and the bit within that
d2969 1
a2969 1
     * from network order (big endian) to little endian
d3027 1
a3027 1

d3029 1
a3029 1

d3032 1
a3032 1
        return E1000_SUCCESS;
d3034 1
a3034 1

d3039 2
a3040 2

    if(em_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {
d3044 1
a3044 1
    if((eeprom_data== ID_LED_RESERVED_0000) ||
d3083 1
a3083 1
    return E1000_SUCCESS;
d3095 1
a3095 2
    int32_t ret_val = E1000_SUCCESS;

d3097 9
a3105 6

    switch(hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
    case em_82543:
    case em_82544:
d3108 18
a3125 13
    case em_82541:
    case em_82547:
    case em_82541_rev_2:
    case em_82547_rev_2:
        /* Turn off PHY Smart Power Down (if enabled) */
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_GMII_FIFO,
                                         &hw->phy_spd_default)))
            return ret_val;
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
                                          (uint16_t)(hw->phy_spd_default &
                                          ~IGP01E1000_GMII_SPD))))
            return ret_val;
        /* Fall Through */
d3127 2
a3128 14
        if(hw->media_type == em_media_type_fiber) {
            ledctl = E1000_READ_REG(hw, LEDCTL);
            /* Save current LEDCTL settings */
            hw->ledctl_default = ledctl;
            /* Turn off LED0 */
            ledctl &= ~(E1000_LEDCTL_LED0_IVRT |
                        E1000_LEDCTL_LED0_BLINK |
                        E1000_LEDCTL_LED0_MODE_MASK);
            ledctl |= (E1000_LEDCTL_MODE_LED_OFF <<
                       E1000_LEDCTL_LED0_MODE_SHIFT);
            E1000_WRITE_REG(hw, LEDCTL, ledctl);
        } else if(hw->media_type == em_media_type_copper)
            E1000_WRITE_REG(hw, LEDCTL, hw->ledctl_mode1);
        break;
d3130 1
a3130 2

    return E1000_SUCCESS;
a3140 2
    int32_t ret_val = E1000_SUCCESS;

d3143 8
a3150 5
    switch(hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
    case em_82543:
    case em_82544:
d3153 6
a3158 10
    case em_82541:
    case em_82547:
    case em_82541_rev_2:
    case em_82547_rev_2:
        /* Turn on PHY Smart Power Down (if previously enabled) */
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
                                          hw->phy_spd_default)))
            return ret_val;
        /* Fall Through */
    default:
d3162 3
d3166 1
a3166 2

    return E1000_SUCCESS;
d3168 1
a3168 1

d3177 1
a3177 1
    uint32_t ctrl = E1000_READ_REG(hw, CTRL);
d3181 6
a3186 4
    switch(hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
    case em_82543:
d3190 12
d3203 5
a3207 10
    case em_82544:
        if(hw->media_type == em_media_type_fiber) {
            /* Set SW Defineable Pin 0 to turn on the LED */
            ctrl |= E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        } else {
            /* Clear SW Defineable Pin 0 to turn on the LED */
            ctrl &= ~E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        }
d3210 2
a3211 9
        if(hw->media_type == em_media_type_fiber) {
            /* Clear SW Defineable Pin 0 to turn on the LED */
            ctrl &= ~E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        } else if(hw->media_type == em_media_type_copper) {
            E1000_WRITE_REG(hw, LEDCTL, hw->ledctl_mode2);
            return E1000_SUCCESS;
        }
        break;
d3213 1
a3213 4

    E1000_WRITE_REG(hw, CTRL, ctrl);

    return E1000_SUCCESS;
d3224 1
a3224 1
    uint32_t ctrl = E1000_READ_REG(hw, CTRL);
d3228 6
a3233 4
    switch(hw->mac_type) {
    case em_82542_rev2_0:
    case em_82542_rev2_1:
    case em_82543:
d3237 12
d3250 5
a3254 10
    case em_82544:
        if(hw->media_type == em_media_type_fiber) {
            /* Clear SW Defineable Pin 0 to turn off the LED */
            ctrl &= ~E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        } else {
            /* Set SW Defineable Pin 0 to turn off the LED */
            ctrl |= E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        }
d3257 2
a3258 9
        if(hw->media_type == em_media_type_fiber) {
            /* Set SW Defineable Pin 0 to turn off the LED */
            ctrl |= E1000_CTRL_SWDPIN0;
            ctrl |= E1000_CTRL_SWDPIO0;
        } else if(hw->media_type == em_media_type_copper) {
            E1000_WRITE_REG(hw, LEDCTL, hw->ledctl_mode1);
            return E1000_SUCCESS;
        }
        break;
d3260 1
a3260 4

    E1000_WRITE_REG(hw, CTRL, ctrl);

    return E1000_SUCCESS;
d3264 1
a3264 1
 * Clears all hardware statistics counters.
d3383 2
a3384 1
        if((hw->collision_delta * hw->ifs_ratio) > hw->tx_packet_delta) {
d3396 2
a3397 1
            if(hw->in_ifs_mode && (hw->tx_packet_delta <= MIN_NUM_XMITS)) {
d3410 1
a3410 1
 *
d3438 2
a3439 2
     * Received Count) was one before the addition,
     * AND it is zero after, then we lost the carry out,
d3441 1
a3441 1
     * This could be simplified if all environments supported
d3447 1
a3447 1
     * since the test for a multicast frame will test positive on
d3508 1
a3508 5

    if(hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
        hw->bus_speed = (hw->bus_type == em_bus_type_pci) ?
                        em_bus_speed_66 : em_bus_speed_120;
    } else if(hw->bus_type == em_bus_type_pci) {
a3565 473
}


/******************************************************************************
 * Estimates the cable length.
 *
 * hw - Struct containing variables accessed by shared code
 * min_length - The estimated minimum length
 * max_length - The estimated maximum length
 *
 * returns: - E1000_ERR_XXX
 *            E1000_SUCCESS
 *
 * This function always returns a ranged length (minimum & maximum).
 * So for M88 phy's, this function interprets the one value returned from the
 * register to the minimum and maximum range.
 * For IGP phy's, the function calculates the range by the AGC registers.
 *****************************************************************************/
int32_t
em_get_cable_length(struct em_hw *hw,
                       uint16_t *min_length,
                       uint16_t *max_length)
{
    int32_t ret_val;
    uint16_t agc_value = 0;
    uint16_t cur_agc, min_agc = IGP01E1000_AGC_LENGTH_TABLE_SIZE;
    uint16_t i, phy_data;

    DEBUGFUNC("em_get_cable_length");

    *min_length = *max_length = 0;

    /* Use old method for Phy older than IGP */
    if(hw->phy_type == em_phy_m88) {
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                         &phy_data)))
            return ret_val;

        /* Convert the enum value to ranged values */
        switch((phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
               M88E1000_PSSR_CABLE_LENGTH_SHIFT) {
        case em_cable_length_50:
            *min_length = 0;
            *max_length = em_igp_cable_length_50;
            break;
        case em_cable_length_50_80:
            *min_length = em_igp_cable_length_50;
            *max_length = em_igp_cable_length_80;
            break;
        case em_cable_length_80_110:
            *min_length = em_igp_cable_length_80;
            *max_length = em_igp_cable_length_110;
            break;
        case em_cable_length_110_140:
            *min_length = em_igp_cable_length_110;
            *max_length = em_igp_cable_length_140;
            break;
        case em_cable_length_140:
            *min_length = em_igp_cable_length_140;
            *max_length = em_igp_cable_length_170;
            break;
        default:
            return -E1000_ERR_PHY;
            break;
        }
    } else if(hw->phy_type == em_phy_igp) { /* For IGP PHY */
        uint16_t agc_reg_array[IGP01E1000_PHY_CHANNEL_NUM] =
                                                         {IGP01E1000_PHY_AGC_A,
                                                          IGP01E1000_PHY_AGC_B,
                                                          IGP01E1000_PHY_AGC_C,
                                                          IGP01E1000_PHY_AGC_D};
        /* Read the AGC registers for all channels */
        for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {

            if((ret_val = em_read_phy_reg(hw, agc_reg_array[i], &phy_data)))
                return ret_val;

            cur_agc = phy_data >> IGP01E1000_AGC_LENGTH_SHIFT;

            /* Array bound check. */
            if((cur_agc >= IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1) ||
               (cur_agc == 0))
                return -E1000_ERR_PHY;

            agc_value += cur_agc;

            /* Update minimal AGC value. */
            if(min_agc > cur_agc)
                min_agc = cur_agc;
        }

        /* Remove the minimal AGC result for length < 50m */
        if(agc_value < IGP01E1000_PHY_CHANNEL_NUM * em_igp_cable_length_50) {
            agc_value -= min_agc;

            /* Get the average length of the remaining 3 channels */
            agc_value /= (IGP01E1000_PHY_CHANNEL_NUM - 1);
        } else {
            /* Get the average length of all the 4 channels. */
            agc_value /= IGP01E1000_PHY_CHANNEL_NUM;
        }

        /* Set the range of the calculated length. */
        *min_length = ((em_igp_cable_length_table[agc_value] -
                       IGP01E1000_AGC_RANGE) > 0) ?
                       (em_igp_cable_length_table[agc_value] -
                       IGP01E1000_AGC_RANGE) : 0;
        *max_length = em_igp_cable_length_table[agc_value] +
                      IGP01E1000_AGC_RANGE;
    }

    return E1000_SUCCESS;
}

/******************************************************************************
 * Check the cable polarity
 *
 * hw - Struct containing variables accessed by shared code
 * polarity - output parameter : 0 - Polarity is not reversed
 *                               1 - Polarity is reversed.
 *
 * returns: - E1000_ERR_XXX
 *            E1000_SUCCESS
 *
 * For phy's older then IGP, this function simply reads the polarity bit in the
 * Phy Status register.  For IGP phy's, this bit is valid only if link speed is
 * 10 Mbps.  If the link speed is 100 Mbps there is no polarity so this bit will
 * return 0.  If the link speed is 1000 Mbps the polarity status is in the
 * IGP01E1000_PHY_PCS_INIT_REG.
 *****************************************************************************/
int32_t
em_check_polarity(struct em_hw *hw,
                     uint16_t *polarity)
{
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_check_polarity");

    if(hw->phy_type == em_phy_m88) {
        /* return the Polarity bit in the Status register. */
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                         &phy_data)))
            return ret_val;
        *polarity = (phy_data & M88E1000_PSSR_REV_POLARITY) >>
                    M88E1000_PSSR_REV_POLARITY_SHIFT;
    } else if(hw->phy_type == em_phy_igp) {
        /* Read the Status register to check the speed */
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
                                         &phy_data)))
            return ret_val;

        /* If speed is 1000 Mbps, must read the IGP01E1000_PHY_PCS_INIT_REG to
         * find the polarity status */
        if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
           IGP01E1000_PSSR_SPEED_1000MBPS) {

            /* Read the GIG initialization PCS register (0x00B4) */
            if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG,
                                             &phy_data)))
                return ret_val;

            /* Check the polarity bits */
            *polarity = (phy_data & IGP01E1000_PHY_POLARITY_MASK) ? 1 : 0;
        } else {
            /* For 10 Mbps, read the polarity bit in the status register. (for
             * 100 Mbps this bit is always 0) */
            *polarity = phy_data & IGP01E1000_PSSR_POLARITY_REVERSED;
        }
    }
    return E1000_SUCCESS;
}

/******************************************************************************
 * Check if Downshift occured
 *
 * hw - Struct containing variables accessed by shared code
 * downshift - output parameter : 0 - No Downshift ocured.
 *                                1 - Downshift ocured.
 *
 * returns: - E1000_ERR_XXX
 *            E1000_SUCCESS 
 *
 * For phy's older then IGP, this function reads the Downshift bit in the Phy
 * Specific Status register.  For IGP phy's, it reads the Downgrade bit in the
 * Link Health register.  In IGP this bit is latched high, so the driver must
 * read it immediately after link is established.
 *****************************************************************************/
int32_t
em_check_downshift(struct em_hw *hw)
{
    int32_t ret_val;
    uint16_t phy_data;

    DEBUGFUNC("em_check_downshift");

    if(hw->phy_type == em_phy_igp) {
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH,
                                         &phy_data)))
            return ret_val;

        hw->speed_downgraded = (phy_data & IGP01E1000_PLHR_SS_DOWNGRADE) ? 1 : 0;
    }
    else if(hw->phy_type == em_phy_m88) {
        if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
                                         &phy_data)))
            return ret_val;

        hw->speed_downgraded = (phy_data & M88E1000_PSSR_DOWNSHIFT) >>
                               M88E1000_PSSR_DOWNSHIFT_SHIFT;
    }
    return E1000_SUCCESS;
}

/*****************************************************************************
 *
 * 82541_rev_2 & 82547_rev_2 have the capability to configure the DSP when a
 * gigabit link is achieved to improve link quality.
 *
 * hw: Struct containing variables accessed by shared code
 *
 * returns: - E1000_ERR_PHY if fail to read/write the PHY
 *            E1000_SUCCESS at any other case.
 *
 ****************************************************************************/

int32_t
em_config_dsp_after_link_change(struct em_hw *hw,
                                   boolean_t link_up)
{
    int32_t ret_val;
    uint16_t phy_data, speed, duplex, i;
    uint16_t dsp_reg_array[IGP01E1000_PHY_CHANNEL_NUM] =
                                        {IGP01E1000_PHY_AGC_PARAM_A,
                                        IGP01E1000_PHY_AGC_PARAM_B,
                                        IGP01E1000_PHY_AGC_PARAM_C,
                                        IGP01E1000_PHY_AGC_PARAM_D};
    uint16_t min_length, max_length;

    DEBUGFUNC("em_config_dsp_after_link_change");

    if(hw->phy_type != em_phy_igp)
        return E1000_SUCCESS;

    if(link_up) {
        if((ret_val = em_get_speed_and_duplex(hw, &speed, &duplex))) {
            DEBUGOUT("Error getting link speed and duplex\n");
            return ret_val;
        }

        if(speed == SPEED_1000) {

            em_get_cable_length(hw, &min_length, &max_length);

            if((hw->dsp_config_state == em_dsp_config_enabled) &&
                min_length >= em_igp_cable_length_50) {

                for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
                    if((ret_val = em_read_phy_reg(hw, dsp_reg_array[i],
                                                     &phy_data)))
                        return ret_val;

                    phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;

                    if((ret_val = em_write_phy_reg(hw, dsp_reg_array[i],
                                                      phy_data)))
                        return ret_val;
                }
                hw->dsp_config_state = em_dsp_config_activated;
            }

            if((hw->ffe_config_state == em_ffe_config_enabled) &&
               (min_length < em_igp_cable_length_50)) {

                uint16_t ffe_idle_err_timeout = FFE_IDLE_ERR_COUNT_TIMEOUT_20;
                uint32_t idle_errs = 0;

                /* clear previous idle error counts */
                if((ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS,
                                                 &phy_data)))
                    return ret_val;

                for(i = 0; i < ffe_idle_err_timeout; i++) {
                    usec_delay(1000);
                    if((ret_val = em_read_phy_reg(hw, PHY_1000T_STATUS,
                                                     &phy_data)))
                        return ret_val;

                    idle_errs += (phy_data & SR_1000T_IDLE_ERROR_CNT);
                    if(idle_errs > SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {
                        hw->ffe_config_state = em_ffe_config_active;

                        if((ret_val = em_write_phy_reg(hw,
                                    IGP01E1000_PHY_DSP_FFE,
                                    IGP01E1000_PHY_DSP_FFE_CM_CP)))
                            return ret_val;
                        break;
                    }

                    if(idle_errs)
                        ffe_idle_err_timeout = FFE_IDLE_ERR_COUNT_TIMEOUT_100;
                }
            }
        }
    } else {
        if(hw->dsp_config_state == em_dsp_config_activated) {
            if((ret_val = em_write_phy_reg(hw, 0x0000,
                IGP01E1000_IEEE_FORCE_GIGA)))
                return ret_val;
            for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
                if((ret_val = em_read_phy_reg(hw, dsp_reg_array[i],
                                                 &phy_data)))
                    return ret_val;

                phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
                phy_data |=  IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS;

                if((ret_val = em_write_phy_reg(hw,dsp_reg_array[i],
                                                  phy_data)))
                    return ret_val;
            }

            if((ret_val = em_write_phy_reg(hw, 0x0000,
                                              IGP01E1000_IEEE_RESTART_AUTONEG)))
                return ret_val;

            hw->dsp_config_state = em_dsp_config_enabled;
        }

        if(hw->ffe_config_state == em_ffe_config_active) {
            if((ret_val = em_write_phy_reg(hw, 0x0000,
                                              IGP01E1000_IEEE_FORCE_GIGA)))
                return ret_val;
            if((ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_DSP_FFE,
                                              IGP01E1000_PHY_DSP_FFE_DEFAULT)))
                return ret_val;

            if((ret_val = em_write_phy_reg(hw, 0x0000,
                                              IGP01E1000_IEEE_RESTART_AUTONEG)))
                return ret_val;
        hw->ffe_config_state = em_ffe_config_enabled;
        }
    }
    return E1000_SUCCESS;
}

/*****************************************************************************
 *
 * This function sets the lplu state according to the active flag.  When
 * activating lplu this function also disables smart speed and vise versa.
 * lplu will not be activated unless the device autonegotiation advertisment
 * meets standards of either 10 or 10/100 or 10/100/1000 at all duplexes.
 * hw: Struct containing variables accessed by shared code
 * active - true to enable lplu false to disable lplu.
 *
 * returns: - E1000_ERR_PHY if fail to read/write the PHY
 *            E1000_SUCCESS at any other case.
 *
 ****************************************************************************/

int32_t
em_set_d3_lplu_state(struct em_hw *hw,
                        boolean_t active)
{
    int32_t ret_val;
    uint16_t phy_data;
    DEBUGFUNC("em_set_d3_lplu_state");

    if(!((hw->mac_type == em_82541_rev_2) ||
         (hw->mac_type == em_82547_rev_2)))
        return E1000_SUCCESS;

    /* During driver activity LPLU should not be used or it will attain link
     * from the lowest speeds starting from 10Mbps. The capability is used for
     * Dx transitions and states */
    if((ret_val = em_read_phy_reg(hw, IGP01E1000_GMII_FIFO, &phy_data)))
        return ret_val;

    if(!active) {
        phy_data &= ~IGP01E1000_GMII_FLEX_SPD;
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data)))
            return ret_val;

        /* LPLU and SmartSpeed are mutually exclusive.  LPLU is used during
         * Dx states where the power conservation is most important.  During
         * driver activity we should enable SmartSpeed, so performance is
         * maintained. */
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                         &phy_data)))
            return ret_val;

        phy_data |= IGP01E1000_PSCFR_SMART_SPEED;
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                          phy_data)))
            return ret_val;

    } else if((hw->autoneg_advertised == AUTONEG_ADVERTISE_SPEED_DEFAULT) ||
              (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_ALL ) ||
              (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_100_ALL)) {

        phy_data |= IGP01E1000_GMII_FLEX_SPD;
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data)))
            return ret_val;

        /* When LPLU is enabled we should disable SmartSpeed */
        if((ret_val = em_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                         &phy_data)))
            return ret_val;

        phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
        if((ret_val = em_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
                                          phy_data)))
            return ret_val;

    }
    return E1000_SUCCESS;
}

/******************************************************************************
 * Change VCO speed register to improve Bit Error Rate performance of SERDES.
 *
 * hw - Struct containing variables accessed by shared code
 *****************************************************************************/
static int32_t
em_set_vco_speed(struct em_hw *hw)
{
    int32_t  ret_val;
    uint16_t default_page = 0;
    uint16_t phy_data;

    DEBUGFUNC("em_set_vco_speed");

    switch(hw->mac_type) {
    case em_82545_rev_3:
    case em_82546_rev_3:
       break;
    default:
        return E1000_SUCCESS;
    }

    /* Set PHY register 30, page 5, bit 8 to 0 */

    if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
                                     &default_page)))
        return ret_val;

    if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0005)))
        return ret_val;

    if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data)))
        return ret_val;

    phy_data &= ~M88E1000_PHY_VCO_REG_BIT8;
    if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data)))
        return ret_val;

    /* Set PHY register 30, page 4, bit 11 to 1 */

    if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0004)))
        return ret_val;

    if((ret_val = em_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data)))
        return ret_val;

    phy_data |= M88E1000_PHY_VCO_REG_BIT11;
    if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data)))
        return ret_val;

    if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
                                      default_page)))
        return ret_val;

    return E1000_SUCCESS;
@


1.1.8.2
log
@Merge with the trunk
@
text
@d34 1
a38 5

#ifdef __FreeBSD__
#include <sys/cdefs.h>
__FBSDID("$FreeBSD: if_em_hw.c,v 1.13 2004/02/10 21:31:09 pdeuskar Exp $");
#endif
d145 2
a146 8
        if(hw->mac_type == em_82541 ||
           hw->mac_type == em_82541_rev_2 ||
           hw->mac_type == em_82547 ||
           hw->mac_type == em_82547_rev_2) {
            hw->phy_type = em_phy_igp;
            break;
        }
        /* Fall Through */
d197 1
d1534 2
a1535 2
        if((i == 0) && (hw->phy_type == em_phy_m88)) {
            /* We didn't get link.  Reset the DSP and wait again for link. */
a1581 19
        /* Polarity reversal workaround for forced 10F/10H links. */
        if(hw->mac_type <= em_82544 &&
           (hw->forced_speed_duplex == em_10_full ||
            hw->forced_speed_duplex == em_10_half)) {
            if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
                                              0x0019)))
                return ret_val;
            if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL,
                                              0x8F0F)))
                return ret_val;
            /* IEEE requirement is 150ms */
            msec_delay(200);
            if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
                                              0x0019)))
                return ret_val;
            if((ret_val = em_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL,
                                              0x8F00)))
                return ret_val;
        }
d1965 1
d2045 6
a2050 4
         * partner capability register.  We use the link speed to determine if
         * TBI compatibility needs to be turned on or off.  If the link is not
         * at gigabit speed, then TBI compatibility is not needed.  If we are
         * at gigabit speed, we turn on TBI compatibility.
d2053 10
a2062 5
            uint16_t speed, duplex;
            em_get_speed_and_duplex(hw, &speed, &duplex);
            if(speed != SPEED_1000) {
                /* If link speed is not set to gigabit speed, we do not need
                 * to enable TBI compatibility.
a2129 23

        hw->serdes_link_down = FALSE;
    }
    /* If we force link for non-auto-negotiation switch, check link status
     * based on MAC synchronization for internal serdes media type.
     */
    else if((hw->media_type == em_media_type_internal_serdes) &&
            !(E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
        /* SYNCH bit and IV bit are sticky. */
        usec_delay(10);
        if(E1000_RXCW_SYNCH & E1000_READ_REG(hw, RXCW)) {
            if(!(rxcw & E1000_RXCW_IV)) {
                hw->serdes_link_down = FALSE;
                DEBUGOUT("SERDES: Link is up.\n");
            }
        } else {
            hw->serdes_link_down = TRUE;
            DEBUGOUT("SERDES: Link is down.\n");
        }
    }
    if((hw->media_type == em_media_type_internal_serdes) &&
       (E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
        hw->serdes_link_down = !(E1000_STATUS_LU & E1000_READ_REG(hw, STATUS));
d2530 2
a2531 2
        for(i = 0; i < 640; i++) {
            usec_delay(5);
d3547 1
a3547 1
    if(eeprom->type == em_eeprom_microwire) {
d3549 1
a3549 1
    } else {
a3550 2
        msec_delay(10);
    }
d3768 6
a3773 3
       (E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1))
            hw->perm_mac_addr[5] ^= 0x01;

d3792 2
d3799 6
d3806 2
a3807 1
    em_rar_set(hw, hw->mac_addr, 0);
a3823 1
 * rar_used_count - offset where to start adding mc addresses into the RAR's
d3834 1
a3834 2
                          uint32_t pad,
                          uint32_t rar_used_count)
d3838 1
d4572 2
a4573 2
    unsigned long io_addr = hw->io_base;
    unsigned long io_data = hw->io_base + 4;
d4592 2
a4593 2
    unsigned long io_addr = hw->io_base;
    unsigned long io_data = hw->io_base + 4;
@


1.1.4.1
log
@sync to -current
@
text
@@

