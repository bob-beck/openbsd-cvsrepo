head	1.192;
access;
symbols
	OPENBSD_6_1:1.185.0.4
	OPENBSD_6_1_BASE:1.185
	OPENBSD_6_0:1.169.0.4
	OPENBSD_6_0_BASE:1.169
	OPENBSD_5_9:1.163.0.2
	OPENBSD_5_9_BASE:1.163
	OPENBSD_5_8:1.143.0.4
	OPENBSD_5_8_BASE:1.143
	OPENBSD_5_7:1.140.0.4
	OPENBSD_5_7_BASE:1.140
	OPENBSD_5_6:1.133.0.4
	OPENBSD_5_6_BASE:1.133
	OPENBSD_5_5:1.130.0.4
	OPENBSD_5_5_BASE:1.130
	OPENBSD_5_4:1.120.0.2
	OPENBSD_5_4_BASE:1.120
	OPENBSD_5_3:1.118.0.2
	OPENBSD_5_3_BASE:1.118
	OPENBSD_5_2:1.113.0.4
	OPENBSD_5_2_BASE:1.113
	OPENBSD_5_1_BASE:1.113
	OPENBSD_5_1:1.113.0.2
	OPENBSD_5_0:1.110.0.2
	OPENBSD_5_0_BASE:1.110
	OPENBSD_4_9:1.109.0.2
	OPENBSD_4_9_BASE:1.109
	OPENBSD_4_8:1.100.0.2
	OPENBSD_4_8_BASE:1.100
	OPENBSD_4_7:1.86.0.2
	OPENBSD_4_7_BASE:1.86
	OPENBSD_4_6:1.59.0.4
	OPENBSD_4_6_BASE:1.59
	OPENBSD_4_5:1.47.0.2
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16;
locks; strict;
comment	@ * @;


1.192
date	2017.09.04.09.12.35;	author stsp;	state Exp;
branches;
next	1.191;
commitid	GqG7E7E0KjZPhdPE;

1.191
date	2017.08.13.15.04.47;	author tb;	state Exp;
branches;
next	1.190;
commitid	XLqDn7VQDm7vyYrH;

1.190
date	2017.06.02.11.18.16;	author stsp;	state Exp;
branches;
next	1.189;
commitid	mubZMAWtcGITvIdK;

1.189
date	2017.05.31.16.12.39;	author stsp;	state Exp;
branches;
next	1.188;
commitid	VcrefZBrsDi9WkIu;

1.188
date	2017.05.30.16.21.55;	author stsp;	state Exp;
branches;
next	1.187;
commitid	YqFVqepUvuYbwmvW;

1.187
date	2017.05.30.11.01.38;	author stsp;	state Exp;
branches;
next	1.186;
commitid	ZSlKwh0ELIMDWYIc;

1.186
date	2017.04.26.07.53.17;	author stsp;	state Exp;
branches;
next	1.185;
commitid	K2DWFYV8OTQ53vHY;

1.185
date	2017.03.08.12.02.41;	author mpi;	state Exp;
branches;
next	1.184;
commitid	okVP7pbbXG8IxGgU;

1.184
date	2017.02.20.15.38.04;	author krw;	state Exp;
branches;
next	1.183;
commitid	VrYnXCykMTDcgN5B;

1.183
date	2017.02.16.10.15.12;	author mpi;	state Exp;
branches;
next	1.182;
commitid	NChVcK48FdZeU9j9;

1.182
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.181;
commitid	VyLWTsbepAOk7VQM;

1.181
date	2017.01.12.18.06.57;	author stsp;	state Exp;
branches;
next	1.180;
commitid	j9xl1Hx6fze7kB7x;

1.180
date	2016.12.23.18.44.51;	author kettenis;	state Exp;
branches;
next	1.179;
commitid	0uXR4ucQpYhtKo0H;

1.179
date	2016.12.18.10.37.42;	author stsp;	state Exp;
branches;
next	1.178;
commitid	AFQR1xEK0cL7id30;

1.178
date	2016.12.10.13.22.07;	author stsp;	state Exp;
branches;
next	1.177;
commitid	cF6ma8C1vctNqwbe;

1.177
date	2016.12.07.15.48.44;	author stsp;	state Exp;
branches;
next	1.176;
commitid	1fHfCmgslQH9ejDE;

1.176
date	2016.11.30.10.52.10;	author stsp;	state Exp;
branches;
next	1.175;
commitid	VNiVgiJs7v2eqStb;

1.175
date	2016.10.28.10.11.22;	author stsp;	state Exp;
branches;
next	1.174;
commitid	x6FB9CJ38ppfRIrW;

1.174
date	2016.10.08.14.44.36;	author stsp;	state Exp;
branches;
next	1.173;
commitid	rgA4IKDARzd7NIy4;

1.173
date	2016.10.08.14.35.19;	author stsp;	state Exp;
branches;
next	1.172;
commitid	8DnAIEhgtpERyEYm;

1.172
date	2016.09.05.08.18.18;	author tedu;	state Exp;
branches;
next	1.171;
commitid	mIu2ZXphx8O1xOdL;

1.171
date	2016.09.02.17.10.48;	author stsp;	state Exp;
branches;
next	1.170;
commitid	tU9T3ulYBG6uJf6n;

1.170
date	2016.08.17.09.43.27;	author stsp;	state Exp;
branches;
next	1.169;
commitid	fZb1ChNdOskvOzMd;

1.169
date	2016.07.20.16.24.37;	author stsp;	state Exp;
branches;
next	1.168;
commitid	JrBQo2VdCwg2v9kU;

1.168
date	2016.07.20.10.26.42;	author stsp;	state Exp;
branches;
next	1.167;
commitid	1T7LRuLs66VDPMtf;

1.167
date	2016.06.27.19.01.02;	author stsp;	state Exp;
branches;
next	1.166;
commitid	4kVcRVljAk1fQaUW;

1.166
date	2016.06.03.18.33.37;	author stsp;	state Exp;
branches;
next	1.165;
commitid	AbJjBCDSGPmbYjFx;

1.165
date	2016.04.28.08.28.18;	author stsp;	state Exp;
branches;
next	1.164;
commitid	SP1PldSb3yi4jHiY;

1.164
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.163;
commitid	8YSL8ByWzGeIGBiJ;

1.163
date	2016.02.07.23.56.19;	author tb;	state Exp;
branches;
next	1.162;
commitid	wLqEaZB0NJqQWn6B;

1.162
date	2016.02.05.20.00.20;	author stsp;	state Exp;
branches;
next	1.161;
commitid	6J7uQPHZeHWPf6l3;

1.161
date	2016.02.05.16.09.19;	author stsp;	state Exp;
branches;
next	1.160;
commitid	mPZyiLTTdZAbwkBA;

1.160
date	2016.02.04.21.32.01;	author stsp;	state Exp;
branches;
next	1.159;
commitid	oGzyRy8m3UvbScnq;

1.159
date	2016.02.04.20.38.57;	author stsp;	state Exp;
branches;
next	1.158;
commitid	Ihi8q4DX05e1Xfp6;

1.158
date	2016.01.25.11.27.11;	author stsp;	state Exp;
branches;
next	1.157;
commitid	U9Unyh02TU5iq9jc;

1.157
date	2016.01.13.14.39.35;	author stsp;	state Exp;
branches;
next	1.156;
commitid	4Ztwj6I8oiHVVbGS;

1.156
date	2016.01.13.08.32.19;	author stsp;	state Exp;
branches;
next	1.155;
commitid	JrmFP0glZND1aun6;

1.155
date	2016.01.13.08.26.37;	author stsp;	state Exp;
branches;
next	1.154;
commitid	gUB4p5PhmYDhjqwf;

1.154
date	2016.01.12.10.53.39;	author stsp;	state Exp;
branches;
next	1.153;
commitid	Ssp1HwCmstBptZnk;

1.153
date	2016.01.07.23.08.38;	author stsp;	state Exp;
branches;
next	1.152;
commitid	YQmveOCEh6MqfAJ4;

1.152
date	2016.01.06.19.56.50;	author stsp;	state Exp;
branches;
next	1.151;
commitid	vqkvQcVZc1K7MmHQ;

1.151
date	2016.01.06.09.17.42;	author stsp;	state Exp;
branches;
next	1.150;
commitid	mJhhg7YUHyZ6MVHp;

1.150
date	2016.01.05.18.41.15;	author stsp;	state Exp;
branches;
next	1.149;
commitid	2QagMjdMhQhIaQgu;

1.149
date	2016.01.04.13.54.19;	author stsp;	state Exp;
branches;
next	1.148;
commitid	ry4GqFXRBXnQ5vkR;

1.148
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.147;
commitid	B0kwmVGiD5DVx4kv;

1.147
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.146;
commitid	5DvsamK0GblTp8ww;

1.146
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.145;
commitid	YT6fyIEviv9qwbl6;

1.145
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.144;
commitid	hPF95ClMUQfeqQDX;

1.144
date	2015.09.01.07.09.55;	author deraadt;	state Exp;
branches;
next	1.143;
commitid	VvLv8PeakqoJLqr3;

1.143
date	2015.05.27.22.10.52;	author kettenis;	state Exp;
branches;
next	1.142;
commitid	lWmV3RdleHaEaZ4U;

1.142
date	2015.04.08.09.29.49;	author jasper;	state Exp;
branches;
next	1.141;
commitid	5o9SFndIDde6PFTR;

1.141
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.140;
commitid	p4LJxGKbi0BU2cG6;

1.140
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.139;
commitid	Hly9lJn6CNMylcFu;

1.139
date	2015.02.08.13.45.57;	author stsp;	state Exp;
branches;
next	1.138;
commitid	UTmmiGFqeC1dycjB;

1.138
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.137;
commitid	MyKPm9Q3dQu92BiX;

1.137
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.136;
commitid	yM2VFFhpDTeFQlve;

1.136
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.135;
commitid	LS2TNeCue5R9L67C;

1.135
date	2014.09.10.07.22.09;	author dcoppa;	state Exp;
branches;
next	1.134;
commitid	mGYbIk0VIF0yEbat;

1.134
date	2014.09.09.18.55.08;	author sthen;	state Exp;
branches;
next	1.133;
commitid	8pWlzts5FN03iazF;

1.133
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.132;
commitid	TGHgrLxu6sxZoiFt;

1.132
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.131;
commitid	OBNa5kfxQ2UXoiIw;

1.131
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.130;

1.130
date	2014.02.11.19.44.22;	author kettenis;	state Exp;
branches;
next	1.129;

1.129
date	2014.02.11.19.30.10;	author kettenis;	state Exp;
branches;
next	1.128;

1.128
date	2014.02.10.19.08.58;	author kettenis;	state Exp;
branches;
next	1.127;

1.127
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2013.11.30.19.41.21;	author kettenis;	state Exp;
branches;
next	1.125;

1.125
date	2013.11.14.12.40.00;	author dlg;	state Exp;
branches;
next	1.124;

1.124
date	2013.10.01.20.06.01;	author sf;	state Exp;
branches;
next	1.123;

1.123
date	2013.08.29.19.06.39;	author syl;	state Exp;
branches;
next	1.122;

1.122
date	2013.08.08.23.32.50;	author syl;	state Exp;
branches;
next	1.121;

1.121
date	2013.08.07.01.06.35;	author bluhm;	state Exp;
branches;
next	1.120;

1.120
date	2013.06.11.18.15.52;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2013.05.29.23.16.52;	author yuo;	state Exp;
branches;
next	1.118;

1.118
date	2012.11.17.14.02.51;	author kettenis;	state Exp;
branches;
next	1.117;

1.117
date	2012.11.17.13.57.23;	author kettenis;	state Exp;
branches;
next	1.116;

1.116
date	2012.11.14.12.30.19;	author kettenis;	state Exp;
branches;
next	1.115;

1.115
date	2012.11.11.20.45.31;	author jcs;	state Exp;
branches;
next	1.114;

1.114
date	2012.10.12.19.53.24;	author haesbaert;	state Exp;
branches;
next	1.113;

1.113
date	2012.01.26.00.45.40;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2011.09.02.18.49.36;	author kettenis;	state Exp;
branches;
next	1.111;

1.111
date	2011.09.01.18.49.56;	author kettenis;	state Exp;
branches;
next	1.110;

1.110
date	2011.06.16.19.48.22;	author oga;	state Exp;
branches;
next	1.109;

1.109
date	2011.01.24.18.32.54;	author damien;	state Exp;
branches;
next	1.108;

1.108
date	2011.01.09.15.53.06;	author damien;	state Exp;
branches;
next	1.107;

1.107
date	2011.01.09.15.45.37;	author damien;	state Exp;
branches;
next	1.106;

1.106
date	2010.12.31.19.48.56;	author damien;	state Exp;
branches;
next	1.105;

1.105
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2010.08.27.20.09.01;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.102;

1.102
date	2010.08.12.16.59.29;	author damien;	state Exp;
branches;
next	1.101;

1.101
date	2010.08.12.15.04.00;	author oga;	state Exp;
branches;
next	1.100;

1.100
date	2010.07.28.21.21.38;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2010.07.23.06.43.00;	author phessler;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.20.19.24.31;	author damien;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.05.18.52.47;	author damien;	state Exp;
branches;
next	1.96;

1.96
date	2010.05.13.09.25.03;	author damien;	state Exp;
branches;
next	1.95;

1.95
date	2010.05.07.11.16.04;	author dhill;	state Exp;
branches;
next	1.94;

1.94
date	2010.05.05.19.47.43;	author damien;	state Exp;
branches;
next	1.93;

1.93
date	2010.05.05.19.41.57;	author damien;	state Exp;
branches;
next	1.92;

1.92
date	2010.04.30.16.31.47;	author damien;	state Exp;
branches;
next	1.91;

1.91
date	2010.04.30.16.08.36;	author damien;	state Exp;
branches;
next	1.90;

1.90
date	2010.04.30.16.06.46;	author damien;	state Exp;
branches;
next	1.89;

1.89
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.88;

1.88
date	2010.04.10.08.37.36;	author damien;	state Exp;
branches;
next	1.87;

1.87
date	2010.04.04.08.55.50;	author damien;	state Exp;
branches;
next	1.86;

1.86
date	2010.02.17.18.23.00;	author damien;	state Exp;
branches;
next	1.85;

1.85
date	2010.02.03.17.51.11;	author damien;	state Exp;
branches;
next	1.84;

1.84
date	2010.02.02.17.06.53;	author damien;	state Exp;
branches;
next	1.83;

1.83
date	2010.01.28.16.59.30;	author damien;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.23.09.14.13;	author damien;	state Exp;
branches;
next	1.81;

1.81
date	2010.01.16.12.48.58;	author damien;	state Exp;
branches;
next	1.80;

1.80
date	2010.01.16.12.42.17;	author damien;	state Exp;
branches;
next	1.79;

1.79
date	2010.01.09.12.53.32;	author damien;	state Exp;
branches;
next	1.78;

1.78
date	2009.11.08.11.54.48;	author damien;	state Exp;
branches;
next	1.77;

1.77
date	2009.11.04.17.46.52;	author damien;	state Exp;
branches;
next	1.76;

1.76
date	2009.11.03.18.57.18;	author damien;	state Exp;
branches;
next	1.75;

1.75
date	2009.11.03.18.55.23;	author damien;	state Exp;
branches;
next	1.74;

1.74
date	2009.11.01.12.01.16;	author damien;	state Exp;
branches;
next	1.73;

1.73
date	2009.10.31.11.52.07;	author damien;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.28.18.42.47;	author damien;	state Exp;
branches;
next	1.71;

1.71
date	2009.10.26.18.38.32;	author damien;	state Exp;
branches;
next	1.70;

1.70
date	2009.10.26.17.55.29;	author damien;	state Exp;
branches;
next	1.69;

1.69
date	2009.10.24.20.17.17;	author damien;	state Exp;
branches;
next	1.68;

1.68
date	2009.10.24.19.00.40;	author damien;	state Exp;
branches;
next	1.67;

1.67
date	2009.10.24.18.32.37;	author damien;	state Exp;
branches;
next	1.66;

1.66
date	2009.10.24.18.14.57;	author damien;	state Exp;
branches;
next	1.65;

1.65
date	2009.10.24.18.06.16;	author damien;	state Exp;
branches;
next	1.64;

1.64
date	2009.10.24.17.51.34;	author damien;	state Exp;
branches;
next	1.63;

1.63
date	2009.09.20.20.04.07;	author damien;	state Exp;
branches;
next	1.62;

1.62
date	2009.08.10.17.21.15;	author damien;	state Exp;
branches;
next	1.61;

1.61
date	2009.08.09.11.40.56;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2009.07.10.07.44.04;	author blambert;	state Exp;
branches;
next	1.59;

1.59
date	2009.06.02.16.28.21;	author damien;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.02.16.24.40;	author damien;	state Exp;
branches;
next	1.57;

1.57
date	2009.05.29.08.25.45;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2009.05.28.16.03.23;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2009.05.27.09.50.31;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2009.05.20.16.31.50;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2009.05.12.19.10.57;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2009.05.11.19.36.00;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2009.05.11.19.28.02;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2009.04.26.02.20.58;	author cnst;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.10.20.39.21;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2009.02.15.08.58.22;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.26.19.18.52;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2008.12.22.18.20.47;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.21.18.19.58;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.12.17.15.40;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.03.17.17.08;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.02.17.17.50;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.25.22.20.11;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.25.21.43.57;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.25.17.06.27;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.22.08.23.52;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.21.17.17.05;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.19.18.52.53;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2008.11.16.09.52.31;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2008.11.16.09.50.02;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2008.11.09.10.00.17;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2008.11.08.18.42.50;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.08.17.15.54;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2008.11.08.12.27.57;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2008.11.08.11.05.36;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2008.11.06.17.04.55;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.03.17.19.54;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2008.10.22.06.25.07;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2008.10.13.16.37.10;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2008.07.31.20.14.17;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.16.18.43.06;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2008.04.27.19.01.59;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.08.16.24.44;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.30.19.19.47;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.27.19.45.44;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.19.19.35.43;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.19.19.34.25;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.17.18.50.54;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.03.13.10.29;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.11.18.53.34;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.10.20.36.49;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.10.18.14.55;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.10.17.55.48;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.07.20.02.54;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.07.19.32.09;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.06.19.33.20;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.06.16.51.49;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.06.16.37.03;	author damien;	state Exp;
branches;
next	;


desc
@@


1.192
log
@Make sure iwn(4) firmware gets to see a beacon before we send an auth request.
Otherwise, the Tx attempt can fail due to the firmware's built-in regulatory
domain enforcement.

Because this code runs in interrrupt context we use a DELAY(). It's currently
set to 3 times the beacon interval. This is a bit long as far as DELAYs go,
but since this driver runs state transitions in interrupt context there is
no better way for now. Lower delays weren't reliable enough in my testing.

Makes association work reliably for me on 5GHz. My original plan was to only
add this hack for 5GHz but Holger Mikolon reported that it also helps on 2GHz
channels with regulatory restrictions (e.g. 13), so do it always.

ok mpi@@
@
text
@/*	$OpenBSD: if_iwn.c,v 1.191 2017/08/13 15:04:47 tb Exp $	*/

/*-
 * Copyright (c) 2007-2010 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Intel WiFi Link 4965 and 1000/5000/6000 Series 802.11 network
 * adapters.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/task.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_mira.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/pci/if_iwnreg.h>
#include <dev/pci/if_iwnvar.h>

static const struct pci_matchid iwn_devices[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_4965_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_4965_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_5100_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_5100_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_5150_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_5150_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_5300_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_5300_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_5350_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_5350_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_1000_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_1000_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6300_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6300_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6200_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6200_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6050_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6050_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6005_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6005_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6030_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6030_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_1030_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_1030_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_100_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_100_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_130_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_130_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6235_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6235_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_2230_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_2230_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_2200_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_2200_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_135_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_135_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_105_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_105_2 },
};

int		iwn_match(struct device *, void *, void *);
void		iwn_attach(struct device *, struct device *, void *);
int		iwn4965_attach(struct iwn_softc *, pci_product_id_t);
int		iwn5000_attach(struct iwn_softc *, pci_product_id_t);
#if NBPFILTER > 0
void		iwn_radiotap_attach(struct iwn_softc *);
#endif
int		iwn_detach(struct device *, int);
int		iwn_activate(struct device *, int);
void		iwn_wakeup(struct iwn_softc *);
void		iwn_init_task(void *);
int		iwn_nic_lock(struct iwn_softc *);
int		iwn_eeprom_lock(struct iwn_softc *);
int		iwn_init_otprom(struct iwn_softc *);
int		iwn_read_prom_data(struct iwn_softc *, uint32_t, void *, int);
int		iwn_dma_contig_alloc(bus_dma_tag_t, struct iwn_dma_info *,
		    void **, bus_size_t, bus_size_t);
void		iwn_dma_contig_free(struct iwn_dma_info *);
int		iwn_alloc_sched(struct iwn_softc *);
void		iwn_free_sched(struct iwn_softc *);
int		iwn_alloc_kw(struct iwn_softc *);
void		iwn_free_kw(struct iwn_softc *);
int		iwn_alloc_ict(struct iwn_softc *);
void		iwn_free_ict(struct iwn_softc *);
int		iwn_alloc_fwmem(struct iwn_softc *);
void		iwn_free_fwmem(struct iwn_softc *);
int		iwn_alloc_rx_ring(struct iwn_softc *, struct iwn_rx_ring *);
void		iwn_reset_rx_ring(struct iwn_softc *, struct iwn_rx_ring *);
void		iwn_free_rx_ring(struct iwn_softc *, struct iwn_rx_ring *);
int		iwn_alloc_tx_ring(struct iwn_softc *, struct iwn_tx_ring *,
		    int);
void		iwn_reset_tx_ring(struct iwn_softc *, struct iwn_tx_ring *);
void		iwn_free_tx_ring(struct iwn_softc *, struct iwn_tx_ring *);
void		iwn5000_ict_reset(struct iwn_softc *);
int		iwn_read_eeprom(struct iwn_softc *);
void		iwn4965_read_eeprom(struct iwn_softc *);
void		iwn4965_print_power_group(struct iwn_softc *, int);
void		iwn5000_read_eeprom(struct iwn_softc *);
void		iwn_read_eeprom_channels(struct iwn_softc *, int, uint32_t);
void		iwn_read_eeprom_enhinfo(struct iwn_softc *);
struct		ieee80211_node *iwn_node_alloc(struct ieee80211com *);
void		iwn_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
int		iwn_media_change(struct ifnet *);
int		iwn_newstate(struct ieee80211com *, enum ieee80211_state, int);
void		iwn_iter_func(void *, struct ieee80211_node *);
void		iwn_calib_timeout(void *);
int		iwn_ccmp_decap(struct iwn_softc *, struct mbuf *,
		    struct ieee80211_node *);
void		iwn_rx_phy(struct iwn_softc *, struct iwn_rx_desc *,
		    struct iwn_rx_data *);
void		iwn_rx_done(struct iwn_softc *, struct iwn_rx_desc *,
		    struct iwn_rx_data *);
void		iwn_rx_compressed_ba(struct iwn_softc *, struct iwn_rx_desc *,
		    struct iwn_rx_data *);
void		iwn5000_rx_calib_results(struct iwn_softc *,
		    struct iwn_rx_desc *, struct iwn_rx_data *);
void		iwn_rx_statistics(struct iwn_softc *, struct iwn_rx_desc *,
		    struct iwn_rx_data *);
void		iwn4965_tx_done(struct iwn_softc *, struct iwn_rx_desc *,
		    struct iwn_rx_data *);
void		iwn5000_tx_done(struct iwn_softc *, struct iwn_rx_desc *,
		    struct iwn_rx_data *);
void		iwn_tx_done(struct iwn_softc *, struct iwn_rx_desc *,
		    uint8_t, uint8_t, uint8_t, uint16_t);
void		iwn_cmd_done(struct iwn_softc *, struct iwn_rx_desc *);
void		iwn_notif_intr(struct iwn_softc *);
void		iwn_wakeup_intr(struct iwn_softc *);
void		iwn_fatal_intr(struct iwn_softc *);
int		iwn_intr(void *);
void		iwn4965_update_sched(struct iwn_softc *, int, int, uint8_t,
		    uint16_t);
void		iwn5000_update_sched(struct iwn_softc *, int, int, uint8_t,
		    uint16_t);
void		iwn5000_reset_sched(struct iwn_softc *, int, int);
int		iwn_tx(struct iwn_softc *, struct mbuf *,
		    struct ieee80211_node *);
int		iwn_rval2ridx(int);
void		iwn_start(struct ifnet *);
void		iwn_watchdog(struct ifnet *);
int		iwn_ioctl(struct ifnet *, u_long, caddr_t);
int		iwn_cmd(struct iwn_softc *, int, const void *, int, int);
int		iwn4965_add_node(struct iwn_softc *, struct iwn_node_info *,
		    int);
int		iwn5000_add_node(struct iwn_softc *, struct iwn_node_info *,
		    int);
int		iwn_set_link_quality(struct iwn_softc *,
		    struct ieee80211_node *);
int		iwn_add_broadcast_node(struct iwn_softc *, int, int);
void		iwn_updateedca(struct ieee80211com *);
void		iwn_set_led(struct iwn_softc *, uint8_t, uint8_t, uint8_t);
int		iwn_set_critical_temp(struct iwn_softc *);
int		iwn_set_timing(struct iwn_softc *, struct ieee80211_node *);
void		iwn4965_power_calibration(struct iwn_softc *, int);
int		iwn4965_set_txpower(struct iwn_softc *, int);
int		iwn5000_set_txpower(struct iwn_softc *, int);
int		iwn4965_get_rssi(const struct iwn_rx_stat *);
int		iwn5000_get_rssi(const struct iwn_rx_stat *);
int		iwn_get_noise(const struct iwn_rx_general_stats *);
int		iwn4965_get_temperature(struct iwn_softc *);
int		iwn5000_get_temperature(struct iwn_softc *);
int		iwn_init_sensitivity(struct iwn_softc *);
void		iwn_collect_noise(struct iwn_softc *,
		    const struct iwn_rx_general_stats *);
int		iwn4965_init_gains(struct iwn_softc *);
int		iwn5000_init_gains(struct iwn_softc *);
int		iwn4965_set_gains(struct iwn_softc *);
int		iwn5000_set_gains(struct iwn_softc *);
void		iwn_tune_sensitivity(struct iwn_softc *,
		    const struct iwn_rx_stats *);
int		iwn_send_sensitivity(struct iwn_softc *);
int		iwn_set_pslevel(struct iwn_softc *, int, int, int);
int		iwn_send_temperature_offset(struct iwn_softc *);
int		iwn_send_btcoex(struct iwn_softc *);
int		iwn_send_advanced_btcoex(struct iwn_softc *);
int		iwn5000_runtime_calib(struct iwn_softc *);
int		iwn_config(struct iwn_softc *);
uint16_t	iwn_get_active_dwell_time(struct iwn_softc *, uint16_t, uint8_t);
uint16_t	iwn_limit_dwell(struct iwn_softc *, uint16_t);
uint16_t	iwn_get_passive_dwell_time(struct iwn_softc *, uint16_t);
int		iwn_scan(struct iwn_softc *, uint16_t);
int		iwn_auth(struct iwn_softc *);
int		iwn_run(struct iwn_softc *);
int		iwn_set_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
void		iwn_delete_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
void		iwn_update_htprot(struct ieee80211com *,
		    struct ieee80211_node *);
int		iwn_ampdu_rx_start(struct ieee80211com *,
		    struct ieee80211_node *, uint8_t);
void		iwn_ampdu_rx_stop(struct ieee80211com *,
		    struct ieee80211_node *, uint8_t);
int		iwn_ampdu_tx_start(struct ieee80211com *,
		    struct ieee80211_node *, uint8_t);
void		iwn_ampdu_tx_stop(struct ieee80211com *,
		    struct ieee80211_node *, uint8_t);
void		iwn4965_ampdu_tx_start(struct iwn_softc *,
		    struct ieee80211_node *, uint8_t, uint16_t);
void		iwn4965_ampdu_tx_stop(struct iwn_softc *,
		    uint8_t, uint16_t);
void		iwn5000_ampdu_tx_start(struct iwn_softc *,
		    struct ieee80211_node *, uint8_t, uint16_t);
void		iwn5000_ampdu_tx_stop(struct iwn_softc *,
		    uint8_t, uint16_t);
int		iwn5000_query_calibration(struct iwn_softc *);
int		iwn5000_send_calibration(struct iwn_softc *);
int		iwn5000_send_wimax_coex(struct iwn_softc *);
int		iwn5000_crystal_calib(struct iwn_softc *);
int		iwn6000_temp_offset_calib(struct iwn_softc *);
int		iwn2000_temp_offset_calib(struct iwn_softc *);
int		iwn4965_post_alive(struct iwn_softc *);
int		iwn5000_post_alive(struct iwn_softc *);
int		iwn4965_load_bootcode(struct iwn_softc *, const uint8_t *,
		    int);
int		iwn4965_load_firmware(struct iwn_softc *);
int		iwn5000_load_firmware_section(struct iwn_softc *, uint32_t,
		    const uint8_t *, int);
int		iwn5000_load_firmware(struct iwn_softc *);
int		iwn_read_firmware_leg(struct iwn_softc *,
		    struct iwn_fw_info *);
int		iwn_read_firmware_tlv(struct iwn_softc *,
		    struct iwn_fw_info *, uint16_t);
int		iwn_read_firmware(struct iwn_softc *);
int		iwn_clock_wait(struct iwn_softc *);
int		iwn_apm_init(struct iwn_softc *);
void		iwn_apm_stop_master(struct iwn_softc *);
void		iwn_apm_stop(struct iwn_softc *);
int		iwn4965_nic_config(struct iwn_softc *);
int		iwn5000_nic_config(struct iwn_softc *);
int		iwn_hw_prepare(struct iwn_softc *);
int		iwn_hw_init(struct iwn_softc *);
void		iwn_hw_stop(struct iwn_softc *);
int		iwn_init(struct ifnet *);
void		iwn_stop(struct ifnet *, int);

#ifdef IWN_DEBUG
#define DPRINTF(x)	do { if (iwn_debug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (iwn_debug >= (n)) printf x; } while (0)
int iwn_debug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

struct cfdriver iwn_cd = {
	NULL, "iwn", DV_IFNET
};

struct cfattach iwn_ca = {
	sizeof (struct iwn_softc), iwn_match, iwn_attach, iwn_detach,
	iwn_activate
};

int
iwn_match(struct device *parent, void *match, void *aux)
{
	return pci_matchbyid((struct pci_attach_args *)aux, iwn_devices,
	    nitems(iwn_devices));
}

void
iwn_attach(struct device *parent, struct device *self, void *aux)
{
	struct iwn_softc *sc = (struct iwn_softc *)self;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct pci_attach_args *pa = aux;
	const char *intrstr;
	pci_intr_handle_t ih;
	pcireg_t memtype, reg;
	int i, error;

	sc->sc_pct = pa->pa_pc;
	sc->sc_pcitag = pa->pa_tag;
	sc->sc_dmat = pa->pa_dmat;

	/*
	 * Get the offset of the PCI Express Capability Structure in PCI
	 * Configuration Space.
	 */
	error = pci_get_capability(sc->sc_pct, sc->sc_pcitag,
	    PCI_CAP_PCIEXPRESS, &sc->sc_cap_off, NULL);
	if (error == 0) {
		printf(": PCIe capability structure not found!\n");
		return;
	}

	/* Clear device-specific "PCI retry timeout" register (41h). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	if (reg & 0xff00)
		pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, reg & ~0xff00);

	/* Hardware bug workaround. */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, PCI_COMMAND_STATUS_REG);
	if (reg & PCI_COMMAND_INTERRUPT_DISABLE) {
		DPRINTF(("PCIe INTx Disable set\n"));
		reg &= ~PCI_COMMAND_INTERRUPT_DISABLE;
		pci_conf_write(sc->sc_pct, sc->sc_pcitag,
		    PCI_COMMAND_STATUS_REG, reg);
	}

	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, IWN_PCI_BAR0);
	error = pci_mapreg_map(pa, IWN_PCI_BAR0, memtype, 0, &sc->sc_st,
	    &sc->sc_sh, NULL, &sc->sc_sz, 0);
	if (error != 0) {
		printf(": can't map mem space\n");
		return;
	}

	/* Install interrupt handler. */
	if (pci_intr_map_msi(pa, &ih) != 0 && pci_intr_map(pa, &ih) != 0) {
		printf(": can't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(sc->sc_pct, ih);
	sc->sc_ih = pci_intr_establish(sc->sc_pct, ih, IPL_NET, iwn_intr, sc,
	    sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s", intrstr);

	/* Read hardware revision and attach. */
	sc->hw_type = (IWN_READ(sc, IWN_HW_REV) >> 4) & 0x1f;
	if (sc->hw_type == IWN_HW_REV_TYPE_4965)
		error = iwn4965_attach(sc, PCI_PRODUCT(pa->pa_id));
	else
		error = iwn5000_attach(sc, PCI_PRODUCT(pa->pa_id));
	if (error != 0) {
		printf(": could not attach device\n");
		return;
	}

	if ((error = iwn_hw_prepare(sc)) != 0) {
		printf(": hardware not ready\n");
		return;
	}

	/* Read MAC address, channels, etc from EEPROM. */
	if ((error = iwn_read_eeprom(sc)) != 0) {
		printf(": could not read EEPROM\n");
		return;
	}

	/* Allocate DMA memory for firmware transfers. */
	if ((error = iwn_alloc_fwmem(sc)) != 0) {
		printf(": could not allocate memory for firmware\n");
		return;
	}

	/* Allocate "Keep Warm" page. */
	if ((error = iwn_alloc_kw(sc)) != 0) {
		printf(": could not allocate keep warm page\n");
		goto fail1;
	}

	/* Allocate ICT table for 5000 Series. */
	if (sc->hw_type != IWN_HW_REV_TYPE_4965 &&
	    (error = iwn_alloc_ict(sc)) != 0) {
		printf(": could not allocate ICT table\n");
		goto fail2;
	}

	/* Allocate TX scheduler "rings". */
	if ((error = iwn_alloc_sched(sc)) != 0) {
		printf(": could not allocate TX scheduler rings\n");
		goto fail3;
	}

	/* Allocate TX rings (16 on 4965AGN, 20 on >=5000). */
	for (i = 0; i < sc->ntxqs; i++) {
		if ((error = iwn_alloc_tx_ring(sc, &sc->txq[i], i)) != 0) {
			printf(": could not allocate TX ring %d\n", i);
			goto fail4;
		}
	}

	/* Allocate RX ring. */
	if ((error = iwn_alloc_rx_ring(sc, &sc->rxq)) != 0) {
		printf(": could not allocate RX ring\n");
		goto fail4;
	}

	/* Clear pending interrupts. */
	IWN_WRITE(sc, IWN_INT, 0xffffffff);

	/* Count the number of available chains. */
	sc->ntxchains =
	    ((sc->txchainmask >> 2) & 1) +
	    ((sc->txchainmask >> 1) & 1) +
	    ((sc->txchainmask >> 0) & 1);
	sc->nrxchains =
	    ((sc->rxchainmask >> 2) & 1) +
	    ((sc->rxchainmask >> 1) & 1) +
	    ((sc->rxchainmask >> 0) & 1);
	printf(", MIMO %dT%dR, %.4s, address %s\n", sc->ntxchains,
	    sc->nrxchains, sc->eeprom_domain, ether_sprintf(ic->ic_myaddr));

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* Set device capabilities. */
	ic->ic_caps =
	    IEEE80211_C_WEP |		/* WEP */
	    IEEE80211_C_RSN |		/* WPA/RSN */
	    IEEE80211_C_SCANALL |	/* device scans all channels at once */
	    IEEE80211_C_SCANALLBAND |	/* driver scans all bands at once */
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_PMGT;		/* power saving supported */

	/* No optional HT features supported for now, */
	ic->ic_htcaps = 0;
	ic->ic_htxcaps = 0;
	ic->ic_txbfcaps = 0;
	ic->ic_aselcaps = 0;
	ic->ic_ampdu_params = (IEEE80211_AMPDU_PARAM_SS_4 | 0x3 /* 64k */);
	if (sc->sc_flags & IWN_FLAG_HAS_11N) {
		/* Set HT capabilities. */
		ic->ic_htcaps = IEEE80211_HTCAP_SGI20;
#ifdef notyet
		ic->ic_htcaps |=
#if IWN_RBUF_SIZE == 8192
		    IEEE80211_HTCAP_AMSDU7935 |
#endif
		    IEEE80211_HTCAP_CBW20_40 |
		    IEEE80211_HTCAP_SGI40;
		if (sc->hw_type != IWN_HW_REV_TYPE_4965)
			ic->ic_htcaps |= IEEE80211_HTCAP_GF;
		if (sc->hw_type == IWN_HW_REV_TYPE_6050)
			ic->ic_htcaps |= IEEE80211_HTCAP_SMPS_DYN;
		else
			ic->ic_htcaps |= IEEE80211_HTCAP_SMPS_DIS;
#endif	/* notyet */
	}

	/* Set supported legacy rates. */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;
	if (sc->sc_flags & IWN_FLAG_HAS_5GHZ) {
		ic->ic_sup_rates[IEEE80211_MODE_11A] =
		    ieee80211_std_rateset_11a;
	}
	if (sc->sc_flags & IWN_FLAG_HAS_11N) {
		/* Set supported HT rates. */
		ic->ic_sup_mcs[0] = 0xff;		/* MCS 0-7 */
#ifdef notyet
		if (sc->nrxchains > 1)
			ic->ic_sup_mcs[1] = 0xff;	/* MCS 8-15 */
		if (sc->nrxchains > 2)
			ic->ic_sup_mcs[2] = 0xff;	/* MCS 16-23 */
#endif
	}

	/* IBSS channel undefined for now. */
	ic->ic_ibss_chan = &ic->ic_channels[0];

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = iwn_ioctl;
	ifp->if_start = iwn_start;
	ifp->if_watchdog = iwn_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_node_alloc = iwn_node_alloc;
	ic->ic_newassoc = iwn_newassoc;
	ic->ic_updateedca = iwn_updateedca;
	ic->ic_set_key = iwn_set_key;
	ic->ic_delete_key = iwn_delete_key;
	ic->ic_update_htprot = iwn_update_htprot;
	ic->ic_ampdu_rx_start = iwn_ampdu_rx_start;
	ic->ic_ampdu_rx_stop = iwn_ampdu_rx_stop;
#ifdef notyet
	ic->ic_ampdu_tx_start = iwn_ampdu_tx_start;
	ic->ic_ampdu_tx_stop = iwn_ampdu_tx_stop;
#endif

	/* Override 802.11 state transition machine. */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = iwn_newstate;
	ieee80211_media_init(ifp, iwn_media_change, ieee80211_media_status);

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 15;

#if NBPFILTER > 0
	iwn_radiotap_attach(sc);
#endif
	timeout_set(&sc->calib_to, iwn_calib_timeout, sc);
	rw_init(&sc->sc_rwlock, "iwnlock");
	task_set(&sc->init_task, iwn_init_task, sc);
	return;

	/* Free allocated memory if something failed during attachment. */
fail4:	while (--i >= 0)
		iwn_free_tx_ring(sc, &sc->txq[i]);
	iwn_free_sched(sc);
fail3:	if (sc->ict != NULL)
		iwn_free_ict(sc);
fail2:	iwn_free_kw(sc);
fail1:	iwn_free_fwmem(sc);
}

int
iwn4965_attach(struct iwn_softc *sc, pci_product_id_t pid)
{
	struct iwn_ops *ops = &sc->ops;

	ops->load_firmware = iwn4965_load_firmware;
	ops->read_eeprom = iwn4965_read_eeprom;
	ops->post_alive = iwn4965_post_alive;
	ops->nic_config = iwn4965_nic_config;
	ops->update_sched = iwn4965_update_sched;
	ops->get_temperature = iwn4965_get_temperature;
	ops->get_rssi = iwn4965_get_rssi;
	ops->set_txpower = iwn4965_set_txpower;
	ops->init_gains = iwn4965_init_gains;
	ops->set_gains = iwn4965_set_gains;
	ops->add_node = iwn4965_add_node;
	ops->tx_done = iwn4965_tx_done;
	ops->ampdu_tx_start = iwn4965_ampdu_tx_start;
	ops->ampdu_tx_stop = iwn4965_ampdu_tx_stop;
	sc->ntxqs = IWN4965_NTXQUEUES;
	sc->ndmachnls = IWN4965_NDMACHNLS;
	sc->broadcast_id = IWN4965_ID_BROADCAST;
	sc->rxonsz = IWN4965_RXONSZ;
	sc->schedsz = IWN4965_SCHEDSZ;
	sc->fw_text_maxsz = IWN4965_FW_TEXT_MAXSZ;
	sc->fw_data_maxsz = IWN4965_FW_DATA_MAXSZ;
	sc->fwsz = IWN4965_FWSZ;
	sc->sched_txfact_addr = IWN4965_SCHED_TXFACT;
	sc->limits = &iwn4965_sensitivity_limits;
	sc->fwname = "iwn-4965";
	/* Override chains masks, ROM is known to be broken. */
	sc->txchainmask = IWN_ANT_AB;
	sc->rxchainmask = IWN_ANT_ABC;

	return 0;
}

int
iwn5000_attach(struct iwn_softc *sc, pci_product_id_t pid)
{
	struct iwn_ops *ops = &sc->ops;

	ops->load_firmware = iwn5000_load_firmware;
	ops->read_eeprom = iwn5000_read_eeprom;
	ops->post_alive = iwn5000_post_alive;
	ops->nic_config = iwn5000_nic_config;
	ops->update_sched = iwn5000_update_sched;
	ops->get_temperature = iwn5000_get_temperature;
	ops->get_rssi = iwn5000_get_rssi;
	ops->set_txpower = iwn5000_set_txpower;
	ops->init_gains = iwn5000_init_gains;
	ops->set_gains = iwn5000_set_gains;
	ops->add_node = iwn5000_add_node;
	ops->tx_done = iwn5000_tx_done;
	ops->ampdu_tx_start = iwn5000_ampdu_tx_start;
	ops->ampdu_tx_stop = iwn5000_ampdu_tx_stop;
	sc->ntxqs = IWN5000_NTXQUEUES;
	sc->ndmachnls = IWN5000_NDMACHNLS;
	sc->broadcast_id = IWN5000_ID_BROADCAST;
	sc->rxonsz = IWN5000_RXONSZ;
	sc->schedsz = IWN5000_SCHEDSZ;
	sc->fw_text_maxsz = IWN5000_FW_TEXT_MAXSZ;
	sc->fw_data_maxsz = IWN5000_FW_DATA_MAXSZ;
	sc->fwsz = IWN5000_FWSZ;
	sc->sched_txfact_addr = IWN5000_SCHED_TXFACT;

	switch (sc->hw_type) {
	case IWN_HW_REV_TYPE_5100:
		sc->limits = &iwn5000_sensitivity_limits;
		sc->fwname = "iwn-5000";
		/* Override chains masks, ROM is known to be broken. */
		sc->txchainmask = IWN_ANT_B;
		sc->rxchainmask = IWN_ANT_AB;
		break;
	case IWN_HW_REV_TYPE_5150:
		sc->limits = &iwn5150_sensitivity_limits;
		sc->fwname = "iwn-5150";
		break;
	case IWN_HW_REV_TYPE_5300:
	case IWN_HW_REV_TYPE_5350:
		sc->limits = &iwn5000_sensitivity_limits;
		sc->fwname = "iwn-5000";
		break;
	case IWN_HW_REV_TYPE_1000:
		sc->limits = &iwn1000_sensitivity_limits;
		sc->fwname = "iwn-1000";
		break;
	case IWN_HW_REV_TYPE_6000:
		sc->limits = &iwn6000_sensitivity_limits;
		sc->fwname = "iwn-6000";
		if (pid == PCI_PRODUCT_INTEL_WL_6200_1 ||
		    pid == PCI_PRODUCT_INTEL_WL_6200_2) {
			sc->sc_flags |= IWN_FLAG_INTERNAL_PA;
			/* Override chains masks, ROM is known to be broken. */
			sc->txchainmask = IWN_ANT_BC;
			sc->rxchainmask = IWN_ANT_BC;
		}
		break;
	case IWN_HW_REV_TYPE_6050:
		sc->limits = &iwn6000_sensitivity_limits;
		sc->fwname = "iwn-6050";
		break;
	case IWN_HW_REV_TYPE_6005:
		sc->limits = &iwn6000_sensitivity_limits;
		if (pid != PCI_PRODUCT_INTEL_WL_6005_1 &&
		    pid != PCI_PRODUCT_INTEL_WL_6005_2) {
			sc->fwname = "iwn-6030";
			sc->sc_flags |= IWN_FLAG_ADV_BT_COEX;
		} else
			sc->fwname = "iwn-6005";
		break;
	case IWN_HW_REV_TYPE_2030:
		sc->limits = &iwn2000_sensitivity_limits;
		sc->fwname = "iwn-2030";
		sc->sc_flags |= IWN_FLAG_ADV_BT_COEX;
		break;
	case IWN_HW_REV_TYPE_2000:
		sc->limits = &iwn2000_sensitivity_limits;
		sc->fwname = "iwn-2000";
		break;
	case IWN_HW_REV_TYPE_135:
		sc->limits = &iwn2000_sensitivity_limits;
		sc->fwname = "iwn-135";
		sc->sc_flags |= IWN_FLAG_ADV_BT_COEX;
		break;
	case IWN_HW_REV_TYPE_105:
		sc->limits = &iwn2000_sensitivity_limits;
		sc->fwname = "iwn-105";
		break;
	default:
		printf(": adapter type %d not supported\n", sc->hw_type);
		return ENOTSUP;
	}
	return 0;
}

#if NBPFILTER > 0
/*
 * Attach the interface to 802.11 radiotap.
 */
void
iwn_radiotap_attach(struct iwn_softc *sc)
{
	bpfattach(&sc->sc_drvbpf, &sc->sc_ic.ic_if, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(IWN_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(IWN_TX_RADIOTAP_PRESENT);
}
#endif

int
iwn_detach(struct device *self, int flags)
{
	struct iwn_softc *sc = (struct iwn_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int qid;

	timeout_del(&sc->calib_to);
	task_del(systq, &sc->init_task);

	/* Uninstall interrupt handler. */
	if (sc->sc_ih != NULL)
		pci_intr_disestablish(sc->sc_pct, sc->sc_ih);

	/* Free DMA resources. */
	iwn_free_rx_ring(sc, &sc->rxq);
	for (qid = 0; qid < sc->ntxqs; qid++)
		iwn_free_tx_ring(sc, &sc->txq[qid]);
	iwn_free_sched(sc);
	iwn_free_kw(sc);
	if (sc->ict != NULL)
		iwn_free_ict(sc);
	iwn_free_fwmem(sc);

	bus_space_unmap(sc->sc_st, sc->sc_sh, sc->sc_sz);

	ieee80211_ifdetach(ifp);
	if_detach(ifp);

	return 0;
}

int
iwn_activate(struct device *self, int act)
{
	struct iwn_softc *sc = (struct iwn_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			iwn_stop(ifp, 0);
		break;
	case DVACT_WAKEUP:
		iwn_wakeup(sc);
		break;
	}

	return 0;
}

void
iwn_wakeup(struct iwn_softc *sc)
{
	pcireg_t reg;

	/* Clear device-specific "PCI retry timeout" register (41h). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	if (reg & 0xff00)
		pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, reg & ~0xff00);
	iwn_init_task(sc);
}

void
iwn_init_task(void *arg1)
{
	struct iwn_softc *sc = arg1;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	rw_enter_write(&sc->sc_rwlock);
	s = splnet();

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == IFF_UP)
		iwn_init(ifp);

	splx(s);
	rw_exit_write(&sc->sc_rwlock);
}

int
iwn_nic_lock(struct iwn_softc *sc)
{
	int ntries;

	/* Request exclusive access to NIC. */
	IWN_SETBITS(sc, IWN_GP_CNTRL, IWN_GP_CNTRL_MAC_ACCESS_REQ);

	/* Spin until we actually get the lock. */
	for (ntries = 0; ntries < 1000; ntries++) {
		if ((IWN_READ(sc, IWN_GP_CNTRL) &
		     (IWN_GP_CNTRL_MAC_ACCESS_ENA | IWN_GP_CNTRL_SLEEP)) ==
		    IWN_GP_CNTRL_MAC_ACCESS_ENA)
			return 0;
		DELAY(10);
	}
	return ETIMEDOUT;
}

static __inline void
iwn_nic_unlock(struct iwn_softc *sc)
{
	IWN_CLRBITS(sc, IWN_GP_CNTRL, IWN_GP_CNTRL_MAC_ACCESS_REQ);
}

static __inline uint32_t
iwn_prph_read(struct iwn_softc *sc, uint32_t addr)
{
	IWN_WRITE(sc, IWN_PRPH_RADDR, IWN_PRPH_DWORD | addr);
	IWN_BARRIER_READ_WRITE(sc);
	return IWN_READ(sc, IWN_PRPH_RDATA);
}

static __inline void
iwn_prph_write(struct iwn_softc *sc, uint32_t addr, uint32_t data)
{
	IWN_WRITE(sc, IWN_PRPH_WADDR, IWN_PRPH_DWORD | addr);
	IWN_BARRIER_WRITE(sc);
	IWN_WRITE(sc, IWN_PRPH_WDATA, data);
}

static __inline void
iwn_prph_setbits(struct iwn_softc *sc, uint32_t addr, uint32_t mask)
{
	iwn_prph_write(sc, addr, iwn_prph_read(sc, addr) | mask);
}

static __inline void
iwn_prph_clrbits(struct iwn_softc *sc, uint32_t addr, uint32_t mask)
{
	iwn_prph_write(sc, addr, iwn_prph_read(sc, addr) & ~mask);
}

static __inline void
iwn_prph_write_region_4(struct iwn_softc *sc, uint32_t addr,
    const uint32_t *data, int count)
{
	for (; count > 0; count--, data++, addr += 4)
		iwn_prph_write(sc, addr, *data);
}

static __inline uint32_t
iwn_mem_read(struct iwn_softc *sc, uint32_t addr)
{
	IWN_WRITE(sc, IWN_MEM_RADDR, addr);
	IWN_BARRIER_READ_WRITE(sc);
	return IWN_READ(sc, IWN_MEM_RDATA);
}

static __inline void
iwn_mem_write(struct iwn_softc *sc, uint32_t addr, uint32_t data)
{
	IWN_WRITE(sc, IWN_MEM_WADDR, addr);
	IWN_BARRIER_WRITE(sc);
	IWN_WRITE(sc, IWN_MEM_WDATA, data);
}

static __inline void
iwn_mem_write_2(struct iwn_softc *sc, uint32_t addr, uint16_t data)
{
	uint32_t tmp;

	tmp = iwn_mem_read(sc, addr & ~3);
	if (addr & 3)
		tmp = (tmp & 0x0000ffff) | data << 16;
	else
		tmp = (tmp & 0xffff0000) | data;
	iwn_mem_write(sc, addr & ~3, tmp);
}

#ifdef IWN_DEBUG
 
static __inline void
iwn_mem_read_region_4(struct iwn_softc *sc, uint32_t addr, uint32_t *data,
    int count)
{
	for (; count > 0; count--, addr += 4)
		*data++ = iwn_mem_read(sc, addr);
}

#endif

static __inline void
iwn_mem_set_region_4(struct iwn_softc *sc, uint32_t addr, uint32_t val,
    int count)
{
	for (; count > 0; count--, addr += 4)
		iwn_mem_write(sc, addr, val);
}

int
iwn_eeprom_lock(struct iwn_softc *sc)
{
	int i, ntries;

	for (i = 0; i < 100; i++) {
		/* Request exclusive access to EEPROM. */
		IWN_SETBITS(sc, IWN_HW_IF_CONFIG,
		    IWN_HW_IF_CONFIG_EEPROM_LOCKED);

		/* Spin until we actually get the lock. */
		for (ntries = 0; ntries < 100; ntries++) {
			if (IWN_READ(sc, IWN_HW_IF_CONFIG) &
			    IWN_HW_IF_CONFIG_EEPROM_LOCKED)
				return 0;
			DELAY(10);
		}
	}
	return ETIMEDOUT;
}

static __inline void
iwn_eeprom_unlock(struct iwn_softc *sc)
{
	IWN_CLRBITS(sc, IWN_HW_IF_CONFIG, IWN_HW_IF_CONFIG_EEPROM_LOCKED);
}

/*
 * Initialize access by host to One Time Programmable ROM.
 * NB: This kind of ROM can be found on 1000 or 6000 Series only.
 */
int
iwn_init_otprom(struct iwn_softc *sc)
{
	uint16_t prev, base, next;
	int count, error;

	/* Wait for clock stabilization before accessing prph. */
	if ((error = iwn_clock_wait(sc)) != 0)
		return error;

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
	iwn_prph_setbits(sc, IWN_APMG_PS, IWN_APMG_PS_RESET_REQ);
	DELAY(5);
	iwn_prph_clrbits(sc, IWN_APMG_PS, IWN_APMG_PS_RESET_REQ);
	iwn_nic_unlock(sc);

	/* Set auto clock gate disable bit for HW with OTP shadow RAM. */
	if (sc->hw_type != IWN_HW_REV_TYPE_1000) {
		IWN_SETBITS(sc, IWN_DBG_LINK_PWR_MGMT,
		    IWN_RESET_LINK_PWR_MGMT_DIS);
	}
	IWN_CLRBITS(sc, IWN_EEPROM_GP, IWN_EEPROM_GP_IF_OWNER);
	/* Clear ECC status. */
	IWN_SETBITS(sc, IWN_OTP_GP,
	    IWN_OTP_GP_ECC_CORR_STTS | IWN_OTP_GP_ECC_UNCORR_STTS);

	/*
	 * Find the block before last block (contains the EEPROM image)
	 * for HW without OTP shadow RAM.
	 */
	if (sc->hw_type == IWN_HW_REV_TYPE_1000) {
		/* Switch to absolute addressing mode. */
		IWN_CLRBITS(sc, IWN_OTP_GP, IWN_OTP_GP_RELATIVE_ACCESS);
		base = 0;
		for (count = 0; count < IWN1000_OTP_NBLOCKS; count++) {
			error = iwn_read_prom_data(sc, base, &next, 2);
			if (error != 0)
				return error;
			if (next == 0)	/* End of linked-list. */
				break;
			prev = base;
			base = letoh16(next);
		}
		if (count == 0 || count == IWN1000_OTP_NBLOCKS)
			return EIO;
		/* Skip "next" word. */
		sc->prom_base = prev + 1;
	}
	return 0;
}

int
iwn_read_prom_data(struct iwn_softc *sc, uint32_t addr, void *data, int count)
{
	uint8_t *out = data;
	uint32_t val, tmp;
	int ntries;

	addr += sc->prom_base;
	for (; count > 0; count -= 2, addr++) {
		IWN_WRITE(sc, IWN_EEPROM, addr << 2);
		for (ntries = 0; ntries < 10; ntries++) {
			val = IWN_READ(sc, IWN_EEPROM);
			if (val & IWN_EEPROM_READ_VALID)
				break;
			DELAY(5);
		}
		if (ntries == 10) {
			printf("%s: timeout reading ROM at 0x%x\n",
			    sc->sc_dev.dv_xname, addr);
			return ETIMEDOUT;
		}
		if (sc->sc_flags & IWN_FLAG_HAS_OTPROM) {
			/* OTPROM, check for ECC errors. */
			tmp = IWN_READ(sc, IWN_OTP_GP);
			if (tmp & IWN_OTP_GP_ECC_UNCORR_STTS) {
				printf("%s: OTPROM ECC error at 0x%x\n",
				    sc->sc_dev.dv_xname, addr);
				return EIO;
			}
			if (tmp & IWN_OTP_GP_ECC_CORR_STTS) {
				/* Correctable ECC error, clear bit. */
				IWN_SETBITS(sc, IWN_OTP_GP,
				    IWN_OTP_GP_ECC_CORR_STTS);
			}
		}
		*out++ = val >> 16;
		if (count > 1)
			*out++ = val >> 24;
	}
	return 0;
}

int
iwn_dma_contig_alloc(bus_dma_tag_t tag, struct iwn_dma_info *dma, void **kvap,
    bus_size_t size, bus_size_t alignment)
{
	int nsegs, error;

	dma->tag = tag;
	dma->size = size;

	error = bus_dmamap_create(tag, size, 1, size, 0, BUS_DMA_NOWAIT,
	    &dma->map);
	if (error != 0)
		goto fail;

	error = bus_dmamem_alloc(tag, size, alignment, 0, &dma->seg, 1, &nsegs,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0)
		goto fail;

	error = bus_dmamem_map(tag, &dma->seg, 1, size, &dma->vaddr,
	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (error != 0)
		goto fail;

	error = bus_dmamap_load_raw(tag, dma->map, &dma->seg, 1, size,
	    BUS_DMA_NOWAIT);
	if (error != 0)
		goto fail;

	bus_dmamap_sync(tag, dma->map, 0, size, BUS_DMASYNC_PREWRITE);

	dma->paddr = dma->map->dm_segs[0].ds_addr;
	if (kvap != NULL)
		*kvap = dma->vaddr;

	return 0;

fail:	iwn_dma_contig_free(dma);
	return error;
}

void
iwn_dma_contig_free(struct iwn_dma_info *dma)
{
	if (dma->map != NULL) {
		if (dma->vaddr != NULL) {
			bus_dmamap_sync(dma->tag, dma->map, 0, dma->size,
			    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(dma->tag, dma->map);
			bus_dmamem_unmap(dma->tag, dma->vaddr, dma->size);
			bus_dmamem_free(dma->tag, &dma->seg, 1);
			dma->vaddr = NULL;
		}
		bus_dmamap_destroy(dma->tag, dma->map);
		dma->map = NULL;
	}
}

int
iwn_alloc_sched(struct iwn_softc *sc)
{
	/* TX scheduler rings must be aligned on a 1KB boundary. */
	return iwn_dma_contig_alloc(sc->sc_dmat, &sc->sched_dma,
	    (void **)&sc->sched, sc->schedsz, 1024);
}

void
iwn_free_sched(struct iwn_softc *sc)
{
	iwn_dma_contig_free(&sc->sched_dma);
}

int
iwn_alloc_kw(struct iwn_softc *sc)
{
	/* "Keep Warm" page must be aligned on a 4KB boundary. */
	return iwn_dma_contig_alloc(sc->sc_dmat, &sc->kw_dma, NULL, 4096,
	    4096);
}

void
iwn_free_kw(struct iwn_softc *sc)
{
	iwn_dma_contig_free(&sc->kw_dma);
}

int
iwn_alloc_ict(struct iwn_softc *sc)
{
	/* ICT table must be aligned on a 4KB boundary. */
	return iwn_dma_contig_alloc(sc->sc_dmat, &sc->ict_dma,
	    (void **)&sc->ict, IWN_ICT_SIZE, 4096);
}

void
iwn_free_ict(struct iwn_softc *sc)
{
	iwn_dma_contig_free(&sc->ict_dma);
}

int
iwn_alloc_fwmem(struct iwn_softc *sc)
{
	/* Must be aligned on a 16-byte boundary. */
	return iwn_dma_contig_alloc(sc->sc_dmat, &sc->fw_dma, NULL,
	    sc->fwsz, 16);
}

void
iwn_free_fwmem(struct iwn_softc *sc)
{
	iwn_dma_contig_free(&sc->fw_dma);
}

int
iwn_alloc_rx_ring(struct iwn_softc *sc, struct iwn_rx_ring *ring)
{
	bus_size_t size;
	int i, error;

	ring->cur = 0;

	/* Allocate RX descriptors (256-byte aligned). */
	size = IWN_RX_RING_COUNT * sizeof (uint32_t);
	error = iwn_dma_contig_alloc(sc->sc_dmat, &ring->desc_dma,
	    (void **)&ring->desc, size, 256);
	if (error != 0) {
		printf("%s: could not allocate RX ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/* Allocate RX status area (16-byte aligned). */
	error = iwn_dma_contig_alloc(sc->sc_dmat, &ring->stat_dma,
	    (void **)&ring->stat, sizeof (struct iwn_rx_status), 16);
	if (error != 0) {
		printf("%s: could not allocate RX status DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Allocate and map RX buffers.
	 */
	for (i = 0; i < IWN_RX_RING_COUNT; i++) {
		struct iwn_rx_data *data = &ring->data[i];

		error = bus_dmamap_create(sc->sc_dmat, IWN_RBUF_SIZE, 1,
		    IWN_RBUF_SIZE, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &data->map);
		if (error != 0) {
			printf("%s: could not create RX buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		data->m = MCLGETI(NULL, M_DONTWAIT, NULL, IWN_RBUF_SIZE);
		if (data->m == NULL) {
			printf("%s: could not allocate RX mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOBUFS;
			goto fail;
		}

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), IWN_RBUF_SIZE, NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_READ);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			goto fail;
		}

		/* Set physical address of RX buffer (256-byte aligned). */
		ring->desc[i] = htole32(data->map->dm_segs[0].ds_addr >> 8);
	}

	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map, 0, size,
	    BUS_DMASYNC_PREWRITE);

	return 0;

fail:	iwn_free_rx_ring(sc, ring);
	return error;
}

void
iwn_reset_rx_ring(struct iwn_softc *sc, struct iwn_rx_ring *ring)
{
	int ntries;

	if (iwn_nic_lock(sc) == 0) {
		IWN_WRITE(sc, IWN_FH_RX_CONFIG, 0);
		for (ntries = 0; ntries < 1000; ntries++) {
			if (IWN_READ(sc, IWN_FH_RX_STATUS) &
			    IWN_FH_RX_STATUS_IDLE)
				break;
			DELAY(10);
		}
		iwn_nic_unlock(sc);
	}
	ring->cur = 0;
	sc->last_rx_valid = 0;
}

void
iwn_free_rx_ring(struct iwn_softc *sc, struct iwn_rx_ring *ring)
{
	int i;

	iwn_dma_contig_free(&ring->desc_dma);
	iwn_dma_contig_free(&ring->stat_dma);

	for (i = 0; i < IWN_RX_RING_COUNT; i++) {
		struct iwn_rx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
		}
		if (data->map != NULL)
			bus_dmamap_destroy(sc->sc_dmat, data->map);
	}
}

int
iwn_alloc_tx_ring(struct iwn_softc *sc, struct iwn_tx_ring *ring, int qid)
{
	bus_addr_t paddr;
	bus_size_t size;
	int i, error;

	ring->qid = qid;
	ring->queued = 0;
	ring->cur = 0;

	/* Allocate TX descriptors (256-byte aligned). */
	size = IWN_TX_RING_COUNT * sizeof (struct iwn_tx_desc);
	error = iwn_dma_contig_alloc(sc->sc_dmat, &ring->desc_dma,
	    (void **)&ring->desc, size, 256);
	if (error != 0) {
		printf("%s: could not allocate TX ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	/*
	 * We only use rings 0 through 4 (4 EDCA + cmd) so there is no need
	 * to allocate commands space for other rings.
	 * XXX Do we really need to allocate descriptors for other rings?
	 */
	if (qid > 4)
		return 0;

	size = IWN_TX_RING_COUNT * sizeof (struct iwn_tx_cmd);
	error = iwn_dma_contig_alloc(sc->sc_dmat, &ring->cmd_dma,
	    (void **)&ring->cmd, size, 4);
	if (error != 0) {
		printf("%s: could not allocate TX cmd DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	paddr = ring->cmd_dma.paddr;
	for (i = 0; i < IWN_TX_RING_COUNT; i++) {
		struct iwn_tx_data *data = &ring->data[i];

		data->cmd_paddr = paddr;
		data->scratch_paddr = paddr + 12;
		paddr += sizeof (struct iwn_tx_cmd);

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    IWN_MAX_SCATTER - 1, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &data->map);
		if (error != 0) {
			printf("%s: could not create TX buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}
	return 0;

fail:	iwn_free_tx_ring(sc, ring);
	return error;
}

void
iwn_reset_tx_ring(struct iwn_softc *sc, struct iwn_tx_ring *ring)
{
	int i;

	for (i = 0; i < IWN_TX_RING_COUNT; i++) {
		struct iwn_tx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}
	}
	/* Clear TX descriptors. */
	memset(ring->desc, 0, ring->desc_dma.size);
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map, 0,
	    ring->desc_dma.size, BUS_DMASYNC_PREWRITE);
	sc->qfullmsk &= ~(1 << ring->qid);
	ring->queued = 0;
	ring->cur = 0;
}

void
iwn_free_tx_ring(struct iwn_softc *sc, struct iwn_tx_ring *ring)
{
	int i;

	iwn_dma_contig_free(&ring->desc_dma);
	iwn_dma_contig_free(&ring->cmd_dma);

	for (i = 0; i < IWN_TX_RING_COUNT; i++) {
		struct iwn_tx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
		}
		if (data->map != NULL)
			bus_dmamap_destroy(sc->sc_dmat, data->map);
	}
}

void
iwn5000_ict_reset(struct iwn_softc *sc)
{
	/* Disable interrupts. */
	IWN_WRITE(sc, IWN_INT_MASK, 0);

	/* Reset ICT table. */
	memset(sc->ict, 0, IWN_ICT_SIZE);
	sc->ict_cur = 0;

	/* Set physical address of ICT table (4KB aligned). */
	DPRINTF(("enabling ICT\n"));
	IWN_WRITE(sc, IWN_DRAM_INT_TBL, IWN_DRAM_INT_TBL_ENABLE |
	    IWN_DRAM_INT_TBL_WRAP_CHECK | sc->ict_dma.paddr >> 12);

	/* Enable periodic RX interrupt. */
	sc->int_mask |= IWN_INT_RX_PERIODIC;
	/* Switch to ICT interrupt mode in driver. */
	sc->sc_flags |= IWN_FLAG_USE_ICT;

	/* Re-enable interrupts. */
	IWN_WRITE(sc, IWN_INT, 0xffffffff);
	IWN_WRITE(sc, IWN_INT_MASK, sc->int_mask);
}

int
iwn_read_eeprom(struct iwn_softc *sc)
{
	struct iwn_ops *ops = &sc->ops;
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t val;
	int error;

	/* Check whether adapter has an EEPROM or an OTPROM. */
	if (sc->hw_type >= IWN_HW_REV_TYPE_1000 &&
	    (IWN_READ(sc, IWN_OTP_GP) & IWN_OTP_GP_DEV_SEL_OTP))
		sc->sc_flags |= IWN_FLAG_HAS_OTPROM;
	DPRINTF(("%s found\n", (sc->sc_flags & IWN_FLAG_HAS_OTPROM) ?
	    "OTPROM" : "EEPROM"));

	/* Adapter has to be powered on for EEPROM access to work. */
	if ((error = iwn_apm_init(sc)) != 0) {
		printf("%s: could not power ON adapter\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	if ((IWN_READ(sc, IWN_EEPROM_GP) & 0x7) == 0) {
		printf("%s: bad ROM signature\n", sc->sc_dev.dv_xname);
		return EIO;
	}
	if ((error = iwn_eeprom_lock(sc)) != 0) {
		printf("%s: could not lock ROM (error=%d)\n",
		    sc->sc_dev.dv_xname, error);
		return error;
	}
	if (sc->sc_flags & IWN_FLAG_HAS_OTPROM) {
		if ((error = iwn_init_otprom(sc)) != 0) {
			printf("%s: could not initialize OTPROM\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
	}

	iwn_read_prom_data(sc, IWN_EEPROM_SKU_CAP, &val, 2);
	DPRINTF(("SKU capabilities=0x%04x\n", letoh16(val)));
	/* Check if HT support is bonded out. */
	if (val & htole16(IWN_EEPROM_SKU_CAP_11N))
		sc->sc_flags |= IWN_FLAG_HAS_11N;

	iwn_read_prom_data(sc, IWN_EEPROM_RFCFG, &val, 2);
	sc->rfcfg = letoh16(val);
	DPRINTF(("radio config=0x%04x\n", sc->rfcfg));
	/* Read Tx/Rx chains from ROM unless it's known to be broken. */
	if (sc->txchainmask == 0)
		sc->txchainmask = IWN_RFCFG_TXANTMSK(sc->rfcfg);
	if (sc->rxchainmask == 0)
		sc->rxchainmask = IWN_RFCFG_RXANTMSK(sc->rfcfg);

	/* Read MAC address. */
	iwn_read_prom_data(sc, IWN_EEPROM_MAC, ic->ic_myaddr, 6);

	/* Read adapter-specific information from EEPROM. */
	ops->read_eeprom(sc);

	iwn_apm_stop(sc);	/* Power OFF adapter. */

	iwn_eeprom_unlock(sc);
	return 0;
}

void
iwn4965_read_eeprom(struct iwn_softc *sc)
{
	uint32_t addr;
	uint16_t val;
	int i;

	/* Read regulatory domain (4 ASCII characters). */
	iwn_read_prom_data(sc, IWN4965_EEPROM_DOMAIN, sc->eeprom_domain, 4);

	/* Read the list of authorized channels (20MHz ones only). */
	for (i = 0; i < 5; i++) {
		addr = iwn4965_regulatory_bands[i];
		iwn_read_eeprom_channels(sc, i, addr);
	}

	/* Read maximum allowed TX power for 2GHz and 5GHz bands. */
	iwn_read_prom_data(sc, IWN4965_EEPROM_MAXPOW, &val, 2);
	sc->maxpwr2GHz = val & 0xff;
	sc->maxpwr5GHz = val >> 8;
	/* Check that EEPROM values are within valid range. */
	if (sc->maxpwr5GHz < 20 || sc->maxpwr5GHz > 50)
		sc->maxpwr5GHz = 38;
	if (sc->maxpwr2GHz < 20 || sc->maxpwr2GHz > 50)
		sc->maxpwr2GHz = 38;
	DPRINTF(("maxpwr 2GHz=%d 5GHz=%d\n", sc->maxpwr2GHz, sc->maxpwr5GHz));

	/* Read samples for each TX power group. */
	iwn_read_prom_data(sc, IWN4965_EEPROM_BANDS, sc->bands,
	    sizeof sc->bands);

	/* Read voltage at which samples were taken. */
	iwn_read_prom_data(sc, IWN4965_EEPROM_VOLTAGE, &val, 2);
	sc->eeprom_voltage = (int16_t)letoh16(val);
	DPRINTF(("voltage=%d (in 0.3V)\n", sc->eeprom_voltage));

#ifdef IWN_DEBUG
	/* Print samples. */
	if (iwn_debug > 0) {
		for (i = 0; i < IWN_NBANDS; i++)
			iwn4965_print_power_group(sc, i);
	}
#endif
}

#ifdef IWN_DEBUG
void
iwn4965_print_power_group(struct iwn_softc *sc, int i)
{
	struct iwn4965_eeprom_band *band = &sc->bands[i];
	struct iwn4965_eeprom_chan_samples *chans = band->chans;
	int j, c;

	printf("===band %d===\n", i);
	printf("chan lo=%d, chan hi=%d\n", band->lo, band->hi);
	printf("chan1 num=%d\n", chans[0].num);
	for (c = 0; c < 2; c++) {
		for (j = 0; j < IWN_NSAMPLES; j++) {
			printf("chain %d, sample %d: temp=%d gain=%d "
			    "power=%d pa_det=%d\n", c, j,
			    chans[0].samples[c][j].temp,
			    chans[0].samples[c][j].gain,
			    chans[0].samples[c][j].power,
			    chans[0].samples[c][j].pa_det);
		}
	}
	printf("chan2 num=%d\n", chans[1].num);
	for (c = 0; c < 2; c++) {
		for (j = 0; j < IWN_NSAMPLES; j++) {
			printf("chain %d, sample %d: temp=%d gain=%d "
			    "power=%d pa_det=%d\n", c, j,
			    chans[1].samples[c][j].temp,
			    chans[1].samples[c][j].gain,
			    chans[1].samples[c][j].power,
			    chans[1].samples[c][j].pa_det);
		}
	}
}
#endif

void
iwn5000_read_eeprom(struct iwn_softc *sc)
{
	struct iwn5000_eeprom_calib_hdr hdr;
	int32_t volt;
	uint32_t base, addr;
	uint16_t val;
	int i;

	/* Read regulatory domain (4 ASCII characters). */
	iwn_read_prom_data(sc, IWN5000_EEPROM_REG, &val, 2);
	base = letoh16(val);
	iwn_read_prom_data(sc, base + IWN5000_EEPROM_DOMAIN,
	    sc->eeprom_domain, 4);

	/* Read the list of authorized channels (20MHz ones only). */
	for (i = 0; i < 5; i++) {
		addr = base + iwn5000_regulatory_bands[i];
		iwn_read_eeprom_channels(sc, i, addr);
	}

	/* Read enhanced TX power information for 6000 Series. */
	if (sc->hw_type >= IWN_HW_REV_TYPE_6000)
		iwn_read_eeprom_enhinfo(sc);

	iwn_read_prom_data(sc, IWN5000_EEPROM_CAL, &val, 2);
	base = letoh16(val);
	iwn_read_prom_data(sc, base, &hdr, sizeof hdr);
	DPRINTF(("calib version=%u pa type=%u voltage=%u\n",
	    hdr.version, hdr.pa_type, letoh16(hdr.volt)));
	sc->calib_ver = hdr.version;

	if (sc->hw_type == IWN_HW_REV_TYPE_2030 ||
	    sc->hw_type == IWN_HW_REV_TYPE_2000 ||
	    sc->hw_type == IWN_HW_REV_TYPE_135 ||
	    sc->hw_type == IWN_HW_REV_TYPE_105) {
		sc->eeprom_voltage = letoh16(hdr.volt);
		iwn_read_prom_data(sc, base + IWN5000_EEPROM_TEMP, &val, 2);
		sc->eeprom_temp = letoh16(val);
		iwn_read_prom_data(sc, base + IWN2000_EEPROM_RAWTEMP, &val, 2);
		sc->eeprom_rawtemp = letoh16(val);
	}

	if (sc->hw_type == IWN_HW_REV_TYPE_5150) {
		/* Compute temperature offset. */
		iwn_read_prom_data(sc, base + IWN5000_EEPROM_TEMP, &val, 2);
		sc->eeprom_temp = letoh16(val);
		iwn_read_prom_data(sc, base + IWN5000_EEPROM_VOLT, &val, 2);
		volt = letoh16(val);
		sc->temp_off = sc->eeprom_temp - (volt / -5);
		DPRINTF(("temp=%d volt=%d offset=%dK\n",
		    sc->eeprom_temp, volt, sc->temp_off));
	} else {
		/* Read crystal calibration. */
		iwn_read_prom_data(sc, base + IWN5000_EEPROM_CRYSTAL,
		    &sc->eeprom_crystal, sizeof (uint32_t));
		DPRINTF(("crystal calibration 0x%08x\n",
		    letoh32(sc->eeprom_crystal)));
	}
}

void
iwn_read_eeprom_channels(struct iwn_softc *sc, int n, uint32_t addr)
{
	struct ieee80211com *ic = &sc->sc_ic;
	const struct iwn_chan_band *band = &iwn_bands[n];
	struct iwn_eeprom_chan channels[IWN_MAX_CHAN_PER_BAND];
	uint8_t chan;
	int i;

	iwn_read_prom_data(sc, addr, channels,
	    band->nchan * sizeof (struct iwn_eeprom_chan));

	for (i = 0; i < band->nchan; i++) {
		if (!(channels[i].flags & IWN_EEPROM_CHAN_VALID))
			continue;

		chan = band->chan[i];

		if (n == 0) {	/* 2GHz band */
			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_2GHZ);
			ic->ic_channels[chan].ic_flags =
			    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
			    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;

		} else {	/* 5GHz band */
			/*
			 * Some adapters support channels 7, 8, 11 and 12
			 * both in the 2GHz and 4.9GHz bands.
			 * Because of limitations in our net80211 layer,
			 * we don't support them in the 4.9GHz band.
			 */
			if (chan <= 14)
				continue;

			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[chan].ic_flags = IEEE80211_CHAN_A;
			/* We have at least one valid 5GHz channel. */
			sc->sc_flags |= IWN_FLAG_HAS_5GHZ;
		}

		/* Is active scan allowed on this channel? */
		if (!(channels[i].flags & IWN_EEPROM_CHAN_ACTIVE)) {
			ic->ic_channels[chan].ic_flags |=
			    IEEE80211_CHAN_PASSIVE;
		}

		/* Save maximum allowed TX power for this channel. */
		sc->maxpwr[chan] = channels[i].maxpwr;

		if (sc->sc_flags & IWN_FLAG_HAS_11N)
			ic->ic_channels[chan].ic_flags |= IEEE80211_CHAN_HT;

		DPRINTF(("adding chan %d flags=0x%x maxpwr=%d\n",
		    chan, channels[i].flags, sc->maxpwr[chan]));
	}
}

void
iwn_read_eeprom_enhinfo(struct iwn_softc *sc)
{
	struct iwn_eeprom_enhinfo enhinfo[35];
	uint16_t val, base;
	int8_t maxpwr;
	int i;

	iwn_read_prom_data(sc, IWN5000_EEPROM_REG, &val, 2);
	base = letoh16(val);
	iwn_read_prom_data(sc, base + IWN6000_EEPROM_ENHINFO,
	    enhinfo, sizeof enhinfo);

	memset(sc->enh_maxpwr, 0, sizeof sc->enh_maxpwr);
	for (i = 0; i < nitems(enhinfo); i++) {
		if (enhinfo[i].chan == 0 || enhinfo[i].reserved != 0)
			continue;	/* Skip invalid entries. */

		maxpwr = 0;
		if (sc->txchainmask & IWN_ANT_A)
			maxpwr = MAX(maxpwr, enhinfo[i].chain[0]);
		if (sc->txchainmask & IWN_ANT_B)
			maxpwr = MAX(maxpwr, enhinfo[i].chain[1]);
		if (sc->txchainmask & IWN_ANT_C)
			maxpwr = MAX(maxpwr, enhinfo[i].chain[2]);
		if (sc->ntxchains == 2)
			maxpwr = MAX(maxpwr, enhinfo[i].mimo2);
		else if (sc->ntxchains == 3)
			maxpwr = MAX(maxpwr, enhinfo[i].mimo3);
		maxpwr /= 2;	/* Convert half-dBm to dBm. */

		DPRINTF(("enhinfo %d, maxpwr=%d\n", i, maxpwr));
		sc->enh_maxpwr[i] = maxpwr;
	}
}

struct ieee80211_node *
iwn_node_alloc(struct ieee80211com *ic)
{
	return malloc(sizeof (struct iwn_node), M_DEVBUF, M_NOWAIT | M_ZERO);
}

void
iwn_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct iwn_softc *sc = ic->ic_if.if_softc;
	struct iwn_node *wn = (void *)ni;
	uint8_t rate;
	int ridx, i;

	if ((ni->ni_flags & IEEE80211_NODE_HT) == 0)
		ieee80211_amrr_node_init(&sc->amrr, &wn->amn);

	/* Start at lowest available bit-rate, AMRR/MiRA will raise. */
	ni->ni_txrate = 0;
	ni->ni_txmcs = 0;

	for (i = 0; i < ni->ni_rates.rs_nrates; i++) {
		rate = ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL;
		/* Map 802.11 rate to HW rate index. */
		for (ridx = 0; ridx <= IWN_RIDX_MAX; ridx++) {
			if (iwn_rates[ridx].plcp != IWN_PLCP_INVALID &&
			    iwn_rates[ridx].rate == rate)
				break;
		}
		wn->ridx[i] = ridx;
	}
}

int
iwn_media_change(struct ifnet *ifp)
{
	struct iwn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t rate, ridx;
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if (ic->ic_fixed_mcs != -1)
		sc->fixed_ridx = iwn_mcs2ridx[ic->ic_fixed_mcs];
	if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate] & IEEE80211_RATE_VAL;
		/* Map 802.11 rate to HW rate index. */
		for (ridx = 0; ridx <= IWN_RIDX_MAX; ridx++)
			if (iwn_rates[ridx].plcp != IWN_PLCP_INVALID &&
			    iwn_rates[ridx].rate == rate)
				break;
		sc->fixed_ridx = ridx;
	}

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
	    (IFF_UP | IFF_RUNNING)) {
		iwn_stop(ifp, 0);
		error = iwn_init(ifp);
	}
	return error;
}

int
iwn_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct ifnet *ifp = &ic->ic_if;
	struct iwn_softc *sc = ifp->if_softc;
	struct ieee80211_node *ni = ic->ic_bss;
	struct iwn_node *wn = (void *)ni;
	int error;

	timeout_del(&sc->calib_to);

	if (ic->ic_state == IEEE80211_S_RUN &&
	    (ni->ni_flags & IEEE80211_NODE_HT))
		ieee80211_mira_cancel_timeouts(&wn->mn);

	switch (nstate) {
	case IEEE80211_S_SCAN:
		/* Make the link LED blink while we're scanning. */
		iwn_set_led(sc, IWN_LED_LINK, 10, 10);

		if ((error = iwn_scan(sc, IEEE80211_CHAN_2GHZ)) != 0) {
			printf("%s: could not initiate scan\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
		ic->ic_state = nstate;
		return 0;

	case IEEE80211_S_ASSOC:
		if (ic->ic_state != IEEE80211_S_RUN)
			break;
		/* FALLTHROUGH */
	case IEEE80211_S_AUTH:
		/* Reset state to handle reassociations correctly. */
		sc->rxon.associd = 0;
		sc->rxon.filter &= ~htole32(IWN_FILTER_BSS);
		sc->calib.state = IWN_CALIB_STATE_INIT;

		if ((error = iwn_auth(sc)) != 0) {
			printf("%s: could not move to auth state\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
		break;

	case IEEE80211_S_RUN:
		if ((error = iwn_run(sc)) != 0) {
			printf("%s: could not move to run state\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
		break;

	case IEEE80211_S_INIT:
		sc->calib.state = IWN_CALIB_STATE_INIT;
		break;
	}

	return sc->sc_newstate(ic, nstate, arg);
}

void
iwn_iter_func(void *arg, struct ieee80211_node *ni)
{
	struct iwn_softc *sc = arg;
	struct iwn_node *wn = (void *)ni;

	if ((ni->ni_flags & IEEE80211_NODE_HT) == 0)
		ieee80211_amrr_choose(&sc->amrr, ni, &wn->amn);
}

void
iwn_calib_timeout(void *arg)
{
	struct iwn_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;

	s = splnet();
	if (ic->ic_fixed_rate == -1) {
		if (ic->ic_opmode == IEEE80211_M_STA)
			iwn_iter_func(sc, ic->ic_bss);
		else
			ieee80211_iterate_nodes(ic, iwn_iter_func, sc);
	}
	/* Force automatic TX power calibration every 60 secs. */
	if (++sc->calib_cnt >= 120) {
		uint32_t flags = 0;

		DPRINTFN(2, ("sending request for statistics\n"));
		(void)iwn_cmd(sc, IWN_CMD_GET_STATISTICS, &flags,
		    sizeof flags, 1);
		sc->calib_cnt = 0;
	}
	splx(s);

	/* Automatic rate control triggered every 500ms. */
	timeout_add_msec(&sc->calib_to, 500);
}

int
iwn_ccmp_decap(struct iwn_softc *sc, struct mbuf *m, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_key *k = &ni->ni_pairwise_key;
	struct ieee80211_frame *wh;
	struct ieee80211_rx_ba *ba;
	uint64_t pn, *prsc;
	uint8_t *ivp;
	uint8_t tid;
	int hdrlen, hasqos;

	wh = mtod(m, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	ivp = (uint8_t *)wh + hdrlen;

	/* Check that ExtIV bit is be set. */
	if (!(ivp[3] & IEEE80211_WEP_EXTIV)) {
		DPRINTF(("CCMP decap ExtIV not set\n"));
		return 1;
	}
	hasqos = ieee80211_has_qos(wh);
	tid = hasqos ? ieee80211_get_qos(wh) & IEEE80211_QOS_TID : 0;
	ba = hasqos ? &ni->ni_rx_ba[tid] : NULL;
	prsc = &k->k_rsc[tid];

	/* Extract the 48-bit PN from the CCMP header. */
	pn = (uint64_t)ivp[0]       |
	     (uint64_t)ivp[1] <<  8 |
	     (uint64_t)ivp[4] << 16 |
	     (uint64_t)ivp[5] << 24 |
	     (uint64_t)ivp[6] << 32 |
	     (uint64_t)ivp[7] << 40;
	if (pn <= *prsc) {
		if (hasqos && ba->ba_state == IEEE80211_BA_AGREED) {
			/*
			 * This is an A-MPDU subframe.
			 * Such frames may be received out of order due to
			 * legitimate retransmissions of failed subframes
			 * in previous A-MPDUs. Duplicates will be handled
			 * in ieee80211_input() as part of A-MPDU reordering.
			 */
		} else if (ieee80211_has_seq(wh)) {
			/*
			 * Not necessarily a replayed frame since we did not
			 * check the sequence number of the 802.11 header yet.
			 */
			int nrxseq, orxseq;

			nrxseq = letoh16(*(u_int16_t *)wh->i_seq) >>
			    IEEE80211_SEQ_SEQ_SHIFT;
			if (hasqos)
				orxseq = ni->ni_qos_rxseqs[tid];
			else
				orxseq = ni->ni_rxseq;
			if (nrxseq < orxseq) {
				DPRINTF(("CCMP replayed (n=%d < o=%d)\n",
				    nrxseq, orxseq));
				ic->ic_stats.is_ccmp_replays++;
				return 1;
			}
		} else {
			DPRINTF(("CCMP replayed\n"));
			ic->ic_stats.is_ccmp_replays++;
			return 1;
		}
	}
	/* Update last seen packet number. */
	*prsc = pn;

	/* Clear Protected bit and strip IV. */
	wh->i_fc[1] &= ~IEEE80211_FC1_PROTECTED;
	memmove(mtod(m, caddr_t) + IEEE80211_CCMP_HDRLEN, wh, hdrlen);
	m_adj(m, IEEE80211_CCMP_HDRLEN);
	/* Strip MIC. */
	m_adj(m, -IEEE80211_CCMP_MICLEN);
	return 0;
}

/*
 * Process an RX_PHY firmware notification.  This is usually immediately
 * followed by an MPDU_RX_DONE notification.
 */
void
iwn_rx_phy(struct iwn_softc *sc, struct iwn_rx_desc *desc,
    struct iwn_rx_data *data)
{
	struct iwn_rx_stat *stat = (struct iwn_rx_stat *)(desc + 1);

	DPRINTFN(2, ("received PHY stats\n"));
	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
	    sizeof (*stat), BUS_DMASYNC_POSTREAD);

	/* Save RX statistics, they will be used on MPDU_RX_DONE. */
	memcpy(&sc->last_rx_stat, stat, sizeof (*stat));
	sc->last_rx_valid = IWN_LAST_RX_VALID;
	/*
	 * The firmware does not send separate RX_PHY
	 * notifications for A-MPDU subframes.
	 */
	if (stat->flags & htole16(IWN_STAT_FLAG_AGG))
		sc->last_rx_valid |= IWN_LAST_RX_AMPDU;
}

/*
 * Process an RX_DONE (4965AGN only) or MPDU_RX_DONE firmware notification.
 * Each MPDU_RX_DONE notification must be preceded by an RX_PHY one.
 */
void
iwn_rx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc,
    struct iwn_rx_data *data)
{
	struct iwn_ops *ops = &sc->ops;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct iwn_rx_ring *ring = &sc->rxq;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct mbuf *m, *m1;
	struct iwn_rx_stat *stat;
	caddr_t head;
	uint32_t flags;
	int error, len, rssi;

	if (desc->type == IWN_MPDU_RX_DONE) {
		/* Check for prior RX_PHY notification. */
		if (!sc->last_rx_valid) {
			DPRINTF(("missing RX_PHY\n"));
			return;
		}
		sc->last_rx_valid &= ~IWN_LAST_RX_VALID;
		stat = &sc->last_rx_stat;
		if ((sc->last_rx_valid & IWN_LAST_RX_AMPDU) &&
		    (stat->flags & htole16(IWN_STAT_FLAG_AGG)) == 0) {
			DPRINTF(("missing RX_PHY (expecting A-MPDU)\n"));
			return;
		}
		if ((sc->last_rx_valid & IWN_LAST_RX_AMPDU) == 0 &&
		    (stat->flags & htole16(IWN_STAT_FLAG_AGG))) {
			DPRINTF(("missing RX_PHY (unexpected A-MPDU)\n"));
			return;
		}
	} else
		stat = (struct iwn_rx_stat *)(desc + 1);

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, IWN_RBUF_SIZE,
	    BUS_DMASYNC_POSTREAD);

	if (stat->cfg_phy_len > IWN_STAT_MAXLEN) {
		printf("%s: invalid RX statistic header\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	if (desc->type == IWN_MPDU_RX_DONE) {
		struct iwn_rx_mpdu *mpdu = (struct iwn_rx_mpdu *)(desc + 1);
		head = (caddr_t)(mpdu + 1);
		len = letoh16(mpdu->len);
	} else {
		head = (caddr_t)(stat + 1) + stat->cfg_phy_len;
		len = letoh16(stat->len);
	}

	flags = letoh32(*(uint32_t *)(head + len));

	/* Discard frames with a bad FCS early. */
	if ((flags & IWN_RX_NOERROR) != IWN_RX_NOERROR) {
		DPRINTFN(2, ("RX flags error %x\n", flags));
		ifp->if_ierrors++;
		return;
	}
	/* Discard frames that are too short. */
	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		/* Allow control frames in monitor mode. */
		if (len < sizeof (struct ieee80211_frame_cts)) {
			DPRINTF(("frame too short: %d\n", len));
			ic->ic_stats.is_rx_tooshort++;
			ifp->if_ierrors++;
			return;
		}
	} else if (len < sizeof (*wh)) {
		DPRINTF(("frame too short: %d\n", len));
		ic->ic_stats.is_rx_tooshort++;
		ifp->if_ierrors++;
		return;
	}

	m1 = MCLGETI(NULL, M_DONTWAIT, NULL, IWN_RBUF_SIZE);
	if (m1 == NULL) {
		ic->ic_stats.is_rx_nombuf++;
		ifp->if_ierrors++;
		return;
	}
	bus_dmamap_unload(sc->sc_dmat, data->map);

	error = bus_dmamap_load(sc->sc_dmat, data->map, mtod(m1, void *),
	    IWN_RBUF_SIZE, NULL, BUS_DMA_NOWAIT | BUS_DMA_READ);
	if (error != 0) {
		m_freem(m1);

		/* Try to reload the old mbuf. */
		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), IWN_RBUF_SIZE, NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_READ);
		if (error != 0) {
			panic("%s: could not load old RX mbuf",
			    sc->sc_dev.dv_xname);
		}
		/* Physical address may have changed. */
		ring->desc[ring->cur] =
		    htole32(data->map->dm_segs[0].ds_addr >> 8);
		bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
		    ring->cur * sizeof (uint32_t), sizeof (uint32_t),
		    BUS_DMASYNC_PREWRITE);
		ifp->if_ierrors++;
		return;
	}

	m = data->m;
	data->m = m1;
	/* Update RX descriptor. */
	ring->desc[ring->cur] = htole32(data->map->dm_segs[0].ds_addr >> 8);
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
	    ring->cur * sizeof (uint32_t), sizeof (uint32_t),
	    BUS_DMASYNC_PREWRITE);

	/* Finalize mbuf. */
	m->m_data = head;
	m->m_pkthdr.len = m->m_len = len;

	/* 
	 * Grab a reference to the source node. Note that control frames are
	 * shorter than struct ieee80211_frame but ieee80211_find_rxnode()
	 * is being careful about control frames.
	 */
	wh = mtod(m, struct ieee80211_frame *);
	if (len < sizeof (*wh) &&
	   (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL) {
		ic->ic_stats.is_rx_tooshort++;
		ifp->if_ierrors++;
		m_freem(m);
		return;
	}
	ni = ieee80211_find_rxnode(ic, wh);

	rxi.rxi_flags = 0;
	if (((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL)
	    && (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) &&
	    !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    (ni->ni_flags & IEEE80211_NODE_RXPROT) &&
	    ni->ni_pairwise_key.k_cipher == IEEE80211_CIPHER_CCMP) {
		if ((flags & IWN_RX_CIPHER_MASK) != IWN_RX_CIPHER_CCMP) {
			ic->ic_stats.is_ccmp_dec_errs++;
			ifp->if_ierrors++;
			m_freem(m);
			return;
		}
		/* Check whether decryption was successful or not. */
		if ((desc->type == IWN_MPDU_RX_DONE &&
		     (flags & (IWN_RX_MPDU_DEC | IWN_RX_MPDU_MIC_OK)) !=
		      (IWN_RX_MPDU_DEC | IWN_RX_MPDU_MIC_OK)) ||
		    (desc->type != IWN_MPDU_RX_DONE &&
		     (flags & IWN_RX_DECRYPT_MASK) != IWN_RX_DECRYPT_OK)) {
			DPRINTF(("CCMP decryption failed 0x%x\n", flags));
			ic->ic_stats.is_ccmp_dec_errs++;
			ifp->if_ierrors++;
			m_freem(m);
			return;
		}
		if (iwn_ccmp_decap(sc, m, ni) != 0) {
			ifp->if_ierrors++;
			m_freem(m);
			return;
		}
		rxi.rxi_flags |= IEEE80211_RXI_HWDEC;
	}

	rssi = ops->get_rssi(stat);

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct iwn_rx_radiotap_header *tap = &sc->sc_rxtap;
		uint16_t chan_flags;

		tap->wr_flags = 0;
		if (stat->flags & htole16(IWN_STAT_FLAG_SHPREAMBLE))
			tap->wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
		tap->wr_chan_freq =
		    htole16(ic->ic_channels[stat->chan].ic_freq);
		chan_flags = ic->ic_channels[stat->chan].ic_flags;
		if (ic->ic_curmode != IEEE80211_MODE_11N)
			chan_flags &= ~IEEE80211_CHAN_HT;
		tap->wr_chan_flags = htole16(chan_flags);
		tap->wr_dbm_antsignal = (int8_t)rssi;
		tap->wr_dbm_antnoise = (int8_t)sc->noise;
		tap->wr_tsft = stat->tstamp;
		if (stat->rflags & IWN_RFLAG_MCS) {
			tap->wr_rate = (0x80 | stat->rate); /* HT MCS index */
		} else {
			switch (stat->rate) {
			/* CCK rates. */
			case  10: tap->wr_rate =   2; break;
			case  20: tap->wr_rate =   4; break;
			case  55: tap->wr_rate =  11; break;
			case 110: tap->wr_rate =  22; break;
			/* OFDM rates. */
			case 0xd: tap->wr_rate =  12; break;
			case 0xf: tap->wr_rate =  18; break;
			case 0x5: tap->wr_rate =  24; break;
			case 0x7: tap->wr_rate =  36; break;
			case 0x9: tap->wr_rate =  48; break;
			case 0xb: tap->wr_rate =  72; break;
			case 0x1: tap->wr_rate =  96; break;
			case 0x3: tap->wr_rate = 108; break;
			/* Unknown rate: should not happen. */
			default:  tap->wr_rate =  0;
			}
		}

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif

	/* Send the frame to the 802.11 layer. */
	rxi.rxi_rssi = rssi;
	rxi.rxi_tstamp = 0;	/* unused */
	ieee80211_input(ifp, m, ni, &rxi);

	/* Node is no longer needed. */
	ieee80211_release_node(ic, ni);
}

/* Process an incoming Compressed BlockAck. */
void
iwn_rx_compressed_ba(struct iwn_softc *sc, struct iwn_rx_desc *desc,
    struct iwn_rx_data *data)
{
	struct iwn_compressed_ba *ba = (struct iwn_compressed_ba *)(desc + 1);
	struct iwn_tx_ring *txq;

	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc), sizeof (*ba),
	    BUS_DMASYNC_POSTREAD);

	txq = &sc->txq[letoh16(ba->qid)];
	/* XXX TBD */
}

/*
 * Process a CALIBRATION_RESULT notification sent by the initialization
 * firmware on response to a CMD_CALIB_CONFIG command (5000 only).
 */
void
iwn5000_rx_calib_results(struct iwn_softc *sc, struct iwn_rx_desc *desc,
    struct iwn_rx_data *data)
{
	struct iwn_phy_calib *calib = (struct iwn_phy_calib *)(desc + 1);
	int len, idx = -1;

	/* Runtime firmware should not send such a notification. */
	if (sc->sc_flags & IWN_FLAG_CALIB_DONE)
		return;

	len = (letoh32(desc->len) & 0x3fff) - 4;
	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc), len,
	    BUS_DMASYNC_POSTREAD);

	switch (calib->code) {
	case IWN5000_PHY_CALIB_DC:
		if (sc->hw_type == IWN_HW_REV_TYPE_5150 ||
		    sc->hw_type == IWN_HW_REV_TYPE_2030 ||
		    sc->hw_type == IWN_HW_REV_TYPE_2000 ||
		    sc->hw_type == IWN_HW_REV_TYPE_135 ||
		    sc->hw_type == IWN_HW_REV_TYPE_105)
			idx = 0;
		break;
	case IWN5000_PHY_CALIB_LO:
		idx = 1;
		break;
	case IWN5000_PHY_CALIB_TX_IQ:
		idx = 2;
		break;
	case IWN5000_PHY_CALIB_TX_IQ_PERIODIC:
		if (sc->hw_type < IWN_HW_REV_TYPE_6000 &&
		    sc->hw_type != IWN_HW_REV_TYPE_5150)
			idx = 3;
		break;
	case IWN5000_PHY_CALIB_BASE_BAND:
		idx = 4;
		break;
	}
	if (idx == -1)	/* Ignore other results. */
		return;

	/* Save calibration result. */
	if (sc->calibcmd[idx].buf != NULL)
		free(sc->calibcmd[idx].buf, M_DEVBUF, 0);
	sc->calibcmd[idx].buf = malloc(len, M_DEVBUF, M_NOWAIT);
	if (sc->calibcmd[idx].buf == NULL) {
		DPRINTF(("not enough memory for calibration result %d\n",
		    calib->code));
		return;
	}
	DPRINTF(("saving calibration result code=%d len=%d\n",
	    calib->code, len));
	sc->calibcmd[idx].len = len;
	memcpy(sc->calibcmd[idx].buf, calib, len);
}

/*
 * Process an RX_STATISTICS or BEACON_STATISTICS firmware notification.
 * The latter is sent by the firmware after each received beacon.
 */
void
iwn_rx_statistics(struct iwn_softc *sc, struct iwn_rx_desc *desc,
    struct iwn_rx_data *data)
{
	struct iwn_ops *ops = &sc->ops;
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwn_calib_state *calib = &sc->calib;
	struct iwn_stats *stats = (struct iwn_stats *)(desc + 1);
	int temp;

	/* Ignore statistics received during a scan. */
	if (ic->ic_state != IEEE80211_S_RUN)
		return;

	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
	    sizeof (*stats), BUS_DMASYNC_POSTREAD);

	DPRINTFN(3, ("received statistics (cmd=%d)\n", desc->type));
	sc->calib_cnt = 0;	/* Reset TX power calibration timeout. */

	/* Test if temperature has changed. */
	if (stats->general.temp != sc->rawtemp) {
		/* Convert "raw" temperature to degC. */
		sc->rawtemp = stats->general.temp;
		temp = ops->get_temperature(sc);
		DPRINTFN(2, ("temperature=%dC\n", temp));

		/* Update TX power if need be (4965AGN only). */
		if (sc->hw_type == IWN_HW_REV_TYPE_4965)
			iwn4965_power_calibration(sc, temp);
	}

	if (desc->type != IWN_BEACON_STATISTICS)
		return;	/* Reply to a statistics request. */

	sc->noise = iwn_get_noise(&stats->rx.general);

	/* Test that RSSI and noise are present in stats report. */
	if (letoh32(stats->rx.general.flags) != 1) {
		DPRINTF(("received statistics without RSSI\n"));
		return;
	}

	/*
	 * XXX Differential gain calibration makes the 6005 firmware
	 * crap out, so skip it for now.  This effectively disables
	 * sensitivity tuning as well.
	 */
	if (sc->hw_type == IWN_HW_REV_TYPE_6005)
		return;

	if (calib->state == IWN_CALIB_STATE_ASSOC)
		iwn_collect_noise(sc, &stats->rx.general);
	else if (calib->state == IWN_CALIB_STATE_RUN)
		iwn_tune_sensitivity(sc, &stats->rx);
}

/*
 * Process a TX_DONE firmware notification.  Unfortunately, the 4965AGN
 * and 5000 adapters have different incompatible TX status formats.
 */
void
iwn4965_tx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc,
    struct iwn_rx_data *data)
{
	struct iwn4965_tx_stat *stat = (struct iwn4965_tx_stat *)(desc + 1);
	struct iwn_tx_ring *ring = &sc->txq[desc->qid & 0xf];
	struct iwn_tx_data *txdata = &ring->data[desc->idx];
	/* XXX 4965 does not report byte count */
	uint16_t len = txdata->totlen + IEEE80211_CRC_LEN;

	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
	    sizeof (*stat), BUS_DMASYNC_POSTREAD);
	iwn_tx_done(sc, desc, stat->nframes, stat->ackfailcnt,
	    letoh32(stat->status) & 0xff, len);
}

void
iwn5000_tx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc,
    struct iwn_rx_data *data)
{
	struct iwn5000_tx_stat *stat = (struct iwn5000_tx_stat *)(desc + 1);

#ifdef notyet
	/* Reset TX scheduler slot. */
	iwn5000_reset_sched(sc, desc->qid & 0xf, desc->idx);
#endif

	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
	    sizeof (*stat), BUS_DMASYNC_POSTREAD);
	iwn_tx_done(sc, desc, stat->nframes, stat->ackfailcnt,
	    letoh16(stat->status) & 0xff, letoh16(stat->len));
}

/*
 * Adapter-independent backend for TX_DONE firmware notifications.
 */
void
iwn_tx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc, uint8_t nframes,
    uint8_t ackfailcnt, uint8_t status, uint16_t len)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct iwn_tx_ring *ring = &sc->txq[desc->qid & 0xf];
	struct iwn_tx_data *data = &ring->data[desc->idx];
	struct iwn_node *wn = (void *)data->ni;
	int txfail = (status != 1 && status != 2);

	KASSERT(nframes == 1); /* We don't support aggregation yet. */

	/* Update rate control statistics. */
	if (data->ni->ni_flags & IEEE80211_NODE_HT) {
		wn->mn.frames += nframes;
		wn->mn.ampdu_size = len;
		wn->mn.agglen = nframes; 
		if (ackfailcnt > 0)
			wn->mn.retries += ackfailcnt;
		if (txfail)
			wn->mn.txfail += nframes;
		if (ic->ic_state == IEEE80211_S_RUN)
			ieee80211_mira_choose(&wn->mn, ic, data->ni);
	} else {
		wn->amn.amn_txcnt++;
		if (ackfailcnt > 0)
			wn->amn.amn_retrycnt++;
	}
	if (txfail) {
		DPRINTF(("%s: status=0x%x\n", __func__, status));
		ifp->if_oerrors++;
	}

	/* Unmap and free mbuf. */
	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, data->map);
	m_freem(data->m);
	data->m = NULL;
	ieee80211_release_node(ic, data->ni);
	data->ni = NULL;

	sc->sc_tx_timer = 0;
	if (--ring->queued < IWN_TX_RING_LOMARK) {
		sc->qfullmsk &= ~(1 << ring->qid);
		if (sc->qfullmsk == 0 && ifq_is_oactive(&ifp->if_snd)) {
			ifq_clr_oactive(&ifp->if_snd);
			(*ifp->if_start)(ifp);
		}
	}
}

/*
 * Process a "command done" firmware notification.  This is where we wakeup
 * processes waiting for a synchronous command completion.
 */
void
iwn_cmd_done(struct iwn_softc *sc, struct iwn_rx_desc *desc)
{
	struct iwn_tx_ring *ring = &sc->txq[4];
	struct iwn_tx_data *data;

	if ((desc->qid & 0xf) != 4)
		return;	/* Not a command ack. */

	data = &ring->data[desc->idx];

	/* If the command was mapped in an mbuf, free it. */
	if (data->m != NULL) {
		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);
		data->m = NULL;
	}
	wakeup(&ring->desc[desc->idx]);
}

/*
 * Process an INT_FH_RX or INT_SW_RX interrupt.
 */
void
iwn_notif_intr(struct iwn_softc *sc)
{
	struct iwn_ops *ops = &sc->ops;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	uint16_t hw;

	bus_dmamap_sync(sc->sc_dmat, sc->rxq.stat_dma.map,
	    0, sc->rxq.stat_dma.size, BUS_DMASYNC_POSTREAD);

	hw = letoh16(sc->rxq.stat->closed_count) & 0xfff;
	while (sc->rxq.cur != hw) {
		struct iwn_rx_data *data = &sc->rxq.data[sc->rxq.cur];
		struct iwn_rx_desc *desc;

		bus_dmamap_sync(sc->sc_dmat, data->map, 0, sizeof (*desc),
		    BUS_DMASYNC_POSTREAD);
		desc = mtod(data->m, struct iwn_rx_desc *);

		DPRINTFN(4, ("notification qid=%d idx=%d flags=%x type=%d\n",
		    desc->qid & 0xf, desc->idx, desc->flags, desc->type));

		if (!(desc->qid & 0x80))	/* Reply to a command. */
			iwn_cmd_done(sc, desc);

		switch (desc->type) {
		case IWN_RX_PHY:
			iwn_rx_phy(sc, desc, data);
			break;

		case IWN_RX_DONE:		/* 4965AGN only. */
		case IWN_MPDU_RX_DONE:
			/* An 802.11 frame has been received. */
			iwn_rx_done(sc, desc, data);
			break;
		case IWN_RX_COMPRESSED_BA:
			/* A Compressed BlockAck has been received. */
			iwn_rx_compressed_ba(sc, desc, data);
			break;
		case IWN_TX_DONE:
			/* An 802.11 frame has been transmitted. */
			ops->tx_done(sc, desc, data);
			break;

		case IWN_RX_STATISTICS:
		case IWN_BEACON_STATISTICS:
			iwn_rx_statistics(sc, desc, data);
			break;

		case IWN_BEACON_MISSED:
		{
			struct iwn_beacon_missed *miss =
			    (struct iwn_beacon_missed *)(desc + 1);
			uint32_t missed;

			if ((ic->ic_opmode != IEEE80211_M_STA) ||
			    (ic->ic_state != IEEE80211_S_RUN))
				break;

			bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
			    sizeof (*miss), BUS_DMASYNC_POSTREAD);
			missed = letoh32(miss->consecutive);

			/*
			 * If more than 5 consecutive beacons are missed,
			 * reinitialize the sensitivity state machine.
			 */
			if (missed > 5)
				(void)iwn_init_sensitivity(sc);

			/*
			 * Rather than go directly to scan state, try to send a
			 * directed probe request first. If that fails then the
			 * state machine will drop us into scanning after timing
			 * out waiting for a probe response.
			 */
			if (missed > ic->ic_bmissthres && !ic->ic_mgt_timer)
				IEEE80211_SEND_MGMT(ic, ic->ic_bss,
				    IEEE80211_FC0_SUBTYPE_PROBE_REQ, 0);
			break;
		}
		case IWN_UC_READY:
		{
			struct iwn_ucode_info *uc =
			    (struct iwn_ucode_info *)(desc + 1);

			/* The microcontroller is ready. */
			bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
			    sizeof (*uc), BUS_DMASYNC_POSTREAD);
			DPRINTF(("microcode alive notification version=%d.%d "
			    "subtype=%x alive=%x\n", uc->major, uc->minor,
			    uc->subtype, letoh32(uc->valid)));

			if (letoh32(uc->valid) != 1) {
				printf("%s: microcontroller initialization "
				    "failed\n", sc->sc_dev.dv_xname);
				break;
			}
			if (uc->subtype == IWN_UCODE_INIT) {
				/* Save microcontroller report. */
				memcpy(&sc->ucode_info, uc, sizeof (*uc));
			}
			/* Save the address of the error log in SRAM. */
			sc->errptr = letoh32(uc->errptr);
			break;
		}
		case IWN_STATE_CHANGED:
		{
			uint32_t *status = (uint32_t *)(desc + 1);

			/* Enabled/disabled notification. */
			bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
			    sizeof (*status), BUS_DMASYNC_POSTREAD);
			DPRINTF(("state changed to %x\n", letoh32(*status)));

			if (letoh32(*status) & 1) {
				/* The radio button has to be pushed. */
				printf("%s: Radio transmitter is off\n",
				    sc->sc_dev.dv_xname);
				/* Turn the interface down. */
				iwn_stop(ifp, 1);
				return;	/* No further processing. */
			}
			break;
		}
		case IWN_START_SCAN:
		{
			struct iwn_start_scan *scan =
			    (struct iwn_start_scan *)(desc + 1);

			bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
			    sizeof (*scan), BUS_DMASYNC_POSTREAD);
			DPRINTFN(2, ("scanning channel %d status %x\n",
			    scan->chan, letoh32(scan->status)));

			/* Fix current channel. */
			ic->ic_bss->ni_chan = &ic->ic_channels[scan->chan];
			break;
		}
		case IWN_STOP_SCAN:
		{
			struct iwn_stop_scan *scan =
			    (struct iwn_stop_scan *)(desc + 1);

			bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
			    sizeof (*scan), BUS_DMASYNC_POSTREAD);
			DPRINTF(("scan finished nchan=%d status=%d chan=%d\n",
			    scan->nchan, scan->status, scan->chan));

			if (scan->status == 1 && scan->chan <= 14 &&
			    (sc->sc_flags & IWN_FLAG_HAS_5GHZ)) {
				/*
				 * We just finished scanning 2GHz channels,
				 * start scanning 5GHz ones.
				 */
				if (iwn_scan(sc, IEEE80211_CHAN_5GHZ) == 0)
					break;
			}
			ieee80211_end_scan(ifp);
			break;
		}
		case IWN5000_CALIBRATION_RESULT:
			iwn5000_rx_calib_results(sc, desc, data);
			break;

		case IWN5000_CALIBRATION_DONE:
			sc->sc_flags |= IWN_FLAG_CALIB_DONE;
			wakeup(sc);
			break;
		}

		sc->rxq.cur = (sc->rxq.cur + 1) % IWN_RX_RING_COUNT;
	}

	/* Tell the firmware what we have processed. */
	hw = (hw == 0) ? IWN_RX_RING_COUNT - 1 : hw - 1;
	IWN_WRITE(sc, IWN_FH_RX_WPTR, hw & ~7);
}

/*
 * Process an INT_WAKEUP interrupt raised when the microcontroller wakes up
 * from power-down sleep mode.
 */
void
iwn_wakeup_intr(struct iwn_softc *sc)
{
	int qid;

	DPRINTF(("ucode wakeup from power-down sleep\n"));

	/* Wakeup RX and TX rings. */
	IWN_WRITE(sc, IWN_FH_RX_WPTR, sc->rxq.cur & ~7);
	for (qid = 0; qid < sc->ntxqs; qid++) {
		struct iwn_tx_ring *ring = &sc->txq[qid];
		IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid << 8 | ring->cur);
	}
}

#ifdef IWN_DEBUG
/*
 * Dump the error log of the firmware when a firmware panic occurs.  Although
 * we can't debug the firmware because it is neither open source nor free, it
 * can help us to identify certain classes of problems.
 */
void
iwn_fatal_intr(struct iwn_softc *sc)
{
	struct iwn_fw_dump dump;
	int i;

	/* Check that the error log address is valid. */
	if (sc->errptr < IWN_FW_DATA_BASE ||
	    sc->errptr + sizeof (dump) >
	    IWN_FW_DATA_BASE + sc->fw_data_maxsz) {
		printf("%s: bad firmware error log address 0x%08x\n",
		    sc->sc_dev.dv_xname, sc->errptr);
		return;
	}
	if (iwn_nic_lock(sc) != 0) {
		printf("%s: could not read firmware error log\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	/* Read firmware error log from SRAM. */
	iwn_mem_read_region_4(sc, sc->errptr, (uint32_t *)&dump,
	    sizeof (dump) / sizeof (uint32_t));
	iwn_nic_unlock(sc);

	if (dump.valid == 0) {
		printf("%s: firmware error log is empty\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	printf("firmware error log:\n");
	printf("  error type      = \"%s\" (0x%08X)\n",
	    (dump.id < nitems(iwn_fw_errmsg)) ?
		iwn_fw_errmsg[dump.id] : "UNKNOWN",
	    dump.id);
	printf("  program counter = 0x%08X\n", dump.pc);
	printf("  source line     = 0x%08X\n", dump.src_line);
	printf("  error data      = 0x%08X%08X\n",
	    dump.error_data[0], dump.error_data[1]);
	printf("  branch link     = 0x%08X%08X\n",
	    dump.branch_link[0], dump.branch_link[1]);
	printf("  interrupt link  = 0x%08X%08X\n",
	    dump.interrupt_link[0], dump.interrupt_link[1]);
	printf("  time            = %u\n", dump.time[0]);

	/* Dump driver status (TX and RX rings) while we're here. */
	printf("driver status:\n");
	for (i = 0; i < sc->ntxqs; i++) {
		struct iwn_tx_ring *ring = &sc->txq[i];
		printf("  tx ring %2d: qid=%-2d cur=%-3d queued=%-3d\n",
		    i, ring->qid, ring->cur, ring->queued);
	}
	printf("  rx ring: cur=%d\n", sc->rxq.cur);
	printf("  802.11 state %d\n", sc->sc_ic.ic_state);
}
#endif

int
iwn_intr(void *arg)
{
	struct iwn_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t r1, r2, tmp;

	/* Disable interrupts. */
	IWN_WRITE(sc, IWN_INT_MASK, 0);

	/* Read interrupts from ICT (fast) or from registers (slow). */
	if (sc->sc_flags & IWN_FLAG_USE_ICT) {
		tmp = 0;
		while (sc->ict[sc->ict_cur] != 0) {
			tmp |= sc->ict[sc->ict_cur];
			sc->ict[sc->ict_cur] = 0;	/* Acknowledge. */
			sc->ict_cur = (sc->ict_cur + 1) % IWN_ICT_COUNT;
		}
		tmp = letoh32(tmp);
		if (tmp == 0xffffffff)	/* Shouldn't happen. */
			tmp = 0;
		else if (tmp & 0xc0000)	/* Workaround a HW bug. */
			tmp |= 0x8000;
		r1 = (tmp & 0xff00) << 16 | (tmp & 0xff);
		r2 = 0;	/* Unused. */
	} else {
		r1 = IWN_READ(sc, IWN_INT);
		if (r1 == 0xffffffff || (r1 & 0xfffffff0) == 0xa5a5a5a0)
			return 0;	/* Hardware gone! */
		r2 = IWN_READ(sc, IWN_FH_INT);
	}
	if (r1 == 0 && r2 == 0) {
		if (ifp->if_flags & IFF_UP)
			IWN_WRITE(sc, IWN_INT_MASK, sc->int_mask);
		return 0;	/* Interrupt not for us. */
	}

	/* Acknowledge interrupts. */
	IWN_WRITE(sc, IWN_INT, r1);
	if (!(sc->sc_flags & IWN_FLAG_USE_ICT))
		IWN_WRITE(sc, IWN_FH_INT, r2);

	if (r1 & IWN_INT_RF_TOGGLED) {
		tmp = IWN_READ(sc, IWN_GP_CNTRL);
		printf("%s: RF switch: radio %s\n", sc->sc_dev.dv_xname,
		    (tmp & IWN_GP_CNTRL_RFKILL) ? "enabled" : "disabled");
	}
	if (r1 & IWN_INT_CT_REACHED) {
		printf("%s: critical temperature reached!\n",
		    sc->sc_dev.dv_xname);
	}
	if (r1 & (IWN_INT_SW_ERR | IWN_INT_HW_ERR)) {
		printf("%s: fatal firmware error\n", sc->sc_dev.dv_xname);

		/* Force a complete recalibration on next init. */
		sc->sc_flags &= ~IWN_FLAG_CALIB_DONE;

		/* Dump firmware error log and stop. */
#ifdef IWN_DEBUG
		iwn_fatal_intr(sc);
#endif
		iwn_stop(ifp, 1);
		task_add(systq, &sc->init_task);
		return 1;
	}
	if ((r1 & (IWN_INT_FH_RX | IWN_INT_SW_RX | IWN_INT_RX_PERIODIC)) ||
	    (r2 & IWN_FH_INT_RX)) {
		if (sc->sc_flags & IWN_FLAG_USE_ICT) {
			if (r1 & (IWN_INT_FH_RX | IWN_INT_SW_RX))
				IWN_WRITE(sc, IWN_FH_INT, IWN_FH_INT_RX);
			IWN_WRITE_1(sc, IWN_INT_PERIODIC,
			    IWN_INT_PERIODIC_DIS);
			iwn_notif_intr(sc);
			if (r1 & (IWN_INT_FH_RX | IWN_INT_SW_RX)) {
				IWN_WRITE_1(sc, IWN_INT_PERIODIC,
				    IWN_INT_PERIODIC_ENA);
			}
		} else
			iwn_notif_intr(sc);
	}

	if ((r1 & IWN_INT_FH_TX) || (r2 & IWN_FH_INT_TX)) {
		if (sc->sc_flags & IWN_FLAG_USE_ICT)
			IWN_WRITE(sc, IWN_FH_INT, IWN_FH_INT_TX);
		wakeup(sc);	/* FH DMA transfer completed. */
	}

	if (r1 & IWN_INT_ALIVE)
		wakeup(sc);	/* Firmware is alive. */

	if (r1 & IWN_INT_WAKEUP)
		iwn_wakeup_intr(sc);

	/* Re-enable interrupts. */
	if (ifp->if_flags & IFF_UP)
		IWN_WRITE(sc, IWN_INT_MASK, sc->int_mask);

	return 1;
}

/*
 * Update TX scheduler ring when transmitting an 802.11 frame (4965AGN and
 * 5000 adapters use a slightly different format).
 */
void
iwn4965_update_sched(struct iwn_softc *sc, int qid, int idx, uint8_t id,
    uint16_t len)
{
	uint16_t *w = &sc->sched[qid * IWN4965_SCHED_COUNT + idx];

	*w = htole16(len + 8);
	bus_dmamap_sync(sc->sc_dmat, sc->sched_dma.map,
	    (caddr_t)w - sc->sched_dma.vaddr, sizeof (uint16_t),
	    BUS_DMASYNC_PREWRITE);
	if (idx < IWN_SCHED_WINSZ) {
		*(w + IWN_TX_RING_COUNT) = *w;
		bus_dmamap_sync(sc->sc_dmat, sc->sched_dma.map,
		    (caddr_t)(w + IWN_TX_RING_COUNT) - sc->sched_dma.vaddr,
		    sizeof (uint16_t), BUS_DMASYNC_PREWRITE);
	}
}

void
iwn5000_update_sched(struct iwn_softc *sc, int qid, int idx, uint8_t id,
    uint16_t len)
{
	uint16_t *w = &sc->sched[qid * IWN5000_SCHED_COUNT + idx];

	*w = htole16(id << 12 | (len + 8));
	bus_dmamap_sync(sc->sc_dmat, sc->sched_dma.map,
	    (caddr_t)w - sc->sched_dma.vaddr, sizeof (uint16_t),
	    BUS_DMASYNC_PREWRITE);
	if (idx < IWN_SCHED_WINSZ) {
		*(w + IWN_TX_RING_COUNT) = *w;
		bus_dmamap_sync(sc->sc_dmat, sc->sched_dma.map,
		    (caddr_t)(w + IWN_TX_RING_COUNT) - sc->sched_dma.vaddr,
		    sizeof (uint16_t), BUS_DMASYNC_PREWRITE);
	}
}

void
iwn5000_reset_sched(struct iwn_softc *sc, int qid, int idx)
{
	uint16_t *w = &sc->sched[qid * IWN5000_SCHED_COUNT + idx];

	*w = (*w & htole16(0xf000)) | htole16(1);
	bus_dmamap_sync(sc->sc_dmat, sc->sched_dma.map,
	    (caddr_t)w - sc->sched_dma.vaddr, sizeof (uint16_t),
	    BUS_DMASYNC_PREWRITE);
	if (idx < IWN_SCHED_WINSZ) {
		*(w + IWN_TX_RING_COUNT) = *w;
		bus_dmamap_sync(sc->sc_dmat, sc->sched_dma.map,
		    (caddr_t)(w + IWN_TX_RING_COUNT) - sc->sched_dma.vaddr,
		    sizeof (uint16_t), BUS_DMASYNC_PREWRITE);
	}
}

int
iwn_rval2ridx(int rval)
{
	int ridx;

	for (ridx = 0; ridx < nitems(iwn_rates); ridx++) {
		if (rval == iwn_rates[ridx].rate)
			break;
	}

	return ridx;
}

int
iwn_tx(struct iwn_softc *sc, struct mbuf *m, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwn_node *wn = (void *)ni;
	struct iwn_tx_ring *ring;
	struct iwn_tx_desc *desc;
	struct iwn_tx_data *data;
	struct iwn_tx_cmd *cmd;
	struct iwn_cmd_data *tx;
	const struct iwn_rate *rinfo;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k = NULL;
	enum ieee80211_edca_ac ac;
	uint32_t flags;
	uint16_t qos;
	u_int hdrlen;
	bus_dma_segment_t *seg;
	uint8_t *ivp, tid, ridx, txant, type;
	int i, totlen, hasqos, error, pad;

	wh = mtod(m, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;

	/* Select EDCA Access Category and TX ring for this frame. */
	if ((hasqos = ieee80211_has_qos(wh))) {
		qos = ieee80211_get_qos(wh);
		tid = qos & IEEE80211_QOS_TID;
		ac = ieee80211_up_to_ac(ic, tid);
	} else {
		qos = 0;
		tid = 0;
		ac = EDCA_AC_BE;
	}

	ring = &sc->txq[ac];
	desc = &ring->desc[ring->cur];
	data = &ring->data[ring->cur];

	/* Choose a TX rate index. */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    type != IEEE80211_FC0_TYPE_DATA)
		ridx = iwn_rval2ridx(ieee80211_min_basic_rate(ic));
	else if (ic->ic_fixed_mcs != -1)
		ridx = sc->fixed_ridx;
	else if (ic->ic_fixed_rate != -1)
		ridx = sc->fixed_ridx;
	else {
		if (ni->ni_flags & IEEE80211_NODE_HT)
			ridx = iwn_mcs2ridx[ni->ni_txmcs];
		else
			ridx = wn->ridx[ni->ni_txrate];
	}	
	rinfo = &iwn_rates[ridx];
#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct iwn_tx_radiotap_header *tap = &sc->sc_txtap;
		uint16_t chan_flags;

		tap->wt_flags = 0;
		tap->wt_chan_freq = htole16(ni->ni_chan->ic_freq);
		chan_flags = ni->ni_chan->ic_flags;
		if (ic->ic_curmode != IEEE80211_MODE_11N)
			chan_flags &= ~IEEE80211_CHAN_HT;
		tap->wt_chan_flags = htole16(chan_flags);
		if ((ni->ni_flags & IEEE80211_NODE_HT) &&
		    !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
		    type == IEEE80211_FC0_TYPE_DATA) {
			tap->wt_rate = (0x80 | ni->ni_txmcs);
		} else
			tap->wt_rate = rinfo->rate;
		tap->wt_hwqueue = ac;
		if ((ic->ic_flags & IEEE80211_F_WEPON) &&
		    (wh->i_fc[1] & IEEE80211_FC1_PROTECTED))
			tap->wt_flags |= IEEE80211_RADIOTAP_F_WEP;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	totlen = m->m_pkthdr.len;

	/* Encrypt the frame if need be. */
	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		/* Retrieve key for TX. */
		k = ieee80211_get_txkey(ic, wh, ni);
		if (k->k_cipher != IEEE80211_CIPHER_CCMP) {
			/* Do software encryption. */
			if ((m = ieee80211_encrypt(ic, m, k)) == NULL)
				return ENOBUFS;
			/* 802.11 header may have moved. */
			wh = mtod(m, struct ieee80211_frame *);
			totlen = m->m_pkthdr.len;

		} else	/* HW appends CCMP MIC. */
			totlen += IEEE80211_CCMP_HDRLEN;
	}

	data->totlen = totlen;

	/* Prepare TX firmware command. */
	cmd = &ring->cmd[ring->cur];
	cmd->code = IWN_CMD_TX_DATA;
	cmd->flags = 0;
	cmd->qid = ring->qid;
	cmd->idx = ring->cur;

	tx = (struct iwn_cmd_data *)cmd->data;
	/* NB: No need to clear tx, all fields are reinitialized here. */
	tx->scratch = 0;	/* clear "scratch" area */

	flags = 0;
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* Unicast frame, check if an ACK is expected. */
		if (!hasqos || (qos & IEEE80211_QOS_ACK_POLICY_MASK) !=
		    IEEE80211_QOS_ACK_POLICY_NOACK)
			flags |= IWN_TX_NEED_ACK;
	}
	if ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
	    (IEEE80211_FC0_TYPE_CTL | IEEE80211_FC0_SUBTYPE_BAR))
		flags |= IWN_TX_IMM_BA;		/* Cannot happen yet. */

	if (wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG)
		flags |= IWN_TX_MORE_FRAG;	/* Cannot happen yet. */

	/* Check if frame must be protected using RTS/CTS or CTS-to-self. */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* NB: Group frames are sent using CCK in 802.11b/g/n (2GHz). */
		if (totlen + IEEE80211_CRC_LEN > ic->ic_rtsthreshold) {
			flags |= IWN_TX_NEED_RTS;
		} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
		    ridx >= IWN_RIDX_OFDM6) {
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
				flags |= IWN_TX_NEED_CTS;
			else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
				flags |= IWN_TX_NEED_RTS;
		}

		if (flags & (IWN_TX_NEED_RTS | IWN_TX_NEED_CTS)) {
			if (sc->hw_type != IWN_HW_REV_TYPE_4965) {
				/* 5000 autoselects RTS/CTS or CTS-to-self. */
				flags &= ~(IWN_TX_NEED_RTS | IWN_TX_NEED_CTS);
				flags |= IWN_TX_NEED_PROTECTION;
			} else
				flags |= IWN_TX_FULL_TXOP;
		}
	}

	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    type != IEEE80211_FC0_TYPE_DATA)
		tx->id = sc->broadcast_id;
	else
		tx->id = wn->id;

	if (type == IEEE80211_FC0_TYPE_MGT) {
		uint8_t subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

#ifndef IEEE80211_STA_ONLY
		/* Tell HW to set timestamp in probe responses. */
		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
			flags |= IWN_TX_INSERT_TSTAMP;
#endif
		if (subtype == IEEE80211_FC0_SUBTYPE_ASSOC_REQ ||
		    subtype == IEEE80211_FC0_SUBTYPE_REASSOC_REQ)
			tx->timeout = htole16(3);
		else
			tx->timeout = htole16(2);
	} else
		tx->timeout = htole16(0);

	if (hdrlen & 3) {
		/* First segment length must be a multiple of 4. */
		flags |= IWN_TX_NEED_PADDING;
		pad = 4 - (hdrlen & 3);
	} else
		pad = 0;

	tx->len = htole16(totlen);
	tx->tid = tid;
	tx->rts_ntries = 60;
	tx->data_ntries = 15;
	tx->lifetime = htole32(IWN_LIFETIME_INFINITE);

	if ((ni->ni_flags & IEEE80211_NODE_HT) &&
	    tx->id != sc->broadcast_id)
		tx->plcp = rinfo->ht_plcp;
	else
		tx->plcp = rinfo->plcp;

	if ((ni->ni_flags & IEEE80211_NODE_HT) &&
	    tx->id != sc->broadcast_id) {
		tx->rflags = rinfo->ht_flags;
		if (ni->ni_htcaps & IEEE80211_HTCAP_SGI20)
			tx->rflags |= IWN_RFLAG_SGI;
	}
	else
		tx->rflags = rinfo->flags;
	if (tx->id == sc->broadcast_id) {
		/* Group or management frame. */
		tx->linkq = 0;
		/* XXX Alternate between antenna A and B? */
		txant = IWN_LSB(sc->txchainmask);
		tx->rflags |= IWN_RFLAG_ANT(txant);
	} else {
		if (ni->ni_flags & IEEE80211_NODE_HT)
			tx->linkq = 7 - ni->ni_txmcs; /* XXX revisit for MIMO */
		else
			tx->linkq = ni->ni_rates.rs_nrates - ni->ni_txrate - 1;
		flags |= IWN_TX_LINKQ;	/* enable MRR */
	}
	/* Set physical address of "scratch area". */
	tx->loaddr = htole32(IWN_LOADDR(data->scratch_paddr));
	tx->hiaddr = IWN_HIADDR(data->scratch_paddr);

	/* Copy 802.11 header in TX command. */
	memcpy((uint8_t *)(tx + 1), wh, hdrlen);

	if (k != NULL && k->k_cipher == IEEE80211_CIPHER_CCMP) {
		/* Trim 802.11 header and prepend CCMP IV. */
		m_adj(m, hdrlen - IEEE80211_CCMP_HDRLEN);
		ivp = mtod(m, uint8_t *);
		k->k_tsc++;
		ivp[0] = k->k_tsc;
		ivp[1] = k->k_tsc >> 8;
		ivp[2] = 0;
		ivp[3] = k->k_id << 6 | IEEE80211_WEP_EXTIV;
		ivp[4] = k->k_tsc >> 16;
		ivp[5] = k->k_tsc >> 24;
		ivp[6] = k->k_tsc >> 32;
		ivp[7] = k->k_tsc >> 40;

		tx->security = IWN_CIPHER_CCMP;
		/* XXX flags |= IWN_TX_AMPDU_CCMP; */
		memcpy(tx->key, k->k_key, k->k_len);

		/* TX scheduler includes CCMP MIC len w/5000 Series. */
		if (sc->hw_type != IWN_HW_REV_TYPE_4965)
			totlen += IEEE80211_CCMP_MICLEN;
	} else {
		/* Trim 802.11 header. */
		m_adj(m, hdrlen);
		tx->security = 0;
	}
	tx->flags = htole32(flags);

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
	    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
	if (error != 0 && error != EFBIG) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m);
		return error;
	}
	if (error != 0) {
		/* Too many DMA segments, linearize mbuf. */
		if (m_defrag(m, M_DONTWAIT)) {
			m_freem(m);
			return ENOBUFS;
		}
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
		    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m);
			return error;
		}
	}

	data->m = m;
	data->ni = ni;

	DPRINTFN(4, ("sending data: qid=%d idx=%d len=%d nsegs=%d\n",
	    ring->qid, ring->cur, m->m_pkthdr.len, data->map->dm_nsegs));

	/* Fill TX descriptor. */
	desc->nsegs = 1 + data->map->dm_nsegs;
	/* First DMA segment is used by the TX command. */
	desc->segs[0].addr = htole32(IWN_LOADDR(data->cmd_paddr));
	desc->segs[0].len  = htole16(IWN_HIADDR(data->cmd_paddr) |
	    (4 + sizeof (*tx) + hdrlen + pad) << 4);
	/* Other DMA segments are for data payload. */
	seg = data->map->dm_segs;
	for (i = 1; i <= data->map->dm_nsegs; i++) {
		desc->segs[i].addr = htole32(IWN_LOADDR(seg->ds_addr));
		desc->segs[i].len  = htole16(IWN_HIADDR(seg->ds_addr) |
		    seg->ds_len << 4);
		seg++;
	}

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, ring->cmd_dma.map,
	    (caddr_t)cmd - ring->cmd_dma.vaddr, sizeof (*cmd),
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
	    (caddr_t)desc - ring->desc_dma.vaddr, sizeof (*desc),
	    BUS_DMASYNC_PREWRITE);

#ifdef notyet
	/* Update TX scheduler. */
	ops->update_sched(sc, ring->qid, ring->cur, tx->id, totlen);
#endif

	/* Kick TX ring. */
	ring->cur = (ring->cur + 1) % IWN_TX_RING_COUNT;
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, ring->qid << 8 | ring->cur);

	/* Mark TX ring as full if we reach a certain threshold. */
	if (++ring->queued > IWN_TX_RING_HIMARK)
		sc->qfullmsk |= 1 << ring->qid;

	return 0;
}

void
iwn_start(struct ifnet *ifp)
{
	struct iwn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (sc->qfullmsk != 0) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
		/* Send pending management frames first. */
		m = mq_dequeue(&ic->ic_mgtq);
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;
			goto sendit;
		}
		if (ic->ic_state != IEEE80211_S_RUN)
			break;

		/* Encapsulate and send data frames. */
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;
#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		if ((m = ieee80211_encap(ifp, m, &ni)) == NULL)
			continue;
sendit:
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		if (iwn_tx(sc, m, ni) != 0) {
			ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			continue;
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
iwn_watchdog(struct ifnet *ifp)
{
	struct iwn_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			iwn_stop(ifp, 1);
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
iwn_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct iwn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	error = rw_enter(&sc->sc_rwlock, RW_WRITE | RW_INTR);
	if (error)
		return error;
	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING))
				error = iwn_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				iwn_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;

	case SIOCS80211POWER:
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error != ENETRESET)
			break;
		if (ic->ic_state == IEEE80211_S_RUN &&
		    sc->calib.state == IWN_CALIB_STATE_RUN) {
			if (ic->ic_flags & IEEE80211_F_PMGTON)
				error = iwn_set_pslevel(sc, 0, 3, 0);
			else	/* back to CAM */
				error = iwn_set_pslevel(sc, 0, 0, 0);
		} else {
			/* Defer until transition to IWN_CALIB_STATE_RUN. */
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		error = 0;
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING)) {
			iwn_stop(ifp, 0);
			error = iwn_init(ifp);
		}
	}

	splx(s);
	rw_exit_write(&sc->sc_rwlock);
	return error;
}

/*
 * Send a command to the firmware.
 */
int
iwn_cmd(struct iwn_softc *sc, int code, const void *buf, int size, int async)
{
	struct iwn_tx_ring *ring = &sc->txq[4];
	struct iwn_tx_desc *desc;
	struct iwn_tx_data *data;
	struct iwn_tx_cmd *cmd;
	struct mbuf *m;
	bus_addr_t paddr;
	int totlen, error;

	desc = &ring->desc[ring->cur];
	data = &ring->data[ring->cur];
	totlen = 4 + size;

	if (size > sizeof cmd->data) {
		/* Command is too large to fit in a descriptor. */
		if (totlen > MCLBYTES)
			return EINVAL;
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL)
			return ENOMEM;
		if (totlen > MHLEN) {
			MCLGET(m, M_DONTWAIT);
			if (!(m->m_flags & M_EXT)) {
				m_freem(m);
				return ENOMEM;
			}
		}
		cmd = mtod(m, struct iwn_tx_cmd *);
		error = bus_dmamap_load(sc->sc_dmat, data->map, cmd, totlen,
		    NULL, BUS_DMA_NOWAIT | BUS_DMA_WRITE);
		if (error != 0) {
			m_freem(m);
			return error;
		}
		data->m = m;
		paddr = data->map->dm_segs[0].ds_addr;
	} else {
		cmd = &ring->cmd[ring->cur];
		paddr = data->cmd_paddr;
	}

	cmd->code = code;
	cmd->flags = 0;
	cmd->qid = ring->qid;
	cmd->idx = ring->cur;
	memcpy(cmd->data, buf, size);

	desc->nsegs = 1;
	desc->segs[0].addr = htole32(IWN_LOADDR(paddr));
	desc->segs[0].len  = htole16(IWN_HIADDR(paddr) | totlen << 4);

	if (size > sizeof cmd->data) {
		bus_dmamap_sync(sc->sc_dmat, data->map, 0, totlen,
		    BUS_DMASYNC_PREWRITE);
	} else {
		bus_dmamap_sync(sc->sc_dmat, ring->cmd_dma.map,
		    (caddr_t)cmd - ring->cmd_dma.vaddr, totlen,
		    BUS_DMASYNC_PREWRITE);
	}
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
	    (caddr_t)desc - ring->desc_dma.vaddr, sizeof (*desc),
	    BUS_DMASYNC_PREWRITE);

#ifdef notyet
	/* Update TX scheduler. */
	ops->update_sched(sc, ring->qid, ring->cur, 0, 0);
#endif

	/* Kick command ring. */
	ring->cur = (ring->cur + 1) % IWN_TX_RING_COUNT;
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, ring->qid << 8 | ring->cur);

	return async ? 0 : tsleep(desc, PCATCH, "iwncmd", hz);
}

int
iwn4965_add_node(struct iwn_softc *sc, struct iwn_node_info *node, int async)
{
	struct iwn4965_node_info hnode;
	caddr_t src, dst;

	/*
	 * We use the node structure for 5000 Series internally (it is
	 * a superset of the one for 4965AGN). We thus copy the common
	 * fields before sending the command.
	 */
	src = (caddr_t)node;
	dst = (caddr_t)&hnode;
	memcpy(dst, src, 48);
	/* Skip TSC, RX MIC and TX MIC fields from ``src''. */
	memcpy(dst + 48, src + 72, 20);
	return iwn_cmd(sc, IWN_CMD_ADD_NODE, &hnode, sizeof hnode, async);
}

int
iwn5000_add_node(struct iwn_softc *sc, struct iwn_node_info *node, int async)
{
	/* Direct mapping. */
	return iwn_cmd(sc, IWN_CMD_ADD_NODE, node, sizeof (*node), async);
}

int
iwn_set_link_quality(struct iwn_softc *sc, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwn_node *wn = (void *)ni;
	struct ieee80211_rateset *rs = &ni->ni_rates;
	struct iwn_cmd_link_quality linkq;
	const struct iwn_rate *rinfo;
	uint8_t txant;
	int i, txrate;

	/* Use the first valid TX antenna. */
	txant = IWN_LSB(sc->txchainmask);

	memset(&linkq, 0, sizeof linkq);
	linkq.id = wn->id;
	linkq.antmsk_1stream = txant;
	linkq.antmsk_2stream = IWN_ANT_AB;
	linkq.ampdu_max = IWN_AMPDU_MAX;
	linkq.ampdu_threshold = 3;
	linkq.ampdu_limit = htole16(4000);	/* 4ms */

	if (ni->ni_flags & IEEE80211_NODE_HT) {
		/* Fill LQ table with MCS 7 - 0 (XXX revisit for MIMO) */
		i = 0;
		for (txrate = 7; txrate >= 0; txrate--) {
			rinfo = &iwn_rates[iwn_mcs2ridx[txrate]];
			linkq.retry[i].plcp = rinfo->ht_plcp;
			linkq.retry[i].rflags = rinfo->ht_flags;

			if (ni->ni_htcaps & IEEE80211_HTCAP_SGI20)
				linkq.retry[i].rflags |= IWN_RFLAG_SGI;

			/* XXX set correct ant mask for MIMO rates here */
			linkq.retry[i].rflags |= IWN_RFLAG_ANT(txant);

			if (++i >= IWN_MAX_TX_RETRIES)
				break;
		}

		/* Fill the rest with the lowest basic rate. */
		rinfo = &iwn_rates[iwn_rval2ridx(ieee80211_min_basic_rate(ic))];
		while (i < IWN_MAX_TX_RETRIES) {
			linkq.retry[i].plcp = rinfo->plcp;
			linkq.retry[i].rflags = rinfo->flags;
			linkq.retry[i].rflags |= IWN_RFLAG_ANT(txant);
			i++;
		}
	} else {
		/* Start at highest available bit-rate. */
		txrate = rs->rs_nrates - 1;
		for (i = 0; i < IWN_MAX_TX_RETRIES; i++) {
			rinfo = &iwn_rates[wn->ridx[txrate]];
			linkq.retry[i].plcp = rinfo->plcp;
			linkq.retry[i].rflags = rinfo->flags;
			linkq.retry[i].rflags |= IWN_RFLAG_ANT(txant);
			/* Next retry at immediate lower bit-rate. */
			if (txrate > 0)
				txrate--;
		}
	}

	return iwn_cmd(sc, IWN_CMD_LINK_QUALITY, &linkq, sizeof linkq, 1);
}

/*
 * Broadcast node is used to send group-addressed and management frames.
 */
int
iwn_add_broadcast_node(struct iwn_softc *sc, int async, int ridx)
{
	struct iwn_ops *ops = &sc->ops;
	struct iwn_node_info node;
	struct iwn_cmd_link_quality linkq;
	const struct iwn_rate *rinfo;
	uint8_t txant;
	int i, error;

	memset(&node, 0, sizeof node);
	IEEE80211_ADDR_COPY(node.macaddr, etherbroadcastaddr);
	node.id = sc->broadcast_id;
	DPRINTF(("adding broadcast node\n"));
	if ((error = ops->add_node(sc, &node, async)) != 0)
		return error;

	/* Use the first valid TX antenna. */
	txant = IWN_LSB(sc->txchainmask);

	memset(&linkq, 0, sizeof linkq);
	linkq.id = sc->broadcast_id;
	linkq.antmsk_1stream = txant;
	linkq.antmsk_2stream = IWN_ANT_AB;
	linkq.ampdu_max = IWN_AMPDU_MAX_NO_AGG;
	linkq.ampdu_threshold = 3;
	linkq.ampdu_limit = htole16(4000);	/* 4ms */

	/* Use lowest mandatory bit-rate. */
	rinfo = &iwn_rates[ridx];
	linkq.retry[0].plcp = rinfo->plcp;
	linkq.retry[0].rflags = rinfo->flags;
	linkq.retry[0].rflags |= IWN_RFLAG_ANT(txant);
	/* Use same bit-rate for all TX retries. */
	for (i = 1; i < IWN_MAX_TX_RETRIES; i++) {
		linkq.retry[i].plcp = linkq.retry[0].plcp;
		linkq.retry[i].rflags = linkq.retry[0].rflags;
	}
	return iwn_cmd(sc, IWN_CMD_LINK_QUALITY, &linkq, sizeof linkq, async);
}

void
iwn_updateedca(struct ieee80211com *ic)
{
#define IWN_EXP2(x)	((1 << (x)) - 1)	/* CWmin = 2^ECWmin - 1 */
	struct iwn_softc *sc = ic->ic_softc;
	struct iwn_edca_params cmd;
	int aci;

	memset(&cmd, 0, sizeof cmd);
	cmd.flags = htole32(IWN_EDCA_UPDATE);
	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		const struct ieee80211_edca_ac_params *ac =
		    &ic->ic_edca_ac[aci];
		cmd.ac[aci].aifsn = ac->ac_aifsn;
		cmd.ac[aci].cwmin = htole16(IWN_EXP2(ac->ac_ecwmin));
		cmd.ac[aci].cwmax = htole16(IWN_EXP2(ac->ac_ecwmax));
		cmd.ac[aci].txoplimit =
		    htole16(IEEE80211_TXOP_TO_US(ac->ac_txoplimit));
	}
	(void)iwn_cmd(sc, IWN_CMD_EDCA_PARAMS, &cmd, sizeof cmd, 1);
#undef IWN_EXP2
}

void
iwn_set_led(struct iwn_softc *sc, uint8_t which, uint8_t off, uint8_t on)
{
	struct iwn_cmd_led led;

	/* Clear microcode LED ownership. */
	IWN_CLRBITS(sc, IWN_LED, IWN_LED_BSM_CTRL);

	led.which = which;
	led.unit = htole32(10000);	/* on/off in unit of 100ms */
	led.off = off;
	led.on = on;
	(void)iwn_cmd(sc, IWN_CMD_SET_LED, &led, sizeof led, 1);
}

/*
 * Set the critical temperature at which the firmware will stop the radio
 * and notify us.
 */
int
iwn_set_critical_temp(struct iwn_softc *sc)
{
	struct iwn_critical_temp crit;
	int32_t temp;

	IWN_WRITE(sc, IWN_UCODE_GP1_CLR, IWN_UCODE_GP1_CTEMP_STOP_RF);

	if (sc->hw_type == IWN_HW_REV_TYPE_5150)
		temp = (IWN_CTOK(110) - sc->temp_off) * -5;
	else if (sc->hw_type == IWN_HW_REV_TYPE_4965)
		temp = IWN_CTOK(110);
	else
		temp = 110;
	memset(&crit, 0, sizeof crit);
	crit.tempR = htole32(temp);
	DPRINTF(("setting critical temperature to %d\n", temp));
	return iwn_cmd(sc, IWN_CMD_SET_CRITICAL_TEMP, &crit, sizeof crit, 0);
}

int
iwn_set_timing(struct iwn_softc *sc, struct ieee80211_node *ni)
{
	struct iwn_cmd_timing cmd;
	uint64_t val, mod;

	memset(&cmd, 0, sizeof cmd);
	memcpy(&cmd.tstamp, ni->ni_tstamp, sizeof (uint64_t));
	cmd.bintval = htole16(ni->ni_intval);
	cmd.lintval = htole16(10);

	/* Compute remaining time until next beacon. */
	val = (uint64_t)ni->ni_intval * IEEE80211_DUR_TU;
	mod = letoh64(cmd.tstamp) % val;
	cmd.binitval = htole32((uint32_t)(val - mod));

	DPRINTF(("timing bintval=%u, tstamp=%llu, init=%u\n",
	    ni->ni_intval, letoh64(cmd.tstamp), (uint32_t)(val - mod)));

	return iwn_cmd(sc, IWN_CMD_TIMING, &cmd, sizeof cmd, 1);
}

void
iwn4965_power_calibration(struct iwn_softc *sc, int temp)
{
	/* Adjust TX power if need be (delta >= 3 degC). */
	DPRINTF(("temperature %d->%d\n", sc->temp, temp));
	if (abs(temp - sc->temp) >= 3) {
		/* Record temperature of last calibration. */
		sc->temp = temp;
		(void)iwn4965_set_txpower(sc, 1);
	}
}

/*
 * Set TX power for current channel (each rate has its own power settings).
 * This function takes into account the regulatory information from EEPROM,
 * the current temperature and the current voltage.
 */
int
iwn4965_set_txpower(struct iwn_softc *sc, int async)
{
/* Fixed-point arithmetic division using a n-bit fractional part. */
#define fdivround(a, b, n)	\
	((((1 << n) * (a)) / (b) + (1 << n) / 2) / (1 << n))
/* Linear interpolation. */
#define interpolate(x, x1, y1, x2, y2, n)	\
	((y1) + fdivround(((int)(x) - (x1)) * ((y2) - (y1)), (x2) - (x1), n))

	static const int tdiv[IWN_NATTEN_GROUPS] = { 9, 8, 8, 8, 6 };
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwn_ucode_info *uc = &sc->ucode_info;
	struct ieee80211_channel *ch;
	struct iwn4965_cmd_txpower cmd;
	struct iwn4965_eeprom_chan_samples *chans;
	const uint8_t *rf_gain, *dsp_gain;
	int32_t vdiff, tdiff;
	int i, c, grp, maxpwr;
	uint8_t chan;

	/* Retrieve current channel from last RXON. */
	chan = sc->rxon.chan;
	DPRINTF(("setting TX power for channel %d\n", chan));
	ch = &ic->ic_channels[chan];

	memset(&cmd, 0, sizeof cmd);
	cmd.band = IEEE80211_IS_CHAN_5GHZ(ch) ? 0 : 1;
	cmd.chan = chan;

	if (IEEE80211_IS_CHAN_5GHZ(ch)) {
		maxpwr   = sc->maxpwr5GHz;
		rf_gain  = iwn4965_rf_gain_5ghz;
		dsp_gain = iwn4965_dsp_gain_5ghz;
	} else {
		maxpwr   = sc->maxpwr2GHz;
		rf_gain  = iwn4965_rf_gain_2ghz;
		dsp_gain = iwn4965_dsp_gain_2ghz;
	}

	/* Compute voltage compensation. */
	vdiff = ((int32_t)letoh32(uc->volt) - sc->eeprom_voltage) / 7;
	if (vdiff > 0)
		vdiff *= 2;
	if (abs(vdiff) > 2)
		vdiff = 0;
	DPRINTF(("voltage compensation=%d (UCODE=%d, EEPROM=%d)\n",
	    vdiff, letoh32(uc->volt), sc->eeprom_voltage));

	/* Get channel attenuation group. */
	if (chan <= 20)		/* 1-20 */
		grp = 4;
	else if (chan <= 43)	/* 34-43 */
		grp = 0;
	else if (chan <= 70)	/* 44-70 */
		grp = 1;
	else if (chan <= 124)	/* 71-124 */
		grp = 2;
	else			/* 125-200 */
		grp = 3;
	DPRINTF(("chan %d, attenuation group=%d\n", chan, grp));

	/* Get channel sub-band. */
	for (i = 0; i < IWN_NBANDS; i++)
		if (sc->bands[i].lo != 0 &&
		    sc->bands[i].lo <= chan && chan <= sc->bands[i].hi)
			break;
	if (i == IWN_NBANDS)	/* Can't happen in real-life. */
		return EINVAL;
	chans = sc->bands[i].chans;
	DPRINTF(("chan %d sub-band=%d\n", chan, i));

	for (c = 0; c < 2; c++) {
		uint8_t power, gain, temp;
		int maxchpwr, pwr, ridx, idx;

		power = interpolate(chan,
		    chans[0].num, chans[0].samples[c][1].power,
		    chans[1].num, chans[1].samples[c][1].power, 1);
		gain  = interpolate(chan,
		    chans[0].num, chans[0].samples[c][1].gain,
		    chans[1].num, chans[1].samples[c][1].gain, 1);
		temp  = interpolate(chan,
		    chans[0].num, chans[0].samples[c][1].temp,
		    chans[1].num, chans[1].samples[c][1].temp, 1);
		DPRINTF(("TX chain %d: power=%d gain=%d temp=%d\n",
		    c, power, gain, temp));

		/* Compute temperature compensation. */
		tdiff = ((sc->temp - temp) * 2) / tdiv[grp];
		DPRINTF(("temperature compensation=%d (current=%d, "
		    "EEPROM=%d)\n", tdiff, sc->temp, temp));

		for (ridx = 0; ridx <= IWN_RIDX_MAX; ridx++) {
			/* Convert dBm to half-dBm. */
			maxchpwr = sc->maxpwr[chan] * 2;
#ifdef notyet
			if (ridx > iwn_mcs2ridx[7] && ridx < iwn_mcs2ridx[16])
				maxchpwr -= 6;	/* MIMO 2T: -3dB */
#endif

			pwr = maxpwr;

			/* Adjust TX power based on rate. */
			if ((ridx % 8) == 5)
				pwr -= 15;	/* OFDM48: -7.5dB */
			else if ((ridx % 8) == 6)
				pwr -= 17;	/* OFDM54: -8.5dB */
			else if ((ridx % 8) == 7)
				pwr -= 20;	/* OFDM60: -10dB */
			else
				pwr -= 10;	/* Others: -5dB */

			/* Do not exceed channel max TX power. */
			if (pwr > maxchpwr)
				pwr = maxchpwr;

			idx = gain - (pwr - power) - tdiff - vdiff;
			if (ridx > iwn_mcs2ridx[7]) /* MIMO */
				idx += (int32_t)letoh32(uc->atten[grp][c]);

			if (cmd.band == 0)
				idx += 9;	/* 5GHz */
			if (ridx == IWN_RIDX_MAX)
				idx += 5;	/* CCK */

			/* Make sure idx stays in a valid range. */
			if (idx < 0)
				idx = 0;
			else if (idx > IWN4965_MAX_PWR_INDEX)
				idx = IWN4965_MAX_PWR_INDEX;

			DPRINTF(("TX chain %d, rate idx %d: power=%d\n",
			    c, ridx, idx));
			cmd.power[ridx].rf_gain[c] = rf_gain[idx];
			cmd.power[ridx].dsp_gain[c] = dsp_gain[idx];
		}
	}

	DPRINTF(("setting TX power for chan %d\n", chan));
	return iwn_cmd(sc, IWN_CMD_TXPOWER, &cmd, sizeof cmd, async);

#undef interpolate
#undef fdivround
}

int
iwn5000_set_txpower(struct iwn_softc *sc, int async)
{
	struct iwn5000_cmd_txpower cmd;

	/*
	 * TX power calibration is handled automatically by the firmware
	 * for 5000 Series.
	 */
	memset(&cmd, 0, sizeof cmd);
	cmd.global_limit = 2 * IWN5000_TXPOWER_MAX_DBM;	/* 16 dBm */
	cmd.flags = IWN5000_TXPOWER_NO_CLOSED;
	cmd.srv_limit = IWN5000_TXPOWER_AUTO;
	DPRINTF(("setting TX power\n"));
	return iwn_cmd(sc, IWN_CMD_TXPOWER_DBM, &cmd, sizeof cmd, async);
}

/*
 * Retrieve the maximum RSSI (in dBm) among receivers.
 */
int
iwn4965_get_rssi(const struct iwn_rx_stat *stat)
{
	struct iwn4965_rx_phystat *phy = (void *)stat->phybuf;
	uint8_t mask, agc;
	int rssi;

	mask = (letoh16(phy->antenna) >> 4) & IWN_ANT_ABC;
	agc  = (letoh16(phy->agc) >> 7) & 0x7f;

	rssi = 0;
	if (mask & IWN_ANT_A)
		rssi = MAX(rssi, phy->rssi[0]);
	if (mask & IWN_ANT_B)
		rssi = MAX(rssi, phy->rssi[2]);
	if (mask & IWN_ANT_C)
		rssi = MAX(rssi, phy->rssi[4]);

	return rssi - agc - IWN_RSSI_TO_DBM;
}

int
iwn5000_get_rssi(const struct iwn_rx_stat *stat)
{
	struct iwn5000_rx_phystat *phy = (void *)stat->phybuf;
	uint8_t agc;
	int rssi;

	agc = (letoh32(phy->agc) >> 9) & 0x7f;

	rssi = MAX(letoh16(phy->rssi[0]) & 0xff,
		   letoh16(phy->rssi[1]) & 0xff);
	rssi = MAX(letoh16(phy->rssi[2]) & 0xff, rssi);

	return rssi - agc - IWN_RSSI_TO_DBM;
}

/*
 * Retrieve the average noise (in dBm) among receivers.
 */
int
iwn_get_noise(const struct iwn_rx_general_stats *stats)
{
	int i, total, nbant, noise;

	total = nbant = 0;
	for (i = 0; i < 3; i++) {
		if ((noise = letoh32(stats->noise[i]) & 0xff) == 0)
			continue;
		total += noise;
		nbant++;
	}
	/* There should be at least one antenna but check anyway. */
	return (nbant == 0) ? -127 : (total / nbant) - 107;
}

/*
 * Compute temperature (in degC) from last received statistics.
 */
int
iwn4965_get_temperature(struct iwn_softc *sc)
{
	struct iwn_ucode_info *uc = &sc->ucode_info;
	int32_t r1, r2, r3, r4, temp;

	r1 = letoh32(uc->temp[0].chan20MHz);
	r2 = letoh32(uc->temp[1].chan20MHz);
	r3 = letoh32(uc->temp[2].chan20MHz);
	r4 = letoh32(sc->rawtemp);

	if (r1 == r3)	/* Prevents division by 0 (should not happen). */
		return 0;

	/* Sign-extend 23-bit R4 value to 32-bit. */
	r4 = ((r4 & 0xffffff) ^ 0x800000) - 0x800000;
	/* Compute temperature in Kelvin. */
	temp = (259 * (r4 - r2)) / (r3 - r1);
	temp = (temp * 97) / 100 + 8;

	DPRINTF(("temperature %dK/%dC\n", temp, IWN_KTOC(temp)));
	return IWN_KTOC(temp);
}

int
iwn5000_get_temperature(struct iwn_softc *sc)
{
	int32_t temp;

	/*
	 * Temperature is not used by the driver for 5000 Series because
	 * TX power calibration is handled by firmware.
	 */
	temp = letoh32(sc->rawtemp);
	if (sc->hw_type == IWN_HW_REV_TYPE_5150) {
		temp = (temp / -5) + sc->temp_off;
		temp = IWN_KTOC(temp);
	}
	return temp;
}

/*
 * Initialize sensitivity calibration state machine.
 */
int
iwn_init_sensitivity(struct iwn_softc *sc)
{
	struct iwn_ops *ops = &sc->ops;
	struct iwn_calib_state *calib = &sc->calib;
	uint32_t flags;
	int error;

	/* Reset calibration state machine. */
	memset(calib, 0, sizeof (*calib));
	calib->state = IWN_CALIB_STATE_INIT;
	calib->cck_state = IWN_CCK_STATE_HIFA;
	/* Set initial correlation values. */
	calib->ofdm_x1     = sc->limits->min_ofdm_x1;
	calib->ofdm_mrc_x1 = sc->limits->min_ofdm_mrc_x1;
	calib->ofdm_x4     = sc->limits->min_ofdm_x4;
	calib->ofdm_mrc_x4 = sc->limits->min_ofdm_mrc_x4;
	calib->cck_x4      = 125;
	calib->cck_mrc_x4  = sc->limits->min_cck_mrc_x4;
	calib->energy_cck  = sc->limits->energy_cck;

	/* Write initial sensitivity. */
	if ((error = iwn_send_sensitivity(sc)) != 0)
		return error;

	/* Write initial gains. */
	if ((error = ops->init_gains(sc)) != 0)
		return error;

	/* Request statistics at each beacon interval. */
	flags = 0;
	DPRINTFN(2, ("sending request for statistics\n"));
	return iwn_cmd(sc, IWN_CMD_GET_STATISTICS, &flags, sizeof flags, 1);
}

/*
 * Collect noise and RSSI statistics for the first 20 beacons received
 * after association and use them to determine connected antennas and
 * to set differential gains.
 */
void
iwn_collect_noise(struct iwn_softc *sc,
    const struct iwn_rx_general_stats *stats)
{
	struct iwn_ops *ops = &sc->ops;
	struct iwn_calib_state *calib = &sc->calib;
	uint32_t val;
	int i;

	/* Accumulate RSSI and noise for all 3 antennas. */
	for (i = 0; i < 3; i++) {
		calib->rssi[i] += letoh32(stats->rssi[i]) & 0xff;
		calib->noise[i] += letoh32(stats->noise[i]) & 0xff;
	}
	/* NB: We update differential gains only once after 20 beacons. */
	if (++calib->nbeacons < 20)
		return;

	/* Determine highest average RSSI. */
	val = MAX(calib->rssi[0], calib->rssi[1]);
	val = MAX(calib->rssi[2], val);

	/* Determine which antennas are connected. */
	sc->chainmask = sc->rxchainmask;
	for (i = 0; i < 3; i++)
		if (val - calib->rssi[i] > 15 * 20)
			sc->chainmask &= ~(1 << i);
	DPRINTF(("RX chains mask: theoretical=0x%x, actual=0x%x\n",
	    sc->rxchainmask, sc->chainmask));

	/* If none of the TX antennas are connected, keep at least one. */
	if ((sc->chainmask & sc->txchainmask) == 0)
		sc->chainmask |= IWN_LSB(sc->txchainmask);

	(void)ops->set_gains(sc);
	calib->state = IWN_CALIB_STATE_RUN;

#ifdef notyet
	/* XXX Disable RX chains with no antennas connected. */
	sc->rxon.rxchain = htole16(IWN_RXCHAIN_SEL(sc->chainmask));
	(void)iwn_cmd(sc, IWN_CMD_RXON, &sc->rxon, sc->rxonsz, 1);
#endif

	/* Enable power-saving mode if requested by user. */
	if (sc->sc_ic.ic_flags & IEEE80211_F_PMGTON)
		(void)iwn_set_pslevel(sc, 0, 3, 1);
}

int
iwn4965_init_gains(struct iwn_softc *sc)
{
	struct iwn_phy_calib_gain cmd;

	memset(&cmd, 0, sizeof cmd);
	cmd.code = IWN4965_PHY_CALIB_DIFF_GAIN;
	/* Differential gains initially set to 0 for all 3 antennas. */
	DPRINTF(("setting initial differential gains\n"));
	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &cmd, sizeof cmd, 1);
}

int
iwn5000_init_gains(struct iwn_softc *sc)
{
	struct iwn_phy_calib cmd;

	memset(&cmd, 0, sizeof cmd);
	cmd.code = sc->reset_noise_gain;
	cmd.ngroups = 1;
	cmd.isvalid = 1;
	DPRINTF(("setting initial differential gains\n"));
	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &cmd, sizeof cmd, 1);
}

int
iwn4965_set_gains(struct iwn_softc *sc)
{
	struct iwn_calib_state *calib = &sc->calib;
	struct iwn_phy_calib_gain cmd;
	int i, delta, noise;

	/* Get minimal noise among connected antennas. */
	noise = INT_MAX;	/* NB: There's at least one antenna. */
	for (i = 0; i < 3; i++)
		if (sc->chainmask & (1 << i))
			noise = MIN(calib->noise[i], noise);

	memset(&cmd, 0, sizeof cmd);
	cmd.code = IWN4965_PHY_CALIB_DIFF_GAIN;
	/* Set differential gains for connected antennas. */
	for (i = 0; i < 3; i++) {
		if (sc->chainmask & (1 << i)) {
			/* Compute attenuation (in unit of 1.5dB). */
			delta = (noise - (int32_t)calib->noise[i]) / 30;
			/* NB: delta <= 0 */
			/* Limit to [-4.5dB,0]. */
			cmd.gain[i] = MIN(abs(delta), 3);
			if (delta < 0)
				cmd.gain[i] |= 1 << 2;	/* sign bit */
		}
	}
	DPRINTF(("setting differential gains Ant A/B/C: %x/%x/%x (%x)\n",
	    cmd.gain[0], cmd.gain[1], cmd.gain[2], sc->chainmask));
	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &cmd, sizeof cmd, 1);
}

int
iwn5000_set_gains(struct iwn_softc *sc)
{
	struct iwn_calib_state *calib = &sc->calib;
	struct iwn_phy_calib_gain cmd;
	int i, ant, div, delta;

	/* We collected 20 beacons and !=6050 need a 1.5 factor. */
	div = (sc->hw_type == IWN_HW_REV_TYPE_6050) ? 20 : 30;

	memset(&cmd, 0, sizeof cmd);
	cmd.code = sc->noise_gain;
	cmd.ngroups = 1;
	cmd.isvalid = 1;
	/* Get first available RX antenna as referential. */
	ant = IWN_LSB(sc->rxchainmask);
	/* Set differential gains for other antennas. */
	for (i = ant + 1; i < 3; i++) {
		if (sc->chainmask & (1 << i)) {
			/* The delta is relative to antenna "ant". */
			delta = ((int32_t)calib->noise[ant] -
			    (int32_t)calib->noise[i]) / div;
			/* Limit to [-4.5dB,+4.5dB]. */
			cmd.gain[i - 1] = MIN(abs(delta), 3);
			if (delta < 0)
				cmd.gain[i - 1] |= 1 << 2;	/* sign bit */
		}
	}
	DPRINTF(("setting differential gains: %x/%x (%x)\n",
	    cmd.gain[0], cmd.gain[1], sc->chainmask));
	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &cmd, sizeof cmd, 1);
}

/*
 * Tune RF RX sensitivity based on the number of false alarms detected
 * during the last beacon period.
 */
void
iwn_tune_sensitivity(struct iwn_softc *sc, const struct iwn_rx_stats *stats)
{
#define inc(val, inc, max)			\
	if ((val) < (max)) {			\
		if ((val) < (max) - (inc))	\
			(val) += (inc);		\
		else				\
			(val) = (max);		\
		needs_update = 1;		\
	}
#define dec(val, dec, min)			\
	if ((val) > (min)) {			\
		if ((val) > (min) + (dec))	\
			(val) -= (dec);		\
		else				\
			(val) = (min);		\
		needs_update = 1;		\
	}

	const struct iwn_sensitivity_limits *limits = sc->limits;
	struct iwn_calib_state *calib = &sc->calib;
	uint32_t val, rxena, fa;
	uint32_t energy[3], energy_min;
	uint8_t noise[3], noise_ref;
	int i, needs_update = 0;

	/* Check that we've been enabled long enough. */
	if ((rxena = letoh32(stats->general.load)) == 0)
		return;

	/* Compute number of false alarms since last call for OFDM. */
	fa  = letoh32(stats->ofdm.bad_plcp) - calib->bad_plcp_ofdm;
	fa += letoh32(stats->ofdm.fa) - calib->fa_ofdm;
	fa *= 200 * IEEE80211_DUR_TU;	/* 200TU */

	/* Save counters values for next call. */
	calib->bad_plcp_ofdm = letoh32(stats->ofdm.bad_plcp);
	calib->fa_ofdm = letoh32(stats->ofdm.fa);

	if (fa > 50 * rxena) {
		/* High false alarm count, decrease sensitivity. */
		DPRINTFN(2, ("OFDM high false alarm count: %u\n", fa));
		inc(calib->ofdm_x1,     1, limits->max_ofdm_x1);
		inc(calib->ofdm_mrc_x1, 1, limits->max_ofdm_mrc_x1);
		inc(calib->ofdm_x4,     1, limits->max_ofdm_x4);
		inc(calib->ofdm_mrc_x4, 1, limits->max_ofdm_mrc_x4);

	} else if (fa < 5 * rxena) {
		/* Low false alarm count, increase sensitivity. */
		DPRINTFN(2, ("OFDM low false alarm count: %u\n", fa));
		dec(calib->ofdm_x1,     1, limits->min_ofdm_x1);
		dec(calib->ofdm_mrc_x1, 1, limits->min_ofdm_mrc_x1);
		dec(calib->ofdm_x4,     1, limits->min_ofdm_x4);
		dec(calib->ofdm_mrc_x4, 1, limits->min_ofdm_mrc_x4);
	}

	/* Compute maximum noise among 3 receivers. */
	for (i = 0; i < 3; i++)
		noise[i] = (letoh32(stats->general.noise[i]) >> 8) & 0xff;
	val = MAX(noise[0], noise[1]);
	val = MAX(noise[2], val);
	/* Insert it into our samples table. */
	calib->noise_samples[calib->cur_noise_sample] = val;
	calib->cur_noise_sample = (calib->cur_noise_sample + 1) % 20;

	/* Compute maximum noise among last 20 samples. */
	noise_ref = calib->noise_samples[0];
	for (i = 1; i < 20; i++)
		noise_ref = MAX(noise_ref, calib->noise_samples[i]);

	/* Compute maximum energy among 3 receivers. */
	for (i = 0; i < 3; i++)
		energy[i] = letoh32(stats->general.energy[i]);
	val = MIN(energy[0], energy[1]);
	val = MIN(energy[2], val);
	/* Insert it into our samples table. */
	calib->energy_samples[calib->cur_energy_sample] = val;
	calib->cur_energy_sample = (calib->cur_energy_sample + 1) % 10;

	/* Compute minimum energy among last 10 samples. */
	energy_min = calib->energy_samples[0];
	for (i = 1; i < 10; i++)
		energy_min = MAX(energy_min, calib->energy_samples[i]);
	energy_min += 6;

	/* Compute number of false alarms since last call for CCK. */
	fa  = letoh32(stats->cck.bad_plcp) - calib->bad_plcp_cck;
	fa += letoh32(stats->cck.fa) - calib->fa_cck;
	fa *= 200 * IEEE80211_DUR_TU;	/* 200TU */

	/* Save counters values for next call. */
	calib->bad_plcp_cck = letoh32(stats->cck.bad_plcp);
	calib->fa_cck = letoh32(stats->cck.fa);

	if (fa > 50 * rxena) {
		/* High false alarm count, decrease sensitivity. */
		DPRINTFN(2, ("CCK high false alarm count: %u\n", fa));
		calib->cck_state = IWN_CCK_STATE_HIFA;
		calib->low_fa = 0;

		if (calib->cck_x4 > 160) {
			calib->noise_ref = noise_ref;
			if (calib->energy_cck > 2)
				dec(calib->energy_cck, 2, energy_min);
		}
		if (calib->cck_x4 < 160) {
			calib->cck_x4 = 161;
			needs_update = 1;
		} else
			inc(calib->cck_x4, 3, limits->max_cck_x4);

		inc(calib->cck_mrc_x4, 3, limits->max_cck_mrc_x4);

	} else if (fa < 5 * rxena) {
		/* Low false alarm count, increase sensitivity. */
		DPRINTFN(2, ("CCK low false alarm count: %u\n", fa));
		calib->cck_state = IWN_CCK_STATE_LOFA;
		calib->low_fa++;

		if (calib->cck_state != IWN_CCK_STATE_INIT &&
		    (((int32_t)calib->noise_ref - (int32_t)noise_ref) > 2 ||
		     calib->low_fa > 100)) {
			inc(calib->energy_cck, 2, limits->min_energy_cck);
			dec(calib->cck_x4,     3, limits->min_cck_x4);
			dec(calib->cck_mrc_x4, 3, limits->min_cck_mrc_x4);
		}
	} else {
		/* Not worth to increase or decrease sensitivity. */
		DPRINTFN(2, ("CCK normal false alarm count: %u\n", fa));
		calib->low_fa = 0;
		calib->noise_ref = noise_ref;

		if (calib->cck_state == IWN_CCK_STATE_HIFA) {
			/* Previous interval had many false alarms. */
			dec(calib->energy_cck, 8, energy_min);
		}
		calib->cck_state = IWN_CCK_STATE_INIT;
	}

	if (needs_update)
		(void)iwn_send_sensitivity(sc);
#undef dec
#undef inc
}

int
iwn_send_sensitivity(struct iwn_softc *sc)
{
	struct iwn_calib_state *calib = &sc->calib;
	struct iwn_enhanced_sensitivity_cmd cmd;
	int len;

	memset(&cmd, 0, sizeof cmd);
	len = sizeof (struct iwn_sensitivity_cmd);
	cmd.which = IWN_SENSITIVITY_WORKTBL;
	/* OFDM modulation. */
	cmd.corr_ofdm_x1       = htole16(calib->ofdm_x1);
	cmd.corr_ofdm_mrc_x1   = htole16(calib->ofdm_mrc_x1);
	cmd.corr_ofdm_x4       = htole16(calib->ofdm_x4);
	cmd.corr_ofdm_mrc_x4   = htole16(calib->ofdm_mrc_x4);
	cmd.energy_ofdm        = htole16(sc->limits->energy_ofdm);
	cmd.energy_ofdm_th     = htole16(62);
	/* CCK modulation. */
	cmd.corr_cck_x4        = htole16(calib->cck_x4);
	cmd.corr_cck_mrc_x4    = htole16(calib->cck_mrc_x4);
	cmd.energy_cck         = htole16(calib->energy_cck);
	/* Barker modulation: use default values. */
	cmd.corr_barker        = htole16(190);
	cmd.corr_barker_mrc    = htole16(390);
	if (!(sc->sc_flags & IWN_FLAG_ENH_SENS))
		goto send;
	/* Enhanced sensitivity settings. */
	len = sizeof (struct iwn_enhanced_sensitivity_cmd);
	cmd.ofdm_det_slope_mrc = htole16(668);
	cmd.ofdm_det_icept_mrc = htole16(4);
	cmd.ofdm_det_slope     = htole16(486);
	cmd.ofdm_det_icept     = htole16(37);
	cmd.cck_det_slope_mrc  = htole16(853);
	cmd.cck_det_icept_mrc  = htole16(4);
	cmd.cck_det_slope      = htole16(476);
	cmd.cck_det_icept      = htole16(99);
send:
	return iwn_cmd(sc, IWN_CMD_SET_SENSITIVITY, &cmd, len, 1);
}

/*
 * Set STA mode power saving level (between 0 and 5).
 * Level 0 is CAM (Continuously Aware Mode), 5 is for maximum power saving.
 */
int
iwn_set_pslevel(struct iwn_softc *sc, int dtim, int level, int async)
{
	struct iwn_pmgt_cmd cmd;
	const struct iwn_pmgt *pmgt;
	uint32_t max, skip_dtim;
	pcireg_t reg;
	int i;

	/* Select which PS parameters to use. */
	if (dtim <= 2)
		pmgt = &iwn_pmgt[0][level];
	else if (dtim <= 10)
		pmgt = &iwn_pmgt[1][level];
	else
		pmgt = &iwn_pmgt[2][level];

	memset(&cmd, 0, sizeof cmd);
	if (level != 0)	/* not CAM */
		cmd.flags |= htole16(IWN_PS_ALLOW_SLEEP);
	if (level == 5)
		cmd.flags |= htole16(IWN_PS_FAST_PD);
	/* Retrieve PCIe Active State Power Management (ASPM). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag,
	    sc->sc_cap_off + PCI_PCIE_LCSR);
	if (!(reg & PCI_PCIE_LCSR_ASPM_L0S))	/* L0s Entry disabled. */
		cmd.flags |= htole16(IWN_PS_PCI_PMGT);
	cmd.rxtimeout = htole32(pmgt->rxtimeout * 1024);
	cmd.txtimeout = htole32(pmgt->txtimeout * 1024);

	if (dtim == 0) {
		dtim = 1;
		skip_dtim = 0;
	} else
		skip_dtim = pmgt->skip_dtim;
	if (skip_dtim != 0) {
		cmd.flags |= htole16(IWN_PS_SLEEP_OVER_DTIM);
		max = pmgt->intval[4];
		if (max == (uint32_t)-1)
			max = dtim * (skip_dtim + 1);
		else if (max > dtim)
			max = (max / dtim) * dtim;
	} else
		max = dtim;
	for (i = 0; i < 5; i++)
		cmd.intval[i] = htole32(MIN(max, pmgt->intval[i]));

	DPRINTF(("setting power saving level to %d\n", level));
	return iwn_cmd(sc, IWN_CMD_SET_POWER_MODE, &cmd, sizeof cmd, async);
}

int
iwn_send_btcoex(struct iwn_softc *sc)
{
	struct iwn_bluetooth cmd;

	memset(&cmd, 0, sizeof cmd);
	cmd.flags = IWN_BT_COEX_CHAN_ANN | IWN_BT_COEX_BT_PRIO;
	cmd.lead_time = IWN_BT_LEAD_TIME_DEF;
	cmd.max_kill = IWN_BT_MAX_KILL_DEF;
	DPRINTF(("configuring bluetooth coexistence\n"));
	return iwn_cmd(sc, IWN_CMD_BT_COEX, &cmd, sizeof(cmd), 0);
}

int
iwn_send_advanced_btcoex(struct iwn_softc *sc)
{
	static const uint32_t btcoex_3wire[12] = {
		0xaaaaaaaa, 0xaaaaaaaa, 0xaeaaaaaa, 0xaaaaaaaa,
		0xcc00ff28, 0x0000aaaa, 0xcc00aaaa, 0x0000aaaa,
		0xc0004000, 0x00004000, 0xf0005000, 0xf0005000,
	};
	struct iwn_btcoex_priotable btprio;
	struct iwn_btcoex_prot btprot;
	int error, i;

	if (sc->hw_type == IWN_HW_REV_TYPE_2030 ||
	    sc->hw_type == IWN_HW_REV_TYPE_135) {
		struct iwn2000_btcoex_config btconfig;

		memset(&btconfig, 0, sizeof btconfig);
		btconfig.flags = IWN_BT_COEX6000_CHAN_INHIBITION |
		    (IWN_BT_COEX6000_MODE_3W << IWN_BT_COEX6000_MODE_SHIFT) |
		    IWN_BT_SYNC_2_BT_DISABLE;
		btconfig.max_kill = 5;
		btconfig.bt3_t7_timer = 1;
		btconfig.kill_ack = htole32(0xffff0000);
		btconfig.kill_cts = htole32(0xffff0000);
		btconfig.sample_time = 2;
		btconfig.bt3_t2_timer = 0xc;
		for (i = 0; i < 12; i++)
			btconfig.lookup_table[i] = htole32(btcoex_3wire[i]);
		btconfig.valid = htole16(0xff);
		btconfig.prio_boost = htole32(0xf0);
		DPRINTF(("configuring advanced bluetooth coexistence\n"));
		error = iwn_cmd(sc, IWN_CMD_BT_COEX, &btconfig,
		    sizeof(btconfig), 1);
		if (error != 0)
			return (error);
	} else {
		struct iwn6000_btcoex_config btconfig;

		memset(&btconfig, 0, sizeof btconfig);
		btconfig.flags = IWN_BT_COEX6000_CHAN_INHIBITION |
		    (IWN_BT_COEX6000_MODE_3W << IWN_BT_COEX6000_MODE_SHIFT) |
		    IWN_BT_SYNC_2_BT_DISABLE;
		btconfig.max_kill = 5;
		btconfig.bt3_t7_timer = 1;
		btconfig.kill_ack = htole32(0xffff0000);
		btconfig.kill_cts = htole32(0xffff0000);
		btconfig.sample_time = 2;
		btconfig.bt3_t2_timer = 0xc;
		for (i = 0; i < 12; i++)
			btconfig.lookup_table[i] = htole32(btcoex_3wire[i]);
		btconfig.valid = htole16(0xff);
		btconfig.prio_boost = 0xf0;
		DPRINTF(("configuring advanced bluetooth coexistence\n"));
		error = iwn_cmd(sc, IWN_CMD_BT_COEX, &btconfig,
		    sizeof(btconfig), 1);
		if (error != 0)
			return (error);
	}

	memset(&btprio, 0, sizeof btprio);
	btprio.calib_init1 = 0x6;
	btprio.calib_init2 = 0x7;
	btprio.calib_periodic_low1 = 0x2;
	btprio.calib_periodic_low2 = 0x3;
	btprio.calib_periodic_high1 = 0x4;
	btprio.calib_periodic_high2 = 0x5;
	btprio.dtim = 0x6;
	btprio.scan52 = 0x8;
	btprio.scan24 = 0xa;
	error = iwn_cmd(sc, IWN_CMD_BT_COEX_PRIOTABLE, &btprio, sizeof(btprio),
	    1);
	if (error != 0)
		return (error);

	/* Force BT state machine change */
	memset(&btprot, 0, sizeof btprot);
	btprot.open = 1;
	btprot.type = 1;
	error = iwn_cmd(sc, IWN_CMD_BT_COEX_PROT, &btprot, sizeof(btprot), 1);
	if (error != 0)
		return (error);

	btprot.open = 0;
	return (iwn_cmd(sc, IWN_CMD_BT_COEX_PROT, &btprot, sizeof(btprot), 1));
}

int
iwn5000_runtime_calib(struct iwn_softc *sc)
{
	struct iwn5000_calib_config cmd;

	memset(&cmd, 0, sizeof cmd);
	cmd.ucode.once.enable = 0xffffffff;
	cmd.ucode.once.start = IWN5000_CALIB_DC;
	DPRINTF(("configuring runtime calibration\n"));
	return iwn_cmd(sc, IWN5000_CMD_CALIB_CONFIG, &cmd, sizeof(cmd), 0);
}

int
iwn_config(struct iwn_softc *sc)
{
	struct iwn_ops *ops = &sc->ops;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	uint32_t txmask;
	uint16_t rxchain;
	int error, ridx;

	/* Set radio temperature sensor offset. */
	if (sc->hw_type == IWN_HW_REV_TYPE_6005) {
		error = iwn6000_temp_offset_calib(sc);
		if (error != 0) {
			printf("%s: could not set temperature offset\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
	}

	if (sc->hw_type == IWN_HW_REV_TYPE_2030 ||
	    sc->hw_type == IWN_HW_REV_TYPE_2000 ||
	    sc->hw_type == IWN_HW_REV_TYPE_135 ||
	    sc->hw_type == IWN_HW_REV_TYPE_105) {
		error = iwn2000_temp_offset_calib(sc);
		if (error != 0) {
			printf("%s: could not set temperature offset\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
	}

	if (sc->hw_type == IWN_HW_REV_TYPE_6050 ||
	    sc->hw_type == IWN_HW_REV_TYPE_6005) {
		/* Configure runtime DC calibration. */
		error = iwn5000_runtime_calib(sc);
		if (error != 0) {
			printf("%s: could not configure runtime calibration\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
	}

	/* Configure valid TX chains for >=5000 Series. */
	if (sc->hw_type != IWN_HW_REV_TYPE_4965) {
		txmask = htole32(sc->txchainmask);
		DPRINTF(("configuring valid TX chains 0x%x\n", txmask));
		error = iwn_cmd(sc, IWN5000_CMD_TX_ANT_CONFIG, &txmask,
		    sizeof txmask, 0);
		if (error != 0) {
			printf("%s: could not configure valid TX chains\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
	}

	/* Configure bluetooth coexistence. */
	if (sc->sc_flags & IWN_FLAG_ADV_BT_COEX)
		error = iwn_send_advanced_btcoex(sc);
	else
		error = iwn_send_btcoex(sc);
	if (error != 0) {
		printf("%s: could not configure bluetooth coexistence\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* Set mode, channel, RX filter and enable RX. */
	memset(&sc->rxon, 0, sizeof (struct iwn_rxon));
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	IEEE80211_ADDR_COPY(sc->rxon.myaddr, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(sc->rxon.wlap, ic->ic_myaddr);
	sc->rxon.chan = ieee80211_chan2ieee(ic, ic->ic_ibss_chan);
	sc->rxon.flags = htole32(IWN_RXON_TSF | IWN_RXON_CTS_TO_SELF);
	if (IEEE80211_IS_CHAN_2GHZ(ic->ic_ibss_chan)) {
		sc->rxon.flags |= htole32(IWN_RXON_AUTO | IWN_RXON_24GHZ);
		if (ic->ic_flags & IEEE80211_F_USEPROT)
			sc->rxon.flags |= htole32(IWN_RXON_TGG_PROT);
		DPRINTF(("%s: 2ghz prot 0x%x\n", __func__,
		    le32toh(sc->rxon.flags)));
	}
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		sc->rxon.mode = IWN_MODE_STA;
		sc->rxon.filter = htole32(IWN_FILTER_MULTICAST);
		break;
	case IEEE80211_M_MONITOR:
		sc->rxon.mode = IWN_MODE_MONITOR;
		sc->rxon.filter = htole32(IWN_FILTER_MULTICAST |
		    IWN_FILTER_CTL | IWN_FILTER_PROMISC);
		break;
	default:
		/* Should not get there. */
		break;
	}
	sc->rxon.cck_mask  = 0x0f;	/* not yet negotiated */
	sc->rxon.ofdm_mask = 0xff;	/* not yet negotiated */
	sc->rxon.ht_single_mask = 0xff;
	sc->rxon.ht_dual_mask = 0xff;
	sc->rxon.ht_triple_mask = 0xff;
	rxchain =
	    IWN_RXCHAIN_VALID(sc->rxchainmask) |
	    IWN_RXCHAIN_MIMO_COUNT(sc->nrxchains) |
	    IWN_RXCHAIN_IDLE_COUNT(sc->nrxchains);
	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		rxchain |= IWN_RXCHAIN_FORCE_SEL(sc->rxchainmask);
		rxchain |= IWN_RXCHAIN_FORCE_MIMO_SEL(sc->rxchainmask);
	    	rxchain |= (IWN_RXCHAIN_DRIVER_FORCE | IWN_RXCHAIN_MIMO_FORCE);
	}
	sc->rxon.rxchain = htole16(rxchain);
	DPRINTF(("setting configuration\n"));
	DPRINTF(("%s: rxon chan %d flags %x cck %x ofdm %x rxchain %x\n",
	    __func__, sc->rxon.chan, le32toh(sc->rxon.flags), sc->rxon.cck_mask,
	    sc->rxon.ofdm_mask, sc->rxon.rxchain));
	error = iwn_cmd(sc, IWN_CMD_RXON, &sc->rxon, sc->rxonsz, 0);
	if (error != 0) {
		printf("%s: RXON command failed\n", sc->sc_dev.dv_xname);
		return error;
	}

	ridx = (sc->sc_ic.ic_curmode == IEEE80211_MODE_11A) ?
	    IWN_RIDX_OFDM6 : IWN_RIDX_CCK1;
	if ((error = iwn_add_broadcast_node(sc, 0, ridx)) != 0) {
		printf("%s: could not add broadcast node\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* Configuration has changed, set TX power accordingly. */
	if ((error = ops->set_txpower(sc, 0)) != 0) {
		printf("%s: could not set TX power\n", sc->sc_dev.dv_xname);
		return error;
	}

	if ((error = iwn_set_critical_temp(sc)) != 0) {
		printf("%s: could not set critical temperature\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* Set power saving level to CAM during initialization. */
	if ((error = iwn_set_pslevel(sc, 0, 0, 0)) != 0) {
		printf("%s: could not set power saving level\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	return 0;
}

uint16_t
iwn_get_active_dwell_time(struct iwn_softc *sc,
    uint16_t flags, uint8_t n_probes)
{
	/* No channel? Default to 2GHz settings */
	if (flags & IEEE80211_CHAN_2GHZ) {
		return (IWN_ACTIVE_DWELL_TIME_2GHZ +
		IWN_ACTIVE_DWELL_FACTOR_2GHZ * (n_probes + 1));
	}

	/* 5GHz dwell time */
	return (IWN_ACTIVE_DWELL_TIME_5GHZ +
	    IWN_ACTIVE_DWELL_FACTOR_5GHZ * (n_probes + 1));
}

/*
 * Limit the total dwell time to 85% of the beacon interval.
 *
 * Returns the dwell time in milliseconds.
 */
uint16_t
iwn_limit_dwell(struct iwn_softc *sc, uint16_t dwell_time)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	int bintval = 0;

	/* bintval is in TU (1.024mS) */
	if (ni != NULL)
		bintval = ni->ni_intval;

	/*
	 * If it's non-zero, we should calculate the minimum of
	 * it and the DWELL_BASE.
	 *
	 * XXX Yes, the math should take into account that bintval
	 * is 1.024mS, not 1mS..
	 */
	if (bintval > 0) {
		return (MIN(IWN_PASSIVE_DWELL_BASE, ((bintval * 85) / 100)));
	}

	/* No association context? Default */
	return (IWN_PASSIVE_DWELL_BASE);
}

uint16_t
iwn_get_passive_dwell_time(struct iwn_softc *sc, uint16_t flags)
{
	uint16_t passive;
	if (flags & IEEE80211_CHAN_2GHZ) {
		passive = IWN_PASSIVE_DWELL_BASE + IWN_PASSIVE_DWELL_TIME_2GHZ;
	} else {
		passive = IWN_PASSIVE_DWELL_BASE + IWN_PASSIVE_DWELL_TIME_5GHZ;
	}

	/* Clamp to the beacon interval if we're associated */
	return (iwn_limit_dwell(sc, passive));
}

int
iwn_scan(struct iwn_softc *sc, uint16_t flags)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwn_scan_hdr *hdr;
	struct iwn_cmd_data *tx;
	struct iwn_scan_essid *essid;
	struct iwn_scan_chan *chan;
	struct ieee80211_frame *wh;
	struct ieee80211_rateset *rs;
	struct ieee80211_channel *c;
	struct ifnet *ifp = &ic->ic_if;
	uint8_t *buf, *frm;
	uint16_t rxchain, dwell_active, dwell_passive;
	uint8_t txant;
	int buflen, error, is_active;

	buf = malloc(IWN_SCAN_MAXSZ, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (buf == NULL) {
		printf("%s: could not allocate buffer for scan command\n",
		    sc->sc_dev.dv_xname);
		return ENOMEM;
	}
	hdr = (struct iwn_scan_hdr *)buf;
	/*
	 * Move to the next channel if no frames are received within 10ms
	 * after sending the probe request.
	 */
	hdr->quiet_time = htole16(10);		/* timeout in milliseconds */
	hdr->quiet_threshold = htole16(1);	/* min # of packets */

	/* Select antennas for scanning. */
	rxchain =
	    IWN_RXCHAIN_VALID(sc->rxchainmask) |
	    IWN_RXCHAIN_FORCE_MIMO_SEL(sc->rxchainmask) |
	    IWN_RXCHAIN_DRIVER_FORCE;
	if ((flags & IEEE80211_CHAN_5GHZ) &&
	    sc->hw_type == IWN_HW_REV_TYPE_4965) {
		/* Ant A must be avoided in 5GHz because of an HW bug. */
		rxchain |= IWN_RXCHAIN_FORCE_SEL(IWN_ANT_BC);
	} else	/* Use all available RX antennas. */
		rxchain |= IWN_RXCHAIN_FORCE_SEL(sc->rxchainmask);
	hdr->rxchain = htole16(rxchain);
	hdr->filter = htole32(IWN_FILTER_MULTICAST | IWN_FILTER_BEACON);

	tx = (struct iwn_cmd_data *)(hdr + 1);
	tx->flags = htole32(IWN_TX_AUTO_SEQ);
	tx->id = sc->broadcast_id;
	tx->lifetime = htole32(IWN_LIFETIME_INFINITE);

	if (flags & IEEE80211_CHAN_5GHZ) {
		/* Send probe requests at 6Mbps. */
		tx->plcp = iwn_rates[IWN_RIDX_OFDM6].plcp;
		rs = &ic->ic_sup_rates[IEEE80211_MODE_11A];
	} else {
		hdr->flags = htole32(IWN_RXON_24GHZ | IWN_RXON_AUTO);
		/* Send probe requests at 1Mbps. */
		tx->plcp = iwn_rates[IWN_RIDX_CCK1].plcp;
		tx->rflags = IWN_RFLAG_CCK;
		rs = &ic->ic_sup_rates[IEEE80211_MODE_11G];
	}
	/* Use the first valid TX antenna. */
	txant = IWN_LSB(sc->txchainmask);
	tx->rflags |= IWN_RFLAG_ANT(txant);

	/*
	 * Only do active scanning if we're announcing a probe request
	 * for a given SSID (or more, if we ever add it to the driver.)
	 */
	is_active = 0;

	/*
	 * If we're scanning for a specific SSID, add it to the command.
	 */
	essid = (struct iwn_scan_essid *)(tx + 1);
	if (ic->ic_des_esslen != 0) {
		essid[0].id = IEEE80211_ELEMID_SSID;
		essid[0].len = ic->ic_des_esslen;
		memcpy(essid[0].data, ic->ic_des_essid, ic->ic_des_esslen);

		is_active = 1;
	}
	/*
	 * Build a probe request frame.  Most of the following code is a
	 * copy & paste of what is done in net80211.
	 */
	wh = (struct ieee80211_frame *)(essid + 20);
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_PROBE_REQ;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	IEEE80211_ADDR_COPY(wh->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, etherbroadcastaddr);
	*(uint16_t *)&wh->i_dur[0] = 0;	/* filled by HW */
	*(uint16_t *)&wh->i_seq[0] = 0;	/* filled by HW */

	frm = (uint8_t *)(wh + 1);
	frm = ieee80211_add_ssid(frm, NULL, 0);
	frm = ieee80211_add_rates(frm, rs);
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		frm = ieee80211_add_xrates(frm, rs);
	if (ic->ic_flags & IEEE80211_F_HTON)
		frm = ieee80211_add_htcaps(frm, ic);

	/* Set length of probe request. */
	tx->len = htole16(frm - (uint8_t *)wh);

	/*
	 * If active scanning is requested but a certain channel is
	 * marked passive, we can do active scanning if we detect
	 * transmissions.
	 *
	 * There is an issue with some firmware versions that triggers
	 * a sysassert on a "good CRC threshold" of zero (== disabled),
	 * on a radar channel even though this means that we should NOT
	 * send probes.
	 *
	 * The "good CRC threshold" is the number of frames that we
	 * need to receive during our dwell time on a channel before
	 * sending out probes -- setting this to a huge value will
	 * mean we never reach it, but at the same time work around
	 * the aforementioned issue. Thus use IWN_GOOD_CRC_TH_NEVER
	 * here instead of IWN_GOOD_CRC_TH_DISABLED.
	 *
	 * This was fixed in later versions along with some other
	 * scan changes, and the threshold behaves as a flag in those
	 * versions.
	 */

	/*
	 * If we're doing active scanning, set the crc_threshold
	 * to a suitable value.  This is different to active veruss
	 * passive scanning depending upon the channel flags; the
	 * firmware will obey that particular check for us.
	 */
	if (sc->tlv_feature_flags & IWN_UCODE_TLV_FLAGS_NEWSCAN)
		hdr->crc_threshold = is_active ?
		    IWN_GOOD_CRC_TH_DEFAULT : IWN_GOOD_CRC_TH_DISABLED;
	else
		hdr->crc_threshold = is_active ?
		    IWN_GOOD_CRC_TH_DEFAULT : IWN_GOOD_CRC_TH_NEVER;

	chan = (struct iwn_scan_chan *)frm;
	for (c  = &ic->ic_channels[1];
	     c <= &ic->ic_channels[IEEE80211_CHAN_MAX]; c++) {
		if ((c->ic_flags & flags) != flags)
			continue;

		chan->chan = htole16(ieee80211_chan2ieee(ic, c));
		DPRINTFN(2, ("adding channel %d\n", chan->chan));
		chan->flags = 0;
		if (ic->ic_des_esslen != 0)
			chan->flags |= htole32(IWN_CHAN_NPBREQS(1));

		if (c->ic_flags & IEEE80211_CHAN_PASSIVE)
			chan->flags |= htole32(IWN_CHAN_PASSIVE);
		else
			chan->flags |= htole32(IWN_CHAN_ACTIVE);

		/*
		 * Calculate the active/passive dwell times.
		 */

		dwell_active = iwn_get_active_dwell_time(sc, flags, is_active);
		dwell_passive = iwn_get_passive_dwell_time(sc, flags);

		/* Make sure they're valid */
		if (dwell_passive <= dwell_active)
			dwell_passive = dwell_active + 1;

		chan->active = htole16(dwell_active);
		chan->passive = htole16(dwell_passive);

		chan->dsp_gain = 0x6e;
		if (IEEE80211_IS_CHAN_5GHZ(c)) {
			chan->rf_gain = 0x3b;
		} else {
			chan->rf_gain = 0x28;
		}
		hdr->nchan++;
		chan++;
	}

	buflen = (uint8_t *)chan - buf;
	hdr->len = htole16(buflen);

	DPRINTF(("sending scan command nchan=%d\n", hdr->nchan));
	error = iwn_cmd(sc, IWN_CMD_SCAN, buf, buflen, 1);
	free(buf, M_DEVBUF, IWN_SCAN_MAXSZ);
	return error;
}

int
iwn_auth(struct iwn_softc *sc)
{
	struct iwn_ops *ops = &sc->ops;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	int error, ridx;

	/* Update adapter configuration. */
	IEEE80211_ADDR_COPY(sc->rxon.bssid, ni->ni_bssid);
	sc->rxon.chan = ieee80211_chan2ieee(ic, ni->ni_chan);
	sc->rxon.flags = htole32(IWN_RXON_TSF | IWN_RXON_CTS_TO_SELF);
	if (IEEE80211_IS_CHAN_2GHZ(ni->ni_chan)) {
		sc->rxon.flags |= htole32(IWN_RXON_AUTO | IWN_RXON_24GHZ);
		if (ic->ic_flags & IEEE80211_F_USEPROT)
			sc->rxon.flags |= htole32(IWN_RXON_TGG_PROT);
		DPRINTF(("%s: 2ghz prot 0x%x\n", __func__,
		    le32toh(sc->rxon.flags)));
	}
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		sc->rxon.flags |= htole32(IWN_RXON_SHSLOT);
	if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
		sc->rxon.flags |= htole32(IWN_RXON_SHPREAMBLE);
	switch (ic->ic_curmode) {
	case IEEE80211_MODE_11A:
		sc->rxon.cck_mask  = 0;
		sc->rxon.ofdm_mask = 0x15;
		break;
	case IEEE80211_MODE_11B:
		sc->rxon.cck_mask  = 0x03;
		sc->rxon.ofdm_mask = 0;
		break;
	default:	/* Assume 802.11b/g/n. */
		sc->rxon.cck_mask  = 0x0f;
		sc->rxon.ofdm_mask = 0x15;
	}
	DPRINTF(("%s: rxon chan %d flags %x cck %x ofdm %x\n", __func__,
	    sc->rxon.chan, le32toh(sc->rxon.flags), sc->rxon.cck_mask,
	    sc->rxon.ofdm_mask));
	error = iwn_cmd(sc, IWN_CMD_RXON, &sc->rxon, sc->rxonsz, 1);
	if (error != 0) {
		printf("%s: RXON command failed\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Configuration has changed, set TX power accordingly. */
	if ((error = ops->set_txpower(sc, 1)) != 0) {
		printf("%s: could not set TX power\n", sc->sc_dev.dv_xname);
		return error;
	}
	/*
	 * Reconfiguring RXON clears the firmware nodes table so we must
	 * add the broadcast node again.
	 */
	ridx = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ?
	    IWN_RIDX_OFDM6 : IWN_RIDX_CCK1;
	if ((error = iwn_add_broadcast_node(sc, 1, ridx)) != 0) {
		printf("%s: could not add broadcast node\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* 
	 * Make sure the firmware gets to see a beacon before we send
	 * the auth request. Otherwise the Tx attempt can fail due to
	 * the firmware's built-in regulatory domain enforcement.
	 */
	DELAY(ni->ni_intval * 3 * IEEE80211_DUR_TU);

	return 0;
}

int
iwn_run(struct iwn_softc *sc)
{
	struct iwn_ops *ops = &sc->ops;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	struct iwn_node_info node;
	int error;

	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		/* Link LED blinks while monitoring. */
		iwn_set_led(sc, IWN_LED_LINK, 50, 50);
		return 0;
	}
	if ((error = iwn_set_timing(sc, ni)) != 0) {
		printf("%s: could not set timing\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Update adapter configuration. */
	sc->rxon.associd = htole16(IEEE80211_AID(ni->ni_associd));
	/* Short preamble and slot time are negotiated when associating. */
	sc->rxon.flags &= ~htole32(IWN_RXON_SHPREAMBLE | IWN_RXON_SHSLOT);
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		sc->rxon.flags |= htole32(IWN_RXON_SHSLOT);
	if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
		sc->rxon.flags |= htole32(IWN_RXON_SHPREAMBLE);
	sc->rxon.filter |= htole32(IWN_FILTER_BSS);

	/* HT is negotiated when associating. */
	if (ni->ni_flags & IEEE80211_NODE_HT) {
		enum ieee80211_htprot htprot =
		    (ni->ni_htop1 & IEEE80211_HTOP1_PROT_MASK);
		DPRINTF(("%s: htprot = %d\n", __func__, htprot));
		sc->rxon.flags |= htole32(IWN_RXON_HT_PROTMODE(htprot));
	} else
		sc->rxon.flags &= ~htole32(IWN_RXON_HT_PROTMODE(3));

	if (IEEE80211_IS_CHAN_5GHZ(ni->ni_chan)) {
		/* 11a or 11n 5GHz */
		sc->rxon.cck_mask  = 0;
		sc->rxon.ofdm_mask = 0x15;
	} else if (ni->ni_flags & IEEE80211_NODE_HT) {
		/* 11n 2GHz */
		sc->rxon.cck_mask  = 0x0f;
		sc->rxon.ofdm_mask = 0x15;
	} else {
		if (ni->ni_rates.rs_nrates == 4) {
			/* 11b */
			sc->rxon.cck_mask  = 0x03;
			sc->rxon.ofdm_mask = 0;
		} else {
			/* assume 11g */
			sc->rxon.cck_mask  = 0x0f;
			sc->rxon.ofdm_mask = 0x15;
		}
	}
	DPRINTF(("%s: rxon chan %d flags %x cck %x ofdm %x\n", __func__,
	    sc->rxon.chan, le32toh(sc->rxon.flags), sc->rxon.cck_mask,
	    sc->rxon.ofdm_mask));
	error = iwn_cmd(sc, IWN_CMD_RXON, &sc->rxon, sc->rxonsz, 1);
	if (error != 0) {
		printf("%s: could not update configuration\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* Configuration has changed, set TX power accordingly. */
	if ((error = ops->set_txpower(sc, 1)) != 0) {
		printf("%s: could not set TX power\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Fake a join to initialize the TX rate. */
	((struct iwn_node *)ni)->id = IWN_ID_BSS;
	iwn_newassoc(ic, ni, 1);

	/* Add BSS node. */
	memset(&node, 0, sizeof node);
	IEEE80211_ADDR_COPY(node.macaddr, ni->ni_macaddr);
	node.id = IWN_ID_BSS;
	if (ni->ni_flags & IEEE80211_NODE_HT) {
		node.htmask = (IWN_AMDPU_SIZE_FACTOR_MASK |
		    IWN_AMDPU_DENSITY_MASK);
		node.htflags = htole32(
		    IWN_AMDPU_SIZE_FACTOR(
			(ic->ic_ampdu_params & IEEE80211_AMPDU_PARAM_LE)) |
		    IWN_AMDPU_DENSITY(
			(ic->ic_ampdu_params & IEEE80211_AMPDU_PARAM_SS) >> 2));
	}
	DPRINTF(("adding BSS node\n"));
	error = ops->add_node(sc, &node, 1);
	if (error != 0) {
		printf("%s: could not add BSS node\n", sc->sc_dev.dv_xname);
		return error;
	}
	DPRINTF(("setting link quality for node %d\n", node.id));
	if ((error = iwn_set_link_quality(sc, ni)) != 0) {
		printf("%s: could not setup link quality for node %d\n",
		    sc->sc_dev.dv_xname, node.id);
		return error;
	}

	if ((error = iwn_init_sensitivity(sc)) != 0) {
		printf("%s: could not set sensitivity\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	/* Start periodic calibration timer. */
	sc->calib.state = IWN_CALIB_STATE_ASSOC;
	sc->calib_cnt = 0;
	timeout_add_msec(&sc->calib_to, 500);

	if (ni->ni_flags & IEEE80211_NODE_HT) {
		struct iwn_node *wn = (void *)ni;
		ieee80211_mira_node_init(&wn->mn);
	}

	/* Link LED always on while associated. */
	iwn_set_led(sc, IWN_LED_LINK, 0, 1);
	return 0;
}

/*
 * We support CCMP hardware encryption/decryption of unicast frames only.
 * HW support for TKIP really sucks.  We should let TKIP die anyway.
 */
int
iwn_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct iwn_softc *sc = ic->ic_softc;
	struct iwn_ops *ops = &sc->ops;
	struct iwn_node *wn = (void *)ni;
	struct iwn_node_info node;
	uint16_t kflags;

	if ((k->k_flags & IEEE80211_KEY_GROUP) ||
	    k->k_cipher != IEEE80211_CIPHER_CCMP)
		return ieee80211_set_key(ic, ni, k);

	kflags = IWN_KFLAG_CCMP | IWN_KFLAG_MAP | IWN_KFLAG_KID(k->k_id);
	if (k->k_flags & IEEE80211_KEY_GROUP)
		kflags |= IWN_KFLAG_GROUP;

	memset(&node, 0, sizeof node);
	node.id = (k->k_flags & IEEE80211_KEY_GROUP) ?
	    sc->broadcast_id : wn->id;
	node.control = IWN_NODE_UPDATE;
	node.flags = IWN_FLAG_SET_KEY;
	node.kflags = htole16(kflags);
	node.kid = k->k_id;
	memcpy(node.key, k->k_key, k->k_len);
	DPRINTF(("set key id=%d for node %d\n", k->k_id, node.id));
	return ops->add_node(sc, &node, 1);
}

void
iwn_delete_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct iwn_softc *sc = ic->ic_softc;
	struct iwn_ops *ops = &sc->ops;
	struct iwn_node *wn = (void *)ni;
	struct iwn_node_info node;

	if ((k->k_flags & IEEE80211_KEY_GROUP) ||
	    k->k_cipher != IEEE80211_CIPHER_CCMP) {
		/* See comment about other ciphers above. */
		ieee80211_delete_key(ic, ni, k);
		return;
	}
	if (ic->ic_state != IEEE80211_S_RUN)
		return;	/* Nothing to do. */
	memset(&node, 0, sizeof node);
	node.id = (k->k_flags & IEEE80211_KEY_GROUP) ?
	    sc->broadcast_id : wn->id;
	node.control = IWN_NODE_UPDATE;
	node.flags = IWN_FLAG_SET_KEY;
	node.kflags = htole16(IWN_KFLAG_INVALID);
	node.kid = 0xff;
	DPRINTF(("delete keys for node %d\n", node.id));
	(void)ops->add_node(sc, &node, 1);
}

/*
 * This function is called by upper layer when HT protection settings in
 * beacons have changed.
 */
void
iwn_update_htprot(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct iwn_softc *sc = ic->ic_softc;
	struct iwn_ops *ops = &sc->ops;
	enum ieee80211_htprot htprot;
	struct iwn_rxon_assoc rxon_assoc;
	int s, error;

	/* Update HT protection mode setting. */
	htprot = (ni->ni_htop1 & IEEE80211_HTOP1_PROT_MASK) >>
	    IEEE80211_HTOP1_PROT_SHIFT;
	sc->rxon.flags &= ~htole32(IWN_RXON_HT_PROTMODE(3));
	sc->rxon.flags |= htole32(IWN_RXON_HT_PROTMODE(htprot));

	/* Update RXON config. */
	memset(&rxon_assoc, 0, sizeof(rxon_assoc));
	rxon_assoc.flags = sc->rxon.flags;
	rxon_assoc.filter = sc->rxon.filter;
	rxon_assoc.ofdm_mask = sc->rxon.ofdm_mask;
	rxon_assoc.cck_mask = sc->rxon.cck_mask;
	rxon_assoc.ht_single_mask = sc->rxon.ht_single_mask;
	rxon_assoc.ht_dual_mask = sc->rxon.ht_dual_mask;
	rxon_assoc.ht_triple_mask = sc->rxon.ht_triple_mask;
	rxon_assoc.rxchain = sc->rxon.rxchain;
	rxon_assoc.acquisition = sc->rxon.acquisition;

	s = splnet();

	error = iwn_cmd(sc, IWN_CMD_RXON_ASSOC, &rxon_assoc,
	    sizeof(rxon_assoc), 1);
	if (error != 0)
		printf("%s: RXON_ASSOC command failed\n", sc->sc_dev.dv_xname);

	DELAY(100);

	/* All RXONs wipe the firmware's txpower table. Restore it. */
	error = ops->set_txpower(sc, 1);
	if (error != 0)
		printf("%s: could not set TX power\n", sc->sc_dev.dv_xname);

	DELAY(100);

	/* Restore power saving level */
	if (ic->ic_flags & IEEE80211_F_PMGTON)
		error = iwn_set_pslevel(sc, 0, 3, 1);
	else
		error = iwn_set_pslevel(sc, 0, 0, 1);
	if (error != 0)
		printf("%s: could not set PS level\n", sc->sc_dev.dv_xname);

	splx(s);
}

/*
 * This function is called by upper layer when an ADDBA request is received
 * from another STA and before the ADDBA response is sent.
 */
int
iwn_ampdu_rx_start(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid)
{
	struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];
	struct iwn_softc *sc = ic->ic_softc;
	struct iwn_ops *ops = &sc->ops;
	struct iwn_node *wn = (void *)ni;
	struct iwn_node_info node;

	memset(&node, 0, sizeof node);
	node.id = wn->id;
	node.control = IWN_NODE_UPDATE;
	node.flags = IWN_FLAG_SET_ADDBA;
	node.addba_tid = tid;
	node.addba_ssn = htole16(ba->ba_winstart);
	DPRINTF(("ADDBA RA=%d TID=%d SSN=%d\n", wn->id, tid,
	    ba->ba_winstart));
	/* XXX async command, so firmware may still fail to add BA agreement */
	return ops->add_node(sc, &node, 1);
}

/*
 * This function is called by upper layer on teardown of an HT-immediate
 * Block Ack agreement (eg. uppon receipt of a DELBA frame).
 */
void
iwn_ampdu_rx_stop(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid)
{
	struct iwn_softc *sc = ic->ic_softc;
	struct iwn_ops *ops = &sc->ops;
	struct iwn_node *wn = (void *)ni;
	struct iwn_node_info node;

	memset(&node, 0, sizeof node);
	node.id = wn->id;
	node.control = IWN_NODE_UPDATE;
	node.flags = IWN_FLAG_SET_DELBA;
	node.delba_tid = tid;
	DPRINTF(("DELBA RA=%d TID=%d\n", wn->id, tid));
	(void)ops->add_node(sc, &node, 1);
}

/*
 * This function is called by upper layer when an ADDBA response is received
 * from another STA.
 */
int
iwn_ampdu_tx_start(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid)
{
	struct ieee80211_tx_ba *ba = &ni->ni_tx_ba[tid];
	struct iwn_softc *sc = ic->ic_softc;
	struct iwn_ops *ops = &sc->ops;
	struct iwn_node *wn = (void *)ni;
	struct iwn_node_info node;
	int error;

	/* Enable TX for the specified RA/TID. */
	wn->disable_tid &= ~(1 << tid);
	memset(&node, 0, sizeof node);
	node.id = wn->id;
	node.control = IWN_NODE_UPDATE;
	node.flags = IWN_FLAG_SET_DISABLE_TID;
	node.disable_tid = htole16(wn->disable_tid);
	error = ops->add_node(sc, &node, 1);
	if (error != 0)
		return error;

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
	ops->ampdu_tx_start(sc, ni, tid, ba->ba_winstart);
	iwn_nic_unlock(sc);
	return 0;
}

void
iwn_ampdu_tx_stop(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid)
{
	struct ieee80211_tx_ba *ba = &ni->ni_tx_ba[tid];
	struct iwn_softc *sc = ic->ic_softc;
	struct iwn_ops *ops = &sc->ops;

	if (iwn_nic_lock(sc) != 0)
		return;
	ops->ampdu_tx_stop(sc, tid, ba->ba_winstart);
	iwn_nic_unlock(sc);
}

void
iwn4965_ampdu_tx_start(struct iwn_softc *sc, struct ieee80211_node *ni,
    uint8_t tid, uint16_t ssn)
{
	struct iwn_node *wn = (void *)ni;
	int qid = 7 + tid;

	/* Stop TX scheduler while we're changing its configuration. */
	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid),
	    IWN4965_TXQ_STATUS_CHGACT);

	/* Assign RA/TID translation to the queue. */
	iwn_mem_write_2(sc, sc->sched_base + IWN4965_SCHED_TRANS_TBL(qid),
	    wn->id << 4 | tid);

	/* Enable chain-building mode for the queue. */
	iwn_prph_setbits(sc, IWN4965_SCHED_QCHAIN_SEL, 1 << qid);

	/* Set starting sequence number from the ADDBA request. */
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid << 8 | (ssn & 0xff));
	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_RDPTR(qid), ssn);

	/* Set scheduler window size. */
	iwn_mem_write(sc, sc->sched_base + IWN4965_SCHED_QUEUE_OFFSET(qid),
	    IWN_SCHED_WINSZ);
	/* Set scheduler frame limit. */
	iwn_mem_write(sc, sc->sched_base + IWN4965_SCHED_QUEUE_OFFSET(qid) + 4,
	    IWN_SCHED_LIMIT << 16);

	/* Enable interrupts for the queue. */
	iwn_prph_setbits(sc, IWN4965_SCHED_INTR_MASK, 1 << qid);

	/* Mark the queue as active. */
	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid),
	    IWN4965_TXQ_STATUS_ACTIVE | IWN4965_TXQ_STATUS_AGGR_ENA |
	    iwn_tid2fifo[tid] << 1);
}

void
iwn4965_ampdu_tx_stop(struct iwn_softc *sc, uint8_t tid, uint16_t ssn)
{
	int qid = 7 + tid;

	/* Stop TX scheduler while we're changing its configuration. */
	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid),
	    IWN4965_TXQ_STATUS_CHGACT);

	/* Set starting sequence number from the ADDBA request. */
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid << 8 | (ssn & 0xff));
	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_RDPTR(qid), ssn);

	/* Disable interrupts for the queue. */
	iwn_prph_clrbits(sc, IWN4965_SCHED_INTR_MASK, 1 << qid);

	/* Mark the queue as inactive. */
	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid),
	    IWN4965_TXQ_STATUS_INACTIVE | iwn_tid2fifo[tid] << 1);
}

void
iwn5000_ampdu_tx_start(struct iwn_softc *sc, struct ieee80211_node *ni,
    uint8_t tid, uint16_t ssn)
{
	struct iwn_node *wn = (void *)ni;
	int qid = 10 + tid;

	/* Stop TX scheduler while we're changing its configuration. */
	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),
	    IWN5000_TXQ_STATUS_CHGACT);

	/* Assign RA/TID translation to the queue. */
	iwn_mem_write_2(sc, sc->sched_base + IWN5000_SCHED_TRANS_TBL(qid),
	    wn->id << 4 | tid);

	/* Enable chain-building mode for the queue. */
	iwn_prph_setbits(sc, IWN5000_SCHED_QCHAIN_SEL, 1 << qid);

	/* Enable aggregation for the queue. */
	iwn_prph_setbits(sc, IWN5000_SCHED_AGGR_SEL, 1 << qid);

	/* Set starting sequence number from the ADDBA request. */
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid << 8 | (ssn & 0xff));
	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_RDPTR(qid), ssn);

	/* Set scheduler window size and frame limit. */
	iwn_mem_write(sc, sc->sched_base + IWN5000_SCHED_QUEUE_OFFSET(qid) + 4,
	    IWN_SCHED_LIMIT << 16 | IWN_SCHED_WINSZ);

	/* Enable interrupts for the queue. */
	iwn_prph_setbits(sc, IWN5000_SCHED_INTR_MASK, 1 << qid);

	/* Mark the queue as active. */
	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),
	    IWN5000_TXQ_STATUS_ACTIVE | iwn_tid2fifo[tid]);
}

void
iwn5000_ampdu_tx_stop(struct iwn_softc *sc, uint8_t tid, uint16_t ssn)
{
	int qid = 10 + tid;

	/* Stop TX scheduler while we're changing its configuration. */
	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),
	    IWN5000_TXQ_STATUS_CHGACT);

	/* Disable aggregation for the queue. */
	iwn_prph_clrbits(sc, IWN5000_SCHED_AGGR_SEL, 1 << qid);

	/* Set starting sequence number from the ADDBA request. */
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid << 8 | (ssn & 0xff));
	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_RDPTR(qid), ssn);

	/* Disable interrupts for the queue. */
	iwn_prph_clrbits(sc, IWN5000_SCHED_INTR_MASK, 1 << qid);

	/* Mark the queue as inactive. */
	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),
	    IWN5000_TXQ_STATUS_INACTIVE | iwn_tid2fifo[tid]);
}

/*
 * Query calibration tables from the initialization firmware.  We do this
 * only once at first boot.  Called from a process context.
 */
int
iwn5000_query_calibration(struct iwn_softc *sc)
{
	struct iwn5000_calib_config cmd;
	int error;

	memset(&cmd, 0, sizeof cmd);
	cmd.ucode.once.enable = 0xffffffff;
	cmd.ucode.once.start  = 0xffffffff;
	cmd.ucode.once.send   = 0xffffffff;
	cmd.ucode.flags       = 0xffffffff;
	DPRINTF(("sending calibration query\n"));
	error = iwn_cmd(sc, IWN5000_CMD_CALIB_CONFIG, &cmd, sizeof cmd, 0);
	if (error != 0)
		return error;

	/* Wait at most two seconds for calibration to complete. */
	if (!(sc->sc_flags & IWN_FLAG_CALIB_DONE))
		error = tsleep(sc, PCATCH, "iwncal", 2 * hz);
	return error;
}

/*
 * Send calibration results to the runtime firmware.  These results were
 * obtained on first boot from the initialization firmware.
 */
int
iwn5000_send_calibration(struct iwn_softc *sc)
{
	int idx, error;

	for (idx = 0; idx < 5; idx++) {
		if (sc->calibcmd[idx].buf == NULL)
			continue;	/* No results available. */
		DPRINTF(("send calibration result idx=%d len=%d\n",
		    idx, sc->calibcmd[idx].len));
		error = iwn_cmd(sc, IWN_CMD_PHY_CALIB, sc->calibcmd[idx].buf,
		    sc->calibcmd[idx].len, 0);
		if (error != 0) {
			printf("%s: could not send calibration result\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
	}
	return 0;
}

int
iwn5000_send_wimax_coex(struct iwn_softc *sc)
{
	struct iwn5000_wimax_coex wimax;

#ifdef notyet
	if (sc->hw_type == IWN_HW_REV_TYPE_6050) {
		/* Enable WiMAX coexistence for combo adapters. */
		wimax.flags =
		    IWN_WIMAX_COEX_ASSOC_WA_UNMASK |
		    IWN_WIMAX_COEX_UNASSOC_WA_UNMASK |
		    IWN_WIMAX_COEX_STA_TABLE_VALID |
		    IWN_WIMAX_COEX_ENABLE;
		memcpy(wimax.events, iwn6050_wimax_events,
		    sizeof iwn6050_wimax_events);
	} else
#endif
	{
		/* Disable WiMAX coexistence. */
		wimax.flags = 0;
		memset(wimax.events, 0, sizeof wimax.events);
	}
	DPRINTF(("Configuring WiMAX coexistence\n"));
	return iwn_cmd(sc, IWN5000_CMD_WIMAX_COEX, &wimax, sizeof wimax, 0);
}

int
iwn5000_crystal_calib(struct iwn_softc *sc)
{
	struct iwn5000_phy_calib_crystal cmd;

	memset(&cmd, 0, sizeof cmd);
	cmd.code = IWN5000_PHY_CALIB_CRYSTAL;
	cmd.ngroups = 1;
	cmd.isvalid = 1;
	cmd.cap_pin[0] = letoh32(sc->eeprom_crystal) & 0xff;
	cmd.cap_pin[1] = (letoh32(sc->eeprom_crystal) >> 16) & 0xff;
	DPRINTF(("sending crystal calibration %d, %d\n",
	    cmd.cap_pin[0], cmd.cap_pin[1]));
	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &cmd, sizeof cmd, 0);
}

int
iwn6000_temp_offset_calib(struct iwn_softc *sc)
{
	struct iwn6000_phy_calib_temp_offset cmd;

	memset(&cmd, 0, sizeof cmd);
	cmd.code = IWN6000_PHY_CALIB_TEMP_OFFSET;
	cmd.ngroups = 1;
	cmd.isvalid = 1;
	if (sc->eeprom_temp != 0)
		cmd.offset = htole16(sc->eeprom_temp);
	else
		cmd.offset = htole16(IWN_DEFAULT_TEMP_OFFSET);
	DPRINTF(("setting radio sensor offset to %d\n", letoh16(cmd.offset)));
	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &cmd, sizeof cmd, 0);
}

int
iwn2000_temp_offset_calib(struct iwn_softc *sc)
{
	struct iwn2000_phy_calib_temp_offset cmd;

	memset(&cmd, 0, sizeof cmd);
	cmd.code = IWN2000_PHY_CALIB_TEMP_OFFSET;
	cmd.ngroups = 1;
	cmd.isvalid = 1;
	if (sc->eeprom_rawtemp != 0) {
		cmd.offset_low = htole16(sc->eeprom_rawtemp);
		cmd.offset_high = htole16(sc->eeprom_temp);
	} else {
		cmd.offset_low = htole16(IWN_DEFAULT_TEMP_OFFSET);
		cmd.offset_high = htole16(IWN_DEFAULT_TEMP_OFFSET);
	}
	cmd.burnt_voltage_ref = htole16(sc->eeprom_voltage);
	DPRINTF(("setting radio sensor offset to %d:%d, voltage to %d\n",
	    letoh16(cmd.offset_low), letoh16(cmd.offset_high),
	    letoh16(cmd.burnt_voltage_ref)));
	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &cmd, sizeof cmd, 0);
}

/*
 * This function is called after the runtime firmware notifies us of its
 * readiness (called in a process context).
 */
int
iwn4965_post_alive(struct iwn_softc *sc)
{
	int error, qid;

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;

	/* Clear TX scheduler state in SRAM. */
	sc->sched_base = iwn_prph_read(sc, IWN_SCHED_SRAM_ADDR);
	iwn_mem_set_region_4(sc, sc->sched_base + IWN4965_SCHED_CTX_OFF, 0,
	    IWN4965_SCHED_CTX_LEN / sizeof (uint32_t));

	/* Set physical address of TX scheduler rings (1KB aligned). */
	iwn_prph_write(sc, IWN4965_SCHED_DRAM_ADDR, sc->sched_dma.paddr >> 10);

	IWN_SETBITS(sc, IWN_FH_TX_CHICKEN, IWN_FH_TX_CHICKEN_SCHED_RETRY);

	/* Disable chain mode for all our 16 queues. */
	iwn_prph_write(sc, IWN4965_SCHED_QCHAIN_SEL, 0);

	for (qid = 0; qid < IWN4965_NTXQUEUES; qid++) {
		iwn_prph_write(sc, IWN4965_SCHED_QUEUE_RDPTR(qid), 0);
		IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid << 8 | 0);

		/* Set scheduler window size. */
		iwn_mem_write(sc, sc->sched_base +
		    IWN4965_SCHED_QUEUE_OFFSET(qid), IWN_SCHED_WINSZ);
		/* Set scheduler frame limit. */
		iwn_mem_write(sc, sc->sched_base +
		    IWN4965_SCHED_QUEUE_OFFSET(qid) + 4,
		    IWN_SCHED_LIMIT << 16);
	}

	/* Enable interrupts for all our 16 queues. */
	iwn_prph_write(sc, IWN4965_SCHED_INTR_MASK, 0xffff);
	/* Identify TX FIFO rings (0-7). */
	iwn_prph_write(sc, IWN4965_SCHED_TXFACT, 0xff);

	/* Mark TX rings (4 EDCA + cmd + 2 HCCA) as active. */
	for (qid = 0; qid < 7; qid++) {
		static uint8_t qid2fifo[] = { 3, 2, 1, 0, 4, 5, 6 };
		iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid),
		    IWN4965_TXQ_STATUS_ACTIVE | qid2fifo[qid] << 1);
	}
	iwn_nic_unlock(sc);
	return 0;
}

/*
 * This function is called after the initialization or runtime firmware
 * notifies us of its readiness (called in a process context).
 */
int
iwn5000_post_alive(struct iwn_softc *sc)
{
	int error, qid;

	/* Switch to using ICT interrupt mode. */
	iwn5000_ict_reset(sc);

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;

	/* Clear TX scheduler state in SRAM. */
	sc->sched_base = iwn_prph_read(sc, IWN_SCHED_SRAM_ADDR);
	iwn_mem_set_region_4(sc, sc->sched_base + IWN5000_SCHED_CTX_OFF, 0,
	    IWN5000_SCHED_CTX_LEN / sizeof (uint32_t));

	/* Set physical address of TX scheduler rings (1KB aligned). */
	iwn_prph_write(sc, IWN5000_SCHED_DRAM_ADDR, sc->sched_dma.paddr >> 10);

	IWN_SETBITS(sc, IWN_FH_TX_CHICKEN, IWN_FH_TX_CHICKEN_SCHED_RETRY);

	/* Enable chain mode for all queues, except command queue. */
	iwn_prph_write(sc, IWN5000_SCHED_QCHAIN_SEL, 0xfffef);
	iwn_prph_write(sc, IWN5000_SCHED_AGGR_SEL, 0);

	for (qid = 0; qid < IWN5000_NTXQUEUES; qid++) {
		iwn_prph_write(sc, IWN5000_SCHED_QUEUE_RDPTR(qid), 0);
		IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid << 8 | 0);

		iwn_mem_write(sc, sc->sched_base +
		    IWN5000_SCHED_QUEUE_OFFSET(qid), 0);
		/* Set scheduler window size and frame limit. */
		iwn_mem_write(sc, sc->sched_base +
		    IWN5000_SCHED_QUEUE_OFFSET(qid) + 4,
		    IWN_SCHED_LIMIT << 16 | IWN_SCHED_WINSZ);
	}

	/* Enable interrupts for all our 20 queues. */
	iwn_prph_write(sc, IWN5000_SCHED_INTR_MASK, 0xfffff);
	/* Identify TX FIFO rings (0-7). */
	iwn_prph_write(sc, IWN5000_SCHED_TXFACT, 0xff);

	/* Mark TX rings (4 EDCA + cmd + 2 HCCA) as active. */
	for (qid = 0; qid < 7; qid++) {
		static uint8_t qid2fifo[] = { 3, 2, 1, 0, 7, 5, 6 };
		iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),
		    IWN5000_TXQ_STATUS_ACTIVE | qid2fifo[qid]);
	}
	iwn_nic_unlock(sc);

	/* Configure WiMAX coexistence for combo adapters. */
	error = iwn5000_send_wimax_coex(sc);
	if (error != 0) {
		printf("%s: could not configure WiMAX coexistence\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	if (sc->hw_type != IWN_HW_REV_TYPE_5150) {
		/* Perform crystal calibration. */
		error = iwn5000_crystal_calib(sc);
		if (error != 0) {
			printf("%s: crystal calibration failed\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
	}
	if (!(sc->sc_flags & IWN_FLAG_CALIB_DONE)) {
		/* Query calibration from the initialization firmware. */
		if ((error = iwn5000_query_calibration(sc)) != 0) {
			printf("%s: could not query calibration\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
		/*
		 * We have the calibration results now, reboot with the
		 * runtime firmware (call ourselves recursively!)
		 */
		iwn_hw_stop(sc);
		error = iwn_hw_init(sc);
	} else {
		/* Send calibration results to runtime firmware. */
		error = iwn5000_send_calibration(sc);
	}
	return error;
}

/*
 * The firmware boot code is small and is intended to be copied directly into
 * the NIC internal memory (no DMA transfer).
 */
int
iwn4965_load_bootcode(struct iwn_softc *sc, const uint8_t *ucode, int size)
{
	int error, ntries;

	size /= sizeof (uint32_t);

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;

	/* Copy microcode image into NIC memory. */
	iwn_prph_write_region_4(sc, IWN_BSM_SRAM_BASE,
	    (const uint32_t *)ucode, size);

	iwn_prph_write(sc, IWN_BSM_WR_MEM_SRC, 0);
	iwn_prph_write(sc, IWN_BSM_WR_MEM_DST, IWN_FW_TEXT_BASE);
	iwn_prph_write(sc, IWN_BSM_WR_DWCOUNT, size);

	/* Start boot load now. */
	iwn_prph_write(sc, IWN_BSM_WR_CTRL, IWN_BSM_WR_CTRL_START);

	/* Wait for transfer to complete. */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (!(iwn_prph_read(sc, IWN_BSM_WR_CTRL) &
		    IWN_BSM_WR_CTRL_START))
			break;
		DELAY(10);
	}
	if (ntries == 1000) {
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		iwn_nic_unlock(sc);
		return ETIMEDOUT;
	}

	/* Enable boot after power up. */
	iwn_prph_write(sc, IWN_BSM_WR_CTRL, IWN_BSM_WR_CTRL_START_EN);

	iwn_nic_unlock(sc);
	return 0;
}

int
iwn4965_load_firmware(struct iwn_softc *sc)
{
	struct iwn_fw_info *fw = &sc->fw;
	struct iwn_dma_info *dma = &sc->fw_dma;
	int error;

	/* Copy initialization sections into pre-allocated DMA-safe memory. */
	memcpy(dma->vaddr, fw->init.data, fw->init.datasz);
	bus_dmamap_sync(sc->sc_dmat, dma->map, 0, fw->init.datasz,
	    BUS_DMASYNC_PREWRITE);
	memcpy(dma->vaddr + IWN4965_FW_DATA_MAXSZ,
	    fw->init.text, fw->init.textsz);
	bus_dmamap_sync(sc->sc_dmat, dma->map, IWN4965_FW_DATA_MAXSZ,
	    fw->init.textsz, BUS_DMASYNC_PREWRITE);

	/* Tell adapter where to find initialization sections. */
	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
	iwn_prph_write(sc, IWN_BSM_DRAM_DATA_ADDR, dma->paddr >> 4);
	iwn_prph_write(sc, IWN_BSM_DRAM_DATA_SIZE, fw->init.datasz);
	iwn_prph_write(sc, IWN_BSM_DRAM_TEXT_ADDR,
	    (dma->paddr + IWN4965_FW_DATA_MAXSZ) >> 4);
	iwn_prph_write(sc, IWN_BSM_DRAM_TEXT_SIZE, fw->init.textsz);
	iwn_nic_unlock(sc);

	/* Load firmware boot code. */
	error = iwn4965_load_bootcode(sc, fw->boot.text, fw->boot.textsz);
	if (error != 0) {
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	/* Now press "execute". */
	IWN_WRITE(sc, IWN_RESET, 0);

	/* Wait at most one second for first alive notification. */
	if ((error = tsleep(sc, PCATCH, "iwninit", hz)) != 0) {
		printf("%s: timeout waiting for adapter to initialize\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* Retrieve current temperature for initial TX power calibration. */
	sc->rawtemp = sc->ucode_info.temp[3].chan20MHz;
	sc->temp = iwn4965_get_temperature(sc);

	/* Copy runtime sections into pre-allocated DMA-safe memory. */
	memcpy(dma->vaddr, fw->main.data, fw->main.datasz);
	bus_dmamap_sync(sc->sc_dmat, dma->map, 0, fw->main.datasz,
	    BUS_DMASYNC_PREWRITE);
	memcpy(dma->vaddr + IWN4965_FW_DATA_MAXSZ,
	    fw->main.text, fw->main.textsz);
	bus_dmamap_sync(sc->sc_dmat, dma->map, IWN4965_FW_DATA_MAXSZ,
	    fw->main.textsz, BUS_DMASYNC_PREWRITE);

	/* Tell adapter where to find runtime sections. */
	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
	iwn_prph_write(sc, IWN_BSM_DRAM_DATA_ADDR, dma->paddr >> 4);
	iwn_prph_write(sc, IWN_BSM_DRAM_DATA_SIZE, fw->main.datasz);
	iwn_prph_write(sc, IWN_BSM_DRAM_TEXT_ADDR,
	    (dma->paddr + IWN4965_FW_DATA_MAXSZ) >> 4);
	iwn_prph_write(sc, IWN_BSM_DRAM_TEXT_SIZE,
	    IWN_FW_UPDATED | fw->main.textsz);
	iwn_nic_unlock(sc);

	return 0;
}

int
iwn5000_load_firmware_section(struct iwn_softc *sc, uint32_t dst,
    const uint8_t *section, int size)
{
	struct iwn_dma_info *dma = &sc->fw_dma;
	int error;

	/* Copy firmware section into pre-allocated DMA-safe memory. */
	memcpy(dma->vaddr, section, size);
	bus_dmamap_sync(sc->sc_dmat, dma->map, 0, size, BUS_DMASYNC_PREWRITE);

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;

	IWN_WRITE(sc, IWN_FH_TX_CONFIG(IWN_SRVC_DMACHNL),
	    IWN_FH_TX_CONFIG_DMA_PAUSE);

	IWN_WRITE(sc, IWN_FH_SRAM_ADDR(IWN_SRVC_DMACHNL), dst);
	IWN_WRITE(sc, IWN_FH_TFBD_CTRL0(IWN_SRVC_DMACHNL),
	    IWN_LOADDR(dma->paddr));
	IWN_WRITE(sc, IWN_FH_TFBD_CTRL1(IWN_SRVC_DMACHNL),
	    IWN_HIADDR(dma->paddr) << 28 | size);
	IWN_WRITE(sc, IWN_FH_TXBUF_STATUS(IWN_SRVC_DMACHNL),
	    IWN_FH_TXBUF_STATUS_TBNUM(1) |
	    IWN_FH_TXBUF_STATUS_TBIDX(1) |
	    IWN_FH_TXBUF_STATUS_TFBD_VALID);

	/* Kick Flow Handler to start DMA transfer. */
	IWN_WRITE(sc, IWN_FH_TX_CONFIG(IWN_SRVC_DMACHNL),
	    IWN_FH_TX_CONFIG_DMA_ENA | IWN_FH_TX_CONFIG_CIRQ_HOST_ENDTFD);

	iwn_nic_unlock(sc);

	/* Wait at most five seconds for FH DMA transfer to complete. */
	return tsleep(sc, PCATCH, "iwninit", 5 * hz);
}

int
iwn5000_load_firmware(struct iwn_softc *sc)
{
	struct iwn_fw_part *fw;
	int error;

	/* Load the initialization firmware on first boot only. */
	fw = (sc->sc_flags & IWN_FLAG_CALIB_DONE) ?
	    &sc->fw.main : &sc->fw.init;

	error = iwn5000_load_firmware_section(sc, IWN_FW_TEXT_BASE,
	    fw->text, fw->textsz);
	if (error != 0) {
		printf("%s: could not load firmware %s section\n",
		    sc->sc_dev.dv_xname, ".text");
		return error;
	}
	error = iwn5000_load_firmware_section(sc, IWN_FW_DATA_BASE,
	    fw->data, fw->datasz);
	if (error != 0) {
		printf("%s: could not load firmware %s section\n",
		    sc->sc_dev.dv_xname, ".data");
		return error;
	}

	/* Now press "execute". */
	IWN_WRITE(sc, IWN_RESET, 0);
	return 0;
}

/*
 * Extract text and data sections from a legacy firmware image.
 */
int
iwn_read_firmware_leg(struct iwn_softc *sc, struct iwn_fw_info *fw)
{
	const uint32_t *ptr;
	size_t hdrlen = 24;
	uint32_t rev;

	ptr = (const uint32_t *)fw->data;
	rev = letoh32(*ptr++);

	/* Check firmware API version. */
	if (IWN_FW_API(rev) <= 1) {
		printf("%s: bad firmware, need API version >=2\n",
		    sc->sc_dev.dv_xname);
		return EINVAL;
	}
	if (IWN_FW_API(rev) >= 3) {
		/* Skip build number (version 2 header). */
		hdrlen += 4;
		ptr++;
	}
	if (fw->size < hdrlen) {
		printf("%s: firmware too short: %zu bytes\n",
		    sc->sc_dev.dv_xname, fw->size);
		return EINVAL;
	}
	fw->main.textsz = letoh32(*ptr++);
	fw->main.datasz = letoh32(*ptr++);
	fw->init.textsz = letoh32(*ptr++);
	fw->init.datasz = letoh32(*ptr++);
	fw->boot.textsz = letoh32(*ptr++);

	/* Check that all firmware sections fit. */
	if (fw->size < hdrlen + fw->main.textsz + fw->main.datasz +
	    fw->init.textsz + fw->init.datasz + fw->boot.textsz) {
		printf("%s: firmware too short: %zu bytes\n",
		    sc->sc_dev.dv_xname, fw->size);
		return EINVAL;
	}

	/* Get pointers to firmware sections. */
	fw->main.text = (const uint8_t *)ptr;
	fw->main.data = fw->main.text + fw->main.textsz;
	fw->init.text = fw->main.data + fw->main.datasz;
	fw->init.data = fw->init.text + fw->init.textsz;
	fw->boot.text = fw->init.data + fw->init.datasz;
	return 0;
}

/*
 * Extract text and data sections from a TLV firmware image.
 */
int
iwn_read_firmware_tlv(struct iwn_softc *sc, struct iwn_fw_info *fw,
    uint16_t alt)
{
	const struct iwn_fw_tlv_hdr *hdr;
	const struct iwn_fw_tlv *tlv;
	const uint8_t *ptr, *end;
	uint64_t altmask;
	uint32_t len;

	if (fw->size < sizeof (*hdr)) {
		printf("%s: firmware too short: %zu bytes\n",
		    sc->sc_dev.dv_xname, fw->size);
		return EINVAL;
	}
	hdr = (const struct iwn_fw_tlv_hdr *)fw->data;
	if (hdr->signature != htole32(IWN_FW_SIGNATURE)) {
		printf("%s: bad firmware signature 0x%08x\n",
		    sc->sc_dev.dv_xname, letoh32(hdr->signature));
		return EINVAL;
	}
	DPRINTF(("FW: \"%.64s\", build 0x%x\n", hdr->descr,
	    letoh32(hdr->build)));

	/*
	 * Select the closest supported alternative that is less than
	 * or equal to the specified one.
	 */
	altmask = letoh64(hdr->altmask);
	while (alt > 0 && !(altmask & (1ULL << alt)))
		alt--;	/* Downgrade. */
	DPRINTF(("using alternative %d\n", alt));

	ptr = (const uint8_t *)(hdr + 1);
	end = (const uint8_t *)(fw->data + fw->size);

	/* Parse type-length-value fields. */
	while (ptr + sizeof (*tlv) <= end) {
		tlv = (const struct iwn_fw_tlv *)ptr;
		len = letoh32(tlv->len);

		ptr += sizeof (*tlv);
		if (ptr + len > end) {
			printf("%s: firmware too short: %zu bytes\n",
			    sc->sc_dev.dv_xname, fw->size);
			return EINVAL;
		}
		/* Skip other alternatives. */
		if (tlv->alt != 0 && tlv->alt != htole16(alt))
			goto next;

		switch (letoh16(tlv->type)) {
		case IWN_FW_TLV_MAIN_TEXT:
			fw->main.text = ptr;
			fw->main.textsz = len;
			break;
		case IWN_FW_TLV_MAIN_DATA:
			fw->main.data = ptr;
			fw->main.datasz = len;
			break;
		case IWN_FW_TLV_INIT_TEXT:
			fw->init.text = ptr;
			fw->init.textsz = len;
			break;
		case IWN_FW_TLV_INIT_DATA:
			fw->init.data = ptr;
			fw->init.datasz = len;
			break;
		case IWN_FW_TLV_BOOT_TEXT:
			fw->boot.text = ptr;
			fw->boot.textsz = len;
			break;
		case IWN_FW_TLV_ENH_SENS:
			if (len !=  0) {
				printf("%s: TLV type %d has invalid size %u\n",
				    sc->sc_dev.dv_xname, letoh16(tlv->type),
				    len);
				goto next;
			}
			sc->sc_flags |= IWN_FLAG_ENH_SENS;
			break;
		case IWN_FW_TLV_PHY_CALIB:
			if (len != sizeof(uint32_t)) {
				printf("%s: TLV type %d has invalid size %u\n",
				    sc->sc_dev.dv_xname, letoh16(tlv->type),
				    len);
				goto next;
			}
			if (letoh32(*ptr) <= IWN5000_PHY_CALIB_MAX) {
				sc->reset_noise_gain = letoh32(*ptr);
				sc->noise_gain = letoh32(*ptr) + 1;
			}
			break;
		case IWN_FW_TLV_FLAGS:
			if (len < sizeof(uint32_t))
				break;
			if (len % sizeof(uint32_t))
				break;
			sc->tlv_feature_flags = letoh32(*ptr);
			DPRINTF(("feature: 0x%08x\n", sc->tlv_feature_flags));
			break;
		default:
			DPRINTF(("TLV type %d not handled\n",
			    letoh16(tlv->type)));
			break;
		}
 next:		/* TLV fields are 32-bit aligned. */
		ptr += (len + 3) & ~3;
	}
	return 0;
}

int
iwn_read_firmware(struct iwn_softc *sc)
{
	struct iwn_fw_info *fw = &sc->fw;
	int error;

	/*
	 * Some PHY calibration commands are firmware-dependent; these
	 * are the default values that will be overridden if
	 * necessary.
	 */
	sc->reset_noise_gain = IWN5000_PHY_CALIB_RESET_NOISE_GAIN;
	sc->noise_gain = IWN5000_PHY_CALIB_NOISE_GAIN;

	memset(fw, 0, sizeof (*fw));

	/* Read firmware image from filesystem. */
	if ((error = loadfirmware(sc->fwname, &fw->data, &fw->size)) != 0) {
		printf("%s: could not read firmware %s (error %d)\n",
		    sc->sc_dev.dv_xname, sc->fwname, error);
		return error;
	}
	if (fw->size < sizeof (uint32_t)) {
		printf("%s: firmware too short: %zu bytes\n",
		    sc->sc_dev.dv_xname, fw->size);
		free(fw->data, M_DEVBUF, fw->size);
		return EINVAL;
	}

	/* Retrieve text and data sections. */
	if (*(const uint32_t *)fw->data != 0)	/* Legacy image. */
		error = iwn_read_firmware_leg(sc, fw);
	else
		error = iwn_read_firmware_tlv(sc, fw, 1);
	if (error != 0) {
		printf("%s: could not read firmware sections\n",
		    sc->sc_dev.dv_xname);
		free(fw->data, M_DEVBUF, fw->size);
		return error;
	}

	/* Make sure text and data sections fit in hardware memory. */
	if (fw->main.textsz > sc->fw_text_maxsz ||
	    fw->main.datasz > sc->fw_data_maxsz ||
	    fw->init.textsz > sc->fw_text_maxsz ||
	    fw->init.datasz > sc->fw_data_maxsz ||
	    fw->boot.textsz > IWN_FW_BOOT_TEXT_MAXSZ ||
	    (fw->boot.textsz & 3) != 0) {
		printf("%s: firmware sections too large\n",
		    sc->sc_dev.dv_xname);
		free(fw->data, M_DEVBUF, fw->size);
		return EINVAL;
	}

	/* We can proceed with loading the firmware. */
	return 0;
}

int
iwn_clock_wait(struct iwn_softc *sc)
{
	int ntries;

	/* Set "initialization complete" bit. */
	IWN_SETBITS(sc, IWN_GP_CNTRL, IWN_GP_CNTRL_INIT_DONE);

	/* Wait for clock stabilization. */
	for (ntries = 0; ntries < 2500; ntries++) {
		if (IWN_READ(sc, IWN_GP_CNTRL) & IWN_GP_CNTRL_MAC_CLOCK_READY)
			return 0;
		DELAY(10);
	}
	printf("%s: timeout waiting for clock stabilization\n",
	    sc->sc_dev.dv_xname);
	return ETIMEDOUT;
}

int
iwn_apm_init(struct iwn_softc *sc)
{
	pcireg_t reg;
	int error;

	/* Disable L0s exit timer (NMI bug workaround). */
	IWN_SETBITS(sc, IWN_GIO_CHICKEN, IWN_GIO_CHICKEN_DIS_L0S_TIMER);
	/* Don't wait for ICH L0s (ICH bug workaround). */
	IWN_SETBITS(sc, IWN_GIO_CHICKEN, IWN_GIO_CHICKEN_L1A_NO_L0S_RX);

	/* Set FH wait threshold to max (HW bug under stress workaround). */
	IWN_SETBITS(sc, IWN_DBG_HPET_MEM, 0xffff0000);

	/* Enable HAP INTA to move adapter from L1a to L0s. */
	IWN_SETBITS(sc, IWN_HW_IF_CONFIG, IWN_HW_IF_CONFIG_HAP_WAKE_L1A);

	/* Retrieve PCIe Active State Power Management (ASPM). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag,
	    sc->sc_cap_off + PCI_PCIE_LCSR);
	/* Workaround for HW instability in PCIe L0->L0s->L1 transition. */
	if (reg & PCI_PCIE_LCSR_ASPM_L1)	/* L1 Entry enabled. */
		IWN_SETBITS(sc, IWN_GIO, IWN_GIO_L0S_ENA);
	else
		IWN_CLRBITS(sc, IWN_GIO, IWN_GIO_L0S_ENA);

	if (sc->hw_type != IWN_HW_REV_TYPE_4965 &&
	    sc->hw_type <= IWN_HW_REV_TYPE_1000)
		IWN_SETBITS(sc, IWN_ANA_PLL, IWN_ANA_PLL_INIT);

	/* Wait for clock stabilization before accessing prph. */
	if ((error = iwn_clock_wait(sc)) != 0)
		return error;

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
	if (sc->hw_type == IWN_HW_REV_TYPE_4965) {
		/* Enable DMA and BSM (Bootstrap State Machine). */
		iwn_prph_write(sc, IWN_APMG_CLK_EN,
		    IWN_APMG_CLK_CTRL_DMA_CLK_RQT |
		    IWN_APMG_CLK_CTRL_BSM_CLK_RQT);
	} else {
		/* Enable DMA. */
		iwn_prph_write(sc, IWN_APMG_CLK_EN,
		    IWN_APMG_CLK_CTRL_DMA_CLK_RQT);
	}
	DELAY(20);
	/* Disable L1-Active. */
	iwn_prph_setbits(sc, IWN_APMG_PCI_STT, IWN_APMG_PCI_STT_L1A_DIS);
	iwn_nic_unlock(sc);

	return 0;
}

void
iwn_apm_stop_master(struct iwn_softc *sc)
{
	int ntries;

	/* Stop busmaster DMA activity. */
	IWN_SETBITS(sc, IWN_RESET, IWN_RESET_STOP_MASTER);
	for (ntries = 0; ntries < 100; ntries++) {
		if (IWN_READ(sc, IWN_RESET) & IWN_RESET_MASTER_DISABLED)
			return;
		DELAY(10);
	}
	printf("%s: timeout waiting for master\n", sc->sc_dev.dv_xname);
}

void
iwn_apm_stop(struct iwn_softc *sc)
{
	iwn_apm_stop_master(sc);

	/* Reset the entire device. */
	IWN_SETBITS(sc, IWN_RESET, IWN_RESET_SW);
	DELAY(10);
	/* Clear "initialization complete" bit. */
	IWN_CLRBITS(sc, IWN_GP_CNTRL, IWN_GP_CNTRL_INIT_DONE);
}

int
iwn4965_nic_config(struct iwn_softc *sc)
{
	if (IWN_RFCFG_TYPE(sc->rfcfg) == 1) {
		/*
		 * I don't believe this to be correct but this is what the
		 * vendor driver is doing. Probably the bits should not be
		 * shifted in IWN_RFCFG_*.
		 */
		IWN_SETBITS(sc, IWN_HW_IF_CONFIG,
		    IWN_RFCFG_TYPE(sc->rfcfg) |
		    IWN_RFCFG_STEP(sc->rfcfg) |
		    IWN_RFCFG_DASH(sc->rfcfg));
	}
	IWN_SETBITS(sc, IWN_HW_IF_CONFIG,
	    IWN_HW_IF_CONFIG_RADIO_SI | IWN_HW_IF_CONFIG_MAC_SI);
	return 0;
}

int
iwn5000_nic_config(struct iwn_softc *sc)
{
	uint32_t tmp;
	int error;

	if (IWN_RFCFG_TYPE(sc->rfcfg) < 3) {
		IWN_SETBITS(sc, IWN_HW_IF_CONFIG,
		    IWN_RFCFG_TYPE(sc->rfcfg) |
		    IWN_RFCFG_STEP(sc->rfcfg) |
		    IWN_RFCFG_DASH(sc->rfcfg));
	}
	IWN_SETBITS(sc, IWN_HW_IF_CONFIG,
	    IWN_HW_IF_CONFIG_RADIO_SI | IWN_HW_IF_CONFIG_MAC_SI);

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
	iwn_prph_setbits(sc, IWN_APMG_PS, IWN_APMG_PS_EARLY_PWROFF_DIS);

	if (sc->hw_type == IWN_HW_REV_TYPE_1000) {
		/*
		 * Select first Switching Voltage Regulator (1.32V) to
		 * solve a stability issue related to noisy DC2DC line
		 * in the silicon of 1000 Series.
		 */
		tmp = iwn_prph_read(sc, IWN_APMG_DIGITAL_SVR);
		tmp &= ~IWN_APMG_DIGITAL_SVR_VOLTAGE_MASK;
		tmp |= IWN_APMG_DIGITAL_SVR_VOLTAGE_1_32;
		iwn_prph_write(sc, IWN_APMG_DIGITAL_SVR, tmp);
	}
	iwn_nic_unlock(sc);

	if (sc->sc_flags & IWN_FLAG_INTERNAL_PA) {
		/* Use internal power amplifier only. */
		IWN_WRITE(sc, IWN_GP_DRIVER, IWN_GP_DRIVER_RADIO_2X2_IPA);
	}
	if ((sc->hw_type == IWN_HW_REV_TYPE_6050 ||
	     sc->hw_type == IWN_HW_REV_TYPE_6005) && sc->calib_ver >= 6) {
		/* Indicate that ROM calibration version is >=6. */
		IWN_SETBITS(sc, IWN_GP_DRIVER, IWN_GP_DRIVER_CALIB_VER6);
	}
	if (sc->hw_type == IWN_HW_REV_TYPE_6005)
		IWN_SETBITS(sc, IWN_GP_DRIVER, IWN_GP_DRIVER_6050_1X2);
	if (sc->hw_type == IWN_HW_REV_TYPE_2030 ||
	    sc->hw_type == IWN_HW_REV_TYPE_2000 ||
	    sc->hw_type == IWN_HW_REV_TYPE_135 ||
	    sc->hw_type == IWN_HW_REV_TYPE_105)
		IWN_SETBITS(sc, IWN_GP_DRIVER, IWN_GP_DRIVER_RADIO_IQ_INVERT);
	return 0;
}

/*
 * Take NIC ownership over Intel Active Management Technology (AMT).
 */
int
iwn_hw_prepare(struct iwn_softc *sc)
{
	int ntries;

	/* Check if hardware is ready. */
	IWN_SETBITS(sc, IWN_HW_IF_CONFIG, IWN_HW_IF_CONFIG_NIC_READY);
	for (ntries = 0; ntries < 5; ntries++) {
		if (IWN_READ(sc, IWN_HW_IF_CONFIG) &
		    IWN_HW_IF_CONFIG_NIC_READY)
			return 0;
		DELAY(10);
	}

	/* Hardware not ready, force into ready state. */
	IWN_SETBITS(sc, IWN_HW_IF_CONFIG, IWN_HW_IF_CONFIG_PREPARE);
	for (ntries = 0; ntries < 15000; ntries++) {
		if (!(IWN_READ(sc, IWN_HW_IF_CONFIG) &
		    IWN_HW_IF_CONFIG_PREPARE_DONE))
			break;
		DELAY(10);
	}
	if (ntries == 15000)
		return ETIMEDOUT;

	/* Hardware should be ready now. */
	IWN_SETBITS(sc, IWN_HW_IF_CONFIG, IWN_HW_IF_CONFIG_NIC_READY);
	for (ntries = 0; ntries < 5; ntries++) {
		if (IWN_READ(sc, IWN_HW_IF_CONFIG) &
		    IWN_HW_IF_CONFIG_NIC_READY)
			return 0;
		DELAY(10);
	}
	return ETIMEDOUT;
}

int
iwn_hw_init(struct iwn_softc *sc)
{
	struct iwn_ops *ops = &sc->ops;
	int error, chnl, qid;

	/* Clear pending interrupts. */
	IWN_WRITE(sc, IWN_INT, 0xffffffff);

	if ((error = iwn_apm_init(sc)) != 0) {
		printf("%s: could not power on adapter\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* Select VMAIN power source. */
	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
	iwn_prph_clrbits(sc, IWN_APMG_PS, IWN_APMG_PS_PWR_SRC_MASK);
	iwn_nic_unlock(sc);

	/* Perform adapter-specific initialization. */
	if ((error = ops->nic_config(sc)) != 0)
		return error;

	/* Initialize RX ring. */
	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
	IWN_WRITE(sc, IWN_FH_RX_CONFIG, 0);
	IWN_WRITE(sc, IWN_FH_RX_WPTR, 0);
	/* Set physical address of RX ring (256-byte aligned). */
	IWN_WRITE(sc, IWN_FH_RX_BASE, sc->rxq.desc_dma.paddr >> 8);
	/* Set physical address of RX status (16-byte aligned). */
	IWN_WRITE(sc, IWN_FH_STATUS_WPTR, sc->rxq.stat_dma.paddr >> 4);
	/* Enable RX. */
	IWN_WRITE(sc, IWN_FH_RX_CONFIG,
	    IWN_FH_RX_CONFIG_ENA           |
	    IWN_FH_RX_CONFIG_IGN_RXF_EMPTY |	/* HW bug workaround */
	    IWN_FH_RX_CONFIG_IRQ_DST_HOST  |
	    IWN_FH_RX_CONFIG_SINGLE_FRAME  |
	    IWN_FH_RX_CONFIG_RB_TIMEOUT(0x11) | /* about 1/2 msec */
	    IWN_FH_RX_CONFIG_NRBD(IWN_RX_RING_COUNT_LOG));
	iwn_nic_unlock(sc);
	IWN_WRITE(sc, IWN_FH_RX_WPTR, (IWN_RX_RING_COUNT - 1) & ~7);

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;

	/* Initialize TX scheduler. */
	iwn_prph_write(sc, sc->sched_txfact_addr, 0);

	/* Set physical address of "keep warm" page (16-byte aligned). */
	IWN_WRITE(sc, IWN_FH_KW_ADDR, sc->kw_dma.paddr >> 4);

	/* Initialize TX rings. */
	for (qid = 0; qid < sc->ntxqs; qid++) {
		struct iwn_tx_ring *txq = &sc->txq[qid];

		/* Set physical address of TX ring (256-byte aligned). */
		IWN_WRITE(sc, IWN_FH_CBBC_QUEUE(qid),
		    txq->desc_dma.paddr >> 8);
	}
	iwn_nic_unlock(sc);

	/* Enable DMA channels. */
	for (chnl = 0; chnl < sc->ndmachnls; chnl++) {
		IWN_WRITE(sc, IWN_FH_TX_CONFIG(chnl),
		    IWN_FH_TX_CONFIG_DMA_ENA |
		    IWN_FH_TX_CONFIG_DMA_CREDIT_ENA);
	}

	/* Clear "radio off" and "commands blocked" bits. */
	IWN_WRITE(sc, IWN_UCODE_GP1_CLR, IWN_UCODE_GP1_RFKILL);
	IWN_WRITE(sc, IWN_UCODE_GP1_CLR, IWN_UCODE_GP1_CMD_BLOCKED);

	/* Clear pending interrupts. */
	IWN_WRITE(sc, IWN_INT, 0xffffffff);
	/* Enable interrupt coalescing. */
	IWN_WRITE(sc, IWN_INT_COALESCING, 512 / 8);
	/* Enable interrupts. */
	IWN_WRITE(sc, IWN_INT_MASK, sc->int_mask);

	/* _Really_ make sure "radio off" bit is cleared! */
	IWN_WRITE(sc, IWN_UCODE_GP1_CLR, IWN_UCODE_GP1_RFKILL);
	IWN_WRITE(sc, IWN_UCODE_GP1_CLR, IWN_UCODE_GP1_RFKILL);

	/* Enable shadow registers. */
	if (sc->hw_type >= IWN_HW_REV_TYPE_6000)
		IWN_SETBITS(sc, IWN_SHADOW_REG_CTRL, 0x800fffff);

	if ((error = ops->load_firmware(sc)) != 0) {
		printf("%s: could not load firmware\n", sc->sc_dev.dv_xname);
		return error;
	}
	/* Wait at most one second for firmware alive notification. */
	if ((error = tsleep(sc, PCATCH, "iwninit", hz)) != 0) {
		printf("%s: timeout waiting for adapter to initialize\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	/* Do post-firmware initialization. */
	return ops->post_alive(sc);
}

void
iwn_hw_stop(struct iwn_softc *sc)
{
	int chnl, qid, ntries;

	IWN_WRITE(sc, IWN_RESET, IWN_RESET_NEVO);

	/* Disable interrupts. */
	IWN_WRITE(sc, IWN_INT_MASK, 0);
	IWN_WRITE(sc, IWN_INT, 0xffffffff);
	IWN_WRITE(sc, IWN_FH_INT, 0xffffffff);
	sc->sc_flags &= ~IWN_FLAG_USE_ICT;

	/* Make sure we no longer hold the NIC lock. */
	iwn_nic_unlock(sc);

	/* Stop TX scheduler. */
	iwn_prph_write(sc, sc->sched_txfact_addr, 0);

	/* Stop all DMA channels. */
	if (iwn_nic_lock(sc) == 0) {
		for (chnl = 0; chnl < sc->ndmachnls; chnl++) {
			IWN_WRITE(sc, IWN_FH_TX_CONFIG(chnl), 0);
			for (ntries = 0; ntries < 200; ntries++) {
				if (IWN_READ(sc, IWN_FH_TX_STATUS) &
				    IWN_FH_TX_STATUS_IDLE(chnl))
					break;
				DELAY(10);
			}
		}
		iwn_nic_unlock(sc);
	}

	/* Stop RX ring. */
	iwn_reset_rx_ring(sc, &sc->rxq);

	/* Reset all TX rings. */
	for (qid = 0; qid < sc->ntxqs; qid++)
		iwn_reset_tx_ring(sc, &sc->txq[qid]);

	if (iwn_nic_lock(sc) == 0) {
		iwn_prph_write(sc, IWN_APMG_CLK_DIS,
		    IWN_APMG_CLK_CTRL_DMA_CLK_RQT);
		iwn_nic_unlock(sc);
	}
	DELAY(5);
	/* Power OFF adapter. */
	iwn_apm_stop(sc);
}

int
iwn_init(struct ifnet *ifp)
{
	struct iwn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int error;

	if ((error = iwn_hw_prepare(sc)) != 0) {
		printf("%s: hardware not ready\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	/* Check that the radio is not disabled by hardware switch. */
	if (!(IWN_READ(sc, IWN_GP_CNTRL) & IWN_GP_CNTRL_RFKILL)) {
		printf("%s: radio is disabled by hardware switch\n",
		    sc->sc_dev.dv_xname);
		error = EPERM;	/* :-) */
		goto fail;
	}

	/* Read firmware images from the filesystem. */
	if ((error = iwn_read_firmware(sc)) != 0) {
		printf("%s: could not read firmware\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	/* Initialize interrupt mask to default value. */
	sc->int_mask = IWN_INT_MASK_DEF;
	sc->sc_flags &= ~IWN_FLAG_USE_ICT;

	/* Initialize hardware and upload firmware. */
	error = iwn_hw_init(sc);
	free(sc->fw.data, M_DEVBUF, sc->fw.size);
	if (error != 0) {
		printf("%s: could not initialize hardware\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/* Configure adapter now that it is ready. */
	if ((error = iwn_config(sc)) != 0) {
		printf("%s: could not configure device\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_flags |= IFF_RUNNING;

	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		ieee80211_begin_scan(ifp);
	else
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

	return 0;

fail:	iwn_stop(ifp, 1);
	return error;
}

void
iwn_stop(struct ifnet *ifp, int disable)
{
	struct iwn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	timeout_del(&sc->calib_to);
	ifp->if_timer = sc->sc_tx_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* In case we were scanning, release the scan "lock". */
	if (ic->ic_scan_lock & IEEE80211_SCAN_REQUEST)
		wakeup(&ic->ic_scan_lock);
	ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

	/* Power OFF hardware. */
	iwn_hw_stop(sc);
}
@


1.191
log
@When iwn_stop() releases the scan lock wake processes sleeping on it.
Fixes ifconfig scan hanging after resume if system suspended during a scan.

ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.190 2017/06/02 11:18:16 stsp Exp $	*/
d4933 8
@


1.190
log
@When iwn(4) firmware reports missed beacons, send a probe request only
if ic_mgt_timer indicates that we're not already waiting for a response.
Fixes a flood of probe requests sent out while the interrupt kept firing.

Also, read the missed beacon counter value after DMA sync.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.189 2017/05/31 16:12:39 stsp Exp $	*/
d6513 2
@


1.189
log
@Implement support for missed beacon notifications in iwn(4).
Works with WIFIonICE.
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.188 2017/05/30 16:21:55 stsp Exp $	*/
d2507 1
a2507 1
			uint32_t missed = letoh32(miss->consecutive);
d2515 1
d2530 1
a2530 1
			if (missed > ic->ic_bmissthres)
@


1.188
log
@Improve the new ieee80211_{min,max}_rates() APIs and fix regressions.

Instead of returning an index into ni_rates, return the RVAL of the
basic rate we want to use. This allows a driver to unambiguously map
the basic rate to the corresponding hardware-specific rate value, and
reduces the possibility of bugs where indices are used with arrays
they weren't intended for.

Adjust iwn(4) accordingly, and use the lowest instead of the highest
basic rate in iwn_tx() to cope better in noisy environments.

Fixes association problems on 5GHz reported by tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.187 2017/05/30 11:01:38 stsp Exp $	*/
d2507 5
d2515 1
d2520 1
a2520 4
			DPRINTFN(2, ("beacons missed %d/%d\n",
			    letoh32(miss->consecutive), letoh32(miss->total)));
			if (ic->ic_state == IEEE80211_S_RUN &&
			    letoh32(miss->consecutive) > 5)
d2522 10
@


1.187
log
@Use ieee80211_{min,max}_basic_rate() in iwn(4).
ok mpi@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.186 2017/04/26 07:53:17 stsp Exp $	*/
d182 1
d2858 13
d2913 1
a2913 1
		ridx = wn->ridx[ieee80211_max_basic_rate(ic)];
d3484 1
a3484 1
		rinfo = &iwn_rates[wn->ridx[ieee80211_min_basic_rate(ic)]];
@


1.186
log
@Tell MiRA about the actual number of retries instead of pretending that
a frame which was retried N times was retried just once.
This punishes retry-heavy data rates even more and should reduce latency.
It does not seem to have a noticable effect on net throughput in my testing.
If this change causes throughput problems for anyone, let me know.
ok tb@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.185 2017/03/08 12:02:41 mpi Exp $	*/
d2899 1
a2899 2
		ridx = (IEEE80211_IS_CHAN_5GHZ(ni->ni_chan)) ?
		    IWN_RIDX_OFDM6 : IWN_RIDX_CCK1;
d3432 1
d3469 2
a3470 5
		/* Fill the rest with the lowest legacy rate. */
		if (IEEE80211_IS_CHAN_5GHZ(ni->ni_chan))
			rinfo = &iwn_rates[IWN_RIDX_OFDM6];
		else
			rinfo = &iwn_rates[IWN_RIDX_CCK1];
@


1.185
log
@Do not clear IFF_UP, even in the error path, clearing IFF_RUNNING
is enough.

This flag should only be set by the stack, drivers shouldn't mess
with it.

Discussed with dlg@@ and mikeb@@, ok mikeb@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.184 2017/02/20 15:38:04 krw Exp $	*/
d2389 1
a2389 1
			wn->mn.retries++;
@


1.184
log
@Remove hack to release/re-acquire netlock in _ioctl().

A short hang in X11 during an ifconfig scan is better than making
tcpdump(8) an express ticket to the ddb prompt.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.183 2017/02/16 10:15:12 mpi Exp $	*/
a2558 1
				ifp->if_flags &= ~IFF_UP;
a3241 1
			ifp->if_flags &= ~IFF_UP;
@


1.183
log
@Revert "Release the NET_LOCK() before entering per-driver ioctl() routine".

This is most likely to be the cause of the deadlock seen by port builders
since it's the only changed that happened after a2k17.

Instead bring back pirofti@@ original hack to release the NET_LOCK() inside
iwm(4) and iwn(4).

This fixes some splassert reported by bluhm@@

Deadlock reported by naddy@@ and rpe@@ and ajacoutot@@ confirmed the deadlock
has been introduced post a2k17.

Tested by and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.182 2017/01/22 10:17:38 dlg Exp $	*/
a3261 3
	/* XXXSMP breaks atomicity */
	rw_exit_write(&netlock);

d3263 1
a3263 2
	if (error) {
		rw_enter_write(&netlock);
a3264 1
	}
a3322 1
	rw_enter_write(&netlock);
@


1.182
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.181 2017/01/12 18:06:57 stsp Exp $	*/
d3262 3
d3266 2
a3267 1
	if (error)
d3269 1
d3328 1
@


1.181
log
@Rename ieee80211_mira_node_destroy() to ieee80211_mira_cancel_timeouts().
No functional change.

The previous name was chosen at a time when I could not yet anticipate
what this function would really end up doing.
The new name should make this function's purpose more obvious, especially
where it appears at strategic places in driver code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.180 2016/12/23 18:44:51 kettenis Exp $	*/
d2402 1
a2402 2
	} else
		ifp->if_opackets++;
@


1.180
log
@Hide static inline functions that are only used in debug code behind the same
#ifdef as the debug code itself.  Prevents clang from warning about these
functions being unused.

ok stsp@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.179 2016/12/18 10:37:42 stsp Exp $	*/
d1767 1
a1767 1
		ieee80211_mira_node_destroy(&wn->mn);
@


1.179
log
@While copying out channel flags to userspace, omit the HT channel flag if
we're not in 11n mode. This will allow tcpdump to show the mode correctly.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.178 2016/12/10 13:22:07 stsp Exp $	*/
d882 2
d891 2
@


1.178
log
@Make retry-heavy rates less attractive to mira.
The number of retried frames shrinks significantly.
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.177 2016/12/07 15:48:44 stsp Exp $	*/
d2133 1
d2140 4
a2143 2
		tap->wr_chan_flags =
		    htole16(ic->ic_channels[stat->chan].ic_flags);
d2914 1
d2918 4
a2921 1
		tap->wt_chan_flags = htole16(ni->ni_chan->ic_flags);
@


1.177
log
@Add mira support to iwn(4).
Please let me know about any regressions.

Tested by myself, tb@@, okan@@, jca@@, naddy@@, mlarkin@@
ok tb@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.176 2016/11/30 10:52:10 stsp Exp $	*/
d2381 3
a2383 2
		if (txfail) {
			wn->mn.retries += ackfailcnt;
a2384 1
		}
@


1.176
log
@Make iwn(4) receive MIMO frames in monitor mode. We can now sniff all 802.11n
frames the hardware is able to receive. Use an xT3R device for best results.
This change has not yet been tested on 1T1R devices due to lack of hardware.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.175 2016/10/28 10:11:22 stsp Exp $	*/
d58 1
d168 2
a169 2
void		iwn_tx_done(struct iwn_softc *, struct iwn_rx_desc *, int,
		    uint8_t);
d1698 4
a1701 2
	ieee80211_amrr_node_init(&sc->amrr, &wn->amn);
	/* Start at lowest available bit-rate, AMRR will raise. */
d1755 2
d1761 4
d1815 1
a1815 1
	struct iwn_node *wn = (struct iwn_node *)ni;
d1817 2
a1818 1
	ieee80211_amrr_choose(&sc->amrr, ni, &wn->amn);
d2332 4
d2339 2
a2340 1
	iwn_tx_done(sc, desc, stat->ackfailcnt, letoh32(stat->status) & 0xff);
d2356 2
a2357 1
	iwn_tx_done(sc, desc, stat->ackfailcnt, letoh16(stat->status) & 0xff);
d2364 2
a2365 2
iwn_tx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc, int ackfailcnt,
    uint8_t status)
d2371 4
a2374 1
	struct iwn_node *wn = (struct iwn_node *)data->ni;
d2377 16
a2392 5
	wn->amn.amn_txcnt++;
	if (ackfailcnt > 0)
		wn->amn.amn_retrycnt++;

	if (status != 1 && status != 2) {
d2954 2
d5015 5
@


1.175
log
@In iwn(4), stop forcing RTS for every frame in 11n mode.
The RTS threshold should be good enough and applies to all modes.
A similar change was made in iwm(4) not long ago.
tested by myself and benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.174 2016/10/08 14:44:36 stsp Exp $	*/
d4507 7
a4513 2
	    IWN_RXCHAIN_MIMO_COUNT(2) |
	    IWN_RXCHAIN_IDLE_COUNT(2);
d4516 3
a4518 3
	DPRINTF(("%s: rxon chan %d flags %x cck %x ofdm %x\n", __func__,
	    sc->rxon.chan, le32toh(sc->rxon.flags), sc->rxon.cck_mask,
	    sc->rxon.ofdm_mask));
@


1.174
log
@Make iwn(4) write MCS into the radiotap rate field.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.173 2016/10/08 14:35:19 stsp Exp $	*/
a2961 2
		else if (ni->ni_flags & IEEE80211_NODE_HT)
			flags |= IWN_TX_NEED_RTS;
@


1.173
log
@Hide details of fatal firmware errors in iwn(4) behind #ifdef IWN_DEBUG.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.172 2016/09/05 08:18:18 tedu Exp $	*/
d2134 21
a2154 17
		switch (stat->rate) {
		/* CCK rates. */
		case  10: tap->wr_rate =   2; break;
		case  20: tap->wr_rate =   4; break;
		case  55: tap->wr_rate =  11; break;
		case 110: tap->wr_rate =  22; break;
		/* OFDM rates. */
		case 0xd: tap->wr_rate =  12; break;
		case 0xf: tap->wr_rate =  18; break;
		case 0x5: tap->wr_rate =  24; break;
		case 0x7: tap->wr_rate =  36; break;
		case 0x9: tap->wr_rate =  48; break;
		case 0xb: tap->wr_rate =  72; break;
		case 0x1: tap->wr_rate =  96; break;
		case 0x3: tap->wr_rate = 108; break;
		/* Unknown rate: should not happen. */
		default:  tap->wr_rate =   0;
d2888 1
a2888 2
			/* XXX need a way to pass current MCS in 11n mode */
			tap->wt_rate = 0;
@


1.172
log
@convert busy flag and tsleep to rwlock as in iwm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.171 2016/09/02 17:10:48 stsp Exp $	*/
d2598 1
a2609 3
	/* Force a complete recalibration on next init. */
	sc->sc_flags &= ~IWN_FLAG_CALIB_DONE;

d2658 1
d2713 4
d2718 1
d2720 1
@


1.171
log
@Enable SGI for iwn(4).
The maximum 11n data rate should go up from 65Mbit/s to 72Mbit/s.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.170 2016/08/17 09:43:27 stsp Exp $	*/
d30 1
d541 1
d781 1
a782 3
	while (sc->sc_flags & IWN_FLAG_BUSY)
		tsleep(&sc->sc_flags, 0, "iwnpwr", 0);
	sc->sc_flags |= IWN_FLAG_BUSY;
a786 2
	sc->sc_flags &= ~IWN_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d788 1
d3214 3
a3217 11
	/*
	 * Prevent processes from entering this function while another
	 * process is tsleep'ing in it.
	 */
	while ((sc->sc_flags & IWN_FLAG_BUSY) && error == 0)
		error = tsleep(&sc->sc_flags, PCATCH, "iwnioc", 0);
	if (error != 0) {
		splx(s);
		return error;
	}
	sc->sc_flags |= IWN_FLAG_BUSY;
a3272 2
	sc->sc_flags &= ~IWN_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d3274 1
@


1.170
log
@iwn(4) scans all bands at once, as far as the net80211 stack is concerned.
So set the appropriate scan capability flags in the ic.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.169 2016/07/20 16:24:37 stsp Exp $	*/
a465 1
#ifdef notyet
d468 3
a470 1
		ic->ic_htcaps =
a474 1
		    IEEE80211_HTCAP_SGI20 |
d482 1
a483 1
#endif	/* notyet */
d3010 1
a3010 1
	    tx->id != sc->broadcast_id)
d3012 3
d3422 3
@


1.169
log
@Make the iwn(4) LED flash 10 times slower in monitor mode.
Makes running monitor mode over extended periods of time much less annoying.
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.168 2016/07/20 10:26:42 stsp Exp $	*/
d453 2
@


1.168
log
@Bring iwn_update_htprot() back, so iwn(4) will properly keep track
of HT protection changes while associated.

HT protection affects behaviour on Tx but is configured along with Rx settings
(because Intel likes it that way). And our previous iwn_update_htprot()
implementation had a bug where it would accidentally clear bits which enable
CCK rates for Rx. The Intel Wireless-N 2200 chip accordingly stopped receiving
some frames (most notably broadcast frames) and the link broke down.

Also, restore the power-saving level after updating the Rx config (like
Linux does), and add some DELAYs for good measure to ensure the firmware
has time to process asynchronous commands we send.

tested by myself and mlarkin@@
ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.167 2016/06/27 19:01:02 stsp Exp $	*/
d4873 1
a4873 1
		iwn_set_led(sc, IWN_LED_LINK, 5, 5);
@


1.167
log
@Revert if_iwm.c r1.166. We are still seeing links dropping upon HT protection
updates with some iwn chips, such as the 2200. Reported by mlarkin and krw.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.165 2016/04/28 08:28:18 stsp Exp $	*/
a5048 4
	/* XXX Disabled for now. It seems to cause output errors
	 * (tx status=0x83) and to make block ack sessions degrade
	 * into a half-working state. */
#if 0
d5050 1
d5066 1
d5073 2
d5079 19
a5097 1
#endif
@


1.166
log
@Put iwn_update_htprot() back, with a fixed implementation this time.
I hope this will fix problems due to collisions and interference.
tested by tb@@ and Marcus MERIGHI
ok tb@@
@
text
@d5049 4
a5053 1
	struct iwn_ops *ops = &sc->ops;
a5074 2
	s = splnet();

d5079 1
a5079 7

	/* All RXONs wipe the firmware's txpower table. Restore it. */
	error = ops->set_txpower(sc, 1);
	if (error != 0)
		printf("%s: could not set TX power\n", sc->sc_dev.dv_xname);

	splx(s);
@


1.165
log
@Add a better implementation of iwn's update_htprot callback which uses
the RXON_ASSOC command instead of clearing and restoring firmware state.
This matches the behaviour of the Linux driver more closely.

However, for now, keep this implementation disabled and do _nothing_ when
HT protection changes. For some unknown reason, updating HT protection
seems to be related to subsequent Tx errors and block ack session instablity.

We'll see how this approach works out in the wild. Please report any issues.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.164 2016/04/13 10:34:32 mpi Exp $	*/
a5048 4
	/* XXX Disabled for now. It seems to cause output errors
	 * (tx status=0x83) and to make block ack sessions degrade
	 * into a half-working state. */
#if 0
d5050 1
d5072 2
d5078 7
a5084 1
#endif
@


1.164
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.163 2016/02/07 23:56:19 tb Exp $	*/
d5049 4
a5053 1
	struct iwn_ops *ops = &sc->ops;
d5055 2
a5056 12
	struct iwn_node_info node;
	int error, ridx;

	timeout_del(&sc->calib_to);

	/* Fake a "disassociation" so we can change RXON configuration. */
	sc->rxon.filter &= ~htole32(IWN_FILTER_BSS);
	error = iwn_cmd(sc, IWN_CMD_RXON, &sc->rxon, sc->rxonsz, 1);
	if (error != 0) {
		printf("%s: RXON command failed\n", sc->sc_dev.dv_xname);
		return;
	}
a5062 6
	sc->rxon.filter |= htole32(IWN_FILTER_BSS);
	error = iwn_cmd(sc, IWN_CMD_RXON, &sc->rxon, sc->rxonsz, 1);
	if (error != 0) {
		printf("%s: RXON command failed\n", sc->sc_dev.dv_xname);
		return;
	}
d5064 10
a5073 4
	/* 
	 * The firmware loses TX power table, node table, LQ table,
	 * and sensitivity calibration after an RXON command.
	 */
d5075 5
a5079 55
	if ((error = ops->set_txpower(sc, 1)) != 0) {
		printf("%s: could not set TX power\n", sc->sc_dev.dv_xname);
		return;
	}

	ridx = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ?
	    IWN_RIDX_OFDM6 : IWN_RIDX_CCK1;
	if ((error = iwn_add_broadcast_node(sc, 1, ridx)) != 0) {
		printf("%s: could not add broadcast node\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	memset(&node, 0, sizeof node);
	IEEE80211_ADDR_COPY(node.macaddr, ni->ni_macaddr);
	node.id = IWN_ID_BSS;
	if (ni->ni_flags & IEEE80211_NODE_HT) {
		node.htmask = (IWN_AMDPU_SIZE_FACTOR_MASK |
		    IWN_AMDPU_DENSITY_MASK);
		node.htflags = htole32(
		    IWN_AMDPU_SIZE_FACTOR(
			(ic->ic_ampdu_params & IEEE80211_AMPDU_PARAM_LE)) |
		    IWN_AMDPU_DENSITY(
			(ic->ic_ampdu_params & IEEE80211_AMPDU_PARAM_SS) >> 2));
	}
	error = ops->add_node(sc, &node, 1);
	if (error != 0) {
		printf("%s: could not add BSS node\n", sc->sc_dev.dv_xname);
		return;
	}

	if ((error = iwn_set_link_quality(sc, ni)) != 0) {
		printf("%s: could not setup link quality for node %d\n",
		    sc->sc_dev.dv_xname, node.id);
		return;
	}

	if ((error = iwn_init_sensitivity(sc)) != 0) {
		printf("%s: could not set sensitivity\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	sc->calib.state = IWN_CALIB_STATE_ASSOC;
	sc->calib_cnt = 0;
	timeout_add_msec(&sc->calib_to, 500);

	if ((ni->ni_flags & IEEE80211_NODE_RXPROT) &&
	    ni->ni_pairwise_key.k_cipher == IEEE80211_CIPHER_CCMP) {
		if ((error = iwn_set_key(ic, ni, &ni->ni_pairwise_key)) != 0) {
			printf("%s: could not set pairwise ccmp key\n",
			    sc->sc_dev.dv_xname);
			return;
		}
	}
@


1.163
log
@Fix off-by-one in loop termination condition.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.162 2016/02/05 20:00:20 stsp Exp $	*/
a508 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.162
log
@Fix iwn(4) CCMP replay detection so it does not drop out-of-order A-MPDU
subframes. Helps 11n mode with WPA.
tested by me, tb@@, and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.161 2016/02/05 16:09:19 stsp Exp $	*/
d3422 1
a3422 1
			if (i++ >= IWN_MAX_TX_RETRIES)
@


1.161
log
@In iwn(4), set max A-MPDU length to 64k instead of 4k and tell the firmware
about A-MPDU spacing. Makes BlockAck happy.
tested by me, tb@@, krw@@, sthen@@, and Henrik Friedrichsen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.160 2016/02/04 21:32:01 stsp Exp $	*/
d1846 1
d1863 1
d1874 1
a1874 1
		if (hasqos && (sc->last_rx_valid & IWN_LAST_RX_AMPDU)) {
@


1.160
log
@Make iwn(4) pass 802.11 control frames in monitor mode.
Now we can see rts/cts, ack, blockack etc. in tcpdump(8).
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.159 2016/02/04 20:38:57 stsp Exp $	*/
d463 1
a463 2
	ic->ic_ampdu_params = IEEE80211_AMPDU_PARAM_SS_4;

d4942 9
a4950 4
#ifdef notyet
	node.htflags = htole32(IWN_AMDPU_SIZE_FACTOR(3) |
	    IWN_AMDPU_DENSITY(5));	/* 2us */
#endif
d5097 9
a5105 4
#ifdef notyet
	node.htflags = htole32(IWN_AMDPU_SIZE_FACTOR(3) |
	    IWN_AMDPU_DENSITY(5));	/* 2us */
#endif
@


1.159
log
@In iwn(4), don't forget about restoring the CCMP key to firmware after
HT protection setting updates. Unbreaks WPA in 11n mode.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.158 2016/01/25 11:27:11 stsp Exp $	*/
d2011 9
a2019 1
	if (len < sizeof (*wh)) {
d2069 5
a2073 1
	/* Grab a reference to the source node. */
d2075 7
d2085 2
a2086 1
	if ((wh->i_fc[1] & IEEE80211_FC1_PROTECTED) &&
@


1.158
log
@Keep track of HT protection settings in beacons and have 11n-capable
drivers update hardware configuration accordingly.
tested by myself, tb@@, deraadt@@, abieber@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.157 2016/01/13 14:39:35 stsp Exp $	*/
d5098 9
@


1.157
log
@Revert most of if_iwm.c r1.155. Use of channel zero was a symptom of
another bug introduced in my turbo mode removal commit; Now fixed.
Keep the debug printf added in r1.155.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.156 2016/01/13 08:32:19 stsp Exp $	*/
d229 2
d520 1
d5015 83
@


1.156
log
@Tell the iwn(4) firmware to retry failed Tx at 1Mbit/s instead of MCS 0.
Seems to make Tx rate scaling go up faster and helps Rx performance.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.155 2016/01/13 08:26:37 stsp Exp $	*/
d4450 1
a4450 1
	sc->rxon.chan = 1;
d4452 7
a4458 1
	sc->rxon.flags |= htole32(IWN_RXON_AUTO | IWN_RXON_24GHZ);
@


1.155
log
@Fix iwn(4) firmware SYSASSERT during hardware initialization.
For some reason we would end up passing channel number zero to
the RXON firmware command, which the firmware doesn't like.
ok sthen@@ reyk@@
and also tested by stefan@@, deraadt@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.154 2016/01/12 10:53:39 stsp Exp $	*/
a3400 8
		/* Fill the rest with MCS 0. */
		rinfo = &iwn_rates[iwn_mcs2ridx[0]];
 		while (i < IWN_MAX_TX_RETRIES - 1) {
			linkq.retry[i].plcp = rinfo->ht_plcp;
			linkq.retry[i].rflags = rinfo->ht_flags;
 			linkq.retry[i].rflags |= IWN_RFLAG_ANT(txant);
 			i++;
 		}
d3402 1
a3402 1
		/* Fill the last slot with the lowest legacy rate. */
@


1.154
log
@fix a misplaced curly brace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.153 2016/01/07 23:08:38 stsp Exp $	*/
d4458 1
a4458 1
	sc->rxon.chan = ieee80211_chan2ieee(ic, ic->ic_ibss_chan);
d4460 1
a4460 7
	if (IEEE80211_IS_CHAN_2GHZ(ic->ic_ibss_chan)) {
		sc->rxon.flags |= htole32(IWN_RXON_AUTO | IWN_RXON_24GHZ);
		if (ic->ic_flags & IEEE80211_F_USEPROT)
			sc->rxon.flags |= htole32(IWN_RXON_TGG_PROT);
		DPRINTF(("%s: 2ghz prot 0x%x\n", __func__,
		    le32toh(sc->rxon.flags)));
	}
d4486 3
@


1.153
log
@Fix A-MPDU parameters in link quality firmware commands in iwn(4) and iwm(4).
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.152 2016/01/06 19:56:50 stsp Exp $	*/
d3432 1
a3432 1
			}
@


1.152
log
@Initialize the A-MPDU parameters field in HT capability elements.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.151 2016/01/06 09:17:42 stsp Exp $	*/
d3383 1
a3383 1
	linkq.ampdu_max = 31;
d3465 1
a3465 1
	linkq.ampdu_max = 64;
@


1.151
log
@Ensure that iwn(4) always uses a CCK rate as last fallback in the firmware's
tx rate retry table. This will hopefully make 11n mode work in very noisy
environments. iwm(4) already does the same.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.150 2016/01/05 18:41:15 stsp Exp $	*/
d461 1
@


1.150
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.149 2016/01/04 13:54:19 stsp Exp $	*/
d3402 1
a3402 1
		while (i < IWN_MAX_TX_RETRIES) {
d3405 12
@


1.149
log
@Add initial support for 11n mode to the iwn(4) driver.
Only MCS 0 to 7 are supported for now.

Tested by many. There might still be outstanding issues but they now appear
to be rare. I'm putting this in so that additional fixes can be developed
and tested more easily if required. This diff is already quite large for
one commit.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.148 2015/11/25 03:09:59 dlg Exp $	*/
a155 1
#ifndef IEEE80211_NO_HT
a157 1
#endif
a228 1
#ifndef IEEE80211_NO_HT
a244 1
#endif
a455 1
#ifndef IEEE80211_NO_HT
a460 1
#endif
a462 1
#ifndef IEEE80211_NO_HT
a478 1
#endif	/* !IEEE80211_NO_HT */
a487 1
#ifndef IEEE80211_NO_HT
a497 1
#endif
a516 1
#ifndef IEEE80211_NO_HT
a522 1
#endif
a565 1
#ifndef IEEE80211_NO_HT
a567 1
#endif
a602 1
#ifndef IEEE80211_NO_HT
a604 1
#endif
a1635 1
#ifndef IEEE80211_NO_HT
a1637 1
#endif
a1696 1
#ifndef IEEE80211_NO_HT
a1697 1
#endif
a1722 1
#ifndef IEEE80211_NO_HT
a1724 1
#endif
a2146 1
#ifndef IEEE80211_NO_HT
a2160 1
#endif
a2422 1
#ifndef IEEE80211_NO_HT
a2426 1
#endif
a2831 1
#ifndef IEEE80211_NO_HT
a2833 1
#endif
a2836 1
#ifndef IEEE80211_NO_HT
a2839 1
#endif
a2850 1
#ifndef IEEE80211_NO_HT
a2856 1
#endif
a2928 1
#ifndef IEEE80211_NO_HT
d2931 1
a2931 1
#endif
a2976 1
#ifndef IEEE80211_NO_HT
a2980 1
#endif
a2982 1
#ifndef IEEE80211_NO_HT
a2986 1
#endif
a2994 1
#ifndef IEEE80211_NO_HT
a2997 1
#endif
a3385 1
#ifndef IEEE80211_NO_HT
d3408 1
a3408 3
	} else
#endif
	{
a4675 1
#ifndef IEEE80211_NO_HT
a4677 1
#endif
d4859 1
a4859 1
#ifndef IEEE80211_NO_HT
d4868 1
a4868 1
#endif
a4872 1
#ifndef IEEE80211_NO_HT
a4876 1
#endif
a5005 1
#ifndef IEEE80211_NO_HT
a5219 1
#endif	/* !IEEE80211_NO_HT */
@


1.148
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.147 2015/11/24 13:33:17 mpi Exp $	*/
d151 1
a151 1
		    struct ieee80211_key *);
d192 1
a192 1
int		iwn_add_broadcast_node(struct iwn_softc *, int);
d283 1
a283 1
int iwn_debug = 0;
d461 9
d487 1
d500 1
d502 1
a502 1
			ic->ic_sup_mcs[1] = 0xff;	/* MCS 7-15 */
d505 1
d530 1
d534 1
d1652 5
d1715 3
d1722 3
a1724 2
		for (ridx = 0; ridx <= IWN_RIDX_MAX; ridx++)
			if (iwn_rates[ridx].rate == rate)
d1726 1
d1743 4
d1752 2
a1753 1
			if (iwn_rates[ridx].rate == rate)
d1848 1
a1848 1
		DPRINTF(("sending request for statistics\n"));
d1860 1
a1860 1
iwn_ccmp_decap(struct iwn_softc *sc, struct mbuf *m, struct ieee80211_key *k)
d1862 2
d1868 1
a1868 1
	int hdrlen;
d1879 2
a1880 2
	tid = ieee80211_has_qos(wh) ?
	    ieee80211_get_qos(wh) & IEEE80211_QOS_TID : 0;
d1891 32
a1922 6
		/*
		 * Not necessarily a replayed frame since we did not check
		 * the sequence number of the 802.11 header yet.
		 */
		DPRINTF(("CCMP replayed\n"));
		return 1;
d1952 7
a1958 1
	sc->last_rx_valid = 1;
d1988 1
a1988 1
		sc->last_rx_valid = 0;
d1990 10
d2106 1
a2106 1
		if (iwn_ccmp_decap(sc, m, &ni->ni_pairwise_key) != 0) {
d2357 2
a2358 1
	if (status != 1 && status != 2)
d2360 1
a2360 1
	else
d2474 1
a2474 1
			DPRINTF(("beacons missed %d/%d\n",
d2855 2
a2856 2
	    type != IEEE80211_FC0_TYPE_DATA) {
		ridx = (ic->ic_curmode == IEEE80211_MODE_11A) ?
d2858 2
a2859 1
	} else if (ic->ic_fixed_rate != -1) {
d2861 11
a2871 2
	} else
		ridx = wn->ridx[ni->ni_txrate];
a2872 1

d2881 9
a2889 1
		tap->wt_rate = rinfo->rate;
d2951 1
a2951 1
		/* NB: Group frames are sent using CCK in 802.11b/g. */
d2961 4
d3009 16
a3024 2
	tx->plcp = rinfo->plcp;
	tx->rflags = rinfo->flags;
d3032 6
a3037 1
		tx->linkq = ni->ni_rates.rs_nrates - ni->ni_txrate - 1;
d3425 37
a3461 10
	/* Start at highest available bit-rate. */
	txrate = rs->rs_nrates - 1;
	for (i = 0; i < IWN_MAX_TX_RETRIES; i++) {
		rinfo = &iwn_rates[wn->ridx[txrate]];
		linkq.retry[i].plcp = rinfo->plcp;
		linkq.retry[i].rflags = rinfo->flags;
		linkq.retry[i].rflags |= IWN_RFLAG_ANT(txant);
		/* Next retry at immediate lower bit-rate. */
		if (txrate > 0)
			txrate--;
d3463 1
d3471 1
a3471 1
iwn_add_broadcast_node(struct iwn_softc *sc, int async)
d3499 1
a3499 2
	rinfo = (sc->sc_ic.ic_curmode != IEEE80211_MODE_11A) ?
	    &iwn_rates[IWN_RIDX_CCK1] : &iwn_rates[IWN_RIDX_OFDM6];
d3708 2
a3709 1
			if ((ridx / 8) & 1)
d3711 1
d3730 1
a3730 1
			if ((ridx / 8) & 1)	/* MIMO */
d3912 1
a3912 1
	DPRINTF(("sending request for statistics\n"));
d4423 1
a4423 1
	int error;
d4489 1
a4489 1
	if (IEEE80211_IS_CHAN_2GHZ(ic->ic_ibss_chan))
d4491 5
d4527 3
a4529 1
	if ((error = iwn_add_broadcast_node(sc, 0)) != 0) {
d4817 1
a4817 1
	int error;
d4823 1
a4823 1
	if (IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
d4825 5
d4843 1
a4843 1
	default:	/* Assume 802.11b/g. */
d4847 3
a4849 2
	DPRINTF(("rxon chan %d flags %x cck %x ofdm %x\n", sc->rxon.chan,
	    sc->rxon.flags, sc->rxon.cck_mask, sc->rxon.ofdm_mask));
d4865 3
a4867 1
	if ((error = iwn_add_broadcast_node(sc, 1)) != 0) {
d4903 34
a4936 1
	DPRINTF(("rxon chan %d flags %x\n", sc->rxon.chan, sc->rxon.flags));
d5073 1
a5073 1
	DPRINTFN(2, ("ADDBA RA=%d TID=%d SSN=%d\n", wn->id, tid,
d5075 1
d5097 1
a5097 1
	DPRINTFN(2, ("DELBA RA=%d TID=%d\n", wn->id, tid));
d6202 1
a6202 1
	    IWN_FH_RX_CONFIG_RB_TIMEOUT(0) |
@


1.147
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.146 2015/11/04 12:11:59 dlg Exp $	*/
d2301 2
a2302 2
		if (sc->qfullmsk == 0 && (ifp->if_flags & IFF_OACTIVE)) {
			ifp->if_flags &= ~IFF_OACTIVE;
d3039 1
a3039 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d3044 1
a3044 1
			ifp->if_flags |= IFF_OACTIVE;
d6170 1
a6170 1
	ifp->if_flags &= ~IFF_OACTIVE;
d6192 2
a6193 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.146
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.145 2015/10/25 13:04:28 mpi Exp $	*/
a50 1
#include <net/if_types.h>
@


1.145
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.144 2015/09/01 07:09:55 deraadt Exp $	*/
d3049 1
a3049 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
@


1.144
log
@sizes for free(), mostly related to firmwares.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.143 2015/05/27 22:10:52 kettenis Exp $	*/
a3108 1
	struct ifaddr *ifa;
a3126 1
		ifa = (struct ifaddr *)data;
a3127 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.143
log
@Use m_defrag(9) instead of rolling our own inlined version.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.142 2015/04/08 09:29:49 jasper Exp $	*/
d4662 1
a4662 1
	free(buf, M_DEVBUF, 0);
d5733 1
a5733 1
		free(fw->data, M_DEVBUF, 0);
d5745 1
a5745 1
		free(fw->data, M_DEVBUF, 0);
d5758 1
a5758 1
		free(fw->data, M_DEVBUF, 0);
d6161 1
a6161 1
	free(sc->fw.data, M_DEVBUF, 0);
@


1.142
log
@don't leak the chip's hardware address during scans when a randomized address
is set by the user.
previously the address read from the eeprom would also be used in discovery
frames, even if later data frames would contain the spoofed address.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.141 2015/03/14 03:38:48 jsg Exp $	*/
a2752 1
	struct mbuf *m1;
d2964 6
a2970 6
		if (error != EFBIG) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m);
			return error;
		}
d2972 1
a2972 2
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
a2975 13
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(m1);
				return ENOBUFS;
			}
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_pkthdr.len = m1->m_len = m->m_pkthdr.len;
		m_freem(m);
		m = m1;

@


1.141
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.140 2015/02/10 23:25:46 mpi Exp $	*/
d4497 1
d4550 1
a4550 1
	
d4576 1
@


1.140
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.139 2015/02/08 13:45:57 stsp Exp $	*/
a48 1
#include <net/if_arp.h>
@


1.139
log
@Sprinkle some string constant consistency on iwn(4) as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.138 2015/01/27 03:17:36 dlg Exp $	*/
a2004 1
	m->m_pkthdr.rcvif = ifp;
@


1.138
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.137 2014/12/22 02:28:52 tedu Exp $	*/
d1191 1
a1191 1
			printf("%s: can't not map mbuf (error %d)\n",
d5741 2
a5742 2
		printf("%s: error, %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, sc->fwname);
d6000 1
a6000 1
		printf("%s: could not power ON adapter\n",
@


1.137
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.136 2014/12/19 22:44:58 guenther Exp $	*/
d115 1
a115 1
void		iwn_init_task(void *, void *);
d536 1
a536 1
	task_set(&sc->init_task, iwn_init_task, sc, NULL);
d769 1
a769 1
	iwn_init_task(sc, NULL);
d773 1
a773 1
iwn_init_task(void *arg1, void *arg2)
@


1.136
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.135 2014/09/10 07:22:09 dcoppa Exp $	*/
a3146 1
#ifdef INET
a3148 1
#endif
@


1.135
log
@
s/IWL/IWN/ in comment here too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.134 2014/09/09 18:55:08 sthen Exp $	*/
d36 1
a38 1
#include <machine/endian.h>
@


1.134
log
@Backport https://svnweb.freebsd.org/base?view=revision&revision=258829 to fix
scans with various iwn(4) devices. From Fabian Raetz, testing by Fabian,
Marcin Piotr Pawlowski, Mike Burns, kettenis@@ and myself. ok kettenis@@ with
minor tweaks for whitespace in #define lines which I've done; also I have
done s/IWL/IWN/ in comments as noticed by dcoppa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.133 2014/07/22 13:12:11 mpi Exp $	*/
d4612 2
a4613 2
	 * the aforementioned issue. Thus use IWL_GOOD_CRC_TH_NEVER
	 * here instead of IWL_GOOD_CRC_TH_DISABLED.
@


1.133
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.132 2014/07/12 18:48:51 tedu Exp $	*/
d223 3
d4430 60
d4502 1
a4502 1
	uint16_t rxchain;
d4504 1
a4504 1
	int buflen, error;
a4539 1
		hdr->crc_threshold = 0xffff;
d4553 6
d4560 3
d4568 2
d4598 35
a4641 2
		if (!(c->ic_flags & IEEE80211_CHAN_PASSIVE))
			chan->flags |= htole32(IWN_CHAN_ACTIVE);
d4644 20
a4666 2
			chan->active  = htole16(24);
			chan->passive = htole16(110);
a4668 2
			chan->active  = htole16(36);
			chan->passive = htole16(120);
d5705 8
@


1.132
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.131 2014/03/19 10:09:19 mpi Exp $	*/
a54 1
#include <netinet/in_systm.h>
a55 1
#include <netinet/ip.h>
@


1.131
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.130 2014/02/11 19:44:22 kettenis Exp $	*/
d2163 1
a2163 1
		free(sc->calibcmd[idx].buf, M_DEVBUF);
d4559 1
a4559 1
	free(buf, M_DEVBUF);
d5622 1
a5622 1
		free(fw->data, M_DEVBUF);
d5634 1
a5634 1
		free(fw->data, M_DEVBUF);
d5647 1
a5647 1
		free(fw->data, M_DEVBUF);
d6050 1
a6050 1
	free(sc->fw.data, M_DEVBUF);
@


1.130
log
@Adjust for renamed pcidevs defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.129 2014/02/11 19:30:10 kettenis Exp $	*/
d3067 1
a3067 1
			ni = (void *)m->m_pkthdr.rcvif;
@


1.129
log
@Intel Centrino Wireless-N 2200 (tested) and Wireless-N 105/135 (untested)
support.  Tested by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.128 2014/02/10 19:08:58 kettenis Exp $	*/
d97 4
a100 4
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_2030_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_2030_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_2000_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_2000_2 },
@


1.128
log
@Intel Centrino Wireless-N 2230 support.  From Fabian Raetz, with a little bit
of polishing from yours truly.  Tested by Fabian and Benoit Lecocq.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.127 2013/12/06 21:03:04 deraadt Exp $	*/
d99 6
d373 1
a373 1
	sc->hw_type = (IWN_READ(sc, IWN_HW_REV) >> 4) & 0xf;
d668 13
d1559 4
a1562 1
	if (sc->hw_type == IWN_HW_REV_TYPE_2030) {
d2137 4
a2140 1
		    sc->hw_type == IWN_HW_REV_TYPE_2030)
d4209 2
a4210 1
	if (sc->hw_type == IWN_HW_REV_TYPE_2030) {
d4313 6
a4318 1
	} else if (sc->hw_type == IWN_HW_REV_TYPE_2030) {
d5817 4
a5820 1
	if (sc->hw_type == IWN_HW_REV_TYPE_2030)
@


1.127
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.126 2013/11/30 19:41:21 kettenis Exp $	*/
d97 2
d248 2
a249 1
int		iwn5000_temp_offset_calib(struct iwn_softc *);
d657 5
d1540 8
d2114 2
a2115 1
		if (sc->hw_type == IWN_HW_REV_TYPE_5150)
d3842 1
a3842 1
	cmd.code = IWN5000_PHY_CALIB_RESET_NOISE_GAIN;
d3892 1
a3892 1
	cmd.code = IWN5000_PHY_CALIB_NOISE_GAIN;
a4179 1
	struct iwn6000_btcoex_config btconfig;
d4184 45
a4228 18
	memset(&btconfig, 0, sizeof btconfig);
	btconfig.flags = IWN_BT_FLAG_COEX6000_CHAN_INHIBITION |
	    (IWN_BT_FLAG_COEX6000_MODE_3W << IWN_BT_FLAG_COEX6000_MODE_SHIFT) |
	    IWN_BT_FLAG_SYNC_2_BT_DISABLE;
	btconfig.max_kill = 5;
	btconfig.bt3_t7_timer = 1;
	btconfig.kill_ack = htole32(0xffff0000);
	btconfig.kill_cts = htole32(0xffff0000);
	btconfig.sample_time = 2;
	btconfig.bt3_t2_timer = 0xc;
	for (i = 0; i < 12; i++)
		btconfig.lookup_table[i] = htole32(btcoex_3wire[i]);
	btconfig.valid = htole16(0xff);
	btconfig.prio_boost = 0xf0;
	DPRINTF(("configuring advanced bluetooth coexistence\n"));
	error = iwn_cmd(sc, IWN_CMD_BT_COEX, &btconfig, sizeof(btconfig), 1);
	if (error != 0)
		return (error);
d4279 1
d4281 8
a4288 2
		/* Set radio temperature sensor offset. */
		error = iwn5000_temp_offset_calib(sc);
d5042 1
a5042 1
iwn5000_temp_offset_calib(struct iwn_softc *sc)
d5044 1
a5044 1
	struct iwn5000_phy_calib_temp_offset cmd;
d5047 1
a5047 1
	cmd.code = IWN5000_PHY_CALIB_TEMP_OFFSET;
d5058 23
d5534 21
d5572 8
d5786 2
@


1.126
log
@Seems we simply have to live with fatal firmware errors.  Even Linux, with its
driver written by Intel engineers occasionally gets them.  So when we get one,
simply reset the chip, reload the firware and bring the interface up again.

tested by stsp@@, pascal@@
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.125 2013/11/14 12:40:00 dlg Exp $	*/
d108 1
a108 1
void		iwn_resume(struct iwn_softc *);
d724 2
a725 2
	case DVACT_RESUME:
		iwn_resume(sc);
d733 1
a733 1
iwn_resume(struct iwn_softc *sc)
d741 1
a741 2

	task_add(systq, &sc->init_task);
@


1.125
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.124 2013/10/01 20:06:01 sf Exp $	*/
d108 2
a109 1
void		iwn_resume(void *, void *);
a312 2
	task_set(&sc->sc_resume_t, iwn_resume, sc, NULL);

d526 1
d689 1
d725 1
a725 1
		task_add(systq, &sc->sc_resume_t);
d733 1
a733 1
iwn_resume(void *arg1, void *arg2)
a734 2
	struct iwn_softc *sc = arg1;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
a735 1
	int s;
d742 10
d757 1
a757 1
	if (ifp->if_flags & IFF_UP)
a2603 1
		ifp->if_flags &= ~IFF_UP;
d2605 1
@


1.124
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.123 2013/08/29 19:06:39 syl Exp $	*/
d35 1
a35 1
#include <sys/workq.h>
d312 2
d724 1
a724 2
		workq_queue_task(NULL, &sc->sc_resume_wqt, 0,
		    iwn_resume, sc, NULL);
@


1.123
log
@Add support for advanced btcoex. This commit is not really needed
but it reduces the diff against the FreeBSD version.

Tested on:
 My Wifi Link 130.
 jca@@ Wifi Link 5300.
 Jan Stary Wifi Link 4965 (thanks).

Adapted from FreeBSD r220894.

ok mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.122 2013/08/08 23:32:50 syl Exp $	*/
d5351 1
a5351 1
		printf("%s: firmware too short: %d bytes\n",
d5364 1
a5364 1
		printf("%s: firmware too short: %d bytes\n",
d5392 1
a5392 1
		printf("%s: firmware too short: %d bytes\n",
d5424 1
a5424 1
			printf("%s: firmware too short: %d bytes\n",
d5479 1
a5479 1
		printf("%s: firmware too short: %d bytes\n",
@


1.122
log
@Add support for Intel Wifi Link 130.

ok kettenis@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.121 2013/08/07 01:06:35 bluhm Exp $	*/
d213 1
d4148 59
d4263 3
a4265 3
	if (sc->sc_flags & IWN_FLAG_ADV_BT_COEX) {
		/* XXX Advanced bluetooth coexistence isn't implemented yet. */
	} else {
d4267 4
a4270 5
		if (error != 0) {
			printf("%s: could not configure bluetooth coexistence\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
@


1.121
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.120 2013/06/11 18:15:52 deraadt Exp $	*/
d93 2
d644 2
a645 6
		if (pid == PCI_PRODUCT_INTEL_WL_1030_1 ||
		    pid == PCI_PRODUCT_INTEL_WL_1030_2 ||
		    pid == PCI_PRODUCT_INTEL_WL_6030_1 ||
		    pid == PCI_PRODUCT_INTEL_WL_6030_2 ||
		    pid == PCI_PRODUCT_INTEL_WL_6235_1 ||
		    pid == PCI_PRODUCT_INTEL_WL_6235_2) {
@


1.120
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.119 2013/05/29 23:16:52 yuo Exp $	*/
a55 1
#include <netinet/in_var.h>
@


1.119
log
@add another pid of Centrino Advanced-N 6235.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.118 2012/11/17 14:02:51 kettenis Exp $	*/
d1829 1
a1829 1
	ovbcopy(wh, mtod(m, caddr_t) + IEEE80211_CCMP_HDRLEN, hdrlen);
@


1.118
log
@Newer chips feature "advanced" bluetooth coexistence, which is why sending
them the "normal" command to configure bluetooth coexistence fails and
makes the firmware crash.  Rename the IWN_FLAG_NO_BT_COEX flag and adjust some
comments to reflect this knowledge.

ok jcs@@, mikeb@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.117 2012/11/17 13:57:23 kettenis Exp $	*/
d95 1
d647 2
a648 1
		    pid == PCI_PRODUCT_INTEL_WL_6235_1) {
@


1.117
log
@Add support for Intel Centrino Wireless-N 1030.  Might not fully work yet, but
instead of causing a firmware crash, scanning now works.

Tested by Daniel Levai.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.116 2012/11/14 12:30:19 kettenis Exp $	*/
d648 1
a648 5

			/* XXX: The 6235 generates a fatal firmware error when
			 * Bluetooth coexistence is attempted, so don't try
			 * it */
			sc->sc_flags |= IWN_FLAG_NO_BT_COEX;
d4203 4
a4206 2
	if (!(sc->sc_flags & IWN_FLAG_NO_BT_COEX)) {
		/* Configure bluetooth coexistence. */
@


1.116
log
@Use the iwn-6030 firmware for the Intel Centrino Advanced-N 6030 as well.
Makes these variants actually work.

Based on a diff from James Turned, also confirmed by weerd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.115 2012/11/11 20:45:31 jcs Exp $	*/
d642 3
a644 1
		if (pid == PCI_PRODUCT_INTEL_WL_6030_1 ||
@


1.115
log
@add support for the Intel Centrino Advanced-N 6235 to iwn(4).

committed over a 6235 device, of course.

ok deraadt@@ kettenis@@ stsp@@ armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.114 2012/10/12 19:53:24 haesbaert Exp $	*/
d642 3
a644 1
		if (pid == PCI_PRODUCT_INTEL_WL_6235_1) {
@


1.114
log
@Cleanup false positives for uninitialized uses.
Part of the work to remove -Wno-uninitialized.

ok blambert jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.113 2012/01/26 00:45:40 deraadt Exp $	*/
d93 2
a94 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_100_2 }
d642 9
a650 1
		sc->fwname = "iwn-6005";
d4203 8
a4210 6
	/* Configure bluetooth coexistence. */
	error = iwn_send_btcoex(sc);
	if (error != 0) {
		printf("%s: could not configure bluetooth coexistence\n",
		    sc->sc_dev.dv_xname);
		return error;
@


1.113
log
@stop the calibration timeout when stopping the interface (i noticed
this issue due to suspend/resume during a calibration)
ok stsp miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.112 2011/09/02 18:49:36 kettenis Exp $	*/
d2714 1
@


1.112
log
@Differential gain calibration makes the 6005 firmware crap out, so skip it for
now until we figure out why.  This probably means the device won't function
optimally, but that's better than not functioning at all.  Makes my
"Intel Centrinto Advanced-N 6205" work quite well.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.111 2011/09/01 18:49:56 kettenis Exp $	*/
d5866 1
@


1.111
log
@The 6005 and 6050-based parts need DC calibration turned on, otherwise the
firmware will crap out, at least on the 6005.  First step to getting my
"Intel Centrino Advanced-N 6205" to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.110 2011/06/16 19:48:22 oga Exp $	*/
d2163 8
@


1.110
log
@Enable msi support on iwn.

tested by many for over a week. ok kettenis@@ phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.109 2011/01/24 18:32:54 damien Exp $	*/
d210 1
d4130 12
d4156 11
@


1.109
log
@unbreak 6200 support by forcing Tx/Rx chains masks since ROM
contains broken data.
reported by matthew@@; verified by me against Linux driver.

remove two if_ierrors++ while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.108 2011/01/09 15:53:06 damien Exp $	*/
d341 1
a341 1
	if (pci_intr_map(pa, &ih) != 0) {
@


1.108
log
@trust the Tx/Rx chains masks in ROM except for the 4965 and 5100
which are known to have broken ROMs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.107 2011/01/09 15:45:37 damien Exp $	*/
d627 1
a627 1
		    pid == PCI_PRODUCT_INTEL_WL_6200_2)
d629 4
a1867 1
			ifp->if_ierrors++;
a1880 1
		ifp->if_ierrors++;
@


1.107
log
@cleanup; change the way opns are attached.
include a fix for Intel Centrino Advanced-N 6250 devices
by Antonio R Nicolosi.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.106 2010/12/31 19:48:56 damien Exp $	*/
d564 1
d606 1
a612 2
		sc->txchainmask = IWN_ANT_A;
		sc->rxchainmask = IWN_ANT_AB;
a617 2
		sc->txchainmask = IWN_ANT_ABC;
		sc->rxchainmask = IWN_ANT_ABC;
a621 2
		sc->txchainmask = IWN_ANT_A;
		sc->rxchainmask = IWN_ANT_AB;
d626 2
a627 3
		switch (pid) {
		case PCI_PRODUCT_INTEL_WL_6200_1:
		case PCI_PRODUCT_INTEL_WL_6200_2:
a628 8
			sc->txchainmask = IWN_ANT_BC;
			sc->rxchainmask = IWN_ANT_BC;
			break;
		default:
			sc->txchainmask = IWN_ANT_ABC;
			sc->rxchainmask = IWN_ANT_ABC;
			break;
		}
a632 2
		sc->txchainmask = IWN_ANT_AB;
		sc->rxchainmask = IWN_ANT_AB;
a636 2
		sc->txchainmask = IWN_ANT_AB;
		sc->rxchainmask = IWN_ANT_AB;
@


1.106
log
@regen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.105 2010/09/07 16:21:45 deraadt Exp $	*/
a34 1
#include <sys/sensors.h>
d98 2
a99 4
const struct	iwn_hal *iwn_hal_attach(struct iwn_softc *, pci_product_id_t);
#ifndef SMALL_KERNEL
void		iwn_sensor_attach(struct iwn_softc *);
#endif
d208 2
d239 2
a274 56
static const struct iwn_hal iwn4965_hal = {
	iwn4965_load_firmware,
	iwn4965_read_eeprom,
	iwn4965_post_alive,
	iwn4965_nic_config,
	iwn4965_update_sched,
	iwn4965_get_temperature,
	iwn4965_get_rssi,
	iwn4965_set_txpower,
	iwn4965_init_gains,
	iwn4965_set_gains,
	iwn4965_add_node,
	iwn4965_tx_done,
#ifndef IEEE80211_NO_HT
	iwn4965_ampdu_tx_start,
	iwn4965_ampdu_tx_stop,
#endif
	IWN4965_NTXQUEUES,
	IWN4965_NDMACHNLS,
	IWN4965_ID_BROADCAST,
	IWN4965_RXONSZ,
	IWN4965_SCHEDSZ,
	IWN4965_FW_TEXT_MAXSZ,
	IWN4965_FW_DATA_MAXSZ,
	IWN4965_FWSZ,
	IWN4965_SCHED_TXFACT
};

static const struct iwn_hal iwn5000_hal = {
	iwn5000_load_firmware,
	iwn5000_read_eeprom,
	iwn5000_post_alive,
	iwn5000_nic_config,
	iwn5000_update_sched,
	iwn5000_get_temperature,
	iwn5000_get_rssi,
	iwn5000_set_txpower,
	iwn5000_init_gains,
	iwn5000_set_gains,
	iwn5000_add_node,
	iwn5000_tx_done,
#ifndef IEEE80211_NO_HT
	iwn5000_ampdu_tx_start,
	iwn5000_ampdu_tx_stop,
#endif
	IWN5000_NTXQUEUES,
	IWN5000_NDMACHNLS,
	IWN5000_ID_BROADCAST,
	IWN5000_RXONSZ,
	IWN5000_SCHEDSZ,
	IWN5000_FW_TEXT_MAXSZ,
	IWN5000_FW_DATA_MAXSZ,
	IWN5000_FWSZ,
	IWN5000_SCHED_TXFACT
};

a297 1
	const struct iwn_hal *hal;
d320 2
a321 2
	reg &= ~0xff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, reg);
d357 8
a364 3
	/* Attach Hardware Abstraction Layer. */
	hal = iwn_hal_attach(sc, PCI_PRODUCT(pa->pa_id));
	if (hal == NULL)
d366 1
d404 2
a405 2
	/* Allocate TX rings (16 on 4965AGN, 20 on 5000.) */
	for (i = 0; i < hal->ntxqs; i++) {
d447 3
a449 2
	/* Set HT capabilities. */
	ic->ic_htcaps =
d451 1
a451 1
	    IEEE80211_HTCAP_AMSDU7935 |
d453 10
a462 9
	    IEEE80211_HTCAP_CBW20_40 |
	    IEEE80211_HTCAP_SGI20 |
	    IEEE80211_HTCAP_SGI40;
	if (sc->hw_type != IWN_HW_REV_TYPE_4965)
		ic->ic_htcaps |= IEEE80211_HTCAP_GF;
	if (sc->hw_type == IWN_HW_REV_TYPE_6050)
		ic->ic_htcaps |= IEEE80211_HTCAP_SMPS_DYN;
	else
		ic->ic_htcaps |= IEEE80211_HTCAP_SMPS_DIS;
d473 8
a480 6
	/* Set supported HT rates. */
	ic->ic_sup_mcs[0] = 0xff;		/* MCS 0-7 */
	if (sc->nrxchains > 1)
		ic->ic_sup_mcs[1] = 0xff;	/* MCS 7-15 */
	if (sc->nrxchains > 2)
		ic->ic_sup_mcs[2] = 0xff;	/* MCS 16-23 */
a515 3
#ifndef SMALL_KERNEL
	iwn_sensor_attach(sc);
#endif
d532 40
a571 2
const struct iwn_hal *
iwn_hal_attach(struct iwn_softc *sc, pci_product_id_t pid)
d573 27
a599 1
	sc->hw_type = (IWN_READ(sc, IWN_HW_REV) >> 4) & 0xf;
a601 7
	case IWN_HW_REV_TYPE_4965:
		sc->sc_hal = &iwn4965_hal;
		sc->limits = &iwn4965_sensitivity_limits;
		sc->fwname = "iwn-4965";
		sc->txchainmask = IWN_ANT_AB;
		sc->rxchainmask = IWN_ANT_ABC;
		break;
a602 1
		sc->sc_hal = &iwn5000_hal;
a608 1
		sc->sc_hal = &iwn5000_hal;
a615 1
		sc->sc_hal = &iwn5000_hal;
a621 1
		sc->sc_hal = &iwn5000_hal;
a627 1
		sc->sc_hal = &iwn5000_hal;
a643 1
		sc->sc_hal = &iwn5000_hal;
a649 1
		sc->sc_hal = &iwn5000_hal;
d657 1
a657 1
		return NULL;
d659 1
a659 17
	return sc->sc_hal;
}

#ifndef SMALL_KERNEL
/*
 * Attach the adapter on-board thermal sensor to the sensors framework.
 */
void
iwn_sensor_attach(struct iwn_softc *sc)
{
	strlcpy(sc->sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof sc->sensordev.xname);
	sc->sensor.type = SENSOR_TEMP;
	/* Temperature is not valid unless interface is up. */
	sc->sensor.flags = SENSOR_FINVALID;
	sensor_attach(&sc->sensordev, &sc->sensor);
	sensordev_install(&sc->sensordev);
a660 1
#endif
d697 1
a697 1
	for (qid = 0; qid < sc->sc_hal->ntxqs; qid++)
a706 6
#ifndef SMALL_KERNEL
	/* Detach the thermal sensor. */
	sensor_detach(&sc->sensordev, &sc->sensor);
	sensordev_deinstall(&sc->sensordev);
#endif

d743 2
a744 2
	reg &= ~0xff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, reg);
d1053 1
a1053 1
	    (void **)&sc->sched, sc->sc_hal->schedsz, 1024);
d1095 1
a1095 1
	    sc->sc_hal->fwsz, 16);
d1112 1
a1112 1
	/* Allocate RX descriptors (256-byte aligned.) */
d1122 1
a1122 1
	/* Allocate RX status area (16-byte aligned.) */
d1163 1
a1163 1
		/* Set physical address of RX buffer (256-byte aligned.) */
d1228 1
a1228 1
	/* Allocate TX descriptors (256-byte aligned.) */
d1334 1
a1334 1
	/* Set physical address of ICT table (4KB aligned.) */
d1352 1
a1352 1
	const struct iwn_hal *hal = sc->sc_hal;
d1388 6
d1397 5
d1407 1
a1407 1
	hal->read_eeprom(sc);
d1422 1
a1422 1
	/* Read regulatory domain (4 ASCII characters.) */
d1425 1
a1425 1
	/* Read the list of authorized channels (20MHz ones only.) */
d1499 1
a1499 1
	int32_t temp, volt;
d1504 1
a1504 1
	/* Read regulatory domain (4 ASCII characters.) */
d1510 1
a1510 1
	/* Read the list of authorized channels (20MHz ones only.) */
d1530 1
a1530 1
		temp = letoh16(val);
d1533 1
a1533 1
		sc->temp_off = temp - (volt / -5);
d1535 1
a1535 1
		    temp, volt, sc->temp_off));
d1864 1
a1864 1
	const struct iwn_hal *hal = sc->sc_hal;
d2002 1
a2002 1
	rssi = hal->get_rssi(stat);
d2076 1
a2076 1
 * firmware on response to a CMD_CALIB_CONFIG command (5000 only.)
d2095 1
a2095 2
		if (sc->hw_type == IWN_HW_REV_TYPE_5150 ||
		    sc->hw_type == IWN_HW_REV_TYPE_6050)
d2139 1
a2139 1
	const struct iwn_hal *hal = sc->sc_hal;
d2159 1
a2159 1
		temp = hal->get_temperature(sc);
d2162 1
a2162 5
		/* Update temperature sensor. */
		sc->sensor.value = IWN_CTOMUK(temp);
		sc->sensor.flags &= ~SENSOR_FINVALID;

		/* Update TX power if need be (4965AGN only.) */
d2289 1
d2330 1
a2330 1
			sc->sc_hal->tx_done(sc, desc, data);
d2468 1
a2468 1
	for (qid = 0; qid < sc->sc_hal->ntxqs; qid++) {
a2481 1
	const struct iwn_hal *hal = sc->sc_hal;
d2491 1
a2491 1
	    IWN_FW_DATA_BASE + hal->fw_data_maxsz) {
d2528 1
a2528 1
	for (i = 0; i < hal->ntxqs; i++) {
d2633 1
a2633 1
 * 5000 adapters use a slightly different format.)
a2690 1
	const struct iwn_hal *hal = sc->sc_hal;
d2831 1
a2831 1
		tx->id = hal->broadcast_id;
d2865 1
a2865 1
	if (tx->id == hal->broadcast_id) {
d2980 1
a2980 1
	hal->update_sched(sc, ring->qid, ring->cur, tx->id, totlen);
d3223 1
a3223 1
	sc->sc_hal->update_sched(sc, ring->qid, ring->cur, 0, 0);
d3300 1
a3300 1
	const struct iwn_hal *hal = sc->sc_hal;
d3309 1
a3309 1
	node.id = hal->broadcast_id;
d3311 1
a3311 1
	if ((error = hal->add_node(sc, &node, async)) != 0)
d3318 1
a3318 1
	linkq.id = hal->broadcast_id;
d3413 1
a3413 1
	val = (uint64_t)ni->ni_intval * 1024;	/* msecs -> usecs */
d3426 1
a3426 1
	/* Adjust TX power if need be (delta >= 3 degC.) */
d3674 1
a3674 1
	if (r1 == r3)	/* Prevents division by 0 (should not happen.) */
d3694 1
a3694 2
	 * TX power calibration is handled by firmware.  We export it to
	 * users through the sensor framework though.
d3710 1
a3710 1
	const struct iwn_hal *hal = sc->sc_hal;
d3733 1
a3733 1
	if ((error = hal->init_gains(sc)) != 0)
d3751 1
a3751 1
	const struct iwn_hal *hal = sc->sc_hal;
d3781 1
a3781 1
	(void)hal->set_gains(sc);
d3787 1
a3787 1
	(void)iwn_cmd(sc, IWN_CMD_RXON, &sc->rxon, hal->rxonsz, 1);
d3923 1
a3923 1
	fa *= 200 * 1024;	/* 200TU */
d3978 1
a3978 1
	fa *= 200 * 1024;	/* 200TU */
d4039 2
a4040 1
	struct iwn_sensitivity_cmd cmd;
d4043 1
d4046 6
a4051 6
	cmd.corr_ofdm_x1     = htole16(calib->ofdm_x1);
	cmd.corr_ofdm_mrc_x1 = htole16(calib->ofdm_mrc_x1);
	cmd.corr_ofdm_x4     = htole16(calib->ofdm_x4);
	cmd.corr_ofdm_mrc_x4 = htole16(calib->ofdm_mrc_x4);
	cmd.energy_ofdm      = htole16(sc->limits->energy_ofdm);
	cmd.energy_ofdm_th   = htole16(62);
d4053 3
a4055 3
	cmd.corr_cck_x4      = htole16(calib->cck_x4);
	cmd.corr_cck_mrc_x4  = htole16(calib->cck_mrc_x4);
	cmd.energy_cck       = htole16(calib->energy_cck);
d4057 16
a4072 8
	cmd.corr_barker      = htole16(190);
	cmd.corr_barker_mrc  = htole16(390);

	DPRINTFN(2, ("setting sensitivity %d/%d/%d/%d/%d/%d/%d\n",
	    calib->ofdm_x1, calib->ofdm_mrc_x1, calib->ofdm_x4,
	    calib->ofdm_mrc_x4, calib->cck_x4, calib->cck_mrc_x4,
	    calib->energy_cck));
	return iwn_cmd(sc, IWN_CMD_SET_SENSITIVITY, &cmd, sizeof cmd, 1);
d4131 13
d4146 1
a4146 1
	const struct iwn_hal *hal = sc->sc_hal;
a4148 1
	struct iwn_bluetooth bluetooth;
d4153 11
a4163 1
	/* Configure valid TX chains for 5000 Series. */
d4177 1
a4177 6
	memset(&bluetooth, 0, sizeof bluetooth);
	bluetooth.flags = IWN_BT_COEX_CHAN_ANN | IWN_BT_COEX_BT_PRIO;
	bluetooth.lead_time = IWN_BT_LEAD_TIME_DEF;
	bluetooth.max_kill = IWN_BT_MAX_KILL_DEF;
	DPRINTF(("configuring bluetooth coexistence\n"));
	error = iwn_cmd(sc, IWN_CMD_BT_COEX, &bluetooth, sizeof bluetooth, 0);
d4218 1
a4218 1
	error = iwn_cmd(sc, IWN_CMD_RXON, &sc->rxon, hal->rxonsz, 0);
d4231 1
a4231 1
	if ((error = hal->set_txpower(sc, 0)) != 0) {
d4297 1
a4297 1
	tx->id = sc->sc_hal->broadcast_id;
d4388 1
a4388 1
	const struct iwn_hal *hal = sc->sc_hal;
d4418 1
a4418 1
	error = iwn_cmd(sc, IWN_CMD_RXON, &sc->rxon, hal->rxonsz, 1);
d4425 1
a4425 1
	if ((error = hal->set_txpower(sc, 1)) != 0) {
d4444 1
a4444 1
	const struct iwn_hal *hal = sc->sc_hal;
d4470 1
a4470 1
	error = iwn_cmd(sc, IWN_CMD_RXON, &sc->rxon, hal->rxonsz, 1);
d4478 1
a4478 1
	if ((error = hal->set_txpower(sc, 1)) != 0) {
d4496 1
a4496 1
	error = hal->add_node(sc, &node, 1);
d4532 1
a4532 1
	const struct iwn_hal *hal = sc->sc_hal;
d4547 1
a4547 1
	    hal->broadcast_id : wn->id;
d4554 1
a4554 1
	return hal->add_node(sc, &node, 1);
d4562 1
a4562 1
	const struct iwn_hal *hal = sc->sc_hal;
d4576 1
a4576 1
	    hal->broadcast_id : wn->id;
d4582 1
a4582 1
	(void)hal->add_node(sc, &node, 1);
d4596 1
d4608 1
a4608 1
	return sc->sc_hal->add_node(sc, &node, 1);
d4613 1
a4613 1
 * Block Ack agreement (eg. uppon receipt of a DELBA frame.)
d4620 1
d4630 1
a4630 1
	(void)sc->sc_hal->add_node(sc, &node, 1);
d4643 1
a4643 1
	const struct iwn_hal *hal = sc->sc_hal;
d4655 1
a4655 1
	error = hal->add_node(sc, &node, 1);
d4661 1
a4661 1
	hal->ampdu_tx_start(sc, ni, tid, ba->ba_winstart);
d4672 1
d4676 1
a4676 1
	sc->sc_hal->ampdu_tx_stop(sc, tid, ba->ba_winstart);
d4878 33
d4913 1
a4913 1
 * readiness (called in a process context.)
d4928 1
a4928 1
	/* Set physical address of TX scheduler rings (1KB aligned.) */
d4966 1
a4966 1
 * notifies us of its readiness (called in a process context.)
d4984 1
a4984 1
	/* Set physical address of TX scheduler rings (1KB aligned.) */
a5025 2
		struct iwn5000_phy_calib_crystal cmd;

d5027 1
a5027 9
		memset(&cmd, 0, sizeof cmd);
		cmd.code = IWN5000_PHY_CALIB_CRYSTAL;
		cmd.ngroups = 1;
		cmd.isvalid = 1;
		cmd.cap_pin[0] = letoh32(sc->eeprom_crystal) & 0xff;
		cmd.cap_pin[1] = (letoh32(sc->eeprom_crystal) >> 16) & 0xff;
		DPRINTF(("sending crystal calibration %d, %d\n",
		    cmd.cap_pin[0], cmd.cap_pin[1]));
		error = iwn_cmd(sc, IWN_CMD_PHY_CALIB, &cmd, sizeof cmd, 0);
d5056 1
a5056 1
 * the NIC internal memory (no DMA transfer.)
a5377 1
	const struct iwn_hal *hal = sc->sc_hal;
d5409 4
a5412 4
	if (fw->main.textsz > hal->fw_text_maxsz ||
	    fw->main.datasz > hal->fw_data_maxsz ||
	    fw->init.textsz > hal->fw_text_maxsz ||
	    fw->init.datasz > hal->fw_data_maxsz ||
d5450 1
a5450 1
	/* Disable L0s exit timer (NMI bug workaround.) */
d5452 1
a5452 1
	/* Don't wait for ICH L0s (ICH bug workaround.) */
d5455 1
a5455 1
	/* Set FH wait threshold to max (HW bug under stress workaround.) */
d5481 1
a5481 1
		/* Enable DMA and BSM (Bootstrap State Machine.) */
d5580 2
a5581 1
	if (sc->hw_type == IWN_HW_REV_TYPE_6050 && sc->calib_ver >= 6) {
d5585 2
d5632 1
a5632 1
	const struct iwn_hal *hal = sc->sc_hal;
d5651 1
a5651 1
	if ((error = hal->nic_config(sc)) != 0)
d5659 1
a5659 1
	/* Set physical address of RX ring (256-byte aligned.) */
d5661 1
a5661 1
	/* Set physical address of RX status (16-byte aligned.) */
d5678 1
a5678 1
	iwn_prph_write(sc, hal->sched_txfact_addr, 0);
d5680 1
a5680 1
	/* Set physical address of "keep warm" page (16-byte aligned.) */
d5684 1
a5684 1
	for (qid = 0; qid < hal->ntxqs; qid++) {
d5687 1
a5687 1
		/* Set physical address of TX ring (256-byte aligned.) */
d5694 1
a5694 1
	for (chnl = 0; chnl < hal->ndmachnls; chnl++) {
d5715 5
a5719 1
	if ((error = hal->load_firmware(sc)) != 0) {
d5730 1
a5730 1
	return hal->post_alive(sc);
a5735 1
	const struct iwn_hal *hal = sc->sc_hal;
d5750 1
a5750 1
	iwn_prph_write(sc, hal->sched_txfact_addr, 0);
d5754 1
a5754 1
		for (chnl = 0; chnl < hal->ndmachnls; chnl++) {
d5770 1
a5770 1
	for (qid = 0; qid < hal->ntxqs; qid++)
a5858 4

	/* Temperature sensor is no longer valid. */
	sc->sensor.value = 0;
	sc->sensor.flags |= SENSOR_FINVALID;
@


1.105
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.104 2010/08/27 20:09:01 deraadt Exp $	*/
d69 26
a94 27
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_4965_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_4965_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_5100_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_5100_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_5150_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_5150_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_5300_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_5300_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_5350_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_5350_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_1000_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_1000_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_3X3_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_3X3_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_IPA_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_IPA_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_2X2_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_2X2_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6005A_2X2_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6005A_2X2_2 },
#ifdef notyet
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6005B_1X1_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6005B_1X1_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6005B_2X2_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6005B_2X2_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6005B_2X2_3 }
#endif
d628 2
a629 2
		case PCI_PRODUCT_INTEL_WIFI_LINK_6000_IPA_1:
		case PCI_PRODUCT_INTEL_WIFI_LINK_6000_IPA_2:
@


1.104
log
@Move the guts of the powerhook function into the activate function and make
it stop calling the powerhook function; then make the powerhook function
call activate.  This basically inverts the whole goop.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.103 2010/08/27 17:08:00 jsg Exp $	*/
a109 1
void		iwn_powerhook(int, void *);
a569 3

	sc->powerhook = powerhook_establish(iwn_powerhook, sc);

a711 3
	if (sc->powerhook != NULL)
		powerhook_disestablish(sc->powerhook);

a779 6
}

void
iwn_powerhook(int why, void *arg)
{
	iwn_activate(arg, why);
@


1.103
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.102 2010/08/12 16:59:29 damien Exp $	*/
d110 1
a110 1
void		iwn_power(int, void *);
d572 1
a572 1
	sc->powerhook = powerhook_establish(iwn_power, sc);
d766 1
a766 7
	iwn_power(PWR_RESUME, arg1);
}

void
iwn_power(int why, void *arg)
{
	struct iwn_softc *sc = arg;
a770 5
	if (why != PWR_RESUME) {
		iwn_stop(ifp, 0);
		return;
	}

d787 6
@


1.102
log
@homogeneous style.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.101 2010/08/12 15:04:00 oga Exp $	*/
a535 1
	ifp->if_init = iwn_init;
@


1.101
log
@Instead of returning EBUSY when the busy flag is set in the ioctl, sleep
until whoever has it is done with it.

This is kept as flag/sleep condvars instead of a rwlock because later we
may want to quiesce the handler before suspend to make sure nothing is
sleeping on a chip that is about to be whacked (doing so will change the
proc so rwlocks won't work).

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.100 2010/07/28 21:21:38 deraadt Exp $	*/
d761 1
a761 1
	return (0);
d3117 1
a3117 1
	while (sc->sc_flags & IWN_FLAG_BUSY && error == 0)
d3119 1
a3119 1
	if (error) {
@


1.100
log
@Make legacy xxpower() functions call xxstop() on suspend, and simplify their
resume paths.  For new-style suspend/resume, add a ca_activate function where
it is missing, and use a workq to resume because these drivers like to sleep.
ok damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.99 2010/07/23 06:43:00 phessler Exp $	*/
d789 2
d797 1
d3117 3
a3119 1
	if (sc->sc_flags & IWN_FLAG_BUSY) {
d3121 1
a3121 1
		return EBUSY;
d3185 1
@


1.99
log
@Add suspend/resume logic.

based heavily on the wpi change by kettenis@@

OK deraadt@@, kettenis@@, damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.98 2010/07/20 19:24:31 damien Exp $	*/
d753 1
a753 1
			iwn_stop(ifp, 1);
d774 1
a774 1
	struct ifnet *ifp;
d778 2
a779 1
	if (why != PWR_RESUME)
d781 1
d791 2
a792 6
	ifp = &sc->sc_ic.ic_if;
	if (ifp->if_flags & IFF_UP) {
		ifp->if_init(ifp);
		if (ifp->if_flags & IFF_RUNNING)
			ifp->if_start(ifp);
	}
@


1.98
log
@do not timeout when stopping DMA channels.
from a similar fix to iwlwifi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.97 2010/06/05 18:52:47 damien Exp $	*/
d36 1
d108 2
d337 2
a338 1
	sizeof (struct iwn_softc), iwn_match, iwn_attach, iwn_detach
d744 26
d787 2
d795 2
@


1.97
log
@change sign extension such that we do not rely on >> being an
arithmetic shift on signed integers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.96 2010/05/13 09:25:03 damien Exp $	*/
a5678 1
	uint32_t tmp;
d5699 1
a5699 2
				tmp = IWN_READ(sc, IWN_FH_TX_STATUS);
				if ((tmp & IWN_FH_TX_STATUS_IDLE(chnl)) ==
@


1.96
log
@new iwn(4) ids.
do not attach to the Gen2b devices yet as it is not clear wether or
not they have their own hardware revision type.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.95 2010/05/07 11:16:04 dhill Exp $	*/
d3677 1
a3677 1
	r4 = (r4 << 8) >> 8;
@


1.95
log
@Remember to restore the spl.  Found out the hard way by me.

ok @@damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.94 2010/05/05 19:47:43 damien Exp $	*/
d86 9
a94 2
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6005_2X2_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6005_2X2_2 }
@


1.94
log
@Prevent a process from entering iwn_ioctl while another process is
tsleep'ing (for example waiting for the firmware to become alive)
in iwn_init.

I believe this might fix a crash reported by dhill@@
This is a temporary fix until I find something better that I will
apply to my other drivers that can tsleep in if_init (wpi, run etc...)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.92 2010/04/30 16:31:47 damien Exp $	*/
d3075 2
a3076 1
	if (sc->sc_flags & IWN_FLAG_BUSY)
d3078 1
@


1.93
log
@firmware images in type-length-value format can now offer different
alternatives in a same image.
@
text
@d3071 7
d3137 2
@


1.92
log
@add HT Capabilities element in outgoing probe requests if HT is
enabled (it is not enabled yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.91 2010/04/30 16:08:36 damien Exp $	*/
d243 1
a243 1
		    struct iwn_fw_info *);
d5222 2
a5223 1
iwn_read_firmware_tlv(struct iwn_softc *sc, struct iwn_fw_info *fw)
d5226 4
a5229 2
	const uint32_t *ptr, *end;
	uint32_t type, len;
d5245 11
a5255 2
	ptr = (const uint32_t *)(hdr + 1);
	end = (const uint32_t *)(fw->data + fw->size);
d5258 6
a5263 4
	while (ptr + 2 <= end) {
		type = letoh32(*ptr++);
		len  = letoh32(*ptr++);
		if (ptr + (len + 3) / 4 > end) {
d5268 5
a5272 1
		switch (type) {
d5274 1
a5274 1
			fw->main.text = (const uint8_t *)ptr;
d5278 1
a5278 1
			fw->main.data = (const uint8_t *)ptr;
d5282 1
a5282 1
			fw->init.text = (const uint8_t *)ptr;
d5286 1
a5286 1
			fw->init.data = (const uint8_t *)ptr;
d5290 1
a5290 1
			fw->boot.text = (const uint8_t *)ptr;
d5294 2
a5295 1
			DPRINTF(("TLV type %d not handled\n", type));
d5298 2
a5299 2
		/* TLV fields are 32-bit aligned. */
		ptr += (len + 3) / 4;
d5330 1
a5330 1
		error = iwn_read_firmware_tlv(sc, fw);
@


1.91
log
@fix for 5GHz band.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.90 2010/04/30 16:06:46 damien Exp $	*/
d4296 4
@


1.90
log
@add support for firmware images in "type-length-value" format.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.89 2010/04/20 22:05:43 tedu Exp $	*/
d4256 1
a4256 1
		hdr->crc_threshold = htole16(1);
@


1.89
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.88 2010/04/10 08:37:36 damien Exp $	*/
d240 4
d5162 3
d5166 1
a5166 1
iwn_read_firmware(struct iwn_softc *sc)
a5167 2
	const struct iwn_hal *hal = sc->sc_hal;
	struct iwn_fw_info *fw = &sc->fw;
d5169 1
a5170 2
	size_t size;
	int error;
a5171 14
	/* Read firmware image from filesystem. */
	if ((error = loadfirmware(sc->fwname, &fw->data, &size)) != 0) {
		printf("%s: error, %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, sc->fwname);
		return error;
	}
	if (size < 28) {
		printf("%s: truncated firmware header: %d bytes\n",
		    sc->sc_dev.dv_xname, size);
		free(fw->data, M_DEVBUF);
		return EINVAL;
	}

	/* Process firmware header. */
d5174 1
a5178 1
		free(fw->data, M_DEVBUF);
d5183 1
a5183 1
		size -= 4;
d5186 5
a5195 13
	size -= 24;

	/* Sanity-check firmware header. */
	if (fw->main.textsz > hal->fw_text_maxsz ||
	    fw->main.datasz > hal->fw_data_maxsz ||
	    fw->init.textsz > hal->fw_text_maxsz ||
	    fw->init.datasz > hal->fw_data_maxsz ||
	    fw->boot.textsz > IWN_FW_BOOT_TEXT_MAXSZ ||
	    (fw->boot.textsz & 3) != 0) {
		printf("%s: invalid firmware header\n", sc->sc_dev.dv_xname);
		free(fw->data, M_DEVBUF);
		return EINVAL;
	}
d5198 4
a5201 5
	if (fw->main.textsz + fw->main.datasz + fw->init.textsz +
	    fw->init.datasz + fw->boot.textsz > size) {
		printf("%s: firmware file too short: %d bytes\n",
		    sc->sc_dev.dv_xname, size);
		free(fw->data, M_DEVBUF);
d5211 116
d5328 1
@


1.88
log
@Intel Centrino Advanced-N 6200 G2 adapters have their own hardware
revision type.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.87 2010/04/04 08:55:50 damien Exp $	*/
a27 1
#include <sys/sysctl.h>
@


1.87
log
@Attach the 2nd generation of 6000 2x2 devices even though the firmware
is not yet available.

The combo WiFi/WiMAX devices need a separate firmware too (that is not
yet available), so do not use the firmware for WiFi-only devices as it
will likely not work.

Change the way active chains (the ones that have an antenna plugged in)
are detected to work around a firmware bug which could make us mark
non-existing chains as active.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.86 2010/02/17 18:23:00 damien Exp $	*/
d87 2
a88 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6005_IPA_1 }
d618 1
a621 1
			sc->fwname = "iwn-6000";
a625 6
		case PCI_PRODUCT_INTEL_WIFI_LINK_6005_IPA_1:
			sc->fwname = "iwn-6005";
			sc->sc_flags |= IWN_FLAG_INTERNAL_PA;
			sc->txchainmask = IWN_ANT_AB;
			sc->rxchainmask = IWN_ANT_AB;
			break;
a626 1
			sc->fwname = "iwn-6000";
d639 7
d5281 1
a5281 2
	    sc->hw_type != IWN_HW_REV_TYPE_6000 &&
	    sc->hw_type != IWN_HW_REV_TYPE_6050)
@


1.86
log
@read calibration version from ROM and set IWN_GP_DRIVER_CALIB_VER6
bit on 6x50 if version>=6.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.85 2010/02/03 17:51:11 damien Exp $	*/
d86 2
a87 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_2X2_2 }
a616 1
		sc->fwname = "iwn-6000";
d620 1
d625 6
d632 1
d641 1
a641 1
		sc->fwname = "iwn-6000";
d3748 1
a3748 1
	sc->chainmask = 0;
d3750 5
a3754 2
		if (val - calib->rssi[i] <= 15 * 20)
			sc->chainmask |= 1 << i;
@


1.85
log
@init ofdm sensitivity with min value (which depends on the chip)
instead of hardcoding it to 90.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.84 2010/02/02 17:06:53 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007-2009 Damien Bergamini <damien.bergamini@@free.fr>
d1475 1
d1499 5
d5378 4
@


1.84
log
@Fix for the Intel WiFi Link 1000.
The EEPROM image is in the OTPROM block before the last block, not in
the last block itself. Intel WiFi Link 1000 parts should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.83 2010/01/28 16:59:30 damien Exp $	*/
d3686 1
a3686 1
	calib->ofdm_x4     = 90;
@


1.83
log
@set differential gains on 6250 too (but use a 1.0 factor, not 1.5).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.82 2010/01/23 09:14:13 damien Exp $	*/
d887 1
a887 2
	uint32_t base;
	uint16_t next;
d912 2
a913 2
	 * Find last valid OTP block (contains the EEPROM image) for HW
	 * without OTP shadow RAM.
d925 1
d928 1
a928 1
		if (base == 0 || count == IWN1000_OTP_NBLOCKS)
d931 1
a931 1
		sc->prom_base = base + 1;
@


1.82
log
@finally, 6250 parts need crystal calibration too.
update sensitivity settings for 5000 series to workaround a performance
bug in the DSP (1000 is not affected so we keep the old values for 5000.)
update sensitivity settings for 6000 series.

from similar changes to iwlwifi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.81 2010/01/16 12:48:58 damien Exp $	*/
a3772 3
	if (sc->hw_type == IWN_HW_REV_TYPE_6050)
		return 0;

d3818 1
a3818 1
	int i, ant, delta;
d3820 2
a3821 2
	if (sc->hw_type == IWN_HW_REV_TYPE_6050)
		return 0;
d3834 1
a3834 1
			    (int32_t)calib->noise[i]) / 30;
@


1.81
log
@rename bluetooth coexistence flags. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.80 2010/01/16 12:42:17 damien Exp $	*/
d608 1
a608 1
		sc->limits = &iwn5000_sensitivity_limits;
d4922 1
a4922 2
	if (sc->hw_type != IWN_HW_REV_TYPE_5150 &&
	    sc->hw_type != IWN_HW_REV_TYPE_6050) {
@


1.80
log
@Enable DC calibration and disable crystal calibration on
Centrino Advanced-N 6250 parts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.78 2009/11/08 11:54:48 damien Exp $	*/
d4110 1
a4110 1
	bluetooth.flags = IWN_BT_COEX_MODE_4WIRE;
@


1.79
log
@workaround for a HW bug (does not affect 4965AGN) that may sporadically
affect latency under some rare circumstances.

from a similar commit to iwlwifi.
@
text
@a487 1
	    IEEE80211_HTCAP_SMPS_DIS |
d493 4
d508 1
a508 1
	ic->ic_sup_mcs[0] = 0xff;
d510 1
a510 1
		ic->ic_sup_mcs[1] = 0xff;
d512 1
a512 1
		ic->ic_sup_mcs[2] = 0xff;
d2066 2
a2067 1
		if (sc->hw_type == IWN_HW_REV_TYPE_5150)
d4922 2
a4923 1
	if (sc->hw_type != IWN_HW_REV_TYPE_5150) {
@


1.78
log
@- remove non-production pci ids for 6050 3x3
- wakeup device earlier in read_prom
- fix ampdu_tx_start (not used yet)
- initialize ht_caps field and rx mcs set (not used yet)
- start processing compressed blockack notifications (does nothing for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.77 2009/11/04 17:46:52 damien Exp $	*/
d2528 4
a2531 2
		if (tmp == 0xffffffff)
			tmp = 0;	/* Shouldn't happen. */
@


1.77
log
@the hybrid 6000 series (using both internal and external power amplifiers)
never made it into production, so remove some dead code and pci ids.

inspired by a similar change to iwlwifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.76 2009/11/03 18:57:18 damien Exp $	*/
d86 1
a86 3
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_2X2_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_3X3_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_3X3_2 }
d142 4
d482 15
a496 1
	/* Set supported rates. */
d503 8
a610 1
	case IWN_HW_REV_TYPE_6050:
a620 5
		case PCI_PRODUCT_INTEL_WIFI_LINK_6050_2X2_1:
		case PCI_PRODUCT_INTEL_WIFI_LINK_6050_2X2_2:
			sc->txchainmask = IWN_ANT_AB;
			sc->rxchainmask = IWN_ANT_AB;
			break;
d627 7
d1349 7
a1364 8

	/* Adapter has to be powered on for EEPROM access to work. */
	if ((error = iwn_apm_init(sc)) != 0) {
		printf("%s: could not power ON adapter\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

d1582 1
d1584 3
d2025 17
d2168 1
a2168 1
	iwn_tx_done(sc, desc, stat->retrycnt, letoh32(stat->status) & 0xff);
d2184 1
a2184 1
	iwn_tx_done(sc, desc, stat->retrycnt, letoh16(stat->status) & 0xff);
d2191 1
a2191 1
iwn_tx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc, int retrycnt,
d2202 1
a2202 1
	if (retrycnt > 0)
d2293 6
a2298 1

a2882 6
	if (error != 0 && error != EFBIG) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m);
		return error;
	}
d2884 6
d3491 1
d4619 1
a4619 1
	/* Enable chain mode for the queue. */
d4623 1
a4623 1
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, ssn);
d4652 1
a4652 1
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, ssn);
d4678 1
a4678 1
	/* Enable chain mode for the queue. */
d4685 1
a4685 1
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, ssn);
d4713 1
a4713 1
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, ssn);
d4781 1
d4791 3
a4793 1
	} else {
@


1.76
log
@s/TX_IQ_PERD/TX_IQ_PERIODIC/
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.75 2009/11/03 18:55:23 damien Exp $	*/
a82 2
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_HYB_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_HYB_2 },
a591 6
		case PCI_PRODUCT_INTEL_WIFI_LINK_6000_HYB_1:
		case PCI_PRODUCT_INTEL_WIFI_LINK_6000_HYB_2:
			sc->sc_flags |= IWN_FLAG_HYBRID;
			sc->txchainmask = IWN_ANT_AB;
			sc->rxchainmask = IWN_ANT_AB;
			break;
d5312 1
a5312 4
	if (sc->sc_flags & IWN_FLAG_HYBRID) {
		/* Use internal and external power amplifiers. */
		IWN_WRITE(sc, IWN_GP_DRIVER, IWN_GP_DRIVER_RADIO_2X2_HYB);
	} else if (sc->sc_flags & IWN_FLAG_INTERNAL_PA) {
@


1.75
log
@use BUS_DMA_{READ,WRITE} hints when mapping mbufs for Rx/Tx even
though this does nothing on i386 and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.74 2009/11/01 12:01:16 damien Exp $	*/
d2035 1
a2035 1
	case IWN5000_PHY_CALIB_TX_IQ_PERD:
@


1.74
log
@- fix rx chain mask in scan command
- no Tx IQ calibration for 6000 series
- remove a comment about iwlwifi that is no longer true
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.73 2009/10/31 11:52:07 damien Exp $	*/
d1124 1
a1124 1
		    BUS_DMA_NOWAIT);
d1880 1
a1880 1
	    IWN_RBUF_SIZE, NULL, BUS_DMA_NOWAIT);
d1887 1
a1887 1
		    BUS_DMA_NOWAIT);
d2840 1
a2840 1
	    BUS_DMA_NOWAIT);
d2868 1
a2868 1
		    BUS_DMA_NOWAIT);
d3102 1
a3102 1
		    NULL, BUS_DMA_NOWAIT);
@


1.73
log
@reorder operations in detach(), call powerhook_disestablish() earlier,
call if_detach() last.
no need to splnet() since we are already called at the right ipl.

iwn(4) diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.72 2009/10/28 18:42:47 damien Exp $	*/
a555 4
		/*
		 * The 4965 is supposed to have 3 RX chains, but the
		 * Intel driver only activates 2.
		 */
d2036 2
a2037 1
		if (sc->hw_type != IWN_HW_REV_TYPE_5150)
d4170 4
a4173 2
	rxchain = IWN_RXCHAIN_FORCE | IWN_RXCHAIN_VALID(IWN_ANT_ABC) |
	    IWN_RXCHAIN_MIMO(IWN_ANT_ABC);
d4177 1
a4177 1
		rxchain |= IWN_RXCHAIN_SEL(IWN_ANT_BC);
d4179 1
a4179 1
		rxchain |= IWN_RXCHAIN_SEL(IWN_ANT_ABC);
@


1.72
log
@- use bus_space_write_1 to write to IWN_INT_PERIODIC (0x5), even though
  bus_space_write_4 worked
- store enhanced power info in softc for 6000 Series
- fix a comment, remove an unused field in softc and reorder pci ids a bit
  while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.71 2009/10/26 18:38:32 damien Exp $	*/
d670 1
a670 1
	int s, qid;
a671 1
	s = splnet();
d678 2
a679 3
	ieee80211_ifdetach(ifp);
 	if_detach(ifp);
	splx(s);
d691 2
d699 2
a700 4
	if (sc->powerhook != NULL)
		powerhook_disestablish(sc->powerhook);

	bus_space_unmap(sc->sc_st, sc->sc_sh, sc->sc_sz);
@


1.71
log
@start Tx at lowest available rate to give initial WPA handshake and
DHCP more chance to succeed w/o too much retries.
AMRR is good enough at raising the Tx rate fast.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.70 2009/10/26 17:55:29 damien Exp $	*/
d79 2
d90 1
a90 3
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_3X3_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_1000_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_1000_2 }
d1486 1
a1486 1
		/* Compute critical temperature (in Kelvin.) */
d1587 1
a1587 1
		/* XXX apply to sc->maxpwr[] */
d2534 2
a2535 1
			IWN_WRITE(sc, IWN_INT_PERIODIC, IWN_INT_PERIODIC_DIS);
d2538 1
a2538 1
				IWN_WRITE(sc, IWN_INT_PERIODIC,
@


1.70
log
@update WiFi Link 6000 product ids.
fix sensitivity settings for 4965.
use different sensitivity limits for 5150 (workaround for HW bug) and 6000.
set valid Tx and Rx chains based on PCI product ids for 6000 series.
cleanup setting of critical temperature.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.69 2009/10/24 20:17:17 damien Exp $	*/
d1606 2
a1615 3
		/* Initial TX rate <= 24Mbps. */
		if (rate <= 48)
			ni->ni_txrate = i;
@


1.69
log
@add explicit barriers for read/write accesses to prph and internal memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.68 2009/10/24 19:00:40 damien Exp $	*/
d79 10
a88 11
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_4 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_5 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_6 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6000_7 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WIFI_LINK_6050_4 },
d95 1
a95 1
const struct	iwn_hal *iwn_hal_attach(struct iwn_softc *);
a277 1
	&iwn4965_sensitivity_limits,
a305 1
	&iwn5000_sensitivity_limits,
a344 1
	sc->sc_id = pa->pa_id;
d400 2
a401 1
	if ((hal = iwn_hal_attach(sc)) == NULL)
d547 1
a547 1
iwn_hal_attach(struct iwn_softc *sc)
d554 1
d556 5
a560 2
		sc->critical_temp = IWN_CTOK(110);
		sc->txchainmask = IWN_ANT_A | IWN_ANT_B;
d565 1
a566 1
		sc->critical_temp = 110;
d568 1
a568 1
		sc->rxchainmask = IWN_ANT_A | IWN_ANT_B;
d572 1
a573 1
		/* NB: critical temperature will be read from EEPROM. */
d575 1
a575 1
		sc->rxchainmask = IWN_ANT_A | IWN_ANT_B;
d580 1
a581 1
		sc->critical_temp = 110;
d587 1
a588 1
		sc->critical_temp = 110;
d590 1
a590 1
		sc->rxchainmask = IWN_ANT_A | IWN_ANT_B;
d595 1
d597 23
a619 3
		sc->critical_temp = 110;
		sc->txchainmask = IWN_ANT_ABC;
		sc->rxchainmask = IWN_ANT_ABC;
d984 1
a984 1
	    BUS_DMA_NOWAIT);
a1491 1
		sc->critical_temp = (IWN_CTOK(110) - sc->temp_off) * -5;
d3195 1
a3195 1
	linkq.antmsk_2stream = IWN_ANT_A | IWN_ANT_B;
d3240 1
a3240 1
	linkq.antmsk_2stream = IWN_ANT_A | IWN_ANT_B;
d3305 1
d3309 6
d3316 2
a3317 2
	crit.tempR = htole32(sc->critical_temp);
	DPRINTF(("setting critical temperature to %u\n", sc->critical_temp));
d3640 2
a3641 2
	calib->ofdm_x1     = hal->limits->min_ofdm_x1;
	calib->ofdm_mrc_x1 = hal->limits->min_ofdm_mrc_x1;
d3643 1
a3643 1
	calib->ofdm_mrc_x4 = hal->limits->min_ofdm_mrc_x4;
d3645 2
a3646 2
	calib->cck_mrc_x4  = hal->limits->min_cck_mrc_x4;
	calib->energy_cck  = hal->limits->energy_cck;
d3829 1
a3829 2
	const struct iwn_hal *hal = sc->sc_hal;
	const struct iwn_sensitivity_limits *limits = hal->limits;
a3957 1
	const struct iwn_hal *hal = sc->sc_hal;
d3968 1
a3968 1
	cmd.energy_ofdm      = htole16(hal->limits->energy_ofdm);
d4180 1
a4180 1
		rxchain |= IWN_RXCHAIN_SEL(IWN_ANT_B | IWN_ANT_C);
a5293 1
	pci_product_id_t id;
d5323 1
a5323 4
	id = PCI_PRODUCT(sc->sc_id);
	if (id == PCI_PRODUCT_INTEL_WIFI_LINK_6000_1 ||
	    id == PCI_PRODUCT_INTEL_WIFI_LINK_6000_2 ||
	    id == PCI_PRODUCT_INTEL_WIFI_LINK_6000_7) {
d5326 1
a5326 1
	} else if (id == PCI_PRODUCT_INTEL_WIFI_LINK_6000_5) {
@


1.68
log
@enable WiFi/WiMAX coexistence for 6050 combo adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.67 2009/10/24 18:32:37 damien Exp $	*/
d740 1
d748 1
d776 1
d784 1
@


1.67
log
@always power on adapter before reading ROM.
previously, it was only done for OTPROM but it seems 4965 (which has
a good old EEPROM) needs it too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.66 2009/10/24 18:14:57 damien Exp $	*/
d231 1
d4706 23
a4788 1
	struct iwn5000_wimax_coex wimax;
d4836 2
a4837 4
	/* Configure WiMAX (IEEE 802.16e) coexistence. */
	memset(&wimax, 0, sizeof wimax);
	DPRINTF(("Configuring WiMAX coexistence\n"));
	error = iwn_cmd(sc, IWN5000_CMD_WIMAX_COEX, &wimax, sizeof wimax, 0);
a4842 1

@


1.66
log
@huge diff introducing many of the recent changes made by intel to iwlwifi:
- ICT interrupts for >=5000 series (avoids reading IWN_INT which is slow)
- support v2 firmware header (including build number)
- switch to v2 firmware api (requires a firmware package upgrade)
- initial support for 1000 series and initial bits for upcoming 6000
  series (untested as hardware is not available to the general public)
- many bug fixes, including workarounds for hardware bugs

make sure to update your iwn-firmware package to iwn-firmware-5.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.63 2009/09/20 20:04:07 damien Exp $	*/
d1321 7
a1328 6
		/* Adapter has to be powered on for OTPROM access to work. */
		if ((error = iwn_apm_init(sc)) != 0) {
			printf("%s: could not power ON adapter\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
d1346 1
a1346 2
	if (sc->sc_flags & IWN_FLAG_HAS_OTPROM)
		iwn_apm_stop(sc);	/* Power OFF adapter. */
@


1.65
log
@iwn_cmd() must be called at splnet().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.64 2009/10/24 17:51:34 damien Exp $	*/
d20 2
a21 2
 * Driver for Intel Wireless WiFi Link 4965 and Intel WiFi Link 5000 Series
 * 802.11 network adapters.
d85 1
d116 2
d127 1
d133 1
d241 1
a241 2
int		iwn4965_apm_init(struct iwn_softc *);
int		iwn5000_apm_init(struct iwn_softc *);
a264 1
	iwn4965_apm_init,
a293 1
	iwn5000_apm_init,
d347 1
a410 6
	/* Power ON adapter. */
	if ((error = hal->apm_init(sc)) != 0) {
		printf(": could not power ON adapter\n");
		return;
	}

d429 7
d439 1
a439 1
		goto fail2;
d446 1
a446 1
			goto fail3;
d453 1
a453 1
		goto fail3;
a455 2
	/* Power OFF adapter. */
	iwn_apm_stop(sc);
d459 9
a470 3
	/* Initialization firmware has not been loaded yet. */
	sc->sc_flags |= IWN_FLAG_FIRST_BOOT;

d539 1
a539 1
fail3:	while (--i >= 0)
d542 2
d558 2
a559 4
		sc->txantmsk = IWN_ANT_A | IWN_ANT_B;
		sc->rxantmsk = IWN_ANT_ABC;
		sc->ntxchains = 2;
		sc->nrxchains = 3;
d565 2
a566 4
		sc->txantmsk = IWN_ANT_B;
		sc->rxantmsk = IWN_ANT_A | IWN_ANT_B;
		sc->ntxchains = 1;
		sc->nrxchains = 2;
d572 2
a573 4
		sc->txantmsk = IWN_ANT_A;
		sc->rxantmsk = IWN_ANT_A | IWN_ANT_B;
		sc->ntxchains = 1;
		sc->nrxchains = 2;
d580 2
a581 2
		sc->txantmsk = sc->rxantmsk = IWN_ANT_ABC;
		sc->ntxchains = sc->nrxchains = 3;
d587 2
a588 4
		sc->txantmsk = IWN_ANT_A;
		sc->rxantmsk = IWN_ANT_A | IWN_ANT_B;
		sc->ntxchains = 1;
		sc->nrxchains = 2;
d591 1
d595 2
a596 13
		sc->txantmsk = IWN_ANT_ABC;
		sc->rxantmsk = IWN_ANT_ABC;
		sc->ntxchains = 3;
		sc->nrxchains = 3;
		break;
	case IWN_HW_REV_TYPE_6050:
		sc->sc_hal = &iwn5000_hal;
		sc->fwname = "iwn-6050";
		sc->critical_temp = 110;
		sc->txantmsk = IWN_ANT_ABC;
		sc->rxantmsk = IWN_ANT_ABC;
		sc->ntxchains = 3;
		sc->nrxchains = 3;
d607 1
a607 1
 * Attach the adapter's on-board thermal sensor to the sensors framework.
d666 2
d846 3
a848 1
	int error;
d850 1
d861 5
d871 21
d902 1
d1024 14
d1085 2
a1086 1
		    IWN_RBUF_SIZE, 0, BUS_DMA_NOWAIT, &data->map);
d1271 25
d1321 12
a1332 5
	if ((sc->sc_flags & IWN_FLAG_HAS_OTPROM) &&
	    ((error = iwn_init_otprom(sc)) != 0)) {
		printf("%s: could not initialize OTPROM (error=%d)\n",
		    sc->sc_dev.dv_xname, error);
		return error;
d1345 3
d1435 1
a1435 1
	int32_t temp, volt, delta;
d1452 4
d1464 4
a1467 4
		delta = temp - (volt / -5);
		sc->critical_temp = (IWN_CTOK(110) - delta) * -5;
		DPRINTF(("temp=%d volt=%d delta=%dK\n",
		    temp, volt, delta));
d1533 32
d1998 1
a1998 1
	if (!(sc->sc_flags & IWN_FLAG_FIRST_BOOT))
d2120 1
d2123 1
d2283 1
a2283 1
				/* Save microcontroller's report. */
d2351 1
d2377 1
a2377 1
	for (qid = 0; qid < 6; qid++) {
d2395 3
d2452 1
a2452 1
	uint32_t r1, r2;
d2455 1
a2455 4
	IWN_WRITE(sc, IWN_MASK, 0);

	r1 = IWN_READ(sc, IWN_INT);
	r2 = IWN_READ(sc, IWN_FH_INT);
d2457 19
d2478 1
a2478 1
			IWN_WRITE(sc, IWN_MASK, IWN_INT_MASK);
a2480 2
	if (r1 == 0xffffffff || (r1 & 0xfffffff0) == 0xa5a5a5a0)
		return 0;	/* Hardware gone! */
d2484 2
a2485 1
	IWN_WRITE(sc, IWN_FH_INT, r2);
d2488 1
a2488 1
		uint32_t tmp = IWN_READ(sc, IWN_GP_CNTRL);
a2494 1
		/* XXX Reduce TX power? */
d2504 14
a2517 3
	if ((r1 & (IWN_INT_FH_RX | IWN_INT_SW_RX)) ||
	    (r2 & IWN_FH_INT_RX))
		iwn_notif_intr(sc);
d2519 3
a2521 1
	if ((r1 & IWN_INT_FH_TX) || (r2 & IWN_FH_INT_TX))
d2523 1
d2533 1
a2533 1
		IWN_WRITE(sc, IWN_MASK, IWN_INT_MASK);
d2760 1
a2760 1
		/* First segment's length must be a multiple of 4. */
d2777 1
a2777 1
		txant = IWN_LSB(sc->txantmsk);
d2886 1
d2889 1
a3052 1
	const struct iwn_hal *hal = sc->sc_hal;
d3115 1
d3117 2
a3118 1
	hal->update_sched(sc, ring->qid, ring->cur, 0, 0);
d3164 1
a3164 1
	txant = IWN_LSB(sc->txantmsk);
d3170 1
a3170 1
	linkq.ampdu_max = 64;
d3209 1
a3209 1
	txant = IWN_LSB(sc->txantmsk);
d3272 2
a3273 1
 * Set the critical temperature at which the firmware will notify us.
d3376 1
a3376 1
	/* Get channel's attenuation group. */
d3389 1
a3389 1
	/* Get channel's sub-band. */
d3437 1
a3437 1
			/* Do not exceed channel's max TX power. */
d3497 1
a3497 1
	mask = (letoh16(phy->antenna) >> 4) & 0x7;
d3576 2
d3583 6
a3588 1
	return letoh32(sc->rawtemp);
d3657 1
a3657 1
	sc->antmsk = 0;
d3660 1
a3660 1
			sc->antmsk |= 1 << i;
d3662 2
a3663 2
	if ((sc->antmsk & sc->txantmsk) == 0)
		sc->antmsk |= IWN_LSB(sc->txantmsk);
d3670 2
a3671 2
	sc->rxon.rxchain = htole16(IWN_RXCHAIN_SEL(sc->antmsk));
	(void)iwn_cmd(sc, IWN_CMD_CONFIGURE, &sc->rxon, hal->rxonsz, 1);
d3696 1
a3696 2
	if (sc->hw_type == IWN_HW_REV_TYPE_6000 ||
	    sc->hw_type == IWN_HW_REV_TYPE_6050)
d3698 1
a3698 1
	    
d3717 1
a3717 1
		if (sc->antmsk & (1 << i))
d3724 1
a3724 1
		if (sc->antmsk & (1 << i)) {
d3735 1
a3735 1
	    cmd.gain[0], cmd.gain[1], cmd.gain[2], sc->antmsk));
d3744 1
a3744 1
	int i, delta;
d3746 1
a3746 2
	if (sc->hw_type == IWN_HW_REV_TYPE_6000 ||
	    sc->hw_type == IWN_HW_REV_TYPE_6050)
d3753 7
a3759 5
	/* Set differential gains for antennas B and C. */
	for (i = 1; i < 3; i++) {
		if (sc->antmsk & (1 << i)) {
			/* The delta is relative to antenna A. */
			delta = ((int32_t)calib->noise[0] -
d3767 2
a3768 2
	DPRINTF(("setting differential gains Ant B/C: %x/%x (%x)\n",
	    cmd.gain[0], cmd.gain[1], sc->antmsk));
d4016 1
d4020 11
a4030 5
	/* Set power saving level to CAM during initialization. */
	if ((error = iwn_set_pslevel(sc, 0, 0, 0)) != 0) {
		printf("%s: could not set power saving level\n",
		    sc->sc_dev.dv_xname);
		return error;
d4035 3
a4037 3
	bluetooth.flags = 3;
	bluetooth.lead = 0xaa;
	bluetooth.kill = 1;
d4046 1
a4046 1
	/* Configure adapter. */
a4050 1
	/* Set default channel. */
d4073 5
a4077 2
	rxchain = IWN_RXCHAIN_VALID(IWN_ANT_ABC) | IWN_RXCHAIN_IDLE_COUNT(2) |
	    IWN_RXCHAIN_MIMO_COUNT(2);
d4080 1
a4080 1
	error = iwn_cmd(sc, IWN_CMD_CONFIGURE, &sc->rxon, hal->rxonsz, 0);
d4082 7
a4088 1
		printf("%s: configure command failed\n", sc->sc_dev.dv_xname);
d4098 2
a4099 2
	if ((error = iwn_add_broadcast_node(sc, 0)) != 0) {
		printf("%s: could not add broadcast node\n",
d4104 3
a4106 2
	if ((error = iwn_set_critical_temp(sc)) != 0) {
		printf("%s: could not set critical temperature\n",
d4173 1
a4173 1
	txant = IWN_LSB(sc->txantmsk);
d4249 1
a4249 1
	/* Update adapter's configuration. */
d4274 1
a4274 1
	error = iwn_cmd(sc, IWN_CMD_CONFIGURE, &sc->rxon, hal->rxonsz, 1);
d4276 1
a4276 1
		printf("%s: could not configure\n", sc->sc_dev.dv_xname);
d4286 1
a4286 1
	 * Reconfiguring RXON clears the firmware's nodes table so we must
d4316 1
a4316 1
	/* Update adapter's configuration. */
d4326 1
a4326 1
	error = iwn_cmd(sc, IWN_CMD_CONFIGURE, &sc->rxon, hal->rxonsz, 1);
d4675 3
a4677 1
	return tsleep(sc, PCATCH, "iwncal", 2 * hz);
d4717 1
a4717 1
	/* Clear TX scheduler's state in SRAM. */
d4768 3
d4774 1
a4774 1
	/* Clear TX scheduler's state in SRAM. */
d4842 1
a4842 1
	if (sc->sc_flags & IWN_FLAG_FIRST_BOOT) {
d4850 2
a4851 2
		 * We have the calibration results now so we can skip
		 * loading the initialization firmware next time.
a4852 3
		sc->sc_flags &= ~IWN_FLAG_FIRST_BOOT;

		/* Reboot (call ourselves recursively!) */
d5022 2
a5023 2
	fw = (sc->sc_flags & IWN_FLAG_FIRST_BOOT) ?
	    &sc->fw.init : &sc->fw.main;
d5050 2
a5051 1
	const struct iwn_firmware_hdr *hdr;
d5061 1
a5061 1
	if (size < sizeof (*hdr)) {
d5067 22
a5088 8
	/* Extract firmware header information. */
	hdr = (struct iwn_firmware_hdr *)fw->data;
	fw->main.textsz = letoh32(hdr->main_textsz);
	fw->main.datasz = letoh32(hdr->main_datasz);
	fw->init.textsz = letoh32(hdr->init_textsz);
	fw->init.datasz = letoh32(hdr->init_datasz);
	fw->boot.textsz = letoh32(hdr->boot_textsz);
	fw->boot.datasz = 0;
d5103 2
a5104 2
	if (size < sizeof (*hdr) + fw->main.textsz + fw->main.datasz +
	    fw->init.textsz + fw->init.datasz + fw->boot.textsz) {
d5112 1
a5112 1
	fw->main.text = (const uint8_t *)(hdr + 1);
d5130 1
a5130 1
	for (ntries = 0; ntries < 25000; ntries++) {
d5133 1
a5133 1
		DELAY(100);
d5141 1
a5141 26
iwn4965_apm_init(struct iwn_softc *sc)
{
	int error;

	/* Disable L0s. */
	IWN_SETBITS(sc, IWN_GIO_CHICKEN, IWN_GIO_CHICKEN_DIS_L0S_TIMER);
	IWN_SETBITS(sc, IWN_GIO_CHICKEN, IWN_GIO_CHICKEN_L1A_NO_L0S_RX);

	if ((error = iwn_clock_wait(sc)) != 0)
		return error;

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
	/* Enable DMA. */
	iwn_prph_write(sc, IWN_APMG_CLK_CTRL,
	    IWN_APMG_CLK_CTRL_DMA_CLK_RQT | IWN_APMG_CLK_CTRL_BSM_CLK_RQT);
	DELAY(20);
	/* Disable L1. */
	iwn_prph_setbits(sc, IWN_APMG_PCI_STT, IWN_APMG_PCI_STT_L1A_DIS);
	iwn_nic_unlock(sc);

	return 0;
}

int
iwn5000_apm_init(struct iwn_softc *sc)
d5143 1
d5146 1
a5146 1
	/* Disable L0s. */
d5148 1
d5151 1
a5151 1
	/* Set Flow Handler wait threshold to the maximum. */
d5154 1
a5154 1
	/* Enable HAP to move adapter from L1a to L0s. */
d5157 11
a5167 1
	if (sc->hw_type != IWN_HW_REV_TYPE_6000 &&
d5171 1
d5177 10
a5186 2
	/* Enable DMA. */
	iwn_prph_write(sc, IWN_APMG_CLK_CTRL, IWN_APMG_CLK_CTRL_DMA_CLK_RQT);
d5188 1
a5188 1
	/* Disable L1. */
d5200 1
d5215 1
a5224 10
	pcireg_t reg;

	/* Retrieve PCIe Active State Power Management (ASPM). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag,
	    sc->sc_cap_off + PCI_PCIE_LCSR);
	if (reg & PCI_PCIE_LCSR_ASPM_L1)	/* L1 Entry enabled. */
		IWN_SETBITS(sc, IWN_GIO, IWN_GIO_L0S_ENA);
	else
		IWN_CLRBITS(sc, IWN_GIO, IWN_GIO_L0S_ENA);

d5244 2
a5245 1
	pcireg_t reg;
a5247 8
	/* Retrieve PCIe Active State Power Management (ASPM). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag,
	    sc->sc_cap_off + PCI_PCIE_LCSR);
	if (reg & PCI_PCIE_LCSR_ASPM_L1)	/* L1 Entry enabled. */
		IWN_SETBITS(sc, IWN_GIO, IWN_GIO_L0S_ENA);
	else
		IWN_CLRBITS(sc, IWN_GIO, IWN_GIO_L0S_ENA);

d5260 12
d5273 11
d5295 10
d5315 1
d5335 1
a5335 1
	if ((error = hal->apm_init(sc)) != 0) {
d5406 1
a5406 1
	IWN_WRITE(sc, IWN_MASK, IWN_INT_MASK);
d5436 1
a5436 1
	IWN_WRITE(sc, IWN_MASK, 0);
d5439 1
d5470 2
a5471 1
		iwn_prph_write(sc, IWN_APMG_CLK_DIS, IWN_APMG_CLK_DMA_RQT);
d5504 4
@


1.64
log
@- iwn_mem_set_region_4 wants a number of 32-bit words, not bytes.
  fix callers (avoid erasing random registers)
- do not enable chain mode for command queue (>=5000 Series only.)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.63 2009/09/20 20:04:07 damien Exp $	*/
d1585 1
a1586 1
		s = splnet();
a1590 1
		splx(s);
d1601 2
@


1.63
log
@Implement a detach function in wpi(4) and iwn(4).
Some laptops will power off the PCIe socket when the radio kill
switch is turned on.

Reported and tested by Frantisek Holop on iwn(4).
Initial diff for iwn(4) by jsg@@
Some additional bits by Frantisek Holop (sensor_detach).
Some tweaks and adaptation to wpi(4) by me.

Fixes kernel/6223.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.62 2009/08/10 17:21:15 damien Exp $	*/
d4546 1
a4546 1
	    IWN4965_SCHED_CTX_LEN);
d4600 1
a4600 1
	    IWN5000_SCHED_CTX_LEN);
d4607 2
a4608 2
	/* Enable chain mode for all our 20 queues. */
	iwn_prph_write(sc, IWN5000_SCHED_QCHAIN_SEL, 0xfffff);
@


1.62
log
@i prefer (m == NULL) over (!m)
change two error messages while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.61 2009/08/09 11:40:56 deraadt Exp $	*/
d102 1
d322 1
a322 1
	sizeof (struct iwn_softc), iwn_match, iwn_attach
d649 40
@


1.61
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.60 2009/07/10 07:44:04 blambert Exp $	*/
d1014 2
a1015 2
		if (!data->m) {
			printf("%s: could not allocate RX mbuf cluster\n",
d1701 1
a1701 1
	if (!m1) {
@


1.60
log
@timeout_add -> timeout_add_msec

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.59 2009/06/02 16:28:21 damien Exp $	*/
d1013 2
a1014 9
		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate RX mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		MCLGETI(data->m, M_DONTWAIT, NULL, IWN_RBUF_SIZE);
		if (!(data->m->m_flags & M_EXT)) {
d1700 2
a1701 9
	MGETHDR(m1, M_DONTWAIT, MT_DATA);
	if (m1 == NULL) {
		ic->ic_stats.is_rx_nombuf++;
		ifp->if_ierrors++;
		return;
	}
	MCLGETI(m1, M_DONTWAIT, NULL, IWN_RBUF_SIZE);
	if (!(m1->m_flags & M_EXT)) {
		m_freem(m1);
@


1.59
log
@do not leak mbufs in the Rx path in case hardware decryption failed.
this leak was introduced when i switched to MCLGETI.

reported by mpf@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.58 2009/06/02 16:24:40 damien Exp $	*/
d1569 1
a1569 1
	timeout_add(&sc->calib_to, hz / 2);
d4173 1
a4173 1
	timeout_add(&sc->calib_to, hz / 2);
@


1.58
log
@make sure the channel's subband is found in iwn4965_set_txpower().

found by "Parfait".
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.57 2009/05/29 08:25:45 damien Exp $	*/
d1770 1
d1782 1
d1787 1
@


1.57
log
@fix confusion between number of DMA channels and number of Tx queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.56 2009/05/28 16:03:23 damien Exp $	*/
d3215 2
@


1.56
log
@workaround a hardware bug by fixing the pci config space command register
at attach time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.55 2009/05/27 09:50:31 damien Exp $	*/
d276 1
d306 1
d1154 1
a1154 2
	uint32_t tmp;
	int i, ntries;
a1155 11
	if (iwn_nic_lock(sc) == 0) {
		IWN_WRITE(sc, IWN_FH_TX_CONFIG(ring->qid), 0);
		for (ntries = 0; ntries < 200; ntries++) {
			tmp = IWN_READ(sc, IWN_FH_TX_STATUS);
			if ((tmp & IWN_FH_TX_STATUS_IDLE(ring->qid)) ==
			    IWN_FH_TX_STATUS_IDLE(ring->qid))
				break;
			DELAY(10);
		}
		iwn_nic_unlock(sc);
	}
d4786 1
a4786 1
	IWN_WRITE(sc, IWN_FH_TX_CONFIG(IWN_SRVC_CHNL),
d4789 2
a4790 2
	IWN_WRITE(sc, IWN_FH_SRAM_ADDR(IWN_SRVC_CHNL), dst);
	IWN_WRITE(sc, IWN_FH_TFBD_CTRL0(IWN_SRVC_CHNL),
d4792 1
a4792 1
	IWN_WRITE(sc, IWN_FH_TFBD_CTRL1(IWN_SRVC_CHNL),
d4794 1
a4794 1
	IWN_WRITE(sc, IWN_FH_TXBUF_STATUS(IWN_SRVC_CHNL),
d4800 1
a4800 1
	IWN_WRITE(sc, IWN_FH_TX_CONFIG(IWN_SRVC_CHNL),
d5094 1
a5094 1
	int error, qid;
d5151 6
a5156 2
		/* Enable TX for this ring. */
		IWN_WRITE(sc, IWN_FH_TX_CONFIG(qid),
a5159 1
	iwn_nic_unlock(sc);
d5194 2
a5195 1
	int qid;
d5210 14
a5223 3
	/* Stop all TX rings. */
	for (qid = 0; qid < hal->ntxqs; qid++)
		iwn_reset_tx_ring(sc, &sc->txq[qid]);
d5227 4
@


1.55
log
@allow iwn(4) to coexist with Intel Active Management Technology (AMT)
which may use WLAN too.  for Intel Centrino 2 vPro only.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.54 2009/05/20 16:31:50 damien Exp $	*/
d348 1
a348 1
	 * Configuration Space (the vendor driver hard-codes it as E0h.)
d361 9
@


1.54
log
@add code to read from OTPROM (1000 and 6000 series only).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.53 2009/05/12 19:10:57 damien Exp $	*/
d241 1
d391 5
d824 1
a824 1
	uint32_t val;
d842 1
a842 1
			uint32_t tmp = IWN_READ(sc, IWN_OTP_GP);
d1208 2
a1209 1
	if (IWN_READ(sc, IWN_OTP_GP) & IWN_OTP_GP_DEV_SEL_OTP)
d5063 28
d5229 5
@


1.53
log
@switch wpi(4) and iwn(4) over to MCLGETI.
notice that i'm not using the per-ifp mbuf accounting/mitigation yet.
for iwn(4), this means we wont' be able to support full 8KB AMSDU on
machines without an IOMMU since >4KB clusters are not guaranteed to
be physcontig.  fortunately, we can program the hardware to do 4KB
AMSDUs only.
simplify {pwi,iwn}_dma_contig_alloc while i'm here: use BUS_DMA_ZERO
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.52 2009/05/11 19:36:00 damien Exp $	*/
d105 1
d787 27
a822 2
		IWN_CLRBITS(sc, IWN_EEPROM, IWN_EEPROM_CMD);

d830 2
a831 2
			printf("%s: could not read EEPROM\n",
			    sc->sc_dev.dv_xname);
d834 14
d1201 6
d1208 1
a1208 1
		printf("%s: bad EEPROM signature\n", sc->sc_dev.dv_xname);
d1212 8
a1219 1
		printf("%s: could not lock EEPROM (error=%d)\n",
@


1.52
log
@new PCI IDs for 6000 series.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.51 2009/05/11 19:28:02 damien Exp $	*/
d107 1
a107 1
		    void **, bus_size_t, bus_size_t, int);
a114 4
struct		iwn_rbuf *iwn_alloc_rbuf(struct iwn_softc *);
void		iwn_free_rbuf(caddr_t, u_int, void *);
int		iwn_alloc_rpool(struct iwn_softc *);
void		iwn_free_rpool(struct iwn_softc *);
d136 2
a137 1
void		iwn_rx_phy(struct iwn_softc *, struct iwn_rx_desc *);
d141 7
a147 4
		    struct iwn_rx_desc *);
void		iwn_rx_statistics(struct iwn_softc *, struct iwn_rx_desc *);
void		iwn4965_tx_done(struct iwn_softc *, struct iwn_rx_desc *);
void		iwn5000_tx_done(struct iwn_softc *, struct iwn_rx_desc *);
a418 6
	/* Allocate RX buffers. */
	if ((error = iwn_alloc_rpool(sc)) != 0) {
		printf(": could not allocate RX buffers\n");
		goto fail3;
	}

d423 1
a423 1
			goto fail4;
d430 1
a430 1
		goto fail4;
d512 1
a512 1
fail4:	while (--i >= 0)
d514 1
a514 2
	iwn_free_rpool(sc);
fail3:	iwn_free_sched(sc);
d817 1
a817 1
    bus_size_t size, bus_size_t alignment, int flags)
d824 2
a825 1
	error = bus_dmamap_create(tag, size, 1, size, 0, flags, &dma->map);
d830 1
a830 1
	    flags);
d834 2
a835 1
	error = bus_dmamem_map(tag, &dma->seg, 1, size, &dma->vaddr, flags);
d839 2
a840 1
	error = bus_dmamap_load_raw(tag, dma->map, &dma->seg, 1, size, flags);
a843 1
	memset(dma->vaddr, 0, size);
d878 1
a878 1
	    (void **)&sc->sched, sc->sc_hal->schedsz, 1024, BUS_DMA_NOWAIT);
d892 1
a892 1
	    4096, BUS_DMA_NOWAIT);
d906 1
a906 1
	    sc->sc_hal->fwsz, 16, BUS_DMA_NOWAIT);
a914 60
struct iwn_rbuf *
iwn_alloc_rbuf(struct iwn_softc *sc)
{
	struct iwn_rbuf *rbuf;

	rbuf = SLIST_FIRST(&sc->rxq.freelist);
	if (rbuf == NULL)
		return NULL;
	SLIST_REMOVE_HEAD(&sc->rxq.freelist, next);
	return rbuf;
}

/*
 * This is called automatically by the network stack when the mbuf to which
 * our RX buffer is attached is freed.
 */
void
iwn_free_rbuf(caddr_t buf, u_int size, void *arg)
{
	struct iwn_rbuf *rbuf = arg;
	struct iwn_softc *sc = rbuf->sc;

	/* Put the RX buffer back in the free list. */
	SLIST_INSERT_HEAD(&sc->rxq.freelist, rbuf, next);
}

int
iwn_alloc_rpool(struct iwn_softc *sc)
{
	struct iwn_rx_ring *ring = &sc->rxq;
	int i, error;

	/* Allocate a big chunk of DMA'able memory... */
	error = iwn_dma_contig_alloc(sc->sc_dmat, &ring->buf_dma, NULL,
	    IWN_RBUF_COUNT * IWN_RBUF_SIZE, 4096, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not allocate RX buffers DMA memory\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	/* ...and split it into chunks of IWN_RBUF_SIZE bytes. */
	SLIST_INIT(&ring->freelist);
	for (i = 0; i < IWN_RBUF_COUNT; i++) {
		struct iwn_rbuf *rbuf = &ring->rbuf[i];

		rbuf->sc = sc;	/* Backpointer for callbacks. */
		rbuf->vaddr = ring->buf_dma.vaddr + i * IWN_RBUF_SIZE;
		rbuf->paddr = ring->buf_dma.paddr + i * IWN_RBUF_SIZE;

		SLIST_INSERT_HEAD(&ring->freelist, rbuf, next);
	}
	return 0;
}

void
iwn_free_rpool(struct iwn_softc *sc)
{
	iwn_dma_contig_free(&sc->rxq.buf_dma);
}

d926 1
a926 1
	    (void **)&ring->desc, size, 256, BUS_DMA_NOWAIT);
d935 1
a935 2
	    (void **)&ring->stat, sizeof (struct iwn_rx_status), 16,
	    BUS_DMA_NOWAIT);
d943 1
a943 1
	 * Allocate RX buffers.
d947 8
a954 1
		struct iwn_rbuf *rbuf;
d963 3
a965 4
		if ((rbuf = iwn_alloc_rbuf(sc)) == NULL) {
			m_freem(data->m);
			data->m = NULL;
			printf("%s: could not allocate RX buffer\n",
d967 10
a976 1
			error = ENOMEM;
a978 3
		/* Attach RX buffer to mbuf header. */
		MEXTADD(data->m, rbuf->vaddr, IWN_RBUF_SIZE, 0, iwn_free_rbuf,
		    rbuf);
d981 1
a981 1
		ring->desc[i] = htole32(rbuf->paddr >> 8);
d984 2
a985 2
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
	    0, ring->desc_dma.size, BUS_DMASYNC_PREWRITE);
d1021 10
a1030 2
		if (ring->data[i].m != NULL)
			m_freem(ring->data[i].m);
d1048 1
a1048 1
	    (void **)&ring->desc, size, 256, BUS_DMA_NOWAIT);
d1064 1
a1064 1
	    (void **)&ring->cmd, size, 4, BUS_DMA_NOWAIT);
d1567 2
a1568 1
iwn_rx_phy(struct iwn_softc *sc, struct iwn_rx_desc *desc)
d1573 2
a1574 3
	bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
	    (caddr_t)stat - sc->rxq.buf_dma.vaddr, sizeof (*stat),
	    BUS_DMASYNC_POSTREAD);
a1592 1
	struct iwn_rbuf *rbuf;
d1600 1
a1600 1
	int len, rssi;
d1614 1
a1614 2
	bus_dmamap_sync(sc->sc_dmat, ring->buf_dma.map,
	    (caddr_t)(desc + 1) - ring->buf_dma.vaddr, IWN_RBUF_SIZE,
d1624 1
a1624 2
		struct iwn_rx_mpdu *mpdu =
		    (struct iwn_rx_mpdu *)(desc + 1);
d1641 1
a1641 1
	if (len < sizeof (struct ieee80211_frame)) {
d1648 38
d1687 6
a1730 30
	if ((rbuf = SLIST_FIRST(&sc->rxq.freelist)) != NULL) {
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
			ic->ic_stats.is_rx_nombuf++;
			ifp->if_ierrors++;
			return;
		}
		/* Attach RX buffer to mbuf header. */
		MEXTADD(m1, rbuf->vaddr, IWN_RBUF_SIZE, 0, iwn_free_rbuf,
		    rbuf);
		SLIST_REMOVE_HEAD(&sc->rxq.freelist, next);

		data->m = m1;

		/* Update RX descriptor. */
		ring->desc[ring->cur] = htole32(rbuf->paddr >> 8);
		bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
		    ring->cur * sizeof (uint32_t), sizeof (uint32_t),
		    BUS_DMASYNC_PREWRITE);
	} else {
		/* No free rbufs, copy frame into an mbuf. */
		m = m_copym2(m, 0, M_COPYALL, M_DONTWAIT);
		if (m == NULL) {
			/* No free mbufs either, drop frame. */
			ic->ic_stats.is_rx_nombuf++;
			ifp->if_ierrors++;
			return;
		}
	}

d1791 2
a1792 1
iwn5000_rx_calib_results(struct iwn_softc *sc, struct iwn_rx_desc *desc)
d1802 1
a1802 2
	bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
	    (caddr_t)calib - sc->rxq.buf_dma.vaddr, len,
d1847 2
a1848 1
iwn_rx_statistics(struct iwn_softc *sc, struct iwn_rx_desc *desc)
d1860 2
a1861 3
	bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
	    (caddr_t)stats - sc->rxq.buf_dma.vaddr, sizeof (*stats),
	    BUS_DMASYNC_POSTREAD);
d1904 2
a1905 1
iwn4965_tx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc)
d1909 2
a1910 3
	bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
	    (caddr_t)stat - sc->rxq.buf_dma.vaddr, sizeof (*stat),
	    BUS_DMASYNC_POSTREAD);
d1915 2
a1916 1
iwn5000_tx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc)
d1923 2
a1924 3
	bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
	    (caddr_t)stat - sc->rxq.buf_dma.vaddr, sizeof (*stat),
	    BUS_DMASYNC_POSTREAD);
d2012 1
a2012 1
		struct iwn_rx_desc *desc = (void *)data->m->m_ext.ext_buf;
d2014 1
a2014 2
		bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
		    (caddr_t)desc - sc->rxq.buf_dma.vaddr, sizeof (*desc),
d2016 1
d2026 1
a2026 1
			iwn_rx_phy(sc, desc);
d2037 1
a2037 1
			sc->sc_hal->tx_done(sc, desc);
d2042 1
a2042 1
			iwn_rx_statistics(sc, desc);
d2050 1
a2050 2
			bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
			    (caddr_t)miss - sc->rxq.buf_dma.vaddr,
d2069 1
a2069 2
			bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
			    (caddr_t)uc - sc->rxq.buf_dma.vaddr,
d2093 1
a2093 2
			bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
			    (caddr_t)status - sc->rxq.buf_dma.vaddr,
d2113 1
a2113 2
			bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
			    (caddr_t)scan - sc->rxq.buf_dma.vaddr,
d2127 1
a2127 2
			bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
			    (caddr_t)scan - sc->rxq.buf_dma.vaddr,
d2145 1
a2145 1
			iwn5000_rx_calib_results(sc, desc);
@


1.51
log
@fix for some 6000 adapters that have a One Time Programmable (OTP) ROM
instead of an EEPROM.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.50 2009/04/26 02:20:58 cnst Exp $	*/
d4 1
a4 2
 * Copyright (c) 2007, 2008
 *	Damien Bergamini <damien.bergamini@@free.fr>
d83 2
@


1.50
log
@in ca_attach() there is no need to set .value and .flags of sensors to 0,
since autoconf(9) allocates softc with M_ZERO;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.49 2009/03/29 21:53:52 sthen Exp $	*/
d1206 1
a1206 1
	if ((IWN_READ(sc, IWN_EEPROM_GP) & 0x6) == 0) {
@


1.49
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.48 2009/03/10 20:39:21 damien Exp $	*/
a610 1
	sc->sensor.value = 0;
@


1.48
log
@cleanup the mess in Intel WiFi Link PCI Ids.
WiFi Link 100 Series have been renamed to 1000 Series by Intel too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.47 2009/02/15 08:58:22 damien Exp $	*/
d363 1
a363 1
		printf(": could not map memory space\n");
d369 1
a369 1
		printf(": could not map interrupt\n");
d376 1
a376 1
		printf(": could not establish interrupt");
d2627 1
a2627 1
		printf("%s: could not map mbuf (error %d)\n",
d2655 1
a2655 1
			printf("%s: could not map mbuf (error %d)\n",
@


1.47
log
@attach the Intel WiFi Link 100 and 6000 Series (though no firmware
is available yet.)
branch the ampdu_{tx,rx}_{start,stop} callbacks too.
remove code that is only needed for evaluation/test boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.46 2009/01/26 19:18:52 damien Exp $	*/
d70 20
a89 20
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_4965AGN_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_4965AGN_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_5100AGN_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_5100AGN_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_5150AGN_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_5150AGN_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_5300AGN_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_5300AGN_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_5350AGN_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_5350AGN_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6000_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6000_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6000_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6000_4 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6050_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6050_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6050_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_6050_4 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_100_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_100_2 }
d566 1
a566 1
	case IWN_HW_REV_TYPE_100:
d568 1
a568 1
		sc->fwname = "iwn-100";
@


1.46
log
@I changed the IEEE80211_QOS_ACK_POLICY_* definitions to be more in line
with other net80211 flags (we no longer need to shift.)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.45 2008/12/22 18:20:47 damien Exp $	*/
d79 11
a89 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_5350AGN_2 }
d203 1
d205 1
a205 1
		    struct ieee80211_node *, uint8_t, uint16_t);
d207 1
a207 1
		    struct ieee80211_node *, uint8_t, uint16_t);
d209 1
a209 1
		    struct ieee80211_node *, uint8_t, uint16_t);
d211 1
a211 1
		    struct ieee80211_node *, uint8_t, uint16_t);
d220 1
d267 1
d270 1
d296 1
d299 1
d489 6
d566 27
d3489 4
d3540 4
d4218 1
d4220 1
a4220 1
 * This function is called by upper layer when a ADDBA request is received
d4225 1
a4225 1
    uint8_t tid, uint16_t ssn)
d4227 1
d4237 3
a4239 2
	node.addba_ssn = htole16(ssn);
	DPRINTFN(2, ("ADDBA RA=%d TID=%d SSN=%d\n", wn->id, tid, ssn));
d4245 1
a4245 1
 * Block Ack (eg. uppon receipt of a DELBA frame.)
d4249 1
a4249 1
    uint8_t tid, uint16_t ssn)
d4265 1
a4265 1
 * This function is called by upper layer when a ADDBA response is received
d4270 1
a4270 1
    uint8_t tid, uint16_t ssn)
d4272 1
d4292 1
a4292 1
	hal->ampdu_tx_start(sc, ni, tid, ssn);
d4299 1
a4299 1
    uint8_t tid, uint16_t ssn)
d4301 1
d4306 1
a4306 1
	sc->sc_hal->ampdu_tx_stop(sc, tid, ssn);
d4429 1
d4939 4
a4942 1
	IWN_SETBITS(sc, IWN_ANA_PLL, IWN_ANA_PLL_INIT);
a4987 12
	uint8_t rev;

	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, PCI_CLASS_REG);
	rev = PCI_REVISION(reg);
	if ((rev & 0x80) && (rev & 0x7f) < 8) {
		reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag,
		    sc->sc_cap_off + PCI_PCIE_DCSR);
		/* Clear PCIe "Enable No Snoop" bit. */
		reg &= ~PCI_PCIE_DCSR_ENA_NO_SNOOP;
		pci_conf_write(sc->sc_pct, sc->sc_pcitag,
		    sc->sc_cap_off + PCI_PCIE_DCSR, reg);
	}
@


1.45
log
@I swapped MGETHDR arguments in my m_defrag removal commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.44 2008/12/21 18:19:58 damien Exp $	*/
d2460 1
a2460 2
		if (!hasqos || (qos & IEEE80211_QOS_ACK_POLICY_MASK) >>
		    IEEE80211_QOS_ACK_POLICY_SHIFT !=
@


1.44
log
@Undo m_defrag().

m_defrag() does not work.  It seems to assume that if the length of
the mbuf passed as parameter is less than MHLEN, then it is an mbuf
header and not a cluster (or something like that.)
It thus fails miserably in the bcopy path.
I don't have the time to investigate further into this.

Thanks to Okan Demirmen for reporting the issue on a ral(4) RT2560.
The RT2560 chipset does not support TX scatter and thus m_defrag()
was called much more often than in other drivers using m_defrag()
where it was less noticeable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.43 2008/12/12 17:15:40 damien Exp $	*/
d2586 1
a2586 1
		MGETHDR(m1, MT_DATA, M_DONTWAIT);
@


1.43
log
@get rid of the ugly IWN_SET_DESC_SEG/NSEGS macros.
add "support" for physical addresses larger than 32-bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.42 2008/12/03 17:17:08 damien Exp $	*/
d2366 1
d2586 2
a2587 1
		if (m_defrag(m, M_DONTWAIT) != 0) {
d2589 9
a2597 1
			return ENOMEM;
d2599 5
@


1.42
log
@allow users to select a fixed rate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.41 2008/12/02 17:17:50 damien Exp $	*/
d2370 1
d2541 2
a2542 1
	tx->loaddr = htole32(data->scratch_paddr);
d2606 1
a2606 1
	IWN_SET_DESC_NSEGS(desc, 1 + data->map->dm_nsegs);
d2608 3
a2610 2
	IWN_SET_DESC_SEG(desc, 0, data->cmd_paddr,
	    4 + sizeof (*tx) + hdrlen + pad);
d2612 1
d2614 4
a2617 2
		IWN_SET_DESC_SEG(desc, i, data->map->dm_segs[i - 1].ds_addr,
		    data->map->dm_segs[i - 1].ds_len);
d2841 3
a2843 2
	IWN_SET_DESC_NSEGS(desc, 1);
	IWN_SET_DESC_SEG(desc, 0, paddr, totlen);
d4694 4
a4697 2
	IWN_WRITE(sc, IWN_FH_TFBD_CTRL0(IWN_SRVC_CHNL), dma->paddr);
	IWN_WRITE(sc, IWN_FH_TFBD_CTRL1(IWN_SRVC_CHNL), size);
@


1.41
log
@Add code for 5150 support (not tested since I don't have the hardware and
because it requires a specific firmware that Intel has not released yet.)
Fix crystal calibration for 5000 Series.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.40 2008/11/25 22:20:11 damien Exp $	*/
d1391 3
d1400 10
d2391 1
a2391 1
	/* Chose a TX rate index. */
d2396 2
@


1.40
log
@more sizeof->nitems
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.39 2008/11/25 21:43:57 damien Exp $	*/
d74 2
a256 1
	"iwn-4965",
a283 1
	"iwn-5000",
d511 1
d520 1
d529 2
a530 1
		sc->critical_temp = IWN_CTOK(110);
d539 1
d1265 1
d1271 1
a1271 1
	iwn_read_prom_data(sc, IWN5000_EEPROM_REG, &val, sizeof val);
d1282 1
a1282 2
	/* Read crystal calibration. */
	iwn_read_prom_data(sc, IWN5000_EEPROM_CAL, &val, sizeof val);
d1284 17
a1300 3
	iwn_read_prom_data(sc, base + IWN5000_EEPROM_CRYSTAL,
	    &sc->eeprom_crystal, sizeof (uint32_t));
	DPRINTF(("crystal calibration 0x%08x\n", sc->eeprom_crystal));
d1767 1
a1767 5
	u_int idx, len;

	/* No initial calibration required for 5150! */
	if (sc->hw_type == IWN_HW_REV_TYPE_5150)
		return;
d1779 4
d1784 1
a1784 1
		idx = 0;
d1787 1
a1787 1
		idx = 1;
d1790 2
a1791 1
		idx = 2;
d1794 1
a1794 1
		idx = 3;
d1796 2
a1797 2
	default:
		/* Ignore other results. */
d1799 1
a1799 1
	}
d4365 1
a4365 1
	for (idx = 0; idx < 4; idx++) {
d4729 1
a4729 1
	if ((error = loadfirmware(hal->fwname, &fw->data, &size)) != 0) {
d4731 1
a4731 1
		    sc->sc_dev.dv_xname, error, hal->fwname);
@


1.39
log
@use shiny new m_defrag() and nitems() instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.38 2008/11/25 17:06:27 damien Exp $	*/
d307 1
a307 1
	    sizeof iwn_devices / sizeof iwn_devices[0]);
@


1.38
log
@add a shitload of bus_dmamap_sync() calls, even though they are no-ops
on i386 and amd64 (we do not implement bounce buffers) where this hardware
is likely to be found.  this is good programming practice.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.37 2008/11/22 08:23:52 brad Exp $	*/
a2146 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d2176 1
a2176 1
	    (dump.id < N(iwn_fw_errmsg)) ?
a2197 1
#undef N
a2334 1
	struct mbuf *m1;
d2549 1
a2549 2
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
a2552 13
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(m1);
				return ENOMEM;
			}
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_len = m1->m_pkthdr.len = m->m_pkthdr.len;
		m_freem(m);
		m = m1;

@


1.37
log
@- Slight wording tweak.. leave -> let.
- Sync wpi(4)'s set_key comment with the comment from iwn(4).

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.36 2008/11/21 17:17:05 damien Exp $	*/
d796 1
d813 2
d984 4
d1108 2
d1117 2
d1136 2
d1535 1
a1535 1
	struct iwn_rx_stat *stat;
d1538 4
a1542 1
	stat = (struct iwn_rx_stat *)(desc + 1);
d1581 4
d1672 3
d1759 5
a1783 1
	len = (letoh32(desc->len) & 0x3fff) - 4;
d1813 4
d1862 3
d1875 4
d1906 2
d1941 2
d1960 3
d1968 4
d2003 4
d2024 3
d2049 3
d2070 3
d2085 3
d2276 4
a2279 1
	if (idx < IWN_SCHED_WINSZ)
d2281 4
d2294 4
a2297 1
	if (idx < IWN_SCHED_WINSZ)
d2299 4
d2311 4
a2314 1
	if (idx < IWN_SCHED_WINSZ)
d2316 4
d2597 9
d2821 12
d4591 2
d4595 2
d4631 2
d4635 2
d4661 1
@


1.36
log
@Fix crystal and gain calibration on 5000 Series.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.35 2008/11/19 18:52:53 damien Exp $	*/
d3956 1
a3956 1
 * HW support for TKIP really sucks.  We should leave TKIP die anyway.
@


1.35
log
@For 5000 Series, store baseband calibration results sent by the
initialization firmware and send them to the runtime firmware.
This has no effect on my 5300 since the initialization firmware
does not send baseband results. This may be important for other
chips though or for future firmware revisions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.34 2008/11/16 09:52:31 damien Exp $	*/
d3297 2
d3344 2
d3353 1
a3353 1
			cmd.gain[i] = MIN(abs(delta), 3);
d3355 1
a3355 1
				cmd.gain[i] |= 1 << 2;	/* sign bit */
d3358 2
a3359 2
	DPRINTF(("setting differential gains Ant A/B/C: %x/%x/%x (%x)\n",
	    cmd.gain[0], cmd.gain[1], cmd.gain[2], sc->antmsk));
d3954 4
a3967 5
	/*
	 * We support CCMP hardware encryption/decryption of unicast frames
	 * only.  Hardware support for TKIP really sucks and it is not worth
	 * implementing.  We should leave TKIP die anyway.
	 */
d4393 4
a4396 2
		cmd.data[0] = letoh32(sc->eeprom_crystal) & 0xff;
		cmd.data[1] = (letoh32(sc->eeprom_crystal) >> 16) & 0xff;
d4398 1
a4398 1
		    cmd.data[0], cmd.data[1]));
@


1.34
log
@clear pending interrupts in the driver attach routine.
otherwise the chip comes up with the RF_TOGGLED bit set which triggers
an if_stop() call if a shared interrupt occurs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.32 2008/11/09 10:00:17 damien Exp $	*/
d1740 1
a1740 1
	case IWN5000_PHY_CALIB_LO_TX_IQ:
d1743 1
a1743 1
	case IWN5000_PHY_CALIB_LO_TX_IQ_PERD:
d1746 3
d4253 1
a4253 1
	for (idx = 0; idx < 3; idx++) {
d4288 3
d4342 3
@


1.33
log
@remove dead code.
@
text
@d424 2
d4825 1
a4825 1
	/* Clear any pending interrupts. */
d4891 1
a4891 1
	/* Clear any pending interrupts. */
@


1.32
log
@rework the rate coding code to get rid of the ugly {wpi,iwn}_plcp_signal()
function.  will be required for future MCS support in iwn.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.31 2008/11/08 18:42:50 damien Exp $	*/
d2764 1
a2764 1
	uint8_t txant, rate;
a2780 1
		rate = rs->rs_rates[txrate] & IEEE80211_RATE_VAL;
@


1.31
log
@when defragmenting an mbuf chain, do not call M_DUP_PKTHDR.
this is an overkill in this case as it duplicates mbuf tags etc...

following a discussion with kettenis@@ a few months ago about gem(4)
did some cleanup while i was there.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.30 2008/11/08 17:15:54 damien Exp $	*/
a146 1
uint8_t		iwn_plcp_signal(int);
d1336 3
a1338 1
	int i;
d1340 1
a1340 1
	ieee80211_amrr_node_init(&sc->amrr, &((struct iwn_node *)ni)->amn);
d1342 11
a1352 5
	/* Set rate to some reasonable initial value. */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;
a2230 29
uint8_t
iwn_plcp_signal(int rate)
{
	switch (rate) {
	/* CCK rates (returned values are device-dependent.) */
	case 2:		return 10;
	case 4:		return 20;
	case 11:	return 55;
	case 22:	return 110;

	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80.) */
	/* R1-R4, (u)ral is R4-R1 */
	case 12:	return 0xd;
	case 18:	return 0xf;
	case 24:	return 0x5;
	case 36:	return 0x7;
	case 48:	return 0x9;
	case 72:	return 0xb;
	case 96:	return 0x1;
	case 108:	return 0x3;
	case 120:	return 0x3;
	}
	/* Unknown rate (should not get there.) */
	return 0;
}

/* Determine if a given rate is CCK or OFDM. */
#define IWN_RATE_IS_OFDM(rate) ((rate) >= 12 && (rate) != 22)

d2236 1
d2242 1
a2248 1
	uint8_t *ivp, tid, txant, type;
d2250 2
a2251 1
	int i, totlen, hasqos, rate, error, pad;
d2271 1
a2271 1
	/* Chose a TX rate. */
d2274 2
a2275 4
		rate = ni->ni_rates.rs_rates[0];
	} else if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
d2277 2
a2278 2
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	rate &= IEEE80211_RATE_VAL;
d2288 1
a2288 1
		tap->wt_rate = rate;
d2355 1
a2355 1
		    IWN_RATE_IS_OFDM(rate)) {
d2375 1
a2375 1
		tx->id = ((struct iwn_node *)ni)->id;
d2405 2
a2406 4
	tx->rate = iwn_plcp_signal(rate);
	tx->rflags = 0;
	if (!IWN_RATE_IS_OFDM(rate))
		tx->rflags |= IWN_RFLAG_CCK;
d2409 1
a2409 1
		tx->ridx = IWN_MAX_TX_RETRIES - 1;
d2414 2
a2415 3
		tx->ridx = ni->ni_rates.rs_nrates - ni->ni_txrate - 1;
		/* Tell adapter to ignore rflags. */
		flags |= IWN_TX_MRR_INDEX;
d2763 1
d2765 1
a2765 1
	int i, ridx;
d2779 1
a2779 1
	ridx = rs->rs_nrates - 1;
d2781 5
a2785 6
		rate = rs->rs_rates[ridx] & IEEE80211_RATE_VAL;
		DPRINTF(("retry %d, rate %d\n", i, rate));
		linkq.retry[i].rate = iwn_plcp_signal(rate);
		linkq.retry[i].rflags = IWN_RFLAG_ANT(txant);
		if (!IWN_RATE_IS_OFDM(rate))
			linkq.retry[i].rflags |= IWN_RFLAG_CCK;
d2787 2
a2788 2
		if (ridx > 0)
			ridx--;
d2802 1
d2825 4
a2828 5
	if (sc->sc_ic.ic_curmode != IEEE80211_MODE_11A) {
		linkq.retry[0].rate = iwn_ridx_to_plcp[IWN_CCK1];
		linkq.retry[0].rflags = IWN_RFLAG_CCK;
	} else
		linkq.retry[0].rate = iwn_ridx_to_plcp[IWN_OFDM6];
d2832 1
a2832 1
		linkq.retry[i].rate = linkq.retry[0].rate;
d3730 1
a3730 1
		tx->rate = iwn_ridx_to_plcp[IWN_OFDM6];
d3735 1
a3735 1
		tx->rate = iwn_ridx_to_plcp[IWN_CCK1];
d3906 4
a3910 1
	((struct iwn_node *)ni)->id = IWN_ID_BSS;
a3929 3

	/* Fake a join to initialize the TX rate. */
	iwn_newassoc(ic, ni, 1);
@


1.30
log
@remove two printfs that slipped through my last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.29 2008/11/08 12:27:57 damien Exp $	*/
d148 1
a148 1
int		iwn_tx_data(struct iwn_softc *, struct mbuf *,
d1458 1
a1458 1
iwn_ccmp_decap(struct iwn_softc *sc, struct mbuf *m0, struct ieee80211_key *k)
d1466 1
a1466 1
	wh = mtod(m0, struct ieee80211_frame *);
d1499 2
a1500 2
	ovbcopy(wh, mtod(m0, caddr_t) + IEEE80211_CCMP_HDRLEN, hdrlen);
	m_adj(m0, IEEE80211_CCMP_HDRLEN);
d1502 1
a1502 1
	m_adj(m0, -IEEE80211_CCMP_MICLEN);
d1538 1
a1538 1
	struct mbuf *m, *mnew;
d1628 2
a1629 2
		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
d1635 1
a1635 1
		MEXTADD(mnew, rbuf->vaddr, IWN_RBUF_SIZE, 0, iwn_free_rbuf,
d1639 1
a1639 1
		data->m = mnew;
d2254 1
a2254 1
iwn_tx_data(struct iwn_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
d2266 1
a2266 1
	struct mbuf *mnew;
d2273 1
a2273 1
	wh = mtod(m0, struct ieee80211_frame *);
d2318 1
a2318 1
		mb.m_next = m0;
d2326 1
a2326 1
	totlen = m0->m_pkthdr.len;
d2334 1
a2334 1
			if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
d2337 2
a2338 2
			wh = mtod(m0, struct ieee80211_frame *);
			totlen = m0->m_pkthdr.len;
d2450 2
a2451 2
		m_adj(m0, hdrlen - IEEE80211_CCMP_HDRLEN);
		ivp = mtod(m0, uint8_t *);
d2471 1
a2471 1
		m_adj(m0, hdrlen);
d2476 1
a2476 1
	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
d2481 1
a2481 1
		m_freem(m0);
d2486 3
a2488 4

		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
			m_freem(m0);
d2491 5
a2495 6
		M_DUP_PKTHDR(mnew, m0);
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(mnew, M_DONTWAIT);
			if (!(mnew->m_flags & M_EXT)) {
				m_freem(m0);
				m_freem(mnew);
d2499 4
a2502 4
		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(mnew, caddr_t));
		m_freem(m0);
		mnew->m_len = mnew->m_pkthdr.len;
		m0 = mnew;
d2504 1
a2504 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
d2509 1
a2509 1
			m_freem(m0);
d2514 1
a2514 1
	data->m = m0;
d2518 1
a2518 1
	    ring->qid, ring->cur, m0->m_pkthdr.len, data->map->dm_nsegs));
d2585 1
a2585 1
		if (iwn_tx_data(sc, m, ni) != 0) {
@


1.29
log
@do not call if_start() from tx_done() unless there is a reason to do so
(IFF_OACTIVE was set.)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.28 2008/11/08 11:05:36 damien Exp $	*/
a2631 1
printf("iwn_ioctl SIOCSIFADDR\n");
a2639 1
printf("iwn_ioctl SIOCSIFFLAGS flags=0x%x\n", ifp->if_flags);
@


1.28
log
@rework iwn_start().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.27 2008/11/06 17:04:55 damien Exp $	*/
d1863 1
a1863 1
	if (--ring->queued < IWN_TX_RING_LOMARK)
d1865 4
a1868 3
	if (sc->qfullmsk == 0) {
		ifp->if_flags &= ~IFF_OACTIVE;
		(*ifp->if_start)(ifp);
@


1.27
log
@The EEPROM is lying about antennas.  Hardcode things based on the chip
ID which is also what the vendor driver happens to do.
Fixes a firmware SYSASSERT on the 5100 when adding the broadcast node.

Reported by Jean-Michel Bessot and Robert <robert at openbsd.pap.st>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.26 2008/11/03 17:19:54 damien Exp $	*/
d1360 1
a1360 1
		(void)iwn_init(ifp);
d1362 1
a1362 1
	return 0;
d2540 1
a2540 1
	if (++ring->queued > IWN_TX_RING_HIMARK) {
d2542 1
a2542 2
		ic->ic_if.if_flags |= IFF_OACTIVE;
	}
d2552 1
a2552 1
	struct mbuf *m0;
a2553 4
	/*
	 * net80211 may still try to send management frames even if the
	 * IFF_RUNNING flag is not set...
	 */
d2558 12
a2569 5
		IF_POLL(&ic->ic_mgtq, m0);
		if (m0 != NULL) {
			if (sc->qfullmsk != 0)
				break;
			IF_DEQUEUE(&ic->ic_mgtq, m0);
d2571 4
a2574 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
d2576 2
a2577 2
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
d2579 3
a2581 12
			if (iwn_tx_data(sc, m0, ni) != 0)
				break;

		} else {
			if (ic->ic_state != IEEE80211_S_RUN)
				break;
			IFQ_POLL(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
			if (sc->qfullmsk != 0)
				break;
			IFQ_DEQUEUE(&ifp->if_snd, m0);
d2583 2
a2584 2
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
d2586 4
a2589 13
			m0 = ieee80211_encap(ifp, m0, &ni);
			if (m0 == NULL)
				continue;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (iwn_tx_data(sc, m0, ni) != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
d2631 1
d2640 1
d2643 1
a2643 1
				(void)iwn_init(ifp);
d2686 1
a2686 1
			(void)iwn_init(ifp);
a3933 1

d4885 1
@


1.26
log
@HW CCMP encryption/decryption of unicast frames.
HW support for other ciphers (TKIP) really sucks (no Michael MIC,
not even TKIP Phase 1) and is thus not implemented here.

fix a panic in iwn_fatal_intr() when dumping the firmware error
log while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.25 2008/10/22 06:25:07 damien Exp $	*/
d511 12
d527 4
a531 1
	case IWN_HW_REV_TYPE_5100:
d536 2
a1152 13
	sc->txantmsk = IWN_RFCFG_TXANTMSK(sc->rfcfg);
	sc->rxantmsk = IWN_RFCFG_RXANTMSK(sc->rfcfg);
	/* Count the number of TX and RX chains. */
	sc->ntxchains =
	    ((sc->txantmsk >> 3) & 1) +
	    ((sc->txantmsk >> 2) & 1) +
	    ((sc->txantmsk >> 1) & 1) +
	    ((sc->txantmsk >> 0) & 1);
	sc->nrxchains =
	    ((sc->rxantmsk >> 3) & 1) +
	    ((sc->rxantmsk >> 2) & 1) +
	    ((sc->rxantmsk >> 1) & 1) +
	    ((sc->rxantmsk >> 0) & 1);
d2833 3
d2852 3
a2854 4
	/*
	 * Setup link quality for broadcast node.  The broadcast node is
	 * used to send group-addressed and management frames.
	 */
d2857 1
a2857 1
	linkq.antmsk_1stream = IWN_ANT_B;
a2861 3

	/* Use the first valid TX antenna. */
	txant = IWN_LSB(sc->txantmsk);
@


1.25
log
@lot of cleanup, small fixes.
prepare for future enhancements.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.24 2008/10/13 16:37:10 damien Exp $	*/
d125 2
a445 1
	ic->ic_sup_rates[IEEE80211_MODE_11A] = ieee80211_std_rateset_11a;
d448 4
d470 2
a475 4
#ifdef notyet
	ic->ic_set_key = iwn_set_key;
	ic->ic_delete_key = iwn_delete_key;
#endif
d1140 1
d1145 1
d1295 3
a1297 3
			 * both in the 2GHz *and* 5GHz bands.
			 * Because of limitations in our net80211 stack,
			 * we can't support these channels in 5GHz band.
d1305 1
a1305 1
			/* We have at least one valid 5GHZ channel. */
d1453 49
d1537 1
a1537 1
	uint32_t *tail;
d1541 1
a1541 1
		/* Check for prior RX_PHY. */
d1568 2
d1571 2
a1572 3
	tail = (uint32_t *)(head + len);
	if ((letoh32(*tail) & IWN_RX_NOERROR) != IWN_RX_NOERROR) {
		DPRINTFN(2, ("RX flags error %x\n", letoh32(*tail)));
d1591 32
a1695 4
	/* Grab a reference to the source node. */
	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

a1696 1
	rxi.rxi_flags = 0;
d2094 3
a2096 2
	printf("\error type       = \"%s\" (0x%08X)\n",
	    dump.id < N(iwn_fw_errmsg) ? iwn_fw_errmsg[dump.id] : "UNKNOWN",
d2098 3
a2100 3
	printf("\tprogram counter = 0x%08X\n", dump.pc);
	printf("\tsource line     = 0x%08X\n", dump.src_line);
	printf("\terror data      = 0x%08X%08X\n",
d2102 1
a2102 1
	printf("\tbranch link     = 0x%08X%08X\n",
d2104 1
a2104 1
	printf("\tinterrupt link  = 0x%08X\n",
d2106 1
a2106 1
	printf("\ttime            = %u\n", dump.time[0]);
d2112 1
a2112 1
		printf("\ttx ring %2d: qid=%2d cur=%3d queued=%3d\n",
d2115 2
a2116 2
	printf("\trx ring: cur=%d\n", sc->rxq.cur);
	printf("\t802.11 state %d\n", sc->sc_ic.ic_state);
a2247 69
#ifdef notyet
void
iwn_ccmp_encap(struct iwn_softc *sc, struct mbuf *m0, struct ieee80211_key *k)
{
	u_int8_t *ivp;

	M_PREPEND(m0, IEEE80211_CCMP_HDRLEN, M_NOWAIT);
	/* NB: Can't fail because of previous m_adj() call. */

	k->k_tsc++;	/* Increment the 48-bit PN. */

	/* Construct CCMP header. */
	ivp = mtod(m0, u_int8_t *);
	ivp[0] = k->k_tsc;		/* PN0 */
	ivp[1] = k->k_tsc >> 8;		/* PN1 */
	ivp[2] = 0;			/* Rsvd */
	ivp[3] = k->k_id << 6 | IEEE80211_WEP_EXTIV;	/* KeyID | ExtIV */
	ivp[4] = k->k_tsc >> 16;	/* PN2 */
	ivp[5] = k->k_tsc >> 24;	/* PN3 */
	ivp[6] = k->k_tsc >> 32;	/* PN4 */
	ivp[7] = k->k_tsc >> 40;	/* PN5 */
}

void
iwn_ccmp_decap(struct iwn_softc *sc, struct mbuf *m0, struct ieee80211_key *k)
{
	struct ieee80211_frame *wh;
	uint64_t pn, *prsc;
	uint8_t *ivp;
	uint8_t tid;
	int hdrlen;

	wh = mtod(m0, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	ivp = (uint8_t *)wh + hdrlen;

	/* Check that ExtIV bit is be set. */
	if (!(ivp[3] & IEEE80211_WEP_EXTIV))
		return 1;

	tid = ieee80211_has_qos(wh) ?
	    ieee80211_get_qos(wh) & IEEE80211_QOS_TID : 0;
	prsc = &k->k_rsc[tid];

	/* Extract the 48-bit PN from the CCMP header. */
	pn = (u_int64_t)ivp[0]       |
	     (u_int64_t)ivp[1] <<  8 |
	     (u_int64_t)ivp[4] << 16 |
	     (u_int64_t)ivp[5] << 24 |
	     (u_int64_t)ivp[6] << 32 |
	     (u_int64_t)ivp[7] << 40;
	if (pn <= *prsc) {
		/* Replayed frame, discard. */
		ic->ic_stats.is_ccmp_replays++;
		return 1;
	}
	/* Update last seen packet number. */
	*prsc = pn;

	/* Clear Protected bit and strip IV. */
	wh->i_fc[1] &= ~IEEE80211_FC1_PROTECTED;
	ovbcopy(wh, mtod(m0, caddr_t) + IEEE80211_CCMP_HDRLEN, hdrlen);
	m_adj(m0, IEEE80211_CCMP_HDRLEN);
	/* Strip MIC. */
	m_adj(m0, -IEEE80211_CCMP_MICLEN);
	return 0;
}
#endif

d2259 1
a2259 1
	struct ieee80211_key *k;
d2264 1
a2264 1
	uint8_t tid, txant, type;
d2266 1
a2266 1
	int i, hasqos, rate, error, pad;
d2321 2
d2327 10
a2336 5
		/* Do software encryption. */
		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOBUFS;
		/* 802.11 header may have moved. */
		wh = mtod(m0, struct ieee80211_frame *);
d2369 1
a2369 2
		if (m0->m_pkthdr.len + IEEE80211_CRC_LEN >
		    ic->ic_rtsthreshold) {
d2417 1
a2417 2
	tx->flags = htole32(flags);
	tx->len = htole16(m0->m_pkthdr.len);
d2435 1
a2435 1
		tx->flags |= htole32(IWN_TX_MRR_INDEX);
d2440 1
a2440 1
	/* Copy and trim 802.11 header. */
d2442 28
a2469 1
	m_adj(m0, hdrlen);
d2480 1
a2480 1
		/* Too many fragments, linearize mbuf. */
d2529 1
a2529 2
	hal->update_sched(sc, ring->qid, ring->cur, tx->id,
	    hdrlen + m0->m_pkthdr.len);
d2802 3
d2807 1
a2807 1
	linkq.antmsk_1stream = IWN_ANT_B;
a2812 3
	/* Use the first valid TX antenna. */
	txant = IWN_LSB(sc->txantmsk);

d2957 1
d3797 2
a3798 2
	*(u_int16_t *)&wh->i_dur[0] = 0;	/* filled by HW */
	*(u_int16_t *)&wh->i_seq[0] = 0;	/* filled by HW */
a3833 2

		frm += sizeof (struct iwn_scan_chan);
d3836 1
a3836 1
	buflen = frm - (uint8_t *)hdr;
d3943 1
d3988 1
a3988 1
	struct iwn_softc *sc = (void *)ic;
d3995 3
a3997 3
	 * We support CCMP hardware encryption/decryption only.  Hardware
	 * support for TKIP really sucks and it is not worth implementing.
	 * We should leave TKIP die anyway.
d3999 2
a4000 1
	if (k->k_cipher != IEEE80211_CIPHER_CCMP)
d4015 1
d4023 1
a4023 1
	struct iwn_softc *sc = (void *)ic;
d4028 2
a4029 1
	if (k->k_cipher != IEEE80211_CIPHER_CCMP) {
d4043 1
d4055 1
a4055 1
	struct iwn_softc *sc = (void *)ic;
d4077 1
a4077 1
	struct iwn_softc *sc = (void *)ic;
d4098 1
a4098 1
	struct iwn_softc *sc = (void *)ic;
d4126 1
a4126 1
	struct iwn_softc *sc = (void *)ic;
@


1.24
log
@Almost complete rewrite of iwn(4).
Add support for Intel WiFi Link 5000 Series adapters (5100/5150/5300/5350).

Quite frankly, Intel made things unnecessarily difficult by gratuitously
changing firmware commands (adding new fields in the middle of a struct)
and some register offsets for the 5000 Series and by defining yet another
way of loading a firmware.
I had to write a hardware abstraction layer to manage those differences.

Committed over a 5300 adapter (3T3R).
Require an upgrade of the iwn-firmware package, even for 4965AGN users.
Not tested on 5100, 5150 and 5350 (test reports are more than welcomed.)
There should be no regression on the 4965AGN.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.23 2008/08/27 09:05:03 damien Exp $	*/
a90 4
void		iwn_prph_write_region_4(struct iwn_softc *, uint32_t,
		    const uint32_t *, int);
void		iwn_mem_set_region_4(struct iwn_softc *, uint32_t, uint32_t,
		    int);
d125 1
a125 1
void		iwn_ampdu_rx_start(struct iwn_softc *, struct iwn_rx_desc *);
d134 1
a134 1
		    uint32_t);
d138 1
d156 3
a158 3
int		iwn_setup_node_mrr(struct iwn_softc *,
		    const struct ieee80211_node *, uint8_t);
int		iwn_set_fixed_rate(struct iwn_softc *, uint8_t, uint8_t, int);
d186 20
a205 6
int		iwn4965_addba(struct iwn_softc *, struct ieee80211_node *,
		    int, int, int);
int		iwn4965_delba(struct iwn_softc *, int, int, int);
int		iwn5000_addba(struct iwn_softc *, struct ieee80211_node *,
		    int, int, int);
int		iwn5000_delba(struct iwn_softc *, int, int, int);
d252 2
d280 2
d337 1
a337 1
	/* Clear device-specific "PCI retry timeout" register (41H). */
d424 2
a425 2
	printf(", %dT%dR, %.4s, address %s\n", sc->ntxchains, sc->nrxchains,
	    sc->eeprom_domain, ether_sprintf(ic->ic_myaddr));
d440 2
a441 1
	    IEEE80211_C_SHPREAMBLE;	/* short preamble supported */
d469 4
a506 2
		sc->ntxchains = 2;
		sc->nrxchains = 2;	/* XXX should be 3? */
a508 6
	case IWN_HW_REV_TYPE_5100:
		sc->sc_hal = &iwn5000_hal;
		sc->ntxchains = 1;
		sc->nrxchains = 2;
		sc->critical_temp = 110;
		break;
a510 2
		sc->ntxchains = 1;
		sc->nrxchains = 2;
d513 1
a516 2
		sc->ntxchains = 3;
		sc->nrxchains = 3;
d575 1
a575 1
	/* Clear device-specific "PCI retry timeout" register (41H). */
d629 13
a641 1
void
d676 9
a684 1
void
d1133 11
d1368 1
a1368 1
		iwn_set_led(sc, IWN_LED_LINK, 20, 2);
d1449 2
a1450 2
 * Process an AMPDU_RX_START firmware notification.  This is usually
 * immediately followed by an AMPDU_RX_DONE notification.
d1453 1
a1453 1
iwn_ampdu_rx_start(struct iwn_softc *sc, struct iwn_rx_desc *desc)
d1457 2
a1458 2
	DPRINTFN(2, ("received AMPDU stats\n"));
	/* Save RX statistics, they will be used on AMPDU_RX_DONE. */
d1465 2
a1466 2
 * Process an RX_DONE (4965AGN only) or AMPDU_RX_DONE firmware notification.
 * Each AMPDU_RX_DONE notification must be preceded by an AMPDU_RX_START.
d1486 2
a1487 2
	if (desc->type == IWN_AMPDU_RX_DONE) {
		/* Check for prior AMPDU_RX_START. */
d1489 1
a1489 1
			DPRINTF(("missing AMPDU_RX_START\n"));
d1504 5
a1508 5
	if (desc->type == IWN_AMPDU_RX_DONE) {
		struct iwn_rx_ampdu *ampdu =
		    (struct iwn_rx_ampdu *)(desc + 1);
		head = (caddr_t)(ampdu + 1);
		len = letoh16(ampdu->len);
d1571 2
d1630 1
a1630 1
	struct iwn5000_calib *calib = (struct iwn5000_calib *)(desc + 1);
d1733 1
a1733 1
	iwn_tx_done(sc, desc, stat->retrycnt, letoh32(stat->status));
d1743 1
a1743 1
	iwn_tx_done(sc, desc, stat->retrycnt, letoh16(stat->status));
d1751 1
a1751 1
    uint32_t status)
d1831 2
a1832 2
		case IWN_AMPDU_RX_START:
			iwn_ampdu_rx_start(sc, desc);
d1836 1
a1836 1
		case IWN_AMPDU_RX_DONE:
d1885 2
d1975 62
d2070 1
a2070 1
		/* XXX reduce TX power? */
d2074 2
d2165 69
d2250 1
a2250 1
	uint8_t tid, type;
d2326 2
a2327 1
	/* NB: No need to bzero tx, all fields are reinitialized here. */
d2360 1
a2360 1
				/* 5000 autoselect RTS/CTS or CTS-to-self. */
d2362 1
a2362 1
				flags |= IWN5000_TX_NEED_RTS_CTS;
d2372 1
a2372 1
		tx->id = IWN_ID_BSS;
d2411 2
a2412 1
		tx->rflags |= IWN_RFLAG_ANT_B;
d2479 1
a2479 1
		     data->map->dm_segs[i - 1].ds_len);
d2624 16
a2651 1

d2726 1
d2728 10
a2737 8
	/* We use the node structure for 5000 internally, convert it. */
	memset(&hnode, 0, sizeof hnode);
	hnode.control = node->control;
	IEEE80211_ADDR_COPY(hnode.macaddr, node->macaddr);
	hnode.id = node->id;
	hnode.flags = node->flags;
	hnode.htflags = node->htflags;
	/* XXX More fields. */
a2747 3
/*
 * Configure hardware multi-rate retries for one node.
 */
d2749 1
a2749 2
iwn_setup_node_mrr(struct iwn_softc *sc, const struct ieee80211_node *ni,
    uint8_t id)
d2751 24
a2774 19
	const struct ieee80211_rateset *rs = &ni->ni_rates;
	struct iwn_cmd_mrr mrr;
	uint8_t rate;
	int i, r;

	memset(&mrr, 0, sizeof mrr);
	mrr.id = id;
	mrr.ssmask = 2;
	mrr.dsmask = 3;
	mrr.ampdu_max = 64;
	mrr.ampdu_disable = 3;
	mrr.ampdu_limit = htole16(4000);

	r = rs->rs_nrates - 1;
	for (i = 0; i < IWN_MAX_TX_RETRIES && r >= 0; i++, r--) {
		rate = rs->rs_rates[r] & IEEE80211_RATE_VAL;
		DPRINTF(("retry %d: rate %d\n", i, rate));
		mrr.table[i].rate = iwn_plcp_signal(rate);
		mrr.table[i].rflags = IWN_RFLAG_ANT_B;
d2776 4
a2779 1
			mrr.table[i].rflags |= IWN_RFLAG_CCK;
d2781 1
a2781 10
	/* Pad with the lowest available bit-rate. */
	rate = rs->rs_rates[0] & IEEE80211_RATE_VAL;
	for (; i < IWN_MAX_TX_RETRIES; i++) {
		DPRINTF(("retry %d: rate %d\n", i, rate));
		mrr.table[i].rate = iwn_plcp_signal(rate);
		mrr.table[i].rflags = IWN_RFLAG_ANT_B;
		if (!IWN_RATE_IS_OFDM(rate))
			mrr.table[i].rflags |= IWN_RFLAG_CCK;
	}
	return iwn_cmd(sc, IWN_CMD_NODE_MRR_SETUP, &mrr, sizeof mrr, 1);
d2785 1
a2785 1
iwn_set_fixed_rate(struct iwn_softc *sc, uint8_t id, uint8_t rate, int async)
d2787 12
a2798 2
	struct iwn_cmd_mrr mrr;
	int i;
d2800 23
a2822 13
	memset(&mrr, 0, sizeof mrr);
	mrr.id = id;
	mrr.ssmask = 2;
	mrr.dsmask = 3;
	mrr.ampdu_max = 64;
	mrr.ampdu_disable = 3;
	mrr.ampdu_limit = htole16(4000);

	/* To set a fixed rate, we make all retries use the same rate. */
	mrr.table[0].rate = iwn_plcp_signal(rate);
	mrr.table[0].rflags = IWN_RFLAG_ANT_B;
	if (!IWN_RATE_IS_OFDM(rate))
		mrr.table[0].rflags |= IWN_RFLAG_CCK;
d2824 2
a2825 2
		mrr.table[i].rate = mrr.table[0].rate;
		mrr.table[i].rflags = mrr.table[0].rflags;
d2827 1
a2827 1
	return iwn_cmd(sc, IWN_CMD_NODE_MRR_SETUP, &mrr, sizeof mrr, async);
d2862 1
a2862 1
	led.unit = htole32(1000);	/* on/off in unit of 100ms */
d3073 3
a3075 3
	cmd.global_limit = 2 * IWN5000_TX_POWER_MAX_DBM;	/* 16 dBm */
	cmd.flags = IWN5000_TX_POWER_NO_CLOSED;
	cmd.srv_limit = IWN5000_TX_POWER_AUTO;
d3094 1
a3094 1
	if (mask & (1 << 0))	/* Ant A */
d3096 1
a3096 1
	if (mask & (1 << 1))	/* Ant B */
d3098 1
a3098 1
	if (mask & (1 << 2))	/* Ant C */
d3247 3
a3249 3
	/* If neither antenna A nor antenna B are connected... */
	if ((sc->antmsk & (1 << 0 | 1 << 1)) == 0)
		sc->antmsk |= 1 << 1;	/* ...mark antenna B as connected! */
d3258 1
d3260 2
a3261 2
	/* XXX Enable power-saving mode. */
	if (ic->ic_flags & IEEE80211_F_PMGTON)
a3262 1
#endif
d3268 1
a3268 1
	struct iwn_phy_calib_cmd cmd;
d3271 1
a3271 1
	cmd.code = IWN4965_SET_DIFF_GAIN;
d3274 1
a3274 1
	return iwn_cmd(sc, IWN_PHY_CALIB, &cmd, sizeof cmd, 1);
d3280 1
a3280 1
	uint32_t code;
d3282 2
a3283 1
	code = htole32(IWN5000_PHY_CALIB_RESET_NOISE_GAIN);
d3285 1
a3285 1
	return iwn_cmd(sc, IWN_PHY_CALIB, &code, sizeof code, 1);
d3292 1
a3292 1
	struct iwn_phy_calib_cmd cmd;
d3302 1
a3302 1
	cmd.code = IWN4965_SET_DIFF_GAIN;
d3306 7
a3312 3
			delta = ((int32_t)calib->noise[i] - noise) / 30;
			cmd.gain[i] = MIN(delta, 3);
			cmd.gain[i] |= 1 << 2;
d3317 1
a3317 1
	return iwn_cmd(sc, IWN_PHY_CALIB, &cmd, sizeof cmd, 1);
d3324 1
a3324 1
	struct iwn_phy_calib_cmd cmd;
d3335 1
a3335 1
			/* Limit differential gain to [-3,+3]. */
d3343 1
a3343 1
	return iwn_cmd(sc, IWN_PHY_CALIB, &cmd, sizeof cmd, 1);
d3485 1
a3485 1
			/* previous interval had many false alarms */
d3525 1
a3525 1
	return iwn_cmd(sc, IWN_SENSITIVITY, &cmd, sizeof cmd, 1);
a3589 1
	struct iwn_node_info node;
a3590 1
	uint8_t rate;
d3593 1
a3593 1
	/* Set power-saving level to CAM during initialization. */
a3627 11
#ifndef IEEE80211_STA_ONLY
#ifdef notyet
	case IEEE80211_M_IBSS:
	case IEEE80211_M_AHDEMO:
		sc->rxon.mode = IWN_MODE_IBSS;
		break;
	case IEEE80211_M_HOSTAP:
		sc->rxon.mode = IWN_MODE_HOSTAP;
		break;
#endif
#endif
d3657 1
a3657 7
	/* Add broadcast node. */
	memset(&node, 0, sizeof node);
	IEEE80211_ADDR_COPY(node.macaddr, etherbroadcastaddr);
	node.id = hal->broadcast_id;
	DPRINTF(("adding broadcast node\n"));
	error = hal->add_node(sc, &node, 0);
	if (error != 0) {
a3661 7
	DPRINTF(("setting fixed rate for node %d\n", node.id));
	rate = (ic->ic_curmode == IEEE80211_MODE_11A) ? 12 : 2;
	if ((error = iwn_set_fixed_rate(sc, node.id, rate, 0)) != 0) {
		printf("%s: could not setup MRR for node %d\n",
		    sc->sc_dev.dv_xname, node.id);
		return error;
	}
a3670 4
/*
 * Send a scan request to the firmware.  Since this command is huge, we map
 * it into an mbuf instead of using the pre-allocated set of commands.
 */
a3673 1
	const struct iwn_hal *hal = sc->sc_hal;
d3675 1
a3675 4
	struct iwn_tx_ring *ring = &sc->txq[4];
	struct iwn_tx_desc *desc;
	struct iwn_tx_data *data;
	struct iwn_tx_cmd *cmd;
a3676 1
	struct iwn_scan_hdr *hdr;
d3682 1
a3682 1
	uint8_t *frm;
d3684 2
a3685 1
	int pktlen, error;
d3687 3
a3689 6
	desc = &ring->desc[ring->cur];
	data = &ring->data[ring->cur];

	MGETHDR(data->m, M_DONTWAIT, MT_DATA);
	if (data->m == NULL) {
		printf("%s: could not allocate mbuf for scan command\n",
d3693 1
a3693 17
	MCLGET(data->m, M_DONTWAIT);
	if (!(data->m->m_flags & M_EXT)) {
		m_freem(data->m);
		data->m = NULL;
		printf("%s: could not allocate mbuf for scan command\n",
		    sc->sc_dev.dv_xname);
		return ENOMEM;
	}

	cmd = mtod(data->m, struct iwn_tx_cmd *);
	cmd->code = IWN_CMD_SCAN;
	cmd->flags = 0;
	cmd->qid = ring->qid;
	cmd->idx = ring->cur;

	hdr = (struct iwn_scan_hdr *)cmd->data;
	memset(hdr, 0, sizeof (struct iwn_scan_hdr));
d3695 2
a3696 3
	 * Move to the next channel if no packets are received within 10 msecs
	 * after sending the probe request (this helps to reduce the duration
	 * of active scans).
d3704 3
a3706 2
	if (sc->hw_type == IWN_HW_REV_TYPE_4965) {
		/* Ant A must be avoided because of an HW bug in 5GHz. */
d3709 1
a3709 1
		rxchain |= IWN_RXCHAIN_SEL((1 << sc->nrxchains) - 1);
a3713 1
	memset(tx, 0, sizeof (struct iwn_cmd_data));
d3715 1
a3715 1
	tx->id = hal->broadcast_id;
d3730 3
a3732 1
	tx->rflags |= IWN_RFLAG_ANT_B;
d3735 5
a3739 5
	memset(essid, 0, 20 * sizeof (struct iwn_scan_essid));
	essid[0].id  = IEEE80211_ELEMID_SSID;
	essid[0].len = ic->ic_des_esslen;
	memcpy(essid[0].data, ic->ic_des_essid, ic->ic_des_esslen);

d3744 1
a3744 1
	wh = (struct ieee80211_frame *)&essid[20];
d3755 1
a3755 1
	frm = ieee80211_add_ssid(frm, ic->ic_des_essid, ic->ic_des_esslen);
d3770 6
a3775 6
		chan->type = 0;
		if (!(c->ic_flags & IEEE80211_CHAN_PASSIVE)) {
			chan->type |= IWN_CHAN_ACTIVE;
			if (ic->ic_des_esslen != 0)
				chan->type |= IWN_CHAN_DIRECT;
		}
d3779 1
a3779 1
			chan->active  = htole16(10);
d3783 1
a3783 1
			chan->active  = htole16(20);
d3792 2
a3793 2
	hdr->len = htole16(frm - (uint8_t *)hdr);
	pktlen = frm - (uint8_t *)cmd;
d3795 4
a3798 22
	error = bus_dmamap_load(sc->sc_dmat, data->map, cmd, pktlen, NULL,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map scan command\n",
		    sc->sc_dev.dv_xname);
		m_freem(data->m);
		data->m = NULL;
		return error;
	}

	IWN_SET_DESC_NSEGS(desc, 1);
	IWN_SET_DESC_SEG(desc, 0, data->map->dm_segs[0].ds_addr,
	    data->map->dm_segs[0].ds_len);

	/* Update TX scheduler. */
	hal->update_sched(sc, ring->qid, ring->cur, 0, 0);

	/* Kick command ring. */
	ring->cur = (ring->cur + 1) % IWN_TX_RING_COUNT;
	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, ring->qid << 8 | ring->cur);

	return 0;
a3806 2
	struct iwn_node_info node;
	uint8_t rate;
a3844 1

d3846 2
a3847 2
	 * Reconfiguring clears the adapter's nodes table so we must add
	 * the broadcast node again.
d3849 1
a3849 6
	memset(&node, 0, sizeof node);
	IEEE80211_ADDR_COPY(node.macaddr, etherbroadcastaddr);
	node.id = hal->broadcast_id;
	DPRINTF(("adding broadcast node\n"));
	error = hal->add_node(sc, &node, 1);
	if (error != 0) {
a3853 7
	DPRINTF(("setting fixed rate for node %d\n", node.id));
	rate = (ic->ic_curmode == IEEE80211_MODE_11A) ? 12 : 2;
	if ((error = iwn_set_fixed_rate(sc, node.id, rate, 1)) != 0) {
		printf("%s: could not setup MRR for broadcast node\n",
		    sc->sc_dev.dv_xname, node.id);
		return error;
	}
d3867 1
a3867 1
		/* link LED blinks while monitoring */
d3900 1
d3914 3
a3916 3
	DPRINTF(("setting MRR for node %d\n", node.id));
	if ((error = iwn_setup_node_mrr(sc, ni, node.id)) != 0) {
		printf("%s: could not setup MRR for node %d\n",
d3921 2
a3922 4
	if (ic->ic_opmode == IEEE80211_M_STA) {
		/* Fake a join to initialize the TX rate. */
		iwn_newassoc(ic, ni, 1);
	}
d3940 2
a3941 2
iwn4965_addba(struct iwn_softc *sc, struct ieee80211_node *ni, int qid,
    int tid, int ssn)
d3943 107
a4052 1
	uint32_t tmp;
d4055 1
a4055 1
	/* Enable TID for RA. */
d4058 1
d4062 2
a4063 1
	if ((error = hal->add_node(sc, &node, 1)) != 0)
d4068 23
d4096 1
a4096 1
	/* Assign (RA,TID) translation to the queue. */
d4101 1
a4101 2
	tmp = iwn_prph_read(sc, IWN4965_SCHED_QCHAIN_SEL);
	iwn_prph_write(sc, IWN4965_SCHED_QCHAIN_SEL, tmp | 1 << qid);
d4115 1
a4115 2
	tmp = iwn_prph_read(sc, IWN4965_SCHED_INTR_MASK);
	iwn_prph_write(sc, IWN4965_SCHED_INTR_MASK, tmp | 1 << qid);
d4118 1
a4118 1
	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),
a4120 3

	iwn_nic_unlock(sc);
	return 0;
d4123 2
a4124 2
int
iwn4965_delba(struct iwn_softc *sc, int qid, int tid, int ssn)
d4126 1
a4126 5
	uint32_t tmp;
	int error;

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
d4137 1
a4137 2
	tmp = iwn_prph_read(sc, IWN4965_SCHED_INTR_MASK);
	iwn_prph_write(sc, IWN4965_SCHED_INTR_MASK, tmp & ~(1 << qid));
a4141 3

	iwn_nic_unlock(sc);
	return 0;
d4144 3
a4146 3
int
iwn5000_addba(struct iwn_softc *sc, struct ieee80211_node *ni, int qid,
    int tid, int ssn)
a4147 1
	const struct iwn_hal *hal = sc->sc_hal;
d4149 1
a4149 15
	struct iwn_node_info node;
	uint32_t tmp;
	int error;

	/* Enable TID for RA. */
	wn->disable_tid &= ~(1 << tid);
	memset(&node, 0, sizeof node);
	node.control = IWN_NODE_UPDATE;
	node.flags = IWN_FLAG_SET_DISABLE_TID;
	node.disable_tid = htole16(wn->disable_tid);
	if ((error = hal->add_node(sc, &node, 1)) != 0)
		return error;

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
d4155 1
a4155 1
	/* Assign (RA,TID) translation to the queue. */
d4160 1
a4160 2
	tmp = iwn_prph_read(sc, IWN5000_SCHED_QCHAIN_SEL);
	iwn_prph_write(sc, IWN5000_SCHED_QCHAIN_SEL, tmp | 1 << qid);
d4163 1
a4163 2
	tmp = iwn_prph_read(sc, IWN5000_SCHED_AGGR_SEL);
	iwn_prph_write(sc, IWN5000_SCHED_AGGR_SEL, tmp | 1 << qid);
d4174 1
a4174 2
	tmp = iwn_prph_read(sc, IWN5000_SCHED_INTR_MASK);
	iwn_prph_write(sc, IWN5000_SCHED_INTR_MASK, tmp | 1 << qid);
a4178 3

	iwn_nic_unlock(sc);
	return 0;
d4181 2
a4182 2
int
iwn5000_delba(struct iwn_softc *sc, int qid, int tid, int ssn)
d4184 1
a4184 5
	uint32_t tmp;
	int error;

	if ((error = iwn_nic_lock(sc)) != 0)
		return error;
d4191 1
a4191 2
	tmp = iwn_prph_read(sc, IWN5000_SCHED_AGGR_SEL);
	iwn_prph_write(sc, IWN5000_SCHED_AGGR_SEL, tmp & ~(1 << qid));
d4198 1
a4198 2
	tmp = iwn_prph_read(sc, IWN5000_SCHED_INTR_MASK);
	iwn_prph_write(sc, IWN5000_SCHED_INTR_MASK, tmp & ~(1 << qid));
a4202 3

	iwn_nic_unlock(sc);
	return 0;
d4243 1
a4243 1
		error = iwn_cmd(sc, IWN_PHY_CALIB, sc->calibcmd[idx].buf,
d4256 1
a4256 1
 * readiness (called in a process context).
d4306 1
a4306 1
 * notifies us of its readiness (called in a process context).
d4349 1
a4349 1
		    IWN5000_TXQ_STATUS_ACTIVE | qid2fifo[qid] << 0);
d4353 1
a4353 1
	/* Configure WiMax (IEEE 802.16) coexistence. */
d4355 1
a4355 1
	DPRINTF(("Configuring WiMax coexistence\n"));
d4358 1
a4358 1
		printf("%s: could not configure WiMax coexistence\n",
d4364 1
a4364 1
		struct iwn5000_phy_calib calib;
d4367 4
a4370 4
		memset(&calib, 0, sizeof calib);
		calib.code = IWN5000_PHY_CALIB_CRYSTAL;
		calib.data[0] = letoh32(sc->eeprom_crystal) & 0xff;
		calib.data[1] = (letoh32(sc->eeprom_crystal) >> 16) & 0xff;
d4372 2
a4373 2
		    calib.data[0], calib.data[1]));
		error = iwn_cmd(sc, IWN_PHY_CALIB, &calib, sizeof calib, 0);
d4456 1
a4456 1
	/* Copy initialization images into pre-allocated DMA-safe memory. */
d4461 1
a4461 1
	/* Tell adapter where to find initialization images. */
a4510 3
/*
 * Load a firmware text or data section through Flow Handler DMA.
 */
a4561 1

d4626 1
a4626 1
	/* get pointers to firmware sections */
a4657 1
	uint32_t tmp;
d4674 1
a4674 2
	tmp = iwn_prph_read(sc, IWN_APMG_PCI_STT);
	iwn_prph_write(sc, IWN_APMG_PCI_STT, tmp | IWN_APMG_PCI_STT_L1A_DIS);
a4682 1
	uint32_t tmp;
d4705 1
a4705 2
	tmp = iwn_prph_read(sc, IWN_APMG_PCI_STT);
	iwn_prph_write(sc, IWN_APMG_PCI_STT, tmp | IWN_APMG_PCI_STT_L1A_DIS);
a4779 1
	uint32_t tmp;
d4783 1
a4783 1
	/* Retrieve Active State Power Management (ASPM). */
d4802 1
a4802 2
	tmp = iwn_prph_read(sc, IWN_APMG_PS);
	iwn_prph_write(sc, IWN_APMG_PS, tmp | IWN_APMG_PS_EARLY_PWROFF_DIS);
a4810 1
	uint32_t tmp;
d4825 1
a4825 4
	tmp = iwn_prph_read(sc, IWN_APMG_PS);
	tmp &= ~IWN_APMG_PS_PWR_SRC_MASK;
	tmp |= IWN_APMG_PS_PWR_SRC(IWN_APMG_PS_PWR_SRC_VMAIN);
	iwn_prph_write(sc, IWN_APMG_PS, tmp);
@


1.23
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.22 2008/07/31 20:14:17 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007,2008
d21 2
a22 1
 * Driver for Intel Wireless WiFi Link 4965AGN 802.11 network adapters.
d71 7
a77 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_4965AGN_2 }
d82 1
d86 1
d88 1
d90 7
d100 2
a101 2
int		iwn_alloc_shared(struct iwn_softc *);
void		iwn_free_shared(struct iwn_softc *);
d117 5
d127 1
a127 11
void		iwn_mem_lock(struct iwn_softc *);
void		iwn_mem_unlock(struct iwn_softc *);
uint32_t	iwn_mem_read(struct iwn_softc *, uint32_t);
void		iwn_mem_write(struct iwn_softc *, uint32_t, uint32_t);
void		iwn_mem_write_region_4(struct iwn_softc *, uint32_t,
		    const uint32_t *, int);
int		iwn_eeprom_lock(struct iwn_softc *);
void		iwn_eeprom_unlock(struct iwn_softc *);
int		iwn_read_prom_data(struct iwn_softc *, uint32_t, void *, int);
int		iwn_load_microcode(struct iwn_softc *, const uint8_t *, int);
int		iwn_load_firmware(struct iwn_softc *);
a128 1
void		iwn_iter_func(void *, struct ieee80211_node *);
d130 1
a130 1
void		iwn_rx_intr(struct iwn_softc *, struct iwn_rx_desc *,
d132 2
d135 5
a139 2
void		iwn_tx_intr(struct iwn_softc *, struct iwn_rx_desc *);
void		iwn_cmd_intr(struct iwn_softc *, struct iwn_rx_desc *);
d141 1
d143 5
a147 3
void		iwn_read_eeprom(struct iwn_softc *);
void		iwn_read_eeprom_channels(struct iwn_softc *, int);
void		iwn_print_power_group(struct iwn_softc *, int);
d150 1
a150 1
		    struct ieee80211_node *, int);
d155 4
a161 2
int		iwn_set_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
d165 6
a170 5
void		iwn_enable_tsf(struct iwn_softc *, struct ieee80211_node *);
void		iwn_power_calibration(struct iwn_softc *, int);
int		iwn_set_txpower(struct iwn_softc *,
		    struct ieee80211_channel *, int);
int		iwn_get_rssi(const struct iwn_rx_stat *);
d172 2
a173 1
int		iwn_get_temperature(struct iwn_softc *);
d175 1
a175 1
void		iwn_compute_differential_gain(struct iwn_softc *,
d177 4
d184 3
d189 26
a214 6
int		iwn_scan(struct iwn_softc *, uint16_t);
int		iwn_config(struct iwn_softc *);
void		iwn_post_alive(struct iwn_softc *);
void		iwn_stop_master(struct iwn_softc *);
int		iwn_reset(struct iwn_softc *);
void		iwn_hw_config(struct iwn_softc *);
a217 2
#define IWN_DEBUG

d227 56
d291 1
a291 1
	    sizeof (iwn_devices) / sizeof (iwn_devices[0]));
a293 3
/* Base Address Register */
#define IWN_PCI_BAR0	0x10

d301 1
d304 1
a304 1
	pcireg_t memtype, data;
d311 15
a325 4
	/* clear device specific PCI configuration register 0x41 */
	data = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	data &= ~0x0000ff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, data);
d335 1
a339 1

d352 13
a364 5
	/*
	 * Put adapter into a known state.
	 */
	if ((error = iwn_reset(sc)) != 0) {
		printf(": could not reset adapter\n");
d368 1
a368 3
	/*
	 * Allocate DMA memory for firmware transfers.
	 */
d370 1
a370 1
		printf(": could not allocate firmware memory\n");
d374 1
a374 3
	/*
	 * Allocate a "keep warm" page.
	 */
d380 3
a382 5
	/*
	 * Allocate shared area (communication area).
	 */
	if ((error = iwn_alloc_shared(sc)) != 0) {
		printf(": could not allocate shared area\n");
d386 1
a386 3
	/*
	 * Allocate Rx buffers and Tx/Rx rings.
	 */
d388 1
a388 1
		printf(": could not allocate Rx buffers\n");
d392 2
a393 1
	for (i = 0; i < IWN_NTXQUEUES; i++) {
d395 1
a395 1
			printf(": could not allocate Tx ring %d\n", i);
d400 1
d402 1
a402 1
		printf(": could not allocate Rx ring\n");
d406 9
d419 1
a419 1
	/* set device capabilities */
d421 1
a421 1
	    IEEE80211_C_WEP |		/* s/w WEP */
a423 1
	    IEEE80211_C_TXPMGT |	/* tx power management */
d427 1
a427 4
	/* read supported channels and MAC address from EEPROM */
	iwn_read_eeprom(sc);

	/* set supported .11a, .11b and .11g rates */
d432 1
a432 1
	/* IBSS channel undefined for now */
a447 3
#ifdef notyet
	ic->ic_set_key = iwn_set_key;
#endif
d450 1
a450 1
	/* override state transition machine */
d461 1
d463 1
a463 1

d470 1
a470 1
	/* free allocated memory if something failed during attachment */
d474 1
a474 1
fail3:	iwn_free_shared(sc);
d479 38
d527 1
a527 1
	/* temperature invalid until interface is up */
d535 1
a541 1
#if NBPFILTER > 0
d552 1
a553 1
}
d560 1
a560 1
	pcireg_t data;
d566 4
a569 4
	/* clear device specific PCI configuration register 0x41 */
	data = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	data &= ~0x0000ff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, data);
d582 138
d773 1
a773 1
iwn_alloc_shared(struct iwn_softc *sc)
d775 3
a777 4
	/* must be aligned on a 1KB boundary */
	return iwn_dma_contig_alloc(sc->sc_dmat, &sc->shared_dma,
	    (void **)&sc->shared, sizeof (struct iwn_shared), 1024,
	    BUS_DMA_NOWAIT);
d781 1
a781 1
iwn_free_shared(struct iwn_softc *sc)
d783 1
a783 1
	iwn_dma_contig_free(&sc->shared_dma);
d789 3
a791 3
	/* must be aligned on a 4KB boundary */
	return iwn_dma_contig_alloc(sc->sc_dmat, &sc->kw_dma, NULL,
	    PAGE_SIZE, PAGE_SIZE, BUS_DMA_NOWAIT);
d803 1
a803 1
	/* allocate enough contiguous space to store text and data */
d805 1
a805 2
	    IWN_FW_MAIN_TEXT_MAXSZ + IWN_FW_MAIN_DATA_MAXSZ, 16,
	    BUS_DMA_NOWAIT);
d828 1
a828 1
 * our Rx buffer is attached is freed.
d836 1
a836 1
	/* put the buffer back in the free list */
d846 1
a846 1
	/* allocate a big chunk of DMA'able memory.. */
d848 1
a848 1
	    IWN_RBUF_COUNT * IWN_RBUF_SIZE, PAGE_SIZE, BUS_DMA_NOWAIT);
d850 1
a850 1
		printf("%s: could not allocate Rx buffers DMA memory\n",
d854 1
a854 2

	/* ..and split it into chunks of "rbufsz" bytes */
d859 1
a859 1
		rbuf->sc = sc;	/* backpointer for callbacks */
d877 1
d882 2
d885 11
a895 2
	    (void **)&ring->desc, IWN_RX_RING_COUNT * sizeof (uint32_t),
	    IWN_RING_DMA_ALIGN, BUS_DMA_NOWAIT);
d897 1
a897 1
		printf("%s: could not allocate rx ring DMA memory\n",
d903 1
a903 1
	 * Setup Rx buffers.
d911 1
a911 1
			printf("%s: could not allocate rx mbuf\n",
d919 1
a919 1
			printf("%s: could not allocate rx buffer\n",
d924 1
a924 1
		/* attach Rx buffer to mbuf */
d928 1
a928 1
		/* Rx buffers are aligned on a 256-byte boundary */
a930 1

d942 9
a950 7
	iwn_mem_lock(sc);

	IWN_WRITE(sc, IWN_RX_CONFIG, 0);
	for (ntries = 0; ntries < 100; ntries++) {
		if (IWN_READ(sc, IWN_RX_STATUS) & IWN_RX_IDLE)
			break;
		DELAY(10);
a951 6
#ifdef IWN_DEBUG
	if (ntries == 100 && iwn_debug > 0)
		printf("%s: timeout resetting Rx ring\n", sc->sc_dev.dv_xname);
#endif
	iwn_mem_unlock(sc);

d953 1
d962 1
d973 1
d981 1
d984 1
a984 1
	    (void **)&ring->desc, size, IWN_RING_DMA_ALIGN, BUS_DMA_NOWAIT);
d986 1
a986 1
		printf("%s: could not allocate tx ring DMA memory\n",
d990 7
d1002 1
a1002 1
		printf("%s: could not allocate tx cmd DMA memory\n",
d1007 1
d1011 4
d1019 1
a1019 1
			printf("%s: could not create tx buf DMA map\n",
a1023 1

d1036 10
a1045 8
	iwn_mem_lock(sc);

	IWN_WRITE(sc, IWN_TX_CONFIG(ring->qid), 0);
	for (ntries = 0; ntries < 100; ntries++) {
		tmp = IWN_READ(sc, IWN_TX_STATUS);
		if ((tmp & IWN_TX_IDLE(ring->qid)) == IWN_TX_IDLE(ring->qid))
			break;
		DELAY(10);
a1046 8
#ifdef IWN_DEBUG
	if (ntries == 100 && iwn_debug > 1) {
		printf("%s: timeout resetting Tx ring %d\n",
		    sc->sc_dev.dv_xname, ring->qid);
	}
#endif
	iwn_mem_unlock(sc);

d1056 3
a1058 1

d1078 2
d1083 2
a1084 2
struct ieee80211_node *
iwn_node_alloc(struct ieee80211com *ic)
d1086 27
a1112 1
	return malloc(sizeof (struct iwn_node), M_DEVBUF, M_NOWAIT | M_ZERO);
d1116 1
a1116 1
iwn_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
d1118 2
a1119 1
	struct iwn_softc *sc = ic->ic_if.if_softc;
d1122 8
a1129 1
	ieee80211_amrr_node_init(&sc->amrr, &((struct iwn_node *)ni)->amn);
d1131 10
a1140 6
	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;
}
d1142 3
a1144 4
int
iwn_media_change(struct ifnet *ifp)
{
	int error;
d1146 4
a1149 3
	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;
d1151 5
a1155 4
	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
	    (IFF_UP | IFF_RUNNING)) {
		iwn_stop(ifp, 0);
		iwn_init(ifp);
d1157 1
a1157 1
	return 0;
d1160 3
a1162 2
int
iwn_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
d1164 3
a1166 3
	struct ifnet *ifp = &ic->ic_if;
	struct iwn_softc *sc = ifp->if_softc;
	int error;
d1168 11
a1178 11
	timeout_del(&sc->calib_to);

	switch (nstate) {
	case IEEE80211_S_SCAN:
		/* make the link LED blink while we're scanning */
		iwn_set_led(sc, IWN_LED_LINK, 20, 2);

		if ((error = iwn_scan(sc, IEEE80211_CHAN_G)) != 0) {
			printf("%s: could not initiate scan\n",
			    sc->sc_dev.dv_xname);
			return error;
d1180 10
a1189 17
		ic->ic_state = nstate;
		return 0;

	case IEEE80211_S_ASSOC:
		if (ic->ic_state != IEEE80211_S_RUN)
			break;
		/* FALLTHROUGH */
	case IEEE80211_S_AUTH:
		/* reset state to handle reassociations correctly */
		sc->config.associd = 0;
		sc->config.filter &= ~htole32(IWN_FILTER_BSS);
		sc->calib.state = IWN_CALIB_STATE_INIT;

		if ((error = iwn_auth(sc)) != 0) {
			printf("%s: could not move to auth state\n",
			    sc->sc_dev.dv_xname);
			return error;
a1190 13
		break;

	case IEEE80211_S_RUN:
		if ((error = iwn_run(sc)) != 0) {
			printf("%s: could not move to run state\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
		break;

	case IEEE80211_S_INIT:
		sc->calib.state = IWN_CALIB_STATE_INIT;
		break;
a1191 2

	return sc->sc_newstate(ic, nstate, arg);
d1193 1
a1194 3
/*
 * Grab exclusive access to NIC memory.
 */
d1196 1
a1196 1
iwn_mem_lock(struct iwn_softc *sc)
d1198 3
a1200 2
	uint32_t tmp;
	int ntries;
d1202 5
a1206 2
	tmp = IWN_READ(sc, IWN_GPIO_CTL);
	IWN_WRITE(sc, IWN_GPIO_CTL, tmp | IWN_GPIO_MAC);
d1208 4
a1211 6
	/* spin until we actually get the lock */
	for (ntries = 0; ntries < 1000; ntries++) {
		if ((IWN_READ(sc, IWN_GPIO_CTL) &
		    (IWN_GPIO_CLOCK | IWN_GPIO_SLEEP)) == IWN_GPIO_CLOCK)
			break;
		DELAY(10);
d1213 7
a1219 2
	if (ntries == 1000)
		printf("%s: could not lock memory\n", sc->sc_dev.dv_xname);
a1221 3
/*
 * Release lock on NIC memory.
 */
d1223 1
a1223 1
iwn_mem_unlock(struct iwn_softc *sc)
d1225 14
a1238 3
	uint32_t tmp = IWN_READ(sc, IWN_GPIO_CTL);
	IWN_WRITE(sc, IWN_GPIO_CTL, tmp & ~IWN_GPIO_MAC);
}
d1240 6
a1245 6
uint32_t
iwn_mem_read(struct iwn_softc *sc, uint32_t addr)
{
	IWN_WRITE(sc, IWN_READ_MEM_ADDR, IWN_MEM_4 | addr);
	return IWN_READ(sc, IWN_READ_MEM_DATA);
}
d1247 9
a1255 6
void
iwn_mem_write(struct iwn_softc *sc, uint32_t addr, uint32_t data)
{
	IWN_WRITE(sc, IWN_WRITE_MEM_ADDR, IWN_MEM_4 | addr);
	IWN_WRITE(sc, IWN_WRITE_MEM_DATA, data);
}
d1257 6
a1262 7
void
iwn_mem_write_region_4(struct iwn_softc *sc, uint32_t addr,
    const uint32_t *data, int wlen)
{
	for (; wlen > 0; wlen--, data++, addr += 4)
		iwn_mem_write(sc, addr, *data);
}
d1264 5
a1268 5
int
iwn_eeprom_lock(struct iwn_softc *sc)
{
	uint32_t tmp;
	int ntries;
d1270 2
a1271 2
	tmp = IWN_READ(sc, IWN_HWCONFIG);
	IWN_WRITE(sc, IWN_HWCONFIG, tmp | IWN_HW_EEPROM_LOCKED);
d1273 2
a1274 5
	/* spin until we actually get the lock */
	for (ntries = 0; ntries < 100; ntries++) {
		if (IWN_READ(sc, IWN_HWCONFIG) & IWN_HW_EEPROM_LOCKED)
			return 0;
		DELAY(10);
a1275 1
	return ETIMEDOUT;
d1278 2
a1279 2
void
iwn_eeprom_unlock(struct iwn_softc *sc)
d1281 1
a1281 2
	uint32_t tmp = IWN_READ(sc, IWN_HWCONFIG);
	IWN_WRITE(sc, IWN_HWCONFIG, tmp & ~IWN_HW_EEPROM_LOCKED);
d1284 2
a1285 6
/*
 * Read `len' bytes from the EEPROM.  We access the EEPROM through the MAC
 * instead of using the traditional bit-bang method.
 */
int
iwn_read_prom_data(struct iwn_softc *sc, uint32_t addr, void *data, int len)
d1287 2
a1288 3
	uint8_t *out = data;
	uint32_t val;
	int ntries;
d1290 1
a1290 5
	iwn_mem_lock(sc);
	for (; len > 0; len -= 2, addr++) {
		IWN_WRITE(sc, IWN_EEPROM_CTL, addr << 2);
		IWN_WRITE(sc, IWN_EEPROM_CTL,
		    IWN_READ(sc, IWN_EEPROM_CTL) & ~IWN_EEPROM_CMD);
d1292 5
a1296 18
		for (ntries = 0; ntries < 10; ntries++) {
			if ((val = IWN_READ(sc, IWN_EEPROM_CTL)) &
			    IWN_EEPROM_READY)
				break;
			DELAY(5);
		}
		if (ntries == 10) {
			printf("%s: could not read EEPROM\n",
			    sc->sc_dev.dv_xname);
			return ETIMEDOUT;
		}
		*out++ = val >> 16;
		if (len > 1)
			*out++ = val >> 24;
	}
	iwn_mem_unlock(sc);

	return 0;
a1298 4
/*
 * The firmware boot code is small and is intended to be copied directly into
 * the NIC internal memory.
 */
d1300 1
a1300 1
iwn_load_microcode(struct iwn_softc *sc, const uint8_t *ucode, int size)
d1302 1
a1302 1
	int ntries;
d1304 3
a1306 1
	size /= sizeof (uint32_t);
d1308 4
a1311 18
	iwn_mem_lock(sc);

	/* copy microcode image into NIC memory */
	iwn_mem_write_region_4(sc, IWN_MEM_UCODE_BASE,
	    (const uint32_t *)ucode, size);

	iwn_mem_write(sc, IWN_MEM_UCODE_SRC, 0);
	iwn_mem_write(sc, IWN_MEM_UCODE_DST, IWN_FW_TEXT);
	iwn_mem_write(sc, IWN_MEM_UCODE_SIZE, size);

	/* run microcode */
	iwn_mem_write(sc, IWN_MEM_UCODE_CTL, IWN_UC_RUN);

	/* wait for transfer to complete */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (!(iwn_mem_read(sc, IWN_MEM_UCODE_CTL) & IWN_UC_RUN))
			break;
		DELAY(10);
a1312 10
	if (ntries == 1000) {
		iwn_mem_unlock(sc);
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}
	iwn_mem_write(sc, IWN_MEM_UCODE_CTL, IWN_UC_ENABLE);

	iwn_mem_unlock(sc);

d1317 1
a1317 1
iwn_load_firmware(struct iwn_softc *sc)
d1319 2
a1320 8
	struct iwn_dma_info *dma = &sc->fw_dma;
	const struct iwn_firmware_hdr *hdr;
	const uint8_t *init_text, *init_data, *main_text, *main_data;
	const uint8_t *boot_text;
	uint32_t init_textsz, init_datasz, main_textsz, main_datasz;
	uint32_t boot_textsz;
	u_char *fw;
	size_t size;
d1323 1
a1323 6
	/* load firmware image from disk */
	if ((error = loadfirmware("iwn-4965agn", &fw, &size)) != 0) {
		printf("%s: error, %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, "iwn-4965agn");
		goto fail1;
	}
d1325 4
a1328 25
	/* extract firmware header information */
	if (size < sizeof (struct iwn_firmware_hdr)) {
		printf("%s: truncated firmware header: %d bytes\n",
		    sc->sc_dev.dv_xname, size);
		error = EINVAL;
		goto fail2;
	}
	hdr = (const struct iwn_firmware_hdr *)fw;
	main_textsz = letoh32(hdr->main_textsz);
	main_datasz = letoh32(hdr->main_datasz);
	init_textsz = letoh32(hdr->init_textsz);
	init_datasz = letoh32(hdr->init_datasz);
	boot_textsz = letoh32(hdr->boot_textsz);

	/* sanity-check firmware segments sizes */
	if (main_textsz > IWN_FW_MAIN_TEXT_MAXSZ ||
	    main_datasz > IWN_FW_MAIN_DATA_MAXSZ ||
	    init_textsz > IWN_FW_INIT_TEXT_MAXSZ ||
	    init_datasz > IWN_FW_INIT_DATA_MAXSZ ||
	    boot_textsz > IWN_FW_BOOT_TEXT_MAXSZ ||
	    (boot_textsz & 3) != 0) {
		printf("%s: invalid firmware header\n", sc->sc_dev.dv_xname);
		error = EINVAL;
		goto fail2;
	}
d1330 7
a1336 8
	/* check that all firmware segments are present */
	if (size < sizeof (struct iwn_firmware_hdr) + main_textsz +
	    main_datasz + init_textsz + init_datasz + boot_textsz) {
		printf("%s: firmware file too short: %d bytes\n",
		    sc->sc_dev.dv_xname, size);
		error = EINVAL;
		goto fail2;
	}
d1338 9
a1346 19
	/* get pointers to firmware segments */
	main_text = (const uint8_t *)(hdr + 1);
	main_data = main_text + main_textsz;
	init_text = main_data + main_datasz;
	init_data = init_text + init_textsz;
	boot_text = init_data + init_datasz;

	/* copy initialization images into pre-allocated DMA-safe memory */
	memcpy(dma->vaddr, init_data, init_datasz);
	memcpy(dma->vaddr + IWN_FW_INIT_DATA_MAXSZ, init_text, init_textsz);

	/* tell adapter where to find initialization images */
	iwn_mem_lock(sc);
	iwn_mem_write(sc, IWN_MEM_DATA_BASE, dma->paddr >> 4);
	iwn_mem_write(sc, IWN_MEM_DATA_SIZE, init_datasz);
	iwn_mem_write(sc, IWN_MEM_TEXT_BASE,
	    (dma->paddr + IWN_FW_INIT_DATA_MAXSZ) >> 4);
	iwn_mem_write(sc, IWN_MEM_TEXT_SIZE, init_textsz);
	iwn_mem_unlock(sc);
d1348 6
a1353 6
	/* load firmware boot code */
	if ((error = iwn_load_microcode(sc, boot_text, boot_textsz)) != 0) {
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}
d1355 7
a1361 2
	/* now press "execute" ;-) */
	IWN_WRITE(sc, IWN_RESET, 0);
d1363 3
a1365 6
	/* wait at most one second for first alive notification */
	if ((error = tsleep(sc, PCATCH, "iwninit", hz)) != 0) {
		/* this isn't what was supposed to happen.. */
		printf("%s: timeout waiting for adapter to initialize\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
d1368 2
a1369 12
	/* copy runtime images into pre-allocated DMA-safe memory */
	memcpy(dma->vaddr, main_data, main_datasz);
	memcpy(dma->vaddr + IWN_FW_MAIN_DATA_MAXSZ, main_text, main_textsz);

	/* tell adapter where to find runtime images */
	iwn_mem_lock(sc);
	iwn_mem_write(sc, IWN_MEM_DATA_BASE, dma->paddr >> 4);
	iwn_mem_write(sc, IWN_MEM_DATA_SIZE, main_datasz);
	iwn_mem_write(sc, IWN_MEM_TEXT_BASE,
	    (dma->paddr + IWN_FW_MAIN_DATA_MAXSZ) >> 4);
	iwn_mem_write(sc, IWN_MEM_TEXT_SIZE, IWN_FW_UPDATED | main_textsz);
	iwn_mem_unlock(sc);
d1371 5
a1375 6
	/* wait at most one second for second alive notification */
	if ((error = tsleep(sc, PCATCH, "iwninit", hz)) != 0) {
		/* this isn't what was supposed to happen.. */
		printf("%s: timeout waiting for adapter to initialize\n",
		    sc->sc_dev.dv_xname);
	}
d1377 1
a1377 2
fail2:	free(fw, M_DEVBUF);
fail1:	return error;
a1386 1
	/* automatic rate control triggered every 500ms */
d1395 3
a1398 2
	/* automatic calibration every 60s */
	if (++sc->calib_cnt >= 120) {
d1400 2
a1401 1
		(void)iwn_cmd(sc, IWN_CMD_GET_STATISTICS, NULL, 0, 1);
d1404 1
a1404 1

d1408 4
a1411 9
void
iwn_iter_func(void *arg, struct ieee80211_node *ni)
{
	struct iwn_softc *sc = arg;
	struct iwn_node *wn = (struct iwn_node *)ni;

	ieee80211_amrr_choose(&sc->amrr, ni, &wn->amn);
}

d1418 1
a1418 1
	/* save Rx statistics, they will be used on IWN_AMPDU_RX_DONE */
d1424 4
d1429 1
a1429 1
iwn_rx_intr(struct iwn_softc *sc, struct iwn_rx_desc *desc,
d1432 1
d1447 1
a1447 1
		/* check for prior AMPDU_RX_START */
d1459 1
a1459 1
		printf("%s: invalid rx statistic header\n",
d1474 1
a1474 1
	/* discard Rx frames with bad CRC early */
d1477 1
a1477 1
		DPRINTFN(2, ("rx flags error %x\n", letoh32(*tail)));
d1481 1
a1481 1
	/* XXX for ieee80211_find_rxnode() */
d1491 1
a1491 1
	/* finalize mbuf */
d1503 1
a1503 2

		/* attach Rx buffer to mbuf */
d1510 1
a1510 1
		/* update Rx descriptor */
d1513 1
a1513 1
		/* no free rbufs, copy frame */
d1516 1
a1516 1
			/* no free mbufs either, drop frame */
d1523 1
a1523 1
	rssi = iwn_get_rssi(stat);
d1539 1
a1539 1
		/* CCK rates */
d1544 1
a1544 1
		/* OFDM rates */
d1553 1
a1553 1
		/* unknown rate: should not happen */
d1567 1
a1567 1
	/* grab a reference to the source node */
d1571 1
a1571 1
	/* send the frame to the 802.11 layer */
d1577 1
a1577 1
	/* node is no longer needed */
d1581 52
d1636 1
d1640 1
d1642 1
a1642 1
	/* ignore beacon statistics received during a scan */
d1647 1
a1647 1
	sc->calib_cnt = 0;	/* reset timeout */
d1649 1
a1649 1
	/* test if temperature has changed */
d1651 1
a1651 2
		int temp;

d1653 2
a1654 2
		temp = iwn_get_temperature(sc);
		DPRINTFN(2, ("temperature=%d\n", temp));
d1656 1
a1656 1
		/* update temperature sensor */
d1658 1
d1660 3
a1662 2
		/* update Tx power if need be */
		iwn_power_calibration(sc, temp);
d1666 1
a1666 1
		return;	/* reply to a statistics request */
a1668 1
	DPRINTFN(3, ("noise=%d\n", sc->noise));
d1670 1
a1670 1
	/* test that RSSI and noise are present in stats report */
d1677 1
a1677 1
		iwn_compute_differential_gain(sc, &stats->rx.general);
d1682 4
d1687 23
a1709 1
iwn_tx_intr(struct iwn_softc *sc, struct iwn_rx_desc *desc)
a1714 1
	struct iwn_tx_stat *stat = (struct iwn_tx_stat *)(desc + 1);
a1715 1
	uint32_t status;
d1717 1
a1717 8
	DPRINTFN(4, ("tx done: qid=%d idx=%d retries=%d nkill=%d rate=%x "
	    "duration=%d status=%x\n", desc->qid, desc->idx, stat->ntries,
	    stat->nkill, stat->rate, letoh16(stat->duration),
	    letoh32(stat->status)));

	/*
	 * Update rate control statistics for the node.
	 */
d1719 1
a1719 2
	if (stat->ntries > 0) {
		DPRINTFN(3, ("tx intr ntries %d\n", stat->ntries));
a1720 1
	}
a1721 1
	status = letoh32(stat->status) & 0xff;
d1727 1
a1733 2
	ring->queued--;

d1735 6
a1740 2
	ifp->if_flags &= ~IFF_OACTIVE;
	(*ifp->if_start)(ifp);
d1743 4
d1748 1
a1748 1
iwn_cmd_intr(struct iwn_softc *sc, struct iwn_rx_desc *desc)
d1754 1
a1754 1
		return;	/* not a command ack */
d1758 1
a1758 1
	/* if the command was mapped in a mbuf, free it */
d1764 1
a1764 2

	wakeup(&ring->cmd[desc->idx]);
d1767 3
d1777 1
a1777 1
	hw = letoh16(sc->shared->closed_count);
d1782 2
a1783 3
		DPRINTFN(4,("rx notification qid=%x idx=%d flags=%x type=%d "
		    "len=%d\n", desc->qid, desc->idx, desc->flags, desc->type,
		    letoh16(desc->len)));
d1785 2
a1786 2
		if (!(desc->qid & 0x80))	/* reply to a command */
			iwn_cmd_intr(sc, desc);
d1789 2
a1790 3
		case IWN_RX_DONE:
		case IWN_AMPDU_RX_DONE:
			iwn_rx_intr(sc, desc, data);
d1793 4
a1796 2
		case IWN_AMPDU_RX_START:
			iwn_ampdu_rx_start(sc, desc);
d1800 2
a1801 2
			/* a 802.11 frame has been transmitted */
			iwn_tx_intr(sc, desc);
d1817 1
a1817 1
			DPRINTFN(2, ("beacons missed %d/%d\n",
d1829 1
a1829 1
			/* the microcontroller is ready */
d1840 1
a1840 1
				/* save microcontroller's report */
d1849 1
a1849 1
			/* enabled/disabled notification */
d1853 1
a1853 1
				/* the radio button has to be pushed */
d1856 1
a1856 1
				/* turn the interface down */
d1859 1
a1859 1
				return;	/* no further processing */
d1871 1
a1871 1
			/* fix current channel */
d1883 2
a1884 1
			if (scan->status == 1 && scan->chan <= 14) {
d1886 2
a1887 2
				 * We just finished scanning 802.11g channels,
				 * start scanning 802.11a ones.
d1889 1
a1889 1
				if (iwn_scan(sc, IEEE80211_CHAN_A) == 0)
d1895 7
d1907 1
a1907 1
	/* tell the firmware what we have processed */
d1909 20
a1928 1
	IWN_WRITE(sc, IWN_RX_WIDX, hw & ~7);
d1938 1
a1938 1
	/* disable interrupts */
d1941 2
a1942 2
	r1 = IWN_READ(sc, IWN_INTR);
	r2 = IWN_READ(sc, IWN_INTR_STATUS);
d1946 2
a1947 2
			IWN_WRITE(sc, IWN_MASK, IWN_INTR_MASK);
		return 0;	/* not for us */
d1949 2
d1952 3
a1954 2
	if (r1 == 0xffffffff)
		return 0;	/* hardware gone */
d1956 2
a1957 8
	/* ack interrupts */
	IWN_WRITE(sc, IWN_INTR, r1);
	IWN_WRITE(sc, IWN_INTR_STATUS, r2);

	DPRINTFN(6, ("interrupt reg1=%x reg2=%x\n", r1, r2));

	if (r1 & IWN_RF_TOGGLED) {
		uint32_t tmp = IWN_READ(sc, IWN_GPIO_CTL);
d1959 1
a1959 1
		    (tmp & IWN_GPIO_RF_ENABLED) ? "enabled" : "disabled");
d1961 1
a1961 1
	if (r1 & IWN_CT_REACHED) {
d1964 1
d1966 1
a1966 1
	if (r1 & (IWN_SW_ERROR | IWN_HW_ERROR)) {
d1972 2
a1973 2
	if ((r1 & (IWN_RX_INTR | IWN_SW_RX_INTR)) ||
	    (r2 & IWN_RX_STATUS_INTR))
d1976 5
a1980 2
	if (r1 & IWN_ALIVE_INTR)
		wakeup(sc);
d1982 4
a1985 1
	/* re-enable interrupts */
d1987 1
a1987 1
		IWN_WRITE(sc, IWN_MASK, IWN_INTR_MASK);
d1992 36
d2032 1
a2032 1
	/* CCK rates (returned values are device-dependent) */
d2038 1
a2038 1
	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
d2050 1
a2050 1
	/* unknown rate (should not get there) */
d2054 1
a2054 1
/* determine if a given rate is CCK or OFDM */
d2058 1
a2058 2
iwn_tx_data(struct iwn_softc *sc, struct mbuf *m0, struct ieee80211_node *ni,
    int ac)
d2060 1
d2062 1
a2062 1
	struct iwn_tx_ring *ring = &sc->txq[ac];
d2069 1
a2070 1
	bus_addr_t paddr;
d2072 2
a2073 1
	uint8_t type;
d2075 1
a2075 4
	int i, rate, error, pad;

	desc = &ring->desc[ring->cur];
	data = &ring->data[ring->cur];
d2081 15
a2095 1
	/* pickup a rate */
a2097 1
		/* mgmt/multicast frames are sent at the lowest avail. rate */
d2116 2
a2117 1
		if (wh->i_fc[1] & IEEE80211_FC1_WEP)
d2130 12
d2149 1
a2149 1
	/* no need to bzero tx, all fields are reinitialized here */
d2151 12
a2162 2
	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);
d2164 2
a2165 2
		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOBUFS;
d2167 1
a2167 14
		wh = mtod(m0, struct ieee80211_frame *);
	}

	flags = IWN_TX_AUTO_SEQ;
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1))
		flags |= IWN_TX_NEED_ACK;

	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    type != IEEE80211_FC0_TYPE_DATA)
		tx->id = IWN_ID_BROADCAST;
	else
		tx->id = IWN_ID_BSS;

	/* check if RTS/CTS or CTS-to-self protection must be used */
d2169 1
a2169 1
		/* multicast frames are not sent at OFDM rates in 802.11b/g */
d2172 1
a2172 1
			flags |= IWN_TX_NEED_RTS | IWN_TX_FULL_TXOP;
d2176 1
a2176 1
				flags |= IWN_TX_NEED_CTS | IWN_TX_FULL_TXOP;
d2178 9
a2186 1
				flags |= IWN_TX_NEED_RTS | IWN_TX_FULL_TXOP;
d2190 6
d2199 2
a2200 1
		/* tell h/w to set timestamp in probe responses */
d2203 1
a2203 1

d2213 1
a2213 1
		/* first segment's length must be a multiple of 4 */
d2221 1
a2221 1
	tx->rate = iwn_plcp_signal(rate);
d2225 6
a2230 4

	/* XXX alternate between Ant A and Ant B ? */
	tx->rflags = IWN_RFLAG_ANT_B;
	if (tx->id == IWN_ID_BROADCAST) {
d2232 2
a2233 2
		if (!IWN_RATE_IS_OFDM(rate))
			tx->rflags |= IWN_RFLAG_CCK;
d2236 1
a2236 1
		/* tell adapter to ignore rflags */
d2239 2
d2242 1
a2242 1
	/* copy and trim IEEE802.11 header */
d2255 1
a2255 1
		/* too many fragments, linearize */
a2270 1

d2292 1
a2292 6
	paddr = ring->cmd_dma.paddr + ring->cur * sizeof (struct iwn_tx_cmd);
	tx->loaddr = htole32(paddr + 4 +
	    offsetof(struct iwn_cmd_data, ntries));
	tx->hiaddr = 0;	/* limit to 32-bit physical addresses */

	/* first scatter/gather segment is used by the tx data command */
d2294 4
a2297 1
	IWN_SET_DESC_SEG(desc, 0, paddr, 4 + sizeof (*tx) + hdrlen + pad);
a2301 7
	sc->shared->len[ring->qid][ring->cur] =
	    htole16(hdrlen + m0->m_pkthdr.len + 8);
	if (ring->cur < IWN_TX_WINDOW) {
		sc->shared->len[ring->qid][ring->cur + IWN_TX_RING_COUNT] =
		    htole16(hdrlen + m0->m_pkthdr.len + 8);
	}
	ring->queued++;
d2303 5
a2307 1
	/* kick Tx ring */
d2309 1
a2309 1
	IWN_WRITE(sc, IWN_TX_WIDX, ring->qid << 8 | ring->cur);
d2311 5
d2337 1
a2337 3
			/* management frames go into ring 0 */
			if (sc->txq[0].queued >= IWN_TX_RING_COUNT - 8) {
				ifp->if_flags |= IFF_OACTIVE;
a2338 1
			}
d2347 1
a2347 1
			if (iwn_tx_data(sc, m0, ni, 0) != 0)
d2356 1
a2356 3
			if (sc->txq[0].queued >= IWN_TX_RING_COUNT - 8) {
				/* there is no place left in this ring */
				ifp->if_flags |= IFF_OACTIVE;
a2357 1
			}
d2370 1
a2370 1
			if (iwn_tx_data(sc, m0, ni, 0) != 0) {
d2427 1
a2427 1
				iwn_init(ifp);
d2450 1
d2454 1
a2454 1
			iwn_init(ifp);
a2455 1
		error = 0;
a2461 140
void
iwn_read_eeprom(struct iwn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	char domain[4];
	uint16_t val;
	int i, error;

	if ((error = iwn_eeprom_lock(sc)) != 0) {
		printf("%s: could not lock EEPROM (error=%d)\n",
		    sc->sc_dev.dv_xname, error);
		return;
	}
	/* read and print regulatory domain */
	iwn_read_prom_data(sc, IWN_EEPROM_DOMAIN, domain, 4);
	printf(", %.4s", domain);

	/* read and print MAC address */
	iwn_read_prom_data(sc, IWN_EEPROM_MAC, ic->ic_myaddr, 6);
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	/* read the list of authorized channels */
	for (i = 0; i < IWN_CHAN_BANDS_COUNT; i++)
		iwn_read_eeprom_channels(sc, i);

	/* read maximum allowed Tx power for 2GHz and 5GHz bands */
	iwn_read_prom_data(sc, IWN_EEPROM_MAXPOW, &val, 2);
	sc->maxpwr2GHz = val & 0xff;
	sc->maxpwr5GHz = val >> 8;
	/* check that EEPROM values are correct */
	if (sc->maxpwr5GHz < 20 || sc->maxpwr5GHz > 50)
		sc->maxpwr5GHz = 38;
	if (sc->maxpwr2GHz < 20 || sc->maxpwr2GHz > 50)
		sc->maxpwr2GHz = 38;
	DPRINTF(("maxpwr 2GHz=%d 5GHz=%d\n", sc->maxpwr2GHz, sc->maxpwr5GHz));

	/* read voltage at which samples were taken */
	iwn_read_prom_data(sc, IWN_EEPROM_VOLTAGE, &val, 2);
	sc->eeprom_voltage = (int16_t)letoh16(val);
	DPRINTF(("voltage=%d (in 0.3V)\n", sc->eeprom_voltage));

	/* read power groups */
	iwn_read_prom_data(sc, IWN_EEPROM_BANDS, sc->bands, sizeof sc->bands);
#ifdef IWN_DEBUG
	if (iwn_debug > 0) {
		for (i = 0; i < IWN_NBANDS; i++)
			iwn_print_power_group(sc, i);
	}
#endif
	iwn_eeprom_unlock(sc);
}

void
iwn_read_eeprom_channels(struct iwn_softc *sc, int n)
{
	struct ieee80211com *ic = &sc->sc_ic;
	const struct iwn_chan_band *band = &iwn_bands[n];
	struct iwn_eeprom_chan channels[IWN_MAX_CHAN_PER_BAND];
	int chan, i;

	iwn_read_prom_data(sc, band->addr, channels,
	    band->nchan * sizeof (struct iwn_eeprom_chan));

	for (i = 0; i < band->nchan; i++) {
		if (!(channels[i].flags & IWN_EEPROM_CHAN_VALID))
			continue;

		chan = band->chan[i];

		if (n == 0) {	/* 2GHz band */
			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_2GHZ);
			ic->ic_channels[chan].ic_flags =
			    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
			    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;

		} else {	/* 5GHz band */
			/*
			 * Some adapters support channels 7, 8, 11 and 12
			 * both in the 2GHz *and* 5GHz bands.
			 * Because of limitations in our net80211(9) stack,
			 * we can't support these channels in 5GHz band.
			 */
			if (chan <= 14)
				continue;

			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[chan].ic_flags = IEEE80211_CHAN_A;
		}

		/* is active scan allowed on this channel? */
		if (!(channels[i].flags & IWN_EEPROM_CHAN_ACTIVE)) {
			ic->ic_channels[chan].ic_flags |=
			    IEEE80211_CHAN_PASSIVE;
		}

		/* save maximum allowed power for this channel */
		sc->maxpwr[chan] = channels[i].maxpwr;

		DPRINTF(("adding chan %d flags=0x%x maxpwr=%d\n",
		    chan, channels[i].flags, sc->maxpwr[chan]));
	}
}

#ifdef IWN_DEBUG
void
iwn_print_power_group(struct iwn_softc *sc, int i)
{
	struct iwn_eeprom_band *band = &sc->bands[i];
	struct iwn_eeprom_chan_samples *chans = band->chans;
	int j, c;

	printf("===band %d===\n", i);
	printf("chan lo=%d, chan hi=%d\n", band->lo, band->hi);
	printf("chan1 num=%d\n", chans[0].num);
	for (c = 0; c < IWN_NTXCHAINS; c++) {
		for (j = 0; j < IWN_NSAMPLES; j++) {
			printf("chain %d, sample %d: temp=%d gain=%d "
			    "power=%d pa_det=%d\n", c, j,
			    chans[0].samples[c][j].temp,
			    chans[0].samples[c][j].gain,
			    chans[0].samples[c][j].power,
			    chans[0].samples[c][j].pa_det);
		}
	}
	printf("chan2 num=%d\n", chans[1].num);
	for (c = 0; c < IWN_NTXCHAINS; c++) {
		for (j = 0; j < IWN_NSAMPLES; j++) {
			printf("chain %d, sample %d: temp=%d gain=%d "
			    "power=%d pa_det=%d\n", c, j,
			    chans[1].samples[c][j].temp,
			    chans[1].samples[c][j].gain,
			    chans[1].samples[c][j].power,
			    chans[1].samples[c][j].pa_det);
		}
	}
}
#endif

d2468 1
d2471 1
d2473 1
d2475 1
d2477 3
a2479 1
	KASSERT(size <= sizeof cmd->data);
d2481 27
a2507 2
	desc = &ring->desc[ring->cur];
	cmd = &ring->cmd[ring->cur];
d2515 2
a2516 1
	paddr = ring->cmd_dma.paddr + ring->cur * sizeof (struct iwn_tx_cmd);
d2518 2
a2519 7
	IWN_SET_DESC_NSEGS(desc, 1);
	IWN_SET_DESC_SEG(desc, 0, paddr, 4 + size);
	sc->shared->len[ring->qid][ring->cur] = htole16(8);
	if (ring->cur < IWN_TX_WINDOW) {
		sc->shared->len[ring->qid][ring->cur + IWN_TX_RING_COUNT] =
		    htole16(8);
	}
d2521 1
a2521 1
	/* kick cmd ring */
d2523 9
a2531 1
	IWN_WRITE(sc, IWN_TX_WIDX, ring->qid << 8 | ring->cur);
d2533 16
a2548 1
	return async ? 0 : tsleep(cmd, PCATCH, "iwncmd", hz);
d2567 1
d2569 1
a2569 1
	mrr.ampdu_limit = 4000;
d2574 1
a2574 1
		DPRINTF(("retry #%d: rate %d\n", i, rate));
d2580 2
a2581 1
	/* pad with the lowest available bit-rate */
d2583 1
a2583 2
		rate = rs->rs_rates[0] & IEEE80211_RATE_VAL;
		DPRINTF(("retry #%d: rate %d\n", i, rate));
d2602 1
d2604 1
a2604 1
	mrr.ampdu_limit = 4000;
d2606 1
a2606 1
	/* to setup a fixed rate, make all retries use the same rate.. */
a2617 32
/*
 * Install a pairwise key into the hardware.
 */
int
iwn_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct iwn_softc *sc = ic->ic_softc;
	struct iwn_node_info node;

	if (k->k_flags & IEEE80211_KEY_GROUP)
		return 0;

	memset(&node, 0, sizeof node);

	switch (k->k_cipher) {
	case IEEE80211_CIPHER_CCMP:
		node.security = htole16(IWN_CIPHER_CCMP);
		memcpy(node.key, k->k_key, k->k_len);
		break;
	default:
		return 0;
	}

	node.id = IWN_ID_BSS;
	IEEE80211_ADDR_COPY(node.macaddr, ni->ni_macaddr);
	node.control = IWN_NODE_UPDATE;
	node.flags = IWN_FLAG_SET_KEY;

	return iwn_cmd(sc, IWN_CMD_ADD_NODE, &node, sizeof node, 1);
}

d2646 3
d2650 1
a2650 1
	led.unit = htole32(100000);	/* on/off in unit of 100ms */
a2652 1

d2657 1
a2657 2
 * Set the critical temperature at which the firmware will automatically stop
 * the radio transmitter.
a2661 1
	struct iwn_ucode_info *uc = &sc->ucode_info;
a2662 7
	uint32_t r1, r2, r3, temp;

	r1 = letoh32(uc->temp[0].chan20MHz);
	r2 = letoh32(uc->temp[1].chan20MHz);
	r3 = letoh32(uc->temp[2].chan20MHz);
	/* inverse function of iwn_get_temperature() */
	temp = r2 + (IWN_CTOK(110) * (r3 - r1)) / 259;
d2664 1
a2664 1
	IWN_WRITE(sc, IWN_UCODE_CLR, IWN_CTEMP_STOP_RF);
d2667 2
a2668 2
	crit.tempR = htole32(temp);
	DPRINTF(("setting critical temperature to %u\n", temp));
d2672 2
a2673 2
void
iwn_enable_tsf(struct iwn_softc *sc, struct ieee80211_node *ni)
d2675 1
a2675 1
	struct iwn_cmd_tsf tsf;
d2678 4
a2681 4
	memset(&tsf, 0, sizeof tsf);
	memcpy(&tsf.tstamp, ni->ni_tstamp, sizeof (uint64_t));
	tsf.bintval = htole16(ni->ni_intval);
	tsf.lintval = htole16(10);
d2683 1
a2683 1
	/* compute remaining time until next beacon */
d2685 2
a2686 2
	mod = letoh64(tsf.tstamp) % val;
	tsf.binitval = htole32((uint32_t)(val - mod));
d2688 2
a2689 2
	DPRINTF(("TSF bintval=%u tstamp=%llu, init=%u\n",
	    ni->ni_intval, letoh64(tsf.tstamp), (uint32_t)(val - mod)));
d2691 1
a2691 2
	if (iwn_cmd(sc, IWN_CMD_TSF, &tsf, sizeof tsf, 1) != 0)
		printf("%s: could not enable TSF\n", sc->sc_dev.dv_xname);
d2695 1
a2695 1
iwn_power_calibration(struct iwn_softc *sc, int temp)
d2697 1
a2697 2
	struct ieee80211com *ic = &sc->sc_ic;

d2699 3
a2701 12

	/* adjust Tx power if need be (delta >= 3C) */
	if (abs(temp - sc->temp) < 3)
		return;

	sc->temp = temp;

	DPRINTF(("setting Tx power for channel %d\n",
	    ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan)));
	if (iwn_set_txpower(sc, ic->ic_bss->ni_chan, 1) != 0) {
		/* just warn, too bad for the automatic calibration... */
		printf("%s: could not adjust Tx power\n", sc->sc_dev.dv_xname);
d2706 1
a2706 1
 * Set Tx power for a given channel (each rate has its own power settings).
d2711 1
a2711 1
iwn_set_txpower(struct iwn_softc *sc, struct ieee80211_channel *ch, int async)
d2713 1
a2713 1
/* fixed-point arithmetic division using a n-bit fractional part */
d2716 1
a2716 1
/* linear interpolation */
d2723 3
a2725 2
	struct iwn_cmd_txpower cmd;
	struct iwn_eeprom_chan_samples *chans;
d2729 1
a2729 1
	u_int chan;
d2731 4
a2734 2
	/* get channel number */
	chan = ieee80211_chan2ieee(ic, ch);
d2742 2
a2743 2
		rf_gain  = iwn_rf_gain_5ghz;
		dsp_gain = iwn_dsp_gain_5ghz;
d2746 2
a2747 2
		rf_gain  = iwn_rf_gain_2ghz;
		dsp_gain = iwn_dsp_gain_2ghz;
d2750 1
a2750 1
	/* compute voltage compensation */
d2759 1
a2759 1
	/* get channel's attenuation group */
d2772 1
a2772 1
	/* get channel's sub-band */
d2780 1
a2780 1
	for (c = 0; c < IWN_NTXCHAINS; c++) {
d2793 1
a2793 1
		DPRINTF(("Tx chain %d: power=%d gain=%d temp=%d\n",
d2796 1
a2796 1
		/* compute temperature compensation */
d2803 2
a2804 4
			if ((ridx / 8) & 1) {
				/* MIMO: decrease Tx power (-3dB) */
				maxchpwr -= 6;
			}
d2806 1
a2806 1
			pwr = maxpwr - 10;
d2808 9
a2816 7
			/* decrease power for highest OFDM rates */
			if ((ridx % 8) == 5)		/* 48Mbit/s */
				pwr -= 5;
			else if ((ridx % 8) == 6)	/* 54Mbit/s */
				pwr -= 7;
			else if ((ridx % 8) == 7)	/* 60Mbit/s */
				pwr -= 10;
d2818 1
d2831 1
a2831 1
			/* make sure idx stays in a valid range */
d2834 2
a2835 2
			else if (idx > IWN_MAX_PWR_INDEX)
				idx = IWN_MAX_PWR_INDEX;
d2837 1
a2837 1
			DPRINTF(("Tx chain %d, rate idx %d: power=%d\n",
d2844 1
a2844 1
	DPRINTF(("setting tx power for chan %d\n", chan));
d2851 17
d2869 1
a2869 1
 * Get the best (maximum) RSSI among Rx antennas (in dBm).
d2872 1
a2872 1
iwn_get_rssi(const struct iwn_rx_stat *stat)
d2874 1
d2878 2
a2879 2
	mask = (letoh16(stat->antenna) >> 4) & 0x7;
	agc  = (letoh16(stat->agc) >> 7) & 0x7f;
d2883 1
a2883 1
		rssi = MAX(rssi, stat->rssi[0]);
d2885 1
a2885 1
		rssi = MAX(rssi, stat->rssi[2]);
d2887 17
a2903 1
		rssi = MAX(rssi, stat->rssi[4]);
d2909 1
a2909 1
 * Get the average noise among Rx antennas (in dBm).
d2923 1
a2923 1
	/* there should be at least one antenna but check anyway */
d2928 1
a2928 1
 * Read temperature (in degC) from the on-board thermal sensor.
d2931 1
a2931 1
iwn_get_temperature(struct iwn_softc *sc)
d2941 1
a2941 1
	if (r1 == r3)	/* prevents division by 0 (should not happen) */
d2944 1
a2944 1
	/* sign-extend 23-bit R4 value to 32-bit */
d2946 1
a2946 1
	/* compute temperature */
d2954 11
d2971 1
d2973 1
a2973 1
	struct iwn_phy_calib_cmd cmd;
d2976 1
a2976 1
	/* reset calibration state */
d2980 8
a2987 8
	/* initial values taken from the reference driver */
	calib->corr_ofdm_x1     = 105;
	calib->corr_ofdm_mrc_x1 = 220;
	calib->corr_ofdm_x4     =  90;
	calib->corr_ofdm_mrc_x4 = 170;
	calib->corr_cck_x4      = 125;
	calib->corr_cck_mrc_x4  = 200;
	calib->energy_cck       = 100;
d2989 1
a2989 1
	/* write initial sensitivity values */
d2993 8
a3000 5
	memset(&cmd, 0, sizeof cmd);
	cmd.code = IWN_SET_DIFF_GAIN;
	/* differential gains initially set to 0 for all 3 antennas */
	DPRINTF(("setting differential gains\n"));
	return iwn_cmd(sc, IWN_PHY_CALIB, &cmd, sizeof cmd, 1);
d3006 1
a3006 1
 * set differential gains.
d3009 1
a3009 1
iwn_compute_differential_gain(struct iwn_softc *sc,
d3012 1
d3014 2
a3015 2
	struct iwn_phy_calib_cmd cmd;
	int i, val;
d3017 1
a3017 1
	/* accumulate RSSI and noise for all 3 antennas */
d3022 1
a3022 2

	/* we update differential gain only once after 20 beacons */
d3026 1
a3026 1
	/* determine antenna with highest average RSSI */
d3030 1
a3030 1
	/* determine which antennas are connected */
d3032 70
a3101 6
	for (i = 0; i < 3; i++)
		if (val - calib->rssi[i] <= 15 * 20)
			sc->antmsk |= 1 << i;
	/* if neither Ant A and Ant B are connected.. */
	if ((sc->antmsk & (1 << 0 | 1 << 1)) == 0)
		sc->antmsk |= 1 << 1;	/* ..mark Ant B as connected! */
d3103 6
a3108 5
	/* get minimal noise among connected antennas */
	val = INT_MAX;	/* ok, there's at least one */
	for (i = 0; i < 3; i++)
		if (sc->antmsk & (1 << i))
			val = MIN(calib->noise[i], val);
d3111 3
a3113 3
	cmd.code = IWN_SET_DIFF_GAIN;
	/* set differential gains for connected antennas */
	for (i = 0; i < 3; i++) {
d3115 7
a3121 4
			cmd.gain[i] = (calib->noise[i] - val) / 30;
			/* limit differential gain to 3 */
			cmd.gain[i] = MIN(cmd.gain[i], 3);
			cmd.gain[i] |= IWN_GAIN_SET;
d3126 1
a3126 2
	if (iwn_cmd(sc, IWN_PHY_CALIB, &cmd, sizeof cmd, 1) == 0)
		calib->state = IWN_CALIB_STATE_RUN;
d3130 1
a3130 1
 * Tune RF Rx sensitivity based on the number of false alarms detected
d3136 1
a3136 1
#define inc_clip(val, inc, max)			\
d3144 1
a3144 1
#define dec_clip(val, dec, min)			\
d3153 2
d3161 1
a3161 1
	/* check that we've been enabled long enough */
d3165 1
a3165 1
	/* compute number of false alarms since last call for OFDM */
d3170 1
a3170 1
	/* save counters values for next call */
d3175 1
a3175 1
		/* high false alarm count, decrease sensitivity */
d3177 4
a3180 4
		inc_clip(calib->corr_ofdm_x1,     1, 140);
		inc_clip(calib->corr_ofdm_mrc_x1, 1, 270);
		inc_clip(calib->corr_ofdm_x4,     1, 120);
		inc_clip(calib->corr_ofdm_mrc_x4, 1, 210);
d3183 1
a3183 1
		/* low false alarm count, increase sensitivity */
d3185 4
a3188 4
		dec_clip(calib->corr_ofdm_x1,     1, 105);
		dec_clip(calib->corr_ofdm_mrc_x1, 1, 220);
		dec_clip(calib->corr_ofdm_x4,     1,  85);
		dec_clip(calib->corr_ofdm_mrc_x4, 1, 170);
d3191 1
a3191 1
	/* compute maximum noise among 3 antennas */
d3196 1
a3196 1
	/* insert it into our samples table */
d3200 1
a3200 1
	/* compute maximum noise among last 20 samples */
d3205 1
a3205 1
	/* compute maximum energy among 3 antennas */
d3210 1
a3210 1
	/* insert it into our samples table */
d3214 1
a3214 1
	/* compute minimum energy among last 10 samples */
d3220 1
a3220 1
	/* compute number of false alarms since last call for CCK */
d3225 1
a3225 1
	/* save counters values for next call */
d3230 1
a3230 1
		/* high false alarm count, decrease sensitivity */
d3235 1
a3235 1
		if (calib->corr_cck_x4 > 160) {
d3238 1
a3238 1
				dec_clip(calib->energy_cck, 2, energy_min);
d3240 2
a3241 2
		if (calib->corr_cck_x4 < 160) {
			calib->corr_cck_x4 = 161;
d3244 1
a3244 1
			inc_clip(calib->corr_cck_x4, 3, 200);
d3246 1
a3246 1
		inc_clip(calib->corr_cck_mrc_x4, 3, 400);
d3249 1
a3249 1
		/* low false alarm count, increase sensitivity */
d3254 2
a3255 2
		if (calib->cck_state != 0 &&
		    ((calib->noise_ref - noise_ref) > 2 ||
d3257 13
a3269 3
			inc_clip(calib->energy_cck,      2,  97);
			dec_clip(calib->corr_cck_x4,     3, 125);
			dec_clip(calib->corr_cck_mrc_x4, 3, 200);
d3271 289
d3561 77
a3637 10
		/* not worth to increase or decrease sensitivity */
		DPRINTFN(2, ("CCK normal false alarm count: %u\n", fa));
		calib->low_fa = 0;
		calib->noise_ref = noise_ref;

		if (calib->cck_state == IWN_CCK_STATE_HIFA) {
			/* previous interval had many false alarms */
			dec_clip(calib->energy_cck, 8, energy_min);
		}
		calib->cck_state = IWN_CCK_STATE_INIT;
d3640 3
a3642 5
	if (needs_update)
		(void)iwn_send_sensitivity(sc);
#undef dec_clip
#undef inc_clip
}
d3644 2
a3645 5
int
iwn_send_sensitivity(struct iwn_softc *sc)
{
	struct iwn_calib_state *calib = &sc->calib;
	struct iwn_sensitivity_cmd cmd;
d3647 3
a3649 16
	memset(&cmd, 0, sizeof cmd);
	cmd.which = IWN_SENSITIVITY_WORKTBL;
	/* OFDM modulation */
	cmd.corr_ofdm_x1     = htole16(calib->corr_ofdm_x1);
	cmd.corr_ofdm_mrc_x1 = htole16(calib->corr_ofdm_mrc_x1);
	cmd.corr_ofdm_x4     = htole16(calib->corr_ofdm_x4);
	cmd.corr_ofdm_mrc_x4 = htole16(calib->corr_ofdm_mrc_x4);
	cmd.energy_ofdm      = htole16(100);
	cmd.energy_ofdm_th   = htole16(62);
	/* CCK modulation */
	cmd.corr_cck_x4      = htole16(calib->corr_cck_x4);
	cmd.corr_cck_mrc_x4  = htole16(calib->corr_cck_mrc_x4);
	cmd.energy_cck       = htole16(calib->energy_cck);
	/* Barker modulation: use default values */
	cmd.corr_barker      = htole16(190);
	cmd.corr_barker_mrc  = htole16(390);
d3651 1
a3651 5
	DPRINTFN(2, ("setting sensitivity %d/%d/%d/%d/%d/%d/%d\n",
	    calib->corr_ofdm_x1, calib->corr_ofdm_mrc_x1, calib->corr_ofdm_x4,
	    calib->corr_ofdm_mrc_x4, calib->corr_cck_x4,
	    calib->corr_cck_mrc_x4, calib->energy_cck));
	return iwn_cmd(sc, IWN_SENSITIVITY, &cmd, sizeof cmd, 1);
d3657 1
d3664 10
a3673 8
	/* update adapter's configuration */
	IEEE80211_ADDR_COPY(sc->config.bssid, ni->ni_bssid);
	sc->config.chan = ieee80211_chan2ieee(ic, ni->ni_chan);
	sc->config.flags = htole32(IWN_CONFIG_TSF);
	if (IEEE80211_IS_CHAN_2GHZ(ni->ni_chan)) {
		sc->config.flags |= htole32(IWN_CONFIG_AUTO |
		    IWN_CONFIG_24GHZ);
	}
d3676 2
a3677 2
		sc->config.cck_mask  = 0;
		sc->config.ofdm_mask = 0x15;
d3680 2
a3681 2
		sc->config.cck_mask  = 0x03;
		sc->config.ofdm_mask = 0;
d3683 7
a3689 12
	default:	/* assume 802.11b/g */
		sc->config.cck_mask  = 0x0f;
		sc->config.ofdm_mask = 0x15;
	}
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		sc->config.flags |= htole32(IWN_CONFIG_SHSLOT);
	if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
		sc->config.flags |= htole32(IWN_CONFIG_SHPREAMBLE);
	DPRINTF(("config chan %d flags %x cck %x ofdm %x\n", sc->config.chan,
	    sc->config.flags, sc->config.cck_mask, sc->config.ofdm_mask));
	error = iwn_cmd(sc, IWN_CMD_CONFIGURE, &sc->config,
	    sizeof (struct iwn_config), 1);
d3695 3
a3697 3
	/* configuration has changed, set Tx power accordingly */
	if ((error = iwn_set_txpower(sc, ni->ni_chan, 1)) != 0) {
		printf("%s: could not set Tx power\n", sc->sc_dev.dv_xname);
d3702 2
a3703 2
	 * Reconfiguring clears the adapter's nodes table so we must
	 * add the broadcast node again.
d3707 1
a3707 1
	node.id = IWN_ID_BROADCAST;
d3709 1
a3709 1
	error = iwn_cmd(sc, IWN_CMD_ADD_NODE, &node, sizeof node, 1);
a3721 1

a3724 3
/*
 * Configure the adapter for associated state.
 */
d3728 1
d3739 4
d3744 4
a3747 7
	iwn_enable_tsf(sc, ni);

	/* update adapter's configuration */
	sc->config.associd = htole16(ni->ni_associd & ~0xc000);
	/* short preamble/slot time are negotiated when associating */
	sc->config.flags &= ~htole32(IWN_CONFIG_SHPREAMBLE |
	    IWN_CONFIG_SHSLOT);
d3749 1
a3749 1
		sc->config.flags |= htole32(IWN_CONFIG_SHSLOT);
d3751 4
a3754 7
		sc->config.flags |= htole32(IWN_CONFIG_SHPREAMBLE);
	sc->config.filter |= htole32(IWN_FILTER_BSS);

	DPRINTF(("config chan %d flags %x\n", sc->config.chan,
	    sc->config.flags));
	error = iwn_cmd(sc, IWN_CMD_CONFIGURE, &sc->config,
	    sizeof (struct iwn_config), 1);
d3761 3
a3763 4
	/* configuration has changed, set Tx power accordingly */
	if ((error = iwn_set_txpower(sc, ni->ni_chan, 1)) != 0) {
		printf("%s: could not set Tx power\n",
		    sc->sc_dev.dv_xname);
d3767 1
a3767 1
	/* add BSS node */
d3771 4
a3774 2
	node.htflags = htole32(3 << IWN_AMDPU_SIZE_FACTOR_SHIFT |
	    5 << IWN_AMDPU_DENSITY_SHIFT);
d3776 1
a3776 1
	error = iwn_cmd(sc, IWN_CMD_ADD_NODE, &node, sizeof node, 1);
d3789 1
a3789 1
		/* fake a join to init the tx rate */
d3798 1
a3798 2

	/* start periodic calibration timer */
d3803 1
a3803 1
	/* link LED always on while associated */
d3805 60
d3866 117
d3987 2
a3988 2
 * Send a scan request to the firmware.  Since this command is huge, we map it
 * into a mbuf instead of using the pre-allocated set of commands.
d3991 1
a3991 1
iwn_scan(struct iwn_softc *sc, uint16_t flags)
d3993 16
a4008 15
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwn_tx_ring *ring = &sc->txq[4];
	struct iwn_tx_desc *desc;
	struct iwn_tx_data *data;
	struct iwn_tx_cmd *cmd;
	struct iwn_cmd_data *tx;
	struct iwn_scan_hdr *hdr;
	struct iwn_scan_essid *essid;
	struct iwn_scan_chan *chan;
	struct ieee80211_frame *wh;
	struct ieee80211_rateset *rs;
	struct ieee80211_channel *c;
	enum ieee80211_phymode mode;
	uint8_t *frm;
	int pktlen, error;
d4010 8
a4017 2
	desc = &ring->desc[ring->cur];
	data = &ring->data[ring->cur];
d4019 12
a4030 5
	MGETHDR(data->m, M_DONTWAIT, MT_DATA);
	if (data->m == NULL) {
		printf("%s: could not allocate mbuf for scan command\n",
		    sc->sc_dev.dv_xname);
		return ENOMEM;
d4032 48
a4079 7
	MCLGET(data->m, M_DONTWAIT);
	if (!(data->m->m_flags & M_EXT)) {
		m_freem(data->m);
		data->m = NULL;
		printf("%s: could not allocate mbuf for scan command\n",
		    sc->sc_dev.dv_xname);
		return ENOMEM;
d4081 13
d4095 2
a4096 5
	cmd = mtod(data->m, struct iwn_tx_cmd *);
	cmd->code = IWN_CMD_SCAN;
	cmd->flags = 0;
	cmd->qid = ring->qid;
	cmd->idx = ring->cur;
d4098 27
a4124 9
	hdr = (struct iwn_scan_hdr *)cmd->data;
	memset(hdr, 0, sizeof (struct iwn_scan_hdr));
	/*
	 * Move to the next channel if no packets are received within 5 msecs
	 * after sending the probe request (this helps to reduce the duration
	 * of active scans).
	 */
	hdr->quiet = htole16(5);	/* timeout in milliseconds */
	hdr->plcp_threshold = htole16(1);	/* min # of packets */
d4126 17
a4142 2
	/* select Ant B and Ant C for scanning */
	hdr->rxchain = htole16(0x3e1 | 7 << IWN_RXCHAIN_ANTMSK_SHIFT);
d4144 2
a4145 6
	tx = (struct iwn_cmd_data *)(hdr + 1);
	memset(tx, 0, sizeof (struct iwn_cmd_data));
	tx->flags = htole32(IWN_TX_AUTO_SEQ | 0x200);	/* XXX */
	tx->id = IWN_ID_BROADCAST;
	tx->lifetime = htole32(IWN_LIFETIME_INFINITE);
	tx->rflags = IWN_RFLAG_ANT_B;
d4147 30
a4176 4
	if (flags & IEEE80211_CHAN_A) {
		hdr->crc_threshold = htole16(1);
		/* send probe requests at 6Mbps */
		tx->rate = iwn_ridx_to_plcp[IWN_OFDM6];
d4178 2
a4179 4
		hdr->flags = htole32(IWN_CONFIG_24GHZ | IWN_CONFIG_AUTO);
		/* send probe requests at 1Mbps */
		tx->rate = iwn_ridx_to_plcp[IWN_CCK1];
		tx->rflags |= IWN_RFLAG_CCK;
d4181 2
d4184 8
a4191 5
	essid = (struct iwn_scan_essid *)(tx + 1);
	memset(essid, 0, 4 * sizeof (struct iwn_scan_essid));
	essid[0].id  = IEEE80211_ELEMID_SSID;
	essid[0].len = ic->ic_des_esslen;
	memcpy(essid[0].data, ic->ic_des_essid, ic->ic_des_esslen);
d4193 1
a4193 13
	/*
	 * Build a probe request frame.  Most of the following code is a
	 * copy & paste of what is done in net80211.
	 */
	wh = (struct ieee80211_frame *)&essid[4];
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_PROBE_REQ;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	IEEE80211_ADDR_COPY(wh->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, etherbroadcastaddr);
	*(u_int16_t *)&wh->i_dur[0] = 0;	/* filled by h/w */
	*(u_int16_t *)&wh->i_seq[0] = 0;	/* filled by h/w */
d4195 2
a4196 1
	frm = (uint8_t *)(wh + 1);
d4198 3
a4200 2
	/* add SSID IE */
	frm = ieee80211_add_ssid(frm, ic->ic_des_essid, ic->ic_des_esslen);
d4202 3
a4204 2
	mode = ieee80211_chan2mode(ic, ic->ic_ibss_chan);
	rs = &ic->ic_sup_rates[mode];
d4206 2
a4207 2
	/* add supported rates IE */
	frm = ieee80211_add_rates(frm, rs);
d4209 13
a4221 3
	/* add supported xrates IE */
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		frm = ieee80211_add_xrates(frm, rs);
d4223 2
a4224 2
	/* setup length of probe request */
	tx->len = htole16(frm - (uint8_t *)wh);
d4226 3
a4228 5
	chan = (struct iwn_scan_chan *)frm;
	for (c  = &ic->ic_channels[1];
	     c <= &ic->ic_channels[IEEE80211_CHAN_MAX]; c++) {
		if ((c->ic_flags & flags) != flags)
			continue;
d4230 6
a4235 19
		chan->chan = ieee80211_chan2ieee(ic, c);
		chan->flags = 0;
		if (!(c->ic_flags & IEEE80211_CHAN_PASSIVE)) {
			chan->flags |= IWN_CHAN_ACTIVE;
			if (ic->ic_des_esslen != 0)
				chan->flags |= IWN_CHAN_DIRECT;
		}
		chan->dsp_gain = 0x6e;
		if (IEEE80211_IS_CHAN_5GHZ(c)) {
			chan->rf_gain = 0x3b;
			chan->active  = htole16(10);
			chan->passive = htole16(110);
		} else {
			chan->rf_gain = 0x28;
			chan->active  = htole16(20);
			chan->passive = htole16(120);
		}
		hdr->nchan++;
		chan++;
d4237 4
a4240 2
		frm += sizeof (struct iwn_scan_chan);
	}
d4242 9
a4250 2
	hdr->len = htole16(frm - (uint8_t *)hdr);
	pktlen = frm - (uint8_t *)cmd;
d4252 2
a4253 2
	error = bus_dmamap_load(sc->sc_dmat, data->map, cmd, pktlen, NULL,
	    BUS_DMA_NOWAIT);
d4255 1
a4255 1
		printf("%s: could not map scan command\n",
a4256 2
		m_freem(data->m);
		data->m = NULL;
d4259 2
d4262 5
a4266 7
	IWN_SET_DESC_NSEGS(desc, 1);
	IWN_SET_DESC_SEG(desc, 0, data->map->dm_segs[0].ds_addr,
	    data->map->dm_segs[0].ds_len);
	sc->shared->len[ring->qid][ring->cur] = htole16(8);
	if (ring->cur < IWN_TX_WINDOW) {
		sc->shared->len[ring->qid][ring->cur + IWN_TX_RING_COUNT] =
		    htole16(8);
d4269 19
a4287 3
	/* kick cmd ring */
	ring->cur = (ring->cur + 1) % IWN_TX_RING_COUNT;
	IWN_WRITE(sc, IWN_TX_WIDX, ring->qid << 8 | ring->cur);
d4289 1
a4289 1
	return 0;	/* will be notified async. of failure/success */
d4292 3
d4296 2
a4297 1
iwn_config(struct iwn_softc *sc)
d4299 1
a4299 6
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct iwn_power power;
	struct iwn_bluetooth bluetooth;
	struct iwn_node_info node;
	uint8_t rate;
d4302 4
a4305 7
	/* set power mode */
	memset(&power, 0, sizeof power);
	power.flags = htole16(IWN_POWER_CAM | 0x8);
	DPRINTF(("setting power mode\n"));
	error = iwn_cmd(sc, IWN_CMD_SET_POWER_MODE, &power, sizeof power, 0);
	if (error != 0) {
		printf("%s: could not set power mode\n", sc->sc_dev.dv_xname);
a4306 1
	}
d4308 33
a4340 8
	/* configure bluetooth coexistence */
	memset(&bluetooth, 0, sizeof bluetooth);
	bluetooth.flags = 3;
	bluetooth.lead = 0xaa;
	bluetooth.kill = 1;
	DPRINTF(("configuring bluetooth coexistence\n"));
	error = iwn_cmd(sc, IWN_CMD_BLUETOOTH, &bluetooth, sizeof bluetooth,
	    0);
d4342 2
a4343 2
		printf("%s: could not configure bluetooth coexistence\n",
		    sc->sc_dev.dv_xname);
d4347 2
a4348 46
	/* configure adapter */
	memset(&sc->config, 0, sizeof (struct iwn_config));
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	IEEE80211_ADDR_COPY(sc->config.myaddr, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(sc->config.wlap, ic->ic_myaddr);
	/* set default channel */
	sc->config.chan = ieee80211_chan2ieee(ic, ic->ic_ibss_chan);
	sc->config.flags = htole32(IWN_CONFIG_TSF);
	if (IEEE80211_IS_CHAN_2GHZ(ic->ic_ibss_chan)) {
		sc->config.flags |= htole32(IWN_CONFIG_AUTO |
		    IWN_CONFIG_24GHZ);
	}
	sc->config.filter = 0;
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		sc->config.mode = IWN_MODE_STA;
		sc->config.filter |= htole32(IWN_FILTER_MULTICAST);
		break;
#ifndef IEEE80211_STA_ONLY
#ifdef notyet
	case IEEE80211_M_IBSS:
	case IEEE80211_M_AHDEMO:
		sc->config.mode = IWN_MODE_IBSS;
		break;
	case IEEE80211_M_HOSTAP:
		sc->config.mode = IWN_MODE_HOSTAP;
		break;
#endif
#endif
	case IEEE80211_M_MONITOR:
		sc->config.mode = IWN_MODE_MONITOR;
		sc->config.filter |= htole32(IWN_FILTER_MULTICAST |
		    IWN_FILTER_CTL | IWN_FILTER_PROMISC);
		break;
	default:
		/* should not get there */
		break;
	}
	sc->config.cck_mask  = 0x0f;	/* not yet negotiated */
	sc->config.ofdm_mask = 0xff;	/* not yet negotiated */
	sc->config.ht_single_mask = 0xff;
	sc->config.ht_dual_mask = 0xff;
	sc->config.rxchain = htole16(0x2800 | 7 << IWN_RXCHAIN_ANTMSK_SHIFT);
	DPRINTF(("setting configuration\n"));
	error = iwn_cmd(sc, IWN_CMD_CONFIGURE, &sc->config,
	    sizeof (struct iwn_config), 0);
d4350 2
a4351 1
		printf("%s: configure command failed\n", sc->sc_dev.dv_xname);
d4355 18
a4372 3
	/* configuration has changed, set Tx power accordingly */
	if ((error = iwn_set_txpower(sc, ic->ic_ibss_chan, 0)) != 0) {
		printf("%s: could not set Tx power\n", sc->sc_dev.dv_xname);
d4375 5
a4379 11

	/* add broadcast node */
	memset(&node, 0, sizeof node);
	IEEE80211_ADDR_COPY(node.macaddr, etherbroadcastaddr);
	node.id = IWN_ID_BROADCAST;
	DPRINTF(("adding broadcast node\n"));
	error = iwn_cmd(sc, IWN_CMD_ADD_NODE, &node, sizeof node, 0);
	if (error != 0) {
		printf("%s: could not add broadcast node\n",
		    sc->sc_dev.dv_xname);
		return error;
d4381 19
a4399 6
	DPRINTF(("setting fixed rate for node %d\n", node.id));
	rate = (ic->ic_curmode == IEEE80211_MODE_11A) ? 12 : 2;
	if ((error = iwn_set_fixed_rate(sc, node.id, rate, 0)) != 0) {
		printf("%s: could not setup MRR for node %d\n",
		    sc->sc_dev.dv_xname, node.id);
		return error;
d4402 7
a4408 4
	if ((error = iwn_set_critical_temp(sc)) != 0) {
		printf("%s: could not set critical temperature\n",
		    sc->sc_dev.dv_xname);
		return error;
d4411 7
d4421 2
a4422 5
/*
 * Do post-alive initialization of the NIC (after firmware upload).
 */
void
iwn_post_alive(struct iwn_softc *sc)
d4424 1
a4424 3
	uint32_t base;
	uint16_t offset;
	int qid;
d4426 2
a4427 1
	iwn_mem_lock(sc);
d4429 5
a4433 5
	/* clear SRAM */
	base = iwn_mem_read(sc, IWN_SRAM_BASE);
	for (offset = 0x380; offset < 0x520; offset += 4) {
		IWN_WRITE(sc, IWN_MEM_WADDR, base + offset);
		IWN_WRITE(sc, IWN_MEM_WDATA, 0);
d4435 4
d4440 23
a4462 3
	/* shared area is aligned on a 1K boundary */
	iwn_mem_write(sc, IWN_SRAM_BASE, sc->shared_dma.paddr >> 10);
	iwn_mem_write(sc, IWN_SELECT_QCHAIN, 0);
d4464 2
a4465 3
	for (qid = 0; qid < IWN_NTXQUEUES; qid++) {
		iwn_mem_write(sc, IWN_QUEUE_RIDX(qid), 0);
		IWN_WRITE(sc, IWN_TX_WIDX, qid << 8 | 0);
d4467 5
a4471 7
		/* set sched. window size */
		IWN_WRITE(sc, IWN_MEM_WADDR, base + IWN_QUEUE_OFFSET(qid));
		IWN_WRITE(sc, IWN_MEM_WDATA, 64);
		/* set sched. frame limit */
		IWN_WRITE(sc, IWN_MEM_WADDR, base + IWN_QUEUE_OFFSET(qid) + 4);
		IWN_WRITE(sc, IWN_MEM_WDATA, 64 << 16);
	}
d4473 10
a4482 2
	/* enable interrupts for all 16 queues */
	iwn_mem_write(sc, IWN_QUEUE_INTR_MASK, 0xffff);
d4484 2
a4485 2
	/* identify active Tx rings (0-7) */
	iwn_mem_write(sc, IWN_TX_ACTIVE, 0xff);
d4487 9
a4495 5
	/* mark Tx rings (4 EDCA + cmd + 2 HCCA) as active */
	for (qid = 0; qid < 7; qid++) {
		iwn_mem_write(sc, IWN_TXQ_STATUS(qid),
		    IWN_TXQ_STATUS_ACTIVE | qid << 1);
	}
d4497 1
a4497 1
	iwn_mem_unlock(sc);
d4501 1
a4501 1
iwn_stop_master(struct iwn_softc *sc)
a4502 1
	uint32_t tmp;
d4505 1
a4505 7
	tmp = IWN_READ(sc, IWN_RESET);
	IWN_WRITE(sc, IWN_RESET, tmp | IWN_STOP_MASTER);

	tmp = IWN_READ(sc, IWN_GPIO_CTL);
	if ((tmp & IWN_GPIO_PWR_STATUS) == IWN_GPIO_PWR_SLEEP)
		return;	/* already asleep */

d4507 2
a4508 2
		if (IWN_READ(sc, IWN_RESET) & IWN_MASTER_DISABLED)
			break;
d4511 1
a4511 4
	if (ntries == 100) {
		printf("%s: timeout waiting for master\n",
		    sc->sc_dev.dv_xname);
	}
d4514 2
a4515 2
int
iwn_reset(struct iwn_softc *sc)
d4517 1
a4517 2
	uint32_t tmp;
	int ntries;
d4519 5
a4523 2
	/* clear any pending interrupts */
	IWN_WRITE(sc, IWN_INTR, 0xffffffff);
d4525 5
a4529 2
	tmp = IWN_READ(sc, IWN_CHICKEN);
	IWN_WRITE(sc, IWN_CHICKEN, tmp | IWN_CHICKEN_DISLOS);
d4531 18
a4548 2
	tmp = IWN_READ(sc, IWN_GPIO_CTL);
	IWN_WRITE(sc, IWN_GPIO_CTL, tmp | IWN_GPIO_INIT);
d4550 10
a4559 10
	/* wait for clock stabilization */
	for (ntries = 0; ntries < 25000; ntries++) {
		if (IWN_READ(sc, IWN_GPIO_CTL) & IWN_GPIO_CLOCK)
			break;
		DELAY(100);
	}
	if (ntries == 25000) {
		printf("%s: timeout waiting for clock stabilization\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
d4561 2
d4566 2
a4567 2
void
iwn_hw_config(struct iwn_softc *sc)
d4569 3
a4571 1
	uint32_t tmp, hw;
d4573 16
a4588 2
	/* enable interrupts mitigation */
	IWN_WRITE(sc, IWN_INTR_MIT, 512 / 32);
d4590 6
a4595 25
	/* voodoo from the reference driver */
	tmp = pci_conf_read(sc->sc_pct, sc->sc_pcitag, PCI_CLASS_REG);
	tmp = PCI_REVISION(tmp);
	if ((tmp & 0x80) && (tmp & 0x7f) < 8) {
		/* enable "no snoop" field */
		tmp = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0xe8);
		tmp &= ~IWN_DIS_NOSNOOP;
		pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0xe8, tmp);
	}

	/* disable L1 entry to work around a hardware bug */
	tmp = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0xf0);
	tmp &= ~IWN_ENA_L1;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0xf0, tmp);

	hw = IWN_READ(sc, IWN_HWCONFIG);
	IWN_WRITE(sc, IWN_HWCONFIG, hw | 0x310);

	iwn_mem_lock(sc);
	tmp = iwn_mem_read(sc, IWN_MEM_POWER);
	iwn_mem_write(sc, IWN_MEM_POWER, tmp | IWN_POWER_RESET);
	DELAY(5);
	tmp = iwn_mem_read(sc, IWN_MEM_POWER);
	iwn_mem_write(sc, IWN_MEM_POWER, tmp & ~IWN_POWER_RESET);
	iwn_mem_unlock(sc);
d4599 1
a4599 1
iwn_init(struct ifnet *ifp)
d4601 1
a4601 2
	struct iwn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
d4605 7
a4611 3
	if ((error = iwn_reset(sc)) != 0) {
		printf("%s: could not reset adapter\n", sc->sc_dev.dv_xname);
		goto fail1;
d4614 12
a4625 5
	iwn_mem_lock(sc);
	iwn_mem_read(sc, IWN_CLOCK_CTL);
	iwn_mem_write(sc, IWN_CLOCK_CTL, 0xa00);
	iwn_mem_read(sc, IWN_CLOCK_CTL);
	iwn_mem_unlock(sc);
d4627 18
a4644 1
	DELAY(20);
d4646 2
a4647 25
	iwn_mem_lock(sc);
	tmp = iwn_mem_read(sc, IWN_MEM_PCIDEV);
	iwn_mem_write(sc, IWN_MEM_PCIDEV, tmp | 0x800);
	iwn_mem_unlock(sc);

	iwn_mem_lock(sc);
	tmp = iwn_mem_read(sc, IWN_MEM_POWER);
	iwn_mem_write(sc, IWN_MEM_POWER, tmp & ~0x03000000);
	iwn_mem_unlock(sc);

	iwn_hw_config(sc);

	/* init Rx ring */
	iwn_mem_lock(sc);
	IWN_WRITE(sc, IWN_RX_CONFIG, 0);
	IWN_WRITE(sc, IWN_RX_WIDX, 0);
	/* Rx ring is aligned on a 256-byte boundary */
	IWN_WRITE(sc, IWN_RX_BASE, sc->rxq.desc_dma.paddr >> 8);
	/* shared area is aligned on a 16-byte boundary */
	IWN_WRITE(sc, IWN_RW_WIDX_PTR, (sc->shared_dma.paddr +
	    offsetof(struct iwn_shared, closed_count)) >> 4);
	IWN_WRITE(sc, IWN_RX_CONFIG, 0x80601000);
	iwn_mem_unlock(sc);

	IWN_WRITE(sc, IWN_RX_WIDX, (IWN_RX_RING_COUNT - 1) & ~7);
d4649 2
a4650 2
	iwn_mem_lock(sc);
	iwn_mem_write(sc, IWN_TX_ACTIVE, 0);
d4652 2
a4653 2
	/* set physical address of "keep warm" page */
	IWN_WRITE(sc, IWN_KW_BASE, sc->kw_dma.paddr >> 4);
d4655 2
a4656 2
	/* init Tx rings */
	for (qid = 0; qid < IWN_NTXQUEUES; qid++) {
d4658 69
a4726 2
		IWN_WRITE(sc, IWN_TX_BASE(qid), txq->desc_dma.paddr >> 8);
		IWN_WRITE(sc, IWN_TX_CONFIG(qid), 0x80000008);
d4728 4
a4731 1
	iwn_mem_unlock(sc);
d4733 6
a4738 12
	/* clear "radio off" and "disable command" bits (reversed logic) */
	IWN_WRITE(sc, IWN_UCODE_CLR, IWN_RADIO_OFF);
	IWN_WRITE(sc, IWN_UCODE_CLR, IWN_DISABLE_CMD);

	/* clear any pending interrupts */
	IWN_WRITE(sc, IWN_INTR, 0xffffffff);
	/* enable interrupts */
	IWN_WRITE(sc, IWN_MASK, IWN_INTR_MASK);

	/* not sure why/if this is necessary... */
	IWN_WRITE(sc, IWN_UCODE_CLR, IWN_RADIO_OFF);
	IWN_WRITE(sc, IWN_UCODE_CLR, IWN_RADIO_OFF);
d4740 2
a4741 2
	/* check that the radio is not disabled by RF switch */
	if (!(IWN_READ(sc, IWN_GPIO_CTL) & IWN_GPIO_RF_ENABLED)) {
d4744 2
a4745 2
		error = EPERM;	/* XXX ;-) */
		goto fail1;
d4748 4
a4751 3
	if ((error = iwn_load_firmware(sc)) != 0) {
		printf("%s: could not load firmware\n", sc->sc_dev.dv_xname);
		goto fail1;
d4754 8
a4761 8
	/* firmware has notified us that it is alive.. */
	iwn_post_alive(sc);	/* ..do post alive initialization */

	sc->rawtemp = sc->ucode_info.temp[3].chan20MHz;
	sc->temp = iwn_get_temperature(sc);
	DPRINTF(("temperature=%d\n", sc->temp));
	sc->sensor.value = IWN_CTOMUK(sc->temp);
	sc->sensor.flags &= ~SENSOR_FINVALID;
d4763 1
d4767 1
a4767 1
		goto fail1;
d4780 1
a4780 1
fail1:	iwn_stop(ifp, 1);
a4788 2
	uint32_t tmp;
	int i;
d4793 1
a4793 1
	/* in case we were scanning, release the scan "lock" */
d4798 2
a4799 16
	IWN_WRITE(sc, IWN_RESET, IWN_NEVO_RESET);

	/* disable interrupts */
	IWN_WRITE(sc, IWN_MASK, 0);
	IWN_WRITE(sc, IWN_INTR, 0xffffffff);
	IWN_WRITE(sc, IWN_INTR_STATUS, 0xffffffff);

	/* make sure we no longer hold the memory lock */
	iwn_mem_unlock(sc);

	/* reset all Tx rings */
	for (i = 0; i < IWN_NTXQUEUES; i++)
		iwn_reset_tx_ring(sc, &sc->txq[i]);

	/* reset Rx ring */
	iwn_reset_rx_ring(sc, &sc->rxq);
d4801 1
a4801 1
	/* temperature is no longer valid */
a4803 10

	iwn_mem_lock(sc);
	iwn_mem_write(sc, IWN_MEM_CLOCK2, 0x200);
	iwn_mem_unlock(sc);

	DELAY(5);

	iwn_stop_master(sc);
	tmp = IWN_READ(sc, IWN_RESET);
	IWN_WRITE(sc, IWN_RESET, tmp | IWN_SW_RESET);
a4804 4

struct cfdriver iwn_cd = {
	NULL, "iwn", DV_IFNET
};
@


1.22
log
@Wait much longer for clock stabilization.

From jcs@@ and in accordance with what the Intel Linux driver does.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.21 2008/07/21 18:43:19 damien Exp $	*/
d3300 2
d3309 2
d3315 3
@


1.21
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.20 2008/06/16 18:43:06 damien Exp $	*/
d3450 1
a3450 1
	for (ntries = 0; ntries < 1000; ntries++) {
d3453 1
a3453 1
		DELAY(10);
d3455 1
a3455 1
	if (ntries == 1000) {
@


1.20
log
@replace min() and max() function calls by MIN() and MAX().
MIN() and MAX() are macros that can evaluate their arguments twice
but it is safe in this context.

following a post from miod@@ about the harmfulness of min() and max()
in the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.19 2008/04/27 19:01:59 damien Exp $	*/
d1199 1
d1334 4
a1337 1
	ieee80211_input(ifp, m, ni, rssi, 0);
@


1.19
log
@fix rate control.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.18 2008/04/16 18:32:15 damien Exp $	*/
d2580 1
a2580 1
		rssi = max(rssi, stat->rssi[0]);
d2582 1
a2582 1
		rssi = max(rssi, stat->rssi[2]);
d2584 1
a2584 1
		rssi = max(rssi, stat->rssi[4]);
d2693 2
a2694 2
	val = max(calib->rssi[0], calib->rssi[1]);
	val = max(calib->rssi[2], val);
d2709 1
a2709 1
			val = min(calib->noise[i], val);
d2718 1
a2718 1
			cmd.gain[i] = min(cmd.gain[i], 3);
d2791 2
a2792 2
	val = max(noise[0], noise[1]);
	val = max(noise[2], val);
d2800 1
a2800 1
		noise_ref = max(noise_ref, calib->noise_samples[i]);
d2805 2
a2806 2
	val = min(energy[0], energy[1]);
	val = min(energy[2], val);
d2814 1
a2814 1
		energy_min = max(energy_min, calib->energy_samples[i]);
@


1.18
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.17 2008/03/08 16:24:44 espie Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007
d136 3
a138 1
int		iwn_setup_node_mrr(struct iwn_softc *, uint8_t, int);
d1811 1
a1811 1
		tx->ridx = 0;
d1813 1
a1813 1
		tx->flags |= htole32(IWN_TX_USE_NODE_RATE);
d2226 2
a2227 1
iwn_setup_node_mrr(struct iwn_softc *sc, uint8_t id, int async)
d2229 1
a2229 1
	struct ieee80211com *ic = &sc->sc_ic;
d2231 2
a2232 1
	int i, ridx;
d2241 14
a2254 8
	if (id == IWN_ID_BSS)
		ridx = IWN_OFDM54;
	else if (ic->ic_curmode == IEEE80211_MODE_11A)
		ridx = IWN_OFDM6;
	else
		ridx = IWN_CCK1;
	for (i = 0; i < IWN_MAX_TX_RETRIES; i++) {
		mrr.table[i].rate = iwn_ridx_to_plcp[ridx];
d2256 1
a2256 1
		if (ridx <= IWN_CCK11)
d2258 25
a2282 1
		ridx = iwn_prev_ridx[ridx];
d2913 1
d2970 3
a2972 2
	DPRINTF(("setting MRR for node %d\n", node.id));
	if ((error = iwn_setup_node_mrr(sc, node.id, 1)) != 0) {
d3041 1
a3041 1
	if ((error = iwn_setup_node_mrr(sc, node.id, 1)) != 0) {
d3251 1
d3339 3
a3341 2
	DPRINTF(("setting MRR for node %d\n", node.id));
	if ((error = iwn_setup_node_mrr(sc, node.id, 0)) != 0) {
@


1.17
log
@allows SMALL_KERNEL compiles
okay damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.16 2007/11/30 19:19:47 damien Exp $	*/
d138 1
a138 1
		    const struct ieee80211_key *);
d296 1
d326 1
d328 1
d1463 1
a1463 1
		    letoh32(desc->len)));
d1680 1
d1686 1
a1686 1
	int i, rate, error, pad, ovhd = 0;
d1740 7
a1746 12
		const struct ieee80211_key *key =
		    &ic->ic_nw_keys[ic->ic_wep_txkey];
		if (key->k_cipher == IEEE80211_CIPHER_WEP40)
			tx->security = IWN_CIPHER_WEP40;
		else
			tx->security = IWN_CIPHER_WEP104;
		tx->security |= ic->ic_wep_txkey << 6;
		memcpy(&tx->key[3], key->k_key, key->k_len);
		/* compute crypto overhead */
		ovhd = IEEE80211_WEP_TOTLEN;
	} else
		tx->security = 0;
d1761 1
a1761 1
		if (m0->m_pkthdr.len + ovhd + IEEE80211_CRC_LEN >
d2258 1
a2258 1
    const struct ieee80211_key *k)
@


1.16
log
@s/letoh16/htole16/ in iwn_send_sensitivity().
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.15 2007/11/27 19:45:44 damien Exp $	*/
d75 1
d77 1
d336 1
d338 1
d356 1
d372 1
@


1.15
log
@fix DMA alignment constraints: rings must be aligned on a 256-byte
boundary, "keep warm" page must be aligned on a 4KB boundary.

make sure sc->shared->len[x][y] == sc->shared->len[x + 256][y] for
all x < 64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.14 2007/11/19 19:35:43 damien Exp $	*/
d2847 6
a2852 6
	cmd.corr_ofdm_x1     = letoh16(calib->corr_ofdm_x1);
	cmd.corr_ofdm_mrc_x1 = letoh16(calib->corr_ofdm_mrc_x1);
	cmd.corr_ofdm_x4     = letoh16(calib->corr_ofdm_x4);
	cmd.corr_ofdm_mrc_x4 = letoh16(calib->corr_ofdm_mrc_x4);
	cmd.energy_ofdm      = letoh16(100);
	cmd.energy_ofdm_th   = letoh16(62);
d2854 3
a2856 3
	cmd.corr_cck_x4      = letoh16(calib->corr_cck_x4);
	cmd.corr_cck_mrc_x4  = letoh16(calib->corr_cck_mrc_x4);
	cmd.energy_cck       = letoh16(calib->energy_cck);
d2858 2
a2859 2
	cmd.corr_barker      = letoh16(190);
	cmd.corr_barker_mrc  = letoh16(390);
@


1.14
log
@pairwise keys always have an ID equal to 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.13 2007/11/19 19:34:25 damien Exp $	*/
d485 1
a485 1
	/* must be aligned on a 16-byte boundary */
d487 1
a487 1
	    PAGE_SIZE, 16, BUS_DMA_NOWAIT);
d1874 4
a1877 1

d1880 1
a1880 1
	/* kick ring */
d2203 4
d3190 4
@


1.13
log
@all TX rings have the same fixed size (256 entries) and this is not
configurable so simplify rings allocation a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.12 2007/11/17 18:50:54 damien Exp $	*/
a2258 1
		node.security |= htole16(k->k_id << 8);
@


1.12
log
@fix reading of EEPROM for some adapters.

from Benjamin Close @@ FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.11 2007/11/03 13:10:29 damien Exp $	*/
d95 1
a95 1
		    int, int);
d276 1
a276 3
		struct iwn_tx_ring *txq = &sc->txq[i];
		error = iwn_alloc_tx_ring(sc, txq, IWN_TX_RING_COUNT, i);
		if (error != 0) {
d282 1
a282 2
	error = iwn_alloc_rx_ring(sc, &sc->rxq);
	if (error != 0) {
d660 1
a660 2
iwn_alloc_tx_ring(struct iwn_softc *sc, struct iwn_tx_ring *ring, int count,
    int qid)
d662 1
a665 1
	ring->count = count;
d669 1
d671 1
a671 2
	    (void **)&ring->desc, count * sizeof (struct iwn_tx_desc),
	    IWN_RING_DMA_ALIGN, BUS_DMA_NOWAIT);
d678 1
d680 1
a680 2
	    (void **)&ring->cmd, count * sizeof (struct iwn_tx_cmd), 4,
	    BUS_DMA_NOWAIT);
d687 1
a687 9
	ring->data = malloc(count * sizeof (struct iwn_tx_data), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (ring->data == NULL) {
		printf("%s: could not allocate tx data slots\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	for (i = 0; i < count; i++) {
d729 1
a729 1
	for (i = 0; i < ring->count; i++) {
d751 6
a756 8
	if (ring->data != NULL) {
		for (i = 0; i < ring->count; i++) {
			struct iwn_tx_data *data = &ring->data[i];

			if (data->m != NULL) {
				bus_dmamap_unload(sc->sc_dmat, data->map);
				m_freem(data->m);
			}
a757 1
		free(ring->data, M_DEVBUF);
d1903 1
a1903 1
			if (sc->txq[0].queued >= sc->txq[0].count - 8) {
d1924 1
a1924 1
			if (sc->txq[0].queued >= sc->txq[0].count - 8) {
@


1.11
log
@fix ENETRESET handling in {wpi,iwn}_ioctl() so that the firmware won't
panic when resetting the device - requested by many
fix ifconfig -M (the interface still has to be down though ie it won't
work while the interface is up).
fix AMPDU window for 4965AGN (has no effect since 802.11n is not
supported yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.10 2007/09/11 18:53:34 damien Exp $	*/
d963 2
@


1.10
log
@s/iwn_edcaupdate/iwn_updateedca/ + hook it into net80211
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.9 2007/09/10 20:36:49 damien Exp $	*/
d806 3
a808 1
	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
d810 1
a810 1

a822 3
	if (ic->ic_state == IEEE80211_S_SCAN)
		ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;

d2035 2
a2036 1
		    (IFF_UP | IFF_RUNNING))
d2038 1
d3348 1
a3348 1
		IWN_WRITE(sc, IWN_MEM_WDATA, 10 << 16);
d3580 3
@


1.9
log
@fix interrupts processing and scan command + cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.8 2007/09/10 18:14:55 damien Exp $	*/
d137 1
a137 1
void		iwn_edcaupdate(struct ieee80211com *);
d327 1
d2287 1
a2287 1
iwn_edcaupdate(struct ieee80211com *ic)
@


1.8
log
@if more than 5 consecutive beacons are lost, reinitialize sensitivity
state machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.7 2007/09/10 17:55:48 damien Exp $	*/
d1230 1
a1230 1
		tail = (uint32_t *)(head + (len = letoh16(ampdu->len)));
d1233 1
a1233 1
		tail = (uint32_t *)(head + (len = letoh16(stat->len)));
d1237 1
d1630 2
a1631 1
	if (r1 & (IWN_RX_INTR | IWN_SW_RX_INTR))
d3095 1
a3095 1
	tx->flags = htole32(IWN_TX_AUTO_SEQ);
d3133 2
a3134 2
	/* add empty SSID IE (firmware generates it for directed scans) */
	frm = ieee80211_add_ssid(frm, NULL, 0);
@


1.7
log
@only send a sensitivity update command when the settings have changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.6 2007/09/07 20:02:54 damien Exp $	*/
d1491 15
@


1.6
log
@properly acknowledge interrupts.  this fixes the interrupts storm i was
seeing with vmstat -i.  re-enable interrupts coalescing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.5 2007/09/07 19:32:09 damien Exp $	*/
d2575 1
a2575 2
	if (r4 & (1 << 23))
		r4 |= ~((1 << 23) - 1);
d2684 16
a2699 4
#define inc_clip(val, inc, max)	\
	if (((val) += (inc)) > (max)) (val) = (max)
#define dec_clip(val, dec, min) \
	if (((val) -= (dec)) < (min)) (val) = (min)
d2722 1
a2726 1
		needs_update = 1;
d2730 1
a2734 1
		needs_update = 1;
d2786 1
a2786 1
		if (calib->corr_cck_x4 < 160)
d2788 2
a2789 1
		else
a2792 1
		needs_update = 1;
a2805 1
			needs_update = 1;
a2815 1
			needs_update = 1;
d2849 4
a2852 1
	DPRINTFN(2, ("setting sensitivity\n"));
@


1.5
log
@make sure the length of the first segment of a Tx descriptor is a multiple
of 4 by inserting padding bytes when necessary.
802.11 QoS headers have a length that is not a multiple of 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.4 2007/09/07 19:05:05 damien Exp $	*/
d1576 1
a1576 1
	uint32_t r;
d1578 9
a1586 2
	r = IWN_READ(sc, IWN_INTR);
	if (r == 0 || r == 0xffffffff)
d1588 1
d1590 2
a1591 1
	DPRINTFN(6, ("interrupt reg=%x\n", r));
a1592 2
	/* disable interrupts */
	IWN_WRITE(sc, IWN_MASK, 0);
d1594 4
a1597 1
	IWN_WRITE(sc, IWN_INTR, r);
d1599 1
a1599 1
	if (r & IWN_RF_TOGGLED) {
d1604 1
a1604 1
	if (r & IWN_CT_REACHED) {
d1608 1
a1608 1
	if (r & (IWN_SW_ERROR | IWN_HW_ERROR)) {
d1614 1
a1614 1
	if (r & (IWN_RX_INTR | IWN_SW_RX_INTR))
d1617 1
a1617 1
	if (r & IWN_ALIVE_INTR)
d3394 1
a3394 2
	/* XXX generates way too much interrupts (vmstat -i) !! */
	IWN_WRITE(sc, IWN_INTR_MIT, 0 /* 512 / 32 */);
@


1.4
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.3 2007/09/06 19:33:20 damien Exp $	*/
d1662 1
a1662 1
	int i, rate, error, ovhd = 0;
d1769 7
d1853 1
a1853 1
	IWN_SET_DESC_SEG(desc, 0, paddr, 4 + sizeof (*tx) + hdrlen);
a3382 1
#ifdef notyet
d3385 1
a3385 2
	IWN_WRITE(sc, IWN_INTR_MIT, 512 / 32);
#endif
@


1.3
log
@fix temperature sensor. the sensors framework wants muK not degC!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.2 2007/09/06 16:51:49 damien Exp $	*/
d691 1
a691 1
	    M_NOWAIT);
a697 2
	memset(ring->data, 0, count * sizeof (struct iwn_tx_data));

d778 1
a778 6
	struct iwn_node *wn;

	wn = malloc(sizeof (struct iwn_node), M_DEVBUF, M_NOWAIT);
	if (wn != NULL)
		memset(wn, 0, sizeof (struct iwn_node));
	return (struct ieee80211_node *)wn;
@


1.2
log
@disable interrupts coallescing for now.
it seems to generate way too much interrupts (as reported by vmstat -i)
and i haven't run with it long enough...
it isn't needed anyway since we do not yet support HT rates.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwn.c,v 1.1 2007/09/06 16:37:03 damien Exp $	*/
a361 1
	strlcpy(sc->sensor.desc, "temperature", sizeof sc->sensor.desc);
d1370 1
a1370 1
		sc->sensor.value = temp;
d3509 1
a3509 1
	sc->sensor.value = sc->temp;
@


1.1
log
@new iwn(4) driver for Intel Wireless WiFi Link 4965AGN.
no support for 802.11n functions yet (need work in net80211(9) first).
committed over my 4965AGN, with only 2 of 3 antennas plugged :-)

needs a firmware that is not freely redistributable (see man page).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3384 1
d3386 1
d3388 1
@

