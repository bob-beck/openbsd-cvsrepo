head	1.65;
access;
symbols
	OPENBSD_6_2:1.65.0.6
	OPENBSD_6_2_BASE:1.65
	OPENBSD_6_1:1.65.0.4
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.64.0.4
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.59.0.4
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.57.0.4
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.53.0.2
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.47.0.6
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.4
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.45.0.6
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.4
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.40.0.6
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.4
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.38.0.4
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.38.0.2
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.5;
locks; strict;
comment	@ * @;


1.65
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.64;
commitid	VyLWTsbepAOk7VQM;

1.64
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.63;
commitid	8YSL8ByWzGeIGBiJ;

1.63
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.62;
commitid	B0kwmVGiD5DVx4kv;

1.62
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.61;
commitid	5gdEnqVoJuTuwdTu;

1.61
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.60;
commitid	5DvsamK0GblTp8ww;

1.60
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.59;
commitid	hPF95ClMUQfeqQDX;

1.59
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.58;
commitid	MVWrtktB46JRxFWT;

1.58
date	2015.05.15.11.36.31;	author mpi;	state Exp;
branches;
next	1.57;
commitid	c8Ar0NXQW26UbBN3;

1.57
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.56;
commitid	yM2VFFhpDTeFQlve;

1.56
date	2014.12.08.10.58.45;	author brad;	state Exp;
branches;
next	1.55;
commitid	2lOR2VAGPukFfE5p;

1.55
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.54;
commitid	TGHgrLxu6sxZoiFt;

1.54
date	2013.08.07.01.06.38;	author bluhm;	state Exp;
branches;
next	1.53;

1.53
date	2013.03.14.01.25.38;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2013.03.09.09.34.15;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2013.01.16.06.15.58;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2012.11.29.21.10.32;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2012.11.23.18.40.29;	author gsoares;	state Exp;
branches;
next	1.48;

1.48
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2011.06.22.16.44.27;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2011.04.03.15.36.03;	author jasper;	state Exp;
branches;
next	1.45;

1.45
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.44;

1.44
date	2009.08.10.19.41.05;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.40;

1.40
date	2007.07.17.23.25.15;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2007.07.17.17.15.34;	author jasper;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.08.19.56.38;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.02.05.12.02;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.07.02.57.45;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.10.23.21.05;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.21.06.48.05;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.08.20.30.51;	author beck;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.21.18.04.09;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.30.15.48.15;	author canacar;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.22.18.16.20;	author canacar;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.09.16.33.55;	author canacar;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.06.17.56.36;	author mcbride;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.09.21.52.17;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.29.17.20.03;	author avsm;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.29.13.23.48;	author avsm;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.15.06.31.24;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.06.34.49;	author kjc;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.25.02.18.47;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.20.19.39.45;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.03.05.56.14;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.16.17.08.08;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.27.20.09.42;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.15.02.28.15;	author jason;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.12.08.00.38.08;	author aaron;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.12.08.00.29.26;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	99.12.08.00.09.59;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	99.12.07.20.42.54;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	99.12.07.01.45.29;	author aaron;	state Exp;
branches;
next	;

1.5.2.1
date	2000.02.20.11.57.05;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.05.14.22.25.47;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.07.04.10.42.22;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.5.2.8;

1.5.2.8
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.5.2.9;

1.5.2.9
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	1.5.2.10;

1.5.2.10
date	2004.06.07.20.41.26;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2000.06.28.00.18.12;	author jason;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.65
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_ste.c,v 1.64 2016/04/13 10:34:32 mpi Exp $ */
/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_ste.c,v 1.14 1999/12/07 20:14:42 wpaul Exp $
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <uvm/uvm_extern.h>              /* for vtophys */

#include <sys/device.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#define STE_USEIOSPACE

#include <dev/pci/if_stereg.h>

int	ste_probe(struct device *, void *, void *);
void	ste_attach(struct device *, struct device *, void *);
int	ste_intr(void *);
void	ste_init(void *);
void	ste_rxeoc(struct ste_softc *);
void	ste_rxeof(struct ste_softc *);
void	ste_txeoc(struct ste_softc *);
void	ste_txeof(struct ste_softc *);
void	ste_stats_update(void *);
void	ste_stop(struct ste_softc *);
void	ste_reset(struct ste_softc *);
int	ste_ioctl(struct ifnet *, u_long, caddr_t);
int	ste_encap(struct ste_softc *, struct ste_chain *,
	    struct mbuf *);
void	ste_start(struct ifnet *);
void	ste_watchdog(struct ifnet *);
int	ste_newbuf(struct ste_softc *,
	    struct ste_chain_onefrag *,
	    struct mbuf *);
int	ste_ifmedia_upd(struct ifnet *);
void	ste_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void	ste_mii_sync(struct ste_softc *);
void	ste_mii_send(struct ste_softc *, u_int32_t, int);
int	ste_mii_readreg(struct ste_softc *,
	    struct ste_mii_frame *);
int	ste_mii_writereg(struct ste_softc *,
	    struct ste_mii_frame *);
int	ste_miibus_readreg(struct device *, int, int);
void	ste_miibus_writereg(struct device *, int, int, int);
void	ste_miibus_statchg(struct device *);

int	ste_eeprom_wait(struct ste_softc *);
int	ste_read_eeprom(struct ste_softc *, caddr_t, int,
	    int, int);
void	ste_wait(struct ste_softc *);
void	ste_iff(struct ste_softc *);
int	ste_init_rx_list(struct ste_softc *);
void	ste_init_tx_list(struct ste_softc *);

#define STE_SETBIT4(sc, reg, x)				\
	CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) | x)

#define STE_CLRBIT4(sc, reg, x)				\
	CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) & ~x)

#define STE_SETBIT2(sc, reg, x)				\
	CSR_WRITE_2(sc, reg, CSR_READ_2(sc, reg) | x)

#define STE_CLRBIT2(sc, reg, x)				\
	CSR_WRITE_2(sc, reg, CSR_READ_2(sc, reg) & ~x)

#define STE_SETBIT1(sc, reg, x)				\
	CSR_WRITE_1(sc, reg, CSR_READ_1(sc, reg) | x)

#define STE_CLRBIT1(sc, reg, x)				\
	CSR_WRITE_1(sc, reg, CSR_READ_1(sc, reg) & ~x)


#define MII_SET(x)		STE_SETBIT1(sc, STE_PHYCTL, x)
#define MII_CLR(x)		STE_CLRBIT1(sc, STE_PHYCTL, x) 

const struct pci_matchid ste_devices[] = {
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DFE550TX },
	{ PCI_VENDOR_SUNDANCE, PCI_PRODUCT_SUNDANCE_ST201_1 },
	{ PCI_VENDOR_SUNDANCE, PCI_PRODUCT_SUNDANCE_ST201_2 }
};

struct cfattach ste_ca = {
	sizeof(struct ste_softc), ste_probe, ste_attach
};

struct cfdriver ste_cd = {
	NULL, "ste", DV_IFNET
};

/*
 * Sync the PHYs by setting data bit and strobing the clock 32 times.
 */
void
ste_mii_sync(struct ste_softc *sc)
{
	int		i;

	MII_SET(STE_PHYCTL_MDIR|STE_PHYCTL_MDATA);

	for (i = 0; i < 32; i++) {
		MII_SET(STE_PHYCTL_MCLK);
		DELAY(1);
		MII_CLR(STE_PHYCTL_MCLK);
		DELAY(1);
	}
}

/*
 * Clock a series of bits through the MII.
 */
void
ste_mii_send(struct ste_softc *sc, u_int32_t bits, int cnt)
{
	int		i;

	MII_CLR(STE_PHYCTL_MCLK);

	for (i = (0x1 << (cnt - 1)); i; i >>= 1) {
                if (bits & i) {
			MII_SET(STE_PHYCTL_MDATA);
                } else {
			MII_CLR(STE_PHYCTL_MDATA);
                }
		DELAY(1);
		MII_CLR(STE_PHYCTL_MCLK);
		DELAY(1);
		MII_SET(STE_PHYCTL_MCLK);
	}
}

/*
 * Read an PHY register through the MII.
 */
int
ste_mii_readreg(struct ste_softc *sc, struct ste_mii_frame *frame)
{
	int		ack, i, s;

	s = splnet();

	/*
	 * Set up frame for RX.
	 */
	frame->mii_stdelim = STE_MII_STARTDELIM;
	frame->mii_opcode = STE_MII_READOP;
	frame->mii_turnaround = 0;
	frame->mii_data = 0;
	
	CSR_WRITE_2(sc, STE_PHYCTL, 0);
	/*
 	 * Turn on data xmit.
	 */
	MII_SET(STE_PHYCTL_MDIR);

	ste_mii_sync(sc);

	/*
	 * Send command/address info.
	 */
	ste_mii_send(sc, frame->mii_stdelim, 2);
	ste_mii_send(sc, frame->mii_opcode, 2);
	ste_mii_send(sc, frame->mii_phyaddr, 5);
	ste_mii_send(sc, frame->mii_regaddr, 5);

	/* Turn off xmit. */
	MII_CLR(STE_PHYCTL_MDIR);

	/* Idle bit */
	MII_CLR((STE_PHYCTL_MCLK|STE_PHYCTL_MDATA));
	DELAY(1);
	MII_SET(STE_PHYCTL_MCLK);
	DELAY(1);

	/* Check for ack */
	MII_CLR(STE_PHYCTL_MCLK);
	DELAY(1);
	ack = CSR_READ_2(sc, STE_PHYCTL) & STE_PHYCTL_MDATA;
	MII_SET(STE_PHYCTL_MCLK);
	DELAY(1);

	/*
	 * Now try reading data bits. If the ack failed, we still
	 * need to clock through 16 cycles to keep the PHY(s) in sync.
	 */
	if (ack) {
		for(i = 0; i < 16; i++) {
			MII_CLR(STE_PHYCTL_MCLK);
			DELAY(1);
			MII_SET(STE_PHYCTL_MCLK);
			DELAY(1);
		}
		goto fail;
	}

	for (i = 0x8000; i; i >>= 1) {
		MII_CLR(STE_PHYCTL_MCLK);
		DELAY(1);
		if (!ack) {
			if (CSR_READ_2(sc, STE_PHYCTL) & STE_PHYCTL_MDATA)
				frame->mii_data |= i;
			DELAY(1);
		}
		MII_SET(STE_PHYCTL_MCLK);
		DELAY(1);
	}

fail:

	MII_CLR(STE_PHYCTL_MCLK);
	DELAY(1);
	MII_SET(STE_PHYCTL_MCLK);
	DELAY(1);

	splx(s);

	if (ack)
		return(1);
	return(0);
}

/*
 * Write to a PHY register through the MII.
 */
int
ste_mii_writereg(struct ste_softc *sc, struct ste_mii_frame *frame)
{
	int		s;

	s = splnet();
	/*
	 * Set up frame for TX.
	 */

	frame->mii_stdelim = STE_MII_STARTDELIM;
	frame->mii_opcode = STE_MII_WRITEOP;
	frame->mii_turnaround = STE_MII_TURNAROUND;
	
	/*
 	 * Turn on data output.
	 */
	MII_SET(STE_PHYCTL_MDIR);

	ste_mii_sync(sc);

	ste_mii_send(sc, frame->mii_stdelim, 2);
	ste_mii_send(sc, frame->mii_opcode, 2);
	ste_mii_send(sc, frame->mii_phyaddr, 5);
	ste_mii_send(sc, frame->mii_regaddr, 5);
	ste_mii_send(sc, frame->mii_turnaround, 2);
	ste_mii_send(sc, frame->mii_data, 16);

	/* Idle bit. */
	MII_SET(STE_PHYCTL_MCLK);
	DELAY(1);
	MII_CLR(STE_PHYCTL_MCLK);
	DELAY(1);

	/*
	 * Turn off xmit.
	 */
	MII_CLR(STE_PHYCTL_MDIR);

	splx(s);

	return(0);
}

int
ste_miibus_readreg(struct device *self, int phy, int reg)
{
	struct ste_softc	*sc = (struct ste_softc *)self;
	struct ste_mii_frame	frame;

	if (sc->ste_one_phy && phy != 0)
		return (0);

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	ste_mii_readreg(sc, &frame);

	return(frame.mii_data);
}

void
ste_miibus_writereg(struct device *self, int phy, int reg, int data)
{
	struct ste_softc	*sc = (struct ste_softc *)self;
	struct ste_mii_frame	frame;

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	frame.mii_data = data;

	ste_mii_writereg(sc, &frame);
}

void
ste_miibus_statchg(struct device *self)
{
	struct ste_softc	*sc = (struct ste_softc *)self;
	struct mii_data		*mii;
	int fdx, fcur;

	mii = &sc->sc_mii;

	fcur = CSR_READ_2(sc, STE_MACCTL0) & STE_MACCTL0_FULLDUPLEX;
	fdx = (mii->mii_media_active & IFM_GMASK) == IFM_FDX;

	if ((fcur && fdx) || (! fcur && ! fdx))
		return;

	STE_SETBIT4(sc, STE_DMACTL,
	    STE_DMACTL_RXDMA_STALL |STE_DMACTL_TXDMA_STALL);
	ste_wait(sc);

	if (fdx)
		STE_SETBIT2(sc, STE_MACCTL0, STE_MACCTL0_FULLDUPLEX);
	else
		STE_CLRBIT2(sc, STE_MACCTL0, STE_MACCTL0_FULLDUPLEX);

	STE_SETBIT4(sc, STE_DMACTL,
	    STE_DMACTL_RXDMA_UNSTALL | STE_DMACTL_TXDMA_UNSTALL);
}
 
int
ste_ifmedia_upd(struct ifnet *ifp)
{
	struct ste_softc	*sc;
	struct mii_data		*mii;

	sc = ifp->if_softc;
	mii = &sc->sc_mii;
	sc->ste_link = 0;
	if (mii->mii_instance) {
		struct mii_softc	*miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	mii_mediachg(mii);

	return(0);
}

void
ste_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct ste_softc	*sc;
	struct mii_data		*mii;

	sc = ifp->if_softc;
	mii = &sc->sc_mii;

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

void
ste_wait(struct ste_softc *sc)
{
	int		i;

	for (i = 0; i < STE_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, STE_DMACTL) & STE_DMACTL_DMA_HALTINPROG))
			break;
	}

	if (i == STE_TIMEOUT)
		printf("%s: command never completed!\n", sc->sc_dev.dv_xname);
}

/*
 * The EEPROM is slow: give it time to come ready after issuing
 * it a command.
 */
int
ste_eeprom_wait(struct ste_softc *sc)
{
	int		i;

	DELAY(1000);

	for (i = 0; i < 100; i++) {
		if (CSR_READ_2(sc, STE_EEPROM_CTL) & STE_EECTL_BUSY)
			DELAY(1000);
		else
			break;
	}

	if (i == 100) {
		printf("%s: eeprom failed to come ready\n",
		    sc->sc_dev.dv_xname);
		return(1);
	}

	return(0);
}

/*
 * Read a sequence of words from the EEPROM. Note that ethernet address
 * data is stored in the EEPROM in network byte order.
 */
int
ste_read_eeprom(struct ste_softc *sc, caddr_t dest, int off, int cnt, int swap)
{
	int			err = 0, i;
	u_int16_t		word = 0, *ptr;

	if (ste_eeprom_wait(sc))
		return(1);

	for (i = 0; i < cnt; i++) {
		CSR_WRITE_2(sc, STE_EEPROM_CTL, STE_EEOPCODE_READ | (off + i));
		err = ste_eeprom_wait(sc);
		if (err)
			break;
		word = CSR_READ_2(sc, STE_EEPROM_DATA);
		ptr = (u_int16_t *)(dest + (i * 2));
		if (swap)
			*ptr = ntohs(word);
		else
			*ptr = word;	
	}

	return(err ? 1 : 0);
}

void
ste_iff(struct ste_softc *sc)
{
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	u_int32_t		rxmode, hashes[2];
	int			h = 0;

	rxmode = CSR_READ_1(sc, STE_RX_MODE);
	rxmode &= ~(STE_RXMODE_ALLMULTI | STE_RXMODE_BROADCAST |
	    STE_RXMODE_MULTIHASH | STE_RXMODE_PROMISC |
	    STE_RXMODE_UNICAST);
	bzero(hashes, sizeof(hashes));
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept broadcast frames.
	 * Always accept frames destined to our station address.
	 */
	rxmode |= STE_RXMODE_BROADCAST | STE_RXMODE_UNICAST;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxmode |= STE_RXMODE_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxmode |= STE_RXMODE_PROMISC;
	} else {
		rxmode |= STE_RXMODE_MULTIHASH;

		/* now program new ones */
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) & 0x3F;

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	CSR_WRITE_2(sc, STE_MAR0, hashes[0] & 0xFFFF);
	CSR_WRITE_2(sc, STE_MAR1, (hashes[0] >> 16) & 0xFFFF);
	CSR_WRITE_2(sc, STE_MAR2, hashes[1] & 0xFFFF);
	CSR_WRITE_2(sc, STE_MAR3, (hashes[1] >> 16) & 0xFFFF);
	CSR_WRITE_1(sc, STE_RX_MODE, rxmode);
}

int
ste_intr(void *xsc)
{
	struct ste_softc	*sc;
	struct ifnet		*ifp;
	u_int16_t		status;
	int			claimed = 0;

	sc = xsc;
	ifp = &sc->arpcom.ac_if;

	/* See if this is really our interrupt. */
	if (!(CSR_READ_2(sc, STE_ISR) & STE_ISR_INTLATCH))
		return claimed;

	for (;;) {
		status = CSR_READ_2(sc, STE_ISR_ACK);

		if (!(status & STE_INTRS))
			break;

		claimed = 1;

		if (status & STE_ISR_RX_DMADONE) {
			ste_rxeoc(sc);
			ste_rxeof(sc);
		}

		if (status & STE_ISR_TX_DMADONE)
			ste_txeof(sc);

		if (status & STE_ISR_TX_DONE)
			ste_txeoc(sc);

		if (status & STE_ISR_STATS_OFLOW) {
			timeout_del(&sc->sc_stats_tmo);
			ste_stats_update(sc);
		}

		if (status & STE_ISR_LINKEVENT)
			mii_pollstat(&sc->sc_mii);

		if (status & STE_ISR_HOSTERR)
			ste_init(sc);
	}

	/* Re-enable interrupts */
	CSR_WRITE_2(sc, STE_IMR, STE_INTRS);

	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
		ste_start(ifp);

	return claimed;
}

void
ste_rxeoc(struct ste_softc *sc)
{
	struct ste_chain_onefrag *cur_rx;

	if (sc->ste_cdata.ste_rx_head->ste_ptr->ste_status == 0) {
		cur_rx = sc->ste_cdata.ste_rx_head;
		do {
			cur_rx = cur_rx->ste_next;
			/* If the ring is empty, just return. */
			if (cur_rx == sc->ste_cdata.ste_rx_head)
				return;
		} while (cur_rx->ste_ptr->ste_status == 0);
		if (sc->ste_cdata.ste_rx_head->ste_ptr->ste_status == 0) {
			/* We've fallen behind the chip: catch it. */
			sc->ste_cdata.ste_rx_head = cur_rx;
		}
	}
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
ste_rxeof(struct ste_softc *sc)
{
        struct mbuf		*m;
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
        struct ifnet		*ifp;
	struct ste_chain_onefrag	*cur_rx;
	int			total_len = 0, count=0;
	u_int32_t		rxstat;

	ifp = &sc->arpcom.ac_if;

	while((rxstat = sc->ste_cdata.ste_rx_head->ste_ptr->ste_status)
	      & STE_RXSTAT_DMADONE) {
		if ((STE_RX_LIST_CNT - count) < 3)
			break;

		cur_rx = sc->ste_cdata.ste_rx_head;
		sc->ste_cdata.ste_rx_head = cur_rx->ste_next;

		/*
		 * If an error occurs, update stats, clear the
		 * status word and leave the mbuf cluster in place:
		 * it should simply get re-used next time this descriptor
	 	 * comes up in the ring.
		 */
		if (rxstat & STE_RXSTAT_FRAME_ERR) {
			ifp->if_ierrors++;
			cur_rx->ste_ptr->ste_status = 0;
			continue;
		}

		/*
		 * If there error bit was not set, the upload complete
		 * bit should be set which means we have a valid packet.
		 * If not, something truly strange has happened.
		 */
		if (!(rxstat & STE_RXSTAT_DMADONE)) {
			printf("%s: bad receive status -- packet dropped",
				sc->sc_dev.dv_xname);
			ifp->if_ierrors++;
			cur_rx->ste_ptr->ste_status = 0;
			continue;
		}

		/* No errors; receive the packet. */	
		m = cur_rx->ste_mbuf;
		total_len = cur_rx->ste_ptr->ste_status & STE_RXSTAT_FRAMELEN;

		/*
		 * Try to conjure up a new mbuf cluster. If that
		 * fails, it means we have an out of memory condition and
		 * should leave the buffer in place and continue. This will
		 * result in a lost packet, but there's little else we
		 * can do in this situation.
		 */
		if (ste_newbuf(sc, cur_rx, NULL) == ENOBUFS) {
			ifp->if_ierrors++;
			cur_rx->ste_ptr->ste_status = 0;
			continue;
		}

		m->m_pkthdr.len = m->m_len = total_len;

		ml_enqueue(&ml, m);

		cur_rx->ste_ptr->ste_status = 0;
		count++;
	}

	if_input(ifp, &ml);
}

void
ste_txeoc(struct ste_softc *sc)
{
	u_int8_t		txstat;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	while ((txstat = CSR_READ_1(sc, STE_TX_STATUS)) &
	    STE_TXSTATUS_TXDONE) {
		if (txstat & STE_TXSTATUS_UNDERRUN ||
		    txstat & STE_TXSTATUS_EXCESSCOLLS ||
		    txstat & STE_TXSTATUS_RECLAIMERR) {
			ifp->if_oerrors++;
			printf("%s: transmission error: %x\n",
			    sc->sc_dev.dv_xname, txstat);

			ste_init(sc);

			if (txstat & STE_TXSTATUS_UNDERRUN &&
			    sc->ste_tx_thresh < ETHER_MAX_DIX_LEN) {
				sc->ste_tx_thresh += STE_MIN_FRAMELEN;
				printf("%s: tx underrun, increasing tx"
				    " start threshold to %d bytes\n",
				    sc->sc_dev.dv_xname, sc->ste_tx_thresh);
			}
			CSR_WRITE_2(sc, STE_TX_STARTTHRESH, sc->ste_tx_thresh);
			CSR_WRITE_2(sc, STE_TX_RECLAIM_THRESH,
			    (ETHER_MAX_DIX_LEN >> 4));
		}
		ste_init(sc);
		CSR_WRITE_2(sc, STE_TX_STATUS, txstat);
	}
}

void
ste_txeof(struct ste_softc *sc)
{
	struct ste_chain	*cur_tx = NULL;
	struct ifnet		*ifp;
	int			idx;

	ifp = &sc->arpcom.ac_if;

	idx = sc->ste_cdata.ste_tx_cons;
	while(idx != sc->ste_cdata.ste_tx_prod) {
		cur_tx = &sc->ste_cdata.ste_tx_chain[idx];

		if (!(cur_tx->ste_ptr->ste_ctl & STE_TXCTL_DMADONE))
			break;

		m_freem(cur_tx->ste_mbuf);
		cur_tx->ste_mbuf = NULL;
		ifq_clr_oactive(&ifp->if_snd);

		STE_INC(idx, STE_TX_LIST_CNT);
	}

	sc->ste_cdata.ste_tx_cons = idx;
	if (idx == sc->ste_cdata.ste_tx_prod)
		ifp->if_timer = 0;
}

void
ste_stats_update(void *xsc)
{
	struct ste_softc	*sc;
	struct ifnet		*ifp;
	struct mii_data		*mii;
	int			s;

	s = splnet();

	sc = xsc;
	ifp = &sc->arpcom.ac_if;
	mii = &sc->sc_mii;

	ifp->if_collisions += CSR_READ_1(sc, STE_LATE_COLLS)
	    + CSR_READ_1(sc, STE_MULTI_COLLS)
	    + CSR_READ_1(sc, STE_SINGLE_COLLS);

	if (!sc->ste_link) {
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
			sc->ste_link++;
			/*
			 * we don't get a call-back on re-init so do it
			 * otherwise we get stuck in the wrong link state
			 */
			ste_miibus_statchg((struct device *)sc);
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
				ste_start(ifp);
		}
	}

	timeout_add_sec(&sc->sc_stats_tmo, 1);
	splx(s);
}

/*
 * Probe for a Sundance ST201 chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
ste_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, ste_devices,
	    nitems(ste_devices)));
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
ste_attach(struct device *parent, struct device *self, void *aux)
{
	const char		*intrstr = NULL;
	struct ste_softc	*sc = (struct ste_softc *)self;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	pci_intr_handle_t	ih;
	struct ifnet		*ifp;
	bus_size_t		size;

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Only use one PHY since this chip reports multiple
	 * Note on the DFE-550TX the PHY is at 1 on the DFE-580TX
	 * it is at 0 & 1.  It is rev 0x12.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DLINK &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DLINK_DFE550TX &&
	    PCI_REVISION(pa->pa_class) == 0x12)
		sc->ste_one_phy = 1;

	/*
	 * Map control/status registers.
	 */

#ifdef STE_USEIOSPACE
	if (pci_mapreg_map(pa, STE_PCI_LOIO,
	    PCI_MAPREG_TYPE_IO, 0,
	    &sc->ste_btag, &sc->ste_bhandle, NULL, &size, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
 #else
	if (pci_mapreg_map(pa, STE_PCI_LOMEM,
	    PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &sc->ste_btag, &sc->ste_bhandle, NULL, &size, 0)) {
		printf(": can't map mem space\n");
		return;
	}
#endif

	/* Allocate interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, ste_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}
	printf(": %s", intrstr);

	/* Reset the adapter. */
	ste_reset(sc);

	/*
	 * Get station address from the EEPROM.
	 */
	if (ste_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
	    STE_EEADDR_NODE0, 3, 0)) {
		printf(": failed to read station address\n");
		goto fail_2;
	}

	printf(", address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));

	sc->ste_ldata_ptr = malloc(sizeof(struct ste_list_data) + 8,
	    M_DEVBUF, M_DONTWAIT);
	if (sc->ste_ldata_ptr == NULL) {
		printf(": no memory for list buffers!\n");
		goto fail_2;
	}

	sc->ste_ldata = (struct ste_list_data *)sc->ste_ldata_ptr;
	bzero(sc->ste_ldata, sizeof(struct ste_list_data));

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = ste_ioctl;
	ifp->if_start = ste_start;
	ifp->if_watchdog = ste_watchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, STE_TX_LIST_CNT - 1);
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_capabilities = IFCAP_VLAN_MTU;

	sc->ste_tx_thresh = STE_TXSTART_THRESH;

	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = ste_miibus_readreg;
	sc->sc_mii.mii_writereg = ste_miibus_writereg;
	sc->sc_mii.mii_statchg = ste_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, ste_ifmedia_upd,ste_ifmedia_sts);
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
	return;

fail_2:
	pci_intr_disestablish(pc, sc->sc_ih);

fail_1:
	bus_space_unmap(sc->ste_btag, sc->ste_bhandle, size);
}

int
ste_newbuf(struct ste_softc *sc, struct ste_chain_onefrag *c, struct mbuf *m)
{
	struct mbuf		*m_new = NULL;

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return(ENOBUFS);
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return(ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_adj(m_new, ETHER_ALIGN);

	c->ste_mbuf = m_new;
	c->ste_ptr->ste_status = 0;
	c->ste_ptr->ste_frag.ste_addr = vtophys(mtod(m_new, vaddr_t));
	c->ste_ptr->ste_frag.ste_len = (ETHER_MAX_DIX_LEN + ETHER_VLAN_ENCAP_LEN) | STE_FRAG_LAST;

	return(0);
}

int
ste_init_rx_list(struct ste_softc *sc)
{
	struct ste_chain_data	*cd;
	struct ste_list_data	*ld;
	int			i;

	cd = &sc->ste_cdata;
	ld = sc->ste_ldata;

	for (i = 0; i < STE_RX_LIST_CNT; i++) {
		cd->ste_rx_chain[i].ste_ptr = &ld->ste_rx_list[i];
		if (ste_newbuf(sc, &cd->ste_rx_chain[i], NULL) == ENOBUFS)
			return(ENOBUFS);
		if (i == (STE_RX_LIST_CNT - 1)) {
			cd->ste_rx_chain[i].ste_next =
			    &cd->ste_rx_chain[0];
			ld->ste_rx_list[i].ste_next =
			    vtophys((vaddr_t)&ld->ste_rx_list[0]);
		} else {
			cd->ste_rx_chain[i].ste_next =
			    &cd->ste_rx_chain[i + 1];
			ld->ste_rx_list[i].ste_next =
			    vtophys((vaddr_t)&ld->ste_rx_list[i + 1]);
		}
		ld->ste_rx_list[i].ste_status = 0;
	}

	cd->ste_rx_head = &cd->ste_rx_chain[0];

	return(0);
}

void
ste_init_tx_list(struct ste_softc *sc)
{
	struct ste_chain_data	*cd;
	struct ste_list_data	*ld;
	int			i;

	cd = &sc->ste_cdata;
	ld = sc->ste_ldata;
	for (i = 0; i < STE_TX_LIST_CNT; i++) {
		cd->ste_tx_chain[i].ste_ptr = &ld->ste_tx_list[i];
		cd->ste_tx_chain[i].ste_phys = vtophys((vaddr_t)&ld->ste_tx_list[i]);
		if (i == (STE_TX_LIST_CNT - 1))
			cd->ste_tx_chain[i].ste_next =
			    &cd->ste_tx_chain[0];
		else
			cd->ste_tx_chain[i].ste_next =
			    &cd->ste_tx_chain[i + 1];
	}

	bzero(ld->ste_tx_list, sizeof(struct ste_desc) * STE_TX_LIST_CNT);

	cd->ste_tx_prod = 0;
	cd->ste_tx_cons = 0;
}

void
ste_init(void *xsc)
{
	struct ste_softc	*sc = (struct ste_softc *)xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct mii_data		*mii;
	int			i, s;

	s = splnet();

	ste_stop(sc);
	/* Reset the chip to a known state. */
	ste_reset(sc);

	mii = &sc->sc_mii;

	/* Init our MAC address */
	for (i = 0; i < ETHER_ADDR_LEN; i++) {
		CSR_WRITE_1(sc, STE_PAR0 + i, sc->arpcom.ac_enaddr[i]);
	}

	/* Init RX list */
	if (ste_init_rx_list(sc) == ENOBUFS) {
		printf("%s: initialization failed: no "
		    "memory for RX buffers\n", sc->sc_dev.dv_xname);
		ste_stop(sc);
		splx(s);
		return;
	}

	/* Set RX polling interval */
	CSR_WRITE_1(sc, STE_RX_DMAPOLL_PERIOD, 64);

	/* Init TX descriptors */
	ste_init_tx_list(sc);

	/* Set the TX freethresh value */
	CSR_WRITE_1(sc, STE_TX_DMABURST_THRESH, ETHER_MAX_DIX_LEN >> 8);

	/* Set the TX start threshold for best performance. */
	CSR_WRITE_2(sc, STE_TX_STARTTHRESH, sc->ste_tx_thresh);

	/* Set the TX reclaim threshold. */
	CSR_WRITE_1(sc, STE_TX_RECLAIM_THRESH, (ETHER_MAX_DIX_LEN >> 4));

	/* Program promiscuous mode and multicast filters. */
	ste_iff(sc);

	/* Load the address of the RX list. */
	STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_RXDMA_STALL);
	ste_wait(sc);
	CSR_WRITE_4(sc, STE_RX_DMALIST_PTR,
	    vtophys((vaddr_t)&sc->ste_ldata->ste_rx_list[0]));
	STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_RXDMA_UNSTALL);
	STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_RXDMA_UNSTALL);

	/* Set TX polling interval (defer until we TX first packet) */
	CSR_WRITE_1(sc, STE_TX_DMAPOLL_PERIOD, 0);

	/* Load address of the TX list */
	STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_TXDMA_STALL);
	ste_wait(sc);
	CSR_WRITE_4(sc, STE_TX_DMALIST_PTR, 0);
	STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_TXDMA_UNSTALL);
	STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_TXDMA_UNSTALL);
	ste_wait(sc);
	sc->ste_tx_prev=NULL;

	/* Enable receiver and transmitter */
	CSR_WRITE_2(sc, STE_MACCTL0, 0);
	CSR_WRITE_2(sc, STE_MACCTL1, 0);
	STE_SETBIT2(sc, STE_MACCTL1, STE_MACCTL1_TX_ENABLE);
	STE_SETBIT2(sc, STE_MACCTL1, STE_MACCTL1_RX_ENABLE);

	/* Enable stats counters. */
	STE_SETBIT2(sc, STE_MACCTL1, STE_MACCTL1_STATS_ENABLE);

	/* Enable interrupts. */
	CSR_WRITE_2(sc, STE_ISR, 0xFFFF);
	CSR_WRITE_2(sc, STE_IMR, STE_INTRS);

	/* Accept VLAN length packets */
	CSR_WRITE_2(sc, STE_MAX_FRAMELEN,
	    ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);

	ste_ifmedia_upd(ifp);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_set(&sc->sc_stats_tmo, ste_stats_update, sc);
	timeout_add_sec(&sc->sc_stats_tmo, 1);
}

void
ste_stop(struct ste_softc *sc)
{
	int			i;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	timeout_del(&sc->sc_stats_tmo);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	CSR_WRITE_2(sc, STE_IMR, 0);
	STE_SETBIT2(sc, STE_MACCTL1, STE_MACCTL1_TX_DISABLE);
	STE_SETBIT2(sc, STE_MACCTL1, STE_MACCTL1_RX_DISABLE);
	STE_SETBIT2(sc, STE_MACCTL1, STE_MACCTL1_STATS_DISABLE);
	STE_SETBIT2(sc, STE_DMACTL, STE_DMACTL_TXDMA_STALL);
	STE_SETBIT2(sc, STE_DMACTL, STE_DMACTL_RXDMA_STALL);
	ste_wait(sc);
	/* 
	 * Try really hard to stop the RX engine or under heavy RX 
	 * data chip will write into de-allocated memory.
	 */
	ste_reset(sc);

	sc->ste_link = 0;

	for (i = 0; i < STE_RX_LIST_CNT; i++) {
		if (sc->ste_cdata.ste_rx_chain[i].ste_mbuf != NULL) {
			m_freem(sc->ste_cdata.ste_rx_chain[i].ste_mbuf);
			sc->ste_cdata.ste_rx_chain[i].ste_mbuf = NULL;
		}
	}

	for (i = 0; i < STE_TX_LIST_CNT; i++) {
		if (sc->ste_cdata.ste_tx_chain[i].ste_mbuf != NULL) {
			m_freem(sc->ste_cdata.ste_tx_chain[i].ste_mbuf);
			sc->ste_cdata.ste_tx_chain[i].ste_mbuf = NULL;
		}
	}

	bzero(sc->ste_ldata, sizeof(struct ste_list_data));
}

void
ste_reset(struct ste_softc *sc)
{
	int		i;

	STE_SETBIT4(sc, STE_ASICCTL,
	    STE_ASICCTL_GLOBAL_RESET|STE_ASICCTL_RX_RESET|
	    STE_ASICCTL_TX_RESET|STE_ASICCTL_DMA_RESET|
	    STE_ASICCTL_FIFO_RESET|STE_ASICCTL_NETWORK_RESET|
	    STE_ASICCTL_AUTOINIT_RESET|STE_ASICCTL_HOST_RESET|
	    STE_ASICCTL_EXTRESET_RESET);

	DELAY(100000);

	for (i = 0; i < STE_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, STE_ASICCTL) & STE_ASICCTL_RESET_BUSY))
			break;
	}

	if (i == STE_TIMEOUT)
		printf("%s: global reset never completed\n",
		    sc->sc_dev.dv_xname);
}

int
ste_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct ste_softc	*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
	int			s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			ste_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else {
				sc->ste_tx_thresh = STE_TXSTART_THRESH;
				ste_init(sc);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				ste_stop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			ste_iff(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

int
ste_encap(struct ste_softc *sc, struct ste_chain *c, struct mbuf *m_head)
{
	int			frag = 0;
	struct ste_frag		*f = NULL;
	struct mbuf		*m;
	struct ste_desc		*d;

	d = c->ste_ptr;
	d->ste_ctl = 0;

encap_retry:
	for (m = m_head, frag = 0; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if (frag == STE_MAXFRAGS)
				break;
			f = &d->ste_frags[frag];
			f->ste_addr = vtophys(mtod(m, vaddr_t));
			f->ste_len = m->m_len;
			frag++;
		}
	}

	if (m != NULL) {
		struct mbuf *mn;
  	 
		/*
		 * We ran out of segments. We have to recopy this
		 * mbuf chain first. Bail out if we can't get the
		 * new buffers.
		 */
		MGETHDR(mn, M_DONTWAIT, MT_DATA);
		if (mn == NULL) {
			m_freem(m_head);
			return ENOMEM;
		}
		if (m_head->m_pkthdr.len > MHLEN) {
			MCLGET(mn, M_DONTWAIT);
			if ((mn->m_flags & M_EXT) == 0) {
				m_freem(mn);
				m_freem(m_head);
				return ENOMEM;
			}
		}
		m_copydata(m_head, 0, m_head->m_pkthdr.len,
			   mtod(mn, caddr_t));
		mn->m_pkthdr.len = mn->m_len = m_head->m_pkthdr.len;
		m_freem(m_head);
		m_head = mn;
		goto encap_retry;
	}

	c->ste_mbuf = m_head;
	d->ste_frags[frag - 1].ste_len |= STE_FRAG_LAST;
	d->ste_ctl = 1;

	return(0);
}

void
ste_start(struct ifnet *ifp)
{
	struct ste_softc	*sc;
	struct mbuf		*m_head = NULL;
	struct ste_chain	*cur_tx;
	int			idx;

	sc = ifp->if_softc;

	if (!sc->ste_link)
		return;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	idx = sc->ste_cdata.ste_tx_prod;

	while(sc->ste_cdata.ste_tx_chain[idx].ste_mbuf == NULL) {
		/*
		 * We cannot re-use the last (free) descriptor;
		 * the chip may not have read its ste_next yet.
		 */
		if (STE_NEXT(idx, STE_TX_LIST_CNT) ==
		    sc->ste_cdata.ste_tx_cons) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		if (m_head == NULL)
			break;

		cur_tx = &sc->ste_cdata.ste_tx_chain[idx];

		if (ste_encap(sc, cur_tx, m_head) != 0)
			break;

		cur_tx->ste_ptr->ste_next = 0;

		if (sc->ste_tx_prev == NULL) {
			cur_tx->ste_ptr->ste_ctl = STE_TXCTL_DMAINTR | 1;
			/* Load address of the TX list */
			STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_TXDMA_STALL);
			ste_wait(sc);

			CSR_WRITE_4(sc, STE_TX_DMALIST_PTR,
			    vtophys((vaddr_t)&sc->ste_ldata->ste_tx_list[0]));

			/* Set TX polling interval to start TX engine */
			CSR_WRITE_1(sc, STE_TX_DMAPOLL_PERIOD, 64);
		  
			STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_TXDMA_UNSTALL);
			ste_wait(sc);
		}else{
			cur_tx->ste_ptr->ste_ctl = STE_TXCTL_DMAINTR | 1;
			sc->ste_tx_prev->ste_ptr->ste_next
				= cur_tx->ste_phys;
		}

		sc->ste_tx_prev = cur_tx;

#if NBPFILTER > 0
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
	 	 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, cur_tx->ste_mbuf,
			    BPF_DIRECTION_OUT);
#endif

		STE_INC(idx, STE_TX_LIST_CNT);
		ifp->if_timer = 5;
	}
	sc->ste_cdata.ste_tx_prod = idx;
}

void
ste_watchdog(struct ifnet *ifp)
{
	struct ste_softc	*sc;

	sc = ifp->if_softc;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);

	ste_txeoc(sc);
	ste_txeof(sc);
	ste_rxeoc(sc);
	ste_rxeof(sc);
	ste_init(sc);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		ste_start(ifp);
}
@


1.64
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.63 2015/11/25 03:09:59 dlg Exp $ */
a751 1
		ifp->if_opackets++;
@


1.63
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.62 2015/11/24 17:11:39 mpi Exp $ */
a904 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.62
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.61 2015/11/24 13:33:17 mpi Exp $ */
d751 1
a751 1
		ifp->if_flags &= ~IFF_OACTIVE;
d1116 1
a1116 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1134 2
a1135 1
	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);
d1314 1
a1314 1
	if (ifp->if_flags & IFF_OACTIVE)
d1326 1
a1326 1
			ifp->if_flags |= IFF_OACTIVE;
@


1.61
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.60 2015/10/25 13:04:28 mpi Exp $ */
a49 1
#include <net/if_dl.h>
@


1.60
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.59 2015/06/24 09:40:54 mpi Exp $ */
a50 1
#include <net/if_types.h>
@


1.59
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.58 2015/05/15 11:36:31 mpi Exp $ */
a1197 1
	struct ifaddr		*ifa = (struct ifaddr *) data;
a1207 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
@


1.58
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.57 2014/12/22 02:28:52 tedu Exp $ */
a691 1
		ifp->if_ipackets++;
@


1.57
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.56 2014/12/08 10:58:45 brad Exp $ */
d631 1
a688 1
		m->m_pkthdr.rcvif = ifp;
d691 1
a693 8
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		/* pass it on. */
		ether_input_mbuf(ifp, m);

d697 2
@


1.56
log
@Have foo_init() call foo_reset() to reset the chip to a known state
as is the case for a lot of the other drivers. Remove some redundant
calls to foo_stop() and foo_reset() before foo_init().

Tested with DP83815, 3c905C, 8139 and ST201.
Mostly from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.55 2014/07/22 13:12:11 mpi Exp $ */
a52 1
#ifdef INET
a54 1
#endif
a1214 1
#ifdef INET
a1216 1
#endif
@


1.55
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.54 2013/08/07 01:06:38 bluhm Exp $ */
d592 1
a592 2
		if (status & STE_ISR_HOSTERR) {
			ste_reset(sc);
a593 1
		}
a724 1
			ste_reset(sc);
d1049 2
a1406 1
	ste_reset(sc);
@


1.54
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.53 2013/03/14 01:25:38 brad Exp $ */
a54 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.53
log
@- Remove return at the end of void functions
- Move the PCI devices table up to the top
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.52 2013/03/09 09:34:15 brad Exp $ */
a55 1
#include <netinet/in_var.h>
@


1.52
log
@Rewrite the receive filter handling code and cleanup the ioctl bits.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.51 2013/01/16 06:15:58 brad Exp $ */
d144 6
a173 2

	return;
a366 2

	return;
a394 2

	return;
a427 2

	return;
a441 2

	return;
a710 2

	return;
a746 2

	return;
a775 2

	return;
a812 2

	return;
a814 6
const struct pci_matchid ste_devices[] = {
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DFE550TX },
	{ PCI_VENDOR_SUNDANCE, PCI_PRODUCT_SUNDANCE_ST201_1 },
	{ PCI_VENDOR_SUNDANCE, PCI_PRODUCT_SUNDANCE_ST201_2 }
};	

a1041 2

	return;
a1135 2

	return;
a1179 2

	return;
a1394 2

	return;
a1415 2

	return;
@


1.51
log
@Some corrections for D-Link device names.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.50 2012/11/29 21:10:32 brad Exp $ */
d118 1
a118 1
void	ste_setmulti(struct ste_softc *);
d505 1
a505 1
ste_setmulti(struct ste_softc *sc)
d507 1
a507 1
	struct ifnet		*ifp;
d511 1
a512 1
	u_int32_t		hashes[2] = { 0, 0 };
d514 31
a544 7
	ifp = &sc->arpcom.ac_if;
allmulti:
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		STE_SETBIT1(sc, STE_RX_MODE, STE_RXMODE_ALLMULTI);
		STE_CLRBIT1(sc, STE_RX_MODE, STE_RXMODE_MULTIHASH);
		return;
	}
d546 1
a546 12
	/* first, zot all the existing hash bits */
	CSR_WRITE_2(sc, STE_MAR0, 0);
	CSR_WRITE_2(sc, STE_MAR1, 0);
	CSR_WRITE_2(sc, STE_MAR2, 0);
	CSR_WRITE_2(sc, STE_MAR3, 0);

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
a547 6
		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) & 0x3F;
		if (h < 32)
			hashes[0] |= (1 << h);
		else
			hashes[1] |= (1 << (h - 32));
		ETHER_NEXT_MULTI(step, enm);
d554 1
a554 4
	STE_CLRBIT1(sc, STE_RX_MODE, STE_RXMODE_ALLMULTI);
	STE_SETBIT1(sc, STE_RX_MODE, STE_RXMODE_MULTIHASH);

	return;
d1107 2
a1108 18
	/* Set up the RX filter. */
	CSR_WRITE_1(sc, STE_RX_MODE, STE_RXMODE_UNICAST);

	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC) {
		STE_SETBIT1(sc, STE_RX_MODE, STE_RXMODE_PROMISC);
	} else {
		STE_CLRBIT1(sc, STE_RX_MODE, STE_RXMODE_PROMISC);
	}

	/* Set capture broadcast bit to accept broadcast frames. */
	if (ifp->if_flags & IFF_BROADCAST) {
		STE_SETBIT1(sc, STE_RX_MODE, STE_RXMODE_BROADCAST);
	} else {
		STE_CLRBIT1(sc, STE_RX_MODE, STE_RXMODE_BROADCAST);
	}

	ste_setmulti(sc);
a1235 1
	struct mii_data		*mii;
d1243 1
a1243 2
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
d1245 2
d1248 1
a1248 5
			break;
		default:
			ste_init(sc);
			break;
		}
d1253 3
a1255 15
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->ste_if_flags & IFF_PROMISC)) {
				STE_SETBIT1(sc, STE_RX_MODE,
				    STE_RXMODE_PROMISC);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->ste_if_flags & IFF_PROMISC) {
				STE_CLRBIT1(sc, STE_RX_MODE,
				    STE_RXMODE_PROMISC);
			}
			if (ifp->if_flags & IFF_RUNNING &&
			    (ifp->if_flags ^ sc->ste_if_flags) & IFF_ALLMULTI)
				ste_setmulti(sc);
			if (!(ifp->if_flags & IFF_RUNNING)) {
a1262 2
		sc->ste_if_flags = ifp->if_flags;
		error = 0;
d1267 1
a1267 2
		mii = &sc->sc_mii;
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
d1276 1
a1276 1
			ste_setmulti(sc);
@


1.50
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.49 2012/11/23 18:40:29 gsoares Exp $ */
d824 1
d826 1
a826 2
	{ PCI_VENDOR_SUNDANCE, PCI_PRODUCT_SUNDANCE_ST201_2 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_550TX }
d859 1
a859 1
	 * Note on the DFE-550 the PHY is at 1 on the DFE-580
d863 1
a863 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DLINK_550TX &&
@


1.49
log
@set ifp->if_baudrate with IF_Gbps() / IF_Mbps().

OK reyk@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.48 2012/10/18 21:44:21 deraadt Exp $ */
a933 1
	ifp->if_baudrate = IF_Mbps(10);
@


1.48
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.47 2011/06/22 16:44:27 tedu Exp $ */
d934 1
a934 1
	ifp->if_baudrate = 10000000;
@


1.47
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.46 2011/04/03 15:36:03 jasper Exp $ */
a847 1
	pcireg_t		command;
d855 1
a855 27
	/*
	 * Handle power management nonsense.
	 */
	command = pci_conf_read(pc, pa->pa_tag, STE_PCI_CAPID) & 0x000000FF;
	if (command == 0x01) {

		command = pci_conf_read(pc, pa->pa_tag, STE_PCI_PWRMGMTCTRL);
		if (command & STE_PSTATE_MASK) {
			u_int32_t		iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(pc, pa->pa_tag, STE_PCI_LOIO);
			membase = pci_conf_read(pc, pa->pa_tag, STE_PCI_LOMEM);
			irq = pci_conf_read(pc, pa->pa_tag, STE_PCI_INTLINE);

			/* Reset the power state. */
			printf("%s: chip is in D%d power mode -- setting to D0\n",
				sc->sc_dev.dv_xname, command & STE_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag, STE_PCI_PWRMGMTCTRL, command);

			/* Restore PCI config data. */
			pci_conf_write(pc, pa->pa_tag, STE_PCI_LOIO, iobase);
			pci_conf_write(pc, pa->pa_tag, STE_PCI_LOMEM, membase);
			pci_conf_write(pc, pa->pa_tag, STE_PCI_INTLINE, irq);
		}
	}
@


1.46
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.45 2009/08/13 14:24:47 jasper Exp $ */
d341 1
a341 1
	bzero((char *)&frame, sizeof(frame));
d356 1
a356 1
	bzero((char *)&frame, sizeof(frame));
d1080 1
a1080 2
	bzero((char *)ld->ste_tx_list,
	    sizeof(struct ste_desc) * STE_TX_LIST_CNT);
@


1.45
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.44 2009/08/10 19:41:05 deraadt Exp $ */
d837 1
a837 1
	    sizeof(ste_devices)/sizeof(ste_devices[0])));
@


1.44
log
@A few more simple cases of shutdown hooks which only call xxstop, when
we now know the interface has already been stopped
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.43 2008/11/28 02:44:18 brad Exp $ */
d149 1
a149 1
	0, "ste", DV_IFNET
@


1.43
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.42 2008/10/02 20:21:14 brad Exp $ */
a84 1
void	ste_shutdown(void *);
a986 2

	shutdownhook_establish(ste_shutdown, sc);
a1503 8
}

void
ste_shutdown(void *v)
{
	struct ste_softc	*sc = (struct ste_softc *)v;

	ste_stop(sc);
@


1.42
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.41 2008/09/10 14:01:22 blambert Exp $ */
d1278 1
a1279 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
d1298 1
a1325 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
a1326 10
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				ste_setmulti(sc);
			error = 0;
		}
		break;
d1332 1
d1335 6
@


1.41
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.40 2007/07/17 23:25:15 krw Exp $ */
a1284 5
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return error;
	}

d1347 1
a1347 2
		error = ENOTTY;
		break;
a1350 1

@


1.40
log
@Add missing '};' to end struct declaration. Compiles again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.39 2007/07/17 17:15:34 jasper Exp $ */
d818 1
a818 1
	timeout_add(&sc->sc_stats_tmo, hz);
d1199 1
a1199 1
	timeout_add(&sc->sc_stats_tmo, hz);
@


1.39
log
@ident/ansify/de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.38 2006/07/08 19:56:38 brad Exp $ */
d828 1
@


1.38
log
@uncomment call to ste_miibus_statchg in ste_stats_update.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.37 2006/05/28 00:04:24 jason Exp $ */
d82 40
a121 40
int ste_probe(struct device *, void *, void *);
void ste_attach(struct device *, struct device *, void *);
int ste_intr(void *);
void ste_shutdown(void *);
void ste_init(void *);
void ste_rxeoc(struct ste_softc *);
void ste_rxeof(struct ste_softc *);
void ste_txeoc(struct ste_softc *);
void ste_txeof(struct ste_softc *);
void ste_stats_update(void *);
void ste_stop(struct ste_softc *);
void ste_reset(struct ste_softc *);
int ste_ioctl(struct ifnet *, u_long, caddr_t);
int ste_encap(struct ste_softc *, struct ste_chain *,
					struct mbuf *);
void ste_start(struct ifnet *);
void ste_watchdog(struct ifnet *);
int ste_newbuf(struct ste_softc *,
					struct ste_chain_onefrag *,
					struct mbuf *);
int ste_ifmedia_upd(struct ifnet *);
void ste_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void ste_mii_sync(struct ste_softc *);
void ste_mii_send(struct ste_softc *, u_int32_t, int);
int ste_mii_readreg(struct ste_softc *,
					struct ste_mii_frame *);
int ste_mii_writereg(struct ste_softc *,
					struct ste_mii_frame *);
int ste_miibus_readreg(struct device *, int, int);
void ste_miibus_writereg(struct device *, int, int, int);
void ste_miibus_statchg(struct device *);

int ste_eeprom_wait(struct ste_softc *);
int ste_read_eeprom(struct ste_softc *, caddr_t, int,
							int, int);
void ste_wait(struct ste_softc *);
void ste_setmulti(struct ste_softc *);
int ste_init_rx_list(struct ste_softc *);
void ste_init_tx_list(struct ste_softc *);
d145 8
d156 2
a157 2
void ste_mii_sync(sc)
	struct ste_softc		*sc;
d159 1
a159 1
	register int		i;
d176 2
a177 4
void ste_mii_send(sc, bits, cnt)
	struct ste_softc		*sc;
	u_int32_t		bits;
	int			cnt;
d179 1
a179 1
	int			i;
d199 2
a200 4
int ste_mii_readreg(sc, frame)
	struct ste_softc		*sc;
	struct ste_mii_frame	*frame;
	
d202 1
a202 1
	int			i, ack, s;
d289 2
a290 4
int ste_mii_writereg(sc, frame)
	struct ste_softc		*sc;
	struct ste_mii_frame	*frame;
	
d292 1
a292 1
	int			s;
d333 2
a334 3
int ste_miibus_readreg(self, phy, reg)
	struct device		*self;
	int			phy, reg;
d351 2
a352 3
void ste_miibus_writereg(self, phy, reg, data)
	struct device		*self;
	int			phy, reg, data;
d368 2
a369 2
void ste_miibus_statchg(self)
	struct device		*self;
d398 2
a399 2
int ste_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d417 2
a418 3
void ste_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
d433 2
a434 2
void ste_wait(sc)
	struct ste_softc		*sc;
d436 1
a436 1
	register int		i;
d453 2
a454 2
int ste_eeprom_wait(sc)
	struct ste_softc		*sc;
d456 1
a456 1
	int			i;
d480 2
a481 6
int ste_read_eeprom(sc, dest, off, cnt, swap)
	struct ste_softc		*sc;
	caddr_t			dest;
	int			off;
	int			cnt;
	int			swap;
d505 2
a506 2
void ste_setmulti(sc)
	struct ste_softc	*sc;
d554 2
a555 2
int ste_intr(xsc)
	void			*xsc;
d635 2
a636 2
void ste_rxeof(sc)
	struct ste_softc		*sc;
d716 2
a717 2
void ste_txeoc(sc)
	struct ste_softc	*sc;
d754 2
a755 2
void ste_txeof(sc)
	struct ste_softc	*sc;
d785 2
a786 2
void ste_stats_update(xsc)
	void			*xsc;
a827 1
};
d833 2
a834 3
int ste_probe(parent, match, aux)
	struct device		*parent;
	void			*match, *aux;
d844 2
a845 3
void ste_attach(parent, self, aux)
	struct device		*parent, *self;
	void			*aux;
d998 2
a999 4
int ste_newbuf(sc, c, m)
	struct ste_softc	*sc;
	struct ste_chain_onefrag	*c;
	struct mbuf		*m;
d1029 2
a1030 2
int ste_init_rx_list(sc)
	struct ste_softc	*sc;
d1062 2
a1063 2
void ste_init_tx_list(sc)
	struct ste_softc	*sc;
d1091 2
a1092 2
void ste_init(xsc)
	void			*xsc;
d1203 2
a1204 2
void ste_stop(sc)
	struct ste_softc	*sc;
d1249 2
a1250 2
void ste_reset(sc)
	struct ste_softc	*sc;
d1273 2
a1274 4
int ste_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d1360 2
a1361 4
int ste_encap(sc, c, m_head)
	struct ste_softc	*sc;
	struct ste_chain	*c;
	struct mbuf		*m_head;
d1419 2
a1420 2
void ste_start(ifp)
	struct ifnet		*ifp;
d1499 2
a1500 2
void ste_watchdog(ifp)
	struct ifnet		*ifp;
d1522 2
a1523 2
void ste_shutdown(v)
	void			*v;
a1528 9

struct cfattach ste_ca = {
	sizeof(struct ste_softc), ste_probe, ste_attach
};

struct cfdriver ste_cd = {
	0, "ste", DV_IFNET
};

@


1.37
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.36 2006/04/02 05:12:02 brad Exp $ */
d610 1
a610 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d817 2
a818 4
#if 0
			ste_miibus_statchg(&mii->mii_dev.dv_parent);
#endif
			if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d1530 1
a1530 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
@


1.36
log
@add another PCI id to the ste(4) driver.

From the Sundance Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.35 2006/03/25 22:41:45 djm Exp $ */
d1365 1
a1365 1
		error = EINVAL;
@


1.35
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.34 2005/11/07 02:57:45 brad Exp $ */
d832 3
a834 2
	{ PCI_VENDOR_SUNDANCE, PCI_PRODUCT_SUNDANCE_ST201 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_550TX },
@


1.34
log
@- splimp -> splnet
- remove spl's from attach
- removing redundant checks before pci_mapreg_map()
- fix dmesg printing
- de-allocate resources on failure to attach
- remove unused VLAN input code from vge(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.33 2005/09/10 23:21:05 brad Exp $ */
d708 1
a708 1
			bpf_mtap(ifp->if_bpf, m);
d1502 2
a1503 1
			bpf_mtap(ifp->if_bpf, cur_tx->ste_mbuf);
@


1.33
log
@- a few fixes from the FreeBSD driver
- make use of pci_mapreg_map()
- ensure driver cleans after itself if ste_attach() fails
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.32 2005/08/09 04:10:12 mickey Exp $ */
d200 1
a200 1
	s = splimp();
d292 1
a292 1
	s = splimp();
d798 1
a798 1
	s = splimp();
d948 1
a948 2
		printf("%s: failed to read station address\n",
		    sc->sc_dev.dv_xname);
d957 1
a957 2
		printf("%s: no memory for list buffers!\n",
		    sc->sc_dev.dv_xname);
a997 1

d1110 1
a1110 1
	s = splimp();
d1295 1
a1295 1
	s = splimp();
@


1.32
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.31 2005/07/02 23:10:11 brad Exp $ */
d87 1
d541 1
a541 2
		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) &
		    0x0000003F;
d582 2
a583 1
		if (status & STE_ISR_RX_DMADONE)
d585 1
d593 5
d616 20
a650 14
	if (sc->ste_cdata.ste_rx_head->ste_ptr->ste_status == 0) {
		cur_rx = sc->ste_cdata.ste_rx_head;
		do {
			cur_rx = cur_rx->ste_next;
			/* If the ring is empty, just return. */
			if (cur_rx == sc->ste_cdata.ste_rx_head)
				return;
		} while (cur_rx->ste_ptr->ste_status == 0);

		if (sc->ste_cdata.ste_rx_head->ste_ptr->ste_status == 0)
		/* We've fallen behind the chip: catch it. */
			sc->ste_cdata.ste_rx_head = cur_rx;
	}

a700 1
		ifp->if_ipackets++;
d704 2
d775 3
a777 6
		if (cur_tx->ste_mbuf != NULL) {
			m_freem(cur_tx->ste_mbuf);
			cur_tx->ste_mbuf = NULL;
			ifp->if_flags &= ~IFF_OACTIVE;
		}

d808 15
a822 6
	mii_tick(mii);
	if (!sc->ste_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		sc->ste_link++;
		if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
			ste_start(ifp);
d863 1
a863 2
	bus_addr_t		iobase;
	bus_size_t		iosize;
a905 1
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d908 5
a912 17
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf(": failed to enable I/O ports\n");
		goto fail;
	}
	if (pci_io_find(pc, pa->pa_tag, STE_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find I/O space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->ste_bhandle)) {
		printf(": can't map I/O space\n");
		goto fail;
	}
	sc->ste_btag = pa->pa_iot;
#else
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		goto fail;
d914 4
a917 5
	if (pci_mem_find(pc, pa->pa_tag, STE_PCI_LOMEM, &iobase, &iosize,NULL)){
		printf(": can't find mem space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->ste_bhandle)) {
d919 1
a919 1
		goto fail;
a920 1
	sc->ste_btag = pa->pa_memt;
d926 1
a926 1
		goto fail;
d936 1
a936 1
		goto fail;
d950 1
a950 1
		goto fail_1;
d953 1
a953 1
	printf(" address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));
d960 1
a960 1
		goto fail_1;
a1000 1
fail:
d1003 3
d1007 1
a1007 1
	pci_intr_disestablish(pc, sc->sc_ih);
d1442 1
a1442 1
	struct ste_chain	*cur_tx = NULL;
a1509 1
		sc->ste_cdata.ste_tx_prod = idx;
d1511 1
d1528 1
@


1.31
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.30 2005/04/21 06:48:05 fgsch Exp $ */
d837 1
a837 1
	u_int32_t		command;
a886 4
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.30
log
@o if the mac address cannot be read, just fail and disestablish the
  irq (for shared irq's) on failure. (should other drivers do the same?)
o if it's a rev 0x12 card, only use the first phy as it reports a
  non-existent one as well (From FreeBSD).
o remove splimp/splx from ste_attach().
o some cleanup.

thanks to matt at mattroberts dot org and paolo at actcom dot net dot il
for testing; commit deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.29 2005/04/08 20:30:51 beck Exp $ */
d1225 2
a1256 2

	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);
@


1.29
log
@remove dmesg spewage when link changes, ok deraadt, brad, canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.28 2005/01/15 05:24:11 brad Exp $ */
d337 3
d468 2
a469 1
		printf("%s: eeprom failed to come ready\n", sc->sc_dev.dv_xname);
a835 1
	int			s;
a845 2
	s = splimp();

d875 10
d946 6
a951 1
	ste_read_eeprom(sc,(caddr_t)&sc->arpcom.ac_enaddr,STE_EEADDR_NODE0,3,0);
d956 1
a956 1
				M_DEVBUF, M_DONTWAIT);
d958 3
a960 2
		printf("%s: no memory for list buffers!\n", sc->sc_dev.dv_xname);
		goto fail;
a1001 1
	splx(s);
d1003 3
d1264 1
a1264 1
	int			i;
d1281 2
a1282 3
		printf("%s: global reset never completed\n", sc->sc_dev.dv_xname);

	return;
@


1.28
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.27 2004/11/21 18:04:09 brad Exp $ */
a386 2

	printf("%s: %s-duplex\n", sc->sc_dev.dv_xname, fdx ? "full":"half");
@


1.27
log
@- Use ETHER_MAX_DIX_LEN.
- Accept VLAN sized frames. based on diff from canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.26 2004/10/30 15:48:15 canacar Exp $ */
d1338 2
a1339 1
			ste_setmulti(sc);
@


1.26
log
@vaddr_t casts for vtophys, works on amd64, enabled in GENERIC
patch submitted and tested by Steffen Schtz, schuetz.steffen at melle de
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.25 2004/09/23 17:45:16 brad Exp $ */
d726 1
a726 1
			    sc->ste_tx_thresh < STE_PACKET_SIZE) {
d734 1
a734 1
			    (STE_PACKET_SIZE >> 4));
d961 1
d1019 1
a1019 1
	c->ste_ptr->ste_frag.ste_len = 1536 | STE_FRAG_LAST;
d1121 1
a1121 1
	CSR_WRITE_1(sc, STE_TX_DMABURST_THRESH, STE_PACKET_SIZE >> 8);
d1127 1
a1127 1
	CSR_WRITE_1(sc, STE_TX_RECLAIM_THRESH, (STE_PACKET_SIZE >> 4));
d1180 4
@


1.25
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.24 2004/08/22 18:16:20 canacar Exp $ */
d1017 1
a1017 1
	c->ste_ptr->ste_frag.ste_addr = vtophys(mtod(m_new, caddr_t));
d1041 1
a1041 1
			    vtophys(&ld->ste_rx_list[0]);
d1046 1
a1046 1
			    vtophys(&ld->ste_rx_list[i + 1]);
d1067 1
a1067 1
		cd->ste_tx_chain[i].ste_phys = vtophys(&ld->ste_tx_list[i]);
d1151 1
a1151 1
	    vtophys(&sc->ste_ldata->ste_rx_list[0]));
d1460 1
a1460 1
			    vtophys(&sc->ste_ldata->ste_tx_list[0]));
@


1.24
log
@Do check for STATS_OFLOW in interrupt handler. The overflow interrupt is
already disabled and the status update function fails to clear the overflow,
causing high interrupt load. Reported and tested by Arvid Grtting.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.23 2004/08/09 16:33:55 canacar Exp $ */
a952 1
	ifp->if_mtu = ETHERMTU;
a954 1
	ifp->if_output = ether_output;
@


1.23
log
@update ste(4) with stability and performance fixes from
FreeBSD if_ste.c revisions 1.28, 1.29, 1.38, 1.43, 1.63, 1.68, 1.70
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.22 2004/06/06 17:56:36 mcbride Exp $ */
a588 5
		if (status & STE_ISR_STATS_OFLOW) {
			timeout_del(&sc->sc_stats_tmo);
			ste_stats_update(sc);
		}

a590 1

@


1.22
log
@Multicast cleanups
- make multicast ranges work
- replace handrolled crc code with ether_crc32_{be,le}()
- add missing calls to ether_{add,del}multi()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.21 2004/04/09 21:52:17 henning Exp $ */
d237 1
a239 1
	ack = CSR_READ_2(sc, STE_PHYCTL) & STE_PHYCTL_MDATA;
d369 1
d373 11
a383 1
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
d385 1
a385 1
	} else {
d387 5
a391 1
	}
d407 1
a407 2
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		    miisc = LIST_NEXT(miisc, mii_list))
d526 4
a529 2
	CSR_WRITE_4(sc, STE_MAR0, 0);
	CSR_WRITE_4(sc, STE_MAR1, 0);
d547 4
a550 2
	CSR_WRITE_4(sc, STE_MAR0, hashes[0]);
	CSR_WRITE_4(sc, STE_MAR1, hashes[1]);
d594 4
d623 1
a623 1
	int			total_len = 0;
d628 18
a645 1
again:
a646 1
	while((rxstat = sc->ste_cdata.ste_rx_head->ste_ptr->ste_status)) {
a702 1
	}
d704 2
a705 21
	/*
	 * Handle the 'end of channel' condition. When the upload
	 * engine hits the end of the RX ring, it will stall. This
	 * is our cue to flush the RX ring, reload the uplist pointer
	 * register and unstall the engine.
	 * XXX This is actually a little goofy. With the ThunderLAN
	 * chip, you get an interrupt when the receiver hits the end
	 * of the receive ring, which tells you exactly when you
	 * you need to reload the ring pointer. Here we have to
	 * fake it. I'm mad at myself for not being clever enough
	 * to avoid the use of a goto here.
	 */
	if (CSR_READ_4(sc, STE_RX_DMALIST_PTR) == 0 ||
		CSR_READ_4(sc, STE_DMACTL) & STE_DMACTL_RXDMA_STOPPED) {
		STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_RXDMA_STALL);
		ste_wait(sc);
		CSR_WRITE_4(sc, STE_RX_DMALIST_PTR,
			vtophys(&sc->ste_ldata->ste_rx_list[0]));
		sc->ste_cdata.ste_rx_head = &sc->ste_cdata.ste_rx_chain[0];
		STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_RXDMA_UNSTALL);
		goto again;
d768 1
a772 1
		sc->ste_cdata.ste_tx_cnt--;
a773 1
		ifp->if_timer = 0;
d777 2
a778 3

	if (cur_tx != NULL)
		ifp->if_flags &= ~IFF_OACTIVE;
a786 1
	struct ste_stats	stats;
d789 1
a789 2
	int			i, s;
	u_int8_t		*p;
d797 3
a799 9
	p = (u_int8_t *)&stats;

	for (i = 0; i < sizeof(stats); i++) {
		*p = CSR_READ_1(sc, STE_STATS + i);
		p++;
	}

	ifp->if_collisions += stats.ste_single_colls +
	    stats.ste_multi_colls + stats.ste_late_colls;
d802 3
a804 5
	if (!sc->ste_link) {
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
			sc->ste_link++;
d948 1
a948 1
				M_DEVBUF, M_NOWAIT);
d970 2
d1056 1
a1056 1

a1081 6
		if (i == 0)
			cd->ste_tx_chain[i].ste_prev =
			    &cd->ste_tx_chain[STE_TX_LIST_CNT - 1];
		else
			cd->ste_tx_chain[i].ste_prev =
			    &cd->ste_tx_chain[i - 1];
a1088 1
	cd->ste_tx_cnt = 0;
d1121 3
d1163 2
a1164 2
	/* Set TX polling interval */
	CSR_WRITE_1(sc, STE_TX_DMAPOLL_PERIOD, 64);
d1169 1
a1169 2
	CSR_WRITE_4(sc, STE_TX_DMALIST_PTR,
	    vtophys(&sc->ste_ldata->ste_tx_list[0]));
d1173 1
d1177 1
d1218 5
d1240 2
d1315 6
a1320 2
			} else if (!(ifp->if_flags & IFF_RUNNING)) {
				sc->ste_tx_thresh = STE_MIN_FRAMELEN;
a1368 1
	int			total_len = 0;
a1371 1
	d->ste_next = 0;
d1373 1
d1378 1
a1378 2
			total_len += m->m_len;
			f = &c->ste_ptr->ste_frags[frag];
d1385 29
d1415 2
a1416 2
	c->ste_ptr->ste_frags[frag - 1].ste_len |= STE_FRAG_LAST;
	c->ste_ptr->ste_ctl = total_len;
d1426 1
a1426 1
	struct ste_chain	*prev = NULL, *cur_tx = NULL, *start_tx;
a1437 1
	start_tx = &sc->ste_cdata.ste_tx_chain[idx];
d1440 6
a1445 1
		if ((STE_TX_LIST_CNT - sc->ste_cdata.ste_tx_cnt) < 3) {
d1456 4
a1459 1
		ste_encap(sc, cur_tx, m_head);
d1461 21
a1481 3
		if (prev != NULL)
			prev->ste_ptr->ste_next = cur_tx->ste_phys;
		prev = cur_tx;
d1493 2
a1494 1
		sc->ste_cdata.ste_tx_cnt++;
a1495 11

	if (cur_tx == NULL)
		return;

	cur_tx->ste_ptr->ste_ctl |= STE_TXCTL_DMAINTR;

	/* Start transmission */
	sc->ste_cdata.ste_tx_prod = idx;
	start_tx->ste_prev->ste_ptr->ste_next = start_tx->ste_phys;

	ifp->if_timer = 5;
@


1.21
log
@do not whine if we cannot get mbufs. the countless printfd makes the machine
crawl under mbuf starvation, making the situationmuch worse, and don't make
sense in the first place.
ok tdeval@@ millert@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.20 2003/06/29 17:20:03 avsm Exp $ */
a117 1
u_int8_t ste_calchash(caddr_t);
a492 26
u_int8_t ste_calchash(addr)
	caddr_t			addr;
{

	u_int32_t		crc, carry;
	int			i, j;
	u_int8_t		c;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (i = 0; i < 6; i++) {
		c = *(addr + i);
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/* return the filter bit position */
	return(crc & 0x0000003F);
}

d504 1
d518 6
a523 1
		h = ste_calchash(enm->enm_addrlo);
@


1.20
log
@lose ste_unit; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.19 2003/06/29 13:23:48 avsm Exp $ */
d1020 1
a1020 3
		if (m_new == NULL) {
			printf("%s: no memory for rx list -- "
			    "packet dropped\n", sc->sc_dev.dv_xname);
a1021 1
		}
a1023 2
			printf("%s: no memory for rx list -- "
			    "packet dropped\n", sc->sc_dev.dv_xname);
@


1.19
log
@another bad format string; %s->%d
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.18 2003/01/15 06:31:24 art Exp $ */
d430 1
a430 1
		printf("ste%d: command never completed!\n", sc->ste_unit);
d454 1
a454 1
		printf("ste%d: eeprom failed to come ready\n", sc->ste_unit);
d651 2
a652 2
			printf("ste%d: bad receive status -- packet dropped",
							sc->ste_unit);
d728 2
a729 2
			printf("ste%d: transmission error: %x\n",
			    sc->ste_unit, txstat);
d737 1
a737 1
				printf("ste%d: tx underrun, increasing tx"
d739 1
a739 1
				    sc->ste_unit, sc->ste_tx_thresh);
a866 1
	sc->ste_unit = sc->sc_dev.dv_unit;
d884 2
a885 2
			printf("ste%d: chip is in D%d power mode "
			"-- setting to D0\n", sc->ste_unit, command & STE_PSTATE_MASK);
d965 1
a965 1
		printf("ste%d: no memory for list buffers!\n", sc->ste_unit);
d1021 2
a1022 2
			printf("ste%d: no memory for rx list -- "
			    "packet dropped\n", sc->ste_unit);
d1027 2
a1028 2
			printf("ste%d: no memory for rx list -- "
			    "packet dropped\n", sc->ste_unit);
d1139 2
a1140 2
		printf("ste%d: initialization failed: no "
		    "memory for RX buffers\n", sc->ste_unit);
d1281 1
a1281 1
		printf("ste%d: global reset never completed\n", sc->ste_unit);
d1476 1
a1476 1
	printf("ste%d: watchdog timeout\n", sc->ste_unit);
@


1.18
log
@Get rid of the remaining vm_offset_t in pci drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.17 2002/11/19 18:40:17 jason Exp $ */
d966 1
a966 1
		printf("%s: no memory for list buffers!\n", sc->ste_unit);
@


1.17
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.16 2002/03/14 01:26:59 millert Exp $ */
d1392 1
a1392 1
			f->ste_addr = vtophys(mtod(m, vm_offset_t));
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.15 2001/11/06 19:53:19 miod Exp $ */
d830 4
d843 2
a844 11
	struct pci_attach_args	*pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SUNDANCE &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SUNDANCE_ST201)
		return(1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DLINK &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DLINK_550TX)
		return(1);

	return(0);
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.14 2001/08/25 10:13:29 art Exp $ */
d82 17
a98 17
int ste_probe		__P((struct device *, void *, void *));
void ste_attach		__P((struct device *, struct device *, void *));
int ste_intr		__P((void *));
void ste_shutdown	__P((void *));
void ste_init		__P((void *));
void ste_rxeof		__P((struct ste_softc *));
void ste_txeoc		__P((struct ste_softc *));
void ste_txeof		__P((struct ste_softc *));
void ste_stats_update	__P((void *));
void ste_stop		__P((struct ste_softc *));
void ste_reset		__P((struct ste_softc *));
int ste_ioctl		__P((struct ifnet *, u_long, caddr_t));
int ste_encap		__P((struct ste_softc *, struct ste_chain *,
					struct mbuf *));
void ste_start		__P((struct ifnet *));
void ste_watchdog	__P((struct ifnet *));
int ste_newbuf		__P((struct ste_softc *,
d100 22
a121 22
					struct mbuf *));
int ste_ifmedia_upd	__P((struct ifnet *));
void ste_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

void ste_mii_sync	__P((struct ste_softc *));
void ste_mii_send	__P((struct ste_softc *, u_int32_t, int));
int ste_mii_readreg	__P((struct ste_softc *,
					struct ste_mii_frame *));
int ste_mii_writereg	__P((struct ste_softc *,
					struct ste_mii_frame *));
int ste_miibus_readreg	__P((struct device *, int, int));
void ste_miibus_writereg	__P((struct device *, int, int, int));
void ste_miibus_statchg	__P((struct device *));

int ste_eeprom_wait	__P((struct ste_softc *));
int ste_read_eeprom	__P((struct ste_softc *, caddr_t, int,
							int, int));
void ste_wait		__P((struct ste_softc *));
u_int8_t ste_calchash	__P((caddr_t));
void ste_setmulti	__P((struct ste_softc *));
int ste_init_rx_list	__P((struct ste_softc *));
void ste_init_tx_list	__P((struct ste_softc *));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.15 2001/11/06 19:53:19 miod Exp $ */
d82 17
a98 17
int ste_probe(struct device *, void *, void *);
void ste_attach(struct device *, struct device *, void *);
int ste_intr(void *);
void ste_shutdown(void *);
void ste_init(void *);
void ste_rxeof(struct ste_softc *);
void ste_txeoc(struct ste_softc *);
void ste_txeof(struct ste_softc *);
void ste_stats_update(void *);
void ste_stop(struct ste_softc *);
void ste_reset(struct ste_softc *);
int ste_ioctl(struct ifnet *, u_long, caddr_t);
int ste_encap(struct ste_softc *, struct ste_chain *,
					struct mbuf *);
void ste_start(struct ifnet *);
void ste_watchdog(struct ifnet *);
int ste_newbuf(struct ste_softc *,
d100 22
a121 22
					struct mbuf *);
int ste_ifmedia_upd(struct ifnet *);
void ste_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void ste_mii_sync(struct ste_softc *);
void ste_mii_send(struct ste_softc *, u_int32_t, int);
int ste_mii_readreg(struct ste_softc *,
					struct ste_mii_frame *);
int ste_mii_writereg(struct ste_softc *,
					struct ste_mii_frame *);
int ste_miibus_readreg(struct device *, int, int);
void ste_miibus_writereg(struct device *, int, int, int);
void ste_miibus_statchg(struct device *);

int ste_eeprom_wait(struct ste_softc *);
int ste_read_eeprom(struct ste_softc *, caddr_t, int,
							int, int);
void ste_wait(struct ste_softc *);
u_int8_t ste_calchash(caddr_t);
void ste_setmulti(struct ste_softc *);
int ste_init_rx_list(struct ste_softc *);
void ste_init_tx_list(struct ste_softc *);
@


1.15.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a829 4
const struct pci_matchid ste_devices[] = {
	{ PCI_VENDOR_SUNDANCE, PCI_PRODUCT_SUNDANCE_ST201 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_550TX },
};
d839 11
a849 2
	return (pci_matchbyid((struct pci_attach_args *)aux, ste_devices,
	    sizeof(ste_devices)/sizeof(ste_devices[0])));
d1397 1
a1397 1
			f->ste_addr = vtophys(mtod(m, vaddr_t));
@


1.14
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.13 2001/08/12 20:03:49 mickey Exp $ */
d67 1
a67 1
#include <vm/vm.h>              /* for vtophys */
@


1.13
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.12 2001/06/27 06:34:49 kjc Exp $ */
d942 1
a942 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
	    &ih)) {
@


1.12
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.11 2001/06/25 02:18:47 fgsch Exp $ */
a67 1
#include <vm/pmap.h>            /* for vtophys */
@


1.11
log
@trivial ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.10 2001/02/20 19:39:45 mickey Exp $ */
d607 1
a607 1
	if (ifp->if_snd.ifq_head != NULL)
d821 1
a821 1
		if (ifp->if_snd.ifq_head != NULL)
d989 2
a990 1
	ifp->if_snd.ifq_maxlen = STE_TX_LIST_CNT - 1;
d1437 1
a1437 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
d1492 1
a1492 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.10
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.9 2001/02/03 05:56:14 mickey Exp $ */
a619 1
        struct ether_header	*eh;
a676 1
		eh = mtod(m, struct ether_header *);
d685 2
a686 3
		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, eh, m);
@


1.9
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.8 2000/10/16 17:08:08 aaron Exp $ */
a1013 4
#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif
@


1.8
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.7 2000/06/27 20:09:42 aaron Exp $ */
d47 1
d594 1
a594 1
			untimeout(ste_stats_update, sc);
d828 1
a828 1
	timeout(ste_stats_update, sc, hz);
d1230 2
a1231 1
	timeout(ste_stats_update, sc, hz);
d1244 1
a1244 1
	untimeout(ste_stats_update, sc);
@


1.7
log
@Make this driver work. When I ported it from FreeBSD, somehow a line got left
out. :-( It was never noticed until now since I didn't have an actual D-Link
550TX card to test with. Thanks to Gardner Cohen for sending me one of these.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.6 2000/02/15 02:28:15 jason Exp $ */
d999 2
a1000 1
	mii_phy_probe(self, &sc->sc_mii, 0xffffffff);
@


1.6
log
@make sure to call ether_{add,del}multi() as appropriate in xxx_ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.5 1999/12/08 00:38:08 aaron Exp $ */
d1104 1
@


1.6.2.1
log
@Pull in patch from current:
Fix (aaron):
Make this driver work. When I ported it from FreeBSD, somehow a line got left
out. :-( It was never noticed until now since I didn't have an actual D-Link
550TX card to test with. Thanks to Gardner Cohen for sending me one of these.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.7 2000/06/27 20:09:42 aaron Exp $ */
a1103 1
		cd->ste_tx_chain[i].ste_ptr = &ld->ste_tx_list[i];
@


1.5
log
@Remove unused #define cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.4 1999/12/08 00:29:26 aaron Exp $ */
d1352 12
a1363 2
		ste_setmulti(sc);
		error = 0;
@


1.5.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.6 2000/02/15 02:28:15 jason Exp $ */
d1352 2
a1353 12
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			ste_setmulti(sc);
			error = 0;
		}
@


1.5.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.10 2001/02/20 19:39:45 mickey Exp $ */
a46 1
#include <sys/timeout.h>
d593 1
a593 1
			timeout_del(&sc->sc_stats_tmo);
d827 1
a827 1
	timeout_add(&sc->sc_stats_tmo, hz);
d999 1
a999 2
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
d1012 4
a1103 1
		cd->ste_tx_chain[i].ste_ptr = &ld->ste_tx_list[i];
d1227 1
a1227 2
	timeout_set(&sc->sc_stats_tmo, ste_stats_update, sc);
	timeout_add(&sc->sc_stats_tmo, hz);
d1240 1
a1240 1
	timeout_del(&sc->sc_stats_tmo);
@


1.5.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.5.2.2 2001/05/14 22:25:47 niklas Exp $ */
d607 1
a607 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d620 1
d678 1
d687 3
a689 2
		/* pass it on. */
		ether_input_mbuf(ifp, m);
d824 1
a824 1
		if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d992 1
a992 2
	IFQ_SET_MAXLEN(&ifp->if_snd, STE_TX_LIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
d1439 1
a1439 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
d1494 1
a1494 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
@


1.5.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.5.2.3 2001/07/04 10:42:22 niklas Exp $ */
d68 1
d943 2
a944 1
	if (pci_intr_map(pa, &ih)) {
@


1.5.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d67 1
a67 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.5.2.6
log
@Merge in -current from roughly a week ago
@
text
@d82 17
a98 17
int ste_probe(struct device *, void *, void *);
void ste_attach(struct device *, struct device *, void *);
int ste_intr(void *);
void ste_shutdown(void *);
void ste_init(void *);
void ste_rxeof(struct ste_softc *);
void ste_txeoc(struct ste_softc *);
void ste_txeof(struct ste_softc *);
void ste_stats_update(void *);
void ste_stop(struct ste_softc *);
void ste_reset(struct ste_softc *);
int ste_ioctl(struct ifnet *, u_long, caddr_t);
int ste_encap(struct ste_softc *, struct ste_chain *,
					struct mbuf *);
void ste_start(struct ifnet *);
void ste_watchdog(struct ifnet *);
int ste_newbuf(struct ste_softc *,
d100 3
a102 3
					struct mbuf *);
int ste_ifmedia_upd(struct ifnet *);
void ste_ifmedia_sts(struct ifnet *, struct ifmediareq *);
d104 9
a112 9
void ste_mii_sync(struct ste_softc *);
void ste_mii_send(struct ste_softc *, u_int32_t, int);
int ste_mii_readreg(struct ste_softc *,
					struct ste_mii_frame *);
int ste_mii_writereg(struct ste_softc *,
					struct ste_mii_frame *);
int ste_miibus_readreg(struct device *, int, int);
void ste_miibus_writereg(struct device *, int, int, int);
void ste_miibus_statchg(struct device *);
d114 8
a121 8
int ste_eeprom_wait(struct ste_softc *);
int ste_read_eeprom(struct ste_softc *, caddr_t, int,
							int, int);
void ste_wait(struct ste_softc *);
u_int8_t ste_calchash(caddr_t);
void ste_setmulti(struct ste_softc *);
int ste_init_rx_list(struct ste_softc *);
void ste_init_tx_list(struct ste_softc *);
@


1.5.2.7
log
@Sync the SMP branch with 3.3
@
text
@a829 4
const struct pci_matchid ste_devices[] = {
	{ PCI_VENDOR_SUNDANCE, PCI_PRODUCT_SUNDANCE_ST201 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_550TX },
};
d839 11
a849 2
	return (pci_matchbyid((struct pci_attach_args *)aux, ste_devices,
	    sizeof(ste_devices)/sizeof(ste_devices[0])));
d1397 1
a1397 1
			f->ste_addr = vtophys(mtod(m, vaddr_t));
@


1.5.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d430 1
a430 1
		printf("%s: command never completed!\n", sc->sc_dev.dv_xname);
d454 1
a454 1
		printf("%s: eeprom failed to come ready\n", sc->sc_dev.dv_xname);
d651 2
a652 2
			printf("%s: bad receive status -- packet dropped",
				sc->sc_dev.dv_xname);
d728 2
a729 2
			printf("%s: transmission error: %x\n",
			    sc->sc_dev.dv_xname, txstat);
d737 1
a737 1
				printf("%s: tx underrun, increasing tx"
d739 1
a739 1
				    sc->sc_dev.dv_xname, sc->ste_tx_thresh);
d867 1
d885 2
a886 2
			printf("%s: chip is in D%d power mode -- setting to D0\n",
				sc->sc_dev.dv_xname, command & STE_PSTATE_MASK);
d966 1
a966 1
		printf("%s: no memory for list buffers!\n", sc->sc_dev.dv_xname);
d1022 2
a1023 2
			printf("%s: no memory for rx list -- "
			    "packet dropped\n", sc->sc_dev.dv_xname);
d1028 2
a1029 2
			printf("%s: no memory for rx list -- "
			    "packet dropped\n", sc->sc_dev.dv_xname);
d1140 2
a1141 2
		printf("%s: initialization failed: no "
		    "memory for RX buffers\n", sc->sc_dev.dv_xname);
d1282 1
a1282 1
		printf("%s: global reset never completed\n", sc->sc_dev.dv_xname);
d1477 1
a1477 1
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);
@


1.5.2.9
log
@Merge with the trunk
@
text
@d1020 3
a1022 1
		if (m_new == NULL)
d1024 1
d1027 2
@


1.5.2.10
log
@sync to head
@
text
@d118 1
d494 26
a530 1
allmulti:
d544 1
a544 6
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) &
		    0x0000003F;
@


1.4
log
@Whoops; forgot to bump FreeBSD version numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.3 1999/12/08 00:09:59 aaron Exp $ */
a121 8

#ifdef STE_USEIOSPACE
#define STE_RES			SYS_RES_IOPORT
#define STE_RID			STE_PCI_LOIO
#else
#define STE_RES			SYS_RES_MEMORY
#define STE_RID			STE_PCI_LOMEM
#endif
@


1.3
log
@Sync with FreeBSD:
- Use TX descriptor polling, similar to the xl driver, to reduce TX overhead.
- As in if_sf, reset PHY when switching modes.
- Remove unused code that was #ifdef foo'd out.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.2 1999/12/07 20:42:54 jason Exp $ */
d33 1
a33 1
 * $FreeBSD: src/sys/pci/if_ste.c,v 1.14 1999/12/07 06:08:11 wpaul Exp $
@


1.2
log
@remove freebsd bridging stuff, and let ALL packets go to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ste.c,v 1.1 1999/12/07 01:45:29 aaron Exp $ */
d33 1
a33 1
 * $FreeBSD: src/sys/pci/if_ste.c,v 1.12 1999/09/22 06:08:11 wpaul Exp $
d398 7
a740 1
			STE_SETBIT4(sc, STE_ASICCTL, STE_ASICCTL_TX_RESET);
d742 3
a744 3
			if (sc->ste_cdata.ste_tx_head != NULL)
				CSR_WRITE_4(sc, STE_TX_DMALIST_PTR,
				    vtophys(sc->ste_cdata.ste_tx_head->ste_ptr));
d766 1
a766 1
	struct ste_chain	*cur_tx;
d768 1
d772 3
a774 2
	/* Clear the timeout timer. */
	ifp->if_timer = 0;
a775 2
	while(sc->ste_cdata.ste_tx_head != NULL) {
		cur_tx = sc->ste_cdata.ste_tx_head;
a777 1
		sc->ste_cdata.ste_tx_head = cur_tx->ste_next;
d779 5
a783 2
		m_freem(cur_tx->ste_mbuf);
		cur_tx->ste_mbuf = NULL;
d786 3
a788 2
		cur_tx->ste_next = sc->ste_cdata.ste_tx_free;
		sc->ste_cdata.ste_tx_free = cur_tx;
d791 3
a793 1
	if (sc->ste_cdata.ste_tx_head == NULL) {
a794 9
		sc->ste_cdata.ste_tx_tail = NULL;
	} else {
		if (CSR_READ_4(sc, STE_DMACTL) & STE_DMACTL_TXDMA_STOPPED ||
		    !CSR_READ_4(sc, STE_TX_DMALIST_PTR)) {
			CSR_WRITE_4(sc, STE_TX_DMALIST_PTR,
			    vtophys(sc->ste_cdata.ste_tx_head->ste_ptr));
			CSR_WRITE_4(sc, STE_DMACTL, STE_DMACTL_TXDMA_UNSTALL);
		}
	}
d826 8
d1112 1
a1112 1
		cd->ste_tx_chain[i].ste_ptr = &ld->ste_tx_list[i];
d1114 2
a1115 1
			cd->ste_tx_chain[i].ste_next = NULL;
d1119 6
d1127 6
a1132 2
	cd->ste_tx_free = &cd->ste_tx_chain[0];
	cd->ste_tx_tail = cd->ste_tx_head = NULL;
a1171 1
	sc->ste_tx_thresh = STE_MIN_FRAMELEN;
d1204 12
d1228 1
a1228 1
	mii_mediachg(mii);
d1258 2
a1300 24
#ifdef foo
	STE_SETBIT4(sc, STE_ASICCTL, STE_ASICCTL_RX_RESET);
	for (i = 0; i < STE_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, STE_ASICCTL) & STE_ASICCTL_RX_RESET))
			break;
	}

	if (i == STE_TIMEOUT)
		printf("ste%d: RX reset never completed\n", sc->ste_unit);

	DELAY(100000);

	STE_SETBIT4(sc, STE_ASICCTL, STE_ASICCTL_TX_RESET);
	for (i = 0; i < STE_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, STE_ASICCTL) & STE_ASICCTL_TX_RESET))
			break;
	}

	if (i == STE_TIMEOUT)
		printf("ste%d: TX reset never completed\n", sc->ste_unit);

	DELAY(100000);
#endif

d1337 14
a1350 1
			ste_init(sc);
d1355 1
a1384 1
	int			total_len;
d1386 2
d1389 3
a1391 2
	m = m_head;
	total_len = 0;
a1404 29
	if (m != NULL) {
		struct mbuf		*m_new = NULL;

		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("ste%d: no memory for "
			   "tx list", sc->ste_unit);
			return(1);
		}
		if (m_head->m_pkthdr.len > MHLEN) {
			MCLGET(m_new, M_DONTWAIT);
			if (!(m_new->m_flags & M_EXT)) {
				m_freem(m_new);
				printf("ste%d: no memory for "
			   	    "tx list", sc->ste_unit);
				return(1);
			}
		}
		m_copydata(m_head, 0, m_head->m_pkthdr.len,
		    mtod(m_new, caddr_t));
		m_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;
		m_freem(m_head);
		m_head = m_new;
		f = &c->ste_ptr->ste_frags[0];
		f->ste_addr = vtophys(mtod(m_new, caddr_t));
		f->ste_len = total_len = m_new->m_len;
		frag = 1;
	}

a1407 1
	c->ste_ptr->ste_next = 0;
d1418 1
d1422 4
a1425 2
	if (sc->ste_cdata.ste_tx_free == NULL) {
		ifp->if_flags |= IFF_OACTIVE;
a1426 1
	}
d1428 8
a1435 1
	start_tx = sc->ste_cdata.ste_tx_free;
a1436 1
	while(sc->ste_cdata.ste_tx_free != NULL) {
d1441 1
a1441 4
		cur_tx = sc->ste_cdata.ste_tx_free;
		sc->ste_cdata.ste_tx_free = cur_tx->ste_next;

		cur_tx->ste_next = NULL;
d1445 2
a1446 4
		if (prev != NULL) {
			prev->ste_next = cur_tx;
			prev->ste_ptr->ste_next = vtophys(cur_tx->ste_ptr);
		}
d1451 1
a1451 1
		 * If there's a BPF listener, bounce a copt of this frame
d1457 3
d1467 3
a1469 19
	STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_TXDMA_STALL);
	ste_wait(sc);

	if (sc->ste_cdata.ste_tx_head != NULL) {
		sc->ste_cdata.ste_tx_tail->ste_next = start_tx;
		sc->ste_cdata.ste_tx_tail->ste_ptr->ste_next =
		    vtophys(start_tx->ste_ptr);
		sc->ste_cdata.ste_tx_tail->ste_ptr->ste_ctl &=
		    ~STE_TXCTL_DMAINTR;
		sc->ste_cdata.ste_tx_tail = cur_tx;
	} else {
		sc->ste_cdata.ste_tx_head = start_tx;
		sc->ste_cdata.ste_tx_tail = cur_tx;
	}

	if (!CSR_READ_4(sc, STE_TX_DMALIST_PTR))
		CSR_WRITE_4(sc, STE_TX_DMALIST_PTR,
		    vtophys(start_tx->ste_ptr));
	STE_SETBIT4(sc, STE_DMACTL, STE_DMACTL_TXDMA_UNSTALL);
a1484 8

#ifdef foo
	if (sc->ste_pinfo != NULL) {
		if (!(ste_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT))
			printf("ste%d: no carrier - transceiver "
			    "cable problem?\n", sc->ste_unit);
	}
#endif
@


1.1
log
@Driver for Sundance ST201 Ethernet; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a65 6
#if 0
#ifdef BRIDGE
#include <net/bridge.h>
#endif
#endif

a684 32
#endif

#if 0
#ifdef BRIDGE
		if (do_bridge) {
			struct ifnet *bdg_ifp ;
			bdg_ifp = bridge_in(m);
			if (bdg_ifp != BDG_LOCAL && bdg_ifp != BDG_DROP)
				bdg_forward(&m, bdg_ifp);
			if (((bdg_ifp != BDG_LOCAL) && (bdg_ifp != BDG_BCAST) &&
			    (bdg_ifp != BDG_MCAST)) || bdg_ifp == BDG_DROP) {
				m_freem(m);
				continue;
			}
		}
#endif
#endif

#if NBPFILTER > 0
		/*
		 * Don't pass packet up to the ether_input() layer unless it's
		 * a broadcast packet, multicast packet, matches our ethernet
		 * address or the interface is in promiscuous mode.
		 */
		if (ifp->if_bpf) {
			if (ifp->if_flags & IFF_PROMISC &&
			    (bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,
			    ETHER_ADDR_LEN) && (eh->ether_dhost[0] & 1) == 0)){
				m_freem(m);
				continue;
			}
		}
@

