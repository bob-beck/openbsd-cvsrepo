head	1.110;
access;
symbols
	OPENBSD_6_1:1.110.0.4
	OPENBSD_6_1_BASE:1.110
	OPENBSD_6_0:1.102.0.4
	OPENBSD_6_0_BASE:1.102
	OPENBSD_5_9:1.101.0.2
	OPENBSD_5_9_BASE:1.101
	OPENBSD_5_8:1.101.0.4
	OPENBSD_5_8_BASE:1.101
	OPENBSD_5_7:1.99.0.4
	OPENBSD_5_7_BASE:1.99
	OPENBSD_5_6:1.96.0.4
	OPENBSD_5_6_BASE:1.96
	OPENBSD_5_5:1.74.0.4
	OPENBSD_5_5_BASE:1.74
	OPENBSD_5_4:1.69.0.4
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.69.0.2
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.51.0.2
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.2
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.39.0.2
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11;
locks; strict;
comment	@ * @;


1.110
date	2017.01.16.18.18.16;	author mikeb;	state Exp;
branches;
next	1.109;
commitid	LS25daDZcujHl81G;

1.109
date	2017.01.16.18.09.35;	author mikeb;	state Exp;
branches;
next	1.108;
commitid	4yS2KzB3EyLx38k0;

1.108
date	2016.11.06.09.58.16;	author dlg;	state Exp;
branches;
next	1.107;
commitid	WN2x5Y8gdDoWPbgs;

1.107
date	2016.10.24.01.50.09;	author dlg;	state Exp;
branches;
next	1.106;
commitid	TUkaiaQuIMsB0nFh;

1.106
date	2016.10.21.05.38.53;	author dlg;	state Exp;
branches;
next	1.105;
commitid	brE23Hpx076uQbsT;

1.105
date	2016.09.14.01.14.54;	author jmatthew;	state Exp;
branches;
next	1.104;
commitid	tp2t27ORRfVbPLah;

1.104
date	2016.08.17.01.02.31;	author krw;	state Exp;
branches;
next	1.103;
commitid	NQJzcPS2mgd0AEvc;

1.103
date	2016.08.09.15.04.34;	author krw;	state Exp;
branches;
next	1.102;
commitid	1YXr1RJYpycJT9hr;

1.102
date	2016.03.07.18.43.59;	author naddy;	state Exp;
branches;
next	1.101;
commitid	Z6e4eqr6FuYFPnlL;

1.101
date	2015.03.18.12.23.25;	author mikeb;	state Exp;
branches;
next	1.100;
commitid	USIpyqLBrSHMM2pi;

1.100
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.99;
commitid	p4LJxGKbi0BU2cG6;

1.99
date	2015.03.02.11.55.52;	author sthen;	state Exp;
branches;
next	1.98;
commitid	1BNjaLfTub1St7Wq;

1.98
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.97;
commitid	MyKPm9Q3dQu92BiX;

1.97
date	2014.09.16.05.12.04;	author dlg;	state Exp;
branches;
next	1.96;
commitid	R9koI281gjH3dMlF;

1.96
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	JtO5uXxVcnZfhUkR;

1.95
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.94;
commitid	OBNa5kfxQ2UXoiIw;

1.94
date	2014.05.04.17.34.17;	author sf;	state Exp;
branches;
next	1.93;

1.93
date	2014.04.25.09.43.04;	author jsg;	state Exp;
branches;
next	1.92;

1.92
date	2014.04.10.01.28.32;	author dlg;	state Exp;
branches;
next	1.91;

1.91
date	2014.04.09.05.00.28;	author dlg;	state Exp;
branches;
next	1.90;

1.90
date	2014.04.09.03.59.28;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2014.03.27.12.19.55;	author dlg;	state Exp;
branches;
next	1.88;

1.88
date	2014.03.27.10.15.43;	author dlg;	state Exp;
branches;
next	1.87;

1.87
date	2014.03.27.07.12.52;	author dlg;	state Exp;
branches;
next	1.86;

1.86
date	2014.03.27.07.06.33;	author dlg;	state Exp;
branches;
next	1.85;

1.85
date	2014.03.27.05.53.37;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2014.03.27.05.34.07;	author dlg;	state Exp;
branches;
next	1.83;

1.83
date	2014.03.27.05.20.27;	author dlg;	state Exp;
branches;
next	1.82;

1.82
date	2014.03.27.05.18.15;	author dlg;	state Exp;
branches;
next	1.81;

1.81
date	2014.03.27.05.09.26;	author dlg;	state Exp;
branches;
next	1.80;

1.80
date	2014.03.24.12.43.51;	author dlg;	state Exp;
branches;
next	1.79;

1.79
date	2014.03.24.12.06.58;	author dlg;	state Exp;
branches;
next	1.78;

1.78
date	2014.03.24.11.10.48;	author dlg;	state Exp;
branches;
next	1.77;

1.77
date	2014.03.24.11.05.03;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2014.03.24.07.24.20;	author dlg;	state Exp;
branches;
next	1.75;

1.75
date	2014.03.06.14.08.06;	author gerhard;	state Exp;
branches;
next	1.74;

1.74
date	2014.01.22.03.02.58;	author mikeb;	state Exp;
branches;
next	1.73;

1.73
date	2013.12.04.17.07.43;	author mikeb;	state Exp;
branches;
next	1.72;

1.72
date	2013.11.06.23.58.25;	author dlg;	state Exp;
branches;
next	1.71;

1.71
date	2013.11.06.08.00.17;	author dlg;	state Exp;
branches;
next	1.70;

1.70
date	2013.10.25.16.21.35;	author mikeb;	state Exp;
branches;
next	1.69;

1.69
date	2013.01.25.04.25.21;	author dlg;	state Exp;
branches;
next	1.68;

1.68
date	2012.09.28.12.46.41;	author mikeb;	state Exp;
branches;
next	1.67;

1.67
date	2012.09.10.09.41.58;	author mikeb;	state Exp;
branches;
next	1.66;

1.66
date	2012.09.07.19.10.39;	author mikeb;	state Exp;
branches;
next	1.65;

1.65
date	2012.08.28.17.02.33;	author mikeb;	state Exp;
branches;
next	1.64;

1.64
date	2012.08.28.14.52.34;	author mikeb;	state Exp;
branches;
next	1.63;

1.63
date	2012.08.25.03.43.27;	author dlg;	state Exp;
branches;
next	1.62;

1.62
date	2012.08.23.15.42.50;	author mikeb;	state Exp;
branches;
next	1.61;

1.61
date	2012.08.23.11.52.02;	author mikeb;	state Exp;
branches;
next	1.60;

1.60
date	2012.08.22.16.59.27;	author mikeb;	state Exp;
branches;
next	1.59;

1.59
date	2012.08.22.16.17.00;	author mikeb;	state Exp;
branches;
next	1.58;

1.58
date	2012.08.22.16.07.42;	author mikeb;	state Exp;
branches;
next	1.57;

1.57
date	2012.08.22.15.52.41;	author mikeb;	state Exp;
branches;
next	1.56;

1.56
date	2012.08.22.14.50.29;	author mikeb;	state Exp;
branches;
next	1.55;

1.55
date	2012.08.17.18.28.31;	author mikeb;	state Exp;
branches;
next	1.54;

1.54
date	2012.08.16.19.19.44;	author mikeb;	state Exp;
branches;
next	1.53;

1.53
date	2012.08.14.17.56.04;	author mikeb;	state Exp;
branches;
next	1.52;

1.52
date	2012.08.14.00.20.17;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2012.04.11.13.29.14;	author naddy;	state Exp;
branches;
next	1.50;

1.50
date	2011.11.03.20.08.49;	author mikeb;	state Exp;
branches;
next	1.49;

1.49
date	2011.09.12.12.33.26;	author mikeb;	state Exp;
branches;
next	1.48;

1.48
date	2011.08.29.12.42.18;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.21.01.03.30;	author sthen;	state Exp;
branches;
next	1.46;

1.46
date	2011.07.20.19.00.35;	author sthen;	state Exp;
branches;
next	1.45;

1.45
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.42;

1.42
date	2011.05.25.00.12.46;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2011.05.15.12.03.14;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2011.04.02.14.36.45;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2011.02.24.23.40.31;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2011.02.21.09.36.15;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.29.03.55.09;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2010.12.29.03.48.30;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.23.00.53.36;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.16.01.23.11;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.15.23.52.32;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.09.22.33.21;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.07.10.29.17;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.07.06.08.57;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.07.06.00.01;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.07.05.35.48;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.07.05.25.53;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.06.09.42.46;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.01.03.20.38;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.27.03.34.29;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.27.01.47.36;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.22.13.10.38;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.26.17.46.31;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.20.00.55.18;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.15.20.18.11;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.10.12.42.17;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.09.17.00.55;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.09.15.50.14;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.06.22.28.07;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.09.19.29.14;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.07.14.10.59;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.25.02.05.41;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.20.19.37.14;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.20.19.34.08;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.09.23.15.07;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.01.00.09.03;	author bluhm;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.24.21.29.16;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.05.03.43.18;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.03.06.00.40;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.27.11.19.04;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.110
log
@Let it compile with debugging enabled
@
text
@/*	$OpenBSD: mpii.c,v 1.109 2017/01/16 18:09:35 mikeb Exp $	*/
/*
 * Copyright (c) 2010, 2012 Mike Belopuhov
 * Copyright (c) 2009 James Giannoules
 * Copyright (c) 2005 - 2010 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2005 - 2010 Marco Peereboom <marco@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/sensors.h>
#include <sys/dkio.h>
#include <sys/tree.h>
#include <sys/task.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/biovar.h>

#include <dev/pci/mpiireg.h>

/* #define MPII_DEBUG */
#ifdef MPII_DEBUG
#define DPRINTF(x...)		do { if (mpii_debug) printf(x); } while(0)
#define DNPRINTF(n,x...)	do { if (mpii_debug & (n)) printf(x); } while(0)
#define	MPII_D_CMD		(0x0001)
#define	MPII_D_INTR		(0x0002)
#define	MPII_D_MISC		(0x0004)
#define	MPII_D_DMA		(0x0008)
#define	MPII_D_IOCTL		(0x0010)
#define	MPII_D_RW		(0x0020)
#define	MPII_D_MEM		(0x0040)
#define	MPII_D_CCB		(0x0080)
#define	MPII_D_PPR		(0x0100)
#define	MPII_D_RAID		(0x0200)
#define	MPII_D_EVT		(0x0400)
#define MPII_D_CFG		(0x0800)
#define MPII_D_MAP		(0x1000)

u_int32_t  mpii_debug = 0
		| MPII_D_CMD
		| MPII_D_INTR
		| MPII_D_MISC
		| MPII_D_DMA
		| MPII_D_IOCTL
		| MPII_D_RW
		| MPII_D_MEM
		| MPII_D_CCB
		| MPII_D_PPR
		| MPII_D_RAID
		| MPII_D_EVT
		| MPII_D_CFG
		| MPII_D_MAP
	;
#else
#define DPRINTF(x...)
#define DNPRINTF(n,x...)
#endif

#define MPII_REQUEST_SIZE		(512)
#define MPII_REQUEST_CREDIT		(128)

struct mpii_dmamem {
	bus_dmamap_t		mdm_map;
	bus_dma_segment_t	mdm_seg;
	size_t			mdm_size;
	caddr_t			mdm_kva;
};
#define MPII_DMA_MAP(_mdm) ((_mdm)->mdm_map)
#define MPII_DMA_DVA(_mdm) ((u_int64_t)(_mdm)->mdm_map->dm_segs[0].ds_addr)
#define MPII_DMA_KVA(_mdm) ((void *)(_mdm)->mdm_kva)

struct mpii_softc;

struct mpii_rcb {
	SIMPLEQ_ENTRY(mpii_rcb)	rcb_link;
	void			*rcb_reply;
	u_int32_t		rcb_reply_dva;
};

SIMPLEQ_HEAD(mpii_rcb_list, mpii_rcb);

struct mpii_device {
	int			flags;
#define MPII_DF_ATTACH		(0x0001)
#define MPII_DF_DETACH		(0x0002)
#define MPII_DF_HIDDEN		(0x0004)
#define MPII_DF_UNUSED		(0x0008)
#define MPII_DF_VOLUME		(0x0010)
#define MPII_DF_VOLUME_DISK	(0x0020)
#define MPII_DF_HOT_SPARE	(0x0040)
	short			slot;
	short			percent;
	u_int16_t		dev_handle;
	u_int16_t		enclosure;
	u_int16_t		expander;
	u_int8_t		phy_num;
	u_int8_t		physical_port;
};

struct mpii_ccb {
	struct mpii_softc	*ccb_sc;

	void *			ccb_cookie;
	bus_dmamap_t		ccb_dmamap;

	bus_addr_t		ccb_offset;
	void			*ccb_cmd;
	bus_addr_t		ccb_cmd_dva;
	u_int16_t		ccb_dev_handle;
	u_int16_t		ccb_smid;

	volatile enum {
		MPII_CCB_FREE,
		MPII_CCB_READY,
		MPII_CCB_QUEUED,
		MPII_CCB_TIMEOUT
	}			ccb_state;

	void			(*ccb_done)(struct mpii_ccb *);
	struct mpii_rcb		*ccb_rcb;

	SIMPLEQ_ENTRY(mpii_ccb)	ccb_link;
};

SIMPLEQ_HEAD(mpii_ccb_list, mpii_ccb);

struct mpii_softc {
	struct device		sc_dev;

	pci_chipset_tag_t	sc_pc;
	pcitag_t		sc_tag;

	void			*sc_ih;

	struct scsi_link	sc_link;

	int			sc_flags;
#define MPII_F_RAID		(1<<1)
#define MPII_F_SAS3		(1<<2)
#define MPII_F_CONFIG_PENDING	(1<<3)

	struct scsibus_softc	*sc_scsibus;

	struct mpii_device	**sc_devs;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_ios;
	bus_dma_tag_t		sc_dmat;

	struct mutex		sc_req_mtx;
	struct mutex		sc_rep_mtx;

	ushort			sc_reply_size;
	ushort			sc_request_size;

	ushort			sc_max_cmds;
	ushort			sc_num_reply_frames;
	u_int			sc_reply_free_qdepth;
	u_int			sc_reply_post_qdepth;

	ushort			sc_chain_sge;
	ushort			sc_max_sgl;

	u_int8_t		sc_ioc_event_replay;

	u_int8_t		sc_porttype;
	u_int8_t		sc_max_volumes;
	u_int16_t		sc_max_devices;
	u_int16_t		sc_vd_count;
	u_int16_t		sc_vd_id_low;
	u_int16_t		sc_pd_id_start;
	int			sc_ioc_number;
	u_int8_t		sc_vf_id;

	struct mpii_ccb		*sc_ccbs;
	struct mpii_ccb_list	sc_ccb_free;
	struct mutex		sc_ccb_free_mtx;

	struct mutex		sc_ccb_mtx;
				/*
				 * this protects the ccb state and list entry
				 * between mpii_scsi_cmd and scsidone.
				 */

	struct mpii_ccb_list	sc_ccb_tmos;
	struct scsi_iohandler	sc_ccb_tmo_handler;

	struct scsi_iopool	sc_iopool;

	struct mpii_dmamem	*sc_requests;

	struct mpii_dmamem	*sc_replies;
	struct mpii_rcb		*sc_rcbs;

	struct mpii_dmamem	*sc_reply_postq;
	struct mpii_reply_descr	*sc_reply_postq_kva;
	u_int			sc_reply_post_host_index;

	struct mpii_dmamem	*sc_reply_freeq;
	u_int			sc_reply_free_host_index;

	struct mpii_rcb_list	sc_evt_sas_queue;
	struct mutex		sc_evt_sas_mtx;
	struct task		sc_evt_sas_task;

	struct mpii_rcb_list	sc_evt_ack_queue;
	struct mutex		sc_evt_ack_mtx;
	struct scsi_iohandler	sc_evt_ack_handler;

	/* scsi ioctl from sd device */
	int			(*sc_ioctl)(struct device *, u_long, caddr_t);

	int			sc_nsensors;
	struct ksensor		*sc_sensors;
	struct ksensordev	sc_sensordev;
};

int	mpii_match(struct device *, void *, void *);
void	mpii_attach(struct device *, struct device *, void *);
int	mpii_detach(struct device *, int);

int	mpii_intr(void *);

struct cfattach mpii_ca = {
	sizeof(struct mpii_softc),
	mpii_match,
	mpii_attach,
	mpii_detach
};

struct cfdriver mpii_cd = {
	NULL,
	"mpii",
	DV_DULL
};

void		mpii_scsi_cmd(struct scsi_xfer *);
void		mpii_scsi_cmd_done(struct mpii_ccb *);
int		mpii_scsi_probe(struct scsi_link *);
int		mpii_scsi_ioctl(struct scsi_link *, u_long, caddr_t, int);

struct scsi_adapter mpii_switch = {
	mpii_scsi_cmd,
	scsi_minphys,
	mpii_scsi_probe,
	NULL,
	mpii_scsi_ioctl
};

struct mpii_dmamem *
		mpii_dmamem_alloc(struct mpii_softc *, size_t);
void		mpii_dmamem_free(struct mpii_softc *,
		    struct mpii_dmamem *);
int		mpii_alloc_ccbs(struct mpii_softc *);
void *		mpii_get_ccb(void *);
void		mpii_put_ccb(void *, void *);
int		mpii_alloc_replies(struct mpii_softc *);
int		mpii_alloc_queues(struct mpii_softc *);
void		mpii_push_reply(struct mpii_softc *, struct mpii_rcb *);
void		mpii_push_replies(struct mpii_softc *);

void		mpii_scsi_cmd_tmo(void *);
void		mpii_scsi_cmd_tmo_handler(void *, void *);
void		mpii_scsi_cmd_tmo_done(struct mpii_ccb *);

int		mpii_insert_dev(struct mpii_softc *, struct mpii_device *);
int		mpii_remove_dev(struct mpii_softc *, struct mpii_device *);
struct mpii_device *
		mpii_find_dev(struct mpii_softc *, u_int16_t);

void		mpii_start(struct mpii_softc *, struct mpii_ccb *);
int		mpii_poll(struct mpii_softc *, struct mpii_ccb *);
void		mpii_poll_done(struct mpii_ccb *);
struct mpii_rcb *
		mpii_reply(struct mpii_softc *, struct mpii_reply_descr *);

void		mpii_wait(struct mpii_softc *, struct mpii_ccb *);
void		mpii_wait_done(struct mpii_ccb *);

void		mpii_init_queues(struct mpii_softc *);

int		mpii_load_xs(struct mpii_ccb *);
int		mpii_load_xs_sas3(struct mpii_ccb *);

u_int32_t	mpii_read(struct mpii_softc *, bus_size_t);
void		mpii_write(struct mpii_softc *, bus_size_t, u_int32_t);
int		mpii_wait_eq(struct mpii_softc *, bus_size_t, u_int32_t,
		    u_int32_t);
int		mpii_wait_ne(struct mpii_softc *, bus_size_t, u_int32_t,
		    u_int32_t);

int		mpii_init(struct mpii_softc *);
int		mpii_reset_soft(struct mpii_softc *);
int		mpii_reset_hard(struct mpii_softc *);

int		mpii_handshake_send(struct mpii_softc *, void *, size_t);
int		mpii_handshake_recv_dword(struct mpii_softc *,
		    u_int32_t *);
int		mpii_handshake_recv(struct mpii_softc *, void *, size_t);

void		mpii_empty_done(struct mpii_ccb *);

int		mpii_iocinit(struct mpii_softc *);
int		mpii_iocfacts(struct mpii_softc *);
int		mpii_portfacts(struct mpii_softc *);
int		mpii_portenable(struct mpii_softc *);
int		mpii_cfg_coalescing(struct mpii_softc *);
int		mpii_board_info(struct mpii_softc *);
int		mpii_target_map(struct mpii_softc *);

int		mpii_eventnotify(struct mpii_softc *);
void		mpii_eventnotify_done(struct mpii_ccb *);
void		mpii_eventack(void *, void *);
void		mpii_eventack_done(struct mpii_ccb *);
void		mpii_event_process(struct mpii_softc *, struct mpii_rcb *);
void		mpii_event_done(struct mpii_softc *, struct mpii_rcb *);
void		mpii_event_sas(void *);
void		mpii_event_raid(struct mpii_softc *,
		    struct mpii_msg_event_reply *);
void		mpii_event_discovery(struct mpii_softc *,
		    struct mpii_msg_event_reply *);

void		mpii_sas_remove_device(struct mpii_softc *, u_int16_t);

int		mpii_req_cfg_header(struct mpii_softc *, u_int8_t,
		    u_int8_t, u_int32_t, int, void *);
int		mpii_req_cfg_page(struct mpii_softc *, u_int32_t, int,
		    void *, int, void *, size_t);

int		mpii_ioctl_cache(struct scsi_link *, u_long, struct dk_cache *);

#if NBIO > 0
int		mpii_ioctl(struct device *, u_long, caddr_t);
int		mpii_ioctl_inq(struct mpii_softc *, struct bioc_inq *);
int		mpii_ioctl_vol(struct mpii_softc *, struct bioc_vol *);
int		mpii_ioctl_disk(struct mpii_softc *, struct bioc_disk *);
int		mpii_bio_hs(struct mpii_softc *, struct bioc_disk *, int,
		    int, int *);
int		mpii_bio_disk(struct mpii_softc *, struct bioc_disk *,
		    u_int8_t);
struct mpii_device *
		mpii_find_vol(struct mpii_softc *, int);
#ifndef SMALL_KERNEL
 int		mpii_bio_volstate(struct mpii_softc *, struct bioc_vol *);
int		mpii_create_sensors(struct mpii_softc *);
void		mpii_refresh_sensors(void *);
#endif /* SMALL_KERNEL */
#endif /* NBIO > 0 */

#define DEVNAME(s)		((s)->sc_dev.dv_xname)

#define dwordsof(s)		(sizeof(s) / sizeof(u_int32_t))

#define mpii_read_db(s)		mpii_read((s), MPII_DOORBELL)
#define mpii_write_db(s, v)	mpii_write((s), MPII_DOORBELL, (v))
#define mpii_read_intr(s)	mpii_read((s), MPII_INTR_STATUS)
#define mpii_write_intr(s, v)	mpii_write((s), MPII_INTR_STATUS, (v))
#define mpii_reply_waiting(s)	((mpii_read_intr((s)) & MPII_INTR_STATUS_REPLY)\
				    == MPII_INTR_STATUS_REPLY)

#define mpii_write_reply_free(s, v) \
    bus_space_write_4((s)->sc_iot, (s)->sc_ioh, \
    MPII_REPLY_FREE_HOST_INDEX, (v))
#define mpii_write_reply_post(s, v) \
    bus_space_write_4((s)->sc_iot, (s)->sc_ioh, \
    MPII_REPLY_POST_HOST_INDEX, (v))

#define mpii_wait_db_int(s)	mpii_wait_ne((s), MPII_INTR_STATUS, \
				    MPII_INTR_STATUS_IOC2SYSDB, 0)
#define mpii_wait_db_ack(s)	mpii_wait_eq((s), MPII_INTR_STATUS, \
				    MPII_INTR_STATUS_SYS2IOCDB, 0)

static inline void
mpii_dvatosge(struct mpii_sge *sge, u_int64_t dva)
{
	htolem32(&sge->sg_addr_lo, dva);
	htolem32(&sge->sg_addr_hi, dva >> 32);
}

#define MPII_PG_EXTENDED	(1<<0)
#define MPII_PG_POLL		(1<<1)
#define MPII_PG_FMT		"\020" "\002POLL" "\001EXTENDED"

static const struct pci_matchid mpii_devices[] = {
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2004 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2008 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2108_3 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2108_4 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2108_5 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2116_1 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2116_2 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2208_1 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2208_2 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2208_3 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2208_4 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2208_5 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2208_6 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2308_1 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2308_2 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2308_3 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS3004 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS3008 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS3108_1 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS3108_2 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS3108_3 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS3108_4 }
};

int
mpii_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid(aux, mpii_devices, nitems(mpii_devices)));
}

void
mpii_attach(struct device *parent, struct device *self, void *aux)
{
	struct mpii_softc		*sc = (struct mpii_softc *)self;
	struct pci_attach_args		*pa = aux;
	pcireg_t			memtype;
	int				r;
	pci_intr_handle_t		ih;
	struct scsibus_attach_args	saa;
	struct mpii_ccb			*ccb;

	sc->sc_pc = pa->pa_pc;
	sc->sc_tag = pa->pa_tag;
	sc->sc_dmat = pa->pa_dmat;

	mtx_init(&sc->sc_req_mtx, IPL_BIO);
	mtx_init(&sc->sc_rep_mtx, IPL_BIO);

	/* find the appropriate memory base */
	for (r = PCI_MAPREG_START; r < PCI_MAPREG_END; r += sizeof(memtype)) {
		memtype = pci_mapreg_type(sc->sc_pc, sc->sc_tag, r);
		if ((memtype & PCI_MAPREG_TYPE_MASK) == PCI_MAPREG_TYPE_MEM)
			break;
	}
	if (r >= PCI_MAPREG_END) {
		printf(": unable to locate system interface registers\n");
		return;
	}

	if (pci_mapreg_map(pa, r, memtype, 0, &sc->sc_iot, &sc->sc_ioh,
	    NULL, &sc->sc_ios, 0xFF) != 0) {
		printf(": unable to map system interface registers\n");
		return;
	}

	/* disable the expansion rom */
	pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_ROM_REG,
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_ROM_REG) &
	    ~PCI_ROM_ENABLE);

	/* disable interrupts */
	mpii_write(sc, MPII_INTR_MASK,
	    MPII_INTR_MASK_RESET | MPII_INTR_MASK_REPLY |
	    MPII_INTR_MASK_DOORBELL);

	/* hook up the interrupt */
	if (pci_intr_map_msi(pa, &ih) != 0 && pci_intr_map(pa, &ih) != 0) {
		printf(": unable to map interrupt\n");
		goto unmap;
	}
	printf(": %s\n", pci_intr_string(sc->sc_pc, ih));

	if (mpii_init(sc) != 0) {
		printf("%s: unable to initialize ioc\n", DEVNAME(sc));
		goto unmap;
	}

	if (mpii_iocfacts(sc) != 0) {
		printf("%s: unable to get iocfacts\n", DEVNAME(sc));
		goto unmap;
	}

	if (mpii_alloc_ccbs(sc) != 0) {
		/* error already printed */
		goto unmap;
	}

	if (mpii_alloc_replies(sc) != 0) {
		printf("%s: unable to allocated reply space\n", DEVNAME(sc));
		goto free_ccbs;
	}

	if (mpii_alloc_queues(sc) != 0) {
		printf("%s: unable to allocate reply queues\n", DEVNAME(sc));
		goto free_replies;
	}

	if (mpii_iocinit(sc) != 0) {
		printf("%s: unable to send iocinit\n", DEVNAME(sc));
		goto free_queues;
	}

	if (mpii_wait_eq(sc, MPII_DOORBELL, MPII_DOORBELL_STATE,
	    MPII_DOORBELL_STATE_OPER) != 0) {
		printf("%s: state: 0x%08x\n", DEVNAME(sc),
			mpii_read_db(sc) & MPII_DOORBELL_STATE);
		printf("%s: operational state timeout\n", DEVNAME(sc));
		goto free_queues;
	}

	mpii_push_replies(sc);
	mpii_init_queues(sc);

	if (mpii_board_info(sc) != 0) {
		printf("%s: unable to get manufacturing page 0\n",
		    DEVNAME(sc));
		goto free_queues;
	}

	if (mpii_portfacts(sc) != 0) {
		printf("%s: unable to get portfacts\n", DEVNAME(sc));
		goto free_queues;
	}

	if (mpii_target_map(sc) != 0) {
		printf("%s: unable to setup target mappings\n", DEVNAME(sc));
		goto free_queues;
	}

	if (mpii_cfg_coalescing(sc) != 0) {
		printf("%s: unable to configure coalescing\n", DEVNAME(sc));
		goto free_queues;
	}

	/* XXX bail on unsupported porttype? */
	if ((sc->sc_porttype == MPII_PORTFACTS_PORTTYPE_SAS_PHYSICAL) ||
	    (sc->sc_porttype == MPII_PORTFACTS_PORTTYPE_SAS_VIRTUAL)) {
		if (mpii_eventnotify(sc) != 0) {
			printf("%s: unable to enable events\n", DEVNAME(sc));
			goto free_queues;
		}
	}

	sc->sc_devs = mallocarray(sc->sc_max_devices,
	    sizeof(struct mpii_device *), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_devs == NULL) {
		printf("%s: unable to allocate memory for mpii_device\n",
		    DEVNAME(sc));
		goto free_queues;
	}

	if (mpii_portenable(sc) != 0) {
		printf("%s: unable to enable port\n", DEVNAME(sc));
		goto free_devs;
	}

	/* we should be good to go now, attach scsibus */
	sc->sc_link.adapter = &mpii_switch;
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = -1;
	sc->sc_link.adapter_buswidth = sc->sc_max_devices;
	sc->sc_link.luns = 1;
	sc->sc_link.openings = sc->sc_max_cmds - 1;
	sc->sc_link.pool = &sc->sc_iopool;

	memset(&saa, 0, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	sc->sc_ih = pci_intr_establish(sc->sc_pc, ih, IPL_BIO,
	    mpii_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL)
		goto free_devs;

	/* force autoconf to wait for the first sas discovery to complete */
	SET(sc->sc_flags, MPII_F_CONFIG_PENDING);
	config_pending_incr();

	/* config_found() returns the scsibus attached to us */
	sc->sc_scsibus = (struct scsibus_softc *) config_found(&sc->sc_dev,
	    &saa, scsiprint);

	/* enable interrupts */
	mpii_write(sc, MPII_INTR_MASK, MPII_INTR_MASK_DOORBELL
	    | MPII_INTR_MASK_RESET);

#if NBIO > 0
	if (ISSET(sc->sc_flags, MPII_F_RAID)) {
		if (bio_register(&sc->sc_dev, mpii_ioctl) != 0)
			panic("%s: controller registration failed",
			    DEVNAME(sc));
		else
			sc->sc_ioctl = mpii_ioctl;

#ifndef SMALL_KERNEL
		if (mpii_create_sensors(sc) != 0)
			printf("%s: unable to create sensors\n", DEVNAME(sc));
#endif
	}
#endif

	return;

free_devs:
	free(sc->sc_devs, M_DEVBUF, 0);
	sc->sc_devs = NULL;

free_queues:
	bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_reply_freeq),
	    0, sc->sc_reply_free_qdepth * 4, BUS_DMASYNC_POSTREAD);
	mpii_dmamem_free(sc, sc->sc_reply_freeq);

	bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_reply_postq),
	    0, sc->sc_reply_post_qdepth * 8, BUS_DMASYNC_POSTREAD);
	mpii_dmamem_free(sc, sc->sc_reply_postq);

free_replies:
	bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_replies),
		0, PAGE_SIZE, BUS_DMASYNC_POSTREAD);
	mpii_dmamem_free(sc, sc->sc_replies);

free_ccbs:
	while ((ccb = mpii_get_ccb(sc)) != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);
	mpii_dmamem_free(sc, sc->sc_requests);
	free(sc->sc_ccbs, M_DEVBUF, 0);

unmap:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	sc->sc_ios = 0;
}

int
mpii_detach(struct device *self, int flags)
{
	struct mpii_softc		*sc = (struct mpii_softc *)self;

	if (sc->sc_ih != NULL) {
		pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
		sc->sc_ih = NULL;
	}
	if (sc->sc_ios != 0) {
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		sc->sc_ios = 0;
	}

	return (0);
}

int
mpii_intr(void *arg)
{
	struct mpii_rcb_list		evts = SIMPLEQ_HEAD_INITIALIZER(evts);
	struct mpii_ccb_list		ccbs = SIMPLEQ_HEAD_INITIALIZER(ccbs);
	struct mpii_softc		*sc = arg;
	struct mpii_reply_descr		*postq = sc->sc_reply_postq_kva, *rdp;
	struct mpii_ccb			*ccb;
	struct mpii_rcb			*rcb;
	int				smid;
	u_int				idx;
	int				rv = 0;

	mtx_enter(&sc->sc_rep_mtx);
	bus_dmamap_sync(sc->sc_dmat,
	    MPII_DMA_MAP(sc->sc_reply_postq),
	    0, sc->sc_reply_post_qdepth * sizeof(*rdp),
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	idx = sc->sc_reply_post_host_index;
	for (;;) {
		rdp = &postq[idx];
		if ((rdp->reply_flags & MPII_REPLY_DESCR_TYPE_MASK) ==
		    MPII_REPLY_DESCR_UNUSED)
			break;
		if (rdp->data == 0xffffffff) {
			/*
			 * ioc is still writing to the reply post queue
			 * race condition - bail!
			 */
			break;
		}

		smid = lemtoh16(&rdp->smid);
		rcb = mpii_reply(sc, rdp);

		if (smid) {
			ccb = &sc->sc_ccbs[smid - 1];
			ccb->ccb_state = MPII_CCB_READY;
			ccb->ccb_rcb = rcb;
			SIMPLEQ_INSERT_TAIL(&ccbs, ccb, ccb_link);
		} else
			SIMPLEQ_INSERT_TAIL(&evts, rcb, rcb_link);

		if (++idx >= sc->sc_reply_post_qdepth)
			idx = 0;

		rv = 1;
	}

	bus_dmamap_sync(sc->sc_dmat,
	    MPII_DMA_MAP(sc->sc_reply_postq),
	    0, sc->sc_reply_post_qdepth * sizeof(*rdp),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	if (rv)
		mpii_write_reply_post(sc, sc->sc_reply_post_host_index = idx);

	mtx_leave(&sc->sc_rep_mtx);

	if (rv == 0)
		return (0);

	while ((ccb = SIMPLEQ_FIRST(&ccbs)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&ccbs, ccb_link);
		ccb->ccb_done(ccb);
	}
	while ((rcb = SIMPLEQ_FIRST(&evts)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&evts, rcb_link);
		mpii_event_process(sc, rcb);
	}

	return (1);
}

int
mpii_load_xs_sas3(struct mpii_ccb *ccb)
{
	struct mpii_softc	*sc = ccb->ccb_sc;
	struct scsi_xfer	*xs = ccb->ccb_cookie;
	struct mpii_msg_scsi_io	*io = ccb->ccb_cmd;
	struct mpii_ieee_sge	*csge, *nsge, *sge;
	bus_dmamap_t		dmap = ccb->ccb_dmamap;
	int			i, error;

	/* Request frame structure is described in the mpii_iocfacts */
	nsge = (struct mpii_ieee_sge *)(io + 1);
	csge = nsge + sc->sc_chain_sge;

	/* zero length transfer still requires an SGE */
	if (xs->datalen == 0) {
		nsge->sg_flags = MPII_IEEE_SGE_END_OF_LIST;
		return (0);
	}

	error = bus_dmamap_load(sc->sc_dmat, dmap, xs->data, xs->datalen, NULL,
	    (xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error) {
		printf("%s: error %d loading dmamap\n", DEVNAME(sc), error);
		return (1);
	}

	for (i = 0; i < dmap->dm_nsegs; i++, nsge++) {
		if (nsge == csge) {
			nsge++;
			/* offset to the chain sge from the beginning */
			io->chain_offset = ((caddr_t)csge - (caddr_t)io) / 4;
			csge->sg_flags = MPII_IEEE_SGE_CHAIN_ELEMENT |
			    MPII_IEEE_SGE_ADDR_SYSTEM;
			/* address of the next sge */
			csge->sg_addr = htole64(ccb->ccb_cmd_dva +
			    ((caddr_t)nsge - (caddr_t)io));
			csge->sg_len = htole32((dmap->dm_nsegs - i) *
			    sizeof(*sge));
		}

		sge = nsge;
		sge->sg_flags = MPII_IEEE_SGE_ADDR_SYSTEM;
		sge->sg_len = htole32(dmap->dm_segs[i].ds_len);
		sge->sg_addr = htole64(dmap->dm_segs[i].ds_addr);
	}

	/* terminate list */
	sge->sg_flags |= MPII_IEEE_SGE_END_OF_LIST;

	bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
	    BUS_DMASYNC_PREWRITE);

	return (0);
}

int
mpii_load_xs(struct mpii_ccb *ccb)
{
	struct mpii_softc	*sc = ccb->ccb_sc;
	struct scsi_xfer	*xs = ccb->ccb_cookie;
	struct mpii_msg_scsi_io	*io = ccb->ccb_cmd;
	struct mpii_sge		*csge, *nsge, *sge;
	bus_dmamap_t		dmap = ccb->ccb_dmamap;
	u_int32_t		flags;
	u_int16_t		len;
	int			i, error;

	/* Request frame structure is described in the mpii_iocfacts */
	nsge = (struct mpii_sge *)(io + 1);
	csge = nsge + sc->sc_chain_sge;

	/* zero length transfer still requires an SGE */
	if (xs->datalen == 0) {
		nsge->sg_hdr = htole32(MPII_SGE_FL_TYPE_SIMPLE |
		    MPII_SGE_FL_LAST | MPII_SGE_FL_EOB | MPII_SGE_FL_EOL);
		return (0);
	}

	error = bus_dmamap_load(sc->sc_dmat, dmap, xs->data, xs->datalen, NULL,
	    (xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error) {
		printf("%s: error %d loading dmamap\n", DEVNAME(sc), error);
		return (1);
	}

	/* safe default starting flags */
	flags = MPII_SGE_FL_TYPE_SIMPLE | MPII_SGE_FL_SIZE_64;
	if (xs->flags & SCSI_DATA_OUT)
		flags |= MPII_SGE_FL_DIR_OUT;

	for (i = 0; i < dmap->dm_nsegs; i++, nsge++) {
		if (nsge == csge) {
			nsge++;
			sge->sg_hdr |= htole32(MPII_SGE_FL_LAST);
			/* offset to the chain sge from the beginning */
			io->chain_offset = ((caddr_t)csge - (caddr_t)io) / 4;
			/* length of the sgl segment we're pointing to */
			len = (dmap->dm_nsegs - i) * sizeof(*sge);
			csge->sg_hdr = htole32(MPII_SGE_FL_TYPE_CHAIN |
			    MPII_SGE_FL_SIZE_64 | len);
			/* address of the next sge */
			mpii_dvatosge(csge, ccb->ccb_cmd_dva +
			    ((caddr_t)nsge - (caddr_t)io));
		}

		sge = nsge;
		sge->sg_hdr = htole32(flags | dmap->dm_segs[i].ds_len);
		mpii_dvatosge(sge, dmap->dm_segs[i].ds_addr);
	}

	/* terminate list */
	sge->sg_hdr |= htole32(MPII_SGE_FL_LAST | MPII_SGE_FL_EOB |
	    MPII_SGE_FL_EOL);

	bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
	    BUS_DMASYNC_PREWRITE);

	return (0);
}

int
mpii_scsi_probe(struct scsi_link *link)
{
	struct mpii_softc *sc = link->adapter_softc;
	struct mpii_cfg_sas_dev_pg0 pg0;
	struct mpii_ecfg_hdr ehdr;
	struct mpii_device *dev;
	uint32_t address;
	int flags;

	if ((sc->sc_porttype != MPII_PORTFACTS_PORTTYPE_SAS_PHYSICAL) &&
	    (sc->sc_porttype != MPII_PORTFACTS_PORTTYPE_SAS_VIRTUAL))
		return (ENXIO);

	dev = sc->sc_devs[link->target];
	if (dev == NULL)
		return (1);

	flags = dev->flags;
	if (ISSET(flags, MPII_DF_HIDDEN) || ISSET(flags, MPII_DF_UNUSED))
		return (1);

	if (ISSET(flags, MPII_DF_VOLUME))
		return (0);

	memset(&ehdr, 0, sizeof(ehdr));	
	ehdr.page_type = MPII_CONFIG_REQ_PAGE_TYPE_EXTENDED;
	ehdr.page_number = 0;
	ehdr.page_version = 0;
	ehdr.ext_page_type = MPII_CONFIG_REQ_EXTPAGE_TYPE_SAS_DEVICE;
	ehdr.ext_page_length = htole16(sizeof(pg0) / 4); /* dwords */

	address = MPII_PGAD_SAS_DEVICE_FORM_HANDLE | (uint32_t)dev->dev_handle;
	if (mpii_req_cfg_page(sc, address, MPII_PG_EXTENDED,
	    &ehdr, 1, &pg0, sizeof(pg0)) != 0) {
		printf("%s: unable to fetch SAS device page 0 for target %u\n",
		    DEVNAME(sc), link->target);

		return (0); /* the handle should still work */
	}

	link->port_wwn = letoh64(pg0.sas_addr);
	link->node_wwn = letoh64(pg0.device_name);

	if (ISSET(lemtoh32(&pg0.device_info),
	    MPII_CFG_SAS_DEV_0_DEVINFO_ATAPI_DEVICE)) {
		link->flags |= SDEV_ATAPI;
		link->quirks |= SDEV_ONLYBIG;
	}

	return (0);
}

u_int32_t
mpii_read(struct mpii_softc *sc, bus_size_t r)
{
	u_int32_t			rv;

	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, 4,
	    BUS_SPACE_BARRIER_READ);
	rv = bus_space_read_4(sc->sc_iot, sc->sc_ioh, r);

	DNPRINTF(MPII_D_RW, "%s: mpii_read %#lx %#x\n", DEVNAME(sc), r, rv);

	return (rv);
}

void
mpii_write(struct mpii_softc *sc, bus_size_t r, u_int32_t v)
{
	DNPRINTF(MPII_D_RW, "%s: mpii_write %#lx %#x\n", DEVNAME(sc), r, v);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, r, v);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, 4,
	    BUS_SPACE_BARRIER_WRITE);
}


int
mpii_wait_eq(struct mpii_softc *sc, bus_size_t r, u_int32_t mask,
    u_int32_t target)
{
	int			i;

	DNPRINTF(MPII_D_RW, "%s: mpii_wait_eq %#lx %#x %#x\n", DEVNAME(sc), r,
	    mask, target);

	for (i = 0; i < 15000; i++) {
		if ((mpii_read(sc, r) & mask) == target)
			return (0);
		delay(1000);
	}

	return (1);
}

int
mpii_wait_ne(struct mpii_softc *sc, bus_size_t r, u_int32_t mask,
    u_int32_t target)
{
	int			i;

	DNPRINTF(MPII_D_RW, "%s: mpii_wait_ne %#lx %#x %#x\n", DEVNAME(sc), r,
	    mask, target);

	for (i = 0; i < 15000; i++) {
		if ((mpii_read(sc, r) & mask) != target)
			return (0);
		delay(1000);
	}

	return (1);
}

int
mpii_init(struct mpii_softc *sc)
{
	u_int32_t		db;
	int			i;

	/* spin until the ioc leaves the reset state */
	if (mpii_wait_ne(sc, MPII_DOORBELL, MPII_DOORBELL_STATE,
	    MPII_DOORBELL_STATE_RESET) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_init timeout waiting to leave "
		    "reset state\n", DEVNAME(sc));
		return (1);
	}

	/* check current ownership */
	db = mpii_read_db(sc);
	if ((db & MPII_DOORBELL_WHOINIT) == MPII_DOORBELL_WHOINIT_PCIPEER) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_init initialised by pci peer\n",
		    DEVNAME(sc));
		return (0);
	}

	for (i = 0; i < 5; i++) {
		switch (db & MPII_DOORBELL_STATE) {
		case MPII_DOORBELL_STATE_READY:
			DNPRINTF(MPII_D_MISC, "%s: mpii_init ioc is ready\n",
			    DEVNAME(sc));
			return (0);

		case MPII_DOORBELL_STATE_OPER:
			DNPRINTF(MPII_D_MISC, "%s: mpii_init ioc is oper\n",
			    DEVNAME(sc));
			if (sc->sc_ioc_event_replay)
				mpii_reset_soft(sc);
			else
				mpii_reset_hard(sc);
			break;

		case MPII_DOORBELL_STATE_FAULT:
			DNPRINTF(MPII_D_MISC, "%s: mpii_init ioc is being "
			    "reset hard\n" , DEVNAME(sc));
			mpii_reset_hard(sc);
			break;

		case MPII_DOORBELL_STATE_RESET:
			DNPRINTF(MPII_D_MISC, "%s: mpii_init waiting to come "
			    "out of reset\n", DEVNAME(sc));
			if (mpii_wait_ne(sc, MPII_DOORBELL, MPII_DOORBELL_STATE,
			    MPII_DOORBELL_STATE_RESET) != 0)
				return (1);
			break;
		}
		db = mpii_read_db(sc);
	}

	return (1);
}

int
mpii_reset_soft(struct mpii_softc *sc)
{
	DNPRINTF(MPII_D_MISC, "%s: mpii_reset_soft\n", DEVNAME(sc));

	if (mpii_read_db(sc) & MPII_DOORBELL_INUSE) {
		return (1);
	}

	mpii_write_db(sc,
	    MPII_DOORBELL_FUNCTION(MPII_FUNCTION_IOC_MESSAGE_UNIT_RESET));

	/* XXX LSI waits 15 sec */
	if (mpii_wait_db_ack(sc) != 0)
		return (1);

	/* XXX LSI waits 15 sec */
	if (mpii_wait_eq(sc, MPII_DOORBELL, MPII_DOORBELL_STATE,
	    MPII_DOORBELL_STATE_READY) != 0)
		return (1);

	/* XXX wait for Sys2IOCDB bit to clear in HIS?? */

	return (0);
}

int
mpii_reset_hard(struct mpii_softc *sc)
{
	u_int16_t		i;

	DNPRINTF(MPII_D_MISC, "%s: mpii_reset_hard\n", DEVNAME(sc));

	mpii_write_intr(sc, 0);

	/* enable diagnostic register */
	mpii_write(sc, MPII_WRITESEQ, MPII_WRITESEQ_FLUSH);
	mpii_write(sc, MPII_WRITESEQ, MPII_WRITESEQ_1);
	mpii_write(sc, MPII_WRITESEQ, MPII_WRITESEQ_2);
	mpii_write(sc, MPII_WRITESEQ, MPII_WRITESEQ_3);
	mpii_write(sc, MPII_WRITESEQ, MPII_WRITESEQ_4);
	mpii_write(sc, MPII_WRITESEQ, MPII_WRITESEQ_5);
	mpii_write(sc, MPII_WRITESEQ, MPII_WRITESEQ_6);

	delay(100);

	if ((mpii_read(sc, MPII_HOSTDIAG) & MPII_HOSTDIAG_DWRE) == 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_reset_hard failure to enable "
		    "diagnostic read/write\n", DEVNAME(sc));
		return(1);
	}

	/* reset ioc */
	mpii_write(sc, MPII_HOSTDIAG, MPII_HOSTDIAG_RESET_ADAPTER);

	/* 240 milliseconds */
	delay(240000);


	/* XXX this whole function should be more robust */

	/* XXX  read the host diagnostic reg until reset adapter bit clears ? */
	for (i = 0; i < 30000; i++) {
		if ((mpii_read(sc, MPII_HOSTDIAG) &
		    MPII_HOSTDIAG_RESET_ADAPTER) == 0)
			break;
		delay(10000);
	}

	/* disable diagnostic register */
	mpii_write(sc, MPII_WRITESEQ, 0xff);

	/* XXX what else? */

	DNPRINTF(MPII_D_MISC, "%s: done with mpii_reset_hard\n", DEVNAME(sc));

	return(0);
}

int
mpii_handshake_send(struct mpii_softc *sc, void *buf, size_t dwords)
{
	u_int32_t		*query = buf;
	int			i;

	/* make sure the doorbell is not in use. */
	if (mpii_read_db(sc) & MPII_DOORBELL_INUSE)
		return (1);

	/* clear pending doorbell interrupts */
	if (mpii_read_intr(sc) & MPII_INTR_STATUS_IOC2SYSDB)
		mpii_write_intr(sc, 0);

	/*
	 * first write the doorbell with the handshake function and the
	 * dword count.
	 */
	mpii_write_db(sc, MPII_DOORBELL_FUNCTION(MPII_FUNCTION_HANDSHAKE) |
	    MPII_DOORBELL_DWORDS(dwords));

	/*
	 * the doorbell used bit will be set because a doorbell function has
	 * started. wait for the interrupt and then ack it.
	 */
	if (mpii_wait_db_int(sc) != 0)
		return (1);
	mpii_write_intr(sc, 0);

	/* poll for the acknowledgement. */
	if (mpii_wait_db_ack(sc) != 0)
		return (1);

	/* write the query through the doorbell. */
	for (i = 0; i < dwords; i++) {
		mpii_write_db(sc, htole32(query[i]));
		if (mpii_wait_db_ack(sc) != 0)
			return (1);
	}

	return (0);
}

int
mpii_handshake_recv_dword(struct mpii_softc *sc, u_int32_t *dword)
{
	u_int16_t		*words = (u_int16_t *)dword;
	int			i;

	for (i = 0; i < 2; i++) {
		if (mpii_wait_db_int(sc) != 0)
			return (1);
		words[i] = letoh16(mpii_read_db(sc) & MPII_DOORBELL_DATA_MASK);
		mpii_write_intr(sc, 0);
	}

	return (0);
}

int
mpii_handshake_recv(struct mpii_softc *sc, void *buf, size_t dwords)
{
	struct mpii_msg_reply	*reply = buf;
	u_int32_t		*dbuf = buf, dummy;
	int			i;

	/* get the first dword so we can read the length out of the header. */
	if (mpii_handshake_recv_dword(sc, &dbuf[0]) != 0)
		return (1);

	DNPRINTF(MPII_D_CMD, "%s: mpii_handshake_recv dwords: %lu reply: %d\n",
	    DEVNAME(sc), dwords, reply->msg_length);

	/*
	 * the total length, in dwords, is in the message length field of the
	 * reply header.
	 */
	for (i = 1; i < MIN(dwords, reply->msg_length); i++) {
		if (mpii_handshake_recv_dword(sc, &dbuf[i]) != 0)
			return (1);
	}

	/* if there's extra stuff to come off the ioc, discard it */
	while (i++ < reply->msg_length) {
		if (mpii_handshake_recv_dword(sc, &dummy) != 0)
			return (1);
		DNPRINTF(MPII_D_CMD, "%s: mpii_handshake_recv dummy read: "
		    "0x%08x\n", DEVNAME(sc), dummy);
	}

	/* wait for the doorbell used bit to be reset and clear the intr */
	if (mpii_wait_db_int(sc) != 0)
		return (1);

	if (mpii_wait_eq(sc, MPII_DOORBELL, MPII_DOORBELL_INUSE, 0) != 0)
		return (1);

	mpii_write_intr(sc, 0);

	return (0);
}

void
mpii_empty_done(struct mpii_ccb *ccb)
{
	/* nothing to do */
}

int
mpii_iocfacts(struct mpii_softc *sc)
{
	struct mpii_msg_iocfacts_request	ifq;
	struct mpii_msg_iocfacts_reply		ifp;
	int					irs;
	int					sge_size;
	u_int					qdepth;

	DNPRINTF(MPII_D_MISC, "%s: mpii_iocfacts\n", DEVNAME(sc));

	memset(&ifq, 0, sizeof(ifq));
	memset(&ifp, 0, sizeof(ifp));

	ifq.function = MPII_FUNCTION_IOC_FACTS;

	if (mpii_handshake_send(sc, &ifq, dwordsof(ifq)) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_iocfacts send failed\n",
		    DEVNAME(sc));
		return (1);
	}

	if (mpii_handshake_recv(sc, &ifp, dwordsof(ifp)) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_iocfacts recv failed\n",
		    DEVNAME(sc));
		return (1);
	}

	sc->sc_ioc_number = ifp.ioc_number;
	sc->sc_vf_id = ifp.vf_id;

	sc->sc_max_volumes = ifp.max_volumes;
	sc->sc_max_devices = ifp.max_volumes + lemtoh16(&ifp.max_targets);

	if (ISSET(lemtoh32(&ifp.ioc_capabilities),
	    MPII_IOCFACTS_CAPABILITY_INTEGRATED_RAID))
		SET(sc->sc_flags, MPII_F_RAID);

	sc->sc_max_cmds = MIN(lemtoh16(&ifp.request_credit),
	    MPII_REQUEST_CREDIT);

	/* SAS3 controllers have different sgl layouts */
	if (ifp.msg_version_maj == 2 && ifp.msg_version_min == 5)
		SET(sc->sc_flags, MPII_F_SAS3);

	/*
	 * The host driver must ensure that there is at least one
	 * unused entry in the Reply Free Queue. One way to ensure
	 * that this requirement is met is to never allocate a number
	 * of reply frames that is a multiple of 16.
	 */
	sc->sc_num_reply_frames = sc->sc_max_cmds + 32;
	if (!(sc->sc_num_reply_frames % 16))
		sc->sc_num_reply_frames--;

	/* must be multiple of 16 */
	sc->sc_reply_post_qdepth = sc->sc_max_cmds +
	    sc->sc_num_reply_frames;
	sc->sc_reply_post_qdepth += 16 - (sc->sc_reply_post_qdepth % 16);

	qdepth = lemtoh16(&ifp.max_reply_descriptor_post_queue_depth);
	if (sc->sc_reply_post_qdepth > qdepth) {
		sc->sc_reply_post_qdepth = qdepth;
		if (sc->sc_reply_post_qdepth < 16) {
			printf("%s: RDPQ is too shallow\n", DEVNAME(sc));
			return (1);
		}
		sc->sc_max_cmds = sc->sc_reply_post_qdepth / 2 - 4;
		sc->sc_num_reply_frames = sc->sc_max_cmds + 4;
	}

	sc->sc_reply_free_qdepth = sc->sc_num_reply_frames +
	    16 - (sc->sc_num_reply_frames % 16);

	/*
	 * Our request frame for an I/O operation looks like this:
	 *
	 * +-------------------+ -.
	 * | mpii_msg_scsi_io  |  |
	 * +-------------------|  |
	 * | mpii_sge          |  |
	 * + - - - - - - - - - +  |
	 * | ...               |  > ioc_request_frame_size
	 * + - - - - - - - - - +  |
	 * | mpii_sge (tail)   |  |
	 * + - - - - - - - - - +  |
	 * | mpii_sge (csge)   |  | --.
	 * + - - - - - - - - - + -'   | chain sge points to the next sge
	 * | mpii_sge          |<-----'
	 * + - - - - - - - - - +
	 * | ...               |
	 * + - - - - - - - - - +
	 * | mpii_sge (tail)   |
	 * +-------------------+
	 * |                   |
	 * ~~~~~~~~~~~~~~~~~~~~~
	 * |                   |
	 * +-------------------+ <- sc_request_size - sizeof(scsi_sense_data)
	 * | scsi_sense_data   |
	 * +-------------------+
	 */

	/* both sizes are in 32-bit words */
	sc->sc_reply_size = ifp.reply_frame_size * 4;
	irs = lemtoh16(&ifp.ioc_request_frame_size) * 4;
	sc->sc_request_size = MPII_REQUEST_SIZE;
	/* make sure we have enough space for scsi sense data */
	if (irs > sc->sc_request_size) {
		sc->sc_request_size = irs + sizeof(struct scsi_sense_data);
		sc->sc_request_size += 16 - (sc->sc_request_size % 16);
	}

	if (ISSET(sc->sc_flags, MPII_F_SAS3)) {
		sge_size = sizeof(struct mpii_ieee_sge);
	} else {
		sge_size = sizeof(struct mpii_sge);
	}

	/* offset to the chain sge */
	sc->sc_chain_sge = (irs - sizeof(struct mpii_msg_scsi_io)) /
	    sge_size - 1;

	/*
	 * A number of simple scatter-gather elements we can fit into the
	 * request buffer after the I/O command minus the chain element.
	 */
	sc->sc_max_sgl = (sc->sc_request_size -
 	    sizeof(struct mpii_msg_scsi_io) - sizeof(struct scsi_sense_data)) /
	    sge_size - 1;

	return (0);
}

int
mpii_iocinit(struct mpii_softc *sc)
{
	struct mpii_msg_iocinit_request		iiq;
	struct mpii_msg_iocinit_reply		iip;

	DNPRINTF(MPII_D_MISC, "%s: mpii_iocinit\n", DEVNAME(sc));

	memset(&iiq, 0, sizeof(iiq));
	memset(&iip, 0, sizeof(iip));

	iiq.function = MPII_FUNCTION_IOC_INIT;
	iiq.whoinit = MPII_WHOINIT_HOST_DRIVER;

	/* XXX JPG do something about vf_id */
	iiq.vf_id = 0;

	iiq.msg_version_maj = 0x02;
	iiq.msg_version_min = 0x00;

	/* XXX JPG ensure compliance with some level and hard-code? */
	iiq.hdr_version_unit = 0x00;
	iiq.hdr_version_dev = 0x00;

	htolem16(&iiq.system_request_frame_size, sc->sc_request_size / 4);

	htolem16(&iiq.reply_descriptor_post_queue_depth,
	    sc->sc_reply_post_qdepth);

	htolem16(&iiq.reply_free_queue_depth, sc->sc_reply_free_qdepth);

	htolem32(&iiq.sense_buffer_address_high,
	    MPII_DMA_DVA(sc->sc_requests) >> 32);

	htolem32(&iiq.system_reply_address_high,
	    MPII_DMA_DVA(sc->sc_replies) >> 32);

	htolem32(&iiq.system_request_frame_base_address_lo,
	    MPII_DMA_DVA(sc->sc_requests));
	htolem32(&iiq.system_request_frame_base_address_hi,
	    MPII_DMA_DVA(sc->sc_requests) >> 32);

	htolem32(&iiq.reply_descriptor_post_queue_address_lo,
	    MPII_DMA_DVA(sc->sc_reply_postq));
	htolem32(&iiq.reply_descriptor_post_queue_address_hi,
	    MPII_DMA_DVA(sc->sc_reply_postq) >> 32);

	htolem32(&iiq.reply_free_queue_address_lo,
	    MPII_DMA_DVA(sc->sc_reply_freeq));
	htolem32(&iiq.reply_free_queue_address_hi,
	    MPII_DMA_DVA(sc->sc_reply_freeq) >> 32);

	if (mpii_handshake_send(sc, &iiq, dwordsof(iiq)) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_iocinit send failed\n",
		    DEVNAME(sc));
		return (1);
	}

	if (mpii_handshake_recv(sc, &iip, dwordsof(iip)) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_iocinit recv failed\n",
		    DEVNAME(sc));
		return (1);
	}

	DNPRINTF(MPII_D_MISC, "%s:  function: 0x%02x msg_length: %d "
	    "whoinit: 0x%02x\n", DEVNAME(sc), iip.function,
	    iip.msg_length, iip.whoinit);
	DNPRINTF(MPII_D_MISC, "%s:  msg_flags: 0x%02x\n", DEVNAME(sc),
	    iip.msg_flags);
	DNPRINTF(MPII_D_MISC, "%s:  vf_id: 0x%02x vp_id: 0x%02x\n", DEVNAME(sc),
	    iip.vf_id, iip.vp_id);
	DNPRINTF(MPII_D_MISC, "%s:  ioc_status: 0x%04x\n", DEVNAME(sc),
	    letoh16(iip.ioc_status));
	DNPRINTF(MPII_D_MISC, "%s:  ioc_loginfo: 0x%08x\n", DEVNAME(sc),
	    letoh32(iip.ioc_loginfo));

	if (lemtoh16(&iip.ioc_status) != MPII_IOCSTATUS_SUCCESS ||
	    lemtoh32(&iip.ioc_loginfo))
		return (1);

	return (0);
}

void
mpii_push_reply(struct mpii_softc *sc, struct mpii_rcb *rcb)
{
	u_int32_t		*rfp;
	u_int			idx;

	if (rcb == NULL)
		return;

	idx = sc->sc_reply_free_host_index;

	rfp = MPII_DMA_KVA(sc->sc_reply_freeq);
	htolem32(&rfp[idx], rcb->rcb_reply_dva);

	if (++idx >= sc->sc_reply_free_qdepth)
		idx = 0;

	mpii_write_reply_free(sc, sc->sc_reply_free_host_index = idx);
}

int
mpii_portfacts(struct mpii_softc *sc)
{
	struct mpii_msg_portfacts_request	*pfq;
	struct mpii_msg_portfacts_reply		*pfp;
	struct mpii_ccb				*ccb;
	int					rv = 1;

	DNPRINTF(MPII_D_MISC, "%s: mpii_portfacts\n", DEVNAME(sc));

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_portfacts mpii_get_ccb fail\n",
		    DEVNAME(sc));
		return (rv);
	}

	ccb->ccb_done = mpii_empty_done;
	pfq = ccb->ccb_cmd;

	memset(pfq, 0, sizeof(*pfq));

	pfq->function = MPII_FUNCTION_PORT_FACTS;
	pfq->chain_offset = 0;
	pfq->msg_flags = 0;
	pfq->port_number = 0;
	pfq->vp_id = 0;
	pfq->vf_id = 0;

	if (mpii_poll(sc, ccb) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_portfacts poll\n",
		    DEVNAME(sc));
		goto err;
	}

	if (ccb->ccb_rcb == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: empty portfacts reply\n",
		    DEVNAME(sc));
		goto err;
	}

	pfp = ccb->ccb_rcb->rcb_reply;
	sc->sc_porttype = pfp->port_type;

	mpii_push_reply(sc, ccb->ccb_rcb);
	rv = 0;
err:
	scsi_io_put(&sc->sc_iopool, ccb);

	return (rv);
}

void
mpii_eventack(void *cookie, void *io)
{
	struct mpii_softc			*sc = cookie;
	struct mpii_ccb				*ccb = io;
	struct mpii_rcb				*rcb, *next;
	struct mpii_msg_event_reply		*enp;
	struct mpii_msg_eventack_request	*eaq;

	mtx_enter(&sc->sc_evt_ack_mtx);
	rcb = SIMPLEQ_FIRST(&sc->sc_evt_ack_queue);
	if (rcb != NULL) {
		next = SIMPLEQ_NEXT(rcb, rcb_link);
		SIMPLEQ_REMOVE_HEAD(&sc->sc_evt_ack_queue, rcb_link);
	}
	mtx_leave(&sc->sc_evt_ack_mtx);

	if (rcb == NULL) {
		scsi_io_put(&sc->sc_iopool, ccb);
		return;
	}

	enp = (struct mpii_msg_event_reply *)rcb->rcb_reply;

	ccb->ccb_done = mpii_eventack_done;
	eaq = ccb->ccb_cmd;

	eaq->function = MPII_FUNCTION_EVENT_ACK;

	eaq->event = enp->event;
	eaq->event_context = enp->event_context;

	mpii_push_reply(sc, rcb);

	mpii_start(sc, ccb);

	if (next != NULL)
		scsi_ioh_add(&sc->sc_evt_ack_handler);
}

void
mpii_eventack_done(struct mpii_ccb *ccb)
{
	struct mpii_softc			*sc = ccb->ccb_sc;

	DNPRINTF(MPII_D_EVT, "%s: event ack done\n", DEVNAME(sc));

	mpii_push_reply(sc, ccb->ccb_rcb);
	scsi_io_put(&sc->sc_iopool, ccb);
}

int
mpii_portenable(struct mpii_softc *sc)
{
	struct mpii_msg_portenable_request	*peq;
	struct mpii_msg_portenable_repy		*pep;
	struct mpii_ccb				*ccb;

	DNPRINTF(MPII_D_MISC, "%s: mpii_portenable\n", DEVNAME(sc));

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_portenable ccb_get\n",
		    DEVNAME(sc));
		return (1);
	}

	ccb->ccb_done = mpii_empty_done;
	peq = ccb->ccb_cmd;

	peq->function = MPII_FUNCTION_PORT_ENABLE;
	peq->vf_id = sc->sc_vf_id;

	if (mpii_poll(sc, ccb) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_portenable poll\n",
		    DEVNAME(sc));
		return (1);
	}

	if (ccb->ccb_rcb == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: empty portenable reply\n",
		    DEVNAME(sc));
		return (1);
	}
	pep = ccb->ccb_rcb->rcb_reply;

	mpii_push_reply(sc, ccb->ccb_rcb);
	scsi_io_put(&sc->sc_iopool, ccb);

	return (0);
}

int
mpii_cfg_coalescing(struct mpii_softc *sc)
{
	struct mpii_cfg_hdr			hdr;
	struct mpii_cfg_ioc_pg1			ipg;

	hdr.page_version = 0;
	hdr.page_length = sizeof(ipg) / 4;
	hdr.page_number = 1;
	hdr.page_type = MPII_CONFIG_REQ_PAGE_TYPE_IOC;
	memset(&ipg, 0, sizeof(ipg));
	if (mpii_req_cfg_page(sc, 0, MPII_PG_POLL, &hdr, 1, &ipg,
	    sizeof(ipg)) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: unable to fetch IOC page 1\n"
		    "page 1\n", DEVNAME(sc));
		return (1);
	}

	if (!ISSET(lemtoh32(&ipg.flags), MPII_CFG_IOC_1_REPLY_COALESCING))
		return (0);

	/* Disable coalescing */
	CLR(ipg.flags, htole32(MPII_CFG_IOC_1_REPLY_COALESCING));
	if (mpii_req_cfg_page(sc, 0, MPII_PG_POLL, &hdr, 0, &ipg,
	    sizeof(ipg)) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: unable to clear coalescing\n",
		    DEVNAME(sc));
		return (1);
	}

	return (0);
}

#define MPII_EVENT_MASKALL(enq)		do {			\
		enq->event_masks[0] = 0xffffffff;		\
		enq->event_masks[1] = 0xffffffff;		\
		enq->event_masks[2] = 0xffffffff;		\
		enq->event_masks[3] = 0xffffffff;		\
	} while (0)

#define MPII_EVENT_UNMASK(enq, evt)	do {			\
		enq->event_masks[evt / 32] &=			\
		    htole32(~(1 << (evt % 32)));		\
	} while (0)

int
mpii_eventnotify(struct mpii_softc *sc)
{
	struct mpii_msg_event_request		*enq;
	struct mpii_ccb				*ccb;

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_eventnotify ccb_get\n",
		    DEVNAME(sc));
		return (1);
	}

	SIMPLEQ_INIT(&sc->sc_evt_sas_queue);
	mtx_init(&sc->sc_evt_sas_mtx, IPL_BIO);
	task_set(&sc->sc_evt_sas_task, mpii_event_sas, sc);

	SIMPLEQ_INIT(&sc->sc_evt_ack_queue);
	mtx_init(&sc->sc_evt_ack_mtx, IPL_BIO);
	scsi_ioh_set(&sc->sc_evt_ack_handler, &sc->sc_iopool,
	    mpii_eventack, sc);

	ccb->ccb_done = mpii_eventnotify_done;
	enq = ccb->ccb_cmd;

	enq->function = MPII_FUNCTION_EVENT_NOTIFICATION;

	/*
	 * Enable reporting of the following events:
	 *
	 * MPII_EVENT_SAS_DISCOVERY
	 * MPII_EVENT_SAS_TOPOLOGY_CHANGE_LIST
	 * MPII_EVENT_SAS_DEVICE_STATUS_CHANGE
	 * MPII_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE
	 * MPII_EVENT_IR_CONFIGURATION_CHANGE_LIST
	 * MPII_EVENT_IR_VOLUME
	 * MPII_EVENT_IR_PHYSICAL_DISK
	 * MPII_EVENT_IR_OPERATION_STATUS
	 */

	MPII_EVENT_MASKALL(enq);
	MPII_EVENT_UNMASK(enq, MPII_EVENT_SAS_DISCOVERY);
	MPII_EVENT_UNMASK(enq, MPII_EVENT_SAS_TOPOLOGY_CHANGE_LIST);
	MPII_EVENT_UNMASK(enq, MPII_EVENT_SAS_DEVICE_STATUS_CHANGE);
	MPII_EVENT_UNMASK(enq, MPII_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE);
	MPII_EVENT_UNMASK(enq, MPII_EVENT_IR_CONFIGURATION_CHANGE_LIST);
	MPII_EVENT_UNMASK(enq, MPII_EVENT_IR_VOLUME);
	MPII_EVENT_UNMASK(enq, MPII_EVENT_IR_PHYSICAL_DISK);
	MPII_EVENT_UNMASK(enq, MPII_EVENT_IR_OPERATION_STATUS);

	mpii_start(sc, ccb);

	return (0);
}

void
mpii_eventnotify_done(struct mpii_ccb *ccb)
{
	struct mpii_softc			*sc = ccb->ccb_sc;
	struct mpii_rcb				*rcb = ccb->ccb_rcb;

	DNPRINTF(MPII_D_EVT, "%s: mpii_eventnotify_done\n", DEVNAME(sc));

	scsi_io_put(&sc->sc_iopool, ccb);
	mpii_event_process(sc, rcb);
}

void
mpii_event_raid(struct mpii_softc *sc, struct mpii_msg_event_reply *enp)
{
	struct mpii_evt_ir_cfg_change_list	*ccl;
	struct mpii_evt_ir_cfg_element		*ce;
	struct mpii_device			*dev;
	u_int16_t				type;
	int					i;

	ccl = (struct mpii_evt_ir_cfg_change_list *)(enp + 1);
	if (ccl->num_elements == 0)
		return;

	if (ISSET(lemtoh32(&ccl->flags), MPII_EVT_IR_CFG_CHANGE_LIST_FOREIGN)) {
		/* bail on foreign configurations */
		return;
	}

	ce = (struct mpii_evt_ir_cfg_element *)(ccl + 1);

	for (i = 0; i < ccl->num_elements; i++, ce++) {
		type = (lemtoh16(&ce->element_flags) &
		    MPII_EVT_IR_CFG_ELEMENT_TYPE_MASK);

		switch (type) {
		case MPII_EVT_IR_CFG_ELEMENT_TYPE_VOLUME:
			switch (ce->reason_code) {
			case MPII_EVT_IR_CFG_ELEMENT_RC_ADDED:
			case MPII_EVT_IR_CFG_ELEMENT_RC_VOLUME_CREATED:
				if (mpii_find_dev(sc,
				    lemtoh16(&ce->vol_dev_handle))) {
					printf("%s: device %#x is already "
					    "configured\n", DEVNAME(sc),
					    lemtoh16(&ce->vol_dev_handle));
					break;
				}
				dev = malloc(sizeof(*dev), M_DEVBUF,
				    M_NOWAIT | M_ZERO);
				if (!dev) {
					printf("%s: failed to allocate a "
					    "device structure\n", DEVNAME(sc));
					break;
				}
				SET(dev->flags, MPII_DF_VOLUME);
				dev->slot = sc->sc_vd_id_low;
				dev->dev_handle = lemtoh16(&ce->vol_dev_handle);
				if (mpii_insert_dev(sc, dev)) {
					free(dev, M_DEVBUF, 0);
					break;
				}
				sc->sc_vd_count++;
				break;
			case MPII_EVT_IR_CFG_ELEMENT_RC_REMOVED:
			case MPII_EVT_IR_CFG_ELEMENT_RC_VOLUME_DELETED:
				if (!(dev = mpii_find_dev(sc,
				    lemtoh16(&ce->vol_dev_handle))))
					break;
				mpii_remove_dev(sc, dev);
				sc->sc_vd_count--;
				break;
			}
			break;
		case MPII_EVT_IR_CFG_ELEMENT_TYPE_VOLUME_DISK:
			if (ce->reason_code ==
			    MPII_EVT_IR_CFG_ELEMENT_RC_PD_CREATED ||
			    ce->reason_code ==
			    MPII_EVT_IR_CFG_ELEMENT_RC_HIDE) {
				/* there should be an underlying sas drive */
				if (!(dev = mpii_find_dev(sc,
				    lemtoh16(&ce->phys_disk_dev_handle))))
					break;
				/* promoted from a hot spare? */
				CLR(dev->flags, MPII_DF_HOT_SPARE);
				SET(dev->flags, MPII_DF_VOLUME_DISK |
				    MPII_DF_HIDDEN);
			}
			break;
		case MPII_EVT_IR_CFG_ELEMENT_TYPE_HOT_SPARE:
			if (ce->reason_code ==
			    MPII_EVT_IR_CFG_ELEMENT_RC_HIDE) {
				/* there should be an underlying sas drive */
				if (!(dev = mpii_find_dev(sc,
				    lemtoh16(&ce->phys_disk_dev_handle))))
					break;
				SET(dev->flags, MPII_DF_HOT_SPARE |
				    MPII_DF_HIDDEN);
			}
			break;
		}
	}
}

void
mpii_event_sas(void *xsc)
{
	struct mpii_softc *sc = xsc;
	struct mpii_rcb *rcb, *next;
	struct mpii_msg_event_reply *enp;
	struct mpii_evt_sas_tcl		*tcl;
	struct mpii_evt_phy_entry	*pe;
	struct mpii_device		*dev;
	int				i;
	u_int16_t			handle;

	mtx_enter(&sc->sc_evt_sas_mtx);
	rcb = SIMPLEQ_FIRST(&sc->sc_evt_sas_queue);
	if (rcb != NULL) {
		next = SIMPLEQ_NEXT(rcb, rcb_link);
		SIMPLEQ_REMOVE_HEAD(&sc->sc_evt_sas_queue, rcb_link);
	}
	mtx_leave(&sc->sc_evt_sas_mtx);

	if (rcb == NULL)
		return;
	if (next != NULL)
		task_add(systq, &sc->sc_evt_sas_task);

	enp = (struct mpii_msg_event_reply *)rcb->rcb_reply;
	switch (lemtoh16(&enp->event)) {
	case MPII_EVENT_SAS_DISCOVERY:
		mpii_event_discovery(sc, enp);
		goto done;
	case MPII_EVENT_SAS_TOPOLOGY_CHANGE_LIST:
		/* handle below */
		break;
	default:
		panic("%s: unexpected event %#x in sas event queue",
		    DEVNAME(sc), lemtoh16(&enp->event));
		/* NOTREACHED */
	}

	tcl = (struct mpii_evt_sas_tcl *)(enp + 1);
	pe = (struct mpii_evt_phy_entry *)(tcl + 1);

	for (i = 0; i < tcl->num_entries; i++, pe++) {
		switch (pe->phy_status & MPII_EVENT_SAS_TOPO_PS_RC_MASK) {
		case MPII_EVENT_SAS_TOPO_PS_RC_ADDED:
			handle = lemtoh16(&pe->dev_handle);
			if (mpii_find_dev(sc, handle)) {
				printf("%s: device %#x is already "
				    "configured\n", DEVNAME(sc), handle);
				break;
			}

			dev = malloc(sizeof(*dev), M_DEVBUF, M_WAITOK | M_ZERO);
			dev->slot = sc->sc_pd_id_start + tcl->start_phy_num + i;
			dev->dev_handle = handle;
			dev->phy_num = tcl->start_phy_num + i;
			if (tcl->enclosure_handle)
				dev->physical_port = tcl->physical_port;
			dev->enclosure = lemtoh16(&tcl->enclosure_handle);
			dev->expander = lemtoh16(&tcl->expander_handle);

			if (mpii_insert_dev(sc, dev)) {
				free(dev, M_DEVBUF, 0);
				break;
			}

			if (sc->sc_scsibus != NULL)
				scsi_probe_target(sc->sc_scsibus, dev->slot);
			break;

		case MPII_EVENT_SAS_TOPO_PS_RC_MISSING:
			dev = mpii_find_dev(sc, lemtoh16(&pe->dev_handle));
			if (dev == NULL)
				break;

			mpii_remove_dev(sc, dev);
			mpii_sas_remove_device(sc, dev->dev_handle);
			if (sc->sc_scsibus != NULL &&
			    !ISSET(dev->flags, MPII_DF_HIDDEN)) {
				scsi_activate(sc->sc_scsibus, dev->slot, -1,
				    DVACT_DEACTIVATE);
				scsi_detach_target(sc->sc_scsibus, dev->slot,
				    DETACH_FORCE);
			}

			free(dev, M_DEVBUF, 0);
			break;
		}
	}

done:
	mpii_event_done(sc, rcb);
}

void
mpii_event_discovery(struct mpii_softc *sc, struct mpii_msg_event_reply *enp)
{
	struct mpii_evt_sas_discovery *esd =
	    (struct mpii_evt_sas_discovery *)(enp + 1);

	if (esd->reason_code == MPII_EVENT_SAS_DISC_REASON_CODE_COMPLETED) {
		if (esd->discovery_status != 0) {
			printf("%s: sas discovery completed with status %#x\n",
			    DEVNAME(sc), esd->discovery_status);
		}

		if (ISSET(sc->sc_flags, MPII_F_CONFIG_PENDING)) {
			CLR(sc->sc_flags, MPII_F_CONFIG_PENDING);
			config_pending_decr();
		}
	}
}

void
mpii_event_process(struct mpii_softc *sc, struct mpii_rcb *rcb)
{
	struct mpii_msg_event_reply		*enp;

	enp = (struct mpii_msg_event_reply *)rcb->rcb_reply;

	DNPRINTF(MPII_D_EVT, "%s: mpii_event_process: %#x\n", DEVNAME(sc),
	    letoh16(enp->event));

	switch (lemtoh16(&enp->event)) {
	case MPII_EVENT_EVENT_CHANGE:
		/* should be properly ignored */
		break;
	case MPII_EVENT_SAS_DISCOVERY:
	case MPII_EVENT_SAS_TOPOLOGY_CHANGE_LIST:
		mtx_enter(&sc->sc_evt_sas_mtx);
		SIMPLEQ_INSERT_TAIL(&sc->sc_evt_sas_queue, rcb, rcb_link);
		mtx_leave(&sc->sc_evt_sas_mtx);
		task_add(systq, &sc->sc_evt_sas_task);
		return;
	case MPII_EVENT_SAS_DEVICE_STATUS_CHANGE:
		break;
	case MPII_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:
		break;
	case MPII_EVENT_IR_VOLUME: {
		struct mpii_evt_ir_volume	*evd =
		    (struct mpii_evt_ir_volume *)(enp + 1);
		struct mpii_device		*dev;
#if NBIO > 0
		const char *vol_states[] = {
			BIOC_SVINVALID_S,
			BIOC_SVOFFLINE_S,
			BIOC_SVBUILDING_S,
			BIOC_SVONLINE_S,
			BIOC_SVDEGRADED_S,
			BIOC_SVONLINE_S,
		};
#endif

		if (cold)
			break;
		KERNEL_LOCK();
		dev = mpii_find_dev(sc, lemtoh16(&evd->vol_dev_handle));
		KERNEL_UNLOCK();
		if (dev == NULL)
			break;
#if NBIO > 0
		if (evd->reason_code == MPII_EVENT_IR_VOL_RC_STATE_CHANGED)
			printf("%s: volume %d state changed from %s to %s\n",
			    DEVNAME(sc), dev->slot - sc->sc_vd_id_low,
			    vol_states[evd->prev_value],
			    vol_states[evd->new_value]);
#endif
		if (evd->reason_code == MPII_EVENT_IR_VOL_RC_STATUS_CHANGED &&
		    ISSET(evd->new_value, MPII_CFG_RAID_VOL_0_STATUS_RESYNC) &&
		    !ISSET(evd->prev_value, MPII_CFG_RAID_VOL_0_STATUS_RESYNC))
			printf("%s: started resync on a volume %d\n",
			    DEVNAME(sc), dev->slot - sc->sc_vd_id_low);
		}
		break;
	case MPII_EVENT_IR_PHYSICAL_DISK:
		break;
	case MPII_EVENT_IR_CONFIGURATION_CHANGE_LIST:
		mpii_event_raid(sc, enp);
		break;
	case MPII_EVENT_IR_OPERATION_STATUS: {
		struct mpii_evt_ir_status	*evs =
		    (struct mpii_evt_ir_status *)(enp + 1);
		struct mpii_device		*dev;

		KERNEL_LOCK();
		dev = mpii_find_dev(sc, lemtoh16(&evs->vol_dev_handle));
		KERNEL_UNLOCK();
		if (dev != NULL &&
		    evs->operation == MPII_EVENT_IR_RAIDOP_RESYNC)
			dev->percent = evs->percent;
		break;
		}
	default:
		DNPRINTF(MPII_D_EVT, "%s:  unhandled event 0x%02x\n",
		    DEVNAME(sc), lemtoh16(&enp->event));
	}

	mpii_event_done(sc, rcb);
}

void
mpii_event_done(struct mpii_softc *sc, struct mpii_rcb *rcb)
{
	struct mpii_msg_event_reply *enp = rcb->rcb_reply;

	if (enp->ack_required) {
		mtx_enter(&sc->sc_evt_ack_mtx);
		SIMPLEQ_INSERT_TAIL(&sc->sc_evt_ack_queue, rcb, rcb_link);
		mtx_leave(&sc->sc_evt_ack_mtx);
		scsi_ioh_add(&sc->sc_evt_ack_handler);
	} else
		mpii_push_reply(sc, rcb);
}

void
mpii_sas_remove_device(struct mpii_softc *sc, u_int16_t handle)
{
	struct mpii_msg_scsi_task_request	*stq;
	struct mpii_msg_sas_oper_request	*soq;
	struct mpii_ccb				*ccb;

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL)
		return;

	stq = ccb->ccb_cmd;
	stq->function = MPII_FUNCTION_SCSI_TASK_MGMT;
	stq->task_type = MPII_SCSI_TASK_TARGET_RESET;
	htolem16(&stq->dev_handle, handle);

	ccb->ccb_done = mpii_empty_done;
	mpii_wait(sc, ccb);

	if (ccb->ccb_rcb != NULL)
		mpii_push_reply(sc, ccb->ccb_rcb);

	/* reuse a ccb */
	ccb->ccb_state = MPII_CCB_READY;
	ccb->ccb_rcb = NULL;

	soq = ccb->ccb_cmd;
	memset(soq, 0, sizeof(*soq));
	soq->function = MPII_FUNCTION_SAS_IO_UNIT_CONTROL;
	soq->operation = MPII_SAS_OP_REMOVE_DEVICE;
	htolem16(&soq->dev_handle, handle);

	ccb->ccb_done = mpii_empty_done;
	mpii_wait(sc, ccb);
	if (ccb->ccb_rcb != NULL)
		mpii_push_reply(sc, ccb->ccb_rcb);

	scsi_io_put(&sc->sc_iopool, ccb);
}

int
mpii_board_info(struct mpii_softc *sc)
{
	struct mpii_msg_iocfacts_request	ifq;
	struct mpii_msg_iocfacts_reply		ifp;
	struct mpii_cfg_manufacturing_pg0	mpg;
	struct mpii_cfg_hdr			hdr;

	memset(&ifq, 0, sizeof(ifq));
	memset(&ifp, 0, sizeof(ifp));

	ifq.function = MPII_FUNCTION_IOC_FACTS;

	if (mpii_handshake_send(sc, &ifq, dwordsof(ifq)) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: failed to request ioc facts\n",
		    DEVNAME(sc));
		return (1);
	}

	if (mpii_handshake_recv(sc, &ifp, dwordsof(ifp)) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: failed to receive ioc facts\n",
		    DEVNAME(sc));
		return (1);
	}

	hdr.page_version = 0;
	hdr.page_length = sizeof(mpg) / 4;
	hdr.page_number = 0;
	hdr.page_type = MPII_CONFIG_REQ_PAGE_TYPE_MANUFACTURING;
	memset(&mpg, 0, sizeof(mpg));
	if (mpii_req_cfg_page(sc, 0, MPII_PG_POLL, &hdr, 1, &mpg,
	    sizeof(mpg)) != 0) {
		printf("%s: unable to fetch manufacturing page 0\n",
		    DEVNAME(sc));
		return (EINVAL);
	}

	printf("%s: %s, firmware %u.%u.%u.%u%s, MPI %u.%u\n", DEVNAME(sc),
	    mpg.board_name, ifp.fw_version_maj, ifp.fw_version_min,
	    ifp.fw_version_unit, ifp.fw_version_dev,
	    ISSET(sc->sc_flags, MPII_F_RAID) ? " IR" : "",
	    ifp.msg_version_maj, ifp.msg_version_min);

	return (0);
}

int
mpii_target_map(struct mpii_softc *sc)
{
	struct mpii_cfg_hdr			hdr;
	struct mpii_cfg_ioc_pg8			ipg;
	int					flags, pad = 0;

	hdr.page_version = 0;
	hdr.page_length = sizeof(ipg) / 4;
	hdr.page_number = 8;
	hdr.page_type = MPII_CONFIG_REQ_PAGE_TYPE_IOC;
	memset(&ipg, 0, sizeof(ipg));
	if (mpii_req_cfg_page(sc, 0, MPII_PG_POLL, &hdr, 1, &ipg,
	    sizeof(ipg)) != 0) {
		printf("%s: unable to fetch ioc page 8\n",
		    DEVNAME(sc));
		return (EINVAL);
	}

	if (lemtoh16(&ipg.flags) & MPII_IOC_PG8_FLAGS_RESERVED_TARGETID_0)
		pad = 1;

	flags = lemtoh16(&ipg.ir_volume_mapping_flags) &
	    MPII_IOC_PG8_IRFLAGS_VOLUME_MAPPING_MODE_MASK;
	if (ISSET(sc->sc_flags, MPII_F_RAID)) {
		if (flags == MPII_IOC_PG8_IRFLAGS_LOW_VOLUME_MAPPING) {
			sc->sc_vd_id_low += pad;
			pad = sc->sc_max_volumes; /* for sc_pd_id_start */
		} else
			sc->sc_vd_id_low = sc->sc_max_devices -
			    sc->sc_max_volumes;
	}

	sc->sc_pd_id_start += pad;

	return (0);
}

int
mpii_req_cfg_header(struct mpii_softc *sc, u_int8_t type, u_int8_t number,
    u_int32_t address, int flags, void *p)
{
	struct mpii_msg_config_request		*cq;
	struct mpii_msg_config_reply		*cp;
	struct mpii_ccb				*ccb;
	struct mpii_cfg_hdr			*hdr = p;
	struct mpii_ecfg_hdr			*ehdr = p;
	int					etype = 0;
	int					rv = 0;

	DNPRINTF(MPII_D_MISC, "%s: mpii_req_cfg_header type: %#x number: %x "
	    "address: 0x%08x flags: 0x%b\n", DEVNAME(sc), type, number,
	    address, flags, MPII_PG_FMT);

	ccb = scsi_io_get(&sc->sc_iopool,
	    ISSET(flags, MPII_PG_POLL) ? SCSI_NOSLEEP : 0);
	if (ccb == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_cfg_header ccb_get\n",
		    DEVNAME(sc));
		return (1);
	}

	if (ISSET(flags, MPII_PG_EXTENDED)) {
		etype = type;
		type = MPII_CONFIG_REQ_PAGE_TYPE_EXTENDED;
	}

	cq = ccb->ccb_cmd;

	cq->function = MPII_FUNCTION_CONFIG;

	cq->action = MPII_CONFIG_REQ_ACTION_PAGE_HEADER;

	cq->config_header.page_number = number;
	cq->config_header.page_type = type;
	cq->ext_page_type = etype;
	htolem32(&cq->page_address, address);
	htolem32(&cq->page_buffer.sg_hdr, MPII_SGE_FL_TYPE_SIMPLE |
	    MPII_SGE_FL_LAST | MPII_SGE_FL_EOB | MPII_SGE_FL_EOL);

	ccb->ccb_done = mpii_empty_done;
	if (ISSET(flags, MPII_PG_POLL)) {
		if (mpii_poll(sc, ccb) != 0) {
			DNPRINTF(MPII_D_MISC, "%s: mpii_cfg_header poll\n",
			    DEVNAME(sc));
			return (1);
		}
	} else
		mpii_wait(sc, ccb);

	if (ccb->ccb_rcb == NULL) {
		scsi_io_put(&sc->sc_iopool, ccb);
		return (1);
	}
	cp = ccb->ccb_rcb->rcb_reply;

	DNPRINTF(MPII_D_MISC, "%s:  action: 0x%02x sgl_flags: 0x%02x "
	    "msg_length: %d function: 0x%02x\n", DEVNAME(sc), cp->action,
	    cp->sgl_flags, cp->msg_length, cp->function);
	DNPRINTF(MPII_D_MISC, "%s:  ext_page_length: %d ext_page_type: 0x%02x "
	    "msg_flags: 0x%02x\n", DEVNAME(sc),
	    letoh16(cp->ext_page_length), cp->ext_page_type,
	    cp->msg_flags);
	DNPRINTF(MPII_D_MISC, "%s:  vp_id: 0x%02x vf_id: 0x%02x\n", DEVNAME(sc),
	    cp->vp_id, cp->vf_id);
	DNPRINTF(MPII_D_MISC, "%s:  ioc_status: 0x%04x\n", DEVNAME(sc),
	    letoh16(cp->ioc_status));
	DNPRINTF(MPII_D_MISC, "%s:  ioc_loginfo: 0x%08x\n", DEVNAME(sc),
	    letoh32(cp->ioc_loginfo));
	DNPRINTF(MPII_D_MISC, "%s:  page_version: 0x%02x page_length: %d "
	    "page_number: 0x%02x page_type: 0x%02x\n", DEVNAME(sc),
	    cp->config_header.page_version,
	    cp->config_header.page_length,
	    cp->config_header.page_number,
	    cp->config_header.page_type);

	if (lemtoh16(&cp->ioc_status) != MPII_IOCSTATUS_SUCCESS)
		rv = 1;
	else if (ISSET(flags, MPII_PG_EXTENDED)) {
		memset(ehdr, 0, sizeof(*ehdr));
		ehdr->page_version = cp->config_header.page_version;
		ehdr->page_number = cp->config_header.page_number;
		ehdr->page_type = cp->config_header.page_type;
		ehdr->ext_page_length = cp->ext_page_length;
		ehdr->ext_page_type = cp->ext_page_type;
	} else
		*hdr = cp->config_header;

	mpii_push_reply(sc, ccb->ccb_rcb);
	scsi_io_put(&sc->sc_iopool, ccb);

	return (rv);
}

int
mpii_req_cfg_page(struct mpii_softc *sc, u_int32_t address, int flags,
    void *p, int read, void *page, size_t len)
{
	struct mpii_msg_config_request		*cq;
	struct mpii_msg_config_reply		*cp;
	struct mpii_ccb				*ccb;
	struct mpii_cfg_hdr			*hdr = p;
	struct mpii_ecfg_hdr			*ehdr = p;
	caddr_t					kva;
	int					page_length;
	int					rv = 0;

	DNPRINTF(MPII_D_MISC, "%s: mpii_cfg_page address: %d read: %d "
	    "type: %x\n", DEVNAME(sc), address, read, hdr->page_type);

	page_length = ISSET(flags, MPII_PG_EXTENDED) ?
	    lemtoh16(&ehdr->ext_page_length) : hdr->page_length;

	if (len > sc->sc_request_size - sizeof(*cq) || len < page_length * 4)
		return (1);

	ccb = scsi_io_get(&sc->sc_iopool,
	    ISSET(flags, MPII_PG_POLL) ? SCSI_NOSLEEP : 0);
	if (ccb == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_cfg_page ccb_get\n",
		    DEVNAME(sc));
		return (1);
	}

	cq = ccb->ccb_cmd;

	cq->function = MPII_FUNCTION_CONFIG;

	cq->action = (read ? MPII_CONFIG_REQ_ACTION_PAGE_READ_CURRENT :
	    MPII_CONFIG_REQ_ACTION_PAGE_WRITE_CURRENT);

	if (ISSET(flags, MPII_PG_EXTENDED)) {
		cq->config_header.page_version = ehdr->page_version;
		cq->config_header.page_number = ehdr->page_number;
		cq->config_header.page_type = ehdr->page_type;
		cq->ext_page_len = ehdr->ext_page_length;
		cq->ext_page_type = ehdr->ext_page_type;
	} else
		cq->config_header = *hdr;
	cq->config_header.page_type &= MPII_CONFIG_REQ_PAGE_TYPE_MASK;
	htolem32(&cq->page_address, address);
	htolem32(&cq->page_buffer.sg_hdr, MPII_SGE_FL_TYPE_SIMPLE |
	    MPII_SGE_FL_LAST | MPII_SGE_FL_EOB | MPII_SGE_FL_EOL |
	    MPII_SGE_FL_SIZE_64 | (page_length * 4) |
	    (read ? MPII_SGE_FL_DIR_IN : MPII_SGE_FL_DIR_OUT));

	/* bounce the page via the request space to avoid more bus_dma games */
	mpii_dvatosge(&cq->page_buffer, ccb->ccb_cmd_dva +
	    sizeof(struct mpii_msg_config_request));

	kva = ccb->ccb_cmd;
	kva += sizeof(struct mpii_msg_config_request);

	if (!read)
		memcpy(kva, page, len);

	ccb->ccb_done = mpii_empty_done;
	if (ISSET(flags, MPII_PG_POLL)) {
		if (mpii_poll(sc, ccb) != 0) {
			DNPRINTF(MPII_D_MISC, "%s: mpii_cfg_header poll\n",
			    DEVNAME(sc));
			return (1);
		}
	} else
		mpii_wait(sc, ccb);

	if (ccb->ccb_rcb == NULL) {
		scsi_io_put(&sc->sc_iopool, ccb);
		return (1);
	}
	cp = ccb->ccb_rcb->rcb_reply;

	DNPRINTF(MPII_D_MISC, "%s:  action: 0x%02x msg_length: %d "
	    "function: 0x%02x\n", DEVNAME(sc), cp->action, cp->msg_length,
	    cp->function);
	DNPRINTF(MPII_D_MISC, "%s:  ext_page_length: %d ext_page_type: 0x%02x "
	    "msg_flags: 0x%02x\n", DEVNAME(sc),
	    letoh16(cp->ext_page_length), cp->ext_page_type,
	    cp->msg_flags);
	DNPRINTF(MPII_D_MISC, "%s:  vp_id: 0x%02x vf_id: 0x%02x\n", DEVNAME(sc),
	    cp->vp_id, cp->vf_id);
	DNPRINTF(MPII_D_MISC, "%s:  ioc_status: 0x%04x\n", DEVNAME(sc),
	    letoh16(cp->ioc_status));
	DNPRINTF(MPII_D_MISC, "%s:  ioc_loginfo: 0x%08x\n", DEVNAME(sc),
	    letoh32(cp->ioc_loginfo));
	DNPRINTF(MPII_D_MISC, "%s:  page_version: 0x%02x page_length: %d "
	    "page_number: 0x%02x page_type: 0x%02x\n", DEVNAME(sc),
	    cp->config_header.page_version,
	    cp->config_header.page_length,
	    cp->config_header.page_number,
	    cp->config_header.page_type);

	if (lemtoh16(&cp->ioc_status) != MPII_IOCSTATUS_SUCCESS)
		rv = 1;
	else if (read)
		memcpy(page, kva, len);

	mpii_push_reply(sc, ccb->ccb_rcb);
	scsi_io_put(&sc->sc_iopool, ccb);

	return (rv);
}

struct mpii_rcb *
mpii_reply(struct mpii_softc *sc, struct mpii_reply_descr *rdp)
{
	struct mpii_rcb		*rcb = NULL;
	u_int32_t		rfid;

	DNPRINTF(MPII_D_INTR, "%s: mpii_reply\n", DEVNAME(sc));

	if ((rdp->reply_flags & MPII_REPLY_DESCR_TYPE_MASK) ==
	    MPII_REPLY_DESCR_ADDRESS_REPLY) {
		rfid = (lemtoh32(&rdp->frame_addr) -
		    (u_int32_t)MPII_DMA_DVA(sc->sc_replies)) /
		    sc->sc_reply_size;

		bus_dmamap_sync(sc->sc_dmat,
		    MPII_DMA_MAP(sc->sc_replies), sc->sc_reply_size * rfid,
		    sc->sc_reply_size, BUS_DMASYNC_POSTREAD);

		rcb = &sc->sc_rcbs[rfid];
	}

	memset(rdp, 0xff, sizeof(*rdp));

	bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_reply_postq),
	    8 * sc->sc_reply_post_host_index, 8,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	return (rcb);
}

struct mpii_dmamem *
mpii_dmamem_alloc(struct mpii_softc *sc, size_t size)
{
	struct mpii_dmamem	*mdm;
	int			nsegs;

	mdm = malloc(sizeof(*mdm), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (mdm == NULL)
		return (NULL);

	mdm->mdm_size = size;

	if (bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &mdm->mdm_map) != 0)
		goto mdmfree;

	if (bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &mdm->mdm_seg,
	    1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0)
		goto destroy;

	if (bus_dmamem_map(sc->sc_dmat, &mdm->mdm_seg, nsegs, size,
	    &mdm->mdm_kva, BUS_DMA_NOWAIT) != 0)
		goto free;

	if (bus_dmamap_load(sc->sc_dmat, mdm->mdm_map, mdm->mdm_kva, size,
	    NULL, BUS_DMA_NOWAIT) != 0)
		goto unmap;

	return (mdm);

unmap:
	bus_dmamem_unmap(sc->sc_dmat, mdm->mdm_kva, size);
free:
	bus_dmamem_free(sc->sc_dmat, &mdm->mdm_seg, 1);
destroy:
	bus_dmamap_destroy(sc->sc_dmat, mdm->mdm_map);
mdmfree:
	free(mdm, M_DEVBUF, 0);

	return (NULL);
}

void
mpii_dmamem_free(struct mpii_softc *sc, struct mpii_dmamem *mdm)
{
	DNPRINTF(MPII_D_MEM, "%s: mpii_dmamem_free %p\n", DEVNAME(sc), mdm);

	bus_dmamap_unload(sc->sc_dmat, mdm->mdm_map);
	bus_dmamem_unmap(sc->sc_dmat, mdm->mdm_kva, mdm->mdm_size);
	bus_dmamem_free(sc->sc_dmat, &mdm->mdm_seg, 1);
	bus_dmamap_destroy(sc->sc_dmat, mdm->mdm_map);
	free(mdm, M_DEVBUF, 0);
}

int
mpii_insert_dev(struct mpii_softc *sc, struct mpii_device *dev)
{
	int		slot;	/* initial hint */

	if (dev == NULL || dev->slot < 0)
		return (1);
	slot = dev->slot;

	while (slot < sc->sc_max_devices && sc->sc_devs[slot] != NULL)
		slot++;

	if (slot >= sc->sc_max_devices)
		return (1);

	dev->slot = slot;
	sc->sc_devs[slot] = dev;

	return (0);
}

int
mpii_remove_dev(struct mpii_softc *sc, struct mpii_device *dev)
{
	int			i;

	if (dev == NULL)
		return (1);

	for (i = 0; i < sc->sc_max_devices; i++) {
		if (sc->sc_devs[i] == NULL)
			continue;

		if (sc->sc_devs[i]->dev_handle == dev->dev_handle) {
			sc->sc_devs[i] = NULL;
			return (0);
		}
	}

	return (1);
}

struct mpii_device *
mpii_find_dev(struct mpii_softc *sc, u_int16_t handle)
{
	int			i;

	for (i = 0; i < sc->sc_max_devices; i++) {
		if (sc->sc_devs[i] == NULL)
			continue;

		if (sc->sc_devs[i]->dev_handle == handle)
			return (sc->sc_devs[i]);
	}

	return (NULL);
}

int
mpii_alloc_ccbs(struct mpii_softc *sc)
{
	struct mpii_ccb		*ccb;
	u_int8_t		*cmd;
	int			i;

	SIMPLEQ_INIT(&sc->sc_ccb_free);
	SIMPLEQ_INIT(&sc->sc_ccb_tmos);
	mtx_init(&sc->sc_ccb_free_mtx, IPL_BIO);
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_ioh_set(&sc->sc_ccb_tmo_handler, &sc->sc_iopool,
	    mpii_scsi_cmd_tmo_handler, sc);

	sc->sc_ccbs = mallocarray((sc->sc_max_cmds-1), sizeof(*ccb),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_ccbs == NULL) {
		printf("%s: unable to allocate ccbs\n", DEVNAME(sc));
		return (1);
	}

	sc->sc_requests = mpii_dmamem_alloc(sc,
	    sc->sc_request_size * sc->sc_max_cmds);
	if (sc->sc_requests == NULL) {
		printf("%s: unable to allocate ccb dmamem\n", DEVNAME(sc));
		goto free_ccbs;
	}
	cmd = MPII_DMA_KVA(sc->sc_requests);

	/*
	 * we have sc->sc_max_cmds system request message
	 * frames, but smid zero cannot be used. so we then
	 * have (sc->sc_max_cmds - 1) number of ccbs
	 */
	for (i = 1; i < sc->sc_max_cmds; i++) {
		ccb = &sc->sc_ccbs[i - 1];

		if (bus_dmamap_create(sc->sc_dmat, MAXPHYS, sc->sc_max_sgl,
		    MAXPHYS, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &ccb->ccb_dmamap) != 0) {
			printf("%s: unable to create dma map\n", DEVNAME(sc));
			goto free_maps;
		}

		ccb->ccb_sc = sc;
		htolem16(&ccb->ccb_smid, i);
		ccb->ccb_offset = sc->sc_request_size * i;

		ccb->ccb_cmd = &cmd[ccb->ccb_offset];
		ccb->ccb_cmd_dva = (u_int32_t)MPII_DMA_DVA(sc->sc_requests) +
		    ccb->ccb_offset;

		DNPRINTF(MPII_D_CCB, "%s: mpii_alloc_ccbs(%d) ccb: %p map: %p "
		    "sc: %p smid: %#x offs: %#lx cmd: %p dva: %#lx\n",
		    DEVNAME(sc), i, ccb, ccb->ccb_dmamap, ccb->ccb_sc,
		    ccb->ccb_smid, ccb->ccb_offset, ccb->ccb_cmd,
		    ccb->ccb_cmd_dva);

		mpii_put_ccb(sc, ccb);
	}

	scsi_iopool_init(&sc->sc_iopool, sc, mpii_get_ccb, mpii_put_ccb);

	return (0);

free_maps:
	while ((ccb = mpii_get_ccb(sc)) != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);

	mpii_dmamem_free(sc, sc->sc_requests);
free_ccbs:
	free(sc->sc_ccbs, M_DEVBUF, 0);

	return (1);
}

void
mpii_put_ccb(void *cookie, void *io)
{
	struct mpii_softc	*sc = cookie;
	struct mpii_ccb		*ccb = io;

	DNPRINTF(MPII_D_CCB, "%s: mpii_put_ccb %p\n", DEVNAME(sc), ccb);

	ccb->ccb_state = MPII_CCB_FREE;
	ccb->ccb_cookie = NULL;
	ccb->ccb_done = NULL;
	ccb->ccb_rcb = NULL;
	memset(ccb->ccb_cmd, 0, sc->sc_request_size);

	KERNEL_UNLOCK();
	mtx_enter(&sc->sc_ccb_free_mtx);
	SIMPLEQ_INSERT_HEAD(&sc->sc_ccb_free, ccb, ccb_link);
	mtx_leave(&sc->sc_ccb_free_mtx);
	KERNEL_LOCK();
}

void *
mpii_get_ccb(void *cookie)
{
	struct mpii_softc	*sc = cookie;
	struct mpii_ccb		*ccb;

	KERNEL_UNLOCK();

	mtx_enter(&sc->sc_ccb_free_mtx);
	ccb = SIMPLEQ_FIRST(&sc->sc_ccb_free);
	if (ccb != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_free, ccb_link);
		ccb->ccb_state = MPII_CCB_READY;
	}
	mtx_leave(&sc->sc_ccb_free_mtx);

	KERNEL_LOCK();

	DNPRINTF(MPII_D_CCB, "%s: mpii_get_ccb %p\n", DEVNAME(sc), ccb);

	return (ccb);
}

int
mpii_alloc_replies(struct mpii_softc *sc)
{
	DNPRINTF(MPII_D_MISC, "%s: mpii_alloc_replies\n", DEVNAME(sc));

	sc->sc_rcbs = mallocarray(sc->sc_num_reply_frames,
	    sizeof(struct mpii_rcb), M_DEVBUF, M_NOWAIT);
	if (sc->sc_rcbs == NULL)
		return (1);

	sc->sc_replies = mpii_dmamem_alloc(sc, sc->sc_reply_size *
	    sc->sc_num_reply_frames);
	if (sc->sc_replies == NULL) {
		free(sc->sc_rcbs, M_DEVBUF, 0);
		return (1);
	}

	return (0);
}

void
mpii_push_replies(struct mpii_softc *sc)
{
	struct mpii_rcb		*rcb;
	caddr_t			kva = MPII_DMA_KVA(sc->sc_replies);
	int			i;

	bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_replies),
	    0, sc->sc_reply_size * sc->sc_num_reply_frames,
	    BUS_DMASYNC_PREREAD);

	for (i = 0; i < sc->sc_num_reply_frames; i++) {
		rcb = &sc->sc_rcbs[i];

		rcb->rcb_reply = kva + sc->sc_reply_size * i;
		rcb->rcb_reply_dva = (u_int32_t)MPII_DMA_DVA(sc->sc_replies) +
		    sc->sc_reply_size * i;
		mpii_push_reply(sc, rcb);
	}
}

void
mpii_start(struct mpii_softc *sc, struct mpii_ccb *ccb)
{
	struct mpii_request_header	*rhp;
	struct mpii_request_descr	descr;
	u_long				 *rdp = (u_long *)&descr;

	DNPRINTF(MPII_D_RW, "%s: mpii_start %#lx\n", DEVNAME(sc),
	    ccb->ccb_cmd_dva);

	bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_requests),
	    ccb->ccb_offset, sc->sc_request_size,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	ccb->ccb_state = MPII_CCB_QUEUED;

	rhp = ccb->ccb_cmd;

	memset(&descr, 0, sizeof(descr));

	switch (rhp->function) {
	case MPII_FUNCTION_SCSI_IO_REQUEST:
		descr.request_flags = MPII_REQ_DESCR_SCSI_IO;
		descr.dev_handle = htole16(ccb->ccb_dev_handle);
		break;
	case MPII_FUNCTION_SCSI_TASK_MGMT:
		descr.request_flags = MPII_REQ_DESCR_HIGH_PRIORITY;
		break;
	default:
		descr.request_flags = MPII_REQ_DESCR_DEFAULT;
	}

	descr.vf_id = sc->sc_vf_id;
	descr.smid = ccb->ccb_smid;

	DNPRINTF(MPII_D_RW, "%s:   MPII_REQ_DESCR_POST_LOW (0x%08x) write "
	    "0x%08lx\n", DEVNAME(sc), MPII_REQ_DESCR_POST_LOW, *rdp);

	DNPRINTF(MPII_D_RW, "%s:   MPII_REQ_DESCR_POST_HIGH (0x%08x) write "
	    "0x%08lx\n", DEVNAME(sc), MPII_REQ_DESCR_POST_HIGH, *(rdp+1));

#if defined(__LP64__)
	bus_space_write_raw_8(sc->sc_iot, sc->sc_ioh,
	    MPII_REQ_DESCR_POST_LOW, *rdp);
#else
	mtx_enter(&sc->sc_req_mtx);
	bus_space_write_raw_4(sc->sc_iot, sc->sc_ioh,
	    MPII_REQ_DESCR_POST_LOW, rdp[0]);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh,
	    MPII_REQ_DESCR_POST_LOW, 8, BUS_SPACE_BARRIER_WRITE);

	bus_space_write_raw_4(sc->sc_iot, sc->sc_ioh,
	    MPII_REQ_DESCR_POST_HIGH, rdp[1]);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh,
	    MPII_REQ_DESCR_POST_LOW, 8, BUS_SPACE_BARRIER_WRITE);
	mtx_leave(&sc->sc_req_mtx);
#endif
}

int
mpii_poll(struct mpii_softc *sc, struct mpii_ccb *ccb)
{
	void				(*done)(struct mpii_ccb *);
	void				*cookie;
	int				rv = 1;

	DNPRINTF(MPII_D_INTR, "%s: mpii_poll\n", DEVNAME(sc));

	done = ccb->ccb_done;
	cookie = ccb->ccb_cookie;

	ccb->ccb_done = mpii_poll_done;
	ccb->ccb_cookie = &rv;

	mpii_start(sc, ccb);

	while (rv == 1) {
		/* avoid excessive polling */
		if (mpii_reply_waiting(sc))
			mpii_intr(sc);
		else
			delay(10);
	}

	ccb->ccb_cookie = cookie;
	done(ccb);

	return (0);
}

void
mpii_poll_done(struct mpii_ccb *ccb)
{
	int				*rv = ccb->ccb_cookie;

	*rv = 0;
}

int
mpii_alloc_queues(struct mpii_softc *sc)
{
	u_int32_t		*rfp;
	int			i;

	DNPRINTF(MPII_D_MISC, "%s: mpii_alloc_queues\n", DEVNAME(sc));

	sc->sc_reply_freeq = mpii_dmamem_alloc(sc,
	    sc->sc_reply_free_qdepth * sizeof(*rfp));
	if (sc->sc_reply_freeq == NULL)
		return (1);
	rfp = MPII_DMA_KVA(sc->sc_reply_freeq);
	for (i = 0; i < sc->sc_num_reply_frames; i++) {
		rfp[i] = (u_int32_t)MPII_DMA_DVA(sc->sc_replies) +
		    sc->sc_reply_size * i;
	}

	sc->sc_reply_postq = mpii_dmamem_alloc(sc,
	    sc->sc_reply_post_qdepth * sizeof(struct mpii_reply_descr));
	if (sc->sc_reply_postq == NULL)
		goto free_reply_freeq;
	sc->sc_reply_postq_kva = MPII_DMA_KVA(sc->sc_reply_postq);
	memset(sc->sc_reply_postq_kva, 0xff, sc->sc_reply_post_qdepth *
	    sizeof(struct mpii_reply_descr));

	return (0);

free_reply_freeq:
	mpii_dmamem_free(sc, sc->sc_reply_freeq);
	return (1);
}

void
mpii_init_queues(struct mpii_softc *sc)
{
	DNPRINTF(MPII_D_MISC, "%s:  mpii_init_queues\n", DEVNAME(sc));

	sc->sc_reply_free_host_index = sc->sc_reply_free_qdepth - 1;
	sc->sc_reply_post_host_index = 0;
	mpii_write_reply_free(sc, sc->sc_reply_free_host_index);
	mpii_write_reply_post(sc, sc->sc_reply_post_host_index);
}

void
mpii_wait(struct mpii_softc *sc, struct mpii_ccb *ccb)
{
	struct mutex		mtx = MUTEX_INITIALIZER(IPL_BIO);
	void			(*done)(struct mpii_ccb *);
	void			*cookie;

	done = ccb->ccb_done;
	cookie = ccb->ccb_cookie;

	ccb->ccb_done = mpii_wait_done;
	ccb->ccb_cookie = &mtx;

	/* XXX this will wait forever for the ccb to complete */

	mpii_start(sc, ccb);

	mtx_enter(&mtx);
	while (ccb->ccb_cookie != NULL)
		msleep(ccb, &mtx, PRIBIO, "mpiiwait", 0);
	mtx_leave(&mtx);

	ccb->ccb_cookie = cookie;
	done(ccb);
}

void
mpii_wait_done(struct mpii_ccb *ccb)
{
	struct mutex		*mtx = ccb->ccb_cookie;

	mtx_enter(mtx);
	ccb->ccb_cookie = NULL;
	mtx_leave(mtx);

	wakeup_one(ccb);
}

void
mpii_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct mpii_softc	*sc = link->adapter_softc;
	struct mpii_ccb		*ccb = xs->io;
	struct mpii_msg_scsi_io	*io;
	struct mpii_device	*dev;
	int			 ret;

	DNPRINTF(MPII_D_CMD, "%s: mpii_scsi_cmd\n", DEVNAME(sc));

	if (xs->cmdlen > MPII_CDB_LEN) {
		DNPRINTF(MPII_D_CMD, "%s: CDB too big %d\n",
		    DEVNAME(sc), xs->cmdlen);
		memset(&xs->sense, 0, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20;
		xs->error = XS_SENSE;
		scsi_done(xs);
		return;
	}

	if ((dev = sc->sc_devs[link->target]) == NULL) {
		/* device no longer exists */
		xs->error = XS_SELTIMEOUT;
		scsi_done(xs);
		return;
	}

	KERNEL_UNLOCK();

	DNPRINTF(MPII_D_CMD, "%s: ccb_smid: %d xs->flags: 0x%x\n",
	    DEVNAME(sc), ccb->ccb_smid, xs->flags);

	ccb->ccb_cookie = xs;
	ccb->ccb_done = mpii_scsi_cmd_done;
	ccb->ccb_dev_handle = dev->dev_handle;

	io = ccb->ccb_cmd;
	memset(io, 0, sizeof(*io));
	io->function = MPII_FUNCTION_SCSI_IO_REQUEST;
	io->sense_buffer_length = sizeof(xs->sense);
	io->sgl_offset0 = sizeof(struct mpii_msg_scsi_io) / 4;
	htolem16(&io->io_flags, xs->cmdlen);
	htolem16(&io->dev_handle, ccb->ccb_dev_handle);
	htobem16(&io->lun[0], link->lun);

	switch (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
	case SCSI_DATA_IN:
		io->direction = MPII_SCSIIO_DIR_READ;
		break;
	case SCSI_DATA_OUT:
		io->direction = MPII_SCSIIO_DIR_WRITE;
		break;
	default:
		io->direction = MPII_SCSIIO_DIR_NONE;
		break;
	}

	io->tagging = MPII_SCSIIO_ATTR_SIMPLE_Q;

	memcpy(io->cdb, xs->cmd, xs->cmdlen);

	htolem32(&io->data_length, xs->datalen);

	/* sense data is at the end of a request */
	htolem32(&io->sense_buffer_low_address, ccb->ccb_cmd_dva +
	    sc->sc_request_size - sizeof(struct scsi_sense_data));

	if (ISSET(sc->sc_flags, MPII_F_SAS3))
		ret = mpii_load_xs_sas3(ccb);
	else
		ret = mpii_load_xs(ccb);

	if (ret != 0) {
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

	timeout_set(&xs->stimeout, mpii_scsi_cmd_tmo, ccb);
	if (xs->flags & SCSI_POLL) {
		if (mpii_poll(sc, ccb) != 0) {
			xs->error = XS_DRIVER_STUFFUP;
			goto done;
		}
	} else {
		timeout_add_msec(&xs->stimeout, xs->timeout);
		mpii_start(sc, ccb);
	}

	KERNEL_LOCK();
	return;

done:
	KERNEL_LOCK();
	scsi_done(xs);
}

void
mpii_scsi_cmd_tmo(void *xccb)
{
	struct mpii_ccb		*ccb = xccb;
	struct mpii_softc	*sc = ccb->ccb_sc;

	printf("%s: mpii_scsi_cmd_tmo\n", DEVNAME(sc));

	mtx_enter(&sc->sc_ccb_mtx);
	if (ccb->ccb_state == MPII_CCB_QUEUED) {
		ccb->ccb_state = MPII_CCB_TIMEOUT;
		SIMPLEQ_INSERT_HEAD(&sc->sc_ccb_tmos, ccb, ccb_link);
	}
	mtx_leave(&sc->sc_ccb_mtx);

	scsi_ioh_add(&sc->sc_ccb_tmo_handler);
}

void
mpii_scsi_cmd_tmo_handler(void *cookie, void *io)
{
	struct mpii_softc			*sc = cookie;
	struct mpii_ccb				*tccb = io;
	struct mpii_ccb				*ccb;
	struct mpii_msg_scsi_task_request	*stq;

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = SIMPLEQ_FIRST(&sc->sc_ccb_tmos);
	if (ccb != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_tmos, ccb_link);
		ccb->ccb_state = MPII_CCB_QUEUED;
	}
	/* should remove any other ccbs for the same dev handle */
	mtx_leave(&sc->sc_ccb_mtx);

	if (ccb == NULL) {
		scsi_io_put(&sc->sc_iopool, tccb);
		return;
	}

	stq = tccb->ccb_cmd;
	stq->function = MPII_FUNCTION_SCSI_TASK_MGMT;
	stq->task_type = MPII_SCSI_TASK_TARGET_RESET;
	htolem16(&stq->dev_handle, ccb->ccb_dev_handle);

	tccb->ccb_done = mpii_scsi_cmd_tmo_done;
	mpii_start(sc, tccb);
}

void
mpii_scsi_cmd_tmo_done(struct mpii_ccb *tccb)
{
	mpii_scsi_cmd_tmo_handler(tccb->ccb_sc, tccb);
}

void
mpii_scsi_cmd_done(struct mpii_ccb *ccb)
{
	struct mpii_ccb		*tccb;
	struct mpii_msg_scsi_io_error	*sie;
	struct mpii_softc	*sc = ccb->ccb_sc;
	struct scsi_xfer	*xs = ccb->ccb_cookie;
	struct scsi_sense_data	*sense;
	bus_dmamap_t		dmap = ccb->ccb_dmamap;

	timeout_del(&xs->stimeout);
	mtx_enter(&sc->sc_ccb_mtx);
	if (ccb->ccb_state == MPII_CCB_TIMEOUT) {
		/* ENOSIMPLEQ_REMOVE :( */
		if (ccb == SIMPLEQ_FIRST(&sc->sc_ccb_tmos))
			SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_tmos, ccb_link);
		else {
			SIMPLEQ_FOREACH(tccb, &sc->sc_ccb_tmos, ccb_link) {
				if (SIMPLEQ_NEXT(tccb, ccb_link) == ccb) {
					SIMPLEQ_REMOVE_AFTER(&sc->sc_ccb_tmos,
					    tccb, ccb_link);
					break;
				}
			}
		}
	}

	ccb->ccb_state = MPII_CCB_READY;
	mtx_leave(&sc->sc_ccb_mtx);

	if (xs->datalen != 0) {
		bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
		    BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, dmap);
	}

	xs->error = XS_NOERROR;
	xs->resid = 0;

	if (ccb->ccb_rcb == NULL) {
		/* no scsi error, we're ok so drop out early */
		xs->status = SCSI_OK;
		goto done;
	}

	sie = ccb->ccb_rcb->rcb_reply;

	DNPRINTF(MPII_D_CMD, "%s: mpii_scsi_cmd_done xs cmd: 0x%02x len: %d "
	    "flags 0x%x\n", DEVNAME(sc), xs->cmd->opcode, xs->datalen,
	    xs->flags);
	DNPRINTF(MPII_D_CMD, "%s:  dev_handle: %d msg_length: %d "
	    "function: 0x%02x\n", DEVNAME(sc), letoh16(sie->dev_handle),
	    sie->msg_length, sie->function);
	DNPRINTF(MPII_D_CMD, "%s:  vp_id: 0x%02x vf_id: 0x%02x\n", DEVNAME(sc),
	    sie->vp_id, sie->vf_id);
	DNPRINTF(MPII_D_CMD, "%s:  scsi_status: 0x%02x scsi_state: 0x%02x "
	    "ioc_status: 0x%04x\n", DEVNAME(sc), sie->scsi_status,
	    sie->scsi_state, letoh16(sie->ioc_status));
	DNPRINTF(MPII_D_CMD, "%s:  ioc_loginfo: 0x%08x\n", DEVNAME(sc),
	    letoh32(sie->ioc_loginfo));
	DNPRINTF(MPII_D_CMD, "%s:  transfer_count: %d\n", DEVNAME(sc),
	    letoh32(sie->transfer_count));
	DNPRINTF(MPII_D_CMD, "%s:  sense_count: %d\n", DEVNAME(sc),
	    letoh32(sie->sense_count));
	DNPRINTF(MPII_D_CMD, "%s:  response_info: 0x%08x\n", DEVNAME(sc),
	    letoh32(sie->response_info));
	DNPRINTF(MPII_D_CMD, "%s:  task_tag: 0x%04x\n", DEVNAME(sc),
	    letoh16(sie->task_tag));
	DNPRINTF(MPII_D_CMD, "%s:  bidirectional_transfer_count: 0x%08x\n",
	    DEVNAME(sc), letoh32(sie->bidirectional_transfer_count));

	if (sie->scsi_state & MPII_SCSIIO_STATE_NO_SCSI_STATUS)
		xs->status = SCSI_TERMINATED;
	else
		xs->status = sie->scsi_status;
	xs->resid = 0;

	switch (lemtoh16(&sie->ioc_status) & MPII_IOCSTATUS_MASK) {
	case MPII_IOCSTATUS_SCSI_DATA_UNDERRUN:
		xs->resid = xs->datalen - lemtoh32(&sie->transfer_count);
		/* FALLTHROUGH */

	case MPII_IOCSTATUS_SUCCESS:
	case MPII_IOCSTATUS_SCSI_RECOVERED_ERROR:
		switch (xs->status) {
		case SCSI_OK:
			xs->error = XS_NOERROR;
			break;

		case SCSI_CHECK:
			xs->error = XS_SENSE;
			break;

		case SCSI_BUSY:
		case SCSI_QUEUE_FULL:
			xs->error = XS_BUSY;
			break;

		default:
			xs->error = XS_DRIVER_STUFFUP;
		}
		break;

	case MPII_IOCSTATUS_BUSY:
	case MPII_IOCSTATUS_INSUFFICIENT_RESOURCES:
		xs->error = XS_BUSY;
		break;

	case MPII_IOCSTATUS_SCSI_IOC_TERMINATED:
	case MPII_IOCSTATUS_SCSI_TASK_TERMINATED:
		xs->error = XS_RESET;
		break;

	case MPII_IOCSTATUS_SCSI_INVALID_DEVHANDLE:
	case MPII_IOCSTATUS_SCSI_DEVICE_NOT_THERE:
		xs->error = XS_SELTIMEOUT;
		break;

	default:
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

	sense = (struct scsi_sense_data *)((caddr_t)ccb->ccb_cmd +
	    sc->sc_request_size - sizeof(*sense));
	if (sie->scsi_state & MPII_SCSIIO_STATE_AUTOSENSE_VALID)
		memcpy(&xs->sense, sense, sizeof(xs->sense));

	DNPRINTF(MPII_D_CMD, "%s:  xs err: %d status: %#x\n", DEVNAME(sc),
	    xs->error, xs->status);

	mpii_push_reply(sc, ccb->ccb_rcb);
done:
	KERNEL_LOCK();
	scsi_done(xs);
	KERNEL_UNLOCK();
}

int
mpii_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag)
{
	struct mpii_softc	*sc = (struct mpii_softc *)link->adapter_softc;
	struct mpii_device	*dev = sc->sc_devs[link->target];

	DNPRINTF(MPII_D_IOCTL, "%s: mpii_scsi_ioctl\n", DEVNAME(sc));

	switch (cmd) {
	case DIOCGCACHE:
	case DIOCSCACHE:
		if (dev != NULL && ISSET(dev->flags, MPII_DF_VOLUME)) {
			return (mpii_ioctl_cache(link, cmd,
			    (struct dk_cache *)addr));
		}
		break;

	default:
		if (sc->sc_ioctl)
			return (sc->sc_ioctl(link->adapter_softc, cmd, addr));

		break;
	}

	return (ENOTTY);
}

int
mpii_ioctl_cache(struct scsi_link *link, u_long cmd, struct dk_cache *dc)
{
	struct mpii_softc *sc = (struct mpii_softc *)link->adapter_softc;
	struct mpii_device *dev = sc->sc_devs[link->target];
	struct mpii_cfg_raid_vol_pg0 *vpg;
	struct mpii_msg_raid_action_request *req;
	struct mpii_msg_raid_action_reply *rep;
	struct mpii_cfg_hdr hdr;
	struct mpii_ccb	*ccb;
	u_int32_t addr = MPII_CFG_RAID_VOL_ADDR_HANDLE | dev->dev_handle;
	size_t pagelen;
	int rv = 0;
	int enabled;

	if (mpii_req_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_RAID_VOL, 0,
	    addr, MPII_PG_POLL, &hdr) != 0)
		return (EINVAL);

	pagelen = hdr.page_length * 4;
	vpg = malloc(pagelen, M_TEMP, M_WAITOK | M_CANFAIL | M_ZERO);
	if (vpg == NULL)
		return (ENOMEM);

	if (mpii_req_cfg_page(sc, addr, MPII_PG_POLL, &hdr, 1,
	    vpg, pagelen) != 0) {
		rv = EINVAL;
		goto done;
	}

	enabled = ((lemtoh16(&vpg->volume_settings) &
	    MPII_CFG_RAID_VOL_0_SETTINGS_CACHE_MASK) ==
	    MPII_CFG_RAID_VOL_0_SETTINGS_CACHE_ENABLED) ? 1 : 0;

	if (cmd == DIOCGCACHE) {
		dc->wrcache = enabled;
		dc->rdcache = 0;
		goto done;
	} /* else DIOCSCACHE */

	if (dc->rdcache) {
		rv = EOPNOTSUPP;
		goto done;
	}

	if (((dc->wrcache) ? 1 : 0) == enabled)
		goto done;

	ccb = scsi_io_get(&sc->sc_iopool, SCSI_POLL);
	if (ccb == NULL) {
		rv = ENOMEM;
		goto done;
	}

	ccb->ccb_done = mpii_empty_done;

	req = ccb->ccb_cmd;
	memset(req, 0, sizeof(*req));
	req->function = MPII_FUNCTION_RAID_ACTION;
	req->action = MPII_RAID_ACTION_CHANGE_VOL_WRITE_CACHE;
	htolem16(&req->vol_dev_handle, dev->dev_handle);
	htolem32(&req->action_data, dc->wrcache ?
	    MPII_RAID_VOL_WRITE_CACHE_ENABLE :
	    MPII_RAID_VOL_WRITE_CACHE_DISABLE);

	if (mpii_poll(sc, ccb) != 0) {
		rv = EIO;
		goto done;
	}

	if (ccb->ccb_rcb != NULL) {
		rep = ccb->ccb_rcb->rcb_reply;
		if ((rep->ioc_status != MPII_IOCSTATUS_SUCCESS) ||
		    ((rep->action_data[0] &
		     MPII_RAID_VOL_WRITE_CACHE_MASK) !=
		    (dc->wrcache ? MPII_RAID_VOL_WRITE_CACHE_ENABLE :
		     MPII_RAID_VOL_WRITE_CACHE_DISABLE)))
			rv = EINVAL;
		mpii_push_reply(sc, ccb->ccb_rcb);
	}

	scsi_io_put(&sc->sc_iopool, ccb);

done:
	free(vpg, M_TEMP, 0);
	return (rv);
}

#if NBIO > 0
int
mpii_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct mpii_softc	*sc = (struct mpii_softc *)dev;
	int			error = 0;

	DNPRINTF(MPII_D_IOCTL, "%s: mpii_ioctl ", DEVNAME(sc));

	switch (cmd) {
	case BIOCINQ:
		DNPRINTF(MPII_D_IOCTL, "inq\n");
		error = mpii_ioctl_inq(sc, (struct bioc_inq *)addr);
		break;
	case BIOCVOL:
		DNPRINTF(MPII_D_IOCTL, "vol\n");
		error = mpii_ioctl_vol(sc, (struct bioc_vol *)addr);
		break;
	case BIOCDISK:
		DNPRINTF(MPII_D_IOCTL, "disk\n");
		error = mpii_ioctl_disk(sc, (struct bioc_disk *)addr);
		break;
	default:
		DNPRINTF(MPII_D_IOCTL, " invalid ioctl\n");
		error = EINVAL;
	}

	return (error);
}

int
mpii_ioctl_inq(struct mpii_softc *sc, struct bioc_inq *bi)
{
	int			i;

	DNPRINTF(MPII_D_IOCTL, "%s: mpii_ioctl_inq\n", DEVNAME(sc));

	strlcpy(bi->bi_dev, DEVNAME(sc), sizeof(bi->bi_dev));
	for (i = 0; i < sc->sc_max_devices; i++)
		if (sc->sc_devs[i] &&
		    ISSET(sc->sc_devs[i]->flags, MPII_DF_VOLUME))
			bi->bi_novol++;
	return (0);
}

int
mpii_ioctl_vol(struct mpii_softc *sc, struct bioc_vol *bv)
{
	struct mpii_cfg_raid_vol_pg0	*vpg;
	struct mpii_cfg_hdr		hdr;
	struct mpii_device		*dev;
	struct scsi_link		*lnk;
	struct device			*scdev;
	size_t				pagelen;
	u_int16_t			volh;
	int				rv, hcnt = 0;

	DNPRINTF(MPII_D_IOCTL, "%s: mpii_ioctl_vol %d\n",
	    DEVNAME(sc), bv->bv_volid);

	if ((dev = mpii_find_vol(sc, bv->bv_volid)) == NULL)
		return (ENODEV);
	volh = dev->dev_handle;

	if (mpii_req_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_RAID_VOL, 0,
	    MPII_CFG_RAID_VOL_ADDR_HANDLE | volh, 0, &hdr) != 0) {
		printf("%s: unable to fetch header for raid volume page 0\n",
		    DEVNAME(sc));
		return (EINVAL);
	}

	pagelen = hdr.page_length * 4;
	vpg = malloc(pagelen, M_TEMP, M_WAITOK | M_CANFAIL | M_ZERO);
	if (vpg == NULL) {
		printf("%s: unable to allocate space for raid "
		    "volume page 0\n", DEVNAME(sc));
		return (ENOMEM);
	}

	if (mpii_req_cfg_page(sc, MPII_CFG_RAID_VOL_ADDR_HANDLE | volh, 0,
	    &hdr, 1, vpg, pagelen) != 0) {
		printf("%s: unable to fetch raid volume page 0\n",
		    DEVNAME(sc));
		free(vpg, M_TEMP, 0);
		return (EINVAL);
	}

	switch (vpg->volume_state) {
	case MPII_CFG_RAID_VOL_0_STATE_ONLINE:
	case MPII_CFG_RAID_VOL_0_STATE_OPTIMAL:
		bv->bv_status = BIOC_SVONLINE;
		break;
	case MPII_CFG_RAID_VOL_0_STATE_DEGRADED:
		if (ISSET(lemtoh32(&vpg->volume_status),
		    MPII_CFG_RAID_VOL_0_STATUS_RESYNC)) {
			bv->bv_status = BIOC_SVREBUILD;
			bv->bv_percent = dev->percent;
		} else
			bv->bv_status = BIOC_SVDEGRADED;
		break;
	case MPII_CFG_RAID_VOL_0_STATE_FAILED:
		bv->bv_status = BIOC_SVOFFLINE;
		break;
	case MPII_CFG_RAID_VOL_0_STATE_INITIALIZING:
		bv->bv_status = BIOC_SVBUILDING;
		break;
	case MPII_CFG_RAID_VOL_0_STATE_MISSING:
	default:
		bv->bv_status = BIOC_SVINVALID;
		break;
	}

	switch (vpg->volume_type) {
	case MPII_CFG_RAID_VOL_0_TYPE_RAID0:
		bv->bv_level = 0;
		break;
	case MPII_CFG_RAID_VOL_0_TYPE_RAID1:
		bv->bv_level = 1;
		break;
	case MPII_CFG_RAID_VOL_0_TYPE_RAID1E:
	case MPII_CFG_RAID_VOL_0_TYPE_RAID10:
		bv->bv_level = 10;
		break;
	default:
		bv->bv_level = -1;
	}

	if ((rv = mpii_bio_hs(sc, NULL, 0, vpg->hot_spare_pool, &hcnt)) != 0) {
		free(vpg, M_TEMP, 0);
		return (rv);
	}

	bv->bv_nodisk = vpg->num_phys_disks + hcnt;

	bv->bv_size = letoh64(vpg->max_lba) * lemtoh16(&vpg->block_size);

	lnk = scsi_get_link(sc->sc_scsibus, dev->slot, 0);
	if (lnk != NULL) {
		scdev = lnk->device_softc;
		strlcpy(bv->bv_dev, scdev->dv_xname, sizeof(bv->bv_dev));
	}

	free(vpg, M_TEMP, 0);
	return (0);
}

int
mpii_ioctl_disk(struct mpii_softc *sc, struct bioc_disk *bd)
{
	struct mpii_cfg_raid_vol_pg0		*vpg;
	struct mpii_cfg_raid_vol_pg0_physdisk	*pd;
	struct mpii_cfg_hdr			hdr;
	struct mpii_device			*dev;
	size_t					pagelen;
	u_int16_t				volh;
	u_int8_t				dn;

	DNPRINTF(MPII_D_IOCTL, "%s: mpii_ioctl_disk %d/%d\n",
	    DEVNAME(sc), bd->bd_volid, bd->bd_diskid);

	if ((dev = mpii_find_vol(sc, bd->bd_volid)) == NULL)
		return (ENODEV);
	volh = dev->dev_handle;

	if (mpii_req_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_RAID_VOL, 0,
	    MPII_CFG_RAID_VOL_ADDR_HANDLE | volh, 0, &hdr) != 0) {
		printf("%s: unable to fetch header for raid volume page 0\n",
		    DEVNAME(sc));
		return (EINVAL);
	}

	pagelen = hdr.page_length * 4;
	vpg = malloc(pagelen, M_TEMP, M_WAITOK | M_CANFAIL | M_ZERO);
	if (vpg == NULL) {
		printf("%s: unable to allocate space for raid "
		    "volume page 0\n", DEVNAME(sc));
		return (ENOMEM);
	}

	if (mpii_req_cfg_page(sc, MPII_CFG_RAID_VOL_ADDR_HANDLE | volh, 0,
	    &hdr, 1, vpg, pagelen) != 0) {
		printf("%s: unable to fetch raid volume page 0\n",
		    DEVNAME(sc));
		free(vpg, M_TEMP, 0);
		return (EINVAL);
	}

	if (bd->bd_diskid >= vpg->num_phys_disks) {
		int		nvdsk = vpg->num_phys_disks;
		int		hsmap = vpg->hot_spare_pool;

		free(vpg, M_TEMP, 0);
		return (mpii_bio_hs(sc, bd, nvdsk, hsmap, NULL));
	}

	pd = (struct mpii_cfg_raid_vol_pg0_physdisk *)(vpg + 1) +
	    bd->bd_diskid;
	dn = pd->phys_disk_num;

	free(vpg, M_TEMP, 0);
	return (mpii_bio_disk(sc, bd, dn));
}

int
mpii_bio_hs(struct mpii_softc *sc, struct bioc_disk *bd, int nvdsk,
     int hsmap, int *hscnt)
{
	struct mpii_cfg_raid_config_pg0	*cpg;
	struct mpii_raid_config_element	*el;
	struct mpii_ecfg_hdr		ehdr;
	size_t				pagelen;
	int				i, nhs = 0;

	if (bd)
		DNPRINTF(MPII_D_IOCTL, "%s: mpii_bio_hs %d\n", DEVNAME(sc),
		    bd->bd_diskid - nvdsk);
	else
		DNPRINTF(MPII_D_IOCTL, "%s: mpii_bio_hs\n", DEVNAME(sc));

	if (mpii_req_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_RAID_CONFIG,
	    0, MPII_CFG_RAID_CONFIG_ACTIVE_CONFIG, MPII_PG_EXTENDED,
	    &ehdr) != 0) {
		printf("%s: unable to fetch header for raid config page 0\n",
		    DEVNAME(sc));
		return (EINVAL);
	}

	pagelen = lemtoh16(&ehdr.ext_page_length) * 4;
	cpg = malloc(pagelen, M_TEMP, M_WAITOK | M_CANFAIL | M_ZERO);
	if (cpg == NULL) {
		printf("%s: unable to allocate space for raid config page 0\n",
		    DEVNAME(sc));
		return (ENOMEM);
	}

	if (mpii_req_cfg_page(sc, MPII_CFG_RAID_CONFIG_ACTIVE_CONFIG,
	    MPII_PG_EXTENDED, &ehdr, 1, cpg, pagelen) != 0) {
		printf("%s: unable to fetch raid config page 0\n",
		    DEVNAME(sc));
		free(cpg, M_TEMP, 0);
		return (EINVAL);
	}

	el = (struct mpii_raid_config_element *)(cpg + 1);
	for (i = 0; i < cpg->num_elements; i++, el++) {
		if (ISSET(lemtoh16(&el->element_flags),
		    MPII_RAID_CONFIG_ELEMENT_FLAG_HSP_PHYS_DISK) &&
		    el->hot_spare_pool == hsmap) {
			/*
			 * diskid comparison is based on the idea that all
			 * disks are counted by the bio(4) in sequence, thus
			 * substracting the number of disks in the volume
			 * from the diskid yields us a "relative" hotspare
			 * number, which is good enough for us.
			 */
			if (bd != NULL && bd->bd_diskid == nhs + nvdsk) {
				u_int8_t dn = el->phys_disk_num;

				free(cpg, M_TEMP, 0);
				return (mpii_bio_disk(sc, bd, dn));
			}
			nhs++;
		}
	}

	if (hscnt)
		*hscnt = nhs;

	free(cpg, M_TEMP, 0);
	return (0);
}

int
mpii_bio_disk(struct mpii_softc *sc, struct bioc_disk *bd, u_int8_t dn)
{
	struct mpii_cfg_raid_physdisk_pg0	*ppg;
	struct mpii_cfg_hdr			hdr;
	struct mpii_device			*dev;
	int					len;

	DNPRINTF(MPII_D_IOCTL, "%s: mpii_bio_disk %d\n", DEVNAME(sc),
	    bd->bd_diskid);

	ppg = malloc(sizeof(*ppg), M_TEMP, M_WAITOK | M_CANFAIL | M_ZERO);
	if (ppg == NULL) {
		printf("%s: unable to allocate space for raid physical disk "
		    "page 0\n", DEVNAME(sc));
		return (ENOMEM);
	}

	hdr.page_version = 0;
	hdr.page_length = sizeof(*ppg) / 4;
	hdr.page_number = 0;
	hdr.page_type = MPII_CONFIG_REQ_PAGE_TYPE_RAID_PD;

	if (mpii_req_cfg_page(sc, MPII_CFG_RAID_PHYS_DISK_ADDR_NUMBER | dn, 0,
	    &hdr, 1, ppg, sizeof(*ppg)) != 0) {
		printf("%s: unable to fetch raid drive page 0\n",
		    DEVNAME(sc));
		free(ppg, M_TEMP, 0);
		return (EINVAL);
	}

	bd->bd_target = ppg->phys_disk_num;

	if ((dev = mpii_find_dev(sc, lemtoh16(&ppg->dev_handle))) == NULL) {
		bd->bd_status = BIOC_SDINVALID;
		free(ppg, M_TEMP, 0);
		return (0);
	}

	switch (ppg->phys_disk_state) {
	case MPII_CFG_RAID_PHYDISK_0_STATE_ONLINE:
	case MPII_CFG_RAID_PHYDISK_0_STATE_OPTIMAL:
		bd->bd_status = BIOC_SDONLINE;
		break;
	case MPII_CFG_RAID_PHYDISK_0_STATE_OFFLINE:
		if (ppg->offline_reason ==
		    MPII_CFG_RAID_PHYDISK_0_OFFLINE_FAILED ||
		    ppg->offline_reason ==
		    MPII_CFG_RAID_PHYDISK_0_OFFLINE_FAILEDREQ)
			bd->bd_status = BIOC_SDFAILED;
		else
			bd->bd_status = BIOC_SDOFFLINE;
		break;
	case MPII_CFG_RAID_PHYDISK_0_STATE_DEGRADED:
		bd->bd_status = BIOC_SDFAILED;
		break;
	case MPII_CFG_RAID_PHYDISK_0_STATE_REBUILDING:
		bd->bd_status = BIOC_SDREBUILD;
		break;
	case MPII_CFG_RAID_PHYDISK_0_STATE_HOTSPARE:
		bd->bd_status = BIOC_SDHOTSPARE;
		break;
	case MPII_CFG_RAID_PHYDISK_0_STATE_NOTCONFIGURED:
		bd->bd_status = BIOC_SDUNUSED;
		break;
	case MPII_CFG_RAID_PHYDISK_0_STATE_NOTCOMPATIBLE:
	default:
		bd->bd_status = BIOC_SDINVALID;
		break;
	}

	bd->bd_size = letoh64(ppg->dev_max_lba) * lemtoh16(&ppg->block_size);

	scsi_strvis(bd->bd_vendor, ppg->vendor_id, sizeof(ppg->vendor_id));
	len = strlen(bd->bd_vendor);
	bd->bd_vendor[len] = ' ';
	scsi_strvis(&bd->bd_vendor[len + 1], ppg->product_id,
	    sizeof(ppg->product_id));
	scsi_strvis(bd->bd_serial, ppg->serial, sizeof(ppg->serial));

	free(ppg, M_TEMP, 0);
	return (0);
}

struct mpii_device *
mpii_find_vol(struct mpii_softc *sc, int volid)
{
	struct mpii_device	*dev = NULL;

	if (sc->sc_vd_id_low + volid >= sc->sc_max_devices)
		return (NULL);
	dev = sc->sc_devs[sc->sc_vd_id_low + volid];
	if (dev && ISSET(dev->flags, MPII_DF_VOLUME))
		return (dev);
	return (NULL);
}

#ifndef SMALL_KERNEL
/*
 * Non-sleeping lightweight version of the mpii_ioctl_vol
 */
int
mpii_bio_volstate(struct mpii_softc *sc, struct bioc_vol *bv)
{
	struct mpii_cfg_raid_vol_pg0	*vpg;
	struct mpii_cfg_hdr		hdr;
	struct mpii_device		*dev = NULL;
	size_t				pagelen;
	u_int16_t			volh;

	if ((dev = mpii_find_vol(sc, bv->bv_volid)) == NULL)
		return (ENODEV);
	volh = dev->dev_handle;

	if (mpii_req_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_RAID_VOL, 0,
	    MPII_CFG_RAID_VOL_ADDR_HANDLE | volh, MPII_PG_POLL, &hdr) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: unable to fetch header for raid "
		    "volume page 0\n", DEVNAME(sc));
		return (EINVAL);
	}

	pagelen = hdr.page_length * 4;
	vpg = malloc(pagelen, M_TEMP, M_NOWAIT | M_ZERO);
	if (vpg == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: unable to allocate space for raid "
		    "volume page 0\n", DEVNAME(sc));
		return (ENOMEM);
	}

	if (mpii_req_cfg_page(sc, MPII_CFG_RAID_VOL_ADDR_HANDLE | volh,
	    MPII_PG_POLL, &hdr, 1, vpg, pagelen) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: unable to fetch raid volume "
		    "page 0\n", DEVNAME(sc));
		free(vpg, M_TEMP, 0);
		return (EINVAL);
	}

	switch (vpg->volume_state) {
	case MPII_CFG_RAID_VOL_0_STATE_ONLINE:
	case MPII_CFG_RAID_VOL_0_STATE_OPTIMAL:
		bv->bv_status = BIOC_SVONLINE;
		break;
	case MPII_CFG_RAID_VOL_0_STATE_DEGRADED:
		if (ISSET(lemtoh32(&vpg->volume_status),
		    MPII_CFG_RAID_VOL_0_STATUS_RESYNC))
			bv->bv_status = BIOC_SVREBUILD;
		else
			bv->bv_status = BIOC_SVDEGRADED;
		break;
	case MPII_CFG_RAID_VOL_0_STATE_FAILED:
		bv->bv_status = BIOC_SVOFFLINE;
		break;
	case MPII_CFG_RAID_VOL_0_STATE_INITIALIZING:
		bv->bv_status = BIOC_SVBUILDING;
		break;
	case MPII_CFG_RAID_VOL_0_STATE_MISSING:
	default:
		bv->bv_status = BIOC_SVINVALID;
		break;
	}

	free(vpg, M_TEMP, 0);
	return (0);
}

int
mpii_create_sensors(struct mpii_softc *sc)
{
	struct scsibus_softc	*ssc = sc->sc_scsibus;
	struct device		*dev;
	struct scsi_link	*link;
	int			i;

	sc->sc_sensors = mallocarray(sc->sc_vd_count, sizeof(struct ksensor),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_sensors == NULL)
		return (1);
	sc->sc_nsensors = sc->sc_vd_count;

	strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensordev.xname));

	for (i = 0; i < sc->sc_vd_count; i++) {
		link = scsi_get_link(ssc, i + sc->sc_vd_id_low, 0);
		if (link == NULL)
			goto bad;

		dev = link->device_softc;

		sc->sc_sensors[i].type = SENSOR_DRIVE;
		sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;

		strlcpy(sc->sc_sensors[i].desc, dev->dv_xname,
		    sizeof(sc->sc_sensors[i].desc));

		sensor_attach(&sc->sc_sensordev, &sc->sc_sensors[i]);
	}

	if (sensor_task_register(sc, mpii_refresh_sensors, 10) == NULL)
		goto bad;

	sensordev_install(&sc->sc_sensordev);

	return (0);

bad:
	free(sc->sc_sensors, M_DEVBUF, 0);

	return (1);
}

void
mpii_refresh_sensors(void *arg)
{
	struct mpii_softc	*sc = arg;
	struct bioc_vol		bv;
	int			i;

	for (i = 0; i < sc->sc_nsensors; i++) {
		memset(&bv, 0, sizeof(bv));
		bv.bv_volid = i;
		if (mpii_bio_volstate(sc, &bv))
			return;
		switch(bv.bv_status) {
		case BIOC_SVOFFLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_FAIL;
			sc->sc_sensors[i].status = SENSOR_S_CRIT;
			break;
		case BIOC_SVDEGRADED:
			sc->sc_sensors[i].value = SENSOR_DRIVE_PFAIL;
			sc->sc_sensors[i].status = SENSOR_S_WARN;
			break;
		case BIOC_SVREBUILD:
			sc->sc_sensors[i].value = SENSOR_DRIVE_REBUILD;
			sc->sc_sensors[i].status = SENSOR_S_WARN;
			break;
		case BIOC_SVONLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_ONLINE;
			sc->sc_sensors[i].status = SENSOR_S_OK;
			break;
		case BIOC_SVINVALID:
			/* FALLTHROUGH */
		default:
			sc->sc_sensors[i].value = 0; /* unknown */
			sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;
		}
	}
}
#endif /* SMALL_KERNEL */
#endif /* NBIO > 0 */
@


1.109
log
@Clean up SCSI operation status and state defines
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.108 2016/11/06 09:58:16 dlg Exp $	*/
d931 1
a931 1
	DNPRINTF(MPII_D_RW, "%s: mpii_read %#x %#x\n", DEVNAME(sc), r, rv);
d939 1
a939 1
	DNPRINTF(MPII_D_RW, "%s: mpii_write %#x %#x\n", DEVNAME(sc), r, v);
d953 1
a953 1
	DNPRINTF(MPII_D_RW, "%s: mpii_wait_eq %#x %#x %#x\n", DEVNAME(sc), r,
d971 1
a971 1
	DNPRINTF(MPII_D_RW, "%s: mpii_wait_ne %#x %#x %#x\n", DEVNAME(sc), r,
d1190 1
a1190 1
	DNPRINTF(MPII_D_CMD, "%s: mpii_handshake_recv dwords: %d reply: %d\n",
d2430 1
a2430 1
	DNPRINTF(MPII_D_MEM, "%s: mpii_dmamem_free %#x\n", DEVNAME(sc), mdm);
d2549 2
a2550 2
		DNPRINTF(MPII_D_CCB, "%s: mpii_alloc_ccbs(%d) ccb: %#x map: %#x "
		    "sc: %#x smid: %#x offs: %#x cmd: %#x dva: %#x\n",
d2579 1
a2579 1
	DNPRINTF(MPII_D_CCB, "%s: mpii_put_ccb %#x\n", DEVNAME(sc), ccb);
d2612 1
a2612 1
	DNPRINTF(MPII_D_CCB, "%s: mpii_get_ccb %#x\n", DEVNAME(sc), ccb);
d2665 1
a2665 1
	DNPRINTF(MPII_D_RW, "%s: mpii_start %#x\n", DEVNAME(sc),
d2694 1
a2694 1
	    "0x%08x\n", DEVNAME(sc), MPII_REQ_DESCR_POST_LOW, *rdp);
d2697 1
a2697 1
	    "0x%08x\n", DEVNAME(sc), MPII_REQ_DESCR_POST_HIGH, *(rdp+1));
@


1.108
log
@dont issue sas config page requests against raid targets.

doing requests like that causes lockups on boot.

reported by and this fix test by simon mages
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.107 2016/10/24 01:50:09 dlg Exp $	*/
d3066 1
a3066 1
	if (sie->scsi_state & MPII_SCSIIO_ERR_STATE_NO_SCSI_STATUS)
d3120 1
a3120 1
	if (sie->scsi_state & MPII_SCSIIO_ERR_STATE_AUTOSENSE_VALID)
@


1.107
log
@augment the scsi_probe handler so it tries to query the sas dev pg 0

sas dev pg0 tells us interesting things, like the devices sas addresses
and if it is ATAPI or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.106 2016/10/21 05:38:53 dlg Exp $	*/
d890 3
@


1.106
log
@mitigate against mpii device attachment racing with mountroot

mpii devices get attached by processing sas discovery events after
threads are running, but if you have a lean (in terms of devices)
and fast machine, these events might run after mountroot.

this change has mpii use config_pending_incr() before it attaches
scsibus, and runs config_pending_decr() after the first scan of the
bus is complete.

to make sure config_pending_decr() is run after the scsi attach/detach
events are processed, the MPII_EVENT_SAS_DISCOVERY events are
deferred to the same context that the MPII_EVENT_SAS_TOPOLOGY_CHANGE_LIST
events run in.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.105 2016/09/14 01:14:54 jmatthew Exp $	*/
d872 6
a877 2
	struct mpii_softc	*sc = link->adapter_softc;
	int			flags;
d883 2
a884 1
	if (sc->sc_devs[link->target] == NULL)
d887 1
a887 1
	flags = sc->sc_devs[link->target]->flags;
d890 25
@


1.105
log
@add support for SAS3 devices, which have a different sgl layout to previous
generations.

tested on a Lenovo N2215 (SAS3008)
ok dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.104 2016/08/17 01:02:31 krw Exp $	*/
d167 1
d348 2
d596 4
d1805 13
d1869 1
d1874 19
d1906 1
a1906 11
	case MPII_EVENT_SAS_DISCOVERY: {
		struct mpii_evt_sas_discovery	*esd =
		    (struct mpii_evt_sas_discovery *)(enp + 1);

		if (esd->reason_code ==
		    MPII_EVENT_SAS_DISC_REASON_CODE_COMPLETED &&
		    esd->discovery_status != 0)
			printf("%s: sas discovery completed with status %#x\n",
			    DEVNAME(sc), esd->discovery_status);
		}
		break;
@


1.104
log
@Make error handling (esp. DATA_UNDERRUN) clearer and avoid losing resid
value.

Specs from mikeb@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.103 2016/08/09 15:04:34 krw Exp $	*/
d166 1
d310 1
d425 7
a431 1
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2308_3 }
d740 57
d1194 1
d1229 4
d1300 6
d1308 1
a1308 1
	    sizeof(struct mpii_sge) - 1;
d1316 1
a1316 1
	    sizeof(struct mpii_sge) - 1;
d2783 1
d2788 1
a2788 1
		DNPRINTF(MPII_D_CMD, "%s: CBD too big %d\n",
d2846 6
a2851 1
	if (mpii_load_xs(ccb) != 0) {
@


1.103
log
@Check xs->status for SCSI_CHECK even in underrun situations.

Lets Bacula find the end of medium on LTO5 drive.

Reported & fix tested by Kor son of Rynar.

ok mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.102 2016/03/07 18:43:59 naddy Exp $	*/
d2921 6
a2926 1
	xs->status = sie->scsi_status;
d2929 2
a2930 15
		switch (xs->status) {
		case SCSI_OK:
			xs->resid = xs->datalen -
			    lemtoh32(&sie->transfer_count);
			break;

		case SCSI_CHECK:
			xs->error = XS_SENSE;
			break;

		default:
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		break;
d2936 1
a2936 1
			xs->resid = 0;
@


1.102
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.101 2015/03/18 12:23:25 mikeb Exp $	*/
d2929 5
@


1.101
log
@Prevent sign extension due to pointer arithmetics

This should make mpii(4) work on i386 again, apparently.
Problem identified and a slightly different fix proposed
by Christiano F. Haesbaert and Pedro Martelletto of Bitrig.
Huge thanks for tracking this down, guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.100 2015/03/14 03:38:48 jsg Exp $	*/
d2986 1
a2986 1
KERNEL_LOCK();
d2988 1
a2988 1
KERNEL_UNLOCK();
@


1.100
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.99 2015/03/02 11:55:52 sthen Exp $	*/
d778 1
a778 1
			    (caddr_t)nsge - (caddr_t)io);
@


1.99
log
@Remove the mpsafe flag for mpii(4), it is a suspect in some kernel hangs I've
seen on MP kernels when doing bulk io transfers from a multithreaded program
(bacula-fd).  ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.98 2015/01/27 03:17:36 dlg Exp $	*/
a24 1
#include <sys/buf.h>
@


1.98
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.97 2014/09/16 05:12:04 dlg Exp $	*/
d581 1
a581 1
	sc->sc_ih = pci_intr_establish(sc->sc_pc, ih, IPL_BIO | IPL_MPSAFE,
@


1.97
log
@mark the mpii interrupt handler as mpsafe, and drop the kernel lock
in the scsi_cmd path and iopool backend.

modelled on mfi and mpi.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.96 2014/07/13 23:10:23 deraadt Exp $	*/
d343 1
a343 1
void		mpii_event_sas(void *, void *);
d1553 1
a1553 1
	task_set(&sc->sc_evt_sas_task, mpii_event_sas, sc, NULL);
d1698 1
a1698 1
mpii_event_sas(void *xsc, void *x)
@


1.96
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.95 2014/07/12 18:48:52 tedu Exp $	*/
d581 1
a581 1
	sc->sc_ih = pci_intr_establish(sc->sc_pc, ih, IPL_BIO,
d1829 1
d1831 1
d1858 1
d1860 1
d2449 1
d2453 1
d2462 2
d2472 2
d2730 2
d2772 1
a2772 2
		scsi_done(xs);
		return;
d2779 1
a2779 1
			scsi_done(xs);
d2781 3
a2783 1
		return;
d2786 6
a2791 2
	timeout_add_msec(&xs->stimeout, xs->timeout);
	mpii_start(sc, ccb);
d2893 1
a2893 2
		scsi_done(xs);
		return;
d2986 2
d2989 1
@


1.95
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.94 2014/05/04 17:34:17 sf Exp $	*/
d556 1
a556 1
	sc->sc_devs = malloc(sc->sc_max_devices *
d2369 1
a2369 1
	sc->sc_ccbs = malloc(sizeof(*ccb) * (sc->sc_max_cmds-1),
d2474 2
a2475 2
	sc->sc_rcbs = malloc(sc->sc_num_reply_frames * sizeof(struct mpii_rcb),
	    M_DEVBUF, M_NOWAIT);
d3533 1
a3533 1
	sc->sc_sensors = malloc(sizeof(struct ksensor) * sc->sc_vd_count,
@


1.94
log
@change type of handle var to u_int16_t

This fixes a format string warning. No change to the format string is
necessary.

suggested by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.93 2014/04/25 09:43:04 jsg Exp $	*/
d612 1
a612 1
	free(sc->sc_devs, M_DEVBUF);
d633 1
a633 1
	free(sc->sc_ccbs, M_DEVBUF);
d1652 1
a1652 1
					free(dev, M_DEVBUF);
d1746 1
a1746 1
				free(dev, M_DEVBUF);
d1769 1
a1769 1
			free(dev, M_DEVBUF);
d2280 1
a2280 1
	free(mdm, M_DEVBUF);
d2294 1
a2294 1
	free(mdm, M_DEVBUF);
d2426 1
a2426 1
	free(sc->sc_ccbs, M_DEVBUF);
d2482 1
a2482 1
		free(sc->sc_rcbs, M_DEVBUF);
d3084 1
a3084 1
	free(vpg, M_TEMP);
d3171 1
a3171 1
		free(vpg, M_TEMP);
d3216 1
a3216 1
		free(vpg, M_TEMP);
d3230 1
a3230 1
	free(vpg, M_TEMP);
d3271 1
a3271 1
		free(vpg, M_TEMP);
d3279 1
a3279 1
		free(vpg, M_TEMP);
d3287 1
a3287 1
	free(vpg, M_TEMP);
d3327 1
a3327 1
		free(cpg, M_TEMP);
d3346 1
a3346 1
				free(cpg, M_TEMP);
d3356 1
a3356 1
	free(cpg, M_TEMP);
d3387 1
a3387 1
		free(ppg, M_TEMP);
d3395 1
a3395 1
		free(ppg, M_TEMP);
d3440 1
a3440 1
	free(ppg, M_TEMP);
d3493 1
a3493 1
		free(vpg, M_TEMP);
d3521 1
a3521 1
	free(vpg, M_TEMP);
d3566 1
a3566 1
	free(sc->sc_sensors, M_DEVBUF);
@


1.93
log
@don't access a pointer till after the null check
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.92 2014/04/10 01:28:32 dlg Exp $	*/
d1707 1
a1707 1
	u_int64_t			handle;
@


1.92
log
@marking the isr as MPSAFE snuck in with r1.76.

while it might be ok (and hasnt actually blown up since i committed
that) id rather review the code and enable it explicitely.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.91 2014/04/09 05:00:28 dlg Exp $	*/
d2300 1
a2300 1
	int slot = dev->slot;	/* initial hint */
d2302 1
a2302 1
	if (dev == NULL || slot < 0)
d2304 1
@


1.91
log
@remove an abstraction that just wraps a straight malloc on attach for
the sc_devs array.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.90 2014/04/09 03:59:28 dlg Exp $	*/
d581 1
a581 1
	sc->sc_ih = pci_intr_establish(sc->sc_pc, ih, IPL_BIO | IPL_MPSAFE,
@


1.90
log
@some mild knf
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.89 2014/03/27 12:19:55 dlg Exp $	*/
a292 1
int		mpii_alloc_dev(struct mpii_softc *);
d556 3
a558 1
	if (mpii_alloc_dev(sc) != 0) {
d566 1
a566 1
		goto free_dev;
d584 1
a584 1
		goto free_dev;
d611 3
a613 3
free_dev:
	if (sc->sc_devs)
		free(sc->sc_devs, M_DEVBUF);
a2294 10
}

int
mpii_alloc_dev(struct mpii_softc *sc)
{
	sc->sc_devs = malloc(sc->sc_max_devices *
	    sizeof(struct mpii_device *), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_devs == NULL)
		return (1);
	return (0);
@


1.89
log
@last of the htolem32 bits
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.88 2014/03/27 10:15:43 dlg Exp $	*/
a1613 1

d1616 2
a1617 1
	if (ISSET(lemtoh32(&ccl->flags), MPII_EVT_IR_CFG_CHANGE_LIST_FOREIGN))
d1620 1
d1760 1
a1760 1
			if (sc->sc_scsibus != NULL && 
d1769 1
d2250 1
a2250 1
	return (NULL);
d2311 1
a2311 1
	if (!dev || slot < 0)
d2313 1
d2316 1
d2319 1
d2322 1
d2331 1
a2331 1
	if (!dev)
d2333 6
a2338 3
	for (i = 0; i < sc->sc_max_devices;  i++)
		if (sc->sc_devs[i] &&
		    sc->sc_devs[i]->dev_handle == dev->dev_handle) {
d2342 2
d2352 5
a2356 2
	for (i = 0; i < sc->sc_max_devices;  i++)
		if (sc->sc_devs[i] && sc->sc_devs[i]->dev_handle == handle)
d2358 2
d2736 1
d2753 1
d2927 1
@


1.88
log
@tweak mpii_start.

on 64bit archs you can post the descriptor in one go, which is easy. on
32bit you have to post it in halves in the right order, which is not
atomic and requires barriers for ordering.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.87 2014/03/27 07:12:52 dlg Exp $	*/
d96 3
a98 3
#define MPII_DMA_MAP(_mdm)	(_mdm)->mdm_map
#define MPII_DMA_DVA(_mdm)	(_mdm)->mdm_map->dm_segs[0].ds_addr
#define MPII_DMA_KVA(_mdm)	(void *)(_mdm)->mdm_kva
a1249 1
	u_int32_t				hi_addr;
d1276 2
a1277 2
	hi_addr = (u_int32_t)((u_int64_t)MPII_DMA_DVA(sc->sc_requests) >> 32);
	htolem32(&iiq.sense_buffer_address_high, hi_addr);
d1279 2
a1280 2
	hi_addr = (u_int32_t)((u_int64_t)MPII_DMA_DVA(sc->sc_replies) >> 32);
	htolem32(&iiq.system_reply_address_high, hi_addr);
d1282 14
a1295 8
	iiq.system_request_frame_base_address =
	    htole64(MPII_DMA_DVA(sc->sc_requests));

	iiq.reply_descriptor_post_queue_address =
	    htole64(MPII_DMA_DVA(sc->sc_reply_postq));

	iiq.reply_free_queue_address =
	    htole64(MPII_DMA_DVA(sc->sc_reply_freeq));
@


1.87
log
@tweak the looping of the postq
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.86 2014/03/27 07:06:33 dlg Exp $	*/
a129 1
	int			ccb_smid;
d138 1
d2387 1
a2387 1
		ccb->ccb_smid = i;
d2502 1
a2502 1
	u_int32_t			*rdp = (u_int32_t *)&descr;
d2507 6
d2520 1
a2520 1
		htolem16(&descr.dev_handle, ccb->ccb_dev_handle);
d2530 1
a2530 7
	htolem16(&descr.smid, ccb->ccb_smid);

	bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_requests),
	    ccb->ccb_offset, sc->sc_request_size,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	ccb->ccb_state = MPII_CCB_QUEUED;
d2538 4
d2543 9
a2551 2
	mpii_write(sc, MPII_REQ_DESCR_POST_LOW, htole32(*rdp));
	mpii_write(sc, MPII_REQ_DESCR_POST_HIGH, htole32(*(rdp+1)));
d2553 1
@


1.86
log
@you want the ring to wrap when it gets to the size of the ring, not one
after it.

jmatthew@@ figured out i am bad at c.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.85 2014/03/27 05:53:37 dlg Exp $	*/
d224 1
a224 1
	int			sc_reply_post_host_index;
d227 1
a227 1
	int			sc_reply_free_host_index;
d666 1
d672 1
a672 1
	    0, 8 * sc->sc_reply_post_qdepth,
d675 1
d677 1
a677 1
		rdp = &postq[sc->sc_reply_post_host_index];
d700 3
a702 2
		sc->sc_reply_post_host_index++;
		sc->sc_reply_post_host_index %= sc->sc_reply_post_qdepth;
d708 1
a708 1
	    0, 8 * sc->sc_reply_post_qdepth,
d712 1
a712 1
		mpii_write_reply_post(sc, sc->sc_reply_post_host_index);
@


1.85
log
@optimise mpii_push_reply.

int types are easier to work with than shorts. use a compare to handle
ring wraparound rather than a mod operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.84 2014/03/27 05:34:07 dlg Exp $	*/
d1334 1
a1334 1
	if (++idx > sc->sc_reply_free_qdepth)
@


1.84
log
@updating the reply queue indexes on the chip dont have any dependent
register ops, so dont need barriers around them.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.83 2014/03/27 05:20:27 dlg Exp $	*/
d185 2
a186 2
	ushort			sc_reply_free_qdepth;
	ushort			sc_reply_post_qdepth;
d1324 1
d1329 2
d1332 1
a1332 1
	htolem32(&rfp[sc->sc_reply_free_host_index], rcb->rcb_reply_dva);
d1334 2
a1335 2
	sc->sc_reply_free_host_index = (sc->sc_reply_free_host_index + 1) %
	    sc->sc_reply_free_qdepth;
d1337 1
a1337 1
	mpii_write_reply_free(sc, sc->sc_reply_free_host_index);
@


1.83
log
@remove unused macros
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.82 2014/03/27 05:18:15 dlg Exp $	*/
d386 6
a391 4
#define mpii_write_reply_free(s, v)	mpii_write((s), \
						MPII_REPLY_FREE_HOST_INDEX, (v))
#define mpii_write_reply_post(s, v)	mpii_write((s), \
						MPII_REPLY_POST_HOST_INDEX, (v))
@


1.82
log
@forgot a htolem32
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.81 2014/03/27 05:09:26 dlg Exp $	*/
a385 2
#define mpii_read_reply_free(s)		mpii_read((s), \
						MPII_REPLY_FREE_HOST_INDEX)
a387 2
#define mpii_read_reply_post(s)		mpii_read((s), \
						MPII_REPLY_POST_HOST_INDEX)
@


1.81
log
@apply more htolemXX and lemtohXX.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.80 2014/03/24 12:43:51 dlg Exp $	*/
d1331 1
a1331 1
	rfp[sc->sc_reply_free_host_index] = htole32(rcb->rcb_reply_dva);
@


1.80
log
@shrink the iopath a bit by using htolemXX and lemtohXX.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.79 2014/03/24 12:06:58 dlg Exp $	*/
d689 1
a689 1
		smid = letoh16(rdp->smid);
d1128 1
d1153 1
a1153 1
	sc->sc_max_devices = ifp.max_volumes + letoh16(ifp.max_targets);
d1155 1
a1155 1
	if (ISSET(letoh32(ifp.ioc_capabilities),
d1159 1
a1159 1
	sc->sc_max_cmds = MIN(letoh16(ifp.request_credit),
d1177 3
a1179 4
	if (sc->sc_reply_post_qdepth >
	    letoh16(ifp.max_reply_descriptor_post_queue_depth)) {
		sc->sc_reply_post_qdepth =
		    letoh16(ifp.max_reply_descriptor_post_queue_depth);
d1221 1
a1221 1
	irs = letoh16(ifp.ioc_request_frame_size) * 4;
d1269 1
a1269 1
	iiq.system_request_frame_size = htole16(sc->sc_request_size / 4);
d1271 2
a1272 2
	iiq.reply_descriptor_post_queue_depth =
	    htole16(sc->sc_reply_post_qdepth);
d1274 1
a1274 1
	iiq.reply_free_queue_depth = htole16(sc->sc_reply_free_qdepth);
d1277 1
a1277 1
	iiq.sense_buffer_address_high = htole32(hi_addr);
d1279 2
a1280 3
	hi_addr = (u_int32_t)
	    ((u_int64_t)MPII_DMA_DVA(sc->sc_replies) >> 32);
	iiq.system_reply_address_high = htole32(hi_addr);
d1315 2
a1316 2
	if (letoh16(iip.ioc_status) != MPII_IOCSTATUS_SUCCESS ||
	    letoh32(iip.ioc_loginfo))
d1501 1
a1501 1
	if (!ISSET(letoh32(ipg.flags), MPII_CFG_IOC_1_REPLY_COALESCING))
d1608 1
a1608 1
	if (ISSET(letoh32(ccl->flags), MPII_EVT_IR_CFG_CHANGE_LIST_FOREIGN))
d1615 1
a1615 1
		type = (letoh16(ce->element_flags) &
d1624 1
a1624 1
				    letoh16(ce->vol_dev_handle))) {
d1627 1
a1627 1
					    letoh16(ce->vol_dev_handle));
d1639 1
a1639 1
				dev->dev_handle = letoh16(ce->vol_dev_handle);
d1649 1
a1649 1
				    letoh16(ce->vol_dev_handle))))
d1663 1
a1663 1
				    letoh16(ce->phys_disk_dev_handle))))
d1676 1
a1676 1
				    letoh16(ce->phys_disk_dev_handle))))
d1696 1
d1718 2
a1719 1
			if (mpii_find_dev(sc, letoh16(pe->dev_handle))) {
d1721 1
a1721 2
				    "configured\n", DEVNAME(sc),
				    letoh16(pe->dev_handle));
d1727 1
a1727 1
			dev->dev_handle = letoh16(pe->dev_handle);
d1731 2
a1732 2
			dev->enclosure = letoh16(tcl->enclosure_handle);
			dev->expander = letoh16(tcl->expander_handle);
d1744 1
a1744 1
			dev = mpii_find_dev(sc, letoh16(pe->dev_handle));
d1775 1
a1775 1
	switch (letoh16(enp->event)) {
d1817 1
a1817 1
		dev = mpii_find_dev(sc, letoh16(evd->vol_dev_handle));
d1844 1
a1844 1
		dev = mpii_find_dev(sc, letoh16(evs->vol_dev_handle));
d1852 1
a1852 1
		    DEVNAME(sc), letoh16(enp->event));
d1886 1
a1886 1
	stq->dev_handle = htole16(handle);
d1902 1
a1902 1
	soq->dev_handle = htole16(handle);
d1977 1
a1977 1
	if (letoh16(ipg.flags) & MPII_IOC_PG8_FLAGS_RESERVED_TARGETID_0)
d1980 1
a1980 1
	flags = letoh16(ipg.ir_volume_mapping_flags) &
d2034 2
a2035 2
	cq->page_address = htole32(address);
	cq->page_buffer.sg_hdr = htole32(MPII_SGE_FL_TYPE_SIMPLE |
d2074 1
a2074 1
	if (letoh16(cp->ioc_status) != MPII_IOCSTATUS_SUCCESS)
d2109 1
a2109 1
	    letoh16(ehdr->ext_page_length) : hdr->page_length;
d2138 2
a2139 2
	cq->page_address = htole32(address);
	cq->page_buffer.sg_hdr = htole32(MPII_SGE_FL_TYPE_SIMPLE |
d2190 1
a2190 1
	if (letoh16(cp->ioc_status) != MPII_IOCSTATUS_SUCCESS)
d2211 1
a2211 1
		rfid = (letoh32(rdp->frame_addr) -
d2510 1
a2510 1
		descr.dev_handle = htole16(ccb->ccb_dev_handle);
d2520 1
a2520 1
	descr.smid = htole16(ccb->ccb_smid);
d2789 1
a2789 1
	stq->dev_handle = htole16(ccb->ccb_dev_handle);
d2998 1
a2998 1
	enabled = ((letoh16(vpg->volume_settings) &
d3028 2
a3029 2
	req->vol_dev_handle = htole16(dev->dev_handle);
	req->action_data = htole32(dc->wrcache ?
d3149 1
a3149 1
		if (ISSET(letoh32(vpg->volume_status),
d3190 1
a3190 1
	bv->bv_size = letoh64(vpg->max_lba) * letoh16(vpg->block_size);
d3283 1
a3283 1
	pagelen = letoh16(ehdr.ext_page_length) * 4;
d3301 1
a3301 1
		if (ISSET(letoh16(el->element_flags),
d3361 1
a3361 1
	if ((dev = mpii_find_dev(sc, letoh16(ppg->dev_handle))) == NULL) {
d3399 1
a3399 1
	bd->bd_size = letoh64(ppg->dev_max_lba) * letoh16(ppg->block_size);
d3471 1
a3471 1
		if (ISSET(letoh32(vpg->volume_status),
@


1.79
log
@make mpii_sge look like mpi_sge, and provide a wrapper for setting the
address in it like the one in mpi too.

shrinks load_xs a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.78 2014/03/24 11:10:48 dlg Exp $	*/
d2702 3
a2704 3
	io->io_flags = htole16(xs->cmdlen);
	io->dev_handle = htole16(ccb->ccb_dev_handle);
	io->lun[0] = htobe16(link->lun);
d2721 1
a2721 1
	io->data_length = htole32(xs->datalen);
d2724 1
a2724 1
	io->sense_buffer_low_address = htole32(ccb->ccb_cmd_dva +
d2876 1
a2876 1
	switch (letoh16(sie->ioc_status) & MPII_IOCSTATUS_MASK) {
d2880 2
a2881 1
			xs->resid = xs->datalen - letoh32(sie->transfer_count);
@


1.78
log
@bcopy to memcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.77 2014/03/24 11:05:03 dlg Exp $	*/
d400 7
a737 1
	u_int64_t		addr;
d776 2
a777 4
			addr = (u_int64_t)ccb->ccb_cmd_dva +
			    (caddr_t)nsge - (caddr_t)io;
			csge->sg_hi_addr = htole32((u_int32_t)(addr >> 32));
			csge->sg_lo_addr = htole32((u_int32_t)addr);
d782 1
a782 3
		addr = (u_int64_t)dmap->dm_segs[i].ds_addr;
		sge->sg_hi_addr = htole32((u_int32_t)(addr >> 32));
		sge->sg_lo_addr = htole32((u_int32_t)addr);
a2100 1
	u_int64_t				dva;
d2145 2
a2146 4
	dva = ccb->ccb_cmd_dva + sizeof(struct mpii_msg_config_request);

	cq->page_buffer.sg_hi_addr = htole32((u_int32_t)(dva >> 32));
	cq->page_buffer.sg_lo_addr = htole32((u_int32_t)dva);
@


1.77
log
@replace bzero with memset
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.76 2014/03/24 07:24:20 dlg Exp $	*/
d2153 1
a2153 1
		bcopy(page, kva, len);
d2194 1
a2194 1
		bcopy(kva, page, len);
d2720 1
a2720 1
	bcopy(xs->cmd, io->cdb, xs->cmdlen);
d2932 1
a2932 1
		bcopy(sense, &xs->sense, sizeof(xs->sense));
@


1.76
log
@rework mpii to use tasks instead of scsi_tasks for sas event handling.
scsi_tasks are still backed by workq, and i dont like having to allocate
storage to defer work.

sas events that cause hotplug events are queued in the softc to be
handled by a single task that loops on the queue for work. think
levelled interrupts. this has a side effect that interrupts are
necessary to enumerate devices for attachment.

i wrote this toward the end of last year, but thought it best to
wait for 5.5 unlock.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.75 2014/03/06 14:08:06 gerhard Exp $	*/
d572 1
a572 1
	bzero(&saa, sizeof(saa));
d1129 2
a1130 2
	bzero(&ifq, sizeof(ifq));
	bzero(&ifp, sizeof(ifp));
d1251 2
a1252 2
	bzero(&iiq, sizeof(iiq));
	bzero(&iip, sizeof(iip));
d1358 1
a1358 1
	bzero(pfq, sizeof(*pfq));
d1492 1
a1492 1
	bzero(&ipg, sizeof(ipg));
d1897 1
a1897 1
	bzero(soq, sizeof(*soq));
d1918 2
a1919 2
	bzero(&ifq, sizeof(ifq));
	bzero(&ifp, sizeof(ifp));
d1939 1
a1939 1
	bzero(&mpg, sizeof(mpg));
d1967 1
a1967 1
	bzero(&ipg, sizeof(ipg));
d2075 1
a2075 1
		bzero(ehdr, sizeof(*ehdr));
d2427 1
a2427 1
	bzero(ccb->ccb_cmd, sc->sc_request_size);
d2506 1
a2506 1
	bzero(&descr, sizeof(descr));
d2676 1
a2676 1
		bzero(&xs->sense, sizeof(xs->sense));
d3025 1
a3025 1
	bzero(req, sizeof(*req));
d3547 1
a3547 1
		bzero(&bv, sizeof(bv));
@


1.75
log
@Cleanup dead code.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.74 2014/01/22 03:02:58 mikeb Exp $	*/
d34 1
d229 4
d344 1
a344 2
void		mpii_event_sas(struct mpii_softc *,
		    struct mpii_msg_event_reply *);
a346 1
void		mpii_event_defer(void *, void *);
d575 1
a575 1
	sc->sc_ih = pci_intr_establish(sc->sc_pc, ih, IPL_BIO,
d802 1
a802 1
		return (1);
d1540 4
d1686 1
a1686 1
mpii_event_sas(struct mpii_softc *sc, struct mpii_msg_event_reply *enp)
d1688 3
d1696 7
a1702 1
	tcl = (struct mpii_evt_sas_tcl *)(enp + 1);
d1704 1
a1704 1
	if (tcl->num_entries == 0)
d1706 2
d1709 2
d1722 2
a1723 6
			dev = malloc(sizeof(*dev), M_DEVBUF, M_NOWAIT | M_ZERO);
			if (!dev) {
				printf("%s: failed to allocate a "
				    "device structure\n", DEVNAME(sc));
				break;
			}
d1731 1
d1736 3
a1738 8
			if (sc->sc_scsibus) {
				SET(dev->flags, MPII_DF_ATTACH);
				if (scsi_task(mpii_event_defer, sc,
				    dev, 0) != 0)
					printf("%s: unable to run device "
					    "attachment routine\n",
					    DEVNAME(sc));
			}
d1740 1
d1742 2
a1743 2
			if (!(dev = mpii_find_dev(sc,
			    letoh16(pe->dev_handle))))
d1745 1
d1747 3
a1749 2
			if (sc->sc_scsibus) {
				SET(dev->flags, MPII_DF_DETACH);
d1752 2
a1753 5
				if (scsi_task(mpii_event_defer, sc,
				    dev, 0) != 0)
					printf("%s: unable to run device "
					    "detachment routine\n",
					    DEVNAME(sc));
d1755 2
a1756 1
			break;
d1759 2
d1789 5
a1793 2
		mpii_event_sas(sc, enp);
		break;
d1815 2
a1816 1
		if (!(dev = mpii_find_dev(sc, letoh16(evd->vol_dev_handle))))
d1842 3
a1844 3
		if (!(dev = mpii_find_dev(sc, letoh16(evs->vol_dev_handle))))
			break;
		if (evs->operation == MPII_EVENT_IR_RAIDOP_RESYNC)
a1870 21
mpii_event_defer(void *xsc, void *arg)
{
	struct mpii_softc	*sc = xsc;
	struct mpii_device	*dev = arg;

	if (ISSET(dev->flags, MPII_DF_DETACH)) {
		mpii_sas_remove_device(sc, dev->dev_handle);
		if (!ISSET(dev->flags, MPII_DF_HIDDEN)) {
			scsi_detach_target(sc->sc_scsibus, dev->slot,
			    DETACH_FORCE);
		}
		free(dev, M_DEVBUF);

	} else if (ISSET(dev->flags, MPII_DF_ATTACH)) {
		CLR(dev->flags, MPII_DF_ATTACH);
		if (!ISSET(dev->flags, MPII_DF_HIDDEN))
			scsi_probe_target(sc->sc_scsibus, dev->slot);
	}
}

void
d2657 2
a2659 1
	mtx_leave(mtx);
@


1.74
log
@fixup a few debug printfs;  pointed out by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.73 2013/12/04 17:07:43 mikeb Exp $	*/
a2996 2
		free(vpg, M_TEMP);
		return (EINVAL);
@


1.73
log
@kill a debug printf;  noticed by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.72 2013/11/06 23:58:25 dlg Exp $	*/
d2173 3
a2175 3
	DNPRINTF(MPII_D_MISC, "%s:  action: 0x%02x sglflags: 0x%02x "
	    "msg_length: %d function: 0x%02x\n", DEVNAME(sc), cp->action,
	    cp->msg_length, cp->function);
d2550 1
a2550 1
	DNPRINTF(MPII_D_INTR, "%s: mpii_complete %d\n", DEVNAME(sc));
@


1.72
log
@pull the event ack handling out of mpii_event_process into mpii_event_done
so we can use it in multiple places.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.71 2013/11/06 08:00:17 dlg Exp $	*/
a1840 2

	printf("%s: %s\n", DEVNAME(sc), __func__);
@


1.71
log
@dont leak ccbs in mpii_sas_remove_device. detaching lots (like, 1000) of
things could run you out of command slots without this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.70 2013/10/25 16:21:35 mikeb Exp $	*/
d338 1
d1833 10
@


1.70
log
@fix an off by one when calculating the length of an sgl segment
that our chain scatter-gather element is pointing to.  the bug
was observed by pedro martelletto with some particular firmware
doing raid 0.  the fix wouldn't have been possible without
extensive debugging and spec conformance verification done by
pedro.

tested by pedro, dlg and myself, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.69 2013/01/25 04:25:21 dlg Exp $	*/
d1899 2
@


1.69
log
@the event type is a 16bit value, not 32bit. use htole16 instead of htole32.

mpii(4) works on sparc64 with this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.68 2012/09/28 12:46:41 mikeb Exp $	*/
d750 1
a750 1
	/* safe default staring flags */
a751 1
	/* if data out */
d761 2
a762 2
			/* lenght of the chain buffer */
			len = (dmap->dm_nsegs - i - 1) * sizeof(*sge);
@


1.68
log
@update my copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.67 2012/09/10 09:41:58 mikeb Exp $	*/
d1756 1
a1756 1
	    letoh32(enp->event));
d1758 1
a1758 1
	switch (letoh32(enp->event)) {
d1831 1
a1831 1
		    DEVNAME(sc), letoh32(enp->event));
@


1.67
log
@autoconf is not the right place to sleep; noticed by haesbaert
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.66 2012/09/07 19:10:39 mikeb Exp $	*/
d3 1
a3 1
 * Copyright (c) 2010 Mike Belopuhov <mkb@@crypt.org.ru>
@


1.66
log
@Fixup a memory access fault on an invalid reply.  Quoting the spec:

    The host driver must ensure that there is at least one
    unused entry in the Reply Free Queue. One way to ensure
    that this requirement is met is to never allocate a number
    of reply frames that is a multiple of 16.

So bring back the old logic of calculating the RFQ depth and add a
comment explaining why is it done.  Duh!
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.65 2012/08/28 17:02:33 mikeb Exp $	*/
d3495 1
a3495 1
	    M_DEVBUF, M_WAITOK | M_CANFAIL | M_ZERO);
@


1.65
log
@oops. a bit of debugging code has sneaked in
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.64 2012/08/28 14:52:34 mikeb Exp $	*/
d1155 7
d1163 2
@


1.64
log
@Get rid of several ill-defined concepts and use more information
provided by the IOC.  Cleanup scatter-gather code and add more
comments.  Tested by a "make build" and bonnie++ torturing on a
SAS2004 with an IR firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.63 2012/08/25 03:43:27 dlg Exp $	*/
a748 3

	if (dmap->dm_nsegs > sc->sc_max_sgl)
		panic("too many segments");
@


1.63
log
@some endian fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.62 2012/08/23 15:42:50 mikeb Exp $	*/
d86 2
a87 11
#define MPII_REQUEST_SIZE	(512)
#define MPII_REPLY_SIZE		(128)
#define MPII_REPLY_COUNT	PAGE_SIZE / MPII_REPLY_SIZE

/*
 * this is the max number of sge's we can stuff in a request frame:
 * sizeof(scsi_io) + sizeof(sense) + sizeof(sge) * 32 = MPII_REQUEST_SIZE
 */
#define MPII_MAX_SGL			(32)

#define MPII_MAX_REQUEST_CREDIT		(128)
a98 6
struct mpii_ccb_bundle {
	struct mpii_msg_scsi_io	mcb_io; /* sgl must follow */
	struct mpii_sge		mcb_sgl[MPII_MAX_SGL];
	struct scsi_sense_data	mcb_sense;
} __packed;

d179 10
a188 8
	int			sc_request_depth;
	int			sc_num_reply_frames;
	int			sc_reply_free_qdepth;
	int			sc_reply_post_qdepth;
	int			sc_maxchdepth;
	int			sc_first_sgl_len;
	int			sc_chain_len;
	int			sc_max_sgl_len;
d565 1
a565 1
	sc->sc_link.openings = sc->sc_request_depth - 1;
d724 2
a725 5
	struct mpii_ccb_bundle	*mcb = ccb->ccb_cmd;
	struct mpii_msg_scsi_io	*io = &mcb->mcb_io;
	struct mpii_sge		*sge = NULL, *nsge = &mcb->mcb_sgl[0];
	struct mpii_sge		*ce = NULL, *nce = NULL;
	u_int64_t		ce_dva;
d727 3
a729 1
	u_int32_t		addr, flags;
d732 4
d743 1
a743 2
	error = bus_dmamap_load(sc->sc_dmat, dmap,
	    xs->data, xs->datalen, NULL,
d750 3
d759 2
a760 8
	/* we will have to exceed the SGEs we can cram into the request frame */
	if (dmap->dm_nsegs > sc->sc_first_sgl_len) {
		ce = &mcb->mcb_sgl[sc->sc_first_sgl_len - 1];
		io->chain_offset = ((u_int8_t *)ce - (u_int8_t *)io) / 4;
	}

	for (i = 0; i < dmap->dm_nsegs; i++) {
		if (nsge == ce) {
d763 11
a773 32

			DNPRINTF(MPII_D_DMA, "%s:   - 0x%08x 0x%08x 0x%08x\n",
			    DEVNAME(sc), sge->sg_hdr,
			    sge->sg_hi_addr, sge->sg_lo_addr);

			if ((dmap->dm_nsegs - i) > sc->sc_chain_len) {
				nce = &nsge[sc->sc_chain_len - 1];
				addr = ((u_int8_t *)nce - (u_int8_t *)nsge) / 4;
				addr = addr << 16 |
				    sizeof(struct mpii_sge) * sc->sc_chain_len;
			} else {
				nce = NULL;
				addr = sizeof(struct mpii_sge) *
				    (dmap->dm_nsegs - i);
			}

			ce->sg_hdr = htole32(MPII_SGE_FL_TYPE_CHAIN |
			    MPII_SGE_FL_SIZE_64 | addr);

			ce_dva = ccb->ccb_cmd_dva +
			    ((u_int8_t *)nsge - (u_int8_t *)mcb);

			addr = (u_int32_t)(ce_dva >> 32);
			ce->sg_hi_addr = htole32(addr);
			addr = (u_int32_t)ce_dva;
			ce->sg_lo_addr = htole32(addr);

			DNPRINTF(MPII_D_DMA, "%s:  ce: 0x%08x 0x%08x 0x%08x\n",
			    DEVNAME(sc), ce->sg_hdr, ce->sg_hi_addr,
			    ce->sg_lo_addr);

			ce = nce;
a775 4
		DNPRINTF(MPII_D_DMA, "%s:  %d: %d 0x%016llx\n", DEVNAME(sc),
		    i, dmap->dm_segs[i].ds_len,
		    (u_int64_t)dmap->dm_segs[i].ds_addr);

a776 1

d778 3
a780 10
		addr = (u_int32_t)((u_int64_t)dmap->dm_segs[i].ds_addr >> 32);
		sge->sg_hi_addr = htole32(addr);
		addr = (u_int32_t)dmap->dm_segs[i].ds_addr;
		sge->sg_lo_addr = htole32(addr);

		DNPRINTF(MPII_D_DMA, "%s:  %d: 0x%08x 0x%08x 0x%08x\n",
		    DEVNAME(sc), i, sge->sg_hdr, sge->sg_hi_addr,
		    sge->sg_lo_addr);

		nsge = sge + 1;
d1125 1
a1145 1
	sc->sc_maxchdepth = ifp.max_chain_depth;
d1156 3
a1158 3
	sc->sc_request_depth = MIN(letoh16(ifp.request_credit),
	    MPII_MAX_REQUEST_CREDIT);
	sc->sc_num_reply_frames = sc->sc_request_depth + 32;
d1161 1
a1161 1
	sc->sc_reply_post_qdepth = sc->sc_request_depth +
d1163 1
a1163 1
	sc->sc_reply_post_qdepth += (16 - (sc->sc_reply_post_qdepth % 16));
d1173 2
a1174 2
		sc->sc_request_depth = sc->sc_reply_post_qdepth / 2 - 4;
		sc->sc_num_reply_frames = sc->sc_request_depth + 4;
d1178 1
a1178 1
	    (16 - (sc->sc_num_reply_frames % 16));
d1181 25
a1205 2
	 * you can fit sg elements on the end of the io cmd if they fit in the
	 * request frame size.
d1208 13
a1220 15
	sc->sc_first_sgl_len = ((letoh16(ifp.ioc_request_frame_size) * 4) -
	    sizeof(struct mpii_msg_scsi_io)) / sizeof(struct mpii_sge);
	DNPRINTF(MPII_D_MISC, "%s:   first sgl len: %d\n", DEVNAME(sc),
	    sc->sc_first_sgl_len);

	sc->sc_chain_len = (letoh16(ifp.ioc_request_frame_size) * 4) /
	    sizeof(struct mpii_sge);
	DNPRINTF(MPII_D_MISC, "%s:   chain len: %d\n", DEVNAME(sc),
	    sc->sc_chain_len);

	/* the sgl tailing the io cmd loses an entry to the chain element. */
	sc->sc_max_sgl_len = MPII_MAX_SGL - 1;
	/* the sgl chains lose an entry for each chain element */
	sc->sc_max_sgl_len -= (MPII_MAX_SGL - sc->sc_first_sgl_len) /
	    sc->sc_chain_len;
d1222 7
a1228 1
	/* XXX we're ignoring the max chain depth */
d1258 1
a1258 1
	iiq.system_request_frame_size = htole16(MPII_REQUEST_SIZE / 4);
d2096 1
a2096 2
	if (len > MPII_REQUEST_SIZE - sizeof(struct mpii_msg_config_request) ||
	    len < page_length * 4)
d2199 2
a2200 1
		    (u_int32_t)MPII_DMA_DVA(sc->sc_replies)) / MPII_REPLY_SIZE;
d2203 2
a2204 2
		    MPII_DMA_MAP(sc->sc_replies), MPII_REPLY_SIZE * rfid,
		    MPII_REPLY_SIZE, BUS_DMASYNC_POSTREAD);
d2339 1
a2339 1
	sc->sc_ccbs = malloc(sizeof(*ccb) * (sc->sc_request_depth-1),
d2347 1
a2347 1
	    MPII_REQUEST_SIZE * sc->sc_request_depth);
d2355 1
a2355 1
	 * we have sc->sc_request_depth system request message
d2357 1
a2357 1
	 * have (sc->sc_request_depth - 1) number of ccbs
d2359 1
a2359 1
	for (i = 1; i < sc->sc_request_depth; i++) {
d2362 2
a2363 3
		if (bus_dmamap_create(sc->sc_dmat, MAXPHYS,
		    sc->sc_max_sgl_len, MAXPHYS, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
d2371 1
a2371 1
		ccb->ccb_offset = MPII_REQUEST_SIZE * i;
d2413 1
a2413 1
	bzero(ccb->ccb_cmd, MPII_REQUEST_SIZE);
d2449 1
a2449 1
	sc->sc_replies = mpii_dmamem_alloc(sc, MPII_REPLY_SIZE *
d2467 2
a2468 1
	    0, MPII_REPLY_SIZE * sc->sc_num_reply_frames, BUS_DMASYNC_PREREAD);
d2473 1
a2473 1
		rcb->rcb_reply = kva + MPII_REPLY_SIZE * i;
d2475 1
a2475 1
		    MPII_REPLY_SIZE * i;
d2510 1
a2510 1
	    ccb->ccb_offset, MPII_REQUEST_SIZE,
d2581 1
a2581 1
		    MPII_REPLY_SIZE * i;
a2652 1
	struct mpii_ccb_bundle	*mcb;
d2684 1
a2684 3
	mcb = ccb->ccb_cmd;
	io = &mcb->mcb_io;

d2687 1
a2687 1
	io->sgl_offset0 = 24; /* XXX fix this */
d2709 1
d2711 1
a2711 1
	    ((u_int8_t *)&mcb->mcb_sense - (u_int8_t *)mcb));
a2718 13
	DNPRINTF(MPII_D_CMD, "%s:  sizeof(mpii_msg_scsi_io): %d "
	    "sizeof(mpii_ccb_bundle): %d sge offset: 0x%02x\n",
	    DEVNAME(sc), sizeof(struct mpii_msg_scsi_io),
	    sizeof(struct mpii_ccb_bundle),
	    (u_int8_t *)&mcb->mcb_sgl[0] - (u_int8_t *)mcb);

	DNPRINTF(MPII_D_CMD, "%s   sgl[0]: 0x%04x 0%04x 0x%04x\n",
	    DEVNAME(sc), mcb->mcb_sgl[0].sg_hdr, mcb->mcb_sgl[0].sg_lo_addr,
	    mcb->mcb_sgl[0].sg_hi_addr);

	DNPRINTF(MPII_D_CMD, "%s:  Offset0: 0x%02x\n", DEVNAME(sc),
	    io->sgl_offset0);

a2727 3
	DNPRINTF(MPII_D_CMD, "%s:    mpii_scsi_cmd(): opcode: %02x "
	    "datalen: %d\n", DEVNAME(sc), xs->cmd->opcode, xs->datalen);

d2794 1
a2794 1
	struct mpii_ccb_bundle	*mcb = ccb->ccb_cmd;
d2914 2
d2917 1
a2917 1
		bcopy(&mcb->mcb_sense, &xs->sense, sizeof(xs->sense));
@


1.62
log
@cleanup calculations in iocfacts a bit: number of reply frames doesn't
have to be not multiple of 16, recalculate request credit and number of
replies if their sum exceeds MaxReplyDescriptorPostQueueDepth.  tested
on SAS2004 with bonnie++.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.61 2012/08/23 11:52:02 mikeb Exp $	*/
d1293 1
a1293 1
	    (u_int64_t)MPII_DMA_DVA(sc->sc_requests);
d1296 1
a1296 1
	    (u_int64_t)MPII_DMA_DVA(sc->sc_reply_postq);
d1299 1
a1299 1
	    (u_int64_t)MPII_DMA_DVA(sc->sc_reply_freeq);
d1325 2
a1326 1
	if ((iip.ioc_status != MPII_IOCSTATUS_SUCCESS) || (iip.ioc_loginfo))
d1341 1
a1341 1
	rfp[sc->sc_reply_free_host_index] = rcb->rcb_reply_dva;
@


1.61
log
@use BUS_DMA_ZERO
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.60 2012/08/22 16:59:27 mikeb Exp $	*/
a921 1

a1204 2

	/* should not be multiple of 16 */
a1205 2
	if (!(sc->sc_num_reply_frames % 16))
		sc->sc_num_reply_frames--;
d1208 3
a1210 4
	sc->sc_reply_free_qdepth = sc->sc_num_reply_frames +
	    (16 - (sc->sc_num_reply_frames % 16));
	sc->sc_reply_post_qdepth = ((sc->sc_request_depth +
	    sc->sc_num_reply_frames + 1 + 15) / 16) * 16;
d1213 1
a1213 1
	    ifp.max_reply_descriptor_post_queue_depth)
d1215 8
a1222 1
		    ifp.max_reply_descriptor_post_queue_depth;
d1224 2
a1225 5
	DNPRINTF(MPII_D_MISC, "%s: sc_request_depth: %d "
	    "sc_num_reply_frames: %d sc_reply_free_qdepth: %d "
	    "sc_reply_post_qdepth: %d\n", DEVNAME(sc), sc->sc_request_depth,
	    sc->sc_num_reply_frames, sc->sc_reply_free_qdepth,
	    sc->sc_reply_post_qdepth);
a1246 2
	DNPRINTF(MPII_D_MISC, "%s:   max sgl len: %d\n", DEVNAME(sc),
	    sc->sc_max_sgl_len);
@


1.60
log
@cleanup mpii_alloc_queues, use caddr_t for kva plus a bit of cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.59 2012/08/22 16:17:00 mikeb Exp $	*/
d2258 1
a2258 1
	    1, &nsegs, BUS_DMA_NOWAIT) != 0)
a2268 6
	DNPRINTF(MPII_D_MEM, "  kva: %p  dva: %p  map: %p  size: %d\n",
	    mdm->mdm_kva, mdm->mdm_map->dm_segs[0].ds_addr, mdm->mdm_map,
	    size);

	bzero(mdm->mdm_kva, size);

a2375 1
	bzero(cmd, MPII_REQUEST_SIZE * sc->sc_request_depth);
@


1.59
log
@remove last remnants of mpii_[e]cfg_header and mpii_[e]cfg_page
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.58 2012/08/22 16:07:42 mikeb Exp $	*/
d2009 5
a2013 5
	struct mpii_cfg_hdr	*hdr = p;
	struct mpii_ccb		*ccb;
	struct mpii_ecfg_hdr	*ehdr = p;
	int			etype = 0;
	int			rv = 0;
d2105 7
a2111 7
	struct mpii_cfg_hdr	*hdr = p;
	struct mpii_ccb		*ccb;
	struct mpii_ecfg_hdr	*ehdr = p;
	u_int64_t		dva;
	char			*kva;
	int			page_length;
	int			rv = 0;
d2494 1
a2494 1
	char			*kva = MPII_DMA_KVA(sc->sc_replies);
d2599 1
a2599 2
	u_int32_t		*kva;
	u_int64_t		*kva64;
d2605 1
a2605 1
	    sc->sc_reply_free_qdepth * 4);
d2608 1
a2608 2

	kva = MPII_DMA_KVA(sc->sc_reply_freeq);
d2610 1
a2610 1
		kva[i] = (u_int32_t)MPII_DMA_DVA(sc->sc_replies) +
a2611 5

		DNPRINTF(MPII_D_MISC, "%s:   %d:  0x%08x = 0x%08x\n",
		    DEVNAME(sc), i,
		    &kva[i], (u_int32_t)MPII_DMA_DVA(sc->sc_replies) +
		    MPII_REPLY_SIZE * i);
d2614 2
a2615 2
	sc->sc_reply_postq =
	    mpii_dmamem_alloc(sc, sc->sc_reply_post_qdepth * 8);
d2619 2
a2620 9

	DNPRINTF(MPII_D_MISC, "%s:  populating reply post descriptor queue\n",
	    DEVNAME(sc));
	kva64 = (u_int64_t *)MPII_DMA_KVA(sc->sc_reply_postq);
	for (i = 0; i < sc->sc_reply_post_qdepth; i++) {
		kva64[i] = 0xffffffffffffffffllu;
		DNPRINTF(MPII_D_MISC, "%s:    %d:  0x%08x = 0x%lx\n",
		    DEVNAME(sc), i, &kva64[i], kva64[i]);
	}
a2624 1

@


1.58
log
@for device pages of the fixed size there's no need to query their
lengths nor to allocate the storage dynamically so place them on
the stack and initialize the header by hand.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.57 2012/08/22 15:52:41 mikeb Exp $	*/
a412 14
#define mpii_cfg_header(_s, _t, _n, _a, _h) \
	mpii_req_cfg_header((_s), (_t), (_n), (_a), \
	    MPII_PG_POLL, (_h))
#define mpii_ecfg_header(_s, _t, _n, _a, _h) \
	mpii_req_cfg_header((_s), (_t), (_n), (_a), \
	    MPII_PG_POLL|MPII_PG_EXTENDED, (_h))

#define mpii_cfg_page(_s, _a, _h, _r, _p, _l) \
	mpii_req_cfg_page((_s), (_a), MPII_PG_POLL, \
	    (_h), (_r), (_p), (_l))
#define mpii_ecfg_page(_s, _a, _h, _r, _p, _l) \
	mpii_req_cfg_page((_s), (_a), MPII_PG_POLL|MPII_PG_EXTENDED, \
	    (_h), (_r), (_p), (_l))

d3490 2
a3491 2
	if (mpii_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_RAID_VOL, 0,
	    MPII_CFG_RAID_VOL_ADDR_HANDLE | volh, &hdr) != 0) {
d3505 2
a3506 2
	if (mpii_cfg_page(sc, MPII_CFG_RAID_VOL_ADDR_HANDLE | volh,
	    &hdr, 1, vpg, pagelen) != 0) {
@


1.57
log
@minor style nits for the function prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.56 2012/08/22 14:50:29 mikeb Exp $	*/
d1513 2
a1514 2
	struct mpii_cfg_hdr		hdr;
	struct mpii_cfg_ioc_pg1		pg;
d1516 7
a1522 8
	if (mpii_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_IOC, 1, 0,
	    &hdr) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: unable to fetch IOC page 1 "
		    "header\n", DEVNAME(sc));
		return (1);
	}

	if (mpii_cfg_page(sc, 0, &hdr, 1, &pg, sizeof(pg)) != 0) {
d1528 1
a1528 1
	if (!ISSET(letoh32(pg.flags), MPII_CFG_IOC_1_REPLY_COALESCING))
d1531 4
a1534 2
	CLR(pg.flags, htole32(MPII_CFG_IOC_1_REPLY_COALESCING));
	if (mpii_cfg_page(sc, 0, &hdr, 0, &pg, sizeof(pg)) != 0) {
d1938 1
a1938 1
	struct mpii_cfg_manufacturing_pg0	*mpg;
a1957 7
	mpg = malloc(sizeof(*mpg), M_TEMP, M_NOWAIT);
	if (mpg == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: unable to allocate space for the "
		    "manufacturing page 0\n", DEVNAME(sc));
		return (ENOMEM);
	}

d1959 1
a1959 1
	hdr.page_length = sizeof(*mpg) / 4;
d1962 3
a1964 3

	if (mpii_req_cfg_page(sc, 0, MPII_PG_POLL, &hdr, 1, mpg,
	    sizeof(*mpg)) != 0) {
a1966 1
		free(mpg, M_TEMP);
d1971 1
a1971 1
	    mpg->board_name, ifp.fw_version_maj, ifp.fw_version_min,
a1975 1
	free(mpg, M_TEMP);
d1982 3
a1984 10
	struct mpii_cfg_hdr	hdr;
	struct mpii_cfg_ioc_pg8	*ipg;
	int			flags, pad = 0;

	ipg = malloc(sizeof(*ipg), M_TEMP, M_NOWAIT);
	if (ipg == NULL) {
		DNPRINTF(MPII_D_CFG, "%s: unable to allocate space for the "
		    "ioc page 8\n", DEVNAME(sc));
		return (ENOMEM);
	}
d1987 1
a1987 1
	hdr.page_length = sizeof(*ipg) / 4;
d1990 3
a1992 3

	if (mpii_req_cfg_page(sc, 0, MPII_PG_POLL, &hdr, 1, ipg,
	    sizeof(*ipg)) != 0) {
a1994 1
		free(ipg, M_TEMP);
d1998 1
a1998 1
	if (letoh16(ipg->flags) & MPII_IOC_PG8_FLAGS_RESERVED_TARGETID_0)
d2001 1
a2001 1
	flags = letoh16(ipg->ir_volume_mapping_flags) &
a2013 1
	free(ipg, M_TEMP);
@


1.56
log
@kill several unused or useless defines; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.55 2012/08/17 18:28:31 mikeb Exp $	*/
d285 2
a286 1
struct mpii_dmamem	*mpii_dmamem_alloc(struct mpii_softc *, size_t);
d304 2
a305 1
struct mpii_device *mpii_find_dev(struct mpii_softc *, u_int16_t);
d310 2
a311 1
struct mpii_rcb *mpii_reply(struct mpii_softc *, struct mpii_reply_descr *);
d375 2
a376 1
struct mpii_device *mpii_find_vol(struct mpii_softc *, int);
@


1.55
log
@cleanup mpii_get_ioc_pg8 mess, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.54 2012/08/16 19:19:44 mikeb Exp $	*/
a271 3
#define PREAD(s, r)	pci_conf_read((s)->sc_pc, (s)->sc_tag, (r))
#define PWRITE(s, r, v)	pci_conf_write((s)->sc_pc, (s)->sc_tag, (r), (v))

a382 1
#define dwordn(p, n)		(((u_int32_t *)(p))[(n)])
d484 3
a486 1
	PWRITE(sc, PCI_ROM_REG, PREAD(sc, PCI_ROM_REG) & ~PCI_ROM_ENABLE);
@


1.54
log
@display board model and firmware revision like mfi/mfii do;  ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.53 2012/08/14 17:56:04 mikeb Exp $	*/
d344 1
a363 2
int		mpii_get_ioc_pg8(struct mpii_softc *);

d554 2
a555 2
	if (mpii_get_ioc_pg8(sc) != 0) {
		printf("%s: unable to get ioc page 8\n", DEVNAME(sc));
d1986 1
a1986 1
mpii_get_ioc_pg8(struct mpii_softc *sc)
d1989 2
a1990 4
	struct mpii_cfg_ioc_pg8	*page;
	size_t			pagelen;
	u_int16_t		flags;
	int			pad = 0, rv = 0;
d1992 5
a1996 7
	DNPRINTF(MPII_D_RAID, "%s: mpii_get_ioc_pg8\n", DEVNAME(sc));

	if (mpii_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_IOC, 8, 0,
	    &hdr) != 0) {
		DNPRINTF(MPII_D_CFG, "%s: mpii_get_ioc_pg8 unable to fetch "
		    "header for IOC page 8\n", DEVNAME(sc));
		return (1);
d1999 11
a2009 14
	pagelen = hdr.page_length * 4; /* dwords to bytes */

	page = malloc(pagelen, M_TEMP, M_NOWAIT);
	if (page == NULL) {
		DNPRINTF(MPII_D_CFG, "%s: mpii_get_ioc_pg8 unable to allocate "
		    "space for ioc config page 8\n", DEVNAME(sc));
		return (1);
	}

	if (mpii_cfg_page(sc, 0, &hdr, 1, page, pagelen) != 0) {
		DNPRINTF(MPII_D_CFG, "%s: mpii_get_raid unable to fetch IOC "
		    "page 8\n", DEVNAME(sc));
		rv = 1;
		goto out;
d2012 1
a2012 12
	DNPRINTF(MPII_D_CFG, "%s:  numdevsperenclosure: 0x%02x\n", DEVNAME(sc),
	    page->num_devs_per_enclosure);
	DNPRINTF(MPII_D_CFG, "%s:  maxpersistententries: 0x%04x "
	    "maxnumphysicalmappedids: 0x%04x\n", DEVNAME(sc),
	    letoh16(page->max_persistent_entries),
	    letoh16(page->max_num_physical_mapped_ids));
	DNPRINTF(MPII_D_CFG, "%s:  flags: 0x%04x\n", DEVNAME(sc),
	    letoh16(page->flags));
	DNPRINTF(MPII_D_CFG, "%s:  irvolumemappingflags: 0x%04x\n",
	    DEVNAME(sc), letoh16(page->ir_volume_mapping_flags));

	if (page->flags & MPII_IOC_PG8_FLAGS_RESERVED_TARGETID_0)
d2015 1
a2015 1
	flags = page->ir_volume_mapping_flags &
d2028 2
a2029 8
	DNPRINTF(MPII_D_MAP, "%s: mpii_get_ioc_pg8 mapping: sc_pd_id_start: %d "
	    "sc_vd_id_low: %d sc_max_volumes: %d\n", DEVNAME(sc),
	    sc->sc_pd_id_start, sc->sc_vd_id_low, sc->sc_max_volumes);

out:
	free(page, M_TEMP);

	return(rv);
@


1.53
log
@whitespace cleanup; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.52 2012/08/14 00:20:17 dlg Exp $	*/
a193 1
	u_int8_t		sc_porttype;
d204 2
a205 2
	u_int16_t		sc_max_enclosures;
	u_int16_t		sc_max_expanders;
a207 1
	u_int16_t		sc_max_dpm_entries;
a210 1
	u_int8_t		sc_num_channels;
a212 1
	u_int8_t		sc_num_ports;
d343 1
d544 6
a1205 44
	DNPRINTF(MPII_D_MISC, "%s:  func: 0x%02x length: %d msgver: %d.%d\n",
	    DEVNAME(sc), ifp.function, ifp.msg_length,
	    ifp.msg_version_maj, ifp.msg_version_min);
	DNPRINTF(MPII_D_MISC, "%s:  msgflags: 0x%02x iocnumber: 0x%02x "
	    "headerver: %d.%d\n", DEVNAME(sc), ifp.msg_flags,
	    ifp.ioc_number, ifp.header_version_unit,
	    ifp.header_version_dev);
	DNPRINTF(MPII_D_MISC, "%s:  vp_id: 0x%02x vf_id: 0x%02x\n", DEVNAME(sc),
	    ifp.vp_id, ifp.vf_id);
	DNPRINTF(MPII_D_MISC, "%s:  iocstatus: 0x%04x ioexceptions: 0x%04x\n",
	    DEVNAME(sc), letoh16(ifp.ioc_status),
	    letoh16(ifp.ioc_exceptions));
	DNPRINTF(MPII_D_MISC, "%s:  iocloginfo: 0x%08x\n", DEVNAME(sc),
	    letoh32(ifp.ioc_loginfo));
	DNPRINTF(MPII_D_MISC, "%s:  numberofports: 0x%02x whoinit: 0x%02x "
	    "maxchaindepth: %d\n", DEVNAME(sc), ifp.number_of_ports,
	    ifp.whoinit, ifp.max_chain_depth);
	DNPRINTF(MPII_D_MISC, "%s:  productid: 0x%04x requestcredit: 0x%04x\n",
	    DEVNAME(sc), letoh16(ifp.product_id), letoh16(ifp.request_credit));
	DNPRINTF(MPII_D_MISC, "%s:  ioc_capabilities: 0x%08x\n", DEVNAME(sc),
	    letoh32(ifp.ioc_capabilities));
	DNPRINTF(MPII_D_MISC, "%s:  fw_version: %d.%d fw_version_unit: 0x%02x "
	    "fw_version_dev: 0x%02x\n", DEVNAME(sc),
	    ifp.fw_version_maj, ifp.fw_version_min,
	    ifp.fw_version_unit, ifp.fw_version_dev);
	DNPRINTF(MPII_D_MISC, "%s:  iocrequestframesize: 0x%04x\n",
	    DEVNAME(sc), letoh16(ifp.ioc_request_frame_size));
	DNPRINTF(MPII_D_MISC, "%s:  maxtargets: 0x%04x "
	    "maxinitiators: 0x%04x\n", DEVNAME(sc),
	    letoh16(ifp.max_targets), letoh16(ifp.max_initiators));
	DNPRINTF(MPII_D_MISC, "%s:  maxenclosures: 0x%04x "
	    "maxsasexpanders: 0x%04x\n", DEVNAME(sc),
	    letoh16(ifp.max_enclosures), letoh16(ifp.max_sas_expanders));
	DNPRINTF(MPII_D_MISC, "%s:  highprioritycredit: 0x%04x "
	    "protocolflags: 0x%02x\n", DEVNAME(sc),
	    letoh16(ifp.high_priority_credit), letoh16(ifp.protocol_flags));
	DNPRINTF(MPII_D_MISC, "%s:  maxvolumes: 0x%02x replyframesize: 0x%02x "
	    "mrdpqd: 0x%04x\n", DEVNAME(sc), ifp.max_volumes,
	    ifp.reply_frame_size,
	    letoh16(ifp.max_reply_descriptor_post_queue_depth));
	DNPRINTF(MPII_D_MISC, "%s:  maxpersistententries: 0x%04x "
	    "maxdevhandle: 0x%02x\n", DEVNAME(sc),
	    letoh16(ifp.max_persistent_entries), letoh16(ifp.max_dev_handle));

a1209 5
	sc->sc_num_ports = ifp.number_of_ports;
	sc->sc_ioc_event_replay = (letoh32(ifp.ioc_capabilities) &
	    MPII_IOCFACTS_CAPABILITY_EVENT_REPLAY) ? 1 : 0;
	sc->sc_max_enclosures = letoh16(ifp.max_enclosures);
	sc->sc_max_expanders = letoh16(ifp.max_sas_expanders);
a1211 1
	sc->sc_num_channels = 1;
d1267 1
a1267 2
	return(0);

a1406 17
	DNPRINTF(MPII_D_MISC, "%s   pfp: 0x%04x\n", DEVNAME(sc), pfp);

	DNPRINTF(MPII_D_MISC, "%s:  function: 0x%02x msg_length: %d\n",
	    DEVNAME(sc), pfp->function, pfp->msg_length);
	DNPRINTF(MPII_D_MISC, "%s:  msg_flags: 0x%02x port_number: %d\n",
	    DEVNAME(sc), pfp->msg_flags, pfp->port_number);
	DNPRINTF(MPII_D_MISC, "%s:  vf_id: 0x%02x vp_id: 0x%02x\n",
	    DEVNAME(sc), pfp->vf_id, pfp->vp_id);
	DNPRINTF(MPII_D_MISC, "%s:  ioc_status: 0x%04x\n", DEVNAME(sc),
	    letoh16(pfp->ioc_status));
	DNPRINTF(MPII_D_MISC, "%s:  ioc_loginfo: 0x%08x\n", DEVNAME(sc),
	    letoh32(pfp->ioc_loginfo));
	DNPRINTF(MPII_D_MISC, "%s:  port_type: 0x%02x\n", DEVNAME(sc),
	    pfp->port_type);
	DNPRINTF(MPII_D_MISC, "%s:  max_posted_cmd_buffers: %d\n", DEVNAME(sc),
	    letoh16(pfp->max_posted_cmd_buffers));

a1527 8
	DNPRINTF(MPII_D_MISC, "%s: IOC page 1\n", DEVNAME(sc));
	DNPRINTF(MPII_D_MISC, "%s:  flags: 0x08%x\n", DEVNAME(sc),
	    letoh32(pg.flags));
	DNPRINTF(MPII_D_MISC, "%s:  coalescing_timeout: %d\n", DEVNAME(sc),
	    letoh32(pg.coalescing_timeout));
	DNPRINTF(MPII_D_MISC, "%s:  coalescing_depth: %d pci_slot_num: %d\n",
	    DEVNAME(sc), pg.coalescing_timeout, pg.pci_slot_num);

d1929 55
@


1.52
log
@split the definitions of the hardware out into a separate file so it can
be reused by a driver for the recent megaraid sas fusion boards.

mikeb was also interested in doing this a while back to make working on
mpii.c easier.

ok by mikeb@@ haesbaert@@ deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.51 2012/04/11 13:29:14 naddy Exp $	*/
d292 1
a292 1
struct mpii_dmamem 	*mpii_dmamem_alloc(struct mpii_softc *, size_t);
d630 1
a630 1
     	    0, sc->sc_reply_free_qdepth * 4, BUS_DMASYNC_POSTREAD);
d1002 1
a1002 1
	
d1051 1
a1051 1
	
d1054 1
a1054 1
		if ((mpii_read(sc, MPII_HOSTDIAG) & 
d1163 1
a1163 1
	
d1166 1
a1166 1
	 
d1220 1
a1220 1
	DNPRINTF(MPII_D_MISC, "%s:  productid: 0x%04x requestcredit: 0x%04x\n", 
d1230 1
a1230 1
	DNPRINTF(MPII_D_MISC, "%s:  maxtargets: 0x%04x " 
d1332 1
a1332 1
	
d1345 1
a1345 1
	iiq.reply_descriptor_post_queue_depth = 
d1349 1
a1349 1
	
d1357 1
a1357 1
	iiq.system_request_frame_base_address = 
d1381 1
a1381 1
	DNPRINTF(MPII_D_MISC, "%s:  msg_flags: 0x%02x\n", DEVNAME(sc), 
d1728 1
a1728 1
				    	    "device structure\n", DEVNAME(sc));
d1969 1
a1969 1
 	struct mpii_msg_scsi_task_request	*stq;
d2134 1
a2134 1
	    "msg_length: %d function: 0x%02x\n", DEVNAME(sc), cp->action, 
d2141 1
a2141 1
	    cp->vp_id, cp->vf_id);	
d2192 1
a2192 1
    	    len < page_length * 4)
d2254 1
a2254 1
	    "msg_length: %d function: 0x%02x\n", DEVNAME(sc), cp->action, 
d2272 1
a2272 1
	
d2386 1
a2386 1
	int slot = dev->slot; 	/* initial hint */
d2673 2
a2674 2
	int			i; 
	
d2681 1
a2681 1
	
d2693 1
a2693 1
	sc->sc_reply_postq = 
d2695 1
a2695 1
	if (sc->sc_reply_postq == NULL) 
d2698 2
a2699 2
	
	DNPRINTF(MPII_D_MISC, "%s:  populating reply post descriptor queue\n", 
d2704 2
a2705 2
		DNPRINTF(MPII_D_MISC, "%s:    %d:  0x%08x = 0x%lx\n", 
		    DEVNAME(sc), i, &kva64[i], kva64[i]); 
d3057 1
a3057 1
}        
d3093 1
a3093 1
 	struct mpii_msg_raid_action_reply *rep;
@


1.51
log
@SLIST_REMOVE_NEXT -> SLIST_REMOVE_AFTER for better consistency and
compatibility with FreeBSD/NetBSD.
Also rename SIMPLEQ_REMOVE_NEXT to SIMPLEQ_REMOVE_AFTER.

ok mikeb@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.50 2011/11/03 20:08:49 mikeb Exp $	*/
d46 1
a46 1655
#define MPII_DOORBELL			(0x00)
/* doorbell read bits */
#define MPII_DOORBELL_STATE		(0xf<<28) /* ioc state */
#define  MPII_DOORBELL_STATE_RESET	(0x0<<28)
#define  MPII_DOORBELL_STATE_READY	(0x1<<28)
#define  MPII_DOORBELL_STATE_OPER	(0x2<<28)
#define  MPII_DOORBELL_STATE_FAULT	(0x4<<28)
#define  MPII_DOORBELL_INUSE		(0x1<<27) /* doorbell used */
#define MPII_DOORBELL_WHOINIT		(0x7<<24) /* last to reset ioc */
#define  MPII_DOORBELL_WHOINIT_NOONE	(0x0<<24) /* not initialized */
#define  MPII_DOORBELL_WHOINIT_SYSBIOS	(0x1<<24) /* system bios */
#define  MPII_DOORBELL_WHOINIT_ROMBIOS	(0x2<<24) /* rom bios */
#define  MPII_DOORBELL_WHOINIT_PCIPEER	(0x3<<24) /* pci peer */
#define  MPII_DOORBELL_WHOINIT_DRIVER	(0x4<<24) /* host driver */
#define  MPII_DOORBELL_WHOINIT_MANUFACT	(0x5<<24) /* manufacturing */
#define MPII_DOORBELL_FAULT		(0xffff<<0) /* fault code */
/* doorbell write bits */
#define MPII_DOORBELL_FUNCTION_SHIFT	(24)
#define MPII_DOORBELL_FUNCTION_MASK	(0xff << MPII_DOORBELL_FUNCTION_SHIFT)
#define MPII_DOORBELL_FUNCTION(x)	\
    (((x) << MPII_DOORBELL_FUNCTION_SHIFT) & MPII_DOORBELL_FUNCTION_MASK)
#define MPII_DOORBELL_DWORDS_SHIFT	16
#define MPII_DOORBELL_DWORDS_MASK	(0xff << MPII_DOORBELL_DWORDS_SHIFT)
#define MPII_DOORBELL_DWORDS(x)		\
    (((x) << MPII_DOORBELL_DWORDS_SHIFT) & MPII_DOORBELL_DWORDS_MASK)
#define MPII_DOORBELL_DATA_MASK		(0xffff)

#define MPII_WRITESEQ			(0x04)
#define  MPII_WRITESEQ_KEY_VALUE_MASK	(0x0000000f) /* key value */
#define  MPII_WRITESEQ_FLUSH		(0x00)
#define  MPII_WRITESEQ_1		(0x0f)
#define  MPII_WRITESEQ_2		(0x04)
#define  MPII_WRITESEQ_3		(0x0b)
#define  MPII_WRITESEQ_4		(0x02)
#define  MPII_WRITESEQ_5		(0x07)
#define  MPII_WRITESEQ_6		(0x0d)

#define MPII_HOSTDIAG			(0x08)
#define  MPII_HOSTDIAG_BDS_MASK		(0x00001800) /* boot device select */
#define   MPII_HOSTDIAG_BDS_DEFAULT 	(0<<11)	/* default address map, flash */
#define   MPII_HOSTDIAG_BDS_HCDW	(1<<11)	/* host code and data window */
#define  MPII_HOSTDIAG_CLEARFBS		(1<<10) /* clear flash bad sig */
#define  MPII_HOSTDIAG_FORCE_HCB_ONBOOT (1<<9)	/* force host controlled boot */
#define  MPII_HOSTDIAG_HCB_MODE		(1<<8)	/* host controlled boot mode */
#define  MPII_HOSTDIAG_DWRE		(1<<7) 	/* diag reg write enabled */
#define  MPII_HOSTDIAG_FBS		(1<<6) 	/* flash bad sig */
#define  MPII_HOSTDIAG_RESET_HIST	(1<<5) 	/* reset history */
#define  MPII_HOSTDIAG_DIAGWR_EN	(1<<4) 	/* diagnostic write enabled */
#define  MPII_HOSTDIAG_RESET_ADAPTER	(1<<2) 	/* reset adapter */
#define  MPII_HOSTDIAG_HOLD_IOC_RESET	(1<<1) 	/* hold ioc in reset */
#define  MPII_HOSTDIAG_DIAGMEM_EN	(1<<0) 	/* diag mem enable */

#define MPII_DIAGRWDATA			(0x10)

#define MPII_DIAGRWADDRLOW		(0x14)

#define MPII_DIAGRWADDRHIGH		(0x18)

#define MPII_INTR_STATUS		(0x30)
#define  MPII_INTR_STATUS_SYS2IOCDB	(1<<31) /* ioc written to by host */
#define  MPII_INTR_STATUS_RESET		(1<<30) /* physical ioc reset */
#define  MPII_INTR_STATUS_REPLY		(1<<3)	/* reply message interrupt */
#define  MPII_INTR_STATUS_IOC2SYSDB	(1<<0) 	/* ioc write to doorbell */

#define MPII_INTR_MASK			(0x34)
#define  MPII_INTR_MASK_RESET		(1<<30) /* ioc reset intr mask */
#define  MPII_INTR_MASK_REPLY		(1<<3) 	/* reply message intr mask */
#define  MPII_INTR_MASK_DOORBELL	(1<<0) 	/* doorbell interrupt mask */

#define MPII_DCR_DATA			(0x38)

#define MPII_DCR_ADDRESS		(0x3c)

#define MPII_REPLY_FREE_HOST_INDEX	(0x48)

#define MPII_REPLY_POST_HOST_INDEX	(0x6c)

#define MPII_HCB_SIZE			(0x74)

#define MPII_HCB_ADDRESS_LOW		(0x78)
#define MPII_HCB_ADDRESS_HIGH		(0x7c)

#define MPII_REQ_DESCR_POST_LOW		(0xc0)
#define MPII_REQ_DESCR_POST_HIGH	(0xc4)

/*
 * Scatter Gather Lists
 */

#define MPII_SGE_FL_LAST		(0x1<<31) /* last element in segment */
#define MPII_SGE_FL_EOB			(0x1<<30) /* last element of buffer */
#define MPII_SGE_FL_TYPE		(0x3<<28) /* element type */
 #define MPII_SGE_FL_TYPE_SIMPLE	(0x1<<28) /* simple element */
 #define MPII_SGE_FL_TYPE_CHAIN		(0x3<<28) /* chain element */
 #define MPII_SGE_FL_TYPE_XACTCTX	(0x0<<28) /* transaction context */
#define MPII_SGE_FL_LOCAL		(0x1<<27) /* local address */
#define MPII_SGE_FL_DIR			(0x1<<26) /* direction */
 #define MPII_SGE_FL_DIR_OUT		(0x1<<26)
 #define MPII_SGE_FL_DIR_IN		(0x0<<26)
#define MPII_SGE_FL_SIZE		(0x1<<25) /* address size */
 #define MPII_SGE_FL_SIZE_32		(0x0<<25)
 #define MPII_SGE_FL_SIZE_64		(0x1<<25)
#define MPII_SGE_FL_EOL			(0x1<<24) /* end of list */

struct mpii_sge {
	u_int32_t		sg_hdr;
	u_int32_t		sg_lo_addr;
	u_int32_t		sg_hi_addr;
} __packed;

struct mpii_fw_tce {
	u_int8_t		reserved1;
	u_int8_t		context_size;
	u_int8_t		details_length;
	u_int8_t		flags;

	u_int32_t		reserved2;

	u_int32_t		image_offset;

	u_int32_t		image_size;
} __packed;

/*
 * Messages
 */

/* functions */
#define MPII_FUNCTION_SCSI_IO_REQUEST			(0x00)
#define MPII_FUNCTION_SCSI_TASK_MGMT			(0x01)
#define MPII_FUNCTION_IOC_INIT				(0x02)
#define MPII_FUNCTION_IOC_FACTS				(0x03)
#define MPII_FUNCTION_CONFIG				(0x04)
#define MPII_FUNCTION_PORT_FACTS			(0x05)
#define MPII_FUNCTION_PORT_ENABLE			(0x06)
#define MPII_FUNCTION_EVENT_NOTIFICATION		(0x07)
#define MPII_FUNCTION_EVENT_ACK				(0x08)
#define MPII_FUNCTION_FW_DOWNLOAD			(0x09)
#define MPII_FUNCTION_TARGET_CMD_BUFFER_POST		(0x0a)
#define MPII_FUNCTION_TARGET_ASSIST			(0x0b)
#define MPII_FUNCTION_TARGET_STATUS_SEND		(0x0c)
#define MPII_FUNCTION_TARGET_MODE_ABORT			(0x0d)
#define MPII_FUNCTION_FW_UPLOAD				(0x12)

#define MPII_FUNCTION_RAID_ACTION			(0x15)
#define MPII_FUNCTION_RAID_SCSI_IO_PASSTHROUGH		(0x16)

#define MPII_FUNCTION_TOOLBOX				(0x17)

#define MPII_FUNCTION_SCSI_ENCLOSURE_PROCESSOR		(0x18)

#define MPII_FUNCTION_SMP_PASSTHROUGH			(0x1a)
#define MPII_FUNCTION_SAS_IO_UNIT_CONTROL		(0x1b)
#define MPII_FUNCTION_SATA_PASSTHROUGH			(0x1c)

#define MPII_FUNCTION_DIAG_BUFFER_POST			(0x1d)
#define MPII_FUNCTION_DIAG_RELEASE			(0x1e)

#define MPII_FUNCTION_TARGET_CMD_BUF_BASE_POST		(0x24)
#define MPII_FUNCTION_TARGET_CMD_BUF_LIST_POST		(0x25)

#define MPII_FUNCTION_IOC_MESSAGE_UNIT_RESET		(0x40)
#define MPII_FUNCTION_IO_UNIT_RESET			(0x41)
#define MPII_FUNCTION_HANDSHAKE				(0x42)

/* Common IOCStatus values for all replies */
#define MPII_IOCSTATUS_MASK				(0x7fff)
#define  MPII_IOCSTATUS_SUCCESS				(0x0000)
#define  MPII_IOCSTATUS_INVALID_FUNCTION		(0x0001)
#define  MPII_IOCSTATUS_BUSY				(0x0002)
#define  MPII_IOCSTATUS_INVALID_SGL			(0x0003)
#define  MPII_IOCSTATUS_INTERNAL_ERROR			(0x0004)
#define  MPII_IOCSTATUS_INVALID_VPID			(0x0005)
#define  MPII_IOCSTATUS_INSUFFICIENT_RESOURCES		(0x0006)
#define  MPII_IOCSTATUS_INVALID_FIELD			(0x0007)
#define  MPII_IOCSTATUS_INVALID_STATE			(0x0008)
#define  MPII_IOCSTATUS_OP_STATE_NOT_SUPPORTED		(0x0009)
/* Config IOCStatus values */
#define  MPII_IOCSTATUS_CONFIG_INVALID_ACTION		(0x0020)
#define  MPII_IOCSTATUS_CONFIG_INVALID_TYPE		(0x0021)
#define  MPII_IOCSTATUS_CONFIG_INVALID_PAGE		(0x0022)
#define  MPII_IOCSTATUS_CONFIG_INVALID_DATA		(0x0023)
#define  MPII_IOCSTATUS_CONFIG_NO_DEFAULTS		(0x0024)
#define  MPII_IOCSTATUS_CONFIG_CANT_COMMIT		(0x0025)
/* SCSIIO Reply initiator values */
#define  MPII_IOCSTATUS_SCSI_RECOVERED_ERROR		(0x0040)
#define  MPII_IOCSTATUS_SCSI_INVALID_DEVHANDLE		(0x0042)
#define  MPII_IOCSTATUS_SCSI_DEVICE_NOT_THERE		(0x0043)
#define  MPII_IOCSTATUS_SCSI_DATA_OVERRUN		(0x0044)
#define  MPII_IOCSTATUS_SCSI_DATA_UNDERRUN		(0x0045)
#define  MPII_IOCSTATUS_SCSI_IO_DATA_ERROR		(0x0046)
#define  MPII_IOCSTATUS_SCSI_PROTOCOL_ERROR		(0x0047)
#define  MPII_IOCSTATUS_SCSI_TASK_TERMINATED		(0x0048)
#define  MPII_IOCSTATUS_SCSI_RESIDUAL_MISMATCH		(0x0049)
#define  MPII_IOCSTATUS_SCSI_TASK_MGMT_FAILED		(0x004a)
#define  MPII_IOCSTATUS_SCSI_IOC_TERMINATED		(0x004b)
#define  MPII_IOCSTATUS_SCSI_EXT_TERMINATED		(0x004c)
/* For use by SCSI Initiator and SCSI Target end-to-end data protection */
#define  MPII_IOCSTATUS_EEDP_GUARD_ERROR		(0x004d)
#define  MPII_IOCSTATUS_EEDP_REF_TAG_ERROR		(0x004e)
#define  MPII_IOCSTATUS_EEDP_APP_TAG_ERROR		(0x004f)
/* SCSI (SPI & FCP) target values */
#define  MPII_IOCSTATUS_TARGET_INVALID_IO_INDEX		(0x0062)
#define  MPII_IOCSTATUS_TARGET_ABORTED			(0x0063)
#define  MPII_IOCSTATUS_TARGET_NO_CONN_RETRYABLE	(0x0064)
#define  MPII_IOCSTATUS_TARGET_NO_CONNECTION		(0x0065)
#define  MPII_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH	(0x006a)
#define  MPII_IOCSTATUS_TARGET_DATA_OFFSET_ERROR	(0x006d)
#define  MPII_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA	(0x006e)
#define  MPII_IOCSTATUS_TARGET_IU_TOO_SHORT		(0x006f)
#define  MPII_IOCSTATUS_TARGET_ACK_NAK_TIMEOUT		(0x0070)
#define  MPII_IOCSTATUS_TARGET_NAK_RECEIVED		(0x0071)
/* Serial Attached SCSI values */
#define  MPII_IOCSTATUS_SAS_SMP_REQUEST_FAILED		(0x0090)
#define  MPII_IOCSTATUS_SAS_SMP_DATA_OVERRUN		(0x0091)
/* Diagnostic Tools values */
#define  MPII_IOCSTATUS_DIAGNOSTIC_RELEASED		(0x00a0)

#define MPII_REP_IOCLOGINFO_TYPE			(0xf<<28)
#define MPII_REP_IOCLOGINFO_TYPE_NONE			(0x0<<28)
#define MPII_REP_IOCLOGINFO_TYPE_SCSI			(0x1<<28)
#define MPII_REP_IOCLOGINFO_TYPE_FC			(0x2<<28)
#define MPII_REP_IOCLOGINFO_TYPE_SAS			(0x3<<28)
#define MPII_REP_IOCLOGINFO_TYPE_ISCSI			(0x4<<28)
#define MPII_REP_IOCLOGINFO_DATA			(0x0fffffff)

/* event notification types */
#define MPII_EVENT_NONE					(0x00)
#define MPII_EVENT_LOG_DATA				(0x01)
#define MPII_EVENT_STATE_CHANGE				(0x02)
#define MPII_EVENT_HARD_RESET_RECEIVED			(0x05)
#define MPII_EVENT_EVENT_CHANGE				(0x0a)
#define MPII_EVENT_TASK_SET_FULL			(0x0e)
#define MPII_EVENT_SAS_DEVICE_STATUS_CHANGE		(0x0f)
#define MPII_EVENT_IR_OPERATION_STATUS			(0x14)
#define MPII_EVENT_SAS_DISCOVERY			(0x16)
#define MPII_EVENT_SAS_BROADCAST_PRIMITIVE		(0x17)
#define MPII_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE	(0x18)
#define MPII_EVENT_SAS_INIT_TABLE_OVERFLOW		(0x19)
#define MPII_EVENT_SAS_TOPOLOGY_CHANGE_LIST		(0x1c)
#define MPII_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE	(0x1d)
#define MPII_EVENT_IR_VOLUME				(0x1e)
#define MPII_EVENT_IR_PHYSICAL_DISK			(0x1f)
#define MPII_EVENT_IR_CONFIGURATION_CHANGE_LIST		(0x20)
#define MPII_EVENT_LOG_ENTRY_ADDED			(0x21)

/* messages */

#define MPII_WHOINIT_NOONE				(0x00)
#define MPII_WHOINIT_SYSTEM_BIOS			(0x01)
#define MPII_WHOINIT_ROM_BIOS				(0x02)
#define MPII_WHOINIT_PCI_PEER				(0x03)
#define MPII_WHOINIT_HOST_DRIVER			(0x04)
#define MPII_WHOINIT_MANUFACTURER			(0x05)

/* default messages */

struct mpii_msg_request {
	u_int8_t		reserved1;
	u_int8_t		reserved2;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int8_t		reserved3;
	u_int8_t		reserved4;
	u_int8_t		reserved5;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved6;
} __packed;

struct mpii_msg_reply {
	u_int16_t		reserved1;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int16_t		reserved2;
	u_int8_t		reserved3;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_if;
	u_int16_t		reserved4;
	
	u_int16_t		reserved5;
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;
} __packed;

/* ioc init */

struct mpii_msg_iocinit_request {
	u_int8_t		whoinit;
	u_int8_t		reserved1;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int16_t		reserved2;
	u_int8_t		reserved3;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved4;

	u_int8_t		msg_version_min;
	u_int8_t		msg_version_maj;
	u_int8_t		hdr_version_unit;
	u_int8_t		hdr_version_dev;

	u_int32_t		reserved5;

	u_int32_t		reserved6;

	u_int16_t		reserved7;
	u_int16_t		system_request_frame_size;

	u_int16_t		reply_descriptor_post_queue_depth;
	u_int16_t		reply_free_queue_depth;

	u_int32_t		sense_buffer_address_high;

	u_int32_t		system_reply_address_high;

	u_int64_t		system_request_frame_base_address;

	u_int64_t		reply_descriptor_post_queue_address;

	u_int64_t		reply_free_queue_address;

	u_int64_t		timestamp;
} __packed;

struct mpii_msg_iocinit_reply {
	u_int8_t		whoinit;
	u_int8_t		reserved1;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int16_t		reserved2;
	u_int8_t		reserved3;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved4;

	u_int16_t		reserved5;
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;
} __packed;

struct mpii_msg_iocfacts_request {
	u_int16_t		reserved1;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int16_t		reserved2;
	u_int8_t		reserved3;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved4;
} __packed;

struct mpii_msg_iocfacts_reply {
	u_int8_t		msg_version_min;
	u_int8_t		msg_version_maj;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int8_t		header_version_dev;
	u_int8_t		header_version_unit;
	u_int8_t		ioc_number;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved1;

	u_int16_t		ioc_exceptions;
#define MPII_IOCFACTS_EXCEPT_CONFIG_CHECKSUM_FAIL	(1<<0)
#define MPII_IOCFACTS_EXCEPT_RAID_CONFIG_INVALID	(1<<1)
#define MPII_IOCFACTS_EXCEPT_FW_CHECKSUM_FAIL		(1<<2)
#define MPII_IOCFACTS_EXCEPT_MANUFACT_CHECKSUM_FAIL	(1<<3)
#define MPII_IOCFACTS_EXCEPT_METADATA_UNSUPPORTED	(1<<4)
#define MPII_IOCFACTS_EXCEPT_IR_FOREIGN_CONFIG_MAC	(1<<8)
	/* XXX JPG BOOT_STATUS in bits[7:5] */
	/* XXX JPG all these #defines need to be fixed up */
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;

	u_int8_t		max_chain_depth;
	u_int8_t		whoinit;
	u_int8_t		number_of_ports;
	u_int8_t		reserved2;

	u_int16_t		request_credit;
	u_int16_t		product_id;

	u_int32_t		ioc_capabilities;
#define MPII_IOCFACTS_CAPABILITY_EVENT_REPLAY           (1<<13)
#define MPII_IOCFACTS_CAPABILITY_INTEGRATED_RAID        (1<<12)
#define MPII_IOCFACTS_CAPABILITY_TLR                    (1<<11)
#define MPII_IOCFACTS_CAPABILITY_MULTICAST              (1<<8)
#define MPII_IOCFACTS_CAPABILITY_BIDIRECTIONAL_TARGET   (1<<7)
#define MPII_IOCFACTS_CAPABILITY_EEDP                   (1<<6)
#define MPII_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER        (1<<4)
#define MPII_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER      (1<<3)
#define MPII_IOCFACTS_CAPABILITY_TASK_SET_FULL_HANDLING (1<<2)

	u_int8_t		fw_version_dev;
	u_int8_t		fw_version_unit;
	u_int8_t		fw_version_min;
	u_int8_t		fw_version_maj;

	u_int16_t		ioc_request_frame_size;
	u_int16_t		reserved3;

	u_int16_t		max_initiators;
	u_int16_t		max_targets;

	u_int16_t		max_sas_expanders;
	u_int16_t		max_enclosures;

	u_int16_t		protocol_flags;
	u_int16_t		high_priority_credit;

	u_int16_t		max_reply_descriptor_post_queue_depth;
	u_int8_t		reply_frame_size;
	u_int8_t		max_volumes;

	u_int16_t		max_dev_handle;
	u_int16_t		max_persistent_entries;

	u_int32_t		reserved4;
} __packed;

struct mpii_msg_portfacts_request {
	u_int16_t		reserved1;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int16_t		reserved2;
	u_int8_t		port_number;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved3;
} __packed;

struct mpii_msg_portfacts_reply {
	u_int16_t		reserved1;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int16_t		reserved2;
	u_int8_t		port_number;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved3;

	u_int16_t		reserved4;
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;

	u_int8_t		reserved5;
	u_int8_t		port_type;
#define MPII_PORTFACTS_PORTTYPE_INACTIVE		(0x00)
#define MPII_PORTFACTS_PORTTYPE_FC			(0x10)
#define MPII_PORTFACTS_PORTTYPE_ISCSI			(0x20)
#define MPII_PORTFACTS_PORTTYPE_SAS_PHYSICAL		(0x30)
#define MPII_PORTFACTS_PORTTYPE_SAS_VIRTUAL		(0x31)
	u_int16_t		reserved6;

	u_int16_t		max_posted_cmd_buffers;
	u_int16_t		reserved7;
} __packed;

struct mpii_msg_portenable_request {
	u_int16_t		reserved1;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int8_t		reserved2;
	u_int8_t		port_flags;	
	u_int8_t		reserved3;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved4;
} __packed;

struct mpii_msg_portenable_reply {
	u_int16_t		reserved1;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int8_t		reserved2;
	u_int8_t		port_flags;
	u_int8_t		reserved3;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved4;

	u_int16_t		reserved5;
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;
} __packed;

struct mpii_msg_event_request {
	u_int16_t		reserved1;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int16_t		reserved2;
	u_int8_t		reserved3;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved4;

	u_int32_t		reserved5;

	u_int32_t		reserved6;

	u_int32_t		event_masks[4];
	
	u_int16_t		sas_broadcase_primitive_masks;
	u_int16_t		reserved7;

	u_int32_t		reserved8;
} __packed;

struct mpii_msg_event_reply {
	u_int16_t		event_data_length;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int16_t		reserved1;
	u_int8_t		ack_required;
#define MPII_EVENT_ACK_REQUIRED				(0x01)
	u_int8_t		msg_flags;
#define MPII_EVENT_FLAGS_REPLY_KEPT			(1<<7)

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved2;

	u_int16_t		reserved3;
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;

	u_int16_t		event;
	u_int16_t		reserved4;

	u_int32_t		event_context;

	/* event data follows */
} __packed;

struct mpii_msg_eventack_request {
	u_int16_t		reserved1;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int8_t		reserved2[3];
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved3;

	u_int16_t		event;
	u_int16_t		reserved4;

	u_int32_t		event_context;
} __packed;

struct mpii_msg_eventack_reply {
	u_int16_t		reserved1;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int8_t		reserved2[3];
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved3;

	u_int16_t		reserved4;
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;
} __packed;

struct mpii_msg_fwupload_request {
	u_int8_t		image_type;
#define MPII_FWUPLOAD_IMAGETYPE_IOC_FW			(0x00)
#define MPII_FWUPLOAD_IMAGETYPE_NV_FW			(0x01)
#define MPII_FWUPLOAD_IMAGETYPE_NV_BACKUP		(0x05)
#define MPII_FWUPLOAD_IMAGETYPE_NV_MANUFACTURING	(0x06)
#define MPII_FWUPLOAD_IMAGETYPE_NV_CONFIG_1		(0x07)
#define MPII_FWUPLOAD_IMAGETYPE_NV_CONFIG_2		(0x08)
#define MPII_FWUPLOAD_IMAGETYPE_NV_MEGARAID		(0x09)
#define MPII_FWUPLOAD_IMAGETYPE_NV_COMPLETE		(0x0a)
#define MPII_FWUPLOAD_IMAGETYPE_COMMON_BOOT_BLOCK	(0x0b)
	u_int8_t		reserved1;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int8_t		reserved2[3];
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved3;

	u_int32_t		reserved4;

	u_int32_t		reserved5;

	struct mpii_fw_tce	tce;

	/* followed by an sgl */
} __packed;

struct mpii_msg_fwupload_reply {
	u_int8_t		image_type;
	u_int8_t		reserved1;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int8_t		reserved2[3];
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved3;

	u_int16_t		reserved4;
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;

	u_int32_t		actual_image_size;
} __packed;

struct mpii_msg_scsi_io {
	u_int16_t		dev_handle;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int16_t		reserved1;
	u_int8_t		reserved2;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved3;
	
	u_int32_t		sense_buffer_low_address;

	u_int16_t		sgl_flags;
	u_int8_t		sense_buffer_length;
	u_int8_t		reserved4;

	u_int8_t		sgl_offset0;
	u_int8_t		sgl_offset1;
	u_int8_t		sgl_offset2;
	u_int8_t		sgl_offset3;

	u_int32_t		skip_count;

	u_int32_t		data_length;

	u_int32_t		bidirectional_data_length;

	u_int16_t		io_flags;
	u_int16_t		eedp_flags;

	u_int32_t		eedp_block_size;

	u_int32_t		secondary_reference_tag;

	u_int16_t		secondary_application_tag;
	u_int16_t		application_tag_translation_mask;

	u_int16_t		lun[4];

/* the following 16 bits are defined in MPI2 as the control field */
	u_int8_t		reserved5;
	u_int8_t		tagging;
#define MPII_SCSIIO_ATTR_SIMPLE_Q			(0x0)
#define MPII_SCSIIO_ATTR_HEAD_OF_Q			(0x1)
#define MPII_SCSIIO_ATTR_ORDERED_Q			(0x2)
#define MPII_SCSIIO_ATTR_ACA_Q				(0x4)
#define MPII_SCSIIO_ATTR_UNTAGGED			(0x5)
#define MPII_SCSIIO_ATTR_NO_DISCONNECT			(0x7)
	u_int8_t		reserved6;
	u_int8_t		direction;
#define MPII_SCSIIO_DIR_NONE				(0x0)
#define MPII_SCSIIO_DIR_WRITE				(0x1)
#define MPII_SCSIIO_DIR_READ				(0x2)

#define	MPII_CDB_LEN					(32)
	u_int8_t		cdb[MPII_CDB_LEN];

	/* followed by an sgl */
} __packed;

struct mpii_msg_scsi_io_error {
	u_int16_t		dev_handle;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int16_t		reserved1;
	u_int8_t		reserved2;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved3;

	u_int8_t		scsi_status;
	/* XXX JPG validate this */
#if notyet
#define MPII_SCSIIO_ERR_STATUS_SUCCESS
#define MPII_SCSIIO_ERR_STATUS_CHECK_COND
#define MPII_SCSIIO_ERR_STATUS_BUSY
#define MPII_SCSIIO_ERR_STATUS_INTERMEDIATE
#define MPII_SCSIIO_ERR_STATUS_INTERMEDIATE_CONDMET
#define MPII_SCSIIO_ERR_STATUS_RESERVATION_CONFLICT
#define MPII_SCSIIO_ERR_STATUS_CMD_TERM
#define MPII_SCSIIO_ERR_STATUS_TASK_SET_FULL
#define MPII_SCSIIO_ERR_STATUS_ACA_ACTIVE
#endif
	u_int8_t		scsi_state;
#define MPII_SCSIIO_ERR_STATE_AUTOSENSE_VALID		(1<<0)
#define MPII_SCSIIO_ERR_STATE_AUTOSENSE_FAILED		(1<<1)
#define MPII_SCSIIO_ERR_STATE_NO_SCSI_STATUS		(1<<2)
#define MPII_SCSIIO_ERR_STATE_TERMINATED		(1<<3)
#define MPII_SCSIIO_ERR_STATE_RESPONSE_INFO_VALID	(1<<4)
#define MPII_SCSIIO_ERR_STATE_QUEUE_TAG_REJECTED	(0xffff)
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;

	u_int32_t		transfer_count;

	u_int32_t		sense_count;

	u_int32_t		response_info;

	u_int16_t		task_tag;
	u_int16_t		reserved4;

	u_int32_t		bidirectional_transfer_count;

	u_int32_t		reserved5;

	u_int32_t		reserved6;
} __packed;

struct mpii_request_descr {
	u_int8_t		request_flags;
#define MPII_REQ_DESCR_TYPE_MASK			(0x0e)
#define MPII_REQ_DESCR_SCSI_IO				(0x00)
#define MPII_REQ_DESCR_SCSI_TARGET			(0x02)
#define MPII_REQ_DESCR_HIGH_PRIORITY			(0x06)
#define MPII_REQ_DESCR_DEFAULT				(0x08)
	u_int8_t		vf_id;
	u_int16_t		smid;

	u_int16_t		lmid;
	u_int16_t		dev_handle;
} __packed;

struct mpii_reply_descr {
	u_int8_t		reply_flags;
#define MPII_REPLY_DESCR_TYPE_MASK               	(0x0f)
#define MPII_REPLY_DESCR_SCSI_IO_SUCCESS         	(0x00)
#define MPII_REPLY_DESCR_ADDRESS_REPLY           	(0x01)
#define MPII_REPLY_DESCR_TARGET_ASSIST_SUCCESS    	(0x02)
#define MPII_REPLY_DESCR_TARGET_COMMAND_BUFFER   	(0x03)
#define MPII_REPLY_DESCR_UNUSED                  	(0x0f)
	u_int8_t		vf_id;
	u_int16_t		smid;

	union {
		u_int32_t	data;
		u_int32_t	frame_addr;	/* Address Reply */
	};
} __packed;

struct mpii_request_header {
	u_int16_t		function_dependent1;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int16_t		function_dependent2;
	u_int8_t		function_dependent3;
	u_int8_t		message_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved;
} __packed;

struct mpii_msg_scsi_task_request {
	u_int16_t		dev_handle;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int8_t		reserved1;
	u_int8_t		task_type;
#define MPII_SCSI_TASK_ABORT_TASK			(0x01)
#define MPII_SCSI_TASK_ABRT_TASK_SET			(0x02)
#define MPII_SCSI_TASK_TARGET_RESET			(0x03)
#define MPII_SCSI_TASK_RESET_BUS			(0x04)
#define MPII_SCSI_TASK_LOGICAL_UNIT_RESET		(0x05)
	u_int8_t		reserved2;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved3;

	u_int16_t		lun[4];

	u_int32_t		reserved4[7];

	u_int16_t		task_mid;
	u_int16_t		reserved5;
} __packed;

struct mpii_msg_scsi_task_reply {
	u_int16_t		dev_handle;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int8_t		response_code;
	u_int8_t		task_type;
	u_int8_t		reserved1;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved2;

	u_int16_t		reserved3;
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;

	u_int32_t		termination_count;
} __packed;

struct mpii_msg_sas_oper_request {
	u_int8_t		operation;
#define MPII_SAS_OP_CLEAR_PERSISTENT		(0x02)
#define MPII_SAS_OP_PHY_LINK_RESET		(0x06)
#define MPII_SAS_OP_PHY_HARD_RESET		(0x07)
#define MPII_SAS_OP_PHY_CLEAR_ERROR_LOG		(0x08)
#define MPII_SAS_OP_SEND_PRIMITIVE		(0x0a)
#define MPII_SAS_OP_FORCE_FULL_DISCOVERY	(0x0b)
#define MPII_SAS_OP_TRANSMIT_PORT_SELECT	(0x0c)
#define MPII_SAS_OP_REMOVE_DEVICE		(0x0d)
#define MPII_SAS_OP_LOOKUP_MAPPING		(0x0e)
#define MPII_SAS_OP_SET_IOC_PARAM		(0x0f)
	u_int8_t		reserved1;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int16_t		dev_handle;
	u_int8_t		ioc_param;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved2;

	u_int16_t		reserved3;
	u_int8_t		phy_num;
	u_int8_t		prim_flags;

	u_int32_t		primitive;

	u_int8_t		lookup_method;
#define MPII_SAS_LOOKUP_METHOD_SAS_ADDR		(0x01)
#define MPII_SAS_LOOKUP_METHOD_SAS_ENCL		(0x02)
#define MPII_SAS_LOOKUP_METHOD_SAS_DEVNAME	(0x03)
	u_int8_t		reserved4;
	u_int16_t		slot_num;

	u_int64_t		lookup_addr;

	u_int32_t		ioc_param_value;

	u_int64_t		reserved5;
} __packed;

struct mpii_msg_sas_oper_reply {
	u_int8_t		operation;
	u_int8_t		reserved1;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int16_t		dev_handle;
	u_int8_t		ioc_param;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved2;

	u_int16_t		reserved3;
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;
} __packed;

struct mpii_msg_raid_action_request {
	u_int8_t	action;
#define MPII_RAID_ACTION_CHANGE_VOL_WRITE_CACHE	(0x17)
	u_int8_t	reserved1;
	u_int8_t	chain_offset;
	u_int8_t	function;

	u_int16_t	vol_dev_handle;
	u_int8_t	phys_disk_num;
	u_int8_t	msg_flags;

	u_int8_t	vp_id;
	u_int8_t	vf_if;
	u_int16_t	reserved2;

	u_int32_t	reserved3;

	u_int32_t	action_data;
#define MPII_RAID_VOL_WRITE_CACHE_MASK			(0x03)
#define MPII_RAID_VOL_WRITE_CACHE_DISABLE		(0x01)
#define MPII_RAID_VOL_WRITE_CACHE_ENABLE		(0x02)

	struct mpii_sge	action_sge;
} __packed;

struct mpii_msg_raid_action_reply {
	u_int8_t	action;
	u_int8_t	reserved1;
	u_int8_t	chain_offset;
	u_int8_t	function;

	u_int16_t	vol_dev_handle;
	u_int8_t	phys_disk_num;
	u_int8_t	msg_flags;

	u_int8_t	vp_id;
	u_int8_t	vf_if;
	u_int16_t	reserved2;

	u_int16_t	reserved3;
	u_int16_t	ioc_status;

	u_int32_t	action_data[5];
} __packed;

struct mpii_cfg_hdr {
	u_int8_t		page_version;
	u_int8_t		page_length;
	u_int8_t		page_number;
	u_int8_t		page_type;
#define MPII_CONFIG_REQ_PAGE_TYPE_ATTRIBUTE		(0xf0)
#define MPI2_CONFIG_PAGEATTR_READ_ONLY              	(0x00)
#define MPI2_CONFIG_PAGEATTR_CHANGEABLE             	(0x10)
#define MPI2_CONFIG_PAGEATTR_PERSISTENT             	(0x20)

#define MPII_CONFIG_REQ_PAGE_TYPE_MASK			(0x0f)
#define MPII_CONFIG_REQ_PAGE_TYPE_IO_UNIT		(0x00)
#define MPII_CONFIG_REQ_PAGE_TYPE_IOC			(0x01)
#define MPII_CONFIG_REQ_PAGE_TYPE_BIOS			(0x02)
#define MPII_CONFIG_REQ_PAGE_TYPE_RAID_VOL		(0x08)
#define MPII_CONFIG_REQ_PAGE_TYPE_MANUFACTURING		(0x09)
#define MPII_CONFIG_REQ_PAGE_TYPE_RAID_PD		(0x0a)
#define MPII_CONFIG_REQ_PAGE_TYPE_EXTENDED		(0x0f)
} __packed;

struct mpii_ecfg_hdr {
	u_int8_t		page_version;
	u_int8_t		reserved1;
	u_int8_t		page_number;
	u_int8_t		page_type;

	u_int16_t		ext_page_length;
	u_int8_t		ext_page_type;
#define MPII_CONFIG_REQ_PAGE_TYPE_SAS_DEVICE		(0x12)
#define MPII_CONFIG_REQ_PAGE_TYPE_RAID_CONFIG		(0x16)
#define MPII_CONFIG_REQ_PAGE_TYPE_DRIVER_MAPPING	(0x17)
	u_int8_t		reserved2;
} __packed;

struct mpii_msg_config_request {
	u_int8_t		action;
#define MPII_CONFIG_REQ_ACTION_PAGE_HEADER		(0x00)
#define MPII_CONFIG_REQ_ACTION_PAGE_READ_CURRENT	(0x01)
#define MPII_CONFIG_REQ_ACTION_PAGE_WRITE_CURRENT	(0x02)
#define MPII_CONFIG_REQ_ACTION_PAGE_DEFAULT		(0x03)
#define MPII_CONFIG_REQ_ACTION_PAGE_WRITE_NVRAM		(0x04)
#define MPII_CONFIG_REQ_ACTION_PAGE_READ_DEFAULT	(0x05)
#define MPII_CONFIG_REQ_ACTION_PAGE_READ_NVRAM		(0x06)
	u_int8_t		sgl_flags;
	u_int8_t		chain_offset;
	u_int8_t		function;

	u_int16_t		ext_page_len;
	u_int8_t		ext_page_type;
#define MPII_CONFIG_REQ_EXTPAGE_TYPE_SAS_IO_UNIT	(0x10)
#define MPII_CONFIG_REQ_EXTPAGE_TYPE_SAS_EXPANDER	(0x11)
#define MPII_CONFIG_REQ_EXTPAGE_TYPE_SAS_DEVICE		(0x12)
#define MPII_CONFIG_REQ_EXTPAGE_TYPE_SAS_PHY		(0x13)
#define MPII_CONFIG_REQ_EXTPAGE_TYPE_LOG		(0x14)
#define MPI2_CONFIG_EXTPAGETYPE_ENCLOSURE            	(0x15)
#define MPI2_CONFIG_EXTPAGETYPE_RAID_CONFIG         	(0x16)
#define MPI2_CONFIG_EXTPAGETYPE_DRIVER_MAPPING      	(0x17)
#define MPI2_CONFIG_EXTPAGETYPE_SAS_PORT            	(0x18)
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved1;

	u_int32_t		reserved2[2];

	struct mpii_cfg_hdr	config_header;

	u_int32_t		page_address;
/* XXX lots of defns here */

	struct mpii_sge		page_buffer;
} __packed;

struct mpii_msg_config_reply {
	u_int8_t		action;
	u_int8_t		sgl_flags;
	u_int8_t		msg_length;
	u_int8_t		function;

	u_int16_t		ext_page_length;
	u_int8_t		ext_page_type;
	u_int8_t		msg_flags;

	u_int8_t		vp_id;
	u_int8_t		vf_id;
	u_int16_t		reserved1;

	u_int16_t		reserved2;
	u_int16_t		ioc_status;

	u_int32_t		ioc_loginfo;

	struct mpii_cfg_hdr	config_header;
} __packed;

struct mpii_cfg_manufacturing_pg0 {
	struct mpii_cfg_hdr	config_header;

	char			chip_name[16];
	char			chip_revision[8];
	char			board_name[16];
	char			board_assembly[16];
	char			board_tracer_number[16];
} __packed;

struct mpii_cfg_ioc_pg1 {
	struct mpii_cfg_hdr     config_header;

	u_int32_t       flags;

	u_int32_t       coalescing_timeout;
#define	MPII_CFG_IOC_1_REPLY_COALESCING			(1<<0)

	u_int8_t        coalescing_depth;
	u_int8_t        pci_slot_num;
	u_int8_t        pci_bus_num;
	u_int8_t        pci_domain_segment;

	u_int32_t       reserved1;

	u_int32_t       reserved2;
} __packed;

struct mpii_cfg_ioc_pg3 {
	struct mpii_cfg_hdr	config_header;

	u_int8_t		no_phys_disks;
	u_int8_t		reserved[3];

	/* followed by a list of mpii_cfg_raid_physdisk structs */
} __packed;

struct mpii_cfg_ioc_pg8 {
	struct mpii_cfg_hdr	config_header;

	u_int8_t		num_devs_per_enclosure;
	u_int8_t		reserved1;
	u_int16_t		reserved2;

	u_int16_t		max_persistent_entries;
	u_int16_t		max_num_physical_mapped_ids;

	u_int16_t		flags;
#define	MPII_IOC_PG8_FLAGS_DA_START_SLOT_1		(1<<5)
#define MPII_IOC_PG8_FLAGS_RESERVED_TARGETID_0		(1<<4)
#define MPII_IOC_PG8_FLAGS_MAPPING_MODE_MASK		(0x0000000e)
#define MPII_IOC_PG8_FLAGS_DEVICE_PERSISTENCE_MAPPING	(0<<1)
#define MPII_IOC_PG8_FLAGS_ENCLOSURE_SLOT_MAPPING	(1<<1)
#define MPII_IOC_PG8_FLAGS_DISABLE_PERSISTENT_MAPPING	(1<<0)
#define	MPII_IOC_PG8_FLAGS_ENABLE_PERSISTENT_MAPPING	(0<<0)
	u_int16_t		reserved3;

	u_int16_t		ir_volume_mapping_flags;
#define	MPII_IOC_PG8_IRFLAGS_VOLUME_MAPPING_MODE_MASK	(0x00000003)
#define	MPII_IOC_PG8_IRFLAGS_LOW_VOLUME_MAPPING		(0<<0)
#define	MPII_IOC_PG8_IRFLAGS_HIGH_VOLUME_MAPPING	(1<<0)
	u_int16_t		reserved4;
	
	u_int32_t		reserved5;
} __packed;

struct mpii_cfg_raid_physdisk {
	u_int8_t		phys_disk_id;
	u_int8_t		phys_disk_bus;
	u_int8_t		phys_disk_ioc;
	u_int8_t		phys_disk_num;
} __packed;

struct mpii_cfg_fc_port_pg0 {
	struct mpii_cfg_hdr	config_header;

	u_int32_t		flags;

	u_int8_t		mpii_port_nr;
	u_int8_t		link_type;
	u_int8_t		port_state;
	u_int8_t		reserved1;

	u_int32_t		port_id;

	u_int64_t		wwnn;

	u_int64_t		wwpn;

	u_int32_t		supported_service_class;

	u_int32_t		supported_speeds;

	u_int32_t		current_speed;

	u_int32_t		max_frame_size;

	u_int64_t		fabric_wwnn;

	u_int64_t		fabric_wwpn;

	u_int32_t		discovered_port_count;

	u_int32_t		max_initiators;

	u_int8_t		max_aliases_supported;
	u_int8_t		max_hard_aliases_supported;
	u_int8_t		num_current_aliases;
	u_int8_t		reserved2;
} __packed;

struct mpii_cfg_fc_port_pg1 {
	struct mpii_cfg_hdr	config_header;

	u_int32_t		flags;

	u_int64_t		noseepromwwnn;

	u_int64_t		noseepromwwpn;

	u_int8_t		hard_alpa;
	u_int8_t		link_config;
	u_int8_t		topology_config;
	u_int8_t		alt_connector;

	u_int8_t		num_req_aliases;
	u_int8_t		rr_tov;
	u_int8_t		initiator_dev_to;
	u_int8_t		initiator_lo_pend_to;
} __packed;

struct mpii_cfg_fc_device_pg0 {
	struct mpii_cfg_hdr	config_header;

	u_int64_t		wwnn;

	u_int64_t		wwpn;

	u_int32_t		port_id;

	u_int8_t		protocol;
	u_int8_t		flags;
	u_int16_t		bb_credit;

	u_int16_t		max_rx_frame_size;
	u_int8_t		adisc_hard_alpa;
	u_int8_t		port_nr;

	u_int8_t		fc_ph_low_version;
	u_int8_t		fc_ph_high_version;
	u_int8_t		current_target_id;
	u_int8_t		current_bus;
} __packed;

#define MPII_CFG_RAID_VOL_ADDR_HANDLE		(1<<28)

struct mpii_cfg_raid_vol_pg0 {
	struct mpii_cfg_hdr	config_header;

	u_int16_t		volume_handle;
	u_int8_t		volume_state;
#define MPII_CFG_RAID_VOL_0_STATE_MISSING		(0x00)
#define MPII_CFG_RAID_VOL_0_STATE_FAILED		(0x01)
#define MPII_CFG_RAID_VOL_0_STATE_INITIALIZING		(0x02)
#define MPII_CFG_RAID_VOL_0_STATE_ONLINE		(0x03)
#define MPII_CFG_RAID_VOL_0_STATE_DEGRADED		(0x04)
#define MPII_CFG_RAID_VOL_0_STATE_OPTIMAL		(0x05)
	u_int8_t		volume_type;
#define MPII_CFG_RAID_VOL_0_TYPE_RAID0			(0x00)
#define MPII_CFG_RAID_VOL_0_TYPE_RAID1E			(0x01)
#define MPII_CFG_RAID_VOL_0_TYPE_RAID1			(0x02)
#define MPII_CFG_RAID_VOL_0_TYPE_RAID10			(0x05)
#define MPII_CFG_RAID_VOL_0_TYPE_UNKNOWN		(0xff)

	u_int32_t		volume_status;
#define MPII_CFG_RAID_VOL_0_STATUS_SCRUB		(1<<20)
#define MPII_CFG_RAID_VOL_0_STATUS_RESYNC		(1<<16)

	u_int16_t		volume_settings;
#define MPII_CFG_RAID_VOL_0_SETTINGS_CACHE_MASK		(0x3<<0)
#define MPII_CFG_RAID_VOL_0_SETTINGS_CACHE_UNCHANGED	(0x0<<0)
#define MPII_CFG_RAID_VOL_0_SETTINGS_CACHE_DISABLED	(0x1<<0)
#define MPII_CFG_RAID_VOL_0_SETTINGS_CACHE_ENABLED	(0x2<<0)

	u_int8_t		hot_spare_pool;
	u_int8_t		reserved1;

	u_int64_t		max_lba;

	u_int32_t		stripe_size;

	u_int16_t		block_size;
	u_int16_t		reserved2;

	u_int8_t		phys_disk_types;
	u_int8_t		resync_rate;
	u_int16_t		data_scrub_rate;

	u_int8_t		num_phys_disks;
	u_int16_t		reserved3;
	u_int8_t		inactive_status;
#define MPII_CFG_RAID_VOL_0_INACTIVE_UNKNOWN		(0x00)
#define MPII_CFG_RAID_VOL_0_INACTIVE_STALE_META		(0x01)
#define MPII_CFG_RAID_VOL_0_INACTIVE_FOREIGN_VOL	(0x02)
#define MPII_CFG_RAID_VOL_0_INACTIVE_NO_RESOURCES	(0x03)
#define MPII_CFG_RAID_VOL_0_INACTIVE_CLONED_VOL		(0x04)
#define MPII_CFG_RAID_VOL_0_INACTIVE_INSUF_META		(0x05)

	/* followed by a list of mpii_cfg_raid_vol_pg0_physdisk structs */
} __packed;

struct mpii_cfg_raid_vol_pg0_physdisk {
	u_int8_t		raid_set_num;
	u_int8_t		phys_disk_map;
	u_int8_t		phys_disk_num;
	u_int8_t		reserved;
} __packed;

struct mpii_cfg_raid_vol_pg1 {
	struct mpii_cfg_hdr	config_header;

	u_int8_t		volume_id;
	u_int8_t		volume_bus;
	u_int8_t		volume_ioc;
	u_int8_t		reserved1;

	u_int8_t		guid[24];

	u_int8_t		name[32];

	u_int64_t		wwid;

	u_int32_t		reserved2;

	u_int32_t		reserved3;
} __packed;

#define MPII_CFG_RAID_PHYS_DISK_ADDR_NUMBER		(1<<28)

struct mpii_cfg_raid_physdisk_pg0 {
	struct mpii_cfg_hdr	config_header;

	u_int16_t		dev_handle;
	u_int8_t		reserved1;
	u_int8_t		phys_disk_num;

	u_int8_t		enc_id;
	u_int8_t		enc_bus;
	u_int8_t		hot_spare_pool;
	u_int8_t		enc_type;
#define MPII_CFG_RAID_PHYDISK_0_ENCTYPE_NONE		(0x0)
#define MPII_CFG_RAID_PHYDISK_0_ENCTYPE_SAFTE		(0x1)
#define MPII_CFG_RAID_PHYDISK_0_ENCTYPE_SES		(0x2)

	u_int32_t		reserved2;

	u_int8_t		vendor_id[8];

	u_int8_t		product_id[16];

	u_int8_t		product_rev[4];

	u_int8_t		serial[32];

	u_int32_t		reserved3;

	u_int8_t		phys_disk_state;
#define MPII_CFG_RAID_PHYDISK_0_STATE_NOTCONFIGURED	(0x00)
#define MPII_CFG_RAID_PHYDISK_0_STATE_NOTCOMPATIBLE	(0x01)
#define MPII_CFG_RAID_PHYDISK_0_STATE_OFFLINE		(0x02)
#define MPII_CFG_RAID_PHYDISK_0_STATE_ONLINE		(0x03)
#define MPII_CFG_RAID_PHYDISK_0_STATE_HOTSPARE		(0x04)
#define MPII_CFG_RAID_PHYDISK_0_STATE_DEGRADED		(0x05)
#define MPII_CFG_RAID_PHYDISK_0_STATE_REBUILDING	(0x06)
#define MPII_CFG_RAID_PHYDISK_0_STATE_OPTIMAL		(0x07)
	u_int8_t		offline_reason;
#define MPII_CFG_RAID_PHYDISK_0_OFFLINE_MISSING		(0x01)
#define MPII_CFG_RAID_PHYDISK_0_OFFLINE_FAILED		(0x03)
#define MPII_CFG_RAID_PHYDISK_0_OFFLINE_INITIALIZING	(0x04)
#define MPII_CFG_RAID_PHYDISK_0_OFFLINE_REQUESTED	(0x05)
#define MPII_CFG_RAID_PHYDISK_0_OFFLINE_FAILEDREQ	(0x06)
#define MPII_CFG_RAID_PHYDISK_0_OFFLINE_OTHER		(0xff)

	u_int8_t		incompat_reason;
	u_int8_t		phys_disk_attrs;

	u_int32_t		phys_disk_status;
#define MPII_CFG_RAID_PHYDISK_0_STATUS_OUTOFSYNC	(1<<0)
#define MPII_CFG_RAID_PHYDISK_0_STATUS_QUIESCED		(1<<1)

	u_int64_t		dev_max_lba;

	u_int64_t		host_max_lba;

	u_int64_t		coerced_max_lba;

	u_int16_t		block_size;
	u_int16_t		reserved4;

	u_int32_t		reserved5;
} __packed;

struct mpii_cfg_raid_physdisk_pg1 {
	struct mpii_cfg_hdr	config_header;

	u_int8_t		num_phys_disk_paths;
	u_int8_t		phys_disk_num;
	u_int16_t		reserved1;

	u_int32_t		reserved2;

	/* followed by mpii_cfg_raid_physdisk_path structs */
} __packed;

struct mpii_cfg_raid_physdisk_path {
	u_int8_t		phys_disk_id;
	u_int8_t		phys_disk_bus;
	u_int16_t		reserved1;

	u_int64_t		wwwid;

	u_int64_t		owner_wwid;

	u_int8_t		ownder_id;
	u_int8_t		reserved2;
	u_int16_t		flags;
#define MPII_CFG_RAID_PHYDISK_PATH_INVALID	(1<<0)
#define MPII_CFG_RAID_PHYDISK_PATH_BROKEN	(1<<1)
} __packed;

#define MPII_CFG_SAS_DEV_ADDR_NEXT		(0<<28)
#define MPII_CFG_SAS_DEV_ADDR_BUS		(1<<28)
#define MPII_CFG_SAS_DEV_ADDR_HANDLE		(2<<28)

struct mpii_cfg_sas_dev_pg0 {
	struct mpii_ecfg_hdr	config_header;

	u_int16_t		slot;
	u_int16_t		enc_handle;

	u_int64_t		sas_addr;

	u_int16_t		parent_dev_handle;
	u_int8_t		phy_num;
	u_int8_t		access_status;

	u_int16_t		dev_handle;
	u_int8_t		target;
	u_int8_t		bus;

	u_int32_t		device_info;
#define MPII_CFG_SAS_DEV_0_DEVINFO_TYPE			(0x7)
#define MPII_CFG_SAS_DEV_0_DEVINFO_TYPE_NONE		(0x0)
#define MPII_CFG_SAS_DEV_0_DEVINFO_TYPE_END		(0x1)
#define MPII_CFG_SAS_DEV_0_DEVINFO_TYPE_EDGE_EXPANDER	(0x2)
#define MPII_CFG_SAS_DEV_0_DEVINFO_TYPE_FANOUT_EXPANDER	(0x3)
#define MPII_CFG_SAS_DEV_0_DEVINFO_SATA_HOST		(1<<3)
#define MPII_CFG_SAS_DEV_0_DEVINFO_SMP_INITIATOR	(1<<4)
#define MPII_CFG_SAS_DEV_0_DEVINFO_STP_INITIATOR	(1<<5)
#define MPII_CFG_SAS_DEV_0_DEVINFO_SSP_INITIATOR	(1<<6)
#define MPII_CFG_SAS_DEV_0_DEVINFO_SATA_DEVICE		(1<<7)
#define MPII_CFG_SAS_DEV_0_DEVINFO_SMP_TARGET		(1<<8)
#define MPII_CFG_SAS_DEV_0_DEVINFO_STP_TARGET		(1<<9)
#define MPII_CFG_SAS_DEV_0_DEVINFO_SSP_TARGET		(1<<10)
#define MPII_CFG_SAS_DEV_0_DEVINFO_DIRECT_ATTACHED	(1<<11)
#define MPII_CFG_SAS_DEV_0_DEVINFO_LSI_DEVICE		(1<<12)
#define MPII_CFG_SAS_DEV_0_DEVINFO_ATAPI_DEVICE		(1<<13)
#define MPII_CFG_SAS_DEV_0_DEVINFO_SEP_DEVICE		(1<<14)

	u_int16_t		flags;
#define MPII_CFG_SAS_DEV_0_FLAGS_DEV_PRESENT		(1<<0)
#define MPII_CFG_SAS_DEV_0_FLAGS_DEV_MAPPED		(1<<1)
#define MPII_CFG_SAS_DEV_0_FLAGS_DEV_MAPPED_PERSISTENT	(1<<2)
#define MPII_CFG_SAS_DEV_0_FLAGS_SATA_PORT_SELECTOR	(1<<3)
#define MPII_CFG_SAS_DEV_0_FLAGS_SATA_FUA		(1<<4)
#define MPII_CFG_SAS_DEV_0_FLAGS_SATA_NCQ		(1<<5)
#define MPII_CFG_SAS_DEV_0_FLAGS_SATA_SMART		(1<<6)
#define MPII_CFG_SAS_DEV_0_FLAGS_SATA_LBA48		(1<<7)
#define MPII_CFG_SAS_DEV_0_FLAGS_UNSUPPORTED		(1<<8)
#define MPII_CFG_SAS_DEV_0_FLAGS_SATA_SETTINGS		(1<<9)
	u_int8_t		physical_port;
	u_int8_t		max_port_conn;

	u_int64_t		device_name;

	u_int8_t		port_groups;
	u_int8_t		dma_group;
	u_int8_t		ctrl_group;
	u_int8_t		reserved1;

	u_int64_t		reserved2;
} __packed;

#define MPII_CFG_RAID_CONFIG_ACTIVE_CONFIG		(2<<28)

struct mpii_cfg_raid_config_pg0 {
	struct	mpii_ecfg_hdr	config_header;

	u_int8_t		num_hot_spares;
	u_int8_t		num_phys_disks;
	u_int8_t		num_volumes;
	u_int8_t		config_num;

	u_int32_t		flags;
#define MPII_CFG_RAID_CONFIG_0_FLAGS_NATIVE		(0<<0)
#define MPII_CFG_RAID_CONFIG_0_FLAGS_FOREIGN		(1<<0)

	u_int32_t		config_guid[6];

	u_int32_t		reserved1;

	u_int8_t		num_elements;
	u_int8_t		reserved2[3];

	/* followed by struct mpii_raid_config_element structs */
} __packed;

struct mpii_raid_config_element {
	u_int16_t		element_flags;
#define MPII_RAID_CONFIG_ELEMENT_FLAG_VOLUME		(0x0)
#define MPII_RAID_CONFIG_ELEMENT_FLAG_VOLUME_PHYS_DISK	(0x1)
#define	MPII_RAID_CONFIG_ELEMENT_FLAG_HSP_PHYS_DISK	(0x2)
#define MPII_RAID_CONFIG_ELEMENT_ONLINE_CE_PHYS_DISK	(0x3)
	u_int16_t		vol_dev_handle;

	u_int8_t		hot_spare_pool;
	u_int8_t		phys_disk_num;
	u_int16_t		phys_disk_dev_handle;
} __packed;

struct mpii_cfg_dpm_pg0 {
	struct mpii_ecfg_hdr	config_header;
#define MPII_DPM_ADDRESS_FORM_MASK			(0xf0000000)
#define MPII_DPM_ADDRESS_FORM_ENTRY_RANGE		(0x00000000)
#define MPII_DPM_ADDRESS_ENTRY_COUNT_MASK		(0x0fff0000)
#define MPII_DPM_ADDRESS_ENTRY_COUNT_SHIFT		(16)
#define MPII_DPM_ADDRESS_START_ENTRY_MASK		(0x0000ffff)

	/* followed by struct mpii_dpm_entry structs */
} __packed;

struct mpii_dpm_entry {
	u_int64_t		physical_identifier;

	u_int16_t		mapping_information;
	u_int16_t		device_index;

	u_int32_t		physical_bits_mapping;

	u_int32_t		reserved1;
} __packed;

struct mpii_evt_sas_discovery {
	u_int8_t		flags;
#define	MPII_EVENT_SAS_DISC_FLAGS_DEV_CHANGE_MASK	(1<<1)
#define MPII_EVENT_SAS_DISC_FLAGS_DEV_CHANGE_NO_CHANGE	(0<<1)
#define MPII_EVENT_SAS_DISC_FLAGS_DEV_CHANGE_CHANGE	(1<<1)
#define MPII_EVENT_SAS_DISC_FLAGS_DISC_IN_PROG_MASK	(1<<0)
#define MPII_EVENT_SAS_DISC_FLAGS_DISC_NOT_IN_PROGRESS	(1<<0)
#define MPII_EVENT_SAS_DISC_FLAGS_DISC_IN_PROGRESS	(0<<0)
	u_int8_t		reason_code;
#define MPII_EVENT_SAS_DISC_REASON_CODE_STARTED		(0x01)
#define	MPII_EVENT_SAS_DISC_REASON_CODE_COMPLETED	(0x02)
	u_int8_t		physical_port;
	u_int8_t		reserved1;

	u_int32_t		discovery_status;
} __packed;

struct mpii_evt_ir_status {
	u_int16_t		vol_dev_handle;
	u_int16_t		reserved1;

	u_int8_t		operation;
#define MPII_EVENT_IR_RAIDOP_RESYNC			(0x00)
#define MPII_EVENT_IR_RAIDOP_OCE			(0x01)
#define MPII_EVENT_IR_RAIDOP_CONS_CHECK			(0x02)
#define MPII_EVENT_IR_RAIDOP_BG_INIT			(0x03)
#define MPII_EVENT_IR_RAIDOP_MAKE_CONS			(0x04)
	u_int8_t		percent;
	u_int16_t		reserved2;

	u_int32_t		reserved3;
};

struct mpii_evt_ir_volume {
	u_int16_t		vol_dev_handle;
	u_int8_t		reason_code;
#define MPII_EVENT_IR_VOL_RC_SETTINGS_CHANGED		(0x01)
#define MPII_EVENT_IR_VOL_RC_STATUS_CHANGED		(0x02)
#define MPII_EVENT_IR_VOL_RC_STATE_CHANGED		(0x03)
	u_int8_t		reserved1;

	u_int32_t		new_value;
	u_int32_t		prev_value;
} __packed;

struct mpii_evt_ir_physical_disk {
	u_int16_t		reserved1;
	u_int8_t		reason_code;
#define MPII_EVENT_IR_PD_RC_SETTINGS_CHANGED		(0x01)
#define MPII_EVENT_IR_PD_RC_STATUS_FLAGS_CHANGED	(0x02)
#define MPII_EVENT_IR_PD_RC_STATUS_CHANGED		(0x03)
	u_int8_t		phys_disk_num;

	u_int16_t		phys_disk_dev_handle;
	u_int16_t		reserved2;

	u_int16_t		slot;
	u_int16_t		enclosure_handle;

	u_int32_t		new_value;
	u_int32_t		previous_value;
} __packed;

struct mpii_evt_sas_tcl {
	u_int16_t		enclosure_handle;
	u_int16_t		expander_handle;

	u_int8_t		num_phys;
	u_int8_t		reserved1[3];

	u_int8_t		num_entries;
	u_int8_t		start_phy_num;
	u_int8_t		expn_status;
#define	MPII_EVENT_SAS_TOPO_ES_ADDED			(0x01)
#define MPII_EVENT_SAS_TOPO_ES_NOT_RESPONDING		(0x02)
#define MPII_EVENT_SAS_TOPO_ES_RESPONDING		(0x03)
#define MPII_EVENT_SAS_TOPO_ES_DELAY_NOT_RESPONDING	(0x04)
	u_int8_t		physical_port;

	/* followed by num_entries number of struct mpii_evt_phy_entry */
} __packed;

struct mpii_evt_phy_entry {
	u_int16_t		dev_handle;
	u_int8_t		link_rate;
	u_int8_t		phy_status;
#define MPII_EVENT_SAS_TOPO_PS_RC_MASK			(0x0f)
#define MPII_EVENT_SAS_TOPO_PS_RC_ADDED			(0x01)
#define MPII_EVENT_SAS_TOPO_PS_RC_MISSING		(0x02)
} __packed;

struct mpii_evt_ir_cfg_change_list {
	u_int8_t		num_elements;
	u_int16_t		reserved;
	u_int8_t		config_num;

	u_int32_t		flags;
#define MPII_EVT_IR_CFG_CHANGE_LIST_FOREIGN		(0x1)

	/* followed by num_elements struct mpii_evt_ir_cfg_elements */
} __packed;

struct mpii_evt_ir_cfg_element {
	u_int16_t		element_flags;
#define MPII_EVT_IR_CFG_ELEMENT_TYPE_MASK		(0xf)
#define MPII_EVT_IR_CFG_ELEMENT_TYPE_VOLUME		(0x0)
#define MPII_EVT_IR_CFG_ELEMENT_TYPE_VOLUME_DISK	(0x1)
#define MPII_EVT_IR_CFG_ELEMENT_TYPE_HOT_SPARE		(0x2)
	u_int16_t		vol_dev_handle;

	u_int8_t		reason_code;
#define MPII_EVT_IR_CFG_ELEMENT_RC_ADDED		(0x01)
#define MPII_EVT_IR_CFG_ELEMENT_RC_REMOVED		(0x02)
#define MPII_EVT_IR_CFG_ELEMENT_RC_NO_CHANGE		(0x03)
#define MPII_EVT_IR_CFG_ELEMENT_RC_HIDE			(0x04)
#define MPII_EVT_IR_CFG_ELEMENT_RC_UNHIDE		(0x05)
#define MPII_EVT_IR_CFG_ELEMENT_RC_VOLUME_CREATED	(0x06)
#define MPII_EVT_IR_CFG_ELEMENT_RC_VOLUME_DELETED	(0x07)
#define MPII_EVT_IR_CFG_ELEMENT_RC_PD_CREATED		(0x08)
#define MPII_EVT_IR_CFG_ELEMENT_RC_PD_DELETED		(0x09)
	u_int8_t		phys_disk_num;
	u_int16_t		phys_disk_dev_handle;
} __packed;
@


1.50
log
@Backout last change that broke the driver.  There's no hardware at hand
to debug it further and it's not nice to have a driver broken for months.
While here, correct calculation of a Reply Post Queue depth -- it has to
be multiple of 16.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.49 2011/09/12 12:33:26 mikeb Exp $	*/
d4595 1
a4595 1
					SIMPLEQ_REMOVE_NEXT(&sc->sc_ccb_tmos,
@


1.49
log
@Clamp a maximum number of outstanding requests at 40 as it was
figured out the hard way by senior Pedro.  Performance decreased
severely with newer firmwares when ioc was stuffed with requests.
Unfortunately it still remains a magic number as LSI doesn't
clearly document what it has to be (controllers report some
meaningless values like 3167 and 1952).

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.48 2011/08/29 12:42:18 dlg Exp $	*/
d1750 1
a1750 1
#define MPII_MAX_REQUEST_CREDIT		(40)
d2929 2
a2930 3

	sc->sc_reply_post_qdepth = sc->sc_request_depth +
	    sc->sc_num_reply_frames + 1;
@


1.48
log
@dont use a semaphore (which doesnt block interrupts in the critical
section) to protect the completion ring. mpii_poll can be in the
middle of the critical section when an interrupt is generated, but
because something is already in the critical section the isr cant
clear the condition causing the interrupt and you spin forever
entering the isr and being forced to exit it without doing any work
by the semaphore.

this moves to protecting the completion ring with a vanilla mutex.
work taken off the ring is stuck on local lists in the isr to be
completed outside the mutex in case a completion path issues a
polled command which will try to call the isr which tries to
mutex_enter while the previous call on the stack would be holding
the mutex...

this diff is large because of the list changes needed to support
the local lists in mpii_intr.

issue found by bluhm@@ and debugged by Christian Ehrhardt
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.47 2011/07/21 01:03:30 sthen Exp $	*/
d1750 1
a1750 1
#define MPII_MAX_REQUEST_CREDIT		(128)
@


1.47
log
@Index the sensor array starting from 0 not sc_vd_id_low. On my R310 this
is 1 so there, this avoids writing past the end of malloc'd space during init.
Also means the correct sensor address is registered so sysctl hw.sensors works.

Was: hw.sensors.mpii0.drive0=unknown (sd0), UNKNOWN
Now: hw.sensors.mpii0.drive0=online (sd0), OK

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.46 2011/07/20 19:00:35 sthen Exp $	*/
d1818 1
a1818 1
	SLIST_ENTRY(mpii_ccb)	ccb_link;
d1821 1
a1821 1
SLIST_HEAD(mpii_ccb_list, mpii_ccb);
a1846 1
	u_int			sc_rep_sem;
d1969 1
a1969 1
int		mpii_reply(struct mpii_softc *, struct mpii_reply_descr *);
a1973 3
int		mpii_sem_enter(struct mpii_softc *);
int		mpii_sem_leave(struct mpii_softc *);

a2159 5
	sc->sc_ih = pci_intr_establish(sc->sc_pc, ih, IPL_BIO,
	    mpii_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL)
		goto unmap;

d2162 1
a2162 1
		goto deintr;
d2167 1
a2167 1
		goto deintr;
d2172 1
a2172 1
		goto deintr;
d2248 5
a2301 4
deintr:
	pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
	sc->sc_ih = NULL;

d2325 1
a2325 1
mpii_sem_enter(struct mpii_softc *sc)
d2327 8
a2334 1
	int rv = 1;
d2337 4
a2340 4
	sc->sc_rep_sem++;
	if (sc->sc_rep_sem > 1)
		rv = 0;
	mtx_leave(&sc->sc_rep_mtx);
d2342 12
a2353 2
	return (rv);
}
d2355 2
a2356 4
int
mpii_sem_leave(struct mpii_softc *sc)
{
	int rv = 1;
d2358 7
a2364 5
	mtx_enter(&sc->sc_rep_mtx);
	sc->sc_rep_sem--;
	if (sc->sc_rep_sem > 0)
		rv = 0;
	mtx_leave(&sc->sc_rep_mtx);
d2366 4
a2369 2
	return (rv);
}
d2371 4
a2374 6
int
mpii_intr(void *arg)
{
	struct mpii_softc		*sc = arg;
	struct mpii_reply_descr		*postq = sc->sc_reply_postq_kva, *rdp;
	int				rv = 0;
d2376 2
a2377 3
	if (!mpii_sem_enter(sc))
		return (0);
	do {
d2379 1
a2379 17
		for (;;) {
			bus_dmamap_sync(sc->sc_dmat,
			    MPII_DMA_MAP(sc->sc_reply_postq),
			    0, 8 * sc->sc_reply_post_qdepth,
			    BUS_DMASYNC_POSTWRITE);

			rdp = &postq[sc->sc_reply_post_host_index];
			if ((rdp->reply_flags & MPII_REPLY_DESCR_TYPE_MASK) ==
			    MPII_REPLY_DESCR_UNUSED)
				break;
			if (rdp->data == 0xffffffff) {
				/*
				 * ioc is still writing to the reply post queue
				 * race condition - bail!
				 */
				break;
			}
d2381 2
a2382 1
			mpii_reply(sc, rdp);
d2384 8
a2391 3
			sc->sc_reply_post_host_index =
			    (sc->sc_reply_post_host_index + 1) %
			    sc->sc_reply_post_qdepth;
d2393 1
a2393 8
			rv = 1;
		}
		if (rv)
			mpii_write_reply_post(sc, sc->sc_reply_post_host_index);

	} while (!mpii_sem_leave(sc));

	return (rv);
d3939 1
a3939 1
int
a3941 1
	struct mpii_ccb		*ccb = NULL;
a3943 1
	int			smid;
a3946 1
	smid = letoh16(rdp->smid);
a3958 4
	DNPRINTF(MPII_D_INTR, "%s: mpii_reply reply_flags: %d smid: %d "
	    "reply: %p\n", DEVNAME(sc), rdp->reply_flags, smid,
	    rcb->rcb_reply);

d3965 1
a3965 9
	if (smid)  {
		ccb = &sc->sc_ccbs[smid - 1];
		ccb->ccb_state = MPII_CCB_READY;
		ccb->ccb_rcb = rcb;
		ccb->ccb_done(ccb);
	} else
		mpii_event_process(sc, rcb);

	return (smid);
d4088 2
a4089 2
	SLIST_INIT(&sc->sc_ccb_free);
	SLIST_INIT(&sc->sc_ccb_tmos);
d4174 1
a4174 1
	SLIST_INSERT_HEAD(&sc->sc_ccb_free, ccb, ccb_link);
d4185 1
a4185 1
	ccb = SLIST_FIRST(&sc->sc_ccb_free);
d4187 1
a4187 1
		SLIST_REMOVE_HEAD(&sc->sc_ccb_free, ccb_link);
d4533 1
a4533 1
		SLIST_INSERT_HEAD(&sc->sc_ccb_tmos, ccb, ccb_link);
d4549 1
a4549 1
	ccb = SLIST_FIRST(&sc->sc_ccb_tmos);
d4551 1
a4551 1
		SLIST_REMOVE_HEAD(&sc->sc_ccb_tmos, ccb_link);
d4580 1
d4589 14
a4602 2
	if (ccb->ccb_state == MPII_CCB_TIMEOUT)
		SLIST_REMOVE(&sc->sc_ccb_tmos, ccb, mpii_ccb, ccb_link);
@


1.46
log
@spell FALLTHROUGH correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.45 2011/07/17 22:46:48 matthew Exp $	*/
d5296 2
a5297 3
	for (i = sc->sc_vd_id_low; i < sc->sc_vd_id_low + sc->sc_vd_count;
	     i++) {
		link = scsi_get_link(ssc, i, 0);
@


1.45
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.44 2011/07/08 22:09:27 matthew Exp $	*/
d5356 1
a5356 1
			/* FALLTRHOUGH */
@


1.44
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.43 2011/06/17 07:06:47 mk Exp $	*/
d2249 2
a2255 2
	saa.saa_targets = sc->sc_max_devices;
	saa.saa_luns = 1;
@


1.43
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.42 2011/05/25 00:12:46 dlg Exp $	*/
a2248 2
	sc->sc_link.adapter_buswidth = sc->sc_max_devices;
	sc->sc_link.luns = 1;
d2254 2
@


1.42
log
@try to map an msi style interrupt. if that doesnt work then try to map a
normal intx style interrupt.

tested on a box with three mpii(4) controllers:

mpii0 at pci5 dev 0 function 0 "Symbios Logic SAS2008" rev 0x03: msi
mpii1 at pci8 dev 0 function 0 "Symbios Logic SAS2008" rev 0x03: msi
mpii2 at pci14 dev 0 function 0 "Symbios Logic SAS2008" rev 0x03: apic 2 int 8

no functional change, ie, everything still works.

it is ok to do this in mpii(4) since it is only enabled on i386 and
amd64, which are the only archs to get msi code so far.

discussed with and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.41 2011/05/15 12:03:14 jsg Exp $	*/
d5288 1
a5288 1
	    M_DEVBUF, M_WAITOK | M_ZERO);
@


1.41
log
@match on LSI SAS2108/SAS2116/SAS2208/SAS2308
ok mikeb@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.40 2011/04/02 14:36:45 dlg Exp $	*/
d2158 1
a2158 1
	if (pci_intr_map(pa, &ih)) {
@


1.40
log
@correctly handle data underruns. this makes things like ses(4) and safte(4)
work (they send big buffers to devices and expect less so they dont have
to do two ops for one read), and would make lun probes work again, etc.

based on the solaris code supplied by lsi.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.39 2011/02/24 23:40:31 dlg Exp $	*/
d2091 15
a2105 1
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2008 }
@


1.39
log
@we want to look up the device attached to a raid volume by its address on
the bus, not which bioctl volume id it is.

ok mikeb@@ krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.38 2011/02/21 09:36:15 dlg Exp $	*/
d4651 5
a4655 2
		xs->resid = xs->datalen - letoh32(sie->transfer_count);
		if (sie->scsi_state & MPII_SCSIIO_ERR_STATE_NO_SCSI_STATUS) {
d4659 1
a4659 1
		/* FALLTHROUGH */
@


1.38
log
@usage: mt [-f device] command [count]

most of the work and bug fixes were done by mikeb@@, i put it in ioctl
form.
ok mikeb@@ and miod@@
tested by me
an earlier revision was tested by ukasz Czarniecki who also reported
the problem in the first place.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.37 2010/12/29 03:55:09 dlg Exp $	*/
d4961 1
a4961 1
	lnk = scsi_get_link(sc->sc_scsibus, bv->bv_volid, 0);
@


1.37
log
@implement timeouts of scsi commands.

timed out scsi commands get put on a list and an iohandler is
scheduled.  that iohandler pulls the timed out scsi command off the
list and issues a task management request to kill all outstanding
io on the target with the timed out io.

all io killed as a result of this request will be returned to the
midlayer with their status set to XS_RESET, which in turn will cause
the midlayer to retry the command. this relies on the previous
commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.36 2010/12/29 03:48:30 dlg Exp $	*/
d32 1
d985 45
d1305 5
d2026 2
d4706 1
a4706 1
}
d4712 1
d4716 107
a4822 4
	if (sc->sc_ioctl)
		return (sc->sc_ioctl(link->adapter_softc, cmd, addr));
	else
		return (ENOTTY);
@


1.36
log
@make mpii properly detach devices, which helps a lot if they have commands in flight. to relevant changes are:

- call the activate(DVACT_DEACTIVATE) function against all the luns
on the target that is going away as soon as possible.
- issue the target reset BEFORE detaching the children devices.
this is needed now tha the midlayer will sleep until all outstanding
commands on a device come back from the adapter before calling the
child devices attach routine.

tested on straight disks and on disks in enclosures.

ok and moral support from krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.35 2010/08/23 00:53:36 dlg Exp $	*/
d1760 2
a1761 1
		MPII_CCB_QUEUED
d1826 9
d1907 4
d4046 1
d4048 3
d4463 1
d4475 1
d4480 55
d4542 8
@


1.35
log
@add support for the LSISAS2004 ships.

from alexey suslikov
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.34 2010/07/16 01:23:11 dlg Exp $	*/
d3420 2
d3534 3
a3536 10
	/*
	 * SAS and IR events are delivered separately, so it won't hurt
	 * to wait for a second.
	 */
	tsleep(sc, PRIBIO, "mpiipause", hz);

	if (!ISSET(dev->flags, MPII_DF_HIDDEN)) {
		if (ISSET(dev->flags, MPII_DF_ATTACH))
			scsi_probe_target(sc->sc_scsibus, dev->slot);
		else if (ISSET(dev->flags, MPII_DF_DETACH))
d3539 2
a3540 1
	}
d3542 4
a3545 4
	if (ISSET(dev->flags, MPII_DF_DETACH)) {
		mpii_sas_remove_device(sc, dev->dev_handle);
		free(dev, M_DEVBUF);
		return;
a3546 2

	CLR(dev->flags, MPII_DF_ATTACH);
d4544 3
d4549 1
a4549 1
		xs->error = XS_BUSY;
d4559 1
@


1.34
log
@gc sc_lock. it is unused. ioctl commands can run concurrently now that
iopools handle sleeping for ccbs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.33 2010/07/15 23:52:32 dlg Exp $	*/
d2023 1
@


1.33
log
@when mpii(4) gets an async event (ie, sas topology change or
integrated raid has changed state) that needs an acknowledgement,
it currently goes scsi_io_get. because events are handled at interrupt
time it cannot wait for ccbs, so if the ccb pool is empty, it wont
get a ccb to ack the event with.

this cuts the code over to using iohandlers to ack these events.
when an ack is required, it shoves the rcb onto a queue and schedules
an iohandler to be run whenever a ccb becomes available. the majority
of the time the ccb will be there and the reply will happen
immediately. however, if the hba is busy we might be deferred until
some other command completes and gives its ccb back to the pool.

because it looks like we can now receive many events at a time
(rather than just one at a time like in mpi), im using a queue to
store the events in. the alternative was an iohandler per rcb, but
that struck me as a bit too heavy.

mikeb is really impressed
no objection from krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.32 2010/07/09 22:33:21 dlg Exp $	*/
a1845 2
	struct rwlock		sc_lock;

a2161 2

	rw_init(&sc->sc_lock, "mpii_lock");
@


1.32
log
@rewrite the polling codepath in mpii.

it basically has the poll code swap the ccb completion path out for
something that clears the flag the poll code is looping on. it just
runs the interrupt handler to try and get that ccb back off the
hardware.

the reply queue is now protected by a semaphore, meaning that if
one cpu is already pulling stuff off the chip, another cpu may try
to also pull stuff off, but will return immediately cos the first
cpu will end up doing the work it wants anyway.

i did it this way so the ccb completion paths wouldnt be run while
a mutex was held, and to avoid reordering of ccb completions and
updates to the reply queue consumer that could be caused by allowing
concurrent runs of the interrupt handler to step on each other.

there is a big change here in that polling doesnt time out anymore.
it keeps trying until it succeeds, or it keeps trying. i think it
is dangerous to complete a ccb until th echip has returned it.

the only safe alternative is to do a full reset of the chip, but
that is a massive amount of work.

reviewed by mikeb
ok krw@@
testing by me on real and logical disks
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.31 2010/07/07 10:29:17 dlg Exp $	*/
d1720 1
d1725 2
d1839 4
d1945 1
a1945 2
void		mpii_eventack(struct mpii_softc *,
		    struct mpii_msg_event_reply *);
d1947 1
a1947 2
void		mpii_event_process(struct mpii_softc *,
		    struct mpii_msg_reply *);
d3069 1
a3069 1
mpii_eventack(struct mpii_softc *sc, struct mpii_msg_event_reply *enp)
d3071 4
a3075 1
	struct mpii_ccb				*ccb;
d3077 10
a3086 4
	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL) {
		DNPRINTF(MPII_D_EVT, "%s: mpii_eventack ccb_get\n",
		    DEVNAME(sc));
d3090 2
d3100 2
d3103 3
a3105 1
	return;
d3225 5
d3267 1
a3270 3
	mpii_event_process(sc, ccb->ccb_rcb->rcb_reply);

	mpii_push_reply(sc, ccb->ccb_rcb);
d3272 1
d3435 1
a3435 1
mpii_event_process(struct mpii_softc *sc, struct mpii_msg_reply *prm)
d3439 1
a3439 1
	enp = (struct mpii_msg_event_reply *)prm;
d3520 7
a3526 2
	if (enp->ack_required)
		mpii_eventack(sc, enp);
d3914 2
a3915 4
	} else {
		mpii_event_process(sc, rcb->rcb_reply);
		mpii_push_reply(sc, rcb);
	}
@


1.31
log
@bring mpi_wait over to mpii for an mpsafe mechanism to sleep while waiting
for a command to complete. this also replaces all the while (!ready) \
tsleep() wrapped in splbio code with mpii_wait.

tested with bioctl runs and sensor updates on a raid volume
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.30 2010/07/07 06:08:57 dlg Exp $	*/
d1791 2
d1898 2
a1899 2
int		mpii_complete(struct mpii_softc *, struct mpii_ccb *, int);
int		mpii_poll(struct mpii_softc *, struct mpii_ccb *, int);
d1905 3
d2045 1
d2249 27
d2281 1
a2281 1
	struct mpii_reply_descr		*rdp;
d2284 2
a2286 2
		bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_reply_postq),
		    0, 8 * sc->sc_reply_post_qdepth, BUS_DMASYNC_POSTWRITE);
d2288 25
a2312 13
		rdp = &sc->sc_reply_postq_kva[sc->sc_reply_post_host_index];
		if ((rdp->reply_flags & MPII_REPLY_DESCR_TYPE_MASK) ==
		    MPII_REPLY_DESCR_UNUSED)
			break;
		if (rdp->data == 0xffffffff) {
			/*
			 * ioc is still writing to the reply post queue
			 * race condition - bail!
			 */
			printf("%s: ioc is writing a reply @@ %d/%d (kva %p)\n",
			    DEVNAME(sc), sc->sc_reply_post_host_index,
			    sc->sc_reply_post_qdepth, rdp);
			break;
d2314 2
a2315 6
		mpii_reply(sc, rdp);
		sc->sc_reply_post_host_index =
		    (sc->sc_reply_post_host_index + 1) %
		    sc->sc_reply_post_qdepth;
		rv |= 1;
	} while (1);
d2317 1
a2317 2
	if (rv)
		mpii_write_reply_post(sc, sc->sc_reply_post_host_index);
d3023 1
a3023 1
	if (mpii_poll(sc, ccb, 50000) != 0) {
d3121 1
a3121 1
	if (mpii_poll(sc, ccb, 80000) != 0) {
d3682 1
a3682 1
		if (mpii_poll(sc, ccb, 5000) != 0) {
d3802 1
a3802 1
		if (mpii_poll(sc, ccb, 5000) != 0) {
d4206 1
a4206 1
mpii_complete(struct mpii_softc *sc, struct mpii_ccb *ccb, int timeout)
d4208 3
a4210 2
	struct mpii_reply_descr		*rdp;
	int				smid = -1;
d4212 4
a4215 2
	DNPRINTF(MPII_D_INTR, "%s: mpii_complete timeout %d\n", DEVNAME(sc),
	    timeout);
d4217 2
a4218 1
	timeout *= 100;
d4220 3
a4222 1
	do {
d4224 3
a4226 3
		if (!mpii_reply_waiting(sc)) {
			if (timeout-- == 0)
				return (1);
d4228 1
a4228 2
			continue;
		}
d4230 2
a4231 2
		bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_reply_postq),
		    0, 8 * sc->sc_reply_post_qdepth, BUS_DMASYNC_POSTWRITE);
d4233 2
a4234 12
		rdp = &sc->sc_reply_postq_kva[sc->sc_reply_post_host_index];
		if ((rdp->reply_flags & MPII_REPLY_DESCR_TYPE_MASK) ==
		    MPII_REPLY_DESCR_UNUSED)
			continue;
		if (rdp->data == 0xffffffff) {
			/*
			 * ioc is still writing to the reply post queue
			 * race condition - bail!
			 */
			printf("%s: ioc is writing a reply\n", DEVNAME(sc));
			continue;
		}
d4236 4
a4239 10
		smid = mpii_reply(sc, rdp);

		DNPRINTF(MPII_D_INTR, "%s: mpii_complete call to mpii_reply"
		    "returned: %d\n", DEVNAME(sc), smid);

		sc->sc_reply_post_host_index =
		    (sc->sc_reply_post_host_index + 1) %
		    sc->sc_reply_post_qdepth;
		mpii_write_reply_post(sc, sc->sc_reply_post_host_index);
	} while (ccb->ccb_smid != smid);
d4241 1
a4241 1
	return (0);
a4302 17
int
mpii_poll(struct mpii_softc *sc, struct mpii_ccb *ccb, int timeout)
{
	int			error;
	int			s;

	DNPRINTF(MPII_D_CMD, "%s: mpii_poll: ccb %p cmd 0x%08x\n",
	    DEVNAME(sc), ccb, ccb->ccb_cmd);

	s = splbio();
	mpii_start(sc, ccb);
	error = mpii_complete(sc, ccb, timeout);
	splx(s);

	return (error);
}

d4428 1
a4428 1
		if (mpii_poll(sc, ccb, xs->timeout) != 0) {
@


1.30
log
@rename ccb_xs to ccb_cookie, and switch it from a struct scsi_xfer * to a
void *. this will let me stash things other than scsi xfers in the ccb for
ccb_done handlers to use.

this is the same change i did in mpi.c r1.128 and mpivar.h r1.28
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.29 2010/07/07 06:00:01 dlg Exp $	*/
d1900 3
a3494 1
	int					s;
d3505 3
a3507 6
	ccb->ccb_done = (void (*)(struct mpii_ccb *))wakeup;
	mpii_start(sc, ccb);
	s = splbio();
	while (ccb->ccb_state != MPII_CCB_READY)
		tsleep(ccb, PRIBIO, "mpiitskmgmt", 0);
	splx(s);
d3521 2
a3522 6
	ccb->ccb_done = (void (*)(struct mpii_ccb *))wakeup;
	mpii_start(sc, ccb);
	s = splbio();
	while (ccb->ccb_state != MPII_CCB_READY)
		tsleep(ccb, PRIBIO, "mpiisasop", 0);
	splx(s);
a3608 1
	int			s;
d3640 1
a3641 1
		ccb->ccb_done = mpii_empty_done;
d3647 2
a3648 8
	} else {
		ccb->ccb_done = (void (*)(struct mpii_ccb *))wakeup;
		mpii_start(sc, ccb);
		s = splbio();
		while (ccb->ccb_state != MPII_CCB_READY)
			tsleep(ccb, PRIBIO, "mpiipghdr", 0);
		splx(s);
	}
a3706 1
	int			s;
d3760 1
a3761 1
		ccb->ccb_done = mpii_empty_done;
d3767 2
a3768 8
	} else {
		ccb->ccb_done = (void (*)(struct mpii_ccb *))wakeup;
		mpii_start(sc, ccb);
		s = splbio();
		while (ccb->ccb_state != MPII_CCB_READY)
			tsleep(ccb, PRIBIO, "mpiipghdr", 0);
		splx(s);
	}
d4289 37
@


1.29
log
@use a mutex to ensure writes to the two registers used to post commands to
the chip are atomic wrt to all cpus in a system.

mpii_push_reply only writes to one reg, so it is already atomic. neither
it or mpii_start need splbio now.

mpii(4) is still not completely mpsafe cos all the sleeps done while
waiting for completion still rely on splbio.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.28 2010/07/07 05:35:48 dlg Exp $	*/
d1746 1
a1746 1
	struct scsi_xfer	*ccb_xs;
d2283 1
a2283 1
	struct scsi_xfer	*xs = ccb->ccb_xs;
d4068 1
a4068 1
	ccb->ccb_xs = NULL;
d4344 1
a4344 1
	ccb->ccb_xs = xs;
d4416 1
a4416 1
	struct scsi_xfer	*xs = ccb->ccb_xs;
@


1.28
log
@let the config page request code sleep while waiting for a ccb if it is
allowed to.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.27 2010/07/07 05:25:53 dlg Exp $	*/
d1790 2
d2036 2
d3504 1
a3505 1
	mpii_start(sc, ccb);
d3508 1
a3510 1
	splx(s);
d3523 1
a3524 1
	mpii_start(sc, ccb);
d3527 1
a3529 1
	splx(s);
d3655 1
a3656 1
		mpii_start(sc, ccb);
a3699 1
	s = splbio();
a3700 1
	splx(s);
d3782 1
a3783 1
		mpii_start(sc, ccb);
a3819 1
	s = splbio();
a3820 1
	splx(s);
d4178 1
d4181 1
a4318 1
	int			s;
a4407 1
	s = splbio();
a4408 1
	splx(s);
@


1.27
log
@do a 1:1 conversion of mpii_{get,put}_ccb to scsi_io_{get,put}.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.26 2010/07/06 09:42:46 dlg Exp $	*/
d3616 2
a3617 1
	ccb = scsi_io_get(&sc->sc_iopool, 0);
d3729 2
a3730 1
	ccb = scsi_io_get(&sc->sc_iopool, 0);
@


1.26
log
@add the iopool wrapper around the mpii ccb free list. cut the midlayer and
the scsi_cmd path over to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.25 2010/07/01 03:20:38 matthew Exp $	*/
d2957 1
a2957 1
	ccb = mpii_get_ccb(sc);
d3011 1
a3011 1
	mpii_put_ccb(sc, ccb);
d3022 1
a3022 1
	ccb = mpii_get_ccb(sc);
d3049 1
a3049 1
	mpii_put_ccb(sc, ccb);
d3061 1
a3061 1
	ccb = mpii_get_ccb(sc);
d3088 1
a3088 1
	mpii_put_ccb(sc, ccb);
d3151 1
a3151 1
	ccb = mpii_get_ccb(sc);
d3201 1
a3201 1
	mpii_put_ccb(sc, ccb);
d3490 1
a3490 1
	ccb = mpii_get_ccb(sc);
d3616 1
a3616 1
	ccb = mpii_get_ccb(sc);
d3658 1
a3658 1
		mpii_put_ccb(sc, ccb);
d3698 1
a3698 1
	mpii_put_ccb(sc, ccb);
d3728 1
a3728 1
	ccb = mpii_get_ccb(sc);
d3786 1
a3786 1
		mpii_put_ccb(sc, ccb);
d3819 1
a3819 1
	mpii_put_ccb(sc, ccb);
@


1.25
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.24 2010/06/28 18:31:02 krw Exp $	*/
d1818 2
d1881 2
a1882 2
struct mpii_ccb *mpii_get_ccb(struct mpii_softc *);
void		mpii_put_ccb(struct mpii_softc *, struct mpii_ccb *);
d2156 1
d4042 2
d4058 1
a4058 1
mpii_put_ccb(struct mpii_softc *sc, struct mpii_ccb *ccb)
d4060 3
d4076 2
a4077 2
struct mpii_ccb *
mpii_get_ccb(struct mpii_softc *sc)
d4079 1
d4311 1
a4311 1
	struct mpii_ccb		*ccb;
a4337 7
	ccb = mpii_get_ccb(sc);
	if (ccb == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}

a4376 1
		mpii_put_ccb(sc, ccb);
a4396 1
			mpii_put_ccb(sc, ccb);
a4432 1
		mpii_put_ccb(sc, ccb);
a4515 1
	mpii_put_ccb(sc, ccb);
@


1.24
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.23 2010/06/27 03:34:29 matthew Exp $	*/
d4670 1
a4670 1
	lnk = sc->sc_scsibus->sc_link[bv->bv_volid][0];
d4976 1
d4990 2
a4991 1
		if (ssc->sc_link[i][0] == NULL)
d4994 1
a4994 1
		dev = ssc->sc_link[i][0]->device_softc;
@


1.23
log
@"Believe it or not," nothing uses scsi_xfer's req_sense_length field
in any meaningful way, so just get rid of it.

ok krw@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.22 2010/06/27 01:47:36 dlg Exp $	*/
a1874 7
struct scsi_device mpii_dev = {
	NULL,
	NULL,
	NULL,
	NULL
};

d2135 1
a2135 1
		printf("%s: unable to allocate memory for mpii_dev\n",
a2147 1
	sc->sc_link.device = &mpii_dev;
@


1.22
log
@mpii was modelled very heavily on mpi which means that it inherited a split
of pci specific code and the rest of the driver. in hindsight, this was a
stupid thing to do in mpi since there will only ever be pci based mpi
controllers. the same goes for mpii, but unlink mpi it doesnt have the bus
and generic driver split at the file level, just in the code.

this merges the pci and generic mpii autoconf code so its just mpii
autoconf code. apologies for the files.pci change.

tested by me
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.21 2010/06/22 13:10:38 dlg Exp $	*/
d4411 1
a4411 2
	    "datalen: %d req_sense_len: %d\n", DEVNAME(sc), xs->cmd->opcode,
	    xs->datalen, xs->req_sense_length);
@


1.21
log
@protect the ccb free list with a mutex rather than relying on splbio
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.20 2010/06/15 04:11:34 dlg Exp $	*/
d1770 6
d1840 4
a1843 2
int	mpii_attach(struct mpii_softc *);
void	mpii_detach(struct mpii_softc *);
d1846 5
a1850 16
int	mpii_pci_match(struct device *, void *, void *);
void	mpii_pci_attach(struct device *, struct device *, void *);
int	mpii_pci_detach(struct device *, int);

struct mpii_pci_softc {
	struct mpii_softc	psc_mpii;

	pci_chipset_tag_t	psc_pc;
	pcitag_t		psc_tag;

	void			*psc_ih;
};

struct cfattach mpii_pci_ca = {
	sizeof(struct mpii_pci_softc), mpii_pci_match, mpii_pci_attach,
	mpii_pci_detach
a1852 100
#define PREAD(s, r)	pci_conf_read((s)->psc_pc, (s)->psc_tag, (r))
#define PWRITE(s, r, v)	pci_conf_write((s)->psc_pc, (s)->psc_tag, (r), (v))

static const struct pci_matchid mpii_devices[] = {
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2008 }
};

int
mpii_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid(aux, mpii_devices, nitems(mpii_devices)));
}

void
mpii_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct mpii_pci_softc		*psc = (void *)self;
	struct mpii_softc		*sc = &psc->psc_mpii;
	struct pci_attach_args		*pa = aux;
	pcireg_t			memtype;
	int				r;
	pci_intr_handle_t		ih;
	const char			*intrstr;

	psc->psc_pc = pa->pa_pc;
	psc->psc_tag = pa->pa_tag;
	psc->psc_ih = NULL;
	sc->sc_dmat = pa->pa_dmat;

	/* find the appropriate memory base */
	for (r = PCI_MAPREG_START; r < PCI_MAPREG_END; r += sizeof(memtype)) {
		memtype = pci_mapreg_type(psc->psc_pc, psc->psc_tag, r);
		if ((memtype & PCI_MAPREG_TYPE_MASK) == PCI_MAPREG_TYPE_MEM)
			break;
	}
	if (r >= PCI_MAPREG_END) {
		printf(": unable to locate system interface registers\n");
		return;
	}

	if (pci_mapreg_map(pa, r, memtype, 0, &sc->sc_iot, &sc->sc_ioh,
	    NULL, &sc->sc_ios, 0xFF) != 0) {
		printf(": unable to map system interface registers\n");
		return;
	}

	/* disable the expansion rom */
	PWRITE(psc, PCI_ROM_REG, PREAD(psc, PCI_ROM_REG) & ~PCI_ROM_ENABLE);

	/* hook up the interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": unable to map interrupt\n");
		goto unmap;
	}
	intrstr = pci_intr_string(psc->psc_pc, ih);
	psc->psc_ih = pci_intr_establish(psc->psc_pc, ih, IPL_BIO,
	    mpii_intr, sc, sc->sc_dev.dv_xname);
	if (psc->psc_ih == NULL) {
		printf(": unable to map interrupt%s%s\n",
		    intrstr == NULL ? "" : " at ",
		    intrstr == NULL ? "" : intrstr);
		goto unmap;
	}
	printf(": %s", intrstr);

	if (mpii_attach(sc) != 0) {
		/* error printed by mpii_attach */
		goto deintr;
	}

	return;

deintr:
	pci_intr_disestablish(psc->psc_pc, psc->psc_ih);
	psc->psc_ih = NULL;
unmap:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	sc->sc_ios = 0;
}

int
mpii_pci_detach(struct device *self, int flags)
{
	struct mpii_pci_softc		*psc = (struct mpii_pci_softc *)self;
	struct mpii_softc		*sc = &psc->psc_mpii;

	mpii_detach(sc);

	if (psc->psc_ih != NULL) {
		pci_intr_disestablish(psc->psc_pc, psc->psc_ih);
		psc->psc_ih = NULL;
	}
	if (sc->sc_ios != 0) {
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		sc->sc_ios = 0;
	}

	return (0);
}

d1859 3
d2014 4
d2019 1
a2019 1
mpii_attach(struct mpii_softc *sc)
d2021 11
d2035 23
a2057 1
	printf("\n");
d2061 14
a2074 2
	    MPII_INTR_MASK_RESET | MPII_INTR_MASK_REPLY
	    | MPII_INTR_MASK_DOORBELL);
d2078 1
a2078 1
		return (1);
d2083 1
a2083 1
		return (1);
d2088 1
a2088 1
		return(1);
d2189 1
a2189 1
	return (0);
d2215 7
a2221 1
	return(1);
d2224 2
a2225 2
void
mpii_detach(struct mpii_softc *sc)
d2227 1
d2229 10
d2241 1
d3883 1
a3883 1
		return (NULL);
@


1.20
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.19 2010/05/26 17:46:31 marco Exp $	*/
d1810 1
a3527 1
	s = splbio();
a3528 1
	splx(s);
a3653 1
	s = splbio();
a3654 1
	splx(s);
a3695 1
		s = splbio();
a3696 1
		splx(s);
d3735 1
a3736 1
	splx(s);
a3765 1
	s = splbio();
a3766 1
	splx(s);
a3823 1
		s = splbio();
a3824 1
		splx(s);
d3856 1
a3857 1
	splx(s);
d4029 1
d4103 2
d4106 1
d4114 1
d4120 1
a4369 1
	s = splbio();
a4370 1
	splx(s);
a4415 1
		s = splbio();
a4417 1
		splx(s);
a4436 1
			s = splbio();
a4438 1
			splx(s);
@


1.19
log
@- no need for a separate mpii_minphys;
- save about 26K of kernel memory by giving scsi
  subsystem a hint that we won't be using more than
  one lun per target;
- remove a debugging leftover.

from Mike Belopuhov <mkb@@crypt.org.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.18 2010/05/20 00:55:18 krw Exp $	*/
d1964 1
a1964 2
int		mpii_scsi_ioctl(struct scsi_link *, u_long, caddr_t,
		    int, struct proc *);
d4573 1
a4573 2
mpii_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag,
    struct proc *p)
@


1.18
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.17 2010/04/15 20:18:11 marco Exp $	*/
a1962 1
void		mpii_minphys(struct buf *bp, struct scsi_link *sl);
d1969 1
a1969 1
	mpii_minphys,
d2211 1
a2421 6
void
mpii_minphys(struct buf *bp, struct scsi_link *sl)
{
	minphys(bp);
}

d3907 1
a3907 2
		if (ccb->ccb_state == MPII_CCB_QUEUED)
			ccb->ccb_state = MPII_CCB_READY;
@


1.17
log
@- fix bunch of use-after-free bugs found by splint;
- support sharing a phy port by devices (should work fine with sas
  expanders that share phy port number if such exist);
- remove dead timeout_xs stuff;
- make mpii_push_reply take a struct mpii_rcb argument instead of an
  address (like mpi does);
- use SLIST instead of TAILQ to manage ccbs (ala mpi);
- rototil openfirmware attachment code as it was copied verbatim
  (but with an error) from mpi and clearly wasn't tested;
- increase reset delay to 240ms for stability purposes;
- sprinkle some 'default' cases in a bunch of switch statements;
- remove several splbio's from the code that runs on boot;
- clarify/simplify the code that deals with sc_vd_id_low;
- some slight cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.16 2010/04/10 12:42:17 marco Exp $	*/
a4369 1
		s = splbio();
a4370 1
		splx(s);
a4376 1
		s = splbio();
a4377 1
		splx(s);
a4385 1
		s = splbio();
a4386 1
		splx(s);
@


1.16
log
@some frees that were forgotten
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.15 2010/04/09 17:00:55 marco Exp $	*/
a39 4
#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif

d263 1
a263 1
#define MPII_REP_IOCLOGINFO_TYPE			(0xf<<28) /* log info type */
d269 1
a269 1
#define MPII_REP_IOCLOGINFO_DATA			(0x0fffffff) /* log info data */
a299 3
/* page address fields */
#define MPII_PAGE_ADDRESS_FC_BTID	(1<<24)	/* Bus Target ID */

d1669 1
a1669 1
uint32_t  mpii_debug = 0
d1763 1
a1763 1
	TAILQ_ENTRY(mpii_ccb)	ccb_link;
d1766 1
a1766 1
TAILQ_HEAD(mpii_ccb_list, mpii_ccb);
a1799 3
	u_int8_t		sc_dpm_enabled;
	u_int8_t		sc_num_reserved_entries;
	u_int8_t		sc_reserve_tid0;
a1801 1
	u_int16_t		sc_vd_id_hi;
a1803 1
	int			sc_target;
a1877 3
#ifdef __sparc64__
	int node;
#endif
a1882 2
	sc->sc_ios = 0;
	sc->sc_target = -1;
a1919 15
#ifdef __sparc64__
		/*
		 * Walk up the Open Firmware device tree until we find a
		 * "scsi-initiator-id" property.
		 */
		node = PCITAG_NODE(pa->pa_tag);
		while (node) {
			if (OF_getprop(node, "scsi-initiator-id",
			    &sc->sc_target, sizeof(sc->sc_target)) ==
			    sizeof(sc->sc_target))
				break;
			node = OF_parent(node);
		}
#endif

d1991 1
a1991 1
void		mpii_push_reply(struct mpii_softc *, u_int32_t);
a2005 1
void		mpii_timeout_xs(void *);
d2060 1
a2060 1
		    u_int8_t, int *);
d2186 1
a2186 1
		(sc->sc_porttype == MPII_PORTFACTS_PORTTYPE_SAS_VIRTUAL)) {
d2210 1
a2210 1
	sc->sc_link.adapter_target = sc->sc_target;
a2312 6
void
mpii_timeout_xs(void *arg)
{
	/* nothing smart could be done here */
}

d2320 2
a2321 2
	struct mpii_sge		*sge, *nsge = &mcb->mcb_sgl[0];
	struct mpii_sge		*ce = NULL, *nce;
d2623 2
a2624 2
	/* 200 milliseconds */
	delay(200000);
d2975 1
a2975 1
mpii_push_reply(struct mpii_softc *sc, u_int32_t rdva)
d2979 3
d2983 1
a2983 1
	rfp[sc->sc_reply_free_host_index] = rdva;
a2995 1
	int					rv = 1, s;
d2997 1
a3000 1
	s = splbio();
a3001 1
	splx(s);
d3021 2
a3022 1
		DNPRINTF(MPII_D_MISC, "%s: mpii_portfacts poll\n", DEVNAME(sc));
d3039 2
a3040 2
	DNPRINTF(MPII_D_MISC, "%s:  vf_id: 0x%02x vp_id: 0x%02x\n", DEVNAME(sc),
	    pfp->vf_id, pfp->vp_id);
d3052 1
a3052 1
	mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
d3063 1
a3064 1
	struct mpii_msg_eventack_request	*eaq;
d3068 2
a3069 1
		DNPRINTF(MPII_D_EVT, "%s: mpii_eventack ccb_get\n", DEVNAME(sc));
d3092 1
a3092 1
	mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
d3101 1
a3101 2
	struct mpii_ccb		*ccb;
	int			s;
a3104 1
	s = splbio();
a3105 1
	splx(s);
d3118 3
a3120 2
	if (mpii_poll(sc, ccb, 50000) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_portenable poll\n", DEVNAME(sc));
d3131 1
a3131 1
	mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
d3140 2
a3141 3
	struct mpii_cfg_hdr	hdr;
	struct mpii_cfg_ioc_pg1	pg;
	u_int32_t		flags;
d3145 2
a3146 2
		DNPRINTF(MPII_D_MISC, "%s: unable to fetch IOC page 1 header\n",
		    DEVNAME(sc));
d3164 1
a3164 2
	flags = letoh32(pg.flags);
	if (!ISSET(flags, MPII_CFG_IOC_1_REPLY_COALESCING))
d3192 1
a3193 2
	struct mpii_msg_event_request		*enq;
	int					s;
a3194 1
	s = splbio();
a3195 1
	splx(s);
a3229 1
	s = splbio();
a3230 1
	splx(s);
d3244 1
a3244 1
	mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
d3291 1
a3291 1
				dev->slot = sc->sc_vd_id_low + sc->sc_vd_count;
d3429 1
a3429 1
			    esd->discovery_status);
d3520 1
d3523 1
a3523 1
	CLR(dev->flags, MPII_DF_ATTACH | MPII_DF_DETACH);
d3551 1
a3551 1
		mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
d3570 1
a3570 1
		mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
d3581 1
a3581 1
	int			rv = 0;
d3585 4
a3588 3
	if (mpii_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_IOC, 8, 0, &hdr) != 0) {
		DNPRINTF(MPII_D_CFG, "%s: mpii_get_ioc_pg8 unable to fetch header"
		    "for IOC page 8\n", DEVNAME(sc));
d3612 1
a3612 1
	    letoh16(page->max_persistent_entries), 
d3616 1
a3616 1
	DNPRINTF(MPII_D_CFG, "%s:  irvolumemappingflags: 0x%04x\n", 
d3619 2
a3620 8
	sc->sc_pd_id_start = 0;

	if (page->flags & MPII_IOC_PG8_FLAGS_RESERVED_TARGETID_0) {
		sc->sc_reserve_tid0 = 1;
		sc->sc_num_reserved_entries = 1;
		sc->sc_pd_id_start = 1;
	} else
		sc->sc_num_reserved_entries = 0;
d3622 1
a3622 1
	flags = page->ir_volume_mapping_flags &&
d3626 2
a3627 4
			sc->sc_num_reserved_entries += sc->sc_max_volumes;
			sc->sc_vd_id_low = 0;
			if (page->flags & MPII_IOC_PG8_FLAGS_RESERVED_TARGETID_0)
				sc->sc_vd_id_low = 1;
d3629 2
a3630 3
			sc->sc_vd_id_low = sc->sc_max_devices - sc->sc_max_volumes;
		sc->sc_vd_id_hi = sc->sc_vd_id_low + sc->sc_max_volumes - 1;
		sc->sc_pd_id_start = sc->sc_vd_id_hi + 1;
d3633 2
d3636 2
a3637 2
	    "sc_vd_id_low: %d sc_vd_id_hi: %d\n", DEVNAME(sc), 
	    sc->sc_pd_id_start, sc->sc_vd_id_low, sc->sc_vd_id_hi);
d3746 1
a3746 1
	mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
d3768 2
a3769 2
	DNPRINTF(MPII_D_MISC, "%s: mpii_cfg_page address: %d read: %d type: %x\n",
	    DEVNAME(sc), address, read, hdr->page_type);
d3782 2
a3783 1
		DNPRINTF(MPII_D_MISC, "%s: mpii_cfg_page ccb_get\n", DEVNAME(sc));
d3871 1
a3871 1
	mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
d3913 2
a3914 1
		ccb->ccb_state = MPII_CCB_READY;
d3919 1
a3919 1
		mpii_push_reply(sc, rcb->rcb_reply_dva);
d3998 3
a4000 1
	if (!dev || dev->slot < 0 || dev->slot >= sc->sc_max_devices)
d4002 3
a4004 3
	if (sc->sc_devs[dev->slot]) {
		printf("%s: slot %d is occupied by the dev %p\n", DEVNAME(sc),
		    dev->slot, sc->sc_devs[dev->slot]);
d4006 2
a4007 2
	}
	sc->sc_devs[dev->slot] = dev;
d4045 1
a4045 1
	TAILQ_INIT(&sc->sc_ccb_free);
d4119 1
a4119 1
	TAILQ_INSERT_TAIL(&sc->sc_ccb_free, ccb, ccb_link);
d4127 4
a4130 4
	ccb = TAILQ_FIRST(&sc->sc_ccb_free);
	if (ccb == NULL) {
		DNPRINTF(MPII_D_CCB, "%s: mpii_get_ccb == NULL\n", DEVNAME(sc));
		return (NULL);
a4132 4
	TAILQ_REMOVE(&sc->sc_ccb_free, ccb, ccb_link);

	ccb->ccb_state = MPII_CCB_READY;

d4174 1
a4174 1
		mpii_push_reply(sc, rcb->rcb_reply_dva);
d4183 1
a4183 1
	u_int32_t			*rdp = (uint32_t *)&descr;
d4466 2
a4467 5
	timeout_set(&xs->stimeout, mpii_timeout_xs, ccb);
	timeout_add_msec(&xs->stimeout, xs->timeout);

	DNPRINTF(MPII_D_CMD, "%s:    mpii_scsi_cmd(): opcode: %02x datalen: %d "
	    "req_sense_len: %d\n", DEVNAME(sc), xs->cmd->opcode,
a4491 2
	if (!(xs->flags & SCSI_POLL))
		timeout_del(&xs->stimeout);
d4581 1
a4581 1
	mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
d4707 1
d4788 2
a4789 1
		u_int8_t	hsmap = vpg->hot_spare_pool;
d4792 1
a4792 1
		return (mpii_bio_hs(sc, bd, vpg->num_phys_disks, hsmap, NULL));
d4805 1
a4805 1
     u_int8_t hsmap, int *hscnt)
d4856 2
d4859 1
a4859 2
				return (mpii_bio_disk(sc, bd,
				    el->phys_disk_num));
d4938 1
d5003 2
a5004 2
		DNPRINTF(MPII_D_MISC, "%s: unable to fetch raid volume page 0\n",
		    DEVNAME(sc));
d5028 1
@


1.15
log
@oopsie, misplaced {
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.14 2010/04/09 15:50:14 marco Exp $	*/
d4951 1
d4959 1
d5003 1
@


1.14
log
@- event handling rewrite (while preserving original logic);
- support additional volume events;
- track volume rebuild progress;
- support for drive hotplug;
- log when volume state changes and when we start to resync;
- mpii_device handling rewrite (r/b tree is no more);
- improvements in mpii_ioctl_* functions;
- use internal disk_phys_num again as phy port number based
  scheme was proven to be unreliable;
- fixup ioc_status check in mpii_scsi_cmd_done;
- change Offline state to Invalid when drive is gone;
- fixup recognition of the rebuilding state;
- don't leak ccb if poll fails;
- make use of the MPII_F_RAID flag and register with bio only
  if there are RAID capabilities (idea from mpi);
- EVENT_UNMASK macro improvement from Kai Doernemann;
- use proper endianness when setting ccb_dev_handle;
- lower a polling delay in the mpii_complete;
- improve readability and debugging output in several places;
- change semantics of the SAS discovery event handler;
- start of the event cleanup;
- start of the whitespace cleanup;
- start of the KNF cleanup;

from Mike Belopuhov <mkb@@crypt.org.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.13 2010/04/06 22:28:07 tedu Exp $	*/
d3436 1
a3436 3
			    letoh16(pe->dev_handle)))) {
				printf("%s: nothing known about drive %#x\n",
				    DEVNAME(sc));
a3437 1
			}
@


1.13
log
@update a random sampling of drivers after the proc.h -> systm.h move
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.12 2010/03/23 01:57:20 krw Exp $	*/
d84 1
a84 1
#define	 MPII_WRITESEQ_6		(0x0d)	
d131 2
a132 2
#define MPII_REQ_DESC_POST_LOW		(0xc0)
#define MPII_REQ_DESC_POST_HIGH		(0xc4)
a213 17
/* request flags fields for request descriptors */
#define MPII_REQ_DESCRIPTOR_FLAGS_TYPE_SHIFT		(0x01)
#define MPII_REQ_DESCRIPTOR_FLAGS_TYPE_MASK		(0x07 << \
					MPII_REQ_DESCRIPTOR_FLAGS_TYPE_SHIFT)
#define MPII_REQ_DESCRIPTOR_FLAGS_SCSI_IO		(0x00)
#define MPII_REQ_DESCRIPTOR_FLAGS_SCSI_TARGET		(0x02)
#define MPII_REQ_DESCRIPTOR_FLAGS_HIGH_PRIORITY		(0x06)
#define MPII_REQ_DESCRIPTOR_FLAGS_DEFAULT		(0x08)

#define MPII_REQ_DESCRIPTOR_FLAGS_IOC_FIFO_MARKER	(0x01)

/* reply flags */
#define MPII_REP_FLAGS_CONT			(1<<7) /* continuation reply */

#define MPII_REP_IOCSTATUS_AVAIL		(1<<15) /* log info available */
#define MPII_REP_IOCSTATUS			(0x7fff) /* status */

d215 1
a628 50
/* XXX JPG */
struct mpii_evt_change {
	u_int8_t		event_state;
	u_int8_t		reserved[3];
} __packed;

/* XXX JPG */
struct mpii_evt_sas_phy {
	u_int8_t		phy_num;
	u_int8_t		link_rates;
#define MPII_EVT_SASPHY_LINK_CUR(x)			((x) & 0xf0) >> 4
#define MPII_EVT_SASPHY_LINK_PREV(x)			(x) & 0x0f
#define MPII_EVT_SASPHY_LINK_ENABLED			(0x0)
#define MPII_EVT_SASPHY_LINK_DISABLED			(0x1)
#define MPII_EVT_SASPHY_LINK_NEGFAIL			(0x2)
#define MPII_EVT_SASPHY_LINK_SATAOOB			(0x3)
#define MPII_EVT_SASPHY_LINK_1_5GBPS			(0x8)
#define MPII_EVT_SASPHY_LINK_3_0GBPS			(0x9)
	u_int16_t		dev_handle;

	u_int64_t		sas_addr;
} __packed;

struct mpii_evt_sas_change {
	u_int16_t		task_tag;
	u_int8_t		reason;
#define MPII_EVT_SASCH_REASON_SMART_DATA		(0x05)
#define MPII_EVT_SASCH_REASON_UNSUPPORTED		(0x07)
#define MPII_EVT_SASCH_REASON_INTERNAL_RESET		(0x08)
#define MPII_EVT_SASCH_REASON_TASK_ABORT_INTERVAL	(0x09)
#define MPII_EVT_SASCH_REASON_ABORT_TASK_SET_INTERVAL	(0x0a)
#define MPII_EVT_SASCH_REASON_CLEAR_TASK_SET_INTERVAL	(0x0b)
#define MPII_EVT_SASCH_REASON_QUERY_TASK_INTERVAL	(0x0c)
#define MPII_EVT_SASCH_REASON_ASYNC_NOTIFICATION	(0x0d)
#define MPII_EVT_SASCH_REASON_CMP_INTERNAL_DEV_RESET	(0x0e)
#define MPII_EVT_SASCH_REASON_CMP_TASK_ABORT_INTERNAL	(0x0f)
#define MPII_EVT_SASCH_REASON_SATA_INIT_FAILURE		(0x10)
	u_int8_t		reserved1;

	u_int8_t		asc;
	u_int8_t		ascq;
	u_int16_t		dev_handle;

	u_int32_t		reserved2;

	u_int64_t		sas_addr;

	u_int16_t		lun[4];
} __packed;

d833 1
a833 1
struct mpii_request_descriptor {
d835 5
d844 1
a844 7
	/*
	 * the following field is descriptor type dependent
	 *    default - undefined 
	 *    scsi io - device handle
	 *    high priority - reserved
	 */
	u_int16_t		type_dependent;
d847 1
a847 1
struct mpii_reply_descriptor {
d849 6
a854 6
#define MPII_REPLY_DESCR_FLAGS_TYPE_MASK               (0x0f)
#define MPII_REPLY_DESCR_FLAGS_SCSI_IO_SUCCESS         (0x00)
#define MPII_REPLY_DESCR_FLAGS_ADDRESS_REPLY           (0x01)
#define MPII_REPLY_DESCR_FLAGS_TARGETASSIST_SUCCESS    (0x02)
#define MPII_REPLY_DESCR_FLAGS_TARGET_COMMAND_BUFFER   (0x03)
#define MPII_REPLY_DESCR_FLAGS_UNUSED                  (0x0f)
d856 1
a856 7
	/*
	 * the following field is reply descriptor type dependent
	 *     default - undefined
	 *     scsi io success - smid 
	 *     address reply - smid 
	 */
	u_int16_t		type_dependent1;
d858 4
a861 7
	/*
	 * the following field is reply descriptor type dependent
	 *     default - undefined
	 *     scsi io success - bottom 16 bits is task tag 
	 *     address reply - reply frame address
	 */
	u_int32_t		type_dependent2;
a877 1
/* XXX JPG delete this? */
d879 1
a879 2
	u_int8_t		target_id;
	u_int8_t		bus;
d885 5
a889 5
#define MPII_MSG_SCSI_TASK_TYPE_ABORT_TASK		(0x01)
#define MPII_MSG_SCSI_TASK_TYPE_ABRT_TASK_SET		(0x02)
#define MPII_MSG_SCSI_TASK_TYPE_TARGET_RESET		(0x03)
#define MPII_MSG_SCSI_TASK_TYPE_RESET_BUS		(0x04)
#define MPII_MSG_SCSI_TASK_TYPE_LOGICAL_UNIT_RESET	(0x05)
d893 3
a895 1
	u_int32_t		msg_context;
d899 1
a899 1
	u_int32_t		reserved3[7];
d901 2
a902 1
	u_int32_t		target_msg_context;
a904 1
/* XXX JPG delete this? */
d906 1
a906 2
	u_int8_t		target_id;
	u_int8_t		bus;
d915 3
a917 1
	u_int32_t		msg_context;
d919 1
a919 1
	u_int16_t		reserved2;
d927 64
d1549 28
a1576 1
/* lots of defines go in here */
d1597 1
a1597 1
struct mpii_evt_sas_topo_change_list {
d1599 1
a1599 1
	u_int16_t		expander_dev_handle;
d1606 1
a1606 1
	u_int8_t		exp_status;
d1617 1
a1617 1
	u_int16_t		attached_dev_handle;
a1618 12
#define MPII_EVENT_SAS_TOPO_LR_CURRENT_LINK_RATE_MASK	(0xf0)
#define MPII_EVENT_SAS_TOPO_LR_CURRENT_LINK_RATE_SHIFT	(4)
#define MPII_EVENT_SAS_TOPO_LR_PREVIOUS_LINK_RATE_MASK	(0x0f)
#define MPII_EVENT_SAS_TOPO_LR_PHY_EN_UNKNOWN_RATE	(0x0)
#define MPII_EVENT_SAS_TOPO_LR_PHY_DISABLE		(0x1)
#define MPII_EVENT_SAS_TOPO_LR_PHY_EN_FAIL_SPEED_NEG	(0x2)
#define MPII_EVENT_SAS_TOPO_LR_PHY_EN_SATA_OOB_COMPLETE	(0x3)
#define MPII_EVENT_SAS_TOPO_LR_PHY_EN_SATA_PORT_SEL	(0x4)
#define MPII_EVENT_SAS_TOPO_LR_PHY_EN_SMP_RESET_IN_PROG	(0x5)
#define MPII_EVENT_SAS_TOPO_LR_PHY_EN_1_5_GBPS		(0x8)
#define MPII_EVENT_SAS_TOPO_LR_PHY_EN_3_0_GBPS		(0x9)
#define MPII_EVENT_SAS_TOPO_LR_PHY_EN_6_0_GBPS		(0xa)
d1621 2
a1622 8
#define	MPII_EVENT_SAS_TOPO_PS_RC_TARG_ADDED		(0x01)
#define MPII_EVENT_SAS_TOPO_PS_RC_TARG_NO_RESPOND_MISS	(0x02)
#define MPII_EVENT_SAS_TOPO_PS_RC_PHY_LINK_STATE_CHANGE	(0x03)
#define MPII_EVENT_SAS_TOPO_PS_RC_PHY_LINK_STATE_NOCHNG	(0x04)
#define MPII_EVENT_SAS_TOPO_PS_RC_WITHIN_DELAY_TIMER	(0x05)
#define MPII_EVENT_SAS_TOPO_PS_PHY_VACANT_MASK		(0x80)
#define MPII_EVENT_SAS_TOPO_PS_PHY_VACANT_NOT_VACANT	(0x00)
#define MPII_EVENT_SAS_TOOP_PS_PHY_VACANT_ACCESS_DENIED	(0x80)
d1631 2
a1632 4
#define MPII_EVT_IR_CFG_CHANGE_LIST_FLAGS_CFG_MASK	(0x1)
#define MPII_EVT_IR_CFG_CHANGE_LIST_FLAGS_CFG_NATIVE	(0)
#define MPII_EVT_IR_CFG_CHANGE_LIST_FLAGS_CFG_FOREIGN	(1)
	
d1638 4
a1641 4
#define MPII_EVT_IR_CFG_ELEMENT_EF_ELEMENT_TYPE_MASK	(0xf)
#define MPII_EVT_IR_CFG_ELEMENT_EF_ELEMENT_TYPE_VOLUME	(0x0)
#define MPII_EVT_IR_CFG_ELEMENT_EF_ELEMENT_TYPE_VOL_PD	(0x1)
#define MPII_EVT_IR_CFG_ELEMENT_EF_ELEMENT_TYPE_HSP_PD	(0x2)
d1687 1
a1687 1
		| MPII_D_EVT 
d1732 10
a1741 3

	RB_ENTRY(mpii_device)	rb_entry;

d1743 2
a1745 8
	u_int8_t		type;
#define MPII_DEV_TYPE_PD	(0x00)
#define MPII_DEV_TYPE_VD_PD	(0x01)
#define MPII_DEV_TYPE_VD	(0x02)
	
	u_int16_t		enclosure_handle;

	u_int16_t		expander_dev_handle;
a1746 9

	u_int32_t		wwid;

	u_int32_t		flags;
#define MPII_DEV_HIDDEN		(1<<0)
#define MPII_DEV_INTERFACE_SAS	(1<<4)
#define MPII_DEV_INTERFACE_SATA	(1<<5)
#define MPII_DEV_SCSI_ML_ATTACH (1<<8)
#define MPII_DEV_UNUSED		(1<<31)
a1748 14
int mpii_dev_cmp(struct mpii_device *, struct mpii_device *);

int
mpii_dev_cmp(struct mpii_device *a, struct mpii_device *b)
{
	return (a->dev_handle < b->dev_handle ? -1 : 
	    a->dev_handle > b->dev_handle);
}

RB_HEAD(mpii_dev_tree, mpii_device) mpii_dev_head = 
    RB_INITIALIZER(&mpii_dev_head);
RB_PROTOTYPE(mpii_dev_tree, mpii_device, rb_entry, mpii_dev_cmp)
RB_GENERATE(mpii_dev_tree, mpii_device, rb_entry, mpii_dev_cmp)

d1784 1
a1784 1
	struct mpii_device	**sc_mpii_dev;
d1800 1
a1800 2
	
	u_int8_t		sc_ir_firmware;
d1810 1
a1813 2
	u_int16_t		sc_pd_count;
	u_int16_t		sc_vd_count;
a1814 6
	/* XXX not sure these below will stay */
	u_int8_t		sc_num_enclosure_table_entries;
	u_int32_t		sc_pending_map_events;
	u_int8_t		sc_tracking_map_events;
	int			sc_discovery_in_progress;
	/* end list of likely to be cut entries */
d1829 1
a1829 1
	struct mpii_reply_descriptor	*sc_reply_postq_kva;	
d1834 1
a1834 1
	
d1840 1
d1871 1
a1871 1
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2008 } 
d1936 1
a1936 1
	
d1949 1
d1951 1
a1951 1
	
d2002 2
a2003 2
	mpii_minphys, 
	mpii_scsi_probe, /* XXX JPG scsi_probe may prove useful for mapping nonsense */
a2022 1
int		mpii_alloc_dev(struct mpii_softc *);
d2026 5
d2034 1
a2034 2
int		mpii_reply(struct mpii_softc *,
		    struct mpii_reply_descriptor *);
d2063 1
a2063 1
int			mpii_cfg_coalescing(struct mpii_softc *);
d2070 1
a2070 1
void		mpii_event_process(struct mpii_softc *, 
d2072 1
a2072 1
void		mpii_event_process_sas_discovery(struct mpii_softc *,
d2074 1
a2074 1
void		mpii_event_process_sas_topo_change(struct mpii_softc *,
d2076 4
a2079 7
void		mpii_event_process_ir_cfg_change_list(struct mpii_softc *, 
		    struct mpii_msg_event_reply *);
void		mpii_event_process_ir_phys_disk(struct mpii_softc *,
		    struct mpii_msg_event_reply *);
/*
void		mpii_evt_sas(void *, void *);
*/
d2096 1
a2096 1
int		mpii_bio_getphy(struct mpii_softc *, u_int16_t, u_int16_t *);
d2157 1
a2157 1
	mpii_write(sc, MPII_INTR_MASK, 
d2218 1
a2218 1
	if ((sc->sc_porttype == MPII_PORTFACTS_PORTTYPE_SAS_PHYSICAL) || 
d2227 1
a2227 1
		printf("%s: unable to allocate memory for mpii_dev\n", 
d2235 1
a2235 2
	} /* assume all discovery events are complete by now */

d2252 1
a2252 1
		&saa, scsiprint);
d2255 1
a2255 1
	mpii_write(sc, MPII_INTR_MASK, MPII_INTR_MASK_DOORBELL 
d2259 6
a2264 4
	if (bio_register(&sc->sc_dev, mpii_ioctl) != 0)
		panic("%s: controller registration failed", DEVNAME(sc));
	else
		sc->sc_ioctl = mpii_ioctl;
d2267 2
a2268 2
	if (mpii_create_sensors(sc) != 0)
		printf("%s: unable to create sensors\n", DEVNAME(sc));
d2270 1
d2276 2
a2277 2
	if (sc->sc_mpii_dev)
		free(sc->sc_mpii_dev, M_DEVBUF);
d2312 1
a2312 2
	struct mpii_reply_descriptor	*rdp;
	u_int8_t			reply_flags;
d2320 2
a2321 3
		reply_flags = (u_int8_t)(rdp->reply_flags) & 
		    MPII_REPLY_DESCR_FLAGS_TYPE_MASK;
		if ((reply_flags == MPII_REPLY_DESCR_FLAGS_UNUSED))
d2323 1
a2323 1
		if (rdp->type_dependent2 == 0xffffffff) {
d2328 3
a2330 1
			printf("%s: ioc is writing a reply\n", DEVNAME(sc));
d2349 1
a2349 5
	struct mpii_ccb		*ccb = arg;
	struct mpii_softc	*sc = ccb->ccb_sc;

	printf("%s: xfer timeout, ccb %d state %d\n", DEVNAME(sc),
	    ccb->ccb_smid, ccb->ccb_state);
a2393 1

d2471 1
a2471 2
	struct mpii_device	*device;
	u_int8_t		flags;
d2473 2
a2474 2
	if ((sc->sc_porttype != MPII_PORTFACTS_PORTTYPE_SAS_PHYSICAL) && 
		(sc->sc_porttype != MPII_PORTFACTS_PORTTYPE_SAS_VIRTUAL)) 
d2477 1
a2477 1
	if (sc->sc_mpii_dev[link->target] == NULL)
d2479 3
a2481 4
		
	device = (struct mpii_device *)sc->sc_mpii_dev[link->target];
	flags = device->flags;	
	if ((flags & MPII_DEV_UNUSED) || (flags & MPII_DEV_HIDDEN))
a2483 2
	sc->sc_mpii_dev[link->target]->flags |= MPII_DEV_SCSI_ML_ATTACH;

d2866 1
a2866 1
	
a2867 2
	sc->sc_ir_firmware = (letoh32(ifp.ioc_capabilities) & 
	    MPII_IOCFACTS_CAPABILITY_INTEGRATED_RAID) ? 1 : 0;    
d2875 5
a2879 1
	
d2883 1
a2883 1
	/* should not be multiple of 16 */ 
d2889 1
a2889 1
	sc->sc_reply_free_qdepth = sc->sc_num_reply_frames + 
d2895 1
a2895 1
	if (sc->sc_reply_post_qdepth > 
d2897 1
a2897 1
		sc->sc_reply_post_qdepth = 
d3032 2
a3033 2
	int			rv = 1, s;
	struct mpii_ccb		*ccb;
d3048 2
a3049 2
	
	bzero(pfq, sizeof(struct mpii_msg_portfacts_request));
d3068 1
a3068 1
	
d3082 1
a3082 1
	DNPRINTF(MPII_D_MISC, "%s:  port_type: 0x%02x\n", DEVNAME(sc), 
a3087 5
	/* XXX JPG no such field in MPI2 .... but the dilemma is what
	 * to return to sc_link.adapter_target ... is -1 acceptable? fake 255?
	if (sc->sc_target == -1)
		sc->sc_target = letoh16(pfp->port_scsi_id);
	*/
d3181 3
a3183 2
	
	if (mpii_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_IOC, 1, 0, &hdr) != 0) {
d3188 1
a3188 1
	
d3218 4
a3221 4
		int	i;					\
								\
		for (i = 0; i < 4; i++)				\
 			enq->event_masks[i] = 0xffffffff;	\
d3224 3
a3226 9
#define MPII_EVENT_UNMASK(enq, evt)	do {				\
		int	i;						\
									\
		for (i = 0; i < 4; i++)					\
			if (evt < 32 * (i + 1)) {			\
				enq->event_masks[i] &=			\
				    htole32(~(1 << (evt - 32 * i)));	\
				break;					\
			}						\
d3273 1
a3273 1
	s = splbio();	
d3281 1
a3281 2
mpii_event_process_ir_cfg_change_list(struct mpii_softc *sc, 
    struct mpii_msg_event_reply *enp)
d3283 3
a3285 6
	struct mpii_evt_ir_cfg_change_list	*ccl;
	struct mpii_evt_ir_cfg_element	*ce;
	struct mpii_device	*device; //, n;
	u_int16_t		type;
	u_int32_t		flags;
	int			i, volid;
d3287 1
a3287 1
	ccl = (struct mpii_evt_ir_cfg_change_list *)(enp + 1);
d3289 3
a3291 1
	flags = letoh32(ccl->flags);
d3293 8
a3300 4
	DNPRINTF(MPII_D_MAP, "%s: mpii_event_process_ir_cfg_change\n", 
	    DEVNAME(sc));
	DNPRINTF(MPII_D_MAP," %s:  flags: 0x%08x num_elements: %d\n",
	    DEVNAME(sc), flags, ccl->num_elements);
d3302 1
a3302 4
	if ((flags & MPII_EVT_IR_CFG_CHANGE_LIST_FLAGS_CFG_MASK) == 
	    MPII_EVT_IR_CFG_CHANGE_LIST_FLAGS_CFG_FOREIGN)
		/* bail on foreign configurations */
		return;
d3306 3
d3313 3
a3315 3
		type = (letoh16(ce->element_flags) & 
		    MPII_EVT_IR_CFG_ELEMENT_EF_ELEMENT_TYPE_MASK);
		
d3317 1
a3317 1
		case MPII_EVT_IR_CFG_ELEMENT_EF_ELEMENT_TYPE_VOLUME:
d3321 20
a3340 39
				/* XXX check for exceeding boundaries */
				volid = sc->sc_vd_id_low + sc->sc_vd_count;

				/* do magic to map vol dev_handle to TID */
				DNPRINTF(MPII_D_MAP, "%s: mapping: attaching "
				    "vol_dev_handle: 0x%04x to volid %d\n", 
				    DEVNAME(sc), letoh16(ce->vol_dev_handle),
				    volid);
			
				if (sc->sc_mpii_dev[volid] == NULL) {
					device = malloc(sizeof(struct mpii_device), 
				    	    M_DEVBUF, M_NOWAIT | M_ZERO);
					if (device == NULL) {
						printf("%s: mpii_event_ir_cfg_change_list "
					    	    "unable to allocate mpii_device\n",
					    	DEVNAME(sc));
						continue;
					}
				
					sc->sc_vd_count++;
					device->type = MPII_DEV_TYPE_VD;
					device->dev_handle = letoh16(ce->vol_dev_handle);
					/* XXX bunch more fields */

					sc->sc_mpii_dev[volid] = device;
					RB_INSERT(mpii_dev_tree, &mpii_dev_head, sc->sc_mpii_dev[volid]);
				} else {
					if (!(sc->sc_mpii_dev[volid]->flags & MPII_DEV_UNUSED)) {
						printf("%s: mpii_evt_ir_cfg_change_list "
					    	    "volume id collision - volid %d\n", 
					    	    DEVNAME(sc), volid);
						continue;
					} else {
						/* sc->sc_mpii_dev[volid] already
						 * exists and is not flagged as
						 * UNUSED so we gracefully (sic)
						 * do nothing at this time.
						 */
					}
d3342 1
a3343 1

d3346 5
a3350 5
				/* do magic to remove volume */
				break;
	
			case MPII_EVT_IR_CFG_ELEMENT_RC_NO_CHANGE:
			default:
d3354 13
a3366 28

		case MPII_EVT_IR_CFG_ELEMENT_EF_ELEMENT_TYPE_VOL_PD:
			switch (ce->reason_code) {		
			case MPII_EVT_IR_CFG_ELEMENT_RC_HIDE:
			case MPII_EVT_IR_CFG_ELEMENT_RC_PD_CREATED:
				/* do magic to hide/tag from OS view */
				//DNPRINTF(MPII_D_MAP, "%s: mapping: hiding "
				 //   "pd_dev_handle: 0x%04x\n", DEVNAME(sc),
				//	letoh16(ce->phys_disk_dev_handle));
				// n.dev_handle = letoh16(ce->phys_disk_dev_handle);
				// device = RB_FIND(mpii_dev_tree, &mpii_dev_head, &n);
				//device = NULL;
				//if (device)
				//	device->flags |= MPII_DEV_HIDDEN;
				break;

			case MPII_EVT_IR_CFG_ELEMENT_RC_UNHIDE:
			case MPII_EVT_IR_CFG_ELEMENT_RC_PD_DELETED:
				/* 
				 * XXX remove evidence of this disk (and no longer
				 * bother to hide it
				 */
				 break;

			case MPII_EVT_IR_CFG_ELEMENT_RC_NO_CHANGE:
			default:
				break;

d3369 10
a3378 6

		case MPII_EVT_IR_CFG_ELEMENT_EF_ELEMENT_TYPE_HSP_PD:
			break;

		default:
			/* XXX oops */
d3385 1
a3385 2
mpii_event_process_sas_topo_change(struct mpii_softc *sc, 
    struct mpii_msg_event_reply *enp)
d3387 1
a3387 1
	struct mpii_evt_sas_topo_change_list	*tcl;
d3389 2
a3390 5
	u_int8_t		reason_code;
	struct mpii_device	*device;
	int			i, slotid;

	tcl = (struct mpii_evt_sas_topo_change_list *)(enp + 1);
d3392 1
a3392 3
	DNPRINTF(MPII_D_MAP, "%s: sas_topo_change: start_phy_num: %d "
	    "num_entries: %d physical_port %d\n", DEVNAME(sc), 
	    tcl->start_phy_num, tcl->num_entries, tcl->physical_port);
d3394 1
a3394 1
	if (tcl->num_entries <= 0)
d3400 12
a3411 27
		reason_code = (pe->phy_status & MPII_EVENT_SAS_TOPO_PS_RC_MASK);

		switch (reason_code) {
		case MPII_EVENT_SAS_TOPO_PS_RC_TARG_ADDED:
			/* XXX begging to move this into a f() */
			DNPRINTF(MPII_D_MAP, "%s: mapping: attached_dev_handle: "
			    "0x%04x  link_rate: 0x%02x phy_status: 0x%02x\n", 
			    DEVNAME(sc), letoh16(pe->attached_dev_handle),
		    	    pe->link_rate, pe->phy_status);
			
			/* XXX check for exceeding boundaries */
			slotid = sc->sc_pd_id_start + tcl->start_phy_num + i;
			
			if (sc->sc_mpii_dev[slotid])
				if (!(sc->sc_mpii_dev[slotid]->flags & MPII_DEV_UNUSED)) {
					printf("%s: mpii_evt_sas_topo_change "
					    "slot id collision - slot %d\n", 
					    DEVNAME(sc), slotid);
					continue;
				}	

			device = malloc(sizeof(struct mpii_device), 
			    M_DEVBUF, M_NOWAIT | M_ZERO);
			if (device == NULL) {
				printf("%s: mpii_event_ir_cfg_change_list "
				    "unable to allocate mpii_device\n",
				    DEVNAME(sc));
d3414 3
a3416 5
			
			sc->sc_pd_count++;		
			device->dev_handle = letoh16(pe->attached_dev_handle);
			device->phy_num = tcl->start_phy_num + i;
			device->type = MPII_DEV_TYPE_PD;
d3418 15
a3432 9
				device->physical_port = tcl->physical_port;
			device->enclosure_handle = letoh16(tcl->enclosure_handle);
			device->expander_dev_handle = letoh16(tcl->expander_dev_handle);
			/* XXX
			device->wwid = 
			device->flags =
			*/
			sc->sc_mpii_dev[slotid] = device;
			RB_INSERT(mpii_dev_tree, &mpii_dev_head, device);
d3434 16
a3449 15

		case MPII_EVENT_SAS_TOPO_PS_RC_TARG_NO_RESPOND_MISS:
			/* according to MPI2 we need to:
			 * a. abort all outstanding I/O operations
			 * b. send a SAS IO unit control request w/ operation
			 *    set to MPII_SAS_OP_REMOVE_DEVICE to remove all IOC
			 *    resources associated with the device.
			 */
		case MPII_EVENT_SAS_TOPO_PS_RC_PHY_LINK_STATE_CHANGE:
		case MPII_EVENT_SAS_TOPO_PS_RC_PHY_LINK_STATE_NOCHNG:
		case MPII_EVENT_SAS_TOPO_PS_RC_WITHIN_DELAY_TIMER:
		default:
			DNPRINTF(MPII_D_EVT, "%s: unhandled "
			    "mpii_event_sas_topo_change reason code\n", 
			    DEVNAME(sc));
a3455 39
mpii_event_process_sas_discovery(struct mpii_softc *sc, struct mpii_msg_event_reply *enp)
{
	struct mpii_evt_sas_discovery	*ds;

	ds = (struct mpii_evt_sas_discovery *)(enp + 1);

	if ((ds->flags & MPII_EVENT_SAS_DISC_FLAGS_DISC_IN_PROG_MASK) == 
	    MPII_EVENT_SAS_DISC_FLAGS_DISC_IN_PROGRESS)
		sc->sc_discovery_in_progress = 1;
	else
		sc->sc_discovery_in_progress = 0;

	switch (ds->reason_code) {
	case MPII_EVENT_SAS_DISC_REASON_CODE_STARTED:
		break;
	case MPII_EVENT_SAS_DISC_REASON_CODE_COMPLETED:
		/* XXX look at ds->discovery_status */
		break;
	default:
		DNPRINTF(MPII_D_EVT, "%s: unknown reason for SAS device status "
		    "change: 0x%02x\n", DEVNAME(sc), ds->reason_code);
		break;
	}
}

void
mpii_event_process_ir_phys_disk(struct mpii_softc *sc, struct mpii_msg_event_reply *enp)
{
	struct mpii_evt_ir_physical_disk	*ipd;

	ipd = (struct mpii_evt_ir_physical_disk *)(enp + 1);

	/* XXX TODO:
	 *     process the event fully
	 *     understand that this is necesarily a IR_PD
	 */
}

void
d3458 1
a3458 1
	struct mpii_msg_event_reply		*enp = (struct mpii_msg_event_reply *)prm;
d3460 1
a3460 1
	DNPRINTF(MPII_D_EVT, "%s: mpii_event_process\n", DEVNAME(sc));
d3462 1
a3462 10
	DNPRINTF(MPII_D_EVT, "%s:  function: 0x%02x msg_length: %d "
	    "event_data_length: %d\n", DEVNAME(sc), enp->function, 
	    enp->msg_length, letoh16(enp->event_data_length));
	DNPRINTF(MPII_D_EVT, "%s:  ack_required: %d msg_flags 0x%02x\n",
	    DEVNAME(sc), enp->ack_required, enp->msg_flags);
	DNPRINTF(MPII_D_EVT, "%s:  ioc_status: 0x%04x\n", DEVNAME(sc),
	    letoh16(enp->ioc_status));
	DNPRINTF(MPII_D_EVT, "%s:  ioc_loginfo: 0x%08x\n", DEVNAME(sc),
	    letoh32(enp->ioc_loginfo));
	DNPRINTF(MPII_D_EVT, "%s:  event: 0x%08x\n", DEVNAME(sc),
d3464 1
a3464 3
	DNPRINTF(MPII_D_EVT, "%s:  event_context: 0x%08x\n", DEVNAME(sc),
	    letoh32(enp->event_context));
	
d3466 13
a3478 2
	case MPII_EVENT_SAS_DISCOVERY:
		mpii_event_process_sas_discovery(sc, enp);
a3479 1

d3481 1
a3481 1
		mpii_event_process_sas_topo_change(sc, enp);
a3482 1

a3483 1
		/* XXX */
a3484 1

a3485 1
		/* XXX track enclosures coming/going */
d3487 14
d3502 17
a3518 2
	case MPII_EVENT_IR_VOLUME:
		/* XXX */
a3519 1

a3520 1
		mpii_event_process_ir_phys_disk(sc, enp);
a3521 1

d3523 1
a3523 1
		mpii_event_process_ir_cfg_change_list(sc, enp);
d3525 4
d3530 6
a3535 4
	case MPII_EVENT_IR_OPERATION_STATUS:
	case MPII_EVENT_TASK_SET_FULL:
	case MPII_EVENT_LOG_ENTRY_ADDED:

a3538 1
		break;
d3541 27
a3567 5
#ifdef MPII_DEBUG
	int i;
	for (i = 0; i < enp->event_data_length; i++) {
		DNPRINTF(MPII_D_EVT, "%s:  event_data: 0x%08x\n", DEVNAME(sc),
		    dwordn((enp+1), i));
a3568 1
#endif /* MPII_DEBUG */
d3570 2
a3571 3
	if (enp->ack_required)
		mpii_eventack(sc, enp);
}	
d3574 1
a3574 1
mpii_eventnotify_done(struct mpii_ccb *ccb)
d3576 24
a3599 1
	struct mpii_softc			*sc = ccb->ccb_sc;
d3601 3
a3603 1
	DNPRINTF(MPII_D_EVT, "%s: mpii_eventnotify_done\n", DEVNAME(sc));
d3605 5
a3609 1
	mpii_event_process(sc, ccb->ccb_rcb->rcb_reply);
d3611 8
a3618 2
	mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
	mpii_put_ccb(sc, ccb);
d3639 2
a3640 2
	
	page = malloc(pagelen, M_TEMP, M_NOWAIT | M_CANFAIL);
d3674 1
a3674 1
	flags = page->ir_volume_mapping_flags && 
d3676 1
a3676 1
	if (sc->sc_ir_firmware) {
d3931 1
a3931 1
mpii_reply(struct mpii_softc *sc, struct mpii_reply_descriptor *rdp)
d3935 1
a3935 2
	u_int8_t		reply_flags;
	u_int32_t		i;
a3937 1

d3940 4
a3943 14
	DNPRINTF(MPII_D_INTR, "%s:  dword[0]: 0x%08x\n", DEVNAME(sc), 
	    letoh32(dwordn(rdp, 0)));
	DNPRINTF(MPII_D_INTR, "%s:  dword[1]: 0x%08x\n", DEVNAME(sc), 
	    letoh32(dwordn(rdp, 1)));

	reply_flags = (u_int8_t)(rdp->reply_flags) & 
	    MPII_REPLY_DESCR_FLAGS_TYPE_MASK;

	/* smid */
	smid = letoh16(rdp->type_dependent1);

	if (reply_flags == MPII_REPLY_DESCR_FLAGS_ADDRESS_REPLY) {
		/* reply frame address */
		i = (letoh32(rdp->type_dependent2) -
d3947 1
a3947 1
		    MPII_DMA_MAP(sc->sc_replies), MPII_REPLY_SIZE * i,
d3950 1
a3950 1
		rcb = &sc->sc_rcbs[i];
d3953 3
a3955 2
	DNPRINTF(MPII_D_INTR, "%s: mpii_reply reply_flags: %d smid: %d reply: %p\n",
	    DEVNAME(sc), reply_flags, smid, rcb->rcb_reply);
d3959 2
a3960 2
	bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_reply_postq), 
	    8 * sc->sc_reply_post_host_index, 8, 
a3964 5
		if (ccb->ccb_state != MPII_CCB_QUEUED) {
			printf("%s: orphaned ccb %d state %d\n", DEVNAME(sc),
			    smid, ccb->ccb_state);
			return (smid);
		}
d3982 1
a3982 1
	mdm = malloc(sizeof(struct mpii_dmamem), M_DEVBUF, M_NOWAIT | M_ZERO);
d4039 6
a4044 7
	DNPRINTF(MPII_D_MEM, "%s: mpii_alloc_dev: sc_max_devices: %d "
	    "sizeof(sc_mpii_dev): %d\n", DEVNAME(sc), sc->sc_max_devices,
	    sizeof(struct mpii_device *) * sc->sc_max_devices);

	sc->sc_mpii_dev = malloc(sc->sc_max_devices * 
	    sizeof(struct mpii_device *), M_DEVBUF, 
	    M_NOWAIT | M_CANFAIL | M_ZERO);
d4046 4
a4049 1
	if (sc->sc_mpii_dev == NULL) 
d4051 29
d4081 4
a4084 1
	return (0);
d4096 2
a4097 2
	sc->sc_ccbs = malloc(sizeof(struct mpii_ccb) * (sc->sc_request_depth-1),
	    M_DEVBUF, M_NOWAIT | M_CANFAIL | M_ZERO);
d4112 3
a4114 3
	/* 
	 * we have sc->sc_request_depth system request message 
	 * frames, but smid zero cannot be used. so we then 
d4197 1
a4197 1
	    M_DEVBUF, M_NOWAIT | M_CANFAIL);
d4201 2
a4202 2
	sc->sc_replies = mpii_dmamem_alloc(sc, 
	    MPII_REPLY_SIZE * sc->sc_num_reply_frames);
d4231 1
a4231 1
void 
d4233 1
a4233 1
{	
d4235 2
a4236 2
	struct mpii_request_descriptor	descriptor;
	u_int32_t			*rdp = (uint32_t *)&descriptor;
d4243 1
a4243 1
	bzero(&descriptor, sizeof(struct mpii_request_descriptor));
d4246 7
a4252 11
	case	MPII_FUNCTION_SCSI_IO_REQUEST:
			descriptor.request_flags = 
			    MPII_REQ_DESCRIPTOR_FLAGS_SCSI_IO;
			/* device handle */
			descriptor.type_dependent = 
			    htole16(ccb->ccb_dev_handle);
			break;
	case	MPII_FUNCTION_SCSI_TASK_MGMT:
			descriptor.request_flags =
			    MPII_REQ_DESCRIPTOR_FLAGS_HIGH_PRIORITY;
			break;
d4254 1
a4254 2
			descriptor.request_flags = 
			    MPII_REQ_DESCRIPTOR_FLAGS_DEFAULT;
d4257 2
a4258 2
	descriptor.vf_id = sc->sc_vf_id;
	descriptor.smid = htole16(ccb->ccb_smid);
d4266 2
a4267 2
	DNPRINTF(MPII_D_RW, "%s:   MPII_REQ_DESC_POST_LOW (0x%08x) write "
	    "0x%08x\n", DEVNAME(sc), MPII_REQ_DESC_POST_LOW, *rdp);
d4269 2
a4270 2
	DNPRINTF(MPII_D_RW, "%s:   MPII_REQ_DESC_POST_HIGH (0x%08x) write "
	    "0x%08x\n", DEVNAME(sc), MPII_REQ_DESC_POST_HIGH, *(rdp+1)); 
d4272 2
a4273 2
	mpii_write(sc, MPII_REQ_DESC_POST_LOW, htole32(*rdp));
	mpii_write(sc, MPII_REQ_DESC_POST_HIGH, htole32(*(rdp+1)));
d4279 1
a4279 2
	struct mpii_reply_descriptor	*rdp;
	u_int8_t			reply_flags;
d4283 4
a4286 2
	    timeout); 
	
d4292 1
a4292 2

			delay(1000);
d4300 2
a4301 3
		reply_flags = (u_int8_t)(rdp->reply_flags) & 
		    MPII_REPLY_DESCR_FLAGS_TYPE_MASK;
		if ((reply_flags == MPII_REPLY_DESCR_FLAGS_UNUSED))
d4303 1
a4303 1
		if (rdp->type_dependent2 == 0xffffffff) {
d4391 2
a4392 1
	DNPRINTF(MPII_D_CMD, "%s: mpii_poll\n", DEVNAME(sc));
a4393 1
	DNPRINTF(MPII_D_CMD, "   ccb->ccb_cmd: 0x%08x\n", DEVNAME(sc), ccb->ccb_cmd);
d4410 1
d4429 9
d4448 1
a4448 1
	
d4454 1
d4463 1
a4463 2
	ccb->ccb_dev_handle = io->dev_handle =
	    htole16(sc->sc_mpii_dev[link->target]->dev_handle);
a4474 1
		break;
d4498 1
a4498 1
	    sizeof(struct mpii_ccb_bundle), 
d4500 1
a4500 1
	
d4506 1
a4506 1
	    io->sgl_offset0); 
d4512 1
d4520 1
a4520 1
	timeout_add(&xs->stimeout, (xs->timeout * 1000) / hz);
d4567 1
a4567 1
	    "function: 0x%02x\n", DEVNAME(sc), letoh16(sie->dev_handle), 
d4586 1
a4586 1
	
d4588 1
a4588 1
	switch (letoh16(sie->ioc_status)) {
a4613 1
			break;
a4630 1
		break;
a4671 1

a4675 1

a4679 1

d4691 2
d4696 4
a4699 4

	bi->bi_nodisk = sc->sc_pd_count;
	bi->bi_novol = sc->sc_vd_count;

d4708 1
d4710 1
a4710 1
	struct device			*dev;
d4718 1
a4718 1
	if (bv->bv_volid > sc->sc_vd_count)
d4720 1
a4720 2

	volh = sc->sc_mpii_dev[sc->sc_vd_id_low + bv->bv_volid]->dev_handle;
a4744 2
	bv->bv_percent = -1;

a4746 12
		switch (letoh32(vpg->volume_status)) {
		case MPII_CFG_RAID_VOL_0_STATUS_SCRUB:
			bv->bv_status = BIOC_SVSCRUB;
			break;
		case MPII_CFG_RAID_VOL_0_STATUS_RESYNC:
			bv->bv_status = BIOC_SVREBUILD;
			break;
		default:
			bv->bv_status = BIOC_SVONLINE;
			break;
		}
		break;
d4751 6
a4756 1
		bv->bv_status = BIOC_SVDEGRADED;
a4781 1
		break;
d4795 2
a4796 2
		dev = lnk->device_softc;
		strlcpy(bv->bv_dev, dev->dv_xname, sizeof(bv->bv_dev));
d4809 1
d4817 1
a4817 1
	if (bd->bd_volid > sc->sc_vd_count)
d4819 1
a4819 2

	volh = sc->sc_mpii_dev[sc->sc_vd_id_low + bd->bd_volid]->dev_handle;
d4930 1
a4930 1
	struct mpii_cfg_raid_physdisk_pg0	ppg;
d4932 1
d4935 2
a4936 2
	DNPRINTF(MPII_D_IOCTL, "%s: mpii_bio_disk %d\n",
	    DEVNAME(sc), bd->bd_diskid);
d4938 6
a4943 2
	if (bd->bd_volid > sc->sc_vd_count)
		return (ENODEV);
d4946 1
a4946 1
	hdr.page_length = sizeof(ppg) / 4;
d4951 1
a4951 1
	    &hdr, 1, &ppg, sizeof(ppg)) != 0) {
d4957 1
a4957 2
	if (mpii_bio_getphy(sc, letoh16(ppg.dev_handle), &bd->bd_target))
		bd->bd_target = letoh16(ppg.phys_disk_num);
d4959 6
a4964 1
	switch (ppg.phys_disk_state) {
d4970 1
a4970 1
		if (ppg.offline_reason ==
d4972 1
a4972 1
		    ppg.offline_reason ==
d4995 1
a4995 1
	bd->bd_size = letoh64(ppg.dev_max_lba) * letoh16(ppg.block_size);
d4997 1
a4997 1
	scsi_strvis(bd->bd_vendor, ppg.vendor_id, sizeof(ppg.vendor_id));
d5000 3
a5002 3
	scsi_strvis(&bd->bd_vendor[len + 1], ppg.product_id,
	    sizeof(ppg.product_id));
	scsi_strvis(bd->bd_serial, ppg.serial, sizeof(ppg.serial));
d5007 2
a5008 2
int
mpii_bio_getphy(struct mpii_softc *sc, u_int16_t dh, u_int16_t *port)
d5010 1
a5010 2
	struct mpii_cfg_sas_dev_pg0	spg;
	struct mpii_ecfg_hdr		ehdr;
d5012 6
a5017 18
	if (!port)
		return (EINVAL);

	bzero(&ehdr, sizeof(ehdr));
	ehdr.page_type = MPII_CONFIG_REQ_PAGE_TYPE_EXTENDED;
	ehdr.ext_page_length = htole16(sizeof(spg) / 4);
	ehdr.ext_page_type = MPII_CONFIG_REQ_PAGE_TYPE_SAS_DEVICE;

	if (mpii_req_cfg_page(sc, MPII_CFG_SAS_DEV_ADDR_HANDLE | dh,
	    MPII_PG_EXTENDED, &ehdr, 1, &spg, sizeof(spg)) != 0) {
		printf("%s: unable to fetch sas device page 0\n",
		    DEVNAME(sc));
		return (EINVAL);
	}

	*port = spg.phy_num;

	return (0);
d5021 3
d5029 1
d5033 1
a5033 1
	if (bv->bv_volid > sc->sc_vd_count)
d5035 1
a5035 2

	volh = sc->sc_mpii_dev[sc->sc_vd_id_low + bv->bv_volid]->dev_handle;
d5045 1
a5045 1
	vpg = malloc(pagelen, M_TEMP, M_NOWAIT | M_CANFAIL | M_ZERO);
a5061 12
		switch (letoh32(vpg->volume_status)) {
		case MPII_CFG_RAID_VOL_0_STATUS_SCRUB:
			bv->bv_status = BIOC_SVSCRUB;
			break;
		case MPII_CFG_RAID_VOL_0_STATUS_RESYNC:
			bv->bv_status = BIOC_SVREBUILD;
			break;
		default:
			bv->bv_status = BIOC_SVONLINE;
			break;
		}
		break;
d5066 5
a5070 1
		bv->bv_status = BIOC_SVDEGRADED;
d5098 1
d5103 2
a5104 1
	for (i = 0; i < sc->sc_vd_count; i++) {
d5139 1
a5139 1
	for (i = 0; i < sc->sc_vd_count; i++) {
a5143 1

a5148 1

d5153 4
a5156 2

		case BIOC_SVSCRUB:
a5160 1

@


1.12
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.11 2010/03/09 19:29:14 marco Exp $	*/
a27 1
#include <sys/proc.h>
@


1.11
log
@- push replies back to the free queue when done processing events
  so that we won't accidentally run out of replies;
- tell ioc our reply post host index right away in the mpii_complete;
- don't try to call ccb_done of the unqueued ccb;
- decrease poll timeouts in req_cfg_header and req_cfg_page by the
  factor of 10 (5 seconds is pretty much enough);
- add facility to calculate event masks and get rid of the Task Set
  Full event;
- alter openings as we have (request_depth - 1) ccbs actually;
- promote printfs in the mpii_bio_volstate to the MISC debug level;
- rototil some more disabled and experimetal code.

from Mike Belopuhov <mkb@@crypt.org.ru>

specific ok from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mpii.c,v 1.10 2010/03/07 14:10:59 marco Exp $	*/
d2026 1
a2026 1
int		mpii_scsi_cmd(struct scsi_xfer *);
d4440 1
a4440 1
int
d4463 1
a4463 1
		return (COMPLETE);
d4469 7
a4475 2
	if (ccb == NULL)
		return (NO_CCB);
d4521 1
a4521 1
		return (COMPLETE);
d4544 1
a4544 1
		return (COMPLETE);
a4556 1
	return (SUCCESSFULLY_QUEUED);
@


1.10
log
@Make NO_CCB do its thing and by proxy mpii gets a much funner number of
openings.

Delete some dead and experimental code.

From: Mike Belopuhov <mkb@@crypt.org.ru>
@
text
@d1 1
a1 1
/* $OpenBSD: mpii.c,v 1.9 2010/02/25 02:05:41 marco Exp $ */
a7 1
 *
a402 1

a510 1

a1486 26
struct mpii_cfg_bios_pg2 {
	struct mpii_cfg_hdr	config_header;

	u_int32_t		reserved1[6];

	u_int8_t		req_boot_device_form;
#define MPII_CFG_BIOS_PG2_DEVICE_FORM_MASK		(0xf)
#define	MPII_CFG_BIOS_PG2_DEVICE_FORM_NO_BOOT_DEVICE	(0x0)
#define MPII_CFG_BIOS_PG2_DEVICE_FORM_SAS_WWID		(0x5)
#define MPII_CFG_BIOS_PG2_DEVICE_FORM_ENCLOSURE_SLOT	(0x6)
#define MPII_CFG_BIOS_PG2_DEVICE_FORM_DEVICE_NAME	(0x7)
	u_int8_t		reserved2[3];

	u_int32_t		a;	

	u_int8_t		req_alt_boot_device_form;
	u_int8_t		reserved3[3];

	u_int32_t		b;

	u_int8_t		current_boot_device_form;
	u_int8_t		reserved4[3];

	u_int32_t		c;
} __packed;

a1873 2
	struct mpii_cfg_dpm_pg0	*sc_dpm_pg0;
	struct mpii_cfg_bios_pg2 *sc_bios_pg2;
a2118 3
int		mpii_get_dpm(struct mpii_softc *);
int		mpii_get_dpm_pg0(struct mpii_softc *, struct mpii_cfg_dpm_pg0 *);
int 		mpii_get_bios_pg2(struct mpii_softc *);
d2208 1
a2208 1
	
d2238 1
a2238 1
	}	
a2244 8
#if 0
	if (mpii_get_dpm(sc) != 0) {
		printf("%s: unable to get driver persistent mapping\n",
		    DEVNAME(sc));
		goto free_queues;
	}
#endif

d2247 1
a2247 1
		goto free_dpm;
d2255 1
a2255 1
			goto free_dpm;
d2262 1
a2262 1
		goto free_dpm;
a2270 5
	if (mpii_get_bios_pg2(sc) != 0) {
		printf("%s: unable to get bios page 2\n", DEVNAME(sc));
		goto free_dev;	
	}

d2279 1
a2279 1
	sc->sc_link.openings = sc->sc_request_depth;
a2305 3
	if (sc->sc_bios_pg2)
		free(sc->sc_bios_pg2, M_TEMP);

a2309 4
free_dpm:
	if (sc->sc_dpm_pg0)
		free(sc->sc_dpm_pg0, M_DEVBUF);

d3259 18
d3298 2
a3299 1
	/* enable reporting of the following events:	
a3301 1
	 * XXX remove MPII_EVENT_SAS_BROADCAST_PRIMITIVE
a3308 2
	 * MPII_EVENT_TASK_SET_FULL
	 * MPII_EVENT_LOG_ENTRY_ADDED
d3311 9
a3319 5
	/* XXX dynamically build event mask */
	enq->event_masks[0] = htole32(0x0f2f3fff);
	enq->event_masks[1] = htole32(0xfffffffc);
	enq->event_masks[2] = htole32(0xffffffff);
	enq->event_masks[3] = htole32(0xffffffff);
a3671 218
mpii_get_bios_pg2(struct mpii_softc *sc)
{
	struct mpii_cfg_hdr	hdr;
	size_t			pagelen;
	int			rv = 0;

	DNPRINTF(MPII_D_RAID, "%s: mpii_get_bios_pg2\n", DEVNAME(sc));

	if (mpii_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_BIOS, 2, 0, &hdr) != 0) {
		DNPRINTF(MPII_D_RAID, "%s: mpii_get_bios_pg2 unable to fetch "
		    "header for BIOS page 2\n", DEVNAME(sc));
		return (1);
	}

	pagelen = hdr.page_length * 4;
	sc->sc_bios_pg2 = malloc(pagelen, M_TEMP, M_NOWAIT | M_CANFAIL);
	if (sc->sc_bios_pg2 == NULL) {
		DNPRINTF(MPII_D_RAID, "%s: mpii_get_bios_pg2 unable to "
		    "allocate space for BIOS page 2\n", DEVNAME(sc));
		return (1);
	}

	if (mpii_cfg_page(sc, 0, &hdr, 1, sc->sc_bios_pg2, pagelen) != 0) {
		DNPRINTF(MPII_D_RAID, "%s: mpii_get_bios_pg2 unable to "
		    "fetch BIOS config page 2\n", DEVNAME(sc));
		rv = 1;
		goto out;
	}

	DNPRINTF(MPII_D_RAID, "%s: req_boot_device_form: 0x%02x "
	    "req_alt_boot_device_form: 0x%02x current_boot_device_form: "
	    "0x%02x\n", DEVNAME(sc), sc->sc_bios_pg2->req_boot_device_form, 
	    sc->sc_bios_pg2->req_alt_boot_device_form, 
	    sc->sc_bios_pg2->current_boot_device_form);

out:
	free(sc->sc_bios_pg2, M_TEMP);

	return (rv);
}

int
mpii_get_dpm(struct mpii_softc *sc)
{
	/* XXX consider expanding (or is that reducing) functionality to support
	 * non-dpm mode of operation when the following fails, but iocfacts
	 * indicated that the ioc supported dmp
	 */
	if (!sc->sc_dpm_enabled) 
		return (1);

	if (mpii_get_dpm_pg0(sc, sc->sc_dpm_pg0) != 0) 
		return (1);
	
	return (0);
}

int
mpii_get_dpm_pg0(struct mpii_softc *sc, struct mpii_cfg_dpm_pg0 *dpm_page)
{
	struct mpii_msg_config_request		*cq;
	struct mpii_msg_config_reply		*cp;
	struct mpii_ccb				*ccb;
	struct mpii_dpm_entry	*dpm_entry;
	struct mpii_ecfg_hdr	ehdr;
	struct mpii_dmamem	*dmapage;
	u_int64_t		dva;
	char			*kva;
	size_t			pagelen;
	u_int32_t		address;
	int			rv = 0, s;

	DNPRINTF(MPII_D_RAID, "%s: mpii_get_dpm_pg0\n", DEVNAME(sc));

	if (mpii_ecfg_header(sc, 
	    MPII_CONFIG_REQ_PAGE_TYPE_DRIVER_MAPPING, 0, 0, &ehdr)) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_get_dpm_pg0 unable to fetch"
		    " header for driver mapping page 0\n", DEVNAME(sc));
		return (1);
	}

	pagelen = sizeof(struct mpii_ecfg_hdr) + sc->sc_max_dpm_entries * 
	    sizeof(struct mpii_dpm_entry);
	
	dpm_page = malloc(pagelen, M_TEMP, M_NOWAIT | M_CANFAIL);
	if (dpm_page == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_get_dpm_pg0 unable to allocate "
		    "space for device persistence mapping page 0\n", DEVNAME(sc));
		return (1);
	}
	
	dmapage = mpii_dmamem_alloc(sc, pagelen);
	if (dmapage == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_get_dpm_pg0 unable to allocate "
		    "space for dpm dma buffer\n", DEVNAME(sc));
		return (1);
	}

	/* the current mpii_req_cfg_page() (and associated macro wrappers) do
	 * not allow large page length nor is is flexible in allowing actions
	 * other that READ_CURRENT or WRITE_CURRENT. since we need to READ_NVRAM
	 * and we need a pagelength around 2580 bytes this function currently
	 * manually creates and drives the config request.
	 *  
	 * XXX modify the mpii_req_cfg_page() to allow the caller to specify:
	 *     - alternate actions
	 *     - use passed-in dma-able buffer OR allocate within function if
	 *     the page length exceeds the left over space in the request frame
	 */

	s = splbio();
	ccb = mpii_get_ccb(sc);
	splx(s);
	if (ccb == NULL) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_get_dpm_pg0 ccb_get\n", DEVNAME(sc));
		return (1);
	}

	address = sc->sc_max_dpm_entries << MPII_DPM_ADDRESS_ENTRY_COUNT_SHIFT;

	cq = ccb->ccb_cmd;

	cq->function = MPII_FUNCTION_CONFIG;
	cq->action = MPII_CONFIG_REQ_ACTION_PAGE_READ_NVRAM;
	
	cq->config_header.page_version = ehdr.page_version;
	cq->config_header.page_number = ehdr.page_number;
	cq->config_header.page_type = ehdr.page_type;
	cq->ext_page_len = htole16(pagelen / 4);
	cq->ext_page_type = ehdr.ext_page_type;
	cq->config_header.page_type &= MPII_CONFIG_REQ_PAGE_TYPE_MASK;
	cq->page_address = htole32(address);
	cq->page_buffer.sg_hdr = htole32(MPII_SGE_FL_TYPE_SIMPLE |
	    MPII_SGE_FL_LAST | MPII_SGE_FL_EOB | MPII_SGE_FL_EOL |
	    (pagelen * 4) | MPII_SGE_FL_DIR_IN);
	 
	dva = MPII_DMA_DVA(dmapage);
	cq->page_buffer.sg_hi_addr = htole32((u_int32_t)(dva >> 32));
	cq->page_buffer.sg_lo_addr = htole32((u_int32_t)dva);

/*	kva = ccb->ccb_cmd;
	kva += sizeof(struct mpii_msg_config_request);
*/
	//kva = MPII_DMA_KVA(page);

  	ccb->ccb_done = mpii_empty_done; 
	if (mpii_poll(sc, ccb, 50000) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_cfg_header poll\n",
		    DEVNAME(sc));
		return (1);
	}

	if (ccb->ccb_rcb == NULL) {
		mpii_put_ccb(sc, ccb);
		return (1);
	}
	cp = ccb->ccb_rcb->rcb_reply;

	DNPRINTF(MPII_D_MISC, "%s:  action: 0x%02x sglflags: 0x%02x "
	    "msg_length: %d function: 0x%02x\n", DEVNAME(sc), cp->action, 
	    cp->msg_length, cp->function);
	DNPRINTF(MPII_D_MISC, "%s:  ext_page_length: %d ext_page_type: 0x%02x "
	    "msg_flags: 0x%02x\n", DEVNAME(sc),
	    letoh16(cp->ext_page_length), cp->ext_page_type,
	    cp->msg_flags);
	DNPRINTF(MPII_D_MISC, "%s:  vp_id: 0x%02x vf_id: 0x%02x\n", DEVNAME(sc),
	    cp->vp_id, cp->vf_id);
	DNPRINTF(MPII_D_MISC, "%s:  ioc_status: 0x%04x\n", DEVNAME(sc),
	    letoh16(cp->ioc_status));
	DNPRINTF(MPII_D_MISC, "%s:  ioc_loginfo: 0x%08x\n", DEVNAME(sc),
	    letoh32(cp->ioc_loginfo));
	DNPRINTF(MPII_D_MISC, "%s:  page_version: 0x%02x page_length: %d "
	    "page_number: 0x%02x page_type: 0x%02x\n", DEVNAME(sc),
	    cp->config_header.page_version,
	    cp->config_header.page_length,
	    cp->config_header.page_number,
	    cp->config_header.page_type);

	kva = MPII_DMA_KVA(dmapage);

#ifdef MPII_DEBUG
	int i, j;
	for (i = 0; i < sc->sc_max_dpm_entries; i++) {
		printf(" (%d) ", i);
		for (j = 0; j < sizeof(struct mpii_dpm_entry); j++)
			printf("%x", (char *)(kva + j + (i * sizeof(struct mpii_dpm_entry))));
		printf("\n");
	}
#endif

	if (letoh16(cp->ioc_status) != MPII_IOCSTATUS_SUCCESS)
		rv = 1;
	/*else
		bcopy(kva, page, pagelen);
*/
	mpii_push_reply(sc, ccb->ccb_rcb->rcb_reply_dva);
	mpii_put_ccb(sc, ccb);

	dpm_entry = (struct mpii_dpm_entry *)(kva + sizeof(struct mpii_ecfg_hdr));
	
//	bcopy(dpm_page, cp, pagelen * 4);

#ifdef MPII_DEBUG 
	for (i = 0; i < sc->sc_max_dpm_entries; i++, dpm_entry++)
		printf("%s:  [%d] physid: 0x%lx mappinginfo: 0x%04x devindex: 0x%04x "
		    "physicabitsmapping: 0x%08x\n", DEVNAME(sc), i,
		    letoh64(dpm_entry->physical_identifier), 
		    letoh16(dpm_entry->mapping_information),
		    letoh16(dpm_entry->device_index), 
		    letoh32(dpm_entry->physical_bits_mapping));
#endif

	free(dpm_page, M_TEMP);
	mpii_dmamem_free(sc, dmapage);
	return (rv);
}

int
a3714 13
#if 0
	if (!(page->flags & MPII_IOC_PG8_FLAGS_ENCLOSURE_SLOT_MAPPING))
		/* XXX we don't currently handle persistent mapping mode */
		printf("%s: warning: controller requested device persistence "
		    "mapping mode is not supported.\n");
#endif

	sc->sc_max_dpm_entries = page->max_persistent_entries;
	sc->sc_dpm_enabled = (sc->sc_max_dpm_entries) ? 1 : 0;

	if (page->flags & MPII_IOC_PG8_FLAGS_DISABLE_PERSISTENT_MAPPING)
		sc->sc_dpm_enabled = 0;

d3794 1
a3794 1
		if (mpii_poll(sc, ccb, 50000) != 0) {
d3925 1
a3925 1
		if (mpii_poll(sc, ccb, 50000) != 0) {
d4011 1
a4011 1
		
d4026 5
d4034 1
a4034 1
	} else
d4036 2
d4349 1
d4358 1
a4360 2
	mpii_write_reply_post(sc, sc->sc_reply_post_host_index);

d5077 2
a5078 2
		printf("%s: unable to fetch header for raid volume page 0\n",
		    DEVNAME(sc));
d5085 1
a5085 1
		printf("%s: unable to allocate space for raid "
d5092 1
a5092 1
		printf("%s: unable to fetch raid volume page 0\n",
@


1.9
log
@- endianness fixes in then bioctl code;
- recognize additional volume and drive states;
- make use of the disk vendor_id as it makes sense for sas drives;
- fixup offline_reason definitions;
- bring back nitems that was removed unintentionaly;
- remove unused mpii_get_raid_config_pg0.

from <mkb@@crypt.org.ru>
@
text
@d1 1
a1 1
/* $OpenBSD: mpii.c,v 1.8 2010/02/20 19:37:14 marco Exp $ */
a1129 20
/*
struct mpii_cfg_raid_vol_pg0 {
	u_int8_t		vol_id;
	u_int8_t		vol_bus;
	u_int8_t		vol_ioc;
	u_int8_t		vol_page;

	u_int8_t		vol_type;
#define MPII_CFG_RAID_TYPE_RAID_IS			(0x00)
#define MPII_CFG_RAID_TYPE_RAID_IME			(0x01)
#define MPII_CFG_RAID_TYPE_RAID_IM			(0x02)
#define MPII_CFG_RAID_TYPE_RAID_5			(0x03)
#define MPII_CFG_RAID_TYPE_RAID_6			(0x04)
#define MPII_CFG_RAID_TYPE_RAID_10			(0x05)
#define MPII_CFG_RAID_TYPE_RAID_50			(0x06)
	u_int8_t		flags;
#define MPII_CFG_RAID_VOL_INACTIVE	(1<<3)
	u_int16_t		reserved;
} __packed;
*/
d1740 1
a1740 2
#define MPII_MAX_REQUEST_CREDIT		(500)
#define	MPII_MAX_REPLY_POST_QDEPTH	(128)
a1898 3
	size_t			sc_fw_len;
	struct mpii_dmamem	*sc_fw;

a1902 4
	struct mpii_cfg_hdr	sc_cfg_hdr;
	struct mpii_cfg_ioc_pg2	*sc_vol_page;
	struct mpii_cfg_raid_vol *sc_vol_list;
	struct mpii_cfg_raid_vol_pg0 *sc_rpg0;
d2125 1
a2125 4
/*
void		mpii_get_raid(struct mpii_softc *);
int		mpii_fwupload(struct mpii_softc *);
*/
a2153 4
int		mpii_dev_reorder(struct mpii_softc *);
void		mpii_reorder_vds(struct mpii_softc *);
void		mpii_reorder_boot_device(struct mpii_softc *);

a2311 5
#if 0
	if (sc->sc_discovery_in_progress)
		printf("%s: warning: discovery still in progress\n", 
		    DEVNAME(sc));
#endif
a2317 12
	if (mpii_dev_reorder(sc) != 0) {
		/* error already printed */
		goto free_bios_pg2;
	}

	/* XXX
	if (mpii_fwupload(sc) != 0) {
		printf("%s: unabel to upload firmware\n", DEVNAME(sc));
		goto free_replies;
	}
	*/

d2326 1
a2326 1
	sc->sc_link.openings = sc->sc_request_depth / sc->sc_max_devices;
a2352 1
free_bios_pg2:
a2986 3
	if (sc->sc_reply_post_qdepth > MPII_MAX_REPLY_POST_QDEPTH)
		sc->sc_reply_post_qdepth = MPII_MAX_REPLY_POST_QDEPTH;
	
a2991 9
	/* XXX JPG temporary override of calculated values.
	 *         need to think this through as the specs
	 *         and other existing drivers contradict
	 */
	sc->sc_reply_post_qdepth = 128;
	sc->sc_request_depth = 128;
	sc->sc_num_reply_frames = 63;
	sc->sc_reply_free_qdepth = 64;
	
a3269 28
}

int
mpii_dev_reorder(struct mpii_softc *sc)
{
	if ((sc->sc_ir_firmware) && (sc->sc_vd_count))
		mpii_reorder_vds(sc);

	if (sc->sc_reserve_tid0)
		mpii_reorder_boot_device(sc);

	return (0);
}

void
mpii_reorder_vds(struct mpii_softc *sc)
{
	/* XXX need to implement
	 * ideas: VD creation order (still not sure what data to key off of),
	 *        member PD slot IDs,
	 *	  random fun
	 */
}

void
mpii_reorder_boot_device(struct mpii_softc *sc)
{
	/* mpii_get_boot_dev(sc) */
@


1.8
log
@Make use of PHY port numbers as targets for the drives instead
of the internal PhysDriveNum.  Also change ENXIO to EINVAL in
one case.

From: Mike Belopuhov <mkb@@crypt.org.ru>

Discussed with Jim Giannoules
@
text
@d1 1
a1 1
/* $OpenBSD: mpii.c,v 1.7 2010/02/20 19:34:08 marco Exp $ */
d1297 2
d1394 4
a1397 4
#define MPII_CFG_RAID_PHYDISK_0_OFFLINE_FAILED		(0x01)
#define MPII_CFG_RAID_PHYDISK_0_OFFLINE_INITIALIZING	(0x01)
#define MPII_CFG_RAID_PHYDISK_0_OFFLINE_REQUESTED	(0x01)
#define MPII_CFG_RAID_PHYDISK_0_OFFLINE_FAILEDREQ	(0x01)
d1970 1
a1970 2
	return (pci_matchbyid(aux, mpii_devices,
	    sizeof(mpii_devices) / sizeof(mpii_devices[0])));
a2180 1
void		mpii_get_raid_config_pg0(struct mpii_softc *);
a3839 85
void
mpii_get_raid_config_pg0(struct mpii_softc *sc)
{
	struct mpii_cfg_raid_config_pg0	*config_page;
	struct mpii_raid_config_element	*element_list, *element;
	struct mpii_ecfg_hdr	hdr;
	size_t			pagelen;
	struct scsi_link	*link;
	int			i;

	DNPRINTF(MPII_D_RAID, "%s: mpii_get_raid_config_pg0\n", DEVNAME(sc));

	if (mpii_cfg_header(sc, MPII_CONFIG_REQ_PAGE_TYPE_RAID_VOL, 0, 0, &hdr) != 0) {
		DNPRINTF(MPII_D_RAID, "%s: mpii_get_raid_config_pg0 unable to "
		    "fetch header for IOC page 2\n", DEVNAME(sc));
		return;
	}

	pagelen = hdr.ext_page_length * 4; /* dwords to bytes */
	config_page = malloc(pagelen, M_TEMP, M_WAITOK|M_CANFAIL);
	if (config_page == NULL) {
		DNPRINTF(MPII_D_RAID, "%s: mpii_get_raid_config_pg0 unable to "
		    "allocate space for raid config page 0\n", DEVNAME(sc));
		return;
	}
	element_list = (struct mpii_raid_config_element *)(config_page + 1);

	if (mpii_cfg_page(sc, 0, &hdr, 1, config_page, pagelen) != 0) {
		DNPRINTF(MPII_D_RAID, "%s: mpii_get_raid_config_pg0 unable to "
		    "fetch raid config page 0\n", DEVNAME(sc));
		goto out;
	}

	DNPRINTF(MPII_D_RAID, "%s:  numhotspares: 0x%2x numphysdisks: 0x%02x "
	    "numvolumes: 0x%02x confignum: 0x%02x\n", DEVNAME(sc), 
	    config_page->num_hot_spares, config_page->num_phys_disks, 
	    config_page->num_volumes, config_page->config_num);
	DNPRINTF(MPII_D_RAID, "%s:  flags: 0x%08x\n", DEVNAME(sc),
	    config_page->flags);
	DNPRINTF(MPII_D_RAID, "%s:  configguid: 0x%08x\n", DEVNAME(sc),
	    config_page->config_guid[0]);
	DNPRINTF(MPII_D_RAID, "%s:              0x%08x\n", DEVNAME(sc),
	    config_page->config_guid[1]);
	DNPRINTF(MPII_D_RAID, "%s:              0x%08x\n", DEVNAME(sc),
	    config_page->config_guid[2]);
	DNPRINTF(MPII_D_RAID, "%s:              0x%08x\n", DEVNAME(sc),
	    config_page->config_guid[3]);
	DNPRINTF(MPII_D_RAID, "%s  numelements: 0x%02x\n", DEVNAME(sc),
	    config_page->num_elements);

	/* don't walk list if there are no RAID capability */
	/* XXX anything like this for MPI2?
	if (capabilities == 0xdeadbeef) {
		printf("%s: deadbeef in raid configuration\n", DEVNAME(sc));
		goto out;
	}
	*/

	if (config_page->num_volumes == 0)
		goto out;

	sc->sc_flags |= MPII_F_RAID;

	for (i = 0; i < config_page->num_volumes; i++) {
		element = &element_list[i];

		DNPRINTF(MPII_D_RAID, "%s:   elementflags: 0x%04x voldevhandle: "
		    "0x%04x\n", DEVNAME(sc), letoh16(element->element_flags),
		    letoh16(element->vol_dev_handle));
		DNPRINTF(MPII_D_RAID, "%s:   hotsparepool: 0x%02x physdisknum: "
		    "0x%02x physdiskdevhandle: 0x%04x\n", DEVNAME(sc),
		    element->hot_spare_pool, element->phys_disk_num,
		    letoh16(element->phys_disk_dev_handle));

		link = sc->sc_scsibus->sc_link[element->vol_dev_handle][0];
		if (link == NULL)
			continue;

		link->flags |= SDEV_VIRTUAL;
	}

out:
	free(config_page, M_TEMP);
}

d5013 1
a5013 2

	DNPRINTF(MPII_D_CMD, "%s:  xs err: 0x%d status: %#x\n", DEVNAME(sc),
d5127 12
d5271 1
a5271 1
	pagelen = ehdr.ext_page_length * 4;
d5289 1
a5289 1
		if (ISSET(el->element_flags,
d5320 1
d5340 2
a5341 2
	if (mpii_bio_getphy(sc, ppg.dev_handle, &bd->bd_target))
		bd->bd_target = ppg.phys_disk_num;
d5349 7
a5355 1
		bd->bd_status = BIOC_SDOFFLINE;
d5376 5
a5380 1
	scsi_strvis(bd->bd_vendor, ppg.product_id, sizeof(ppg.product_id));
d5397 1
a5397 1
	ehdr.ext_page_length = sizeof(spg) / 4;
a5420 3
	DNPRINTF(MPII_D_IOCTL, "%s: mpii_ioctl_vol %d\n",
	    DEVNAME(sc), bv->bv_volid);

d5451 12
@


1.7
log
@- implements bioctl support;
- fixes hot-un-plugging w/ softeps;
- improves performance;
- fixes IPL levels;
- fixes lots of small things;
- does a little bit of cleanup;
- fixes NOWAIT/WAITOK;
- disables useless/unused Driver Persistent Mapping code

From Mike Belopuhov <mkb@@crypt.org.ru>

Discussed with Jim Giannoules
@
text
@d1 1
a1 1
/* $OpenBSD: mpii.c,v 1.6 2010/01/09 23:15:07 krw Exp $ */
d1357 2
a1358 3
	u_int8_t		phys_disk_id;
	u_int8_t		phys_disk_bus;
	u_int8_t		phys_disk_ioc;
d1369 1
a1369 1
	u_int32_t		reserved1;
d1379 1
a1379 1
	u_int32_t		reserved2;
d1412 1
a1412 1
	u_int16_t		reserved3;
d1414 1
a1414 1
	u_int32_t		reserved4;
d2198 1
d5358 1
a5358 1
		return (ENXIO);
d5413 2
a5414 2
	bd->bd_channel = ppg.phys_disk_bus;
	bd->bd_target = ppg.phys_disk_num;
d5445 26
@


1.6
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: mpii.c,v 1.5 2009/12/01 00:09:03 bluhm Exp $ */
d3 4
a6 3
 * Copyright (c) James Giannoules
 * Copyright (c) 2005 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2005 Marco Peereboom <marco@@openbsd.org>
d34 1
a1023 1
#define MPII_CONFIG_REQ_PAGE_TYPE_DRIVER_MAPPING	(0x17)
d1034 3
d1276 2
d1281 8
a1288 3
	u_int8_t		volume_id;
	u_int8_t		volume_bus;
	u_int8_t		volume_ioc;
d1290 5
d1296 1
a1296 12
	u_int8_t		volume_status;
#define MPII_CFG_RAID_VOL_0_STATUS_ENABLED		(1<<0)
#define MPII_CFG_RAID_VOL_0_STATUS_QUIESCED		(1<<1)
#define MPII_CFG_RAID_VOL_0_STATUS_RESYNCING		(1<<2)
#define MPII_CFG_RAID_VOL_0_STATUS_ACTIVE		(1<<3)
#define MPII_CFG_RAID_VOL_0_STATUS_BADBLOCK_FULL	(1<<4)
	u_int8_t		volume_state;
#define MPII_CFG_RAID_VOL_0_STATE_OPTIMAL		(0x00)
#define MPII_CFG_RAID_VOL_0_STATE_DEGRADED		(0x01)
#define MPII_CFG_RAID_VOL_0_STATE_FAILED		(0x02)
#define MPII_CFG_RAID_VOL_0_STATE_MISSING		(0x03)
	u_int16_t		reserved1;
a1298 8
#define MPII_CFG_RAID_VOL_0_SETTINGS_WRITE_CACHE_EN	(1<<0)
#define MPII_CFG_RAID_VOL_0_SETTINGS_OFFLINE_SMART_ERR	(1<<1)
#define MPII_CFG_RAID_VOL_0_SETTINGS_OFFLINE_SMART	(1<<2)
#define MPII_CFG_RAID_VOL_0_SETTINGS_AUTO_SWAP		(1<<3)
#define MPII_CFG_RAID_VOL_0_SETTINGS_HI_PRI_RESYNC	(1<<4)
#define MPII_CFG_RAID_VOL_0_SETTINGS_PROD_SUFFIX	(1<<5)
#define MPII_CFG_RAID_VOL_0_SETTINGS_FAST_SCRUB		(1<<6) /* obsolete */
#define MPII_CFG_RAID_VOL_0_SETTINGS_DEFAULTS		(1<<15)
d1300 1
a1300 1
	u_int8_t		reserved2;
d1302 1
a1302 3
	u_int32_t		max_lba;

	u_int32_t		reserved3;
d1306 2
a1307 1
	u_int32_t		reserved4;
d1309 3
a1311 1
	u_int32_t		reserved5;
d1314 1
a1314 2
	u_int8_t		data_scrub_rate;
	u_int8_t		resync_rate;
d1327 1
a1327 1
	u_int16_t		reserved;
d1330 1
d1352 2
a1371 4
	u_int8_t		ext_disk_id[8];

	u_int8_t		disk_id[16];

d1378 20
a1397 1
	u_int8_t		info[32];
d1399 4
a1402 1
	u_int8_t		phys_disk_status;
a1404 10
	u_int8_t		phys_disk_state;
#define MPII_CFG_RAID_PHYDISK_0_STATE_ONLINE		(0x00)
#define MPII_CFG_RAID_PHYDISK_0_STATE_MISSING		(0x01)
#define MPII_CFG_RAID_PHYDISK_0_STATE_INCOMPAT		(0x02)
#define MPII_CFG_RAID_PHYDISK_0_STATE_FAILED		(0x03)
#define MPII_CFG_RAID_PHYDISK_0_STATE_INIT		(0x04)
#define MPII_CFG_RAID_PHYDISK_0_STATE_OFFLINE		(0x05)
#define MPII_CFG_RAID_PHYDISK_0_STATE_HOSTFAIL		(0x06)
#define MPII_CFG_RAID_PHYDISK_0_STATE_OTHER		(0xff)
	u_int16_t		reserved2;
d1406 5
a1410 1
	u_int32_t		max_lba;
d1412 1
a1412 2
	u_int8_t		error_cdb_byte;
	u_int8_t		error_sense_key;
d1415 1
a1415 7
	u_int16_t		error_count;
	u_int8_t		error_asc;
	u_int8_t		error_ascq;

	u_int16_t		smart_count;
	u_int8_t		smart_asc;
	u_int8_t		smart_ascq;
d1497 10
a1506 1
	u_int8_t		reserved;
d1535 2
d1890 1
d1969 2
a1970 1
	return (pci_matchbyid(aux, mpii_devices, nitems(mpii_devices)));
d2097 1
a2097 1
	NULL
d2122 2
a2123 1
int		mpii_reply(struct mpii_softc *);
a2190 1
int		mpii_bio_get_pg0_raid(struct mpii_softc *, int);
d2195 4
a2198 1
int		mpii_ioctl_setstate(struct mpii_softc *, struct bioc_setstate *);
d2200 1
d2218 1
a2218 1
#define mpii_read_reply_free(s, v)	mpii_read((s), \
d2222 1
a2222 1
#define mpii_read_reply_post(s, v)	mpii_read((s), \
d2314 1
d2320 1
d2341 1
a2341 5
	
	/* enable interrupts */
	mpii_write(sc, MPII_INTR_MASK, MPII_INTR_MASK_DOORBELL 
	    | MPII_INTR_MASK_RESET);
	
d2347 1
d2351 1
d2387 16
d2449 8
a2456 1
	struct mpii_softc	*sc = arg;
d2458 19
a2476 2
	if (mpii_reply(sc) < 0)
		return (0);
d2478 2
a2479 4
	while (mpii_reply(sc) >= 0)
		;
	
	mpii_write_reply_post(sc, sc->sc_reply_post_host_index);
d2481 1
a2481 1
	return (1);
d2487 5
a2491 1
/* XXX */
a2606 1
	/* XXX */
d3129 1
a3129 1
	iiq.system_reply_address_high = hi_addr;
d3447 2
a3448 1
	
d3450 1
a3485 3

		for (volid = 0; volid < sc->sc_max_devices; volid++)

d3505 1
a3505 1
				    	    M_DEVBUF, M_ZERO);
d3631 1
a3631 1
			    M_DEVBUF, M_ZERO);
d3639 1
d3814 1
a3814 1
	sc->sc_bios_pg2 = malloc(pagelen, M_TEMP, M_WAITOK|M_CANFAIL);
d3968 1
a3968 1
	dpm_page = malloc(pagelen, M_TEMP, M_WAITOK|M_CANFAIL);
d4120 1
a4120 1
	page = malloc(pagelen, M_TEMP, M_WAITOK|M_CANFAIL);
d4145 1
d4150 1
d4251 6
a4256 2
	if (ccb->ccb_rcb == NULL)
		panic("%s: unable to fetch config header\n", DEVNAME(sc));
d4291 1
d4294 1
d4351 1
a4351 1
	    (page_length * 4) |
d4383 1
d4385 1
d4415 1
d4418 1
d4424 1
a4424 1
mpii_reply(struct mpii_softc *sc)
a4425 1
	struct mpii_reply_descriptor	*rdp;
a4427 1
	struct mpii_msg_reply	*reply = NULL;
d4429 1
a4429 1
	u_int32_t		reply_dva, i;
d4435 4
a4438 5
	/* XXX need to change to to be just the reply we expect to read */
	bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_reply_postq), 0, 
	    8 * sc->sc_reply_post_qdepth, BUS_DMASYNC_POSTWRITE);
		 
	rdp = &sc->sc_reply_postq_kva[sc->sc_reply_post_host_index];
a4441 3
	
	if ((reply_flags == MPII_REPLY_DESCR_FLAGS_UNUSED))
		return (-1);
d4443 2
a4444 11
	if (dwordn(rdp, 1) == 0xffffffff)
		/*
		 * ioc is still writing to the reply post queue
		 * race condition - bail!
		 */
		 return (-1);
		 
	DNPRINTF(MPII_D_INTR, "%s:  dword[0]: 0x%08x\n", DEVNAME(sc), 
	    letoh32(dwordn(rdp, 0)));
	DNPRINTF(MPII_D_INTR, "%s:  dword[1]: 0x%08x\n", DEVNAME(sc), 
	    letoh32(dwordn(rdp, 1)));
d4446 1
a4446 2
	switch (reply_flags) {
	case MPII_REPLY_DESCR_FLAGS_ADDRESS_REPLY:
d4448 3
a4450 4
		reply_dva = letoh32(rdp->type_dependent2);
		i = (reply_dva - (u_int32_t)MPII_DMA_DVA(sc->sc_replies)) /
			MPII_REPLY_SIZE;
		
a4455 5
		reply = rcb->rcb_reply;
		/* fall through */
	default:
		/* smid */
		 smid = letoh16(rdp->type_dependent1);
d4459 1
a4459 1
	    DEVNAME(sc), reply_flags, smid, reply);
d4461 1
a4461 16
	if (smid)  {
		ccb = &sc->sc_ccbs[smid - 1];

		/* XXX why is this necessary ? */
		bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_requests),
		    ccb->ccb_offset, MPII_REQUEST_SIZE,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		ccb->ccb_state = MPII_CCB_READY;
		ccb->ccb_rcb = rcb;
	}

	DNPRINTF(MPII_D_INTR, "    rcb: 0x%04x\n", rcb);

	dwordn(rdp, 0) = 0xffffffff;
	dwordn(rdp, 1) = 0xffffffff;
a4465 3
		
	sc->sc_reply_post_host_index = (sc->sc_reply_post_host_index + 1) %
	    sc->sc_reply_post_qdepth;
d4467 4
a4470 1
	if (smid)
d4472 1
a4472 1
	else
d4506 4
a4511 4
	DNPRINTF(MPII_D_MEM, "%s: mpii_dmamem_alloc size: %d mdm: %#x "
	    "map: %#x nsegs: %d segs: %#x kva: %x\n",
	    DEVNAME(sc), size, mdm->mdm_map, nsegs, mdm->mdm_seg, mdm->mdm_kva);

d4547 1
a4547 1
	    M_WAITOK | M_CANFAIL | M_ZERO);
d4565 1
a4565 1
	    M_DEVBUF, M_WAITOK | M_CANFAIL | M_ZERO);
d4634 1
d4665 1
a4665 1
	    M_DEVBUF, M_WAITOK|M_CANFAIL);
d4698 1
d4704 1
d4740 1
a4740 2
	    "0x%08x\n", DEVNAME(sc), MPII_REQ_DESC_POST_LOW, 
	    dwordn(&descriptor, 0));
d4743 1
a4743 2
	    "0x%08x\n", DEVNAME(sc), MPII_REQ_DESC_POST_HIGH, 
	    dwordn(&descriptor, 1));
d4745 2
a4746 4
	/* XXX make this 64 bit? */
	mpii_write(sc, MPII_REQ_DESC_POST_LOW, htole32(dwordn(&descriptor, 0)));
	mpii_write(sc, MPII_REQ_DESC_POST_HIGH, 
	    htole32(dwordn(&descriptor, 1)));
d4752 4
a4755 2
	int			smid = -1;
	
a4767 10
		
		smid = mpii_reply(sc);
	
		/* generates PCI write every completed reply, but
		 * prevents deadlock waiting for specific smid
		 */
		mpii_write_reply_post(sc, sc->sc_reply_post_host_index);
		
		DNPRINTF(MPII_D_INTR, "%s: mpii_complete call to mpii_reply returned: %d\n",
		    DEVNAME(sc), smid);
d4769 24
d4795 2
a4907 21
	/* XXX */
	if (sc->sc_mpii_dev[link->target] == NULL) {
		DNPRINTF(MPII_D_MAP, "%s: mpii_scsi_cmd nonexistent tid %d\n", 
		    DEVNAME(sc), link->target);
		return (99);
	}

	/* XXX */
	if (sc->sc_mpii_dev[link->target]->flags & MPII_DEV_UNUSED) {
		DNPRINTF(MPII_D_MAP, "%s: mpii_scsi_cmd tid %d is "
		    "MPII_DEV_UNUSED\n", DEVNAME(sc), link->target);
		return (99);
	}

	/* XXX */
	if (sc->sc_mpii_dev[link->target]->flags & MPII_DEV_HIDDEN) {
		DNPRINTF(MPII_D_MAP, "%s: mpii_scsi_cmd tid %d is "
		    "MPII_DEV_HIDDEN\n", DEVNAME(sc), link->target);
		return (99);
	}

d4921 2
a4922 1
	io->dev_handle = htole16(sc->sc_mpii_dev[link->target]->dev_handle);
a4954 2
	timeout_set(&xs->stimeout, mpii_timeout_xs, ccb);

d4978 3
d5008 2
a5009 1
	/* timeout_del */
d5080 2
d5099 1
a5099 1
	DNPRINTF(MPII_D_CMD, "%s:  xs err: 0x%02x status: %d\n", DEVNAME(sc),
d5106 489
@


1.5
log
@Change type of dva to u_int64_t to make mpii(4) compile on i386.
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: mpii.c,v 1.4 2009/11/24 21:29:16 marco Exp $ */
a4840 1
		xs->flags |= ITSDONE;
a4912 1
		xs->flags |= ITSDONE;
a4937 1
			xs->flags |= ITSDONE;
a4974 1
	xs->flags |= ITSDONE;
@


1.4
log
@Add event framework.
Map IR volumes & disks at discovery time in predictable manner.

From James Giannoules
@
text
@d1 1
a1 1
/* $OpenBSD: mpii.c,v 1.3 2009/11/05 03:43:18 marco Exp $ */
d3887 1
a3887 1
	bus_addr_t		dva;
@


1.3
log
@Make compile on 32 bit as well.

From James Giannoules
@
text
@d1 1
a1 1
/* $OpenBSD: mpii.c,v 1.2 2009/11/03 06:00:40 marco Exp $ */
d49 1
a49 1
#define MPII_DOORBELL			0x00
d66 1
a66 1
#define MPII_DOORBELL_FUNCTION_SHIFT	24
d74 1
a74 1
#define MPII_DOORBELL_DATA_MASK		0xffff
d76 9
a84 9
#define MPII_WRITESEQ			0x04
#define  MPII_WRITESEQ_KEY_VALUE_MASK	0x0000000f /* key value */
#define  MPII_WRITESEQ_FLUSH		0x00
#define  MPII_WRITESEQ_1		0x0f
#define  MPII_WRITESEQ_2		0x04
#define  MPII_WRITESEQ_3		0x0b
#define  MPII_WRITESEQ_4		0x03
#define  MPII_WRITESEQ_5		0x07
#define	 MPII_WRITESEQ_6		0x0d	
d86 2
a87 2
#define MPII_HOSTDIAG			0x08
#define  MPII_HOSTDIAG_BDS_MASK		0x00001800 /* boot device select */
d101 1
a101 1
#define MPII_DIAGRWDATA			0x10
d103 1
a103 1
#define MPII_DIAGRWADDRLOW		0x14
d105 1
a105 1
#define MPII_DIAGRWADDRHIGH		0x18
d107 1
a107 1
#define MPII_INTR_STATUS		0x30
d113 1
a113 1
#define MPII_INTR_MASK			0x34
d118 1
a118 1
#define MPII_DCR_DATA			0x38
d120 1
a120 1
#define MPII_DCR_ADDRESS		0x3C
d122 1
a122 1
#define MPII_REPLY_FREE_HOST_INDEX	0x48
d124 1
a124 1
#define MPII_REPLY_POST_HOST_INDEX	0x6C
d126 1
a126 1
#define MPII_HCB_SIZE			0x74
d128 2
a129 2
#define MPII_HCB_ADDRESS_LOW		0x78
#define MPII_HCB_ADDRESS_HIGH		0x7C
d131 2
a132 2
#define MPII_REQ_DESC_POST_LOW		0xC0
#define MPII_REQ_DESC_POST_HIGH		0xC4
d187 4
a190 4
#define MPII_FUNCTION_TARGET_CMD_BUFFER_POST		(0x0A)
#define MPII_FUNCTION_TARGET_ASSIST			(0x0B)
#define MPII_FUNCTION_TARGET_STATUS_SEND		(0x0C)
#define MPII_FUNCTION_TARGET_MODE_ABORT			(0x0D)
d200 3
a202 3
#define MPII_FUNCTION_SMP_PASSTHROUGH			(0x1A)
#define MPII_FUNCTION_SAS_IO_UNIT_CONTROL		(0x1B)
#define MPII_FUNCTION_SATA_PASSTHROUGH			(0x1C)
d204 2
a205 2
#define MPII_FUNCTION_DIAG_BUFFER_POST			(0x1D)
#define MPII_FUNCTION_DIAG_RELEASE			(0x1E)
d228 1
a228 1
#define MPII_REP_IOCSTATUS_AVAIL		(1<<15) /* logging info available */
d259 3
a261 3
#define  MPII_IOCSTATUS_SCSI_TASK_MGMT_FAILED		(0x004A)
#define  MPII_IOCSTATUS_SCSI_IOC_TERMINATED		(0x004B)
#define  MPII_IOCSTATUS_SCSI_EXT_TERMINATED		(0x004C)
d263 3
a265 3
#define  MPII_IOCSTATUS_EEDP_GUARD_ERROR		(0x004D)
#define  MPII_IOCSTATUS_EEDP_REF_TAG_ERROR		(0x004E)
#define  MPII_IOCSTATUS_EEDP_APP_TAG_ERROR		(0x004F)
d271 4
a274 4
#define  MPII_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH	(0x006A)
#define  MPII_IOCSTATUS_TARGET_DATA_OFFSET_ERROR	(0x006D)
#define  MPII_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA	(0x006E)
#define  MPII_IOCSTATUS_TARGET_IU_TOO_SHORT		(0x006F)
d281 1
a281 1
#define  MPII_IOCSTATUS_DIAGNOSTIC_RELEASED		(0x00A0)
d283 1
a283 1
#define MPII_REP_IOCLOGINFO_TYPE			(0xf<<28) /* logging info type */
d289 1
a289 1
#define MPII_REP_IOCLOGINFO_DATA			(0x0fffffff) /* logging info data */
d292 18
a309 24
#define MPII_EVENT_NONE					0x00
#define MPII_EVENT_LOG_DATA				0x01
#define MPII_EVENT_STATE_CHANGE				0x02
#define MPII_EVENT_UNIT_ATTENTION			0x03
#define MPII_EVENT_IOC_BUS_RESET			0x04
#define MPII_EVENT_EXT_BUS_RESET			0x05
#define MPII_EVENT_RESCAN				0x06
#define MPII_EVENT_LINK_STATUS_CHANGE			0x07
#define MPII_EVENT_LOOP_STATE_CHANGE			0x08
#define MPII_EVENT_LOGOUT				0x09
#define MPII_EVENT_EVENT_CHANGE				0x0a
#define MPII_EVENT_INTEGRATED_RAID			0x0b
#define MPII_EVENT_SCSI_DEVICE_STATUS_CHANGE		0x0c
#define MPII_EVENT_ON_BUS_TIMER_EXPIRED			0x0d
#define MPII_EVENT_QUEUE_FULL				0x0e
#define MPII_EVENT_SAS_DEVICE_STATUS_CHANGE		0x0f
#define MPII_EVENT_SAS_SES				0x10
#define MPII_EVENT_PERSISTENT_TABLE_FULL		0x11
#define MPII_EVENT_SAS_PHY_LINK_STATUS			0x12
#define MPII_EVENT_SAS_DISCOVERY_ERROR			0x13
#define MPII_EVENT_IR_RESYNC_UPDATE			0x14
#define MPII_EVENT_IR2					0x15
#define MPII_EVENT_SAS_DISCOVERY			0x16
#define MPII_EVENT_LOG_ENTRY_ADDED			0x21
d313 6
a318 6
#define MPII_WHOINIT_NOONE				0x00
#define MPII_WHOINIT_SYSTEM_BIOS			0x01
#define MPII_WHOINIT_ROM_BIOS				0x02
#define MPII_WHOINIT_PCI_PEER				0x03
#define MPII_WHOINIT_HOST_DRIVER			0x04
#define MPII_WHOINIT_MANUFACTURER			0x05
d548 5
a552 5
#define MPII_PORTFACTS_PORTTYPE_INACTIVE		0x00
#define MPII_PORTFACTS_PORTTYPE_FC			0x10
#define MPII_PORTFACTS_PORTTYPE_ISCSI			0x20
#define MPII_PORTFACTS_PORTTYPE_SAS_PHYSICAL		0x30
#define MPII_PORTFACTS_PORTTYPE_SAS_VIRTUAL		0x31
d657 8
a664 8
#define MPII_EVT_SASPHY_LINK_CUR(x)			(((x) & 0xf0) >> 4)
#define MPII_EVT_SASPHY_LINK_PREV(x)			((x) & 0x0f)
#define MPII_EVT_SASPHY_LINK_ENABLED			0x0
#define MPII_EVT_SASPHY_LINK_DISABLED			0x1
#define MPII_EVT_SASPHY_LINK_NEGFAIL			0x2
#define MPII_EVT_SASPHY_LINK_SATAOOB			0x3
#define MPII_EVT_SASPHY_LINK_1_5GBPS			0x8
#define MPII_EVT_SASPHY_LINK_3_0GBPS			0x9
d673 11
a683 11
#define MPII_EVT_SASCH_REASON_SMART_DATA		0x05
#define MPII_EVT_SASCH_REASON_UNSUPPORTED		0x07
#define MPII_EVT_SASCH_REASON_INTERNAL_RESET		0x08
#define MPII_EVT_SASCH_REASON_TASK_ABORT_INTERVAL	0x09
#define MPII_EVT_SASCH_REASON_ABORT_TASK_SET_INTERVAL	0x0A
#define MPII_EVT_SASCH_REASON_CLEAR_TASK_SET_INTERVAL	0x0B
#define MPII_EVT_SASCH_REASON_QUERY_TASK_INTERVAL	0x0C
#define MPII_EVT_SASCH_REASON_ASYNC_NOTIFICATION	0x0D
#define MPII_EVT_SASCH_REASON_CMP_INTERNAL_DEV_RESET	0x0E
#define MPII_EVT_SASCH_REASON_CMP_TASK_ABORT_INTERNAL	0x0F
#define MPII_EVT_SASCH_REASON_SATA_INIT_FAILURE		0x10
d742 2
a743 2
#define MPII_FWUPLOAD_IMAGETYPE_NV_COMPLETE		(0x0A)
#define MPII_FWUPLOAD_IMAGETYPE_COMMON_BOOT_BLOCK	(0x0B)
d842 1
a842 1
#define	MPII_CDB_LEN					32
d918 1
a918 1
#define MPII_REPLY_DESCR_FLAGS_TYPE_MASK               (0x0F)
d923 1
a923 1
#define MPII_REPLY_DESCR_FLAGS_UNUSED                  (0x0F)
d1020 3
a1022 2
#define MPII_CONFIG_REQ_PAGE_TYPE_RAID_PD		(0x0A)
#define MPII_CONFIG_REQ_PAGE_TYPE_EXTENDED		(0x0F)
d1166 7
d1176 3
d1495 26
d1556 140
a1695 1
/*#define MPII_DEBUG*/
d1699 13
a1711 12
#define	MPII_D_CMD		0x0001
#define	MPII_D_INTR		0x0002
#define	MPII_D_MISC		0x0004
#define	MPII_D_DMA		0x0008
#define	MPII_D_IOCTL		0x0010
#define	MPII_D_RW		0x0020
#define	MPII_D_MEM		0x0040
#define	MPII_D_CCB		0x0080
#define	MPII_D_PPR		0x0100
#define	MPII_D_RAID		0x0200
#define	MPII_D_EVT		0x0400
#define MPII_D_CFG		0x0800
d1726 1
d1733 3
a1735 3
#define MPII_REQUEST_SIZE	512
#define MPII_REPLY_SIZE		128
#define MPII_REPLY_COUNT	(PAGE_SIZE / MPII_REPLY_SIZE)
d1741 1
a1741 1
#define MPII_MAX_SGL		32
d1743 2
a1744 2
#define MPII_MAX_REQUEST_CREDIT	500
#define	MPII_MAX_REPLY_POST_QDEPTH 128
d1752 3
a1754 3
#define MPII_DMA_MAP(_mdm)	((_mdm)->mdm_map)
#define MPII_DMA_DVA(_mdm)	((_mdm)->mdm_map->dm_segs[0].ds_addr)
#define MPII_DMA_KVA(_mdm)	((void *)(_mdm)->mdm_kva)
d1769 40
d1844 2
d1860 1
d1862 20
a1881 2

	int			sc_buswidth;
d1911 1
a1911 1
	struct mpii_cfg_raid_vol	*sc_vol_list;
d1913 2
d2077 1
a2077 1
	NULL,
d2097 1
d2137 1
a2137 1

d2143 11
d2161 1
a2161 1
void		mpii_get_ioc_pg8(struct mpii_softc *);
d2163 7
d2210 4
d2215 2
a2216 1
    mpii_req_cfg_header((_s), (_t), (_n), (_a), 0, (_h))
d2218 2
a2219 1
    mpii_req_cfg_header((_s), (_t), (_n), (_a), 1, (_h))
d2222 2
a2223 1
    mpii_req_cfg_page((_s), (_a), 0, (_h), (_r), (_p), (_l))
d2225 2
a2226 1
    mpii_req_cfg_page((_s), (_a), 1, (_h), (_r), (_p), (_l))
d2268 1
a2268 1
		goto free_ccbs;
d2276 1
a2276 1
		goto free_ccbs;
d2284 1
a2284 1
		goto free_replies;
d2287 35
d2324 10
a2333 1
		goto free_replies;
d2336 4
a2339 6
	mpii_get_ioc_pg8(sc);
	mpii_get_raid_config_pg0(sc);
	
	if (mpii_cfg_coalescing(sc) != 0)
		/* this is fatal in mpi */
		printf("%s: unable to configure coalescing\n", DEVNAME(sc));
d2341 1
a2341 1
	/* XXX JPG not yet implemented
d2345 2
a2346 1
	}*/
d2355 2
a2356 2
	sc->sc_link.adapter_buswidth = sc->sc_buswidth;
	sc->sc_link.openings = sc->sc_request_depth / sc->sc_buswidth;
d2365 1
a2365 6
	/* XXX JPG here we need to:
	 * 
	 *   get raid pages
	 *   do whatever is necessary for MPI2 host mapping
	 *   update our array/RB tree for target -> dev_handle mapping
	 */
d2367 16
a2382 3
	/* enable interrupts */
	mpii_write(sc, MPII_INTR_MASK, MPII_INTR_MASK_DOORBELL 
	    | MPII_INTR_MASK_RESET);
d2384 3
a2386 1
	return (0);
d2547 24
d2605 1
a2605 1
	for (i = 0; i < 10000; i++) {
d2623 1
a2623 1
	for (i = 0; i < 10000; i++) {
d2663 8
d2673 2
a2674 3
			    "reset\n" , DEVNAME(sc));
			if (mpii_reset_soft(sc) != 0)
				mpii_reset_hard(sc);
a2696 1
		printf("db in use\n");
a2734 1

d2737 3
a2739 1
	if ((mpii_read(sc, MPII_HOSTDIAG) & MPII_HOSTDIAG_DWRE) == 0)
d2741 1
a2950 3
	/* XXX JPG should this be max targets + max vol from cfg page ?? */
	sc->sc_buswidth = (ifp.max_targets == 0) ? 256 : 
	    letoh16(ifp.max_targets);
d2954 7
d3182 1
a3182 1
	/* no such field in MPI2 .... but the dilemma is what
d3196 35
d3275 28
d3343 434
d3862 177
a4038 1
void
a4040 1
	struct mpii_cfg_raid_vol	*vol_list;
d4042 1
a4042 1
	struct mpii_cfg_ioc_pg8	*vol_page;
d4044 2
d4050 1
a4050 1
		DNPRINTF(MPII_D_RAID, "%s: mpii_get_ioc_pg8 unable to fetch header"
d4052 1
a4052 1
		return;
d4056 4
a4059 3
	vol_page = malloc(pagelen, M_TEMP, M_WAITOK|M_CANFAIL);
	if (vol_page == NULL) {
		DNPRINTF(MPII_D_RAID, "%s: mpii_get_ioc_pg8 unable to allocate "
d4061 1
a4061 1
		return;
a4062 1
	vol_list = (struct mpii_cfg_raid_vol *)(vol_page + 1);
d4064 2
a4065 2
	if (mpii_cfg_page(sc, 0, &hdr, 1, vol_page, pagelen) != 0) {
		DNPRINTF(MPII_D_RAID, "%s: mpii_get_raid unable to fetch IOC "
d4067 1
d4071 3
a4073 3
	DNPRINTF(MPII_D_RAID, "%s:  numdevsperenclosure: 0x%02x\n", DEVNAME(sc),
	    vol_page->num_devs_per_enclosure);
	DNPRINTF(MPII_D_RAID, "%s:  maxpersistententries: 0x%04x "
d4075 44
a4118 6
	    letoh16(vol_page->max_persistent_entries), 
	    letoh16(vol_page->max_num_physical_mapped_ids));
	DNPRINTF(MPII_D_RAID, "%s:  flags: 0x%04x\n", DEVNAME(sc),
	    letoh16(vol_page->flags));
	DNPRINTF(MPII_D_RAID, "%s:  irvolumemappingflags: 0x%04x\n", 
	    DEVNAME(sc), letoh16(vol_page->ir_volume_mapping_flags));
d4121 3
a4123 1
	free(vol_page, M_TEMP);
d4128 1
a4128 1
    u_int32_t address, int extended, void *p)
d4130 3
a4132 2
	struct mpii_msg_config_request	*cq;
	struct mpii_msg_config_reply	*cp;
a4133 1
	struct mpii_cfg_hdr	*hdr = p;
d4140 2
a4141 2
	    "address: 0x%08x extended: %d\n", DEVNAME(sc), type, number,
	    address, extended);
d4152 1
a4152 1
	if (extended) {
a4156 1
	ccb->ccb_done = mpii_empty_done;
d4170 14
a4183 3
	if (mpii_poll(sc, ccb, 50000) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_cfg_header poll\n", DEVNAME(sc));
		return (1);
d4212 1
a4212 1
	else if (extended) {
d4229 1
a4229 1
mpii_req_cfg_page(struct mpii_softc *sc, u_int32_t address, int extended,
d4234 1
a4235 1
	struct mpii_cfg_hdr	*hdr = p;
d4243 1
a4243 1
	DNPRINTF(MPII_D_MISC, "%s: mpii_req_cfg_page address: %d read: %d type: %x\n",
d4246 1
a4246 1
	page_length = extended ?
d4250 1
a4250 1
	    len < page_length * 4)
a4260 1
	ccb->ccb_done = mpii_empty_done;
d4268 1
a4268 1
	if (extended) {
d4291 1
d4295 14
a4308 3
	if (mpii_poll(sc, ccb, 50000) != 0) {
		DNPRINTF(MPII_D_MISC, "%s: mpii_cfg_page poll\n", DEVNAME(sc));
		return (1);
d4336 1
a4336 1

d4352 1
a4352 1
	struct mpii_ccb		*ccb;
d4379 1
a4379 1
		 return (0);
d4408 2
a4409 5
	if (smid == 0) {
		printf("smid == 0 !!\n");
		goto end;
	}
	ccb = &sc->sc_ccbs[smid - 1];
d4411 4
a4414 4
	/* XXX why is this necessary ? */
	bus_dmamap_sync(sc->sc_dmat, MPII_DMA_MAP(sc->sc_requests),
	    ccb->ccb_offset, MPII_REQUEST_SIZE,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
d4416 3
a4418 2
	ccb->ccb_state = MPII_CCB_READY;
	ccb->ccb_rcb = rcb;
a4430 1
	ccb->ccb_done(ccb);
d4432 4
a4435 1
end:
d4501 17
d4542 4
a4545 5
	/*
	 * we have sc->sc_request_depth system request message frames, but
	 * smid zero cannot be used.
	 * 
	 * we then have (sc->sc_request_depth - 1) number of ccbs
a4803 3



d4853 21
d4888 1
a4888 1
	io->dev_handle = htole32(link->target);
@


1.2
log
@Simplify and remove debug cruft from interrupt handler.  Original diff from
James Giannoules.  Some KNF from me.
@
text
@d1 1
a1 1
/* $OpenBSD: mpii.c,v 1.1 2009/10/27 11:19:04 dlg Exp $ */
d3677 1
a3677 1
		kva64[i] = 0xffffffffffffffff;
@


1.1
log
@rename the source file. my screwup, i asked for this and didnt check it.
@
text
@d1 1
a1 1
/* $OpenBSD: mpii_pci.c,v 1.1 2009/10/27 02:21:59 marco Exp $ */
a2096 2
	int			rv = 0, count = 0;
	int			max_processed_replies = 0;
d2098 1
a2098 5
#ifdef MPII_DEBUG
	int			disable_interrupt = 0;
	u_int32_t		db;

	if (disable_interrupt)
d2101 2
a2102 18
	db = mpii_read_db(sc);
	if ((db & MPII_DOORBELL_STATE) != MPII_DOORBELL_STATE_OPER) {
		printf("db not operational\n");
		disable_interrupt = 1;
		return (0);
	}
#endif
	while (mpii_reply(sc) >= 0) {
		rv = 1;
		if (count++ == 100) {
		/* disable interrupts */
			mpii_write(sc, MPII_INTR_MASK, 
			    MPII_INTR_MASK_RESET | MPII_INTR_MASK_REPLY 
			    | MPII_INTR_MASK_DOORBELL);
			mpii_write_reply_post(sc, sc->sc_reply_post_host_index);
			return (0);
		}
	}
d2106 1
a2106 4
	if (count > max_processed_replies)
		max_processed_replies = count;

	return (rv);
@

