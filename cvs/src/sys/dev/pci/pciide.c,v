head	1.358;
access;
symbols
	OPENBSD_6_2:1.358.0.4
	OPENBSD_6_2_BASE:1.358
	OPENBSD_6_1:1.357.0.8
	OPENBSD_6_1_BASE:1.357
	OPENBSD_6_0:1.357.0.6
	OPENBSD_6_0_BASE:1.357
	OPENBSD_5_9:1.357.0.2
	OPENBSD_5_9_BASE:1.357
	OPENBSD_5_8:1.353.0.4
	OPENBSD_5_8_BASE:1.353
	OPENBSD_5_7:1.351.0.4
	OPENBSD_5_7_BASE:1.351
	OPENBSD_5_6:1.347.0.4
	OPENBSD_5_6_BASE:1.347
	OPENBSD_5_5:1.343.0.4
	OPENBSD_5_5_BASE:1.343
	OPENBSD_5_4:1.342.0.2
	OPENBSD_5_4_BASE:1.342
	OPENBSD_5_3:1.341.0.2
	OPENBSD_5_3_BASE:1.341
	OPENBSD_5_2:1.339.0.2
	OPENBSD_5_2_BASE:1.339
	OPENBSD_5_1_BASE:1.337
	OPENBSD_5_1:1.337.0.2
	OPENBSD_5_0:1.332.0.2
	OPENBSD_5_0_BASE:1.332
	OPENBSD_4_9:1.323.0.2
	OPENBSD_4_9_BASE:1.323
	OPENBSD_4_8:1.318.0.2
	OPENBSD_4_8_BASE:1.318
	OPENBSD_4_7:1.306.0.2
	OPENBSD_4_7_BASE:1.306
	OPENBSD_4_6:1.296.0.4
	OPENBSD_4_6_BASE:1.296
	OPENBSD_4_5:1.293.0.2
	OPENBSD_4_5_BASE:1.293
	OPENBSD_4_4:1.287.0.2
	OPENBSD_4_4_BASE:1.287
	OPENBSD_4_3:1.281.0.2
	OPENBSD_4_3_BASE:1.281
	OPENBSD_4_2:1.272.0.2
	OPENBSD_4_2_BASE:1.272
	OPENBSD_4_1:1.262.0.2
	OPENBSD_4_1_BASE:1.262
	OPENBSD_4_0:1.254.0.2
	OPENBSD_4_0_BASE:1.254
	OPENBSD_3_9:1.226.0.2
	OPENBSD_3_9_BASE:1.226
	OPENBSD_3_8:1.201.0.2
	OPENBSD_3_8_BASE:1.201
	OPENBSD_3_7:1.186.0.2
	OPENBSD_3_7_BASE:1.186
	OPENBSD_3_6:1.169.0.2
	OPENBSD_3_6_BASE:1.169
	SMP_SYNC_A:1.168
	SMP_SYNC_B:1.168
	OPENBSD_3_5:1.163.0.2
	OPENBSD_3_5_BASE:1.163
	OPENBSD_3_4:1.138.0.2
	OPENBSD_3_4_BASE:1.138
	UBC_SYNC_A:1.123
	OPENBSD_3_3:1.117.0.2
	OPENBSD_3_3_BASE:1.117
	OPENBSD_3_2:1.91.0.2
	OPENBSD_3_2_BASE:1.91
	OPENBSD_3_1:1.82.0.2
	OPENBSD_3_1_BASE:1.82
	UBC_SYNC_B:1.92
	UBC:1.76.0.2
	UBC_BASE:1.76
	OPENBSD_3_0:1.71.0.2
	OPENBSD_3_0_BASE:1.71
	OPENBSD_2_9_BASE:1.51
	OPENBSD_2_9:1.51.0.2
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	SMP:1.20.0.2
	SMP_BASE:1.20
	kame_19991208:1.15
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11;
locks; strict;
comment	@ * @;


1.358
date	2017.07.12.13.40.59;	author mikeb;	state Exp;
branches;
next	1.357;
commitid	cTjozW3ysyPPIWCb;

1.357
date	2015.12.21.20.52.33;	author mmcc;	state Exp;
branches;
next	1.356;
commitid	k8aE7YBH4hOvqBK0;

1.356
date	2015.11.24.11.24.21;	author mpi;	state Exp;
branches;
next	1.355;
commitid	LNKJOh76qqHsMn33;

1.355
date	2015.10.18.20.24.10;	author uaa;	state Exp;
branches;
next	1.354;
commitid	OXiQnKZHCMrhTxgf;

1.354
date	2015.09.10.18.10.34;	author deraadt;	state Exp;
branches;
next	1.353;
commitid	pbNNrPaFfPV40pxN;

1.353
date	2015.03.21.13.42.06;	author mpi;	state Exp;
branches;
next	1.352;
commitid	Yxcxsi4mmiWWxbGK;

1.352
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.351;
commitid	p4LJxGKbi0BU2cG6;

1.351
date	2015.01.09.07.29.45;	author jsg;	state Exp;
branches;
next	1.350;
commitid	nM2YtwRCeqD1c9uW;

1.350
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.349;
commitid	LS2TNeCue5R9L67C;

1.349
date	2014.10.16.19.30.59;	author kettenis;	state Exp;
branches;
next	1.348;
commitid	X8XwuWaERGtdFJRS;

1.348
date	2014.08.13.07.45.37;	author jsg;	state Exp;
branches;
next	1.347;
commitid	YGAaJF68IQuYIJ8j;

1.347
date	2014.07.13.23.19.51;	author sasano;	state Exp;
branches;
next	1.346;
commitid	PL3amUyfW4Yq7GGJ;

1.346
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.345;
commitid	OBNa5kfxQ2UXoiIw;

1.345
date	2014.04.24.15.38.25;	author jsg;	state Exp;
branches;
next	1.344;

1.344
date	2014.04.24.04.11.17;	author jsg;	state Exp;
branches;
next	1.343;

1.343
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.342;

1.342
date	2013.05.27.21.19.31;	author miod;	state Exp;
branches;
next	1.341;

1.341
date	2013.01.05.08.27.48;	author jasper;	state Exp;
branches;
next	1.340;

1.340
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.339;

1.339
date	2012.04.22.14.22.28;	author miod;	state Exp;
branches;
next	1.338;

1.338
date	2012.03.13.21.32.42;	author kettenis;	state Exp;
branches;
next	1.337;

1.337
date	2012.01.15.15.16.23;	author jsg;	state Exp;
branches;
next	1.336;

1.336
date	2012.01.04.03.38.59;	author jsg;	state Exp;
branches;
next	1.335;

1.335
date	2011.11.12.18.39.23;	author guenther;	state Exp;
branches;
next	1.334;

1.334
date	2011.11.02.23.04.20;	author jsg;	state Exp;
branches;
next	1.333;

1.333
date	2011.09.17.12.23.19;	author jsg;	state Exp;
branches;
next	1.332;

1.332
date	2011.07.15.16.44.18;	author deraadt;	state Exp;
branches;
next	1.331;

1.331
date	2011.07.11.17.10.37;	author jcs;	state Exp;
branches;
next	1.330;

1.330
date	2011.05.09.22.33.54;	author matthew;	state Exp;
branches;
next	1.329;

1.329
date	2011.05.09.22.25.50;	author matthew;	state Exp;
branches;
next	1.328;

1.328
date	2011.04.27.07.55.05;	author jsg;	state Exp;
branches;
next	1.327;

1.327
date	2011.04.18.04.16.12;	author deraadt;	state Exp;
branches;
next	1.326;

1.326
date	2011.04.14.22.24.34;	author jsg;	state Exp;
branches;
next	1.325;

1.325
date	2011.04.07.14.56.38;	author miod;	state Exp;
branches;
next	1.324;

1.324
date	2011.04.03.15.36.03;	author jasper;	state Exp;
branches;
next	1.323;

1.323
date	2010.11.18.18.12.52;	author kettenis;	state Exp;
branches;
next	1.322;

1.322
date	2010.11.06.16.57.34;	author kettenis;	state Exp;
branches;
next	1.321;

1.321
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.320;

1.320
date	2010.08.31.16.02.25;	author deraadt;	state Exp;
branches;
next	1.319;

1.319
date	2010.08.31.12.50.51;	author miod;	state Exp;
branches;
next	1.318;

1.318
date	2010.08.06.05.34.29;	author deraadt;	state Exp;
branches;
next	1.317;

1.317
date	2010.08.06.02.47.27;	author deraadt;	state Exp;
branches;
next	1.316;

1.316
date	2010.08.03.21.53.02;	author deraadt;	state Exp;
branches;
next	1.315;

1.315
date	2010.08.02.13.50.33;	author deraadt;	state Exp;
branches;
next	1.314;

1.314
date	2010.08.02.05.14.34;	author deraadt;	state Exp;
branches;
next	1.313;

1.313
date	2010.07.28.18.31.51;	author deraadt;	state Exp;
branches;
next	1.312;

1.312
date	2010.07.28.15.50.19;	author deraadt;	state Exp;
branches;
next	1.311;

1.311
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.310;

1.310
date	2010.07.23.02.50.04;	author deraadt;	state Exp;
branches;
next	1.309;

1.309
date	2010.07.22.18.11.16;	author deraadt;	state Exp;
branches;
next	1.308;

1.308
date	2010.04.20.06.59.47;	author jsg;	state Exp;
branches;
next	1.307;

1.307
date	2010.04.11.16.58.06;	author kettenis;	state Exp;
branches;
next	1.306;

1.306
date	2009.11.21.14.34.20;	author jsg;	state Exp;
branches;
next	1.305;

1.305
date	2009.11.01.01.50.15;	author dlg;	state Exp;
branches;
next	1.304;

1.304
date	2009.10.18.10.40.03;	author jsg;	state Exp;
branches;
next	1.303;

1.303
date	2009.10.17.00.49.05;	author jsg;	state Exp;
branches;
next	1.302;

1.302
date	2009.10.13.22.05.13;	author jsg;	state Exp;
branches;
next	1.301;

1.301
date	2009.10.05.20.39.26;	author deraadt;	state Exp;
branches;
next	1.300;

1.300
date	2009.10.05.20.01.40;	author jsg;	state Exp;
branches;
next	1.299;

1.299
date	2009.09.29.17.51.07;	author deraadt;	state Exp;
branches;
next	1.298;

1.298
date	2009.09.05.10.24.58;	author miod;	state Exp;
branches;
next	1.297;

1.297
date	2009.08.02.09.48.53;	author sthen;	state Exp;
branches;
next	1.296;

1.296
date	2009.06.26.02.46.27;	author kevlo;	state Exp;
branches;
next	1.295;

1.295
date	2009.05.31.04.42.16;	author jsg;	state Exp;
branches;
next	1.294;

1.294
date	2009.04.24.07.59.50;	author jsg;	state Exp;
branches;
next	1.293;

1.293
date	2009.02.07.02.09.01;	author jsg;	state Exp;
branches;
next	1.292;

1.292
date	2009.01.04.10.37.40;	author jsg;	state Exp;
branches;
next	1.291;

1.291
date	2009.01.04.10.22.01;	author jsg;	state Exp;
branches;
next	1.290;

1.290
date	2008.10.02.16.00.41;	author deraadt;	state Exp;
branches;
next	1.289;

1.289
date	2008.09.25.19.06.57;	author chl;	state Exp;
branches;
next	1.288;

1.288
date	2008.09.17.06.14.09;	author brad;	state Exp;
branches;
next	1.287;

1.287
date	2008.07.29.20.09.11;	author kettenis;	state Exp;
branches;
next	1.286;

1.286
date	2008.07.08.05.59.39;	author brad;	state Exp;
branches;
next	1.285;

1.285
date	2008.07.06.10.38.52;	author jsg;	state Exp;
branches;
next	1.284;

1.284
date	2008.06.13.17.03.26;	author maja;	state Exp;
branches;
next	1.283;

1.283
date	2008.06.11.05.28.33;	author brad;	state Exp;
branches;
next	1.282;

1.282
date	2008.04.29.11.40.58;	author jsg;	state Exp;
branches;
next	1.281;

1.281
date	2008.02.27.20.10.29;	author kettenis;	state Exp;
branches;
next	1.280;

1.280
date	2008.02.05.20.22.22;	author blambert;	state Exp;
branches;
next	1.279;

1.279
date	2008.01.29.10.34.00;	author jsg;	state Exp;
branches;
next	1.278;

1.278
date	2008.01.11.11.30.56;	author jsg;	state Exp;
branches;
next	1.277;

1.277
date	2008.01.02.06.54.30;	author brad;	state Exp;
branches;
next	1.276;

1.276
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.275;

1.275
date	2007.10.17.22.11.52;	author brad;	state Exp;
branches;
next	1.274;

1.274
date	2007.10.09.23.26.05;	author krw;	state Exp;
branches;
next	1.273;

1.273
date	2007.09.14.23.18.25;	author brad;	state Exp;
branches;
next	1.272;

1.272
date	2007.07.02.14.01.14;	author dlg;	state Exp;
branches;
next	1.271;

1.271
date	2007.06.26.17.48.18;	author kettenis;	state Exp;
branches;
next	1.270;

1.270
date	2007.06.20.04.10.59;	author jsg;	state Exp;
branches;
next	1.269;

1.269
date	2007.06.02.18.44.44;	author jsg;	state Exp;
branches;
next	1.268;

1.268
date	2007.05.11.13.26.20;	author jsg;	state Exp;
branches;
next	1.267;

1.267
date	2007.05.10.17.41.50;	author kettenis;	state Exp;
branches;
next	1.266;

1.266
date	2007.05.02.00.53.25;	author jsg;	state Exp;
branches;
next	1.265;

1.265
date	2007.03.27.15.40.18;	author deraadt;	state Exp;
branches;
next	1.264;

1.264
date	2007.03.27.07.16.09;	author deraadt;	state Exp;
branches;
next	1.263;

1.263
date	2007.03.21.12.20.30;	author jsg;	state Exp;
branches;
next	1.262;

1.262
date	2006.11.21.21.48.54;	author brad;	state Exp;
branches;
next	1.261;

1.261
date	2006.11.19.21.45.49;	author brad;	state Exp;
branches;
next	1.260;

1.260
date	2006.11.05.20.27.42;	author brad;	state Exp;
branches;
next	1.259;

1.259
date	2006.10.19.09.55.47;	author tom;	state Exp;
branches;
next	1.258;

1.258
date	2006.10.02.17.56.41;	author brad;	state Exp;
branches;
next	1.257;

1.257
date	2006.09.26.06.53.41;	author jsg;	state Exp;
branches;
next	1.256;

1.256
date	2006.09.26.06.45.13;	author jsg;	state Exp;
branches;
next	1.255;

1.255
date	2006.09.19.03.34.49;	author brad;	state Exp;
branches;
next	1.254;

1.254
date	2006.09.16.00.46.56;	author jsg;	state Exp;
branches;
next	1.253;

1.253
date	2006.09.16.00.39.54;	author jsg;	state Exp;
branches;
next	1.252;

1.252
date	2006.08.19.17.59.00;	author jsg;	state Exp;
branches;
next	1.251;

1.251
date	2006.08.19.17.38.56;	author jsg;	state Exp;
branches;
next	1.250;

1.250
date	2006.08.06.01.24.38;	author brad;	state Exp;
branches;
next	1.249;

1.249
date	2006.07.23.02.12.12;	author brad;	state Exp;
branches;
next	1.248;

1.248
date	2006.07.16.13.24.14;	author jsg;	state Exp;
branches;
next	1.247;

1.247
date	2006.07.10.21.28.29;	author deraadt;	state Exp;
branches;
next	1.246;

1.246
date	2006.07.08.06.39.00;	author brad;	state Exp;
branches;
next	1.245;

1.245
date	2006.07.07.03.56.33;	author brad;	state Exp;
branches;
next	1.244;

1.244
date	2006.07.07.00.01.15;	author jsg;	state Exp;
branches;
next	1.243;

1.243
date	2006.06.26.22.14.59;	author miod;	state Exp;
branches;
next	1.242;

1.242
date	2006.06.26.02.40.40;	author brad;	state Exp;
branches;
next	1.241;

1.241
date	2006.06.24.10.11.03;	author jsg;	state Exp;
branches;
next	1.240;

1.240
date	2006.06.24.07.51.30;	author jsg;	state Exp;
branches;
next	1.239;

1.239
date	2006.04.27.00.34.19;	author jsg;	state Exp;
branches;
next	1.238;

1.238
date	2006.04.26.23.52.06;	author jsg;	state Exp;
branches;
next	1.237;

1.237
date	2006.04.26.15.15.46;	author jsg;	state Exp;
branches;
next	1.236;

1.236
date	2006.04.25.09.09.42;	author jsg;	state Exp;
branches;
next	1.235;

1.235
date	2006.04.23.15.08.34;	author jsg;	state Exp;
branches;
next	1.234;

1.234
date	2006.04.17.01.51.37;	author jsg;	state Exp;
branches;
next	1.233;

1.233
date	2006.04.15.00.15.12;	author jsg;	state Exp;
branches;
next	1.232;

1.232
date	2006.04.09.00.51.58;	author brad;	state Exp;
branches;
next	1.231;

1.231
date	2006.04.02.01.36.07;	author jsg;	state Exp;
branches;
next	1.230;

1.230
date	2006.03.28.12.56.44;	author robert;	state Exp;
branches;
next	1.229;

1.229
date	2006.03.27.20.33.38;	author kettenis;	state Exp;
branches;
next	1.228;

1.228
date	2006.03.27.09.59.26;	author jsg;	state Exp;
branches;
next	1.227;

1.227
date	2006.03.06.19.32.18;	author kettenis;	state Exp;
branches;
next	1.226;

1.226
date	2006.02.24.20.59.04;	author kettenis;	state Exp;
branches;
next	1.225;

1.225
date	2006.02.10.21.45.41;	author kettenis;	state Exp;
branches;
next	1.224;

1.224
date	2006.02.03.11.50.34;	author brad;	state Exp;
branches;
next	1.223;

1.223
date	2006.02.03.08.54.51;	author brad;	state Exp;
branches;
next	1.222;

1.222
date	2006.02.01.09.32.42;	author jsg;	state Exp;
branches;
next	1.221;

1.221
date	2006.01.24.12.25.51;	author jsg;	state Exp;
branches;
next	1.220;

1.220
date	2006.01.22.17.31.27;	author kettenis;	state Exp;
branches;
next	1.219;

1.219
date	2006.01.01.18.40.08;	author kettenis;	state Exp;
branches;
next	1.218;

1.218
date	2005.12.15.00.01.10;	author krw;	state Exp;
branches;
next	1.217;

1.217
date	2005.10.26.21.07.38;	author brad;	state Exp;
branches;
next	1.216;

1.216
date	2005.10.22.23.13.26;	author brad;	state Exp;
branches;
next	1.215;

1.215
date	2005.10.22.23.03.30;	author brad;	state Exp;
branches;
next	1.214;

1.214
date	2005.10.20.18.30.06;	author brad;	state Exp;
branches;
next	1.213;

1.213
date	2005.10.20.12.06.51;	author grange;	state Exp;
branches;
next	1.212;

1.212
date	2005.10.18.13.07.34;	author brad;	state Exp;
branches;
next	1.211;

1.211
date	2005.10.17.11.35.05;	author jsg;	state Exp;
branches;
next	1.210;

1.210
date	2005.10.17.11.24.25;	author jsg;	state Exp;
branches;
next	1.209;

1.209
date	2005.10.17.06.43.48;	author grange;	state Exp;
branches;
next	1.208;

1.208
date	2005.10.17.06.35.17;	author grange;	state Exp;
branches;
next	1.207;

1.207
date	2005.10.16.20.07.21;	author kettenis;	state Exp;
branches;
next	1.206;

1.206
date	2005.10.15.23.07.09;	author brad;	state Exp;
branches;
next	1.205;

1.205
date	2005.10.15.11.42.52;	author brad;	state Exp;
branches;
next	1.204;

1.204
date	2005.09.15.06.43.02;	author jsg;	state Exp;
branches;
next	1.203;

1.203
date	2005.09.14.06.13.22;	author jsg;	state Exp;
branches;
next	1.202;

1.202
date	2005.09.05.13.21.49;	author jsg;	state Exp;
branches;
next	1.201;

1.201
date	2005.08.18.13.40.00;	author jsg;	state Exp;
branches;
next	1.200;

1.200
date	2005.08.18.13.05.59;	author jsg;	state Exp;
branches;
next	1.199;

1.199
date	2005.08.09.04.10.13;	author mickey;	state Exp;
branches;
next	1.198;

1.198
date	2005.07.21.09.47.57;	author jsg;	state Exp;
branches;
next	1.197;

1.197
date	2005.07.09.09.45.21;	author ho;	state Exp;
branches;
next	1.196;

1.196
date	2005.06.15.04.45.48;	author fgsch;	state Exp;
branches;
next	1.195;

1.195
date	2005.06.08.20.43.40;	author fgsch;	state Exp;
branches;
next	1.194;

1.194
date	2005.06.01.21.50.52;	author miod;	state Exp;
branches;
next	1.193;

1.193
date	2005.05.26.17.43.24;	author jsg;	state Exp;
branches;
next	1.192;

1.192
date	2005.04.29.01.11.46;	author jsg;	state Exp;
branches;
next	1.191;

1.191
date	2005.04.20.00.57.25;	author jsg;	state Exp;
branches;
next	1.190;

1.190
date	2005.04.20.00.53.11;	author jsg;	state Exp;
branches;
next	1.189;

1.189
date	2005.04.20.00.46.20;	author jsg;	state Exp;
branches;
next	1.188;

1.188
date	2005.04.20.00.35.55;	author jsg;	state Exp;
branches;
next	1.187;

1.187
date	2005.04.10.00.45.41;	author jsg;	state Exp;
branches;
next	1.186;

1.186
date	2005.02.21.19.55.50;	author grange;	state Exp;
branches;
next	1.185;

1.185
date	2005.02.01.21.53.55;	author grange;	state Exp;
branches;
next	1.184;

1.184
date	2005.01.31.04.25.44;	author martin;	state Exp;
branches;
next	1.183;

1.183
date	2005.01.22.15.08.52;	author martin;	state Exp;
branches;
next	1.182;

1.182
date	2005.01.15.15.23.39;	author jsg;	state Exp;
branches;
next	1.181;

1.181
date	2004.12.11.08.39.28;	author henning;	state Exp;
branches;
next	1.180;

1.180
date	2004.11.27.09.14.23;	author grange;	state Exp;
branches;
next	1.179;

1.179
date	2004.11.21.18.43.58;	author grange;	state Exp;
branches;
next	1.178;

1.178
date	2004.10.19.13.07.00;	author grange;	state Exp;
branches;
next	1.177;

1.177
date	2004.10.17.19.21.37;	author grange;	state Exp;
branches;
next	1.176;

1.176
date	2004.10.17.19.00.45;	author grange;	state Exp;
branches;
next	1.175;

1.175
date	2004.10.17.18.47.08;	author grange;	state Exp;
branches;
next	1.174;

1.174
date	2004.10.17.18.16.12;	author grange;	state Exp;
branches;
next	1.173;

1.173
date	2004.10.17.18.05.55;	author grange;	state Exp;
branches;
next	1.172;

1.172
date	2004.10.17.17.52.45;	author grange;	state Exp;
branches;
next	1.171;

1.171
date	2004.10.17.17.42.01;	author grange;	state Exp;
branches;
next	1.170;

1.170
date	2004.09.15.17.53.18;	author grange;	state Exp;
branches;
next	1.169;

1.169
date	2004.08.21.07.13.55;	author mickey;	state Exp;
branches;
next	1.168;

1.168
date	2004.06.02.18.55.08;	author grange;	state Exp;
branches;
next	1.167;

1.167
date	2004.05.24.22.52.52;	author mickey;	state Exp;
branches;
next	1.166;

1.166
date	2004.05.06.17.28.18;	author peter;	state Exp;
branches;
next	1.165;

1.165
date	2004.05.04.15.10.59;	author grange;	state Exp;
branches;
next	1.164;

1.164
date	2004.05.03.15.18.21;	author drahn;	state Exp;
branches;
next	1.163;

1.163
date	2004.03.12.19.10.07;	author grange;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2004.02.18.09.49.04;	author grange;	state Exp;
branches;
next	1.161;

1.161
date	2004.02.07.19.27.24;	author grange;	state Exp;
branches;
next	1.160;

1.160
date	2004.02.02.19.38.43;	author grange;	state Exp;
branches;
next	1.159;

1.159
date	2004.02.02.00.21.56;	author grange;	state Exp;
branches;
next	1.158;

1.158
date	2004.01.31.20.01.42;	author grange;	state Exp;
branches;
next	1.157;

1.157
date	2004.01.31.19.53.18;	author grange;	state Exp;
branches;
next	1.156;

1.156
date	2004.01.31.19.46.44;	author grange;	state Exp;
branches;
next	1.155;

1.155
date	2004.01.31.19.29.39;	author grange;	state Exp;
branches;
next	1.154;

1.154
date	2004.01.17.21.23.16;	author grange;	state Exp;
branches;
next	1.153;

1.153
date	2004.01.09.21.32.24;	author brad;	state Exp;
branches;
next	1.152;

1.152
date	2003.12.20.08.03.54;	author grange;	state Exp;
branches;
next	1.151;

1.151
date	2003.12.12.13.03.51;	author grange;	state Exp;
branches;
next	1.150;

1.150
date	2003.12.12.13.00.37;	author grange;	state Exp;
branches;
next	1.149;

1.149
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.148;

1.148
date	2003.10.31.04.11.41;	author drahn;	state Exp;
branches;
next	1.147;

1.147
date	2003.10.29.18.46.43;	author matthieu;	state Exp;
branches;
next	1.146;

1.146
date	2003.10.29.17.31.11;	author matthieu;	state Exp;
branches;
next	1.145;

1.145
date	2003.10.17.08.51.19;	author grange;	state Exp;
branches;
next	1.144;

1.144
date	2003.10.17.08.14.09;	author grange;	state Exp;
branches;
next	1.143;

1.143
date	2003.10.16.14.52.58;	author grange;	state Exp;
branches;
next	1.142;

1.142
date	2003.10.16.11.30.00;	author grange;	state Exp;
branches;
next	1.141;

1.141
date	2003.10.09.18.57.00;	author grange;	state Exp;
branches;
next	1.140;

1.140
date	2003.09.29.13.39.16;	author grange;	state Exp;
branches;
next	1.139;

1.139
date	2003.09.28.21.01.43;	author grange;	state Exp;
branches;
next	1.138;

1.138
date	2003.08.01.11.05.09;	author grange;	state Exp;
branches;
next	1.137;

1.137
date	2003.07.30.19.59.17;	author grange;	state Exp;
branches;
next	1.136;

1.136
date	2003.07.29.18.16.27;	author grange;	state Exp;
branches;
next	1.135;

1.135
date	2003.07.23.22.10.36;	author grange;	state Exp;
branches;
next	1.134;

1.134
date	2003.07.23.22.07.15;	author grange;	state Exp;
branches;
next	1.133;

1.133
date	2003.07.20.22.26.50;	author tedu;	state Exp;
branches;
next	1.132;

1.132
date	2003.06.18.20.21.50;	author grange;	state Exp;
branches;
next	1.131;

1.131
date	2003.06.07.20.00.31;	author grange;	state Exp;
branches;
next	1.130;

1.130
date	2003.06.07.19.49.50;	author grange;	state Exp;
branches;
next	1.129;

1.129
date	2003.06.06.11.28.41;	author grange;	state Exp;
branches;
next	1.128;

1.128
date	2003.05.30.09.07.46;	author grange;	state Exp;
branches;
next	1.127;

1.127
date	2003.05.22.19.26.27;	author grange;	state Exp;
branches;
next	1.126;

1.126
date	2003.05.17.18.45.15;	author grange;	state Exp;
branches;
next	1.125;

1.125
date	2003.05.17.18.35.04;	author grange;	state Exp;
branches;
next	1.124;

1.124
date	2003.05.17.18.31.54;	author grange;	state Exp;
branches;
next	1.123;

1.123
date	2003.05.02.09.33.33;	author grange;	state Exp;
branches;
next	1.122;

1.122
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.121;

1.121
date	2003.04.20.21.09.28;	author grange;	state Exp;
branches;
next	1.120;

1.120
date	2003.03.29.11.02.09;	author grange;	state Exp;
branches;
next	1.119;

1.119
date	2003.03.28.23.49.48;	author millert;	state Exp;
branches;
next	1.118;

1.118
date	2003.03.28.16.12.28;	author grange;	state Exp;
branches;
next	1.117;

1.117
date	2003.03.06.11.49.20;	author grange;	state Exp;
branches;
next	1.116;

1.116
date	2003.02.24.20.54.15;	author grange;	state Exp;
branches;
next	1.115;

1.115
date	2003.02.24.01.34.41;	author grange;	state Exp;
branches;
next	1.114;

1.114
date	2003.02.21.20.10.33;	author grange;	state Exp;
branches;
next	1.113;

1.113
date	2003.02.13.15.39.59;	author grange;	state Exp;
branches;
next	1.112;

1.112
date	2003.02.13.15.30.21;	author grange;	state Exp;
branches;
next	1.111;

1.111
date	2003.01.30.07.50.17;	author henric;	state Exp;
branches;
next	1.110;

1.110
date	2003.01.17.00.54.23;	author grange;	state Exp;
branches;
next	1.109;

1.109
date	2003.01.16.17.24.46;	author grange;	state Exp;
branches;
next	1.108;

1.108
date	2003.01.16.16.15.46;	author grange;	state Exp;
branches;
next	1.107;

1.107
date	2003.01.16.12.31.01;	author grange;	state Exp;
branches;
next	1.106;

1.106
date	2003.01.16.01.17.23;	author grange;	state Exp;
branches;
next	1.105;

1.105
date	2003.01.15.01.36.10;	author grange;	state Exp;
branches;
next	1.104;

1.104
date	2003.01.14.20.52.10;	author grange;	state Exp;
branches;
next	1.103;

1.103
date	2003.01.13.23.29.27;	author grange;	state Exp;
branches;
next	1.102;

1.102
date	2002.12.19.16.32.59;	author grange;	state Exp;
branches;
next	1.101;

1.101
date	2002.12.10.11.47.47;	author grange;	state Exp;
branches;
next	1.100;

1.100
date	2002.11.24.19.39.19;	author grange;	state Exp;
branches;
next	1.99;

1.99
date	2002.11.20.21.33.37;	author grange;	state Exp;
branches;
next	1.98;

1.98
date	2002.11.20.19.39.02;	author jason;	state Exp;
branches;
next	1.97;

1.97
date	2002.11.18.11.06.40;	author grange;	state Exp;
branches;
next	1.96;

1.96
date	2002.11.17.19.21.52;	author grange;	state Exp;
branches;
next	1.95;

1.95
date	2002.11.15.03.33.25;	author grange;	state Exp;
branches;
next	1.94;

1.94
date	2002.11.08.11.44.59;	author gluk;	state Exp;
branches;
next	1.93;

1.93
date	2002.11.08.11.07.28;	author gluk;	state Exp;
branches;
next	1.92;

1.92
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2002.09.09.17.45.26;	author gluk;	state Exp;
branches;
next	1.90;

1.90
date	2002.08.30.16.21.43;	author gluk;	state Exp;
branches;
next	1.89;

1.89
date	2002.08.09.20.26.45;	author jsyn;	state Exp;
branches;
next	1.88;

1.88
date	2002.07.29.22.19.39;	author mickey;	state Exp;
branches;
next	1.87;

1.87
date	2002.07.10.11.01.01;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2002.07.06.14.35.47;	author gluk;	state Exp;
branches;
next	1.85;

1.85
date	2002.06.08.23.32.51;	author chris;	state Exp;
branches;
next	1.84;

1.84
date	2002.06.08.23.04.07;	author chris;	state Exp;
branches;
next	1.83;

1.83
date	2002.05.03.13.25.30;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2002.04.01.16.57.54;	author gluk;	state Exp;
branches;
next	1.81;

1.81
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.79;

1.79
date	2002.03.01.20.01.35;	author chris;	state Exp;
branches;
next	1.78;

1.78
date	2002.02.16.08.18.57;	author chris;	state Exp;
branches;
next	1.77;

1.77
date	2002.02.10.04.29.32;	author chris;	state Exp;
branches;
next	1.76;

1.76
date	2001.12.11.22.04.12;	author chris;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2001.11.18.20.55.42;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2001.11.11.07.43.30;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2001.09.29.04.46.49;	author jason;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2001.09.29.03.28.11;	author jason;	state Exp;
branches;
next	1.69;

1.69
date	2001.09.29.02.41.31;	author jason;	state Exp;
branches;
next	1.68;

1.68
date	2001.09.27.16.35.03;	author gluk;	state Exp;
branches;
next	1.67;

1.67
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2001.08.31.18.14.37;	author chris;	state Exp;
branches;
next	1.65;

1.65
date	2001.08.25.12.43.58;	author art;	state Exp;
branches;
next	1.64;

1.64
date	2001.08.25.10.13.30;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2001.08.23.11.25.54;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2001.08.23.11.04.24;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.60;

1.60
date	2001.08.03.22.03.44;	author chris;	state Exp;
branches;
next	1.59;

1.59
date	2001.07.31.06.14.05;	author csapuntz;	state Exp;
branches;
next	1.58;

1.58
date	2001.07.20.05.56.25;	author csapuntz;	state Exp;
branches;
next	1.57;

1.57
date	2001.07.19.18.16.22;	author csapuntz;	state Exp;
branches;
next	1.56;

1.56
date	2001.06.27.05.22.31;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2001.06.26.05.58.38;	author csapuntz;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.25.23.00.55;	author csapuntz;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.12.15.40.32;	author niklas;	state Exp;
branches;
next	1.52;

1.52
date	2001.05.22.15.32.38;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	2001.04.17.22.43.50;	author chris;	state Exp;
branches;
next	1.50;

1.50
date	2001.04.04.18.25.07;	author csapuntz;	state Exp;
branches;
next	1.49;

1.49
date	2001.04.04.07.02.51;	author csapuntz;	state Exp;
branches;
next	1.48;

1.48
date	2001.03.26.22.17.05;	author chris;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.25.13.11.54;	author csapuntz;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.16.09.16.05;	author chris;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.22.03.04.09;	author chris;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.06.07.57.08;	author chris;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.29.00.20.17;	author csapuntz;	state Exp;
branches;
next	1.42;

1.42
date	2001.01.22.23.09.05;	author chris;	state Exp;
branches;
next	1.41;

1.41
date	2001.01.18.22.09.12;	author chris;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.08.19.54.09;	author jeremy;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.08.14.44.57;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2000.12.06.22.45.41;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.20.14.24.29;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.13.23.09.58;	author chris;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.07.23.31.39;	author chris;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.21.17.57.23;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.10.21.05.43.18;	author chris;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.16.18.09.56;	author chris;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.25.15.33.39;	author chris;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.05.00.53.01;	author chris;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.31.23.39.43;	author chris;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.07.19.07.21;	author chris;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.07.18.42.16;	author chris;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.26.18.09.11;	author chris;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.26.17.51.16;	author chris;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.13.03.56.41;	author chris;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.04.19.42.53;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.10.07.06.17;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.24.17.47.41;	author chris;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.17.17.12.34;	author chris;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.01.11.01.16.00;	author chris;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.11.01.14.52;	author chris;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.10.23.28.35;	author chris;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.10.22.54.45;	author chris;	state Exp;
branches;
next	1.15;

1.15
date	99.11.23.20.48.35;	author chris;	state Exp;
branches;
next	1.14;

1.14
date	99.11.17.01.22.56;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	99.11.03.01.02.56;	author chris;	state Exp;
branches;
next	1.12;

1.12
date	99.11.02.02.43.45;	author chris;	state Exp;
branches;
next	1.11;

1.11
date	99.10.09.03.42.04;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	99.10.04.22.54.18;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.09.01.04.32.14;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	99.08.05.00.10.31;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.08.04.23.27.49;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.07.30.00.17.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.07.25.04.42.31;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	99.07.22.04.37.30;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.07.20.07.48.12;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.07.19.00.32.44;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	99.07.18.21.25.19;	author csapuntz;	state Exp;
branches;
next	;

1.20.2.1
date	2001.05.14.22.25.54;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.07.04.10.42.55;	author niklas;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.10.31.03.22.47;	author nate;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2001.11.13.21.10.03;	author niklas;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2001.12.05.00.43.30;	author niklas;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2002.03.06.02.11.46;	author niklas;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2002.03.28.15.35.58;	author niklas;	state Exp;
branches;
next	1.20.2.8;

1.20.2.8
date	2003.03.28.00.38.24;	author niklas;	state Exp;
branches;
next	1.20.2.9;

1.20.2.9
date	2003.04.19.19.17.49;	author niklas;	state Exp;
branches;
next	1.20.2.10;

1.20.2.10
date	2003.05.13.19.35.08;	author ho;	state Exp;
branches;
next	1.20.2.11;

1.20.2.11
date	2003.06.07.11.02.31;	author ho;	state Exp;
branches;
next	1.20.2.12;

1.20.2.12
date	2004.02.19.10.56.29;	author niklas;	state Exp;
branches;
next	1.20.2.13;

1.20.2.13
date	2004.06.05.23.12.53;	author niklas;	state Exp;
branches;
next	;

1.71.2.1
date	2001.11.14.03.00.46;	author jason;	state Exp;
branches;
next	;

1.76.2.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.76.2.2;

1.76.2.2
date	2002.10.29.00.33.29;	author art;	state Exp;
branches;
next	1.76.2.3;

1.76.2.3
date	2003.05.19.22.18.02;	author tedu;	state Exp;
branches;
next	;

1.163.2.1
date	2004.05.14.21.32.19;	author brad;	state Exp;
branches;
next	;


desc
@@


1.358
log
@Introduce two quirks to prevent attaching ATA and ATAPI devices

Hyper-V and Xen have varying support for detaching emulated IDE
devices ranging from none on Hyper-V to only IDE disks but not
CDROM (Xen). The quirk mechanism provides a way of enforcing the
desired behavior.

With suggestions and OK kettenis, tedu, mlarkin
@
text
@/*	$OpenBSD: pciide.c,v 1.357 2015/12/21 20:52:33 mmcc Exp $	*/
/*	$NetBSD: pciide.c,v 1.127 2001/08/03 01:31:08 tsutsui Exp $	*/

/*
 * Copyright (c) 1999, 2000, 2001 Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Copyright (c) 1996, 1998 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCI IDE controller driver.
 *
 * Author: Christopher G. Demetriou, March 2, 1998 (derived from NetBSD
 * sys/dev/pci/ppb.c, revision 1.16).
 *
 * See "PCI IDE Controller Specification, Revision 1.0 3/4/94" and
 * "Programming Interface for Bus Master IDE Controller, Revision 1.0
 * 5/16/94" from the PCI SIG.
 *
 */

#define DEBUG_DMA	0x01
#define DEBUG_XFERS	0x02
#define DEBUG_FUNCS	0x08
#define DEBUG_PROBE	0x10

#ifdef WDCDEBUG
#ifndef WDCDEBUG_PCIIDE_MASK
#define WDCDEBUG_PCIIDE_MASK 0x00
#endif
int wdcdebug_pciide_mask = WDCDEBUG_PCIIDE_MASK;
#define WDCDEBUG_PRINT(args, level) do {		\
	if ((wdcdebug_pciide_mask & (level)) != 0)	\
		printf args;				\
} while (0)
#else
#define WDCDEBUG_PRINT(args, level)
#endif
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/endian.h>

#include <machine/bus.h>

#include <dev/ata/atavar.h>
#include <dev/ata/satareg.h>
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcvar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/pciidereg.h>
#include <dev/pci/pciidevar.h>
#include <dev/pci/pciide_piix_reg.h>
#include <dev/pci/pciide_amd_reg.h>
#include <dev/pci/pciide_apollo_reg.h>
#include <dev/pci/pciide_cmd_reg.h>
#include <dev/pci/pciide_sii3112_reg.h>
#include <dev/pci/pciide_cy693_reg.h>
#include <dev/pci/pciide_sis_reg.h>
#include <dev/pci/pciide_acer_reg.h>
#include <dev/pci/pciide_pdc202xx_reg.h>
#include <dev/pci/pciide_opti_reg.h>
#include <dev/pci/pciide_hpt_reg.h>
#include <dev/pci/pciide_acard_reg.h>
#include <dev/pci/pciide_natsemi_reg.h>
#include <dev/pci/pciide_nforce_reg.h>
#include <dev/pci/pciide_ite_reg.h>
#include <dev/pci/pciide_ixp_reg.h>
#include <dev/pci/pciide_svwsata_reg.h>
#include <dev/pci/pciide_jmicron_reg.h>
#include <dev/pci/pciide_rdc_reg.h>
#include <dev/pci/cy82c693var.h>

int pciide_skip_ata;
int pciide_skip_atapi;

/* functions for reading/writing 8-bit PCI registers */

u_int8_t pciide_pci_read(pci_chipset_tag_t, pcitag_t,
					int);
void pciide_pci_write(pci_chipset_tag_t, pcitag_t,
					int, u_int8_t);

u_int8_t
pciide_pci_read(pci_chipset_tag_t pc, pcitag_t pa, int reg)
{
	return (pci_conf_read(pc, pa, (reg & ~0x03)) >>
	    ((reg & 0x03) * 8) & 0xff);
}

void
pciide_pci_write(pci_chipset_tag_t pc, pcitag_t pa, int reg, u_int8_t val)
{
	pcireg_t pcival;

	pcival = pci_conf_read(pc, pa, (reg & ~0x03));
	pcival &= ~(0xff << ((reg & 0x03) * 8));
	pcival |= (val << ((reg & 0x03) * 8));
	pci_conf_write(pc, pa, (reg & ~0x03), pcival);
}

void default_chip_map(struct pciide_softc *, struct pci_attach_args *);

void sata_chip_map(struct pciide_softc *, struct pci_attach_args *);
void sata_setup_channel(struct channel_softc *);

void piix_chip_map(struct pciide_softc *, struct pci_attach_args *);
void piixsata_chip_map(struct pciide_softc *, struct pci_attach_args *);
void piix_setup_channel(struct channel_softc *);
void piix3_4_setup_channel(struct channel_softc *);
void piix_timing_debug(struct pciide_softc *);

u_int32_t piix_setup_idetim_timings(u_int8_t, u_int8_t, u_int8_t);
u_int32_t piix_setup_idetim_drvs(struct ata_drive_datas *);
u_int32_t piix_setup_sidetim_timings(u_int8_t, u_int8_t, u_int8_t);

void amd756_chip_map(struct pciide_softc *, struct pci_attach_args *);
void amd756_setup_channel(struct channel_softc *);

void apollo_chip_map(struct pciide_softc *, struct pci_attach_args *);
void apollo_setup_channel(struct channel_softc *);

void cmd_chip_map(struct pciide_softc *, struct pci_attach_args *);
void cmd0643_9_chip_map(struct pciide_softc *, struct pci_attach_args *);
void cmd0643_9_setup_channel(struct channel_softc *);
void cmd680_chip_map(struct pciide_softc *, struct pci_attach_args *);
void cmd680_setup_channel(struct channel_softc *);
void cmd680_channel_map(struct pci_attach_args *, struct pciide_softc *, int);
void cmd_channel_map(struct pci_attach_args *,
			struct pciide_softc *, int);
int  cmd_pci_intr(void *);
void cmd646_9_irqack(struct channel_softc *);

void sii_fixup_cacheline(struct pciide_softc *, struct pci_attach_args *);
void sii3112_chip_map(struct pciide_softc *, struct pci_attach_args *);
void sii3112_setup_channel(struct channel_softc *);
void sii3112_drv_probe(struct channel_softc *);
void sii3114_chip_map(struct pciide_softc *, struct pci_attach_args *);
void sii3114_mapreg_dma(struct pciide_softc *, struct pci_attach_args *);
int  sii3114_chansetup(struct pciide_softc *, int);
void sii3114_mapchan(struct pciide_channel *);
u_int8_t sii3114_dmacmd_read(struct pciide_softc *, int);
void sii3114_dmacmd_write(struct pciide_softc *, int, u_int8_t);
u_int8_t sii3114_dmactl_read(struct pciide_softc *, int);
void sii3114_dmactl_write(struct pciide_softc *, int, u_int8_t);
void sii3114_dmatbl_write(struct pciide_softc *, int, u_int32_t);

void cy693_chip_map(struct pciide_softc *, struct pci_attach_args *);
void cy693_setup_channel(struct channel_softc *);

void sis_chip_map(struct pciide_softc *, struct pci_attach_args *);
void sis_setup_channel(struct channel_softc *);
void sis96x_setup_channel(struct channel_softc *);
int  sis_hostbr_match(struct pci_attach_args *);
int  sis_south_match(struct pci_attach_args *);

void natsemi_chip_map(struct pciide_softc *, struct pci_attach_args *);
void natsemi_setup_channel(struct channel_softc *);
int  natsemi_pci_intr(void *);
void natsemi_irqack(struct channel_softc *);
void ns_scx200_chip_map(struct pciide_softc *, struct pci_attach_args *);
void ns_scx200_setup_channel(struct channel_softc *);

void acer_chip_map(struct pciide_softc *, struct pci_attach_args *);
void acer_setup_channel(struct channel_softc *);
int  acer_pci_intr(void *);
int  acer_dma_init(void *, int, int, void *, size_t, int);

void pdc202xx_chip_map(struct pciide_softc *, struct pci_attach_args *);
void pdc202xx_setup_channel(struct channel_softc *);
void pdc20268_setup_channel(struct channel_softc *);
int  pdc202xx_pci_intr(void *);
int  pdc20265_pci_intr(void *);
void pdc20262_dma_start(void *, int, int);
int  pdc20262_dma_finish(void *, int, int, int);

u_int8_t pdc268_config_read(struct channel_softc *, int);

void pdcsata_chip_map(struct pciide_softc *, struct pci_attach_args *);
void pdc203xx_setup_channel(struct channel_softc *);
int  pdc203xx_pci_intr(void *);
void pdc203xx_irqack(struct channel_softc *);
void pdc203xx_dma_start(void *,int ,int);
int  pdc203xx_dma_finish(void *, int, int, int);
int  pdc205xx_pci_intr(void *);
void pdc205xx_do_reset(struct channel_softc *);
void pdc205xx_drv_probe(struct channel_softc *);

void opti_chip_map(struct pciide_softc *, struct pci_attach_args *);
void opti_setup_channel(struct channel_softc *);

void hpt_chip_map(struct pciide_softc *, struct pci_attach_args *);
void hpt_setup_channel(struct channel_softc *);
int  hpt_pci_intr(void *);

void acard_chip_map(struct pciide_softc *, struct pci_attach_args *);
void acard_setup_channel(struct channel_softc *);

void serverworks_chip_map(struct pciide_softc *, struct pci_attach_args *);
void serverworks_setup_channel(struct channel_softc *);
int  serverworks_pci_intr(void *);

void svwsata_chip_map(struct pciide_softc *, struct pci_attach_args *);
void svwsata_mapreg_dma(struct pciide_softc *, struct pci_attach_args *);
void svwsata_mapchan(struct pciide_channel *);
u_int8_t svwsata_dmacmd_read(struct pciide_softc *, int);
void svwsata_dmacmd_write(struct pciide_softc *, int, u_int8_t);
u_int8_t svwsata_dmactl_read(struct pciide_softc *, int);
void svwsata_dmactl_write(struct pciide_softc *, int, u_int8_t);
void svwsata_dmatbl_write(struct pciide_softc *, int, u_int32_t);
void svwsata_drv_probe(struct channel_softc *);

void nforce_chip_map(struct pciide_softc *, struct pci_attach_args *);
void nforce_setup_channel(struct channel_softc *);
int  nforce_pci_intr(void *);

void artisea_chip_map(struct pciide_softc *, struct pci_attach_args *);

void ite_chip_map(struct pciide_softc *, struct pci_attach_args *);
void ite_setup_channel(struct channel_softc *);

void ixp_chip_map(struct pciide_softc *, struct pci_attach_args *);
void ixp_setup_channel(struct channel_softc *);

void jmicron_chip_map(struct pciide_softc *, struct pci_attach_args *);
void jmicron_setup_channel(struct channel_softc *);

void phison_chip_map(struct pciide_softc *, struct pci_attach_args *);
void phison_setup_channel(struct channel_softc *);

void sch_chip_map(struct pciide_softc *, struct pci_attach_args *);
void sch_setup_channel(struct channel_softc *);

void rdc_chip_map(struct pciide_softc *, struct pci_attach_args *);
void rdc_setup_channel(struct channel_softc *);

struct pciide_product_desc {
	u_int32_t ide_product;
	u_short ide_flags;
	/* map and setup chip, probe drives */
	void (*chip_map)(struct pciide_softc *, struct pci_attach_args *);
};

/* Flags for ide_flags */
#define IDE_PCI_CLASS_OVERRIDE	0x0001	/* accept even if class != pciide */
#define IDE_16BIT_IOSPACE	0x0002	/* I/O space BARS ignore upper word */

/* Default product description for devices not known from this controller */
const struct pciide_product_desc default_product_desc = {
	0,				/* Generic PCI IDE controller */
	0,
	default_chip_map
};

const struct pciide_product_desc pciide_intel_products[] =  {
	{ PCI_PRODUCT_INTEL_31244,	/* Intel 31244 SATA */
	  0,
	  artisea_chip_map
	},
	{ PCI_PRODUCT_INTEL_82092AA,	/* Intel 82092AA IDE */
	  0,
	  default_chip_map
	},
	{ PCI_PRODUCT_INTEL_82371FB_IDE, /* Intel 82371FB IDE (PIIX) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82371FB_ISA, /* Intel 82371FB IDE (PIIX) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82372FB_IDE, /* Intel 82372FB IDE (PIIX4) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82371SB_IDE, /* Intel 82371SB IDE (PIIX3) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82371AB_IDE, /* Intel 82371AB IDE (PIIX4) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82371MX, /* Intel 82371MX IDE */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82440MX_IDE, /* Intel 82440MX IDE */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82451NX, /* Intel 82451NX (PIIX4) IDE */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801AA_IDE, /* Intel 82801AA IDE (ICH) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801AB_IDE, /* Intel 82801AB IDE (ICH0) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801BAM_IDE, /* Intel 82801BAM IDE (ICH2) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801BA_IDE, /* Intel 82801BA IDE (ICH2) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801CAM_IDE, /* Intel 82801CAM IDE (ICH3) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801CA_IDE, /* Intel 82801CA IDE (ICH3) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801DB_IDE, /* Intel 82801DB IDE (ICH4) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801DBL_IDE, /* Intel 82801DBL IDE (ICH4-L) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801DBM_IDE, /* Intel 82801DBM IDE (ICH4-M) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801EB_IDE, /* Intel 82801EB/ER (ICH5/5R) IDE */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801EB_SATA, /* Intel 82801EB (ICH5) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801ER_SATA, /* Intel 82801ER (ICH5R) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_6300ESB_IDE, /* Intel 6300ESB IDE */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_6300ESB_SATA, /* Intel 6300ESB SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_6300ESB_SATA2, /* Intel 6300ESB SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_6321ESB_IDE, /* Intel 6321ESB IDE */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801FB_IDE,  /* Intel 82801FB (ICH6) IDE */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801FBM_SATA,  /* Intel 82801FBM (ICH6M) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801FB_SATA, /* Intel 82801FB (ICH6) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801FR_SATA, /* Intel 82801FR (ICH6R) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801GB_IDE,  /* Intel 82801GB (ICH7) IDE */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801GB_SATA, /* Intel 82801GB (ICH7) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801GR_AHCI, /* Intel 82801GR (ICH7R) AHCI */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801GR_RAID, /* Intel 82801GR (ICH7R) RAID */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801GBM_SATA, /* Intel 82801GBM (ICH7M) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801GBM_AHCI, /* Intel 82801GBM (ICH7M) AHCI */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801GHM_RAID, /* Intel 82801GHM (ICH7M DH) RAID */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801H_SATA_1, /* Intel 82801H (ICH8) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801H_AHCI_6P, /* Intel 82801H (ICH8) AHCI */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801H_RAID, /* Intel 82801H (ICH8) RAID */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801H_AHCI_4P, /* Intel 82801H (ICH8) AHCI */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801H_SATA_2, /* Intel 82801H (ICH8) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801HBM_SATA, /* Intel 82801HBM (ICH8M) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801HBM_AHCI, /* Intel 82801HBM (ICH8M) AHCI */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801HBM_RAID, /* Intel 82801HBM (ICH8M) RAID */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801HBM_IDE, /* Intel 82801HBM (ICH8M) IDE */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801I_SATA_1, /* Intel 82801I (ICH9) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801I_SATA_2, /* Intel 82801I (ICH9) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801I_SATA_3, /* Intel 82801I (ICH9) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801I_SATA_4, /* Intel 82801I (ICH9) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801I_SATA_5, /* Intel 82801I (ICH9M) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801I_SATA_6, /* Intel 82801I (ICH9M) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801JD_SATA_1, /* Intel 82801JD (ICH10) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801JD_SATA_2, /* Intel 82801JD (ICH10) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801JI_SATA_1, /* Intel 82801JI (ICH10) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801JI_SATA_2, /* Intel 82801JI (ICH10) SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_6321ESB_SATA, /* Intel 6321ESB SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_3400_SATA_1, /* Intel 3400 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_3400_SATA_2, /* Intel 3400 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_3400_SATA_3, /* Intel 3400 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_3400_SATA_4, /* Intel 3400 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_3400_SATA_5, /* Intel 3400 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_3400_SATA_6, /* Intel 3400 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_C600_SATA, /* Intel C600 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_C610_SATA_1, /* Intel C610 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_C610_SATA_2, /* Intel C610 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_C610_SATA_3, /* Intel C610 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_6SERIES_SATA_1, /* Intel 6 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_6SERIES_SATA_2, /* Intel 6 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_6SERIES_SATA_3, /* Intel 6 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_6SERIES_SATA_4, /* Intel 6 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_7SERIES_SATA_1, /* Intel 7 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_7SERIES_SATA_2, /* Intel 7 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_7SERIES_SATA_3, /* Intel 7 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_7SERIES_SATA_4, /* Intel 7 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_8SERIES_SATA_1, /* Intel 8 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_8SERIES_SATA_2, /* Intel 8 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_8SERIES_SATA_3, /* Intel 8 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_8SERIES_SATA_4, /* Intel 8 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_8SERIES_LP_SATA_1, /* Intel 8 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_8SERIES_LP_SATA_2, /* Intel 8 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_8SERIES_LP_SATA_3, /* Intel 8 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_8SERIES_LP_SATA_4, /* Intel 8 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_9SERIES_SATA_1, /* Intel 9 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_9SERIES_SATA_2, /* Intel 9 Series SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_ATOMC2000_SATA_1, /* Intel Atom C2000 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_ATOMC2000_SATA_2, /* Intel Atom C2000 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_ATOMC2000_SATA_3, /* Intel Atom C2000 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_ATOMC2000_SATA_4, /* Intel Atom C2000 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_BAYTRAIL_SATA_1, /* Intel Baytrail SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_BAYTRAIL_SATA_2, /* Intel Baytrail SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_EP80579_SATA, /* Intel EP80579 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_DH8900_SATA_1, /* Intel DH8900 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_DH8900_SATA_2, /* Intel DH8900 SATA */
	  0,
	  piixsata_chip_map
	},
	{ PCI_PRODUCT_INTEL_SCH_IDE, /* Intel SCH IDE */
	  0,
	  sch_chip_map
	}
};

const struct pciide_product_desc pciide_amd_products[] =  {
	{ PCI_PRODUCT_AMD_PBC756_IDE,	/* AMD 756 */
	  0,
	  amd756_chip_map
	},
	{ PCI_PRODUCT_AMD_766_IDE, /* AMD 766 */
	  0,
	  amd756_chip_map
	},
	{ PCI_PRODUCT_AMD_PBC768_IDE,
	  0,
	  amd756_chip_map
	},
	{ PCI_PRODUCT_AMD_8111_IDE,
	  0,
	  amd756_chip_map
	},
	{ PCI_PRODUCT_AMD_CS5536_IDE,
	  0,
	  amd756_chip_map
	},
	{ PCI_PRODUCT_AMD_HUDSON2_IDE,
	  0,
	  ixp_chip_map
	}
};

#ifdef notyet
const struct pciide_product_desc pciide_opti_products[] = {

	{ PCI_PRODUCT_OPTI_82C621,
	  0,
	  opti_chip_map
	},
	{ PCI_PRODUCT_OPTI_82C568,
	  0,
	  opti_chip_map
	},
	{ PCI_PRODUCT_OPTI_82D568,
	  0,
	  opti_chip_map
	}
};
#endif

const struct pciide_product_desc pciide_cmd_products[] =  {
	{ PCI_PRODUCT_CMDTECH_640,	/* CMD Technology PCI0640 */
	  0,
	  cmd_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_643,	/* CMD Technology PCI0643 */
	  0,
	  cmd0643_9_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_646,	/* CMD Technology PCI0646 */
	  0,
	  cmd0643_9_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_648,	/* CMD Technology PCI0648 */
	  0,
	  cmd0643_9_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_649,	/* CMD Technology PCI0649 */
	  0,
	  cmd0643_9_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_680,	/* CMD Technology PCI0680 */
	  IDE_PCI_CLASS_OVERRIDE,
	  cmd680_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_3112,	/* SiI3112 SATA */
	  0,
	  sii3112_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_3512,	/* SiI3512 SATA */
	  0,
	  sii3112_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_AAR_1210SA, /* Adaptec AAR-1210SA */
	  0,
	  sii3112_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_3114,	/* SiI3114 SATA */
	  0,
	  sii3114_chip_map
	}
};

const struct pciide_product_desc pciide_via_products[] =  {
	{ PCI_PRODUCT_VIATECH_VT82C416, /* VIA VT82C416 IDE */
	  0,
	  apollo_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VT82C571, /* VIA VT82C571 IDE */
	  0,
	  apollo_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VT6410, /* VIA VT6410 IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  apollo_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VT6415, /* VIA VT6415 IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  apollo_chip_map
	},
	{ PCI_PRODUCT_VIATECH_CX700_IDE, /* VIA CX700 IDE */
	  0,
	  apollo_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VX700_IDE, /* VIA VX700 IDE */
	  0,
	  apollo_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VX855_IDE, /* VIA VX855 IDE */
	  0,
	  apollo_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VX900_IDE, /* VIA VX900 IDE */
	  0,
	  apollo_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VT6420_SATA, /* VIA VT6420 SATA */
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VT6421_SATA, /* VIA VT6421 SATA */
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VT8237A_SATA, /* VIA VT8237A SATA */
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VT8237A_SATA_2, /* VIA VT8237A SATA */
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VT8237S_SATA, /* VIA VT8237S SATA */
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_VIATECH_VT8251_SATA, /* VIA VT8251 SATA */
	  0,
	  sata_chip_map
	}
};

const struct pciide_product_desc pciide_cypress_products[] =  {
	{ PCI_PRODUCT_CONTAQ_82C693,	/* Contaq CY82C693 IDE */
	  IDE_16BIT_IOSPACE,
	  cy693_chip_map
	}
};

const struct pciide_product_desc pciide_sis_products[] =  {
	{ PCI_PRODUCT_SIS_5513,		/* SIS 5513 EIDE */
	  0,
	  sis_chip_map
	},
	{ PCI_PRODUCT_SIS_180,		/* SIS 180 SATA */
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_SIS_181,		/* SIS 181 SATA */
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_SIS_182,		/* SIS 182 SATA */
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_SIS_1183,		/* SIS 1183 SATA */
	  0,
	  sata_chip_map
	}
};

/*
 * The National/AMD CS5535 requires MSRs to set DMA/PIO modes so it
 * has been banished to the MD i386 pciide_machdep
 */
const struct pciide_product_desc pciide_natsemi_products[] =  {
#ifdef __i386__
	{ PCI_PRODUCT_NS_CS5535_IDE,	/* National/AMD CS5535 IDE */
	  0,
	  gcsc_chip_map
	},
#endif
	{ PCI_PRODUCT_NS_PC87415,	/* National Semi PC87415 IDE */
	  0,
	  natsemi_chip_map
	},
	{ PCI_PRODUCT_NS_SCx200_IDE,	/* National Semi SCx200 IDE */
	  0,
	  ns_scx200_chip_map
	}
};

const struct pciide_product_desc pciide_acer_products[] =  {
	{ PCI_PRODUCT_ALI_M5229,	/* Acer Labs M5229 UDMA IDE */
	  0,
	  acer_chip_map
	}
};

const struct pciide_product_desc pciide_triones_products[] =  {
	{ PCI_PRODUCT_TRIONES_HPT366,	/* Highpoint HPT36x/37x IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map,
	},
	{ PCI_PRODUCT_TRIONES_HPT372A,	/* Highpoint HPT372A IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map
	},
	{ PCI_PRODUCT_TRIONES_HPT302,	/* Highpoint HPT302 IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map
	},
	{ PCI_PRODUCT_TRIONES_HPT371,	/* Highpoint HPT371 IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map
	},
	{ PCI_PRODUCT_TRIONES_HPT374,	/* Highpoint HPT374 IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map
	}
};

const struct pciide_product_desc pciide_promise_products[] =  {
	{ PCI_PRODUCT_PROMISE_PDC20246,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20262,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20265,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20267,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20268,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20268R,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20269,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20271,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20275,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20276,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20277,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20318,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20319,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20371,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20375,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20376,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20377,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20378,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20379,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC40518,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC40519,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC40718,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC40719,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC40779,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20571,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20575,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20579,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20771,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20775,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdcsata_chip_map,
	}
};

const struct pciide_product_desc pciide_acard_products[] =  {
	{ PCI_PRODUCT_ACARD_ATP850U,	/* Acard ATP850U Ultra33 Controller */
	  IDE_PCI_CLASS_OVERRIDE,
	  acard_chip_map,
	},
	{ PCI_PRODUCT_ACARD_ATP860,	/* Acard ATP860 Ultra66 Controller */
	  IDE_PCI_CLASS_OVERRIDE,
	  acard_chip_map,
	},
	{ PCI_PRODUCT_ACARD_ATP860A,	/* Acard ATP860-A Ultra66 Controller */
	  IDE_PCI_CLASS_OVERRIDE,
	  acard_chip_map,
	},
	{ PCI_PRODUCT_ACARD_ATP865A,	/* Acard ATP865-A Ultra133 Controller */
	  IDE_PCI_CLASS_OVERRIDE,
	  acard_chip_map,
	},
	{ PCI_PRODUCT_ACARD_ATP865R,	/* Acard ATP865-R Ultra133 Controller */
	  IDE_PCI_CLASS_OVERRIDE,
	  acard_chip_map,
	}
};

const struct pciide_product_desc pciide_serverworks_products[] =  {
	{ PCI_PRODUCT_RCC_OSB4_IDE,
	  0,
	  serverworks_chip_map,
	},
	{ PCI_PRODUCT_RCC_CSB5_IDE,
	  0,
	  serverworks_chip_map,
	},
	{ PCI_PRODUCT_RCC_CSB6_IDE,
	  0,
	  serverworks_chip_map,
	},
	{ PCI_PRODUCT_RCC_CSB6_RAID_IDE,
	  0,
	  serverworks_chip_map,
	},
	{ PCI_PRODUCT_RCC_HT_1000_IDE,
	  0,
	  serverworks_chip_map,
	},
	{ PCI_PRODUCT_RCC_K2_SATA,
	  0,
	  svwsata_chip_map,
	},
	{ PCI_PRODUCT_RCC_FRODO4_SATA,
	  0,
	  svwsata_chip_map,
	},
	{ PCI_PRODUCT_RCC_FRODO8_SATA,
	  0,
	  svwsata_chip_map,
	},
	{ PCI_PRODUCT_RCC_HT_1000_SATA_1,
	  0,
	  svwsata_chip_map,
	},
	{ PCI_PRODUCT_RCC_HT_1000_SATA_2,
	  0,
	  svwsata_chip_map,
	}
};

const struct pciide_product_desc pciide_nvidia_products[] = {
	{ PCI_PRODUCT_NVIDIA_NFORCE_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE2_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE2_400_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE3_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE3_250_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE4_ATA133,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP04_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP51_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP55_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP61_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP65_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP67_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP73_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP77_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE2_400_SATA,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE3_250_SATA,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE3_250_SATA2,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE4_SATA1,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE4_SATA2,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP04_SATA,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP04_SATA2,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP51_SATA,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP51_SATA2,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP55_SATA,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP55_SATA2,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP61_SATA,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP61_SATA2,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP61_SATA3,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP65_SATA_1,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP65_SATA_2,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP65_SATA_3,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP65_SATA_4,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP67_SATA_1,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP67_SATA_2,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP67_SATA_3,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP67_SATA_4,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP77_SATA_1,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP79_SATA_1,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP79_SATA_2,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP79_SATA_3,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP79_SATA_4,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP89_SATA_1,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP89_SATA_2,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP89_SATA_3,
	  0,
	  sata_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_MCP89_SATA_4,
	  0,
	  sata_chip_map
	}
};

const struct pciide_product_desc pciide_ite_products[] = {
	{ PCI_PRODUCT_ITEXPRESS_IT8211F,
	  IDE_PCI_CLASS_OVERRIDE,
	  ite_chip_map
	},
	{ PCI_PRODUCT_ITEXPRESS_IT8212F,
	  IDE_PCI_CLASS_OVERRIDE,
	  ite_chip_map
	}
};

const struct pciide_product_desc pciide_ati_products[] = {
	{ PCI_PRODUCT_ATI_SB200_IDE,
	  0,
	  ixp_chip_map
	},
	{ PCI_PRODUCT_ATI_SB300_IDE,
	  0,
	  ixp_chip_map
	},
	{ PCI_PRODUCT_ATI_SB400_IDE,
	  0,
	  ixp_chip_map
	},
	{ PCI_PRODUCT_ATI_SB600_IDE,
	  0,
	  ixp_chip_map
	},
	{ PCI_PRODUCT_ATI_SB700_IDE,
	  0,
	  ixp_chip_map
	},
	{ PCI_PRODUCT_ATI_SB300_SATA,
	  0,
	  sii3112_chip_map
	},
	{ PCI_PRODUCT_ATI_SB400_SATA_1,
	  0,
	  sii3112_chip_map
	},
	{ PCI_PRODUCT_ATI_SB400_SATA_2,
	  0,
	  sii3112_chip_map
	}
};

const struct pciide_product_desc pciide_jmicron_products[] = {
	{ PCI_PRODUCT_JMICRON_JMB361,
	  0,
	  jmicron_chip_map
	},
	{ PCI_PRODUCT_JMICRON_JMB363,
	  0,
	  jmicron_chip_map
	},
	{ PCI_PRODUCT_JMICRON_JMB365,
	  0,
	  jmicron_chip_map
	},
	{ PCI_PRODUCT_JMICRON_JMB366,
	  0,
	  jmicron_chip_map
	},
	{ PCI_PRODUCT_JMICRON_JMB368,
	  0,
	  jmicron_chip_map
	}
};

const struct pciide_product_desc pciide_phison_products[] = {
	{ PCI_PRODUCT_PHISON_PS5000,
	  0,
	  phison_chip_map
	},
};

const struct pciide_product_desc pciide_rdc_products[] = {
	{ PCI_PRODUCT_RDC_R1012_IDE,
	  0,
	  rdc_chip_map
	},
};

struct pciide_vendor_desc {
	u_int32_t ide_vendor;
	const struct pciide_product_desc *ide_products;
	int ide_nproducts;
};

const struct pciide_vendor_desc pciide_vendors[] = {
	{ PCI_VENDOR_INTEL, pciide_intel_products,
	  nitems(pciide_intel_products) },
	{ PCI_VENDOR_AMD, pciide_amd_products,
	  nitems(pciide_amd_products) },
#ifdef notyet
	{ PCI_VENDOR_OPTI, pciide_opti_products,
	  nitems(pciide_opti_products) },
#endif
	{ PCI_VENDOR_CMDTECH, pciide_cmd_products,
	  nitems(pciide_cmd_products) },
	{ PCI_VENDOR_VIATECH, pciide_via_products,
	  nitems(pciide_via_products) },
	{ PCI_VENDOR_CONTAQ, pciide_cypress_products,
	  nitems(pciide_cypress_products) },
	{ PCI_VENDOR_SIS, pciide_sis_products,
	  nitems(pciide_sis_products) },
	{ PCI_VENDOR_NS, pciide_natsemi_products,
	  nitems(pciide_natsemi_products) },
	{ PCI_VENDOR_ALI, pciide_acer_products,
	  nitems(pciide_acer_products) },
	{ PCI_VENDOR_TRIONES, pciide_triones_products,
	  nitems(pciide_triones_products) },
	{ PCI_VENDOR_ACARD, pciide_acard_products,
	  nitems(pciide_acard_products) },
	{ PCI_VENDOR_RCC, pciide_serverworks_products,
	  nitems(pciide_serverworks_products) },
	{ PCI_VENDOR_PROMISE, pciide_promise_products,
	  nitems(pciide_promise_products) },
	{ PCI_VENDOR_NVIDIA, pciide_nvidia_products,
	  nitems(pciide_nvidia_products) },
	{ PCI_VENDOR_ITEXPRESS, pciide_ite_products,
	  nitems(pciide_ite_products) },
	{ PCI_VENDOR_ATI, pciide_ati_products,
	  nitems(pciide_ati_products) },
	{ PCI_VENDOR_JMICRON, pciide_jmicron_products,
	  nitems(pciide_jmicron_products) },
	{ PCI_VENDOR_PHISON, pciide_phison_products,
	  nitems(pciide_phison_products) },
	{ PCI_VENDOR_RDC, pciide_rdc_products,
	  nitems(pciide_rdc_products) }
};

/* options passed via the 'flags' config keyword */
#define PCIIDE_OPTIONS_DMA	0x01

int	pciide_match(struct device *, void *, void *);
void	pciide_attach(struct device *, struct device *, void *);
int	pciide_detach(struct device *, int);
int	pciide_activate(struct device *, int);

struct cfattach pciide_pci_ca = {
	sizeof(struct pciide_softc), pciide_match, pciide_attach,
	pciide_detach, pciide_activate
};

struct cfattach pciide_jmb_ca = {
	sizeof(struct pciide_softc), pciide_match, pciide_attach,
	pciide_detach, pciide_activate
};

struct cfdriver pciide_cd = {
	NULL, "pciide", DV_DULL
};

const struct pciide_product_desc *pciide_lookup_product(u_int32_t);

const struct pciide_product_desc *
pciide_lookup_product(u_int32_t id)
{
	const struct pciide_product_desc *pp;
	const struct pciide_vendor_desc *vp;
	int i;

	for (i = 0, vp = pciide_vendors; i < nitems(pciide_vendors); vp++, i++)
		if (PCI_VENDOR(id) == vp->ide_vendor)
			break;

	if (i == nitems(pciide_vendors))
		return (NULL);

	for (pp = vp->ide_products, i = 0; i < vp->ide_nproducts; pp++, i++)
		if (PCI_PRODUCT(id) == pp->ide_product)
			break;

	if (i == vp->ide_nproducts)
		return (NULL);
	return (pp);
}

int
pciide_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;
	const struct pciide_product_desc *pp;

	/*
 	 * Some IDE controllers have severe bugs when used in PCI mode.
	 * We punt and attach them to the ISA bus instead.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_PCTECH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_PCTECH_RZ1000)
		return (0);

	/*
 	 * Some controllers (e.g. promise Ultra-33) don't claim to be PCI IDE
	 * controllers. Let see if we can deal with it anyway.
	 */
	pp = pciide_lookup_product(pa->pa_id);
	if (pp  && (pp->ide_flags & IDE_PCI_CLASS_OVERRIDE))
		return (1);

	/*
	 * Check the ID register to see that it's a PCI IDE controller.
	 * If it is, we assume that we can deal with it; it _should_
	 * work in a standardized way...
	 */
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_MASS_STORAGE) {
		switch (PCI_SUBCLASS(pa->pa_class)) {
		case PCI_SUBCLASS_MASS_STORAGE_IDE:
			return (1);

		/*
		 * We only match these if we know they have
		 * a match, as we may not support native interfaces
		 * on them.
		 */
		case PCI_SUBCLASS_MASS_STORAGE_SATA:
		case PCI_SUBCLASS_MASS_STORAGE_RAID:
		case PCI_SUBCLASS_MASS_STORAGE_MISC:
			if (pp)
				return (1);
			else
				return (0);
			break;
		}
	}

	return (0);
}

void
pciide_attach(struct device *parent, struct device *self, void *aux)
{
	struct pciide_softc *sc = (struct pciide_softc *)self;
	struct pci_attach_args *pa = aux;

	sc->sc_pp = pciide_lookup_product(pa->pa_id);
	if (sc->sc_pp == NULL)
		sc->sc_pp = &default_product_desc;
	sc->sc_rev = PCI_REVISION(pa->pa_class);

	sc->sc_pc = pa->pa_pc;
	sc->sc_tag = pa->pa_tag;

	/* Set up DMA defaults; these might be adjusted by chip_map. */
	sc->sc_dma_maxsegsz = IDEDMA_BYTE_COUNT_MAX;
	sc->sc_dma_boundary = IDEDMA_BYTE_COUNT_ALIGN;

	sc->sc_dmacmd_read = pciide_dmacmd_read;
	sc->sc_dmacmd_write = pciide_dmacmd_write;
	sc->sc_dmactl_read = pciide_dmactl_read;
	sc->sc_dmactl_write = pciide_dmactl_write;
	sc->sc_dmatbl_write = pciide_dmatbl_write;

	WDCDEBUG_PRINT((" sc_pc=%p, sc_tag=%p, pa_class=0x%x\n", sc->sc_pc,
	    sc->sc_tag, pa->pa_class), DEBUG_PROBE);

	if (pciide_skip_ata)
		sc->sc_wdcdev.quirks |= WDC_QUIRK_NOATA;
	if (pciide_skip_atapi)
		sc->sc_wdcdev.quirks |= WDC_QUIRK_NOATAPI;

	sc->sc_pp->chip_map(sc, pa);

	WDCDEBUG_PRINT(("pciide: command/status register=0x%x\n",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG)),
	    DEBUG_PROBE);
}

int
pciide_detach(struct device *self, int flags)
{
	struct pciide_softc *sc = (struct pciide_softc *)self;
	if (sc->chip_unmap == NULL)
		panic("unmap not yet implemented for this chipset");
	else
		sc->chip_unmap(sc, flags);

	return 0;
}

int
pciide_activate(struct device *self, int act)
{
	int rv = 0;
	struct pciide_softc *sc = (struct pciide_softc *)self;
	int i;

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);

		for (i = 0; i < nitems(sc->sc_save); i++)
			sc->sc_save[i] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, PCI_MAPREG_END + 0x18 + (i * 4));

		if (sc->sc_pp->chip_map == sch_chip_map) {
			sc->sc_save2[0] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, SCH_D0TIM);
			sc->sc_save2[1] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, SCH_D1TIM);
		} else if (sc->sc_pp->chip_map == piixsata_chip_map) {
			sc->sc_save2[0] = pciide_pci_read(sc->sc_pc,
			    sc->sc_tag, ICH5_SATA_MAP);
			sc->sc_save2[1] = pciide_pci_read(sc->sc_pc,
			    sc->sc_tag, ICH5_SATA_PI);
			sc->sc_save2[2] = pciide_pci_read(sc->sc_pc,
			    sc->sc_tag, ICH_SATA_PCS);
		} else if (sc->sc_pp->chip_map == sii3112_chip_map) {
			sc->sc_save2[0] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, SII3112_SCS_CMD);
			sc->sc_save2[1] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, SII3112_PCI_CFGCTL);
		} else if (sc->sc_pp->chip_map == ite_chip_map) {
			sc->sc_save2[0] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, IT_TIM(0));
		} else if (sc->sc_pp->chip_map == nforce_chip_map) {
			sc->sc_save2[0] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, NFORCE_PIODMATIM);
			sc->sc_save2[1] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, NFORCE_PIOTIM);
			sc->sc_save2[2] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, NFORCE_UDMATIM);
		}
		break;
	case DVACT_RESUME:
		for (i = 0; i < nitems(sc->sc_save); i++)
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PCI_MAPREG_END + 0x18 + (i * 4),
			    sc->sc_save[i]);

		if (sc->sc_pp->chip_map == default_chip_map ||
		    sc->sc_pp->chip_map == sata_chip_map ||
		    sc->sc_pp->chip_map == piix_chip_map ||
		    sc->sc_pp->chip_map == amd756_chip_map ||
		    sc->sc_pp->chip_map == phison_chip_map ||
		    sc->sc_pp->chip_map == rdc_chip_map ||
		    sc->sc_pp->chip_map == ixp_chip_map ||
		    sc->sc_pp->chip_map == acard_chip_map ||
		    sc->sc_pp->chip_map == apollo_chip_map ||
		    sc->sc_pp->chip_map == sis_chip_map) {
			/* nothing to restore -- uses only 0x40 - 0x56 */
		} else if (sc->sc_pp->chip_map == sch_chip_map) {
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    SCH_D0TIM, sc->sc_save2[0]);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    SCH_D1TIM, sc->sc_save2[1]);
		} else if (sc->sc_pp->chip_map == piixsata_chip_map) {
			pciide_pci_write(sc->sc_pc, sc->sc_tag,
			    ICH5_SATA_MAP, sc->sc_save2[0]);
			pciide_pci_write(sc->sc_pc, sc->sc_tag,
			    ICH5_SATA_PI, sc->sc_save2[1]);
			pciide_pci_write(sc->sc_pc, sc->sc_tag,
			    ICH_SATA_PCS, sc->sc_save2[2]);
		} else if (sc->sc_pp->chip_map == sii3112_chip_map) {
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    SII3112_SCS_CMD, sc->sc_save2[0]);
			delay(50 * 1000);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    SII3112_PCI_CFGCTL, sc->sc_save2[1]);
			delay(50 * 1000);
		} else if (sc->sc_pp->chip_map == ite_chip_map) {
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    IT_TIM(0), sc->sc_save2[0]);
		} else if (sc->sc_pp->chip_map == nforce_chip_map) {
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    NFORCE_PIODMATIM, sc->sc_save2[0]);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    NFORCE_PIOTIM, sc->sc_save2[1]);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    NFORCE_UDMATIM, sc->sc_save2[2]);
		} else {
			printf("%s: restore for unknown chip map %x\n",
			    sc->sc_wdcdev.sc_dev.dv_xname,
			    sc->sc_pp->ide_product);
		}

		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
pciide_mapregs_compat(struct pci_attach_args *pa, struct pciide_channel *cp,
    int compatchan, bus_size_t *cmdsizep, bus_size_t *ctlsizep)
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	pcireg_t csr;

	cp->compat = 1;
	*cmdsizep = PCIIDE_COMPAT_CMD_SIZE;
	*ctlsizep = PCIIDE_COMPAT_CTL_SIZE;

	csr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG,
	    csr | PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MASTER_ENABLE);
	
	wdc_cp->cmd_iot = pa->pa_iot;

	if (bus_space_map(wdc_cp->cmd_iot, PCIIDE_COMPAT_CMD_BASE(compatchan),
	    PCIIDE_COMPAT_CMD_SIZE, 0, &wdc_cp->cmd_ioh) != 0) {
		printf("%s: couldn't map %s cmd regs\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return (0);
	}

	wdc_cp->ctl_iot = pa->pa_iot;

	if (bus_space_map(wdc_cp->ctl_iot, PCIIDE_COMPAT_CTL_BASE(compatchan),
	    PCIIDE_COMPAT_CTL_SIZE, 0, &wdc_cp->ctl_ioh) != 0) {
		printf("%s: couldn't map %s ctl regs\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		bus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh,
		    PCIIDE_COMPAT_CMD_SIZE);
		return (0);
	}
	wdc_cp->cmd_iosz = *cmdsizep;
	wdc_cp->ctl_iosz = *ctlsizep;

	return (1);
}

int
pciide_unmapregs_compat(struct pciide_softc *sc, struct pciide_channel *cp)
{
	struct channel_softc *wdc_cp = &cp->wdc_channel;

	bus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, wdc_cp->cmd_iosz);
	bus_space_unmap(wdc_cp->ctl_iot, wdc_cp->cmd_ioh, wdc_cp->ctl_iosz);

	if (sc->sc_pci_ih != NULL) {
		pciide_machdep_compat_intr_disestablish(sc->sc_pc, sc->sc_pci_ih);
		sc->sc_pci_ih = NULL;
	}

	return (0);
}

int
pciide_mapregs_native(struct pci_attach_args *pa, struct pciide_channel *cp,
    bus_size_t *cmdsizep, bus_size_t *ctlsizep, int (*pci_intr)(void *))
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	const char *intrstr;
	pci_intr_handle_t intrhandle;
	pcireg_t maptype;

	cp->compat = 0;

	if (sc->sc_pci_ih == NULL) {
		if (pci_intr_map(pa, &intrhandle) != 0) {
			printf("%s: couldn't map native-PCI interrupt\n",
			    sc->sc_wdcdev.sc_dev.dv_xname);
			return (0);
		}
		intrstr = pci_intr_string(pa->pa_pc, intrhandle);
		sc->sc_pci_ih = pci_intr_establish(pa->pa_pc,
		    intrhandle, IPL_BIO, pci_intr, sc,
		    sc->sc_wdcdev.sc_dev.dv_xname);
		if (sc->sc_pci_ih != NULL) {
			printf("%s: using %s for native-PCI interrupt\n",
			    sc->sc_wdcdev.sc_dev.dv_xname,
			    intrstr ? intrstr : "unknown interrupt");
		} else {
			printf("%s: couldn't establish native-PCI interrupt",
			    sc->sc_wdcdev.sc_dev.dv_xname);
			if (intrstr != NULL)
				printf(" at %s", intrstr);
			printf("\n");
			return (0);
		}
	}
	cp->ih = sc->sc_pci_ih;
	sc->sc_pc = pa->pa_pc;

	maptype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
	    PCIIDE_REG_CMD_BASE(wdc_cp->channel));
	WDCDEBUG_PRINT(("%s: %s cmd regs mapping: %s\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
	    (maptype == PCI_MAPREG_TYPE_IO ? "I/O" : "memory")), DEBUG_PROBE);
	if (pci_mapreg_map(pa, PCIIDE_REG_CMD_BASE(wdc_cp->channel),
	    maptype, 0,
	    &wdc_cp->cmd_iot, &wdc_cp->cmd_ioh, NULL, cmdsizep, 0) != 0) {
		printf("%s: couldn't map %s cmd regs\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return (0);
	}

	maptype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
	    PCIIDE_REG_CTL_BASE(wdc_cp->channel));
	WDCDEBUG_PRINT(("%s: %s ctl regs mapping: %s\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
	    (maptype == PCI_MAPREG_TYPE_IO ? "I/O": "memory")), DEBUG_PROBE);
	if (pci_mapreg_map(pa, PCIIDE_REG_CTL_BASE(wdc_cp->channel),
	    maptype, 0,
	    &wdc_cp->ctl_iot, &cp->ctl_baseioh, NULL, ctlsizep, 0) != 0) {
		printf("%s: couldn't map %s ctl regs\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		bus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, *cmdsizep);
		return (0);
	}
	/*
	 * In native mode, 4 bytes of I/O space are mapped for the control
	 * register, the control register is at offset 2. Pass the generic
	 * code a handle for only one byte at the right offset.
	 */
	if (bus_space_subregion(wdc_cp->ctl_iot, cp->ctl_baseioh, 2, 1,
	    &wdc_cp->ctl_ioh) != 0) {
		printf("%s: unable to subregion %s ctl regs\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		bus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, *cmdsizep);
		bus_space_unmap(wdc_cp->cmd_iot, cp->ctl_baseioh, *ctlsizep);
		return (0);
	}
	wdc_cp->cmd_iosz = *cmdsizep;
	wdc_cp->ctl_iosz = *ctlsizep;

	return (1);
}

int
pciide_unmapregs_native(struct pciide_softc *sc, struct pciide_channel *cp)
{
	struct channel_softc *wdc_cp = &cp->wdc_channel;

	bus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, wdc_cp->cmd_iosz);

	/* Unmap the whole control space, not just the sub-region */
	bus_space_unmap(wdc_cp->ctl_iot, cp->ctl_baseioh, wdc_cp->ctl_iosz);

	if (sc->sc_pci_ih != NULL) {
		pci_intr_disestablish(sc->sc_pc, sc->sc_pci_ih);
		sc->sc_pci_ih = NULL;
	}

	return (0);
}

void
pciide_mapreg_dma(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	pcireg_t maptype;
	bus_addr_t addr;

	/*
	 * Map DMA registers
	 *
	 * Note that sc_dma_ok is the right variable to test to see if
	 * DMA can be done.  If the interface doesn't support DMA,
	 * sc_dma_ok will never be non-zero.  If the DMA regs couldn't
	 * be mapped, it'll be zero.  I.e., sc_dma_ok will only be
	 * non-zero if the interface supports DMA and the registers
	 * could be mapped.
	 *
	 * XXX Note that despite the fact that the Bus Master IDE specs
	 * XXX say that "The bus master IDE function uses 16 bytes of IO
	 * XXX space", some controllers (at least the United
	 * XXX Microelectronics UM8886BF) place it in memory space.
	 */

	maptype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
	    PCIIDE_REG_BUS_MASTER_DMA);

	switch (maptype) {
	case PCI_MAPREG_TYPE_IO:
		sc->sc_dma_ok = (pci_mapreg_info(pa->pa_pc, pa->pa_tag,
		    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO,
		    &addr, NULL, NULL) == 0);
		if (sc->sc_dma_ok == 0) {
			printf(", unused (couldn't query registers)");
			break;
		}
		if ((sc->sc_pp->ide_flags & IDE_16BIT_IOSPACE)
		    && addr >= 0x10000) {
			sc->sc_dma_ok = 0;
			printf(", unused (registers at unsafe address %#lx)", addr);
			break;
		}
		/* FALLTHROUGH */

	case PCI_MAPREG_MEM_TYPE_32BIT:
		sc->sc_dma_ok = (pci_mapreg_map(pa,
		    PCIIDE_REG_BUS_MASTER_DMA, maptype, 0,
		    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, &sc->sc_dma_iosz,
		    0) == 0);
		sc->sc_dmat = pa->pa_dmat;
		if (sc->sc_dma_ok == 0) {
			printf(", unused (couldn't map registers)");
		} else {
			sc->sc_wdcdev.dma_arg = sc;
			sc->sc_wdcdev.dma_init = pciide_dma_init;
			sc->sc_wdcdev.dma_start = pciide_dma_start;
			sc->sc_wdcdev.dma_finish = pciide_dma_finish;
		}
		break;

	default:
		sc->sc_dma_ok = 0;
		printf(", (unsupported maptype 0x%x)", maptype);
		break;
	}
}

void
pciide_unmapreg_dma(struct pciide_softc *sc)
{
	bus_space_unmap(sc->sc_dma_iot, sc->sc_dma_ioh, sc->sc_dma_iosz);
}

int
pciide_intr_flag(struct pciide_channel *cp)
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int chan = cp->wdc_channel.channel;

	if (cp->dma_in_progress) {
		int retry = 10;
		int status;

		/* Check the status register */
		for (retry = 10; retry > 0; retry--) {
			status = PCIIDE_DMACTL_READ(sc, chan);
			if (status & IDEDMA_CTL_INTR) {
				break;
			}
			DELAY(5);
		}

		/* Not for us.  */
		if (retry == 0)
			return (0);

		return (1);
	}

	return (-1);
}

int
pciide_compat_intr(void *arg)
{
	struct pciide_channel *cp = arg;

	if (pciide_intr_flag(cp) == 0)
		return (0);

#ifdef DIAGNOSTIC
	/* should only be called for a compat channel */
	if (cp->compat == 0)
		panic("pciide compat intr called for non-compat chan %p", cp);
#endif
	return (wdcintr(&cp->wdc_channel));
}

int
pciide_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv;

	rv = 0;
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;

		/* If a compat channel skip. */
		if (cp->compat)
			continue;

		if (cp->hw_ok == 0)
			continue;

		if (pciide_intr_flag(cp) == 0)
			continue;

		crv = wdcintr(wdc_cp);
		if (crv == 0)
			;		/* leave rv alone */
		else if (crv == 1)
			rv = 1;		/* claim the intr */
		else if (rv == 0)	/* crv should be -1 in this case */
			rv = crv;	/* if we've done no better, take it */
	}
	return (rv);
}

u_int8_t
pciide_dmacmd_read(struct pciide_softc *sc, int chan)
{
	return (bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(chan)));
}

void
pciide_dmacmd_write(struct pciide_softc *sc, int chan, u_int8_t val)
{
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(chan), val);
}

u_int8_t
pciide_dmactl_read(struct pciide_softc *sc, int chan)
{
	return (bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(chan)));
}

void
pciide_dmactl_write(struct pciide_softc *sc, int chan, u_int8_t val)
{
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(chan), val);
}

void
pciide_dmatbl_write(struct pciide_softc *sc, int chan, u_int32_t val)
{
	bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_TBL(chan), val);
}

void
pciide_channel_dma_setup(struct pciide_channel *cp)
{
	int drive;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct ata_drive_datas *drvp;

	for (drive = 0; drive < 2; drive++) {
		drvp = &cp->wdc_channel.ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* setup DMA if needed */
		if (((drvp->drive_flags & DRIVE_DMA) == 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) == 0) ||
		    sc->sc_dma_ok == 0) {
			drvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);
			continue;
		}
		if (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)
		    != 0) {
			/* Abort DMA setup */
			drvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);
			continue;
		}
	}
}

int
pciide_dma_table_setup(struct pciide_softc *sc, int channel, int drive)
{
	bus_dma_segment_t seg;
	int error, rseg;
	const bus_size_t dma_table_size =
	    sizeof(struct idedma_table) * NIDEDMA_TABLES;
	struct pciide_dma_maps *dma_maps =
	    &sc->pciide_channels[channel].dma_maps[drive];

	/* If table was already allocated, just return */
	if (dma_maps->dma_table)
		return (0);

	/* Allocate memory for the DMA tables and map it */
	if ((error = bus_dmamem_alloc(sc->sc_dmat, dma_table_size,
	    IDEDMA_TBL_ALIGN, IDEDMA_TBL_ALIGN, &seg, 1, &rseg,
	    BUS_DMA_NOWAIT)) != 0) {
		printf("%s:%d: unable to allocate table DMA for "
		    "drive %d, error=%d\n", sc->sc_wdcdev.sc_dev.dv_xname,
		    channel, drive, error);
		return (error);
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,
	    dma_table_size,
	    (caddr_t *)&dma_maps->dma_table,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s:%d: unable to map table DMA for"
		    "drive %d, error=%d\n", sc->sc_wdcdev.sc_dev.dv_xname,
		    channel, drive, error);
		return (error);
	}

	WDCDEBUG_PRINT(("pciide_dma_table_setup: table at %p len %ld, "
	    "phy 0x%lx\n", dma_maps->dma_table, dma_table_size,
	    seg.ds_addr), DEBUG_PROBE);

	/* Create and load table DMA map for this disk */
	if ((error = bus_dmamap_create(sc->sc_dmat, dma_table_size,
	    1, dma_table_size, IDEDMA_TBL_ALIGN, BUS_DMA_NOWAIT,
	    &dma_maps->dmamap_table)) != 0) {
		printf("%s:%d: unable to create table DMA map for "
		    "drive %d, error=%d\n", sc->sc_wdcdev.sc_dev.dv_xname,
		    channel, drive, error);
		return (error);
	}
	if ((error = bus_dmamap_load(sc->sc_dmat,
	    dma_maps->dmamap_table,
	    dma_maps->dma_table,
	    dma_table_size, NULL, BUS_DMA_NOWAIT)) != 0) {
		printf("%s:%d: unable to load table DMA map for "
		    "drive %d, error=%d\n", sc->sc_wdcdev.sc_dev.dv_xname,
		    channel, drive, error);
		return (error);
	}
	WDCDEBUG_PRINT(("pciide_dma_table_setup: phy addr of table 0x%lx\n",
	    dma_maps->dmamap_table->dm_segs[0].ds_addr), DEBUG_PROBE);
	/* Create a xfer DMA map for this drive */
	if ((error = bus_dmamap_create(sc->sc_dmat, IDEDMA_BYTE_COUNT_MAX,
	    NIDEDMA_TABLES, sc->sc_dma_maxsegsz, sc->sc_dma_boundary,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
	    &dma_maps->dmamap_xfer)) != 0) {
		printf("%s:%d: unable to create xfer DMA map for "
		    "drive %d, error=%d\n", sc->sc_wdcdev.sc_dev.dv_xname,
		    channel, drive, error);
		return (error);
	}
	return (0);
}

int
pciide_dma_init(void *v, int channel, int drive, void *databuf,
    size_t datalen, int flags)
{
	struct pciide_softc *sc = v;
	int error, seg;
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	struct pciide_dma_maps *dma_maps =
	    &sc->pciide_channels[channel].dma_maps[drive];
#ifndef BUS_DMA_RAW
#define BUS_DMA_RAW 0
#endif

	error = bus_dmamap_load(sc->sc_dmat,
	    dma_maps->dmamap_xfer,
	    databuf, datalen, NULL, BUS_DMA_NOWAIT|BUS_DMA_RAW);
	if (error) {
		printf("%s:%d: unable to load xfer DMA map for "
		    "drive %d, error=%d\n", sc->sc_wdcdev.sc_dev.dv_xname,
		    channel, drive, error);
		return (error);
	}

	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, 0,
	    dma_maps->dmamap_xfer->dm_mapsize,
	    (flags & WDC_DMA_READ) ?
	    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);

	for (seg = 0; seg < dma_maps->dmamap_xfer->dm_nsegs; seg++) {
#ifdef DIAGNOSTIC
		/* A segment must not cross a 64k boundary */
		{
		u_long phys = dma_maps->dmamap_xfer->dm_segs[seg].ds_addr;
		u_long len = dma_maps->dmamap_xfer->dm_segs[seg].ds_len;
		if ((phys & ~IDEDMA_BYTE_COUNT_MASK) !=
		    ((phys + len - 1) & ~IDEDMA_BYTE_COUNT_MASK)) {
			printf("pciide_dma: segment %d physical addr 0x%lx"
			    " len 0x%lx not properly aligned\n",
			    seg, phys, len);
			panic("pciide_dma: buf align");
		}
		}
#endif
		dma_maps->dma_table[seg].base_addr =
		    htole32(dma_maps->dmamap_xfer->dm_segs[seg].ds_addr);
		dma_maps->dma_table[seg].byte_count =
		    htole32(dma_maps->dmamap_xfer->dm_segs[seg].ds_len &
		    IDEDMA_BYTE_COUNT_MASK);
		WDCDEBUG_PRINT(("\t seg %d len %d addr 0x%x\n",
		   seg, letoh32(dma_maps->dma_table[seg].byte_count),
		   letoh32(dma_maps->dma_table[seg].base_addr)), DEBUG_DMA);

	}
	dma_maps->dma_table[dma_maps->dmamap_xfer->dm_nsegs -1].byte_count |=
	    htole32(IDEDMA_BYTE_COUNT_EOT);

	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_table, 0,
	    dma_maps->dmamap_table->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	/* Maps are ready. Start DMA function */
#ifdef DIAGNOSTIC
	if (dma_maps->dmamap_table->dm_segs[0].ds_addr & ~IDEDMA_TBL_MASK) {
		printf("pciide_dma_init: addr 0x%lx not properly aligned\n",
		    dma_maps->dmamap_table->dm_segs[0].ds_addr);
		panic("pciide_dma_init: table align");
	}
#endif

	/* Clear status bits */
	PCIIDE_DMACTL_WRITE(sc, channel, PCIIDE_DMACTL_READ(sc, channel));
	/* Write table addr */
	PCIIDE_DMATBL_WRITE(sc, channel,
	    dma_maps->dmamap_table->dm_segs[0].ds_addr);
	/* set read/write */
	PCIIDE_DMACMD_WRITE(sc, channel,
	    ((flags & WDC_DMA_READ) ? IDEDMA_CMD_WRITE : 0) | cp->idedma_cmd);
	/* remember flags */
	dma_maps->dma_flags = flags;
	return (0);
}

void
pciide_dma_start(void *v, int channel, int drive)
{
	struct pciide_softc *sc = v;

	WDCDEBUG_PRINT(("pciide_dma_start\n"), DEBUG_XFERS);
	PCIIDE_DMACMD_WRITE(sc, channel, PCIIDE_DMACMD_READ(sc, channel) |
	    IDEDMA_CMD_START);

	sc->pciide_channels[channel].dma_in_progress = 1;
}

int
pciide_dma_finish(void *v, int channel, int drive, int force)
{
	struct pciide_softc *sc = v;
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	u_int8_t status;
	int error = 0;
	struct pciide_dma_maps *dma_maps =
	    &sc->pciide_channels[channel].dma_maps[drive];

	status = PCIIDE_DMACTL_READ(sc, channel);
	WDCDEBUG_PRINT(("pciide_dma_finish: status 0x%x\n", status),
	    DEBUG_XFERS);
	if (status == 0xff)
		return (status);

	if (force == 0 && (status & IDEDMA_CTL_INTR) == 0) {
		error = WDC_DMAST_NOIRQ;
		goto done;
	}

	/* stop DMA channel */
	PCIIDE_DMACMD_WRITE(sc, channel,
	    ((dma_maps->dma_flags & WDC_DMA_READ) ?
	    0x00 : IDEDMA_CMD_WRITE) | cp->idedma_cmd);

	/* Unload the map of the data buffer */
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, 0,
	    dma_maps->dmamap_xfer->dm_mapsize,
	    (dma_maps->dma_flags & WDC_DMA_READ) ?
	    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, dma_maps->dmamap_xfer);

	/* Clear status bits */
	PCIIDE_DMACTL_WRITE(sc, channel, status);

	if ((status & IDEDMA_CTL_ERR) != 0) {
		printf("%s:%d:%d: bus-master DMA error: status=0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, channel, drive, status);
		error |= WDC_DMAST_ERR;
	}

	if ((status & IDEDMA_CTL_INTR) == 0) {
		printf("%s:%d:%d: bus-master DMA error: missing interrupt, "
		    "status=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname, channel,
		    drive, status);
		error |= WDC_DMAST_NOIRQ;
	}

	if ((status & IDEDMA_CTL_ACT) != 0) {
		/* data underrun, may be a valid condition for ATAPI */
		error |= WDC_DMAST_UNDER;
	}

done:
	sc->pciide_channels[channel].dma_in_progress = 0;
	return (error);
}

void
pciide_irqack(struct channel_softc *chp)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int chan = chp->channel;

	/* clear status bits in IDE DMA registers */
	PCIIDE_DMACTL_WRITE(sc, chan, PCIIDE_DMACTL_READ(sc, chan));
}

/* some common code used by several chip_map */
int
pciide_chansetup(struct pciide_softc *sc, int channel, pcireg_t interface)
{
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	sc->wdc_chanarray[channel] = &cp->wdc_channel;
	cp->name = PCIIDE_CHANNEL_NAME(channel);
	cp->wdc_channel.channel = channel;
	cp->wdc_channel.wdc = &sc->sc_wdcdev;
	cp->wdc_channel.ch_queue = wdc_alloc_queue();
	if (cp->wdc_channel.ch_queue == NULL) {
		printf("%s: %s "
		    "cannot allocate channel queue",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return (0);
	}
	cp->hw_ok = 1;

	return (1);
}

void
pciide_chanfree(struct pciide_softc *sc, int channel)
{
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	if (cp->wdc_channel.ch_queue)
		wdc_free_queue(cp->wdc_channel.ch_queue);
}

/* some common code used by several chip channel_map */
void
pciide_mapchan(struct pci_attach_args *pa, struct pciide_channel *cp,
    pcireg_t interface, bus_size_t *cmdsizep, bus_size_t *ctlsizep,
    int (*pci_intr)(void *))
{
	struct channel_softc *wdc_cp = &cp->wdc_channel;

	if (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))
		cp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,
		    pci_intr);
	else
		cp->hw_ok = pciide_mapregs_compat(pa, cp,
		    wdc_cp->channel, cmdsizep, ctlsizep);
	if (cp->hw_ok == 0)
		return;
	wdc_cp->data32iot = wdc_cp->cmd_iot;
	wdc_cp->data32ioh = wdc_cp->cmd_ioh;
	wdcattach(wdc_cp);
}

void
pciide_unmap_chan(struct pciide_softc *sc, struct pciide_channel *cp, int flags)
{
	struct channel_softc *wdc_cp = &cp->wdc_channel;

	wdcdetach(wdc_cp, flags);

	if (cp->compat != 0)
		pciide_unmapregs_compat(sc, cp);
	else
		pciide_unmapregs_native(sc, cp);
}

/*
 * Generic code to call to know if a channel can be disabled. Return 1
 * if channel can be disabled, 0 if not
 */
int
pciide_chan_candisable(struct pciide_channel *cp)
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct channel_softc *wdc_cp = &cp->wdc_channel;

	if ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&
	    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {
		printf("%s: %s disabled (no drives)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		cp->hw_ok = 0;
		return (1);
	}
	return (0);
}

/*
 * generic code to map the compat intr if hw_ok=1 and it is a compat channel.
 * Set hw_ok=0 on failure
 */
void
pciide_map_compat_intr(struct pci_attach_args *pa, struct pciide_channel *cp,
    int compatchan, int interface)
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct channel_softc *wdc_cp = &cp->wdc_channel;

	if ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)
		return;

	cp->compat = 1;
	cp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,
	    pa, compatchan, pciide_compat_intr, cp);
	if (cp->ih == NULL) {
		printf("%s: no compatibility interrupt for use by %s\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		cp->hw_ok = 0;
	}
}

/*
 * generic code to unmap the compat intr if hw_ok=1 and it is a compat channel.
 * Set hw_ok=0 on failure
 */
void
pciide_unmap_compat_intr(struct pci_attach_args *pa, struct pciide_channel *cp,
    int compatchan, int interface)
{
	struct channel_softc *wdc_cp = &cp->wdc_channel;

	if ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)
		return;

	pciide_machdep_compat_intr_disestablish(pa->pa_pc, cp->ih);
}

void
pciide_print_channels(int nchannels, pcireg_t interface)
{
	int i;

	for (i = 0; i < nchannels; i++) {
		printf(", %s %s to %s", PCIIDE_CHANNEL_NAME(i),
		    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?
		    "configured" : "wired",
		    (interface & PCIIDE_INTERFACE_PCI(i)) ? "native-PCI" :
		    "compatibility");
	}

	printf("\n");
}

void
pciide_print_modes(struct pciide_channel *cp)
{
	wdc_print_current_modes(&cp->wdc_channel);
}

void
default_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	pcireg_t csr;
	int channel, drive;
	struct ata_drive_datas *drvp;
	u_int8_t idedma_ctl;
	bus_size_t cmdsize, ctlsize;
	char *failreason;

	if (interface & PCIIDE_INTERFACE_BUS_MASTER_DMA) {
		printf(": DMA");
		if (sc->sc_pp == &default_product_desc &&
		    (sc->sc_wdcdev.sc_dev.dv_cfdata->cf_flags &
		    PCIIDE_OPTIONS_DMA) == 0) {
			printf(" (unsupported)");
			sc->sc_dma_ok = 0;
		} else {
			pciide_mapreg_dma(sc, pa);
			if (sc->sc_dma_ok != 0)
				printf(", (partial support)");
		}
	} else {
		printf(": no DMA");
		sc->sc_dma_ok = 0;
	}
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 0;
	sc->sc_wdcdev.DMA_cap = 0;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		if (interface & PCIIDE_INTERFACE_PCI(channel)) {
			cp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize,
			    &ctlsize, pciide_pci_intr);
		} else {
			cp->hw_ok = pciide_mapregs_compat(pa, cp,
			    channel, &cmdsize, &ctlsize);
		}
		if (cp->hw_ok == 0)
			continue;
		/*
		 * Check to see if something appears to be there.
		 */
		failreason = NULL;
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		if (!wdcprobe(&cp->wdc_channel)) {
			failreason = "not responding; disabled or no drives?";
			goto next;
		}
		/*
		 * Now, make sure it's actually attributable to this PCI IDE
		 * channel by trying to access the channel again while the
		 * PCI IDE controller's I/O space is disabled.  (If the
		 * channel no longer appears to be there, it belongs to
		 * this controller.)  YUCK!
		 */
		csr = pci_conf_read(sc->sc_pc, sc->sc_tag,
	  	    PCI_COMMAND_STATUS_REG);
		pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG,
		    csr & ~PCI_COMMAND_IO_ENABLE);
		if (wdcprobe(&cp->wdc_channel))
			failreason = "other hardware responding at addresses";
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    PCI_COMMAND_STATUS_REG, csr);
next:
		if (failreason) {
			printf("%s: %s ignored (%s)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
			    failreason);
			cp->hw_ok = 0;
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			bus_space_unmap(cp->wdc_channel.cmd_iot,
			    cp->wdc_channel.cmd_ioh, cmdsize);
			if (interface & PCIIDE_INTERFACE_PCI(channel))
				bus_space_unmap(cp->wdc_channel.ctl_iot,
				    cp->ctl_baseioh, ctlsize);
			else
				bus_space_unmap(cp->wdc_channel.ctl_iot,
				    cp->wdc_channel.ctl_ioh, ctlsize);
		}
		if (cp->hw_ok) {
			cp->wdc_channel.data32iot = cp->wdc_channel.cmd_iot;
			cp->wdc_channel.data32ioh = cp->wdc_channel.cmd_ioh;
			wdcattach(&cp->wdc_channel);
		}
	}

	if (sc->sc_dma_ok == 0)
		return;

	/* Allocate DMA maps */
	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		idedma_ctl = 0;
		cp = &sc->pciide_channels[channel];
		for (drive = 0; drive < 2; drive++) {
			drvp = &cp->wdc_channel.ch_drive[drive];
			/* If no drive, skip */
			if ((drvp->drive_flags & DRIVE) == 0)
				continue;
			if ((drvp->drive_flags & DRIVE_DMA) == 0)
				continue;
			if (pciide_dma_table_setup(sc, channel, drive) != 0) {
				/* Abort DMA setup */
				printf("%s:%d:%d: cannot allocate DMA maps, "
				    "using PIO transfers\n",
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive);
				drvp->drive_flags &= ~DRIVE_DMA;
			}
			printf("%s:%d:%d: using DMA data transfers\n",
			    sc->sc_wdcdev.sc_dev.dv_xname,
			    channel, drive);
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		}
		if (idedma_ctl != 0) {
			/* Add software bits in status register */
			PCIIDE_DMACTL_WRITE(sc, channel, idedma_ctl);
		}
	}
}

void
default_chip_unmap(struct pciide_softc *sc, int flags)
{
	struct pciide_channel *cp;
	int channel;

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		pciide_unmap_chan(sc, cp, flags);
		pciide_chanfree(sc, channel);
	}

	pciide_unmapreg_dma(sc);

	if (sc->sc_cookie)
		free(sc->sc_cookie, M_DEVBUF, sc->sc_cookielen);
}

void
sata_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	int channel;
	bus_size_t cmdsize, ctlsize;

	if (interface == 0) {
		WDCDEBUG_PRINT(("sata_chip_map interface == 0\n"),
		    DEBUG_PROBE);
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);
	}

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA |
		    WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 6;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_SATA;
	sc->sc_wdcdev.set_modes = sata_setup_channel;
	sc->chip_unmap = default_chip_unmap;

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		sata_setup_channel(&cp->wdc_channel);
	}
}

void
sata_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		}
	}

	/*
	 * Nothing to do to setup modes; it is meaningless in S-ATA
	 * (but many S-ATA drives still want to get the SET_FEATURE
	 * command).
	 */
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		PCIIDE_DMACTL_WRITE(sc, chp->channel, idedma_ctl);
	}
	pciide_print_modes(cp);
}

void
piix_timing_debug(struct pciide_softc *sc)
{
	WDCDEBUG_PRINT(("piix_setup_chip: idetim=0x%x",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM)),
	    DEBUG_PROBE);
	if (sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_IDE &&
	    sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_ISA) {
		WDCDEBUG_PRINT((", sidetim=0x%x",
		    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM)),
		    DEBUG_PROBE);
		if (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {
			WDCDEBUG_PRINT((", udmareg 0x%x",
			    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG)),
			    DEBUG_PROBE);
		}
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6321ESB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBL_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801HBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82372FB_IDE) {
			WDCDEBUG_PRINT((", IDE_CONTROL 0x%x",
			    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG)),
			    DEBUG_PROBE);
		}
	}
	WDCDEBUG_PRINT(("\n"), DEBUG_PROBE);
}

void
piix_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	u_int32_t idetim;
	bus_size_t cmdsize, ctlsize;

	pcireg_t interface = PCI_INTERFACE(pa->pa_class);

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		switch (sc->sc_pp->ide_product) {
		case PCI_PRODUCT_INTEL_6300ESB_IDE:
		case PCI_PRODUCT_INTEL_6321ESB_IDE:
		case PCI_PRODUCT_INTEL_82371AB_IDE:
		case PCI_PRODUCT_INTEL_82372FB_IDE:
		case PCI_PRODUCT_INTEL_82440MX_IDE:
		case PCI_PRODUCT_INTEL_82451NX:
		case PCI_PRODUCT_INTEL_82801AA_IDE:
		case PCI_PRODUCT_INTEL_82801AB_IDE:
		case PCI_PRODUCT_INTEL_82801BAM_IDE:
		case PCI_PRODUCT_INTEL_82801BA_IDE:
		case PCI_PRODUCT_INTEL_82801CAM_IDE:
		case PCI_PRODUCT_INTEL_82801CA_IDE:
		case PCI_PRODUCT_INTEL_82801DB_IDE:
		case PCI_PRODUCT_INTEL_82801DBL_IDE:
		case PCI_PRODUCT_INTEL_82801DBM_IDE:
		case PCI_PRODUCT_INTEL_82801EB_IDE:
		case PCI_PRODUCT_INTEL_82801FB_IDE:
		case PCI_PRODUCT_INTEL_82801GB_IDE:
		case PCI_PRODUCT_INTEL_82801HBM_IDE:
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
			break;
		}
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_INTEL_82801AA_IDE:
	case PCI_PRODUCT_INTEL_82372FB_IDE:
		sc->sc_wdcdev.UDMA_cap = 4;
		break;
	case PCI_PRODUCT_INTEL_6300ESB_IDE:
	case PCI_PRODUCT_INTEL_6321ESB_IDE:
	case PCI_PRODUCT_INTEL_82801BAM_IDE:
	case PCI_PRODUCT_INTEL_82801BA_IDE:
	case PCI_PRODUCT_INTEL_82801CAM_IDE:
	case PCI_PRODUCT_INTEL_82801CA_IDE:
	case PCI_PRODUCT_INTEL_82801DB_IDE:
	case PCI_PRODUCT_INTEL_82801DBL_IDE:
	case PCI_PRODUCT_INTEL_82801DBM_IDE:
	case PCI_PRODUCT_INTEL_82801EB_IDE:
	case PCI_PRODUCT_INTEL_82801FB_IDE:
	case PCI_PRODUCT_INTEL_82801GB_IDE:
	case PCI_PRODUCT_INTEL_82801HBM_IDE:
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
	default:
		sc->sc_wdcdev.UDMA_cap = 2;
		break;
	}

	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371FB_IDE ||
		   sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371FB_ISA) {
		sc->sc_wdcdev.set_modes = piix_setup_channel;
	} else {
		sc->sc_wdcdev.set_modes = piix3_4_setup_channel;
	}
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	piix_timing_debug(sc);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];

		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		idetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);
		if ((PIIX_IDETIM_READ(idetim, channel) &
		    PIIX_IDETIM_IDE) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			cp->hw_ok = 0;
			continue;
		}
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0)
			goto next;
		if (pciide_chan_candisable(cp)) {
			idetim = PIIX_IDETIM_CLEAR(idetim, PIIX_IDETIM_IDE,
			    channel);
			pci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_IDETIM,
			    idetim);
		}
		if (cp->hw_ok == 0)
			goto next;
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
next:
		if (cp->hw_ok == 0)
			pciide_unmap_compat_intr(pa, cp, channel, interface);
	}

	piix_timing_debug(sc);
}

void
piixsata_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	int channel;
	bus_size_t cmdsize, ctlsize;
	u_int8_t reg, ich = 0;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA |
		    WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		sc->sc_wdcdev.DMA_cap = 2;
		sc->sc_wdcdev.UDMA_cap = 6;
	}
	sc->sc_wdcdev.PIO_cap = 4;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_SATA;
	sc->sc_wdcdev.set_modes = sata_setup_channel;

	switch(sc->sc_pp->ide_product) {
	case PCI_PRODUCT_INTEL_6300ESB_SATA:
	case PCI_PRODUCT_INTEL_6300ESB_SATA2:
	case PCI_PRODUCT_INTEL_82801EB_SATA:
	case PCI_PRODUCT_INTEL_82801ER_SATA:
		ich = 5;
		break;
	case PCI_PRODUCT_INTEL_82801FB_SATA:
	case PCI_PRODUCT_INTEL_82801FR_SATA:
	case PCI_PRODUCT_INTEL_82801FBM_SATA:
		ich = 6;
		break;
	default:
		ich = 7;
		break;
	}

	/*
	 * Put the SATA portion of controllers that don't operate in combined
	 * mode into native PCI modes so the maximum number of devices can be
	 * used.  Intel calls this "enhanced mode"
	 */
	if (ich == 5) {
		reg = pciide_pci_read(sc->sc_pc, sc->sc_tag, ICH5_SATA_MAP);
		if ((reg & ICH5_SATA_MAP_COMBINED) == 0) {
			reg = pciide_pci_read(pa->pa_pc, pa->pa_tag,
			    ICH5_SATA_PI);
			reg |= ICH5_SATA_PI_PRI_NATIVE |
			    ICH5_SATA_PI_SEC_NATIVE;
			pciide_pci_write(pa->pa_pc, pa->pa_tag,
			    ICH5_SATA_PI, reg);
			interface |= PCIIDE_INTERFACE_PCI(0) |
			    PCIIDE_INTERFACE_PCI(1);
		}
	} else {
		reg = pciide_pci_read(sc->sc_pc, sc->sc_tag, ICH5_SATA_MAP) &
		    ICH6_SATA_MAP_CMB_MASK;
		if (reg != ICH6_SATA_MAP_CMB_PRI &&
		    reg != ICH6_SATA_MAP_CMB_SEC) {
			reg = pciide_pci_read(pa->pa_pc, pa->pa_tag,
			    ICH5_SATA_PI);
			reg |= ICH5_SATA_PI_PRI_NATIVE |
			    ICH5_SATA_PI_SEC_NATIVE;

			pciide_pci_write(pa->pa_pc, pa->pa_tag,
			    ICH5_SATA_PI, reg);
			interface |= PCIIDE_INTERFACE_PCI(0) |
			    PCIIDE_INTERFACE_PCI(1);

			/*
			 * Ask for SATA IDE Mode, we don't need to do this
			 * for the combined mode case as combined mode is
			 * only allowed in IDE Mode
			 */
			if (ich >= 7) {
				reg = pciide_pci_read(sc->sc_pc, sc->sc_tag,
				    ICH5_SATA_MAP) & ~ICH7_SATA_MAP_SMS_MASK;
				pciide_pci_write(pa->pa_pc, pa->pa_tag,
				    ICH5_SATA_MAP, reg);
			}
		}
	}

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;

		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok != 0)
			sc->sc_wdcdev.set_modes(&cp->wdc_channel);

		if (cp->hw_ok == 0)
			pciide_unmap_compat_intr(pa, cp, channel, interface);
	}
}

void
piix_setup_channel(struct channel_softc *chp)
{
	u_int8_t mode[2], drive;
	u_int32_t oidetim, idetim, idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct ata_drive_datas *drvp = cp->wdc_channel.ch_drive;

	oidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);
	idetim = PIIX_IDETIM_CLEAR(oidetim, 0xffff, chp->channel);
	idedma_ctl = 0;

	/* set up new idetim: Enable IDE registers decode */
	idetim = PIIX_IDETIM_SET(idetim, PIIX_IDETIM_IDE,
	    chp->channel);

	/* setup DMA */
	pciide_channel_dma_setup(cp);

	/*
	 * Here we have to mess up with drives mode: PIIX can't have
	 * different timings for master and slave drives.
	 * We need to find the best combination.
	 */

	/* If both drives supports DMA, take the lower mode */
	if ((drvp[0].drive_flags & DRIVE_DMA) &&
	    (drvp[1].drive_flags & DRIVE_DMA)) {
		mode[0] = mode[1] =
		    min(drvp[0].DMA_mode, drvp[1].DMA_mode);
		    drvp[0].DMA_mode = mode[0];
		    drvp[1].DMA_mode = mode[1];
		goto ok;
	}
	/*
	 * If only one drive supports DMA, use its mode, and
	 * put the other one in PIO mode 0 if mode not compatible
	 */
	if (drvp[0].drive_flags & DRIVE_DMA) {
		mode[0] = drvp[0].DMA_mode;
		mode[1] = drvp[1].PIO_mode;
		if (piix_isp_pio[mode[1]] != piix_isp_dma[mode[0]] ||
		    piix_rtc_pio[mode[1]] != piix_rtc_dma[mode[0]])
			mode[1] = drvp[1].PIO_mode = 0;
		goto ok;
	}
	if (drvp[1].drive_flags & DRIVE_DMA) {
		mode[1] = drvp[1].DMA_mode;
		mode[0] = drvp[0].PIO_mode;
		if (piix_isp_pio[mode[0]] != piix_isp_dma[mode[1]] ||
		    piix_rtc_pio[mode[0]] != piix_rtc_dma[mode[1]])
			mode[0] = drvp[0].PIO_mode = 0;
		goto ok;
	}
	/*
	 * If both drives are not DMA, takes the lower mode, unless
	 * one of them is PIO mode < 2
	 */
	if (drvp[0].PIO_mode < 2) {
		mode[0] = drvp[0].PIO_mode = 0;
		mode[1] = drvp[1].PIO_mode;
	} else if (drvp[1].PIO_mode < 2) {
		mode[1] = drvp[1].PIO_mode = 0;
		mode[0] = drvp[0].PIO_mode;
	} else {
		mode[0] = mode[1] =
		    min(drvp[1].PIO_mode, drvp[0].PIO_mode);
		drvp[0].PIO_mode = mode[0];
		drvp[1].PIO_mode = mode[1];
	}
ok:	/* The modes are setup */
	for (drive = 0; drive < 2; drive++) {
		if (drvp[drive].drive_flags & DRIVE_DMA) {
			idetim |= piix_setup_idetim_timings(
			    mode[drive], 1, chp->channel);
			goto end;
		}
	}
	/* If we are there, none of the drives are DMA */
	if (mode[0] >= 2)
		idetim |= piix_setup_idetim_timings(
		    mode[0], 0, chp->channel);
	else
		idetim |= piix_setup_idetim_timings(
		    mode[1], 0, chp->channel);
end:	/*
	 * timing mode is now set up in the controller. Enable
	 * it per-drive
	 */
	for (drive = 0; drive < 2; drive++) {
		/* If no drive, skip */
		if ((drvp[drive].drive_flags & DRIVE) == 0)
			continue;
		idetim |= piix_setup_idetim_drvs(&drvp[drive]);
		if (drvp[drive].drive_flags & DRIVE_DMA)
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel),
		    idedma_ctl);
	}
	pci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_IDETIM, idetim);
	pciide_print_modes(cp);
}

void
piix3_4_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	u_int32_t oidetim, idetim, sidetim, udmareg, ideconf, idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int drive;
	int channel = chp->channel;

	oidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);
	sidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM);
	udmareg = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG);
	ideconf = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG);
	idetim = PIIX_IDETIM_CLEAR(oidetim, 0xffff, channel);
	sidetim &= ~(PIIX_SIDETIM_ISP_MASK(channel) |
	    PIIX_SIDETIM_RTC_MASK(channel));

	idedma_ctl = 0;
	/* If channel disabled, no need to go further */
	if ((PIIX_IDETIM_READ(oidetim, channel) & PIIX_IDETIM_IDE) == 0)
		return;
	/* set up new idetim: Enable IDE registers decode */
	idetim = PIIX_IDETIM_SET(idetim, PIIX_IDETIM_IDE, channel);

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		udmareg &= ~(PIIX_UDMACTL_DRV_EN(channel, drive) |
		    PIIX_UDMATIM_SET(0x3, channel, drive));
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (((drvp->drive_flags & DRIVE_DMA) == 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) == 0))
			goto pio;

		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6321ESB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBL_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801HBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82372FB_IDE) {
			ideconf |= PIIX_CONFIG_PINGPONG;
		}
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6321ESB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBL_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801HBM_IDE) {
			/* setup Ultra/100 */
			if (drvp->UDMA_mode > 2 &&
			    (ideconf & PIIX_CONFIG_CR(channel, drive)) == 0)
				drvp->UDMA_mode = 2;
			if (drvp->UDMA_mode > 4) {
				ideconf |= PIIX_CONFIG_UDMA100(channel, drive);
			} else {
				ideconf &= ~PIIX_CONFIG_UDMA100(channel, drive);
				if (drvp->UDMA_mode > 2) {
					ideconf |= PIIX_CONFIG_UDMA66(channel,
					    drive);
				} else {
					ideconf &= ~PIIX_CONFIG_UDMA66(channel,
					    drive);
				}
			}
		}
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82372FB_IDE) {
			/* setup Ultra/66 */
			if (drvp->UDMA_mode > 2 &&
			    (ideconf & PIIX_CONFIG_CR(channel, drive)) == 0)
				drvp->UDMA_mode = 2;
			if (drvp->UDMA_mode > 2)
				ideconf |= PIIX_CONFIG_UDMA66(channel, drive);
			else
				ideconf &= ~PIIX_CONFIG_UDMA66(channel, drive);
		}

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&
		    (drvp->drive_flags & DRIVE_UDMA)) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			udmareg |= PIIX_UDMACTL_DRV_EN( channel, drive);
			udmareg |= PIIX_UDMATIM_SET(
			    piix4_sct_udma[drvp->UDMA_mode], channel, drive);
		} else {
			/* use Multiword DMA */
			drvp->drive_flags &= ~DRIVE_UDMA;
			if (drive == 0) {
				idetim |= piix_setup_idetim_timings(
				    drvp->DMA_mode, 1, channel);
			} else {
				sidetim |= piix_setup_sidetim_timings(
					drvp->DMA_mode, 1, channel);
				idetim = PIIX_IDETIM_SET(idetim,
				    PIIX_IDETIM_SITRE, channel);
			}
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:		/* use PIO mode */
		idetim |= piix_setup_idetim_drvs(drvp);
		if (drive == 0) {
			idetim |= piix_setup_idetim_timings(
			    drvp->PIO_mode, 0, channel);
		} else {
			sidetim |= piix_setup_sidetim_timings(
				drvp->PIO_mode, 0, channel);
			idetim = PIIX_IDETIM_SET(idetim,
			    PIIX_IDETIM_SITRE, channel);
		}
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel),
		    idedma_ctl);
	}
	pci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_IDETIM, idetim);
	pci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM, sidetim);
	pci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG, udmareg);
	pci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_CONFIG, ideconf);
	pciide_print_modes(cp);
}


/* setup ISP and RTC fields, based on mode */
u_int32_t
piix_setup_idetim_timings(u_int8_t mode, u_int8_t dma, u_int8_t channel)
{

	if (dma)
		return (PIIX_IDETIM_SET(0,
		    PIIX_IDETIM_ISP_SET(piix_isp_dma[mode]) |
		    PIIX_IDETIM_RTC_SET(piix_rtc_dma[mode]),
		    channel));
	else
		return (PIIX_IDETIM_SET(0,
		    PIIX_IDETIM_ISP_SET(piix_isp_pio[mode]) |
		    PIIX_IDETIM_RTC_SET(piix_rtc_pio[mode]),
		    channel));
}

/* setup DTE, PPE, IE and TIME field based on PIO mode */
u_int32_t
piix_setup_idetim_drvs(struct ata_drive_datas *drvp)
{
	u_int32_t ret = 0;
	struct channel_softc *chp = drvp->chnl_softc;
	u_int8_t channel = chp->channel;
	u_int8_t drive = drvp->drive;

	/*
	 * If drive is using UDMA, timings setups are independant
	 * So just check DMA and PIO here.
	 */
	if (drvp->drive_flags & DRIVE_DMA) {
		/* if mode = DMA mode 0, use compatible timings */
		if ((drvp->drive_flags & DRIVE_DMA) &&
		    drvp->DMA_mode == 0) {
			drvp->PIO_mode = 0;
			return (ret);
		}
		ret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);
		/*
		 * PIO and DMA timings are the same, use fast timings for PIO
		 * too, else use compat timings.
		 */
		if ((piix_isp_pio[drvp->PIO_mode] !=
		    piix_isp_dma[drvp->DMA_mode]) ||
		    (piix_rtc_pio[drvp->PIO_mode] !=
		    piix_rtc_dma[drvp->DMA_mode]))
			drvp->PIO_mode = 0;
		/* if PIO mode <= 2, use compat timings for PIO */
		if (drvp->PIO_mode <= 2) {
			ret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_DTE(drive),
			    channel);
			return (ret);
		}
	}

	/*
	 * Now setup PIO modes. If mode < 2, use compat timings.
	 * Else enable fast timings. Enable IORDY and prefetch/post
	 * if PIO mode >= 3.
	 */

	if (drvp->PIO_mode < 2)
		return (ret);

	ret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);
	if (drvp->PIO_mode >= 3) {
		ret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_IE(drive), channel);
		ret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_PPE(drive), channel);
	}
	return (ret);
}

/* setup values in SIDETIM registers, based on mode */
u_int32_t
piix_setup_sidetim_timings(u_int8_t mode, u_int8_t dma, u_int8_t channel)
{
	if (dma)
		return (PIIX_SIDETIM_ISP_SET(piix_isp_dma[mode], channel) |
		    PIIX_SIDETIM_RTC_SET(piix_rtc_dma[mode], channel));
	else
		return (PIIX_SIDETIM_ISP_SET(piix_isp_pio[mode], channel) |
		    PIIX_SIDETIM_RTC_SET(piix_rtc_pio[mode], channel));
}

void
amd756_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	int channel;
	pcireg_t chanenable;
	bus_size_t cmdsize, ctlsize;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_AMD_8111_IDE:
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
	case PCI_PRODUCT_AMD_766_IDE:
	case PCI_PRODUCT_AMD_PBC768_IDE:
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
	default:
		sc->sc_wdcdev.UDMA_cap = 4;
		break;
	}
	sc->sc_wdcdev.set_modes = amd756_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	chanenable = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_CHANSTATUS_EN);

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		if ((chanenable & AMD756_CHAN_EN(channel)) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			cp->hw_ok = 0;
			continue;
		}
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;

		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);

		if (pciide_chan_candisable(cp)) {
			chanenable &= ~AMD756_CHAN_EN(channel);
		}
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		amd756_setup_channel(&cp->wdc_channel);
	}
	pci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_CHANSTATUS_EN,
	    chanenable);
	return;
}

void
amd756_setup_channel(struct channel_softc *chp)
{
	u_int32_t udmatim_reg, datatim_reg;
	u_int8_t idedma_ctl;
	int mode, drive;
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	pcireg_t chanenable;
#ifndef	PCIIDE_AMD756_ENABLEDMA
	int product = sc->sc_pp->ide_product;
	int rev = sc->sc_rev;
#endif

	idedma_ctl = 0;
	datatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_DATATIM);
	udmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_UDMA);
	datatim_reg &= ~AMD756_DATATIM_MASK(chp->channel);
	udmatim_reg &= ~AMD756_UDMA_MASK(chp->channel);
	chanenable = pci_conf_read(sc->sc_pc, sc->sc_tag,
	    AMD756_CHANSTATUS_EN);

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		if (((drvp->drive_flags & DRIVE_DMA) == 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) == 0)) {
			mode = drvp->PIO_mode;
			goto pio;
		}
		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&
		    (drvp->drive_flags & DRIVE_UDMA)) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;

			/* Check cable */
			if ((chanenable & AMD756_CABLE(chp->channel,
			    drive)) == 0 && drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    chp->channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}

			udmatim_reg |= AMD756_UDMA_EN(chp->channel, drive) |
			    AMD756_UDMA_EN_MTH(chp->channel, drive) |
			    AMD756_UDMA_TIME(chp->channel, drive,
				amd756_udma_tim[drvp->UDMA_mode]);
			/* can use PIO timings, MW DMA unused */
			mode = drvp->PIO_mode;
		} else {
			/* use Multiword DMA, but only if revision is OK */
			drvp->drive_flags &= ~DRIVE_UDMA;
#ifndef PCIIDE_AMD756_ENABLEDMA
			/*
			 * The workaround doesn't seem to be necessary
			 * with all drives, so it can be disabled by
			 * PCIIDE_AMD756_ENABLEDMA. It causes a hard hang if
			 * triggered.
			 */
			if (AMD756_CHIPREV_DISABLEDMA(product, rev)) {
				printf("%s:%d:%d: multi-word DMA disabled due "
				    "to chip revision\n",
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    chp->channel, drive);
				mode = drvp->PIO_mode;
				drvp->drive_flags &= ~DRIVE_DMA;
				goto pio;
			}
#endif
			/* mode = min(pio, dma+2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode +2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:		/* setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
			mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}
		datatim_reg |=
		    AMD756_DATATIM_PULSE(chp->channel, drive,
			amd756_pio_set[mode]) |
		    AMD756_DATATIM_RECOV(chp->channel, drive,
			amd756_pio_rec[mode]);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel),
		    idedma_ctl);
	}
	pciide_print_modes(cp);
	pci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_DATATIM, datatim_reg);
	pci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_UDMA, udmatim_reg);
}

void
apollo_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pcireg_t interface;
	int no_ideconf = 0, channel;
	u_int32_t ideconf;
	bus_size_t cmdsize, ctlsize;
	pcitag_t tag;
	pcireg_t id, class;

	/*
	 * Fake interface since VT6410 is claimed to be a ``RAID'' device.
	 */
	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCI_INTERFACE(pa->pa_class);
	} else {
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);
	}

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_VIATECH_VT6410:
	case PCI_PRODUCT_VIATECH_VT6415:
		no_ideconf = 1;
		/* FALLTHROUGH */
	case PCI_PRODUCT_VIATECH_CX700_IDE:
	case PCI_PRODUCT_VIATECH_VX700_IDE:
	case PCI_PRODUCT_VIATECH_VX855_IDE:
	case PCI_PRODUCT_VIATECH_VX900_IDE:
		printf(": ATA133");
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
	default:
		/* 
		 * Determine the DMA capabilities by looking at the
		 * ISA bridge.
		 */
		tag = pci_make_tag(pa->pa_pc, pa->pa_bus, pa->pa_device, 0);
		id = pci_conf_read(sc->sc_pc, tag, PCI_ID_REG);
		class = pci_conf_read(sc->sc_pc, tag, PCI_CLASS_REG);

		/*
		 * XXX On the VT8237, the ISA bridge is on a different
		 * device.
		 */
		if (PCI_CLASS(class) != PCI_CLASS_BRIDGE &&
		    pa->pa_device == 15) {
			tag = pci_make_tag(pa->pa_pc, pa->pa_bus, 17, 0);
			id = pci_conf_read(sc->sc_pc, tag, PCI_ID_REG);
			class = pci_conf_read(sc->sc_pc, tag, PCI_CLASS_REG);
		}

		switch (PCI_PRODUCT(id)) {
		case PCI_PRODUCT_VIATECH_VT82C586_ISA:
			if (PCI_REVISION(class) >= 0x02) {
				printf(": ATA33");
				sc->sc_wdcdev.UDMA_cap = 2;
			} else {
				printf(": DMA");
				sc->sc_wdcdev.UDMA_cap = 0;
			}
			break;
		case PCI_PRODUCT_VIATECH_VT82C596A:
			if (PCI_REVISION(class) >= 0x12) {
				printf(": ATA66");
				sc->sc_wdcdev.UDMA_cap = 4;
			} else {
				printf(": ATA33");
				sc->sc_wdcdev.UDMA_cap = 2;
			}
			break;

		case PCI_PRODUCT_VIATECH_VT82C686A_ISA:
			if (PCI_REVISION(class) >= 0x40) {
				printf(": ATA100");
				sc->sc_wdcdev.UDMA_cap = 5;
			} else {
				printf(": ATA66");
				sc->sc_wdcdev.UDMA_cap = 4;
			}
			break;
		case PCI_PRODUCT_VIATECH_VT8231_ISA:
		case PCI_PRODUCT_VIATECH_VT8233_ISA:
			printf(": ATA100");
			sc->sc_wdcdev.UDMA_cap = 5;
			break;
		case PCI_PRODUCT_VIATECH_VT8233A_ISA:
		case PCI_PRODUCT_VIATECH_VT8235_ISA:
		case PCI_PRODUCT_VIATECH_VT8237_ISA:
			printf(": ATA133");
			sc->sc_wdcdev.UDMA_cap = 6;
			break;
		default:
			printf(": DMA");
			sc->sc_wdcdev.UDMA_cap = 0;
			break;
		}
		break;
	}

	pciide_mapreg_dma(sc, pa);
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		if (sc->sc_wdcdev.UDMA_cap > 0)
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = apollo_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	WDCDEBUG_PRINT(("apollo_chip_map: old APO_IDECONF=0x%x, "
	    "APO_CTLMISC=0x%x, APO_DATATIM=0x%x, APO_UDMA=0x%x\n",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_IDECONF),
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_CTLMISC),
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM),
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA)),
	    DEBUG_PROBE);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		if (no_ideconf == 0) {
			ideconf = pci_conf_read(sc->sc_pc, sc->sc_tag,
			    APO_IDECONF);
			if ((ideconf & APO_IDECONF_EN(channel)) == 0) {
				printf("%s: %s ignored (disabled)\n",
				    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
				cp->hw_ok = 0;
				continue;
			}
		}
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;

		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			goto next;
		}
		if (pciide_chan_candisable(cp)) {
			if (no_ideconf == 0) {
				ideconf &= ~APO_IDECONF_EN(channel);
				pci_conf_write(sc->sc_pc, sc->sc_tag,
				    APO_IDECONF, ideconf);
			}
		}

		if (cp->hw_ok == 0)
			goto next;
		apollo_setup_channel(&sc->pciide_channels[channel].wdc_channel);
next:
		if (cp->hw_ok == 0)
			pciide_unmap_compat_intr(pa, cp, channel, interface);
	}
	WDCDEBUG_PRINT(("apollo_chip_map: APO_DATATIM=0x%x, APO_UDMA=0x%x\n",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM),
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA)), DEBUG_PROBE);
}

void
apollo_setup_channel(struct channel_softc *chp)
{
	u_int32_t udmatim_reg, datatim_reg;
	u_int8_t idedma_ctl;
	int mode, drive;
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	idedma_ctl = 0;
	datatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM);
	udmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);
	datatim_reg &= ~APO_DATATIM_MASK(chp->channel);
	udmatim_reg &= ~APO_UDMA_MASK(chp->channel);

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	/*
	 * We can't mix Ultra/33 and Ultra/66 on the same channel, so
	 * downgrade to Ultra/33 if needed
	 */
	if ((chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&
	    (chp->ch_drive[1].drive_flags & DRIVE_UDMA)) {
		/* both drives UDMA */
		if (chp->ch_drive[0].UDMA_mode > 2 &&
		    chp->ch_drive[1].UDMA_mode <= 2) {
			/* drive 0 Ultra/66, drive 1 Ultra/33 */
			chp->ch_drive[0].UDMA_mode = 2;
		} else if (chp->ch_drive[1].UDMA_mode > 2 &&
		    chp->ch_drive[0].UDMA_mode <= 2) {
			/* drive 1 Ultra/66, drive 0 Ultra/33 */
			chp->ch_drive[1].UDMA_mode = 2;
		}
	}

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		if (((drvp->drive_flags & DRIVE_DMA) == 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) == 0)) {
			mode = drvp->PIO_mode;
			goto pio;
		}
		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&
		    (drvp->drive_flags & DRIVE_UDMA)) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			udmatim_reg |= APO_UDMA_EN(chp->channel, drive) |
			    APO_UDMA_EN_MTH(chp->channel, drive);
			if (sc->sc_wdcdev.UDMA_cap == 6) {
				udmatim_reg |= APO_UDMA_TIME(chp->channel,
				    drive, apollo_udma133_tim[drvp->UDMA_mode]);
			} else if (sc->sc_wdcdev.UDMA_cap == 5) {
				/* 686b */
				udmatim_reg |= APO_UDMA_TIME(chp->channel,
				    drive, apollo_udma100_tim[drvp->UDMA_mode]);
			} else if (sc->sc_wdcdev.UDMA_cap == 4) {
				/* 596b or 686a */
				udmatim_reg |= APO_UDMA_CLK66(chp->channel);
				udmatim_reg |= APO_UDMA_TIME(chp->channel,
				    drive, apollo_udma66_tim[drvp->UDMA_mode]);
			} else {
				/* 596a or 586b */
				udmatim_reg |= APO_UDMA_TIME(chp->channel,
				    drive, apollo_udma33_tim[drvp->UDMA_mode]);
			}
			/* can use PIO timings, MW DMA unused */
			mode = drvp->PIO_mode;
		} else {
			/* use Multiword DMA */
			drvp->drive_flags &= ~DRIVE_UDMA;
			/* mode = min(pio, dma+2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode +2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:		/* setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
			mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}
		datatim_reg |=
		    APO_DATATIM_PULSE(chp->channel, drive,
			apollo_pio_set[mode]) |
		    APO_DATATIM_RECOV(chp->channel, drive,
			apollo_pio_rec[mode]);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel),
		    idedma_ctl);
	}
	pciide_print_modes(cp);
	pci_conf_write(sc->sc_pc, sc->sc_tag, APO_DATATIM, datatim_reg);
	pci_conf_write(sc->sc_pc, sc->sc_tag, APO_UDMA, udmatim_reg);
}

void
cmd_channel_map(struct pci_attach_args *pa, struct pciide_softc *sc,
    int channel)
{
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	bus_size_t cmdsize, ctlsize;
	u_int8_t ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CTRL);
	pcireg_t interface;
	int one_channel;

	/*
	 * The 0648/0649 can be told to identify as a RAID controller.
	 * In this case, we have to fake interface
	 */
	if (PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCIIDE_INTERFACE_SETTABLE(0) |
		    PCIIDE_INTERFACE_SETTABLE(1);
		if (pciide_pci_read(pa->pa_pc, pa->pa_tag, CMD_CONF) &
		    CMD_CONF_DSA1)
			interface |= PCIIDE_INTERFACE_PCI(0) |
			    PCIIDE_INTERFACE_PCI(1);
	} else {
		interface = PCI_INTERFACE(pa->pa_class);
	}

	sc->wdc_chanarray[channel] = &cp->wdc_channel;
	cp->name = PCIIDE_CHANNEL_NAME(channel);
	cp->wdc_channel.channel = channel;
	cp->wdc_channel.wdc = &sc->sc_wdcdev;

	/*
	 * Older CMD64X doesn't have independant channels
	 */
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_CMDTECH_649:
		one_channel = 0;
		break;
	default:
		one_channel = 1;
		break;
	}

	if (channel > 0 && one_channel) {
		cp->wdc_channel.ch_queue =
		    sc->pciide_channels[0].wdc_channel.ch_queue;
	} else {
		cp->wdc_channel.ch_queue = wdc_alloc_queue();
	}
	if (cp->wdc_channel.ch_queue == NULL) {
		printf(
		    "%s: %s cannot allocate channel queue",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return;
	}

	/*
	 * with a CMD PCI64x, if we get here, the first channel is enabled:
	 * there's no way to disable the first channel without disabling
	 * the whole device
	 */
	if (channel != 0 && (ctrl & CMD_CTRL_2PORT) == 0) {
		printf("%s: %s ignored (disabled)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		cp->hw_ok = 0;
		return;
	}
	cp->hw_ok = 1;
	pciide_map_compat_intr(pa, cp, channel, interface);
	if (cp->hw_ok == 0)
		return;
	pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, cmd_pci_intr);
	if (cp->hw_ok == 0) {
		pciide_unmap_compat_intr(pa, cp, channel, interface);
		return;
	}
	if (pciide_chan_candisable(cp)) {
		if (channel == 1) {
			ctrl &= ~CMD_CTRL_2PORT;
			pciide_pci_write(pa->pa_pc, pa->pa_tag,
			    CMD_CTRL, ctrl);
			pciide_unmap_compat_intr(pa, cp, channel, interface);
		}
	}
}

int
cmd_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv;
	u_int32_t priirq, secirq;

	rv = 0;
	priirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CONF);
	secirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23);
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		/* If a compat channel skip. */
		if (cp->compat)
			continue;
		if ((i == 0 && (priirq & CMD_CONF_DRV0_INTR)) ||
		    (i == 1 && (secirq & CMD_ARTTIM23_IRQ))) {
			crv = wdcintr(wdc_cp);
			if (crv == 0) {
#if 0
				printf("%s:%d: bogus intr\n",
				    sc->sc_wdcdev.sc_dev.dv_xname, i);
#endif
			} else
				rv = 1;
		}
	}
	return (rv);
}

void
cmd_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	int channel;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);

	printf(": no DMA");
	sc->sc_dma_ok = 0;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cmd_channel_map(pa, sc, channel);
	}
}

void
cmd0643_9_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	int rev = sc->sc_rev;
	pcireg_t interface;

	/*
	 * The 0648/0649 can be told to identify as a RAID controller.
	 * In this case, we have to fake interface
	 */
	if (PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCIIDE_INTERFACE_SETTABLE(0) |
		    PCIIDE_INTERFACE_SETTABLE(1);
		if (pciide_pci_read(pa->pa_pc, pa->pa_tag, CMD_CONF) &
		    CMD_CONF_DSA1)
			interface |= PCIIDE_INTERFACE_PCI(0) |
			    PCIIDE_INTERFACE_PCI(1);
	} else {
		interface = PCI_INTERFACE(pa->pa_class);
	}

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		switch (sc->sc_pp->ide_product) {
		case PCI_PRODUCT_CMDTECH_649:
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
			sc->sc_wdcdev.UDMA_cap = 5;
			sc->sc_wdcdev.irqack = cmd646_9_irqack;
			break;
		case PCI_PRODUCT_CMDTECH_648:
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
			sc->sc_wdcdev.UDMA_cap = 4;
			sc->sc_wdcdev.irqack = cmd646_9_irqack;
			break;
		case PCI_PRODUCT_CMDTECH_646:
			if (rev >= CMD0646U2_REV) {
				sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
				sc->sc_wdcdev.UDMA_cap = 2;
			} else if (rev >= CMD0646U_REV) {
			/*
			 * Linux's driver claims that the 646U is broken
			 * with UDMA. Only enable it if we know what we're
			 * doing
			 */
#ifdef PCIIDE_CMD0646U_ENABLEUDMA
				sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
				sc->sc_wdcdev.UDMA_cap = 2;
#endif
				/* explicitly disable UDMA */
				pciide_pci_write(sc->sc_pc, sc->sc_tag,
				    CMD_UDMATIM(0), 0);
				pciide_pci_write(sc->sc_pc, sc->sc_tag,
				    CMD_UDMATIM(1), 0);
			}
			sc->sc_wdcdev.irqack = cmd646_9_irqack;
			break;
		default:
			sc->sc_wdcdev.irqack = pciide_irqack;
		}
	}

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = cmd0643_9_setup_channel;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	WDCDEBUG_PRINT(("cmd0643_9_chip_map: old timings reg 0x%x 0x%x\n",
		pci_conf_read(sc->sc_pc, sc->sc_tag, 0x54),
		pci_conf_read(sc->sc_pc, sc->sc_tag, 0x58)),
		DEBUG_PROBE);
	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		cmd_channel_map(pa, sc, channel);
		if (cp->hw_ok == 0)
			continue;
		cmd0643_9_setup_channel(&cp->wdc_channel);
	}
	/*
	 * note - this also makes sure we clear the irq disable and reset
	 * bits
	 */
	pciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_DMA_MODE, CMD_DMA_MULTIPLE);
	WDCDEBUG_PRINT(("cmd0643_9_chip_map: timings reg now 0x%x 0x%x\n",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, 0x54),
	    pci_conf_read(sc->sc_pc, sc->sc_tag, 0x58)),
	    DEBUG_PROBE);
}

void
cmd0643_9_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	u_int8_t tim;
	u_int32_t idedma_ctl, udma_reg;
	int drive;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	idedma_ctl = 0;
	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		tim = cmd0643_9_data_tim_pio[drvp->PIO_mode];
		if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) {
			if (drvp->drive_flags & DRIVE_UDMA) {
				/* UltraDMA on a 646U2, 0648 or 0649 */
				drvp->drive_flags &= ~DRIVE_DMA;
				udma_reg = pciide_pci_read(sc->sc_pc,
				    sc->sc_tag, CMD_UDMATIM(chp->channel));
				if (drvp->UDMA_mode > 2 &&
				    (pciide_pci_read(sc->sc_pc, sc->sc_tag,
				    CMD_BICSR) &
				    CMD_BICSR_80(chp->channel)) == 0) {
					WDCDEBUG_PRINT(("%s(%s:%d:%d): "
					    "80-wire cable not detected\n",
					    drvp->drive_name,
					    sc->sc_wdcdev.sc_dev.dv_xname,
					    chp->channel, drive), DEBUG_PROBE);
					drvp->UDMA_mode = 2;
				}
				if (drvp->UDMA_mode > 2)
					udma_reg &= ~CMD_UDMATIM_UDMA33(drive);
				else if (sc->sc_wdcdev.UDMA_cap > 2)
					udma_reg |= CMD_UDMATIM_UDMA33(drive);
				udma_reg |= CMD_UDMATIM_UDMA(drive);
				udma_reg &= ~(CMD_UDMATIM_TIM_MASK <<
				    CMD_UDMATIM_TIM_OFF(drive));
				udma_reg |=
				    (cmd0646_9_tim_udma[drvp->UDMA_mode] <<
				    CMD_UDMATIM_TIM_OFF(drive));
				pciide_pci_write(sc->sc_pc, sc->sc_tag,
				    CMD_UDMATIM(chp->channel), udma_reg);
			} else {
				/*
				 * use Multiword DMA.
				 * Timings will be used for both PIO and DMA,
				 * so adjust DMA mode if needed
				 * if we have a 0646U2/8/9, turn off UDMA
				 */
				if (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {
					udma_reg = pciide_pci_read(sc->sc_pc,
					    sc->sc_tag,
					    CMD_UDMATIM(chp->channel));
					udma_reg &= ~CMD_UDMATIM_UDMA(drive);
					pciide_pci_write(sc->sc_pc, sc->sc_tag,
					    CMD_UDMATIM(chp->channel),
					    udma_reg);
				}
				if (drvp->PIO_mode >= 3 &&
				    (drvp->DMA_mode + 2) > drvp->PIO_mode) {
					drvp->DMA_mode = drvp->PIO_mode - 2;
				}
				tim = cmd0643_9_data_tim_dma[drvp->DMA_mode];
			}
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		}
		pciide_pci_write(sc->sc_pc, sc->sc_tag,
		    CMD_DATA_TIM(chp->channel, drive), tim);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel),
		    idedma_ctl);
	}
	pciide_print_modes(cp);
#ifdef __sparc64__
	/*
	 * The Ultra 5 has a tendency to hang during reboot.  This is due
	 * to the PCI0646U asserting a PCI interrupt line when the chip
	 * registers claim that it is not.  Performing a reset at this
	 * point appears to eliminate the symptoms.  It is likely the
	 * real cause is still lurking somewhere in the code.
	 */
	wdcreset(chp, SILENT);
#endif /* __sparc64__ */
}

void
cmd646_9_irqack(struct channel_softc *chp)
{
	u_int32_t priirq, secirq;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	if (chp->channel == 0) {
		priirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CONF);
		pciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_CONF, priirq);
	} else {
		secirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23);
		pciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23, secirq);
	}
	pciide_irqack(chp);
}

void
cmd680_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;

	printf("\n%s: bus-master DMA support present",
	    sc->sc_wdcdev.sc_dev.dv_xname);
	pciide_mapreg_dma(sc, pa);
	printf("\n");
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.UDMA_cap = 6;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = cmd680_setup_channel;

	pciide_pci_write(sc->sc_pc, sc->sc_tag, 0x80, 0x00);
	pciide_pci_write(sc->sc_pc, sc->sc_tag, 0x84, 0x00);
	pciide_pci_write(sc->sc_pc, sc->sc_tag, 0x8a,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, 0x8a) | 0x01);
	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		cmd680_channel_map(pa, sc, channel);
		if (cp->hw_ok == 0)
			continue;
		cmd680_setup_channel(&cp->wdc_channel);
	}
}

void
cmd680_channel_map(struct pci_attach_args *pa, struct pciide_softc *sc,
    int channel)
{
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	bus_size_t cmdsize, ctlsize;
	int interface, i, reg;
	static const u_int8_t init_val[] =
	    {             0x8a, 0x32, 0x8a, 0x32, 0x8a, 0x32,
	      0x92, 0x43, 0x92, 0x43, 0x09, 0x40, 0x09, 0x40 };

	if (PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCIIDE_INTERFACE_SETTABLE(0) |
		    PCIIDE_INTERFACE_SETTABLE(1);
		interface |= PCIIDE_INTERFACE_PCI(0) |
		    PCIIDE_INTERFACE_PCI(1);
	} else {
		interface = PCI_INTERFACE(pa->pa_class);
	}

	sc->wdc_chanarray[channel] = &cp->wdc_channel;
	cp->name = PCIIDE_CHANNEL_NAME(channel);
	cp->wdc_channel.channel = channel;
	cp->wdc_channel.wdc = &sc->sc_wdcdev;

	cp->wdc_channel.ch_queue = wdc_alloc_queue();
	if (cp->wdc_channel.ch_queue == NULL) {
		printf("%s %s: "
		    "cannot allocate channel queue",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		    return;
	}

	/* XXX */
	reg = 0xa2 + channel * 16;
	for (i = 0; i < sizeof(init_val); i++)
		pciide_pci_write(sc->sc_pc, sc->sc_tag, reg + i, init_val[i]);

	printf("%s: %s %s to %s mode\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
	    (interface & PCIIDE_INTERFACE_SETTABLE(channel)) ?
	    "configured" : "wired",
	    (interface & PCIIDE_INTERFACE_PCI(channel)) ?
	    "native-PCI" : "compatibility");

	pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, pciide_pci_intr);
	if (cp->hw_ok == 0)
		return;
	pciide_map_compat_intr(pa, cp, channel, interface);
}

void
cmd680_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	u_int8_t mode, off, scsc;
	u_int16_t val;
	u_int32_t idedma_ctl;
	int drive;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	pci_chipset_tag_t pc = sc->sc_pc;
	pcitag_t pa = sc->sc_tag;
	static const u_int8_t udma2_tbl[] =
	    { 0x0f, 0x0b, 0x07, 0x06, 0x03, 0x02, 0x01 };
	static const u_int8_t udma_tbl[] =
	    { 0x0c, 0x07, 0x05, 0x04, 0x02, 0x01, 0x00 };
	static const u_int16_t dma_tbl[] =
	    { 0x2208, 0x10c2, 0x10c1 };
	static const u_int16_t pio_tbl[] =
	    { 0x328a, 0x2283, 0x1104, 0x10c3, 0x10c1 };

	idedma_ctl = 0;
	pciide_channel_dma_setup(cp);
	mode = pciide_pci_read(pc, pa, 0x80 + chp->channel * 4);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		mode &= ~(0x03 << (drive * 4));
		if (drvp->drive_flags & DRIVE_UDMA) {
			drvp->drive_flags &= ~DRIVE_DMA;
			off = 0xa0 + chp->channel * 16;
			if (drvp->UDMA_mode > 2 &&
			    (pciide_pci_read(pc, pa, off) & 0x01) == 0)
				drvp->UDMA_mode = 2;
			scsc = pciide_pci_read(pc, pa, 0x8a);
			if (drvp->UDMA_mode == 6 && (scsc & 0x30) == 0) {
				pciide_pci_write(pc, pa, 0x8a, scsc | 0x01);
				scsc = pciide_pci_read(pc, pa, 0x8a);
				if ((scsc & 0x30) == 0)
					drvp->UDMA_mode = 5;
			}
			mode |= 0x03 << (drive * 4);
			off = 0xac + chp->channel * 16 + drive * 2;
			val = pciide_pci_read(pc, pa, off) & ~0x3f;
			if (scsc & 0x30)
				val |= udma2_tbl[drvp->UDMA_mode];
			else
				val |= udma_tbl[drvp->UDMA_mode];
			pciide_pci_write(pc, pa, off, val);
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			mode |= 0x02 << (drive * 4);
			off = 0xa8 + chp->channel * 16 + drive * 2;
			val = dma_tbl[drvp->DMA_mode];
			pciide_pci_write(pc, pa, off, val & 0xff);
			pciide_pci_write(pc, pa, off, val >> 8);
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			mode |= 0x01 << (drive * 4);
			off = 0xa4 + chp->channel * 16 + drive * 2;
			val = pio_tbl[drvp->PIO_mode];
			pciide_pci_write(pc, pa, off, val & 0xff);
			pciide_pci_write(pc, pa, off, val >> 8);
		}
	}

	pciide_pci_write(pc, pa, 0x80 + chp->channel * 4, mode);
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel),
		    idedma_ctl);
	}
	pciide_print_modes(cp);
}

/*
 * When the Silicon Image 3112 retries a PCI memory read command,
 * it may retry it as a memory read multiple command under some
 * circumstances.  This can totally confuse some PCI controllers,
 * so ensure that it will never do this by making sure that the
 * Read Threshold (FIFO Read Request Control) field of the FIFO
 * Valid Byte Count and Control registers for both channels (BA5
 * offset 0x40 and 0x44) are set to be at least as large as the
 * cacheline size register.
 */
void
sii_fixup_cacheline(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	pcireg_t cls, reg40, reg44;

	cls = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	cls = (cls >> PCI_CACHELINE_SHIFT) & PCI_CACHELINE_MASK;
	cls *= 4;
	if (cls > 224) {
		cls = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
		cls &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);
		cls |= ((224/4) << PCI_CACHELINE_SHIFT);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, cls);
		cls = 224;
	}
	if (cls < 32)
		cls = 32;
	cls = (cls + 31) / 32;
	reg40 = ba5_read_4(sc, 0x40);
	reg44 = ba5_read_4(sc, 0x44);
	if ((reg40 & 0x7) < cls)
		ba5_write_4(sc, 0x40, (reg40 & ~0x07) | cls);
	if ((reg44 & 0x7) < cls)
		ba5_write_4(sc, 0x44, (reg44 & ~0x07) | cls);
}

void
sii3112_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	bus_size_t cmdsize, ctlsize;
	pcireg_t interface, scs_cmd, cfgctl;
	int channel;
	struct pciide_satalink *sl;

	/* Allocate memory for private data */
	sc->sc_cookielen = sizeof(*sl);
	sc->sc_cookie = malloc(sc->sc_cookielen, M_DEVBUF, M_NOWAIT | M_ZERO);
	sl = sc->sc_cookie;

	sc->chip_unmap = default_chip_unmap;

#define	SII3112_RESET_BITS						\
	(SCS_CMD_PBM_RESET | SCS_CMD_ARB_RESET |			\
	 SCS_CMD_FF1_RESET | SCS_CMD_FF0_RESET |			\
	 SCS_CMD_IDE1_RESET | SCS_CMD_IDE0_RESET)

	/*
	 * Reset everything and then unblock all of the interrupts.
	 */
	scs_cmd = pci_conf_read(pa->pa_pc, pa->pa_tag, SII3112_SCS_CMD);
	pci_conf_write(pa->pa_pc, pa->pa_tag, SII3112_SCS_CMD,
		       scs_cmd | SII3112_RESET_BITS);
	delay(50 * 1000);
	pci_conf_write(pa->pa_pc, pa->pa_tag, SII3112_SCS_CMD,
		       scs_cmd & SCS_CMD_BA5_EN);
	delay(50 * 1000);

	if (scs_cmd & SCS_CMD_BA5_EN) {
		if (pci_mapreg_map(pa, PCI_MAPREG_START + 0x14,
				   PCI_MAPREG_TYPE_MEM |
				   PCI_MAPREG_MEM_TYPE_32BIT, 0,
				   &sl->ba5_st, &sl->ba5_sh,
				   NULL, NULL, 0) != 0)
			printf(": unable to map BA5 register space\n");
		else
			sl->ba5_en = 1;
	} else {
		cfgctl = pci_conf_read(pa->pa_pc, pa->pa_tag,
				       SII3112_PCI_CFGCTL);
		pci_conf_write(pa->pa_pc, pa->pa_tag, SII3112_PCI_CFGCTL,
			       cfgctl | CFGCTL_BA5INDEN);
	}

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");

	/*
	 * Rev. <= 0x01 of the 3112 have a bug that can cause data
	 * corruption if DMA transfers cross an 8K boundary.  This is
	 * apparently hard to tickle, but we'll go ahead and play it
	 * safe.
	 */
	if (sc->sc_rev <= 0x01) {
		sc->sc_dma_maxsegsz = 8192;
		sc->sc_dma_boundary = 8192;
	}

	sii_fixup_cacheline(sc, pa);

	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32;
	sc->sc_wdcdev.PIO_cap = 4;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		sc->sc_wdcdev.DMA_cap = 2;
		sc->sc_wdcdev.UDMA_cap = 6;
	}
	sc->sc_wdcdev.set_modes = sii3112_setup_channel;

	/* We can use SControl and SStatus to probe for drives. */
	sc->sc_wdcdev.drv_probe = sii3112_drv_probe;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	/*
	 * The 3112 either identifies itself as a RAID storage device
	 * or a Misc storage device.  Fake up the interface bits for
	 * what our driver expects.
	 */
	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCI_INTERFACE(pa->pa_class);
	} else {
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);
	}

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0)
			continue;
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
}

void
sii3112_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t idedma_ctl, dtm;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;
	dtm = 0;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			dtm |= DTM_IDEx_DMA;
		} else if (drvp->drive_flags & DRIVE_DMA) {
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			dtm |= DTM_IDEx_DMA;
		} else {
			dtm |= DTM_IDEx_PIO;
		}
	}

	/*
	 * Nothing to do to setup modes; it is meaningless in S-ATA
	 * (but many S-ATA drives still want to get the SET_FEATURE
	 * command).
	 */
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		PCIIDE_DMACTL_WRITE(sc, chp->channel, idedma_ctl);
	}
	BA5_WRITE_4(sc, chp->channel, ba5_IDE_DTM, dtm);
	pciide_print_modes(cp);
}

void
sii3112_drv_probe(struct channel_softc *chp)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	uint32_t scontrol, sstatus;
	uint8_t scnt, sn, cl, ch;
	int s;

	/*
	 * The 3112 is a 2-port part, and only has one drive per channel
	 * (each port emulates a master drive).
	 *
	 * The 3114 is similar, but has 4 channels.
	 */

	/*
	 * Request communication initialization sequence, any speed.
	 * Performing this is the equivalent of an ATA Reset.
	 */
	scontrol = SControl_DET_INIT | SControl_SPD_ANY;

	/*
	 * XXX We don't yet support SATA power management; disable all
	 * power management state transitions.
	 */
	scontrol |= SControl_IPM_NONE;

	BA5_WRITE_4(sc, chp->channel, ba5_SControl, scontrol);
	delay(50 * 1000);
	scontrol &= ~SControl_DET_INIT;
	BA5_WRITE_4(sc, chp->channel, ba5_SControl, scontrol);
	delay(50 * 1000);

	sstatus = BA5_READ_4(sc, chp->channel, ba5_SStatus);
#if 0
	printf("%s: port %d: SStatus=0x%08x, SControl=0x%08x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel, sstatus,
	    BA5_READ_4(sc, chp->channel, ba5_SControl));
#endif
	switch (sstatus & SStatus_DET_mask) {
	case SStatus_DET_NODEV:
		/* No device; be silent. */
		break;

	case SStatus_DET_DEV_NE:
		printf("%s: port %d: device connected, but "
		    "communication not established\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel);
		break;

	case SStatus_DET_OFFLINE:
		printf("%s: port %d: PHY offline\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel);
		break;

	case SStatus_DET_DEV:
		/*
		 * XXX ATAPI detection doesn't currently work.  Don't
		 * XXX know why.  But, it's not like the standard method
		 * XXX can detect an ATAPI device connected via a SATA/PATA
		 * XXX bridge, so at least this is no worse.  --thorpej
		 */
		if (chp->_vtbl != NULL)
			CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (0 << 4));
		else
			bus_space_write_1(chp->cmd_iot, chp->cmd_ioh,
			    wdr_sdh & _WDC_REGMASK, WDSD_IBM | (0 << 4));
		delay(10);	/* 400ns delay */
		/* Save register contents. */
		if (chp->_vtbl != NULL) {
			scnt = CHP_READ_REG(chp, wdr_seccnt);
			sn = CHP_READ_REG(chp, wdr_sector);
			cl = CHP_READ_REG(chp, wdr_cyl_lo);
			ch = CHP_READ_REG(chp, wdr_cyl_hi);
		} else {
			scnt = bus_space_read_1(chp->cmd_iot,
			    chp->cmd_ioh, wdr_seccnt & _WDC_REGMASK);
			sn = bus_space_read_1(chp->cmd_iot,
			    chp->cmd_ioh, wdr_sector & _WDC_REGMASK);
			cl = bus_space_read_1(chp->cmd_iot,
			    chp->cmd_ioh, wdr_cyl_lo & _WDC_REGMASK);
			ch = bus_space_read_1(chp->cmd_iot,
			    chp->cmd_ioh, wdr_cyl_hi & _WDC_REGMASK);
		}
#if 0
		printf("%s: port %d: scnt=0x%x sn=0x%x cl=0x%x ch=0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel,
		    scnt, sn, cl, ch);
#endif
		/*
		 * scnt and sn are supposed to be 0x1 for ATAPI, but in some
		 * cases we get wrong values here, so ignore it.
		 */
		s = splbio();
		if (cl == 0x14 && ch == 0xeb)
			chp->ch_drive[0].drive_flags |= DRIVE_ATAPI;
		else
			chp->ch_drive[0].drive_flags |= DRIVE_ATA;
		splx(s);

		printf("%s: port %d",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel);
		switch ((sstatus & SStatus_SPD_mask) >> SStatus_SPD_shift) {
		case 1:
			printf(": 1.5Gb/s");
			break;
		case 2:
			printf(": 3.0Gb/s");
			break;
		}
		printf("\n");
		break;

	default:
		printf("%s: port %d: unknown SStatus: 0x%08x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel, sstatus);
	}
}

void
sii3114_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pcireg_t scs_cmd;
	pci_intr_handle_t intrhandle;
	const char *intrstr;
	int channel;
	struct pciide_satalink *sl;

	/* Allocate memory for private data */
	sc->sc_cookielen = sizeof(*sl);
	sc->sc_cookie = malloc(sc->sc_cookielen, M_DEVBUF, M_NOWAIT | M_ZERO);
	sl = sc->sc_cookie;

#define	SII3114_RESET_BITS						\
	(SCS_CMD_PBM_RESET | SCS_CMD_ARB_RESET |			\
	 SCS_CMD_FF1_RESET | SCS_CMD_FF0_RESET |			\
	 SCS_CMD_FF3_RESET | SCS_CMD_FF2_RESET |			\
	 SCS_CMD_IDE1_RESET | SCS_CMD_IDE0_RESET |			\
	 SCS_CMD_IDE3_RESET | SCS_CMD_IDE2_RESET)

	/*
	 * Reset everything and then unblock all of the interrupts.
	 */
	scs_cmd = pci_conf_read(pa->pa_pc, pa->pa_tag, SII3112_SCS_CMD);
	pci_conf_write(pa->pa_pc, pa->pa_tag, SII3112_SCS_CMD,
		       scs_cmd | SII3114_RESET_BITS);
	delay(50 * 1000);
	pci_conf_write(pa->pa_pc, pa->pa_tag, SII3112_SCS_CMD,
		       scs_cmd & SCS_CMD_M66EN);
	delay(50 * 1000);

	/*
	 * On the 3114, the BA5 register space is always enabled.  In
	 * order to use the 3114 in any sane way, we must use this BA5
	 * register space, and so we consider it an error if we cannot
	 * map it.
	 *
	 * As a consequence of using BA5, our register mapping is different
	 * from a normal PCI IDE controller's, and so we are unable to use
	 * most of the common PCI IDE register mapping functions.
	 */
	if (pci_mapreg_map(pa, PCI_MAPREG_START + 0x14,
			   PCI_MAPREG_TYPE_MEM |
			   PCI_MAPREG_MEM_TYPE_32BIT, 0,
			   &sl->ba5_st, &sl->ba5_sh,
			   NULL, NULL, 0) != 0) {
		printf(": unable to map BA5 register space\n");
		return;
	}
	sl->ba5_en = 1;

	/*
	 * Set the Interrupt Steering bit in the IDEDMA_CMD register of
	 * channel 2.  This is required at all times for proper operation
	 * when using the BA5 register space (otherwise interrupts from
	 * all 4 channels won't work).
	 */
	BA5_WRITE_4(sc, 2, ba5_IDEDMA_CMD, IDEDMA_CMD_INT_STEER);

	printf(": DMA");
	sii3114_mapreg_dma(sc, pa);
	printf("\n");

	sii_fixup_cacheline(sc, pa);

	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32;
	sc->sc_wdcdev.PIO_cap = 4;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		sc->sc_wdcdev.DMA_cap = 2;
		sc->sc_wdcdev.UDMA_cap = 6;
	}
	sc->sc_wdcdev.set_modes = sii3112_setup_channel;

	/* We can use SControl and SStatus to probe for drives. */
	sc->sc_wdcdev.drv_probe = sii3112_drv_probe;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = 4;

	/* Map and establish the interrupt handler. */
	if (pci_intr_map(pa, &intrhandle) != 0) {
		printf("%s: couldn't map native-PCI interrupt\n",
		    sc->sc_wdcdev.sc_dev.dv_xname);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, intrhandle);
	sc->sc_pci_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_BIO,
					   /* XXX */
					   pciide_pci_intr, sc,
					   sc->sc_wdcdev.sc_dev.dv_xname);
	if (sc->sc_pci_ih != NULL) {
		printf("%s: using %s for native-PCI interrupt\n",
		    sc->sc_wdcdev.sc_dev.dv_xname,
		    intrstr ? intrstr : "unknown interrupt");
	} else {
		printf("%s: couldn't establish native-PCI interrupt",
		    sc->sc_wdcdev.sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (sii3114_chansetup(sc, channel) == 0)
			continue;
		sii3114_mapchan(cp);
		if (cp->hw_ok == 0)
			continue;
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
}

void
sii3114_mapreg_dma(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	int chan, reg;
	bus_size_t size;
	struct pciide_satalink *sl = sc->sc_cookie;

	sc->sc_wdcdev.dma_arg = sc;
	sc->sc_wdcdev.dma_init = pciide_dma_init;
	sc->sc_wdcdev.dma_start = pciide_dma_start;
	sc->sc_wdcdev.dma_finish = pciide_dma_finish;

	/*
	 * Slice off a subregion of BA5 for each of the channel's DMA
	 * registers.
	 */

	sc->sc_dma_iot = sl->ba5_st;
	for (chan = 0; chan < 4; chan++) {
		for (reg = 0; reg < IDEDMA_NREGS; reg++) {
			size = 4;
			if (size > (IDEDMA_SCH_OFFSET - reg))
				size = IDEDMA_SCH_OFFSET - reg;
			if (bus_space_subregion(sl->ba5_st,
			    sl->ba5_sh,
			    satalink_ba5_regmap[chan].ba5_IDEDMA_CMD + reg,
			    size, &sl->regs[chan].dma_iohs[reg]) != 0) {
				sc->sc_dma_ok = 0;
				printf(": can't subregion offset "
				    "%lu size %lu",
				    (u_long) satalink_ba5_regmap[
						chan].ba5_IDEDMA_CMD + reg,
				    (u_long) size);
				return;
			}
		}
	}

	sc->sc_dmacmd_read = sii3114_dmacmd_read;
	sc->sc_dmacmd_write = sii3114_dmacmd_write;
	sc->sc_dmactl_read = sii3114_dmactl_read;
	sc->sc_dmactl_write = sii3114_dmactl_write;
	sc->sc_dmatbl_write = sii3114_dmatbl_write;

	/* DMA registers all set up! */
	sc->sc_dmat = pa->pa_dmat;
	sc->sc_dma_ok = 1;
}

int
sii3114_chansetup(struct pciide_softc *sc, int channel)
{
	static const char *channel_names[] = {
		"port 0",
		"port 1",
		"port 2",
		"port 3",
	};
	struct pciide_channel *cp = &sc->pciide_channels[channel];

	sc->wdc_chanarray[channel] = &cp->wdc_channel;

	/*
	 * We must always keep the Interrupt Steering bit set in channel 2's
	 * IDEDMA_CMD register.
	 */
	if (channel == 2)
		cp->idedma_cmd = IDEDMA_CMD_INT_STEER;

	cp->name = channel_names[channel];
	cp->wdc_channel.channel = channel;
	cp->wdc_channel.wdc = &sc->sc_wdcdev;
	cp->wdc_channel.ch_queue = wdc_alloc_queue();
	if (cp->wdc_channel.ch_queue == NULL) {
		printf("%s %s channel: "
		    "cannot allocate channel queue",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return (0);
	}
	return (1);
}

void
sii3114_mapchan(struct pciide_channel *cp)
{
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct pciide_satalink *sl = sc->sc_cookie;
	int chan = wdc_cp->channel;
	int i;

	cp->hw_ok = 0;
	cp->compat = 0;
	cp->ih = sc->sc_pci_ih;

	sl->regs[chan].cmd_iot = sl->ba5_st;
	if (bus_space_subregion(sl->ba5_st, sl->ba5_sh,
			satalink_ba5_regmap[chan].ba5_IDE_TF0,
			9, &sl->regs[chan].cmd_baseioh) != 0) {
		printf("%s: couldn't subregion %s cmd base\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return;
	}

	sl->regs[chan].ctl_iot = sl->ba5_st;
	if (bus_space_subregion(sl->ba5_st, sl->ba5_sh,
			satalink_ba5_regmap[chan].ba5_IDE_TF8,
			1, &cp->ctl_baseioh) != 0) {
		printf("%s: couldn't subregion %s ctl base\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return;
	}
	sl->regs[chan].ctl_ioh = cp->ctl_baseioh;

	for (i = 0; i < WDC_NREG; i++) {
		if (bus_space_subregion(sl->regs[chan].cmd_iot,
		    sl->regs[chan].cmd_baseioh,
		    i, i == 0 ? 4 : 1,
		    &sl->regs[chan].cmd_iohs[i]) != 0) {
			printf("%s: couldn't subregion %s channel "
			    "cmd regs\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			return;
		}
	}
	sl->regs[chan].cmd_iohs[wdr_status & _WDC_REGMASK] =
	    sl->regs[chan].cmd_iohs[wdr_command & _WDC_REGMASK];
	sl->regs[chan].cmd_iohs[wdr_features & _WDC_REGMASK] =
	    sl->regs[chan].cmd_iohs[wdr_error & _WDC_REGMASK];
	wdc_cp->data32iot = wdc_cp->cmd_iot = sl->regs[chan].cmd_iot;
	wdc_cp->data32ioh = wdc_cp->cmd_ioh = sl->regs[chan].cmd_iohs[0];
	wdc_cp->_vtbl = &wdc_sii3114_vtbl;
	wdcattach(wdc_cp);
	cp->hw_ok = 1;
}

u_int8_t
sii3114_read_reg(struct channel_softc *chp, enum wdc_regs reg)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct pciide_satalink *sl = sc->sc_cookie;

	if (reg & _WDC_AUX)
		return (bus_space_read_1(sl->regs[chp->channel].ctl_iot,
		    sl->regs[chp->channel].ctl_ioh, reg & _WDC_REGMASK));
	else
		return (bus_space_read_1(sl->regs[chp->channel].cmd_iot,
		    sl->regs[chp->channel].cmd_iohs[reg & _WDC_REGMASK], 0));
}

void
sii3114_write_reg(struct channel_softc *chp, enum wdc_regs reg, u_int8_t val)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct pciide_satalink *sl = sc->sc_cookie;

	if (reg & _WDC_AUX)
		bus_space_write_1(sl->regs[chp->channel].ctl_iot,
		    sl->regs[chp->channel].ctl_ioh, reg & _WDC_REGMASK, val);
	else
		bus_space_write_1(sl->regs[chp->channel].cmd_iot,
		    sl->regs[chp->channel].cmd_iohs[reg & _WDC_REGMASK],
		    0, val);
}

u_int8_t
sii3114_dmacmd_read(struct pciide_softc *sc, int chan)
{
	struct pciide_satalink *sl = sc->sc_cookie;

	return (bus_space_read_1(sc->sc_dma_iot,
	    sl->regs[chan].dma_iohs[IDEDMA_CMD(0)], 0));
}

void
sii3114_dmacmd_write(struct pciide_softc *sc, int chan, u_int8_t val)
{
	struct pciide_satalink *sl = sc->sc_cookie;

	bus_space_write_1(sc->sc_dma_iot,
	    sl->regs[chan].dma_iohs[IDEDMA_CMD(0)], 0, val);
}

u_int8_t
sii3114_dmactl_read(struct pciide_softc *sc, int chan)
{
	struct pciide_satalink *sl = sc->sc_cookie;

	return (bus_space_read_1(sc->sc_dma_iot,
	    sl->regs[chan].dma_iohs[IDEDMA_CTL(0)], 0));
}

void
sii3114_dmactl_write(struct pciide_softc *sc, int chan, u_int8_t val)
{
	struct pciide_satalink *sl = sc->sc_cookie;

	bus_space_write_1(sc->sc_dma_iot,
	    sl->regs[chan].dma_iohs[IDEDMA_CTL(0)], 0, val);
}

void
sii3114_dmatbl_write(struct pciide_softc *sc, int chan, u_int32_t val)
{
	struct pciide_satalink *sl = sc->sc_cookie;

	bus_space_write_4(sc->sc_dma_iot,
	    sl->regs[chan].dma_iohs[IDEDMA_TBL(0)], 0, val);
}

void
cy693_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;
	struct pciide_cy *cy;

	/* Allocate memory for private data */
	sc->sc_cookielen = sizeof(*cy);
	sc->sc_cookie = malloc(sc->sc_cookielen, M_DEVBUF, M_NOWAIT | M_ZERO);
	cy = sc->sc_cookie;

	/*
	 * this chip has 2 PCI IDE functions, one for primary and one for
	 * secondary. So we need to call pciide_mapregs_compat() with
	 * the real channel
	 */
	if (pa->pa_function == 1) {
		cy->cy_compatchan = 0;
	} else if (pa->pa_function == 2) {
		cy->cy_compatchan = 1;
	} else {
		printf(": unexpected PCI function %d\n", pa->pa_function);
		return;
	}

	if (interface & PCIIDE_INTERFACE_BUS_MASTER_DMA) {
		printf(": DMA");
		pciide_mapreg_dma(sc, pa);
	} else {
		printf(": no DMA");
		sc->sc_dma_ok = 0;
	}

	cy->cy_handle = cy82c693_init(pa->pa_iot);
	if (cy->cy_handle == NULL) {
		printf(", (unable to map ctl registers)");
		sc->sc_dma_ok = 0;
	}

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = cy693_setup_channel;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = 1;

	/* Only one channel for this chip; if we are here it's enabled */
	cp = &sc->pciide_channels[0];
	sc->wdc_chanarray[0] = &cp->wdc_channel;
	cp->name = PCIIDE_CHANNEL_NAME(0);
	cp->wdc_channel.channel = 0;
	cp->wdc_channel.wdc = &sc->sc_wdcdev;
	cp->wdc_channel.ch_queue = wdc_alloc_queue();
	if (cp->wdc_channel.ch_queue == NULL) {
		printf(": cannot allocate channel queue\n");
		return;
	}
	printf(", %s %s to ", PCIIDE_CHANNEL_NAME(0),
	    (interface & PCIIDE_INTERFACE_SETTABLE(0)) ?
	    "configured" : "wired");
	if (interface & PCIIDE_INTERFACE_PCI(0)) {
		printf("native-PCI\n");
		cp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize, &ctlsize,
		    pciide_pci_intr);
	} else {
		printf("compatibility\n");
		cp->hw_ok = pciide_mapregs_compat(pa, cp, cy->cy_compatchan,
		    &cmdsize, &ctlsize);
	}

	cp->wdc_channel.data32iot = cp->wdc_channel.cmd_iot;
	cp->wdc_channel.data32ioh = cp->wdc_channel.cmd_ioh;
	pciide_map_compat_intr(pa, cp, cy->cy_compatchan, interface);
	if (cp->hw_ok == 0)
		return;
	wdcattach(&cp->wdc_channel);
	if (pciide_chan_candisable(cp)) {
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    PCI_COMMAND_STATUS_REG, 0);
	}
	if (cp->hw_ok == 0) {
		pciide_unmap_compat_intr(pa, cp, cy->cy_compatchan,
		    interface);
		return;
	}

	WDCDEBUG_PRINT(("cy693_chip_map: old timings reg 0x%x\n",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL)), DEBUG_PROBE);
	cy693_setup_channel(&cp->wdc_channel);
	WDCDEBUG_PRINT(("cy693_chip_map: new timings reg 0x%x\n",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL)), DEBUG_PROBE);
}

void
cy693_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t cy_cmd_ctrl;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int dma_mode = -1;
	struct pciide_cy *cy = sc->sc_cookie;

	cy_cmd_ctrl = idedma_ctl = 0;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		if (drvp->drive_flags & DRIVE_DMA) {
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			/* use Multiword DMA */
			if (dma_mode == -1 || dma_mode > drvp->DMA_mode)
				dma_mode = drvp->DMA_mode;
		}
		cy_cmd_ctrl |= (cy_pio_pulse[drvp->PIO_mode] <<
		    CY_CMD_CTRL_IOW_PULSE_OFF(drive));
		cy_cmd_ctrl |= (cy_pio_rec[drvp->PIO_mode] <<
		    CY_CMD_CTRL_IOW_REC_OFF(drive));
		cy_cmd_ctrl |= (cy_pio_pulse[drvp->PIO_mode] <<
		    CY_CMD_CTRL_IOR_PULSE_OFF(drive));
		cy_cmd_ctrl |= (cy_pio_rec[drvp->PIO_mode] <<
		    CY_CMD_CTRL_IOR_REC_OFF(drive));
	}
	pci_conf_write(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL, cy_cmd_ctrl);
	chp->ch_drive[0].DMA_mode = dma_mode;
	chp->ch_drive[1].DMA_mode = dma_mode;

	if (dma_mode == -1)
		dma_mode = 0;

	if (cy->cy_handle != NULL) {
		/* Note: `multiple' is implied. */
		cy82c693_write(cy->cy_handle,
		    (cy->cy_compatchan == 0) ?
		    CY_DMA_IDX_PRIMARY : CY_DMA_IDX_SECONDARY, dma_mode);
	}

	pciide_print_modes(cp);

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
}

static struct sis_hostbr_type {
	u_int16_t id;
	u_int8_t rev;
	u_int8_t udma_mode;
	char *name;
	u_int8_t type;
#define SIS_TYPE_NOUDMA	0
#define SIS_TYPE_66	1
#define SIS_TYPE_100OLD	2
#define SIS_TYPE_100NEW 3
#define SIS_TYPE_133OLD 4
#define SIS_TYPE_133NEW 5
#define SIS_TYPE_SOUTH	6
} sis_hostbr_type[] = {
	/* Most infos here are from sos@@freebsd.org */
	{PCI_PRODUCT_SIS_530, 0x00, 4, "530", SIS_TYPE_66},
#if 0
	/*
	 * controllers associated to a rev 0x2 530 Host to PCI Bridge
	 * have problems with UDMA (info provided by Christos)
	 */
	{PCI_PRODUCT_SIS_530, 0x02, 0, "530 (buggy)", SIS_TYPE_NOUDMA},
#endif
	{PCI_PRODUCT_SIS_540, 0x00, 4, "540", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_550, 0x00, 4, "550", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_620, 0x00, 4, "620", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_630, 0x00, 4, "630", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_630, 0x30, 5, "630S", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_633, 0x00, 5, "633", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_635, 0x00, 5, "635", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_640, 0x00, 4, "640", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_645, 0x00, 6, "645", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_646, 0x00, 6, "645DX", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_648, 0x00, 6, "648", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_650, 0x00, 6, "650", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_651, 0x00, 6, "651", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_652, 0x00, 6, "652", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_655, 0x00, 6, "655", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_658, 0x00, 6, "658", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_661, 0x00, 6, "661", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_730, 0x00, 5, "730", SIS_TYPE_100OLD},
	{PCI_PRODUCT_SIS_733, 0x00, 5, "733", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_735, 0x00, 5, "735", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_740, 0x00, 5, "740", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_741, 0x00, 6, "741", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_745, 0x00, 5, "745", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_746, 0x00, 6, "746", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_748, 0x00, 6, "748", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_750, 0x00, 6, "750", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_751, 0x00, 6, "751", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_752, 0x00, 6, "752", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_755, 0x00, 6, "755", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_760, 0x00, 6, "760", SIS_TYPE_SOUTH},
	/*
	 * From sos@@freebsd.org: the 0x961 ID will never be found in real world
	 * {PCI_PRODUCT_SIS_961, 0x00, 6, "961", SIS_TYPE_133NEW},
	 */
	{PCI_PRODUCT_SIS_962, 0x00, 6, "962", SIS_TYPE_133NEW},
	{PCI_PRODUCT_SIS_963, 0x00, 6, "963", SIS_TYPE_133NEW},
	{PCI_PRODUCT_SIS_964, 0x00, 6, "964", SIS_TYPE_133NEW},
	{PCI_PRODUCT_SIS_965, 0x00, 6, "965", SIS_TYPE_133NEW},
	{PCI_PRODUCT_SIS_966, 0x00, 6, "966", SIS_TYPE_133NEW},
	{PCI_PRODUCT_SIS_968, 0x00, 6, "968", SIS_TYPE_133NEW}
};

static struct sis_hostbr_type *sis_hostbr_type_match;

int
sis_hostbr_match(struct pci_attach_args *pa)
{
	int i;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_SIS)
		return (0);
	sis_hostbr_type_match = NULL;
	for (i = 0;
	    i < sizeof(sis_hostbr_type) / sizeof(sis_hostbr_type[0]);
	    i++) {
		if (PCI_PRODUCT(pa->pa_id) == sis_hostbr_type[i].id &&
		    PCI_REVISION(pa->pa_class) >= sis_hostbr_type[i].rev)
			sis_hostbr_type_match = &sis_hostbr_type[i];
	}
	return (sis_hostbr_type_match != NULL);
}

int
sis_south_match(struct pci_attach_args *pa)
{
	return(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SIS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SIS_85C503 &&
	    PCI_REVISION(pa->pa_class) >= 0x10);
}

void
sis_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	u_int8_t sis_ctr0 = pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_CTRL0);
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	int rev = sc->sc_rev;
	bus_size_t cmdsize, ctlsize;
	struct pciide_sis *sis;

	/* Allocate memory for private data */
	sc->sc_cookielen = sizeof(*sis);
	sc->sc_cookie = malloc(sc->sc_cookielen, M_DEVBUF, M_NOWAIT | M_ZERO);
	sis = sc->sc_cookie;

	pci_find_device(NULL, sis_hostbr_match);

	if (sis_hostbr_type_match) {
		if (sis_hostbr_type_match->type == SIS_TYPE_SOUTH) {
			pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_57,
			    pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    SIS_REG_57) & 0x7f);
			if (sc->sc_pp->ide_product == SIS_PRODUCT_5518) {
				sis->sis_type = SIS_TYPE_133NEW;
				sc->sc_wdcdev.UDMA_cap =
				    sis_hostbr_type_match->udma_mode;
			} else {
				if (pci_find_device(NULL, sis_south_match)) {
					sis->sis_type = SIS_TYPE_133OLD;
					sc->sc_wdcdev.UDMA_cap =
					    sis_hostbr_type_match->udma_mode;
				} else {
					sis->sis_type = SIS_TYPE_100NEW;
					sc->sc_wdcdev.UDMA_cap =
					    sis_hostbr_type_match->udma_mode;
				}
			}
		} else {
			sis->sis_type = sis_hostbr_type_match->type;
			sc->sc_wdcdev.UDMA_cap =
			    sis_hostbr_type_match->udma_mode;
		}
		printf(": %s", sis_hostbr_type_match->name);
	} else {
		printf(": 5597/5598");
		if (rev >= 0xd0) {
			sc->sc_wdcdev.UDMA_cap = 2;
			sis->sis_type = SIS_TYPE_66;
		} else {
			sc->sc_wdcdev.UDMA_cap = 0;
			sis->sis_type = SIS_TYPE_NOUDMA;
		}
	}

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		if (sis->sis_type >= SIS_TYPE_66)
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
	}

	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	switch (sis->sis_type) {
	case SIS_TYPE_NOUDMA:
	case SIS_TYPE_66:
	case SIS_TYPE_100OLD:
		sc->sc_wdcdev.set_modes = sis_setup_channel;
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_MISC,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_MISC) |
		    SIS_MISC_TIM_SEL | SIS_MISC_FIFO_SIZE | SIS_MISC_GTC);
		break;
	case SIS_TYPE_100NEW:
	case SIS_TYPE_133OLD:
		sc->sc_wdcdev.set_modes = sis_setup_channel;
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_49,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_49) | 0x01);
		break;
	case SIS_TYPE_133NEW:
		sc->sc_wdcdev.set_modes = sis96x_setup_channel;
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_50,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_50) & 0xf7);
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_52,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_52) & 0xf7);
		break;
	}

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		if ((channel == 0 && (sis_ctr0 & SIS_CTRL0_CHAN0_EN) == 0) ||
		    (channel == 1 && (sis_ctr0 & SIS_CTRL0_CHAN1_EN) == 0)) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			cp->hw_ok = 0;
			continue;
		}
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		if (pciide_chan_candisable(cp)) {
			if (channel == 0)
				sis_ctr0 &= ~SIS_CTRL0_CHAN0_EN;
			else
				sis_ctr0 &= ~SIS_CTRL0_CHAN1_EN;
			pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_CTRL0,
			    sis_ctr0);
		}
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
}

void
sis96x_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t sis_tim;
	u_int32_t idedma_ctl;
	int regtim;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	sis_tim = 0;
	idedma_ctl = 0;
	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		regtim = SIS_TIM133(
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_57),
		    chp->channel, drive);
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			if (pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    SIS96x_REG_CBL(chp->channel)) & SIS96x_REG_CBL_33) {
				if (drvp->UDMA_mode > 2)
					drvp->UDMA_mode = 2;
			}
			sis_tim |= sis_udma133new_tim[drvp->UDMA_mode];
			sis_tim |= sis_pio133new_tim[drvp->PIO_mode];
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			/*
			 * use Multiword DMA
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode > (drvp->DMA_mode + 2))
				drvp->PIO_mode = drvp->DMA_mode + 2;
			if (drvp->DMA_mode + 2 > (drvp->PIO_mode))
				drvp->DMA_mode = (drvp->PIO_mode > 2) ?
				    drvp->PIO_mode - 2 : 0;
			sis_tim |= sis_dma133new_tim[drvp->DMA_mode];
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			sis_tim |= sis_pio133new_tim[drvp->PIO_mode];
		}
		WDCDEBUG_PRINT(("sis96x_setup_channel: new timings reg for "
		    "channel %d drive %d: 0x%x (reg 0x%x)\n",
		    chp->channel, drive, sis_tim, regtim), DEBUG_PROBE);
		pci_conf_write(sc->sc_pc, sc->sc_tag, regtim, sis_tim);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

void
sis_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t sis_tim;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct pciide_sis *sis = sc->sc_cookie;

	WDCDEBUG_PRINT(("sis_setup_channel: old timings reg for "
	    "channel %d 0x%x\n", chp->channel,
	    pci_conf_read(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel))),
	    DEBUG_PROBE);
	sis_tim = 0;
	idedma_ctl = 0;
	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		if ((drvp->drive_flags & DRIVE_DMA) == 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) == 0)
			goto pio;

		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			if (pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    SIS_REG_CBL) & SIS_REG_CBL_33(chp->channel)) {
				if (drvp->UDMA_mode > 2)
					drvp->UDMA_mode = 2;
			}
			switch (sis->sis_type) {
			case SIS_TYPE_66:
			case SIS_TYPE_100OLD:
				sis_tim |= sis_udma66_tim[drvp->UDMA_mode] <<
				    SIS_TIM66_UDMA_TIME_OFF(drive);
				break;
			case SIS_TYPE_100NEW:
				sis_tim |=
				    sis_udma100new_tim[drvp->UDMA_mode] <<
				    SIS_TIM100_UDMA_TIME_OFF(drive);
				break;
			case SIS_TYPE_133OLD:
				sis_tim |=
				    sis_udma133old_tim[drvp->UDMA_mode] <<
				    SIS_TIM100_UDMA_TIME_OFF(drive);
				break;
			default:
				printf("unknown SiS IDE type %d\n",
				    sis->sis_type);
			}
		} else {
			/*
			 * use Multiword DMA
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode > (drvp->DMA_mode + 2))
				drvp->PIO_mode = drvp->DMA_mode + 2;
			if (drvp->DMA_mode + 2 > (drvp->PIO_mode))
				drvp->DMA_mode = (drvp->PIO_mode > 2) ?
				    drvp->PIO_mode - 2 : 0;
			if (drvp->DMA_mode == 0)
				drvp->PIO_mode = 0;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
pio:		switch (sis->sis_type) {
		case SIS_TYPE_NOUDMA:
		case SIS_TYPE_66:
		case SIS_TYPE_100OLD:
			sis_tim |= sis_pio_act[drvp->PIO_mode] <<
			    SIS_TIM66_ACT_OFF(drive);
			sis_tim |= sis_pio_rec[drvp->PIO_mode] <<
			    SIS_TIM66_REC_OFF(drive);
			break;
		case SIS_TYPE_100NEW:
		case SIS_TYPE_133OLD:
			sis_tim |= sis_pio_act[drvp->PIO_mode] <<
			    SIS_TIM100_ACT_OFF(drive);
			sis_tim |= sis_pio_rec[drvp->PIO_mode] <<
			    SIS_TIM100_REC_OFF(drive);
			break;
		default:
			printf("unknown SiS IDE type %d\n",
			    sis->sis_type);
		}
	}
	WDCDEBUG_PRINT(("sis_setup_channel: new timings reg for "
	    "channel %d 0x%x\n", chp->channel, sis_tim), DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel), sis_tim);
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

void
natsemi_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface, ctl;
	bus_size_t cmdsize, ctlsize;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16;

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = natsemi_irqack;
	}

	pciide_pci_write(sc->sc_pc, sc->sc_tag, NATSEMI_CCBT, 0xb7);

	/*
	 * Mask off interrupts from both channels, appropriate channel(s)
	 * will be unmasked later.
	 */
	pciide_pci_write(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2) |
	    NATSEMI_CHMASK(0) | NATSEMI_CHMASK(1));

	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = natsemi_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag,
	    PCI_CLASS_REG));
	interface &= ~PCIIDE_CHANSTATUS_EN;	/* Reserved on PC87415 */
	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	/* If we're in PCIIDE mode, unmask INTA, otherwise mask it. */
	ctl = pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL1);
	if (interface & (PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1)))
		ctl &= ~NATSEMI_CTRL1_INTAMASK;
	else
		ctl |= NATSEMI_CTRL1_INTAMASK;
	pciide_pci_write(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL1, ctl);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;

		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    natsemi_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		natsemi_setup_channel(&cp->wdc_channel);
	}
}

void
natsemi_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, ndrives = 0;
	u_int32_t idedma_ctl = 0;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	u_int8_t tim;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		ndrives++;
		/* add timing values, setup DMA if needed */
		if ((drvp->drive_flags & DRIVE_DMA) == 0) {
			tim = natsemi_pio_pulse[drvp->PIO_mode] |
			    (natsemi_pio_recover[drvp->PIO_mode] << 4);
		} else {
			/*
			 * use Multiword DMA
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode >= 3 &&
			    (drvp->DMA_mode + 2) > drvp->PIO_mode) {
				drvp->DMA_mode = drvp->PIO_mode - 2;
			}
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			tim = natsemi_dma_pulse[drvp->DMA_mode] |
			    (natsemi_dma_recover[drvp->DMA_mode] << 4);
		}

		pciide_pci_write(sc->sc_pc, sc->sc_tag,
		    NATSEMI_RTREG(chp->channel, drive), tim);
		pciide_pci_write(sc->sc_pc, sc->sc_tag,
		    NATSEMI_WTREG(chp->channel, drive), tim);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
	if (ndrives > 0) {
		/* Unmask the channel if at least one drive is found */
		pciide_pci_write(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2) &
		    ~(NATSEMI_CHMASK(chp->channel)));
	}

	pciide_print_modes(cp);

	/* Go ahead and ack interrupts generated during probe. */
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(chp->channel),
	    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		IDEDMA_CTL(chp->channel)));
}

void
natsemi_irqack(struct channel_softc *chp)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	u_int8_t clr;

	/* The "clear" bits are in the wrong register *sigh* */
	clr = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(chp->channel));
	clr |= bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(chp->channel)) &
	    (IDEDMA_CTL_ERR | IDEDMA_CTL_INTR);
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(chp->channel), clr);
}

int
natsemi_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv;
	u_int8_t msk;

	rv = 0;
	msk = pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2);
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;

		/* If a compat channel skip. */
		if (cp->compat)
			continue;

		/* If this channel is masked, skip it. */
		if (msk & NATSEMI_CHMASK(i))
			continue;

		if (pciide_intr_flag(cp) == 0)
			continue;

		crv = wdcintr(wdc_cp);
		if (crv == 0)
			;		/* leave rv alone */
		else if (crv == 1)
			rv = 1;		/* claim the intr */
		else if (rv == 0)	/* crv should be -1 in this case */
			rv = crv;	/* if we've done no better, take it */
	}
	return (rv);
}

void
ns_scx200_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 2;

	sc->sc_wdcdev.set_modes = ns_scx200_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	/*
	 * Soekris net4801 errata 0003:
	 *
	 * The SC1100 built in busmaster IDE controller is pretty standard,
	 * but have two bugs: data transfers need to be dword aligned and
	 * it cannot do an exact 64Kbyte data transfer.
	 *
	 * Assume that reducing maximum segment size by one page
	 * will be enough, and restrict boundary too for extra certainty.
	 */
	if (sc->sc_pp->ide_product == PCI_PRODUCT_NS_SCx200_IDE) {
		sc->sc_dma_maxsegsz = IDEDMA_BYTE_COUNT_MAX - PAGE_SIZE;
		sc->sc_dma_boundary = IDEDMA_BYTE_COUNT_MAX - PAGE_SIZE;
	}

	/*
	 * This chip seems to be unable to do one-sector transfers
	 * using DMA.
	 */
	sc->sc_wdcdev.quirks = WDC_QUIRK_NOSHORTDMA;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
}

void
ns_scx200_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, mode;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	int pioformat;
	pcireg_t piotim, dmatim;

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;

	pioformat = (pci_conf_read(sc->sc_pc, sc->sc_tag,
	    SCx200_TIM_DMA(0, 0)) >> SCx200_PIOFORMAT_SHIFT) & 0x01;
	WDCDEBUG_PRINT(("%s: pio format %d\n", __func__, pioformat),
	    DEBUG_PROBE);

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		piotim = pci_conf_read(sc->sc_pc, sc->sc_tag,
		    SCx200_TIM_PIO(channel, drive));
		dmatim = pci_conf_read(sc->sc_pc, sc->sc_tag,
		    SCx200_TIM_DMA(channel, drive));
		WDCDEBUG_PRINT(("%s:%d:%d: piotim=0x%x, dmatim=0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, channel, drive,
		    piotim, dmatim), DEBUG_PROBE);

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			drvp->drive_flags &= ~DRIVE_DMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			dmatim = scx200_udma33[drvp->UDMA_mode];
			mode = drvp->PIO_mode;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			dmatim = scx200_dma33[drvp->DMA_mode];

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			mode = drvp->PIO_mode;
		}

		/* Setup PIO mode */
		drvp->PIO_mode = mode;
		if (mode < 2)
			drvp->DMA_mode = 0;
		else
			drvp->DMA_mode = mode - 2;

		piotim = scx200_pio33[pioformat][drvp->PIO_mode];

		WDCDEBUG_PRINT(("%s:%d:%d: new piotim=0x%x, dmatim=0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, channel, drive,
		    piotim, dmatim), DEBUG_PROBE);

		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    SCx200_TIM_PIO(channel, drive), piotim);
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    SCx200_TIM_DMA(channel, drive), dmatim);
	}

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}

	pciide_print_modes(cp);
}

void
acer_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t cr, interface;
	bus_size_t cmdsize, ctlsize;
	int rev = sc->sc_rev;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
		if (rev >= 0x20) {
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
			if (rev >= 0xC4)
				sc->sc_wdcdev.UDMA_cap = 5;
			else if (rev >= 0xC2)
				sc->sc_wdcdev.UDMA_cap = 4;
			else
				sc->sc_wdcdev.UDMA_cap = 2;
		}
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		if (rev <= 0xC4)
			sc->sc_wdcdev.dma_init = acer_dma_init;
	}

	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = acer_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CDRC,
	    (pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CDRC) |
		ACER_CDRC_DMA_EN) & ~ACER_CDRC_FIFO_DISABLE);

	/* Enable "microsoft register bits" R/W. */
	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR3,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR3) | ACER_CCAR3_PI);
	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR1,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR1) &
	    ~(ACER_CHANSTATUS_RO|PCIIDE_CHAN_RO(0)|PCIIDE_CHAN_RO(1)));
	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR2,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR2) &
	    ~ACER_CHANSTATUSREGS_RO);
	cr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG);
	cr |= (PCIIDE_CHANSTATUS_EN << PCI_INTERFACE_SHIFT);
	pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG, cr);
	/* Don't use cr, re-read the real register content instead */
	interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag,
	    PCI_CLASS_REG));

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	/* From linux: enable "Cable Detection" */
	if (rev >= 0xC2)
		pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_0x4B,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_0x4B)
		    | ACER_0x4B_CDETECT);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		if ((interface & PCIIDE_CHAN_EN(channel)) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			cp->hw_ok = 0;
			continue;
		}
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    (rev >= 0xC2) ? pciide_pci_intr : acer_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		if (pciide_chan_candisable(cp)) {
			cr &= ~(PCIIDE_CHAN_EN(channel) << PCI_INTERFACE_SHIFT);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PCI_CLASS_REG, cr);
		}
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		acer_setup_channel(&cp->wdc_channel);
	}
}

void
acer_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t acer_fifo_udma;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	idedma_ctl = 0;
	acer_fifo_udma = pci_conf_read(sc->sc_pc, sc->sc_tag, ACER_FTH_UDMA);
	WDCDEBUG_PRINT(("acer_setup_channel: old fifo/udma reg 0x%x\n",
	    acer_fifo_udma), DEBUG_PROBE);
	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	if ((chp->ch_drive[0].drive_flags | chp->ch_drive[1].drive_flags) &
	    DRIVE_UDMA)	{	/* check 80 pins cable */
		if (pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_0x4A) &
		    ACER_0x4A_80PIN(chp->channel)) {
			WDCDEBUG_PRINT(("%s:%d: 80-wire cable not detected\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel),
			    DEBUG_PROBE);
			if (chp->ch_drive[0].UDMA_mode > 2)
				chp->ch_drive[0].UDMA_mode = 2;
			if (chp->ch_drive[1].UDMA_mode > 2)
				chp->ch_drive[1].UDMA_mode = 2;
		}
	}

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		WDCDEBUG_PRINT(("acer_setup_channel: old timings reg for "
		    "channel %d drive %d 0x%x\n", chp->channel, drive,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag,
		    ACER_IDETIM(chp->channel, drive))), DEBUG_PROBE);
		/* clear FIFO/DMA mode */
		acer_fifo_udma &= ~(ACER_FTH_OPL(chp->channel, drive, 0x3) |
		    ACER_UDMA_EN(chp->channel, drive) |
		    ACER_UDMA_TIM(chp->channel, drive, 0x7));

		/* add timing values, setup DMA if needed */
		if ((drvp->drive_flags & DRIVE_DMA) == 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) == 0) {
			acer_fifo_udma |=
			    ACER_FTH_OPL(chp->channel, drive, 0x1);
			goto pio;
		}

		acer_fifo_udma |= ACER_FTH_OPL(chp->channel, drive, 0x2);
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			acer_fifo_udma |= ACER_UDMA_EN(chp->channel, drive);
			acer_fifo_udma |=
			    ACER_UDMA_TIM(chp->channel, drive,
				acer_udma[drvp->UDMA_mode]);
			/* XXX disable if one drive < UDMA3 ? */
			if (drvp->UDMA_mode >= 3) {
				pciide_pci_write(sc->sc_pc, sc->sc_tag,
				    ACER_0x4B,
				    pciide_pci_read(sc->sc_pc, sc->sc_tag,
				    ACER_0x4B) | ACER_0x4B_UDMA66);
			}
		} else {
			/*
			 * use Multiword DMA
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode > (drvp->DMA_mode + 2))
				drvp->PIO_mode = drvp->DMA_mode + 2;
			if (drvp->DMA_mode + 2 > (drvp->PIO_mode))
				drvp->DMA_mode = (drvp->PIO_mode > 2) ?
				    drvp->PIO_mode - 2 : 0;
			if (drvp->DMA_mode == 0)
				drvp->PIO_mode = 0;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
pio:		pciide_pci_write(sc->sc_pc, sc->sc_tag,
		    ACER_IDETIM(chp->channel, drive),
		    acer_pio[drvp->PIO_mode]);
	}
	WDCDEBUG_PRINT(("acer_setup_channel: new fifo/udma reg 0x%x\n",
	    acer_fifo_udma), DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, ACER_FTH_UDMA, acer_fifo_udma);
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

int
acer_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv;
	u_int32_t chids;

	rv = 0;
	chids = pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CHIDS);
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		/* If a compat channel skip. */
		if (cp->compat)
			continue;
		if (chids & ACER_CHIDS_INT(i)) {
			crv = wdcintr(wdc_cp);
			if (crv == 0)
				printf("%s:%d: bogus intr\n",
				    sc->sc_wdcdev.sc_dev.dv_xname, i);
			else
				rv = 1;
		}
	}
	return (rv);
}

int
acer_dma_init(void *v, int channel, int drive, void *databuf,
    size_t datalen, int flags)
{
	/* Use PIO for LBA48 transfers. */
	if (flags & WDC_DMA_LBA48)
		return (EINVAL);

	return (pciide_dma_init(v, channel, drive, databuf, datalen, flags));
}

void
hpt_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int i, compatchan, revision;
	pcireg_t interface;
	bus_size_t cmdsize, ctlsize;

	revision = sc->sc_rev;

	/*
	 * when the chip is in native mode it identifies itself as a
	 * 'misc mass storage'. Fake interface in this case.
	 */
	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCI_INTERFACE(pa->pa_class);
	} else {
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0);
		if ((sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
		   (revision == HPT370_REV || revision == HPT370A_REV ||
		    revision == HPT372_REV)) ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT302 ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT371 ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374)
			interface |= PCIIDE_INTERFACE_PCI(1);
	}

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;

	sc->sc_wdcdev.set_modes = hpt_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
	    revision == HPT366_REV) {
		sc->sc_wdcdev.UDMA_cap = 4;
		/*
		 * The 366 has 2 PCI IDE functions, one for primary and one
		 * for secondary. So we need to call pciide_mapregs_compat()
		 * with the real channel
		 */
		if (pa->pa_function == 0) {
			compatchan = 0;
		} else if (pa->pa_function == 1) {
			compatchan = 1;
		} else {
			printf("%s: unexpected PCI function %d\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, pa->pa_function);
			return;
		}
		sc->sc_wdcdev.nchannels = 1;
	} else {
		sc->sc_wdcdev.nchannels = 2;
		if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT302 ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT371 ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374)
			sc->sc_wdcdev.UDMA_cap = 6;
		else if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366) {
			if (revision == HPT372_REV)
				sc->sc_wdcdev.UDMA_cap = 6;
			else
				sc->sc_wdcdev.UDMA_cap = 5;
		}
	}
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		compatchan = 0;
		if (sc->sc_wdcdev.nchannels > 1) {
			compatchan = i;
			if((pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    HPT370_CTRL1(i)) & HPT370_CTRL1_EN) == 0) {
				printf("%s: %s ignored (disabled)\n",
				    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
				cp->hw_ok = 0;
				continue;
			}
		}
		if (pciide_chansetup(sc, i, interface) == 0)
			continue;
		if (interface & PCIIDE_INTERFACE_PCI(i)) {
			cp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize,
			    &ctlsize, hpt_pci_intr);
		} else {
			cp->hw_ok = pciide_mapregs_compat(pa, cp, compatchan,
			    &cmdsize, &ctlsize);
		}
		if (cp->hw_ok == 0)
			return;
		cp->wdc_channel.data32iot = cp->wdc_channel.cmd_iot;
		cp->wdc_channel.data32ioh = cp->wdc_channel.cmd_ioh;
		wdcattach(&cp->wdc_channel);
		hpt_setup_channel(&cp->wdc_channel);
	}
	if ((sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
	    (revision == HPT370_REV || revision == HPT370A_REV ||
	    revision == HPT372_REV)) ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT302 ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT371 ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374) {
		/*
		 * Turn off fast interrupts
		 */
		pciide_pci_write(sc->sc_pc, sc->sc_tag, HPT370_CTRL2(0),
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT370_CTRL2(0)) &
		    ~(HPT370_CTRL2_FASTIRQ | HPT370_CTRL2_HIRQ));
		pciide_pci_write(sc->sc_pc, sc->sc_tag, HPT370_CTRL2(1),
		pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT370_CTRL2(1)) &
		~(HPT370_CTRL2_FASTIRQ | HPT370_CTRL2_HIRQ));

		/*
		 * HPT370 and highter has a bit to disable interrupts,
		 * make sure to clear it
		 */
		pciide_pci_write(sc->sc_pc, sc->sc_tag, HPT_CSEL,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT_CSEL) &
		    ~HPT_CSEL_IRQDIS);
	}
	/* set clocks, etc (mandatory on 372/4, optional otherwise) */
	if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT302 ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT371 ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374 ||
	    (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
	    revision == HPT372_REV))
		pciide_pci_write(sc->sc_pc, sc->sc_tag, HPT_SC2,
		    (pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT_SC2) &
		     HPT_SC2_MAEN) | HPT_SC2_OSC_EN);

	return;
}

void
hpt_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	int cable;
	u_int32_t before, after;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int revision = sc->sc_rev;
	u_int32_t *tim_pio, *tim_dma, *tim_udma;

	cable = pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT_CSEL);

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;

	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_TRIONES_HPT366:
		if (revision == HPT370_REV ||
		    revision == HPT370A_REV) {
			tim_pio = hpt370_pio;
			tim_dma = hpt370_dma;
			tim_udma = hpt370_udma;
		} else if (revision == HPT372_REV) {
			tim_pio = hpt372_pio;
			tim_dma = hpt372_dma;
			tim_udma = hpt372_udma;
		} else {
			tim_pio = hpt366_pio;
			tim_dma = hpt366_dma;
			tim_udma = hpt366_udma;
		}
		break;
	case PCI_PRODUCT_TRIONES_HPT372A:
	case PCI_PRODUCT_TRIONES_HPT302:
	case PCI_PRODUCT_TRIONES_HPT371:
		tim_pio = hpt372_pio;
		tim_dma = hpt372_dma;
		tim_udma = hpt372_udma;
		break;
	case PCI_PRODUCT_TRIONES_HPT374:
		tim_pio = hpt374_pio;
		tim_dma = hpt374_dma;
		tim_udma = hpt374_udma;
		break;
	default:
		printf("%s: no known timing values\n",
		    sc->sc_wdcdev.sc_dev.dv_xname);
		goto end;
	}

	/* Per drive settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		before = pci_conf_read(sc->sc_pc, sc->sc_tag,
				       HPT_IDETIM(chp->channel, drive));

		/* add timing values, setup DMA if needed */
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			if ((cable & HPT_CSEL_CBLID(chp->channel)) != 0 &&
			    drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    chp->channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}
			after = tim_udma[drvp->UDMA_mode];
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			/*
			 * use Multiword DMA.
			 * Timings will be used for both PIO and DMA, so adjust
			 * DMA mode if needed
			 */
			if (drvp->PIO_mode >= 3 &&
			    (drvp->DMA_mode + 2) > drvp->PIO_mode) {
				drvp->DMA_mode = drvp->PIO_mode - 2;
			}
			after = tim_dma[drvp->DMA_mode];
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			/* PIO only */
			after = tim_pio[drvp->PIO_mode];
		}
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    HPT_IDETIM(chp->channel, drive), after);
		WDCDEBUG_PRINT(("%s: bus speed register set to 0x%08x "
		    "(BIOS 0x%08x)\n", sc->sc_wdcdev.sc_dev.dv_xname,
		    after, before), DEBUG_PROBE);
	}
end:
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

int
hpt_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int rv = 0;
	int dmastat, i, crv;

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(i));
		if((dmastat & (IDEDMA_CTL_ACT | IDEDMA_CTL_INTR)) !=
		    IDEDMA_CTL_INTR)
		    continue;
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		crv = wdcintr(wdc_cp);
		if (crv == 0) {
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
			bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
			    IDEDMA_CTL(i), dmastat);
		} else
			rv = 1;
	}
	return (rv);
}

/* Macros to test product */
#define PDC_IS_262(sc)							\
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20262 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20265  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267)
#define PDC_IS_265(sc)							\
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20265 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268R ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20271  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20275  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277)
#define PDC_IS_268(sc)							\
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268R ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20271  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20275  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277)
#define PDC_IS_269(sc)							\
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20271  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20275  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277)

u_int8_t
pdc268_config_read(struct channel_softc *chp, int index)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;

	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_INDEX(channel), index);
	return (bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_DATA(channel)));
}

void
pdc202xx_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface, st, mode;
	bus_size_t cmdsize, ctlsize;

	if (!PDC_IS_268(sc)) {
		st = pci_conf_read(sc->sc_pc, sc->sc_tag, PDC2xx_STATE);
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: controller state 0x%x\n",
		    st), DEBUG_PROBE);
	}

	/* turn off  RAID mode */
	if (!PDC_IS_268(sc))
		st &= ~PDC2xx_STATE_IDERAID;

	/*
 	 * can't rely on the PCI_CLASS_REG content if the chip was in raid
	 * mode. We have to fake interface
	 */
	interface = PCIIDE_INTERFACE_SETTABLE(0) | PCIIDE_INTERFACE_SETTABLE(1);
	if (PDC_IS_268(sc) || (st & PDC2xx_STATE_NATIVE))
		interface |= PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20246 ||
	    PDC_IS_262(sc))
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_NO_ATAPI_DMA;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	if (PDC_IS_269(sc))
		sc->sc_wdcdev.UDMA_cap = 6;
	else if (PDC_IS_265(sc))
		sc->sc_wdcdev.UDMA_cap = 5;
	else if (PDC_IS_262(sc))
		sc->sc_wdcdev.UDMA_cap = 4;
	else
		sc->sc_wdcdev.UDMA_cap = 2;
	sc->sc_wdcdev.set_modes = PDC_IS_268(sc) ?
	    pdc20268_setup_channel : pdc202xx_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	if (PDC_IS_262(sc)) {
		sc->sc_wdcdev.dma_start = pdc20262_dma_start;
		sc->sc_wdcdev.dma_finish = pdc20262_dma_finish;
	}

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);
	if (!PDC_IS_268(sc)) {
		/* setup failsafe defaults */
		mode = 0;
		mode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[0]);
		mode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[0]);
		mode = PDC2xx_TIM_SET_MB(mode, pdc2xx_dma_mb[0]);
		mode = PDC2xx_TIM_SET_MC(mode, pdc2xx_dma_mc[0]);
		for (channel = 0;
		     channel < sc->sc_wdcdev.nchannels;
		     channel++) {
			WDCDEBUG_PRINT(("pdc202xx_setup_chip: channel %d "
			    "drive 0 initial timings  0x%x, now 0x%x\n",
			    channel, pci_conf_read(sc->sc_pc, sc->sc_tag,
			    PDC2xx_TIM(channel, 0)), mode | PDC2xx_TIM_IORDYp),
			    DEBUG_PROBE);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PDC2xx_TIM(channel, 0), mode | PDC2xx_TIM_IORDYp);
			WDCDEBUG_PRINT(("pdc202xx_setup_chip: channel %d "
			    "drive 1 initial timings  0x%x, now 0x%x\n",
			    channel, pci_conf_read(sc->sc_pc, sc->sc_tag,
	 		    PDC2xx_TIM(channel, 1)), mode), DEBUG_PROBE);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PDC2xx_TIM(channel, 1), mode);
		}

		mode = PDC2xx_SCR_DMA;
		if (PDC_IS_262(sc)) {
			mode = PDC2xx_SCR_SET_GEN(mode, PDC262_SCR_GEN_LAT);
		} else {
			/* the BIOS set it up this way */
			mode = PDC2xx_SCR_SET_GEN(mode, 0x1);
		}
		mode = PDC2xx_SCR_SET_I2C(mode, 0x3); /* ditto */
		mode = PDC2xx_SCR_SET_POLL(mode, 0x1); /* ditto */
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: initial SCR  0x%x, "
		    "now 0x%x\n",
		    bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh,
			PDC2xx_SCR),
		    mode), DEBUG_PROBE);
		bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC2xx_SCR, mode);

		/* controller initial state register is OK even without BIOS */
		/* Set DMA mode to IDE DMA compatibility */
		mode =
		    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM);
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: primary mode 0x%x", mode),
		    DEBUG_PROBE);
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM,
		    mode | 0x1);
		mode =
		    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM);
		WDCDEBUG_PRINT((", secondary mode 0x%x\n", mode ), DEBUG_PROBE);
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM,
		    mode | 0x1);
	}

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		if (!PDC_IS_268(sc) && (st & (PDC_IS_262(sc) ?
		    PDC262_STATE_EN(channel):PDC246_STATE_EN(channel))) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			cp->hw_ok = 0;
			continue;
		}
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		if (PDC_IS_265(sc))
			pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
			    pdc20265_pci_intr);
		else
			pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
			    pdc202xx_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		if (!PDC_IS_268(sc) && pciide_chan_candisable(cp)) {
			st &= ~(PDC_IS_262(sc) ?
			    PDC262_STATE_EN(channel):PDC246_STATE_EN(channel));
			pciide_unmap_compat_intr(pa, cp, channel, interface);
		}
		if (PDC_IS_268(sc))
			pdc20268_setup_channel(&cp->wdc_channel);
		else
			pdc202xx_setup_channel(&cp->wdc_channel);
	}
	if (!PDC_IS_268(sc)) {
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: new controller state "
		    "0x%x\n", st), DEBUG_PROBE);
		pci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_STATE, st);
	}
	return;
}

void
pdc202xx_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	pcireg_t mode, st;
	u_int32_t idedma_ctl, scr, atapi;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;
	WDCDEBUG_PRINT(("pdc202xx_setup_channel %s: scr 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname,
	    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC262_U66)),
	    DEBUG_PROBE);

	/* Per channel settings */
	if (PDC_IS_262(sc)) {
		scr = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_U66);
		st = pci_conf_read(sc->sc_pc, sc->sc_tag, PDC2xx_STATE);
		/* Check cable */
		if ((st & PDC262_STATE_80P(channel)) != 0 &&
		    ((chp->ch_drive[0].drive_flags & DRIVE_UDMA &&
		    chp->ch_drive[0].UDMA_mode > 2) ||
		    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&
		    chp->ch_drive[1].UDMA_mode > 2))) {
			WDCDEBUG_PRINT(("%s:%d: 80-wire cable not detected\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, channel),
			    DEBUG_PROBE);
			if (chp->ch_drive[0].UDMA_mode > 2)
				chp->ch_drive[0].UDMA_mode = 2;
			if (chp->ch_drive[1].UDMA_mode > 2)
				chp->ch_drive[1].UDMA_mode = 2;
		}
		/* Trim UDMA mode */
		if ((chp->ch_drive[0].drive_flags & DRIVE_UDMA &&
		    chp->ch_drive[0].UDMA_mode <= 2) ||
		    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&
		    chp->ch_drive[1].UDMA_mode <= 2)) {
			if (chp->ch_drive[0].UDMA_mode > 2)
				chp->ch_drive[0].UDMA_mode = 2;
			if (chp->ch_drive[1].UDMA_mode > 2)
				chp->ch_drive[1].UDMA_mode = 2;
		}
		/* Set U66 if needed */
		if ((chp->ch_drive[0].drive_flags & DRIVE_UDMA &&
		    chp->ch_drive[0].UDMA_mode > 2) ||
		    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&
		    chp->ch_drive[1].UDMA_mode > 2))
			scr |= PDC262_U66_EN(channel);
		else
			scr &= ~PDC262_U66_EN(channel);
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_U66, scr);
		WDCDEBUG_PRINT(("pdc202xx_setup_channel %s:%d: ATAPI 0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, channel,
		    bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_ATAPI(channel))), DEBUG_PROBE);
		if (chp->ch_drive[0].drive_flags & DRIVE_ATAPI ||
		    chp->ch_drive[1].drive_flags & DRIVE_ATAPI) {
			if (((chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&
			    !(chp->ch_drive[1].drive_flags & DRIVE_UDMA) &&
			    (chp->ch_drive[1].drive_flags & DRIVE_DMA)) ||
			    ((chp->ch_drive[1].drive_flags & DRIVE_UDMA) &&
			    !(chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&
			    (chp->ch_drive[0].drive_flags & DRIVE_DMA)))
				atapi = 0;
			else
				atapi = PDC262_ATAPI_UDMA;
			bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
			    PDC262_ATAPI(channel), atapi);
		}
	}
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		mode = 0;
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			mode = PDC2xx_TIM_SET_MB(mode,
			   pdc2xx_udma_mb[drvp->UDMA_mode]);
			mode = PDC2xx_TIM_SET_MC(mode,
			   pdc2xx_udma_mc[drvp->UDMA_mode]);
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			mode = PDC2xx_TIM_SET_MB(mode,
			    pdc2xx_dma_mb[drvp->DMA_mode]);
			mode = PDC2xx_TIM_SET_MC(mode,
			   pdc2xx_dma_mc[drvp->DMA_mode]);
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			mode = PDC2xx_TIM_SET_MB(mode,
			    pdc2xx_dma_mb[0]);
			mode = PDC2xx_TIM_SET_MC(mode,
			    pdc2xx_dma_mc[0]);
		}
		mode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[drvp->PIO_mode]);
		mode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[drvp->PIO_mode]);
		if (drvp->drive_flags & DRIVE_ATA)
			mode |= PDC2xx_TIM_PRE;
		mode |= PDC2xx_TIM_SYNC | PDC2xx_TIM_ERRDY;
		if (drvp->PIO_mode >= 3) {
			mode |= PDC2xx_TIM_IORDY;
			if (drive == 0)
				mode |= PDC2xx_TIM_IORDYp;
		}
		WDCDEBUG_PRINT(("pdc202xx_setup_channel: %s:%d:%d "
		    "timings 0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname,
		    chp->channel, drive, mode), DEBUG_PROBE);
		    pci_conf_write(sc->sc_pc, sc->sc_tag,
		    PDC2xx_TIM(chp->channel, drive), mode);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

void
pdc20268_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, cable;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;

	/* check 80 pins cable */
	cable = pdc268_config_read(chp, 0x0b) & PDC268_CABLE;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			if (cable && drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}
		} else if (drvp->drive_flags & DRIVE_DMA) {
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		}
	}
	/* nothing to do to setup modes, the controller snoop SET_FEATURE cmd */
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

int
pdc202xx_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv;
	u_int32_t scr;

	rv = 0;
	scr = bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SCR);
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		/* If a compat channel skip. */
		if (cp->compat)
			continue;
		if (scr & PDC2xx_SCR_INT(i)) {
			crv = wdcintr(wdc_cp);
			if (crv == 0)
				printf("%s:%d: bogus intr (reg 0x%x)\n",
				    sc->sc_wdcdev.sc_dev.dv_xname, i, scr);
			else
				rv = 1;
		}
	}
	return (rv);
}

int
pdc20265_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv;
	u_int32_t dmastat;

	rv = 0;
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		/* If a compat channel skip. */
		if (cp->compat)
			continue;

		/*
		 * In case of shared IRQ check that the interrupt
		 * was actually generated by this channel.
		 * Only check the channel that is enabled.
		 */
		if (cp->hw_ok && PDC_IS_268(sc)) {
			if ((pdc268_config_read(wdc_cp,
			    0x0b) & PDC268_INTR) == 0)
				continue;
		}

		/*
		 * The Ultra/100 seems to assert PDC2xx_SCR_INT * spuriously,
		 * however it asserts INT in IDEDMA_CTL even for non-DMA ops.
		 * So use it instead (requires 2 reg reads instead of 1,
		 * but we can't do it another way).
		 */
		dmastat = bus_space_read_1(sc->sc_dma_iot,
		    sc->sc_dma_ioh, IDEDMA_CTL(i));
		if ((dmastat & IDEDMA_CTL_INTR) == 0)
			continue;

		crv = wdcintr(wdc_cp);
		if (crv == 0)
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
		else
			rv = 1;
	}
	return (rv);
}

void
pdc20262_dma_start(void *v, int channel, int drive)
{
	struct pciide_softc *sc = v;
	struct pciide_dma_maps *dma_maps =
	    &sc->pciide_channels[channel].dma_maps[drive];
	u_int8_t clock;
	u_int32_t count;

	if (dma_maps->dma_flags & WDC_DMA_LBA48) {
		clock = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_U66);
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_U66, clock | PDC262_U66_EN(channel));
		count = dma_maps->dmamap_xfer->dm_mapsize >> 1;
		count |= dma_maps->dma_flags & WDC_DMA_READ ?
		    PDC262_ATAPI_LBA48_READ : PDC262_ATAPI_LBA48_WRITE;
		bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_ATAPI(channel), count);
	}

	pciide_dma_start(v, channel, drive);
}

int
pdc20262_dma_finish(void *v, int channel, int drive, int force)
{
	struct pciide_softc *sc = v;
	struct pciide_dma_maps *dma_maps =
	    &sc->pciide_channels[channel].dma_maps[drive];
 	u_int8_t clock;

	if (dma_maps->dma_flags & WDC_DMA_LBA48) {
		clock = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_U66);
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_U66, clock & ~PDC262_U66_EN(channel));
		bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_ATAPI(channel), 0);
	}

	return (pciide_dma_finish(v, channel, drive, force));
}

void
pdcsata_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	struct pciide_pdcsata *ps;
	int channel, i;
	bus_size_t dmasize;
	pci_intr_handle_t intrhandle;
	const char *intrstr;

	/* Allocate memory for private data */
	sc->sc_cookielen = sizeof(*ps);
	sc->sc_cookie = malloc(sc->sc_cookielen, M_DEVBUF, M_NOWAIT | M_ZERO);
	ps = sc->sc_cookie;

	/*
	 * Promise SATA controllers have 3 or 4 channels,
	 * the usual IDE registers are mapped in I/O space, with offsets.
	 */
	if (pci_intr_map(pa, &intrhandle) != 0) {
		printf(": couldn't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, intrhandle);

	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_PROMISE_PDC20318:
	case PCI_PRODUCT_PROMISE_PDC20319:
	case PCI_PRODUCT_PROMISE_PDC20371:
	case PCI_PRODUCT_PROMISE_PDC20375:
	case PCI_PRODUCT_PROMISE_PDC20376:
	case PCI_PRODUCT_PROMISE_PDC20377:
	case PCI_PRODUCT_PROMISE_PDC20378:
	case PCI_PRODUCT_PROMISE_PDC20379:
	default:
		sc->sc_pci_ih = pci_intr_establish(pa->pa_pc,
	    	    intrhandle, IPL_BIO, pdc203xx_pci_intr, sc,
	    	    sc->sc_wdcdev.sc_dev.dv_xname);
		break;

	case PCI_PRODUCT_PROMISE_PDC40518:
	case PCI_PRODUCT_PROMISE_PDC40519:
	case PCI_PRODUCT_PROMISE_PDC40718:
	case PCI_PRODUCT_PROMISE_PDC40719:
	case PCI_PRODUCT_PROMISE_PDC40779:
	case PCI_PRODUCT_PROMISE_PDC20571:
	case PCI_PRODUCT_PROMISE_PDC20575:
	case PCI_PRODUCT_PROMISE_PDC20579:
	case PCI_PRODUCT_PROMISE_PDC20771:
	case PCI_PRODUCT_PROMISE_PDC20775:
		sc->sc_pci_ih = pci_intr_establish(pa->pa_pc,
	    	    intrhandle, IPL_BIO, pdc205xx_pci_intr, sc,
	    	    sc->sc_wdcdev.sc_dev.dv_xname);
		break;
	}
		
	if (sc->sc_pci_ih == NULL) {
		printf(": couldn't establish native-PCI interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}

	sc->sc_dma_ok = (pci_mapreg_map(pa, PCIIDE_REG_BUS_MASTER_DMA,
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->sc_dma_iot,
	    &sc->sc_dma_ioh, NULL, &dmasize, 0) == 0);
	if (!sc->sc_dma_ok) {
		printf(": couldn't map bus-master DMA registers\n");
		pci_intr_disestablish(pa->pa_pc, sc->sc_pci_ih);
		return;
	}

	sc->sc_dmat = pa->pa_dmat;

	if (pci_mapreg_map(pa, PDC203xx_BAR_IDEREGS,
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &ps->ba5_st,
	    &ps->ba5_sh, NULL, NULL, 0) != 0) {
		printf(": couldn't map IDE registers\n");
		bus_space_unmap(sc->sc_dma_iot, sc->sc_dma_ioh, dmasize);
		pci_intr_disestablish(pa->pa_pc, sc->sc_pci_ih);
		return;
	}

	printf(": DMA\n");

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
	sc->sc_wdcdev.irqack = pdc203xx_irqack;
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 6;
	sc->sc_wdcdev.set_modes = pdc203xx_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;

	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_PROMISE_PDC20318:
	case PCI_PRODUCT_PROMISE_PDC20319:
	case PCI_PRODUCT_PROMISE_PDC20371:
	case PCI_PRODUCT_PROMISE_PDC20375:
	case PCI_PRODUCT_PROMISE_PDC20376:
	case PCI_PRODUCT_PROMISE_PDC20377:
	case PCI_PRODUCT_PROMISE_PDC20378:
	case PCI_PRODUCT_PROMISE_PDC20379:
	default:
		bus_space_write_4(ps->ba5_st, ps->ba5_sh, 0x06c, 0x00ff0033);
		sc->sc_wdcdev.nchannels =
		    (bus_space_read_4(ps->ba5_st, ps->ba5_sh, 0x48) & 0x02) ?
		    PDC203xx_NCHANNELS : 3;
		break;

	case PCI_PRODUCT_PROMISE_PDC40518:
	case PCI_PRODUCT_PROMISE_PDC40519:
	case PCI_PRODUCT_PROMISE_PDC40718:
	case PCI_PRODUCT_PROMISE_PDC40719:
	case PCI_PRODUCT_PROMISE_PDC40779:
	case PCI_PRODUCT_PROMISE_PDC20571:
		bus_space_write_4(ps->ba5_st, ps->ba5_sh, 0x60, 0x00ff00ff);
		sc->sc_wdcdev.nchannels = PDC40718_NCHANNELS;
  	 
		sc->sc_wdcdev.reset = pdc205xx_do_reset;
		sc->sc_wdcdev.drv_probe = pdc205xx_drv_probe;
		
		break;
	case PCI_PRODUCT_PROMISE_PDC20575:
	case PCI_PRODUCT_PROMISE_PDC20579:
	case PCI_PRODUCT_PROMISE_PDC20771:
	case PCI_PRODUCT_PROMISE_PDC20775:
		bus_space_write_4(ps->ba5_st, ps->ba5_sh, 0x60, 0x00ff00ff);
		sc->sc_wdcdev.nchannels = PDC20575_NCHANNELS;

		sc->sc_wdcdev.reset = pdc205xx_do_reset;
		sc->sc_wdcdev.drv_probe = pdc205xx_drv_probe;
		
		break;
	}

	sc->sc_wdcdev.dma_arg = sc;
	sc->sc_wdcdev.dma_init = pciide_dma_init;
	sc->sc_wdcdev.dma_start = pdc203xx_dma_start;
	sc->sc_wdcdev.dma_finish = pdc203xx_dma_finish;

	for (channel = 0; channel < sc->sc_wdcdev.nchannels;
	     channel++) {
		cp = &sc->pciide_channels[channel];
		sc->wdc_chanarray[channel] = &cp->wdc_channel;

		cp->ih = sc->sc_pci_ih;
		cp->name = NULL;
		cp->wdc_channel.channel = channel;
		cp->wdc_channel.wdc = &sc->sc_wdcdev;
		cp->wdc_channel.ch_queue = wdc_alloc_queue();
		if (cp->wdc_channel.ch_queue == NULL) {
			printf("%s: channel %d: "
			    "cannot allocate channel queue\n",
			sc->sc_wdcdev.sc_dev.dv_xname, channel);
			continue;
		}
		wdc_cp = &cp->wdc_channel;

		ps->regs[channel].ctl_iot = ps->ba5_st;
		ps->regs[channel].cmd_iot = ps->ba5_st;

		if (bus_space_subregion(ps->ba5_st, ps->ba5_sh,
		    0x0238 + (channel << 7), 1,
		    &ps->regs[channel].ctl_ioh) != 0) {
			printf("%s: couldn't map channel %d ctl regs\n",
			    sc->sc_wdcdev.sc_dev.dv_xname,
			    channel);
			continue;
		}
		for (i = 0; i < WDC_NREG; i++) {
			if (bus_space_subregion(ps->ba5_st, ps->ba5_sh,
			    0x0200 + (i << 2) + (channel << 7), i == 0 ? 4 : 1,
			    &ps->regs[channel].cmd_iohs[i]) != 0) {
				printf("%s: couldn't map channel %d cmd "
				    "regs\n",
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel);
				goto loop_end;
			}
		}
		ps->regs[channel].cmd_iohs[wdr_status & _WDC_REGMASK] =
		    ps->regs[channel].cmd_iohs[wdr_command & _WDC_REGMASK];
		ps->regs[channel].cmd_iohs[wdr_features & _WDC_REGMASK] =
		    ps->regs[channel].cmd_iohs[wdr_error & _WDC_REGMASK];
		wdc_cp->data32iot = wdc_cp->cmd_iot =
		    ps->regs[channel].cmd_iot;
		wdc_cp->data32ioh = wdc_cp->cmd_ioh =
		    ps->regs[channel].cmd_iohs[0];
		wdc_cp->_vtbl = &wdc_pdc203xx_vtbl;

		/*
		 * Subregion de busmaster registers. They're spread all over
		 * the controller's register space :(. They are also 4 bytes
		 * sized, with some specific extentions in the extra bits.
		 * It also seems that the IDEDMA_CTL register isn't available.
		 */
		if (bus_space_subregion(ps->ba5_st, ps->ba5_sh,
		    0x260 + (channel << 7), 1,
		    &ps->regs[channel].dma_iohs[IDEDMA_CMD(0)]) != 0) {
			printf("%s channel %d: can't subregion DMA "
			    "registers\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, channel);
			continue;
		}
		if (bus_space_subregion(ps->ba5_st, ps->ba5_sh,
		    0x244 + (channel << 7), 4,
		    &ps->regs[channel].dma_iohs[IDEDMA_TBL(0)]) != 0) {
			printf("%s channel %d: can't subregion DMA "
			    "registers\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, channel);
			continue;
		}

		wdcattach(wdc_cp);
		bus_space_write_4(sc->sc_dma_iot,
		    ps->regs[channel].dma_iohs[IDEDMA_CMD(0)], 0,
		    (bus_space_read_4(sc->sc_dma_iot,
			ps->regs[channel].dma_iohs[IDEDMA_CMD(0)],
			0) & ~0x00003f9f) | (channel + 1));
		bus_space_write_4(ps->ba5_st, ps->ba5_sh,
		    (channel + 1) << 2, 0x00000001);

		pdc203xx_setup_channel(&cp->wdc_channel);

loop_end: ;
	}

	printf("%s: using %s for native-PCI interrupt\n",
	    sc->sc_wdcdev.sc_dev.dv_xname,
	    intrstr ? intrstr : "unknown interrupt");
}

void
pdc203xx_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	int drive, s;

	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (drvp->drive_flags & DRIVE_UDMA) {
			s = splbio();
			drvp->drive_flags &= ~DRIVE_DMA;
			splx(s);
		}
	}
	pciide_print_modes(cp);
}

int
pdc203xx_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	struct pciide_pdcsata *ps = sc->sc_cookie;
	int i, rv, crv;
	u_int32_t scr;

	rv = 0;
	scr = bus_space_read_4(ps->ba5_st, ps->ba5_sh, 0x00040);

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		if (scr & (1 << (i + 1))) {
			crv = wdcintr(wdc_cp);
			if (crv == 0) {
				printf("%s:%d: bogus intr (reg 0x%x)\n",
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    i, scr);
			} else
				rv = 1;
		}
	}

	return (rv);
}

int
pdc205xx_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	struct pciide_pdcsata *ps = sc->sc_cookie;
	int i, rv, crv;
	u_int32_t scr, status;

	rv = 0;
	scr = bus_space_read_4(ps->ba5_st, ps->ba5_sh, 0x40);
	bus_space_write_4(ps->ba5_st, ps->ba5_sh, 0x40, scr & 0x0000ffff);

	status = bus_space_read_4(ps->ba5_st, ps->ba5_sh, 0x60);
	bus_space_write_4(ps->ba5_st, ps->ba5_sh, 0x60, status & 0x000000ff);

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		if (scr & (1 << (i + 1))) {
			crv = wdcintr(wdc_cp);
			if (crv == 0) {
				printf("%s:%d: bogus intr (reg 0x%x)\n",
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    i, scr);
			} else
				rv = 1;
		}
	}
	return rv;
}

void
pdc203xx_irqack(struct channel_softc *chp)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct pciide_pdcsata *ps = sc->sc_cookie;
	int chan = chp->channel;

	bus_space_write_4(sc->sc_dma_iot,
	    ps->regs[chan].dma_iohs[IDEDMA_CMD(0)], 0,
	    (bus_space_read_4(sc->sc_dma_iot,
		ps->regs[chan].dma_iohs[IDEDMA_CMD(0)],
		0) & ~0x00003f9f) | (chan + 1));
	bus_space_write_4(ps->ba5_st, ps->ba5_sh,
	    (chan + 1) << 2, 0x00000001);
}

void
pdc203xx_dma_start(void *v, int channel, int drive)
{
	struct pciide_softc *sc = v;
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	struct pciide_dma_maps *dma_maps = &cp->dma_maps[drive];
	struct pciide_pdcsata *ps = sc->sc_cookie;

	/* Write table address */
	bus_space_write_4(sc->sc_dma_iot,
	    ps->regs[channel].dma_iohs[IDEDMA_TBL(0)], 0,
	    dma_maps->dmamap_table->dm_segs[0].ds_addr);

	/* Start DMA engine */
	bus_space_write_4(sc->sc_dma_iot,
	    ps->regs[channel].dma_iohs[IDEDMA_CMD(0)], 0,
	    (bus_space_read_4(sc->sc_dma_iot,
	    ps->regs[channel].dma_iohs[IDEDMA_CMD(0)],
	    0) & ~0xc0) | ((dma_maps->dma_flags & WDC_DMA_READ) ? 0x80 : 0xc0));
}

int
pdc203xx_dma_finish(void *v, int channel, int drive, int force)
{
	struct pciide_softc *sc = v;
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	struct pciide_dma_maps *dma_maps = &cp->dma_maps[drive];
	struct pciide_pdcsata *ps = sc->sc_cookie;

	/* Stop DMA channel */
	bus_space_write_4(sc->sc_dma_iot,
	    ps->regs[channel].dma_iohs[IDEDMA_CMD(0)], 0,
	    (bus_space_read_4(sc->sc_dma_iot,
	    ps->regs[channel].dma_iohs[IDEDMA_CMD(0)],
	    0) & ~0x80));

	/* Unload the map of the data buffer */
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, 0,
	    dma_maps->dmamap_xfer->dm_mapsize,
	    (dma_maps->dma_flags & WDC_DMA_READ) ?
	    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, dma_maps->dmamap_xfer);

	return (0);
}

u_int8_t
pdc203xx_read_reg(struct channel_softc *chp, enum wdc_regs reg)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct pciide_pdcsata *ps = sc->sc_cookie;
	u_int8_t val;

	if (reg & _WDC_AUX) {
		return (bus_space_read_1(ps->regs[chp->channel].ctl_iot,
		    ps->regs[chp->channel].ctl_ioh, reg & _WDC_REGMASK));
	} else {
		val = bus_space_read_1(ps->regs[chp->channel].cmd_iot,
		    ps->regs[chp->channel].cmd_iohs[reg & _WDC_REGMASK], 0);
		return (val);
	}
}

void
pdc203xx_write_reg(struct channel_softc *chp, enum wdc_regs reg, u_int8_t val)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct pciide_pdcsata *ps = sc->sc_cookie;

	if (reg & _WDC_AUX)
		bus_space_write_1(ps->regs[chp->channel].ctl_iot,
		    ps->regs[chp->channel].ctl_ioh, reg & _WDC_REGMASK, val);
	else
		bus_space_write_1(ps->regs[chp->channel].cmd_iot,
		    ps->regs[chp->channel].cmd_iohs[reg & _WDC_REGMASK],
		    0, val);
}

void
pdc205xx_do_reset(struct channel_softc *chp)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct pciide_pdcsata *ps = sc->sc_cookie;
	u_int32_t scontrol;

	wdc_do_reset(chp);

	/* reset SATA */
	scontrol = SControl_DET_INIT | SControl_SPD_ANY | SControl_IPM_NONE;
	SCONTROL_WRITE(ps, chp->channel, scontrol);
	delay(50*1000);

	scontrol &= ~SControl_DET_INIT;
	SCONTROL_WRITE(ps, chp->channel, scontrol);
	delay(50*1000);
}

void
pdc205xx_drv_probe(struct channel_softc *chp)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct pciide_pdcsata *ps = sc->sc_cookie;
	bus_space_handle_t *iohs;
	u_int32_t scontrol, sstatus;
	u_int16_t scnt, sn, cl, ch;
	int s;

	SCONTROL_WRITE(ps, chp->channel, 0);
	delay(50*1000);

	scontrol = SControl_DET_INIT | SControl_SPD_ANY | SControl_IPM_NONE;
	SCONTROL_WRITE(ps,chp->channel,scontrol);
	delay(50*1000);

	scontrol &= ~SControl_DET_INIT;
	SCONTROL_WRITE(ps,chp->channel,scontrol);
	delay(50*1000);

	sstatus = SSTATUS_READ(ps,chp->channel);

	switch (sstatus & SStatus_DET_mask) {
	case SStatus_DET_NODEV:
		/* No Device; be silent.  */
		break;

	case SStatus_DET_DEV_NE:
		printf("%s: port %d: device connected, but "
		    "communication not established\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel);
		break;

	case SStatus_DET_OFFLINE:
		printf("%s: port %d: PHY offline\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel);
		break;

	case SStatus_DET_DEV:
		iohs = ps->regs[chp->channel].cmd_iohs;
		bus_space_write_1(chp->cmd_iot, iohs[wdr_sdh], 0,
		    WDSD_IBM);
		delay(10);	/* 400ns delay */
		scnt = bus_space_read_2(chp->cmd_iot, iohs[wdr_seccnt], 0);
		sn = bus_space_read_2(chp->cmd_iot, iohs[wdr_sector], 0);
		cl = bus_space_read_2(chp->cmd_iot, iohs[wdr_cyl_lo], 0);
		ch = bus_space_read_2(chp->cmd_iot, iohs[wdr_cyl_hi], 0);
#if 0
		printf("%s: port %d: scnt=0x%x sn=0x%x cl=0x%x ch=0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel,
		    scnt, sn, cl, ch);
#endif
		/*
		 * scnt and sn are supposed to be 0x1 for ATAPI, but in some
		 * cases we get wrong values here, so ignore it.
		 */
		s = splbio();
		if (cl == 0x14 && ch == 0xeb)
			chp->ch_drive[0].drive_flags |= DRIVE_ATAPI;
		else
			chp->ch_drive[0].drive_flags |= DRIVE_ATA;
		splx(s);
#if 0
		printf("%s: port %d",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel);
		switch ((sstatus & SStatus_SPD_mask) >> SStatus_SPD_shift) {
		case 1:
			printf(": 1.5Gb/s");
			break;
		case 2:
			printf(": 3.0Gb/s");
			break;
		}
		printf("\n");
#endif
		break;

	default:
		printf("%s: port %d: unknown SStatus: 0x%08x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel, sstatus);
	}
}

#ifdef notyet
/*
 * Inline functions for accessing the timing registers of the
 * OPTi controller.
 *
 * These *MUST* disable interrupts as they need atomic access to
 * certain magic registers. Failure to adhere to this *will*
 * break things in subtle ways if the wdc registers are accessed
 * by an interrupt routine while this magic sequence is executing.
 */
static __inline__ u_int8_t
opti_read_config(struct channel_softc *chp, int reg)
{
	u_int8_t rv;
	int s = splhigh();

	/* Two consecutive 16-bit reads from register #1 (0x1f1/0x171) */
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);

	/* Followed by an 8-bit write of 0x3 to register #2 */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x03u);

	/* Now we can read the required register */
	rv = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, reg);

	/* Restore the real registers */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x83u);

	splx(s);

	return (rv);
}

static __inline__ void
opti_write_config(struct channel_softc *chp, int reg, u_int8_t val)
{
	int s = splhigh();

	/* Two consecutive 16-bit reads from register #1 (0x1f1/0x171) */
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);

	/* Followed by an 8-bit write of 0x3 to register #2 */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x03u);

	/* Now we can write the required register */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, reg, val);

	/* Restore the real registers */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x83u);

	splx(s);
}

void
opti_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	bus_size_t cmdsize, ctlsize;
	pcireg_t interface;
	u_int8_t init_ctrl;
	int channel;

	printf(": DMA");
	/*
	 * XXXSCW:
	 * There seem to be a couple of buggy revisions/implementations
	 * of the OPTi pciide chipset. This kludge seems to fix one of
	 * the reported problems (NetBSD PR/11644) but still fails for the
	 * other (NetBSD PR/13151), although the latter may be due to other
	 * issues too...
	 */
	if (sc->sc_rev <= 0x12) {
		printf(" (disabled)");
		sc->sc_dma_ok = 0;
		sc->sc_wdcdev.cap = 0;
	} else {
		sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA32;
		pciide_mapreg_dma(sc, pa);
	}

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_MODE;
	sc->sc_wdcdev.PIO_cap = 4;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		sc->sc_wdcdev.DMA_cap = 2;
	}
	sc->sc_wdcdev.set_modes = opti_setup_channel;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	init_ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag,
	    OPTI_REG_INIT_CONTROL);

	interface = PCI_INTERFACE(pa->pa_class);

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		if (channel == 1 &&
		    (init_ctrl & OPTI_INIT_CONTROL_CH2_DISABLE) != 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			cp->hw_ok = 0;
			continue;
		}
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		opti_setup_channel(&cp->wdc_channel);
	}
}

void
opti_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int drive, spd;
	int mode[2];
	u_int8_t rv, mr;

	/*
	 * The `Delay' and `Address Setup Time' fields of the
	 * Miscellaneous Register are always zero initially.
	 */
	mr = opti_read_config(chp, OPTI_REG_MISC) & ~OPTI_MISC_INDEX_MASK;
	mr &= ~(OPTI_MISC_DELAY_MASK |
		OPTI_MISC_ADDR_SETUP_MASK |
		OPTI_MISC_INDEX_MASK);

	/* Prime the control register before setting timing values */
	opti_write_config(chp, OPTI_REG_CONTROL, OPTI_CONTROL_DISABLE);

	/* Determine the clockrate of the PCIbus the chip is attached to */
	spd = (int) opti_read_config(chp, OPTI_REG_STRAP);
	spd &= OPTI_STRAP_PCI_SPEED_MASK;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0) {
			mode[drive] = -1;
			continue;
		}

		if ((drvp->drive_flags & DRIVE_DMA)) {
			/*
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode > (drvp->DMA_mode + 2))
				drvp->PIO_mode = drvp->DMA_mode + 2;
			if (drvp->DMA_mode + 2 > (drvp->PIO_mode))
				drvp->DMA_mode = (drvp->PIO_mode > 2) ?
				    drvp->PIO_mode - 2 : 0;
			if (drvp->DMA_mode == 0)
				drvp->PIO_mode = 0;

			mode[drive] = drvp->DMA_mode + 5;
		} else
			mode[drive] = drvp->PIO_mode;

		if (drive && mode[0] >= 0 &&
		    (opti_tim_as[spd][mode[0]] != opti_tim_as[spd][mode[1]])) {
			/*
			 * Can't have two drives using different values
			 * for `Address Setup Time'.
			 * Slow down the faster drive to compensate.
			 */
			int d = (opti_tim_as[spd][mode[0]] >
				 opti_tim_as[spd][mode[1]]) ?  0 : 1;

			mode[d] = mode[1-d];
			chp->ch_drive[d].PIO_mode = chp->ch_drive[1-d].PIO_mode;
			chp->ch_drive[d].DMA_mode = 0;
			chp->ch_drive[d].drive_flags &= DRIVE_DMA;
		}
	}

	for (drive = 0; drive < 2; drive++) {
		int m;
		if ((m = mode[drive]) < 0)
			continue;

		/* Set the Address Setup Time and select appropriate index */
		rv = opti_tim_as[spd][m] << OPTI_MISC_ADDR_SETUP_SHIFT;
		rv |= OPTI_MISC_INDEX(drive);
		opti_write_config(chp, OPTI_REG_MISC, mr | rv);

		/* Set the pulse width and recovery timing parameters */
		rv  = opti_tim_cp[spd][m] << OPTI_PULSE_WIDTH_SHIFT;
		rv |= opti_tim_rt[spd][m] << OPTI_RECOVERY_TIME_SHIFT;
		opti_write_config(chp, OPTI_REG_READ_CYCLE_TIMING, rv);
		opti_write_config(chp, OPTI_REG_WRITE_CYCLE_TIMING, rv);

		/* Set the Enhanced Mode register appropriately */
	    	rv = pciide_pci_read(sc->sc_pc, sc->sc_tag, OPTI_REG_ENH_MODE);
		rv &= ~OPTI_ENH_MODE_MASK(chp->channel, drive);
		rv |= OPTI_ENH_MODE(chp->channel, drive, opti_tim_em[m]);
		pciide_pci_write(sc->sc_pc, sc->sc_tag, OPTI_REG_ENH_MODE, rv);
	}

	/* Finally, enable the timings */
	opti_write_config(chp, OPTI_REG_CONTROL, OPTI_CONTROL_ENABLE);

	pciide_print_modes(cp);
}
#endif

void
serverworks_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	pcitag_t pcib_tag;
	int channel;
	bus_size_t cmdsize, ctlsize;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_RCC_OSB4_IDE:
		sc->sc_wdcdev.UDMA_cap = 2;
		break;
	case PCI_PRODUCT_RCC_CSB5_IDE:
		if (sc->sc_rev < 0x92)
			sc->sc_wdcdev.UDMA_cap = 4;
		else
			sc->sc_wdcdev.UDMA_cap = 5;
		break;
	case PCI_PRODUCT_RCC_CSB6_IDE:
		sc->sc_wdcdev.UDMA_cap = 4;
		break;
	case PCI_PRODUCT_RCC_CSB6_RAID_IDE:
	case PCI_PRODUCT_RCC_HT_1000_IDE:
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
	}

	sc->sc_wdcdev.set_modes = serverworks_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels =
	    (sc->sc_pp->ide_product == PCI_PRODUCT_RCC_CSB6_IDE ? 1 : 2);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    serverworks_pci_intr);
		if (cp->hw_ok == 0)
			return;
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			return;
		serverworks_setup_channel(&cp->wdc_channel);
	}

	pcib_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, pa->pa_device, 0);
	pci_conf_write(pa->pa_pc, pcib_tag, 0x64,
	    (pci_conf_read(pa->pa_pc, pcib_tag, 0x64) & ~0x2000) | 0x4000);
}

void
serverworks_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	int drive, unit;
	u_int32_t pio_time, dma_time, pio_mode, udma_mode;
	u_int32_t idedma_ctl;
	static const u_int8_t pio_modes[5] = {0x5d, 0x47, 0x34, 0x22, 0x20};
	static const u_int8_t dma_modes[3] = {0x77, 0x21, 0x20};

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	pio_time = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x40);
	dma_time = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x44);
	pio_mode = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x48);
	udma_mode = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x54);

	pio_time &= ~(0xffff << (16 * channel));
	dma_time &= ~(0xffff << (16 * channel));
	pio_mode &= ~(0xff << (8 * channel + 16));
	udma_mode &= ~(0xff << (8 * channel + 16));
	udma_mode &= ~(3 << (2 * channel));

	idedma_ctl = 0;

	/* Per drive settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		unit = drive + 2 * channel;
		/* add timing values, setup DMA if needed */
		pio_time |= pio_modes[drvp->PIO_mode] << (8 * (unit^1));
		pio_mode |= drvp->PIO_mode << (4 * unit + 16);
		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&
		    (drvp->drive_flags & DRIVE_UDMA)) {
			/* use Ultra/DMA, check for 80-pin cable */
			if (sc->sc_rev <= 0x92 && drvp->UDMA_mode > 2 &&
			    (PCI_PRODUCT(pci_conf_read(sc->sc_pc, sc->sc_tag,
			    PCI_SUBSYS_ID_REG)) &
			    (1 << (14 + channel))) == 0) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}
			dma_time |= dma_modes[drvp->DMA_mode] << (8 * (unit^1));
			udma_mode |= drvp->UDMA_mode << (4 * unit + 16);
			udma_mode |= 1 << unit;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) &&
		    (drvp->drive_flags & DRIVE_DMA)) {
			/* use Multiword DMA */
			drvp->drive_flags &= ~DRIVE_UDMA;
			dma_time |= dma_modes[drvp->DMA_mode] << (8 * (unit^1));
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			/* PIO only */
			drvp->drive_flags &= ~(DRIVE_UDMA | DRIVE_DMA);
		}
	}

	pci_conf_write(sc->sc_pc, sc->sc_tag, 0x40, pio_time);
	pci_conf_write(sc->sc_pc, sc->sc_tag, 0x44, dma_time);
	if (sc->sc_pp->ide_product != PCI_PRODUCT_RCC_OSB4_IDE)
		pci_conf_write(sc->sc_pc, sc->sc_tag, 0x48, pio_mode);
	pci_conf_write(sc->sc_pc, sc->sc_tag, 0x54, udma_mode);

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

int
serverworks_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int rv = 0;
	int dmastat, i, crv;

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(i));
		if ((dmastat & (IDEDMA_CTL_ACT | IDEDMA_CTL_INTR)) !=
		    IDEDMA_CTL_INTR)
			continue;
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		crv = wdcintr(wdc_cp);
		if (crv == 0) {
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
			bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
			    IDEDMA_CTL(i), dmastat);
		} else
			rv = 1;
	}
	return (rv);
}

void
svwsata_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pci_intr_handle_t intrhandle;
	const char *intrstr;
	int channel;
	struct pciide_svwsata *ss;

	/* Allocate memory for private data */
	sc->sc_cookielen = sizeof(*ss);
	sc->sc_cookie = malloc(sc->sc_cookielen, M_DEVBUF, M_NOWAIT | M_ZERO);
	ss = sc->sc_cookie;

	/* The 4-port version has a dummy second function. */
	if (pci_conf_read(sc->sc_pc, sc->sc_tag,
	    PCI_MAPREG_START + 0x14) == 0) {
		printf("\n");
		return;
	}

	if (pci_mapreg_map(pa, PCI_MAPREG_START + 0x14,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &ss->ba5_st, &ss->ba5_sh, NULL, NULL, 0) != 0) {
		printf(": unable to map BA5 register space\n");
		return;
	}

	printf(": DMA");
	svwsata_mapreg_dma(sc, pa);
	printf("\n");

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA |
		    WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 6;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = 4;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_SATA;
	sc->sc_wdcdev.set_modes = sata_setup_channel;

	/* We can use SControl and SStatus to probe for drives. */
	sc->sc_wdcdev.drv_probe = svwsata_drv_probe;

	/* Map and establish the interrupt handler. */
	if(pci_intr_map(pa, &intrhandle) != 0) {
		printf("%s: couldn't map native-PCI interrupt\n",
		    sc->sc_wdcdev.sc_dev.dv_xname);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, intrhandle);
	sc->sc_pci_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_BIO,
	    pciide_pci_intr, sc, sc->sc_wdcdev.sc_dev.dv_xname);
	if (sc->sc_pci_ih != NULL) {
		printf("%s: using %s for native-PCI interrupt\n",
		    sc->sc_wdcdev.sc_dev.dv_xname,
		    intrstr ? intrstr : "unknown interrupt");
	} else {
		printf("%s: couldn't establish native-PCI interrupt",
		    sc->sc_wdcdev.sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}

	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_RCC_K2_SATA:
		bus_space_write_4(ss->ba5_st, ss->ba5_sh, SVWSATA_SICR1,
		    bus_space_read_4(ss->ba5_st, ss->ba5_sh, SVWSATA_SICR1)
		    & ~0x00040000);
		bus_space_write_4(ss->ba5_st, ss->ba5_sh,
		    SVWSATA_SIM, 0);
		break;
	}

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, 0) == 0)
			continue;
		svwsata_mapchan(cp);
		sata_setup_channel(&cp->wdc_channel);
	}
}

void
svwsata_mapreg_dma(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_svwsata *ss = sc->sc_cookie;

	sc->sc_wdcdev.dma_arg = sc;
	sc->sc_wdcdev.dma_init = pciide_dma_init;
	sc->sc_wdcdev.dma_start = pciide_dma_start;
	sc->sc_wdcdev.dma_finish = pciide_dma_finish;

	/* XXX */
	sc->sc_dma_iot = ss->ba5_st;
	sc->sc_dma_ioh = ss->ba5_sh;

	sc->sc_dmacmd_read = svwsata_dmacmd_read;
	sc->sc_dmacmd_write = svwsata_dmacmd_write;
	sc->sc_dmactl_read = svwsata_dmactl_read;
	sc->sc_dmactl_write = svwsata_dmactl_write;
	sc->sc_dmatbl_write = svwsata_dmatbl_write;

	/* DMA registers all set up! */
	sc->sc_dmat = pa->pa_dmat;
	sc->sc_dma_ok = 1;
}

u_int8_t
svwsata_dmacmd_read(struct pciide_softc *sc, int chan)
{
	return (bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    (chan << 8) + SVWSATA_DMA + IDEDMA_CMD(0)));
}

void
svwsata_dmacmd_write(struct pciide_softc *sc, int chan, u_int8_t val)
{
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    (chan << 8) + SVWSATA_DMA + IDEDMA_CMD(0), val);
}

u_int8_t
svwsata_dmactl_read(struct pciide_softc *sc, int chan)
{
	return (bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    (chan << 8) + SVWSATA_DMA + IDEDMA_CTL(0)));
}

void
svwsata_dmactl_write(struct pciide_softc *sc, int chan, u_int8_t val)
{
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    (chan << 8) + SVWSATA_DMA + IDEDMA_CTL(0), val);
}

void
svwsata_dmatbl_write(struct pciide_softc *sc, int chan, u_int32_t val)
{
	bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
	    (chan << 8) + SVWSATA_DMA + IDEDMA_TBL(0), val);
}

void
svwsata_mapchan(struct pciide_channel *cp)
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	struct pciide_svwsata *ss = sc->sc_cookie;

	cp->compat = 0;
	cp->ih = sc->sc_pci_ih;

	if (bus_space_subregion(ss->ba5_st, ss->ba5_sh,
		(wdc_cp->channel << 8) + SVWSATA_TF0,
		SVWSATA_TF8 - SVWSATA_TF0, &wdc_cp->cmd_ioh) != 0) {
		printf("%s: couldn't map %s cmd regs\n",
		       sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return;
	}
	if (bus_space_subregion(ss->ba5_st, ss->ba5_sh,
		(wdc_cp->channel << 8) + SVWSATA_TF8, 4,
		&wdc_cp->ctl_ioh) != 0) {
		printf("%s: couldn't map %s ctl regs\n",
		       sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return;
	}
	wdc_cp->cmd_iot = wdc_cp->ctl_iot = ss->ba5_st;
	wdc_cp->_vtbl = &wdc_svwsata_vtbl;
	wdc_cp->ch_flags |= WDCF_DMA_BEFORE_CMD;
	wdcattach(wdc_cp);
}

void
svwsata_drv_probe(struct channel_softc *chp)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct pciide_svwsata *ss = sc->sc_cookie;
	int channel = chp->channel;
	uint32_t scontrol, sstatus;
	uint8_t scnt, sn, cl, ch;
	int s;

	/*
	 * Request communication initialization sequence, any speed.
	 * Performing this is the equivalent of an ATA Reset.
	 */
	scontrol = SControl_DET_INIT | SControl_SPD_ANY;

	/*
	 * XXX We don't yet support SATA power management; disable all
	 * power management state transitions.
	 */
	scontrol |= SControl_IPM_NONE;

	bus_space_write_4(ss->ba5_st, ss->ba5_sh,
	    (channel << 8) + SVWSATA_SCONTROL, scontrol);
	delay(50 * 1000);
	scontrol &= ~SControl_DET_INIT;
	bus_space_write_4(ss->ba5_st, ss->ba5_sh,
	    (channel << 8) + SVWSATA_SCONTROL, scontrol);
	delay(100 * 1000);

	sstatus = bus_space_read_4(ss->ba5_st, ss->ba5_sh,
	    (channel << 8) + SVWSATA_SSTATUS);
#if 0
	printf("%s: port %d: SStatus=0x%08x, SControl=0x%08x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel, sstatus,
	    bus_space_read_4(ss->ba5_st, ss->ba5_sh,
	        (channel << 8) + SVWSATA_SSTATUS));
#endif
	switch (sstatus & SStatus_DET_mask) {
	case SStatus_DET_NODEV:
		/* No device; be silent. */
		break;

	case SStatus_DET_DEV_NE:
		printf("%s: port %d: device connected, but "
		    "communication not established\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel);
		break;

	case SStatus_DET_OFFLINE:
		printf("%s: port %d: PHY offline\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel);
		break;

	case SStatus_DET_DEV:
		/*
		 * XXX ATAPI detection doesn't currently work.  Don't
		 * XXX know why.  But, it's not like the standard method
		 * XXX can detect an ATAPI device connected via a SATA/PATA
		 * XXX bridge, so at least this is no worse.  --thorpej
		 */
		if (chp->_vtbl != NULL)
			CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (0 << 4));
		else
			bus_space_write_1(chp->cmd_iot, chp->cmd_ioh,
			    wdr_sdh & _WDC_REGMASK, WDSD_IBM | (0 << 4));
		delay(10);	/* 400ns delay */
		/* Save register contents. */
		if (chp->_vtbl != NULL) {
			scnt = CHP_READ_REG(chp, wdr_seccnt);
			sn = CHP_READ_REG(chp, wdr_sector);
			cl = CHP_READ_REG(chp, wdr_cyl_lo);
			ch = CHP_READ_REG(chp, wdr_cyl_hi);
		} else {
			scnt = bus_space_read_1(chp->cmd_iot,
			    chp->cmd_ioh, wdr_seccnt & _WDC_REGMASK);
			sn = bus_space_read_1(chp->cmd_iot,
			    chp->cmd_ioh, wdr_sector & _WDC_REGMASK);
			cl = bus_space_read_1(chp->cmd_iot,
			    chp->cmd_ioh, wdr_cyl_lo & _WDC_REGMASK);
			ch = bus_space_read_1(chp->cmd_iot,
			    chp->cmd_ioh, wdr_cyl_hi & _WDC_REGMASK);
		}
#if 0
		printf("%s: port %d: scnt=0x%x sn=0x%x cl=0x%x ch=0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel,
		    scnt, sn, cl, ch);
#endif
		/*
		 * scnt and sn are supposed to be 0x1 for ATAPI, but in some
		 * cases we get wrong values here, so ignore it.
		 */
		s = splbio();
		if (cl == 0x14 && ch == 0xeb)
			chp->ch_drive[0].drive_flags |= DRIVE_ATAPI;
		else
			chp->ch_drive[0].drive_flags |= DRIVE_ATA;
		splx(s);

		printf("%s: port %d",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel);
		switch ((sstatus & SStatus_SPD_mask) >> SStatus_SPD_shift) {
		case 1:
			printf(": 1.5Gb/s");
			break;
		case 2:
			printf(": 3.0Gb/s");
			break;
		}
		printf("\n");
		break;

	default:
		printf("%s: port %d: unknown SStatus: 0x%08x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel, sstatus);
	}
}

u_int8_t
svwsata_read_reg(struct channel_softc *chp, enum wdc_regs reg)
{
	if (reg & _WDC_AUX) {
		return (bus_space_read_4(chp->ctl_iot, chp->ctl_ioh,
		    (reg & _WDC_REGMASK) << 2));
	} else {
		return (bus_space_read_4(chp->cmd_iot, chp->cmd_ioh,
		    (reg & _WDC_REGMASK) << 2));
	}
}

void
svwsata_write_reg(struct channel_softc *chp, enum wdc_regs reg, u_int8_t val)
{
	if (reg & _WDC_AUX) {
		bus_space_write_4(chp->ctl_iot, chp->ctl_ioh,
		    (reg & _WDC_REGMASK) << 2, val);
	} else {
		bus_space_write_4(chp->cmd_iot, chp->cmd_ioh,
		    (reg & _WDC_REGMASK) << 2, val);
	}
}
 
void
svwsata_lba48_write_reg(struct channel_softc *chp, enum wdc_regs reg, u_int16_t val)
{
	if (reg & _WDC_AUX) {
		bus_space_write_4(chp->ctl_iot, chp->ctl_ioh,
		    (reg & _WDC_REGMASK) << 2, val);
	} else {
		bus_space_write_4(chp->cmd_iot, chp->cmd_ioh,
		    (reg & _WDC_REGMASK) << 2, val);
	}
}
 
#define	ACARD_IS_850(sc) \
	((sc)->sc_pp->ide_product == PCI_PRODUCT_ACARD_ATP850U)

void
acard_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int i;
	pcireg_t interface;
	bus_size_t cmdsize, ctlsize;

	/*
	 * when the chip is in native mode it identifies itself as a
	 * 'misc mass storage'. Fake interface in this case.
	 */
	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCI_INTERFACE(pa->pa_class);
	} else {
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);
	}

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_ACARD_ATP850U:
		sc->sc_wdcdev.UDMA_cap = 2;
		break;
	case PCI_PRODUCT_ACARD_ATP860:
	case PCI_PRODUCT_ACARD_ATP860A:
		sc->sc_wdcdev.UDMA_cap = 4;
		break;
	case PCI_PRODUCT_ACARD_ATP865A:
	case PCI_PRODUCT_ACARD_ATP865R:
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
	}

	sc->sc_wdcdev.set_modes = acard_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = 2;

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		if (pciide_chansetup(sc, i, interface) == 0)
			continue;
		if (interface & PCIIDE_INTERFACE_PCI(i)) {
			cp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize,
			    &ctlsize, pciide_pci_intr);
		} else {
			cp->hw_ok = pciide_mapregs_compat(pa, cp, i,
			    &cmdsize, &ctlsize);
		}
		if (cp->hw_ok == 0)
			return;
		cp->wdc_channel.data32iot = cp->wdc_channel.cmd_iot;
		cp->wdc_channel.data32ioh = cp->wdc_channel.cmd_ioh;
		wdcattach(&cp->wdc_channel);
		acard_setup_channel(&cp->wdc_channel);
	}
	if (!ACARD_IS_850(sc)) {
		u_int32_t reg;
		reg = pci_conf_read(sc->sc_pc, sc->sc_tag, ATP8x0_CTRL);
		reg &= ~ATP860_CTRL_INT;
		pci_conf_write(sc->sc_pc, sc->sc_tag, ATP8x0_CTRL, reg);
	}
}

void
acard_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	int drive;
	u_int32_t idetime, udma_mode;
	u_int32_t idedma_ctl;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	if (ACARD_IS_850(sc)) {
		idetime = 0;
		udma_mode = pci_conf_read(sc->sc_pc, sc->sc_tag, ATP850_UDMA);
		udma_mode &= ~ATP850_UDMA_MASK(channel);
	} else {
		idetime = pci_conf_read(sc->sc_pc, sc->sc_tag, ATP860_IDETIME);
		idetime &= ~ATP860_SETTIME_MASK(channel);
		udma_mode = pci_conf_read(sc->sc_pc, sc->sc_tag, ATP860_UDMA);
		udma_mode &= ~ATP860_UDMA_MASK(channel);
	}

	idedma_ctl = 0;

	/* Per drive settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&
		    (drvp->drive_flags & DRIVE_UDMA)) {
			/* use Ultra/DMA */
			if (ACARD_IS_850(sc)) {
				idetime |= ATP850_SETTIME(drive,
				    acard_act_udma[drvp->UDMA_mode],
				    acard_rec_udma[drvp->UDMA_mode]);
				udma_mode |= ATP850_UDMA_MODE(channel, drive,
				    acard_udma_conf[drvp->UDMA_mode]);
			} else {
				idetime |= ATP860_SETTIME(channel, drive,
				    acard_act_udma[drvp->UDMA_mode],
				    acard_rec_udma[drvp->UDMA_mode]);
				udma_mode |= ATP860_UDMA_MODE(channel, drive,
				    acard_udma_conf[drvp->UDMA_mode]);
			}
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) &&
		    (drvp->drive_flags & DRIVE_DMA)) {
			/* use Multiword DMA */
			drvp->drive_flags &= ~DRIVE_UDMA;
			if (ACARD_IS_850(sc)) {
				idetime |= ATP850_SETTIME(drive,
				    acard_act_dma[drvp->DMA_mode],
				    acard_rec_dma[drvp->DMA_mode]);
			} else {
				idetime |= ATP860_SETTIME(channel, drive,
				    acard_act_dma[drvp->DMA_mode],
				    acard_rec_dma[drvp->DMA_mode]);
			}
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			/* PIO only */
			drvp->drive_flags &= ~(DRIVE_UDMA | DRIVE_DMA);
			if (ACARD_IS_850(sc)) {
				idetime |= ATP850_SETTIME(drive,
				    acard_act_pio[drvp->PIO_mode],
				    acard_rec_pio[drvp->PIO_mode]);
			} else {
				idetime |= ATP860_SETTIME(channel, drive,
				    acard_act_pio[drvp->PIO_mode],
				    acard_rec_pio[drvp->PIO_mode]);
			}
		pci_conf_write(sc->sc_pc, sc->sc_tag, ATP8x0_CTRL,
		    pci_conf_read(sc->sc_pc, sc->sc_tag, ATP8x0_CTRL)
		    | ATP8x0_CTRL_EN(channel));
		}
	}

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}
	pciide_print_modes(cp);

	if (ACARD_IS_850(sc)) {
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    ATP850_IDETIME(channel), idetime);
		pci_conf_write(sc->sc_pc, sc->sc_tag, ATP850_UDMA, udma_mode);
	} else {
		pci_conf_write(sc->sc_pc, sc->sc_tag, ATP860_IDETIME, idetime);
		pci_conf_write(sc->sc_pc, sc->sc_tag, ATP860_UDMA, udma_mode);
	}
}

void
nforce_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;
	u_int32_t conf;

	conf = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_CONF);
	WDCDEBUG_PRINT(("%s: conf register 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, conf), DEBUG_PROBE);

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_NVIDIA_NFORCE_IDE:
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
	default:
		sc->sc_wdcdev.UDMA_cap = 6;
	}
	sc->sc_wdcdev.set_modes = nforce_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];

		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		if ((conf & NFORCE_CHAN_EN(channel)) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			cp->hw_ok = 0;
			continue;
		}

		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    nforce_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		if (pciide_chan_candisable(cp)) {
			conf &= ~NFORCE_CHAN_EN(channel);
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
	WDCDEBUG_PRINT(("%s: new conf register 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, conf), DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_CONF, conf);
}

void
nforce_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, mode;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	u_int32_t conf, piodmatim, piotim, udmatim;

	conf = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_CONF);
	piodmatim = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_PIODMATIM);
	piotim = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_PIOTIM);
	udmatim = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_UDMATIM);
	WDCDEBUG_PRINT(("%s: %s old timing values: piodmatim=0x%x, "
	    "piotim=0x%x, udmatim=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname,
	    cp->name, piodmatim, piotim, udmatim), DEBUG_PROBE);

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	/* Clear all bits for this channel */
	idedma_ctl = 0;
	piodmatim &= ~NFORCE_PIODMATIM_MASK(channel);
	udmatim &= ~NFORCE_UDMATIM_MASK(channel);

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			drvp->drive_flags &= ~DRIVE_DMA;

			udmatim |= NFORCE_UDMATIM_SET(channel, drive,
			    nforce_udma[drvp->UDMA_mode]) |
			    NFORCE_UDMA_EN(channel, drive) |
			    NFORCE_UDMA_ENM(channel, drive);

			mode = drvp->PIO_mode;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			mode = drvp->PIO_mode;
			goto pio;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:
		/* Setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
			mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}
		piodmatim |= NFORCE_PIODMATIM_SET(channel, drive,
		    nforce_pio[mode]);
	}

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}

	WDCDEBUG_PRINT(("%s: %s new timing values: piodmatim=0x%x, "
	    "piotim=0x%x, udmatim=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname,
	    cp->name, piodmatim, piotim, udmatim), DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_PIODMATIM, piodmatim);
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_UDMATIM, udmatim);

	pciide_print_modes(cp);
}

int
nforce_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv;
	u_int32_t dmastat;

	rv = 0;
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;

		/* Skip compat channel */
		if (cp->compat)
			continue;

		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(i));
		if ((dmastat & IDEDMA_CTL_INTR) == 0)
			continue;

		crv = wdcintr(wdc_cp);
		if (crv == 0)
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
		else
			rv = 1;
	}
	return (rv);
}

void
artisea_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	bus_size_t cmdsize, ctlsize;
	pcireg_t interface;
	int channel;

	printf(": DMA");
#ifdef PCIIDE_I31244_DISABLEDMA
	if (sc->sc_rev == 0) {
		printf(" disabled due to rev. 0");
		sc->sc_dma_ok = 0;
	} else
#endif
		pciide_mapreg_dma(sc, pa);
	printf("\n");

	/*
	 * XXX Configure LEDs to show activity.
	 */

	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_SATA;
	sc->sc_wdcdev.PIO_cap = 4;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		sc->sc_wdcdev.DMA_cap = 2;
		sc->sc_wdcdev.UDMA_cap = 6;
	}
	sc->sc_wdcdev.set_modes = sata_setup_channel;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	interface = PCI_INTERFACE(pa->pa_class);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0)
			continue;
		pciide_map_compat_intr(pa, cp, channel, interface);
		sata_setup_channel(&cp->wdc_channel);
	}
}

void
ite_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface;
	bus_size_t cmdsize, ctlsize;
	pcireg_t cfg, modectl;

	/*
	 * Fake interface since IT8212F is claimed to be a ``RAID'' device.
	 */
	interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
	    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);

	cfg = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_CFG);
	modectl = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_MODE);
	WDCDEBUG_PRINT(("%s: cfg=0x%x, modectl=0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cfg & IT_CFG_MASK,
	    modectl & IT_MODE_MASK), DEBUG_PROBE);

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 6;

	sc->sc_wdcdev.set_modes = ite_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	/* Disable RAID */
	modectl &= ~IT_MODE_RAID1;
	/* Disable CPU firmware mode */
	modectl &= ~IT_MODE_CPU;

	pci_conf_write(sc->sc_pc, sc->sc_tag, IT_MODE, modectl);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];

		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}

	/* Re-read configuration registers after channels setup */
	cfg = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_CFG);
	modectl = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_MODE);
	WDCDEBUG_PRINT(("%s: cfg=0x%x, modectl=0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cfg & IT_CFG_MASK,
	    modectl & IT_MODE_MASK), DEBUG_PROBE);
}

void
ite_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, mode;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	pcireg_t cfg, modectl;
	pcireg_t tim;

	cfg = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_CFG);
	modectl = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_MODE);
	tim = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_TIM(channel));
	WDCDEBUG_PRINT(("%s:%d: tim=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname,
	    channel, tim), DEBUG_PROBE);

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	/* Clear all bits for this channel */
	idedma_ctl = 0;

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			drvp->drive_flags &= ~DRIVE_DMA;
			modectl &= ~IT_MODE_DMA(channel, drive);

#if 0
			/* Check cable, works only in CPU firmware mode */
			if (drvp->UDMA_mode > 2 &&
			    (cfg & IT_CFG_CABLE(channel, drive)) == 0) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): "
				    "80-wire cable not detected\n",
				    drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}
#endif

			if (drvp->UDMA_mode >= 5)
				tim |= IT_TIM_UDMA5(drive);
			else
				tim &= ~IT_TIM_UDMA5(drive);

			mode = drvp->PIO_mode;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;
			modectl |= IT_MODE_DMA(channel, drive);

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			mode = drvp->PIO_mode;
			goto pio;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:
		/* Setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
			mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}

		/* Enable IORDY if PIO mode >= 3 */
		if (drvp->PIO_mode >= 3)
			cfg |= IT_CFG_IORDY(channel);
	}

	WDCDEBUG_PRINT(("%s: tim=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname,
	    tim), DEBUG_PROBE);

	pci_conf_write(sc->sc_pc, sc->sc_tag, IT_CFG, cfg);
	pci_conf_write(sc->sc_pc, sc->sc_tag, IT_MODE, modectl);
	pci_conf_write(sc->sc_pc, sc->sc_tag, IT_TIM(channel), tim);

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}

	pciide_print_modes(cp);
}

void
ixp_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 6;

	sc->sc_wdcdev.set_modes = ixp_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
}

void
ixp_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, mode;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	pcireg_t udma, mdma_timing, pio, pio_timing;

	pio_timing = pci_conf_read(sc->sc_pc, sc->sc_tag, IXP_PIO_TIMING);
	pio = pci_conf_read(sc->sc_pc, sc->sc_tag, IXP_PIO_CTL);
	mdma_timing = pci_conf_read(sc->sc_pc, sc->sc_tag, IXP_MDMA_TIMING);
	udma = pci_conf_read(sc->sc_pc, sc->sc_tag, IXP_UDMA_CTL);

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			IXP_UDMA_ENABLE(udma, chp->channel, drive);
			IXP_SET_MODE(udma, chp->channel, drive,
			    drvp->UDMA_mode);
			mode = drvp->PIO_mode;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			IXP_UDMA_DISABLE(udma, chp->channel, drive);
			IXP_SET_TIMING(mdma_timing, chp->channel, drive,
			    ixp_mdma_timings[drvp->DMA_mode]);

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			mode = drvp->PIO_mode;
		}

		/* Setup PIO mode */
		drvp->PIO_mode = mode;
		if (mode < 2)
			drvp->DMA_mode = 0;
		else
			drvp->DMA_mode = mode - 2;
		/*
		 * Set PIO mode and timings
		 * Linux driver avoids PIO mode 1, let's do it too.
		 */
		if (drvp->PIO_mode == 1)
			drvp->PIO_mode = 0;

		IXP_SET_MODE(pio, chp->channel, drive, drvp->PIO_mode);
		IXP_SET_TIMING(pio_timing, chp->channel, drive,
		    ixp_pio_timings[drvp->PIO_mode]);
	}

	pci_conf_write(sc->sc_pc, sc->sc_tag, IXP_UDMA_CTL, udma);
	pci_conf_write(sc->sc_pc, sc->sc_tag, IXP_MDMA_TIMING, mdma_timing);
	pci_conf_write(sc->sc_pc, sc->sc_tag, IXP_PIO_CTL, pio);
	pci_conf_write(sc->sc_pc, sc->sc_tag, IXP_PIO_TIMING, pio_timing);

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}

	pciide_print_modes(cp);
}

void
jmicron_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;
	u_int32_t conf;

	conf = pci_conf_read(sc->sc_pc, sc->sc_tag, JMICRON_CONF);
	WDCDEBUG_PRINT(("%s: conf register 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, conf), DEBUG_PROBE);

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 6;
	sc->sc_wdcdev.set_modes = jmicron_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];

		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

#if 0
		if ((conf & JMICRON_CHAN_EN(channel)) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			cp->hw_ok = 0;
			continue;
		}
#endif

		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		if (pciide_chan_candisable(cp)) {
			conf &= ~JMICRON_CHAN_EN(channel);
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
	WDCDEBUG_PRINT(("%s: new conf register 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, conf), DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, JMICRON_CONF, conf);
}

void
jmicron_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, mode;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	u_int32_t conf;

	conf = pci_conf_read(sc->sc_pc, sc->sc_tag, JMICRON_CONF);

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	/* Clear all bits for this channel */
	idedma_ctl = 0;

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			drvp->drive_flags &= ~DRIVE_DMA;

			/* see if cable is up to scratch */
			if ((conf & JMICRON_CONF_40PIN) &&
			    (drvp->UDMA_mode > 2))
				drvp->UDMA_mode = 2;

			mode = drvp->PIO_mode;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			mode = drvp->PIO_mode;
			goto pio;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:
		/* Setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}
	}

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}

	pciide_print_modes(cp);
}

void
phison_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;

	sc->chip_unmap = default_chip_unmap;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 5;
	sc->sc_wdcdev.set_modes = phison_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = 1;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];

		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
}

void
phison_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, mode;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	/* Clear all bits for this channel */
	idedma_ctl = 0;

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			drvp->drive_flags &= ~DRIVE_DMA;
			mode = drvp->PIO_mode;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			mode = drvp->PIO_mode;
			goto pio;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:
		/* Setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}
	}

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}

	pciide_print_modes(cp);
}

void
sch_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 5;
	sc->sc_wdcdev.set_modes = sch_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = 1;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];

		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
}

void
sch_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, mode;
	u_int32_t tim, timaddr;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		timaddr = (drive == 0) ? SCH_D0TIM : SCH_D1TIM;
		tim = pci_conf_read(sc->sc_pc, sc->sc_tag, timaddr);
		tim &= ~SCH_TIM_MASK;

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			drvp->drive_flags &= ~DRIVE_DMA;

			mode = drvp->PIO_mode;
			tim |= (drvp->UDMA_mode << 16) | SCH_TIM_SYNCDMA;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;

			tim &= ~SCH_TIM_SYNCDMA;

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			mode = drvp->PIO_mode;
			goto pio;
		}

pio:
		/* Setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}
		tim |= (drvp->DMA_mode << 8) | (drvp->PIO_mode);
		pci_conf_write(sc->sc_pc, sc->sc_tag, timaddr, tim);
	}

	pciide_print_modes(cp);
}

void
rdc_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	u_int32_t patr;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA |
			WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		sc->sc_wdcdev.dma_init = pciide_dma_init;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 5;
	sc->sc_wdcdev.set_modes = rdc_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	WDCDEBUG_PRINT(("rdc_chip_map: old PATR=0x%x, "
			"PSD1ATR=0x%x, UDCCR=0x%x, IIOCR=0x%x\n",
			pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_PATR),
			pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_PSD1ATR),
			pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_UDCCR),
			pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_IIOCR)),
		       DEBUG_PROBE);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];

		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		patr = pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_PATR);
		if ((patr & RDCIDE_PATR_EN(channel)) == 0) {
			printf("%s: %s ignored (disabled)\n",
			       sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			cp->hw_ok = 0;
			continue;
		}
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
			       pciide_pci_intr);
		if (cp->hw_ok == 0)
			goto next;
		if (pciide_chan_candisable(cp)) {
			patr &= ~RDCIDE_PATR_EN(channel);
			pci_conf_write(sc->sc_pc, sc->sc_tag, RDCIDE_PATR,
				       patr);
		}
		if (cp->hw_ok == 0)
			goto next;
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
next:
		if (cp->hw_ok == 0)
			pciide_unmap_compat_intr(pa, cp, channel, interface);
	}

	WDCDEBUG_PRINT(("rdc_chip_map: PATR=0x%x, "
			"PSD1ATR=0x%x, UDCCR=0x%x, IIOCR=0x%x\n",
			pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_PATR),
			pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_PSD1ATR),
			pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_UDCCR),
			pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_IIOCR)),
		       DEBUG_PROBE);
}

void
rdc_setup_channel(struct channel_softc *chp)
{
	u_int8_t drive;
	u_int32_t patr, psd1atr, udccr, iiocr;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	struct ata_drive_datas *drvp;

	patr = pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_PATR);
	psd1atr = pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_PSD1ATR);
	udccr = pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_UDCCR);
	iiocr = pci_conf_read(sc->sc_pc, sc->sc_tag, RDCIDE_IIOCR);

	/* setup DMA */
	pciide_channel_dma_setup(cp);

	/* clear modes */
	patr = patr & (RDCIDE_PATR_EN(0) | RDCIDE_PATR_EN(1));
	psd1atr &= ~RDCIDE_PSD1ATR_SETUP_MASK(chp->channel);
	psd1atr &= ~RDCIDE_PSD1ATR_HOLD_MASK(chp->channel);
	for (drive = 0; drive < 2; drive++) {
		udccr &= ~RDCIDE_UDCCR_EN(chp->channel, drive);
		udccr &= ~RDCIDE_UDCCR_TIM_MASK(chp->channel, drive);
		iiocr &= ~RDCIDE_IIOCR_CLK_MASK(chp->channel, drive);
	}
	/* now setup modes */
	for (drive = 0; drive < 2; drive++) {
		drvp = &cp->wdc_channel.ch_drive[drive];
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (drvp->drive_flags & DRIVE_ATAPI)
			patr |= RDCIDE_PATR_ATA(chp->channel, drive);
		if (drive == 0) {
			patr |= RDCIDE_PATR_SETUP(rdcide_setup[drvp->PIO_mode],
						  chp->channel);
			patr |= RDCIDE_PATR_HOLD(rdcide_hold[drvp->PIO_mode],
						 chp->channel);
		} else {
			patr |= RDCIDE_PATR_DEV1_TEN(chp->channel);
			psd1atr |= RDCIDE_PSD1ATR_SETUP(
				rdcide_setup[drvp->PIO_mode],
				chp->channel);
			psd1atr |= RDCIDE_PSD1ATR_HOLD(
				rdcide_hold[drvp->PIO_mode],
				chp->channel);
		}
		if (drvp->PIO_mode > 0) {
			patr |= RDCIDE_PATR_FTIM(chp->channel, drive);
			patr |= RDCIDE_PATR_IORDY(chp->channel, drive);
		}
		if (drvp->drive_flags & DRIVE_DMA)
			patr |= RDCIDE_PATR_DMAEN(chp->channel, drive);
		if ((drvp->drive_flags & DRIVE_UDMA) == 0)
			continue;

		if ((iiocr & RDCIDE_IIOCR_CABLE(chp->channel, drive)) == 0
		    && drvp->UDMA_mode > 2)
			drvp->UDMA_mode = 2;
		udccr |= RDCIDE_UDCCR_EN(chp->channel, drive);
		udccr |= RDCIDE_UDCCR_TIM(rdcide_udmatim[drvp->UDMA_mode],
			chp->channel, drive);
		iiocr |= RDCIDE_IIOCR_CLK(rdcide_udmaclk[drvp->UDMA_mode],
			chp->channel, drive);
	}

	pci_conf_write(sc->sc_pc, sc->sc_tag, RDCIDE_PATR, patr);
	pci_conf_write(sc->sc_pc, sc->sc_tag, RDCIDE_PSD1ATR, psd1atr);
	pci_conf_write(sc->sc_pc, sc->sc_tag, RDCIDE_UDCCR, udccr);
	pci_conf_write(sc->sc_pc, sc->sc_tag, RDCIDE_IIOCR, iiocr);
}
@


1.357
log
@Goto a loop_end label rather than using a continue statement for an
error condition in an inner loop. Found with Coccinelle.

Pointed out by tedu@@, ok kettenis@@ and deraadt@@ about three months ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.356 2015/11/24 11:24:21 mpi Exp $	*/
d128 3
d1544 5
@


1.356
log
@Double the delay between the PHY reset and the status check for
ServerWorks SATA.

Allow to reliably found disks on xserve G5.

from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.355 2015/10/18 20:24:10 uaa Exp $	*/
d6979 1
a6979 1
				continue;
d7025 2
@


1.355
log
@The change of 5.7's sys/arch/i386/i386/bus_space.c and
sys/arch/i386/include/bus.h invokes the kernel crash at boot
when ignored (disabled) channel is detected.

In all ATA controllers, ignored (disabled) channel is still set cp->hwok = 1.
And pciide_mapregs_native() is not called, wdc_cp->cmd_iot is 0.

5.6 and before, cmd_iot = 0 is treated as I386_BUS_SPACE_IO,
so there is no problem to call bus_space_read_1() in wdcintr().

5.7 and after, cmd_iot is used as function pointer.
We have to initialize it with pciide_mapregs_native() or something,
otherwise set cp->hwok = 0 to prevent calling wdcintr().

When ignored (disabled) channel is found, default_chip_map() should set
cp->hwok = 0. So all controllers do same thing.

ok by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.354 2015/09/10 18:10:34 deraadt Exp $	*/
d7931 1
a7931 1
	delay(50 * 1000);
@


1.354
log
@sizes for free(); ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.353 2015/03/21 13:42:06 mpi Exp $	*/
d2787 1
d3311 1
d3585 1
d3788 1
a3788 1
	 if (channel != 0 && (ctrl & CMD_CTRL_2PORT) == 0) {
d3791 1
d5244 1
d5853 1
d6101 1
d6466 1
d7428 1
d8283 1
d8831 1
d9202 1
@


1.353
log
@Print speeds consistently.

ok brynet@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.352 2015/03/14 03:38:48 jsg Exp $	*/
d2568 1
a2568 1
		free(sc->sc_cookie, M_DEVBUF, 0);
d4286 2
a4287 1
	sc->sc_cookie = malloc(sizeof(*sl), M_DEVBUF, M_NOWAIT | M_ZERO);
d4559 2
a4560 1
	sc->sc_cookie = malloc(sizeof(*sl), M_DEVBUF, M_NOWAIT | M_ZERO);
d4888 2
a4889 1
	sc->sc_cookie = malloc(sizeof(*cy), M_DEVBUF, M_NOWAIT | M_ZERO);
d5146 2
a5147 1
	sc->sc_cookie = malloc(sizeof(*sis), M_DEVBUF, M_NOWAIT | M_ZERO);
d6802 2
a6803 1
	sc->sc_cookie = malloc(sizeof(*ps), M_DEVBUF, M_NOWAIT | M_ZERO);
d7722 2
a7723 1
	sc->sc_cookie = malloc(sizeof(*ss), M_DEVBUF, M_NOWAIT | M_ZERO);
@


1.352
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.351 2015/01/09 07:29:45 jsg Exp $	*/
d4528 1
a4528 1
		printf("%s: port %d: device present",
d4532 1
a4532 1
			printf(", speed: 1.5Gb/s");
d4535 1
a4535 1
			printf(", speed: 3.0Gb/s");
d7286 1
a7286 1
		printf("%s: port %d: device present",
d7290 1
a7290 1
			printf(", speed: 1.5Gb/s");
d7293 1
a7293 1
			printf(", speed: 3.0Gb/s");
d7987 1
a7987 1
		printf("%s: port %d: device present",
d7991 1
a7991 1
			printf(", speed: 1.5Gb/s");
d7994 1
a7994 1
			printf(", speed: 3.0Gb/s");
@


1.351
log
@match on C610
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.350 2014/12/19 22:44:58 guenther Exp $	*/
a120 1
#include <dev/pci/pciide_i31244_reg.h>
@


1.350
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.349 2014/10/16 19:30:59 kettenis Exp $	*/
d561 12
@


1.349
log
@Additonal registers needs to be saved in sc_save2, not sc_save.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.348 2014/08/13 07:45:37 jsg Exp $	*/
d92 1
a94 1
#include <machine/endian.h>
@


1.348
log
@match on Intel 9 series and 9 series LP PCH, and add 8 series KT to puc
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.347 2014/07/13 23:19:51 sasano Exp $	*/
d1578 1
a1578 1
			sc->sc_save[0] = pci_conf_read(sc->sc_pc,
d1580 1
a1580 1
			sc->sc_save[1] = pci_conf_read(sc->sc_pc,
d1625 1
a1625 1
			    SII3112_SCS_CMD, sc->sc_save[0]);
d1628 1
a1628 1
			    SII3112_PCI_CFGCTL, sc->sc_save[1]);
@


1.347
log
@pciide.c, pciide_rdc_reg.h(new): ported rdcide(4) from NetBSD.
it supports RDC's R1012 IDE controller.

tested on 86duino EduCake (DM&P Vortex86EX SoC)

ok by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.346 2014/07/12 18:48:52 tedu Exp $	*/
d625 8
@


1.346
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.345 2014/04/24 15:38:25 jsg Exp $	*/
d126 1
d286 3
d1342 7
d1393 3
a1395 1
	  nitems(pciide_phison_products) }
d1597 1
d9120 147
@


1.345
log
@no need to check for default_chip_map twice in one if statement
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.344 2014/04/24 04:11:17 jsg Exp $	*/
d2535 1
a2535 1
		free(sc->sc_cookie, M_DEVBUF);
@


1.344
log
@match some more intel sata devices in ide mode
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.343 2013/12/06 21:03:04 deraadt Exp $	*/
a1585 1
		    sc->sc_pp->chip_map == default_chip_map ||
@


1.343
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.342 2013/05/27 21:19:31 miod Exp $	*/
d556 4
d588 60
d649 8
@


1.342
log
@Fix edge cases of uninitialized variables. In my tree for too long, I even
got ok's for azalia but I don't remember from whom.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.341 2013/01/05 08:27:48 jasper Exp $	*/
a1464 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
a1500 3
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		break;
d1553 3
@


1.341
log
@- add some intel 7 series sata ids.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.340 2012/10/08 21:47:50 deraadt Exp $	*/
d5983 1
@


1.340
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.339 2012/04/22 14:22:28 miod Exp $	*/
d569 12
@


1.339
log
@VT6410 and VT6415 controllers do not implement the `channel enable' register,
so don't incorrectly assume both channels are disabled on these controllers.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.338 2012/03/13 21:32:42 kettenis Exp $	*/
d1491 3
@


1.338
log
@Don't call wdcintr() for channels that aren't properly initialized or don't
have any drives on them.  Fixes a panic seen on sparc64 machines with that
pesky Acer Labs chipset.

ok deraadt@@, krw@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.337 2012/01/15 15:16:23 jsg Exp $	*/
d3335 1
a3335 1
	int channel;
d3351 9
a3359 6
	if ((PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT6410) ||
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT6415) ||
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_CX700_IDE) ||
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VX700_IDE) ||
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VX855_IDE) ||
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VX900_IDE)) { 
d3362 2
a3363 1
	} else {
d3428 1
d3461 8
a3468 5
		ideconf = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_IDECONF);
		if ((ideconf & APO_IDECONF_EN(channel)) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			continue;
d3480 5
a3484 3
			ideconf &= ~APO_IDECONF_EN(channel);
			pci_conf_write(sc->sc_pc, sc->sc_tag, APO_IDECONF,
			    ideconf);
@


1.337
log
@As SiS IDE has the same PCI product id for different revisions
with different bugs the host bridge is used to determine which path
to take.  As pointed out by Chris Cappuccio we need to expand
this list to cover newer chips SiS have inflicted on the world.
From and tested by Loganaden Velvindron (on SiS 968).
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.336 2012/01/04 03:38:59 jsg Exp $	*/
d1839 3
@


1.336
log
@Add support for SiS 1183 SATA. From/tested by Loganaden Velvindron.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.335 2011/11/12 18:39:23 guenther Exp $	*/
d4969 3
a4971 1
	{PCI_PRODUCT_SIS_965, 0x00, 6, "965", SIS_TYPE_133NEW}
@


1.335
log
@Unbreak tree after kettenis's sanitization in pcidevs

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.334 2011/11/02 23:04:20 jsg Exp $	*/
d750 4
@


1.334
log
@Make sure we set UDMA capabilities for HT-1000 IDE,
this was missed when support for HT-1000 IDE was added.
From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.333 2011/09/17 12:23:19 jsg Exp $	*/
d1104 1
a1104 1
	{ PCI_PRODUCT_NVIDIA_MCP65_SATA,
d1108 1
a1108 1
	{ PCI_PRODUCT_NVIDIA_MCP65_SATA2,
d1112 1
a1112 1
	{ PCI_PRODUCT_NVIDIA_MCP65_SATA3,
d1116 1
a1116 1
	{ PCI_PRODUCT_NVIDIA_MCP65_SATA4,
d1120 1
a1120 1
	{ PCI_PRODUCT_NVIDIA_MCP67_SATA,
d1124 1
a1124 1
	{ PCI_PRODUCT_NVIDIA_MCP67_SATA2,
d1128 1
a1128 1
	{ PCI_PRODUCT_NVIDIA_MCP67_SATA3,
d1132 1
a1132 1
	{ PCI_PRODUCT_NVIDIA_MCP67_SATA4,
@


1.333
log
@use default_chip_unmap for sata_chip_map, lets the via controllers detach
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.332 2011/07/15 16:44:18 deraadt Exp $	*/
d7431 1
@


1.332
log
@Cope with the start-dma-before-init errata and some other register setup
errata for the Serverworks SATA chipset found on the macppc xserve G5.
ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.331 2011/07/11 17:10:37 jcs Exp $	*/
d2481 1
@


1.331
log
@pass the interface for non-compat-mode piix.  from netbsd.

ok deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.330 2011/05/09 22:33:54 matthew Exp $	*/
d7640 10
d7745 1
@


1.330
log
@Refactor queue allocation and initialization into a wdc_alloc_queue()
function, and let attachment code calls this rather than malloc(9).
This prevents re-initialization of the queue in shared queue chipsets.
Also, add wdc_free_queue() as a complementary function.

Earlier version (without wdc_free_queue()) tested by sthen@@ and Amit
Kulkarni on various pciide(4) chips.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.329 2011/05/09 22:25:50 matthew Exp $	*/
d2656 1
a2656 2
		/* PIIX is compat-only */
		if (pciide_chansetup(sc, channel, 0) == 0)
d2665 1
a2665 2
		/* PIIX are compat-only pciide devices */
		pciide_map_compat_intr(pa, cp, channel, 0);
d2668 2
a2669 1
		pciide_mapchan(pa, cp, 0, &cmdsize, &ctlsize, pciide_pci_intr);
d2683 1
a2683 1
			pciide_unmap_compat_intr(pa, cp, channel, 0);
@


1.329
log
@Initialize the wdc ata_drive_datas structs earlier in wdcattach() so
that chip-specific drv_probe routines can assume they've already been
initialized.

Tested by sthen@@ on i386, armish, and amd64, with both affected and
non-affected pciide(4) chips.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.328 2011/04/27 07:55:05 jsg Exp $	*/
d2158 1
a2158 2
	cp->wdc_channel.ch_queue =
	    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);
d2161 1
a2161 1
		    "cannot allocate memory for command queue",
d2175 1
a2175 1
		free(cp->wdc_channel.ch_queue, M_DEVBUF);
d3638 1
a3638 2
		cp->wdc_channel.ch_queue =
		    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);
d3642 1
a3642 1
		    "%s: %s cannot allocate memory for command queue",
d4002 1
a4002 2
	cp->wdc_channel.ch_queue =
	    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);
d4005 1
a4005 1
		    "can't allocate memory for command queue",
d4604 1
a4604 2
	cp->wdc_channel.ch_queue =
	    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);
d4607 1
a4607 1
		    "can't allocate memory for command queue",
d4803 1
a4803 2
	cp->wdc_channel.ch_queue =
	    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);
d4805 1
a4805 1
		printf(": cannot allocate memory for command queue\n");
d6802 1
a6802 2
		cp->wdc_channel.ch_queue =
		    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);
d6805 1
a6805 1
			    "can't allocate memory for command queue\n",
@


1.328
log
@support Intel 6 series SATA in non raid/non ahci mode.
tested by Daniel Dickman
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.327 2011/04/18 04:16:12 deraadt Exp $	*/
d4304 1
a4304 7
	int i, s;

	/* XXX This should be done by other code. */
	for (i = 0; i < 2; i++) {
		chp->ch_drive[i].chnl_softc = chp;
		chp->ch_drive[i].drive = i;
	}
d7100 1
a7100 7
	int i, s;

	/* XXX This should be done by other code. */
	for (i = 0; i < 2; i++) {
		chp->ch_drive[i].chnl_softc = chp;
		chp->ch_drive[i].drive = i;
	}
d7754 1
a7754 7
	int i, s;

	/* XXX This should be done by other code. */
	for (i = 0; i < 2; i++) {
		chp->ch_drive[i].chnl_softc = chp;
		chp->ch_drive[i].drive = i;
	}
@


1.327
log
@keep an eye out for wdc registers returning 0xff.  if they return 0xff,
this probably means the controller is dead -- as in, a hot plug eject
event.  in that case, mark the driver dead and try harder to return -1
in the interrupt handler.
tested by many
ok dlg, miod did not object
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.326 2011/04/14 22:24:34 jsg Exp $	*/
d553 16
@


1.326
log
@add support for VIA VT6415 & VX900 IDE
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.325 2011/04/07 14:56:38 miod Exp $	*/
d2076 2
@


1.325
log
@Avoid using an uninitialized variable when downgrading PIO mode too much on
ITExpress chipsets. (similar to 1.243, with a deja vu)
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.324 2011/04/03 15:36:03 jasper Exp $	*/
d667 4
d683 4
d3328 1
d3331 2
a3332 1
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VX855_IDE)) { 
@


1.324
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.323 2010/11/18 18:12:52 kettenis Exp $	*/
d8453 1
@


1.323
log
@Mark NVIDIA MCP89 SATA controllers as such.  Makes them use DMA instead of PIO
such that we get decent performance out of them.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.322 2010/11/06 16:57:34 kettenis Exp $	*/
d1234 1
a1234 1
	  sizeof(pciide_intel_products)/sizeof(pciide_intel_products[0]) },
d1236 1
a1236 1
	  sizeof(pciide_amd_products)/sizeof(pciide_amd_products[0]) },
d1239 1
a1239 1
	  sizeof(pciide_opti_products)/sizeof(pciide_opti_products[0]) },
d1242 1
a1242 1
	  sizeof(pciide_cmd_products)/sizeof(pciide_cmd_products[0]) },
d1244 1
a1244 1
	  sizeof(pciide_via_products)/sizeof(pciide_via_products[0]) },
d1246 1
a1246 1
	  sizeof(pciide_cypress_products)/sizeof(pciide_cypress_products[0]) },
d1248 1
a1248 1
	  sizeof(pciide_sis_products)/sizeof(pciide_sis_products[0]) },
d1250 1
a1250 1
	  sizeof(pciide_natsemi_products)/sizeof(pciide_natsemi_products[0]) },
d1252 1
a1252 1
	  sizeof(pciide_acer_products)/sizeof(pciide_acer_products[0]) },
d1254 1
a1254 1
	  sizeof(pciide_triones_products)/sizeof(pciide_triones_products[0]) },
d1256 1
a1256 1
	  sizeof(pciide_acard_products)/sizeof(pciide_acard_products[0]) },
d1258 1
a1258 1
	  sizeof(pciide_serverworks_products)/sizeof(pciide_serverworks_products[0]) },
d1260 1
a1260 1
	  sizeof(pciide_promise_products)/sizeof(pciide_promise_products[0]) },
d1262 1
a1262 1
	  sizeof(pciide_nvidia_products)/sizeof(pciide_nvidia_products[0]) },
d1264 1
a1264 1
	  sizeof(pciide_ite_products)/sizeof(pciide_ite_products[0]) },
d1266 1
a1266 1
	  sizeof(pciide_ati_products)/sizeof(pciide_ati_products[0]) },
d1268 1
a1268 1
	  sizeof(pciide_jmicron_products)/sizeof(pciide_jmicron_products[0]) },
d1270 1
a1270 1
	  sizeof(pciide_phison_products)/sizeof(pciide_phison_products[0]) }
d1304 1
a1304 3
	for (i = 0, vp = pciide_vendors;
	    i < sizeof(pciide_vendors)/sizeof(pciide_vendors[0]);
	    vp++, i++)
d1308 1
a1308 1
	if (i == sizeof(pciide_vendors)/sizeof(pciide_vendors[0]))
@


1.322
log
@Revision 0xc4 and earlier of the Acer Labs M5229 UDMA IDE controller can't do
DMA for LBA48 commands.  Work around this issue by (silently) falling back
to PIO for LBA48 commands.  Access to the tail end of large disks will be much
slower, but at least it works.

From NetBSD (Takeshi Nakayama).

ok jsg@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.321 2010/08/31 17:13:44 deraadt Exp $	*/
d1129 16
@


1.321
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.320 2010/08/31 16:02:25 deraadt Exp $	*/
d218 1
d5633 2
d5827 11
@


1.320
log
@no need to specially handle the 4 AMD756 registers at suspend/resume time;
they fall within the pcipower() handled range.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.319 2010/08/31 12:50:51 miod Exp $	*/
d1410 3
@


1.319
log
@PCI configuration space register save/restore for AMD756.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.318 2010/08/06 05:34:29 deraadt Exp $	*/
a1443 9
		} else if (sc->sc_pp->chip_map == amd756_chip_map) {
			sc->sc_save2[0] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, AMD756_CHANSTATUS_EN);
			sc->sc_save2[1] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, AMD756_DATATIM);
			sc->sc_save2[2] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, AMD756_CYCLE_ADDR_TIME);
			sc->sc_save2[3] = pci_conf_read(sc->sc_pc,
			    sc->sc_tag, AMD756_UDMA);
d1455 1
a1491 9
		} else if (sc->sc_pp->chip_map == amd756_chip_map) {
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    AMD756_CHANSTATUS_EN, sc->sc_save2[0]);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    AMD756_DATATIM, sc->sc_save2[1]);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    AMD756_CYCLE_ADDR_TIME, sc->sc_save2[2]);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    AMD756_UDMA, sc->sc_save2[3]);
@


1.318
log
@ok, that is the last of the easy chips to check for register saves.  i'm
going to give up on reading gobs of crap for a while and hope that someone
else takes on the next few.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.317 2010/08/06 02:47:27 deraadt Exp $	*/
d1444 9
d1500 9
@


1.317
log
@another set of chips which do not need register rewrites at resume time
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.316 2010/08/03 21:53:02 deraadt Exp $	*/
d1459 2
a1460 1
		    sc->sc_pp->chip_map == apollo_chip_map) {
@


1.316
log
@no special registers to restore on via chips either
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.315 2010/08/02 13:50:33 deraadt Exp $	*/
d1453 1
@


1.315
log
@jmicron code was writing to the wrong register; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.314 2010/08/02 05:14:34 deraadt Exp $	*/
d1457 2
a1458 1
		    sc->sc_pp->chip_map == default_chip_map) {
@


1.314
log
@Save/restore more registers at suspend/resume for those chips which look
like they need it.  (Or don't, when it appears they don't need it)
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.313 2010/07/28 18:31:51 deraadt Exp $	*/
d8651 1
a8651 1
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_CONF, conf);
@


1.313
log
@the default pciide chip needs no additional register restores; tested by jcs on one model
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.312 2010/07/28 15:50:19 deraadt Exp $	*/
d1434 10
d1452 7
a1458 2
		if (sc->sc_pp->chip_map == default_chip_map) {
			/* nothing more to restore */
a1470 6
		} else if (sc->sc_pp->chip_map == piix_chip_map) {
			/* nothing more to restore */
		} else if (sc->sc_pp->chip_map == phison_chip_map) {
			/* nothing more to restore */
		} else if (sc->sc_pp->chip_map == ixp_chip_map) {
			/* nothing to restore (0x40 - 0x56) */
d1478 10
@


1.312
log
@suspend save/restore for SIS3112; tested by mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.311 2010/07/23 07:47:13 jsg Exp $	*/
d1442 3
a1444 1
		if (sc->sc_pp->chip_map == sch_chip_map) {
@


1.311
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.310 2010/07/23 02:50:04 deraadt Exp $	*/
d1429 5
d1460 7
@


1.310
log
@For suspend/reume, ATI IXP chips (might) need 0x40-0x56 saved.. but
these the 6 registers already saved
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.309 2010/07/22 18:11:16 deraadt Exp $	*/
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Manuel Bouyer.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.309
log
@When suspending, save & restore as many registers as we can from the
pciide front-ends chips.  More registers will have to added here, chip
by chip (warning messages about unknown chipsets, on resume, mean that
you should talk to me).  Also call the wdc back-end (our child) to have
it reset the controller properly on resume.  This makes all pciide that
we've tested unsuspend.
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.308 2010/04/20 06:59:47 jsg Exp $	*/
a1434 4
		} else if (sc->sc_pp->chip_map == piix_chip_map) {
			/* nothing to save */
		} else if (sc->sc_pp->chip_map == phison_chip_map) {
			/* nothing to save */
d1459 2
@


1.308
log
@Don't write garbage to the config space for phison,
we shouldn't be touching the config space at all here.

Found by the clang static analyser.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.307 2010/04/11 16:58:06 kettenis Exp $	*/
d1412 2
d1417 24
d1442 27
a1471 1

@


1.307
log
@Send "STANDBY IMMEDIATE" command to ATA disks upon suspend.  For this to work,
pciide(4) needs to formward DVACT_SUSPEND and DVACT_RESUME events to its
children, so do that.

Gets rid of the nasty "click" sound from the disk on many laptops.

ok marco@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.306 2009/11/21 14:34:20 jsg Exp $	*/
a8657 1
	u_int32_t conf;
a8697 3
	WDCDEBUG_PRINT(("%s: new conf register 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, conf), DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_CONF, conf);
@


1.306
log
@EP80579 SATA
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.305 2009/11/01 01:50:15 dlg Exp $	*/
d1268 1
d1271 2
a1272 1
	sizeof(struct pciide_softc), pciide_match, pciide_attach, pciide_detach,
d1276 2
a1277 1
	sizeof(struct pciide_softc), pciide_match, pciide_attach, pciide_detach,
d1406 15
@


1.305
log
@add support for the ati sb900^Whudson2 chips.

from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.304 2009/10/18 10:40:03 jsg Exp $	*/
d558 4
@


1.304
log
@Match on Intel 3400 SATA.
Tested by bwaichu@@yahoo.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.303 2009/10/17 00:49:05 jsg Exp $	*/
d587 4
@


1.303
log
@Match on MCP77 SATA.
From and tested by minusf@@obiit.org
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.302 2009/10/13 22:05:13 jsg Exp $	*/
d534 24
@


1.302
log
@Correct udma timing register offset and the udma mode ceiling
we allow for Intel SCH chips.

From tharada@@oucrc.org in PR 6232, verified against the datasheet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.301 2009/10/05 20:39:26 deraadt Exp $	*/
d1082 4
@


1.301
log
@Fill pciide_unmapregs_compat() with stuff which might work, if we ever get
there.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.300 2009/10/05 20:01:40 jsg Exp $	*/
d8735 1
a8735 1
	sc->sc_wdcdev.UDMA_cap = 6;
@


1.300
log
@Add some minimalistic detach/unmap bits for pciide,
done using a chipset unmap callback.

Still needs to work to distinguish between compat
register mappings and compat interrupts so we
don't get caught out.

Tested with a diskless sii3112 CardBus eSATA controller
by me, and testing and feedback by deraadt@@ with
a phison based expresscard SSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.299 2009/09/29 17:51:07 deraadt Exp $	*/
d1404 2
d1413 11
a1423 1
	panic("unmapregs_compat not implemented");
@


1.299
log
@Support the Phison PS5000.  IO Data and other vendors are now using this
on an expresscard SSD adaptor.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.298 2009/09/05 10:24:58 miod Exp $	*/
d1231 1
d1234 1
a1234 1
	sizeof(struct pciide_softc), pciide_match, pciide_attach
d1238 1
a1238 1
	sizeof(struct pciide_softc), pciide_match, pciide_attach
d1358 12
d1409 6
d1450 1
d1491 3
d1497 18
d1560 2
a1561 1
		    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL, 0) == 0);
d1580 6
d1980 8
d2009 13
d2241 18
d3966 2
d8593 2
@


1.298
log
@Remove unnecessary assignments in sii311[24]_chip_map().
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.297 2009/08/02 09:48:53 sthen Exp $	*/
d284 3
d1172 7
d1221 3
a1223 1
	  sizeof(pciide_jmicron_products)/sizeof(pciide_jmicron_products[0]) }
d8459 116
@


1.297
log
@Minor KNF from Brad. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.296 2009/06/26 02:46:27 kevlo Exp $	*/
d3861 1
a3861 1
	struct pciide_satalink *sl = sc->sc_cookie;
d4137 1
a4137 1
	struct pciide_satalink *sl = sc->sc_cookie;
@


1.296
log
@add the VIA VX855 chipset

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.295 2009/05/31 04:42:16 jsg Exp $	*/
d2735 1
a2735 1
				idetim =PIIX_IDETIM_SET(idetim,
d2749 1
a2749 1
			idetim =PIIX_IDETIM_SET(idetim,
@


1.295
log
@Add SCH IDE support code.
Tested on a p series vaio.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.294 2009/04/24 07:59:50 jsg Exp $	*/
d645 4
d3057 2
a3058 1
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VX700_IDE)) { 
@


1.294
log
@Add support for ICH10 SATA devices not operating in AHCI mode.
Tested by Christian Stuermer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.293 2009/02/07 02:09:01 jsg Exp $	*/
d284 3
d533 4
d8474 111
@


1.293
log
@Match on native/legacy MCP79 SATA ids.
From/Tested by Laurence Tratt on an asus p5n7a board.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.292 2009/01/04 10:37:40 jsg Exp $	*/
d508 16
@


1.292
log
@Add support for CS5535 IDE adapted from the gcscide code in NetBSD
originally written by Juan Romero Pardines.

Thanks to Lars Kotthoff for testing on a HeroLogic HL-463 system.

Because the CS5535 doesn't provide SMM emulated PCI access to set
DMA/PIO modes or a real PCI IDE controller we have to resort to
making MSR calls.  As this is very MD specific, hide most of uglyness
away in i386 MD pciide code.

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.291 2009/01/04 10:22:01 jsg Exp $	*/
d1052 16
@


1.291
log
@Shift prototypes for some common pciide functions out into
a header file where MD code can get at them.

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.290 2008/10/02 16:00:41 deraadt Exp $	*/
d674 4
d679 6
@


1.290
log
@backout Tadpole specific non-dma workaround commited in  1.287, since it
appears the machine Mark got had a disk which failed very soon after
that
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.289 2008/09/25 19:06:57 chl Exp $	*/
a283 15
u_int8_t pciide_dmacmd_read(struct pciide_softc *, int);
void pciide_dmacmd_write(struct pciide_softc *, int, u_int8_t);
u_int8_t pciide_dmactl_read(struct pciide_softc *, int);
void pciide_dmactl_write(struct pciide_softc *, int, u_int8_t);
void pciide_dmatbl_write(struct pciide_softc *, int, u_int32_t);

void pciide_channel_dma_setup(struct pciide_channel *);
int  pciide_dma_table_setup(struct pciide_softc *, int, int);
int  pciide_dma_init(void *, int, int, void *, size_t, int);
void pciide_dma_start(void *, int, int);
int  pciide_dma_finish(void *, int, int, int);
void pciide_irqack(struct channel_softc *);
void pciide_print_modes(struct pciide_channel *);
void pciide_print_channels(int, pcireg_t);

a1177 20

int	pciide_mapregs_compat( struct pci_attach_args *,
	    struct pciide_channel *, int, bus_size_t *, bus_size_t *);
int	pciide_mapregs_native(struct pci_attach_args *,
	    struct pciide_channel *, bus_size_t *, bus_size_t *,
	    int (*pci_intr)(void *));
void	pciide_mapreg_dma(struct pciide_softc *,
	    struct pci_attach_args *);
int	pciide_chansetup(struct pciide_softc *, int, pcireg_t);
void	pciide_mapchan(struct pci_attach_args *,
	    struct pciide_channel *, pcireg_t, bus_size_t *, bus_size_t *,
	    int (*pci_intr)(void *));
int	pciide_chan_candisable(struct pciide_channel *);
void	pciide_map_compat_intr( struct pci_attach_args *,
	    struct pciide_channel *, int, int);
void	pciide_unmap_compat_intr( struct pci_attach_args *,
	    struct pciide_channel *, int, int);
int	pciide_compat_intr(void *);
int	pciide_pci_intr(void *);
int	pciide_intr_flag(struct pciide_channel *);
@


1.289
log
@remove dead stores and newly created unused variable.

Found by LLVM/Clang Static Analyzer.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.288 2008/09/17 06:14:09 brad Exp $	*/
a133 5
#ifdef __sparc64__
#include <machine/autoconf.h>
#include <machine/openfirm.h>
#endif

a5342 3
#ifdef __sparc64__
	char buf[32];
#endif
a5347 12

#ifdef __sparc64__
	/*
	 * XXX The Tadpole SPARCLE doesn't want to do DMA.  PIO works
	 * fine, so we have this ugly hack to make the machine work.
	 * It is likely the real cause is still lurking somewhere in
	 * the code.
	 */
	if (OF_getprop(findroot(), "name", buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "TAD,SPARCLE") == 0)
		sc->sc_dma_ok = 0;
#endif
@


1.288
log
@Update for renamed ATI PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.287 2008/07/29 20:09:11 kettenis Exp $	*/
a4235 1
	struct pciide_channel *pc;
a4251 1
		pc = &sc->pciide_channels[chan];
a8469 1
			mode = 0;
@


1.287
log
@Add an ugly hack to disable DMA on the Tadpole SPARCLE laptop.  It doesn't
work and this way we fall back on PIO which does work.  I'm pretty sure
this is caused by bugs in our code, but I cannot find them.

ok deraadt@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.286 2008/07/08 05:59:39 brad Exp $	*/
d1079 1
a1079 1
	{ PCI_PRODUCT_ATI_IXP_IDE_200,
d1083 1
a1083 1
	{ PCI_PRODUCT_ATI_IXP_IDE_300,
d1087 1
a1087 1
	{ PCI_PRODUCT_ATI_IXP_IDE_400,
d1091 1
a1091 1
	{ PCI_PRODUCT_ATI_IXP_IDE_600,
d1095 1
a1095 1
	{ PCI_PRODUCT_ATI_IXP_IDE_700,
d1099 1
a1099 1
	{ PCI_PRODUCT_ATI_IXP_SATA_300,
d1103 1
a1103 1
	{ PCI_PRODUCT_ATI_IXP_SATA_400_1,
d1107 1
a1107 1
	{ PCI_PRODUCT_ATI_IXP_SATA_400_2,
@


1.286
log
@Remove the IDE_PCI_CLASS_OVERRIDE quirk flag for the Intel AHCI controllers
as they're of the subclass SATA and the SiI3512 SATA controller as it is of
the subclass MISC.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.285 2008/07/06 10:38:52 jsg Exp $	*/
d134 5
d5350 3
d5358 12
@


1.285
log
@pciide_match() is a bit convoluted, we match anything claiming
to be MASS_STORAGE subclass IDE regardless of id, and other
ids depending on the subclass and a known id or a known id
and the override flag.

We really want to check the subclass so we don't attach
pciide to the wrong function of a chip, which happened
last time around before the additional subclasses were
checked in the non override case and the overrides were pulled.

A bunch of the override flags were pulled after some common
subclasses (SATA/RAID) were added.  So if we have a known
id and a SATA/RAID subclass we would match.  Turns out some
Silicon Image SATA devices claim to be of subclass MISC
so add that as well.  Unbreaks one of hennings machines
with 3114 SATA and likely quite a few other machines.

'seems safe enough to me' miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.284 2008/06/13 17:03:26 maja Exp $	*/
d447 1
a447 1
	  IDE_PCI_CLASS_OVERRIDE,
d459 1
a459 1
	  IDE_PCI_CLASS_OVERRIDE,
d471 1
a471 1
	  IDE_PCI_CLASS_OVERRIDE,
d479 1
a479 1
	  IDE_PCI_CLASS_OVERRIDE,
d491 1
a491 1
	  IDE_PCI_CLASS_OVERRIDE,
d603 1
a603 1
	  IDE_PCI_CLASS_OVERRIDE,
@


1.284
log
@Restore IDE_PCI_CLASS_OVERRIDE on SiI3512 SATA.

On socppc it has the subclass PCI_SUBCLASS_MASS_STORAGE_MISC
so without the quirk socppc will not find its disk.

-moj
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.283 2008/06/11 05:28:33 brad Exp $	*/
d1280 1
@


1.283
log
@Remove the IDE_PCI_CLASS_OVERRIDE quirk flag for Intel (except AHCI),
CMD Technology, Silicon Image, VIA, SiS, Broadcom, and ATI IDE/SATA
chipsets.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.282 2008/04/29 11:40:58 jsg Exp $	*/
d603 1
a603 1
	  0,
@


1.282
log
@Change sis_chip_map() to use pci_find_device() as the original
NetBSD code it was based on did/does, now we have it.

This makes detecting sis 96x work properly without having to
do silly things like adding host bridges in the list.  Of
course we wouldn't be in this mess in the first place if sis
designed their chips properly instead of reusing the same
pci id.

Add 964/965 devices while here.

Tested by todd@@ on a machine with 965.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.281 2008/02/27 20:10:29 kettenis Exp $	*/
d403 1
a403 1
	  IDE_PCI_CLASS_OVERRIDE,
d407 1
a407 1
	  IDE_PCI_CLASS_OVERRIDE,
d411 1
a411 1
	  IDE_PCI_CLASS_OVERRIDE,
d415 1
a415 1
	  IDE_PCI_CLASS_OVERRIDE,
d419 1
a419 1
	  IDE_PCI_CLASS_OVERRIDE,
d423 1
a423 1
	  IDE_PCI_CLASS_OVERRIDE,
d427 1
a427 1
	  IDE_PCI_CLASS_OVERRIDE,
d431 1
a431 1
	  IDE_PCI_CLASS_OVERRIDE,
d435 1
a435 1
	  IDE_PCI_CLASS_OVERRIDE,
d439 1
a439 1
	  IDE_PCI_CLASS_OVERRIDE,
d443 1
a443 1
	  IDE_PCI_CLASS_OVERRIDE,
d451 1
a451 1
	  IDE_PCI_CLASS_OVERRIDE,
d455 1
a455 1
	  IDE_PCI_CLASS_OVERRIDE,
d463 1
a463 1
	  IDE_PCI_CLASS_OVERRIDE,
d467 1
a467 1
	  IDE_PCI_CLASS_OVERRIDE,
d475 1
a475 1
	  IDE_PCI_CLASS_OVERRIDE,
d483 1
a483 1
	  IDE_PCI_CLASS_OVERRIDE,
d487 1
a487 1
	  IDE_PCI_CLASS_OVERRIDE,
d495 1
a495 1
	  IDE_PCI_CLASS_OVERRIDE,
d587 1
a587 1
	  IDE_PCI_CLASS_OVERRIDE,
d591 1
a591 1
	  IDE_PCI_CLASS_OVERRIDE,
d599 1
a599 1
	  IDE_PCI_CLASS_OVERRIDE,
d603 1
a603 1
	  IDE_PCI_CLASS_OVERRIDE,
d607 1
a607 1
	  IDE_PCI_CLASS_OVERRIDE,
d610 2
a611 2
	{ PCI_PRODUCT_CMDTECH_3114,	/* SiI3114 */
	  IDE_PCI_CLASS_OVERRIDE,
d638 1
a638 1
	  IDE_PCI_CLASS_OVERRIDE,
d642 1
a642 1
	  IDE_PCI_CLASS_OVERRIDE,
d646 1
a646 1
	  IDE_PCI_CLASS_OVERRIDE,
d658 1
a658 1
	  IDE_PCI_CLASS_OVERRIDE,
d676 1
a676 1
	  IDE_PCI_CLASS_OVERRIDE,
d680 1
a680 1
	  IDE_PCI_CLASS_OVERRIDE,
d684 1
a684 1
	  IDE_PCI_CLASS_OVERRIDE,
d894 1
a894 1
	  IDE_PCI_CLASS_OVERRIDE,
d1095 1
a1095 1
	  IDE_PCI_CLASS_OVERRIDE,
d1099 1
a1099 1
	  IDE_PCI_CLASS_OVERRIDE,
d1103 1
a1103 1
	  IDE_PCI_CLASS_OVERRIDE,
@


1.281
log
@Add ICH8M SATA IDE support, and adjust for renamed ICH7 and ICH8 IDs.

tested by drahn@@, "looks right to me" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.280 2008/02/05 20:22:22 blambert Exp $	*/
d4662 3
a4664 1
	{PCI_PRODUCT_SIS_963, 0x00, 6, "963", SIS_TYPE_133NEW}
a4703 2
	pcitag_t br_tag;
	struct pci_attach_args br_pa;
d4710 1
a4710 6
	/* Find PCI bridge (dev 0 func 0 on the same bus) */
	br_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, 0, 0);
	br_pa.pa_id = pci_conf_read(sc->sc_pc, br_tag, PCI_ID_REG);
	br_pa.pa_class = pci_conf_read(sc->sc_pc, br_tag, PCI_CLASS_REG);
	WDCDEBUG_PRINT(("%s: PCI bridge pa_id=0x%x pa_class=0x%x\n",
	    __func__, br_pa.pa_id, br_pa.pa_class), DEBUG_PROBE);
d4712 1
a4712 1
	if (sis_hostbr_match(&br_pa)) {
d4722 1
a4722 13
				/* Find ISA bridge (func 0 of the same dev) */
				br_tag = pci_make_tag(pa->pa_pc, pa->pa_bus,
				    pa->pa_device, 0);
				br_pa.pa_id = pci_conf_read(sc->sc_pc,
				    br_tag, PCI_ID_REG);
				br_pa.pa_class = pci_conf_read(sc->sc_pc,
				    br_tag, PCI_CLASS_REG);
				WDCDEBUG_PRINT(("%s: ISA bridge "
				    "pa_id=0x%x pa_class=0x%x\n",
				    __func__, br_pa.pa_id, br_pa.pa_class),
				    DEBUG_PROBE);

				if (sis_south_match(&br_pa)) {
@


1.280
log
@de-inline pciide, shaving a goodly amount off the kernel

ok jsg@@ "please kill it" marco@@ "no objections" krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.279 2008/01/29 10:34:00 jsg Exp $	*/
d446 1
a446 1
	{ PCI_PRODUCT_INTEL_82801GR_SATA, /* Intel 82801GR (ICH7R) SATA */
d450 1
a450 1
	{ PCI_PRODUCT_INTEL_82801GR_AHCI, /* Intel 82801GR (ICH7R) AHCI */
d462 1
a462 1
	{ PCI_PRODUCT_INTEL_82801GHM_RAID, /* Intel 82801GHM (ICH7-M DH) SATA */
d466 1
a466 1
	{ PCI_PRODUCT_INTEL_82801H_SATA_1_6P, /* Intel 82801H (ICH8) SATA */
d470 1
a470 1
	{ PCI_PRODUCT_INTEL_82801H_AHCI, /* Intel 82801H (ICH8) AHCI */
d474 1
a474 1
	{ PCI_PRODUCT_INTEL_82801H_RAID, /* Intel 82801H (ICH8) SATA */
d478 1
a478 1
	{ PCI_PRODUCT_INTEL_82801H_SATA_1_4P, /* Intel 82801H (ICH8) SATA */
d486 5
a490 1
	{ PCI_PRODUCT_INTEL_82801HBM_SATA_1, /* Intel 82801HBM (ICH8M) SATA */
d494 1
a494 1
	{ PCI_PRODUCT_INTEL_82801HBM_SATA_2, /* Intel 82801HBM (ICH8M) SATA */
@


1.279
log
@Add support for VIA VT8237S SATA.
From Antonio Marques <froz@@icix.org> in PR 5718.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.278 2008/01/11 11:30:56 jsg Exp $	*/
a110 6
#if defined(SMALL_KERNEL)
#define	INLINE
#else
#define	INLINE __inline
#endif

d134 1
a134 1
/* inlines for reading/writing 8-bit PCI registers */
d136 1
a136 1
static INLINE u_int8_t pciide_pci_read(pci_chipset_tag_t, pcitag_t,
d138 1
a138 1
static INLINE void pciide_pci_write(pci_chipset_tag_t, pcitag_t,
d141 1
a141 1
static INLINE u_int8_t
d148 1
a148 1
static INLINE void
d170 3
a172 3
static u_int32_t piix_setup_idetim_timings(u_int8_t, u_int8_t, u_int8_t);
static u_int32_t piix_setup_idetim_drvs(struct ata_drive_datas *);
static u_int32_t piix_setup_sidetim_timings(u_int8_t, u_int8_t, u_int8_t);
d233 2
d2745 1
a2745 1
static u_int32_t
d2762 1
a2762 1
static u_int32_t
d2817 1
a2817 1
static u_int32_t
d5880 1
a5880 1
static INLINE u_int8_t
a5890 14
}

/* unused */
static __inline void
pdc268_config_write(struct channel_softc *chp, int index, u_int8_t value)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;

	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_INDEX(channel), index);
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_DATA(channel), value);
@


1.278
log
@Turns out the id I thought was both CX700/VX700 IDE was only for VX700,
so rename it and add a CX700 id.

Tweaked version of a diff from dtrombley@@dslindiana.com who tested
with a board with the new id.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.277 2008/01/02 06:54:30 brad Exp $	*/
d650 4
@


1.277
log
@Add the ATI SB700 chipset.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.276 2007/11/27 16:22:13 martynas Exp $	*/
d633 4
d3033 2
a3034 1
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_CX700_IDE)) { 
@


1.276
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.275 2007/10/17 22:11:52 brad Exp $	*/
d1079 4
@


1.275
log
@Add the Intel ICH9 chipset.

Tested by damien@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.274 2007/10/09 23:26:05 krw Exp $	*/
d2224 1
a2224 1
			WDCDEBUG_PRINT((", udamreg 0x%x",
@


1.274
log
@malloc+bzero -> malloc+M_ZERO. Use 'malloc(sizeof(*p) ...' idiom.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.273 2007/09/14 23:18:25 brad Exp $	*/
d501 24
@


1.273
log
@add the NVIDIA MCP73/MCP77 IDE controller PCI ids.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.272 2007/07/02 14:01:14 dlg Exp $	*/
d3807 1
a3807 2
	sc->sc_cookie = malloc(sizeof(struct pciide_satalink), M_DEVBUF,
	    M_NOWAIT);
a3808 1
	bzero(sl, sizeof(*sl));
d4083 1
a4083 2
	sc->sc_cookie = malloc(sizeof(struct pciide_satalink), M_DEVBUF,
	    M_NOWAIT);
a4084 1
	bzero(sl, sizeof(*sl));
d4414 1
a4414 1
	sc->sc_cookie = malloc(sizeof(struct pciide_cy), M_DEVBUF, M_NOWAIT);
a4415 1
	bzero(cy, sizeof(*cy));
d4670 1
a4670 1
	sc->sc_cookie = malloc(sizeof(struct pciide_sis), M_DEVBUF, M_NOWAIT);
a4671 1
	bzero(sis, sizeof(*sis));
d6342 1
a6342 2
	sc->sc_cookie = malloc(sizeof(struct pciide_pdcsata), M_DEVBUF,
	    M_NOWAIT);
a6343 1
	bzero(ps, sizeof(*ps));
d7267 1
a7267 2
	sc->sc_cookie = malloc(sizeof(struct pciide_svwsata), M_DEVBUF,
	    M_NOWAIT);
a7268 1
	bzero(ss, sizeof(*ss));
@


1.272
log
@kettenis suggested that i can use pci_intr_map twice on the same device
safely, so i tried it and it worked great. i can reuse the pci_attach_args
to attach ahci and now pciide to jmb without really modifying either of
them. lots of code shrinks.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.271 2007/06/26 17:48:18 kettenis Exp $	*/
d929 8
@


1.271
log
@Make natsemi_pci_intr() use pciide_intr_flag().  Needed on the PC87415 part
integrated on the PC87560 Legacy IO chip found on several hppa workstation
models.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.270 2007/06/20 04:10:59 jsg Exp $	*/
d1065 16
d1138 5
a1142 1
struct cfattach pciide_ca = {
@


1.270
log
@Add support for VIA CX700/VX700 IDE.
Tested by jcs@@ on a model 2 oqo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.269 2007/06/02 18:44:44 jsg Exp $	*/
d5109 1
a5109 1
	u_int8_t ide_dmactl, msk;
d5125 2
a5126 7
		/* Get intr status */
		ide_dmactl = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(i));

		if (ide_dmactl & IDEDMA_CTL_ERR)
			printf("%s:%d: error intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
d5128 7
a5134 8
		if (ide_dmactl & IDEDMA_CTL_INTR) {
			crv = wdcintr(wdc_cp);
			if (crv == 0)
				printf("%s:%d: bogus intr\n",
				    sc->sc_wdcdev.sc_dev.dv_xname, i);
			else
				rv = 1;
		}
@


1.269
log
@Add support for ICH8M IDE.
Tested by Daniel Dickman <didickman@@gmail.com>

pciide(4) does not need to be updated as it does not split
SATA/IDE support up into different sections (ICH8M already listed).
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.268 2007/05/11 13:26:20 jsg Exp $	*/
d605 4
d2972 2
a2973 1
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT6410) { 
@


1.268
log
@Ditch acard_pci_intr() as nothing currently uses it.
Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.267 2007/05/10 17:41:50 kettenis Exp $	*/
d498 4
d2186 1
d2232 1
d2256 1
d2586 1
d2601 2
a2602 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_IDE) {
@


1.267
log
@Don't skip channels that don't have the WDCF_IRQ_WAIT flag set.  Apparently
some chips generate interrupts we don't expect, but we need to ack those.
Fixes the cdrom hangs on various sparc64 systems.

tested by some, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.266 2007/05/02 00:53:25 jsg Exp $	*/
a257 1
int  acard_pci_intr(void *);
a7737 34
}

int
acard_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int rv = 0;
	int dmastat, i, crv;

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(i));
		if ((dmastat & IDEDMA_CTL_INTR) == 0)
			continue;
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		if ((wdc_cp->ch_flags & WDCF_IRQ_WAIT) == 0) {
			(void)wdcintr(wdc_cp);
			bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
			    IDEDMA_CTL(i), dmastat);
			continue;
		}
		crv = wdcintr(wdc_cp);
		if (crv == 0)
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
		else if (crv == 1)
			rv = 1;
		else if (rv == 0)
			rv = crv;
	}
	return (rv);
@


1.266
log
@Another VIA VT8237A SATA.
Tested by Graeme Lee <graeme@@omni.net.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.265 2007/03/27 15:40:18 deraadt Exp $	*/
a1495 3
			continue;
		/* if this channel not waiting for intr, skip */
		if ((wdc_cp->ch_flags & WDCF_IRQ_WAIT) == 0)
@


1.265
log
@this level of serverworks sata does not help
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.263 2007/03/21 12:20:30 jsg Exp $	*/
d612 4
@


1.264
log
@disable serverworks sata until it works (been busted for a year on the
G5, might work a lot better soon)
@
text
@a849 1
#if 0
a853 1
#endif
@


1.263
log
@Basic support for JMicron PATA.
JMB368 supported for now, multi port cards
that share PATA/SATA need to do a complicated
internal channel mapping dance I plan to look into next.

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.262 2006/11/21 21:48:54 brad Exp $	*/
d850 1
d855 1
@


1.262
log
@fix dmesg printing for the artisea chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.261 2006/11/19 21:45:49 brad Exp $	*/
d137 1
d286 3
d1053 7
d1100 3
a1102 1
	  sizeof(pciide_ati_products)/sizeof(pciide_ati_products[0]) }
d8315 144
@


1.261
log
@Re-enable the Intel i31244 support now that real hardware actually exists.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.260 2006/11/05 20:27:42 brad Exp $	*/
d7966 1
a7966 2
	printf("%s: DMA",
	    sc->sc_wdcdev.sc_dev.dv_xname);
@


1.260
log
@add the MCP67 PATA and SATA PCI ids as well as fixing nforce_chip_map() to
set the proper UDMA capability for MCP61 and MCP65 chipsets.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.259 2006/10/19 09:55:47 tom Exp $	*/
d319 4
a406 6
#ifdef notyet
	{ PCI_PRODUCT_INTEL_31244,	 /* Intel 31244 SATA */
	  0,
	  artisea_chip_map
	},
#endif
a7957 1
#ifdef notyet
d7968 1
a7968 1
#ifndef PCIIDE_I31244_ENABLEDMA
a8009 1
#endif
@


1.259
log
@Match the IDE controller in the AMD Geode companion device CS5536.
The disk in the AMD Geode LX-800-based system now works much faster.

hints grange@@; ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.258 2006/10/02 17:56:41 brad Exp $	*/
d915 4
d990 16
d7792 1
a7792 8
	case PCI_PRODUCT_NVIDIA_NFORCE2_IDE:
	case PCI_PRODUCT_NVIDIA_NFORCE2_400_IDE:
	case PCI_PRODUCT_NVIDIA_NFORCE3_IDE:
	case PCI_PRODUCT_NVIDIA_NFORCE3_250_IDE:
	case PCI_PRODUCT_NVIDIA_NFORCE4_ATA133:
	case PCI_PRODUCT_NVIDIA_MCP04_IDE:
	case PCI_PRODUCT_NVIDIA_MCP51_IDE:
	case PCI_PRODUCT_NVIDIA_MCP55_IDE:
a7793 3
		break;
	default:
		sc->sc_wdcdev.UDMA_cap = 0;
@


1.258
log
@sync the ServerWorks ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.257 2006/09/26 06:53:41 jsg Exp $	*/
d517 4
@


1.257
log
@Shrink the number of matches done in piixsata_chip_map,
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.256 2006/09/26 06:45:13 jsg Exp $	*/
d856 1
a856 1
	{ PCI_PRODUCT_RCC_HT_1000_SATA,
d860 1
a860 1
	{ PCI_PRODUCT_RCC_SATA,
@


1.256
log
@Move some duplicated debug code into its own function.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.255 2006/09/19 03:34:49 brad Exp $	*/
d2311 1
a2311 6
	case PCI_PRODUCT_INTEL_82801GB_SATA:
	case PCI_PRODUCT_INTEL_82801GR_SATA:
	case PCI_PRODUCT_INTEL_82801GR_AHCI:
	case PCI_PRODUCT_INTEL_82801GBM_SATA:
	case PCI_PRODUCT_INTEL_82801GBM_AHCI:
	case PCI_PRODUCT_INTEL_82801GHM_RAID:
a2312 11
		break;
	case PCI_PRODUCT_INTEL_82801H_SATA_1_6P:
	case PCI_PRODUCT_INTEL_82801H_AHCI:
	case PCI_PRODUCT_INTEL_82801H_RAID:
	case PCI_PRODUCT_INTEL_82801H_SATA_1_4P:
	case PCI_PRODUCT_INTEL_82801H_SATA_2:
	case PCI_PRODUCT_INTEL_82801HBM_SATA_1:
	case PCI_PRODUCT_INTEL_82801HBM_SATA_2:
	case PCI_PRODUCT_INTEL_6321ESB_SATA:
	default:
		ich = 8;
@


1.255
log
@add a missing space to a DMA load error printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.254 2006/09/16 00:46:56 jsg Exp $	*/
d173 1
d2118 39
d2233 1
a2233 35
	WDCDEBUG_PRINT(("piix_setup_chip: old idetim=0x%x",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM)),
	    DEBUG_PROBE);
	if (sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_IDE &&
	    sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_ISA) {
		WDCDEBUG_PRINT((", sidetim=0x%x",
		    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM)),
		    DEBUG_PROBE);
		if (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {
			WDCDEBUG_PRINT((", udamreg 0x%x",
			    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG)),
			    DEBUG_PROBE);
		}
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6321ESB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBL_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82372FB_IDE) {
			WDCDEBUG_PRINT((", IDE_CONTROL 0x%x",
			    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG)),
			    DEBUG_PROBE);
		}

	}
	WDCDEBUG_PRINT(("\n"), DEBUG_PROBE);
d2269 1
a2269 34
	WDCDEBUG_PRINT(("piix_setup_chip: idetim=0x%x",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM)),
	    DEBUG_PROBE);
	if (sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_IDE &&
	    sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_ISA) {
		WDCDEBUG_PRINT((", sidetim=0x%x",
		    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM)),
		    DEBUG_PROBE);
		if (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {
			WDCDEBUG_PRINT((", udamreg 0x%x",
			    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG)),
			    DEBUG_PROBE);
		}
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6321ESB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBL_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82372FB_IDE) {
			WDCDEBUG_PRINT((", IDE_CONTROL 0x%x",
			    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG)),
			    DEBUG_PROBE);
		}
	}
	WDCDEBUG_PRINT(("\n"), DEBUG_PROBE);
@


1.254
log
@Support for Intel 6321ESB SATA.  Tested on one of cloder's new
Xeon systems.

ok cloder@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.253 2006/09/16 00:39:54 jsg Exp $	*/
d1626 1
a1626 1
		printf("%s:%d: unable to load xfer DMA map for"
@


1.253
log
@Match VIA VT8237A SATA which while untested should act like
the older VIA SATA devices for our purposes going by FreeBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.252 2006/08/19 17:59:00 jsg Exp $	*/
d495 4
d2353 2
@


1.252
log
@Support for Intel 82801H/ICH8 SATA parts, untested but should
work like the previous generation for our purposes going by the
datasheet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.251 2006/08/19 17:38:56 jsg Exp $	*/
d596 4
@


1.251
log
@Be sure to set the mode for AHCI capable Intel SATA correctly and
move things around to make ICH8 additions easier.
Thanks to several people who tested various configs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.250 2006/08/06 01:24:38 brad Exp $	*/
d467 28
d2337 9
@


1.250
log
@add the Intel 6321ESB IDE controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.249 2006/07/23 02:12:12 brad Exp $	*/
d2270 1
a2270 1
	u_int8_t reg, ich7 = 0;
d2290 22
d2317 1
a2317 6
	switch(sc->sc_pp->ide_product) {
	/* ICH 5 */
	case PCI_PRODUCT_INTEL_6300ESB_SATA:
	case PCI_PRODUCT_INTEL_6300ESB_SATA2:
	case PCI_PRODUCT_INTEL_82801EB_SATA:
	case PCI_PRODUCT_INTEL_82801ER_SATA:
d2329 1
a2329 13
		break;
	/* ICH 7 */
	case PCI_PRODUCT_INTEL_82801GB_SATA:
	case PCI_PRODUCT_INTEL_82801GR_SATA:
	case PCI_PRODUCT_INTEL_82801GR_AHCI:
	case PCI_PRODUCT_INTEL_82801GBM_SATA:
	case PCI_PRODUCT_INTEL_82801GBM_AHCI:
	case PCI_PRODUCT_INTEL_82801GHM_RAID:
		ich7 = 1;
	/* ICH 6 */
	case PCI_PRODUCT_INTEL_82801FB_SATA:
	case PCI_PRODUCT_INTEL_82801FR_SATA:
	case PCI_PRODUCT_INTEL_82801FBM_SATA:
d2339 5
d2349 6
a2354 7
			if (ich7)
				reg &= ~ICH7_SATA_MAP_SMS_MASK;

			pciide_pci_write(pa->pa_pc, pa->pa_tag,
			    ICH5_SATA_PI, reg);
			interface |= PCIIDE_INTERFACE_PCI(0) |
			    PCIIDE_INTERFACE_PCI(1);
a2355 1
		break;
@


1.249
log
@add NVidia MCP61/65 ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.248 2006/07/16 13:24:14 jsg Exp $	*/
d420 4
d2098 2
a2113 1
		case PCI_PRODUCT_INTEL_6300ESB_IDE:
d2127 2
a2136 1
	case PCI_PRODUCT_INTEL_6300ESB_IDE:
d2170 3
a2172 1
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||
a2181 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE ||
d2240 3
a2242 1
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||
a2251 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE ||
d2297 2
a2300 2
	case PCI_PRODUCT_INTEL_6300ESB_SATA:
	case PCI_PRODUCT_INTEL_6300ESB_SATA2:
d2518 3
a2520 1
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||
a2529 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE ||
d2535 3
a2537 1
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BAM_IDE ||
a2544 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE ||
@


1.248
log
@Match a few more Promise SATA chips which should work
if the FreeBSD driver is any indication.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.247 2006/07/10 21:28:29 deraadt Exp $	*/
d862 8
d911 28
@


1.247
log
@in pciide_mapregs_compat() explicitly enable PCI IO, then remove all the
checks in all the sub-drivers checking for this; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.246 2006/07/08 06:39:00 brad Exp $	*/
d721 4
d733 4
d749 4
d6250 1
d6253 1
d6257 1
d6322 1
d6325 1
d6336 1
@


1.246
log
@add the ATI IXP300 SATA PCI id.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.245 2006/07/07 03:56:33 brad Exp $	*/
a994 1
int	pciide_chipen(struct pciide_softc *, struct pci_attach_args *);
a1125 16
/* tell whether the chip is enabled or not */
int
pciide_chipen(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	pcireg_t csr;

	csr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);
	if ((csr & PCI_COMMAND_IO_ENABLE) == 0 ) {
		printf("\n%s: device disabled\n",
		    sc->sc_wdcdev.sc_dev.dv_xname);
		return (0);
	}

	return (1);
}

d1132 1
d1138 4
a1819 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a1951 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a2037 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a2215 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a2658 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a2853 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a3219 14
	/*
 	 * For a CMD PCI064x, the use of PCI_COMMAND_IO_ENABLE
	 * and base address registers can be disabled at
 	 * hardware level. In this case, the device is wired
	 * in compat mode and its first channel is always enabled,
	 * but we can't rely on PCI_COMMAND_IO_ENABLE.
	 * In fact, it seems that the first channel of the CMD PCI0640
	 * can't be disabled.
 	 */

#ifdef PCIIDE_CMD064x_DISABLE
	if (pciide_chipen(sc, pa) == 0)
		return;
#endif
a3257 14
	/*
	 * For a CMD PCI064x, the use of PCI_COMMAND_IO_ENABLE
	 * and base address registers can be disabled at
	 * hardware level. In this case, the device is wired
	 * in compat mode and its first channel is always enabled,
 	 * but we can't rely on PCI_COMMAND_IO_ENABLE.
	 * In fact, it seems that the first channel of the CMD PCI0640
	 * can't be disabled.
	*/

#ifdef PCIIDE_CMD064x_DISABLE
	if (pciide_chipen(sc, pa) == 0)
		return;
#endif
a3450 2
	if (pciide_chipen(sc, pa) == 0)
		return;
a3658 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a3936 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a4269 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a4526 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a4843 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a5033 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a5189 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a5409 2
	if (pciide_chipen(sc, pa) == 0)
		return;
a5751 2
	if (pciide_chipen(sc, pa) == 0)
		return;
a6781 2
	if (pciide_chipen(sc, pa) == 0)
		return;
a6951 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a7126 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a7460 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a7675 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a7878 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a7945 3
	if (pciide_chipen(sc, pa) == 0)
		return;

a8102 3

	if (pciide_chipen(sc, pa) == 0)
		return;
@


1.245
log
@Broadcom HT-1000 SATA no longer requires IDE_PCI_CLASS_OVERRIDE now that
pciide_match checks for the PCI SATA subclass.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.244 2006/07/07 00:01:15 jsg Exp $	*/
d920 8
a934 4
	},
	{ PCI_PRODUCT_ATI_IXP_IDE_600,
	  0,
	  ixp_chip_map
@


1.244
log
@Check for SATA and RAID subclasses if we have a matching PCI ID.
This should remove the need for most if not all of the override flags.
"looks safe to me" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.243 2006/06/26 22:14:59 miod Exp $	*/
d804 1
a804 1
	  IDE_PCI_CLASS_OVERRIDE,
@


1.243
log
@Avoid using an uninitialized variable when downgrading PIO mode too much on
nForce chipsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.242 2006/06/26 02:40:40 brad Exp $	*/
d1054 2
a1055 3
	 * Check the ID register to see that it's a PCI IDE controller.
	 * If it is, we assume that we can deal with it; it _should_
	 * work in a standardized way...
d1057 2
a1058 2
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_MASS_STORAGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_IDE) {
a1059 1
	}
d1062 3
a1064 2
 	 * Some controllers (e.g. promise Ultra-33) don't claim to be PCI IDE
	 * controllers. Let see if we can deal with it anyway.
d1066 18
a1083 3
	pp = pciide_lookup_product(pa->pa_id);
	if (pp  && (pp->ide_flags & IDE_PCI_CLASS_OVERRIDE)) {
		return (1);
@


1.242
log
@Add IDE_PCI_CLASS_OVERRIDE for ServerWorks HT-1000 SATA.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.241 2006/06/24 10:11:03 jsg Exp $	*/
d7884 1
@


1.241
log
@Somehow managed to miss including the part of Henrik's diff where
we actually match the PCI ID of the 40518 controller.
Pointed out by Henrik Flodell.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.240 2006/06/24 07:51:30 jsg Exp $	*/
d804 1
a804 1
	  0,
@


1.240
log
@Support for Promise PDC205xx based SATA controllers; adapted
from NetBSD, with additions of some more devices from
Aaron Linville and Henrik Flodell.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.239 2006/04/27 00:34:19 jsg Exp $	*/
d714 4
@


1.239
log
@Match the ICH7-M DH in RAID mode and ask for
IDE SATA mode of operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.238 2006/04/26 23:52:06 jsg Exp $	*/
d243 3
d716 24
d6284 29
a6312 3
	sc->sc_pci_ih = pci_intr_establish(pa->pa_pc,
	    intrhandle, IPL_BIO, pdc203xx_pci_intr, sc,
	    sc->sc_wdcdev.sc_dev.dv_xname);
d6352 39
a6390 4
	bus_space_write_4(ps->ba5_st, ps->ba5_sh, 0x06c, 0x00ff0033);
	sc->sc_wdcdev.nchannels =
	    (bus_space_read_4(ps->ba5_st, ps->ba5_sh, 0x48) & 0x02) ?
	    PDC203xx_NCHANNELS : 3;
d6540 33
d6668 111
@


1.238
log
@Remove ICH6M from case statements in IDE code now we
treat it like a SATA controller.
reminded by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.237 2006/04/26 15:15:46 jsg Exp $	*/
d456 4
d2238 1
@


1.237
log
@ATI IXP 600 IDE.  Hardware is not generally available yet
but should work going by Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.236 2006/04/25 09:09:42 jsg Exp $	*/
a2029 1
		case PCI_PRODUCT_INTEL_82801FBM_SATA:
a2051 1
	case PCI_PRODUCT_INTEL_82801FBM_SATA:
a2095 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_SATA ||
a2164 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_SATA ||
a2443 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_SATA ||
a2457 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_SATA ||
@


1.236
log
@Match PCI ids for Intel ICH7 SATA in AHCI mode.
Then ask for SATA IDE mode of operation.

X60/T60 Thinkpads are shipped in AHCI configuration by default,
this makes them work without changing a BIOS option.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.235 2006/04/23 15:08:34 jsg Exp $	*/
d892 4
@


1.235
log
@Allow Intel SATA to map compatibility interrupts.
This makes a bunch of ICH6M/ICH7M systems that don't present
an IDE controller work.
And stop treating ICH6M like an IDE controller now this works for everyone.

Thanks to all the people who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.234 2006/04/17 01:51:37 jsg Exp $	*/
d445 9
a453 1
	{ PCI_PRODUCT_INTEL_82801GBM_SATA, /* Intel 82801GB (ICH7M) SATA */
d2182 1
a2182 1
	u_int8_t reg;
d2228 7
a2238 4
	/* ICH 7 */
	case PCI_PRODUCT_INTEL_82801GB_SATA:
	case PCI_PRODUCT_INTEL_82801GR_SATA:
	case PCI_PRODUCT_INTEL_82801GBM_SATA:
d2247 9
@


1.234
log
@Match ICH7R SATA which while untested should work.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.233 2006/04/15 00:15:12 jsg Exp $	*/
d423 1
a423 1
	  piix_chip_map
a2178 7
	if (interface == 0) {
		WDCDEBUG_PRINT(("piixsata_chip_map interface == 0\n"),
		    DEBUG_PROBE);
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);
	}

a2180 1
	printf("\n");
d2186 2
a2189 2
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 6;
d2244 2
d2250 5
d2257 5
a2261 1
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
@


1.233
log
@Add support for non-RAID part of the ITExpress IT8212F.
From Hans-Guenter Weigand hgw at d1906.inka.de.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.232 2006/04/09 00:51:58 brad Exp $	*/
d437 5
a441 1
	{ PCI_PRODUCT_INTEL_82801GB_SATA_1, /* Intel 82801GB (ICH7) SATA */
d2233 2
a2234 2
	case PCI_PRODUCT_INTEL_82801GB_SATA_1:
	case PCI_PRODUCT_INTEL_82801GB_SATA_3:
@


1.232
log
@add another ServerWorks SATA PCI id.

From the Linux svw driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.231 2006/04/02 01:36:07 jsg Exp $	*/
d850 4
@


1.231
log
@To be able to use the maximum number of IDE/SATA disks on an ICH
system we have to make some channels native as there isn't enough
legacy I/O space/interrupts to go around.  Intel calls this
enhanced mode.

An updated and expanded version of a diff from Ulrik Holmn.

"looks sane" grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.230 2006/03/28 12:56:44 robert Exp $	*/
d757 4
@


1.230
log
@Add Intel 82801GB (ICH7M) SATA;

reported by Gabor Micsko <trey@@hup.hu>; ok jsg@@ marco@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.229 2006/03/27 20:33:38 kettenis Exp $	*/
d2162 1
d2192 47
@


1.229
log
@Add IDE_PCI_CLASS_OVERRIDE for ServerWorks K2 SATA.
ok grange@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.228 2006/03/27 09:59:26 jsg Exp $	*/
d438 4
@


1.228
log
@Split the chip map for Intel SATA out into a seperate function
for readability/maintainability.
Tested by several people on ICH6-M/ICH7

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.227 2006/03/06 19:32:18 kettenis Exp $	*/
d741 1
a741 1
	  0,
@


1.227
log
@Make UDMA on the VT8237 work again.
ok jsg@@, grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.226 2006/02/24 20:59:04 kettenis Exp $	*/
d170 1
d393 1
a393 1
	  piix_chip_map
d397 1
a397 1
	  piix_chip_map
d411 1
a411 1
	  piix_chip_map
d415 1
a415 1
	  piix_chip_map
d427 1
a427 1
	  piix_chip_map
d431 1
a431 1
	  piix_chip_map
d439 1
a439 1
	  piix_chip_map
a1999 2
		case PCI_PRODUCT_INTEL_82801EB_SATA:
		case PCI_PRODUCT_INTEL_82801ER_SATA:
a2000 2
		case PCI_PRODUCT_INTEL_6300ESB_SATA:
		case PCI_PRODUCT_INTEL_6300ESB_SATA2:
a2002 2
		case PCI_PRODUCT_INTEL_82801FB_SATA:
		case PCI_PRODUCT_INTEL_82801FR_SATA:
a2003 1
		case PCI_PRODUCT_INTEL_82801GB_SATA_1:
a2022 2
	case PCI_PRODUCT_INTEL_82801EB_SATA:
	case PCI_PRODUCT_INTEL_82801ER_SATA:
a2023 2
	case PCI_PRODUCT_INTEL_6300ESB_SATA:
	case PCI_PRODUCT_INTEL_6300ESB_SATA2:
a2025 2
	case PCI_PRODUCT_INTEL_82801FB_SATA:
	case PCI_PRODUCT_INTEL_82801FR_SATA:
a2026 1
	case PCI_PRODUCT_INTEL_82801GB_SATA_1:
d2033 2
a2034 10
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_SATA2 ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FR_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_SATA_1) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_SATA;
		sc->sc_wdcdev.set_modes = sata_setup_channel;
	} else if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371FB_IDE ||
a2044 9
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_SATA2 ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FR_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_SATA_1)
		goto chansetup;

a2080 1
chansetup:
a2083 17
		/* SATA setup */
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_SATA ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FR_SATA ||
		    sc->sc_pp->ide_product ==
		    PCI_PRODUCT_INTEL_82801GB_SATA_1) {
			if (pciide_chansetup(sc, channel, interface) == 0)
				continue;
			pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
			    pciide_pci_intr);
			if (cp->hw_ok == 0)
				continue;
			sc->sc_wdcdev.set_modes(&cp->wdc_channel);
			continue;
		}

a2114 9
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_SATA2 ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FR_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_SATA_1)
		return;

d2149 47
@


1.226
log
@Make ServerWorks SATA less chatty.  Sprinkle some KNF while I'm there.
ok brad@@, grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.225 2006/02/10 21:45:41 kettenis Exp $	*/
d2739 2
a2740 2
	pcitag_t pcib_tag;
	pcireg_t pcib_id, pcib_class;
d2759 17
a2775 11
		/* Determine the DMA capabilities by looking at the ISA bridge. */
		pcib_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, pa->pa_device, 0);
		pcib_id = pci_conf_read(sc->sc_pc, pcib_tag, PCI_ID_REG);
		pcib_class = pci_conf_read(sc->sc_pc, pcib_tag, PCI_CLASS_REG);

		/* XXX On the VT8237, the ISA bridge is on a different device. */
		if (PCI_CLASS(pcib_class) != PCI_CLASS_BRIDGE && pa->pa_device == 15 &&
		    PCI_PRODUCT(pcib_id) == PCI_PRODUCT_VIATECH_VT82C571) {
			pcib_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, 17, 0);
			pcib_id = pci_conf_read(sc->sc_pc, pcib_tag, PCI_ID_REG);
			pcib_class = pci_conf_read(sc->sc_pc, pcib_tag, PCI_CLASS_REG);
d2778 1
a2778 1
		switch (PCI_PRODUCT(pcib_id)) {
d2780 1
a2780 1
			if (PCI_REVISION(pcib_class) >= 0x02) {
d2789 1
a2789 1
			if (PCI_REVISION(pcib_class) >= 0x12) {
d2799 1
a2799 1
			if (PCI_REVISION(pcib_class) >= 0x40) {
a2814 1
		case PCI_PRODUCT_VIATECH_VT6410:
@


1.225
log
@Fix LBA48 access for ServerWorks SATA.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.224 2006/02/03 11:50:34 brad Exp $	*/
d6887 7
d6895 2
a6896 4
			   PCI_MAPREG_TYPE_MEM |
			   PCI_MAPREG_MEM_TYPE_32BIT, 0,
			   &ss->ba5_st, &ss->ba5_sh,
			   NULL, NULL, 0) != 0) {
d7082 1
a7082 1
#if 1
d7133 1
a7133 1
#if 1
@


1.224
log
@add some more Intel PIIX IDE controllers..

- 82372FB  Ultra66
- 82371FB and 82371MX  Non-UDMA capable

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.223 2006/02/03 08:54:51 brad Exp $	*/
d7177 12
@


1.223
log
@add Intel 82451NX (PIIX4) and 82801DBL (ICH4-L).

ok grange@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.222 2006/02/01 09:32:42 jsg Exp $	*/
d322 8
d338 4
d1986 1
d2018 1
d2055 2
a2056 1
	} else if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371FB_IDE) {
d2078 2
a2079 1
	if (sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_IDE) {
d2101 2
a2102 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_IDE) {
d2175 2
a2176 1
	if (sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_IDE) {
d2198 2
a2199 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_IDE) {
d2368 2
a2369 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801GB_IDE) {
d2401 2
a2402 1
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE) {
@


1.222
log
@Add support for VIA VT6410.
Originally from Benoit Izac in PR 4995 reworked to
not be affected by the southbridge checking the other VIA
ids have to do by incorporating suggestions from brad@@ and kettenis@@.

ok brad@@ kettenis@@ grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.221 2006/01/24 12:25:51 jsg Exp $	*/
d334 4
d366 4
d1975 1
d1983 1
d2012 1
d2079 1
d2174 1
d2343 1
d2357 1
@


1.221
log
@Match a few more NVIDIA product ids found in Linux drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.220 2006/01/22 17:31:27 kettenis Exp $	*/
d511 4
d2699 1
a2699 1
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
d2706 10
d2719 6
a2724 8
	/* Determine the DMA capabilities by looking at the ISA bridge. */
	pcib_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, pa->pa_device, 0);
	pcib_id = pci_conf_read(sc->sc_pc, pcib_tag, PCI_ID_REG);
	pcib_class = pci_conf_read(sc->sc_pc, pcib_tag, PCI_CLASS_REG);

	/* XXX On the VT8237, the ISA bridge is on a different device. */
	if (PCI_CLASS(pcib_class) != PCI_CLASS_BRIDGE && pa->pa_device == 15) {
		pcib_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, 17, 0);
a2726 1
	}
d2728 6
a2733 8
	switch (PCI_PRODUCT(pcib_id)) {
	case PCI_PRODUCT_VIATECH_VT82C586_ISA:
		if (PCI_REVISION(pcib_class) >= 0x02) {
			printf(": ATA33");
			sc->sc_wdcdev.UDMA_cap = 2;
		} else {
			printf(": DMA");
			sc->sc_wdcdev.UDMA_cap = 0;
a2734 10
		break;
	case PCI_PRODUCT_VIATECH_VT82C596A:
		if (PCI_REVISION(pcib_class) >= 0x12) {
			printf(": ATA66");
			sc->sc_wdcdev.UDMA_cap = 4;
		} else {
			printf(": ATA33");
			sc->sc_wdcdev.UDMA_cap = 2;
		}
		break;
d2736 31
a2766 2
	case PCI_PRODUCT_VIATECH_VT82C686A_ISA:
		if (PCI_REVISION(pcib_class) >= 0x40) {
d2769 12
a2780 3
		} else {
			printf(": ATA66");
			sc->sc_wdcdev.UDMA_cap = 4;
a2781 16
		break;
	case PCI_PRODUCT_VIATECH_VT8231_ISA:
	case PCI_PRODUCT_VIATECH_VT8233_ISA:
		printf(": ATA100");
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
	case PCI_PRODUCT_VIATECH_VT8233A_ISA:
	case PCI_PRODUCT_VIATECH_VT8235_ISA:
	case PCI_PRODUCT_VIATECH_VT8237_ISA:
		printf(": ATA133");
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
	default:
		printf(": DMA");
		sc->sc_wdcdev.UDMA_cap = 0;
		break;
@


1.220
log
@Fix UDMA on IDE function integrated on VIA VT8237 south bridge.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.219 2006/01/01 18:40:08 kettenis Exp $	*/
d758 12
d805 8
d7383 3
@


1.219
log
@Adjust for renamed VIA VT8233 PCI ID's.
ok brad@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.218 2005/12/15 00:01:10 krw Exp $	*/
d2684 2
a2686 1

d2689 7
@


1.218
log
@Missing break and initializations found by lint.

ok jsg@@ uwe@@ grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.217 2005/10/26 21:07:38 brad Exp $	*/
d2719 1
a2719 1
	case PCI_PRODUCT_VIATECH_VT8366_ISA:
d2723 1
a2723 1
	case PCI_PRODUCT_VIATECH_VT8233_ISA:
@


1.217
log
@revert 82801FBM SATA controller back to being configured as an IDE controller
until someone can figure out why it works on some systems and not on others.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.216 2005/10/22 23:13:26 brad Exp $	*/
d4632 1
d4966 2
d7822 2
@


1.216
log
@check for 82801FBM SATA in one more spot.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.215 2005/10/22 23:03:30 brad Exp $	*/
a2000 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_SATA ||
a2019 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_SATA ||
d2048 1
a2064 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_SATA ||
a2113 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_SATA ||
d2142 1
d2310 1
d2323 1
@


1.215
log
@82801FBM_IDE -> 82801FBM_SATA
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.214 2005/10/20 18:30:06 brad Exp $	*/
d2116 1
@


1.214
log
@fix a typo in a Via PCI product id.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.213 2005/10/20 12:06:51 grange Exp $	*/
d400 1
a400 1
	{ PCI_PRODUCT_INTEL_82801FBM_IDE,  /* Intel 82801FBM (ICH6M) IDE */
d1958 1
a1958 1
		case PCI_PRODUCT_INTEL_82801FBM_IDE:
d1986 1
a1986 1
	case PCI_PRODUCT_INTEL_82801FBM_IDE:
d2001 1
d2021 1
a2049 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_IDE ||
d2066 1
a2143 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_IDE ||
a2310 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_IDE ||
a2322 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_IDE ||
@


1.213
log
@Don't try to match VIA ide chips as ISA bridges.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.212 2005/10/18 13:07:34 brad Exp $	*/
d515 1
a515 1
	{ PCI_PRODUCT_VIATECH_VT6420_SATA, /* VIA VT6421 SATA */
@


1.212
log
@Add some missing IDE/SATA interfaces..

- Via VT6421 SATA
- ServerWorks HT-1000 IDE
- ServerWorks Frodo4/Frodo8 and HT-1000 SATA
- NVidia NForce3 250 2nd channel, MCP04 and MCP51

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.211 2005/10/17 11:35:05 jsg Exp $	*/
d2725 1
a2725 3
	case PCI_PRODUCT_VIATECH_VT6420_SATA:
	case PCI_PRODUCT_VIATECH_VT6421_SATA:
	case PCI_PRODUCT_VIATECH_VT8251_SATA:
@


1.211
log
@Simplify case statement in apollo_chip_map().
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.210 2005/10/17 11:24:25 jsg Exp $	*/
d515 4
d711 4
d717 13
a729 1
	  svwsata_chip_map
d746 1
a746 1
	{ PCI_PRODUCT_NVIDIA_NFORCE2_400_SATA,
d748 1
a748 1
	  sata_chip_map
d750 1
a750 1
	{ PCI_PRODUCT_NVIDIA_NFORCE3_IDE,
d754 1
a754 1
	{ PCI_PRODUCT_NVIDIA_NFORCE3_250_IDE,
d758 4
d766 1
a766 1
	{ PCI_PRODUCT_NVIDIA_NFORCE4_ATA133,
d768 1
a768 1
	  nforce_chip_map
d777 16
d2726 1
@


1.210
log
@Recognise VT8251.  From Blake Willis <blake at 2112.net>.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.209 2005/10/17 06:43:48 grange Exp $	*/
a2678 3
		printf(": ATA100");
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
a2683 3
		printf(": ATA133");
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
a2684 3
		printf(": ATA133");
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
a2685 3
		printf(": ATA133");
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
@


1.209
log
@Don't clear dma_in_progress flag too early, noticed by jason@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.208 2005/10/17 06:35:17 grange Exp $	*/
d514 4
d2695 4
@


1.208
log
@Fixup cacheline on sii3114 like we do for sii3112;
from ragge@@netbsd via jason@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.207 2005/10/16 20:07:21 kettenis Exp $	*/
a1466 2
	sc->pciide_channels[channel].dma_in_progress = 0;

d1471 4
a1474 2
	if (force == 0 && (status & IDEDMA_CTL_INTR) == 0)
		return (WDC_DMAST_NOIRQ);
d1508 3
@


1.207
log
@ServerWorks SATA
ok deraadt@@, grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.206 2005/10/15 23:07:09 brad Exp $	*/
d194 1
d3417 36
a3458 1
	pcireg_t cls, reg40, reg44;
d3518 1
a3518 29
	/*
	 * When the Silicon Image 3112 retries a PCI memory read command,
	 * it may retry it as a memory read multiple command under some
	 * circumstances.  This can totally confuse some PCI controllers,
	 * so ensure that it will never do this by making sure that the
	 * Read Threshold (FIFO Read Request Control) field of the FIFO
	 * Valid Byte Count and Control registers for both channels (BA5
	 * offset 0x40 and 0x44) are set to be at least as large as the
	 * cacheline size register.
	 */
	cls = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	cls = (cls >> PCI_CACHELINE_SHIFT) & PCI_CACHELINE_MASK;
	cls *= 4;
	if (cls > 224) {
		cls = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
		cls &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);
		cls |= ((224/4) << PCI_CACHELINE_SHIFT);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, cls);
		cls = 224;
	}
	if (cls < 32)
		cls = 32;
	cls = (cls + 31) / 32;
	reg40 = ba5_read_4(sc, 0x40);
	reg44 = ba5_read_4(sc, 0x44);
	if ((reg40 & 0x7) < cls)
		ba5_write_4(sc, 0x40, (reg40 & ~0x07) | cls);
	if ((reg44 & 0x7) < cls)
		ba5_write_4(sc, 0x44, (reg44 & ~0x07) | cls);
d3801 2
@


1.206
log
@update Via and 3Com ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.205 2005/10/15 11:42:52 brad Exp $	*/
d136 1
d257 10
d701 4
d952 2
a953 1
	    pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG)), DEBUG_PROBE);
d6733 305
d7039 12
@


1.205
log
@Tweak names and add entries to the RCC (ServerWorks/Broadcom) PCI ids.

Based on Linux's pci.ids and sata_svw.c
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.204 2005/09/15 06:43:02 jsg Exp $	*/
d499 1
a499 1
	{ PCI_PRODUCT_VIATECH_VT8237_SATA, /* VIA VT8237 SATA */
d2670 1
a2670 1
	case PCI_PRODUCT_VIATECH_VT8237_SATA:
@


1.204
log
@Revert rev 1.202 for now as it breaks at least one machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.201 2005/08/18 13:40:00 jsg Exp $	*/
d687 1
a687 1
	{ PCI_PRODUCT_RCC_CSB6_IDE2,
d6575 3
a6579 3
	case PCI_PRODUCT_RCC_CSB6_IDE2:
		sc->sc_wdcdev.UDMA_cap = 4;
		break;
d6585 1
a6585 1
	    (sc->sc_pp->ide_product == PCI_PRODUCT_RCC_CSB6_IDE2 ? 1 : 2);
@


1.203
log
@Support for ATI IXP 200/300/400 IDE mostly based on changes
made by Quentin Garnier to NetBSD.
tested by tdeval@@ and ian@@, ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.202 2005/09/05 13:21:49 jsg Exp $	*/
d291 2
a292 1
#define IDE_16BIT_IOSPACE	0x0001	/* I/O space BARS ignore upper word */
d363 1
a363 1
	  0,
d373 1
a373 1
	  0,
d377 1
a377 1
	  0,
d381 1
a381 1
	  0,
d385 1
a385 1
	  0,
d389 1
a389 1
	  0,
d393 1
a393 1
	  0,
d397 1
a397 1
	  0,
d401 1
a401 1
	  0,
d405 1
a405 1
	  0,
d461 1
a461 1
	  0,
d465 1
a465 1
	  0,
d469 1
a469 1
	  0,
d473 1
a473 1
	  0,
d477 1
a477 1
	  0,
d481 1
a481 1
	  0,
d485 1
a485 1
	  0,
d500 1
a500 1
	  0,
d518 1
a518 1
	  0,
d522 1
a522 1
	  0,
d526 1
a526 1
	  0,
d551 1
a551 1
	  0,
d555 1
a555 1
	  0,
d559 1
a559 1
	  0,
d563 1
a563 1
	  0,
d567 1
a567 1
	  0,
d574 1
a574 1
	  0,
d578 1
a578 1
	  0,
d582 1
a582 1
	  0,
d586 1
a586 1
	  0,
d590 1
a590 1
	  0,
d594 1
a594 1
	  0,
d598 1
a598 1
	  0,
d602 1
a602 1
	  0,
d606 1
a606 1
	  0,
d610 1
a610 1
	  0,
d614 1
a614 1
	  0,
d618 1
a618 1
	  0,
d622 1
a622 1
	  0,
d626 1
a626 1
	  0,
d630 1
a630 1
	  0,
d634 1
a634 1
	  0,
d638 1
a638 1
	  0,
d642 1
a642 1
	  0,
d646 1
a646 1
	  0,
d653 1
a653 1
	  0,
d657 1
a657 1
	  0,
d661 1
a661 1
	  0,
d665 1
a665 1
	  0,
d669 1
a669 1
	  0,
d738 1
a738 1
	  0,
d757 1
a757 1
	  0,
d761 1
a761 1
	  0,
d875 1
d899 2
a900 1
	if (pciide_lookup_product(pa->pa_id)) 
d902 1
@


1.202
log
@If we have a match for the PCI ID we don't care what the PCI class is.
It is often not mass storage anyway.  Remove IDE_PCI_CLASS_OVERRIDE
which forced matching when class was not mass storage, just use PCI ID.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.201 2005/08/18 13:40:00 jsg Exp $	*/
d135 1
d265 3
d743 12
d7358 132
@


1.201
log
@Match nforce 2/3/4 SATA using generic sata_chip_map().
Tested by dlg@@ on nforce 3, and several people on
nforce 4. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.200 2005/08/18 13:05:59 jsg Exp $	*/
d287 1
a287 2
#define IDE_PCI_CLASS_OVERRIDE	0x0001	/* accept even if class != pciide */
#define IDE_16BIT_IOSPACE	0x0002	/* I/O space BARS ignore upper word */
d358 1
a358 1
	  IDE_PCI_CLASS_OVERRIDE,
d368 1
a368 1
	  IDE_PCI_CLASS_OVERRIDE,
d372 1
a372 1
	  IDE_PCI_CLASS_OVERRIDE,
d376 1
a376 1
	  IDE_PCI_CLASS_OVERRIDE,
d380 1
a380 1
	  IDE_PCI_CLASS_OVERRIDE,
d384 1
a384 1
	  IDE_PCI_CLASS_OVERRIDE,
d388 1
a388 1
	  IDE_PCI_CLASS_OVERRIDE,
d392 1
a392 1
	  IDE_PCI_CLASS_OVERRIDE,
d396 1
a396 1
	  IDE_PCI_CLASS_OVERRIDE,
d400 1
a400 1
	  IDE_PCI_CLASS_OVERRIDE,
d456 1
a456 1
	  IDE_PCI_CLASS_OVERRIDE,
d460 1
a460 1
	  IDE_PCI_CLASS_OVERRIDE,
d464 1
a464 1
	  IDE_PCI_CLASS_OVERRIDE,
d468 1
a468 1
	  IDE_PCI_CLASS_OVERRIDE,
d472 1
a472 1
	  IDE_PCI_CLASS_OVERRIDE,
d476 1
a476 1
	  IDE_PCI_CLASS_OVERRIDE,
d480 1
a480 1
	  IDE_PCI_CLASS_OVERRIDE,
d495 1
a495 1
	  IDE_PCI_CLASS_OVERRIDE,
d513 1
a513 1
	  IDE_PCI_CLASS_OVERRIDE,
d517 1
a517 1
	  IDE_PCI_CLASS_OVERRIDE,
d521 1
a521 1
	  IDE_PCI_CLASS_OVERRIDE,
d546 1
a546 1
	  IDE_PCI_CLASS_OVERRIDE,
d550 1
a550 1
	  IDE_PCI_CLASS_OVERRIDE,
d554 1
a554 1
	  IDE_PCI_CLASS_OVERRIDE,
d558 1
a558 1
	  IDE_PCI_CLASS_OVERRIDE,
d562 1
a562 1
	  IDE_PCI_CLASS_OVERRIDE,
d569 1
a569 1
	  IDE_PCI_CLASS_OVERRIDE,
d573 1
a573 1
	  IDE_PCI_CLASS_OVERRIDE,
d577 1
a577 1
	  IDE_PCI_CLASS_OVERRIDE,
d581 1
a581 1
	  IDE_PCI_CLASS_OVERRIDE,
d585 1
a585 1
	  IDE_PCI_CLASS_OVERRIDE,
d589 1
a589 1
	  IDE_PCI_CLASS_OVERRIDE,
d593 1
a593 1
	  IDE_PCI_CLASS_OVERRIDE,
d597 1
a597 1
	  IDE_PCI_CLASS_OVERRIDE,
d601 1
a601 1
	  IDE_PCI_CLASS_OVERRIDE,
d605 1
a605 1
	  IDE_PCI_CLASS_OVERRIDE,
d609 1
a609 1
	  IDE_PCI_CLASS_OVERRIDE,
d613 1
a613 1
	  IDE_PCI_CLASS_OVERRIDE,
d617 1
a617 1
	  IDE_PCI_CLASS_OVERRIDE,
d621 1
a621 1
	  IDE_PCI_CLASS_OVERRIDE,
d625 1
a625 1
	  IDE_PCI_CLASS_OVERRIDE,
d629 1
a629 1
	  IDE_PCI_CLASS_OVERRIDE,
d633 1
a633 1
	  IDE_PCI_CLASS_OVERRIDE,
d637 1
a637 1
	  IDE_PCI_CLASS_OVERRIDE,
d641 1
a641 1
	  IDE_PCI_CLASS_OVERRIDE,
d648 1
a648 1
	  IDE_PCI_CLASS_OVERRIDE,
d652 1
a652 1
	  IDE_PCI_CLASS_OVERRIDE,
d656 1
a656 1
	  IDE_PCI_CLASS_OVERRIDE,
d660 1
a660 1
	  IDE_PCI_CLASS_OVERRIDE,
d664 1
a664 1
	  IDE_PCI_CLASS_OVERRIDE,
d733 1
a733 1
	  IDE_PCI_CLASS_OVERRIDE,
d740 1
a740 1
	  IDE_PCI_CLASS_OVERRIDE,
d744 1
a744 1
	  IDE_PCI_CLASS_OVERRIDE,
a857 1
	const struct pciide_product_desc *pp;
d881 1
a881 2
	pp = pciide_lookup_product(pa->pa_id);
	if (pp  && (pp->ide_flags & IDE_PCI_CLASS_OVERRIDE)) {
a882 1
	}
@


1.200
log
@Several boards incorporating SIS SATA chips have dellusions of granduer
so we have to override the PCI class they claim to be. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.199 2005/08/09 04:10:13 mickey Exp $	*/
d702 4
d714 4
d721 8
@


1.199
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.198 2005/07/21 09:47:57 jsg Exp $	*/
d514 1
a514 1
	  0,
d518 1
a518 1
	  0,
d522 1
a522 1
	  0,
@


1.198
log
@ICH7 IDE/SATA support based diff from Marcello Balduccini in
NetBSD PR 30795. ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.197 2005/07/09 09:45:21 ho Exp $	*/
d878 1
a879 4
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;
	struct pciide_softc *sc = (struct pciide_softc *)self;
	pcireg_t csr;
a902 6

	if (sc->sc_dma_ok) {
		csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		csr |= PCI_COMMAND_MASTER_ENABLE;
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);
	}
@


1.197
log
@Missing pciide_print_modes() in pdc203xx_setup_channel(). fgsch@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.196 2005/06/15 04:45:48 fgsch Exp $	*/
d395 8
d1874 2
d1902 2
d1915 2
a1916 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FR_SATA) {
d1934 2
a1935 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FR_SATA)
d1961 2
a1962 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_IDE) {
d1979 3
a1981 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FR_SATA) {
d2028 2
a2029 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FR_SATA)
d2055 2
a2056 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_IDE) {
d2223 2
a2224 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_IDE) {
d2236 2
a2237 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FBM_IDE) {
@


1.196
log
@promise pdc203xx support; from bouyer@@netbsd.org via grange@@ with a few
tweaks by me. grange@@ ok who cannot commit atm.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.195 2005/06/08 20:43:40 fgsch Exp $	*/
d6138 1
@


1.195
log
@use SMALL_KERNEL for all arch's, not just alpha and also apply the defs
for sii3112 funcs; grange@@ mickey@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.194 2005/06/01 21:50:52 miod Exp $	*/
d233 7
d605 31
a635 3
	{ PCI_PRODUCT_PROMISE_PDC20376,	/* PDC20376 SATA */
	  IDE_PCI_CLASS_OVERRIDE,	/* XXX: subclass RAID */
	  pdc202xx_chip_map,
d5449 1
a5449 2
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)
d5457 1
a5457 2
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)
d5463 1
a5463 2
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)
a5527 2
	if (sc->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_SATA;
d5544 1
a5544 1
			pdc20268_setup_channel : pdc202xx_setup_channel;
d5948 317
@


1.194
log
@De-inline if option SMALL_KERNEL on alpha; saves 4KB off RAMDISK{,B}, other
kernels and platforms unaffected.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.193 2005/05/26 17:43:24 jsg Exp $	*/
d111 6
a137 6

#if defined(SMALL_KERNEL) && defined(__alpha__)
#define	INLINE
#else
#define	INLINE __inline
#endif
@


1.193
log
@nForce4 PATA support from Olivier Crouzet <ol at epita.fr>. ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.192 2005/04/29 01:11:46 jsg Exp $	*/
d132 8
a139 1
static __inline u_int8_t pciide_pci_read(pci_chipset_tag_t, pcitag_t,
d141 1
a141 1
static __inline void pciide_pci_write(pci_chipset_tag_t, pcitag_t,
d144 1
a144 1
static __inline u_int8_t
d151 1
a151 1
static __inline void
d5433 1
a5433 1
static __inline u_int8_t
d5446 1
@


1.192
log
@Support ATI IXP 400 SATA, which is a Silicon Image 3112 in sheep's clothing.
Tested by Pedro la Peu <pedro at am-gen.org>. ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.191 2005/04/20 00:57:25 jsg Exp $	*/
d659 4
d6570 1
@


1.191
log
@SiS 180/181/182 SATA support using generic sata_chip_map().
Hints from NetBSD and FreeBSD.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.187 2005/04/10 00:45:41 jsg Exp $	*/
d669 10
d718 3
a720 1
	  sizeof(pciide_ite_products)/sizeof(pciide_ite_products[0]) }
@


1.190
log
@Replace VIA SATA chip map routine with generic sata_chip_map().
ok grange@@
@
text
@d490 12
@


1.189
log
@SiS 760 support from a tech@@ mail from peter.galbavy at knowtion.net
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.188 2005/04/20 00:35:55 jsg Exp $	*/
d157 1
a171 1
void apollo_sata_chip_map(struct pciide_softc *, struct pci_attach_args *);
d475 1
a475 1
	  apollo_sata_chip_map
d1669 47
a2626 47
}

void
apollo_sata_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	int channel;
	bus_size_t cmdsize, ctlsize;

	if (pciide_chipen(sc, pa) == 0)
		return;

	if (interface == 0) {
		WDCDEBUG_PRINT(("apollo_sata_chip_map interface == 0\n"),
		    DEBUG_PROBE);
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);
	}

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA |
		    WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 6;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_SATA;
	sc->sc_wdcdev.set_modes = sata_setup_channel;

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		sata_setup_channel(&cp->wdc_channel);
	}
@


1.188
log
@SiS 661 support tested on a Gigabyte 8S661FXMP-RZ board.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.187 2005/04/10 00:45:41 jsg Exp $	*/
d4149 1
@


1.187
log
@Support for ICH6M IDE. Tested on a Dell Latitude D810 by
Raymond Lillard <rlillard at sonic.net>. ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.186 2005/02/21 19:55:50 grange Exp $	*/
d4136 1
@


1.186
log
@Support another Intel 6300ESB SATA.
Tested by Marc Wirth <MarcWirth@@mac.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.185 2005/02/01 21:53:55 grange Exp $	*/
d370 4
d1746 1
d1772 1
d1829 2
a1830 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_IDE) {
d1919 2
a1920 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_IDE) {
d2086 2
a2087 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_IDE) {
d2098 2
a2099 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801FB_IDE) {
@


1.185
log
@Correctly setup Intel 82801FB and 82801FR SATA; from aurelien6545@@free.fr.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.184 2005/01/31 04:25:44 martin Exp $	*/
d362 4
d1740 1
d1765 1
d1778 1
d1796 1
d1885 1
@


1.184
log
@The SiS 5513 is really a own design, partially revert my previous commit here.

pointed out by Chris Cappucio <chris at nmedia.net>; ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.183 2005/01/22 15:08:52 martin Exp $	*/
d1830 3
a1832 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA) {
@


1.183
log
@PCI_PRODUCT_SIS_5513 -> PCI_PRODUCT_SIS_5597_IDE

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.182 2005/01/15 15:23:39 jsg Exp $	*/
d479 1
a479 1
	{ PCI_PRODUCT_SIS_5597_IDE,		/* SIS 5597 EIDE */
@


1.182
log
@nForce2 Ultra 400 IDE support. ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.181 2004/12/11 08:39:28 henning Exp $	*/
d479 1
a479 1
	{ PCI_PRODUCT_SIS_5513,		/* SIS 5513 EIDE */
@


1.181
log
@nForce3-250, From: Brent Graveland <brent@@graveland.net>, grange ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.180 2004/11/27 09:14:23 grange Exp $	*/
d628 4
d6516 1
@


1.180
log
@KNF, ANSI, cleanup. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.179 2004/11/21 18:43:58 grange Exp $	*/
d627 8
d6512 2
@


1.179
log
@Intel ICH6/ICH6R IDE and SATA support.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.178 2004/10/19 13:07:00 grange Exp $	*/
d77 4
a80 4
#define DEBUG_DMA   0x01
#define DEBUG_XFERS  0x02
#define DEBUG_FUNCS  0x08
#define DEBUG_PROBE  0x10
d133 1
a133 1
					      int);
d135 1
a135 1
					   int, u_int8_t);
d138 1
a138 4
pciide_pci_read(pc, pa, reg)
	pci_chipset_tag_t pc;
	pcitag_t pa;
	int reg;
a139 1

d145 1
a145 5
pciide_pci_write(pc, pa, reg, val)
	pci_chipset_tag_t pc;
	pcitag_t pa;
	int reg;
	u_int8_t val;
d373 1
a373 1
	},
d409 1
a409 1
	},
a681 3
#ifndef __OpenBSD__
int	pciide_match(struct device *, struct cfdata *, void *);
#else
a682 1
#endif
d689 2
a690 3
#ifdef __OpenBSD__
struct        cfdriver pciide_cd = {
      NULL, "pciide", DV_DULL
d692 1
a692 1
#endif
d712 1
a712 1
int     pciide_intr_flag(struct pciide_channel *);
d717 1
a717 2
pciide_lookup_product(id)
	u_int32_t id;
d730 1
a730 1
		return NULL;
d737 2
a738 2
		return NULL;
	return pp;
d742 1
a742 8
pciide_match(parent, match, aux)
	struct device *parent;
#ifdef __OpenBSD__
	void *match;
#else
	struct cfdata *match;
#endif
	void *aux;
d778 1
a778 3
pciide_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d821 1
a821 3
pciide_chipen(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d829 1
a829 1
		return 0;
d832 1
a832 1
	return 1;
d836 2
a837 5
pciide_mapregs_compat(pa, cp, compatchan, cmdsizep, ctlsizep)
	struct pci_attach_args *pa;
	struct pciide_channel *cp;
	int compatchan;
	bus_size_t *cmdsizep, *ctlsizep;
d870 2
a871 5
pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep, pci_intr)
	struct pci_attach_args * pa;
	struct pciide_channel *cp;
	bus_size_t *cmdsizep, *ctlsizep;
	int (*pci_intr)(void *);
d885 1
a885 1
			return 0;
a887 1
#ifdef __OpenBSD__
a890 4
#else
		sc->sc_pci_ih = pci_intr_establish(pa->pa_pc,
		    intrhandle, IPL_BIO, pci_intr, sc);
#endif
d901 1
a901 1
			return 0;
d916 1
a916 1
		return 0;
d930 1
a930 1
		return 0;
d943 1
a943 1
		return 0;
d949 1
a949 3
pciide_mapreg_dma(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d966 1
a966 1
	 * XXX space," some controllers (at least the United
d1042 1
a1042 2
pciide_compat_intr(arg)
	void *arg;
d1047 1
a1047 1
		return 0;
d1058 1
a1058 2
pciide_pci_intr(arg)
	void *arg;
d1127 1
a1127 2
pciide_channel_dma_setup(cp)
	struct pciide_channel *cp;
d1155 1
a1155 3
pciide_dma_table_setup(sc, channel, drive)
	struct pciide_softc *sc;
	int channel, drive;
d1166 1
a1166 1
		return 0;
d1175 1
a1175 1
		return error;
d1185 1
a1185 1
		return error;
d1199 1
a1199 1
		return error;
d1208 1
a1208 1
		return error;
d1220 1
a1220 1
		return error;
d1222 1
a1222 1
	return 0;
d1226 2
a1227 6
pciide_dma_init(v, channel, drive, databuf, datalen, flags)
	void *v;
	int channel, drive;
	void *databuf;
	size_t datalen;
	int flags;
d1245 1
a1245 1
		return error;
d1304 1
a1304 1
	return 0;
d1308 1
a1308 3
pciide_dma_start(v, channel, drive)
	void *v;
	int channel, drive;
d1312 1
a1312 1
	WDCDEBUG_PRINT(("pciide_dma_start\n"),DEBUG_XFERS);
d1320 1
a1320 4
pciide_dma_finish(v, channel, drive, force)
	void *v;
	int channel, drive;
	int force;
d1336 1
a1336 1
		return WDC_DMAST_NOIRQ;
d1370 1
a1370 1
	return error;
d1374 1
a1374 2
pciide_irqack(chp)
	struct channel_softc *chp;
d1386 1
a1386 4
pciide_chansetup(sc, channel, interface)
	struct pciide_softc *sc;
	int channel;
	pcireg_t interface;
d1399 1
a1399 1
		return 0;
d1403 1
a1403 1
	return 1;
d1408 3
a1410 6
pciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)
	struct pci_attach_args *pa;
	struct pciide_channel *cp;
	pcireg_t interface;
	bus_size_t *cmdsizep, *ctlsizep;
	int (*pci_intr)(void *);
d1432 1
a1432 2
pciide_chan_candisable(cp)
	struct pciide_channel *cp;
d1442 1
a1442 1
		return 1;
d1444 1
a1444 1
	return 0;
d1452 2
a1453 4
pciide_map_compat_intr(pa, cp, compatchan, interface)
	struct pci_attach_args *pa;
	struct pciide_channel *cp;
	int compatchan, interface;
d1476 2
a1477 4
pciide_unmap_compat_intr(pa, cp, compatchan, interface)
	struct pci_attach_args *pa;
	struct pciide_channel *cp;
	int compatchan, interface;
d1488 1
a1488 3
pciide_print_channels(nchannels, interface)
	int nchannels;
	pcireg_t interface;
d1504 1
a1504 2
pciide_print_modes(cp)
	struct pciide_channel *cp;
d1510 1
a1510 3
default_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d1689 1
a1689 3
piix_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d1899 1
a1899 2
piix_setup_channel(chp)
	struct channel_softc *chp;
d2007 1
a2007 2
piix3_4_setup_channel(chp)
	struct channel_softc *chp;
d2099 1
a2099 1
			udmareg |= PIIX_UDMACTL_DRV_EN( channel,drive);
d2145 1
a2145 4
piix_setup_idetim_timings(mode, dma, channel)
	u_int8_t mode;
	u_int8_t dma;
	u_int8_t channel;
d2149 1
a2149 1
		return PIIX_IDETIM_SET(0,
d2152 1
a2152 1
		    channel);
d2154 1
a2154 1
		return PIIX_IDETIM_SET(0,
d2157 1
a2157 1
		    channel);
d2162 1
a2162 2
piix_setup_idetim_drvs(drvp)
	struct ata_drive_datas *drvp;
d2178 1
a2178 1
			return ret;
d2194 1
a2194 1
			return ret;
d2205 1
a2205 1
		return ret;
d2212 1
a2212 1
	return ret;
d2217 1
a2217 4
piix_setup_sidetim_timings(mode, dma, channel)
	u_int8_t mode;
	u_int8_t dma;
	u_int8_t channel;
d2220 2
a2221 2
		return PIIX_SIDETIM_ISP_SET(piix_isp_dma[mode], channel) |
		    PIIX_SIDETIM_RTC_SET(piix_rtc_dma[mode], channel);
d2223 2
a2224 2
		return PIIX_SIDETIM_ISP_SET(piix_isp_pio[mode], channel) |
		    PIIX_SIDETIM_RTC_SET(piix_rtc_pio[mode], channel);
d2228 1
a2228 3
amd756_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d2302 1
a2302 2
amd756_setup_channel(chp)
	struct channel_softc *chp;
d2414 1
a2414 3
apollo_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d2591 1
a2591 1
		     pciide_pci_intr);
d2597 1
a2597 2
apollo_setup_channel(chp)
	struct channel_softc *chp;
d2707 2
a2708 4
cmd_channel_map(pa, sc, channel)
	struct pci_attach_args *pa;
	struct pciide_softc *sc;
	int channel;
d2792 1
a2792 2
cmd_pci_intr(arg)
	void *arg;
d2821 1
a2821 1
	return rv;
d2825 1
a2825 3
cmd_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d2859 1
a2859 3
cmd0643_9_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d2970 1
a2970 2
cmd0643_9_setup_channel(chp)
	struct channel_softc *chp;
d3066 1
a3066 2
cmd646_9_irqack(chp)
	struct channel_softc *chp;
d3083 1
a3083 3
cmd680_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d3123 2
a3124 4
cmd680_channel_map(pa, sc, channel)
	struct pci_attach_args *pa;
	struct pciide_softc *sc;
	int channel;
d3175 1
a3175 2
cmd680_setup_channel(chp)
	struct channel_softc *chp;
d3366 1
a3366 1
	/* 
d3661 2
a3662 2
			      sc->sc_wdcdev.sc_dev.dv_xname,
			      intrstr ? intrstr : "unknown interrupt");
d3665 1
a3665 1
			     sc->sc_wdcdev.sc_dev.dv_xname);
d3899 1
a3899 3
cy693_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d3997 1
a3997 1
	    pci_conf_read(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL)),DEBUG_PROBE);
d4004 1
a4004 2
cy693_setup_channel(chp)
	struct channel_softc *chp;
d4152 1
a4152 3
sis_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d4372 1
a4372 2
sis_setup_channel(chp)
	struct channel_softc *chp;
d4476 1
a4476 3
natsemi_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d4544 1
a4544 2
natsemi_setup_channel(chp)
	struct channel_softc *chp;
d4609 1
a4609 2
natsemi_irqack(chp)
	struct channel_softc *chp;
d4626 1
a4626 2
natsemi_pci_intr(arg)
	void *arg;
d4825 1
a4825 3
acer_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d4922 1
a4922 2
acer_setup_channel(chp)
	struct channel_softc *chp;
d5020 1
a5020 2
acer_pci_intr(arg)
	void *arg;
d5045 1
a5045 1
	return rv;
d5049 1
a5049 3
hpt_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d5193 1
a5193 2
hpt_setup_channel(chp)
	struct channel_softc *chp;
d5302 1
a5302 2
hpt_pci_intr(arg)
	void *arg;
d5327 1
a5327 1
	return rv;
d5390 1
a5390 3
pdc202xx_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d5552 1
a5552 2
pdc202xx_setup_channel(chp)
	struct channel_softc *chp;
d5681 1
a5681 2
pdc20268_setup_channel(chp)
	struct channel_softc *chp;
d5728 1
a5728 2
pdc202xx_pci_intr(arg)
	void *arg;
d5753 1
a5753 1
	return rv;
d5757 1
a5757 2
pdc20265_pci_intr(arg)
	void *arg;
d5802 1
a5802 1
	return rv;
d5880 1
a5880 1
	return rv;
d5905 1
a5905 3
opti_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d5976 1
a5976 2
opti_setup_channel(chp)
	struct channel_softc *chp;
d5981 1
a5981 1
	int drive,spd;
d6077 1
a6077 3
serverworks_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d6144 1
a6144 2
serverworks_setup_channel(chp)
	struct channel_softc *chp;
d6226 1
a6226 2
serverworks_pci_intr(arg)
	void *arg;
d6251 1
a6251 1
	return rv;
d6259 1
a6259 3
acard_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
d6338 1
a6338 2
acard_setup_channel(chp)
	struct channel_softc *chp;
d6438 1
a6438 2
acard_pci_intr(arg)
	void *arg;
d6468 1
a6468 1
	return rv;
d6670 1
a6670 1
	return rv;
@


1.178
log
@serverworks csb5 revision after 0x92 seems not to have 80-wire
cable check. Should fix PR 3958.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.177 2004/10/17 19:21:37 grange Exp $	*/
d370 12
d1795 3
d1819 3
d1830 3
a1832 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_SATA) {
d1847 3
a1849 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_SATA)
d1873 2
a1874 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE) {
d1933 3
a1935 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_SATA)
d1959 2
a1960 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE) {
d2127 2
a2128 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE) {
d2138 2
a2139 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_6300ESB_IDE) {
@


1.177
log
@Improve support for SiI3112 and add new controllers: SiI3512, SiI3114
and Adaptec AAR-1210SA (SiI3112 based). Mostly from NetBSD (work by
thorpej@@).

Tested by me, Alexey E. Suslikov <cruel@@texnika.com.ua>, tedu@@, krw@@,
marc@@, markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.176 2004/10/17 19:00:45 grange Exp $	*/
d6288 1
a6288 1
			if (drvp->UDMA_mode > 2 &&
@


1.176
log
@Allow chip-map function to specify which bits must permanently present
in the dma command register. It's a no-op for now but sii3114 will need
it. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.175 2004/10/17 18:47:08 grange Exp $	*/
d195 10
d434 10
a443 2
	{ PCI_PRODUCT_CMDTECH_3112,	/* SiI 3112 SATA */
	  IDE_PCI_CLASS_OVERRIDE,	/* XXX: subclass RAID */
d445 4
d3330 2
a3331 1
	pcireg_t interface;
d3333 1
d3338 38
d3378 1
d3391 31
a3421 2
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_SATA;
d3432 3
d3438 4
a3441 3
	/*
	 * The 3112 can be told to identify as a RAID controller.
	 * In this case, we have to fake interface
a3449 2
	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

a3457 1
		pciide_map_compat_intr(pa, cp, channel, interface);
d3502 1
a3502 2
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
d3504 1
a3504 2
	pci_conf_write(sc->sc_pc, sc->sc_tag,
	    chp->channel == 0 ? SII3112_DTM_IDE0 : SII3112_DTM_IDE1, dtm);
d3506 462
@


1.175
log
@Don't touch dma registers directly, instead use callbacks that
can be overridden by chip-map function. It's a no-op for now but
will be needed to support sata controllers which have a non-lenear
dma registers space.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.174 2004/10/17 18:16:12 grange Exp $	*/
d1244 1
d1314 1
a1314 1
	    (flags & WDC_DMA_READ) ? IDEDMA_CMD_WRITE : 0);
d1341 1
d1358 2
a1359 2
	    (dma_maps->dma_flags & WDC_DMA_READ) ?
	    0x00 : IDEDMA_CMD_WRITE);
@


1.174
log
@Stop bloating pciide_softc with chip-specific variables. Add one pointer
to chip private data and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.173 2004/10/17 18:05:55 grange Exp $	*/
d248 6
d787 6
d1020 1
d1028 1
a1028 3
			status = bus_space_read_1(sc->sc_dma_iot,
			    sc->sc_dma_ioh,
			    IDEDMA_CTL(cp->wdc_channel.channel));
d1097 35
d1307 1
a1307 4
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(channel),
	    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		IDEDMA_CTL(channel)));
d1309 1
a1309 2
	bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_TBL(channel),
d1312 2
a1313 3
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(channel),
	    (flags & WDC_DMA_READ) ? IDEDMA_CMD_WRITE: 0);
d1327 2
a1328 4
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(channel),
	    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		IDEDMA_CMD(channel)) | IDEDMA_CMD_START);
d1347 1
a1347 2
	status = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(channel));
d1355 1
a1355 2
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(channel),
d1367 1
a1367 3
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(channel),
	    status);
d1395 1
d1398 1
a1398 4
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(chp->channel),
	    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		IDEDMA_CTL(chp->channel)));
d1676 1
a1676 3
			bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
			    IDEDMA_CTL(channel),
			    idedma_ctl);
d1716 1
a1716 2
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
@


1.173
log
@Move pciide_softc definition to pciidevar.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.172 2004/10/17 17:52:45 grange Exp $	*/
d3393 1
d3397 6
d3409 1
a3409 1
		sc->sc_cy_compatchan = 0;
d3411 1
a3411 1
		sc->sc_cy_compatchan = 1;
d3425 2
a3426 2
	sc->sc_cy_handle = cy82c693_init(pa->pa_iot);
	if (sc->sc_cy_handle == NULL) {
d3465 1
a3465 1
		cp->hw_ok = pciide_mapregs_compat(pa, cp, sc->sc_cy_compatchan,
d3471 1
a3471 1
	pciide_map_compat_intr(pa, cp, sc->sc_cy_compatchan, interface);
d3480 1
a3480 1
		pciide_unmap_compat_intr(pa, cp, sc->sc_cy_compatchan,
d3503 1
d3538 1
a3538 1
	if (sc->sc_cy_handle != NULL) {
d3540 2
a3541 2
		cy82c693_write(sc->sc_cy_handle,
		    (sc->sc_cy_compatchan == 0) ?
d3654 1
d3659 5
d3677 1
a3677 1
				sc->sis_type = SIS_TYPE_133NEW;
d3694 1
a3694 1
					sc->sis_type = SIS_TYPE_133OLD;
d3698 1
a3698 1
					sc->sis_type = SIS_TYPE_100NEW;
d3704 1
a3704 1
			sc->sis_type = sis_hostbr_type_match->type;
d3713 1
a3713 1
			sc->sis_type = SIS_TYPE_66;
d3716 1
a3716 1
			sc->sis_type = SIS_TYPE_NOUDMA;
d3728 1
a3728 1
		if (sc->sis_type >= SIS_TYPE_66)
d3737 1
a3737 1
	switch (sc->sis_type) {
d3873 1
d3902 1
a3902 1
			switch (sc->sis_type) {
d3919 1
a3919 1
				    sc->sis_type);
d3936 1
a3936 1
pio:		switch (sc->sis_type) {
d3954 1
a3954 1
			    sc->sis_type);
@


1.172
log
@Fix space.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.171 2004/10/17 17:42:01 grange Exp $	*/
a161 49

struct pciide_softc {
	struct wdc_softc	sc_wdcdev;	/* common wdc definitions */
	pci_chipset_tag_t	sc_pc;		/* PCI registers info */
	pcitag_t		sc_tag;
	void			*sc_pci_ih;	/* PCI interrupt handle */
	int			sc_dma_ok;	/* bus-master DMA info */
	bus_space_tag_t		sc_dma_iot;
	bus_space_handle_t	sc_dma_ioh;
	bus_dma_tag_t		sc_dmat;

	/*
	 * Some controllers might have DMA restrictions other than
	 * the norm.
	 */
	bus_size_t		sc_dma_maxsegsz;
	bus_size_t		sc_dma_boundary;

	/* For Cypress */
	const struct cy82c693_handle *sc_cy_handle;
	int sc_cy_compatchan;

	/* For SiS */
	u_int8_t sis_type;

	/* Chip description */
	const struct pciide_product_desc *sc_pp;
	/* Chip revision */
	int sc_rev;
	/* common definitions */
	struct channel_softc *wdc_chanarray[PCIIDE_NUM_CHANNELS];
	/* internal bookkeeping */
	struct pciide_channel {			/* per-channel data */
		struct channel_softc wdc_channel; /* generic part */
		char		*name;
		int		hw_ok;		/* hardware mapped & OK? */
		int		compat;		/* is it compat? */
		int             dma_in_progress;
		void		*ih;		/* compat or pci handle */
		bus_space_handle_t ctl_baseioh;	/* ctrl regs blk, native mode */
		/* DMA tables and DMA map for xfer, for each drive */
		struct pciide_dma_maps {
			bus_dmamap_t    dmamap_table;
			struct idedma_table *dma_table;
			bus_dmamap_t    dmamap_xfer;
			int dma_flags;
		} dma_maps[2];
	} pciide_channels[PCIIDE_NUM_CHANNELS];
};
@


1.171
log
@Small includes cleanup: explicit bus.h inclusion, add satareg.h and
reorder a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.170 2004/09/15 17:53:18 grange Exp $	*/
d110 1
@


1.170
log
@Add support for Intel 6300ESB IDE and SATA.
There's a little botch to be fixed later in our Intel SATA support
that's why the first variants of the diff didn't work.
Thanks to Markus Foerster <markus@@1ster.de> for access to the testing
machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.169 2004/08/21 07:13:55 mickey Exp $	*/
d99 1
d102 5
a128 4

#include <dev/ata/atavar.h>
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcvar.h>
@


1.169
log
@in case of failure use the same logic for unmapping as it was used for mapping; found and testing by Jack Culpepper <jack@@cloudconnector.com>; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.168 2004/06/02 18:55:08 grange Exp $	*/
d390 1
a390 1
	}
d392 8
d1773 2
d1794 2
d1803 2
a1804 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA) {
d1818 2
a1819 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA)
d1842 2
a1843 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE) {
d1901 2
a1902 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA)
d1925 2
a1926 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE) {
d2092 2
a2093 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE) {
d2102 2
a2103 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE) {
@


1.168
log
@Add quirks field to the wdc softc and implement the first one:
WDC_QUIRK_NOSHORTDMA which disables DMA for the one-sector
transfers. Use this quirk for the Geode SC1100 IDE to fix
hanging during fdisk reported in PR 3729.
Thanks to Alexandre Belloni <abelloni@@nerim.net> for testing.

ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.167 2004/05/24 22:52:52 mickey Exp $	*/
d1638 6
a1643 2
			bus_space_unmap(cp->wdc_channel.ctl_iot,
			    cp->wdc_channel.ctl_ioh, ctlsize);
@


1.167
log
@do not bother w/ void pci_devinfo() calls and free resources on failures
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.166 2004/05/06 17:28:18 peter Exp $	*/
d4217 6
@


1.166
log
@Add support for the SiS 741 Northbridge. ok deraadt@@, grange@@

Note for the archives; before this patch my ASRock K7S41 m/b would
hang after booting install media without DMA disabled for the
drive(s) in the BIOS.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.165 2004/05/04 15:10:59 grange Exp $	*/
a805 1
	char devinfo[256];
d808 1
a808 1
	if (sc->sc_pp == NULL) {
a809 3
		pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo,
		    sizeof devinfo);
	}
@


1.165
log
@Fix my stupid bug with missing sata_setup_channel() call.
Now VIA VT8237 SATA really works.

Problem report, testing and ok drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.164 2004/05/03 15:18:21 drahn Exp $	*/
d3616 1
@


1.164
log
@Remove OpenBSD/pegaos, this has been announced before but delayed until
the tree was stable. No point in code supporting a company which screws
its employees being in the OpenBSD tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.162 2004/02/18 09:49:04 grange Exp $	*/
d2622 1
@


1.163
log
@Enable ata133 on amd8111; from netbsd
tested by beck@@
@
text
@a918 7
#ifdef __pegasos__
		/* stupid broken board */
		if (intrhandle == 0xe)
			pci_intr_establish(pa->pa_pc,
			    0xf, IPL_BIO, pci_intr, sc,
			    sc->sc_wdcdev.sc_dev.dv_xname);
#endif
@


1.163.2.1
log
@MFC:
Fix by grange@@

Fix my stupid bug with missing sata_setup_channel() call.
Now VIA VT8237 SATA really works.

ok deraadt@@ grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.163 2004/03/12 19:10:07 grange Exp $	*/
a2628 1
		sata_setup_channel(&cp->wdc_channel);
@


1.162
log
@Yet another wonna-be-raid device.
Reported by Dmitry S. Popov <D.S.Popov@@inp.nsk.su>.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.161 2004/02/07 19:27:24 grange Exp $	*/
d2285 3
a2289 1
	case PCI_PRODUCT_AMD_8111_IDE:
@


1.161
log
@Final bits to make IT8212F working:
- don't touch bus speed register;
- don't try to setup the chip in compat mode, it's native always;
- disable cable check, it works only in cpu firmware mode.

Testing Aubert Guillaume <aubertguillaume@@wanadoo.fr>
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.160 2004/02/02 19:38:43 grange Exp $	*/
d383 1
a383 1
	  0,
@


1.160
log
@Support for UDMA2 capable SCx200 ide found on all National Semiconductor
SC1100 based boards (soekris net4801 e.g.). Tested both with CF cards
and UDMA2 drive.

Help and three (sic!) OKs from gluk@@, test and ok markus@@.
Thanks to Wim for the soekris board.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.159 2004/02/02 00:21:56 grange Exp $	*/
a6310 2
	/* Select 66 MHz bus */
	modectl &= ~(IT_MODE_50MHZ(0) | IT_MODE_50MHZ(1));
a6318 3
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
a6320 4
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
d6370 2
a6371 1
			/* Check cable */
d6381 1
@


1.159
log
@ite is a yet another ``raid'' device, fake interface for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.158 2004/01/31 20:01:42 grange Exp $	*/
d255 2
d495 4
d4179 150
@


1.158
log
@fix stupid typo in the reading/writing mode control register for ite.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.157 2004/01/31 19:53:18 grange Exp $	*/
d6112 1
a6112 1
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
d6115 6
@


1.157
log
@ite doesn't need a special interrupt function.
more space to save.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.156 2004/01/31 19:46:44 grange Exp $	*/
d6117 1
a6117 1
	modectl = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_CFG);
d6152 1
a6152 1
	pci_conf_write(sc->sc_pc, sc->sc_tag, IT_CFG, modectl);
@


1.156
log
@Disable i31244 support until we see a real divice using this chip.
If you're lucky owner of it mail me.
Also don't compile opti support stuff since it's disabled anyway.
Saves about 3K on floppy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.155 2004/01/31 19:29:39 grange Exp $	*/
a290 1
int  ite_pci_intr(void *);
d6163 1
a6163 1
		    ite_pci_intr);
a6279 33
}

int
ite_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv;
	u_int8_t dmastat;

	rv = 0;
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;

		/* Skip compat channel */
		if (cp->compat)
			continue;

		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(i));
		if ((dmastat & IDEDMA_CTL_INTR) == 0)
			continue;

		crv = wdcintr(wdc_cp);
		if (crv == 0)
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
		else
			rv = 1;
	}
	return rv;
@


1.155
log
@spaces, .o is the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.154 2004/01/17 21:23:16 grange Exp $	*/
d385 1
d390 1
d5215 1
d5443 1
d6050 1
d6106 1
@


1.154
log
@Read product id and revision from pci conf space only once
and then use the saved values.

ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.153 2004/01/09 21:32:24 brad Exp $	*/
d209 1
a209 1
void default_chip_map(struct pciide_softc*, struct pci_attach_args*);
d213 3
a215 3
void piix_chip_map(struct pciide_softc*, struct pci_attach_args*);
void piix_setup_channel(struct channel_softc*);
void piix3_4_setup_channel(struct channel_softc*);
d218 1
a218 1
static u_int32_t piix_setup_idetim_drvs(struct ata_drive_datas*);
d221 2
a222 2
void amd756_chip_map(struct pciide_softc*, struct pci_attach_args*);
void amd756_setup_channel(struct channel_softc*);
d224 9
a232 9
void apollo_chip_map(struct pciide_softc*, struct pci_attach_args*);
void apollo_sata_chip_map(struct pciide_softc*, struct pci_attach_args*);
void apollo_setup_channel(struct channel_softc*);

void cmd_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cmd0643_9_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cmd0643_9_setup_channel(struct channel_softc*);
void cmd680_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cmd680_setup_channel(struct channel_softc*);
d239 2
a240 2
void sii3112_chip_map(struct pciide_softc*, struct pci_attach_args*);
void sii3112_setup_channel(struct channel_softc*);
d242 2
a243 2
void cy693_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cy693_setup_channel(struct channel_softc*);
d245 2
a246 2
void sis_chip_map(struct pciide_softc*, struct pci_attach_args*);
void sis_setup_channel(struct channel_softc*);
d251 2
a252 2
void natsemi_chip_map(struct pciide_softc*, struct pci_attach_args*);
void natsemi_setup_channel(struct channel_softc*);
d256 2
a257 2
void acer_chip_map(struct pciide_softc*, struct pci_attach_args*);
void acer_setup_channel(struct channel_softc*);
d260 3
a262 3
void pdc202xx_chip_map(struct pciide_softc*, struct pci_attach_args*);
void pdc202xx_setup_channel(struct channel_softc*);
void pdc20268_setup_channel(struct channel_softc*);
d268 2
a269 2
void opti_chip_map(struct pciide_softc*, struct pci_attach_args*);
void opti_setup_channel(struct channel_softc*);
d271 2
a272 2
void hpt_chip_map(struct pciide_softc*, struct pci_attach_args*);
void hpt_setup_channel(struct channel_softc*);
d275 2
a276 2
void acard_chip_map(struct pciide_softc*, struct pci_attach_args*);
void acard_setup_channel(struct channel_softc*);
d279 2
a280 2
void serverworks_chip_map(struct pciide_softc*, struct pci_attach_args*);
void serverworks_setup_channel(struct channel_softc*);
d294 1
a294 1
int  pciide_dma_table_setup(struct pciide_softc*, int, int);
d306 1
a306 1
	void (*chip_map)(struct pciide_softc*, struct pci_attach_args*);
d699 1
a699 1
	    struct pciide_channel *, int, bus_size_t *, bus_size_t*);
d718 1
a718 1
const struct pciide_product_desc* pciide_lookup_product(u_int32_t);
d1400 1
a1400 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d1694 2
a1695 2
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc*)cp->wdc_channel.wdc;
d1924 1
a1924 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d2033 1
a2033 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d2334 1
a2334 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d2631 1
a2631 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d3012 1
a3012 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d3106 1
a3106 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d3224 1
a3224 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d3367 2
a3368 2
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc*)cp->wdc_channel.wdc;
d3517 1
a3517 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d3815 1
a3815 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d3880 1
a3880 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d4053 1
a4053 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d4116 1
a4116 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d4281 1
a4281 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d4557 1
a4557 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d4919 1
a4919 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d5048 1
a5048 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d5345 1
a5345 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d5515 1
a5515 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d5713 1
a5713 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d5929 1
a5929 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
d6180 1
a6180 1
	struct pciide_channel *cp = (struct pciide_channel*)chp;
@


1.153
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.152 2003/12/20 08:03:54 grange Exp $	*/
d807 1
d2338 2
a2339 4
	int product = PCI_PRODUCT(
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_ID_REG));
	int rev = PCI_REVISION(
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));
d2898 1
a2898 2
	int rev = PCI_REVISION(
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));
d3315 1
a3315 1
	if (PCI_REVISION(pa->pa_class) <= 0x01) {
d3665 1
a3665 1
	pcireg_t rev = PCI_REVISION(pa->pa_class);
d3685 1
a3685 2
			if (PCI_PRODUCT(pci_conf_read(sc->sc_pc, sc->sc_tag,
			    PCI_ID_REG)) == SIS_PRODUCT_5518) {
d4183 1
a4183 1
	pcireg_t rev = PCI_REVISION(pa->pa_class);
d4414 1
a4414 1
	revision = sc->sc_rev = PCI_REVISION(pa->pa_class);
d5289 1
a5289 1
	if (PCI_REVISION(pa->pa_class) <= 0x12) {
d5473 1
a5473 1
		if (PCI_REVISION(pa->pa_class) < 0x92)
d5872 1
a5872 1
	switch (PCI_PRODUCT(pa->pa_id)) {
d6060 1
a6060 1
	if (PCI_REVISION(pa->pa_class) == 0) {
@


1.152
log
@Support for ITExpress IT8212F ATA133 controller; close PR 3540.
Submitter is unresponsible so the diff is not tested. If you
have any problems with it open a new PR.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.151 2003/12/12 13:03:51 grange Exp $	*/
a97 2

#include <uvm/uvm_extern.h>
@


1.151
log
@Support for 2 new acard ata133 chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.150 2003/12/12 13:00:37 grange Exp $	*/
d123 1
d291 4
d631 7
d675 3
a677 1
	  sizeof(pciide_nvidia_products)/sizeof(pciide_nvidia_products[0]) }
d6105 208
@


1.150
log
@nforce chip doesn't have cable check bit; noticed by hugh@@ a long
time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.149 2003/11/07 10:16:45 jmc Exp $	*/
d585 8
d5615 1
a5615 1
#define	ACARD_IS_850(sc)							\
d5655 13
a5667 1
	sc->sc_wdcdev.UDMA_cap = ACARD_IS_850(sc) ? 2 : 4;
@


1.149
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.148 2003/10/31 04:11:41 drahn Exp $	*/
a5932 10

			/* Check cable */
			if ((conf & NFORCE_CONF_CABLE(channel, drive)) == 0 &&
			    drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}
@


1.148
log
@Work around a _really_ _nasty_ pciide attachment problem on pegasos,
it maps the IO in PCI space, but assumes tradition interrupt mappings.
Better solution welcome.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.147 2003/10/29 18:46:43 matthieu Exp $	*/
d2845 1
a2845 1
	 * and base adresses registers can be disabled at
d2900 1
a2900 1
	 * and base adresses registers can be disabled at
@


1.147
log
@un-revert previous. wrong suspect. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.145 2003/10/17 08:51:19 grange Exp $	*/
d891 7
@


1.146
log
@backout previous. It breaks my u5 drive. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.144 2003/10/17 08:14:09 grange Exp $	*/
d2718 1
d2740 13
a2752 1
	if (channel > 0) {
@


1.145
log
@Old CMD chips don't have independant channels; from NetBSD.
Work by niklas@@ but he don't want to commit it and it causes conflicts.
@
text
@a2717 1
	int one_channel;
d2739 1
a2739 13
	/*
	 * Older CMD64X doesn't have independant channels
	 */
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_CMDTECH_649:
		one_channel = 0;
		break;
	default:
		one_channel = 1;
		break;
	}

	if (channel > 0 && one_channel) {
@


1.144
log
@Merge an old fix from NetBSD:
- do not stop/unload current DMA operation if an IRQ was not detected
  by DMA engine unless the force flag was given, fixes DMA problems
  in shared IRQ setups;
- ack interrupt before entering DMA codepath

Tested by many.
Work by niklas@@ but he doesn't want to commit it for some reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.143 2003/10/16 14:52:58 grange Exp $	*/
d2718 1
d2740 13
a2752 1
	if (channel > 0) {
@


1.143
log
@Mark all supported SATA controllers with flag WDC_CAPABILITY_SATA
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.142 2003/10/16 11:30:00 grange Exp $	*/
d267 1
a267 1
int  pdc20262_dma_finish(void *, int, int);
d294 1
a294 1
int  pciide_dma_finish(void *, int, int);
d1309 1
a1309 1
pciide_dma_finish(v, channel, drive)
d1312 1
d1327 3
d5157 1
a5157 1
pdc20262_dma_finish(void *v, int channel, int drive)
d5173 1
a5173 1
	return (pciide_dma_finish(v, channel, drive));
@


1.142
log
@Allow setting of wdcdebug*_mask variables via preprocessor defines.
This makes creating debug kernels be much more easy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.141 2003/10/09 18:57:00 grange Exp $	*/
d1759 2
a1760 1
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA)
d1762 1
a1762 1
	else if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371FB_IDE)
d1764 1
a1764 1
	else
d1766 1
d2581 1
a2581 1
	    WDC_CAPABILITY_MODE;
d3279 1
a3279 1
	    WDC_CAPABILITY_MODE;
d4744 2
d6030 1
a6030 1
	    WDC_CAPABILITY_MODE;
@


1.141
log
@Support for VIA VT8237 ATA and SATA from NetBSD.
Thanks to Anton Komarov for providing access to the VIA board.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.140 2003/09/29 13:39:16 grange Exp $	*/
d83 4
a86 1
int wdcdebug_pciide_mask = 0;
@


1.140
log
@Experimental support for serverworks csb6 third channel inspired by
freebsd ata driver. Close PR 3485.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.139 2003/09/28 21:01:43 grange Exp $	*/
d223 1
d461 4
d2469 4
d2540 46
@


1.139
log
@kill trailing spaces, no functional changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.138 2003/08/01 11:05:09 grange Exp $	*/
d593 4
d5378 3
d5385 2
a5386 1
	sc->sc_wdcdev.nchannels = 2;
@


1.138
log
@Fix ICH5R SATA support
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.137 2003/07/30 19:59:17 grange Exp $	*/
d873 1
a873 1
		}	
d1025 1
a1025 1
		
d1217 1
a1217 1
	    dma_maps->dmamap_xfer->dm_mapsize,		
d2088 1
a2088 1
	
d2122 1
a2122 1
	
d2227 1
a2227 1
		sc->sc_wdcdev.irqack = pciide_irqack;		
d2413 2
a2414 2
	pcib_class = pci_conf_read(sc->sc_pc, pcib_tag, PCI_CLASS_REG);	
	
d2482 1
a2482 1
	
d2595 1
a2595 1
				    drive, apollo_udma66_tim[drvp->UDMA_mode]);				
d4145 1
a4145 1
		}		
d4952 1
a4952 1
	
@


1.137
log
@Experimental support for ICH5/ICH5R SATA, inspired from FreeBSD
ata driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.136 2003/07/29 18:16:27 grange Exp $	*/
d370 5
a374 1
	{ PCI_PRODUCT_INTEL_82801EB_SATA, /* Intel 82801EB/ER (ICH5/5R) SATA */
d1720 1
d1739 1
d1746 2
a1747 1
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA)
d1758 2
a1759 1
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA)
d1796 2
a1797 1
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA) {
d1839 2
a1840 1
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA)
@


1.136
log
@Support for HPT302 and HPT371, inspired from the FreeBSD ata driver.
Thanks to otto@@ for help in regress testing and tedu@@ for unslacking me.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.135 2003/07/23 22:10:36 grange Exp $	*/
d366 6
a371 2
	{ PCI_PRODUCT_INTEL_82801EB_IDE, /* Intel 82801EB/82801ER IDE */
	  0,				 /* (ICH5/ICH5R)	      */
d1715 1
d1733 1
d1740 3
a1742 1
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371FB_IDE)
d1751 3
d1783 1
d1786 13
d1829 3
@


1.135
log
@Enable ATAPI DMA for modern Promise ATA controllers since only old
ones have problems with it. Tested on PDC20262/268/269.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.134 2003/07/23 22:07:15 grange Exp $	*/
d184 2
d492 8
d4271 1
a4271 1
	revision = PCI_REVISION(pa->pa_class);
d4286 2
d4327 4
a4330 2
		if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374 ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A)
d4370 2
d4393 2
d4416 2
d4426 35
d4482 1
a4482 5
			after = (sc->sc_wdcdev.nchannels == 2) ?
			    ((sc->sc_wdcdev.UDMA_cap == 6) ?
			    hpt374_udma[drvp->UDMA_mode] :
			    hpt370_udma[drvp->UDMA_mode]) :
			    hpt366_udma[drvp->UDMA_mode];
d4494 1
a4494 5
			after = (sc->sc_wdcdev.nchannels == 2) ?
			    ((sc->sc_wdcdev.UDMA_cap == 6) ?
			    hpt374_dma[drvp->DMA_mode] :
			    hpt370_dma[drvp->DMA_mode]) :
			    hpt366_dma[drvp->DMA_mode];
d4498 1
a4498 5
			after = (sc->sc_wdcdev.nchannels == 2) ?
			    ( (sc->sc_wdcdev.UDMA_cap == 6) ?
			    hpt374_pio[drvp->PIO_mode] :
			    hpt370_pio[drvp->PIO_mode]) :
			    hpt366_pio[drvp->PIO_mode];
d4506 1
@


1.134
log
@Old Promise ATA controllers need some additional operations
during DMA transfers to work correctly with LBA48 drives.
Based on diff from Takeshi Nakayama <tn@@catvmics.ne.jp> for NetBSD
with some corrections from FreeBSD ATA driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.133 2003/07/20 22:26:50 tedu Exp $	*/
d4594 4
a4597 1
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_NO_ATAPI_DMA;
@


1.133
log
@acer chips seem to work with atapi dma now.  ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.132 2003/06/18 20:21:50 grange Exp $	*/
d260 2
d4615 5
d4975 44
@


1.132
log
@For HPT370 chips disable interrupt prediction and correct timing
value for UDMA5. Enable UDMA5 for HPT370A again since it's safe now.
Work by Otto Moerbeek <otto@@drijf.net> via PR 3282. Help in testing from
gluk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.131 2003/06/07 20:00:31 grange Exp $	*/
a4036 3

	if (rev < 0xC4)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_NO_ATAPI_DMA;
@


1.131
log
@Experimental support for Intel 31244 SATA, only parallel ATA mode yet;
from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.130 2003/06/07 19:49:50 grange Exp $	*/
a4323 6
			if (revision == HPT370_REV) {
				/*
				 * XXX disable udma5 for now.
				 */
				sc->sc_wdcdev.UDMA_cap = 4;
			}
d4358 10
@


1.130
log
@Add a generic channel setup routine for SATA devices; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.129 2003/06/06 11:28:41 grange Exp $	*/
d119 1
d280 2
d366 4
d5794 56
@


1.129
log
@Add support for Intel ICH5/ICH5R IDE
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.128 2003/05/30 09:07:46 grange Exp $	*/
d206 2
d1615 41
@


1.128
log
@Cleanup: \t vs spaces, kill trailing spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.127 2003/05/22 19:26:27 grange Exp $	*/
d357 4
d1648 1
d1665 1
d1700 2
a1701 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE) {
d1762 2
a1763 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE) {
d1928 2
a1929 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE) {
d1937 2
a1938 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE) {
@


1.127
log
@Support for Intel ICH4-M; from marius aamodt eriksen <marius@@monkey.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.126 2003/05/17 18:45:15 grange Exp $	*/
d25 1
a25 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
d276 1
a276 1
 
d353 4
a356 4
       { PCI_PRODUCT_INTEL_82801DBM_IDE, /* Intel 82801DBM IDE (ICH4-M) */
         0,
         piix_chip_map
       },
d635 1
a635 1
int	pciide_mapregs_native(struct pci_attach_args *, 
d974 1
a974 1
pciide_intr_flag(struct pciide_channel *cp) 
d984 1
a984 1
			status = bus_space_read_1(sc->sc_dma_iot, 
d1216 1
a1216 1
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_table, 0, 
d1288 1
a1288 1
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, 0, 
d1321 1
a1321 1
        struct channel_softc *chp;
d1323 2
a1324 2
        struct pciide_channel *cp = (struct pciide_channel*)chp;
        struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
d1326 5
a1330 5
        /* clear status bits in IDE DMA registers */
        bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
            IDEDMA_CTL(chp->channel),
            bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
                IDEDMA_CTL(chp->channel)));
d1456 1
a1456 1
		    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   
d1643 1
a1643 1
               case PCI_PRODUCT_INTEL_82801DBM_IDE:
d1659 1
a1659 1
       case PCI_PRODUCT_INTEL_82801DBM_IDE:
d1693 2
a1694 2
                   sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
                   sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE) {
d1754 2
a1755 2
                   sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
                   sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE) {
d1848 1
a1848 1
	else 
d1919 2
a1920 2
                   sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
                   sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE) {
d1927 2
a1928 2
                   sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
                   sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE) {
d2015 1
a2015 1
		    PIIX_IDETIM_ISP_SET(piix_isp_dma[mode]) | 
d2018 1
a2018 1
	else 
d2020 1
a2020 1
		    PIIX_IDETIM_ISP_SET(piix_isp_pio[mode]) | 
d2091 1
a2091 1
	else 
d2116 2
a2117 2
                sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
                sc->sc_wdcdev.irqack = pciide_irqack;		
d2239 1
a2239 1
			 * triggered. 
d2357 1
a2357 1
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 | 
d2446 1
a2446 1
		if (chp->ch_drive[0].UDMA_mode > 2 && 
d2611 1
a2611 1
	int i, rv, crv; 
d2731 10
a2740 10
                case PCI_PRODUCT_CMDTECH_646:
                        if (rev >= CMD0646U2_REV) {
                                sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
                                sc->sc_wdcdev.UDMA_cap = 2;
                        } else if (rev >= CMD0646U_REV) {
                        /*
                         * Linux's driver claims that the 646U is broken
                         * with UDMA. Only enable it if we know what we're
                         * doing
                         */
d2742 2
a2743 2
                                sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
                                sc->sc_wdcdev.UDMA_cap = 2;
d2745 8
a2752 8
                                /* explicitly disable UDMA */
                                pciide_pci_write(sc->sc_pc, sc->sc_tag,
                                    CMD_UDMATIM(0), 0);
                                pciide_pci_write(sc->sc_pc, sc->sc_tag,
                                    CMD_UDMATIM(1), 0);
                        }
                        sc->sc_wdcdev.irqack = cmd646_9_irqack;
                        break;
d2829 1
a2829 1
				else if (sc->sc_wdcdev.UDMA_cap > 2) 
d2887 1
a2887 1
        struct channel_softc *chp;
d2889 12
a2900 12
        u_int32_t priirq, secirq;
        struct pciide_channel *cp = (struct pciide_channel*)chp;
        struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

        if (chp->channel == 0) {
                priirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CONF);
                pciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_CONF, priirq);
        } else {
                secirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23);
                pciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23, secirq);
        }
        pciide_irqack(chp);
d3119 1
a3119 1
	/* 
d3197 1
a3197 1
{       
d3281 1
a3281 1
		pciide_unmap_compat_intr(pa, cp, sc->sc_cy_compatchan, 
d3285 1
a3285 1
				       
d3669 1
a3669 1
	    "channel %d 0x%x\n", chp->channel, 
d3698 1
a3698 1
				sis_tim |= sis_udma66_tim[drvp->UDMA_mode] << 
d3703 1
a3703 1
				    sis_udma100new_tim[drvp->UDMA_mode] << 
d3707 1
a3707 1
				    sis_udma133old_tim[drvp->UDMA_mode] << 
d3899 1
a3899 1
        struct channel_softc *chp;
d3901 2
a3902 2
        struct pciide_channel *cp = (struct pciide_channel*)chp;
        struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
d4074 1
a4074 1
	WDCDEBUG_PRINT(("acer_setup_channel: old fifo/udma reg 0x%x\n", 
d4120 1
a4120 1
			acer_fifo_udma |= 
d4128 1
a4128 1
				        ACER_0x4B) | ACER_0x4B_UDMA66);
d4167 1
a4167 1
	int i, rv, crv; 
d4204 1
a4204 1
	/* 
d4213 1
a4213 1
               if ((sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
d4257 1
a4257 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A) 
d4266 1
a4266 1
				 * XXX disable udma5 for now. 
d4425 1
a4425 1
		wdc_cp = &cp->wdc_channel;	       
d4768 1
a4768 1
		    sc->sc_wdcdev.sc_dev.dv_xname, 
d4836 1
a4836 1
	int i, rv, crv; 
d4866 1
a4866 1
	int i, rv, crv; 
d5011 1
a5011 1
        pciide_print_channels(sc->sc_wdcdev.nchannels, interface);
d5332 1
a5332 1
	/* 
d5709 1
a5709 1
	int i, rv, crv; 
@


1.126
log
@Experimental support for SiI 3112 SATA card; from NetBSD.
Thanks to chris@@ for this card.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.125 2003/05/17 18:35:04 grange Exp $	*/
d353 4
d1643 1
d1659 1
d1693 2
a1694 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
d1754 2
a1755 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
d1919 2
a1920 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
d1927 2
a1928 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
@


1.125
log
@Allow chip-specific setup routines to change dma engine parameters
(size and align of dma segment) since some chips may have quirks;
from NetBSD.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.124 2003/05/17 18:31:54 grange Exp $	*/
d109 1
d231 3
d416 4
d3066 114
@


1.124
log
@Add debug warning messages about missing 80-wire cable to all
cable checking procedures.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.123 2003/05/02 09:33:33 grange Exp $	*/
d166 7
d734 4
d1134 1
a1134 1
	    NIDEDMA_TABLES, IDEDMA_BYTE_COUNT_MAX, IDEDMA_BYTE_COUNT_ALIGN,
@


1.123
log
@Rework SIS IDE support. Unbreak the newest chips and fix issues with the
old ones. Original work by sos@@freebsd, then adapted for netbsd by
bouyer@@netbsd. Many thanks to Paul de Weerd <paul@@mail.me.maar.nu>
for problem report, providing url to the preliminary netbsd diff and
access to testing machine. Extra testing by tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.122 2003/04/27 11:22:53 ho Exp $	*/
d2790 6
a2795 1
				    CMD_BICSR_80(chp->channel)) == 0)
d2797 1
d3940 3
d4214 5
a4218 1
			    drvp->UDMA_mode > 2)
d4220 1
d4534 14
d4549 1
a4549 2
		if ((st & PDC262_STATE_80P(channel)) != 0 ||
		    (chp->ch_drive[0].drive_flags & DRIVE_UDMA &&
d5103 7
a5109 1
			    (PCI_PRODUCT(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_SUBSYS_ID_REG)) & (1 << (14 + channel))) == 0)
d5111 1
@


1.122
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.121 2003/04/20 21:09:28 grange Exp $	*/
d170 3
d228 3
d3205 86
d3302 2
a3303 2
	pcitag_t pchb_tag;
	pcireg_t pchb_id, pchb_class;
d3308 57
a3367 6
	/* get a PCI tag for the host bridge (function 0 of the same device) */
	pchb_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, pa->pa_device, 0);
	/* and read ID and rev of the ISA bridge */
	pchb_id = pci_conf_read(sc->sc_pc, pchb_tag, PCI_ID_REG);
	pchb_class = pci_conf_read(sc->sc_pc, pchb_tag, PCI_CLASS_REG);

d3373 1
a3373 8
		/*
		 * controllers with rev > 0xd0 support UDMA 2 at least
		 * controllers associated to a rev 0x2 530 Host to PCI Bridge
		 * have problems with UDMA
		 */
		if (rev >= 0xd0 &&
		    (PCI_PRODUCT(pchb_id) != PCI_PRODUCT_SIS_530 ||
		    PCI_REVISION(pchb_class) >= 0x03))
a3378 3
	if (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA)
		sc->sc_wdcdev.UDMA_cap = 2;
	sc->sc_wdcdev.set_modes = sis_setup_channel;
d3382 23
a3407 4
	pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_MISC,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_MISC) |
	    SIS_MISC_TIM_SEL | SIS_MISC_FIFO_SIZE);

d3413 1
a3413 1
	 	    (channel == 1 && (sis_ctr0 & SIS_CTRL0_CHAN1_EN) == 0)) {
d3439 1
a3439 1
		sis_setup_channel(&cp->wdc_channel);
d3444 65
d3541 24
a3564 3
			sis_tim |= sis_udma_tim[drvp->UDMA_mode] << 
			    SIS_TIM_UDMA_TIME_OFF(drive);
			sis_tim |= SIS_TIM_UDMA_EN(drive);
d3580 20
a3599 4
pio:		sis_tim |= sis_pio_act[drvp->PIO_mode] <<
		    SIS_TIM_ACT_OFF(drive);
		sis_tim |= sis_pio_rec[drvp->PIO_mode] <<
		    SIS_TIM_REC_OFF(drive);
@


1.121
log
@In pdc20265_pci_intr() perform shared irq check only if channel is
enabled since it reqires accessing channel's bus space.
Problem reported by Armin Wolfermann <aw@@osn.de>.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.120 2003/03/29 11:02:09 grange Exp $	*/
d714 2
a715 1
		pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
@


1.120
log
@Very limited support for Promise PDC20376 SATA. Only parallel ATA
compatibility mode works for now.
Based on tests by Jedi/Sector One <j@@pureftpd.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.119 2003/03/28 23:49:48 millert Exp $	*/
d4455 1
d4457 1
a4457 1
		if (PDC_IS_268(sc)) {
@


1.119
log
@unbreak after SiS pcidevs change
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.118 2003/03/28 16:12:28 grange Exp $	*/
d500 4
d4040 2
a4041 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277)
d4049 2
a4050 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277)
d4056 2
a4057 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277)
@


1.118
log
@Improve debug output a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.117 2003/03/06 11:49:20 grange Exp $	*/
d3231 1
a3231 1
		    (PCI_PRODUCT(pchb_id) != PCI_PRODUCT_SIS_SiS530 ||
@


1.117
log
@Support for ServerWorks CSB6 IDE
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.116 2003/02/24 20:54:15 grange Exp $	*/
d716 2
a717 4
#ifdef WDCDEBUG
       if (wdcdebug_pciide_mask & DEBUG_PROBE)
               printf(" sc_pc %p, sc_tag %p\n", sc->sc_pc, sc->sc_tag);
#endif
@


1.116
log
@Detypoing; henric@@ and me
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.115 2003/02/24 01:34:41 grange Exp $	*/
d527 4
d4742 3
@


1.115
log
@For CMD chips call pciide_chan_candisable() for both channels to prevent
setuping channel 0 without any drives. This solves a long delay during
the pciide probe on a diskless sparc64.
Found and tested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.114 2003/02/21 20:10:33 grange Exp $	*/
d1394 1
a1394 1
 * generic code to map the compat intr if hw_ok=1 and it is a compat channel.
d2828 1
a2828 1
	 * to the PCI0646U asserting a PCI interrtupt line when the chip
@


1.114
log
@Fix Manuel Bouyer's copyright, from NetBSD
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.113 2003/02/13 15:39:59 grange Exp $	*/
d2552 2
a2553 2
	if (channel == 1) {
		if (pciide_chan_candisable(cp)) {
@


1.113
log
@Final part of NVIDIA nForce/nForce2 IDE support:
- registers definitions
- timing values setup
- cable detection
Partially from Linux, FreeBSD and AMD specs.
Many thanks to Johan Lindman <tybollt@@solace.mh.se> for providing
access to the testing machine.
ok gluk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.112 2003/02/13 15:30:21 grange Exp $	*/
d17 1
a17 2
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
@


1.112
log
@Add cable detection for AMD chips, directly from AMD specs.
Tested by todd@@; ok gluk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.111 2003/01/30 07:50:17 henric Exp $	*/
d118 1
d5087 5
d5129 7
d5147 1
d5149 1
d5154 3
d5163 1
a5163 1
	int drive;
d5168 9
d5181 1
d5183 2
d5194 3
a5196 1
		if (drvp->drive_flags & DRIVE_UDMA) {
d5198 38
a5235 3
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
d5237 2
d5240 2
d5249 7
@


1.111
log
@
Many Ultra 5s likes to hang when starting.  The last thing on the console
is: "pcons at mainbus0 not configured".  The problem is that the IDE chip
asserts a PCI interrupt line even while the registers on the chip claim
that it is not.  Doing a channel reset helps, but is almost certainly only
a work-around for the real problem.  Several other work-arounds have been
suggested, but this one has had the most testing.


Many have looked and helped (notably grange@@).  Thanks.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.110 2003/01/17 00:54:23 grange Exp $	*/
d2138 1
d2151 2
d2172 11
@


1.110
log
@80-pin -> 80-wire in debug output; requested by chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.109 2003/01/16 17:24:46 grange Exp $	*/
d2811 10
@


1.109
log
@Missing break
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.108 2003/01/16 16:15:46 grange Exp $	*/
d4352 1
a4352 1
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-pin "
@


1.108
log
@- add two inline functions for accessing chip configuration space
  through the index and data registers
- proper registers and bits names
- more debug in cable detection
- back the code for checking interrupt asserting in case of shared IRQ,
  it seems to solve the problem with repeatable ``bugus intr'' messages
  in PDC20376 (one more step to get it working); based on tests by
  j@@pureftpd.org

Some input and ok from costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.107 2003/01/16 12:31:01 grange Exp $	*/
d5084 1
@


1.107
log
@Add channel number to report of registers mapping type.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.106 2003/01/16 01:17:23 grange Exp $	*/
d4026 26
d4332 1
d4335 1
a4335 3
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC268_REG0, 0x0b);
	cable = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_REG1) & 0x04;
d4351 5
a4355 1
			if (cable && drvp->UDMA_mode > 2)
d4357 1
d4366 1
a4366 1
		    IDEDMA_CTL(chp->channel), idedma_ctl);
d4418 11
@


1.106
log
@Don't hardcode IO mapping for cmd/ctl regs, use pci_mapreg_type()
instead. This allows chips with memory mapped registers (e.g. Promise
PDC20376) to work.
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.105 2003/01/15 01:36:10 grange Exp $	*/
d831 2
a832 2
	WDCDEBUG_PRINT(("%s: cmd regs mapping: %s\n",
	    sc->sc_wdcdev.sc_dev.dv_xname,
d844 2
a845 2
	WDCDEBUG_PRINT(("%s: ctl regs mapping: %s\n",
	    sc->sc_wdcdev.sc_dev.dv_xname,
@


1.105
log
@revert last change; request from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.104 2003/01/14 20:52:10 grange Exp $	*/
d795 1
d828 6
d835 1
a835 1
	    PCI_MAPREG_TYPE_IO, 0,
d842 5
d848 1
a848 1
	    PCI_MAPREG_TYPE_IO, 0,
@


1.104
log
@Add a define for easy access to sc_wdcdev.sc_dev.dv_xname
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.103 2003/01/13 23:29:27 grange Exp $	*/
a157 1
#define sc_xname sc_wdcdev.sc_dev.dv_xname
@


1.103
log
@Add experimental support for NVIDIA nForce/nForce2 IDE chips.
Tested by Johan Lindman <tybollt@@solace.mh.se>
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.102 2002/12/19 16:32:59 grange Exp $	*/
d158 1
@


1.102
log
@Protect WDCDEBUG_PRINT macro with do {} while (0)
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.101 2002/12/10 11:47:47 grange Exp $	*/
d255 4
d529 11
d575 3
a577 1
	  sizeof(pciide_promise_products)/sizeof(pciide_promise_products[0]) }
d4998 134
@


1.101
log
@Add support for VIA VT8231; from NetBSD, untested.
ok gluk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.100 2002/11/24 19:39:19 grange Exp $	*/
d85 4
a88 2
#define WDCDEBUG_PRINT(args, level) \
	if (wdcdebug_pciide_mask & (level)) printf args
@


1.100
log
@Check whether the chip enabled or not by reading status register.
Close PR 2980
ok gluk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.99 2002/11/20 21:33:37 grange Exp $	*/
d2246 4
@


1.99
log
@o change dma engine registers macros so that the channel
specifying is required
o fix missed offsets for the secondary channel which were found
with the help of this new more strict semantics; this can solve
many old problems

tested by gluk@@, jason@@
ok gluk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.98 2002/11/20 19:39:02 jason Exp $	*/
d717 5
a721 7
	if ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {
		csr = pci_conf_read(sc->sc_pc, sc->sc_tag,
		    PCI_COMMAND_STATUS_REG);
		printf("%s: device disabled (at %s)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname,
		    (csr & PCI_COMMAND_IO_ENABLE) == 0 ?
		    "device" : "bridge");
d724 1
@


1.98
log
@Overhaul natsemi driver:
- setup the DMA bits on the second channel correctly (missing channel offset)
- setup timing for PIO/DMA modes
- workaround the fact that the INTR/ERR clear bits are in the wrong register
- only read the interrupt mask register once in the interrupt path
Many thanks to grange@@ for assistance and debugging!
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.97 2002/11/18 11:06:40 grange Exp $	*/
d920 1
a920 2
			    IDEDMA_CTL + IDEDMA_SCH_OFFSET * 
			    cp->wdc_channel.channel);
d1165 1
a1165 1
	    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel,
d1167 1
a1167 1
		IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel));
d1170 1
a1170 1
	    IDEDMA_TBL + IDEDMA_SCH_OFFSET * channel,
d1174 1
a1174 1
	    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,
d1190 1
a1190 1
	    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,
d1192 1
a1192 1
		IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel) | IDEDMA_CMD_START);
d1211 1
a1211 1
	    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel);
d1217 1
a1217 1
	    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,
d1230 1
a1230 1
	    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel,
d1262 1
a1262 1
            IDEDMA_CTL + IDEDMA_SCH_OFFSET * chp->channel,
d1264 1
a1264 1
                IDEDMA_CTL + IDEDMA_SCH_OFFSET * chp->channel));
d1539 1
a1539 1
			    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * channel),
d1796 1
a1796 1
		    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),
d1922 1
a1922 1
		    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * channel),
d2191 1
a2191 1
		    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),
d2432 1
a2432 1
		    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),
d2773 1
a2773 1
		    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),
d2967 1
a2967 1
		    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),
d3130 1
a3130 1
		    IDEDMA_CTL, idedma_ctl);
d3288 1
a3288 1
		    IDEDMA_CTL, idedma_ctl);
d3411 1
a3411 2
		    (chp->channel * IDEDMA_SCH_OFFSET) + IDEDMA_CTL,
		    idedma_ctl);
d3424 1
a3424 1
	    (chp->channel * IDEDMA_SCH_OFFSET) + IDEDMA_CTL,
d3426 1
a3426 1
		(chp->channel * IDEDMA_SCH_OFFSET) + IDEDMA_CTL));
d3439 1
a3439 1
	    IDEDMA_CMD + IDEDMA_SCH_OFFSET * chp->channel);
d3441 1
a3441 1
	    IDEDMA_CTL + IDEDMA_SCH_OFFSET * chp->channel) &
d3444 1
a3444 1
	    IDEDMA_CMD + IDEDMA_SCH_OFFSET * chp->channel, clr);
d3473 1
a3473 1
		    (i * IDEDMA_SCH_OFFSET) + IDEDMA_CTL);
d3684 1
a3684 1
		    IDEDMA_CTL, idedma_ctl);
d3927 1
a3927 1
		    IDEDMA_CTL, idedma_ctl);
d3944 1
a3944 1
		    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i);
d3955 1
a3955 1
			    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i, dmastat);
d4258 1
a4258 1
		    IDEDMA_CTL, idedma_ctl);
d4302 1
a4302 1
		    IDEDMA_CTL, idedma_ctl);
d4361 1
a4361 1
		    sc->sc_dma_ioh, IDEDMA_CTL + IDEDMA_SCH_OFFSET * i);
d4736 1
a4736 1
		    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel, idedma_ctl);
d4753 1
a4753 1
		    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i);
d4764 1
a4764 1
			    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i, dmastat);
d4931 1
a4931 1
		    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel, idedma_ctl);
d4957 1
a4957 1
		    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i);
d4965 1
a4965 1
			    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i, dmastat);
@


1.97
log
@typo; gluk@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.96 2002/11/17 19:21:52 grange Exp $	*/
d227 1
d3313 1
a3313 1
		sc->sc_wdcdev.irqack = pciide_irqack;
a3361 1

d3373 1
d3386 17
a3402 2
		if ((drvp->drive_flags & DRIVE_DMA) == 0)
			goto pio;
a3403 11
		/*
		 * use Multiword DMA
		 * Timings will be used for both PIO and DMA,
		 * so adjust DMA mode if needed
		 */
		if (drvp->PIO_mode >= 3 &&
		    (drvp->DMA_mode + 2) > drvp->PIO_mode) {
			drvp->DMA_mode = drvp->PIO_mode - 2;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
pio:
d3405 1
a3405 1
		    NATSEMI_RTREG(chp->channel, drive), 0x85);
d3407 1
a3407 1
		    NATSEMI_WTREG(chp->channel, drive), 0x85);
d3412 2
a3413 1
		    IDEDMA_CTL, idedma_ctl);
d3421 1
d3431 18
d3460 1
d3464 1
a3469 1
		msk = pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2);
d3476 1
d3480 1
d3490 1
a3490 1
	return rv;
@


1.96
log
@o fix cp->name usage: since it's initialized with PCIIDE_CHANNEL_NAME()
macro it already contains a word ``channel'', so there's no need to
print it twice
o report when channel is disabled due to the absence of drives on it
(idea from NetBSD)

close PR 2973
ok costa@@ gluk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.95 2002/11/15 03:33:25 grange Exp $	*/
d709 1
a709 1
/* tell wether the chip is enabled or not */
@


1.95
log
@o add support for VIA VT8233 and VT8235
VT8233 tested by jolan@@cryptonomicon.org, VT8235 untested
o correct VIA timings for UDMA 5
o don't set the APO_UDMA_CLK66 bit for UDMA 5 capable chipset

from NetBSD

gluk@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.94 2002/11/08 11:44:59 gluk Exp $	*/
d831 1
a831 1
		printf("%s: unable to subregion %s channel ctl regs\n",
d1324 1
d1329 2
d2869 1
a2869 1
		printf("%s %s channel: "
d2880 1
a2880 1
	printf("%s: %s channel %s to %s mode\n",
d4085 1
a4085 1
			printf("%s: %s channel ignored (disabled)\n",
d4459 1
a4459 1
			printf("%s: %s channel ignored (disabled)\n",
@


1.94
log
@Support for Promise PDC20275 and PDC20277. Untested.
from grange@@rt.mipt.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.93 2002/11/08 11:07:28 gluk Exp $	*/
d2249 8
d2262 1
a2262 1
	
d2381 4
a2384 2
			
			if (sc->sc_wdcdev.UDMA_cap == 5) {
a2385 1
				udmatim_reg |= APO_UDMA_CLK66(chp->channel);
@


1.93
log
@Don't check IRQ assertion since this code was derived from FreeBSD
without any documentation and breaks second channel support.
Supplied and tested by grange@@rt.mipt.ru.
Thanks to Evgeniy Polyakov <johnpol@@2ka.mipt.ru> for hardware donation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.92 2002/10/12 01:09:44 krw Exp $	*/
d482 4
d489 4
d3936 3
a3938 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276)
d3944 3
a3946 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276)
d3950 3
a3952 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276)
@


1.92
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.91 2002/09/09 17:45:26 gluk Exp $	*/
a4293 9

	/* process our own interrupts only during IRQ sharing */
	if (PDC_IS_268(sc)) {
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC268_REG0, 0xb);
		if (!(bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC268_REG1) & 0x20))
			return 0;
	}
@


1.91
log
@Add support of Silicon Image 0680 Ultra ATA/133 Controller.
Code from NetBSD.
Submitted and tested by Jonathon Fletcher <jonathon.fletcher@@pobox.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.90 2002/08/30 16:21:43 gluk Exp $	*/
d941 1
a941 1
		panic("pciide compat intr called for non-compat chan %p\n", cp);
@


1.90
log
@Support for PDC20271 and PDC20276.
Enable UDMA6 for Ultra133 chips (PDC20269, PDC20271 and PDC20276).
PDC20271 and PDC20276 not tested, but Free/NetBSD's source code claims
that they works the same as the PDC20269.

from Alexander Yurchenko <grange@@rt.mipt.ru>

csapuntz@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.89 2002/08/09 20:26:45 jsyn Exp $	*/
d210 3
d388 4
d2775 176
@


1.89
log
@Get rid of remaining __P usage (except for imported code);
ok millert@@, rogue ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.88 2002/07/29 22:19:39 mickey Exp $	*/
d470 8
d3743 3
a3745 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269)
d3749 7
a3755 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269)
d3799 3
a3801 1
	if (PDC_IS_265(sc))
@


1.88
log
@dma support for serverwors osb4 and csb5, from netbsd; csapuntz@@, deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.87 2002/07/10 11:01:01 markus Exp $	*/
d246 3
a248 3
void serverworks_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void serverworks_setup_channel __P((struct channel_softc*));
int  serverworks_pci_intr __P((void *));
@


1.87
log
@ICH4 support; ok gluk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.86 2002/07/06 14:35:47 gluk Exp $	*/
d245 4
d488 12
d531 2
d4357 168
@


1.86
log
@HPT 372, 372A and 374.  Only HPT372 was tested.
Mostly from NetBSD.

deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.85 2002/06/08 23:32:51 chris Exp $	*/
d310 1
a310 1
	{ PCI_PRODUCT_INTEL_82801CAM_IDE, /* Intel 82801CAM IDE (ICH2) */
d314 5
a318 1
	{ PCI_PRODUCT_INTEL_82801CA_IDE, /* Intel 82801CA IDE (ICH2) */
d1532 1
d1547 1
d1580 2
a1581 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE) {
d1640 2
a1641 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE) {
d1804 2
a1805 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE) {
d1811 2
a1812 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE) {
@


1.85
log
@match new amd pciide a'la netbsd
hpt was fixed in 1.79
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.84 2002/06/08 23:04:07 chris Exp $	*/
d423 8
d3477 5
a3481 1
		if (revision == HPT370_REV || revision == HPT370A_REV)
d3500 2
a3501 1
	if (revision < HPT370_REV) {
d3520 15
a3534 7
		/*
		 * XXX disable udma5 for now. 
		 */
		if (revision == HPT370_REV)
			sc->sc_wdcdev.UDMA_cap = 4;
		else
			sc->sc_wdcdev.UDMA_cap = 5;
d3563 5
a3567 1
	if (revision == HPT370_REV || revision == HPT370A_REV) {
d3569 2
a3570 2
		 * HPT370_REV has a bit to disable interrupts, make sure
		 * to clear it
d3576 9
d3624 3
a3626 1
			    hpt370_udma[drvp->UDMA_mode] :
d3640 3
a3642 1
			    hpt370_dma[drvp->DMA_mode] :
d3648 3
a3650 1
			    hpt370_pio[drvp->PIO_mode] :
@


1.84
log
@pullup two fixes from netbsd
-no longer set southbridge enable bit on ALi rev >=c2 as it is unnecessary
and causes rev c4 to hang
-in hpt_pci_intr accept interrupt only once IDEDMA_CTL_ACT is turned off,
fixes dma errors, lost interrupts, and other problems in hpt370 native mode
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.83 2002/05/03 13:25:30 espie Exp $	*/
d329 8
d1989 2
d3640 2
a3641 1
		if((dmastat & IDEDMA_CTL_INTR) == 0)
@


1.83
log
@82801CA/CAM works like previous models.

Suggested by csapuntz@@, tested to work.
Okay csapuntz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.82 2002/04/01 16:57:54 gluk Exp $	*/
d3274 1
a3274 1
	if (rev >= 0xC2) {
a3277 12
		/* set south-bridge's enable bit, m1533, 0x79 */
		if (rev == 0xC2)
			/* 1543C-B0 (m1533, 0x79, bit 2) */
			pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_0x79,
			    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_0x79)
			    | ACER_0x79_REVC2_EN);
		else
			/* 1553/1535 (m1533, 0x79, bit 1) */
			pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_0x79,
			    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_0x79)
			    | ACER_0x79_EN);
	}
d3630 1
a3630 2
		if((dmastat & ( IDEDMA_CTL_ACT | IDEDMA_CTL_INTR)) !=
		    IDEDMA_CTL_INTR)
@


1.82
log
@- add support for PDC20268R (not tested) and PDC20269
- fix interrupt handling when IRQ is shared
- cable detection
- sync with NetBSD

Work by Alexander Yurchenko <grange@@rt.mipt.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.81 2002/03/14 03:16:06 millert Exp $	*/
d310 8
d1510 2
d1524 2
d1556 3
a1558 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ) {
d1615 3
a1617 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ) {
d1778 3
a1780 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ) {
d1784 3
a1786 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE) {
@


1.81
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.80 2002/03/14 01:26:59 millert Exp $	*/
d231 1
d253 1
a253 1
void pciide_print_channels(int, pcireg_t);;
d430 8
d3643 1
a3643 2
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268)
d3647 3
a3649 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268)
d3651 3
a3653 1
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268)
d3667 2
a3668 2
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: "
		    "controller state 0x%x\n", st), DEBUG_PROBE);
d3682 1
a3682 1
	if (PDC_IS_268(sc) || st & PDC2xx_STATE_NATIVE)
d3703 2
a3704 1
	sc->sc_wdcdev.set_modes = pdc202xx_setup_channel;
d3709 24
d3734 22
a3755 14
	if (PDC_IS_268(sc))
		goto pdc268_doesnt_need_it;
	/* setup failsafe defaults */
	mode = 0;
	mode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[0]);
	mode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[0]);
	mode = PDC2xx_TIM_SET_MB(mode, pdc2xx_dma_mb[0]);
	mode = PDC2xx_TIM_SET_MC(mode, pdc2xx_dma_mc[0]);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: channel %d drive 0 "
		    "initial timings  0x%x, now 0x%x\n", channel,
		    pci_conf_read(sc->sc_pc, sc->sc_tag,
		    PDC2xx_TIM(channel, 0)), mode | PDC2xx_TIM_IORDYp),
d3757 7
a3763 8
		pci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_TIM(channel, 0),
		    mode | PDC2xx_TIM_IORDYp);
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: channel %d drive 1 "
		    "initial timings  0x%x, now 0x%x\n", channel,
		pci_conf_read(sc->sc_pc, sc->sc_tag,
	 	    PDC2xx_TIM(channel, 1)), mode), DEBUG_PROBE);
		pci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_TIM(channel, 1),
		    mode);
a3765 27
	mode = PDC2xx_SCR_DMA;
	if (PDC_IS_262(sc)) {
		mode = PDC2xx_SCR_SET_GEN(mode, PDC262_SCR_GEN_LAT);
	} else {
		/* the BIOS set it up this way */
		mode = PDC2xx_SCR_SET_GEN(mode, 0x1);
	}
	mode = PDC2xx_SCR_SET_I2C(mode, 0x3); /* ditto */
	mode = PDC2xx_SCR_SET_POLL(mode, 0x1); /* ditto */
	WDCDEBUG_PRINT(("pdc202xx_setup_chip: initial SCR  0x%x, now 0x%x\n",
	    bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SCR), mode),
	    DEBUG_PROBE);
	bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SCR, mode);

	/* controller initial state register is OK even without BIOS */
	/* Set DMA mode to IDE DMA compatibility */
	mode = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM);
	WDCDEBUG_PRINT(("pdc202xx_setup_chip: primary mode 0x%x", mode ),
	    DEBUG_PROBE);
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM,
	    mode | 0x1);
	mode = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM);
	WDCDEBUG_PRINT((", secondary mode 0x%x\n", mode ), DEBUG_PROBE);
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM,
	    mode | 0x1);

pdc268_doesnt_need_it:
d3772 1
a3772 1
			printf("%s: %s ignored (disabled)\n",
d3794 5
a3798 2
		pdc202xx_setup_channel(&cp->wdc_channel);
        }
d3800 2
a3801 2
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: "
		"new controller state 0x%x\n", st), DEBUG_PROBE);
a3821 3
	if (PDC_IS_268(sc))
		goto skip_for_pdc268;
	
a3885 1
			drvp->drive_flags &= ~DRIVE_DMA;
d3921 22
d3944 21
a3964 1
skip_for_pdc268:
d3994 1
a3994 1
        }
d4007 9
@


1.80
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.79 2002/03/01 20:01:35 chris Exp $	*/
d247 3
a249 3
int  pciide_dma_init(void*, int, int, void *, size_t, int);
void pciide_dma_start(void*, int, int);
int  pciide_dma_finish(void*, int, int);
d504 1
a504 1
int	pciide_mapregs_native __P((struct pci_attach_args *, 
d506 1
a506 1
	    int (*pci_intr)(void *)));
d510 1
a510 1
void	pciide_mapchan __P((struct pci_attach_args *,
d512 1
a512 1
	    int (*pci_intr)(void *)));
@


1.79
log
@From NetBSD, noticed by Alexander Yurchenko

"In hpt_pci_intr(): There is interrupt pending once IDEDMA_CTL_ACT is
turned off. It seems that IDEDMA_CTL_INTR is asserted before DMA transfer
is complete, leading to race condition in case of interrupt sharing.
Discovered reading the FreeBSD code."
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.78 2002/02/16 08:18:57 chris Exp $	*/
d123 4
a126 4
static __inline u_int8_t pciide_pci_read __P((pci_chipset_tag_t, pcitag_t,
					      int));
static __inline void pciide_pci_write __P((pci_chipset_tag_t, pcitag_t,
					   int, u_int8_t));
d191 1
a191 1
void default_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
d193 51
a243 51
void piix_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void piix_setup_channel __P((struct channel_softc*));
void piix3_4_setup_channel __P((struct channel_softc*));

static u_int32_t piix_setup_idetim_timings __P((u_int8_t, u_int8_t, u_int8_t));
static u_int32_t piix_setup_idetim_drvs __P((struct ata_drive_datas*));
static u_int32_t piix_setup_sidetim_timings __P((u_int8_t, u_int8_t, u_int8_t));

void amd756_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void amd756_setup_channel __P((struct channel_softc*));

void apollo_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void apollo_setup_channel __P((struct channel_softc*));

void cmd_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void cmd0643_9_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void cmd0643_9_setup_channel __P((struct channel_softc*));
void cmd_channel_map __P((struct pci_attach_args *,
			struct pciide_softc *, int));
int  cmd_pci_intr __P((void *));
void cmd646_9_irqack __P((struct channel_softc *));

void cy693_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void cy693_setup_channel __P((struct channel_softc*));

void sis_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void sis_setup_channel __P((struct channel_softc*));

void natsemi_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void natsemi_setup_channel __P((struct channel_softc*));
int  natsemi_pci_intr __P((void *));

void acer_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void acer_setup_channel __P((struct channel_softc*));
int  acer_pci_intr __P((void *));

void pdc202xx_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void pdc202xx_setup_channel __P((struct channel_softc*));
int  pdc202xx_pci_intr __P((void *));
int  pdc20265_pci_intr __P((void *));

void opti_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void opti_setup_channel __P((struct channel_softc*));

void hpt_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void hpt_setup_channel __P((struct channel_softc*));
int  hpt_pci_intr __P((void *));

void acard_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void acard_setup_channel __P((struct channel_softc*));
int  acard_pci_intr __P((void *));
d245 8
a252 8
void pciide_channel_dma_setup __P((struct pciide_channel *));
int  pciide_dma_table_setup __P((struct pciide_softc*, int, int));
int  pciide_dma_init __P((void*, int, int, void *, size_t, int));
void pciide_dma_start __P((void*, int, int));
int  pciide_dma_finish __P((void*, int, int));
void pciide_irqack __P((struct channel_softc *));
void pciide_print_modes __P((struct pciide_channel *));
void pciide_print_channels __P((int, pcireg_t));;
d258 1
a258 1
	void (*chip_map) __P((struct pciide_softc*, struct pci_attach_args*));
d486 1
a486 1
int	pciide_match __P((struct device *, struct cfdata *, void *));
d488 1
a488 1
int	pciide_match __P((struct device *, void *, void *));
d490 1
a490 1
void	pciide_attach __P((struct device *, struct device *, void *));
d501 3
a503 3
int	pciide_chipen __P((struct pciide_softc *, struct pci_attach_args *));
int	pciide_mapregs_compat __P(( struct pci_attach_args *,
	    struct pciide_channel *, int, bus_size_t *, bus_size_t*));
d506 4
a509 4
	    int (*pci_intr) __P((void *))));
void	pciide_mapreg_dma __P((struct pciide_softc *,
	    struct pci_attach_args *));
int	pciide_chansetup __P((struct pciide_softc *, int, pcireg_t));
d512 8
a519 8
	    int (*pci_intr) __P((void *))));
int	pciide_chan_candisable __P((struct pciide_channel *));
void	pciide_map_compat_intr __P(( struct pci_attach_args *,
	    struct pciide_channel *, int, int));
void	pciide_unmap_compat_intr __P(( struct pci_attach_args *,
	    struct pciide_channel *, int, int));
int	pciide_compat_intr __P((void *));
int	pciide_pci_intr __P((void *));
d522 1
a522 1
const struct pciide_product_desc* pciide_lookup_product __P((u_int32_t));
d692 1
a692 1
	int (*pci_intr) __P((void *));
d1221 1
a1221 1
	int (*pci_intr) __P((void *));
@


1.78
log
@Disable udma5 on the HPT370 for now.  The silent data corruption disappears
at udma4.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.77 2002/02/10 04:29:32 chris Exp $	*/
d3613 2
a3614 1
		if ((dmastat & IDEDMA_CTL_INTR) == 0)
@


1.77
log
@Match the VT8366_ISA (chip VT8233) south bridge as ATA100
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.76 2001/12/11 22:04:12 chris Exp $	*/
d3480 7
a3486 1
		sc->sc_wdcdev.UDMA_cap = 5;
@


1.76
log
@Support Promise Ultra100TX2 (PDC20268)

from Alexander Yurchenko <grange@@rt.mipt.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.75 2001/11/18 20:55:42 deraadt Exp $	*/
d2147 4
d2522 4
@


1.76.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.76 2001/12/11 22:04:12 chris Exp $	*/
d123 4
a126 4
static __inline u_int8_t pciide_pci_read(pci_chipset_tag_t, pcitag_t,
					      int);
static __inline void pciide_pci_write(pci_chipset_tag_t, pcitag_t,
					   int, u_int8_t);
d191 1
a191 1
void default_chip_map(struct pciide_softc*, struct pci_attach_args*);
d193 51
a243 52
void piix_chip_map(struct pciide_softc*, struct pci_attach_args*);
void piix_setup_channel(struct channel_softc*);
void piix3_4_setup_channel(struct channel_softc*);

static u_int32_t piix_setup_idetim_timings(u_int8_t, u_int8_t, u_int8_t);
static u_int32_t piix_setup_idetim_drvs(struct ata_drive_datas*);
static u_int32_t piix_setup_sidetim_timings(u_int8_t, u_int8_t, u_int8_t);

void amd756_chip_map(struct pciide_softc*, struct pci_attach_args*);
void amd756_setup_channel(struct channel_softc*);

void apollo_chip_map(struct pciide_softc*, struct pci_attach_args*);
void apollo_setup_channel(struct channel_softc*);

void cmd_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cmd0643_9_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cmd0643_9_setup_channel(struct channel_softc*);
void cmd_channel_map(struct pci_attach_args *,
			struct pciide_softc *, int);
int  cmd_pci_intr(void *);
void cmd646_9_irqack(struct channel_softc *);

void cy693_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cy693_setup_channel(struct channel_softc*);

void sis_chip_map(struct pciide_softc*, struct pci_attach_args*);
void sis_setup_channel(struct channel_softc*);

void natsemi_chip_map(struct pciide_softc*, struct pci_attach_args*);
void natsemi_setup_channel(struct channel_softc*);
int  natsemi_pci_intr(void *);

void acer_chip_map(struct pciide_softc*, struct pci_attach_args*);
void acer_setup_channel(struct channel_softc*);
int  acer_pci_intr(void *);

void pdc202xx_chip_map(struct pciide_softc*, struct pci_attach_args*);
void pdc202xx_setup_channel(struct channel_softc*);
void pdc20268_setup_channel(struct channel_softc*);
int  pdc202xx_pci_intr(void *);
int  pdc20265_pci_intr(void *);

void opti_chip_map(struct pciide_softc*, struct pci_attach_args*);
void opti_setup_channel(struct channel_softc*);

void hpt_chip_map(struct pciide_softc*, struct pci_attach_args*);
void hpt_setup_channel(struct channel_softc*);
int  hpt_pci_intr(void *);

void acard_chip_map(struct pciide_softc*, struct pci_attach_args*);
void acard_setup_channel(struct channel_softc*);
int  acard_pci_intr(void *);
d245 8
a252 8
void pciide_channel_dma_setup(struct pciide_channel *);
int  pciide_dma_table_setup(struct pciide_softc*, int, int);
int  pciide_dma_init(void *, int, int, void *, size_t, int);
void pciide_dma_start(void *, int, int);
int  pciide_dma_finish(void *, int, int);
void pciide_irqack(struct channel_softc *);
void pciide_print_modes(struct pciide_channel *);
void pciide_print_channels(int, pcireg_t);
d258 1
a258 1
	void (*chip_map)(struct pciide_softc*, struct pci_attach_args*);
a308 8
	{ PCI_PRODUCT_INTEL_82801CAM_IDE, /* Intel 82801CAM IDE (ICH2) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801CA_IDE, /* Intel 82801CA IDE (ICH2) */
	  0,
	  piix_chip_map
	},
a319 8
	{ PCI_PRODUCT_AMD_PBC768_IDE,
	  0,
	  amd756_chip_map
	},
	{ PCI_PRODUCT_AMD_8111_IDE,
	  0,
	  amd756_chip_map
	}
a428 8
	},
	{ PCI_PRODUCT_PROMISE_PDC20268R,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20269,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
d486 1
a486 1
int	pciide_match(struct device *, struct cfdata *, void *);
d488 1
a488 1
int	pciide_match(struct device *, void *, void *);
d490 1
a490 1
void	pciide_attach(struct device *, struct device *, void *);
d501 4
a504 4
int	pciide_chipen(struct pciide_softc *, struct pci_attach_args *);
int	pciide_mapregs_compat( struct pci_attach_args *,
	    struct pciide_channel *, int, bus_size_t *, bus_size_t*);
int	pciide_mapregs_native(struct pci_attach_args *, 
d506 5
a510 5
	    int (*pci_intr)(void *));
void	pciide_mapreg_dma(struct pciide_softc *,
	    struct pci_attach_args *);
int	pciide_chansetup(struct pciide_softc *, int, pcireg_t);
void	pciide_mapchan(struct pci_attach_args *,
d512 8
a519 8
	    int (*pci_intr)(void *));
int	pciide_chan_candisable(struct pciide_channel *);
void	pciide_map_compat_intr( struct pci_attach_args *,
	    struct pciide_channel *, int, int);
void	pciide_unmap_compat_intr( struct pci_attach_args *,
	    struct pciide_channel *, int, int);
int	pciide_compat_intr(void *);
int	pciide_pci_intr(void *);
d522 1
a522 1
const struct pciide_product_desc* pciide_lookup_product(u_int32_t);
d692 1
a692 1
	int (*pci_intr)(void *);
d1221 1
a1221 1
	int (*pci_intr)(void *);
a1492 2
		case PCI_PRODUCT_INTEL_82801CAM_IDE:
		case PCI_PRODUCT_INTEL_82801CA_IDE:
a1504 2
	case PCI_PRODUCT_INTEL_82801CAM_IDE:
	case PCI_PRODUCT_INTEL_82801CA_IDE:
d1535 1
a1535 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE) {
d1592 1
a1592 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE) {
d1753 1
a1753 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE) {
d1757 1
a1757 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE) {
a1951 2
	case PCI_PRODUCT_AMD_PBC768_IDE:
	case PCI_PRODUCT_AMD_8111_IDE:
a2146 4
	case PCI_PRODUCT_VIATECH_VT8366_ISA:
		printf(": ATA100");
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
a2517 4
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
			sc->sc_wdcdev.UDMA_cap = 5;
			sc->sc_wdcdev.irqack = cmd646_9_irqack;
			break;
d3237 1
a3237 1
	if (rev >= 0xC2)
d3241 12
d3472 1
a3472 7
		/*
		 * XXX disable udma5 for now. 
		 */
		if (revision == HPT370_REV)
			sc->sc_wdcdev.UDMA_cap = 4;
		else
			sc->sc_wdcdev.UDMA_cap = 5;
d3599 1
a3599 2
		if((dmastat & (IDEDMA_CTL_ACT | IDEDMA_CTL_INTR)) !=
		    IDEDMA_CTL_INTR)
d3619 2
a3620 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267)
d3624 1
a3624 3
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268R ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269)
d3626 1
a3626 3
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268R ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269)
d3640 2
a3641 2
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: controller state 0x%x\n",
		    st), DEBUG_PROBE);
d3655 1
a3655 1
	if (PDC_IS_268(sc) || (st & PDC2xx_STATE_NATIVE))
d3676 1
a3676 2
	sc->sc_wdcdev.set_modes = PDC_IS_268(sc) ?
			pdc20268_setup_channel : pdc202xx_setup_channel;
a3680 24
	if (!PDC_IS_268(sc)) {
		/* setup failsafe defaults */
		mode = 0;
		mode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[0]);
		mode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[0]);
		mode = PDC2xx_TIM_SET_MB(mode, pdc2xx_dma_mb[0]);
		mode = PDC2xx_TIM_SET_MC(mode, pdc2xx_dma_mc[0]);
		for (channel = 0;
		     channel < sc->sc_wdcdev.nchannels;
		     channel++) {
			WDCDEBUG_PRINT(("pdc202xx_setup_chip: channel %d "
			    "drive 0 initial timings  0x%x, now 0x%x\n",
			    channel, pci_conf_read(sc->sc_pc, sc->sc_tag,
			    PDC2xx_TIM(channel, 0)), mode | PDC2xx_TIM_IORDYp),
			    DEBUG_PROBE);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PDC2xx_TIM(channel, 0), mode | PDC2xx_TIM_IORDYp);
			WDCDEBUG_PRINT(("pdc202xx_setup_chip: channel %d "
			    "drive 1 initial timings  0x%x, now 0x%x\n",
			    channel, pci_conf_read(sc->sc_pc, sc->sc_tag,
	 		    PDC2xx_TIM(channel, 1)), mode), DEBUG_PROBE);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PDC2xx_TIM(channel, 1), mode);
		}
d3682 14
a3695 22
		mode = PDC2xx_SCR_DMA;
		if (PDC_IS_262(sc)) {
			mode = PDC2xx_SCR_SET_GEN(mode, PDC262_SCR_GEN_LAT);
		} else {
			/* the BIOS set it up this way */
			mode = PDC2xx_SCR_SET_GEN(mode, 0x1);
		}
		mode = PDC2xx_SCR_SET_I2C(mode, 0x3); /* ditto */
		mode = PDC2xx_SCR_SET_POLL(mode, 0x1); /* ditto */
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: initial SCR  0x%x, "
		    "now 0x%x\n",
		    bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh,
			PDC2xx_SCR),
		    mode), DEBUG_PROBE);
		bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC2xx_SCR, mode);

		/* controller initial state register is OK even without BIOS */
		/* Set DMA mode to IDE DMA compatibility */
		mode =
		    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM);
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: primary mode 0x%x", mode),
d3697 16
a3712 7
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM,
		    mode | 0x1);
		mode =
		    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM);
		WDCDEBUG_PRINT((", secondary mode 0x%x\n", mode ), DEBUG_PROBE);
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM,
		    mode | 0x1);
d3714 6
d3721 13
d3740 1
a3740 1
			printf("%s: %s channel ignored (disabled)\n",
d3762 2
a3763 5
		if (PDC_IS_268(sc))
			pdc20268_setup_channel(&cp->wdc_channel);
		else
			pdc202xx_setup_channel(&cp->wdc_channel);
	}
d3765 2
a3766 2
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: new controller state "
		    "0x%x\n", st), DEBUG_PROBE);
d3787 3
d3854 1
a3889 22
	pciide_print_modes(cp);
}

void
pdc20268_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	int drive, cable;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	/* check 80 pins cable */
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC268_REG0, 0x0b);
	cable = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_REG1) & 0x04;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;
d3891 1
a3891 21
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			if (cable && drvp->UDMA_mode > 2)
				drvp->UDMA_mode = 2;
		} else if (drvp->drive_flags & DRIVE_DMA) {
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		}
	}
	/* nothing to do to setup modes, the controller snoop SET_FEATURE cmd */
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL, idedma_ctl);
	}
d3921 1
a3921 1
	}
a3933 9

	/* process our own interrupts only during IRQ sharing */
	if (PDC_IS_268(sc)) {
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC268_REG0, 0xb);
		if (!(bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC268_REG1) & 0x20))
			return 0;
	}
@


1.76.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.76.2.1 2002/06/11 03:42:27 art Exp $	*/
a209 3
void cmd680_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cmd680_setup_channel(struct channel_softc*);
void cmd680_channel_map(struct pci_attach_args *, struct pciide_softc *, int);
a244 4

void serverworks_chip_map(struct pciide_softc*, struct pci_attach_args*);
void serverworks_setup_channel(struct channel_softc*);
int  serverworks_pci_intr(void *);
d310 1
a310 1
	{ PCI_PRODUCT_INTEL_82801CAM_IDE, /* Intel 82801CAM IDE (ICH3) */
d314 1
a314 5
	{ PCI_PRODUCT_INTEL_82801CA_IDE, /* Intel 82801CA IDE (ICH3) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801DB_IDE, /* Intel 82801DB IDE (ICH4) */
a376 4
	},
	{ PCI_PRODUCT_CMDTECH_680,	/* CMD Technology PCI0680 */
	  IDE_PCI_CLASS_OVERRIDE,
	  cmd680_chip_map
a422 8
	},
	{ PCI_PRODUCT_TRIONES_HPT372A,	/* Highpoint HPT372A IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map
	},
	{ PCI_PRODUCT_TRIONES_HPT374,	/* Highpoint HPT374 IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map
a453 8
	},
	{ PCI_PRODUCT_PROMISE_PDC20271,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20276,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
a471 12
const struct pciide_product_desc pciide_serverworks_products[] =  {
	{ PCI_PRODUCT_RCC_OSB4_IDE,
	  0,
	  serverworks_chip_map,
	},
	{ PCI_PRODUCT_RCC_CSB5_IDE,
	  0,
	  serverworks_chip_map,
	},
};


a502 2
	{ PCI_VENDOR_RCC, pciide_serverworks_products,
	  sizeof(pciide_serverworks_products)/sizeof(pciide_serverworks_products[0]) },
d896 1
a896 1
		panic("pciide compat intr called for non-compat chan %p", cp);
a1519 1
		case PCI_PRODUCT_INTEL_82801DB_IDE:
a1533 1
	case PCI_PRODUCT_INTEL_82801DB_IDE:
d1566 1
a1566 2
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
d1625 1
a1625 2
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
d1788 1
a1788 2
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
d1794 1
a1794 2
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
a2726 176
cmd680_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
{
	struct pciide_channel *cp;
	int channel;

	if (pciide_chipen(sc, pa) == 0)
		return;
	printf("\n%s: bus-master DMA support present",
	    sc->sc_wdcdev.sc_dev.dv_xname);
	pciide_mapreg_dma(sc, pa);
	printf("\n");
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.UDMA_cap = 6;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = cmd680_setup_channel;

	pciide_pci_write(sc->sc_pc, sc->sc_tag, 0x80, 0x00);
	pciide_pci_write(sc->sc_pc, sc->sc_tag, 0x84, 0x00);
	pciide_pci_write(sc->sc_pc, sc->sc_tag, 0x8a,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, 0x8a) | 0x01);
	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		cmd680_channel_map(pa, sc, channel);
		if (cp->hw_ok == 0)
			continue;
		cmd680_setup_channel(&cp->wdc_channel);
	}
}

void
cmd680_channel_map(pa, sc, channel)
	struct pci_attach_args *pa;
	struct pciide_softc *sc;
	int channel;
{
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	bus_size_t cmdsize, ctlsize;
	int interface, i, reg;
	static const u_int8_t init_val[] =
	    {             0x8a, 0x32, 0x8a, 0x32, 0x8a, 0x32,
	      0x92, 0x43, 0x92, 0x43, 0x09, 0x40, 0x09, 0x40 };

	if (PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCIIDE_INTERFACE_SETTABLE(0) |
		    PCIIDE_INTERFACE_SETTABLE(1);
		interface |= PCIIDE_INTERFACE_PCI(0) |
		    PCIIDE_INTERFACE_PCI(1);
	} else {
		interface = PCI_INTERFACE(pa->pa_class);
	}

	sc->wdc_chanarray[channel] = &cp->wdc_channel;
	cp->name = PCIIDE_CHANNEL_NAME(channel);
	cp->wdc_channel.channel = channel;
	cp->wdc_channel.wdc = &sc->sc_wdcdev;

	cp->wdc_channel.ch_queue =
	    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);
	if (cp->wdc_channel.ch_queue == NULL) {
		printf("%s %s channel: "
		    "can't allocate memory for command queue",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		    return;
	}

	/* XXX */
	reg = 0xa2 + channel * 16;
	for (i = 0; i < sizeof(init_val); i++)
		pciide_pci_write(sc->sc_pc, sc->sc_tag, reg + i, init_val[i]);

	printf("%s: %s channel %s to %s mode\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
	    (interface & PCIIDE_INTERFACE_SETTABLE(channel)) ?
	    "configured" : "wired",
	    (interface & PCIIDE_INTERFACE_PCI(channel)) ?
	    "native-PCI" : "compatibility");

	pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, pciide_pci_intr);
	if (cp->hw_ok == 0)
		return;
	pciide_map_compat_intr(pa, cp, channel, interface);
}

void
cmd680_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	u_int8_t mode, off, scsc;
	u_int16_t val;
	u_int32_t idedma_ctl;
	int drive;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	pci_chipset_tag_t pc = sc->sc_pc;
	pcitag_t pa = sc->sc_tag;
	static const u_int8_t udma2_tbl[] =
	    { 0x0f, 0x0b, 0x07, 0x06, 0x03, 0x02, 0x01 };
	static const u_int8_t udma_tbl[] =
	    { 0x0c, 0x07, 0x05, 0x04, 0x02, 0x01, 0x00 };
	static const u_int16_t dma_tbl[] =
	    { 0x2208, 0x10c2, 0x10c1 };
	static const u_int16_t pio_tbl[] =
	    { 0x328a, 0x2283, 0x1104, 0x10c3, 0x10c1 };

	idedma_ctl = 0;
	pciide_channel_dma_setup(cp);
	mode = pciide_pci_read(pc, pa, 0x80 + chp->channel * 4);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		mode &= ~(0x03 << (drive * 4));
		if (drvp->drive_flags & DRIVE_UDMA) {
			drvp->drive_flags &= ~DRIVE_DMA;
			off = 0xa0 + chp->channel * 16;
			if (drvp->UDMA_mode > 2 &&
			    (pciide_pci_read(pc, pa, off) & 0x01) == 0)
				drvp->UDMA_mode = 2;
			scsc = pciide_pci_read(pc, pa, 0x8a);
			if (drvp->UDMA_mode == 6 && (scsc & 0x30) == 0) {
				pciide_pci_write(pc, pa, 0x8a, scsc | 0x01);
				scsc = pciide_pci_read(pc, pa, 0x8a);
				if ((scsc & 0x30) == 0)
					drvp->UDMA_mode = 5;
			}
			mode |= 0x03 << (drive * 4);
			off = 0xac + chp->channel * 16 + drive * 2;
			val = pciide_pci_read(pc, pa, off) & ~0x3f;
			if (scsc & 0x30)
				val |= udma2_tbl[drvp->UDMA_mode];
			else
				val |= udma_tbl[drvp->UDMA_mode];
			pciide_pci_write(pc, pa, off, val);
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			mode |= 0x02 << (drive * 4);
			off = 0xa8 + chp->channel * 16 + drive * 2;
			val = dma_tbl[drvp->DMA_mode];
			pciide_pci_write(pc, pa, off, val & 0xff);
			pciide_pci_write(pc, pa, off, val >> 8);
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			mode |= 0x01 << (drive * 4);
			off = 0xa4 + chp->channel * 16 + drive * 2;
			val = pio_tbl[drvp->PIO_mode];
			pciide_pci_write(pc, pa, off, val & 0xff);
			pciide_pci_write(pc, pa, off, val >> 8);
		}
	}

	pciide_pci_write(pc, pa, 0x80 + chp->channel * 4, mode);
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),
		    idedma_ctl);
	}
	pciide_print_modes(cp);
}

void
d3469 1
a3469 5
               if ((sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
		   (revision == HPT370_REV || revision == HPT370A_REV ||
		    revision == HPT372_REV)) ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374)
d3488 1
a3488 2
	if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
	    revision == HPT366_REV) {
d3507 7
a3513 15
		if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374 ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A) 
			sc->sc_wdcdev.UDMA_cap = 6;
		else if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366) {
			if (revision == HPT372_REV)
				sc->sc_wdcdev.UDMA_cap = 6;
			else
				sc->sc_wdcdev.UDMA_cap = 5;
			if (revision == HPT370_REV) {
				/*
				 * XXX disable udma5 for now. 
				 */
				sc->sc_wdcdev.UDMA_cap = 4;
			}
		}
d3542 1
a3542 5
	if ((sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
	    (revision == HPT370_REV || revision == HPT370A_REV ||
	    revision == HPT372_REV)) ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374) {
d3544 2
a3545 2
		 * HPT370 and highter has a bit to disable interrupts,
		 * make sure to clear it
a3550 9
	/* set clocks, etc (mandatory on 372/4, optional otherwise) */
	if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374 ||
	    (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
	    revision == HPT372_REV))
		pciide_pci_write(sc->sc_pc, sc->sc_tag, HPT_SC2,
		    (pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT_SC2) &
		     HPT_SC2_MAEN) | HPT_SC2_OSC_EN);

d3590 1
a3590 3
			    ((sc->sc_wdcdev.UDMA_cap == 6) ?
			    hpt374_udma[drvp->UDMA_mode] :
			    hpt370_udma[drvp->UDMA_mode]) :
d3604 1
a3604 3
			    ((sc->sc_wdcdev.UDMA_cap == 6) ?
			    hpt374_dma[drvp->DMA_mode] :
			    hpt370_dma[drvp->DMA_mode]) :
d3610 1
a3610 3
			    ( (sc->sc_wdcdev.UDMA_cap == 6) ?
			    hpt374_pio[drvp->PIO_mode] :
			    hpt370_pio[drvp->PIO_mode]) :
d3667 1
a3667 3
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20271  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276)
d3671 1
a3671 7
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20271  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276)
#define PDC_IS_269(sc)							\
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20271  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276)
d3715 1
a3715 3
	if (PDC_IS_269(sc))
		sc->sc_wdcdev.UDMA_cap = 6;
	else if (PDC_IS_265(sc))
a4288 168
}

void
serverworks_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
{
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	pcitag_t pcib_tag;
	int channel;
	bus_size_t cmdsize, ctlsize;

	if (pciide_chipen(sc, pa) == 0)
		return;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_RCC_OSB4_IDE:
		sc->sc_wdcdev.UDMA_cap = 2;
		break;
	case PCI_PRODUCT_RCC_CSB5_IDE:
		if (PCI_REVISION(pa->pa_class) < 0x92)
			sc->sc_wdcdev.UDMA_cap = 4;
		else
			sc->sc_wdcdev.UDMA_cap = 5;
		break;
	}

	sc->sc_wdcdev.set_modes = serverworks_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = 2;

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    serverworks_pci_intr);
		if (cp->hw_ok == 0)
			return;
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			return;
		serverworks_setup_channel(&cp->wdc_channel);
	}

	pcib_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, pa->pa_device, 0);
	pci_conf_write(pa->pa_pc, pcib_tag, 0x64,
	    (pci_conf_read(pa->pa_pc, pcib_tag, 0x64) & ~0x2000) | 0x4000);
}

void
serverworks_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	int drive, unit;
	u_int32_t pio_time, dma_time, pio_mode, udma_mode;
	u_int32_t idedma_ctl;
	static const u_int8_t pio_modes[5] = {0x5d, 0x47, 0x34, 0x22, 0x20};
	static const u_int8_t dma_modes[3] = {0x77, 0x21, 0x20};

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	pio_time = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x40);
	dma_time = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x44);
	pio_mode = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x48);
	udma_mode = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x54);

	pio_time &= ~(0xffff << (16 * channel));
	dma_time &= ~(0xffff << (16 * channel));
	pio_mode &= ~(0xff << (8 * channel + 16));
	udma_mode &= ~(0xff << (8 * channel + 16));
	udma_mode &= ~(3 << (2 * channel));

	idedma_ctl = 0;

	/* Per drive settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		unit = drive + 2 * channel;
		/* add timing values, setup DMA if needed */
		pio_time |= pio_modes[drvp->PIO_mode] << (8 * (unit^1));
		pio_mode |= drvp->PIO_mode << (4 * unit + 16);
		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&
		    (drvp->drive_flags & DRIVE_UDMA)) {
			/* use Ultra/DMA, check for 80-pin cable */
			if (drvp->UDMA_mode > 2 &&
			    (PCI_PRODUCT(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_SUBSYS_ID_REG)) & (1 << (14 + channel))) == 0)
				drvp->UDMA_mode = 2;
			dma_time |= dma_modes[drvp->DMA_mode] << (8 * (unit^1));
			udma_mode |= drvp->UDMA_mode << (4 * unit + 16);
			udma_mode |= 1 << unit;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) &&
		    (drvp->drive_flags & DRIVE_DMA)) {
			/* use Multiword DMA */
			drvp->drive_flags &= ~DRIVE_UDMA;
			dma_time |= dma_modes[drvp->DMA_mode] << (8 * (unit^1));
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			/* PIO only */
			drvp->drive_flags &= ~(DRIVE_UDMA | DRIVE_DMA);
		}
	}

	pci_conf_write(sc->sc_pc, sc->sc_tag, 0x40, pio_time);
	pci_conf_write(sc->sc_pc, sc->sc_tag, 0x44, dma_time);
	if (sc->sc_pp->ide_product != PCI_PRODUCT_RCC_OSB4_IDE)
		pci_conf_write(sc->sc_pc, sc->sc_tag, 0x48, pio_mode);
	pci_conf_write(sc->sc_pc, sc->sc_tag, 0x54, udma_mode);

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel, idedma_ctl);
	}
	pciide_print_modes(cp);
}

int
serverworks_pci_intr(arg)
	void *arg;
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int rv = 0;
	int dmastat, i, crv;

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i);
		if ((dmastat & (IDEDMA_CTL_ACT | IDEDMA_CTL_INTR)) !=
		    IDEDMA_CTL_INTR)
			continue;
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		crv = wdcintr(wdc_cp);
		if (crv == 0) {
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
			bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
			    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i, dmastat);
		} else
			rv = 1;
	}
	return rv;
@


1.76.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d17 2
a18 1
 *	This product includes software developed by Manuel Bouyer.
d85 2
a86 4
#define WDCDEBUG_PRINT(args, level) do {		\
	if ((wdcdebug_pciide_mask & (level)) != 0)	\
		printf args;				\
} while (0)
a115 1
#include <dev/pci/pciide_nforce_reg.h>
a167 3
	/* For SiS */
	u_int8_t sis_type;

a222 3
void sis96x_setup_channel(struct channel_softc *);
int  sis_hostbr_match(struct pci_attach_args *);
int  sis_south_match(struct pci_attach_args *);
a226 1
void natsemi_irqack(struct channel_softc *);
a251 4

void nforce_chip_map(struct pciide_softc *, struct pci_attach_args *);
void nforce_setup_channel(struct channel_softc *);
int  nforce_pci_intr(void *);
a481 4
	{ PCI_PRODUCT_PROMISE_PDC20275,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
a484 8
	},
	{ PCI_PRODUCT_PROMISE_PDC20277,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20376,	/* PDC20376 SATA */
	  IDE_PCI_CLASS_OVERRIDE,	/* XXX: subclass RAID */
	  pdc202xx_chip_map,
a511 15
	{ PCI_PRODUCT_RCC_CSB6_IDE,
	  0,
	  serverworks_chip_map,
	},
};

const struct pciide_product_desc pciide_nvidia_products[] = {
	{ PCI_PRODUCT_NVIDIA_NFORCE_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE2_IDE,
	  0,
	  nforce_chip_map
	}
d549 1
a549 3
	  sizeof(pciide_promise_products)/sizeof(pciide_promise_products[0]) },
	{ PCI_VENDOR_NVIDIA, pciide_nvidia_products,
	  sizeof(pciide_nvidia_products)/sizeof(pciide_nvidia_products[0]) }
d678 1
a678 2
		pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo,
		    sizeof devinfo);
d684 4
a687 2
	WDCDEBUG_PRINT((" sc_pc=%p, sc_tag=%p, pa_class=0x%x\n", sc->sc_pc,
	    sc->sc_tag, pa->pa_class), DEBUG_PROBE);
d701 1
a701 1
/* tell whether the chip is enabled or not */
d708 7
a714 5

	csr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);
	if ((csr & PCI_COMMAND_IO_ENABLE) == 0 ) {
		printf("\n%s: device disabled\n",
		    sc->sc_wdcdev.sc_dev.dv_xname);
a716 1

a767 1
	pcireg_t maptype;
a799 6

	maptype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
	    PCIIDE_REG_CMD_BASE(wdc_cp->channel));
	WDCDEBUG_PRINT(("%s: %s cmd regs mapping: %s\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
	    (maptype == PCI_MAPREG_TYPE_IO ? "I/O" : "memory")), DEBUG_PROBE);
d801 1
a801 1
	    maptype, 0,
a807 5
	maptype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
	    PCIIDE_REG_CTL_BASE(wdc_cp->channel));
	WDCDEBUG_PRINT(("%s: %s ctl regs mapping: %s\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
	    (maptype == PCI_MAPREG_TYPE_IO ? "I/O": "memory")), DEBUG_PROBE);
d809 1
a809 1
	    maptype, 0,
d823 1
a823 1
		printf("%s: unable to subregion %s ctl regs\n",
d911 2
a912 1
			    IDEDMA_CTL(cp->wdc_channel.channel));
d1157 1
a1157 1
	    IDEDMA_CTL(channel),
d1159 1
a1159 1
		IDEDMA_CTL(channel)));
d1162 1
a1162 1
	    IDEDMA_TBL(channel),
d1166 1
a1166 1
	    IDEDMA_CMD(channel),
d1182 1
a1182 1
	    IDEDMA_CMD(channel),
d1184 1
a1184 1
		IDEDMA_CMD(channel)) | IDEDMA_CMD_START);
d1203 1
a1203 1
	    IDEDMA_CTL(channel));
d1209 1
a1209 1
	    IDEDMA_CMD(channel),
d1222 1
a1222 1
	    IDEDMA_CTL(channel),
d1254 1
a1254 1
            IDEDMA_CTL(chp->channel),
d1256 1
a1256 1
                IDEDMA_CTL(chp->channel)));
a1315 1
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
a1319 2
		printf("%s: %s disabled (no drives)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
d1353 1
a1353 1
 * generic code to unmap the compat intr if hw_ok=1 and it is a compat channel.
d1528 1
a1528 1
			    IDEDMA_CTL(channel),
d1785 1
a1785 1
		    IDEDMA_CTL(chp->channel),
d1911 1
a1911 1
		    IDEDMA_CTL(channel),
a2096 1
	pcireg_t chanenable;
a2108 2
	chanenable = pci_conf_read(sc->sc_pc, sc->sc_tag,
	    AMD756_CHANSTATUS_EN);
a2127 11

			/* Check cable */
			if ((chanenable & AMD756_CABLE(chp->channel,
			    drive)) == 0 && drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    chp->channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}

d2180 1
a2180 1
		    IDEDMA_CTL(chp->channel),
a2236 4
	case PCI_PRODUCT_VIATECH_VT8231_ISA:
		printf(": ATA100");
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
a2240 8
	case PCI_PRODUCT_VIATECH_VT8233_ISA:
		printf(": ATA133");
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
	case PCI_PRODUCT_VIATECH_VT8235_ISA:
		printf(": ATA133");
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
d2246 1
a2246 1

d2365 2
a2366 4
			if (sc->sc_wdcdev.UDMA_cap == 6) {
				udmatim_reg |= APO_UDMA_TIME(chp->channel,
				    drive, apollo_udma133_tim[drvp->UDMA_mode]);
			} else if (sc->sc_wdcdev.UDMA_cap == 5) {
d2368 1
d2412 1
a2412 1
		    IDEDMA_CTL(chp->channel),
d2484 2
a2485 2
	if (pciide_chan_candisable(cp)) {
		if (channel == 1) {
d2753 1
a2753 1
		    IDEDMA_CTL(chp->channel),
a2756 10
#ifdef __sparc64__
	/*
	 * The Ultra 5 has a tendency to hang during reboot.  This is due
	 * to the PCI0646U asserting a PCI interrupt line when the chip
	 * registers claim that it is not.  Performing a reset at this
	 * point appears to eliminate the symptoms.  It is likely the
	 * real cause is still lurking somewhere in the code.
	 */
	wdcreset(chp, SILENT);
#endif /* __sparc64__ */
d2849 1
a2849 1
		printf("%s %s: "
d2860 1
a2860 1
	printf("%s: %s %s to %s mode\n",
d2947 1
a2947 1
		    IDEDMA_CTL(chp->channel),
d3110 1
a3110 78
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
}

static struct sis_hostbr_type {
	u_int16_t id;
	u_int8_t rev;
	u_int8_t udma_mode;
	char *name;
	u_int8_t type;
#define SIS_TYPE_NOUDMA	0
#define SIS_TYPE_66	1
#define SIS_TYPE_100OLD	2
#define SIS_TYPE_100NEW 3
#define SIS_TYPE_133OLD 4
#define SIS_TYPE_133NEW 5
#define SIS_TYPE_SOUTH	6
} sis_hostbr_type[] = {
	/* Most infos here are from sos@@freebsd.org */
	{PCI_PRODUCT_SIS_530, 0x00, 4, "530", SIS_TYPE_66},
#if 0
	/*
	 * controllers associated to a rev 0x2 530 Host to PCI Bridge
	 * have problems with UDMA (info provided by Christos)
	 */
	{PCI_PRODUCT_SIS_530, 0x02, 0, "530 (buggy)", SIS_TYPE_NOUDMA},
#endif
	{PCI_PRODUCT_SIS_540, 0x00, 4, "540", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_550, 0x00, 4, "550", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_620, 0x00, 4, "620", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_630, 0x00, 4, "630", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_630, 0x30, 5, "630S", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_633, 0x00, 5, "633", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_635, 0x00, 5, "635", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_640, 0x00, 4, "640", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_645, 0x00, 6, "645", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_646, 0x00, 6, "645DX", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_648, 0x00, 6, "648", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_650, 0x00, 6, "650", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_651, 0x00, 6, "651", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_652, 0x00, 6, "652", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_655, 0x00, 6, "655", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_658, 0x00, 6, "658", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_730, 0x00, 5, "730", SIS_TYPE_100OLD},
	{PCI_PRODUCT_SIS_733, 0x00, 5, "733", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_735, 0x00, 5, "735", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_740, 0x00, 5, "740", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_745, 0x00, 5, "745", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_746, 0x00, 6, "746", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_748, 0x00, 6, "748", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_750, 0x00, 6, "750", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_751, 0x00, 6, "751", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_752, 0x00, 6, "752", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_755, 0x00, 6, "755", SIS_TYPE_SOUTH},
	/*
	 * From sos@@freebsd.org: the 0x961 ID will never be found in real world
	 * {PCI_PRODUCT_SIS_961, 0x00, 6, "961", SIS_TYPE_133NEW},
	 */
	{PCI_PRODUCT_SIS_962, 0x00, 6, "962", SIS_TYPE_133NEW},
	{PCI_PRODUCT_SIS_963, 0x00, 6, "963", SIS_TYPE_133NEW}
};

static struct sis_hostbr_type *sis_hostbr_type_match;

int
sis_hostbr_match(struct pci_attach_args *pa)
{
	int i;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_SIS)
		return (0);
	sis_hostbr_type_match = NULL;
	for (i = 0;
	    i < sizeof(sis_hostbr_type) / sizeof(sis_hostbr_type[0]);
	    i++) {
		if (PCI_PRODUCT(pa->pa_id) == sis_hostbr_type[i].id &&
		    PCI_REVISION(pa->pa_class) >= sis_hostbr_type[i].rev)
			sis_hostbr_type_match = &sis_hostbr_type[i];
a3111 9
	return (sis_hostbr_type_match != NULL);
}

int
sis_south_match(struct pci_attach_args *pa)
{
	return(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SIS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SIS_85C503 &&
	    PCI_REVISION(pa->pa_class) >= 0x10);
d3125 2
a3126 2
	pcitag_t br_tag;
	struct pci_attach_args br_pa;
a3130 57
	/* Find PCI bridge (dev 0 func 0 on the same bus) */
	br_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, 0, 0);
	br_pa.pa_id = pci_conf_read(sc->sc_pc, br_tag, PCI_ID_REG);
	br_pa.pa_class = pci_conf_read(sc->sc_pc, br_tag, PCI_CLASS_REG);
	WDCDEBUG_PRINT(("%s: PCI bridge pa_id=0x%x pa_class=0x%x\n",
	    __func__, br_pa.pa_id, br_pa.pa_class), DEBUG_PROBE);

	if (sis_hostbr_match(&br_pa)) {
		if (sis_hostbr_type_match->type == SIS_TYPE_SOUTH) {
			pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_57,
			    pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    SIS_REG_57) & 0x7f);
			if (PCI_PRODUCT(pci_conf_read(sc->sc_pc, sc->sc_tag,
			    PCI_ID_REG)) == SIS_PRODUCT_5518) {
				sc->sis_type = SIS_TYPE_133NEW;
				sc->sc_wdcdev.UDMA_cap =
				    sis_hostbr_type_match->udma_mode;
			} else {
				/* Find ISA bridge (func 0 of the same dev) */
				br_tag = pci_make_tag(pa->pa_pc, pa->pa_bus,
				    pa->pa_device, 0);
				br_pa.pa_id = pci_conf_read(sc->sc_pc,
				    br_tag, PCI_ID_REG);
				br_pa.pa_class = pci_conf_read(sc->sc_pc,
				    br_tag, PCI_CLASS_REG);
				WDCDEBUG_PRINT(("%s: ISA bridge "
				    "pa_id=0x%x pa_class=0x%x\n",
				    __func__, br_pa.pa_id, br_pa.pa_class),
				    DEBUG_PROBE);

				if (sis_south_match(&br_pa)) {
					sc->sis_type = SIS_TYPE_133OLD;
					sc->sc_wdcdev.UDMA_cap =
					    sis_hostbr_type_match->udma_mode;
				} else {
					sc->sis_type = SIS_TYPE_100NEW;
					sc->sc_wdcdev.UDMA_cap =
					    sis_hostbr_type_match->udma_mode;
				}
			}
		} else {
			sc->sis_type = sis_hostbr_type_match->type;
			sc->sc_wdcdev.UDMA_cap =
			    sis_hostbr_type_match->udma_mode;
		}
		printf(": %s", sis_hostbr_type_match->name);
	} else {
		printf(": 5597/5598");
		if (rev >= 0xd0) {
			sc->sc_wdcdev.UDMA_cap = 2;
			sc->sis_type = SIS_TYPE_66;
		} else {
			sc->sc_wdcdev.UDMA_cap = 0;
			sc->sis_type = SIS_TYPE_NOUDMA;
		}
	}

d3134 6
d3145 8
a3152 1
		if (sc->sis_type >= SIS_TYPE_66)
d3158 3
a3163 23
	switch (sc->sis_type) {
	case SIS_TYPE_NOUDMA:
	case SIS_TYPE_66:
	case SIS_TYPE_100OLD:
		sc->sc_wdcdev.set_modes = sis_setup_channel;
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_MISC,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_MISC) |
		    SIS_MISC_TIM_SEL | SIS_MISC_FIFO_SIZE | SIS_MISC_GTC);
		break;
	case SIS_TYPE_100NEW:
	case SIS_TYPE_133OLD:
		sc->sc_wdcdev.set_modes = sis_setup_channel;
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_49,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_49) | 0x01);
		break;
	case SIS_TYPE_133NEW:
		sc->sc_wdcdev.set_modes = sis96x_setup_channel;
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_50,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_50) & 0xf7);
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_52,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_52) & 0xf7);
		break;
	}
d3167 4
d3176 1
a3176 1
		    (channel == 1 && (sis_ctr0 & SIS_CTRL0_CHAN1_EN) == 0)) {
d3202 1
a3202 1
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
a3206 65
sis96x_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t sis_tim;
	u_int32_t idedma_ctl;
	int regtim;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	sis_tim = 0;
	idedma_ctl = 0;
	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		regtim = SIS_TIM133(
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_57),
		    chp->channel, drive);
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			if (pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    SIS96x_REG_CBL(chp->channel)) & SIS96x_REG_CBL_33) {
				if (drvp->UDMA_mode > 2)
					drvp->UDMA_mode = 2;
			}
			sis_tim |= sis_udma133new_tim[drvp->UDMA_mode];
			sis_tim |= sis_pio133new_tim[drvp->PIO_mode];
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			/*
			 * use Multiword DMA
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode > (drvp->DMA_mode + 2))
				drvp->PIO_mode = drvp->DMA_mode + 2;
			if (drvp->DMA_mode + 2 > (drvp->PIO_mode))
				drvp->DMA_mode = (drvp->PIO_mode > 2) ?
				    drvp->PIO_mode - 2 : 0;
			sis_tim |= sis_dma133new_tim[drvp->DMA_mode];
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			sis_tim |= sis_pio133new_tim[drvp->PIO_mode];
		}
		WDCDEBUG_PRINT(("sis96x_setup_channel: new timings reg for "
		    "channel %d drive %d: 0x%x (reg 0x%x)\n",
		    chp->channel, drive, sis_tim, regtim), DEBUG_PROBE);
		pci_conf_write(sc->sc_pc, sc->sc_tag, regtim, sis_tim);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

void
d3239 3
a3241 24
			if (pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    SIS_REG_CBL) & SIS_REG_CBL_33(chp->channel)) {
				if (drvp->UDMA_mode > 2)
					drvp->UDMA_mode = 2;
			}
			switch (sc->sis_type) {
			case SIS_TYPE_66:
			case SIS_TYPE_100OLD:
				sis_tim |= sis_udma66_tim[drvp->UDMA_mode] << 
				    SIS_TIM66_UDMA_TIME_OFF(drive);
				break;
			case SIS_TYPE_100NEW:
				sis_tim |=
				    sis_udma100new_tim[drvp->UDMA_mode] << 
				    SIS_TIM100_UDMA_TIME_OFF(drive);
			case SIS_TYPE_133OLD:
				sis_tim |=
				    sis_udma133old_tim[drvp->UDMA_mode] << 
				    SIS_TIM100_UDMA_TIME_OFF(drive);
				break;
			default:
				printf("unknown SiS IDE type %d\n",
				    sc->sis_type);
			}
d3257 4
a3260 20
pio:		switch (sc->sis_type) {
		case SIS_TYPE_NOUDMA:
		case SIS_TYPE_66:
		case SIS_TYPE_100OLD:
			sis_tim |= sis_pio_act[drvp->PIO_mode] <<
			    SIS_TIM66_ACT_OFF(drive);
			sis_tim |= sis_pio_rec[drvp->PIO_mode] <<
			    SIS_TIM66_REC_OFF(drive);
			break;
		case SIS_TYPE_100NEW:
		case SIS_TYPE_133OLD:
			sis_tim |= sis_pio_act[drvp->PIO_mode] <<
			    SIS_TIM100_ACT_OFF(drive);
			sis_tim |= sis_pio_rec[drvp->PIO_mode] <<
			    SIS_TIM100_REC_OFF(drive);
			break;
		default:
			printf("unknown SiS IDE type %d\n",
			    sc->sis_type);
		}
d3268 1
a3268 1
		    IDEDMA_CTL(chp->channel), idedma_ctl);
d3292 1
a3292 1
		sc->sc_wdcdev.irqack = natsemi_irqack;
d3341 1
a3352 1
	u_int8_t tim;
d3365 11
a3375 16
		if ((drvp->drive_flags & DRIVE_DMA) == 0) {
			tim = natsemi_pio_pulse[drvp->PIO_mode] |
			    (natsemi_pio_recover[drvp->PIO_mode] << 4);
		} else {
			/*
			 * use Multiword DMA
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode >= 3 &&
			    (drvp->DMA_mode + 2) > drvp->PIO_mode) {
				drvp->DMA_mode = drvp->PIO_mode - 2;
			}
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			tim = natsemi_dma_pulse[drvp->DMA_mode] |
			    (natsemi_dma_recover[drvp->DMA_mode] << 4);
d3377 2
a3378 1

d3380 1
a3380 1
		    NATSEMI_RTREG(chp->channel, drive), tim);
d3382 1
a3382 1
		    NATSEMI_WTREG(chp->channel, drive), tim);
d3387 1
a3387 1
		    IDEDMA_CTL(chp->channel), idedma_ctl);
a3394 1

d3399 1
a3399 1
	    IDEDMA_CTL(chp->channel),
d3401 1
a3401 19
		IDEDMA_CTL(chp->channel)));
}

void
natsemi_irqack(chp)
        struct channel_softc *chp;
{
        struct pciide_channel *cp = (struct pciide_channel*)chp;
        struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	u_int8_t clr;

	/* The "clear" bits are in the wrong register *sigh* */
	clr = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(chp->channel));
	clr |= bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(chp->channel)) &
	    (IDEDMA_CTL_ERR | IDEDMA_CTL_INTR);
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(chp->channel), clr);
a3414 1
	msk = pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2);
a3417 1

d3423 1
d3429 1
a3429 2
		    IDEDMA_CTL(i));

a3432 1

d3442 1
a3442 1
	return (rv);
d3638 1
a3638 1
		    IDEDMA_CTL(chp->channel), idedma_ctl);
d3881 1
a3881 1
		    IDEDMA_CTL(chp->channel), idedma_ctl);
d3898 1
a3898 1
		    IDEDMA_CTL(i));
d3909 1
a3909 1
			    IDEDMA_CTL(i), dmastat);
d3928 1
a3928 4
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20275  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)
d3934 1
a3934 4
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20275  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)
d3938 1
a3938 30
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20275  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)

static __inline u_int8_t
pdc268_config_read(struct channel_softc *chp, int index)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;

	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_INDEX(channel), index);
	return (bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_DATA(channel)));
}

static __inline void
pdc268_config_write(struct channel_softc *chp, int index, u_int8_t value)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;

	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_INDEX(channel), index);
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_DATA(channel), value);
}
d4059 1
a4059 1
			printf("%s: %s ignored (disabled)\n",
d4206 1
a4206 1
		    IDEDMA_CTL(channel), idedma_ctl);
a4219 1
	int channel = chp->channel;
d4222 3
a4224 1
	cable = pdc268_config_read(chp, 0x0b) & PDC268_CABLE;
d4240 1
a4240 5
			if (cable && drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive), DEBUG_PROBE);
a4241 1
			}
d4250 1
a4250 1
		    IDEDMA_CTL(channel), idedma_ctl);
d4295 9
a4310 12

		/*
		 * In case of shared IRQ check that the interrupt
		 * was actually generated by this channel.
		 * Only check the channel that is enabled.
		 */
		if (cp->hw_ok && PDC_IS_268(sc)) {
			if ((pdc268_config_read(wdc_cp,
			    0x0b) & PDC268_INTR) == 0)
				continue;
		}

d4318 1
a4318 1
		    sc->sc_dma_ioh, IDEDMA_CTL(i));
d4442 1
a4442 1
			printf("%s: %s ignored (disabled)\n",
a4596 3
	case PCI_PRODUCT_RCC_CSB6_IDE:
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
d4693 1
a4693 1
		    IDEDMA_CTL(channel), idedma_ctl);
d4710 1
a4710 1
		    IDEDMA_CTL(i));
d4721 1
a4721 1
			    IDEDMA_CTL(i), dmastat);
d4888 1
a4888 1
		    IDEDMA_CTL(channel), idedma_ctl);
d4914 1
a4914 1
		    IDEDMA_CTL(i));
d4922 1
a4922 1
			    IDEDMA_CTL(i), dmastat);
a4932 212
	}
	return rv;
}

void
nforce_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;
	u_int32_t conf;

	conf = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_CONF);
	WDCDEBUG_PRINT(("%s: conf register 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, conf), DEBUG_PROBE);

	if (pciide_chipen(sc, pa) == 0)
		return;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_NVIDIA_NFORCE_IDE:
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
	case PCI_PRODUCT_NVIDIA_NFORCE2_IDE:
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
	default:
		sc->sc_wdcdev.UDMA_cap = 0;
	}
	sc->sc_wdcdev.set_modes = nforce_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];

		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		if ((conf & NFORCE_CHAN_EN(channel)) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			continue;
		}

		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    nforce_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		if (pciide_chan_candisable(cp)) {
			conf &= ~NFORCE_CHAN_EN(channel);
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
	WDCDEBUG_PRINT(("%s: new conf register 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, conf), DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_CONF, conf);
}

void
nforce_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, mode;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	u_int32_t conf, piodmatim, piotim, udmatim;

	conf = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_CONF);
	piodmatim = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_PIODMATIM);
	piotim = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_PIOTIM);
	udmatim = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_UDMATIM);
	WDCDEBUG_PRINT(("%s: %s old timing values: piodmatim=0x%x, "
	    "piotim=0x%x, udmatim=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname,
	    cp->name, piodmatim, piotim, udmatim), DEBUG_PROBE);

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	/* Clear all bits for this channel */
	idedma_ctl = 0;
	piodmatim &= ~NFORCE_PIODMATIM_MASK(channel);
	udmatim &= ~NFORCE_UDMATIM_MASK(channel);

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			drvp->drive_flags &= ~DRIVE_DMA;

			/* Check cable */
			if ((conf & NFORCE_CONF_CABLE(channel, drive)) == 0 &&
			    drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}

			udmatim |= NFORCE_UDMATIM_SET(channel, drive,
			    nforce_udma[drvp->UDMA_mode]) |
			    NFORCE_UDMA_EN(channel, drive) |
			    NFORCE_UDMA_ENM(channel, drive);

			mode = drvp->PIO_mode;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			goto pio;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:
		/* Setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
			mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}
		piodmatim |= NFORCE_PIODMATIM_SET(channel, drive,
		    nforce_pio[mode]);
	}

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}

	WDCDEBUG_PRINT(("%s: %s new timing values: piodmatim=0x%x, "
	    "piotim=0x%x, udmatim=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname,
	    cp->name, piodmatim, piotim, udmatim), DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_PIODMATIM, piodmatim);
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_UDMATIM, udmatim);

	pciide_print_modes(cp);
}

int
nforce_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv; 
	u_int32_t dmastat;

	rv = 0;
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;

		/* Skip compat channel */
		if (cp->compat)
			continue;

		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(i));
		if ((dmastat & IDEDMA_CTL_INTR) == 0)
			continue;

		crv = wdcintr(wdc_cp);
		if (crv == 0)
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
		else
			rv = 1;
@


1.75
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.74 2001/11/11 07:43:30 deraadt Exp $	*/
d425 4
a3614 1

d3619 2
a3620 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267)
d3623 4
a3626 3
        (sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267)


d3638 5
a3642 3
	st = pci_conf_read(sc->sc_pc, sc->sc_tag, PDC2xx_STATE);
	WDCDEBUG_PRINT(("pdc202xx_setup_chip: controller state 0x%x\n", st),
	    DEBUG_PROBE);
d3647 2
a3648 1
	st &= ~PDC2xx_STATE_IDERAID;
d3655 1
a3655 1
	if (st & PDC2xx_STATE_NATIVE)
d3682 2
d3733 1
d3738 1
a3738 1
		if ((st & (PDC_IS_262(sc) ?
d3757 1
a3757 1
		if (pciide_chan_candisable(cp)) {
d3764 5
a3768 3
	WDCDEBUG_PRINT(("pdc202xx_setup_chip: new controller state 0x%x\n", st),
	    DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_STATE, st);
d3787 3
d3890 2
@


1.74
log
@Noone seems to want to fix the sparc64 cd bogus intr bug, so I will simply disable the message
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.73 2001/11/06 19:53:19 miod Exp $	*/
d2533 1
a2533 1
                                /* explicitely disable UDMA */
@


1.73
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.72 2001/11/05 17:25:58 art Exp $	*/
d2418 2
a2419 1
			if (crv == 0)
d2422 2
a2423 1
			else
@


1.72
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.71 2001/09/29 04:46:49 jason Exp $	*/
d95 1
a95 1
#include <vm/vm.h>
@


1.71
log
@PC87415: Don't claim to support DATA32 or MODE
(now correctly probes the DMA modes).
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.70 2001/09/29 03:28:11 jason Exp $	*/
a1034 1
#ifdef __HAVE_NEW_BUS_DMAMAP_SYNC
a1038 5
#else
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer,
	    (flags & WDC_DMA_READ) ?
	    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
#endif
a1067 1
#ifdef __HAVE_NEW_BUS_DMAMAP_SYNC
a1070 4
#else
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_table, 
	    BUS_DMASYNC_PREWRITE);
#endif
a1139 1
#ifdef __HAVE_NEW_BUS_DMAMAP_SYNC
a1143 5
#else
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, 
	    (dma_maps->dma_flags & WDC_DMA_READ) ?
	    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
#endif
@


1.71.2.1
log
@Pull in patch from current (Errata 003):
Noone seems to want to fix the sparc64 cd bogus intr bug, so I will simply disab
le the message
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.71 2001/09/29 04:46:49 jason Exp $	*/
d2435 1
a2435 2
			if (crv == 0) {
#if 0
d2438 1
a2438 2
#endif
			} else
@


1.70
log
@for pc87415:
- don't hardwire interrupt interrupts to pci mode
- unmask the pci interrupt if at least one channel is in pci mode
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.69 2001/09/29 02:41:31 jason Exp $	*/
d3025 1
a3025 2
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
@


1.69
log
@add pciide driver for National Semiconductor PC87415.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.68 2001/09/27 16:35:03 gluk Exp $	*/
d3017 1
a3017 1
	pcireg_t interface;
a3033 2
	pciide_pci_write(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL1,
	    NATSEMI_CTRL1_CH1INTMAP | NATSEMI_CTRL1_CH2INTMAP);
d3053 8
@


1.68
log
@style fixes from Alexander Yurchenko <grange@@grange.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.67 2001/09/11 20:05:25 miod Exp $	*/
d115 1
a115 1

d221 4
d388 7
d466 2
d3008 167
@


1.67
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.66 2001/08/31 18:14:37 chris Exp $	*/
d363 1
a363 1
	 },
d400 2
a401 2
	IDE_PCI_CLASS_OVERRIDE,
	pdc202xx_chip_map,
d404 2
a405 2
	IDE_PCI_CLASS_OVERRIDE,
	pdc202xx_chip_map,
d408 2
a409 2
	IDE_PCI_CLASS_OVERRIDE,
	pdc202xx_chip_map,
d412 2
a413 2
	IDE_PCI_CLASS_OVERRIDE,
	pdc202xx_chip_map,
d419 3
a421 3
	 IDE_PCI_CLASS_OVERRIDE,
	 acard_chip_map,
	 },
d423 2
a424 2
	 IDE_PCI_CLASS_OVERRIDE,
	 acard_chip_map,
d427 2
a428 2
	 IDE_PCI_CLASS_OVERRIDE,
	 acard_chip_map,
d625 3
a627 3
	 	   sc->sc_wdcdev.sc_dev.dv_xname,
	  	  (csr & PCI_COMMAND_IO_ENABLE) == 0 ?
		  "device" : "bridge");
d1205 2
a1206 2
			"cannot allocate memory for command queue",
		sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
d1313 1
a1313 1
		    }
d1351 2
a1352 2
		if (sc->sc_dma_ok != 0)
			printf(", (partial support)");
d1373 1
a1373 1
		    continue;
d1587 1
a1587 1
			        DEBUG_PROBE);
d1595 1
a1595 1
			DEBUG_PROBE);
d1754 1
a1754 1
		    ideconf |= PIIX_CONFIG_PINGPONG;
d2201 1
a2201 1
				    ideconf);
d3300 1
a3300 1
	 for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
d3365 1
a3365 1
					HPT_IDETIM(chp->channel, drive));
d3762 2
a3763 2
		if((dmastat & IDEDMA_CTL_INTR) == 0)
		    continue;
@


1.66
log
@Print a hex value with 0x (Alexander Yurchenko <grange@@rt.mipt.ru>)
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.65 2001/08/25 12:43:58 art Exp $	*/
a95 1
#include <vm/vm_kern.h>
@


1.65
log
@ - Use BUS_DMA_RAW if it's defined.
 - pretty.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.64 2001/08/25 10:13:30 art Exp $	*/
d611 1
a611 1
	WDCDEBUG_PRINT(("pciide: command/status register=%x\n",
@


1.64
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.63 2001/08/23 11:25:54 art Exp $	*/
d1009 3
d1015 1
a1015 1
	    databuf, datalen, NULL, BUS_DMA_NOWAIT);
d1024 1
a1024 2
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer,
	    0,
d1063 1
a1063 2
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_table, 
	    0,
d1140 1
a1140 2
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, 
	    0,
@


1.63
log
@sparc64 really benefits from knowing exactly what mappings to sync
on bus_dmamap_sync, so it will have the same call footprint as in NetBSD.
Rather than converting the whole world to the new arguments we will slowly
convert everything that sparc64 needs with ifdef __HAVE_NEW_BUS_DMAMAP_SYNC
Once most relevant drivers are converted we can start implementing the new
bus_dmamap_sycn on other archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.62 2001/08/23 11:04:24 art Exp $	*/
d686 1
a686 2
		if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
		    pa->pa_intrline, &intrhandle) != 0) {
@


1.62
log
@Some reordering in the code caused hw_ok to never be set to 1
which causes some CMD Technology controllers to never attach properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.61 2001/08/12 20:33:50 mickey Exp $	*/
d1021 1
a1021 1
#ifndef __OpenBSD__
d1061 1
a1061 1
#ifndef __OpenBSD__
d1139 1
a1139 1
#ifndef __OpenBSD__
d1143 1
a1143 1
	    (dma_map->dma_flags & WDC_DMA_READ) ?
@


1.61
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.60 2001/08/03 22:03:44 chris Exp $	*/
d2383 1
@


1.60
log
@from NetBSD:
Add support for Acard ATP850/860, Highpoint HPT370A, and ALi UDMA4/5 controllers
Workaround some OPTi chipset bugs (opti_chip_map still disabled by default)
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.59 2001/07/31 06:14:05 csapuntz Exp $	*/
a95 1
#include <vm/vm_param.h>
@


1.59
log
@

On DMA timeouts, stop busmaster PCIIDE and reset channel. Avoid reading
device registers as this may cause lock-ups on some chipsets

Clean-up in atapiscsi. Get rid of claim_irq. Instead, atapiscsi always
returns -1 (maybe) from the interrupt handler.
@
text
@d1 2
a2 2
/*      $OpenBSD: pciide.c,v 1.58 2001/07/20 05:56:25 csapuntz Exp $     */
/*	$NetBSD: pciide.c,v 1.110 2001/03/20 17:56:46 bouyer Exp $	*/
d5 1
a5 1
 * Copyright (c) 1999 Manuel Bouyer.
d116 1
d238 4
d419 15
d461 2
d2851 2
d2859 7
d2871 8
a2878 1
		if (rev >= 0xd0)
d3023 1
a3023 1
		if (rev >= 0x20)
d3025 7
a3037 2
	if (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA)
		sc->sc_wdcdev.UDMA_cap = 2;
d3064 18
d3095 1
a3095 1
		    acer_pci_intr);
d3131 11
d3172 7
d3262 1
a3262 1
		if (revision == HPT370_REV)
d3329 1
a3329 1
	if (revision == HPT370_REV) {
d3845 16
a3860 1
	pciide_mapreg_dma(sc, pa);
d3862 1
a3862 2
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
d4003 209
@


1.58
log
@

Add pa_bus to pci_attach_args

Better VIA IDE chipset handling. From NetBSD
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.57 2001/07/19 18:16:22 csapuntz Exp $     */
d179 1
d483 2
d793 31
d829 3
d861 3
d1089 2
d1104 2
d3351 1
a3351 1
		wdc_cp = &cp->wdc_channel;
d3687 1
@


1.57
log
@AMD766 support with UDMA/100. Thanks to Peter Galbavy for the patch
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.56 2001/06/27 05:22:31 deraadt Exp $     */
a2041 1
        pcireg_t rev = PCI_REVISION(pa->pa_class);
d2043 1
a2043 1
	u_int32_t ideconf, udma_conf, old_udma_conf;
d2045 2
d2050 40
a2089 1
	printf(": DMA");
d2096 1
a2096 2
		if (sc->sc_pp->ide_product == PCI_PRODUCT_VIATECH_VT82C571
		    && rev >= 6)
a2100 1
	sc->sc_wdcdev.UDMA_cap = 2;
a2106 1
	old_udma_conf = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);
d2112 1
a2112 1
	    old_udma_conf),
a2114 24
	if (rev >= 6) {
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    old_udma_conf | (APO_UDMA_PIO_MODE(0, 0) | APO_UDMA_EN(0, 0)
		    | APO_UDMA_EN_MTH(0, 0) | APO_UDMA_CLK66(0)),
		    APO_UDMA);
		udma_conf = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);
		WDCDEBUG_PRINT(("apollo_chip_map: APO_UDMA now 0x%x\n",
		    udma_conf), DEBUG_PROBE);
		if ((udma_conf & (APO_UDMA_PIO_MODE(0, 0) | APO_UDMA_EN(0, 0) |
		    APO_UDMA_EN_MTH(0, 0))) ==
		    (APO_UDMA_PIO_MODE(0, 0) | APO_UDMA_EN(0, 0) |
		    APO_UDMA_EN_MTH(0, 0))) {
			if ((udma_conf & APO_UDMA_CLK66(0)) ==
			    APO_UDMA_CLK66(0)) {
				printf("%s: Ultra/66 capable\n",
				    sc->sc_wdcdev.sc_dev.dv_xname);
				sc->sc_wdcdev.UDMA_cap = 4;
			}
		} else {
			sc->sc_wdcdev.cap &= ~WDC_CAPABILITY_UDMA;
		}
		pci_conf_write(sc->sc_pc, sc->sc_tag, old_udma_conf, APO_UDMA);
	}
 
d2207 17
a2223 6
			    APO_UDMA_EN_MTH(chp->channel, drive) |
			    APO_UDMA_TIME(chp->channel, drive,
				apollo_udma_tim[drvp->UDMA_mode]);
			if (drvp->UDMA_mode > 2)
				udmatim_reg |=
				    APO_UDMA_CLK66(chp->channel);
@


1.56
log
@remove excess proto
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.55 2001/06/26 05:58:38 csapuntz Exp $     */
d308 4
d1887 8
a1894 1
	sc->sc_wdcdev.UDMA_cap = 4;
d1945 2
d1991 1
a1991 1
			if (AMD756_CHIPREV_DISABLEDMA(rev)) {
@


1.55
log
@

Fix args to pciide_machdep_compat_intr_disestablish
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.54 2001/06/25 23:00:55 csapuntz Exp $     */
a475 1
int	pciide_print __P((void *, const char *pnp));
@


1.54
log
@Enable interrupts during PCIIDE detect
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.53 2001/06/12 15:40:32 niklas Exp $     */
a1225 1
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
d1231 1
a1231 1
	pciide_machdep_compat_intr_disestablish(&sc->sc_wdcdev.sc_dev, cp->ih);
@


1.53
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.52 2001/05/22 15:32:38 ho Exp $     */
d474 2
d1143 1
a1202 2
	if (cp->hw_ok == 0)
		return;
d1206 1
d1216 19
d1322 3
d1350 1
a1354 2
		} else {
			pciide_map_compat_intr(pa, cp, channel, interface);
d1492 3
d1497 1
a1497 1
			continue;
a1503 1
		pciide_map_compat_intr(pa, cp, channel, 0);
d1505 1
a1505 1
			continue;
d1507 3
d1903 4
d1910 1
a1910 1
		if (pciide_chan_candisable(cp))
d1912 3
a1914 2
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
d1916 1
d2102 4
d2108 3
a2110 2
		if (cp->hw_ok == 0)
			continue;
a2115 1
		pciide_map_compat_intr(pa, cp, channel, interface);
d2118 1
a2118 1
			continue;
d2120 3
d2283 3
a2285 1

d2287 2
a2288 1
	if (cp->hw_ok == 0)
d2290 1
d2296 1
a2298 1
	pciide_map_compat_intr(pa, cp, channel, interface);
d2657 3
d2665 3
a2667 2
	pciide_map_compat_intr(pa, cp, sc->sc_cy_compatchan, interface);
	if (cp->hw_ok == 0)
d2669 2
d2790 3
d2795 2
a2796 1
		if (cp->hw_ok == 0)
d2798 1
d2807 2
a2808 2
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
d2810 1
d2950 4
a2953 1
		}
d2956 2
a2957 1
		if (cp->hw_ok == 0)
d2959 1
d2965 4
a2968 1
		pciide_map_compat_intr(pa, cp, channel, interface);
d3407 3
d3416 5
a3420 3
		if (cp->hw_ok == 0)
		    continue;
		if (pciide_chan_candisable(cp))
d3423 2
a3424 1
		pciide_map_compat_intr(pa, cp, channel, interface);
d3718 3
d3723 2
a3724 4
		if (cp->hw_ok == 0)
			continue;
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
d3726 1
@


1.52
log
@Compile with WDCDEBUG. Fix a debug printout.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.51 2001/04/17 22:43:50 chris Exp $     */
d688 1
a688 1
	    &wdc_cp->cmd_iot, &wdc_cp->cmd_ioh, NULL, cmdsizep) != 0) {
d696 1
a696 1
	    &wdc_cp->ctl_iot, &cp->ctl_baseioh, NULL, ctlsizep) != 0) {
d765 1
a765 1
		    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);
@


1.51
log
@Enable UDMA for rev 0xd0 SiS again (undone in last update)
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.50 2001/04/04 18:25:07 csapuntz Exp $     */
d571 1
a571 1
               printf("sc_pc %s, sc_tag %s\n", sc->sc_pc, sc->sc_tag);
d988 2
a989 2
		   seg, le32toh(dma_maps->dma_table[seg].byte_count),
		   le32toh(dma_maps->dma_table[seg].base_addr)), DEBUG_DMA);
d3180 1
a3180 1
		    "(BIOS 0x%08x)\n", drvp->drv_softc->dv_xname,
@


1.50
log
@

Disable ATAPI DMA on Promise controllers and some ALi controllers.

Change Bus Master DMA Stop to not trust what we read from the device.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.49 2001/04/04 07:02:51 csapuntz Exp $     */
d2710 1
a2710 1
		if (rev > 0xd0)
@


1.49
log
@

Minor cleanup to minimize diffs with NetBSD
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.48 2001/03/26 22:17:05 chris Exp $     */
a375 1
#ifdef notyet
a381 1
#endif
a431 1
#ifdef notyet
a433 1
#endif
d1065 2
a1066 2
	    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel) & ~IDEDMA_CMD_START);
d2843 4
d3045 1
d3263 1
a3263 1
	    WDC_CAPABILITY_MODE;
@


1.48
log
@Support for Ultra/66 on Highpoint HPT366 and Ultra/100 on HPT370
@
text
@d1 2
a2 2
/*      $OpenBSD: pciide.c,v 1.47 2001/03/25 13:11:54 csapuntz Exp $     */
/*	$NetBSD: pciide.c,v 1.48 1999/11/28 20:05:18 bouyer Exp $	*/
d17 2
a18 2
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
d23 10
a32 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d99 2
a122 9
#if BYTE_ORDER == BIG_ENDIAN
#include <machine/bswap.h> 
#define	htopci(x)	bswap32(x)
#define	pcitoh(x)	bswap32(x)
#else 
#define	htopci(x)	(x)
#define	pcitoh(x)	(x)
#endif

a443 2
#define	PCIIDE_CHANNEL_NAME(chan)	((chan) == 0 ? "channel 0" : "channel 1")

d599 5
a603 4
		PCI_COMMAND_STATUS_REG);
	printf(": device disabled (at %s)\n",
		(csr & PCI_COMMAND_IO_ENABLE) == 0 ?
		"device" : "bridge");
a608 1

d987 1
a987 1
		    htopci(dma_maps->dmamap_xfer->dm_segs[seg].ds_addr);
d989 1
a989 1
		    htopci(dma_maps->dmamap_xfer->dm_segs[seg].ds_len &
d992 2
a993 2
		   seg, pcitoh(dma_maps->dma_table[seg].byte_count),
		   pcitoh(dma_maps->dma_table[seg].base_addr)), DEBUG_DMA);
d997 1
a997 1
	    htopci(IDEDMA_BYTE_COUNT_EOT);
d1092 1
a1092 1
		printf("%s:%d:%d: Bus-Master DMA error: status=0x%x\n",
d1098 1
a1098 1
		printf("%s:%d:%d: Bus-Master DMA error: missing interrupt, "
d1143 1
a1143 1
		 return 0;
a1146 1

a1148 1

d1249 1
a1249 2
	pcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,
				    sc->sc_tag, PCI_CLASS_REG));
a1377 1

d1390 1
a1390 2
	pcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,
					    sc->sc_tag, PCI_CLASS_REG)); 
d1397 2
a1412 3

	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
d1521 1
a1521 1
 
d1670 1
a1670 1
		if (drvp->UDMA_mode > 2 &&
d1685 2
a1686 2
                }
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ) {
d1842 1
a1842 2
	pcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,
				    sc->sc_tag, PCI_CLASS_REG));
d1852 2
a1853 1

a1858 2
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
			     WDC_CAPABILITY_MODE;
d2010 2
a2018 1
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA32 | WDC_CAPABILITY_MODE;
a2024 1
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;
d2107 1
a2107 1
	udmatim_reg &= ~AP0_UDMA_MASK(chp->channel);
a2257 1

a2298 1

d2319 1
a2319 1
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;
d2427 4
d2462 2
a2463 1
				/* UltraDMA on a 0648 or 0649 */
d2473 1
a2473 1
				else
d2479 1
a2479 1
				    (cmd0648_9_tim_udma[drvp->UDMA_mode] <<
d2488 1
a2488 1
				 * if we have a 0648/9, turn off UDMA
d2543 1
a2543 2
	pcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,
				    sc->sc_tag, PCI_CLASS_REG));
d2576 2
a2581 2
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
d2700 2
a2701 4
	pcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,
				    sc->sc_tag, PCI_CLASS_REG));
	pcireg_t rev = PCI_REVISION(pci_conf_read(sc->sc_pc, sc->sc_tag,
			    PCI_CLASS_REG));
d2709 2
a2710 1

d2714 1
a2714 1
		if (rev >= 0xd0)
a2717 2
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
d2723 1
d2845 2
a2846 1

a2854 2
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
a3044 1
        printf("\n");
a3218 207
/*
 * Inline functions for accessing the timing registers of the
 * OPTi controller.
 *
 * These *MUST* disable interrupts as they need atomic access to
 * certain magic registers. Failure to adhere to this *will*
 * break things in subtle ways if the wdc registers are accessed
 * by an interrupt routine while this magic sequence is executing.
 */
static __inline__ u_int8_t
opti_read_config(struct channel_softc *chp, int reg)
{
	u_int8_t rv;
	int s = splhigh();

	/* Two consecutive 16-bit reads from register #1 (0x1f1/0x171) */
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);

	/* Followed by an 8-bit write of 0x3 to register #2 */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x03u);

	/* Now we can read the required register */
	rv = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, reg);

	/* Restore the real registers */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x83u);

	splx(s);

	return rv;
}

static __inline__ void
opti_write_config(struct channel_softc *chp, int reg, u_int8_t val)
{
	int s = splhigh();

	/* Two consecutive 16-bit reads from register #1 (0x1f1/0x171) */
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);

	/* Followed by an 8-bit write of 0x3 to register #2 */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x03u);

	/* Now we can write the required register */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, reg, val);

	/* Restore the real registers */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x83u);

	splx(s);
}

void
opti_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
{
	struct pciide_channel *cp;
	bus_size_t cmdsize, ctlsize;
	pcireg_t interface;
	u_int8_t init_ctrl;
	int channel;

	if (pciide_chipen(sc, pa) == 0)
		return;
	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_MODE;
	sc->sc_wdcdev.PIO_cap = 4;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.DMA_cap = 2;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.set_modes = opti_setup_channel;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	init_ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag,
	    OPTI_REG_INIT_CONTROL);

	interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,
	    sc->sc_tag, PCI_CLASS_REG));

        pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		if (channel == 1 &&
		    (init_ctrl & OPTI_INIT_CONTROL_CH2_DISABLE) != 0) {
			printf("%s: %s channel ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			continue;
		}
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0)
			continue;
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		opti_setup_channel(&cp->wdc_channel);
	}
}

void
opti_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int drive,spd;
	int mode[2];
	u_int8_t rv, mr;

	/*
	 * The `Delay' and `Address Setup Time' fields of the
	 * Miscellaneous Register are always zero initially.
	 */
	mr = opti_read_config(chp, OPTI_REG_MISC) & ~OPTI_MISC_INDEX_MASK;
	mr &= ~(OPTI_MISC_DELAY_MASK |
		OPTI_MISC_ADDR_SETUP_MASK |
		OPTI_MISC_INDEX_MASK);

	/* Prime the control register before setting timing values */
	opti_write_config(chp, OPTI_REG_CONTROL, OPTI_CONTROL_DISABLE);

	/* Determine the clockrate of the PCIbus the chip is attached to */
	spd = 2;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0) {
			mode[drive] = -1;
			continue;
		}

		if ((drvp->drive_flags & DRIVE_DMA)) {
			/*
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode > (drvp->DMA_mode + 2))
				drvp->PIO_mode = drvp->DMA_mode + 2;
			if (drvp->DMA_mode + 2 > (drvp->PIO_mode))
				drvp->DMA_mode = (drvp->PIO_mode > 2) ?
				    drvp->PIO_mode - 2 : 0;
			if (drvp->DMA_mode == 0)
				drvp->PIO_mode = 0;

			mode[drive] = drvp->DMA_mode + 5;
		} else
			mode[drive] = drvp->PIO_mode;

		if (drive && mode[0] >= 0 &&
		    (opti_tim_as[spd][mode[0]] != opti_tim_as[spd][mode[1]])) {
			/*
			 * Can't have two drives using different values
			 * for `Address Setup Time'.
			 * Slow down the faster drive to compensate.
			 */
			int d = (opti_tim_as[spd][mode[0]] >
				 opti_tim_as[spd][mode[1]]) ?  0 : 1;

			mode[d] = mode[1-d];
			chp->ch_drive[d].PIO_mode = chp->ch_drive[1-d].PIO_mode;
			chp->ch_drive[d].DMA_mode = 0;
			chp->ch_drive[d].drive_flags &= DRIVE_DMA;
		}
	}

	for (drive = 0; drive < 2; drive++) {
		int m;
		if ((m = mode[drive]) < 0)
			continue;

		/* Set the Address Setup Time and select appropriate index */
		rv = opti_tim_as[spd][m] << OPTI_MISC_ADDR_SETUP_SHIFT;
		rv |= OPTI_MISC_INDEX(drive);
		opti_write_config(chp, OPTI_REG_MISC, mr | rv);

		/* Set the pulse width and recovery timing parameters */
		rv  = opti_tim_cp[spd][m] << OPTI_PULSE_WIDTH_SHIFT;
		rv |= opti_tim_rt[spd][m] << OPTI_RECOVERY_TIME_SHIFT;
		opti_write_config(chp, OPTI_REG_READ_CYCLE_TIMING, rv);
		opti_write_config(chp, OPTI_REG_WRITE_CYCLE_TIMING, rv);

		/* Set the Enhanced Mode register appropriately */
	    	rv = pciide_pci_read(sc->sc_pc, sc->sc_tag, OPTI_REG_ENH_MODE);
		rv &= ~OPTI_ENH_MODE_MASK(chp->channel, drive);
		rv |= OPTI_ENH_MODE(chp->channel, drive, opti_tim_em[m]);
		pciide_pci_write(sc->sc_pc, sc->sc_tag, OPTI_REG_ENH_MODE, rv);
	}

	/* Finally, enable the timings */
	opti_write_config(chp, OPTI_REG_CONTROL, OPTI_CONTROL_ENABLE);
d3220 1
a3220 4
	pciide_print_modes(cp);
}

/* A macro to test product */
d3434 2
d3523 1
a3523 4
		/*
		 * If a compat channel, skip.  This may
		 * never be the case on a PDC2026x ??
		 */
d3544 212
@


1.47
log
@Minor mods to DMA interface - get rid of unnecessary args. Allow DMA functions to return status flags.

Note: Changing code to have DMA interface indicate when I/O is done (a la NetBSD) was considered. It was rejected due to questionable backward compatability
with ISA DMA and MAC obio DMA

Added irqack from NetBSD (though this feature should really be in the
PCI interrupt handlers)

Use pool
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.46 2001/03/16 09:16:05 chris Exp $     */
d114 1
d240 4
d393 7
d446 2
d3035 204
d3536 1
a3536 5
	if (PDC_IS_265(sc)) {
		/* the BIOS set it up this way */
		mode = PDC2xx_SCR_SET_GEN(mode, 0x3);
		mode |= 0x80000000;
	} else if (PDC_IS_262(sc)) {
@


1.46
log
@Pull in NetBSD Promise Ultra/100 support

(Now we actually program Ultra/100 modes instead of Ultra/66 modes on the
Ultra/100 controller)

This also fixes interrupt handling on the PDC20265/7 controller.  I suspect
this new interrupt routine for the PDC20255/7 controller should also be used
on the PDC20262.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.45 2001/02/22 03:04:09 chris Exp $     */
d193 1
d220 1
d243 3
a245 2
void pciide_dma_start __P((void*, int, int, int));
int  pciide_dma_finish __P((void*, int, int, int));
d1027 2
d1033 1
a1033 1
pciide_dma_start(v, channel, drive, flags)
d1035 1
a1035 1
	int channel, drive, flags;
d1047 1
a1047 1
pciide_dma_finish(v, channel, drive, flags)
a1049 1
	int flags;
d1053 1
d1057 11
d1073 1
a1073 1
	    (flags & WDC_DMA_READ) ?
d1077 1
a1077 1
	    (flags & WDC_DMA_READ) ?
a1079 1

a1081 11
	status = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel);
	WDCDEBUG_PRINT(("pciide_dma_finish: status 0x%x\n", status),
	    DEBUG_XFERS);

	/* stop DMA channel */
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,
	    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel) & ~IDEDMA_CMD_START);

d1090 1
a1090 1
		return -1;
d1093 1
a1093 1
	if ((flags & WDC_DMA_POLL) == 0 && (status & IDEDMA_CTL_INTR) == 0) {
d1097 1
a1097 1
		return -1;
d1102 1
a1102 1
		return 1;
d1104 15
a1118 1
	return 0;
d1275 4
a1278 2
	if (sc->sc_dma_ok)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
d1399 2
a1400 1
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
d1856 1
a1856 1
	if (sc->sc_dma_ok)
d1858 3
d2015 2
a2016 1
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
d2341 2
d2379 1
a2379 1
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
d2385 1
d2387 24
d2521 18
d2578 4
a2581 2
	if (sc->sc_dma_ok)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
d2715 2
a2716 1
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
d2854 2
d3094 1
a3094 1
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
d3096 1
d3275 1
a3275 1
	if (sc->sc_dma_ok)
d3277 3
@


1.45
log
@Use real VIA product names for IDE controllers rather then contrived ones,
ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.44 2001/02/06 07:57:08 chris Exp $     */
d233 1
d3159 1
a3159 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20265 ||	\
d3161 5
d3203 3
a3205 1
	if (PDC_IS_262(sc))
d3239 5
a3243 1
	if (PDC_IS_262(sc)) {
d3278 6
a3283 2
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pdc202xx_pci_intr);
d3314 4
d3345 4
d3435 2
a3436 2
				printf("%s:%d: bogus intr\n",
				    sc->sc_wdcdev.sc_dev.dv_xname, i);
d3441 40
@


1.44
log
@Laptop ICH2 IDE
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.43 2001/01/29 00:20:17 csapuntz Exp $     */
d351 1
a351 1
	{ PCI_PRODUCT_VIATECH_VT82C586_IDE, /* VIA VT82C586 (Apollo VP) IDE */
d355 1
a355 1
	{ PCI_PRODUCT_VIATECH_VT82C586A_IDE, /* VIA VT82C586A IDE */
d1991 1
a1991 1
		if (sc->sc_pp->ide_product == PCI_PRODUCT_VIATECH_VT82C586A_IDE
@


1.43
log
@


Add wdc_print_current_modes to print current transfer modes set on the
devices. Print after attach in wdc_isa, wdc_isapnp, wdc_pcmcia.
pciide_print_modes rewritten to use wdc_print_current_modes.

Disable wdc_print_caps since it's not as useful.

Inspired by NetBSD. Thanks to Dale and Theo for pointing out this improvement.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.42 2001/01/22 23:09:05 chris Exp $     */
d292 4
d1384 1
d1399 1
d1430 1
d1482 1
d1643 1
d1647 2
a1648 1
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE) {
@


1.42
log
@from NetBSD: only pass one byte for control register handle (Manuel Bouyer)
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.41 2001/01/18 22:09:12 chris Exp $     */
d1215 1
a1215 22
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int drive;
	struct channel_softc *chp;
	struct ata_drive_datas *drvp;

	chp = &cp->wdc_channel;
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		printf("%s(%s:%d:%d): using PIO mode %d",
		    drvp->drive_name,
		    sc->sc_wdcdev.sc_dev.dv_xname,
		    chp->channel, drive, drvp->PIO_mode);
		if (drvp->drive_flags & DRIVE_DMA)
			printf(", DMA mode %d", drvp->DMA_mode);
		if (drvp->drive_flags & DRIVE_UDMA)
			printf(", Ultra-DMA mode %d", drvp->UDMA_mode);
		if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))
			printf(" (using DMA data transfers)");
		printf("\n");
	}
@


1.41
log
@Only try VIA CLK66 bit code for VIA rev >= 6,
Only try UDMA on ALi rev >= 0x20 (as per Daniela Engert's ChipList.txt)
After I fix a few more bugs I will re-enable the ALi code
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.39 2000/12/08 14:44:57 millert Exp $     */
d187 1
d688 1
a688 1
	    &wdc_cp->ctl_iot, &wdc_cp->ctl_ioh, NULL, ctlsizep) != 0) {
d692 13
@


1.40
log
@
From chris@@
Partial sync w/NetBSD
-Support Ultra/100 on Intel ICH2 (Tomokazu HARADA)
-Support Ultra/66 on VIA Apollo (Manuel Bouyer)
-Disable 16bit io-space limitation on Promise (Charles Hannum)
@
text
@d2012 20
a2031 16
	pci_conf_write(sc->sc_pc, sc->sc_tag,
	    old_udma_conf | (APO_UDMA_PIO_MODE(0, 0) | APO_UDMA_EN(0, 0) |
	    APO_UDMA_EN_MTH(0, 0) | APO_UDMA_CLK66(0)),
	    APO_UDMA);
	udma_conf = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);
	WDCDEBUG_PRINT(("apollo_chip_map: APO_UDMA now 0x%x\n", udma_conf),
	    DEBUG_PROBE);
	if ((udma_conf & (APO_UDMA_PIO_MODE(0, 0) | APO_UDMA_EN(0, 0) |
	    APO_UDMA_EN_MTH(0, 0))) ==
	    (APO_UDMA_PIO_MODE(0, 0) | APO_UDMA_EN(0, 0) |
	    APO_UDMA_EN_MTH(0, 0))) {
		if ((udma_conf & APO_UDMA_CLK66(0)) ==
		    APO_UDMA_CLK66(0)) {
			printf("%s: Ultra/66 capable\n",
			    sc->sc_wdcdev.sc_dev.dv_xname);
			sc->sc_wdcdev.UDMA_cap = 4;
d2033 1
a2033 2
	} else {
		sc->sc_wdcdev.cap &= ~WDC_CAPABILITY_UDMA;
a2034 1
	pci_conf_write(sc->sc_pc, sc->sc_tag, old_udma_conf, APO_UDMA);
d2765 1
d2773 5
a2777 2
	if (sc->sc_dma_ok)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
d2783 2
a2784 1
	sc->sc_wdcdev.UDMA_cap = 2;
a2791 1

@


1.39
log
@Fix attach message printing for CY82C693U to be like pciide_print_channels().
It is done inline for the CY82C693U since it only has one channel.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.38 2000/12/06 22:45:41 deraadt Exp $     */
d381 1
a381 1
	IDE_PCI_CLASS_OVERRIDE|IDE_16BIT_IOSPACE,
d385 1
a385 1
	IDE_PCI_CLASS_OVERRIDE|IDE_16BIT_IOSPACE,
d389 1
a389 1
	IDE_PCI_CLASS_OVERRIDE|IDE_16BIT_IOSPACE,
d393 1
a393 1
	IDE_PCI_CLASS_OVERRIDE|IDE_16BIT_IOSPACE,
d1399 2
d1402 1
a1402 1
		sc->sc_wdcdev.UDMA_cap = 4;
d1645 19
a1663 2
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ) {
d1979 1
a1979 1
	u_int32_t ideconf;
d2003 1
d2009 1
a2009 1
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA)),
d2012 22
d2085 18
d2122 3
@


1.38
log
@supposed changes needed for 82801BA support; chris
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.37 2000/11/20 14:24:29 deraadt Exp $     */
d2462 1
a2462 2
	printf("%s: primary channel %s to ",
	    sc->sc_wdcdev.sc_dev.dv_xname,
d2466 1
a2466 1
		printf("native-PCI");
d2470 1
a2470 1
		printf("compatibility");
a2473 1
        printf(" mode\n");
@


1.37
log
@support at least ATA6 on 82801BA; chris
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.36 2000/11/13 23:09:58 chris Exp $     */
d1428 2
a1429 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE) {
d1479 2
a1480 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE) {
d1639 2
a1640 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE) {
d1643 2
a1644 1
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE) {
@


1.36
log
@Don't map unsafe registers from controllers that require 16 bit io space
(from NetBSD)
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.35 2000/11/07 23:31:39 chris Exp $     */
d291 1
a291 1
	{ PCI_PRODUCT_INTEL_82801BA_IDE, /* Intel 82801BA IDE (ICH0) */
d758 1
d1382 1
a1382 1
		switch(sc->sc_pp->ide_product) {
d1387 1
d1389 1
d1397 9
a1405 2
	sc->sc_wdcdev.UDMA_cap =
	    (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE) ? 4 : 2;
d2285 1
@


1.35
log
@Promise PCI devs renamed
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.34 2000/10/21 17:57:23 deraadt Exp $     */
d252 2
a253 1
#define IDE_PCI_CLASS_OVERRIDE 0x0001 /* accept even if class != pciide */
d358 1
a358 1
	  0,
d381 1
a381 1
	IDE_PCI_CLASS_OVERRIDE,
d385 1
a385 1
	IDE_PCI_CLASS_OVERRIDE,
d389 1
a389 1
	IDE_PCI_CLASS_OVERRIDE,
d393 1
a393 1
	IDE_PCI_CLASS_OVERRIDE,
d702 1
d725 15
d746 1
a746 1
			printf(", (unuseable)"); /* couldn't map registers */
@


1.34
log
@82801BA is DMA, in 3 months there will be lots of these
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.33 2000/10/21 05:43:18 chris Exp $     */
d379 1
a379 1
	{ PCI_PRODUCT_PROMISE_ULTRA33,
d383 1
a383 1
	{ PCI_PRODUCT_PROMISE_ULTRA66,
d387 1
a387 1
	{ PCI_PRODUCT_PROMISE_ULTRA100,
d391 1
a391 1
	{ PCI_PRODUCT_PROMISE_ULTRA100_2,
d3055 3
a3057 3
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_ULTRA66 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_ULTRA100 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_ULTRA100_2)
@


1.33
log
@(Temporarily) disable DMA support for OPTi 82C621 and untested 82C568/82D568
because it breaks on two different revisions in two different ways and
is so old and slow anyways that it isn't that much of an advantage to have DMA
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.32 2000/10/16 18:09:56 chris Exp $     */
d287 4
@


1.32
log
@Fix a bug introduced in 1.25->1.26 with regards to printing channel
information, tested by deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.31 2000/08/25 15:33:39 chris Exp $     */
d299 1
d301 1
d315 1
d404 1
d407 1
d2909 1
a2909 1
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 | WDC_CAPABILITY_MODE;
d2973 1
a2973 2
	spd = (int) opti_read_config(chp, OPTI_REG_STRAP);
	spd &= OPTI_STRAP_PCI_SPEED_MASK;
@


1.31
log
@Match Promise Ultra/100 as PDC20262 instead of PDC20246
(netbsd)
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.30 2000/08/05 00:53:01 chris Exp $     */
d2070 1
a2070 1
	int interface;
a2105 2
	pciide_print_channels(1, interface);

d2169 1
d2193 2
d2207 16
d2257 2
@


1.30
log
@Support Promise Ultra/100 as found on some Microstar motherboards
(From NetBSD PR 10756)
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.29 2000/07/31 23:39:43 chris Exp $     */
d3027 4
a3030 1
#define	PDC_IS_262(sc) (sc->sc_pp->ide_product == PCI_PRODUCT_PROMISE_ULTRA66)
@


1.29
log
@Fix PR 1341 -
Don't enable UDMA modes on VIA "82C586" with revision under 6
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.28 2000/07/07 19:07:21 chris Exp $     */
d381 4
@


1.28
log
@Support Intel 440MX Ultra/33 controller found on various laptops
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.27 2000/07/07 18:42:16 chris Exp $     */
d1818 1
d1821 1
d1913 2
a1914 2
	pcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,
				    sc->sc_tag, PCI_CLASS_REG));
d1925 2
a1926 1
		if (sc->sc_pp->ide_product == PCI_PRODUCT_VIATECH_VT82C586A_IDE)
@


1.27
log
@From NetBSD:
Match Promise Ultra/100 controller
(Ultra/100 drives will be used as Ultra/66 fow now)
Work-around for a bug in revision D2 AMD controllers
(They do not work correctly with Multiword-DMA mode, workaround is to
disable MW DMA, but this bug does not affect all drives so there is an
option PCIIDE_AMD756_ENABLEDMA to stop this behavior.  You know you have
this bug when your system hangs completely with this option.)
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.26 2000/06/26 18:09:11 chris Exp $     */
d278 4
d1353 1
@


1.26
log
@interface can be faked for cmd chips
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.25 2000/06/26 17:51:16 chris Exp $     */
d375 4
d1813 2
d1847 1
a1847 1
			/* use Multiword DMA */
d1849 17
@


1.25
log
@from NetBSD
support CMD 648/649 UDMA66 controllers
fix promise UDMA66 cable check
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.24 2000/06/13 03:56:41 chris Exp $     */
d2071 2
a2135 2
	pcireg_t interface =
	    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));
a2158 2
	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

a2170 1
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
a2204 2

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);
@


1.24
log
@clean up Cypress section (obviously nobody has used these w/OpenBSD)
also sync w/NetBSD
support map memory mapped or IO mapped controllers
program DMA modes for Cypress controllers
support for OPTi chipsets (82C621 and compatible 82C568/82D568)
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.23 2000/05/04 19:42:53 millert Exp $     */
d213 2
a214 2
void cmd0643_6_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void cmd0643_6_setup_channel __P((struct channel_softc*));
d317 1
a317 1
	  cmd0643_6_chip_map
d321 9
a329 1
	  cmd0643_6_chip_map
d2035 16
a2050 2
	pcireg_t interface =
	    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));
d2167 1
a2167 1
cmd0643_6_chip_map(sc, pa)
d2173 1
a2173 2
	pcireg_t interface =
	    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));
d2191 3
a2193 1
	if (sc->sc_dma_ok)
d2195 7
a2204 2
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
d2207 1
a2207 1
	sc->sc_wdcdev.set_modes = cmd0643_6_setup_channel;
d2211 1
a2211 1
	WDCDEBUG_PRINT(("cmd0643_6_chip_map: old timings reg 0x%x 0x%x\n",
d2220 1
a2220 1
		cmd0643_6_setup_channel(&cp->wdc_channel);
d2223 1
a2223 1
	WDCDEBUG_PRINT(("cmd0643_6_chip_map: timings reg now 0x%x 0x%x\n",
d2230 1
a2230 1
cmd0643_6_setup_channel(chp)
d2235 1
a2235 1
	u_int32_t idedma_ctl;
d2250 44
a2293 10
		tim = cmd0643_6_data_tim_pio[drvp->PIO_mode];
		if (drvp->drive_flags & DRIVE_DMA) {
			/*
			 * use Multiword DMA.
			 * Timings will be used for both PIO and DMA, so adjust
			 * DMA mode if needed
			 */
			if (drvp->PIO_mode >= 3 &&
			    (drvp->DMA_mode + 2) > drvp->PIO_mode) {
				drvp->DMA_mode = drvp->PIO_mode - 2;
a2294 1
			tim = cmd0643_6_data_tim_dma[drvp->DMA_mode];
d3143 1
a3143 1
		if ((st & PDC262_STATE_80P(channel)) == 0 ||
@


1.23
log
@Don't attach a PCTECH RZ1000 on the PCI bus--it has severe problems.
It will attach at wdc and be less problematical, though I still
wouldn't trust my data to it.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.22 2000/04/10 07:06:17 csapuntz Exp $     */
d113 4
d171 5
d232 3
d295 15
d381 2
d432 1
a432 1
int	pciiide_chan_candisable __P((struct pciide_channel *));
a529 1

d671 2
a686 2
	 * XXX eventually, we should probably read the register and check
	 * XXX which type it is.  Either that or 'quirk' certain devices.
d689 23
a711 11
	sc->sc_dma_ok = (pci_mapreg_map(pa,
	    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);
	sc->sc_dmat = pa->pa_dmat;
	if (sc->sc_dma_ok == 0) {
		printf(", (unuseable)"); /* couldn't map registers */
	} else {
		sc->sc_wdcdev.dma_arg = sc;
		sc->sc_wdcdev.dma_init = pciide_dma_init;
		sc->sc_wdcdev.dma_start = pciide_dma_start;
		sc->sc_wdcdev.dma_finish = pciide_dma_finish;
d1092 1
a1092 1
pciiide_chan_candisable(cp)
d1396 1
a1396 1
		if (pciiide_chan_candisable(cp)) {
d1778 1
a1778 1
		if (pciiide_chan_candisable(cp))
d1924 1
a1924 1
		if (pciiide_chan_candisable(cp)) {
d2064 1
a2064 1
		if (pciiide_chan_candisable(cp)) {
d2256 1
a2256 1
	int compatchan;
d2266 1
a2266 1
		compatchan = 0;
d2268 1
a2268 1
		compatchan = 1;
d2270 1
a2270 2
		printf("%s: unexpected PCI function %d\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, pa->pa_function);
d2273 1
d2282 5
a2286 1
	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);
d2301 1
a2301 1
		sc->wdc_chanarray[0] = &cp->wdc_channel;
d2308 1
a2308 3
		printf("%s: %s"
		    "cannot allocate memory for command queue",
		sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
d2311 14
d2329 1
a2329 1
	if (pciiide_chan_candisable(cp)) {
d2333 1
a2333 1
	pciide_map_compat_intr(pa, cp, compatchan, interface);
d2384 11
d2396 1
d2460 1
a2460 1
		if (pciiide_chan_candisable(cp)) {
d2606 1
a2606 1
		if (pciiide_chan_candisable(cp)) {
d2724 211
d3047 1
a3047 1
		if (pciiide_chan_candisable(cp))
@


1.22
log
@

Added support for wd detach (merge from NetBSD). Support for
SCSI/ATAPI detach is not here yet.

Minor cleanup of wdc. Downgrade to UDMA mode 1 before going further.
Want to stay in UDMA modes because they're more error-resilient due to
a CRC.

Got rid of some of the ridiculous amount of softc sharing going on.
Hopefully, this will make the life of whoever goes in and fixes the
ref-counting to be correct easier.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.21 2000/03/24 17:47:41 chris Exp $     */
d449 8
@


1.21
log
@From NetBSD:

Don't reset cp->hw_ok ro 0 when cp isn't initialised in cy693_chip_map()

Support for AMD 756 IDE controller
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.20 2000/01/17 17:12:34 chris Exp $     */
d1117 1
a1117 1
		    drvp->drv_softc->dv_xname,
@


1.20
log
@From Manuel Bouyer -
Don't set WDC_CAPABILITY_UDMA at all for SiS rev < 0xd0
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.19 2000/01/11 01:16:00 chris Exp $     */
d106 1
d197 3
d268 1
a268 1
	  piix_chip_map,
d272 8
a279 1
	  piix_chip_map,
d352 2
d1686 136
a2223 1
		cp->hw_ok = 0;
@


1.20.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*      $OpenBSD: pciide.c,v 1.51 2001/04/17 22:43:50 chris Exp $     */
/*	$NetBSD: pciide.c,v 1.110 2001/03/20 17:56:46 bouyer Exp $	*/
d17 2
a18 2
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
d23 11
a33 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a99 2
#include <machine/endian.h>

a105 1
#include <dev/pci/pciide_amd_reg.h>
a111 5
#include <dev/pci/pciide_opti_reg.h>
#include <dev/pci/pciide_hpt_reg.h>

#include <dev/pci/cy82c693var.h>

d116 9
a165 5

	/* For Cypress */
	const struct cy82c693_handle *sc_cy_handle;
	int sc_cy_compatchan;

a176 1
		bus_space_handle_t ctl_baseioh;	/* ctrl regs blk, native mode */
a181 1
			int dma_flags;
a195 3
void amd756_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void amd756_setup_channel __P((struct channel_softc*));

d200 2
a201 2
void cmd0643_9_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void cmd0643_9_setup_channel __P((struct channel_softc*));
a204 1
void cmd646_9_irqack __P((struct channel_softc *));
a218 8
int  pdc20265_pci_intr __P((void *));

void opti_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void opti_setup_channel __P((struct channel_softc*));

void hpt_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void hpt_setup_channel __P((struct channel_softc*));
int  hpt_pci_intr __P((void *));
d223 2
a224 3
void pciide_dma_start __P((void*, int, int));
int  pciide_dma_finish __P((void*, int, int));
void pciide_irqack __P((struct channel_softc *));
d236 1
a236 2
#define IDE_PCI_CLASS_OVERRIDE	0x0001	/* accept even if class != pciide */
#define IDE_16BIT_IOSPACE	0x0002	/* I/O space BARS ignore upper word */
a261 4
	{ PCI_PRODUCT_INTEL_82440MX_IDE, /* Intel 82440MX IDE */
	  0,
	  piix_chip_map
	},
d264 1
a264 1
	  piix_chip_map
d268 1
a268 33
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801BAM_IDE, /* Intel 82801BAM IDE (ICH2) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801BA_IDE, /* Intel 82801BA IDE (ICH2) */
	  0,
	  piix_chip_map
	},
};

const struct pciide_product_desc pciide_amd_products[] =  {
	{ PCI_PRODUCT_AMD_PBC756_IDE,	/* AMD 756 */
	  0,
	  amd756_chip_map
	},
};

#ifdef notyet
const struct pciide_product_desc pciide_opti_products[] = {

	{ PCI_PRODUCT_OPTI_82C621,
	  0,
	  opti_chip_map
	},
	{ PCI_PRODUCT_OPTI_82C568,
	  0,
	  opti_chip_map
	},
	{ PCI_PRODUCT_OPTI_82D568,
	  0,
	  opti_chip_map
a270 1
#endif
d279 1
a279 1
	  cmd0643_9_chip_map
d283 1
a283 9
	  cmd0643_9_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_648,	/* CMD Technology PCI0648 */
	  IDE_PCI_CLASS_OVERRIDE,
	  cmd0643_9_chip_map
	},
	{ PCI_PRODUCT_CMDTECH_649,	/* CMD Technology PCI0649 */
	  IDE_PCI_CLASS_OVERRIDE,
	  cmd0643_9_chip_map
d288 1
a288 1
	{ PCI_PRODUCT_VIATECH_VT82C416, /* VIA VT82C416 IDE */
d292 1
a292 1
	{ PCI_PRODUCT_VIATECH_VT82C571, /* VIA VT82C571 IDE */
d300 1
a300 1
	  IDE_16BIT_IOSPACE,
d312 1
d319 1
a319 7

const struct pciide_product_desc pciide_triones_products[] =  {
	{ PCI_PRODUCT_TRIONES_HPT366,	/* Highpoint HPT36x/37x IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map,
	}
};
d322 1
a322 5
	{ PCI_PRODUCT_PROMISE_PDC20246,
	IDE_PCI_CLASS_OVERRIDE,
	pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20262,
d326 1
a326 5
	{ PCI_PRODUCT_PROMISE_PDC20265,
	IDE_PCI_CLASS_OVERRIDE,
	pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20267,
a340 6
	{ PCI_VENDOR_AMD, pciide_amd_products,
	  sizeof(pciide_amd_products)/sizeof(pciide_amd_products[0]) },
#ifdef notyet
	{ PCI_VENDOR_OPTI, pciide_opti_products,
	  sizeof(pciide_opti_products)/sizeof(pciide_opti_products[0]) },
#endif
d349 1
d352 1
a352 2
	{ PCI_VENDOR_TRIONES, pciide_triones_products,
	  sizeof(pciide_triones_products)/sizeof(pciide_triones_products[0]) },
d357 2
d390 1
a390 1
int	pciide_chan_candisable __P((struct pciide_channel *));
a437 8
 	 * Some IDE controllers have severe bugs when used in PCI mode.
	 * We punt and attach them to the ISA bus instead.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_PCTECH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_PCTECH_RZ1000)
		return (0);

	/*
d480 1
d507 4
a510 5
		    PCI_COMMAND_STATUS_REG);
		printf("%s: device disabled (at %s)\n",
	 	   sc->sc_wdcdev.sc_dev.dv_xname,
	  	  (csr & PCI_COMMAND_IO_ENABLE) == 0 ?
		  "device" : "bridge");
d516 1
d608 1
a608 1
	    &wdc_cp->ctl_iot, &cp->ctl_baseioh, NULL, ctlsizep) != 0) {
a613 13
	/*
	 * In native mode, 4 bytes of I/O space are mapped for the control
	 * register, the control register is at offset 2. Pass the generic
	 * code a handle for only one byte at the right offset.
	 */
	if (bus_space_subregion(wdc_cp->ctl_iot, cp->ctl_baseioh, 2, 1,
	    &wdc_cp->ctl_ioh) != 0) {
		printf("%s: unable to subregion %s channel ctl regs\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		bus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, *cmdsizep);
		bus_space_unmap(wdc_cp->cmd_iot, cp->ctl_baseioh, *ctlsizep);
		return 0;
	}
a621 3
	pcireg_t maptype;
	bus_addr_t addr;

d636 2
d640 11
a650 39
	maptype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
	    PCIIDE_REG_BUS_MASTER_DMA);

	switch (maptype) {
	case PCI_MAPREG_TYPE_IO:
		sc->sc_dma_ok = (pci_mapreg_info(pa->pa_pc, pa->pa_tag,
		    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO,
		    &addr, NULL, NULL) == 0);
		if (sc->sc_dma_ok == 0) {
			printf(", unused (couldn't query registers)");
			break;
		}
		if ((sc->sc_pp->ide_flags & IDE_16BIT_IOSPACE)
		    && addr >= 0x10000) {
			sc->sc_dma_ok = 0;
			printf(", unused (registers at unsafe address %#lx)", addr);
			break;
		}
		/* FALLTHROUGH */

	case PCI_MAPREG_MEM_TYPE_32BIT:
		sc->sc_dma_ok = (pci_mapreg_map(pa,
		    PCIIDE_REG_BUS_MASTER_DMA, maptype, 0,
		    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);
		sc->sc_dmat = pa->pa_dmat;
		if (sc->sc_dma_ok == 0) {
			printf(", unused (couldn't map registers)");
		} else {
			sc->sc_wdcdev.dma_arg = sc;
			sc->sc_wdcdev.dma_init = pciide_dma_init;
			sc->sc_wdcdev.dma_start = pciide_dma_start;
			sc->sc_wdcdev.dma_finish = pciide_dma_finish;
		}
		break;

	default:
		sc->sc_dma_ok = 0;
		printf(", (unsupported maptype 0x%x)", maptype);
		break;
d853 1
a853 1
		    htole32(dma_maps->dmamap_xfer->dm_segs[seg].ds_addr);
d855 1
a855 1
		    htole32(dma_maps->dmamap_xfer->dm_segs[seg].ds_len &
d858 2
a859 2
		   seg, le32toh(dma_maps->dma_table[seg].byte_count),
		   le32toh(dma_maps->dma_table[seg].base_addr)), DEBUG_DMA);
d863 1
a863 1
	    htole32(IDEDMA_BYTE_COUNT_EOT);
a896 2
	/* remember flags */
	dma_maps->dma_flags = flags;
d901 1
a901 1
pciide_dma_start(v, channel, drive)
d903 1
a903 1
	int channel, drive;
d915 1
a915 1
pciide_dma_finish(v, channel, drive)
d918 1
a921 1
	int error = 0;
a924 11
	status = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel);
	WDCDEBUG_PRINT(("pciide_dma_finish: status 0x%x\n", status),
	    DEBUG_XFERS);

	/* stop DMA channel */
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,
	    (dma_maps->dma_flags & WDC_DMA_READ) ?
	    0x00 : IDEDMA_CMD_WRITE);

d930 1
a930 1
	    (dma_map->dma_flags & WDC_DMA_READ) ?
d934 1
a934 1
	    (dma_maps->dma_flags & WDC_DMA_READ) ?
d937 1
d940 11
d957 1
a957 1
		printf("%s:%d:%d: bus-master DMA error: status=0x%x\n",
d959 1
a959 1
		error |= WDC_DMAST_ERR;
d962 2
a963 2
	if ((status & IDEDMA_CTL_INTR) == 0) {
		printf("%s:%d:%d: bus-master DMA error: missing interrupt, "
d966 1
a966 1
		error |= WDC_DMAST_NOIRQ;
d971 1
a971 1
		error |= WDC_DMAST_UNDER;
d973 1
a973 15
	return error;
}

void
pciide_irqack(chp)
        struct channel_softc *chp;
{
        struct pciide_channel *cp = (struct pciide_channel*)chp;
        struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

        /* clear status bits in IDE DMA registers */
        bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
            IDEDMA_CTL + IDEDMA_SCH_OFFSET * chp->channel,
            bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
                IDEDMA_CTL + IDEDMA_SCH_OFFSET * chp->channel));
d994 1
a994 1
		return 0;
d998 1
d1001 1
d1031 1
a1031 1
pciide_chan_candisable(cp)
d1093 22
a1114 1
	wdc_print_current_modes(&cp->wdc_channel);
d1123 2
a1124 1
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
d1151 2
a1152 4
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
d1251 1
d1264 2
a1265 1
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
a1271 2
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
d1273 2
a1274 3
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		switch (sc->sc_pp->ide_product) {
a1275 1
		case PCI_PRODUCT_INTEL_82440MX_IDE:
a1277 2
		case PCI_PRODUCT_INTEL_82801BAM_IDE:
		case PCI_PRODUCT_INTEL_82801BA_IDE:
a1278 1
			break;
d1281 3
d1286 2
a1287 12
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_INTEL_82801AA_IDE:
		sc->sc_wdcdev.UDMA_cap = 4;
		break;
	case PCI_PRODUCT_INTEL_82801BAM_IDE:
	case PCI_PRODUCT_INTEL_82801BA_IDE:
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
	default:
		sc->sc_wdcdev.UDMA_cap = 2;
		break;
	}
d1310 1
a1310 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ) {
d1335 1
a1335 1
		if (pciide_chan_candisable(cp)) {
d1360 1
a1360 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ) {
d1378 1
a1378 1

d1519 1
a1519 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ) {
a1521 19
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE) {
			/* setup Ultra/100 */
			if (drvp->UDMA_mode > 2 &&
			    (ideconf & PIIX_CONFIG_CR(channel, drive)) == 0)
				drvp->UDMA_mode = 2;
			if (drvp->UDMA_mode > 4) {
				ideconf |= PIIX_CONFIG_UDMA100(channel, drive);
			} else {
				ideconf &= ~PIIX_CONFIG_UDMA100(channel, drive);
				if (drvp->UDMA_mode > 2) {
					ideconf |= PIIX_CONFIG_UDMA66(channel,
					    drive);
				} else {
					ideconf &= ~PIIX_CONFIG_UDMA66(channel,
					    drive);
				}
			}
		}
d1673 1
a1673 1
amd756_chip_map(sc, pa)
d1678 2
a1679 1
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
d1681 1
a1681 1
	pcireg_t chanenable;
a1685 1

a1687 2
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
d1689 3
a1691 3
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
                sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
                sc->sc_wdcdev.irqack = pciide_irqack;		
d1693 1
d1696 2
a1697 2
	sc->sc_wdcdev.UDMA_cap = 4;
	sc->sc_wdcdev.set_modes = amd756_setup_channel;
d1700 1
a1700 1
	chanenable = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_CHANSTATUS_EN);
d1703 8
d1717 2
a1718 1
		if ((chanenable & AMD756_CHAN_EN(channel)) == 0) {
d1725 8
a1733 3
		if (pciide_chan_candisable(cp))
			chanenable &= ~AMD756_CHAN_EN(channel);
		pciide_map_compat_intr(pa, cp, channel, interface);
d1736 1
a1736 2

		amd756_setup_channel(&cp->wdc_channel);
d1738 3
a1740 3
	pci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_CHANSTATUS_EN,
	    chanenable);
	return;
d1744 1
a1744 1
amd756_setup_channel(chp)
a1752 4
#ifndef	PCIIDE_AMD756_ENABLEDMA
	int rev = PCI_REVISION(
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));
#endif
d1755 4
a1758 4
	datatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_DATATIM);
	udmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_UDMA);
	datatim_reg &= ~AMD756_DATATIM_MASK(chp->channel);
	udmatim_reg &= ~AMD756_UDMA_MASK(chp->channel);
d1778 4
a1781 4
			udmatim_reg |= AMD756_UDMA_EN(chp->channel, drive) |
			    AMD756_UDMA_EN_MTH(chp->channel, drive) |
			    AMD756_UDMA_TIME(chp->channel, drive,
				amd756_udma_tim[drvp->UDMA_mode]);
d1785 1
a1785 1
			/* use Multiword DMA, but only if revision is OK */
a1786 17
#ifndef PCIIDE_AMD756_ENABLEDMA
			/*
			 * The workaround doesn't seem to be necessary
			 * with all drives, so it can be disabled by
			 * PCIIDE_AMD756_ENABLEDMA. It causes a hard hang if
			 * triggered. 
			 */
			if (AMD756_CHIPREV_DISABLEDMA(rev)) {
				printf("%s:%d:%d: multi-word DMA disabled due "
				    "to chip revision\n",
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    chp->channel, drive);
				mode = drvp->PIO_mode;
				drvp->drive_flags &= ~DRIVE_DMA;
				goto pio;
			}
#endif
d1805 4
a1808 4
		    AMD756_DATATIM_PULSE(chp->channel, drive,
			amd756_pio_set[mode]) |
		    AMD756_DATATIM_RECOV(chp->channel, drive,
			amd756_pio_rec[mode]);
d1817 2
a1818 2
	pci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_DATATIM, datatim_reg);
	pci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_UDMA, udmatim_reg);
d1822 2
a1823 1
apollo_chip_map(sc, pa)
d1825 1
a1825 1
	struct pci_attach_args *pa;
d1827 1
a1827 5
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
        pcireg_t rev = PCI_REVISION(pa->pa_class);
	int channel;
	u_int32_t ideconf, udma_conf, old_udma_conf;
d1829 8
d1838 11
a1848 1
	if (pciide_chipen(sc, pa) == 0)
a1849 10
	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 | 
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		if (sc->sc_pp->ide_product == PCI_PRODUCT_VIATECH_VT82C571
		    && rev >= 6)
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
a1850 6
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 2;
	sc->sc_wdcdev.set_modes = apollo_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
d1852 8
a1859 218
	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);
	
	old_udma_conf = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);
	WDCDEBUG_PRINT(("apollo_chip_map: old APO_IDECONF=0x%x, "
	    "APO_CTLMISC=0x%x, APO_DATATIM=0x%x, APO_UDMA=0x%x\n",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_IDECONF),
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_CTLMISC),
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM),
	    old_udma_conf),
	    DEBUG_PROBE);

	if (rev >= 6) {
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    old_udma_conf | (APO_UDMA_PIO_MODE(0, 0) | APO_UDMA_EN(0, 0)
		    | APO_UDMA_EN_MTH(0, 0) | APO_UDMA_CLK66(0)),
		    APO_UDMA);
		udma_conf = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);
		WDCDEBUG_PRINT(("apollo_chip_map: APO_UDMA now 0x%x\n",
		    udma_conf), DEBUG_PROBE);
		if ((udma_conf & (APO_UDMA_PIO_MODE(0, 0) | APO_UDMA_EN(0, 0) |
		    APO_UDMA_EN_MTH(0, 0))) ==
		    (APO_UDMA_PIO_MODE(0, 0) | APO_UDMA_EN(0, 0) |
		    APO_UDMA_EN_MTH(0, 0))) {
			if ((udma_conf & APO_UDMA_CLK66(0)) ==
			    APO_UDMA_CLK66(0)) {
				printf("%s: Ultra/66 capable\n",
				    sc->sc_wdcdev.sc_dev.dv_xname);
				sc->sc_wdcdev.UDMA_cap = 4;
			}
		} else {
			sc->sc_wdcdev.cap &= ~WDC_CAPABILITY_UDMA;
		}
		pci_conf_write(sc->sc_pc, sc->sc_tag, old_udma_conf, APO_UDMA);
	}
 
	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		ideconf = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_IDECONF);
		if ((ideconf & APO_IDECONF_EN(channel)) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			continue;
		}
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0)
			continue;
		if (pciide_chan_candisable(cp)) {
			ideconf &= ~APO_IDECONF_EN(channel);
			pci_conf_write(sc->sc_pc, sc->sc_tag, APO_IDECONF,
				    ideconf);
		}
		pciide_map_compat_intr(pa, cp, channel, interface);

		if (cp->hw_ok == 0)
			continue;
		apollo_setup_channel(&sc->pciide_channels[channel].wdc_channel);
	}
	WDCDEBUG_PRINT(("apollo_chip_map: APO_DATATIM=0x%x, APO_UDMA=0x%x\n",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM),
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA)), DEBUG_PROBE);
}

void
apollo_setup_channel(chp)
	struct channel_softc *chp;
{
	u_int32_t udmatim_reg, datatim_reg;
	u_int8_t idedma_ctl;
	int mode, drive;
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	idedma_ctl = 0;
	datatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM);
	udmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);
	datatim_reg &= ~APO_DATATIM_MASK(chp->channel);
	udmatim_reg &= ~APO_UDMA_MASK(chp->channel);

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	/*
	 * We can't mix Ultra/33 and Ultra/66 on the same channel, so
	 * downgrade to Ultra/33 if needed
	 */
	if ((chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&
	    (chp->ch_drive[1].drive_flags & DRIVE_UDMA)) {
		/* both drives UDMA */
		if (chp->ch_drive[0].UDMA_mode > 2 && 
		    chp->ch_drive[1].UDMA_mode <= 2) {
			/* drive 0 Ultra/66, drive 1 Ultra/33 */
			chp->ch_drive[0].UDMA_mode = 2;
		} else if (chp->ch_drive[1].UDMA_mode > 2 &&
		    chp->ch_drive[0].UDMA_mode <= 2) {
			/* drive 1 Ultra/66, drive 0 Ultra/33 */
			chp->ch_drive[1].UDMA_mode = 2;
		}
	}

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		if (((drvp->drive_flags & DRIVE_DMA) == 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) == 0)) {
			mode = drvp->PIO_mode;
			goto pio;
		}
		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&
		    (drvp->drive_flags & DRIVE_UDMA)) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			udmatim_reg |= APO_UDMA_EN(chp->channel, drive) |
			    APO_UDMA_EN_MTH(chp->channel, drive) |
			    APO_UDMA_TIME(chp->channel, drive,
				apollo_udma_tim[drvp->UDMA_mode]);
			if (drvp->UDMA_mode > 2)
				udmatim_reg |=
				    APO_UDMA_CLK66(chp->channel);
			/* can use PIO timings, MW DMA unused */
			mode = drvp->PIO_mode;
		} else {
			/* use Multiword DMA */
			drvp->drive_flags &= ~DRIVE_UDMA;
			/* mode = min(pio, dma+2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode +2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:		/* setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
			mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}
		datatim_reg |=
		    APO_DATATIM_PULSE(chp->channel, drive,
			apollo_pio_set[mode]) |
		    APO_DATATIM_RECOV(chp->channel, drive,
			apollo_pio_rec[mode]);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),
		    idedma_ctl);
	}
	pciide_print_modes(cp);
	pci_conf_write(sc->sc_pc, sc->sc_tag, APO_DATATIM, datatim_reg);
	pci_conf_write(sc->sc_pc, sc->sc_tag, APO_UDMA, udmatim_reg);
}

void
cmd_channel_map(pa, sc, channel)
	struct pci_attach_args *pa;
	struct pciide_softc *sc;
	int channel;
{
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	bus_size_t cmdsize, ctlsize;
	u_int8_t ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CTRL);
	pcireg_t interface;

	/*
	 * The 0648/0649 can be told to identify as a RAID controller.
	 * In this case, we have to fake interface
	 */
	if (PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCIIDE_INTERFACE_SETTABLE(0) |
		    PCIIDE_INTERFACE_SETTABLE(1);
		if (pciide_pci_read(pa->pa_pc, pa->pa_tag, CMD_CONF) &
		    CMD_CONF_DSA1)
			interface |= PCIIDE_INTERFACE_PCI(0) |
			    PCIIDE_INTERFACE_PCI(1);
	} else {
		interface = PCI_INTERFACE(pa->pa_class);
	}

	sc->wdc_chanarray[channel] = &cp->wdc_channel;
	cp->name = PCIIDE_CHANNEL_NAME(channel);
	cp->wdc_channel.channel = channel;
	cp->wdc_channel.wdc = &sc->sc_wdcdev;

	if (channel > 0) {
		cp->wdc_channel.ch_queue =
		    sc->pciide_channels[0].wdc_channel.ch_queue;
	} else {
		cp->wdc_channel.ch_queue =
		    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);
	}
	if (cp->wdc_channel.ch_queue == NULL) {
		printf(
		    "%s: %s cannot allocate memory for command queue",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return;
	}

	/*
	 * with a CMD PCI64x, if we get here, the first channel is enabled:
	 * there's no way to disable the first channel without disabling
	 * the whole device
	 */
	 if (channel != 0 && (ctrl & CMD_CTRL_2PORT) == 0) {
		printf("%s: %s ignored (disabled)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
d1867 1
a1867 1
		if (pciide_chan_candisable(cp)) {
d1874 1
d1915 3
a1917 1
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
d1938 1
a1938 1
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16;
d1948 1
a1948 1
cmd0643_9_chip_map(sc, pa)
d1954 2
a1955 18
	int rev = PCI_REVISION(
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));
	pcireg_t interface;

	/*
	 * The 0648/0649 can be told to identify as a RAID controller.
	 * In this case, we have to fake interface
	 */
	if (PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCIIDE_INTERFACE_SETTABLE(0) |
		    PCIIDE_INTERFACE_SETTABLE(1);
		if (pciide_pci_read(pa->pa_pc, pa->pa_tag, CMD_CONF) &
		    CMD_CONF_DSA1)
			interface |= PCIIDE_INTERFACE_PCI(0) |
			    PCIIDE_INTERFACE_PCI(1);
	} else {
		interface = PCI_INTERFACE(pa->pa_class);
	}
d1973 2
a1974 37
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		switch (sc->sc_pp->ide_product) {
		case PCI_PRODUCT_CMDTECH_649:
		case PCI_PRODUCT_CMDTECH_648:
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
			sc->sc_wdcdev.UDMA_cap = 4;
			sc->sc_wdcdev.irqack = cmd646_9_irqack;
			break;
                case PCI_PRODUCT_CMDTECH_646:
                        if (rev >= CMD0646U2_REV) {
                                sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
                                sc->sc_wdcdev.UDMA_cap = 2;
                        } else if (rev >= CMD0646U_REV) {
                        /*
                         * Linux's driver claims that the 646U is broken
                         * with UDMA. Only enable it if we know what we're
                         * doing
                         */
#ifdef PCIIDE_CMD0646U_ENABLEUDMA
                                sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
                                sc->sc_wdcdev.UDMA_cap = 2;
#endif
                                /* explicitely disable UDMA */
                                pciide_pci_write(sc->sc_pc, sc->sc_tag,
                                    CMD_UDMATIM(0), 0);
                                pciide_pci_write(sc->sc_pc, sc->sc_tag,
                                    CMD_UDMATIM(1), 0);
                        }
                        sc->sc_wdcdev.irqack = cmd646_9_irqack;
                        break;
		default:
			sc->sc_wdcdev.irqack = pciide_irqack;
		}
	}
d1978 2
d1982 1
a1982 1
	sc->sc_wdcdev.set_modes = cmd0643_9_setup_channel;
d1986 1
a1986 1
	WDCDEBUG_PRINT(("cmd0643_9_chip_map: old timings reg 0x%x 0x%x\n",
d1995 1
a1995 1
		cmd0643_9_setup_channel(&cp->wdc_channel);
a1996 4
	/*
	 * note - this also makes sure we clear the irq disable and reset
	 * bits
	 */
d1998 1
a1998 1
	WDCDEBUG_PRINT(("cmd0643_9_chip_map: timings reg now 0x%x 0x%x\n",
d2005 1
a2005 1
cmd0643_9_setup_channel(chp)
d2010 1
a2010 1
	u_int32_t idedma_ctl, udma_reg;
d2025 10
a2034 45
		tim = cmd0643_9_data_tim_pio[drvp->PIO_mode];
		if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) {
			if (drvp->drive_flags & DRIVE_UDMA) {
				/* UltraDMA on a 646U2, 0648 or 0649 */
				drvp->drive_flags &= ~DRIVE_DMA;
				udma_reg = pciide_pci_read(sc->sc_pc,
				    sc->sc_tag, CMD_UDMATIM(chp->channel));
				if (drvp->UDMA_mode > 2 &&
				    (pciide_pci_read(sc->sc_pc, sc->sc_tag,
				    CMD_BICSR) &
				    CMD_BICSR_80(chp->channel)) == 0)
					drvp->UDMA_mode = 2;
				if (drvp->UDMA_mode > 2)
					udma_reg &= ~CMD_UDMATIM_UDMA33(drive);
				else if (sc->sc_wdcdev.UDMA_cap > 2) 
					udma_reg |= CMD_UDMATIM_UDMA33(drive);
				udma_reg |= CMD_UDMATIM_UDMA(drive);
				udma_reg &= ~(CMD_UDMATIM_TIM_MASK <<
				    CMD_UDMATIM_TIM_OFF(drive));
				udma_reg |=
				    (cmd0646_9_tim_udma[drvp->UDMA_mode] <<
				    CMD_UDMATIM_TIM_OFF(drive));
				pciide_pci_write(sc->sc_pc, sc->sc_tag,
				    CMD_UDMATIM(chp->channel), udma_reg);
			} else {
				/*
				 * use Multiword DMA.
				 * Timings will be used for both PIO and DMA,
				 * so adjust DMA mode if needed
				 * if we have a 0646U2/8/9, turn off UDMA
				 */
				if (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {
					udma_reg = pciide_pci_read(sc->sc_pc,
					    sc->sc_tag,
					    CMD_UDMATIM(chp->channel));
					udma_reg &= ~CMD_UDMATIM_UDMA(drive);
					pciide_pci_write(sc->sc_pc, sc->sc_tag,
					    CMD_UDMATIM(chp->channel),
					    udma_reg);
				}
				if (drvp->PIO_mode >= 3 &&
				    (drvp->DMA_mode + 2) > drvp->PIO_mode) {
					drvp->DMA_mode = drvp->PIO_mode - 2;
				}
				tim = cmd0643_9_data_tim_dma[drvp->DMA_mode];
d2036 1
a2051 18
cmd646_9_irqack(chp)
        struct channel_softc *chp;
{
        u_int32_t priirq, secirq;
        struct pciide_channel *cp = (struct pciide_channel*)chp;
        struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

        if (chp->channel == 0) {
                priirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CONF);
                pciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_CONF, priirq);
        } else {
                secirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23);
                pciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23, secirq);
        }
        pciide_irqack(chp);
}

void
d2057 3
a2059 2
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;
d2069 1
a2069 1
		sc->sc_cy_compatchan = 0;
d2071 1
a2071 1
		sc->sc_cy_compatchan = 1;
d2073 3
a2075 1
		printf(": unexpected PCI function %d\n", pa->pa_function);
a2077 1

d2086 1
a2086 5
	sc->sc_cy_handle = cy82c693_init(pa->pa_iot);
	if (sc->sc_cy_handle == NULL) {
		printf(", (unable to map ctl registers)");
		sc->sc_dma_ok = 0;
	}
d2088 3
a2090 1
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
a2091 4
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
d2101 1
a2101 1
	sc->wdc_chanarray[0] = &cp->wdc_channel;
d2108 3
a2110 1
		printf(": cannot allocate memory for command queue\n");
a2112 12
	printf(", %s %s to ", PCIIDE_CHANNEL_NAME(0),
	    (interface & PCIIDE_INTERFACE_SETTABLE(0)) ?
	    "configured" : "wired");
	if (interface & PCIIDE_INTERFACE_PCI(0)) {
		printf("native-PCI\n");
		cp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize, &ctlsize,
		    pciide_pci_intr);
	} else {
		printf("compatibility\n");
		cp->hw_ok = pciide_mapregs_compat(pa, cp, sc->sc_cy_compatchan,
		    &cmdsize, &ctlsize);
	}
d2117 1
a2117 1
	if (pciide_chan_candisable(cp)) {
d2121 1
a2121 1
	pciide_map_compat_intr(pa, cp, sc->sc_cy_compatchan, interface);
a2171 11

	if (dma_mode == -1)
		dma_mode = 0;

	if (sc->sc_cy_handle != NULL) {
		/* Note: `multiple' is implied. */
		cy82c693_write(sc->sc_cy_handle,
		    (sc->sc_cy_compatchan == 0) ?
		    CY_DMA_IDX_PRIMARY : CY_DMA_IDX_SECONDARY, dma_mode);
	}

a2172 1

d2188 4
a2191 2
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	pcireg_t rev = PCI_REVISION(pa->pa_class);
d2199 1
a2199 2
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
d2201 1
a2201 2
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
d2206 2
a2212 1

d2236 1
a2236 1
		if (pciide_chan_candisable(cp)) {
a2326 1
	pcireg_t rev = PCI_REVISION(pa->pa_class);
a2332 2
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
d2334 2
a2335 10
	if (rev < 0xC4)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_NO_ATAPI_DMA;

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
		if (rev >= 0x20)
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
d2337 2
d2341 1
a2341 2
	if (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA)
		sc->sc_wdcdev.UDMA_cap = 2;
d2350 1
d2382 1
a2382 1
		if (pciide_chan_candisable(cp)) {
d2500 3
d2504 1
a2504 1
hpt_chip_map(sc, pa)
d2509 2
a2510 218
	int i, compatchan, revision;
	pcireg_t interface;
	bus_size_t cmdsize, ctlsize;

	if (pciide_chipen(sc, pa) == 0)
		return;
	revision = PCI_REVISION(pa->pa_class);

	/* 
	 * when the chip is in native mode it identifies itself as a
	 * 'misc mass storage'. Fake interface in this case.
	 */
	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCI_INTERFACE(pa->pa_class);
	} else {
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0);
		if (revision == HPT370_REV)
			interface |= PCIIDE_INTERFACE_PCI(1);
	}

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;

	sc->sc_wdcdev.set_modes = hpt_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	if (revision < HPT370_REV) {
		sc->sc_wdcdev.UDMA_cap = 4;
		/*
		 * The 366 has 2 PCI IDE functions, one for primary and one
		 * for secondary. So we need to call pciide_mapregs_compat()
		 * with the real channel
		 */
		if (pa->pa_function == 0) {
			compatchan = 0;
		} else if (pa->pa_function == 1) {
			compatchan = 1;
		} else {
			printf("%s: unexpected PCI function %d\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, pa->pa_function);
			return;
		}
		sc->sc_wdcdev.nchannels = 1;
	} else {
		sc->sc_wdcdev.nchannels = 2;
		sc->sc_wdcdev.UDMA_cap = 5;
	}
	 for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		if (sc->sc_wdcdev.nchannels > 1) {
			compatchan = i;
			if((pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    HPT370_CTRL1(i)) & HPT370_CTRL1_EN) == 0) {
				printf("%s: %s ignored (disabled)\n",
				    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
				continue;
			}
		}
		if (pciide_chansetup(sc, i, interface) == 0)
			continue;
		if (interface & PCIIDE_INTERFACE_PCI(i)) {
			cp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize,
			    &ctlsize, hpt_pci_intr);
		} else {
			cp->hw_ok = pciide_mapregs_compat(pa, cp, compatchan,
			    &cmdsize, &ctlsize);
		}
		if (cp->hw_ok == 0)
			return;
		cp->wdc_channel.data32iot = cp->wdc_channel.cmd_iot;
		cp->wdc_channel.data32ioh = cp->wdc_channel.cmd_ioh;
		wdcattach(&cp->wdc_channel);
		hpt_setup_channel(&cp->wdc_channel);
	}
	if (revision == HPT370_REV) {
		/*
		 * HPT370_REV has a bit to disable interrupts, make sure
		 * to clear it
		 */
		pciide_pci_write(sc->sc_pc, sc->sc_tag, HPT_CSEL,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT_CSEL) &
		    ~HPT_CSEL_IRQDIS);
	}
	return;
}

void
hpt_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	int drive;
	int cable;
	u_int32_t before, after;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	cable = pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT_CSEL);

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;

	/* Per drive settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		before = pci_conf_read(sc->sc_pc, sc->sc_tag,
					HPT_IDETIM(chp->channel, drive));

		/* add timing values, setup DMA if needed */
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			if ((cable & HPT_CSEL_CBLID(chp->channel)) != 0 &&
			    drvp->UDMA_mode > 2)
				drvp->UDMA_mode = 2;
			after = (sc->sc_wdcdev.nchannels == 2) ?
			    hpt370_udma[drvp->UDMA_mode] :
			    hpt366_udma[drvp->UDMA_mode];
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			/*
			 * use Multiword DMA.
			 * Timings will be used for both PIO and DMA, so adjust
			 * DMA mode if needed
			 */
			if (drvp->PIO_mode >= 3 &&
			    (drvp->DMA_mode + 2) > drvp->PIO_mode) {
				drvp->DMA_mode = drvp->PIO_mode - 2;
			}
			after = (sc->sc_wdcdev.nchannels == 2) ?
			    hpt370_dma[drvp->DMA_mode] :
			    hpt366_dma[drvp->DMA_mode];
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			/* PIO only */
			after = (sc->sc_wdcdev.nchannels == 2) ?
			    hpt370_pio[drvp->PIO_mode] :
			    hpt366_pio[drvp->PIO_mode];
		}
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    HPT_IDETIM(chp->channel, drive), after);
		WDCDEBUG_PRINT(("%s: bus speed register set to 0x%08x "
		    "(BIOS 0x%08x)\n", drvp->drv_softc->dv_xname,
		    after, before), DEBUG_PROBE);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL, idedma_ctl);
	}
	pciide_print_modes(cp);
}

int
hpt_pci_intr(arg)
	void *arg;
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int rv = 0;
	int dmastat, i, crv;

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i);
		if ((dmastat & IDEDMA_CTL_INTR) == 0)
		    continue;
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		crv = wdcintr(wdc_cp);
		if (crv == 0) {
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
			bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
			    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i, dmastat);
		} else
			rv = 1;
	}
	return rv;
}


/* Macros to test product */
#define PDC_IS_262(sc)							\
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20262 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20265  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267)
#define PDC_IS_265(sc)							\
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20265 ||	\
        (sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267)



void
pdc202xx_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface, st, mode;
d2534 2
a2535 2
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_NO_ATAPI_DMA;
	if (sc->sc_dma_ok) {
a2536 3
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
d2539 1
a2539 3
	if (PDC_IS_265(sc))
		sc->sc_wdcdev.UDMA_cap = 5;
	else if (PDC_IS_262(sc))
d2608 2
a2609 6
		if (PDC_IS_265(sc))
			pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
			    pdc20265_pci_intr);
		else
			pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
			    pdc202xx_pci_intr);
d2612 1
a2612 1
		if (pciide_chan_candisable(cp))
a2639 4
	WDCDEBUG_PRINT(("pdc202xx_setup_channel %s: scr 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname,
	    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC262_U66)),
	    DEBUG_PROBE);
d2647 1
a2647 1
		if ((st & PDC262_STATE_80P(channel)) != 0 ||
a2666 4
		WDCDEBUG_PRINT(("pdc202xx_setup_channel %s:%d: ATAPI 0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, channel,
		    bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_ATAPI(channel))), DEBUG_PROBE);
a2688 2
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
d2753 2
a2754 2
				printf("%s:%d: bogus intr (reg 0x%x)\n",
				    sc->sc_wdcdev.sc_dev.dv_xname, i, scr);
a2759 249
}

int
pdc20265_pci_intr(arg)
	void *arg;
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv; 
	u_int32_t dmastat;

	rv = 0;
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		/* If a compat channel skip. */
		if (cp->compat)
			continue;
		/*
		 * The Ultra/100 seems to assert PDC2xx_SCR_INT * spuriously,
		 * however it asserts INT in IDEDMA_CTL even for non-DMA ops.
		 * So use it instead (requires 2 reg reads instead of 1,
		 * but we can't do it another way).
		 */
		dmastat = bus_space_read_1(sc->sc_dma_iot,
		    sc->sc_dma_ioh, IDEDMA_CTL + IDEDMA_SCH_OFFSET * i);
		if((dmastat & IDEDMA_CTL_INTR) == 0)
		    continue;
		crv = wdcintr(wdc_cp);
		if (crv == 0)
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
		else
			rv = 1;
	}
	return rv;
}

/*
 * Inline functions for accessing the timing registers of the
 * OPTi controller.
 *
 * These *MUST* disable interrupts as they need atomic access to
 * certain magic registers. Failure to adhere to this *will*
 * break things in subtle ways if the wdc registers are accessed
 * by an interrupt routine while this magic sequence is executing.
 */
static __inline__ u_int8_t
opti_read_config(struct channel_softc *chp, int reg)
{
	u_int8_t rv;
	int s = splhigh();

	/* Two consecutive 16-bit reads from register #1 (0x1f1/0x171) */
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);

	/* Followed by an 8-bit write of 0x3 to register #2 */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x03u);

	/* Now we can read the required register */
	rv = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, reg);

	/* Restore the real registers */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x83u);

	splx(s);

	return rv;
}

static __inline__ void
opti_write_config(struct channel_softc *chp, int reg, u_int8_t val)
{
	int s = splhigh();

	/* Two consecutive 16-bit reads from register #1 (0x1f1/0x171) */
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);
	(void) bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wdr_features);

	/* Followed by an 8-bit write of 0x3 to register #2 */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x03u);

	/* Now we can write the required register */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, reg, val);

	/* Restore the real registers */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wdr_seccnt, 0x83u);

	splx(s);
}

void
opti_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
{
	struct pciide_channel *cp;
	bus_size_t cmdsize, ctlsize;
	pcireg_t interface;
	u_int8_t init_ctrl;
	int channel;

	if (pciide_chipen(sc, pa) == 0)
		return;
	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	sc->sc_wdcdev.PIO_cap = 4;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		sc->sc_wdcdev.DMA_cap = 2;
	}
	sc->sc_wdcdev.set_modes = opti_setup_channel;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	init_ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag,
	    OPTI_REG_INIT_CONTROL);

	interface = PCI_INTERFACE(pa->pa_class);

        pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		if (channel == 1 &&
		    (init_ctrl & OPTI_INIT_CONTROL_CH2_DISABLE) != 0) {
			printf("%s: %s channel ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			continue;
		}
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0)
			continue;
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		opti_setup_channel(&cp->wdc_channel);
	}
}

void
opti_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int drive,spd;
	int mode[2];
	u_int8_t rv, mr;

	/*
	 * The `Delay' and `Address Setup Time' fields of the
	 * Miscellaneous Register are always zero initially.
	 */
	mr = opti_read_config(chp, OPTI_REG_MISC) & ~OPTI_MISC_INDEX_MASK;
	mr &= ~(OPTI_MISC_DELAY_MASK |
		OPTI_MISC_ADDR_SETUP_MASK |
		OPTI_MISC_INDEX_MASK);

	/* Prime the control register before setting timing values */
	opti_write_config(chp, OPTI_REG_CONTROL, OPTI_CONTROL_DISABLE);

	/* Determine the clockrate of the PCIbus the chip is attached to */
	spd = (int) opti_read_config(chp, OPTI_REG_STRAP);
	spd &= OPTI_STRAP_PCI_SPEED_MASK;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0) {
			mode[drive] = -1;
			continue;
		}

		if ((drvp->drive_flags & DRIVE_DMA)) {
			/*
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode > (drvp->DMA_mode + 2))
				drvp->PIO_mode = drvp->DMA_mode + 2;
			if (drvp->DMA_mode + 2 > (drvp->PIO_mode))
				drvp->DMA_mode = (drvp->PIO_mode > 2) ?
				    drvp->PIO_mode - 2 : 0;
			if (drvp->DMA_mode == 0)
				drvp->PIO_mode = 0;

			mode[drive] = drvp->DMA_mode + 5;
		} else
			mode[drive] = drvp->PIO_mode;

		if (drive && mode[0] >= 0 &&
		    (opti_tim_as[spd][mode[0]] != opti_tim_as[spd][mode[1]])) {
			/*
			 * Can't have two drives using different values
			 * for `Address Setup Time'.
			 * Slow down the faster drive to compensate.
			 */
			int d = (opti_tim_as[spd][mode[0]] >
				 opti_tim_as[spd][mode[1]]) ?  0 : 1;

			mode[d] = mode[1-d];
			chp->ch_drive[d].PIO_mode = chp->ch_drive[1-d].PIO_mode;
			chp->ch_drive[d].DMA_mode = 0;
			chp->ch_drive[d].drive_flags &= DRIVE_DMA;
		}
	}

	for (drive = 0; drive < 2; drive++) {
		int m;
		if ((m = mode[drive]) < 0)
			continue;

		/* Set the Address Setup Time and select appropriate index */
		rv = opti_tim_as[spd][m] << OPTI_MISC_ADDR_SETUP_SHIFT;
		rv |= OPTI_MISC_INDEX(drive);
		opti_write_config(chp, OPTI_REG_MISC, mr | rv);

		/* Set the pulse width and recovery timing parameters */
		rv  = opti_tim_cp[spd][m] << OPTI_PULSE_WIDTH_SHIFT;
		rv |= opti_tim_rt[spd][m] << OPTI_RECOVERY_TIME_SHIFT;
		opti_write_config(chp, OPTI_REG_READ_CYCLE_TIMING, rv);
		opti_write_config(chp, OPTI_REG_WRITE_CYCLE_TIMING, rv);

		/* Set the Enhanced Mode register appropriately */
	    	rv = pciide_pci_read(sc->sc_pc, sc->sc_tag, OPTI_REG_ENH_MODE);
		rv &= ~OPTI_ENH_MODE_MASK(chp->channel, drive);
		rv |= OPTI_ENH_MODE(chp->channel, drive, opti_tim_em[m]);
		pciide_pci_write(sc->sc_pc, sc->sc_tag, OPTI_REG_ENH_MODE, rv);
	}

	/* Finally, enable the timings */
	opti_write_config(chp, OPTI_REG_CONTROL, OPTI_CONTROL_ENABLE);

	pciide_print_modes(cp);
@


1.20.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.20.2.1 2001/05/14 22:25:54 niklas Exp $     */
d474 1
a474 2
void	pciide_unmap_compat_intr __P(( struct pci_attach_args *,
	    struct pciide_channel *, int, int));
d571 1
a571 1
               printf(" sc_pc %p, sc_tag %p\n", sc->sc_pc, sc->sc_tag);
d688 1
a688 1
	    &wdc_cp->cmd_iot, &wdc_cp->cmd_ioh, NULL, cmdsizep, 0) != 0) {
d696 1
a696 1
	    &wdc_cp->ctl_iot, &cp->ctl_baseioh, NULL, ctlsizep, 0) != 0) {
d765 1
a765 1
		    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL, 0) == 0);
d988 2
a989 2
		   seg, letoh32(dma_maps->dma_table[seg].byte_count),
		   letoh32(dma_maps->dma_table[seg].base_addr)), DEBUG_DMA);
a1140 1
	cp->hw_ok = 1;
d1200 2
a1204 1
	cp->compat = 1;
a1213 18
/*
 * generic code to map the compat intr if hw_ok=1 and it is a compat channel.
 * Set hw_ok=0 on failure
 */
void
pciide_unmap_compat_intr(pa, cp, compatchan, interface)
	struct pci_attach_args *pa;
	struct pciide_channel *cp;
	int compatchan, interface;
{
	struct channel_softc *wdc_cp = &cp->wdc_channel;

	if ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)
		return;

	pciide_machdep_compat_intr_disestablish(pa->pa_pc, cp->ih);
}

a1300 3
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
a1325 1
			pciide_unmap_compat_intr(pa, cp, channel, interface);
d1330 2
d1469 1
a1469 1
		pciide_map_compat_intr(pa, cp, channel, 0);
a1471 3
		pciide_mapchan(pa, cp, 0, &cmdsize, &ctlsize, pciide_pci_intr);
		if (cp->hw_ok == 0)
			goto next;
d1478 1
d1480 1
a1480 1
			goto next;
a1481 3
next:
		if (cp->hw_ok == 0)
			pciide_unmap_compat_intr(pa, cp, channel, 0);
a1874 4
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;

d1878 1
a1878 1
		if (pciide_chan_candisable(cp)) {
d1880 2
a1881 3
		}
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
a1882 1
		}
d2068 2
a2069 1
		pciide_map_compat_intr(pa, cp, channel, interface);
a2071 6

		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			goto next;
		}
d2077 1
d2080 1
a2080 1
			goto next;
a2081 3
next:
		if (cp->hw_ok == 0)
			pciide_unmap_compat_intr(pa, cp, channel, interface);
d2242 2
a2243 1
	pciide_map_compat_intr(pa, cp, channel, interface);
a2245 5
	pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, cmd_pci_intr);
	if (cp->hw_ok == 0) {
		pciide_unmap_compat_intr(pa, cp, channel, interface);
		return;
	}
a2250 1
			pciide_unmap_compat_intr(pa, cp, channel, interface);
d2253 1
a2611 3
	pciide_map_compat_intr(pa, cp, sc->sc_cy_compatchan, interface);
	if (cp->hw_ok == 0)
		return;
d2617 2
a2618 3
	if (cp->hw_ok == 0) {
		pciide_unmap_compat_intr(pa, cp, sc->sc_cy_compatchan, 
		    interface);
a2619 2
	}
				       
a2738 3
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
d2741 1
a2741 2
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
a2742 1
		}
d2751 2
a2752 2
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
a2753 1
		}
d2893 1
a2893 4
		}		
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
d2896 1
a2896 2
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
a2897 1
		}
d2903 1
a2903 4
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
d3180 1
a3180 1
		    "(BIOS 0x%08x)\n", sc->sc_wdcdev.sc_dev.dv_xname,
a3341 3
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
d3348 3
a3350 5
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		if (pciide_chan_candisable(cp)) {
d3353 1
a3353 2
			pciide_unmap_compat_intr(pa, cp, channel, interface);
		}
d3647 4
a3653 6
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
@


1.20.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*      $OpenBSD: pciide.c,v 1.20.2.2 2001/07/04 10:42:55 niklas Exp $     */
/*	$NetBSD: pciide.c,v 1.127 2001/08/03 01:31:08 tsutsui Exp $	*/
d5 1
a5 1
 * Copyright (c) 1999, 2000, 2001 Manuel Bouyer.
d96 2
d116 1
a116 2
#include <dev/pci/pciide_acard_reg.h>
#include <dev/pci/pciide_natsemi_reg.h>
a178 1
		int             dma_in_progress;
a220 4
void natsemi_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void natsemi_setup_channel __P((struct channel_softc*));
int  natsemi_pci_intr __P((void *));

a235 4

void acard_chip_map __P((struct pciide_softc*, struct pci_attach_args*));
void acard_setup_channel __P((struct channel_softc*));
int  acard_pci_intr __P((void *));
a307 4
	{ PCI_PRODUCT_AMD_766_IDE, /* AMD 766 */
	  0,
	  amd756_chip_map
	},
d355 1
a355 1
	},
a375 7
const struct pciide_product_desc pciide_natsemi_products[] =  {
	{ PCI_PRODUCT_NS_PC87415,	/* National Semi PC87415 IDE */
	  0,
	  natsemi_chip_map
	}
};

d392 2
a393 2
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
d396 2
a397 2
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
d400 2
a401 2
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
d404 2
a405 17
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	}
};

const struct pciide_product_desc pciide_acard_products[] =  {
	{ PCI_PRODUCT_ACARD_ATP850U,	/* Acard ATP850U Ultra33 Controller */
	  IDE_PCI_CLASS_OVERRIDE,
	  acard_chip_map,
	},
	{ PCI_PRODUCT_ACARD_ATP860,	/* Acard ATP860 Ultra66 Controller */
	  IDE_PCI_CLASS_OVERRIDE,
	  acard_chip_map,
	},
	{ PCI_PRODUCT_ACARD_ATP860A,	/* Acard ATP860-A Ultra66 Controller */
	  IDE_PCI_CLASS_OVERRIDE,
	  acard_chip_map,
a431 2
	{ PCI_VENDOR_NS, pciide_natsemi_products,
	  sizeof(pciide_natsemi_products)/sizeof(pciide_natsemi_products[0]) },
a435 2
	{ PCI_VENDOR_ACARD, pciide_acard_products,
	  sizeof(pciide_acard_products)/sizeof(pciide_acard_products[0]) },
a477 2
int     pciide_intr_flag(struct pciide_channel *);

d583 1
a583 1
	WDCDEBUG_PRINT(("pciide: command/status register=0x%x\n",
d598 3
a600 3
		    sc->sc_wdcdev.sc_dev.dv_xname,
		    (csr & PCI_COMMAND_IO_ENABLE) == 0 ?
		    "device" : "bridge");
d658 2
a659 1
		if (pci_intr_map(pa, &intrhandle) != 0) {
a785 31
pciide_intr_flag(struct pciide_channel *cp) 
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	if (cp->dma_in_progress) {
		int retry = 10;
		int status;

		/* Check the status register */
		for (retry = 10; retry > 0; retry--) {
			status = bus_space_read_1(sc->sc_dma_iot, 
			    sc->sc_dma_ioh,
			    IDEDMA_CTL + IDEDMA_SCH_OFFSET * 
			    cp->wdc_channel.channel);
			if (status & IDEDMA_CTL_INTR) {
				break;
			}
			DELAY(5);
		}
		
		/* Not for us.  */
		if (retry == 0)
			return (0);

		return (1);
	}

	return (-1);
}

int
a790 3
	if (pciide_intr_flag(cp) == 0)
		return 0;

a819 3
		if (pciide_intr_flag(cp) == 0)
			continue;

a944 3
#ifndef BUS_DMA_RAW
#define BUS_DMA_RAW 0
#endif
d948 1
a948 1
	    databuf, datalen, NULL, BUS_DMA_NOWAIT|BUS_DMA_RAW);
d956 3
a958 2
#ifdef __HAVE_NEW_BUS_DMAMAP_SYNC
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, 0,
d996 3
a998 2
#ifdef __HAVE_NEW_BUS_DMAMAP_SYNC
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_table, 0, 
a1044 2

	sc->pciide_channels[channel].dma_in_progress = 1;
a1057 2
	sc->pciide_channels[channel].dma_in_progress = 0;

d1070 3
a1072 2
#ifdef __HAVE_NEW_BUS_DMAMAP_SYNC
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, 0, 
d1074 1
a1074 1
	    (dma_maps->dma_flags & WDC_DMA_READ) ?
d1138 2
a1139 2
		    "cannot allocate memory for command queue",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
d1246 1
a1246 1
	}
d1284 2
a1285 2
			if (sc->sc_dma_ok != 0)
				printf(", (partial support)");
d1306 1
a1306 1
			continue;
d1520 1
a1520 1
			    DEBUG_PROBE);
d1528 1
a1528 1
			    DEBUG_PROBE);
d1687 1
a1687 1
			ideconf |= PIIX_CONFIG_PINGPONG;
d1883 1
a1883 8
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_AMD_766_IDE:
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
	default:
		sc->sc_wdcdev.UDMA_cap = 4;
		break;
	}
a1933 2
	int product = PCI_PRODUCT(
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_ID_REG));
d1978 1
a1978 1
			if (AMD756_CHIPREV_DISABLEDMA(product, rev)) {
d2029 1
d2031 1
a2031 1
	u_int32_t ideconf;
a2032 2
	pcitag_t pcib_tag;
	pcireg_t pcib_id, pcib_class;
d2036 1
a2036 40
	pcib_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, pa->pa_device, 0);

	pcib_id = pci_conf_read(sc->sc_pc, pcib_tag, PCI_ID_REG);
	pcib_class = pci_conf_read(sc->sc_pc, pcib_tag, PCI_CLASS_REG);	
	
	switch (PCI_PRODUCT(pcib_id)) {
	case PCI_PRODUCT_VIATECH_VT82C586_ISA:
		if (PCI_REVISION(pcib_class) >= 0x02) {
			printf(": ATA33");
			sc->sc_wdcdev.UDMA_cap = 2;
		} else {
			printf(": DMA");
			sc->sc_wdcdev.UDMA_cap = 0;
		}
		break;
	case PCI_PRODUCT_VIATECH_VT82C596A:
		if (PCI_REVISION(pcib_class) >= 0x12) {
			printf(": ATA66");
			sc->sc_wdcdev.UDMA_cap = 4;
		} else {
			printf(": ATA33");
			sc->sc_wdcdev.UDMA_cap = 2;
		}
		break;

	case PCI_PRODUCT_VIATECH_VT82C686A_ISA:
		if (PCI_REVISION(pcib_class) >= 0x40) {
			printf(": ATA100");
			sc->sc_wdcdev.UDMA_cap = 5;
		} else {
			printf(": ATA66");
			sc->sc_wdcdev.UDMA_cap = 4;
		}
		break;
	default:
		printf(": DMA");
		sc->sc_wdcdev.UDMA_cap = 0;
		break;
	}
	
d2043 2
a2044 1
		if (sc->sc_wdcdev.UDMA_cap > 0)
d2049 1
d2056 1
d2062 1
a2062 1
	    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA)),
d2065 24
d2112 1
a2112 1
			    ideconf);
d2181 6
a2186 17
			    APO_UDMA_EN_MTH(chp->channel, drive);
			
			if (sc->sc_wdcdev.UDMA_cap == 5) {
				/* 686b */
				udmatim_reg |= APO_UDMA_CLK66(chp->channel);
				udmatim_reg |= APO_UDMA_TIME(chp->channel,
				    drive, apollo_udma100_tim[drvp->UDMA_mode]);
			} else if (sc->sc_wdcdev.UDMA_cap == 4) {
				/* 596b or 686a */
				udmatim_reg |= APO_UDMA_CLK66(chp->channel);
				udmatim_reg |= APO_UDMA_TIME(chp->channel,
				    drive, apollo_udma66_tim[drvp->UDMA_mode]);				
			} else {
				/* 596a or 586b */
				udmatim_reg |= APO_UDMA_TIME(chp->channel,
				    drive, apollo_udma33_tim[drvp->UDMA_mode]);
			}
a2280 1
	cp->hw_ok = 1;
a2747 2
	pcitag_t pchb_tag;
	pcireg_t pchb_id, pchb_class;
a2753 7

	/* get a PCI tag for the host bridge (function 0 of the same device) */
	pchb_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, pa->pa_device, 0);
	/* and read ID and rev of the ISA bridge */
	pchb_id = pci_conf_read(sc->sc_pc, pchb_tag, PCI_ID_REG);
	pchb_class = pci_conf_read(sc->sc_pc, pchb_tag, PCI_CLASS_REG);

d2759 1
a2759 8
		/*
		 * controllers with rev > 0xd0 support UDMA 2 at least
		 * controllers associated to a rev 0x2 530 Host to PCI Bridge
		 * have problems with UDMA
		 */
		if (rev >= 0xd0 &&
		    (PCI_PRODUCT(pchb_id) != PCI_PRODUCT_SIS_SiS530 ||
		    PCI_REVISION(pchb_class) >= 0x03))
a2880 172
natsemi_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface, ctl;
	bus_size_t cmdsize, ctlsize;

	if (pciide_chipen(sc, pa) == 0)
		return;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16;

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}

	pciide_pci_write(sc->sc_pc, sc->sc_tag, NATSEMI_CCBT, 0xb7);

	/*
	 * Mask off interrupts from both channels, appropriate channel(s)
	 * will be unmasked later.
	 */
	pciide_pci_write(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2) |
	    NATSEMI_CHMASK(0) | NATSEMI_CHMASK(1));

	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = natsemi_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag,
	    PCI_CLASS_REG));
	interface &= ~PCIIDE_CHANSTATUS_EN;	/* Reserved on PC87415 */
	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	/* If we're in PCIIDE mode, unmask INTA, otherwise mask it. */
	ctl = pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL1);
	if (interface & (PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1)))
		ctl &= ~NATSEMI_CTRL1_INTAMASK;
	else
		ctl |= NATSEMI_CTRL1_INTAMASK;
	pciide_pci_write(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL1, ctl);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;

		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    natsemi_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		natsemi_setup_channel(&cp->wdc_channel);
	}

}

void
natsemi_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	int drive, ndrives = 0;
	u_int32_t idedma_ctl = 0;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		ndrives++;
		/* add timing values, setup DMA if needed */
		if ((drvp->drive_flags & DRIVE_DMA) == 0)
			goto pio;

		/*
		 * use Multiword DMA
		 * Timings will be used for both PIO and DMA,
		 * so adjust DMA mode if needed
		 */
		if (drvp->PIO_mode >= 3 &&
		    (drvp->DMA_mode + 2) > drvp->PIO_mode) {
			drvp->DMA_mode = drvp->PIO_mode - 2;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
pio:
		pciide_pci_write(sc->sc_pc, sc->sc_tag,
		    NATSEMI_RTREG(chp->channel, drive), 0x85);
		pciide_pci_write(sc->sc_pc, sc->sc_tag,
		    NATSEMI_WTREG(chp->channel, drive), 0x85);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL, idedma_ctl);
	}
	if (ndrives > 0) {
		/* Unmask the channel if at least one drive is found */
		pciide_pci_write(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2) &
		    ~(NATSEMI_CHMASK(chp->channel)));
	}
	pciide_print_modes(cp);

	/* Go ahead and ack interrupts generated during probe. */
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    (chp->channel * IDEDMA_SCH_OFFSET) + IDEDMA_CTL,
	    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		(chp->channel * IDEDMA_SCH_OFFSET) + IDEDMA_CTL));
}

int
natsemi_pci_intr(arg)
	void *arg;
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv;
	u_int8_t ide_dmactl, msk;

	rv = 0;
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		/* If a compat channel skip. */
		if (cp->compat)
			continue;

		/* If this channel is masked, skip it. */
		msk = pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2);
		if (msk & NATSEMI_CHMASK(i))
			continue;

		/* Get intr status */
		ide_dmactl = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    (i * IDEDMA_SCH_OFFSET) + IDEDMA_CTL);
		if (ide_dmactl & IDEDMA_CTL_ERR)
			printf("%s:%d: error intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
		if (ide_dmactl & IDEDMA_CTL_INTR) {
			crv = wdcintr(wdc_cp);
			if (crv == 0)
				printf("%s:%d: bogus intr\n",
				    sc->sc_wdcdev.sc_dev.dv_xname, i);
			else
				rv = 1;
		}
	}
	return rv;
}

void
d2904 1
a2904 1
		if (rev >= 0x20) {
a2905 7
			if (rev >= 0xC4)
				sc->sc_wdcdev.UDMA_cap = 5;
			else if (rev >= 0xC2)
				sc->sc_wdcdev.UDMA_cap = 4;
			else
				sc->sc_wdcdev.UDMA_cap = 2;
		}
d2912 2
a2939 18
	/* From linux: enable "Cable Detection" */
	if (rev >= 0xC2) {
		pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_0x4B,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_0x4B)
		    | ACER_0x4B_CDETECT);
		/* set south-bridge's enable bit, m1533, 0x79 */
		if (rev == 0xC2)
			/* 1543C-B0 (m1533, 0x79, bit 2) */
			pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_0x79,
			    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_0x79)
			    | ACER_0x79_REVC2_EN);
		else
			/* 1553/1535 (m1533, 0x79, bit 1) */
			pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_0x79,
			    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_0x79)
			    | ACER_0x79_EN);
	}

d2953 1
a2953 1
		    (rev >= 0xC2) ? pciide_pci_intr : acer_pci_intr);
a2988 11
	if ((chp->ch_drive[0].drive_flags | chp->ch_drive[1].drive_flags) &
	    DRIVE_UDMA)	{	/* check 80 pins cable */
		if (pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_0x4A) &
		    ACER_0x4A_80PIN(chp->channel)) {
			if (chp->ch_drive[0].UDMA_mode > 2)
				chp->ch_drive[0].UDMA_mode = 2;
			if (chp->ch_drive[1].UDMA_mode > 2)
				chp->ch_drive[1].UDMA_mode = 2;
		}
	}

a3018 7
			/* XXX disable if one drive < UDMA3 ? */
			if (drvp->UDMA_mode >= 3) {
				pciide_pci_write(sc->sc_pc, sc->sc_tag,
				    ACER_0x4B,
				    pciide_pci_read(sc->sc_pc, sc->sc_tag,
				        ACER_0x4B) | ACER_0x4B_UDMA66);
			}
d3102 1
a3102 1
		if (revision == HPT370_REV || revision == HPT370A_REV)
d3142 1
a3142 1
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
d3169 1
a3169 1
	if (revision == HPT370_REV || revision == HPT370A_REV) {
d3207 1
a3207 1
				       HPT_IDETIM(chp->channel, drive));
d3270 1
a3270 1
		wdc_cp = &cp->wdc_channel;	       
d3604 2
a3605 3
		if ((dmastat & IDEDMA_CTL_INTR) == 0)
			continue;

d3684 1
a3684 16
	/*
	 * XXXSCW:
	 * There seem to be a couple of buggy revisions/implementations
	 * of the OPTi pciide chipset. This kludge seems to fix one of
	 * the reported problems (NetBSD PR/11644) but still fails for the
	 * other (NetBSD PR/13151), although the latter may be due to other
	 * issues too...
	 */
	if (PCI_REVISION(pa->pa_class) <= 0x12) {
		printf(" (disabled)");
		sc->sc_dma_ok = 0;
		sc->sc_wdcdev.cap = 0;
	} else {
		sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA32;
		pciide_mapreg_dma(sc, pa);
	}
d3686 2
a3687 1
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_MODE;
a3827 209
}


#define	ACARD_IS_850(sc)							\
	((sc)->sc_pp->ide_product == PCI_PRODUCT_ACARD_ATP850U)

void
acard_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
{
	struct pciide_channel *cp;
	int i;
	pcireg_t interface;
	bus_size_t cmdsize, ctlsize;

	if (pciide_chipen(sc, pa) == 0)
		return;

	/* 
	 * when the chip is in native mode it identifies itself as a
	 * 'misc mass storage'. Fake interface in this case.
	 */
	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCI_INTERFACE(pa->pa_class);
	} else {
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);
	}

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = ACARD_IS_850(sc) ? 2 : 4;

	sc->sc_wdcdev.set_modes = acard_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = 2;

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		if (pciide_chansetup(sc, i, interface) == 0)
			continue;
		if (interface & PCIIDE_INTERFACE_PCI(i)) {
			cp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize,
			    &ctlsize, pciide_pci_intr);
		} else {
			cp->hw_ok = pciide_mapregs_compat(pa, cp, i,
			    &cmdsize, &ctlsize);
		}
		if (cp->hw_ok == 0)
			return;
		cp->wdc_channel.data32iot = cp->wdc_channel.cmd_iot;
		cp->wdc_channel.data32ioh = cp->wdc_channel.cmd_ioh;
		wdcattach(&cp->wdc_channel);
		acard_setup_channel(&cp->wdc_channel);
	}
	if (!ACARD_IS_850(sc)) {
		u_int32_t reg;
		reg = pci_conf_read(sc->sc_pc, sc->sc_tag, ATP8x0_CTRL);
		reg &= ~ATP860_CTRL_INT;
		pci_conf_write(sc->sc_pc, sc->sc_tag, ATP8x0_CTRL, reg);
	}
}

void
acard_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	int drive;
	u_int32_t idetime, udma_mode;
	u_int32_t idedma_ctl;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	if (ACARD_IS_850(sc)) {
		idetime = 0;
		udma_mode = pci_conf_read(sc->sc_pc, sc->sc_tag, ATP850_UDMA);
		udma_mode &= ~ATP850_UDMA_MASK(channel);
	} else {
		idetime = pci_conf_read(sc->sc_pc, sc->sc_tag, ATP860_IDETIME);
		idetime &= ~ATP860_SETTIME_MASK(channel);
		udma_mode = pci_conf_read(sc->sc_pc, sc->sc_tag, ATP860_UDMA);
		udma_mode &= ~ATP860_UDMA_MASK(channel);
	}

	idedma_ctl = 0;

	/* Per drive settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&
		    (drvp->drive_flags & DRIVE_UDMA)) {
			/* use Ultra/DMA */
			if (ACARD_IS_850(sc)) {
				idetime |= ATP850_SETTIME(drive,
				    acard_act_udma[drvp->UDMA_mode],
				    acard_rec_udma[drvp->UDMA_mode]);
				udma_mode |= ATP850_UDMA_MODE(channel, drive,
				    acard_udma_conf[drvp->UDMA_mode]);
			} else {
				idetime |= ATP860_SETTIME(channel, drive,
				    acard_act_udma[drvp->UDMA_mode],
				    acard_rec_udma[drvp->UDMA_mode]);
				udma_mode |= ATP860_UDMA_MODE(channel, drive,
				    acard_udma_conf[drvp->UDMA_mode]);
			}
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) &&
		    (drvp->drive_flags & DRIVE_DMA)) {
			/* use Multiword DMA */
			drvp->drive_flags &= ~DRIVE_UDMA;
			if (ACARD_IS_850(sc)) {
				idetime |= ATP850_SETTIME(drive,
				    acard_act_dma[drvp->DMA_mode],
				    acard_rec_dma[drvp->DMA_mode]);
			} else {
				idetime |= ATP860_SETTIME(channel, drive,
				    acard_act_dma[drvp->DMA_mode],
				    acard_rec_dma[drvp->DMA_mode]);
			}
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			/* PIO only */
			drvp->drive_flags &= ~(DRIVE_UDMA | DRIVE_DMA);
			if (ACARD_IS_850(sc)) {
				idetime |= ATP850_SETTIME(drive,
				    acard_act_pio[drvp->PIO_mode],
				    acard_rec_pio[drvp->PIO_mode]);
			} else {
				idetime |= ATP860_SETTIME(channel, drive,
				    acard_act_pio[drvp->PIO_mode],
				    acard_rec_pio[drvp->PIO_mode]);
			}
		pci_conf_write(sc->sc_pc, sc->sc_tag, ATP8x0_CTRL,
		    pci_conf_read(sc->sc_pc, sc->sc_tag, ATP8x0_CTRL)
		    | ATP8x0_CTRL_EN(channel));
		}
	}

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel, idedma_ctl);
	}
	pciide_print_modes(cp);

	if (ACARD_IS_850(sc)) {
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    ATP850_IDETIME(channel), idetime);
		pci_conf_write(sc->sc_pc, sc->sc_tag, ATP850_UDMA, udma_mode);
	} else {
		pci_conf_write(sc->sc_pc, sc->sc_tag, ATP860_IDETIME, idetime);
		pci_conf_write(sc->sc_pc, sc->sc_tag, ATP860_UDMA, udma_mode);
	}
}

int
acard_pci_intr(arg)
	void *arg;
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int rv = 0;
	int dmastat, i, crv;

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i);
		if ((dmastat & IDEDMA_CTL_INTR) == 0)
			continue;
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		if ((wdc_cp->ch_flags & WDCF_IRQ_WAIT) == 0) {
			(void)wdcintr(wdc_cp);
			bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
			    IDEDMA_CTL + IDEDMA_SCH_OFFSET * i, dmastat);
			continue;
		}
		crv = wdcintr(wdc_cp);
		if (crv == 0)
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
		else if (crv == 1)
			rv = 1;
		else if (rv == 0)
			rv = crv;
	}
	return rv;
@


1.20.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d95 1
a95 1
#include <uvm/uvm_extern.h>
d1035 1
d1040 5
d1074 1
d1078 4
d1151 1
d1156 5
d2435 1
a2435 2
			if (crv == 0) {
#if 0
d2438 1
a2438 2
#endif
			} else
@


1.20.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.20.2.4 2001/11/13 21:10:03 niklas Exp $     */
d2533 1
a2533 1
                                /* explicitly disable UDMA */
@


1.20.2.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
a424 4
	},
	{ PCI_PRODUCT_PROMISE_PDC20268,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
a2142 4
	case PCI_PRODUCT_VIATECH_VT8366_ISA:
		printf(": ATA100");
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
a2513 4
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
			sc->sc_wdcdev.UDMA_cap = 5;
			sc->sc_wdcdev.irqack = cmd646_9_irqack;
			break;
d3468 1
a3468 7
		/*
		 * XXX disable udma5 for now. 
		 */
		if (revision == HPT370_REV)
			sc->sc_wdcdev.UDMA_cap = 4;
		else
			sc->sc_wdcdev.UDMA_cap = 5;
d3595 1
a3595 2
		if((dmastat & ( IDEDMA_CTL_ACT | IDEDMA_CTL_INTR)) !=
		    IDEDMA_CTL_INTR)
d3611 1
d3616 1
a3616 2
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268)
d3619 3
a3621 4
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268)
#define PDC_IS_268(sc)							\
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268)
d3633 3
a3635 5
	if (!PDC_IS_268(sc)) {
		st = pci_conf_read(sc->sc_pc, sc->sc_tag, PDC2xx_STATE);
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: "
		    "controller state 0x%x\n", st), DEBUG_PROBE);
	}
d3640 1
a3640 2
	if (!PDC_IS_268(sc))
		st &= ~PDC2xx_STATE_IDERAID;
d3647 1
a3647 1
	if (PDC_IS_268(sc) || st & PDC2xx_STATE_NATIVE)
a3673 2
	if (PDC_IS_268(sc))
		goto pdc268_doesnt_need_it;
a3722 1
pdc268_doesnt_need_it:
d3727 1
a3727 1
		if (!PDC_IS_268(sc) && (st & (PDC_IS_262(sc) ?
d3746 1
a3746 1
		if (!PDC_IS_268(sc) && pciide_chan_candisable(cp)) {
d3753 3
a3755 5
	if (!PDC_IS_268(sc)) {
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: "
		"new controller state 0x%x\n", st), DEBUG_PROBE);
		pci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_STATE, st);
	}
a3773 3
	if (PDC_IS_268(sc))
		goto skip_for_pdc268;
	
a3873 2
	
skip_for_pdc268:
@


1.20.2.7
log
@Merge in -current from roughly a week ago
@
text
@d123 4
a126 4
static __inline u_int8_t pciide_pci_read(pci_chipset_tag_t, pcitag_t,
					      int);
static __inline void pciide_pci_write(pci_chipset_tag_t, pcitag_t,
					   int, u_int8_t);
d191 1
a191 1
void default_chip_map(struct pciide_softc*, struct pci_attach_args*);
d193 51
a243 51
void piix_chip_map(struct pciide_softc*, struct pci_attach_args*);
void piix_setup_channel(struct channel_softc*);
void piix3_4_setup_channel(struct channel_softc*);

static u_int32_t piix_setup_idetim_timings(u_int8_t, u_int8_t, u_int8_t);
static u_int32_t piix_setup_idetim_drvs(struct ata_drive_datas*);
static u_int32_t piix_setup_sidetim_timings(u_int8_t, u_int8_t, u_int8_t);

void amd756_chip_map(struct pciide_softc*, struct pci_attach_args*);
void amd756_setup_channel(struct channel_softc*);

void apollo_chip_map(struct pciide_softc*, struct pci_attach_args*);
void apollo_setup_channel(struct channel_softc*);

void cmd_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cmd0643_9_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cmd0643_9_setup_channel(struct channel_softc*);
void cmd_channel_map(struct pci_attach_args *,
			struct pciide_softc *, int);
int  cmd_pci_intr(void *);
void cmd646_9_irqack(struct channel_softc *);

void cy693_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cy693_setup_channel(struct channel_softc*);

void sis_chip_map(struct pciide_softc*, struct pci_attach_args*);
void sis_setup_channel(struct channel_softc*);

void natsemi_chip_map(struct pciide_softc*, struct pci_attach_args*);
void natsemi_setup_channel(struct channel_softc*);
int  natsemi_pci_intr(void *);

void acer_chip_map(struct pciide_softc*, struct pci_attach_args*);
void acer_setup_channel(struct channel_softc*);
int  acer_pci_intr(void *);

void pdc202xx_chip_map(struct pciide_softc*, struct pci_attach_args*);
void pdc202xx_setup_channel(struct channel_softc*);
int  pdc202xx_pci_intr(void *);
int  pdc20265_pci_intr(void *);

void opti_chip_map(struct pciide_softc*, struct pci_attach_args*);
void opti_setup_channel(struct channel_softc*);

void hpt_chip_map(struct pciide_softc*, struct pci_attach_args*);
void hpt_setup_channel(struct channel_softc*);
int  hpt_pci_intr(void *);

void acard_chip_map(struct pciide_softc*, struct pci_attach_args*);
void acard_setup_channel(struct channel_softc*);
int  acard_pci_intr(void *);
d245 8
a252 8
void pciide_channel_dma_setup(struct pciide_channel *);
int  pciide_dma_table_setup(struct pciide_softc*, int, int);
int  pciide_dma_init(void *, int, int, void *, size_t, int);
void pciide_dma_start(void *, int, int);
int  pciide_dma_finish(void *, int, int);
void pciide_irqack(struct channel_softc *);
void pciide_print_modes(struct pciide_channel *);
void pciide_print_channels(int, pcireg_t);;
d258 1
a258 1
	void (*chip_map)(struct pciide_softc*, struct pci_attach_args*);
d486 1
a486 1
int	pciide_match(struct device *, struct cfdata *, void *);
d488 1
a488 1
int	pciide_match(struct device *, void *, void *);
d490 1
a490 1
void	pciide_attach(struct device *, struct device *, void *);
d501 4
a504 4
int	pciide_chipen(struct pciide_softc *, struct pci_attach_args *);
int	pciide_mapregs_compat( struct pci_attach_args *,
	    struct pciide_channel *, int, bus_size_t *, bus_size_t*);
int	pciide_mapregs_native(struct pci_attach_args *, 
d506 5
a510 5
	    int (*pci_intr)(void *));
void	pciide_mapreg_dma(struct pciide_softc *,
	    struct pci_attach_args *);
int	pciide_chansetup(struct pciide_softc *, int, pcireg_t);
void	pciide_mapchan(struct pci_attach_args *,
d512 8
a519 8
	    int (*pci_intr)(void *));
int	pciide_chan_candisable(struct pciide_channel *);
void	pciide_map_compat_intr( struct pci_attach_args *,
	    struct pciide_channel *, int, int);
void	pciide_unmap_compat_intr( struct pci_attach_args *,
	    struct pciide_channel *, int, int);
int	pciide_compat_intr(void *);
int	pciide_pci_intr(void *);
d522 1
a522 1
const struct pciide_product_desc* pciide_lookup_product(u_int32_t);
d692 1
a692 1
	int (*pci_intr)(void *);
d1221 1
a1221 1
	int (*pci_intr)(void *);
@


1.20.2.8
log
@Sync the SMP branch with 3.3
@
text
@d17 2
a18 1
 *	This product includes software developed by Manuel Bouyer.
d85 2
a86 4
#define WDCDEBUG_PRINT(args, level) do {		\
	if ((wdcdebug_pciide_mask & (level)) != 0)	\
		printf args;				\
} while (0)
a115 1
#include <dev/pci/pciide_nforce_reg.h>
a209 3
void cmd680_chip_map(struct pciide_softc*, struct pci_attach_args*);
void cmd680_setup_channel(struct channel_softc*);
void cmd680_channel_map(struct pci_attach_args *, struct pciide_softc *, int);
a223 1
void natsemi_irqack(struct channel_softc *);
a230 1
void pdc20268_setup_channel(struct channel_softc*);
a243 8

void serverworks_chip_map(struct pciide_softc*, struct pci_attach_args*);
void serverworks_setup_channel(struct channel_softc*);
int  serverworks_pci_intr(void *);

void nforce_chip_map(struct pciide_softc *, struct pci_attach_args *);
void nforce_setup_channel(struct channel_softc *);
int  nforce_pci_intr(void *);
d252 1
a252 1
void pciide_print_channels(int, pcireg_t);
a308 12
	{ PCI_PRODUCT_INTEL_82801CAM_IDE, /* Intel 82801CAM IDE (ICH3) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801CA_IDE, /* Intel 82801CA IDE (ICH3) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801DB_IDE, /* Intel 82801DB IDE (ICH4) */
	  0,
	  piix_chip_map
	},
a319 8
	{ PCI_PRODUCT_AMD_PBC768_IDE,
	  0,
	  amd756_chip_map
	},
	{ PCI_PRODUCT_AMD_8111_IDE,
	  0,
	  amd756_chip_map
	}
a359 4
	},
	{ PCI_PRODUCT_CMDTECH_680,	/* CMD Technology PCI0680 */
	  IDE_PCI_CLASS_OVERRIDE,
	  cmd680_chip_map
a405 8
	},
	{ PCI_PRODUCT_TRIONES_HPT372A,	/* Highpoint HPT372A IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map
	},
	{ PCI_PRODUCT_TRIONES_HPT374,	/* Highpoint HPT374 IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map
a428 24
	},
	{ PCI_PRODUCT_PROMISE_PDC20268R,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20269,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20271,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20275,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20276,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
	},
	{ PCI_PRODUCT_PROMISE_PDC20277,
	  IDE_PCI_CLASS_OVERRIDE,
	  pdc202xx_chip_map,
a446 27
const struct pciide_product_desc pciide_serverworks_products[] =  {
	{ PCI_PRODUCT_RCC_OSB4_IDE,
	  0,
	  serverworks_chip_map,
	},
	{ PCI_PRODUCT_RCC_CSB5_IDE,
	  0,
	  serverworks_chip_map,
	},
	{ PCI_PRODUCT_RCC_CSB6_IDE,
	  0,
	  serverworks_chip_map,
	},
};

const struct pciide_product_desc pciide_nvidia_products[] = {
	{ PCI_PRODUCT_NVIDIA_NFORCE_IDE,
	  0,
	  nforce_chip_map
	},
	{ PCI_PRODUCT_NVIDIA_NFORCE2_IDE,
	  0,
	  nforce_chip_map
	}
};


a477 2
	{ PCI_VENDOR_RCC, pciide_serverworks_products,
	  sizeof(pciide_serverworks_products)/sizeof(pciide_serverworks_products[0]) },
d479 1
a479 3
	  sizeof(pciide_promise_products)/sizeof(pciide_promise_products[0]) },
	{ PCI_VENDOR_NVIDIA, pciide_nvidia_products,
	  sizeof(pciide_nvidia_products)/sizeof(pciide_nvidia_products[0]) }
d631 1
a631 1
/* tell whether the chip is enabled or not */
d638 7
a644 5

	csr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);
	if ((csr & PCI_COMMAND_IO_ENABLE) == 0 ) {
		printf("\n%s: device disabled\n",
		    sc->sc_wdcdev.sc_dev.dv_xname);
a646 1

a697 1
	pcireg_t maptype;
a729 6

	maptype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
	    PCIIDE_REG_CMD_BASE(wdc_cp->channel));
	WDCDEBUG_PRINT(("%s: %s cmd regs mapping: %s\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
	    (maptype == PCI_MAPREG_TYPE_IO ? "I/O" : "memory")), DEBUG_PROBE);
d731 1
a731 1
	    maptype, 0,
a737 5
	maptype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
	    PCIIDE_REG_CTL_BASE(wdc_cp->channel));
	WDCDEBUG_PRINT(("%s: %s ctl regs mapping: %s\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
	    (maptype == PCI_MAPREG_TYPE_IO ? "I/O": "memory")), DEBUG_PROBE);
d739 1
a739 1
	    maptype, 0,
d753 1
a753 1
		printf("%s: unable to subregion %s ctl regs\n",
d841 2
a842 1
			    IDEDMA_CTL(cp->wdc_channel.channel));
d871 1
a871 1
		panic("pciide compat intr called for non-compat chan %p", cp);
d1087 1
a1087 1
	    IDEDMA_CTL(channel),
d1089 1
a1089 1
		IDEDMA_CTL(channel)));
d1092 1
a1092 1
	    IDEDMA_TBL(channel),
d1096 1
a1096 1
	    IDEDMA_CMD(channel),
d1112 1
a1112 1
	    IDEDMA_CMD(channel),
d1114 1
a1114 1
		IDEDMA_CMD(channel)) | IDEDMA_CMD_START);
d1133 1
a1133 1
	    IDEDMA_CTL(channel));
d1139 1
a1139 1
	    IDEDMA_CMD(channel),
d1152 1
a1152 1
	    IDEDMA_CTL(channel),
d1184 1
a1184 1
            IDEDMA_CTL(chp->channel),
d1186 1
a1186 1
                IDEDMA_CTL(chp->channel)));
a1245 1
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
a1249 2
		printf("%s: %s disabled (no drives)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
d1283 1
a1283 1
 * generic code to unmap the compat intr if hw_ok=1 and it is a compat channel.
d1458 1
a1458 1
			    IDEDMA_CTL(channel),
a1492 3
		case PCI_PRODUCT_INTEL_82801CAM_IDE:
		case PCI_PRODUCT_INTEL_82801CA_IDE:
		case PCI_PRODUCT_INTEL_82801DB_IDE:
a1504 3
	case PCI_PRODUCT_INTEL_82801CAM_IDE:
	case PCI_PRODUCT_INTEL_82801CA_IDE:
	case PCI_PRODUCT_INTEL_82801DB_IDE:
d1535 1
a1535 4
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
d1592 1
a1592 4
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
d1703 1
a1703 1
		    IDEDMA_CTL(chp->channel),
d1753 1
a1753 4
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
d1757 1
a1757 4
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801BA_IDE||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CAM_IDE||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801CA_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE) {
d1823 1
a1823 1
		    IDEDMA_CTL(channel),
a1951 2
	case PCI_PRODUCT_AMD_PBC768_IDE:
	case PCI_PRODUCT_AMD_8111_IDE:
a2006 1
	pcireg_t chanenable;
a2018 2
	chanenable = pci_conf_read(sc->sc_pc, sc->sc_tag,
	    AMD756_CHANSTATUS_EN);
a2037 11

			/* Check cable */
			if ((chanenable & AMD756_CABLE(chp->channel,
			    drive)) == 0 && drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    chp->channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}

d2090 1
a2090 1
		    IDEDMA_CTL(chp->channel),
a2146 4
	case PCI_PRODUCT_VIATECH_VT8231_ISA:
		printf(": ATA100");
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
a2150 8
	case PCI_PRODUCT_VIATECH_VT8233_ISA:
		printf(": ATA133");
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
	case PCI_PRODUCT_VIATECH_VT8235_ISA:
		printf(": ATA133");
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
d2156 1
a2156 1

d2275 2
a2276 4
			if (sc->sc_wdcdev.UDMA_cap == 6) {
				udmatim_reg |= APO_UDMA_TIME(chp->channel,
				    drive, apollo_udma133_tim[drvp->UDMA_mode]);
			} else if (sc->sc_wdcdev.UDMA_cap == 5) {
d2278 1
d2322 1
a2322 1
		    IDEDMA_CTL(chp->channel),
d2394 2
a2395 2
	if (pciide_chan_candisable(cp)) {
		if (channel == 1) {
d2663 1
a2663 1
		    IDEDMA_CTL(chp->channel),
a2666 10
#ifdef __sparc64__
	/*
	 * The Ultra 5 has a tendency to hang during reboot.  This is due
	 * to the PCI0646U asserting a PCI interrupt line when the chip
	 * registers claim that it is not.  Performing a reset at this
	 * point appears to eliminate the symptoms.  It is likely the
	 * real cause is still lurking somewhere in the code.
	 */
	wdcreset(chp, SILENT);
#endif /* __sparc64__ */
a2687 176
cmd680_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
{
	struct pciide_channel *cp;
	int channel;

	if (pciide_chipen(sc, pa) == 0)
		return;
	printf("\n%s: bus-master DMA support present",
	    sc->sc_wdcdev.sc_dev.dv_xname);
	pciide_mapreg_dma(sc, pa);
	printf("\n");
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.UDMA_cap = 6;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = cmd680_setup_channel;

	pciide_pci_write(sc->sc_pc, sc->sc_tag, 0x80, 0x00);
	pciide_pci_write(sc->sc_pc, sc->sc_tag, 0x84, 0x00);
	pciide_pci_write(sc->sc_pc, sc->sc_tag, 0x8a,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, 0x8a) | 0x01);
	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		cmd680_channel_map(pa, sc, channel);
		if (cp->hw_ok == 0)
			continue;
		cmd680_setup_channel(&cp->wdc_channel);
	}
}

void
cmd680_channel_map(pa, sc, channel)
	struct pci_attach_args *pa;
	struct pciide_softc *sc;
	int channel;
{
	struct pciide_channel *cp = &sc->pciide_channels[channel];
	bus_size_t cmdsize, ctlsize;
	int interface, i, reg;
	static const u_int8_t init_val[] =
	    {             0x8a, 0x32, 0x8a, 0x32, 0x8a, 0x32,
	      0x92, 0x43, 0x92, 0x43, 0x09, 0x40, 0x09, 0x40 };

	if (PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCIIDE_INTERFACE_SETTABLE(0) |
		    PCIIDE_INTERFACE_SETTABLE(1);
		interface |= PCIIDE_INTERFACE_PCI(0) |
		    PCIIDE_INTERFACE_PCI(1);
	} else {
		interface = PCI_INTERFACE(pa->pa_class);
	}

	sc->wdc_chanarray[channel] = &cp->wdc_channel;
	cp->name = PCIIDE_CHANNEL_NAME(channel);
	cp->wdc_channel.channel = channel;
	cp->wdc_channel.wdc = &sc->sc_wdcdev;

	cp->wdc_channel.ch_queue =
	    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);
	if (cp->wdc_channel.ch_queue == NULL) {
		printf("%s %s: "
		    "can't allocate memory for command queue",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		    return;
	}

	/* XXX */
	reg = 0xa2 + channel * 16;
	for (i = 0; i < sizeof(init_val); i++)
		pciide_pci_write(sc->sc_pc, sc->sc_tag, reg + i, init_val[i]);

	printf("%s: %s %s to %s mode\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
	    (interface & PCIIDE_INTERFACE_SETTABLE(channel)) ?
	    "configured" : "wired",
	    (interface & PCIIDE_INTERFACE_PCI(channel)) ?
	    "native-PCI" : "compatibility");

	pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, pciide_pci_intr);
	if (cp->hw_ok == 0)
		return;
	pciide_map_compat_intr(pa, cp, channel, interface);
}

void
cmd680_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	u_int8_t mode, off, scsc;
	u_int16_t val;
	u_int32_t idedma_ctl;
	int drive;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	pci_chipset_tag_t pc = sc->sc_pc;
	pcitag_t pa = sc->sc_tag;
	static const u_int8_t udma2_tbl[] =
	    { 0x0f, 0x0b, 0x07, 0x06, 0x03, 0x02, 0x01 };
	static const u_int8_t udma_tbl[] =
	    { 0x0c, 0x07, 0x05, 0x04, 0x02, 0x01, 0x00 };
	static const u_int16_t dma_tbl[] =
	    { 0x2208, 0x10c2, 0x10c1 };
	static const u_int16_t pio_tbl[] =
	    { 0x328a, 0x2283, 0x1104, 0x10c3, 0x10c1 };

	idedma_ctl = 0;
	pciide_channel_dma_setup(cp);
	mode = pciide_pci_read(pc, pa, 0x80 + chp->channel * 4);

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		mode &= ~(0x03 << (drive * 4));
		if (drvp->drive_flags & DRIVE_UDMA) {
			drvp->drive_flags &= ~DRIVE_DMA;
			off = 0xa0 + chp->channel * 16;
			if (drvp->UDMA_mode > 2 &&
			    (pciide_pci_read(pc, pa, off) & 0x01) == 0)
				drvp->UDMA_mode = 2;
			scsc = pciide_pci_read(pc, pa, 0x8a);
			if (drvp->UDMA_mode == 6 && (scsc & 0x30) == 0) {
				pciide_pci_write(pc, pa, 0x8a, scsc | 0x01);
				scsc = pciide_pci_read(pc, pa, 0x8a);
				if ((scsc & 0x30) == 0)
					drvp->UDMA_mode = 5;
			}
			mode |= 0x03 << (drive * 4);
			off = 0xac + chp->channel * 16 + drive * 2;
			val = pciide_pci_read(pc, pa, off) & ~0x3f;
			if (scsc & 0x30)
				val |= udma2_tbl[drvp->UDMA_mode];
			else
				val |= udma_tbl[drvp->UDMA_mode];
			pciide_pci_write(pc, pa, off, val);
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			mode |= 0x02 << (drive * 4);
			off = 0xa8 + chp->channel * 16 + drive * 2;
			val = dma_tbl[drvp->DMA_mode];
			pciide_pci_write(pc, pa, off, val & 0xff);
			pciide_pci_write(pc, pa, off, val >> 8);
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			mode |= 0x01 << (drive * 4);
			off = 0xa4 + chp->channel * 16 + drive * 2;
			val = pio_tbl[drvp->PIO_mode];
			pciide_pci_write(pc, pa, off, val & 0xff);
			pciide_pci_write(pc, pa, off, val >> 8);
		}
	}

	pciide_pci_write(pc, pa, 0x80 + chp->channel * 4, mode);
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel),
		    idedma_ctl);
	}
	pciide_print_modes(cp);
}

void
d2844 1
a2844 1
		    IDEDMA_CTL(chp->channel), idedma_ctl);
d3002 1
a3002 1
		    IDEDMA_CTL(chp->channel), idedma_ctl);
d3026 1
a3026 1
		sc->sc_wdcdev.irqack = natsemi_irqack;
d3075 1
a3086 1
	u_int8_t tim;
d3099 11
a3109 16
		if ((drvp->drive_flags & DRIVE_DMA) == 0) {
			tim = natsemi_pio_pulse[drvp->PIO_mode] |
			    (natsemi_pio_recover[drvp->PIO_mode] << 4);
		} else {
			/*
			 * use Multiword DMA
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode >= 3 &&
			    (drvp->DMA_mode + 2) > drvp->PIO_mode) {
				drvp->DMA_mode = drvp->PIO_mode - 2;
			}
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			tim = natsemi_dma_pulse[drvp->DMA_mode] |
			    (natsemi_dma_recover[drvp->DMA_mode] << 4);
d3111 2
a3112 1

d3114 1
a3114 1
		    NATSEMI_RTREG(chp->channel, drive), tim);
d3116 1
a3116 1
		    NATSEMI_WTREG(chp->channel, drive), tim);
d3121 1
a3121 1
		    IDEDMA_CTL(chp->channel), idedma_ctl);
a3128 1

d3133 1
a3133 1
	    IDEDMA_CTL(chp->channel),
d3135 1
a3135 19
		IDEDMA_CTL(chp->channel)));
}

void
natsemi_irqack(chp)
        struct channel_softc *chp;
{
        struct pciide_channel *cp = (struct pciide_channel*)chp;
        struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	u_int8_t clr;

	/* The "clear" bits are in the wrong register *sigh* */
	clr = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(chp->channel));
	clr |= bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(chp->channel)) &
	    (IDEDMA_CTL_ERR | IDEDMA_CTL_INTR);
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CMD(chp->channel), clr);
a3148 1
	msk = pciide_pci_read(sc->sc_pc, sc->sc_tag, NATSEMI_CTRL2);
a3151 1

d3157 1
d3163 1
a3163 2
		    IDEDMA_CTL(i));

a3166 1

d3176 1
a3176 1
	return (rv);
d3245 1
a3245 1
	if (rev >= 0xC2)
d3249 12
d3384 1
a3384 1
		    IDEDMA_CTL(chp->channel), idedma_ctl);
d3442 1
a3442 5
               if ((sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
		   (revision == HPT370_REV || revision == HPT370A_REV ||
		    revision == HPT372_REV)) ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374)
d3461 1
a3461 2
	if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
	    revision == HPT366_REV) {
d3480 7
a3486 15
		if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374 ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A) 
			sc->sc_wdcdev.UDMA_cap = 6;
		else if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366) {
			if (revision == HPT372_REV)
				sc->sc_wdcdev.UDMA_cap = 6;
			else
				sc->sc_wdcdev.UDMA_cap = 5;
			if (revision == HPT370_REV) {
				/*
				 * XXX disable udma5 for now. 
				 */
				sc->sc_wdcdev.UDMA_cap = 4;
			}
		}
d3515 1
a3515 5
	if ((sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
	    (revision == HPT370_REV || revision == HPT370A_REV ||
	    revision == HPT372_REV)) ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374) {
d3517 2
a3518 2
		 * HPT370 and highter has a bit to disable interrupts,
		 * make sure to clear it
a3523 9
	/* set clocks, etc (mandatory on 372/4, optional otherwise) */
	if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374 ||
	    (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
	    revision == HPT372_REV))
		pciide_pci_write(sc->sc_pc, sc->sc_tag, HPT_SC2,
		    (pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT_SC2) &
		     HPT_SC2_MAEN) | HPT_SC2_OSC_EN);

d3563 1
a3563 3
			    ((sc->sc_wdcdev.UDMA_cap == 6) ?
			    hpt374_udma[drvp->UDMA_mode] :
			    hpt370_udma[drvp->UDMA_mode]) :
d3577 1
a3577 3
			    ((sc->sc_wdcdev.UDMA_cap == 6) ?
			    hpt374_dma[drvp->DMA_mode] :
			    hpt370_dma[drvp->DMA_mode]) :
d3583 1
a3583 3
			    ( (sc->sc_wdcdev.UDMA_cap == 6) ?
			    hpt374_pio[drvp->PIO_mode] :
			    hpt370_pio[drvp->PIO_mode]) :
d3595 1
a3595 1
		    IDEDMA_CTL(chp->channel), idedma_ctl);
d3612 2
a3613 2
		    IDEDMA_CTL(i));
		if((dmastat & (IDEDMA_CTL_ACT | IDEDMA_CTL_INTR)) !=
d3623 1
a3623 1
			    IDEDMA_CTL(i), dmastat);
d3634 2
a3635 1
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20267)
d3639 1
a3639 7
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268R ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20271  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20275  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277)
d3641 1
a3641 39
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20268R ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20271  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20275  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277)
#define PDC_IS_269(sc)							\
	((sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20269 ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20271  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20275  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20276  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277)

static __inline u_int8_t
pdc268_config_read(struct channel_softc *chp, int index)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;

	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_INDEX(channel), index);
	return (bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_DATA(channel)));
}

static __inline void
pdc268_config_write(struct channel_softc *chp, int index, u_int8_t value)
{
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;

	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_INDEX(channel), index);
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    PDC268_DATA(channel), value);
}
d3655 2
a3656 2
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: controller state 0x%x\n",
		    st), DEBUG_PROBE);
d3670 1
a3670 1
	if (PDC_IS_268(sc) || (st & PDC2xx_STATE_NATIVE))
d3685 1
a3685 3
	if (PDC_IS_269(sc))
		sc->sc_wdcdev.UDMA_cap = 6;
	else if (PDC_IS_265(sc))
d3691 1
a3691 2
	sc->sc_wdcdev.set_modes = PDC_IS_268(sc) ?
			pdc20268_setup_channel : pdc202xx_setup_channel;
a3695 24
	if (!PDC_IS_268(sc)) {
		/* setup failsafe defaults */
		mode = 0;
		mode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[0]);
		mode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[0]);
		mode = PDC2xx_TIM_SET_MB(mode, pdc2xx_dma_mb[0]);
		mode = PDC2xx_TIM_SET_MC(mode, pdc2xx_dma_mc[0]);
		for (channel = 0;
		     channel < sc->sc_wdcdev.nchannels;
		     channel++) {
			WDCDEBUG_PRINT(("pdc202xx_setup_chip: channel %d "
			    "drive 0 initial timings  0x%x, now 0x%x\n",
			    channel, pci_conf_read(sc->sc_pc, sc->sc_tag,
			    PDC2xx_TIM(channel, 0)), mode | PDC2xx_TIM_IORDYp),
			    DEBUG_PROBE);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PDC2xx_TIM(channel, 0), mode | PDC2xx_TIM_IORDYp);
			WDCDEBUG_PRINT(("pdc202xx_setup_chip: channel %d "
			    "drive 1 initial timings  0x%x, now 0x%x\n",
			    channel, pci_conf_read(sc->sc_pc, sc->sc_tag,
	 		    PDC2xx_TIM(channel, 1)), mode), DEBUG_PROBE);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PDC2xx_TIM(channel, 1), mode);
		}
d3697 31
a3727 30
		mode = PDC2xx_SCR_DMA;
		if (PDC_IS_262(sc)) {
			mode = PDC2xx_SCR_SET_GEN(mode, PDC262_SCR_GEN_LAT);
		} else {
			/* the BIOS set it up this way */
			mode = PDC2xx_SCR_SET_GEN(mode, 0x1);
		}
		mode = PDC2xx_SCR_SET_I2C(mode, 0x3); /* ditto */
		mode = PDC2xx_SCR_SET_POLL(mode, 0x1); /* ditto */
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: initial SCR  0x%x, "
		    "now 0x%x\n",
		    bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh,
			PDC2xx_SCR),
		    mode), DEBUG_PROBE);
		bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC2xx_SCR, mode);

		/* controller initial state register is OK even without BIOS */
		/* Set DMA mode to IDE DMA compatibility */
		mode =
		    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM);
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: primary mode 0x%x", mode),
		    DEBUG_PROBE);
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM,
		    mode | 0x1);
		mode =
		    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM);
		WDCDEBUG_PRINT((", secondary mode 0x%x\n", mode ), DEBUG_PROBE);
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM,
		    mode | 0x1);
d3729 6
d3736 13
d3777 2
a3778 5
		if (PDC_IS_268(sc))
			pdc20268_setup_channel(&cp->wdc_channel);
		else
			pdc202xx_setup_channel(&cp->wdc_channel);
	}
d3780 2
a3781 2
		WDCDEBUG_PRINT(("pdc202xx_setup_chip: new controller state "
		    "0x%x\n", st), DEBUG_PROBE);
d3802 3
d3869 1
d3903 1
a3903 1
		    IDEDMA_CTL(channel), idedma_ctl);
a3904 21
	pciide_print_modes(cp);
}

void
pdc20268_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	int drive, cable;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;

	/* check 80 pins cable */
	cable = pdc268_config_read(chp, 0x0b) & PDC268_CABLE;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;
d3906 1
a3906 26
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			if (cable && drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}
		} else if (drvp->drive_flags & DRIVE_DMA) {
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		}
	}
	/* nothing to do to setup modes, the controller snoop SET_FEATURE cmd */
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}
d3936 1
a3936 1
	}
a3956 11

		/*
		 * In case of shared IRQ check that the interrupt
		 * was actually generated by this channel.
		 */
		if (PDC_IS_268(sc)) {
			if ((pdc268_config_read(wdc_cp,
			    0x0b) & PDC268_INTR) == 0)
				continue;
		}

d3964 1
a3964 1
		    sc->sc_dma_ioh, IDEDMA_CTL(i));
d4088 1
a4088 1
			printf("%s: %s ignored (disabled)\n",
a4205 171
void
serverworks_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
{
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	pcitag_t pcib_tag;
	int channel;
	bus_size_t cmdsize, ctlsize;

	if (pciide_chipen(sc, pa) == 0)
		return;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_RCC_OSB4_IDE:
		sc->sc_wdcdev.UDMA_cap = 2;
		break;
	case PCI_PRODUCT_RCC_CSB5_IDE:
		if (PCI_REVISION(pa->pa_class) < 0x92)
			sc->sc_wdcdev.UDMA_cap = 4;
		else
			sc->sc_wdcdev.UDMA_cap = 5;
		break;
	case PCI_PRODUCT_RCC_CSB6_IDE:
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
	}

	sc->sc_wdcdev.set_modes = serverworks_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = 2;

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    serverworks_pci_intr);
		if (cp->hw_ok == 0)
			return;
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			return;
		serverworks_setup_channel(&cp->wdc_channel);
	}

	pcib_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, pa->pa_device, 0);
	pci_conf_write(pa->pa_pc, pcib_tag, 0x64,
	    (pci_conf_read(pa->pa_pc, pcib_tag, 0x64) & ~0x2000) | 0x4000);
}

void
serverworks_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	int drive, unit;
	u_int32_t pio_time, dma_time, pio_mode, udma_mode;
	u_int32_t idedma_ctl;
	static const u_int8_t pio_modes[5] = {0x5d, 0x47, 0x34, 0x22, 0x20};
	static const u_int8_t dma_modes[3] = {0x77, 0x21, 0x20};

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	pio_time = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x40);
	dma_time = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x44);
	pio_mode = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x48);
	udma_mode = pci_conf_read(sc->sc_pc, sc->sc_tag, 0x54);

	pio_time &= ~(0xffff << (16 * channel));
	dma_time &= ~(0xffff << (16 * channel));
	pio_mode &= ~(0xff << (8 * channel + 16));
	udma_mode &= ~(0xff << (8 * channel + 16));
	udma_mode &= ~(3 << (2 * channel));

	idedma_ctl = 0;

	/* Per drive settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		unit = drive + 2 * channel;
		/* add timing values, setup DMA if needed */
		pio_time |= pio_modes[drvp->PIO_mode] << (8 * (unit^1));
		pio_mode |= drvp->PIO_mode << (4 * unit + 16);
		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&
		    (drvp->drive_flags & DRIVE_UDMA)) {
			/* use Ultra/DMA, check for 80-pin cable */
			if (drvp->UDMA_mode > 2 &&
			    (PCI_PRODUCT(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_SUBSYS_ID_REG)) & (1 << (14 + channel))) == 0)
				drvp->UDMA_mode = 2;
			dma_time |= dma_modes[drvp->DMA_mode] << (8 * (unit^1));
			udma_mode |= drvp->UDMA_mode << (4 * unit + 16);
			udma_mode |= 1 << unit;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) &&
		    (drvp->drive_flags & DRIVE_DMA)) {
			/* use Multiword DMA */
			drvp->drive_flags &= ~DRIVE_UDMA;
			dma_time |= dma_modes[drvp->DMA_mode] << (8 * (unit^1));
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			/* PIO only */
			drvp->drive_flags &= ~(DRIVE_UDMA | DRIVE_DMA);
		}
	}

	pci_conf_write(sc->sc_pc, sc->sc_tag, 0x40, pio_time);
	pci_conf_write(sc->sc_pc, sc->sc_tag, 0x44, dma_time);
	if (sc->sc_pp->ide_product != PCI_PRODUCT_RCC_OSB4_IDE)
		pci_conf_write(sc->sc_pc, sc->sc_tag, 0x48, pio_mode);
	pci_conf_write(sc->sc_pc, sc->sc_tag, 0x54, udma_mode);

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

int
serverworks_pci_intr(arg)
	void *arg;
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int rv = 0;
	int dmastat, i, crv;

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(i));
		if ((dmastat & (IDEDMA_CTL_ACT | IDEDMA_CTL_INTR)) !=
		    IDEDMA_CTL_INTR)
			continue;
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;
		crv = wdcintr(wdc_cp);
		if (crv == 0) {
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
			bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
			    IDEDMA_CTL(i), dmastat);
		} else
			rv = 1;
	}
	return rv;
}

d4366 1
a4366 1
		    IDEDMA_CTL(channel), idedma_ctl);
d4392 1
a4392 1
		    IDEDMA_CTL(i));
d4400 1
a4400 1
			    IDEDMA_CTL(i), dmastat);
a4410 212
	}
	return rv;
}

void
nforce_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	bus_size_t cmdsize, ctlsize;
	u_int32_t conf;

	conf = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_CONF);
	WDCDEBUG_PRINT(("%s: conf register 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, conf), DEBUG_PROBE);

	if (pciide_chipen(sc, pa) == 0)
		return;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_NVIDIA_NFORCE_IDE:
		sc->sc_wdcdev.UDMA_cap = 5;
		break;
	case PCI_PRODUCT_NVIDIA_NFORCE2_IDE:
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
	default:
		sc->sc_wdcdev.UDMA_cap = 0;
	}
	sc->sc_wdcdev.set_modes = nforce_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];

		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;

		if ((conf & NFORCE_CHAN_EN(channel)) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			continue;
		}

		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    nforce_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		if (pciide_chan_candisable(cp)) {
			conf &= ~NFORCE_CHAN_EN(channel);
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}

		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
	WDCDEBUG_PRINT(("%s: new conf register 0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, conf), DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_CONF, conf);
}

void
nforce_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, mode;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	u_int32_t conf, piodmatim, piotim, udmatim;

	conf = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_CONF);
	piodmatim = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_PIODMATIM);
	piotim = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_PIOTIM);
	udmatim = pci_conf_read(sc->sc_pc, sc->sc_tag, NFORCE_UDMATIM);
	WDCDEBUG_PRINT(("%s: %s old timing values: piodmatim=0x%x, "
	    "piotim=0x%x, udmatim=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname,
	    cp->name, piodmatim, piotim, udmatim), DEBUG_PROBE);

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	/* Clear all bits for this channel */
	idedma_ctl = 0;
	piodmatim &= ~NFORCE_PIODMATIM_MASK(channel);
	udmatim &= ~NFORCE_UDMATIM_MASK(channel);

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			drvp->drive_flags &= ~DRIVE_DMA;

			/* Check cable */
			if ((conf & NFORCE_CONF_CABLE(channel, drive)) == 0 &&
			    drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}

			udmatim |= NFORCE_UDMATIM_SET(channel, drive,
			    nforce_udma[drvp->UDMA_mode]) |
			    NFORCE_UDMA_EN(channel, drive) |
			    NFORCE_UDMA_ENM(channel, drive);

			mode = drvp->PIO_mode;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			goto pio;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:
		/* Setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
			mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}
		piodmatim |= NFORCE_PIODMATIM_SET(channel, drive,
		    nforce_pio[mode]);
	}

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}

	WDCDEBUG_PRINT(("%s: %s new timing values: piodmatim=0x%x, "
	    "piotim=0x%x, udmatim=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname,
	    cp->name, piodmatim, piotim, udmatim), DEBUG_PROBE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_PIODMATIM, piodmatim);
	pci_conf_write(sc->sc_pc, sc->sc_tag, NFORCE_UDMATIM, udmatim);

	pciide_print_modes(cp);
}

int
nforce_pci_intr(void *arg)
{
	struct pciide_softc *sc = arg;
	struct pciide_channel *cp;
	struct channel_softc *wdc_cp;
	int i, rv, crv; 
	u_int32_t dmastat;

	rv = 0;
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		wdc_cp = &cp->wdc_channel;

		/* Skip compat channel */
		if (cp->compat)
			continue;

		dmastat = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(i));
		if ((dmastat & IDEDMA_CTL_INTR) == 0)
			continue;

		crv = wdcintr(wdc_cp);
		if (crv == 0)
			printf("%s:%d: bogus intr\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, i);
		else
			rv = 1;
@


1.20.2.9
log
@A sweep to fix remaining files not in sync with the SMP_SYNC_B point.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.117 2003/03/06 11:49:20 grange Exp $	*/
@


1.20.2.10
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.20.2.9 2003/04/19 19:17:49 niklas Exp $	*/
a169 3
	/* For SiS */
	u_int8_t sis_type;

a224 3
void sis96x_setup_channel(struct channel_softc *);
int  sis_hostbr_match(struct pci_attach_args *);
int  sis_south_match(struct pci_attach_args *);
a499 4
	},
	{ PCI_PRODUCT_PROMISE_PDC20376,	/* PDC20376 SATA */
	  IDE_PCI_CLASS_OVERRIDE,	/* XXX: subclass RAID */
	  pdc202xx_chip_map,
d710 1
a710 2
		pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo,
		    sizeof devinfo);
d716 4
a719 2
	WDCDEBUG_PRINT((" sc_pc=%p, sc_tag=%p, pa_class=0x%x\n", sc->sc_pc,
	    sc->sc_tag, pa->pa_class), DEBUG_PROBE);
a3195 86
static struct sis_hostbr_type {
	u_int16_t id;
	u_int8_t rev;
	u_int8_t udma_mode;
	char *name;
	u_int8_t type;
#define SIS_TYPE_NOUDMA	0
#define SIS_TYPE_66	1
#define SIS_TYPE_100OLD	2
#define SIS_TYPE_100NEW 3
#define SIS_TYPE_133OLD 4
#define SIS_TYPE_133NEW 5
#define SIS_TYPE_SOUTH	6
} sis_hostbr_type[] = {
	/* Most infos here are from sos@@freebsd.org */
	{PCI_PRODUCT_SIS_530, 0x00, 4, "530", SIS_TYPE_66},
#if 0
	/*
	 * controllers associated to a rev 0x2 530 Host to PCI Bridge
	 * have problems with UDMA (info provided by Christos)
	 */
	{PCI_PRODUCT_SIS_530, 0x02, 0, "530 (buggy)", SIS_TYPE_NOUDMA},
#endif
	{PCI_PRODUCT_SIS_540, 0x00, 4, "540", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_550, 0x00, 4, "550", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_620, 0x00, 4, "620", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_630, 0x00, 4, "630", SIS_TYPE_66},
	{PCI_PRODUCT_SIS_630, 0x30, 5, "630S", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_633, 0x00, 5, "633", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_635, 0x00, 5, "635", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_640, 0x00, 4, "640", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_645, 0x00, 6, "645", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_646, 0x00, 6, "645DX", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_648, 0x00, 6, "648", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_650, 0x00, 6, "650", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_651, 0x00, 6, "651", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_652, 0x00, 6, "652", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_655, 0x00, 6, "655", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_658, 0x00, 6, "658", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_730, 0x00, 5, "730", SIS_TYPE_100OLD},
	{PCI_PRODUCT_SIS_733, 0x00, 5, "733", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_735, 0x00, 5, "735", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_740, 0x00, 5, "740", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_745, 0x00, 5, "745", SIS_TYPE_100NEW},
	{PCI_PRODUCT_SIS_746, 0x00, 6, "746", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_748, 0x00, 6, "748", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_750, 0x00, 6, "750", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_751, 0x00, 6, "751", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_752, 0x00, 6, "752", SIS_TYPE_SOUTH},
	{PCI_PRODUCT_SIS_755, 0x00, 6, "755", SIS_TYPE_SOUTH},
	/*
	 * From sos@@freebsd.org: the 0x961 ID will never be found in real world
	 * {PCI_PRODUCT_SIS_961, 0x00, 6, "961", SIS_TYPE_133NEW},
	 */
	{PCI_PRODUCT_SIS_962, 0x00, 6, "962", SIS_TYPE_133NEW},
	{PCI_PRODUCT_SIS_963, 0x00, 6, "963", SIS_TYPE_133NEW}
};

static struct sis_hostbr_type *sis_hostbr_type_match;

int
sis_hostbr_match(struct pci_attach_args *pa)
{
	int i;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_SIS)
		return (0);
	sis_hostbr_type_match = NULL;
	for (i = 0;
	    i < sizeof(sis_hostbr_type) / sizeof(sis_hostbr_type[0]);
	    i++) {
		if (PCI_PRODUCT(pa->pa_id) == sis_hostbr_type[i].id &&
		    PCI_REVISION(pa->pa_class) >= sis_hostbr_type[i].rev)
			sis_hostbr_type_match = &sis_hostbr_type[i];
	}
	return (sis_hostbr_type_match != NULL);
}

int
sis_south_match(struct pci_attach_args *pa)
{
	return(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SIS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SIS_85C503 &&
	    PCI_REVISION(pa->pa_class) >= 0x10);
}

d3207 2
a3208 2
	pcitag_t br_tag;
	struct pci_attach_args br_pa;
a3212 57
	/* Find PCI bridge (dev 0 func 0 on the same bus) */
	br_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, 0, 0);
	br_pa.pa_id = pci_conf_read(sc->sc_pc, br_tag, PCI_ID_REG);
	br_pa.pa_class = pci_conf_read(sc->sc_pc, br_tag, PCI_CLASS_REG);
	WDCDEBUG_PRINT(("%s: PCI bridge pa_id=0x%x pa_class=0x%x\n",
	    __func__, br_pa.pa_id, br_pa.pa_class), DEBUG_PROBE);

	if (sis_hostbr_match(&br_pa)) {
		if (sis_hostbr_type_match->type == SIS_TYPE_SOUTH) {
			pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_57,
			    pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    SIS_REG_57) & 0x7f);
			if (PCI_PRODUCT(pci_conf_read(sc->sc_pc, sc->sc_tag,
			    PCI_ID_REG)) == SIS_PRODUCT_5518) {
				sc->sis_type = SIS_TYPE_133NEW;
				sc->sc_wdcdev.UDMA_cap =
				    sis_hostbr_type_match->udma_mode;
			} else {
				/* Find ISA bridge (func 0 of the same dev) */
				br_tag = pci_make_tag(pa->pa_pc, pa->pa_bus,
				    pa->pa_device, 0);
				br_pa.pa_id = pci_conf_read(sc->sc_pc,
				    br_tag, PCI_ID_REG);
				br_pa.pa_class = pci_conf_read(sc->sc_pc,
				    br_tag, PCI_CLASS_REG);
				WDCDEBUG_PRINT(("%s: ISA bridge "
				    "pa_id=0x%x pa_class=0x%x\n",
				    __func__, br_pa.pa_id, br_pa.pa_class),
				    DEBUG_PROBE);

				if (sis_south_match(&br_pa)) {
					sc->sis_type = SIS_TYPE_133OLD;
					sc->sc_wdcdev.UDMA_cap =
					    sis_hostbr_type_match->udma_mode;
				} else {
					sc->sis_type = SIS_TYPE_100NEW;
					sc->sc_wdcdev.UDMA_cap =
					    sis_hostbr_type_match->udma_mode;
				}
			}
		} else {
			sc->sis_type = sis_hostbr_type_match->type;
			sc->sc_wdcdev.UDMA_cap =
			    sis_hostbr_type_match->udma_mode;
		}
		printf(": %s", sis_hostbr_type_match->name);
	} else {
		printf(": 5597/5598");
		if (rev >= 0xd0) {
			sc->sc_wdcdev.UDMA_cap = 2;
			sc->sis_type = SIS_TYPE_66;
		} else {
			sc->sc_wdcdev.UDMA_cap = 0;
			sc->sis_type = SIS_TYPE_NOUDMA;
		}
	}

d3216 6
d3227 8
a3234 1
		if (sc->sis_type >= SIS_TYPE_66)
d3240 3
a3245 23
	switch (sc->sis_type) {
	case SIS_TYPE_NOUDMA:
	case SIS_TYPE_66:
	case SIS_TYPE_100OLD:
		sc->sc_wdcdev.set_modes = sis_setup_channel;
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_MISC,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_MISC) |
		    SIS_MISC_TIM_SEL | SIS_MISC_FIFO_SIZE | SIS_MISC_GTC);
		break;
	case SIS_TYPE_100NEW:
	case SIS_TYPE_133OLD:
		sc->sc_wdcdev.set_modes = sis_setup_channel;
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_49,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_49) | 0x01);
		break;
	case SIS_TYPE_133NEW:
		sc->sc_wdcdev.set_modes = sis96x_setup_channel;
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_50,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_50) & 0xf7);
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_REG_52,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_52) & 0xf7);
		break;
	}
d3249 4
d3258 1
a3258 1
		    (channel == 1 && (sis_ctr0 & SIS_CTRL0_CHAN1_EN) == 0)) {
d3284 1
a3284 1
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
a3288 65
sis96x_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t sis_tim;
	u_int32_t idedma_ctl;
	int regtim;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	sis_tim = 0;
	idedma_ctl = 0;
	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	for (drive = 0; drive < 2; drive++) {
		regtim = SIS_TIM133(
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_REG_57),
		    chp->channel, drive);
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		/* add timing values, setup DMA if needed */
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			if (pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    SIS96x_REG_CBL(chp->channel)) & SIS96x_REG_CBL_33) {
				if (drvp->UDMA_mode > 2)
					drvp->UDMA_mode = 2;
			}
			sis_tim |= sis_udma133new_tim[drvp->UDMA_mode];
			sis_tim |= sis_pio133new_tim[drvp->PIO_mode];
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			/*
			 * use Multiword DMA
			 * Timings will be used for both PIO and DMA,
			 * so adjust DMA mode if needed
			 */
			if (drvp->PIO_mode > (drvp->DMA_mode + 2))
				drvp->PIO_mode = drvp->DMA_mode + 2;
			if (drvp->DMA_mode + 2 > (drvp->PIO_mode))
				drvp->DMA_mode = (drvp->PIO_mode > 2) ?
				    drvp->PIO_mode - 2 : 0;
			sis_tim |= sis_dma133new_tim[drvp->DMA_mode];
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else {
			sis_tim |= sis_pio133new_tim[drvp->PIO_mode];
		}
		WDCDEBUG_PRINT(("sis96x_setup_channel: new timings reg for "
		    "channel %d drive %d: 0x%x (reg 0x%x)\n",
		    chp->channel, drive, sis_tim, regtim), DEBUG_PROBE);
		pci_conf_write(sc->sc_pc, sc->sc_tag, regtim, sis_tim);
	}
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

void
d3321 3
a3323 24
			if (pciide_pci_read(sc->sc_pc, sc->sc_tag,
			    SIS_REG_CBL) & SIS_REG_CBL_33(chp->channel)) {
				if (drvp->UDMA_mode > 2)
					drvp->UDMA_mode = 2;
			}
			switch (sc->sis_type) {
			case SIS_TYPE_66:
			case SIS_TYPE_100OLD:
				sis_tim |= sis_udma66_tim[drvp->UDMA_mode] << 
				    SIS_TIM66_UDMA_TIME_OFF(drive);
				break;
			case SIS_TYPE_100NEW:
				sis_tim |=
				    sis_udma100new_tim[drvp->UDMA_mode] << 
				    SIS_TIM100_UDMA_TIME_OFF(drive);
			case SIS_TYPE_133OLD:
				sis_tim |=
				    sis_udma133old_tim[drvp->UDMA_mode] << 
				    SIS_TIM100_UDMA_TIME_OFF(drive);
				break;
			default:
				printf("unknown SiS IDE type %d\n",
				    sc->sis_type);
			}
d3339 4
a3342 20
pio:		switch (sc->sis_type) {
		case SIS_TYPE_NOUDMA:
		case SIS_TYPE_66:
		case SIS_TYPE_100OLD:
			sis_tim |= sis_pio_act[drvp->PIO_mode] <<
			    SIS_TIM66_ACT_OFF(drive);
			sis_tim |= sis_pio_rec[drvp->PIO_mode] <<
			    SIS_TIM66_REC_OFF(drive);
			break;
		case SIS_TYPE_100NEW:
		case SIS_TYPE_133OLD:
			sis_tim |= sis_pio_act[drvp->PIO_mode] <<
			    SIS_TIM100_ACT_OFF(drive);
			sis_tim |= sis_pio_rec[drvp->PIO_mode] <<
			    SIS_TIM100_REC_OFF(drive);
			break;
		default:
			printf("unknown SiS IDE type %d\n",
			    sc->sis_type);
		}
d4038 1
a4038 2
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)
d4046 1
a4046 2
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)
d4052 1
a4052 2
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20277  ||	\
	(sc)->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)
a4449 1
		 * Only check the channel that is enabled.
d4451 1
a4451 1
		if (cp->hw_ok && PDC_IS_268(sc)) {
@


1.20.2.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pciide.c,v 1.20.2.10 2003/05/13 19:35:08 ho Exp $	*/
d25 1
a25 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
a108 1
#include <dev/pci/pciide_sii3112_reg.h>
a165 7
	/*
	 * Some controllers might have DMA restrictions other than
	 * the norm.
	 */
	bus_size_t		sc_dma_maxsegsz;
	bus_size_t		sc_dma_boundary;

a222 3
void sii3112_chip_map(struct pciide_softc*, struct pci_attach_args*);
void sii3112_setup_channel(struct channel_softc*);

d265 1
a265 1

a341 8
	{ PCI_PRODUCT_INTEL_82801DBM_IDE, /* Intel 82801DBM IDE (ICH4-M) */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801EB_IDE, /* Intel 82801EB/82801ER IDE */
	  0,				 /* (ICH5/ICH5R)	      */
	  piix_chip_map
	},
a404 4
	},
	{ PCI_PRODUCT_CMDTECH_3112,	/* SiI 3112 SATA */
	  IDE_PCI_CLASS_OVERRIDE,	/* XXX: subclass RAID */
	  sii3112_chip_map
d616 1
a616 1
int	pciide_mapregs_native(struct pci_attach_args *,
a726 4
	/* Set up DMA defaults; these might be adjusted by chip_map. */
	sc->sc_dma_maxsegsz = IDEDMA_BYTE_COUNT_MAX;
	sc->sc_dma_boundary = IDEDMA_BYTE_COUNT_ALIGN;

d951 1
a951 1
pciide_intr_flag(struct pciide_channel *cp)
d961 1
a961 1
			status = bus_space_read_1(sc->sc_dma_iot,
d1123 1
a1123 1
	    NIDEDMA_TABLES, sc->sc_dma_maxsegsz, sc->sc_dma_boundary,
d1193 1
a1193 1
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_table, 0,
d1265 1
a1265 1
	bus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, 0,
d1298 1
a1298 1
	struct channel_softc *chp;
d1300 2
a1301 2
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
d1303 5
a1307 5
	/* clear status bits in IDE DMA registers */
	bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
	    IDEDMA_CTL(chp->channel),
	    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		IDEDMA_CTL(chp->channel)));
d1433 1
a1433 1
		    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?
a1619 2
		case PCI_PRODUCT_INTEL_82801DBM_IDE:
		case PCI_PRODUCT_INTEL_82801EB_IDE:
a1634 2
	case PCI_PRODUCT_INTEL_82801DBM_IDE:
	case PCI_PRODUCT_INTEL_82801EB_IDE:
d1668 1
a1668 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE) {
d1728 1
a1728 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE) {
d1821 1
a1821 1
	else
d1892 1
a1892 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE) {
d1899 1
a1899 3
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DB_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801DBM_IDE ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_IDE) {
d1986 1
a1986 1
		    PIIX_IDETIM_ISP_SET(piix_isp_dma[mode]) |
d1989 1
a1989 1
	else
d1991 1
a1991 1
		    PIIX_IDETIM_ISP_SET(piix_isp_pio[mode]) |
d2062 1
a2062 1
	else
d2087 2
a2088 2
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;		
d2210 1
a2210 1
			 * triggered.
d2328 1
a2328 1
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
d2417 1
a2417 1
		if (chp->ch_drive[0].UDMA_mode > 2 &&
d2582 1
a2582 1
	int i, rv, crv;
d2702 10
a2711 10
		case PCI_PRODUCT_CMDTECH_646:
			if (rev >= CMD0646U2_REV) {
				sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
				sc->sc_wdcdev.UDMA_cap = 2;
			} else if (rev >= CMD0646U_REV) {
			/*
			 * Linux's driver claims that the 646U is broken
			 * with UDMA. Only enable it if we know what we're
			 * doing
			 */
d2713 2
a2714 2
				sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
				sc->sc_wdcdev.UDMA_cap = 2;
d2716 8
a2723 8
				/* explicitly disable UDMA */
				pciide_pci_write(sc->sc_pc, sc->sc_tag,
				    CMD_UDMATIM(0), 0);
				pciide_pci_write(sc->sc_pc, sc->sc_tag,
				    CMD_UDMATIM(1), 0);
			}
			sc->sc_wdcdev.irqack = cmd646_9_irqack;
			break;
d2790 1
a2790 6
				    CMD_BICSR_80(chp->channel)) == 0) {
					WDCDEBUG_PRINT(("%s(%s:%d:%d): "
					    "80-wire cable not detected\n",
					    drvp->drive_name,
					    sc->sc_wdcdev.sc_dev.dv_xname,
					    chp->channel, drive), DEBUG_PROBE);
a2791 1
				}
d2794 1
a2794 1
				else if (sc->sc_wdcdev.UDMA_cap > 2)
d2852 1
a2852 1
	struct channel_softc *chp;
d2854 12
a2865 12
	u_int32_t priirq, secirq;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	if (chp->channel == 0) {
		priirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CONF);
		pciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_CONF, priirq);
	} else {
		secirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23);
		pciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23, secirq);
	}
	pciide_irqack(chp);
a3044 114
sii3112_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	bus_size_t cmdsize, ctlsize;
	pcireg_t interface;
	int channel;

	if (pciide_chipen(sc, pa) == 0)
		return;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	/*
	 * Rev. <= 0x01 of the 3112 have a bug that can cause data
	 * corruption if DMA transfers cross an 8K boundary.  This is
	 * apparently hard to tickle, but we'll go ahead and play it
	 * safe.
	 */
	if (PCI_REVISION(pa->pa_class) <= 0x01) {
		sc->sc_dma_maxsegsz = 8192;
		sc->sc_dma_boundary = 8192;
	}

	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	sc->sc_wdcdev.PIO_cap = 4;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		sc->sc_wdcdev.DMA_cap = 2;
		sc->sc_wdcdev.UDMA_cap = 6;
	}
	sc->sc_wdcdev.set_modes = sii3112_setup_channel;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	/*
	 * The 3112 can be told to identify as a RAID controller.
	 * In this case, we have to fake interface
	 */
	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_IDE) {
		interface = PCI_INTERFACE(pa->pa_class);
	} else {
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);
	}

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0)
			continue;
		pciide_map_compat_intr(pa, cp, channel, interface);
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}
}

void
sii3112_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t idedma_ctl, dtm;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc*)cp->wdc_channel.wdc;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;
	dtm = 0;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			dtm |= DTM_IDEx_DMA;
		} else if (drvp->drive_flags & DRIVE_DMA) {
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			dtm |= DTM_IDEx_DMA;
		} else {
			dtm |= DTM_IDEx_PIO;
		}
	}

	/*
	 * Nothing to do to setup modes; it is meaningless in S-ATA
	 * (but many S-ATA drives still want to get the SET_FEATURE
	 * command).
	 */
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
	pci_conf_write(sc->sc_pc, sc->sc_tag,
	    chp->channel == 0 ? SII3112_DTM_IDE0 : SII3112_DTM_IDE1, dtm);
	pciide_print_modes(cp);
}

void
d3048 1
a3048 1
{
d3132 1
a3132 1
		pciide_unmap_compat_intr(pa, cp, sc->sc_cy_compatchan,
d3136 1
a3136 1

d3520 1
a3520 1
	    "channel %d 0x%x\n", chp->channel,
d3549 1
a3549 1
				sis_tim |= sis_udma66_tim[drvp->UDMA_mode] <<
d3554 1
a3554 1
				    sis_udma100new_tim[drvp->UDMA_mode] <<
d3558 1
a3558 1
				    sis_udma133old_tim[drvp->UDMA_mode] <<
d3750 1
a3750 1
	struct channel_softc *chp;
d3752 2
a3753 2
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
d3925 1
a3925 1
	WDCDEBUG_PRINT(("acer_setup_channel: old fifo/udma reg 0x%x\n",
a3933 3
			WDCDEBUG_PRINT(("%s:%d: 80-wire cable not detected\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, chp->channel),
			    DEBUG_PROBE);
d3968 1
a3968 1
			acer_fifo_udma |=
d3976 1
a3976 1
				    ACER_0x4B) | ACER_0x4B_UDMA66);
d4015 1
a4015 1
	int i, rv, crv;
d4052 1
a4052 1
	/*
d4061 1
a4061 1
		if ((sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT366 &&
d4105 1
a4105 1
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A)
d4114 1
a4114 1
				 * XXX disable udma5 for now.
d4205 1
a4205 5
			    drvp->UDMA_mode > 2) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    chp->channel, drive), DEBUG_PROBE);
a4206 1
			}
d4268 1
a4268 1
		wdc_cp = &cp->wdc_channel;
a4519 14
		/* Check cable */
		if ((st & PDC262_STATE_80P(channel)) != 0 &&
		    ((chp->ch_drive[0].drive_flags & DRIVE_UDMA &&
		    chp->ch_drive[0].UDMA_mode > 2) ||
		    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&
		    chp->ch_drive[1].UDMA_mode > 2))) {
			WDCDEBUG_PRINT(("%s:%d: 80-wire cable not detected\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, channel),
			    DEBUG_PROBE);
			if (chp->ch_drive[0].UDMA_mode > 2)
				chp->ch_drive[0].UDMA_mode = 2;
			if (chp->ch_drive[1].UDMA_mode > 2)
				chp->ch_drive[1].UDMA_mode = 2;
		}
d4521 2
a4522 1
		if ((chp->ch_drive[0].drive_flags & DRIVE_UDMA &&
d4598 1
a4598 1
		    sc->sc_wdcdev.sc_dev.dv_xname,
d4666 1
a4666 1
	int i, rv, crv;
d4696 1
a4696 1
	int i, rv, crv;
d4841 1
a4841 1
	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);
d5076 1
a5076 7
			    (PCI_PRODUCT(pci_conf_read(sc->sc_pc, sc->sc_tag,
			    PCI_SUBSYS_ID_REG)) &
			    (1 << (14 + channel))) == 0) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): 80-wire "
				    "cable not detected\n", drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive), DEBUG_PROBE);
a5077 1
			}
d5155 1
a5155 1
	/*
d5532 1
a5532 1
	int i, rv, crv;
@


1.20.2.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 1
a83 4
#ifndef WDCDEBUG_PCIIDE_MASK
#define WDCDEBUG_PCIIDE_MASK 0x00
#endif
int wdcdebug_pciide_mask = WDCDEBUG_PCIIDE_MASK;
d96 2
a118 2
#include <dev/pci/pciide_i31244_reg.h>
#include <dev/pci/pciide_ite_reg.h>
a182 2
	/* Chip revision */
	int sc_rev;
d204 1
a204 1
void default_chip_map(struct pciide_softc *, struct pci_attach_args *);
d206 3
a208 5
void sata_setup_channel(struct channel_softc *);

void piix_chip_map(struct pciide_softc *, struct pci_attach_args *);
void piix_setup_channel(struct channel_softc *);
void piix3_4_setup_channel(struct channel_softc *);
d211 1
a211 1
static u_int32_t piix_setup_idetim_drvs(struct ata_drive_datas *);
d214 5
a218 2
void amd756_chip_map(struct pciide_softc *, struct pci_attach_args *);
void amd756_setup_channel(struct channel_softc *);
d220 5
a224 9
void apollo_chip_map(struct pciide_softc *, struct pci_attach_args *);
void apollo_sata_chip_map(struct pciide_softc *, struct pci_attach_args *);
void apollo_setup_channel(struct channel_softc *);

void cmd_chip_map(struct pciide_softc *, struct pci_attach_args *);
void cmd0643_9_chip_map(struct pciide_softc *, struct pci_attach_args *);
void cmd0643_9_setup_channel(struct channel_softc *);
void cmd680_chip_map(struct pciide_softc *, struct pci_attach_args *);
void cmd680_setup_channel(struct channel_softc *);
d231 2
a232 2
void sii3112_chip_map(struct pciide_softc *, struct pci_attach_args *);
void sii3112_setup_channel(struct channel_softc *);
d234 2
a235 2
void cy693_chip_map(struct pciide_softc *, struct pci_attach_args *);
void cy693_setup_channel(struct channel_softc *);
d237 2
a238 2
void sis_chip_map(struct pciide_softc *, struct pci_attach_args *);
void sis_setup_channel(struct channel_softc *);
d243 2
a244 2
void natsemi_chip_map(struct pciide_softc *, struct pci_attach_args *);
void natsemi_setup_channel(struct channel_softc *);
a246 2
void ns_scx200_chip_map(struct pciide_softc *, struct pci_attach_args *);
void ns_scx200_setup_channel(struct channel_softc *);
d248 2
a249 2
void acer_chip_map(struct pciide_softc *, struct pci_attach_args *);
void acer_setup_channel(struct channel_softc *);
d252 3
a254 3
void pdc202xx_chip_map(struct pciide_softc *, struct pci_attach_args *);
void pdc202xx_setup_channel(struct channel_softc *);
void pdc20268_setup_channel(struct channel_softc *);
a256 2
void pdc20262_dma_start(void *, int, int);
int  pdc20262_dma_finish(void *, int, int, int);
d258 2
a259 2
void opti_chip_map(struct pciide_softc *, struct pci_attach_args *);
void opti_setup_channel(struct channel_softc *);
d261 2
a262 2
void hpt_chip_map(struct pciide_softc *, struct pci_attach_args *);
void hpt_setup_channel(struct channel_softc *);
d265 2
a266 2
void acard_chip_map(struct pciide_softc *, struct pci_attach_args *);
void acard_setup_channel(struct channel_softc *);
d269 2
a270 2
void serverworks_chip_map(struct pciide_softc *, struct pci_attach_args *);
void serverworks_setup_channel(struct channel_softc *);
a276 5
void artisea_chip_map(struct pciide_softc *, struct pci_attach_args *);

void ite_chip_map(struct pciide_softc *, struct pci_attach_args *);
void ite_setup_channel(struct channel_softc *);

d278 1
a278 1
int  pciide_dma_table_setup(struct pciide_softc *, int, int);
d281 1
a281 1
int  pciide_dma_finish(void *, int, int, int);
d290 1
a290 1
	void (*chip_map)(struct pciide_softc *, struct pci_attach_args *);
d357 2
a358 10
	{ PCI_PRODUCT_INTEL_82801EB_IDE, /* Intel 82801EB/ER (ICH5/5R) IDE */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801EB_SATA, /* Intel 82801EB (ICH5) SATA */
	  0,
	  piix_chip_map
	},
	{ PCI_PRODUCT_INTEL_82801ER_SATA, /* Intel 82801ER (ICH5R) SATA */
	  0,
a360 6
#ifdef notyet
	{ PCI_PRODUCT_INTEL_31244,	 /* Intel 31244 SATA */
	  0,
	  artisea_chip_map
	}
#endif
a438 4
	},
	{ PCI_PRODUCT_VIATECH_VT8237_SATA, /* VIA VT8237 SATA */
	  IDE_PCI_CLASS_OVERRIDE,
	  apollo_sata_chip_map
a459 4
	},
	{ PCI_PRODUCT_NS_SCx200_IDE,	/* National Semi SCx200 IDE */
	  0,
	  ns_scx200_chip_map
a478 8
	{ PCI_PRODUCT_TRIONES_HPT302,	/* Highpoint HPT302 IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map
	},
	{ PCI_PRODUCT_TRIONES_HPT371,	/* Highpoint HPT371 IDE */
	  IDE_PCI_CLASS_OVERRIDE,
	  hpt_chip_map
	},
a547 8
	},
	{ PCI_PRODUCT_ACARD_ATP865A,	/* Acard ATP865-A Ultra133 Controller */
	  IDE_PCI_CLASS_OVERRIDE,
	  acard_chip_map,
	},
	{ PCI_PRODUCT_ACARD_ATP865R,	/* Acard ATP865-R Ultra133 Controller */
	  IDE_PCI_CLASS_OVERRIDE,
	  acard_chip_map,
a563 4
	{ PCI_PRODUCT_RCC_CSB6_IDE2,
	  0,
	  serverworks_chip_map,
	}
a576 7
const struct pciide_product_desc pciide_ite_products[] = {
	{ PCI_PRODUCT_ITEXPRESS_IT8212F,
	  IDE_PCI_CLASS_OVERRIDE,
	  ite_chip_map
	}
};

d614 1
a614 3
	  sizeof(pciide_nvidia_products)/sizeof(pciide_nvidia_products[0]) },
	{ PCI_VENDOR_ITEXPRESS, pciide_ite_products,
	  sizeof(pciide_ite_products)/sizeof(pciide_ite_products[0]) }
d638 1
a638 1
	    struct pciide_channel *, int, bus_size_t *, bus_size_t *);
d657 1
a657 1
const struct pciide_product_desc *pciide_lookup_product(u_int32_t);
a745 1
	sc->sc_rev = PCI_REVISION(pa->pa_class);
d844 1
a844 1
		}
a849 7
#ifdef __pegasos__
		/* stupid broken board */
		if (intrhandle == 0xe)
			pci_intr_establish(pa->pa_pc,
			    0xf, IPL_BIO, pci_intr, sc,
			    sc->sc_wdcdev.sc_dev.dv_xname);
#endif
d996 1
a996 1

d1188 1
a1188 1
	    dma_maps->dmamap_xfer->dm_mapsize,
d1268 1
a1268 1
pciide_dma_finish(v, channel, drive, force)
a1270 1
	int force;
a1284 3
	if (force == 0 && (status & IDEDMA_CTL_INTR) == 0)
		return WDC_DMAST_NOIRQ;

d1327 1
a1327 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
a1615 41
sata_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;

	/* setup DMA if needed */
	pciide_channel_dma_setup(cp);

	idedma_ctl = 0;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (drvp->drive_flags & DRIVE_UDMA) {
			/* use Ultra/DMA */
			drvp->drive_flags &= ~DRIVE_DMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
		}
	}

	/*
	 * Nothing to do to setup modes; it is meaningless in S-ATA
	 * (but many S-ATA drives still want to get the SET_FEATURE
	 * command).
	 */
	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(chp->channel), idedma_ctl);
	}
	pciide_print_modes(cp);
}

void
a1648 2
		case PCI_PRODUCT_INTEL_82801EB_SATA:
		case PCI_PRODUCT_INTEL_82801ER_SATA:
a1665 2
	case PCI_PRODUCT_INTEL_82801EB_SATA:
	case PCI_PRODUCT_INTEL_82801ER_SATA:
d1672 1
a1672 5
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_SATA;
		sc->sc_wdcdev.set_modes = sata_setup_channel;
	} else if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371FB_IDE) {
d1674 1
a1674 1
	} else {
a1675 1
	}
a1680 4
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA)
		goto chansetup;

a1709 1
chansetup:
a1711 14

		/* SATA setup */
		if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA) {
			if (pciide_chansetup(sc, channel, interface) == 0)
				continue;
			pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
			    pciide_pci_intr);
			if (cp->hw_ok == 0)
				continue;
			sc->sc_wdcdev.set_modes(&cp->wdc_channel);
			continue;
		}

a1742 4
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801EB_SATA ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801ER_SATA)
		return;

d1778 1
a1778 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d1887 1
a1887 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d1988 1
a1988 1

d2022 1
a2022 1

d2127 1
a2127 1
		sc->sc_wdcdev.irqack = pciide_irqack;
d2188 1
a2188 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d2192 4
a2195 2
	int product = sc->sc_pp->ide_product;
	int rev = sc->sc_rev;
d2313 2
a2314 2
	pcib_class = pci_conf_read(sc->sc_pc, pcib_tag, PCI_CLASS_REG);

a2359 4
	case PCI_PRODUCT_VIATECH_VT8237_SATA:
		printf(": ATA133");
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
d2382 1
a2382 1

a2429 46
apollo_sata_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
	int channel;
	bus_size_t cmdsize, ctlsize;

	if (pciide_chipen(sc, pa) == 0)
		return;

	if (interface == 0) {
		WDCDEBUG_PRINT(("apollo_sata_chip_map interface == 0\n"),
		    DEBUG_PROBE);
		interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
		    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);
	}

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	printf("\n");

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA |
		    WDC_CAPABILITY_DMA | WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 6;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_SATA;
	sc->sc_wdcdev.set_modes = sata_setup_channel;

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		     pciide_pci_intr);
	}
}

void
d2437 1
a2437 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d2495 1
a2495 1
				    drive, apollo_udma66_tim[drvp->UDMA_mode]);
a2549 1
	int one_channel;
d2571 1
a2571 13
	/*
	 * Older CMD64X doesn't have independant channels
	 */
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_CMDTECH_649:
		one_channel = 0;
		break;
	default:
		one_channel = 1;
		break;
	}

	if (channel > 0 && one_channel) {
d2657 1
a2657 1
	 * and base address registers can be disabled at
d2691 2
a2692 1
	int rev = sc->sc_rev;
d2712 1
a2712 1
	 * and base address registers can be disabled at
d2806 1
a2806 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d2900 1
a2900 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d3018 1
a3018 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d3109 1
a3109 1
	if (sc->sc_rev <= 0x01) {
d3115 1
a3115 1
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_SATA;
d3161 2
a3162 2
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
d3311 1
a3311 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d3459 1
a3459 1
	int rev = sc->sc_rev;
d3479 2
a3480 1
			if (sc->sc_pp->ide_product == SIS_PRODUCT_5518) {
d3610 1
a3610 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d3675 1
a3675 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d3848 1
a3848 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d3911 1
a3911 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d3970 3
a3972 1
ns_scx200_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
d3976 1
a3976 1
	pcireg_t interface = PCI_INTERFACE(pa->pa_class);
d3978 1
a3984 1

d3987 4
d3992 10
a4001 1
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
d4005 1
d4008 1
a4008 3
	sc->sc_wdcdev.UDMA_cap = 2;

	sc->sc_wdcdev.set_modes = ns_scx200_setup_channel;
d4012 19
a4030 14
	/*
	 * Soekris net4801 errata 0003:
	 *
	 * The SC1100 built in busmaster IDE controller is pretty standard,
	 * but have two bugs: data transfers need to be dword aligned and
	 * it cannot do an exact 64Kbyte data transfer.
	 *
	 * Assume that reducing maximum segment size by one page
	 * will be enough, and restrict boundary too for extra certainty.
	 */
	if (sc->sc_pp->ide_product == PCI_PRODUCT_NS_SCx200_IDE) {
		sc->sc_dma_maxsegsz = IDEDMA_BYTE_COUNT_MAX - PAGE_SIZE;
		sc->sc_dma_boundary = IDEDMA_BYTE_COUNT_MAX - PAGE_SIZE;
	}
d4034 6
d4044 5
d4053 10
a4062 1
		    pciide_pci_intr);
d4067 1
a4067 1
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
d4072 2
a4073 1
ns_scx200_setup_channel(struct channel_softc *chp)
d4076 2
a4077 1
	int drive, mode;
a4080 188
	int channel = chp->channel;
	int pioformat;
	pcireg_t piotim, dmatim;

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	pioformat = (pci_conf_read(sc->sc_pc, sc->sc_tag,
	    SCx200_TIM_DMA(0, 0)) >> SCx200_PIOFORMAT_SHIFT) & 0x01;
	WDCDEBUG_PRINT(("%s: pio format %d\n", __func__, pioformat),
	    DEBUG_PROBE);

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		piotim = pci_conf_read(sc->sc_pc, sc->sc_tag,
		    SCx200_TIM_PIO(channel, drive));
		dmatim = pci_conf_read(sc->sc_pc, sc->sc_tag,
		    SCx200_TIM_DMA(channel, drive));
		WDCDEBUG_PRINT(("%s:%d:%d: piotim=0x%x, dmatim=0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, channel, drive,
		    piotim, dmatim), DEBUG_PROBE);

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			drvp->drive_flags &= ~DRIVE_DMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			dmatim = scx200_udma33[drvp->UDMA_mode];
			mode = drvp->PIO_mode;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;
			idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);
			dmatim = scx200_dma33[drvp->DMA_mode];

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			mode = drvp->PIO_mode;
		}

		/* Setup PIO mode */
		drvp->PIO_mode = mode;
		if (mode < 2)
			drvp->DMA_mode = 0;
		else
			drvp->DMA_mode = mode - 2;

		piotim = scx200_pio33[pioformat][drvp->PIO_mode];

		WDCDEBUG_PRINT(("%s:%d:%d: new piotim=0x%x, dmatim=0x%x\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, channel, drive,
		    piotim, dmatim), DEBUG_PROBE);

		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    SCx200_TIM_PIO(channel, drive), piotim);
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    SCx200_TIM_DMA(channel, drive), dmatim);
	}

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}

	pciide_print_modes(cp);
}

void
acer_chip_map(sc, pa)
	struct pciide_softc *sc;
	struct pci_attach_args *pa;
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t cr, interface;
	bus_size_t cmdsize, ctlsize;
	int rev = sc->sc_rev;

	if (pciide_chipen(sc, pa) == 0)
		return;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);
	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;

	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
		if (rev >= 0x20) {
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
			if (rev >= 0xC4)
				sc->sc_wdcdev.UDMA_cap = 5;
			else if (rev >= 0xC2)
				sc->sc_wdcdev.UDMA_cap = 4;
			else
				sc->sc_wdcdev.UDMA_cap = 2;
		}
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}

	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = acer_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CDRC,
	    (pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CDRC) |
		ACER_CDRC_DMA_EN) & ~ACER_CDRC_FIFO_DISABLE);

	/* Enable "microsoft register bits" R/W. */
	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR3,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR3) | ACER_CCAR3_PI);
	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR1,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR1) &
	    ~(ACER_CHANSTATUS_RO|PCIIDE_CHAN_RO(0)|PCIIDE_CHAN_RO(1)));
	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR2,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR2) &
	    ~ACER_CHANSTATUSREGS_RO);
	cr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG);
	cr |= (PCIIDE_CHANSTATUS_EN << PCI_INTERFACE_SHIFT);
	pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG, cr);
	/* Don't use cr, re-read the real register content instead */
	interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag,
	    PCI_CLASS_REG));

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	/* From linux: enable "Cable Detection" */
	if (rev >= 0xC2)
		pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_0x4B,
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_0x4B)
		    | ACER_0x4B_CDETECT);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		if ((interface & PCIIDE_CHAN_EN(channel)) == 0) {
			printf("%s: %s ignored (disabled)\n",
			    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
			continue;
		}
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    (rev >= 0xC2) ? pciide_pci_intr : acer_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		if (pciide_chan_candisable(cp)) {
			cr &= ~(PCIIDE_CHAN_EN(channel) << PCI_INTERFACE_SHIFT);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PCI_CLASS_REG, cr);
		}
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		acer_setup_channel(&cp->wdc_channel);
	}
}

void
acer_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	int drive;
	u_int32_t acer_fifo_udma;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
d4212 1
a4212 1
	revision = sc->sc_rev;
a4226 2
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT302 ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT371 ||
d4266 2
a4267 4
		if (sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT372A ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT302 ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT371 ||
		    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT374)
d4274 6
a4312 2
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT302 ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT371 ||
a4314 10
		 * Turn off fast interrupts
		 */
		pciide_pci_write(sc->sc_pc, sc->sc_tag, HPT370_CTRL2(0),
		    pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT370_CTRL2(0)) &
		    ~(HPT370_CTRL2_FASTIRQ | HPT370_CTRL2_HIRQ));
		pciide_pci_write(sc->sc_pc, sc->sc_tag, HPT370_CTRL2(1),
		pciide_pci_read(sc->sc_pc, sc->sc_tag, HPT370_CTRL2(1)) &
		~(HPT370_CTRL2_FASTIRQ | HPT370_CTRL2_HIRQ));

		/*
a4323 2
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT302 ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_TRIONES_HPT371 ||
d4343 1
a4343 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
a4344 2
	int revision = sc->sc_rev;
	u_int32_t *tim_pio, *tim_dma, *tim_udma;
a4352 35
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_TRIONES_HPT366:
		if (revision == HPT370_REV ||
		    revision == HPT370A_REV) {
			tim_pio = hpt370_pio;
			tim_dma = hpt370_dma;
			tim_udma = hpt370_udma;
		} else if (revision == HPT372_REV) {
			tim_pio = hpt372_pio;
			tim_dma = hpt372_dma;
			tim_udma = hpt372_udma;
		} else {
			tim_pio = hpt366_pio;
			tim_dma = hpt366_dma;
			tim_udma = hpt366_udma;
		}
		break;
	case PCI_PRODUCT_TRIONES_HPT372A:
	case PCI_PRODUCT_TRIONES_HPT302:
	case PCI_PRODUCT_TRIONES_HPT371:
		tim_pio = hpt372_pio;
		tim_dma = hpt372_dma;
		tim_udma = hpt372_udma;
		break;
	case PCI_PRODUCT_TRIONES_HPT374:
		tim_pio = hpt374_pio;
		tim_dma = hpt374_dma;
		tim_udma = hpt374_udma;
		break;
	default:
		printf("%s: no known timing values\n",
		    sc->sc_wdcdev.sc_dev.dv_xname);
		goto end;
	}

d4374 5
a4378 1
			after = tim_udma[drvp->UDMA_mode];
d4390 5
a4394 1
			after = tim_dma[drvp->DMA_mode];
d4398 5
a4402 1
			after = tim_pio[drvp->PIO_mode];
a4409 1
end:
d4541 1
a4541 6
	    WDC_CAPABILITY_MODE;
	if (sc->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20246 ||
	    PDC_IS_262(sc))
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_NO_ATAPI_DMA;
	if (sc->sc_pp->ide_product == PCI_PRODUCT_PROMISE_PDC20376)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_SATA;
a4561 5
	if (PDC_IS_262(sc)) {
		sc->sc_wdcdev.dma_start = pdc20262_dma_start;
		sc->sc_wdcdev.dma_finish = pdc20262_dma_finish;
	}

d4669 1
a4669 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d4798 1
a4798 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d4809 1
a4809 1

a4918 45
void
pdc20262_dma_start(void *v, int channel, int drive)
{
	struct pciide_softc *sc = v;
	struct pciide_dma_maps *dma_maps =
	    &sc->pciide_channels[channel].dma_maps[drive];
	u_int8_t clock;
	u_int32_t count;

	if (dma_maps->dma_flags & WDC_DMA_LBA48) {
		clock = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_U66);
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_U66, clock | PDC262_U66_EN(channel));
		count = dma_maps->dmamap_xfer->dm_mapsize >> 1;
		count |= dma_maps->dma_flags & WDC_DMA_READ ?
		    PDC262_ATAPI_LBA48_READ : PDC262_ATAPI_LBA48_WRITE;
		bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_ATAPI(channel), count);
	}

	pciide_dma_start(v, channel, drive);
}

int
pdc20262_dma_finish(void *v, int channel, int drive, int force)
{
	struct pciide_softc *sc = v;
	struct pciide_dma_maps *dma_maps =
	    &sc->pciide_channels[channel].dma_maps[drive];
 	u_int8_t clock;

	if (dma_maps->dma_flags & WDC_DMA_LBA48) {
		clock = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_U66);
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_U66, clock & ~PDC262_U66_EN(channel));
		bus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,
		    PDC262_ATAPI(channel), 0);
	}

	return (pciide_dma_finish(v, channel, drive, force));
}

#ifdef notyet
d4995 1
a4995 1
	if (sc->sc_rev <= 0x12) {
d5051 1
a5051 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
a5145 1
#endif
d5179 1
a5179 1
		if (sc->sc_rev < 0x92)
a5186 3
	case PCI_PRODUCT_RCC_CSB6_IDE2:
		sc->sc_wdcdev.UDMA_cap = 4;
		break;
d5191 1
a5191 2
	sc->sc_wdcdev.nchannels =
	    (sc->sc_pp->ide_product == PCI_PRODUCT_RCC_CSB6_IDE2 ? 1 : 2);
d5217 1
a5217 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d5326 1
a5326 1
#define	ACARD_IS_850(sc) \
d5366 1
a5366 13
	switch (sc->sc_pp->ide_product) {
	case PCI_PRODUCT_ACARD_ATP850U:
		sc->sc_wdcdev.UDMA_cap = 2;
		break;
	case PCI_PRODUCT_ACARD_ATP860:
	case PCI_PRODUCT_ACARD_ATP860A:
		sc->sc_wdcdev.UDMA_cap = 4;
		break;
	case PCI_PRODUCT_ACARD_ATP865A:
	case PCI_PRODUCT_ACARD_ATP865R:
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
	}
d5403 1
a5403 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d5562 1
a5562 1
	switch (sc->sc_pp->ide_product) {
d5619 1
a5619 1
	struct pciide_channel *cp = (struct pciide_channel *)chp;
d5653 10
a5743 239
}

#ifdef notyet
void
artisea_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	bus_size_t cmdsize, ctlsize;
	pcireg_t interface;
	int channel;

	if (pciide_chipen(sc, pa) == 0)
		return;

	printf("%s: DMA",
	    sc->sc_wdcdev.sc_dev.dv_xname);
#ifndef PCIIDE_I31244_ENABLEDMA
	if (sc->sc_rev == 0) {
		printf(" disabled due to rev. 0");
		sc->sc_dma_ok = 0;
	} else
#endif
		pciide_mapreg_dma(sc, pa);
	printf("\n");

	/*
	 * XXX Configure LEDs to show activity.
	 */

	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE | WDC_CAPABILITY_SATA;
	sc->sc_wdcdev.PIO_cap = 4;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
		sc->sc_wdcdev.DMA_cap = 2;
		sc->sc_wdcdev.UDMA_cap = 6;
	}
	sc->sc_wdcdev.set_modes = sata_setup_channel;

	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	interface = PCI_INTERFACE(pa->pa_class);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];
		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0)
			continue;
		pciide_map_compat_intr(pa, cp, channel, interface);
		sata_setup_channel(&cp->wdc_channel);
	}
}
#endif

void
ite_chip_map(struct pciide_softc *sc, struct pci_attach_args *pa)
{
	struct pciide_channel *cp;
	int channel;
	pcireg_t interface;
	bus_size_t cmdsize, ctlsize;
	pcireg_t cfg, modectl;

	/*
	 * Fake interface since IT8212F is claimed to be a ``RAID'' device.
	 */
	interface = PCIIDE_INTERFACE_BUS_MASTER_DMA |
	    PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);

	cfg = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_CFG);
	modectl = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_MODE);
	WDCDEBUG_PRINT(("%s: cfg=0x%x, modectl=0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cfg & IT_CFG_MASK,
	    modectl & IT_MODE_MASK), DEBUG_PROBE);

	if (pciide_chipen(sc, pa) == 0)
		return;

	printf(": DMA");
	pciide_mapreg_dma(sc, pa);

	sc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |
	    WDC_CAPABILITY_MODE;
	if (sc->sc_dma_ok) {
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_IRQACK;
		sc->sc_wdcdev.irqack = pciide_irqack;
	}
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.UDMA_cap = 6;

	sc->sc_wdcdev.set_modes = ite_setup_channel;
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;

	pciide_print_channels(sc->sc_wdcdev.nchannels, interface);

	/* Disable RAID */
	modectl &= ~IT_MODE_RAID1;
	/* Disable CPU firmware mode */
	modectl &= ~IT_MODE_CPU;
	/* Select 66 MHz bus */
	modectl &= ~(IT_MODE_50MHZ(0) | IT_MODE_50MHZ(1));

	pci_conf_write(sc->sc_pc, sc->sc_tag, IT_MODE, modectl);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		cp = &sc->pciide_channels[channel];

		if (pciide_chansetup(sc, channel, interface) == 0)
			continue;
		pciide_map_compat_intr(pa, cp, channel, interface);
		if (cp->hw_ok == 0)
			continue;
		pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,
		    pciide_pci_intr);
		if (cp->hw_ok == 0) {
			pciide_unmap_compat_intr(pa, cp, channel, interface);
			continue;
		}
		sc->sc_wdcdev.set_modes(&cp->wdc_channel);
	}

	/* Re-read configuration registers after channels setup */
	cfg = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_CFG);
	modectl = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_MODE);
	WDCDEBUG_PRINT(("%s: cfg=0x%x, modectl=0x%x\n",
	    sc->sc_wdcdev.sc_dev.dv_xname, cfg & IT_CFG_MASK,
	    modectl & IT_MODE_MASK), DEBUG_PROBE);
}

void
ite_setup_channel(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	int drive, mode;
	u_int32_t idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel *)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int channel = chp->channel;
	pcireg_t cfg, modectl;
	pcireg_t tim;

	cfg = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_CFG);
	modectl = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_MODE);
	tim = pci_conf_read(sc->sc_pc, sc->sc_tag, IT_TIM(channel));
	WDCDEBUG_PRINT(("%s:%d: tim=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname,
	    channel, tim), DEBUG_PROBE);

	/* Setup DMA if needed */
	pciide_channel_dma_setup(cp);

	/* Clear all bits for this channel */
	idedma_ctl = 0;

	/* Per channel settings */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];

		/* If no drive, skip */
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		if ((chp->wdc->cap & WDC_CAPABILITY_UDMA) != 0 &&
		    (drvp->drive_flags & DRIVE_UDMA) != 0) {
			/* Setup UltraDMA mode */
			drvp->drive_flags &= ~DRIVE_DMA;
			modectl &= ~IT_MODE_DMA(channel, drive);

			/* Check cable */
			if (drvp->UDMA_mode > 2 &&
			    (cfg & IT_CFG_CABLE(channel, drive)) == 0) {
				WDCDEBUG_PRINT(("%s(%s:%d:%d): "
				    "80-wire cable not detected\n",
				    drvp->drive_name,
				    sc->sc_wdcdev.sc_dev.dv_xname,
				    channel, drive), DEBUG_PROBE);
				drvp->UDMA_mode = 2;
			}

			if (drvp->UDMA_mode >= 5)
				tim |= IT_TIM_UDMA5(drive);
			else
				tim &= ~IT_TIM_UDMA5(drive);

			mode = drvp->PIO_mode;
		} else if ((chp->wdc->cap & WDC_CAPABILITY_DMA) != 0 &&
		    (drvp->drive_flags & DRIVE_DMA) != 0) {
			/* Setup multiword DMA mode */
			drvp->drive_flags &= ~DRIVE_UDMA;
			modectl |= IT_MODE_DMA(channel, drive);

			/* mode = min(pio, dma + 2) */
			if (drvp->PIO_mode <= (drvp->DMA_mode + 2))
				mode = drvp->PIO_mode;
			else
				mode = drvp->DMA_mode + 2;
		} else {
			goto pio;
		}
		idedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);

pio:
		/* Setup PIO mode */
		if (mode <= 2) {
			drvp->DMA_mode = 0;
			drvp->PIO_mode = 0;
			mode = 0;
		} else {
			drvp->PIO_mode = mode;
			drvp->DMA_mode = mode - 2;
		}

		/* Enable IORDY if PIO mode >= 3 */
		if (drvp->PIO_mode >= 3)
			cfg |= IT_CFG_IORDY(channel);
	}

	WDCDEBUG_PRINT(("%s: tim=0x%x\n", sc->sc_wdcdev.sc_dev.dv_xname,
	    tim), DEBUG_PROBE);

	pci_conf_write(sc->sc_pc, sc->sc_tag, IT_CFG, cfg);
	pci_conf_write(sc->sc_pc, sc->sc_tag, IT_MODE, modectl);
	pci_conf_write(sc->sc_pc, sc->sc_tag, IT_TIM(channel), tim);

	if (idedma_ctl != 0) {
		/* Add software bits in status register */
		bus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,
		    IDEDMA_CTL(channel), idedma_ctl);
	}

	pciide_print_modes(cp);
@


1.20.2.13
log
@Merge with the trunk
@
text
@d383 1
a383 1
	  IDE_PCI_CLASS_OVERRIDE,
d806 1
d809 1
a809 1
	if (sc->sc_pp == NULL)
d811 3
d919 7
a2284 3
	case PCI_PRODUCT_AMD_8111_IDE:
		sc->sc_wdcdev.UDMA_cap = 6;
		break;
d2287 1
a2626 1
		sata_setup_channel(&cp->wdc_channel);
a3619 1
	{PCI_PRODUCT_SIS_741, 0x00, 6, "741", SIS_TYPE_SOUTH},
a4224 6
	/*
	 * This chip seems to be unable to do one-sector transfers
	 * using DMA.
	 */
	sc->sc_wdcdev.quirks = WDC_QUIRK_NOSHORTDMA;

d6311 2
d6321 3
d6326 4
d6379 1
a6379 2
#if 0
			/* Check cable, works only in CPU firmware mode */
a6388 1
#endif
@


1.19
log
@Clean up my cruft
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.18 2000/01/11 01:14:52 chris Exp $     */
d2200 5
a2204 2
	if (sc->sc_dma_ok)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
d2210 2
a2211 1
	sc->sc_wdcdev.UDMA_cap = (rev >= 0xd0) ? 2 : 0;
@


1.18
log
@use PCI_REVISION macro
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.17 2000/01/10 23:28:35 chris Exp $     */
a2192 2

	printf("\nrevision: i:%i h:%x i:%i h:%x i:%i h:%x\n",rev,rev,interface,interface,interface & PCI_REVISION_MASK, interface & PCI_REVISION_MASK);
@


1.17
log
@Don't enable UDMA modes for revisions of SiS 5513 < 0xd0
The only revisions I know which don't actually support UDMA are 0x09 and below..
But the only revision I know which does support UDMA is 0xd0 (and presumably
above that)
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.16 2000/01/10 22:54:45 chris Exp $     */
a2186 1
	u_int32_t rev;
d2190 2
d2194 2
a2208 2

	rev = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG) & PCI_REVISION_MASK;
a2209 1

@


1.16
log
@Sync w/NetBSD regarding Promise PDC20262 support (the Promise Ultra/66
controller actually works now!) and Manuel Bouyer's copyright.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.15 1999/11/23 20:48:35 chris Exp $     */
d2187 1
d2206 4
a2209 1
	sc->sc_wdcdev.UDMA_cap = 2;
@


1.15
log
@Bugfix from NetBSD.  For SiS, PIIX, and Apollo IDE controllers,
the secondary channel was ignored when the primary channel is disabled.
@
text
@d1 35
a35 2
/*      $OpenBSD: pciide.c,v 1.14 1999/11/17 01:22:56 csapuntz Exp $     */
/*	$NetBSD: pciide.c,v 1.40 1999/07/12 13:49:38 bouyer Exp $	*/
d2494 2
d2533 1
a2533 1
	if (sc->sc_pp->ide_product == PCI_PRODUCT_PROMISE_ULTRA66) 
d2567 6
a2572 1
	mode = PDC2xx_SCR_SET_GEN(mode, 0x1); /* the BIOS set it up this way */
d2581 1
a2581 1
	/* The Linux driver does this */
d2596 2
a2597 1
		if ((st & PDC2xx_STATE_EN(channel)) == 0) {
d2607 2
a2608 1
		    st &= ~PDC2xx_STATE_EN(channel);
d2624 2
a2625 2
	pcireg_t mode;
	u_int32_t idedma_ctl;
d2628 1
d2634 42
d2681 1
a2681 3
		 mode = PDC2xx_TIM_IORDY;
		if (drvp->drive_flags & DRIVE_ATA)
			mode |= PDC2xx_TIM_PRE;
d2703 8
a2710 5
		mode |= PDC2xx_TIM_SYNC;
		if (drvp->PIO_mode >= 3 &&(drvp->drive_flags & DRIVE_ATA))
			mode |= PDC2xx_TIM_ERRDY;
		if (drive == 0)
			mode |= PDC2xx_TIM_IORDYp;
@


1.14
log
@

New interface to ATA registers that goes through the lower-level device
driver (pciide, wdc, etc.)

Remove #define WDCDEBUG from top of files

More fixes to ATAPISCSI logic:

Not all devices transition correctly between phases. Devices are supposed
to keep BSY high until they've set the registers to the next sensible
state. Some devices drop BSY and leave the registers in an old or
nonsense state. Our polling code is extremely sensitive to this
(though an early itnerrupt could also observe this). So, if the device is
in an unexpected state, the new polling code waits for a while in the hope
that it enters a better state.

This seems to fix many of the problems reported.

Also, there was a horrible bug which would cause sense to fail on a ATAPI
command that sent data to the drive
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.13 1999/11/03 01:02:56 chris Exp $     */
d1296 1
a1296 1
			return;
d1688 1
a1688 1
			return;
d2191 1
a2191 1
			return;
@


1.13
log
@0x5597 will never match an SiS pciide controller because they are 0x5513
The NetBSD pcidevs is confusing because it calles "5597_IDE" 0x5513,
but OpenBSD pcidevs just had "SiS 5597" as 0x5597
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.12 1999/11/02 02:43:45 chris Exp $     */
a44 4

#ifndef WDCDEBUG
#define WDCDEBUG
#endif
@


1.12
log
@fix printf (had an extra space)
add useless comments to new Intel code
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.11 1999/10/09 03:42:04 csapuntz Exp $     */
d277 1
a277 1
	{ PCI_PRODUCT_SIS_5597,		/* SIS 5597/5598 IDE */
d2577 1
a2577 1
return;
@


1.11
log
@

wdc layer work:
Separate wdc_probe_caps into wdc_probe_caps and wdc_print_caps for more
flexibility in printing capability information.

Get rid of wdc_final_attach.

Include name of device (e.g. cd0), if possible, on errors.

atapiscsi layer work:
Put a pointer to the SCSI device into ata_drive_datas' drv_softc field

Simplify, simplify, simplify. Got rid of a bunch of fields in atapiscsi_softc

Delay printing capabilities until we know the real device name (e.g. st0)
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.10 1999/10/04 22:54:18 deraadt Exp $     */
d233 1
a233 1
	{ PCI_PRODUCT_INTEL_82801AA_IDE,
d237 1
a237 1
	{ PCI_PRODUCT_INTEL_82801AB_IDE,
d1116 1
a1116 1
			printf(", (partial support) ");
@


1.10
log
@promise support; chris@@ took it from netbsd
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.9 1999/09/01 04:32:14 csapuntz Exp $     */
a438 1
	struct pciide_channel *cp;
a440 1
	int i;
a462 8
	}

	/* This is a hook so that the ATAPI-SCSI stuff can
	   attach the SCSI BUS now and do the probes */
	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];

		wdc_final_attach(&cp->wdc_channel);
@


1.9
log
@

Fix messed up logic that could cause an unmap of an unmapped region.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.8 1999/08/05 00:10:31 niklas Exp $     */
d82 1
d157 1
a157 4
void default_setup_cap __P((struct pciide_softc*));
void default_setup_chip __P((struct pciide_softc*));
void default_channel_map __P((struct pci_attach_args *, 
		struct pciide_channel *));
d159 1
a159 2
void piix_setup_cap __P((struct pciide_softc*));
void piix_setup_chip __P((struct pciide_softc*));
a160 1
void piix3_4_setup_chip __P((struct pciide_softc*));
d162 1
a162 1
void piix_channel_map __P((struct pci_attach_args *, struct pciide_channel *));
d167 1
a167 2
void apollo_setup_cap __P((struct pciide_softc*));
void apollo_setup_chip __P((struct pciide_softc*));
a168 2
void apollo_channel_map __P((struct pci_attach_args *,
		struct pciide_channel *));
d170 2
a171 2
void cmd0643_6_setup_cap __P((struct pciide_softc*));
void cmd0643_6_setup_chip __P((struct pciide_softc*));
d173 3
a175 1
void cmd_channel_map __P((struct pci_attach_args *, struct pciide_channel *));
d177 1
a177 2
void cy693_setup_cap __P((struct pciide_softc*));
void cy693_setup_chip __P((struct pciide_softc*));
a178 1
void cy693_channel_map __P((struct pci_attach_args *, struct pciide_channel *));
d180 1
a180 2
void sis_setup_cap __P((struct pciide_softc*));
void sis_setup_chip __P((struct pciide_softc*));
a181 1
void sis_channel_map __P((struct pci_attach_args *, struct pciide_channel *));
d183 1
a183 2
void acer_setup_cap __P((struct pciide_softc*));
void acer_setup_chip __P((struct pciide_softc*));
d185 1
a185 1
void acer_channel_map __P((struct pci_attach_args *, struct pciide_channel *));
d187 4
d197 1
d202 2
a203 8
	u_short ide_num_channels;
	/* init controller's capabilities for drives probe */
	void (*setup_cap) __P((struct pciide_softc*));
	/* init controller after drives probe */
	void (*setup_chip) __P((struct pciide_softc*));
	/* map channel if possible/necessary */
	void (*channel_map) __P((struct pci_attach_args *,
		struct pciide_channel *));
d207 1
a207 2
#define CMD_PCI064x_IOEN	0x01 /* CMD-style PCI_COMMAND_IO_ENABLE */
#define ONE_QUEUE		0x02 /* device need serialised access */
d213 1
a213 4
	PCIIDE_NUM_CHANNELS,
	default_setup_cap,
	default_setup_chip,
	default_channel_map
d219 1
a219 4
	  PCIIDE_NUM_CHANNELS,
	  default_setup_cap,
	  default_setup_chip,
	  default_channel_map
d223 1
a223 4
	  PCIIDE_NUM_CHANNELS,
	  piix_setup_cap,
	  piix_setup_chip,
	  piix_channel_map
d227 1
a227 4
	  PCIIDE_NUM_CHANNELS,
	  piix_setup_cap,
	  piix3_4_setup_chip,
	  piix_channel_map
d231 10
a240 5
	  PCIIDE_NUM_CHANNELS,
	  piix_setup_cap,
	  piix3_4_setup_chip,
	  piix_channel_map
	}
d245 2
a246 5
	  ONE_QUEUE | CMD_PCI064x_IOEN,
	  PCIIDE_NUM_CHANNELS,
	  default_setup_cap,
	  default_setup_chip,
	  cmd_channel_map
d249 2
a250 5
	  ONE_QUEUE | CMD_PCI064x_IOEN,
	  PCIIDE_NUM_CHANNELS,
	  cmd0643_6_setup_cap,
	  cmd0643_6_setup_chip,
	  cmd_channel_map
d253 2
a254 5
	  ONE_QUEUE | CMD_PCI064x_IOEN,
	  PCIIDE_NUM_CHANNELS,
	  cmd0643_6_setup_cap,
	  cmd0643_6_setup_chip,
	  cmd_channel_map
d261 1
a261 4
	  PCIIDE_NUM_CHANNELS,
	  apollo_setup_cap,
	  apollo_setup_chip,
	  apollo_channel_map
d265 1
a265 4
	  PCIIDE_NUM_CHANNELS,
	  apollo_setup_cap,
	  apollo_setup_chip,
	  apollo_channel_map
d272 1
a272 4
	  1,
	  cy693_setup_cap,
	  cy693_setup_chip,
	  cy693_channel_map
d279 1
a279 4
	  PCIIDE_NUM_CHANNELS,
	  sis_setup_cap,
	  sis_setup_chip,
	  sis_channel_map
d287 1
a287 4
	  PCIIDE_NUM_CHANNELS,
	  acer_setup_cap,
	  acer_setup_chip,
	  acer_channel_map
d292 11
d322 1
a322 1
	  sizeof(pciide_acer_products)/sizeof(pciide_acer_products[0]) }
d324 2
d349 1
d353 5
a357 1
	    struct pciide_channel *, bus_size_t *, bus_size_t *));
d359 2
a360 1
	    struct pciide_channel *, int, bus_size_t *, bus_size_t *));
d406 1
d418 9
d440 1
a440 1
	pcireg_t class, interface, csr;
d444 1
a444 1
        sc->sc_pp = pciide_lookup_product(pa->pa_id);
a449 24
	if ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {
		csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		/*
		 * For a CMD PCI064x, the use of PCI_COMMAND_IO_ENABLE
		 * and base adresses registers can be disabled at
		 * hardware level. In this case, the device is wired
		 * in compat mode and its first channel is always enabled,
		 * but we can't rely on PCI_COMMAND_IO_ENABLE.
		 * In fact, it seems that the first channel of the CMD PCI0640
		 * can't be disabled.
		 */
#ifndef PCIIDE_CMD064x_DISABLE
		if ((sc->sc_pp->ide_flags & CMD_PCI064x_IOEN) == 0) {
#else
		if (1) {
#endif
			printf(": device disabled (at %s)\n",
		 	   sc->sc_wdcdev.sc_dev.dv_xname,
		  	  (csr & PCI_COMMAND_IO_ENABLE) == 0 ?
			  "device" : "bridge");
			return;
		}
	}

a452 2
	class = pci_conf_read(pc, tag, PCI_CLASS_REG);
	interface = PCI_INTERFACE(class);
d454 4
a457 60
	/*
	 * Map DMA registers, if DMA is supported.
	 *
	 * Note that sc_dma_ok is the right variable to test to see if
	 * DMA can be done.  If the interface doesn't support DMA,
	 * sc_dma_ok will never be non-zero.  If the DMA regs couldn't
	 * be mapped, it'll be zero.  I.e., sc_dma_ok will only be
	 * non-zero if the interface supports DMA and the registers
	 * could be mapped.
	 *
	 * XXX Note that despite the fact that the Bus Master IDE specs
	 * XXX say that "The bus master IDE function uses 16 bytes of IO
	 * XXX space," some controllers (at least the United
	 * XXX Microelectronics UM8886BF) place it in memory space.
	 * XXX eventually, we should probably read the register and check
	 * XXX which type it is.  Either that or 'quirk' certain devices.
	 */
	if (interface & PCIIDE_INTERFACE_BUS_MASTER_DMA) {
		printf(": DMA");
		if (sc->sc_pp == &default_product_desc &&
		    (sc->sc_wdcdev.sc_dev.dv_cfdata->cf_flags &
		    PCIIDE_OPTIONS_DMA) == 0) {
			printf(" (unsupported)");
			sc->sc_dma_ok = 0;
		} else {
			sc->sc_dma_ok = (pci_mapreg_map(pa,
			    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,
			    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);
			sc->sc_dmat = pa->pa_dmat;
			if (sc->sc_dma_ok == 0) {
				printf(" (unuseable)");
			} else {
				if (sc->sc_pp == &default_product_desc)
					printf(" (partial support) ");
				sc->sc_wdcdev.dma_arg = sc;
				sc->sc_wdcdev.dma_init = pciide_dma_init;
				sc->sc_wdcdev.dma_start = pciide_dma_start;
				sc->sc_wdcdev.dma_finish = pciide_dma_finish;
			}
		}
	} else {
		printf(": no DMA");
	}
	sc->sc_pp->setup_cap(sc);
	sc->sc_wdcdev.channels = sc->wdc_chanarray;
	sc->sc_wdcdev.nchannels = sc->sc_pp->ide_num_channels;;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		printf(", %s %s to %s", PCIIDE_CHANNEL_NAME(i),
		    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?
		      "configured" : "wired",
		    (interface & PCIIDE_INTERFACE_PCI(i)) ? "native-PCI" :
		      "compatibility");
	}
	printf("\n");

	for (i = 0; i < sc->sc_wdcdev.nchannels; i++) {
		cp = &sc->pciide_channels[i];
		sc->wdc_chanarray[i] = &cp->wdc_channel;
d459 1
a459 18
		cp->name = PCIIDE_CHANNEL_NAME(i);

		cp->wdc_channel.channel = i;
		cp->wdc_channel.wdc = &sc->sc_wdcdev;
		if (i > 0 && (sc->sc_pp->ide_flags & ONE_QUEUE)) {
			cp->wdc_channel.ch_queue =
			    sc->pciide_channels[0].wdc_channel.ch_queue;
		} else {
			cp->wdc_channel.ch_queue =
			    malloc(sizeof(struct channel_queue), M_DEVBUF,
			    M_NOWAIT);
		}
		if (cp->wdc_channel.ch_queue == NULL) {
			printf("%s: %s cannot allocate memory for "
			    "command queue", sc->sc_wdcdev.sc_dev.dv_xname,
			    cp->name);
			continue;
		}
a460 10
		/*
		 * sc->sc_pp->channel_map() will also call wdcattach.
		 * Eventually the channel will be  disabled if there's no
		 * drive present. cp->hw_ok will be updated accordingly.
		 */
		sc->sc_pp->channel_map(pa, cp);
			
	}
	/* Now that all drives are know, setup DMA, etc ...*/
	sc->sc_pp->setup_chip(sc);
d479 19
a506 1
	int rv = 1;
a512 1
	wdc_cp->ctl_iot = pa->pa_iot;
d521 2
d532 1
a532 1
	return (rv);
d536 1
a536 1
pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep)
d540 1
d559 1
a559 1
		    intrhandle, IPL_BIO, pciide_pci_intr, sc,
d563 1
a563 1
		    intrhandle, IPL_BIO, pciide_pci_intr, sc);
d598 37
d957 26
d985 1
a985 1
pciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep)
a986 1
	int interface;
d988 1
d990 1
d995 2
a996 1
		cp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep);
d1053 18
d1099 1
a1099 1
default_setup_cap(sc)
d1101 1
d1103 29
d1136 5
a1140 1
}
d1142 55
a1196 7
void
default_setup_chip(sc)
	struct pciide_softc *sc;
{
	int channel, drive, idedma_ctl;
	struct channel_softc *chp;
	struct ata_drive_datas *drvp;
d1199 1
a1199 1
		return; /* nothing to do */
d1204 1
a1204 1
		chp = &sc->pciide_channels[channel].wdc_channel;
d1206 1
a1206 1
			drvp = &chp->ch_drive[drive];
d1214 1
a1214 1
				printf("%s:%d:%d: can't allocate DMA maps, "
d1236 2
a1237 1
default_channel_map(pa, cp)
d1239 1
d1241 2
a1242 2
{	
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
a1243 5
	pcireg_t csr;
	const char *failreason = NULL;
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	int interface =
	    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));
d1245 4
a1248 6
	if (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))
		cp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize, &ctlsize);
	else
		cp->hw_ok = pciide_mapregs_compat(pa, cp, wdc_cp->channel,
		    &cmdsize, &ctlsize);
	if (cp->hw_ok == 0)
d1251 10
a1260 36
	/*
	 * Check to see if something appears to be there.
	 */
	if (!wdcprobe(wdc_cp)) {
		failreason = "not responding; disabled or no drives?";
		goto out;
	}

	/*
	 * Now, make sure it's actually attributable to this PCI IDE
	 * channel by trying to access the channel again while the
	 * PCI IDE controller's I/O space is disabled.  (If the
	 * channel no longer appears to be there, it belongs to
	 * this controller.)  YUCK!
	 */
	csr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG,
	    csr & ~PCI_COMMAND_IO_ENABLE);
	if (wdcprobe(wdc_cp))
		failreason = "other hardware responding at addresses";
	pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG, csr);

out:
	if (failreason) {
		printf("%s: %s ignored (%s)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
		    failreason);
		cp->hw_ok = 0;
		bus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, cmdsize);
		bus_space_unmap(wdc_cp->ctl_iot, wdc_cp->ctl_ioh, ctlsize);
	}
	pciide_map_compat_intr(pa, cp, wdc_cp->channel, interface);
	if (cp->hw_ok) {
		wdc_cp->data32iot = wdc_cp->cmd_iot;
		wdc_cp->data32ioh = wdc_cp->cmd_ioh;
		wdcattach(wdc_cp);
a1261 1
}
d1263 2
a1264 8
void
piix_setup_cap(sc)
	struct pciide_softc *sc;
{
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371AB_IDE)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA32 | WDC_CAPABILITY_MODE |
	    WDC_CAPABILITY_DMA;
d1267 5
a1271 3
	sc->sc_wdcdev.UDMA_cap = 2;
	if (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371SB_IDE ||
	    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371AB_IDE)
d1273 2
a1274 3
	else
		sc->sc_wdcdev.set_modes = piix_setup_channel;
}
d1276 1
a1276 5
void
piix_setup_chip(sc)
	struct pciide_softc *sc;
{
	u_int8_t channel;
d1278 18
d1297 2
a1298 2
	WDCDEBUG_PRINT(("piix_setup_chip: old idetim=0x%x\n",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM)), DEBUG_PROBE);
d1301 45
a1345 1
		piix_setup_channel(&sc->pciide_channels[channel].wdc_channel);
d1347 1
a1347 2
	WDCDEBUG_PRINT(("piix_setup_chip: idetim=0x%x\n",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM)), DEBUG_PROBE);
d1359 1
a1359 1

d1460 2
a1461 2
piix3_4_setup_chip(sc)
	struct pciide_softc *sc;
d1463 6
a1468 1
	int channel;
d1470 7
a1476 42
	WDCDEBUG_PRINT(("piix3_4_setup_chip: old idetim=0x%x, sidetim=0x%x",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM),
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM)), DEBUG_PROBE);
	if (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {
		WDCDEBUG_PRINT((", udamreg 0x%x",
		    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG)),
		    DEBUG_PROBE);
	}
	WDCDEBUG_PRINT(("\n"), DEBUG_PROBE);

	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		piix3_4_setup_channel(
		    &sc->pciide_channels[channel].wdc_channel);
	}

	WDCDEBUG_PRINT(("piix3_4_setup_chip: idetim=0x%x, sidetim=0x%x",
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM),
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM)), DEBUG_PROBE);
	if (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {
		WDCDEBUG_PRINT((", udmareg=0x%x",
		pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG)),
		DEBUG_PROBE);
	}
	WDCDEBUG_PRINT(("\n"), DEBUG_PROBE);
}

void
piix3_4_setup_channel(chp)
	struct channel_softc *chp;
{
	struct ata_drive_datas *drvp;
	u_int32_t oidetim, idetim, sidetim, udmareg, idedma_ctl;
	struct pciide_channel *cp = (struct pciide_channel*)chp;
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	int drive;

	oidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);
	sidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM);
	udmareg = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG);
	idetim = PIIX_IDETIM_CLEAR(oidetim, 0xffff, chp->channel);
	sidetim &= ~(PIIX_SIDETIM_ISP_MASK(chp->channel) |
	    PIIX_SIDETIM_RTC_MASK(chp->channel));
d1480 1
a1480 1
	if ((PIIX_IDETIM_READ(oidetim, chp->channel) & PIIX_IDETIM_IDE) == 0)
d1483 1
a1483 1
	idetim = PIIX_IDETIM_SET(idetim, PIIX_IDETIM_IDE, chp->channel);
d1489 2
a1490 2
		udmareg &= ~(PIIX_UDMACTL_DRV_EN(chp->channel, drive) |
		    PIIX_UDMATIM_SET(0x3, chp->channel, drive));
d1499 15
d1518 1
a1518 2
			udmareg |= PIIX_UDMACTL_DRV_EN(
			    chp->channel, drive);
d1520 1
a1520 2
			    piix4_sct_udma[drvp->UDMA_mode],
			    chp->channel, drive);
d1526 1
a1526 1
				    drvp->DMA_mode, 1, chp->channel);
d1529 1
a1529 1
					drvp->DMA_mode, 1, chp->channel);
d1531 1
a1531 1
				    PIIX_IDETIM_SITRE, chp->channel);
d1540 1
a1540 1
			    drvp->PIO_mode, 0, chp->channel);
d1543 1
a1543 1
				drvp->PIO_mode, 0, chp->channel);
d1545 1
a1545 1
			    PIIX_IDETIM_SITRE, chp->channel);
d1551 1
a1551 1
		    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),
d1557 1
d1654 2
a1655 1
piix_channel_map(pa, cp)
d1657 1
d1659 4
a1662 2
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
a1663 2
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	u_int32_t idetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);
d1665 1
a1665 4
	if ((PIIX_IDETIM_READ(idetim, wdc_cp->channel) &
	    PIIX_IDETIM_IDE) == 0) {
		printf("%s: %s ignored (disabled)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
d1667 6
d1674 1
a1674 21

	/* PIIX are compat-only pciide devices */
	pciide_mapchan(pa, cp, 0, &cmdsize, &ctlsize);
	if (cp->hw_ok == 0)
		return;
	if (pciiide_chan_candisable(cp)) {
		idetim = PIIX_IDETIM_CLEAR(idetim, PIIX_IDETIM_IDE,
					   wdc_cp->channel);
		pci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_IDETIM, idetim);
	}
	pciide_map_compat_intr(pa, cp, wdc_cp->channel, 0);
}

void
apollo_setup_cap(sc)
	struct pciide_softc *sc;
{
	if (sc->sc_pp->ide_product == PCI_PRODUCT_VIATECH_VT82C586A_IDE)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA32 | WDC_CAPABILITY_MODE |
	    WDC_CAPABILITY_DMA;
d1679 3
d1683 3
a1685 9
}

void
apollo_setup_chip(sc)
	struct pciide_softc *sc;
{
	int channel;

	WDCDEBUG_PRINT(("apollo_setup_chip: old APO_IDECONF=0x%x, "
d1694 23
d1719 1
a1719 1
	WDCDEBUG_PRINT(("apollo_setup_chip: APO_DATATIM=0x%x, APO_UDMA=0x%x\n",
d1803 1
a1803 1
apollo_channel_map(pa, cp)
d1805 2
a1806 1
	struct pciide_channel *cp;
d1808 1
a1808 1
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
d1810 2
a1811 3
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	u_int32_t ideconf = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_IDECONF);
	int interface =
d1814 15
a1828 2
	if ((ideconf & APO_IDECONF_EN(wdc_cp->channel)) == 0) {
		printf("%s: %s ignored (disabled)\n",
a1832 22
	pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize);
	if (cp->hw_ok == 0)
		return;
	if (pciiide_chan_candisable(cp)) {
		ideconf &= ~APO_IDECONF_EN(wdc_cp->channel);
		pci_conf_write(sc->sc_pc, sc->sc_tag, APO_IDECONF, ideconf);
	}
	pciide_map_compat_intr(pa, cp, wdc_cp->channel, interface);
}

void
cmd_channel_map(pa, cp)
	struct pci_attach_args *pa;
	struct pciide_channel *cp;
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
	bus_size_t cmdsize, ctlsize;
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	u_int8_t ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CTRL);
	int interface =
	    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));

d1838 1
a1838 1
	if (wdc_cp->channel != 0 && (ctrl & CMD_CTRL_2PORT) == 0) {
d1844 1
a1844 1
	pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize);
d1847 1
a1847 1
	if (wdc_cp->channel == 1) {
d1854 34
a1887 1
	pciide_map_compat_intr(pa, cp, wdc_cp->channel, interface);
d1891 1
a1891 1
cmd0643_6_setup_cap(sc)
d1893 1
d1895 25
d1921 5
a1925 5
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA32 | WDC_CAPABILITY_MODE |
	    WDC_CAPABILITY_DMA;
	sc->sc_wdcdev.PIO_cap = 4;
	sc->sc_wdcdev.DMA_cap = 2;
	sc->sc_wdcdev.set_modes = cmd0643_6_setup_channel;
d1929 1
a1929 1
cmd0643_6_setup_chip(sc)
d1931 1
d1933 1
d1935 2
d1938 30
a1967 1
	WDCDEBUG_PRINT(("cmd0643_6_setup_chip: old timings reg 0x%x 0x%x\n",
d1972 5
a1976 2
		cmd0643_6_setup_channel(
		    &sc->pciide_channels[channel].wdc_channel);
a1977 1
	/* configure for DMA read multiple */
d1979 1
a1979 1
	WDCDEBUG_PRINT(("cmd0643_6_setup_chip: timings reg now 0x%x 0x%x\n",
d2033 1
a2033 1
cy693_setup_cap(sc)
d2035 33
a2067 1
{
d2069 4
a2072 2
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA32 | WDC_CAPABILITY_MODE |
	    WDC_CAPABILITY_DMA;
a2075 1
}
d2077 17
a2093 4
void
cy693_setup_chip(sc)
	struct pciide_softc *sc;
{
d2095 14
a2108 5
	WDCDEBUG_PRINT(("cy693_setup_chip: old timings reg 0x%x\n",
		pci_conf_read(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL)),
		DEBUG_PROBE);
	cy693_setup_channel(&sc->pciide_channels[0].wdc_channel);
	WDCDEBUG_PRINT(("cy693_setup_chip: new timings reg 0x%x\n",
d2122 1
d2137 3
a2139 9
			/*
			 * use Multiword DMA
			 * Timings will be used for both PIO and DMA, so adjust
			 * DMA mode if needed
			 */
			if (drvp->PIO_mode > (drvp->DMA_mode + 2))
				drvp->PIO_mode = drvp->DMA_mode + 2;
			if (drvp->DMA_mode == 0)
				drvp->PIO_mode = 0;
d2151 2
d2162 2
a2163 1
cy693_channel_map(pa, cp)
d2165 1
d2167 4
a2170 2
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
a2171 4
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	int interface =
	    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));
	int compatchan;
d2173 2
a2174 4
#ifdef DIAGNOSTIC
	if (wdc_cp->channel != 0)
		panic("cy693_channel_map: channel %d", wdc_cp->channel);
#endif
d2176 2
a2177 33
	/*
	 * this chip has 2 PCI IDE functions, one for primary and one for
	 * secondary. So we need to call pciide_mapregs_compat() with
	 * the real channel
	 */
	if (pa->pa_function == 1) {
		compatchan = 0;
	} else if (pa->pa_function == 2) {
		compatchan = 1;
	} else {
		printf("%s: unexpected PCI function %d\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, pa->pa_function);
		cp->hw_ok = 0;
		return;
	}
		
	/* Only one channel for this chip; if we are here it's enabled */
	if (interface & PCIIDE_INTERFACE_PCI(0))
		cp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize, &ctlsize);
	else
		cp->hw_ok = pciide_mapregs_compat(pa, cp, compatchan,
		    &cmdsize, &ctlsize);
	if (cp->hw_ok == 0)
		return;
	wdc_cp->data32iot = wdc_cp->cmd_iot;
	wdc_cp->data32ioh = wdc_cp->cmd_ioh;
	wdcattach(wdc_cp);
	if (pciiide_chan_candisable(cp)) {
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    PCI_COMMAND_STATUS_REG, 0);
	}
	pciide_map_compat_intr(pa, cp, compatchan, interface);
}
d2179 2
a2180 4
void
sis_setup_cap(sc)
	struct pciide_softc *sc;
{
d2182 2
a2183 2
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA32 | WDC_CAPABILITY_MODE |
	    WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
d2188 2
a2189 1
}
d2191 1
a2191 5
void
sis_setup_chip(sc)
	struct pciide_softc *sc;
{
	int channel;
a2192 3
	for (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {
		sis_setup_channel(&sc->pciide_channels[channel].wdc_channel);
	}
d2196 28
d2237 1
a2237 1
	WDCDEBUG_PRINT(("sis_setup_chip: old timings reg for "
d2282 1
a2282 1
	WDCDEBUG_PRINT(("sis_setup_chip: new timings reg for "
d2294 2
a2295 1
sis_channel_map(pa, cp)
d2297 1
d2299 2
a2300 2
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
a2301 4
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	u_int8_t sis_ctr0 = pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_CTRL0);
	int interface =
	    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));
d2303 1
a2303 4
	if ((wdc_cp->channel == 0 && (sis_ctr0 & SIS_CTRL0_CHAN0_EN) == 0) ||
	    (wdc_cp->channel == 1 && (sis_ctr0 & SIS_CTRL0_CHAN1_EN) == 0)) {
		printf("%s: %s ignored (disabled)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
a2304 1
	}
d2306 2
a2307 12
	pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize);
	if (cp->hw_ok == 0)
		return;
	if (pciiide_chan_candisable(cp)) {
		if (wdc_cp->channel == 0)
			sis_ctr0 &= ~SIS_CTRL0_CHAN0_EN;
		else
			sis_ctr0 &= ~SIS_CTRL0_CHAN1_EN;
		pciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_CTRL0, sis_ctr0);
	}
	pciide_map_compat_intr(pa, cp, wdc_cp->channel, interface);
}
d2309 2
a2310 4
void
acer_setup_cap(sc)
	struct pciide_softc *sc;
{
d2312 2
a2313 2
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA32 | WDC_CAPABILITY_MODE |
	    WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;
d2318 2
a2319 7
}

void
acer_setup_chip(sc)
	struct pciide_softc *sc;
{
	int channel;
d2325 19
d2345 19
a2363 1
		acer_setup_channel(&sc->pciide_channels[channel].wdc_channel);
d2380 1
a2380 1
	WDCDEBUG_PRINT(("acer_setup_chip: old fifo/udma reg 0x%x\n", 
d2390 1
a2390 1
		WDCDEBUG_PRINT(("acer_setup_chip: old timings reg for "
d2434 1
a2434 1
	WDCDEBUG_PRINT(("acer_setup_chip: new fifo/udma reg 0x%x\n",
d2445 31
d2477 2
a2478 1
acer_channel_map(pa, cp)
d2480 1
d2482 2
a2483 2
{
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
d2485 9
a2493 3
	struct channel_softc *wdc_cp = &cp->wdc_channel;
	u_int32_t cr;
	int interface;
d2496 2
a2497 3
	 * Enable "microsoft register bits" R/W. Will be done 2 times
	 * (one for each channel) but should'nt be a problem. There's no
	 * better place where to put this.
d2499 104
a2602 14
	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR3,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR3) | ACER_CCAR3_PI);
	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR1,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR1) &
	    ~(ACER_CHANSTATUS_RO|PCIIDE_CHAN_RO(0)|PCIIDE_CHAN_RO(1)));
	pciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR2,
	    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR2) &
	    ~ACER_CHANSTATUSREGS_RO);
	cr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG);
	cr |= (PCIIDE_CHANSTATUS_EN << PCI_INTERFACE_SHIFT);
	pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG, cr);
	/* Don't use cr, re-read the real register content instead */
	interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag,
	    PCI_CLASS_REG));
d2604 46
a2649 4
	if ((interface & PCIIDE_CHAN_EN(wdc_cp->channel)) == 0) {
		printf("%s: %s ignored (disabled)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
		return;
d2651 12
d2664 18
a2681 8
	pciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize);
	if (cp->hw_ok == 0)
		return;
	if (pciiide_chan_candisable(cp)) {
		cr &= ~(PCIIDE_CHAN_EN(wdc_cp->channel) << PCI_INTERFACE_SHIFT);
		pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG, cr);
	}
	pciide_map_compat_intr(pa, cp, wdc_cp->channel, interface);
@


1.8
log
@It is not ok to do #ifdef processing inside argument lists of calls, where
it is feasible the function is really a macro, like pci_intr_establish is
on alpha.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.7 1999/08/04 23:27:49 niklas Exp $     */
d618 2
d624 1
a624 1
		rv = 0;
a626 1
	wdc_cp->ctl_iot = pa->pa_iot;
d633 1
a633 1
		rv = 0;
@


1.7
log
@new bus_dma API, match it
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.6 1999/07/30 00:17:37 deraadt Exp $     */
d659 5
d665 1
a665 3
		    intrhandle, IPL_BIO, pciide_pci_intr, sc
#ifdef __OpenBSD__
		    , sc->sc_wdcdev.sc_dev.dv_xname
a666 1
			);
@


1.6
log
@printout flaws
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.5 1999/07/25 04:42:31 csapuntz Exp $     */
a798 3
#ifdef __OpenBSD__
#define BUS_DMA_COHERENT 0
#endif
a807 3
#ifdef __OpenBSD__
#undef BUS_DMA_COHERENT
#endif
@


1.5
log
@

I've gotten complaints about failed DMA with the Acer Labs PCI IDE
chipset. I will disable it until the arrival of the Acer databook so
I can validate the driver against some specs.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.4 1999/07/22 04:37:30 deraadt Exp $     */
d516 1
a516 1
			printf(" (unsupported) ");
d524 1
a524 1
				printf(" (unuseable) ");
@


1.4
log
@shorten dmesg; rename primary/secondary to channel 0/1; save space in
vendor/product tables
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.3 1999/07/20 07:48:12 fgsch Exp $     */
d323 1
d333 1
d352 1
d355 1
@


1.3
log
@Fix SIS 5597 define.
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.2 1999/07/19 00:32:44 csapuntz Exp $     */
d206 2
a207 3
	int ide_flags;
	int ide_num_channels;
	const char *ide_name;
d223 1
a223 1
	0,
a225 1
	"Generic PCI IDE controller",
d232 1
a232 1
	{ PCI_PRODUCT_INTEL_82092AA,
a234 1
	  "Intel 82092AA IDE controller",
d239 1
a239 1
	{ PCI_PRODUCT_INTEL_82371FB_IDE,
a241 1
	  "Intel 82371FB IDE controller (PIIX)",
d246 1
a246 1
	{ PCI_PRODUCT_INTEL_82371SB_IDE,
a248 1
	  "Intel 82371SB IDE Interface (PIIX3)",
d253 1
a253 1
	{ PCI_PRODUCT_INTEL_82371AB_IDE,
a255 1
	  "Intel 82371AB IDE controller (PIIX4)",
a258 5
	},
	{ 0,
	  0,
	  0,
	  NULL,
d263 1
a263 1
	{ PCI_PRODUCT_CMDTECH_640,
a265 1
	  "CMD Technology PCI0640",
d270 1
a270 1
	{ PCI_PRODUCT_CMDTECH_643,
a272 1
	  "CMD Technology PCI0643",
d277 1
a277 1
	{ PCI_PRODUCT_CMDTECH_646,
a279 1
	  "CMD Technology PCI0646",
a282 5
	},
	{ 0,
	  0,
	  0,
	  NULL,
d287 1
a287 1
	{ PCI_PRODUCT_VIATECH_VT82C586_IDE,
a289 1
	  "VIA Technologies VT82C586 (Apollo VP) IDE Controller",
d294 1
a294 1
	{ PCI_PRODUCT_VIATECH_VT82C586A_IDE,
a296 1
	  "VIA Technologies VT82C586A IDE Controller",
a299 5
	},
	{ 0,
	  0,
	  0,
	  NULL,
d304 1
a304 1
	{ PCI_PRODUCT_CONTAQ_82C693,
a306 1
	  "Contaq Microsystems CY82C693 IDE Controller",
a309 5
	},
	{ 0,
	  0,
	  0,
	  NULL,
d314 1
a314 1
	{ PCI_PRODUCT_SIS_5597,
a316 1
	  "Silicon Integrated System 5597/5598 IDE controller",
a319 5
	},
	{ 0,
	  0,
	  0,
	  NULL,
d324 1
a324 1
	{ PCI_PRODUCT_ALI_M5229,
a326 1
	  "Acer Labs M5229 UDMA IDE Controller",
a329 5
	},
	{ 0,
	  0,
	  0,
	  NULL,
d336 1
d340 12
a351 7
	{ PCI_VENDOR_INTEL, pciide_intel_products },
	{ PCI_VENDOR_CMDTECH, pciide_cmd_products },
	{ PCI_VENDOR_VIATECH, pciide_via_products },
	{ PCI_VENDOR_CONTAQ, pciide_cypress_products },
	{ PCI_VENDOR_SIS, pciide_sis_products },
	{ PCI_VENDOR_ALI, pciide_acer_products },
	{ 0, NULL }
d354 1
a354 1
#define	PCIIDE_CHANNEL_NAME(chan)	((chan) == 0 ? "primary" : "secondary")
d395 1
d397 3
a399 1
	for (vp = pciide_vendors; vp->ide_products != NULL; vp++)
d403 1
a403 1
	if ((pp = vp->ide_products) == NULL)
d406 1
a406 1
	for (; pp->ide_name != NULL; pp++)
d409 2
a410 2
    
	if (pp->ide_name == NULL)
a457 4
		printf(": %s (rev. 0x%02x)\n", devinfo,
		    PCI_REVISION(pa->pa_class));
	} else {
		printf(": %s\n", sc->sc_pp->ide_name);
d476 1
a476 1
			printf("%s: device disabled (at %s)\n",
d508 1
a508 2
		printf("%s: bus-master DMA support present",
		    sc->sc_wdcdev.sc_dev.dv_xname);
d512 1
a512 1
			printf(", but unused (no driver support)");
d520 1
a520 1
				printf(", but unused (couldn't map registers)");
d523 1
a523 2
					printf(", used without full driver "
					    "support");
d531 1
a531 2
		printf("%s: hardware does not support DMA",
		    sc->sc_wdcdev.sc_dev.dv_xname);
a532 1
	printf("\n");
d539 9
d556 2
a557 2
		    cp->wdc_channel.ch_queue =
			sc->pciide_channels[0].wdc_channel.ch_queue;
d559 3
a561 3
		    cp->wdc_channel.ch_queue =
		        malloc(sizeof(struct channel_queue), M_DEVBUF,
			M_NOWAIT);
d564 3
a566 3
		    printf("%s %s channel: "
			"can't allocate memory for command queue",
			sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
a568 6
		printf("%s: %s channel %s to %s mode\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,
		    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?
		      "configured" : "wired",
		    (interface & PCIIDE_INTERFACE_PCI(i)) ? "native-PCI" :
		      "compatibility");
d573 1
a573 1
		 * drive present. sc->hw_ok will be updated accordingly.
d616 1
a616 1
		printf("%s: couldn't map %s channel cmd regs\n",
d624 1
a624 1
		printf("%s: couldn't map %s channel ctl regs\n",
d678 1
a678 1
		printf("%s: couldn't map %s channel cmd regs\n",
d686 1
a686 1
		printf("%s: couldn't map %s channel ctl regs\n",
a1051 1
	struct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;
a1055 2
		printf("%s: disabling %s channel (no drives)\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
d1083 2
a1084 2
		printf("%s: no compatibility interrupt for use by %s "
		    "channel\n", sc->sc_wdcdev.sc_dev.dv_xname, cp->name);
d1217 1
a1217 1
		printf("%s: %s channel ignored (%s)\n",
d1598 1
a1598 1
		printf("%s: %s channel ignored (disabled)\n",
d1743 1
a1743 1
		printf("%s: %s channel ignored (disabled)\n",
d1776 1
a1776 1
		printf("%s: %s channel ignored (disabled)\n",
d2111 1
a2111 1
		printf("%s: %s channel ignored (disabled)\n",
d2267 1
a2267 1
		printf("%s: %s channel ignored (disabled)\n",
@


1.2
log
@

Lower chatiness
@
text
@d1 1
a1 1
/*      $OpenBSD: pciide.c,v 1.1 1999/07/18 21:25:19 csapuntz Exp $     */
d346 1
a346 1
	{ PCI_PRODUCT_SIS_5597_IDE,
@


1.1
log
@

Import of NetBSD ATA/IDE stuff.

Introduction of home-grown

To enable this stuff in your configuration, look at the NEWATA conf file
and go through

dev/isa/files.isa
dev/pci/files.pci
conf/files
arch/i386/conf/files.i386

and follow the instructions on commenting/uncommenting stuff
@
text
@d1 1
a1 1
/*      $OpenBSD: $     */
d56 1
a56 1
int wdcdebug_pciide_mask;
a820 1
	printf ("pciide_dma_table_setup: 1\n");
a824 1
	printf ("pciide_dma_table_setup: 2\n");
@

