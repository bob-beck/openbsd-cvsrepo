head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.12
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.10
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.4
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.20
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.18
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.14
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.12
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.10
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.8
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2;
locks; strict;
comment	@ * @;


1.19
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.18;
commitid	LS2TNeCue5R9L67C;

1.18
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.02.00.01.37;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.28.14.17.19;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.08.18.21.33;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.21.19.55.30;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.09.17.41.00;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.29.18.53.58;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.06.22.24.14;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.16.00.53.12;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.26.00.06.35;	author krw;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.08.25.10.13.30;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.12.15.40.33;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.15.06.01.30;	author krw;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.03.10.05.04.06;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.01.17.14.28;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.20.00.32.30;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.15.04.07.58;	author krw;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.25.57;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.43.03;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.10.29.00.33.29;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@/*	$OpenBSD: siop_pci_common.c,v 1.18 2010/07/23 07:47:13 jsg Exp $ */
/*	$NetBSD: siop_pci_common.c,v 1.25 2005/06/28 00:28:42 thorpej Exp $ */

/*
 * Copyright (c) 2000 Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* SYM53c8xx PCI-SCSI I/O Processors driver: PCI front-end */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#include <sys/endian.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/ic/siopreg.h>
#include <dev/ic/siopvar_common.h>
#include <dev/pci/siop_pci_common.h>

/* List (array, really :) of chips we know how to handle */
const struct siop_product_desc siop_products[] = {
	{ PCI_PRODUCT_SYMBIOS_810,
	0x00,
	SF_PCI_RL | SF_CHIP_LS,
	4, 8, 3, 250, 0
	},
	{ PCI_PRODUCT_SYMBIOS_810,
	0x10,
	SF_PCI_RL | SF_PCI_BOF | SF_CHIP_PF | SF_CHIP_LS,
	4, 8, 3, 250, 0
	},
	{ PCI_PRODUCT_SYMBIOS_815,
	0x00,
	SF_PCI_RL | SF_PCI_BOF,
	4, 8, 3, 250, 0
	},
	{ PCI_PRODUCT_SYMBIOS_820,
	0x00,
	SF_PCI_RL | SF_CHIP_LS | SF_BUS_WIDE,
	4, 8, 3, 250, 0
	},
	{ PCI_PRODUCT_SYMBIOS_825,
	0x00,
	SF_PCI_RL | SF_PCI_BOF | SF_BUS_WIDE,
	4, 8, 3, 250, 0
	},
	{ PCI_PRODUCT_SYMBIOS_825,
	0x10,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_LS | SF_CHIP_10REGS |
	SF_BUS_WIDE,
	7, 8, 3, 250, 4096
	},
	{ PCI_PRODUCT_SYMBIOS_860,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_PF | SF_CHIP_LS |
	SF_BUS_ULTRA,
	4, 8, 5, 125, 0
	},
	{ PCI_PRODUCT_SYMBIOS_875,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_LS | SF_CHIP_10REGS |
	SF_BUS_ULTRA | SF_BUS_WIDE,
	7, 16, 5, 125, 4096
	},
	{ PCI_PRODUCT_SYMBIOS_875,
	0x02,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_DBLR |
	SF_CHIP_LS | SF_CHIP_10REGS |
	SF_BUS_ULTRA | SF_BUS_WIDE,
	7, 16, 5, 125, 4096
	},
	{ PCI_PRODUCT_SYMBIOS_875J,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_DBLR |
	SF_CHIP_LS | SF_CHIP_10REGS |
	SF_BUS_ULTRA | SF_BUS_WIDE,
	7, 16, 5, 125, 4096
	},
	{ PCI_PRODUCT_SYMBIOS_885,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_DBLR |
	SF_CHIP_LS | SF_CHIP_10REGS |
	SF_BUS_ULTRA | SF_BUS_WIDE,
	7, 16, 5, 125, 4096
	},
	{ PCI_PRODUCT_SYMBIOS_895,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
	SF_CHIP_LS | SF_CHIP_10REGS |
	SF_BUS_ULTRA2 | SF_BUS_WIDE,
	7, 31, 7, 62, 4096
	},
	{ PCI_PRODUCT_SYMBIOS_896,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
	SF_CHIP_LS | SF_CHIP_10REGS |
	SF_BUS_ULTRA2 | SF_BUS_WIDE,
	7, 31, 7, 62, 8192
	},
	{ PCI_PRODUCT_SYMBIOS_895A,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
	SF_CHIP_LS | SF_CHIP_10REGS |
	SF_BUS_ULTRA2 | SF_BUS_WIDE,
	7, 31, 7, 62, 8192
	},
	{ PCI_PRODUCT_SYMBIOS_1010,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM |
	SF_CHIP_LS | SF_CHIP_10REGS | SF_CHIP_DFBC | SF_CHIP_DBLR |
	SF_CHIP_GEBUG |
	SF_BUS_ULTRA3 | SF_BUS_WIDE,
	7, 31, 0, 62, 8192
	},
	{ PCI_PRODUCT_SYMBIOS_1010,
	0x01,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM |
	SF_CHIP_LS | SF_CHIP_10REGS | SF_CHIP_DFBC | SF_CHIP_DBLR | SF_CHIP_DT |
	SF_CHIP_GEBUG |
	SF_BUS_ULTRA3 | SF_BUS_WIDE,
	7, 62, 0, 62, 8192
	},
	{ PCI_PRODUCT_SYMBIOS_1010_2,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM |
	SF_CHIP_LS | SF_CHIP_10REGS | SF_CHIP_DFBC | SF_CHIP_DBLR | SF_CHIP_DT |
	SF_CHIP_AAIP |
	SF_BUS_ULTRA3 | SF_BUS_WIDE,
	7, 62, 0, 62, 8192
	},
	{ PCI_PRODUCT_SYMBIOS_1510D,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
	SF_CHIP_LS | SF_CHIP_10REGS |
	SF_BUS_ULTRA2 | SF_BUS_WIDE,
	7, 31, 7, 62, 4096
	},
	{ 0,
	0x00,
	0x00,
	0, 0, 0, 0, 0
	},
};

const struct siop_product_desc *
siop_lookup_product(u_int32_t id, int rev)
{
	const struct siop_product_desc *pp;
	const struct siop_product_desc *rp = NULL;

	if (PCI_VENDOR(id) != PCI_VENDOR_SYMBIOS)
		return NULL;

	for (pp = siop_products; pp->product != 0; pp++) {
		if (PCI_PRODUCT(id) == pp->product && pp->revision <= rev)
			if (rp == NULL || pp->revision > rp->revision)
				rp = pp;
	}
	return rp;
}

int
siop_pci_attach_common(struct siop_pci_common_softc *pci_sc,
    struct siop_common_softc *siop_sc, struct pci_attach_args *pa,
    int (*intr)(void*))
{
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;
	const char *intrstr;
	pci_intr_handle_t intrhandle;
	bus_space_tag_t iot, memt;
	bus_space_handle_t ioh, memh;
	pcireg_t memtype;
	int memh_valid, ioh_valid;
	bus_addr_t ioaddr, memaddr;
	bus_size_t iosize, memsize, ramsize;

	pci_sc->sc_pp =
	    siop_lookup_product(pa->pa_id, PCI_REVISION(pa->pa_class));
	if (pci_sc->sc_pp == NULL) {
		printf(": broken match/attach!\n");
		return 0;
	}
	/* copy interesting infos about the chip */
	siop_sc->features = pci_sc->sc_pp->features;
#ifdef SIOP_SYMLED    /* XXX Should be a devprop! */
	siop_sc->features |= SF_CHIP_LED0;
#endif
	siop_sc->maxburst = pci_sc->sc_pp->maxburst;
	siop_sc->maxoff = pci_sc->sc_pp->maxoff;
	siop_sc->clock_div = pci_sc->sc_pp->clock_div;
	siop_sc->clock_period = pci_sc->sc_pp->clock_period;
	siop_sc->ram_size = pci_sc->sc_pp->ram_size;

	siop_sc->sc_reset = siop_pci_reset;
	pci_sc->sc_pc = pc;
	pci_sc->sc_tag = tag;
	siop_sc->sc_dmat = pa->pa_dmat;

	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, 0x14);
	switch (memtype) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		memh_valid = (pci_mapreg_map(pa, 0x14, memtype, 0,
		    &memt, &memh, &memaddr, &memsize, 0) == 0);
		break;
	default:
		memh_valid = 0;
	}

	ioh_valid = (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, &ioaddr, &iosize, 0) == 0);

	if (memh_valid) {
		siop_sc->sc_rt = memt;
		siop_sc->sc_rh = memh;
		siop_sc->sc_raddr = memaddr;
	} else if (ioh_valid) {
		siop_sc->sc_rt = iot;
		siop_sc->sc_rh = ioh;
		siop_sc->sc_raddr = ioaddr;
	} else {
		printf(": unable to map device registers\n");
		return 0;
	}

	if (pci_intr_map(pa, &intrhandle) != 0) {
		printf(": couldn't map interrupt\n");
		goto out;
	}
	intrstr = pci_intr_string(pa->pa_pc, intrhandle);
	pci_sc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_BIO,
	    intr, siop_sc, siop_sc->sc_dev.dv_xname);
	if (pci_sc->sc_ih != NULL) {
		printf(": %s",
		    intrstr ? intrstr : "?");
	} else {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto out;
	}

	if (siop_sc->features & SF_CHIP_RAM) {
		int bar;
		switch (memtype) {
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
			bar = 0x18;
			break;
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
			bar = 0x1c;
			break;
		default:
			printf(": invalid memory type %d\n", memtype);
			goto out;
		}
		if (pci_mapreg_map(pa, bar, memtype, 0,
                    &siop_sc->sc_ramt, &siop_sc->sc_ramh,
		    &siop_sc->sc_scriptaddr, &ramsize, 0) == 0) {
			printf(", using %luK of on-board RAM",
			    (u_long)ramsize / 1024);
		} else {
			printf(", can't map on-board RAM");
			siop_sc->features &= ~SF_CHIP_RAM;
		}
	}

	printf("\n");

	return (1);

 out:
	if (pci_sc->sc_ih) {
		pci_intr_disestablish(pa->pa_pc, pci_sc->sc_ih);
		pci_sc->sc_ih = NULL;
	}
	if (ioh_valid)
		bus_space_unmap(iot, ioh, iosize);
	if (memh_valid)
		bus_space_unmap(memt, memh, memsize);
	return (0);
}

void
siop_pci_reset(struct siop_common_softc *sc)
{
	int dmode;

	dmode = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_DMODE);
	if (sc->features & SF_PCI_RL)
		dmode |= DMODE_ERL;
	if (sc->features & SF_PCI_RM)
		dmode |= DMODE_ERMP;
	if (sc->features & SF_PCI_BOF)
		dmode |= DMODE_BOF;
	if (sc->features & SF_PCI_CLS)
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_DCNTL,
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_DCNTL) |
		    DCNTL_CLSE);
	if (sc->features & SF_PCI_WRI)
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST3,
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST3) |
		    CTEST3_WRIE);
	if (sc->maxburst) {
		int ctest5 = bus_space_read_1(sc->sc_rt, sc->sc_rh,
		    SIOP_CTEST5);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST4,
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST4) &
		    ~CTEST4_BDIS);
		dmode &= ~DMODE_BL_MASK;
		dmode |= ((sc->maxburst - 1) << DMODE_BL_SHIFT) & DMODE_BL_MASK;
		ctest5 &= ~CTEST5_BBCK;
		ctest5 |= (sc->maxburst - 1) & CTEST5_BBCK;
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST5, ctest5);
	} else {
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST4,
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST4) |
		    CTEST4_BDIS);
	}
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_DMODE, dmode);
}
@


1.18
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.17 2007/11/02 00:01:37 fgsch Exp $ */
d36 1
a36 2

#include <machine/endian.h>
@


1.17
log
@Fix ram size output botched in my last change; reported by
Pablo Méndez Hernández.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.16 2007/10/28 14:17:19 fgsch Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.16
log
@fix the panic reported in pr/5602 by correctly unmaping the space on error.
disestablish the interrupt on error as well. krw@@ comments and ok
tested by reporter via mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.15 2006/04/20 20:31:12 miod Exp $ */
d310 1
a310 1
			    (u_long)memsize / 1024);
@


1.15
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.14 2005/10/08 18:21:33 krw Exp $ */
d224 1
a224 1
	bus_size_t memsize, iosize;
d253 1
a253 1
		    &memt, &memh, &memaddr, NULL, 0) == 0);
d277 1
a277 2
		bus_space_unmap(siop_sc->sc_rt, siop_sc->sc_rh, iosize);
		return 0;
d290 1
a290 2
		bus_space_unmap(siop_sc->sc_rt, siop_sc->sc_rh, iosize);
		return 0;
d304 1
a304 1
			return 0;
d308 1
a308 1
		    &siop_sc->sc_scriptaddr, &memsize, 0) == 0) {
d319 12
a330 1
	return 1;
@


1.14
log
@ANSI function decs (thorpej via NetBSD), remove trailing whitespace
(perry via NetBSD), add SF_CHIP_AAIP flag (still unused) to 1010-66
(bouyer via NetBSD), add error handling if PCI memory type is invalid
(christos via NetBSD).  Note we are now sync'd up to latest (r1.25)
NetBSD source.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.13 2004/07/21 19:55:30 mickey Exp $ */
d311 2
a312 1
			printf(", using %dK of on-board RAM", memsize / 1024);
@


1.13
log
@remove hppa workarounds; from jkunz@@ pr3861
@
text
@d1 2
a2 2
/*	$OpenBSD: siop_pci_common.c,v 1.12 2003/10/09 17:41:00 mickey Exp $ */
/*	$NetBSD: siop_pci_common.c,v 1.17 2002/05/04 18:11:06 bouyer Exp $ */
d24 1
a24 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
d174 2
a175 1
	SF_BUS_ULTRA3 | SF_BUS_WIDE, 
d194 1
a194 3
siop_lookup_product(id, rev)
	u_int32_t id;
	int rev;
d211 3
a213 5
siop_pci_attach_common(pci_sc, siop_sc, pa, intr)
	struct siop_pci_common_softc *pci_sc;
	struct siop_common_softc *siop_sc;
	struct pci_attach_args *pa;
	int (*intr) (void*);
d216 1
a216 1
	pcitag_t tag = pa->pa_tag;    
d304 3
d324 1
a324 2
siop_pci_reset(sc)
	struct siop_common_softc *sc;
@


1.12
log
@remove duplicate ifdef __hppa__ that somehow has gotten in there
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.11 2003/09/29 18:53:58 mickey Exp $ */
a236 4
#ifdef __hppa__
	/* XXX On board ram doesn't work (yet?) on hppa. */
	siop_sc->features &= ~SF_CHIP_RAM;
#endif
@


1.11
log
@better dmesg output including onboard memory size when present, free resources on failures; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.10 2003/09/06 22:24:14 krw Exp $ */
a301 3
#ifdef __hppa__
	siop_sc->features &= ~SF_CHIP_RAM;
#endif
@


1.10
log
@A couple of hppa-only changes, allowing siop to work on pci hppa
machines.

Align siop_xfer on 128 byte boundary, and don't use on-board RAM.
Aligning siop_xfer will be made general, post-3.4.

From mickey@@.

ok deraadt@@ mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.9 2002/09/16 00:53:12 krw Exp $ */
d227 1
d232 1
a232 1
		printf("siop: broken match/attach!\n");
d267 1
a267 1
	    &iot, &ioh, &ioaddr, NULL, 0) == 0);
d278 1
a278 2
		printf("\n%s: unable to map device registers\n",
		    siop_sc->sc_dev.dv_xname);
d282 23
d317 2
a318 2
		    &siop_sc->sc_scriptaddr, NULL, 0) == 0) {
			printf(" using on-board RAM");
d320 1
a320 1
			printf(" can't map on-board RAM");
d325 2
a326 19
	if (pci_intr_map(pa, &intrhandle) != 0) {
		printf("\n%s: couldn't map interrupt\n",
		    siop_sc->sc_dev.dv_xname);
		return 0;
	}
	intrstr = pci_intr_string(pa->pa_pc, intrhandle);
	pci_sc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_BIO,
	    intr, siop_sc, siop_sc->sc_dev.dv_xname);
	if (pci_sc->sc_ih != NULL) {
		printf(" %s\n",
		    intrstr ? intrstr : "?");
	} else {
		printf("\n%s: couldn't establish interrupt",
		    siop_sc->sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return 0;
	}
@


1.9
log
@Resync siop with NetBSD. Make strong effort to minimize
differences, undoing whitespace, spelling, etc. changes
and adopting the NetBSD code instead of equivalent home
grown code for PPR negotiation, etc.

siop.c            1.21 -> 1.64
siop_common.c     1.12 -> 1.30
siopreg.h         1.7  -> 1.13
siopvar.h         1.13 -> 1.18
siopvar_common.h  1.10 -> 1.21
ncr53cxxx.c       1.5  -> 1.10
siop.ss           1.12 -> 1.17
siop_pci.c        1.8  -> 1.11
siop_pci_common.c 1.6  -> 1.17
siop_pci_common.h 1.2  -> 1.4

Many fixes, add 1010-66 support, restructure things to prepare for
addition of esiop, osiop and oosiop drivers.

tested on various archs by art@@, millert@@, wilfried@@, jason@@,
Dan Weeks.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.8 2001/10/26 00:06:35 krw Exp $ */
d236 4
@


1.8
log
@Fix a problem with the probe message being printed for cards with no
RAM.

A card that did not have RAM was causing a probe message with no
terminating '\n', but with a dangling ', '.

Problem noted by Todd T. Fries.
@
text
@d1 2
a2 2
/*	$OpenBSD: siop_pci_common.c,v 1.7 2001/08/25 10:13:30 art Exp $ */
/*	$NetBSD: siop_pci_common.c,v 1.6 2001/01/10 15:50:20 thorpej Exp $	*/
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer
d52 1
a52 1
#include <dev/ic/siopvar.h>
d60 1
a60 1
	4, 8, 3, SF_CLOCK_2500, 0
d65 1
a65 1
	4, 8, 3, SF_CLOCK_2500, 0
d70 1
a70 1
	4, 8, 3, SF_CLOCK_2500, 0
d75 1
a75 1
	4, 8, 3, SF_CLOCK_2500, 0
d80 1
a80 1
	4, 8, 3, SF_CLOCK_2500, 0
d87 1
a87 1
	7, 8, 3, SF_CLOCK_2500, 4096
d94 1
a94 1
	4, 8, 5, SF_CLOCK_1250, 0
d101 1
a101 1
	7, 16, 5, SF_CLOCK_1250, 4096
d109 1
a109 1
	7, 16, 5, SF_CLOCK_1250, 4096
d117 1
a117 1
	7, 16, 5, SF_CLOCK_1250, 4096
d125 1
a125 1
	7, 16, 5, SF_CLOCK_1250, 4096
d133 1
a133 1
	7, 31, 7, SF_CLOCK_625, 4096
d135 1
a135 1
	{ PCI_PRODUCT_SYMBIOS_895A,
d138 1
a138 1
	SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
d141 1
a141 1
	7, 31, 7, SF_CLOCK_625, 8192
d143 1
a143 1
	{ PCI_PRODUCT_SYMBIOS_896,
d146 1
a146 1
	SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
d149 1
a149 1
	7, 31, 7, SF_CLOCK_625, 8192
d154 22
a175 4
	SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
	SF_CHIP_LS | SF_CHIP_10REGS | SF_CHIP_C10 |
	SF_BUS_ULTRA2 | SF_BUS_WIDE,
	7, 62, 0, SF_CLOCK_625, 8192
d183 1
a183 1
	7, 31, 7, SF_CLOCK_625, 4096
d212 3
a214 2
siop_pci_attach_common(sc, pa)
	struct siop_pci_softc *sc;
d216 1
d228 3
a230 2
	sc->sc_pp = siop_lookup_product(pa->pa_id, PCI_REVISION(pa->pa_class));
	if (sc->sc_pp == NULL) {
d235 14
a248 11
	sc->siop.features = sc->sc_pp->features;
	sc->siop.maxburst = sc->sc_pp->maxburst;
	sc->siop.maxoff = sc->sc_pp->maxoff;
	sc->siop.clock_div = sc->sc_pp->clock_div;
	sc->siop.scf_index = sc->sc_pp->scf_index;
	sc->siop.ram_size = sc->sc_pp->ram_size;

	sc->siop.sc_reset = siop_pci_reset;
	sc->sc_pc = pc;
	sc->sc_tag = tag;
	sc->siop.sc_dmat = pa->pa_dmat;
d265 3
a267 3
		sc->siop.sc_rt = memt;
		sc->siop.sc_rh = memh;
		sc->siop.sc_raddr = memaddr;
d269 3
a271 3
		sc->siop.sc_rt = iot;
		sc->siop.sc_rh = ioh;
		sc->siop.sc_raddr = ioaddr;
d274 1
a274 1
		    sc->siop.sc_dev.dv_xname);
d278 1
a278 1
	if (sc->siop.features & SF_CHIP_RAM) {
d289 7
a295 3
                    &sc->siop.sc_ramt, &sc->siop.sc_ramh,
		    &sc->siop.sc_scriptaddr, NULL, 0) != 0)
			sc->siop.features &= ~SF_CHIP_RAM;
d298 1
a298 1
	if (pci_intr_map(pa, &intrhandle)) {
d300 1
a300 1
		    sc->siop.sc_dev.dv_xname);
d304 6
a309 3
	sc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_BIO,
	    siop_intr, &sc->siop, sc->siop.sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
d311 1
a311 1
		    sc->siop.sc_dev.dv_xname);
a316 6

	printf(": %s", (intrstr != NULL) ? intrstr : "irq ?");
	if (sc->siop.features & SF_CHIP_RAM)
		printf(", has RAM");
	printf("\n");

d322 1
a322 1
	struct siop_softc *sc;
d352 1
a352 1
	} else if ((sc->features & SF_CHIP_C10) == 0) {
@


1.8.2.1
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: siop_pci_common.c,v 1.17 2002/05/04 18:11:06 bouyer Exp $ */
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer.
d52 1
a52 1
#include <dev/ic/siopvar_common.h>
d60 1
a60 1
	4, 8, 3, 250, 0
d65 1
a65 1
	4, 8, 3, 250, 0
d70 1
a70 1
	4, 8, 3, 250, 0
d75 1
a75 1
	4, 8, 3, 250, 0
d80 1
a80 1
	4, 8, 3, 250, 0
d87 1
a87 1
	7, 8, 3, 250, 4096
d94 1
a94 1
	4, 8, 5, 125, 0
d101 1
a101 1
	7, 16, 5, 125, 4096
d109 1
a109 1
	7, 16, 5, 125, 4096
d117 1
a117 1
	7, 16, 5, 125, 4096
d125 1
a125 1
	7, 16, 5, 125, 4096
d133 1
a133 1
	7, 31, 7, 62, 4096
d135 1
a135 1
	{ PCI_PRODUCT_SYMBIOS_896,
d138 1
a138 1
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
d141 1
a141 1
	7, 31, 7, 62, 8192
d143 1
a143 1
	{ PCI_PRODUCT_SYMBIOS_895A,
d146 1
a146 1
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
d149 1
a149 1
	7, 31, 7, 62, 8192
d154 4
a157 22
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM |
	SF_CHIP_LS | SF_CHIP_10REGS | SF_CHIP_DFBC | SF_CHIP_DBLR |
	SF_CHIP_GEBUG |
	SF_BUS_ULTRA3 | SF_BUS_WIDE,
	7, 31, 0, 62, 8192
	},
	{ PCI_PRODUCT_SYMBIOS_1010,
	0x01,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM |
	SF_CHIP_LS | SF_CHIP_10REGS | SF_CHIP_DFBC | SF_CHIP_DBLR | SF_CHIP_DT |
	SF_CHIP_GEBUG |
	SF_BUS_ULTRA3 | SF_BUS_WIDE,
	7, 62, 0, 62, 8192
	},
	{ PCI_PRODUCT_SYMBIOS_1010_2,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM |
	SF_CHIP_LS | SF_CHIP_10REGS | SF_CHIP_DFBC | SF_CHIP_DBLR | SF_CHIP_DT |
	SF_BUS_ULTRA3 | SF_BUS_WIDE, 
	7, 62, 0, 62, 8192
d165 1
a165 1
	7, 31, 7, 62, 4096
d194 2
a195 3
siop_pci_attach_common(pci_sc, siop_sc, pa, intr)
	struct siop_pci_common_softc *pci_sc;
	struct siop_common_softc *siop_sc;
a196 1
	int (*intr) (void*);
d208 2
a209 3
	pci_sc->sc_pp =
	    siop_lookup_product(pa->pa_id, PCI_REVISION(pa->pa_class));
	if (pci_sc->sc_pp == NULL) {
d214 11
a224 14
	siop_sc->features = pci_sc->sc_pp->features;
#ifdef SIOP_SYMLED    /* XXX Should be a devprop! */
	siop_sc->features |= SF_CHIP_LED0;
#endif
	siop_sc->maxburst = pci_sc->sc_pp->maxburst;
	siop_sc->maxoff = pci_sc->sc_pp->maxoff;
	siop_sc->clock_div = pci_sc->sc_pp->clock_div;
	siop_sc->clock_period = pci_sc->sc_pp->clock_period;
	siop_sc->ram_size = pci_sc->sc_pp->ram_size;

	siop_sc->sc_reset = siop_pci_reset;
	pci_sc->sc_pc = pc;
	pci_sc->sc_tag = tag;
	siop_sc->sc_dmat = pa->pa_dmat;
d241 3
a243 3
		siop_sc->sc_rt = memt;
		siop_sc->sc_rh = memh;
		siop_sc->sc_raddr = memaddr;
d245 3
a247 3
		siop_sc->sc_rt = iot;
		siop_sc->sc_rh = ioh;
		siop_sc->sc_raddr = ioaddr;
d250 1
a250 1
		    siop_sc->sc_dev.dv_xname);
d254 1
a254 1
	if (siop_sc->features & SF_CHIP_RAM) {
d265 3
a267 7
                    &siop_sc->sc_ramt, &siop_sc->sc_ramh,
		    &siop_sc->sc_scriptaddr, NULL, 0) == 0) {
			printf(" using on-board RAM");
		} else {
			printf(" can't map on-board RAM");
			siop_sc->features &= ~SF_CHIP_RAM;
		}
d270 1
a270 1
	if (pci_intr_map(pa, &intrhandle) != 0) {
d272 1
a272 1
		    siop_sc->sc_dev.dv_xname);
d276 3
a278 6
	pci_sc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_BIO,
	    intr, siop_sc, siop_sc->sc_dev.dv_xname);
	if (pci_sc->sc_ih != NULL) {
		printf(" %s\n",
		    intrstr ? intrstr : "?");
	} else {
d280 1
a280 1
		    siop_sc->sc_dev.dv_xname);
d286 6
d297 1
a297 1
	struct siop_common_softc *sc;
d327 1
a327 1
	} else {
@


1.7
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.6 2001/06/12 15:40:33 niklas Exp $ */
d278 1
a278 3
	if (sc->sc_ih != NULL)
		printf(": %s, ", (intrstr != NULL) ? intrstr : "irq ?");
	else {
d287 1
d289 2
a290 1
		printf("has RAM\n");
@


1.6
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.5 2001/04/15 06:01:30 krw Exp $ */
d270 1
a270 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &intrhandle)) {
@


1.5
log
@Support U160 on 53c1010 chips.

Add support for PPR negotiations and DT transfers,
and the preservation and restoration of the
SCNTL4 register which controls Ultra3 transfers.

Redo sync lookup, since the same period factor
can mean two things depending on whether you are
using DT or ST. Keep a minimum allowed ST period
factor, and a minimum allowd DT period factor for
each adapter.

Currently NO support for QAS or IUS or AIP.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.4 2001/03/10 05:04:06 krw Exp $ */
d231 1
a231 1
		    &memt, &memh, &memaddr, NULL) == 0);
d238 1
a238 1
	    &iot, &ioh, &ioaddr, NULL) == 0);
d266 1
a266 1
		    &sc->siop.sc_scriptaddr, NULL) != 0)
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.5 2001/04/15 06:01:30 krw Exp $ */
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.5.4.1 2001/05/14 22:25:57 niklas Exp $ */
d231 1
a231 1
		    &memt, &memh, &memaddr, NULL, 0) == 0);
d238 1
a238 1
	    &iot, &ioh, &ioaddr, NULL, 0) == 0);
d266 1
a266 1
		    &sc->siop.sc_scriptaddr, NULL, 0) != 0)
@


1.5.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.5.4.2 2001/07/04 10:43:03 niklas Exp $ */
d270 2
a271 1
	if (pci_intr_map(pa, &intrhandle)) {
d279 3
a281 1
	if (sc->sc_ih == NULL) {
a289 1
	printf(": %s", (intrstr != NULL) ? intrstr : "irq ?");
d291 1
a291 2
		printf(", has RAM");
	printf("\n");
@


1.5.4.4
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: siop_pci_common.c,v 1.17 2002/05/04 18:11:06 bouyer Exp $ */
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer.
d52 1
a52 1
#include <dev/ic/siopvar_common.h>
d60 1
a60 1
	4, 8, 3, 250, 0
d65 1
a65 1
	4, 8, 3, 250, 0
d70 1
a70 1
	4, 8, 3, 250, 0
d75 1
a75 1
	4, 8, 3, 250, 0
d80 1
a80 1
	4, 8, 3, 250, 0
d87 1
a87 1
	7, 8, 3, 250, 4096
d94 1
a94 1
	4, 8, 5, 125, 0
d101 1
a101 1
	7, 16, 5, 125, 4096
d109 1
a109 1
	7, 16, 5, 125, 4096
d117 1
a117 1
	7, 16, 5, 125, 4096
d125 1
a125 1
	7, 16, 5, 125, 4096
d133 1
a133 1
	7, 31, 7, 62, 4096
d135 1
a135 1
	{ PCI_PRODUCT_SYMBIOS_896,
d138 1
a138 1
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
d141 1
a141 1
	7, 31, 7, 62, 8192
d143 1
a143 1
	{ PCI_PRODUCT_SYMBIOS_895A,
d146 1
a146 1
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM | SF_CHIP_QUAD |
d149 1
a149 1
	7, 31, 7, 62, 8192
d154 4
a157 22
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM |
	SF_CHIP_LS | SF_CHIP_10REGS | SF_CHIP_DFBC | SF_CHIP_DBLR |
	SF_CHIP_GEBUG |
	SF_BUS_ULTRA3 | SF_BUS_WIDE,
	7, 31, 0, 62, 8192
	},
	{ PCI_PRODUCT_SYMBIOS_1010,
	0x01,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM |
	SF_CHIP_LS | SF_CHIP_10REGS | SF_CHIP_DFBC | SF_CHIP_DBLR | SF_CHIP_DT |
	SF_CHIP_GEBUG |
	SF_BUS_ULTRA3 | SF_BUS_WIDE,
	7, 62, 0, 62, 8192
	},
	{ PCI_PRODUCT_SYMBIOS_1010_2,
	0x00,
	SF_PCI_RL | SF_PCI_CLS | SF_PCI_WRI | SF_PCI_RM |
	SF_CHIP_LEDC | SF_CHIP_FIFO | SF_CHIP_PF | SF_CHIP_RAM |
	SF_CHIP_LS | SF_CHIP_10REGS | SF_CHIP_DFBC | SF_CHIP_DBLR | SF_CHIP_DT |
	SF_BUS_ULTRA3 | SF_BUS_WIDE, 
	7, 62, 0, 62, 8192
d165 1
a165 1
	7, 31, 7, 62, 4096
d194 2
a195 3
siop_pci_attach_common(pci_sc, siop_sc, pa, intr)
	struct siop_pci_common_softc *pci_sc;
	struct siop_common_softc *siop_sc;
a196 1
	int (*intr) (void*);
d208 2
a209 3
	pci_sc->sc_pp =
	    siop_lookup_product(pa->pa_id, PCI_REVISION(pa->pa_class));
	if (pci_sc->sc_pp == NULL) {
d214 11
a224 14
	siop_sc->features = pci_sc->sc_pp->features;
#ifdef SIOP_SYMLED    /* XXX Should be a devprop! */
	siop_sc->features |= SF_CHIP_LED0;
#endif
	siop_sc->maxburst = pci_sc->sc_pp->maxburst;
	siop_sc->maxoff = pci_sc->sc_pp->maxoff;
	siop_sc->clock_div = pci_sc->sc_pp->clock_div;
	siop_sc->clock_period = pci_sc->sc_pp->clock_period;
	siop_sc->ram_size = pci_sc->sc_pp->ram_size;

	siop_sc->sc_reset = siop_pci_reset;
	pci_sc->sc_pc = pc;
	pci_sc->sc_tag = tag;
	siop_sc->sc_dmat = pa->pa_dmat;
d241 3
a243 3
		siop_sc->sc_rt = memt;
		siop_sc->sc_rh = memh;
		siop_sc->sc_raddr = memaddr;
d245 3
a247 3
		siop_sc->sc_rt = iot;
		siop_sc->sc_rh = ioh;
		siop_sc->sc_raddr = ioaddr;
d250 1
a250 1
		    siop_sc->sc_dev.dv_xname);
d254 1
a254 1
	if (siop_sc->features & SF_CHIP_RAM) {
d265 3
a267 7
                    &siop_sc->sc_ramt, &siop_sc->sc_ramh,
		    &siop_sc->sc_scriptaddr, NULL, 0) == 0) {
			printf(" using on-board RAM");
		} else {
			printf(" can't map on-board RAM");
			siop_sc->features &= ~SF_CHIP_RAM;
		}
d270 1
a270 1
	if (pci_intr_map(pa, &intrhandle) != 0) {
d272 1
a272 1
		    siop_sc->sc_dev.dv_xname);
d276 3
a278 6
	pci_sc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_BIO,
	    intr, siop_sc, siop_sc->sc_dev.dv_xname);
	if (pci_sc->sc_ih != NULL) {
		printf(" %s\n",
		    intrstr ? intrstr : "?");
	} else {
d280 1
a280 1
		    siop_sc->sc_dev.dv_xname);
d286 6
d297 1
a297 1
	struct siop_common_softc *sc;
d327 1
a327 1
	} else {
@


1.5.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a226 1
	bus_size_t memsize, iosize;
d231 1
a231 1
		printf(": broken match/attach!\n");
a235 4
#ifdef __hppa__
	/* XXX On board ram doesn't work (yet?) on hppa. */
	siop_sc->features &= ~SF_CHIP_RAM;
#endif
d262 1
a262 1
	    &iot, &ioh, &ioaddr, &iosize, 0) == 0);
d273 2
a274 21
		printf(": unable to map device registers\n");
		return 0;
	}

	if (pci_intr_map(pa, &intrhandle) != 0) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(siop_sc->sc_rt, siop_sc->sc_rh, iosize);
		return 0;
	}
	intrstr = pci_intr_string(pa->pa_pc, intrhandle);
	pci_sc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_BIO,
	    intr, siop_sc, siop_sc->sc_dev.dv_xname);
	if (pci_sc->sc_ih != NULL) {
		printf(": %s",
		    intrstr ? intrstr : "?");
	} else {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(siop_sc->sc_rt, siop_sc->sc_rh, iosize);
d290 2
a291 2
		    &siop_sc->sc_scriptaddr, &memsize, 0) == 0) {
			printf(", using %dK of on-board RAM", memsize / 1024);
d293 1
a293 1
			printf(", can't map on-board RAM");
d298 19
a316 2
	printf("\n");

@


1.4
log
@First support for 53c1010 chip. This enables support up to U2W for
either or both channels on the 53c1010. U3W/U160 support coming.

The particulars of 53c1010 support was derived from the FreeBSD/Linux
sym-2 driver under development by Gerard ROUDIER (groudier@@FreeBSD.org).

This first support ensures that registers and bits now reserved are
not used by the 53c1010. It uses the new DFBC register to obtain
DMA FIFO relics.

A single new feature (SF_CHIP_C10) was added, rather than a new
feature for each change the 53c1010 incorporates.

These changes were sufficient to get the imbedded 53c1010 on a Tyan
S2510U3NG board to support installation of OpenBSD to a Quantum Atlas
10K2 drive, and several subsequent 'make build' and 'make release'
cycles using disks on both channels, with and without
softupdates.

More 53c1010 specific code is yet to be extracted from sym-2,
including the changes necessary to enable U160.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.3 2001/03/01 17:14:28 krw Exp $ */
d60 1
a60 1
	4, 8, 3, 250, 0
d65 1
a65 1
	4, 8, 3, 250, 0
d70 1
a70 1
	4, 8, 3, 250, 0
d75 1
a75 1
	4, 8, 3, 250, 0
d80 1
a80 1
	4, 8, 3, 250, 0
d87 1
a87 1
	7, 8, 3, 250, 4096
d94 1
a94 1
	4, 8, 5, 125, 0
d101 1
a101 1
	7, 16, 5, 125, 4096
d109 1
a109 1
	7, 16, 5, 125, 4096
d117 1
a117 1
	7, 16, 5, 125, 4096
d125 1
a125 1
	7, 16, 5, 125, 4096
d133 1
a133 1
	7, 31, 7, 62, 4096
d141 1
a141 1
	7, 31, 7, 62, 8192
d149 1
a149 1
	7, 31, 7, 62, 8192
d157 1
a157 1
	7, 31, 0, 62, 8192
d165 1
a165 1
	7, 31, 7, 62, 4096
d218 1
a218 1
	sc->siop.clock_period = sc->sc_pp->clock_period;
@


1.3
log
@Typo police: various misspelling, capitalizations, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.2 2001/02/20 00:32:30 krw Exp $ */
d135 1
a135 1
	{ PCI_PRODUCT_SYMBIOS_896,
d143 1
a143 1
	{ PCI_PRODUCT_SYMBIOS_895A,
d151 8
d328 1
a328 1
	} else {
@


1.2
log
@Tone down the verbosity level on the siop driver, print negotiation
results on one line, during boot polling only.

Force wide/sync negotiations for all targets during boot.

Delete extraneous name field and associated strings that duplicate
info provided in INQUIRY data.

Actually timeout during polling rather than wait forever for
ITSDONE.

Remove unneeded check for SCSI_POLL before calling scsi_done(). Makes
logic conform to other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_pci_common.c,v 1.1 2001/02/15 04:07:58 krw Exp $ */
d202 1
a202 1
		printf("sym: broken match/attach!!\n");
@


1.1
log
@Import siop, a replacement for the ncr SCSI driver, from NetBSD.

Written for NetBSD by Manuel Bouyer.

Tested with various cards on i386 and alpha.

Outstanding issue: doesn't work with PowerPC yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a58 1
	"Symbios Logic 53c810 (fast scsi)",
a63 1
	"Symbios Logic 53c810a (fast scsi)",
a68 1
	"Symbios Logic 53c815 (fast scsi)",
a73 1
	"Symbios Logic 53c820 (fast wide scsi)",
a78 1
	"Symbios Logic 53c825 (fast wide scsi)",
a83 1
	"Symbios Logic 53c825a (fast wide scsi)",
a90 1
	"Symbios Logic 53c860 (ultra scsi)",
a97 1
	"Symbios Logic 53c875 (ultra-wide scsi)",
a104 1
	"Symbios Logic 53c875 (ultra-wide scsi)",
a112 1
	"Symbios Logic 53c875j (ultra-wide scsi)",
a120 1
	"Symbios Logic 53c885 (ultra-wide scsi)",
a128 1
	"Symbios Logic 53c895 (ultra2-wide scsi)",
a136 1
	"Symbios Logic 53c896 (ultra2-wide scsi)",
a144 1
	"Symbios Logic 53c895a (ultra2-wide scsi)",
a152 1
	"Symbios Logic 53c1510d (ultra2-wide scsi)",
a160 1
	NULL,
d177 1
a177 1
	for (pp = siop_products; pp->name != NULL; pp++) {
a213 1
	printf(": %s\n", sc->sc_pp->name);
d241 1
a241 1
		printf("%s: unable to map device registers\n",
d258 1
a258 6
		    &sc->siop.sc_scriptaddr, NULL) == 0) {
			printf("%s: using on-board RAM\n",
			    sc->siop.sc_dev.dv_xname);
		} else {
			printf("%s: can't map on-board RAM\n",
			    sc->siop.sc_dev.dv_xname);
a259 1
		}
d264 1
a264 1
		printf("%s: couldn't map interrupt\n",
d271 4
a274 6
	if (sc->sc_ih != NULL) {
		printf("%s: interrupting at %s\n",
		    sc->siop.sc_dev.dv_xname,
		    intrstr ? intrstr : "unknown interrupt");
	} else {
		printf("%s: couldn't establish interrupt",
d281 4
@

