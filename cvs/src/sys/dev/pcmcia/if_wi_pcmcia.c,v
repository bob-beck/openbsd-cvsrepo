head	1.74;
access;
symbols
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.74.0.4
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.73.0.6
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.73.0.4
	OPENBSD_5_7_BASE:1.73
	OPENBSD_5_6:1.72.0.6
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.72.0.4
	OPENBSD_5_5_BASE:1.72
	OPENBSD_5_4:1.70.0.10
	OPENBSD_5_4_BASE:1.70
	OPENBSD_5_3:1.70.0.8
	OPENBSD_5_3_BASE:1.70
	OPENBSD_5_2:1.70.0.6
	OPENBSD_5_2_BASE:1.70
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.4
	OPENBSD_5_0:1.70.0.2
	OPENBSD_5_0_BASE:1.70
	OPENBSD_4_9:1.69.0.2
	OPENBSD_4_9_BASE:1.69
	OPENBSD_4_8:1.68.0.4
	OPENBSD_4_8_BASE:1.68
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.67.0.4
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.66.0.10
	OPENBSD_4_5_BASE:1.66
	OPENBSD_4_4:1.66.0.8
	OPENBSD_4_4_BASE:1.66
	OPENBSD_4_3:1.66.0.6
	OPENBSD_4_3_BASE:1.66
	OPENBSD_4_2:1.66.0.4
	OPENBSD_4_2_BASE:1.66
	OPENBSD_4_1:1.66.0.2
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.65.0.2
	OPENBSD_4_0_BASE:1.65
	OPENBSD_3_9:1.64.0.2
	OPENBSD_3_9_BASE:1.64
	OPENBSD_3_8:1.62.0.4
	OPENBSD_3_8_BASE:1.62
	OPENBSD_3_7:1.62.0.2
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.49.0.2
	OPENBSD_3_6_BASE:1.49
	SMP_SYNC_A:1.49
	SMP_SYNC_B:1.49
	OPENBSD_3_5:1.45.0.2
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	UBC_SYNC_A:1.40
	OPENBSD_3_3:1.40.0.2
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.38.0.2
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	UBC_SYNC_B:1.38
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SMP:1.7.0.2;
locks; strict;
comment	@ * @;


1.74
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.73;
commitid	5gdEnqVoJuTuwdTu;

1.73
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.72;
commitid	yM2VFFhpDTeFQlve;

1.72
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2013.11.14.12.33.15;	author dlg;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.29.21.53.53;	author sthen;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.26.19.46.28;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.20.20.31.13;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2005.10.31.05.37.13;	author jsg;	state Exp;
branches;
next	1.63;

1.63
date	2005.09.18.09.24.04;	author jsg;	state Exp;
branches;
next	1.62;

1.62
date	2005.03.13.04.34.43;	author dlg;	state Exp;
branches;
next	1.61;

1.61
date	2005.03.06.23.32.07;	author jsg;	state Exp;
branches;
next	1.60;

1.60
date	2005.01.27.17.04.56;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2005.01.21.03.32.21;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2005.01.20.00.44.28;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2005.01.11.22.07.58;	author drahn;	state Exp;
branches;
next	1.56;

1.56
date	2004.11.23.21.12.23;	author fgsch;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.22.08.48.38;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2004.10.20.12.53.28;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2004.10.11.15.16.37;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2004.09.30.14.24.05;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2004.09.27.03.49.14;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2004.09.25.02.01.31;	author fgsch;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.04.18.03.35;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.01.17.35.58;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.03.16.58.11;	author drahn;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.06.21.08.57;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.16.03.20.00;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.26.15.34.16;	author drahn;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.06.20.53.57;	author drahn;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.14.22.06.48;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.06.21.17.50;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.26.18.58.32;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.09.11.00.27;	author fgsch;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.01.13.31.06;	author fgsch;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.25.15.13.09;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.22.22.10.38;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.21.08.31.09;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.20.17.10.56;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.09.22.34.16;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.08.00.01.25;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.28.02.14.09;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.17.17.33.44;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.07.23.23.49;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.06.21.58.12;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.06.20.31.56;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.06.00.58.05;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.05.15.35.15;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.04.18.44.35;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.02.03.57.05;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.29.18.54.07;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.28.16.45.52;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.22.14.36.04;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.04.16.28.02;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.05.21.04.11;	author mickey;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.11.27.18.12.03;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.20.23.39.51;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.02.22.07.00;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.28.19.23.52;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.25.17.25.33;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.25.16.18.46;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.23.01.56.10;	author millert;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.06.11.00.50.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.07.22.41.00;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.07.04.49.07;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.06.18.53.49;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.22.11.04.50;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.15.02.40.35;	author millert;	state Exp;
branches;
next	;

1.7.2.1
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.11.13.21.10.03;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.12.05.00.43.31;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.02.19.10.56.31;	author niklas;	state Exp;
branches;
next	1.7.2.8;

1.7.2.8
date	2004.06.05.23.12.55;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.37;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2003.05.19.22.19.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.74
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/* $OpenBSD: if_wi_pcmcia.c,v 1.73 2014/12/22 02:28:52 tedu Exp $ */
/* $NetBSD: if_wi_pcmcia.c,v 1.14 2001/11/26 04:34:56 ichiro Exp $ */

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	From: if_wi.c,v 1.7 1999/07/04 14:40:22 wpaul Exp $
 */

/*
 * Lucent WaveLAN/IEEE 802.11 PCMCIA driver for OpenBSD.
 *
 * Originally written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/tree.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_ioctl.h>

#include <machine/bus.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>

#include <dev/ic/if_wireg.h>
#include <dev/ic/if_wi_ieee.h>
#include <dev/ic/if_wivar.h>

int	wi_pcmcia_match(struct device *, void *, void *);
void	wi_pcmcia_attach(struct device *, struct device *, void *);
int	wi_pcmcia_detach(struct device *, int);
int	wi_pcmcia_activate(struct device *, int);
void	wi_pcmcia_wakeup(struct wi_softc *);

struct wi_pcmcia_softc {
	struct wi_softc sc_wi;

	struct pcmcia_io_handle	sc_pcioh;
	int			sc_io_window;
	struct pcmcia_function	*sc_pf;
};

struct cfattach wi_pcmcia_ca = {
	sizeof (struct wi_pcmcia_softc), wi_pcmcia_match, wi_pcmcia_attach,
	wi_pcmcia_detach, wi_pcmcia_activate
};

static const struct wi_pcmcia_product {
	u_int16_t	pp_vendor;
	u_int16_t	pp_product;
	const char	*pp_cisinfo[4];
} wi_pcmcia_products[] = {
	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_LUCENT_WAVELAN_IEEE
	},
	{ PCMCIA_VENDOR_3COM,
	  PCMCIA_PRODUCT_3COM_3CRWE737A,
	  PCMCIA_CIS_3COM_3CRWE737A
	},
	{ PCMCIA_VENDOR_3COM,
	  PCMCIA_PRODUCT_3COM_3CRWE777A,
	  PCMCIA_CIS_3COM_3CRWE777A
	},
	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_PCC_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCC_11
	},
	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_PCCA_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCA_11
	},
	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_PCCB_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCB_11
	},
	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_PCCL_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCL_11
	},
	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_WLCFL_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_WLCFL_11
	},
	{ PCMCIA_VENDOR_INTEL,
	  PCMCIA_PRODUCT_INTEL_PRO_WLAN_2011,
	  PCMCIA_CIS_INTEL_PRO_WLAN_2011
	},
	{ PCMCIA_VENDOR_INTERSIL,
	  PCMCIA_PRODUCT_INTERSIL_PRISM2,
	  PCMCIA_CIS_INTERSIL_PRISM2
	},
	{ PCMCIA_VENDOR_SAMSUNG,
	  PCMCIA_PRODUCT_SAMSUNG_SWL_2000N,
	  PCMCIA_CIS_SAMSUNG_SWL_2000N
	},
	{ PCMCIA_VENDOR_LINKSYS2,
	  PCMCIA_PRODUCT_LINKSYS2_IWN,
	  PCMCIA_CIS_LINKSYS2_IWN
	},
	{ PCMCIA_VENDOR_LINKSYS2,
	  PCMCIA_PRODUCT_LINKSYS2_IWN2,
	  PCMCIA_CIS_LINKSYS2_IWN2
	},
	{ PCMCIA_VENDOR_LINKSYS2,
	  PCMCIA_PRODUCT_LINKSYS2_WCF11,
	  PCMCIA_CIS_LINKSYS2_WCF11
	},
	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_SMC_2632W
	},
	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_NANOSPEED_PRISM2
	},
	{ PCMCIA_VENDOR_ELSA,
	  PCMCIA_PRODUCT_ELSA_XI300_IEEE,
	  PCMCIA_CIS_ELSA_XI300_IEEE
	},
	{ PCMCIA_VENDOR_ELSA,
	  PCMCIA_PRODUCT_ELSA_XI325_IEEE,
	  PCMCIA_CIS_ELSA_XI325_IEEE
	},
	{ PCMCIA_VENDOR_ELSA,
	  PCMCIA_PRODUCT_ELSA_WNB11CFZ,
	  PCMCIA_CIS_ELSA_WNB11CFZ
	},
	{ PCMCIA_VENDOR_COMPAQ,
	  PCMCIA_PRODUCT_COMPAQ_NC5004,
	  PCMCIA_CIS_COMPAQ_NC5004
	},
	{ PCMCIA_VENDOR_CONTEC,
	  PCMCIA_PRODUCT_CONTEC_FX_DS110_PCC,
	  PCMCIA_CIS_CONTEC_FX_DS110_PCC
	},
	{ PCMCIA_VENDOR_TDK,
	  PCMCIA_PRODUCT_TDK_LAK_CD011WL,
	  PCMCIA_CIS_TDK_LAK_CD011WL
	},
	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_NEC_CMZ_RT_WP
	},
	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_NTT_ME_WLAN
	},
	{ PCMCIA_VENDOR_ADDTRON,
	  PCMCIA_PRODUCT_ADDTRON_AWP100,
	  PCMCIA_CIS_ADDTRON_AWP100
	},
	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_CABLETRON_ROAMABOUT
	},
	{ PCMCIA_VENDOR_IODATA2,
	  PCMCIA_PRODUCT_IODATA2_WCF12,
	  PCMCIA_CIS_IODATA2_WCF12
	},
	{ PCMCIA_VENDOR_IODATA2,
	  PCMCIA_PRODUCT_IODATA2_WNB11PCM,
	  PCMCIA_CIS_IODATA2_WNB11PCM
	},
	{ PCMCIA_VENDOR_GEMTEK,
	  PCMCIA_PRODUCT_GEMTEK_WLAN,
	  PCMCIA_CIS_GEMTEK_WLAN
	},
	{ PCMCIA_VENDOR_ELSA,
	  PCMCIA_PRODUCT_ELSA_XI800_IEEE,
	  PCMCIA_CIS_ELSA_XI800_IEEE
	},
	{ PCMCIA_VENDOR_BUFFALO,
	  PCMCIA_PRODUCT_BUFFALO_WLI_PCM_S11,
	  PCMCIA_CIS_BUFFALO_WLI_PCM_S11
	},
	{ PCMCIA_VENDOR_BUFFALO,
	  PCMCIA_PRODUCT_BUFFALO_WLI_CF_S11G,
	  PCMCIA_CIS_BUFFALO_WLI_CF_S11G
	},
	{ PCMCIA_VENDOR_EMTAC,
	  PCMCIA_PRODUCT_EMTAC_WLAN,
	  PCMCIA_CIS_EMTAC_WLAN
	},
	{ PCMCIA_VENDOR_SIMPLETECH,
	  PCMCIA_PRODUCT_SIMPLETECH_SPECTRUM24_ALT,
	  PCMCIA_CIS_SIMPLETECH_SPECTRUM24_ALT
	},
	{ PCMCIA_VENDOR_ERICSSON,
	  PCMCIA_PRODUCT_ERICSSON_WIRELESSLAN,
	  PCMCIA_CIS_ERICSSON_WIRELESSLAN
	},
	{ PCMCIA_VENDOR_PROXIM,
	  PCMCIA_PRODUCT_PROXIM_RANGELANDS_8430,
	  PCMCIA_CIS_PROXIM_RANGELANDS_8430
	},
	{ PCMCIA_VENDOR_ACTIONTEC,
	  PCMCIA_PRODUCT_ACTIONTEC_HWC01170,
	  PCMCIA_CIS_ACTIONTEC_HWC01170
	},
	{ PCMCIA_VENDOR_NOKIA,
	  PCMCIA_PRODUCT_NOKIA_C020_WLAN,
	  PCMCIA_CIS_NOKIA_C020_WLAN
	},
	{ PCMCIA_VENDOR_NOKIA,
	  PCMCIA_PRODUCT_NOKIA_C110_WLAN,
	  PCMCIA_CIS_NOKIA_C110_WLAN
	},
	{ PCMCIA_VENDOR_NETGEAR2,
	  PCMCIA_PRODUCT_NETGEAR2_MA401RA,
	  PCMCIA_CIS_NETGEAR2_MA401RA
	},
	{ PCMCIA_VENDOR_NETGEAR2,
	  PCMCIA_PRODUCT_NETGEAR2_DWL650,
	  PCMCIA_CIS_NETGEAR2_DWL650
	},
	{ PCMCIA_VENDOR_AIRVAST,
	  PCMCIA_PRODUCT_AIRVAST_WN_100,
	  PCMCIA_CIS_AIRVAST_WN_100
	},
	{ PCMCIA_VENDOR_SIEMENS,
	  PCMCIA_PRODUCT_SIEMENS_SS1021,
	  PCMCIA_CIS_SIEMENS_SS1021
	},
	{ PCMCIA_VENDOR_PROXIM,
	  PCMCIA_PRODUCT_PROXIM_HARMONY_80211B,
	  PCMCIA_CIS_PROXIM_HARMONY_80211B
	},
	{ PCMCIA_VENDOR_MICROSOFT,
	  PCMCIA_PRODUCT_MICROSOFT_MN520,
	  PCMCIA_CIS_MICROSOFT_MN520
	},
	{ PCMCIA_VENDOR_ADAPTEC2,
	  PCMCIA_PRODUCT_ADAPTEC2_AWN8030,
	  PCMCIA_CIS_ADAPTEC2_AWN8030
	},
	{ PCMCIA_VENDOR_ASUS,
	  PCMCIA_PRODUCT_ASUS_WL_100,
	  PCMCIA_CIS_ASUS_WL_100
	},
	{ PCMCIA_VENDOR_SENAO,
	  PCMCIA_PRODUCT_SENAO_EL2511CD2EM,
	  PCMCIA_CIS_SENAO_EL2511CD2EM
	},
	{ PCMCIA_VENDOR_ARTEM,
	  PCMCIA_PRODUCT_ARTEM_ONAIR,
	  PCMCIA_CIS_ARTEM_ONAIR
	},
	{ PCMCIA_VENDOR_PLANEX,
	  PCMCIA_PRODUCT_PLANEX_GWNS11H,
	  PCMCIA_CIS_PLANEX_GWNS11H
	},
	{ PCMCIA_VENDOR_SYMBOL,
	  PCMCIA_PRODUCT_SYMBOL_LA4100,
	  PCMCIA_CIS_SYMBOL_LA4100
	},
	{ PCMCIA_VENDOR_BAY,
	  PCMCIA_PRODUCT_BAY_EMOBILITY_11B,
	  PCMCIA_CIS_BAY_EMOBILITY_11B
	},
	{ PCMCIA_VENDOR_GREYCELL,
	  PCMCIA_PRODUCT_GREYCELL_DWL650H,
	  PCMCIA_CIS_GREYCELL_DWL650H
	},
	{ PCMCIA_VENDOR_FUJITSU,
	  PCMCIA_PRODUCT_FUJITSU_WL110,
	  PCMCIA_CIS_FUJITSU_WL110
	},
	{ PCMCIA_VENDOR_ALLIEDTELESIS,
	  PCMCIA_PRODUCT_ALLIEDTELESIS_WR211PCM,
	  PCMCIA_CIS_ALLIEDTELESIS_WR211PCM
	},
	{ PCMCIA_VENDOR_HWN,
	  PCMCIA_PRODUCT_HWN_AIRWAY80211,
	  PCMCIA_CIS_HWN_AIRWAY80211
	},
	{ PCMCIA_VENDOR_SOCKET,
	  PCMCIA_PRODUCT_SOCKET_LP_WLAN_CF,
	  PCMCIA_CIS_SOCKET_LP_WLAN_CF
	}
};

static const struct wi_pcmcia_product *wi_lookup(struct pcmcia_attach_args *pa);

const struct wi_pcmcia_product *
wi_lookup(struct pcmcia_attach_args *pa)
{
	const struct wi_pcmcia_product *pp;
	const struct wi_pcmcia_product *epp = wi_pcmcia_products +
	    sizeof(wi_pcmcia_products) / sizeof(wi_pcmcia_products[0]);

	/*
	 * Several PRISM II-based cards use the Lucent WaveLAN vendor
	 * and product IDs so we match by CIS information first.
	 */
	for (pp = wi_pcmcia_products; pp < epp; pp++) {
		if (pa->card->cis1_info[0] != NULL &&
		    pp->pp_cisinfo[0] != NULL &&
		    strcmp(pa->card->cis1_info[0], pp->pp_cisinfo[0]) == 0 &&
		    pa->card->cis1_info[1] != NULL &&
		    pp->pp_cisinfo[1] != NULL &&
		    strcmp(pa->card->cis1_info[1], pp->pp_cisinfo[1]) == 0)
			return (pp);
	}

	/* Match by vendor/product ID. */
	for (pp = wi_pcmcia_products; pp < epp; pp++) {
		if (pa->manufacturer != PCMCIA_VENDOR_INVALID &&
		    pa->manufacturer == pp->pp_vendor &&
		    pa->product != PCMCIA_PRODUCT_INVALID &&
		    pa->product == pp->pp_product)
			return (pp);
	}

	return (NULL);
}

int
wi_pcmcia_match(struct device *parent, void *match, void *aux)
{
	struct pcmcia_attach_args *pa = aux;

	if (wi_lookup(pa) != NULL)
		return (1);
	return (0);
}

void
wi_pcmcia_attach(struct device *parent, struct device *self, void *aux)
{
	struct wi_pcmcia_softc	*psc = (struct wi_pcmcia_softc *)self;
	struct wi_softc		*sc = &psc->sc_wi;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_function	*pf = pa->pf;
	struct pcmcia_config_entry *cfe = SIMPLEQ_FIRST(&pf->cfe_head);
	const char		*intrstr;
	int			state = 0;

	psc->sc_pf = pf;

	/* Enable the card. */
	pcmcia_function_init(pf, cfe);
	if (pcmcia_function_enable(pf)) {
		printf(": function enable failed\n");
		goto bad;
	}
	state++;

	if (pcmcia_io_alloc(pf, 0, WI_IOSIZ, WI_IOSIZ, &psc->sc_pcioh)) {
		printf(": can't alloc i/o space\n");
		goto bad;
	}
	state++;

	if (pcmcia_io_map(pf, PCMCIA_WIDTH_IO16, 0, WI_IOSIZ,
	    &psc->sc_pcioh, &psc->sc_io_window)) {
		printf(": can't map i/o space\n");
		goto bad;
	}
	state++;

	printf(" port 0x%lx/%lu", psc->sc_pcioh.addr,
	    (u_long)psc->sc_pcioh.size);

	sc->wi_ltag = sc->wi_btag = psc->sc_pcioh.iot;
	sc->wi_lhandle = sc->wi_bhandle = psc->sc_pcioh.ioh;
	sc->wi_cor_offset = WI_COR_OFFSET;
	sc->wi_flags |= WI_FLAGS_BUS_PCMCIA;

	/* Make sure interrupts are disabled. */
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	CSR_WRITE_2(sc, WI_EVENT_ACK, 0xffff);

	/* Establish the interrupt. */
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, wi_intr, psc,
	    sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("%s: can't establish interrupt\n",
		    sc->sc_dev.dv_xname);
		goto bad;
	}

	intrstr = pcmcia_intr_string(psc->sc_pf, sc->sc_ih);
	printf("%s%s\n", *intrstr ? ", " : "", intrstr);
	if (wi_attach(sc, &wi_func_io) == 0)
		return;

	/* wi_attach() failed, do some cleanup */
	pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
	sc->sc_ih = NULL;

bad:
	if (state > 2)
		pcmcia_io_unmap(pf, psc->sc_io_window);
	if (state > 1)
		pcmcia_io_free(pf, &psc->sc_pcioh);
	if (state > 0)
		pcmcia_function_disable(pf);
}

int
wi_pcmcia_detach(struct device *dev, int flags)
{
	struct wi_pcmcia_softc *psc = (struct wi_pcmcia_softc *)dev;
	struct wi_softc *sc = &psc->sc_wi;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
		return (0);

	wi_detach(sc);

	sc->wi_flags = 0;

	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (0);
}

int
wi_pcmcia_activate(struct device *dev, int act)
{
	struct wi_pcmcia_softc *psc = (struct wi_pcmcia_softc *)dev;
	struct wi_softc *sc = &psc->sc_wi;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	switch (act) {
	case DVACT_SUSPEND:
		ifp->if_timer = 0;
		if (ifp->if_flags & IFF_RUNNING)
			wi_stop(sc);
		sc->wi_flags &= ~WI_FLAGS_INITIALIZED;
		if (sc->sc_ih != NULL)
			pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(psc->sc_pf);
		break;
	case DVACT_RESUME:
		pcmcia_function_enable(psc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
		    wi_intr, sc, sc->sc_dev.dv_xname);
		break;
	case DVACT_WAKEUP:
		wi_pcmcia_wakeup(sc);
		break;
	case DVACT_DEACTIVATE:
		if (sc->sc_ih != NULL)
			pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(psc->sc_pf);
		break;
	}
	return (0);
}

void
wi_pcmcia_wakeup(struct wi_softc *sc)
{
	int s;

	s = splnet();
	while (sc->wi_flags & WI_FLAGS_BUSY)
		tsleep(&sc->wi_flags, 0, "wipwr", 0);
	sc->wi_flags |= WI_FLAGS_BUSY;

	wi_cor_reset(sc);
	wi_init(sc);

	sc->wi_flags &= ~WI_FLAGS_BUSY;
	wakeup(&sc->wi_flags);
	splx(s);
}
@


1.73
log
@unifdef INET
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.72 2013/12/06 21:03:04 deraadt Exp $ */
a53 1
#include <net/if_dl.h>
@


1.72
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.71 2013/11/14 12:33:15 dlg Exp $ */
a56 1
#ifdef INET
a58 1
#endif
@


1.71
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.70 2011/07/03 15:47:17 matthew Exp $ */
a51 1
#include <sys/task.h>
d79 1
a79 1
void	wi_pcmcia_resume(void *, void *);
a86 1
	struct task		sc_resume_t;
a385 1
	task_set(&psc->sc_resume_t, wi_pcmcia_resume, sc, NULL);
d492 3
a494 1
		task_add(systq, &psc->sc_resume_t);
d507 1
a507 1
wi_pcmcia_resume(void *arg1, void *arg2)
a508 1
	struct wi_softc *sc = (struct wi_softc *)arg1;
@


1.70
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.69 2010/08/30 20:33:18 deraadt Exp $ */
d52 1
a52 1
#include <sys/workq.h>
d88 1
a88 1
	struct workq_task	sc_resume_wqt;
d388 1
d495 1
a495 2
		workq_queue_task(NULL, &psc->sc_resume_wqt, 0,
		    wi_pcmcia_resume, sc, NULL);
@


1.69
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.68 2009/10/13 19:33:16 pirofti Exp $ */
a479 7
	case DVACT_ACTIVATE:
		pcmcia_function_enable(psc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
		    wi_intr, sc, sc->sc_dev.dv_xname);
		workq_queue_task(NULL, &psc->sc_resume_wqt, 0,
		    wi_pcmcia_resume, sc, NULL);
		break;
@


1.68
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.67 2009/03/29 21:53:53 sthen Exp $ */
d52 1
d80 1
d88 1
a477 1
	int s;
a478 1
	s = splnet();
d484 2
a485 2
		wi_cor_reset(sc);
		wi_init(sc);
d487 1
a487 2

	case DVACT_DEACTIVATE:
d494 14
d511 19
a530 1
	return (0);
@


1.67
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.66 2006/11/26 19:46:28 deraadt Exp $ */
d78 1
a78 1
int	wi_pcmcia_activate(struct device *, enum devact);
d470 1
a470 1
wi_pcmcia_activate(struct device *dev, enum devact act)
@


1.66
log
@avoid extra inclusions; ok jsg
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.65 2006/04/20 20:31:13 miod Exp $ */
d402 1
a402 1
		printf(": can't map io space\n");
d423 1
a423 1
		printf("%s: couldn't establish interrupt\n",
@


1.65
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.64 2005/10/31 05:37:13 jsg Exp $ */
d62 1
a62 1
#include <net80211/ieee80211.h>
a63 1
#include <net80211/ieee80211_var.h>
@


1.64
log
@Move from arpcom to ieee80211com in wi softc.  This will be
required for net80211 support.
Updated version of a diff from dlg@@
similiar diff ok fgsch@@, ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.63 2005/09/18 09:24:04 jsg Exp $ */
d408 2
a409 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);
@


1.63
log
@ansi. No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.62 2005/03/13 04:34:43 dlg Exp $ */
d51 1
d64 1
d451 1
a451 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d474 1
a474 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
@


1.62
log
@in the event wi_attach fails dont panic trying to clean up a nonexistant
interrupt handler.

ok uwe@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.61 2005/03/06 23:32:07 jsg Exp $ */
d330 1
a330 2
wi_lookup(pa)
	struct pcmcia_attach_args *pa;
d363 1
a363 3
wi_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d373 1
a373 3
wi_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d445 1
a445 3
wi_pcmcia_detach(dev, flags)
	struct device *dev;
	int flags;
d468 1
a468 3
wi_pcmcia_activate(dev, act)
	struct device *dev;
	enum devact act;
@


1.61
log
@Untested support for I-O DATA WN-B11/CFZ.
Documentation to follow if I get a report of it working.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.60 2005/01/27 17:04:56 millert Exp $ */
d436 1
d438 1
d499 2
a500 1
		pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
@


1.60
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.59 2005/01/21 03:32:21 millert Exp $ */
d168 4
@


1.59
log
@Undo last change; if wi_pcmcia_attach failed we already freed up the
pcmcia resources and trying to do it again will cause problems.
Just return silently if WI_FLAGS_ATTACHED is not set in wi_flags.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.58 2005/01/20 00:44:28 millert Exp $ */
d381 1
d427 2
a428 1
	printf("\n");
@


1.58
log
@If the card failed to attach completely we still want to unmap its
resources when it is ejected.  OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.57 2005/01/11 22:07:58 drahn Exp $ */
d449 3
@


1.57
log
@Pass device names on intr_establish() call, other drivers need this too.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.56 2004/11/23 21:12:23 fgsch Exp $ */
a448 5

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED)) {
		printf("%s: already detached\n", sc->sc_dev.dv_xname);
		return (0);
	}
@


1.56
log
@replace old net/if_ieee80211.h header with the net80211 ones, kernel part.
millert@@ mcbride@@ jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.55 2004/10/22 08:48:38 jsg Exp $ */
d418 2
a419 1
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, wi_intr, psc, "");
@


1.55
log
@add some more wi devices found in netbsd and freebsd
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.54 2004/10/20 12:53:28 deraadt Exp $ */
d61 2
a62 1
#include <net/if_ieee80211.h>
@


1.54
log
@put newlines at slightly different places during attach, leading to clean
USB attach
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.53 2004/10/11 15:16:37 mickey Exp $ */
d124 4
d148 4
d197 4
d252 4
d291 28
@


1.53
log
@add support for Planex GW-NS11H; from Jonathan Gray <jsg@@goblin.cx>
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.52 2004/09/30 14:24:05 millert Exp $ */
d380 1
@


1.52
log
@ARtem Onair 802.11b card works with wi(4); Marco Pfatschbacher
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.51 2004/09/27 03:49:14 millert Exp $ */
d271 4
@


1.51
log
@Add Proxim Harmony 802.11b card and attach it to wi(4); David Vincelli
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.50 2004/09/25 02:01:31 fgsch Exp $ */
d267 4
@


1.50
log
@Senao el-2511cd2ext2m support. Reported and tested by Randy Bender
<randybender2004 at hotmail dot com>; millert@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.49 2004/06/04 18:03:35 millert Exp $ */
d247 4
@


1.49
log
@Add support for ASUS SpaceLink WL-100 PCMCIA 802.11b card; Sigfred HÃversen
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.48 2004/06/01 17:35:58 millert Exp $ */
d259 4
@


1.48
log
@Add support for the Adaptec AWN-8030 WLAN pcmcia-card (prism 2.5) from
Andreas Abeck.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.47 2004/05/03 16:58:11 drahn Exp $ */
d255 4
@


1.47
log
@If wi@@pcmcia fails in wiattach(), disestablish the interrupt and
let the rest of the cleanup code run. ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.46 2004/04/06 21:08:57 millert Exp $ */
d251 4
@


1.46
log
@Attach Microsoft MN-520 wireless card
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.45 2003/12/16 03:20:00 millert Exp $ */
d356 4
a359 2
	wi_attach(sc, &wi_func_io);
	return;
@


1.45
log
@Remove unused strings; we print out info from pcmciadevs during
device attachment so we don't need extra ones.  OK mickey@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.44 2003/10/26 15:34:16 drahn Exp $ */
d247 4
@


1.44
log
@Driver for PRISM 2.5/3 based (wifi) USB adapters. This is a work in progress,
it does not yet handle bulk data copies or hostap mode. Only one model
currently supported, however driver may support other PRISM based adapters.
ok millert@@ fgsch@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.43 2003/09/06 20:53:57 drahn Exp $ */
a94 1
	const char	*pp_name;
d98 1
a98 2
	  PCMCIA_CIS_LUCENT_WAVELAN_IEEE,
	  "WaveLAN/IEEE"
d102 1
a102 2
	  PCMCIA_CIS_3COM_3CRWE737A,
	  "3Com AirConnect Wireless LAN"
d106 1
a106 2
	  PCMCIA_CIS_3COM_3CRWE777A,
	  "3Com AirConnect Wireless LAN"
d110 1
a110 2
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCC_11,
	  "Corega Wireless LAN PCC-11"
d114 1
a114 2
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCA_11,
	  "Corega Wireless LAN PCCA-11",
d118 1
a118 2
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCB_11,
	  "Corega Wireless LAN PCCB-11",
d122 1
a122 2
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCL_11,
	  "Corega Wireless LAN PCCL-11",
d126 1
a126 2
	  PCMCIA_CIS_INTEL_PRO_WLAN_2011,
	  "Intel PRO/Wireless 2011",
d130 1
a130 2
	  PCMCIA_CIS_INTERSIL_PRISM2,
	  "Intersil Prism II",
d134 1
a134 2
	  PCMCIA_CIS_SAMSUNG_SWL_2000N,
	  "Samsung MagicLAN SWL-2000N",
d138 1
a138 2
	  PCMCIA_CIS_LINKSYS2_IWN,
	  "Linksys Instant Wireless Network",
d142 1
a142 2
	  PCMCIA_CIS_LINKSYS2_IWN2,
	  "Linksys Instant Wireless Network",
d146 1
a146 2
	  PCMCIA_CIS_SMC_2632W,
	  "SMC 2632 EZ Connect Wireless PC Card",
d150 1
a150 2
	  PCMCIA_CIS_NANOSPEED_PRISM2,
	  "NANOSPEED ROOT-RZ2000 WLAN Card",
d154 1
a154 2
	  PCMCIA_CIS_ELSA_XI300_IEEE,
	  "XI300 Wireless LAN",
d158 1
a158 2
	  PCMCIA_CIS_ELSA_XI325_IEEE,
	  "XI325 Wireless LAN",
d162 1
a162 2
	  PCMCIA_CIS_COMPAQ_NC5004,
	  "Compaq Agency NC5004 Wireless Card",
d166 1
a166 2
	  PCMCIA_CIS_CONTEC_FX_DS110_PCC,
	  "Contec FLEXLAN/FX-DS110-PCC",
d170 1
a170 2
	  PCMCIA_CIS_TDK_LAK_CD011WL,
	  "TDK LAK-CD011WL",
d174 1
a174 2
	  PCMCIA_CIS_NEC_CMZ_RT_WP,
	  "NEC Wireless Card CMZ-RT-WP",
d178 1
a178 2
	  PCMCIA_CIS_NTT_ME_WLAN,
	  "NTT-ME 11Mbps Wireless LAN PC Card",
d182 1
a182 2
	  PCMCIA_CIS_ADDTRON_AWP100,
	  "Addtron AWP-100",
d186 1
a186 2
	  PCMCIA_CIS_CABLETRON_ROAMABOUT,
	  "Cabletron RoamAbout",
d190 1
a190 2
	  PCMCIA_CIS_IODATA2_WNB11PCM,
	  "I-O DATA WN-B11/PCM",
d194 1
a194 2
	  PCMCIA_CIS_GEMTEK_WLAN,
	  "GEMTEK Prism2_5 WaveLAN Card"
d198 1
a198 2
	  PCMCIA_CIS_ELSA_XI800_IEEE,
	  "ELSA XI800 CF Wireless LAN"
d202 1
a202 2
	  PCMCIA_CIS_BUFFALO_WLI_PCM_S11,
	  "BUFFALO AirStation 11Mbps WLAN"
d206 1
a206 2
	  PCMCIA_CIS_BUFFALO_WLI_CF_S11G,
	  "BUFFALO AirStation 11Mbps CF WLAN"
d210 1
a210 2
	  PCMCIA_CIS_EMTAC_WLAN,
	  "EMTAC A2424i 11Mbps WLAN Card"
d214 1
a214 2
	  PCMCIA_CIS_SIMPLETECH_SPECTRUM24_ALT,
	  "LA4111 Spectrum24 WLAN PC Card"
d218 1
a218 2
	  PCMCIA_CIS_ERICSSON_WIRELESSLAN,
	  "DSSS Wireless LAN PC Card" 
d222 1
a222 2
	  PCMCIA_CIS_PROXIM_RANGELANDS_8430,
	  "Proxim RangeLAN-DS/LAN PC CARD",
d226 1
a226 2
	  PCMCIA_CIS_ACTIONTEC_HWC01170,
	  "ACTIONTEC PRISM Wireless LAN PC CARD",
d230 1
a230 2
	  PCMCIA_CIS_NOKIA_C020_WLAN,
	  "NOKIA C020 Wireless LAN PC CARD",
d234 1
a234 2
	  PCMCIA_CIS_NOKIA_C110_WLAN,
	  "NOKIA C110 Wireless LAN PC CARD",
d238 1
a238 2
	  PCMCIA_CIS_NETGEAR2_MA401RA,
	  "Netgear MA401RA Wireless LAN PC CARD",
d242 1
a242 2
	  PCMCIA_CIS_AIRVAST_WN_100,
	  "AirVast WN-100 Wireless LAN PC CARD",
d246 1
a246 7
	  PCMCIA_CIS_SIEMENS_SS1021,
	  "SpeedStream 1021 Wireless PCMCIA CARD",
	},
	{ 0,
	  0,
	  { NULL, NULL, NULL, NULL },
	  NULL,
d257 2
d264 1
a264 1
	for (pp = wi_pcmcia_products; pp->pp_name != NULL; pp++) {
d275 1
a275 1
	for (pp = wi_pcmcia_products; pp->pp_name != NULL; pp++) {
@


1.43
log
@Add wi_detach, use it in pcmcia so that the shutdownhook is properly removed.
ok miod@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.42 2003/07/14 22:06:48 millert Exp $ */
d394 1
a394 1
	wi_attach(sc);
@


1.42
log
@Add Siemens SpeedStream 1021
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.41 2003/07/06 21:17:50 millert Exp $ */
d420 1
a420 2
	if (ifp->if_flags & IFF_RUNNING)
		wi_stop(sc);
@


1.41
log
@Add Corega Wireless LAN PCCL-11; Jonathon Fletcher
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.40 2003/02/26 18:58:32 millert Exp $ */
d281 5
@


1.40
log
@Add support for AirVast WN-100; nick@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.39 2002/11/19 18:36:18 jason Exp $ */
d126 5
@


1.39
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.38 2002/07/09 11:00:27 fgsch Exp $ */
d271 5
@


1.38
log
@move common declarations to if_wivar.h; mickey@@ and millert@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.37 2002/07/01 13:31:06 fgsch Exp $ */
d334 1
a334 1
	struct pcmcia_config_entry *cfe = pf->cfe_head.sqh_first;
@


1.37
log
@when printing the size, use what we have map'ed, not what's in the
configuration.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.36 2002/06/25 15:13:09 millert Exp $ */
a76 6

int	wi_intr(void *);
int	wi_attach(struct wi_softc *);
void	wi_cor_reset(struct wi_softc *);
void	wi_init(struct wi_softc *);
void	wi_stop(struct wi_softc *);
@


1.36
log
@Back out my change to pass in sc_dev.dv_xname to pcmcia_intr_establish().
It screws up printing in dmesg and doesn't actually help anything
since interupts in "vmstat -i" show up as pcmcia*, not wi* or an*.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.35 2002/06/22 22:10:38 fgsch Exp $ */
d366 1
a366 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, cfe->iospace[0].length);
@


1.35
log
@Add new flag, WI_FLAGS_BUS_PCMCIA and mark pcmcia attachment as such.
Replace ugly kludge with a macro that tests on sparc if it's pcmcia
and tries to deal with it correctly (card mapped as be).
This makes possible to have wi at pcmcia and pci on sparc64; from theo
and myself.  Tested with the PLX adapter and the SBus pcmcia bridge.
millert@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.34 2002/06/21 08:31:09 henning Exp $ */
d378 1
a378 2
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, wi_intr, psc,
	    sc->sc_dev.dv_xname);
@


1.34
log
@add support for Netgear MA401RA (Prism-2.5)
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.33 2002/06/20 17:10:56 millert Exp $ */
d371 1
@


1.33
log
@Add ELSA / ZCOMAX XI-325 (and XI-325H); Ken Simpson
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.32 2002/06/09 22:34:16 millert Exp $ */
d272 5
@


1.32
log
@Pass in the device name to pcmcia_intr_establish() instead of ""
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.31 2002/06/09 03:14:18 todd Exp $ */
d172 5
@


1.31
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.30 2002/06/08 00:01:25 fgsch Exp $ */
d367 2
a368 1
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, wi_intr, psc, "");
@


1.30
log
@print address; millert@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.29 2002/05/28 02:14:09 mickey Exp $ */
d393 1
a393 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d421 1
a421 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
@


1.29
log
@add an id for nokia c110/c111; attach both w/ the if_wi_pcmcia (prism1-prism2 clones, according to linux)
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.28 2002/04/17 17:33:44 millert Exp $ */
d355 2
@


1.28
log
@Clear flags indicating whether or not wi or hostap is active as
early as possible.  Also the timeout_del() in wi_stop() to before
we disable wi(4) so it doesn't fire at the wrong time.
Joint effort between mickey@@ and myself.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.27 2002/04/07 23:23:49 millert Exp $ */
d257 10
@


1.27
log
@Don't reset COR in wi_reset(), break it out into its own function and
only call it from wi_attach() and wi_pcmcia_activate() (ie: just once).
It would be nicer to have the COR reset be part of the bus-specific
code but we need to know whether or not we have a Lucent card since
old Lucent firmware revs get messed up on a COR soft reset.

Even with the COR reset we still need to avoid initializing Symbol
cards more than once.  However, we *do* want to do a reset after
returning from suspend.  Therefore, rename wi_gone to wi_flags and
store both the attach and init status in it.  wi_reset() now checks
wi_flags to see if the card should be initialized in the Symbol case.

Info on initializing Symbol cards once from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.26 2002/04/06 21:58:12 millert Exp $ */
d391 2
a397 2

	sc->wi_flags = 0;
@


1.26
log
@For PLX-based bridge cards, move printing of pcmcia card CIS strings
out of generic wi_attach() and into wi_pci_attach().  This means
we can't print the CIS info for embedded cards like the NCP130 but
since those don't have a "real" pcmcia card in them this is really
not a problem.  Also check to see that there is actually a pcmcia
present and give and error if not.  CIS magic number taken from the
Linux orinoco driver; there may be a better way to do this.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.25 2002/04/06 20:31:56 millert Exp $ */
d80 1
d383 1
a383 1
	if (sc->wi_gone) {
d397 1
a397 1
	sc->wi_gone = 1;
d418 1
d426 1
@


1.25
log
@Add support for Symbol cards and printing of the primary station
firmware version.  Adapted from NetBSD and the Linux orinoco driver.
The Symbol firmware requires that we do a COR soft reset before
initializing the card in wi_reset().  Also, setting WI_RID_ROAMING_MODE
caused the Symbol card to go into a strange (non-working) mode with
firmware 2.x.x.

There are some other Symbol additions/oddities that will need to be
addressed in the future.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.24 2002/04/06 00:58:05 mickey Exp $ */
d79 1
a79 1
int	wi_attach(struct wi_softc *, int);
d361 1
a361 1
	wi_attach(sc, 0);
@


1.24
log
@actiontec wlan support; form jason@@ackley.net via pr#2526
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.23 2002/04/05 15:35:15 millert Exp $ */
d345 3
a347 2
	sc->wi_btag = psc->sc_pcioh.iot;
	sc->wi_bhandle = psc->sc_pcioh.ioh;
@


1.23
log
@Actually set wi_gone when we detach, based on what the an driver does.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.22 2002/04/04 18:44:35 millert Exp $ */
d251 5
@


1.22
log
@wi_init() now takes a struct wi_softc * not a void * since an sc pointer
is available everywhere wi_init() is called.  deraadt@@ OK
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.21 2002/04/02 03:57:05 millert Exp $ */
d376 8
d389 2
@


1.21
log
@3Com AirConnect 3CRWE777A is really just a 3CRWE737A in disguise.
They use 3CRWE777A because that is the part number for the PCI adapter
it comes with but the card can be used w/o it.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.20 2002/03/29 18:54:07 millert Exp $ */
d80 1
a80 1
void	wi_init(void *);
@


1.20
log
@Add Proxim RangeLAN-DS PCMCIA card (model 8430); Paul M. Hirsch
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.19 2002/03/28 16:45:52 provos Exp $ */
d110 5
@


1.19
log
@new linksys wpc11; okay mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.18 2002/03/14 01:27:01 millert Exp $ */
d240 7
a246 1
	  "DSSS Wireless LAN PC Card" },
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.17 2002/01/22 14:36:04 mickey Exp $ */
d145 5
@


1.17
log
@dup wi_pcmcia_attach(); from maurice@@amaze.nl
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.16 2002/01/04 16:28:02 mickey Exp $ */
d73 9
a81 9
int	wi_pcmcia_match		__P((struct device *, void *, void *));
void	wi_pcmcia_attach	__P((struct device *, struct device *, void *));
int	wi_pcmcia_detach	__P((struct device *, int));
int	wi_pcmcia_activate	__P((struct device *, enum devact));

int	wi_intr			__P((void *));
int	wi_attach		__P((struct wi_softc *, int));
void	wi_init			__P((void *));
void	wi_stop			__P((struct wi_softc *));
d243 1
a243 1
static const struct wi_pcmcia_product *wi_lookup __P((struct pcmcia_attach_args *pa));
@


1.16
log
@match on ericsson wlan; from lha@@stacken.kth.se, pr 2295
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.15 2001/12/05 21:04:11 mickey Exp $ */
a76 1
void	wi_pcmcia_attach	__P((struct device *, struct device *, void *));
@


1.15
log
@match on Symbol's Spectrum24 pcmcia/prism2, form netbsd
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d233 4
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.17 2002/01/22 14:36:04 mickey Exp $ */
d77 1
a232 4
	{ PCMCIA_VENDOR_ERICSSON,
	  PCMCIA_PRODUCT_ERICSSON_WIRELESSLAN,
	  PCMCIA_CIS_ERICSSON_WIRELESSLAN,
	  "DSSS Wireless LAN PC Card" },
@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.15.2.1 2002/01/31 22:55:37 niklas Exp $ */
d73 9
a81 10
int	wi_pcmcia_match(struct device *, void *, void *);
void	wi_pcmcia_attach(struct device *, struct device *, void *);
int	wi_pcmcia_detach(struct device *, int);
int	wi_pcmcia_activate(struct device *, enum devact);

int	wi_intr(void *);
int	wi_attach(struct wi_softc *);
void	wi_cor_reset(struct wi_softc *);
void	wi_init(struct wi_softc *);
void	wi_stop(struct wi_softc *);
a111 5
	{ PCMCIA_VENDOR_3COM,
	  PCMCIA_PRODUCT_3COM_3CRWE777A,
	  PCMCIA_CIS_3COM_3CRWE777A,
	  "3Com AirConnect Wireless LAN"
	},
a146 5
	{ PCMCIA_VENDOR_LINKSYS2,
	  PCMCIA_PRODUCT_LINKSYS2_IWN2,
	  PCMCIA_CIS_LINKSYS2_IWN2,
	  "Linksys Instant Wireless Network",
	},
d235 1
a235 22
	  "DSSS Wireless LAN PC Card" 
	},
	{ PCMCIA_VENDOR_PROXIM,
	  PCMCIA_PRODUCT_PROXIM_RANGELANDS_8430,
	  PCMCIA_CIS_PROXIM_RANGELANDS_8430,
	  "Proxim RangeLAN-DS/LAN PC CARD",
	},
	{ PCMCIA_VENDOR_ACTIONTEC,
	  PCMCIA_PRODUCT_ACTIONTEC_HWC01170,
	  PCMCIA_CIS_ACTIONTEC_HWC01170,
	  "ACTIONTEC PRISM Wireless LAN PC CARD",
	},
	{ PCMCIA_VENDOR_NOKIA,
	  PCMCIA_PRODUCT_NOKIA_C020_WLAN,
	  PCMCIA_CIS_NOKIA_C020_WLAN,
	  "NOKIA C020 Wireless LAN PC CARD",
	},
	{ PCMCIA_VENDOR_NOKIA,
	  PCMCIA_PRODUCT_NOKIA_C110_WLAN,
	  PCMCIA_CIS_NOKIA_C110_WLAN,
	  "NOKIA C110 Wireless LAN PC CARD",
	},
d243 1
a243 1
static const struct wi_pcmcia_product *wi_lookup(struct pcmcia_attach_args *pa);
d324 2
a325 5
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, cfe->iospace[0].length);

	sc->wi_ltag = sc->wi_btag = psc->sc_pcioh.iot;
	sc->wi_lhandle = sc->wi_bhandle = psc->sc_pcioh.ioh;
	sc->wi_cor_offset = WI_COR_OFFSET;
d339 1
a339 1
	wi_attach(sc);
d358 1
a358 11
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED)) {
		printf("%s: already detached\n", sc->sc_dev.dv_xname);
		return (0);
	}

	if (ifp->if_flags & IFF_RUNNING)
		wi_stop(sc);

	sc->wi_flags = 0;
d376 1
a376 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a384 1
		wi_cor_reset(sc);
a391 1
		sc->wi_flags &= ~WI_FLAGS_INITIALIZED;
@


1.15.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: if_wi_pcmcia.c,v 1.15.2.2 2002/06/11 03:42:28 art Exp $ */
d78 6
a172 5
	{ PCMCIA_VENDOR_ELSA,
	  PCMCIA_PRODUCT_ELSA_XI325_IEEE,
	  PCMCIA_CIS_ELSA_XI325_IEEE,
	  "XI325 Wireless LAN",
	},
a267 5
	{ PCMCIA_VENDOR_NETGEAR2,
	  PCMCIA_PRODUCT_NETGEAR2_MA401RA,
	  PCMCIA_CIS_NETGEAR2_MA401RA,
	  "Netgear MA401RA Wireless LAN PC CARD",
	},
d356 1
a356 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);
a360 1
	sc->wi_flags |= WI_FLAGS_BUS_PCMCIA;
@


1.15.2.4
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a271 5
	{ PCMCIA_VENDOR_AIRVAST,
	  PCMCIA_PRODUCT_AIRVAST_WN_100,
	  PCMCIA_CIS_AIRVAST_WN_100,
	  "AirVast WN-100 Wireless LAN PC CARD",
	},
d334 1
a334 1
	struct pcmcia_config_entry *cfe = SIMPLEQ_FIRST(&pf->cfe_head);
@


1.14
log
@match on buffalo and emtac wavelans; from netbsd
@
text
@d1 2
a2 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.13 2001/11/20 23:39:51 mickey Exp $	*/
d227 5
@


1.13
log
@match on linksys iwn; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.12 2001/11/02 22:07:00 mickey Exp $	*/
d211 15
@


1.12
log
@match on intel pro/wireless 2011, from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.11 2001/10/28 19:23:52 mickey Exp $	*/
d141 5
@


1.11
log
@match on elsa cf wireless lan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.10 2001/10/25 17:25:33 mickey Exp $	*/
d126 5
@


1.10
log
@match on corega pccb-11
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.9 2001/10/25 16:18:46 mickey Exp $	*/
d196 5
@


1.9
log
@match on gemtek
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.8 2001/08/17 21:52:16 deraadt Exp $	*/
d121 5
@


1.8
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.7 2001/06/23 01:56:10 millert Exp $	*/
d186 5
@


1.7
log
@Disable interupts *before* establishing them to avoid a race.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.6 2001/06/11 00:50:38 millert Exp $	*/
d283 1
a283 1
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, wi_intr, psc);
d334 2
a335 4
		printf("%s:", WI_PRT_ARG(sc));
		sc->sc_ih =
		    pcmcia_intr_establish(psc->sc_pf, IPL_NET, wi_intr, sc);
		printf("\n");
@


1.7.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.7 2001/06/23 01:56:10 millert Exp $	*/
a121 5
	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_PCCB_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCB_11,
	  "Corega Wireless LAN PCCB-11",
	},
a186 5
	{ PCMCIA_VENDOR_GEMTEK,
	  PCMCIA_PRODUCT_GEMTEK_WLAN,
	  PCMCIA_CIS_GEMTEK_WLAN,
	  "GEMTEK Prism2_5 WaveLAN Card"
	},
d283 1
a283 1
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, wi_intr, psc, "");
d334 4
a337 2
		sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
		    wi_intr, sc, sc->sc_dev.dv_xname);
@


1.7.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a126 5
	{ PCMCIA_VENDOR_INTEL,
	  PCMCIA_PRODUCT_INTEL_PRO_WLAN_2011,
	  PCMCIA_CIS_INTEL_PRO_WLAN_2011,
	  "Intel PRO/Wireless 2011",
	},
a195 5
	},
	{ PCMCIA_VENDOR_ELSA,
	  PCMCIA_PRODUCT_ELSA_XI800_IEEE,
	  PCMCIA_CIS_ELSA_XI800_IEEE,
	  "ELSA XI800 CF Wireless LAN"
@


1.7.2.3
log
@Merge in -current
@
text
@a141 5
	{ PCMCIA_VENDOR_LINKSYS2,
	  PCMCIA_PRODUCT_LINKSYS2_IWN,
	  PCMCIA_CIS_LINKSYS2_IWN,
	  "Linksys Instant Wireless Network",
	},
a205 15
	},
	{ PCMCIA_VENDOR_BUFFALO,
	  PCMCIA_PRODUCT_BUFFALO_WLI_PCM_S11,
	  PCMCIA_CIS_BUFFALO_WLI_PCM_S11,
	  "BUFFALO AirStation 11Mbps WLAN"
	},
	{ PCMCIA_VENDOR_BUFFALO,
	  PCMCIA_PRODUCT_BUFFALO_WLI_CF_S11G,
	  PCMCIA_CIS_BUFFALO_WLI_CF_S11G,
	  "BUFFALO AirStation 11Mbps CF WLAN"
	},
	{ PCMCIA_VENDOR_EMTAC,
	  PCMCIA_PRODUCT_EMTAC_WLAN,
	  PCMCIA_CIS_EMTAC_WLAN,
	  "EMTAC A2424i 11Mbps WLAN Card"
@


1.7.2.4
log
@Merge in trunk
@
text
@d1 1
a1 2
/* $OpenBSD$ */
/* $NetBSD: if_wi_pcmcia.c,v 1.14 2001/11/26 04:34:56 ichiro Exp $ */
d76 1
a226 9
	{ PCMCIA_VENDOR_SIMPLETECH,
	  PCMCIA_PRODUCT_SIMPLETECH_SPECTRUM24_ALT,
	  PCMCIA_CIS_SIMPLETECH_SPECTRUM24_ALT,
	  "LA4111 Spectrum24 WLAN PC Card"
	},
	{ PCMCIA_VENDOR_ERICSSON,
	  PCMCIA_PRODUCT_ERICSSON_WIRELESSLAN,
	  PCMCIA_CIS_ERICSSON_WIRELESSLAN,
	  "DSSS Wireless LAN PC Card" },
@


1.7.2.5
log
@Merge in -current from roughly a week ago
@
text
@d73 9
a81 9
int	wi_pcmcia_match(struct device *, void *, void *);
void	wi_pcmcia_attach(struct device *, struct device *, void *);
int	wi_pcmcia_detach(struct device *, int);
int	wi_pcmcia_activate(struct device *, enum devact);

int	wi_intr(void *);
int	wi_attach(struct wi_softc *, int);
void	wi_init(void *);
void	wi_stop(struct wi_softc *);
d243 1
a243 1
static const struct wi_pcmcia_product *wi_lookup(struct pcmcia_attach_args *pa);
@


1.7.2.6
log
@Sync the SMP branch with 3.3
@
text
@d78 5
a111 5
	{ PCMCIA_VENDOR_3COM,
	  PCMCIA_PRODUCT_3COM_3CRWE777A,
	  PCMCIA_CIS_3COM_3CRWE777A,
	  "3Com AirConnect Wireless LAN"
	},
a146 5
	{ PCMCIA_VENDOR_LINKSYS2,
	  PCMCIA_PRODUCT_LINKSYS2_IWN2,
	  PCMCIA_CIS_LINKSYS2_IWN2,
	  "Linksys Instant Wireless Network",
	},
a161 5
	{ PCMCIA_VENDOR_ELSA,
	  PCMCIA_PRODUCT_ELSA_XI325_IEEE,
	  PCMCIA_CIS_ELSA_XI325_IEEE,
	  "XI325 Wireless LAN",
	},
d235 1
a235 32
	  "DSSS Wireless LAN PC Card" 
	},
	{ PCMCIA_VENDOR_PROXIM,
	  PCMCIA_PRODUCT_PROXIM_RANGELANDS_8430,
	  PCMCIA_CIS_PROXIM_RANGELANDS_8430,
	  "Proxim RangeLAN-DS/LAN PC CARD",
	},
	{ PCMCIA_VENDOR_ACTIONTEC,
	  PCMCIA_PRODUCT_ACTIONTEC_HWC01170,
	  PCMCIA_CIS_ACTIONTEC_HWC01170,
	  "ACTIONTEC PRISM Wireless LAN PC CARD",
	},
	{ PCMCIA_VENDOR_NOKIA,
	  PCMCIA_PRODUCT_NOKIA_C020_WLAN,
	  PCMCIA_CIS_NOKIA_C020_WLAN,
	  "NOKIA C020 Wireless LAN PC CARD",
	},
	{ PCMCIA_VENDOR_NOKIA,
	  PCMCIA_PRODUCT_NOKIA_C110_WLAN,
	  PCMCIA_CIS_NOKIA_C110_WLAN,
	  "NOKIA C110 Wireless LAN PC CARD",
	},
	{ PCMCIA_VENDOR_NETGEAR2,
	  PCMCIA_PRODUCT_NETGEAR2_MA401RA,
	  PCMCIA_CIS_NETGEAR2_MA401RA,
	  "Netgear MA401RA Wireless LAN PC CARD",
	},
	{ PCMCIA_VENDOR_AIRVAST,
	  PCMCIA_PRODUCT_AIRVAST_WN_100,
	  PCMCIA_CIS_AIRVAST_WN_100,
	  "AirVast WN-100 Wireless LAN PC CARD",
	},
d298 1
a298 1
	struct pcmcia_config_entry *cfe = SIMPLEQ_FIRST(&pf->cfe_head);
d324 2
a325 6
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);

	sc->wi_ltag = sc->wi_btag = psc->sc_pcioh.iot;
	sc->wi_lhandle = sc->wi_bhandle = psc->sc_pcioh.ioh;
	sc->wi_cor_offset = WI_COR_OFFSET;
	sc->wi_flags |= WI_FLAGS_BUS_PCMCIA;
d339 1
a339 1
	wi_attach(sc);
d358 1
a358 11
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED)) {
		printf("%s: already detached\n", sc->sc_dev.dv_xname);
		return (0);
	}

	if (ifp->if_flags & IFF_RUNNING)
		wi_stop(sc);

	sc->wi_flags = 0;
d376 1
a376 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a384 1
		wi_cor_reset(sc);
a391 1
		sc->wi_flags &= ~WI_FLAGS_INITIALIZED;
@


1.7.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d95 1
d99 2
a100 1
	  PCMCIA_CIS_LUCENT_WAVELAN_IEEE
d104 2
a105 1
	  PCMCIA_CIS_3COM_3CRWE737A
d109 2
a110 1
	  PCMCIA_CIS_3COM_3CRWE777A
d114 2
a115 1
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCC_11
d119 2
a120 1
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCA_11
d124 2
a125 5
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCB_11
	},
	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_PCCL_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCL_11
d129 2
a130 1
	  PCMCIA_CIS_INTEL_PRO_WLAN_2011
d134 2
a135 1
	  PCMCIA_CIS_INTERSIL_PRISM2
d139 2
a140 1
	  PCMCIA_CIS_SAMSUNG_SWL_2000N
d144 2
a145 1
	  PCMCIA_CIS_LINKSYS2_IWN
d149 2
a150 1
	  PCMCIA_CIS_LINKSYS2_IWN2
d154 2
a155 1
	  PCMCIA_CIS_SMC_2632W
d159 2
a160 1
	  PCMCIA_CIS_NANOSPEED_PRISM2
d164 2
a165 1
	  PCMCIA_CIS_ELSA_XI300_IEEE
d169 2
a170 1
	  PCMCIA_CIS_ELSA_XI325_IEEE
d174 2
a175 1
	  PCMCIA_CIS_COMPAQ_NC5004
d179 2
a180 1
	  PCMCIA_CIS_CONTEC_FX_DS110_PCC
d184 2
a185 1
	  PCMCIA_CIS_TDK_LAK_CD011WL
d189 2
a190 1
	  PCMCIA_CIS_NEC_CMZ_RT_WP
d194 2
a195 1
	  PCMCIA_CIS_NTT_ME_WLAN
d199 2
a200 1
	  PCMCIA_CIS_ADDTRON_AWP100
d204 2
a205 1
	  PCMCIA_CIS_CABLETRON_ROAMABOUT
d209 2
a210 1
	  PCMCIA_CIS_IODATA2_WNB11PCM
d214 2
a215 1
	  PCMCIA_CIS_GEMTEK_WLAN
d219 2
a220 1
	  PCMCIA_CIS_ELSA_XI800_IEEE
d224 2
a225 1
	  PCMCIA_CIS_BUFFALO_WLI_PCM_S11
d229 2
a230 1
	  PCMCIA_CIS_BUFFALO_WLI_CF_S11G
d234 2
a235 1
	  PCMCIA_CIS_EMTAC_WLAN
d239 2
a240 1
	  PCMCIA_CIS_SIMPLETECH_SPECTRUM24_ALT
d244 2
a245 1
	  PCMCIA_CIS_ERICSSON_WIRELESSLAN
d249 2
a250 1
	  PCMCIA_CIS_PROXIM_RANGELANDS_8430
d254 2
a255 1
	  PCMCIA_CIS_ACTIONTEC_HWC01170
d259 2
a260 1
	  PCMCIA_CIS_NOKIA_C020_WLAN
d264 2
a265 1
	  PCMCIA_CIS_NOKIA_C110_WLAN
d269 2
a270 1
	  PCMCIA_CIS_NETGEAR2_MA401RA
d274 2
a275 1
	  PCMCIA_CIS_AIRVAST_WN_100
d277 4
a280 3
	{ PCMCIA_VENDOR_SIEMENS,
	  PCMCIA_PRODUCT_SIEMENS_SS1021,
	  PCMCIA_CIS_SIEMENS_SS1021
a290 2
	const struct wi_pcmcia_product *epp = wi_pcmcia_products +
	    sizeof(wi_pcmcia_products) / sizeof(wi_pcmcia_products[0]);
d296 1
a296 1
	for (pp = wi_pcmcia_products; pp < epp; pp++) {
d307 1
a307 1
	for (pp = wi_pcmcia_products; pp < epp; pp++) {
d384 1
a384 1
	wi_attach(sc, &wi_func_io);
d410 2
a411 1
	wi_detach(sc);
@


1.7.2.8
log
@Merge with the trunk
@
text
@a246 12
	},
	{ PCMCIA_VENDOR_MICROSOFT,
	  PCMCIA_PRODUCT_MICROSOFT_MN520,
	  PCMCIA_CIS_MICROSOFT_MN520
	},
	{ PCMCIA_VENDOR_ADAPTEC2,
	  PCMCIA_PRODUCT_ADAPTEC2_AWN8030,
	  PCMCIA_CIS_ADAPTEC2_AWN8030
	},
	{ PCMCIA_VENDOR_ASUS,
	  PCMCIA_PRODUCT_ASUS_WL_100,
	  PCMCIA_CIS_ASUS_WL_100
d352 2
a353 4
	if (wi_attach(sc, &wi_func_io) == 0)
		return;

	pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
@


1.6
log
@For PCI attachments print the CIS strings since otherwise all we have
is info on the PCI -> PCMCIA dumb bridge and not the card itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.5 2001/06/07 22:41:00 millert Exp $	*/
d60 2
d278 4
a288 4

	/* Make sure interrupts are disabled. */
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	CSR_WRITE_2(sc, WI_EVENT_ACK, 0xffff);
@


1.5
log
@no longer need bogus Linksys WPC11 entry now that we autodetect prism vs. lucent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.4 2001/06/07 04:49:07 mickey Exp $	*/
d77 1
a77 1
int	wi_attach		__P((struct wi_softc *));
d288 1
a288 1
	wi_attach(sc);
@


1.4
log
@probe prism2 chips based on the probed card id, not cis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.3 2001/06/06 18:53:49 millert Exp $	*/
a183 5
	},
	{ PCMCIA_VENDOR_LINKSYS,
	  PCMCIA_PRODUCT_LINKSYS_WPC11,
	  PCMCIA_CIS_LINKSYS_WPC11,
	  "Linksys WPC11",
@


1.3
log
@PCI shim for if_wi.c as	promised.  Magic for setting the PLX up
correctly take from the FreeBSD driver and explained by imp@@
Currently this is hard-coded for PrismII cards but that will change
when the PrismII auto-detect code is added to if_wi.c.
Tested with a LinkSys WPC11 in a Global Sun GL24110P02 (aka LinSys WDT11)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.2 2001/05/22 11:04:50 fgsch Exp $	*/
a98 1
	int		pp_prism2;
d103 2
a104 3
	  "WaveLAN/IEEE",
	  0 },

d108 2
a109 3
	  "3Com AirConnect Wireless LAN",
	  1 },

d113 2
a114 3
	  "Corega Wireless LAN PCC-11",
	  1 },

d119 1
a119 2
	  1 },

d124 1
a124 2
	  1 },

d129 1
a129 2
	  1 },

d134 1
a134 2
	  1 },

d139 1
a139 2
	  1 },

d144 1
a144 2
	  1 },

d149 1
a149 2
	  1 },

d154 1
a154 2
	  1 },

d159 1
a159 2
	  1 },

d164 1
a164 2
	  1 },

d169 1
a169 2
	  1 },

d174 1
a174 2
	  1 },

d179 1
a179 2
	  0 },

d184 1
a184 2
	  1 },

d189 1
a189 2
	  1 },

d194 1
a194 1
	  0 }
a252 1
	const struct wi_pcmcia_product *pp;
a276 7

	pp = wi_lookup(pa);
	if (pp == NULL) {
		/* should not happen */
		sc->sc_prism2 = 0;
	} else
		sc->sc_prism2 = pp->pp_prism2;
@


1.2
log
@Vendor and prodid are 16-bits, not 32.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.1 2001/05/15 02:40:35 millert Exp $	*/
d315 4
@


1.1
log
@Split wi(4) into bus-dependent and bus-independent bits similar to
an(4) -- no real code changes at this point.
Rename if_wavelan_ieee.h to if_wi_ieee.h while I'm at it and
create an if_wivar.h similar to NetBSD.
PCI adaptors exist that are not true PCMCIA controllers so
wi(4) @@ PCI is possible (though the code is not working yet ;-).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pcmcia.c,v 1.30 2001/04/08 21:44:36 mickey Exp $	*/
d95 2
a96 2
	u_int32_t	pp_vendor;
	u_int32_t	pp_product;
@

