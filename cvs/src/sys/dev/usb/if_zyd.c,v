head	1.118;
access;
symbols
	OPENBSD_6_1:1.117.0.4
	OPENBSD_6_1_BASE:1.117
	OPENBSD_6_0:1.115.0.4
	OPENBSD_6_0_BASE:1.115
	OPENBSD_5_9:1.114.0.2
	OPENBSD_5_9_BASE:1.114
	OPENBSD_5_8:1.108.0.4
	OPENBSD_5_8_BASE:1.108
	OPENBSD_5_7:1.107.0.2
	OPENBSD_5_7_BASE:1.107
	OPENBSD_5_6:1.104.0.4
	OPENBSD_5_6_BASE:1.104
	OPENBSD_5_5:1.95.0.4
	OPENBSD_5_5_BASE:1.95
	OPENBSD_5_4:1.90.0.2
	OPENBSD_5_4_BASE:1.90
	OPENBSD_5_3:1.88.0.8
	OPENBSD_5_3_BASE:1.88
	OPENBSD_5_2:1.88.0.6
	OPENBSD_5_2_BASE:1.88
	OPENBSD_5_1_BASE:1.88
	OPENBSD_5_1:1.88.0.4
	OPENBSD_5_0:1.88.0.2
	OPENBSD_5_0_BASE:1.88
	OPENBSD_4_9:1.87.0.2
	OPENBSD_4_9_BASE:1.87
	OPENBSD_4_8:1.81.0.4
	OPENBSD_4_8_BASE:1.81
	OPENBSD_4_7:1.81.0.2
	OPENBSD_4_7_BASE:1.81
	OPENBSD_4_6:1.79.0.4
	OPENBSD_4_6_BASE:1.79
	OPENBSD_4_5:1.72.0.2
	OPENBSD_4_5_BASE:1.72
	OPENBSD_4_4:1.69.0.2
	OPENBSD_4_4_BASE:1.69
	OPENBSD_4_3:1.66.0.2
	OPENBSD_4_3_BASE:1.66
	OPENBSD_4_2:1.58.0.2
	OPENBSD_4_2_BASE:1.58
	OPENBSD_4_1:1.52.0.2
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25;
locks; strict;
comment	@ * @;


1.118
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	6s3MfY9d6ZKdL2Uz;

1.117
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.116;
commitid	x5RWYO05Q3UFL5Oq;

1.116
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.115;
commitid	VyLWTsbepAOk7VQM;

1.115
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.114;
commitid	gWZDkudwxydTq8x4;

1.114
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.113;
commitid	fbhqfhfdKxBcsetK;

1.113
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.112;
commitid	B0kwmVGiD5DVx4kv;

1.112
date	2015.11.24.13.45.07;	author mpi;	state Exp;
branches;
next	1.111;
commitid	FuSD2mFDJWATHIDx;

1.111
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.110;
commitid	5DvsamK0GblTp8ww;

1.110
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.109;
commitid	YT6fyIEviv9qwbl6;

1.109
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.108;
commitid	pwYnMC1gOKohmeGw;

1.108
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.107;
commitid	p4LJxGKbi0BU2cG6;

1.107
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.106;
commitid	Hly9lJn6CNMylcFu;

1.106
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.105;
commitid	yM2VFFhpDTeFQlve;

1.105
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.104;
commitid	LS2TNeCue5R9L67C;

1.104
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.103;
commitid	Pclvgy2Z4XV9hveD;

1.103
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.102;
commitid	OBNa5kfxQ2UXoiIw;

1.102
date	2014.07.12.15.26.54;	author stsp;	state Exp;
branches;
next	1.101;
commitid	sxfxtPjGFKbiRn3A;

1.101
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.100;
commitid	b0VSac5dnnsxcDao;

1.100
date	2014.06.03.14.41.56;	author stsp;	state Exp;
branches;
next	1.99;
commitid	LK0uyjqw1gppkIxa;

1.99
date	2014.06.03.14.41.26;	author stsp;	state Exp;
branches;
next	1.98;
commitid	zwp9QqEi0aa3efwm;

1.98
date	2014.06.03.14.41.04;	author stsp;	state Exp;
branches;
next	1.97;
commitid	JbKMKV67uO8z2HqP;

1.97
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.95;

1.95
date	2014.02.15.02.20.29;	author jsg;	state Exp;
branches;
next	1.94;

1.94
date	2013.11.26.20.33.19;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2013.11.06.15.55.15;	author jeremy;	state Exp;
branches;
next	1.92;

1.92
date	2013.11.05.10.20.05;	author mpi;	state Exp;
branches;
next	1.91;

1.91
date	2013.08.07.01.06.43;	author bluhm;	state Exp;
branches;
next	1.90;

1.90
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.89;

1.89
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.88;

1.88
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.87;

1.87
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.86;

1.86
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.85;

1.85
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.84;

1.84
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.83;

1.83
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.82;

1.82
date	2010.08.27.17.08.01;	author jsg;	state Exp;
branches;
next	1.81;

1.81
date	2009.11.22.22.13.51;	author jsg;	state Exp;
branches;
next	1.80;

1.80
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.01.08.53.44;	author damien;	state Exp;
branches;
next	1.78;

1.78
date	2009.06.01.08.51.22;	author damien;	state Exp;
branches;
next	1.77;

1.77
date	2009.06.01.08.43.20;	author damien;	state Exp;
branches;
next	1.76;

1.76
date	2009.05.31.13.03.21;	author jsg;	state Exp;
branches;
next	1.75;

1.75
date	2009.05.31.12.33.29;	author jsg;	state Exp;
branches;
next	1.74;

1.74
date	2009.05.31.12.29.21;	author jsg;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.27.11.40.56;	author jsg;	state Exp;
branches;
next	1.72;

1.72
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.71;

1.71
date	2008.08.27.09.49.32;	author damien;	state Exp;
branches;
next	1.70;

1.70
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.69;

1.69
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.68;

1.68
date	2008.05.27.00.11.11;	author jsg;	state Exp;
branches;
next	1.67;

1.67
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.66;

1.66
date	2007.12.07.05.05.02;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.27.20.30.14;	author damien;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.18.00.43.13;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.03.14.10.37;	author damien;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.14.08.31.55;	author fkr;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2007.08.28.18.34.38;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.11.00.08.04;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.09.09.11.22;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2007.01.14.00.12.13;	author jsg;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.02.14.43.50;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.16.15.35.47;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2006.12.09.23.26.02;	author maja;	state Exp;
branches;
next	1.46;

1.46
date	2006.12.02.16.43.27;	author mglocker;	state Exp;
branches;
next	1.45;

1.45
date	2006.11.30.19.28.07;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.30.17.45.40;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.30.17.39.12;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.30.09.27.20;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.29.16.23.19;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.29.13.56.17;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2006.11.27.15.44.03;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.26.11.14.22;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.16.19.43.52;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.13.20.06.38;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.03.19.34.56;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.01.11.52.24;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.23.18.08.34;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2006.10.23.17.44.15;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.22.12.52.03;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.22.11.53.21;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.21.18.32.20;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.10.21.18.18.50;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2006.09.23.22.28.43;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2006.09.18.16.20.20;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2006.08.24.13.16.02;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.15.18.10.54;	author niallo;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.04.15.49.19;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.04.06.53.17;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.03.14.16.12;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.03.13.12.58;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2006.07.02.06.52.36;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.02.02.59.21;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.02.02.16.49;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.02.01.25.10;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.02.01.04.58;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.02.00.56.14;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.01.05.07.26;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.01.04.25.07;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.30.12.27.21;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.29.12.13.43;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.28.04.30.24;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.28.04.15.40;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.28.03.48.46;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.27.13.40.35;	author xsa;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.27.13.30.01;	author xsa;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.27.09.21.55;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.27.03.49.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.21.18.49.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.21.18.45.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.118
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: if_zyd.c,v 1.117 2017/03/26 15:31:15 deraadt Exp $	*/

/*-
 * Copyright (c) 2006 by Damien Bergamini <damien.bergamini@@free.fr>
 * Copyright (c) 2006 by Florian Stoehr <ich@@florian-stoehr.de>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * ZyDAS ZD1211/ZD1211B USB WLAN driver.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_zydreg.h>

#ifdef ZYD_DEBUG
#define DPRINTF(x)	do { if (zyddebug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (zyddebug > (n)) printf x; } while (0)
int zyddebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

static const struct zyd_phy_pair zyd_def_phy[] = ZYD_DEF_PHY;
static const struct zyd_phy_pair zyd_def_phyB[] = ZYD_DEF_PHYB;

/* various supported device vendors/products */
#define ZYD_ZD1211_DEV(v, p)	\
	{ { USB_VENDOR_##v, USB_PRODUCT_##v##_##p }, ZYD_ZD1211 }
#define ZYD_ZD1211B_DEV(v, p)	\
	{ { USB_VENDOR_##v, USB_PRODUCT_##v##_##p }, ZYD_ZD1211B }
static const struct zyd_type {
	struct usb_devno	dev;
	uint8_t			rev;
#define ZYD_ZD1211	0
#define ZYD_ZD1211B	1
} zyd_devs[] = {
	ZYD_ZD1211_DEV(3COM2,		3CRUSB10075),
	ZYD_ZD1211_DEV(ABOCOM,		WL54),
	ZYD_ZD1211_DEV(ASUS,		WL159G),
	ZYD_ZD1211_DEV(CYBERTAN,	TG54USB),
	ZYD_ZD1211_DEV(DRAYTEK,		VIGOR550),
	ZYD_ZD1211_DEV(PLANEX2,		GWUS54GD),
	ZYD_ZD1211_DEV(PLANEX2,		GWUS54GZL),
	ZYD_ZD1211_DEV(PLANEX3,		GWUS54GZ),
	ZYD_ZD1211_DEV(PLANEX3,		GWUS54MINI),
	ZYD_ZD1211_DEV(SAGEM,		XG760A),
	ZYD_ZD1211_DEV(SENAO,		NUB8301),
	ZYD_ZD1211_DEV(SITECOMEU,	WL113),
	ZYD_ZD1211_DEV(SWEEX,		ZD1211),
	ZYD_ZD1211_DEV(TEKRAM,		QUICKWLAN),
	ZYD_ZD1211_DEV(TEKRAM,		ZD1211_1),
	ZYD_ZD1211_DEV(TEKRAM,		ZD1211_2),
	ZYD_ZD1211_DEV(TWINMOS,		G240),
	ZYD_ZD1211_DEV(UMEDIA,		ALL0298V2),
	ZYD_ZD1211_DEV(UMEDIA,		TEW429UB_A),
	ZYD_ZD1211_DEV(UMEDIA,		TEW429UB),
	ZYD_ZD1211_DEV(UNKNOWN2,	NW3100),
	ZYD_ZD1211_DEV(WISTRONNEWEB,	UR055G),
	ZYD_ZD1211_DEV(ZCOM,		ZD1211),
	ZYD_ZD1211_DEV(ZYDAS,		ALL0298),
	ZYD_ZD1211_DEV(ZYDAS,		ZD1211),
	ZYD_ZD1211_DEV(ZYXEL,		AG225H),
	ZYD_ZD1211_DEV(ZYXEL,		G200V2),
	ZYD_ZD1211_DEV(ZYXEL,		G202),
	ZYD_ZD1211_DEV(ZYXEL,		G220),
	ZYD_ZD1211_DEV(ZYXEL,		G220F),

	ZYD_ZD1211B_DEV(ACCTON,		SMCWUSBG),
	ZYD_ZD1211B_DEV(ACCTON,		WN4501H_LF_IR),
	ZYD_ZD1211B_DEV(ACCTON,		WUS201),
	ZYD_ZD1211B_DEV(ACCTON,		ZD1211B),
	ZYD_ZD1211B_DEV(ASUS,		A9T_WIFI),
	ZYD_ZD1211B_DEV(BELKIN,		F5D7050C),
	ZYD_ZD1211B_DEV(BELKIN,		ZD1211B),
	ZYD_ZD1211B_DEV(BEWAN,		BWIFI_USB54AR),
	ZYD_ZD1211B_DEV(CISCOLINKSYS,	WUSBF54G),
	ZYD_ZD1211B_DEV(CYBERTAN,	ZD1211B),
	ZYD_ZD1211B_DEV(FIBERLINE,	WL430U),
	ZYD_ZD1211B_DEV(MELCO,		KG54L),
	ZYD_ZD1211B_DEV(PHILIPS,	SNU5600),
	ZYD_ZD1211B_DEV(PHILIPS,	SNU5630NS05),
	ZYD_ZD1211B_DEV(PLANEX2,	GW_US54GXS),
	ZYD_ZD1211B_DEV(PLANEX4,	GWUS54ZGL),
	ZYD_ZD1211B_DEV(PLANEX4,	ZD1211B),
	ZYD_ZD1211B_DEV(SAGEM,		XG76NA),
	ZYD_ZD1211B_DEV(SITECOMEU,	WL603),
	ZYD_ZD1211B_DEV(SITECOMEU,	ZD1211B),
	ZYD_ZD1211B_DEV(UMEDIA,		TEW429UBC1),
	ZYD_ZD1211B_DEV(UNKNOWN2,	ZD1211B),
	ZYD_ZD1211B_DEV(UNKNOWN3,	ZD1211B),
	ZYD_ZD1211B_DEV(SONY,		IFU_WLM2),
	ZYD_ZD1211B_DEV(USR,		USR5423),
	ZYD_ZD1211B_DEV(VTECH,		ZD1211B),
	ZYD_ZD1211B_DEV(ZCOM,		ZD1211B),
	ZYD_ZD1211B_DEV(ZYDAS,		ZD1211B),
	ZYD_ZD1211B_DEV(ZYDAS,		ZD1211B_2),
	ZYD_ZD1211B_DEV(ZYXEL,		AG220),
	ZYD_ZD1211B_DEV(ZYXEL,		AG225HV2),
	ZYD_ZD1211B_DEV(ZYXEL,		G220V2),
	ZYD_ZD1211B_DEV(ZYXEL,		M202)
};
#define zyd_lookup(v, p)	\
	((const struct zyd_type *)usb_lookup(zyd_devs, v, p))

int zyd_match(struct device *, void *, void *);
void zyd_attach(struct device *, struct device *, void *);
int zyd_detach(struct device *, int);

struct cfdriver zyd_cd = {
	NULL, "zyd", DV_IFNET
};

const struct cfattach zyd_ca = {
	sizeof(struct zyd_softc), zyd_match, zyd_attach, zyd_detach
};

void		zyd_attachhook(struct device *);
int		zyd_complete_attach(struct zyd_softc *);
int		zyd_open_pipes(struct zyd_softc *);
void		zyd_close_pipes(struct zyd_softc *);
int		zyd_alloc_tx_list(struct zyd_softc *);
void		zyd_free_tx_list(struct zyd_softc *);
int		zyd_alloc_rx_list(struct zyd_softc *);
void		zyd_free_rx_list(struct zyd_softc *);
struct		ieee80211_node *zyd_node_alloc(struct ieee80211com *);
int		zyd_media_change(struct ifnet *);
void		zyd_next_scan(void *);
void		zyd_task(void *);
int		zyd_newstate(struct ieee80211com *, enum ieee80211_state, int);
int		zyd_cmd_read(struct zyd_softc *, const void *, size_t, int);
int		zyd_read16(struct zyd_softc *, uint16_t, uint16_t *);
int		zyd_read32(struct zyd_softc *, uint16_t, uint32_t *);
int		zyd_cmd_write(struct zyd_softc *, u_int16_t, const void *, int);
int		zyd_write16(struct zyd_softc *, uint16_t, uint16_t);
int		zyd_write32(struct zyd_softc *, uint16_t, uint32_t);
int		zyd_rfwrite(struct zyd_softc *, uint32_t);
void		zyd_lock_phy(struct zyd_softc *);
void		zyd_unlock_phy(struct zyd_softc *);
int		zyd_rfmd_init(struct zyd_rf *);
int		zyd_rfmd_switch_radio(struct zyd_rf *, int);
int		zyd_rfmd_set_channel(struct zyd_rf *, uint8_t);
int		zyd_al2230_init(struct zyd_rf *);
int		zyd_al2230_switch_radio(struct zyd_rf *, int);
int		zyd_al2230_set_channel(struct zyd_rf *, uint8_t);
int		zyd_al2230_init_b(struct zyd_rf *);
int		zyd_al7230B_init(struct zyd_rf *);
int		zyd_al7230B_switch_radio(struct zyd_rf *, int);
int		zyd_al7230B_set_channel(struct zyd_rf *, uint8_t);
int		zyd_al2210_init(struct zyd_rf *);
int		zyd_al2210_switch_radio(struct zyd_rf *, int);
int		zyd_al2210_set_channel(struct zyd_rf *, uint8_t);
int		zyd_gct_init(struct zyd_rf *);
int		zyd_gct_switch_radio(struct zyd_rf *, int);
int		zyd_gct_set_channel(struct zyd_rf *, uint8_t);
int		zyd_maxim_init(struct zyd_rf *);
int		zyd_maxim_switch_radio(struct zyd_rf *, int);
int		zyd_maxim_set_channel(struct zyd_rf *, uint8_t);
int		zyd_maxim2_init(struct zyd_rf *);
int		zyd_maxim2_switch_radio(struct zyd_rf *, int);
int		zyd_maxim2_set_channel(struct zyd_rf *, uint8_t);
int		zyd_rf_attach(struct zyd_softc *, uint8_t);
const char	*zyd_rf_name(uint8_t);
int		zyd_hw_init(struct zyd_softc *);
int		zyd_read_eeprom(struct zyd_softc *);
void		zyd_set_multi(struct zyd_softc *);
void		zyd_set_macaddr(struct zyd_softc *, const uint8_t *);
void		zyd_set_bssid(struct zyd_softc *, const uint8_t *);
int		zyd_switch_radio(struct zyd_softc *, int);
void		zyd_set_led(struct zyd_softc *, int, int);
int		zyd_set_rxfilter(struct zyd_softc *);
void		zyd_set_chan(struct zyd_softc *, struct ieee80211_channel *);
int		zyd_set_beacon_interval(struct zyd_softc *, int);
uint8_t		zyd_plcp_signal(int);
void		zyd_intr(struct usbd_xfer *, void *, usbd_status);
void		zyd_rx_data(struct zyd_softc *, const uint8_t *, uint16_t);
void		zyd_rxeof(struct usbd_xfer *, void *, usbd_status);
void		zyd_txeof(struct usbd_xfer *, void *, usbd_status);
int		zyd_tx(struct zyd_softc *, struct mbuf *,
		    struct ieee80211_node *);
void		zyd_start(struct ifnet *);
void		zyd_watchdog(struct ifnet *);
int		zyd_ioctl(struct ifnet *, u_long, caddr_t);
int		zyd_init(struct ifnet *);
void		zyd_stop(struct ifnet *, int);
int		zyd_loadfirmware(struct zyd_softc *, u_char *, size_t);
void		zyd_iter_func(void *, struct ieee80211_node *);
void		zyd_amrr_timeout(void *);
void		zyd_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);

int
zyd_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (!uaa->iface)
		return UMATCH_NONE;

	return (zyd_lookup(uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
}

void
zyd_attachhook(struct device *self)
{
	struct zyd_softc *sc = (struct zyd_softc *)self;
	const char *fwname;
	u_char *fw;
	size_t fwsize;
	int error;

	fwname = (sc->mac_rev == ZYD_ZD1211) ? "zd1211" : "zd1211b";
	if ((error = loadfirmware(fwname, &fw, &fwsize)) != 0) {
		printf("%s: error %d, could not read firmware file %s\n",
		    sc->sc_dev.dv_xname, error, fwname);
		return;
	}

	error = zyd_loadfirmware(sc, fw, fwsize);
	free(fw, M_DEVBUF, fwsize);
	if (error != 0) {
		printf("%s: could not load firmware (error=%d)\n",
		    sc->sc_dev.dv_xname, error);
		return;
	}

	/* complete the attach process */
	if (zyd_complete_attach(sc) == 0)
		sc->attached = 1;
}

void
zyd_attach(struct device *parent, struct device *self, void *aux)
{
	struct zyd_softc *sc = (struct zyd_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usb_device_descriptor_t* ddesc;

	sc->sc_udev = uaa->device;

	sc->mac_rev = zyd_lookup(uaa->vendor, uaa->product)->rev;

	ddesc = usbd_get_device_descriptor(sc->sc_udev);
	if (UGETW(ddesc->bcdDevice) < 0x4330) {
		printf("%s: device version mismatch: 0x%x "
		    "(only >= 43.30 supported)\n", sc->sc_dev.dv_xname,
		    UGETW(ddesc->bcdDevice));
		return;
	}

	config_mountroot(self, zyd_attachhook);
}

int
zyd_complete_attach(struct zyd_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	usbd_status error;
	int i;

	usb_init_task(&sc->sc_task, zyd_task, sc, USB_TASK_TYPE_GENERIC);
	timeout_set(&sc->scan_to, zyd_next_scan, sc);

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 10;
	timeout_set(&sc->amrr_to, zyd_amrr_timeout, sc);

	error = usbd_set_config_no(sc->sc_udev, ZYD_CONFIG_NO, 1);
	if (error != 0) {
		printf("%s: setting config no failed\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = usbd_device2interface_handle(sc->sc_udev, ZYD_IFACE_INDEX,
	    &sc->sc_iface);
	if (error != 0) {
		printf("%s: getting interface handle failed\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	if ((error = zyd_open_pipes(sc)) != 0) {
		printf("%s: could not open pipes\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	if ((error = zyd_read_eeprom(sc)) != 0) {
		printf("%s: could not read EEPROM\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	if ((error = zyd_rf_attach(sc, sc->rf_rev)) != 0) {
		printf("%s: could not attach RF\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	if ((error = zyd_hw_init(sc)) != 0) {
		printf("%s: hardware initialization failed\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	printf("%s: HMAC ZD1211%s, FW %02x.%02x, RF %s, PA %x, address %s\n",
	    sc->sc_dev.dv_xname, (sc->mac_rev == ZYD_ZD1211) ? "": "B",
	    sc->fw_rev >> 8, sc->fw_rev & 0xff, zyd_rf_name(sc->rf_rev),
	    sc->pa_rev, ether_sprintf(ic->ic_myaddr));

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* set device capabilities */
	ic->ic_caps =
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
	    IEEE80211_C_TXPMGT |	/* tx power management */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_WEP |		/* s/w WEP */
	    IEEE80211_C_RSN;		/* WPA/RSN */

	/* set supported .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = zyd_ioctl;
	ifp->if_start = zyd_start;
	ifp->if_watchdog = zyd_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_node_alloc = zyd_node_alloc;
	ic->ic_newassoc = zyd_newassoc;

	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = zyd_newstate;
	ieee80211_media_init(ifp, zyd_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(ZYD_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(ZYD_TX_RADIOTAP_PRESENT);
#endif

fail:	return error;
}

int
zyd_detach(struct device *self, int flags)
{
	struct zyd_softc *sc = (struct zyd_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	s = splusb();

	usb_rem_task(sc->sc_udev, &sc->sc_task);
	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->amrr_to))
		timeout_del(&sc->amrr_to);

	zyd_close_pipes(sc);

	if (!sc->attached) {
		splx(s);
		return 0;
	}

	if (ifp->if_softc != NULL) {
		ieee80211_ifdetach(ifp);
		if_detach(ifp);
	}

	zyd_free_rx_list(sc);
	zyd_free_tx_list(sc);

	sc->attached = 0;

	splx(s);

	return 0;
}

int
zyd_open_pipes(struct zyd_softc *sc)
{
	usb_endpoint_descriptor_t *edesc;
	int isize;
	usbd_status error;

	/* interrupt in */
	edesc = usbd_get_endpoint_descriptor(sc->sc_iface, 0x83);
	if (edesc == NULL)
		return EINVAL;

	isize = UGETW(edesc->wMaxPacketSize);
	if (isize == 0)	/* should not happen */
		return EINVAL;

	sc->ibuf = malloc(isize, M_USBDEV, M_NOWAIT);
	if (sc->ibuf == NULL)
		return ENOMEM;
	sc->ibuflen = isize;
	error = usbd_open_pipe_intr(sc->sc_iface, 0x83, USBD_SHORT_XFER_OK,
	    &sc->zyd_ep[ZYD_ENDPT_IIN], sc, sc->ibuf, isize, zyd_intr,
	    USBD_DEFAULT_INTERVAL);
	if (error != 0) {
		printf("%s: open rx intr pipe failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	/* interrupt out (not necessarily an interrupt pipe) */
	error = usbd_open_pipe(sc->sc_iface, 0x04, USBD_EXCLUSIVE_USE,
	    &sc->zyd_ep[ZYD_ENDPT_IOUT]);
	if (error != 0) {
		printf("%s: open tx intr pipe failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	/* bulk in */
	error = usbd_open_pipe(sc->sc_iface, 0x82, USBD_EXCLUSIVE_USE,
	    &sc->zyd_ep[ZYD_ENDPT_BIN]);
	if (error != 0) {
		printf("%s: open rx pipe failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	/* bulk out */
	error = usbd_open_pipe(sc->sc_iface, 0x01, USBD_EXCLUSIVE_USE,
	    &sc->zyd_ep[ZYD_ENDPT_BOUT]);
	if (error != 0) {
		printf("%s: open tx pipe failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	return 0;

fail:	zyd_close_pipes(sc);
	return error;
}

void
zyd_close_pipes(struct zyd_softc *sc)
{
	int i;

	for (i = 0; i < ZYD_ENDPT_CNT; i++) {
		if (sc->zyd_ep[i] != NULL) {
			usbd_abort_pipe(sc->zyd_ep[i]);
			usbd_close_pipe(sc->zyd_ep[i]);
			sc->zyd_ep[i] = NULL;
		}
	}
	if (sc->ibuf != NULL) {
		free(sc->ibuf, M_USBDEV, sc->ibuflen);
		sc->ibuf = NULL;
	}
}

int
zyd_alloc_tx_list(struct zyd_softc *sc)
{
	int i, error;

	sc->tx_queued = 0;

	for (i = 0; i < ZYD_TX_LIST_CNT; i++) {
		struct zyd_tx_data *data = &sc->tx_data[i];

		data->sc = sc;	/* backpointer for callbacks */

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate tx xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		data->buf = usbd_alloc_buffer(data->xfer, ZYD_MAX_TXBUFSZ);
		if (data->buf == NULL) {
			printf("%s: could not allocate tx buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		/* clear Tx descriptor */
		bzero(data->buf, sizeof (struct zyd_tx_desc));
	}
	return 0;

fail:	zyd_free_tx_list(sc);
	return error;
}

void
zyd_free_tx_list(struct zyd_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	int i;

	for (i = 0; i < ZYD_TX_LIST_CNT; i++) {
		struct zyd_tx_data *data = &sc->tx_data[i];

		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}
		if (data->ni != NULL) {
			ieee80211_release_node(ic, data->ni);
			data->ni = NULL;
		}
	}
}

int
zyd_alloc_rx_list(struct zyd_softc *sc)
{
	int i, error;

	for (i = 0; i < ZYD_RX_LIST_CNT; i++) {
		struct zyd_rx_data *data = &sc->rx_data[i];

		data->sc = sc;	/* backpointer for callbacks */

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate rx xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		data->buf = usbd_alloc_buffer(data->xfer, ZYX_MAX_RXBUFSZ);
		if (data->buf == NULL) {
			printf("%s: could not allocate rx buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
	}
	return 0;

fail:	zyd_free_rx_list(sc);
	return error;
}

void
zyd_free_rx_list(struct zyd_softc *sc)
{
	int i;

	for (i = 0; i < ZYD_RX_LIST_CNT; i++) {
		struct zyd_rx_data *data = &sc->rx_data[i];

		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}
	}
}

struct ieee80211_node *
zyd_node_alloc(struct ieee80211com *ic)
{
	return malloc(sizeof (struct zyd_node), M_DEVBUF, M_NOWAIT | M_ZERO);
}

int
zyd_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		zyd_init(ifp);

	return 0;
}

/*
 * This function is called periodically (every 200ms) during scanning to
 * switch from one channel to another.
 */
void
zyd_next_scan(void *arg)
{
	struct zyd_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);
}

void
zyd_task(void *arg)
{
	struct zyd_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	enum ieee80211_state ostate;

	ostate = ic->ic_state;

	switch (sc->sc_state) {
	case IEEE80211_S_INIT:
		if (ostate == IEEE80211_S_RUN) {
			/* turn link LED off */
			zyd_set_led(sc, ZYD_LED1, 0);

			/* stop data LED from blinking */
			zyd_write32(sc, sc->fwbase + ZYD_FW_LINK_STATUS, 0);
		}
		break;

	case IEEE80211_S_SCAN:
		zyd_set_chan(sc, ic->ic_bss->ni_chan);
		timeout_add_msec(&sc->scan_to, 200);
		break;

	case IEEE80211_S_AUTH:
	case IEEE80211_S_ASSOC:
		zyd_set_chan(sc, ic->ic_bss->ni_chan);
		break;

	case IEEE80211_S_RUN:
	{
		struct ieee80211_node *ni = ic->ic_bss;

		zyd_set_chan(sc, ni->ni_chan);

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			/* turn link LED on */
			zyd_set_led(sc, ZYD_LED1, 1);

			/* make data LED blink upon Tx */
			zyd_write32(sc, sc->fwbase + ZYD_FW_LINK_STATUS, 1);

			zyd_set_bssid(sc, ni->ni_bssid);
		}

		if (ic->ic_opmode == IEEE80211_M_STA) {
			/* fake a join to init the tx rate */
			zyd_newassoc(ic, ni, 1);
		}

		/* start automatic rate control timer */
		if (ic->ic_fixed_rate == -1)
			timeout_add_sec(&sc->amrr_to, 1);

		break;
	}
	}

	sc->sc_newstate(ic, sc->sc_state, sc->sc_arg);
}

int
zyd_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct zyd_softc *sc = ic->ic_softc;

	usb_rem_task(sc->sc_udev, &sc->sc_task);
	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);

	/* do it in a process context */
	sc->sc_state = nstate;
	sc->sc_arg = arg;
	usb_add_task(sc->sc_udev, &sc->sc_task);

	return 0;
}

/*
 * Issue a read command for the specificed register (of size regsize)
 * and await a reply of olen bytes in sc->odata.
 */
int
zyd_cmd_read(struct zyd_softc *sc, const void *reg, size_t regsize, int olen)
{
	struct usbd_xfer *xfer;
	struct zyd_cmd cmd;
	usbd_status error;
	int s;

	if ((xfer = usbd_alloc_xfer(sc->sc_udev)) == NULL)
		return ENOMEM;

	bzero(&cmd, sizeof(cmd));
	cmd.code = htole16(ZYD_CMD_IORD);
	bcopy(reg, cmd.data, regsize);

	bzero(sc->odata, sizeof(sc->odata));
	sc->olen = olen;

	usbd_setup_xfer(xfer, sc->zyd_ep[ZYD_ENDPT_IOUT], 0,
	    &cmd, sizeof(cmd.code) + regsize,
	    USBD_FORCE_SHORT_XFER | USBD_SYNCHRONOUS,
	    ZYD_INTR_TIMEOUT, NULL);
	s = splusb();
	sc->odone = 0;
	error = usbd_transfer(xfer);
	splx(s);
	if (error) {
		printf("%s: could not send command: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		usbd_free_xfer(xfer);
		return EIO;
	}

	if (!sc->odone) {
		/* wait for ZYD_NOTIF_IORD interrupt */
		if (tsleep(sc, PWAIT, "zydcmd", ZYD_INTR_TIMEOUT) != 0)
			printf("%s: read command failed\n",
			    sc->sc_dev.dv_xname);
	}
	usbd_free_xfer(xfer);

	return error;
}

int
zyd_read16(struct zyd_softc *sc, uint16_t reg, uint16_t *val)
{
	struct zyd_io *odata;
	int error;

	reg = htole16(reg);
	error = zyd_cmd_read(sc, &reg, sizeof(reg), sizeof(*odata));
	if (error == 0) {
		odata = (struct zyd_io *)sc->odata;
		*val = letoh16(odata[0].val);
	}
	return error;
}

int
zyd_read32(struct zyd_softc *sc, uint16_t reg, uint32_t *val)
{
	struct zyd_io *odata;
	uint16_t regs[2];
	int error;

	regs[0] = htole16(ZYD_REG32_HI(reg));
	regs[1] = htole16(ZYD_REG32_LO(reg));
	error = zyd_cmd_read(sc, regs, sizeof(regs), sizeof(*odata) * 2);
	if (error == 0) {
		odata = (struct zyd_io *)sc->odata;
		*val = letoh16(odata[0].val) << 16 | letoh16(odata[1].val);
	}
	return error;
}

int
zyd_cmd_write(struct zyd_softc *sc, u_int16_t code, const void *data, int len)
{
	struct usbd_xfer *xfer;
	struct zyd_cmd cmd;
	usbd_status error;

	if ((xfer = usbd_alloc_xfer(sc->sc_udev)) == NULL)
		return ENOMEM;

	bzero(&cmd, sizeof(cmd));
	cmd.code = htole16(code);
	bcopy(data, cmd.data, len);

	usbd_setup_xfer(xfer, sc->zyd_ep[ZYD_ENDPT_IOUT], 0,
	    &cmd, sizeof(cmd.code) + len,
	    USBD_FORCE_SHORT_XFER | USBD_SYNCHRONOUS,
	    ZYD_INTR_TIMEOUT, NULL);
	error = usbd_transfer(xfer);
	if (error)
		printf("%s: could not send command: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));

	usbd_free_xfer(xfer);
	return error;
}

int
zyd_write16(struct zyd_softc *sc, uint16_t reg, uint16_t val)
{ 
	struct zyd_io io;

	io.reg = htole16(reg);
	io.val = htole16(val);
	return zyd_cmd_write(sc, ZYD_CMD_IOWR, &io, sizeof(io));
}

int
zyd_write32(struct zyd_softc *sc, uint16_t reg, uint32_t val)
{
	struct zyd_io io[2];

	io[0].reg = htole16(ZYD_REG32_HI(reg));
	io[0].val = htole16(val >> 16);
	io[1].reg = htole16(ZYD_REG32_LO(reg));
	io[1].val = htole16(val & 0xffff);

	return zyd_cmd_write(sc, ZYD_CMD_IOWR, io, sizeof(io));
}

int
zyd_rfwrite(struct zyd_softc *sc, uint32_t val)
{
	struct zyd_rf *rf = &sc->sc_rf;
	struct zyd_rfwrite req;
	uint16_t cr203;
	int i;

	(void)zyd_read16(sc, ZYD_CR203, &cr203);
	cr203 &= ~(ZYD_RF_IF_LE | ZYD_RF_CLK | ZYD_RF_DATA);

	req.code  = htole16(2);
	req.width = htole16(rf->width);
	for (i = 0; i < rf->width; i++) {
		req.bit[i] = htole16(cr203);
		if (val & (1 << (rf->width - 1 - i)))
			req.bit[i] |= htole16(ZYD_RF_DATA);
	}
	return zyd_cmd_write(sc, ZYD_CMD_RFCFG, &req, 4 + 2 * rf->width);
}

void
zyd_lock_phy(struct zyd_softc *sc)
{
	uint32_t tmp;

	(void)zyd_read32(sc, ZYD_MAC_MISC, &tmp);
	tmp &= ~ZYD_UNLOCK_PHY_REGS;
	(void)zyd_write32(sc, ZYD_MAC_MISC, tmp);
}

void
zyd_unlock_phy(struct zyd_softc *sc)
{
	uint32_t tmp;

	(void)zyd_read32(sc, ZYD_MAC_MISC, &tmp);
	tmp |= ZYD_UNLOCK_PHY_REGS;
	(void)zyd_write32(sc, ZYD_MAC_MISC, tmp);
}

/*
 * RFMD RF methods.
 */
int
zyd_rfmd_init(struct zyd_rf *rf)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct zyd_phy_pair phyini[] = ZYD_RFMD_PHY;
	static const uint32_t rfini[] = ZYD_RFMD_RF;
	int i, error;

	/* init RF-dependent PHY registers */
	for (i = 0; i < nitems(phyini); i++) {
		error = zyd_write16(sc, phyini[i].reg, phyini[i].val);
		if (error != 0)
			return error;
	}

	/* init RFMD radio */
	for (i = 0; i < nitems(rfini); i++) {
		if ((error = zyd_rfwrite(sc, rfini[i])) != 0)
			return error;
	}
	return 0;
}

int
zyd_rfmd_switch_radio(struct zyd_rf *rf, int on)
{
	struct zyd_softc *sc = rf->rf_sc;

	(void)zyd_write16(sc, ZYD_CR10, on ? 0x89 : 0x15);
	(void)zyd_write16(sc, ZYD_CR11, on ? 0x00 : 0x81);

	return 0;
}

int
zyd_rfmd_set_channel(struct zyd_rf *rf, uint8_t chan)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct {
		uint32_t	r1, r2;
	} rfprog[] = ZYD_RFMD_CHANTABLE;

	(void)zyd_rfwrite(sc, rfprog[chan - 1].r1);
	(void)zyd_rfwrite(sc, rfprog[chan - 1].r2);

	return 0;
}

/*
 * AL2230 RF methods.
 */
int
zyd_al2230_init(struct zyd_rf *rf)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct zyd_phy_pair phyini[] = ZYD_AL2230_PHY;
	static const struct zyd_phy_pair phy2230s[] = ZYD_AL2230S_PHY_INIT;
	static const uint32_t rfini[] = ZYD_AL2230_RF;
	int i, error;

	/* init RF-dependent PHY registers */
	for (i = 0; i < nitems(phyini); i++) {
		error = zyd_write16(sc, phyini[i].reg, phyini[i].val);
		if (error != 0)
			return error;
	}
	if (sc->rf_rev == ZYD_RF_AL2230S) {
		for (i = 0; i < nitems(phy2230s); i++) {
			error = zyd_write16(sc, phy2230s[i].reg,
			    phy2230s[i].val);
			if (error != 0)
				return error;
		}
	}
	/* init AL2230 radio */
	for (i = 0; i < nitems(rfini); i++) {
		if ((error = zyd_rfwrite(sc, rfini[i])) != 0)
			return error;
	}
	return 0;
}

int
zyd_al2230_init_b(struct zyd_rf *rf)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct zyd_phy_pair phyini[] = ZYD_AL2230_PHY_B;
	static const uint32_t rfini[] = ZYD_AL2230_RF_B;
	int i, error;

	/* init RF-dependent PHY registers */
	for (i = 0; i < nitems(phyini); i++) {
		error = zyd_write16(sc, phyini[i].reg, phyini[i].val);
		if (error != 0)
			return error;
	}

	/* init AL2230 radio */
	for (i = 0; i < nitems(rfini); i++) {
		if ((error = zyd_rfwrite(sc, rfini[i])) != 0)
			return error;
	}
	return 0;
}

int
zyd_al2230_switch_radio(struct zyd_rf *rf, int on)
{
	struct zyd_softc *sc = rf->rf_sc;
	int on251 = (sc->mac_rev == ZYD_ZD1211) ? 0x3f : 0x7f;

	(void)zyd_write16(sc, ZYD_CR11,  on ? 0x00 : 0x04);
	(void)zyd_write16(sc, ZYD_CR251, on ? on251 : 0x2f);

	return 0;
}

int
zyd_al2230_set_channel(struct zyd_rf *rf, uint8_t chan)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct {
		uint32_t	r1, r2, r3;
	} rfprog[] = ZYD_AL2230_CHANTABLE;

	(void)zyd_rfwrite(sc, rfprog[chan - 1].r1);
	(void)zyd_rfwrite(sc, rfprog[chan - 1].r2);
	(void)zyd_rfwrite(sc, rfprog[chan - 1].r3);

	(void)zyd_write16(sc, ZYD_CR138, 0x28);
	(void)zyd_write16(sc, ZYD_CR203, 0x06);

	return 0;
}

/*
 * AL7230B RF methods.
 */
int
zyd_al7230B_init(struct zyd_rf *rf)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct zyd_phy_pair phyini_1[] = ZYD_AL7230B_PHY_1;
	static const struct zyd_phy_pair phyini_2[] = ZYD_AL7230B_PHY_2;
	static const struct zyd_phy_pair phyini_3[] = ZYD_AL7230B_PHY_3;
	static const uint32_t rfini_1[] = ZYD_AL7230B_RF_1;
	static const uint32_t rfini_2[] = ZYD_AL7230B_RF_2;
	int i, error;

	/* for AL7230B, PHY and RF need to be initialized in "phases" */

	/* init RF-dependent PHY registers, part one */
	for (i = 0; i < nitems(phyini_1); i++) {
		error = zyd_write16(sc, phyini_1[i].reg, phyini_1[i].val);
		if (error != 0)
			return error;
	}
	/* init AL7230B radio, part one */
	for (i = 0; i < nitems(rfini_1); i++) {
		if ((error = zyd_rfwrite(sc, rfini_1[i])) != 0)
			return error;
	}
	/* init RF-dependent PHY registers, part two */
	for (i = 0; i < nitems(phyini_2); i++) {
		error = zyd_write16(sc, phyini_2[i].reg, phyini_2[i].val);
		if (error != 0)
			return error;
	}
	/* init AL7230B radio, part two */
	for (i = 0; i < nitems(rfini_2); i++) {
		if ((error = zyd_rfwrite(sc, rfini_2[i])) != 0)
			return error;
	}
	/* init RF-dependent PHY registers, part three */
	for (i = 0; i < nitems(phyini_3); i++) {
		error = zyd_write16(sc, phyini_3[i].reg, phyini_3[i].val);
		if (error != 0)
			return error;
	}

	return 0;
}

int
zyd_al7230B_switch_radio(struct zyd_rf *rf, int on)
{
	struct zyd_softc *sc = rf->rf_sc;

	(void)zyd_write16(sc, ZYD_CR11,  on ? 0x00 : 0x04);
	(void)zyd_write16(sc, ZYD_CR251, on ? 0x3f : 0x2f);

	return 0;
}

int
zyd_al7230B_set_channel(struct zyd_rf *rf, uint8_t chan)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct {
		uint32_t	r1, r2;
	} rfprog[] = ZYD_AL7230B_CHANTABLE;
	static const uint32_t rfsc[] = ZYD_AL7230B_RF_SETCHANNEL;
	int i, error;

	(void)zyd_write16(sc, ZYD_CR240, 0x57);
	(void)zyd_write16(sc, ZYD_CR251, 0x2f);

	for (i = 0; i < nitems(rfsc); i++) {
		if ((error = zyd_rfwrite(sc, rfsc[i])) != 0)
			return error;
	}

	(void)zyd_write16(sc, ZYD_CR128, 0x14);
	(void)zyd_write16(sc, ZYD_CR129, 0x12);
	(void)zyd_write16(sc, ZYD_CR130, 0x10);
	(void)zyd_write16(sc, ZYD_CR38,  0x38);
	(void)zyd_write16(sc, ZYD_CR136, 0xdf);

	(void)zyd_rfwrite(sc, rfprog[chan - 1].r1);
	(void)zyd_rfwrite(sc, rfprog[chan - 1].r2);
	(void)zyd_rfwrite(sc, 0x3c9000);

	(void)zyd_write16(sc, ZYD_CR251, 0x3f);
	(void)zyd_write16(sc, ZYD_CR203, 0x06);
	(void)zyd_write16(sc, ZYD_CR240, 0x08);

	return 0;
}

/*
 * AL2210 RF methods.
 */
int
zyd_al2210_init(struct zyd_rf *rf)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct zyd_phy_pair phyini[] = ZYD_AL2210_PHY;
	static const uint32_t rfini[] = ZYD_AL2210_RF;
	uint32_t tmp;
	int i, error;

	(void)zyd_write32(sc, ZYD_CR18, 2);

	/* init RF-dependent PHY registers */
	for (i = 0; i < nitems(phyini); i++) {
		error = zyd_write16(sc, phyini[i].reg, phyini[i].val);
		if (error != 0)
			return error;
	}
	/* init AL2210 radio */
	for (i = 0; i < nitems(rfini); i++) {
		if ((error = zyd_rfwrite(sc, rfini[i])) != 0)
			return error;
	}
	(void)zyd_write16(sc, ZYD_CR47, 0x1e);
	(void)zyd_read32(sc, ZYD_CR_RADIO_PD, &tmp);
	(void)zyd_write32(sc, ZYD_CR_RADIO_PD, tmp & ~1);
	(void)zyd_write32(sc, ZYD_CR_RADIO_PD, tmp | 1);
	(void)zyd_write32(sc, ZYD_CR_RFCFG, 0x05);
	(void)zyd_write32(sc, ZYD_CR_RFCFG, 0x00);
	(void)zyd_write16(sc, ZYD_CR47, 0x1e);
	(void)zyd_write32(sc, ZYD_CR18, 3);

	return 0;
}

int
zyd_al2210_switch_radio(struct zyd_rf *rf, int on)
{
	/* vendor driver does nothing for this RF chip */

	return 0;
}

int
zyd_al2210_set_channel(struct zyd_rf *rf, uint8_t chan)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const uint32_t rfprog[] = ZYD_AL2210_CHANTABLE;
	uint32_t tmp;

	(void)zyd_write32(sc, ZYD_CR18, 2);
	(void)zyd_write16(sc, ZYD_CR47, 0x1e);
	(void)zyd_read32(sc, ZYD_CR_RADIO_PD, &tmp);
	(void)zyd_write32(sc, ZYD_CR_RADIO_PD, tmp & ~1);
	(void)zyd_write32(sc, ZYD_CR_RADIO_PD, tmp | 1);
	(void)zyd_write32(sc, ZYD_CR_RFCFG, 0x05);

	(void)zyd_write32(sc, ZYD_CR_RFCFG, 0x00);
	(void)zyd_write16(sc, ZYD_CR47, 0x1e);

	/* actually set the channel */
	(void)zyd_rfwrite(sc, rfprog[chan - 1]);

	(void)zyd_write32(sc, ZYD_CR18, 3);

	return 0;
}

/*
 * GCT RF methods.
 */
int
zyd_gct_init(struct zyd_rf *rf)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct zyd_phy_pair phyini[] = ZYD_GCT_PHY;
	static const uint32_t rfini[] = ZYD_GCT_RF;
	int i, error;

	/* init RF-dependent PHY registers */
	for (i = 0; i < nitems(phyini); i++) {
		error = zyd_write16(sc, phyini[i].reg, phyini[i].val);
		if (error != 0)
			return error;
	}
	/* init cgt radio */
	for (i = 0; i < nitems(rfini); i++) {
		if ((error = zyd_rfwrite(sc, rfini[i])) != 0)
			return error;
	}
	return 0;
}

int
zyd_gct_switch_radio(struct zyd_rf *rf, int on)
{
	/* vendor driver does nothing for this RF chip */

	return 0;
}

int
zyd_gct_set_channel(struct zyd_rf *rf, uint8_t chan)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const uint32_t rfprog[] = ZYD_GCT_CHANTABLE;

	(void)zyd_rfwrite(sc, 0x1c0000);
	(void)zyd_rfwrite(sc, rfprog[chan - 1]);
	(void)zyd_rfwrite(sc, 0x1c0008);

	return 0;
}

/*
 * Maxim RF methods.
 */
int
zyd_maxim_init(struct zyd_rf *rf)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct zyd_phy_pair phyini[] = ZYD_MAXIM_PHY;
	static const uint32_t rfini[] = ZYD_MAXIM_RF;
	uint16_t tmp;
	int i, error;

	/* init RF-dependent PHY registers */
	for (i = 0; i < nitems(phyini); i++) {
		error = zyd_write16(sc, phyini[i].reg, phyini[i].val);
		if (error != 0)
			return error;
	}
	(void)zyd_read16(sc, ZYD_CR203, &tmp);
	(void)zyd_write16(sc, ZYD_CR203, tmp & ~(1 << 4));

	/* init maxim radio */
	for (i = 0; i < nitems(rfini); i++) {
		if ((error = zyd_rfwrite(sc, rfini[i])) != 0)
			return error;
	}
	(void)zyd_read16(sc, ZYD_CR203, &tmp);
	(void)zyd_write16(sc, ZYD_CR203, tmp | (1 << 4));

	return 0;
}

int
zyd_maxim_switch_radio(struct zyd_rf *rf, int on)
{
	/* vendor driver does nothing for this RF chip */

	return 0;
}

int
zyd_maxim_set_channel(struct zyd_rf *rf, uint8_t chan)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct zyd_phy_pair phyini[] = ZYD_MAXIM_PHY;
	static const uint32_t rfini[] = ZYD_MAXIM_RF;
	static const struct {
		uint32_t	r1, r2;
	} rfprog[] = ZYD_MAXIM_CHANTABLE;
	uint16_t tmp;
	int i, error;

	/*
	 * Do the same as we do when initializing it, except for the channel
	 * values coming from the two channel tables.
	 */

	/* init RF-dependent PHY registers */
	for (i = 0; i < nitems(phyini); i++) {
		error = zyd_write16(sc, phyini[i].reg, phyini[i].val);
		if (error != 0)
			return error;
	}
	(void)zyd_read16(sc, ZYD_CR203, &tmp);
	(void)zyd_write16(sc, ZYD_CR203, tmp & ~(1 << 4));

	/* first two values taken from the chantables */
	(void)zyd_rfwrite(sc, rfprog[chan - 1].r1);
	(void)zyd_rfwrite(sc, rfprog[chan - 1].r2);

	/* init maxim radio - skipping the two first values */
	for (i = 2; i < nitems(rfini); i++) {
		if ((error = zyd_rfwrite(sc, rfini[i])) != 0)
			return error;
	}
	(void)zyd_read16(sc, ZYD_CR203, &tmp);
	(void)zyd_write16(sc, ZYD_CR203, tmp | (1 << 4));

	return 0;
}

/*
 * Maxim2 RF methods.
 */
int
zyd_maxim2_init(struct zyd_rf *rf)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct zyd_phy_pair phyini[] = ZYD_MAXIM2_PHY;
	static const uint32_t rfini[] = ZYD_MAXIM2_RF;
	uint16_t tmp;
	int i, error;

	/* init RF-dependent PHY registers */
	for (i = 0; i < nitems(phyini); i++) {
		error = zyd_write16(sc, phyini[i].reg, phyini[i].val);
		if (error != 0)
			return error;
	}
	(void)zyd_read16(sc, ZYD_CR203, &tmp);
	(void)zyd_write16(sc, ZYD_CR203, tmp & ~(1 << 4));

	/* init maxim2 radio */
	for (i = 0; i < nitems(rfini); i++) {
		if ((error = zyd_rfwrite(sc, rfini[i])) != 0)
			return error;
	}
	(void)zyd_read16(sc, ZYD_CR203, &tmp);
	(void)zyd_write16(sc, ZYD_CR203, tmp | (1 << 4));

	return 0;
}

int
zyd_maxim2_switch_radio(struct zyd_rf *rf, int on)
{
	/* vendor driver does nothing for this RF chip */

	return 0;
}

int
zyd_maxim2_set_channel(struct zyd_rf *rf, uint8_t chan)
{
	struct zyd_softc *sc = rf->rf_sc;
	static const struct zyd_phy_pair phyini[] = ZYD_MAXIM2_PHY;
	static const uint32_t rfini[] = ZYD_MAXIM2_RF;
	static const struct {
		uint32_t	r1, r2;
	} rfprog[] = ZYD_MAXIM2_CHANTABLE;
	uint16_t tmp;
	int i, error;

	/*
	 * Do the same as we do when initializing it, except for the channel
	 * values coming from the two channel tables.
	 */

	/* init RF-dependent PHY registers */
	for (i = 0; i < nitems(phyini); i++) {
		error = zyd_write16(sc, phyini[i].reg, phyini[i].val);
		if (error != 0)
			return error;
	}
	(void)zyd_read16(sc, ZYD_CR203, &tmp);
	(void)zyd_write16(sc, ZYD_CR203, tmp & ~(1 << 4));

	/* first two values taken from the chantables */
	(void)zyd_rfwrite(sc, rfprog[chan - 1].r1);
	(void)zyd_rfwrite(sc, rfprog[chan - 1].r2);

	/* init maxim2 radio - skipping the two first values */
	for (i = 2; i < nitems(rfini); i++) {
		if ((error = zyd_rfwrite(sc, rfini[i])) != 0)
			return error;
	}
	(void)zyd_read16(sc, ZYD_CR203, &tmp);
	(void)zyd_write16(sc, ZYD_CR203, tmp | (1 << 4));

	return 0;
}

int
zyd_rf_attach(struct zyd_softc *sc, uint8_t type)
{
	struct zyd_rf *rf = &sc->sc_rf;

	rf->rf_sc = sc;

	switch (type) {
	case ZYD_RF_RFMD:
		rf->init         = zyd_rfmd_init;
		rf->switch_radio = zyd_rfmd_switch_radio;
		rf->set_channel  = zyd_rfmd_set_channel;
		rf->width        = 24;	/* 24-bit RF values */
		break;
	case ZYD_RF_AL2230:
	case ZYD_RF_AL2230S:
		if (sc->mac_rev == ZYD_ZD1211B)
			rf->init = zyd_al2230_init_b;
		else
			rf->init = zyd_al2230_init;
		rf->switch_radio = zyd_al2230_switch_radio;
		rf->set_channel  = zyd_al2230_set_channel;
		rf->width        = 24;	/* 24-bit RF values */
		break;
	case ZYD_RF_AL7230B:
		rf->init         = zyd_al7230B_init;
		rf->switch_radio = zyd_al7230B_switch_radio;
		rf->set_channel  = zyd_al7230B_set_channel;
		rf->width        = 24;	/* 24-bit RF values */
		break;
	case ZYD_RF_AL2210:
		rf->init         = zyd_al2210_init;
		rf->switch_radio = zyd_al2210_switch_radio;
		rf->set_channel  = zyd_al2210_set_channel;
		rf->width        = 24;	/* 24-bit RF values */
		break;
	case ZYD_RF_GCT:
		rf->init         = zyd_gct_init;
		rf->switch_radio = zyd_gct_switch_radio;
		rf->set_channel  = zyd_gct_set_channel;
		rf->width        = 21;	/* 21-bit RF values */
		break;
	case ZYD_RF_MAXIM_NEW:
		rf->init         = zyd_maxim_init;
		rf->switch_radio = zyd_maxim_switch_radio;
		rf->set_channel  = zyd_maxim_set_channel;
		rf->width        = 18;	/* 18-bit RF values */
		break;
	case ZYD_RF_MAXIM_NEW2:
		rf->init         = zyd_maxim2_init;
		rf->switch_radio = zyd_maxim2_switch_radio;
		rf->set_channel  = zyd_maxim2_set_channel;
		rf->width        = 18;	/* 18-bit RF values */
		break;
	default:
		printf("%s: sorry, radio \"%s\" is not supported yet\n",
		    sc->sc_dev.dv_xname, zyd_rf_name(type));
		return EINVAL;
	}
	return 0;
}

const char *
zyd_rf_name(uint8_t type)
{
	static const char * const zyd_rfs[] = {
		"unknown", "unknown", "UW2451",   "UCHIP",     "AL2230",
		"AL7230B", "THETA",   "AL2210",   "MAXIM_NEW", "GCT",
		"AL2230S", "RALINK",  "INTERSIL", "RFMD",      "MAXIM_NEW2",
		"PHILIPS"
	};
	return zyd_rfs[(type > 15) ? 0 : type];
}

int
zyd_hw_init(struct zyd_softc *sc)
{
	struct zyd_rf *rf = &sc->sc_rf;
	const struct zyd_phy_pair *phyp;
	uint32_t tmp;
	int error;

	/* specify that the plug and play is finished */
	(void)zyd_write32(sc, ZYD_MAC_AFTER_PNP, 1);

	(void)zyd_read16(sc, ZYD_FIRMWARE_BASE_ADDR, &sc->fwbase);
	DPRINTF(("firmware base address=0x%04x\n", sc->fwbase));

	/* retrieve firmware revision number */
	(void)zyd_read16(sc, sc->fwbase + ZYD_FW_FIRMWARE_REV, &sc->fw_rev);

	(void)zyd_write32(sc, ZYD_CR_GPI_EN, 0);
	(void)zyd_write32(sc, ZYD_MAC_CONT_WIN_LIMIT, 0x7f043f);

	/* disable interrupts */
	(void)zyd_write32(sc, ZYD_CR_INTERRUPT, 0);

	/* PHY init */
	zyd_lock_phy(sc);
	phyp = (sc->mac_rev == ZYD_ZD1211B) ? zyd_def_phyB : zyd_def_phy;
	for (; phyp->reg != 0; phyp++) {
		if ((error = zyd_write16(sc, phyp->reg, phyp->val)) != 0)
			goto fail;
	}
	if (sc->fix_cr157) {
		if (zyd_read32(sc, ZYD_EEPROM_PHY_REG, &tmp) == 0)
			(void)zyd_write32(sc, ZYD_CR157, tmp >> 8);
	}
	zyd_unlock_phy(sc);

	/* HMAC init */
	zyd_write32(sc, ZYD_MAC_ACK_EXT, 0x00000020);
	zyd_write32(sc, ZYD_CR_ADDA_MBIAS_WT, 0x30000808);

	if (sc->mac_rev == ZYD_ZD1211) {
		zyd_write32(sc, ZYD_MAC_RETRY, 0x00000002);
	} else {
		zyd_write32(sc, ZYD_MACB_MAX_RETRY, 0x02020202);
		zyd_write32(sc, ZYD_MACB_TXPWR_CTL4, 0x007f003f);
		zyd_write32(sc, ZYD_MACB_TXPWR_CTL3, 0x007f003f);
		zyd_write32(sc, ZYD_MACB_TXPWR_CTL2, 0x003f001f);
		zyd_write32(sc, ZYD_MACB_TXPWR_CTL1, 0x001f000f);
		zyd_write32(sc, ZYD_MACB_AIFS_CTL1, 0x00280028);
		zyd_write32(sc, ZYD_MACB_AIFS_CTL2, 0x008C003c);
		zyd_write32(sc, ZYD_MACB_TXOP, 0x01800824);
	}

	zyd_write32(sc, ZYD_MAC_SNIFFER, 0x00000000);
	zyd_write32(sc, ZYD_MAC_RXFILTER, 0x00000000);
	zyd_write32(sc, ZYD_MAC_GHTBL, 0x00000000);
	zyd_write32(sc, ZYD_MAC_GHTBH, 0x80000000);
	zyd_write32(sc, ZYD_MAC_MISC, 0x000000a4);
	zyd_write32(sc, ZYD_CR_ADDA_PWR_DWN, 0x0000007f);
	zyd_write32(sc, ZYD_MAC_BCNCFG, 0x00f00401);
	zyd_write32(sc, ZYD_MAC_PHY_DELAY2, 0x00000000);
	zyd_write32(sc, ZYD_MAC_ACK_EXT, 0x00000080);
	zyd_write32(sc, ZYD_CR_ADDA_PWR_DWN, 0x00000000);
	zyd_write32(sc, ZYD_MAC_SIFS_ACK_TIME, 0x00000100);
	zyd_write32(sc, ZYD_MAC_DIFS_EIFS_SIFS, 0x0547c032);
	zyd_write32(sc, ZYD_CR_RX_PE_DELAY, 0x00000070);
	zyd_write32(sc, ZYD_CR_PS_CTRL, 0x10000000);
	zyd_write32(sc, ZYD_MAC_RTSCTSRATE, 0x02030203);
	zyd_write32(sc, ZYD_MAC_RX_THRESHOLD, 0x000c0640);
	zyd_write32(sc, ZYD_MAC_BACKOFF_PROTECT, 0x00000114);

	/* RF chip init */
	zyd_lock_phy(sc);
	error = (*rf->init)(rf);
	zyd_unlock_phy(sc);
	if (error != 0) {
		printf("%s: radio initialization failed\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/* init beacon interval to 100ms */
	if ((error = zyd_set_beacon_interval(sc, 100)) != 0)
		goto fail;

fail:	return error;
}

int
zyd_read_eeprom(struct zyd_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;
	uint16_t val;
	int i;

	/* read MAC address */
	(void)zyd_read32(sc, ZYD_EEPROM_MAC_ADDR_P1, &tmp);
	ic->ic_myaddr[0] = tmp & 0xff;
	ic->ic_myaddr[1] = tmp >>  8;
	ic->ic_myaddr[2] = tmp >> 16;
	ic->ic_myaddr[3] = tmp >> 24;
	(void)zyd_read32(sc, ZYD_EEPROM_MAC_ADDR_P2, &tmp);
	ic->ic_myaddr[4] = tmp & 0xff;
	ic->ic_myaddr[5] = tmp >>  8;

	(void)zyd_read32(sc, ZYD_EEPROM_POD, &tmp);
	sc->rf_rev    = tmp & 0x0f;
	sc->fix_cr47  = (tmp >> 8 ) & 0x01;
	sc->fix_cr157 = (tmp >> 13) & 0x01;
	sc->pa_rev    = (tmp >> 16) & 0x0f;

	/* read regulatory domain (currently unused) */
	(void)zyd_read32(sc, ZYD_EEPROM_SUBID, &tmp);
	sc->regdomain = tmp >> 16;
	DPRINTF(("regulatory domain %x\n", sc->regdomain));

	/* read Tx power calibration tables */
	for (i = 0; i < 7; i++) {
		(void)zyd_read16(sc, ZYD_EEPROM_PWR_CAL + i, &val);
		sc->pwr_cal[i * 2] = val >> 8;
		sc->pwr_cal[i * 2 + 1] = val & 0xff;

		(void)zyd_read16(sc, ZYD_EEPROM_PWR_INT + i, &val);
		sc->pwr_int[i * 2] = val >> 8;
		sc->pwr_int[i * 2 + 1] = val & 0xff;

		(void)zyd_read16(sc, ZYD_EEPROM_36M_CAL + i, &val);
		sc->ofdm36_cal[i * 2] = val >> 8;
		sc->ofdm36_cal[i * 2 + 1] = val & 0xff;

		(void)zyd_read16(sc, ZYD_EEPROM_48M_CAL + i, &val);
		sc->ofdm48_cal[i * 2] = val >> 8;
		sc->ofdm48_cal[i * 2 + 1] = val & 0xff;

		(void)zyd_read16(sc, ZYD_EEPROM_54M_CAL + i, &val);
		sc->ofdm54_cal[i * 2] = val >> 8;
		sc->ofdm54_cal[i * 2 + 1] = val & 0xff;
	}
	return 0;
}

void
zyd_set_multi(struct zyd_softc *sc)
{
	struct arpcom *ac = &sc->sc_ic.ic_ac;
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	uint32_t lo, hi;
	uint8_t bit;

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if ((ifp->if_flags & (IFF_ALLMULTI | IFF_PROMISC)) != 0) {
		lo = hi = 0xffffffff;
		goto done;
	}
	lo = hi = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		bit = enm->enm_addrlo[5] >> 2;
		if (bit < 32)
			lo |= 1 << bit;
		else
			hi |= 1 << (bit - 32);
		ETHER_NEXT_MULTI(step, enm);
	}

done:
	hi |= 1U << 31;	/* make sure the broadcast bit is set */
	zyd_write32(sc, ZYD_MAC_GHTBL, lo);
	zyd_write32(sc, ZYD_MAC_GHTBH, hi);
}

void
zyd_set_macaddr(struct zyd_softc *sc, const uint8_t *addr)
{
	uint32_t tmp;

	tmp = addr[3] << 24 | addr[2] << 16 | addr[1] << 8 | addr[0];
	(void)zyd_write32(sc, ZYD_MAC_MACADRL, tmp);

	tmp = addr[5] << 8 | addr[4];
	(void)zyd_write32(sc, ZYD_MAC_MACADRH, tmp);
}

void
zyd_set_bssid(struct zyd_softc *sc, const uint8_t *addr)
{
	uint32_t tmp;

	tmp = addr[3] << 24 | addr[2] << 16 | addr[1] << 8 | addr[0];
	(void)zyd_write32(sc, ZYD_MAC_BSSADRL, tmp);

	tmp = addr[5] << 8 | addr[4];
	(void)zyd_write32(sc, ZYD_MAC_BSSADRH, tmp);
}

int
zyd_switch_radio(struct zyd_softc *sc, int on)
{
	struct zyd_rf *rf = &sc->sc_rf;
	int error;

	zyd_lock_phy(sc);
	error = (*rf->switch_radio)(rf, on);
	zyd_unlock_phy(sc);

	return error;
}

void
zyd_set_led(struct zyd_softc *sc, int which, int on)
{
	uint32_t tmp;

	(void)zyd_read32(sc, ZYD_MAC_TX_PE_CONTROL, &tmp);
	tmp &= ~which;
	if (on)
		tmp |= which;
	(void)zyd_write32(sc, ZYD_MAC_TX_PE_CONTROL, tmp);
}

int
zyd_set_rxfilter(struct zyd_softc *sc)
{
	uint32_t rxfilter;

	switch (sc->sc_ic.ic_opmode) {
	case IEEE80211_M_STA:
		rxfilter = ZYD_FILTER_BSS;
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
	case IEEE80211_M_HOSTAP:
		rxfilter = ZYD_FILTER_HOSTAP;
		break;
#endif
	case IEEE80211_M_MONITOR:
		rxfilter = ZYD_FILTER_MONITOR;
		break;
	default:
		/* should not get there */
		return EINVAL;
	}
	return zyd_write32(sc, ZYD_MAC_RXFILTER, rxfilter);
}

void
zyd_set_chan(struct zyd_softc *sc, struct ieee80211_channel *c)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct zyd_rf *rf = &sc->sc_rf;
	uint32_t tmp;
	u_int chan;

	chan = ieee80211_chan2ieee(ic, c);
	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
		return;

	zyd_lock_phy(sc);

	(*rf->set_channel)(rf, chan);

	/* update Tx power */
	(void)zyd_write16(sc, ZYD_CR31, sc->pwr_int[chan - 1]);

	if (sc->mac_rev == ZYD_ZD1211B) {
		(void)zyd_write16(sc, ZYD_CR67, sc->ofdm36_cal[chan - 1]);
		(void)zyd_write16(sc, ZYD_CR66, sc->ofdm48_cal[chan - 1]);
		(void)zyd_write16(sc, ZYD_CR65, sc->ofdm54_cal[chan - 1]);

		(void)zyd_write16(sc, ZYD_CR68, sc->pwr_cal[chan - 1]);

		(void)zyd_write16(sc, ZYD_CR69, 0x28);
		(void)zyd_write16(sc, ZYD_CR69, 0x2a);
	}

	if (sc->fix_cr47) {
		/* set CCK baseband gain from EEPROM */
		if (zyd_read32(sc, ZYD_EEPROM_PHY_REG, &tmp) == 0)
			(void)zyd_write16(sc, ZYD_CR47, tmp & 0xff);
	}

	(void)zyd_write32(sc, ZYD_CR_CONFIG_PHILIPS, 0);

	zyd_unlock_phy(sc);
}

int
zyd_set_beacon_interval(struct zyd_softc *sc, int bintval)
{
	/* XXX this is probably broken.. */
	(void)zyd_write32(sc, ZYD_CR_ATIM_WND_PERIOD, bintval - 2);
	(void)zyd_write32(sc, ZYD_CR_PRE_TBTT,        bintval - 1);
	(void)zyd_write32(sc, ZYD_CR_BCN_INTERVAL,    bintval);

	return 0;
}

uint8_t
zyd_plcp_signal(int rate)
{
	switch (rate) {
	/* CCK rates (returned values are device-dependent) */
	case 2:		return 0x0;
	case 4:		return 0x1;
	case 11:	return 0x2;
	case 22:	return 0x3;

	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
	case 12:	return 0xb;
	case 18:	return 0xf;
	case 24:	return 0xa;
	case 36:	return 0xe;
	case 48:	return 0x9;
	case 72:	return 0xd;
	case 96:	return 0x8;
	case 108:	return 0xc;

	/* unsupported rates (should not get there) */
	default:	return 0xff;
	}
}

void
zyd_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct zyd_softc *sc = (struct zyd_softc *)priv;
	const struct zyd_cmd *cmd;
	uint32_t len;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		if (status == USBD_STALLED) {
			usbd_clear_endpoint_stall_async(
			    sc->zyd_ep[ZYD_ENDPT_IIN]);
		}
		return;
	}

	cmd = (const struct zyd_cmd *)sc->ibuf;

	if (letoh16(cmd->code) == ZYD_NOTIF_RETRYSTATUS) {
		struct zyd_notif_retry *retry =
		    (struct zyd_notif_retry *)cmd->data;
		struct ieee80211com *ic = &sc->sc_ic;
		struct ifnet *ifp = &ic->ic_if;
		struct ieee80211_node *ni;

		DPRINTF(("retry intr: rate=0x%x addr=%s count=%d (0x%x)\n",
		    letoh16(retry->rate), ether_sprintf(retry->macaddr),
		    letoh16(retry->count) & 0xff, letoh16(retry->count)));

		/*
		 * Find the node to which the packet was sent and update its
		 * retry statistics.  In BSS mode, this node is the AP we're
		 * associated to so no lookup is actually needed.
		 */
		if (ic->ic_opmode != IEEE80211_M_STA) {
			ni = ieee80211_find_node(ic, retry->macaddr);
			if (ni == NULL)
				return;	/* just ignore */
		} else
			ni = ic->ic_bss;

		((struct zyd_node *)ni)->amn.amn_retrycnt++;

		if (letoh16(retry->count) & 0x100)
			ifp->if_oerrors++;	/* too many retries */

	} else if (letoh16(cmd->code) == ZYD_NOTIF_IORD) {
		if (letoh16(*(uint16_t *)cmd->data) == ZYD_CR_INTERRUPT)
			return;	/* HMAC interrupt */

		if (!sc->odone) {
			/* copy answer into sc->odata buffer */
			usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);
			bcopy(cmd->data, sc->odata, sc->olen);
			sc->odone = 1;
			wakeup(sc); /* wakeup zyd_cmd_read() */
		}

	} else {
		printf("%s: unknown notification %x\n", sc->sc_dev.dv_xname,
		    letoh16(cmd->code));
	}
}

void
zyd_rx_data(struct zyd_softc *sc, const uint8_t *buf, uint16_t len)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_node *ni;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	const struct zyd_plcphdr *plcp;
	const struct zyd_rx_stat *stat;
	struct mbuf *m;
	int s;

	if (len < ZYD_MIN_FRAGSZ) {
		DPRINTFN(2, ("frame too short (length=%d)\n", len));
		ifp->if_ierrors++;
		return;
	}

	plcp = (const struct zyd_plcphdr *)buf;
	stat = (const struct zyd_rx_stat *)(buf + len - sizeof (*stat));

	if (stat->flags & ZYD_RX_ERROR) {
		DPRINTF(("%s: RX status indicated error (%x)\n",
		    sc->sc_dev.dv_xname, stat->flags));
		ifp->if_ierrors++;
		return;
	}

	/* compute actual frame length */
	len -= (sizeof (*plcp) + sizeof (*stat) + IEEE80211_CRC_LEN);

	if (len > MCLBYTES) {
		DPRINTFN(2, ("frame too large (length=%d)\n", len));
		ifp->if_ierrors++;
		return;
	}

	/* allocate a mbuf to store the frame */
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}
	if (len > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			ifp->if_ierrors++;
			m_freem(m);
			return;
		}
	}
	bcopy(plcp + 1, mtod(m, caddr_t), len);
	m->m_pkthdr.len = m->m_len = len;

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct zyd_rx_radiotap_header *tap = &sc->sc_rxtap;
		static const uint8_t rates[] = {
			/* reverse function of zyd_plcp_signal() */
			2, 4, 11, 22, 0, 0, 0, 0,
			96, 48, 24, 12, 108, 72, 36, 18
		};

		tap->wr_flags = 0;
		tap->wr_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		tap->wr_rssi = stat->rssi;
		tap->wr_rate = rates[plcp->signal & 0xf];

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif

	s = splnet();
	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);
	rxi.rxi_flags = 0;
	rxi.rxi_rssi = stat->rssi;
	rxi.rxi_tstamp = 0;	/* unused */
	ieee80211_input(ifp, m, ni, &rxi);

	/* node is no longer needed */
	ieee80211_release_node(ic, ni);

	splx(s);
}

void
zyd_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct zyd_rx_data *data = priv;
	struct zyd_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	const struct zyd_rx_desc *desc;
	int len;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall(sc->zyd_ep[ZYD_ENDPT_BIN]);

		goto skip;
	}
	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	if (len < ZYD_MIN_RXBUFSZ) {
		DPRINTFN(2, ("xfer too short (length=%d)\n", len));
		ifp->if_ierrors++;
		goto skip;
	}

	desc = (const struct zyd_rx_desc *)
	    (data->buf + len - sizeof (struct zyd_rx_desc));

	if (UGETW(desc->tag) == ZYD_TAG_MULTIFRAME) {
		const uint8_t *p = data->buf, *end = p + len;
		int i;

		DPRINTFN(3, ("received multi-frame transfer\n"));

		for (i = 0; i < ZYD_MAX_RXFRAMECNT; i++) {
			const uint16_t len = UGETW(desc->len[i]);

			if (len == 0 || p + len >= end)
				break;

			zyd_rx_data(sc, p, len);
			/* next frame is aligned on a 32-bit boundary */
			p += (len + 3) & ~3;
		}
	} else {
		DPRINTFN(3, ("received single-frame transfer\n"));

		zyd_rx_data(sc, data->buf, len);
	}

skip:	/* setup a new transfer */
	usbd_setup_xfer(xfer, sc->zyd_ep[ZYD_ENDPT_BIN], data, NULL,
	    ZYX_MAX_RXBUFSZ, USBD_NO_COPY | USBD_SHORT_XFER_OK,
	    USBD_NO_TIMEOUT, zyd_rxeof);
	(void)usbd_transfer(xfer);
}

void
zyd_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct zyd_tx_data *data = priv;
	struct zyd_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		printf("%s: could not transmit buffer: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status));

		if (status == USBD_STALLED) {
			usbd_clear_endpoint_stall_async(
			    sc->zyd_ep[ZYD_ENDPT_BOUT]);
		}
		ifp->if_oerrors++;
		return;
	}

	s = splnet();

	/* update rate control statistics */
	((struct zyd_node *)data->ni)->amn.amn_txcnt++;

	ieee80211_release_node(ic, data->ni);
	data->ni = NULL;

	sc->tx_queued--;

	sc->tx_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);
	zyd_start(ifp);

	splx(s);
}

int
zyd_tx(struct zyd_softc *sc, struct mbuf *m, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct zyd_tx_desc *desc;
	struct zyd_tx_data *data;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	int xferlen, totlen, rate;
	uint16_t pktlen;
	usbd_status error;

	wh = mtod(m, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);
		if ((m = ieee80211_encrypt(ic, m, k)) == NULL)
			return ENOBUFS;
		wh = mtod(m, struct ieee80211_frame *);
	}

	/* pickup a rate */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	     IEEE80211_FC0_TYPE_MGT)) {
		/* mgmt/multicast frames are sent at the lowest avail. rate */
		rate = ni->ni_rates.rs_rates[0];
	} else if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
	} else
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	rate &= IEEE80211_RATE_VAL;
	if (rate == 0)	/* XXX should not happen */
		rate = 2;

	data = &sc->tx_data[0];
	desc = (struct zyd_tx_desc *)data->buf;

	data->ni = ni;

	xferlen = sizeof (struct zyd_tx_desc) + m->m_pkthdr.len;
	totlen = m->m_pkthdr.len + IEEE80211_CRC_LEN;

	/* fill Tx descriptor */
	desc->len = htole16(totlen);

	desc->flags = ZYD_TX_FLAG_BACKOFF;
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* multicast frames are not sent at OFDM rates in 802.11b/g */
		if (totlen > ic->ic_rtsthreshold) {
			desc->flags |= ZYD_TX_FLAG_RTS;
		} else if (ZYD_RATE_IS_OFDM(rate) &&
		    (ic->ic_flags & IEEE80211_F_USEPROT)) {
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
				desc->flags |= ZYD_TX_FLAG_CTS_TO_SELF;
			else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
				desc->flags |= ZYD_TX_FLAG_RTS;
		}
	} else
		desc->flags |= ZYD_TX_FLAG_MULTICAST;

	if ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
	    (IEEE80211_FC0_TYPE_CTL | IEEE80211_FC0_SUBTYPE_PS_POLL))
		desc->flags |= ZYD_TX_FLAG_TYPE(ZYD_TX_TYPE_PS_POLL);

	desc->phy = zyd_plcp_signal(rate);
	if (ZYD_RATE_IS_OFDM(rate)) {
		desc->phy |= ZYD_TX_PHY_OFDM;
		if (ic->ic_curmode == IEEE80211_MODE_11A)
			desc->phy |= ZYD_TX_PHY_5GHZ;
	} else if (rate != 2 && (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
		desc->phy |= ZYD_TX_PHY_SHPREAMBLE;

	/* actual transmit length (XXX why +10?) */
	pktlen = sizeof (struct zyd_tx_desc) + 10;
	if (sc->mac_rev == ZYD_ZD1211)
		pktlen += totlen;
	desc->pktlen = htole16(pktlen);

	desc->plcp_length = htole16((16 * totlen + rate - 1) / rate);
	desc->plcp_service = 0;
	if (rate == 22) {
		const int remainder = (16 * totlen) % 22;
		if (remainder != 0 && remainder < 7)
			desc->plcp_service |= ZYD_PLCP_LENGEXT;
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct zyd_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	m_copydata(m, 0, m->m_pkthdr.len,
	    data->buf + sizeof (struct zyd_tx_desc));

	DPRINTFN(10, ("%s: sending data frame len=%u rate=%u xferlen=%u\n",
	    sc->sc_dev.dv_xname, m->m_pkthdr.len, rate, xferlen));

	m_freem(m);	/* mbuf no longer needed */

	usbd_setup_xfer(data->xfer, sc->zyd_ep[ZYD_ENDPT_BOUT], data,
	    data->buf, xferlen, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    ZYD_TX_TIMEOUT, zyd_txeof);
	error = usbd_transfer(data->xfer);
	if (error != USBD_IN_PROGRESS && error != 0) {
		ifp->if_oerrors++;
		return EIO;
	}
	sc->tx_queued++;

	return 0;
}

void
zyd_start(struct ifnet *ifp)
{
	struct zyd_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (sc->tx_queued >= ZYD_TX_LIST_CNT) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
		/* send pending management frames first */
		m = mq_dequeue(&ic->ic_mgtq);
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;
			goto sendit;
		}
		if (ic->ic_state != IEEE80211_S_RUN)
			break;

		/* encapsulate and send data frames */
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;
#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		if ((m = ieee80211_encap(ifp, m, &ni)) == NULL)
			continue;
sendit:
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		if (zyd_tx(sc, m, ni) != 0) {
			ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			continue;
		}

		sc->tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
zyd_watchdog(struct ifnet *ifp)
{
	struct zyd_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->tx_timer > 0) {
		if (--sc->tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			/* zyd_init(ifp); XXX needs a process context ? */
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
zyd_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct zyd_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			/*
			 * If only the PROMISC or ALLMULTI flag changes, then
			 * don't do a full re-init of the chip, just update
			 * the Rx filter.
			 */
			if ((ifp->if_flags & IFF_RUNNING) &&
			    ((ifp->if_flags ^ sc->sc_if_flags) &
			     (IFF_ALLMULTI | IFF_PROMISC)) != 0) {
				zyd_set_multi(sc);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING))
					zyd_init(ifp);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				zyd_stop(ifp, 1);
		}
		sc->sc_if_flags = ifp->if_flags;
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);
		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				zyd_set_multi(sc);
			error = 0;
		}
		break;

	case SIOCS80211CHANNEL:
		/*
		 * This allows for fast channel switching in monitor mode
		 * (used by kismet). In IBSS mode, we must explicitly reset
		 * the interface to generate a new beacon frame.
		 */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			zyd_set_chan(sc, ic->ic_ibss_chan);
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_RUNNING | IFF_UP)) ==
		    (IFF_RUNNING | IFF_UP))
			zyd_init(ifp);
		error = 0;
	}

	splx(s);

	return error;
}

int
zyd_init(struct ifnet *ifp)
{
	struct zyd_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int i, error;

	zyd_stop(ifp, 0);

	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	DPRINTF(("setting MAC address to %s\n", ether_sprintf(ic->ic_myaddr)));
	zyd_set_macaddr(sc, ic->ic_myaddr);

	/* we'll do software WEP decryption for now */
	DPRINTF(("setting encryption type\n"));
	error = zyd_write32(sc, ZYD_MAC_ENCRYPTION_TYPE, ZYD_ENC_SNIFFER);
	if (error != 0)
		return error;

	/* promiscuous mode */
	(void)zyd_write32(sc, ZYD_MAC_SNIFFER,
	    (ic->ic_opmode == IEEE80211_M_MONITOR) ? 1 : 0);

	(void)zyd_set_rxfilter(sc);

	/* switch radio transmitter ON */
	(void)zyd_switch_radio(sc, 1);

	/* set basic rates */
	if (ic->ic_curmode == IEEE80211_MODE_11B)
		(void)zyd_write32(sc, ZYD_MAC_BAS_RATE, 0x0003);
	else if (ic->ic_curmode == IEEE80211_MODE_11A)
		(void)zyd_write32(sc, ZYD_MAC_BAS_RATE, 0x1500);
	else	/* assumes 802.11b/g */
		(void)zyd_write32(sc, ZYD_MAC_BAS_RATE, 0x000f);

	/* set mandatory rates */
	if (ic->ic_curmode == IEEE80211_MODE_11B)
		(void)zyd_write32(sc, ZYD_MAC_MAN_RATE, 0x000f);
	else if (ic->ic_curmode == IEEE80211_MODE_11A)
		(void)zyd_write32(sc, ZYD_MAC_MAN_RATE, 0x1500);
	else	/* assumes 802.11b/g */
		(void)zyd_write32(sc, ZYD_MAC_MAN_RATE, 0x150f);

	/* set default BSS channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	zyd_set_chan(sc, ic->ic_bss->ni_chan);

	/* enable interrupts */
	(void)zyd_write32(sc, ZYD_CR_INTERRUPT, ZYD_HWINT_MASK);

	/*
	 * Allocate Tx and Rx xfer queues.
	 */
	if ((error = zyd_alloc_tx_list(sc)) != 0) {
		printf("%s: could not allocate Tx list\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	if ((error = zyd_alloc_rx_list(sc)) != 0) {
		printf("%s: could not allocate Rx list\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Start up the receive pipe.
	 */
	for (i = 0; i < ZYD_RX_LIST_CNT; i++) {
		struct zyd_rx_data *data = &sc->rx_data[i];

		usbd_setup_xfer(data->xfer, sc->zyd_ep[ZYD_ENDPT_BIN], data,
		    NULL, ZYX_MAX_RXBUFSZ, USBD_NO_COPY | USBD_SHORT_XFER_OK,
		    USBD_NO_TIMEOUT, zyd_rxeof);
		error = usbd_transfer(data->xfer);
		if (error != USBD_IN_PROGRESS && error != 0) {
			printf("%s: could not queue Rx transfer\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_flags |= IFF_RUNNING;

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	return 0;

fail:	zyd_stop(ifp, 1);
	return error;
}

void
zyd_stop(struct ifnet *ifp, int disable)
{
	struct zyd_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	sc->tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);	/* free all nodes */

	/* switch radio transmitter OFF */
	(void)zyd_switch_radio(sc, 0);

	/* disable Rx */
	(void)zyd_write32(sc, ZYD_MAC_RXFILTER, 0);

	/* disable interrupts */
	(void)zyd_write32(sc, ZYD_CR_INTERRUPT, 0);

	usbd_abort_pipe(sc->zyd_ep[ZYD_ENDPT_BIN]);
	usbd_abort_pipe(sc->zyd_ep[ZYD_ENDPT_BOUT]);

	zyd_free_rx_list(sc);
	zyd_free_tx_list(sc);
}

int
zyd_loadfirmware(struct zyd_softc *sc, u_char *fw, size_t size)
{
	usb_device_request_t req;
	uint16_t addr;
	uint8_t stat;

	DPRINTF(("firmware size=%zd\n", size));

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = ZYD_DOWNLOADREQ;
	USETW(req.wIndex, 0);

	addr = ZYD_FIRMWARE_START_ADDR;
	while (size > 0) {
		const int mlen = min(size, 4096);

		DPRINTF(("loading firmware block: len=%d, addr=0x%x\n", mlen,
		    addr));

		USETW(req.wValue, addr);
		USETW(req.wLength, mlen);
		if (usbd_do_request(sc->sc_udev, &req, fw) != 0)
			return EIO;

		addr += mlen / 2;
		fw   += mlen;
		size -= mlen;
	}

	/* check whether the upload succeeded */
	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = ZYD_DOWNLOADSTS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, sizeof stat);
	if (usbd_do_request(sc->sc_udev, &req, &stat) != 0)
		return EIO;

	return (stat & 0x80) ? EIO : 0;
}

void
zyd_iter_func(void *arg, struct ieee80211_node *ni)
{
	struct zyd_softc *sc = arg;
	struct zyd_node *zn = (struct zyd_node *)ni;

	ieee80211_amrr_choose(&sc->amrr, ni, &zn->amn);
}

void
zyd_amrr_timeout(void *arg)
{
	struct zyd_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;

	s = splnet();
	if (ic->ic_opmode == IEEE80211_M_STA)
		zyd_iter_func(sc, ic->ic_bss);
	else
		ieee80211_iterate_nodes(ic, zyd_iter_func, sc);
	splx(s);

	timeout_add_sec(&sc->amrr_to, 1);
}

void
zyd_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct zyd_softc *sc = ic->ic_softc;
	int i;

	ieee80211_amrr_node_init(&sc->amrr, &((struct zyd_node *)ni)->amn);

	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;
}
@


1.117
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.116 2017/01/22 10:17:39 dlg Exp $	*/
d254 1
a254 1
	size_t size;
d258 1
a258 1
	if ((error = loadfirmware(fwname, &fw, &size)) != 0) {
d264 2
a265 2
	error = zyd_loadfirmware(sc, fw, size);
	free(fw, M_DEVBUF, size);
d469 1
a469 1

d525 1
a525 1
		free(sc->ibuf, M_USBDEV, 0);
@


1.116
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.115 2016/04/13 11:03:37 mpi Exp $	*/
d265 1
a265 1
	free(fw, M_DEVBUF, 0);
@


1.115
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.114 2015/12/11 16:07:02 mpi Exp $	*/
a2081 1
	ifp->if_opackets++;
@


1.114
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.113 2015/11/25 03:10:00 dlg Exp $	*/
a384 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.113
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.112 2015/11/24 13:45:07 mpi Exp $	*/
d162 1
a162 1
void		zyd_attachhook(void *);
d249 1
a249 1
zyd_attachhook(void *xsc)
d251 1
a251 1
	struct zyd_softc *sc = xsc;
d296 1
a296 4
	if (rootvp == NULL)
		mountroothook_establish(zyd_attachhook, sc);
	else
		zyd_attachhook(sc);
@


1.112
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.111 2015/11/24 13:33:18 mpi Exp $	*/
d2089 1
a2089 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2234 1
a2234 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d2239 1
a2239 1
			ifp->if_flags |= IFF_OACTIVE;
d2458 1
a2458 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2480 2
a2481 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.111
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.110 2015/11/04 12:12:00 dlg Exp $	*/
a41 1
#include <net/if_arp.h>
@


1.110
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.109 2015/10/25 12:11:56 mpi Exp $	*/
a44 1
#include <net/if_types.h>
@


1.109
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.108 2015/03/14 03:38:49 jsg Exp $	*/
d2245 1
a2245 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
@


1.108
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.107 2015/02/10 23:25:46 mpi Exp $	*/
a2303 1
	struct ifaddr *ifa;
a2310 1
		ifa = (struct ifaddr *)data;
a2311 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.107
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.106 2014/12/22 02:28:52 tedu Exp $	*/
a36 2

#include <machine/bus.h>
@


1.106
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.105 2014/12/19 22:44:59 guenther Exp $	*/
a1955 1
	m->m_pkthdr.rcvif = ifp;
@


1.105
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.104 2014/07/13 15:52:49 mpi Exp $	*/
a2316 1
#ifdef INET
a2318 1
#endif
@


1.104
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.103 2014/07/12 18:48:52 tedu Exp $	*/
d36 1
a38 1
#include <machine/endian.h>
@


1.103
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.102 2014/07/12 15:26:54 stsp Exp $	*/
a48 1
#ifdef INET
a49 1
#include <netinet/in_systm.h>
a50 2
#include <netinet/ip.h>
#endif
@


1.102
log
@Rework zyd(4)'s register read/write methods to eliminate race conditions.

Read commands were issued via asynchronous transfers and replies were
expected after a fixed tsleep() timeout. Upon timeout zyd simply freed
the xfer even if it was still in-flight within the USB stack. This could
cause havoc such as making all USB ports on the system unusable until reboot.
  ehci_freex: xfer=0xfffffe811e63e9d8 not busy, 0x4f4e5155
  ("busy" here would indicate the xfer is done and marked for being freed)

To fix this, issue read commands with synchronous transfers so the xfer
can always complete. Split read/write code paths into separate methods.
Add a flag that tells us if a reply was received in interrupt context
while the read path waited in tsleep().

With and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.101 2014/07/12 07:59:23 mpi Exp $	*/
d273 1
a273 1
	free(fw, M_DEVBUF);
d537 1
a537 1
		free(sc->ibuf, M_USBDEV);
@


1.101
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.100 2014/06/03 14:41:56 stsp Exp $	*/
d183 1
a183 2
int		zyd_cmd(struct zyd_softc *, uint16_t, const void *, int,
		    void *, int, u_int);
d186 1
d759 4
d764 1
a764 2
zyd_cmd(struct zyd_softc *sc, uint16_t code, const void *idata, int ilen,
    void *odata, int olen, u_int flags)
a767 1
	uint16_t xferflags;
d774 13
a786 14
	cmd.code = htole16(code);
	bcopy(idata, cmd.data, ilen);

	xferflags = USBD_FORCE_SHORT_XFER;
	if (!(flags & ZYD_CMD_FLAG_READ))
		xferflags |= USBD_SYNCHRONOUS;
	else
		s = splusb();

	sc->odata = odata;
	sc->olen  = olen;

	usbd_setup_xfer(xfer, sc->zyd_ep[ZYD_ENDPT_IOUT], 0, &cmd,
	    sizeof (uint16_t) + ilen, xferflags, ZYD_INTR_TIMEOUT, NULL);
d788 3
a790 4
	if (error != USBD_IN_PROGRESS && error != 0) {
		if (flags & ZYD_CMD_FLAG_READ)
			splx(s);
		printf("%s: could not send command (error=%s)\n",
d795 6
a800 3
	if (!(flags & ZYD_CMD_FLAG_READ)) {
		usbd_free_xfer(xfer);
		return 0;	/* write: don't wait for reply */
d802 1
a802 4
	/* wait at most one second for command reply */
	error = tsleep(sc, PCATCH, "zydcmd", hz);
	sc->odata = NULL;	/* in case answer is received too late */
	splx(s);
a803 1
	usbd_free_xfer(xfer);
d810 1
a810 1
	struct zyd_pair tmp;
d814 5
a818 4
	error = zyd_cmd(sc, ZYD_CMD_IORD, &reg, sizeof reg, &tmp, sizeof tmp,
	    ZYD_CMD_FLAG_READ);
	if (error == 0)
		*val = letoh16(tmp.val);
d825 1
a825 1
	struct zyd_pair tmp[2];
d831 5
a835 4
	error = zyd_cmd(sc, ZYD_CMD_IORD, regs, sizeof regs, tmp, sizeof tmp,
	    ZYD_CMD_FLAG_READ);
	if (error == 0)
		*val = letoh16(tmp[0].val) << 16 | letoh16(tmp[1].val);
d840 1
a840 1
zyd_write16(struct zyd_softc *sc, uint16_t reg, uint16_t val)
d842 6
a847 1
	struct zyd_pair pair;
d849 3
a851 2
	pair.reg = htole16(reg);
	pair.val = htole16(val);
d853 21
a873 1
	return zyd_cmd(sc, ZYD_CMD_IOWR, &pair, sizeof pair, NULL, 0, 0);
d879 1
a879 1
	struct zyd_pair pair[2];
d881 4
a884 4
	pair[0].reg = htole16(ZYD_REG32_HI(reg));
	pair[0].val = htole16(val >> 16);
	pair[1].reg = htole16(ZYD_REG32_LO(reg));
	pair[1].val = htole16(val & 0xffff);
d886 1
a886 1
	return zyd_cmd(sc, ZYD_CMD_IOWR, pair, sizeof pair, NULL, 0, 0);
d907 1
a907 1
	return zyd_cmd(sc, ZYD_CMD_RFCFG, &req, 4 + 2 * rf->width, NULL, 0, 0);
d1893 7
a1899 8
		if (sc->odata == NULL)
			return;	/* unexpected IORD notification */

		/* copy answer into caller-supplied buffer */
		usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);
		bcopy(cmd->data, sc->odata, sc->olen);

		wakeup(sc);	/* wakeup caller */
@


1.100
log
@Make zyd(4) compile with ZYD_DEBUG.
ok krw@@ kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.99 2014/06/03 14:41:26 stsp Exp $	*/
d158 10
a167 15
int zyd_match(struct device *, void *, void *); 
void zyd_attach(struct device *, struct device *, void *); 
int zyd_detach(struct device *, int); 
int zyd_activate(struct device *, int); 

struct cfdriver zyd_cd = { 
	NULL, "zyd", DV_IFNET 
}; 

const struct cfattach zyd_ca = { 
	sizeof(struct zyd_softc), 
	zyd_match, 
	zyd_attach, 
	zyd_detach, 
	zyd_activate, 
a2569 13
}

int
zyd_activate(struct device *self, int act)
{
	struct zyd_softc *sc = (struct zyd_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return 0;
@


1.99
log
@Fix an off-by-one in zyd_rxeof().
ok krw@@ kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.98 2014/06/03 14:41:04 stsp Exp $	*/
d2501 1
a2501 1
	DPRINTF(("firmware size=%d\n", size));
@


1.98
log
@Fix zyd(4)'s frame length adjustment in RX path. Instead of snipping off
HW-specific data and CRC trailer as intended, the driver was telling the
net80211 layer frames were longer than they actually are. Math is hard.
ok krw@@ kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.97 2014/03/19 10:09:19 mpi Exp $	*/
d2021 1
a2021 1
			if (len == 0 || p + len > end)
@


1.97
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.96 2014/03/07 18:39:02 mpi Exp $	*/
d1916 1
a1916 1
	len -= sizeof (*plcp) - sizeof (*stat) - IEEE80211_CRC_LEN;
@


1.96
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.95 2014/02/15 02:20:29 jsg Exp $	*/
d2233 1
a2233 1
			ni = (void *)m->m_pkthdr.rcvif;
@


1.95
log
@Correct the name of a Planex device and add some additional
ZyXEL zyd(4) devices.

From Ben Taylor
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.94 2013/11/26 20:33:19 deraadt Exp $	*/
a65 4

#ifdef USB_DEBUG
#define ZYD_DEBUG
#endif
@


1.94
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.93 2013/11/06 15:55:15 jeremy Exp $	*/
a119 1
	ZYD_ZD1211_DEV(ZYXEL,		ZYAIRG220),
d122 2
d140 2
a145 2
	ZYD_ZD1211B_DEV(UNKNOWN1,	ZD1211B_1),
	ZYD_ZD1211B_DEV(UNKNOWN1,	ZD1211B_2),
d154 2
a155 1
	ZYD_ZD1211B_DEV(ZYXEL,		M202),
d157 1
@


1.93
log
@Make usbd_free_xfer return void, since no callers use the return value.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.92 2013/11/05 10:20:05 mpi Exp $	*/
d1664 1
a1664 1
	hi |= 1 << 31;	/* make sure the broadcast bit is set */
@


1.92
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not introduce any behavior change but will help changing our
representation of multicast entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.91 2013/08/07 01:06:43 bluhm Exp $	*/
d798 1
a798 1
		(void)usbd_free_xfer(xfer);
d802 1
a802 1
		(void)usbd_free_xfer(xfer);
d810 1
a810 1
	(void)usbd_free_xfer(xfer);
@


1.91
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.90 2013/04/15 09:23:01 mglocker Exp $	*/
d1645 3
a1654 5
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			lo = hi = 0xffffffff;
			goto done;
		}
@


1.90
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.89 2013/03/28 03:58:03 tedu Exp $	*/
a51 1
#include <netinet/in_var.h>
@


1.89
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.88 2011/07/03 15:47:17 matthew Exp $	*/
d234 1
a234 1
void		zyd_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d236 2
a237 2
void		zyd_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void		zyd_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d770 1
a770 1
	usbd_xfer_handle xfer;
d1824 1
a1824 1
zyd_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1987 1
a1987 1
zyd_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d2046 1
a2046 1
zyd_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.88
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.87 2011/01/25 20:03:36 jakemsr Exp $	*/
a27 1
#include <sys/proc.h>
@


1.87
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.86 2010/12/06 04:41:39 jakemsr Exp $	*/
a2587 3
	case DVACT_ACTIVATE:
		break;

@


1.86
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.85 2010/10/27 17:51:11 jakemsr Exp $	*/
a429 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);

a465 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.85
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.84 2010/10/23 16:14:07 jakemsr Exp $	*/
d2591 2
d2598 1
@


1.84
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.83 2010/10/23 15:42:09 jakemsr Exp $	*/
d458 4
a461 2
	ieee80211_ifdetach(ifp);
	if_detach(ifp);
@


1.83
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.82 2010/08/27 17:08:01 jsg Exp $	*/
d446 4
a449 2
	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);
@


1.82
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.81 2009/11/22 22:13:51 jsg Exp $	*/
d326 1
a326 1
	usb_init_task(&sc->sc_task, zyd_task, sc);
@


1.81
log
@add a bunch of devices found in linux drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.80 2009/10/13 19:33:17 pirofti Exp $	*/
a400 1
	ifp->if_init = zyd_init;
@


1.80
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.79 2009/06/01 08:53:44 damien Exp $	*/
d116 1
d119 1
d127 2
d133 1
d139 1
d149 1
d154 1
@


1.79
log
@oops, bad merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.78 2009/06/01 08:51:22 damien Exp $	*/
d156 1
a156 1
int zyd_activate(struct device *, enum devact); 
d2578 1
a2578 1
zyd_activate(struct device *self, enum devact act)
@


1.78
log
@- cleanup tx path
- nitemize
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.77 2009/06/01 08:43:20 damien Exp $	*/
d1431 1
@


1.77
log
@fix endianness issue.

tested by jsg@@ on tadpole sparc64 laptop.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.76 2009/05/31 13:03:21 jsg Exp $	*/
d231 1
a231 1
int		zyd_tx_data(struct zyd_softc *, struct mbuf *,
d705 1
a705 1
		timeout_add(&sc->scan_to, hz / 5);
a911 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d918 1
a918 1
	for (i = 0; i < N(phyini); i++) {
d925 1
a925 1
	for (i = 0; i < N(rfini); i++) {
a929 1
#undef N
a962 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d970 1
a970 1
	for (i = 0; i < N(phyini); i++) {
a974 1

d976 1
a976 1
		for (i = 0; i < N(phy2230s); i++) {
a982 1

d984 1
a984 1
	for (i = 0; i < N(rfini); i++) {
a988 1
#undef N
a993 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1000 1
a1000 1
	for (i = 0; i < N(phyini); i++) {
d1007 1
a1007 1
	for (i = 0; i < N(rfini); i++) {
a1011 1
#undef N
a1049 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1061 1
a1061 1
	for (i = 0; i < N(phyini_1); i++) {
d1067 1
a1067 1
	for (i = 0; i < N(rfini_1); i++) {
d1072 1
a1072 1
	for (i = 0; i < N(phyini_2); i++) {
d1078 1
a1078 1
	for (i = 0; i < N(rfini_2); i++) {
d1083 1
a1083 1
	for (i = 0; i < N(phyini_3); i++) {
a1089 1
#undef N
a1105 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1116 1
a1116 1
	for (i = 0; i < N(rfsc); i++) {
a1135 1
#undef N
a1143 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1153 1
a1153 1
	for (i = 0; i < N(phyini); i++) {
d1159 1
a1159 1
	for (i = 0; i < N(rfini); i++) {
a1172 1
#undef N
a1213 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1220 1
a1220 1
	for (i = 0; i < N(phyini); i++) {
d1226 1
a1226 1
	for (i = 0; i < N(rfini); i++) {
a1230 1
#undef N
a1259 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1267 1
a1267 1
	for (i = 0; i < N(phyini); i++) {
d1276 1
a1276 1
	for (i = 0; i < N(rfini); i++) {
a1283 1
#undef N
a1296 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1312 1
a1312 1
	for (i = 0; i < N(phyini); i++) {
d1325 1
a1325 1
	for (i = 2; i < N(rfini); i++) {
a1332 1
#undef N
a1340 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1348 1
a1348 1
	for (i = 0; i < N(phyini); i++) {
d1357 1
a1357 1
	for (i = 0; i < N(rfini); i++) {
a1364 1
#undef N
a1377 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1393 1
a1393 1
	for (i = 0; i < N(phyini); i++) {
d1406 1
a1406 1
	for (i = 2; i < N(rfini); i++) {
a1413 1
#undef N
a1430 1
	case ZYD_RF_AL2230S:
d1483 1
a1483 1
		"AL2230S",  "RALINK",  "INTERSIL", "RFMD",      "MAXIM_NEW2",
d2083 1
a2083 1
zyd_tx_data(struct zyd_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
d2095 1
a2095 1
	wh = mtod(m0, struct ieee80211_frame *);
d2099 1
a2099 2

		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
d2101 1
a2101 3

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
d2124 2
a2125 2
	xferlen = sizeof (struct zyd_tx_desc) + m0->m_pkthdr.len;
	totlen = m0->m_pkthdr.len + IEEE80211_CRC_LEN;
d2184 1
a2184 1
		mb.m_next = m0;
d2192 1
a2192 1
	m_copydata(m0, 0, m0->m_pkthdr.len,
d2196 1
a2196 1
	    sc->sc_dev.dv_xname, m0->m_pkthdr.len, rate, xferlen));
d2198 1
a2198 1
	m_freem(m0);	/* mbuf no longer needed */
d2219 1
a2219 1
	struct mbuf *m0;
a2220 4
	/*
	 * net80211 may still try to send management frames even if the
	 * IFF_RUNNING flag is not set...
	 */
d2225 12
a2236 7
		IF_POLL(&ic->ic_mgtq, m0);
		if (m0 != NULL) {
			if (sc->tx_queued >= ZYD_TX_LIST_CNT) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IF_DEQUEUE(&ic->ic_mgtq, m0);
d2238 4
a2241 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
d2243 2
a2244 2
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
d2246 3
a2248 21
			if (zyd_tx_data(sc, m0, ni) != 0)
				break;
		} else {
			if (ic->ic_state != IEEE80211_S_RUN)
				break;
			IFQ_POLL(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
			if (sc->tx_queued >= ZYD_TX_LIST_CNT) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IFQ_DEQUEUE(&ifp->if_snd, m0);
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
			if ((m0 = ieee80211_encap(ifp, m0, &ni)) == NULL) {
				ifp->if_oerrors++;
				continue;
			}
d2250 2
a2251 2
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
d2253 4
a2256 6
			if (zyd_tx_data(sc, m0, ni) != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
@


1.76
log
@Add AL2230S support, extracted from part of a massive
'sync to p4' style commit in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.75 2009/05/31 12:33:29 jsg Exp $	*/
d2192 1
a2192 1
	desc->plcp_length = (16 * totlen + rate - 1) / rate;
@


1.75
log
@PV2000 -> AL2230S
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.74 2009/05/31 12:29:21 jsg Exp $	*/
d968 1
d979 9
d1455 1
@


1.74
log
@Match on siemens zd1211b, support for the al2230s radio
is not yet in, but this makes things easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.73 2009/03/27 11:40:56 jsg Exp $	*/
d1497 1
a1497 1
		"PV2000",  "RALINK",  "INTERSIL", "RFMD",      "MAXIM_NEW2",
@


1.73
log
@Sitecom WL-603 should work according to linux driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.72 2008/10/15 19:12:18 blambert Exp $	*/
d130 1
@


1.72
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.71 2008/08/27 09:49:32 damien Exp $	*/
d135 1
@


1.71
log
@hardware may pass us ACK or CTS frames in some cases, so use
IEEE80211_ACK_LEN instead of IEEE80211_MIN_LEN for ZYD_MIN_RXBUFSZ
and ZYD_MIN_FRAGSZ.
silence some warnings while i'm there.
change ZYD_FILTER_BSS to use the same value as the vendor's driver
that contains some magic (undocumented) bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.70 2008/08/27 09:05:03 damien Exp $	*/
d734 1
a734 1
			timeout_add(&sc->amrr_to, hz);
d2590 1
a2590 1
	timeout_add(&sc->amrr_to, hz);
@


1.70
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.69 2008/07/21 18:43:19 damien Exp $	*/
d1908 1
a1908 1
	int rlen, s;
d1911 1
a1911 2
		printf("%s: frame too short (length=%d)\n",
		    sc->sc_dev.dv_xname, len);
d1917 1
a1917 2
	stat = (const struct zyd_rx_stat *)
	    (buf + len - sizeof (struct zyd_rx_stat));
d1927 7
a1933 2
	rlen = len - sizeof (struct zyd_plcphdr) -
	    sizeof (struct zyd_rx_stat) - IEEE80211_CRC_LEN;
a1937 2
		printf("%s: could not allocate rx mbuf\n",
		    sc->sc_dev.dv_xname);
d1941 1
a1941 1
	if (rlen > MHLEN) {
d1944 1
a1944 2
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
a1945 1
			ifp->if_ierrors++;
d1949 1
d1951 1
a1951 2
	m->m_pkthdr.len = m->m_len = rlen;
	bcopy((const uint8_t *)(plcp + 1), mtod(m, uint8_t *), rlen);
d2015 1
a2015 2
		printf("%s: xfer too short (length=%d)\n",
		    sc->sc_dev.dv_xname, len);
@


1.69
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.68 2008/05/27 00:11:11 jsg Exp $	*/
d1737 1
d1742 1
@


1.68
log
@Add ZyXEL G-202, which was already in usbdevs.
From/tested by pedro@@am-gen.org
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.67 2008/04/16 18:32:15 damien Exp $	*/
d1902 1
d1981 4
a1984 1
	ieee80211_input(ifp, m, ni, stat->rssi, 0);
@


1.67
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.66 2007/12/07 05:05:02 deraadt Exp $	*/
d122 1
@


1.66
log
@more zydas versions, collected from various places
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.65 2007/11/27 20:30:14 damien Exp $	*/
d372 2
a373 1
	    IEEE80211_C_WEP;		/* s/w WEP */
d2097 1
d2104 4
a2107 3
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
@


1.65
log
@properly update hardware multicast filter.
hints from zd1211rw.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.64 2007/11/18 00:43:13 brad Exp $	*/
d103 1
d121 1
@


1.64
log
@add the Planex GW-US54GXS adapter.

From the Linux ZyDAS driver.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.63 2007/11/03 14:10:37 damien Exp $	*/
d213 3
a215 2
int		zyd_set_macaddr(struct zyd_softc *, const uint8_t *);
int		zyd_set_bssid(struct zyd_softc *, const uint8_t *);
d1639 37
a1675 1
int
a1684 2

	return 0;
d1687 1
a1687 1
int
a1696 2

	return 0;
d2328 13
a2340 2
			if (!(ifp->if_flags & IFF_RUNNING))
				zyd_init(ifp);
d2345 1
d2354 3
a2356 1
		if (error == ENETRESET)
d2358 1
d2402 1
a2402 3
	error = zyd_set_macaddr(sc, ic->ic_myaddr);
	if (error != 0)
		return error;
@


1.63
log
@two fixes from FreeBSD:
- fix an incorrect setting of `retry times' in case of zd1211b
- increase max rx size so there's room for multi-frame transactions
  (slightly modified version)

from the Linux zd1211rw driver:
- patch registers CR47 and CR157 on devices that require it
- fix power calibration setting on ZD1211B
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.62 2007/10/14 08:31:55 fkr Exp $	*/
d130 1
@


1.62
log
@attach Planex GWUS54GD, from freebsd
ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.61 2007/10/11 18:33:14 deraadt Exp $	*/
d1500 1
d1525 4
d1538 1
a1538 1
		zyd_write32(sc, ZYD_MAC_RETRY, 0x02020202);
d1544 1
a1544 1
		zyd_write32(sc, ZYD_MACB_AIFS_CTL2, 0x008C003C);
d1602 4
a1605 2
	sc->rf_rev = tmp & 0x0f;
	sc->pa_rev = (tmp >> 16) & 0x0f;
d1718 1
d1730 1
a1730 2
	(void)zyd_write32(sc, ZYD_CR31, sc->pwr_int[chan - 1]);
	(void)zyd_write32(sc, ZYD_CR68, sc->pwr_cal[chan - 1]);
d1733 5
a1737 3
		(void)zyd_write32(sc, ZYD_CR67, sc->ofdm36_cal[chan - 1]);
		(void)zyd_write32(sc, ZYD_CR66, sc->ofdm48_cal[chan - 1]);
		(void)zyd_write32(sc, ZYD_CR65, sc->ofdm54_cal[chan - 1]);
d1739 2
a1740 2
		(void)zyd_write32(sc, ZYD_CR69, 0x28);
		(void)zyd_write32(sc, ZYD_CR69, 0x2a);
d1742 8
@


1.61
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.60 2007/09/07 19:05:05 damien Exp $	*/
d101 1
@


1.60
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.59 2007/08/28 18:34:38 deraadt Exp $	*/
a281 1
	char *devinfop;
a284 4

	devinfop = usbd_devinfo_alloc(sc->sc_udev, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.59
log
@unify firmware load failure messages; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.58 2007/06/14 10:11:15 mbalmer Exp $	*/
d646 1
a646 6
	struct zyd_node *zn;

	zn = malloc(sizeof (struct zyd_node), M_DEVBUF, M_NOWAIT);
	if (zn != NULL)
		bzero(zn, sizeof (struct zyd_node));
	return (struct ieee80211_node *)zn;
@


1.58
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.57 2007/06/12 16:26:36 mbalmer Exp $	*/
d259 2
a260 2
		printf("%s: could not read firmware file %s (error=%d)\n",
		    sc->sc_dev.dv_xname, fwname, error);
@


1.57
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.56 2007/06/10 14:49:00 mbalmer Exp $	*/
d146 16
a161 1
USB_DECLARE_DRIVER_CLASS(zyd, DV_IFNET);
@


1.56
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.55 2007/06/10 10:53:48 mbalmer Exp $	*/
d2529 1
a2529 1
zyd_activate(device_ptr_t self, enum devact act)
@


1.55
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.54 2007/06/09 12:22:53 mbalmer Exp $	*/
d245 1
a245 1
		    USBDEVNAME(sc->sc_dev), fwname, error);
d253 1
a253 1
		    USBDEVNAME(sc->sc_dev), error);
d273 1
a273 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d281 1
a281 1
		    "(only >= 43.30 supported)\n", USBDEVNAME(sc->sc_dev),
d310 1
a310 1
		    USBDEVNAME(sc->sc_dev));
d318 1
a318 1
		    USBDEVNAME(sc->sc_dev));
d323 1
a323 1
		printf("%s: could not open pipes\n", USBDEVNAME(sc->sc_dev));
d328 1
a328 1
		printf("%s: could not read EEPROM\n", USBDEVNAME(sc->sc_dev));
d333 1
a333 1
		printf("%s: could not attach RF\n", USBDEVNAME(sc->sc_dev));
d339 1
a339 1
		    USBDEVNAME(sc->sc_dev));
d344 1
a344 1
	    USBDEVNAME(sc->sc_dev), (sc->mac_rev == ZYD_ZD1211) ? "": "B",
d379 1
a379 1
	memcpy(ifp->if_xname, USBDEVNAME(sc->sc_dev), IFNAMSIZ);
d471 1
a471 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d480 1
a480 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d489 1
a489 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d498 1
a498 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d541 1
a541 1
			    USBDEVNAME(sc->sc_dev));
d548 1
a548 1
			    USBDEVNAME(sc->sc_dev));
d595 1
a595 1
			    USBDEVNAME(sc->sc_dev));
d602 1
a602 1
			    USBDEVNAME(sc->sc_dev));
d780 1
a780 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1471 1
a1471 1
		    USBDEVNAME(sc->sc_dev), zyd_rf_name(type));
d1561 1
a1561 1
		    USBDEVNAME(sc->sc_dev));
d1829 1
a1829 1
		printf("%s: unknown notification %x\n", USBDEVNAME(sc->sc_dev),
d1848 1
a1848 1
		    USBDEVNAME(sc->sc_dev), len);
d1859 1
a1859 1
		    USBDEVNAME(sc->sc_dev), stat->flags));
d1872 1
a1872 1
		    USBDEVNAME(sc->sc_dev));
d1880 1
a1880 1
			    USBDEVNAME(sc->sc_dev));
d1950 1
a1950 1
		    USBDEVNAME(sc->sc_dev), len);
d2001 1
a2001 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(status));
d2144 1
a2144 1
	    USBDEVNAME(sc->sc_dev), m0->m_pkthdr.len, rate, xferlen));
d2238 1
a2238 1
			printf("%s: device timeout\n", USBDEVNAME(sc->sc_dev));
d2377 1
a2377 1
		    USBDEVNAME(sc->sc_dev));
d2382 1
a2382 1
		    USBDEVNAME(sc->sc_dev));
d2398 1
a2398 1
			    USBDEVNAME(sc->sc_dev));
@


1.54
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.53 2007/05/27 04:00:25 jsg Exp $	*/
d405 1
a405 1
	    USBDEV(sc->sc_dev));
d441 1
a441 1
	    USBDEV(sc->sc_dev));
@


1.53
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.52 2007/02/11 00:08:04 jsg Exp $	*/
a2535 1
		/*if_deactivate(&sc->sc_ic.sc_if);*/
@


1.52
log
@Don't enable debug spam by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.51 2007/02/09 09:11:22 jsg Exp $	*/
d221 2
a222 1
USB_MATCH(zyd)
d224 1
a224 1
	USB_MATCH_START(zyd, uaa);
d262 2
a263 1
USB_ATTACH(zyd)
d265 2
a266 1
	USB_ATTACH_START(zyd, sc, uaa);
d273 1
a273 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d283 1
a283 1
		USB_ATTACH_ERROR_RETURN;
a289 2

	USB_ATTACH_SUCCESS_RETURN;
d410 2
a411 1
USB_DETACH(zyd)
d413 1
a413 1
	USB_DETACH_START(zyd, sc);
@


1.51
log
@Add a bunch more zyd(4) devices
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.50 2007/01/14 00:12:13 jsg Exp $	*/
d69 1
a69 1
/*#ifdef USB_DEBUG*/
d71 1
a71 1
/*#endif*/
d76 1
a76 1
int zyddebug = 1;
@


1.50
log
@Match some additional devices found in Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.49 2007/01/02 14:43:50 claudio Exp $	*/
a98 1
	ZYD_ZD1211_DEV(BELKIN,		F5D7050C),
d108 2
a109 1
	ZYD_ZD1211_DEV(TEKRAM,		ZD1211),
d115 1
d121 1
d123 2
d127 1
d130 1
d132 4
d137 3
a141 1
	ZYD_ZD1211B_DEV(ZYDAS,		ZD1211B),
@


1.49
log
@Don't use M_DUP_PKTHDR() in the driver bpf hook. Using M_DUP_PKTHDR() on a
static mbuf results in a mbuf tag memory leak. Same change as in rum(4).
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.48 2006/12/16 15:35:47 damien Exp $	*/
d105 1
d111 1
d116 1
d123 1
d128 1
@


1.48
log
@o add missing calibration bits for ZD1211B in zyd_set_chan()
o add workaround for TX rate==0 bug here too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.47 2006/12/09 23:26:02 maja Exp $	*/
a1887 1
		M_DUP_PKTHDR(&mb, m);
d1891 3
a1893 1
		mb.m_pkthdr.len += mb.m_len;
a2111 1
		M_DUP_PKTHDR(&mb, m0);
d2115 3
a2117 1
		mb.m_pkthdr.len += mb.m_len;
@


1.47
log
@Add USR5423. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.46 2006/12/02 16:43:27 mglocker Exp $	*/
a1700 1
	/* XXX more ZD1211B specific bits? */
d1702 4
d2045 2
@


1.46
log
@Add a "break" which makes AL7230B initialize now.  Still doesn't work
afterwards, but ...

Spotted by claudio@@, ok deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.45 2006/11/30 19:28:07 damien Exp $	*/
d122 1
@


1.45
log
@cosmetic
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.44 2006/11/30 17:45:40 damien Exp $	*/
d1425 1
@


1.44
log
@fix PHY initialization for ZD1211B.
we were iterating from 0 to N(zyd_def_phy), but N(zyd_def_phy) is not
equal to N(zyd_def_phyB). we were probably writting garbage to the PHY.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.43 2006/11/30 17:39:12 damien Exp $	*/
a97 2
	ZYD_ZD1211B_DEV(ACCTON,		SMCWUSBG),
	ZYD_ZD1211B_DEV(ASUS,		A9T_WIFI),
a99 1
	ZYD_ZD1211B_DEV(CISCOLINKSYS,	WUSBF54G),
a101 1
	ZYD_ZD1211B_DEV(FIBERLINE,	WL430U),
a104 1
	ZYD_ZD1211B_DEV(SAGEM,		XG76NA),
a111 1
	ZYD_ZD1211B_DEV(UMEDIA,		TEW429UBC1),
d115 7
d1276 3
a1278 2
	static const uint32_t rfprog_f[] = ZYD_MAXIM_CHANTABLE_F;
	static const uint32_t rfprog_n[] = ZYD_MAXIM_CHANTABLE_N;
d1297 2
a1298 2
	(void)zyd_rfwrite(sc, rfprog_f[chan - 1]);
	(void)zyd_rfwrite(sc, rfprog_n[chan - 1]);
d1361 3
a1363 2
	static const uint32_t rfprog_f[] = ZYD_MAXIM2_CHANTABLE_F;
	static const uint32_t rfprog_n[] = ZYD_MAXIM2_CHANTABLE_N;
d1382 2
a1383 2
	(void)zyd_rfwrite(sc, rfprog_f[chan - 1]);
	(void)zyd_rfwrite(sc, rfprog_n[chan - 1]);
d1701 2
a1702 2
		zyd_write32(sc, ZYD_CR69, 0x28);
		zyd_write32(sc, ZYD_CR69, 0x2a);
d2014 1
a2014 1
	u_int16_t hdrlen;
d2081 4
a2084 8
	hdrlen = sizeof (struct zyd_tx_desc) + 10;

	if (sc->mac_rev == ZYD_ZD1211B) {
		/* XXX this means no cipher */
		desc->pktlen = htole16(hdrlen);
	} else {
		desc->pktlen = htole16(hdrlen + totlen);
	}
@


1.43
log
@fix setting of MAC register ZYD_MAC_RETRY for ZD1211B.
maximum retry count must be set for each EDCA access category.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.42 2006/11/30 09:27:20 jsg Exp $	*/
a1468 3
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
	const struct zyd_phy_pair *zyd_def_phyp = (sc->mac_rev == ZYD_ZD1211B) ?
	    zyd_def_phyB : zyd_def_phy;
d1470 2
a1471 1
	int i, error;
d1490 3
a1492 4
	for (i = 0; i < N(zyd_def_phy); i++) {
		error = zyd_write16(sc, zyd_def_phyp[i].reg,
		    zyd_def_phyp[i].val);
		if (error != 0)
a1546 1
#undef N
@


1.42
log
@more ZD1211B devices
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.41 2006/11/29 16:23:19 jsg Exp $	*/
a1502 1
	zyd_write32(sc, ZYD_MAC_RETRY, 0x00000002);
d1504 4
a1507 1
	if (sc->mac_rev == ZYD_ZD1211B) {
@


1.41
log
@Remaining bits required for ZD1211B support.
Seems to work fine with Linksys and 3Com adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.40 2006/11/29 13:56:17 jsg Exp $	*/
d98 2
d105 1
d109 1
d117 1
d121 1
@


1.40
log
@match Linksys WUSBF54G
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.39 2006/11/27 15:44:03 jsg Exp $	*/
d151 1
d948 25
d1403 4
a1406 1
		rf->init         = zyd_al2230_init;
d2007 1
d2074 8
a2081 1
	desc->pktlen = htole16(sizeof (struct zyd_tx_desc) + totlen + 10);
@


1.39
log
@Initial untested bits for ZD1211B support, different init
sequences for radios not yet done.
"commit what you have" damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.38 2006/11/26 11:14:22 deraadt Exp $	*/
d100 1
d116 1
a116 1
/*	ZYD_ZD1211B_DEV(ZYDAS,		ZD1211B), */
@


1.38
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.37 2006/11/16 19:43:52 damien Exp $	*/
d82 3
d115 1
d949 1
d952 1
a952 1
	(void)zyd_write16(sc, ZYD_CR251, on ? 0x3f : 0x2f);
d1434 2
a1435 2
	static const struct zyd_phy_pair zyd_def_phy[] = ZYD_DEF_PHY;
	static const struct zyd_mac_pair zyd_def_mac[] = ZYD_DEF_MAC;
d1457 2
a1458 2
		error = zyd_write16(sc, zyd_def_phy[i].reg,
		    zyd_def_phy[i].val);
d1465 31
a1495 6
	for (i = 0; i < N(zyd_def_mac); i++) {
		error = zyd_write32(sc, zyd_def_mac[i].reg,
		    zyd_def_mac[i].val);
		if (error != 0)
			goto fail;
	}
d1661 6
@


1.37
log
@add support for 4 new radios: AL2210, CGT, Maxim New, Maxim New2

untested because of lack of hardware. if you have a ZD1211 adapter
with one of these radios, please drop us a mail.

code written by Florian Stoehr <ich AT florian-stoehr DOT de>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.36 2006/11/13 20:06:38 damien Exp $	*/
a189 11
/*
 * Supported rates for 802.11b/g modes (in 500Kbps unit).
 */
static const struct ieee80211_rateset zyd_rateset_11b = {
	4, { 2, 4, 11, 22 }
};

static const struct ieee80211_rateset zyd_rateset_11g =	{
	8, { 12, 18, 24, 36, 48, 72, 96, 108 }
};

d329 2
a330 2
	ic->ic_sup_rates[IEEE80211_MODE_11B] = zyd_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = zyd_rateset_11g;
@


1.36
log
@first round of commits for proper 11b/g protection support:
- use the newly introduced ieee80211_get_rts() and
  ieee80211_get_cts_to_self() functions.
- use CTS-to-self instead of RTS/CTS to protect OFDM frames in
  a mixed 11b/g BSS.
- make sure multicast frames are sent using CCK modulation.

remove support for 5GHz radios in ral(4) RT2560 and ural(4).
i'm not aware of any such adapters on the market and 11a code
is known to be broken.

some cleanup while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.35 2006/11/03 19:34:56 damien Exp $	*/
d149 12
d1079 288
d1392 24
@


1.35
log
@add new code to handle the AL7230B radios.

code written by Florian Stoehr. not tested due to lack of hardware.
if you happen to have an adapter with this radio please report success/
failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.34 2006/11/01 11:52:24 damien Exp $	*/
d1091 1
a1091 1
		rf->width        = 24;	/* 24-bit RF values */		
d1642 4
a1645 3
	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_MGT) {
		/* mgmt frames are sent at the lowest available bit-rate */
d1647 5
a1651 7
	} else {
		if (ic->ic_fixed_rate != -1) {
			rate = ic->ic_sup_rates[ic->ic_curmode].
			    rs_rates[ic->ic_fixed_rate];
		} else
			rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	}
d1667 2
a1668 3
		if (totlen > ic->ic_rtsthreshold ||
		    (ZYD_RATE_IS_OFDM(rate) &&
		    (ic->ic_flags & IEEE80211_F_USEPROT)))
d1670 7
d1934 1
a1934 1
		(void)zyd_write32(sc, ZYD_MAC_BAS_RATE, 0x3);
d1938 1
a1938 1
		(void)zyd_write32(sc, ZYD_MAC_BAS_RATE, 0x150f);
d1942 1
a1942 1
		(void)zyd_write32(sc, ZYD_MAC_MAN_RATE, 0x0f);
@


1.34
log
@abort bulk-in and bulk-out pipes in zyd_stop() before freeing the
Rx/Tx xfer lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.33 2006/10/23 18:08:34 damien Exp $	*/
d146 3
d969 98
d1087 5
@


1.33
log
@simplify zyd_read_eeprom().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.32 2006/10/23 17:44:15 damien Exp $	*/
d1909 3
@


1.32
log
@turn link led off when returning to the S_INIT state.
implement fast channel switching for monitor mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.31 2006/10/22 12:52:03 damien Exp $	*/
d1098 1
a1098 2
	}
	for (i = 0; i < 7; i++) {
d1102 1
a1102 2
	}
	for (i = 0; i < 7; i++) {
d1106 1
a1106 2
	}
	for (i = 0; i < 7; i++) {
d1110 1
a1110 2
	}
	for (i = 0; i < 7; i++) {
@


1.31
log
@make data LED blink upon TX.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.30 2006/10/22 11:53:21 damien Exp $	*/
d646 1
a646 1
			zyd_set_led(sc, ZYD_LED1, 1);
d1726 1
a1726 1
zyd_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
d1736 1
a1736 1
	switch (command) {
d1758 1
a1758 1
		error = (command == SIOCADDMULTI) ?
d1765 14
d1780 1
a1780 1
		error = ieee80211_ioctl(ifp, command, data);
@


1.30
log
@do per-node rate control.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.29 2006/10/21 18:32:20 deraadt Exp $	*/
d153 1
d644 7
a650 1
		/* XXX update link LED */
a666 1
		/* XXX update link LED, start Tx LED */
d669 7
a675 1
		if (ic->ic_opmode != IEEE80211_M_MONITOR)
d677 1
d1163 12
a1884 2
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

d1888 2
@


1.29
log
@some extra const disease damien was testing slipped in; ok damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.28 2006/10/21 18:18:50 damien Exp $	*/
d126 1
d154 1
a154 2
void		zyd_set_chan(struct zyd_softc *,
		    struct ieee80211_channel *);
d169 1
a169 1
void		zyd_amrr_start(struct zyd_softc *, struct ieee80211_node *);
d171 2
d347 2
d591 11
d666 8
a673 4
		/* enable automatic rate control in STA mode */
		if (ic->ic_opmode == IEEE80211_M_STA &&
		    ic->ic_fixed_rate == -1)
			zyd_amrr_start(sc, ni);
d1259 1
a1259 2
		    letoh16(retry->rate),
		    ether_sprintf((u_char *)retry->macaddr),
d1274 2
a1275 1
		sc->amn.amn_retrycnt++;
d1476 3
a1483 1
	sc->amn.amn_txcnt++;
d1922 1
a1922 1
zyd_amrr_start(struct zyd_softc *sc, struct ieee80211_node *ni)
d1924 5
a1928 1
	int i;
d1930 6
a1935 1
	ieee80211_amrr_node_init(&sc->amrr, &sc->amn);
d1937 6
a1942 5
	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;
d1948 1
a1948 1
zyd_amrr_timeout(void *arg)
d1950 4
a1953 1
	struct zyd_softc *sc = arg;
d1955 5
a1959 2
	ieee80211_amrr_choose(&sc->amrr, sc->sc_ic.ic_bss, &sc->amn);
	timeout_add(&sc->amrr_to, hz);
@


1.28
log
@huge diff to bring zyd(4) into a working state.
should work with ZD1211 (not ZD1211B!) adapters with either a
RFMD or AL2230 radio chip.
does not support IBSS or HostAP modes yet.

committed over a Billion 3011G (ZD1211/AL2230).

"commit it!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.27 2006/09/23 22:28:43 mglocker Exp $	*/
d154 1
a154 1
		    const struct ieee80211_channel *);
d1155 1
a1155 1
zyd_set_chan(struct zyd_softc *sc, const struct ieee80211_channel *c)
d1233 2
a1234 2
		const struct zyd_notif_retry *retry =
		    (const struct zyd_notif_retry *)cmd->data;
d1285 1
a1285 1
	const struct ieee80211_frame *wh;
d1361 1
a1361 1
	wh = mtod(m, const struct ieee80211_frame *);
@


1.27
log
@Add TRENDnet TEW-429UB A.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.26 2006/09/18 16:20:20 damien Exp $	*/
d3 2
a4 1
/*
d21 1
a21 1
 * ZyDAS ZD1211 USB WLAN driver
a23 4
#define ZYD_DEBUG

#include <sys/cdefs.h>

d28 1
d34 2
a35 2
#include <sys/kthread.h>
#include <sys/queue.h>
a36 1
#include <sys/tty.h>
d39 1
a39 7

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>

#include <dev/usb/usbdevs.h>
a42 1
#include <net/bpfdesc.h>
a43 1

d52 2
d55 1
d59 1
d62 4
a65 4
#ifdef USB_DEBUG
#define ZYD_DEBUG
//#define ZYD_INTRDUMP
#endif
d69 4
a72 1
/* Debug printf helper macros */
d74 2
a75 2
#define DPRINTF(x)	do { if (zyddebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (zyddebug>(n)) printf x; } while (0)
d79 1
a79 1
#define DPRINTFN(n,x)
d82 30
a111 20
static const struct usb_devno zyd_devs[] = {
	{ USB_VENDOR_3COM2,		USB_PRODUCT_3COM2_3CRUSB10075 },
	{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_WL54 },
	{ USB_VENDOR_ASUS,		USB_PRODUCT_ASUS_WL159G },
	{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_F5D7050C },
	{ USB_VENDOR_CYBERTAN,		USB_PRODUCT_CYBERTAN_TG54USB },
	{ USB_VENDOR_DRAYTEK,		USB_PRODUCT_DRAYTEK_VIGOR550 },
	{ USB_VENDOR_PLANEX2,		USB_PRODUCT_PLANEX2_GWUS54GZL },
	{ USB_VENDOR_PLANEX3,		USB_PRODUCT_PLANEX3_GWUS54MINI },
	{ USB_VENDOR_SAGEM,		USB_PRODUCT_SAGEM_XG760A },
	{ USB_VENDOR_SITECOMEU,		USB_PRODUCT_SITECOMEU_WL113 },
	{ USB_VENDOR_SWEEX,		USB_PRODUCT_SWEEX_ZD1211 },
	{ USB_VENDOR_TEKRAM,		USB_PRODUCT_TEKRAM_QUICKWLAN },
	{ USB_VENDOR_TEKRAM,		USB_PRODUCT_TEKRAM_ZD1211 },
	{ USB_VENDOR_TWINMOS,		USB_PRODUCT_TWINMOS_G240 },
	{ USB_VENDOR_UMEDIA,		USB_PRODUCT_UMEDIA_TEW429UB_A },
	{ USB_VENDOR_UMEDIA,		USB_PRODUCT_UMEDIA_TEW429UB },
	{ USB_VENDOR_WISTRONNEWEB,	USB_PRODUCT_WISTRONNEWEB_UR055G },
	{ USB_VENDOR_ZYDAS,		USB_PRODUCT_ZYDAS_ZD1211 },
	{ USB_VENDOR_ZYXEL,		USB_PRODUCT_ZYXEL_ZYAIRG220 }
d113 2
a117 43
uint16_t	zyd_getrealaddr(struct zyd_softc *, uint32_t);
usbd_status	zyd_usbrequest(struct zyd_softc *, uint8_t, uint8_t,
		    uint16_t, uint16_t, uint16_t, uint8_t *);
usbd_status	zyd_usbrequestzc(struct zyd_softc *, struct zyd_control *);
void		zyd_reset(struct zyd_softc *);
usbd_status	zyd_usb_bulk_read(struct zyd_softc *, void *, uint32_t,
		    uint32_t *);
usbd_status	zyd_usb_bulk_write(struct zyd_softc *, void *, uint32_t);
Static void	zydintr(usbd_xfer_handle, usbd_private_handle, usbd_status);
int		zyd_usb_intr_read(struct zyd_softc *, void *, uint32_t);
usbd_status	zyd_usb_intr_write(struct zyd_softc *, void *, uint32_t);
uint32_t	zyd_addrinc(uint32_t);
int		zyd_read16(struct zyd_softc *, uint32_t, uint16_t *);
int		zyd_read32(struct zyd_softc *, uint32_t, uint32_t *);
int		zyd_read16_multi(struct zyd_softc *, uint32_t *, uint16_t *,
		    uint8_t);
int		zyd_read32_multi(struct zyd_softc *, uint32_t *, uint32_t *,
		    uint8_t);

usbd_status	zyd_write16(struct zyd_softc *, uint32_t, uint16_t);
usbd_status	zyd_write32(struct zyd_softc *, uint32_t, uint32_t);
usbd_status	zyd_write16_multi(struct zyd_softc *, uint32_t *,
		    uint16_t *, uint8_t);
usbd_status	zyd_write32_multi(struct zyd_softc *, uint32_t *,
		    uint32_t *, uint8_t);
usbd_status	zyd_write16_batch(struct zyd_softc *,
	 	    const struct zyd_adpairs16 *, int);
usbd_status	zyd_write32_batch(struct zyd_softc *,
		    const struct zyd_adpairs32 *, int);
usbd_status	zyd_rfwrite(struct zyd_softc *, uint32_t, uint8_t);

int		zyd_openpipes(struct zyd_softc *);
void		zyd_closepipes(struct zyd_softc *);
int		zyd_alloc_tx(struct zyd_softc *);
void		zyd_free_tx(struct zyd_softc *);
int		zyd_alloc_rx(struct zyd_softc *);
void		zyd_free_rx(struct zyd_softc *);
void		zyd_stateoutput(struct zyd_softc *);
void		zyd_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void		zyd_rxframeproc(struct zyd_rx_data *, uint8_t *, uint16_t);
void		zyd_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);

int		zyd_uploadfirmware(struct zyd_softc *);
d119 18
d139 7
a145 3
usbd_status	zyd_get_aw_pt_bi(struct zyd_softc *, struct zyd_aw_pt_bi *);
usbd_status	zyd_set_aw_pt_bi(struct zyd_softc *, struct zyd_aw_pt_bi *);
usbd_status	zyd_set_beacon_interval(struct zyd_softc *, uint32_t);
d147 9
a155 40
usbd_status	zyd_read_rf_pa_types(struct zyd_softc *, uint8_t *, uint8_t *);

usbd_status	zyd_rf_rfmd_init(struct zyd_softc *, struct zyd_rf *);
usbd_status	zyd_rf_rfmd_switchradio(struct zyd_softc *, uint8_t);
usbd_status	zyd_rf_rfmd_set_channel(struct zyd_softc *, struct zyd_rf *,
		    uint8_t);

usbd_status	zyd_rf_al2230_init(struct zyd_softc *, struct zyd_rf *);
usbd_status	zyd_rf_al2230_switchradio(struct zyd_softc *, uint8_t);
usbd_status	zyd_rf_al2230_set_channel(struct zyd_softc *, struct zyd_rf *,
		    uint8_t);

usbd_status	zyd_rf_init_hw(struct zyd_softc *, struct zyd_rf *, uint8_t);

usbd_status	zyd_hw_init(struct zyd_softc *, struct ieee80211com *);
usbd_status	zyd_get_e2p_mac_addr(struct zyd_softc *, struct zyd_macaddr *);
usbd_status	zyd_set_mac_addr(struct zyd_softc *,
		    const struct zyd_macaddr *);
usbd_status	zyd_read_regdomain(struct zyd_softc *, uint8_t *);
int		zyd_regdomain_supported(uint8_t);

int		zyd_tblreader(struct zyd_softc *, uint8_t *, size_t,
		    uint32_t, uint32_t);
int		zyd_readcaltables(struct zyd_softc *);

int		zyd_reset_channel(struct zyd_softc *);
usbd_status	zyd_set_encryption_type(struct zyd_softc *, uint32_t);
usbd_status	zyd_switch_radio(struct zyd_softc *, uint8_t);
usbd_status	zyd_enable_hwint(struct zyd_softc *);
usbd_status	zyd_disable_hwint(struct zyd_softc *);
usbd_status	zyd_set_basic_rates(struct zyd_softc *, int);
usbd_status	zyd_set_mandatory_rates(struct zyd_softc *, int);
usbd_status	zyd_reset_mode(struct zyd_softc *);
usbd_status	zyd_set_bssid(struct zyd_softc *, uint8_t *);
usbd_status	zyd_complete_attach(struct zyd_softc *);
int		zyd_media_change(struct ifnet *);
int		zyd_newstate(struct ieee80211com *, enum ieee80211_state, int);
int		zyd_initial_config(struct zyd_softc *);
void		zyd_update_promisc(struct zyd_softc *);
uint16_t	zyd_txtime(int, int, uint32_t);
d157 4
a160 7
uint16_t	zyd_calc_useclen(int, uint16_t, uint8_t *);

void		zyd_setup_tx_desc(struct zyd_softc *,
		    struct zyd_controlsetformat *, struct mbuf *, int, int);

int		zyd_tx_mgt(struct zyd_softc *, struct mbuf *,
		    struct ieee80211_node *);
a162 8
int		zyd_tx_bcn(struct zyd_softc *, struct mbuf *,
		    struct ieee80211_node *);

void		zyd_set_chan(struct zyd_softc *, struct ieee80211_channel *);

/* Registered @@ if */
int		zyd_init(struct ifnet *);
/*void		zyd_stop(struct ifnet *, int);*/
d164 1
d166 5
a170 1
void		zyd_watchdog(struct ifnet *);
d172 5
a176 7
void		zyd_next_scan(void *);
void		zyd_task(void *);


/* Device, regardless of RF */
static const struct zyd_adpairs16 zyd_def_cr[] = {
	ZYD_DEF_CR
d179 2
a180 2
static const struct zyd_adpairs32 zyd_def_mac[] = {
	ZYD_DEF_MAC
d183 3
a185 4
/* RF2959 */
static const struct zyd_adpairs16 zyd_rfmd_cr[] = {
	ZYD_RFMD_CR
};
d187 2
a188 3
static const uint32_t zyd_rfmd_rf[] = {
	ZYD_RFMD_RF
};
d190 3
a192 4
/* AL2230 */
static const struct zyd_adpairs16 zyd_al2230_cr[] = {
	ZYD_AL2230_CR
};
d194 2
a195 10
static const uint32_t zyd_al2230_rf[] = {
	ZYD_AL2230_RF
};


/*
 * Debug dump
 */
void bindump(uint8_t *, int);
void bindump(uint8_t *ptr, int len)
d197 5
a201 1
	int i;
d203 6
a208 2
	for (i = 0; i < len; i++) {
		DPRINTF(("%02x=%02x ", i, *(ptr + i)));
d210 6
a215 2
		if ((i > 0) && (!((i + 1) % 7)))
			DPRINTF(("\n"));
d218 3
a220 1
	DPRINTF(("\n"));
d223 1
a223 6

/*
 * Get the real address from a range-mangled address
 */
uint16_t
zyd_getrealaddr(struct zyd_softc *sc, uint32_t mangled_addr)
d225 3
a227 3
	uint16_t add;
	uint16_t res;
	uint16_t blubb;
d229 1
a229 1
	add = 0;
d231 4
a234 3
	switch (ZYD_GET_RANGE(mangled_addr)) {
	case ZYD_RANGE_USB:
		break;
d236 1
a236 3
	case ZYD_RANGE_CTL:
		add = ZYD_CTRL_START_ADDR;
		break;
d238 6
a243 7
	case ZYD_RANGE_E2P:
		add = ZYD_E2P_START_ADDR;
		break;

	case ZYD_RANGE_FW:
		add = sc->firmware_base;
		break;
d246 4
a249 2
	res = (add + ZYD_GET_OFFS(mangled_addr));
	blubb = ZYD_GET_OFFS(mangled_addr);
d251 1
a251 4
/*	DPRINTF(("mangled = %x, add = %x, blubb = %x, result = %x\n",
		mangled_addr, add, blubb, res));*/

	return res;
d254 2
a255 7

/*
 * USB request basic wrapper
 */
usbd_status
zyd_usbrequest(struct zyd_softc *sc, uint8_t type, uint8_t request,
	uint16_t value, uint16_t index, uint16_t length, uint8_t *data)
d257 4
a260 4
	usb_device_request_t req;
	usbd_xfer_handle xfer;
	usbd_status err;
	int total_len = 0, s;
d262 2
a263 9
	req.bmRequestType = type;
	req.bRequest = request;
	USETW(req.wValue, value);
	USETW(req.wIndex, index);
	USETW(req.wLength, length);

	DPRINTFN(20, ("%s: req=%02x val=%02x ind=%02x "
	    "len=%02x\n", USBDEVNAME(sc->zyd_dev), request,
	    value, index, length));
d265 3
a267 2
	/* Block network interrupts */
	s = splnet();
d269 6
a274 3
	xfer = usbd_alloc_xfer(sc->zyd_udev);
	usbd_setup_default_xfer(xfer, sc->zyd_udev, 0, 500000, &req, data,
	    length, USBD_SHORT_XFER_OK, 0);
d276 7
a282 1
	err = usbd_sync_transfer(xfer);
d284 4
a287 1
	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);
d289 3
a291 10
#ifdef ZYD_DEBUG
	if (zyddebug) {
		if (type & UT_READ) {
			DPRINTFN(20, ("%s: transfered 0x%x bytes in\n",
			    USBDEVNAME(sc->zyd_dev), total_len));
		} else {
			if (total_len != length)
				DPRINTF(("%s: wrote only %x bytes\n",
				    USBDEVNAME(sc->zyd_dev), total_len));
		}
a292 1
#endif /* ZYD_DEBUG */
d294 4
a297 1
	usbd_free_xfer(xfer);
d299 5
a303 2
	/* Allow interrupts again */
	splx(s);
d305 4
a308 2
	return (err);
}
d310 3
a312 9
/*
 * Same, higher level
 */
usbd_status
zyd_usbrequestzc(struct zyd_softc *sc, struct zyd_control *zc)
{
	return zyd_usbrequest(sc, zc->type, zc->id, zc->value,
	    zc->index, zc->length, zc->data);
}
d314 6
a319 9
/*
 * Issue a SET_CONFIGURATION command, which will reset the device.
 */
void
zyd_reset(struct zyd_softc *sc)
{
	if (usbd_set_config_no(sc->zyd_udev, ZYD_CONFIG_NO, 1) ||
	    usbd_device2interface_handle(sc->zyd_udev, ZYD_IFACE_IDX, &sc->zyd_iface))
		printf("%s: reset failed\n", USBDEVNAME(sc->zyd_dev));
d321 3
a323 3
	/* Wait a little while for the chip to get its brains in order. */
	usbd_delay_ms(sc->zyd_udev, 100);
}
d325 8
a332 10
/*
 * Bulk transfer, read
 */
usbd_status
zyd_usb_bulk_read(struct zyd_softc *sc, void *data, uint32_t size,
	uint32_t *readbytes)
{
	usbd_xfer_handle xfer;
	usbd_status err;
	int timeout = 1000;
d334 8
a341 1
	xfer = usbd_alloc_xfer(sc->zyd_udev);
d343 2
a344 2
	if (xfer == NULL)
		return (EIO);
d346 4
a349 2
	err = usbd_bulk_transfer(xfer, sc->zyd_ep[ZYD_ENDPT_BIN], 0,
	    timeout, data, &size, "zydrb");
d351 3
a353 1
	usbd_free_xfer(xfer);
d355 3
a357 1
	*readbytes = size;
d359 4
a362 17
	return (err);
}

/*
 * Bulk transfer, write
 */
usbd_status
zyd_usb_bulk_write(struct zyd_softc *sc, void *data, uint32_t size)
{
	usbd_xfer_handle xfer;
	usbd_status err;
	int timeout = 1000;

	xfer = usbd_alloc_xfer(sc->zyd_udev);

	if (xfer == NULL)
		return (EIO);
d364 2
a365 2
	err = usbd_bulk_transfer(xfer, sc->zyd_ep[ZYD_ENDPT_BOUT], 0,
	    timeout, data, &size, "zydwb");
d367 1
a367 3
	usbd_free_xfer(xfer);

	return (err);
d370 5
a374 12
/*
 * Callback handler for interrupt transfer
 */
Static void
zydintr(usbd_xfer_handle xfer, usbd_private_handle thehandle,
	usbd_status status)
{
	struct zyd_softc *sc = thehandle;
	uint32_t count;
/*	char rawbuf[1024];
	char tmpbuf[100];
	int i;*/
d376 1
a376 1
	DPRINTFN(2, ("zydintr: status=%d\n", status));
d378 3
a380 2
	if (status == USBD_CANCELLED)
		return;
d382 1
a382 3
	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->zyd_ep[ZYD_ENDPT_IIN]);
d384 3
a386 1
		return;
d389 2
a390 2
/*	DPRINTF(("zydintr: getting xfer status\n"));*/
	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
d392 2
a393 1
/*	DPRINTF(("zydintr: xfer=%p status=%d count=%d\n", xfer, status, count));*/
d395 1
a395 2
/*	memset(rawbuf, 0, 1024);
	strcpy(rawbuf, "data: ");
d397 1
a397 4
	for (i = 0; i < count; ++i) {
		sprintf(tmpbuf, "%d:%02X ", i, *(sc->ibuf + i));
		strcat(rawbuf, tmpbuf);
	}*/
d399 2
a400 1
/*	DPRINTF(("zydintr: raw buffer is %s\n", rawbuf));*/
d402 1
a402 9
	(void)b_to_q(sc->ibuf, count, &sc->q_reply);

	if (sc->pending) {
		sc->pending = 0;
		DPRINTFN(5, ("zydintr: waking %p\n", sc));
		wakeup(sc);
	}

/*	selnotify(&sc->rsel, 0);*/
a404 3
/*
 * Interrupt call reply transfer, read
 */
d406 1
a406 1
zyd_usb_intr_read(struct zyd_softc *sc, void *data, uint32_t size)
d408 8
a415 1
	int s, error;
d417 3
a419 1
	error = 0;
d421 3
a423 2
	/* Block until we got the interrupt */
	s = splusb();
d425 7
a431 11
	while (sc->q_reply.c_cc == 0) {
		/* It was an interrupt, but it is not affecting us */
		sc->pending = 1;
		DPRINTFN(5, ("zyd_usb_intr_read: sleep on %p\n", sc));
		error = tsleep(sc, PZERO | PCATCH, "zydri", 0);
		DPRINTFN(5, ("zyd_usb_intr_read: woke, error=%d\n", error));

		if (error) {
			sc->pending = 0;
			break;
		}
d434 8
a441 8
	/*
	 * Unfortunately, the ZD1211 transmits more bytes than
	 * actually requested. Fetch everything in the queue
	 * here. zyd_intr() uses different queues for different
	 * types of data, "q_reply" is always the "reply-to-call"
	 * queue, so it's safe to fetch the whole buffer here,
	 * parallel register read request are not allowed.
	 */
d443 8
a450 7
	/*
	 * The buffer contains 2 bytes header, then pairs
	 * of 2 bytes address + 2 bytes data. Plus some
	 * ZD1211-garbage (grrr....).
	 */
	if ((sc->q_reply.c_cc > 0) && (!error))
		q_to_b(&sc->q_reply, data, size);
d452 8
a459 2
	/* Flush the queue */
	ndflush(&sc->q_reply, sc->q_reply.c_cc);
d461 1
a461 2
	/* Allow all interrupts again */
	splx(s);
d463 2
a464 1
	return (error);
d467 2
a468 8
/*
 * Interrupt transfer, write.
 *
 * Not always an "interrupt transfer", as if operating in
 * full speed mode, EP4 is bulk out, not interrupt out.
 */
usbd_status
zyd_usb_intr_write(struct zyd_softc *sc, void *data, uint32_t size)
d470 1
a470 3
	usbd_xfer_handle xfer;
	usbd_status err;
	int timeout = 1000;
d472 10
a481 19
/*	uint32_t size1 = size;*/

#ifdef ZYD_INTRDUMP
	DPRINTF(("%s: intrwrite raw dump:\n", USBDEVNAME(sc->zyd_dev)));
	bindump(data, size);
#endif

	xfer = usbd_alloc_xfer(sc->zyd_udev);

	if (xfer == NULL)
		return (EIO);

	/* Only use the interrupt transfer in high speed mode */
	if (sc->zyd_udev->speed == USB_SPEED_HIGH) {
		err = usbd_intr_transfer(xfer, sc->zyd_ep[ZYD_ENDPT_IOUT], 0,
			timeout, (uint8_t *)data, &size, "zydwi");
	} else {
		err = usbd_bulk_transfer(xfer, sc->zyd_ep[ZYD_ENDPT_IOUT], 0,
			timeout, (uint8_t *)data, &size, "zydwi");
a482 7

/*	DPRINTF(("zyd_usb_intr_write: err = %d, size = %d, size1 = %d\n",
		err, size, size1));*/

	usbd_free_xfer(xfer);

	return (err);
d485 2
a486 5
/*
 * Offset correction (all ranges except CTL use word addressing)
 */
uint32_t
zyd_addrinc(uint32_t addr)
d488 3
a490 2
	uint32_t range = ZYD_GET_RANGE(addr);
	uint32_t offs = ZYD_GET_OFFS(addr);
d492 2
a493 1
	offs += (range == ZYD_RANGE_CTL) ? 2 : 1;
d495 1
a495 2
	return (range | offs);
}
d497 22
a518 7
/*
 * Read a single 16-bit register
 */
int
zyd_read16(struct zyd_softc *sc, uint32_t addr, uint16_t *value)
{
	return zyd_read16_multi(sc, &addr, value, 1);
d521 2
a522 5
/*
 * Read a single 32-bit register
 */
int
zyd_read32(struct zyd_softc *sc, uint32_t addr, uint32_t *value)
d524 15
a538 1
	return zyd_read32_multi(sc, &addr, value, 1);
a540 3
/*
 * Read up to 15 16-bit registers (newer firmware versions)
 */
d542 1
a542 2
zyd_read16_multi(struct zyd_softc *sc, uint32_t *addrs, uint16_t *data,
	uint8_t usecount)
d544 1
a544 4
	struct zyd_intoutmultiread in;
	struct zyd_intinmultioutput op;
	int i, rv;
	int s;
d546 2
a547 2
	memset(&in, 0, sizeof(struct zyd_intoutmultiread));
	memset(&op, 0, sizeof(struct zyd_intinmultioutput));
d549 1
a549 1
	USETW(in.id, ZYD_CMD_IORDREQ);
d551 14
a564 10
	for (i = 0; i < usecount; i++)
		USETW(in.addr[i], zyd_getrealaddr(sc, addrs[i]));

	s = splnet();
	zyd_usb_intr_write(sc, &in, (2 + (usecount * 2)));
	rv = zyd_usb_intr_read(sc, &op, (2 + (usecount * 4)));
	splx(s);

	for (i = 0; i < usecount; i++) {
		data[i] = UGETW(op.registers[i].data);
d566 1
d568 2
a569 1
	return rv;
d572 2
a573 6
/*
 * Read up to 7 32-bit registers (newer firmware versions)
 */
int
zyd_read32_multi(struct zyd_softc *sc, uint32_t *addrs, uint32_t *data,
	uint8_t usecount)
d575 1
a575 5
	struct zyd_intoutmultiread in;
	struct zyd_intinmultioutput op;
	int i, rv;
	int realcount;
	int s;
d577 2
a578 1
	realcount = usecount * 2;
d580 6
a585 2
	memset(&in, 0, sizeof(struct zyd_intoutmultiread));
	memset(&op, 0, sizeof(struct zyd_intinmultioutput));
d587 4
a590 1
	USETW(in.id, ZYD_CMD_IORDREQ);
d592 3
a594 5
	for (i = 0; i < usecount; i++) {
		/* high word is first */
		USETW(in.addr[i * 2], zyd_getrealaddr(sc, zyd_addrinc(addrs[i])));
		USETW(in.addr[(i * 2) + 1], zyd_getrealaddr(sc, addrs[i]));
	}
d596 2
a597 4
	s = splnet();
	zyd_usb_intr_write(sc, &in, (2 + (realcount * 2)));
	rv = zyd_usb_intr_read(sc, &op, (2 + (realcount * 4)));
	splx(s);
d599 1
a599 7
	for (i = 0; i < usecount; i++) {
		data[i] =
		    (UGETW(op.registers[i * 2].data) << 16) |
		    UGETW(op.registers[(i * 2) + 1].data);
	}

	return rv;
d603 2
a604 1
 * Write a single 16-bit register
d606 2
a607 2
usbd_status
zyd_write16(struct zyd_softc *sc, uint32_t addr, uint16_t value)
d609 6
a614 1
	return zyd_write16_multi(sc, &addr, &value, 1);
d617 2
a618 5
/*
 * Write a single 32-bit register
 */
usbd_status
zyd_write32(struct zyd_softc *sc, uint32_t addr, uint32_t value)
d620 3
a622 2
	return zyd_write32_multi(sc, &addr, &value, 1);
}
d624 1
a624 11
/*
 * Write up to 15 16-bit registers (newer firmware versions)
 */
usbd_status
zyd_write16_multi(struct zyd_softc *sc, uint32_t *addrs, uint16_t *data,
	uint8_t usecount)
{
	struct zyd_intoutmultiwrite mw;
	int i;
	int s;
	usbd_status rw;
d626 4
a629 1
	memset(&mw, 0, sizeof(struct zyd_intoutmultiwrite));
d631 4
a634 1
	USETW(mw.id, ZYD_CMD_IOWRREQ);
d636 4
a639 4
	for (i = 0; i < usecount; i++) {
		USETW(mw.registers[i].addr, zyd_getrealaddr(sc, addrs[i]));
		USETW(mw.registers[i].data, data[i]);
	}
d641 3
a643 3
	s = splnet();
	rw = zyd_usb_intr_write(sc, &mw, (2 + (usecount * 4)));
	splx(s);
d645 2
a646 2
	return rw;
}
d648 2
a649 12
/*
 * Write up to 7 32-bit registers (newer firmware versions)
 */
usbd_status
zyd_write32_multi(struct zyd_softc *sc, uint32_t *addrs, uint32_t *data,
	uint8_t usecount)
{
	struct zyd_intoutmultiwrite mw;
	int i;
	int realcount;
	int s;
	usbd_status rw;
d651 4
a654 1
	realcount = usecount * 2;
d656 3
a658 1
	memset(&mw, 0, sizeof(struct zyd_intoutmultiwrite));
d660 2
a661 1
	USETW(mw.id, ZYD_CMD_IOWRREQ);
d663 4
a666 4
	for (i = 0; i < usecount; i++) {
		/* high word is first */
		USETW(mw.registers[i * 2].addr, zyd_getrealaddr(sc, zyd_addrinc(addrs[i])));
		USETW(mw.registers[i * 2].data, (*data >> 16));
d668 3
a670 3
		USETW(mw.registers[(i * 2) + 1].addr, zyd_getrealaddr(sc, addrs[i]));
		USETW(mw.registers[(i * 2) + 1].data, (*data));
	}
d672 4
a675 3
	s = splnet();
	rw = zyd_usb_intr_write(sc, &mw, (2 + (realcount * 4)));
	splx(s);
d677 1
a677 1
	return rw;
d680 3
a682 6
/*
 * Batch write 16-bit data
 */
usbd_status
zyd_write16_batch(struct zyd_softc *sc, const struct zyd_adpairs16 *data,
	int count)
d684 8
a691 3
	/* TODO: Optimize, use multi-writer */
	usbd_status rv;
	int i;
d693 2
a694 1
	rv = 0;
d696 5
a700 1
/*	DPRINTF(("zyd_write16_batch: %d items\n", count));*/
d702 2
a703 3
	for (i = 0; i < count; i++) {
/*		DPRINTF(("zyd_write16_batch: item %d: @@%x -> %02x\n", i, data[i].addr, data[i].data));*/
		rv = zyd_write16(sc, data[i].addr, data[i].data);
d705 19
a723 3
		if (rv)
			break;
	}
d725 2
a726 1
	return rv;
d729 2
a730 6
/*
 * Batch write 32-bit data
 */
usbd_status
zyd_write32_batch(struct zyd_softc *sc, const struct zyd_adpairs32 *data,
	int count)
d732 2
a733 3
	/* TODO: Optimize, use multi-writer */
	usbd_status rv;
	int i;
d735 7
a741 1
	rv = 0;
d743 6
a748 1
/*	DPRINTF(("zyd_write32_batch: %d items\n", count));*/
d750 7
a756 9
	for (i = 0; i < count; i++) {
/*		DPRINTF(("zyd_write32_batch: item %d: @@%x -> %08x\n", i, data[i].addr, data[i].data));*/
		rv = zyd_write32(sc, data[i].addr, data[i].data);

		if (rv)
			break;
	}

	return rv;
d759 2
a760 5
/*
 * Write RF registers
 */
usbd_status
zyd_rfwrite(struct zyd_softc *sc, uint32_t value, uint8_t bits)
d762 1
a762 4
	struct zyd_req_rfwrite *req = NULL;
	int len, i;
	uint16_t bw_template;
	usbd_status rv;
d764 2
a765 1
	DPRINTFN(4, ("Entering zyd_rfwrite()\n"));
d767 2
a768 1
	rv = zyd_read16(sc, ZYD_CR203, &bw_template);
d770 4
a773 2
	if (rv)
		goto leave;
d775 4
a778 2
	/* Clear template */
	bw_template &= ~(ZYD_RF_IF_LE | ZYD_RF_CLK | ZYD_RF_DATA);
d780 2
a781 2
	len = sizeof(struct zyd_req_rfwrite) + (bits * sizeof(uWord));
	req = malloc(len, M_TEMP, M_WAITOK);
d783 7
a789 9
	if (!req)
		return USBD_NOMEM;

	USETW(req->id, ZYD_CMD_RFCFGREQ);
	USETW(req->value, 2);
	USETW(req->bits, bits);

	for (i = 0; i < bits; i++) {
		uint16_t bv = bw_template;
d791 2
a792 2
		if (value & (1 << (bits - 1 - i)))
			bv |= ZYD_RF_DATA;
d794 6
a799 1
		USETW(req->bit_values[i], bv);
d801 2
d804 4
a807 1
	rv = zyd_usb_intr_write(sc, req, len);
d809 4
a812 1
	free(req, M_TEMP);
d814 4
a817 2
	DPRINTFN(4, ("Finished zyd_rfwrite(): rv = %d, wrote %d bits\n", rv,
	    bits));
d819 3
a821 2
leave:
	return rv;
d825 1
a825 1
 * Open bulk and interrupt pipes
d828 1
a828 1
zyd_openpipes(struct zyd_softc *sc)
d830 5
a834 3
	usbd_status err;
	int isize;
	usb_endpoint_descriptor_t *edesc;
d836 6
a841 3
	/* Interrupt in */
	edesc = usbd_interface2endpoint_descriptor(sc->zyd_iface,
	    ZYD_ENDPT_IIN);
d843 8
a850 1
	isize = UGETW(edesc->wMaxPacketSize);
d852 4
a855 2
	if (isize == 0)	/* shouldn't happen */
		return (EINVAL);
d857 2
a858 13
	sc->ibuf = malloc(isize, M_USBDEV, M_WAITOK);
			
	if (clalloc(&sc->q_reply, 1024, 0) == -1)
		return (ENOMEM);

	err = usbd_open_pipe_intr(sc->zyd_iface, sc->zyd_ed[ZYD_ENDPT_IIN],
	    USBD_SHORT_XFER_OK, &sc->zyd_ep[ZYD_ENDPT_IIN],
	    sc, sc->ibuf, isize, zydintr, USBD_DEFAULT_INTERVAL);
	if (err) {
		printf("%s: open intr pipe failed: %s\n",
		    USBDEVNAME(sc->zyd_dev), usbd_errstr(err));
		goto fail;
	}
d860 2
a861 5
	/* Interrupt out (not neccessary really an interrupt pipe) */
	err = usbd_open_pipe(sc->zyd_iface, sc->zyd_ed[ZYD_ENDPT_IOUT],
	    0, &sc->zyd_ep[ZYD_ENDPT_IOUT]);
	if (err)
		goto fail;
d863 7
a869 8
	/* Bulk in */
	err = usbd_open_pipe(sc->zyd_iface, sc->zyd_ed[ZYD_ENDPT_BIN],
	    0, &sc->zyd_ep[ZYD_ENDPT_BIN]);
	if (err) {
		printf("%s: open rx pipe failed: %s\n",
		    USBDEVNAME(sc->zyd_dev), usbd_errstr(err));
		goto fail;
	}
d871 2
a872 8
	/* Bulk out */
	err = usbd_open_pipe(sc->zyd_iface, sc->zyd_ed[ZYD_ENDPT_BOUT],
	    0, &sc->zyd_ep[ZYD_ENDPT_BOUT]);
	if (err) {
		printf("%s: open tx pipe failed: %s\n",
		    USBDEVNAME(sc->zyd_dev), usbd_errstr(err));
		goto fail;
	}
a874 4

fail:	free(sc->ibuf, M_USBDEV);
	clfree(&sc->q_reply);
	return (EIO);
d878 1
a878 1
 * Close bulk and interrupt pipes
d880 2
a881 2
void
zyd_closepipes(struct zyd_softc *sc)
d883 5
a887 1
	int i;
d889 6
a894 5
	for (i = 0; i < ZYD_ENDPT_CNT; i++)
		if (sc->zyd_ep[i]) {
			usbd_abort_pipe(sc->zyd_ep[i]);
			usbd_close_pipe(sc->zyd_ep[i]);
		}
d896 4
a899 6
	ndflush(&sc->q_reply, sc->q_reply.c_cc);
	clfree(&sc->q_reply);

	if (sc->ibuf) {
		free(sc->ibuf, M_USBDEV);
		sc->ibuf = NULL;
d901 2
a904 3
/*
 * Allocate TX list
 */
d906 1
a906 1
zyd_alloc_tx(struct zyd_softc *sc)
d908 1
a908 2
	struct zyd_tx_data *data;
	int i, error;
d910 2
a911 1
	sc->tx_queued = 0;
d913 2
a914 4
	for (i = 0; i < ZYD_TX_LIST_CNT; i++) {
		data = &sc->tx_data[i];
		data->sc = sc;
		data->xfer = usbd_alloc_xfer(sc->zyd_udev);
d916 11
a926 9
		if (data->xfer == NULL) {
			printf("%s: could not allocate tx xfer\n",
			    USBDEVNAME(sc->zyd_dev));
			error = ENOMEM;
			goto fail;
		}

		data->buf = usbd_alloc_buffer(data->xfer,
			ZYD_TX_DESC_SIZE + MCLBYTES);
d928 2
a929 7
		if (data->buf == NULL) {
			printf("%s: could not allocate tx buffer\n",
			    USBDEVNAME(sc->zyd_dev));
			error = ENOMEM;
			goto fail;
		}
	}
a931 4

fail:
	zyd_free_tx(sc);
	return error;
d934 2
a935 2
void
zyd_free_tx(struct zyd_softc *sc)
d937 1
a937 3
	struct ieee80211com *ic = &sc->sc_ic;
	struct zyd_tx_data *data;
	int i;
d939 1
a939 2
	for (i = 0; i < ZYD_TX_LIST_CNT; i++) {
		data = &sc->tx_data[i];
d941 20
a960 4
		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}
d962 10
a971 5
		if (data->ni != NULL) {
			ieee80211_release_node(ic, data->ni);
			data->ni = NULL;
		}
	}
d975 1
a975 1
zyd_alloc_rx(struct zyd_softc *sc)
d977 4
a980 1
	struct zyd_rx_data *data;
d983 8
a990 2
	for (i = 0; i < ZYD_RX_LIST_CNT; i++) {
		data = &sc->rx_data[i];
d992 2
a993 1
		data->sc = sc;
d995 2
a996 1
		data->xfer = usbd_alloc_xfer(sc->zyd_udev);
d998 6
a1003 4
		if (data->xfer == NULL) {
			printf("%s: could not allocate rx xfer\n",
			    USBDEVNAME(sc->zyd_dev));
			error = ENOMEM;
d1005 2
a1006 1
		}
d1008 5
a1012 4
		if (usbd_alloc_buffer(data->xfer, MCLBYTES) == NULL) {
			printf("%s: could not allocate rx buffer\n",
			    USBDEVNAME(sc->zyd_dev));
			error = ENOMEM;
d1014 1
a1014 1
		}
d1016 9
a1024 1
		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
d1026 3
a1028 6
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    USBDEVNAME(sc->zyd_dev));
			error = ENOMEM;
			goto fail;
		}
d1030 3
a1032 1
		MCLGET(data->m, M_DONTWAIT);
d1034 7
a1040 6
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate rx mbuf cluster\n",
			    USBDEVNAME(sc->zyd_dev));
			error = ENOMEM;
			goto fail;
		}
d1042 44
a1085 1
		data->buf = mtod(data->m, uint8_t *);
d1087 13
d1102 6
d1109 7
a1115 3
fail:
	zyd_free_tx(sc);
	return error;
d1118 2
a1119 2
void
zyd_free_rx(struct zyd_softc *sc)
d1121 6
a1126 2
	struct zyd_rx_data *data;
	int i;
d1128 2
a1129 2
	for (i = 0; i < ZYD_RX_LIST_CNT; i++) {
		data = &sc->rx_data[i];
d1131 4
a1134 4
		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}
d1136 14
a1149 4
		if (data->m != NULL) {
			m_freem(data->m);
			data->m = NULL;
		}
d1151 1
a1153 3
/*
 * Fetch and print state flags of zydas
 */
d1155 1
a1155 1
zyd_stateoutput(struct zyd_softc *sc)
d1157 3
a1159 1
	uint32_t debug;
d1161 3
a1163 1
	DPRINTF(("In zyd_stateoutput()\n"));
d1165 1
a1165 3
	debug = 0;
	zyd_read32(sc, ZYD_REG_CTL(0x6D4), &debug);
	DPRINTF(("DEBUG: Tx complete: %x\n", debug));
d1167 1
a1167 3
	debug = 0;
	zyd_read32(sc, ZYD_REG_CTL(0x6F4), &debug);
	DPRINTF(("DEBUG: Tx total packet: %x\n", debug));
d1169 3
a1171 3
	debug = 0;
	zyd_read32(sc, ZYD_REG_CTL(0x69C), &debug);
	DPRINTF(("DEBUG: Rx timeout count: %x\n", debug));
d1173 2
a1174 3
	debug = 0;
	zyd_read32(sc, ZYD_REG_CTL(0x6A0), &debug);
	DPRINTF(("DEBUG: Rx total frame count: %x\n", debug));
d1176 7
a1182 3
	debug = 0;
	zyd_read32(sc, ZYD_REG_CTL(0x6A4), &debug);
	DPRINTF(("DEBUG: Rx CRC32: %x\n", debug));
d1184 2
a1185 3
	debug = 0;
	zyd_read32(sc, ZYD_REG_CTL(0x6A8), &debug);
	DPRINTF(("DEBUG: Rx CRC16: %x\n", debug));
d1187 9
a1195 3
	debug = 0;
	zyd_read32(sc, ZYD_REG_CTL(0x6AC), &debug);
	DPRINTF(("DEBUG: Rx unicast decr error: %x\n", debug));
d1197 9
a1205 3
	debug = 0;
	zyd_read32(sc, ZYD_REG_CTL(0x6B0), &debug);
	DPRINTF(("DEBUG: Rx FIFO overrun: %x\n", debug));
d1207 3
a1209 3
	debug = 0;
	zyd_read32(sc, ZYD_REG_CTL(0x6BC), &debug);
	DPRINTF(("DEBUG: Rx multicast decr error: %x\n", debug));
a1211 3
/*
 * EOF handler for TX transfer
 */
d1213 1
a1213 1
zyd_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1215 3
a1217 7
	struct zyd_tx_data *data = priv;
	struct zyd_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	DPRINTF(("%s: Entering zyd_txeof()\n", USBDEVNAME(sc->zyd_dev)));
d1223 4
a1226 7
		printf("%s: could not transmit buffer: %s\n",
		    USBDEVNAME(sc->zyd_dev), usbd_errstr(status));

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->zyd_ep[ZYD_ENDPT_BOUT]);

		ifp->if_oerrors++;
d1230 1
a1230 1
	s = splnet();
d1232 11
a1242 4
	m_freem(data->m);
	data->m = NULL;
	ieee80211_release_node(ic, data->ni);
	data->ni = NULL;
d1244 26
a1269 2
	sc->tx_queued--;
	ifp->if_opackets++;
d1271 1
a1271 3
	sc->tx_timer = 0;
	ifp->if_flags &= ~IFF_OACTIVE;
/*	zyd_start(ifp);*/
d1273 4
a1276 1
	splx(s);
a1278 6
/*
 * RX frame processor.
 *
 * Needed because rxeof might fetch multiple frames
 * inside a single USB transfer.
 */
d1280 1
a1280 1
zyd_rxframeproc(struct zyd_rx_data *data, uint8_t *buf, uint16_t len)
a1281 1
	struct zyd_softc *sc = data->sc;
a1283 2
	struct ieee80211_frame *wh;
	struct zyd_rxstatusreport *desc;
d1285 3
d1289 1
a1289 3
	uint8_t *useptr;
	int s;
	int optype;
d1291 3
a1293 3
	/* Too small for at least an RX status report? */
	if (len < ZYD_RX_DESC_SIZE) {
		printf("%s: xfer too short %d\n", USBDEVNAME(sc->zyd_dev), len);
d1295 1
a1295 1
		goto skip;
d1298 7
a1304 20
	/* An RX status report is appended */
	desc = (struct zyd_rxstatusreport *)(buf + len - ZYD_RX_DESC_SIZE);

	/*
	 * TODO: Signal strength and quality have to be calculated in
	 * conjunction with the PLCP header! The printed values are RAW!
	 */

	/* Print RX debug info */
	DPRINTFN(3, ("Rx status: signalstrength = %d, signalqualitycck = %d, "
	    "signalqualityofdm = %d, decryptiontype = %d, "
	    "modulationtype = %d, rxerrorreason = %d, errorindication = %d\n",
	    desc->signalstrength, desc->signalqualitycck, desc->signalqualityofdm,
	    desc->decryptiontype, desc->modulationtype, desc->rxerrorreason,
	    desc->errorindication));

	/* Bad frame? */
	if (desc->errorindication) {
		DPRINTF(("%s: RX status indicated error\n",
		    USBDEVNAME(sc->zyd_dev)));
d1306 1
a1306 1
		goto skip;
d1309 5
a1313 1
	/* Setup a new mbuf for this */
a1314 1

d1317 2
a1318 1
		    USBDEVNAME(sc->zyd_dev));
d1321 9
a1329 9

	MCLGET(m, M_DONTWAIT);

	if (!(m->m_flags & M_EXT)) {
		printf("%s: could not allocate rx mbuf cluster\n",
		    USBDEVNAME(sc->zyd_dev));
		m_freem(m);
		m = NULL;
		return;
a1330 4

	useptr = mtod(m, uint8_t *);
	memcpy(useptr, buf, len);

d1332 2
a1333 4
	m->m_pkthdr.len = m->m_len = len - ZYD_RX_DESC_SIZE;
	m->m_flags |= M_HASFCS; /* hardware appends FCS */

	s = splnet();
d1339 5
d1348 2
a1349 2
		tap->wr_rssi = desc->signalstrength;
		tap->wr_max_rssi = 0;	/* XXX */
d1360 2
a1361 1
	wh = mtod(m, struct ieee80211_frame *);
d1363 3
a1365 1
	ieee80211_input(ifp, m, ni, desc->signalstrength, 0);
a1367 2
	DPRINTFN(3, ("iee80211_input() -> %d\n", optype));

a1368 3

skip:
	;
a1370 3
/*
 * EOF handler for RX transfer
 */
d1378 1
a1379 3
	struct zyd_rxleninfoapp *leninfoapp;
/*	int i;
	uint16_t tfs;*/
a1389 1

d1392 3
a1394 14
#ifdef ZYD_DEBUG
	if (zyddebug > 10) {
		printf("zyd_rxeof: Len = %d, raw dump follows\n", len);
		bindump(data->buf, len);
	}
#endif

	/*
	 * It must be at least 4 bytes - still broken if it is
	 * 4 bytes, but that's enough to hold the multi-frame
	 * append header
	 */
	if (len < sizeof(struct zyd_rxleninfoapp)) {
		printf("%s: xfer too short %d\n", USBDEVNAME(sc->zyd_dev), len);
d1399 2
a1400 3
	/* See whether this is a multi-frame tansmission */
	leninfoapp = (struct zyd_rxleninfoapp *)
		(data->buf + len - sizeof(struct zyd_rxleninfoapp));
d1402 3
a1404 3
	if (UGETW(leninfoapp->marker) == ZYD_MULTIFRAME_MARKER) {
		/* Multiframe received */
		DPRINTFN(3, ("Received multi-frame transmission\n"));
d1406 1
a1406 1
		/* TODO: Support 'em properly */
d1408 2
a1409 2
		/* Append PLCP header size */
/*		tfs = ZYD_PLCP_HDR_SIZE;
d1411 2
a1412 8
		for (i = 0; i < 3; ++i) {
			uint16_t tfl = UGETW(leninfoapp->len[i]);

			zyd_rxframeproc(data, data->buf + tfs, tfl);
			tfs += tfl;
		}*/

		goto skip;
d1414 4
d1419 1
a1419 13
		DPRINTFN(3, ("Received single-frame transmission\n"));
		zyd_rxframeproc(data, data->buf + ZYD_PLCP_HDR_SIZE,
		    len - ZYD_PLCP_HDR_SIZE);
	}

	/* Reestablish the buf for the next round */
	MGETHDR(data->m, M_DONTWAIT, MT_DATA);

	if (data->m == NULL) {
		printf("%s: could not allocate rx mbuf\n",
		    USBDEVNAME(sc->zyd_dev));
		return;
	}
d1421 1
a1421 8
	MCLGET(data->m, M_DONTWAIT);

	if (!(data->m->m_flags & M_EXT)) {
		printf("%s: could not allocate rx mbuf cluster\n",
		    USBDEVNAME(sc->zyd_dev));
		m_freem(data->m);
		data->m = NULL;
		return;
a1423 2
	data->buf = mtod(data->m, uint8_t *);

d1425 4
a1428 3
	usbd_setup_xfer(xfer, sc->zyd_ep[ZYD_ENDPT_BIN], data, data->buf,
	    MCLBYTES, USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, zyd_rxeof);
	usbd_transfer(xfer);
d1432 1
a1432 1
zyd_attachhook(void *xsc)
d1434 5
a1438 1
	struct zyd_softc *sc = xsc;
d1440 3
a1442 2
	if (zyd_uploadfirmware(sc))
		USB_ATTACH_ERROR_RETURN;
d1444 2
a1445 2
	/* Perform a device reset */
	zyd_reset(sc);
d1447 6
a1452 95
	/* Complete the attach process (hardware init) */
	if (zyd_complete_attach(sc) != 0)
		USB_ATTACH_ERROR_RETURN;
	sc->zyd_attached = 1;
}

/*
 * Upload firmware to device.
 *
 * Returns nozero on error.
 *
 * The whole upload procedure was implemented accordingly to
 * what ZyDAS' Linux driver does. It does however *NOT* match
 * what their documentation says (argh...)!
 */
int
zyd_uploadfirmware(struct zyd_softc *sc)
{
	/* ZD1211 uses a proprietary "setup" command to upload the fw */
	struct zyd_control zc;
	uint8_t stsresult;
	int result;
	size_t imgsize;
	u_char *imgptr, *imgptr0;

	memset(&zc, 0, sizeof(struct zyd_control));
	zc.type = ZYD_FIRMDOWN_REQ;
	zc.id = ZYD_FIRMDOWN_ID;
	zc.value = ZYD_FIRMWARE_START_ADDR; /* TODO: Different on old ones! */

	result = loadfirmware("zd1211", &imgptr0, &imgsize);

	if (result) {
		printf("%s: failed loadfirmware of file %s: errno %d\n",
		    USBDEVNAME(sc->zyd_dev), "zd1211", result);

		return -1;
	}

	imgptr = imgptr0;

	DPRINTF(("%s: Firmware upload: imgsize=%d\n", USBDEVNAME(sc->zyd_dev),
	    imgsize));

	/* Issue upload command(s) */
	while (imgsize > 0) {
		/* Transfer 4KB max */
		int tlen = (imgsize > 4096) ? 4096 : imgsize;

		DPRINTF(("%s: Firmware upload: tlen=%d, value=%x\n",
		    USBDEVNAME(sc->zyd_dev), tlen, zc.value));

		zc.length = tlen;
		zc.data = imgptr;

		if (zyd_usbrequestzc(sc, &zc) != USBD_NORMAL_COMPLETION) {
			printf("%s: Error: Cannot upload firmware to device\n",
			    USBDEVNAME(sc->zyd_dev));

			result = -1;
			goto cleanup;
		};

		imgsize -= tlen;
		imgptr += tlen;

		zc.value += (uint16_t)(tlen / 2); /* Requires word */
	};

	/* See whether the upload succeeded */
	memset(&zc, 0, sizeof(struct zyd_control));
	zc.type = ZYD_FIRMSTAT_REQ;
	zc.id = ZYD_FIRMSTAT_ID;
	zc.value = 0;
	zc.length = 1;
	zc.data = &stsresult;

	if (zyd_usbrequestzc(sc, &zc) != USBD_NORMAL_COMPLETION) {
		printf("%s: Error: Cannot check for proper firmware upload\n",
		    USBDEVNAME(sc->zyd_dev));

		result = -1;
		goto cleanup;
	};

	/* Firmware successfully uploaded? */
	if (stsresult == ZYD_FIRMWAREUP_FAILURE) {
		printf("%s: Error: Firmware upload failed: 0x%X\n",
		    USBDEVNAME(sc->zyd_dev), stsresult);

		result = -1;
		goto cleanup;
	} else {
		DPRINTF(("%s: Firmware successfully uploaded\n",
		    USBDEVNAME(sc->zyd_dev)));
a1454 1814
	result = 0;

cleanup:
	free(imgptr0, M_DEVBUF);

	return result;
}

/*
 * Driver OS interface
 */

/*
 * Probe for a ZD1211-containing product
 */
USB_MATCH(zyd)
{
	USB_MATCH_START(zyd, uaa);

	if (!uaa->iface)
		return (UMATCH_NONE);

	return (usb_lookup(zyd_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
}

/*
 * Attach the interface. Allocate softc structures, do
 * setup and ethernet/BPF attach.
 */
USB_ATTACH(zyd)
{
	USB_ATTACH_START(zyd, sc, uaa);
	char *devinfop;
	usbd_status err;
	usbd_device_handle dev = uaa->device;
	usb_device_descriptor_t* ddesc;

	devinfop = usbd_devinfo_alloc(dev, 0);
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->zyd_dev), devinfop);
	usbd_devinfo_free(devinfop);

	ddesc = usbd_get_device_descriptor(dev);

	if (UGETW(ddesc->bcdDevice) < ZYD_ALLOWED_DEV_VERSION) {
		printf("%s: device version mismatch: 0x%X "
		    "(only >= 43.30 supported)\n",
		    USBDEVNAME(sc->zyd_dev), UGETW(ddesc->bcdDevice));

		USB_ATTACH_ERROR_RETURN;
	}

	err = usbd_set_config_no(dev, ZYD_CONFIG_NO, 1);

	if (err) {
		printf("%s: setting config no failed\n", USBDEVNAME(sc->zyd_dev));

		USB_ATTACH_ERROR_RETURN;
	}

	err = usbd_device2interface_handle(dev, ZYD_IFACE_IDX, &sc->zyd_iface);

	if (err) {
		printf("%s: getting interface handle failed\n",
		    USBDEVNAME(sc->zyd_dev));

		USB_ATTACH_ERROR_RETURN;
	}

	sc->zyd_unit = self->dv_unit;
	sc->zyd_udev = dev;

	/* Now upload the firmware */
	if (rootvp == NULL)
		mountroothook_establish(zyd_attachhook, sc);
	else
		zyd_attachhook(sc);

	USB_ATTACH_SUCCESS_RETURN;
}

/*
 * Lock PHY registers
 */
void
zyd_lock_phy(struct zyd_softc *sc)
{
	uint32_t temp;

	zyd_read32(sc, ZYD_MAC_MISC, &temp);
	temp &= ~ZYD_UNLOCK_PHY_REGS;
	zyd_write32(sc, ZYD_MAC_MISC, temp);
}

/*
 * Unlock PHY registers
 */
void
zyd_unlock_phy(struct zyd_softc *sc)
{
	uint32_t temp;

	zyd_read32(sc, ZYD_MAC_MISC, &temp);
	temp |= ZYD_UNLOCK_PHY_REGS;
	zyd_write32(sc, ZYD_MAC_MISC, temp);
}

/*
 * Helper beacon (get)
 */
usbd_status
zyd_get_aw_pt_bi(struct zyd_softc *sc, struct zyd_aw_pt_bi *s)
{
	static uint32_t addrs[] =
	    { ZYD_CR_ATIM_WND_PERIOD, ZYD_CR_PRE_TBTT, ZYD_CR_BCN_INTERVAL };
	uint32_t values[3];
	usbd_status rv;

	rv = zyd_read32_multi(sc, addrs, values, 3);

	if (rv) {
		memset(s, 0, sizeof(*s));
	} else {
		s->atim_wnd_period = values[0];
		s->pre_tbtt = values[1];
		s->beacon_interval = values[2];
		DPRINTF(("%s: aw %u pt %u bi %u\n", USBDEVNAME(sc->zyd_dev),
		    s->atim_wnd_period, s->pre_tbtt, s->beacon_interval));
	}

	return rv;
}

/*
 * Helper beacon (set)
 */
usbd_status
zyd_set_aw_pt_bi(struct zyd_softc *sc, struct zyd_aw_pt_bi *s)
{
	static uint32_t addrs[] =
	    { ZYD_CR_ATIM_WND_PERIOD, ZYD_CR_PRE_TBTT, ZYD_CR_BCN_INTERVAL };
	uint32_t data[3];

	if (s->beacon_interval <= 5)
		s->beacon_interval = 5;

	if (s->pre_tbtt < 4 || s->pre_tbtt >= s->beacon_interval)
		s->pre_tbtt = s->beacon_interval - 1;

	if (s->atim_wnd_period >= s->pre_tbtt)
		s->atim_wnd_period = s->pre_tbtt - 1;

	data[0] = s->atim_wnd_period;
	data[1] = s->pre_tbtt;
	data[2] = s->beacon_interval;

	return zyd_write32_multi(sc, addrs, data, 3);
}

/*
 * Set beacon interval
 */
usbd_status
zyd_set_beacon_interval(struct zyd_softc *sc, uint32_t interval)
{
	struct zyd_aw_pt_bi s;
	usbd_status rv;

	rv = zyd_get_aw_pt_bi(sc, &s);

	if (rv)
		goto out;

	s.beacon_interval = interval;
	rv = zyd_set_aw_pt_bi(sc, &s);

out:
	return rv;
}

/*
 * Get RF name
 */
const char *
zyd_rf_name(uint8_t type)
{
	if (type & 0xf0)
		type = 0;

	return zyd_rfs[type];
}

/*
 * Read RF PA types
 */
usbd_status
zyd_read_rf_pa_types(struct zyd_softc *sc, uint8_t *rf_type,
	uint8_t *pa_type)
{
	uint32_t value;
	uint8_t rf, pa;
	usbd_status rv;

	rf = pa = 0;

	rv = zyd_read32(sc, ZYD_E2P_POD, &value);

	if (!rv) {
		rf = value & 0x0f;
		pa = (value >> 16) & 0x0f;
	}

	*rf_type = rf;
	*pa_type = pa;

	return rv;
}

/*
 * RF driver: Init for RFMD chip
 */
usbd_status
zyd_rf_rfmd_init(struct zyd_softc *sc, struct zyd_rf *rf)
{
	int i;
	usbd_status rv;

	DPRINTF(("%s: rf_init(): ir1 = %d, ir2 = %d\n",
	    USBDEVNAME(sc->zyd_dev),
	    (sizeof(zyd_rfmd_cr) / sizeof(struct zyd_adpairs16)),
	    (sizeof(zyd_rfmd_rf) / sizeof(uint32_t))));

	rv = zyd_write16_batch(sc, zyd_rfmd_cr, (sizeof(zyd_rfmd_cr) /
	    sizeof(struct zyd_adpairs16)));

	if (rv)
		return rv;

	for (i = 0; i < (sizeof(zyd_rfmd_rf) / sizeof(uint32_t)); i++) {
		rv = zyd_rfwrite(sc, zyd_rfmd_rf[i], ZYD_RF_RV_BITS);

		if (rv)
			break;
	}

	DPRINTF(("%s: rf_init(). rv = %d\n", USBDEVNAME(sc->zyd_dev), rv));

	return rv;
}

/*
 * RF driver: Switch radio on/off for RFMD chip
 */
usbd_status
zyd_rf_rfmd_switchradio(struct zyd_softc *sc, uint8_t onoff)
{
	static const struct zyd_adpairs16 ir_on[] = {
		ZYD_RFMD_RADIO_ON
	};

	static const struct zyd_adpairs16 ir_off[] = {
		ZYD_RFMD_RADIO_OFF
	};

	if (onoff)
		return zyd_write16_batch(sc, ir_on,
		    (sizeof(ir_on) / sizeof(struct zyd_adpairs16)));

	return zyd_write16_batch(sc, ir_off, (sizeof(ir_off) /
	    sizeof(struct zyd_adpairs16)));
}

/*
 * RF driver: Channel setting for RFMD chip
 */
usbd_status
zyd_rf_rfmd_set_channel(struct zyd_softc *sc, struct zyd_rf *rf,
	uint8_t channel)
{
	static const uint32_t rfmd_table[][2] = {
		ZYD_RFMD_CHANTABLE
	};

	const uint32_t *dp;
	int i;
	usbd_status rv;

	dp = rfmd_table[channel - 1];

	for (i = 0; i < 2; i++) {
		rv = zyd_rfwrite(sc, dp[i], ZYD_RF_RV_BITS);

		if (rv)
			break;
	}

	return rv;
}

/*
 * RF driver: Switch radio on/off for AL2230 chip
 */
usbd_status
zyd_rf_al2230_switchradio(struct zyd_softc *sc, uint8_t onoff)
{
	static const struct zyd_adpairs16 ir_on[] = {
		ZYD_AL2230_RADIO_ON
	};

	static const struct zyd_adpairs16 ir_off[] = {
		ZYD_AL2230_RADIO_OFF
	};

	if (onoff)
		return zyd_write16_batch(sc, ir_on,
		    (sizeof(ir_on) / sizeof(struct zyd_adpairs16)));

	return zyd_write16_batch(sc, ir_off, (sizeof(ir_off) /
	    sizeof(struct zyd_adpairs16)));
}

/*
 * RF driver: Init for AL2230 chip
 */
usbd_status
zyd_rf_al2230_init(struct zyd_softc *sc, struct zyd_rf *rf)
{
	int i;
	usbd_status rv;

	rv = zyd_write16_batch(sc, zyd_al2230_cr, (sizeof(zyd_al2230_cr) /
	    sizeof(struct zyd_adpairs16)));

	if (rv)
		return rv;

	for (i = 0; i < (sizeof(zyd_al2230_rf) / sizeof(uint32_t)); i++) {
		rv = zyd_rfwrite(sc, zyd_al2230_rf[i], ZYD_RF_RV_BITS);

		if (rv)
			break;
	}

	return rv;
}

/*
 * RF driver: Channel setting for AL2230 chip
 */
usbd_status
zyd_rf_al2230_set_channel(struct zyd_softc *sc, struct zyd_rf *rf,
	uint8_t channel)
{
	static const struct zyd_adpairs16 sc_cmd[] = {
		ZYD_AL2230_SETCHANNEL
	};

	static const uint32_t al2230_table[][3] = {
		ZYD_AL2230_CHANTABLE
	};
	
	usbd_status rv;
	int i;
	const uint32_t *ptr = al2230_table[channel - 1];
	
	for (i = 0; i < 3; i++) {
		rv = zyd_rfwrite(sc, *ptr, ZYD_RF_RV_BITS);
		ptr++;
		
		if (rv)
			return rv;
	}
	
	return zyd_write16_batch(sc, sc_cmd, (sizeof(sc_cmd) /
	    sizeof(struct zyd_adpairs16)));
}

/*
 * Assign drivers and init the RF
 */
usbd_status
zyd_rf_init_hw(struct zyd_softc *sc, struct zyd_rf *rf, uint8_t type)
{
	int rv;

	switch (type) {
	case ZYD_RF_RFMD:
		rf->init_hw = zyd_rf_rfmd_init;
		rf->switch_radio = zyd_rf_rfmd_switchradio;
		rf->set_channel = zyd_rf_rfmd_set_channel;
		break;

	case ZYD_RF_AL2230:
		rf->init_hw = zyd_rf_al2230_init;
		rf->switch_radio = zyd_rf_al2230_switchradio;
		rf->set_channel = zyd_rf_al2230_set_channel;
		break;

	default:
		printf("%s: Sorry, radio %s is not supported yet\n",
		    USBDEVNAME(sc->zyd_dev), zyd_rf_name(type));
		rf->type = 0;
		rv = USBD_INVAL;
		goto leave;
	}

	rf->flags = 0;
	rf->type = type;

	zyd_lock_phy(sc);
	rv = rf->init_hw(sc, rf);
	zyd_unlock_phy(sc);

leave:
	return rv;
}

/*
 * Init the hardware
 */
usbd_status
zyd_hw_init(struct zyd_softc *sc, struct ieee80211com *ic)
{
	usbd_status rv;
	int stage = 0;
	uint8_t rf;

	rv = zyd_write32(sc, ZYD_MAC_AFTER_PNP, 1);

	if (rv)
		goto leave;

	stage++;

	rv = zyd_read16(sc, ZYD_REG_USB(ZYD_FIRMWARE_BASE_ADDR),
	    &sc->firmware_base);

	DPRINTF(("%s: zyd_hw_init: firmware_base = 0x%04X\n",
	    USBDEVNAME(sc->zyd_dev), sc->firmware_base));

	/* Print the firmware version */
	rv = zyd_read16(sc, ZYD_FW_FIRMWARE_VER, &sc->fw_ver);

	if (rv)
		goto leave;

	stage++;

	rv = zyd_write32(sc, ZYD_CR_GPI_EN, 0);

	if (rv)
		goto leave;

	stage++;

	rv = zyd_write32(sc, ZYD_MAC_CONT_WIN_LIMIT, 0x007f043f);

	if (rv)
		goto leave;

	stage++;

	zyd_set_mandatory_rates(sc, ic->ic_curmode);

	zyd_disable_hwint(sc);

	/* PHY init ("reset") */
	zyd_lock_phy(sc);
	rv = zyd_write16_batch(sc, zyd_def_cr,
	    (sizeof(zyd_def_cr) / sizeof(struct zyd_adpairs16)));
	zyd_unlock_phy(sc);

	if (rv)
		goto leave;

	stage++;

	/* HMAC init */
	rv = zyd_write32_batch(sc, zyd_def_mac,
	    (sizeof(zyd_def_mac) / sizeof(struct zyd_adpairs32)));

	if (rv)
		goto leave;

	stage++;

	/* RF/PA types */
	rv = zyd_read_rf_pa_types(sc, &rf, &sc->pa_ver);

	if (rv)
		goto leave;

	stage++;

	/* Now init the RF chip */
	rv = zyd_rf_init_hw(sc, &sc->rf, rf);

	if (rv)
		goto leave;

	stage++;

	/* Init beacon to 100 * 1024 s */
	rv = zyd_set_beacon_interval(sc, 100);

	if (rv)
		goto leave;

	stage++;

leave:
	DPRINTF(("%s: zyd_hw_init: rv = %d, stage = %d\n",
	    USBDEVNAME(sc->zyd_dev), rv, stage));
	return rv;
}

/*
 * Get MAC address from EEPROM
 */
usbd_status
zyd_get_e2p_mac_addr(struct zyd_softc *sc, struct zyd_macaddr *mac_addr)
{
	uint32_t mac[2];
	usbd_status rv;

	rv = zyd_read32(sc, ZYD_E2P_MAC_ADDR_P1, &mac[0]);

	if (rv)
		goto leave;

	rv = zyd_read32(sc, ZYD_E2P_MAC_ADDR_P2, &mac[1]);

	if (rv)
		goto leave;

	mac_addr->addr[0] = mac[0];
	mac_addr->addr[1] = mac[0] >>  8;
	mac_addr->addr[2] = mac[0] >> 16;
	mac_addr->addr[3] = mac[0] >> 24;
	mac_addr->addr[4] = mac[1];
	mac_addr->addr[5] = mac[1] >>  8;

leave:
	return rv;
}

/*
 * Set MAC address (will accept ANY address)
 */
usbd_status
zyd_set_mac_addr(struct zyd_softc *sc, const struct zyd_macaddr *mac_addr)
{
	uint32_t addrs[2];
	uint32_t trans[2];

	addrs[0] = ZYD_MAC_MACADDRL;
	addrs[1] = ZYD_MAC_MACADDRH;

	trans[0] = (
	    (mac_addr->addr[3] << 24) | (mac_addr->addr[2] << 16) |
	    (mac_addr->addr[1] << 8) | (mac_addr->addr[0]));

	trans[1] = (
	    (mac_addr->addr[5] << 8) | (mac_addr->addr[4]));

	return zyd_write32_multi(sc, addrs, trans, 2);
}

/*
 * Read regdomain
 */
usbd_status
zyd_read_regdomain(struct zyd_softc *sc, uint8_t *regdomain)
{
	uint32_t value;
	usbd_status rv;

	rv = zyd_read32(sc, ZYD_E2P_SUBID, &value);

	if (!rv)
		*regdomain = value >> 16;

	return rv;
}

/*
 * Check whether a particular regdomain is supported
 */
int
zyd_regdomain_supported(uint8_t regdomain)
{
	const struct zyd_channel_range *range;

	range = &zyd_channel_ranges[0];

	for ( ; ; ) {
		if (range->regdomain == regdomain)
			return (range->start != 0);
		else if (range->regdomain == -1)
			break; /* end of list */

		range++;
	}

	return 0;
}

/*
 * Helper used by all table readers
 */
int
zyd_tblreader(struct zyd_softc *sc, uint8_t *values, size_t count,
	uint32_t e2p_addr, uint32_t guard)
{
	int r;
	int i;
	uint32_t v;

	for (i = 0;;) {
		r = zyd_read32(sc, (e2p_addr + (i / 2)), &v);

		if (r)
			return r;

		v -= guard;

		if (i+4 < count) {
			values[i++] = v;
			values[i++] = v >>  8;
			values[i++] = v >> 16;
			values[i++] = v >> 24;
			continue;
		}

		for (;i < count; i++)
			values[i] = v >> (8*(i%3));

		return 0;
	}

	return 0;
}

/*
 * Read calibration tables
 */
int
zyd_readcaltables(struct zyd_softc *sc)
{
	int rv;
	int i;

	static const uint32_t addresses[] = {
		ZYD_E2P_36M_CAL_VALUE1,
		ZYD_E2P_48M_CAL_VALUE1,
		ZYD_E2P_54M_CAL_VALUE1,
	};

	rv = zyd_tblreader(sc, sc->pwr_cal_values,
	    ZYD_E2P_CHANNEL_COUNT, ZYD_E2P_PWR_CAL_VALUE1, 0);
		
	if (rv)
		goto leave;

	rv = zyd_tblreader(sc, sc->pwr_int_values,
	    ZYD_E2P_CHANNEL_COUNT, ZYD_E2P_PWR_INT_VALUE1,	ZYD_E2P_PWR_INT_GUARD);

	if (rv)
		goto leave;

	for (i = 0; i < 3; i++) {
		rv = zyd_tblreader(sc, sc->ofdm_cal_values[i],
		    ZYD_E2P_CHANNEL_COUNT, addresses[i], 0);
		if (rv)
			goto leave;
	}

leave:
	return rv;
}

/*
 * Reset channel
 */
int
zyd_reset_channel(struct zyd_softc *sc)
{
	const struct zyd_channel_range *range;

	range = &zyd_channel_ranges[0];

	for ( ; ; ) {
		if (range->regdomain == sc->regdomain)
			if (range->start == 0)
				return 1;
			else
			{
				sc->channel = range->start;
				sc->mac_flags &= ~ZMF_FIXED_CHANNEL;
			}
		else if (range->regdomain == -1)
			return 1; /* end of list */

		range++;
	}

	return 0;
}

/*
 * Set encryption type
 */
usbd_status
zyd_set_encryption_type(struct zyd_softc *sc, uint32_t type)
{
	return zyd_write32(sc, ZYD_MAC_ENCRYPTION_TYPE, type);
}

/*
 * Switch radio on/off
 */
usbd_status
zyd_switch_radio(struct zyd_softc *sc, uint8_t onoff)
{
	usbd_status rv;

	zyd_lock_phy(sc);
	rv = sc->rf.switch_radio(sc, onoff);
	zyd_unlock_phy(sc);

	if (!rv)
		sc->zyd_radio_on = onoff;

	return rv;
}

/*
 * Enable hardware interrupt
 */
usbd_status
zyd_enable_hwint(struct zyd_softc *sc)
{
	return zyd_write32(sc, ZYD_CR_INTERRUPT, ZYD_HWINT_ENABLED);
}

/*
 * Disable hardware interrupt
 */
usbd_status
zyd_disable_hwint(struct zyd_softc *sc)
{
	return zyd_write32(sc, ZYD_CR_INTERRUPT, ZYD_HWINT_DISABLED);
}

/*
 * Set basic rates
 */
usbd_status
zyd_set_basic_rates(struct zyd_softc *sc, int mode)
{
	/* Do not request high rates for the basic set */
	uint32_t outf = 0;

	switch (mode) {
	case IEEE80211_MODE_11B:
		/* 11B: 1, 2 MBPS */
		outf = 3;
		break;

	case IEEE80211_MODE_11G:
		/* 11G: 6, 12, 24 MBPS */
		outf = (21 << 8);
		break;

	default:
		return -1;
	}

	return zyd_write32(sc, ZYD_MAC_BASICRATE, outf);
}

/*
 * Set mandatory rates. This is the full spectrum of a certain mode.
 */
usbd_status
zyd_set_mandatory_rates(struct zyd_softc *sc, int mode)
{
	uint32_t outf = 0;

	switch (mode) {
	case IEEE80211_MODE_11B:
		/* 11B: 1, 2, 5.5, 11 */
		outf = CSF_RT_CCK_1 | CSF_RT_CCK_2 | CSF_RT_CCK_5_5 | CSF_RT_CCK_11;
		break;

	case IEEE80211_MODE_11G:
		/* 11G: 6, 9, 12, 18, 24, 36, 48, 54 */
		outf = CSF_RT_OFDM_6 | CSF_RT_OFDM_9 | CSF_RT_OFDM_12 |
		    CSF_RT_OFDM_18 | CSF_RT_OFDM_24 | CSF_RT_OFDM_36 |
		    CSF_RT_OFDM_48 | CSF_RT_OFDM_54;
		break;

	default:
		return -1;
	}

	return zyd_write32(sc, ZYD_MAC_MANDATORYRATE, outf);
}

/*
 * Reset mode
 */
usbd_status
zyd_reset_mode(struct zyd_softc *sc)
{
	struct zyd_adpairs32 io[3] = {
		{ ZYD_MAC_STOHOSTSETTING, STH_BCN | STH_PRB_RSP | STH_AUTH | STH_ASS_RSP },
		{ ZYD_MAC_SNIFFER, 0U },
		{ ZYD_MAC_ENCRYPTION_TYPE, 0U }
	};
/*
	if (ieee->iw_mode == IW_MODE_MONITOR) {
		ioreqs[0].value = 0xffffffff;
		ioreqs[1].value = 0x1;
		ioreqs[2].value = ENC_SNIFFER;
	}*/

	DPRINTF(("%s: In zyd_reset_mode()\n", USBDEVNAME(sc->zyd_dev)));

	return zyd_write32_batch(sc, io, 3);
}


/*
 * Set BSSID
 */
usbd_status
zyd_set_bssid(struct zyd_softc *sc, uint8_t *addr)
{
	uint32_t addrh;
	uint32_t addrl;
	usbd_status rv;

	addrh = (*((uint32_t *)addr) >> 16);
	addrl = *((uint32_t *)(addr + 2));

	DPRINTF(("%s: Setting BSSID addrh = %x, addrl = %x\n",
	    USBDEVNAME(sc->zyd_dev), addrh, addrl));

	rv = zyd_write32(sc, ZYD_MAC_BSSADRL, addrl);

	if (!rv)
		rv = zyd_write32(sc, ZYD_MAC_BSSADRH, addrh);

	return rv;
}

/*
 * Complete the attach process
 */
usbd_status
zyd_complete_attach(struct zyd_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct zyd_macaddr mac;

	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	usbd_status rv;
	int i;

	id = usbd_get_interface_descriptor(sc->zyd_iface);

	/*
	 * Endpoint 1 = Bulk out (512b @@ high speed / 64b @@ full speed)
	 * Endpoint 2 = Bulk in  (512b @@ high speed / 64b @@ full speed)
	 * Endpoint 3 = Intr in (64b)
	 * Endpoint 4 = Intr out @@ high speed / bulk out @@ full speed (64b)
	 */
	
	DPRINTFN(10, ("A total of %d endpoints available\n", id->bNumEndpoints));
	
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->zyd_iface, i);

		if (ed == NULL) {
			printf("%s: no endpoint descriptor for iface %d\n",
			    USBDEVNAME(sc->zyd_dev), i);
			return -1;
		}

/*		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			sc->zyd_ep[ZYD_ENDPT_BIN] = ed->bEndpointAddress;
		else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			sc->sc_tx_no = ed->bEndpointAddress;*/
	}
	
	ed = usbd_interface2endpoint_descriptor(sc->zyd_iface, 0);
	sc->zyd_ed[ZYD_ENDPT_BOUT] = ed->bEndpointAddress;

	ed = usbd_interface2endpoint_descriptor(sc->zyd_iface, 1);
	sc->zyd_ed[ZYD_ENDPT_BIN] = ed->bEndpointAddress;

	ed = usbd_interface2endpoint_descriptor(sc->zyd_iface, 2);
	sc->zyd_ed[ZYD_ENDPT_IIN] = ed->bEndpointAddress;

	ed = usbd_interface2endpoint_descriptor(sc->zyd_iface, 3);
	sc->zyd_ed[ZYD_ENDPT_IOUT] = ed->bEndpointAddress;

	/* Open the pipes */
	zyd_openpipes(sc);

	/* Init hardware */
	rv = zyd_hw_init(sc, ic);

	if (rv)
		goto leave;

	/* Read MAC from EEPROM and copy to interface */
	rv = zyd_get_e2p_mac_addr(sc, &mac);
	memcpy(&sc->sc_ic.ic_myaddr, &mac, IEEE80211_ADDR_LEN);

	printf("%s: Firmware 0x%04X, Radio %s, PA %#01x, address %s\n",
	    USBDEVNAME(sc->zyd_dev), sc->fw_ver, zyd_rf_name(sc->rf.type),
	    sc->pa_ver, ether_sprintf(ic->ic_myaddr));

	if (rv)
		goto leave;

	/* Read calibration tables from EEPROM */
	rv = zyd_readcaltables(sc);

	if (rv)
		goto leave;

	DPRINTF(("%s: Loading regdomain\n", USBDEVNAME(sc->zyd_dev)));
	/* Load the regdomain and see whether it is supported */
	rv = zyd_read_regdomain(sc, &sc->default_regdomain);

	if (rv)
		goto leave;

	if (!zyd_regdomain_supported(sc->default_regdomain)) {
		printf("%s: Error: Regulatory Domain %#04x is not supported.",
		    USBDEVNAME(sc->zyd_dev), sc->default_regdomain);
			
		rv = USBD_INVAL;
		goto leave;
	}

	sc->regdomain = sc->default_regdomain;

	sc->zyd_encrypt = ENC_NOWEP;
	sc->zyd_wepkeylen = 0;
	sc->zyd_wepkey = 0;

	bzero(sc->zyd_bssid, ETHER_ADDR_LEN);
	sc->zyd_ssidlen = strlen(ZYD_DEFAULT_SSID);
	memcpy(sc->zyd_ssid, ZYD_DEFAULT_SSID, sc->zyd_ssidlen);

	/* TODO: Is this an allowed channel in the domain? */
	sc->channel = ZYD_DEFAULT_CHANNEL;
	sc->zyd_desired_channel = IEEE80211_CHAN_ANY;
	sc->zyd_operation = OM_INFRASTRUCTURE;

	/* Network interface setup */
	ic->ic_softc = sc;
	ic->ic_phytype = IEEE80211_T_OFDM;
	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_state = IEEE80211_S_INIT;

	/* Set device capabilities */
	ic->ic_caps = IEEE80211_C_MONITOR | IEEE80211_C_IBSS |
	    IEEE80211_C_HOSTAP | IEEE80211_C_SHPREAMBLE | IEEE80211_C_PMGT |
	    IEEE80211_C_TXPMGT | IEEE80211_C_WEP;

	/* Rates are in 0,5 MBps units */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = zyd_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = zyd_rateset_11g;

	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	ifp->if_softc = sc;
	memcpy(ifp->if_xname, USBDEVNAME(sc->zyd_dev), IFNAMSIZ);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_init = zyd_init;
	ifp->if_start = zyd_start;
	ifp->if_ioctl = zyd_ioctl;
	ifp->if_watchdog = zyd_watchdog;
	ifp->if_mtu = ZYD_DEFAULT_MTU;
	IFQ_SET_READY(&ifp->if_snd);

	/* Call MI attach routine. */
	if_attach(ifp);
	ieee80211_ifattach(ifp);

	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = zyd_newstate;

	/* setup ifmedia interface */
	ieee80211_media_init(ifp, zyd_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + 64);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(ZYD_RX_RADIOTAP_PRESENT);
	
	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(ZYD_TX_RADIOTAP_PRESENT);
#endif

	usb_init_task(&sc->sc_task, zyd_task, sc);

/*	ieee80211_announce(ic);*/

	timeout_set(&sc->scan_ch, zyd_next_scan, sc);
	timeout_add(&sc->scan_ch, hz);

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->zyd_udev,
	    USBDEV(sc->zyd_dev));

leave:
	DPRINTF(("%s: EXITING complete_attach(): Status = %d\n",
	    USBDEVNAME(sc->zyd_dev), rv));
	return rv;
}

/*
 * Detach device
 */
USB_DETACH(zyd)
{
	USB_DETACH_START(zyd, sc);
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	s = splusb();

/*	zyd_stop(ifp, 1);*/

	usb_rem_task(sc->zyd_udev, &sc->sc_task);

	timeout_del(&sc->scan_ch);

	zyd_closepipes(sc);

	zyd_free_rx(sc);
	zyd_free_tx(sc);

	if (sc->zyd_attached) {
		ieee80211_ifdetach(ifp);
		if_detach(ifp);
	}
	sc->zyd_attached = 0;

	splx(s);

	return 0;
}

int
zyd_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);

	if (error != ENETRESET)
		return error;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		zyd_init(ifp);

	return 0;
}

int
zyd_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct zyd_softc *sc = ic->ic_if.if_softc;

	DPRINTF(("%s: zyd_newstate(): %d\n", USBDEVNAME(sc->zyd_dev), nstate));

	usb_rem_task(sc->zyd_udev, &sc->sc_task);

	timeout_del(&sc->scan_ch);

	/* do it in a process context */
	sc->sc_state = nstate;
	usb_add_task(sc->zyd_udev, &sc->sc_task);

	return 0;
}

/*
 * Initial configuration
 *
 * - Copy MAC address
 * - Init channel (to first in allowed range)
 * - Set encryption type
 */
int
zyd_initial_config(struct zyd_softc *sc)
{
/*	struct ieee80211com *ic = &sc->sc_ic;*/
/*	uint32_t i;*/
	usbd_status rv;

	rv = zyd_set_mac_addr(sc, (const struct zyd_macaddr *)&sc->sc_ic.ic_myaddr);

	if (rv)
		return rv;

/*	DPRINTF(("Reset channel\n"));
	if (zyd_reset_channel(sc) != 0) {
		return USBD_INVAL;
	}*/

	rv = zyd_set_encryption_type(sc, sc->zyd_encrypt);

	if (rv)
		return rv;

	/* TODO: Check what we've already initialized in the hw_init section */

	DPRINTFN(10, ("%s: completed initial config\n",
	   USBDEVNAME(sc->zyd_dev)));
	return 0;
}


void
zyd_update_promisc(struct zyd_softc *sc)
{
}

/*
 * Compute the duration (in us) needed to transmit `len' bytes at rate `rate'.
 * The function automatically determines the operating mode depending on the
 * given rate. `flags' indicates whether short preamble is in use or not.
 */
uint16_t
zyd_txtime(int len, int rate, uint32_t flags)
{
	uint16_t txtime;
	int ceil, dbps;

	if (ZYD_RATE_IS_OFDM(rate)) {
		/*
		 * OFDM TXTIME calculation.
		 * From IEEE Std 802.11a-1999, pp. 37.
		 */
		dbps = rate * 2; /* data bits per OFDM symbol */

		ceil = (16 + 8 * len + 6) / dbps;

		if ((16 + 8 * len + 6) % dbps != 0)
			ceil++;

		txtime = 16 + 4 + 4 * ceil + 6;
	} else {
		/*
		 * High Rate TXTIME calculation.
		 * From IEEE Std 802.11b-1999, pp. 28.
		 */
		ceil = (8 * len * 2) / rate;

		if ((8 * len * 2) % rate != 0)
			ceil++;

		if (rate != 2 && (flags & IEEE80211_F_SHPREAMBLE))
			txtime =  72 + 24 + ceil;
		else
			txtime = 144 + 48 + ceil;
	}

	return txtime;
}

/*
 * Rate-to-bit-converter (Field "rate" in zyd_controlsetformat)
 */
uint8_t
zyd_plcp_signal(int rate)
{
	switch (rate) {
	/* CCK rates */
	case 2:		return 0x0;
	case 4:		return 0x1;
	case 11:	return 0x2;
	case 22:	return 0x3;

	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
	case 12:	return 0xb;
	case 18:	return 0xf;
	case 24:	return 0xa;
	case 36:	return 0xe;
	case 48:	return 0x9;
	case 72:	return 0xd;
	case 96:	return 0x8;
	case 108:	return 0xc;

	/* unsupported rates (should not get there) */
	default:	return 0xff;
	}
}
/*
int
zyd_calc_useclen2(uint8_t *service, uint8_t cs_rate, uint16_t tx_length)
{
	static const uint8_t rate_divisor[] = {
		[ZD_CS_CCK_RATE_1M]	=  1,
		[ZD_CS_CCK_RATE_2M]	=  2,
		[ZD_CS_CCK_RATE_5_5M]	= 11, // bits must be doubled
		[ZD_CS_CCK_RATE_11M]	= 11,
		[ZD_OFDM_RATE_6M]	=  6,
		[ZD_OFDM_RATE_9M]	=  9,
		[ZD_OFDM_RATE_12M]	= 12,
		[ZD_OFDM_RATE_18M]	= 18,
		[ZD_OFDM_RATE_24M]	= 24,
		[ZD_OFDM_RATE_36M]	= 36,
		[ZD_OFDM_RATE_48M]	= 48,
		[ZD_OFDM_RATE_54M]	= 54,
	};

	uint32_t bits = (uint32_t)tx_length * 8;
	uint32_t divisor;

	divisor = rate_divisor[cs_rate];
	if (divisor == 0)
		return -EINVAL;

	switch (cs_rate) {
	case ZD_CS_CCK_RATE_5_5M:
		bits = (2*bits) + 10; // round up to the next integer
		break;
	case ZD_CS_CCK_RATE_11M:
		if (service) {
			uint32_t t = bits % 11;
			*service &= ~ZD_PLCP_SERVICE_LENGTH_EXTENSION;
			if (0 < t && t <= 3) {
				*service |= ZD_PLCP_SERVICE_LENGTH_EXTENSION;
			}
		}
		bits += 10; // round up to the next integer
		break;
	}

	return bits/divisor;
}

enum {
	R2M_SHORT_PREAMBLE = 0x01,
	R2M_11A		   = 0x02,
};
*/

/*
 * Calculate frame transmit length in microseconds
 */
uint16_t
zyd_calc_useclen(int rate, uint16_t len, uint8_t *service)
{
	uint32_t remainder;
	uint32_t delta;
	uint16_t leninus;

	leninus = 0;
	*(service) = 0;

	switch (rate) {
	case 2:	/* 1M bps */
		leninus = len << 3;
		break;

	case 4:	/* 2M bps */
		leninus = len << 2;
		break;

	case 11: /* 5.5M bps */
		leninus = (uint16_t)(((uint32_t)len << 4) / 11);
		remainder = (((uint32_t)len << 4) % 11);

		if (remainder)
			leninus += 1;
		break;

	case 22: /* 11M bps */
		leninus = (uint16_t)(((uint32_t)len << 3) / 11);
		remainder = (((uint32_t)len << 3) % 11);
		delta = 11 - remainder;

		if (remainder) {
			leninus += 1;
			if (delta >= 8)
				*(service) |= 0x80; /* Bit 7 */
		}
		break;

	case 12:/* 6M */
		leninus = (uint16_t)(((uint32_t)len << 3) / 6);
		break;

	case 18:/* 9M */
		leninus = (uint16_t)(((uint32_t)len << 3) / 9);
		break;

	case 24:/* 12M */
		leninus = (uint16_t)(((uint32_t)len << 3) / 12);
		break;

	case 36:/* 18M */
		leninus = (uint16_t)(((uint32_t)len << 3) / 18);
		break;

	case 48:/* 24M */
		leninus = (uint16_t)(((uint32_t)len << 3) / 24);
		break;

	case 72:/* 36M */
		leninus = (uint16_t)(((uint32_t)len << 3) / 36);
		break;

	case 96:/* 48M */
		leninus = (uint16_t)(((uint32_t)len << 3) / 48);
		break;

	case 108: /* 54M */
		leninus = (uint16_t)(((uint32_t)len << 3) / 54);
		break;
	}

	return leninus;
}

/*
 * Setup the controlsetformat structure
 */
void
zyd_setup_tx_desc(struct zyd_softc *sc, struct zyd_controlsetformat *desc,
	struct mbuf *m, int len, int rate)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_frame *wh = mtod(m, struct ieee80211_frame *);
	u_int8_t more_frag = wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG;
	uint8_t type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;
	uint8_t subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;
	uint16_t txlen;

	DPRINTF(("%s: Entering zyd_setup_tx_desc()\n",
	    USBDEVNAME(sc->zyd_dev)));
	DPRINTF(("%s: sizeof (zyd_controlsetformat) = %d\n",
	    USBDEVNAME(sc->zyd_dev), sizeof(struct zyd_controlsetformat)));

	memset(desc, 0, ZYD_TX_DESC_SIZE);

	/* Rate (CCK and OFDM) */
	desc->rate = zyd_plcp_signal(rate);

	/* Modulation type (CCK/OFDM) */
	if (ZYD_RATE_IS_OFDM(rate))
		desc->modulationtype = CSF_MT_OFDM;
	else
		desc->modulationtype = CSF_MT_CCK;

	/* Preamble/a/g (depending on modtype) */
	if (desc->modulationtype == CSF_MT_CCK) {
		if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
			desc->preamble = CSF_PM_CCK_SHORT;
	}

	// DEBUG!
	desc->preamble = 0;

	/*
	 * Transmit frame length in bytes:
	 * 802.11 MAC header length + raw data length
	 * + ICV/(MIC) length + FCS length.
	 */
	txlen = len; /* + 4;*/
	desc->txlen = htole16(txlen);

	/*
	 * If no more fragments, enable backoff protection,
	 * 80211-1999 p. 77
	 */
	if (!more_frag)
		desc->needbackoff = CSF_BO_RAND;

	/* Multicast */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1))
		desc->multicast = CSF_MC_MULTICAST;

	/* Frame type */
	switch (type) {
	case IEEE80211_FC0_TYPE_DATA:
		desc->frametype = CSF_FT_DATAFRAME;
		break;

	case IEEE80211_FC0_TYPE_MGT:
		desc->frametype = CSF_FT_MGMTFRAME;
		break;

	case IEEE80211_FC0_TYPE_CTL:
		/* Only subtype PS_POLL has seq control */
		if (subtype == IEEE80211_FC0_SUBTYPE_PS_POLL)
			desc->frametype = CSF_FT_POLLFRAME;
		else
			desc->frametype = CSF_FT_NOSEQCONTROL;
		break;

	/* All other don't have a sequence control field */
	default:
		desc->frametype = CSF_FT_NOSEQCONTROL;
	}

	/* Wake dst. ignored */

	/*
	 * RTS/CTS
	 * If the frame is non-multicast, non-mgt, set "RTS" if
	 * fragment size > RTS threshold in CCK mode. In OFDM, set
	 * self cts instead.
	 */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)
		&& (type != IEEE80211_FC0_TYPE_MGT)
		&& (txlen > ic->ic_rtsthreshold)) {

		if (ZYD_RATE_IS_OFDM(rate))
			desc->selfcts = CSF_SC_SCFRAME;
		else
			desc->rts = CSF_RTS_NEEDRTSFRAME;
	}

	/* Encryption */

	/*
	 * TODO: Hmm ... only set this if hardware performs
	 * encryption. Does it???
	 */	

	/* Self cts */
/*	if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
		desc->selfcts = CSF_SC_SCFRAME;*/

	/* Packet length */
	/* DEBUG: appendet 25... */
	desc->packetlength = htole16(len + 25);
/*	desc->packetlength = (ZYD_TX_DESC_SIZE + len + 1) & ~1; */

	/* Service (PLCP) */
	desc->service = 0;

	/* Current length (usec) */
	desc->currentlength = htole16(
		zyd_calc_useclen(rate, txlen, &desc->service));

	/* Next frame length (usec) */
	if (more_frag)
		desc->nextframelen = desc->currentlength; // DEBUG!

	DPRINTF(("desc: rate=%d, modulationtype=%d, preamble=%d, "
	    "txlen=%d, needbackoff=%d, multicast=%d, frametype=%d, "
	    "wakedst=%d, rts=%d, encryption=%d, selfcts=%d, "
	    "packetlength=%d, currentlength=%d, service=%d, nextframelen=%d\n",
	    desc->rate, desc->modulationtype, desc->preamble,
	    desc->txlen, desc->needbackoff, desc->multicast, desc->frametype,
	    desc->wakedst, desc->rts, desc->encryption, desc->selfcts,
	    desc->packetlength, desc->currentlength, desc->service,
	    desc->nextframelen));
}

void dump_fw_registers(struct zyd_softc *);

void
dump_fw_registers(struct zyd_softc *sc)
{
	static const uint32_t addr[4] = {
		ZYD_FW_FIRMWARE_VER,
		ZYD_FW_USB_SPEED,
		ZYD_FW_FIX_TX_RATE,
		ZYD_FW_LINK_STATUS
	};

/*	int rv, i;*/
	int i;
	uint16_t values[4];

	for (i = 0; i < 4; ++i)
		zyd_read16(sc, addr[i], &values[i]);

	DPRINTF(("FW_FIRMWARE_VER %#06hx\n", values[0]));
	DPRINTF(("FW_USB_SPEED %#06hx\n", values[1]));
	DPRINTF(("FW_FIX_TX_RATE %#06hx\n", values[2]));
	DPRINTF(("FW_LINK_STATUS %#06hx\n", values[3]));
}


int
zyd_tx_mgt(struct zyd_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct zyd_controlsetformat *desc;
	struct zyd_tx_data *data;
	struct ieee80211_frame *wh;
	uint16_t dur;
	usbd_status error;
	int xferlen, rate;

	DPRINTF(("%s: Entering zyd_tx_mgt()\n", USBDEVNAME(sc->zyd_dev)));

/*	dump_fw_registers(sc);*/

	data = &sc->tx_data[0];
	desc = (struct zyd_controlsetformat *)data->buf;

	rate = IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan) ? 12 : 2;

	data->m = m0;
	data->ni = ni;

	wh = mtod(m0, struct ieee80211_frame *);

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		dur = zyd_txtime(ZYD_ACK_SIZE, rate, ic->ic_flags) + ZYD_SIFS;
		*(uint16_t *)wh->i_dur = htole16(dur);

/*		// tell hardware to add timestamp for probe responses
		if ((wh->i_fc[0] &
			(IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
			(IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
			flags |= RAL_TX_TIMESTAMP;*/
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct zyd_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		
		M_DUP_PKTHDR(&mb, m0);
		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_pkthdr.len += mb.m_len;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	m_copydata(m0, 0, m0->m_pkthdr.len, data->buf + ZYD_TX_DESC_SIZE);

#ifdef ZYD_DEBUG
	if (zyddebug >= 3) {
		printf("%s: Raw dump before desc setup:\n",
		    USBDEVNAME(sc->zyd_dev));
		bindump(data->buf, xferlen);
	}
#endif

	zyd_setup_tx_desc(sc, desc, m0, m0->m_pkthdr.len, rate);

	/* xfer length needs to be a multiple of two! */
	xferlen = (ZYD_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;

	/* Make sure padding is 0x00 */
	if (xferlen != (ZYD_TX_DESC_SIZE + m0->m_pkthdr.len))
		*(data->buf + xferlen - 1) = 0x00;

	DPRINTF(("%s: sending mgt frame len=%u rate=%u xfer len=%u\n",
	    USBDEVNAME(sc->zyd_dev), m0->m_pkthdr.len, rate, xferlen));

#ifdef ZYD_DEBUG
	if (zyddebug >= 3) {
		printf("%s: Raw send data output:\n", USBDEVNAME(sc->zyd_dev));
		bindump(data->buf, xferlen);
	}
#endif

	usbd_setup_xfer(data->xfer, sc->zyd_ep[ZYD_ENDPT_BOUT], data,
	    data->buf, xferlen, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    ZYD_TX_TIMEOUT, zyd_txeof);

	error = usbd_transfer(data->xfer);

	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS) {
		DPRINTF(("%s: zyd_tx_mgt(): Error %d\n",
		    USBDEVNAME(sc->zyd_dev), error));
		m_freem(m0);
		return error;
	}

	sc->tx_queued++;

/*	zyd_stateoutput(sc);*/

	return 0;
}

int
zyd_tx_data(struct zyd_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
/*	struct ifnet *ifp = &ic->ic_if;*/
	struct ieee80211_rateset *rs;
	struct zyd_controlsetformat *desc;
	struct zyd_tx_data *data;
	struct ieee80211_frame *wh;
/*	uint16_t dur;*/
	usbd_status error;
	int xferlen, rate;

	/* XXX this should be reworked! */
	if (ic->ic_fixed_rate != -1) {
		if (ic->ic_curmode != IEEE80211_MODE_AUTO)
			rs = &ic->ic_sup_rates[ic->ic_curmode];
		else
			rs = &ic->ic_sup_rates[IEEE80211_MODE_11G];

		rate = rs->rs_rates[ic->ic_fixed_rate];
	} else {
		rs = &ni->ni_rates;
		rate = rs->rs_rates[ni->ni_txrate];
	}

	rate &= IEEE80211_RATE_VAL;

/*	if (ic->ic_flags & IEEE80211_F_WEPON) {
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
			return ENOBUFS;
	}*/

	data = &sc->tx_data[0];
	desc = (struct zyd_controlsetformat *)data->buf;

	data->m = m0;
	data->ni = ni;

	wh = mtod(m0, struct ieee80211_frame *);

/*	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		dur = zyd_txtime(ZYD_ACK_SIZE, zyd_ack_rate(ic, rate),
			ic->ic_flags) + ZYD_SIFS;
		*(uint16_t *)wh->i_dur = htole16(dur);
	}*/

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct zyd_tx_radiotap_header *tap = &sc->sc_txtap;
	
		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);

		M_DUP_PKTHDR(&mb, m0);
		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_pkthdr.len += mb.m_len;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	m_copydata(m0, 0, m0->m_pkthdr.len, data->buf + ZYD_TX_DESC_SIZE);
	zyd_setup_tx_desc(sc, desc, m0, m0->m_pkthdr.len, rate);

	// xfer length needs to be a multiple of two!
	xferlen = (ZYD_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;

	DPRINTF(("%s: sending data frame len=%u rate=%u xfer len=%u\n",
	    USBDEVNAME(sc->zyd_dev), m0->m_pkthdr.len, rate, xferlen));

	usbd_setup_xfer(data->xfer, sc->zyd_ep[ZYD_ENDPT_BOUT], data,
	    data->buf, xferlen, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    ZYD_TX_TIMEOUT, zyd_txeof);

	error = usbd_transfer(data->xfer);

	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS) {
		m_freem(m0);
		return error;
	}

	sc->tx_queued++;

	return 0;
}

/*
 * Transmit beacon frame
 */
int
zyd_tx_bcn(struct zyd_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct zyd_controlsetformat *desc;
	usbd_xfer_handle xfer;
	usbd_status error;
	uint8_t cmd = 0;
	uint8_t *buf;
	int xferlen, rate;

	rate = IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan) ? 12 : 4;

	xfer = usbd_alloc_xfer(sc->zyd_udev);

	if (xfer == NULL)
		return ENOMEM;

	/* xfer length needs to be a multiple of two! */
	xferlen = (ZYD_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;

	buf = usbd_alloc_buffer(xfer, xferlen);

	if (buf == NULL) {
		usbd_free_xfer(xfer);
		return ENOMEM;
	}

	usbd_setup_xfer(xfer, sc->zyd_ep[ZYD_ENDPT_BOUT], NULL, &cmd, sizeof cmd,
		USBD_FORCE_SHORT_XFER, ZYD_TX_TIMEOUT, NULL);

	error = usbd_sync_transfer(xfer);

	if (error != 0) {
		usbd_free_xfer(xfer);
		return error;
	}

	desc = (struct zyd_controlsetformat *)buf;

	m_copydata(m0, 0, m0->m_pkthdr.len, buf + ZYD_TX_DESC_SIZE);
	zyd_setup_tx_desc(sc, desc, m0, m0->m_pkthdr.len, rate);

	DPRINTF(("%s: sending beacon frame len=%u rate=%u xfer len=%u\n",
	    USBDEVNAME(sc->zyd_dev), m0->m_pkthdr.len, rate, xferlen));

	usbd_setup_xfer(xfer, sc->zyd_ep[ZYD_ENDPT_BOUT], NULL, buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, ZYD_TX_TIMEOUT, NULL);

	error = usbd_sync_transfer(xfer);
	usbd_free_xfer(xfer);

	return error;
}


void
zyd_set_chan(struct zyd_softc *sc, struct ieee80211_channel *c)
{
	struct ieee80211com *ic = &sc->sc_ic;
/*	uint8_t power, tmp;
	u_int i, chan;*/
	unsigned int chan;

	chan = ieee80211_chan2ieee(ic, c);

	DPRINTF(("%s: zyd_set_chan: Will try %d\n", USBDEVNAME(sc->zyd_dev),
	    chan));

	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
	{
		DPRINTF(("%s: zyd_set_chan(): 0 or ANY, exiting\n",
		    USBDEVNAME(sc->zyd_dev)));
		return;
	}

	zyd_lock_phy(sc);

	sc->rf.set_channel(sc, &sc->rf, chan);

	/* Power integration */
	zyd_write32(sc, ZYD_CR31, sc->pwr_int_values[chan - 1]);

	/* Power calibration */
	zyd_write32(sc, ZYD_CR68, sc->pwr_cal_values[chan - 1]);

	zyd_unlock_phy(sc);
}

/*
 * Interface: init
 */
int
zyd_init(struct ifnet *ifp)
{
	struct zyd_softc *sc = ifp->if_softc;
	struct ieee80211com	*ic = &sc->sc_ic;
	struct zyd_rx_data *data;
	usbd_status	err;
	uint32_t statedata;
	int	i, s;

d1457 2
a1458 1
/*	zyd_stop(ifp, 0);*/
d1460 3
a1462 2
	/* Do initial setup */
	err = zyd_initial_config(sc);
d1464 3
a1466 6
	if (err) {
		DPRINTF(("%s: initial config failed!\n",
		    USBDEVNAME(sc->zyd_dev)));
		splx(s);
		return(EIO);
	}
d1468 2
a1469 3
	/* Additional init */
	zyd_reset_mode(sc);
	zyd_switch_radio(sc, 1);
d1471 10
a1480 2
	/* Set basic rates */
	zyd_set_basic_rates(sc, ic->ic_curmode);
d1482 1
a1482 2
	/* Set mandatory rates */
/*	zyd_set_mandatory_rates(sc, ic->ic_curmode);	*/
d1484 4
a1487 5
	/* set default BSS channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	DPRINTF(("%s: Setting channel from if_init()\n",
	    USBDEVNAME(sc->zyd_dev)));
	zyd_set_chan(sc, ic->ic_bss->ni_chan);
d1489 3
a1491 1
	zyd_enable_hwint(sc);
d1493 13
a1505 1
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
d1507 2
a1508 1
	DPRINTFN(10, ("%s: zyd_init\n", USBDEVNAME(sc->zyd_dev)));
d1510 1
a1510 4
	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
		return(0);
	}
d1512 2
a1513 4
	/*
	 * Allocate Tx and Rx xfer queues.
	 */
	err = zyd_alloc_tx(sc);
d1515 2
a1516 5
	if (err != 0) {
		printf("%s: could not allocate Tx list\n",
		    USBDEVNAME(sc->zyd_dev));
		goto fail;
	}
d1518 13
a1530 1
	err = zyd_alloc_rx(sc);
d1532 17
a1548 4
	if (err != 0) {
		printf("%s: could not allocate Rx list\n",
		    USBDEVNAME(sc->zyd_dev));
		goto fail;
d1551 4
a1554 5
	/*
	 * Start up the receive pipe.
	 */
	for (i = 0; i < ZYD_RX_LIST_CNT; i++) {
		data = &sc->rx_data[i];
d1556 4
a1559 3
		usbd_setup_xfer(data->xfer, sc->zyd_ep[ZYD_ENDPT_BIN], data,
		    data->buf, MCLBYTES, USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT,
		    zyd_rxeof);
d1561 6
a1566 1
		usbd_transfer(data->xfer);
d1568 1
d1570 2
a1571 2
	/* Load the multicast filter. */
	/*zyd_setmulti(sc); */
d1573 2
a1574 2
	DPRINTFN(10, ("%s: starting up using MAC=%s\n",
	    USBDEVNAME(sc->zyd_dev), ether_sprintf(ic->ic_myaddr)));
d1576 1
a1576 2
	DPRINTFN(10, ("%s: initialised transceiver\n",
	    USBDEVNAME(sc->zyd_dev)));
d1578 9
a1586 9
	ifp->if_flags &= ~IFF_OACTIVE;
	ifp->if_flags |= IFF_RUNNING;

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	zyd_read32(sc, ZYD_REG_CTL(0x684), &statedata);
a1588 5

fail:
/*	zyd_stop(ifp, 1);*/
	splx(s);
	return err;
a1590 21
/*
void
zyd_stop(struct ifnet *ifp, int disable)
{
	struct zyd_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	DPRINTF(("Entering zyd_stop()\n"));

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

	sc->tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);

	zyd_free_rx(sc);
	zyd_free_tx(sc);

	DPRINTF(("Leaving zyd_stop()\n"));
}*/

a1595 1
	struct ether_header *eh;
a1605 2
	DPRINTF(("%s: Entering zyd_start()\n", USBDEVNAME(sc->zyd_dev)));

a1608 3
			DPRINTF(("%s: zyd_start: m0 != NULL, tx_queued = %d\n",
			    USBDEVNAME(sc->zyd_dev), sc->tx_queued));

a1612 1

a1616 1

d1621 1
a1621 2

			if (zyd_tx_mgt(sc, m0, ni) != 0)
a1622 1

a1625 1

a1628 1

a1633 13

			if (m0->m_len < sizeof (struct ether_header) &&
				!(m0 = m_pullup(m0, sizeof (struct ether_header))))
				continue;

			eh = mtod(m0, struct ether_header *);
			ni = ieee80211_find_txnode(ic, eh->ether_dhost);

			if (ni == NULL) {
				m_freem(m0);
				continue;
			}

a1637 1

a1641 1

a1645 1

d1647 2
a1648 1
				ieee80211_release_node(ic, ni);
d1659 20
d1686 1
a1686 1
	int err = 0, s;
a1698 1

d1701 1
a1701 3
			if (ifp->if_flags & IFF_RUNNING)
				zyd_update_promisc(sc);
			else
d1704 2
a1705 2
/*			if (ifp->if_flags & IFF_RUNNING)
				zyd_stop(ifp, 1);*/
d1712 1
a1712 1
		err = (command == SIOCADDMULTI) ?
d1715 2
a1716 21

		if (err == ENETRESET)
			err = 0;
		break;

	case SIOCS80211CHANNEL:
		/*
		 * This allows for fast channel switching in monitor mode
		 * (used by kismet). In IBSS mode, we must explicitly reset
		 * the interface to generate a new beacon frame.
		 */
		DPRINTF(("%s: Setting channel from ioctl\n",
		    USBDEVNAME(sc->zyd_dev)));
		
		err = ieee80211_ioctl(ifp, command, data);

		if (err == ENETRESET &&
			ic->ic_opmode == IEEE80211_M_MONITOR) {
			zyd_set_chan(sc, ic->ic_ibss_chan);
			err = 0;
		}
d1720 1
a1720 4
		DPRINTFN(15, ("%s: ieee80211_ioctl (%lu)\n",
		    USBDEVNAME(sc->zyd_dev), command));
		err = ieee80211_ioctl(ifp, command, data);
		break;
d1723 1
a1723 1
	if (err == ENETRESET) {
d1725 1
a1725 3
		    (IFF_RUNNING | IFF_UP)) {
			DPRINTF(("%s: zyd_ioctl(): netreset\n",
			    USBDEVNAME(sc->zyd_dev)));
d1727 1
a1727 2
		}
		err = 0;
d1732 1
a1732 1
	return (err);
d1735 2
a1736 2
void
zyd_watchdog(struct ifnet *ifp)
d1739 41
d1781 20
a1800 1
	DPRINTF(("%s: zyd_watchdog()\n", USBDEVNAME(sc->zyd_dev)));
d1802 5
a1806 1
	ifp->if_timer = 0;
d1808 8
a1815 6
	if (sc->tx_timer > 0) {
		if (--sc->tx_timer == 0) {
			printf("%s: device timeout\n", USBDEVNAME(sc->zyd_dev));
			/*zyd_init(ifp); XXX needs a process context ? */
			ifp->if_oerrors++;
			return;
a1816 1
		ifp->if_timer = 1;
d1819 12
a1830 1
	ieee80211_watchdog(ifp);
a1832 4
/*
 * This function is called periodically (every 200ms) during scanning to
 * switch from one channel to another.
 */
d1834 1
a1834 1
zyd_next_scan(void *arg)
d1836 1
a1836 1
	struct zyd_softc *sc = arg;
d1839 5
a1843 1
	DPRINTF(("%s: Executing next_scan\n", USBDEVNAME(sc->zyd_dev)));
d1845 2
a1846 3
	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(&ic->ic_if);
}
d1848 2
a1849 10
/*
 * USB task callback
 */
void
zyd_task(void *arg)
{
	struct zyd_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	enum ieee80211_state ostate;
	struct mbuf *m;
d1851 2
a1852 1
	ostate = ic->ic_state;
d1854 3
a1856 4
	if (sc->sc_state == IEEE80211_S_INIT) {
		if (ostate == IEEE80211_S_RUN) {
		}
		sc->sc_newstate(ic, sc->sc_state, -1);
d1858 6
a1863 2
		return;	
	}
d1865 1
a1865 3
	DPRINTF(("%s: Setting channel from task 0x%x\n",
	    USBDEVNAME(sc->zyd_dev), sc->sc_state));
	zyd_set_chan(sc, ic->ic_bss->ni_chan);
d1867 29
a1895 2
	switch (sc->sc_state) {
	case IEEE80211_S_INIT:
d1897 2
a1898 3
	case IEEE80211_S_SCAN:
		timeout_add(&sc->scan_ch, hz / 5);
		break;
d1900 4
a1903 3
	case IEEE80211_S_AUTH:
	case IEEE80211_S_ASSOC:
		break;
d1905 1
a1905 3
	case IEEE80211_S_RUN:
		if (ic->ic_opmode != IEEE80211_M_MONITOR)
			zyd_set_bssid(sc, ic->ic_bss->ni_bssid);
d1907 5
a1911 9
		if (ic->ic_opmode == IEEE80211_M_HOSTAP ||
			ic->ic_opmode == IEEE80211_M_IBSS) {
			m = ieee80211_beacon_alloc(ic, ic->ic_bss);

			if (m == NULL) {
				printf("%s: could not allocate beacon\n",
				    USBDEVNAME(sc->zyd_dev));
				return;
			}
d1913 2
a1914 6
			if (zyd_tx_bcn(sc, m, ic->ic_bss) != 0) {
				m_freem(m);
				printf("%s: could not transmit beacon\n",
				    USBDEVNAME(sc->zyd_dev));
				return;
			}
d1916 4
a1919 5
			/* beacon is no longer needed */
			m_freem(m);
		}
		break;
	}
d1921 2
a1922 1
	sc->sc_newstate(ic, sc->sc_state, -1);
a1927 4
	struct zyd_softc *sc = (struct zyd_softc *)self;

	DPRINTF(("%s: Entering zyd_activate()\n", USBDEVNAME(sc->zyd_dev)));

d1933 1
a1933 1
		if_deactivate(&sc->sc_if);
a1935 1

@


1.26
log
@don't use IF_PREPEND() on altq's.
use IFQ_POLL()/IFQ_DEQUEUE() logic instead as described in altq(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.25 2006/08/24 13:16:02 jsg Exp $	*/
d101 1
@


1.25
log
@Be sure to print device name in debug messages, remove
a few surplus dmesg messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.24 2006/08/15 18:10:54 niallo Exp $	*/
d3490 1
a3490 2
			IFQ_DEQUEUE(&ifp->if_snd, m0);

a3494 1
				IF_PREPEND(&ifp->if_snd, m0);
d3498 1
@


1.24
log
@- Belkin F5D705C is a zyd(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.23 2006/07/04 15:49:19 xsa Exp $	*/
d329 3
a331 7
#ifdef ZYD_DEBUG
	if (zyddebug) {
		DPRINTFN(20, ("%s: req=%02x val=%02x ind=%02x "
		    "len=%02x\n", USBDEVNAME(sc->zyd_dev), request,
		    value, index, length));
	}
#endif /* ZYD_DEBUG */
d557 1
a557 1
	DPRINTF(("intrwrite raw dump:\n"));
d1156 1
a1156 1
	DPRINTF(("Entering zyd_txeof()\n"));
a1186 2

	DPRINTF(("Leaving zyd_txeof()\n"));
d1234 2
a1235 1
		DPRINTF(("RX status indicated error\n"));
d1453 2
a1454 1
	DPRINTF(("Firmware upload: imgsize=%d\n", imgsize));
d1461 2
a1462 1
		DPRINTF(("Firmware upload: tlen=%d, value=%x\n", tlen, zc.value));
d1636 2
a1637 2
		DPRINTF(("aw %u pt %u bi %u\n", s->atim_wnd_period,
		    s->pre_tbtt, s->beacon_interval));
d1737 2
a1738 1
	DPRINTF(("rf_init(): ir1 = %d, ir2 = %d\n",
d1755 1
a1755 1
	DPRINTF(("rf_init(). rv = %d\n", rv));
d1947 2
a1948 1
	DPRINTF(("zyd_hw_init: firmware_base = 0x%04X\n", sc->firmware_base));
d2021 2
a2022 1
	DPRINTF(("zyd_hw_init: rv = %d, stage = %d\n", rv, stage));
d2337 1
a2337 1
	DPRINTF(("In zyd_reset_mode()\n"));
d2356 2
a2357 3
	DPRINTF(("Setting BSSID\n"));

	DPRINTF(("addrh = %x, addrl = %x\n", addrh, addrl));
d2391 1
a2391 1
	DPRINTF(("A total of %d endpoints available\n", id->bNumEndpoints));
a2401 18
		DPRINTF(("Endpoint %d: ", i));

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN) {
			DPRINTF(("in "));

			if (UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
				DPRINTF(("bulk\n"));
			else
				DPRINTF(("int\n"));
		} else {
			DPRINTF(("out "));

			if (UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
				DPRINTF(("bulk\n"));
			else
				DPRINTF(("int\n"));
		}

d2448 1
a2448 1
	DPRINTF(("Loading regdomain\n"));
a2454 1
	DPRINTF(("Regdomain supported?\n"));
d2546 2
a2547 1
	DPRINTF(("EXITING complete_attach(): Status = %d\n", rv));
d2605 1
a2605 1
	DPRINTF(("zyd_newstate(): %d\n", nstate));
a2631 1
	DPRINTF(("Setting mac-addr\n"));
a2641 1
	DPRINTF(("Setting encryption type\n"));
d2873 4
a2876 3
	DPRINTF(("Entering zyd_setup_tx_desc()\n"));
	DPRINTF(("sizeof (zyd_controlsetformat) = %d\n",
	    sizeof(struct zyd_controlsetformat)));
d3033 1
a3033 1
	DPRINTF(("Entering zyd_tx_mgt()\n"));
d3096 2
a3097 2
	DPRINTF(("sending mgt frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len, rate, xferlen));
d3113 2
a3114 1
		DPRINTF(("zyd_tx_mgt(): Error %d\n", error));
a3122 2
	DPRINTF(("Leaving zyd_tx_mgt()\n"));

a3138 2
	DPRINTF(("Entering zyd_tx_data()\n"));

d3199 2
a3200 2
	DPRINTF(("sending data frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len, rate, xferlen));
a3214 2
	DPRINTF(("Leaving zyd_tx_data()\n"));

a3231 2
	DPRINTF(("Entering zyd_tx_bcn()\n"));

d3264 2
a3265 2
	DPRINTF(("sending beacon frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len, rate, xferlen));
a3272 2
	DPRINTF(("Leaving zyd_tx_bcn()\n"));

d3287 2
a3288 1
	DPRINTF(("zyd_set_chan: Will try %d\n", chan));
d3292 2
a3293 1
		DPRINTF(("zyd_set_chan(): 0 or ANY, exiting\n"));
a3322 2
	DPRINTF(("Entering zyd_init()\n"));

a3346 2
	DPRINTF(("@@1: zyd_init()\n"));

d3349 2
a3350 1
	DPRINTF(("Setting channel from if_init()\n"));
a3354 2
	DPRINTF(("@@2: zyd_init()\n"));

a3366 1
	DPRINTF(("@@3: zyd_init()\n"));
a3374 1
	DPRINTF(("@@4: zyd_init()\n"));
a3385 1
	DPRINTF(("@@5: zyd_init()\n"));
a3397 1
	DPRINTF(("@@6: zyd_init()\n"));
a3412 2
	DPRINTF(("@@7: zyd_init()\n"));

a3413 1
	DPRINTF(("State machine: %x\n", statedata));
d3460 1
a3460 1
	DPRINTF(("Entering zyd_start()\n"));
d3465 2
a3466 2
			DPRINTF(("zyd_start: m0 != NULL, tx_queued = %d\n",
			    sc->tx_queued));
a3482 2
			DPRINTF(("if_state: @@1\n"));

a3486 2
			DPRINTF(("if_state: @@2\n"));

a3490 1
			DPRINTF(("if_state: @@3\n"));
a3494 2
			DPRINTF(("if_state: @@4\n"));

a3500 2
			DPRINTF(("if_state: @@5\n"));

a3504 1
			DPRINTF(("if_state: @@6\n"));
a3512 2
			DPRINTF(("if_state: @@7\n"));

a3527 2
			DPRINTF(("if_state: @@8\n"));

a3537 2

	DPRINTF(("Finished zyd_start()\n"));
d3590 2
a3591 1
		DPRINTF(("IOCTL: SIOCS80211CHANNEL (Setting channel from ioctl\n"));
d3629 1
a3629 1
	DPRINTF(("zyd_watchdog()\n"));
d3656 1
a3656 1
	DPRINTF(("Executing next_scan\n"));
d3675 12
a3688 3
		if (ostate == IEEE80211_S_RUN) {
		}
		break;
a3690 3
		DPRINTF(("Setting channel from task (SCAN)\n"));
		zyd_set_chan(sc, ic->ic_bss->ni_chan);

a3694 4
		DPRINTF(("Setting channel from task (AUTH)\n"));
		zyd_set_chan(sc, ic->ic_bss->ni_chan);
		break;

a3695 2
		DPRINTF(("Setting channel from task (ASSOC)\n"));
		zyd_set_chan(sc, ic->ic_bss->ni_chan);
a3698 3
		DPRINTF(("Setting channel from task (RUN)\n"));
		zyd_set_chan(sc, ic->ic_bss->ni_chan);

d3731 3
a3733 1
	DPRINTF(("Entering zyd_activate()\n"));
@


1.23
log
@cleanup in zyd_openpipes(); no functional change. OK jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.22 2006/07/04 06:53:17 jsg Exp $	*/
d90 1
@


1.22
log
@Harcoded hex values for control field don't work so
ditch them and at least attempt to use the function
that sets up the control field properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.21 2006/07/03 14:16:12 xsa Exp $	*/
d885 2
a886 1
	edesc = usbd_interface2endpoint_descriptor(sc->zyd_iface, ZYD_ENDPT_IIN);
a900 1

d902 3
a904 3
		free(sc->ibuf, M_USBDEV);
		clfree(&sc->q_reply);
		return (EIO);
d910 2
a911 6

	if (err) {
		free(sc->ibuf, M_USBDEV);
		clfree(&sc->q_reply);
		return (EIO);
	}
a915 1

d917 3
a919 3
		free(sc->ibuf, M_USBDEV);
		clfree(&sc->q_reply);
		return (EIO);
a924 1

d926 3
a928 3
		free(sc->ibuf, M_USBDEV);
		clfree(&sc->q_reply);
		return (EIO);
d932 4
@


1.21
log
@minor knf; ok jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.20 2006/07/03 13:12:58 xsa Exp $	*/
a3045 7
	static const uint8_t winbuf[]  = {
		0x01, 0x2e, 0x00, 0x03, 0x43, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x11, 0xf6, 0x7f, 0x9b, 0x3c, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x82, 0x84, 0x0b, 0x16, 0x32, 0x08, 0x0c, 0x12, 0x18,
		0x24, 0x30, 0x48, 0x60, 0x6c
	};

a3099 6

/* DEBUG: Use exactly what windoof does */
	memcpy(data->buf, winbuf, sizeof(winbuf));
	xferlen = sizeof(winbuf);


d3108 1
a3108 1
/*	zyd_setup_tx_desc(sc, desc, m0, m0->m_pkthdr.len, rate);*/
d3110 1
a3110 1
	// xfer length needs to be a multiple of two!
@


1.20
log
@in zyd_start():
net80211 may still try to send management frames even if the
IFF_RUNNING flag is not set...; ok jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.19 2006/07/02 06:52:36 jsg Exp $	*/
d1004 2
a1005 4
/*
 * Free TX list
 */
void zyd_free_tx(struct zyd_softc *sc)
d1026 2
a1027 4
/*
 * Allocate RX list
 */
int zyd_alloc_rx(struct zyd_softc *sc)
d1081 2
a1082 4
/*
 * Free RX list
 */
void zyd_free_rx(struct zyd_softc *sc)
d1105 2
a1106 1
void zyd_stateoutput(struct zyd_softc *sc)
d2753 2
a2754 1
int zyd_calc_useclen2(uint8_t *service, uint8_t cs_rate, uint16_t tx_length)
a3476 3
 * Interface: stop
 */
/*
a3496 3
/*
 * Interface: start
 */
a3608 3
/*
 * Interface: ioctl
 */
d3670 5
a3674 5
		default:
			DPRINTFN(15, ("%s: ieee80211_ioctl (%lu)\n",
			    USBDEVNAME(sc->zyd_dev), command));
			err = ieee80211_ioctl(ifp, command, data);
			break;
a3691 3
/*
 * Interface: watchdog
 */
@


1.19
log
@If ieee80211_encap() returns NULL the node is already free,
do not try to free it again.
Modified version of a diff from Graham Gower.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.18 2006/07/02 02:59:21 jsg Exp $	*/
d3515 7
@


1.18
log
@Move some of the verbose debug printfs like dumping packets
to higher debug levels so we can tell what is happening.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.17 2006/07/02 02:16:49 jsg Exp $	*/
d3586 2
a3587 4
			m0 = ieee80211_encap(ifp, m0, &ni);

			if (m0 == NULL) {
				ieee80211_release_node(ic, ni);
@


1.17
log
@Send management frames at 1Mbit for better compatibility/chance
of working.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.16 2006/07/02 01:25:10 jsg Exp $	*/
d454 1
a454 1
	DPRINTF(("zydintr: status=%d\n", status));
d834 1
a834 1
	DPRINTF(("Entering zyd_rfwrite()\n"));
d867 2
a868 1
	DPRINTF(("Finished zyd_rfwrite(): rv = %d, wrote %d bits\n", rv, bits));
d1237 1
a1237 1
	DPRINTF(("Rx status: signalstrength = %d, signalqualitycck = %d, "
d1304 1
a1304 1
	DPRINTF(("iee80211_input() -> %d\n", optype));
a1326 2
	DPRINTF(("Entering zyd_rxeof\n"));

d1339 6
a1344 4
	DPRINTF(("zyd_rxeof: Len = %d\n", len));
	DPRINTF(("zyd_rxeof: Raw dump follows\n"));

	bindump(data->buf, len);
d1363 1
a1363 1
		DPRINTF(("Received multi-frame transmission\n"));
d1380 1
a1380 1
		DPRINTF(("Received single-frame transmission\n"));
a1405 2
	DPRINTF(("Leaving zyd_rxeof()\n"));

d3117 7
a3123 4
	DPRINTF(("Raw dump before desc setup:\n"));

	bindump(data->buf, xferlen);
/*	bindump(data->buf + ZYD_TX_DESC_SIZE, m0->m_pkthdr.len);*/
d3137 6
a3142 3
	DPRINTF(("Raw send data output:\n"));

	bindump(data->buf, xferlen);
@


1.16
log
@Rename several functions for consistency/simplicity.
Discussed with Florian.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.15 2006/07/02 01:04:58 jsg Exp $	*/
d3073 1
a3073 1
	rate = IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan) ? 12 : 4;
@


1.15
log
@Support for adapters with Airoha AL2230 radios from Florian.
This lets me see beacons on my device.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.14 2006/07/02 00:56:14 jsg Exp $	*/
d120 3
a122 3
int		zyd_singleregread16(struct zyd_softc *, uint32_t, uint16_t *);
int		zyd_singleregread32(struct zyd_softc *, uint32_t, uint32_t *);
int		zyd_multiregread16(struct zyd_softc *, uint32_t *, uint16_t *,
d124 1
a124 1
int		zyd_multiregread32(struct zyd_softc *, uint32_t *, uint32_t *,
d127 3
a129 3
usbd_status	zyd_singleregwrite16(struct zyd_softc *, uint32_t, uint16_t);
usbd_status	zyd_singleregwrite32(struct zyd_softc *, uint32_t, uint32_t);
usbd_status	zyd_multiregwrite16(struct zyd_softc *, uint32_t *,
d131 1
a131 1
usbd_status	zyd_multiregwrite32(struct zyd_softc *, uint32_t *,
d133 1
a133 1
usbd_status	zyd_batchwrite16(struct zyd_softc *,
d135 1
a135 1
usbd_status	zyd_batchwrite32(struct zyd_softc *,
d214 5
a218 5
int		zyd_if_init(struct ifnet *);
/*void		zyd_if_stop(struct ifnet *, int);*/
void		zyd_if_start(struct ifnet *);
int		zyd_if_ioctl(struct ifnet *, u_long, caddr_t);
void		zyd_if_watchdog(struct ifnet *);
d604 1
a604 1
zyd_singleregread16(struct zyd_softc *sc, uint32_t addr, uint16_t *value)
d606 1
a606 1
	return zyd_multiregread16(sc, &addr, value, 1);
d613 1
a613 1
zyd_singleregread32(struct zyd_softc *sc, uint32_t addr, uint32_t *value)
d615 1
a615 1
	return zyd_multiregread32(sc, &addr, value, 1);
d622 1
a622 1
zyd_multiregread16(struct zyd_softc *sc, uint32_t *addrs, uint16_t *data,
d654 1
a654 1
zyd_multiregread32(struct zyd_softc *sc, uint32_t *addrs, uint32_t *data,
d694 1
a694 1
zyd_singleregwrite16(struct zyd_softc *sc, uint32_t addr, uint16_t value)
d696 1
a696 1
	return zyd_multiregwrite16(sc, &addr, &value, 1);
d703 1
a703 1
zyd_singleregwrite32(struct zyd_softc *sc, uint32_t addr, uint32_t value)
d705 1
a705 1
	return zyd_multiregwrite32(sc, &addr, &value, 1);
d712 1
a712 1
zyd_multiregwrite16(struct zyd_softc *sc, uint32_t *addrs, uint16_t *data,
d740 1
a740 1
zyd_multiregwrite32(struct zyd_softc *sc, uint32_t *addrs, uint32_t *data,
d775 1
a775 1
zyd_batchwrite16(struct zyd_softc *sc, const struct zyd_adpairs16 *data,
d784 1
a784 1
/*	DPRINTF(("zyd_batchwrite16: %d items\n", count));*/
d787 2
a788 2
/*		DPRINTF(("zyd_batchwrite16: item %d: @@%x -> %02x\n", i, data[i].addr, data[i].data));*/
		rv = zyd_singleregwrite16(sc, data[i].addr, data[i].data);
d801 1
a801 1
zyd_batchwrite32(struct zyd_softc *sc, const struct zyd_adpairs32 *data,
d810 1
a810 1
/*	DPRINTF(("zyd_batchwrite32: %d items\n", count));*/
d813 2
a814 2
/*		DPRINTF(("zyd_batchwrite32: item %d: @@%x -> %08x\n", i, data[i].addr, data[i].data));*/
		rv = zyd_singleregwrite32(sc, data[i].addr, data[i].data);
d836 1
a836 1
	rv = zyd_singleregread16(sc, ZYD_CR203, &bw_template);
d1117 1
a1117 1
	zyd_singleregread32(sc, ZYD_REG_CTL(0x6D4), &debug);
d1121 1
a1121 1
	zyd_singleregread32(sc, ZYD_REG_CTL(0x6F4), &debug);
d1125 1
a1125 1
	zyd_singleregread32(sc, ZYD_REG_CTL(0x69C), &debug);
d1129 1
a1129 1
	zyd_singleregread32(sc, ZYD_REG_CTL(0x6A0), &debug);
d1133 1
a1133 1
	zyd_singleregread32(sc, ZYD_REG_CTL(0x6A4), &debug);
d1137 1
a1137 1
	zyd_singleregread32(sc, ZYD_REG_CTL(0x6A8), &debug);
d1141 1
a1141 1
	zyd_singleregread32(sc, ZYD_REG_CTL(0x6AC), &debug);
d1145 1
a1145 1
	zyd_singleregread32(sc, ZYD_REG_CTL(0x6B0), &debug);
d1149 1
a1149 1
	zyd_singleregread32(sc, ZYD_REG_CTL(0x6BC), &debug);
d1193 1
a1193 1
/*	zyd_if_start(ifp);*/
d1609 1
a1609 1
	zyd_singleregread32(sc, ZYD_MAC_MISC, &temp);
d1611 1
a1611 1
	zyd_singleregwrite32(sc, ZYD_MAC_MISC, temp);
d1622 1
a1622 1
	zyd_singleregread32(sc, ZYD_MAC_MISC, &temp);
d1624 1
a1624 1
	zyd_singleregwrite32(sc, ZYD_MAC_MISC, temp);
d1638 1
a1638 1
	rv = zyd_multiregread32(sc, addrs, values, 3);
d1676 1
a1676 1
	return zyd_multiregwrite32(sc, addrs, data, 3);
d1725 1
a1725 1
	rv = zyd_singleregread32(sc, ZYD_E2P_POD, &value);
d1751 1
a1751 1
	rv = zyd_batchwrite16(sc, zyd_rfmd_cr, (sizeof(zyd_rfmd_cr) /
d1784 1
a1784 1
		return zyd_batchwrite16(sc, ir_on,
d1787 1
a1787 1
	return zyd_batchwrite16(sc, ir_off, (sizeof(ir_off) /
d1833 1
a1833 1
		return zyd_batchwrite16(sc, ir_on,
d1836 1
a1836 1
	return zyd_batchwrite16(sc, ir_off, (sizeof(ir_off) /
d1849 1
a1849 1
	rv = zyd_batchwrite16(sc, zyd_al2230_cr, (sizeof(zyd_al2230_cr) /
d1892 1
a1892 1
	return zyd_batchwrite16(sc, sc_cmd, (sizeof(sc_cmd) /
d1946 1
a1946 1
	rv = zyd_singleregwrite32(sc, ZYD_MAC_AFTER_PNP, 1);
d1953 1
a1953 1
	rv = zyd_singleregread16(sc, ZYD_REG_USB(ZYD_FIRMWARE_BASE_ADDR),
d1959 1
a1959 1
	rv = zyd_singleregread16(sc, ZYD_FW_FIRMWARE_VER, &sc->fw_ver);
d1966 1
a1966 1
	rv = zyd_singleregwrite32(sc, ZYD_CR_GPI_EN, 0);
d1973 1
a1973 1
	rv = zyd_singleregwrite32(sc, ZYD_MAC_CONT_WIN_LIMIT, 0x007f043f);
d1986 1
a1986 1
	rv = zyd_batchwrite16(sc, zyd_def_cr,
d1996 1
a1996 1
	rv = zyd_batchwrite32(sc, zyd_def_mac,
d2042 1
a2042 1
	rv = zyd_singleregread32(sc, ZYD_E2P_MAC_ADDR_P1, &mac[0]);
d2047 1
a2047 1
	rv = zyd_singleregread32(sc, ZYD_E2P_MAC_ADDR_P2, &mac[1]);
d2082 1
a2082 1
	return zyd_multiregwrite32(sc, addrs, trans, 2);
d2094 1
a2094 1
	rv = zyd_singleregread32(sc, ZYD_E2P_SUBID, &value);
d2136 1
a2136 1
		r = zyd_singleregread32(sc, (e2p_addr + (i / 2)), &v);
d2232 1
a2232 1
	return zyd_singleregwrite32(sc, ZYD_MAC_ENCRYPTION_TYPE, type);
d2259 1
a2259 1
	return zyd_singleregwrite32(sc, ZYD_CR_INTERRUPT, ZYD_HWINT_ENABLED);
d2268 1
a2268 1
	return zyd_singleregwrite32(sc, ZYD_CR_INTERRUPT, ZYD_HWINT_DISABLED);
d2295 1
a2295 1
	return zyd_singleregwrite32(sc, ZYD_MAC_BASICRATE, outf);
d2323 1
a2323 1
	return zyd_singleregwrite32(sc, ZYD_MAC_MANDATORYRATE, outf);
d2346 1
a2346 1
	return zyd_batchwrite32(sc, io, 3);
d2367 1
a2367 1
	rv = zyd_singleregwrite32(sc, ZYD_MAC_BSSADRL, addrl);
d2370 1
a2370 1
		rv = zyd_singleregwrite32(sc, ZYD_MAC_BSSADRH, addrh);
d2532 4
a2535 4
	ifp->if_init = zyd_if_init;
	ifp->if_start = zyd_if_start;
	ifp->if_ioctl = zyd_if_ioctl;
	ifp->if_watchdog = zyd_if_watchdog;
d2588 1
a2588 1
/*	zyd_if_stop(ifp, 1);*/
d2621 1
a2621 1
		zyd_if_init(ifp);
d3039 1
a3039 1
		zyd_singleregread16(sc, addr[i], &values[i]);
d3342 1
a3342 1
	zyd_singleregwrite32(sc, ZYD_CR31, sc->pwr_int_values[chan - 1]);
d3345 1
a3345 1
	zyd_singleregwrite32(sc, ZYD_CR68, sc->pwr_cal_values[chan - 1]);
d3354 1
a3354 1
zyd_if_init(struct ifnet *ifp)
d3363 1
a3363 1
	DPRINTF(("Entering zyd_if_init()\n"));
d3367 1
a3367 1
/*	zyd_if_stop(ifp, 0);*/
d3389 1
a3389 1
	DPRINTF(("@@1: zyd_if_init()\n"));
d3398 1
a3398 1
	DPRINTF(("@@2: zyd_if_init()\n"));
d3412 1
a3412 1
	DPRINTF(("@@3: zyd_if_init()\n"));
d3421 1
a3421 1
	DPRINTF(("@@4: zyd_if_init()\n"));
d3433 1
a3433 1
	DPRINTF(("@@5: zyd_if_init()\n"));
d3446 1
a3446 1
	DPRINTF(("@@6: zyd_if_init()\n"));
d3462 1
a3462 1
	DPRINTF(("@@7: zyd_if_init()\n"));
d3464 1
a3464 1
	zyd_singleregread32(sc, ZYD_REG_CTL(0x684), &statedata);
d3470 1
a3470 1
/*	zyd_if_stop(ifp, 1);*/
d3480 1
a3480 1
zyd_if_stop(struct ifnet *ifp, int disable)
d3485 1
a3485 1
	DPRINTF(("Entering zyd_if_stop()\n"));
d3496 1
a3496 1
	DPRINTF(("Leaving zyd_if_stop()\n"));
d3503 1
a3503 1
zyd_if_start(struct ifnet *ifp)
d3511 1
a3511 1
	DPRINTF(("Entering zyd_if_start()\n"));
d3516 1
a3516 1
			DPRINTF(("zyd_if_start: m0 != NULL, tx_queued = %d\n",
d3606 1
a3606 1
	DPRINTF(("Finished zyd_if_start()\n"));
d3613 1
a3613 1
zyd_if_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
d3638 1
a3638 1
				zyd_if_init(ifp);
d3641 1
a3641 1
				zyd_if_stop(ifp, 1);*/
d3683 1
a3683 1
			DPRINTF(("%s: zyd_if_ioctl(): netreset\n",
d3685 1
a3685 1
			zyd_if_init(ifp);
d3699 1
a3699 1
zyd_if_watchdog(struct ifnet *ifp)
d3703 1
a3703 1
	DPRINTF(("zyd_if_watchdog()\n"));
@


1.14
log
@Fix channel frequency/flags in radiotap structures.
Now I can see probes cycling 1->14 instead of just
sitting at channel 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.13 2006/07/01 05:07:26 jsg Exp $	*/
d224 1
d233 1
d242 10
d1824 14
a1837 1
	return 0;
d1846 17
a1862 1
	return 0;
d1872 22
a1893 1
	return 0;
@


1.13
log
@Remove a few noisy debug printfs that aren't doing anything useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.12 2006/07/01 04:25:07 jsg Exp $	*/
d1272 2
a1273 2
		tap->wr_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
d3036 2
a3037 2
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
d3155 2
a3156 2
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
@


1.12
log
@Initial radiotap/bpf bits based on ural.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.11 2006/06/30 12:27:21 jsg Exp $	*/
a1585 4
	DPRINTF(("Setting debug flags\n"));
	/* TODO: What about debugging flags in OpenBSD? */
/*	sc->sc_ic.ic_debug = IEEE80211_MSG_ANY;*/  /* <<<--- this is the NetBSD version */

a1793 2
	DPRINTF(("Entering zyd_rf_rfmd_set_channel()\n"));

a1802 2
	DPRINTF(("Finished zyd_rf_rfmd_set_channel()\n"));

a3264 2
	DPRINTF(("Entering zyd_set_chan()\n"));

a3274 2
	DPRINTF(("@@1: zyd_set_chan()\n"));

a3285 2

	DPRINTF(("Finished zyd_set_chan()\n"));
a3558 2
	DPRINTF(("Entering zyd_if_ioctl()\n"));

a3571 1
		DPRINTF(("IOCTL: SIOCSIFFLAGS\n"));
a3584 1
		DPRINTF(("IOCTL: SIOCADDMULTI\n"));
a3628 2

	DPRINTF(("Finished zyd_if_ioctl()\n"));
@


1.11
log
@Shrink dmesg output, use ether_sprintf() to print MAC address.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.10 2006/06/29 12:13:43 jsg Exp $	*/
d1266 20
d2495 13
d3037 19
d3156 19
d3481 5
d3527 6
d3539 5
@


1.10
log
@Move register value pair table definitions into if_zydreg.h
and move declarations of the big ones to get them off the
limited amount of stack we get to play with in kernel land.
Discussed with Florian, ok reyk@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.9 2006/06/28 04:30:24 jsg Exp $	*/
a1701 3

		printf("%s: Radio %s (%#01x), PA %#01x\n",
		    USBDEVNAME(sc->zyd_dev), zyd_rf_name(rf), rf, pa);
d1870 1
a1870 2
	uint8_t rf, pa;
	uint16_t theversion;
d1885 1
a1885 1
	rv = zyd_singleregread16(sc, ZYD_FW_FIRMWARE_VER, &theversion);
a1891 3
	printf("%s: Firmware version is 0x%04X\n",
	    USBDEVNAME(sc->zyd_dev), theversion);

d1931 1
a1931 1
	rv = zyd_read_rf_pa_types(sc, &rf, &pa);
a1984 5
	printf("%s: E2P MAC address is %02X:%02X:%02X:%02X:%02X:%02X\n",
	    USBDEVNAME(sc->zyd_dev), mac_addr->addr[0], mac_addr->addr[1],
	    mac_addr->addr[2], mac_addr->addr[3], mac_addr->addr[4],
	    mac_addr->addr[5]);

d2386 4
@


1.9
log
@Add a roothook so the firmware can load when the adapter
is already inserted at boot time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.8 2006/06/28 04:15:40 jsg Exp $	*/
d223 17
a1718 71
	/* Copied nearly verbatim from the Linux driver rewrite */
	static const struct zyd_adpairs16 ir1[] = {
		{ ZYD_CR2,   0x1E }, { ZYD_CR9,   0x20 }, { ZYD_CR10,  0x89 },
		{ ZYD_CR11,  0x00 }, { ZYD_CR15,  0xD0 }, { ZYD_CR17,  0x68 },
		{ ZYD_CR19,  0x4a }, { ZYD_CR20,  0x0c }, { ZYD_CR21,  0x0E },
		{ ZYD_CR23,  0x48 },
		/* normal size for cca threshold */
		{ ZYD_CR24,  0x14 },
		/* { ZYD_CR24,  0x20 }, */
		{ ZYD_CR26,  0x90 }, { ZYD_CR27,  0x30 }, { ZYD_CR29,  0x20 },
		{ ZYD_CR31,  0xb2 }, { ZYD_CR32,  0x43 }, { ZYD_CR33,  0x28 },
		{ ZYD_CR38,  0x30 }, { ZYD_CR34,  0x0f }, { ZYD_CR35,  0xF0 },
		{ ZYD_CR41,  0x2a }, { ZYD_CR46,  0x7F }, { ZYD_CR47,  0x1e },
		{ ZYD_CR51,  0xc5 }, { ZYD_CR52,  0xc5 }, { ZYD_CR53,  0xc5 },
		{ ZYD_CR79,  0x58 }, { ZYD_CR80,  0x30 }, { ZYD_CR81,  0x30 },
		{ ZYD_CR82,  0x00 }, { ZYD_CR83,  0x24 }, { ZYD_CR84,  0x04 },
		{ ZYD_CR85,  0x00 }, { ZYD_CR86,  0x10 }, { ZYD_CR87,  0x2A },
		{ ZYD_CR88,  0x10 }, { ZYD_CR89,  0x24 }, { ZYD_CR90,  0x18 },
		/* { ZYD_CR91,  0x18 }, */
		/* should solve continous CTS frame problems */
		{ ZYD_CR91,  0x00 },
		{ ZYD_CR92,  0x0a }, { ZYD_CR93,  0x00 }, { ZYD_CR94,  0x01 },
		{ ZYD_CR95,  0x00 }, { ZYD_CR96,  0x40 }, { ZYD_CR97,  0x37 },
		{ ZYD_CR98,  0x05 }, { ZYD_CR99,  0x28 }, { ZYD_CR100, 0x00 },
		{ ZYD_CR101, 0x13 }, { ZYD_CR102, 0x27 }, { ZYD_CR103, 0x27 },
		{ ZYD_CR104, 0x18 }, { ZYD_CR105, 0x12 },
		/* normal size */
		{ ZYD_CR106, 0x1a },
		/* { ZYD_CR106, 0x22 }, */
		{ ZYD_CR107, 0x24 }, { ZYD_CR108, 0x0a }, { ZYD_CR109, 0x13 },
		{ ZYD_CR110, 0x2F }, { ZYD_CR111, 0x27 }, { ZYD_CR112, 0x27 },
		{ ZYD_CR113, 0x27 }, { ZYD_CR114, 0x27 }, { ZYD_CR115, 0x40 },
		{ ZYD_CR116, 0x40 }, { ZYD_CR117, 0xF0 }, { ZYD_CR118, 0xF0 },
		{ ZYD_CR119, 0x16 },
		/* no TX continuation */
		{ ZYD_CR122, 0x00 },
		/* { ZYD_CR122, 0xff }, */
		{ ZYD_CR127, 0x03 }, { ZYD_CR131, 0x08 }, { ZYD_CR138, 0x28 },
		{ ZYD_CR148, 0x44 }, { ZYD_CR150, 0x10 }, { ZYD_CR169, 0xBB },
		{ ZYD_CR170, 0xBB }
	};

	static const uint32_t ir2[] = {
		0x000007,  /* REG0(CFG1) */
		0x07dd43,  /* REG1(IFPLL1) */
		0x080959,  /* REG2(IFPLL2) */
		0x0e6666,
		0x116a57,  /* REG4 */
		0x17dd43,  /* REG5 */
		0x1819f9,  /* REG6 */
		0x1e6666,
		0x214554,
		0x25e7fa,
		0x27fffa,
		/* The Zydas driver somehow forgets to set this value. It's
		 * only set for Japan. We are using internal power control
		 * for now.
		 */
		0x294128, /* internal power */
		/* 0x28252c, */ /* External control TX power */
		/* CR31_CCK, CR51_6-36M, CR52_48M, CR53_54M */
		0x2c0000,
		0x300000,
		0x340000,  /* REG13(0xD) */
		0x381e0f,  /* REG14(0xE) */
		/* Bogus, RF2959's data sheet doesn't know register 27, which is
		 * actually referenced here.
		 */
		0x6c180f  /* REG27(0x11) */
	};

d1723 2
a1724 2
	    (sizeof(ir1) / sizeof(struct zyd_adpairs16)),
	    (sizeof(ir2) / sizeof(uint32_t))));
d1726 2
a1727 1
	rv = zyd_batchwrite16(sc, ir1, (sizeof(ir1) / sizeof(struct zyd_adpairs16)));
d1732 2
a1733 2
	for (i = 0; i < (sizeof(ir2) / sizeof(uint32_t)); i++) {
		rv = zyd_rfwrite(sc, ir2[i], ZYD_RF_RV_BITS);
d1751 1
a1751 2
		{ ZYD_CR10, 0x89 },
		{ ZYD_CR11, 0x00 }
d1755 1
a1755 2
		{ ZYD_CR10, 0x15 },
		{ ZYD_CR11, 0x81 }
d1759 2
a1760 2
		return zyd_batchwrite16(sc, ir_on, (sizeof(ir_on) /
		    sizeof(struct zyd_adpairs16)));
d1774 1
a1774 14
		{ 0x181979, 0x1e6666 },
		{ 0x181989, 0x1e6666 },
		{ 0x181999, 0x1e6666 },
		{ 0x1819a9, 0x1e6666 },
		{ 0x1819b9, 0x1e6666 },
		{ 0x1819c9, 0x1e6666 },
		{ 0x1819d9, 0x1e6666 },
		{ 0x1819e9, 0x1e6666 },
		{ 0x1819f9, 0x1e6666 },
		{ 0x181a09, 0x1e6666 },
		{ 0x181a19, 0x1e6666 },
		{ 0x181a29, 0x1e6666 },
		{ 0x181a39, 0x1e6666 },
		{ 0x181a60, 0x1c0000 }
a1870 88
	/* Copied nearly verbatim from the Linux driver rewrite */
	static const struct zyd_adpairs16 ir1[] = {
		{ ZYD_CR0,   0x0a }, { ZYD_CR1,   0x06 }, { ZYD_CR2,   0x26 },
		{ ZYD_CR3,   0x38 }, { ZYD_CR4,   0x80 }, { ZYD_CR9,   0xa0 },
		{ ZYD_CR10,  0x81 }, { ZYD_CR11,  0x00 }, { ZYD_CR12,  0x7f },
		{ ZYD_CR13,  0x8c }, { ZYD_CR14,  0x80 }, { ZYD_CR15,  0x3d },
		{ ZYD_CR16,  0x20 }, { ZYD_CR17,  0x1e }, { ZYD_CR18,  0x0a },
		{ ZYD_CR19,  0x48 }, { ZYD_CR20,  0x0c }, { ZYD_CR21,  0x0c },
		{ ZYD_CR22,  0x23 }, { ZYD_CR23,  0x90 }, { ZYD_CR24,  0x14 },
		{ ZYD_CR25,  0x40 }, { ZYD_CR26,  0x10 }, { ZYD_CR27,  0x19 },
		{ ZYD_CR28,  0x7f }, { ZYD_CR29,  0x80 }, { ZYD_CR30,  0x4b },
		{ ZYD_CR31,  0x60 }, { ZYD_CR32,  0x43 }, { ZYD_CR33,  0x08 },
		{ ZYD_CR34,  0x06 }, { ZYD_CR35,  0x0a }, { ZYD_CR36,  0x00 },
		{ ZYD_CR37,  0x00 }, { ZYD_CR38,  0x38 }, { ZYD_CR39,  0x0c },
		{ ZYD_CR40,  0x84 }, { ZYD_CR41,  0x2a }, { ZYD_CR42,  0x80 },
		{ ZYD_CR43,  0x10 }, { ZYD_CR44,  0x12 }, { ZYD_CR46,  0xff },
		{ ZYD_CR47,  0x08 }, { ZYD_CR48,  0x26 }, { ZYD_CR49,  0x5b },
		{ ZYD_CR64,  0xd0 }, { ZYD_CR65,  0x04 }, { ZYD_CR66,  0x58 },
		{ ZYD_CR67,  0xc9 }, { ZYD_CR68,  0x88 }, { ZYD_CR69,  0x41 },
		{ ZYD_CR70,  0x23 }, { ZYD_CR71,  0x10 }, { ZYD_CR72,  0xff },
		{ ZYD_CR73,  0x32 }, { ZYD_CR74,  0x30 }, { ZYD_CR75,  0x65 },
		{ ZYD_CR76,  0x41 }, { ZYD_CR77,  0x1b }, { ZYD_CR78,  0x30 },
		{ ZYD_CR79,  0x68 }, { ZYD_CR80,  0x64 }, { ZYD_CR81,  0x64 },
		{ ZYD_CR82,  0x00 }, { ZYD_CR83,  0x00 }, { ZYD_CR84,  0x00 },
		{ ZYD_CR85,  0x02 }, { ZYD_CR86,  0x00 }, { ZYD_CR87,  0x00 },
		{ ZYD_CR88,  0xff }, { ZYD_CR89,  0xfc }, { ZYD_CR90,  0x00 },
		{ ZYD_CR91,  0x00 }, { ZYD_CR92,  0x00 }, { ZYD_CR93,  0x08 },
		{ ZYD_CR94,  0x00 }, { ZYD_CR95,  0x00 }, { ZYD_CR96,  0xff },
		{ ZYD_CR97,  0xe7 }, { ZYD_CR98,  0x00 }, { ZYD_CR99,  0x00 },
		{ ZYD_CR100, 0x00 }, { ZYD_CR101, 0xae }, { ZYD_CR102, 0x02 },
		{ ZYD_CR103, 0x00 }, { ZYD_CR104, 0x03 }, { ZYD_CR105, 0x65 },
		{ ZYD_CR106, 0x04 }, { ZYD_CR107, 0x00 }, { ZYD_CR108, 0x0a },
		{ ZYD_CR109, 0xaa }, { ZYD_CR110, 0xaa }, { ZYD_CR111, 0x25 },
		{ ZYD_CR112, 0x25 }, { ZYD_CR113, 0x00 }, { ZYD_CR119, 0x1e },
		{ ZYD_CR125, 0x90 }, { ZYD_CR126, 0x00 }, { ZYD_CR127, 0x00 },
		{ ZYD_CR5,   0x00 }, { ZYD_CR6,   0x00 }, { ZYD_CR7,   0x00 },
		{ ZYD_CR8,   0x00 }, { ZYD_CR9,   0x20 }, { ZYD_CR12,  0xf0 },
		{ ZYD_CR20,  0x0e }, { ZYD_CR21,  0x0e }, { ZYD_CR27,  0x10 },
		{ ZYD_CR44,  0x33 }, { ZYD_CR47,  0x30 }, { ZYD_CR83,  0x24 },
		{ ZYD_CR84,  0x04 }, { ZYD_CR85,  0x00 }, { ZYD_CR86,  0x0C },
		{ ZYD_CR87,  0x12 }, { ZYD_CR88,  0x0C }, { ZYD_CR89,  0x00 },
		{ ZYD_CR90,  0x10 }, { ZYD_CR91,  0x08 }, { ZYD_CR93,  0x00 },
		{ ZYD_CR94,  0x01 }, { ZYD_CR95,  0x00 }, { ZYD_CR96,  0x50 },
		{ ZYD_CR97,  0x37 }, { ZYD_CR98,  0x35 }, { ZYD_CR101, 0x13 },
		{ ZYD_CR102, 0x27 }, { ZYD_CR103, 0x27 }, { ZYD_CR104, 0x18 },
		{ ZYD_CR105, 0x12 }, { ZYD_CR109, 0x27 }, { ZYD_CR110, 0x27 },
		{ ZYD_CR111, 0x27 }, { ZYD_CR112, 0x27 }, { ZYD_CR113, 0x27 },
		{ ZYD_CR114, 0x27 }, { ZYD_CR115, 0x26 }, { ZYD_CR116, 0x24 },
		{ ZYD_CR117, 0xfc }, { ZYD_CR118, 0xfa }, { ZYD_CR120, 0x4f },
		{ ZYD_CR123, 0x27 }, { ZYD_CR125, 0xaa }, { ZYD_CR127, 0x03 },
		{ ZYD_CR128, 0x14 }, { ZYD_CR129, 0x12 }, { ZYD_CR130, 0x10 },
		{ ZYD_CR131, 0x0C }, { ZYD_CR136, 0xdf }, { ZYD_CR137, 0x40 },
		{ ZYD_CR138, 0xa0 }, { ZYD_CR139, 0xb0 }, { ZYD_CR140, 0x99 },
		{ ZYD_CR141, 0x82 }, { ZYD_CR142, 0x54 }, { ZYD_CR143, 0x1c },
		{ ZYD_CR144, 0x6c }, { ZYD_CR147, 0x07 }, { ZYD_CR148, 0x4c },
		{ ZYD_CR149, 0x50 }, { ZYD_CR150, 0x0e }, { ZYD_CR151, 0x18 },
		{ ZYD_CR160, 0xfe }, { ZYD_CR161, 0xee }, { ZYD_CR162, 0xaa },
		{ ZYD_CR163, 0xfa }, { ZYD_CR164, 0xfa }, { ZYD_CR165, 0xea },
		{ ZYD_CR166, 0xbe }, { ZYD_CR167, 0xbe }, { ZYD_CR168, 0x6a },
		{ ZYD_CR169, 0xba }, { ZYD_CR170, 0xba }, { ZYD_CR171, 0xba },
		/* Note: ZYD_CR204 must lead the ZYD_CR203 */
		{ ZYD_CR204, 0x7d }, { ZYD_CR203, 0x30 }/*, { ZYD_CR240, 0x80 }*/
	};

	static const struct zyd_adpairs32 ir2[] = {
		{ ZYD_MAC_ACK_EXT,		0x20 },
		{ ZYD_CR_ADDA_MBIAS_WARMTIME,	0x30000808 },
		{ ZYD_MAC_RETRY,		0x2 },
		{ ZYD_MAC_SNIFFER,		0 },
		{ ZYD_MAC_STOHOSTSETTING,	0 },//ZYD_AP_RX_FILTER },
		{ ZYD_MAC_GHTBL,		0x00 },
		{ ZYD_MAC_GHTBH,		0x80000000 },
		{ ZYD_MAC_MISC,			0xa4 },
		{ ZYD_CR_ADDA_PWR_DWN,		0x7f },
		{ ZYD_MAC_BCNCFG,		0x00f00401 },
		{ ZYD_MAC_PHY_DELAY2,		0x00 },
		{ ZYD_MAC_ACK_EXT,		0x80 },
		{ ZYD_CR_ADDA_PWR_DWN,		0x00 },
		{ ZYD_MAC_SIFS_ACK_TIME,	0x100 },
		{ ZYD_MAC_DIFS_EIFS_SIFS,	0x547c032 },
		{ ZYD_CR_RX_PE_DELAY,		0x70 },
		{ ZYD_CR_PS_CTRL,		0x10000000 },
		{ ZYD_MAC_RTSCTSRATE,		0x02030203 },
		{ ZYD_MAC_RX_THRESHOLD,		0x000c0640 },
		{ ZYD_MAC_AFTER_PNP,		0x1 },
		{ ZYD_MAC_BACKOFF_PROTECT,	0x114 }
	};

d1919 2
a1920 2
	rv = zyd_batchwrite16(sc, ir1,
	    (sizeof(ir1) / sizeof(struct zyd_adpairs16)));
d1929 2
a1930 2
	rv = zyd_batchwrite32(sc, ir2,
	    (sizeof(ir2) / sizeof(struct zyd_adpairs32)));
@


1.8
log
@Leave usbd_add_drv_event() call till the end of the attach process
to remove the possibility of things like panics due to
unitialised timeouts when the usb task runs before
we finish attaching.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.7 2006/06/28 03:48:46 jsg Exp $	*/
d151 1
d1364 17
d1409 1
a1409 1
		    USBDEVNAME(sc->zyd_dev), "zyd", result);
d1544 4
a1547 2
	if (zyd_uploadfirmware(sc) != 0)
		USB_ATTACH_ERROR_RETURN;
a1551 8

	/* Perform a device reset */
	zyd_reset(sc);

	/* Complete the attach process (hardware init) */
	if (zyd_complete_attach(sc) != 0)
		USB_ATTACH_ERROR_RETURN;
	sc->zyd_attached = 1;
@


1.7
log
@Allow devices > revision 43.30 to attach.
Devices < 43.30 don't support all the used commands
according to Florian.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.6 2006/06/27 13:40:35 xsa Exp $	*/
d2631 3
a2635 3

	timeout_set(&sc->scan_ch, zyd_next_scan, sc);
	timeout_add(&sc->scan_ch, hz);
@


1.6
log
@DECLARE_DRIVER_CLASS(zyd, DV_IFNET); ok jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.5 2006/06/27 13:30:01 xsa Exp $	*/
d1497 3
a1499 2
	if (UGETW(ddesc->bcdDevice) != ZYD_ALLOWED_DEV_VERSION) {
		printf("%s: device version mismatch: 0x%X (only 43.30 supported)\n",
@


1.5
log
@knf in proto's; ok jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.4 2006/06/27 09:21:55 jsg Exp $	*/
d106 1
a106 1
USB_DECLARE_DRIVER(zyd);
@


1.4
log
@Switch from magic numbers to usbdevs for vendor/product pairs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.3 2006/06/27 03:49:44 deraadt Exp $	*/
d108 101
a208 92
/*
 * Prototypes
 */
uint16_t zyd_getrealaddr(struct zyd_softc *, uint32_t);
usbd_status zyd_usbrequest(struct zyd_softc *, uint8_t, uint8_t,
	uint16_t, uint16_t, uint16_t, uint8_t *);
usbd_status zyd_usbrequestzc(struct zyd_softc *, struct zyd_control *);
void zyd_reset(struct zyd_softc *);
usbd_status zyd_usb_bulk_read(struct zyd_softc *, void *, uint32_t, uint32_t *);
usbd_status zyd_usb_bulk_write(struct zyd_softc *, void *, uint32_t);
Static void zydintr(usbd_xfer_handle, usbd_private_handle, usbd_status);
int zyd_usb_intr_read(struct zyd_softc *, void *, uint32_t);
usbd_status zyd_usb_intr_write(struct zyd_softc *, void *, uint32_t);
uint32_t zyd_addrinc(uint32_t);
int zyd_singleregread16(struct zyd_softc *, uint32_t, uint16_t *);
int zyd_singleregread32(struct zyd_softc *, uint32_t, uint32_t *);
int zyd_multiregread16(struct zyd_softc *, uint32_t *, uint16_t *, uint8_t);
int zyd_multiregread32(struct zyd_softc *, uint32_t *, uint32_t *, uint8_t);

usbd_status zyd_singleregwrite16(struct zyd_softc *, uint32_t, uint16_t);
usbd_status zyd_singleregwrite32(struct zyd_softc *, uint32_t, uint32_t);
usbd_status zyd_multiregwrite16(struct zyd_softc *, uint32_t *, uint16_t *, uint8_t);
usbd_status zyd_multiregwrite32(struct zyd_softc *, uint32_t *, uint32_t *, uint8_t);
usbd_status zyd_batchwrite16(struct zyd_softc *,
	const struct zyd_adpairs16 *, int);
usbd_status zyd_batchwrite32(struct zyd_softc *,
	const struct zyd_adpairs32 *, int);
usbd_status zyd_rfwrite(struct zyd_softc *, uint32_t, uint8_t);

int zyd_openpipes(struct zyd_softc *);
void zyd_closepipes(struct zyd_softc *);
int zyd_alloc_tx(struct zyd_softc *);
void zyd_free_tx(struct zyd_softc *);
int zyd_alloc_rx(struct zyd_softc *);
void zyd_free_rx(struct zyd_softc *);
void zyd_stateoutput(struct zyd_softc *);
void zyd_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void zyd_rxframeproc(struct zyd_rx_data *, uint8_t *, uint16_t);
void zyd_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);

int zyd_uploadfirmware(struct zyd_softc *);
void zyd_lock_phy(struct zyd_softc *);
void zyd_unlock_phy(struct zyd_softc *);
usbd_status zyd_get_aw_pt_bi(struct zyd_softc *, struct zyd_aw_pt_bi *);
usbd_status zyd_set_aw_pt_bi(struct zyd_softc *, struct zyd_aw_pt_bi *);
usbd_status zyd_set_beacon_interval(struct zyd_softc *, uint32_t);
const char *zyd_rf_name(uint8_t);
usbd_status zyd_read_rf_pa_types(struct zyd_softc *, uint8_t *, uint8_t *);

usbd_status zyd_rf_rfmd_init(struct zyd_softc *, struct zyd_rf *);
usbd_status zyd_rf_rfmd_switchradio(struct zyd_softc *, uint8_t);
usbd_status zyd_rf_rfmd_set_channel(struct zyd_softc *, struct zyd_rf *, uint8_t);

usbd_status zyd_rf_al2230_init(struct zyd_softc *, struct zyd_rf *);
usbd_status zyd_rf_al2230_switchradio(struct zyd_softc *, uint8_t);
usbd_status zyd_rf_al2230_set_channel(struct zyd_softc *, struct zyd_rf *, uint8_t);

usbd_status zyd_rf_init_hw(struct zyd_softc *, struct zyd_rf *, uint8_t);

usbd_status zyd_hw_init(struct zyd_softc *, struct ieee80211com *);
usbd_status zyd_get_e2p_mac_addr(struct zyd_softc *, struct zyd_macaddr *);
usbd_status zyd_set_mac_addr(struct zyd_softc *, const struct zyd_macaddr *);
usbd_status zyd_read_regdomain(struct zyd_softc *, uint8_t *);
int zyd_regdomain_supported(uint8_t);

int zyd_tblreader(struct zyd_softc *, uint8_t *, size_t, uint32_t, uint32_t);
int zyd_readcaltables(struct zyd_softc *);

int zyd_reset_channel(struct zyd_softc *);
usbd_status zyd_set_encryption_type(struct zyd_softc *, uint32_t);
usbd_status zyd_switch_radio(struct zyd_softc *, uint8_t);
usbd_status zyd_enable_hwint(struct zyd_softc *);
usbd_status zyd_disable_hwint(struct zyd_softc *);
usbd_status zyd_set_basic_rates(struct zyd_softc *, int);
usbd_status zyd_set_mandatory_rates(struct zyd_softc *, int);
usbd_status zyd_reset_mode(struct zyd_softc *);
usbd_status zyd_set_bssid(struct zyd_softc *, uint8_t *);
usbd_status zyd_complete_attach(struct zyd_softc *);
int zyd_media_change(struct ifnet *);
int zyd_newstate(struct ieee80211com *, enum ieee80211_state, int);
int zyd_initial_config(struct zyd_softc *);
void zyd_update_promisc(struct zyd_softc *);
uint16_t zyd_txtime(int, int, uint32_t);
uint8_t zyd_plcp_signal(int);
uint16_t zyd_calc_useclen(int, uint16_t, uint8_t *);

void zyd_setup_tx_desc(struct zyd_softc *, struct zyd_controlsetformat *,
	struct mbuf *, int, int);

int zyd_tx_mgt(struct zyd_softc *, struct mbuf *, struct ieee80211_node *);
int zyd_tx_data(struct zyd_softc *, struct mbuf *, struct ieee80211_node *);
int	zyd_tx_bcn(struct zyd_softc *, struct mbuf *, struct ieee80211_node *);
d210 1
a210 1
void zyd_set_chan(struct zyd_softc *, struct ieee80211_channel *);
d213 5
a217 5
int	zyd_if_init(struct ifnet *);
/*void zyd_if_stop(struct ifnet *, int);*/
void zyd_if_start(struct ifnet *);
int	zyd_if_ioctl(struct ifnet *, u_long, caddr_t);
void zyd_if_watchdog(struct ifnet *);
d219 2
a220 2
void zyd_next_scan(void *);
void zyd_task(void *);
@


1.3
log
@avoid multiple detach problems; ich@@florian-stoehr.de
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.2 2006/06/21 18:49:20 deraadt Exp $	*/
d86 20
a1460 1
	int i;
d1465 2
a1466 9
	for (i = 0; i < sizeof(zyd_devs)/sizeof(zyd_devs[0]); i++) {
		struct zyd_type *t = &zyd_devs[i];

		if ((uaa->vendor == t->vid) && (uaa->product == t->pid)) {
			return (UMATCH_VENDOR_PRODUCT);
		}
	}

	return (UMATCH_NONE);
@


1.2
log
@minimal knf and cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_zyd.c,v 1.1 2006/06/21 18:45:11 deraadt Exp $	*/
d886 1
a886 2
	usbd_abort_pipe(sc->zyd_ep[ZYD_ENDPT_IIN]);
	usbd_close_pipe(sc->zyd_ep[ZYD_ENDPT_IIN]);
d888 5
a892 8
	usbd_abort_pipe(sc->zyd_ep[ZYD_ENDPT_IOUT]);
	usbd_close_pipe(sc->zyd_ep[ZYD_ENDPT_IOUT]);

	usbd_abort_pipe(sc->zyd_ep[ZYD_ENDPT_BIN]);
	usbd_close_pipe(sc->zyd_ep[ZYD_ENDPT_BIN]);

	usbd_abort_pipe(sc->zyd_ep[ZYD_ENDPT_BOUT]);
	usbd_close_pipe(sc->zyd_ep[ZYD_ENDPT_BOUT]);
d897 4
a900 2
	free(sc->ibuf, M_USBDEV);
	sc->ibuf = NULL;
d1517 1
d2642 5
a2646 2
	ieee80211_ifdetach(ifp);
	if_detach(ifp);
@


1.1
log
@a good start at a driver for the Zydas ZD1211 802.11 devices by
ich@@florian-stoehr.de.  Apparently it can receive now.  Contact him
if you want to help, or need the firmware image.
@
text
@d1 1
a1 1
/* $Id: if_zyd.c,v 1.7 2006/06/21 18:34:25 stoehr Exp $ */
d18 1
a18 1
 
d22 1
a22 1
 
d92 1
a92 1
usbd_status zyd_usbrequest(struct zyd_softc *, uint8_t, uint8_t, 
d111 1
a111 1
usbd_status zyd_batchwrite16(struct zyd_softc *, 
d113 1
a113 1
usbd_status zyd_batchwrite32(struct zyd_softc *, 
d200 2
a201 2
	
 	for (i = 0; i < len; i++) {
d203 1
a203 1
		
d205 1
a205 1
		    DPRINTF(("\n"));
d207 1
a207 1
	
d215 1
a215 1
uint16_t 
d221 1
a221 1
	
d223 1
a223 1
	
d225 14
a238 14
		case ZYD_RANGE_USB:
			break;
			
		case ZYD_RANGE_CTL:
			add = ZYD_CTRL_START_ADDR;
			break;
			
		case ZYD_RANGE_E2P:
			add = ZYD_E2P_START_ADDR;
			break;
			
		case ZYD_RANGE_FW:
			add = sc->firmware_base;
			break;		
d240 1
a240 1
	
d244 1
a244 1
/*	DPRINTF(("mangled = %x, add = %x, blubb = %x, result = %x\n", 
d246 1
a246 1
	
d250 1
a250 1
 
d255 1
a255 1
zyd_usbrequest(struct zyd_softc *sc, uint8_t type, uint8_t request, 
d305 1
a305 1
	
d335 2
a336 2
 */ 
usbd_status 
d343 1
a343 1
	
d353 1
a353 1
	
d355 1
a355 1
	
d361 1
a361 1
 */ 
d368 1
a368 1
	
d378 1
a378 1
	
d386 1
a386 1
zydintr(usbd_xfer_handle xfer, usbd_private_handle thehandle, 
d394 1
a394 1
	
d403 1
a403 1
			
d411 1
a411 1
	
d414 1
a414 1
	
d419 1
a419 1
	
d429 1
a429 1
	
d432 1
a432 1
 
d440 1
a440 1
	
d442 1
a442 1
	
d467 2
a468 2
	
	/* 
d470 1
a470 1
	 * of 2 bytes address + 2 bytes data. Plus some 
d472 1
a472 1
	 */	
d475 1
a475 1
		
d477 2
a478 2
	ndflush(&sc->q_reply, sc->q_reply.c_cc);		
		
d497 1
a497 1
	
d499 1
a499 1
	
d509 1
a509 1
		
d518 2
a519 2
	
/*	DPRINTF(("zyd_usb_intr_write: err = %d, size = %d, size1 = %d\n", 
d521 1
a521 1
		
d523 1
a523 1
	
d525 2
a526 2
} 
 
d530 1
a530 1
uint32_t 
d535 1
a535 1
	
d537 1
a537 1
	
d544 1
a544 1
int 
d553 1
a553 1
int 
d570 1
a570 1
	
d573 1
a573 1
	
d575 1
a575 1
	
d579 1
a579 1
	s = splnet();		
d583 1
a583 1
	
d603 1
a603 1
	
d605 1
a605 1
	
d608 1
a608 1
	
d610 1
a610 1
	
d616 1
a616 1
	
d621 1
a621 1
	
d623 2
a624 2
		data[i] = 
		    (UGETW(op.registers[i * 2].data) << 16) | 
d627 1
a627 1
	
d634 1
a634 1
usbd_status 
d643 1
a643 1
usbd_status 
d660 1
a660 1
	
d662 1
a662 1
	
d664 1
a664 1
	
d669 1
a669 1
	
d673 1
a673 1
	
d689 1
a689 1
	
d691 1
a691 1
	
d693 1
a693 1
	
d695 1
a695 1
	
d700 1
a700 1
		
d704 1
a704 1
		
d708 1
a708 1
	
d722 1
a722 1
	
d724 1
a724 1
	
d726 1
a726 1
	
d730 1
a730 1
		
d734 1
a734 1
	
d748 1
a748 1
	
d750 1
a750 1
	
d756 1
a756 1
		
d760 1
a760 1
	
d767 1
a767 1
usbd_status 
d774 1
a774 1
	
d776 1
a776 1
	
d778 1
a778 1
	
d781 1
a781 1
		
d784 1
a784 1
	
d787 1
a787 1
	
d790 1
a790 1
		
d794 1
a794 1
	
d797 1
a797 1
		
d800 1
a800 1
			
d803 1
a803 1
	
d805 1
a805 1
	
d807 1
a807 1
	
d812 1
a812 1
} 
d823 1
a823 1
	
d826 1
a826 1
	
d829 1
a829 1
	if (isize == 0)	/* shouldn't happen */	
d833 1
a833 1
			 
d836 1
a836 1
		
d838 1
a838 1
	    USBD_SHORT_XFER_OK, &sc->zyd_ep[ZYD_ENDPT_IIN], 
d846 1
a846 1
	
d848 1
a848 1
	err = usbd_open_pipe(sc->zyd_iface, sc->zyd_ed[ZYD_ENDPT_IOUT], 
d858 1
a858 1
	err = usbd_open_pipe(sc->zyd_iface, sc->zyd_ed[ZYD_ENDPT_BIN], 
d860 1
a860 1
		
d866 1
a866 1
		
d868 1
a868 1
	err = usbd_open_pipe(sc->zyd_iface, sc->zyd_ed[ZYD_ENDPT_BOUT], 
d870 1
a870 1
		
d908 1
a908 1
int 
d920 1
a920 1
		
d930 1
a930 1
			
d941 1
a941 1
fail:	
d984 1
a984 1
		
d1000 1
a1000 1
		
d1009 1
a1009 1
		
d1022 1
a1022 1
fail:	
d1056 1
a1056 1
	
d1066 1
a1066 1
	
d1074 1
a1074 1
	
d1107 1
a1107 1
	
d1139 1
a1139 1
	
d1162 1
a1162 1
	
d1169 1
a1169 1
	
d1172 3
a1174 3
	
	/* 
	 * TODO: Signal strength and quality have to be calculated in 
d1176 2
a1177 2
	 */	
	
d1195 1
a1195 1
	
d1203 1
a1203 1
	
d1237 1
a1237 1
void 
d1248 1
a1248 1
	
d1257 1
a1257 1
			
d1262 1
a1262 1
	
d1265 1
a1265 1
	
d1267 2
a1268 2
	
	/* 
d1278 1
a1278 1
	
d1282 1
a1282 1
		
d1286 1
a1286 1
		
d1288 1
a1288 1
		
d1291 1
a1291 1
		
d1294 1
a1294 1
			
d1298 1
a1298 1
		
d1300 1
a1300 1
		
d1303 4
a1306 4
		zyd_rxframeproc(data, data->buf + ZYD_PLCP_HDR_SIZE, 
		    len - ZYD_PLCP_HDR_SIZE);		
	}	
	
d1309 1
a1309 1
	
d1317 1
a1317 1
	
d1327 1
a1327 1
	
d1331 1
a1331 1
	usbd_setup_xfer(xfer, sc->zyd_ep[ZYD_ENDPT_BIN], data, data->buf, 
a1332 1
	    
d1345 1
a1345 1
int 
d1354 1
a1354 1
	
d1359 1
a1359 1
	
d1361 1
a1361 1
	
d1367 1
a1367 1
	}	
d1370 1
a1370 1
	
d1372 1
a1372 1
	
d1377 1
a1377 1
		
d1382 1
a1382 1
		
d1386 1
a1386 1
				
d1390 1
a1390 1
		
d1393 2
a1394 2
		
		zc.value += (uint16_t)(tlen / 2); /* Requires word */	  
d1396 1
a1396 1
	
d1398 1
a1398 1
	memset(&zc, 0, sizeof(struct zyd_control));	
d1404 1
a1404 1
	
d1412 1
a1412 1
	
a1423 2
	
	result = 0;	
d1425 3
a1427 1
cleanup:	
d1429 1
a1429 1
	
d1439 1
a1439 1
 */ 
d1455 1
a1455 1
	
d1458 1
a1458 1
 
d1475 1
a1475 1
	
d1477 1
a1477 1
	
d1479 1
a1479 1
		printf("%s: device version mismatch: 0x%X (only 43.30 supported)\n", 
d1486 1
a1486 1
	
d1489 1
a1489 1
			
d1494 1
a1494 1
	
d1498 1
a1498 1
			
d1508 1
a1508 1
	
d1512 1
a1512 1
	
d1515 2
a1516 2
	
	/* Complete the attach process (hardware init) */	
d1530 3
a1532 3
	
	zyd_singleregread32(sc, ZYD_MAC_MISC, &temp);	
	temp &= ~ZYD_UNLOCK_PHY_REGS;	
d1543 3
a1545 3
	
	zyd_singleregread32(sc, ZYD_MAC_MISC, &temp);	
	temp |= ZYD_UNLOCK_PHY_REGS;	
d1552 1
a1552 1
usbd_status 
d1559 1
a1559 1
	
d1568 1
a1568 1
		DPRINTF(("aw %u pt %u bi %u\n", s->atim_wnd_period, 
d1571 1
a1571 1
	
d1574 1
a1574 1
	
d1578 1
a1578 1
usbd_status 
d1587 1
a1587 1
		
d1590 1
a1590 1
		
d1593 1
a1593 1
		
d1611 1
a1611 1
	
d1614 1
a1614 1
		
d1617 1
a1617 1
	
d1625 1
a1625 1
const char * 
d1630 1
a1630 1
		
d1637 2
a1638 2
usbd_status 
zyd_read_rf_pa_types(struct zyd_softc *sc, uint8_t *rf_type, 
d1646 1
a1646 1
	
d1648 1
a1648 1
	
d1652 2
a1653 2
	
		printf("%s: Radio %s (%#01x), PA %#01x\n", 
d1739 1
a1739 1
	
d1742 1
a1742 1
	
d1746 1
a1746 1
		
d1754 1
a1754 1
		
d1779 1
a1779 1
	
d1781 1
a1781 1
		return zyd_batchwrite16(sc, ir_on, (sizeof(ir_on) / 
d1784 1
a1784 1
	return zyd_batchwrite16(sc, ir_off, (sizeof(ir_off) / 
d1792 1
a1792 1
zyd_rf_rfmd_set_channel(struct zyd_softc *sc, struct zyd_rf *rf, 
d1810 1
a1810 1
	}; 
d1815 1
a1815 1
	
d1817 1
a1817 1
	
d1822 1
a1822 1
		
d1854 1
a1854 1
zyd_rf_al2230_set_channel(struct zyd_softc *sc, struct zyd_rf *rf, 
d1863 1
a1863 1
usbd_status 
d1869 18
a1886 19
		case ZYD_RF_RFMD:
			rf->init_hw = zyd_rf_rfmd_init;
			rf->switch_radio = zyd_rf_rfmd_switchradio;
			rf->set_channel = zyd_rf_rfmd_set_channel;
			break;
			
		case ZYD_RF_AL2230:
			rf->init_hw = zyd_rf_al2230_init;
			rf->switch_radio = zyd_rf_al2230_switchradio;
			rf->set_channel = zyd_rf_al2230_set_channel;
			break;
			
		default:
			printf("%s: Sorry, radio %s is not supported yet\n", 
			    USBDEVNAME(sc->zyd_dev), zyd_rf_name(type));
		
			rf->type = 0;
			rv = USBD_INVAL; 
			goto leave;
d1895 1
a1895 1
	
d1903 1
a1903 1
usbd_status 
d1998 1
a1998 1
	
d2003 1
a2003 1
		
d2005 2
a2006 2
		
	rv = zyd_singleregread16(sc, ZYD_REG_USB(ZYD_FIRMWARE_BASE_ADDR), 
d2008 1
a2008 1
		
d2010 1
a2010 1
	
d2016 1
a2016 1
		
d2019 1
a2019 1
	printf("%s: Firmware version is 0x%04X\n", 
d2021 1
a2021 1
		
d2026 1
a2026 1
		
d2033 1
a2033 1
		
d2035 3
a2037 3
	
	zyd_set_mandatory_rates(sc, ic->ic_curmode);	
	
d2040 3
a2042 3
	/* PHY init ("reset") */		
	zyd_lock_phy(sc);	
	rv = zyd_batchwrite16(sc, ir1, 
d2045 1
a2045 1
		
d2048 1
a2048 1
		
d2052 1
a2052 1
	rv = zyd_batchwrite32(sc, ir2, 
d2057 1
a2057 1
		
d2067 1
a2067 1
	
d2078 1
a2078 1
		
d2097 1
a2097 1
	
d2099 1
a2099 1
	
d2107 1
a2107 1
	
d2114 1
a2114 1
	
d2116 2
a2117 2
	    USBDEVNAME(sc->zyd_dev), mac_addr->addr[0], mac_addr->addr[1], 
	    mac_addr->addr[2], mac_addr->addr[3], mac_addr->addr[4], 
d2127 1
a2127 1
usbd_status 
d2132 1
a2132 1
	
d2135 1
a2135 1
	
d2139 1
a2139 1
		
d2142 1
a2142 1
		
d2149 1
a2149 1
usbd_status 
d2166 1
a2166 1
int 
d2170 1
a2170 1
	
d2172 1
a2172 1
	
d2178 1
a2178 1
		
d2181 1
a2181 1
	
d2188 1
a2188 1
int 
d2198 1
a2198 1
		
d2201 1
a2201 1
			
d2203 1
a2203 1
		
d2211 1
a2211 1
		
d2214 1
a2214 1
			
d2229 1
a2229 1
	
d2238 1
a2238 1
		 
d2241 1
a2241 1
		
d2247 1
a2247 1
		
a2250 1
		    
d2262 1
a2262 1
int 
d2266 1
a2266 1
	
d2268 1
a2268 1
	
d2280 1
a2280 1
		
d2283 1
a2283 1
	
d2299 1
a2299 1
usbd_status 
d2303 1
a2303 1
	
d2307 1
a2307 1
	
d2342 12
a2353 12
		case IEEE80211_MODE_11B:
			/* 11B: 1, 2 MBPS */
			outf = 3;
			break;
		
		case IEEE80211_MODE_11G:
			/* 11G: 6, 12, 24 MBPS */
			outf = (21 << 8);
			break;		
			
		default:
			return -1;
d2355 1
a2355 1
	
d2368 18
a2385 17
		case IEEE80211_MODE_11B:
			/* 11B: 1, 2, 5.5, 11 */
			outf = CSF_RT_CCK_1 | CSF_RT_CCK_2 | CSF_RT_CCK_5_5 | CSF_RT_CCK_11;
			break;
		
		case IEEE80211_MODE_11G:
			/* 11G: 6, 9, 12, 18, 24, 36, 48, 54 */
			outf = CSF_RT_OFDM_6 | CSF_RT_OFDM_9 | CSF_RT_OFDM_12 | CSF_RT_OFDM_18
				| CSF_RT_OFDM_24 | CSF_RT_OFDM_36 | CSF_RT_OFDM_48 | CSF_RT_OFDM_54;
			break;
			
		default:
			return -1;
	}
	
	return zyd_singleregwrite32(sc, ZYD_MAC_MANDATORYRATE, outf);
}
d2404 1
a2404 1
	
d2409 1
a2409 1
 
d2414 1
a2414 1
usbd_status 
d2420 1
a2420 1
	
d2423 1
a2423 1
	
d2425 1
a2425 1
	
d2427 1
a2427 1
	
d2429 1
a2429 1
	
d2432 1
a2432 1
	
d2452 1
a2452 1
	
d2458 2
a2459 2
	 */	
	 
d2461 1
a2461 1
	 
d2464 1
a2464 1
		
a2467 1
			    
d2470 1
a2470 1
		
d2472 1
a2472 1
		
d2475 1
a2475 1
			
d2482 1
a2482 1
			
d2496 1
a2496 1
	 
d2499 1
a2499 1
	
d2502 1
a2502 1
	
d2508 1
a2508 1
	
d2511 1
a2511 1
	
d2514 1
a2514 1
	
d2524 1
a2524 1
		
d2530 2
a2531 2
		
	DPRINTF(("Loading regdomain\n"));		
d2537 1
a2537 1
		
d2542 1
a2542 1
			   
d2546 1
a2546 1
	
d2548 1
a2548 1
	
d2556 1
a2556 1
	
d2561 1
a2561 1
	
d2567 1
a2567 1
	
d2572 1
a2572 1
	
d2575 2
a2576 2
	ic->ic_sup_rates[IEEE80211_MODE_11G] = zyd_rateset_11g;	
	
d2618 1
a2618 1
	return rv;	
d2629 1
a2629 1
	
d2631 1
a2631 1
	
d2634 2
a2635 2
   	usb_rem_task(sc->zyd_udev, &sc->sc_task);
	
d2637 1
a2637 1
	
d2639 1
a2639 1
	
d2657 1
a2657 1
	
d2698 2
a2699 2
	
	DPRINTF(("Setting mac-addr\n"));	
d2704 1
a2704 1
		
d2709 1
a2709 1
	
d2712 1
a2712 1
	
d2715 1
a2715 1
		
d2724 1
a2724 1
void 
d2748 1
a2748 1
		
d2759 1
a2759 1
		
d2779 15
a2793 15
		/* CCK rates */
		case 2:		return 0x0;
		case 4:		return 0x1;
		case 11:	return 0x2;
		case 22:	return 0x3;

		/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
		case 12:	return 0xb;
		case 18:	return 0xf;
		case 24:	return 0xa;
		case 36:	return 0xe;
		case 48:	return 0x9;
		case 72:	return 0xd;
		case 96:	return 0x8;
		case 108:	return 0xc;
d2795 2
a2796 2
		/* unsupported rates (should not get there) */
		default:	return 0xff;
d2852 1
a2852 1
uint16_t 
d2858 1
a2858 1
	
d2863 55
a2917 14
		case 2:	/* 1M bps */
			leninus = len << 3;
			break;
			
		case 4:	/* 2M bps */
			leninus = len << 2;
			break;
			
		case 11: /* 5.5M bps */
			leninus = (uint16_t)(((uint32_t)len << 4) / 11);
			remainder = (((uint32_t)len << 4) % 11);
			
			if (remainder)
				leninus += 1;
d2919 3
a2921 46
			break;
			
		case 22: /* 11M bps */
			leninus = (uint16_t)(((uint32_t)len << 3) / 11);
			remainder = (((uint32_t)len << 3) % 11);
			delta = 11 - remainder;
			
			if (remainder) {
				leninus += 1;
				
				if (delta >= 8)
					*(service) |= 0x80; /* Bit 7 */
			}
			break;
		
		case 12:/* 6M */
			leninus = (uint16_t)(((uint32_t)len << 3) / 6);
			break;
			
		case 18:/* 9M */
			leninus = (uint16_t)(((uint32_t)len << 3) / 9);
			break;
			
		case 24:/* 12M */
			leninus = (uint16_t)(((uint32_t)len << 3) / 12);
			break;
			
		case 36:/* 18M */
			leninus = (uint16_t)(((uint32_t)len << 3) / 18);
			break;
			
		case 48:/* 24M */
			leninus = (uint16_t)(((uint32_t)len << 3) / 24);
			break;
			
		case 72:/* 36M */
			leninus = (uint16_t)(((uint32_t)len << 3) / 36);
			break;
			
		case 96:/* 48M */
			leninus = (uint16_t)(((uint32_t)len << 3) / 48);
			break;
			
		case 108: /* 54M */
			leninus = (uint16_t)(((uint32_t)len << 3) / 54);
			break;
d2923 1
a2923 1
	
d2940 1
a2940 1
	
d2942 1
a2942 1
	DPRINTF(("sizeof (zyd_controlsetformat) = %d\n", 
d2944 1
a2944 1
	
d2946 1
a2946 1
	
d2949 1
a2949 1
	
d2955 1
a2955 1
		
d2961 1
a2961 1
	
d2964 2
a2965 2
	
	/* 
d2967 1
a2967 1
	 * 802.11 MAC header length + raw data length 
d2969 1
a2969 1
	 */	
d2972 1
a2972 1
	
d2978 1
a2978 1
		desc->needbackoff = CSF_BO_RAND;	
d2983 1
a2983 1
	
d2986 7
a2992 3
		case IEEE80211_FC0_TYPE_DATA:
			desc->frametype = CSF_FT_DATAFRAME;
			break;
d2994 5
a2998 14
		case IEEE80211_FC0_TYPE_MGT:
			desc->frametype = CSF_FT_MGMTFRAME;
			break;
			
		case IEEE80211_FC0_TYPE_CTL:
			/* Only subtype PS_POLL has seq control */
			if (subtype == IEEE80211_FC0_SUBTYPE_PS_POLL)
				desc->frametype = CSF_FT_POLLFRAME;
			else
				desc->frametype = CSF_FT_NOSEQCONTROL;
			break;
			
		/* All other don't have a sequence control field */
		default:
d3000 5
d3006 1
a3006 1
	
d3008 2
a3009 2
	
	/* 
d3022 1
a3022 1
			desc->rts = CSF_RTS_NEEDRTSFRAME;	
d3024 1
a3024 1
	
d3026 2
a3027 2
	
	/* 
d3030 2
a3031 2
	 */	 
	
d3035 1
a3035 1
		
d3040 1
a3040 1
	
d3046 2
a3047 2
		zyd_calc_useclen(rate, txlen, &desc->service));	
	
d3051 1
a3051 1
		
d3065 1
a3065 1
void 
d3069 2
a3070 2
		ZYD_FW_FIRMWARE_VER, 
		ZYD_FW_USB_SPEED, 
d3078 1
a3078 1
	
d3098 1
a3098 1
	
d3106 1
a3106 1
	
d3108 1
a3108 1
	
d3125 1
a3125 1
/*		// tell hardware to add timestamp for probe responses 
d3133 2
a3134 2
	
	
a3137 1
	
d3139 3
a3141 2
	DPRINTF(("Raw dump before desc setup:\n"));	
	
d3147 1
a3147 1
	// xfer length needs to be a multiple of two! 
d3153 1
a3153 1
	
d3156 1
a3156 1
		
d3158 1
a3158 1
		
d3161 2
a3162 2
	usbd_setup_xfer(data->xfer, sc->zyd_ep[ZYD_ENDPT_BOUT], data, 
	    data->buf, xferlen, USBD_FORCE_SHORT_XFER | USBD_NO_COPY, 
d3166 1
a3166 1
	
d3174 1
a3174 1
	
d3176 1
a3176 1
	
d3209 1
a3209 1
	
d3235 1
a3235 1
	// xfer length needs to be a multiple of two! 
d3241 2
a3242 2
	usbd_setup_xfer(data->xfer, sc->zyd_ep[ZYD_ENDPT_BOUT], data, 
	    data->buf, xferlen, USBD_FORCE_SHORT_XFER | USBD_NO_COPY, 
d3246 1
a3246 1
	
d3278 1
a3278 1
	
d3286 1
a3286 1
	
d3296 1
a3296 1
	
d3329 1
a3329 1
	
d3333 1
a3333 1
	
d3335 1
a3335 1
	
d3341 1
a3341 1
		
d3343 1
a3343 1
	
d3347 1
a3347 1
	
d3350 1
a3350 1
	
d3353 2
a3354 2
	
	zyd_unlock_phy(sc);	
d3362 1
a3362 1
int	
d3371 1
a3371 1
	
d3373 1
a3373 1
	
d3377 1
a3377 1
	
d3380 1
a3380 1
	
a3383 1
		    
d3387 1
a3387 1
	
d3391 1
a3391 1
	
d3403 2
a3404 2
	zyd_set_chan(sc, ic->ic_bss->ni_chan);	
	
d3409 1
a3409 1
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));	
d3417 1
a3417 1
	
d3423 1
a3423 1
	
a3426 1
		    
d3432 1
a3432 1
	
a3435 1
		    
d3446 2
a3447 2
		usbd_setup_xfer(data->xfer, sc->zyd_ep[ZYD_ENDPT_BIN], data, 
		    data->buf, MCLBYTES, USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, 
d3449 1
a3449 1
			
d3472 1
a3472 1
	
d3475 1
a3475 1
	
d3488 1
a3488 1
void 
d3493 1
a3493 1
	
d3511 1
a3511 1
void 
d3525 1
a3525 1
			DPRINTF(("zyd_if_start: m0 != NULL, tx_queued = %d\n", 
d3527 1
a3527 1
		
d3532 1
a3532 1
			
d3537 1
a3537 1
			
d3548 1
a3548 1
			
d3551 1
a3551 1
			
d3554 1
a3554 1
			
d3556 1
a3556 1
			
d3564 1
a3564 1
			
d3569 1
a3569 1
			DPRINTF(("if_state: @@6\n"));			
d3572 1
a3572 1
			
d3580 1
a3580 1
			
d3587 1
a3587 1
			
d3605 1
a3605 1
int	
d3613 1
a3613 1
	
d3617 1
a3617 1
	
d3619 21
a3639 21
		case SIOCSIFADDR:
			ifa = (struct ifaddr *)data;
			ifp->if_flags |= IFF_UP;
	#ifdef INET
			if (ifa->ifa_addr->sa_family == AF_INET)
				arp_ifinit(&ic->ic_ac, ifa);
	#endif
			/* FALLTHROUGH */

		case SIOCSIFFLAGS:
			DPRINTF(("IOCTL: SIOCSIFFLAGS\n"));
			if (ifp->if_flags & IFF_UP) {
				if (ifp->if_flags & IFF_RUNNING)
					zyd_update_promisc(sc);
				else
					zyd_if_init(ifp);
			} else {
/*				if (ifp->if_flags & IFF_RUNNING)
					zyd_if_stop(ifp, 1);*/
			}
			break;
d3641 7
a3647 7
		case SIOCADDMULTI:
		case SIOCDELMULTI:
			DPRINTF(("IOCTL: SIOCADDMULTI\n"));
			ifr = (struct ifreq *)data;
			err = (command == SIOCADDMULTI) ?
			    ether_addmulti(ifr, &ic->ic_ac) :
			    ether_delmulti(ifr, &ic->ic_ac);
d3649 3
a3651 3
			if (err == ENETRESET)
				err = 0;
			break;
d3660 1
a3660 1
		 
a3672 1
			    
a3681 1
			    
d3690 1
a3690 1
	
d3697 1
a3697 1
void 
d3728 1
a3728 1
	
d3757 1
a3757 1
		
d3774 1
a3774 1
		
d3781 1
a3781 1
			
a3784 1
				    
a3791 1
				    
@

