head	1.86;
access;
symbols
	OPENBSD_6_1_BASE:1.86
	OPENBSD_6_0:1.84.0.6
	OPENBSD_6_0_BASE:1.84
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.83.0.4
	OPENBSD_5_8_BASE:1.83
	OPENBSD_5_7:1.81.0.2
	OPENBSD_5_7_BASE:1.81
	OPENBSD_5_6:1.80.0.4
	OPENBSD_5_6_BASE:1.80
	OPENBSD_5_5:1.79.0.4
	OPENBSD_5_5_BASE:1.79
	OPENBSD_5_4:1.76.0.2
	OPENBSD_5_4_BASE:1.76
	OPENBSD_5_3:1.71.0.2
	OPENBSD_5_3_BASE:1.71
	OPENBSD_5_2:1.69.0.2
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.68
	OPENBSD_5_1:1.68.0.4
	OPENBSD_5_0:1.68.0.2
	OPENBSD_5_0_BASE:1.68
	OPENBSD_4_9:1.67.0.2
	OPENBSD_4_9_BASE:1.67
	OPENBSD_4_8:1.60.0.2
	OPENBSD_4_8_BASE:1.60
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19;
locks; strict;
comment	@ * @;


1.86
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.85;
commitid	x5RWYO05Q3UFL5Oq;

1.85
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.84;
commitid	xlY19nmD0cBL53l1;

1.84
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.83;
commitid	fbhqfhfdKxBcsetK;

1.83
date	2015.05.02.10.44.29;	author jsg;	state Exp;
branches;
next	1.82;
commitid	bVmCCZZhAZIaB19k;

1.82
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.81;
commitid	p4LJxGKbi0BU2cG6;

1.81
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.80;
commitid	zM5ckwX4kwwmipG0;

1.80
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.79;
commitid	OBNa5kfxQ2UXoiIw;

1.79
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2013.10.21.10.36.26;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2013.10.20.20.07.31;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2013.04.26.14.28.39;	author mpi;	state Exp;
branches;
next	1.74;

1.74
date	2013.04.17.17.49.58;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.72;

1.72
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.71;

1.71
date	2012.09.18.17.24.51;	author jasper;	state Exp;
branches;
next	1.70;

1.70
date	2012.09.18.17.11.41;	author jasper;	state Exp;
branches;
next	1.69;

1.69
date	2012.03.26.19.12.54;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.66;

1.66
date	2010.12.27.03.03.50;	author jakemsr;	state Exp;
branches;
next	1.65;

1.65
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2010.10.16.07.06.20;	author maja;	state Exp;
branches;
next	1.63;

1.63
date	2010.10.10.11.11.54;	author mglocker;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.27.19.49.43;	author thib;	state Exp;
branches;
next	1.61;

1.61
date	2010.08.31.17.00.05;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2010.07.29.12.37.16;	author maja;	state Exp;
branches;
next	1.59;

1.59
date	2010.07.19.15.59.11;	author maja;	state Exp;
branches;
next	1.58;

1.58
date	2010.06.27.01.15.04;	author maja;	state Exp;
branches;
next	1.57;

1.57
date	2010.06.01.04.53.17;	author mglocker;	state Exp;
branches;
next	1.56;

1.56
date	2010.04.12.19.42.02;	author mglocker;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.11.12.38.23;	author mglocker;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.10.08.59.18;	author maja;	state Exp;
branches;
next	1.52;

1.52
date	2009.09.27.18.17.45;	author mglocker;	state Exp;
branches;
next	1.51;

1.51
date	2009.09.26.09.46.51;	author mglocker;	state Exp;
branches;
next	1.50;

1.50
date	2009.09.21.07.41.18;	author mglocker;	state Exp;
branches;
next	1.49;

1.49
date	2009.09.20.11.24.02;	author mglocker;	state Exp;
branches;
next	1.48;

1.48
date	2009.09.20.10.56.02;	author mglocker;	state Exp;
branches;
next	1.47;

1.47
date	2009.09.20.10.18.20;	author mglocker;	state Exp;
branches;
next	1.46;

1.46
date	2009.09.19.21.48.34;	author mglocker;	state Exp;
branches;
next	1.45;

1.45
date	2009.09.19.21.43.14;	author mglocker;	state Exp;
branches;
next	1.44;

1.44
date	2009.09.19.21.34.40;	author mglocker;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.19.20.49.53;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.19.11.54.16;	author mglocker;	state Exp;
branches;
next	1.41;

1.41
date	2009.09.13.18.16.15;	author mglocker;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.13.10.40.08;	author mglocker;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.13.08.59.09;	author mglocker;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.13.08.11.52;	author mglocker;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.12.21.52.25;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.12.12.27.09;	author mglocker;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.11.20.12.51;	author mglocker;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.09.07.01.20;	author mglocker;	state Exp;
branches;
next	1.33;

1.33
date	2009.09.06.12.25.38;	author mglocker;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.06.10.36.04;	author mglocker;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.05.20.35.30;	author mglocker;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.30.12.05.23;	author maja;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.29.08.19.22;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.27.19.43.50;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.26.19.30.46;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.26.19.07.45;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.26.12.23.39;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.25.19.46.51;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.09.20.10.08;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.02.10.38.34;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.23.18.28.28;	author maja;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.06.16.56.56;	author yuo;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.01.18.21.51;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.01.18.07.55;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.01.17.41.27;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.01.15.47.38;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.01.15.28.16;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.01.11.26.18;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.31.18.26.44;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.24.11.11.03;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.24.11.05.16;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.22.16.03.39;	author maja;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.21.16.26.56;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.21.12.28.29;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.18.20.21.40;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.10.19.42.54;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.10.14.53.27;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.10.09.28.58;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.09.20.06.38;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.09.19.23.07;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.86
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@/*	$OpenBSD: udl.c,v 1.85 2016/11/06 12:58:01 mpi Exp $ */

/*
 * Copyright (c) 2009 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for the ``DisplayLink DL-120 / DL-160'' graphic chips based
 * on the reversed engineered specifications of Florian Echtler
 * <floe@@butterbrot.org>:
 *
 * 	http://floe.butterbrot.org/displaylink/doku.php
 *
 * This driver has been inspired by the cfxga(4) driver because we have
 * to deal with similar challenges, like no direct access to the video
 * memory.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <dev/videomode/videomode.h>
#include <dev/videomode/edidvar.h>

#include <dev/usb/udl.h>
#include <dev/usb/udlio.h>

/*
 * Defines.
 */
#if 0
#define UDL_DEBUG
#endif
#ifdef UDL_DEBUG
int udl_debug = 1;
#define DPRINTF(l, x...) do { if ((l) <= udl_debug) printf(x); } while (0)
#else
#define DPRINTF(l, x...)
#endif

#define DN(sc)		((sc)->sc_dev.dv_xname)
#define FUNC		__func__

/*
 * Prototypes.
 */
int		udl_match(struct device *, void *, void *);
void		udl_attach(struct device *, struct device *, void *);
void		udl_attach_hook(struct device *);
int		udl_detach(struct device *, int);
int		udl_activate(struct device *, int);

int		udl_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t		udl_mmap(void *, off_t, int);
int		udl_alloc_screen(void *, const struct wsscreen_descr *,
		    void **, int *, int *, long *);
void		udl_free_screen(void *, void *);
int		udl_show_screen(void *, void *, int,
		    void (*)(void *, int, int), void *);
int		udl_load_font(void *, void *, struct wsdisplay_font *);
int		udl_list_font(void *, struct wsdisplay_font *);
void		udl_burner(void *, u_int, u_int);

int		udl_copycols(void *, int, int, int, int);
int		udl_copyrows(void *, int, int, int);
int		udl_erasecols(void *, int, int, int, long);
int		udl_eraserows(void *, int, int, long);
int		udl_putchar(void *, int, int, u_int, long);
int		udl_do_cursor(struct rasops_info *);
int		udl_draw_char(struct udl_softc *, uint16_t, uint16_t, u_int,
		    uint32_t, uint32_t);
int		udl_damage(struct udl_softc *, uint8_t *,
		    uint32_t, uint32_t, uint32_t, uint32_t);
int		udl_draw_image(struct udl_softc *, uint8_t *,
		    uint32_t, uint32_t, uint32_t, uint32_t);

usbd_status	udl_ctrl_msg(struct udl_softc *, uint8_t, uint8_t,
		    uint16_t, uint16_t, uint8_t *, size_t);
usbd_status	udl_poll(struct udl_softc *, uint32_t *);
usbd_status	udl_read_1(struct udl_softc *, uint16_t, uint8_t *);
usbd_status	udl_write_1(struct udl_softc *, uint16_t, uint8_t);
usbd_status	udl_read_edid(struct udl_softc *, uint8_t *);
uint8_t		udl_lookup_mode(uint16_t, uint16_t, uint8_t, uint16_t,
		    uint32_t);
int		udl_select_chip(struct udl_softc *);
usbd_status	udl_set_enc_key(struct udl_softc *, uint8_t *, uint8_t);
usbd_status	udl_set_decomp_table(struct udl_softc *, uint8_t *, uint16_t);

int		udl_load_huffman(struct udl_softc *);
void		udl_free_huffman(struct udl_softc *);
int		udl_fbmem_alloc(struct udl_softc *);
void		udl_fbmem_free(struct udl_softc *);
usbd_status	udl_cmd_alloc_xfer(struct udl_softc *);
void		udl_cmd_free_xfer(struct udl_softc *);
int		udl_cmd_alloc_buf(struct udl_softc *);
void		udl_cmd_free_buf(struct udl_softc *);
void		udl_cmd_insert_int_1(struct udl_softc *, uint8_t);
void		udl_cmd_insert_int_2(struct udl_softc *, uint16_t);
void		udl_cmd_insert_int_3(struct udl_softc *, uint32_t);
void		udl_cmd_insert_int_4(struct udl_softc *, uint32_t);
void		udl_cmd_insert_buf(struct udl_softc *, uint8_t *, uint32_t);
int		udl_cmd_insert_buf_comp(struct udl_softc *, uint8_t *,
		    uint32_t);
int		udl_cmd_insert_head_comp(struct udl_softc *, uint32_t);
int		udl_cmd_insert_check(struct udl_softc *, int);
void		udl_cmd_set_xfer_type(struct udl_softc *, int);
void		udl_cmd_save_offset(struct udl_softc *);
void		udl_cmd_restore_offset(struct udl_softc *);
void		udl_cmd_write_reg_1(struct udl_softc *, uint8_t, uint8_t);
void		udl_cmd_write_reg_3(struct udl_softc *, uint8_t, uint32_t);
usbd_status	udl_cmd_send(struct udl_softc *);
usbd_status	udl_cmd_send_async(struct udl_softc *);
void		udl_cmd_send_async_cb(struct usbd_xfer *, void *, usbd_status);

usbd_status	udl_init_chip(struct udl_softc *);
void		udl_init_fb_offsets(struct udl_softc *, uint32_t, uint32_t,
		    uint32_t, uint32_t);
usbd_status	udl_init_resolution(struct udl_softc *);
usbd_status	udl_clear_screen(struct udl_softc *);
void		udl_select_mode(struct udl_softc *);
int		udl_fb_buf_write(struct udl_softc *, uint8_t *, uint32_t,
		    uint32_t, uint16_t);
int		udl_fb_block_write(struct udl_softc *, uint16_t, uint32_t,
		    uint32_t, uint32_t, uint32_t);
int		udl_fb_line_write(struct udl_softc *, uint16_t, uint32_t,
		    uint32_t, uint32_t);
int		udl_fb_off_write(struct udl_softc *, uint16_t, uint32_t,
		    uint16_t);
int		udl_fb_block_copy(struct udl_softc *, uint32_t, uint32_t,
		    uint32_t, uint32_t, uint32_t, uint32_t);
int		udl_fb_line_copy(struct udl_softc *, uint32_t, uint32_t,
		    uint32_t, uint32_t, uint32_t);
int		udl_fb_off_copy(struct udl_softc *, uint32_t, uint32_t,
		    uint16_t);
int		udl_fb_buf_write_comp(struct udl_softc *, uint8_t *, uint32_t,
		    uint32_t, uint16_t);
int		udl_fb_block_write_comp(struct udl_softc *, uint16_t, uint32_t,
		    uint32_t, uint32_t, uint32_t);
int		udl_fb_line_write_comp(struct udl_softc *, uint16_t, uint32_t,
		    uint32_t, uint32_t);
int		udl_fb_off_write_comp(struct udl_softc *, uint16_t, uint32_t,
		    uint16_t);
int		udl_fb_block_copy_comp(struct udl_softc *, uint32_t, uint32_t,
		    uint32_t, uint32_t, uint32_t, uint32_t);
int		udl_fb_line_copy_comp(struct udl_softc *, uint32_t, uint32_t,
		    uint32_t, uint32_t, uint32_t);
int		udl_fb_off_copy_comp(struct udl_softc *, uint32_t, uint32_t,
		    uint16_t);
#ifdef UDL_DEBUG
void		udl_hexdump(void *, int, int);
usbd_status	udl_init_test(struct udl_softc *);
#endif

/*
 * Driver glue.
 */
struct cfdriver udl_cd = {
	NULL, "udl", DV_DULL
};

const struct cfattach udl_ca = {
	sizeof(struct udl_softc),
	udl_match,
	udl_attach,
	udl_detach,
	udl_activate
};

/*
 * wsdisplay glue.
 */
struct wsscreen_descr udl_stdscreen = {
	"std",			/* name */
	0, 0,			/* ncols, nrows */
	NULL,			/* textops */
	0, 0,			/* fontwidth, fontheight */
	WSSCREEN_WSCOLORS	/* capabilities */
};

const struct wsscreen_descr *udl_scrlist[] = {
	&udl_stdscreen
};

struct wsscreen_list udl_screenlist = {
	sizeof(udl_scrlist) / sizeof(struct wsscreen_descr *), udl_scrlist
};

struct wsdisplay_accessops udl_accessops = {
	.ioctl = udl_ioctl,
	.mmap = udl_mmap,
	.alloc_screen = udl_alloc_screen,
	.free_screen = udl_free_screen,
	.show_screen = udl_show_screen,
	.load_font = udl_load_font,
	.list_font = udl_list_font,
	.burn_screen = udl_burner
};

/*
 * Matching devices.
 */
struct udl_type {
	struct usb_devno	udl_dev;
	uint16_t		udl_chip;
};

static const struct udl_type udl_devs[] = {
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LCD4300U },	DL120 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LCD8000U },	DL120 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_GUC2020 },	DL160 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LD220 },	DL165 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_VCUD60 },	DL160 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_DLDVI },	DL160 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_VGA10 },	DL120 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_WSDVI },	DLUNK },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_EC008 },	DL160 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_HPDOCK },	DL160 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_NL571 },	DL160 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_M01061 },	DL195 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_NBDOCK },	DL165 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_SWDVI },	DLUNK },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_UM7X0 },	DL120 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_CONV },	DL160 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LUM70 },	DL125 },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_POLARIS2 },	DLUNK },
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LT1421 },	DLUNK }
};
#define udl_lookup(v, p) ((struct udl_type *)usb_lookup(udl_devs, v, p))

int
udl_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return (UMATCH_NONE);

	if (udl_lookup(uaa->vendor, uaa->product) != NULL)
		return (UMATCH_VENDOR_PRODUCT);

	return (UMATCH_NONE);
}

void
udl_attach(struct device *parent, struct device *self, void *aux)
{
	struct udl_softc *sc = (struct udl_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct wsemuldisplaydev_attach_args aa;
	usbd_status error;
	int err, i;

	sc->sc_udev = uaa->device;
	sc->sc_chip = udl_lookup(uaa->vendor, uaa->product)->udl_chip;
	sc->sc_width = 0;
	sc->sc_height = 0;
	sc->sc_depth = 16;
	sc->sc_cur_mode = MAX_DL_MODES;

	/*
	 * Override chip if requested.
	 */
	if ((sc->sc_dev.dv_cfdata->cf_flags & 0xff00) > 0) {
		i = ((sc->sc_dev.dv_cfdata->cf_flags & 0xff00) >> 8) - 1;
		if (i <= DLMAX) {
			sc->sc_chip = i;
			printf("%s: %s: cf_flags (0x%04x) forced chip to %d\n",
			    DN(sc), FUNC,
			    sc->sc_dev.dv_cfdata->cf_flags, i);
		}
	}

	/*
	 * The product might have more than one chip
	 */
	if (sc->sc_chip == DLUNK)
		if (udl_select_chip(sc))
			return;


	/*
	 * Create device handle to interface descriptor.
	 */
	error = usbd_device2interface_handle(sc->sc_udev, 0, &sc->sc_iface);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/*
	 * Allocate bulk command xfer.
	 */
	error = udl_cmd_alloc_xfer(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/*
	 * Allocate command buffer.
	 */
	err = udl_cmd_alloc_buf(sc);
	if (err != 0)
		return;

	/*
	 * Open bulk TX pipe.
	 */
	error = usbd_open_pipe(sc->sc_iface, 0x01, USBD_EXCLUSIVE_USE,
	    &sc->sc_tx_pipeh);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/*
	 * Device initialization is done per synchronous xfers.
	 */
	udl_cmd_set_xfer_type(sc, UDL_CMD_XFER_SYNC);

	/*
	 * Initialize chip.
	 */
	error = udl_init_chip(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/*
	 * Select edid mode.
	 */
	udl_select_mode(sc);

	/*
	 * Override mode if requested.
	 */
	if ((sc->sc_dev.dv_cfdata->cf_flags & 0xff) > 0) {
		i = (sc->sc_dev.dv_cfdata->cf_flags & 0xff) - 1;

		if (i < MAX_DL_MODES) {
			if (udl_modes[i].chip <= sc->sc_chip) {
				sc->sc_width = udl_modes[i].hdisplay;
				sc->sc_height = udl_modes[i].vdisplay;
				printf("%s: %s: cf_flags (0x%04x) ",
				    DN(sc), FUNC,
				    sc->sc_dev.dv_cfdata->cf_flags);
				printf("forced mode to %d\n", i);
				sc->sc_cur_mode = i;
			}
		}
	}

	error = udl_init_resolution(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/*
	 * Attach wsdisplay.
	 */
	aa.console = 0;
	aa.scrdata = &udl_screenlist;
	aa.accessops = &udl_accessops;
	aa.accesscookie = sc;
	aa.defaultscreens = 0;

	sc->sc_wsdisplay = config_found(self, &aa, wsemuldisplaydevprint);

	/*
	 * Load Huffman table.
	 */
	config_mountroot(self, udl_attach_hook);
}

void
udl_attach_hook(struct device *self)
{
	struct udl_softc *sc = (struct udl_softc *)self;

	if (udl_load_huffman(sc) != 0) {
		/* compression not possible */
		printf("%s: run in uncompressed mode\n", DN(sc));
		sc->udl_fb_buf_write = udl_fb_buf_write;
		sc->udl_fb_block_write = udl_fb_block_write;
		sc->udl_fb_line_write = udl_fb_line_write;
		sc->udl_fb_off_write = udl_fb_off_write;
		sc->udl_fb_block_copy = udl_fb_block_copy;
		sc->udl_fb_line_copy = udl_fb_line_copy;
		sc->udl_fb_off_copy = udl_fb_off_copy;
	} else {
		/* compression possible */
		sc->udl_fb_buf_write = udl_fb_buf_write_comp;
		sc->udl_fb_block_write = udl_fb_block_write_comp;
		sc->udl_fb_line_write = udl_fb_line_write_comp;
		sc->udl_fb_off_write = udl_fb_off_write_comp;
		sc->udl_fb_block_copy = udl_fb_block_copy_comp;
		sc->udl_fb_line_copy = udl_fb_line_copy_comp;
		sc->udl_fb_off_copy = udl_fb_off_copy_comp;
	}
#ifdef UDL_DEBUG
	if (udl_debug >= 4)
		udl_init_test(sc);
#endif
	/*
	 * From this point on we do asynchronous xfers.
	 */
	udl_cmd_set_xfer_type(sc, UDL_CMD_XFER_ASYNC);

	/*
	 * Set initial wsdisplay emulation mode.
	 */
	sc->sc_mode = WSDISPLAYIO_MODE_EMUL;
}

int
udl_detach(struct device *self, int flags)
{
	struct udl_softc *sc = (struct udl_softc *)self;

	/*
	 * Close bulk TX pipe.
	 */
	if (sc->sc_tx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_tx_pipeh);
		usbd_close_pipe(sc->sc_tx_pipeh);
	}

	/*
	 * Free command buffer.
	 */
	udl_cmd_free_buf(sc);

	/*
	 * Free command xfer.
	 */
	udl_cmd_free_xfer(sc);

	/*
	 * Free Huffman table.
	 */
	udl_free_huffman(sc);

	/*
	 * Free framebuffer memory.
	 */
	udl_fbmem_free(sc);

	/*
	 * Detach wsdisplay.
	 */
	if (sc->sc_wsdisplay != NULL)
		config_detach(sc->sc_wsdisplay, DETACH_FORCE);

	return (0);
}

int
udl_activate(struct device *self, int act)
{
	struct udl_softc *sc = (struct udl_softc *)self;
	int rv;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	rv = config_activate_children(self, act);
	return (rv);
}

/* ---------- */

int
udl_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct udl_softc *sc;
	struct wsdisplay_fbinfo *wdf;
	struct udl_ioctl_damage *d;
	int r, error, mode;

	sc = v;

	DPRINTF(1, "%s: %s: ('%c', %d, %d)\n",
	    DN(sc), FUNC, IOCGROUP(cmd), cmd & 0xff, IOCPARM_LEN(cmd));

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_DL;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_height;
		wdf->width = sc->sc_width;
		wdf->depth = sc->sc_depth;
		wdf->cmsize = 0;	/* XXX fill up colormap size */
		break;
	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)data;
		if (mode == sc->sc_mode)
			break;
		switch (mode) {
		case WSDISPLAYIO_MODE_EMUL:
			/* clear screen */
			(void)udl_clear_screen(sc);
			break;
		case WSDISPLAYIO_MODE_DUMBFB:
			/* TODO */
			break;
		default:
			return (EINVAL);
		}
		sc->sc_mode = mode;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_width * (sc->sc_depth / 8);
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		/* handled for us by wscons */
		break;
	case UDLIO_DAMAGE:
		d = (struct udl_ioctl_damage *)data;
		d->status = UDLIO_STATUS_OK;
		r = udl_damage(sc, sc->sc_fbmem, d->x1, d->x2, d->y1, d->y2);
		if (r != 0) {
			error = tsleep(sc, 0, "udlio", hz / 100);
			if (error) {
				d->status = UDLIO_STATUS_FAILED;
			} else {
				r = udl_damage(sc, sc->sc_fbmem, d->x1, d->x2,
				    d->y1, d->y2);
				if (r != 0)
					d->status = UDLIO_STATUS_FAILED;
			}
		}
		break;
	default:
		return (-1);
	}

	return (0);
}

paddr_t
udl_mmap(void *v, off_t off, int prot)
{
	struct udl_softc *sc;
	caddr_t p;
	paddr_t pa;

	sc = v;

	DPRINTF(1, "%s: %s\n", DN(sc), FUNC);

	/* allocate framebuffer memory */
	if (udl_fbmem_alloc(sc) == -1)
		return (-1);

	/* return memory address to userland process */
	p = sc->sc_fbmem + off;
	if (pmap_extract(pmap_kernel(), (vaddr_t)p, &pa) == FALSE) {
		printf("udl_mmap: invalid page\n");
		udl_fbmem_free(sc);
		return (-1);
	}
	return (pa);
}

int
udl_alloc_screen(void *v, const struct wsscreen_descr *type,
    void **cookiep, int *curxp, int *curyp, long *attrp)
{
	struct udl_softc *sc = v;
	struct wsdisplay_font *font;

	DPRINTF(1, "%s: %s\n", DN(sc), FUNC);

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	/*
	 * Initialize rasops.
	 */
	sc->sc_ri.ri_depth = sc->sc_depth;
	sc->sc_ri.ri_bits = NULL;
	sc->sc_ri.ri_width = sc->sc_width;
	sc->sc_ri.ri_height = sc->sc_height;
	sc->sc_ri.ri_stride = sc->sc_width * sc->sc_height / 8;
	sc->sc_ri.ri_hw = (void *)sc;
	sc->sc_ri.ri_flg = 0;

	/* swap B and R at 16 bpp */
	if (sc->sc_depth == 16) {
		sc->sc_ri.ri_rnum = 5;
		sc->sc_ri.ri_rpos = 11;
		sc->sc_ri.ri_gnum = 6;
		sc->sc_ri.ri_gpos = 5;
		sc->sc_ri.ri_bnum = 5;
		sc->sc_ri.ri_bpos = 0;
	}

	rasops_init(&sc->sc_ri, 100, 200);

	sc->sc_ri.ri_ops.copycols = udl_copycols;
	sc->sc_ri.ri_ops.copyrows = udl_copyrows;
	sc->sc_ri.ri_ops.erasecols = udl_erasecols;
	sc->sc_ri.ri_ops.eraserows = udl_eraserows;
	sc->sc_ri.ri_ops.putchar = udl_putchar;
	sc->sc_ri.ri_do_cursor = udl_do_cursor;

	sc->sc_ri.ri_ops.alloc_attr(&sc->sc_ri, 0, 0, 0, attrp);

	udl_stdscreen.nrows = sc->sc_ri.ri_rows;
	udl_stdscreen.ncols = sc->sc_ri.ri_cols;
	udl_stdscreen.textops = &sc->sc_ri.ri_ops;
	udl_stdscreen.fontwidth = sc->sc_ri.ri_font->fontwidth;
	udl_stdscreen.fontheight = sc->sc_ri.ri_font->fontheight;
	udl_stdscreen.capabilities = sc->sc_ri.ri_caps;

	*cookiep = &sc->sc_ri;
	*curxp = 0;
	*curyp = 0;

	/* allocate character backing store */
	sc->sc_cbs = mallocarray(sc->sc_ri.ri_rows, sc->sc_ri.ri_cols *
	    sizeof(*sc->sc_cbs), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (sc->sc_cbs == NULL) {
		printf("%s: can't allocate mem for character backing store!\n",
		    DN(sc));
		return (ENOMEM);
	}

	sc->sc_nscreens++;

	font = sc->sc_ri.ri_font;
	DPRINTF(1, "%s: %s: using font %s (%dx%d)\n",
	    DN(sc), FUNC, font->name, sc->sc_ri.ri_cols, sc->sc_ri.ri_rows);

	return (0);
}

void
udl_free_screen(void *v, void *cookie)
{
	struct udl_softc *sc;

	sc = v;

	DPRINTF(1, "%s: %s\n", DN(sc), FUNC);

	/* free character backing store */
	if (sc->sc_cbs != NULL)
		free(sc->sc_cbs, M_DEVBUF, 0);

	sc->sc_nscreens--;
}

int
udl_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	struct udl_softc *sc;

	sc = v;

	DPRINTF(1, "%s: %s\n", DN(sc), FUNC);

	return (0);
}

int
udl_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct udl_softc *sc = v;
	struct rasops_info *ri = &sc->sc_ri;

	return rasops_load_font(ri, emulcookie, font);
}

int
udl_list_font(void *v, struct wsdisplay_font *font)
{
	struct udl_softc *sc = v;
	struct rasops_info *ri = &sc->sc_ri;

	return rasops_list_font(ri, font);
}

void
udl_burner(void *v, u_int on, u_int flags)
{
	struct udl_softc *sc;

	sc = v;

	DPRINTF(1, "%s: %s: screen %s\n", DN(sc), FUNC, on ? "ON" : "OFF");

	if (on)
		udl_cmd_write_reg_1(sc, UDL_REG_SCREEN, UDL_REG_SCREEN_ON);
	else
		udl_cmd_write_reg_1(sc, UDL_REG_SCREEN, UDL_REG_SCREEN_OFF);

	udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0xff);

	(void)udl_cmd_send_async(sc);
}

/* ---------- */

int
udl_copycols(void *cookie, int row, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	struct udl_softc *sc;
	int sx, sy, dx, dy, cx, cy, r;
	usbd_status error;

	sc = ri->ri_hw;

	DPRINTF(2, "%s: %s: row=%d, src=%d, dst=%d, num=%d\n",
	    DN(sc), FUNC, row, src, dst, num);

	udl_cmd_save_offset(sc);

	sx = src * ri->ri_font->fontwidth;
	sy = row * ri->ri_font->fontheight;
	dx = dst * ri->ri_font->fontwidth;
	dy = row * ri->ri_font->fontheight;
	cx = num * ri->ri_font->fontwidth;
	cy = ri->ri_font->fontheight;

	/* copy row block to off-screen first to fix overlay-copy problem */
	r = (sc->udl_fb_block_copy)
	    (sc, sx, sy, 0, sc->sc_ri.ri_emuheight, cx, cy);
	if (r != 0)
		goto fail;

	/* copy row block back from off-screen now */
	r = (sc->udl_fb_block_copy)
	    (sc, 0, sc->sc_ri.ri_emuheight, dx, dy, cx, cy);
	if (r != 0)
		goto fail;

	error = udl_cmd_send_async(sc);
	if (error != USBD_NORMAL_COMPLETION) {
fail:
		udl_cmd_restore_offset(sc);
		return (EAGAIN);
	}

	/* update character backing store */
	bcopy(sc->sc_cbs + ((row * sc->sc_ri.ri_cols) + src),
	    sc->sc_cbs + ((row * sc->sc_ri.ri_cols) + dst),
	    num * sizeof(*sc->sc_cbs));

	return (0);
}

int
udl_copyrows(void *cookie, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	struct udl_softc *sc;
	int sy, dy, cx, cy, r;
	usbd_status error;

	sc = ri->ri_hw;

	DPRINTF(2, "%s: %s: src=%d, dst=%d, num=%d\n",
	    DN(sc), FUNC, src, dst, num);

	udl_cmd_save_offset(sc);

	sy = src * sc->sc_ri.ri_font->fontheight;
	dy = dst * sc->sc_ri.ri_font->fontheight;
	cx = sc->sc_ri.ri_emuwidth;
	cy = num * sc->sc_ri.ri_font->fontheight;

	/* copy row block to off-screen first to fix overlay-copy problem */
	r = (sc->udl_fb_block_copy)
	    (sc, 0, sy, 0, sc->sc_ri.ri_emuheight, cx, cy);
	if (r != 0)
		goto fail;

	/* copy row block back from off-screen now */
	r = (sc->udl_fb_block_copy)
	    (sc, 0, sc->sc_ri.ri_emuheight, 0, dy, cx, cy);
	if (r != 0)
		goto fail;

	error = udl_cmd_send_async(sc);
	if (error != USBD_NORMAL_COMPLETION) {
fail:
		udl_cmd_restore_offset(sc);
		return (EAGAIN);
	}

	/* update character backing store */
	bcopy(sc->sc_cbs + (src * sc->sc_ri.ri_cols),
	    sc->sc_cbs + (dst * sc->sc_ri.ri_cols),
	    (num * sc->sc_ri.ri_cols) * sizeof(*sc->sc_cbs));

	return (0);
}

int
udl_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct udl_softc *sc = ri->ri_hw;
	uint16_t bgc;
	int fg, bg;
	int x, y, cx, cy, r;
	usbd_status error;

	sc = ri->ri_hw;

	DPRINTF(2, "%s: %s: row=%d, col=%d, num=%d\n",
	    DN(sc), FUNC, row, col, num);

	udl_cmd_save_offset(sc);

	sc->sc_ri.ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	bgc = (uint16_t)sc->sc_ri.ri_devcmap[bg];

	x = col * sc->sc_ri.ri_font->fontwidth;
	y = row * sc->sc_ri.ri_font->fontheight;
	cx = num * sc->sc_ri.ri_font->fontwidth;
	cy = sc->sc_ri.ri_font->fontheight;

	r = (sc->udl_fb_block_write)(sc, bgc, x, y, cx, cy);
	if (r != 0)
		goto fail;

	error = udl_cmd_send_async(sc);
	if (error != USBD_NORMAL_COMPLETION) {
fail:
		udl_cmd_restore_offset(sc);
		return (EAGAIN);
	}

	/* update character backing store */
	bzero(sc->sc_cbs + ((row * sc->sc_ri.ri_cols) + col),
	    num * sizeof(*sc->sc_cbs));

	return (0);
}

int
udl_eraserows(void *cookie, int row, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct udl_softc *sc;
	uint16_t bgc;
	int fg, bg;
	int x, y, cx, cy, r;
	usbd_status error;

	sc = ri->ri_hw;

	DPRINTF(2, "%s: %s: row=%d, num=%d\n", DN(sc), FUNC, row, num);

	udl_cmd_save_offset(sc);

	sc->sc_ri.ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	bgc = (uint16_t)sc->sc_ri.ri_devcmap[bg];

	x = 0;
	y = row * sc->sc_ri.ri_font->fontheight;
	cx = sc->sc_ri.ri_emuwidth;
	cy = num * sc->sc_ri.ri_font->fontheight;

	r = (sc->udl_fb_block_write)(sc, bgc, x, y, cx, cy);
	if (r != 0)
		goto fail;

	error = udl_cmd_send_async(sc);
	if (error != USBD_NORMAL_COMPLETION) {
fail:
		udl_cmd_restore_offset(sc);
		return (EAGAIN);
	}

	/* update character backing store */
	bzero(sc->sc_cbs + (row * sc->sc_ri.ri_cols),
	    (num * sc->sc_ri.ri_cols) * sizeof(*sc->sc_cbs));

	return (0);
}

int
udl_putchar(void *cookie, int row, int col, u_int uc, long attr)
{
	struct rasops_info *ri = cookie;
	struct udl_softc *sc = ri->ri_hw;
	int r;
	uint16_t fgc, bgc;
	uint32_t x, y, fg, bg;

	DPRINTF(4, "%s: %s\n", DN(sc), FUNC);

	udl_cmd_save_offset(sc);

	sc->sc_ri.ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	fgc = (uint16_t)sc->sc_ri.ri_devcmap[fg];
	bgc = (uint16_t)sc->sc_ri.ri_devcmap[bg];

	x = col * ri->ri_font->fontwidth;
	y = row * ri->ri_font->fontheight;

	if (uc == ' ') {
		/*
		 * Writting a block for the space character instead rendering
		 * it from font bits is more slim.
		 */
		r = (sc->udl_fb_block_write)(sc, bgc, x, y,
		    ri->ri_font->fontwidth, ri->ri_font->fontheight);
		if (r != 0)
			goto fail;
	} else {
		/* render a character from font bits */
		r = udl_draw_char(sc, fgc, bgc, uc, x, y);
		if (r != 0)
			goto fail;
	}

	/*
	 * We don't call udl_cmd_send_async() here, since sending each
	 * character by itself gets the performance down bad.  Instead the
	 * character will be buffered until another rasops function flush
	 * the buffer.
	 */

	/* update character backing store */
	sc->sc_cbs[(row * sc->sc_ri.ri_cols) + col] = uc;

	return (0);

fail:
	udl_cmd_restore_offset(sc);
	return (EAGAIN);
}

int
udl_do_cursor(struct rasops_info *ri)
{
	struct udl_softc *sc = ri->ri_hw;
	int r, pos;
	uint32_t x, y;
	uint8_t save_cursor;
	usbd_status error;

	DPRINTF(2, "%s: %s: ccol=%d, crow=%d\n",
	    DN(sc), FUNC, ri->ri_ccol, ri->ri_crow);

	udl_cmd_save_offset(sc);
	save_cursor = sc->sc_cursor_on;

	x = ri->ri_ccol * ri->ri_font->fontwidth;
	y = ri->ri_crow * ri->ri_font->fontheight;

	if (sc->sc_cursor_on == 0) {
		/* save the last character block to off-screen */
		r = (sc->udl_fb_block_copy)(sc, x, y, 0, sc->sc_ri.ri_emuheight,
		    ri->ri_font->fontwidth, ri->ri_font->fontheight);
		if (r != 0)
			goto fail;

		/* draw cursor */
		pos = (ri->ri_crow * sc->sc_ri.ri_cols) + ri->ri_ccol;
		if (sc->sc_cbs[pos] == 0 || sc->sc_cbs[pos] == ' ') {
			r = (sc->udl_fb_block_write)(sc, 0xffff, x, y,
			    ri->ri_font->fontwidth, ri->ri_font->fontheight);
		} else {
			r = udl_draw_char(sc, 0x0000, 0xffff, sc->sc_cbs[pos],
			    x, y);
		}
		if (r != 0)
			goto fail;

		sc->sc_cursor_on = 1;
	} else {
		/* restore the last saved character from off-screen */
		r = (sc->udl_fb_block_copy)(sc, 0, sc->sc_ri.ri_emuheight, x, y,
		    ri->ri_font->fontwidth, ri->ri_font->fontheight);
		if (r != 0)
			goto fail;

		sc->sc_cursor_on = 0;
	}

	error = udl_cmd_send_async(sc);
	if (error != USBD_NORMAL_COMPLETION) {
fail:
		udl_cmd_restore_offset(sc);
		sc->sc_cursor_on = save_cursor;
		return (EAGAIN);
	}

	return (0);
}

int
udl_draw_char(struct udl_softc *sc, uint16_t fg, uint16_t bg, u_int uc,
    uint32_t x, uint32_t y)
{
	int i, j, ly, r;
	uint8_t *fontchar;
	uint8_t buf[UDL_CMD_MAX_DATA_SIZE];
	uint16_t *line, lrgb16, fontbits, luc;
	struct wsdisplay_font *font = sc->sc_ri.ri_font;

	fontchar = (uint8_t *)(font->data + (uc - font->firstchar) *
	    sc->sc_ri.ri_fontscale);

	ly = y;
	for (i = 0; i < font->fontheight; i++) {
		if (font->fontwidth > 8) {
			fontbits = betoh16(*(uint16_t *)fontchar);
		} else {
			fontbits = *fontchar;
			fontbits = fontbits << 8;
		}
		line = (uint16_t *)buf;

		for (j = 15; j > (15 - font->fontwidth); j--) {
			luc = 1 << j;
			if (fontbits & luc)
				lrgb16 = htobe16(fg);
			else
				lrgb16 = htobe16(bg);
			bcopy(&lrgb16, line, 2);
			line++;
		}
		r = (sc->udl_fb_buf_write)(sc, buf, x, ly, font->fontwidth);
		if (r != 0)
			return (r);
		ly++;

		fontchar += font->stride;
	}

	return (0);
}

int
udl_damage(struct udl_softc *sc, uint8_t *image,
    uint32_t x1, uint32_t x2, uint32_t y1, uint32_t y2)
{
	int r;
	int x, y, width, height;
	usbd_status error;

	udl_cmd_save_offset(sc);

	x = x1;
	y = y1;
	width = x2 - x1;
	height = y2 - y1;

	r = udl_draw_image(sc, image, x, y, width, height);
	if (r != 0)
		goto fail;

	error = udl_cmd_send_async(sc);
	if (error != USBD_NORMAL_COMPLETION) {
fail:
		udl_cmd_restore_offset(sc);
		return (EAGAIN);
	}

	return (0);
}

int
udl_draw_image(struct udl_softc *sc, uint8_t *image,
    uint32_t x, uint32_t y, uint32_t width, uint32_t height)
{
	int i, j, r;
	int width_cur, x_cur;
	uint8_t buf[UDL_CMD_MAX_DATA_SIZE];
	uint16_t *image16, lrgb16;
	uint32_t off, block;

	for (i = 0; i < height; i++) {
		off = ((y * sc->sc_width) + x) * 2;
		x_cur = x;
		width_cur = width;

		while (width_cur) {
			if (width_cur > UDL_CMD_MAX_PIXEL_COUNT)
				block = UDL_CMD_MAX_PIXEL_COUNT;
			else
				block = width_cur;

			/* fix RGB ordering */
			image16 = (uint16_t *)(image + off);
			for (j = 0; j < (block * 2); j += 2) {
				lrgb16 = htobe16(*image16);
				bcopy(&lrgb16, buf + j, 2);
				image16++;
			}

			r = (sc->udl_fb_buf_write)(sc, buf, x_cur, y, block);
			if (r != 0)
				return (r);

			off += block * 2;
			x_cur += block;
			width_cur -= block;
		}
		y++;
	}

	return (0);
}

/* ---------- */

usbd_status
udl_ctrl_msg(struct udl_softc *sc, uint8_t rt, uint8_t r,
    uint16_t index, uint16_t value, uint8_t *buf, size_t len)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = rt;
	req.bRequest = r;
	USETW(req.wIndex, index);
	USETW(req.wValue, value);
	USETW(req.wLength, len);

	error = usbd_do_request(sc->sc_udev, &req, buf);
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: %s: %s!\n", DN(sc), FUNC, usbd_errstr(error));
		return (error);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
udl_poll(struct udl_softc *sc, uint32_t *buf)
{
	uint8_t lbuf[4];
	usbd_status error;

	error = udl_ctrl_msg(sc, UT_READ_VENDOR_DEVICE,
	    UDL_CTRL_CMD_POLL, 0x0000, 0x0000, lbuf, 4);
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: %s: %s!\n", DN(sc), FUNC, usbd_errstr(error));
		return (error);
	}
	*buf = *(uint32_t *)lbuf;

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
udl_read_1(struct udl_softc *sc, uint16_t addr, uint8_t *buf)
{
	uint8_t lbuf[1];
	usbd_status error;

	error = udl_ctrl_msg(sc, UT_READ_VENDOR_DEVICE,
	    UDL_CTRL_CMD_READ_1, addr, 0x0000, lbuf, 1);
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: %s: %s!\n", DN(sc), FUNC, usbd_errstr(error));
		return (error);
	}
	*buf = *(uint8_t *)lbuf;

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
udl_write_1(struct udl_softc *sc, uint16_t addr, uint8_t buf)
{
	usbd_status error;

	error = udl_ctrl_msg(sc, UT_WRITE_VENDOR_DEVICE,
	    UDL_CTRL_CMD_WRITE_1, addr, 0x0000, &buf, 1);
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: %s: %s!\n", DN(sc), FUNC, usbd_errstr(error));
		return (error);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
udl_read_edid(struct udl_softc *sc, uint8_t *buf)
{
	uint8_t lbuf[64];
	uint16_t offset;
	usbd_status error;

	offset = 0;

	error = udl_ctrl_msg(sc, UT_READ_VENDOR_DEVICE,
	    UDL_CTRL_CMD_READ_EDID, 0x00a1, (offset << 8), lbuf, 64);
	if (error != USBD_NORMAL_COMPLETION)
		goto fail;
	bcopy(lbuf + 1, buf + offset, 63);
	offset += 63;

	error = udl_ctrl_msg(sc, UT_READ_VENDOR_DEVICE,
	    UDL_CTRL_CMD_READ_EDID, 0x00a1, (offset << 8), lbuf, 64);
	if (error != USBD_NORMAL_COMPLETION)
		goto fail;
	bcopy(lbuf + 1, buf + offset, 63);
	offset += 63;

	error = udl_ctrl_msg(sc, UT_READ_VENDOR_DEVICE,
	    UDL_CTRL_CMD_READ_EDID, 0x00a1, (offset << 8), lbuf, 3);
	if (error != USBD_NORMAL_COMPLETION)
		goto fail;
	bcopy(lbuf + 1, buf + offset, 2);

	return (USBD_NORMAL_COMPLETION);
fail:
	printf("%s: %s: %s!\n", DN(sc), FUNC, usbd_errstr(error));
	return (error);
}

uint8_t
udl_lookup_mode(uint16_t hdisplay, uint16_t vdisplay, uint8_t hz,
    uint16_t chip, uint32_t clock)
{
	uint8_t	idx = 0;

	/*
	 * Check first if we have a matching mode with pixelclock
	 */
	while (idx < MAX_DL_MODES) {
		if ((udl_modes[idx].hdisplay == hdisplay) &&
		    (udl_modes[idx].vdisplay == vdisplay) &&
		    (udl_modes[idx].clock == clock) &&
		    (udl_modes[idx].chip <= chip)) {
			return(idx);
		}
		idx++;
	}

	/*
	 * If not, check for matching mode with update frequency
	 */
	idx = 0;
	while (idx < MAX_DL_MODES) {
		if ((udl_modes[idx].hdisplay == hdisplay) &&
		    (udl_modes[idx].vdisplay == vdisplay) &&
		    (udl_modes[idx].hz == hz) &&
		    (udl_modes[idx].chip <= chip)) {
			return(idx);
		}
		idx++;
	}

	return(idx);
}

int
udl_select_chip(struct udl_softc *sc)
{
	char serialnum[USB_MAX_STRING_LEN];
	usb_device_descriptor_t *dd;
	usb_string_descriptor_t us;
	usbd_status error;
	int len, i, n;
	char *s;
	uint16_t c;

	sc->sc_chip = DL120;

	dd = usbd_get_device_descriptor(sc->sc_udev);

	if ((UGETW(dd->idVendor) == USB_VENDOR_DISPLAYLINK) &&
	    (UGETW(dd->idProduct) == USB_PRODUCT_DISPLAYLINK_WSDVI)) {

		/*
		 * WS Tech DVI is DL120 or DL160. All deviced uses the
		 * same revision (0.04) so iSerialNumber must be used
		 * to determin which chip it is.
		 */

		bzero(serialnum, sizeof serialnum);
		error = usbd_get_string_desc(sc->sc_udev, dd->iSerialNumber,
		    0, &us, &len);
		if (error != USBD_NORMAL_COMPLETION)
			return (1);

		s = &serialnum[0];
		n = len / 2 - 1;
		for (i = 0; i < n && i < USB_MAX_STRING_LEN; i++) {
			c = UGETW(us.bString[i]);
			/* Convert from Unicode, handle buggy strings. */
			if ((c & 0xff00) == 0)
				*s++ = c;
			else if ((c & 0x00ff) == 0)
				*s++ = c >> 8;
			else
				*s++ = '?';
		}
		*s++ = 0;

		if (strlen(serialnum) > 7)
			if (strncmp(serialnum, "0198-13", 7) == 0)
				sc->sc_chip = DL160;

		DPRINTF(1, "%s: %s: iSerialNumber (%s) used to select chip (%d)\n",
		     DN(sc), FUNC, serialnum, sc->sc_chip);

	}

	if ((UGETW(dd->idVendor) == USB_VENDOR_DISPLAYLINK) &&
	    (UGETW(dd->idProduct) == USB_PRODUCT_DISPLAYLINK_SWDVI)) {

		/*
		 * SUNWEIT DVI is DL160, DL125, DL165 or DL195. Major revision
		 * can be used to differ between DL1x0 and DL1x5. Minor to
		 * differ between DL1x5. iSerialNumber seems not to be uniqe.
		 */

		sc->sc_chip = DL160;

		if (UGETW(dd->bcdDevice) >= 0x100) {
			sc->sc_chip = DL165;
			if (UGETW(dd->bcdDevice) == 0x104)
				sc->sc_chip = DL195;
			if (UGETW(dd->bcdDevice) == 0x108)
				sc->sc_chip = DL125;
		}

		DPRINTF(1, "%s: %s: bcdDevice (%02x) used to select chip (%d)\n",
		     DN(sc), FUNC, UGETW(dd->bcdDevice), sc->sc_chip);

	}

	return (0);
}

usbd_status
udl_set_enc_key(struct udl_softc *sc, uint8_t *buf, uint8_t len)
{
	usbd_status error;

	error = udl_ctrl_msg(sc, UT_WRITE_VENDOR_DEVICE,
	    UDL_CTRL_CMD_SET_KEY, 0x0000, 0x0000, buf, len);
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: %s: %s!\n", DN(sc), FUNC, usbd_errstr(error));
		return (error);
	}
	
	return (USBD_NORMAL_COMPLETION);
}

usbd_status
udl_set_decomp_table(struct udl_softc *sc, uint8_t *buf, uint16_t len)
{
	int err;

	udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
	udl_cmd_insert_int_1(sc, UDL_BULK_CMD_DECOMP);
	udl_cmd_insert_int_4(sc, 0x263871cd);	/* magic number */
	udl_cmd_insert_int_4(sc, 0x00000200);	/* 512 byte chunks */
	udl_cmd_insert_buf(sc, buf, len);

	err = udl_cmd_send(sc);
	if (err != 0)
		return (USBD_INVAL);

	return (USBD_NORMAL_COMPLETION);
}

/* ---------- */

int
udl_load_huffman(struct udl_softc *sc)
{
	const char *name = "udl_huffman";
	int error;

	if (sc->sc_huffman == NULL) {
		error = loadfirmware(name, &sc->sc_huffman,
		    &sc->sc_huffman_size);
		if (error != 0) {
			printf("%s: error %d, could not read huffman table "
			    "%s!\n", DN(sc), error, name);
			return (EIO);
		}
	}

	DPRINTF(1, "%s: huffman table %s allocated\n", DN(sc), name);

	return (0);
}

void
udl_free_huffman(struct udl_softc *sc)
{
	if (sc->sc_huffman != NULL) {
		free(sc->sc_huffman, M_DEVBUF, sc->sc_huffman_size);
		sc->sc_huffman = NULL;
		sc->sc_huffman_size = 0;
		DPRINTF(1, "%s: huffman table freed\n", DN(sc));
	}
}

int
udl_fbmem_alloc(struct udl_softc *sc)
{
	int size;

	size = (sc->sc_width * sc->sc_height) * (sc->sc_depth / 8);
	size = round_page(size);

	if (sc->sc_fbmem == NULL) {
		sc->sc_fbmem = malloc(size, M_DEVBUF, M_NOWAIT|M_ZERO);
		if (sc->sc_fbmem == NULL)
			return (-1);
	}
	sc->sc_fbmemsize = size;
	return (0);
}

void
udl_fbmem_free(struct udl_softc *sc)
{
	if (sc->sc_fbmem != NULL) {
		free(sc->sc_fbmem, M_DEVBUF, sc->sc_fbmemsize);
		sc->sc_fbmem = NULL;
		sc->sc_fbmemsize = 0;
	}
}

usbd_status
udl_cmd_alloc_xfer(struct udl_softc *sc)
{
	int i;

	for (i = 0; i < UDL_CMD_XFER_COUNT; i++) {
		struct udl_cmd_xfer *cx = &sc->sc_cmd_xfer[i];

		cx->sc = sc;

		cx->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (cx->xfer == NULL) {
			printf("%s: %s: can't allocate xfer handle!\n",
			    DN(sc), FUNC);
			return (USBD_NOMEM);
		}

		cx->buf = usbd_alloc_buffer(cx->xfer, UDL_CMD_MAX_XFER_SIZE);
		if (cx->buf == NULL) {
			printf("%s: %s: can't allocate xfer buffer!\n",
			    DN(sc), FUNC);
			return (USBD_NOMEM);
		}
	}

	return (USBD_NORMAL_COMPLETION);
}

void
udl_cmd_free_xfer(struct udl_softc *sc)
{
	int i;

	for (i = 0; i < UDL_CMD_XFER_COUNT; i++) {
		struct udl_cmd_xfer *cx = &sc->sc_cmd_xfer[i];

		if (cx->xfer != NULL) {
			usbd_free_xfer(cx->xfer);
			cx->xfer = NULL;
		}
	}
}

int
udl_cmd_alloc_buf(struct udl_softc *sc)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;

	cb->buf = malloc(UDL_CMD_MAX_XFER_SIZE, M_DEVBUF, M_NOWAIT|M_ZERO);
	if (cb->buf == NULL) {
		printf("%s: %s: can't allocate buffer!\n",
		    DN(sc), FUNC);
		return (ENOMEM);
	}
	cb->off = 0;
	cb->compblock = 0;

	return (0);
}

void
udl_cmd_free_buf(struct udl_softc *sc)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;

	if (cb->buf != NULL) {
		free(cb->buf, M_DEVBUF, 0);
		cb->buf = NULL;
	}
	cb->off = 0;
}

void
udl_cmd_insert_int_1(struct udl_softc *sc, uint8_t value)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;

	cb->buf[cb->off] = value;

	cb->off += 1;
}

void
udl_cmd_insert_int_2(struct udl_softc *sc, uint16_t value)
{
	uint16_t lvalue;
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;

	lvalue = htobe16(value);
	bcopy(&lvalue, cb->buf + cb->off, 2);

	cb->off += 2;
}

void
udl_cmd_insert_int_3(struct udl_softc *sc, uint32_t value)
{
	uint32_t lvalue;
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
#if BYTE_ORDER == BIG_ENDIAN
	lvalue = htobe32(value) << 8;
#else
	lvalue = htobe32(value) >> 8;
#endif
	bcopy(&lvalue, cb->buf + cb->off, 3);

	cb->off += 3;
}

void
udl_cmd_insert_int_4(struct udl_softc *sc, uint32_t value)
{
	uint32_t lvalue;
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;

	lvalue = htobe32(value);
	bcopy(&lvalue, cb->buf + cb->off, 4);

	cb->off += 4;
}

void
udl_cmd_insert_buf(struct udl_softc *sc, uint8_t *buf, uint32_t len)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;

	bcopy(buf, cb->buf + cb->off, len);

	cb->off += len;
}

int
udl_cmd_insert_buf_comp(struct udl_softc *sc, uint8_t *buf, uint32_t len)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
	struct udl_huffman *h;
	uint8_t bit_pos;
	uint16_t *pixels, prev;
	int16_t diff;
	uint32_t bit_count, bit_pattern, bit_cur;
	int i, j, bytes, eob, padding, next;

	pixels = (uint16_t *)buf;
	bit_pos = bytes = eob = padding = 0;

	/*
	 * If the header doesn't fit into the 512 byte main-block anymore,
	 * skip the header and finish up the main-block.  We return zero
	 * to signal our caller that the header has been skipped.
	 */
	if (cb->compblock >= UDL_CB_RESTART_SIZE) {
		cb->off -= UDL_CMD_WRITE_HEAD_SIZE;
		cb->compblock -= UDL_CMD_WRITE_HEAD_SIZE;
		eob = 1;
	}

	/*
	 * Generate a sub-block with maximal 256 pixels compressed data.
	 */
	for (i = 0; i < len / 2 && eob == 0; i++) {
		/* get difference between current and previous pixel */
		if (i > 0)
			prev = betoh16(pixels[i - 1]);
		else
			prev = 0;

		/* get the huffman difference bit sequence */
		diff = betoh16(pixels[i]) - prev;
		h = (struct udl_huffman *)(sc->sc_huffman + UDL_HUFFMAN_BASE);
		h += diff;
		bit_count = h->bit_count;
		bit_pattern = betoh32(h->bit_pattern);


		/* we are near the end of the main-block, so quit loop */
		if (bit_count % 8 == 0)
			next = bit_count / 8;
		else
			next = (bit_count / 8) + 1;

		if (cb->compblock + next >= UDL_CB_BODY_SIZE) {
			eob = 1;
			break;
		}

		/* generate one pixel compressed data */
		for (j = 0; j < bit_count; j++) {
			if (bit_pos == 0)
				cb->buf[cb->off] = 0;
			bit_cur = (bit_pattern >> j) & 1;
			cb->buf[cb->off] |= (bit_cur << bit_pos);
			bit_pos++;

			if (bit_pos == 8) {
				bit_pos = 0;
				cb->off++;
				cb->compblock++;
			}
		}
		bytes += 2;
	}

	/*
	 * If we have bits left in our last byte, round up to the next
	 * byte, so we don't overwrite them.
	 */
	if (bit_pos != 0) {
		cb->off++;
		cb->compblock++;
	}

	/*
	 * Finish up a 512 byte main-block.  The leftover space gets
	 * padded to zero.  Finally terminate the block by writting the
	 * 0xff-into-UDL_REG_SYNC-register sequence.
	 */
	if (eob == 1) {
		padding = (UDL_CB_BODY_SIZE - cb->compblock);
		for (i = 0; i < padding; i++) {
			cb->buf[cb->off] = 0;
			cb->off++;
			cb->compblock++;
		}
		udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0xff);
		cb->compblock = 0;
	}

	/* return how many bytes we have compressed */
	return (bytes);
}

int
udl_cmd_insert_head_comp(struct udl_softc *sc, uint32_t len)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
	int i, padding;

	if (cb->compblock > UDL_CB_BODY_SIZE) {
		cb->off -= UDL_CMD_COPY_HEAD_SIZE;
		cb->compblock -= UDL_CMD_COPY_HEAD_SIZE;

		padding = (UDL_CB_BODY_SIZE - cb->compblock);
		for (i = 0; i < padding; i++) {
			cb->buf[cb->off] = 0;
			cb->off++;
			cb->compblock++;
		}
		udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0xff);
		cb->compblock = 0;
		return (0);
	}

	return (len);
}

int
udl_cmd_insert_check(struct udl_softc *sc, int len)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
	int total;
	usbd_status error;

	total = cb->off + len;

	if (total > UDL_CMD_MAX_XFER_SIZE) {
		/* command buffer is almost full, try to flush it */
		if (cb->xfer_type == UDL_CMD_XFER_ASYNC)
			error = udl_cmd_send_async(sc);
		else
			error = udl_cmd_send(sc);
		if (error != USBD_NORMAL_COMPLETION) {
			DPRINTF(1, "%s: %s: can't flush full command buffer\n",
			    DN(sc), FUNC);
			return (EAGAIN);
		}
	}

	return (0);
}

void
udl_cmd_set_xfer_type(struct udl_softc *sc, int xfer_type)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;

	cb->xfer_type = xfer_type;
}

void
udl_cmd_save_offset(struct udl_softc *sc)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;

	cb->off_save = cb->off;
	cb->compblock_save = cb->compblock;
}

void
udl_cmd_restore_offset(struct udl_softc *sc)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;

	cb->off = cb->off_save;
	cb->compblock = cb->compblock_save;
}

void
udl_cmd_write_reg_1(struct udl_softc *sc, uint8_t reg, uint8_t val)
{
	udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
	udl_cmd_insert_int_1(sc, UDL_BULK_CMD_REG_WRITE_1);
	udl_cmd_insert_int_1(sc, reg);
	udl_cmd_insert_int_1(sc, val);
}

void
udl_cmd_write_reg_3(struct udl_softc *sc, uint8_t reg, uint32_t val)
{
	udl_cmd_write_reg_1(sc, reg + 0, (val >> 16) & 0xff);
	udl_cmd_write_reg_1(sc, reg + 1, (val >> 8) & 0xff);
	udl_cmd_write_reg_1(sc, reg + 2, (val >> 0) & 0xff);
}

usbd_status
udl_cmd_send(struct udl_softc *sc)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
	struct udl_cmd_xfer *cx = &sc->sc_cmd_xfer[0];
	int len;
	usbd_status error;

	/* mark end of command stack */
	udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
	udl_cmd_insert_int_1(sc, UDL_BULK_CMD_EOC);

	bcopy(cb->buf, cx->buf, cb->off);

	len = cb->off;
	usbd_setup_xfer(cx->xfer, sc->sc_tx_pipeh, 0, cx->buf, len,
	    USBD_NO_COPY | USBD_SHORT_XFER_OK | USBD_SYNCHRONOUS, 1000, NULL);
	error = usbd_transfer(cx->xfer);
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: %s: %s!\n", DN(sc), FUNC, usbd_errstr(error));
		/* we clear our buffer now to avoid growing out of bounds */
		goto fail;
	}
	DPRINTF(1, "%s: %s: sent %d of %d bytes\n",
	    DN(sc), FUNC, len, cb->off);
fail:
	cb->off = 0;
	cb->compblock = 0;

	return (error);
}

usbd_status
udl_cmd_send_async(struct udl_softc *sc)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
	struct udl_cmd_xfer *cx;
	usbd_status error;
	int i, s;

	/* check if command xfer queue is full */
	if (sc->sc_cmd_xfer_cnt == UDL_CMD_XFER_COUNT)
		return (USBD_IN_USE);

	s = splusb();	/* no callbacks please until accounting is done */

	/* find a free command xfer buffer */
	for (i = 0; i < UDL_CMD_XFER_COUNT; i++) {
		if (sc->sc_cmd_xfer[i].busy == 0)
			break;
	}
	if (i == UDL_CMD_XFER_COUNT) {
		/* this shouldn't happen */
		splx(s);
		return (USBD_IN_USE);
	}
	cx = &sc->sc_cmd_xfer[i];

	/* mark end of command stack */
	udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
	udl_cmd_insert_int_1(sc, UDL_BULK_CMD_EOC);

	/* copy command buffer to xfer buffer */
	bcopy(cb->buf, cx->buf, cb->off);

	/* do xfer */
	usbd_setup_xfer(cx->xfer, sc->sc_tx_pipeh, cx, cx->buf, cb->off,
	     USBD_NO_COPY, 1000, udl_cmd_send_async_cb);
	error = usbd_transfer(cx->xfer);
	if (error != 0 && error != USBD_IN_PROGRESS) {
		printf("%s: %s: %s!\n", DN(sc), FUNC, usbd_errstr(error));
		splx(s);
		return (error);
	}
	DPRINTF(2, "%s: %s: sending %d bytes from buffer no. %d\n",
	    DN(sc), FUNC, cb->off, i);

	/* free command buffer, lock xfer buffer */
	cb->off = 0;
	cb->compblock = 0;
	cx->busy = 1;
	sc->sc_cmd_xfer_cnt++;

	splx(s);

	return (USBD_NORMAL_COMPLETION);
}

void
udl_cmd_send_async_cb(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct udl_cmd_xfer *cx = priv;
	struct udl_softc *sc = cx->sc;
	int len;

	if (status != USBD_NORMAL_COMPLETION) {
		printf("%s: %s: %s!\n", DN(sc), FUNC, usbd_errstr(status));

		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_tx_pipeh);
		goto skip;
	}
	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	DPRINTF(3, "%s: %s: sent %d bytes\n", DN(sc), FUNC, len);
skip:
	/* free xfer buffer */
	cx->busy = 0;
	sc->sc_cmd_xfer_cnt--;

	/* wakeup UDLIO_DAMAGE if it sleeps for a free xfer buffer */
	wakeup(sc);
}

/* ---------- */

usbd_status
udl_init_chip(struct udl_softc *sc)
{
	uint8_t ui8;
	uint32_t ui32;
	usbd_status error;

	error = udl_poll(sc, &ui32);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);
	DPRINTF(1, "%s: %s: poll=0x%08x\n", DN(sc), FUNC, ui32);

	/* Some products may use later chip too */
	switch (ui32 & 0xff) {
	case 0xf1:				/* DL1x5 */
		switch (sc->sc_chip) {
		case DL120:
			sc->sc_chip = DL125;
			break;
		case DL160:
			sc->sc_chip = DL165;
			break;
		}
		break;
	}
	DPRINTF(1, "%s: %s: chip %d\n", DN(sc), FUNC, sc->sc_chip);

	error = udl_read_1(sc, 0xc484, &ui8);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);
	DPRINTF(1, "%s: %s: read 0x%02x from 0xc484\n", DN(sc), FUNC, ui8);

	error = udl_write_1(sc, 0xc41f, 0x01);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);
	DPRINTF(1, "%s: %s: write 0x01 to 0xc41f\n", DN(sc), FUNC);

	error = udl_read_edid(sc, sc->sc_edid);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);
	DPRINTF(1, "%s: %s: read EDID\n", DN(sc), FUNC);

	error = udl_set_enc_key(sc, udl_null_key_1, sizeof(udl_null_key_1));
	if (error != USBD_NORMAL_COMPLETION)
		return (error);
	DPRINTF(1, "%s: %s: set encryption key\n", DN(sc), FUNC);

	error = udl_write_1(sc, 0xc40b, 0x00);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);
	DPRINTF(1, "%s: %s: write 0x00 to 0xc40b\n", DN(sc), FUNC, ui8);

	error = udl_set_decomp_table(sc, udl_decomp_table,
	    sizeof(udl_decomp_table));
	if (error != USBD_NORMAL_COMPLETION)
		return (error);
	DPRINTF(1, "%s: %s: set decompression table\n", DN(sc), FUNC);

	return (USBD_NORMAL_COMPLETION);
}

void
udl_init_fb_offsets(struct udl_softc *sc, uint32_t start16, uint32_t stride16,
    uint32_t start8, uint32_t stride8)
{
	udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0x00);
	udl_cmd_write_reg_3(sc, UDL_REG_ADDR_START16, start16);
	udl_cmd_write_reg_3(sc, UDL_REG_ADDR_STRIDE16, stride16);
	udl_cmd_write_reg_3(sc, UDL_REG_ADDR_START8, start8);
	udl_cmd_write_reg_3(sc, UDL_REG_ADDR_STRIDE8, stride8);
	udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0xff);
}

usbd_status
udl_init_resolution(struct udl_softc *sc)
{
	int i;
	usbd_status error;
	uint8_t *buf = udl_modes[sc->sc_cur_mode].mode;

	/* write resolution values and set video memory offsets */
	udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0x00);
	for (i = 0; i < UDL_MODE_SIZE; i++)
		udl_cmd_write_reg_1(sc, i, buf[i]);
	udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0xff);

	udl_init_fb_offsets(sc, 0x000000, 0x000a00, 0x555555, 0x000500);
	error = udl_cmd_send(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	/* clear screen */
	error = udl_clear_screen(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	/* show framebuffer content */
	udl_cmd_write_reg_1(sc, UDL_REG_SCREEN, UDL_REG_SCREEN_ON);
	udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0xff);
	error = udl_cmd_send(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
udl_clear_screen(struct udl_softc *sc)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
	usbd_status error;

	/* clear screen */
	udl_fb_block_write(sc, 0x0000, 0, 0, sc->sc_width, sc->sc_height);
	if (cb->xfer_type == UDL_CMD_XFER_ASYNC)
		error = udl_cmd_send_async(sc);
	else
		error = udl_cmd_send(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	return (USBD_NORMAL_COMPLETION);
}

void
udl_select_mode(struct udl_softc *sc)
{
	struct udl_mode mode;
	int index = MAX_DL_MODES, i;

	/* try to get the preferred mode from EDID */
	edid_parse(sc->sc_edid, &sc->sc_edid_info);
#ifdef UDL_DEBUG
	edid_print(&sc->sc_edid_info);
#endif
	if (sc->sc_edid_info.edid_preferred_mode != NULL) {
		mode.hz = 
		    (sc->sc_edid_info.edid_preferred_mode->dot_clock * 1000) /
		    (sc->sc_edid_info.edid_preferred_mode->htotal *
		     sc->sc_edid_info.edid_preferred_mode->vtotal);
		mode.clock = 
		    sc->sc_edid_info.edid_preferred_mode->dot_clock / 10;
		mode.hdisplay =
		    sc->sc_edid_info.edid_preferred_mode->hdisplay;
		mode.vdisplay =
		    sc->sc_edid_info.edid_preferred_mode->vdisplay;
		index = udl_lookup_mode(mode.hdisplay, mode.vdisplay, mode.hz,
		    sc->sc_chip, mode.clock);
		sc->sc_cur_mode = index;
	} else {
		DPRINTF(1, "%s: %s: no preferred mode found!\n", DN(sc), FUNC);
	}

	if (index == MAX_DL_MODES) {
		DPRINTF(1, "%s: %s: no mode line found for %dx%d @@ %dHz!\n",
		    DN(sc), FUNC, mode.hdisplay, mode.vdisplay, mode.hz);

		i = 0;
		while (i < sc->sc_edid_info.edid_nmodes) {
			mode.hz = 
			    (sc->sc_edid_info.edid_modes[i].dot_clock * 1000) /
			    (sc->sc_edid_info.edid_modes[i].htotal *
			     sc->sc_edid_info.edid_modes[i].vtotal);
			mode.clock = 
			    sc->sc_edid_info.edid_modes[i].dot_clock / 10;
			mode.hdisplay =
			    sc->sc_edid_info.edid_modes[i].hdisplay;
			mode.vdisplay =
			    sc->sc_edid_info.edid_modes[i].vdisplay;
			index = udl_lookup_mode(mode.hdisplay, mode.vdisplay,
			    mode.hz, sc->sc_chip, mode.clock);
			if (index < MAX_DL_MODES)
				if ((sc->sc_cur_mode == MAX_DL_MODES) ||
				    (index > sc->sc_cur_mode))
					sc->sc_cur_mode = index;
			i++;
		}
	}

	/*
	 * If no mode found use default.
	 */
	if (sc->sc_cur_mode == MAX_DL_MODES)
		sc->sc_cur_mode = udl_lookup_mode(800, 600, 60, sc->sc_chip, 0);

	mode = udl_modes[sc->sc_cur_mode];
	sc->sc_width = mode.hdisplay;
	sc->sc_height = mode.vdisplay;

	/*
	 * We always use 16bit color depth for now.
	 */
	sc->sc_depth = 16;

	DPRINTF(1, "%s: %s: %dx%d @@ %dHz\n",
	    DN(sc), FUNC, mode.hdisplay, mode.vdisplay, mode.hz);
}

int
udl_fb_buf_write(struct udl_softc *sc, uint8_t *buf, uint32_t x,
    uint32_t y, uint16_t width)
{
	uint16_t lwidth;
	uint32_t off;
	int r;

	r = udl_cmd_insert_check(sc, UDL_CMD_WRITE_MAX_SIZE);
	if (r != 0)
		return (r);

	off = ((y * sc->sc_width) + x) * 2;
	lwidth = width * 2;

	udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
	udl_cmd_insert_int_1(sc, UDL_BULK_CMD_FB_WRITE | UDL_BULK_CMD_FB_WORD);
	udl_cmd_insert_int_3(sc, off);
	udl_cmd_insert_int_1(sc, width >= UDL_CMD_MAX_PIXEL_COUNT ? 0 : width);

	udl_cmd_insert_buf(sc, buf, lwidth);

	return (0);
}

int
udl_fb_block_write(struct udl_softc *sc, uint16_t rgb16, uint32_t x,
    uint32_t y, uint32_t width, uint32_t height)
{
	uint32_t i;
	int r;

	for (i = 0; i < height; i++) {
		r = udl_fb_line_write(sc, rgb16, x, y + i, width);
		if (r != 0)
			return (r);
	}

	return (0);
}

int
udl_fb_line_write(struct udl_softc *sc, uint16_t rgb16, uint32_t x,
    uint32_t y, uint32_t width)
{
	uint32_t off, block;
	int r;

	off = (y * sc->sc_width) + x;

	while (width) {
		if (width > UDL_CMD_MAX_PIXEL_COUNT)	
			block = UDL_CMD_MAX_PIXEL_COUNT;
		else
			block = width;

		r = udl_fb_off_write(sc, rgb16, off, block);
		if (r != 0)
			return (r);

		off += block;
		width -= block;
	}

	return (0);
}

int
udl_fb_off_write(struct udl_softc *sc, uint16_t rgb16, uint32_t off,
    uint16_t width)
{
	uint8_t buf[UDL_CMD_MAX_DATA_SIZE];
	uint16_t lwidth, lrgb16;
	uint32_t loff;
	int i, r;

	r = udl_cmd_insert_check(sc, UDL_CMD_WRITE_MAX_SIZE);
	if (r != 0)
		return (r);

	loff = off * 2;
	lwidth = width * 2;

	udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
	udl_cmd_insert_int_1(sc, UDL_BULK_CMD_FB_WRITE | UDL_BULK_CMD_FB_WORD);
	udl_cmd_insert_int_3(sc, loff);
	udl_cmd_insert_int_1(sc, width >= UDL_CMD_MAX_PIXEL_COUNT ? 0 : width);

	for (i = 0; i < lwidth; i += 2) {
		lrgb16 = htobe16(rgb16);
		bcopy(&lrgb16, buf + i, 2);
	}

	udl_cmd_insert_buf(sc, buf, lwidth);

	return (0);
}

int
udl_fb_block_copy(struct udl_softc *sc, uint32_t src_x, uint32_t src_y,
    uint32_t dst_x, uint32_t dst_y, uint32_t width, uint32_t height)
{
	int i, r;

	for (i = 0; i < height; i++) {
		r = udl_fb_line_copy(sc, src_x, src_y + i, dst_x, dst_y + i,
		    width);
		if (r != 0)
			return (r);
	}

	return (0);
}


int
udl_fb_line_copy(struct udl_softc *sc, uint32_t src_x, uint32_t src_y,
    uint32_t dst_x, uint32_t dst_y, uint32_t width)
{
	uint32_t src_off, dst_off, block;
	int r;

	src_off = (src_y * sc->sc_width) + src_x;
	dst_off = (dst_y * sc->sc_width) + dst_x;

	while (width) {
		if (width > UDL_CMD_MAX_PIXEL_COUNT)
			block = UDL_CMD_MAX_PIXEL_COUNT;
		else
			block = width;

		r = udl_fb_off_copy(sc, src_off, dst_off, block);
		if (r != 0)
			return (r);

		src_off += block;
		dst_off += block;
		width -= block;
	}

	return (0);
}

int
udl_fb_off_copy(struct udl_softc *sc, uint32_t src_off, uint32_t dst_off,
    uint16_t width)
{
	uint32_t ldst_off, lsrc_off;
	int r;

	r = udl_cmd_insert_check(sc, UDL_CMD_COPY_MAX_SIZE);
	if (r != 0)
		return (r);

	ldst_off = dst_off * 2;
	lsrc_off = src_off * 2;

	udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
	udl_cmd_insert_int_1(sc, UDL_BULK_CMD_FB_COPY | UDL_BULK_CMD_FB_WORD);
	udl_cmd_insert_int_3(sc, ldst_off);
	udl_cmd_insert_int_1(sc, width >= UDL_CMD_MAX_PIXEL_COUNT ? 0 : width);
	udl_cmd_insert_int_3(sc, lsrc_off);

	return (0);
}

int
udl_fb_buf_write_comp(struct udl_softc *sc, uint8_t *buf, uint32_t x,
    uint32_t y, uint16_t width)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
	uint8_t *count;
	uint16_t lwidth;
	uint32_t off;
	int r, sent;

	r = udl_cmd_insert_check(sc, UDL_CMD_WRITE_MAX_SIZE);
	if (r != 0)
		return (r);

	off = ((y * sc->sc_width) + x) * 2;
	lwidth = width * 2;

	/*
	 * A new compressed stream needs the 0xff-into-UDL_REG_SYNC-register
	 * sequence always as first command.
	 */
	if (cb->off == 0)
		udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0xff);

	r = sent = 0;
	while (sent < lwidth) {
		udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
		udl_cmd_insert_int_1(sc,
		    UDL_BULK_CMD_FB_WRITE |
		    UDL_BULK_CMD_FB_WORD |
		    UDL_BULK_CMD_FB_COMP);
		udl_cmd_insert_int_3(sc, off + sent);
		udl_cmd_insert_int_1(sc,
		    width >= UDL_CMD_MAX_PIXEL_COUNT ? 0 : width);
		cb->compblock += UDL_CMD_WRITE_HEAD_SIZE;

		count = &cb->buf[cb->off - 1];
		r = udl_cmd_insert_buf_comp(sc, buf + sent, lwidth - sent);
		if (r > 0 && r != (lwidth - sent)) {
			*count = r / 2;
			width -= r / 2;
		}
		sent += r;
	}

	return (0);
}

int
udl_fb_block_write_comp(struct udl_softc *sc, uint16_t rgb16, uint32_t x,
    uint32_t y, uint32_t width, uint32_t height)
{
	uint32_t i;
	int r;

	for (i = 0; i < height; i++) {
		r = udl_fb_line_write_comp(sc, rgb16, x, y + i, width);
		if (r != 0)
			return (r);
	}

	return (0);
}

int
udl_fb_line_write_comp(struct udl_softc *sc, uint16_t rgb16, uint32_t x,
    uint32_t y, uint32_t width)
{
	uint32_t off, block;
	int r;

	off = (y * sc->sc_width) + x;

	while (width) {
		if (width > UDL_CMD_MAX_PIXEL_COUNT)	
			block = UDL_CMD_MAX_PIXEL_COUNT;
		else
			block = width;

		r = udl_fb_off_write_comp(sc, rgb16, off, block);
		if (r != 0)
			return (r);

		off += block;
		width -= block;
	}

	return (0);
}

int
udl_fb_off_write_comp(struct udl_softc *sc, uint16_t rgb16, uint32_t off,
    uint16_t width)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
	uint8_t buf[UDL_CMD_MAX_DATA_SIZE];
	uint8_t *count;
	uint16_t lwidth, lrgb16;
	uint32_t loff;
	int i, r, sent;

	r = udl_cmd_insert_check(sc, UDL_CMD_WRITE_MAX_SIZE);
	if (r != 0)
		return (r);

	loff = off * 2;
	lwidth = width * 2;

	for (i = 0; i < lwidth; i += 2) {
		lrgb16 = htobe16(rgb16);
		bcopy(&lrgb16, buf + i, 2);
	}

	/*
	 * A new compressed stream needs the 0xff-into-UDL_REG_SYNC-register
	 * sequence always as first command.
	 */
	if (cb->off == 0)
		udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0xff);

	r = sent = 0;
	while (sent < lwidth) {
		udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
		udl_cmd_insert_int_1(sc,
		    UDL_BULK_CMD_FB_WRITE |
		    UDL_BULK_CMD_FB_WORD |
		    UDL_BULK_CMD_FB_COMP);
		udl_cmd_insert_int_3(sc, loff + sent);
		udl_cmd_insert_int_1(sc,
		    width >= UDL_CMD_MAX_PIXEL_COUNT ? 0 : width);
		cb->compblock += UDL_CMD_WRITE_HEAD_SIZE;

		count = &cb->buf[cb->off - 1];
		r = udl_cmd_insert_buf_comp(sc, buf + sent, lwidth - sent);
		if (r > 0 && r != (lwidth - sent)) {
			*count = r / 2;
			width -= r / 2;
		}
		sent += r;
	}

	return (0);
}

int
udl_fb_block_copy_comp(struct udl_softc *sc, uint32_t src_x, uint32_t src_y,
    uint32_t dst_x, uint32_t dst_y, uint32_t width, uint32_t height)
{
	int i, r;

	for (i = 0; i < height; i++) {
		r = udl_fb_line_copy_comp(sc, src_x, src_y + i,
		    dst_x, dst_y + i, width);
		if (r != 0)
			return (r);
	}

	return (0);
}

int
udl_fb_line_copy_comp(struct udl_softc *sc, uint32_t src_x, uint32_t src_y,
    uint32_t dst_x, uint32_t dst_y, uint32_t width)
{
	uint32_t src_off, dst_off, block;
	int r;

	src_off = (src_y * sc->sc_width) + src_x;
	dst_off = (dst_y * sc->sc_width) + dst_x;

	while (width) {
		if (width > UDL_CMD_MAX_PIXEL_COUNT)
			block = UDL_CMD_MAX_PIXEL_COUNT;
		else
			block = width;

		r = udl_fb_off_copy_comp(sc, src_off, dst_off, block);
		if (r != 0)
			return (r);

		src_off += block;
		dst_off += block;
		width -= block;
	}

	return (0);
}

int
udl_fb_off_copy_comp(struct udl_softc *sc, uint32_t src_off, uint32_t dst_off,
    uint16_t width)
{
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
	uint32_t ldst_off, lsrc_off;
	int r;

	r = udl_cmd_insert_check(sc, UDL_CMD_COPY_MAX_SIZE);
	if (r != 0)
		return (r);

	ldst_off = dst_off * 2;
	lsrc_off = src_off * 2;

	/*
	 * A new compressed stream needs the 0xff-into-UDL_REG_SYNC-register
	 * sequence always as first command.
	 */
	if (cb->off == 0)
		udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0xff);

	r = 0;
	while (r < 1) {
		udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
		udl_cmd_insert_int_1(sc,
		    UDL_BULK_CMD_FB_COPY | UDL_BULK_CMD_FB_WORD);
		udl_cmd_insert_int_3(sc, ldst_off);
		udl_cmd_insert_int_1(sc,
		    width >= UDL_CMD_MAX_PIXEL_COUNT ? 0 : width);
		udl_cmd_insert_int_3(sc, lsrc_off);
		cb->compblock += UDL_CMD_COPY_HEAD_SIZE;

		r = udl_cmd_insert_head_comp(sc, UDL_CMD_COPY_HEAD_SIZE);
	}

	return (0);
}

/* ---------- */
#ifdef UDL_DEBUG
void
udl_hexdump(void *buf, int len, int quiet)
{
	int i;

	for (i = 0; i < len; i++) {
		if (quiet == 0) {
			if (i % 16 == 0)
				printf("%s%5i:", i ? "\n" : "", i);
			if (i % 4 == 0)
				printf(" ");
		}
		printf("%02x", (int)*((u_char *)buf + i));
	}
	printf("\n");
}

usbd_status
udl_init_test(struct udl_softc *sc)
{
	int i, j, parts, loops;
	uint16_t color;
	uint16_t rgb24[3] = { 0xf800, 0x07e0, 0x001f };

	loops = (sc->sc_width * sc->sc_height) / UDL_CMD_MAX_PIXEL_COUNT;
	parts = loops / 3;
	color = rgb24[0];

	j = 1;
	for (i = 0; i < loops; i++) {
		if (i == parts) {
			color = rgb24[j];
			parts += parts;
			j++;
		}
		(sc->udl_fb_off_write)(sc, color, i * UDL_CMD_MAX_PIXEL_COUNT,
		    UDL_CMD_MAX_PIXEL_COUNT);
	}
	(void)udl_cmd_send(sc);

	return (USBD_NORMAL_COMPLETION);
}
#endif
@


1.85
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.84 2015/12/11 16:07:02 mpi Exp $ */
d1421 1
a1421 1
		free(sc->sc_huffman, M_DEVBUF, 0);
d1441 1
a1441 1

d1449 1
a1449 1
		free(sc->sc_fbmem, M_DEVBUF, 0);
d1451 1
@


1.84
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.83 2015/05/02 10:44:29 jsg Exp $ */
d261 1
a261 1
	if (uaa->iface != NULL)
a305 6
	/*
	 * Set device configuration descriptor number.
	 */
	error = usbd_set_config_no(sc->sc_udev, 1, 0);
	if (error != USBD_NORMAL_COMPLETION)
		return;
@


1.83
log
@add missing splx calls
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.82 2015/03/14 03:38:49 jsg Exp $ */
d75 1
a75 1
void		udl_attach_hook(void *);
d396 1
a396 4
	if (rootvp == NULL)
		mountroothook_establish(udl_attach_hook, sc);
	else
		udl_attach_hook(sc);
d400 1
a400 1
udl_attach_hook(void *arg)
d402 1
a402 1
	struct udl_softc *sc = arg;
@


1.82
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.81 2014/12/09 07:05:06 doug Exp $ */
d1839 1
@


1.81
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.80 2014/07/12 18:48:52 tedu Exp $ */
a37 2

#include <machine/bus.h>
@


1.80
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.79 2013/12/06 21:03:05 deraadt Exp $ */
d655 1
a655 1
	sc->sc_cbs = malloc((sc->sc_ri.ri_rows * sc->sc_ri.ri_cols) *
@


1.79
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.78 2013/10/21 10:36:26 miod Exp $ */
d683 1
a683 1
		free(sc->sc_cbs, M_DEVBUF);
d1432 1
a1432 1
		free(sc->sc_huffman, M_DEVBUF);
d1460 1
a1460 1
		free(sc->sc_fbmem, M_DEVBUF);
d1531 1
a1531 1
		free(cb->buf, M_DEVBUF);
@


1.78
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.77 2013/10/20 20:07:31 miod Exp $ */
d490 1
a490 1
	int ret = 0;
d497 2
a498 3
	ret = config_activate_children(self, act);

	return (ret);
@


1.77
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.76 2013/05/30 16:15:02 deraadt Exp $ */
d88 2
d222 2
d700 18
@


1.76
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.75 2013/04/26 14:28:39 mpi Exp $ */
d215 6
a220 9
	udl_ioctl,
	udl_mmap,
	udl_alloc_screen,
	udl_free_screen,
	udl_show_screen,
	NULL,
	NULL,
	NULL,
	udl_burner
@


1.75
log
@Don't use usbd_bulk_transfer() to submit a synchronous transfer. This
function is badly named and should be used for transfers coming from
userland which is not the case here as synchronous transfers are only
used while configuring the device.

Note that the transfer submission code can be simplified now that sync
and async transfers use the standard setup_xfer()/transfer() method.

Tested by and ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.74 2013/04/17 17:49:58 tedu Exp $ */
d489 1
d496 1
d498 1
a498 1
	return (0);
@


1.74
log
@uvm_extern.h not uvm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.73 2013/04/15 09:23:02 mglocker Exp $ */
d1783 3
a1785 3
	error = usbd_bulk_transfer(cx->xfer, sc->sc_tx_pipeh,
	    USBD_NO_COPY | USBD_SHORT_XFER_OK, 1000, cx->buf, &len,
	    "udl_bulk_xmit");
@


1.73
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.72 2013/03/28 03:58:03 tedu Exp $ */
d35 3
a37 1
#include <uvm/uvm.h>
@


1.72
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.71 2012/09/18 17:24:51 jasper Exp $ */
d137 1
a137 2
void		udl_cmd_send_async_cb(usbd_xfer_handle, usbd_private_handle,
		    usbd_status);
d1854 1
a1854 2
udl_cmd_send_async_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
    usbd_status status)
@


1.71
log
@the 'WIDE' was dropped
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.70 2012/09/18 17:11:41 jasper Exp $ */
a34 1
#include <sys/proc.h>
@


1.70
log
@support the Lenovo ThinkVision LT1421

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.69 2012/03/26 19:12:54 claudio Exp $ */
d253 1
a253 1
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LT1421WIDE }, DLUNK }
@


1.69
log
@Add support for the udl(4) in the Polaris2 USB dock
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.68 2011/07/03 15:47:17 matthew Exp $ */
d252 2
a253 1
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_POLARIS2 },	DLUNK }
@


1.68
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.67 2011/01/25 20:03:36 jakemsr Exp $ */
d251 2
a252 1
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LUM70 },	DL125 }
@


1.67
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.66 2010/12/27 03:03:50 jakemsr Exp $ */
a488 2
	case DVACT_ACTIVATE:
		break;
@


1.66
log
@* add cfattach activate functions and call usbd_deactivate() in the
  DVACT_DEACTIVATE case for drivers that don't have activate finctions
* fill out cfattach activate functions and call usbd_deactivate() in
  the DVACT_DEACTIVATE case for drivers that don't have a dying flag

"ok with the intent" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.65 2010/12/26 15:41:00 miod Exp $ */
a391 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev, &sc->sc_dev);

a478 2

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev, &sc->sc_dev);
@


1.65
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.64 2010/10/16 07:06:20 maja Exp $ */
d490 2
d496 1
a496 1
		/* XXX sc->sc_dying = 1; */
@


1.64
log
@SUNWEIT DVI can be just about any chipset. Use the revision to select which.
Some other products use more than one generation of chipset. e.g. both
DL160 and DL165. Change to a later chipset if the family is newer than
expected. ok mglocker@@   -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.63 2010/10/10 11:11:54 mglocker Exp $ */
a595 1
#if defined(__powerpc__) || defined(__sparc64__)
a596 3
#else
	return (atop(pa));
#endif
@


1.63
log
@Add proper malloc flags so we can attach again.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.62 2010/09/27 19:49:43 thib Exp $ */
d248 1
a248 1
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_SWDVI },	DL160 },
d1293 36
a1328 17
	bzero(serialnum, sizeof serialnum);
	error = usbd_get_string_desc(sc->sc_udev, dd->iSerialNumber,
	    0, &us, &len);
	if (error != USBD_NORMAL_COMPLETION)
		return (1);
		
	s = &serialnum[0];
	n = len / 2 - 1;
	for (i = 0; i < n && i < USB_MAX_STRING_LEN; i++) {
		c = UGETW(us.bString[i]);
		/* Convert from Unicode, handle buggy strings. */
		if ((c & 0xff00) == 0)
			*s++ = c;
		else if ((c & 0x00ff) == 0)
			*s++ = c >> 8;
		else
			*s++ = '?';
a1329 1
	*s++ = 0;
d1331 2
a1332 3
	if (strlen(serialnum) > 7)
		if (strncmp(serialnum, "0198-13", 7) == 0)
			sc->sc_chip = DL160;
d1334 20
a1353 2
	DPRINTF(1, "%s: %s: iSerialNumber (%s) used to select chip (%d)\n",
	     DN(sc), FUNC, serialnum, sc->sc_chip);
d1903 15
@


1.62
log
@A few M_ZEROs without any M_WAITOK/M_NOWAITs.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.61 2010/08/31 17:00:05 deraadt Exp $ */
d1399 1
a1399 1
		sc->sc_fbmem = malloc(size, M_DEVBUF, M_ZERO);
d1464 1
a1464 1
	cb->buf = malloc(UDL_CMD_MAX_XFER_SIZE, M_DEVBUF, 0);
@


1.61
log
@annotate that this driver needs sc_dying code
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.60 2010/07/29 12:37:16 maja Exp $ */
d660 1
a660 1
	    sizeof(*sc->sc_cbs), M_DEVBUF, M_ZERO);
@


1.60
log
@Add some more devices. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.59 2010/07/19 15:59:11 maja Exp $ */
d494 1
@


1.59
log
@Lilliput UM-70 uses the newer DL1x5 chipset. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.58 2010/06/27 01:15:04 maja Exp $ */
d237 1
d245 1
d247 1
@


1.58
log
@Add another one. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.57 2010/06/01 04:53:17 mglocker Exp $ */
d248 1
a248 1
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LUM70 },	DL120 }
@


1.57
log
@Add ``StarTech CONV-USB2DVI'' udl device.
From Bryan Vyhmeister
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.56 2010/04/12 19:42:02 mglocker Exp $ */
d247 2
a248 1
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_CONV },	DL160 }
@


1.56
log
@Enable transparent console cursor by adding a driver internal character
backing store.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.55 2009/10/13 19:33:17 pirofti Exp $ */
d246 2
a247 1
	{ { USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_UM7X0 },	DL120 }
@


1.55
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.54 2009/10/11 12:38:23 mglocker Exp $ */
d652 9
d679 4
d761 5
d808 5
d852 4
d894 4
d944 3
d958 1
a958 1
	int r;
a962 8
	/*
	 * XXX
	 * We can't draw a transparent cursor yet because the chip
	 * doesn't offer an XOR command nor a read command for screen
	 * regions.  Maybe this gets fixed once when wscons(4) is able
	 * to remember the on-screen characters.
	 */

d980 8
a987 2
		r = (sc->udl_fb_block_write)(sc, 0xffff, x, y,
		    ri->ri_font->fontwidth, ri->ri_font->fontheight);
@


1.54
log
@Minor cleanup run, no functional changes;
- Spacing / comments.
- Be constant in using variable types.
- Avoid repeating function-inline definitions for the same variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.53 2009/10/10 08:59:18 maja Exp $ */
d78 1
a78 1
int		udl_activate(struct device *, enum devact);
d483 1
a483 1
udl_activate(struct device *self, enum devact act)
@


1.53
log
@Let udl select the maximum resolution supported by the udl device and the
monitor. Use the EDID parsing from videomode. -moj  ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.52 2009/09/27 18:17:45 mglocker Exp $ */
d231 1
a231 1
	u_int16_t		udl_chip;
d235 12
a246 12
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LCD4300U },	DL120 },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LCD8000U },	DL120 },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LD220 },	DL165 },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_VCUD60 },	DL160 },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_DLDVI },	DL160 },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_VGA10 },	DL120 },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_WSDVI },	DLUNK },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_EC008 },	DL160 },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_HPDOCK },	DL160 },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_M01061 },	DL195 },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_SWDVI },	DL160 },
	{{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_UM7X0 },	DL120 }
d271 1
a271 1
	int err;
a283 2
		uint16_t i;

d357 1
a357 1
		uint8_t i = (sc->sc_dev.dv_cfdata->cf_flags & 0xff) - 1;
d363 1
a363 1
				printf("%s: %s: cf_flags (0x%04x) forced mode to %d\n",
d365 2
a366 1
				    sc->sc_dev.dv_cfdata->cf_flags, i);
d371 1
a371 1
	
d1206 1
a1206 1
	uint16_t chip, uint32_t clock)
d1236 1
d1249 1
a1249 1
	u_int16_t c;
a1938 1

d1942 1
a1942 1
		    (sc->sc_edid_info.edid_preferred_mode->htotal*
d1945 1
a1945 1
		    sc->sc_edid_info.edid_preferred_mode->dot_clock/10;
a1957 1

d1965 1
a1965 1
			    (sc->sc_edid_info.edid_modes[i].htotal*
d1968 1
a1968 1
			    sc->sc_edid_info.edid_modes[i].dot_clock/10;
d1984 1
a1984 1
	 * If no mode found. Use default.
d1986 1
a1986 1
	if (sc->sc_cur_mode == MAX_DL_MODES) {
a1987 1
	}
d1994 1
a1994 1
	 * we always use 16bit color depth for now
@


1.52
log
@If no xfer buffer is free for the UDLIO_DAMAGE ioctl, sleep in the kernel
until one xfer buffer gets freed again, instead userland needs to handle
this.

Help and OK miod@@, matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.51 2009/09/26 09:46:51 mglocker Exp $ */
d49 3
d108 3
d144 1
a144 1
usbd_status	udl_init_resolution(struct udl_softc *, uint8_t *, uint8_t);
d146 1
d229 3
a231 13
static const struct usb_devno udl_devs[] = {
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LCD4300U },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LCD8000U },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_LD220 },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_VCUD60 },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_DLDVI },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_VGA10 },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_WSDVI },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_EC008 },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_HPDOCK },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_M01061 },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_SWDVI },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_UM7X0 }
d234 16
d258 1
a258 1
	if (usb_lookup(udl_devs, uaa->vendor, uaa->product) != NULL)
d274 27
d351 1
a351 1
	 * Initialize resolution.
d353 7
a359 3
	sc->sc_width = 800;	/* XXX shouldn't we do this somewhere else? */
	sc->sc_height = 600;
	sc->sc_depth = 16;
d361 13
a373 2
	error = udl_init_resolution(sc, udl_reg_vals_800,
	    sizeof(udl_reg_vals_800));
d631 1
a631 1
	rasops_init(&sc->sc_ri, 100, 100);
d670 2
d1205 80
a1823 1
	int8_t edid[128];
d1841 1
a1841 1
	error = udl_read_edid(sc, edid);
d1844 2
a1845 4
	DPRINTF(1, "%s: %s: read EDID=\n", DN(sc), FUNC);
#ifdef UDL_DEBUG
	udl_hexdump(edid, sizeof(edid), 0);
#endif
d1878 1
a1878 1
udl_init_resolution(struct udl_softc *sc, uint8_t *buf, uint8_t len)
d1882 1
d1886 1
a1886 1
	for (i = 0; i < len; i++)
d1926 77
@


1.51
log
@Fix artefacts in compression mode especially seen when running X.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.50 2009/09/21 07:41:18 mglocker Exp $ */
d33 1
d35 1
d449 1
a449 1
	int r, mode;
d493 1
d496 9
a504 3
			d->status = UDLIO_STATUS_FAILED;
		} else {
			d->status = UDLIO_STATUS_OK;
d1675 3
@


1.50
log
@Document a private ioctl range for wscons drivers (from Miod).  Therefore
change the UDLIO_DAMAGE ioctl from 0 to 128 and move the ioctl part from
udl.h to udlio.h so we can include it in userland applications.

Suggested and OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.49 2009/09/20 11:24:02 mglocker Exp $ */
d1382 1
a1382 1
	if (cb->compblock > UDL_CB_RESTART_SIZE) {
@


1.49
log
@Remove XXX content about missing screen repaint when switching to EMUL
mode.  Miod mentioned that is it OK to loose screen content when switching
DUMBFB -> EMUL.  Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.48 2009/09/20 10:56:02 mglocker Exp $ */
d48 1
@


1.48
log
@For now just clear the screen when switching to emulation mode (need to
figure out how we can repaint it as well).
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.47 2009/09/20 10:18:20 mglocker Exp $ */
d470 1
a471 1
			/* XXX how shall we repaint the screen? */
@


1.47
log
@Add WSDISPLAYIO_SMODE, WSDISPLAYIO_SVIDEO, WSDISPLAYIO_GVIDEO ioctl.  To
be completed.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.46 2009/09/19 21:48:34 mglocker Exp $ */
d136 1
d374 5
d470 2
a471 1
			/* TODO */
d476 2
d1748 1
a1748 2
	udl_fb_block_write(sc, 0x0000, 0, 0, sc->sc_width, sc->sc_height);
	error = udl_cmd_send(sc);
d1756 18
@


1.46
log
@Rename another function; udl_cmd_set_xfer -> udl_cmd_set_xfer_type is
a bit more self explaining.  No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.45 2009/09/19 21:43:14 mglocker Exp $ */
d440 1
a440 1
	int r;
a446 1
	/* TODO */
d458 14
d474 4
@


1.45
log
@Rename two functions; udl_cmd_get_offset -> udl_cmd_save_offset, and
udl_cmd_set_offset -> udl_cmd_restore_offset, matches better what we
do.  No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.44 2009/09/19 21:34:40 mglocker Exp $ */
d122 1
a122 1
void		udl_cmd_set_xfer(struct udl_softc *, int);
d297 1
a297 1
	udl_cmd_set_xfer(sc, UDL_CMD_XFER_SYNC);
d372 1
a372 1
	udl_cmd_set_xfer(sc, UDL_CMD_XFER_ASYNC);
d1471 1
a1471 1
		if (cb->xfer_method == UDL_CMD_XFER_ASYNC)
d1486 1
a1486 1
udl_cmd_set_xfer(struct udl_softc *sc, int xfer_method)
d1490 1
a1490 1
	cb->xfer_method = xfer_method;
@


1.44
log
@Re-sort function pointer assignments.  No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.43 2009/09/19 20:49:53 mglocker Exp $ */
d123 2
a124 2
void		udl_cmd_get_offset(struct udl_softc *);
void		udl_cmd_set_offset(struct udl_softc *);
d628 1
a628 1
	udl_cmd_get_offset(sc);
d652 1
a652 1
		udl_cmd_set_offset(sc);
d672 1
a672 1
	udl_cmd_get_offset(sc);
d694 1
a694 1
		udl_cmd_set_offset(sc);
d716 1
a716 1
	udl_cmd_get_offset(sc);
d733 1
a733 1
		udl_cmd_set_offset(sc);
d754 1
a754 1
	udl_cmd_get_offset(sc);
d771 1
a771 1
		udl_cmd_set_offset(sc);
d789 1
a789 1
	udl_cmd_get_offset(sc);
d824 1
a824 1
	udl_cmd_set_offset(sc);
d848 1
a848 1
	udl_cmd_get_offset(sc);
d881 1
a881 1
		udl_cmd_set_offset(sc);
d940 1
a940 1
	udl_cmd_get_offset(sc);
d954 1
a954 1
		udl_cmd_set_offset(sc);
d1494 1
a1494 1
udl_cmd_get_offset(struct udl_softc *sc)
d1503 1
a1503 1
udl_cmd_set_offset(struct udl_softc *sc)
@


1.43
log
@If UDLIO_DAMAGE fails to queue the damage drawing request, undo the
operation and tell the X11 driver to retry later (same as for rasops).
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.42 2009/09/19 11:54:16 mglocker Exp $ */
d348 3
d352 2
a353 3
		sc->udl_fb_line_write = udl_fb_line_write;
		sc->udl_fb_block_write = udl_fb_block_write;
		sc->udl_fb_buf_write = udl_fb_buf_write;
a354 2
		sc->udl_fb_line_copy = udl_fb_line_copy;
		sc->udl_fb_block_copy = udl_fb_block_copy;
d357 3
d361 2
a362 3
		sc->udl_fb_line_write = udl_fb_line_write_comp;
		sc->udl_fb_block_write = udl_fb_block_write_comp;
		sc->udl_fb_buf_write = udl_fb_buf_write_comp;
a363 2
		sc->udl_fb_line_copy = udl_fb_line_copy_comp;
		sc->udl_fb_block_copy = udl_fb_block_copy_comp;
@


1.42
log
@Add bits for X11 support over the wsdisplay framework (fully Huffman
compressed).  The upcoming X11 driver mmaps its framebuffer from the
kernel and sends updates via the Damage mechanism.

Committed from a X session on udl, of course.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.41 2009/09/13 18:16:15 mglocker Exp $ */
d466 3
a468 2
			/* XXX we need to inform X11 when we failed to draw */
			printf("%s: %s: damage draw failed!\n", DN(sc), FUNC);
d938 3
d949 1
a949 1
		return (r);
d951 6
a956 3
	r = udl_cmd_send_async(sc);
	if (r != 0)
		return (r);
@


1.41
log
@Remove (last) obsolete panic() case.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.40 2009/09/13 10:40:08 mglocker Exp $ */
d91 4
d107 2
d404 5
d438 3
d452 18
d481 2
d488 16
a503 1
	return (-1);
d931 66
d1169 26
@


1.40
log
@Fix command undo for compression.  Fixes artifacts seen in some cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.39 2009/09/13 08:59:09 mglocker Exp $ */
d1432 2
a1433 2
		/* XXX this shouldn't happen */
		panic("udl_cmd_send_async: buffer full");
@


1.39
log
@Move some real noisy operations to a higher debug level.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.38 2009/09/13 08:11:52 mglocker Exp $ */
d117 2
a118 2
uint32_t	udl_cmd_get_offset(struct udl_softc *);
void		udl_cmd_set_offset(struct udl_softc *, uint32_t);
a570 1
	uint32_t save_offset;
d578 1
a578 1
	save_offset = udl_cmd_get_offset(sc);
d602 1
a602 1
		udl_cmd_set_offset(sc, save_offset);
a614 1
	uint32_t save_offset;
d622 1
a622 1
	save_offset = udl_cmd_get_offset(sc);
d644 1
a644 1
		udl_cmd_set_offset(sc, save_offset);
a658 1
	uint32_t save_offset;
d666 1
a666 1
	save_offset = udl_cmd_get_offset(sc);
d683 1
a683 1
		udl_cmd_set_offset(sc, save_offset);
a697 1
	uint32_t save_offset;
d704 1
a704 1
	save_offset = udl_cmd_get_offset(sc);
d721 1
a721 1
		udl_cmd_set_offset(sc, save_offset);
a735 1
	uint32_t save_offset;
d739 1
a739 1
	save_offset = udl_cmd_get_offset(sc);
d774 1
a774 1
	udl_cmd_set_offset(sc, save_offset);
a783 1
	uint32_t save_offset;
d798 1
a798 1
	save_offset = udl_cmd_get_offset(sc);
d831 1
a831 1
		udl_cmd_set_offset(sc, save_offset);
d1345 1
a1345 1
uint32_t
d1350 2
a1351 1
	return (cb->off);
d1355 1
a1355 1
udl_cmd_set_offset(struct udl_softc *sc, uint32_t offset)
d1359 2
a1360 1
	cb->off = offset;
@


1.38
log
@Use function pointers in erasecols and eraserows for framebuffer
operations, so we do compression in there as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.37 2009/09/12 21:52:25 mglocker Exp $ */
d360 2
a361 1
	udl_init_test(sc);
d742 1
a742 1
	DPRINTF(2, "%s: %s\n", DN(sc), FUNC);
d1490 1
a1490 1
	DPRINTF(2, "%s: %s: sent %d bytes\n", DN(sc), FUNC, len);
@


1.37
log
@Don't use function pointers at places where we always call the same
function.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.36 2009/09/12 12:27:09 mglocker Exp $ */
d678 1
a678 1
	r = udl_fb_block_write(sc, bgc, x, y, cx, cy);
d717 1
a717 1
	r = udl_fb_block_write(sc, bgc, x, y, cx, cy);
@


1.36
log
@Re-sort some functions.  Fix comment.  No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.35 2009/09/11 20:12:51 mglocker Exp $ */
d1837 1
a1837 1
		r = (sc->udl_fb_off_write)(sc, rgb16, off, block);
@


1.35
log
@Don't panic if the command buffer runs full.  Instead try to flush it,
and continue operation afterwards.  If we can't flush immediately, we will
undo the operation and return EAGAIN to wsdisplay (like we do already for
the xfer queue).

This allows us to set higher resolutions (tested up to 1280x1024) without
bumping the command buffer or xfer buffer memory further.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.34 2009/09/09 07:01:20 mglocker Exp $ */
d89 2
d130 6
d138 3
a140 3
int		udl_fb_line_write(struct udl_softc *, uint16_t, uint32_t,
		    uint32_t, uint32_t);
int		udl_fb_block_write(struct udl_softc *, uint16_t, uint32_t,
a141 2
int		udl_fb_buf_write(struct udl_softc *, uint8_t *, uint32_t,
		    uint32_t, uint16_t);
d144 3
a146 1
int		udl_fb_line_copy(struct udl_softc *, uint32_t, uint32_t,
d148 2
a149 2
int		udl_fb_block_copy(struct udl_softc *, uint32_t, uint32_t,
		    uint32_t, uint32_t, uint32_t, uint32_t);
d152 3
a154 3
int		udl_fb_line_write_comp(struct udl_softc *, uint16_t, uint32_t,
		    uint32_t, uint32_t);
int		udl_fb_block_write_comp(struct udl_softc *, uint16_t, uint32_t,
a155 2
int		udl_fb_buf_write_comp(struct udl_softc *, uint8_t *, uint32_t,
		    uint32_t, uint16_t);
a157 6
int		udl_fb_line_copy_comp(struct udl_softc *, uint32_t, uint32_t,
		    uint32_t, uint32_t, uint32_t);
int		udl_fb_block_copy_comp(struct udl_softc *, uint32_t, uint32_t,
		    uint32_t, uint32_t, uint32_t, uint32_t);
int		udl_draw_char(struct udl_softc *, uint16_t, uint16_t, u_int,
		    uint32_t, uint32_t);
d844 43
d1423 1
a1423 1
	/* check if command queue is full */
d1429 1
a1429 1
	/* find a free ring buffer */
d1593 2
a1594 2
udl_fb_off_write(struct udl_softc *sc, uint16_t rgb16, uint32_t off,
    uint16_t width)
d1596 3
a1598 4
	uint8_t buf[UDL_CMD_MAX_DATA_SIZE];
	uint16_t lwidth, lrgb16;
	uint32_t loff;
	int i, r;
d1604 1
a1604 1
	loff = off * 2;
d1609 1
a1609 1
	udl_cmd_insert_int_3(sc, loff);
d1612 16
a1627 3
	for (i = 0; i < lwidth; i += 2) {
		lrgb16 = htobe16(rgb16);
		bcopy(&lrgb16, buf + i, 2);
a1629 2
	udl_cmd_insert_buf(sc, buf, lwidth);

d1660 2
a1661 2
udl_fb_block_write(struct udl_softc *sc, uint16_t rgb16, uint32_t x,
    uint32_t y, uint32_t width, uint32_t height)
d1663 4
a1666 19
	uint32_t i;
	int r;

	for (i = 0; i < height; i++) {
		r = udl_fb_line_write(sc, rgb16, x, y + i, width);
		if (r != 0)
			return (r);
	}

	return (0);
}

int
udl_fb_buf_write(struct udl_softc *sc, uint8_t *buf, uint32_t x,
    uint32_t y, uint16_t width)
{
	uint16_t lwidth;
	uint32_t off;
	int r;
d1672 1
a1672 1
	off = ((y * sc->sc_width) + x) * 2;
d1677 1
a1677 1
	udl_cmd_insert_int_3(sc, off);
d1680 5
d1691 2
a1692 2
udl_fb_off_copy(struct udl_softc *sc, uint32_t src_off, uint32_t dst_off,
    uint16_t width)
d1694 1
a1694 2
	uint32_t ldst_off, lsrc_off;
	int r;
d1696 6
a1701 12
	r = udl_cmd_insert_check(sc, UDL_CMD_COPY_MAX_SIZE);
	if (r != 0)
		return (r);

	ldst_off = dst_off * 2;
	lsrc_off = src_off * 2;

	udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
	udl_cmd_insert_int_1(sc, UDL_BULK_CMD_FB_COPY | UDL_BULK_CMD_FB_WORD);
	udl_cmd_insert_int_3(sc, ldst_off);
	udl_cmd_insert_int_1(sc, width >= UDL_CMD_MAX_PIXEL_COUNT ? 0 : width);
	udl_cmd_insert_int_3(sc, lsrc_off);
d1706 1
d1736 2
a1737 2
udl_fb_block_copy(struct udl_softc *sc, uint32_t src_x, uint32_t src_y,
    uint32_t dst_x, uint32_t dst_y, uint32_t width, uint32_t height)
d1739 9
a1747 1
	int i, r;
d1749 5
a1753 6
	for (i = 0; i < height; i++) {
		r = udl_fb_line_copy(sc, src_x, src_y + i, dst_x, dst_y + i,
		    width);
		if (r != 0)
			return (r);
	}
d1759 2
a1760 2
udl_fb_off_write_comp(struct udl_softc *sc, uint16_t rgb16, uint32_t off,
    uint16_t width)
a1762 1
	uint8_t buf[UDL_CMD_MAX_DATA_SIZE];
d1764 3
a1766 3
	uint16_t lwidth, lrgb16;
	uint32_t loff;
	int i, r, sent;
d1772 1
a1772 1
	loff = off * 2;
a1774 5
	for (i = 0; i < lwidth; i += 2) {
		lrgb16 = htobe16(rgb16);
		bcopy(&lrgb16, buf + i, 2);
	}

d1789 1
a1789 1
		udl_cmd_insert_int_3(sc, loff + sent);
d1807 16
d1849 2
a1850 18
udl_fb_block_write_comp(struct udl_softc *sc, uint16_t rgb16, uint32_t x,
    uint32_t y, uint32_t width, uint32_t height)
{
	uint32_t i;
	int r;

	for (i = 0; i < height; i++) {
		r = udl_fb_line_write_comp(sc, rgb16, x, y + i, width);
		if (r != 0)
			return (r);
	}

	return (0);
}

int
udl_fb_buf_write_comp(struct udl_softc *sc, uint8_t *buf, uint32_t x,
    uint32_t y, uint16_t width)
d1853 1
d1855 3
a1857 3
	uint16_t lwidth;
	uint32_t off;
	int r, sent;
d1863 1
a1863 1
	off = ((y * sc->sc_width) + x) * 2;
d1866 5
d1885 1
a1885 1
		udl_cmd_insert_int_3(sc, off + sent);
d1903 2
a1904 2
udl_fb_off_copy_comp(struct udl_softc *sc, uint32_t src_off, uint32_t dst_off,
    uint16_t width)
d1906 1
a1906 3
	struct udl_cmd_buf *cb = &sc->sc_cmd_buf;
	uint32_t ldst_off, lsrc_off;
	int r;
d1908 5
a1912 26
	r = udl_cmd_insert_check(sc, UDL_CMD_COPY_MAX_SIZE);
	if (r != 0)
		return (r);

	ldst_off = dst_off * 2;
	lsrc_off = src_off * 2;

	/*
	 * A new compressed stream needs the 0xff-into-UDL_REG_SYNC-register
	 * sequence always as first command.
	 */
	if (cb->off == 0)
		udl_cmd_write_reg_1(sc, UDL_REG_SYNC, 0xff);

	r = 0;
	while (r < 1) {
		udl_cmd_insert_int_1(sc, UDL_BULK_SOC);
		udl_cmd_insert_int_1(sc,
		    UDL_BULK_CMD_FB_COPY | UDL_BULK_CMD_FB_WORD);
		udl_cmd_insert_int_3(sc, ldst_off);
		udl_cmd_insert_int_1(sc,
		    width >= UDL_CMD_MAX_PIXEL_COUNT ? 0 : width);
		udl_cmd_insert_int_3(sc, lsrc_off);
		cb->compblock += UDL_CMD_COPY_HEAD_SIZE;

		r = udl_cmd_insert_head_comp(sc, UDL_CMD_COPY_HEAD_SIZE);
d1947 2
a1948 2
udl_fb_block_copy_comp(struct udl_softc *sc, uint32_t src_x, uint32_t src_y,
    uint32_t dst_x, uint32_t dst_y, uint32_t width, uint32_t height)
d1950 3
a1952 1
	int i, r;
d1954 3
a1956 6
	for (i = 0; i < height; i++) {
		r = udl_fb_line_copy_comp(sc, src_x, src_y + i,
		    dst_x, dst_y + i, width);
		if (r != 0)
			return (r);
	}
d1958 2
a1959 2
	return (0);
}
d1961 6
a1966 9
int
udl_draw_char(struct udl_softc *sc, uint16_t fg, uint16_t bg, u_int uc,
    uint32_t x, uint32_t y)
{
	int i, j, ly, r;
	uint8_t *fontchar;
	uint8_t buf[UDL_CMD_MAX_DATA_SIZE];
	uint16_t *line, lrgb16, fontbits, luc;
	struct wsdisplay_font *font = sc->sc_ri.ri_font;
d1968 10
a1977 2
	fontchar = (uint8_t *)(font->data + (uc - font->firstchar) *
	    sc->sc_ri.ri_fontscale);
d1979 1
a1979 25
	ly = y;
	for (i = 0; i < font->fontheight; i++) {
		if (font->fontwidth > 8) {
			fontbits = betoh16(*(uint16_t *)fontchar);
		} else {
			fontbits = *fontchar;
			fontbits = fontbits << 8;
		}
		line = (uint16_t *)buf;

		for (j = 15; j > (15 - font->fontwidth); j--) {
			luc = 1 << j;
			if (fontbits & luc)
				lrgb16 = htobe16(fg);
			else
				lrgb16 = htobe16(bg);
			bcopy(&lrgb16, line, 2);
			line++;
		}
		r = (sc->udl_fb_buf_write)(sc, buf, x, ly, font->fontwidth);
		if (r != 0)
			return (r);
		ly++;

		fontchar += font->stride;
@


1.34
log
@Today we just support a font width up to 8 pixels.  Allow a font width
up to 16 pixels now.

Reported by maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.33 2009/09/06 12:25:38 mglocker Exp $ */
d113 2
a114 1
void		udl_cmd_insert_check(struct udl_cmd_buf *, int);
d128 1
a128 1
void		udl_fb_off_write(struct udl_softc *, uint16_t, uint32_t,
d130 1
a130 1
void		udl_fb_line_write(struct udl_softc *, uint16_t, uint32_t,
d132 1
a132 1
void		udl_fb_block_write(struct udl_softc *, uint16_t, uint32_t,
d134 1
a134 1
void		udl_fb_buf_write(struct udl_softc *, uint8_t *, uint32_t,
d136 1
a136 1
void		udl_fb_off_copy(struct udl_softc *, uint32_t, uint32_t,
d138 1
a138 1
void		udl_fb_line_copy(struct udl_softc *, uint32_t, uint32_t,
d140 1
a140 1
void		udl_fb_block_copy(struct udl_softc *, uint32_t, uint32_t,
d142 1
a142 1
void		udl_fb_off_write_comp(struct udl_softc *, uint16_t, uint32_t,
d144 1
a144 1
void		udl_fb_line_write_comp(struct udl_softc *, uint16_t, uint32_t,
d146 1
a146 1
void		udl_fb_block_write_comp(struct udl_softc *, uint16_t, uint32_t,
d148 1
a148 1
void		udl_fb_buf_write_comp(struct udl_softc *, uint8_t *, uint32_t,
d150 1
a150 1
void		udl_fb_off_copy_comp(struct udl_softc *, uint32_t, uint32_t,
d152 1
a152 1
void		udl_fb_line_copy_comp(struct udl_softc *, uint32_t, uint32_t,
d154 1
a154 1
void		udl_fb_block_copy_comp(struct udl_softc *, uint32_t, uint32_t,
d156 1
a156 1
void		udl_draw_char(struct udl_softc *, uint16_t, uint16_t, u_int,
d289 5
d362 4
d569 1
a569 1
	int sx, sy, dx, dy, cx, cy;
d588 4
a591 1
	(sc->udl_fb_block_copy)(sc, sx, sy, 0, sc->sc_ri.ri_emuheight, cx, cy);
d594 4
a597 1
	(sc->udl_fb_block_copy)(sc, 0, sc->sc_ri.ri_emuheight, dx, dy, cx, cy);
d601 1
d614 1
a614 1
	int sy, dy, cx, cy;
d631 4
a634 1
	(sc->udl_fb_block_copy)(sc, 0, sy, 0, sc->sc_ri.ri_emuheight, cx, cy);
d637 4
a640 1
	(sc->udl_fb_block_copy)(sc, 0, sc->sc_ri.ri_emuheight, 0, dy, cx, cy);
d644 1
d659 1
a659 1
	int x, y, cx, cy;
d678 3
a680 1
	udl_fb_block_write(sc, bgc, x, y, cx, cy);
d684 1
d699 1
a699 1
	int x, y, cx, cy;
d717 3
a719 1
	udl_fb_block_write(sc, bgc, x, y, cx, cy);
d723 1
d736 1
d739 1
d743 2
d757 1
a757 1
		(sc->udl_fb_block_write)(sc, bgc, x, y,
d759 2
d763 3
a765 1
		udl_draw_char(sc, fgc, bgc, uc, x, y);
d776 4
d786 1
d811 1
a811 1
		(sc->udl_fb_block_copy)(sc, x, y, 0, sc->sc_ri.ri_emuheight,
d813 2
d817 1
a817 1
		(sc->udl_fb_block_write)(sc, 0xffff, x, y,
d819 2
d825 1
a825 1
		(sc->udl_fb_block_copy)(sc, 0, sc->sc_ri.ri_emuheight, x, y,
d827 2
d835 1
a1095 2
	udl_cmd_insert_check(cb, 1);

a1106 2
	udl_cmd_insert_check(cb, 2);

a1117 2

	udl_cmd_insert_check(cb, 3);
a1133 2
	udl_cmd_insert_check(cb, 4);

a1144 2
	udl_cmd_insert_check(cb, len);

a1160 2
	udl_cmd_insert_check(cb, len);

a1255 2
	udl_cmd_insert_check(cb, len);

d1274 2
a1275 2
void
udl_cmd_insert_check(struct udl_cmd_buf *cb, int len)
d1277 1
d1279 1
d1283 11
a1293 3
	if (total >=  UDL_CMD_MAX_XFER_SIZE) {
		/* XXX */
		panic("udl_cmd_insert_check: command buffer is full");
d1295 10
d1549 1
a1549 1
void
d1556 5
a1560 1
	int i;
d1576 2
d1580 1
a1580 1
void
d1585 1
d1595 3
a1597 1
		udl_fb_off_write(sc, rgb16, off, block);
d1602 2
d1606 1
a1606 1
void
d1611 7
d1619 1
a1619 2
	for (i = 0; i < height; i++)
		udl_fb_line_write(sc, rgb16, x, y + i, width);
d1622 1
a1622 1
void
d1628 5
d1643 2
d1647 1
a1647 1
void
d1652 5
d1666 2
d1670 1
a1670 1
void
d1675 1
d1686 3
a1688 1
		udl_fb_off_copy(sc, src_off, dst_off, block);
d1694 2
d1698 1
a1698 1
void
d1702 8
a1709 1
	int i;
d1711 1
a1711 2
	for (i = 0; i < height; i++)
		udl_fb_line_copy(sc, src_x, src_y + i, dst_x, dst_y + i, width);
d1714 1
a1714 1
void
d1725 4
d1764 2
d1768 1
a1768 1
void
d1773 1
d1783 3
a1785 1
		(sc->udl_fb_off_write)(sc, rgb16, off, block);
d1790 2
d1794 1
a1794 1
void
d1799 7
d1807 1
a1807 2
	for (i = 0; i < height; i++)
		udl_fb_line_write_comp(sc, rgb16, x, y + i, width);
d1810 1
a1810 1
void
d1820 4
d1854 2
d1858 1
a1858 1
void
d1866 4
d1893 2
d1897 1
a1897 1
void
d1902 1
d1913 3
a1915 1
		udl_fb_off_copy_comp(sc, src_off, dst_off, block);
d1921 2
d1925 1
a1925 1
void
d1929 8
a1936 1
	int i;
d1938 1
a1938 3
	for (i = 0; i < height; i++)
		udl_fb_line_copy_comp(sc, src_x, src_y + i, dst_x, dst_y + i,
		    width);
d1941 1
a1941 1
void
d1945 1
a1945 1
	int i, j, ly;
d1973 3
a1975 1
		(sc->udl_fb_buf_write)(sc, buf, x, ly, font->fontwidth);
d1980 2
@


1.33
log
@Fix typo in comment, safe -> save.

Spotted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.32 2009/09/06 10:36:04 mglocker Exp $ */
d1809 1
a1809 1
	uint8_t *fontchar, fontbits, luc;
d1811 1
a1811 1
	uint16_t *line, lrgb16;
d1819 6
a1824 1
		fontbits = *fontchar;
d1827 1
a1827 1
		for (j = (font->fontwidth - 1); j != -1; j--) {
@


1.32
log
@Fix udl_copycols overlay copy problem by copying area to off-screen first
(same as in udl_copyrows).
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.31 2009/09/05 20:35:30 mglocker Exp $ */
d767 1
a767 1
		/* safe the last character block to off-screen */
d777 1
a777 1
		/* restore the last safed character from off-screen */
@


1.31
log
@Make use of the new wsdisplay ability, committed by miod previously, which
allows our rasops functions to return EAGAIN if our usb command queue is
full.  This gets us rid of the ugly while { delay(); } loop and makes udl
work also on MP kernels now (we faced a deadlock so far because spinning
in that delay() loop with biglock active wasn't that much fun).

With help from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.30 2009/09/05 14:09:35 miod Exp $ */
d577 5
a581 1
	(sc->udl_fb_block_copy)(sc, sx, sy, dx, dy, cx, cy);
@


1.30
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.29 2009/08/30 12:05:23 maja Exp $ */
d114 2
d560 2
d568 2
d579 5
a583 1
	(void)udl_cmd_send_async(sc);
d585 1
a585 1
	return 0;
d594 2
d602 2
d615 5
a619 1
	(void)udl_cmd_send_async(sc);
d621 1
a621 1
	return 0;
d632 2
d640 2
d652 5
a656 1
	(void)udl_cmd_send_async(sc);
d658 1
a658 1
	return 0;
d669 2
d676 2
d688 5
a692 1
	(void)udl_cmd_send_async(sc);
d694 1
a694 1
	return 0;
d733 1
a733 1
	return 0;
d741 3
d756 3
d780 6
a785 1
	(void)udl_cmd_send_async(sc);
d787 1
a787 1
	return 0;
d1247 16
d1320 3
a1322 13
	/* if the ring buffer is full, wait until it's flushed completely */
	if (sc->sc_cmd_xfer_cnt == UDL_CMD_XFER_COUNT) {
		DPRINTF(2, "%s: %s: ring buffer full, wait until flushed\n",
		    DN(sc), FUNC);
		/*
		 * XXX
		 * Yes, this is ugly.  But since we can't tsleep() here, I
		 * have no better idea how we can delay rasops so it doesn't
		 * blow up our command buffer.
		 */
		while (sc->sc_cmd_xfer_cnt > 0)
			delay(100);
	}
d1350 1
@


1.29
log
@Add some new devices. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.28 2009/08/29 08:19:22 mglocker Exp $ */
d83 6
a88 6
void		udl_copycols(void *, int, int, int, int);
void		udl_copyrows(void *, int, int, int);
void		udl_erasecols(void *, int, int, int, long);
void		udl_eraserows(void *, int, int, long);
void		udl_putchar(void *, int, int, u_int, long);
void		udl_do_cursor(struct rasops_info *);
d552 1
a552 1
void
d574 2
d578 1
a578 1
void
d602 2
d606 1
a606 1
void
d631 2
d635 1
a635 1
void
d659 2
d663 1
a663 1
void
d698 2
d702 1
a702 1
void
d741 2
@


1.28
log
@Ooops, revert the last bcopy()-elimination commit.  I forgot that bcopy()
does the job for us on strict alignment archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.27 2009/08/27 19:43:50 mglocker Exp $ */
d212 1
d220 2
a221 1
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_SWDVI }
@


1.27
log
@Reduce padding overhead in compressed blocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.26 2009/08/26 19:30:46 mglocker Exp $ */
d999 1
a999 1
	*(uint16_t *)(cb->buf + cb->off) = lvalue;
d1016 1
a1016 1
	*(uint32_t *)(cb->buf + cb->off) = lvalue;
d1030 1
a1030 1
	*(uint32_t *)(cb->buf + cb->off) = lvalue;
d1442 1
a1442 1
		*(uint16_t *)(buf + i) = lrgb16;
d1562 1
a1562 1
		*(uint16_t *)(buf + i) = lrgb16;
d1758 1
a1758 1
			*line = lrgb16;
@


1.26
log
@Remove obsolete comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.25 2009/08/26 19:07:45 mglocker Exp $ */
a28 2
 *
 * TODO: - Reduce padding overhead in compressed blocks.
d1056 1
a1056 1
	int i, j, bytes, eob, padding;
d1068 1
a1068 1
	if (cb->compblock >= UDL_CB_RESTART1_SIZE) {
d1091 12
a1117 4

		/* we are near the end of the main-block, so quit loop */
		if (cb->compblock >= UDL_CB_RESTART1_SIZE)
			eob = 1;
d1157 1
a1157 1
	if (cb->compblock >= UDL_CB_RESTART2_SIZE) {
@


1.25
log
@Replace some stupidly used bcopy()s by direct assignment.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.24 2009/08/26 12:23:39 mglocker Exp $ */
d30 1
a30 2
 * TODO: - Cleanup the endianess mess.
 *	 - Reduce padding overhead in compressed blocks.
@


1.24
log
@Also avoid __packed struct to Huffman table in the driver side in favour
of performance.  Instead generate the Huffman table with two ints.

Suggested, help and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.23 2009/08/25 19:46:51 mglocker Exp $ */
d30 1
a30 1
 * TODO: - Cleanup the bcopy() and endianess mess.
d1002 1
a1002 1
	bcopy(&lvalue, cb->buf + cb->off, 2);
d1019 1
a1019 1
	bcopy(&lvalue, cb->buf + cb->off, 3);
d1033 1
a1033 1
	bcopy(&lvalue, cb->buf + cb->off, 4);
d1437 1
a1437 1
		bcopy(&lrgb16, buf + i, 2);
d1557 1
a1557 1
		bcopy(&lrgb16, buf + i, 2);
d1753 1
a1753 1
			bcopy(&lrgb16, line, 2);
@


1.23
log
@Enable pixel compression (Huffman pixel difference method).  If the
Huffman table can't be loaded, the driver will operate in uncompressed
mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.22 2009/08/09 20:10:08 mglocker Exp $ */
d1055 1
a1055 1
	uint8_t bit_count, bit_pos;
d1058 1
a1058 1
	uint32_t bit_pattern, bit_cur;
@


1.22
log
@Check if the command buffer has been allocated before we free it.  Fixes
a possible page fault trap while device detach.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.21 2009/08/02 10:38:34 miod Exp $ */
d29 3
d73 1
d102 2
d113 3
d142 14
d317 38
d381 5
d572 1
a572 1
	udl_fb_block_copy(sc, sx, sy, dx, dy, cx, cy);
d595 1
a595 1
	udl_fb_block_copy(sc, 0, sy, 0, sc->sc_ri.ri_emuheight, cx, cy);
d598 1
a598 1
	udl_fb_block_copy(sc, 0, sc->sc_ri.ri_emuheight, 0, dy, cx, cy);
d678 1
a678 1
		udl_fb_block_write(sc, bgc, x, y,
d715 1
a715 1
		udl_fb_block_copy(sc, x, y, 0, sc->sc_ri.ri_emuheight,
d719 1
a719 1
		udl_fb_block_write(sc, 0xffff, x, y,
d725 1
a725 1
		udl_fb_block_copy(sc, 0, sc->sc_ri.ri_emuheight, x, y,
d877 32
d964 1
d1050 120
d1227 1
d1287 1
d1542 188
d1756 1
a1756 1
		udl_fb_buf_write(sc, buf, x, ly, font->fontwidth);
d1800 1
a1800 1
		udl_fb_off_write(sc, color, i * UDL_CMD_MAX_PIXEL_COUNT,
@


1.21
log
@Never return nonzero in a device activate method invoked with DVACT_ACTIVATE,
for this prevents it to be invoked with DVACT_DEACTIVATE later. This had
been sweeped some time ago already, but bad constructs crept in again.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.20 2009/07/23 18:28:28 maja Exp $ */
d875 4
a878 1
	free(cb->buf, M_DEVBUF);
@


1.20
log
@Add some more udl devices. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.19 2009/06/06 16:56:56 yuo Exp $ */
d335 1
a335 1
		return (EOPNOTSUPP);
@


1.19
log
@add another UDL device
- LCD-4300U (century corp.)

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.18 2009/06/01 18:21:51 mglocker Exp $ */
d192 1
d196 4
a199 1
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_EC008 }
@


1.18
log
@Use the background color attribute in udl_erasecols and udl_eraserows
instead hardcoding ``0x0000''.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.17 2009/06/01 18:07:55 mglocker Exp $ */
d190 1
@


1.17
log
@Sort argument list of udl_draw_char similar as udl_fb_* friends.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.16 2009/06/01 17:41:27 mglocker Exp $ */
d537 1
d547 1
d554 1
a554 1
	udl_fb_block_write(sc, 0x0000, x, y, cx, cy);
d564 2
d572 3
d580 1
a580 1
	udl_fb_block_write(sc, 0x0000, x, y, cx, cy);
@


1.16
log
@Allow a font width other than 8 pixels.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.15 2009/06/01 15:47:38 mglocker Exp $ */
d133 2
a134 2
void		udl_draw_char(struct udl_softc *, uint32_t, uint32_t,
		    uint16_t, uint16_t, u_int);
d604 1
a604 1
		udl_draw_char(sc, x, y, fgc, bgc, uc);
d1306 2
a1307 2
udl_draw_char(struct udl_softc *sc, uint32_t x, uint32_t y,
    uint16_t fg, uint16_t bg, u_int uc)
@


1.15
log
@Better naming for some framebuffer functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.14 2009/06/01 15:28:16 mglocker Exp $ */
d1323 1
a1323 1
		for (j = 7; j != -1; j--) {
@


1.14
log
@Reduce data payload for font drawing to a fixed size per character.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.13 2009/06/01 11:26:18 mglocker Exp $ */
d121 1
a121 1
void		udl_fb_pos_write(struct udl_softc *, uint16_t, uint32_t,
d123 1
a123 1
void		udl_fb_blk_write(struct udl_softc *, uint16_t, uint32_t,
d129 1
a129 1
void		udl_fb_pos_copy(struct udl_softc *, uint32_t, uint32_t,
d131 1
a131 1
void		udl_fb_blk_copy(struct udl_softc *, uint32_t, uint32_t,
d501 1
a501 1
	udl_fb_blk_copy(sc, sx, sy, dx, dy, cx, cy);
d524 1
a524 1
	udl_fb_blk_copy(sc, 0, sy, 0, sc->sc_ri.ri_emuheight, cx, cy);
d527 1
a527 1
	udl_fb_blk_copy(sc, 0, sc->sc_ri.ri_emuheight, 0, dy, cx, cy);
d552 1
a552 1
	udl_fb_blk_write(sc, 0x0000, x, y, cx, cy);
d573 1
a573 1
	udl_fb_blk_write(sc, 0x0000, x, y, cx, cy);
d600 1
a600 1
		udl_fb_blk_write(sc, bgc, x, y,
d637 1
a637 1
		udl_fb_blk_copy(sc, x, y, 0, sc->sc_ri.ri_emuheight,
d641 1
a641 1
		udl_fb_blk_write(sc, 0xffff, x, y,
d647 1
a647 1
		udl_fb_blk_copy(sc, 0, sc->sc_ri.ri_emuheight, x, y,
d1167 1
a1167 1
	udl_fb_blk_write(sc, 0x0000, 0, 0, sc->sc_width, sc->sc_height);
d1208 1
a1208 1
udl_fb_pos_write(struct udl_softc *sc, uint16_t rgb16, uint32_t x,
d1229 1
a1229 1
udl_fb_blk_write(struct udl_softc *sc, uint16_t rgb16, uint32_t x,
d1235 1
a1235 1
		udl_fb_pos_write(sc, rgb16, x, y + i, width);
d1273 1
a1273 1
udl_fb_pos_copy(struct udl_softc *sc, uint32_t src_x, uint32_t src_y,
d1296 1
a1296 1
udl_fb_blk_copy(struct udl_softc *sc, uint32_t src_x, uint32_t src_y,
d1302 1
a1302 1
		udl_fb_pos_copy(sc, src_x, src_y + i, dst_x, dst_y + i, width);
@


1.13
log
@I forgot to apply the End Of Command token for async xfers.  Maybe that
caused the stalls seen in some rare conditions?  Who knows ...
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.12 2009/05/31 18:26:44 mglocker Exp $ */
d125 2
d1239 18
d1309 1
a1309 1
	int i, j, lx, ly;
d1311 2
a1314 3
	/* draw the characters background first */
	udl_fb_blk_write(sc, bg, x, y, font->fontwidth, font->fontheight);

a1317 1
	lx = x;
d1321 1
d1326 5
a1330 2
				udl_fb_pos_write(sc, fg, lx, ly, 1);
			lx++;
d1332 1
a1332 1
		lx = x;
@


1.12
log
@We are able to address 256 pixels (16bit) per command not just 128 pixels.
This safes us some protocol overhead, especially when bit blittering
large regions.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.11 2009/05/24 11:11:03 mglocker Exp $ */
d1029 4
@


1.11
log
@Mention broken cursor drawing.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.10 2009/05/24 11:05:16 mglocker Exp $ */
d120 1
a120 1
		    uint8_t);
d126 1
a126 1
		    uint8_t);
d1178 1
a1178 1
    uint8_t width)
d1191 1
a1191 1
	udl_cmd_insert_int_1(sc, width);
d1234 1
a1234 1
    uint8_t width)
d1244 1
a1244 1
	udl_cmd_insert_int_1(sc, width);
d1339 1
a1339 1
	loops = sc->sc_width * sc->sc_height / UDL_CMD_MAX_PIXEL_COUNT;
@


1.10
log
@List product name instead chip type.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.9 2009/05/22 16:03:39 maja Exp $ */
d618 8
@


1.9
log
@Add Unitek Y-2240. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.8 2009/05/21 16:26:56 maja Exp $ */
d188 2
a189 2
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_DL120 },
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_DL160 },
@


1.8
log
@Add Knig CMP-USBVGA10. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.7 2009/05/21 12:28:29 maja Exp $ */
d191 1
@


1.7
log
@Add ForwardVideo EasyCAP008. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.6 2009/05/18 20:21:40 mglocker Exp $ */
d190 1
@


1.6
log
@Add support for the DisplayLink USB<->DVI Adapter.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.5 2009/05/10 19:42:54 mglocker Exp $ */
d189 2
a190 1
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_DL160 }
@


1.5
log
@In debug mode let us know which ioctl has been requested.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.4 2009/05/10 14:53:27 mglocker Exp $ */
d188 2
a189 1
	{ USB_VENDOR_DISPLAYLINK, USB_PRODUCT_DISPLAYLINK_DL120 }
@


1.4
log
@Make inactivity screen blanking (burner) work.
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.3 2009/05/10 09:28:58 mglocker Exp $ */
d341 2
a342 1
	DPRINTF(1, "%s: %s\n", DN(sc), FUNC);
@


1.3
log
@Adjust debug level to be not that noisy by default (level 1).
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.2 2009/05/09 20:06:38 mglocker Exp $ */
d461 1
a461 1
	DPRINTF(1, "%s: %s: %s\n", DN(sc), FUNC, on ? "on" : "off");
d464 1
a464 1
		udl_cmd_write_reg_1(sc, UDL_REG_BLANK_SCREEN, 0x01);
d466 1
a466 1
		udl_cmd_write_reg_1(sc, UDL_REG_BLANK_SCREEN, 0x00);
d470 1
a470 1
	(void)udl_cmd_send(sc);
d1154 1
a1154 1
	udl_cmd_write_reg_1(sc, UDL_REG_BLANK_SCREEN, 0x00);
@


1.2
log
@Return -1 from unused udl_mmap() function instead of 0.

Spotted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udl.c,v 1.1 2009/05/09 19:23:07 mglocker Exp $ */
d992 1
a992 1
		DPRINTF(1, "%s: %s: ring buffer full, wait until flushed\n",
d1028 1
a1028 1
	DPRINTF(1, "%s: %s: sending %d bytes from buffer no. %d\n",
d1060 1
a1060 1
	DPRINTF(1, "%s: %s: sent %d bytes\n", DN(sc), FUNC, len);
@


1.1
log
@Initial console device driver for USB displays based on the DisplayLink
DL-120 / DL-160 graphic chips, using the wsdisplay(4) layer.  Based on
the reversed engineered specifications of Florian Echtler.  The driver
is disabled in GENERIC for now.

Thanks to claudio@@ for donating me a device and to oga@@ and miod@@ for
giving me hints in the graphic and wsdisplay area.

OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d364 1
a364 1
	return (NULL);
@

