head	1.108;
access;
symbols
	OPENBSD_6_1_BASE:1.108
	OPENBSD_6_0:1.106.0.4
	OPENBSD_6_0_BASE:1.106
	OPENBSD_5_9:1.104.0.2
	OPENBSD_5_9_BASE:1.104
	OPENBSD_5_8:1.103.0.4
	OPENBSD_5_8_BASE:1.103
	OPENBSD_5_7:1.101.0.2
	OPENBSD_5_7_BASE:1.101
	OPENBSD_5_6:1.100.0.4
	OPENBSD_5_6_BASE:1.100
	OPENBSD_5_5:1.96.0.4
	OPENBSD_5_5_BASE:1.96
	OPENBSD_5_4:1.90.0.2
	OPENBSD_5_4_BASE:1.90
	OPENBSD_5_3:1.89.0.2
	OPENBSD_5_3_BASE:1.89
	OPENBSD_5_2:1.86.0.2
	OPENBSD_5_2_BASE:1.86
	OPENBSD_5_1_BASE:1.85
	OPENBSD_5_1:1.85.0.2
	OPENBSD_5_0:1.79.0.2
	OPENBSD_5_0_BASE:1.79
	OPENBSD_4_9:1.72.0.2
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.66.0.2
	OPENBSD_4_8_BASE:1.66
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.47.0.4
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.3.0.4
	OPENBSD_4_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.108
date	2016.12.12.04.26.29;	author jsg;	state Exp;
branches;
next	1.107;
commitid	uJaKgVIoCpu0gqe7;

1.107
date	2016.09.21.08.57.17;	author mpi;	state Exp;
branches;
next	1.106;
commitid	WYZaTXNdzJSPAX2J;

1.106
date	2016.06.01.13.20.01;	author chris;	state Exp;
branches;
next	1.105;
commitid	P53OGnpugqHFTDMm;

1.105
date	2016.05.23.15.45.18;	author chris;	state Exp;
branches;
next	1.104;
commitid	3FTDOT7CSzovC24X;

1.104
date	2015.09.29.08.34.28;	author mpi;	state Exp;
branches;
next	1.103;
commitid	KMKxesFafK2BPjVF;

1.103
date	2015.05.05.10.17.09;	author mpi;	state Exp;
branches;
next	1.102;
commitid	aJBHwUadUxs2HOvX;

1.102
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.101;
commitid	p4LJxGKbi0BU2cG6;

1.101
date	2015.01.06.10.42.16;	author mpi;	state Exp;
branches;
next	1.100;
commitid	dy6wYD3o7FF6yDVw;

1.100
date	2014.07.12.21.24.33;	author mpi;	state Exp;
branches;
next	1.99;
commitid	AGVMSdzbrCHVAlSG;

1.99
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.98;
commitid	OBNa5kfxQ2UXoiIw;

1.98
date	2014.05.16.13.53.35;	author dcoppa;	state Exp;
branches;
next	1.97;

1.97
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2013.12.13.17.43.07;	author yuo;	state Exp;
branches;
next	1.95;

1.95
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.94;

1.94
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.93;

1.93
date	2013.11.07.10.34.20;	author pirofti;	state Exp;
branches;
next	1.92;

1.92
date	2013.09.20.15.34.51;	author mpi;	state Exp;
branches;
next	1.91;

1.91
date	2013.08.02.09.00.49;	author mikeb;	state Exp;
branches;
next	1.90;

1.90
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.89;

1.89
date	2013.01.04.02.49.44;	author jsg;	state Exp;
branches;
next	1.88;

1.88
date	2012.12.19.03.35.54;	author jsg;	state Exp;
branches;
next	1.87;

1.87
date	2012.08.03.12.44.37;	author jsg;	state Exp;
branches;
next	1.86;

1.86
date	2012.07.17.09.48.22;	author dcoppa;	state Exp;
branches;
next	1.85;

1.85
date	2012.01.14.10.26.11;	author sthen;	state Exp;
branches;
next	1.84;

1.84
date	2012.01.14.10.24.43;	author sthen;	state Exp;
branches;
next	1.83;

1.83
date	2011.11.19.13.29.50;	author mikeb;	state Exp;
branches;
next	1.82;

1.82
date	2011.11.17.06.13.48;	author jsg;	state Exp;
branches;
next	1.81;

1.81
date	2011.11.11.00.45.30;	author gsoares;	state Exp;
branches;
next	1.80;

1.80
date	2011.10.20.10.44.39;	author dcoppa;	state Exp;
branches;
next	1.79;

1.79
date	2011.07.22.11.37.09;	author dcoppa;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.21.08.20.23;	author dcoppa;	state Exp;
branches;
next	1.77;

1.77
date	2011.07.08.23.10.31;	author yuo;	state Exp;
branches;
next	1.76;

1.76
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.75;

1.75
date	2011.06.15.14.02.10;	author jsg;	state Exp;
branches;
next	1.74;

1.74
date	2011.04.24.02.56.11;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2011.03.19.09.16.28;	author dcoppa;	state Exp;
branches;
next	1.72;

1.72
date	2011.02.01.18.31.11;	author dcoppa;	state Exp;
branches;
next	1.71;

1.71
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.70;

1.70
date	2010.12.30.16.28.12;	author ajacoutot;	state Exp;
branches;
next	1.69;

1.69
date	2010.12.11.22.53.30;	author jsg;	state Exp;
branches;
next	1.68;

1.68
date	2010.10.12.21.08.08;	author mpf;	state Exp;
branches;
next	1.67;

1.67
date	2010.08.21.18.46.30;	author jsg;	state Exp;
branches;
next	1.66;

1.66
date	2010.06.26.00.34.19;	author yuo;	state Exp;
branches;
next	1.65;

1.65
date	2010.06.15.09.43.27;	author fkr;	state Exp;
branches;
next	1.64;

1.64
date	2010.06.14.13.07.01;	author fkr;	state Exp;
branches;
next	1.63;

1.63
date	2010.05.20.11.31.34;	author yuo;	state Exp;
branches;
next	1.62;

1.62
date	2010.04.25.17.09.52;	author jsg;	state Exp;
branches;
next	1.61;

1.61
date	2010.04.14.02.47.58;	author kevlo;	state Exp;
branches;
next	1.60;

1.60
date	2010.04.03.10.55.43;	author mpf;	state Exp;
branches;
next	1.59;

1.59
date	2010.03.27.10.40.00;	author otto;	state Exp;
branches;
next	1.58;

1.58
date	2010.02.22.23.36.42;	author mpf;	state Exp;
branches;
next	1.57;

1.57
date	2010.02.08.22.24.21;	author mpf;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.02.09.12.52;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2009.12.27.21.09.51;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2009.12.17.09.14.02;	author mpf;	state Exp;
branches;
next	1.53;

1.53
date	2009.11.23.12.37.34;	author yuo;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.22.14.27.33;	author sthen;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.12.21.30.08;	author jsg;	state Exp;
branches;
next	1.49;

1.49
date	2009.09.07.20.26.13;	author mpf;	state Exp;
branches;
next	1.48;

1.48
date	2009.08.25.19.51.35;	author robert;	state Exp;
branches;
next	1.47;

1.47
date	2009.05.24.08.30.32;	author sthen;	state Exp;
branches;
next	1.46;

1.46
date	2009.05.12.04.13.01;	author yuo;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.25.15.02.13;	author yuo;	state Exp;
branches;
next	1.44;

1.44
date	2009.02.24.13.23.03;	author yuo;	state Exp;
branches;
next	1.43;

1.43
date	2009.02.18.17.15.21;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.19.10.25.34;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.04.00.23.00;	author fkr;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.01.22.26.27;	author martin;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.23.21.55.08;	author fkr;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.23.14.32.34;	author fkr;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.23.14.20.01;	author fkr;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.21.21.10.03;	author fkr;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.07.20.49.21;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.08.17.17.15;	author yuo;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.30.15.40.39;	author canacar;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.28.10.42.12;	author yuo;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.20.14.24.49;	author yuo;	state Exp;
branches;
next	1.30;

1.30
date	2008.07.02.07.30.13;	author yuo;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.02.09.42.22;	author yuo;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.28.13.33.44;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.26.11.29.50;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.26.11.20.39;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.12.12.24.43;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.09.13.31.47;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.09.13.09.34;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.05.12.19.22;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.25.04.21.15;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2008.02.19.10.57.48;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.31.19.33.49;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.20.00.18.34;	author fkr;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.19.23.59.27;	author jcs;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.13.12.17.30;	author fkr;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.03.09.45.03;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.30.01.22.53;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.13.19.54.21;	author stevesk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.27.19.25.23;	author fkr;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.17.14.26.51;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.24.10.31.22;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.108
log
@Add support for Option iCON 505 from Piotr Isajew and consistently
name other iCON devices the way Option does.
@
text
@/*	$OpenBSD: umsm.c,v 1.107 2016/09/21 08:57:17 mpi Exp $	*/

/*
 * Copyright (c) 2008 Yojiro UO <yuo@@nui.org>
 * Copyright (c) 2006 Jonathan Gray <jsg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Driver for Qualcomm MSM EVDO and UMTS communication devices */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/tty.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/ucomvar.h>
#include <dev/usb/usbcdc.h>
#include <dev/usb/umassvar.h>
#undef DPRINTF	/* undef DPRINTF for umass */

#ifdef UMSM_DEBUG
int     umsmdebug = 0;
#define DPRINTFN(n, x)  do { if (umsmdebug > (n)) printf x; } while (0)
#else
#define DPRINTFN(n, x)
#endif

#define DPRINTF(x) DPRINTFN(0, x)

#define UMSMBUFSZ	4096
#define	UMSM_INTR_INTERVAL	100	/* ms */
#define E220_MODE_CHANGE_REQUEST 0x2
#define TRUINSTALL_CHANGEMODE_REQUEST 0x0b

int umsm_match(struct device *, void *, void *);
void umsm_attach(struct device *, struct device *, void *);
int umsm_detach(struct device *, int);

int umsm_open(void *, int);
void umsm_close(void *, int);
void umsm_intr(struct usbd_xfer *, void *, usbd_status);
void umsm_get_status(void *, int, u_char *, u_char *);
void umsm_set(void *, int, int, int);

struct umsm_softc {
	struct device		 sc_dev;
	struct usbd_device	*sc_udev;
	struct usbd_interface	*sc_iface;
	int			 sc_iface_no;
	struct device		*sc_subdev;
	uint16_t		 sc_flag;

	/* interrupt ep */
	int			 sc_intr_number;
	struct usbd_pipe	*sc_intr_pipe;
	u_char			*sc_intr_buf;
	int			 sc_isize;

	u_char			 sc_lsr;	/* Local status register */
	u_char			 sc_msr;	/* status register */
	u_char			 sc_dtr;	/* current DTR state */
	u_char			 sc_rts;	/* current RTS state */
};

usbd_status umsm_huawei_changemode(struct usbd_device *);
usbd_status umsm_truinstall_changemode(struct usbd_device *);
usbd_status umsm_umass_changemode(struct umsm_softc *);

struct ucom_methods umsm_methods = {
	umsm_get_status,
	umsm_set,
	NULL,
	NULL,
	umsm_open,
	umsm_close,
	NULL,
	NULL,
};

struct umsm_type {
	struct usb_devno	umsm_dev;
	uint16_t		umsm_flag;
/* device type */
#define	DEV_NORMAL	0x0000
#define	DEV_HUAWEI	0x0001
#define	DEV_TRUINSTALL	0x0002
#define	DEV_UMASS1	0x0010
#define	DEV_UMASS2	0x0020
#define	DEV_UMASS3	0x0040
#define	DEV_UMASS4	0x0080
#define	DEV_UMASS5	0x0100
#define	DEV_UMASS6	0x0200
#define	DEV_UMASS7	0x0400
#define	DEV_UMASS8	0x1000
#define DEV_UMASS	(DEV_UMASS1 | DEV_UMASS2 | DEV_UMASS3 | DEV_UMASS4 | \
    DEV_UMASS5 | DEV_UMASS6 | DEV_UMASS7 | DEV_UMASS8)
};

static const struct umsm_type umsm_devs[] = {
	{{ USB_VENDOR_AIRPRIME,	USB_PRODUCT_AIRPRIME_PC5220 }, 0},
	{{ USB_VENDOR_AIRPRIME, USB_PRODUCT_AIRPRIME_AIRCARD_313U }, 0},

	{{ USB_VENDOR_ANYDATA,	USB_PRODUCT_ANYDATA_A2502 }, 0},
	{{ USB_VENDOR_ANYDATA,	USB_PRODUCT_ANYDATA_ADU_500A }, 0},
	{{ USB_VENDOR_ANYDATA,  USB_PRODUCT_ANYDATA_ADU_E100H }, 0},

	{{ USB_VENDOR_DELL,	USB_PRODUCT_DELL_EU870D }, 0},
	{{ USB_VENDOR_DELL,	USB_PRODUCT_DELL_U740 }, 0},
	{{ USB_VENDOR_DELL,	USB_PRODUCT_DELL_W5500 }, 0},

	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E161 }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E173S_INIT }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E173S }, 0},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E180 }, DEV_HUAWEI},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E181 }, DEV_HUAWEI},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E182 }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E1820 }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E220 }, DEV_HUAWEI},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E303 }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E353_INIT }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E510 }, DEV_HUAWEI},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E618 }, DEV_HUAWEI},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E392_INIT }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_EM770W }, 0},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_Mobile }, DEV_HUAWEI},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_K3765_INIT }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_K3765 }, 0},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_MU609 }, DEV_TRUINSTALL},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_K4510 }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_K4511 }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E1750 }, DEV_UMASS5},
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E1752 }, 0},

	{{ USB_VENDOR_HYUNDAI,	USB_PRODUCT_HYUNDAI_UM175 }, 0},

	{{ USB_VENDOR_LONGCHEER, USB_PRODUCT_LONGCHEER_D21LCMASS }, DEV_UMASS3},
	{{ USB_VENDOR_LONGCHEER, USB_PRODUCT_LONGCHEER_D21LC }, 0},
	{{ USB_VENDOR_LONGCHEER, USB_PRODUCT_LONGCHEER_510FUMASS }, DEV_UMASS3},
	{{ USB_VENDOR_LONGCHEER, USB_PRODUCT_LONGCHEER_510FU }, 0},

	{{ USB_VENDOR_KYOCERA2,	USB_PRODUCT_KYOCERA2_KPC650 }, 0},

	{{ USB_VENDOR_MEDIATEK, USB_PRODUCT_MEDIATEK_UMASS }, DEV_UMASS8},
	{{ USB_VENDOR_MEDIATEK, USB_PRODUCT_MEDIATEK_DC_4COM }, 0},

	/* XXX Some qualcomm devices are missing */
	{{ USB_VENDOR_QUALCOMM,	USB_PRODUCT_QUALCOMM_MSM_DRIVER }, DEV_UMASS1},
	{{ USB_VENDOR_QUALCOMM,	USB_PRODUCT_QUALCOMM_MSM_DRIVER2 }, DEV_UMASS4},
	{{ USB_VENDOR_QUALCOMM,	USB_PRODUCT_QUALCOMM_MSM_HSDPA }, 0},
	{{ USB_VENDOR_QUALCOMM,	USB_PRODUCT_QUALCOMM_MSM_HSDPA2 }, 0},
	{{ USB_VENDOR_QUALCOMM,	USB_PRODUCT_QUALCOMM_MSM_HSDPA3 }, 0},

	{{ USB_VENDOR_QUANTA2, USB_PRODUCT_QUANTA2_UMASS }, DEV_UMASS4},
	{{ USB_VENDOR_QUANTA2, USB_PRODUCT_QUANTA2_Q101 }, 0},

	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_AC2746 }, 0},
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_UMASS_INSTALLER }, DEV_UMASS4},
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_UMASS_INSTALLER2 }, DEV_UMASS6},
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_UMASS_INSTALLER3 }, DEV_UMASS7},
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_UMASS_INSTALLER4 }, DEV_UMASS4},
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_K3565Z }, 0},
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_MF112 }, DEV_UMASS4},
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_MF633 }, 0},
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_MF637 }, 0},
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_MSA110UP }, 0},

	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_EXPRESSCARD }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_MERLINV620 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_MERLINV740 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_V720 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_MERLINU740 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_MERLINU740_2 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_U870 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_XU870 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_EU870D }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_X950D }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_ES620 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_U720 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_U727 }, DEV_UMASS1},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_MC950D }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_MERLINX950D }, DEV_UMASS4},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_ZEROCD2 }, DEV_UMASS4},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_U760 }, DEV_UMASS4},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_MC760 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_MC760CD }, DEV_UMASS4},

	{{ USB_VENDOR_NOVATEL1,	USB_PRODUCT_NOVATEL1_FLEXPACKGPS }, 0},

	{{ USB_VENDOR_NOKIA2, USB_PRODUCT_NOKIA2_CS15UMASS }, DEV_UMASS4},
	{{ USB_VENDOR_NOKIA2, USB_PRODUCT_NOKIA2_CS15 }, 0},

	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GT3GFUSION }, 0},
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GT3GPLUS }, 0},
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GT3GQUAD }, 0},
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GT3GQUADPLUS }, 0},
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GSICON72 }, DEV_UMASS1},
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GTHSUPA380E }, 0},
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GTMAX36 }, 0},
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_ICON225 }, DEV_UMASS2},
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_ICON505 }, DEV_UMASS1},
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_SCORPION }, 0},
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_VODAFONEMC3G }, 0},

	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_EM5625 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC5720 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AIRCARD_595 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC5725 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AC597E }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_C597 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AC595U }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AIRCARD_580 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC5720_2 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC5725_2 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC8755_2 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC8765 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC8755 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC8775 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC8755_3 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC8775_2 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AIRCARD_875 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC8780 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC8781 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC8790 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AC880 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AC881 }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AC880E }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AC881E }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AC880U }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AC881U }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AC885U }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_C01SW }, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_USB305}, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_TRUINSTALL }, DEV_TRUINSTALL},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC8355}, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AIRCARD_340U}, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_AIRCARD_770S}, 0},
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_MC7455}, 0},

	{{ USB_VENDOR_TCTMOBILE, USB_PRODUCT_TCTMOBILE_UMASS }, DEV_UMASS3},
	{{ USB_VENDOR_TCTMOBILE, USB_PRODUCT_TCTMOBILE_UMASS_2 }, DEV_UMASS3},
	{{ USB_VENDOR_TCTMOBILE, USB_PRODUCT_TCTMOBILE_UMSM }, 0},
	{{ USB_VENDOR_TCTMOBILE, USB_PRODUCT_TCTMOBILE_UMSM_2 }, 0},
	{{ USB_VENDOR_TCTMOBILE, USB_PRODUCT_TCTMOBILE_UMSM_3 }, 0},

	{{ USB_VENDOR_TOSHIBA, USB_PRODUCT_TOSHIBA_HSDPA }, 0},

	{{ USB_VENDOR_HP, USB_PRODUCT_HP_HS2300 }, 0},

	{{ USB_VENDOR_CMOTECH, USB_PRODUCT_CMOTECH_CNU510 }, 0}, /* ??? */
	{{ USB_VENDOR_CMOTECH, USB_PRODUCT_CMOTECH_CCU550 }, 0}, /* ??? */
	{{ USB_VENDOR_CMOTECH, USB_PRODUCT_CMOTECH_CGU628 }, DEV_UMASS1},
	{{ USB_VENDOR_CMOTECH, USB_PRODUCT_CMOTECH_CGU628_DISK }, 0},
	{{ USB_VENDOR_CMOTECH, USB_PRODUCT_CMOTECH_CNU680 }, DEV_UMASS1},
};

#define umsm_lookup(v, p) ((const struct umsm_type *)usb_lookup(umsm_devs, v, p))

struct cfdriver umsm_cd = {
	NULL, "umsm", DV_DULL
};

const struct cfattach umsm_ca = {
	sizeof(struct umsm_softc), umsm_match, umsm_attach, umsm_detach
};

int
umsm_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	uint16_t flag;

	if (uaa->iface == NULL)
		return UMATCH_NONE;

	/*
	 * Some devices (eg Huawei E220) have multiple interfaces and some
	 * of them are of class umass. Don't claim ownership in such case.
	 */
	if (umsm_lookup(uaa->vendor, uaa->product) != NULL) {
		id = usbd_get_interface_descriptor(uaa->iface);
		flag = umsm_lookup(uaa->vendor, uaa->product)->umsm_flag;

		if (id == NULL || id->bInterfaceClass == UICLASS_MASS) {
			/*
			 * Some high-speed modems require special care.
			 */
			if (flag & DEV_HUAWEI) {
				if (uaa->ifaceno != 2)
					return UMATCH_VENDOR_IFACESUBCLASS;
				else
					return UMATCH_NONE;
			} else if (flag & DEV_UMASS) {
				return UMATCH_VENDOR_IFACESUBCLASS;
			} else if (flag & DEV_TRUINSTALL) {
				return UMATCH_VENDOR_IFACESUBCLASS;
			} else
				return UMATCH_NONE;
		/*
		 * Some devices have interfaces which fail to attach but in
		 * addition seem to make the remaining interfaces unusable. Only
		 * attach whitelisted interfaces in this case.
		 */
		} else if ((uaa->vendor == USB_VENDOR_MEDIATEK &&
			    uaa->product == USB_PRODUCT_MEDIATEK_DC_4COM) &&
			   !(id->bInterfaceClass == UICLASS_VENDOR &&
			    ((id->bInterfaceSubClass == 0x02 &&
			      id->bInterfaceProtocol == 0x01) ||
			     (id->bInterfaceSubClass == 0x00 &&
			      id->bInterfaceProtocol == 0x00)))) {
			return UMATCH_NONE;
		} else
			return UMATCH_VENDOR_IFACESUBCLASS;
	}

	return UMATCH_NONE;
}

void
umsm_attach(struct device *parent, struct device *self, void *aux)
{
	struct umsm_softc *sc = (struct umsm_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct ucom_attach_args uca;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	int i;

	bzero(&uca, sizeof(uca));
	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;
	sc->sc_flag  = umsm_lookup(uaa->vendor, uaa->product)->umsm_flag;

	id = usbd_get_interface_descriptor(sc->sc_iface);

	/*
	 * Some 3G modems have multiple interfaces and some of them
	 * are umass class. Don't claim ownership in such case.
	 */
	if (id == NULL || id->bInterfaceClass == UICLASS_MASS) {
		/*
		 * Some 3G modems require a special request to
		 * enable their modem function.
		 */
		if ((sc->sc_flag & DEV_HUAWEI) && uaa->ifaceno == 0) {
                        umsm_huawei_changemode(uaa->device);
			printf("%s: umass only mode. need to reattach\n",
				sc->sc_dev.dv_xname);
		} else if (sc->sc_flag & DEV_TRUINSTALL) {
			umsm_truinstall_changemode(uaa->device);
			printf("%s: truinstall mode. need to reattach\n",
				sc->sc_dev.dv_xname);
		} else if ((sc->sc_flag & DEV_UMASS) && uaa->ifaceno == 0) {
			umsm_umass_changemode(sc);
		}

		/*
		 * The device will reset its own bus from the device side
		 * when its mode was changed, so just return.
		 */
		return;
	}

	sc->sc_iface_no = id->bInterfaceNumber;
	uca.bulkin = uca.bulkout = -1;
	sc->sc_intr_number = sc->sc_isize = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor found for %d\n",
			    sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_intr_number = ed->bEndpointAddress;
			sc->sc_isize = UGETW(ed->wMaxPacketSize);
			DPRINTF(("%s: find interrupt endpoint for %s\n",
				__func__, sc->sc_dev.dv_xname));
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			uca.bulkin = ed->bEndpointAddress;
		else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			uca.bulkout = ed->bEndpointAddress;
	}
	if (uca.bulkin == -1 || uca.bulkout == -1) {
		printf("%s: missing endpoint\n", sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	sc->sc_dtr = sc->sc_rts = -1;

	/* We need to force size as some devices lie */
	uca.ibufsize = UMSMBUFSZ;
	uca.obufsize = UMSMBUFSZ;
	uca.ibufsizepad = UMSMBUFSZ;
	uca.opkthdrlen = 0;
	uca.device = sc->sc_udev;
	uca.iface = sc->sc_iface;
	uca.methods = &umsm_methods;
	uca.arg = sc;
	uca.info = NULL;
	uca.portno = UCOM_UNK_PORTNO;

	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);
}

int
umsm_detach(struct device *self, int flags)
{
	struct umsm_softc *sc = (struct umsm_softc *)self;
	int rv = 0;

	/* close the interrupt endpoint if that is opened */
	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		usbd_close_pipe(sc->sc_intr_pipe);
		free(sc->sc_intr_buf, M_USBDEV, 0);
		sc->sc_intr_pipe = NULL;
	}

	usbd_deactivate(sc->sc_udev);
	if (sc->sc_subdev != NULL) {
		rv = config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
	}

	return (rv);
}

int
umsm_open(void *addr, int portno)
{
	struct umsm_softc *sc = addr;
	int err;

	if (usbd_is_dying(sc->sc_udev))
		return (ENXIO);

	if (sc->sc_intr_number != -1 && sc->sc_intr_pipe == NULL) {
		sc->sc_intr_buf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);
		err = usbd_open_pipe_intr(sc->sc_iface,
		    sc->sc_intr_number,
		    USBD_SHORT_XFER_OK,
		    &sc->sc_intr_pipe,
		    sc,
		    sc->sc_intr_buf,
		    sc->sc_isize,
		    umsm_intr,
		    UMSM_INTR_INTERVAL);
		if (err) {
			printf("%s: cannot open interrupt pipe (addr %d)\n",
			    sc->sc_dev.dv_xname,
			    sc->sc_intr_number);
			return (EIO);
		}
	}

	return (0);
}

void
umsm_close(void *addr, int portno)
{
	struct umsm_softc *sc = addr;
	int err;

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		err = usbd_close_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: close interrupt pipe failed: %s\n",
			    sc->sc_dev.dv_xname,
			    usbd_errstr(err));
		free(sc->sc_intr_buf, M_USBDEV, 0);
		sc->sc_intr_pipe = NULL;
	}
}

void
umsm_intr(struct usbd_xfer *xfer, void *priv,
	usbd_status status)
{
	struct umsm_softc *sc = priv;
	struct usb_cdc_notification *buf;
	u_char mstatus;

	buf = (struct usb_cdc_notification *)sc->sc_intr_buf;
	if (usbd_is_dying(sc->sc_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		DPRINTF(("%s: umsm_intr: abnormal status: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status)));
		usbd_clear_endpoint_stall_async(sc->sc_intr_pipe);
		return;
	}

	if (buf->bmRequestType != UCDC_NOTIFICATION) {
#if 1 /* test */
		printf("%s: this device is not using CDC notify message in intr pipe.\n"
		    "Please send your dmesg to <bugs@@openbsd.org>, thanks.\n",
		    sc->sc_dev.dv_xname);
		printf("%s: intr buffer 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_intr_buf[0], sc->sc_intr_buf[1],
		    sc->sc_intr_buf[2], sc->sc_intr_buf[3],
		    sc->sc_intr_buf[4], sc->sc_intr_buf[5],
		    sc->sc_intr_buf[6]);
#else
		DPRINTF(("%s: umsm_intr: unknown message type(0x%02x)\n",
		    sc->sc_dev.dv_xname, buf->bmRequestType));
#endif
		return;
	}

	if (buf->bNotification == UCDC_N_SERIAL_STATE) {
		/* invalid message length, discard it */
		if (UGETW(buf->wLength) != 2)
			return;
		/* XXX: sc_lsr is always 0 */
		sc->sc_lsr = sc->sc_msr = 0;
		mstatus = buf->data[0];
		if (ISSET(mstatus, UCDC_N_SERIAL_RI))
			sc->sc_msr |= UMSR_RI;
		if (ISSET(mstatus, UCDC_N_SERIAL_DSR))
			sc->sc_msr |= UMSR_DSR;
		if (ISSET(mstatus, UCDC_N_SERIAL_DCD))
			sc->sc_msr |= UMSR_DCD;
	} else if (buf->bNotification != UCDC_N_CONNECTION_SPEED_CHANGE) {
		DPRINTF(("%s: umsm_intr: unknown notify message (0x%02x)\n",
		    sc->sc_dev.dv_xname, buf->bNotification));
		return;
	}

	ucom_status_change((struct ucom_softc *)sc->sc_subdev);
}

void
umsm_get_status(void *addr, int portno, u_char *lsr, u_char *msr)
{
	struct umsm_softc *sc = addr;

	if (lsr != NULL)
		*lsr = sc->sc_lsr;
	if (msr != NULL)
		*msr = sc->sc_msr;
}

void
umsm_set(void *addr, int portno, int reg, int onoff)
{
	struct umsm_softc *sc = addr;
	usb_device_request_t req;
	int ls;

	switch (reg) {
	case UCOM_SET_DTR:
		if (sc->sc_dtr == onoff)
			return;
		sc->sc_dtr = onoff;
		break;
	case UCOM_SET_RTS:
		if (sc->sc_rts == onoff)
			return;
		sc->sc_rts = onoff;
		break;
	default:
		return;
	}

	/* build a usb request */
	ls = (sc->sc_dtr ? UCDC_LINE_DTR : 0) |
	     (sc->sc_rts ? UCDC_LINE_RTS : 0);
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UCDC_SET_CONTROL_LINE_STATE;
	USETW(req.wValue, ls);
	USETW(req.wIndex, sc->sc_iface_no);
	USETW(req.wLength, 0);

	(void)usbd_do_request(sc->sc_udev, &req, 0);
}

usbd_status
umsm_huawei_changemode(struct usbd_device *dev)
{
	usb_device_request_t req;
	usbd_status err;

	req.bmRequestType = UT_WRITE_DEVICE;
	req.bRequest = UR_SET_FEATURE;
	USETW(req.wValue, UF_DEVICE_REMOTE_WAKEUP);
	USETW(req.wIndex, E220_MODE_CHANGE_REQUEST);
	USETW(req.wLength, 0);

	err = usbd_do_request(dev, &req, 0);
	if (err)
		return (EIO);

	return (0);
}

usbd_status
umsm_truinstall_changemode(struct usbd_device *dev)
{
	usb_device_request_t req;
	usbd_status err;
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = TRUINSTALL_CHANGEMODE_REQUEST;
	USETW(req.wValue, 0x1);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(dev, &req, 0);
	if (err)
		return (EIO);

	return (0);
}

usbd_status
umsm_umass_changemode(struct umsm_softc *sc)
{
#define UMASS_CMD_REZERO_UNIT		0x01
#define UMASS_CMD_START_STOP		0x1b
#define UMASS_CMDPARAM_EJECT		0x02
#define UMASS_SERVICE_ACTION_OUT	0x9f
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	struct usbd_xfer *xfer;
	struct usbd_pipe *cmdpipe;
	usbd_status err;
	u_int32_t n;
	void *bufp;
	int target_ep, i;

	struct umass_bbb_cbw cbw;
	static int dCBWTag = 0x12345678;

	USETDW(cbw.dCBWSignature, CBWSIGNATURE);
	USETDW(cbw.dCBWTag, dCBWTag);
	cbw.bCBWLUN   = 0;
	cbw.bCDBLength= 6;
	bzero(cbw.CBWCDB, sizeof(cbw.CBWCDB));

	switch (sc->sc_flag) {
	case DEV_UMASS1:
		USETDW(cbw.dCBWDataTransferLength, 0x0);
		cbw.bCBWFlags = CBWFLAGS_OUT;
		cbw.CBWCDB[0] = UMASS_CMD_REZERO_UNIT;
		cbw.CBWCDB[1] = 0x0;	/* target LUN: 0 */
		break;
	case DEV_UMASS2:
		USETDW(cbw.dCBWDataTransferLength, 0x1);
		cbw.bCBWFlags = CBWFLAGS_IN;
		cbw.CBWCDB[0] = UMASS_CMD_REZERO_UNIT;
		cbw.CBWCDB[1] = 0x0;	/* target LUN: 0 */
		break;
	case DEV_UMASS3: /* longcheer */
		USETDW(cbw.dCBWDataTransferLength, 0x80);
		cbw.bCBWFlags = CBWFLAGS_IN;
		cbw.CBWCDB[0] = 0x06;
		cbw.CBWCDB[1] = 0xf5;
		cbw.CBWCDB[2] = 0x04;
		cbw.CBWCDB[3] = 0x02;
		cbw.CBWCDB[4] = 0x52;
		cbw.CBWCDB[5] = 0x70;
		break;
	case DEV_UMASS4:
		USETDW(cbw.dCBWDataTransferLength, 0x0);
		cbw.bCBWFlags = CBWFLAGS_OUT;
		cbw.CBWCDB[0] = UMASS_CMD_START_STOP;
		cbw.CBWCDB[1] = 0x00;	/* target LUN: 0 */
		cbw.CBWCDB[4] = UMASS_CMDPARAM_EJECT;
		break;
	case DEV_UMASS5:
		cbw.bCBWFlags = CBWFLAGS_OUT;
		cbw.CBWCDB[0] = 0x11;
		cbw.CBWCDB[1] = 0x06;
		break;
	case DEV_UMASS6:	/* ZTE */
		USETDW(cbw.dCBWDataTransferLength, 0x20);
		cbw.bCBWFlags = CBWFLAGS_IN;
		cbw.bCDBLength= 12;
		cbw.CBWCDB[0] = 0x85;
		cbw.CBWCDB[1] = 0x01;
		cbw.CBWCDB[2] = 0x01;
		cbw.CBWCDB[3] = 0x01;
		cbw.CBWCDB[4] = 0x18;
		cbw.CBWCDB[5] = 0x01;
		cbw.CBWCDB[6] = 0x01;
		cbw.CBWCDB[7] = 0x01;
		cbw.CBWCDB[8] = 0x01;
		cbw.CBWCDB[9] = 0x01;
		break;
	case DEV_UMASS7:	/* ZTE */
		USETDW(cbw.dCBWDataTransferLength, 0xc0);
		cbw.bCBWFlags = CBWFLAGS_IN;
		cbw.CBWCDB[0] = UMASS_SERVICE_ACTION_OUT;
		cbw.CBWCDB[1] = 0x03;
		break;
	case DEV_UMASS8:
		USETDW(cbw.dCBWDataTransferLength, 0x0);
		cbw.bCBWFlags = CBWFLAGS_OUT;
		cbw.CBWCDB[0] = 0xf0;
		cbw.CBWCDB[1] = 0x01;
		cbw.CBWCDB[2] = 0x03;
		break;
	default:
		DPRINTF(("%s: unknown device type.\n", sc->sc_dev.dv_xname));
		break;
	}

	/* get command endpoint address */
	id = usbd_get_interface_descriptor(sc->sc_iface);
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			return (USBD_IOERROR);
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			target_ep = ed->bEndpointAddress;
	}

	/* open command endppoint */
	err = usbd_open_pipe(sc->sc_iface, target_ep,
		USBD_EXCLUSIVE_USE, &cmdpipe);
	if (err) {
		DPRINTF(("%s: open pipe for modem change cmd failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err)));
		return (err);
	}

	xfer = usbd_alloc_xfer(sc->sc_udev);
	if (xfer == NULL) {
		usbd_close_pipe(cmdpipe);
		return (USBD_NOMEM);
	} else {
		bufp = usbd_alloc_buffer(xfer, UMASS_BBB_CBW_SIZE);
		if (bufp == NULL)
			err = USBD_NOMEM;
		else {
			n = UMASS_BBB_CBW_SIZE;
			memcpy(bufp, &cbw, UMASS_BBB_CBW_SIZE);
			usbd_setup_xfer(xfer, cmdpipe, 0, bufp, n,
			    USBD_NO_COPY | USBD_SYNCHRONOUS, 0, NULL);
			err = usbd_transfer(xfer);
			if (err) {
				usbd_clear_endpoint_stall(cmdpipe);
				DPRINTF(("%s: send error:%s", __func__,
				    usbd_errstr(err)));
			}
		}
		usbd_close_pipe(cmdpipe);
		usbd_free_buffer(xfer);
		usbd_free_xfer(xfer);
	}

	return (err);
}
@


1.107
log
@SierraWireless MC7455.

From Yannick Gravel, ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.106 2016/06/01 13:20:01 chris Exp $	*/
a213 1
	{{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GTHSDPA225 }, DEV_UMASS2},
d216 2
@


1.106
log
@Netgear/Sierra Aircard 340U

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.105 2016/05/23 15:45:18 chris Exp $	*/
d253 1
@


1.105
log
@Support Airprime/Sierra AirCard 313U, Netgear/Sierra AirCard 770S

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.104 2015/09/29 08:34:28 mpi Exp $	*/
d251 1
@


1.104
log
@Huawei K4511 3G modem.

From phil AT unita.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.103 2015/05/05 10:17:09 mpi Exp $	*/
d118 1
d251 1
d363 1
a363 2
		} else if ((sc->sc_flag & DEV_TRUINSTALL) &&
			    uaa->ifaceno == 0) {
@


1.103
log
@Huawei MU609 from Cristi√°n Edwards.

ok dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.102 2015/03/14 03:38:50 jsg Exp $	*/
d144 1
a144 1
	{{ USB_VENDOR_HUAWEI,   USB_PRODUCT_HUAWEI_MU609 }, DEV_TRUINSTALL},
d146 1
@


1.102
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.101 2015/01/06 10:42:16 mpi Exp $	*/
d144 1
@


1.101
log
@Support for MEDION S4222 which needs another funky umass quirk.  From
Ingo Feinerer.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.100 2014/07/12 21:24:33 mpi Exp $	*/
a31 1
#include <dev/usb/usbdi_util.h>
@


1.100
log
@Kill the last dumb DVACT_DEACTIVATE handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.99 2014/07/12 18:48:52 tedu Exp $	*/
d112 1
d114 1
a114 1
    DEV_UMASS5 | DEV_UMASS6 | DEV_UMASS7)
d158 3
d310 13
d723 7
@


1.99
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.98 2014/05/16 13:53:35 dcoppa Exp $	*/
a55 1
int umsm_activate(struct device *, int);
d270 1
a270 5
	sizeof(struct umsm_softc),
	umsm_match,
	umsm_attach,
	umsm_detach,
	umsm_activate,
a427 13
}

int
umsm_activate(struct device *self, int act)
{
	struct umsm_softc *sc = (struct umsm_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.98
log
@Add Alcatel OneTouch L100V

Diff from Lukasz Ratajski

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.97 2014/03/07 18:39:02 mpi Exp $	*/
d422 1
a422 1
		free(sc->sc_intr_buf, M_USBDEV);
d495 1
a495 1
		free(sc->sc_intr_buf, M_USBDEV);
@


1.97
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.96 2013/12/13 17:43:07 yuo Exp $	*/
d248 1
d251 1
@


1.96
log
@add an entry for "IIJmobile 510FU"
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.95 2013/11/15 10:17:39 pirofti Exp $	*/
a37 4

#ifdef USB_DEBUG
#define UMSM_DEBUG
#endif
@


1.95
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.94 2013/11/15 08:25:31 pirofti Exp $	*/
d157 2
@


1.94
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.93 2013/11/07 10:34:20 pirofti Exp $	*/
d489 1
a489 5
		err = usbd_abort_pipe(sc->sc_intr_pipe);
       		if (err)
			printf("%s: abort interrupt pipe failed: %s\n",
			    sc->sc_dev.dv_xname,
			    usbd_errstr(err));
@


1.93
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.92 2013/09/20 15:34:51 mpi Exp $	*/
a438 1
	int rv = 0;
a441 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d445 1
a445 1
	return (rv);
@


1.92
log
@Unify and document usbd_transfer(9).

Get rid of the badly named usbd_bulk_transfer() and usbd_intr_transfer()
they were two identical wrappers to submit a synchronous transfer.

Now all synchronous transfers are submited using usbd_setup_xfer(9) and
usbd_transfer(9) explicitly using the USBD_CATCH flag when signals must
be checked.

Previous version ok'd by mglocker@@, with subtle inputs from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.91 2013/08/02 09:00:49 mikeb Exp $	*/
a73 1
	u_char			 sc_dying;
d372 1
a372 1
			sc->sc_dying = 1;
d391 1
a391 1
		sc->sc_dying = 1;
d426 1
a426 1
	sc->sc_dying = 1;
d445 1
a445 1
		sc->sc_dying = 1;
d457 1
a457 1
	if (sc->sc_dying)
d488 1
a488 1
	if (sc->sc_dying)
d516 1
a516 1
	if (sc->sc_dying)
@


1.91
log
@add Sierra Wireless MC8355 (Gobi 3000)
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.90 2013/04/15 09:23:02 mglocker Exp $	*/
d771 5
a775 3
			err = usbd_bulk_transfer(xfer, cmdpipe, USBD_NO_COPY,
			    USBD_NO_TIMEOUT, bufp, &n, "umsm");
			if (err)
d778 1
@


1.90
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.89 2013/01/04 02:49:44 jsg Exp $	*/
d248 1
@


1.89
log
@add Huawei E353
from/tested by Zavisa Nikac
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.88 2012/12/19 03:35:54 jsg Exp $	*/
d64 1
a64 1
void umsm_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d70 2
a71 2
	usbd_device_handle	 sc_udev;
	usbd_interface_handle	 sc_iface;
d79 1
a79 1
	usbd_pipe_handle	 sc_intr_pipe;
d89 2
a90 2
usbd_status umsm_huawei_changemode(usbd_device_handle);
usbd_status umsm_truinstall_changemode(usbd_device_handle);
d508 1
a508 1
umsm_intr(usbd_xfer_handle xfer, usbd_private_handle priv,
d512 1
a512 1
	usb_cdc_notification_t *buf;
d515 1
a515 1
	buf = (usb_cdc_notification_t *)sc->sc_intr_buf;
d615 1
a615 1
umsm_huawei_changemode(usbd_device_handle dev)
d634 1
a634 1
umsm_truinstall_changemode(usbd_device_handle dev)
d660 2
a661 2
	usbd_xfer_handle xfer;
	usbd_pipe_handle cmdpipe;
d667 1
a667 1
	umass_bbb_cbw_t	cbw;
@


1.88
log
@add another umsm device that uses the qualcomm vid.  named
Aeon 921T by the importer, it isn't clear what the real name is.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.87 2012/08/03 12:44:37 jsg Exp $	*/
d142 1
@


1.87
log
@add HUAWEI E392, tested by Alexei Malinin
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.86 2012/07/17 09:48:22 dcoppa Exp $	*/
d162 1
d165 1
@


1.86
log
@Add the Huawei Mobile E303.

From Andreas Bartelt, obsd AT bartula DOT de

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.85 2012/01/14 10:26:11 sthen Exp $	*/
d144 1
@


1.85
log
@KNF whitespace; no change with diff -w
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.84 2012/01/14 10:24:43 sthen Exp $	*/
d141 1
@


1.84
log
@Support Huawei K4510 with DEV_UMASS5; Daniele Pilenga
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.83 2011/11/19 13:29:50 mikeb Exp $	*/
d57 4
a60 4
int umsm_match(struct device *, void *, void *); 
void umsm_attach(struct device *, struct device *, void *); 
int umsm_detach(struct device *, int); 
int umsm_activate(struct device *, int); 
d121 1
a121 1
 
d150 1
a150 1
	
d152 1
a152 1
	
d261 10
a270 10
struct cfdriver umsm_cd = { 
	NULL, "umsm", DV_DULL 
}; 

const struct cfattach umsm_ca = { 
	sizeof(struct umsm_softc), 
	umsm_match, 
	umsm_attach, 
	umsm_detach, 
	umsm_activate, 
d296 1
a296 1
				if (uaa->ifaceno != 2) 
d308 1
a308 1
	} 
d341 1
a341 1
			printf("%s: umass only mode. need to reattach\n", 
d346 1
a346 1
			printf("%s: truinstall mode. need to reattach\n", 
d353 2
a354 2
		 * The device will reset its own bus from the device side 
		 * when its mode was changed, so just return. 
d375 1
a375 1
			DPRINTF(("%s: find interrupt endpoint for %s\n", 
d529 1
a529 1
		printf("%s: intr buffer 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n", 
d531 4
a534 4
		    sc->sc_intr_buf[0], sc->sc_intr_buf[1], 
		    sc->sc_intr_buf[2], sc->sc_intr_buf[3], 
		    sc->sc_intr_buf[4], sc->sc_intr_buf[5], 
		    sc->sc_intr_buf[6]); 
d622 1
a622 1
	if (err) 
d640 1
a640 1
	if (err) 
d647 1
a647 1
umsm_umass_changemode(struct umsm_softc *sc) 
d668 1
a668 1
	cbw.bCDBLength= 6; 
d673 1
a673 1
		USETDW(cbw.dCBWDataTransferLength, 0x0); 
d679 1
a679 1
		USETDW(cbw.dCBWDataTransferLength, 0x1); 
d685 1
a685 1
		USETDW(cbw.dCBWDataTransferLength, 0x80); 
d695 1
a695 1
		USETDW(cbw.dCBWDataTransferLength, 0x0); 
d707 1
a707 1
		USETDW(cbw.dCBWDataTransferLength, 0x20); 
d709 1
a709 1
		cbw.bCDBLength= 12; 
d775 1
a775 1
		
@


1.83
log
@Add ZTE MF190;  ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.82 2011/11/17 06:13:48 jsg Exp $	*/
d147 1
@


1.82
log
@support Huawei EM770W
from Baurzhan Muftakhidinov
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.81 2011/11/11 00:45:30 gsoares Exp $	*/
d169 1
@


1.81
log
@add support for HUAWEI Mobile E173s

tested by me
ok jsg@@ sthen@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.80 2011/10/20 10:44:39 dcoppa Exp $	*/
d143 1
@


1.80
log
@Add Alcatel One Touch X210/X220 (another rebadged TCT Mobile modem)

ok sthen@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.79 2011/07/22 11:37:09 dcoppa Exp $	*/
d134 2
@


1.79
log
@Add the Huawei E181.

From Chris Turner <c.turner(at)199technologies(dot)com>

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.78 2011/07/21 08:20:23 dcoppa Exp $	*/
d241 1
@


1.78
log
@Add the Huawei E1750 USB modem

From bsd.user(at)mail(dot)ru

ok jsg@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.77 2011/07/08 23:10:31 yuo Exp $	*/
d135 1
@


1.77
log
@add support for HUAWEI E1752 seriese modem

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.76 2011/07/03 15:47:17 matthew Exp $	*/
d143 1
@


1.76
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.75 2011/06/15 14:02:10 jsg Exp $	*/
d143 1
@


1.75
log
@Add support for ZTE AC2746.
Slightly changed version of a diff from Martin Furter.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.74 2011/04/24 02:56:11 deraadt Exp $	*/
a427 3
	case DVACT_ACTIVATE:
		break;

@


1.74
log
@Match Sierra USB305; from Erik Mugele
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.73 2011/03/19 09:16:28 dcoppa Exp $	*/
d110 1
a110 1
#define DEV_TRUINSTALL	0x0002
d117 1
d119 1
a119 1
    DEV_UMASS5 | DEV_UMASS6)
d159 2
d162 1
a162 1
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_UMASS_INSTALLER }, DEV_UMASS4},
d643 4
a646 3
#define UMASS_CMD_REZERO_UNIT	0x01
#define UMASS_CMD_START_STOP	0x1b
#define UMASS_CMDPARAM_EJECT	0x02
d714 6
@


1.73
log
@Add the ONDA MSA110UP USB modem
Tested by Sergio Charpinel Jr.

OK sthen@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.72 2011/02/01 18:31:11 dcoppa Exp $	*/
d230 1
@


1.72
log
@Add the Toshiba 3G HSDPA MiniCard, found in my Dell Latitude D630.

Ok jsg@@, sthen@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.71 2011/01/25 20:03:36 jakemsr Exp $	*/
d164 1
@


1.71
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.70 2010/12/30 16:28:12 ajacoutot Exp $	*/
d233 2
@


1.70
log
@Add the Novatel EU870D HSDPA modem found in (at least) Dell XT.

ok robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.69 2010/12/11 22:53:30 jsg Exp $	*/
a387 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);
	
a409 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.69
log
@Add support for the ZTE MF112 from MERIGHI Marcus.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.68 2010/10/12 21:08:08 mpf Exp $	*/
d128 1
@


1.68
log
@Add Sierra Wireless MC8790.
OK yuo, fkr, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.67 2010/08/21 18:46:30 jsg Exp $	*/
d160 1
@


1.67
log
@Match the Huawei E1820, from David Zeillinger.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.66 2010/06/26 00:34:19 yuo Exp $	*/
d218 1
@


1.66
log
@add HUAWEI E182 (aka Emobile D31HW)
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.65 2010/06/15 09:43:27 fkr Exp $	*/
d134 1
@


1.65
log
@various Huawei 3g devices share a usb id, some of them need DEV_UMASS5 for proper
initialization, old ones still work with DEV_UMASS5 as well. This enables a
whole bunch of newer huawei devices to work.
Also reported on misc@@ by David Zeillinger.

discussed with jsg@@ and mpf@@
ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.64 2010/06/14 13:07:01 fkr Exp $	*/
d133 1
@


1.64
log
@attach CNU-680 to umsm(4)
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.63 2010/05/20 11:31:34 yuo Exp $	*/
d131 1
a131 1
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E161 }, DEV_UMASS1},
@


1.63
log
@add mode change command to support ZTE 3G modem (MF633 etc)

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.62 2010/04/25 17:09:52 jsg Exp $	*/
d235 1
@


1.62
log
@Novatel MC760 bits from Ted Roby <ted.roby@@gmail.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.61 2010/04/14 02:47:58 kevlo Exp $	*/
d116 1
d118 1
a118 1
    DEV_UMASS5)
d155 2
a156 1
	{{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_UMASS }, DEV_UMASS4},
d158 1
d691 15
@


1.61
log
@add support for Quanta Q101.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.60 2010/04/03 10:55:43 mpf Exp $	*/
d175 2
@


1.60
log
@Add support for Nokia Internet Stick CS-15.
Device and initial diff from Patrick Wildt. Thanks.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.59 2010/03/27 10:40:00 otto Exp $	*/
d150 3
@


1.59
log
@add mode switch code for Huawei K3765; much help from & ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.58 2010/02/22 23:36:42 mpf Exp $	*/
d174 3
@


1.58
log
@Rename QUALCOMM3 to ZTE.
Add support for ZTE MF637.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.57 2010/02/08 22:24:21 mpf Exp $	*/
d115 3
a117 1
#define DEV_UMASS	(DEV_UMASS1 | DEV_UMASS2 | DEV_UMASS3 | DEV_UMASS4)
d136 2
d263 1
a263 1
				if  (uaa->ifaceno != 2) 
d675 5
@


1.57
log
@Add ZTE K3565-Z USB MSM modem.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.56 2010/01/02 09:12:52 jsg Exp $	*/
d147 3
a149 3
	{{ USB_VENDOR_QUALCOMM3, USB_PRODUCT_QUALCOMM3_K3565Z_UMASS },
	    DEV_UMASS4},
	{{ USB_VENDOR_QUALCOMM3, USB_PRODUCT_QUALCOMM3_K3565Z }, 0},
@


1.56
log
@When finding certain novatel devices in mass storage mode
we need to do scsi ejects.

One reported/tested by lahrcm@@hotmail.com another suggested
by David Coppa based on what FreeBSD does.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.55 2009/12/27 21:09:51 jsg Exp $	*/
d146 4
@


1.55
log
@Huawei 180E, from and tested by Bruce O'Neel.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.54 2009/12/17 09:14:02 mpf Exp $	*/
d162 2
a163 2
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_ZEROCD2 }, 0},
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_U760 }, 0},
@


1.54
log
@Add support for Huawei E161.
OK jsg@@, yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.53 2009/11/23 12:37:34 yuo Exp $	*/
d129 1
@


1.53
log
@add new umsm type modems: Softbank C01SW (Sierra OEM) and
Emobile H12HW (Huawei OEM)

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.52 2009/10/22 14:27:33 sthen Exp $	*/
d128 1
@


1.52
log
@add Option GT HSUPA 380E, as found in the Acer AspireOne AOA150-BG model.
ok mpf@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.51 2009/10/13 19:33:19 pirofti Exp $	*/
d131 1
d202 1
@


1.51
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.50 2009/10/12 21:30:08 jsg Exp $	*/
d170 1
@


1.50
log
@TCT Mobile modem, rebadged as Alcatel One Touch X060/X200.
From David Coppa <dcoppa@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.49 2009/09/07 20:26:13 mpf Exp $	*/
d60 1
a60 1
int umsm_activate(struct device *, enum devact); 
d391 1
a391 1
umsm_activate(struct device *self, enum devact act)
@


1.49
log
@Add another umass-to-modem request type which is needed for
the Novatel MC950D. Input & ok jsg; ok fkr, deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.48 2009/08/25 19:51:35 robert Exp $	*/
d201 3
@


1.48
log
@Add USB_PRODUCT_NOVATEL_EU870D that can be found in some dell d430
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.47 2009/05/24 08:30:32 sthen Exp $	*/
d114 2
a115 1
#define DEV_UMASS	(DEV_UMASS1 | DEV_UMASS2 | DEV_UMASS3)
d158 1
a158 1
	{{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_MERLINX950D }, 0},
d610 2
d652 7
@


1.47
log
@- rename Audiovox vendor to Hyundai
- add Pantech UM175 to umsm(4)

from Dan Colish on tech@@; ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.46 2009/05/12 04:13:01 yuo Exp $	*/
d151 1
@


1.46
log
@add support for the sierra's Truinstlal enabled modems. (ex. Sierra 881U)

ok @@jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.45 2009/03/25 15:02:13 yuo Exp $	*/
d130 3
a132 1

@


1.45
log
@add new umsm(4) device, Emobile D21LC (longcheer's OEM product)

ok jsg@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.44 2009/02/24 13:23:03 yuo Exp $	*/
d55 1
d90 1
d110 1
d196 1
a196 1
	{{ USB_VENDOR_SIERRA, USB_PRODUCT_SIERRA_TRUINSTALL }, DEV_UMASS1},
d247 1
a247 1
			} else if (flag & DEV_UMASS)
d249 3
a251 1
			else
d290 5
d575 18
@


1.44
log
@move AnyDATA ADU-E100H to umsm(4) from ubsa(4) as it uses msm chipset.

reported by denis1482
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.43 2009/02/18 17:15:21 deraadt Exp $	*/
d110 2
a111 1
#define DEV_UMASS	(DEV_UMASS1 | DEV_UMASS2)
d128 3
a594 2
	cbw.CBWCDB[0] = UMASS_CMD_REZERO_UNIT;
	cbw.CBWCDB[1] = 0x0;	/* target LUN: 0 */
d600 2
d606 12
@


1.43
log
@Make the best guesses possible about newer usb modems and in which modes
they need to be started up.  Some limited discussion with yuo@@ and fkr@@,
who to a large degree I think have punted on even trying to stay ahead
of the curve here.  Come on guys.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.42 2009/01/19 10:25:34 jsg Exp $	*/
d118 1
@


1.42
log
@Add support for Novatel Wireless Ovation U727.
Tested by Seth Hanford.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.41 2008/12/04 00:23:00 fkr Exp $	*/
d115 1
d118 2
d121 1
d125 1
d127 2
a128 17
	{{ USB_VENDOR_NOVATEL1,	USB_PRODUCT_NOVATEL1_FLEXPACKGPS }, 0},
	{{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_EXPRESSCARD }, 0},
	{{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_MERLINV620 }, 0},
	{{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_S720 }, 0},
	{{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_U720 }, 0},
	{{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_U727 }, DEV_UMASS1},
	{{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_XU870 }, 0},
	{{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_ES620 }, 0},
	{{ USB_VENDOR_OPTION,	USB_PRODUCT_OPTION_GT3GFUSION }, 0},
	{{ USB_VENDOR_OPTION,	USB_PRODUCT_OPTION_GT3GPLUS }, 0},
	{{ USB_VENDOR_OPTION,	USB_PRODUCT_OPTION_GT3GQUAD }, 0},
	{{ USB_VENDOR_OPTION,	USB_PRODUCT_OPTION_GT3GQUADPLUS }, 0},
	{{ USB_VENDOR_OPTION,	USB_PRODUCT_OPTION_GSICON72 }, DEV_UMASS1},
	{{ USB_VENDOR_OPTION,	USB_PRODUCT_OPTION_GTHSDPA225 }, DEV_UMASS2},
	{{ USB_VENDOR_OPTION,	USB_PRODUCT_OPTION_GTMAX36 }, 0},
	{{ USB_VENDOR_OPTION,	USB_PRODUCT_OPTION_SCORPION }, 0},
	{{ USB_VENDOR_OPTION,	USB_PRODUCT_OPTION_VODAFONEMC3G }, 0},
d132 64
a195 12
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_EM5625 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_AIRCARD_580 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_AIRCARD_595 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_AIRCARD_875 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC5720 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC5725 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC5725_2 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC8755 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC8755_2 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC8755_3 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC8765 }, 0},
	{{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC8775 }, 0},
@


1.41
log
@move Option GlobeTrotter 3G Quad / 3G Quad Plus and the
Vodafone Mobile Connect from ubsa(4) to umsm(4) as these should work
better with that driver.
discussed with yuo@@, jsg@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.40 2008/12/01 22:26:27 martin Exp $	*/
d127 1
@


1.40
log
@add the Huawei E510 modem

ok fkr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.39 2008/11/23 21:55:08 fkr Exp $	*/
d131 2
d137 1
@


1.39
log
@umsmdebug should be 0.
ok yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.38 2008/11/23 14:32:34 fkr Exp $	*/
d119 1
@


1.38
log
@move another Option modem from ubsa(4) to umsm(4), as umsm(4) supports
this much better.
ok yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.37 2008/11/23 14:20:01 fkr Exp $	*/
d44 1
a44 1
int     umsmdebug = 1;
@


1.37
log
@correct some typos in the comments
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.36 2008/11/21 21:10:03 fkr Exp $	*/
d132 1
@


1.36
log
@move Option Globetrotter GT Fusion from ubsa(4) to umsm(4) since it
does CDC. discussed with yuo@@ and jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.35 2008/11/07 20:49:21 deraadt Exp $	*/
d184 1
a184 1
			 * Some high-speed modem requre special care.
d220 2
a221 2
	 * Some 3G modem devices have multiple interface and some 
	 * of them are umass class. Don't claim ownership in such case.
d225 2
a226 2
		 * Some 3G modems require special request to
		 * enable it's modem function.
@


1.35
log
@same umass dance required for Huawei E169g/E618; Stefan Sperling; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.34 2008/10/08 17:17:15 yuo Exp $	*/
d128 1
@


1.34
log
@As the Option N.V. Globetrotter HSDPA Modem is not compatible
with ubsa(4), it is moved to umsm(4).

ok jsg@@, reported by Daniele Pilenga
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.33 2008/07/30 15:40:39 canacar Exp $	*/
d119 1
a119 1
	{{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E618 }, 0},
@


1.33
log
@Add an alternate ID for Sierra Wireless MC5725 modem, found
in a Lenovo T60, reported by Juan Delgado. ok you@@, jsg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.32 2008/07/28 10:42:12 yuo Exp $	*/
d131 1
@


1.32
log
@add another 3G modems support to umsm(4).
 - Option GlobeSuffer ICON7.2
 - Option GlobeTrotter HSDPA ICON 225

These modems require special request to change its mode to modem.
It is similar with huawei E220, but these modems using UMASS
standard query to change mode.

tested by pyr@@ and ajacoutot@@
ok jsg@@ and pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.31 2008/07/20 14:24:49 yuo Exp $	*/
d140 1
@


1.31
log
@Huawei E618 and E620 is not compatible with ubsa(4).
This patch moves these device to umsm(4).

reported by Aleksander Piotrowski, ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.30 2008/07/02 07:30:13 yuo Exp $	*/
d4 1
d36 2
a51 1

a66 2
usbd_status umsm_e220_changemode(usbd_device_handle);

d74 1
d88 3
d102 43
a144 30
static const struct usb_devno umsm_devs[] = {
	{ USB_VENDOR_AIRPRIME,	USB_PRODUCT_AIRPRIME_PC5220 },
	{ USB_VENDOR_ANYDATA,	USB_PRODUCT_ANYDATA_A2502 },
	{ USB_VENDOR_ANYDATA,	USB_PRODUCT_ANYDATA_ADU_500A },
	{ USB_VENDOR_DELL,	USB_PRODUCT_DELL_W5500 },
	{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E220 },
	{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E618 },
	{ USB_VENDOR_KYOCERA2,	USB_PRODUCT_KYOCERA2_KPC650 },
	{ USB_VENDOR_NOVATEL1,	USB_PRODUCT_NOVATEL1_FLEXPACKGPS },
	{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_EXPRESSCARD },
	{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_MERLINV620 },
	{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_S720 },
	{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_U720 },
	{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_XU870 },
	{ USB_VENDOR_NOVATEL,	USB_PRODUCT_NOVATEL_ES620 },
	{ USB_VENDOR_OPTION,	USB_PRODUCT_OPTION_GT3GPLUS },
	{ USB_VENDOR_QUALCOMM,	USB_PRODUCT_QUALCOMM_MSM_DRIVER },
	{ USB_VENDOR_QUALCOMM,	USB_PRODUCT_QUALCOMM_MSM_HSDPA },
	{ USB_VENDOR_QUALCOMM,	USB_PRODUCT_QUALCOMM_MSM_HSDPA2 },
	{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_EM5625 },
	{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_AIRCARD_580 },
	{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_AIRCARD_595 },
	{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_AIRCARD_875 },
	{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC5720 },
	{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC5725 },
	{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC8755 },
	{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC8755_2 },
	{ USB_VENDOR_SIERRA,    USB_PRODUCT_SIERRA_MC8755_3 },
	{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC8765 },
	{ USB_VENDOR_SIERRA,	USB_PRODUCT_SIERRA_MC8775 },
d147 1
d166 1
d172 1
a172 1
	 * Some devices(eg Huawei E220) have multiple interfaces and some
d175 14
a188 9
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL || id->bInterfaceClass == UICLASS_MASS) {
		/*
		 * E220 is a dual mode device, so we have to deal with
		 * it differently.
		 */
		if (uaa->vendor  == USB_VENDOR_HUAWEI &&
                    uaa->product == USB_PRODUCT_HUAWEI_E220) {
			if  (uaa->ifaceno != 2) 
d193 2
a194 2
			return UMATCH_NONE;
	}
d196 1
a196 2
	return (usb_lookup(umsm_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_IFACESUBCLASS : UMATCH_NONE;
d212 1
d216 4
d222 2
a223 2
		 * Huawei E220 requires a special command to change into
		 * modem mode
d225 2
a226 9
		if (uaa->vendor  == USB_VENDOR_HUAWEI &&
		    uaa->product == USB_PRODUCT_HUAWEI_E220 &&
		    uaa->ifaceno == 0) {
                        umsm_e220_changemode(uaa->device);
			/*
			 * The device will reset its own bus from the
			 * device side, so we just return from this device
			 * probe process. 
			 */
d229 2
d232 5
a389 1

a498 1

d500 1
a500 1
umsm_e220_changemode(usbd_device_handle dev)
d516 85
@


1.30
log
@fix interrupt pipe processing.

    many high speed modem devices use CDC-like notify message protocol
    in there intr pipe rather than ubsa(4) compatible protocol.
    now umsm(4) interrupt message will be treated as CDC notify.

    And, this patch contains "verbose message patch" to find incompatible
    device in umsm(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.29 2008/06/02 09:42:22 yuo Exp $	*/
d104 1
@


1.29
log
@fix kernel freeze when the device unpluged (and the device was still active)

ok jsg@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.28 2008/05/28 13:33:44 pyr Exp $	*/
d34 1
d63 1
d71 1
d83 2
d89 1
a89 1
	NULL,
d211 1
d242 2
d254 1
d369 2
a370 1
	u_char *buf;
d372 1
a372 1
	buf = sc->sc_intr_buf;
d386 36
a421 3
	/* XXX */
	sc->sc_lsr = buf[2];
	sc->sc_msr = buf[3];
d436 35
@


1.28
log
@Add support for Option GlobeTrotter 3G+ cards as distributed by Orange
in umsm.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.27 2008/05/26 11:29:50 jsg Exp $	*/
d258 8
@


1.27
log
@Limit to 80 char width and tweak comments for readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.25 2008/05/12 12:24:43 jsg Exp $	*/
d107 1
@


1.26
log
@Properly handle usbd_get_interface_descriptor() returning NULL.
From Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d186 4
a189 1
		/* Huawei E220 require special command to change its mode to modem */
d191 2
a192 1
                    uaa->product == USB_PRODUCT_HUAWEI_E220 && uaa->ifaceno == 0) {
d195 3
a197 2
			 * the device will reset its own bus from device side, therefore
			 * we only return from this device probe process. 
@


1.25
log
@If we find an E220 device in umass mode send the magic command
to enable the serial portions of the device.
From Yojiro UO <yuo@@iijlab.net>, tested by bernd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.24 2008/05/09 13:31:47 jsg Exp $	*/
a195 1
			return;
d197 1
@


1.24
log
@Add support for NTT DoCoMo A2502.
From/tested by Yojiro UO <yuo@@iijlab.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.23 2008/05/09 13:09:34 jsg Exp $	*/
d35 14
d51 1
d63 2
d150 14
a163 2
	if (id == NULL || id->bInterfaceClass == UICLASS_MASS)
		return UMATCH_NONE;
d185 15
d201 1
d215 2
a216 2
			printf("%s: find interrupt endpoint for %s\n", 
				__func__, sc->sc_dev.dv_xname);
d356 2
a357 2
		printf("%s: umsm_intr: abnormal status: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status));
d378 19
@


1.23
log
@Increase buffer size to 4k and make use of interrupt endpoint
to increase responsiveness.

From Yojiro UO <yuo@@iijlab.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.22 2008/05/05 12:19:22 jsg Exp $	*/
d78 1
d81 1
a103 1
	{ USB_VENDOR_HUAWEI,	USB_PRODUCT_HUAWEI_E220 },
@


1.22
log
@Make umsm only claim a single interface so it doesn't match
on umass interfaces, and add Huawei E220.

From rivo nurges <rix@@estpak.ee>.

And add another device while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.21 2008/04/25 04:21:15 jsg Exp $	*/
d24 1
d35 12
a46 1
#define UMSMBUFSZ	2048
d54 9
d66 1
d70 2
a71 3
	NULL,
	NULL,
	NULL,
a104 4
int umsm_match(struct device *, void *, void *); 
void umsm_attach(struct device *, struct device *, void *); 
int umsm_detach(struct device *, int); 
int umsm_activate(struct device *, enum devact); 
d166 6
d236 96
@


1.21
log
@Another HSDPA MSM.
From/tested by giovanni <qgiovanni@@gmail.com>.
No man page addition as it is unclear who makes it.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.20 2008/02/19 10:57:48 jsg Exp $	*/
a34 2
#define UMSM_CONFIG_NO	0
#define UMSM_IFACE_NO	0
d67 1
d81 1
d105 4
d110 6
a115 1
	if (uaa->iface != NULL)
d119 1
a119 1
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
a129 1
	usbd_status error;
d134 1
a134 17

	if (usbd_set_config_index(sc->sc_udev, UMSM_CONFIG_NO, 1) != 0) {
		printf("%s: could not set configuration no\n",
		    sc->sc_dev.dv_xname);
		sc->sc_dying = 1;
		return;
	}

	/* get the first interface handle */
	error = usbd_device2interface_handle(sc->sc_udev, UMSM_IFACE_NO,
	    &sc->sc_iface);
	if (error != 0) {
		printf("%s: could not get interface handle\n",
		    sc->sc_dev.dv_xname);
		sc->sc_dying = 1;
		return;
	}
@


1.20
log
@Match on AnyDATA ADU-500A.
Tested by Sergey Prysiazhnyi <apelsin@@atmnis.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.19 2007/12/31 19:33:49 deraadt Exp $	*/
d70 1
@


1.19
log
@new product
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.18 2007/12/20 00:18:34 fkr Exp $	*/
d59 1
@


1.18
log
@attach another variant of the MC8755, this one is found in x61s laptops from lenovo.

tested by oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.17 2007/10/11 18:33:15 deraadt Exp $	*/
d61 1
@


1.17
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.16 2007/06/19 23:59:27 jcs Exp $	*/
d76 1
@


1.16
log
@attach to the novatel ES620 found in the oqo model 2 w/sprint card
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.15 2007/06/14 10:11:16 mbalmer Exp $	*/
a117 1
	char *devinfop;
a121 3
	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.15
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.14 2007/06/13 06:25:03 mbalmer Exp $	*/
d66 1
@


1.14
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.13 2007/06/12 16:26:37 mbalmer Exp $	*/
d79 16
a94 1
USB_DECLARE_DRIVER(umsm);
@


1.13
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.12 2007/06/10 14:49:01 mbalmer Exp $	*/
d39 5
a43 5
	struct device		sc_dev;
	usbd_device_handle	sc_udev;
	usbd_interface_handle	sc_iface;
	struct device *		sc_subdev;
	u_char			sc_dying;
@


1.12
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.11 2007/06/10 10:53:48 mbalmer Exp $	*/
d42 1
a42 1
	device_ptr_t		sc_subdev;
d189 1
a189 1
umsm_activate(device_ptr_t self, enum devact act)
@


1.11
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.10 2007/06/06 19:25:49 mk Exp $	*/
d108 1
a108 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d113 1
a113 1
		    USBDEVNAME(sc->sc_dev));
d123 1
a123 1
		    USBDEVNAME(sc->sc_dev));
d135 1
a135 1
			    USBDEVNAME(sc->sc_dev), i);
d148 1
a148 1
		printf("%s: missing endpoint\n", USBDEVNAME(sc->sc_dev));
@


1.10
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.9 2007/05/27 04:00:25 jsg Exp $	*/
d165 1
a165 1
	    USBDEV(sc->sc_dev));
d183 1
a183 1
			   USBDEV(sc->sc_dev));
@


1.9
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.8 2007/05/13 12:17:30 fkr Exp $	*/
d39 1
a39 1
	USBBASEDEVICE		sc_dev;
@


1.8
log
@sync comment with reality
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.7 2007/05/03 09:45:03 jsg Exp $	*/
d81 2
a82 1
USB_MATCH(umsm)
d84 1
a84 1
	USB_MATCH_START(umsm, uaa);
d93 2
a94 1
USB_ATTACH(umsm)
d96 2
a97 1
	USB_ATTACH_START(umsm, sc, uaa);
d108 1
a108 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d115 1
a115 1
		USB_ATTACH_ERROR_RETURN;
d125 1
a125 1
		USB_ATTACH_ERROR_RETURN;
d137 1
a137 1
			USB_ATTACH_ERROR_RETURN;
d150 1
a150 1
		USB_ATTACH_ERROR_RETURN;
a167 2

	USB_ATTACH_SUCCESS_RETURN;
d170 2
a171 1
USB_DETACH(umsm)
d173 1
a173 1
	USB_DETACH_START(umsm, sc);
@


1.7
log
@Support ONDA Communication H600.
Tested by Massimo Lusetti <massimo@@cedoc.mo.it>
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.6 2007/01/30 01:22:53 jsg Exp $	*/
d19 1
a19 1
/* Driver for Qualcomm MSM EVDO devices */
@


1.6
log
@Add some umsm devices found in Linux driver.
"looks good" fkr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.5 2007/01/13 19:54:21 stevesk Exp $	*/
d66 1
@


1.5
log
@attach to Sierra Wireless Aircard 875; ok fkr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.4 2006/12/27 19:25:23 fkr Exp $	*/
d59 1
d61 1
d63 4
d68 1
d70 2
d73 3
@


1.4
log
@make the Sierra Wireless MC8755 attach to umsm(4). this is a MiniPCI
adapter that hosts a usb controller. from janek@@openbug.org.
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.3 2006/07/17 14:26:51 jsg Exp $	*/
d62 1
@


1.3
log
@PC5740 is umodem not umsm.  Should fix PR 5181.
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.2 2006/06/23 06:27:12 miod Exp $	*/
d62 1
@


1.2
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umsm.c,v 1.1 2006/03/24 10:31:22 jsg Exp $	*/
a57 1
	{ USB_VENDOR_AUDIOVOX,	USB_PRODUCT_AUDIOVOX_PC5740 },
@


1.1
log
@Driver for the serial interface to Qualcomm MSM EVDO modems.
Tested with Verizon Wireless by jolan@@
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d181 1
a181 1
		return (EOPNOTSUPP);
@

