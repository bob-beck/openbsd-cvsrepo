head	1.35;
access;
symbols
	OPENBSD_6_2:1.35.0.2
	OPENBSD_6_2_BASE:1.35
	OPENBSD_6_1:1.35.0.4
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.34.0.6
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.33.0.12
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.4
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.8
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.6
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.30.0.8
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.6
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.4
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14;
locks; strict;
comment	@ * @;


1.35
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.34;
commitid	xlY19nmD0cBL53l1;

1.34
date	2015.08.31.07.32.15;	author mpi;	state Exp;
branches;
next	1.33;
commitid	OC3m0oX6E148IQZ8;

1.33
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.32;

1.32
date	2013.04.12.12.58.39;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.27.03.03.50;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.07.08.59.32;	author mk;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.02.15.59.35;	author grange;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.11.01.05.43;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.08.21.14.12;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2006.09.30.15.53.49;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2006.09.30.11.24.58;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2006.09.30.10.54.55;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.30.10.42.30;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.30.10.35.42;	author grange;	state Exp;
branches;
next	1.8;

1.8
date	2006.09.30.10.26.17;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.29.19.41.22;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.27.16.29.56;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.27.15.32.37;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.27.15.02.45;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.27.14.40.55;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.27.13.02.47;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.27.08.54.44;	author grange;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@/*	$OpenBSD: uow.c,v 1.34 2015/08/31 07:32:15 mpi Exp $	*/

/*
 * Copyright (c) 2006 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Maxim/Dallas DS2490 USB 1-Wire adapter driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>

#include <dev/onewire/onewirereg.h>
#include <dev/onewire/onewirevar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#include <dev/usb/uowreg.h>

#define UOW_TIMEOUT	1000	/* ms */

struct uow_softc {
	struct device		 sc_dev;

	struct onewire_bus	 sc_ow_bus;
	struct device		*sc_ow_dev;

	struct usbd_device	*sc_udev;
	struct usbd_interface	*sc_iface;
	struct usbd_pipe	*sc_ph_ibulk;
	struct usbd_pipe	*sc_ph_obulk;
	struct usbd_pipe	*sc_ph_intr;
	u_int8_t		 sc_regs[DS2490_NREGS];
	struct usbd_xfer	*sc_xfer_in;
	struct usbd_xfer	*sc_xfer_out;
	u_int8_t		 sc_fifo[DS2490_DATAFIFOSIZE];
};

int uow_match(struct device *, void *, void *); 
void uow_attach(struct device *, struct device *, void *); 
int uow_detach(struct device *, int); 
int uow_activate(struct device *, int); 

struct cfdriver uow_cd = { 
	NULL, "uow", DV_DULL 
}; 

const struct cfattach uow_ca = { 
	sizeof(struct uow_softc), 
	uow_match, 
	uow_attach, 
	uow_detach, 
	uow_activate, 
};

/* List of supported devices */
static const struct usb_devno uow_devs[] = {
	{ USB_VENDOR_DALLAS,		USB_PRODUCT_DALLAS_USB_FOB_IBUTTON }
};

int	uow_ow_reset(void *);
int	uow_ow_bit(void *, int);
int	uow_ow_read_byte(void *);
void	uow_ow_write_byte(void *, int);
void	uow_ow_read_block(void *, void *, int);
void	uow_ow_write_block(void *, const void *, int);
void	uow_ow_matchrom(void *, u_int64_t);
int	uow_ow_search(void *, u_int64_t *, int, u_int64_t);

int	uow_cmd(struct uow_softc *, int, int, int);
#define uow_ctlcmd(s, c, p)	uow_cmd((s), DS2490_CONTROL_CMD, (c), (p))
#define uow_commcmd(s, c, p)	uow_cmd((s), DS2490_COMM_CMD, (c), (p))
#define uow_modecmd(s, c, p)	uow_cmd((s), DS2490_MODE_CMD, (c), (p))

void	uow_intr(struct usbd_xfer *, void *, usbd_status);
int	uow_read(struct uow_softc *, void *, int);
int	uow_write(struct uow_softc *, const void *, int);
int	uow_reset(struct uow_softc *);

int
uow_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != DS2490_USB_CONFIG)
		return (UMATCH_NONE);

	return ((usb_lookup(uow_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
uow_attach(struct device *parent, struct device *self, void *aux)
{
	struct uow_softc *sc = (struct uow_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	int ep_ibulk = -1, ep_obulk = -1, ep_intr = -1;
	struct onewirebus_attach_args oba;
	usbd_status error;
	int i;

	sc->sc_udev = uaa->device;

	/* Get interface handle */
	if ((error = usbd_device2interface_handle(sc->sc_udev,
	    DS2490_USB_IFACE, &sc->sc_iface)) != 0) {
		printf("%s: failed to get iface %d: %s\n",
		    sc->sc_dev.dv_xname, DS2490_USB_IFACE,
		    usbd_errstr(error));
		return;
	}

	/* Find endpoints */
	id = usbd_get_interface_descriptor(sc->sc_iface);
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: failed to get endpoint %d descriptor\n",
			    sc->sc_dev.dv_xname, i);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			ep_ibulk = ed->bEndpointAddress;
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			ep_obulk = ed->bEndpointAddress;
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT)
			ep_intr = ed->bEndpointAddress;
	}
	if (ep_ibulk == -1 || ep_obulk == -1 || ep_intr == -1) {
		printf("%s: missing endpoint: ibulk %d, obulk %d, intr %d\n",
		   sc->sc_dev.dv_xname, ep_ibulk, ep_obulk, ep_intr);
		return;
	}

	/* Open pipes */
	if ((error = usbd_open_pipe(sc->sc_iface, ep_ibulk, USBD_EXCLUSIVE_USE,
	    &sc->sc_ph_ibulk)) != 0) {
		printf("%s: failed to open bulk-in pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		return;
	}
	if ((error = usbd_open_pipe(sc->sc_iface, ep_obulk, USBD_EXCLUSIVE_USE,
	    &sc->sc_ph_obulk)) != 0) {
		printf("%s: failed to open bulk-out pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}
	if ((error = usbd_open_pipe_intr(sc->sc_iface, ep_intr,
	    USBD_SHORT_XFER_OK, &sc->sc_ph_intr, sc,
	    sc->sc_regs, sizeof(sc->sc_regs), uow_intr,
	    USBD_DEFAULT_INTERVAL)) != 0) {
		printf("%s: failed to open intr pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	/* Allocate xfers for bulk transfers */
	if ((sc->sc_xfer_in = usbd_alloc_xfer(sc->sc_udev)) == NULL) {
		printf("%s: failed to alloc bulk-in xfer\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	if ((sc->sc_xfer_out = usbd_alloc_xfer(sc->sc_udev)) == NULL) {
		printf("%s: failed to alloc bulk-out xfer\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	memset(sc->sc_fifo, 0xff, sizeof(sc->sc_fifo));

	/* Reset device */
	uow_reset(sc);

	/* Attach 1-Wire bus */
	sc->sc_ow_bus.bus_cookie = sc;
	sc->sc_ow_bus.bus_reset = uow_ow_reset;
	sc->sc_ow_bus.bus_bit = uow_ow_bit;
	sc->sc_ow_bus.bus_read_byte = uow_ow_read_byte;
	sc->sc_ow_bus.bus_write_byte = uow_ow_write_byte;
	sc->sc_ow_bus.bus_read_block = uow_ow_read_block;
	sc->sc_ow_bus.bus_write_block = uow_ow_write_block;
	sc->sc_ow_bus.bus_matchrom = uow_ow_matchrom;
#if 0
	sc->sc_ow_bus.bus_search = uow_ow_search;
#endif

	bzero(&oba, sizeof(oba));
	oba.oba_bus = &sc->sc_ow_bus;
	sc->sc_ow_dev = config_found(self, &oba, onewirebus_print);

	return;

fail:
	if (sc->sc_ph_ibulk != NULL) {
		usbd_close_pipe(sc->sc_ph_ibulk);
		sc->sc_ph_ibulk = NULL;
	}
	if (sc->sc_ph_obulk != NULL) {
		usbd_close_pipe(sc->sc_ph_obulk);
		sc->sc_ph_obulk = NULL;
	}
	if (sc->sc_ph_intr != NULL) {
		usbd_close_pipe(sc->sc_ph_intr);
		sc->sc_ph_intr = NULL;
	}
	if (sc->sc_xfer_in != NULL) {
		usbd_free_xfer(sc->sc_xfer_in);
		sc->sc_xfer_in = NULL;
	}
	if (sc->sc_xfer_out != NULL) {
		usbd_free_xfer(sc->sc_xfer_out);
		sc->sc_xfer_out = NULL;
	}
}

int
uow_detach(struct device *self, int flags)
{
	struct uow_softc *sc = (struct uow_softc *)self;
	int rv = 0, s;

	s = splusb();

	if (sc->sc_ph_ibulk != NULL) {
		usbd_abort_pipe(sc->sc_ph_ibulk);
		usbd_close_pipe(sc->sc_ph_ibulk);
	}
	if (sc->sc_ph_obulk != NULL) {
		usbd_abort_pipe(sc->sc_ph_obulk);
		usbd_close_pipe(sc->sc_ph_obulk);
	}
	if (sc->sc_ph_intr != NULL) {
		usbd_abort_pipe(sc->sc_ph_intr);
		usbd_close_pipe(sc->sc_ph_intr);
	}

	if (sc->sc_xfer_in != NULL)
		usbd_free_xfer(sc->sc_xfer_in);
	if (sc->sc_xfer_out != NULL)
		usbd_free_xfer(sc->sc_xfer_out);

	if (sc->sc_ow_dev != NULL)
		rv = config_detach(sc->sc_ow_dev, flags);

	splx(s);

	return (rv);
}

int
uow_activate(struct device *self, int act)
{
	struct uow_softc *sc = (struct uow_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (sc->sc_ow_dev != NULL)
			rv = config_deactivate(sc->sc_ow_dev);
		usbd_deactivate(sc->sc_udev);
		break;
	}

	return (rv);
}

int
uow_ow_reset(void *arg)
{
	struct uow_softc *sc = arg;

	if (uow_commcmd(sc, DS2490_COMM_1WIRE_RESET | DS2490_BIT_IM, 0) != 0)
		return (1);

	/* XXX: check presence pulse */
	return (0);
}

int
uow_ow_bit(void *arg, int value)
{
	struct uow_softc *sc = arg;
	u_int8_t data;

	if (uow_commcmd(sc, DS2490_COMM_BIT_IO | DS2490_BIT_IM |
	    (value ? DS2490_BIT_D : 0), 0) != 0)
		return (1);
	if (uow_read(sc, &data, 1) != 1)
		return (1);

	return (data);
}

int
uow_ow_read_byte(void *arg)
{
	struct uow_softc *sc = arg;
	u_int8_t data;

	if (uow_commcmd(sc, DS2490_COMM_BYTE_IO | DS2490_BIT_IM, 0xff) != 0)
		return (-1);
	if (uow_read(sc, &data, 1) != 1)
		return (-1);

	return (data);
}

void
uow_ow_write_byte(void *arg, int value)
{
	struct uow_softc *sc = arg;
	u_int8_t data;

	if (uow_commcmd(sc, DS2490_COMM_BYTE_IO | DS2490_BIT_IM, value) != 0)
		return;
	uow_read(sc, &data, sizeof(data));
}

void
uow_ow_read_block(void *arg, void *buf, int len)
{
	struct uow_softc *sc = arg;

	if (uow_write(sc, sc->sc_fifo, len) != 0)
		return;
	if (uow_commcmd(sc, DS2490_COMM_BLOCK_IO | DS2490_BIT_IM, len) != 0)
		return;
	uow_read(sc, buf, len);
}

void
uow_ow_write_block(void *arg, const void *buf, int len)
{
	struct uow_softc *sc = arg;

	if (uow_write(sc, buf, len) != 0)
		return;
	if (uow_commcmd(sc, DS2490_COMM_BLOCK_IO | DS2490_BIT_IM, len) != 0)
		return;
}

void
uow_ow_matchrom(void *arg, u_int64_t rom)
{
	struct uow_softc *sc = arg;
	u_int8_t data[8];
	int i;

	for (i = 0; i < 8; i++)
		data[i] = (rom >> (i * 8)) & 0xff;

	if (uow_write(sc, data, 8) != 0)
		return;
	if (uow_commcmd(sc, DS2490_COMM_MATCH_ACCESS | DS2490_BIT_IM,
	    ONEWIRE_CMD_MATCH_ROM) != 0)
		return;
}

int
uow_ow_search(void *arg, u_int64_t *buf, int size, u_int64_t startrom)
{
	struct uow_softc *sc = arg;
	u_int8_t data[8];
	int i, rv;

	for (i = 0; i < 8; i++)
		data[i] = (startrom >> (i * 8)) & 0xff;

	if (uow_write(sc, data, 8) != 0)
		return (-1);
	if (uow_commcmd(sc, DS2490_COMM_SEARCH_ACCESS | DS2490_BIT_IM |
	    DS2490_BIT_SM | DS2490_BIT_RST | DS2490_BIT_F, size << 8 |
	    ONEWIRE_CMD_SEARCH_ROM) != 0)
		return (-1);

	if ((rv = uow_read(sc, buf, size * 8)) == -1)
		return (-1);

	return (rv / 8);
}

int
uow_cmd(struct uow_softc *sc, int type, int cmd, int param)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = type;
	USETW(req.wValue, cmd);
	USETW(req.wIndex, param);
	USETW(req.wLength, 0);
	if ((error = usbd_do_request(sc->sc_udev, &req, NULL)) != 0) {
		printf("%s: cmd failed, type 0x%02x, cmd 0x%04x, "
		    "param 0x%04x: %s\n", sc->sc_dev.dv_xname, type, cmd,
		    param, usbd_errstr(error));
		if (cmd != DS2490_CTL_RESET_DEVICE)
			uow_reset(sc);
		return (1);
	}

again:
	if (tsleep(sc->sc_regs, PRIBIO, "uowcmd",
	    (UOW_TIMEOUT * hz) / 1000) != 0) {
		printf("%s: cmd timeout, type 0x%02x, cmd 0x%04x, "
		    "param 0x%04x\n", sc->sc_dev.dv_xname, type, cmd,
		    param);
		return (1);
	}
	if ((sc->sc_regs[DS2490_ST_STFL] & DS2490_ST_STFL_IDLE) == 0)
		goto again;

	return (0);
}

void
uow_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct uow_softc *sc = priv;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_ph_intr);
		return;
	}

	wakeup(sc->sc_regs);
}

int
uow_read(struct uow_softc *sc, void *buf, int len)
{
	usbd_status error;
	int count;

	/* XXX: implement FIFO status monitoring */
	if (len > DS2490_DATAFIFOSIZE) {
		printf("%s: read %d bytes, xfer too big\n",
		    sc->sc_dev.dv_xname, len);
		return (-1);
	}

	usbd_setup_xfer(sc->sc_xfer_in, sc->sc_ph_ibulk, sc, buf, len,
	    USBD_SHORT_XFER_OK | USBD_SYNCHRONOUS, UOW_TIMEOUT, NULL);
	error = usbd_transfer(sc->sc_xfer_in);
	if (error != 0) {
		printf("%s: read failed, len %d: %s\n",
		    sc->sc_dev.dv_xname, len, usbd_errstr(error));
		uow_reset(sc);
		return (-1);
	}

	usbd_get_xfer_status(sc->sc_xfer_in, NULL, NULL, &count, &error);
	return (count);
}

int
uow_write(struct uow_softc *sc, const void *buf, int len)
{
	usbd_status error;

	/* XXX: implement FIFO status monitoring */
	if (len > DS2490_DATAFIFOSIZE) {
		printf("%s: write %d bytes, xfer too big\n",
		    sc->sc_dev.dv_xname, len);
		return (1);
	}

	usbd_setup_xfer(sc->sc_xfer_out, sc->sc_ph_obulk, sc, (void *)buf,
	    len, USBD_SYNCHRONOUS, UOW_TIMEOUT, NULL);
	error = usbd_transfer(sc->sc_xfer_out);
	if (error != 0) {
		printf("%s: write failed, len %d: %s\n",
		    sc->sc_dev.dv_xname, len, usbd_errstr(error));
		uow_reset(sc);
		return (1);
	}

	return (0);
}

int
uow_reset(struct uow_softc *sc)
{
	return (uow_ctlcmd(sc, DS2490_CTL_RESET_DEVICE, 0));
}
@


1.34
log
@Use one xfer per pipe instead of doing an alloc/free dance for every
usbd_transfer(9).

This fixes a use-after-free.

Bug found by and diff from John L. Scarfone <john AT scarfone DOT net>
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.33 2013/04/15 09:23:02 mglocker Exp $	*/
d103 1
a103 1
	if (uaa->iface != NULL)
a122 9

	/* Set USB configuration */
	if ((error = usbd_set_config_no(sc->sc_udev,
	    DS2490_USB_CONFIG, 0)) != 0) {
		printf("%s: failed to set config %d: %s\n",
		    sc->sc_dev.dv_xname, DS2490_USB_CONFIG,
		    usbd_errstr(error));
		return;
	}
@


1.33
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.32 2013/04/12 12:58:39 mpi Exp $	*/
d52 2
a53 1
	struct usbd_xfer	*sc_xfer;
d190 8
a197 4
#if 0
	/* Allocate xfer for bulk transfers */
	if ((sc->sc_xfer = usbd_alloc_xfer(sc->sc_udev)) == NULL) {
		printf("%s: failed to alloc bulk xfer\n",
a200 1
#endif
d227 1
a227 1
	if (sc->sc_ph_ibulk != NULL)
d229 3
a231 1
	if (sc->sc_ph_obulk != NULL)
d233 3
a235 1
	if (sc->sc_ph_intr != NULL)
d237 10
a246 2
	if (sc->sc_xfer != NULL)
		usbd_free_xfer(sc->sc_xfer);
d270 4
a273 2
	if (sc->sc_xfer != NULL)
		usbd_free_xfer(sc->sc_xfer);
d478 1
a478 5
	if ((sc->sc_xfer = usbd_alloc_xfer(sc->sc_udev)) == NULL) {
		printf("%s: failed to alloc xfer\n", sc->sc_dev.dv_xname);
		return (-1);
	}
	usbd_setup_xfer(sc->sc_xfer, sc->sc_ph_ibulk, sc, buf, len,
d480 1
a480 2
	error = usbd_transfer(sc->sc_xfer);
	usbd_free_xfer(sc->sc_xfer);
d488 1
a488 1
	usbd_get_xfer_status(sc->sc_xfer, NULL, NULL, &count, &error);
d504 3
a506 8
	if ((sc->sc_xfer = usbd_alloc_xfer(sc->sc_udev)) == NULL) {
		printf("%s: failed to alloc xfer\n", sc->sc_dev.dv_xname);
		return (-1);
	}
	usbd_setup_xfer(sc->sc_xfer, sc->sc_ph_obulk, sc, (void *)buf, len,
	    USBD_SYNCHRONOUS, UOW_TIMEOUT, NULL);
	error = usbd_transfer(sc->sc_xfer);
	usbd_free_xfer(sc->sc_xfer);
@


1.32
log
@Instead of using a wrapper around usbd_transfer() when submitting a
transfer synchronously just pass the USBD_SYNCHRONOUS flag like any
other flags when creating a transfer.

ok sthen@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.31 2013/03/28 03:58:03 tedu Exp $	*/
d46 5
a50 5
	usbd_device_handle	 sc_udev;
	usbd_interface_handle	 sc_iface;
	usbd_pipe_handle	 sc_ph_ibulk;
	usbd_pipe_handle	 sc_ph_obulk;
	usbd_pipe_handle	 sc_ph_intr;
d52 1
a52 1
	usbd_xfer_handle	 sc_xfer;
d92 1
a92 1
void	uow_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d432 1
a432 1
uow_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.31
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.30 2011/07/03 15:47:17 matthew Exp $	*/
d465 2
a466 2
	    USBD_SHORT_XFER_OK, UOW_TIMEOUT, NULL);
	error = usbd_sync_transfer(sc->sc_xfer);
d495 3
a497 3
	usbd_setup_xfer(sc->sc_xfer, sc->sc_ph_obulk, sc, (void *)buf, len, 0,
	    UOW_TIMEOUT, NULL);
	error = usbd_sync_transfer(sc->sc_xfer);
@


1.30
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.29 2011/01/25 20:03:36 jakemsr Exp $	*/
a26 1
#include <sys/proc.h>
@


1.29
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.28 2010/12/27 03:03:50 jakemsr Exp $	*/
a272 2
	case DVACT_ACTIVATE:
		break;
@


1.28
log
@* add cfattach activate functions and call usbd_deactivate() in the
  DVACT_DEACTIVATE case for drivers that don't have activate finctions
* fill out cfattach activate functions and call usbd_deactivate() in
  the DVACT_DEACTIVATE case for drivers that don't have a dying flag

"ok with the intent" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.27 2010/03/07 08:59:32 mk Exp $	*/
a261 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.27
log
@Remove unused DPRINTF() macro.

ok grange
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.26 2009/10/13 19:33:19 pirofti Exp $	*/
d281 1
@


1.26
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.25 2007/10/11 18:33:15 deraadt Exp $	*/
a37 6

#ifdef UOW_DEBUG
#define DPRINTF(x) printf x
#else
#define DPRINTF(x)
#endif
@


1.25
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.24 2007/09/02 15:59:35 grange Exp $	*/
d66 1
a66 1
int uow_activate(struct device *, enum devact); 
d276 1
a276 1
uow_activate(struct device *self, enum devact act)
@


1.24
log
@Disable ROM search acceleration for now, it has some issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.23 2007/06/14 10:11:16 mbalmer Exp $	*/
a122 1
	char *devinfop;
a128 6

	/* Display device info string */
	printf("\n");
	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.23
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.22 2007/06/13 06:25:03 mbalmer Exp $	*/
d226 1
d228 1
@


1.22
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.21 2007/06/12 16:26:37 mbalmer Exp $	*/
d63 16
a78 1
USB_DECLARE_DRIVER(uow);
@


1.21
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.20 2007/06/11 01:05:43 jsg Exp $	*/
d48 1
a48 1
	struct device		sc_dev;
d50 2
a51 2
	struct onewire_bus	sc_ow_bus;
	struct device *		sc_ow_dev;
d53 8
a60 8
	usbd_device_handle	sc_udev;
	usbd_interface_handle	sc_iface;
	usbd_pipe_handle	sc_ph_ibulk;
	usbd_pipe_handle	sc_ph_obulk;
	usbd_pipe_handle	sc_ph_intr;
	u_int8_t		sc_regs[DS2490_NREGS];
	usbd_xfer_handle	sc_xfer;
	u_int8_t		sc_fifo[DS2490_DATAFIFOSIZE];
@


1.20
log
@usbd_devinfo_alloc() uses M_WAITOK so don't check return value.
From Karl Sjödahl <dunceor@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.19 2007/06/10 14:49:01 mbalmer Exp $	*/
d266 1
a266 1
uow_activate(device_ptr_t self, enum devact act)
@


1.19
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.18 2007/06/10 10:53:48 mbalmer Exp $	*/
d118 3
a120 4
	if ((devinfop = usbd_devinfo_alloc(uaa->device, 0)) != NULL) {
		printf("%s: %s\n", sc->sc_dev.dv_xname, devinfop);
		usbd_devinfo_free(devinfop);
	}
@


1.18
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.17 2007/06/06 19:25:49 mk Exp $	*/
d119 1
a119 1
		printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d127 1
a127 1
		    USBDEVNAME(sc->sc_dev), DS2490_USB_CONFIG,
d136 1
a136 1
		    USBDEVNAME(sc->sc_dev), DS2490_USB_IFACE,
d147 1
a147 1
			    USBDEVNAME(sc->sc_dev), i);
d163 1
a163 1
		   USBDEVNAME(sc->sc_dev), ep_ibulk, ep_obulk, ep_intr);
d171 1
a171 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d177 1
a177 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d185 1
a185 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d193 1
a193 1
		    USBDEVNAME(sc->sc_dev));
d412 1
a412 1
		    "param 0x%04x: %s\n", USBDEVNAME(sc->sc_dev), type, cmd,
d423 1
a423 1
		    "param 0x%04x\n", USBDEVNAME(sc->sc_dev), type, cmd,
d458 1
a458 1
		    USBDEVNAME(sc->sc_dev), len);
d463 1
a463 1
		printf("%s: failed to alloc xfer\n", USBDEVNAME(sc->sc_dev));
d472 1
a472 1
		    USBDEVNAME(sc->sc_dev), len, usbd_errstr(error));
d489 1
a489 1
		    USBDEVNAME(sc->sc_dev), len);
d494 1
a494 1
		printf("%s: failed to alloc xfer\n", USBDEVNAME(sc->sc_dev));
d503 1
a503 1
		    USBDEVNAME(sc->sc_dev), len, usbd_errstr(error));
@


1.17
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.16 2007/06/05 08:43:56 mbalmer Exp $	*/
d261 1
a261 1
	    USBDEV(sc->sc_dev));
@


1.16
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.15 2007/05/27 04:00:25 jsg Exp $	*/
d48 1
a48 1
	USBBASEDEVICE		sc_dev;
@


1.15
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.14 2006/10/08 21:14:12 grange Exp $	*/
d70 8
a77 8
Static int	uow_ow_reset(void *);
Static int	uow_ow_bit(void *, int);
Static int	uow_ow_read_byte(void *);
Static void	uow_ow_write_byte(void *, int);
Static void	uow_ow_read_block(void *, void *, int);
Static void	uow_ow_write_block(void *, const void *, int);
Static void	uow_ow_matchrom(void *, u_int64_t);
Static int	uow_ow_search(void *, u_int64_t *, int, u_int64_t);
d79 1
a79 1
Static int	uow_cmd(struct uow_softc *, int, int, int);
d84 4
a87 4
Static void	uow_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static int	uow_read(struct uow_softc *, void *, int);
Static int	uow_write(struct uow_softc *, const void *, int);
Static int	uow_reset(struct uow_softc *);
d284 1
a284 1
Static int
d296 1
a296 1
Static int
d311 1
a311 1
Static int
d325 1
a325 1
Static void
d336 1
a336 1
Static void
d348 1
a348 1
Static void
d359 1
a359 1
Static void
d376 1
a376 1
Static int
d399 1
a399 1
Static int
d433 1
a433 1
Static void
d449 1
a449 1
Static int
d481 1
a481 1
Static int
d511 1
a511 1
Static int
@


1.14
log
@Implement bus searching.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.13 2006/09/30 15:53:49 grange Exp $	*/
d89 2
a90 1
USB_MATCH(uow)
d92 1
a92 1
	USB_MATCH_START(uow, uaa);
d101 2
a102 1
USB_ATTACH(uow)
d104 2
a105 1
	USB_ATTACH_START(uow, sc, uaa);
d117 1
a117 1
	USB_ATTACH_SETUP;
d129 1
a129 1
		USB_ATTACH_ERROR_RETURN;
d138 1
a138 1
		USB_ATTACH_ERROR_RETURN;
d148 1
a148 1
			USB_ATTACH_ERROR_RETURN;
d164 1
a164 1
		USB_ATTACH_ERROR_RETURN;
d172 1
a172 1
		USB_ATTACH_ERROR_RETURN;
d218 1
a218 1
	USB_ATTACH_SUCCESS_RETURN;
a228 1
	USB_ATTACH_ERROR_RETURN;
d231 2
a232 1
USB_DETACH(uow)
d234 1
a234 1
	USB_DETACH_START(uow, sc);
@


1.13
log
@Implement match rom command.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.12 2006/09/30 11:24:58 grange Exp $	*/
d77 1
d186 1
d193 1
d209 1
d302 1
a302 1
	if (uow_read(sc, &data, sizeof(data)) != 0)
d316 1
a316 1
	if (uow_read(sc, &data, sizeof(data)) != 0)
d360 1
a360 1
	u_int8_t buf[8];
d364 1
a364 1
		buf[i] = (rom >> (i * 8)) & 0xff;
d366 1
a366 1
	if (uow_write(sc, buf, 8) != 0)
d374 23
d416 1
a416 1
	bzero(sc->sc_regs, sizeof(sc->sc_regs));
d424 2
d450 1
d456 1
a456 1
		return (1);
d459 9
a467 3
	usbd_setup_xfer(sc->sc_xfer, sc->sc_ph_ibulk, sc, buf, len, 0,
	    UOW_TIMEOUT, NULL);
	if ((error = usbd_sync_transfer(sc->sc_xfer)) != 0) {
d471 1
a471 1
		return (1);
d474 2
a475 1
	return (0);
d490 4
d496 3
a498 1
	if ((error = usbd_sync_transfer(sc->sc_xfer)) != 0) {
@


1.12
log
@Reset device on errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.11 2006/09/30 10:54:55 grange Exp $	*/
d29 1
d76 1
d205 1
d349 17
@


1.11
log
@Pretty.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.10 2006/09/30 10:42:30 grange Exp $	*/
d364 2
d414 1
d438 1
@


1.10
log
@More useful error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.9 2006/09/30 10:35:42 grange Exp $	*/
d361 3
a363 3
		printf("%s: cmd failed, type %d, cmd %d, param %d: %s\n",
		    USBDEVNAME(sc->sc_dev), type, cmd, param,
		    usbd_errstr(error));
d370 3
a372 2
		printf("%s: cmd timeout, type %d, cmd %d, param %d\n",
		    USBDEVNAME(sc->sc_dev), type, cmd, param);
@


1.9
log
@Reset device on attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.8 2006/09/30 10:26:17 grange Exp $	*/
d361 3
a363 2
		printf("%s: failed to do request: %s\n",
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d370 2
a371 1
		printf("%s: request timeout\n", USBDEVNAME(sc->sc_dev));
d409 2
a410 2
		printf("%s: failed to read: %s\n",
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d432 2
a433 2
		printf("%s: failed to write: %s\n",
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
@


1.8
log
@Add new parameter to uow_cmd() to set command type.
Create aliases uow_ctlcmd(), uow_commcmd() and uow_modecmd()
for sending control, communication and mode commands.
No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.7 2006/09/29 19:41:22 grange Exp $	*/
d84 1
d192 3
d436 6
@


1.7
log
@Implement block read/write operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.6 2006/09/27 16:29:56 grange Exp $	*/
d76 5
a80 1
Static int	uow_cmd(struct uow_softc *, int, int);
d275 1
a275 1
	if (uow_cmd(sc, DS2490_COMM_1WIRE_RESET | DS2490_BIT_IM, 0) != 0)
d288 1
a288 1
	if (uow_cmd(sc, DS2490_COMM_BIT_IO | DS2490_BIT_IM |
d303 1
a303 1
	if (uow_cmd(sc, DS2490_COMM_BYTE_IO | DS2490_BIT_IM, 0xff) != 0)
d317 1
a317 1
	if (uow_cmd(sc, DS2490_COMM_BYTE_IO | DS2490_BIT_IM, value) != 0)
d329 1
a329 1
	if (uow_cmd(sc, DS2490_COMM_BLOCK_IO | DS2490_BIT_IM, len) != 0)
d341 1
a341 1
	if (uow_cmd(sc, DS2490_COMM_BLOCK_IO | DS2490_BIT_IM, len) != 0)
d346 1
a346 1
uow_cmd(struct uow_softc *sc, int cmd, int param)
d352 1
a352 1
	req.bRequest = DS2490_COMM_CMD;
@


1.6
log
@Implement 1-wire byte read/write.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.5 2006/09/27 15:32:37 grange Exp $	*/
d59 1
d73 2
d78 2
a79 1
Static int	uow_recv(struct uow_softc *, void *, int);
d185 2
d193 2
d287 1
a287 1
	if (uow_recv(sc, &data, sizeof(data)) != 0)
d301 1
a301 1
	if (uow_recv(sc, &data, sizeof(data)) != 0)
d315 24
a338 1
	uow_recv(sc, &data, sizeof(data));
d385 24
a408 1
uow_recv(struct uow_softc *sc, void *buf, int size)
d412 8
a419 1
	usbd_setup_xfer(sc->sc_xfer, sc->sc_ph_ibulk, sc, buf, size, 0,
d422 1
a422 1
		printf("%s: failed to recv xfer: %s\n",
@


1.5
log
@Move bulk-in transfer to the separate function.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.4 2006/09/27 15:02:45 grange Exp $	*/
d70 2
d185 2
d283 25
@


1.4
log
@Allocate xfer for bulk transfers only once on attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.3 2006/09/27 14:40:55 grange Exp $	*/
d73 1
a270 1
	usbd_status error;
d275 1
a275 7

	usbd_setup_xfer(sc->sc_xfer, sc->sc_ph_ibulk, sc, &data, sizeof(data),
	    0, UOW_TIMEOUT, NULL);
	error = usbd_sync_transfer(sc->sc_xfer);
	if (error != 0) {
		printf("%s: failed to do xfer: %s\n",
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
a276 1
	}
d322 16
@


1.3
log
@Protect detach function with splusb.
Call usbd_abort_pipe before closing pipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.2 2006/09/27 13:02:47 grange Exp $	*/
d58 1
d171 7
d196 2
d221 3
a268 1
	usbd_xfer_handle xfer;
d276 3
a278 8
	if ((xfer = usbd_alloc_xfer(sc->sc_udev)) == NULL) {
		printf("%s: failed to alloc xfer\n", USBDEVNAME(sc->sc_dev));
		return (1);
	}
	usbd_setup_xfer(xfer, sc->sc_ph_ibulk, sc, &data, sizeof(data), 0,
	    UOW_TIMEOUT, NULL);
	error = usbd_sync_transfer(xfer);
	usbd_free_xfer(xfer);
@


1.2
log
@Add missing <sys/device.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: uow.c,v 1.1 2006/09/27 08:54:44 grange Exp $	*/
d194 1
a194 1
	int rv = 0;
d196 4
a199 1
	if (sc->sc_ph_ibulk != NULL)
d201 3
a203 1
	if (sc->sc_ph_obulk != NULL)
d205 3
a207 1
	if (sc->sc_ph_intr != NULL)
d209 1
d213 2
@


1.1
log
@Add Maxim/Dallas DS2490 USB 1-Wire adapter driver.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d25 1
@

