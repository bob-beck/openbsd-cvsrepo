head	1.40;
access;
symbols
	OPENBSD_6_2:1.40.0.2
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.8
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.6
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.4
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17;
locks; strict;
comment	@ * @;


1.40
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	6s3MfY9d6ZKdL2Uz;

1.39
date	2016.09.02.09.14.59;	author mpi;	state Exp;
branches;
next	1.38;
commitid	blfE5YU3eGM81J65;

1.38
date	2016.06.05.20.15.54;	author bru;	state Exp;
branches;
next	1.37;
commitid	liGGvUBP6Bv7by7V;

1.37
date	2016.02.10.05.49.50;	author guenther;	state Exp;
branches;
next	1.36;
commitid	4VoeOO8ryUyFcWSQ;

1.36
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.35;
commitid	p4LJxGKbi0BU2cG6;

1.35
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.34;
commitid	LS2TNeCue5R9L67C;

1.34
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.33;
commitid	OBNa5kfxQ2UXoiIw;

1.33
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.07.10.33.43;	author pirofti;	state Exp;
branches;
next	1.31;

1.31
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	2011.03.03.21.48.49;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.05.20.39.31;	author matthieu;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.14.20.05.09;	author chl;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.29.16.29.42;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.18.19.44.40;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.16.03.19.15;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.06.20.28.56;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.30.18.49.29;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.11.01.05.43;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.10.10.53.49;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.06.19.25.50;	author mk;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.31.02.56.03;	author robert;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.18.18.47.30;	author robert;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.08.20.48.03;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.26.17.00.28;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.25.14.17.42;	author robert;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.10.22.37.17;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.23.14.35.19;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.16.21.40.32;	author robert;	state Exp;
branches;
next	;


desc
@@


1.40
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: uts.c,v 1.39 2016/09/02 09:14:59 mpi Exp $ */

/*
 * Copyright (c) 2007 Robert Nagy <robert@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/intr.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

#ifdef UTS_DEBUG
#define DPRINTF(x)		do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

struct tsscale {
	int	minx, maxx;
	int	miny, maxy;
	int	swapxy;
	int	resx, resy;
} def_scale = {
	67, 1931, 102, 1937, 0, 1024, 768
};

struct uts_softc {
	struct device		sc_dev;
	struct usbd_device	*sc_udev;
	struct usbd_interface	*sc_iface;
	int			sc_iface_number;
	int			sc_product;
	int			sc_vendor;

	int			sc_intr_number;
	struct usbd_pipe	*sc_intr_pipe;
	u_char			*sc_ibuf;
	int			sc_isize;
	u_int8_t		sc_pkts;

	struct device		*sc_wsmousedev;

	int	sc_enabled;
	int	sc_buttons;
	int	sc_oldx;
	int	sc_oldy;
	int	sc_rawmode;

	struct tsscale sc_tsscale;
};

struct uts_pos {
	int	down;
	int	x;
	int	y;
	int	z;	/* touch pressure */
};

const struct usb_devno uts_devs[] = {
	{ USB_VENDOR_FTDI,		USB_PRODUCT_FTDI_ITM_TOUCH },
	{ USB_VENDOR_EGALAX,		USB_PRODUCT_EGALAX_TPANEL },
	{ USB_VENDOR_EGALAX,		USB_PRODUCT_EGALAX_TPANEL2 },
	{ USB_VENDOR_GUNZE,		USB_PRODUCT_GUNZE_TOUCHPANEL }
};

void uts_intr(struct usbd_xfer *, void *, usbd_status);
void uts_get_pos(void *addr, struct uts_pos *tp);

int	uts_enable(void *);
void	uts_disable(void *);
int	uts_ioctl(void *, u_long, caddr_t, int, struct proc *);

const struct wsmouse_accessops uts_accessops = {
	uts_enable,
	uts_ioctl,
	uts_disable,
};

int uts_match(struct device *, void *, void *);
void uts_attach(struct device *, struct device *, void *);
int uts_detach(struct device *, int);
int uts_activate(struct device *, int);

struct cfdriver uts_cd = {
	NULL, "uts", DV_DULL
};

const struct cfattach uts_ca = {
	sizeof(struct uts_softc),
	uts_match,
	uts_attach,
	uts_detach,
	uts_activate,
};

int
uts_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;

	if (uaa->iface == NULL)
		return (UMATCH_NONE);

	/* Some eGalax touch screens are HID devices. ignore them */
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id != NULL && id->bInterfaceClass == UICLASS_HID)
		return (UMATCH_NONE);

	return (usb_lookup(uts_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
}

void
uts_attach(struct device *parent, struct device *self, void *aux)
{
	struct uts_softc *sc = (struct uts_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usb_config_descriptor_t *cdesc;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	struct wsmousedev_attach_args a;
	int i;

	sc->sc_udev = uaa->device;
	sc->sc_product = uaa->product;
	sc->sc_vendor = uaa->vendor;
	sc->sc_intr_number = -1;
	sc->sc_intr_pipe = NULL;
	sc->sc_enabled = sc->sc_isize = 0;

	/* Copy the default scalue values to each softc */
	bcopy(&def_scale, &sc->sc_tsscale, sizeof(sc->sc_tsscale));

	/* get the config descriptor */
	cdesc = usbd_get_config_descriptor(sc->sc_udev);
	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* get the interface */
	if (usbd_device2interface_handle(uaa->device, 0, &sc->sc_iface) != 0) {
		printf("%s: failed to get interface\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* Find the interrupt endpoint */
	id = usbd_get_interface_descriptor(sc->sc_iface);
	sc->sc_iface_number = id->bInterfaceNumber;

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
			    sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_intr_number = ed->bEndpointAddress;
			sc->sc_isize = UGETW(ed->wMaxPacketSize);
		}
	}

	if (sc->sc_intr_number== -1) {
		printf("%s: Could not find interrupt in\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	a.accessops = &uts_accessops;
	a.accesscookie = sc;

	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
}

int
uts_detach(struct device *self, int flags)
{
	struct uts_softc *sc = (struct uts_softc *)self;
	int rv = 0;

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		usbd_close_pipe(sc->sc_intr_pipe);
		sc->sc_intr_pipe = NULL;
	}

	if (sc->sc_wsmousedev != NULL) {
		rv = config_detach(sc->sc_wsmousedev, flags);
		sc->sc_wsmousedev = NULL;
	}

	return (rv);
}

int
uts_activate(struct device *self, int act)
{
	struct uts_softc *sc = (struct uts_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (sc->sc_wsmousedev != NULL)
			rv = config_deactivate(sc->sc_wsmousedev);
		usbd_deactivate(sc->sc_udev);
		break;
	}

	return (rv);
}

int
uts_enable(void *v)
{
	struct uts_softc *sc = v;
	int err;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	if (sc->sc_enabled)
		return (EBUSY);

	if (sc->sc_isize == 0)
		return (0);
	sc->sc_ibuf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);
	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_intr_number,
	    USBD_SHORT_XFER_OK, &sc->sc_intr_pipe, sc, sc->sc_ibuf,
	    sc->sc_isize, uts_intr, USBD_DEFAULT_INTERVAL);
	if (err) {
		free(sc->sc_ibuf, M_USBDEV, sc->sc_isize);
		sc->sc_intr_pipe = NULL;
		return (EIO);
	}

	sc->sc_enabled = 1;
	sc->sc_buttons = 0;

	return (0);
}

void
uts_disable(void *v)
{
	struct uts_softc *sc = v;

	if (!sc->sc_enabled) {
		printf("uts_disable: already disabled!\n");
		return;
	}

	/* Disable interrupts. */
	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		usbd_close_pipe(sc->sc_intr_pipe);
		sc->sc_intr_pipe = NULL;
	}

	if (sc->sc_ibuf != NULL) {
		free(sc->sc_ibuf, M_USBDEV, sc->sc_isize);
		sc->sc_ibuf = NULL;
	}

	sc->sc_enabled = 0;
}

int
uts_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *l)
{
	int error = 0;
	struct uts_softc *sc = v;
	struct wsmouse_calibcoords *wsmc = (struct wsmouse_calibcoords *)data;

	DPRINTF(("uts_ioctl(%d, '%c', %d)\n",
	    IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd & 0xff));

	switch (cmd) {
	case WSMOUSEIO_SCALIBCOORDS:
		if (!(wsmc->minx >= -32768 && wsmc->maxx >= 0 &&
		    wsmc->miny >= -32768 && wsmc->maxy >= 0 &&
		    wsmc->resx >= 0 && wsmc->resy >= 0 &&
		    wsmc->minx < 32768 && wsmc->maxx < 32768 &&
		    wsmc->miny < 32768 && wsmc->maxy < 32768 &&
		    (wsmc->maxx - wsmc->minx) != 0 &&
		    (wsmc->maxy - wsmc->miny) != 0 &&
		    wsmc->resx < 32768 && wsmc->resy < 32768 &&
		    wsmc->swapxy >= 0 && wsmc->swapxy <= 1 &&
		    wsmc->samplelen >= 0 && wsmc->samplelen <= 1))
			return (EINVAL);

		sc->sc_tsscale.minx = wsmc->minx;
		sc->sc_tsscale.maxx = wsmc->maxx;
		sc->sc_tsscale.miny = wsmc->miny;
		sc->sc_tsscale.maxy = wsmc->maxy;
		sc->sc_tsscale.swapxy = wsmc->swapxy;
		sc->sc_tsscale.resx = wsmc->resx;
		sc->sc_tsscale.resy = wsmc->resy;
		sc->sc_rawmode = wsmc->samplelen;
		break;
	case WSMOUSEIO_GCALIBCOORDS:
		wsmc->minx = sc->sc_tsscale.minx;
		wsmc->maxx = sc->sc_tsscale.maxx;
		wsmc->miny = sc->sc_tsscale.miny;
		wsmc->maxy = sc->sc_tsscale.maxy;
		wsmc->swapxy = sc->sc_tsscale.swapxy;
		wsmc->resx = sc->sc_tsscale.resx;
		wsmc->resy = sc->sc_tsscale.resy;
		wsmc->samplelen = sc->sc_rawmode;
		break;
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_TPANEL;
		break;
	default:
		error = ENOTTY;
		break;
	}

	return (error);
}

void
uts_get_pos(void *addr, struct uts_pos *tp)
{
	struct uts_softc *sc = addr;
	u_char *p = sc->sc_ibuf;
	int down, x, y, z;

	switch (sc->sc_product) {
	case USB_PRODUCT_FTDI_ITM_TOUCH:
		down = (~p[7] & 0x20);
		x = ((p[0] & 0x1f) << 7) | (p[3] & 0x7f);
		/* Invert the Y coordinate */
		y = 0x0fff - abs(((p[1] & 0x1f) << 7) | (p[4] & 0x7f));
		z = ((p[2] & 0x1) << 7) | (p[5] & 0x7f);
		sc->sc_pkts = 0x8;
		break;
	case USB_PRODUCT_EGALAX_TPANEL:
	case USB_PRODUCT_EGALAX_TPANEL2:
		/*
		 * eGalax and Gunze USB touch panels have the same device ID,
		 * so decide upon the vendor ID.
		 */
		switch (sc->sc_vendor) {
		case USB_VENDOR_EGALAX:
			down = (p[0] & 0x01);
			/* Invert the X coordinate */
			x = 0x07ff - abs(((p[3] & 0x0f) << 7) | (p[4] & 0x7f));
			y = ((p[1] & 0x0f) << 7) | (p[2] & 0x7f);
			z = down;
			sc->sc_pkts = 0x5;
			break;
		case USB_VENDOR_GUNZE:
			down = (~p[7] & 0x20);
			/* Invert the X coordinate */
			x = 0x0fff - abs(((p[0] & 0x1f) << 7) | (p[2] & 0x7f));
			y = ((p[1] & 0x1f) << 7) | (p[3] & 0x7f);
			z = (down != 0);
			sc->sc_pkts = 0x4;
			break;
		}
		break;
	}

	DPRINTF(("%s: down = 0x%x, sc->sc_pkts = 0x%x\n",
	    sc->sc_dev.dv_xname, down, sc->sc_pkts));

	/* x/y values are not reliable if there is no pressure */
	if (down) {
		if (sc->sc_tsscale.swapxy && !sc->sc_rawmode) {
			/* Swap X/Y-Axis */
			tp->y = x;
			tp->x = y;
		} else {
			tp->x = x;
			tp->y = y;
		}
		if (!sc->sc_rawmode &&
		    (sc->sc_tsscale.maxx - sc->sc_tsscale.minx) != 0 &&
		    (sc->sc_tsscale.maxy - sc->sc_tsscale.miny) != 0) {
			/* Scale down to the screen resolution. */
			tp->x = ((tp->x - sc->sc_tsscale.minx) *
			    sc->sc_tsscale.resx) /
			    (sc->sc_tsscale.maxx - sc->sc_tsscale.minx);
			tp->y = ((tp->y - sc->sc_tsscale.miny) *
			    sc->sc_tsscale.resy) /
			    (sc->sc_tsscale.maxy - sc->sc_tsscale.miny);
		}
	} else {
		tp->x = sc->sc_oldx;
		tp->y = sc->sc_oldy;
	}
	tp->z = z;
	tp->down = down;
}

void
uts_intr(struct usbd_xfer *xfer, void *addr, usbd_status status)
{
	struct uts_softc *sc = addr;
	u_int32_t len;
	int s;
	struct uts_pos tp;

	if (status == USBD_CANCELLED)
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		printf("%s: status %d\n", sc->sc_dev.dv_xname, status);
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_intr_pipe);
		return;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	s = spltty();

	uts_get_pos(sc, &tp);

	if (len != sc->sc_pkts) {
		DPRINTF(("%s: bad input length %d != %d\n",
		    sc->sc_dev.dv_xname, len, sc->sc_isize));
		splx(s);
		return;
	}

	DPRINTF(("%s: tp.down = %d, tp.z = %d, tp.x = %d, tp.y = %d\n",
	    sc->sc_dev.dv_xname, tp.down, tp.z, tp.x, tp.y));

	WSMOUSE_TOUCH(sc->sc_wsmousedev, tp.down, tp.x, tp.y, tp.z, 0);
	sc->sc_oldy = tp.y;
	sc->sc_oldx = tp.x;

	splx(s);
}
@


1.39
log
@Avoid calling usbd_set_config_index() in *_attach() and let the stack
do it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.38 2016/06/05 20:15:54 bru Exp $ */
d270 1
a270 1
		free(sc->sc_ibuf, M_USBDEV, 0);
d299 1
a299 1
		free(sc->sc_ibuf, M_USBDEV, 0);
@


1.38
log
@Use the new input functions of wsmouse in mouse and touchscreen drivers.

ok stsp@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.37 2016/02/10 05:49:50 guenther Exp $ */
a46 2
#define UTS_CONFIG_INDEX 0

a162 8

	/* Move the device into the configured state. */
	if (usbd_set_config_index(uaa->device, UTS_CONFIG_INDEX, 1) != 0) {
		printf("%s: could not set configuartion no\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}
@


1.37
log
@Permit negative x and y coordinates in mouse.scale for uts and ums.
Needed by some touchscreens.

no objection matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.36 2015/03/14 03:38:50 jsg Exp $ */
d479 1
a479 3
	wsmouse_input(sc->sc_wsmousedev, tp.down, tp.x, tp.y, tp.z, 0,
	    WSMOUSE_INPUT_ABSOLUTE_X | WSMOUSE_INPUT_ABSOLUTE_Y |
	    WSMOUSE_INPUT_ABSOLUTE_Z);
@


1.36
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.35 2014/12/19 22:44:59 guenther Exp $ */
d328 2
a329 2
		if (!(wsmc->minx >= 0 && wsmc->maxx >= 0 &&
		    wsmc->miny >= 0 && wsmc->maxy >= 0 &&
@


1.35
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.34 2014/07/12 18:48:53 tedu Exp $ */
a30 1
#include <machine/bus.h>
@


1.34
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.33 2014/03/07 18:39:02 mpi Exp $ */
d29 1
a31 1
#include <machine/endian.h>
@


1.33
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.32 2013/11/07 10:33:43 pirofti Exp $ */
d281 1
a281 1
		free(sc->sc_ibuf, M_USBDEV);
d310 1
a310 1
		free(sc->sc_ibuf, M_USBDEV);
@


1.32
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.31 2013/04/15 09:23:02 mglocker Exp $ */
a40 4

#ifdef USB_DEBUG
#define UTS_DEBUG
#endif
@


1.31
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.30 2011/07/03 15:47:17 matthew Exp $ */
a80 1
	int	sc_dying;
d175 1
a175 1
		sc->sc_dying = 1;
d184 1
a184 1
		sc->sc_dying = 1;
d192 1
a192 1
		sc->sc_dying = 1;
d205 1
a205 1
			sc->sc_dying = 1;
d219 1
a219 1
		sc->sc_dying = 1;
d259 1
a259 1
		sc->sc_dying = 1;
d272 1
a272 1
	if (sc->sc_dying)
@


1.30
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.29 2011/03/03 21:48:49 kettenis Exp $ */
d65 2
a66 2
	usbd_device_handle	sc_udev;
	usbd_interface_handle	sc_iface;
d72 1
a72 1
	usbd_pipe_handle	sc_intr_pipe;
d103 2
a104 2
void uts_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
void uts_get_pos(usbd_private_handle addr, struct uts_pos *tp);
d377 1
a377 1
uts_get_pos(usbd_private_handle addr, struct uts_pos *tp)
d452 1
a452 1
uts_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
@


1.29
log
@Prevent division-by-zero when scaling down to the screen resolution.  Make
the WSMOUSEIO_SCALIBCOORDS fail with EINVAL if the settings would cause a
division-by-zero.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.28 2011/01/25 20:03:36 jakemsr Exp $ */
a256 3
	case DVACT_ACTIVATE:
		break;

@


1.28
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.27 2010/09/24 08:33:59 yuo Exp $ */
d342 2
d435 3
a437 1
		if (!sc->sc_rawmode) {
@


1.27
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.26 2009/12/05 20:39:31 matthieu Exp $ */
a223 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev, &sc->sc_dev);

a245 2

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev, &sc->sc_dev);
@


1.26
log
@Ignore HID devices that have the same vendor and product ids than
devices actually supported by this device. The Linux driver confirms
they exist. ok miod@@ jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.25 2009/10/13 19:33:19 pirofti Exp $ */
a242 2

	sc->sc_dying = 1;
@


1.25
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.24 2009/02/14 20:05:09 chl Exp $ */
d137 1
d140 5
@


1.24
log
@remove dead assignments and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok fgsch@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.23 2008/12/29 16:29:42 miod Exp $ */
d119 1
a119 1
int uts_activate(struct device *, enum devact);
d251 1
a251 1
uts_activate(struct device *self, enum devact act)
@


1.23
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.22 2007/10/11 18:33:15 deraadt Exp $ */
d154 1
a154 1
	int i, found;
a193 1
	found = 0;
@


1.22
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.21 2007/09/18 19:44:40 miod Exp $ */
d403 1
a403 1
			/* Invert the X coordiate */
@


1.21
log
@Do not return from uts_intr() without restoring spl if it has been changed,
also clean up uts_get_pos() interface while there; spotted by and joint work
with fgsch@@, ok matthieu@@ robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.20 2007/09/16 03:19:15 fgsch Exp $ */
a153 1
	char *devinfop;
a164 6

	/* Display device info string */
	printf("\n");
	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.20
log
@some style(9). no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.19 2007/09/06 20:28:56 matthieu Exp $ */
d104 1
a104 1
struct uts_pos uts_get_pos(usbd_private_handle addr, struct uts_pos tp);
d385 2
a386 2
struct uts_pos
uts_get_pos(usbd_private_handle addr, struct uts_pos tp)
d435 2
a436 2
			tp.y = x;
			tp.x = y;
d438 2
a439 2
			tp.x = x;
			tp.y = y;
d443 1
a443 1
			tp.x = ((tp.x - sc->sc_tsscale.minx) *
d446 1
a446 1
			tp.y = ((tp.y - sc->sc_tsscale.miny) *
d451 2
a452 2
		tp.x = sc->sc_oldx;
		tp.y = sc->sc_oldy;
d454 2
a455 3
	tp.z = z;
	tp.down = down;
	return (tp);
a465 4
	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	s = spltty();

d471 2
a472 1
		usbd_clear_endpoint_stall_async(sc->sc_intr_pipe);
d476 5
a480 1
	tp = uts_get_pos(sc, tp);
d485 1
@


1.19
log
@Return pressure as absolute z axis on ITM touchscreens. Other models
just return 0 or 1 on this axis, depending on the contact.
Ok robert@@ miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.18 2007/08/30 18:49:29 matthieu Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Robert Nagy <robert@@openbsd.org> 
d62 1
a62 1
 
d116 15
a130 15
int uts_match(struct device *, void *, void *); 
void uts_attach(struct device *, struct device *, void *); 
int uts_detach(struct device *, int); 
int uts_activate(struct device *, enum devact); 

struct cfdriver uts_cd = { 
	NULL, "uts", DV_DULL 
}; 

const struct cfattach uts_ca = { 
	sizeof(struct uts_softc), 
	uts_match, 
	uts_attach, 
	uts_detach, 
	uts_activate, 
d139 1
a139 1
		return UMATCH_NONE;
d142 1
a142 1
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
d176 1
a176 1
			sc->sc_dev.dv_xname);
d185 1
a185 1
			sc->sc_dev.dv_xname);
d193 1
a193 1
			sc->sc_dev.dv_xname);
d207 1
a207 1
				sc->sc_dev.dv_xname, i);
d221 1
a221 1
			sc->sc_dev.dv_xname);
d226 1
a226 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);
d253 1
a253 2
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
d291 1
a291 1
		return 0;
d294 2
a295 2
		USBD_SHORT_XFER_OK, &sc->sc_intr_pipe, sc, sc->sc_ibuf,
		sc->sc_isize, uts_intr, USBD_DEFAULT_INTERVAL);
d299 1
a299 1
		return EIO;
d362 1
a362 1
		sc->sc_rawmode = wsmc->samplelen; 
d395 1
a395 1
		x = ((p[0] & 0x1f) << 7) | (p[3] & 0x7f);  
d433 1
a433 2

		if (sc->sc_tsscale.swapxy && !sc->sc_rawmode) {	
d484 1
a484 1
			sc->sc_dev.dv_xname, len, sc->sc_isize));
d489 1
a489 1
		sc->sc_dev.dv_xname, tp.down, tp.z, tp.x, tp.y));
d492 2
a493 2
		WSMOUSE_INPUT_ABSOLUTE_X | WSMOUSE_INPUT_ABSOLUTE_Y |
		WSMOUSE_INPUT_ABSOLUTE_Z); 
@


1.18
log
@don't swap X and Y coordinates while in raw mode. ok robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.17 2007/06/14 10:11:16 mbalmer Exp $ */
d90 1
d392 1
a392 1
	int down, x, y;
d400 1
d415 1
d423 1
a452 1
		tp.z = 1;
a455 1
		tp.z = 0;
d457 2
a458 1

d491 2
a492 2
	DPRINTF(("%s: tp.z = %d, tp.x = %d, tp.y = %d\n",
	    sc->sc_dev.dv_xname, tp.z, tp.x, tp.y));
d494 1
a494 1
	wsmouse_input(sc->sc_wsmousedev, tp.z, tp.x, tp.y, 0, 0,
@


1.17
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.16 2007/06/13 06:25:03 mbalmer Exp $ */
d431 3
a433 1
		if (sc->sc_tsscale.swapxy) {	/* Swap X/Y-Axis */
a439 1

@


1.16
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.15 2007/06/12 16:26:37 mbalmer Exp $ */
d115 16
a130 1
USB_DECLARE_DRIVER(uts);
@


1.15
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.14 2007/06/11 01:05:43 jsg Exp $ */
d77 1
a77 1
	struct device *		sc_wsmousedev;
@


1.14
log
@usbd_devinfo_alloc() uses M_WAITOK so don't check return value.
From Karl Sjödahl <dunceor@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.13 2007/06/10 14:49:01 mbalmer Exp $ */
d77 1
a77 1
	device_ptr_t		sc_wsmousedev;
d245 1
a245 1
uts_activate(device_ptr_t self, enum devact act)
@


1.13
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.12 2007/06/10 10:53:49 mbalmer Exp $ */
d153 3
a155 4
	if ((devinfop = usbd_devinfo_alloc(uaa->device, 0)) != NULL) {
		printf("%s: %s\n", sc->sc_dev.dv_xname, devinfop);
		usbd_devinfo_free(devinfop);
	}
@


1.12
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.11 2007/06/06 19:25:50 mk Exp $ */
d154 1
a154 1
		printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d161 1
a161 1
			USBDEVNAME(sc->sc_dev));
d170 1
a170 1
			USBDEVNAME(sc->sc_dev));
d178 1
a178 1
			USBDEVNAME(sc->sc_dev));
d192 1
a192 1
				USBDEVNAME(sc->sc_dev), i);
d206 1
a206 1
			USBDEVNAME(sc->sc_dev));
d413 1
a413 1
	    USBDEVNAME(sc->sc_dev), down, sc->sc_pkts));
d460 1
a460 1
		printf("%s: status %d\n", USBDEVNAME(sc->sc_dev), status);
d469 1
a469 1
			USBDEVNAME(sc->sc_dev), len, sc->sc_isize));
d474 1
a474 1
	    USBDEVNAME(sc->sc_dev), tp.z, tp.x, tp.y));
@


1.11
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.10 2007/06/05 08:43:56 mbalmer Exp $ */
d212 1
a212 1
			   USBDEV(sc->sc_dev));
d240 1
a240 1
			   USBDEV(sc->sc_dev));
@


1.10
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.9 2007/05/31 02:56:03 robert Exp $ */
d64 1
a64 1
	USBBASEDEVICE		sc_dev;
@


1.9
log
@add Gunze USB Touch Panel support
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.8 2007/05/27 04:00:25 jsg Exp $ */
d95 1
a95 1
Static const struct usb_devno uts_devs[] = {
d102 1
a102 1
Static void uts_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d105 3
a107 3
Static int	uts_enable(void *);
Static void	uts_disable(void *);
Static int	uts_ioctl(void *, u_long, caddr_t, int, struct proc *);
d265 1
a265 1
Static int
d295 1
a295 1
Static void
d320 1
a320 1
Static int
d444 1
a444 1
Static void
@


1.8
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.7 2007/05/18 18:47:30 robert Exp $ */
d69 1
d98 2
a99 1
	{ USB_VENDOR_EGALAX,		USB_PRODUCT_EGALAX_TPANEL2 }
d143 1
d389 20
a408 5
		down = (p[0] & 0x01);
		/* Invert the X coordiate */
		x = 0x07ff - abs(((p[3] & 0x0f) << 7) | (p[4] & 0x7f));
		y = ((p[1] & 0x0f) << 7) | (p[2] & 0x7f);
		sc->sc_pkts = 0x5;
@


1.7
log
@fix the check of wsmouse_calibcoords values and
invert the X or Y coordinates to make the top left
corner (0,0).
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.6 2007/05/08 20:48:03 robert Exp $ */
d115 2
a116 1
USB_MATCH(uts)
d118 1
a118 1
	USB_MATCH_START(uts, uaa);
d127 2
a128 1
USB_ATTACH(uts)
d130 2
a131 1
	USB_ATTACH_START(uts, sc, uaa);
d149 1
a149 1
	USB_ATTACH_SETUP;
d160 1
a160 1
		USB_ATTACH_ERROR_RETURN;
d169 1
a169 1
		USB_ATTACH_ERROR_RETURN;
d177 1
a177 1
		USB_ATTACH_ERROR_RETURN;
d191 1
a191 1
			USB_ATTACH_ERROR_RETURN;
d205 1
a205 1
		USB_ATTACH_ERROR_RETURN;
a214 2

	USB_ATTACH_SUCCESS_RETURN;
d217 2
a218 1
USB_DETACH(uts)
d220 1
a220 1
	USB_DETACH_START(uts, sc);
@


1.6
log
@Make use of struct wsmouse_calibcoords and add ioctl support
for getting and passing calibration values. Move the scale
struct to uts_softc so that each device can have it's own values
instead of using the global one.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.5 2007/04/26 17:00:28 miod Exp $ */
d333 1
a333 1
		    wsmc->swapxy >= 0 && wsmc->swapxy < 1 &&
d378 2
a379 1
		y = ((p[1] & 0x1f) << 7) | (p[4] & 0x7f);
d385 2
a386 1
		x = ((p[3] & 0x0f) << 7) | (p[4] & 0x7f);
d404 1
a404 1
	
@


1.5
log
@USB device lists do not need a terminating sentinel, so don't provide any;
this should prevent phantom devices from attaching axe or uberry on
some machines.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.4 2007/04/25 14:17:42 robert Exp $ */
a20 1
#include <sys/sysctl.h>
d54 9
d83 1
a83 1
};
d85 1
a85 12
/* Settable via sysctl */
int	uts_rawmode;
struct utsscale {
	int	ts_minx;
	int	ts_maxx;
	int	ts_miny;
	int	ts_maxy;
	int	ts_swapxy;
	int	ts_resx;
	int	ts_resy;
} uts_scale = {
	67, 1931, 102, 1937, 0, 1024, 768
d142 3
d318 7
d326 30
d358 4
a361 1
		return (0);
d364 1
a364 1
	return (-1);
a370 1
	struct utsscale *tsp = &uts_scale;
d395 1
a395 1
		if (tsp->ts_swapxy) {	/* Swap X/Y-Axis */
d403 1
a403 1
		if (!uts_rawmode) {
d405 6
a410 4
			tp.x = ((tp.x - tsp->ts_minx) * tsp->ts_resx) /
			    (tsp->ts_maxx - tsp->ts_minx);
			tp.y = ((tp.y - tsp->ts_miny) * tsp->ts_resy) /
			    (tsp->ts_maxy - tsp->ts_miny);
@


1.4
log
@Add suport for printing debug information like coordinates if UTS_DEBUG
is defined and make sure that we are calling wsmouse_input every time
the screen gets touched on different types of touchscreens.
Some minor cleanups while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.3 2007/04/10 22:37:17 miod Exp $ */
d100 1
a100 2
	{ USB_VENDOR_EGALAX,		USB_PRODUCT_EGALAX_TPANEL2 },
	{ 0, 0 }
@


1.3
log
@Add support for a fourth axis on wsmouse devices, e.g. on the Apple Might
Mouse.  Currently limited to USB mice.

Adapted from a diff from Gareth <garf@@loveandnature.co.za> on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.2 2007/03/23 14:35:19 robert Exp $ */
d43 10
d88 1
a88 1
	3800, 500, 450, 3800, 1, 1024, 768
d338 1
a338 1
		down = (p[7] & 0x20);	
d341 1
a341 1
		sc->sc_pkts = 8;
d348 1
a348 1
		sc->sc_pkts = 5;
d352 5
a356 1
	if (!down) {
a373 1
		/* x/y values are not reliable if there is no pressure */
d406 2
a407 2
		printf("%s: bad input length %d != %d\n",
			USBDEVNAME(sc->sc_dev), len, sc->sc_isize);
d410 3
@


1.2
log
@the input length is different on the eGalax and ITM screens,
so let's adapt the code by specifing the corrent length and
and move the check to the correct place.
@
text
@d1 1
a1 1
/*	$OpenBSD: uts.c,v 1.1 2007/03/16 21:40:32 robert Exp $ */
d398 1
a398 1
	wsmouse_input(sc->sc_wsmousedev, tp.z, tp.x, tp.y, 0,
@


1.1
log
@uts(4) is a driver for USB Touchscreens;

currently the driver only support touchscreens made by eGalax and
Future Technology Devices (ITM)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d56 1
d331 1
d338 1
d390 3
a392 1
	if (len != 8) {
a396 2

	tp = uts_get_pos(sc, tp);
@

