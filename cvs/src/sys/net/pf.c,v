head	1.1030;
access;
symbols
	OPENBSD_6_1:1.1019.0.4
	OPENBSD_6_1_BASE:1.1019
	OPENBSD_6_0:1.979.0.4
	OPENBSD_6_0_BASE:1.979
	OPENBSD_5_9:1.965.0.2
	OPENBSD_5_9_BASE:1.965
	OPENBSD_5_8:1.935.0.4
	OPENBSD_5_8_BASE:1.935
	OPENBSD_5_7:1.906.0.2
	OPENBSD_5_7_BASE:1.906
	OPENBSD_5_6:1.883.0.4
	OPENBSD_5_6_BASE:1.883
	OPENBSD_5_5:1.868.0.4
	OPENBSD_5_5_BASE:1.868
	OPENBSD_5_4:1.838.0.2
	OPENBSD_5_4_BASE:1.838
	OPENBSD_5_3:1.818.0.2
	OPENBSD_5_3_BASE:1.818
	OPENBSD_5_2:1.808.0.2
	OPENBSD_5_2_BASE:1.808
	OPENBSD_5_1_BASE:1.802
	OPENBSD_5_1:1.802.0.2
	OPENBSD_5_0:1.770.0.2
	OPENBSD_5_0_BASE:1.770
	OPENBSD_4_9:1.727.0.2
	OPENBSD_4_9_BASE:1.727
	OPENBSD_4_8:1.696.0.2
	OPENBSD_4_8_BASE:1.696
	OPENBSD_4_7:1.690.0.2
	OPENBSD_4_7_BASE:1.690
	OPENBSD_4_6:1.655.0.4
	OPENBSD_4_6_BASE:1.655
	OPENBSD_4_5:1.634.0.2
	OPENBSD_4_5_BASE:1.634
	OPENBSD_4_4:1.614.0.2
	OPENBSD_4_4_BASE:1.614
	OPENBSD_4_3:1.567.0.2
	OPENBSD_4_3_BASE:1.567
	OPENBSD_4_2:1.552.0.2
	OPENBSD_4_2_BASE:1.552
	OPENBSD_4_1:1.527.0.2
	OPENBSD_4_1_BASE:1.527
	OPENBSD_4_0:1.513.0.2
	OPENBSD_4_0_BASE:1.513
	OPENBSD_3_9:1.510.0.2
	OPENBSD_3_9_BASE:1.510
	OPENBSD_3_8:1.502.0.2
	OPENBSD_3_8_BASE:1.502
	OPENBSD_3_7:1.483.0.2
	OPENBSD_3_7_BASE:1.483
	OPENBSD_3_6:1.457.0.2
	OPENBSD_3_6_BASE:1.457
	SMP_SYNC_A:1.451
	SMP_SYNC_B:1.450
	OPENBSD_3_5:1.433.0.2
	OPENBSD_3_5_BASE:1.433
	OPENBSD_3_4:1.389.0.2
	OPENBSD_3_4_BASE:1.389
	UBC_SYNC_A:1.357
	OPENBSD_3_3:1.328.0.2
	OPENBSD_3_3_BASE:1.328
	OPENBSD_3_2:1.245.0.2
	OPENBSD_3_2_BASE:1.245
	OPENBSD_3_1:1.201.0.2
	OPENBSD_3_1_BASE:1.201
	UBC_SYNC_B:1.257
	UBC:1.180.0.2
	UBC_BASE:1.180
	OPENBSD_3_0:1.163.0.2
	OPENBSD_3_0_BASE:1.163
	SMP:1.95.0.2;
locks; strict;
comment	@ * @;


1.1030
date	2017.05.28.16.55.54;	author bluhm;	state Exp;
branches;
next	1.1029;
commitid	fVacbt2trwJo0tol;

1.1029
date	2017.05.28.16.43.45;	author bluhm;	state Exp;
branches;
next	1.1028;
commitid	2nvtDSXE6XBBUlgS;

1.1028
date	2017.05.28.14.54.00;	author bluhm;	state Exp;
branches;
next	1.1027;
commitid	sUfoCjfafnpLsoF7;

1.1027
date	2017.05.23.09.09.03;	author bluhm;	state Exp;
branches;
next	1.1026;
commitid	WGxfyyYEcPeRzdVY;

1.1026
date	2017.05.20.22.56.43;	author sashan;	state Exp;
branches;
next	1.1025;
commitid	jDeA50op1ccbx4KF;

1.1025
date	2017.05.19.10.43.05;	author rzalamena;	state Exp;
branches;
next	1.1024;
commitid	g4jKg3k29Ku0EWej;

1.1024
date	2017.05.16.22.16.30;	author sashan;	state Exp;
branches;
next	1.1023;
commitid	RVtT0vc7qT2d1M9d;

1.1023
date	2017.05.16.12.24.01;	author mpi;	state Exp;
branches;
next	1.1022;
commitid	SAe3SQ48vKH6r5FL;

1.1022
date	2017.05.15.12.26.00;	author mpi;	state Exp;
branches;
next	1.1021;
commitid	WMZaI3vIHNC1J8ol;

1.1021
date	2017.05.05.16.30.39;	author mikeb;	state Exp;
branches;
next	1.1020;
commitid	Vl3z13Xv9PhJRyZN;

1.1020
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.1019;
commitid	Gef6NNDxonzfVaq2;

1.1019
date	2017.03.17.17.19.16;	author mpi;	state Exp;
branches
	1.1019.4.1;
next	1.1018;
commitid	CxqvXOMqotM60GAI;

1.1018
date	2017.03.09.05.47.28;	author claudio;	state Exp;
branches;
next	1.1017;
commitid	UKn3YcuNNIuNbCSS;

1.1017
date	2017.03.07.16.28.37;	author mikeb;	state Exp;
branches;
next	1.1016;
commitid	vYi43U6WYsVqlrkq;

1.1016
date	2017.03.07.09.29.40;	author mpi;	state Exp;
branches;
next	1.1015;
commitid	QgQyFPB2cBKh0tC3;

1.1015
date	2017.02.09.15.19.32;	author jca;	state Exp;
branches;
next	1.1014;
commitid	Hew5AYIxyEp5lNbI;

1.1014
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.1013;
commitid	2R0NOjEDy2jGtnjL;

1.1013
date	2017.01.30.17.52.24;	author benno;	state Exp;
branches;
next	1.1012;
commitid	R17N1ThXoxr4aHhp;

1.1012
date	2017.01.30.17.41.33;	author benno;	state Exp;
branches;
next	1.1011;
commitid	jxfz0zamCXSbKEUx;

1.1011
date	2017.01.25.06.15.50;	author mpi;	state Exp;
branches;
next	1.1010;
commitid	X7Hk1efefaYrWlw3;

1.1010
date	2017.01.09.14.47.13;	author mpi;	state Exp;
branches;
next	1.1009;
commitid	9mW3Rdc7FelukRFu;

1.1009
date	2016.12.29.13.01.48;	author bluhm;	state Exp;
branches;
next	1.1008;
commitid	niqDyzVo4a11cYNV;

1.1008
date	2016.12.28.15.36.15;	author bluhm;	state Exp;
branches;
next	1.1007;
commitid	f1Hwv5X6T0BAAKmI;

1.1007
date	2016.12.28.15.19.02;	author bluhm;	state Exp;
branches;
next	1.1006;
commitid	tdE0FpPjjgZBycsn;

1.1006
date	2016.12.23.20.49.41;	author bluhm;	state Exp;
branches;
next	1.1005;
commitid	cbvfPcS7iIdktoB7;

1.1005
date	2016.12.23.19.46.13;	author bluhm;	state Exp;
branches;
next	1.1004;
commitid	YeWZdWbAjFya1AGq;

1.1004
date	2016.12.06.00.01.55;	author jsg;	state Exp;
branches;
next	1.1003;
commitid	Uke8oLHZloj6kEDP;

1.1003
date	2016.11.28.23.15.30;	author bluhm;	state Exp;
branches;
next	1.1002;
commitid	tRB1wgF5XEe7ukoA;

1.1002
date	2016.11.23.12.13.23;	author bluhm;	state Exp;
branches;
next	1.1001;
commitid	Pp3tKF2NLsiC2o7E;

1.1001
date	2016.11.22.19.29.54;	author procter;	state Exp;
branches;
next	1.1000;
commitid	Wwno1dT3ILCyVgb1;

1.1000
date	2016.11.21.15.23.18;	author bluhm;	state Exp;
branches;
next	1.999;
commitid	yj7ltP322q615IJl;

1.999
date	2016.11.17.13.17.32;	author bluhm;	state Exp;
branches;
next	1.998;
commitid	eg2LuWuzOploBhVo;

1.998
date	2016.11.14.13.25.00;	author bluhm;	state Exp;
branches;
next	1.997;
commitid	B8d5g57KBGx1yYQP;

1.997
date	2016.11.14.03.51.53;	author dlg;	state Exp;
branches;
next	1.996;
commitid	Khqq96MLd95C1Z1s;

1.996
date	2016.10.28.07.54.19;	author sashan;	state Exp;
branches;
next	1.995;
commitid	Rv7MhoGDNXtOE6x2;

1.995
date	2016.10.27.21.41.20;	author bluhm;	state Exp;
branches;
next	1.994;
commitid	RZerTDpaYI8sgJZ6;

1.994
date	2016.10.26.21.07.22;	author bluhm;	state Exp;
branches;
next	1.993;
commitid	aaKAr0kv3QWNHoVo;

1.993
date	2016.10.20.23.18.43;	author sashan;	state Exp;
branches;
next	1.992;
commitid	4GBoDut1GLJhOlmY;

1.992
date	2016.10.18.13.28.01;	author henning;	state Exp;
branches;
next	1.991;
commitid	E0MSCxfVE1cKcqjo;

1.991
date	2016.10.18.11.29.27;	author bluhm;	state Exp;
branches;
next	1.990;
commitid	ph89xSVxdMkzMRzN;

1.990
date	2016.10.18.11.20.42;	author bluhm;	state Exp;
branches;
next	1.989;
commitid	sVKKpLEwdEwWK8JB;

1.989
date	2016.10.09.18.01.57;	author henning;	state Exp;
branches;
next	1.988;
commitid	y4OMc9bgX9cdDPTK;

1.988
date	2016.10.06.19.09.08;	author bluhm;	state Exp;
branches;
next	1.987;
commitid	IO8dsedjngxSg7J1;

1.987
date	2016.09.27.04.57.17;	author dlg;	state Exp;
branches;
next	1.986;
commitid	irzdR7hwk1GHVaEu;

1.986
date	2016.09.27.02.51.12;	author dlg;	state Exp;
branches;
next	1.985;
commitid	bZuzILta8BoFCDiT;

1.985
date	2016.09.22.10.50.19;	author jsg;	state Exp;
branches;
next	1.984;
commitid	c8QSE6r4ysRJsDrL;

1.984
date	2016.09.07.09.36.49;	author mpi;	state Exp;
branches;
next	1.983;
commitid	maggOul7Gx8kGBXs;

1.983
date	2016.09.03.17.11.40;	author sashan;	state Exp;
branches;
next	1.982;
commitid	JAk2J5vzbGC5EyfM;

1.982
date	2016.08.20.08.34.30;	author procter;	state Exp;
branches;
next	1.981;
commitid	zLszZ8lmZ7zIfSnw;

1.981
date	2016.08.20.08.31.36;	author procter;	state Exp;
branches;
next	1.980;
commitid	VkHZT3J09fH4tfiL;

1.980
date	2016.08.17.03.24.11;	author procter;	state Exp;
branches;
next	1.979;
commitid	NB7EODatRadIbwDM;

1.979
date	2016.07.18.13.17.44;	author bluhm;	state Exp;
branches
	1.979.4.1;
next	1.978;
commitid	LlSukCQvQcHux9Yv;

1.978
date	2016.06.21.16.45.37;	author bluhm;	state Exp;
branches;
next	1.977;
commitid	EPeqwz8xsvf417j5;

1.977
date	2016.06.15.11.49.34;	author mpi;	state Exp;
branches;
next	1.976;
commitid	qWegq9wDcxofLjIV;

1.976
date	2016.06.15.11.36.06;	author mikeb;	state Exp;
branches;
next	1.975;
commitid	M8Mky6ZXisJyQBHU;

1.975
date	2016.06.07.01.31.54;	author tedu;	state Exp;
branches;
next	1.974;
commitid	37V3kDRiYRccnYvB;

1.974
date	2016.05.31.07.35.36;	author mpi;	state Exp;
branches;
next	1.973;
commitid	3vLf0g1Bo7ekw00g;

1.973
date	2016.05.28.12.04.33;	author sthen;	state Exp;
branches;
next	1.972;
commitid	WWfGhYWt5IExEXFX;

1.972
date	2016.05.24.05.02.34;	author mpi;	state Exp;
branches;
next	1.971;
commitid	GM30whPuIGiYzUbB;

1.971
date	2016.05.23.12.26.28;	author mpi;	state Exp;
branches;
next	1.970;
commitid	ZfWhklTDYBaqoJGd;

1.970
date	2016.05.03.12.13.38;	author mpi;	state Exp;
branches;
next	1.969;
commitid	TBD5370V0rvOYywK;

1.969
date	2016.04.15.02.54.17;	author dlg;	state Exp;
branches;
next	1.968;
commitid	TLgnIL2tHEx3rUtl;

1.968
date	2016.04.07.14.28.16;	author mpi;	state Exp;
branches;
next	1.967;
commitid	UatRm9F5NY6nwt5n;

1.967
date	2016.03.29.10.34.42;	author sashan;	state Exp;
branches;
next	1.966;
commitid	3oT5Q5z024mhykOL;

1.966
date	2016.03.04.22.38.23;	author sashan;	state Exp;
branches;
next	1.965;
commitid	7fajBfMUpKRTskMd;

1.965
date	2016.01.31.00.18.07;	author sashan;	state Exp;
branches
	1.965.2.1;
next	1.964;
commitid	XnM42P9Sq7TQR88T;

1.964
date	2016.01.25.18.49.57;	author sashan;	state Exp;
branches;
next	1.963;
commitid	KeemoLxcm7FS1oYy;

1.963
date	2016.01.07.22.23.13;	author sashan;	state Exp;
branches;
next	1.962;
commitid	uGcSilygSiLkUqPZ;

1.962
date	2015.12.23.21.04.55;	author jasper;	state Exp;
branches;
next	1.961;
commitid	fJOVhuW2zBjxPtee;

1.961
date	2015.12.22.13.33.26;	author sashan;	state Exp;
branches;
next	1.960;
commitid	oBRhtWcDV0ThviVT;

1.960
date	2015.12.06.10.03.23;	author henning;	state Exp;
branches;
next	1.959;
commitid	BOloQs48TQM07QHG;

1.959
date	2015.12.05.21.23.51;	author henning;	state Exp;
branches;
next	1.958;
commitid	h2JnbfJCwXnWUaC0;

1.958
date	2015.12.05.14.58.06;	author henning;	state Exp;
branches;
next	1.957;
commitid	Qp6xVC0LVIvANYZS;

1.957
date	2015.12.03.21.11.53;	author sashan;	state Exp;
branches;
next	1.956;
commitid	nhuzteWvIf6uiITt;

1.956
date	2015.12.03.14.05.28;	author bluhm;	state Exp;
branches;
next	1.955;
commitid	Qo1JIwCdJHaA2LFI;

1.955
date	2015.12.03.09.49.15;	author bluhm;	state Exp;
branches;
next	1.954;
commitid	6HkfIaw2ROsrfw1Q;

1.954
date	2015.12.02.16.00.42;	author sashan;	state Exp;
branches;
next	1.953;
commitid	uojPT94sS2Q9I95I;

1.953
date	2015.12.02.13.29.25;	author claudio;	state Exp;
branches;
next	1.952;
commitid	Hf3C2AvfIXmCAmHE;

1.952
date	2015.11.21.11.29.40;	author mpi;	state Exp;
branches;
next	1.951;
commitid	lH935V5VmT4OfWCp;

1.951
date	2015.11.20.10.42.51;	author mpi;	state Exp;
branches;
next	1.950;
commitid	UsUl7pnwJXMMORv0;

1.950
date	2015.11.12.10.07.14;	author mpi;	state Exp;
branches;
next	1.949;
commitid	DLHQ4NjCPIqpY9kD;

1.949
date	2015.11.06.17.55.55;	author mpi;	state Exp;
branches;
next	1.948;
commitid	rF3eCQCnoqyAKLl5;

1.948
date	2015.10.27.10.52.17;	author mpi;	state Exp;
branches;
next	1.947;
commitid	pUxjPEbAeKZSbuEi;

1.947
date	2015.10.13.19.32.31;	author sashan;	state Exp;
branches;
next	1.946;
commitid	2CkJMFIEZK18G5IB;

1.946
date	2015.10.08.11.36.51;	author dlg;	state Exp;
branches;
next	1.945;
commitid	x9P7w55EUlF0EQh7;

1.945
date	2015.09.23.08.49.46;	author mpi;	state Exp;
branches;
next	1.944;
commitid	24xqlqpNt9NPeWH3;

1.944
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.943;
commitid	zZXiESHR0g5lNO0l;

1.943
date	2015.09.12.20.26.06;	author mpi;	state Exp;
branches;
next	1.942;
commitid	UM7jfgLT8vWQUBm1;

1.942
date	2015.09.12.16.32.27;	author bluhm;	state Exp;
branches;
next	1.941;
commitid	MzqupFla51i44EuX;

1.941
date	2015.09.11.15.21.31;	author mpi;	state Exp;
branches;
next	1.940;
commitid	xQBlxvzDwifpmxF3;

1.940
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.939;
commitid	Cr0DVA7exR1t2zXg;

1.939
date	2015.09.10.08.28.31;	author mpi;	state Exp;
branches;
next	1.938;
commitid	HnG66cy5an8UA4Iu;

1.938
date	2015.09.09.20.03.56;	author dlg;	state Exp;
branches;
next	1.937;
commitid	JADA4jEL9IAaKFZr;

1.937
date	2015.09.01.19.12.25;	author sashan;	state Exp;
branches;
next	1.936;
commitid	t9mePMusNtbKWnxJ;

1.936
date	2015.08.19.21.22.41;	author sashan;	state Exp;
branches;
next	1.935;
commitid	YGKggp2X8s4irKok;

1.935
date	2015.07.21.02.32.04;	author sashan;	state Exp;
branches;
next	1.934;
commitid	cPDXdho3rjhTprUk;

1.934
date	2015.07.20.18.42.08;	author jsg;	state Exp;
branches;
next	1.933;
commitid	nffqezEm9k9xuYCt;

1.933
date	2015.07.20.01.18.33;	author mcbride;	state Exp;
branches;
next	1.932;
commitid	vUhxln3IyKWnKmPF;

1.932
date	2015.07.19.23.13.58;	author sashan;	state Exp;
branches;
next	1.931;
commitid	JUghvRdAvz2W0Kg5;

1.931
date	2015.07.19.05.48.11;	author sashan;	state Exp;
branches;
next	1.930;
commitid	SIH047fmULS8uLq7;

1.930
date	2015.07.19.01.58.19;	author sashan;	state Exp;
branches;
next	1.929;
commitid	c3fH8E2IvSIMTGY0;

1.929
date	2015.07.18.23.11.35;	author sashan;	state Exp;
branches;
next	1.928;
commitid	cvdELLAE4gFq1NCH;

1.928
date	2015.07.18.19.19.00;	author sashan;	state Exp;
branches;
next	1.927;
commitid	JLCIxhdc71KA1Osw;

1.927
date	2015.07.18.15.47.01;	author mpi;	state Exp;
branches;
next	1.926;
commitid	oUfDvyu3RKjOMjak;

1.926
date	2015.07.18.15.19.44;	author sashan;	state Exp;
branches;
next	1.925;
commitid	FkfdBMmgICAjEgne;

1.925
date	2015.07.17.22.52.29;	author tedu;	state Exp;
branches;
next	1.924;
commitid	OOrGfFHYAn65M2qc;

1.924
date	2015.07.16.21.14.21;	author mpi;	state Exp;
branches;
next	1.923;
commitid	VGPlklxThaST7mIm;

1.923
date	2015.07.16.16.12.15;	author mpi;	state Exp;
branches;
next	1.922;
commitid	STtcOm1B3VSMXz2h;

1.922
date	2015.07.08.13.03.26;	author bluhm;	state Exp;
branches;
next	1.921;
commitid	rRy7znn1PIEdZWQJ;

1.921
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.920;
commitid	J4OPNuggl4DOKGzM;

1.920
date	2015.06.22.15.58.23;	author mikeb;	state Exp;
branches;
next	1.919;
commitid	U5byky6UH0vsqxMY;

1.919
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.918;
commitid	h7z8lokZ0dFyuWpg;

1.918
date	2015.06.07.12.02.28;	author jsg;	state Exp;
branches;
next	1.917;
commitid	st7eUqjf7vKTD48M;

1.917
date	2015.06.05.13.22.34;	author mikeb;	state Exp;
branches;
next	1.916;
commitid	OE0CVnFL4x2RZU75;

1.916
date	2015.05.26.16.17.51;	author mikeb;	state Exp;
branches;
next	1.915;
commitid	hyJNPK8j0ZCSGmUC;

1.915
date	2015.05.22.14.18.55;	author mikeb;	state Exp;
branches;
next	1.914;
commitid	l30NkhEeQ1MBcdhn;

1.914
date	2015.05.22.14.16.09;	author mikeb;	state Exp;
branches;
next	1.913;
commitid	rNY7Hl02xkmbVJnq;

1.913
date	2015.05.11.12.22.14;	author henning;	state Exp;
branches;
next	1.912;
commitid	CitaRBUD7quISLVm;

1.912
date	2015.04.17.11.04.01;	author mikeb;	state Exp;
branches;
next	1.911;
commitid	6glXvFR7NxzCcdRd;

1.911
date	2015.04.11.13.00.12;	author dlg;	state Exp;
branches;
next	1.910;
commitid	uT17hi9tQuyDqgaw;

1.910
date	2015.04.08.12.50.21;	author mikeb;	state Exp;
branches;
next	1.909;
commitid	8ZjJ0dkawcBrala5;

1.909
date	2015.03.18.12.23.15;	author dlg;	state Exp;
branches;
next	1.908;
commitid	veRr3qZI7HBatTwk;

1.908
date	2015.03.16.02.40.55;	author yasuoka;	state Exp;
branches;
next	1.907;
commitid	tUGlrQo8QQLT60nV;

1.907
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.906;
commitid	p4LJxGKbi0BU2cG6;

1.906
date	2015.02.14.23.32.41;	author sthen;	state Exp;
branches;
next	1.905;
commitid	yqzib6o76qMH9qZC;

1.905
date	2015.02.12.01.24.10;	author henning;	state Exp;
branches;
next	1.904;
commitid	9O1PirN7lXfubwO8;

1.904
date	2015.02.10.09.28.40;	author henning;	state Exp;
branches;
next	1.903;
commitid	UCQxCe3lrdmzEpqK;

1.903
date	2015.02.10.06.45.55;	author henning;	state Exp;
branches;
next	1.902;
commitid	eD7tXFa7upGCZ3zN;

1.902
date	2015.02.09.19.14.48;	author markus;	state Exp;
branches;
next	1.901;
commitid	ftKPXkYdMYfFNrbF;

1.901
date	2015.02.07.09.15.25;	author henning;	state Exp;
branches;
next	1.900;
commitid	pZLeqJcEZHrepTac;

1.900
date	2015.02.05.01.10.57;	author mpi;	state Exp;
branches;
next	1.899;
commitid	Vt4pFgzpwezZJ2dA;

1.899
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.898;
commitid	VK3ncyiP3NS1N4Sy;

1.898
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.897;
commitid	zhW8jJrfVCoAthrR;

1.897
date	2014.12.11.08.45.44;	author mpi;	state Exp;
branches;
next	1.896;
commitid	e2wzs6CZd9kbtuRH;

1.896
date	2014.11.20.13.54.24;	author mpi;	state Exp;
branches;
next	1.895;
commitid	F3Fu23ZZ8dwzir4r;

1.895
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.894;
commitid	Z1vcFtHO8wRH0yRt;

1.894
date	2014.11.16.17.40.17;	author tedu;	state Exp;
branches;
next	1.893;
commitid	uTRYYdKAFgGuFA8c;

1.893
date	2014.11.16.17.37.42;	author tedu;	state Exp;
branches;
next	1.892;
commitid	I2S88DLQluPEw9S5;

1.892
date	2014.11.16.11.58.14;	author dlg;	state Exp;
branches;
next	1.891;
commitid	709Ss529LLrHEbdQ;

1.891
date	2014.11.11.11.37.05;	author mikeb;	state Exp;
branches;
next	1.890;
commitid	ENbCbbtqueE7IrFb;

1.890
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.889;
commitid	w0MRp28dmfD1ZzO8;

1.889
date	2014.10.14.09.52.25;	author mpi;	state Exp;
branches;
next	1.888;
commitid	6AYfDT0Lpez1LFQp;

1.888
date	2014.10.08.07.37.01;	author mpi;	state Exp;
branches;
next	1.887;
commitid	Zq5kNn2HIZzyRxfQ;

1.887
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.886;
commitid	HQcmytntiCJTHORs;

1.886
date	2014.08.12.15.29.33;	author mikeb;	state Exp;
branches;
next	1.885;
commitid	VQXfMjKroH5JkPuJ;

1.885
date	2014.08.12.14.42.06;	author mikeb;	state Exp;
branches;
next	1.884;
commitid	8rTAna1OtQF4tDHR;

1.884
date	2014.08.12.14.38.27;	author mikeb;	state Exp;
branches;
next	1.883;
commitid	rj3vXaJ8TiOS9RoX;

1.883
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches
	1.883.4.1;
next	1.882;
commitid	DQakU8LLWV6Iwx84;

1.882
date	2014.07.13.16.58.43;	author bluhm;	state Exp;
branches;
next	1.881;
commitid	3Zkzzkgbxiveo4Fa;

1.881
date	2014.07.10.03.17.59;	author lteo;	state Exp;
branches;
next	1.880;
commitid	baLHEMMpirACq25p;

1.880
date	2014.07.02.13.04.50;	author mikeb;	state Exp;
branches;
next	1.879;
commitid	R3o71yWBjPgoUXBj;

1.879
date	2014.06.25.16.21.20;	author mikeb;	state Exp;
branches;
next	1.878;
commitid	jAxcy0jCm4KoeB0n;

1.878
date	2014.05.20.11.03.13;	author mpi;	state Exp;
branches;
next	1.877;

1.877
date	2014.04.24.11.55.12;	author henning;	state Exp;
branches;
next	1.876;

1.876
date	2014.04.22.14.41.03;	author mpi;	state Exp;
branches;
next	1.875;

1.875
date	2014.04.21.12.22.25;	author henning;	state Exp;
branches;
next	1.874;

1.874
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.873;

1.873
date	2014.04.19.12.59.53;	author henning;	state Exp;
branches;
next	1.872;

1.872
date	2014.04.18.15.13.01;	author henning;	state Exp;
branches;
next	1.871;

1.871
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.870;

1.870
date	2014.03.10.17.27.06;	author jca;	state Exp;
branches;
next	1.869;

1.869
date	2014.03.10.17.22.27;	author jca;	state Exp;
branches;
next	1.868;

1.868
date	2014.01.25.03.39.00;	author lteo;	state Exp;
branches
	1.868.4.1;
next	1.867;

1.867
date	2014.01.24.12.07.50;	author henning;	state Exp;
branches;
next	1.866;

1.866
date	2014.01.23.23.51.29;	author henning;	state Exp;
branches;
next	1.865;

1.865
date	2014.01.22.04.33.34;	author henning;	state Exp;
branches;
next	1.864;

1.864
date	2014.01.20.02.57.49;	author henning;	state Exp;
branches;
next	1.863;

1.863
date	2014.01.03.12.48.58;	author pelikan;	state Exp;
branches;
next	1.862;

1.862
date	2013.11.18.20.30.04;	author bluhm;	state Exp;
branches;
next	1.861;

1.861
date	2013.11.16.00.36.01;	author chl;	state Exp;
branches;
next	1.860;

1.860
date	2013.11.15.21.34.51;	author haesbaert;	state Exp;
branches;
next	1.859;

1.859
date	2013.11.15.16.15.41;	author bluhm;	state Exp;
branches;
next	1.858;

1.858
date	2013.11.15.10.18.26;	author haesbaert;	state Exp;
branches;
next	1.857;

1.857
date	2013.10.30.11.35.10;	author mpi;	state Exp;
branches;
next	1.856;

1.856
date	2013.10.30.11.21.26;	author mikeb;	state Exp;
branches;
next	1.855;

1.855
date	2013.10.28.12.09.41;	author mikeb;	state Exp;
branches;
next	1.854;

1.854
date	2013.10.24.11.14.33;	author deraadt;	state Exp;
branches;
next	1.853;

1.853
date	2013.10.23.16.13.54;	author mikeb;	state Exp;
branches;
next	1.852;

1.852
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.851;

1.851
date	2013.10.23.11.06.56;	author mikeb;	state Exp;
branches;
next	1.850;

1.850
date	2013.10.22.15.35.57;	author lteo;	state Exp;
branches;
next	1.849;

1.849
date	2013.10.21.09.39.23;	author henning;	state Exp;
branches;
next	1.848;

1.848
date	2013.10.20.13.42.36;	author henning;	state Exp;
branches;
next	1.847;

1.847
date	2013.10.20.13.21.56;	author claudio;	state Exp;
branches;
next	1.846;

1.846
date	2013.10.20.11.03.00;	author phessler;	state Exp;
branches;
next	1.845;

1.845
date	2013.10.19.10.47.53;	author henning;	state Exp;
branches;
next	1.844;

1.844
date	2013.10.17.16.27.41;	author bluhm;	state Exp;
branches;
next	1.843;

1.843
date	2013.10.12.12.13.10;	author henning;	state Exp;
branches;
next	1.842;

1.842
date	2013.10.11.10.58.42;	author gerhard;	state Exp;
branches;
next	1.841;

1.841
date	2013.10.09.09.32.01;	author camield;	state Exp;
branches;
next	1.840;

1.840
date	2013.09.27.10.20.08;	author bluhm;	state Exp;
branches;
next	1.839;

1.839
date	2013.08.19.09.16.25;	author henning;	state Exp;
branches;
next	1.838;

1.838
date	2013.07.05.13.07.57;	author blambert;	state Exp;
branches;
next	1.837;

1.837
date	2013.06.26.09.12.39;	author henning;	state Exp;
branches;
next	1.836;

1.836
date	2013.06.26.07.53.59;	author blambert;	state Exp;
branches;
next	1.835;

1.835
date	2013.06.17.19.50.06;	author bluhm;	state Exp;
branches;
next	1.834;

1.834
date	2013.06.05.00.56.35;	author henning;	state Exp;
branches;
next	1.833;

1.833
date	2013.06.04.19.07.59;	author henning;	state Exp;
branches;
next	1.832;

1.832
date	2013.06.04.19.03.11;	author henning;	state Exp;
branches;
next	1.831;

1.831
date	2013.06.04.18.58.28;	author henning;	state Exp;
branches;
next	1.830;

1.830
date	2013.06.03.16.57.05;	author bluhm;	state Exp;
branches;
next	1.829;

1.829
date	2013.06.03.16.32.00;	author bluhm;	state Exp;
branches;
next	1.828;

1.828
date	2013.06.03.01.41.04;	author henning;	state Exp;
branches;
next	1.827;

1.827
date	2013.06.02.23.06.36;	author henning;	state Exp;
branches;
next	1.826;

1.826
date	2013.06.01.21.18.02;	author henning;	state Exp;
branches;
next	1.825;

1.825
date	2013.05.14.23.59.26;	author mikeb;	state Exp;
branches;
next	1.824;

1.824
date	2013.05.10.11.36.24;	author mikeb;	state Exp;
branches;
next	1.823;

1.823
date	2013.05.03.15.33.47;	author florian;	state Exp;
branches;
next	1.822;

1.822
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.821;

1.821
date	2013.03.29.13.16.14;	author bluhm;	state Exp;
branches;
next	1.820;

1.820
date	2013.03.28.00.32.11;	author bluhm;	state Exp;
branches;
next	1.819;

1.819
date	2013.03.11.19.48.40;	author sthen;	state Exp;
branches;
next	1.818;

1.818
date	2013.01.20.22.51.16;	author bluhm;	state Exp;
branches;
next	1.817;

1.817
date	2012.11.23.18.35.25;	author mikeb;	state Exp;
branches;
next	1.816;

1.816
date	2012.11.06.12.32.41;	author henning;	state Exp;
branches;
next	1.815;

1.815
date	2012.11.01.07.55.56;	author henning;	state Exp;
branches;
next	1.814;

1.814
date	2012.10.30.12.09.05;	author florian;	state Exp;
branches;
next	1.813;

1.813
date	2012.10.21.13.06.02;	author benno;	state Exp;
branches;
next	1.812;

1.812
date	2012.09.19.12.35.07;	author blambert;	state Exp;
branches;
next	1.811;

1.811
date	2012.09.18.10.11.53;	author henning;	state Exp;
branches;
next	1.810;

1.810
date	2012.08.30.11.43.36;	author mikeb;	state Exp;
branches;
next	1.809;

1.809
date	2012.07.26.12.25.31;	author mikeb;	state Exp;
branches;
next	1.808;

1.808
date	2012.07.10.17.33.48;	author bluhm;	state Exp;
branches;
next	1.807;

1.807
date	2012.07.07.16.24.32;	author henning;	state Exp;
branches;
next	1.806;

1.806
date	2012.06.26.13.14.42;	author mikeb;	state Exp;
branches;
next	1.805;

1.805
date	2012.05.12.13.08.48;	author mpf;	state Exp;
branches;
next	1.804;

1.804
date	2012.04.11.13.29.14;	author naddy;	state Exp;
branches;
next	1.803;

1.803
date	2012.04.03.15.09.03;	author mikeb;	state Exp;
branches;
next	1.802;

1.802
date	2012.02.05.22.38.06;	author mikeb;	state Exp;
branches;
next	1.801;

1.801
date	2012.02.03.01.57.51;	author bluhm;	state Exp;
branches;
next	1.800;

1.800
date	2012.01.28.14.07.02;	author mikeb;	state Exp;
branches;
next	1.799;

1.799
date	2012.01.28.14.00.06;	author mikeb;	state Exp;
branches;
next	1.798;

1.798
date	2012.01.26.20.16.06;	author bluhm;	state Exp;
branches;
next	1.797;

1.797
date	2012.01.26.18.19.59;	author bluhm;	state Exp;
branches;
next	1.796;

1.796
date	2012.01.18.17.21.50;	author chl;	state Exp;
branches;
next	1.795;

1.795
date	2012.01.17.21.12.17;	author bluhm;	state Exp;
branches;
next	1.794;

1.794
date	2012.01.16.16.38.01;	author bluhm;	state Exp;
branches;
next	1.793;

1.793
date	2012.01.15.22.55.35;	author bluhm;	state Exp;
branches;
next	1.792;

1.792
date	2011.12.21.23.00.16;	author mpf;	state Exp;
branches;
next	1.791;

1.791
date	2011.12.19.23.32.36;	author mikeb;	state Exp;
branches;
next	1.790;

1.790
date	2011.12.12.21.30.27;	author mikeb;	state Exp;
branches;
next	1.789;

1.789
date	2011.12.02.03.15.31;	author haesbaert;	state Exp;
branches;
next	1.788;

1.788
date	2011.11.28.01.04.50;	author dlg;	state Exp;
branches;
next	1.787;

1.787
date	2011.11.26.03.28.46;	author mcbride;	state Exp;
branches;
next	1.786;

1.786
date	2011.11.25.12.52.10;	author dlg;	state Exp;
branches;
next	1.785;

1.785
date	2011.10.21.09.21.44;	author mikeb;	state Exp;
branches;
next	1.784;

1.784
date	2011.10.13.18.23.39;	author claudio;	state Exp;
branches;
next	1.783;

1.783
date	2011.10.07.14.24.10;	author henning;	state Exp;
branches;
next	1.782;

1.782
date	2011.09.28.17.15.45;	author bluhm;	state Exp;
branches;
next	1.781;

1.781
date	2011.09.22.14.57.12;	author bluhm;	state Exp;
branches;
next	1.780;

1.780
date	2011.09.21.19.07.30;	author bluhm;	state Exp;
branches;
next	1.779;

1.779
date	2011.09.20.15.17.26;	author bluhm;	state Exp;
branches;
next	1.778;

1.778
date	2011.09.20.10.51.18;	author bluhm;	state Exp;
branches;
next	1.777;

1.777
date	2011.09.19.12.51.52;	author bluhm;	state Exp;
branches;
next	1.776;

1.776
date	2011.09.18.13.50.13;	author bluhm;	state Exp;
branches;
next	1.775;

1.775
date	2011.09.18.10.40.55;	author bluhm;	state Exp;
branches;
next	1.774;

1.774
date	2011.09.17.16.01.55;	author bluhm;	state Exp;
branches;
next	1.773;

1.773
date	2011.09.17.11.34.49;	author henning;	state Exp;
branches;
next	1.772;

1.772
date	2011.09.17.10.12.37;	author bluhm;	state Exp;
branches;
next	1.771;

1.771
date	2011.08.30.00.40.47;	author mikeb;	state Exp;
branches;
next	1.770;

1.770
date	2011.08.03.12.28.40;	author mpf;	state Exp;
branches;
next	1.769;

1.769
date	2011.07.27.00.26.10;	author mcbride;	state Exp;
branches;
next	1.768;

1.768
date	2011.07.24.12.13.10;	author mcbride;	state Exp;
branches;
next	1.767;

1.767
date	2011.07.23.21.17.47;	author bluhm;	state Exp;
branches;
next	1.766;

1.766
date	2011.07.22.14.57.31;	author mcbride;	state Exp;
branches;
next	1.765;

1.765
date	2011.07.22.13.05.29;	author henning;	state Exp;
branches;
next	1.764;

1.764
date	2011.07.09.17.42.19;	author bluhm;	state Exp;
branches;
next	1.763;

1.763
date	2011.07.08.18.50.51;	author henning;	state Exp;
branches;
next	1.762;

1.762
date	2011.07.07.20.46.36;	author bluhm;	state Exp;
branches;
next	1.761;

1.761
date	2011.07.07.00.47.18;	author mcbride;	state Exp;
branches;
next	1.760;

1.760
date	2011.07.05.19.53.43;	author mikeb;	state Exp;
branches;
next	1.759;

1.759
date	2011.07.04.18.12.51;	author bluhm;	state Exp;
branches;
next	1.758;

1.758
date	2011.07.04.16.26.23;	author bluhm;	state Exp;
branches;
next	1.757;

1.757
date	2011.07.04.06.54.49;	author claudio;	state Exp;
branches;
next	1.756;

1.756
date	2011.07.03.23.37.55;	author zinke;	state Exp;
branches;
next	1.755;

1.755
date	2011.07.03.23.33.38;	author bluhm;	state Exp;
branches;
next	1.754;

1.754
date	2011.07.03.18.42.45;	author henning;	state Exp;
branches;
next	1.753;

1.753
date	2011.07.03.18.08.02;	author claudio;	state Exp;
branches;
next	1.752;

1.752
date	2011.07.01.21.00.40;	author bluhm;	state Exp;
branches;
next	1.751;

1.751
date	2011.06.23.19.10.40;	author claudio;	state Exp;
branches;
next	1.750;

1.750
date	2011.06.21.08.59.47;	author bluhm;	state Exp;
branches;
next	1.749;

1.749
date	2011.06.20.19.03.41;	author claudio;	state Exp;
branches;
next	1.748;

1.748
date	2011.06.14.10.14.01;	author mcbride;	state Exp;
branches;
next	1.747;

1.747
date	2011.06.02.22.08.40;	author sthen;	state Exp;
branches;
next	1.746;

1.746
date	2011.05.25.06.48.12;	author claudio;	state Exp;
branches;
next	1.745;

1.745
date	2011.05.24.14.01.51;	author claudio;	state Exp;
branches;
next	1.744;

1.744
date	2011.05.22.13.21.24;	author claudio;	state Exp;
branches;
next	1.743;

1.743
date	2011.05.13.14.31.16;	author oga;	state Exp;
branches;
next	1.742;

1.742
date	2011.04.24.19.36.54;	author bluhm;	state Exp;
branches;
next	1.741;

1.741
date	2011.04.23.10.00.36;	author bluhm;	state Exp;
branches;
next	1.740;

1.740
date	2011.04.12.10.47.29;	author mikeb;	state Exp;
branches;
next	1.739;

1.739
date	2011.04.07.19.35.05;	author miod;	state Exp;
branches;
next	1.738;

1.738
date	2011.04.06.13.18.39;	author claudio;	state Exp;
branches;
next	1.737;

1.737
date	2011.04.05.20.36.59;	author henning;	state Exp;
branches;
next	1.736;

1.736
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.735;

1.735
date	2011.04.05.15.51.41;	author sthen;	state Exp;
branches;
next	1.734;

1.734
date	2011.04.05.13.48.18;	author mikeb;	state Exp;
branches;
next	1.733;

1.733
date	2011.04.04.17.44.43;	author henning;	state Exp;
branches;
next	1.732;

1.732
date	2011.04.04.14.16.48;	author henning;	state Exp;
branches;
next	1.731;

1.731
date	2011.04.04.14.00.16;	author henning;	state Exp;
branches;
next	1.730;

1.730
date	2011.03.24.20.09.44;	author bluhm;	state Exp;
branches;
next	1.729;

1.729
date	2011.03.07.23.30.18;	author bluhm;	state Exp;
branches;
next	1.728;

1.728
date	2011.03.05.01.53.16;	author bluhm;	state Exp;
branches;
next	1.727;

1.727
date	2011.02.23.15.46.14;	author mikeb;	state Exp;
branches;
next	1.726;

1.726
date	2011.02.14.11.01.36;	author sthen;	state Exp;
branches;
next	1.725;

1.725
date	2011.02.06.23.12.12;	author bluhm;	state Exp;
branches;
next	1.724;

1.724
date	2011.02.06.13.08.49;	author bluhm;	state Exp;
branches;
next	1.723;

1.723
date	2011.02.05.17.29.05;	author bluhm;	state Exp;
branches;
next	1.722;

1.722
date	2011.01.22.11.43.57;	author bluhm;	state Exp;
branches;
next	1.721;

1.721
date	2011.01.19.11.39.56;	author bluhm;	state Exp;
branches;
next	1.720;

1.720
date	2011.01.11.13.35.58;	author mcbride;	state Exp;
branches;
next	1.719;

1.719
date	2011.01.10.18.57.59;	author bluhm;	state Exp;
branches;
next	1.718;

1.718
date	2011.01.10.10.26.38;	author mcbride;	state Exp;
branches;
next	1.717;

1.717
date	2011.01.05.17.36.55;	author bluhm;	state Exp;
branches;
next	1.716;

1.716
date	2010.12.31.12.21.36;	author bluhm;	state Exp;
branches;
next	1.715;

1.715
date	2010.12.24.20.12.56;	author henning;	state Exp;
branches;
next	1.714;

1.714
date	2010.12.07.11.39.40;	author jsg;	state Exp;
branches;
next	1.713;

1.713
date	2010.09.24.02.28.10;	author henning;	state Exp;
branches;
next	1.712;

1.712
date	2010.09.24.02.22.37;	author henning;	state Exp;
branches;
next	1.711;

1.711
date	2010.09.24.02.15.00;	author henning;	state Exp;
branches;
next	1.710;

1.710
date	2010.09.24.02.06.47;	author henning;	state Exp;
branches;
next	1.709;

1.709
date	2010.09.24.01.56.12;	author henning;	state Exp;
branches;
next	1.708;

1.708
date	2010.09.24.01.53.22;	author henning;	state Exp;
branches;
next	1.707;

1.707
date	2010.09.24.00.55.48;	author jsg;	state Exp;
branches;
next	1.706;

1.706
date	2010.09.23.14.17.02;	author mcbride;	state Exp;
branches;
next	1.705;

1.705
date	2010.09.22.05.58.29;	author henning;	state Exp;
branches;
next	1.704;

1.704
date	2010.09.22.02.12.36;	author henning;	state Exp;
branches;
next	1.703;

1.703
date	2010.09.21.11.29.12;	author henning;	state Exp;
branches;
next	1.702;

1.702
date	2010.09.21.10.43.41;	author henning;	state Exp;
branches;
next	1.701;

1.701
date	2010.09.21.10.37.33;	author henning;	state Exp;
branches;
next	1.700;

1.700
date	2010.09.21.07.04.24;	author henning;	state Exp;
branches;
next	1.699;

1.699
date	2010.09.21.04.09.33;	author henning;	state Exp;
branches;
next	1.698;

1.698
date	2010.09.21.03.42.17;	author henning;	state Exp;
branches;
next	1.697;

1.697
date	2010.09.21.02.51.35;	author henning;	state Exp;
branches;
next	1.696;

1.696
date	2010.08.05.17.21.19;	author bluhm;	state Exp;
branches
	1.696.2.1;
next	1.695;

1.695
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.694;

1.694
date	2010.07.01.19.45.29;	author henning;	state Exp;
branches;
next	1.693;

1.693
date	2010.06.27.21.58.35;	author henning;	state Exp;
branches;
next	1.692;

1.692
date	2010.06.27.01.39.43;	author henning;	state Exp;
branches;
next	1.691;

1.691
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.690;

1.690
date	2010.02.04.14.10.12;	author sthen;	state Exp;
branches
	1.690.2.1;
next	1.689;

1.689
date	2010.01.18.23.52.46;	author mcbride;	state Exp;
branches;
next	1.688;

1.688
date	2010.01.14.20.43.19;	author mcbride;	state Exp;
branches;
next	1.687;

1.687
date	2010.01.14.01.19.46;	author mcbride;	state Exp;
branches;
next	1.686;

1.686
date	2010.01.14.01.06.14;	author henning;	state Exp;
branches;
next	1.685;

1.685
date	2010.01.14.00.00.05;	author henning;	state Exp;
branches;
next	1.684;

1.684
date	2010.01.13.23.45.14;	author henning;	state Exp;
branches;
next	1.683;

1.683
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.682;

1.682
date	2010.01.11.04.07.07;	author henning;	state Exp;
branches;
next	1.681;

1.681
date	2010.01.11.03.52.03;	author henning;	state Exp;
branches;
next	1.680;

1.680
date	2009.12.24.04.24.19;	author dlg;	state Exp;
branches;
next	1.679;

1.679
date	2009.12.14.12.31.45;	author henning;	state Exp;
branches;
next	1.678;

1.678
date	2009.12.08.08.26.33;	author sthen;	state Exp;
branches;
next	1.677;

1.677
date	2009.11.26.14.34.49;	author dlg;	state Exp;
branches;
next	1.676;

1.676
date	2009.11.23.18.41.21;	author henning;	state Exp;
branches;
next	1.675;

1.675
date	2009.11.23.18.10.43;	author henning;	state Exp;
branches;
next	1.674;

1.674
date	2009.11.23.18.04.10;	author henning;	state Exp;
branches;
next	1.673;

1.673
date	2009.11.23.17.22.11;	author henning;	state Exp;
branches;
next	1.672;

1.672
date	2009.11.23.17.18.05;	author henning;	state Exp;
branches;
next	1.671;

1.671
date	2009.11.23.16.03.10;	author henning;	state Exp;
branches;
next	1.670;

1.670
date	2009.11.22.22.34.50;	author henning;	state Exp;
branches;
next	1.669;

1.669
date	2009.11.21.20.54.27;	author henning;	state Exp;
branches;
next	1.668;

1.668
date	2009.11.05.20.50.14;	author michele;	state Exp;
branches;
next	1.667;

1.667
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.666;

1.666
date	2009.10.29.10.28.27;	author jsg;	state Exp;
branches;
next	1.665;

1.665
date	2009.10.28.20.11.01;	author jsg;	state Exp;
branches;
next	1.664;

1.664
date	2009.10.06.21.21.48;	author claudio;	state Exp;
branches;
next	1.663;

1.663
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.662;

1.662
date	2009.09.16.12.28.19;	author henning;	state Exp;
branches;
next	1.661;

1.661
date	2009.09.16.12.26.55;	author henning;	state Exp;
branches;
next	1.660;

1.660
date	2009.09.08.17.52.17;	author michele;	state Exp;
branches;
next	1.659;

1.659
date	2009.09.08.17.00.41;	author michele;	state Exp;
branches;
next	1.658;

1.658
date	2009.09.01.13.42.00;	author henning;	state Exp;
branches;
next	1.657;

1.657
date	2009.07.28.11.22.33;	author henning;	state Exp;
branches;
next	1.656;

1.656
date	2009.07.28.11.20.09;	author henning;	state Exp;
branches;
next	1.655;

1.655
date	2009.06.26.19.39.49;	author markus;	state Exp;
branches
	1.655.4.1;
next	1.654;

1.654
date	2009.06.22.17.04.02;	author jsing;	state Exp;
branches;
next	1.653;

1.653
date	2009.06.22.16.55.14;	author jsing;	state Exp;
branches;
next	1.652;

1.652
date	2009.06.22.13.55.39;	author jsing;	state Exp;
branches;
next	1.651;

1.651
date	2009.06.08.03.56.14;	author henning;	state Exp;
branches;
next	1.650;

1.650
date	2009.06.08.02.36.06;	author sthen;	state Exp;
branches;
next	1.649;

1.649
date	2009.06.05.00.05.21;	author claudio;	state Exp;
branches;
next	1.648;

1.648
date	2009.05.18.20.37.13;	author bluhm;	state Exp;
branches;
next	1.647;

1.647
date	2009.04.30.12.54.32;	author henning;	state Exp;
branches;
next	1.646;

1.646
date	2009.04.23.02.01.21;	author dlg;	state Exp;
branches;
next	1.645;

1.645
date	2009.04.17.18.37.06;	author henning;	state Exp;
branches;
next	1.644;

1.644
date	2009.04.15.13.10.38;	author henning;	state Exp;
branches;
next	1.643;

1.643
date	2009.04.15.05.14.45;	author david;	state Exp;
branches;
next	1.642;

1.642
date	2009.04.14.19.39.56;	author grange;	state Exp;
branches;
next	1.641;

1.641
date	2009.04.11.23.42.05;	author jsing;	state Exp;
branches;
next	1.640;

1.640
date	2009.04.06.12.05.55;	author henning;	state Exp;
branches;
next	1.639;

1.639
date	2009.03.15.19.40.41;	author miod;	state Exp;
branches;
next	1.638;

1.638
date	2009.03.14.23.44.09;	author mcbride;	state Exp;
branches;
next	1.637;

1.637
date	2009.03.09.13.53.09;	author mcbride;	state Exp;
branches;
next	1.636;

1.636
date	2009.03.07.01.15.41;	author mcbride;	state Exp;
branches;
next	1.635;

1.635
date	2009.03.05.03.09.37;	author mcbride;	state Exp;
branches;
next	1.634;

1.634
date	2009.02.27.12.37.45;	author henning;	state Exp;
branches
	1.634.2.1;
next	1.633;

1.633
date	2009.02.16.00.31.25;	author dlg;	state Exp;
branches;
next	1.632;

1.632
date	2009.01.30.17.27.20;	author naddy;	state Exp;
branches;
next	1.631;

1.631
date	2009.01.30.10.32.26;	author dlg;	state Exp;
branches;
next	1.630;

1.630
date	2009.01.29.15.12.28;	author pyr;	state Exp;
branches;
next	1.629;

1.629
date	2009.01.27.17.33.07;	author mpf;	state Exp;
branches;
next	1.628;

1.628
date	2009.01.16.23.43.01;	author david;	state Exp;
branches;
next	1.627;

1.627
date	2008.11.24.13.22.09;	author mikeb;	state Exp;
branches;
next	1.626;

1.626
date	2008.11.21.18.01.30;	author claudio;	state Exp;
branches;
next	1.625;

1.625
date	2008.10.28.22.57.01;	author mpf;	state Exp;
branches;
next	1.624;

1.624
date	2008.10.23.22.22.43;	author deraadt;	state Exp;
branches;
next	1.623;

1.623
date	2008.10.02.15.12.45;	author jsing;	state Exp;
branches;
next	1.622;

1.622
date	2008.09.28.14.39.55;	author jsing;	state Exp;
branches;
next	1.621;

1.621
date	2008.09.17.20.10.37;	author chl;	state Exp;
branches;
next	1.620;

1.620
date	2008.09.10.09.10.17;	author henning;	state Exp;
branches;
next	1.619;

1.619
date	2008.09.09.13.56.39;	author henning;	state Exp;
branches;
next	1.618;

1.618
date	2008.09.03.12.57.19;	author henning;	state Exp;
branches;
next	1.617;

1.617
date	2008.09.02.17.35.16;	author chl;	state Exp;
branches;
next	1.616;

1.616
date	2008.08.26.12.17.10;	author henning;	state Exp;
branches;
next	1.615;

1.615
date	2008.08.22.00.35.08;	author bluhm;	state Exp;
branches;
next	1.614;

1.614
date	2008.08.02.12.34.37;	author henning;	state Exp;
branches
	1.614.2.1;
next	1.613;

1.613
date	2008.07.22.12.31.35;	author henning;	state Exp;
branches;
next	1.612;

1.612
date	2008.07.21.15.58.59;	author david;	state Exp;
branches;
next	1.611;

1.611
date	2008.07.21.15.56.55;	author david;	state Exp;
branches;
next	1.610;

1.610
date	2008.07.14.13.29.45;	author henning;	state Exp;
branches;
next	1.609;

1.609
date	2008.07.10.07.41.21;	author djm;	state Exp;
branches;
next	1.608;

1.608
date	2008.07.10.05.44.54;	author david;	state Exp;
branches;
next	1.607;

1.607
date	2008.07.05.16.57.50;	author david;	state Exp;
branches;
next	1.606;

1.606
date	2008.07.04.00.56.48;	author henning;	state Exp;
branches;
next	1.605;

1.605
date	2008.07.04.00.09.31;	author henning;	state Exp;
branches;
next	1.604;

1.604
date	2008.07.03.15.46.23;	author henning;	state Exp;
branches;
next	1.603;

1.603
date	2008.07.01.13.07.02;	author mcbride;	state Exp;
branches;
next	1.602;

1.602
date	2008.07.01.12.56.19;	author mcbride;	state Exp;
branches;
next	1.601;

1.601
date	2008.06.29.08.42.15;	author mcbride;	state Exp;
branches;
next	1.600;

1.600
date	2008.06.26.03.56.20;	author mcbride;	state Exp;
branches;
next	1.599;

1.599
date	2008.06.21.02.05.46;	author mcbride;	state Exp;
branches;
next	1.598;

1.598
date	2008.06.16.01.16.04;	author henning;	state Exp;
branches;
next	1.597;

1.597
date	2008.06.12.18.41.41;	author henning;	state Exp;
branches;
next	1.596;

1.596
date	2008.06.11.17.52.37;	author henning;	state Exp;
branches;
next	1.595;

1.595
date	2008.06.11.04.04.19;	author henning;	state Exp;
branches;
next	1.594;

1.594
date	2008.06.11.03.36.33;	author henning;	state Exp;
branches;
next	1.593;

1.593
date	2008.06.11.03.28.10;	author henning;	state Exp;
branches;
next	1.592;

1.592
date	2008.06.11.03.26.03;	author henning;	state Exp;
branches;
next	1.591;

1.591
date	2008.06.11.02.54.05;	author henning;	state Exp;
branches;
next	1.590;

1.590
date	2008.06.11.02.46.34;	author henning;	state Exp;
branches;
next	1.589;

1.589
date	2008.06.10.22.59.13;	author reyk;	state Exp;
branches;
next	1.588;

1.588
date	2008.06.10.22.39.31;	author mcbride;	state Exp;
branches;
next	1.587;

1.587
date	2008.06.10.21.14.39;	author reyk;	state Exp;
branches;
next	1.586;

1.586
date	2008.06.10.20.05.13;	author henning;	state Exp;
branches;
next	1.585;

1.585
date	2008.06.10.19.32.13;	author henning;	state Exp;
branches;
next	1.584;

1.584
date	2008.06.10.04.26.31;	author henning;	state Exp;
branches;
next	1.583;

1.583
date	2008.06.10.04.24.17;	author henning;	state Exp;
branches;
next	1.582;

1.582
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.581;

1.581
date	2008.06.08.21.30.44;	author henning;	state Exp;
branches;
next	1.580;

1.580
date	2008.06.08.17.23.19;	author henning;	state Exp;
branches;
next	1.579;

1.579
date	2008.06.02.11.38.22;	author mcbride;	state Exp;
branches;
next	1.578;

1.578
date	2008.05.30.14.22.48;	author henning;	state Exp;
branches;
next	1.577;

1.577
date	2008.05.29.01.00.53;	author mcbride;	state Exp;
branches;
next	1.576;

1.576
date	2008.05.29.00.28.07;	author henning;	state Exp;
branches;
next	1.575;

1.575
date	2008.05.18.11.54.04;	author mcbride;	state Exp;
branches;
next	1.574;

1.574
date	2008.05.15.19.40.37;	author markus;	state Exp;
branches;
next	1.573;

1.573
date	2008.05.09.02.44.54;	author markus;	state Exp;
branches;
next	1.572;

1.572
date	2008.05.07.07.07.29;	author markus;	state Exp;
branches;
next	1.571;

1.571
date	2008.05.07.06.15.26;	author markus;	state Exp;
branches;
next	1.570;

1.570
date	2008.05.06.09.44.25;	author markus;	state Exp;
branches;
next	1.569;

1.569
date	2008.05.06.03.45.21;	author mpf;	state Exp;
branches;
next	1.568;

1.568
date	2008.05.05.13.00.43;	author henning;	state Exp;
branches;
next	1.567;

1.567
date	2008.02.20.23.40.13;	author henning;	state Exp;
branches
	1.567.2.1;
next	1.566;

1.566
date	2008.02.16.12.22.19;	author markus;	state Exp;
branches;
next	1.565;

1.565
date	2007.11.22.02.01.46;	author henning;	state Exp;
branches;
next	1.564;

1.564
date	2007.11.18.21.53.47;	author deraadt;	state Exp;
branches;
next	1.563;

1.563
date	2007.11.16.14.03.37;	author dhartmei;	state Exp;
branches;
next	1.562;

1.562
date	2007.11.11.23.58.43;	author pascoe;	state Exp;
branches;
next	1.561;

1.561
date	2007.10.31.21.15.27;	author mpf;	state Exp;
branches;
next	1.560;

1.560
date	2007.10.25.21.36.21;	author mpf;	state Exp;
branches;
next	1.559;

1.559
date	2007.09.18.18.45.59;	author markus;	state Exp;
branches;
next	1.558;

1.558
date	2007.09.07.20.34.10;	author bluhm;	state Exp;
branches;
next	1.557;

1.557
date	2007.08.30.13.07.06;	author henning;	state Exp;
branches;
next	1.556;

1.556
date	2007.08.30.10.43.43;	author dhartmei;	state Exp;
branches;
next	1.555;

1.555
date	2007.08.30.09.28.48;	author dhartmei;	state Exp;
branches;
next	1.554;

1.554
date	2007.08.28.16.09.12;	author henning;	state Exp;
branches;
next	1.553;

1.553
date	2007.08.23.11.15.49;	author dhartmei;	state Exp;
branches;
next	1.552;

1.552
date	2007.08.21.15.57.27;	author dhartmei;	state Exp;
branches
	1.552.2.1;
next	1.551;

1.551
date	2007.07.18.15.39.44;	author mpf;	state Exp;
branches;
next	1.550;

1.550
date	2007.07.10.15.58.37;	author kurt;	state Exp;
branches;
next	1.549;

1.549
date	2007.07.04.08.14.14;	author mpf;	state Exp;
branches;
next	1.548;

1.548
date	2007.06.25.13.57.18;	author henning;	state Exp;
branches;
next	1.547;

1.547
date	2007.06.24.11.17.13;	author mcbride;	state Exp;
branches;
next	1.546;

1.546
date	2007.06.21.11.55.54;	author henning;	state Exp;
branches;
next	1.545;

1.545
date	2007.06.20.14.14.17;	author mpf;	state Exp;
branches;
next	1.544;

1.544
date	2007.06.15.08.18.59;	author henning;	state Exp;
branches;
next	1.543;

1.543
date	2007.06.09.18.30.47;	author henning;	state Exp;
branches;
next	1.542;

1.542
date	2007.06.09.16.32.00;	author henning;	state Exp;
branches;
next	1.541;

1.541
date	2007.06.02.01.28.55;	author henning;	state Exp;
branches;
next	1.540;

1.540
date	2007.06.01.18.44.22;	author henning;	state Exp;
branches;
next	1.539;

1.539
date	2007.06.01.18.01.59;	author henning;	state Exp;
branches;
next	1.538;

1.538
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.537;

1.537
date	2007.05.31.18.48.05;	author mcbride;	state Exp;
branches;
next	1.536;

1.536
date	2007.05.31.06.22.40;	author mcbride;	state Exp;
branches;
next	1.535;

1.535
date	2007.05.31.04.11.42;	author mcbride;	state Exp;
branches;
next	1.534;

1.534
date	2007.05.29.00.50.41;	author henning;	state Exp;
branches;
next	1.533;

1.533
date	2007.05.28.17.16.39;	author henning;	state Exp;
branches;
next	1.532;

1.532
date	2007.05.27.21.17.38;	author dlg;	state Exp;
branches;
next	1.531;

1.531
date	2007.05.27.18.30.02;	author pyr;	state Exp;
branches;
next	1.530;

1.530
date	2007.05.26.20.12.02;	author henning;	state Exp;
branches;
next	1.529;

1.529
date	2007.05.08.23.36.25;	author mcbride;	state Exp;
branches;
next	1.528;

1.528
date	2007.05.08.23.31.20;	author mcbride;	state Exp;
branches;
next	1.527;

1.527
date	2007.02.22.15.23.23;	author pyr;	state Exp;
branches;
next	1.526;

1.526
date	2007.02.19.10.18.58;	author pyr;	state Exp;
branches;
next	1.525;

1.525
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.524;

1.524
date	2007.02.08.15.24.24;	author itojun;	state Exp;
branches;
next	1.523;

1.523
date	2006.12.22.13.24.52;	author reyk;	state Exp;
branches;
next	1.522;

1.522
date	2006.12.21.12.26.51;	author dhartmei;	state Exp;
branches;
next	1.521;

1.521
date	2006.12.14.20.40.54;	author dhartmei;	state Exp;
branches;
next	1.520;

1.520
date	2006.12.13.09.01.59;	author itojun;	state Exp;
branches;
next	1.519;

1.519
date	2006.11.16.13.17.15;	author henning;	state Exp;
branches;
next	1.518;

1.518
date	2006.10.31.14.49.01;	author henning;	state Exp;
branches;
next	1.517;

1.517
date	2006.10.27.13.56.51;	author mcbride;	state Exp;
branches;
next	1.516;

1.516
date	2006.10.11.08.42.31;	author mcbride;	state Exp;
branches;
next	1.515;

1.515
date	2006.09.18.09.53.05;	author markus;	state Exp;
branches;
next	1.514;

1.514
date	2006.09.18.07.03.35;	author dhartmei;	state Exp;
branches;
next	1.513;

1.513
date	2006.07.06.13.25.40;	author henning;	state Exp;
branches;
next	1.512;

1.512
date	2006.05.17.14.50.47;	author henning;	state Exp;
branches;
next	1.511;

1.511
date	2006.03.14.11.09.42;	author djm;	state Exp;
branches;
next	1.510;

1.510
date	2006.02.07.18.41.14;	author dhartmei;	state Exp;
branches;
next	1.509;

1.509
date	2006.01.31.03.40.31;	author frantzen;	state Exp;
branches;
next	1.508;

1.508
date	2005.11.14.09.18.55;	author pascoe;	state Exp;
branches;
next	1.507;

1.507
date	2005.11.04.08.24.15;	author mcbride;	state Exp;
branches;
next	1.506;

1.506
date	2005.10.26.03.47.33;	author mcbride;	state Exp;
branches;
next	1.505;

1.505
date	2005.10.25.11.19.35;	author henning;	state Exp;
branches;
next	1.504;

1.504
date	2005.10.17.08.43.35;	author henning;	state Exp;
branches;
next	1.503;

1.503
date	2005.09.28.01.46.32;	author pascoe;	state Exp;
branches;
next	1.502;

1.502
date	2005.08.22.11.54.25;	author dhartmei;	state Exp;
branches
	1.502.2.1;
next	1.501;

1.501
date	2005.08.22.09.48.05;	author dhartmei;	state Exp;
branches;
next	1.500;

1.500
date	2005.08.18.10.28.13;	author pascoe;	state Exp;
branches;
next	1.499;

1.499
date	2005.08.11.05.09.29;	author joel;	state Exp;
branches;
next	1.498;

1.498
date	2005.07.31.05.20.56;	author pascoe;	state Exp;
branches;
next	1.497;

1.497
date	2005.07.31.03.30.55;	author pascoe;	state Exp;
branches;
next	1.496;

1.496
date	2005.07.29.06.26.43;	author pascoe;	state Exp;
branches;
next	1.495;

1.495
date	2005.07.21.08.02.26;	author markus;	state Exp;
branches;
next	1.494;

1.494
date	2005.07.04.08.28.04;	author markus;	state Exp;
branches;
next	1.493;

1.493
date	2005.06.13.20.17.25;	author henning;	state Exp;
branches;
next	1.492;

1.492
date	2005.05.27.17.22.40;	author dhartmei;	state Exp;
branches;
next	1.491;

1.491
date	2005.05.26.15.29.48;	author dhartmei;	state Exp;
branches;
next	1.490;

1.490
date	2005.05.23.23.28.53;	author dhartmei;	state Exp;
branches;
next	1.489;

1.489
date	2005.05.21.21.03.57;	author henning;	state Exp;
branches;
next	1.488;

1.488
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.487;

1.487
date	2005.04.22.09.53.18;	author dhartmei;	state Exp;
branches;
next	1.486;

1.486
date	2005.04.15.12.59.40;	author joel;	state Exp;
branches;
next	1.485;

1.485
date	2005.04.14.08.21.01;	author henning;	state Exp;
branches;
next	1.484;

1.484
date	2005.04.14.02.19.09;	author joel;	state Exp;
branches;
next	1.483;

1.483
date	2005.03.15.17.38.43;	author dhartmei;	state Exp;
branches
	1.483.2.1;
next	1.482;

1.482
date	2005.03.04.11.01.32;	author dhartmei;	state Exp;
branches;
next	1.481;

1.481
date	2005.03.03.07.13.39;	author dhartmei;	state Exp;
branches;
next	1.480;

1.480
date	2005.02.27.15.08.39;	author dhartmei;	state Exp;
branches;
next	1.479;

1.479
date	2005.01.30.00.02.30;	author dhartmei;	state Exp;
branches;
next	1.478;

1.478
date	2005.01.20.18.07.33;	author dhartmei;	state Exp;
branches;
next	1.477;

1.477
date	2005.01.07.18.58.39;	author mcbride;	state Exp;
branches;
next	1.476;

1.476
date	2004.12.22.17.17.55;	author dhartmei;	state Exp;
branches;
next	1.475;

1.475
date	2004.12.17.17.32.28;	author dhartmei;	state Exp;
branches;
next	1.474;

1.474
date	2004.12.14.03.49.06;	author mcbride;	state Exp;
branches;
next	1.473;

1.473
date	2004.12.11.11.45.44;	author mpf;	state Exp;
branches;
next	1.472;

1.472
date	2004.12.10.22.13.25;	author henning;	state Exp;
branches;
next	1.471;

1.471
date	2004.12.07.18.02.03;	author mcbride;	state Exp;
branches;
next	1.470;

1.470
date	2004.12.07.10.33.41;	author dhartmei;	state Exp;
branches;
next	1.469;

1.469
date	2004.12.07.09.36.16;	author deraadt;	state Exp;
branches;
next	1.468;

1.468
date	2004.12.07.05.30.25;	author mcbride;	state Exp;
branches;
next	1.467;

1.467
date	2004.12.06.23.28.38;	author dhartmei;	state Exp;
branches;
next	1.466;

1.466
date	2004.12.05.12.12.01;	author dhartmei;	state Exp;
branches;
next	1.465;

1.465
date	2004.12.04.07.49.48;	author mcbride;	state Exp;
branches;
next	1.464;

1.464
date	2004.11.24.00.36.10;	author dhartmei;	state Exp;
branches;
next	1.463;

1.463
date	2004.11.19.18.20.10;	author dhartmei;	state Exp;
branches;
next	1.462;

1.462
date	2004.11.12.19.44.44;	author dhartmei;	state Exp;
branches;
next	1.461;

1.461
date	2004.11.07.01.16.52;	author dhartmei;	state Exp;
branches;
next	1.460;

1.460
date	2004.09.29.10.32.33;	author dhartmei;	state Exp;
branches;
next	1.459;

1.459
date	2004.09.20.19.56.01;	author henning;	state Exp;
branches;
next	1.458;

1.458
date	2004.09.17.21.49.15;	author mcbride;	state Exp;
branches;
next	1.457;

1.457
date	2004.07.11.15.54.21;	author itojun;	state Exp;
branches
	1.457.2.1;
next	1.456;

1.456
date	2004.06.25.11.04.03;	author itojun;	state Exp;
branches;
next	1.455;

1.455
date	2004.06.25.00.42.58;	author itojun;	state Exp;
branches;
next	1.454;

1.454
date	2004.06.22.07.35.19;	author cedric;	state Exp;
branches;
next	1.453;

1.453
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.452;

1.452
date	2004.06.21.19.26.01;	author mcbride;	state Exp;
branches;
next	1.451;

1.451
date	2004.06.10.14.22.54;	author dhartmei;	state Exp;
branches;
next	1.450;

1.450
date	2004.06.06.16.49.08;	author cedric;	state Exp;
branches;
next	1.449;

1.449
date	2004.05.19.17.50.51;	author dhartmei;	state Exp;
branches;
next	1.448;

1.448
date	2004.05.11.07.34.11;	author dhartmei;	state Exp;
branches;
next	1.447;

1.447
date	2004.05.11.07.06.52;	author dhartmei;	state Exp;
branches;
next	1.446;

1.446
date	2004.05.05.23.16.03;	author frantzen;	state Exp;
branches;
next	1.445;

1.445
date	2004.04.28.02.51.58;	author cedric;	state Exp;
branches;
next	1.444;

1.444
date	2004.04.28.02.43.08;	author pb;	state Exp;
branches;
next	1.443;

1.443
date	2004.04.27.18.28.07;	author frantzen;	state Exp;
branches;
next	1.442;

1.442
date	2004.04.26.02.03.38;	author mcbride;	state Exp;
branches;
next	1.441;

1.441
date	2004.04.26.00.12.27;	author cedric;	state Exp;
branches;
next	1.440;

1.440
date	2004.04.25.18.45.57;	author dhartmei;	state Exp;
branches;
next	1.439;

1.439
date	2004.04.25.18.09.29;	author pb;	state Exp;
branches;
next	1.438;

1.438
date	2004.04.25.02.32.35;	author pb;	state Exp;
branches;
next	1.437;

1.437
date	2004.04.25.00.34.08;	author dhartmei;	state Exp;
branches;
next	1.436;

1.436
date	2004.04.24.23.22.54;	author cedric;	state Exp;
branches;
next	1.435;

1.435
date	2004.04.17.00.13.36;	author henning;	state Exp;
branches;
next	1.434;

1.434
date	2004.04.05.08.19.49;	author dhartmei;	state Exp;
branches;
next	1.433;

1.433
date	2004.03.26.22.20.57;	author dhartmei;	state Exp;
branches
	1.433.2.1;
next	1.432;

1.432
date	2004.03.25.03.03.49;	author mcbride;	state Exp;
branches;
next	1.431;

1.431
date	2004.03.22.04.54.17;	author mcbride;	state Exp;
branches;
next	1.430;

1.430
date	2004.03.11.10.15.26;	author mcbride;	state Exp;
branches;
next	1.429;

1.429
date	2004.03.09.21.44.40;	author mcbride;	state Exp;
branches;
next	1.428;

1.428
date	2004.02.24.12.09.34;	author mcbride;	state Exp;
branches;
next	1.427;

1.427
date	2004.02.24.06.53.30;	author mcbride;	state Exp;
branches;
next	1.426;

1.426
date	2004.02.20.19.22.03;	author mcbride;	state Exp;
branches;
next	1.425;

1.425
date	2004.02.19.07.41.45;	author kjc;	state Exp;
branches;
next	1.424;

1.424
date	2004.02.10.22.42.57;	author dhartmei;	state Exp;
branches;
next	1.423;

1.423
date	2004.02.10.20.20.01;	author itojun;	state Exp;
branches;
next	1.422;

1.422
date	2004.02.10.18.49.10;	author henning;	state Exp;
branches;
next	1.421;

1.421
date	2004.02.04.10.43.18;	author mcbride;	state Exp;
branches;
next	1.420;

1.420
date	2004.02.02.12.47.50;	author cedric;	state Exp;
branches;
next	1.419;

1.419
date	2004.01.27.09.31.15;	author markus;	state Exp;
branches;
next	1.418;

1.418
date	2004.01.06.20.24.33;	author dhartmei;	state Exp;
branches;
next	1.417;

1.417
date	2004.01.05.18.41.47;	author dhartmei;	state Exp;
branches;
next	1.416;

1.416
date	2004.01.04.12.56.33;	author cedric;	state Exp;
branches;
next	1.415;

1.415
date	2003.12.31.22.14.42;	author deraadt;	state Exp;
branches;
next	1.414;

1.414
date	2003.12.31.11.18.25;	author cedric;	state Exp;
branches;
next	1.413;

1.413
date	2003.12.19.16.12.43;	author henning;	state Exp;
branches;
next	1.412;

1.412
date	2003.12.18.16.07.38;	author dhartmei;	state Exp;
branches;
next	1.411;

1.411
date	2003.12.15.09.10.25;	author henning;	state Exp;
branches;
next	1.410;

1.410
date	2003.12.15.07.28.25;	author mcbride;	state Exp;
branches;
next	1.409;

1.409
date	2003.12.15.07.11.30;	author mcbride;	state Exp;
branches;
next	1.408;

1.408
date	2003.12.15.00.02.03;	author mcbride;	state Exp;
branches;
next	1.407;

1.407
date	2003.12.12.20.05.45;	author cedric;	state Exp;
branches;
next	1.406;

1.406
date	2003.12.11.13.13.27;	author cedric;	state Exp;
branches;
next	1.405;

1.405
date	2003.12.08.07.07.35;	author mcbride;	state Exp;
branches;
next	1.404;

1.404
date	2003.11.28.01.06.59;	author mcbride;	state Exp;
branches;
next	1.403;

1.403
date	2003.11.21.01.47.16;	author mcbride;	state Exp;
branches;
next	1.402;

1.402
date	2003.11.21.01.43.43;	author mcbride;	state Exp;
branches;
next	1.401;

1.401
date	2003.11.16.23.23.16;	author mcbride;	state Exp;
branches;
next	1.400;

1.400
date	2003.11.09.11.25.01;	author dhartmei;	state Exp;
branches;
next	1.399;

1.399
date	2003.11.04.21.43.15;	author markus;	state Exp;
branches;
next	1.398;

1.398
date	2003.11.03.07.50.00;	author cedric;	state Exp;
branches;
next	1.397;

1.397
date	2003.10.31.10.34.47;	author mcbride;	state Exp;
branches;
next	1.396;

1.396
date	2003.10.29.15.35.08;	author dhartmei;	state Exp;
branches;
next	1.395;

1.395
date	2003.10.25.20.27.07;	author mcbride;	state Exp;
branches;
next	1.394;

1.394
date	2003.10.10.15.26.40;	author dhartmei;	state Exp;
branches;
next	1.393;

1.393
date	2003.10.02.05.47.30;	author itojun;	state Exp;
branches;
next	1.392;

1.392
date	2003.09.26.21.44.08;	author cedric;	state Exp;
branches;
next	1.391;

1.391
date	2003.09.26.14.48.19;	author mcbride;	state Exp;
branches;
next	1.390;

1.390
date	2003.09.24.17.18.03;	author mcbride;	state Exp;
branches;
next	1.389;

1.389
date	2003.09.01.15.08.39;	author henning;	state Exp;
branches
	1.389.2.1;
next	1.388;

1.388
date	2003.09.01.10.41.38;	author cedric;	state Exp;
branches;
next	1.387;

1.387
date	2003.08.28.09.41.03;	author cedric;	state Exp;
branches;
next	1.386;

1.386
date	2003.08.21.19.12.07;	author frantzen;	state Exp;
branches;
next	1.385;

1.385
date	2003.08.18.11.01.41;	author dhartmei;	state Exp;
branches;
next	1.384;

1.384
date	2003.08.17.15.36.48;	author dhartmei;	state Exp;
branches;
next	1.383;

1.383
date	2003.08.14.19.00.12;	author jason;	state Exp;
branches;
next	1.382;

1.382
date	2003.08.09.14.56.48;	author cedric;	state Exp;
branches;
next	1.381;

1.381
date	2003.08.07.14.20.50;	author henning;	state Exp;
branches;
next	1.380;

1.380
date	2003.07.29.20.56.55;	author dhartmei;	state Exp;
branches;
next	1.379;

1.379
date	2003.07.29.00.51.32;	author cedric;	state Exp;
branches;
next	1.378;

1.378
date	2003.07.19.13.08.58;	author cedric;	state Exp;
branches;
next	1.377;

1.377
date	2003.07.12.09.36.23;	author dhartmei;	state Exp;
branches;
next	1.376;

1.376
date	2003.07.09.22.03.15;	author itojun;	state Exp;
branches;
next	1.375;

1.375
date	2003.07.04.10.57.27;	author markus;	state Exp;
branches;
next	1.374;

1.374
date	2003.07.04.10.39.30;	author henning;	state Exp;
branches;
next	1.373;

1.373
date	2003.07.04.08.24.52;	author markus;	state Exp;
branches;
next	1.372;

1.372
date	2003.06.29.23.37.12;	author itojun;	state Exp;
branches;
next	1.371;

1.371
date	2003.06.29.12.25.03;	author itojun;	state Exp;
branches;
next	1.370;

1.370
date	2003.06.28.00.27.10;	author itojun;	state Exp;
branches;
next	1.369;

1.369
date	2003.06.24.13.55.13;	author henning;	state Exp;
branches;
next	1.368;

1.368
date	2003.06.24.13.52.50;	author henning;	state Exp;
branches;
next	1.367;

1.367
date	2003.06.21.09.07.01;	author djm;	state Exp;
branches;
next	1.366;

1.366
date	2003.06.20.18.24.57;	author dhartmei;	state Exp;
branches;
next	1.365;

1.365
date	2003.06.20.17.38.24;	author dhartmei;	state Exp;
branches;
next	1.364;

1.364
date	2003.06.14.07.23.15;	author dhartmei;	state Exp;
branches;
next	1.363;

1.363
date	2003.06.10.22.05.03;	author dhartmei;	state Exp;
branches;
next	1.362;

1.362
date	2003.06.09.11.14.46;	author mcbride;	state Exp;
branches;
next	1.361;

1.361
date	2003.06.03.12.34.04;	author henning;	state Exp;
branches;
next	1.360;

1.360
date	2003.05.18.19.58.56;	author henning;	state Exp;
branches;
next	1.359;

1.359
date	2003.05.18.18.33.28;	author dhartmei;	state Exp;
branches;
next	1.358;

1.358
date	2003.05.17.21.15.23;	author dhartmei;	state Exp;
branches;
next	1.357;

1.357
date	2003.05.17.03.04.45;	author mcbride;	state Exp;
branches;
next	1.356;

1.356
date	2003.05.17.02.01.20;	author henning;	state Exp;
branches;
next	1.355;

1.355
date	2003.05.17.01.08.50;	author dhartmei;	state Exp;
branches;
next	1.354;

1.354
date	2003.05.16.17.15.17;	author dhartmei;	state Exp;
branches;
next	1.353;

1.353
date	2003.05.14.23.46.45;	author frantzen;	state Exp;
branches;
next	1.352;

1.352
date	2003.05.14.21.50.56;	author henning;	state Exp;
branches;
next	1.351;

1.351
date	2003.05.14.08.42.00;	author canacar;	state Exp;
branches;
next	1.350;

1.350
date	2003.05.14.04.51.10;	author henning;	state Exp;
branches;
next	1.349;

1.349
date	2003.05.13.17.45.23;	author henning;	state Exp;
branches;
next	1.348;

1.348
date	2003.05.12.22.53.47;	author frantzen;	state Exp;
branches;
next	1.347;

1.347
date	2003.05.12.17.49.03;	author mcbride;	state Exp;
branches;
next	1.346;

1.346
date	2003.05.12.01.25.31;	author dhartmei;	state Exp;
branches;
next	1.345;

1.345
date	2003.05.11.20.44.03;	author frantzen;	state Exp;
branches;
next	1.344;

1.344
date	2003.05.11.01.17.15;	author dhartmei;	state Exp;
branches;
next	1.343;

1.343
date	2003.05.10.23.32.48;	author dhartmei;	state Exp;
branches;
next	1.342;

1.342
date	2003.05.10.23.04.31;	author dhartmei;	state Exp;
branches;
next	1.341;

1.341
date	2003.05.10.22.33.33;	author dhartmei;	state Exp;
branches;
next	1.340;

1.340
date	2003.05.06.21.21.23;	author dhartmei;	state Exp;
branches;
next	1.339;

1.339
date	2003.04.30.12.30.27;	author cedric;	state Exp;
branches;
next	1.338;

1.338
date	2003.04.25.17.41.25;	author dhartmei;	state Exp;
branches;
next	1.337;

1.337
date	2003.04.11.14.40.57;	author henning;	state Exp;
branches;
next	1.336;

1.336
date	2003.04.09.18.21.58;	author henning;	state Exp;
branches;
next	1.335;

1.335
date	2003.04.09.15.32.59;	author cedric;	state Exp;
branches;
next	1.334;

1.334
date	2003.04.05.20.24.58;	author cedric;	state Exp;
branches;
next	1.333;

1.333
date	2003.04.05.20.20.58;	author cedric;	state Exp;
branches;
next	1.332;

1.332
date	2003.04.05.20.18.23;	author cedric;	state Exp;
branches;
next	1.331;

1.331
date	2003.04.03.15.27.17;	author cedric;	state Exp;
branches;
next	1.330;

1.330
date	2003.04.03.13.17.24;	author cedric;	state Exp;
branches;
next	1.329;

1.329
date	2003.03.31.13.15.27;	author cedric;	state Exp;
branches;
next	1.328;

1.328
date	2003.03.21.12.47.36;	author cedric;	state Exp;
branches
	1.328.2.1;
next	1.327;

1.327
date	2003.03.09.20.26.12;	author frantzen;	state Exp;
branches;
next	1.326;

1.326
date	2003.03.04.11.23.43;	author pb;	state Exp;
branches;
next	1.325;

1.325
date	2003.03.02.12.00.39;	author dhartmei;	state Exp;
branches;
next	1.324;

1.324
date	2003.02.27.13.35.57;	author henning;	state Exp;
branches;
next	1.323;

1.323
date	2003.02.27.12.56.04;	author cedric;	state Exp;
branches;
next	1.322;

1.322
date	2003.02.25.17.54.06;	author mcbride;	state Exp;
branches;
next	1.321;

1.321
date	2003.02.16.21.30.13;	author deraadt;	state Exp;
branches;
next	1.320;

1.320
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.319;

1.319
date	2003.02.12.12.50.29;	author mcbride;	state Exp;
branches;
next	1.318;

1.318
date	2003.02.12.03.02.23;	author mcbride;	state Exp;
branches;
next	1.317;

1.317
date	2003.02.09.16.21.00;	author dhartmei;	state Exp;
branches;
next	1.316;

1.316
date	2003.02.05.13.07.20;	author mcbride;	state Exp;
branches;
next	1.315;

1.315
date	2003.02.01.15.20.16;	author dhartmei;	state Exp;
branches;
next	1.314;

1.314
date	2003.01.31.19.36.39;	author dhartmei;	state Exp;
branches;
next	1.313;

1.313
date	2003.01.31.19.22.11;	author dhartmei;	state Exp;
branches;
next	1.312;

1.312
date	2003.01.31.19.09.12;	author dhartmei;	state Exp;
branches;
next	1.311;

1.311
date	2003.01.25.22.48.45;	author mcbride;	state Exp;
branches;
next	1.310;

1.310
date	2003.01.24.15.55.36;	author dhartmei;	state Exp;
branches;
next	1.309;

1.309
date	2003.01.24.15.05.31;	author dhartmei;	state Exp;
branches;
next	1.308;

1.308
date	2003.01.24.11.30.00;	author dhartmei;	state Exp;
branches;
next	1.307;

1.307
date	2003.01.23.13.36.17;	author dhartmei;	state Exp;
branches;
next	1.306;

1.306
date	2003.01.21.22.23.49;	author dhartmei;	state Exp;
branches;
next	1.305;

1.305
date	2003.01.19.13.52.18;	author henning;	state Exp;
branches;
next	1.304;

1.304
date	2003.01.18.06.31.59;	author mcbride;	state Exp;
branches;
next	1.303;

1.303
date	2003.01.18.05.07.45;	author mcbride;	state Exp;
branches;
next	1.302;

1.302
date	2003.01.09.15.58.35;	author dhartmei;	state Exp;
branches;
next	1.301;

1.301
date	2003.01.09.10.40.44;	author cedric;	state Exp;
branches;
next	1.300;

1.300
date	2003.01.07.00.21.07;	author dhartmei;	state Exp;
branches;
next	1.299;

1.299
date	2003.01.06.10.08.36;	author deraadt;	state Exp;
branches;
next	1.298;

1.298
date	2003.01.05.22.14.23;	author dhartmei;	state Exp;
branches;
next	1.297;

1.297
date	2003.01.04.17.40.51;	author dhartmei;	state Exp;
branches;
next	1.296;

1.296
date	2003.01.04.16.35.00;	author dhartmei;	state Exp;
branches;
next	1.295;

1.295
date	2003.01.03.19.31.43;	author deraadt;	state Exp;
branches;
next	1.294;

1.294
date	2003.01.02.01.56.56;	author dhartmei;	state Exp;
branches;
next	1.293;

1.293
date	2003.01.01.16.09.29;	author henning;	state Exp;
branches;
next	1.292;

1.292
date	2003.01.01.04.26.19;	author dhartmei;	state Exp;
branches;
next	1.291;

1.291
date	2003.01.01.03.53.22;	author dhartmei;	state Exp;
branches;
next	1.290;

1.290
date	2002.12.31.19.18.41;	author mcbride;	state Exp;
branches;
next	1.289;

1.289
date	2002.12.31.00.00.44;	author dhartmei;	state Exp;
branches;
next	1.288;

1.288
date	2002.12.29.20.07.34;	author cedric;	state Exp;
branches;
next	1.287;

1.287
date	2002.12.27.21.43.58;	author mcbride;	state Exp;
branches;
next	1.286;

1.286
date	2002.12.27.16.55.15;	author dhartmei;	state Exp;
branches;
next	1.285;

1.285
date	2002.12.27.15.20.30;	author dhartmei;	state Exp;
branches;
next	1.284;

1.284
date	2002.12.26.16.21.37;	author mcbride;	state Exp;
branches;
next	1.283;

1.283
date	2002.12.26.15.51.51;	author dhartmei;	state Exp;
branches;
next	1.282;

1.282
date	2002.12.23.13.15.18;	author mcbride;	state Exp;
branches;
next	1.281;

1.281
date	2002.12.22.02.37.58;	author mcbride;	state Exp;
branches;
next	1.280;

1.280
date	2002.12.19.12.46.06;	author dhartmei;	state Exp;
branches;
next	1.279;

1.279
date	2002.12.19.11.05.11;	author dhartmei;	state Exp;
branches;
next	1.278;

1.278
date	2002.12.19.10.49.54;	author dhartmei;	state Exp;
branches;
next	1.277;

1.277
date	2002.12.18.19.40.41;	author dhartmei;	state Exp;
branches;
next	1.276;

1.276
date	2002.12.18.18.35.30;	author dhartmei;	state Exp;
branches;
next	1.275;

1.275
date	2002.12.18.16.59.47;	author henning;	state Exp;
branches;
next	1.274;

1.274
date	2002.12.18.16.28.40;	author dhartmei;	state Exp;
branches;
next	1.273;

1.273
date	2002.12.18.16.03.25;	author henning;	state Exp;
branches;
next	1.272;

1.272
date	2002.12.18.14.41.37;	author mcbride;	state Exp;
branches;
next	1.271;

1.271
date	2002.12.17.12.30.13;	author mcbride;	state Exp;
branches;
next	1.270;

1.270
date	2002.12.13.21.48.30;	author henning;	state Exp;
branches;
next	1.269;

1.269
date	2002.12.06.00.47.32;	author dhartmei;	state Exp;
branches;
next	1.268;

1.268
date	2002.12.03.15.52.33;	author mickey;	state Exp;
branches;
next	1.267;

1.267
date	2002.12.01.19.54.32;	author mcbride;	state Exp;
branches;
next	1.266;

1.266
date	2002.12.01.01.20.02;	author mcbride;	state Exp;
branches;
next	1.265;

1.265
date	2002.11.29.18.25.22;	author mickey;	state Exp;
branches;
next	1.264;

1.264
date	2002.11.28.12.07.37;	author mcbride;	state Exp;
branches;
next	1.263;

1.263
date	2002.11.24.22.45.48;	author mcbride;	state Exp;
branches;
next	1.262;

1.262
date	2002.11.23.09.37.01;	author deraadt;	state Exp;
branches;
next	1.261;

1.261
date	2002.11.23.05.48.01;	author mcbride;	state Exp;
branches;
next	1.260;

1.260
date	2002.11.23.05.16.58;	author mcbride;	state Exp;
branches;
next	1.259;

1.259
date	2002.11.22.09.54.35;	author henning;	state Exp;
branches;
next	1.258;

1.258
date	2002.10.29.19.51.04;	author mickey;	state Exp;
branches;
next	1.257;

1.257
date	2002.10.22.12.23.35;	author mcbride;	state Exp;
branches;
next	1.256;

1.256
date	2002.10.20.13.08.29;	author mcbride;	state Exp;
branches;
next	1.255;

1.255
date	2002.10.14.12.58.27;	author henning;	state Exp;
branches;
next	1.254;

1.254
date	2002.10.08.05.12.08;	author kjc;	state Exp;
branches;
next	1.253;

1.253
date	2002.10.07.14.53.00;	author dhartmei;	state Exp;
branches;
next	1.252;

1.252
date	2002.10.07.13.23.45;	author henning;	state Exp;
branches;
next	1.251;

1.251
date	2002.10.07.13.18.40;	author henning;	state Exp;
branches;
next	1.250;

1.250
date	2002.10.07.13.15.02;	author henning;	state Exp;
branches;
next	1.249;

1.249
date	2002.10.07.12.59.54;	author henning;	state Exp;
branches;
next	1.248;

1.248
date	2002.10.07.12.39.29;	author dhartmei;	state Exp;
branches;
next	1.247;

1.247
date	2002.10.05.21.17.57;	author dhartmei;	state Exp;
branches;
next	1.246;

1.246
date	2002.10.04.17.45.55;	author ish;	state Exp;
branches;
next	1.245;

1.245
date	2002.09.27.17.57.53;	author henning;	state Exp;
branches;
next	1.244;

1.244
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches;
next	1.243;

1.243
date	2002.08.28.15.43.02;	author pefo;	state Exp;
branches;
next	1.242;

1.242
date	2002.08.12.16.41.25;	author dhartmei;	state Exp;
branches;
next	1.241;

1.241
date	2002.08.08.14.31.51;	author dhartmei;	state Exp;
branches;
next	1.240;

1.240
date	2002.07.24.17.56.03;	author dhartmei;	state Exp;
branches;
next	1.239;

1.239
date	2002.07.15.18.07.17;	author henning;	state Exp;
branches;
next	1.238;

1.238
date	2002.07.15.17.52.44;	author henning;	state Exp;
branches;
next	1.237;

1.237
date	2002.07.12.15.52.26;	author art;	state Exp;
branches;
next	1.236;

1.236
date	2002.07.10.22.17.58;	author itojun;	state Exp;
branches;
next	1.235;

1.235
date	2002.06.14.21.35.00;	author todd;	state Exp;
branches;
next	1.234;

1.234
date	2002.06.11.02.42.27;	author frantzen;	state Exp;
branches;
next	1.233;

1.233
date	2002.06.11.02.12.37;	author dhartmei;	state Exp;
branches;
next	1.232;

1.232
date	2002.06.11.02.02.21;	author dhartmei;	state Exp;
branches;
next	1.231;

1.231
date	2002.06.11.01.58.31;	author dhartmei;	state Exp;
branches;
next	1.230;

1.230
date	2002.06.10.19.31.44;	author dhartmei;	state Exp;
branches;
next	1.229;

1.229
date	2002.06.10.17.05.10;	author dhartmei;	state Exp;
branches;
next	1.228;

1.228
date	2002.06.09.20.20.58;	author dhartmei;	state Exp;
branches;
next	1.227;

1.227
date	2002.06.09.10.55.59;	author pb;	state Exp;
branches;
next	1.226;

1.226
date	2002.06.09.10.52.38;	author pb;	state Exp;
branches;
next	1.225;

1.225
date	2002.06.09.08.53.08;	author pb;	state Exp;
branches;
next	1.224;

1.224
date	2002.06.09.04.44.34;	author pb;	state Exp;
branches;
next	1.223;

1.223
date	2002.06.09.03.57.18;	author pb;	state Exp;
branches;
next	1.222;

1.222
date	2002.06.09.01.49.42;	author jasoni;	state Exp;
branches;
next	1.221;

1.221
date	2002.06.09.01.44.31;	author jasoni;	state Exp;
branches;
next	1.220;

1.220
date	2002.06.08.07.58.06;	author dhartmei;	state Exp;
branches;
next	1.219;

1.219
date	2002.06.07.22.53.37;	author pb;	state Exp;
branches;
next	1.218;

1.218
date	2002.06.07.21.46.08;	author jasoni;	state Exp;
branches;
next	1.217;

1.217
date	2002.06.07.21.25.35;	author dhartmei;	state Exp;
branches;
next	1.216;

1.216
date	2002.06.07.21.14.02;	author frantzen;	state Exp;
branches;
next	1.215;

1.215
date	2002.06.07.20.59.20;	author dhartmei;	state Exp;
branches;
next	1.214;

1.214
date	2002.06.07.18.45.59;	author pb;	state Exp;
branches;
next	1.213;

1.213
date	2002.06.01.04.06.47;	author hugh;	state Exp;
branches;
next	1.212;

1.212
date	2002.05.31.20.58.25;	author itojun;	state Exp;
branches;
next	1.211;

1.211
date	2002.05.31.19.45.17;	author deraadt;	state Exp;
branches;
next	1.210;

1.210
date	2002.05.28.17.28.14;	author jasoni;	state Exp;
branches;
next	1.209;

1.209
date	2002.05.19.22.31.28;	author deraadt;	state Exp;
branches;
next	1.208;

1.208
date	2002.05.12.02.21.14;	author itojun;	state Exp;
branches;
next	1.207;

1.207
date	2002.05.12.00.54.56;	author dhartmei;	state Exp;
branches;
next	1.206;

1.206
date	2002.05.09.19.58.42;	author dhartmei;	state Exp;
branches;
next	1.205;

1.205
date	2002.05.05.21.40.22;	author dhartmei;	state Exp;
branches;
next	1.204;

1.204
date	2002.04.24.18.10.25;	author dhartmei;	state Exp;
branches;
next	1.203;

1.203
date	2002.04.23.14.32.22;	author dhartmei;	state Exp;
branches;
next	1.202;

1.202
date	2002.04.20.10.13.57;	author fgsch;	state Exp;
branches;
next	1.201;

1.201
date	2002.04.08.17.49.43;	author jason;	state Exp;
branches
	1.201.2.1;
next	1.200;

1.200
date	2002.03.31.13.02.08;	author dhartmei;	state Exp;
branches;
next	1.199;

1.199
date	2002.03.30.06.21.00;	author dhartmei;	state Exp;
branches;
next	1.198;

1.198
date	2002.03.27.18.16.21;	author mickey;	state Exp;
branches;
next	1.197;

1.197
date	2002.03.26.20.24.51;	author dhartmei;	state Exp;
branches;
next	1.196;

1.196
date	2002.03.25.23.33.13;	author dhartmei;	state Exp;
branches;
next	1.195;

1.195
date	2002.03.25.22.03.01;	author frantzen;	state Exp;
branches;
next	1.194;

1.194
date	2002.03.08.11.32.52;	author mpech;	state Exp;
branches;
next	1.193;

1.193
date	2002.02.26.07.25.33;	author dhartmei;	state Exp;
branches;
next	1.192;

1.192
date	2002.02.23.00.03.58;	author art;	state Exp;
branches;
next	1.191;

1.191
date	2002.02.17.21.48.05;	author dhartmei;	state Exp;
branches;
next	1.190;

1.190
date	2002.02.15.15.42.52;	author art;	state Exp;
branches;
next	1.189;

1.189
date	2002.02.14.19.46.49;	author deraadt;	state Exp;
branches;
next	1.188;

1.188
date	2002.02.14.15.32.11;	author dhartmei;	state Exp;
branches;
next	1.187;

1.187
date	2002.02.11.16.22.48;	author dhartmei;	state Exp;
branches;
next	1.186;

1.186
date	2002.02.11.16.21.26;	author dhartmei;	state Exp;
branches;
next	1.185;

1.185
date	2002.01.23.00.39.48;	author art;	state Exp;
branches;
next	1.184;

1.184
date	2002.01.12.01.34.49;	author jasoni;	state Exp;
branches;
next	1.183;

1.183
date	2002.01.09.11.30.53;	author dhartmei;	state Exp;
branches;
next	1.182;

1.182
date	2002.01.08.09.31.55;	author dhartmei;	state Exp;
branches;
next	1.181;

1.181
date	2001.12.31.16.46.39;	author mickey;	state Exp;
branches;
next	1.180;

1.180
date	2001.12.18.00.14.20;	author jasoni;	state Exp;
branches
	1.180.2.1;
next	1.179;

1.179
date	2001.12.11.03.08.47;	author jasoni;	state Exp;
branches;
next	1.178;

1.178
date	2001.12.10.18.28.32;	author dhartmei;	state Exp;
branches;
next	1.177;

1.177
date	2001.12.10.18.08.11;	author dhartmei;	state Exp;
branches;
next	1.176;

1.176
date	2001.12.03.18.47.46;	author dhartmei;	state Exp;
branches;
next	1.175;

1.175
date	2001.12.01.19.11.41;	author deraadt;	state Exp;
branches;
next	1.174;

1.174
date	2001.11.30.17.01.54;	author jasoni;	state Exp;
branches;
next	1.173;

1.173
date	2001.11.27.20.29.25;	author jasoni;	state Exp;
branches;
next	1.172;

1.172
date	2001.11.27.17.50.36;	author frantzen;	state Exp;
branches;
next	1.171;

1.171
date	2001.11.26.16.50.26;	author jasoni;	state Exp;
branches;
next	1.170;

1.170
date	2001.11.21.19.00.24;	author dhartmei;	state Exp;
branches;
next	1.169;

1.169
date	2001.11.20.09.27.58;	author mpech;	state Exp;
branches;
next	1.168;

1.168
date	2001.11.16.11.07.20;	author mickey;	state Exp;
branches;
next	1.167;

1.167
date	2001.11.14.23.30.36;	author mickey;	state Exp;
branches;
next	1.166;

1.166
date	2001.11.13.17.45.26;	author frantzen;	state Exp;
branches;
next	1.165;

1.165
date	2001.11.06.11.48.29;	author dhartmei;	state Exp;
branches;
next	1.164;

1.164
date	2001.10.24.09.07.38;	author dhartmei;	state Exp;
branches;
next	1.163;

1.163
date	2001.10.15.16.22.21;	author dhartmei;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2001.10.13.23.07.19;	author dhartmei;	state Exp;
branches;
next	1.161;

1.161
date	2001.10.02.08.44.21;	author dhartmei;	state Exp;
branches;
next	1.160;

1.160
date	2001.09.30.03.49.18;	author frantzen;	state Exp;
branches;
next	1.159;

1.159
date	2001.09.27.17.49.12;	author dhartmei;	state Exp;
branches;
next	1.158;

1.158
date	2001.09.27.15.15.17;	author dhartmei;	state Exp;
branches;
next	1.157;

1.157
date	2001.09.27.14.02.44;	author dhartmei;	state Exp;
branches;
next	1.156;

1.156
date	2001.09.23.04.07.07;	author frantzen;	state Exp;
branches;
next	1.155;

1.155
date	2001.09.21.07.18.49;	author dhartmei;	state Exp;
branches;
next	1.154;

1.154
date	2001.09.19.11.09.59;	author dhartmei;	state Exp;
branches;
next	1.153;

1.153
date	2001.09.17.17.16.27;	author dhartmei;	state Exp;
branches;
next	1.152;

1.152
date	2001.09.15.22.25.25;	author dhartmei;	state Exp;
branches;
next	1.151;

1.151
date	2001.09.15.16.47.07;	author dhartmei;	state Exp;
branches;
next	1.150;

1.150
date	2001.09.15.03.54.40;	author frantzen;	state Exp;
branches;
next	1.149;

1.149
date	2001.09.14.20.22.18;	author jasoni;	state Exp;
branches;
next	1.148;

1.148
date	2001.09.11.22.20.48;	author dhartmei;	state Exp;
branches;
next	1.147;

1.147
date	2001.09.06.18.05.46;	author jasoni;	state Exp;
branches;
next	1.146;

1.146
date	2001.09.05.19.12.59;	author dhartmei;	state Exp;
branches;
next	1.145;

1.145
date	2001.09.05.12.42.31;	author dhartmei;	state Exp;
branches;
next	1.144;

1.144
date	2001.09.04.12.32.53;	author dhartmei;	state Exp;
branches;
next	1.143;

1.143
date	2001.09.04.08.55.37;	author dhartmei;	state Exp;
branches;
next	1.142;

1.142
date	2001.08.31.23.05.22;	author frantzen;	state Exp;
branches;
next	1.141;

1.141
date	2001.08.28.08.12.17;	author dhartmei;	state Exp;
branches;
next	1.140;

1.140
date	2001.08.28.00.02.43;	author frantzen;	state Exp;
branches;
next	1.139;

1.139
date	2001.08.26.23.23.03;	author niklas;	state Exp;
branches;
next	1.138;

1.138
date	2001.08.25.21.54.25;	author frantzen;	state Exp;
branches;
next	1.137;

1.137
date	2001.08.22.03.02.25;	author frantzen;	state Exp;
branches;
next	1.136;

1.136
date	2001.08.22.00.26.10;	author frantzen;	state Exp;
branches;
next	1.135;

1.135
date	2001.08.21.17.25.59;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2001.08.21.01.54.17;	author frantzen;	state Exp;
branches;
next	1.133;

1.133
date	2001.08.19.20.25.22;	author dhartmei;	state Exp;
branches;
next	1.132;

1.132
date	2001.08.19.20.00.39;	author frantzen;	state Exp;
branches;
next	1.131;

1.131
date	2001.08.19.19.46.08;	author dhartmei;	state Exp;
branches;
next	1.130;

1.130
date	2001.08.19.19.08.35;	author frantzen;	state Exp;
branches;
next	1.129;

1.129
date	2001.08.19.19.03.58;	author dhartmei;	state Exp;
branches;
next	1.128;

1.128
date	2001.08.19.18.19.08;	author dhartmei;	state Exp;
branches;
next	1.127;

1.127
date	2001.08.19.17.03.00;	author frantzen;	state Exp;
branches;
next	1.126;

1.126
date	2001.08.19.01.53.26;	author frantzen;	state Exp;
branches;
next	1.125;

1.125
date	2001.08.18.22.26.08;	author dhartmei;	state Exp;
branches;
next	1.124;

1.124
date	2001.08.18.21.09.13;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	2001.08.11.12.05.00;	author dhartmei;	state Exp;
branches;
next	1.122;

1.122
date	2001.08.01.23.07.36;	author provos;	state Exp;
branches;
next	1.121;

1.121
date	2001.07.30.23.00.37;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2001.07.29.12.53.17;	author dhartmei;	state Exp;
branches;
next	1.119;

1.119
date	2001.07.25.12.22.28;	author dhartmei;	state Exp;
branches;
next	1.118;

1.118
date	2001.07.21.23.26.41;	author dhartmei;	state Exp;
branches;
next	1.117;

1.117
date	2001.07.19.00.07.36;	author krw;	state Exp;
branches;
next	1.116;

1.116
date	2001.07.18.22.24.07;	author dhartmei;	state Exp;
branches;
next	1.115;

1.115
date	2001.07.17.21.54.25;	author provos;	state Exp;
branches;
next	1.114;

1.114
date	2001.07.17.20.34.51;	author provos;	state Exp;
branches;
next	1.113;

1.113
date	2001.07.15.23.05.04;	author dhartmei;	state Exp;
branches;
next	1.112;

1.112
date	2001.07.14.10.36.53;	author dhartmei;	state Exp;
branches;
next	1.111;

1.111
date	2001.07.13.23.44.08;	author fgsch;	state Exp;
branches;
next	1.110;

1.110
date	2001.07.13.01.52.10;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2001.07.11.16.14.15;	author dhartmei;	state Exp;
branches;
next	1.108;

1.108
date	2001.07.09.23.15.27;	author dhartmei;	state Exp;
branches;
next	1.107;

1.107
date	2001.07.09.10.30.57;	author dhartmei;	state Exp;
branches;
next	1.106;

1.106
date	2001.07.07.01.56.09;	author marc;	state Exp;
branches;
next	1.105;

1.105
date	2001.07.06.23.01.30;	author dhartmei;	state Exp;
branches;
next	1.104;

1.104
date	2001.07.06.22.45.32;	author dhartmei;	state Exp;
branches;
next	1.103;

1.103
date	2001.07.06.22.22.45;	author chris;	state Exp;
branches;
next	1.102;

1.102
date	2001.07.06.22.09.00;	author dhartmei;	state Exp;
branches;
next	1.101;

1.101
date	2001.07.06.21.19.55;	author chris;	state Exp;
branches;
next	1.100;

1.100
date	2001.07.06.17.40.34;	author provos;	state Exp;
branches;
next	1.99;

1.99
date	2001.07.05.21.39.29;	author provos;	state Exp;
branches;
next	1.98;

1.98
date	2001.07.04.20.00.38;	author dhartmei;	state Exp;
branches;
next	1.97;

1.97
date	2001.07.03.04.20.47;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2001.07.03.03.34.41;	author beck;	state Exp;
branches;
next	1.95;

1.95
date	2001.07.02.19.19.49;	author provos;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2001.07.02.19.18.40;	author provos;	state Exp;
branches;
next	1.93;

1.93
date	2001.07.01.23.31.31;	author dugsong;	state Exp;
branches;
next	1.92;

1.92
date	2001.07.01.23.04.44;	author dhartmei;	state Exp;
branches;
next	1.91;

1.91
date	2001.07.01.17.16.03;	author kjell;	state Exp;
branches;
next	1.90;

1.90
date	2001.07.01.11.22.45;	author dhartmei;	state Exp;
branches;
next	1.89;

1.89
date	2001.06.29.16.48.02;	author niklas;	state Exp;
branches;
next	1.88;

1.88
date	2001.06.29.12.57.02;	author provos;	state Exp;
branches;
next	1.87;

1.87
date	2001.06.28.22.49.49;	author provos;	state Exp;
branches;
next	1.86;

1.86
date	2001.06.28.22.38.16;	author dhartmei;	state Exp;
branches;
next	1.85;

1.85
date	2001.06.28.22.36.09;	author dugsong;	state Exp;
branches;
next	1.84;

1.84
date	2001.06.28.22.17.42;	author provos;	state Exp;
branches;
next	1.83;

1.83
date	2001.06.28.21.53.41;	author provos;	state Exp;
branches;
next	1.82;

1.82
date	2001.06.28.10.04.19;	author hugh;	state Exp;
branches;
next	1.81;

1.81
date	2001.06.27.22.41.25;	author dhartmei;	state Exp;
branches;
next	1.80;

1.80
date	2001.06.27.22.05.20;	author jasoni;	state Exp;
branches;
next	1.79;

1.79
date	2001.06.27.21.34.57;	author dhartmei;	state Exp;
branches;
next	1.78;

1.78
date	2001.06.27.16.07.16;	author provos;	state Exp;
branches;
next	1.77;

1.77
date	2001.06.27.10.31.51;	author kjell;	state Exp;
branches;
next	1.76;

1.76
date	2001.06.27.10.27.43;	author kjell;	state Exp;
branches;
next	1.75;

1.75
date	2001.06.27.04.24.43;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2001.06.27.04.01.56;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2001.06.27.03.47.01;	author dugsong;	state Exp;
branches;
next	1.72;

1.72
date	2001.06.27.03.39.11;	author provos;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.27.03.24.23;	author dugsong;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.27.02.13.43;	author provos;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.27.02.10.17;	author provos;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.27.01.57.17;	author provos;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.27.01.55.54;	author provos;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.26.23.26.24;	author provos;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.26.22.56.02;	author dugsong;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.26.22.26.12;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.26.21.47.40;	author dhartmei;	state Exp;
branches;
next	1.62;

1.62
date	2001.06.26.20.56.36;	author provos;	state Exp;
branches;
next	1.61;

1.61
date	2001.06.26.20.50.26;	author dhartmei;	state Exp;
branches;
next	1.60;

1.60
date	2001.06.26.20.06.36;	author provos;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.26.19.51.04;	author provos;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.26.19.43.14;	author dhartmei;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.26.19.09.43;	author provos;	state Exp;
branches;
next	1.56;

1.56
date	2001.06.26.19.01.55;	author provos;	state Exp;
branches;
next	1.55;

1.55
date	2001.06.26.18.17.53;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.26.17.45.57;	author provos;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.26.15.58.42;	author provos;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.26.15.35.41;	author provos;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.26.15.33.00;	author provos;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.26.12.27.16;	author wilfried;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.26.11.17.31;	author dhartmei;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.26.06.58.28;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.26.05.03.36;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.26.05.02.11;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.26.04.57.34;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.26.04.24.45;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.26.04.17.11;	author frantzen;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.26.04.02.50;	author provos;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.26.04.00.29;	author provos;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.26.00.11.00;	author dhartmei;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.25.23.02.20;	author provos;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.25.22.53.39;	author dhartmei;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.25.22.08.03;	author dhartmei;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.25.20.48.17;	author provos;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.25.19.53.37;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.25.19.22.26;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.25.17.17.04;	author dhartmei;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.25.16.53.20;	author jasoni;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.25.10.07.14;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.25.09.57.08;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.25.09.46.20;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.25.09.35.52;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.25.09.31.07;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.25.09.23.30;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.25.08.58.21;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.25.08.42.08;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.25.08.39.48;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.25.05.28.03;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.25.01.52.55;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.25.01.00.35;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.25.00.14.57;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.25.00.02.54;	author dhartmei;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.24.23.56.32;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.24.23.50.11;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.24.23.48.53;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.24.23.43.59;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.24.23.29.14;	author dhartmei;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.24.23.26.14;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.24.23.10.23;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.24.22.42.18;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.24.22.12.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.24.21.50.29;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.24.21.29.29;	author dhartmei;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.24.21.16.02;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.24.21.10.24;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.24.20.54.55;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.24.20.49.40;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.24.20.47.37;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.24.19.48.58;	author kjell;	state Exp;
branches;
next	;

1.95.2.1
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.95.2.2;

1.95.2.2
date	2001.11.13.22.59.58;	author niklas;	state Exp;
branches;
next	1.95.2.3;

1.95.2.3
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.95.2.4;

1.95.2.4
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.95.2.5;

1.95.2.5
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.95.2.6;

1.95.2.6
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.95.2.7;

1.95.2.7
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.95.2.8;

1.95.2.8
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.95.2.9;

1.95.2.9
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.95.2.10;

1.95.2.10
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.95.2.11;

1.95.2.11
date	2004.06.05.23.11.24;	author niklas;	state Exp;
branches;
next	1.95.2.12;

1.95.2.12
date	2004.06.07.20.41.36;	author niklas;	state Exp;
branches;
next	1.95.2.13;

1.95.2.13
date	2004.06.13.08.50.16;	author niklas;	state Exp;
branches;
next	;

1.163.2.1
date	2001.11.13.18.45.11;	author jason;	state Exp;
branches;
next	1.163.2.2;

1.163.2.2
date	2001.12.05.19.47.39;	author jason;	state Exp;
branches;
next	1.163.2.3;

1.163.2.3
date	2001.12.13.19.52.37;	author jason;	state Exp;
branches;
next	1.163.2.4;

1.163.2.4
date	2002.02.21.04.23.24;	author jason;	state Exp;
branches;
next	1.163.2.5;

1.163.2.5
date	2002.09.30.18.11.13;	author miod;	state Exp;
branches;
next	;

1.180.2.1
date	2002.01.31.22.55.44;	author niklas;	state Exp;
branches;
next	1.180.2.2;

1.180.2.2
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.180.2.3;

1.180.2.3
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.180.2.4;

1.180.2.4
date	2003.05.19.22.29.34;	author tedu;	state Exp;
branches;
next	;

1.201.2.1
date	2002.09.30.18.30.51;	author jason;	state Exp;
branches;
next	;

1.328.2.1
date	2003.05.31.00.57.50;	author margarida;	state Exp;
branches;
next	1.328.2.2;

1.328.2.2
date	2003.06.15.20.35.45;	author brad;	state Exp;
branches;
next	1.328.2.3;

1.328.2.3
date	2003.07.10.22.34.28;	author brad;	state Exp;
branches;
next	1.328.2.4;

1.328.2.4
date	2003.08.09.18.23.10;	author brad;	state Exp;
branches;
next	1.328.2.5;

1.328.2.5
date	2003.10.31.06.36.16;	author brad;	state Exp;
branches;
next	1.328.2.6;

1.328.2.6
date	2004.03.14.00.15.05;	author brad;	state Exp;
branches;
next	;

1.389.2.1
date	2003.10.31.06.06.29;	author brad;	state Exp;
branches;
next	1.389.2.2;

1.389.2.2
date	2004.03.14.00.13.42;	author brad;	state Exp;
branches;
next	1.389.2.3;

1.389.2.3
date	2004.04.10.09.38.19;	author brad;	state Exp;
branches;
next	1.389.2.4;

1.389.2.4
date	2004.04.30.23.27.57;	author brad;	state Exp;
branches;
next	1.389.2.5;

1.389.2.5
date	2004.07.17.03.32.12;	author brad;	state Exp;
branches;
next	;

1.433.2.1
date	2004.04.30.21.46.33;	author brad;	state Exp;
branches;
next	1.433.2.2;

1.433.2.2
date	2004.07.17.03.22.34;	author brad;	state Exp;
branches;
next	1.433.2.3;

1.433.2.3
date	2004.11.13.23.24.37;	author brad;	state Exp;
branches;
next	1.433.2.4;

1.433.2.4
date	2004.11.28.19.55.33;	author brad;	state Exp;
branches;
next	1.433.2.5;

1.433.2.5
date	2004.12.16.02.05.39;	author brad;	state Exp;
branches;
next	1.433.2.6;

1.433.2.6
date	2004.12.19.18.52.27;	author brad;	state Exp;
branches;
next	1.433.2.7;

1.433.2.7
date	2005.01.06.14.15.43;	author brad;	state Exp;
branches;
next	1.433.2.8;

1.433.2.8
date	2005.02.19.22.47.44;	author brad;	state Exp;
branches;
next	;

1.457.2.1
date	2004.11.06.00.39.35;	author brad;	state Exp;
branches;
next	1.457.2.2;

1.457.2.2
date	2004.11.13.23.46.26;	author brad;	state Exp;
branches;
next	1.457.2.3;

1.457.2.3
date	2004.11.13.23.48.51;	author brad;	state Exp;
branches;
next	1.457.2.4;

1.457.2.4
date	2004.11.28.06.21.44;	author brad;	state Exp;
branches;
next	1.457.2.5;

1.457.2.5
date	2004.12.16.02.04.55;	author brad;	state Exp;
branches;
next	1.457.2.6;

1.457.2.6
date	2004.12.19.18.48.57;	author brad;	state Exp;
branches;
next	1.457.2.7;

1.457.2.7
date	2005.01.06.14.11.56;	author brad;	state Exp;
branches;
next	1.457.2.8;

1.457.2.8
date	2005.02.19.22.38.33;	author brad;	state Exp;
branches;
next	;

1.483.2.1
date	2005.10.07.19.56.14;	author brad;	state Exp;
branches;
next	;

1.502.2.1
date	2006.05.02.22.55.52;	author brad;	state Exp;
branches;
next	;

1.552.2.1
date	2007.11.27.16.37.57;	author henning;	state Exp;
branches;
next	;

1.567.2.1
date	2009.04.11.23.43.23;	author sthen;	state Exp;
branches;
next	;

1.614.2.1
date	2009.04.11.23.43.32;	author sthen;	state Exp;
branches;
next	;

1.634.2.1
date	2009.04.11.23.43.40;	author sthen;	state Exp;
branches;
next	;

1.655.4.1
date	2009.08.06.11.15.18;	author henning;	state Exp;
branches;
next	;

1.690.2.1
date	2011.02.16.19.13.44;	author sthen;	state Exp;
branches;
next	;

1.696.2.1
date	2011.02.16.19.13.21;	author sthen;	state Exp;
branches;
next	;

1.868.4.1
date	2015.01.03.00.37.05;	author brad;	state Exp;
branches;
next	1.868.4.2;
commitid	7PCDrsJlkNKhX7Wd;

1.868.4.2
date	2015.01.03.00.42.15;	author brad;	state Exp;
branches;
next	;
commitid	6JxoWiDHpPBf419J;

1.883.4.1
date	2015.01.03.00.30.23;	author brad;	state Exp;
branches;
next	;
commitid	vfFVsLXr0lx6v3cW;

1.965.2.1
date	2017.03.09.17.44.29;	author benno;	state Exp;
branches;
next	;
commitid	kS8ERFZ4hzJJ796y;

1.979.4.1
date	2017.03.09.17.43.50;	author benno;	state Exp;
branches;
next	;
commitid	H3dbBIhN5kAKtMNo;

1.1019.4.1
date	2017.05.06.22.46.19;	author mikeb;	state Exp;
branches;
next	;
commitid	LleOieqsYAlvsSt8;


desc
@@


1.1030
log
@Limit the nested header chain for IPv6 extensions headers and for
authentication headers in the IPv4 case.  This prevents spending
excessive cpu time on crafted packets.
OK henning@@
@
text
@/*	$OpenBSD: pf.c,v 1.1029 2017/05/28 16:43:45 bluhm Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002 - 2013 Henning Brauer <henning@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include "bpfilter.h"
#include "carp.h"
#include "pflog.h"
#include "pfsync.h"
#include "pflow.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/filio.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/kernel.h>
#include <sys/time.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/rwlock.h>
#include <sys/syslog.h>

#include <crypto/sha2.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcp_fsm.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/ip_divert.h>

#ifdef INET6
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
#include <netinet6/nd6.h>
#include <netinet6/ip6_divert.h>
#endif /* INET6 */

#include <net/pfvar.h>
#include <net/pfvar_priv.h>

#if NPFLOG > 0
#include <net/if_pflog.h>
#endif	/* NPFLOG > 0 */

#if NPFLOW > 0
#include <net/if_pflow.h>
#endif	/* NPFLOW > 0 */

#if NPFSYNC > 0
#include <net/if_pfsync.h>
#endif /* NPFSYNC > 0 */

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_interface.h>
#endif

/*
 * Global variables
 */
struct pf_state_tree	 pf_statetbl;
struct pf_queuehead	 pf_queues[2];
struct pf_queuehead	*pf_queues_active;
struct pf_queuehead	*pf_queues_inactive;

struct pf_status	 pf_status;

int			 pf_hdr_limit = 20;  /* arbitrary limit, tune in ddb */

SHA2_CTX		 pf_tcp_secret_ctx;
u_char			 pf_tcp_secret[16];
int			 pf_tcp_secret_init;
int			 pf_tcp_iss_off;

enum pf_test_status {
	PF_TEST_FAIL = -1,
	PF_TEST_OK,
	PF_TEST_QUICK
};

struct pf_test_ctx {
	enum pf_test_status	  test_status;
	struct pf_pdesc		 *pd;
	struct pf_rule_actions	  act;
	u_int8_t		  icmpcode;
	u_int8_t		  icmptype;
	int			  icmp_dir;
	int			  state_icmp;
	int			  tag;
	u_short			  reason;
	struct pf_rule_item	 *ri;
	struct pf_src_node	 *sns[PF_SN_MAX];
	struct pf_rule_slist	  rules;
	struct pf_rule		 *nr;
	struct pf_rule		**rm;
	struct pf_rule		 *a;
	struct pf_rule		**am;
	struct pf_ruleset	**rsm;
	struct pf_ruleset	 *arsm;
	struct pf_ruleset	 *aruleset;
	struct tcphdr		 *th;
	int			  depth;
};

#define	PF_ANCHOR_STACK_MAX	64

struct pool		 pf_src_tree_pl, pf_rule_pl, pf_queue_pl;
struct pool		 pf_state_pl, pf_state_key_pl, pf_state_item_pl;
struct pool		 pf_rule_item_pl, pf_sn_item_pl;

void			 pf_init_threshold(struct pf_threshold *, u_int32_t,
			    u_int32_t);
void			 pf_add_threshold(struct pf_threshold *);
int			 pf_check_threshold(struct pf_threshold *);
int			 pf_check_tcp_cksum(struct mbuf *, int, int,
			    sa_family_t);
static __inline void	 pf_cksum_fixup(u_int16_t *, u_int16_t, u_int16_t,
			    u_int8_t);
void			 pf_cksum_fixup_a(u_int16_t *, const struct pf_addr *,
			    const struct pf_addr *, sa_family_t, u_int8_t);
int			 pf_modulate_sack(struct pf_pdesc *,
			    struct pf_state_peer *);
int			 pf_icmp_mapping(struct pf_pdesc *, u_int8_t, int *,
			    u_int16_t *, u_int16_t *);
int			 pf_change_icmp_af(struct mbuf *, int,
			    struct pf_pdesc *, struct pf_pdesc *,
			    struct pf_addr *, struct pf_addr *, sa_family_t,
			    sa_family_t);
int			 pf_translate_a(struct pf_pdesc *, struct pf_addr *,
			    struct pf_addr *);
void			 pf_translate_icmp(struct pf_pdesc *, struct pf_addr *,
			    u_int16_t *, struct pf_addr *, struct pf_addr *,
			    u_int16_t);
int			 pf_translate_icmp_af(struct pf_pdesc*, int, void *);
void			 pf_send_icmp(struct mbuf *, u_int8_t, u_int8_t,
			    sa_family_t, struct pf_rule *, u_int);
void			 pf_detach_state(struct pf_state *);
void			 pf_state_key_detach(struct pf_state *, int);
u_int32_t		 pf_tcp_iss(struct pf_pdesc *);
void			 pf_rule_to_actions(struct pf_rule *,
			    struct pf_rule_actions *);
int			 pf_test_rule(struct pf_pdesc *, struct pf_rule **,
			    struct pf_state **, struct pf_rule **,
			    struct pf_ruleset **, u_short *);
static __inline int	 pf_create_state(struct pf_pdesc *, struct pf_rule *,
			    struct pf_rule *, struct pf_rule *,
			    struct pf_state_key **, struct pf_state_key **,
			    int *, struct pf_state **, int,
			    struct pf_rule_slist *, struct pf_rule_actions *,
			    struct pf_src_node *[]);
static __inline int	 pf_state_key_addr_setup(struct pf_pdesc *, void *,
			    int, struct pf_addr *, int, struct pf_addr *,
			    int, int);
int			 pf_state_key_setup(struct pf_pdesc *, struct
			    pf_state_key **, struct pf_state_key **, int);
int			 pf_tcp_track_full(struct pf_pdesc *,
			    struct pf_state_peer *, struct pf_state_peer *,
			    struct pf_state **, u_short *, int *);
int			 pf_tcp_track_sloppy(struct pf_pdesc *,
			    struct pf_state_peer *, struct pf_state_peer *,
			    struct pf_state **, u_short *);
static __inline int	 pf_synproxy(struct pf_pdesc *, struct pf_state **,
			    u_short *);
int			 pf_test_state(struct pf_pdesc *, struct pf_state **,
			    u_short *);
int			 pf_icmp_state_lookup(struct pf_pdesc *,
			    struct pf_state_key_cmp *, struct pf_state **,
			    u_int16_t, u_int16_t, int, int *, int, int);
int			 pf_test_state_icmp(struct pf_pdesc *,
			    struct pf_state **, u_short *);
u_int8_t		 pf_get_wscale(struct pf_pdesc *);
u_int16_t		 pf_get_mss(struct pf_pdesc *);
u_int16_t		 pf_calc_mss(struct pf_addr *, sa_family_t, int,
			    u_int16_t);
static __inline int	 pf_set_rt_ifp(struct pf_state *, struct pf_addr *,
			    sa_family_t);
struct pf_divert	*pf_get_divert(struct mbuf *);
int			 pf_walk_header(struct pf_pdesc *, struct ip *,
			    u_short *);
int			 pf_walk_option6(struct pf_pdesc *, struct ip6_hdr *,
			    int, int, u_short *);
int			 pf_walk_header6(struct pf_pdesc *, struct ip6_hdr *,
			    u_short *);
void			 pf_print_state_parts(struct pf_state *,
			    struct pf_state_key *, struct pf_state_key *);
int			 pf_addr_wrap_neq(struct pf_addr_wrap *,
			    struct pf_addr_wrap *);
int			 pf_compare_state_keys(struct pf_state_key *,
			    struct pf_state_key *, struct pfi_kif *, u_int);
struct pf_state		*pf_find_state(struct pfi_kif *,
			    struct pf_state_key_cmp *, u_int, struct mbuf *);
int			 pf_src_connlimit(struct pf_state **);
int			 pf_match_rcvif(struct mbuf *, struct pf_rule *);
int			 pf_step_into_anchor(struct pf_test_ctx *,
			    struct pf_rule *);
int			 pf_match_rule(struct pf_test_ctx *,
			    struct pf_ruleset *);
void			 pf_counters_inc(int, struct pf_pdesc *,
			    struct pf_state *, struct pf_rule *,
			    struct pf_rule *);
void			 pf_state_key_link(struct pf_state_key *,
			    struct pf_state_key *);
void			 pf_inpcb_unlink_state_key(struct inpcb *);
void			 pf_state_key_unlink_reverse(struct pf_state_key *);

#if NPFLOG > 0
void			 pf_log_matches(struct pf_pdesc *, struct pf_rule *,
			    struct pf_rule *, struct pf_ruleset *,
			    struct pf_rule_slist *);
#endif	/* NPFLOG > 0 */

extern struct pool pfr_ktable_pl;
extern struct pool pfr_kentry_pl;

struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] = {
	{ &pf_state_pl, PFSTATE_HIWAT, PFSTATE_HIWAT },
	{ &pf_src_tree_pl, PFSNODE_HIWAT, PFSNODE_HIWAT },
	{ &pf_frent_pl, PFFRAG_FRENT_HIWAT, PFFRAG_FRENT_HIWAT },
	{ &pfr_ktable_pl, PFR_KTABLE_HIWAT, PFR_KTABLE_HIWAT },
	{ &pfr_kentry_pl, PFR_KENTRY_HIWAT, PFR_KENTRY_HIWAT }
};

#define STATE_LOOKUP(i, k, d, s, m)					\
	do {								\
		s = pf_find_state(i, k, d, m);				\
		if (s == NULL || (s)->timeout == PFTM_PURGE)		\
			return (PF_DROP);				\
		if (d == PF_OUT &&					\
		    (((s)->rule.ptr->rt == PF_ROUTETO &&		\
		    (s)->rule.ptr->direction == PF_OUT) ||		\
		    ((s)->rule.ptr->rt == PF_REPLYTO &&			\
		    (s)->rule.ptr->direction == PF_IN)) &&		\
		    (s)->rt_kif != NULL &&				\
		    (s)->rt_kif != i)					\
			return (PF_PASS);				\
	} while (0)

#define BOUND_IFACE(r, k) \
	((r)->rule_flag & PFRULE_IFBOUND) ? (k) : pfi_all

#define STATE_INC_COUNTERS(s)					\
	do {							\
		struct pf_rule_item *mrm;			\
		s->rule.ptr->states_cur++;			\
		s->rule.ptr->states_tot++;			\
		if (s->anchor.ptr != NULL) {			\
			s->anchor.ptr->states_cur++;		\
			s->anchor.ptr->states_tot++;		\
		}						\
		SLIST_FOREACH(mrm, &s->match_rules, entry)	\
			mrm->r->states_cur++;			\
	} while (0)

static __inline int pf_src_compare(struct pf_src_node *, struct pf_src_node *);
static __inline int pf_state_compare_key(struct pf_state_key *,
	struct pf_state_key *);
static __inline int pf_state_compare_id(struct pf_state *,
	struct pf_state *);
static __inline void pf_cksum_uncover(u_int16_t *, u_int16_t, u_int8_t);
static __inline void pf_cksum_cover(u_int16_t *, u_int16_t, u_int8_t);

struct pf_src_tree tree_src_tracking;

struct pf_state_tree_id tree_id;
struct pf_state_queue state_list;

RB_GENERATE(pf_src_tree, pf_src_node, entry, pf_src_compare);
RB_GENERATE(pf_state_tree, pf_state_key, entry, pf_state_compare_key);
RB_GENERATE(pf_state_tree_id, pf_state,
    entry_id, pf_state_compare_id);

SLIST_HEAD(pf_rule_gcl, pf_rule)	pf_rule_gcl =
	SLIST_HEAD_INITIALIZER(pf_rule_gcl);

__inline int
pf_addr_compare(struct pf_addr *a, struct pf_addr *b, sa_family_t af)
{
	switch (af) {
	case AF_INET:
		if (a->addr32[0] > b->addr32[0])
			return (1);
		if (a->addr32[0] < b->addr32[0])
			return (-1);
		break;
#ifdef INET6
	case AF_INET6:
		if (a->addr32[3] > b->addr32[3])
			return (1);
		if (a->addr32[3] < b->addr32[3])
			return (-1);
		if (a->addr32[2] > b->addr32[2])
			return (1);
		if (a->addr32[2] < b->addr32[2])
			return (-1);
		if (a->addr32[1] > b->addr32[1])
			return (1);
		if (a->addr32[1] < b->addr32[1])
			return (-1);
		if (a->addr32[0] > b->addr32[0])
			return (1);
		if (a->addr32[0] < b->addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}
	return (0);
}

static __inline int
pf_src_compare(struct pf_src_node *a, struct pf_src_node *b)
{
	int	diff;

	if (a->rule.ptr > b->rule.ptr)
		return (1);
	if (a->rule.ptr < b->rule.ptr)
		return (-1);
	if ((diff = a->type - b->type) != 0)
		return (diff);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	if ((diff = pf_addr_compare(&a->addr, &b->addr, a->af)) != 0)
		return (diff);
	return (0);
}

void
pf_addrcpy(struct pf_addr *dst, struct pf_addr *src, sa_family_t af)
{
	switch (af) {
	case AF_INET:
		dst->addr32[0] = src->addr32[0];
		break;
#ifdef INET6
	case AF_INET6:
		dst->addr32[0] = src->addr32[0];
		dst->addr32[1] = src->addr32[1];
		dst->addr32[2] = src->addr32[2];
		dst->addr32[3] = src->addr32[3];
		break;
#endif /* INET6 */
	default:
		unhandled_af(af);
	}
}

void
pf_init_threshold(struct pf_threshold *threshold,
    u_int32_t limit, u_int32_t seconds)
{
	threshold->limit = limit * PF_THRESHOLD_MULT;
	threshold->seconds = seconds;
	threshold->count = 0;
	threshold->last = time_uptime;
}

void
pf_add_threshold(struct pf_threshold *threshold)
{
	u_int32_t t = time_uptime, diff = t - threshold->last;

	if (diff >= threshold->seconds)
		threshold->count = 0;
	else
		threshold->count -= threshold->count * diff /
		    threshold->seconds;
	threshold->count += PF_THRESHOLD_MULT;
	threshold->last = t;
}

int
pf_check_threshold(struct pf_threshold *threshold)
{
	return (threshold->count > threshold->limit);
}

int
pf_src_connlimit(struct pf_state **state)
{
	int			 bad = 0;
	struct pf_src_node	*sn;

	if ((sn = pf_get_src_node((*state), PF_SN_NONE)) == NULL)
		return (0);

	sn->conn++;
	(*state)->src.tcp_est = 1;
	pf_add_threshold(&sn->conn_rate);

	if ((*state)->rule.ptr->max_src_conn &&
	    (*state)->rule.ptr->max_src_conn < sn->conn) {
		pf_status.lcounters[LCNT_SRCCONN]++;
		bad++;
	}

	if ((*state)->rule.ptr->max_src_conn_rate.limit &&
	    pf_check_threshold(&sn->conn_rate)) {
		pf_status.lcounters[LCNT_SRCCONNRATE]++;
		bad++;
	}

	if (!bad)
		return (0);

	if ((*state)->rule.ptr->overload_tbl) {
		struct pfr_addr p;
		u_int32_t	killed = 0;

		pf_status.lcounters[LCNT_OVERLOAD_TABLE]++;
		if (pf_status.debug >= LOG_NOTICE) {
			log(LOG_NOTICE,
			    "pf: pf_src_connlimit: blocking address ");
			pf_print_host(&sn->addr, 0,
			    (*state)->key[PF_SK_WIRE]->af);
		}

		bzero(&p, sizeof(p));
		p.pfra_af = (*state)->key[PF_SK_WIRE]->af;
		switch ((*state)->key[PF_SK_WIRE]->af) {
		case AF_INET:
			p.pfra_net = 32;
			p.pfra_ip4addr = sn->addr.v4;
			break;
#ifdef INET6
		case AF_INET6:
			p.pfra_net = 128;
			p.pfra_ip6addr = sn->addr.v6;
			break;
#endif /* INET6 */
		}

		pfr_insert_kentry((*state)->rule.ptr->overload_tbl,
		    &p, time_second);

		/* kill existing states if that's required. */
		if ((*state)->rule.ptr->flush) {
			struct pf_state_key *sk;
			struct pf_state *st;

			pf_status.lcounters[LCNT_OVERLOAD_FLUSH]++;
			RB_FOREACH(st, pf_state_tree_id, &tree_id) {
				sk = st->key[PF_SK_WIRE];
				/*
				 * Kill states from this source.  (Only those
				 * from the same rule if PF_FLUSH_GLOBAL is not
				 * set)
				 */
				if (sk->af ==
				    (*state)->key[PF_SK_WIRE]->af &&
				    (((*state)->direction == PF_OUT &&
				    PF_AEQ(&sn->addr, &sk->addr[1], sk->af)) ||
				    ((*state)->direction == PF_IN &&
				    PF_AEQ(&sn->addr, &sk->addr[0], sk->af))) &&
				    ((*state)->rule.ptr->flush &
				    PF_FLUSH_GLOBAL ||
				    (*state)->rule.ptr == st->rule.ptr)) {
					st->timeout = PFTM_PURGE;
					st->src.state = st->dst.state =
					    TCPS_CLOSED;
					killed++;
				}
			}
			if (pf_status.debug >= LOG_NOTICE)
				addlog(", %u states killed", killed);
		}
		if (pf_status.debug >= LOG_NOTICE)
			addlog("\n");
	}

	/* kill this state */
	(*state)->timeout = PFTM_PURGE;
	(*state)->src.state = (*state)->dst.state = TCPS_CLOSED;
	return (1);
}

int
pf_insert_src_node(struct pf_src_node **sn, struct pf_rule *rule,
    enum pf_sn_types type, sa_family_t af, struct pf_addr *src,
    struct pf_addr *raddr)
{
	struct pf_src_node	k;

	if (*sn == NULL) {
		k.af = af;
		k.type = type;
		PF_ACPY(&k.addr, src, af);
		k.rule.ptr = rule;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		*sn = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
	}
	if (*sn == NULL) {
		if (!rule->max_src_nodes ||
		    rule->src_nodes < rule->max_src_nodes)
			(*sn) = pool_get(&pf_src_tree_pl, PR_NOWAIT | PR_ZERO);
		else
			pf_status.lcounters[LCNT_SRCNODES]++;
		if ((*sn) == NULL)
			return (-1);

		pf_init_threshold(&(*sn)->conn_rate,
		    rule->max_src_conn_rate.limit,
		    rule->max_src_conn_rate.seconds);

		(*sn)->type = type;
		(*sn)->af = af;
		(*sn)->rule.ptr = rule;
		PF_ACPY(&(*sn)->addr, src, af);
		if (raddr)
			PF_ACPY(&(*sn)->raddr, raddr, af);
		if (RB_INSERT(pf_src_tree,
		    &tree_src_tracking, *sn) != NULL) {
			if (pf_status.debug >= LOG_NOTICE) {
				log(LOG_NOTICE,
				    "pf: src_tree insert failed: ");
				pf_print_host(&(*sn)->addr, 0, af);
				addlog("\n");
			}
			pool_put(&pf_src_tree_pl, *sn);
			return (-1);
		}
		(*sn)->creation = time_uptime;
		(*sn)->rule.ptr->src_nodes++;
		pf_status.scounters[SCNT_SRC_NODE_INSERT]++;
		pf_status.src_nodes++;
	} else {
		if (rule->max_src_states &&
		    (*sn)->states >= rule->max_src_states) {
			pf_status.lcounters[LCNT_SRCSTATES]++;
			return (-1);
		}
	}
	return (0);
}

void
pf_remove_src_node(struct pf_src_node *sn)
{
	if (sn->states > 0 || sn->expire > time_uptime)
		return;

	sn->rule.ptr->src_nodes--;
	if (sn->rule.ptr->states_cur == 0 &&
	    sn->rule.ptr->src_nodes == 0)
		pf_rm_rule(NULL, sn->rule.ptr);
	RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
	pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
	pf_status.src_nodes--;
	pool_put(&pf_src_tree_pl, sn);
}

struct pf_src_node *
pf_get_src_node(struct pf_state *s, enum pf_sn_types type)
{
	struct pf_sn_item	*sni;

	SLIST_FOREACH(sni, &s->src_nodes, next)
		if (sni->sn->type == type)
			return (sni->sn);
	return (NULL);
}

void
pf_state_rm_src_node(struct pf_state *s, struct pf_src_node *sn)
{
	struct pf_sn_item	*sni, *snin, *snip = NULL;

	for (sni = SLIST_FIRST(&s->src_nodes); sni; sni = snin) {
		snin = SLIST_NEXT(sni, next);
		if (sni->sn == sn) {
			if (snip)
				SLIST_REMOVE_AFTER(snip, next);
			else
				SLIST_REMOVE_HEAD(&s->src_nodes, next);
			pool_put(&pf_sn_item_pl, sni);
			sni = NULL;
			sn->states--;
		}
		if (sni != NULL)
			snip = sni;
	}
}

/* state table stuff */

static __inline int
pf_state_compare_key(struct pf_state_key *a, struct pf_state_key *b)
{
	int	diff;

	if ((diff = a->proto - b->proto) != 0)
		return (diff);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	if ((diff = pf_addr_compare(&a->addr[0], &b->addr[0], a->af)) != 0)
		return (diff);
	if ((diff = pf_addr_compare(&a->addr[1], &b->addr[1], a->af)) != 0)
		return (diff);
	if ((diff = a->port[0] - b->port[0]) != 0)
		return (diff);
	if ((diff = a->port[1] - b->port[1]) != 0)
		return (diff);
	if ((diff = a->rdomain - b->rdomain) != 0)
		return (diff);
	return (0);
}

static __inline int
pf_state_compare_id(struct pf_state *a, struct pf_state *b)
{
	if (a->id > b->id)
		return (1);
	if (a->id < b->id)
		return (-1);
	if (a->creatorid > b->creatorid)
		return (1);
	if (a->creatorid < b->creatorid)
		return (-1);

	return (0);
}

int
pf_state_key_attach(struct pf_state_key *sk, struct pf_state *s, int idx)
{
	struct pf_state_item	*si;
	struct pf_state_key     *cur;
	struct pf_state		*olds = NULL;

	KASSERT(s->key[idx] == NULL);
	if ((cur = RB_INSERT(pf_state_tree, &pf_statetbl, sk)) != NULL) {
		/* key exists. check for same kif, if none, add to key */
		TAILQ_FOREACH(si, &cur->states, entry)
			if (si->s->kif == s->kif &&
			    ((si->s->key[PF_SK_WIRE]->af == sk->af &&
			     si->s->direction == s->direction) ||
			    (si->s->key[PF_SK_WIRE]->af !=
			     si->s->key[PF_SK_STACK]->af &&
			     sk->af == si->s->key[PF_SK_STACK]->af &&
			     si->s->direction != s->direction))) {
				int reuse = 0;

				if (sk->proto == IPPROTO_TCP &&
				    si->s->src.state >= TCPS_FIN_WAIT_2 &&
				    si->s->dst.state >= TCPS_FIN_WAIT_2)
					reuse = 1;
				if (pf_status.debug >= LOG_NOTICE) {
					log(LOG_NOTICE,
					    "pf: %s key attach %s on %s: ",
					    (idx == PF_SK_WIRE) ?
					    "wire" : "stack",
					    reuse ? "reuse" : "failed",
					    s->kif->pfik_name);
					pf_print_state_parts(s,
					    (idx == PF_SK_WIRE) ?  sk : NULL,
					    (idx == PF_SK_STACK) ?  sk : NULL);
					addlog(", existing: ");
					pf_print_state_parts(si->s,
					    (idx == PF_SK_WIRE) ?  sk : NULL,
					    (idx == PF_SK_STACK) ?  sk : NULL);
					addlog("\n");
				}
				if (reuse) {
					si->s->src.state = si->s->dst.state =
					    TCPS_CLOSED;
					/* remove late or sks can go away */
					olds = si->s;
				} else {
					pool_put(&pf_state_key_pl, sk);
					return (-1);	/* collision! */
				}
			}
		pool_put(&pf_state_key_pl, sk);
		s->key[idx] = cur;
	} else
		s->key[idx] = sk;

	if ((si = pool_get(&pf_state_item_pl, PR_NOWAIT)) == NULL) {
		pf_state_key_detach(s, idx);
		return (-1);
	}
	si->s = s;

	/* list is sorted, if-bound states before floating */
	if (s->kif == pfi_all)
		TAILQ_INSERT_TAIL(&s->key[idx]->states, si, entry);
	else
		TAILQ_INSERT_HEAD(&s->key[idx]->states, si, entry);

	if (olds)
		pf_remove_state(olds);

	return (0);
}

void
pf_detach_state(struct pf_state *s)
{
	if (s->key[PF_SK_WIRE] == s->key[PF_SK_STACK])
		s->key[PF_SK_WIRE] = NULL;

	if (s->key[PF_SK_STACK] != NULL)
		pf_state_key_detach(s, PF_SK_STACK);

	if (s->key[PF_SK_WIRE] != NULL)
		pf_state_key_detach(s, PF_SK_WIRE);
}

void
pf_state_key_detach(struct pf_state *s, int idx)
{
	struct pf_state_item	*si;
	struct pf_state_key	*sk;

	if (s->key[idx] == NULL)
		return;

	si = TAILQ_FIRST(&s->key[idx]->states);
	while (si && si->s != s)
	    si = TAILQ_NEXT(si, entry);

	if (si) {
		TAILQ_REMOVE(&s->key[idx]->states, si, entry);
		pool_put(&pf_state_item_pl, si);
	}

	sk = s->key[idx];
	s->key[idx] = NULL;
	if (TAILQ_EMPTY(&sk->states)) {
		RB_REMOVE(pf_state_tree, &pf_statetbl, sk);
		sk->removed = 1;
		pf_state_key_unlink_reverse(sk);
		pf_inpcb_unlink_state_key(sk->inp);
		pf_state_key_unref(sk);
	}
}

struct pf_state_key *
pf_alloc_state_key(int pool_flags)
{
	struct pf_state_key	*sk;

	if ((sk = pool_get(&pf_state_key_pl, pool_flags)) == NULL)
		return (NULL);
	TAILQ_INIT(&sk->states);

	return (sk);
}

static __inline int
pf_state_key_addr_setup(struct pf_pdesc *pd, void *arg, int sidx,
    struct pf_addr *saddr, int didx, struct pf_addr *daddr, int af, int multi)
{
	struct pf_state_key_cmp *key = arg;
#ifdef INET6
	struct pf_addr *target;

	if (af == AF_INET || pd->proto != IPPROTO_ICMPV6)
		goto copy;

	switch (pd->hdr.icmp6.icmp6_type) {
	case ND_NEIGHBOR_SOLICIT:
		if (multi)
			return (-1);
		target = (struct pf_addr *)&pd->hdr.nd_ns.nd_ns_target;
		daddr = target;
		break;
	case ND_NEIGHBOR_ADVERT:
		if (multi)
			return (-1);
		target = (struct pf_addr *)&pd->hdr.nd_ns.nd_ns_target;
		saddr = target;
		if (IN6_IS_ADDR_MULTICAST(&pd->dst->v6)) {
			key->addr[didx].addr32[0] = 0;
			key->addr[didx].addr32[1] = 0;
			key->addr[didx].addr32[2] = 0;
			key->addr[didx].addr32[3] = 0;
			daddr = NULL; /* overwritten */
		}
		break;
	default:
		if (multi) {
			key->addr[sidx].addr32[0] = __IPV6_ADDR_INT32_MLL;
			key->addr[sidx].addr32[1] = 0;
			key->addr[sidx].addr32[2] = 0;
			key->addr[sidx].addr32[3] = __IPV6_ADDR_INT32_ONE;
			saddr = NULL; /* overwritten */
		}
	}
 copy:
#endif	/* INET6 */
	if (saddr)
		PF_ACPY(&key->addr[sidx], saddr, af);
	if (daddr)
		PF_ACPY(&key->addr[didx], daddr, af);

	return (0);
}

int
pf_state_key_setup(struct pf_pdesc *pd, struct pf_state_key **skw,
    struct pf_state_key **sks, int rtableid)
{
	/* if returning error we MUST pool_put state keys ourselves */
	struct pf_state_key *sk1, *sk2;
	u_int wrdom = pd->rdomain;
	int afto = pd->af != pd->naf;

	if ((sk1 = pf_alloc_state_key(PR_NOWAIT | PR_ZERO)) == NULL)
		return (ENOMEM);

	pf_state_key_addr_setup(pd, sk1, pd->sidx, pd->src, pd->didx, pd->dst,
	    pd->af, 0);
	sk1->port[pd->sidx] = pd->osport;
	sk1->port[pd->didx] = pd->odport;
	sk1->proto = pd->proto;
	sk1->af = pd->af;
	sk1->rdomain = pd->rdomain;
	PF_REF_INIT(sk1->refcnt);
	sk1->removed = 0;
	if (rtableid >= 0)
		wrdom = rtable_l2(rtableid);

	if (PF_ANEQ(&pd->nsaddr, pd->src, pd->af) ||
	    PF_ANEQ(&pd->ndaddr, pd->dst, pd->af) ||
	    pd->nsport != pd->osport || pd->ndport != pd->odport ||
	    wrdom != pd->rdomain || afto) {	/* NAT/NAT64 */
		if ((sk2 = pf_alloc_state_key(PR_NOWAIT | PR_ZERO)) == NULL) {
			pool_put(&pf_state_key_pl, sk1);
			return (ENOMEM);
		}
		pf_state_key_addr_setup(pd, sk2, afto ? pd->didx : pd->sidx,
		    &pd->nsaddr, afto ? pd->sidx : pd->didx, &pd->ndaddr,
		    pd->naf, 0);
		sk2->port[afto ? pd->didx : pd->sidx] = pd->nsport;
		sk2->port[afto ? pd->sidx : pd->didx] = pd->ndport;
		if (afto) {
			switch (pd->proto) {
			case IPPROTO_ICMP:
				sk2->proto = IPPROTO_ICMPV6;
				break;
			case IPPROTO_ICMPV6:
				sk2->proto = IPPROTO_ICMP;
				break;
			default:
				sk2->proto = pd->proto;
			}
		} else
			sk2->proto = pd->proto;
		sk2->af = pd->naf;
		sk2->rdomain = wrdom;
		PF_REF_INIT(sk2->refcnt);
		sk2->removed = 0;
	} else
		sk2 = sk1;

	if (pd->dir == PF_IN) {
		*skw = sk1;
		*sks = sk2;
	} else {
		*sks = sk1;
		*skw = sk2;
	}

	if (pf_status.debug >= LOG_DEBUG) {
		log(LOG_DEBUG, "pf: key setup: ");
		pf_print_state_parts(NULL, *skw, *sks);
		addlog("\n");
	}

	return (0);
}

int
pf_state_insert(struct pfi_kif *kif, struct pf_state_key **skw,
    struct pf_state_key **sks, struct pf_state *s)
{
	NET_ASSERT_LOCKED();

	s->kif = kif;
	if (*skw == *sks) {
		if (pf_state_key_attach(*skw, s, PF_SK_WIRE))
			return (-1);
		*skw = *sks = s->key[PF_SK_WIRE];
		s->key[PF_SK_STACK] = s->key[PF_SK_WIRE];
	} else {
		if (pf_state_key_attach(*skw, s, PF_SK_WIRE)) {
			pool_put(&pf_state_key_pl, *sks);
			return (-1);
		}
		*skw = s->key[PF_SK_WIRE];
		if (pf_state_key_attach(*sks, s, PF_SK_STACK)) {
			pf_state_key_detach(s, PF_SK_WIRE);
			return (-1);
		}
		*sks = s->key[PF_SK_STACK];
	}

	if (s->id == 0 && s->creatorid == 0) {
		s->id = htobe64(pf_status.stateid++);
		s->creatorid = pf_status.hostid;
	}
	if (RB_INSERT(pf_state_tree_id, &tree_id, s) != NULL) {
		if (pf_status.debug >= LOG_NOTICE) {
			log(LOG_NOTICE, "pf: state insert failed: "
			    "id: %016llx creatorid: %08x",
			    betoh64(s->id), ntohl(s->creatorid));
			addlog("\n");
		}
		pf_detach_state(s);
		return (-1);
	}
	TAILQ_INSERT_TAIL(&state_list, s, entry_list);
	pf_status.fcounters[FCNT_STATE_INSERT]++;
	pf_status.states++;
	pfi_kif_ref(kif, PFI_KIF_REF_STATE);
#if NPFSYNC > 0
	pfsync_insert_state(s);
#endif	/* NPFSYNC > 0 */
	return (0);
}

struct pf_state *
pf_find_state_byid(struct pf_state_cmp *key)
{
	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	return (RB_FIND(pf_state_tree_id, &tree_id, (struct pf_state *)key));
}

int
pf_compare_state_keys(struct pf_state_key *a, struct pf_state_key *b,
    struct pfi_kif *kif, u_int dir)
{
	/* a (from hdr) and b (new) must be exact opposites of each other */
	if (a->af == b->af && a->proto == b->proto &&
	    PF_AEQ(&a->addr[0], &b->addr[1], a->af) &&
	    PF_AEQ(&a->addr[1], &b->addr[0], a->af) &&
	    a->port[0] == b->port[1] &&
	    a->port[1] == b->port[0] && a->rdomain == b->rdomain)
		return (0);
	else {
		/* mismatch. must not happen. */
		if (pf_status.debug >= LOG_ERR) {
			log(LOG_ERR,
			    "pf: state key linking mismatch! dir=%s, "
			    "if=%s, stored af=%u, a0: ",
			    dir == PF_OUT ? "OUT" : "IN",
			    kif->pfik_name, a->af);
			pf_print_host(&a->addr[0], a->port[0], a->af);
			addlog(", a1: ");
			pf_print_host(&a->addr[1], a->port[1], a->af);
			addlog(", proto=%u", a->proto);
			addlog(", found af=%u, a0: ", b->af);
			pf_print_host(&b->addr[0], b->port[0], b->af);
			addlog(", a1: ");
			pf_print_host(&b->addr[1], b->port[1], b->af);
			addlog(", proto=%u", b->proto);
			addlog("\n");
		}
		return (-1);
	}
}

struct pf_state *
pf_find_state(struct pfi_kif *kif, struct pf_state_key_cmp *key, u_int dir,
    struct mbuf *m)
{
	struct pf_state_key	*sk, *pkt_sk, *inp_sk;
	struct pf_state_item	*si;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;
	if (pf_status.debug >= LOG_DEBUG) {
		log(LOG_DEBUG, "pf: key search, if=%s: ", kif->pfik_name);
		pf_print_state_parts(NULL, (struct pf_state_key *)key, NULL);
		addlog("\n");
	}

	inp_sk = NULL;
	pkt_sk = NULL;
	sk = NULL;
	if (dir == PF_OUT) {
		/* first if block deals with outbound forwarded packet */
		pkt_sk = m->m_pkthdr.pf.statekey;

		if (!pf_state_key_isvalid(pkt_sk)) {
			pf_pkt_unlink_state_key(m);
			pkt_sk = NULL;
		}

		if (pkt_sk && pf_state_key_isvalid(pkt_sk->reverse))
			sk = pkt_sk->reverse;

		if (pkt_sk == NULL) {
			/* here we deal with local outbound packet */
			if (m->m_pkthdr.pf.inp != NULL) {
				inp_sk = m->m_pkthdr.pf.inp->inp_pf_sk;
				if (pf_state_key_isvalid(inp_sk))
					sk = inp_sk;
				else
					pf_inpcb_unlink_state_key(
					    m->m_pkthdr.pf.inp);
			}
		}
	}

	if (sk == NULL) {
		if ((sk = RB_FIND(pf_state_tree, &pf_statetbl,
		    (struct pf_state_key *)key)) == NULL)
			return (NULL);
		if (dir == PF_OUT && pkt_sk &&
		    pf_compare_state_keys(pkt_sk, sk, kif, dir) == 0)
			pf_state_key_link(sk, pkt_sk);
		else if (dir == PF_OUT)
			pf_inp_link(m, m->m_pkthdr.pf.inp);
	}

	/* remove firewall data from outbound packet */
	if (dir == PF_OUT)
		pf_pkt_addr_changed(m);

	/* list is sorted, if-bound states before floating ones */
	TAILQ_FOREACH(si, &sk->states, entry)
		if ((si->s->kif == pfi_all || si->s->kif == kif) &&
		    ((si->s->key[PF_SK_WIRE]->af == si->s->key[PF_SK_STACK]->af
		    && sk == (dir == PF_IN ? si->s->key[PF_SK_WIRE] :
		    si->s->key[PF_SK_STACK])) ||
		    (si->s->key[PF_SK_WIRE]->af != si->s->key[PF_SK_STACK]->af
		    && dir == PF_IN && (sk == si->s->key[PF_SK_STACK] ||
		    sk == si->s->key[PF_SK_WIRE]))))
			return (si->s);

	return (NULL);
}

struct pf_state *
pf_find_state_all(struct pf_state_key_cmp *key, u_int dir, int *more)
{
	struct pf_state_key	*sk;
	struct pf_state_item	*si, *ret = NULL;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	sk = RB_FIND(pf_state_tree, &pf_statetbl, (struct pf_state_key *)key);

	if (sk != NULL) {
		TAILQ_FOREACH(si, &sk->states, entry)
			if (dir == PF_INOUT ||
			    (sk == (dir == PF_IN ? si->s->key[PF_SK_WIRE] :
			    si->s->key[PF_SK_STACK]))) {
				if (more == NULL)
					return (si->s);

				if (ret)
					(*more)++;
				else
					ret = si;
			}
	}
	return (ret ? ret->s : NULL);
}

void
pf_state_export(struct pfsync_state *sp, struct pf_state *st)
{
	int32_t expire;

	bzero(sp, sizeof(struct pfsync_state));

	/* copy from state key */
	sp->key[PF_SK_WIRE].addr[0] = st->key[PF_SK_WIRE]->addr[0];
	sp->key[PF_SK_WIRE].addr[1] = st->key[PF_SK_WIRE]->addr[1];
	sp->key[PF_SK_WIRE].port[0] = st->key[PF_SK_WIRE]->port[0];
	sp->key[PF_SK_WIRE].port[1] = st->key[PF_SK_WIRE]->port[1];
	sp->key[PF_SK_WIRE].rdomain = htons(st->key[PF_SK_WIRE]->rdomain);
	sp->key[PF_SK_WIRE].af = st->key[PF_SK_WIRE]->af;
	sp->key[PF_SK_STACK].addr[0] = st->key[PF_SK_STACK]->addr[0];
	sp->key[PF_SK_STACK].addr[1] = st->key[PF_SK_STACK]->addr[1];
	sp->key[PF_SK_STACK].port[0] = st->key[PF_SK_STACK]->port[0];
	sp->key[PF_SK_STACK].port[1] = st->key[PF_SK_STACK]->port[1];
	sp->key[PF_SK_STACK].rdomain = htons(st->key[PF_SK_STACK]->rdomain);
	sp->key[PF_SK_STACK].af = st->key[PF_SK_STACK]->af;
	sp->rtableid[PF_SK_WIRE] = htonl(st->rtableid[PF_SK_WIRE]);
	sp->rtableid[PF_SK_STACK] = htonl(st->rtableid[PF_SK_STACK]);
	sp->proto = st->key[PF_SK_WIRE]->proto;
	sp->af = st->key[PF_SK_WIRE]->af;

	/* copy from state */
	strlcpy(sp->ifname, st->kif->pfik_name, sizeof(sp->ifname));
	memcpy(&sp->rt_addr, &st->rt_addr, sizeof(sp->rt_addr));
	sp->creation = htonl(time_uptime - st->creation);
	expire = pf_state_expires(st);
	if (expire <= time_uptime)
		sp->expire = htonl(0);
	else
		sp->expire = htonl(expire - time_uptime);

	sp->direction = st->direction;
#if NPFLOG > 0
	sp->log = st->log;
#endif	/* NPFLOG > 0 */
	sp->timeout = st->timeout;
	sp->state_flags = htons(st->state_flags);
	if (!SLIST_EMPTY(&st->src_nodes))
		sp->sync_flags |= PFSYNC_FLAG_SRCNODE;

	sp->id = st->id;
	sp->creatorid = st->creatorid;
	pf_state_peer_hton(&st->src, &sp->src);
	pf_state_peer_hton(&st->dst, &sp->dst);

	if (st->rule.ptr == NULL)
		sp->rule = htonl(-1);
	else
		sp->rule = htonl(st->rule.ptr->nr);
	if (st->anchor.ptr == NULL)
		sp->anchor = htonl(-1);
	else
		sp->anchor = htonl(st->anchor.ptr->nr);
	sp->nat_rule = htonl(-1);	/* left for compat, nat_rule is gone */

	pf_state_counter_hton(st->packets[0], sp->packets[0]);
	pf_state_counter_hton(st->packets[1], sp->packets[1]);
	pf_state_counter_hton(st->bytes[0], sp->bytes[0]);
	pf_state_counter_hton(st->bytes[1], sp->bytes[1]);

	sp->max_mss = htons(st->max_mss);
	sp->min_ttl = st->min_ttl;
	sp->set_tos = st->set_tos;
	sp->set_prio[0] = st->set_prio[0];
	sp->set_prio[1] = st->set_prio[1];
}

/* END state table stuff */

void
pf_purge_expired_rules(void)
{
	struct pf_rule	*r;

	NET_ASSERT_LOCKED();

	if (SLIST_EMPTY(&pf_rule_gcl))
		return;

	while ((r = SLIST_FIRST(&pf_rule_gcl)) != NULL) {
		SLIST_REMOVE(&pf_rule_gcl, r, pf_rule, gcle);
		KASSERT(r->rule_flag & PFRULE_EXPIRED);
		pf_purge_rule(r);
	}
}

void
pf_purge_thread(void *v)
{
	int nloops = 0, s;

	for (;;) {
		tsleep(pf_purge_thread, PWAIT, "pftm", 1 * hz);

		NET_LOCK(s);

		/* process a fraction of the state table every second */
		pf_purge_expired_states(1 + (pf_status.states
		    / pf_default_rule.timeout[PFTM_INTERVAL]));

		/* purge other expired types every PFTM_INTERVAL seconds */
		if (++nloops >= pf_default_rule.timeout[PFTM_INTERVAL]) {
			pf_purge_expired_fragments();
			pf_purge_expired_src_nodes(0);
			pf_purge_expired_rules();
			nloops = 0;
		}

		NET_UNLOCK(s);
	}
}

int32_t
pf_state_expires(const struct pf_state *state)
{
	u_int32_t	timeout;
	u_int32_t	start;
	u_int32_t	end;
	u_int32_t	states;

	/* handle all PFTM_* > PFTM_MAX here */
	if (state->timeout == PFTM_PURGE)
		return (0);

	KASSERT(state->timeout != PFTM_UNLINKED);
	KASSERT(state->timeout < PFTM_MAX);

	timeout = state->rule.ptr->timeout[state->timeout];
	if (!timeout)
		timeout = pf_default_rule.timeout[state->timeout];

	start = state->rule.ptr->timeout[PFTM_ADAPTIVE_START];
	if (start) {
		end = state->rule.ptr->timeout[PFTM_ADAPTIVE_END];
		states = state->rule.ptr->states_cur;
	} else {
		start = pf_default_rule.timeout[PFTM_ADAPTIVE_START];
		end = pf_default_rule.timeout[PFTM_ADAPTIVE_END];
		states = pf_status.states;
	}
	if (end && states > start && start < end) {
		if (states >= end)
			return (0);

		timeout = (u_int64_t)timeout * (end - states) / (end - start);
	}

	return (state->expire + timeout);
}

void
pf_purge_expired_src_nodes(void)
{
	struct pf_src_node		*cur, *next;

	NET_ASSERT_LOCKED();

	for (cur = RB_MIN(pf_src_tree, &tree_src_tracking); cur; cur = next) {
	next = RB_NEXT(pf_src_tree, &tree_src_tracking, cur);

		if (cur->states == 0 && cur->expire <= time_uptime) {
			next = RB_NEXT(pf_src_tree, &tree_src_tracking, cur);
			pf_remove_src_node(cur);
		}
	}
}

void
pf_src_tree_remove_state(struct pf_state *s)
{
	u_int32_t		 timeout;
	struct pf_sn_item	*sni;

	while ((sni = SLIST_FIRST(&s->src_nodes)) != NULL) {
		SLIST_REMOVE_HEAD(&s->src_nodes, next);
		if (s->src.tcp_est)
			--sni->sn->conn;
		if (--sni->sn->states == 0) {
			timeout = s->rule.ptr->timeout[PFTM_SRC_NODE];
			if (!timeout)
				timeout =
				    pf_default_rule.timeout[PFTM_SRC_NODE];
			sni->sn->expire = time_uptime + timeout;
		}
		pool_put(&pf_sn_item_pl, sni);
	}
}

void
pf_remove_state(struct pf_state *cur)
{
	NET_ASSERT_LOCKED();

	/* handle load balancing related tasks */
	pf_postprocess_addr(cur);

	if (cur->src.state == PF_TCPS_PROXY_DST) {
		pf_send_tcp(cur->rule.ptr, cur->key[PF_SK_WIRE]->af,
		    &cur->key[PF_SK_WIRE]->addr[1],
		    &cur->key[PF_SK_WIRE]->addr[0],
		    cur->key[PF_SK_WIRE]->port[1],
		    cur->key[PF_SK_WIRE]->port[0],
		    cur->src.seqhi, cur->src.seqlo + 1,
		    TH_RST|TH_ACK, 0, 0, 0, 1, cur->tag,
		    cur->key[PF_SK_WIRE]->rdomain);
	}
	RB_REMOVE(pf_state_tree_id, &tree_id, cur);
#if NPFLOW > 0
	if (cur->state_flags & PFSTATE_PFLOW) {
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
		export_pflow(cur);
		rw_enter_write(&netlock);
	}
#endif	/* NPFLOW > 0 */
#if NPFSYNC > 0
	pfsync_delete_state(cur);
#endif	/* NPFSYNC > 0 */
	cur->timeout = PFTM_UNLINKED;
	pf_src_tree_remove_state(cur);
	pf_detach_state(cur);
}

void
pf_remove_divert_state(struct pf_state_key *sk)
{
	struct pf_state_item	*si;

	TAILQ_FOREACH(si, &sk->states, entry) {
		if (sk == si->s->key[PF_SK_STACK] && si->s->rule.ptr &&
		    si->s->rule.ptr->divert.port) {
			pf_remove_state(si->s);
			break;
		}
	}
}

void
pf_free_state(struct pf_state *cur)
{
	struct pf_rule_item *ri;

	NET_ASSERT_LOCKED();

#if NPFSYNC > 0
	if (pfsync_state_in_use(cur))
		return;
#endif	/* NPFSYNC > 0 */
	KASSERT(cur->timeout == PFTM_UNLINKED);
	if (--cur->rule.ptr->states_cur == 0 &&
	    cur->rule.ptr->src_nodes == 0)
		pf_rm_rule(NULL, cur->rule.ptr);
	if (cur->anchor.ptr != NULL)
		if (--cur->anchor.ptr->states_cur == 0)
			pf_rm_rule(NULL, cur->anchor.ptr);
	while ((ri = SLIST_FIRST(&cur->match_rules))) {
		SLIST_REMOVE_HEAD(&cur->match_rules, entry);
		if (--ri->r->states_cur == 0 &&
		    ri->r->src_nodes == 0)
			pf_rm_rule(NULL, ri->r);
		pool_put(&pf_rule_item_pl, ri);
	}
	pf_normalize_tcp_cleanup(cur);
	pfi_kif_unref(cur->kif, PFI_KIF_REF_STATE);
	TAILQ_REMOVE(&state_list, cur, entry_list);
	if (cur->tag)
		pf_tag_unref(cur->tag);
	pool_put(&pf_state_pl, cur);
	pf_status.fcounters[FCNT_STATE_REMOVALS]++;
	pf_status.states--;
}

void
pf_purge_expired_states(u_int32_t maxcheck)
{
	static struct pf_state	*cur = NULL;
	struct pf_state		*next;

	NET_ASSERT_LOCKED();

	while (maxcheck--) {
		/* wrap to start of list when we hit the end */
		if (cur == NULL) {
			cur = TAILQ_FIRST(&state_list);
			if (cur == NULL)
				break;	/* list empty */
		}

		/* get next state, as cur may get deleted */
		next = TAILQ_NEXT(cur, entry_list);

		if (cur->timeout == PFTM_UNLINKED) {
			/* free removed state */
			pf_free_state(cur);
		} else if (pf_state_expires(cur) <= time_uptime) {
			/* remove and free expired state */
			pf_remove_state(cur);
			pf_free_state(cur);
		}
		cur = next;
	}
}

int
pf_tbladdr_setup(struct pf_ruleset *rs, struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_TABLE)
		return (0);
	if ((aw->p.tbl = pfr_attach_table(rs, aw->v.tblname, 1)) == NULL)
		return (1);
	return (0);
}

void
pf_tbladdr_remove(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_TABLE || aw->p.tbl == NULL)
		return;
	pfr_detach_table(aw->p.tbl);
	aw->p.tbl = NULL;
}

void
pf_tbladdr_copyout(struct pf_addr_wrap *aw)
{
	struct pfr_ktable *kt = aw->p.tbl;

	if (aw->type != PF_ADDR_TABLE || kt == NULL)
		return;
	if (!(kt->pfrkt_flags & PFR_TFLAG_ACTIVE) && kt->pfrkt_root != NULL)
		kt = kt->pfrkt_root;
	aw->p.tbl = NULL;
	aw->p.tblcnt = (kt->pfrkt_flags & PFR_TFLAG_ACTIVE) ?
		kt->pfrkt_cnt : -1;
}

void
pf_print_host(struct pf_addr *addr, u_int16_t p, sa_family_t af)
{
	switch (af) {
	case AF_INET: {
		u_int32_t a = ntohl(addr->addr32[0]);
		addlog("%u.%u.%u.%u", (a>>24)&255, (a>>16)&255,
		    (a>>8)&255, a&255);
		if (p) {
			p = ntohs(p);
			addlog(":%u", p);
		}
		break;
	}
#ifdef INET6
	case AF_INET6: {
		u_int16_t b;
		u_int8_t i, curstart, curend, maxstart, maxend;
		curstart = curend = maxstart = maxend = 255;
		for (i = 0; i < 8; i++) {
			if (!addr->addr16[i]) {
				if (curstart == 255)
					curstart = i;
				curend = i;
			} else {
				if ((curend - curstart) >
				    (maxend - maxstart)) {
					maxstart = curstart;
					maxend = curend;
				}
				curstart = curend = 255;
			}
		}
		if ((curend - curstart) >
		    (maxend - maxstart)) {
			maxstart = curstart;
			maxend = curend;
		}
		for (i = 0; i < 8; i++) {
			if (i >= maxstart && i <= maxend) {
				if (i == 0)
					addlog(":");
				if (i == maxend)
					addlog(":");
			} else {
				b = ntohs(addr->addr16[i]);
				addlog("%x", b);
				if (i < 7)
					addlog(":");
			}
		}
		if (p) {
			p = ntohs(p);
			addlog("[%u]", p);
		}
		break;
	}
#endif /* INET6 */
	}
}

void
pf_print_state(struct pf_state *s)
{
	pf_print_state_parts(s, NULL, NULL);
}

void
pf_print_state_parts(struct pf_state *s,
    struct pf_state_key *skwp, struct pf_state_key *sksp)
{
	struct pf_state_key *skw, *sks;
	u_int8_t proto, dir;

	/* Do our best to fill these, but they're skipped if NULL */
	skw = skwp ? skwp : (s ? s->key[PF_SK_WIRE] : NULL);
	sks = sksp ? sksp : (s ? s->key[PF_SK_STACK] : NULL);
	proto = skw ? skw->proto : (sks ? sks->proto : 0);
	dir = s ? s->direction : 0;

	switch (proto) {
	case IPPROTO_IPV4:
		addlog("IPv4");
		break;
	case IPPROTO_IPV6:
		addlog("IPv6");
		break;
	case IPPROTO_TCP:
		addlog("TCP");
		break;
	case IPPROTO_UDP:
		addlog("UDP");
		break;
	case IPPROTO_ICMP:
		addlog("ICMP");
		break;
	case IPPROTO_ICMPV6:
		addlog("ICMPv6");
		break;
	default:
		addlog("%u", proto);
		break;
	}
	switch (dir) {
	case PF_IN:
		addlog(" in");
		break;
	case PF_OUT:
		addlog(" out");
		break;
	}
	if (skw) {
		addlog(" wire: (%d) ", skw->rdomain);
		pf_print_host(&skw->addr[0], skw->port[0], skw->af);
		addlog(" ");
		pf_print_host(&skw->addr[1], skw->port[1], skw->af);
	}
	if (sks) {
		addlog(" stack: (%d) ", sks->rdomain);
		if (sks != skw) {
			pf_print_host(&sks->addr[0], sks->port[0], sks->af);
			addlog(" ");
			pf_print_host(&sks->addr[1], sks->port[1], sks->af);
		} else
			addlog("-");
	}
	if (s) {
		if (proto == IPPROTO_TCP) {
			addlog(" [lo=%u high=%u win=%u modulator=%u",
			    s->src.seqlo, s->src.seqhi,
			    s->src.max_win, s->src.seqdiff);
			if (s->src.wscale && s->dst.wscale)
				addlog(" wscale=%u",
				    s->src.wscale & PF_WSCALE_MASK);
			addlog("]");
			addlog(" [lo=%u high=%u win=%u modulator=%u",
			    s->dst.seqlo, s->dst.seqhi,
			    s->dst.max_win, s->dst.seqdiff);
			if (s->src.wscale && s->dst.wscale)
				addlog(" wscale=%u",
				s->dst.wscale & PF_WSCALE_MASK);
			addlog("]");
		}
		addlog(" %u:%u", s->src.state, s->dst.state);
		if (s->rule.ptr)
			addlog(" @@%d", s->rule.ptr->nr);
	}
}

void
pf_print_flags(u_int8_t f)
{
	if (f)
		addlog(" ");
	if (f & TH_FIN)
		addlog("F");
	if (f & TH_SYN)
		addlog("S");
	if (f & TH_RST)
		addlog("R");
	if (f & TH_PUSH)
		addlog("P");
	if (f & TH_ACK)
		addlog("A");
	if (f & TH_URG)
		addlog("U");
	if (f & TH_ECE)
		addlog("E");
	if (f & TH_CWR)
		addlog("W");
}

#define	PF_SET_SKIP_STEPS(i)					\
	do {							\
		while (head[i] != cur) {			\
			head[i]->skip[i].ptr = cur;		\
			head[i] = TAILQ_NEXT(head[i], entries);	\
		}						\
	} while (0)

void
pf_calc_skip_steps(struct pf_rulequeue *rules)
{
	struct pf_rule *cur, *prev, *head[PF_SKIP_COUNT];
	int i;

	cur = TAILQ_FIRST(rules);
	prev = cur;
	for (i = 0; i < PF_SKIP_COUNT; ++i)
		head[i] = cur;
	while (cur != NULL) {
		if (cur->kif != prev->kif || cur->ifnot != prev->ifnot)
			PF_SET_SKIP_STEPS(PF_SKIP_IFP);
		if (cur->direction != prev->direction)
			PF_SET_SKIP_STEPS(PF_SKIP_DIR);
		if (cur->onrdomain != prev->onrdomain ||
		    cur->ifnot != prev->ifnot)
			PF_SET_SKIP_STEPS(PF_SKIP_RDOM);
		if (cur->af != prev->af)
			PF_SET_SKIP_STEPS(PF_SKIP_AF);
		if (cur->proto != prev->proto)
			PF_SET_SKIP_STEPS(PF_SKIP_PROTO);
		if (cur->src.neg != prev->src.neg ||
		    pf_addr_wrap_neq(&cur->src.addr, &prev->src.addr))
			PF_SET_SKIP_STEPS(PF_SKIP_SRC_ADDR);
		if (cur->dst.neg != prev->dst.neg ||
		    pf_addr_wrap_neq(&cur->dst.addr, &prev->dst.addr))
			PF_SET_SKIP_STEPS(PF_SKIP_DST_ADDR);
		if (cur->src.port[0] != prev->src.port[0] ||
		    cur->src.port[1] != prev->src.port[1] ||
		    cur->src.port_op != prev->src.port_op)
			PF_SET_SKIP_STEPS(PF_SKIP_SRC_PORT);
		if (cur->dst.port[0] != prev->dst.port[0] ||
		    cur->dst.port[1] != prev->dst.port[1] ||
		    cur->dst.port_op != prev->dst.port_op)
			PF_SET_SKIP_STEPS(PF_SKIP_DST_PORT);

		prev = cur;
		cur = TAILQ_NEXT(cur, entries);
	}
	for (i = 0; i < PF_SKIP_COUNT; ++i)
		PF_SET_SKIP_STEPS(i);
}

int
pf_addr_wrap_neq(struct pf_addr_wrap *aw1, struct pf_addr_wrap *aw2)
{
	if (aw1->type != aw2->type)
		return (1);
	switch (aw1->type) {
	case PF_ADDR_ADDRMASK:
	case PF_ADDR_RANGE:
		if (PF_ANEQ(&aw1->v.a.addr, &aw2->v.a.addr, AF_INET6))
			return (1);
		if (PF_ANEQ(&aw1->v.a.mask, &aw2->v.a.mask, AF_INET6))
			return (1);
		return (0);
	case PF_ADDR_DYNIFTL:
		return (aw1->p.dyn->pfid_kt != aw2->p.dyn->pfid_kt);
	case PF_ADDR_NONE:
	case PF_ADDR_NOROUTE:
	case PF_ADDR_URPFFAILED:
		return (0);
	case PF_ADDR_TABLE:
		return (aw1->p.tbl != aw2->p.tbl);
	case PF_ADDR_RTLABEL:
		return (aw1->v.rtlabel != aw2->v.rtlabel);
	default:
		addlog("invalid address type: %d\n", aw1->type);
		return (1);
	}
}

/* This algorithm computes 'a + b - c' in ones-complement using a trick to
 * emulate at most one ones-complement subtraction. This thereby limits net
 * carries/borrows to at most one, eliminating a reduction step and saving one
 * each of +, >>, & and ~.
 *
 * def. x mod y = x - (x//y)*y for integer x,y
 * def. sum = x mod 2^16
 * def. accumulator = (x >> 16) mod 2^16
 *
 * The trick works as follows: subtracting exactly one u_int16_t from the
 * u_int32_t x incurs at most one underflow, wrapping its upper 16-bits, the
 * accumulator, to 2^16 - 1. Adding this to the 16-bit sum preserves the
 * ones-complement borrow:
 *
 *  (sum + accumulator) mod 2^16
 * =	{ assume underflow: accumulator := 2^16 - 1 }
 *  (sum + 2^16 - 1) mod 2^16
 * =	{ mod }
 *  (sum - 1) mod 2^16
 *
 * Although this breaks for sum = 0, giving 0xffff, which is ones-complement's
 * other zero, not -1, that cannot occur: the 16-bit sum cannot be underflown
 * to zero as that requires subtraction of at least 2^16, which exceeds a
 * single u_int16_t's range.
 *
 * We use the following theorem to derive the implementation:
 *
 * th. (x + (y mod z)) mod z  =  (x + y) mod z   (0)
 * proof.
 *     (x + (y mod z)) mod z
 *    =  { def mod }
 *     (x + y - (y//z)*z) mod z
 *    =  { (a + b*c) mod c = a mod c }
 *     (x + y) mod z			[end of proof]
 *
 * ... and thereby obtain:
 *
 *  (sum + accumulator) mod 2^16
 * =	{ def. accumulator, def. sum }
 *  (x mod 2^16 + (x >> 16) mod 2^16) mod 2^16
 * =	{ (0), twice }
 *  (x + (x >> 16)) mod 2^16
 * =	{ x mod 2^n = x & (2^n - 1) }
 *  (x + (x >> 16)) & 0xffff
 *
 * Note: this serves also as a reduction step for at most one add (as the
 * trailing mod 2^16 prevents further reductions by destroying carries).
 */
static __inline void
pf_cksum_fixup(u_int16_t *cksum, u_int16_t was, u_int16_t now,
    u_int8_t proto)
{
	u_int32_t x;
	const int udp = proto == IPPROTO_UDP;

	x = *cksum + was - now;
	x = (x + (x >> 16)) & 0xffff;

	/* optimise: eliminate a branch when not udp */
	if (udp && *cksum == 0x0000)
		return;
	if (udp && x == 0x0000)
		x = 0xffff;

	*cksum = (u_int16_t)(x);
}

/* pre: coverage(cksum) is superset of coverage(covered_cksum) */
static __inline void
pf_cksum_uncover(u_int16_t *cksum, u_int16_t covered_cksum, u_int8_t proto)
{
	pf_cksum_fixup(cksum, ~covered_cksum, 0x0, proto);
}

/* pre: disjoint(coverage(cksum), coverage(uncovered_cksum)) */
static __inline void
pf_cksum_cover(u_int16_t *cksum, u_int16_t uncovered_cksum, u_int8_t proto)
{
	pf_cksum_fixup(cksum, 0x0, ~uncovered_cksum, proto);
}

/* pre: *a is 16-bit aligned within its packet
 *
 * This algorithm emulates 16-bit ones-complement sums on a twos-complement
 * machine by conserving ones-complement's otherwise discarded carries in the
 * upper bits of x. These accumulated carries when added to the lower 16-bits
 * over at least zero 'reduction' steps then complete the ones-complement sum.
 *
 * def. sum = x mod 2^16
 * def. accumulator = (x >> 16)
 *
 * At most two reduction steps
 *
 *   x := sum + accumulator
 * =    { def sum, def accumulator }
 *   x := x mod 2^16 + (x >> 16)
 * =    { x mod 2^n = x & (2^n - 1) }
 *   x := (x & 0xffff) + (x >> 16)
 *
 * are necessary to incorporate the accumulated carries (at most one per add)
 * i.e. to reduce x < 2^16 from at most 16 carries in the upper 16 bits.
 *
 * The function is also invariant over the endian of the host. Why?
 *
 * Define the unary transpose operator ~ on a bitstring in python slice
 * notation as lambda m: m[P:] + m[:P] , for some constant pivot P.
 *
 * th. ~ distributes over ones-complement addition, denoted by +_1, i.e.
 *
 *     ~m +_1 ~n  =  ~(m +_1 n)    (for all bitstrings m,n of equal length)
 *
 * proof. Regard the bitstrings in m +_1 n as split at P, forming at most two
 * 'half-adds'. Under ones-complement addition, each half-add carries to the
 * other, so the sum of each half-add is unaffected by their relative
 * order. Therefore:
 *
 *     ~m +_1 ~n
 *   =    { half-adds invariant under transposition }
 *     ~s
 *   =    { substitute }
 *     ~(m +_1 n)                   [end of proof]
 *
 * th. Summing two in-memory ones-complement 16-bit variables m,n on a machine
 * with the converse endian does not alter the result.
 *
 * proof.
 *        { converse machine endian: load/store transposes, P := 8 }
 *     ~(~m +_1 ~n)
 *   =    { ~ over +_1 }
 *     ~~m +_1 ~~n
 *   =    { ~ is an involution }
 *      m +_1 n                     [end of proof]
 *
 */
#define NEG(x) ((u_int16_t)~(x))
void
pf_cksum_fixup_a(u_int16_t *cksum, const struct pf_addr *a,
    const struct pf_addr *an, sa_family_t af, u_int8_t proto)
{
	u_int32_t	 x;
	const u_int16_t	*n = an->addr16;
	const u_int16_t *o = a->addr16;
	const int	 udp = proto == IPPROTO_UDP;

	switch (af) {
	case AF_INET:
		x = *cksum + o[0] + NEG(n[0]) + o[1] + NEG(n[1]);
		break;
#ifdef INET6
	case AF_INET6:
		x = *cksum + o[0] + NEG(n[0]) + o[1] + NEG(n[1]) +\
			     o[2] + NEG(n[2]) + o[3] + NEG(n[3]) +\
			     o[4] + NEG(n[4]) + o[5] + NEG(n[5]) +\
			     o[6] + NEG(n[6]) + o[7] + NEG(n[7]);
		break;
#endif /* INET6 */
	default:
		unhandled_af(af);
	}

	x = (x & 0xffff) + (x >> 16);
	x = (x & 0xffff) + (x >> 16);

	/* optimise: eliminate a branch when not udp */
	if (udp && *cksum == 0x0000)
		return;
	if (udp && x == 0x0000)
		x = 0xffff;

	*cksum = (u_int16_t)(x);
}

int
pf_patch_8(struct pf_pdesc *pd, u_int8_t *f, u_int8_t v, bool hi)
{
	int	rewrite = 0;

	if (*f != v) {
		u_int16_t old = htons(hi ? (*f << 8) : *f);
		u_int16_t new = htons(hi ? ( v << 8) :  v);

		pf_cksum_fixup(pd->pcksum, old, new, pd->proto);
		*f = v;
		rewrite = 1;
	}

	return (rewrite);
}

/* pre: *f is 16-bit aligned within its packet */
int
pf_patch_16(struct pf_pdesc *pd, u_int16_t *f, u_int16_t v)
{
	int	rewrite = 0;

	if (*f != v) {
		pf_cksum_fixup(pd->pcksum, *f, v, pd->proto);
		*f = v;
		rewrite = 1;
	}

	return (rewrite);
}

int
pf_patch_16_unaligned(struct pf_pdesc *pd, void *f, u_int16_t v, bool hi)
{
	int		rewrite = 0;
	u_int8_t       *fb = (u_int8_t*)f;
	u_int8_t       *vb = (u_int8_t*)&v;

	if (hi && ALIGNED_POINTER(f, u_int16_t)) {
		return (pf_patch_16(pd, f, v)); /* optimise */
	}

	rewrite += pf_patch_8(pd, fb++, *vb++, hi);
	rewrite += pf_patch_8(pd, fb++, *vb++,!hi);

	return (rewrite);
}

/* pre: *f is 16-bit aligned within its packet */
/* pre: pd->proto != IPPROTO_UDP */
int
pf_patch_32(struct pf_pdesc *pd, u_int32_t *f, u_int32_t v)
{
	int		rewrite = 0;
	u_int16_t      *pc = pd->pcksum;
	u_int8_t        proto = pd->proto;

	/* optimise: inline udp fixup code is unused; let compiler scrub it */
	if (proto == IPPROTO_UDP)
		panic("pf_patch_32: udp");

	/* optimise: skip *f != v guard; true for all use-cases */
	pf_cksum_fixup(pc, *f / (1 << 16), v / (1 << 16), proto);
	pf_cksum_fixup(pc, *f % (1 << 16), v % (1 << 16), proto);

	*f = v;
	rewrite = 1;

	return (rewrite);
}

int
pf_patch_32_unaligned(struct pf_pdesc *pd, void *f, u_int32_t v, bool hi)
{
	int		rewrite = 0;
	u_int8_t       *fb = (u_int8_t*)f;
	u_int8_t       *vb = (u_int8_t*)&v;

	if (hi && ALIGNED_POINTER(f, u_int32_t)) {
		return (pf_patch_32(pd, f, v)); /* optimise */
	}

	rewrite += pf_patch_8(pd, fb++, *vb++, hi);
	rewrite += pf_patch_8(pd, fb++, *vb++,!hi);
	rewrite += pf_patch_8(pd, fb++, *vb++, hi);
	rewrite += pf_patch_8(pd, fb++, *vb++,!hi);

	return (rewrite);
}

int
pf_icmp_mapping(struct pf_pdesc *pd, u_int8_t type, int *icmp_dir,
    u_int16_t *virtual_id, u_int16_t *virtual_type)
{
	/*
	 * ICMP types marked with PF_OUT are typically responses to
	 * PF_IN, and will match states in the opposite direction.
	 * PF_IN ICMP types need to match a state with that type.
	 */
	*icmp_dir = PF_OUT;

	/* Queries (and responses) */
	switch (pd->af) {
	case AF_INET:
		switch (type) {
		case ICMP_ECHO:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case ICMP_ECHOREPLY:
			*virtual_type = ICMP_ECHO;
			*virtual_id = pd->hdr.icmp.icmp_id;
			break;

		case ICMP_TSTAMP:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case ICMP_TSTAMPREPLY:
			*virtual_type = ICMP_TSTAMP;
			*virtual_id = pd->hdr.icmp.icmp_id;
			break;

		case ICMP_IREQ:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case ICMP_IREQREPLY:
			*virtual_type = ICMP_IREQ;
			*virtual_id = pd->hdr.icmp.icmp_id;
			break;

		case ICMP_MASKREQ:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case ICMP_MASKREPLY:
			*virtual_type = ICMP_MASKREQ;
			*virtual_id = pd->hdr.icmp.icmp_id;
			break;

		case ICMP_IPV6_WHEREAREYOU:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case ICMP_IPV6_IAMHERE:
			*virtual_type = ICMP_IPV6_WHEREAREYOU;
			*virtual_id = 0; /* Nothing sane to match on! */
			break;

		case ICMP_MOBILE_REGREQUEST:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case ICMP_MOBILE_REGREPLY:
			*virtual_type = ICMP_MOBILE_REGREQUEST;
			*virtual_id = 0; /* Nothing sane to match on! */
			break;

		case ICMP_ROUTERSOLICIT:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case ICMP_ROUTERADVERT:
			*virtual_type = ICMP_ROUTERSOLICIT;
			*virtual_id = 0; /* Nothing sane to match on! */
			break;

		/* These ICMP types map to other connections */
		case ICMP_UNREACH:
		case ICMP_SOURCEQUENCH:
		case ICMP_REDIRECT:
		case ICMP_TIMXCEED:
		case ICMP_PARAMPROB:
			/* These will not be used, but set them anyway */
			*icmp_dir = PF_IN;
			*virtual_type = htons(type);
			*virtual_id = 0;
			return (1);  /* These types match to another state */

		/*
		 * All remaining ICMP types get their own states,
		 * and will only match in one direction.
		 */
		default:
			*icmp_dir = PF_IN;
			*virtual_type = type;
			*virtual_id = 0;
			break;
		}
		break;
#ifdef INET6
	case AF_INET6:
		switch (type) {
		case ICMP6_ECHO_REQUEST:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case ICMP6_ECHO_REPLY:
			*virtual_type = ICMP6_ECHO_REQUEST;
			*virtual_id = pd->hdr.icmp6.icmp6_id;
			break;

		case MLD_LISTENER_QUERY:
		case MLD_LISTENER_REPORT: {
			struct mld_hdr *mld = &pd->hdr.mld;
			u_int32_t h;

			/*
			 * Listener Report can be sent by clients
			 * without an associated Listener Query.
			 * In addition to that, when Report is sent as a
			 * reply to a Query its source and destination
			 * address are different.
			 */
			*icmp_dir = PF_IN;
			*virtual_type = MLD_LISTENER_QUERY;
			/* generate fake id for these messages */
			h = mld->mld_addr.s6_addr32[0] ^
			    mld->mld_addr.s6_addr32[1] ^
			    mld->mld_addr.s6_addr32[2] ^
			    mld->mld_addr.s6_addr32[3];
			*virtual_id = (h >> 16) ^ (h & 0xffff);
			break;
		}

		/*
		 * ICMP6_FQDN and ICMP6_NI query/reply are the same type as
		 * ICMP6_WRU
		 */
		case ICMP6_WRUREQUEST:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case ICMP6_WRUREPLY:
			*virtual_type = ICMP6_WRUREQUEST;
			*virtual_id = 0; /* Nothing sane to match on! */
			break;

		case MLD_MTRACE:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case MLD_MTRACE_RESP:
			*virtual_type = MLD_MTRACE;
			*virtual_id = 0; /* Nothing sane to match on! */
			break;

		case ND_NEIGHBOR_SOLICIT:
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
		case ND_NEIGHBOR_ADVERT: {
			struct nd_neighbor_solicit *nd = &pd->hdr.nd_ns;
			u_int32_t h;

			*virtual_type = ND_NEIGHBOR_SOLICIT;
			/* generate fake id for these messages */
			h = nd->nd_ns_target.s6_addr32[0] ^
			    nd->nd_ns_target.s6_addr32[1] ^
			    nd->nd_ns_target.s6_addr32[2] ^
			    nd->nd_ns_target.s6_addr32[3];
			*virtual_id = (h >> 16) ^ (h & 0xffff);
			break;
		}

		/*
		 * These ICMP types map to other connections.
		 * ND_REDIRECT can't be in this list because the triggering
		 * packet header is optional.
		 */
		case ICMP6_DST_UNREACH:
		case ICMP6_PACKET_TOO_BIG:
		case ICMP6_TIME_EXCEEDED:
		case ICMP6_PARAM_PROB:
			/* These will not be used, but set them anyway */
			*icmp_dir = PF_IN;
			*virtual_type = htons(type);
			*virtual_id = 0;
			return (1);  /* These types match to another state */
		/*
		 * All remaining ICMP6 types get their own states,
		 * and will only match in one direction.
		 */
		default:
			*icmp_dir = PF_IN;
			*virtual_type = type;
			*virtual_id = 0;
			break;
		}
		break;
#endif /* INET6 */
	}
	*virtual_type = htons(*virtual_type);
	return (0);  /* These types match to their own state */
}

void
pf_translate_icmp(struct pf_pdesc *pd, struct pf_addr *qa, u_int16_t *qp,
    struct pf_addr *oa, struct pf_addr *na, u_int16_t np)
{
	/* note: doesn't trouble to fixup quoted checksums, if any */

	/* change quoted protocol port */
	if (qp != NULL)
		pf_patch_16(pd, qp, np);

	/* change quoted ip address */
	pf_cksum_fixup_a(pd->pcksum, qa, na, pd->af, pd->proto);
	PF_ACPY(qa, na, pd->af);

	/* change network-header's ip address */
	if (oa)
		pf_translate_a(pd, oa, na);
}

/* pre: *a is 16-bit aligned within its packet */
/*      *a is a network header src/dst address */
int
pf_translate_a(struct pf_pdesc *pd, struct pf_addr *a, struct pf_addr *an)
{
	int	rewrite = 0;

	/* warning: !PF_ANEQ != PF_AEQ */
	if (!PF_ANEQ(a, an, pd->af))
		return (0);

	/* fixup transport pseudo-header, if any */
	switch (pd->proto) {
	case IPPROTO_TCP:       /* FALLTHROUGH */
	case IPPROTO_UDP:	/* FALLTHROUGH */
	case IPPROTO_ICMPV6:
		pf_cksum_fixup_a(pd->pcksum, a, an, pd->af, pd->proto);
		break;
	default:
		break;  /* assume no pseudo-header */
	}

	PF_ACPY(a, an, pd->af);
	rewrite = 1;

	return (rewrite);
}

#if INET6
/* pf_translate_af() may change pd->m, adjust local copies after calling */
int
pf_translate_af(struct pf_pdesc *pd)
{
	static const struct pf_addr	zero;
	struct ip		       *ip4;
	struct ip6_hdr		       *ip6;
	int				copyback = 0;
	u_int				hlen, ohlen, dlen;
	u_int16_t		       *pc;
	u_int8_t			af_proto, naf_proto;

	hlen = (pd->naf == AF_INET) ? sizeof(*ip4) : sizeof(*ip6);
	ohlen = pd->off;
	dlen = pd->tot_len - pd->off;
	pc = pd->pcksum;

	af_proto = naf_proto = pd->proto;
	if (naf_proto == IPPROTO_ICMP)
		af_proto = IPPROTO_ICMPV6;
	if (naf_proto == IPPROTO_ICMPV6)
		af_proto = IPPROTO_ICMP;

	/* uncover stale pseudo-header */
	switch (af_proto) {
	case IPPROTO_ICMPV6:
		/* optimise: unchanged for TCP/UDP */
		pf_cksum_fixup(pc, htons(af_proto), 0x0, af_proto);
		pf_cksum_fixup(pc, htons(dlen),     0x0, af_proto);
				/* FALLTHROUGH */
	case IPPROTO_UDP:	/* FALLTHROUGH */
	case IPPROTO_TCP:
		pf_cksum_fixup_a(pc, pd->src, &zero, pd->af, af_proto);
		pf_cksum_fixup_a(pc, pd->dst, &zero, pd->af, af_proto);
		copyback = 1;
		break;
	default:
		break;	/* assume no pseudo-header */
	}

	/* replace the network header */
	m_adj(pd->m, pd->off);
	pd->src = NULL;
	pd->dst = NULL;

	if ((M_PREPEND(pd->m, hlen, M_DONTWAIT)) == NULL) {
		pd->m = NULL;
		return (-1);
	}

	pd->off = hlen;
	pd->tot_len += hlen - ohlen;

	switch (pd->naf) {
	case AF_INET:
		ip4 = mtod(pd->m, struct ip *);
		bzero(ip4, hlen);
		ip4->ip_v   = IPVERSION;
		ip4->ip_hl  = hlen >> 2;
		ip4->ip_tos = pd->tos;
		ip4->ip_len = htons(hlen + dlen);
		ip4->ip_id  = htons(ip_randomid());
		ip4->ip_off = htons(IP_DF);
		ip4->ip_ttl = pd->ttl;
		ip4->ip_p   = pd->proto;
		ip4->ip_src = pd->nsaddr.v4;
		ip4->ip_dst = pd->ndaddr.v4;
		break;
	case AF_INET6:
		ip6 = mtod(pd->m, struct ip6_hdr *);
		bzero(ip6, hlen);
		ip6->ip6_vfc  = IPV6_VERSION;
		ip6->ip6_flow |= htonl((u_int32_t)pd->tos << 20);
		ip6->ip6_plen = htons(dlen);
		ip6->ip6_nxt  = pd->proto;
		if (!pd->ttl || pd->ttl > IPV6_DEFHLIM)
			ip6->ip6_hlim = IPV6_DEFHLIM;
		else
			ip6->ip6_hlim = pd->ttl;
		ip6->ip6_src  = pd->nsaddr.v6;
		ip6->ip6_dst  = pd->ndaddr.v6;
		break;
	default:
		unhandled_af(pd->naf);
	}

	/* UDP over IPv6 must be checksummed per rfc2460 p27 */
	if (naf_proto == IPPROTO_UDP && *pc == 0x0000 &&
	    pd->naf == AF_INET6) {
		pd->m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;
	}

	/* cover fresh pseudo-header */
	switch (naf_proto) {
	case IPPROTO_ICMPV6:
		/* optimise: unchanged for TCP/UDP */
		pf_cksum_fixup(pc, 0x0, htons(naf_proto), naf_proto);
		pf_cksum_fixup(pc, 0x0, htons(dlen),      naf_proto);
				/* FALLTHROUGH */
	case IPPROTO_UDP:	/* FALLTHROUGH */
	case IPPROTO_TCP:
		pf_cksum_fixup_a(pc, &zero, &pd->nsaddr, pd->naf, naf_proto);
		pf_cksum_fixup_a(pc, &zero, &pd->ndaddr, pd->naf, naf_proto);
		copyback = 1;
		break;
	default:
		break;	/* assume no pseudo-header */
	}

	/* flush pd->pcksum */
	if (copyback)
		m_copyback(pd->m, pd->off, pd->hdrlen, &pd->hdr, M_NOWAIT);

	return (0);
}

int
pf_change_icmp_af(struct mbuf *m, int ipoff2, struct pf_pdesc *pd,
    struct pf_pdesc *pd2, struct pf_addr *src, struct pf_addr *dst,
    sa_family_t af, sa_family_t naf)
{
	struct mbuf		*n = NULL;
	struct ip		*ip4;
	struct ip6_hdr		*ip6;
	u_int			 hlen, ohlen, dlen;
	int			 d;

	if (af == naf || (af != AF_INET && af != AF_INET6) ||
	    (naf != AF_INET && naf != AF_INET6))
		return (-1);

	/* split the mbuf chain on the quoted ip/ip6 header boundary */
	if ((n = m_split(m, ipoff2, M_DONTWAIT)) == NULL)
		return (-1);

	/* new quoted header */
	hlen = naf == AF_INET ? sizeof(*ip4) : sizeof(*ip6);
	/* old quoted header */
	ohlen = pd2->off - ipoff2;

	/* trim old quoted header */
	pf_cksum_uncover(pd->pcksum, in_cksum(n, ohlen), pd->proto);
	m_adj(n, ohlen);

	/* prepend a new, translated, quoted header */
	if ((M_PREPEND(n, hlen, M_DONTWAIT)) == NULL)
		return (-1);

	switch (naf) {
	case AF_INET:
		ip4 = mtod(n, struct ip *);
		bzero(ip4, sizeof(*ip4));
		ip4->ip_v   = IPVERSION;
		ip4->ip_hl  = sizeof(*ip4) >> 2;
		ip4->ip_len = htons(sizeof(*ip4) + pd2->tot_len - ohlen);
		ip4->ip_id  = htons(ip_randomid());
		ip4->ip_off = htons(IP_DF);
		ip4->ip_ttl = pd2->ttl;
		if (pd2->proto == IPPROTO_ICMPV6)
			ip4->ip_p = IPPROTO_ICMP;
		else
			ip4->ip_p = pd2->proto;
		ip4->ip_src = src->v4;
		ip4->ip_dst = dst->v4;
		ip4->ip_sum = in_cksum(n, ip4->ip_hl << 2);
		break;
	case AF_INET6:
		ip6 = mtod(n, struct ip6_hdr *);
		bzero(ip6, sizeof(*ip6));
		ip6->ip6_vfc  = IPV6_VERSION;
		ip6->ip6_plen = htons(pd2->tot_len - ohlen);
		if (pd2->proto == IPPROTO_ICMP)
			ip6->ip6_nxt = IPPROTO_ICMPV6;
		else
			ip6->ip6_nxt = pd2->proto;
		if (!pd2->ttl || pd2->ttl > IPV6_DEFHLIM)
			ip6->ip6_hlim = IPV6_DEFHLIM;
		else
			ip6->ip6_hlim = pd2->ttl;
		ip6->ip6_src  = src->v6;
		ip6->ip6_dst  = dst->v6;
		break;
	}

	/* cover new quoted header */
	/* optimise: any new AF_INET header of ours sums to zero */
	if (naf != AF_INET) {
		pf_cksum_cover(pd->pcksum, in_cksum(n, hlen), pd->proto);
	}

	/* reattach modified quoted packet to outer header */
	{
		int nlen = n->m_pkthdr.len;
		m_cat(m, n);
		m->m_pkthdr.len += nlen;
	}

	/* account for altered length */
	d = hlen - ohlen;

	if (pd->proto == IPPROTO_ICMPV6) {
		/* fixup pseudo-header */
		dlen = pd->tot_len - pd->off;
		pf_cksum_fixup(pd->pcksum,
		    htons(dlen), htons(dlen + d), pd->proto);
	}

	pd->tot_len  += d;
	pd2->tot_len += d;
	pd2->off     += d;

	/* note: not bothering to update network headers as
	   these due for rewrite by pf_translate_af() */

	return (0);
}


#define PTR_IP(field)	(offsetof(struct ip, field))
#define PTR_IP6(field)	(offsetof(struct ip6_hdr, field))

int
pf_translate_icmp_af(struct pf_pdesc *pd, int af, void *arg)
{
	struct icmp		*icmp4;
	struct icmp6_hdr	*icmp6;
	u_int32_t		 mtu;
	int32_t			 ptr = -1;
	u_int8_t		 type;
	u_int8_t		 code;

	switch (af) {
	case AF_INET:
		icmp6 = arg;
		type  = icmp6->icmp6_type;
		code  = icmp6->icmp6_code;
		mtu   = ntohl(icmp6->icmp6_mtu);

		switch (type) {
		case ICMP6_ECHO_REQUEST:
			type = ICMP_ECHO;
			break;
		case ICMP6_ECHO_REPLY:
			type = ICMP_ECHOREPLY;
			break;
		case ICMP6_DST_UNREACH:
			type = ICMP_UNREACH;
			switch (code) {
			case ICMP6_DST_UNREACH_NOROUTE:
			case ICMP6_DST_UNREACH_BEYONDSCOPE:
			case ICMP6_DST_UNREACH_ADDR:
				code = ICMP_UNREACH_HOST;
				break;
			case ICMP6_DST_UNREACH_ADMIN:
				code = ICMP_UNREACH_HOST_PROHIB;
				break;
			case ICMP6_DST_UNREACH_NOPORT:
				code = ICMP_UNREACH_PORT;
				break;
			default:
				return (-1);
			}
			break;
		case ICMP6_PACKET_TOO_BIG:
			type = ICMP_UNREACH;
			code = ICMP_UNREACH_NEEDFRAG;
			mtu -= 20;
			break;
		case ICMP6_TIME_EXCEEDED:
			type = ICMP_TIMXCEED;
			break;
		case ICMP6_PARAM_PROB:
			switch (code) {
			case ICMP6_PARAMPROB_HEADER:
				type = ICMP_PARAMPROB;
				code = ICMP_PARAMPROB_ERRATPTR;
				ptr  = ntohl(icmp6->icmp6_pptr);

				if (ptr == PTR_IP6(ip6_vfc))
					; /* preserve */
				else if (ptr == PTR_IP6(ip6_vfc) + 1)
					ptr = PTR_IP(ip_tos);
				else if (ptr == PTR_IP6(ip6_plen) ||
				    ptr == PTR_IP6(ip6_plen) + 1)
					ptr = PTR_IP(ip_len);
				else if (ptr == PTR_IP6(ip6_nxt))
					ptr = PTR_IP(ip_p);
				else if (ptr == PTR_IP6(ip6_hlim))
					ptr = PTR_IP(ip_ttl);
				else if (ptr >= PTR_IP6(ip6_src) &&
				    ptr < PTR_IP6(ip6_dst))
					ptr = PTR_IP(ip_src);
				else if (ptr >= PTR_IP6(ip6_dst) &&
				    ptr < sizeof(struct ip6_hdr))
					ptr = PTR_IP(ip_dst);
				else {
					return (-1);
				}
				break;
			case ICMP6_PARAMPROB_NEXTHEADER:
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_PROTOCOL;
				break;
			default:
				return (-1);
			}
			break;
		default:
			return (-1);
		}

		pf_patch_8(pd, &icmp6->icmp6_type, type, PF_HI);
		pf_patch_8(pd, &icmp6->icmp6_code, code, PF_LO);

		/* aligns well with a icmpv4 nextmtu */
		pf_patch_32(pd, &icmp6->icmp6_mtu, htonl(mtu));

		/* icmpv4 pptr is a one most significant byte */
		if (ptr >= 0)
			pf_patch_32(pd, &icmp6->icmp6_pptr, htonl(ptr << 24));
		break;
	case AF_INET6:
		icmp4 = arg;
		type  = icmp4->icmp_type;
		code  = icmp4->icmp_code;
		mtu   = ntohs(icmp4->icmp_nextmtu);

		switch (type) {
		case ICMP_ECHO:
			type = ICMP6_ECHO_REQUEST;
			break;
		case ICMP_ECHOREPLY:
			type = ICMP6_ECHO_REPLY;
			break;
		case ICMP_UNREACH:
			type = ICMP6_DST_UNREACH;
			switch (code) {
			case ICMP_UNREACH_NET:
			case ICMP_UNREACH_HOST:
			case ICMP_UNREACH_NET_UNKNOWN:
			case ICMP_UNREACH_HOST_UNKNOWN:
			case ICMP_UNREACH_ISOLATED:
			case ICMP_UNREACH_TOSNET:
			case ICMP_UNREACH_TOSHOST:
				code = ICMP6_DST_UNREACH_NOROUTE;
				break;
			case ICMP_UNREACH_PORT:
				code = ICMP6_DST_UNREACH_NOPORT;
				break;
			case ICMP_UNREACH_NET_PROHIB:
			case ICMP_UNREACH_HOST_PROHIB:
			case ICMP_UNREACH_FILTER_PROHIB:
			case ICMP_UNREACH_PRECEDENCE_CUTOFF:
				code = ICMP6_DST_UNREACH_ADMIN;
				break;
			case ICMP_UNREACH_PROTOCOL:
				type = ICMP6_PARAM_PROB;
				code = ICMP6_PARAMPROB_NEXTHEADER;
				ptr  = offsetof(struct ip6_hdr, ip6_nxt);
				break;
			case ICMP_UNREACH_NEEDFRAG:
				type = ICMP6_PACKET_TOO_BIG;
				code = 0;
				mtu += 20;
				break;
			default:
				return (-1);
			}
			break;
		case ICMP_TIMXCEED:
			type = ICMP6_TIME_EXCEEDED;
			break;
		case ICMP_PARAMPROB:
			type = ICMP6_PARAM_PROB;
			switch (code) {
			case ICMP_PARAMPROB_ERRATPTR:
				code = ICMP6_PARAMPROB_HEADER;
				break;
			case ICMP_PARAMPROB_LENGTH:
				code = ICMP6_PARAMPROB_HEADER;
				break;
			default:
				return (-1);
			}

			ptr = icmp4->icmp_pptr;
			if (ptr == 0 || ptr == PTR_IP(ip_tos))
				; /* preserve */
			else if (ptr == PTR_IP(ip_len) ||
			    ptr == PTR_IP(ip_len) + 1)
				ptr = PTR_IP6(ip6_plen);
			else if (ptr == PTR_IP(ip_ttl))
				ptr = PTR_IP6(ip6_hlim);
			else if (ptr == PTR_IP(ip_p))
				ptr = PTR_IP6(ip6_nxt);
			else if (ptr >= PTR_IP(ip_src) &&
			    ptr < PTR_IP(ip_dst))
				ptr = PTR_IP6(ip6_src);
			else if (ptr >= PTR_IP(ip_dst) &&
			    ptr < sizeof(struct ip))
				ptr = PTR_IP6(ip6_dst);
			else {
				return (-1);
			}
			break;
		default:
			return (-1);
		}

		pf_patch_8(pd, &icmp4->icmp_type, type, PF_HI);
		pf_patch_8(pd, &icmp4->icmp_code, code, PF_LO);
		pf_patch_16(pd, &icmp4->icmp_nextmtu, htons(mtu));
		if (ptr >= 0)
			pf_patch_32(pd, &icmp4->icmp_void, htonl(ptr));
		break;
	}

	return (0);
}
#endif /* INET6 */

/*
 * Need to modulate the sequence numbers in the TCP SACK option
 * (credits to Krzysztof Pfaff for report and patch)
 */
int
pf_modulate_sack(struct pf_pdesc *pd, struct pf_state_peer *dst)
{
	struct tcphdr	*th = &pd->hdr.tcp;
	int		 hlen = (th->th_off << 2) - sizeof(*th);
	int		 thoptlen = hlen;
	u_int8_t	 opts[MAX_TCPOPTLEN], *opt = opts;
	int		 copyback = 0, i, olen;
	struct sackblk	 sack;

#define TCPOLEN_SACKLEN	(TCPOLEN_SACK + 2)
	if (hlen < TCPOLEN_SACKLEN || hlen > MAX_TCPOPTLEN || !pf_pull_hdr(
	    pd->m, pd->off + sizeof(*th), opts, hlen, NULL, NULL, pd->af))
		return 0;

	while (hlen >= TCPOLEN_SACKLEN) {
		olen = opt[1];
		switch (*opt) {
		case TCPOPT_EOL:	/* FALLTHROUGH */
		case TCPOPT_NOP:
			opt++;
			hlen--;
			break;
		case TCPOPT_SACK:
			if (olen > hlen)
				olen = hlen;
			if (olen >= TCPOLEN_SACKLEN) {
				for (i = 2; i + TCPOLEN_SACK <= olen;
				    i += TCPOLEN_SACK) {
					size_t startoff = (opt + i) - opts;
					memcpy(&sack, &opt[i], sizeof(sack));
					pf_patch_32_unaligned(pd, &sack.start,
					    htonl(ntohl(sack.start) -
						dst->seqdiff),
					    PF_ALGNMNT(startoff));
					pf_patch_32_unaligned(pd, &sack.end,
					    htonl(ntohl(sack.end) -
						dst->seqdiff),
					    PF_ALGNMNT(startoff +
						sizeof(sack.start)));
					memcpy(&opt[i], &sack, sizeof(sack));
				}
				copyback = 1;
			}
			/* FALLTHROUGH */
		default:
			if (olen < 2)
				olen = 2;
			hlen -= olen;
			opt += olen;
		}
	}

	if (copyback)
		m_copyback(pd->m, pd->off + sizeof(*th), thoptlen, opts,
		    M_NOWAIT);
	return (copyback);
}

struct mbuf *
pf_build_tcp(const struct pf_rule *r, sa_family_t af,
    const struct pf_addr *saddr, const struct pf_addr *daddr,
    u_int16_t sport, u_int16_t dport, u_int32_t seq, u_int32_t ack,
    u_int8_t flags, u_int16_t win, u_int16_t mss, u_int8_t ttl, int tag,
    u_int16_t rtag, u_int rdom)
{
	struct mbuf	*m;
	int		 len, tlen;
	struct ip	*h;
#ifdef INET6
	struct ip6_hdr	*h6;
#endif /* INET6 */
	struct tcphdr	*th;
	char		*opt;

	/* maximum segment size tcp option */
	tlen = sizeof(struct tcphdr);
	if (mss)
		tlen += 4;

	switch (af) {
	case AF_INET:
		len = sizeof(struct ip) + tlen;
		break;
#ifdef INET6
	case AF_INET6:
		len = sizeof(struct ip6_hdr) + tlen;
		break;
#endif /* INET6 */
	default:
		unhandled_af(af);
	}

	/* create outgoing mbuf */
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	if (m == NULL)
		return (NULL);
	if (tag)
		m->m_pkthdr.pf.flags |= PF_TAG_GENERATED;
	m->m_pkthdr.pf.tag = rtag;
	m->m_pkthdr.ph_rtableid = rdom;
	if (r && (r->scrub_flags & PFSTATE_SETPRIO))
		m->m_pkthdr.pf.prio = r->set_prio[0];
	if (r && r->qid)
		m->m_pkthdr.pf.qid = r->qid;
	m->m_data += max_linkhdr;
	m->m_pkthdr.len = m->m_len = len;
	m->m_pkthdr.ph_ifidx = 0;
	m->m_pkthdr.csum_flags |= M_TCP_CSUM_OUT;
	bzero(m->m_data, len);
	switch (af) {
	case AF_INET:
		h = mtod(m, struct ip *);
		h->ip_p = IPPROTO_TCP;
		h->ip_len = htons(tlen);
		h->ip_v = 4;
		h->ip_hl = sizeof(*h) >> 2;
		h->ip_tos = IPTOS_LOWDELAY;
		h->ip_len = htons(len);
		h->ip_off = htons(ip_mtudisc ? IP_DF : 0);
		h->ip_ttl = ttl ? ttl : ip_defttl;
		h->ip_sum = 0;
		h->ip_src.s_addr = saddr->v4.s_addr;
		h->ip_dst.s_addr = daddr->v4.s_addr;

		th = (struct tcphdr *)((caddr_t)h + sizeof(struct ip));
		break;
#ifdef INET6
	case AF_INET6:
		h6 = mtod(m, struct ip6_hdr *);
		h6->ip6_nxt = IPPROTO_TCP;
		h6->ip6_plen = htons(tlen);
		h6->ip6_vfc |= IPV6_VERSION;
		h6->ip6_hlim = IPV6_DEFHLIM;
		memcpy(&h6->ip6_src, &saddr->v6, sizeof(struct in6_addr));
		memcpy(&h6->ip6_dst, &daddr->v6, sizeof(struct in6_addr));

		th = (struct tcphdr *)((caddr_t)h6 + sizeof(struct ip6_hdr));
		break;
#endif /* INET6 */
	default:
		unhandled_af(af);
	}

	/* TCP header */
	th->th_sport = sport;
	th->th_dport = dport;
	th->th_seq = htonl(seq);
	th->th_ack = htonl(ack);
	th->th_off = tlen >> 2;
	th->th_flags = flags;
	th->th_win = htons(win);

	if (mss) {
		opt = (char *)(th + 1);
		opt[0] = TCPOPT_MAXSEG;
		opt[1] = 4;
		mss = htons(mss);
		memcpy((opt + 2), &mss, 2);
	}

	return (m);
}

void
pf_send_tcp(const struct pf_rule *r, sa_family_t af,
    const struct pf_addr *saddr, const struct pf_addr *daddr,
    u_int16_t sport, u_int16_t dport, u_int32_t seq, u_int32_t ack,
    u_int8_t flags, u_int16_t win, u_int16_t mss, u_int8_t ttl, int tag,
    u_int16_t rtag, u_int rdom)
{
	struct mbuf     *m;

	if ((m = pf_build_tcp(r, af, saddr, daddr, sport, dport, seq, ack,
	     flags, win, mss, ttl, tag, rtag, rdom)) == NULL)
		return;

	switch (af) {
	case AF_INET:
		ip_send(m);
		break;
#ifdef INET6
	case AF_INET6:
		ip6_send(m);
		break;
#endif /* INET6 */
	}
}

static void
pf_send_challenge_ack(struct pf_pdesc *pd, struct pf_state *s,
    struct pf_state_peer *src, struct pf_state_peer *dst)
{
	/*
	 * We are sending challenge ACK as a response to SYN packet, which
	 * matches existing state (modulo TCP window check). Therefore packet
	 * must be sent on behalf of destination.
	 *
	 * We expect sender to remain either silent, or send RST packet
	 * so both, firewall and remote peer, can purge dead state from
	 * memory.
	 */
	pf_send_tcp(s->rule.ptr, pd->af, pd->dst, pd->src,
	    pd->hdr.tcp.th_dport, pd->hdr.tcp.th_sport, dst->seqlo,
	    src->seqlo, TH_ACK, 0, 0, s->rule.ptr->return_ttl, 1, 0,
	    pd->rdomain);
}

void
pf_send_icmp(struct mbuf *m, u_int8_t type, u_int8_t code, sa_family_t af,
    struct pf_rule *r, u_int rdomain)
{
	struct mbuf	*m0;

	if ((m0 = m_copym(m, 0, M_COPYALL, M_NOWAIT)) == NULL)
		return;

	m0->m_pkthdr.pf.flags |= PF_TAG_GENERATED;
	m0->m_pkthdr.ph_rtableid = rdomain;
	if (r && (r->scrub_flags & PFSTATE_SETPRIO))
		m0->m_pkthdr.pf.prio = r->set_prio[0];
	if (r && r->qid)
		m0->m_pkthdr.pf.qid = r->qid;

	switch (af) {
	case AF_INET:
		icmp_error(m0, type, code, 0, 0);
		break;
#ifdef INET6
	case AF_INET6:
		icmp6_error(m0, type, code, 0);
		break;
#endif /* INET6 */
	}
}

/*
 * Return ((n = 0) == (a = b [with mask m]))
 * Note: n != 0 => returns (a != b [with mask m])
 */
int
pf_match_addr(u_int8_t n, struct pf_addr *a, struct pf_addr *m,
    struct pf_addr *b, sa_family_t af)
{
	switch (af) {
	case AF_INET:
		if ((a->addr32[0] & m->addr32[0]) ==
		    (b->addr32[0] & m->addr32[0]))
			return (n == 0);
		break;
#ifdef INET6
	case AF_INET6:
		if (((a->addr32[0] & m->addr32[0]) ==
		     (b->addr32[0] & m->addr32[0])) &&
		    ((a->addr32[1] & m->addr32[1]) ==
		     (b->addr32[1] & m->addr32[1])) &&
		    ((a->addr32[2] & m->addr32[2]) ==
		     (b->addr32[2] & m->addr32[2])) &&
		    ((a->addr32[3] & m->addr32[3]) ==
		     (b->addr32[3] & m->addr32[3])))
			return (n == 0);
		break;
#endif /* INET6 */
	}

	return (n != 0);
}

/*
 * Return 1 if b <= a <= e, otherwise return 0.
 */
int
pf_match_addr_range(struct pf_addr *b, struct pf_addr *e,
    struct pf_addr *a, sa_family_t af)
{
	switch (af) {
	case AF_INET:
		if ((ntohl(a->addr32[0]) < ntohl(b->addr32[0])) ||
		    (ntohl(a->addr32[0]) > ntohl(e->addr32[0])))
			return (0);
		break;
#ifdef INET6
	case AF_INET6: {
		int	i;

		/* check a >= b */
		for (i = 0; i < 4; ++i)
			if (ntohl(a->addr32[i]) > ntohl(b->addr32[i]))
				break;
			else if (ntohl(a->addr32[i]) < ntohl(b->addr32[i]))
				return (0);
		/* check a <= e */
		for (i = 0; i < 4; ++i)
			if (ntohl(a->addr32[i]) < ntohl(e->addr32[i]))
				break;
			else if (ntohl(a->addr32[i]) > ntohl(e->addr32[i]))
				return (0);
		break;
	}
#endif /* INET6 */
	}
	return (1);
}

int
pf_match(u_int8_t op, u_int32_t a1, u_int32_t a2, u_int32_t p)
{
	switch (op) {
	case PF_OP_IRG:
		return ((p > a1) && (p < a2));
	case PF_OP_XRG:
		return ((p < a1) || (p > a2));
	case PF_OP_RRG:
		return ((p >= a1) && (p <= a2));
	case PF_OP_EQ:
		return (p == a1);
	case PF_OP_NE:
		return (p != a1);
	case PF_OP_LT:
		return (p < a1);
	case PF_OP_LE:
		return (p <= a1);
	case PF_OP_GT:
		return (p > a1);
	case PF_OP_GE:
		return (p >= a1);
	}
	return (0); /* never reached */
}

int
pf_match_port(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
{
	return (pf_match(op, ntohs(a1), ntohs(a2), ntohs(p)));
}

int
pf_match_uid(u_int8_t op, uid_t a1, uid_t a2, uid_t u)
{
	if (u == UID_MAX && op != PF_OP_EQ && op != PF_OP_NE)
		return (0);
	return (pf_match(op, a1, a2, u));
}

int
pf_match_gid(u_int8_t op, gid_t a1, gid_t a2, gid_t g)
{
	if (g == GID_MAX && op != PF_OP_EQ && op != PF_OP_NE)
		return (0);
	return (pf_match(op, a1, a2, g));
}

int
pf_match_tag(struct mbuf *m, struct pf_rule *r, int *tag)
{
	if (*tag == -1)
		*tag = m->m_pkthdr.pf.tag;

	return ((!r->match_tag_not && r->match_tag == *tag) ||
	    (r->match_tag_not && r->match_tag != *tag));
}

int
pf_match_rcvif(struct mbuf *m, struct pf_rule *r)
{
	struct ifnet *ifp;
	struct pfi_kif *kif;

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		return (0);

#if NCARP > 0
	if (ifp->if_type == IFT_CARP && ifp->if_carpdev)
		kif = (struct pfi_kif *)ifp->if_carpdev->if_pf_kif;
	else
#endif /* NCARP */
		kif = (struct pfi_kif *)ifp->if_pf_kif;

	if_put(ifp);

	if (kif == NULL) {
		DPFPRINTF(LOG_ERR,
		    "%s: kif == NULL, @@%d via %s", __func__,
		    r->nr, r->rcv_ifname);
		return (0);
	}

	return (pfi_kif_match(r->rcv_kif, kif));
}

void
pf_tag_packet(struct mbuf *m, int tag, int rtableid)
{
	if (tag > 0)
		m->m_pkthdr.pf.tag = tag;
	if (rtableid >= 0)
		m->m_pkthdr.ph_rtableid = (u_int)rtableid;
}

enum pf_test_status
pf_step_into_anchor(struct pf_test_ctx *ctx, struct pf_rule *r)
{
	int	rv;

	if (ctx->depth >= PF_ANCHOR_STACK_MAX) {
		log(LOG_ERR, "pf_step_into_anchor: stack overflow\n");
		return (PF_TEST_FAIL);
	}

	ctx->depth++;

	if (r->anchor_wildcard) {
		struct pf_anchor	*child;
		rv = PF_TEST_OK;
		RB_FOREACH(child, pf_anchor_node, &r->anchor->children) {
			rv = pf_match_rule(ctx, &child->ruleset);
			if ((rv == PF_TEST_QUICK) || (rv == PF_TEST_FAIL)) {
				/*
				 * we either hit a rule qith quick action
				 * (more likely), or hit some runtime
				 * error (e.g. pool_get() faillure).
				 */
				break;
			}
		}
	} else {
		rv = pf_match_rule(ctx, &r->anchor->ruleset);
	}

	ctx->depth--;

	return (rv);
}

void
pf_poolmask(struct pf_addr *naddr, struct pf_addr *raddr,
    struct pf_addr *rmask, struct pf_addr *saddr, sa_family_t af)
{
	switch (af) {
	case AF_INET:
		naddr->addr32[0] = (raddr->addr32[0] & rmask->addr32[0]) |
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]);
		break;
#ifdef INET6
	case AF_INET6:
		naddr->addr32[0] = (raddr->addr32[0] & rmask->addr32[0]) |
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]);
		naddr->addr32[1] = (raddr->addr32[1] & rmask->addr32[1]) |
		((rmask->addr32[1] ^ 0xffffffff ) & saddr->addr32[1]);
		naddr->addr32[2] = (raddr->addr32[2] & rmask->addr32[2]) |
		((rmask->addr32[2] ^ 0xffffffff ) & saddr->addr32[2]);
		naddr->addr32[3] = (raddr->addr32[3] & rmask->addr32[3]) |
		((rmask->addr32[3] ^ 0xffffffff ) & saddr->addr32[3]);
		break;
#endif /* INET6 */
	default:
		unhandled_af(af);
	}
}

void
pf_addr_inc(struct pf_addr *addr, sa_family_t af)
{
	switch (af) {
	case AF_INET:
		addr->addr32[0] = htonl(ntohl(addr->addr32[0]) + 1);
		break;
#ifdef INET6
	case AF_INET6:
		if (addr->addr32[3] == 0xffffffff) {
			addr->addr32[3] = 0;
			if (addr->addr32[2] == 0xffffffff) {
				addr->addr32[2] = 0;
				if (addr->addr32[1] == 0xffffffff) {
					addr->addr32[1] = 0;
					addr->addr32[0] =
					    htonl(ntohl(addr->addr32[0]) + 1);
				} else
					addr->addr32[1] =
					    htonl(ntohl(addr->addr32[1]) + 1);
			} else
				addr->addr32[2] =
				    htonl(ntohl(addr->addr32[2]) + 1);
		} else
			addr->addr32[3] =
			    htonl(ntohl(addr->addr32[3]) + 1);
		break;
#endif /* INET6 */
	default:
		unhandled_af(af);
	}
}

int
pf_socket_lookup(struct pf_pdesc *pd)
{
	struct pf_addr		*saddr, *daddr;
	u_int16_t		 sport, dport;
	struct inpcbtable	*tb;
	struct inpcb		*inp;

	pd->lookup.uid = UID_MAX;
	pd->lookup.gid = GID_MAX;
	pd->lookup.pid = NO_PID;
	switch (pd->virtual_proto) {
	case IPPROTO_TCP:
		sport = pd->hdr.tcp.th_sport;
		dport = pd->hdr.tcp.th_dport;
		NET_ASSERT_LOCKED();
		tb = &tcbtable;
		break;
	case IPPROTO_UDP:
		sport = pd->hdr.udp.uh_sport;
		dport = pd->hdr.udp.uh_dport;
		NET_ASSERT_LOCKED();
		tb = &udbtable;
		break;
	default:
		return (-1);
	}
	if (pd->dir == PF_IN) {
		saddr = pd->src;
		daddr = pd->dst;
	} else {
		u_int16_t	p;

		p = sport;
		sport = dport;
		dport = p;
		saddr = pd->dst;
		daddr = pd->src;
	}
	switch (pd->af) {
	case AF_INET:
		/*
		 * Fails when rtable is changed while evaluating the ruleset
		 * The socket looked up will not match the one hit in the end.
		 */
		inp = in_pcbhashlookup(tb, saddr->v4, sport, daddr->v4, dport,
		    pd->rdomain);
		if (inp == NULL) {
			inp = in_pcblookup_listen(tb, daddr->v4, dport, 0,
			    NULL, pd->rdomain);
			if (inp == NULL)
				return (-1);
		}
		break;
#ifdef INET6
	case AF_INET6:
		inp = in6_pcbhashlookup(tb, &saddr->v6, sport, &daddr->v6,
		    dport, pd->rdomain);
		if (inp == NULL) {
			inp = in6_pcblookup_listen(tb, &daddr->v6, dport, 0,
			    NULL, pd->rdomain);
			if (inp == NULL)
				return (-1);
		}
		break;
#endif /* INET6 */
	default:
		unhandled_af(pd->af);
	}
	pd->lookup.uid = inp->inp_socket->so_euid;
	pd->lookup.gid = inp->inp_socket->so_egid;
	pd->lookup.pid = inp->inp_socket->so_cpid;
	return (1);
}

u_int8_t
pf_get_wscale(struct pf_pdesc *pd)
{
	struct tcphdr	*th = &pd->hdr.tcp;
	int		 hlen;
	u_int8_t	 hdr[60];
	u_int8_t	*opt, optlen;
	u_int8_t	 wscale = 0;

	hlen = th->th_off << 2;		/* hlen <= sizeof(hdr) */
	if (hlen <= sizeof(struct tcphdr))
		return (0);
	if (!pf_pull_hdr(pd->m, pd->off, hdr, hlen, NULL, NULL, pd->af))
		return (0);
	opt = hdr + sizeof(struct tcphdr);
	hlen -= sizeof(struct tcphdr);
	while (hlen >= 3) {
		switch (*opt) {
		case TCPOPT_EOL:
		case TCPOPT_NOP:
			++opt;
			--hlen;
			break;
		case TCPOPT_WINDOW:
			wscale = opt[2];
			if (wscale > TCP_MAX_WINSHIFT)
				wscale = TCP_MAX_WINSHIFT;
			wscale |= PF_WSCALE_FLAG;
			/* FALLTHROUGH */
		default:
			optlen = opt[1];
			if (optlen < 2)
				optlen = 2;
			hlen -= optlen;
			opt += optlen;
			break;
		}
	}
	return (wscale);
}

u_int16_t
pf_get_mss(struct pf_pdesc *pd)
{
	struct tcphdr	*th = &pd->hdr.tcp;
	int		 hlen;
	u_int8_t	 hdr[60];
	u_int8_t	*opt, optlen;
	u_int16_t	 mss = tcp_mssdflt;

	hlen = th->th_off << 2;		/* hlen <= sizeof(hdr) */
	if (hlen <= sizeof(struct tcphdr))
		return (0);
	if (!pf_pull_hdr(pd->m, pd->off, hdr, hlen, NULL, NULL, pd->af))
		return (0);
	opt = hdr + sizeof(struct tcphdr);
	hlen -= sizeof(struct tcphdr);
	while (hlen >= TCPOLEN_MAXSEG) {
		switch (*opt) {
		case TCPOPT_EOL:
		case TCPOPT_NOP:
			++opt;
			--hlen;
			break;
		case TCPOPT_MAXSEG:
			memcpy(&mss, (opt + 2), 2);
			mss = ntohs(mss);
			/* FALLTHROUGH */
		default:
			optlen = opt[1];
			if (optlen < 2)
				optlen = 2;
			hlen -= optlen;
			opt += optlen;
			break;
		}
	}
	return (mss);
}

u_int16_t
pf_calc_mss(struct pf_addr *addr, sa_family_t af, int rtableid, u_int16_t offer)
{
	struct ifnet		*ifp;
	struct sockaddr_in	*dst;
#ifdef INET6
	struct sockaddr_in6	*dst6;
#endif /* INET6 */
	struct rtentry		*rt = NULL;
	struct sockaddr_storage	 ss;
	int			 hlen;
	u_int16_t		 mss = tcp_mssdflt;

	memset(&ss, 0, sizeof(ss));

	switch (af) {
	case AF_INET:
		hlen = sizeof(struct ip);
		dst = (struct sockaddr_in *)&ss;
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = addr->v4;
		rt = rtalloc(sintosa(dst), 0, rtableid);
		break;
#ifdef INET6
	case AF_INET6:
		hlen = sizeof(struct ip6_hdr);
		dst6 = (struct sockaddr_in6 *)&ss;
		dst6->sin6_family = AF_INET6;
		dst6->sin6_len = sizeof(*dst6);
		dst6->sin6_addr = addr->v6;
		rt = rtalloc(sin6tosa(dst6), 0, rtableid);
		break;
#endif /* INET6 */
	}

	if (rt != NULL && (ifp = if_get(rt->rt_ifidx)) != NULL) {
		mss = ifp->if_mtu - hlen - sizeof(struct tcphdr);
		mss = max(tcp_mssdflt, mss);
		if_put(ifp);
	}
	rtfree(rt);
	mss = min(mss, offer);
	mss = max(mss, 64);		/* sanity - at least max opt space */
	return (mss);
}

static __inline int
pf_set_rt_ifp(struct pf_state *s, struct pf_addr *saddr, sa_family_t af)
{
	struct pf_rule *r = s->rule.ptr;
	struct pf_src_node *sns[PF_SN_MAX];
	int	rv;

	s->rt_kif = NULL;
	if (!r->rt)
		return (0);

	bzero(sns, sizeof(sns));
	switch (af) {
	case AF_INET:
		rv = pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL, sns,
		    &r->route, PF_SN_ROUTE);
		break;
#ifdef INET6
	case AF_INET6:
		rv = pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL, sns,
		    &r->route, PF_SN_ROUTE);
		break;
#endif /* INET6 */
	default:
		rv = 1;
	}

	if (rv == 0) {
		s->rt_kif = r->route.kif;
		s->natrule.ptr = r;
	}

	return (rv);
}

u_int32_t
pf_tcp_iss(struct pf_pdesc *pd)
{
	SHA2_CTX ctx;
	union {
		uint8_t bytes[SHA512_DIGEST_LENGTH];
		uint32_t words[1];
	} digest;

	if (pf_tcp_secret_init == 0) {
		arc4random_buf(pf_tcp_secret, sizeof(pf_tcp_secret));
		SHA512Init(&pf_tcp_secret_ctx);
		SHA512Update(&pf_tcp_secret_ctx, pf_tcp_secret,
		    sizeof(pf_tcp_secret));
		pf_tcp_secret_init = 1;
	}
	ctx = pf_tcp_secret_ctx;

	SHA512Update(&ctx, &pd->rdomain, sizeof(pd->rdomain));
	SHA512Update(&ctx, &pd->hdr.tcp.th_sport, sizeof(u_short));
	SHA512Update(&ctx, &pd->hdr.tcp.th_dport, sizeof(u_short));
	switch (pd->af) {
	case AF_INET:
		SHA512Update(&ctx, &pd->src->v4, sizeof(struct in_addr));
		SHA512Update(&ctx, &pd->dst->v4, sizeof(struct in_addr));
		break;
#ifdef INET6
	case AF_INET6:
		SHA512Update(&ctx, &pd->src->v6, sizeof(struct in6_addr));
		SHA512Update(&ctx, &pd->dst->v6, sizeof(struct in6_addr));
		break;
#endif /* INET6 */
	}
	SHA512Final(digest.bytes, &ctx);
	pf_tcp_iss_off += 4096;
	return (digest.words[0] + tcp_iss + pf_tcp_iss_off);
}

void
pf_rule_to_actions(struct pf_rule *r, struct pf_rule_actions *a)
{
	if (r->qid)
		a->qid = r->qid;
	if (r->pqid)
		a->pqid = r->pqid;
	if (r->rtableid >= 0)
		a->rtableid = r->rtableid;
#if NPFLOG > 0
	a->log |= r->log;
#endif	/* NPFLOG > 0 */
	if (r->scrub_flags & PFSTATE_SETTOS)
		a->set_tos = r->set_tos;
	if (r->min_ttl)
		a->min_ttl = r->min_ttl;
	if (r->max_mss)
		a->max_mss = r->max_mss;
	a->flags |= (r->scrub_flags & (PFSTATE_NODF|PFSTATE_RANDOMID|
	    PFSTATE_SETTOS|PFSTATE_SCRUB_TCP|PFSTATE_SETPRIO));
	if (r->scrub_flags & PFSTATE_SETPRIO) {
		a->set_prio[0] = r->set_prio[0];
		a->set_prio[1] = r->set_prio[1];
	}
}

#define PF_TEST_ATTRIB(t, a)			\
	if (t) {				\
		r = a;				\
		continue;			\
	} else do {				\
	} while (0)

enum pf_test_status
pf_match_rule(struct pf_test_ctx *ctx, struct pf_ruleset *ruleset)
{
	struct pf_rule	*r;

	r = TAILQ_FIRST(ruleset->rules.active.ptr);
	while (r != NULL) {
		r->evaluations++;
		PF_TEST_ATTRIB(
		    (pfi_kif_match(r->kif, ctx->pd->kif) == r->ifnot),
			r->skip[PF_SKIP_IFP].ptr);
		PF_TEST_ATTRIB((r->direction && r->direction != ctx->pd->dir),
			r->skip[PF_SKIP_DIR].ptr);
		PF_TEST_ATTRIB((r->onrdomain >= 0  &&
		    (r->onrdomain == ctx->pd->rdomain) == r->ifnot),
			r->skip[PF_SKIP_RDOM].ptr);
		PF_TEST_ATTRIB((r->af && r->af != ctx->pd->af),
			r->skip[PF_SKIP_AF].ptr);
		PF_TEST_ATTRIB((r->proto && r->proto != ctx->pd->proto),
			r->skip[PF_SKIP_PROTO].ptr);
		PF_TEST_ATTRIB((PF_MISMATCHAW(&r->src.addr, &ctx->pd->nsaddr,
		    ctx->pd->naf, r->src.neg, ctx->pd->kif,
		    ctx->act.rtableid)),
			r->skip[PF_SKIP_SRC_ADDR].ptr);
		PF_TEST_ATTRIB((PF_MISMATCHAW(&r->dst.addr, &ctx->pd->ndaddr,
		    ctx->pd->af, r->dst.neg, NULL, ctx->act.rtableid)),
			r->skip[PF_SKIP_DST_ADDR].ptr);

		switch (ctx->pd->virtual_proto) {
		case PF_VPROTO_FRAGMENT:
			/* tcp/udp only. port_op always 0 in other cases */
			PF_TEST_ATTRIB((r->src.port_op || r->dst.port_op),
				TAILQ_NEXT(r, entries));
			PF_TEST_ATTRIB((ctx->pd->proto == IPPROTO_TCP &&
			    r->flagset),
				TAILQ_NEXT(r, entries));
			/* icmp only. type/code always 0 in other cases */
			PF_TEST_ATTRIB((r->type || r->code),
				TAILQ_NEXT(r, entries));
			/* tcp/udp only. {uid|gid}.op always 0 in other cases */
			PF_TEST_ATTRIB((r->gid.op || r->uid.op),
				TAILQ_NEXT(r, entries));
			break;

		case IPPROTO_TCP:
			PF_TEST_ATTRIB(((r->flagset & ctx->th->th_flags) !=
			    r->flags),
				TAILQ_NEXT(r, entries));
			PF_TEST_ATTRIB((r->os_fingerprint != PF_OSFP_ANY &&
			    !pf_osfp_match(pf_osfp_fingerprint(ctx->pd),
			    r->os_fingerprint)),
				TAILQ_NEXT(r, entries));
			/* FALLTHROUGH */

		case IPPROTO_UDP:
			/* tcp/udp only. port_op always 0 in other cases */
			PF_TEST_ATTRIB((r->src.port_op &&
			    !pf_match_port(r->src.port_op, r->src.port[0],
			    r->src.port[1], ctx->pd->nsport)),
				r->skip[PF_SKIP_SRC_PORT].ptr);
			PF_TEST_ATTRIB((r->dst.port_op &&
			    !pf_match_port(r->dst.port_op, r->dst.port[0],
			    r->dst.port[1], ctx->pd->ndport)),
				r->skip[PF_SKIP_DST_PORT].ptr);
			/* tcp/udp only. uid.op always 0 in other cases */
			PF_TEST_ATTRIB((r->uid.op && (ctx->pd->lookup.done ||
			    (ctx->pd->lookup.done =
			    pf_socket_lookup(ctx->pd), 1)) &&
			    !pf_match_uid(r->uid.op, r->uid.uid[0],
			    r->uid.uid[1], ctx->pd->lookup.uid)),
				TAILQ_NEXT(r, entries));
			/* tcp/udp only. gid.op always 0 in other cases */
			PF_TEST_ATTRIB((r->gid.op && (ctx->pd->lookup.done ||
			    (ctx->pd->lookup.done =
			    pf_socket_lookup(ctx->pd), 1)) &&
			    !pf_match_gid(r->gid.op, r->gid.gid[0],
			    r->gid.gid[1], ctx->pd->lookup.gid)),
				TAILQ_NEXT(r, entries));
			break;

		case IPPROTO_ICMP:
		case IPPROTO_ICMPV6:
			/* icmp only. type always 0 in other cases */
			PF_TEST_ATTRIB((r->type &&
			    r->type != ctx->icmptype + 1),
				TAILQ_NEXT(r, entries));
			/* icmp only. type always 0 in other cases */
			PF_TEST_ATTRIB((r->code &&
			    r->code != ctx->icmpcode + 1),
				TAILQ_NEXT(r, entries));
			/* icmp only. don't create states on replies */
			PF_TEST_ATTRIB((r->keep_state && !ctx->state_icmp &&
			    (r->rule_flag & PFRULE_STATESLOPPY) == 0 &&
			    ctx->icmp_dir != PF_IN),
				TAILQ_NEXT(r, entries));
			break;

		default:
			break;
		}

		PF_TEST_ATTRIB((r->rule_flag & PFRULE_FRAGMENT &&
		    ctx->pd->virtual_proto != PF_VPROTO_FRAGMENT),
			TAILQ_NEXT(r, entries));
		PF_TEST_ATTRIB((r->tos && !(r->tos == ctx->pd->tos)),
			TAILQ_NEXT(r, entries));
		PF_TEST_ATTRIB((r->prob &&
		    r->prob <= arc4random_uniform(UINT_MAX - 1) + 1),
			TAILQ_NEXT(r, entries));
		PF_TEST_ATTRIB((r->match_tag &&
		    !pf_match_tag(ctx->pd->m, r, &ctx->tag)),
			TAILQ_NEXT(r, entries));
		PF_TEST_ATTRIB((r->rcv_kif && pf_match_rcvif(ctx->pd->m, r) ==
		    r->rcvifnot),
			TAILQ_NEXT(r, entries));
		PF_TEST_ATTRIB((r->prio &&
		    (r->prio == PF_PRIO_ZERO ? 0 : r->prio) !=
		    ctx->pd->m->m_pkthdr.pf.prio),
			TAILQ_NEXT(r, entries));

		/* FALLTHROUGH */
		if (r->tag)
			ctx->tag = r->tag;
		if (r->anchor == NULL) {
			if (r->action == PF_MATCH) {
				if ((ctx->ri = pool_get(&pf_rule_item_pl,
				    PR_NOWAIT)) == NULL) {
					REASON_SET(&ctx->reason, PFRES_MEMORY);
					ctx->test_status = PF_TEST_FAIL;
					break;
				}
				ctx->ri->r = r;
				/* order is irrelevant */
				SLIST_INSERT_HEAD(&ctx->rules, ctx->ri, entry);
				ctx->ri = NULL;
				pf_rule_to_actions(r, &ctx->act);
				if (r->rule_flag & PFRULE_AFTO)
					ctx->pd->naf = r->naf;
				if (pf_get_transaddr(r, ctx->pd, ctx->sns,
				    &ctx->nr) == -1) {
					REASON_SET(&ctx->reason,
					    PFRES_TRANSLATE);
					ctx->test_status = PF_TEST_FAIL;
					break;
				}
#if NPFLOG > 0
				if (r->log) {
					REASON_SET(&ctx->reason, PFRES_MATCH);
					PFLOG_PACKET(ctx->pd, ctx->reason, r,
					    ctx->a, ruleset, NULL);
				}
#endif	/* NPFLOG > 0 */
			} else {
				/*
				 * found matching r
				 */
				*ctx->rm = r;
				/*
				 * anchor, with ruleset, where r belongs to
				 */
				*ctx->am = ctx->a;
				/*
				 * ruleset where r belongs to
				 */
				*ctx->rsm = ruleset;
				/*
				 * ruleset, where anchor belongs to.
				 */
				ctx->arsm = ctx->aruleset;
			}

#if NPFLOG > 0
			if (ctx->act.log & PF_LOG_MATCHES)
				pf_log_matches(ctx->pd, r, ctx->a, ruleset,
				    &ctx->rules);
#endif	/* NPFLOG > 0 */

			if (r->quick) {
				ctx->test_status = PF_TEST_QUICK;
				break;
			}
		} else {
			ctx->a = r;		/* remember anchor */
			ctx->aruleset = ruleset;	/* and its ruleset */
			if (pf_step_into_anchor(ctx, r) != PF_TEST_OK) {
				break;
			}
		}
		r = TAILQ_NEXT(r, entries);
	}

	return (ctx->test_status);
}

int
pf_test_rule(struct pf_pdesc *pd, struct pf_rule **rm, struct pf_state **sm,
    struct pf_rule **am, struct pf_ruleset **rsm, u_short *reason)
{
	struct pf_rule		*r = NULL;
	struct pf_rule		*a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_state_key	*skw = NULL, *sks = NULL;
	int			 rewrite = 0;
	u_int16_t		 virtual_type, virtual_id;
	int			 action = PF_DROP;
	struct pf_test_ctx	 ctx;
	int			 rv;

	bzero(&ctx, sizeof(ctx));
	ctx.pd = pd;
	ctx.rm = rm;
	ctx.am = am;
	ctx.rsm = rsm;
	ctx.th = &pd->hdr.tcp;
	ctx.act.rtableid = pd->rdomain;
	ctx.tag = -1;
	SLIST_INIT(&ctx.rules);

	if (pd->dir == PF_IN && if_congested()) {
		REASON_SET(&ctx.reason, PFRES_CONGEST);
		return (PF_DROP);
	}

	switch (pd->virtual_proto) {
	case IPPROTO_ICMP:
		ctx.icmptype = pd->hdr.icmp.icmp_type;
		ctx.icmpcode = pd->hdr.icmp.icmp_code;
		ctx.state_icmp = pf_icmp_mapping(pd, ctx.icmptype,
		    &ctx.icmp_dir, &virtual_id, &virtual_type);
		if (ctx.icmp_dir == PF_IN) {
			pd->osport = pd->nsport = virtual_id;
			pd->odport = pd->ndport = virtual_type;
		} else {
			pd->osport = pd->nsport = virtual_type;
			pd->odport = pd->ndport = virtual_id;
		}
		break;
#ifdef INET6
	case IPPROTO_ICMPV6:
		ctx.icmptype = pd->hdr.icmp6.icmp6_type;
		ctx.icmpcode = pd->hdr.icmp6.icmp6_code;
		ctx.state_icmp = pf_icmp_mapping(pd, ctx.icmptype,
		    &ctx.icmp_dir, &virtual_id, &virtual_type);
		if (ctx.icmp_dir == PF_IN) {
			pd->osport = pd->nsport = virtual_id;
			pd->odport = pd->ndport = virtual_type;
		} else {
			pd->osport = pd->nsport = virtual_type;
			pd->odport = pd->ndport = virtual_id;
		}
		break;
#endif /* INET6 */
	}

	ruleset = &pf_main_ruleset;
	rv = pf_match_rule(&ctx, ruleset);
	if (rv == PF_TEST_FAIL) {
		/*
		 * Reason has been set in pf_match_rule() already.
		 */
		goto cleanup;
	}

	r = *ctx.rm;	/* matching rule */
	a = *ctx.am;	/* rule that defines an anchor containing 'r' */
	ruleset = *ctx.rsm;/* ruleset of the anchor defined by the rule 'a' */
	ctx.aruleset = ctx.arsm;/* ruleset of the 'a' rule itself */



	/* apply actions for last matching pass/block rule */
	pf_rule_to_actions(r, &ctx.act);
	if (r->rule_flag & PFRULE_AFTO)
		pd->naf = r->naf;
	if (pf_get_transaddr(r, pd, ctx.sns, &ctx.nr) == -1) {
		REASON_SET(&ctx.reason, PFRES_TRANSLATE);
		goto cleanup;
	}
	REASON_SET(&ctx.reason, PFRES_MATCH);

#if NPFLOG > 0
	if (r->log)
		PFLOG_PACKET(pd, ctx.reason, r, ctx.a, ruleset, NULL);
	if (ctx.act.log & PF_LOG_MATCHES)
		pf_log_matches(pd, r, ctx.a, ruleset, &ctx.rules);
#endif	/* NPFLOG > 0 */

	if (pd->virtual_proto != PF_VPROTO_FRAGMENT &&
	    (r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNRST) ||
	    (r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		if (pd->proto == IPPROTO_TCP &&
		    ((r->rule_flag & PFRULE_RETURNRST) ||
		    (r->rule_flag & PFRULE_RETURN)) &&
		    !(ctx.th->th_flags & TH_RST)) {
			u_int32_t	 ack =
			    ntohl(ctx.th->th_seq) + pd->p_len;

			if (pf_check_tcp_cksum(pd->m, pd->off,
			    pd->tot_len - pd->off, pd->af))
				REASON_SET(&ctx.reason, PFRES_PROTCKSUM);
			else {
				if (ctx.th->th_flags & TH_SYN)
					ack++;
				if (ctx.th->th_flags & TH_FIN)
					ack++;
				pf_send_tcp(r, pd->af, pd->dst,
				    pd->src, ctx.th->th_dport,
				    ctx.th->th_sport, ntohl(ctx.th->th_ack),
				    ack, TH_RST|TH_ACK, 0, 0, r->return_ttl,
				    1, 0, pd->rdomain);
			}
		} else if ((pd->proto != IPPROTO_ICMP ||
		    ICMP_INFOTYPE(ctx.icmptype)) && pd->af == AF_INET &&
		    r->return_icmp)
			pf_send_icmp(pd->m, r->return_icmp >> 8,
			    r->return_icmp & 255, pd->af, r, pd->rdomain);
		else if ((pd->proto != IPPROTO_ICMPV6 ||
		    (ctx.icmptype >= ICMP6_ECHO_REQUEST &&
		    ctx.icmptype != ND_REDIRECT)) && pd->af == AF_INET6 &&
		    r->return_icmp6)
			pf_send_icmp(pd->m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, pd->af, r, pd->rdomain);
	}

	if (r->action == PF_DROP)
		goto cleanup;

	pf_tag_packet(pd->m, ctx.tag, ctx.act.rtableid);
	if (ctx.act.rtableid >= 0 &&
	    rtable_l2(ctx.act.rtableid) != pd->rdomain)
		pd->destchg = 1;

	if (r->action == PF_PASS && pd->badopts && ! r->allow_opts) {
		REASON_SET(&ctx.reason, PFRES_IPOPTIONS);
#if NPFLOG > 0
		pd->pflog |= PF_LOG_FORCE;
#endif	/* NPFLOG > 0 */
		DPFPRINTF(LOG_NOTICE, "dropping packet with "
		    "ip/ipv6 options in pf_test_rule()");
		goto cleanup;
	}

	action = PF_PASS;

	if (pd->virtual_proto != PF_VPROTO_FRAGMENT
	    && !ctx.state_icmp && r->keep_state) {

		if (r->rule_flag & PFRULE_SRCTRACK &&
		    pf_insert_src_node(&ctx.sns[PF_SN_NONE], r, PF_SN_NONE,
		    pd->af, pd->src, NULL) != 0) {
			REASON_SET(&ctx.reason, PFRES_SRCLIMIT);
			goto cleanup;
		}

		if (r->max_states && (r->states_cur >= r->max_states)) {
			pf_status.lcounters[LCNT_STATES]++;
			REASON_SET(&ctx.reason, PFRES_MAXSTATES);
			goto cleanup;
		}

		action = pf_create_state(pd, r, a, ctx.nr, &skw, &sks,
		    &rewrite, sm, ctx.tag, &ctx.rules, &ctx.act, ctx.sns);

		if (action != PF_PASS)
			goto cleanup;
		if (sks != skw) {
			struct pf_state_key	*sk;

			if (pd->dir == PF_IN)
				sk = sks;
			else
				sk = skw;
			rewrite += pf_translate(pd,
			    &sk->addr[pd->af == pd->naf ? pd->sidx : pd->didx],
			    sk->port[pd->af == pd->naf ? pd->sidx : pd->didx],
			    &sk->addr[pd->af == pd->naf ? pd->didx : pd->sidx],
			    sk->port[pd->af == pd->naf ? pd->didx : pd->sidx],
			    virtual_type, ctx.icmp_dir);
		}

#ifdef INET6
		if (rewrite && skw->af != sks->af)
			action = PF_AFRT;
#endif /* INET6 */

	} else {
		while ((ctx.ri = SLIST_FIRST(&ctx.rules))) {
			SLIST_REMOVE_HEAD(&ctx.rules, entry);
			pool_put(&pf_rule_item_pl, ctx.ri);
		}
	}

	/* copy back packet headers if needed */
	if (rewrite && pd->hdrlen) {
		m_copyback(pd->m, pd->off, pd->hdrlen, &pd->hdr, M_NOWAIT);
	}

#if NPFSYNC > 0
	if (*sm != NULL && !ISSET((*sm)->state_flags, PFSTATE_NOSYNC) &&
	    pd->dir == PF_OUT && pfsync_up()) {
		/*
		 * We want the state created, but we dont
		 * want to send this in case a partner
		 * firewall has to know about it to allow
		 * replies through it.
		 */
		if (pfsync_defer(*sm, pd->m))
			return (PF_DEFER);
	}
#endif	/* NPFSYNC > 0 */

	if (r->rule_flag & PFRULE_ONCE) {
		r->rule_flag |= PFRULE_EXPIRED;
		r->exptime = time_second;
		SLIST_INSERT_HEAD(&pf_rule_gcl, r, gcle);
	}

	return (action);

cleanup:
	while ((ctx.ri = SLIST_FIRST(&ctx.rules))) {
		SLIST_REMOVE_HEAD(&ctx.rules, entry);
		pool_put(&pf_rule_item_pl, ctx.ri);
	}

	return (action);
}

static __inline int
pf_create_state(struct pf_pdesc *pd, struct pf_rule *r, struct pf_rule *a,
    struct pf_rule *nr, struct pf_state_key **skw, struct pf_state_key **sks,
    int *rewrite, struct pf_state **sm, int tag, struct pf_rule_slist *rules,
    struct pf_rule_actions *act, struct pf_src_node *sns[PF_SN_MAX])
{
	struct pf_state		*s = NULL;
	struct tcphdr		*th = &pd->hdr.tcp;
	u_int16_t		 mss = tcp_mssdflt;
	u_short			 reason;
	u_int			 i;

	s = pool_get(&pf_state_pl, PR_NOWAIT | PR_ZERO);
	if (s == NULL) {
		REASON_SET(&reason, PFRES_MEMORY);
		goto csfailed;
	}
	s->rule.ptr = r;
	s->anchor.ptr = a;
	s->natrule.ptr = nr;
	if (r->allow_opts)
		s->state_flags |= PFSTATE_ALLOWOPTS;
	if (r->rule_flag & PFRULE_STATESLOPPY)
		s->state_flags |= PFSTATE_SLOPPY;
	if (r->rule_flag & PFRULE_PFLOW)
		s->state_flags |= PFSTATE_PFLOW;
#if NPFLOG > 0
	s->log = act->log & PF_LOG_ALL;
#endif	/* NPFLOG > 0 */
	s->qid = act->qid;
	s->pqid = act->pqid;
	s->rtableid[pd->didx] = act->rtableid;
	s->rtableid[pd->sidx] = -1;	/* return traffic is routed normally */
	s->min_ttl = act->min_ttl;
	s->set_tos = act->set_tos;
	s->max_mss = act->max_mss;
	s->state_flags |= act->flags;
#if NPFSYNC > 0
	s->sync_state = PFSYNC_S_NONE;
#endif	/* NPFSYNC > 0 */
	s->set_prio[0] = act->set_prio[0];
	s->set_prio[1] = act->set_prio[1];
	SLIST_INIT(&s->src_nodes);

	switch (pd->proto) {
	case IPPROTO_TCP:
		s->src.seqlo = ntohl(th->th_seq);
		s->src.seqhi = s->src.seqlo + pd->p_len + 1;
		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
		    r->keep_state == PF_STATE_MODULATE) {
			/* Generate sequence number modulator */
			if ((s->src.seqdiff = pf_tcp_iss(pd) - s->src.seqlo) ==
			    0)
				s->src.seqdiff = 1;
			pf_patch_32(pd,
			    &th->th_seq, htonl(s->src.seqlo + s->src.seqdiff));
			*rewrite = 1;
		} else
			s->src.seqdiff = 0;
		if (th->th_flags & TH_SYN) {
			s->src.seqhi++;
			s->src.wscale = pf_get_wscale(pd);
		}
		s->src.max_win = MAX(ntohs(th->th_win), 1);
		if (s->src.wscale & PF_WSCALE_MASK) {
			/* Remove scale factor from initial window */
			int win = s->src.max_win;
			win += 1 << (s->src.wscale & PF_WSCALE_MASK);
			s->src.max_win = (win - 1) >>
			    (s->src.wscale & PF_WSCALE_MASK);
		}
		if (th->th_flags & TH_FIN)
			s->src.seqhi++;
		s->dst.seqhi = 1;
		s->dst.max_win = 1;
		s->src.state = TCPS_SYN_SENT;
		s->dst.state = TCPS_CLOSED;
		s->timeout = PFTM_TCP_FIRST_PACKET;
		break;
	case IPPROTO_UDP:
		s->src.state = PFUDPS_SINGLE;
		s->dst.state = PFUDPS_NO_TRAFFIC;
		s->timeout = PFTM_UDP_FIRST_PACKET;
		break;
	case IPPROTO_ICMP:
#ifdef INET6
	case IPPROTO_ICMPV6:
#endif	/* INET6 */
		s->timeout = PFTM_ICMP_FIRST_PACKET;
		break;
	default:
		s->src.state = PFOTHERS_SINGLE;
		s->dst.state = PFOTHERS_NO_TRAFFIC;
		s->timeout = PFTM_OTHER_FIRST_PACKET;
	}

	s->creation = time_uptime;
	s->expire = time_uptime;

	if (pd->proto == IPPROTO_TCP) {
		if (s->state_flags & PFSTATE_SCRUB_TCP &&
		    pf_normalize_tcp_init(pd, &s->src)) {
			REASON_SET(&reason, PFRES_MEMORY);
			goto csfailed;
		}
		if (s->state_flags & PFSTATE_SCRUB_TCP && s->src.scrub &&
		    pf_normalize_tcp_stateful(pd, &reason, s, &s->src, &s->dst,
		    rewrite)) {
			/* This really shouldn't happen!!! */
			DPFPRINTF(LOG_ERR,
			    "%s: tcp normalize failed on first pkt", __func__);
			goto csfailed;
		}
	}
	s->direction = pd->dir;

	if (pf_state_key_setup(pd, skw, sks, act->rtableid)) {
		REASON_SET(&reason, PFRES_MEMORY);
		goto csfailed;
	}

	for (i = 0; i < PF_SN_MAX; i++)
		if (sns[i] != NULL) {
			struct pf_sn_item	*sni;

			sni = pool_get(&pf_sn_item_pl, PR_NOWAIT);
			if (sni == NULL) {
				REASON_SET(&reason, PFRES_MEMORY);
				goto csfailed;
			}
			sni->sn = sns[i];
			SLIST_INSERT_HEAD(&s->src_nodes, sni, next);
			sni->sn->states++;
		}

	if (pf_set_rt_ifp(s, pd->src, (*skw)->af) != 0) {
		REASON_SET(&reason, PFRES_NOROUTE);
		goto csfailed;
	}

	if (pf_state_insert(BOUND_IFACE(r, pd->kif), skw, sks, s)) {
		pf_detach_state(s);
		*sks = *skw = NULL;
		REASON_SET(&reason, PFRES_STATEINS);
		goto csfailed;
	} else
		*sm = s;

	/*
	 * Make state responsible for rules it binds here.
	 */
	memcpy(&s->match_rules, rules, sizeof(s->match_rules));
	bzero(rules, sizeof(*rules));
	STATE_INC_COUNTERS(s);

	if (tag > 0) {
		pf_tag_ref(tag);
		s->tag = tag;
	}
	if (pd->proto == IPPROTO_TCP && (th->th_flags & (TH_SYN|TH_ACK)) ==
	    TH_SYN && r->keep_state == PF_STATE_SYNPROXY) {
		int rtid = pd->rdomain;
		if (act->rtableid >= 0)
			rtid = act->rtableid;
		s->src.state = PF_TCPS_PROXY_SRC;
		s->src.seqhi = arc4random();
		/* Find mss option */
		mss = pf_get_mss(pd);
		mss = pf_calc_mss(pd->src, pd->af, rtid, mss);
		mss = pf_calc_mss(pd->dst, pd->af, rtid, mss);
		s->src.mss = mss;
		pf_send_tcp(r, pd->af, pd->dst, pd->src, th->th_dport,
		    th->th_sport, s->src.seqhi, ntohl(th->th_seq) + 1,
		    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, 0, pd->rdomain);
		REASON_SET(&reason, PFRES_SYNPROXY);
		return (PF_SYNPROXY_DROP);
	}

	return (PF_PASS);

csfailed:
	if (s) {
		pf_normalize_tcp_cleanup(s);	/* safe even w/o init */
		pf_src_tree_remove_state(s);
		pool_put(&pf_state_pl, s);
	}

	for (i = 0; i < PF_SN_MAX; i++)
		if (sns[i] != NULL)
			pf_remove_src_node(sns[i]);

	return (PF_DROP);
}

int
pf_translate(struct pf_pdesc *pd, struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport, u_int16_t virtual_type,
    int icmp_dir)
{
	/*
	 * when called from bpf_mtap_pflog, there are extra constraints:
	 * -mbuf is faked, m_data is the bpf buffer
	 * -pd is not fully set up
	 */
	int	rewrite = 0;
	int	afto = pd->af != pd->naf;

	if (afto || PF_ANEQ(daddr, pd->dst, pd->af))
		pd->destchg = 1;

	switch (pd->proto) {
	case IPPROTO_TCP:	/* FALLTHROUGH */
	case IPPROTO_UDP:
		rewrite += pf_patch_16(pd, pd->sport, sport);
		rewrite += pf_patch_16(pd, pd->dport, dport);
		break;

	case IPPROTO_ICMP:
		/* pf_translate() is also used when logging invalid packets */
		if (pd->af != AF_INET)
			return (0);

		if (afto) {
#ifdef INET6
			if (pf_translate_icmp_af(pd, AF_INET6, &pd->hdr.icmp))
				return (0);
			pd->proto = IPPROTO_ICMPV6;
			rewrite = 1;
#endif /* INET6 */
		}
		if (virtual_type == htons(ICMP_ECHO)) {
			u_int16_t icmpid = (icmp_dir == PF_IN) ? sport : dport;
			rewrite += pf_patch_16(pd,
			    &pd->hdr.icmp.icmp_id, icmpid);
		}
		break;

#ifdef INET6
	case IPPROTO_ICMPV6:
		/* pf_translate() is also used when logging invalid packets */
		if (pd->af != AF_INET6)
			return (0);

		if (afto) {
			if (pf_translate_icmp_af(pd, AF_INET, &pd->hdr.icmp6))
				return (0);
			pd->proto = IPPROTO_ICMP;
			rewrite = 1;
		}
		if (virtual_type == htons(ICMP6_ECHO_REQUEST)) {
			u_int16_t icmpid = (icmp_dir == PF_IN) ? sport : dport;
			rewrite += pf_patch_16(pd,
			    &pd->hdr.icmp6.icmp6_id, icmpid);
		}
		break;
#endif /* INET6 */
	}

	if (!afto) {
		rewrite += pf_translate_a(pd, pd->src, saddr);
		rewrite += pf_translate_a(pd, pd->dst, daddr);
	}

	return (rewrite);
}

int
pf_tcp_track_full(struct pf_pdesc *pd, struct pf_state_peer *src,
    struct pf_state_peer *dst, struct pf_state **state, u_short *reason,
    int *copyback)
{
	struct tcphdr		*th = &pd->hdr.tcp;
	u_int16_t		 win = ntohs(th->th_win);
	u_int32_t		 ack, end, data_end, seq, orig_seq;
	u_int8_t		 sws, dws;
	int			 ackskew;

	if (src->wscale && dst->wscale && !(th->th_flags & TH_SYN)) {
		sws = src->wscale & PF_WSCALE_MASK;
		dws = dst->wscale & PF_WSCALE_MASK;
	} else
		sws = dws = 0;

	/*
	 * Sequence tracking algorithm from Guido van Rooij's paper:
	 *   http://www.madison-gurkha.com/publications/tcp_filtering/
	 *	tcp_filtering.ps
	 */

	orig_seq = seq = ntohl(th->th_seq);
	if (src->seqlo == 0) {
		/* First packet from this end. Set its state */

		if (((*state)->state_flags & PFSTATE_SCRUB_TCP || dst->scrub) &&
		    src->scrub == NULL) {
			if (pf_normalize_tcp_init(pd, src)) {
				REASON_SET(reason, PFRES_MEMORY);
				return (PF_DROP);
			}
		}

		/* Deferred generation of sequence number modulator */
		if (dst->seqdiff && !src->seqdiff) {
			/* use random iss for the TCP server */
			while ((src->seqdiff = arc4random() - seq) == 0)
				continue;
			ack = ntohl(th->th_ack) - dst->seqdiff;
			pf_patch_32(pd, &th->th_seq, htonl(seq + src->seqdiff));
			pf_patch_32(pd, &th->th_ack, htonl(ack));
			*copyback = 1;
		} else {
			ack = ntohl(th->th_ack);
		}

		end = seq + pd->p_len;
		if (th->th_flags & TH_SYN) {
			end++;
			if (dst->wscale & PF_WSCALE_FLAG) {
				src->wscale = pf_get_wscale(pd);
				if (src->wscale & PF_WSCALE_FLAG) {
					/* Remove scale factor from initial
					 * window */
					sws = src->wscale & PF_WSCALE_MASK;
					win = ((u_int32_t)win + (1 << sws) - 1)
					    >> sws;
					dws = dst->wscale & PF_WSCALE_MASK;
				} else {
					/* fixup other window */
					dst->max_win = MIN(TCP_MAXWIN,
					    (u_int32_t)dst->max_win <<
					    (dst->wscale & PF_WSCALE_MASK));
					/* in case of a retrans SYN|ACK */
					dst->wscale = 0;
				}
			}
		}
		data_end = end;
		if (th->th_flags & TH_FIN)
			end++;

		src->seqlo = seq;
		if (src->state < TCPS_SYN_SENT)
			src->state = TCPS_SYN_SENT;

		/*
		 * May need to slide the window (seqhi may have been set by
		 * the crappy stack check or if we picked up the connection
		 * after establishment)
		 */
		if (src->seqhi == 1 ||
		    SEQ_GEQ(end + MAX(1, dst->max_win << dws), src->seqhi))
			src->seqhi = end + MAX(1, dst->max_win << dws);
		if (win > src->max_win)
			src->max_win = win;

	} else {
		ack = ntohl(th->th_ack) - dst->seqdiff;
		if (src->seqdiff) {
			/* Modulate sequence numbers */
			pf_patch_32(pd, &th->th_seq, htonl(seq + src->seqdiff));
			pf_patch_32(pd, &th->th_ack, htonl(ack));
			*copyback = 1;
		}
		end = seq + pd->p_len;
		if (th->th_flags & TH_SYN)
			end++;
		data_end = end;
		if (th->th_flags & TH_FIN)
			end++;
	}

	if ((th->th_flags & TH_ACK) == 0) {
		/* Let it pass through the ack skew check */
		ack = dst->seqlo;
	} else if ((ack == 0 &&
	    (th->th_flags & (TH_ACK|TH_RST)) == (TH_ACK|TH_RST)) ||
	    /* broken tcp stacks do not set ack */
	    (dst->state < TCPS_SYN_SENT)) {
		/*
		 * Many stacks (ours included) will set the ACK number in an
		 * FIN|ACK if the SYN times out -- no sequence to ACK.
		 */
		ack = dst->seqlo;
	}

	if (seq == end) {
		/* Ease sequencing restrictions on no data packets */
		seq = src->seqlo;
		data_end = end = seq;
	}

	ackskew = dst->seqlo - ack;


	/*
	 * Need to demodulate the sequence numbers in any TCP SACK options
	 * (Selective ACK). We could optionally validate the SACK values
	 * against the current ACK window, either forwards or backwards, but
	 * I'm not confident that SACK has been implemented properly
	 * everywhere. It wouldn't surprise me if several stacks accidently
	 * SACK too far backwards of previously ACKed data. There really aren't
	 * any security implications of bad SACKing unless the target stack
	 * doesn't validate the option length correctly. Someone trying to
	 * spoof into a TCP connection won't bother blindly sending SACK
	 * options anyway.
	 */
	if (dst->seqdiff && (th->th_off << 2) > sizeof(struct tcphdr)) {
		if (pf_modulate_sack(pd, dst))
			*copyback = 1;
	}


#define MAXACKWINDOW (0xffff + 1500)	/* 1500 is an arbitrary fudge factor */
	if (SEQ_GEQ(src->seqhi, data_end) &&
	    /* Last octet inside other's window space */
	    SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws)) &&
	    /* Retrans: not more than one window back */
	    (ackskew >= -MAXACKWINDOW) &&
	    /* Acking not more than one reassembled fragment backwards */
	    (ackskew <= (MAXACKWINDOW << sws)) &&
	    /* Acking not more than one window forward */
	    ((th->th_flags & TH_RST) == 0 || orig_seq == src->seqlo ||
	    (orig_seq == src->seqlo + 1) || (orig_seq + 1 == src->seqlo))) {
	    /* Require an exact/+1 sequence match on resets when possible */

		if (dst->scrub || src->scrub) {
			if (pf_normalize_tcp_stateful(pd, reason, *state, src,
			    dst, copyback))
				return (PF_DROP);
		}

		/* update max window */
		if (src->max_win < win)
			src->max_win = win;
		/* synchronize sequencing */
		if (SEQ_GT(end, src->seqlo))
			src->seqlo = end;
		/* slide the window of what the other end can send */
		if (SEQ_GEQ(ack + (win << sws), dst->seqhi))
			dst->seqhi = ack + MAX((win << sws), 1);

		/* update states */
		if (th->th_flags & TH_SYN)
			if (src->state < TCPS_SYN_SENT)
				src->state = TCPS_SYN_SENT;
		if (th->th_flags & TH_FIN)
			if (src->state < TCPS_CLOSING)
				src->state = TCPS_CLOSING;
		if (th->th_flags & TH_ACK) {
			if (dst->state == TCPS_SYN_SENT) {
				dst->state = TCPS_ESTABLISHED;
				if (src->state == TCPS_ESTABLISHED &&
				    !SLIST_EMPTY(&(*state)->src_nodes) &&
				    pf_src_connlimit(state)) {
					REASON_SET(reason, PFRES_SRCLIMIT);
					return (PF_DROP);
				}
			} else if (dst->state == TCPS_CLOSING)
				dst->state = TCPS_FIN_WAIT_2;
		}
		if (th->th_flags & TH_RST)
			src->state = dst->state = TCPS_TIME_WAIT;

		/* update expire time */
		(*state)->expire = time_uptime;
		if (src->state >= TCPS_FIN_WAIT_2 &&
		    dst->state >= TCPS_FIN_WAIT_2)
			(*state)->timeout = PFTM_TCP_CLOSED;
		else if (src->state >= TCPS_CLOSING &&
		    dst->state >= TCPS_CLOSING)
			(*state)->timeout = PFTM_TCP_FIN_WAIT;
		else if (src->state < TCPS_ESTABLISHED ||
		    dst->state < TCPS_ESTABLISHED)
			(*state)->timeout = PFTM_TCP_OPENING;
		else if (src->state >= TCPS_CLOSING ||
		    dst->state >= TCPS_CLOSING)
			(*state)->timeout = PFTM_TCP_CLOSING;
		else
			(*state)->timeout = PFTM_TCP_ESTABLISHED;

		/* Fall through to PASS packet */
	} else if ((dst->state < TCPS_SYN_SENT ||
		dst->state >= TCPS_FIN_WAIT_2 ||
		src->state >= TCPS_FIN_WAIT_2) &&
	    SEQ_GEQ(src->seqhi + MAXACKWINDOW, data_end) &&
	    /* Within a window forward of the originating packet */
	    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW)) {
	    /* Within a window backward of the originating packet */

		/*
		 * This currently handles three situations:
		 *  1) Stupid stacks will shotgun SYNs before their peer
		 *     replies.
		 *  2) When PF catches an already established stream (the
		 *     firewall rebooted, the state table was flushed, routes
		 *     changed...)
		 *  3) Packets get funky immediately after the connection
		 *     closes (this should catch Solaris spurious ACK|FINs
		 *     that web servers like to spew after a close)
		 *
		 * This must be a little more careful than the above code
		 * since packet floods will also be caught here. We don't
		 * update the TTL here to mitigate the damage of a packet
		 * flood and so the same code can handle awkward establishment
		 * and a loosened connection close.
		 * In the establishment case, a correct peer response will
		 * validate the connection, go through the normal state code
		 * and keep updating the state TTL.
		 */

		if (pf_status.debug >= LOG_NOTICE) {
			log(LOG_NOTICE, "pf: loose state match: ");
			pf_print_state(*state);
			pf_print_flags(th->th_flags);
			addlog(" seq=%u (%u) ack=%u len=%u ackskew=%d "
			    "pkts=%llu:%llu dir=%s,%s\n", seq, orig_seq, ack,
			    pd->p_len, ackskew, (*state)->packets[0],
			    (*state)->packets[1],
			    pd->dir == PF_IN ? "in" : "out",
			    pd->dir == (*state)->direction ? "fwd" : "rev");
		}

		if (dst->scrub || src->scrub) {
			if (pf_normalize_tcp_stateful(pd, reason, *state, src,
			    dst, copyback))
				return (PF_DROP);
		}

		/* update max window */
		if (src->max_win < win)
			src->max_win = win;
		/* synchronize sequencing */
		if (SEQ_GT(end, src->seqlo))
			src->seqlo = end;
		/* slide the window of what the other end can send */
		if (SEQ_GEQ(ack + (win << sws), dst->seqhi))
			dst->seqhi = ack + MAX((win << sws), 1);

		/*
		 * Cannot set dst->seqhi here since this could be a shotgunned
		 * SYN and not an already established connection.
		 */
		if (th->th_flags & TH_FIN)
			if (src->state < TCPS_CLOSING)
				src->state = TCPS_CLOSING;
		if (th->th_flags & TH_RST)
			src->state = dst->state = TCPS_TIME_WAIT;

		/* Fall through to PASS packet */
	} else {
		if ((*state)->dst.state == TCPS_SYN_SENT &&
		    (*state)->src.state == TCPS_SYN_SENT) {
			/* Send RST for state mismatches during handshake */
			if (!(th->th_flags & TH_RST))
				pf_send_tcp((*state)->rule.ptr, pd->af,
				    pd->dst, pd->src, th->th_dport,
				    th->th_sport, ntohl(th->th_ack), 0,
				    TH_RST, 0, 0,
				    (*state)->rule.ptr->return_ttl, 1, 0,
				    pd->rdomain);
			src->seqlo = 0;
			src->seqhi = 1;
			src->max_win = 1;
		} else if (pf_status.debug >= LOG_NOTICE) {
			log(LOG_NOTICE, "pf: BAD state: ");
			pf_print_state(*state);
			pf_print_flags(th->th_flags);
			addlog(" seq=%u (%u) ack=%u len=%u ackskew=%d "
			    "pkts=%llu:%llu dir=%s,%s\n",
			    seq, orig_seq, ack, pd->p_len, ackskew,
			    (*state)->packets[0], (*state)->packets[1],
			    pd->dir == PF_IN ? "in" : "out",
			    pd->dir == (*state)->direction ? "fwd" : "rev");
			addlog("pf: State failure on: %c %c %c %c | %c %c\n",
			    SEQ_GEQ(src->seqhi, data_end) ? ' ' : '1',
			    SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws)) ?
			    ' ': '2',
			    (ackskew >= -MAXACKWINDOW) ? ' ' : '3',
			    (ackskew <= (MAXACKWINDOW << sws)) ? ' ' : '4',
			    SEQ_GEQ(src->seqhi + MAXACKWINDOW, data_end) ?
			    ' ' :'5',
			    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW) ?' ' :'6');
		}
		REASON_SET(reason, PFRES_BADSTATE);
		return (PF_DROP);
	}

	return (PF_PASS);
}

int
pf_tcp_track_sloppy(struct pf_pdesc *pd, struct pf_state_peer *src,
    struct pf_state_peer *dst, struct pf_state **state, u_short *reason)
{
	struct tcphdr		*th = &pd->hdr.tcp;

	if (th->th_flags & TH_SYN)
		if (src->state < TCPS_SYN_SENT)
			src->state = TCPS_SYN_SENT;
	if (th->th_flags & TH_FIN)
		if (src->state < TCPS_CLOSING)
			src->state = TCPS_CLOSING;
	if (th->th_flags & TH_ACK) {
		if (dst->state == TCPS_SYN_SENT) {
			dst->state = TCPS_ESTABLISHED;
			if (src->state == TCPS_ESTABLISHED &&
			    !SLIST_EMPTY(&(*state)->src_nodes) &&
			    pf_src_connlimit(state)) {
				REASON_SET(reason, PFRES_SRCLIMIT);
				return (PF_DROP);
			}
		} else if (dst->state == TCPS_CLOSING) {
			dst->state = TCPS_FIN_WAIT_2;
		} else if (src->state == TCPS_SYN_SENT &&
		    dst->state < TCPS_SYN_SENT) {
			/*
			 * Handle a special sloppy case where we only see one
			 * half of the connection. If there is a ACK after
			 * the initial SYN without ever seeing a packet from
			 * the destination, set the connection to established.
			 */
			dst->state = src->state = TCPS_ESTABLISHED;
			if (!SLIST_EMPTY(&(*state)->src_nodes) &&
			    pf_src_connlimit(state)) {
				REASON_SET(reason, PFRES_SRCLIMIT);
				return (PF_DROP);
			}
		} else if (src->state == TCPS_CLOSING &&
		    dst->state == TCPS_ESTABLISHED &&
		    dst->seqlo == 0) {
			/*
			 * Handle the closing of half connections where we
			 * don't see the full bidirectional FIN/ACK+ACK
			 * handshake.
			 */
			dst->state = TCPS_CLOSING;
		}
	}
	if (th->th_flags & TH_RST)
		src->state = dst->state = TCPS_TIME_WAIT;

	/* update expire time */
	(*state)->expire = time_uptime;
	if (src->state >= TCPS_FIN_WAIT_2 &&
	    dst->state >= TCPS_FIN_WAIT_2)
		(*state)->timeout = PFTM_TCP_CLOSED;
	else if (src->state >= TCPS_CLOSING &&
	    dst->state >= TCPS_CLOSING)
		(*state)->timeout = PFTM_TCP_FIN_WAIT;
	else if (src->state < TCPS_ESTABLISHED ||
	    dst->state < TCPS_ESTABLISHED)
		(*state)->timeout = PFTM_TCP_OPENING;
	else if (src->state >= TCPS_CLOSING ||
	    dst->state >= TCPS_CLOSING)
		(*state)->timeout = PFTM_TCP_CLOSING;
	else
		(*state)->timeout = PFTM_TCP_ESTABLISHED;

	return (PF_PASS);
}

static __inline int
pf_synproxy(struct pf_pdesc *pd, struct pf_state **state, u_short *reason)
{
	struct pf_state_key	*sk = (*state)->key[pd->didx];

	if ((*state)->src.state == PF_TCPS_PROXY_SRC) {
		struct tcphdr	*th = &pd->hdr.tcp;

		if (pd->dir != (*state)->direction) {
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		}
		if (th->th_flags & TH_SYN) {
			if (ntohl(th->th_seq) != (*state)->src.seqlo) {
				REASON_SET(reason, PFRES_SYNPROXY);
				return (PF_DROP);
			}
			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    (*state)->src.seqhi, ntohl(th->th_seq) + 1,
			    TH_SYN|TH_ACK, 0, (*state)->src.mss, 0, 1,
			    0, pd->rdomain);
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		} else if ((th->th_flags & (TH_ACK|TH_RST|TH_FIN)) != TH_ACK ||
		    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
		    (ntohl(th->th_seq) != (*state)->src.seqlo + 1)) {
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_DROP);
		} else if (!SLIST_EMPTY(&(*state)->src_nodes) &&
		    pf_src_connlimit(state)) {
			REASON_SET(reason, PFRES_SRCLIMIT);
			return (PF_DROP);
		} else
			(*state)->src.state = PF_TCPS_PROXY_DST;
	}
	if ((*state)->src.state == PF_TCPS_PROXY_DST) {
		struct tcphdr	*th = &pd->hdr.tcp;

		if (pd->dir == (*state)->direction) {
			if (((th->th_flags & (TH_SYN|TH_ACK)) != TH_ACK) ||
			    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
			    (ntohl(th->th_seq) != (*state)->src.seqlo + 1)) {
				REASON_SET(reason, PFRES_SYNPROXY);
				return (PF_DROP);
			}
			(*state)->src.max_win = MAX(ntohs(th->th_win), 1);
			if ((*state)->dst.seqhi == 1)
				(*state)->dst.seqhi = arc4random();
			pf_send_tcp((*state)->rule.ptr, pd->af,
			    &sk->addr[pd->sidx], &sk->addr[pd->didx],
			    sk->port[pd->sidx], sk->port[pd->didx],
			    (*state)->dst.seqhi, 0, TH_SYN, 0,
			    (*state)->src.mss, 0, 0, (*state)->tag,
			    sk->rdomain);
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		} else if (((th->th_flags & (TH_SYN|TH_ACK)) !=
		    (TH_SYN|TH_ACK)) ||
		    (ntohl(th->th_ack) != (*state)->dst.seqhi + 1)) {
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_DROP);
		} else {
			(*state)->dst.max_win = MAX(ntohs(th->th_win), 1);
			(*state)->dst.seqlo = ntohl(th->th_seq);
			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    ntohl(th->th_ack), ntohl(th->th_seq) + 1,
			    TH_ACK, (*state)->src.max_win, 0, 0, 0,
			    (*state)->tag, pd->rdomain);
			pf_send_tcp((*state)->rule.ptr, pd->af,
			    &sk->addr[pd->sidx], &sk->addr[pd->didx],
			    sk->port[pd->sidx], sk->port[pd->didx],
			    (*state)->src.seqhi + 1, (*state)->src.seqlo + 1,
			    TH_ACK, (*state)->dst.max_win, 0, 0, 1,
			    0, sk->rdomain);
			(*state)->src.seqdiff = (*state)->dst.seqhi -
			    (*state)->src.seqlo;
			(*state)->dst.seqdiff = (*state)->src.seqhi -
			    (*state)->dst.seqlo;
			(*state)->src.seqhi = (*state)->src.seqlo +
			    (*state)->dst.max_win;
			(*state)->dst.seqhi = (*state)->dst.seqlo +
			    (*state)->src.max_win;
			(*state)->src.wscale = (*state)->dst.wscale = 0;
			(*state)->src.state = (*state)->dst.state =
			    TCPS_ESTABLISHED;
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		}
	}
	return (PF_PASS);
}

int
pf_test_state(struct pf_pdesc *pd, struct pf_state **state, u_short *reason)
{
	struct pf_state_key_cmp	 key;
	int			 copyback = 0;
	struct pf_state_peer	*src, *dst;
	int			 action = PF_PASS;
	struct inpcb		*inp;

	key.af = pd->af;
	key.proto = pd->virtual_proto;
	key.rdomain = pd->rdomain;
	PF_ACPY(&key.addr[pd->sidx], pd->src, key.af);
	PF_ACPY(&key.addr[pd->didx], pd->dst, key.af);
	key.port[pd->sidx] = pd->osport;
	key.port[pd->didx] = pd->odport;
	inp = pd->m->m_pkthdr.pf.inp;

	STATE_LOOKUP(pd->kif, &key, pd->dir, *state, pd->m);

	if (pd->dir == (*state)->direction) {
		src = &(*state)->src;
		dst = &(*state)->dst;
	} else {
		src = &(*state)->dst;
		dst = &(*state)->src;
	}

	switch (pd->virtual_proto) {
	case IPPROTO_TCP:
		if ((action = pf_synproxy(pd, state, reason)) != PF_PASS)
			return (action);
		if ((pd->hdr.tcp.th_flags & (TH_SYN|TH_ACK)) == TH_SYN) {

			if (dst->state >= TCPS_FIN_WAIT_2 &&
			    src->state >= TCPS_FIN_WAIT_2) {
				if (pf_status.debug >= LOG_NOTICE) {
					log(LOG_NOTICE, "pf: state reuse ");
					pf_print_state(*state);
					pf_print_flags(pd->hdr.tcp.th_flags);
					addlog("\n");
				}
				/* XXX make sure it's the same direction ?? */
				(*state)->src.state = TCPS_CLOSED;
				(*state)->dst.state = TCPS_CLOSED;
				pf_remove_state(*state);
				*state = NULL;
				pd->m->m_pkthdr.pf.inp = inp;
				return (PF_DROP);
			} else if (dst->state >= TCPS_ESTABLISHED &&
			    src->state >= TCPS_ESTABLISHED) {
				/*
				 * SYN matches existing state???
				 * Typically happens when sender boots up after
				 * sudden panic. Certain protocols (NFSv3) are
				 * always using same port numbers. Challenge
				 * ACK enables all parties (firewall and peers)
				 * to get in sync again.
				 */
				pf_send_challenge_ack(pd, *state, src, dst);
				return (PF_DROP);
			}
		}

		if ((*state)->state_flags & PFSTATE_SLOPPY) {
			if (pf_tcp_track_sloppy(pd, src, dst, state, reason) ==
			    PF_DROP)
				return (PF_DROP);
		} else {
			int	ret;

			if (PF_REVERSED_KEY((*state)->key, pd->af))
				ret = pf_tcp_track_full(pd, dst, src, state,
				    reason, &copyback);
			else
				ret = pf_tcp_track_full(pd, src, dst, state,
				    reason, &copyback);
			if (ret == PF_DROP)
				return (PF_DROP);
		}
		break;
	case IPPROTO_UDP:
		/* update states */
		if (src->state < PFUDPS_SINGLE)
			src->state = PFUDPS_SINGLE;
		if (dst->state == PFUDPS_SINGLE)
			dst->state = PFUDPS_MULTIPLE;

		/* update expire time */
		(*state)->expire = time_uptime;
		if (src->state == PFUDPS_MULTIPLE &&
		    dst->state == PFUDPS_MULTIPLE)
			(*state)->timeout = PFTM_UDP_MULTIPLE;
		else
			(*state)->timeout = PFTM_UDP_SINGLE;
		break;
	default:
		/* update states */
		if (src->state < PFOTHERS_SINGLE)
			src->state = PFOTHERS_SINGLE;
		if (dst->state == PFOTHERS_SINGLE)
			dst->state = PFOTHERS_MULTIPLE;

		/* update expire time */
		(*state)->expire = time_uptime;
		if (src->state == PFOTHERS_MULTIPLE &&
		    dst->state == PFOTHERS_MULTIPLE)
			(*state)->timeout = PFTM_OTHER_MULTIPLE;
		else
			(*state)->timeout = PFTM_OTHER_SINGLE;
		break;
	}

	/* translate source/destination address, if necessary */
	if ((*state)->key[PF_SK_WIRE] != (*state)->key[PF_SK_STACK]) {
		struct pf_state_key	*nk;
		int			 afto, sidx, didx;

		if (PF_REVERSED_KEY((*state)->key, pd->af))
			nk = (*state)->key[pd->sidx];
		else
			nk = (*state)->key[pd->didx];

		afto = pd->af != nk->af;
		sidx = afto ? pd->didx : pd->sidx;
		didx = afto ? pd->sidx : pd->didx;

#ifdef INET6
		if (afto) {
			PF_ACPY(&pd->nsaddr, &nk->addr[sidx], nk->af);
			PF_ACPY(&pd->ndaddr, &nk->addr[didx], nk->af);
			pd->naf = nk->af;
			action = PF_AFRT;
		}
#endif /* INET6 */

		if (!afto)
			pf_translate_a(pd, pd->src, &nk->addr[sidx]);

		if (pd->sport != NULL)
			pf_patch_16(pd, pd->sport, nk->port[sidx]);

		if (afto || PF_ANEQ(pd->dst, &nk->addr[didx], pd->af) ||
		    pd->rdomain != nk->rdomain)
			pd->destchg = 1;

		if (!afto)
			pf_translate_a(pd, pd->dst, &nk->addr[didx]);

		if (pd->dport != NULL)
			pf_patch_16(pd, pd->dport, nk->port[didx]);

		pd->m->m_pkthdr.ph_rtableid = nk->rdomain;
		copyback = 1;
	}

	if (copyback && pd->hdrlen > 0) {
		m_copyback(pd->m, pd->off, pd->hdrlen, &pd->hdr, M_NOWAIT);
	}

	return (action);
}

int
pf_icmp_state_lookup(struct pf_pdesc *pd, struct pf_state_key_cmp *key,
    struct pf_state **state, u_int16_t icmpid, u_int16_t type,
    int icmp_dir, int *iidx, int multi, int inner)
{
	int direction;

	key->af = pd->af;
	key->proto = pd->proto;
	key->rdomain = pd->rdomain;
	if (icmp_dir == PF_IN) {
		*iidx = pd->sidx;
		key->port[pd->sidx] = icmpid;
		key->port[pd->didx] = type;
	} else {
		*iidx = pd->didx;
		key->port[pd->sidx] = type;
		key->port[pd->didx] = icmpid;
	}

	if (pf_state_key_addr_setup(pd, key, pd->sidx, pd->src, pd->didx,
	    pd->dst, pd->af, multi))
		return (PF_DROP);

	STATE_LOOKUP(pd->kif, key, pd->dir, *state, pd->m);

	if ((*state)->state_flags & PFSTATE_SLOPPY)
		return (-1);

	/* Is this ICMP message flowing in right direction? */
	if ((*state)->key[PF_SK_WIRE]->af != (*state)->key[PF_SK_STACK]->af)
		direction = (pd->af == (*state)->key[PF_SK_WIRE]->af) ?
		    PF_IN : PF_OUT;
	else
		direction = (*state)->direction;
	if ((((!inner && direction == pd->dir) ||
	    (inner && direction != pd->dir)) ?
	    PF_IN : PF_OUT) != icmp_dir) {
		if (pf_status.debug >= LOG_NOTICE) {
			log(LOG_NOTICE,
			    "pf: icmp type %d in wrong direction (%d): ",
			    ntohs(type), icmp_dir);
			pf_print_state(*state);
			addlog("\n");
		}
		return (PF_DROP);
	}
	return (-1);
}

int
pf_test_state_icmp(struct pf_pdesc *pd, struct pf_state **state,
    u_short *reason)
{
	u_int16_t	 virtual_id, virtual_type;
	u_int8_t	 icmptype;
	int		 icmp_dir, iidx, ret, copyback = 0;

	struct pf_state_key_cmp key;

	switch (pd->proto) {
	case IPPROTO_ICMP:
		icmptype = pd->hdr.icmp.icmp_type;
		break;
#ifdef INET6
	case IPPROTO_ICMPV6:
		icmptype = pd->hdr.icmp6.icmp6_type;
		break;
#endif /* INET6 */
	default:
		panic("unhandled proto %d", pd->proto);
	}

	if (pf_icmp_mapping(pd, icmptype, &icmp_dir, &virtual_id,
	    &virtual_type) == 0) {
		/*
		 * ICMP query/reply message not related to a TCP/UDP packet.
		 * Search for an ICMP state.
		 */
		ret = pf_icmp_state_lookup(pd, &key, state,
		    virtual_id, virtual_type, icmp_dir, &iidx,
		    0, 0);
		/* IPv6? try matching a multicast address */
		if (ret == PF_DROP && pd->af == AF_INET6 && icmp_dir == PF_OUT)
			ret = pf_icmp_state_lookup(pd, &key, state, virtual_id,
			    virtual_type, icmp_dir, &iidx, 1, 0);
		if (ret >= 0)
			return (ret);

		(*state)->expire = time_uptime;
		(*state)->timeout = PFTM_ICMP_ERROR_REPLY;

		/* translate source/destination address, if necessary */
		if ((*state)->key[PF_SK_WIRE] != (*state)->key[PF_SK_STACK]) {
			struct pf_state_key	*nk;
			int			 afto, sidx, didx;

			if (PF_REVERSED_KEY((*state)->key, pd->af))
				nk = (*state)->key[pd->sidx];
			else
				nk = (*state)->key[pd->didx];

			afto = pd->af != nk->af;
			sidx = afto ? pd->didx : pd->sidx;
			didx = afto ? pd->sidx : pd->didx;
			iidx = afto ? !iidx : iidx;
#ifdef	INET6
			if (afto) {
				PF_ACPY(&pd->nsaddr, &nk->addr[sidx], nk->af);
				PF_ACPY(&pd->ndaddr, &nk->addr[didx], nk->af);
				pd->naf = nk->af;
			}
#endif /* INET6 */
			if (!afto) {
				pf_translate_a(pd, pd->src, &nk->addr[sidx]);
				pf_translate_a(pd, pd->dst, &nk->addr[didx]);
			}

			if (pd->rdomain != nk->rdomain)
				pd->destchg = 1;
			if (!afto && PF_ANEQ(pd->dst,
				&nk->addr[didx], pd->af))
				pd->destchg = 1;
			pd->m->m_pkthdr.ph_rtableid = nk->rdomain;

			switch (pd->af) {
			case AF_INET:
#ifdef INET6
				if (afto) {
					if (pf_translate_icmp_af(pd, AF_INET6,
					    &pd->hdr.icmp))
						return (PF_DROP);
					pd->proto = IPPROTO_ICMPV6;
				}
#endif /* INET6 */
				pf_patch_16(pd,
				    &pd->hdr.icmp.icmp_id, nk->port[iidx]);

				m_copyback(pd->m, pd->off, ICMP_MINLEN,
				    &pd->hdr.icmp, M_NOWAIT);
				copyback = 1;
				break;
#ifdef INET6
			case AF_INET6:
				if (afto) {
					if (pf_translate_icmp_af(pd, AF_INET,
					    &pd->hdr.icmp6))
						return (PF_DROP);
					pd->proto = IPPROTO_ICMP;
				}

				pf_patch_16(pd,
				    &pd->hdr.icmp6.icmp6_id, nk->port[iidx]);

				m_copyback(pd->m, pd->off,
				    sizeof(struct icmp6_hdr), &pd->hdr.icmp6,
				    M_NOWAIT);
				copyback = 1;
				break;
#endif /* INET6 */
			}
#ifdef	INET6
			if (afto)
				return (PF_AFRT);
#endif /* INET6 */
		}
	} else {
		/*
		 * ICMP error message in response to a TCP/UDP packet.
		 * Extract the inner TCP/UDP header and search for that state.
		 */
		struct pf_pdesc	 pd2;
		struct ip	 h2;
#ifdef INET6
		struct ip6_hdr	 h2_6;
#endif /* INET6 */
		int		 ipoff2;

		/* Initialize pd2 fields valid for both packets with pd. */
		bzero(&pd2, sizeof(pd2));
		pd2.af = pd->af;
		pd2.dir = pd->dir;
		pd2.kif = pd->kif;
		pd2.m = pd->m;
		pd2.rdomain = pd->rdomain;
		/* Payload packet is from the opposite direction. */
		pd2.sidx = (pd2.dir == PF_IN) ? 1 : 0;
		pd2.didx = (pd2.dir == PF_IN) ? 0 : 1;
		switch (pd->af) {
		case AF_INET:
			/* offset of h2 in mbuf chain */
			ipoff2 = pd->off + ICMP_MINLEN;

			if (!pf_pull_hdr(pd2.m, ipoff2, &h2, sizeof(h2),
			    NULL, reason, pd2.af)) {
				DPFPRINTF(LOG_NOTICE,
				    "ICMP error message too short (ip)");
				return (PF_DROP);
			}
			/*
			 * ICMP error messages don't refer to non-first
			 * fragments
			 */
			if (h2.ip_off & htons(IP_OFFMASK)) {
				REASON_SET(reason, PFRES_FRAG);
				return (PF_DROP);
			}

			/* offset of protocol header that follows h2 */
			pd2.off = ipoff2;
			if (pf_walk_header(&pd2, &h2, reason) != PF_PASS)
				return (PF_DROP);

			pd2.tot_len = ntohs(h2.ip_len);
			pd2.src = (struct pf_addr *)&h2.ip_src;
			pd2.dst = (struct pf_addr *)&h2.ip_dst;
			break;
#ifdef INET6
		case AF_INET6:
			ipoff2 = pd->off + sizeof(struct icmp6_hdr);

			if (!pf_pull_hdr(pd2.m, ipoff2, &h2_6, sizeof(h2_6),
			    NULL, reason, pd2.af)) {
				DPFPRINTF(LOG_NOTICE,
				    "ICMP error message too short (ip6)");
				return (PF_DROP);
			}

			pd2.off = ipoff2;
			if (pf_walk_header6(&pd2, &h2_6, reason) != PF_PASS)
				return (PF_DROP);

			pd2.tot_len = ntohs(h2_6.ip6_plen) +
			    sizeof(struct ip6_hdr);
			pd2.src = (struct pf_addr *)&h2_6.ip6_src;
			pd2.dst = (struct pf_addr *)&h2_6.ip6_dst;
			break;
#endif /* INET6 */
		default:
			unhandled_af(pd->af);
		}

		switch (pd2.proto) {
		case IPPROTO_TCP: {
			struct tcphdr		*th = &pd2.hdr.tcp;
			u_int32_t		 seq;
			struct pf_state_peer	*src, *dst;
			u_int8_t		 dws;

			/*
			 * Only the first 8 bytes of the TCP header can be
			 * expected. Don't access any TCP header fields after
			 * th_seq, an ackskew test is not possible.
			 */
			if (!pf_pull_hdr(pd2.m, pd2.off, th, 8, NULL, reason,
			    pd2.af)) {
				DPFPRINTF(LOG_NOTICE,
				    "ICMP error message too short (tcp)");
				return (PF_DROP);
			}

			key.af = pd2.af;
			key.proto = IPPROTO_TCP;
			key.rdomain = pd2.rdomain;
			PF_ACPY(&key.addr[pd2.sidx], pd2.src, key.af);
			PF_ACPY(&key.addr[pd2.didx], pd2.dst, key.af);
			key.port[pd2.sidx] = th->th_sport;
			key.port[pd2.didx] = th->th_dport;

			STATE_LOOKUP(pd2.kif, &key, pd2.dir, *state, pd2.m);

			if (pd2.dir == (*state)->direction) {
				if (PF_REVERSED_KEY((*state)->key, pd->af)) {
					src = &(*state)->src;
					dst = &(*state)->dst;
				} else {
					src = &(*state)->dst;
					dst = &(*state)->src;
				}
			} else {
				if (PF_REVERSED_KEY((*state)->key, pd->af)) {
					src = &(*state)->dst;
					dst = &(*state)->src;
				} else {
					src = &(*state)->src;
					dst = &(*state)->dst;
				}
			}

			if (src->wscale && dst->wscale)
				dws = dst->wscale & PF_WSCALE_MASK;
			else
				dws = 0;

			/* Demodulate sequence number */
			seq = ntohl(th->th_seq) - src->seqdiff;
			if (src->seqdiff) {
				pf_patch_32(pd, &th->th_seq, htonl(seq));
				copyback = 1;
			}

			if (!((*state)->state_flags & PFSTATE_SLOPPY) &&
			    (!SEQ_GEQ(src->seqhi, seq) || !SEQ_GEQ(seq,
			    src->seqlo - (dst->max_win << dws)))) {
				if (pf_status.debug >= LOG_NOTICE) {
					log(LOG_NOTICE,
					    "pf: BAD ICMP %d:%d ",
					    icmptype, pd->hdr.icmp.icmp_code);
					pf_print_host(pd->src, 0, pd->af);
					addlog(" -> ");
					pf_print_host(pd->dst, 0, pd->af);
					addlog(" state: ");
					pf_print_state(*state);
					addlog(" seq=%u\n", seq);
				}
				REASON_SET(reason, PFRES_BADSTATE);
				return (PF_DROP);
			} else {
				if (pf_status.debug >= LOG_DEBUG) {
					log(LOG_DEBUG,
					    "pf: OK ICMP %d:%d ",
					    icmptype, pd->hdr.icmp.icmp_code);
					pf_print_host(pd->src, 0, pd->af);
					addlog(" -> ");
					pf_print_host(pd->dst, 0, pd->af);
					addlog(" state: ");
					pf_print_state(*state);
					addlog(" seq=%u\n", seq);
				}
			}

			/* translate source/destination address, if necessary */
			if ((*state)->key[PF_SK_WIRE] !=
			    (*state)->key[PF_SK_STACK]) {
				struct pf_state_key	*nk;
				int			 afto, sidx, didx;

				if (PF_REVERSED_KEY((*state)->key, pd->af))
					nk = (*state)->key[pd->sidx];
				else
					nk = (*state)->key[pd->didx];

				afto = pd->af != nk->af;
				sidx = afto ? pd2.didx : pd2.sidx;
				didx = afto ? pd2.sidx : pd2.didx;

#ifdef INET6
				if (afto) {
					if (pf_translate_icmp_af(pd, nk->af,
					    &pd->hdr.icmp))
						return (PF_DROP);
					m_copyback(pd->m, pd->off,
					    sizeof(struct icmp6_hdr),
					    &pd->hdr.icmp6, M_NOWAIT);
					if (pf_change_icmp_af(pd->m, ipoff2,
					    pd, &pd2, &nk->addr[sidx],
					    &nk->addr[didx], pd->af, nk->af))
						return (PF_DROP);
					if (nk->af == AF_INET)
						pd->proto = IPPROTO_ICMP;
					else
						pd->proto = IPPROTO_ICMPV6;
					pd->m->m_pkthdr.ph_rtableid =
					    nk->rdomain;
					pd->destchg = 1;
					PF_ACPY(&pd->nsaddr,
					    &nk->addr[pd2.sidx], nk->af);
					PF_ACPY(&pd->ndaddr,
					    &nk->addr[pd2.didx], nk->af);
					pd->naf = nk->af;

					pf_patch_16(pd,
					    &th->th_sport, nk->port[sidx]);
					pf_patch_16(pd,
					    &th->th_dport, nk->port[didx]);

					m_copyback(pd2.m, pd2.off, 8, th,
					    M_NOWAIT);
					return (PF_AFRT);
				}
#endif	/* INET6 */
				if (PF_ANEQ(pd2.src,
				    &nk->addr[pd2.sidx], pd2.af) ||
				    nk->port[pd2.sidx] != th->th_sport)
					pf_translate_icmp(pd, pd2.src,
					    &th->th_sport, pd->dst,
					    &nk->addr[pd2.sidx],
					    nk->port[pd2.sidx]);

				if (PF_ANEQ(pd2.dst, &nk->addr[pd2.didx],
				    pd2.af) || pd2.rdomain != nk->rdomain)
					pd->destchg = 1;
				pd->m->m_pkthdr.ph_rtableid = nk->rdomain;

				if (PF_ANEQ(pd2.dst,
				    &nk->addr[pd2.didx], pd2.af) ||
				    nk->port[pd2.didx] != th->th_dport)
					pf_translate_icmp(pd, pd2.dst,
					    &th->th_dport, pd->src,
					    &nk->addr[pd2.didx],
					    nk->port[pd2.didx]);
				copyback = 1;
			}

			if (copyback) {
				switch (pd2.af) {
				case AF_INET:
					m_copyback(pd->m, pd->off, ICMP_MINLEN,
					    &pd->hdr.icmp, M_NOWAIT);
					m_copyback(pd2.m, ipoff2, sizeof(h2),
					    &h2, M_NOWAIT);
					break;
#ifdef INET6
				case AF_INET6:
					m_copyback(pd->m, pd->off,
					    sizeof(struct icmp6_hdr),
					    &pd->hdr.icmp6, M_NOWAIT);
					m_copyback(pd2.m, ipoff2, sizeof(h2_6),
					    &h2_6, M_NOWAIT);
					break;
#endif /* INET6 */
				}
				m_copyback(pd2.m, pd2.off, 8, th, M_NOWAIT);
			}
			break;
		}
		case IPPROTO_UDP: {
			struct udphdr	*uh = &pd2.hdr.udp;

			if (!pf_pull_hdr(pd2.m, pd2.off, uh, sizeof(*uh),
			    NULL, reason, pd2.af)) {
				DPFPRINTF(LOG_NOTICE,
				    "ICMP error message too short (udp)");
				return (PF_DROP);
			}

			key.af = pd2.af;
			key.proto = IPPROTO_UDP;
			key.rdomain = pd2.rdomain;
			PF_ACPY(&key.addr[pd2.sidx], pd2.src, key.af);
			PF_ACPY(&key.addr[pd2.didx], pd2.dst, key.af);
			key.port[pd2.sidx] = uh->uh_sport;
			key.port[pd2.didx] = uh->uh_dport;

			STATE_LOOKUP(pd2.kif, &key, pd2.dir, *state, pd2.m);

			/* translate source/destination address, if necessary */
			if ((*state)->key[PF_SK_WIRE] !=
			    (*state)->key[PF_SK_STACK]) {
				struct pf_state_key	*nk;
				int			 afto, sidx, didx;

				if (PF_REVERSED_KEY((*state)->key, pd->af))
					nk = (*state)->key[pd->sidx];
				else
					nk = (*state)->key[pd->didx];

				afto = pd->af != nk->af;
				sidx = afto ? pd2.didx : pd2.sidx;
				didx = afto ? pd2.sidx : pd2.didx;

#ifdef INET6
				if (afto) {
					if (pf_translate_icmp_af(pd, nk->af,
					    &pd->hdr.icmp))
						return (PF_DROP);
					m_copyback(pd->m, pd->off,
					    sizeof(struct icmp6_hdr),
					    &pd->hdr.icmp6, M_NOWAIT);
					if (pf_change_icmp_af(pd->m, ipoff2,
					    pd, &pd2, &nk->addr[sidx],
					    &nk->addr[didx], pd->af, nk->af))
						return (PF_DROP);
					if (nk->af == AF_INET)
						pd->proto = IPPROTO_ICMP;
					else
						pd->proto = IPPROTO_ICMPV6;
					pd->m->m_pkthdr.ph_rtableid =
					    nk->rdomain;
					pd->destchg = 1;
					PF_ACPY(&pd->nsaddr,
					    &nk->addr[pd2.sidx], nk->af);
					PF_ACPY(&pd->ndaddr,
					    &nk->addr[pd2.didx], nk->af);
					pd->naf = nk->af;

					pf_patch_16(pd,
					    &uh->uh_sport, nk->port[sidx]);
					pf_patch_16(pd,
					    &uh->uh_dport, nk->port[didx]);

					m_copyback(pd2.m, pd2.off, sizeof(*uh),
					    uh, M_NOWAIT);
					return (PF_AFRT);
				}
#endif /* INET6 */

				if (PF_ANEQ(pd2.src,
				    &nk->addr[pd2.sidx], pd2.af) ||
				    nk->port[pd2.sidx] != uh->uh_sport)
					pf_translate_icmp(pd, pd2.src,
					    &uh->uh_sport, pd->dst,
					    &nk->addr[pd2.sidx],
					    nk->port[pd2.sidx]);

				if (PF_ANEQ(pd2.dst, &nk->addr[pd2.didx],
				    pd2.af) || pd2.rdomain != nk->rdomain)
					pd->destchg = 1;
				pd->m->m_pkthdr.ph_rtableid = nk->rdomain;

				if (PF_ANEQ(pd2.dst,
				    &nk->addr[pd2.didx], pd2.af) ||
				    nk->port[pd2.didx] != uh->uh_dport)
					pf_translate_icmp(pd, pd2.dst,
					    &uh->uh_dport, pd->src,
					    &nk->addr[pd2.didx],
					    nk->port[pd2.didx]);

				switch (pd2.af) {
				case AF_INET:
					m_copyback(pd->m, pd->off, ICMP_MINLEN,
					    &pd->hdr.icmp, M_NOWAIT);
					m_copyback(pd2.m, ipoff2, sizeof(h2),
					    &h2, M_NOWAIT);
					break;
#ifdef INET6
				case AF_INET6:
					m_copyback(pd->m, pd->off,
					    sizeof(struct icmp6_hdr),
					    &pd->hdr.icmp6, M_NOWAIT);
					m_copyback(pd2.m, ipoff2, sizeof(h2_6),
					    &h2_6, M_NOWAIT);
					break;
#endif /* INET6 */
				}
				/* Avoid recomputing quoted UDP checksum.
				 * note: udp6 0 csum invalid per rfc2460 p27.
				 * but presumed nothing cares in this context */
				pf_patch_16(pd, &uh->uh_sum, 0);
				m_copyback(pd2.m, pd2.off, sizeof(*uh), uh,
				    M_NOWAIT);
				copyback = 1;
			}
			break;
		}
		case IPPROTO_ICMP: {
			struct icmp	*iih = &pd2.hdr.icmp;

			if (pd2.af != AF_INET) {
				REASON_SET(reason, PFRES_NORM);
				return (PF_DROP);
			}

			if (!pf_pull_hdr(pd2.m, pd2.off, iih, ICMP_MINLEN,
			    NULL, reason, pd2.af)) {
				DPFPRINTF(LOG_NOTICE,
				    "ICMP error message too short (icmp)");
				return (PF_DROP);
			}

			pf_icmp_mapping(&pd2, iih->icmp_type,
			    &icmp_dir, &virtual_id, &virtual_type);

			ret = pf_icmp_state_lookup(&pd2, &key, state,
			    virtual_id, virtual_type, icmp_dir, &iidx, 0, 1);
			if (ret >= 0)
				return (ret);

			/* translate source/destination address, if necessary */
			if ((*state)->key[PF_SK_WIRE] !=
			    (*state)->key[PF_SK_STACK]) {
				struct pf_state_key	*nk;
				int			 afto, sidx, didx;

				if (PF_REVERSED_KEY((*state)->key, pd->af))
					nk = (*state)->key[pd->sidx];
				else
					nk = (*state)->key[pd->didx];

				afto = pd->af != nk->af;
				sidx = afto ? pd2.didx : pd2.sidx;
				didx = afto ? pd2.sidx : pd2.didx;
				iidx = afto ? !iidx : iidx;

#ifdef INET6
				if (afto) {
					if (nk->af != AF_INET6)
						return (PF_DROP);
					if (pf_translate_icmp_af(pd, nk->af,
					    &pd->hdr.icmp))
						return (PF_DROP);
					m_copyback(pd->m, pd->off,
					    sizeof(struct icmp6_hdr),
					    &pd->hdr.icmp6, M_NOWAIT);
					if (pf_change_icmp_af(pd->m, ipoff2,
					    pd, &pd2, &nk->addr[sidx],
					    &nk->addr[didx], pd->af, nk->af))
						return (PF_DROP);
					pd->proto = IPPROTO_ICMPV6;
					if (pf_translate_icmp_af(pd,
						nk->af, iih))
						return (PF_DROP);
					if (virtual_type == htons(ICMP_ECHO))
						pf_patch_16(pd, &iih->icmp_id,
						    nk->port[iidx]);
					m_copyback(pd2.m, pd2.off, ICMP_MINLEN,
					    iih, M_NOWAIT);
					pd->m->m_pkthdr.ph_rtableid =
					    nk->rdomain;
					pd->destchg = 1;
					PF_ACPY(&pd->nsaddr,
					    &nk->addr[pd2.sidx], nk->af);
					PF_ACPY(&pd->ndaddr,
					    &nk->addr[pd2.didx], nk->af);
					pd->naf = nk->af;
					return (PF_AFRT);
				}
#endif /* INET6 */

				if (PF_ANEQ(pd2.src,
				    &nk->addr[pd2.sidx], pd2.af) ||
				    (virtual_type == htons(ICMP_ECHO) &&
				    nk->port[iidx] != iih->icmp_id))
					pf_translate_icmp(pd, pd2.src,
					    (virtual_type == htons(ICMP_ECHO)) ?
					    &iih->icmp_id : NULL,
					    pd->dst, &nk->addr[pd2.sidx],
					    (virtual_type == htons(ICMP_ECHO)) ?
					    nk->port[iidx] : 0);

				if (PF_ANEQ(pd2.dst, &nk->addr[pd2.didx],
				    pd2.af) || pd2.rdomain != nk->rdomain)
					pd->destchg = 1;
				pd->m->m_pkthdr.ph_rtableid = nk->rdomain;

				if (PF_ANEQ(pd2.dst,
				    &nk->addr[pd2.didx], pd2.af))
					pf_translate_icmp(pd, pd2.dst, NULL,
					    pd->src, &nk->addr[pd2.didx], 0);

				m_copyback(pd->m, pd->off, ICMP_MINLEN,
				    &pd->hdr.icmp, M_NOWAIT);
				m_copyback(pd2.m, ipoff2, sizeof(h2), &h2,
				    M_NOWAIT);
				m_copyback(pd2.m, pd2.off, ICMP_MINLEN, iih,
				    M_NOWAIT);
				copyback = 1;
			}
			break;
		}
#ifdef INET6
		case IPPROTO_ICMPV6: {
			struct icmp6_hdr	*iih = &pd2.hdr.icmp6;

			if (pd2.af != AF_INET6) {
				REASON_SET(reason, PFRES_NORM);
				return (PF_DROP);
			}

			if (!pf_pull_hdr(pd2.m, pd2.off, iih,
			    sizeof(struct icmp6_hdr), NULL, reason, pd2.af)) {
				DPFPRINTF(LOG_NOTICE,
				    "ICMP error message too short (icmp6)");
				return (PF_DROP);
			}

			pf_icmp_mapping(&pd2, iih->icmp6_type,
			    &icmp_dir, &virtual_id, &virtual_type);
			ret = pf_icmp_state_lookup(&pd2, &key, state,
			    virtual_id, virtual_type, icmp_dir, &iidx, 0, 1);
			/* IPv6? try matching a multicast address */
			if (ret == PF_DROP && pd2.af == AF_INET6 &&
			    icmp_dir == PF_OUT)
				ret = pf_icmp_state_lookup(&pd2, &key, state,
				    virtual_id, virtual_type, icmp_dir, &iidx,
				    1, 1);
			if (ret >= 0)
				return (ret);

			/* translate source/destination address, if necessary */
			if ((*state)->key[PF_SK_WIRE] !=
			    (*state)->key[PF_SK_STACK]) {
				struct pf_state_key	*nk;
				int			 afto, sidx, didx;

				if (PF_REVERSED_KEY((*state)->key, pd->af))
					nk = (*state)->key[pd->sidx];
				else
					nk = (*state)->key[pd->didx];

				afto = pd->af != nk->af;
				sidx = afto ? pd2.didx : pd2.sidx;
				didx = afto ? pd2.sidx : pd2.didx;
				iidx = afto ? !iidx : iidx;

				if (afto) {
					if (nk->af != AF_INET)
						return (PF_DROP);
					if (pf_translate_icmp_af(pd, nk->af,
					    &pd->hdr.icmp))
						return (PF_DROP);
					m_copyback(pd->m, pd->off,
					    sizeof(struct icmp6_hdr),
					    &pd->hdr.icmp6, M_NOWAIT);
					if (pf_change_icmp_af(pd->m, ipoff2,
					    pd, &pd2, &nk->addr[sidx],
					    &nk->addr[didx], pd->af, nk->af))
						return (PF_DROP);
					pd->proto = IPPROTO_ICMP;
					if (pf_translate_icmp_af(pd,
						nk->af, iih))
						return (PF_DROP);
					if (virtual_type ==
					    htons(ICMP6_ECHO_REQUEST))
						pf_patch_16(pd, &iih->icmp6_id,
						    nk->port[iidx]);
					m_copyback(pd2.m, pd2.off,
					    sizeof(struct icmp6_hdr), iih,
					    M_NOWAIT);
					pd->m->m_pkthdr.ph_rtableid =
					    nk->rdomain;
					pd->destchg = 1;
					PF_ACPY(&pd->nsaddr,
					    &nk->addr[pd2.sidx], nk->af);
					PF_ACPY(&pd->ndaddr,
					    &nk->addr[pd2.didx], nk->af);
					pd->naf = nk->af;
					return (PF_AFRT);
				}

				if (PF_ANEQ(pd2.src,
				    &nk->addr[pd2.sidx], pd2.af) ||
				    ((virtual_type ==
				    htons(ICMP6_ECHO_REQUEST)) &&
				    nk->port[pd2.sidx] != iih->icmp6_id))
					pf_translate_icmp(pd, pd2.src,
					    (virtual_type ==
					    htons(ICMP6_ECHO_REQUEST))
					    ? &iih->icmp6_id : NULL,
					    pd->dst, &nk->addr[pd2.sidx],
					    (virtual_type ==
					    htons(ICMP6_ECHO_REQUEST))
					    ? nk->port[iidx] : 0);

				if (PF_ANEQ(pd2.dst, &nk->addr[pd2.didx],
				    pd2.af) || pd2.rdomain != nk->rdomain)
					pd->destchg = 1;
				pd->m->m_pkthdr.ph_rtableid = nk->rdomain;

				if (PF_ANEQ(pd2.dst,
				    &nk->addr[pd2.didx], pd2.af))
					pf_translate_icmp(pd, pd2.dst, NULL,
					    pd->src, &nk->addr[pd2.didx], 0);

				m_copyback(pd->m, pd->off,
				    sizeof(struct icmp6_hdr), &pd->hdr.icmp6,
				    M_NOWAIT);
				m_copyback(pd2.m, ipoff2, sizeof(h2_6), &h2_6,
				    M_NOWAIT);
				m_copyback(pd2.m, pd2.off,
				    sizeof(struct icmp6_hdr), iih, M_NOWAIT);
				copyback = 1;
			}
			break;
		}
#endif /* INET6 */
		default: {
			key.af = pd2.af;
			key.proto = pd2.proto;
			key.rdomain = pd2.rdomain;
			PF_ACPY(&key.addr[pd2.sidx], pd2.src, key.af);
			PF_ACPY(&key.addr[pd2.didx], pd2.dst, key.af);
			key.port[0] = key.port[1] = 0;

			STATE_LOOKUP(pd2.kif, &key, pd2.dir, *state, pd2.m);

			/* translate source/destination address, if necessary */
			if ((*state)->key[PF_SK_WIRE] !=
			    (*state)->key[PF_SK_STACK]) {
				struct pf_state_key *nk =
				    (*state)->key[pd->didx];

				if (PF_ANEQ(pd2.src,
				    &nk->addr[pd2.sidx], pd2.af))
					pf_translate_icmp(pd, pd2.src, NULL,
					    pd->dst, &nk->addr[pd2.sidx], 0);

				if (PF_ANEQ(pd2.dst, &nk->addr[pd2.didx],
				    pd2.af) || pd2.rdomain != nk->rdomain)
					pd->destchg = 1;
				pd->m->m_pkthdr.ph_rtableid = nk->rdomain;

				if (PF_ANEQ(pd2.dst,
				    &nk->addr[pd2.didx], pd2.af))
					pf_translate_icmp(pd, pd2.dst, NULL,
					    pd->src, &nk->addr[pd2.didx], 0);

				switch (pd2.af) {
				case AF_INET:
					m_copyback(pd->m, pd->off, ICMP_MINLEN,
					    &pd->hdr.icmp, M_NOWAIT);
					m_copyback(pd2.m, ipoff2, sizeof(h2),
					    &h2, M_NOWAIT);
					break;
#ifdef INET6
				case AF_INET6:
					m_copyback(pd->m, pd->off,
					    sizeof(struct icmp6_hdr),
					    &pd->hdr.icmp6, M_NOWAIT);
					m_copyback(pd2.m, ipoff2, sizeof(h2_6),
					    &h2_6, M_NOWAIT);
					break;
#endif /* INET6 */
				}
				copyback = 1;
			}
			break;
		}
		}
	}
	if (copyback) {
		m_copyback(pd->m, pd->off, pd->hdrlen, &pd->hdr, M_NOWAIT);
	}

	return (PF_PASS);
}

/*
 * ipoff and off are measured from the start of the mbuf chain.
 * h must be at "ipoff" on the mbuf chain.
 */
void *
pf_pull_hdr(struct mbuf *m, int off, void *p, int len,
    u_short *actionp, u_short *reasonp, sa_family_t af)
{
	int iplen = 0;

	switch (af) {
	case AF_INET: {
		struct ip	*h = mtod(m, struct ip *);
		u_int16_t	 fragoff = (ntohs(h->ip_off) & IP_OFFMASK) << 3;

		if (fragoff) {
			if (fragoff >= len)
				ACTION_SET(actionp, PF_PASS);
			else {
				ACTION_SET(actionp, PF_DROP);
				REASON_SET(reasonp, PFRES_FRAG);
			}
			return (NULL);
		}
		iplen = ntohs(h->ip_len);
		break;
	}
#ifdef INET6
	case AF_INET6: {
		struct ip6_hdr	*h = mtod(m, struct ip6_hdr *);

		iplen = ntohs(h->ip6_plen) + sizeof(struct ip6_hdr);
		break;
	}
#endif /* INET6 */
	}
	if (m->m_pkthdr.len < off + len || iplen < off + len) {
		ACTION_SET(actionp, PF_DROP);
		REASON_SET(reasonp, PFRES_SHORT);
		return (NULL);
	}
	m_copydata(m, off, len, p);
	return (p);
}

int
pf_routable(struct pf_addr *addr, sa_family_t af, struct pfi_kif *kif,
    int rtableid)
{
	struct sockaddr_storage	 ss;
	struct sockaddr_in	*dst;
	int			 ret = 1;
	int			 check_mpath;
#ifdef INET6
	struct sockaddr_in6	*dst6;
#endif	/* INET6 */
	struct rtentry		*rt = NULL;

	check_mpath = 0;
	memset(&ss, 0, sizeof(ss));
	switch (af) {
	case AF_INET:
		dst = (struct sockaddr_in *)&ss;
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = addr->v4;
		if (ipmultipath)
			check_mpath = 1;
		break;
#ifdef INET6
	case AF_INET6:
		/*
		 * Skip check for addresses with embedded interface scope,
		 * as they would always match anyway.
		 */
		if (IN6_IS_SCOPE_EMBED(&addr->v6))
			goto out;
		dst6 = (struct sockaddr_in6 *)&ss;
		dst6->sin6_family = AF_INET6;
		dst6->sin6_len = sizeof(*dst6);
		dst6->sin6_addr = addr->v6;
		if (ip6_multipath)
			check_mpath = 1;
		break;
#endif /* INET6 */
	}

	/* Skip checks for ipsec interfaces */
	if (kif != NULL && kif->pfik_ifp->if_type == IFT_ENC)
		goto out;

	rt = rtalloc(sstosa(&ss), 0, rtableid);
	if (rt != NULL) {
		/* No interface given, this is a no-route check */
		if (kif == NULL)
			goto out;

		if (kif->pfik_ifp == NULL) {
			ret = 0;
			goto out;
		}

		/* Perform uRPF check if passed input interface */
		ret = 0;
		do {
			if (rt->rt_ifidx == kif->pfik_ifp->if_index) {
				ret = 1;
#if NCARP > 0
			} else {
				struct ifnet	*ifp;

				ifp = if_get(rt->rt_ifidx);
				if (ifp != NULL && ifp->if_type == IFT_CARP &&
				    ifp->if_carpdev == kif->pfik_ifp)
					ret = 1;
				if_put(ifp);
#endif /* NCARP */
			}

			rt = rtable_iterate(rt);
		} while (check_mpath == 1 && rt != NULL && ret == 0);
	} else
		ret = 0;
out:
	rtfree(rt);
	return (ret);
}

int
pf_rtlabel_match(struct pf_addr *addr, sa_family_t af, struct pf_addr_wrap *aw,
    int rtableid)
{
	struct sockaddr_storage	 ss;
	struct sockaddr_in	*dst;
#ifdef INET6
	struct sockaddr_in6	*dst6;
#endif	/* INET6 */
	struct rtentry		*rt;
	int			 ret = 0;

	memset(&ss, 0, sizeof(ss));
	switch (af) {
	case AF_INET:
		dst = (struct sockaddr_in *)&ss;
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = addr->v4;
		break;
#ifdef INET6
	case AF_INET6:
		dst6 = (struct sockaddr_in6 *)&ss;
		dst6->sin6_family = AF_INET6;
		dst6->sin6_len = sizeof(*dst6);
		dst6->sin6_addr = addr->v6;
		break;
#endif /* INET6 */
	}

	rt = rtalloc(sstosa(&ss), RT_RESOLVE, rtableid);
	if (rt != NULL) {
		if (rt->rt_labelid == aw->v.rtlabel)
			ret = 1;
		rtfree(rt);
	}

	return (ret);
}

/* pf_route() may change pd->m, adjust local copies after calling */
void
pf_route(struct pf_pdesc *pd, struct pf_rule *r, struct pf_state *s)
{
	struct mbuf		*m0, *m1;
	struct sockaddr_in	*dst, sin;
	struct rtentry		*rt = NULL;
	struct ip		*ip;
	struct ifnet		*ifp = NULL;
	struct pf_addr		 naddr;
	struct pf_src_node	*sns[PF_SN_MAX];
	int			 error = 0;
	unsigned int		 rtableid;

	if (pd->m->m_pkthdr.pf.routed++ > 3) {
		m_freem(pd->m);
		pd->m = NULL;
		return;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_dup_pkt(pd->m, max_linkhdr, M_NOWAIT)) == NULL)
			return;
	} else {
		if ((r->rt == PF_REPLYTO) == (r->direction == pd->dir))
			return;
		m0 = pd->m;
	}

	if (m0->m_len < sizeof(struct ip)) {
		DPFPRINTF(LOG_ERR,
		    "%s: m0->m_len < sizeof(struct ip)", __func__);
		goto bad;
	}

	ip = mtod(m0, struct ip *);

	memset(&sin, 0, sizeof(sin));
	dst = &sin;
	dst->sin_family = AF_INET;
	dst->sin_len = sizeof(*dst);
	dst->sin_addr = ip->ip_dst;
	rtableid = m0->m_pkthdr.ph_rtableid;

	if (s == NULL) {
		bzero(sns, sizeof(sns));
		if (pf_map_addr(AF_INET, r,
		    (struct pf_addr *)&ip->ip_src,
		    &naddr, NULL, sns, &r->route, PF_SN_ROUTE)) {
			DPFPRINTF(LOG_ERR,
			    "%s: pf_map_addr() failed", __func__);
			goto bad;
		}

		if (!PF_AZERO(&naddr, AF_INET))
			dst->sin_addr.s_addr = naddr.v4.s_addr;
		ifp = r->route.kif ?
		    r->route.kif->pfik_ifp : NULL;
	} else {
		if (!PF_AZERO(&s->rt_addr, AF_INET))
			dst->sin_addr.s_addr =
			    s->rt_addr.v4.s_addr;
		ifp = s->rt_kif ? s->rt_kif->pfik_ifp : NULL;
	}
	if (ifp == NULL)
		goto bad;

	if (pd->kif->pfik_ifp != ifp) {
		if (pf_test(AF_INET, PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip)) {
			DPFPRINTF(LOG_ERR,
			    "%s: m0->m_len < sizeof(struct ip)", __func__);
			goto bad;
		}
		ip = mtod(m0, struct ip *);
	}

	in_proto_cksum_out(m0, ifp);

	rt = rtalloc(sintosa(dst), RT_RESOLVE, rtableid);
	if (!rtisvalid(rt)) {
		ipstat_inc(ips_noroute);
		goto bad;
	}

	if (ntohs(ip->ip_len) <= ifp->if_mtu) {
		ip->ip_sum = 0;
		if (ifp->if_capabilities & IFCAP_CSUM_IPv4)
			m0->m_pkthdr.csum_flags |= M_IPV4_CSUM_OUT;
		else {
			ipstat_inc(ips_outswcsum);
			ip->ip_sum = in_cksum(m0, ip->ip_hl << 2);
		}
		error = ifp->if_output(ifp, m0, sintosa(dst), rt);
		goto done;
	}

	/*
	 * Too large for interface; fragment if possible.
	 * Must be able to put at least 8 bytes per fragment.
	 */
	if (ip->ip_off & htons(IP_DF)) {
		ipstat_inc(ips_cantfrag);
		if (r->rt != PF_DUPTO) {
			icmp_error(m0, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG, 0,
			    ifp->if_mtu);
			goto done;
		} else
			goto bad;
	}

	m1 = m0;
	error = ip_fragment(m0, ifp, ifp->if_mtu);
	if (error) {
		m0 = NULL;
		goto bad;
	}

	for (m0 = m1; m0; m0 = m1) {
		m1 = m0->m_nextpkt;
		m0->m_nextpkt = 0;
		if (error == 0)
			error = ifp->if_output(ifp, m0, sintosa(dst), rt);
		else
			m_freem(m0);
	}

	if (error == 0)
		ipstat_inc(ips_fragmented);

done:
	if (r->rt != PF_DUPTO)
		pd->m = NULL;
	rtfree(rt);
	return;

bad:
	m_freem(m0);
	goto done;
}

#ifdef INET6
/* pf_route6() may change pd->m, adjust local copies after calling */
void
pf_route6(struct pf_pdesc *pd, struct pf_rule *r, struct pf_state *s)
{
	struct mbuf		*m0;
	struct sockaddr_in6	*dst, sin6;
	struct rtentry		*rt = NULL;
	struct ip6_hdr		*ip6;
	struct ifnet		*ifp = NULL;
	struct pf_addr		 naddr;
	struct pf_src_node	*sns[PF_SN_MAX];
	struct m_tag		*mtag;
	unsigned int		 rtableid;

	if (pd->m->m_pkthdr.pf.routed++ > 3) {
		m_freem(pd->m);
		pd->m = NULL;
		return;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_dup_pkt(pd->m, max_linkhdr, M_NOWAIT)) == NULL)
			return;
	} else {
		if ((r->rt == PF_REPLYTO) == (r->direction == pd->dir))
			return;
		m0 = pd->m;
	}

	if (m0->m_len < sizeof(struct ip6_hdr)) {
		DPFPRINTF(LOG_ERR,
		    "%s: m0->m_len < sizeof(struct ip6_hdr)", __func__);
		goto bad;
	}
	ip6 = mtod(m0, struct ip6_hdr *);

	memset(&sin6, 0, sizeof(sin6));
	dst = &sin6;
	dst->sin6_family = AF_INET6;
	dst->sin6_len = sizeof(*dst);
	dst->sin6_addr = ip6->ip6_dst;
	rtableid = m0->m_pkthdr.ph_rtableid;

	if (s == NULL) {
		bzero(sns, sizeof(sns));
		if (pf_map_addr(AF_INET6, r, (struct pf_addr *)&ip6->ip6_src,
		    &naddr, NULL, sns, &r->route, PF_SN_ROUTE)) {
			DPFPRINTF(LOG_ERR,
			    "%s: pf_map_addr() failed", __func__);
			goto bad;
		}
		if (!PF_AZERO(&naddr, AF_INET6))
			PF_ACPY((struct pf_addr *)&dst->sin6_addr,
			    &naddr, AF_INET6);
		ifp = r->route.kif ? r->route.kif->pfik_ifp : NULL;
	} else {
		if (!PF_AZERO(&s->rt_addr, AF_INET6))
			PF_ACPY((struct pf_addr *)&dst->sin6_addr,
			    &s->rt_addr, AF_INET6);
		ifp = s->rt_kif ? s->rt_kif->pfik_ifp : NULL;
	}
	if (ifp == NULL)
		goto bad;

	if (pd->kif->pfik_ifp != ifp) {
		if (pf_test(AF_INET6, PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip6_hdr)) {
			DPFPRINTF(LOG_ERR,
			    "%s: m0->m_len < sizeof(struct ip6_hdr)", __func__);
			goto bad;
		}
	}

	in6_proto_cksum_out(m0, ifp);

	if (IN6_IS_SCOPE_EMBED(&dst->sin6_addr))
		dst->sin6_addr.s6_addr16[1] = htons(ifp->if_index);

	rt = rtalloc(sin6tosa(dst), RT_RESOLVE, rtableid);
	if (!rtisvalid(rt)) {
		ip6stat_inc(ip6s_noroute);
		goto bad;
	}

	/*
	 * If packet has been reassembled by PF earlier, we have to
	 * use pf_refragment6() here to turn it back to fragments.
	 */
	if ((mtag = m_tag_find(m0, PACKET_TAG_PF_REASSEMBLED, NULL))) {
		(void) pf_refragment6(&m0, mtag, dst, ifp, rt);
	} else if ((u_long)m0->m_pkthdr.len <= ifp->if_mtu) {
		ifp->if_output(ifp, m0, sin6tosa(dst), rt);
	} else {
		icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
	}

done:
	if (r->rt != PF_DUPTO)
		pd->m = NULL;
	rtfree(rt);
	return;

bad:
	m_freem(m0);
	goto done;
}
#endif /* INET6 */


/*
 * check TCP checksum and set mbuf flag
 *   off is the offset where the protocol header starts
 *   len is the total length of protocol header plus payload
 * returns 0 when the checksum is valid, otherwise returns 1.
 * if the _OUT flag is set the checksum isn't done yet, consider these ok
 */
int
pf_check_tcp_cksum(struct mbuf *m, int off, int len, sa_family_t af)
{
	u_int16_t sum;

	if (m->m_pkthdr.csum_flags &
	    (M_TCP_CSUM_IN_OK | M_TCP_CSUM_OUT)) {
		return (0);
	}
	if (m->m_pkthdr.csum_flags & M_TCP_CSUM_IN_BAD ||
	    off < sizeof(struct ip) ||
	    m->m_pkthdr.len < off + len) {
		return (1);
	}

	/* need to do it in software */
	tcpstat_inc(tcps_inswcsum);

	switch (af) {
	case AF_INET:
		if (m->m_len < sizeof(struct ip))
			return (1);

		sum = in4_cksum(m, IPPROTO_TCP, off, len);
		break;
#ifdef INET6
	case AF_INET6:
		if (m->m_len < sizeof(struct ip6_hdr))
			return (1);

		sum = in6_cksum(m, IPPROTO_TCP, off, len);
		break;
#endif /* INET6 */
	default:
		unhandled_af(af);
	}
	if (sum) {
		tcpstat_inc(tcps_rcvbadsum);
		m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_BAD;
		return (1);
	}

	m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_OK;
	return (0);
}

struct pf_divert *
pf_find_divert(struct mbuf *m)
{
	struct m_tag    *mtag;

	if ((mtag = m_tag_find(m, PACKET_TAG_PF_DIVERT, NULL)) == NULL)
		return (NULL);

	return ((struct pf_divert *)(mtag + 1));
}

struct pf_divert *
pf_get_divert(struct mbuf *m)
{
	struct m_tag    *mtag;

	if ((mtag = m_tag_find(m, PACKET_TAG_PF_DIVERT, NULL)) == NULL) {
		mtag = m_tag_get(PACKET_TAG_PF_DIVERT, sizeof(struct pf_divert),
		    M_NOWAIT);
		if (mtag == NULL)
			return (NULL);
		bzero(mtag + 1, sizeof(struct pf_divert));
		m_tag_prepend(m, mtag);
	}

	return ((struct pf_divert *)(mtag + 1));
}

int
pf_walk_header(struct pf_pdesc *pd, struct ip *h, u_short *reason)
{
	struct ip6_ext		 ext;
	u_int32_t		 hlen, end;
	int			 hdr_cnt;

	hlen = h->ip_hl << 2;
	if (hlen < sizeof(struct ip) || hlen > ntohs(h->ip_len)) {
		REASON_SET(reason, PFRES_SHORT);
		return (PF_DROP);
	}
	end = pd->off + ntohs(h->ip_len);
	pd->off += hlen;
	pd->proto = h->ip_p;
	/* stop walking over non initial fragments */
	if ((h->ip_off & htons(IP_OFFMASK)) != 0)
		return (PF_PASS);

	for (hdr_cnt = 0; hdr_cnt < pf_hdr_limit; hdr_cnt++) {
		switch (pd->proto) {
		case IPPROTO_AH:
			/* fragments may be short */
			if ((h->ip_off & htons(IP_MF | IP_OFFMASK)) != 0 &&
			    end < pd->off + sizeof(ext))
				return (PF_PASS);
			if (!pf_pull_hdr(pd->m, pd->off, &ext, sizeof(ext),
			    NULL, reason, AF_INET)) {
				DPFPRINTF(LOG_NOTICE, "IP short exthdr");
				return (PF_DROP);
			}
			pd->off += (ext.ip6e_len + 2) * 4;
			pd->proto = ext.ip6e_nxt;
			break;
		default:
			return (PF_PASS);
		}
	}
	DPFPRINTF(LOG_NOTICE, "IPv4 nested authentication header limit");
	REASON_SET(reason, PFRES_IPOPTIONS);
	return (PF_DROP);
}

#ifdef INET6
int
pf_walk_option6(struct pf_pdesc *pd, struct ip6_hdr *h, int off, int end,
    u_short *reason)
{
	struct ip6_opt		 opt;
	struct ip6_opt_jumbo	 jumbo;

	while (off < end) {
		if (!pf_pull_hdr(pd->m, off, &opt.ip6o_type,
		    sizeof(opt.ip6o_type), NULL, reason, AF_INET6)) {
			DPFPRINTF(LOG_NOTICE, "IPv6 short opt type");
			return (PF_DROP);
		}
		if (opt.ip6o_type == IP6OPT_PAD1) {
			off++;
			continue;
		}
		if (!pf_pull_hdr(pd->m, off, &opt, sizeof(opt),
		    NULL, reason, AF_INET6)) {
			DPFPRINTF(LOG_NOTICE, "IPv6 short opt");
			return (PF_DROP);
		}
		if (off + sizeof(opt) + opt.ip6o_len > end) {
			DPFPRINTF(LOG_NOTICE, "IPv6 long opt");
			REASON_SET(reason, PFRES_IPOPTIONS);
			return (PF_DROP);
		}
		switch (opt.ip6o_type) {
		case IP6OPT_JUMBO:
			if (pd->jumbolen != 0) {
				DPFPRINTF(LOG_NOTICE, "IPv6 multiple jumbo");
				REASON_SET(reason, PFRES_IPOPTIONS);
				return (PF_DROP);
			}
			if (ntohs(h->ip6_plen) != 0) {
				DPFPRINTF(LOG_NOTICE, "IPv6 bad jumbo plen");
				REASON_SET(reason, PFRES_IPOPTIONS);
				return (PF_DROP);
			}
			if (!pf_pull_hdr(pd->m, off, &jumbo, sizeof(jumbo),
			    NULL, reason, AF_INET6)) {
				DPFPRINTF(LOG_NOTICE, "IPv6 short jumbo");
				return (PF_DROP);
			}
			memcpy(&pd->jumbolen, jumbo.ip6oj_jumbo_len,
			    sizeof(pd->jumbolen));
			pd->jumbolen = ntohl(pd->jumbolen);
			if (pd->jumbolen < IPV6_MAXPACKET) {
				DPFPRINTF(LOG_NOTICE, "IPv6 short jumbolen");
				REASON_SET(reason, PFRES_IPOPTIONS);
				return (PF_DROP);
			}
			break;
		default:
			break;
		}
		off += sizeof(opt) + opt.ip6o_len;
	}

	return (PF_PASS);
}

int
pf_walk_header6(struct pf_pdesc *pd, struct ip6_hdr *h, u_short *reason)
{
	struct ip6_frag		 frag;
	struct ip6_ext		 ext;
	struct ip6_rthdr	 rthdr;
	u_int32_t		 end;
	int			 hdr_cnt, fraghdr_cnt = 0, rthdr_cnt = 0;

	pd->off += sizeof(struct ip6_hdr);
	end = pd->off + ntohs(h->ip6_plen);
	pd->fragoff = pd->extoff = pd->jumbolen = 0;
	pd->proto = h->ip6_nxt;

	for (hdr_cnt = 0; hdr_cnt < pf_hdr_limit; hdr_cnt++) {
		switch (pd->proto) {
		case IPPROTO_FRAGMENT:
			if (fraghdr_cnt++) {
				DPFPRINTF(LOG_NOTICE, "IPv6 multiple fragment");
				REASON_SET(reason, PFRES_FRAG);
				return (PF_DROP);
			}
			/* jumbo payload packets cannot be fragmented */
			if (pd->jumbolen != 0) {
				DPFPRINTF(LOG_NOTICE, "IPv6 fragmented jumbo");
				REASON_SET(reason, PFRES_FRAG);
				return (PF_DROP);
			}
			if (!pf_pull_hdr(pd->m, pd->off, &frag, sizeof(frag),
			    NULL, reason, AF_INET6)) {
				DPFPRINTF(LOG_NOTICE, "IPv6 short fragment");
				return (PF_DROP);
			}
			/* stop walking over non initial fragments */
			if (ntohs((frag.ip6f_offlg & IP6F_OFF_MASK)) != 0) {
				pd->fragoff = pd->off;
				return (PF_PASS);
			}
			/* RFC6946:  reassemble only non atomic fragments */
			if (frag.ip6f_offlg & IP6F_MORE_FRAG)
				pd->fragoff = pd->off;
			pd->off += sizeof(frag);
			pd->proto = frag.ip6f_nxt;
			break;
		case IPPROTO_ROUTING:
			if (rthdr_cnt++) {
				DPFPRINTF(LOG_NOTICE, "IPv6 multiple rthdr");
				REASON_SET(reason, PFRES_IPOPTIONS);
				return (PF_DROP);
			}
			/* fragments may be short */
			if (pd->fragoff != 0 && end < pd->off + sizeof(rthdr)) {
				pd->off = pd->fragoff;
				pd->proto = IPPROTO_FRAGMENT;
				return (PF_PASS);
			}
			if (!pf_pull_hdr(pd->m, pd->off, &rthdr, sizeof(rthdr),
			    NULL, reason, AF_INET6)) {
				DPFPRINTF(LOG_NOTICE, "IPv6 short rthdr");
				return (PF_DROP);
			}
			if (rthdr.ip6r_type == IPV6_RTHDR_TYPE_0) {
				DPFPRINTF(LOG_NOTICE, "IPv6 rthdr0");
				REASON_SET(reason, PFRES_IPOPTIONS);
				return (PF_DROP);
			}
			/* FALLTHROUGH */
		case IPPROTO_HOPOPTS:
			/* RFC2460 4.1:  Hop-by-Hop only after IPv6 header */
			if (pd->proto == IPPROTO_HOPOPTS && hdr_cnt > 0) {
				DPFPRINTF(LOG_NOTICE, "IPv6 hopopts not first");
				REASON_SET(reason, PFRES_IPOPTIONS);
				return (PF_DROP);
			}
			/* FALLTHROUGH */
		case IPPROTO_AH:
		case IPPROTO_DSTOPTS:
			/* fragments may be short */
			if (pd->fragoff != 0 && end < pd->off + sizeof(ext)) {
				pd->off = pd->fragoff;
				pd->proto = IPPROTO_FRAGMENT;
				return (PF_PASS);
			}
			if (!pf_pull_hdr(pd->m, pd->off, &ext, sizeof(ext),
			    NULL, reason, AF_INET6)) {
				DPFPRINTF(LOG_NOTICE, "IPv6 short exthdr");
				return (PF_DROP);
			}
			/* reassembly needs the ext header before the frag */
			if (pd->fragoff == 0)
				pd->extoff = pd->off;
			if (pd->proto == IPPROTO_HOPOPTS && pd->fragoff == 0) {
				if (pf_walk_option6(pd, h,
				    pd->off + sizeof(ext),
				    pd->off + (ext.ip6e_len + 1) * 8, reason)
				    != PF_PASS)
					return (PF_DROP);
				if (ntohs(h->ip6_plen) == 0 &&
				    pd->jumbolen != 0) {
					DPFPRINTF(LOG_NOTICE,
					    "IPv6 missing jumbo");
					REASON_SET(reason, PFRES_IPOPTIONS);
					return (PF_DROP);
				}
			}
			if (pd->proto == IPPROTO_AH)
				pd->off += (ext.ip6e_len + 2) * 4;
			else
				pd->off += (ext.ip6e_len + 1) * 8;
			pd->proto = ext.ip6e_nxt;
			break;
		case IPPROTO_TCP:
		case IPPROTO_UDP:
		case IPPROTO_ICMPV6:
			/* fragments may be short, ignore inner header then */
			if (pd->fragoff != 0 && end < pd->off +
			    (pd->proto == IPPROTO_TCP ? sizeof(struct tcphdr) :
			    pd->proto == IPPROTO_UDP ? sizeof(struct udphdr) :
			    sizeof(struct icmp6_hdr))) {
				pd->off = pd->fragoff;
				pd->proto = IPPROTO_FRAGMENT;
			}
			/* FALLTHROUGH */
		default:
			return (PF_PASS);
		}
	}
	DPFPRINTF(LOG_NOTICE, "IPv6 nested extension header limit");
	REASON_SET(reason, PFRES_IPOPTIONS);
	return (PF_DROP);
}
#endif /* INET6 */

int
pf_setup_pdesc(struct pf_pdesc *pd, sa_family_t af, int dir,
    struct pfi_kif *kif, struct mbuf *m, u_short *reason)
{
	bzero(pd, sizeof(*pd));
	pd->dir = dir;
	pd->kif = kif;		/* kif is NULL when called by pflog */
	pd->m = m;
	pd->sidx = (dir == PF_IN) ? 0 : 1;
	pd->didx = (dir == PF_IN) ? 1 : 0;
	pd->af = pd->naf = af;
	pd->rdomain = rtable_l2(pd->m->m_pkthdr.ph_rtableid);

	switch (pd->af) {
	case AF_INET: {
		struct ip	*h;

		/* Check for illegal packets */
		if (pd->m->m_pkthdr.len < (int)sizeof(struct ip)) {
			REASON_SET(reason, PFRES_SHORT);
			return (PF_DROP);
		}

		h = mtod(pd->m, struct ip *);
		if (pd->m->m_pkthdr.len < ntohs(h->ip_len)) {
			REASON_SET(reason, PFRES_SHORT);
			return (PF_DROP);
		}

		if (pf_walk_header(pd, h, reason) != PF_PASS)
			return (PF_DROP);

		pd->src = (struct pf_addr *)&h->ip_src;
		pd->dst = (struct pf_addr *)&h->ip_dst;
		pd->tot_len = ntohs(h->ip_len);
		pd->tos = h->ip_tos & ~IPTOS_ECN_MASK;
		pd->ttl = h->ip_ttl;
		if (h->ip_hl > 5)	/* has options */
			pd->badopts++;
		pd->virtual_proto = (h->ip_off & htons(IP_MF | IP_OFFMASK)) ?
		     PF_VPROTO_FRAGMENT : pd->proto;

		break;
	}
#ifdef INET6
	case AF_INET6: {
		struct ip6_hdr	*h;

		/* Check for illegal packets */
		if (pd->m->m_pkthdr.len < (int)sizeof(struct ip6_hdr)) {
			REASON_SET(reason, PFRES_SHORT);
			return (PF_DROP);
		}

		h = mtod(pd->m, struct ip6_hdr *);
		if (pd->m->m_pkthdr.len <
		    sizeof(struct ip6_hdr) + ntohs(h->ip6_plen)) {
			REASON_SET(reason, PFRES_SHORT);
			return (PF_DROP);
		}

		if (pf_walk_header6(pd, h, reason) != PF_PASS)
			return (PF_DROP);

#if 1
		/*
		 * we do not support jumbogram yet.  if we keep going, zero
		 * ip6_plen will do something bad, so drop the packet for now.
		 */
		if (pd->jumbolen != 0) {
			REASON_SET(reason, PFRES_NORM);
			return (PF_DROP);
		}
#endif	/* 1 */

		pd->src = (struct pf_addr *)&h->ip6_src;
		pd->dst = (struct pf_addr *)&h->ip6_dst;
		pd->tot_len = ntohs(h->ip6_plen) + sizeof(struct ip6_hdr);
		pd->tos = (ntohl(h->ip6_flow) & 0x0fc00000) >> 20;
		pd->ttl = h->ip6_hlim;
		pd->virtual_proto = (pd->fragoff != 0) ?
			PF_VPROTO_FRAGMENT : pd->proto;

		break;
	}
#endif /* INET6 */
	default:
		panic("pf_setup_pdesc called with illegal af %u", pd->af);

	}

	PF_ACPY(&pd->nsaddr, pd->src, pd->af);
	PF_ACPY(&pd->ndaddr, pd->dst, pd->af);

	switch (pd->virtual_proto) {
	case IPPROTO_TCP: {
		struct tcphdr	*th = &pd->hdr.tcp;

		if (!pf_pull_hdr(pd->m, pd->off, th, sizeof(*th),
		    NULL, reason, pd->af))
			return (PF_DROP);
		pd->hdrlen = sizeof(*th);
		if (pd->off + (th->th_off << 2) > pd->tot_len ||
		    (th->th_off << 2) < sizeof(struct tcphdr)) {
			REASON_SET(reason, PFRES_SHORT);
			return (PF_DROP);
		}
		pd->p_len = pd->tot_len - pd->off - (th->th_off << 2);
		pd->sport = &th->th_sport;
		pd->dport = &th->th_dport;
		pd->pcksum = &th->th_sum;
		break;
	}
	case IPPROTO_UDP: {
		struct udphdr	*uh = &pd->hdr.udp;

		if (!pf_pull_hdr(pd->m, pd->off, uh, sizeof(*uh),
		    NULL, reason, pd->af))
			return (PF_DROP);
		pd->hdrlen = sizeof(*uh);
		if (uh->uh_dport == 0 ||
		    pd->off + ntohs(uh->uh_ulen) > pd->tot_len ||
		    ntohs(uh->uh_ulen) < sizeof(struct udphdr)) {
			REASON_SET(reason, PFRES_SHORT);
			return (PF_DROP);
		}
		pd->sport = &uh->uh_sport;
		pd->dport = &uh->uh_dport;
		pd->pcksum = &uh->uh_sum;
		break;
	}
	case IPPROTO_ICMP: {
		if (!pf_pull_hdr(pd->m, pd->off, &pd->hdr.icmp, ICMP_MINLEN,
		    NULL, reason, pd->af))
			return (PF_DROP);
		pd->hdrlen = ICMP_MINLEN;
		if (pd->off + pd->hdrlen > pd->tot_len) {
			REASON_SET(reason, PFRES_SHORT);
			return (PF_DROP);
		}
		pd->pcksum = &pd->hdr.icmp.icmp_cksum;
		break;
	}
#ifdef INET6
	case IPPROTO_ICMPV6: {
		size_t	icmp_hlen = sizeof(struct icmp6_hdr);

		if (!pf_pull_hdr(pd->m, pd->off, &pd->hdr.icmp6, icmp_hlen,
		    NULL, reason, pd->af))
			return (PF_DROP);
		/* ICMP headers we look further into to match state */
		switch (pd->hdr.icmp6.icmp6_type) {
		case MLD_LISTENER_QUERY:
		case MLD_LISTENER_REPORT:
			icmp_hlen = sizeof(struct mld_hdr);
			break;
		case ND_NEIGHBOR_SOLICIT:
		case ND_NEIGHBOR_ADVERT:
			icmp_hlen = sizeof(struct nd_neighbor_solicit);
			break;
		}
		if (icmp_hlen > sizeof(struct icmp6_hdr) &&
		    !pf_pull_hdr(pd->m, pd->off, &pd->hdr.icmp6, icmp_hlen,
		    NULL, reason, pd->af))
			return (PF_DROP);
		pd->hdrlen = icmp_hlen;
		if (pd->off + pd->hdrlen > pd->tot_len) {
			REASON_SET(reason, PFRES_SHORT);
			return (PF_DROP);
		}
		pd->pcksum = &pd->hdr.icmp6.icmp6_cksum;
		break;
	}
#endif	/* INET6 */
	}

	if (pd->sport)
		pd->osport = pd->nsport = *pd->sport;
	if (pd->dport)
		pd->odport = pd->ndport = *pd->dport;

	return (PF_PASS);
}

void
pf_counters_inc(int action, struct pf_pdesc *pd, struct pf_state *s,
    struct pf_rule *r, struct pf_rule *a)
{
	int dirndx;
	pd->kif->pfik_bytes[pd->af == AF_INET6][pd->dir == PF_OUT]
	    [action != PF_PASS] += pd->tot_len;
	pd->kif->pfik_packets[pd->af == AF_INET6][pd->dir == PF_OUT]
	    [action != PF_PASS]++;

	if (action == PF_PASS || action == PF_AFRT || r->action == PF_DROP) {
		dirndx = (pd->dir == PF_OUT);
		r->packets[dirndx]++;
		r->bytes[dirndx] += pd->tot_len;
		if (a != NULL) {
			a->packets[dirndx]++;
			a->bytes[dirndx] += pd->tot_len;
		}
		if (s != NULL) {
			struct pf_rule_item	*ri;
			struct pf_sn_item	*sni;

			SLIST_FOREACH(sni, &s->src_nodes, next) {
				sni->sn->packets[dirndx]++;
				sni->sn->bytes[dirndx] += pd->tot_len;
			}
			dirndx = (pd->dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd->tot_len;

			SLIST_FOREACH(ri, &s->match_rules, entry) {
				ri->r->packets[dirndx]++;
				ri->r->bytes[dirndx] += pd->tot_len;

				if (ri->r->src.addr.type == PF_ADDR_TABLE)
					pfr_update_stats(ri->r->src.addr.p.tbl,
					    &s->key[(s->direction == PF_IN)]->
						addr[(s->direction == PF_OUT)],
					    pd, ri->r->action, ri->r->src.neg);
				if (ri->r->dst.addr.type == PF_ADDR_TABLE)
					pfr_update_stats(ri->r->dst.addr.p.tbl,
					    &s->key[(s->direction == PF_IN)]->
						addr[(s->direction == PF_IN)],
					    pd, ri->r->action, ri->r->dst.neg);
			}
		}
		if (r->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(r->src.addr.p.tbl,
			    (s == NULL) ? pd->src :
			    &s->key[(s->direction == PF_IN)]->
				addr[(s->direction == PF_OUT)],
			    pd, r->action, r->src.neg);
		if (r->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(r->dst.addr.p.tbl,
			    (s == NULL) ? pd->dst :
			    &s->key[(s->direction == PF_IN)]->
				addr[(s->direction == PF_IN)],
			    pd, r->action, r->dst.neg);
	}
}

int
pf_test(sa_family_t af, int fwdir, struct ifnet *ifp, struct mbuf **m0)
{
	struct pfi_kif		*kif;
	u_short			 action, reason = 0;
	struct pf_rule		*a = NULL, *r = &pf_default_rule;
	struct pf_state		*s = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_pdesc		 pd;
	int			 dir = (fwdir == PF_FWD) ? PF_OUT : fwdir;
	u_int32_t		 qid, pqid = 0;

	if (!pf_status.running)
		return (PF_PASS);

#if NCARP > 0
	if (ifp->if_type == IFT_CARP && ifp->if_carpdev)
		kif = (struct pfi_kif *)ifp->if_carpdev->if_pf_kif;
	else
#endif /* NCARP */
		kif = (struct pfi_kif *)ifp->if_pf_kif;

	if (kif == NULL) {
		DPFPRINTF(LOG_ERR,
		    "%s: kif == NULL, if_xname %s", __func__, ifp->if_xname);
		return (PF_DROP);
	}
	if (kif->pfik_flags & PFI_IFLAG_SKIP)
		return (PF_PASS);

#ifdef DIAGNOSTIC
	if (((*m0)->m_flags & M_PKTHDR) == 0)
		panic("non-M_PKTHDR is passed to pf_test");
#endif /* DIAGNOSTIC */

	if ((*m0)->m_pkthdr.pf.flags & PF_TAG_GENERATED)
		return (PF_PASS);

	if ((*m0)->m_pkthdr.pf.flags & PF_TAG_DIVERTED_PACKET)
		return (PF_PASS);

	if ((*m0)->m_pkthdr.pf.flags & PF_TAG_REFRAGMENTED) {
		(*m0)->m_pkthdr.pf.flags &= ~PF_TAG_REFRAGMENTED;
		return (PF_PASS);
	}

	action = pf_setup_pdesc(&pd, af, dir, kif, *m0, &reason);
	if (action != PF_PASS) {
#if NPFLOG > 0
		pd.pflog |= PF_LOG_FORCE;
#endif	/* NPFLOG > 0 */
		goto done;
	}

	/* packet normalization and reassembly */
	switch (pd.af) {
	case AF_INET:
		action = pf_normalize_ip(&pd, &reason);
		break;
#ifdef INET6
	case AF_INET6:
		action = pf_normalize_ip6(&pd, &reason);
		break;
#endif	/* INET6 */
	}
	*m0 = pd.m;
	/* if packet sits in reassembly queue, return without error */
	if (pd.m == NULL)
		return PF_PASS;
	if (action != PF_PASS) {
#if NPFLOG > 0
		pd.pflog |= PF_LOG_FORCE;
#endif	/* NPFLOG > 0 */
		goto done;
	}

	/* if packet has been reassembled, update packet description */
	if (pf_status.reass && pd.virtual_proto == PF_VPROTO_FRAGMENT) {
		action = pf_setup_pdesc(&pd, af, dir, kif, pd.m, &reason);
		if (action != PF_PASS) {
#if NPFLOG > 0
			pd.pflog |= PF_LOG_FORCE;
#endif	/* NPFLOG > 0 */
			goto done;
		}
	}
	pd.m->m_pkthdr.pf.flags |= PF_TAG_PROCESSED;

	switch (pd.virtual_proto) {

	case PF_VPROTO_FRAGMENT: {
		/*
		 * handle fragments that aren't reassembled by
		 * normalization
		 */
		action = pf_test_rule(&pd, &r, &s, &a, &ruleset, &reason);
		if (action != PF_PASS)
			REASON_SET(&reason, PFRES_FRAG);
		break;
	}

	case IPPROTO_ICMP: {
		if (pd.af != AF_INET) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_NORM);
			DPFPRINTF(LOG_NOTICE,
			    "dropping IPv6 packet with ICMPv4 payload");
			goto done;
		}
		action = pf_test_state_icmp(&pd, &s, &reason);
		if (action == PF_PASS || action == PF_AFRT) {
#if NPFSYNC > 0
			pfsync_update_state(s);
#endif /* NPFSYNC > 0 */
			r = s->rule.ptr;
			a = s->anchor.ptr;
#if NPFLOG > 0
			pd.pflog |= s->log;
#endif	/* NPFLOG > 0 */
		} else if (s == NULL)
			action = pf_test_rule(&pd, &r, &s, &a, &ruleset,
			    &reason);
		break;
	}

#ifdef INET6
	case IPPROTO_ICMPV6: {
		if (pd.af != AF_INET6) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_NORM);
			DPFPRINTF(LOG_NOTICE,
			    "dropping IPv4 packet with ICMPv6 payload");
			goto done;
		}
		action = pf_test_state_icmp(&pd, &s, &reason);
		if (action == PF_PASS || action == PF_AFRT) {
#if NPFSYNC > 0
			pfsync_update_state(s);
#endif /* NPFSYNC > 0 */
			r = s->rule.ptr;
			a = s->anchor.ptr;
#if NPFLOG > 0
			pd.pflog |= s->log;
#endif	/* NPFLOG > 0 */
		} else if (s == NULL)
			action = pf_test_rule(&pd, &r, &s, &a, &ruleset,
			    &reason);
		break;
	}
#endif /* INET6 */

	default:
		if (pd.virtual_proto == IPPROTO_TCP) {
			if ((pd.hdr.tcp.th_flags & TH_ACK) && pd.p_len == 0)
				pqid = 1;
			action = pf_normalize_tcp(&pd);
			if (action == PF_DROP)
				goto done;
		}
		action = pf_test_state(&pd, &s, &reason);
		if (action == PF_PASS || action == PF_AFRT) {
#if NPFSYNC > 0
			pfsync_update_state(s);
#endif /* NPFSYNC > 0 */
			r = s->rule.ptr;
			a = s->anchor.ptr;
#if NPFLOG > 0
			pd.pflog |= s->log;
#endif	/* NPFLOG > 0 */
		} else if (s == NULL)
			action = pf_test_rule(&pd, &r, &s, &a, &ruleset,
			    &reason);

		if (pd.virtual_proto == IPPROTO_TCP) {
			if (s) {
				if (s->max_mss)
					pf_normalize_mss(&pd, s->max_mss);
			} else if (r->max_mss)
				pf_normalize_mss(&pd, r->max_mss);
		}

		break;
	}

done:
	if (action != PF_DROP) {
		if (s) {
			/* The non-state case is handled in pf_test_rule() */
			if (action == PF_PASS && pd.badopts &&
			    !(s->state_flags & PFSTATE_ALLOWOPTS)) {
				action = PF_DROP;
				REASON_SET(&reason, PFRES_IPOPTIONS);
#if NPFLOG > 0
				pd.pflog |= PF_LOG_FORCE;
#endif	/* NPFLOG > 0 */
				DPFPRINTF(LOG_NOTICE, "dropping packet with "
				    "ip/ipv6 options in pf_test()");
			}

			pf_scrub(pd.m, s->state_flags, pd.af, s->min_ttl,
			    s->set_tos);
			pf_tag_packet(pd.m, s->tag, s->rtableid[pd.didx]);
			if (pqid || (pd.tos & IPTOS_LOWDELAY)) {
				qid = s->pqid;
				if (s->state_flags & PFSTATE_SETPRIO)
					pd.m->m_pkthdr.pf.prio = s->set_prio[1];
			} else {
				qid = s->qid;
				if (s->state_flags & PFSTATE_SETPRIO)
					pd.m->m_pkthdr.pf.prio = s->set_prio[0];
			}
		} else {
			pf_scrub(pd.m, r->scrub_flags, pd.af, r->min_ttl,
			    r->set_tos);
			if (pqid || (pd.tos & IPTOS_LOWDELAY)) {
				qid = r->pqid;
				if (r->scrub_flags & PFSTATE_SETPRIO)
					pd.m->m_pkthdr.pf.prio = r->set_prio[1];
			} else {
				qid = r->qid;
				if (r->scrub_flags & PFSTATE_SETPRIO)
					pd.m->m_pkthdr.pf.prio = r->set_prio[0];
			}
		}
	}

	if (action == PF_PASS && qid)
		pd.m->m_pkthdr.pf.qid = qid;
	if (pd.dir == PF_IN && s && s->key[PF_SK_STACK]) {
		/*
		 * Check below fires whenever caller forgets to call
		 * pf_pkt_addr_changed(). This might happen when we
		 * deal with IP tunnels.
		 */
		if (pd.m->m_pkthdr.pf.statekey != NULL) {
#ifdef DDB
			m_print(pd.m, printf);
#endif
			panic("incoming mbuf already has a statekey");
		}
		pd.m->m_pkthdr.pf.statekey =
		    pf_state_key_ref(s->key[PF_SK_STACK]);
	}
	if (pd.dir == PF_OUT &&
	    pd.m->m_pkthdr.pf.inp && !pd.m->m_pkthdr.pf.inp->inp_pf_sk &&
	    s && s->key[PF_SK_STACK] && !s->key[PF_SK_STACK]->inp) {
		pd.m->m_pkthdr.pf.inp->inp_pf_sk =
		    pf_state_key_ref(s->key[PF_SK_STACK]);
		s->key[PF_SK_STACK]->inp = pd.m->m_pkthdr.pf.inp;
	}

	if (s && (pd.m->m_pkthdr.ph_flowid & M_FLOWID_VALID) == 0) {
		pd.m->m_pkthdr.ph_flowid = M_FLOWID_VALID |
		    (M_FLOWID_MASK & bemtoh64(&s->id));
	}

	/*
	 * connections redirected to loopback should not match sockets
	 * bound specifically to loopback due to security implications,
	 * see tcp_input() and in_pcblookup_listen().
	 */
	if (pd.destchg)
		if ((pd.af == AF_INET && (ntohl(pd.dst->v4.s_addr) >>
		    IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) ||
		    (pd.af == AF_INET6 && IN6_IS_ADDR_LOOPBACK(&pd.dst->v6)))
			pd.m->m_pkthdr.pf.flags |= PF_TAG_TRANSLATE_LOCALHOST;
	/* We need to redo the route lookup on outgoing routes. */
	if (pd.destchg && pd.dir == PF_OUT)
		pd.m->m_pkthdr.pf.flags |= PF_TAG_REROUTE;

	if (pd.dir == PF_IN && action == PF_PASS && r->divert.port) {
		struct pf_divert *divert;

		if ((divert = pf_get_divert(pd.m))) {
			pd.m->m_pkthdr.pf.flags |= PF_TAG_DIVERTED;
			divert->port = r->divert.port;
			divert->rdomain = pd.rdomain;
			divert->addr = r->divert.addr;
		}
	}

	if (action == PF_PASS && r->divert_packet.port)
		action = PF_DIVERT;

#if NPFLOG > 0
	if (pd.pflog) {
		struct pf_rule_item	*ri;

		if (pd.pflog & PF_LOG_FORCE || r->log & PF_LOG_ALL)
			PFLOG_PACKET(&pd, reason, r, a, ruleset, NULL);
		if (s) {
			SLIST_FOREACH(ri, &s->match_rules, entry)
				if (ri->r->log & PF_LOG_ALL)
					PFLOG_PACKET(&pd, reason, ri->r, a,
					    ruleset, NULL);
		}
	}
#endif	/* NPFLOG > 0 */

	pf_counters_inc(action, &pd, s, r, a);

	switch (action) {
	case PF_SYNPROXY_DROP:
		m_freem(pd.m);
		/* FALLTHROUGH */
	case PF_DEFER:
		pd.m = NULL;
		action = PF_PASS;
		break;
	case PF_DIVERT:
		switch (pd.af) {
		case AF_INET:
			if (!divert_packet(pd.m, pd.dir, r->divert_packet.port))
				pd.m = NULL;
			break;
#ifdef INET6
		case AF_INET6:
			if (!divert6_packet(pd.m, pd.dir,
			    r->divert_packet.port))
				pd.m = NULL;
			break;
#endif /* INET6 */
		}
		action = PF_PASS;
		break;
#ifdef INET6
	case PF_AFRT:
		if (pf_translate_af(&pd)) {
			action = PF_DROP;
			break;
		}
		pd.m->m_pkthdr.pf.flags |= PF_TAG_GENERATED;
		switch (pd.naf) {
		case AF_INET:
			if (pd.dir == PF_IN)
				ip_forward(pd.m, ifp, NULL, 1);
			else
				ip_output(pd.m, NULL, NULL, 0, NULL, NULL, 0);
			break;
		case AF_INET6:
			if (pd.dir == PF_IN)
				ip6_forward(pd.m, NULL, 1);
			else
				ip6_output(pd.m, NULL, NULL, 0, NULL, NULL);
			break;
		}
		pd.m = NULL;
		action = PF_PASS;
		break;
#endif /* INET6 */
	case PF_DROP:
		m_freem(pd.m);
		pd.m = NULL;
		break;
	default:
		if (r->rt) {
			switch (pd.af) {
			case AF_INET:
				pf_route(&pd, r, s);
				break;
#ifdef INET6
			case AF_INET6:
				pf_route6(&pd, r, s);
				break;
#endif /* INET6 */
			}
		}
		break;
	}

#ifdef INET6
	/* if reassembled packet passed, create new fragments */
	if (pf_status.reass && action == PF_PASS && pd.m && fwdir == PF_FWD) {
		struct m_tag	*mtag;

		if ((mtag = m_tag_find(pd.m, PACKET_TAG_PF_REASSEMBLED, NULL)))
			action = pf_refragment6(&pd.m, mtag, NULL, NULL, NULL);
	}
#endif	/* INET6 */
	if (s && action != PF_DROP) {
		if (!s->if_index_in && dir == PF_IN)
			s->if_index_in = ifp->if_index;
		else if (!s->if_index_out && dir == PF_OUT)
			s->if_index_out = ifp->if_index;
	}

	*m0 = pd.m;
	return (action);
}

int
pf_ouraddr(struct mbuf *m)
{
	struct pf_state_key	*sk;

	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED)
		return (1);

	sk = m->m_pkthdr.pf.statekey;
	if (sk != NULL) {
		if (sk->inp != NULL)
			return (1);

		/* If we have linked state keys it is certainly forwarded. */
		if (sk->reverse != NULL)
			return (0);
	}

	return (-1);
}

/*
 * must be called whenever any addressing information such as
 * address, port, protocol has changed
 */
void
pf_pkt_addr_changed(struct mbuf *m)
{
	pf_pkt_unlink_state_key(m);
	m->m_pkthdr.pf.inp = NULL;
}

struct inpcb *
pf_inp_lookup(struct mbuf *m)
{
	struct inpcb *inp = NULL;
	struct pf_state_key *sk = m->m_pkthdr.pf.statekey;

	if (!pf_state_key_isvalid(sk))
		pf_pkt_unlink_state_key(m);
	else
		inp = m->m_pkthdr.pf.statekey->inp;

	if (inp && inp->inp_pf_sk)
		KASSERT(m->m_pkthdr.pf.statekey == inp->inp_pf_sk);

	return (inp);
}

void
pf_inp_link(struct mbuf *m, struct inpcb *inp)
{
	struct pf_state_key *sk = m->m_pkthdr.pf.statekey;

	if (!pf_state_key_isvalid(sk)) {
		pf_pkt_unlink_state_key(m);
		return;
	}

	/*
	 * we don't need to grab PF-lock here. At worst case we link inp to
	 * state, which might be just being marked as deleted by another
	 * thread.
	 */
	if (inp && !sk->inp && !inp->inp_pf_sk) {
		sk->inp = inp;
		inp->inp_pf_sk = pf_state_key_ref(sk);
	}
	/* The statekey has finished finding the inp, it is no longer needed. */
	pf_pkt_unlink_state_key(m);
}

void
pf_inp_unlink(struct inpcb *inp)
{
	if (inp->inp_pf_sk) {
		inp->inp_pf_sk->inp = NULL;
		pf_inpcb_unlink_state_key(inp);
	}
}

void
pf_state_key_link(struct pf_state_key *sk, struct pf_state_key *pkt_sk)
{
	/*
	 * Assert will not wire as long as we are called by pf_find_state()
	 */
	KASSERT((pkt_sk->reverse == NULL) && (sk->reverse == NULL));
	pkt_sk->reverse = pf_state_key_ref(sk);
	sk->reverse = pf_state_key_ref(pkt_sk);
}

#if NPFLOG > 0
void
pf_log_matches(struct pf_pdesc *pd, struct pf_rule *rm, struct pf_rule *am,
    struct pf_ruleset *ruleset, struct pf_rule_slist *matchrules)
{
	struct pf_rule_item	*ri;

	/* if this is the log(matches) rule, packet has been logged already */
	if (rm->log & PF_LOG_MATCHES)
		return;

	SLIST_FOREACH(ri, matchrules, entry)
		if (ri->r->log & PF_LOG_MATCHES)
			PFLOG_PACKET(pd, PFRES_MATCH, rm, am, ruleset, ri->r);
}
#endif	/* NPFLOG > 0 */

struct pf_state_key *
pf_state_key_ref(struct pf_state_key *sk)
{
	if (sk != NULL)
		PF_REF_TAKE(sk->refcnt);

	return (sk);
}

void
pf_state_key_unref(struct pf_state_key *sk)
{
	if ((sk != NULL) && PF_REF_RELE(sk->refcnt)) {
		/* state key must be removed from tree */
		KASSERT(!pf_state_key_isvalid(sk));
		/* state key must be unlinked from reverse key */
		KASSERT(sk->reverse == NULL);
		/* state key must be unlinked from socket */
		KASSERT((sk->inp == NULL) || (sk->inp->inp_pf_sk == NULL));
		sk->inp = NULL;
		pool_put(&pf_state_key_pl, sk);
	}
}

int
pf_state_key_isvalid(struct pf_state_key *sk)
{
	return ((sk != NULL) && (sk->removed == 0));
}

void
pf_pkt_unlink_state_key(struct mbuf *m)
{
	pf_state_key_unref(m->m_pkthdr.pf.statekey);
	m->m_pkthdr.pf.statekey = NULL;
}

void
pf_pkt_state_key_ref(struct mbuf *m)
{
	pf_state_key_ref(m->m_pkthdr.pf.statekey);
}

void
pf_inpcb_unlink_state_key(struct inpcb *inp)
{
	if (inp != NULL) {
		pf_state_key_unref(inp->inp_pf_sk);
		inp->inp_pf_sk = NULL;
	}
}

void
pf_state_key_unlink_reverse(struct pf_state_key *sk)
{
	if ((sk != NULL) && (sk->reverse != NULL)) {
		pf_state_key_unref(sk->reverse->reverse);
		sk->reverse->reverse = NULL;
		pf_state_key_unref(sk->reverse);
		sk->reverse = NULL;
	}
}
@


1.1029
log
@Fix bad white spaces, wrap long lines, kill some empty lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1028 2017/05/28 14:54:00 bluhm Exp $ */
d117 2
d6124 1
d6137 2
a6138 1
	for (;;) {
d6157 3
d6232 1
a6232 1
	int			 hdr_cnt = 0, fraghdr_cnt = 0, rthdr_cnt = 0;
d6238 2
a6239 2
	for (;;) {
		hdr_cnt++;
d6294 1
a6294 1
			if (pd->proto == IPPROTO_HOPOPTS && hdr_cnt > 1) {
d6352 3
@


1.1028
log
@Pf was handling IPv4 and IPv6 differently regarding AH extension
headers.  pf_walk_header6() steps over it and detects the real
protocol.  So to implement a minimal header walking function
pf_walk_header() for IPv4.  It does the header checks and jumps
over AH.  Then pf does not understand AH as a protocol, it is just
an extension that authenticates the packet.  Move some header and
option checks to pf_walk_header() for consistency with IPv6.  This
also improves the header check for IPv4 packets in ICMP payload.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1027 2017/05/23 09:09:03 bluhm Exp $ */
d241 4
a244 2
int			 pf_step_into_anchor(struct pf_test_ctx *, struct pf_rule *);
int			 pf_match_rule(struct pf_test_ctx *, struct pf_ruleset *);
d3581 1
a3581 1
#if NPFLOG > 0 
d3590 1
a3590 1
 				 * found matching r
@


1.1027
log
@Move the common length check in pf_pull_hdr() after the address
family switch.  This makes the specific calculation more obvious.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1026 2017/05/20 22:56:43 sashan Exp $ */
d225 2
d4991 3
a4993 1
			pd2.off = ipoff2 + (h2.ip_hl << 2);
a4994 1
			pd2.proto = h2.ip_p;
d6115 38
d6370 1
a6370 5
		pd->off = h->ip_hl << 2;

		if (pd->off < sizeof(struct ip) ||
		    pd->off > ntohs(h->ip_len) ||
		    pd->m->m_pkthdr.len < ntohs(h->ip_len)) {
d6375 3
a6379 1
		pd->virtual_proto = pd->proto = h->ip_p;
d6385 2
a6386 3

		if (h->ip_off & htons(IP_MF | IP_OFFMASK))
			pd->virtual_proto = PF_VPROTO_FRAGMENT;
a6400 2
		pd->off = 0;

a6422 1
		pd->virtual_proto = pd->proto;
d6426 2
a6427 3

		if (pd->fragoff != 0)
			pd->virtual_proto = PF_VPROTO_FRAGMENT;
@


1.1026
log
@- fixes regression found by pf_forward test

O.K. bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1025 2017/05/19 10:43:05 rzalamena Exp $ */
d5614 2
d5630 1
a5630 6
		if (m->m_pkthdr.len < off + len ||
		    ntohs(h->ip_len) < off + len) {
			ACTION_SET(actionp, PF_DROP);
			REASON_SET(reasonp, PFRES_SHORT);
			return (NULL);
		}
d5637 1
a5637 7
		if (m->m_pkthdr.len < off + len ||
		    (ntohs(h->ip6_plen) + sizeof(struct ip6_hdr)) <
		    (unsigned)(off + len)) {
			ACTION_SET(actionp, PF_DROP);
			REASON_SET(reasonp, PFRES_SHORT);
			return (NULL);
		}
d5641 5
@


1.1025
log
@Change PF behavior to allow MLD Listener Report packets to be sent
without needing a previously created state by MLD Listener Query. It
wasn't working because: (1) you might not have a previous MLD Listener
Query and (2) the addresses of the Query and Report don't match.

ok mikeb@@, sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1024 2017/05/16 22:16:30 sashan Exp $ */
d3647 1
@


1.1024
log
@- percpu anchor stacks
  we actually don't need to pre-allocate per_anchor_stack[], if we use
  a 'natural' recursion, when doing anchor tree traversal.

O.K. mikeb@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1023 2017/05/16 12:24:01 mpi Exp $ */
a2066 2
			*icmp_dir = PF_IN;
			/* FALLTHROUGH */
d2071 8
@


1.1023
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1022 2017/05/15 12:26:00 mpi Exp $ */
d122 31
a152 6
struct pf_anchor_stackframe {
	struct pf_ruleset			*rs;
	struct pf_rule				*r;
	struct pf_anchor_node			*parent;
	struct pf_anchor			*child;
} pf_anchor_stack[64];
d239 2
a240 5
void			 pf_step_into_anchor(int *, struct pf_ruleset **,
			    struct pf_rule **, struct pf_rule **);
int			 pf_step_out_of_anchor(int *, struct pf_ruleset **,
			     struct pf_rule **, struct pf_rule **,
			     int *);
d3024 2
a3025 3
void
pf_step_into_anchor(int *depth, struct pf_ruleset **rs,
    struct pf_rule **r, struct pf_rule **a)
d3027 6
a3032 1
	struct pf_anchor_stackframe	*f;
d3034 15
a3048 15
	if (*depth >= sizeof(pf_anchor_stack) /
	    sizeof(pf_anchor_stack[0])) {
		log(LOG_ERR, "pf: anchor stack overflow\n");
		*r = TAILQ_NEXT(*r, entries);
		return;
	} else if (a != NULL)
		*a = *r;
	f = pf_anchor_stack + (*depth)++;
	f->rs = *rs;
	f->r = *r;
	if ((*r)->anchor_wildcard) {
		f->parent = &(*r)->anchor->children;
		if ((f->child = RB_MIN(pf_anchor_node, f->parent)) == NULL) {
			*r = NULL;
			return;
a3049 1
		*rs = &f->child->ruleset;
d3051 1
a3051 3
		f->parent = NULL;
		f->child = NULL;
		*rs = &(*r)->anchor->ruleset;
a3052 9
	*r = TAILQ_FIRST((*rs)->rules.active.ptr);
}

int
pf_step_out_of_anchor(int *depth, struct pf_ruleset **rs,
    struct pf_rule **r, struct pf_rule **a, int *match)
{
	struct pf_anchor_stackframe	*f;
	int quick = 0;
d3054 1
a3054 28
	do {
		if (*depth <= 0)
			break;
		f = pf_anchor_stack + *depth - 1;
		if (f->parent != NULL && f->child != NULL) {
			f->child = RB_NEXT(pf_anchor_node, f->parent, f->child);
			if (f->child != NULL) {
				*rs = &f->child->ruleset;
				*r = TAILQ_FIRST((*rs)->rules.active.ptr);
				if (*r == NULL)
					continue;
				else
					break;
			}
		}
		(*depth)--;
		if (*depth == 0 && a != NULL)
			*a = NULL;
		else if (a != NULL)
			*a = f->r;
		*rs = f->rs;
		if (*match > *depth) {
			*match = *depth;
			if (f->r->quick)
				quick = 1;
		}
		*r = TAILQ_NEXT(f->r, entries);
	} while (*r == NULL);
d3056 1
a3056 1
	return (quick);
d3420 4
a3423 5
	do {					\
		if (t) {			\
			r = a;			\
			goto nextrule;		\
		}				\
d3426 2
a3427 3
int
pf_test_rule(struct pf_pdesc *pd, struct pf_rule **rm, struct pf_state **sm,
    struct pf_rule **am, struct pf_ruleset **rsm, u_short *reason)
d3429 1
a3429 29
	struct pf_rule		*r;
	struct pf_rule		*nr = NULL;
	struct pf_rule		*a = NULL;
	struct pf_ruleset	*arsm = NULL;
	struct pf_ruleset	*aruleset = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_rule_slist	 rules;
	struct pf_rule_item	*ri;
	struct pf_src_node	*sns[PF_SN_MAX];
	struct pf_state_key	*skw = NULL, *sks = NULL;
	struct pf_rule_actions	 act;
	int			 rewrite = 0;
	int			 tag = -1;
	int			 asd = 0;
	int			 match = 0;
	int			 state_icmp = 0, icmp_dir = 0;
	u_int16_t		 virtual_type, virtual_id;
	u_int8_t		 icmptype = 0, icmpcode = 0;
	int			 action = PF_DROP;

	bzero(&act, sizeof(act));
	bzero(sns, sizeof(sns));
	act.rtableid = pd->rdomain;
	SLIST_INIT(&rules);

	if (pd->dir == PF_IN && if_congested()) {
		REASON_SET(reason, PFRES_CONGEST);
		return (PF_DROP);
	}
d3431 1
a3431 33
	switch (pd->virtual_proto) {
	case IPPROTO_ICMP:
		icmptype = pd->hdr.icmp.icmp_type;
		icmpcode = pd->hdr.icmp.icmp_code;
		state_icmp = pf_icmp_mapping(pd, icmptype,
		    &icmp_dir, &virtual_id, &virtual_type);
		if (icmp_dir == PF_IN) {
			pd->osport = pd->nsport = virtual_id;
			pd->odport = pd->ndport = virtual_type;
		} else {
			pd->osport = pd->nsport = virtual_type;
			pd->odport = pd->ndport = virtual_id;
		}
		break;
#ifdef INET6
	case IPPROTO_ICMPV6:
		icmptype = pd->hdr.icmp6.icmp6_type;
		icmpcode = pd->hdr.icmp6.icmp6_code;
		state_icmp = pf_icmp_mapping(pd, icmptype,
		    &icmp_dir, &virtual_id, &virtual_type);
		if (icmp_dir == PF_IN) {
			pd->osport = pd->nsport = virtual_id;
			pd->odport = pd->ndport = virtual_type;
		} else {
			pd->osport = pd->nsport = virtual_type;
			pd->odport = pd->ndport = virtual_id;
		}
		break;
#endif /* INET6 */
	}

	ruleset = &pf_main_ruleset;
	r = TAILQ_FIRST(pf_main_ruleset.rules.active.ptr);
a3432 4
		if (r->rule_flag & PFRULE_EXPIRED) {
			r = TAILQ_NEXT(r, entries);
			goto nextrule;
		}
d3434 2
a3435 1
		PF_TEST_ATTRIB((pfi_kif_match(r->kif, pd->kif) == r->ifnot),
d3437 1
a3437 1
		PF_TEST_ATTRIB((r->direction && r->direction != pd->dir),
d3440 1
a3440 1
		    (r->onrdomain == pd->rdomain) == r->ifnot),
d3442 1
a3442 1
		PF_TEST_ATTRIB((r->af && r->af != pd->af),
d3444 1
a3444 1
		PF_TEST_ATTRIB((r->proto && r->proto != pd->proto),
d3446 3
a3448 2
		PF_TEST_ATTRIB((PF_MISMATCHAW(&r->src.addr, &pd->nsaddr,
		    pd->naf, r->src.neg, pd->kif, act.rtableid)),
d3450 2
a3451 2
		PF_TEST_ATTRIB((PF_MISMATCHAW(&r->dst.addr, &pd->ndaddr, pd->af,
		    r->dst.neg, NULL, act.rtableid)),
d3454 1
a3454 1
		switch (pd->virtual_proto) {
d3459 2
a3460 1
			PF_TEST_ATTRIB((pd->proto == IPPROTO_TCP && r->flagset),
d3471 1
a3471 1
			PF_TEST_ATTRIB(((r->flagset & pd->hdr.tcp.th_flags) !=
d3475 1
a3475 1
			    !pf_osfp_match(pf_osfp_fingerprint(pd),
d3484 1
a3484 1
			    r->src.port[1], pd->nsport)),
d3488 1
a3488 1
			    r->dst.port[1], pd->ndport)),
d3491 3
a3493 3
			PF_TEST_ATTRIB((r->uid.op && (pd->lookup.done ||
			    (pd->lookup.done =
			    pf_socket_lookup(pd), 1)) &&
d3495 1
a3495 1
			    r->uid.uid[1], pd->lookup.uid)),
d3498 3
a3500 3
			PF_TEST_ATTRIB((r->gid.op && (pd->lookup.done ||
			    (pd->lookup.done =
			    pf_socket_lookup(pd), 1)) &&
d3502 1
a3502 1
			    r->gid.gid[1], pd->lookup.gid)),
d3509 2
a3510 1
			PF_TEST_ATTRIB((r->type && r->type != icmptype + 1),
d3513 2
a3514 1
			PF_TEST_ATTRIB((r->code && r->code != icmpcode + 1),
d3517 1
a3517 1
			PF_TEST_ATTRIB((r->keep_state && !state_icmp &&
d3519 1
a3519 1
			    icmp_dir != PF_IN),
d3528 1
a3528 1
		    pd->virtual_proto != PF_VPROTO_FRAGMENT),
d3530 1
a3530 1
		PF_TEST_ATTRIB((r->tos && !(r->tos == pd->tos)),
d3535 2
a3536 1
		PF_TEST_ATTRIB((r->match_tag && !pf_match_tag(pd->m, r, &tag)),
d3538 1
a3538 1
		PF_TEST_ATTRIB((r->rcv_kif && pf_match_rcvif(pd->m, r) ==
d3541 3
a3543 2
		PF_TEST_ATTRIB((r->prio && (r->prio == PF_PRIO_ZERO ?
		    0 : r->prio) != pd->m->m_pkthdr.pf.prio),
d3548 1
a3548 1
			tag = r->tag;
d3551 1
a3551 1
				if ((ri = pool_get(&pf_rule_item_pl,
d3553 3
a3555 2
					REASON_SET(reason, PFRES_MEMORY);
					goto cleanup;
d3557 1
a3557 1
				ri->r = r;
d3559 3
a3561 2
				SLIST_INSERT_HEAD(&rules, ri, entry);
				pf_rule_to_actions(r, &act);
d3563 7
a3569 4
					pd->naf = r->naf;
				if (pf_get_transaddr(r, pd, sns, &nr) == -1) {
					REASON_SET(reason, PFRES_TRANSLATE);
					goto cleanup;
d3571 1
a3571 1
#if NPFLOG > 0
d3573 3
a3575 3
					REASON_SET(reason, PFRES_MATCH);
					PFLOG_PACKET(pd, *reason, r, a, ruleset,
					    NULL);
d3579 16
a3594 5
				match = asd;
				*rm = r;
				*am = a;
				*rsm = ruleset;
				arsm = aruleset;
d3598 3
a3600 2
			if (act.log & PF_LOG_MATCHES)
				pf_log_matches(pd, r, a, ruleset, &rules);
d3603 2
a3604 1
			if (r->quick)
d3606 1
a3606 1
			r = TAILQ_NEXT(r, entries);
d3608 5
a3612 2
			aruleset = ruleset;
			pf_step_into_anchor(&asd, &ruleset, &r, &a);
d3614 19
d3634 52
a3685 4
 nextrule:
		if (r == NULL && pf_step_out_of_anchor(&asd, &ruleset,
		    &r, &a, &match))
			break;
d3687 7
a3693 4
	r = *rm;	/* matching rule */
	a = *am;	/* rule that defines an anchor containing 'r' */
	ruleset = *rsm;	/* ruleset of the anchor defined by the rule 'a' */
	aruleset = arsm;/* ruleset of the 'a' rule itself */
d3696 1
a3696 1
	pf_rule_to_actions(r, &act);
d3699 2
a3700 2
	if (pf_get_transaddr(r, pd, sns, &nr) == -1) {
		REASON_SET(reason, PFRES_TRANSLATE);
d3703 1
a3703 1
	REASON_SET(reason, PFRES_MATCH);
d3707 3
a3709 3
		PFLOG_PACKET(pd, *reason, r, a, ruleset, NULL);
	if (act.log & PF_LOG_MATCHES)
		pf_log_matches(pd, r, a, ruleset, &rules);
d3720 3
a3722 3
		    !(pd->hdr.tcp.th_flags & TH_RST)) {
			struct tcphdr	*th = &pd->hdr.tcp;
			u_int32_t ack = ntohl(th->th_seq) + pd->p_len;
d3726 1
a3726 1
				REASON_SET(reason, PFRES_PROTCKSUM);
d3728 1
a3728 1
				if (th->th_flags & TH_SYN)
d3730 1
a3730 1
				if (th->th_flags & TH_FIN)
d3733 4
a3736 3
				    pd->src, th->th_dport, th->th_sport,
				    ntohl(th->th_ack), ack, TH_RST|TH_ACK, 0, 0,
				    r->return_ttl, 1, 0, pd->rdomain);
d3739 1
a3739 1
		    ICMP_INFOTYPE(icmptype)) && pd->af == AF_INET &&
d3744 2
a3745 2
		    (icmptype >= ICMP6_ECHO_REQUEST &&
		    icmptype != ND_REDIRECT)) && pd->af == AF_INET6 &&
d3754 3
a3756 3
	pf_tag_packet(pd->m, tag, act.rtableid);
	if (act.rtableid >= 0 &&
	    rtable_l2(act.rtableid) != pd->rdomain)
d3760 1
a3760 1
		REASON_SET(reason, PFRES_IPOPTIONS);
d3772 1
a3772 1
	    && !state_icmp && r->keep_state) {
d3775 3
a3777 3
		    pf_insert_src_node(&sns[PF_SN_NONE], r, PF_SN_NONE, pd->af,
		    pd->src, NULL) != 0) {
			REASON_SET(reason, PFRES_SRCLIMIT);
d3783 1
a3783 1
			REASON_SET(reason, PFRES_MAXSTATES);
d3787 2
a3788 2
		action = pf_create_state(pd, r, a, nr, &skw, &sks, &rewrite,
		    sm, tag, &rules, &act, sns);
d3804 1
a3804 1
			    virtual_type, icmp_dir);
d3813 3
a3815 3
		while ((ri = SLIST_FIRST(&rules))) {
			SLIST_REMOVE_HEAD(&rules, entry);
			pool_put(&pf_rule_item_pl, ri);
d3847 3
a3849 3
	while ((ri = SLIST_FIRST(&rules))) {
		SLIST_REMOVE_HEAD(&rules, entry);
		pool_put(&pf_rule_item_pl, ri);
@


1.1022
log
@Enable the NET_LOCK(), take 3.

Recursions are still marked as XXXSMP.

ok deraadt@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1021 2017/05/05 16:30:39 mikeb Exp $ */
d898 1
a898 1
	splsoftassert(IPL_SOFTNET);
d1278 1
a1278 1
	splsoftassert(IPL_SOFTNET);
@


1.1021
log
@Put back the call to pf_remove_src_node lost in the netlock backout

Reported by Remi Barbier, thanks!  OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1020 2017/05/04 15:00:24 bluhm Exp $ */
d1157 1
a1157 1
pf_purge_expired_rules(int locked)
d1161 2
a1165 5
	if (!locked)
		rw_enter_write(&pf_consistency_lock);
	else
		rw_assert_wrlock(&pf_consistency_lock);

a1170 3

	if (!locked)
		rw_exit_write(&pf_consistency_lock);
d1191 1
a1191 1
			pf_purge_expired_rules(0);
d1238 1
a1238 1
pf_purge_expired_src_nodes(int waslocked)
d1241 2
a1242 1
	int				 locked = waslocked;
d1248 1
a1248 6
			if (! locked) {
				rw_enter_write(&pf_consistency_lock);
				next = RB_NEXT(pf_src_tree,
				    &tree_src_tracking, cur);
				locked = 1;
			}
a1251 3

	if (locked && !waslocked)
		rw_exit_write(&pf_consistency_lock);
d1296 2
d1299 1
a1323 1
/* callers should hold the write_lock on pf_consistency_lock */
d1329 1
a1329 1
	splsoftassert(IPL_SOFTNET);
d1364 2
a1365 1
	int			 locked = 0;
a1379 4
			if (! locked) {
				rw_enter_write(&pf_consistency_lock);
				locked = 1;
			}
a1383 4
			if (! locked) {
				rw_enter_write(&pf_consistency_lock);
				locked = 1;
			}
a1387 3

	if (locked)
		rw_exit_write(&pf_consistency_lock);
@


1.1020
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1019 2017/03/17 17:19:16 mpi Exp $ */
d1259 1
@


1.1019
log
@Revert the NET_LOCK() and bring back pf's contention lock for release.

For the moment the NET_LOCK() is always taken by threads running under
KERNEL_LOCK().  That means it doesn't buy us anything except a possible
deadlock that we did not spot.  So make sure this doesn't happen, we'll
have plenty of time in the next release cycle to stress test it.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1018 2017/03/09 05:47:28 claudio Exp $ */
d5694 1
a5694 1
	rt = rtalloc((struct sockaddr *)&ss, 0, rtableid);
d5761 1
a5761 1
	rt = rtalloc((struct sockaddr *)&ss, RT_RESOLVE, rtableid);
@


1.1019.4.1
log
@Put back the call to pf_remove_src_node lost in the netlock backout

Reported by Remi Barbier, thanks!  OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1019 2017/03/17 17:19:16 mpi Exp $ */
a1258 1
			pf_remove_src_node(cur);
@


1.1018
log
@Prevent integer overflow in PF when calculating the adaptive timeout.
Mainly states of established TCP connections whould be affected resulting
in immediate state removal once the numer of states is bigger than
adaptive.start.  Disabling adative timeouts is a workaround to avoid this bug.
Issue found and initial diff by Mathieu Blanc (mathieu.blanc at cea dot fr)
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1017 2017/03/07 16:28:37 mikeb Exp $ */
d1157 1
a1157 1
pf_purge_expired_rules(void)
a1160 2
	NET_ASSERT_LOCKED();

d1164 5
d1174 3
d1197 1
a1197 1
			pf_purge_expired_rules();
d1244 1
a1244 1
pf_purge_expired_src_nodes(void)
d1247 1
a1247 2

	NET_ASSERT_LOCKED();
d1253 6
a1258 2
			next = RB_NEXT(pf_src_tree, &tree_src_tracking, cur);
			pf_remove_src_node(cur);
d1261 3
a1307 2
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
a1308 1
		rw_enter_write(&netlock);
d1333 1
d1339 1
a1339 1
	NET_ASSERT_LOCKED();
d1374 1
a1374 2

	NET_ASSERT_LOCKED();
d1389 4
d1397 4
d1405 3
@


1.1017
log
@Don't overwrite the flow ID once it's set

Output processing may split, encapsulate or obfuscate a single
stream which makes the changed flow ID less useful for purposes
of flow control, for instance fair sharing of bandwidth.

OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1016 2017/03/07 09:29:40 mpi Exp $ */
d1202 1
a1202 1
	int32_t		timeout;
d1231 1
a1231 1
		timeout = timeout * (end - states) / (end - start);
@


1.1016
log
@Enforce that tcbtable and udbtable must be accessed with the NET_LOCK().

Get rid of the old splnet()/splx() dances.  What's protecting them right
now is the KERNEL_LOCK().  but since pf(4) look at these tables we want
to protect them in another way, hence the NET_LOCK(), at least as hint.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1015 2017/02/09 15:19:32 jca Exp $ */
d6785 1
a6785 1
	if (s) {
@


1.1015
log
@percpu counters for TCP stats

ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1014 2017/02/05 16:04:14 jca Exp $ */
d3146 1
d3152 1
@


1.1014
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1013 2017/01/30 17:52:24 benno Exp $ */
d6029 1
a6029 1
	tcpstat.tcps_inswcsum++;
d6050 1
a6050 1
		tcpstat.tcps_rcvbadsum++;
@


1.1013
log
@whitespace, from bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1012 2017/01/30 17:41:33 benno Exp $ */
d5977 1
a5977 1
		ip6stat.ip6s_noroute++;
@


1.1012
log
@removes the pf_consistency_lock and protects the users with
NET_LOCK().  pfioctl() will need the NET_LOCK() anyway. So better keep
things simple until we're going to redesign PF for a MP world.
fixes the crash reported by Kaya Saman.
ok mpi@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1011 2017/01/25 06:15:50 mpi Exp $ */
d1248 1
a1248 2
			next = RB_NEXT(pf_src_tree,
			    &tree_src_tracking, cur);
@


1.1011
log
@Enable the NET_LOCK(), take 2.

Recursions are currently known and marked a XXXSMP.

Please report any assert to bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1010 2017/01/09 14:47:13 mpi Exp $ */
d1157 1
a1157 1
pf_purge_expired_rules(int locked)
d1161 2
a1165 5
	if (!locked)
		rw_enter_write(&pf_consistency_lock);
	else
		rw_assert_wrlock(&pf_consistency_lock);

a1170 3

	if (!locked)
		rw_exit_write(&pf_consistency_lock);
d1191 1
a1191 1
			pf_purge_expired_rules(0);
d1238 1
a1238 1
pf_purge_expired_src_nodes(int waslocked)
d1241 2
a1242 1
	int				 locked = waslocked;
d1248 2
a1249 6
			if (! locked) {
				rw_enter_write(&pf_consistency_lock);
				next = RB_NEXT(pf_src_tree,
				    &tree_src_tracking, cur);
				locked = 1;
			}
a1252 3

	if (locked && !waslocked)
		rw_exit_write(&pf_consistency_lock);
a1324 1
/* callers should hold the write_lock on pf_consistency_lock */
d1330 1
a1330 1
	splsoftassert(IPL_SOFTNET);
d1365 2
a1366 1
	int			 locked = 0;
a1380 4
			if (! locked) {
				rw_enter_write(&pf_consistency_lock);
				locked = 1;
			}
a1384 4
			if (! locked) {
				rw_enter_write(&pf_consistency_lock);
				locked = 1;
			}
a1388 3

	if (locked)
		rw_exit_write(&pf_consistency_lock);
@


1.1010
log
@pf_purge_thread() needs the NET_LOCK().

ok sashan@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1009 2016/12/29 13:01:48 bluhm Exp $ */
d1308 3
a1310 1
	if (cur->state_flags & PFSTATE_PFLOW)
d1312 2
@


1.1009
log
@In pf_refragment6() use the valid route from pf_route6() instead
of calling rtalloc() again.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1008 2016/12/28 15:36:15 bluhm Exp $ */
d1187 1
a1187 1
		s = splsoftnet();
d1201 1
a1201 1
		splx(s);
@


1.1008
log
@In pf_find_state() pkt_sk was set to NULL if pkt_sk->reverse was
not valid.  This did not work as the value of pkt_sk must be used
later to establish the link.  So discard the packet statekey only
if it is invalid itself and use it to establish the reverse link.
From Christiano Haesbaert; OK sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1007 2016/12/28 15:19:02 bluhm Exp $ */
d6006 1
a6006 1
		(void) pf_refragment6(&m0, mtag, dst, ifp);
d6928 1
a6928 1
			action = pf_refragment6(&pd.m, mtag, NULL, NULL);
@


1.1007
log
@Better check for a valid route than for an existing route in pf
route-to by calling rtisvalid().  Make pf_route() and pf_route6()
similar and move the rtalloc() call to the same place.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1006 2016/12/23 20:49:41 bluhm Exp $ */
d1005 2
a1006 4
		if (pf_state_key_isvalid(pkt_sk) &&
		    pf_state_key_isvalid(pkt_sk->reverse)) {
			sk = pkt_sk->reverse;
		} else {
d1010 3
@


1.1006
log
@Replace function names with __func__ in debug prints to make grep
happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1005 2016/12/23 19:46:13 bluhm Exp $ */
a5834 6
	rt = rtalloc(sintosa(dst), RT_RESOLVE, rtableid);
	if (rt == NULL) {
		ipstat_inc(ips_noroute);
		goto bad;
	}

d5850 6
d5994 6
a6006 5
		rt = rtalloc(sin6tosa(dst), RT_RESOLVE, rtableid);
		if (rt == NULL) {
			ip6stat.ip6s_noroute++;
			goto bad;
		}
a6007 1
		rtfree(rt);
d6015 1
@


1.1005
log
@Fix white spaces.  No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1004 2016/12/06 00:01:55 jsg Exp $ */
d3004 1
a3004 1
		    "pf_test_via: kif == NULL, @@%d via %s",
d3029 1
a3029 1
		log(LOG_ERR, "pf_step_into_anchor: stack overflow\n");
d3962 1
a3962 1
			    "pf_normalize_tcp_stateful failed on first pkt");
d5799 1
a5799 1
		    "pf_route: m0->m_len < sizeof(struct ip)");
d5818 1
a5818 1
			    "pf_route: pf_map_addr() failed.");
d5848 1
a5848 1
			    "pf_route: m0->m_len < sizeof(struct ip)");
d5944 1
a5944 1
		    "pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
d5961 1
a5961 1
			    "pf_route6: pf_map_addr() failed.");
d5984 1
a5984 1
			    "pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
d6574 1
a6574 1
		    "pf_test: kif == NULL, if_xname %s", ifp->if_xname);
@


1.1004
log
@Use the sizeof udphdr not the sizeof a pointer to it in the af-to
specific part of pf_test_state_icmp().  This worked by accident on LP64
archs as the struct is eight bytes long.

ok mikeb@@ bluhm@@ krw@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1003 2016/11/28 23:15:30 bluhm Exp $ */
d1754 1
a1754 1
 	if (udp && *cksum == 0x0000)
d1759 1
a1759 1
        *cksum = (u_int16_t)(x);
d1849 1
a1849 1
	        break;
d2230 1
a2230 1
                copyback = 1;
d3631 2
a3632 2
		PF_TEST_ATTRIB((r->prio &&
		    (r->prio == PF_PRIO_ZERO ? 0 : r->prio) != pd->m->m_pkthdr.pf.prio),
d3655 1
a3655 1
#if NPFLOG > 0 
d4638 1
a4638 1
			return (action); 
d4641 1
a4641 1
		    	if (dst->state >= TCPS_FIN_WAIT_2 &&
d4658 2
a4659 2
                                /*
                                 * SYN matches existing state???
d4665 2
a4666 2
                                 */
                                pf_send_challenge_ack(pd, *state, src, dst);
d6048 1
a6048 1
	
@


1.1003
log
@Path MTU discovery and traceroute did not always work with pf af-to.
If an incoming packet is directly put into the output path, sending
the icmp error packet is never done.  As this is basically forwarding,
calling ip_forward() for such packets does everything that is needed.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1002 2016/11/23 12:13:23 bluhm Exp $ */
d5260 1
a5260 1
					m_copyback(pd2.m, pd2.off, sizeof(uh),
@


1.1002
log
@Explicitly forbid to combine af-to with route-to in pfctl.  The
parser cannot handle that correctly and is is unclear wether the
kernel code would work.  Remove the feature until someone needs it
and properly implements and tests it.
OK mike@@ sashan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1001 2016/11/22 19:29:54 procter Exp $ */
d6884 4
a6887 1
			ip_output(pd.m, NULL, NULL, 0, NULL, NULL, 0);
d6890 4
a6893 1
			ip6_output(pd.m, NULL, NULL, 0, NULL, NULL);
@


1.1001
log
@Fold union pf_headers buffer into struct pf_pdesc (enabled by pfvar_priv.h).
Prevent pf_socket_lookup() reading uninitialised header buffers on fragments.
OK blum@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1000 2016/11/21 15:23:18 bluhm Exp $ */
d6881 8
a6888 21
		if (r->rt) {
			switch (pd.naf) {
			case AF_INET:
				pf_route(&pd, r, s);
				break;
			case AF_INET6:
				pf_route6(&pd, r, s);
				break;
			}
		}
		if (pd.m) {
			pd.m->m_pkthdr.pf.flags |= PF_TAG_GENERATED;
			switch (pd.naf) {
			case AF_INET:
				ip_output(pd.m, NULL, NULL, 0, NULL, NULL, 0);
				break;
			case AF_INET6:
				ip6_output(pd.m, NULL, NULL, 0, NULL, NULL);
				break;
			}
			pd.m = NULL;
d6890 1
@


1.1000
log
@In pf_route() and pf_route6() the !r->rt case was only used by
af-to.  pf_route6() called ip6_output() to do the work while
pf_route() had some custom implementation for that.  It is simpler
to call ip_output() or ip6_output() from pf_test() directly.
OK procter@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.999 2016/11/17 13:17:32 bluhm Exp $ */
a775 1
	struct nd_neighbor_solicit *nd;
d781 1
a781 1
	switch (pd->hdr.icmp6->icmp6_type) {
d785 1
a785 2
		nd = (void *)pd->hdr.icmp6;
		target = (struct pf_addr *)&nd->nd_ns_target;
d791 1
a791 2
		nd = (void *)pd->hdr.icmp6;
		target = (struct pf_addr *)&nd->nd_ns_target;
d1978 1
a1978 1
			*virtual_id = pd->hdr.icmp->icmp_id;
d1986 1
a1986 1
			*virtual_id = pd->hdr.icmp->icmp_id;
d1994 1
a1994 1
			*virtual_id = pd->hdr.icmp->icmp_id;
d2002 1
a2002 1
			*virtual_id = pd->hdr.icmp->icmp_id;
d2060 1
a2060 1
			*virtual_id = pd->hdr.icmp6->icmp6_id;
d2067 1
a2067 1
			struct mld_hdr *mld = (void *)pd->hdr.icmp6;
d2104 1
a2104 1
			struct nd_neighbor_solicit *nd = (void *)pd->hdr.icmp6;
d2307 1
a2307 1
		m_copyback(pd->m, pd->off, pd->hdrlen, pd->hdr.any, M_NOWAIT);
d2624 1
a2624 1
	struct tcphdr	*th = pd->hdr.tcp;
d2824 1
a2824 1
	    pd->hdr.tcp->th_dport, pd->hdr.tcp->th_sport, dst->seqlo,
a3157 2
	if (pd == NULL)
		return (-1);
d3161 1
a3161 1
	switch (pd->proto) {
d3163 2
a3164 4
		if (pd->hdr.tcp == NULL)
			return (-1);
		sport = pd->hdr.tcp->th_sport;
		dport = pd->hdr.tcp->th_dport;
d3168 2
a3169 4
		if (pd->hdr.udp == NULL)
			return (-1);
		sport = pd->hdr.udp->uh_sport;
		dport = pd->hdr.udp->uh_dport;
d3226 1
a3226 1
	struct tcphdr	*th = pd->hdr.tcp;
d3267 1
a3267 1
	struct tcphdr	*th = pd->hdr.tcp;
d3404 2
a3405 2
	SHA512Update(&ctx, &pd->hdr.tcp->th_sport, sizeof(u_short));
	SHA512Update(&ctx, &pd->hdr.tcp->th_dport, sizeof(u_short));
a3469 1
	struct tcphdr		*th = pd->hdr.tcp;
d3493 2
a3494 2
		icmptype = pd->hdr.icmp->icmp_type;
		icmpcode = pd->hdr.icmp->icmp_code;
d3507 2
a3508 2
		icmptype = pd->hdr.icmp6->icmp6_type;
		icmpcode = pd->hdr.icmp6->icmp6_code;
d3564 1
a3564 1
			PF_TEST_ATTRIB(((r->flagset & th->th_flags) !=
d3718 3
a3720 2
		    !(th->th_flags & TH_RST)) {
			u_int32_t	 ack = ntohl(th->th_seq) + pd->p_len;
d3818 1
a3818 1
		m_copyback(pd->m, pd->off, pd->hdrlen, pd->hdr.any, M_NOWAIT);
d3859 1
a3859 1
	struct tcphdr		*th = pd->hdr.tcp;
d4076 1
a4076 1
			if (pf_translate_icmp_af(pd, AF_INET6, pd->hdr.icmp))
d4085 1
a4085 1
			    &pd->hdr.icmp->icmp_id, icmpid);
d4096 1
a4096 1
			if (pf_translate_icmp_af(pd, AF_INET, pd->hdr.icmp6))
d4104 1
a4104 1
			    &pd->hdr.icmp6->icmp6_id, icmpid);
d4123 1
a4123 1
	struct tcphdr		*th = pd->hdr.tcp;
d4446 1
a4446 1
	struct tcphdr		*th = pd->hdr.tcp;
d4519 1
a4519 1
		struct tcphdr	*th = pd->hdr.tcp;
d4550 1
a4550 1
		struct tcphdr	*th = pd->hdr.tcp;
d4639 1
a4639 1
		if ((pd->hdr.tcp->th_flags & (TH_SYN|TH_ACK)) == TH_SYN) {
d4646 1
a4646 1
					pf_print_flags(pd->hdr.tcp->th_flags);
d4764 1
a4764 1
		m_copyback(pd->m, pd->off, pd->hdrlen, pd->hdr.any, M_NOWAIT);
d4832 1
a4832 1
		icmptype = pd->hdr.icmp->icmp_type;
d4836 1
a4836 1
		icmptype = pd->hdr.icmp6->icmp6_type;
d4900 1
a4900 1
					    pd->hdr.icmp))
d4906 1
a4906 1
				    &pd->hdr.icmp->icmp_id, nk->port[iidx]);
d4909 1
a4909 1
				    pd->hdr.icmp, M_NOWAIT);
d4916 1
a4916 1
					    pd->hdr.icmp6))
d4922 1
a4922 1
				    &pd->hdr.icmp6->icmp6_id, nk->port[iidx]);
d4925 1
a4925 1
				    sizeof(struct icmp6_hdr), pd->hdr.icmp6,
d5013 1
a5013 1
			struct tcphdr		 th;
d5023 1
a5023 1
			if (!pf_pull_hdr(pd2.m, pd2.off, &th, 8, NULL, reason,
d5035 2
a5036 2
			key.port[pd2.sidx] = th.th_sport;
			key.port[pd2.didx] = th.th_dport;
d5064 1
a5064 1
			seq = ntohl(th.th_seq) - src->seqdiff;
d5066 1
a5066 1
				pf_patch_32(pd, &th.th_seq, htonl(seq));
d5076 1
a5076 1
					    icmptype, pd->hdr.icmp->icmp_code);
d5090 1
a5090 1
					    icmptype, pd->hdr.icmp->icmp_code);
d5118 1
a5118 1
					    pd->hdr.icmp))
d5122 1
a5122 1
					    pd->hdr.icmp6, M_NOWAIT);
d5141 1
a5141 1
					    &th.th_sport, nk->port[sidx]);
d5143 1
a5143 1
					    &th.th_dport, nk->port[didx]);
d5145 1
a5145 1
					m_copyback(pd2.m, pd2.off, 8, &th,
d5152 1
a5152 1
				    nk->port[pd2.sidx] != th.th_sport)
d5154 1
a5154 1
					    &th.th_sport, pd->dst,
d5165 1
a5165 1
				    nk->port[pd2.didx] != th.th_dport)
d5167 1
a5167 1
					    &th.th_dport, pd->src,
d5177 1
a5177 1
					    pd->hdr.icmp, M_NOWAIT);
d5185 1
a5185 1
					    pd->hdr.icmp6, M_NOWAIT);
d5191 1
a5191 1
				m_copyback(pd2.m, pd2.off, 8, &th, M_NOWAIT);
d5196 1
a5196 1
			struct udphdr		uh;
d5198 1
a5198 1
			if (!pf_pull_hdr(pd2.m, pd2.off, &uh, sizeof(uh),
d5210 2
a5211 2
			key.port[pd2.sidx] = uh.uh_sport;
			key.port[pd2.didx] = uh.uh_dport;
d5233 1
a5233 1
					    pd->hdr.icmp))
d5237 1
a5237 1
					    pd->hdr.icmp6, M_NOWAIT);
d5256 1
a5256 1
					    &uh.uh_sport, nk->port[sidx]);
d5258 1
a5258 1
					    &uh.uh_dport, nk->port[didx]);
d5261 1
a5261 1
					    &uh, M_NOWAIT);
d5268 1
a5268 1
				    nk->port[pd2.sidx] != uh.uh_sport)
d5270 1
a5270 1
					    &uh.uh_sport, pd->dst,
d5281 1
a5281 1
				    nk->port[pd2.didx] != uh.uh_dport)
d5283 1
a5283 1
					    &uh.uh_dport, pd->src,
d5290 1
a5290 1
					    pd->hdr.icmp, M_NOWAIT);
d5298 1
a5298 1
					    pd->hdr.icmp6, M_NOWAIT);
d5307 2
a5308 2
				pf_patch_16(pd, &uh.uh_sum, 0);
				m_copyback(pd2.m, pd2.off, sizeof(uh), &uh,
d5315 1
a5315 1
			struct icmp		iih;
d5322 1
a5322 1
			if (!pf_pull_hdr(pd2.m, pd2.off, &iih, ICMP_MINLEN,
d5329 1
a5329 2
			pd2.hdr.icmp = &iih;
			pf_icmp_mapping(&pd2, iih.icmp_type,
d5358 1
a5358 1
					    pd->hdr.icmp))
d5362 1
a5362 1
					    pd->hdr.icmp6, M_NOWAIT);
d5369 1
a5369 1
						nk->af, &iih))
d5372 1
a5372 1
						pf_patch_16(pd, &iih.icmp_id,
d5375 1
a5375 1
					    &iih, M_NOWAIT);
d5391 1
a5391 1
				    nk->port[iidx] != iih.icmp_id))
d5394 1
a5394 1
					    &iih.icmp_id : NULL,
d5410 1
a5410 1
				    pd->hdr.icmp, M_NOWAIT);
d5413 1
a5413 1
				m_copyback(pd2.m, pd2.off, ICMP_MINLEN, &iih,
d5421 1
a5421 1
			struct icmp6_hdr	iih;
d5428 1
a5428 1
			if (!pf_pull_hdr(pd2.m, pd2.off, &iih,
d5435 1
a5435 2
			pd2.hdr.icmp6 = &iih;
			pf_icmp_mapping(&pd2, iih.icmp6_type,
d5468 1
a5468 1
					    pd->hdr.icmp))
d5472 1
a5472 1
					    pd->hdr.icmp6, M_NOWAIT);
d5479 1
a5479 1
						nk->af, &iih))
d5483 1
a5483 1
						pf_patch_16(pd, &iih.icmp6_id,
d5486 1
a5486 1
					    sizeof(struct icmp6_hdr), &iih,
d5503 1
a5503 1
				    nk->port[pd2.sidx] != iih.icmp6_id))
d5507 1
a5507 1
					    ? &iih.icmp6_id : NULL,
d5524 1
a5524 1
				    sizeof(struct icmp6_hdr), pd->hdr.icmp6,
d5529 1
a5529 1
				    sizeof(struct icmp6_hdr), &iih, M_NOWAIT);
d5569 1
a5569 1
					    pd->hdr.icmp, M_NOWAIT);
d5577 1
a5577 1
					    pd->hdr.icmp6, M_NOWAIT);
d5590 1
a5590 1
		m_copyback(pd->m, pd->off, pd->hdrlen, pd->hdr.any, M_NOWAIT);
d6299 1
a6299 1
pf_setup_pdesc(struct pf_pdesc *pd, void *pdhdrs, sa_family_t af, int dir,
a6302 1
	pd->hdr.any = pdhdrs;
d6401 1
a6401 1
		struct tcphdr	*th = pd->hdr.tcp;
d6419 1
a6419 1
		struct udphdr	*uh = pd->hdr.udp;
d6437 1
a6437 1
		if (!pf_pull_hdr(pd->m, pd->off, pd->hdr.icmp, ICMP_MINLEN,
d6445 1
a6445 1
		pd->pcksum = &pd->hdr.icmp->icmp_cksum;
d6452 1
a6452 1
		if (!pf_pull_hdr(pd->m, pd->off, pd->hdr.icmp6, icmp_hlen,
d6456 1
a6456 1
		switch (pd->hdr.icmp6->icmp6_type) {
d6467 1
a6467 1
		    !pf_pull_hdr(pd->m, pd->off, pd->hdr.icmp6, icmp_hlen,
d6475 1
a6475 1
		pd->pcksum = &pd->hdr.icmp6->icmp6_cksum;
a6558 1
	union pf_headers	 pdhdrs;
d6596 1
a6596 1
	action = pf_setup_pdesc(&pd, &pdhdrs, af, dir, kif, *m0, &reason);
d6628 1
a6628 2
		action = pf_setup_pdesc(&pd, &pdhdrs, af, dir, kif, pd.m,
		    &reason);
d6703 1
a6703 1
			if ((pd.hdr.tcp->th_flags & TH_ACK) && pd.p_len == 0)
@


1.999
log
@The pf fragment reassembly code accepted IPv6 hop-by-hop headers
after fragment headers.  Add an extra check that the hop-by-hop
header is always the first extension header after the IPv6 header.
Found by Antonios Atlasis; OK sthen@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.998 2016/11/14 13:25:00 bluhm Exp $ */
d5823 7
a5829 4
	if (!r->rt) {
		rt = rtalloc(sintosa(dst), RT_RESOLVE, rtableid);
		if (rt == NULL) {
			ipstat_inc(ips_noroute);
d5833 4
a5836 6
		ifp = if_get(rt->rt_ifidx);

		if (rt->rt_flags & RTF_GATEWAY)
			dst = satosin(rt->rt_gateway);

		m0->m_pkthdr.pf.flags |= PF_TAG_GENERATED;
d5838 4
a5841 26
		if (s == NULL) {
			bzero(sns, sizeof(sns));
			if (pf_map_addr(AF_INET, r,
			    (struct pf_addr *)&ip->ip_src,
			    &naddr, NULL, sns, &r->route, PF_SN_ROUTE)) {
				DPFPRINTF(LOG_ERR,
				    "pf_route: pf_map_addr() failed.");
				goto bad;
			}

			if (!PF_AZERO(&naddr, AF_INET))
				dst->sin_addr.s_addr = naddr.v4.s_addr;
			ifp = r->route.kif ?
			    r->route.kif->pfik_ifp : NULL;
		} else {
			if (!PF_AZERO(&s->rt_addr, AF_INET))
				dst->sin_addr.s_addr =
				    s->rt_addr.v4.s_addr;
			ifp = s->rt_kif ? s->rt_kif->pfik_ifp : NULL;
		}

		rt = rtalloc(sintosa(dst), RT_RESOLVE, rtableid);
		if (rt == NULL) {
			ipstat_inc(ips_noroute);
			goto bad;
		}
d5846 5
a5914 2
	if (!r->rt)
		if_put(ifp);
a5966 6
	if (!r->rt) {
		m0->m_pkthdr.pf.flags |= PF_TAG_GENERATED;
		ip6_output(m0, NULL, NULL, 0, NULL, NULL);
		goto done;
	}

d6895 22
a6916 4
		if (pd.naf == AF_INET)
			pf_route(&pd, r, s);
		if (pd.naf == AF_INET6)
			pf_route6(&pd, r, s);
@


1.998
log
@Instead of passing an extra mbuf pointer to pf_route(), it should
just use pd->m.  Then pf_test() can also operate on pd.m and set
the *m0 value in the caller just before it returns.
OK sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.997 2016/11/14 03:51:53 dlg Exp $ */
d6210 1
a6210 1
	int			 fraghdr_cnt = 0, rthdr_cnt = 0;
d6217 1
d6270 8
a6278 1
		case IPPROTO_HOPOPTS:
@


1.997
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the ipstat struct.

ipstat_inc(ips_foo) replaces ipstat.ips_foo++ for the actual updates.
ipstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the ipstat struct for now.

ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.996 2016/10/28 07:54:19 sashan Exp $ */
d2199 1
d5779 1
d5781 1
a5781 2
pf_route(struct mbuf **m, struct pf_pdesc *pd, struct pf_rule *r,
    struct pf_state *s)
d5793 4
a5796 7
	if (m == NULL || *m == NULL || r == NULL)
		panic("pf_route: invalid parameters");

	if ((*m)->m_pkthdr.pf.routed++ > 3) {
		m0 = *m;
		*m = NULL;
		goto bad;
d5800 1
a5800 1
		if ((m0 = m_dup_pkt(*m, max_linkhdr, M_NOWAIT)) == NULL)
d5805 1
a5805 1
		m0 = *m;
d5930 1
a5930 1
		*m = NULL;
d5942 1
d5944 1
a5944 2
pf_route6(struct mbuf **m, struct pf_pdesc *pd, struct pf_rule *r,
    struct pf_state *s)
d5956 4
a5959 7
	if (m == NULL || *m == NULL || r == NULL)
		panic("pf_route6: invalid parameters");

	if ((*m)->m_pkthdr.pf.routed++ > 3) {
		m0 = *m;
		*m = NULL;
		goto bad;
d5963 1
a5963 1
		if ((m0 = m_dup_pkt(*m, max_linkhdr, M_NOWAIT)) == NULL)
d5968 1
a5968 1
		m0 = *m;
d5988 1
a5988 1
		return;
d6049 1
a6049 1
		*m = NULL;
d6657 1
a6657 1
		action = pf_setup_pdesc(&pd, &pdhdrs, af, dir, kif, *m0,
d6883 2
a6884 1
		m_freem(*m0);
d6886 1
a6886 1
		*m0 = NULL;
d6893 1
a6893 1
				*m0 = NULL;
d6899 1
a6899 1
				*m0 = NULL;
a6907 2
			if (!pd.m)
				*m0 = NULL;
d6912 1
a6912 1
			pf_route(&pd.m, &pd, r, s);
d6914 1
a6914 2
			pf_route6(&pd.m, &pd, r, s);
		*m0 = NULL;
d6919 2
a6920 2
		m_freem(*m0);
		*m0 = NULL;
a6922 1
		/* pf_route can free the mbuf causing *m0 to become NULL */
d6926 1
a6926 1
				pf_route(m0, &pd, r, s);
d6930 1
a6930 1
				pf_route6(m0, &pd, r, s);
d6940 1
a6940 1
	if (pf_status.reass && action == PF_PASS && *m0 && fwdir == PF_FWD) {
d6943 2
a6944 2
		if ((mtag = m_tag_find(*m0, PACKET_TAG_PF_REASSEMBLED, NULL)))
			action = pf_refragment6(m0, mtag, NULL, NULL);
d6954 1
@


1.996
log
@- once rule should not attempt to remove its parent rule.
  (problem pointed out by Petr, fix proposed by Dilli) _at_ oracle
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.995 2016/10/27 21:41:20 bluhm Exp $ */
d5828 1
a5828 1
			ipstat.ips_noroute++;
d5862 1
a5862 1
			ipstat.ips_noroute++;
d5890 1
a5890 1
			ipstat.ips_outswcsum++;
d5902 1
a5902 1
		ipstat.ips_cantfrag++;
d5928 1
a5928 1
		ipstat.ips_fragmented++;
@


1.995
log
@Pass a struct pf_pdesc to pf_route() like it is done in the other
pf functions.  That means less parameters, more consistency and
later we can call functions that need a pd from pf_route().
OK sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.994 2016/10/26 21:07:22 bluhm Exp $ */
a3843 6
		if ((a != NULL) && TAILQ_EMPTY(a->ruleset->rules.active.ptr)) {
			a->rule_flag |= PFRULE_EXPIRED;
			a->exptime = time_second;
			SLIST_INSERT_HEAD(&pf_rule_gcl, a, gcle);
		}

@


1.994
log
@Put union pf_headers and struct pf_pdesc into separate header file
pfvar_priv.h.  The pf_headers had to be defined in multiple .c files
before.  In pfvar.h it would have unknown storage size, this file
is included in too many places.  The idea is to have a private pf
header that is only included in the pf part of the kernel.  For now
it contains pf_pdesc and pf_headers, it may be extended later.
discussion, input and OK henning@@ procter@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.993 2016/10/20 23:18:43 sashan Exp $ */
d5785 1
a5785 1
pf_route(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp,
d5798 1
a5798 2
	if (m == NULL || *m == NULL || r == NULL ||
	    (dir != PF_IN && dir != PF_OUT) || oifp == NULL)
d5811 1
a5811 1
		if ((r->rt == PF_REPLYTO) == (r->direction == dir))
d5876 1
a5876 1
	if (oifp != ifp) {
d5951 1
a5951 1
pf_route6(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp,
d5964 1
a5964 2
	if (m == NULL || *m == NULL || r == NULL ||
	    (dir != PF_IN && dir != PF_OUT) || oifp == NULL)
d5977 1
a5977 1
		if ((r->rt == PF_REPLYTO) == (r->direction == dir))
d6023 1
a6023 1
	if (oifp != ifp) {
d6924 1
a6924 1
			pf_route(&pd.m, r, dir, kif->pfik_ifp, s);
d6926 1
a6926 1
			pf_route6(&pd.m, r, dir, kif->pfik_ifp, s);
d6940 1
a6940 1
				pf_route(m0, r, pd.dir, pd.kif->pfik_ifp, s);
d6944 1
a6944 1
				pf_route6(m0, r, pd.dir, pd.kif->pfik_ifp, s);
@


1.993
log
@- PF should send a challenge ACK as response to SYN, which matches existing
  state. Extra thanks goes to bluhm@@ for careful testing and fixing patch I've
  sent to tech@@

O.K. henning@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.992 2016/10/18 13:28:01 henning Exp $ */
d66 1
d68 2
a71 3
#include <netinet/udp.h>
#include <netinet/ip_icmp.h>
#include <netinet/in_pcb.h>
d75 1
a76 1
#include <netinet/icmp_var.h>
d79 8
d88 1
a101 9
#ifdef INET6
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
#include <netinet6/nd6.h>
#include <netinet6/ip6_divert.h>
#endif /* INET6 */

a127 16

/*
 * Cannot fold into pf_pdesc directly, unknown storage size outside pf.c.
 * Keep in sync with union pf_headers in pflog_bpfcopy() in if_pflog.c.
 */
union pf_headers {
	struct tcphdr		tcp;
	struct udphdr		udp;
	struct icmp		icmp;
#ifdef INET6
	struct icmp6_hdr	icmp6;
	struct mld_hdr		mld;
	struct nd_neighbor_solicit nd_ns;
#endif /* INET6 */
};

@


1.992
log
@split pf_send_tcp() into the part that builds the mbuf and the actual
sending, needed soon. ok sashan mikeb lteo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.991 2016/10/18 11:29:27 bluhm Exp $ */
d2828 19
d4669 29
a4697 8
		if (((pd->hdr.tcp->th_flags & (TH_SYN|TH_ACK)) == TH_SYN) &&
		    dst->state >= TCPS_FIN_WAIT_2 &&
		    src->state >= TCPS_FIN_WAIT_2) {
			if (pf_status.debug >= LOG_NOTICE) {
				log(LOG_NOTICE, "pf: state reuse ");
				pf_print_state(*state);
				pf_print_flags(pd->hdr.tcp->th_flags);
				addlog("\n");
a4698 6
			/* XXX make sure it's the same direction ?? */
			(*state)->src.state = (*state)->dst.state = TCPS_CLOSED;
			pf_remove_state(*state);
			*state = NULL;
			pd->m->m_pkthdr.pf.inp = inp;
			return (PF_DROP);
@


1.991
log
@The variable dlen is always positive and d may be negative.  So
declare both with the correct sign in pf_change_icmp_af().
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.990 2016/10/18 11:20:42 bluhm Exp $ */
a172 5
void			 pf_send_tcp(const struct pf_rule *, sa_family_t,
			    const struct pf_addr *, const struct pf_addr *,
			    u_int16_t, u_int16_t, u_int32_t, u_int32_t,
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t, int,
			    u_int16_t, u_int);
d2698 2
a2699 2
void
pf_send_tcp(const struct pf_rule *r, sa_family_t af,
d2735 1
a2735 1
		return;
d2799 16
@


1.990
log
@The checksum of a ICMP "need to frag" packet for TCP was wrong when
created from a ICMP6 "too big" packet.  The function pf_change_icmp_af()
has code to adjust the pseudo-header checksum in the ICMP6 case,
but pf_test_state_icmp() changed the proto before the case was
entered.
So call pf_change_icmp_af() before the pd->proto is converted in
the TCP and UDP payload case like it was already done for ICMP and
ICMP6 payload.
Found by sys/net/pf_forward regress test; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.989 2016/10/09 18:01:57 henning Exp $ */
d2343 2
a2344 1
	u_int			 hlen, ohlen, d;
d2421 1
a2421 1
		int dlen = pd->tot_len - pd->off;
@


1.989
log
@formatting nit (a tab got lost somewhen)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.988 2016/10/06 19:09:08 bluhm Exp $ */
d5107 4
a5123 5
					if (pf_change_icmp_af(pd->m, ipoff2,
					    pd, &pd2, &nk->addr[sidx],
					    &nk->addr[didx], pd->af, nk->af))
						return (PF_DROP);

d5222 4
a5237 5

					if (pf_change_icmp_af(pd->m, ipoff2,
					    pd, &pd2, &nk->addr[sidx],
					    &nk->addr[didx], pd->af, nk->af))
						return (PF_DROP);
@


1.988
log
@Remove redundant comments that say a function must be called at
splsoftnet() if the function does a splsoftassert(IPL_SOFTNET)
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.987 2016/09/27 04:57:17 dlg Exp $ */
d267 1
a267 1
		s = pf_find_state(i, k, d, m);			\
@


1.987
log
@roll back turning RB into RBT until i get better at this process.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.986 2016/09/27 02:51:12 dlg Exp $ */
a1310 1
/* callers should be at splsoftnet */
d1356 1
a1356 2
/* callers should be at splsoftnet and hold the
 * write_lock on pf_consistency_lock */
@


1.986
log
@move pf from the RB macros to the RBT functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.985 2016/09/22 10:50:19 jsg Exp $ */
d296 5
a300 6
static __inline int pf_src_compare(const struct pf_src_node *,
	const struct pf_src_node *);
static __inline int pf_state_compare_key(const struct pf_state_key *,
	const struct pf_state_key *);
static __inline int pf_state_compare_id(const struct pf_state *,
	const struct pf_state *);
d309 3
a311 3
RBT_GENERATE(pf_src_tree, pf_src_node, entry, pf_src_compare);
RBT_GENERATE(pf_state_tree, pf_state_key, entry, pf_state_compare_key);
RBT_GENERATE(pf_state_tree_id, pf_state,
d318 1
a318 2
pf_addr_compare(const struct pf_addr *a, const struct pf_addr *b,
    sa_family_t af)
d352 1
a352 1
pf_src_compare(const struct pf_src_node *a, const struct pf_src_node *b)
d483 1
a483 1
			RBT_FOREACH(st, pf_state_tree_id, &tree_id) {
d531 1
a531 1
		*sn = RBT_FIND(pf_src_tree, &tree_src_tracking, &k);
d552 1
a552 1
		if (RBT_INSERT(pf_src_tree,
d587 1
a587 1
	RBT_REMOVE(pf_src_tree, &tree_src_tracking, sn);
d628 1
a628 1
pf_state_compare_key(const struct pf_state_key *a, const struct pf_state_key *b)
d650 1
a650 1
pf_state_compare_id(const struct pf_state *a, const struct pf_state *b)
d672 1
a672 1
	if ((cur = RBT_INSERT(pf_state_tree, &pf_statetbl, sk)) != NULL) {
d771 1
a771 1
		RBT_REMOVE(pf_state_tree, &pf_statetbl, sk);
d947 1
a947 1
	if (RBT_INSERT(pf_state_tree_id, &tree_id, s) != NULL) {
d972 1
a972 1
	return (RBT_FIND(pf_state_tree_id, &tree_id, (struct pf_state *)key));
d1051 1
a1051 1
		if ((sk = RBT_FIND(pf_state_tree, &pf_statetbl,
d1087 1
a1087 1
	sk = RBT_FIND(pf_state_tree, &pf_statetbl, (struct pf_state_key *)key);
d1272 2
a1273 2
	for (cur = RBT_MIN(pf_src_tree, &tree_src_tracking); cur; cur = next) {
		next = RBT_NEXT(pf_src_tree, cur);
d1278 2
a1279 1
				next = RBT_NEXT(pf_src_tree, cur);
d1330 1
a1330 1
	RBT_REMOVE(pf_state_tree_id, &tree_id, cur);
d3028 1
a3028 1
		if ((f->child = RBT_MIN(pf_anchor_node, f->parent)) == NULL) {
d3053 1
a3053 1
			f->child = RBT_NEXT(pf_anchor_node, f->child);
@


1.985
log
@Fix indentation.  No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.984 2016/09/07 09:36:49 mpi Exp $ */
d296 6
a301 5
static __inline int pf_src_compare(struct pf_src_node *, struct pf_src_node *);
static __inline int pf_state_compare_key(struct pf_state_key *,
	struct pf_state_key *);
static __inline int pf_state_compare_id(struct pf_state *,
	struct pf_state *);
d310 3
a312 3
RB_GENERATE(pf_src_tree, pf_src_node, entry, pf_src_compare);
RB_GENERATE(pf_state_tree, pf_state_key, entry, pf_state_compare_key);
RB_GENERATE(pf_state_tree_id, pf_state,
d319 2
a320 1
pf_addr_compare(struct pf_addr *a, struct pf_addr *b, sa_family_t af)
d354 1
a354 1
pf_src_compare(struct pf_src_node *a, struct pf_src_node *b)
d485 1
a485 1
			RB_FOREACH(st, pf_state_tree_id, &tree_id) {
d533 1
a533 1
		*sn = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
d554 1
a554 1
		if (RB_INSERT(pf_src_tree,
d589 1
a589 1
	RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
d630 1
a630 1
pf_state_compare_key(struct pf_state_key *a, struct pf_state_key *b)
d652 1
a652 1
pf_state_compare_id(struct pf_state *a, struct pf_state *b)
d674 1
a674 1
	if ((cur = RB_INSERT(pf_state_tree, &pf_statetbl, sk)) != NULL) {
d773 1
a773 1
		RB_REMOVE(pf_state_tree, &pf_statetbl, sk);
d949 1
a949 1
	if (RB_INSERT(pf_state_tree_id, &tree_id, s) != NULL) {
d974 1
a974 1
	return (RB_FIND(pf_state_tree_id, &tree_id, (struct pf_state *)key));
d1053 1
a1053 1
		if ((sk = RB_FIND(pf_state_tree, &pf_statetbl,
d1089 1
a1089 1
	sk = RB_FIND(pf_state_tree, &pf_statetbl, (struct pf_state_key *)key);
d1274 2
a1275 2
	for (cur = RB_MIN(pf_src_tree, &tree_src_tracking); cur; cur = next) {
	next = RB_NEXT(pf_src_tree, &tree_src_tracking, cur);
d1280 1
a1280 2
				next = RB_NEXT(pf_src_tree,
				    &tree_src_tracking, cur);
d1331 1
a1331 1
	RB_REMOVE(pf_state_tree_id, &tree_id, cur);
d3029 1
a3029 1
		if ((f->child = RB_MIN(pf_anchor_node, f->parent)) == NULL) {
d3054 1
a3054 1
			f->child = RB_NEXT(pf_anchor_node, f->parent, f->child);
@


1.984
log
@Rename rtable_mpath_next() into rtable_iterate() and make it do a proper
reference count.

rtable_iterate() frees the passed ``rt'' and returns the next one on the
multipath list or NULL if there's none.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.983 2016/09/03 17:11:40 sashan Exp $ */
d1890 1
a1890 1
 	*cksum = (u_int16_t)(x);
@


1.983
log
@Let purge thread to remove once rules, not packets.
Thanks mikeb@@ for idea to add expire time.

OK mpi@@, OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.982 2016/08/20 08:34:30 procter Exp $ */
d5646 1
a5646 1
	struct rtentry		*rt, *rt0 = NULL;
d5681 2
a5682 2
	rt0 = rtalloc((struct sockaddr *)&ss, 0, rtableid);
	if (rt0 != NULL) {
a5693 1
		rt = rt0;
d5709 1
a5709 5
#ifndef SMALL_KERNEL
			rt = rtable_mpath_next(rt);
#else
			rt = NULL;
#endif /* SMALL_KERNEL */
d5714 1
a5714 1
	rtfree(rt0);
@


1.982
log
@Push 'field changed' guards into 'change field' functions;
optimise pf_patch_32(); simplify pf_match_addr()
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.981 2016/08/20 08:31:36 procter Exp $ */
d314 3
d1180 23
d1220 1
d3521 4
d3830 11
a3840 2
	if (r->rule_flag & PFRULE_ONCE)
		pf_purge_rule(ruleset, r, aruleset, a);
@


1.981
log
@Retire pf_translate_ap()
OK mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.980 2016/08/17 03:24:11 procter Exp $ */
d167 1
a167 1
void			 pf_translate_a(struct pf_pdesc *, struct pf_addr *,
d1866 1
a1866 1
void
d1869 1
a1869 2
	u_int16_t new = htons(hi ? ( v << 8) :  v);
	u_int16_t old = htons(hi ? (*f << 8) : *f);
d1871 10
a1880 2
	pf_cksum_fixup(pd->pcksum, old, new, pd->proto);
	*f = v;
d1884 1
a1884 1
void
d1887 9
a1895 2
	pf_cksum_fixup(pd->pcksum, *f, v, pd->proto);
	*f = v;
d1898 1
a1898 1
void
d1901 3
a1903 2
	u_int8_t *fb = (u_int8_t*)f;
	u_int8_t *vb = (u_int8_t*)&v;
d1906 1
a1906 2
		pf_patch_16(pd, f, v); /* optimise */
		return;
d1909 4
a1912 2
	pf_patch_8(pd, fb++, *vb++, hi);
	pf_patch_8(pd, fb++, *vb++,!hi);
d1916 2
a1917 1
void
d1920 11
a1930 1
	u_int16_t *pc = pd->pcksum;
a1931 2
	pf_cksum_fixup(pc, *f / (1 << 16), v / (1 << 16), pd->proto);
	pf_cksum_fixup(pc, *f % (1 << 16), v % (1 << 16), pd->proto);
d1933 3
d1938 1
a1938 1
void
d1941 3
a1943 2
	u_int8_t *fb = (u_int8_t*)f;
	u_int8_t *vb = (u_int8_t*)&v;
d1946 1
a1946 2
		pf_patch_32(pd, f, v); /* optimise */
		return;
d1949 6
a1954 4
	pf_patch_8(pd, fb++, *vb++, hi);
	pf_patch_8(pd, fb++, *vb++,!hi);
	pf_patch_8(pd, fb++, *vb++, hi);
	pf_patch_8(pd, fb++, *vb++,!hi);
d2168 1
a2168 1
void
d2171 6
d2189 3
d2820 2
a2821 3
 * Return 1 if the addresses a and b match (with mask m), otherwise return 0.
 * If n is 0, they match if they are equal. If n is != 0, they match if they
 * are different.
a2826 2
	int	match = 0;

d2831 1
a2831 1
			match++;
d2843 1
a2843 1
			match++;
d2847 2
a2848 11
	if (match) {
		if (n)
			return (0);
		else
			return (1);
	} else {
		if (n)
			return (1);
		else
			return (0);
	}
d4024 1
a4024 17
	case IPPROTO_TCP:
		if (afto || PF_ANEQ(saddr, pd->src, pd->af) ||
		    *pd->sport != sport) {
			if (pd->af == pd->naf)
				pf_translate_a(pd, pd->src, saddr);
			pf_patch_16(pd, pd->sport, sport);
			rewrite = 1;
		}
		if (afto || PF_ANEQ(daddr, pd->dst, pd->af) ||
		    *pd->dport != dport) {
			if (pd->af == pd->naf)
				pf_translate_a(pd, pd->dst, daddr);
			pf_patch_16(pd, pd->dport, dport);
			rewrite = 1;
		}
		break;

d4026 2
a4027 14
		if (afto || PF_ANEQ(saddr, pd->src, pd->af) ||
		    *pd->sport != sport) {
			if (pd->af == pd->naf)
				pf_translate_a(pd, pd->src, saddr);
			pf_patch_16(pd, pd->sport, sport);
			rewrite = 1;
		}
		if (afto || PF_ANEQ(daddr, pd->dst, pd->af) ||
		    *pd->dport != dport) {
			if (pd->af == pd->naf)
				pf_translate_a(pd, pd->dst, daddr);
			pf_patch_16(pd, pd->dport, dport);
			rewrite = 1;
		}
a4041 9
		} else {
			if (PF_ANEQ(saddr, pd->src, pd->af)) {
				pf_translate_a(pd, pd->src, saddr);
				rewrite = 1;
			}
			if (PF_ANEQ(daddr, pd->dst, pd->af)) {
				pf_translate_a(pd, pd->dst, daddr);
				rewrite = 1;
			}
d4045 2
a4046 6

			if (icmpid != pd->hdr.icmp->icmp_id) {
				pf_patch_16(pd,
				    &pd->hdr.icmp->icmp_id, icmpid);
				rewrite = 1;
			}
a4060 9
		} else {
			if (PF_ANEQ(saddr, pd->src, pd->af)) {
				pf_translate_a(pd, pd->src, saddr);
				rewrite = 1;
			}
			if (PF_ANEQ(daddr, pd->dst, pd->af)) {
				pf_translate_a(pd, pd->dst, daddr);
				rewrite = 1;
			}
d4064 2
a4065 6

			if (icmpid != pd->hdr.icmp6->icmp6_id) {
				pf_patch_16(pd,
				    &pd->hdr.icmp6->icmp6_id, icmpid);
				rewrite = 1;
			}
d4069 1
d4071 3
a4073 25
	default:
		switch (pd->af) {
		case AF_INET:
			if (!afto && PF_ANEQ(saddr, pd->src, pd->af)) {
				pf_translate_a(pd, pd->src, saddr);
				rewrite = 1;
			}
			if (!afto && PF_ANEQ(daddr, pd->dst, pd->af)) {
				pf_translate_a(pd, pd->dst, daddr);
				rewrite = 1;
			}
			break;
#ifdef INET6
		case AF_INET6:
			if (!afto && PF_ANEQ(saddr, pd->src, pd->af)) {
				pf_translate_a(pd, pd->src, saddr);
				rewrite = 1;
			}
			if (!afto && PF_ANEQ(daddr, pd->dst, pd->af)) {
				pf_translate_a(pd, pd->dst, daddr);
				rewrite = 1;
			}
			break;
#endif /* INET6 */
		}
d4075 1
d4689 5
a4693 7
		if (afto || PF_ANEQ(pd->src, &nk->addr[sidx], pd->af) ||
		    nk->port[sidx] != pd->osport) {
			if (pd->af == pd->naf)
				pf_translate_a(pd, pd->src, &nk->addr[sidx]);
			if (pd->sport != NULL)
				pf_patch_16(pd, pd->sport, nk->port[sidx]);
		}
d4699 5
a4703 7
		if (afto || PF_ANEQ(pd->dst, &nk->addr[didx], pd->af) ||
		    nk->port[didx] != pd->odport) {
			if (pd->af == pd->naf)
				pf_translate_a(pd, pd->dst, &nk->addr[didx]);
			if (pd->dport != NULL)
				pf_patch_16(pd, pd->dport, nk->port[didx]);
		}
d4829 5
d4836 3
d4851 2
a4852 16
				if (!afto && PF_ANEQ(pd->src,
				    &nk->addr[sidx], AF_INET))
					pf_translate_a(pd,
					    pd->src, &nk->addr[sidx]);

				if (!afto && PF_ANEQ(pd->dst,
				    &nk->addr[didx], AF_INET)) {
					pf_translate_a(pd,
					    pd->dst, &nk->addr[didx]);
					pd->destchg = 1;
				}

				if (nk->port[iidx] !=  pd->hdr.icmp->icmp_id) {
					pf_patch_16(pd, &pd->hdr.icmp->icmp_id,
					    nk->port[iidx]);
				}
a4865 5
				if (!afto && PF_ANEQ(pd->src,
				    &nk->addr[sidx], AF_INET6)) {
					pf_translate_a(pd,
					    pd->src, &nk->addr[sidx]);
				}
d4867 2
a4868 12
				if (!afto && PF_ANEQ(pd->dst,
				    &nk->addr[didx], AF_INET6)) {
					pf_translate_a(pd,
					    pd->dst, &nk->addr[didx]);
					pd->destchg = 1;
				}

				if (nk->port[iidx] != pd->hdr.icmp6->icmp6_id) {
					pf_patch_16(pd,
					    &pd->hdr.icmp6->icmp6_id,
					    nk->port[iidx]);
				}
d5320 1
a5320 2
					if (virtual_type == htons(ICMP_ECHO) &&
					    nk->port[iidx] != iih.icmp_id)
d5432 1
a5432 2
					    htons(ICMP6_ECHO_REQUEST) &&
					    nk->port[iidx] != iih.icmp6_id)
@


1.980
log
@Reintroduce 5.3-style checksum modification to preserve end-to-end checksums
when fiddling with packets but without the mess that motivated Henning to
remove it. Affects only this one aspect of Henning's checksum work. Also tweak
the basic algorithm and supply a correctness argument.

OK dlg@@ deraadt@@ sthen@@; no objection henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.979 2016/07/18 13:17:44 bluhm Exp $ */
a156 2
void			 pf_translate_ap(struct pf_pdesc *, struct pf_addr *,
			    u_int16_t *, struct pf_addr *, u_int16_t);
a1910 10
pf_translate_ap(struct pf_pdesc *pd, struct pf_addr *a, u_int16_t *p,
    struct pf_addr *an, u_int16_t pn)
{
	if (pd->af == pd->naf)
		pf_translate_a(pd, a, an);
	if (p != NULL)
		pf_patch_16(pd, p, pn);
}

void
d4000 3
a4002 1
			pf_translate_ap(pd, pd->src, pd->sport, saddr, sport);
d4007 3
a4009 1
			pf_translate_ap(pd, pd->dst, pd->dport, daddr, dport);
d4017 3
a4019 1
			pf_translate_ap(pd, pd->src, pd->sport, saddr, sport);
d4024 3
a4026 1
			pf_translate_ap(pd, pd->dst, pd->dport, daddr, dport);
d4077 1
a4077 1
				pf_translate_ap(pd, pd->src, NULL, saddr, 0);
d4081 1
a4081 1
				pf_translate_ap(pd, pd->dst, NULL, daddr, 0);
d4112 1
a4112 1
				pf_translate_ap(pd, pd->src, NULL, saddr, 0);
d4116 1
a4116 1
				pf_translate_ap(pd, pd->dst, NULL, daddr, 0);
d4737 6
a4742 3
		    nk->port[sidx] != pd->osport)
			pf_translate_ap(pd, pd->src, pd->sport,
			    &nk->addr[sidx], nk->port[sidx]);
d4749 6
a4754 3
		    nk->port[didx] != pd->odport)
			pf_translate_ap(pd, pd->dst, pd->dport,
			    &nk->addr[didx], nk->port[didx]);
d4873 7
a4879 1

d4924 4
a4927 3
				    &nk->addr[sidx], AF_INET6))
					pf_translate_ap(pd, pd->src, NULL,
					    &nk->addr[sidx], 0);
d4931 2
a4932 2
					pf_translate_ap(pd, pd->dst, NULL,
					    &nk->addr[didx], 0);
d4950 1
a4950 4
			if (afto) {
				PF_ACPY(&pd->nsaddr, &nk->addr[sidx], nk->af);
				PF_ACPY(&pd->ndaddr, &nk->addr[didx], nk->af);
				pd->naf = nk->af;
a4951 1
			}
d5158 6
a5163 8
					pf_translate_ap(pd,
					    pd2.src, &th.th_sport,
					    &nk->addr[pd2.sidx],
					    nk->port[sidx]);
					pf_translate_ap(pd,
					    pd2.dst, &th.th_dport,
					    &nk->addr[pd2.didx],
					    nk->port[didx]);
d5274 6
a5279 8
					pf_translate_ap(pd,
					    pd2.src, &uh.uh_sport,
					    &nk->addr[pd2.sidx],
					    nk->port[sidx]);
					pf_translate_ap(pd,
					    pd2.dst, &uh.uh_dport,
					    &nk->addr[pd2.didx],
					    nk->port[didx]);
@


1.979
log
@Hide pf internals by moving code from in_ouraddr() to pf_ouraddr().
OK mpi@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.978 2016/06/21 16:45:37 bluhm Exp $ */
d153 5
a157 2

void			 pf_change_ap(struct pf_pdesc *, struct pf_addr *,
d159 2
a164 3
void			 pf_change_icmp(struct pf_pdesc *, struct pf_addr *,
			    u_int16_t *, struct pf_addr *, struct pf_addr *,
			    u_int16_t);
d169 6
a174 1
int			 pf_translate_icmp_af(int, void *);
d303 2
d1696 135
d1832 82
a1913 1
pf_change_ap(struct pf_pdesc *pd, struct pf_addr *a, u_int16_t *p,
a1915 3
	if (pd->csum_status == PF_CSUM_UNKNOWN)
		pf_check_proto_cksum(pd, pd->off, pd->tot_len - pd->off,
		    pd->proto, pd->af);
d1917 1
a1917 1
		PF_ACPY(a, an, pd->naf);
d1919 1
a1919 1
		*p = pn;
a1921 1
/* Changes a u_int32_t.  Uses a void * so there are no align restrictions */
d1923 1
a1923 1
pf_change_a(struct pf_pdesc *pd, void *a, u_int32_t an)
d1925 12
a1936 4
	if (pd->csum_status == PF_CSUM_UNKNOWN)
		pf_check_proto_cksum(pd, pd->off, pd->tot_len - pd->off,
		    pd->proto, pd->af);
	memcpy(a, &an, sizeof(u_int32_t));
d2130 1
a2130 1
pf_change_icmp(struct pf_pdesc *pd, struct pf_addr *ia, u_int16_t *ip,
d2133 1
a2133 7
	if (pd->csum_status == PF_CSUM_UNKNOWN)
		pf_check_proto_cksum(pd, pd->off, pd->tot_len - pd->off,
		    pd->proto, pd->af);

	/* Change inner protocol port */
	if (ip != NULL)
		*ip = np;
d2135 3
a2137 2
	/* Change inner ip address */
	PF_ACPY(ia, na, pd->af);
d2139 5
a2143 1
	/* Outer ip address, fix outer icmpv6 checksum, if necessary. */
d2145 20
a2164 1
		PF_ACPY(oa, na, pd->af);
d2171 18
a2188 5
	struct mbuf		*mp;
	struct ip		*ip4;
	struct ip6_hdr		*ip6;
	struct icmp6_hdr	*icmp;
	int			 hlen;
d2190 16
a2205 5
	if (pd->csum_status == PF_CSUM_UNKNOWN)
		pf_check_proto_cksum(pd, pd->off, pd->tot_len - pd->off,
		    pd->proto, pd->af);

	hlen = pd->naf == AF_INET ? sizeof(*ip4) : sizeof(*ip6);
d2207 1
a2207 1
	/* trim the old header */
d2209 2
a2211 1
	/* prepend a new one */
d2217 3
d2227 1
a2227 1
		ip4->ip_len = htons(hlen + (pd->tot_len - pd->off));
d2240 1
a2240 1
		ip6->ip6_plen = htons(pd->tot_len - pd->off);
d2250 7
a2256 1
		return (-1);
d2259 15
a2273 14
	/* recalculate icmp/icmp6 checksums */
	if (pd->proto == IPPROTO_ICMP || pd->proto == IPPROTO_ICMPV6) {
		int off;
		if ((mp = m_pulldown(pd->m, hlen, sizeof(*icmp), &off)) ==
		    NULL) {
			pd->m = NULL;
			return (-1);
		}
		icmp = (struct icmp6_hdr *)(mp->m_data + off);
		icmp->icmp6_cksum = 0;
		icmp->icmp6_cksum = pd->naf == AF_INET ?
		    in4_cksum(pd->m, 0, hlen, ntohs(ip4->ip_len) - hlen) :
		    in6_cksum(pd->m, IPPROTO_ICMPV6, hlen,
		    ntohs(ip6->ip6_plen));
d2276 4
d2284 1
a2284 1
pf_change_icmp_af(struct mbuf *m, int off, struct pf_pdesc *pd,
d2291 1
a2291 5
	int			 hlen, olen, mlen;

	if (pd->csum_status == PF_CSUM_UNKNOWN)
		pf_check_proto_cksum(pd, pd->off, pd->tot_len - pd->off,
		    pd->proto, pd->af);
d2297 2
a2298 2
	/* split the mbuf chain on the inner ip/ip6 header boundary */
	if ((n = m_split(m, off, M_DONTWAIT)) == NULL)
d2301 1
a2301 3
	/* old header */
	olen = pd2->off - off;
	/* new header */
d2303 2
d2306 3
a2308 2
	/* trim old header */
	m_adj(n, olen);
d2310 1
a2310 1
	/* prepend a new one */
a2313 1
	/* translate inner ip/ip6 header */
d2320 1
a2320 1
		ip4->ip_len = htons(sizeof(*ip4) + pd2->tot_len - olen);
d2336 1
a2336 1
		ip6->ip6_plen = htons(pd2->tot_len - olen);
d2350 29
a2378 8
	/* adjust payload offset and total packet length */
	pd2->off += hlen - olen;
	pd->tot_len += hlen - olen;

	/* merge modified inner packet with the original header */
	mlen = n->m_pkthdr.len;
	m_cat(m, n);
	m->m_pkthdr.len += mlen;
d2388 1
a2388 1
pf_translate_icmp_af(int af, void *arg)
d2476 4
a2479 2
		icmp6->icmp6_type = type;
		icmp6->icmp6_code = code;
d2481 2
a2482 1
		icmp6->icmp6_mtu = htonl(mtu);
d2485 1
a2485 1
			icmp6->icmp6_pptr = htonl(ptr << 24);
d2574 4
a2577 3
		icmp4->icmp_type = type;
		icmp4->icmp_code = code;
		icmp4->icmp_nextmtu = htons(mtu);
d2579 1
a2579 1
			icmp4->icmp_void = htonl(ptr);
d2620 1
d2622 1
a2622 1
					pf_change_a(pd, &sack.start,
d2624 3
a2626 2
					    dst->seqdiff));
					pf_change_a(pd, &sack.end,
d2628 3
a2630 1
					    dst->seqdiff));
d3671 2
a3672 2
			if (pf_check_proto_cksum(pd, pd->off,
			    pd->tot_len - pd->off, IPPROTO_TCP, pd->af))
a3766 1
		pf_cksum(pd, pd->m);
d3852 2
a3853 2
			pf_change_a(pd, &th->th_seq,
			    htonl(s->src.seqlo + s->src.seqdiff));
d4012 1
a4012 1
			pf_change_ap(pd, pd->src, pd->sport, saddr, sport);
d4017 1
a4017 1
			pf_change_ap(pd, pd->dst, pd->dport, daddr, dport);
d4025 1
a4025 1
			pf_change_ap(pd, pd->src, pd->sport, saddr, sport);
d4030 1
a4030 1
			pf_change_ap(pd, pd->dst, pd->dport, daddr, dport);
d4042 1
a4042 1
			if (pf_translate_icmp_af(AF_INET6, pd->hdr.icmp))
d4049 1
a4049 2
				pf_change_a(pd, &pd->src->v4.s_addr,
				    saddr->v4.s_addr);
d4053 1
a4053 2
				pf_change_a(pd, &pd->dst->v4.s_addr,
				    daddr->v4.s_addr);
d4061 2
a4062 5
				if (pd->csum_status == PF_CSUM_UNKNOWN)
					pf_check_proto_cksum(pd, pd->off,
					    pd->tot_len - pd->off, pd->proto,
					    pd->af);
				pd->hdr.icmp->icmp_id = icmpid;
d4075 1
a4075 2
			/* ip_sum will be recalculated in pf_translate_af */
			if (pf_translate_icmp_af(AF_INET, pd->hdr.icmp6))
d4081 1
a4081 1
				pf_change_ap(pd, pd->src, NULL, saddr, 0);
d4085 1
a4085 1
				pf_change_ap(pd, pd->dst, NULL, daddr, 0);
d4093 2
a4094 5
				if (pd->csum_status == PF_CSUM_UNKNOWN)
					pf_check_proto_cksum(pd, pd->off,
					    pd->tot_len - pd->off, pd->proto,
					    pd->af);
				pd->hdr.icmp6->icmp6_id = icmpid;
d4105 1
a4105 2
				pf_change_a(pd, &pd->src->v4.s_addr,
				    saddr->v4.s_addr);
d4109 1
a4109 2
				pf_change_a(pd, &pd->dst->v4.s_addr,
				    daddr->v4.s_addr);
d4116 1
a4116 1
				pf_change_ap(pd, pd->src, NULL, saddr, 0);
d4120 1
a4120 1
				pf_change_ap(pd, pd->dst, NULL, daddr, 0);
d4171 2
a4172 2
			pf_change_a(pd, &th->th_seq, htonl(seq + src->seqdiff));
			pf_change_a(pd, &th->th_ack, htonl(ack));
d4223 2
a4224 2
			pf_change_a(pd, &th->th_seq, htonl(seq + src->seqdiff));
			pf_change_a(pd, &th->th_ack, htonl(ack));
d4742 1
a4742 1
			pf_change_ap(pd, pd->src, pd->sport,
d4751 1
a4751 1
			pf_change_ap(pd, pd->dst, pd->dport,
a4758 1
		pf_cksum(pd, pd->m);
a4818 1
	struct pf_addr  *saddr = pd->src, *daddr = pd->dst;
d4880 1
a4880 1
					if (pf_translate_icmp_af(AF_INET6,
d4888 2
a4889 2
					pf_change_a(pd, &saddr->v4.s_addr,
					    nk->addr[sidx].v4.s_addr);
d4893 2
a4894 2
					pf_change_a(pd, &daddr->v4.s_addr,
					    nk->addr[didx].v4.s_addr);
d4899 2
a4900 5
					if (pd->csum_status == PF_CSUM_UNKNOWN)
						pf_check_proto_cksum(pd,
						    pd->off, pd->tot_len -
						    pd->off, pd->proto, pd->af);
					pd->hdr.icmp->icmp_id = nk->port[iidx];
d4910 1
a4910 1
					if (pf_translate_icmp_af(AF_INET,
d4917 1
a4917 1
					pf_change_ap(pd, saddr, NULL,
d4922 1
a4922 1
					pf_change_ap(pd, daddr, NULL,
d4928 3
a4930 6
					if (pd->csum_status == PF_CSUM_UNKNOWN)
						pf_check_proto_cksum(pd,
						    pd->off, pd->tot_len -
						    pd->off, pd->proto, pd->af);
					pd->hdr.icmp6->icmp6_id =
					    nk->port[iidx];
d5079 1
a5079 1
				pf_change_a(pd, &th.th_seq, htonl(seq));
d5130 1
a5130 1
					if (pf_translate_icmp_af(nk->af,
d5153 2
a5154 1
					pf_change_ap(pd, pd2.src, &th.th_sport,
d5157 2
a5158 1
					pf_change_ap(pd, pd2.dst, &th.th_dport,
d5169 2
a5170 2
					pf_change_icmp(pd, pd2.src,
					    &th.th_sport, daddr,
d5182 2
a5183 2
					pf_change_icmp(pd, pd2.dst,
					    &th.th_dport, saddr,
d5248 1
a5248 1
					if (pf_translate_icmp_af(nk->af,
d5271 2
a5272 1
					pf_change_ap(pd, pd2.src, &uh.uh_sport,
d5275 2
a5276 1
					pf_change_ap(pd, pd2.dst, &uh.uh_dport,
d5288 2
a5289 2
					pf_change_icmp(pd, pd2.src,
					    &uh.uh_sport, daddr,
d5301 2
a5302 2
					pf_change_icmp(pd, pd2.dst,
					    &uh.uh_dport, saddr,
d5323 4
a5326 1
				uh.uh_sum = 0;
d5377 1
a5377 1
					if (pf_translate_icmp_af(nk->af,
d5388 2
a5389 1
					if (pf_translate_icmp_af(nk->af, &iih))
d5393 2
a5394 1
						iih.icmp_id = nk->port[iidx];
d5413 1
a5413 1
					pf_change_icmp(pd, pd2.src,
d5416 1
a5416 1
					    daddr, &nk->addr[pd2.sidx],
d5427 2
a5428 2
					pf_change_icmp(pd, pd2.dst, NULL,
					    saddr, &nk->addr[pd2.didx], 0);
d5489 1
a5489 1
					if (pf_translate_icmp_af(nk->af,
d5500 2
a5501 1
					if (pf_translate_icmp_af(nk->af, &iih))
d5506 2
a5507 1
						iih.icmp6_id = nk->port[iidx];
d5527 1
a5527 1
					pf_change_icmp(pd, pd2.src,
d5531 1
a5531 1
					    daddr, &nk->addr[pd2.sidx],
d5543 2
a5544 2
					pf_change_icmp(pd, pd2.dst, NULL,
					    saddr, &nk->addr[pd2.didx], 0);
d5576 2
a5577 2
					pf_change_icmp(pd, pd2.src, NULL,
					    daddr, &nk->addr[pd2.sidx], 0);
d5586 2
a5587 2
					pf_change_icmp(pd, pd2.dst, NULL,
					    saddr, &nk->addr[pd2.didx], 0);
a5612 1
		pf_cksum(pd, pd->m);
d6085 1
a6085 1
 * check protocol (tcp/udp/icmp/icmp6) checksum and set mbuf flag
d6092 1
a6092 2
pf_check_proto_cksum(struct pf_pdesc *pd, int off, int len, u_int8_t p,
    sa_family_t af)
a6093 1
	u_int16_t flag_ok, flag_bad, flag_out;
d6096 2
a6097 29
	if (pd->csum_status == PF_CSUM_OK)
		return (0);
	if (pd->csum_status == PF_CSUM_BAD)
		return (1);

	switch (p) {
	case IPPROTO_TCP:
		flag_ok = M_TCP_CSUM_IN_OK;
		flag_out = M_TCP_CSUM_OUT;
		flag_bad = M_TCP_CSUM_IN_BAD;
		break;
	case IPPROTO_UDP:
		flag_ok = M_UDP_CSUM_IN_OK;
		flag_out = M_UDP_CSUM_OUT;
		flag_bad = M_UDP_CSUM_IN_BAD;
		break;
	case IPPROTO_ICMP:
#ifdef INET6
	case IPPROTO_ICMPV6:
#endif /* INET6 */
		flag_ok = M_ICMP_CSUM_IN_OK;
		flag_out = M_ICMP_CSUM_OUT;
		flag_bad = M_ICMP_CSUM_IN_BAD;
		break;
	default:
		return (1);
	}
	if (pd->m->m_pkthdr.csum_flags & (flag_ok | flag_out)) {
		pd->csum_status = PF_CSUM_OK;
d6100 3
a6102 3
	if (pd->m->m_pkthdr.csum_flags & flag_bad || off < sizeof(struct ip) ||
	    pd->m->m_pkthdr.len < off + len) {
		pd->csum_status = PF_CSUM_BAD;
d6107 1
a6107 4
	if (p == IPPROTO_TCP)
		tcpstat.tcps_inswcsum++;
	else if (p == IPPROTO_UDP)
		udpstat.udps_inswcsum++;
d6111 1
a6111 2
		if (pd->m->m_len < sizeof(struct ip)) {
			pd->csum_status = PF_CSUM_BAD;
d6113 2
a6114 2
		}
		sum = in4_cksum(pd->m, (p == IPPROTO_ICMP ? 0 : p), off, len);
d6118 1
a6118 2
		if (pd->m->m_len < sizeof(struct ip6_hdr)) {
			pd->csum_status = PF_CSUM_BAD;
d6120 2
a6121 2
		}
		sum = in6_cksum(pd->m, p, off, len);
d6128 2
a6129 18
		switch (p) {
		case IPPROTO_TCP:
			tcpstat.tcps_rcvbadsum++;
			break;
		case IPPROTO_UDP:
			udpstat.udps_badsum++;
			break;
		case IPPROTO_ICMP:
			icmpstat.icps_checksum++;
			break;
#ifdef INET6
		case IPPROTO_ICMPV6:
			icmp6stat.icp6s_checksum++;
			break;
#endif /* INET6 */
		}
		pd->m->m_pkthdr.csum_flags |= flag_bad;
		pd->csum_status = PF_CSUM_BAD;
d6132 2
a6133 2
	pd->m->m_pkthdr.csum_flags |= flag_ok;
	pd->csum_status = PF_CSUM_OK;
d6528 1
a6982 31
}

void
pf_cksum(struct pf_pdesc *pd, struct mbuf *m)
{
	if (pd->csum_status != PF_CSUM_OK)
		return;	/* don't fix broken cksums */

	switch (pd->proto) {
	case IPPROTO_TCP:
		pd->hdr.tcp->th_sum = 0;
		m->m_pkthdr.csum_flags |= M_TCP_CSUM_OUT;
		break;
	case IPPROTO_UDP:
		pd->hdr.udp->uh_sum = 0;
		m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;
		break;
	case IPPROTO_ICMP:
		pd->hdr.icmp->icmp_cksum = 0;
		m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;
		break;
#ifdef INET6
	case IPPROTO_ICMPV6:
		pd->hdr.icmp6->icmp6_cksum = 0;
		m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;
		break;
#endif /* INET6 */
	default:
		/* nothing */
		break;
	}
@


1.979.4.1
log
@OpenBSD 6.0 errata 19
MFC sys/net/pf.c rev 1.1018 claudio
    Prevent integer overflow in PF when calculating the adaptive timeout.
    Mainly states of established TCP connections whould be affected resulting
    in immediate state removal once the numer of states is bigger than
    adaptive.start.  Disabling adative timeouts is a workaround to avoid this bug.
    Issue found and initial diff by Mathieu Blanc (mathieu.blanc at cea dot fr)
    OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.979 2016/07/18 13:17:44 bluhm Exp $ */
d1197 1
a1197 1
	u_int32_t	timeout;
d1226 1
a1226 1
		timeout = (u_int64_t)timeout * (end - states) / (end - start);
@


1.978
log
@To assist debugging TCP connection reuse with NAT, expand the
existing log in pf_state_key_attach() from the failed to the reuse
case.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.977 2016/06/15 11:49:34 mpi Exp $ */
d6762 21
@


1.977
log
@Kill nd6_output(), it doesn't do anything since the resolution logic
has been moved to nd6_resolve().

ok visa@@, millert@@, florian@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.976 2016/06/15 11:36:06 mikeb Exp $ */
d672 2
d676 19
a694 1
				    si->s->dst.state >= TCPS_FIN_WAIT_2) {
a699 20
					if (pf_status.debug >= LOG_NOTICE) {
						log(LOG_NOTICE,
						    "pf: %s key attach "
						    "failed on %s: ",
						    (idx == PF_SK_WIRE) ?
						    "wire" : "stack",
						    s->kif->pfik_name);
						pf_print_state_parts(s,
						    (idx == PF_SK_WIRE) ?
						    sk : NULL,
						    (idx == PF_SK_STACK) ?
						    sk : NULL);
						addlog(", existing: ");
						pf_print_state_parts(si->s,
						    (idx == PF_SK_WIRE) ?
						    sk : NULL,
						    (idx == PF_SK_STACK) ?
						    sk : NULL);
						addlog("\n");
					}
@


1.976
log
@There's no need to convert values returned by arc4random to the network
byte order.  Spotted by Gleb Smirnoff (glebius@@FreeBSD.org), thanks!

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.975 2016/06/07 01:31:54 tedu Exp $ */
d5765 1
a5765 1
		nd6_output(ifp, m0, dst, rt);
@


1.975
log
@per trending style, add continue to empty loops.
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.974 2016/05/31 07:35:36 mpi Exp $ */
d3653 1
a3653 1
		s->src.seqhi = htonl(arc4random());
d4274 1
a4274 1
				(*state)->dst.seqhi = htonl(arc4random());
@


1.974
log
@Do not call nd6_output() without route entry argument.

ok sthen@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.973 2016/05/28 12:04:33 sthen Exp $ */
d3870 1
a3870 1
				;
@


1.973
log
@Backout pf.c r1.972, pf_norm.c r1.184, ok claudio

pf_test calls pf_refragment6 with dst=NULL, which is passed down to
rtable_match which attempts to dereference it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.971 2016/05/23 12:26:28 mpi Exp $ */
d5668 1
d5674 1
d5707 1
d5760 7
a5766 1
		nd6_output(ifp, m0, dst, NULL);
@


1.972
log
@Do not call nd6_output() without route entry argument.

ok bluhm@@
@
text
@a5667 1
	struct rtentry		*rt = NULL;
a5672 1
	unsigned int		 rtableid;
a5704 1
	rtableid = m0->m_pkthdr.ph_rtableid;
d5757 1
a5757 7
		rt = rtalloc(sin6tosa(dst), RT_RESOLVE, rtableid);
		if (rt == NULL) {
			ip6stat.ip6s_noroute++;
			goto bad;
		}
		nd6_output(ifp, m0, dst, rt);
		rtfree(rt);
@


1.971
log
@Pass a route entry to if_output() instead of relying on arpresolve() magic.

This refactoring aims to reduce the number of places where a route entry is
inserted in the routing table.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.970 2016/05/03 12:13:38 mpi Exp $ */
d5668 1
d5674 1
d5707 1
d5760 7
a5766 1
		nd6_output(ifp, m0, dst, NULL);
@


1.970
log
@Put back a panic() if an incoming packet already has a statekey.

Apparently nobody can hit this condition anymore or people do not
report bugs if their kernel do not panic.

ok dlg@@, sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.969 2016/04/15 02:54:17 dlg Exp $ */
d5577 6
d5611 1
a5611 1
		error = ifp->if_output(ifp, m0, sintosa(dst), NULL);
d5640 1
a5640 1
			error = ifp->if_output(ifp, m0, sintosa(dst), NULL);
@


1.969
log
@replace m_copym2 with m_dup_pkt for the dup-to handling.

note that this uses max_linkhdr as the adjustment arg. this follows
what the ip stack does when generating packets as it provides space
for link headers (like ethernet headers) to be prepended on the new
packet.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.968 2016/04/07 14:28:16 mpi Exp $ */
a6572 1
			printf("WARNING incoming mbuf already has a statekey:");
a6574 2
#else
			printf("%p\n", pd.m);
d6576 1
a6576 1
			pf_pkt_unlink_state_key(pd.m);
@


1.968
log
@Instead of panicking if an mbuf(9) already has a statekey dump its
content and unlink the statekey.

This should allow us to find the reminding corner cases of packets
looped back in the stack.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.967 2016/03/29 10:34:42 sashan Exp $ */
d5520 1
a5520 1
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
d5679 1
a5679 1
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
@


1.967
log
@- packet must keep reference to statekey
  this is the second attempt to get it in, the first
  attempt got backed out on Jan 31 2016

  the change also contains fixes contributed by Stefan Kempf
  in earlier iteration.

OK srhen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.966 2016/03/04 22:38:23 sashan Exp $ */
d102 4
d6568 3
a6570 3
		 * ASSERT() below fires whenever caller forgets to call
		 * pf_pkt_addr_changed(). This might happen when we deal with
		 * IP tunnels.
d6572 9
a6580 1
		KASSERT(pd.m->m_pkthdr.pf.statekey == NULL);
@


1.966
log
@- putting back KASSERT(), which I've backed out on Jan 31
  We don't expect inbound packets to come to PF with statekey attached.

- I've also found missing call to pf_pkt_addr_changed() at various
  places, which needs to get fixed to prevent KASSERT() from firing.

OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.965 2016/01/31 00:18:07 sashan Exp $ */
d234 5
d740 1
d754 8
a761 7
	if (TAILQ_EMPTY(&s->key[idx]->states)) {
		RB_REMOVE(pf_state_tree, &pf_statetbl, s->key[idx]);
		if (s->key[idx]->reverse)
			s->key[idx]->reverse->reverse = NULL;
		if (s->key[idx]->inp)
			s->key[idx]->inp->inp_pf_sk = NULL;
		pool_put(&pf_state_key_pl, s->key[idx]);
a762 1
	s->key[idx] = NULL;
d849 2
d882 2
d999 1
a999 1
	struct pf_state_key	*sk;
d1009 28
a1036 7
	if (dir == PF_OUT && m->m_pkthdr.pf.statekey &&
	    m->m_pkthdr.pf.statekey->reverse)
		sk = m->m_pkthdr.pf.statekey->reverse;
	else if (dir == PF_OUT && m->m_pkthdr.pf.inp &&
	    m->m_pkthdr.pf.inp->inp_pf_sk)
		sk = m->m_pkthdr.pf.inp->inp_pf_sk;
	else {
d1040 5
a1044 9
		if (dir == PF_OUT && m->m_pkthdr.pf.statekey &&
		    pf_compare_state_keys(m->m_pkthdr.pf.statekey, sk,
		    kif, dir) == 0) {
			m->m_pkthdr.pf.statekey->reverse = sk;
			sk->reverse = m->m_pkthdr.pf.statekey;
		} else if (dir == PF_OUT && m->m_pkthdr.pf.inp && !sk->inp) {
			m->m_pkthdr.pf.inp->inp_pf_sk = sk;
			sk->inp = m->m_pkthdr.pf.inp;
		}
d1047 3
a1049 4
	if (dir == PF_OUT) {
		m->m_pkthdr.pf.statekey = NULL;
		m->m_pkthdr.pf.inp = NULL;
	}
d6569 2
a6570 1
		pd.m->m_pkthdr.pf.statekey = s->key[PF_SK_STACK];
d6575 2
a6576 1
		pd.m->m_pkthdr.pf.inp->inp_pf_sk = s->key[PF_SK_STACK];
d6747 1
a6747 1
	m->m_pkthdr.pf.statekey = NULL;
d6755 1
d6757 3
a6759 1
	if (m->m_pkthdr.pf.statekey) {
d6761 4
a6764 3
		if (inp && inp->inp_pf_sk)
			KASSERT(m->m_pkthdr.pf.statekey == inp->inp_pf_sk);
	}
d6771 15
a6785 4
	if (m->m_pkthdr.pf.statekey && inp &&
	    !m->m_pkthdr.pf.statekey->inp && !inp->inp_pf_sk) {
		m->m_pkthdr.pf.statekey->inp = inp;
		inp->inp_pf_sk = m->m_pkthdr.pf.statekey;
d6788 1
a6788 1
	m->m_pkthdr.pf.statekey = NULL;
d6796 1
a6796 1
		inp->inp_pf_sk = NULL;
d6800 11
d6827 63
@


1.965
log
@- m_pkthdr.pf.statekey changes are not ready for 5.9, I must back them out

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.962 2015/12/23 21:04:55 jasper Exp $ */
d6537 6
@


1.965.2.1
log
@OpenBSD 5.9 errata 36
MFC sys/net/pf.c rev 1.1018 claudio
    Prevent integer overflow in PF when calculating the adaptive timeout.
    Mainly states of established TCP connections whould be affected resulting
    in immediate state removal once the numer of states is bigger than
    adaptive.start.  Disabling adative timeouts is a workaround to avoid this bug.
    Issue found and initial diff by Mathieu Blanc (mathieu.blanc at cea dot fr)
    OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.965 2016/01/31 00:18:07 sashan Exp $ */
d1167 1
a1167 1
	u_int32_t	timeout;
d1196 1
a1196 1
		timeout = (u_int64_t)timeout * (end - states) / (end - start);
@


1.964
log
@- plugging massive pf_state_key leak

OK mpi@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.963 2016/01/07 22:23:13 sashan Exp $ */
a233 5
void			 pf_state_key_link(struct pf_state_key *,
			    struct pf_state_key *);
void			 pf_inpcb_unlink_state_key(struct inpcb *);
void			 pf_state_key_unlink_reverse(struct pf_state_key *);

d697 1
a697 1
	} else {
a698 1
	}
a734 1
	struct pf_state_key	*sk;
d748 8
a755 1
	sk = s->key[idx];
a756 7
	if (TAILQ_EMPTY(&sk->states)) {
		RB_REMOVE(pf_state_tree, &pf_statetbl, sk);
		sk->removed = 1;
		pf_state_key_unlink_reverse(sk);
		pf_inpcb_unlink_state_key(sk->inp);
		pf_state_key_unref(sk);
	}
a842 2
	PF_REF_INIT(sk1->refcnt);
	sk1->removed = 0;
a873 2
		PF_REF_INIT(sk2->refcnt);
		sk2->removed = 0;
d989 1
a989 1
	struct pf_state_key	*sk, *pkt_sk, *inp_sk;
d999 7
a1005 28
	inp_sk = NULL;
	pkt_sk = NULL;
	sk = NULL;
	if (dir == PF_OUT) {
		/* first if block deals with outbound forwarded packet */
		pkt_sk = m->m_pkthdr.pf.statekey;
		if (pf_state_key_isvalid(pkt_sk) &&
		    pf_state_key_isvalid(pkt_sk->reverse)) {
			sk = pkt_sk->reverse;
		} else {
			pf_pkt_unlink_state_key(m);
			pkt_sk = NULL;
		}

		if (pkt_sk == NULL) {
			/* here we deal with local outbound packet */
			if (m->m_pkthdr.pf.inp != NULL) {
				inp_sk = m->m_pkthdr.pf.inp->inp_pf_sk;
				if (pf_state_key_isvalid(inp_sk))
					sk = inp_sk;
				else
					pf_inpcb_unlink_state_key(
					    m->m_pkthdr.pf.inp);
			}
		}
	}

	if (sk == NULL) {
d1009 9
a1017 5
		if (dir == PF_OUT && pkt_sk &&
		    pf_compare_state_keys(pkt_sk, sk, kif, dir) == 0)
			pf_state_key_link(sk, pkt_sk);
		else if (dir == PF_OUT)
			pf_inp_link(m, m->m_pkthdr.pf.inp);
d1020 4
a1023 3
	/* remove firewall data from outbound packet */
	if (dir == PF_OUT)
		pf_pkt_addr_changed(m);
d6537 1
a6537 8
		/*
		 * ASSERT() below fires whenever caller forgets to call
		 * pf_pkt_addr_changed(). This might happen when we deal with
		 * IP tunnels.
		 */
		KASSERT(pd.m->m_pkthdr.pf.statekey == NULL);
		pd.m->m_pkthdr.pf.statekey =
		    pf_state_key_ref(s->key[PF_SK_STACK]);
d6542 1
a6542 2
		pd.m->m_pkthdr.pf.inp->inp_pf_sk =
		    pf_state_key_ref(s->key[PF_SK_STACK]);
d6713 1
a6713 1
	pf_pkt_unlink_state_key(m);
a6720 1
	struct pf_state_key *sk = m->m_pkthdr.pf.statekey;
d6722 1
a6722 3
	if (!pf_state_key_isvalid(sk))
		pf_pkt_unlink_state_key(m);
	else
d6724 3
a6726 4

	if (inp && inp->inp_pf_sk)
		KASSERT(m->m_pkthdr.pf.statekey == inp->inp_pf_sk);

d6733 4
a6736 15
	struct pf_state_key *sk = m->m_pkthdr.pf.statekey;

	if (!pf_state_key_isvalid(sk)) {
		pf_pkt_unlink_state_key(m);
		return;
	}

	/*
	 * we don't need to grab PF-lock here. At worst case we link inp to
	 * state, which might be just being marked as deleted by another
	 * thread.
	 */
	if (inp && !sk->inp && !inp->inp_pf_sk) {
		sk->inp = inp;
		inp->inp_pf_sk = pf_state_key_ref(sk);
d6739 1
a6739 1
	pf_pkt_unlink_state_key(m);
d6747 1
a6747 1
		pf_inpcb_unlink_state_key(inp);
a6750 11
void
pf_state_key_link(struct pf_state_key *sk, struct pf_state_key *pkt_sk)
{
	/*
	 * Assert will not wire as long as we are called by pf_find_state()
	 */
	KASSERT((pkt_sk->reverse == NULL) && (sk->reverse == NULL));
	pkt_sk->reverse = pf_state_key_ref(sk);
	sk->reverse = pf_state_key_ref(pkt_sk);
}

a6766 63

struct pf_state_key *
pf_state_key_ref(struct pf_state_key *sk)
{
	if (sk != NULL)
		PF_REF_TAKE(sk->refcnt);

	return (sk);
}

void
pf_state_key_unref(struct pf_state_key *sk)
{
	if ((sk != NULL) && PF_REF_RELE(sk->refcnt)) {
		/* state key must be removed from tree */
		KASSERT(!pf_state_key_isvalid(sk));
		/* state key must be unlinked from reverse key */
		KASSERT(sk->reverse == NULL);
		/* state key must be unlinked from socket */
		KASSERT((sk->inp == NULL) || (sk->inp->inp_pf_sk == NULL));
		sk->inp = NULL;
		pool_put(&pf_state_key_pl, sk);
	}
}

int
pf_state_key_isvalid(struct pf_state_key *sk)
{
	return ((sk != NULL) && (sk->removed == 0));
}

void
pf_pkt_unlink_state_key(struct mbuf *m)
{
	pf_state_key_unref(m->m_pkthdr.pf.statekey);
	m->m_pkthdr.pf.statekey = NULL;
}

void
pf_pkt_state_key_ref(struct mbuf *m)
{
	pf_state_key_ref(m->m_pkthdr.pf.statekey);
}

void
pf_inpcb_unlink_state_key(struct inpcb *inp)
{
	if (inp != NULL) {
		pf_state_key_unref(inp->inp_pf_sk);
		inp->inp_pf_sk = NULL;
	}
}

void
pf_state_key_unlink_reverse(struct pf_state_key *sk)
{
	if ((sk != NULL) && (sk->reverse != NULL)) {
		pf_state_key_unref(sk->reverse->reverse);
		sk->reverse->reverse = NULL;
		pf_state_key_unref(sk->reverse);
		sk->reverse = NULL;
	}
}
@


1.963
log
@- retrying to commit earlier change, which got backed out

    - yet another tiny step towards MP PF. This time we need to make sure
      statekey attached to packet stays around, while accepted packet is
      routed through IP stack.

  this time I'm also bringing fix contributed by Stefan Kempf. Stefan's fix
  makes sure we grab reference in m_dup_pkthdr()

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.962 2015/12/23 21:04:55 jasper Exp $ */
a703 2
		/* need to grab reference for PF */
		pf_state_key_ref(sk);
d3401 2
d3438 6
d3474 1
a3474 6
#ifdef INET6
	if (rewrite && skw->af != sks->af)
		return (PF_AFRT);
#endif /* INET6 */

	return (PF_PASS);
d6563 7
a6569 1
	if (pd.dir == PF_IN && s && s->key[PF_SK_STACK])
d6572 1
@


1.962
log
@revert previous:
----------------------------------------------------------------------
revision 1.961
date: 2015/12/22 13:33:26;  author: sashan;  state: Exp;  lines: +153 -44;
commitid: oBRhtWcDV0ThviVT;
- yet another tiny step towards MP PF. This time we need to make sure
  statekey attached to packet stays around, while accepted packet is
  routed through IP stack.

OK mpi@@, henning@@
----------------------------------------------------------------------

there have been multiple reports of KASSERT(!pf_state_key_isvalid(sk)) being
triggered without much effort, so back this out for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.960 2015/12/06 10:03:23 henning Exp $ */
d234 5
d702 1
a702 1
	} else
d704 3
d743 1
d757 8
a764 7
	if (TAILQ_EMPTY(&s->key[idx]->states)) {
		RB_REMOVE(pf_state_tree, &pf_statetbl, s->key[idx]);
		if (s->key[idx]->reverse)
			s->key[idx]->reverse->reverse = NULL;
		if (s->key[idx]->inp)
			s->key[idx]->inp->inp_pf_sk = NULL;
		pool_put(&pf_state_key_pl, s->key[idx]);
a765 1
	s->key[idx] = NULL;
d852 2
d885 2
d1002 1
a1002 1
	struct pf_state_key	*sk;
d1012 28
a1039 7
	if (dir == PF_OUT && m->m_pkthdr.pf.statekey &&
	    m->m_pkthdr.pf.statekey->reverse)
		sk = m->m_pkthdr.pf.statekey->reverse;
	else if (dir == PF_OUT && m->m_pkthdr.pf.inp &&
	    m->m_pkthdr.pf.inp->inp_pf_sk)
		sk = m->m_pkthdr.pf.inp->inp_pf_sk;
	else {
d1043 5
a1047 9
		if (dir == PF_OUT && m->m_pkthdr.pf.statekey &&
		    pf_compare_state_keys(m->m_pkthdr.pf.statekey, sk,
		    kif, dir) == 0) {
			m->m_pkthdr.pf.statekey->reverse = sk;
			sk->reverse = m->m_pkthdr.pf.statekey;
		} else if (dir == PF_OUT && m->m_pkthdr.pf.inp && !sk->inp) {
			m->m_pkthdr.pf.inp->inp_pf_sk = sk;
			sk->inp = m->m_pkthdr.pf.inp;
		}
d1050 3
a1052 4
	if (dir == PF_OUT) {
		m->m_pkthdr.pf.statekey = NULL;
		m->m_pkthdr.pf.inp = NULL;
	}
d6563 2
a6564 1
		pd.m->m_pkthdr.pf.statekey = s->key[PF_SK_STACK];
d6568 2
a6569 1
		pd.m->m_pkthdr.pf.inp->inp_pf_sk = s->key[PF_SK_STACK];
d6740 1
a6740 1
	m->m_pkthdr.pf.statekey = NULL;
d6748 1
d6750 3
a6752 1
	if (m->m_pkthdr.pf.statekey) {
d6754 4
a6757 3
		if (inp && inp->inp_pf_sk)
			KASSERT(m->m_pkthdr.pf.statekey == inp->inp_pf_sk);
	}
d6764 15
a6778 4
	if (m->m_pkthdr.pf.statekey && inp &&
	    !m->m_pkthdr.pf.statekey->inp && !inp->inp_pf_sk) {
		m->m_pkthdr.pf.statekey->inp = inp;
		inp->inp_pf_sk = m->m_pkthdr.pf.statekey;
d6781 1
a6781 1
	m->m_pkthdr.pf.statekey = NULL;
d6789 1
a6789 1
		inp->inp_pf_sk = NULL;
d6793 11
d6820 63
@


1.961
log
@- yet another tiny step towards MP PF. This time we need to make sure
  statekey attached to packet stays around, while accepted packet is
  routed through IP stack.

OK mpi@@, henning@@
@
text
@a233 5
void			 pf_state_key_link(struct pf_state_key *,
			    struct pf_state_key *);
void			 pf_inpcb_unlink_state_key(struct inpcb *);
void			 pf_state_key_unlink_reverse(struct pf_state_key *);

d697 1
a697 1
	} else {
a698 3
		/* need to grab reference for PF */
		pf_state_key_ref(sk);
	}
a734 1
	struct pf_state_key	*sk;
d748 8
a755 1
	sk = s->key[idx];
a756 7
	if (TAILQ_EMPTY(&sk->states)) {
		RB_REMOVE(pf_state_tree, &pf_statetbl, sk);
		sk->removed = 1;
		pf_state_key_unlink_reverse(sk);
		pf_inpcb_unlink_state_key(sk->inp);
		pf_state_key_unref(sk);
	}
a842 2
	PF_REF_INIT(sk1->refcnt);
	sk1->removed = 0;
a873 2
		PF_REF_INIT(sk2->refcnt);
		sk2->removed = 0;
d989 1
a989 1
	struct pf_state_key	*sk, *pkt_sk, *inp_sk;
d999 7
a1005 28
	inp_sk = NULL;
	pkt_sk = NULL;
	sk = NULL;
	if (dir == PF_OUT) {
		/* first if block deals with outbound forwarded packet */
		pkt_sk = m->m_pkthdr.pf.statekey;
		if (pf_state_key_isvalid(pkt_sk) &&
		    pf_state_key_isvalid(pkt_sk->reverse)) {
			sk = pkt_sk->reverse;
		} else {
			pf_pkt_unlink_state_key(m);
			pkt_sk = NULL;
		}

		if (pkt_sk == NULL) {
			/* here we deal with local outbound packet */
			if (m->m_pkthdr.pf.inp != NULL) {
				inp_sk = m->m_pkthdr.pf.inp->inp_pf_sk;
				if (pf_state_key_isvalid(inp_sk))
					sk = inp_sk;
				else
					pf_inpcb_unlink_state_key(
					    m->m_pkthdr.pf.inp);
			}
		}
	}

	if (sk == NULL) {
d1009 9
a1017 5
		if (dir == PF_OUT && pkt_sk &&
		    pf_compare_state_keys(pkt_sk, sk, kif, dir) == 0)
			pf_state_key_link(sk, pkt_sk);
		else if (dir == PF_OUT)
			pf_inp_link(m, m->m_pkthdr.pf.inp);
d1020 4
a1023 3
	/* remove firewall data from outbound packet */
	if (dir == PF_OUT)
		pf_pkt_addr_changed(m);
d6534 1
a6534 2
		pd.m->m_pkthdr.pf.statekey =
		    pf_state_key_ref(s->key[PF_SK_STACK]);
d6538 1
a6538 2
		pd.m->m_pkthdr.pf.inp->inp_pf_sk =
		    pf_state_key_ref(s->key[PF_SK_STACK]);
d6709 1
a6709 1
	pf_pkt_unlink_state_key(m);
a6716 1
	struct pf_state_key *sk = m->m_pkthdr.pf.statekey;
d6718 1
a6718 3
	if (!pf_state_key_isvalid(sk))
		pf_pkt_unlink_state_key(m);
	else
d6720 3
a6722 4

	if (inp && inp->inp_pf_sk)
		KASSERT(m->m_pkthdr.pf.statekey == inp->inp_pf_sk);

d6729 4
a6732 10
	struct pf_state_key *sk = m->m_pkthdr.pf.statekey;

	if (!pf_state_key_isvalid(sk)) {
		pf_pkt_unlink_state_key(m);
		return;
	}

	if (inp && !sk->inp && !inp->inp_pf_sk) {
		sk->inp = inp;
		inp->inp_pf_sk = pf_state_key_ref(sk);
d6735 1
a6735 1
	pf_pkt_unlink_state_key(m);
d6743 1
a6743 1
		pf_inpcb_unlink_state_key(inp);
a6746 11
void
pf_state_key_link(struct pf_state_key *sk, struct pf_state_key *pkt_sk)
{
	/*
	 * Assert will not fire as long as we are called by pf_find_state()
	 */
	KASSERT((pkt_sk->reverse == NULL) && (sk->reverse == NULL));
	pkt_sk->reverse = pf_state_key_ref(sk);
	sk->reverse = pf_state_key_ref(pkt_sk);
}

a6762 57

struct pf_state_key *
pf_state_key_ref(struct pf_state_key *sk)
{
	if (sk != NULL)
		PF_REF_TAKE(sk->refcnt);

	return (sk);
}

void
pf_state_key_unref(struct pf_state_key *sk)
{
	if ((sk != NULL) && PF_REF_RELE(sk->refcnt)) {
		/* state key must be removed from tree */
		KASSERT(!pf_state_key_isvalid(sk));
		/* state key must be unlinked from reverse key */
		KASSERT(sk->reverse == NULL);
		/* state key must be unlinked from socket */
		KASSERT((sk->inp == NULL) || (sk->inp->inp_pf_sk == NULL));
		sk->inp = NULL;
		pool_put(&pf_state_key_pl, sk);
	}
}

int
pf_state_key_isvalid(struct pf_state_key *sk)
{
	return ((sk != NULL) && (sk->removed == 0));
}

void
pf_pkt_unlink_state_key(struct mbuf *m)
{
	pf_state_key_unref(m->m_pkthdr.pf.statekey);
	m->m_pkthdr.pf.statekey = NULL;
}

void
pf_inpcb_unlink_state_key(struct inpcb *inp)
{
	if (inp != NULL) {
		pf_state_key_unref(inp->inp_pf_sk);
		inp->inp_pf_sk = NULL;
	}
}

void
pf_state_key_unlink_reverse(struct pf_state_key *sk)
{
	if ((sk != NULL) && (sk->reverse != NULL)) {
		pf_state_key_unref(sk->reverse->reverse);
		sk->reverse->reverse = NULL;
		pf_state_key_unref(sk->reverse);
		sk->reverse = NULL;
	}
}
@


1.960
log
@g/c pf_change_a6(). it's exactly the same thing as pf_change_ap() with p =
NULL. inspired by Richard Procter <richard.n.procter@@gmail.com>'s mail on
tech from Aug 17, but redone. ok sashan vgross
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.959 2015/12/05 21:23:51 henning Exp $ */
d234 5
d702 1
a702 1
	} else
d704 3
d743 1
d757 8
a764 7
	if (TAILQ_EMPTY(&s->key[idx]->states)) {
		RB_REMOVE(pf_state_tree, &pf_statetbl, s->key[idx]);
		if (s->key[idx]->reverse)
			s->key[idx]->reverse->reverse = NULL;
		if (s->key[idx]->inp)
			s->key[idx]->inp->inp_pf_sk = NULL;
		pool_put(&pf_state_key_pl, s->key[idx]);
a765 1
	s->key[idx] = NULL;
d852 2
d885 2
d1002 1
a1002 1
	struct pf_state_key	*sk;
d1012 28
a1039 7
	if (dir == PF_OUT && m->m_pkthdr.pf.statekey &&
	    m->m_pkthdr.pf.statekey->reverse)
		sk = m->m_pkthdr.pf.statekey->reverse;
	else if (dir == PF_OUT && m->m_pkthdr.pf.inp &&
	    m->m_pkthdr.pf.inp->inp_pf_sk)
		sk = m->m_pkthdr.pf.inp->inp_pf_sk;
	else {
d1043 5
a1047 9
		if (dir == PF_OUT && m->m_pkthdr.pf.statekey &&
		    pf_compare_state_keys(m->m_pkthdr.pf.statekey, sk,
		    kif, dir) == 0) {
			m->m_pkthdr.pf.statekey->reverse = sk;
			sk->reverse = m->m_pkthdr.pf.statekey;
		} else if (dir == PF_OUT && m->m_pkthdr.pf.inp && !sk->inp) {
			m->m_pkthdr.pf.inp->inp_pf_sk = sk;
			sk->inp = m->m_pkthdr.pf.inp;
		}
d1050 3
a1052 4
	if (dir == PF_OUT) {
		m->m_pkthdr.pf.statekey = NULL;
		m->m_pkthdr.pf.inp = NULL;
	}
d6563 2
a6564 1
		pd.m->m_pkthdr.pf.statekey = s->key[PF_SK_STACK];
d6568 2
a6569 1
		pd.m->m_pkthdr.pf.inp->inp_pf_sk = s->key[PF_SK_STACK];
d6740 1
a6740 1
	m->m_pkthdr.pf.statekey = NULL;
d6748 1
d6750 3
a6752 1
	if (m->m_pkthdr.pf.statekey) {
d6754 4
a6757 3
		if (inp && inp->inp_pf_sk)
			KASSERT(m->m_pkthdr.pf.statekey == inp->inp_pf_sk);
	}
d6764 10
a6773 4
	if (m->m_pkthdr.pf.statekey && inp &&
	    !m->m_pkthdr.pf.statekey->inp && !inp->inp_pf_sk) {
		m->m_pkthdr.pf.statekey->inp = inp;
		inp->inp_pf_sk = m->m_pkthdr.pf.statekey;
d6776 1
a6776 1
	m->m_pkthdr.pf.statekey = NULL;
d6784 1
a6784 1
		inp->inp_pf_sk = NULL;
d6788 11
d6815 57
@


1.959
log
@g/c unneeded af (address family) params to pf_change_ap and _icmp
both af and naf (af-to case) are in the pf_pdesc
some code shuffling to actually set these before calling pf_change_ap/_icmp
inspired by Richard Procter <richard.n.procter@@gmail.com>'s mail on tech
from Aug 17, but redone
ok bluhm vgross
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.958 2015/12/05 14:58:06 henning Exp $ */
a153 2
void			 pf_change_a6(struct pf_pdesc *, struct pf_addr *a,
			    struct pf_addr *an);
a1679 11
#ifdef INET6
void
pf_change_a6(struct pf_pdesc *pd, struct pf_addr *a, struct pf_addr *an)
{
	if (pd->csum_status == PF_CSUM_UNKNOWN)
		pf_check_proto_cksum(pd, pd->off, pd->tot_len - pd->off,
		    pd->proto, pd->af);
	PF_ACPY(a, an, AF_INET6);
}
#endif /* INET6 */

d3744 1
a3744 1
				pf_change_a6(pd, pd->src, saddr);
d3748 1
a3748 1
				pf_change_a6(pd, pd->dst, daddr);
d3784 1
a3784 1
				pf_change_a6(pd, pd->src, saddr);
d3788 1
a3788 1
				pf_change_a6(pd, pd->dst, daddr);
d4590 2
a4591 2
					pf_change_a6(pd, saddr,
					    &nk->addr[sidx]);
d4595 2
a4596 2
					pf_change_a6(pd, daddr,
					    &nk->addr[didx]);
@


1.958
log
@pass a pointer to pf_test()'s reason to pf_test_rule instead of using a
local one. While we always intended to keep the logging in pf_test_rule
and pf_test so seperate that we don't end up with a wrong reason, this
is just too fragile and I can't even convince myself that it still is
right. pointed out by markus, ok bluhm benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.956 2015/12/03 14:05:28 bluhm Exp $ */
d151 1
a151 2
			    u_int16_t *, struct pf_addr *, u_int16_t,
			    sa_family_t);
d160 1
a160 1
			    u_int16_t, sa_family_t);
d1661 1
a1661 1
    struct pf_addr *an, u_int16_t pn, sa_family_t naf)
d1666 2
a1667 2
	if (pd->af == naf)
		PF_ACPY(a, an, naf);
d1885 1
a1885 1
    struct pf_addr *oa, struct pf_addr *na, u_int16_t np, sa_family_t af)
d1896 1
a1896 1
	PF_ACPY(ia, na, af);
d1900 1
a1900 1
		PF_ACPY(oa, na, af);
d3682 1
a3682 2
			pf_change_ap(pd, pd->src, pd->sport, saddr, sport,
			    pd->naf);
d3687 1
a3687 2
			pf_change_ap(pd, pd->dst, pd->dport, daddr, dport,
			    pd->naf);
d3695 1
a3695 2
			pf_change_ap(pd, pd->src, pd->sport, saddr, sport,
			    pd->naf);
d3700 1
a3700 2
			pf_change_ap(pd, pd->dst, pd->dport, daddr, dport,
			    pd->naf);
d4412 9
d4424 1
a4424 1
			    &nk->addr[sidx], nk->port[sidx], nk->af);
d4433 1
a4433 10
			    &nk->addr[didx], nk->port[didx], nk->af);

#ifdef INET6
		if (afto) {
			PF_ACPY(&pd->nsaddr, &nk->addr[sidx], nk->af);
			PF_ACPY(&pd->ndaddr, &nk->addr[didx], nk->af);
			pd->naf = nk->af;
			action = PF_AFRT;
		}
#endif /* INET6 */
a4824 4
					if (pf_change_icmp_af(pd->m, ipoff2,
					    pd, &pd2, &nk->addr[sidx],
					    &nk->addr[didx], pd->af, nk->af))
						return (PF_DROP);
a4828 8
					pf_change_ap(pd, pd2.src, &th.th_sport,
					    &nk->addr[pd2.sidx], nk->port[sidx],
					    nk->af);
					pf_change_ap(pd, pd2.dst, &th.th_dport,
					    &nk->addr[pd2.didx], nk->port[didx],
					    nk->af);
					m_copyback(pd2.m, pd2.off, 8, &th,
					    M_NOWAIT);
d4837 13
d4859 1
a4859 1
					    nk->port[pd2.sidx], pd2.af);
d4872 1
a4872 1
					    nk->port[pd2.didx], pd2.af);
a4940 4
					if (pf_change_icmp_af(pd->m, ipoff2,
					    pd, &pd2, &nk->addr[sidx],
					    &nk->addr[didx], pd->af, nk->af))
						return (PF_DROP);
a4944 8
					pf_change_ap(pd, pd2.src, &uh.uh_sport,
					    &nk->addr[pd2.sidx], nk->port[sidx],
					    nk->af);
					pf_change_ap(pd, pd2.dst, &uh.uh_dport,
					    &nk->addr[pd2.didx], nk->port[didx],
					    nk->af);
					m_copyback(pd2.m, pd2.off, sizeof(uh),
					    &uh, M_NOWAIT);
d4953 13
d4976 1
a4976 1
					    nk->port[pd2.sidx], pd2.af);
d4989 1
a4989 1
					    nk->port[pd2.didx], pd2.af);
d5098 1
a5098 1
					    nk->port[iidx] : 0, AF_INET);
d5108 1
a5108 2
					    saddr, &nk->addr[pd2.didx], 0,
					    AF_INET);
d5212 1
a5212 1
					    ? nk->port[iidx] : 0, AF_INET6);
d5222 1
a5222 2
					    saddr, &nk->addr[pd2.didx], 0,
					    AF_INET6);
d5255 1
a5255 2
					    daddr, &nk->addr[pd2.sidx], 0,
					    pd2.af);
d5265 1
a5265 2
					    saddr, &nk->addr[pd2.didx], 0,
					    pd2.af);
@


1.957
log
@ip_send()/ip6_send() allow PF to send response packet in ipsoftnet task.
this avoids current recursion to pf_test() function. the change also
switches icmp_error()/icmp6_error() to use ip_send()/ip6_send() so
they are safe for PF.

The idea comes from Markus Friedl. bluhm, mikeb and mpi helped me
a lot to get it into shape.

OK bluhm@@, mpi@@
@
text
@d181 1
a181 1
			    struct pf_ruleset **);
d3085 1
a3085 1
    struct pf_rule **am, struct pf_ruleset **rsm)
a3098 1
	u_short			 reason;
d3114 1
a3114 1
		REASON_SET(&reason, PFRES_CONGEST);
d3265 1
a3265 1
					REASON_SET(&reason, PFRES_MEMORY);
d3275 1
a3275 1
					REASON_SET(&reason, PFRES_TRANSLATE);
d3280 2
a3281 2
					REASON_SET(&reason, PFRES_MATCH);
					PFLOG_PACKET(pd, reason, r, a, ruleset,
d3321 1
a3321 1
		REASON_SET(&reason, PFRES_TRANSLATE);
d3324 1
a3324 1
	REASON_SET(&reason, PFRES_MATCH);
d3328 1
a3328 1
		PFLOG_PACKET(pd, reason, r, a, ruleset, NULL);
d3346 1
a3346 1
				REASON_SET(&reason, PFRES_PROTCKSUM);
d3379 1
a3379 1
		REASON_SET(&reason, PFRES_IPOPTIONS);
d3394 1
a3394 1
			REASON_SET(&reason, PFRES_SRCLIMIT);
d3400 1
a3400 1
			REASON_SET(&reason, PFRES_MAXSTATES);
d6420 1
a6420 1
		action = pf_test_rule(&pd, &r, &s, &a, &ruleset);
d6445 2
a6446 1
			action = pf_test_rule(&pd, &r, &s, &a, &ruleset);
d6470 2
a6471 1
			action = pf_test_rule(&pd, &r, &s, &a, &ruleset);
d6495 2
a6496 1
			action = pf_test_rule(&pd, &r, &s, &a, &ruleset);
@


1.956
log
@To avoid that the stack manipules the pf statekeys directly, introduce
pf_inp_...() lookup, link and unlink functions as an interface.
Locking can be added to them later.  Remove the first linking at
the beginning of tcp_input() and udp_input() as it is not necessary.
It will be done later anyway.  That code was a relict, from the
time before I had added the second linking.
Input from mikeb@@ and sashan@@;  OK sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.955 2015/12/03 09:49:15 bluhm Exp $ */
d2427 1
a2427 1
		ip_output(m, NULL, NULL, 0, NULL, NULL, 0);
d2431 1
a2431 1
		ip6_output(m, NULL, NULL, 0, NULL, NULL);
@


1.955
log
@Rename pf_unlink_state() to pf_remove_state() so the name does not
collide with the statekey to inp unlinking.
OK sashan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.954 2015/12/02 16:00:42 sashan Exp $ */
d6729 34
@


1.954
log
@- hide PF internals to pf_unlink_divert_state() from in_pcb.c

OK mpi@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.953 2015/12/02 13:29:25 claudio Exp $ */
d671 1
a671 1
					/* unlink late or sks can go away */
d716 1
a716 1
		pf_unlink_state(olds);
d1252 1
a1252 1
pf_unlink_state(struct pf_state *cur)
d1283 1
a1283 1
pf_unlink_divert_state(struct pf_state_key *sk)
d1290 1
a1290 1
			pf_unlink_state(si->s);
d1352 1
a1352 1
			/* free unlinked state */
d1359 2
a1360 2
			/* unlink and free expired state */
			pf_unlink_state(cur);
d4349 1
a4349 1
			pf_unlink_state(*state);
@


1.953
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.952 2015/11/21 11:29:40 mpi Exp $ */
d1280 14
@


1.952
log
@Add a comment after every #endif

requested by sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.951 2015/11/20 10:42:51 mpi Exp $ */
d2937 1
a2937 1
		rt = rtalloc(sintosa(dst), RT_REPORT, rtableid);
d2946 1
a2946 1
		rt = rtalloc(sin6tosa(dst6), RT_REPORT, rtableid);
d5387 1
a5387 1
	rt0 = rtalloc((struct sockaddr *)&ss, RT_REPORT, rtableid);
d5459 1
a5459 1
	rt = rtalloc((struct sockaddr *)&ss, RT_REPORT|RT_RESOLVE, rtableid);
d5518 1
a5518 1
		rt = rtalloc(sintosa(dst), RT_REPORT|RT_RESOLVE, rtableid);
@


1.951
log
@Make use if_get() and get rid of rt_ifp.

While here keep carp(4) bits under NCARP.

Tested by and ok sthen@@, ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.950 2015/11/12 10:07:14 mpi Exp $ */
d2603 1
a2603 1
#endif
d5413 1
a5413 1
#endif
d5420 1
a5420 1
#endif
d6330 1
a6330 1
#endif
@


1.950
log
@Prefix flowid with ph_ and print it in m_print().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.949 2015/11/06 17:55:55 mpi Exp $ */
d39 1
d2599 1
d2603 1
a5352 1
	struct ifnet		*ifp;
d5402 13
a5414 4
			if (rt->rt_ifp->if_type == IFT_CARP)
				ifp = rt->rt_ifp->if_carpdev;
			else
				ifp = rt->rt_ifp;
a5415 2
			if (kif->pfik_ifp == ifp)
				ret = 1;
d5524 1
a5524 1
		ifp = rt->rt_ifp;
d5619 2
d6326 1
d6330 1
@


1.949
log
@Rename rt_mpath_next() into rtable_mpath_next() and provide an
implementation for ART based on the singly-linked list of route
entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.948 2015/10/27 10:52:17 mpi Exp $ */
d6534 1
a6534 1
		pd.m->m_pkthdr.flowid = M_FLOWID_VALID |
@


1.948
log
@Use rt_ifidx rather than rt_ifp.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.947 2015/10/13 19:32:31 sashan Exp $ */
d5408 1
a5408 1
			rt = rt_mpath_next(rt);
@


1.947
log
@- pf_insert_src_node(): global argument (arg6) is useless, function
  always gets pointer to rule.

- pf_remove_src_node(): function should always remove matching src node,
  regardless the sn->rule.ptr being NULL or valid rule

- sn->rule.ptr is never NULL, spotted by mpi and Richard Procter _von_ gmail.com

OK mpi@@, OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.946 2015/10/08 11:36:51 dlg Exp $ */
d2915 1
d2948 2
a2949 2
	if (rt && rt->rt_ifp) {
		mss = rt->rt_ifp->if_mtu - hlen - sizeof(struct tcphdr);
d2951 1
a2951 1
		rtfree(rt);
d2953 1
@


1.946
log
@use the state id to set a flowid on an mbuf.

ok mpi@@ mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.945 2015/09/23 08:49:46 mpi Exp $ */
d504 1
a504 1
    struct pf_addr *raddr, int global)
d512 1
a512 4
		if (global)
			k.rule.ptr = NULL;
		else
			k.rule.ptr = rule;
d531 1
a531 4
		if (global)
			(*sn)->rule.ptr = NULL;
		else
			(*sn)->rule.ptr = rule;
d547 1
a547 2
		if ((*sn)->rule.ptr != NULL)
			(*sn)->rule.ptr->src_nodes++;
d566 8
a573 10
	if (sn->rule.ptr != NULL) {
		sn->rule.ptr->src_nodes--;
		if (sn->rule.ptr->states_cur == 0 &&
		    sn->rule.ptr->src_nodes == 0)
			pf_rm_rule(NULL, sn->rule.ptr);
		RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
		pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
		pf_status.src_nodes--;
		pool_put(&pf_src_tree_pl, sn);
	}
d3375 1
a3375 1
		    pd->src, NULL, 0) != 0) {
@


1.945
log
@Always increment rt_use inside rtalloc(9) instead of doing it in some
specific places.

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.944 2015/09/13 17:53:44 mpi Exp $ */
d6538 5
@


1.944
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.943 2015/09/12 20:26:06 mpi Exp $ */
a5522 1
		rt->rt_use++;
@


1.943
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.942 2015/09/12 16:32:27 bluhm Exp $ */
d5578 1
a5578 1
		error = if_output(ifp, m0, sintosa(dst), NULL);
d5607 1
a5607 1
			error = if_output(ifp, m0, sintosa(dst), NULL);
@


1.942
log
@If M_PREPEND() fails, it frees the mbuf.  In this case pf_translate_af()
must reset pd->m to avoid a use after free.
OK sashan@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.941 2015/09/11 15:21:31 mpi Exp $ */
d5578 1
a5578 1
		error = (*ifp->if_output)(ifp, m0, sintosa(dst), NULL);
d5607 1
a5607 2
			error = (*ifp->if_output)(ifp, m0, sintosa(dst),
			    NULL);
@


1.941
log
@rtfree(9) accepts NULL now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.940 2015/09/11 08:17:06 claudio Exp $ */
d1918 2
a1919 1
	if ((M_PREPEND(pd->m, hlen, M_DONTWAIT)) == NULL)
d1921 1
@


1.940
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.939 2015/09/10 08:28:31 mpi Exp $ */
d5421 1
a5421 2
	if (rt0 != NULL)
		rtfree(rt0);
d5617 1
a5617 2
	if (rt != NULL)
		rtfree(rt);
@


1.939
log
@Kill two simple in6_ifstat_inc().
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.938 2015/09/09 20:03:56 dlg Exp $ */
d2423 1
a2423 1
		ip6_output(m, NULL, NULL, 0, NULL, NULL, NULL);
d5674 1
a5674 1
		ip6_output(m0, NULL, NULL, 0, NULL, NULL, NULL);
@


1.938
log
@add if_put after the if_get.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.937 2015/09/01 19:12:25 sashan Exp $ */
a5724 1
		in6_ifstat_inc(ifp, ifs6_in_toobig);
@


1.937
log
@- route-to, dup-to, reply-to should not override the block action

  Spotted by Dilli Paudel <dilli ! paudel at oracle ! com>

ok jung@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.936 2015/08/19 21:22:41 sashan Exp $ */
d2609 2
@


1.936
log
@PF must keep IPv6 fragment size as chosen by sender also for packets,
which are routed on behalf route-to action.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.935 2015/07/21 02:32:04 sashan Exp $ */
d6625 4
@


1.935
log
@- added /* FALLTHROUGH */ comments, typecasts (u_int32_t)-1, ...


ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.934 2015/07/20 18:42:08 jsg Exp $ */
d5636 1
d5711 3
d5715 2
a5716 2
	 * If the packet is too large for the outgoing interface,
	 * send back an icmp6 error.
d5718 3
a5720 3
	if (IN6_IS_SCOPE_EMBED(&dst->sin6_addr))
		dst->sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	if ((u_long)m0->m_pkthdr.len <= ifp->if_mtu) {
d5724 1
a5724 4
		if (r->rt != PF_DUPTO)
			icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
		else
			goto bad;
d6648 1
a6648 1
			action = pf_refragment6(m0, mtag);
@


1.934
log
@Add some panics to default paths where code later assumes a non default
path was taken.  This both prevents warnings from clang and acts as a
sanity check.

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.933 2015/07/20 01:18:33 mcbride Exp $ */
d1705 1
d1713 1
d1721 1
d1729 1
d1737 1
d1745 1
d1753 1
d1787 1
d1795 1
d1816 1
d1824 1
d1832 1
d2626 1
a2626 1
		m->m_pkthdr.ph_rtableid = rtableid;
@


1.933
log
@INET6 is here to stay, so stop hauling around never-compiled code
to optimize for an INET-only kernel, as well as the fantasy unicorn
INET6-only kernel. (INET-only kernel still works)

prompted by deraadt
ok bluhm sashan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.932 2015/07/19 23:13:58 sashan Exp $ */
d2816 2
@


1.932
log
@rule_item might leak, when pf_create_state() fails

OK @@mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.931 2015/07/19 05:48:11 sashan Exp $ */
a351 1
#ifdef INET6
d359 1
d366 3
a370 1
#endif /* INET6 */
a2686 1
#ifdef INET6
d2696 1
d2707 3
d2720 1
d2740 3
a2744 1
#endif /* INET6 */
@


1.931
log
@unsinged variables should not be compared to be leq than 0 (unsigned a <= 0)

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.930 2015/07/19 01:58:19 sashan Exp $ */
d3071 1
a3354 1
		int action;
d3373 1
a3373 1
			return (action);
d3431 1
a3431 1
	return (PF_DROP);
a3453 1
	memcpy(&s->match_rules, rules, sizeof(s->match_rules));
d3582 5
@


1.930
log
@unused arguments at pf_normalize_tcp_init() and pf_refragment6()

OK deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.929 2015/07/18 23:11:35 sashan Exp $ */
d1220 1
a1220 1
		if (cur->states <= 0 && cur->expire <= time_uptime) {
d1245 1
a1245 1
		if (--sni->sn->states <= 0) {
@


1.929
log
@pf_send_tcp() should also use unhandled_af()

ok jsg@@, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.928 2015/07/18 19:19:00 sashan Exp $ */
d3536 1
a3536 1
		    pf_normalize_tcp_init(pd, &s->src, &s->dst)) {
d3806 1
a3806 1
			if (pf_normalize_tcp_init(pd, src, dst)) {
d6621 1
a6621 1
			action = pf_refragment6(m0, mtag, fwdir);
@


1.928
log
@msg.mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.927 2015/07/18 15:47:01 mpi Exp $ */
d2382 2
@


1.927
log
@Even if pf(4) is not compiled with SMALL_KERNEL add a define around
rt_mpath_next() to document the difference in behavior between the
multipath and non-multipath routing code.

No that the same pattern is present in if_group_egress_build().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.926 2015/07/18 15:19:44 sashan Exp $ */
d79 2
d82 3
d86 1
d236 1
d240 1
d948 1
a948 1
#endif
d1111 1
d1113 1
d1279 1
a1279 1
#endif
d1282 1
a1282 1
#endif
d1300 1
a1300 1
#endif
d3020 1
d3022 1
d3240 1
d3246 1
d3255 1
d3258 1
d3288 1
d3293 1
d3342 1
d3344 1
d3411 1
a3411 1
#endif
d3459 1
d3461 1
d3472 1
a3472 1
#endif
d6105 1
a6105 1
#endif
d6325 1
d6327 1
d6347 1
d6349 1
d6358 1
d6360 1
d6391 1
a6391 1
#endif /* NPFSYNC */
d6394 1
d6396 1
d6415 1
a6415 1
#endif /* NPFSYNC */
d6418 1
d6420 1
d6439 1
a6439 1
#endif /* NPFSYNC */
d6442 1
d6444 1
d6467 1
d6469 1
d6540 1
d6553 1
d6674 1
d6689 1
@


1.926
log
@INET/INET6 address family check should be unified in PF

it also adds af_unhandled(), where it is currently missing.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.925 2015/07/17 22:52:29 tedu Exp $ */
a61 1
#include <net/radix_mpath.h>
d5360 1
d5362 3
@


1.925
log
@remove obsolete INET kernel option
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.924 2015/07/16 21:14:21 mpi Exp $ */
d817 1
a817 1
#endif
d3397 1
a3397 1
#if INET && INET6
d3400 1
a3400 1
#endif /* INET && INET6 */
d3499 1
a3499 1
#endif
d4369 1
a4369 1
#if INET && INET6
d4376 1
a4376 1
#endif /* INET && INET6 */
d4572 1
a4572 1
#if INET && INET6
d4579 1
a4579 1
#endif /* INET && INET6 */
d4760 1
a4760 1
#if INET && INET6
d4794 1
a4794 1
#endif
d4875 1
a4875 1
#if INET && INET6
d4909 1
a4909 1
#endif /* INET && INET6 */
d5302 1
a5302 1
#endif
d5379 1
a5379 1
#endif
d6313 1
a6313 1
#endif
d6539 1
a6539 1
#if INET && INET6
d6554 1
a6554 1
#endif /* INET && INET6 */
d6580 1
a6580 1
#endif
@


1.924
log
@Kill IP_ROUTETOETHER.

This pseudo-option is a hack to support return-rst on bridge(4).  It
passes Ethernet information via a "struct route" through ip_output().

"struct route" is slowly dying...

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.923 2015/07/16 16:12:15 mpi Exp $ */
d1875 1
a1875 1
#if INET && INET6
d2231 1
a2231 1
#endif /* INET && INET6 */
@


1.923
log
@Expand ancient NTOHL/NTOHS/HTONS/HTONL macros.

ok guenther@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.922 2015/07/08 13:03:26 bluhm Exp $ */
d59 1
a76 1
#include <netinet/if_ether.h>
d165 1
a165 2
			    u_int16_t, u_int, struct ether_header *,
			    struct ifnet *);
d1264 1
a1264 1
		    cur->key[PF_SK_WIRE]->rdomain, NULL, NULL);
d2297 1
a2297 1
    u_int16_t rtag, u_int rdom, struct ether_header *eh, struct ifnet *ifp)
d2394 1
a2394 20
		if (eh == NULL) {
			ip_output(m, NULL, NULL, 0, NULL, NULL, 0);
		} else {
			struct route		 ro;
			struct rtentry		 rt;
			struct ether_header	*e = (void *)ro.ro_dst.sa_data;

			if (ifp == NULL) {
				m_freem(m);
				return;
			}
			rt.rt_ifp = ifp;
			ro.ro_rt = &rt;
			ro.ro_dst.sa_len = sizeof(ro.ro_dst);
			ro.ro_dst.sa_family = pseudo_AF_HDRCMPLT;
			memcpy(e->ether_shost, eh->ether_dhost, ETHER_ADDR_LEN);
			memcpy(e->ether_dhost, eh->ether_shost, ETHER_ADDR_LEN);
			e->ether_type = eh->ether_type;
			ip_output(m, NULL, &ro, IP_ROUTETOETHER, NULL, NULL, 0);
		}
d3300 1
a3300 2
				    r->return_ttl, 1, 0, pd->rdomain,
				    pd->eh, pd->kif->pfik_ifp);
d3580 1
a3580 2
		    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, 0, pd->rdomain,
		    NULL, NULL);
d4047 1
a4047 1
				    pd->rdomain, pd->eh, pd->kif->pfik_ifp);
d4170 1
a4170 1
			    0, pd->rdomain, NULL, NULL);
d4203 1
a4203 1
			    sk->rdomain, NULL, NULL);
d4218 1
a4218 1
			    (*state)->tag, pd->rdomain, NULL, NULL);
d4224 1
a4224 1
			    0, sk->rdomain, NULL, NULL);
d5500 1
a5500 1
		if (pf_test(AF_INET, PF_OUT, ifp, &m0, NULL) != PF_PASS)
d5644 1
a5644 1
		if (pf_test(AF_INET6, PF_OUT, ifp, &m0, NULL) != PF_PASS)
d6254 1
a6254 2
pf_test(sa_family_t af, int fwdir, struct ifnet *ifp, struct mbuf **m0,
    struct ether_header *eh)
a6332 1
	pd.eh = eh;
@


1.922
log
@Linking the local socket to pf states went wrong when IPsec was
involved.  For outgoing packets the IPsec layer did not clear the
sending socket from the mbuf when the address changed.  This resulted
in strange state match and create behavior in pf.  So clear the pf
statekey and inp in the packet header for both directions when the
address changes.
Mark Patruck reported the bug, identified my problematic commit and
tested the fix.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.921 2015/06/30 15:30:17 mpi Exp $ */
d1750 1
a1750 1
			*virtual_type = type;
a1751 1
			HTONS(*virtual_type);
d1836 1
a1836 1
			*virtual_type = type;
a1837 1
			HTONS(*virtual_type);
d1852 1
a1852 1
	HTONS(*virtual_type);
d2389 1
a2389 1
		HTONS(mss);
d2561 1
a2561 4
	NTOHS(a1);
	NTOHS(a2);
	NTOHS(p);
	return (pf_match(op, a1, a2, p));
d2890 1
a2890 1
			NTOHS(mss);
@


1.921
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.920 2015/06/22 15:58:23 mikeb Exp $ */
d6659 1
@


1.920
log
@Increment rule counters only after successful state insertion

Do rule counter increments after state has been successfully
installed.  This has an additional benefit of making error
handling a bit simpler.

OK mpi, bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.919 2015/06/16 11:09:39 mpi Exp $ */
d2432 1
a2432 1
	if ((m0 = m_copy(m, 0, M_COPYALL)) == NULL)
@


1.919
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.918 2015/06/07 12:02:28 jsg Exp $ */
a277 10
#define STATE_DEC_COUNTERS(s)					\
	do {							\
		struct pf_rule_item *mrm;			\
		if (s->anchor.ptr != NULL)			\
			s->anchor.ptr->states_cur--;		\
		s->rule.ptr->states_cur--;			\
		SLIST_FOREACH(mrm, &s->match_rules, entry)	\
			mrm->r->states_cur--;			\
	} while (0)

a3459 1
	STATE_INC_COUNTERS(s);
d3586 2
d3618 1
a3623 5

	if (s) {
		STATE_DEC_COUNTERS(s);
		pool_put(&pf_state_pl, s);
	}
@


1.918
log
@Introduce unhandled_af() for cases where code conditionally does
something based on an address family and later assumes one of the paths
was taken.  This was initially just calls to panic until guenther
suggested a function to reduce the amount of strings needed.

This reduces the amount of noise with static analysers and acts
as a sanity check.

ok guenther@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.917 2015/06/05 13:22:34 mikeb Exp $ */
d2353 1
a2353 1
	m->m_pkthdr.rcvif = NULL;
d2608 1
a2608 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d2611 1
@


1.917
log
@Improve error handling and recovery during state insertion

Reshuffle the code around a bit and greatly improve error handling
fixing a few bugs along the way.

Problem reported by and fix was written with Alexandr Nedvedicky.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.916 2015/05/26 16:17:51 mikeb Exp $ */
d2335 2
d4499 2
d4691 2
d5798 2
@


1.916
log
@Don't create ICMP states on reply packets unless tracking states sloppy

Since we've strengthened the ICMP state matching procedure during lookup
to only match packets against states set up in a particular direction, we
need to make sure we don't create states on packets that would otherwise
be flowing in the direction opposite to the direction of the state and
prevent further packets from matching the created state due to strict
rules imposed by the ICMP direction check.

Problem reported by Alexandr Nedvedicky, alexandr.nedvedicky-at-oracle.com.
Discussed with reyk@@;  OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.915 2015/05/22 14:18:55 mikeb Exp $ */
d206 3
a208 3
				u_int16_t);
void			 pf_set_rt_ifp(struct pf_state *,
			    struct pf_addr *);
d2961 2
a2962 2
void
pf_set_rt_ifp(struct pf_state *s, struct pf_addr *saddr)
d2966 1
d2970 2
a2971 1
		return;
d2973 1
a2973 1
	switch (s->key[PF_SK_WIRE]->af) {
d2975 1
a2975 1
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL, sns,
a2976 2
		s->rt_kif = r->route.kif;
		s->natrule.ptr = r;
d2980 1
a2980 1
		pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL, sns,
d2982 7
a2990 2
		break;
#endif /* INET6 */
d2992 2
a3566 10
	if (pf_state_insert(BOUND_IFACE(r, pd->kif), skw, sks, s)) {
		pf_state_key_detach(s, PF_SK_STACK);
		pf_state_key_detach(s, PF_SK_WIRE);
		*sks = *skw = NULL;
		REASON_SET(&reason, PFRES_STATEINS);
		goto csfailed;
	} else
		*sm = s;

	/* attach src nodes late, otherwise cleanup on error nontrivial */
d3574 1
a3574 4
				pf_src_tree_remove_state(s);
				STATE_DEC_COUNTERS(s);
				pool_put(&pf_state_pl, s);
				return (PF_DROP);
d3581 13
a3593 1
	pf_set_rt_ifp(s, pd->src);	/* needs s->state_key set */
d3621 5
d3629 1
a3630 2
		pf_normalize_tcp_cleanup(s);	/* safe even w/o init */
		pf_src_tree_remove_state(s);
@


1.915
log
@Cut down on if statements around pf_icmp_state_lookup

Checked with blambert@@, OK millert, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.914 2015/05/22 14:16:09 mikeb Exp $ */
d3080 1
a3080 1
	int			 state_icmp = 0, icmp_dir;
d3205 5
@


1.914
log
@Cleanup leftover PF_ICMP_MULTI_* code that is not needed anymore.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.913 2015/05/11 12:22:14 henning Exp $ */
d4493 6
a4498 11
		if (ret >= 0) {
			if (ret == PF_DROP && pd->af == AF_INET6 &&
			    icmp_dir == PF_OUT) {
				ret = pf_icmp_state_lookup(pd, &key, state,
				    virtual_id, virtual_type, icmp_dir, &iidx,
				    1, 0);
				if (ret >= 0)
					return (ret);
			} else
				return (ret);
		}
d5101 8
a5108 11
			if (ret >= 0) {
				if (ret == PF_DROP && pd2.af == AF_INET6 &&
				    icmp_dir == PF_OUT) {
					ret = pf_icmp_state_lookup(&pd2, &key,
					    state, virtual_id, virtual_type,
					    icmp_dir, &iidx, 1, 1);
					if (ret >= 0)
						return (ret);
				} else
					return (ret);
			}
@


1.913
log
@fix a potential use-after-free in pf_state_rm_src_node
found by jsg; ok jsg mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.912 2015/04/17 11:04:01 mikeb Exp $ */
d152 1
a152 1
			    int *, u_int16_t *, u_int16_t *);
a246 3
enum { PF_ICMP_MULTI_NONE, PF_ICMP_MULTI_LINK };


d819 1
a819 1
		if (multi == PF_ICMP_MULTI_LINK) {
d1689 1
a1689 1
pf_icmp_mapping(struct pf_pdesc *pd, u_int8_t type, int *icmp_dir, int *multi,
a1697 1
	*multi = PF_ICMP_MULTI_LINK;
d3080 1
a3080 1
	int			 state_icmp = 0, icmp_dir, multi;
d3099 1
a3099 1
		    &icmp_dir, &multi, &virtual_id, &virtual_type);
d3113 1
a3113 1
		    &icmp_dir, &multi, &virtual_id, &virtual_type);
d4469 1
a4469 1
	int		 icmp_dir, iidx, ret, multi, copyback = 0;
d4484 2
a4485 2
	if (pf_icmp_mapping(pd, icmptype, &icmp_dir, &multi,
	    &virtual_id, &virtual_type) == 0) {
d4492 1
a4492 1
		    PF_ICMP_MULTI_NONE, 0);
d4498 1
a4498 1
				    multi, 0);
d4996 1
a4996 1
			    &icmp_dir, &multi, &virtual_id, &virtual_type);
d4999 1
a4999 2
			    virtual_id, virtual_type, icmp_dir, &iidx,
			    PF_ICMP_MULTI_NONE, 1);
d5103 1
a5103 1
			    &icmp_dir, &multi, &virtual_id, &virtual_type);
d5105 1
a5105 2
			    virtual_id, virtual_type, icmp_dir, &iidx,
			    PF_ICMP_MULTI_NONE, 1);
d5111 1
a5111 1
					    icmp_dir, &iidx, multi, 1);
@


1.912
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.911 2015/04/11 13:00:12 dlg Exp $ */
d614 1
d617 2
a618 1
		snip = sni;
@


1.911
log
@the hfsc pools are only used in hfsc.c, so move the init of them
there instead of pf_ioctl.c.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.910 2015/04/08 12:50:21 mikeb Exp $ */
a5453 3
#ifdef IPSEC
	struct m_tag		*mtag;
#endif /* IPSEC */
a5540 13

	/* Copied from ip_output. */
#ifdef IPSEC
	/*
	 * If we got here and IPsec crypto processing didn't happen, drop it.
	 */
	if ((mtag = m_tag_find(m0, PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED, NULL))
	    != NULL) {
		/* Notify IPsec to do its own crypto. */
		ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
		goto bad;
	}
#endif /* IPSEC */
@


1.910
log
@Destination table needs it's own negation flag passed to the pfr_update_stats.

Spotted by Alexandr Nedvedicky <alexandr ! nedvedicky at oracle ! com>,
thanks a lot!  Ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.909 2015/03/18 12:23:15 dlg Exp $ */
a137 1
struct pool		 hfsc_class_pl, hfsc_classq_pl, hfsc_internal_sc_pl;
@


1.909
log
@remove the congestion handling from struct ifqueue.

its only used for the ip and ip6 network stack input queues, so it
seems unfair that every instance of ifqueue has to carry a pointer
around for this specific use case.

this moves the congestion marker to a kernel global. if we detect
that we're congested, we assume the whole system is busy and punish
all input queues.

marking a system as congested is done by setting the global to the
current value of ticks. as the system moves away from that value,
it moves away from being congested until the comparison fails.

written at s2k15
ok henning@@ beck@@ bluhm@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.908 2015/03/16 02:40:55 yasuoka Exp $ */
d6280 1
a6280 1
					    pd, ri->r->action, ri->r->src.neg);
@


1.908
log
@When state creations happen in short term by outgoing packets of one
SO_BINDANY socket, the new state didn't have a link of the socket's
pcb.  So the incoming packets allowed by the state were mistakenly
forwarded and the pcb could not get them.  Fix pf not to lost the link
of the pcb when the state is recreated.

ok bluhm mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.907 2015/03/14 03:38:51 jsg Exp $ */
a223 1
int			 pf_check_congestion(struct ifqueue *);
a3077 1
	struct ifqueue		*ifq = &ipintrq;
d3092 1
a3092 6
#ifdef INET6
	if (pd->af == AF_INET6)
		ifq = &ip6intrq;
#endif

	if (pd->dir == PF_IN && pf_check_congestion(ifq)) {
a6635 9
}

int
pf_check_congestion(struct ifqueue *ifq)
{
	if (ifq->ifq_congestion)
		return (1);
	else
		return (0);
@


1.907
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.906 2015/02/14 23:32:41 sthen Exp $ */
d4282 1
d4291 1
d4320 1
@


1.906
log
@Rather than using 0xff as a placeholder for "don't check prio", use 0xff to
mean "prio is 0". This avoids the need for code changes in programs which add
pf rules (as was done in pfctl but not other programs) to handle the new
"check prio" functionality. Specifically this unbreaks ftp-proxy.

Use of #define rather than magic 0xff suggested by benno.
ok benno "if henning doesnt like it he can change it when he recovers from jet-lag"
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.905 2015/02/12 01:24:10 henning Exp $ */
a59 1
#include <net/bpf.h>
@


1.905
log
@change log(matches) semantics slightly to make it more useful. since it
is a debug tool change of semantics not considered problematic.
up until now, log(matches) forced logging on subsequent matching rules,
the actual logging used the log settings from that matched rule.
now, log(matches) causes subsequent matches to be logged with the log settings
from the log(matches) rule. in particular (this was the driving point),
log(matches, to pflog23) allows you to have the trace log going to a seperate
pflog interface, not clobbering your regular pflogs, actually not affecting
them at all.
long conversation with bluhm about it, which didn't lead to a single bit
changed in the diff but was very very helpful. ok bluhm as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.902 2015/02/09 19:14:48 markus Exp $ */
d3236 2
a3237 2
		PF_TEST_ATTRIB((r->prio != 0xff &&
		    r->prio != pd->m->m_pkthdr.pf.prio),
@


1.904
log
@include the "set prio" values.
no real compat issue since we're using spare bytes.
old -> new ends up with set prio (0, 0) equivalent
new -> old is entirely harmless, old ignores the prios.
requested by Alexey Suslikov <alexey.suslikov at gmail>
ok phessler pelikan dlg
@
text
@d235 3
d3260 1
a3260 1
				if (r->log || act.log & PF_LOG_MATCHES) {
d3262 2
a3263 1
					PFLOG_PACKET(pd, reason, r, a, ruleset);
a3270 4
				if (act.log & PF_LOG_MATCHES) {
					REASON_SET(&reason, PFRES_MATCH);
					PFLOG_PACKET(pd, reason, r, a, ruleset);
				}
d3273 3
d3304 4
a3307 2
	if (r->log || act.log & PF_LOG_MATCHES)
		PFLOG_PACKET(pd, reason, r, a, ruleset);
d6557 1
a6557 1
			PFLOG_PACKET(&pd, reason, r, a, ruleset);
d6562 1
a6562 1
					    ruleset);
d6691 15
@


1.903
log
@since we inherit prio (as in, the queuing priority) from outside sources,
i. e. on vlan interfaces, it is useful to be able to match on it -
effectively matching on classification done elsewhere.
i thought i had long implemented that, but chrisz@@ asking for it made
me notice that wasn't the case.
tests by chrisz, ok phessler pelikan
@
text
@d1145 2
@


1.902
log
@correctly reset max_win if the SYN-ACK lacks a wscale option. pf
was setting max_win to 0 and discarded retransmitted SYN-ACK segments
without wscale if the original SYN contained a wscale option.
with gerhard@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.901 2015/02/07 09:15:25 henning Exp $ */
d3230 3
@


1.901
log
@pf synproxy will do the 3WHS on behalf of the target machine, and once
the 3WHS is completed, establish the backend connection. The trigger
for "3WHS completed" is the reception of the first ACK. However, we
should not proceed if that ACK also has RST or FIN set.
ACK+RST part pointed out by Kojedzinszky Richard <krichy at tvnetwork hu>
ok mikeb dlg phessler claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.899 2015/01/24 00:29:06 deraadt Exp $ */
d3839 3
a3841 2
					dst->max_win <<= dst->wscale &
					    PF_WSCALE_MASK;
@


1.900
log
@Make sure pf(4) does not see embedded scopes.

Packets destinated to link-local addresses are looped back with embedded
scopes because we cannot restore them using the receiving interface (lo0).
Embedded scopes are needed by the routing table to match RTF_LOCAL routes,
but pf(4) never saw them and existing rules are likely to break without
teaching the rule engine about them, found by dlg@@ the hard way.

So save and restore embedded scopes around pf_test() for packets going
through loopback.

ok dlg@@, mikeb@@
@
text
@d4195 1
a4195 1
		} else if (!(th->th_flags & TH_ACK) ||
@


1.899
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.898 2014/12/19 17:14:40 tedu Exp $ */
a821 5

			if (IN6_IS_SCOPE_EMBED(&key->addr[didx].v6))
				key->addr[sidx].addr16[1] =
				    key->addr[didx].addr16[1];

@


1.898
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.897 2014/12/11 08:45:44 mpi Exp $ */
d74 1
@


1.897
log
@Do not use "struct route" when it is not necessary.

This structure is now only used to pass a cached route entry to
ip{6,}_output() which will be converted shortly.

With inputs from millert@@, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.896 2014/11/20 13:54:24 mpi Exp $ */
a309 1
#ifdef INET
a315 1
#endif /* INET */
a362 1
#ifdef INET
a365 1
#endif /* INET */
a448 1
#ifdef INET
a452 1
#endif /* INET */
a1407 1
#ifdef INET
a1417 1
#endif /* INET */
a1704 1
#ifdef INET
a1779 1
#endif /* INET */
a2317 1
#ifdef INET
a2318 1
#endif /* INET */
a2330 1
#ifdef INET
a2333 1
#endif /* INET */
a2358 1
#ifdef INET
a2374 1
#endif /* INET */
a2407 1
#ifdef INET
a2429 1
#endif /* INET */
a2454 1
#ifdef INET
a2457 1
#endif /* INET */
a2477 1
#ifdef INET
a2482 1
#endif /* INET */
a2517 1
#ifdef INET
a2522 1
#endif /* INET */
a2715 1
#ifdef INET
a2719 1
#endif /* INET */
a2736 1
#ifdef INET
a2739 1
#endif /* INET */
a2806 1
#ifdef INET
a2820 1
#endif /* INET */
a2922 1
#ifdef INET
a2923 1
#endif /* INET */
a2934 1
#ifdef INET
a2942 1
#endif /* INET */
a2975 1
#ifdef INET
a2981 1
#endif /* INET */
a3014 1
#ifdef INET
a3018 1
#endif /* INET */
a3104 1
#ifdef INET
a3117 1
#endif /* INET */
a3674 1
#ifdef INET
a3711 1
#endif /* INET */
a3719 1
#ifdef INET
a3724 1
#endif /* INET */
a3751 1
#ifdef INET
a3763 1
#endif /* INET */
a4474 1
#ifdef INET
a4477 1
#endif /* INET */
a4528 1
#ifdef INET
a4561 1
#endif /* INET */
a4563 1
#ifdef INET
a4569 1
#endif /* INET */
a4612 1
#ifdef INET
a4613 1
#endif /* INET */
a4629 1
#ifdef INET
a4656 1
#endif /* INET */
a4843 1
#ifdef INET
a4849 1
#endif /* INET */
a4956 1
#ifdef INET
a4962 1
#endif /* INET */
a4979 1
#ifdef INET
a5086 1
#endif /* INET */
a5136 1
#ifdef INET
a5169 1
#endif /* INET */
a5241 1
#ifdef INET
a5247 1
#endif /* INET */
a5280 1
#ifdef INET
a5301 1
#endif /* INET */
a5337 1
#ifdef INET
a5345 1
#endif /* INET */
a5413 1
#ifdef INET
a5419 1
#endif /* INET */
a5439 1
#ifdef INET
a5615 1
#endif /* INET */
a5787 1
#ifdef INET
a5794 1
#endif /* INET */
a6058 1
#ifdef INET
a6091 1
#endif /* INET */
a6349 1
#ifdef INET
a6352 1
#endif
@


1.896
log
@Rework the handling of interfaces and IPv6 addresses for local delivery.

- Unicast packets sent to any local address will have their interface
set to loobpack.

- In order to differentiate traffic from interfaces having identical
link-local addresses, provide the scoped addresses to pf(4).

- Update the icmp6 state lookup logic to match scoped MLL addresses.

- Remove a shortcut in ip6_input() that bypasses pf and always look
for an RTF_LOCAL route.

Packets sent to multicast addresses still retain their original
interface due to the fact that local multicast packet delivering
does not use if_output.

This makes ping6 to link-local addresses work even with pf enabled
and "set skip" on loopbacks, reported by Pieter Verberne.

Debugged, analysed and tested with mikeb@@.

ok mikeb@@, henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.895 2014/11/18 02:37:31 tedu Exp $ */
a2954 1
	struct route		 ro;
a2957 1
	struct route_in6	 ro6;
d2960 1
d2964 2
d2970 1
a2970 2
		bzero(&ro, sizeof(ro));
		dst = (struct sockaddr_in *)&ro.ro_dst;
d2974 1
a2974 3
		ro.ro_tableid = rtableid;
		ro.ro_rt = rtalloc(&ro.ro_dst, RT_REPORT, ro.ro_tableid);
		rt = ro.ro_rt;
d2980 1
a2980 2
		bzero(&ro6, sizeof(ro6));
		dst6 = (struct sockaddr_in6 *)&ro6.ro_dst;
d2984 1
a2984 4
		ro6.ro_tableid = rtableid;
		ro6.ro_rt = rtalloc(sin6tosa(&ro6.ro_dst), RT_REPORT,
		    ro6.ro_tableid);
		rt = ro6.ro_rt;
d5393 1
a5398 3
	struct route_in6	 ro;
#else
	struct route		 ro;
d5400 1
a5400 1
	struct rtentry		*rt;
d5404 1
a5404 2
	bzero(&ro, sizeof(ro));
	ro.ro_tableid = rtableid;
d5408 1
a5408 1
		dst = (struct sockaddr_in *)&ro.ro_dst;
d5424 1
a5424 1
		dst6 = &ro.ro_dst;
d5438 2
a5439 4
	ro.ro_rt = rtalloc((struct sockaddr *)&ro.ro_dst, RT_REPORT,
	    ro.ro_tableid);

	if (ro.ro_rt != NULL) {
d5451 1
a5451 1
		rt = ro.ro_rt;
d5465 2
a5466 2
	if (ro.ro_rt != NULL)
		rtfree(ro.ro_rt);
d5474 1
a5477 3
	struct route_in6	 ro;
#else
	struct route		 ro;
d5479 1
d5482 1
a5482 2
	bzero(&ro, sizeof(ro));
	ro.ro_tableid = rtableid;
d5486 1
a5486 1
		dst = (struct sockaddr_in *)(&ro.ro_dst);
d5494 1
a5494 1
		dst6 = &ro.ro_dst;
d5502 3
a5504 5
	ro.ro_rt = rtalloc((struct sockaddr *)&ro.ro_dst, RT_REPORT,
	    ro.ro_tableid);

	if (ro.ro_rt != NULL) {
		if (ro.ro_rt->rt_labelid == aw->v.rtlabel)
d5506 1
a5506 1
		rtfree(ro.ro_rt);
d5518 2
a5519 3
	struct route		 iproute;
	struct route		*ro = NULL;
	struct sockaddr_in	*dst;
d5525 1
d5557 2
a5558 3
	ro = &iproute;
	bzero((caddr_t)ro, sizeof(*ro));
	dst = satosin(&ro->ro_dst);
d5562 1
a5562 1
	ro->ro_tableid = m0->m_pkthdr.ph_rtableid;
d5565 2
a5566 3
		ro->ro_rt = rtalloc(&ro->ro_dst, RT_REPORT|RT_RESOLVE,
		    ro->ro_tableid);
		if (ro->ro_rt == 0) {
d5571 2
a5572 2
		ifp = ro->ro_rt->rt_ifp;
		ro->ro_rt->rt_use++;
d5574 2
a5575 2
		if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			dst = satosin(ro->ro_rt->rt_gateway);
d5681 2
a5682 2
	if (ro == &iproute && ro->ro_rt)
		rtfree(ro->ro_rt);
d5697 1
a5697 3
	struct route_in6	 ip6route;
	struct route_in6	*ro;
	struct sockaddr_in6	*dst;
d5729 2
a5730 3
	ro = &ip6route;
	bzero((caddr_t)ro, sizeof(*ro));
	dst = (struct sockaddr_in6 *)&ro->ro_dst;
a5733 1
	ro->ro_tableid = m0->m_pkthdr.ph_rtableid;
@


1.895
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.894 2014/11/16 17:40:17 tedu Exp $ */
d827 5
d5804 1
a5804 1
		nd6_output(ifp, ifp, m0, dst, NULL);
@


1.894
log
@remove now unnecessary casts from hash update calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.893 2014/11/16 17:37:42 tedu Exp $ */
a78 1
#include <dev/rndvar.h>
@


1.893
log
@convert to use sha512 for pf iss. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.892 2014/11/16 11:58:14 dlg Exp $ */
d3049 3
a3051 3
	SHA512Update(&ctx, (char *)&pd->rdomain, sizeof(pd->rdomain));
	SHA512Update(&ctx, (char *)&pd->hdr.tcp->th_sport, sizeof(u_short));
	SHA512Update(&ctx, (char *)&pd->hdr.tcp->th_dport, sizeof(u_short));
d3055 2
a3056 2
		SHA512Update(&ctx, (char *)&pd->src->v4, sizeof(struct in_addr));
		SHA512Update(&ctx, (char *)&pd->dst->v4, sizeof(struct in_addr));
d3061 2
a3062 2
		SHA512Update(&ctx, (char *)&pd->src->v6, sizeof(struct in6_addr));
		SHA512Update(&ctx, (char *)&pd->dst->v6, sizeof(struct in6_addr));
@


1.892
log
@mix the rdomain (rtable?) into the hash for tcp iss generation.

ok phessler@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.891 2014/11/11 11:37:05 mikeb Exp $ */
d56 1
a56 1
#include <crypto/md5.h>
d108 1
a108 1
MD5_CTX			 pf_tcp_secret_ctx;
d3034 5
a3038 2
	MD5_CTX ctx;
	u_int32_t digest[4];
d3042 2
a3043 2
		MD5Init(&pf_tcp_secret_ctx);
		MD5Update(&pf_tcp_secret_ctx, pf_tcp_secret,
d3049 3
a3051 3
	MD5Update(&ctx, (char *)&pd->rdomain, sizeof(pd->rdomain));
	MD5Update(&ctx, (char *)&pd->hdr.tcp->th_sport, sizeof(u_short));
	MD5Update(&ctx, (char *)&pd->hdr.tcp->th_dport, sizeof(u_short));
d3055 2
a3056 2
		MD5Update(&ctx, (char *)&pd->src->v4, sizeof(struct in_addr));
		MD5Update(&ctx, (char *)&pd->dst->v4, sizeof(struct in_addr));
d3061 2
a3062 2
		MD5Update(&ctx, (char *)&pd->src->v6, sizeof(struct in6_addr));
		MD5Update(&ctx, (char *)&pd->dst->v6, sizeof(struct in6_addr));
d3066 1
a3066 1
	MD5Final((u_char *)digest, &ctx);
d3068 1
a3068 1
	return (digest[0] + tcp_iss + pf_tcp_iss_off);
@


1.891
log
@Ask networking stack to recalculate the ICMPv6 checksum in pf_route6
since we might have tweaked the addresses.

Problem reported and fix test by Bastien Durel <bastien at geekwu ! org>,
thanks!  OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.890 2014/11/01 21:40:38 mpi Exp $ */
d3046 1
@


1.890
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.889 2014/10/14 09:52:25 mpi Exp $ */
d5786 2
@


1.889
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.888 2014/10/08 07:37:01 mpi Exp $ */
d2971 1
a2971 2
		ro.ro_rt = rtalloc1(&ro.ro_dst, RT_REPORT | RT_NOCLONING,
		    ro.ro_tableid);
d2984 2
a2985 2
		ro6.ro_rt = rtalloc1(sin6tosa(&ro6.ro_dst),
		    RT_REPORT | RT_NOCLONING, ro6.ro_tableid);
d5439 2
a5440 2
	ro.ro_rt = rtalloc1((struct sockaddr *)&ro.ro_dst,
	    RT_REPORT | RT_NOCLONING, ro.ro_tableid);
d5507 2
a5508 2
	ro.ro_rt = rtalloc1((struct sockaddr *)&ro.ro_dst,
	    RT_REPORT | RT_NOCLONING, ro.ro_tableid);
d5573 2
a5574 1
		ro->ro_rt = rtalloc1(&ro->ro_dst, RT_REPORT, ro->ro_tableid);
@


1.888
log
@Use rtalloc1() instead of rtalloc_noclone().

ok henning@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.887 2014/09/27 12:26:16 mpi Exp $ */
d2995 1
a2995 1
		RTFREE(rt);
d5470 1
a5470 1
		RTFREE(ro.ro_rt);
d5514 1
a5514 1
		RTFREE(ro.ro_rt);
d5691 1
a5691 1
		RTFREE(ro->ro_rt);
@


1.887
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.886 2014/08/12 15:29:33 mikeb Exp $ */
d2971 2
a2972 1
		rtalloc_noclone(&ro);
d2985 2
a2986 1
		rtalloc_noclone((struct route *)&ro6);
d5440 2
a5441 1
	rtalloc_noclone((struct route *)&ro);
d5508 2
a5509 1
	rtalloc_noclone((struct route *)&ro);
@


1.886
log
@Finally implement what's stated in the man page regarding parent
anchors for "once" rules: "In case this is the only rule in the
anchor, the anchor will be destroyed automatically after the rule
is matched."  Employ an additional pointer pair to keep track of
the parent ruleset containing the anchor that we want to remove.

OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.885 2014/08/12 14:42:06 mikeb Exp $ */
d5570 1
a5570 1
		rtalloc(ro);
@


1.885
log
@Make sure that pf_step_into_anchor always saves a pointer to the rule
that owns the anchor on the pf anchor stack.  There's no reason why we
should check for depth here.  As a side effect this makes sure that the
correct nested anchor gets it's counter bumped instead of the top most.

For the save/restore symmetry pf_step_out_of_anchor is made to always
restore previous value of the anchor rule.  depth == 0 means what we a
at the top (main ruleset).

OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.884 2014/08/12 14:38:27 mikeb Exp $ */
d3105 2
d3302 1
d3312 2
a3313 1
		} else
d3315 1
d3322 4
a3325 3
	r = *rm;
	a = *am;
	ruleset = *rsm;
d3458 1
a3458 1
		pf_purge_rule(ruleset, r);
@


1.884
log
@Apart from some minor code reshuffling the big change is that we
start with a ruleset pointer assigned to pf_main_ruleset so that
pf_purge_rule doesn't get called with a NULL.

Prompted by the discussion with Alexandr Nedvedicky <alexandr !
nedvedicky at oracle ! com>.

OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.883 2014/07/22 11:06:09 mpi Exp $ */
d2671 1
a2671 1
	} else if (*depth == 0 && a != NULL)
d2716 2
@


1.883
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.882 2014/07/13 16:58:43 bluhm Exp $ */
d3168 1
@


1.883.4.1
log
@Ask networking stack to recalculate the ICMPv6 checksum in pf_route6
since we might have tweaked the addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.883 2014/07/22 11:06:09 mpi Exp $ */
a5772 2

	in6_proto_cksum_out(m0, ifp);
@


1.882
log
@Put back a m_copyback() that got lost in rev 1.837 of pf.c.  This
fixes the rewrite of an IPv6 header of an ICMP6 packet in the payload
of an ICMP6 error packet.  Path MTU discovery with ping6 over pf
nat or rdr works again.
Found by src/regress/sys/net/pf_fragment make run-regress-fragping6
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.881 2014/07/10 03:17:59 lteo Exp $ */
a64 1
#include <netinet/in_systm.h>
@


1.881
log
@Simplify the way divert(4) sends packets to userspace: Instead of
unnecessarily allocating an mbuf tag to store the divert port, just pass
the divert port directly to divert_packet() or divert6_packet() as an
argument.

includes a style fix pointed out by bluhm@@
ok bluhm@@ henning@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.880 2014/07/02 13:04:50 mikeb Exp $ */
d5252 3
a5254 1
				m_copyback(pd->m, pd2.off,
@


1.880
log
@u_int32_t's can't go negative
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.879 2014/06/25 16:21:20 mikeb Exp $ */
d6620 1
a6620 6
	if (action == PF_PASS && r->divert_packet.port) {
		struct pf_divert *divert;

		if ((divert = pf_get_divert(pd.m)))
			divert->port = r->divert_packet.port;

a6621 1
	}
d6648 1
a6648 1
			if (divert_packet(pd.m, pd.dir) == 0)
d6653 2
a6654 1
			if (divert6_packet(pd.m, pd.dir) == 0)
@


1.879
log
@pf_translate doesn't use the mbuf argument anymore.

From Alexandr Nedvedicky <alexandr ! nedvedicky at oracle ! com>.  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.878 2014/05/20 11:03:13 mpi Exp $ */
d587 2
a588 2
		if (sn->rule.ptr->states_cur <= 0 &&
		    sn->rule.ptr->src_nodes <= 0)
d1310 2
a1311 2
	if (--cur->rule.ptr->states_cur <= 0 &&
	    cur->rule.ptr->src_nodes <= 0)
d1314 1
a1314 1
		if (--cur->anchor.ptr->states_cur <= 0)
d1318 2
a1319 2
		if (--ri->r->states_cur <= 0 &&
		    ri->r->src_nodes <= 0)
@


1.878
log
@Assign the queue ID to the correct packet header when sending ICMP messages.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.877 2014/04/24 11:55:12 henning Exp $ */
d3420 1
a3420 1
			    virtual_type, icmp_dir, pd->m);
d3660 1
a3660 1
    int icmp_dir, struct mbuf *m)
@


1.877
log
@ewps... repair qid assignment
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.875 2014/04/21 12:22:25 henning Exp $ */
d2467 1
a2467 1
		m->m_pkthdr.pf.qid = r->qid;
@


1.876
log
@Remove some altq tentacles.

ok pelikan@@, henning@@
@
text
@d2362 2
d2466 2
d6584 2
@


1.875
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.874 2014/04/21 11:10:54 henning Exp $ */
a106 3
struct pf_altqqueue	 pf_altqs[2];
struct pf_altqqueue	*pf_altqs_active;
struct pf_altqqueue	*pf_altqs_inactive;
a108 4
u_int32_t		 ticket_altqs_active;
u_int32_t		 ticket_altqs_inactive;
int			 altqs_inactive_open;

d139 1
a139 1
struct pool		 pf_altq_pl, pf_rule_item_pl, pf_sn_item_pl;
@


1.874
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.873 2014/04/19 12:59:53 henning Exp $ */
d2429 1
a2429 1
			ip_output(m, NULL, NULL, 0, NULL, NULL);
d2446 1
a2446 1
			ip_output(m, NULL, &ro, IP_ROUTETOETHER, NULL, NULL);
@


1.873
log
@shrink pf by 445 lines.
while there, get rid of the altq ioctls and assciated now obsolete code
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.870 2014/03/10 17:27:06 jca Exp $ */
d2429 1
a2429 2
			ip_output(m, (void *)NULL, (void *)NULL, 0,
			    (void *)NULL, (void *)NULL);
d2446 1
a2446 2
			ip_output(m, (void *)NULL, &ro, IP_ROUTETOETHER,
			    (void *)NULL, (void *)NULL);
@


1.872
log
@pf_send_tcp: ask the stack to do the cksum instead of doing it manually
ok benno lteo naddy (back in january)
@
text
@a2368 8

#ifdef ALTQ
	if (r != NULL && r->qid) {
		m->m_pkthdr.pf.qid = r->qid;
		/* add hints for ecn */
		m->m_pkthdr.pf.hdr = mtod(m, struct ip *);
	}
#endif /* ALTQ */
a2473 8
#ifdef ALTQ
	if (r->qid) {
		m0->m_pkthdr.pf.qid = r->qid;
		/* add hints for ecn */
		m0->m_pkthdr.pf.hdr = mtod(m0, struct ip *);
	}
#endif /* ALTQ */

a6596 7

#ifdef ALTQ
	if (action == PF_PASS && qid) {
		pd.m->m_pkthdr.pf.qid = qid;
		pd.m->m_pkthdr.pf.hdr = mtod(pd.m, caddr_t);/* hints for ecn */
	}
#endif /* ALTQ */
@


1.871
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d2380 1
a2385 2

		/* IP header fields included in the TCP checksum */
d2388 7
a2403 2

		/* IP header fields included in the TCP checksum */
d2406 2
a2435 11
		/* TCP checksum */
		th->th_sum = in_cksum(m, len);

		/* Finish the IP header */
		h->ip_v = 4;
		h->ip_hl = sizeof(*h) >> 2;
		h->ip_tos = IPTOS_LOWDELAY;
		h->ip_len = htons(len);
		h->ip_off = htons(ip_mtudisc ? IP_DF : 0);
		h->ip_ttl = ttl ? ttl : ip_defttl;
		h->ip_sum = 0;
a2461 7
		/* TCP checksum */
		th->th_sum = in6_cksum(m, IPPROTO_TCP,
		    sizeof(struct ip6_hdr), tlen);

		h6->ip6_vfc |= IPV6_VERSION;
		h6->ip6_hlim = IPV6_DEFHLIM;

@


1.870
log
@When translating packets from one address family to another, pass the
TOS/Traffic Class field of the original packet.  Discussed with mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.869 2014/03/10 17:22:27 jca Exp $ */
d2366 1
a2366 1
	m->m_pkthdr.rdomain = rdom;
d2490 1
a2490 1
	m0->m_pkthdr.rdomain = rdomain;
d2691 1
a2691 1
		m->m_pkthdr.rdomain = rtableid;
d4469 1
a4469 1
		pd->m->m_pkthdr.rdomain = nk->rdomain;
d4596 1
a4596 1
			pd->m->m_pkthdr.rdomain = nk->rdomain;
d4886 2
a4887 1
					pd->m->m_pkthdr.rdomain = nk->rdomain;
d4908 1
a4908 1
				pd->m->m_pkthdr.rdomain = nk->rdomain;
d5003 2
a5004 1
					pd->m->m_pkthdr.rdomain = nk->rdomain;
d5026 1
a5026 1
				pd->m->m_pkthdr.rdomain = nk->rdomain;
d5126 2
a5127 1
					pd->m->m_pkthdr.rdomain = nk->rdomain;
d5152 1
a5152 1
				pd->m->m_pkthdr.rdomain = nk->rdomain;
d5245 2
a5246 1
					pd->m->m_pkthdr.rdomain = nk->rdomain;
d5274 1
a5274 1
				pd->m->m_pkthdr.rdomain = nk->rdomain;
d5317 1
a5317 1
				pd->m->m_pkthdr.rdomain = nk->rdomain;
d5590 1
a5590 1
	ro->ro_tableid = m0->m_pkthdr.rdomain;
d5765 1
a5765 1
	ro->ro_tableid = m0->m_pkthdr.rdomain;
d6162 1
a6162 1
	pd->rdomain = rtable_l2(pd->m->m_pkthdr.rdomain);
@


1.869
log
@When setting up the packet description, also retrieve the Traffic Class
field of IPv6 packets.  Issue reported by Christophe Heurtaux on frnog.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.868 2014/01/25 03:39:00 lteo Exp $ */
d1935 1
d1948 1
@


1.868
log
@Simplify and shorten the way ICMP checksums are verified in
pf_check_proto_cksum() by letting it use the same in4_cksum() call that
is used for TCP and UDP checksums.

ok henning@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.867 2014/01/24 12:07:50 henning Exp $ */
d6231 1
a6231 1
		pd->tos = 0;
@


1.868.4.1
log
@Ask networking stack to recalculate the ICMPv6 checksum in pf_route6
since we might have tweaked the addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.868 2014/01/25 03:39:00 lteo Exp $ */
a5798 2

	in6_proto_cksum_out(m0, ifp);
@


1.868.4.2
log
@Put back a m_copyback() that got lost in rev 1.837 of pf.c.  This
fixes the rewrite of an IPv6 header of an ICMP6 packet in the payload
of an ICMP6 error packet.  Path MTU discovery with ping6 over pf
nat or rdr works again.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.868.4.1 2015/01/03 00:37:05 brad Exp $ */
d5279 1
a5279 3
				m_copyback(pd2.m, ipoff2, sizeof(h2_6), &h2_6,
				    M_NOWAIT);
				m_copyback(pd2.m, pd2.off,
@


1.867
log
@in pf_check_proto_cksum, updtae the swcksum counters if we cksummed in
software. ok naddy
(this is pbly the ultimate commit'n'run)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.866 2014/01/23 23:51:29 henning Exp $ */
d5888 3
a5890 16
		if (p == IPPROTO_ICMP) {
			if (pd->m->m_len < off) {
				pd->csum_status = PF_CSUM_BAD;
				return (1);
			}
			pd->m->m_data += off;
			pd->m->m_len -= off;
			sum = in_cksum(pd->m, len);
			pd->m->m_data -= off;
			pd->m->m_len += off;
		} else {
			if (pd->m->m_len < sizeof(struct ip)) {
				pd->csum_status = PF_CSUM_BAD;
				return (1);
			}
			sum = in4_cksum(pd->m, p, off, len);
d5892 1
@


1.866
log
@since the cksum rewrite the counters for hardware checksummed packets
are are lie, since the software engine emulates hardware offloading
and that is later indistinguishable. so kill the hw cksummed counters.
introduce software checksummed packet counters instead.
tcp/udp handles ip & ipvshit, ip cksum covered, 6 has no ip layer cksum.
as before we still have a miscounting bug for inbound with pf on, to be
fixed in the next step.
found by, prodding & ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.864 2014/01/20 02:57:49 henning Exp $ */
d5878 7
@


1.865
log
@7x bcopy -> memcpy, impossibility of overlaps verified. ok benno dlg
@
text
@d5656 1
a5656 1
		if (ifp->if_capabilities & IFCAP_CSUM_IPv4) {
d5658 2
a5659 2
			ipstat.ips_outhwcsum++;
		} else
d5661 1
a5661 5
		/* Update relevant hardware checksum stats for TCP/UDP */
		if (m0->m_pkthdr.csum_flags & M_TCP_CSUM_OUT)
			tcpstat.tcps_outhwcsum++;
		else if (m0->m_pkthdr.csum_flags & M_UDP_CSUM_OUT)
			udpstat.udps_outhwcsum++;
@


1.864
log
@support negated matches on the rcvif, ok dlg benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.862 2013/11/18 20:30:04 bluhm Exp $ */
d1121 1
a1121 1
	bcopy(&st->rt_addr, &sp->rt_addr, sizeof(sp->rt_addr));
d2422 1
a2422 1
		bcopy((caddr_t)&mss, (caddr_t)(opt + 2), 2);
d2455 2
a2456 2
			bcopy(eh->ether_dhost, e->ether_shost, ETHER_ADDR_LEN);
			bcopy(eh->ether_shost, e->ether_dhost, ETHER_ADDR_LEN);
d2961 1
a2961 1
			bcopy((caddr_t)(opt + 2), (caddr_t)&mss, 2);
d3519 1
a3519 1
	bcopy(rules, &s->match_rules, sizeof(s->match_rules));
@


1.863
log
@Switch frequently allocated structs from malloc(M_DEVBUF) to separate pools.

ok henning, "looks fine" mikeb, input from guenther.
@
text
@d3296 2
a3297 1
		PF_TEST_ATTRIB((r->rcv_kif && !pf_match_rcvif(pd->m, r)),
@


1.862
log
@The prio value of a pf match rule was overridden by a later pass
rule even if the latter had no prio flag.  Fix match rules with
prio to work as expected.
Found by Roman Kravchuk; reported and tested by Alexey Suslikov;
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.861 2013/11/16 00:36:01 chl Exp $ */
d147 1
@


1.861
log
@Remove dead assignments and now unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mikeb@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.860 2013/11/15 21:34:51 haesbaert Exp $ */
d3113 4
a3116 2
	a->set_prio[0] = r->set_prio[0];
	a->set_prio[1] = r->set_prio[1];
@


1.860
log
@Revert 1.858, as it causes panics of inp:

kernel diagnostic assertion \"sotoinpcb(inp->inp_socket) == inp\"
failed: file "../../../../netinet/tcp_input.c", line 646

Will think of a better fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.859 2013/11/15 16:15:41 bluhm Exp $ */
d4530 1
a4530 1
	u_int16_t	*icmpsum, virtual_id, virtual_type;
a4539 1
		icmpsum = &pd->hdr.icmp->icmp_cksum;
a4544 1
		icmpsum = &pd->hdr.icmp6->icmp6_cksum;
a4686 1
		u_int16_t	*ipsum2;
a4726 1
			ipsum2 = &h2.ip_sum;
a4747 1
			ipsum2 = NULL;
a5797 1
		ip6 = mtod(m0, struct ip6_hdr *);
@


1.859
log
@After discussion with deraadt@@ and Fernando Gont, it seems that the
stack should still scan for IPv6 type 0 routing headers.  There are
OpenBSD routers running without pf and there are plenty of legacy
implementations supporting RH0.

Bring back the function ip6_check_rh0hdr() that I removed a month
ago.  As an improvement to the prevoius solution, only scan the
header chain in ip6_input() if the packet has not been inspected
by pf.  Both implementations drop packets with RH0 anywhere in the
extension header chain.

OK mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.858 2013/11/15 10:18:26 haesbaert Exp $ */
a6808 4
	if (m->m_pkthdr.pf.inp) {
		m->m_pkthdr.pf.inp->inp_pf_sk = NULL;
		m->m_pkthdr.pf.inp = NULL;
	}
@


1.858
log
@Forget socket linking on pf_pkt_addr_changed(), this fixes among other
things, setups with ipsec+ifbound.

The sympthon was that local IPSec packets (tunnel->tunnel) would not
match state after the latest pf_find_state() changes. The first packet
would go through, but the subsequent ones would fail the match and
collide later with the existing state.

ok henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.857 2013/10/30 11:35:10 mpi Exp $ */
d6493 1
@


1.857
log
@Allow to compile a kernel without INET6.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.856 2013/10/30 11:21:26 mikeb Exp $ */
d6808 4
@


1.856
log
@translate icmpv6 echo id's the same way we do for icmpv4;  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.855 2013/10/28 12:09:41 mikeb Exp $ */
d6788 1
d6793 1
@


1.855
log
@previous udp port number rewrite fix turned out to be a work around
the incorrect pf_change_ap call;  while here make the tcp case use
pf_change_ap since it shares the same properties.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.854 2013/10/24 11:14:33 deraadt Exp $ */
d3792 12
@


1.854
log
@Move obvious kernel prototypes (and structure's with kernel pointers,
obviously only used in the kernel) behind #ifdef _KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.853 2013/10/23 16:13:54 mikeb Exp $ */
d4865 6
a4870 2
					th.th_sport = nk->port[sidx];
					th.th_dport = nk->port[didx];
d4981 6
a4986 8
					pf_change_ap(pd, pd2.src,
					    &uh.uh_sum, &nk->addr[pd2.sidx],
					    nk->port[sidx], nk->af);
					pf_change_ap(pd, pd2.dst,
					    &uh.uh_sum, &nk->addr[pd2.didx],
					    nk->port[didx], nk->af);
					uh.uh_sport = nk->port[sidx];
					uh.uh_dport = nk->port[didx];
@


1.853
log
@translate port numbers for inner udp packets when they're returned
as a payload of icmp error messages;  makes traceroute6 operate
across a nat64 gateway.

prompted by sthen, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.852 2013/10/23 15:12:42 mpi Exp $ */
d834 1
a834 1
			key->addr[sidx].addr32[0] = IPV6_ADDR_INT32_MLL;
d837 1
a837 1
			key->addr[sidx].addr32[3] = IPV6_ADDR_INT32_ONE;
@


1.852
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.851 2013/10/23 11:06:56 mikeb Exp $ */
d4983 2
@


1.851
log
@overwrite icmp packet type-specific nextptr field only when we're
changing it.  fixes an icmp to icmpv6 translation regression found
by todd and sthen.

ok henning sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.850 2013/10/22 15:35:57 lteo Exp $ */
a64 1
#include <netinet/in_var.h>
@


1.850
log
@In pf_test_state_icmp(), actually copy pd->hdr.any back into the mbuf as
intended after the ICMP/ICMPv6 checksum is zeroed in pf_cksum().  This
resolves an issue found by sthen@@ where ICMP traffic with nat-to failed
due to incorrect checksums.

Fix tested by sthen@@ and myself
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.849 2013/10/21 09:39:23 henning Exp $ */
d2160 2
a2161 1
		icmp6->icmp6_pptr = htonl(ptr << 24);
d2253 2
a2254 1
		icmp4->icmp_void = htonl(ptr);
@


1.849
log
@pf_translate: missing conditonal pf_check_proto_cksum calls before
mucking with the icmpid.
impact of the bug is quite limited, only affect icmp echo requests & reply
through nat when the natting does not actually change any address.
ok bluhm, found while hunting something else sthen is seeing
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.845 2013/10/19 10:47:53 henning Exp $ */
d5328 1
a5328 1
	if (copyback)
d5330 2
@


1.848
log
@in pf_cksum, set the icmp/icmp6 cksums to 0, for comsistency with tcp/udp
with & ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.847 2013/10/20 13:21:56 claudio Exp $ */
d3759 4
d4604 5
a4608 1
				if (nk->port[iidx] !=  pd->hdr.icmp->icmp_id)
d4610 1
d4639 5
a4643 1
				if (nk->port[iidx] != pd->hdr.icmp6->icmp6_id)
d4646 1
@


1.847
log
@rt_mpath_next() was always called with 0 in the last argument. So drop it.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.846 2013/10/20 11:03:00 phessler Exp $ */
d6752 3
d6756 1
@


1.846
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.845 2013/10/19 10:47:53 henning Exp $ */
d5446 1
a5446 1
			rt = rt_mpath_next(rt, 0);
@


1.845
log
@pf_cksum doesn't need to compute the pseudo hdr cksum any more.
ok lteo florian
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.844 2013/10/17 16:27:41 bluhm Exp $ */
d2878 1
a2878 1
		    dport);
d2881 1
a2881 1
			    NULL);
d5731 1
d6134 1
a6161 1
		pd->rdomain = rtable_l2(pd->m->m_pkthdr.rdomain);
a6210 1
		pd->rdomain = 0;
@


1.844
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.843 2013/10/12 12:13:10 henning Exp $ */
a6744 5
		if (pd->af == AF_INET) {
			pd->hdr.tcp->th_sum = in_cksum_phdr(pd->src->v4.s_addr,
			    pd->dst->v4.s_addr, htons(pd->tot_len -
			    pd->off + IPPROTO_TCP));
		}
a6748 5
		if (pd->af == AF_INET) {
			pd->hdr.udp->uh_sum = in_cksum_phdr(pd->src->v4.s_addr,
			    pd->dst->v4.s_addr, htons(pd->tot_len -
			    pd->off + IPPROTO_UDP));
		}
@


1.843
log
@new bandwidth shaping subsystem, kernel side
uses hfsc behind the scenes; altq stays in parallel for a migration phase.
if.h even more messy for the transition, but eventuelly it should become
readable...
looked over & tested by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.842 2013/10/11 10:58:42 gerhard Exp $ */
d91 1
@


1.842
log
@Prevent non-data packets from being dropped.

ok bluhm@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.841 2013/10/09 09:32:01 camield Exp $ */
d5 1
a5 1
 * Copyright (c) 2002 - 2012 Henning Brauer <henning@@openbsd.org>
d103 3
d144 1
a144 1
struct pool		 pf_src_tree_pl, pf_rule_pl;
@


1.841
log
@Don't leak ruleitems from match rules when hitting a per-rule max state limit.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.840 2013/09/27 10:20:08 bluhm Exp $ */
d3943 1
a3943 1
		end = seq;
@


1.840
log
@IPv6 atomic fragments must not go the reassembly queue, but be
processed immediately.  Let pf step over an atomic fragment header
and handle the packet like an unfragmented.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.839 2013/08/19 09:16:25 henning Exp $ */
d3419 6
a3500 7

	/* check maximums */
	if (r->max_states && (r->states_cur >= r->max_states)) {
		pf_status.lcounters[LCNT_STATES]++;
		REASON_SET(&reason, PFRES_MAXSTATES);
		return (PF_DROP);
	}
@


1.839
log
@in pf_test_rule, when dealing with a match rule, obey the match rule's quick
flag to decide wether to abort ruleset eval instead of the last matching rule's
one. makes "match quick" abort ruleset evaluation with the current block/pass
state. from Maxim Khitrov <max at mxcrypt.com>, ok bluhm mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.838 2013/07/05 13:07:57 blambert Exp $ */
d6003 1
a6003 1
	int			 rthdr_cnt = 0;
d6012 1
a6012 1
			if (pd->fragoff != 0) {
a6027 1
			pd->fragoff = pd->off;
d6029 2
a6030 1
			if (ntohs((frag.ip6f_offlg & IP6F_OFF_MASK)) != 0)
d6032 4
@


1.838
log
@Collect and display 'match' counters for pf tables.

While here, fix pf table displays to fit within 80 chars.

Manpage input jmc@@

ok henning@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.837 2013/06/26 09:12:39 henning Exp $ */
d3326 1
a3326 1
			if ((*rm)->quick)
@


1.837
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.836 2013/06/26 07:53:59 blambert Exp $ */
d6346 1
a6346 4
					    pd->af, pd->tot_len,
					    pd->dir == PF_OUT,
					    r->action == PF_PASS,
					    ri->r->src.neg);
d6351 1
a6351 4
					    pd->af, pd->tot_len,
					    pd->dir == PF_OUT,
					    r->action == PF_PASS,
					    ri->r->dst.neg);
d6359 1
a6359 2
			    pd->af, pd->tot_len, pd->dir == PF_OUT,
			    r->action == PF_PASS, r->src.neg);
d6365 1
a6365 2
			    pd->af, pd->tot_len, pd->dir == PF_OUT,
			    r->action == PF_PASS, r->dst.neg);
@


1.836
log
@Rudimentary counter fix for tables used in match rules.

Fixes an issue seen by reyk@@

ok henning@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.835 2013/06/17 19:50:06 bluhm Exp $ */
d5 1
a5 1
 * Copyright (c) 2002 - 2010 Henning Brauer
d150 1
a150 1
void			 pf_change_ap(struct pf_addr *, u_int16_t *,
d152 1
a152 1
			    u_int8_t, sa_family_t, sa_family_t);
d155 2
a156 2
void			 pf_change_a6(struct pf_addr *, u_int16_t *,
			    struct pf_addr *, u_int8_t);
d159 3
a161 4
void			 pf_change_icmp(struct pf_addr *, u_int16_t *,
			    struct pf_addr *, struct pf_addr *, u_int16_t,
			    u_int16_t *, u_int16_t *, u_int16_t *,
			    u_int8_t, sa_family_t);
a214 2
int			 pf_check_proto_cksum(struct mbuf *, int, int,
			    u_int8_t, sa_family_t);
a1664 15
u_int16_t
pf_cksum_fixup(u_int16_t cksum, u_int16_t old, u_int16_t new, u_int8_t udp)
{
	u_int32_t	l;

	if (udp && !cksum)
		return (0x0000);
	l = cksum + old - new;
	l = (l >> 16) + (l & 65535);
	l = l & 65535;
	if (udp && !l)
		return (0xFFFF);
	return (l);
}

d1666 2
a1667 3
pf_change_ap(struct pf_addr *a, u_int16_t *p, u_int16_t *pc,
    struct pf_addr *an, u_int16_t pn, u_int8_t u, sa_family_t af,
    sa_family_t naf)
d1669 4
a1672 5
	struct pf_addr	ao;
	u_int16_t	po;

	PF_ACPY(&ao, a, af);
	if (af == naf)
d1674 2
a1675 72

	if (p == NULL)	/* no port -> done. no cksum to worry about. */
		return;
	po = *p;
	*p = pn;

	switch (af) {
#ifdef INET
	case AF_INET:
		switch (naf) {
		case AF_INET:
			*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
			    ao.addr16[0], an->addr16[0], u),
			    ao.addr16[1], an->addr16[1], u),
			    po, pn, u);
			break;
#ifdef INET6
		case AF_INET6:
			*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
			    ao.addr16[0], an->addr16[0], u),
			    ao.addr16[1], an->addr16[1], u),
			    0,            an->addr16[2], u),
			    0,            an->addr16[3], u),
			    0,            an->addr16[4], u),
			    0,            an->addr16[5], u),
			    0,            an->addr16[6], u),
			    0,            an->addr16[7], u),
			    po, pn, u);
			break;
#endif /* INET6 */
		}
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		switch (naf) {
#ifdef INET
		case AF_INET:
			*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
			    ao.addr16[0], an->addr16[0], u),
			    ao.addr16[1], an->addr16[1], u),
			    ao.addr16[2], 0,             u),
			    ao.addr16[3], 0,             u),
			    ao.addr16[4], 0,             u),
			    ao.addr16[5], 0,             u),
			    ao.addr16[6], 0,             u),
			    ao.addr16[7], 0,             u),
			    po, pn, u);
			break;
#endif /* INET */
		case AF_INET6:
			*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
			    ao.addr16[0], an->addr16[0], u),
			    ao.addr16[1], an->addr16[1], u),
			    ao.addr16[2], an->addr16[2], u),
			    ao.addr16[3], an->addr16[3], u),
			    ao.addr16[4], an->addr16[4], u),
			    ao.addr16[5], an->addr16[5], u),
			    ao.addr16[6], an->addr16[6], u),
			    ao.addr16[7], an->addr16[7], u),
			    po, pn, u);
			break;
		}
		break;
#endif /* INET6 */
	}
d1680 1
a1680 1
pf_change_a(void *a, u_int16_t *c, u_int32_t an, u_int8_t u)
d1682 3
a1684 3
	u_int32_t	ao;

	memcpy(&ao, a, sizeof(ao));
a1685 3
	if (c != NULL)
		*c = pf_cksum_fixup(pf_cksum_fixup(*c, ao / 65536, an / 65536,
		    u), ao % 65536, an % 65536, u);
d1690 1
a1690 1
pf_change_a6(struct pf_addr *a, u_int16_t *c, struct pf_addr *an, u_int8_t u)
d1692 3
a1694 3
	struct pf_addr	ao;

	PF_ACPY(&ao, a, AF_INET6);
a1695 13

	if (c)
		*c = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*c,
		    ao.addr16[0], an->addr16[0], u),
		    ao.addr16[1], an->addr16[1], u),
		    ao.addr16[2], an->addr16[2], u),
		    ao.addr16[3], an->addr16[3], u),
		    ao.addr16[4], an->addr16[4], u),
		    ao.addr16[5], an->addr16[5], u),
		    ao.addr16[6], an->addr16[6], u),
		    ao.addr16[7], an->addr16[7], u);
d1883 2
a1884 3
pf_change_icmp(struct pf_addr *ia, u_int16_t *ip, struct pf_addr *oa,
    struct pf_addr *na, u_int16_t np, u_int16_t *pc, u_int16_t *h2c,
    u_int16_t *ic, u_int8_t u, sa_family_t af)
d1886 3
a1888 1
	struct pf_addr	oia, ooa;
d1890 3
a1892 3
	PF_ACPY(&oia, ia, af);
	if (oa)
		PF_ACPY(&ooa, oa, af);
d1894 1
a1894 15
	/* Change inner protocol port, fix inner protocol checksum. */
	if (ip != NULL) {
		u_int16_t	oip = *ip;
		u_int32_t	opc;

		if (pc != NULL)
			opc = *pc;
		*ip = np;
		if (pc != NULL)
			*pc = pf_cksum_fixup(*pc, oip, *ip, u);
		*ic = pf_cksum_fixup(*ic, oip, *ip, 0);
		if (pc != NULL)
			*ic = pf_cksum_fixup(*ic, opc, *pc, 0);
	}
	/* Change inner ip address, fix inner ip and icmp checksums. */
a1895 4
	switch (af) {
#ifdef INET
	case AF_INET: {
		u_int32_t	 oh2c = *h2c;
a1896 27
		/* XXX just in_cksum() */
		*h2c = pf_cksum_fixup(pf_cksum_fixup(*h2c,
		    oia.addr16[0], ia->addr16[0], 0),
		    oia.addr16[1], ia->addr16[1], 0);
		*ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
		    oia.addr16[0], ia->addr16[0], 0),
		    oia.addr16[1], ia->addr16[1], 0);
		*ic = pf_cksum_fixup(*ic, oh2c, *h2c, 0);
		break;
	}
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*ic,
		    oia.addr16[0], ia->addr16[0], u),
		    oia.addr16[1], ia->addr16[1], u),
		    oia.addr16[2], ia->addr16[2], u),
		    oia.addr16[3], ia->addr16[3], u),
		    oia.addr16[4], ia->addr16[4], u),
		    oia.addr16[5], ia->addr16[5], u),
		    oia.addr16[6], ia->addr16[6], u),
		    oia.addr16[7], ia->addr16[7], u);
		break;
#endif /* INET6 */
	}
d1898 1
a1898 1
	if (oa) {
a1899 15
#ifdef INET6
		if (af == AF_INET6)
			*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(*ic,
			    ooa.addr16[0], oa->addr16[0], u),
			    ooa.addr16[1], oa->addr16[1], u),
			    ooa.addr16[2], oa->addr16[2], u),
			    ooa.addr16[3], oa->addr16[3], u),
			    ooa.addr16[4], oa->addr16[4], u),
			    ooa.addr16[5], oa->addr16[5], u),
			    ooa.addr16[6], oa->addr16[6], u),
			    ooa.addr16[7], oa->addr16[7], u);
#endif /* INET6 */
	}
d1912 4
d1985 4
d2151 6
a2156 22
		if (icmp6->icmp6_type != type) {
			icmp6->icmp6_cksum = pf_cksum_fixup(icmp6->icmp6_cksum,
			    icmp6->icmp6_type, type, 0);
			icmp6->icmp6_type = type;
		}
		if (icmp6->icmp6_code != code) {
			icmp6->icmp6_cksum = pf_cksum_fixup(icmp6->icmp6_cksum,
			    icmp6->icmp6_code, code, 0);
			icmp6->icmp6_code = code;
		}
		if (icmp6->icmp6_mtu != htonl(mtu)) {
			icmp6->icmp6_cksum = pf_cksum_fixup(icmp6->icmp6_cksum,
			    htons(ntohl(icmp6->icmp6_mtu)), htons(mtu), 0);
			/* aligns well with a icmpv4 nextmtu */
			icmp6->icmp6_mtu = htonl(mtu);
		}
		if (ptr >= 0 && icmp6->icmp6_pptr != htonl(ptr)) {
			icmp6->icmp6_cksum = pf_cksum_fixup(icmp6->icmp6_cksum,
			    htons(ntohl(icmp6->icmp6_pptr)), htons(ptr), 0);
			/* icmpv4 pptr is a one most significant byte */
			icmp6->icmp6_pptr = htonl(ptr << 24);
		}
d2245 4
a2248 20
		if (icmp4->icmp_type != type) {
			icmp4->icmp_cksum = pf_cksum_fixup(icmp4->icmp_cksum,
			    icmp4->icmp_type, type, 0);
			icmp4->icmp_type = type;
		}
		if (icmp4->icmp_code != code) {
			icmp4->icmp_cksum = pf_cksum_fixup(icmp4->icmp_cksum,
			    icmp4->icmp_code, code, 0);
			icmp4->icmp_code = code;
		}
		if (icmp4->icmp_nextmtu != htons(mtu)) {
			icmp4->icmp_cksum = pf_cksum_fixup(icmp4->icmp_cksum,
			    icmp4->icmp_nextmtu, htons(mtu), 0);
			icmp4->icmp_nextmtu = htons(mtu);
		}
		if (ptr >= 0 && icmp4->icmp_void != ptr) {
			icmp4->icmp_cksum = pf_cksum_fixup(icmp4->icmp_cksum,
			    htons(icmp4->icmp_pptr), htons(ptr), 0);
			icmp4->icmp_void = htonl(ptr);
		}
d2290 1
a2290 1
					pf_change_a(&sack.start, &th->th_sum,
d2292 2
a2293 2
					    dst->seqdiff), 0);
					pf_change_a(&sack.end, &th->th_sum,
d2295 1
a2295 1
					    dst->seqdiff), 0);
d3365 1
a3365 1
			if (pf_check_proto_cksum(pd->m, pd->off,
d3436 1
a3436 1
			    virtual_type, icmp_dir);
d3445 3
a3447 2
	/* copy back packet headers if we performed NAT operations */
	if (rewrite && pd->hdrlen)
d3449 1
d3545 2
a3546 2
			pf_change_a(&th->th_seq, &th->th_sum,
			    htonl(s->src.seqlo + s->src.seqdiff), 0);
d3683 1
a3683 1
    int icmp_dir)
d3700 2
a3701 2
			pf_change_ap(pd->src, pd->sport, &pd->hdr.tcp->th_sum,
			    saddr, sport, 0, pd->af, pd->naf);
d3706 2
a3707 2
			pf_change_ap(pd->dst, pd->dport, &pd->hdr.tcp->th_sum,
			    daddr, dport, 0, pd->af, pd->naf);
d3715 2
a3716 2
			pf_change_ap(pd->src, pd->sport, &pd->hdr.udp->uh_sum,
			    saddr, sport, 1, pd->af, pd->naf);
d3721 2
a3722 2
			pf_change_ap(pd->dst, pd->dport, &pd->hdr.udp->uh_sum,
			    daddr, dport, 1, pd->af, pd->naf);
d3742 2
a3743 2
				pf_change_a(&pd->src->v4.s_addr, NULL,
				    saddr->v4.s_addr, 0);
d3747 2
a3748 2
				pf_change_a(&pd->dst->v4.s_addr, NULL,
				    daddr->v4.s_addr, 0);
a3755 3
				pd->hdr.icmp->icmp_cksum = pf_cksum_fixup(
				    pd->hdr.icmp->icmp_cksum,
				    pd->hdr.icmp->icmp_id, icmpid, 0);
d3779 1
a3779 2
				pf_change_a6(pd->src,
				    &pd->hdr.icmp6->icmp6_cksum, saddr, 0);
d3783 1
a3783 2
				pf_change_a6(pd->dst,
				    &pd->hdr.icmp6->icmp6_cksum, daddr, 0);
d3795 2
a3796 2
				pf_change_a(&pd->src->v4.s_addr, NULL,
				    saddr->v4.s_addr, 0);
d3800 2
a3801 2
				pf_change_a(&pd->dst->v4.s_addr, NULL,
				    daddr->v4.s_addr, 0);
d3809 1
a3809 1
				pf_change_a6(pd->src, NULL, saddr, 0);
d3813 1
a3813 1
				pf_change_a6(pd->dst, NULL, daddr, 0);
d3864 2
a3865 3
			pf_change_a(&th->th_seq, &th->th_sum, htonl(seq +
			    src->seqdiff), 0);
			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack), 0);
d3915 2
a3916 3
			pf_change_a(&th->th_seq, &th->th_sum, htonl(seq +
			    src->seqdiff), 0);
			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack), 0);
d4422 2
a4423 3
			pf_change_ap(pd->src, pd->sport, pd->pcksum,
			    &nk->addr[sidx], nk->port[sidx],
			    pd->virtual_proto == IPPROTO_UDP, pd->af, nk->af);
d4428 1
d4431 2
a4432 4
			pf_change_ap(pd->dst, pd->dport, pd->pcksum,
			    &nk->addr[didx], nk->port[didx],
			    pd->virtual_proto == IPPROTO_UDP, pd->af, nk->af);
		pd->m->m_pkthdr.rdomain = nk->rdomain;
d4443 1
d4447 2
a4448 1
	if (copyback && pd->hdrlen > 0)
d4450 1
d4512 2
a4513 1
	int		 icmp_dir, iidx, ret, multi;
d4587 2
a4588 2
					pf_change_a(&saddr->v4.s_addr, NULL,
					    nk->addr[sidx].v4.s_addr, 0);
d4592 2
a4593 2
					pf_change_a(&daddr->v4.s_addr, NULL,
					    nk->addr[didx].v4.s_addr, 0);
d4597 1
a4597 7
				if (nk->port[iidx] !=
				    pd->hdr.icmp->icmp_id) {
					pd->hdr.icmp->icmp_cksum =
					    pf_cksum_fixup(
					    pd->hdr.icmp->icmp_cksum,
					     pd->hdr.icmp->icmp_id,
					    nk->port[iidx], 0);
a4598 1
				}
d4602 1
d4617 2
a4618 3
					pf_change_a6(saddr,
					    &pd->hdr.icmp6->icmp6_cksum,
					    &nk->addr[sidx], 0);
d4622 2
a4623 3
					pf_change_a6(daddr,
					    &pd->hdr.icmp6->icmp6_cksum,
					    &nk->addr[didx], 0);
d4634 1
a4646 2
		return (PF_PASS);

a4732 1
			int			 copyback = 0;
d4782 1
a4782 2
				pf_change_a(&th.th_seq, icmpsum,
				    htonl(seq), 0);
d4864 4
a4867 4
					pf_change_icmp(pd2.src, &th.th_sport,
					    daddr, &nk->addr[pd2.sidx],
					    nk->port[pd2.sidx], NULL,
					    ipsum2, icmpsum, 0, pd2.af);
d4877 4
a4880 4
					pf_change_icmp(pd2.dst, &th.th_dport,
					    saddr, &nk->addr[pd2.didx],
					    nk->port[pd2.didx], NULL,
					    ipsum2, icmpsum, 0, pd2.af);
a4905 2

			return (PF_PASS);
d4959 1
a4959 1
					pf_change_ap(pd2.src, &uh.uh_sport,
d4961 2
a4962 2
					    nk->port[sidx], 1, pd->af, nk->af);
					pf_change_ap(pd2.dst, &uh.uh_dport,
d4964 1
a4964 1
					    nk->port[didx], 1, pd->af, nk->af);
d4981 4
a4984 4
					pf_change_icmp(pd2.src, &uh.uh_sport,
					    daddr, &nk->addr[pd2.sidx],
					    nk->port[pd2.sidx], &uh.uh_sum,
					    ipsum2, icmpsum, 1, pd2.af);
d4994 4
a4997 4
					pf_change_icmp(pd2.dst, &uh.uh_dport,
					    saddr, &nk->addr[pd2.didx],
					    nk->port[pd2.didx], &uh.uh_sum,
					    ipsum2, icmpsum, 1, pd2.af);
d5018 1
d5021 1
a5022 1
			return (PF_PASS);
d5104 1
a5104 1
					pf_change_icmp(pd2.src,
d5109 1
a5109 2
					    nk->port[iidx] : 0, NULL,
					    ipsum2, icmpsum, 0, AF_INET);
d5118 3
a5120 3
					pf_change_icmp(pd2.dst, NULL, saddr,
					    &nk->addr[pd2.didx], 0, NULL,
					    ipsum2, icmpsum, 0, AF_INET);
d5128 1
a5129 1
			return (PF_PASS);
d5223 1
a5223 1
					pf_change_icmp(pd2.src,
d5230 1
a5230 2
					    ? nk->port[iidx] : 0, NULL,
					    ipsum2, icmpsum, 0, AF_INET6);
d5239 3
a5241 3
					pf_change_icmp(pd2.dst, NULL, saddr,
					    &nk->addr[pd2.didx], 0, NULL,
					    ipsum2, icmpsum, 0, AF_INET6);
d5246 1
a5246 3
				m_copyback(pd2.m, ipoff2, sizeof(h2_6), &h2_6,
				    M_NOWAIT);
				m_copyback(pd2.m, pd2.off,
d5248 1
a5249 1
			return (PF_PASS);
d5271 3
a5273 3
					pf_change_icmp(pd2.src, NULL, daddr,
					    &nk->addr[pd2.sidx], 0, NULL,
					    ipsum2, icmpsum, 0, pd2.af);
d5282 3
a5284 3
					pf_change_icmp(pd2.dst, NULL, saddr,
					    &nk->addr[pd2.didx], 0, NULL,
					    ipsum2, icmpsum, 0, pd2.af);
d5305 1
a5306 1
			return (PF_PASS);
d5311 4
d5805 1
a5805 1
pf_check_proto_cksum(struct mbuf *m, int off, int len, u_int8_t p,
d5811 5
d5831 3
a5833 1
		flag_ok = flag_out = flag_bad = 0;
d5838 2
a5839 1
	if (m->m_pkthdr.csum_flags & (flag_ok | flag_out))
d5841 4
a5844 5
	if (m->m_pkthdr.csum_flags & flag_bad)
		return (1);
	if (off < sizeof(struct ip) || len < sizeof(struct udphdr))
		return (1);
	if (m->m_pkthdr.len < off + len)
d5846 1
d5851 2
a5852 1
			if (m->m_len < off)
d5854 6
a5859 5
			m->m_data += off;
			m->m_len -= off;
			sum = in_cksum(m, len);
			m->m_data -= off;
			m->m_len += off;
d5861 2
a5862 1
			if (m->m_len < sizeof(struct ip))
d5864 2
a5865 1
			sum = in4_cksum(m, p, off, len);
d5871 2
a5872 1
		if (m->m_len < sizeof(struct ip6_hdr))
d5874 2
a5875 1
		sum = in6_cksum(m, p, off, len);
a5879 1
		m->m_pkthdr.csum_flags |= flag_bad;
d5896 2
d5900 2
a5901 1
	m->m_pkthdr.csum_flags |= flag_ok;
d6735 35
@


1.835
log
@Before pulling the TCP options from the mbuf onto the stack, do an
additional length check in pf_modulate_sack() and pf_normalize_mss().
Overflow cannot happen due to the restricted values in the length
calculation.  As this is not obvious, be better safe than sorry.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.834 2013/06/05 00:56:35 henning Exp $ */
d6529 17
@


1.834
log
@after the pf_test_state folding, in pf_test in the proto switch, the
udp and the default case are 100% identical, tcp does a little more, but
that is easier to add w/ two "if tcp" blocks in the default case, so the
udp and tcp cases die. ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.833 2013/06/04 19:07:59 henning Exp $ */
d2460 2
a2461 2
	if (hlen < TCPOLEN_SACKLEN || !pf_pull_hdr(pd->m, pd->off + sizeof(*th),
	    opts, hlen, NULL, NULL, pd->af))
@


1.833
log
@fold pf_test_state_{tcp,udp,other} into one pf_test_state.
the _icmp variant stays because it is completely different.
factor out the synproxy code into a new pf_synproxy() for readability.
pf_setup_pdesc sets us up with access to ports, cksum etc in a protocol
independent matter, so we don't need many protocol switches here.
tcp and udp were almost identical, the _other case changes significantly -
not too unlikely this fixes a subtle bug or two in that case.
ok ryan benno bluhm mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.832 2013/06/04 19:03:11 henning Exp $ */
a6645 40
	case IPPROTO_TCP: {
		if ((pd.hdr.tcp->th_flags & TH_ACK) && pd.p_len == 0)
			pqid = 1;
		action = pf_normalize_tcp(&pd);
		if (action == PF_DROP)
			goto done;
		action = pf_test_state(&pd, &s, &reason);
		if (action == PF_PASS || action == PF_AFRT) {
#if NPFSYNC > 0
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			pd.pflog |= s->log;
		} else if (s == NULL)
			action = pf_test_rule(&pd, &r, &s, &a, &ruleset);

		if (s) {
			if (s->max_mss)
				pf_normalize_mss(&pd, s->max_mss);
		} else if (r->max_mss)
			pf_normalize_mss(&pd, r->max_mss);

		break;
	}

	case IPPROTO_UDP: {
		action = pf_test_state(&pd, &s, &reason);
		if (action == PF_PASS || action == PF_AFRT) {
#if NPFSYNC > 0
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			pd.pflog |= s->log;
		} else if (s == NULL)
			action = pf_test_rule(&pd, &r, &s, &a, &ruleset);
		break;
	}

d6691 7
d6708 9
@


1.832
log
@add a pointer to the protocol checksum header field to pf_pdesc and set
it up in pf_setup_pdesc(). ok ryan benno mikeb bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.831 2013/06/04 18:58:28 henning Exp $ */
d201 4
a204 4
int			 pf_test_state_tcp(struct pf_pdesc *,
			    struct pf_state **, u_short *);
int			 pf_test_state_udp( struct pf_pdesc *,
			    struct pf_state **);
a209 2
int			 pf_test_state_other( struct pf_pdesc *,
			    struct pf_state **);
d4411 2
a4412 2
int
pf_test_state_tcp(struct pf_pdesc *pd, struct pf_state **state, u_short *reason)
d4414 1
a4414 6
	struct pf_state_key_cmp	 key;
	struct tcphdr		*th = pd->hdr.tcp;
	int			 copyback = 0;
	struct pf_state_peer	*src, *dst;
	struct pf_state_key	*sk;
	int			 action = PF_PASS;
d4416 2
a4417 9
	key.af = pd->af;
	key.proto = IPPROTO_TCP;
	key.rdomain = pd->rdomain;
	PF_ACPY(&key.addr[pd->sidx], pd->src, key.af);
	PF_ACPY(&key.addr[pd->didx], pd->dst, key.af);
	key.port[pd->sidx] = th->th_sport;
	key.port[pd->didx] = th->th_dport;

	STATE_LOOKUP(pd->kif, &key, pd->dir, *state, pd->m);
a4418 11
	if (pd->dir == (*state)->direction) {
		src = &(*state)->src;
		dst = &(*state)->dst;
	} else {
		src = &(*state)->dst;
		dst = &(*state)->src;
	}

	sk = (*state)->key[pd->didx];

	if ((*state)->src.state == PF_TCPS_PROXY_SRC) {
d4448 2
d4502 1
a4502 79

	if (((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN) &&
	    dst->state >= TCPS_FIN_WAIT_2 &&
	    src->state >= TCPS_FIN_WAIT_2) {
		if (pf_status.debug >= LOG_NOTICE) {
			log(LOG_NOTICE, "pf: state reuse ");
			pf_print_state(*state);
			pf_print_flags(th->th_flags);
			addlog("\n");
		}
		/* XXX make sure it's the same direction ?? */
		(*state)->src.state = (*state)->dst.state = TCPS_CLOSED;
		pf_unlink_state(*state);
		*state = NULL;
		return (PF_DROP);
	}

	if ((*state)->state_flags & PFSTATE_SLOPPY) {
		if (pf_tcp_track_sloppy(pd, src, dst, state, reason) == PF_DROP)
			return (PF_DROP);
	} else {
		int	ret;

		if (PF_REVERSED_KEY((*state)->key, pd->af))
			ret = pf_tcp_track_full(pd, dst, src, state,
			    reason, &copyback);
		else
			ret = pf_tcp_track_full(pd, src, dst, state,
			    reason, &copyback);
		if (ret == PF_DROP)
			return (PF_DROP);
	}

	/* translate source/destination address, if necessary */
	if ((*state)->key[PF_SK_WIRE] != (*state)->key[PF_SK_STACK]) {
		struct pf_state_key	*nk;
		int			 afto, sidx, didx;

		if (PF_REVERSED_KEY((*state)->key, pd->af))
			nk = (*state)->key[pd->sidx];
		else
			nk = (*state)->key[pd->didx];

		afto = pd->af != nk->af;
		sidx = afto ? pd->didx : pd->sidx;
		didx = afto ? pd->sidx : pd->didx;

		if (afto || PF_ANEQ(pd->src, &nk->addr[sidx], pd->af) ||
		    nk->port[sidx] != th->th_sport)
			pf_change_ap(pd->src, &th->th_sport, &th->th_sum,
			    &nk->addr[sidx], nk->port[sidx], 0, pd->af, nk->af);

		if (afto || PF_ANEQ(pd->dst, &nk->addr[didx], pd->af) ||
		    pd->rdomain != nk->rdomain)
			pd->destchg = 1;
		if (afto || PF_ANEQ(pd->dst, &nk->addr[didx], pd->af) ||
		    nk->port[didx] != th->th_dport)
			pf_change_ap(pd->dst, &th->th_dport, &th->th_sum,
			    &nk->addr[didx], nk->port[didx], 0, pd->af,
			    nk->af);
		pd->m->m_pkthdr.rdomain = nk->rdomain;

#if INET && INET6
		if (afto) {
			PF_ACPY(&pd->nsaddr, &nk->addr[sidx], nk->af);
			PF_ACPY(&pd->ndaddr, &nk->addr[didx], nk->af);
			pd->naf = nk->af;
			action = PF_AFRT;
		}
#endif /* INET && INET6 */

		copyback = 1;
	}

	/* Copyback sequence modulation or stateful scrub changes if needed */
	if (copyback)
		m_copyback(pd->m, pd->off, sizeof(*th), th, M_NOWAIT);

	return (action);
d4506 1
a4506 1
pf_test_state_udp(struct pf_pdesc *pd, struct pf_state **state)
d4508 2
a4510 2
	struct pf_state_key_cmp	 key;
	struct udphdr		*uh = pd->hdr.udp;
d4514 1
a4514 1
	key.proto = IPPROTO_UDP;
d4518 2
a4519 2
	key.port[pd->sidx] = uh->uh_sport;
	key.port[pd->didx] = uh->uh_dport;
d4531 26
a4556 5
	/* update states */
	if (src->state < PFUDPS_SINGLE)
		src->state = PFUDPS_SINGLE;
	if (dst->state == PFUDPS_SINGLE)
		dst->state = PFUDPS_MULTIPLE;
d4558 41
a4598 6
	/* update expire time */
	(*state)->expire = time_uptime;
	if (src->state == PFUDPS_MULTIPLE && dst->state == PFUDPS_MULTIPLE)
		(*state)->timeout = PFTM_UDP_MULTIPLE;
	else
		(*state)->timeout = PFTM_UDP_SINGLE;
d4615 4
a4618 3
		    nk->port[sidx] != uh->uh_sport)
			pf_change_ap(pd->src, &uh->uh_sport, &uh->uh_sum,
			    &nk->addr[sidx], nk->port[sidx], 1, pd->af, nk->af);
d4624 4
a4627 3
		    nk->port[didx] != uh->uh_dport)
			pf_change_ap(pd->dst, &uh->uh_dport, &uh->uh_sum,
			    &nk->addr[didx], nk->port[didx], 1, pd->af, nk->af);
d4639 1
a4639 1
		m_copyback(pd->m, pd->off, sizeof(*uh), uh, M_NOWAIT);
d4642 3
a5520 105
int
pf_test_state_other(struct pf_pdesc *pd, struct pf_state **state)
{
	struct pf_state_peer	*src, *dst;
	struct pf_state_key_cmp	 key;
	int			 action = PF_PASS;

	key.af = pd->af;
	key.proto = pd->proto;
	key.rdomain = pd->rdomain;
	PF_ACPY(&key.addr[pd->sidx], pd->src, key.af);
	PF_ACPY(&key.addr[pd->didx], pd->dst, key.af);
	key.port[0] = key.port[1] = 0;

	STATE_LOOKUP(pd->kif, &key, pd->dir, *state, pd->m);

	if (pd->dir == (*state)->direction) {
		src = &(*state)->src;
		dst = &(*state)->dst;
	} else {
		src = &(*state)->dst;
		dst = &(*state)->src;
	}

	/* update states */
	if (src->state < PFOTHERS_SINGLE)
		src->state = PFOTHERS_SINGLE;
	if (dst->state == PFOTHERS_SINGLE)
		dst->state = PFOTHERS_MULTIPLE;

	/* update expire time */
	(*state)->expire = time_uptime;
	if (src->state == PFOTHERS_MULTIPLE && dst->state == PFOTHERS_MULTIPLE)
		(*state)->timeout = PFTM_OTHER_MULTIPLE;
	else
		(*state)->timeout = PFTM_OTHER_SINGLE;

	/* translate source/destination address, if necessary */
	if ((*state)->key[PF_SK_WIRE] != (*state)->key[PF_SK_STACK]) {
		struct pf_state_key	*nk;
		int			 afto;

		if (PF_REVERSED_KEY((*state)->key, pd->af))
			nk = (*state)->key[pd->sidx];
		else
			nk = (*state)->key[pd->didx];

		afto = pd->af != nk->af;

		KASSERT(nk);
		KASSERT(pd);
		KASSERT(pd->src);
		KASSERT(pd->dst);

		switch (pd->af) {
#ifdef INET
		case AF_INET:
			if (!afto &&
			    PF_ANEQ(pd->src, &nk->addr[pd->sidx], AF_INET))
				pf_change_a(&pd->src->v4.s_addr, NULL,
				    nk->addr[pd->sidx].v4.s_addr,
				    0);
			if (!afto &&
			    PF_ANEQ(pd->dst, &nk->addr[pd->didx], AF_INET)) {
				pf_change_a(&pd->dst->v4.s_addr, NULL,
				    nk->addr[pd->didx].v4.s_addr,
				    0);
				pd->destchg = 1;
			}
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			if (!afto &&
			    PF_ANEQ(pd->src, &nk->addr[pd->sidx], AF_INET6))
				PF_ACPY(pd->src, &nk->addr[pd->sidx], pd->af);

			if (!afto &&
			    PF_ANEQ(pd->dst, &nk->addr[pd->didx], AF_INET6)) {
				PF_ACPY(pd->dst, &nk->addr[pd->didx], pd->af);
				pd->destchg = 1;
			}
			break;
#endif /* INET6 */
		}
		if (pd->rdomain != nk->rdomain)
			pd->destchg = 1;

#if INET && INET6
		if (afto) {
			PF_ACPY(&pd->nsaddr,
			    &nk->addr[afto ? pd->didx : pd->sidx], nk->af);
			PF_ACPY(&pd->ndaddr,
			    &nk->addr[afto ? pd->sidx : pd->didx], nk->af);
			pd->destchg = 1;
			pd->naf = nk->af;
			action = PF_AFRT;
		}
#endif /* INET && INET6 */

		pd->m->m_pkthdr.rdomain = nk->rdomain;
	}
	return (action);
}

d6652 1
a6652 1
		action = pf_test_state_tcp(&pd, &s, &reason);
d6673 1
a6673 1
		action = pf_test_state_udp(&pd, &s);
d6731 1
a6731 1
		action = pf_test_state_other(&pd, &s);
@


1.831
log
@make pf_change_ap() usable without a port. if the port pointer is NULL,
just return after being done with the address. ok bluhm ryan mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.829 2013/06/03 16:32:00 bluhm Exp $ */
d6568 1
d6586 1
d6598 1
@


1.830
log
@Link pf states and socket inpcbs together more tightly.  The linking
was only done when a packet traveled up the stack from pf to
tcp_input().  Now also link the state and inpcb when the packet is
going down from tcp_output() to pf.  As a consequence, divert-reply
states where the initial SYN does not get an answer, can be handled
more correctly.

This change is part of a larger diff that has been backed out in
2011.  Bring the feature back in small steps to see when bad things
start to happen.

OK henning deraadt
@
text
@d1691 1
a1691 1
	u_int16_t	po = *p;
d1697 3
@


1.829
log
@Update o[sd]port whenever n[sd]port is changed.  This fixes a
regression introduced with pf.c 1.827 and allows us to create icmp
states again.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.828 2013/06/03 01:41:04 henning Exp $ */
d1031 3
d1043 3
d1049 1
a1049 1
	if (dir == PF_OUT)
d1051 2
d6925 6
@


1.828
log
@fix anchor quick with nested anchors. we lost the quick flag as soon as
we stepped into a child anchor.
simplify the logic, get rid of the match flag in the anchor stack, just
use the match variable we already had (and used in a boolean style) to track
the nest level we had a match at. when a child anchor had a match we also
have a match in the current anchor, so update the match level accordingly,
and thus correctly honour the quick flag.
reported by, along with the right idea on how to fix this, by Sean Gallagher
\sean at teletech.com.au/, who also helped testing the fix. ok ryan & benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.827 2013/06/02 23:06:36 henning Exp $ */
d3347 2
a3348 2
			pd->nsport = virtual_id;
			pd->ndport = virtual_type;
d3350 2
a3351 2
			pd->nsport = virtual_type;
			pd->ndport = virtual_id;
d3362 2
a3363 2
			pd->nsport = virtual_id;
			pd->ndport = virtual_type;
d3365 2
a3366 2
			pd->nsport = virtual_type;
			pd->ndport = virtual_id;
@


1.827
log
@set up osport and odport (original src/dst port) in pf_setup_pdesc instead
of late in pf_test_rule - need that for upcoming changes. ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.824 2013/05/10 11:36:24 mikeb Exp $ */
d237 1
a237 1
			    struct pf_rule **, struct pf_rule **, int *);
d2868 1
a2868 1
    struct pf_rule **r, struct pf_rule **a, int *match)
a2871 2
	(*r)->anchor->match = 0;
	*match = 0;
d2884 1
a2884 2
		if ((f->child = RB_MIN(pf_anchor_node, f->parent)) ==
		    NULL) {
a2908 4
			if (f->child->match || *match) {
				f->r->anchor->match = 1;
				*match = 0;
			}
d2923 5
a2927 2
		if (f->r->anchor->match || *match)
			quick = f->r->quick;
d3496 1
a3496 1
				match = 1;
d3510 1
a3510 2
			pf_step_into_anchor(&asd, &ruleset,
			    &r, &a, &match);
@


1.826
log
@pf_step_{into,out_of}_anchor() are only ever called from pf_test_rule()
these days, so:
-move the prototypes from pfvar.h to pf.c
-remove the now useless null point checks for *match, it is always provided
ok ryan
@
text
@a3375 3
	pd->osport = pd->nsport;
	pd->odport = pd->ndport;

d6625 1
a6625 1
		pd->nsport = *pd->sport;
d6627 1
a6627 1
		pd->ndport = *pd->dport;
@


1.825
log
@Pass the correct pointer to pool_put if pf_state_key_attach fails.
Thanks to Brian Poole <pooleb @@ gmail ! com> for noticing this.
@
text
@d236 5
d2873 1
a2873 2
	if (match)
		*match = 0;
d2912 1
a2912 2
			if (f->child->match ||
			    (match != NULL && *match)) {
d2930 1
a2930 1
		if (f->r->anchor->match || (match != NULL && *match))
@


1.824
log
@Since pf_state_key_attach can decide to free the provided state
key we need to sync our state key pointers with whatever values
the function will pick.  Not doing so will produce wrong results
if address translation must be applied afterwards and we happen
to have a state key collision.  Then pf_translate will follow an
old pointer and punch in garbage addresses into the packet.

Noticed, initial patch and tests by Vitaly Sinilin <vs @@ kp4 ! ru>
ok tedu, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.823 2013/05/03 15:33:47 florian Exp $ */
d932 1
a932 1
			pool_put(&pf_state_key_pl, sks);
@


1.823
log
@Export ingress/egress interface index in pflow(4).
Report that this is needed for some netflow collector and tests by
Chris Ivancic & Colin Ligertwood.

OK mikeb@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.822 2013/04/10 08:50:59 mpi Exp $ */
d919 2
a920 2
pf_state_insert(struct pfi_kif *kif, struct pf_state_key *skw,
    struct pf_state_key *sks, struct pf_state *s)
d925 2
a926 2
	if (skw == sks) {
		if (pf_state_key_attach(skw, s, PF_SK_WIRE))
d928 1
d931 1
a931 1
		if (pf_state_key_attach(skw, s, PF_SK_WIRE)) {
d935 2
a936 1
		if (pf_state_key_attach(sks, s, PF_SK_STACK)) {
d940 1
d3795 1
a3795 1
	if (pf_state_insert(BOUND_IFACE(r, pd->kif), *skw, *sks, s)) {
@


1.822
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.821 2013/03/29 13:16:14 bluhm Exp $ */
d7040 6
@


1.821
log
@Declare struct pf_state_key in the mbuf and in_pcb header files to
avoid ugly casts.
OK krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.820 2013/03/28 00:32:11 bluhm Exp $ */
d92 1
a92 1
#include <netinet/in_pcb.h>
a5714 1
	extern int		 ipmultipath;
a5715 1
	extern int		 ip6_multipath;
@


1.820
log
@Unfortunately the satosin, sintosa, ifatoia, satosin6, sin6tosa,
ifatoia6 macros do not check the source type.  They just cast
anything.  Remove needless casts and do not use those macros if the
source type does not match.  Remove duplicate defines.
No binary change.  OK kettenis@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.819 2013/03/11 19:48:40 sthen Exp $ */
d1021 2
a1022 2
	    ((struct pf_state_key *)m->m_pkthdr.pf.statekey)->reverse)
		sk = ((struct pf_state_key *)m->m_pkthdr.pf.statekey)->reverse;
d1030 1
a1030 2
			((struct pf_state_key *)
			    m->m_pkthdr.pf.statekey)->reverse = sk;
@


1.819
log
@Add a separate "translation" counter and use this rather than "memory"
when address translation fails due to no free ports in the configured range.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.818 2013/01/20 22:51:16 bluhm Exp $ */
d5733 1
a5733 1
		dst = satosin(&ro.ro_dst);
d5749 1
a5749 1
		dst6 = (struct sockaddr_in6 *)&ro.ro_dst;
d5814 1
a5814 1
		dst = satosin(&ro.ro_dst);
d5822 1
a5822 1
		dst6 = (struct sockaddr_in6 *)&ro.ro_dst;
@


1.818
log
@Make pf TCP sequence number tracking less strict by one octet for
FIN packets.  The data of a TCP packet must fit into the announced
window, but this is not required for the sequence number of the
FIN.  A packet with the FIN bit set and containing data that fits
exactly into the announced window was blocked.  Our stack generates
such packets when the receive buffer size is set to 1024.  Now pf
uses only the data lenght for window comparison.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.817 2012/11/23 18:35:25 mikeb Exp $ */
d3490 1
a3490 1
					REASON_SET(&reason, PFRES_MEMORY);
d3529 1
a3529 1
		REASON_SET(&reason, PFRES_MEMORY);
@


1.817
log
@make sure to always pass an array of struct pf_src_node pointers to
the pf_map_addr.  doing otherwise leads to the stack corruption.
bug was reported and fix tested by arjan schrijver, thanks!
ok jsing, henning, florian who has also found the same bug in
pf_route and pf_route6 functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.816 2012/11/06 12:32:41 henning Exp $ */
d4016 1
a4016 1
	u_int32_t		 ack, end, seq, orig_seq;
d4079 1
d4110 1
d4157 1
a4157 1
	if (SEQ_GEQ(src->seqhi, end) &&
d4228 1
a4228 1
	    SEQ_GEQ(src->seqhi + MAXACKWINDOW, end) &&
d4318 1
a4318 1
			    SEQ_GEQ(src->seqhi, end) ? ' ' : '1',
d4323 2
a4324 1
			    SEQ_GEQ(src->seqhi + MAXACKWINDOW, end) ?' ' :'5',
@


1.816
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.815 2012/11/01 07:55:56 henning Exp $ */
d3207 1
a3207 1
	struct pf_src_node *sn = NULL;
d3212 1
d3216 1
a3216 1
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL, &sn,
d3224 1
a3224 1
		pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL, &sn,
d3714 2
d5850 1
a5850 1
	struct pf_src_node	*sn = NULL;
d5907 1
d5910 1
a5910 1
			    &naddr, NULL, &sn, &r->route, PF_SN_ROUTE)) {
d6034 1
a6034 1
	struct pf_src_node	*sn = NULL;
d6076 1
d6078 1
a6078 1
		    &naddr, NULL, &sn, &r->route, PF_SN_ROUTE)) {
@


1.815
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.813 2012/10/21 13:06:02 benno Exp $ */
d5 1
a5 1
 * Copyright (c) 2002 - 2012 Henning Brauer <henning@@openbsd.org>
d151 2
a152 2
			    struct pf_addr *, u_int16_t, sa_family_t,
			    sa_family_t);
d155 2
a156 1
void			 pf_change_a6(struct pf_addr *a, struct pf_addr *an);
d161 2
a162 1
			    sa_family_t);
d1655 15
d1671 3
a1673 2
pf_change_ap(struct pf_addr *a, u_int16_t *p, struct pf_addr *an,
    u_int16_t pn, sa_family_t af, sa_family_t naf)
d1675 4
d1681 1
d1683 67
d1754 1
a1754 1
pf_change_a(void *a, u_int32_t an)
d1756 3
d1760 3
d1767 1
a1767 1
pf_change_a6(struct pf_addr *a, struct pf_addr *an)
d1769 3
d1773 13
d1974 2
a1975 1
    struct pf_addr *na, u_int16_t np, sa_family_t af)
d1977 13
a1989 2
	/* Change inner protocol port */
	if (ip != NULL)
d1991 7
a1997 2

	/* Change inner ip address */
d1999 4
d2004 27
d2032 1
a2032 1
	if (oa)
d2034 15
d2292 22
a2313 6
		icmp6->icmp6_type = type;
		icmp6->icmp6_code = code;
		/* aligns well with a icmpv4 nextmtu */
		icmp6->icmp6_mtu = htonl(mtu);
		/* icmpv4 pptr is a one most significant byte */
		icmp6->icmp6_pptr = htonl(ptr << 24);
d2402 20
a2421 4
		icmp4->icmp_type = type;
		icmp4->icmp_code = code;
		icmp4->icmp_nextmtu = htons(mtu);
		icmp4->icmp_void = htonl(ptr);
d2463 1
a2463 1
					pf_change_a(&sack.start,
d2465 2
a2466 2
					    dst->seqdiff));
					pf_change_a(&sack.end,
d2468 1
a2468 1
					    dst->seqdiff));
d3618 1
a3618 1
			    virtual_type, icmp_dir, pd->m);
d3627 2
a3628 3
	/* copy back packet headers if needed */
	if (rewrite && pd->hdrlen) {
		pf_cksum(pd, pd->m);
a3629 1
	}
d3723 2
a3724 2
			pf_change_a(&th->th_seq,
			    htonl(s->src.seqlo + s->src.seqdiff));
d3861 1
a3861 1
    int icmp_dir, struct mbuf *m)
d3878 2
a3879 2
			pf_change_ap(pd->src, pd->sport, saddr, sport, pd->af,
			    pd->naf);
d3884 2
a3885 2
			pf_change_ap(pd->dst, pd->dport, daddr, dport, pd->af,
			    pd->naf);
d3893 2
a3894 2
			pf_change_ap(pd->src, pd->sport, saddr, sport, pd->af,
			    pd->naf);
d3899 2
a3900 2
			pf_change_ap(pd->dst, pd->dport, daddr, dport, pd->af,
			    pd->naf);
d3920 2
a3921 2
				pf_change_a(&pd->src->v4.s_addr,
				    saddr->v4.s_addr);
d3925 2
a3926 2
				pf_change_a(&pd->dst->v4.s_addr,
				    daddr->v4.s_addr);
d3934 3
d3960 2
a3961 1
				pf_change_a6(pd->src, saddr);
d3965 2
a3966 1
				pf_change_a6(pd->dst, daddr);
d3978 2
a3979 2
				pf_change_a(&pd->src->v4.s_addr,
				    saddr->v4.s_addr);
d3983 2
a3984 2
				pf_change_a(&pd->dst->v4.s_addr,
				    daddr->v4.s_addr);
d3992 1
a3992 1
				pf_change_a6(pd->src, saddr);
d3996 1
a3996 1
				pf_change_a6(pd->dst, daddr);
d4047 3
a4049 2
			pf_change_a(&th->th_seq, htonl(seq + src->seqdiff));
			pf_change_a(&th->th_ack, htonl(ack));
d4098 3
a4100 2
			pf_change_a(&th->th_seq, htonl(seq + src->seqdiff));
			pf_change_a(&th->th_ack, htonl(ack));
d4560 2
a4561 2
			pf_change_ap(pd->src, &th->th_sport,
			    &nk->addr[sidx], nk->port[sidx], pd->af, nk->af);
d4564 3
d4568 3
a4570 3
			pf_change_ap(pd->dst, &th->th_dport,
			    &nk->addr[didx], nk->port[didx], pd->af, nk->af);

d4586 1
a4586 2
	if (copyback) {
		pf_cksum(pd, pd->m);
d4588 1
a4588 1
	}
d4647 2
a4648 2
			pf_change_ap(pd->src, &uh->uh_sport,
			    &nk->addr[sidx], nk->port[sidx], pd->af, nk->af);
a4652 1

d4655 3
a4657 2
			pf_change_ap(pd->dst, &uh->uh_dport,
			    &nk->addr[didx], nk->port[didx], pd->af, nk->af);
a4667 2
		pd->m->m_pkthdr.rdomain = nk->rdomain;
		pf_cksum(pd, pd->m);
d4731 1
a4731 2
	int		 icmp_dir, iidx, ret, multi, copyback = 0;

d4805 2
a4806 2
					pf_change_a(&saddr->v4.s_addr,
					    nk->addr[sidx].v4.s_addr);
d4810 2
a4811 2
					pf_change_a(&daddr->v4.s_addr,
					    nk->addr[didx].v4.s_addr);
d4815 7
a4821 1
				if (nk->port[iidx] !=  pd->hdr.icmp->icmp_id)
d4823 1
a4826 1
				copyback = 1;
d4842 2
a4843 1
					    &nk->addr[sidx]);
d4848 2
a4849 1
					    &nk->addr[didx]);
a4859 1
				copyback = 1;
d4872 2
d4960 1
d5010 2
a5011 1
				pf_change_a(&th.th_seq, htonl(seq));
d5095 2
a5096 1
					    nk->port[pd2.sidx], pd2.af);
d5108 2
a5109 1
					    nk->port[pd2.didx], pd2.af);
d5135 2
d5190 1
a5190 1
					pf_change_ap(pd2.src,
d5192 2
a5193 2
					    nk->port[sidx], pd->af, nk->af);
					pf_change_ap(pd2.dst,
d5195 1
a5195 1
					    nk->port[didx], pd->af, nk->af);
d5214 2
a5215 1
					    nk->port[pd2.sidx], pd2.af);
d5227 2
a5228 1
					    nk->port[pd2.didx], pd2.af);
a5248 1
				uh.uh_sum = 0;
a5250 1
				copyback = 1;
d5252 1
d5339 2
a5340 1
					    nk->port[iidx] : 0, AF_INET);
d5350 2
a5351 1
					    &nk->addr[pd2.didx], 0, AF_INET);
a5358 1
				copyback = 1;
d5360 1
d5461 2
a5462 1
					    ? nk->port[iidx] : 0, AF_INET6);
d5472 2
a5473 1
					    &nk->addr[pd2.didx], 0, AF_INET6);
d5478 3
a5480 1
				m_copyback(pd->m, pd2.off,
a5481 1
				copyback = 1;
d5483 1
d5506 2
a5507 1
					    &nk->addr[pd2.sidx], 0, pd2.af);
d5517 2
a5518 1
					    &nk->addr[pd2.didx], 0, pd2.af);
a5538 1
				copyback = 1;
d5540 1
a5544 4
	if (copyback)
		pf_cksum(pd, pd->m);

	return (PF_PASS);
d5606 3
a5608 2
				pf_change_a(&pd->src->v4.s_addr,
				    nk->addr[pd->sidx].v4.s_addr);
d5611 3
a5613 2
				pf_change_a(&pd->dst->v4.s_addr,
				    nk->addr[pd->didx].v4.s_addr);
a7045 32
}

void
pf_cksum(struct pf_pdesc *pd, struct mbuf *m)
{
	switch (pd->proto) {
	case IPPROTO_TCP:
		pd->hdr.tcp->th_sum = 0;
		if (pd->af == AF_INET) {
			pd->hdr.tcp->th_sum = in_cksum_phdr(pd->src->v4.s_addr,
			    pd->dst->v4.s_addr, htons(pd->tot_len -
			    pd->off + IPPROTO_TCP));
		}
		m->m_pkthdr.csum_flags |= M_TCP_CSUM_OUT;
		break;
	case IPPROTO_UDP:
		pd->hdr.udp->uh_sum = 0;
		if (pd->af == AF_INET) {
			pd->hdr.udp->uh_sum = in_cksum_phdr(pd->src->v4.s_addr,
			    pd->dst->v4.s_addr, htons(pd->tot_len -
			    pd->off + IPPROTO_UDP));
		}
		m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;
		break;
	case IPPROTO_ICMP:
	case IPPROTO_ICMPV6:
		m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;
		break;
	default:
		/* nothing */
		break;
	}
@


1.814
log
@Use time_uptime for expiration values as time_second can be skewed at
runtime while time_uptime is monotonic. Prevent underflows in
pfsync(4) and pflow(4) by using signed variables.  pfsync(4) problem
pointed out by camield.

Diff originally by dlg, frag and pflow bits by me.

feedback dlg
man page tweak jmc

Various versions of the pflow bits tested by Hrvoje Popovski
(hrvoje AT srce DOT hr), thanks!

ok benno, henning, dlg
@
text
@d5 1
a5 1
 * Copyright (c) 2002 - 2010 Henning Brauer
d151 2
a152 2
			    u_int16_t *, struct pf_addr *, u_int16_t,
			    u_int8_t, sa_family_t, sa_family_t);
d155 1
a155 2
void			 pf_change_a6(struct pf_addr *, u_int16_t *,
			    struct pf_addr *, u_int8_t);
d160 1
a160 2
			    u_int16_t *, u_int16_t *, u_int16_t *,
			    u_int8_t, sa_family_t);
a1652 15
u_int16_t
pf_cksum_fixup(u_int16_t cksum, u_int16_t old, u_int16_t new, u_int8_t udp)
{
	u_int32_t	l;

	if (udp && !cksum)
		return (0x0000);
	l = cksum + old - new;
	l = (l >> 16) + (l & 65535);
	l = l & 65535;
	if (udp && !l)
		return (0xFFFF);
	return (l);
}

d1654 2
a1655 3
pf_change_ap(struct pf_addr *a, u_int16_t *p, u_int16_t *pc,
    struct pf_addr *an, u_int16_t pn, u_int8_t u, sa_family_t af,
    sa_family_t naf)
a1656 4
	struct pf_addr	ao;
	u_int16_t	po = *p;

	PF_ACPY(&ao, a, af);
a1658 1

a1659 67

	switch (af) {
#ifdef INET
	case AF_INET:
		switch (naf) {
		case AF_INET:
			*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
			    ao.addr16[0], an->addr16[0], u),
			    ao.addr16[1], an->addr16[1], u),
			    po, pn, u);
			break;
#ifdef INET6
		case AF_INET6:
			*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
			    ao.addr16[0], an->addr16[0], u),
			    ao.addr16[1], an->addr16[1], u),
			    0,            an->addr16[2], u),
			    0,            an->addr16[3], u),
			    0,            an->addr16[4], u),
			    0,            an->addr16[5], u),
			    0,            an->addr16[6], u),
			    0,            an->addr16[7], u),
			    po, pn, u);
			break;
#endif /* INET6 */
		}
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		switch (naf) {
#ifdef INET
		case AF_INET:
			*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
			    ao.addr16[0], an->addr16[0], u),
			    ao.addr16[1], an->addr16[1], u),
			    ao.addr16[2], 0,             u),
			    ao.addr16[3], 0,             u),
			    ao.addr16[4], 0,             u),
			    ao.addr16[5], 0,             u),
			    ao.addr16[6], 0,             u),
			    ao.addr16[7], 0,             u),
			    po, pn, u);
			break;
#endif /* INET */
		case AF_INET6:
			*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
			    ao.addr16[0], an->addr16[0], u),
			    ao.addr16[1], an->addr16[1], u),
			    ao.addr16[2], an->addr16[2], u),
			    ao.addr16[3], an->addr16[3], u),
			    ao.addr16[4], an->addr16[4], u),
			    ao.addr16[5], an->addr16[5], u),
			    ao.addr16[6], an->addr16[6], u),
			    ao.addr16[7], an->addr16[7], u),
			    po, pn, u);
			break;
		}
		break;
#endif /* INET6 */
	}
d1664 1
a1664 1
pf_change_a(void *a, u_int16_t *c, u_int32_t an, u_int8_t u)
a1665 3
	u_int32_t	ao;

	memcpy(&ao, a, sizeof(ao));
a1666 3
	if (c != NULL)
		*c = pf_cksum_fixup(pf_cksum_fixup(*c, ao / 65536, an / 65536,
		    u), ao % 65536, an % 65536, u);
d1671 1
a1671 1
pf_change_a6(struct pf_addr *a, u_int16_t *c, struct pf_addr *an, u_int8_t u)
a1672 3
	struct pf_addr	ao;

	PF_ACPY(&ao, a, AF_INET6);
a1673 13

	if (c)
		*c = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*c,
		    ao.addr16[0], an->addr16[0], u),
		    ao.addr16[1], an->addr16[1], u),
		    ao.addr16[2], an->addr16[2], u),
		    ao.addr16[3], an->addr16[3], u),
		    ao.addr16[4], an->addr16[4], u),
		    ao.addr16[5], an->addr16[5], u),
		    ao.addr16[6], an->addr16[6], u),
		    ao.addr16[7], an->addr16[7], u);
d1862 1
a1862 2
    struct pf_addr *na, u_int16_t np, u_int16_t *pc, u_int16_t *h2c,
    u_int16_t *ic, u_int8_t u, sa_family_t af)
d1864 3
a1866 10
	struct pf_addr	oia, ooa;

	PF_ACPY(&oia, ia, af);
	if (oa)
		PF_ACPY(&ooa, oa, af);

	/* Change inner protocol port, fix inner protocol checksum. */
	if (ip != NULL) {
		u_int16_t	oip = *ip;
		u_int32_t	opc;
d1868 1
a1868 10
		if (pc != NULL)
			opc = *pc;
		*ip = np;
		if (pc != NULL)
			*pc = pf_cksum_fixup(*pc, oip, *ip, u);
		*ic = pf_cksum_fixup(*ic, oip, *ip, 0);
		if (pc != NULL)
			*ic = pf_cksum_fixup(*ic, opc, *pc, 0);
	}
	/* Change inner ip address, fix inner ip and icmp checksums. */
a1869 4
	switch (af) {
#ifdef INET
	case AF_INET: {
		u_int32_t	 oh2c = *h2c;
a1870 27
		/* XXX just in_cksum() */
		*h2c = pf_cksum_fixup(pf_cksum_fixup(*h2c,
		    oia.addr16[0], ia->addr16[0], 0),
		    oia.addr16[1], ia->addr16[1], 0);
		*ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
		    oia.addr16[0], ia->addr16[0], 0),
		    oia.addr16[1], ia->addr16[1], 0);
		*ic = pf_cksum_fixup(*ic, oh2c, *h2c, 0);
		break;
	}
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*ic,
		    oia.addr16[0], ia->addr16[0], u),
		    oia.addr16[1], ia->addr16[1], u),
		    oia.addr16[2], ia->addr16[2], u),
		    oia.addr16[3], ia->addr16[3], u),
		    oia.addr16[4], ia->addr16[4], u),
		    oia.addr16[5], ia->addr16[5], u),
		    oia.addr16[6], ia->addr16[6], u),
		    oia.addr16[7], ia->addr16[7], u);
		break;
#endif /* INET6 */
	}
d1872 1
a1872 1
	if (oa) {
a1873 15
#ifdef INET6
		if (af == AF_INET6)
			*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(*ic,
			    ooa.addr16[0], oa->addr16[0], u),
			    ooa.addr16[1], oa->addr16[1], u),
			    ooa.addr16[2], oa->addr16[2], u),
			    ooa.addr16[3], oa->addr16[3], u),
			    ooa.addr16[4], oa->addr16[4], u),
			    ooa.addr16[5], oa->addr16[5], u),
			    ooa.addr16[6], oa->addr16[6], u),
			    ooa.addr16[7], oa->addr16[7], u);
#endif /* INET6 */
	}
d2117 6
a2122 22
		if (icmp6->icmp6_type != type) {
			icmp6->icmp6_cksum = pf_cksum_fixup(icmp6->icmp6_cksum,
			    icmp6->icmp6_type, type, 0);
			icmp6->icmp6_type = type;
		}
		if (icmp6->icmp6_code != code) {
			icmp6->icmp6_cksum = pf_cksum_fixup(icmp6->icmp6_cksum,
			    icmp6->icmp6_code, code, 0);
			icmp6->icmp6_code = code;
		}
		if (icmp6->icmp6_mtu != htonl(mtu)) {
			icmp6->icmp6_cksum = pf_cksum_fixup(icmp6->icmp6_cksum,
			    htons(ntohl(icmp6->icmp6_mtu)), htons(mtu), 0);
			/* aligns well with a icmpv4 nextmtu */
			icmp6->icmp6_mtu = htonl(mtu);
		}
		if (ptr >= 0 && icmp6->icmp6_pptr != htonl(ptr)) {
			icmp6->icmp6_cksum = pf_cksum_fixup(icmp6->icmp6_cksum,
			    htons(ntohl(icmp6->icmp6_pptr)), htons(ptr), 0);
			/* icmpv4 pptr is a one most significant byte */
			icmp6->icmp6_pptr = htonl(ptr << 24);
		}
d2211 4
a2214 20
		if (icmp4->icmp_type != type) {
			icmp4->icmp_cksum = pf_cksum_fixup(icmp4->icmp_cksum,
			    icmp4->icmp_type, type, 0);
			icmp4->icmp_type = type;
		}
		if (icmp4->icmp_code != code) {
			icmp4->icmp_cksum = pf_cksum_fixup(icmp4->icmp_cksum,
			    icmp4->icmp_code, code, 0);
			icmp4->icmp_code = code;
		}
		if (icmp4->icmp_nextmtu != htons(mtu)) {
			icmp4->icmp_cksum = pf_cksum_fixup(icmp4->icmp_cksum,
			    icmp4->icmp_nextmtu, htons(mtu), 0);
			icmp4->icmp_nextmtu = htons(mtu);
		}
		if (ptr >= 0 && icmp4->icmp_void != ptr) {
			icmp4->icmp_cksum = pf_cksum_fixup(icmp4->icmp_cksum,
			    htons(icmp4->icmp_pptr), htons(ptr), 0);
			icmp4->icmp_void = htonl(ptr);
		}
d2256 1
a2256 1
					pf_change_a(&sack.start, &th->th_sum,
d2258 2
a2259 2
					    dst->seqdiff), 0);
					pf_change_a(&sack.end, &th->th_sum,
d2261 1
a2261 1
					    dst->seqdiff), 0);
d3411 1
a3411 1
			    virtual_type, icmp_dir);
d3420 3
a3422 2
	/* copy back packet headers if we performed NAT operations */
	if (rewrite && pd->hdrlen)
d3424 1
d3518 2
a3519 2
			pf_change_a(&th->th_seq, &th->th_sum,
			    htonl(s->src.seqlo + s->src.seqdiff), 0);
d3656 1
a3656 1
    int icmp_dir)
d3673 2
a3674 2
			pf_change_ap(pd->src, pd->sport, &pd->hdr.tcp->th_sum,
			    saddr, sport, 0, pd->af, pd->naf);
d3679 2
a3680 2
			pf_change_ap(pd->dst, pd->dport, &pd->hdr.tcp->th_sum,
			    daddr, dport, 0, pd->af, pd->naf);
d3688 2
a3689 2
			pf_change_ap(pd->src, pd->sport, &pd->hdr.udp->uh_sum,
			    saddr, sport, 1, pd->af, pd->naf);
d3694 2
a3695 2
			pf_change_ap(pd->dst, pd->dport, &pd->hdr.udp->uh_sum,
			    daddr, dport, 1, pd->af, pd->naf);
d3715 2
a3716 2
				pf_change_a(&pd->src->v4.s_addr, NULL,
				    saddr->v4.s_addr, 0);
d3720 2
a3721 2
				pf_change_a(&pd->dst->v4.s_addr, NULL,
				    daddr->v4.s_addr, 0);
a3728 3
				pd->hdr.icmp->icmp_cksum = pf_cksum_fixup(
				    pd->hdr.icmp->icmp_cksum,
				    pd->hdr.icmp->icmp_id, icmpid, 0);
d3752 1
a3752 2
				pf_change_a6(pd->src,
				    &pd->hdr.icmp6->icmp6_cksum, saddr, 0);
d3756 1
a3756 2
				pf_change_a6(pd->dst,
				    &pd->hdr.icmp6->icmp6_cksum, daddr, 0);
d3768 2
a3769 2
				pf_change_a(&pd->src->v4.s_addr, NULL,
				    saddr->v4.s_addr, 0);
d3773 2
a3774 2
				pf_change_a(&pd->dst->v4.s_addr, NULL,
				    daddr->v4.s_addr, 0);
d3782 1
a3782 1
				pf_change_a6(pd->src, NULL, saddr, 0);
d3786 1
a3786 1
				pf_change_a6(pd->dst, NULL, daddr, 0);
d3837 2
a3838 3
			pf_change_a(&th->th_seq, &th->th_sum, htonl(seq +
			    src->seqdiff), 0);
			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack), 0);
d3887 2
a3888 3
			pf_change_a(&th->th_seq, &th->th_sum, htonl(seq +
			    src->seqdiff), 0);
			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack), 0);
d4348 2
a4349 2
			pf_change_ap(pd->src, &th->th_sport, &th->th_sum,
			    &nk->addr[sidx], nk->port[sidx], 0, pd->af, nk->af);
a4351 3
		    pd->rdomain != nk->rdomain)
			pd->destchg = 1;
		if (afto || PF_ANEQ(pd->dst, &nk->addr[didx], pd->af) ||
d4353 3
a4355 3
			pf_change_ap(pd->dst, &th->th_dport, &th->th_sum,
			    &nk->addr[didx], nk->port[didx], 0, pd->af,
			    nk->af);
d4371 2
a4372 1
	if (copyback)
d4374 1
a4374 1

d4433 2
a4434 2
			pf_change_ap(pd->src, &uh->uh_sport, &uh->uh_sum,
			    &nk->addr[sidx], nk->port[sidx], 1, pd->af, nk->af);
d4439 1
d4442 2
a4443 3
			pf_change_ap(pd->dst, &uh->uh_dport, &uh->uh_sum,
			    &nk->addr[didx], nk->port[didx], 1, pd->af, nk->af);
		pd->m->m_pkthdr.rdomain = nk->rdomain;
d4454 2
d4519 2
a4520 1
	int		 icmp_dir, iidx, ret, multi;
d4594 2
a4595 2
					pf_change_a(&saddr->v4.s_addr, NULL,
					    nk->addr[sidx].v4.s_addr, 0);
d4599 2
a4600 2
					pf_change_a(&daddr->v4.s_addr, NULL,
					    nk->addr[didx].v4.s_addr, 0);
d4604 1
a4604 7
				if (nk->port[iidx] !=
				    pd->hdr.icmp->icmp_id) {
					pd->hdr.icmp->icmp_cksum =
					    pf_cksum_fixup(
					    pd->hdr.icmp->icmp_cksum,
					     pd->hdr.icmp->icmp_id,
					    nk->port[iidx], 0);
a4605 1
				}
d4609 1
d4625 1
a4625 2
					    &pd->hdr.icmp6->icmp6_cksum,
					    &nk->addr[sidx], 0);
d4630 1
a4630 2
					    &pd->hdr.icmp6->icmp6_cksum,
					    &nk->addr[didx], 0);
d4641 1
a4653 2
		return (PF_PASS);

a4739 1
			int			 copyback = 0;
d4789 1
a4789 2
				pf_change_a(&th.th_seq, icmpsum,
				    htonl(seq), 0);
d4873 1
a4873 2
					    nk->port[pd2.sidx], NULL,
					    ipsum2, icmpsum, 0, pd2.af);
d4885 1
a4885 2
					    nk->port[pd2.didx], NULL,
					    ipsum2, icmpsum, 0, pd2.af);
a4910 2

			return (PF_PASS);
d4964 1
a4964 1
					pf_change_ap(pd2.src, &uh.uh_sport,
d4966 2
a4967 2
					    nk->port[sidx], 1, pd->af, nk->af);
					pf_change_ap(pd2.dst, &uh.uh_dport,
d4969 1
a4969 1
					    nk->port[didx], 1, pd->af, nk->af);
d4988 1
a4988 2
					    nk->port[pd2.sidx], &uh.uh_sum,
					    ipsum2, icmpsum, 1, pd2.af);
d5000 1
a5000 2
					    nk->port[pd2.didx], &uh.uh_sum,
					    ipsum2, icmpsum, 1, pd2.af);
d5021 1
d5024 1
a5025 1
			return (PF_PASS);
d5112 1
a5112 2
					    nk->port[iidx] : 0, NULL,
					    ipsum2, icmpsum, 0, AF_INET);
d5122 1
a5122 2
					    &nk->addr[pd2.didx], 0, NULL,
					    ipsum2, icmpsum, 0, AF_INET);
d5130 1
a5131 1
			return (PF_PASS);
d5232 1
a5232 2
					    ? nk->port[iidx] : 0, NULL,
					    ipsum2, icmpsum, 0, AF_INET6);
d5242 1
a5242 2
					    &nk->addr[pd2.didx], 0, NULL,
					    ipsum2, icmpsum, 0, AF_INET6);
d5247 1
a5247 3
				m_copyback(pd2.m, ipoff2, sizeof(h2_6), &h2_6,
				    M_NOWAIT);
				m_copyback(pd2.m, pd2.off,
d5249 1
a5250 1
			return (PF_PASS);
d5273 1
a5273 2
					    &nk->addr[pd2.sidx], 0, NULL,
					    ipsum2, icmpsum, 0, pd2.af);
d5283 1
a5283 2
					    &nk->addr[pd2.didx], 0, NULL,
					    ipsum2, icmpsum, 0, pd2.af);
d5304 1
a5305 1
			return (PF_PASS);
d5310 4
d5375 2
a5376 3
				pf_change_a(&pd->src->v4.s_addr, NULL,
				    nk->addr[pd->sidx].v4.s_addr,
				    0);
d5379 2
a5380 3
				pf_change_a(&pd->dst->v4.s_addr, NULL,
				    nk->addr[pd->didx].v4.s_addr,
				    0);
d6813 32
@


1.813
log
@Add the IP_DIVERTFL socket option on divert(4) sockets to control
which packets (as in direction) of the traffic will be diverted
through the divert socket.
ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.812 2012/09/19 12:35:07 blambert Exp $ */
d392 1
a392 1
	threshold->last = time_second;
d398 1
a398 1
	u_int32_t t = time_second, diff = t - threshold->last;
d585 1
a585 1
	if (sn->states > 0 || sn->expire > time_second)
d1083 2
d1109 2
a1110 2
	sp->expire = pf_state_expires(st);
	if (sp->expire <= time_second)
d1113 1
a1113 1
		sp->expire = htonl(sp->expire - time_second);
d1174 1
a1174 1
u_int32_t
d1177 1
a1177 1
	u_int32_t	timeout;
d1184 2
a1185 1
		return (time_second);
d1188 1
d1192 1
d1203 4
a1206 5
		if (states < end)
			return (state->expire + timeout * (end - states) /
			    (end - start));
		else
			return (time_second);
d1208 1
d1221 1
a1221 1
		if (cur->states <= 0 && cur->expire <= time_second) {
d1251 1
a1251 1
			sni->sn->expire = time_second + timeout;
d1351 1
a1351 1
		} else if (pf_state_expires(cur) <= time_second) {
d3766 1
a3766 1
	s->expire = time_second;
d4203 1
a4203 1
		(*state)->expire = time_second;
d4380 1
a4380 1
	(*state)->expire = time_second;
d4625 1
a4625 1
	(*state)->expire = time_second;
d4770 1
a4770 1
		(*state)->expire = time_second;
d5578 1
a5578 1
	(*state)->expire = time_second;
@


1.812
log
@More radix internals pushdown; place rn_mpath_next, which accepts and
returns radix_node pointers, inside a new rt_mpath_next, which accepts
and returns rtentry pointers, and start using that instead.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.811 2012/09/18 10:11:53 henning Exp $ */
d6976 2
a6977 1
			divert_packet(pd.m, pd.dir);
d6981 2
a6982 1
			divert6_packet(pd.m, pd.dir);
a6985 1
		*m0 = NULL;
@


1.811
log
@prio 0 is valid, therefore, I chose an "impossible" value for prio meaning
"not set" and used a PF_PRIO_NOTSET define for it. now that means that
everything that creates a struct pf_rule doesn't get away with bzero'ing it,
which turned out to be not so nice. so get rid of PF_PRIO_NOTSET, instead,
make a rule+state flag PFSTATE_SETPRIO which indicates wether the prio
should be set. ok benno claudio mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.809 2012/07/26 12:25:31 mikeb Exp $ */
a5712 1
	struct radix_node	*rn;
d5766 1
a5766 1
		rn = (struct radix_node *)ro.ro_rt;
a5767 1
			rt = (struct rtentry *)rn;
d5775 2
a5776 2
			rn = rn_mpath_next(rn, 0);
		} while (check_mpath == 1 && rn != NULL && ret == 0);
@


1.810
log
@Sloppy state tracking renders ICMP direction check useless
and harmful as we might see only half of the connection in
the asymmetric setups but ignore the state match.  The bug
was reported and fix was verified by Insan Praja <insan ()
ims-solusi ! com>.  Thanks!  OK mcbride, henning
@
text
@d2527 1
a2527 1
	if (r && r->set_prio[0] != PF_PRIO_NOTSET)
d2651 1
a2651 1
	if (r && r->set_prio[0] != PF_PRIO_NOTSET)
d3280 3
a3282 5
	    PFSTATE_SETTOS|PFSTATE_SCRUB_TCP));
	if (r->set_prio[0] != PF_PRIO_NOTSET)
		a->set_prio[0] = r->set_prio[0];
	if (r->set_prio[1] != PF_PRIO_NOTSET)
		a->set_prio[1] = r->set_prio[1];
a3317 1
	act.set_prio[0] = act.set_prio[1] = PF_PRIO_NOTSET;
d6887 1
a6887 1
				if (s->set_prio[1] != PF_PRIO_NOTSET)
d6891 1
a6891 1
				if (s->set_prio[0] != PF_PRIO_NOTSET)
d6899 1
a6899 1
				if (r->set_prio[1] != PF_PRIO_NOTSET)
d6903 1
a6903 1
				if (r->set_prio[0] != PF_PRIO_NOTSET)
@


1.809
log
@rename all_state_flags to state_flags to finish the transition
to the 16 bit flags;  reminded by claudio, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.808 2012/07/10 17:33:48 bluhm Exp $ */
d4697 3
@


1.808
log
@With address family translation, the ip length of the quoted ip
packet within the icmp error packet was wrong.  Fix this by using
the pd2.tot_len of the inner packet and substract the old header's
length.
OK mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.807 2012/07/07 16:24:32 henning Exp $ */
d1116 1
a1116 3
	/* XXX replace state_flags post 5.0 */
	sp->state_flags = st->state_flags;
	sp->all_state_flags = htons(st->state_flags);
@


1.807
log
@rename prio in struct pf_rule and related structs to set_prio so it is
utterly clear this is not a filter criteria but a packet modification thing.
also preparation for upcoming changes, including one to unscrew this mess
(I should not have to touch half the tree for this - ifixitlater)
not user visible, ok gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.805 2012/05/12 13:08:48 mpf Exp $ */
a2138 2
	/* data lenght */
	mlen = m->m_pkthdr.len - pd2->off;
d2154 1
a2154 1
		ip4->ip_len = htons(sizeof(*ip4) + mlen);
d2170 1
a2170 1
		ip6->ip6_plen = htons(mlen);
d4921 1
d4942 2
@


1.806
log
@initialize 'reason' variable before passing it to the pflog_packet;
from david hill;  ok henning
@
text
@d2531 2
a2532 2
	if (r && r->prio[0] != PF_PRIO_NOTSET)
		m->m_pkthdr.pf.prio = r->prio[0];
d2655 2
a2656 2
	if (r && r->prio[0] != PF_PRIO_NOTSET)
		m0->m_pkthdr.pf.prio = r->prio[0];
d3285 4
a3288 4
	if (r->prio[0] != PF_PRIO_NOTSET)
		a->prio[0] = r->prio[0];
	if (r->prio[1] != PF_PRIO_NOTSET)
		a->prio[1] = r->prio[1];
d3324 1
a3324 1
	act.prio[0] = act.prio[1] = PF_PRIO_NOTSET;
d3713 2
a3714 2
	s->prio[0] = act->prio[0];
	s->prio[1] = act->prio[1];
d6888 2
a6889 2
				if (s->prio[1] != PF_PRIO_NOTSET)
					 pd.m->m_pkthdr.pf.prio = s->prio[1];
d6892 2
a6893 2
				if (s->prio[0] != PF_PRIO_NOTSET)
					 pd.m->m_pkthdr.pf.prio = s->prio[0];
d6900 2
a6901 2
				if (r->prio[1] != PF_PRIO_NOTSET)
					 pd.m->m_pkthdr.pf.prio = r->prio[1];
d6904 2
a6905 2
				if (r->prio[0] != PF_PRIO_NOTSET)
					 pd.m->m_pkthdr.pf.prio = r->prio[0];
@


1.805
log
@Ignore/preserve ECN bits on ToS matching and scrubbing.
The lower 2 bits of the tos-header are used for ECN.
 (http://tools.ietf.org/html/rfc2474#section-3)
OK henning@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.804 2012/04/11 13:29:14 naddy Exp $ */
d3494 2
a3495 1
				if (r->log || act.log & PF_LOG_MATCHES)
d3497 1
d3503 2
a3504 1
				if (act.log & PF_LOG_MATCHES)
d3506 1
@


1.804
log
@SLIST_REMOVE_NEXT -> SLIST_REMOVE_AFTER for better consistency and
compatibility with FreeBSD/NetBSD.
Also rename SIMPLEQ_REMOVE_NEXT to SIMPLEQ_REMOVE_AFTER.

ok mikeb@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.803 2012/04/03 15:09:03 mikeb Exp $ */
d6465 1
a6465 1
		pd->tos = h->ip_tos;
@


1.803
log
@Fix kernel compilation with pf but without pfsync pseudo-device by
moving the state export functionality from pfsync code into pf.
Based on the initial diff diff by guenther, ok henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.802 2012/02/05 22:38:06 mikeb Exp $ */
d620 1
a620 1
				SLIST_REMOVE_NEXT(&s->src_nodes, snip, next);
@


1.802
log
@Improve the ICMPv6 direction check

Following bluhm's advice this changes the way we setup state keys and
perform state lookups for ICMPv6 Neighbor Discovery packets:
  - replace the NS-dst with ND target address;
  - replace the NA-src with ND target address;
  - replace the NA-dst with unspecified address if it is a multicast.

This allows pf to match Address Resolution, Neighbor Unreachability
Detection and Duplicate Address Detection packets to the corresponding
states without the need to create new ones or match unrelated ones.
As a side effect we're doing now one state table lookup for ND packets
instead of two.

Fixes a bug uncovered by one of the previous commits that virtually
breaks IPv6 connectivity after few minutes of use.

ok stsp henning, with and ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.801 2012/02/03 01:57:51 bluhm Exp $ */
d1080 67
d3706 1
d3708 1
@


1.801
log
@The kernel did not compile without INET6.  Put some #ifdefs into
pf to fix that.
- add #ifdef INET6 in obvious places
- af translation is only possible with both INET and INET6
- interleave #endif /* INET6 */ and closing brace correctly
- it is not necessary to #ifdef function prototypes
- do not compile af translate functions at all instead of empty stub,
  then the linker will report inconsistencies
- pf_poolmask() actually takes an sa_family_t not an u_int8_t argument
No binary change for GENERIC compiled with -O2 and -UDIAGNOSTIC.
reported by Olivier Cochard-Labbe; ok mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.800 2012/01/28 14:07:02 mikeb Exp $ */
d190 3
d251 1
a251 1
enum { PF_ICMP_MULTI_NONE, PF_ICMP_MULTI_SOLICITED, PF_ICMP_MULTI_LINK };
d795 53
d855 1
d860 2
a861 2
	PF_ACPY(&sk1->addr[pd->sidx], pd->src, pd->af);
	PF_ACPY(&sk1->addr[pd->didx], pd->dst, pd->af);
d870 1
a870 2
	if (pd->af != pd->naf ||
	    PF_ANEQ(&pd->nsaddr, pd->src, pd->af) ||
d873 1
a873 1
	    wrdom != pd->rdomain) {	/* NAT */
d878 6
a883 7
		PF_ACPY(&sk2->addr[pd->af == pd->naf ? pd->sidx : pd->didx],
		    &pd->nsaddr, pd->naf);
		PF_ACPY(&sk2->addr[pd->af == pd->naf ? pd->didx : pd->sidx],
		    &pd->ndaddr, pd->naf);
		sk2->port[pd->af == pd->naf ? pd->sidx : pd->didx] = pd->nsport;
		sk2->port[pd->af == pd->naf ? pd->didx : pd->sidx] = pd->ndport;
		if (pd->af != pd->naf) {
d1720 2
a1721 2
pf_icmp_mapping(struct pf_pdesc *pd, u_int8_t type,
    int *icmp_dir, int *multi, u_int16_t *virtual_id, u_int16_t *virtual_type)
a1860 1
			*multi = PF_ICMP_MULTI_SOLICITED;
d4622 4
a4625 19
	if (pd->af == AF_INET6 && multi != PF_ICMP_MULTI_NONE) {
		switch (multi) {
		case PF_ICMP_MULTI_SOLICITED:
			key->addr[pd->sidx].addr32[0] = IPV6_ADDR_INT32_MLL;
			key->addr[pd->sidx].addr32[1] = 0;
			key->addr[pd->sidx].addr32[2] = IPV6_ADDR_INT32_ONE;
			key->addr[pd->sidx].addr32[3] = pd->src->addr32[3];
			key->addr[pd->sidx].addr8[12] = 0xff;
			break;
		case PF_ICMP_MULTI_LINK:
			key->addr[pd->sidx].addr32[0] = IPV6_ADDR_INT32_MLL;
			key->addr[pd->sidx].addr32[1] = 0;
			key->addr[pd->sidx].addr32[2] = 0;
			key->addr[pd->sidx].addr32[3] = IPV6_ADDR_INT32_ONE;
			break;
		}
	} else
		PF_ACPY(&key->addr[pd->sidx], pd->src, key->af);
	PF_ACPY(&key->addr[pd->didx], pd->dst, key->af);
@


1.800
log
@improve icmp virtual id generation for ND and MLD packets so that
two consecutive host addresses won't generate the same value which
is used as a port number in state entries;  ok bluhm, sperreault
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.799 2012/01/28 14:00:06 mikeb Exp $ */
a154 1
#ifdef INET6
a156 1
#endif /* INET6 */
d1927 1
a1930 1
#if INET && INET6
a1991 1
#endif /* INET && INET6 */
a2000 1
#if INET && INET6
a2072 1
#endif /* INET && INET6 */
a2083 1
#if INET && INET6
a2301 1
#endif /* INET && INET6 */
d2305 1
d3128 1
d3133 2
d3139 1
d3525 2
a3526 1
	if (rewrite && skw->af != sks->af) {
d3528 3
a3530 2
	} else
		return (PF_PASS);
d3787 1
d3792 1
d3826 1
d3832 1
d4448 1
d4455 1
d4534 1
d4541 1
d4689 1
a4689 1
#endif
d4725 1
a4725 1
#endif
d4750 1
d4757 1
d5091 1
a5091 1
#endif
d5212 1
a5212 1
#endif
d5331 1
a5331 1
#endif
d5519 1
d5529 1
d5610 1
d5619 1
d5692 1
d5699 1
d6138 1
d6317 1
d6368 1
a6368 1
#endif
d6415 1
a6415 1
#endif
d6721 1
d6742 1
d6878 1
a6887 1
#ifdef INET6
a6889 1
#endif
d6893 1
@


1.799
log
@try to lookup the icmp state based on a correct packet descriptor;
ok bluhm, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.798 2012/01/26 20:16:06 bluhm Exp $ */
d1771 1
d1775 5
a1779 4
			*virtual_id = (mld->mld_addr.s6_addr32[0] ^
				mld->mld_addr.s6_addr32[1] ^
				mld->mld_addr.s6_addr32[2] ^
				mld->mld_addr.s6_addr32[3]) & 0xffff;
d1805 1
d1810 5
a1814 4
			*virtual_id = (nd->nd_ns_target.s6_addr32[0] ^
				nd->nd_ns_target.s6_addr32[1] ^
				nd->nd_ns_target.s6_addr32[2] ^
				nd->nd_ns_target.s6_addr32[3]) & 0xffff;
@


1.798
log
@Clean up the pf normalization code:
- Let pf_normalize_ip() and pf_normalize_ip6() take the struct
  pf_pdesc pd as argument.
- Always check wether the mbuf got NULL after normalization to make
  the code more robust.
- Make the code structure of pf_normalize_ip6() more like
  pf_normalize_ip() to make the differences obvious.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.797 2012/01/26 18:19:59 bluhm Exp $ */
d5257 1
a5257 1
				if (ret == PF_DROP && pd->af == AF_INET6 &&
d5259 1
a5259 1
					ret = pf_icmp_state_lookup(pd, &key,
@


1.797
log
@Minor fixes for pf_walk_header6():
- Fragment offset is in network byte order.
- Check for legal short fragments before calling pf_pull_hdr() to
  avoid bogus reason accounting.
- When checking wether the protocol header is within the fragment,
  count the IPv6 payload length relative to the end of the IPv6 header.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.796 2012/01/18 17:21:50 chl Exp $ */
d6596 1
a6596 1
		action = pf_normalize_ip(m0, pd.dir, &reason);
d6601 1
a6601 2
		action = pf_normalize_ip6(m0, pd.dir, pd.fragoff, pd.extoff,
		    &reason);
d6605 4
a6615 4
		/* if packet sits in reassembly queue, return without error */
		if (*m0 == NULL)
			return PF_PASS;

@


1.796
log
@Remove dead assignments and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.795 2012/01/17 21:12:17 bluhm Exp $ */
d6186 1
d6190 1
d6214 1
a6214 1
			if ((frag.ip6f_offlg & IP6F_OFF_MASK) != 0)
d6225 6
a6233 6
				/* fragments may be short */
				if (pd->fragoff != 0) {
					pd->off = pd->fragoff;
					pd->proto = IPPROTO_FRAGMENT;
					return (PF_PASS);
				}
d6245 6
a6253 6
				/* fragments may be short */
				if (pd->fragoff != 0) {
					pd->off = pd->fragoff;
					pd->proto = IPPROTO_FRAGMENT;
					return (PF_PASS);
				}
d6283 1
a6283 1
			if (pd->fragoff != 0 && ntohs(h->ip6_plen) < pd->off +
@


1.795
log
@Fix trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.794 2012/01/16 16:38:01 bluhm Exp $ */
a3179 1
	struct pf_rule		*lastr = NULL;
a3354 1
			lastr = r;
d4604 1
a4604 1
	u_int16_t	 icmpid, *icmpsum, virtual_id, virtual_type;
a4612 1
		icmpid = pd->hdr.icmp->icmp_id;
a4618 1
		icmpid = pd->hdr.icmp6->icmp6_id;
@


1.794
log
@Pass struct pf_pdesc to pf_walk_option6() and pf_walk_header6() to
make their argument list shorter.  Also fix a bug where pf_walk_option6()
used the outer header in the pd2 case.
ok henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.793 2012/01/15 22:55:35 bluhm Exp $ */
d4404 1
a4404 1
			ret = pf_tcp_track_full(pd, dst, src, state, 
@


1.793
log
@Calling pf_normalize_ip() from pf_setup_pdesc() was bad as the
latter is called from pf packet logging.  This resulted in normalization
and reassembly of bad packets to be logged.  So rearrange the code
and move the call to pf_test().
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.792 2011/12/21 23:00:16 mpf Exp $ */
d220 3
a222 1
int			 pf_walk_option6(struct mbuf *, int, int, u_int32_t *,
a223 2
int			 pf_walk_header6(struct mbuf *, struct ip6_hdr *, int *,
			    int *, int *, u_int8_t *, u_int32_t *, u_short *);
a4761 2
		int		 fragoff2, extoff2;
		u_int32_t	 jumbolen;
d4818 1
a4818 3
			if (pf_walk_header6(pd2.m, &h2_6, &pd2.off, &extoff2,
			    &fragoff2, &pd2.proto, &jumbolen, reason)
			    != PF_PASS)
d6123 1
a6123 1
pf_walk_option6(struct mbuf *m, int off, int end, u_int32_t *jumbolen,
a6127 1
	struct ip6_hdr		*h = mtod(m, struct ip6_hdr *);
d6130 2
a6131 2
		if (!pf_pull_hdr(m, off, &opt.ip6o_type, sizeof(opt.ip6o_type),
		    NULL, reason, AF_INET6)) {
d6139 1
a6139 1
		if (!pf_pull_hdr(m, off, &opt, sizeof(opt),
d6151 1
a6151 1
			if (*jumbolen != 0) {
d6161 1
a6161 1
			if (!pf_pull_hdr(m, off, &jumbo, sizeof(jumbo),
d6166 4
a6169 4
			memcpy(jumbolen, jumbo.ip6oj_jumbo_len,
			    sizeof(*jumbolen));
			*jumbolen = ntohl(*jumbolen);
			if (*jumbolen < IPV6_MAXPACKET) {
d6185 1
a6185 2
pf_walk_header6(struct mbuf *m, struct ip6_hdr *h, int *off, int *extoff,
    int *fragoff, u_int8_t *nxt, u_int32_t *jumbolen, u_short *reason)
d6192 3
a6194 4
	*off += sizeof(struct ip6_hdr);
	*extoff = *fragoff = 0;
	*nxt = h->ip6_nxt;
	*jumbolen = 0;
d6196 1
a6196 1
		switch (*nxt) {
d6198 1
a6198 1
			if (*fragoff != 0) {
d6204 1
a6204 1
			if (*jumbolen != 0) {
d6209 1
a6209 1
			if (!pf_pull_hdr(m, *off, &frag, sizeof(frag),
d6214 1
a6214 1
			*fragoff = *off;
d6218 2
a6219 2
			*off += sizeof(frag);
			*nxt = frag.ip6f_nxt;
d6227 1
a6227 1
			if (!pf_pull_hdr(m, *off, &rthdr, sizeof(rthdr),
d6231 3
a6233 3
				if (*fragoff != 0) {
					*off = *fragoff;
					*nxt = IPPROTO_FRAGMENT;
d6247 1
a6247 1
			if (!pf_pull_hdr(m, *off, &ext, sizeof(ext),
d6251 3
a6253 3
				if (*fragoff != 0) {
					*off = *fragoff;
					*nxt = IPPROTO_FRAGMENT;
d6259 7
a6265 6
			if (*fragoff == 0)
				*extoff = *off;
			if (*nxt == IPPROTO_HOPOPTS && *fragoff == 0) {
				if (pf_walk_option6(m, *off + sizeof(ext),
				    *off + (ext.ip6e_len + 1) * 8, jumbolen,
				    reason) != PF_PASS)
d6267 2
a6268 1
				if (ntohs(h->ip6_plen) == 0 && *jumbolen != 0) {
d6275 2
a6276 2
			if (*nxt == IPPROTO_AH)
				*off += (ext.ip6e_len + 2) * 4;
d6278 2
a6279 2
				*off += (ext.ip6e_len + 1) * 8;
			*nxt = ext.ip6e_nxt;
d6285 3
a6287 3
			if (*fragoff != 0 && ntohs(h->ip6_plen) < *off +
			    (*nxt == IPPROTO_TCP ? sizeof(struct tcphdr) :
			    *nxt == IPPROTO_UDP ? sizeof(struct udphdr) :
d6289 2
a6290 2
				*off = *fragoff;
				*nxt = IPPROTO_FRAGMENT;
a6351 2
		u_int32_t	 jumbolen;
		u_int8_t	 nxt;
d6368 1
a6368 2
		if (pf_walk_header6(pd->m, h, &pd->off, &pd->extoff,
		    &pd->fragoff, &nxt, &jumbolen, reason) != PF_PASS)
d6376 1
a6376 1
		if (jumbolen != 0) {
d6384 1
a6384 1
		pd->virtual_proto = pd->proto = nxt;
@


1.792
log
@Just use pd->sidx and pd->didx to reverse the state key arguments
in pf_test_state_*(). This needs less code and is more consistent.
OK mikeb, markus, henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.791 2011/12/19 23:32:36 mikeb Exp $ */
d6306 1
a6306 1
    struct pfi_kif *kif, struct mbuf **m0, u_short *action, u_short *reason)
d6312 1
a6312 1
	pd->m = *m0;
a6323 1
			*action = PF_DROP;
d6325 1
a6325 1
			return (-1);
a6333 1
			*action = PF_DROP;
d6335 1
a6335 1
			return (-1);
a6337 16
		/* packet reassembly */
		if (h->ip_off & htons(IP_MF | IP_OFFMASK) &&
		    pf_normalize_ip(m0, dir, reason) != PF_PASS) {
			*action = PF_DROP;
			return (-1);
		}
		pd->m = *m0;
		if (pd->m == NULL) {
			/* packet sits in reassembly queue, no error */
			*action = PF_PASS;
			return (-1);
		}
		/* refetch header, recalc offset and update pd */
		h = mtod(pd->m, struct ip *);
		pd->off = h->ip_hl << 2;

a6356 1
		int		 extoff, fragoff;
a6361 1
			*action = PF_DROP;
d6363 1
a6363 1
			return (-1);
a6370 1
			*action = PF_DROP;
d6372 1
a6372 1
			return (-1);
d6375 3
a6377 30
		if (pf_walk_header6(pd->m, h, &pd->off, &extoff, &fragoff, &nxt,
		    &jumbolen, reason) != PF_PASS) {
			*action = PF_DROP;
			return (-1);
		}

		if (pf_status.reass && fragoff != 0) {
			/* packet reassembly */
			if (pf_normalize_ip6(m0, dir, fragoff, extoff, reason)
			    != PF_PASS) {
				*action = PF_DROP;
				return (-1);
			}
			pd->m = *m0;
			if (pd->m == NULL) {
				/* packet sits in reassembly queue, no error */
				*action = PF_PASS;
				return (-1);
			}

			/* refetch header, recalc offset, then update pd */
			h = mtod(pd->m, struct ip6_hdr *);
			pd->off = 0;

			if (pf_walk_header6(pd->m, h, &pd->off, &extoff,
			    &fragoff, &nxt, &jumbolen, reason) != PF_PASS) {
				*action = PF_DROP;
				return (-1);
			}
		}
a6384 1
			*action = PF_DROP;
d6386 1
a6386 1
			return (-1);
d6398 1
a6398 1
		if (fragoff != 0)
d6417 2
a6418 2
		    action, reason, pd->af))
			return (-1);
a6421 1
			*action = PF_DROP;
d6423 1
a6423 1
			return (-1);
d6434 2
a6435 2
		    action, reason, pd->af))
			return (-1);
a6439 1
			*action = PF_DROP;
d6441 1
a6441 1
			return (-1);
d6449 2
a6450 2
		    action, reason, pd->af))
			return (-1);
a6452 1
			*action = PF_DROP;
d6454 1
a6454 1
			return (-1);
d6463 2
a6464 2
		    action, reason, pd->af))
			return (-1);
d6478 2
a6479 2
		    action, reason, pd->af))
			return (-1);
a6481 1
			*action = PF_DROP;
d6483 1
a6483 1
			return (-1);
d6495 1
a6495 1
	return (0);
d6596 21
a6616 4
	if (pf_setup_pdesc(&pd, &pdhdrs, af, dir, kif, m0, &action, &reason)
	    == -1) {
		if (action == PF_PASS)
			return (PF_PASS);
d6619 14
@


1.791
log
@improve the icmp direction check to deal correctly with af-to states
(there only one state and it's direction is always PF_IN) and don't
exclude icmp echo replies from the test.

ok mcbride, claudio on previous version, ok henning, "looks good" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.790 2011/12/12 21:30:27 mikeb Exp $ */
d4281 4
a4284 11
	if (pd->dir == PF_IN)	{	/* wire side, straight */
		PF_ACPY(&key.addr[0], pd->src, key.af);
		PF_ACPY(&key.addr[1], pd->dst, key.af);
		key.port[0] = th->th_sport;
		key.port[1] = th->th_dport;
	} else {			/* stack side, reverse */
		PF_ACPY(&key.addr[1], pd->src, key.af);
		PF_ACPY(&key.addr[0], pd->dst, key.af);
		key.port[1] = th->th_sport;
		key.port[0] = th->th_dport;
	}
d4470 4
a4473 11
	if (pd->dir == PF_IN)	{	/* wire side, straight */
		PF_ACPY(&key.addr[0], pd->src, key.af);
		PF_ACPY(&key.addr[1], pd->dst, key.af);
		key.port[0] = uh->uh_sport;
		key.port[1] = uh->uh_dport;
	} else {			/* stack side, reverse */
		PF_ACPY(&key.addr[1], pd->src, key.af);
		PF_ACPY(&key.addr[0], pd->dst, key.af);
		key.port[1] = uh->uh_sport;
		key.port[0] = uh->uh_dport;
	}
d5435 3
a5437 9
	if (pd->dir == PF_IN)	{
		PF_ACPY(&key.addr[0], pd->src, key.af);
		PF_ACPY(&key.addr[1], pd->dst, key.af);
		key.port[0] = key.port[1] = 0;
	} else {
		PF_ACPY(&key.addr[1], pd->src, key.af);
		PF_ACPY(&key.addr[0], pd->dst, key.af);
		key.port[1] = key.port[0] = 0;
	}
@


1.790
log
@fixup af-to regression with match rules

pfctl should not infer the af-to behavior from the af/naf difference.
instead, we should be clear that this is an af-to rule.  essentially
this change converts FOM_AFTO marker into a rule flag PFRULE_AFTO so
that we don't rely on ambiguous checks (like r->af != r->naf) when
setting things up.

positive review and comments from claudio, ok henning, sperreault
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.789 2011/12/02 03:15:31 haesbaert Exp $ */
d4558 2
d4595 7
a4601 3
	if ((*state)->rule.ptr->type &&
	    (((!inner && (*state)->direction == pd->dir) ||
	    (inner && (*state)->direction != pd->dir)) ?
@


1.789
log
@Kill unused IFCAP_IPSEC and IFCAP_IPCOMP.

ok claudio@@ henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.788 2011/11/28 01:04:50 dlg Exp $ */
d3367 1
a3367 1
				if (r->naf)
d3402 1
a3402 1
	if (r->naf)
@


1.788
log
@deprecate PFTM_UNTIL_PACKET. nothing in the tree uses it, and
pf_state_expires() handled it incorrectly.

discussed with mikeb@@
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.787 2011/11/26 03:28:46 mcbride Exp $ */
d5831 1
a5831 2
	 * If deferred crypto processing is needed, check that the
	 * interface supports it.
d5834 1
a5834 1
	    != NULL && (ifp->if_capabilities & IFCAP_IPSEC) == 0) {
@


1.787
log
@Apply route-to to deferred packet; without this the first packet of a
connection does not observe the route-to option.

ok dlg mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.786 2011/11/25 12:52:10 dlg Exp $ */
a1064 2
	if (state->timeout == PFTM_UNTIL_PACKET)
		return (0);
@


1.786
log
@use time_uptime to set state creation values as time_second can be
skewed at runtime by things like date(1) and ntpd. time_uptime is
monotonic and therefore more useful to compare against.

ok deraadt@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.785 2011/10/21 09:21:44 mikeb Exp $ */
a210 4
void			 pf_route(struct mbuf **, struct pf_rule *, int,
			    struct ifnet *, struct pf_state *);
void			 pf_route6(struct mbuf **, struct pf_rule *, int,
			    struct ifnet *, struct pf_state *);
@


1.785
log
@add forgotten fixup for icmp6 id's when translating;  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.784 2011/10/13 18:23:39 claudio Exp $ */
d570 1
a570 1
		(*sn)->creation = time_second;
d3644 1
a3644 1
	s->creation = time_second;
@


1.784
log
@Since the IPv6 madness is not enough introduce NAT64 -- which is actually
"af-to" a generic IP version translator for pf(4).
Not everything perfect yet but lets fix these things in the tree.
Insane amount of work done by sperreault@@, mikeb@@ and reyk@@.
Looked over by mcbride@@ henning@@ and myself at eurobsdcon.
OK mcbride@@ and general put it in from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.783 2011/10/07 14:24:10 henning Exp $ */
d4745 4
@


1.783
log
@remove inaccurate comment - we don't have state tableS any more, there is
just one and the variable name is clear enough. ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.781 2011/09/22 14:57:12 bluhm Exp $ */
d152 1
a152 1
			    u_int8_t, sa_family_t);
d165 5
d684 6
a689 1
			    si->s->direction == s->direction) {
d819 2
a820 1
	if (PF_ANEQ(&pd->nsaddr, pd->src, pd->af) ||
d828 20
a847 6
		PF_ACPY(&sk2->addr[pd->sidx], &pd->nsaddr, pd->af);
		PF_ACPY(&sk2->addr[pd->didx], &pd->ndaddr, pd->af);
		sk2->port[pd->sidx] = pd->nsport;
		sk2->port[pd->didx] = pd->ndport;
		sk2->proto = pd->proto;
		sk2->af = pd->af;
d993 6
a998 2
		    sk == (dir == PF_IN ? si->s->key[PF_SK_WIRE] :
		    si->s->key[PF_SK_STACK]))
d1555 2
a1556 1
    struct pf_addr *an, u_int16_t pn, u_int8_t u, sa_family_t af)
d1562 3
a1564 1
	PF_ACPY(a, an, af);
d1570 24
a1593 4
		*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
		    ao.addr16[0], an->addr16[0], u),
		    ao.addr16[1], an->addr16[1], u),
		    po, pn, u);
d1598 32
a1629 12
		*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
		    ao.addr16[0], an->addr16[0], u),
		    ao.addr16[1], an->addr16[1], u),
		    ao.addr16[2], an->addr16[2], u),
		    ao.addr16[3], an->addr16[3], u),
		    ao.addr16[4], an->addr16[4], u),
		    ao.addr16[5], an->addr16[5], u),
		    ao.addr16[6], an->addr16[6], u),
		    ao.addr16[7], an->addr16[7], u),
		    po, pn, u);
a1634 1

d1931 384
d3273 2
a3274 2
		PF_TEST_ATTRIB((PF_MISMATCHAW(&r->src.addr, &pd->nsaddr, pd->af,
		    r->src.neg, pd->kif, act.rtableid)),
d3373 2
d3408 2
d3497 4
a3500 2
			    &sk->addr[pd->sidx], sk->port[pd->sidx],
			    &sk->addr[pd->didx], sk->port[pd->didx],
d3531 4
a3534 1
	return (PF_PASS);
d3748 1
d3750 1
a3750 1
	if (PF_ANEQ(daddr, pd->dst, pd->af))
d3755 2
a3756 1
		if (PF_ANEQ(saddr, pd->src, pd->af) || *pd->sport != sport) {
d3758 1
a3758 1
			    saddr, sport, 0, pd->af);
d3761 2
a3762 1
		if (PF_ANEQ(daddr, pd->dst, pd->af) || *pd->dport != dport) {
d3764 1
a3764 1
			    daddr, dport, 0, pd->af);
d3770 2
a3771 1
		if (PF_ANEQ(saddr, pd->src, pd->af) || *pd->sport != sport) {
d3773 1
a3773 1
			    saddr, sport, 1, pd->af);
d3776 2
a3777 1
		if (PF_ANEQ(daddr, pd->dst, pd->af) || *pd->dport != dport) {
d3779 1
a3779 1
			    daddr, dport, 1, pd->af);
d3790 4
a3793 8
		if (PF_ANEQ(saddr, pd->src, pd->af)) {
			pf_change_a(&pd->src->v4.s_addr, NULL,
			    saddr->v4.s_addr, 0);
			rewrite = 1;
		}
		if (PF_ANEQ(daddr, pd->dst, pd->af)) {
			pf_change_a(&pd->dst->v4.s_addr, NULL,
			    daddr->v4.s_addr, 0);
d3795 11
d3827 5
a3831 8
		if (PF_ANEQ(saddr, pd->src, pd->af)) {
			pf_change_a6(pd->src, &pd->hdr.icmp6->icmp6_cksum,
			    saddr, 0);
			rewrite = 1;
		}
		if (PF_ANEQ(daddr, pd->dst, pd->af)) {
			pf_change_a6(pd->dst, &pd->hdr.icmp6->icmp6_cksum,
			    daddr, 0);
d3833 11
d3852 1
a3852 1
			if (PF_ANEQ(saddr, pd->src, pd->af)) {
d3857 1
a3857 1
			if (PF_ANEQ(daddr, pd->dst, pd->af)) {
d3866 1
a3866 1
			if (PF_ANEQ(saddr, pd->src, pd->af)) {
d3870 1
a3870 1
			if (PF_ANEQ(daddr, pd->dst, pd->af)) {
d4282 1
d4414 9
a4422 2
		if (pf_tcp_track_full(pd, src, dst, state, reason, &copyback)
		    == PF_DROP)
d4428 11
a4438 1
		struct pf_state_key *nk = (*state)->key[pd->didx];
d4440 2
a4441 2
		if (PF_ANEQ(pd->src, &nk->addr[pd->sidx], pd->af) ||
		    nk->port[pd->sidx] != th->th_sport)
d4443 3
a4445 2
			    &nk->addr[pd->sidx], nk->port[pd->sidx], 0, pd->af);
		if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], pd->af) ||
d4448 2
a4449 2
		if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], pd->af) ||
		    nk->port[pd->didx] != th->th_dport)
d4451 2
a4452 1
			    &nk->addr[pd->didx], nk->port[pd->didx], 0, pd->af);
d4454 8
d4469 1
a4469 1
	return (PF_PASS);
d4478 1
d4520 2
a4521 1
		struct pf_state_key *nk = (*state)->key[pd->didx];
d4523 11
a4533 2
		if (PF_ANEQ(pd->src, &nk->addr[pd->sidx], pd->af) ||
		    nk->port[pd->sidx] != uh->uh_sport)
d4535 3
a4537 2
			    &nk->addr[pd->sidx], nk->port[pd->sidx], 1, pd->af);
		if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], pd->af) ||
d4540 2
a4541 2
		if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], pd->af) ||
		    nk->port[pd->didx] != uh->uh_dport)
d4543 1
a4543 1
			    &nk->addr[pd->didx], nk->port[pd->didx], 1, pd->af);
d4545 8
d4556 1
a4556 1
	return (PF_PASS);
d4668 12
a4679 1
			struct pf_state_key *nk = (*state)->key[pd->didx];
d4688 10
a4697 2
				if (PF_ANEQ(pd->src,
				    &nk->addr[pd->sidx], AF_INET))
d4699 1
a4699 1
					    nk->addr[pd->sidx].v4.s_addr, 0);
d4701 2
a4702 2
				if (PF_ANEQ(pd->dst, &nk->addr[pd->didx],
				    AF_INET)) {
d4704 1
a4704 1
					    nk->addr[pd->didx].v4.s_addr, 0);
d4724 10
a4733 2
				if (PF_ANEQ(pd->src,
				    &nk->addr[pd->sidx], AF_INET6))
d4736 1
a4736 1
					    &nk->addr[pd->sidx], 0);
d4738 2
a4739 2
				if (PF_ANEQ(pd->dst,
				    &nk->addr[pd->didx], AF_INET6)) {
d4742 1
a4742 1
					    &nk->addr[pd->didx], 0);
d4752 6
d4873 7
a4879 2
				src = &(*state)->dst;
				dst = &(*state)->src;
d4881 7
a4887 2
				src = &(*state)->src;
				dst = &(*state)->dst;
d4936 7
a4942 2
				struct pf_state_key *nk =
				    (*state)->key[pd->didx];
d4944 34
d5050 46
a5095 2
				struct pf_state_key *nk =
				    (*state)->key[pd->didx];
d5172 45
a5216 2
				struct pf_state_key *nk =
				    (*state)->key[pd->didx];
d5289 47
a5335 2
				struct pf_state_key *nk =
				    (*state)->key[pd->didx];
d5440 1
d5480 9
a5488 1
		struct pf_state_key *nk = (*state)->key[pd->didx];
d5498 2
a5499 1
			if (PF_ANEQ(pd->src, &nk->addr[pd->sidx], AF_INET))
d5503 2
a5504 1
			if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], AF_INET)) {
d5514 2
a5515 1
			if (PF_ANEQ(pd->src, &nk->addr[pd->sidx], AF_INET6))
d5518 2
a5519 1
			if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], AF_INET6)) {
d5529 10
d5541 1
a5541 1
	return (PF_PASS);
a6326 1
	pd->af = af;
d6332 1
d6379 1
d6461 1
d6578 1
a6578 1
	if (action == PF_PASS || r->action == PF_DROP) {
d6695 1
a6695 1
		if (action == PF_PASS) {
d6716 1
a6716 1
		if (action == PF_PASS) {
d6737 1
a6737 1
		if (action == PF_PASS) {
d6758 1
a6758 1
		if (action == PF_PASS) {
d6772 1
a6772 1
		if (action == PF_PASS) {
d6901 16
@


1.782
log
@As requested by henning, move the mbuf pointer into struct pf_pdesc.
Also sort pd to the beginning of the functions' parameter lists for
consistency.
ok henning
@
text
@a101 2

/* state tables */
@


1.781
log
@As I have touched half of pf lines anyway, fix whitespaces now.
KNF, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.780 2011/09/21 19:07:30 bluhm Exp $ */
d155 1
a155 1
int			 pf_modulate_sack(struct mbuf *, struct pf_pdesc *,
d180 2
a181 2
int			 pf_test_rule(struct pf_rule **, struct pf_state **,
			    struct mbuf *, struct pf_pdesc *, struct pf_rule **,
d183 2
a184 2
static __inline int	 pf_create_state(struct pf_rule *, struct pf_rule *,
			    struct pf_rule *, struct pf_pdesc *,
d186 1
a186 1
			    struct mbuf *, int *, struct pf_state **, int,
d191 17
a207 18
int			 pf_tcp_track_full(struct pf_state_peer *,
			    struct pf_state_peer *, struct pf_state **,
			    struct mbuf *, struct pf_pdesc *, u_short *, int *);
int			 pf_tcp_track_sloppy(struct pf_state_peer *,
			    struct pf_state_peer *, struct pf_state **,
			    struct pf_pdesc *, u_short *);
int			 pf_test_state_tcp(struct pf_state **, struct mbuf *,
			    struct pf_pdesc *, u_short *);
int			 pf_test_state_udp(struct pf_state **, struct mbuf *,
			    struct pf_pdesc *);
int			 pf_icmp_state_lookup(struct pf_state_key_cmp *,
			    struct pf_pdesc *, struct pf_state **,
			    struct mbuf *, u_int16_t, u_int16_t, int, int *,
			    int, int);
int			 pf_test_state_icmp(struct pf_state **, struct mbuf *,
			    struct pf_pdesc *, u_short *);
int			 pf_test_state_other(struct pf_state **, struct mbuf *,
			    struct pf_pdesc *);
d212 2
a213 2
u_int8_t		 pf_get_wscale(struct mbuf *, struct pf_pdesc *);
u_int16_t		 pf_get_mss(struct mbuf *, struct pf_pdesc *);
d1867 1
a1867 1
pf_modulate_sack(struct mbuf *m, struct pf_pdesc *pd, struct pf_state_peer *dst)
d1877 1
a1877 1
	if (hlen < TCPOLEN_SACKLEN || !pf_pull_hdr(m, pd->off + sizeof(*th),
d1916 2
a1917 1
		m_copyback(m, pd->off + sizeof(*th), thoptlen, opts, M_NOWAIT);
d2503 1
a2503 1
pf_get_wscale(struct mbuf *m, struct pf_pdesc *pd)
d2514 1
a2514 1
	if (!pf_pull_hdr(m, pd->off, hdr, hlen, NULL, NULL, pd->af))
d2544 1
a2544 1
pf_get_mss(struct mbuf *m, struct pf_pdesc *pd)
d2555 1
a2555 1
	if (!pf_pull_hdr(m, pd->off, hdr, hlen, NULL, NULL, pd->af))
d2730 2
a2731 2
pf_test_rule(struct pf_rule **rm, struct pf_state **sm, struct mbuf *m,
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
d2847 1
a2847 1
			    !pf_osfp_match(pf_osfp_fingerprint(pd, m),
d2900 1
a2900 1
		PF_TEST_ATTRIB((r->match_tag && !pf_match_tag(m, r, &tag)),
d2902 1
a2902 1
		PF_TEST_ATTRIB((r->rcv_kif && !pf_match_rcvif(m, r)),
d2925 1
a2925 2
					PFLOG_PACKET(m, reason, r, a, ruleset,
					    pd);
d2932 1
a2932 2
					PFLOG_PACKET(m, reason, r, a, ruleset,
					    pd);
d2960 1
a2960 1
		PFLOG_PACKET(m, reason, r, a, ruleset, pd);
d2973 1
a2973 1
			if (pf_check_proto_cksum(m, pd->off,
d2990 1
a2990 1
			pf_send_icmp(m, r->return_icmp >> 8,
d2996 1
a2996 1
			pf_send_icmp(m, r->return_icmp6 >> 8,
d3003 1
a3003 1
	pf_tag_packet(m, tag, act.rtableid);
d3027 1
a3027 1
		action = pf_create_state(r, a, nr, pd, &skw, &sks, m, &rewrite,
d3053 1
a3053 1
		m_copyback(m, pd->off, pd->hdrlen, pd->hdr.any, M_NOWAIT);
d3064 1
a3064 1
		if (pfsync_defer(*sm, m))
d3084 4
a3087 5
pf_create_state(struct pf_rule *r, struct pf_rule *a, struct pf_rule *nr,
    struct pf_pdesc *pd, struct pf_state_key **skw, struct pf_state_key **sks,
    struct mbuf *m, int *rewrite, struct pf_state **sm, int tag,
    struct pf_rule_slist *rules, struct pf_rule_actions *act,
    struct pf_src_node *sns[PF_SN_MAX])
d3147 1
a3147 1
			s->src.wscale = pf_get_wscale(m, pd);
d3187 1
a3187 1
		    pf_normalize_tcp_init(m, pd, &s->src, &s->dst)) {
d3192 2
a3193 2
		    pf_normalize_tcp_stateful(m, pd, &reason, s,
		    &s->src, &s->dst, rewrite)) {
d3247 1
a3247 1
		mss = pf_get_mss(m, pd);
d3400 3
a3402 3
pf_tcp_track_full(struct pf_state_peer *src, struct pf_state_peer *dst,
    struct pf_state **state, struct mbuf *m, struct pf_pdesc *pd,
    u_short *reason, int *copyback)
d3428 1
a3428 1
			if (pf_normalize_tcp_init(m, pd, src, dst)) {
d3452 1
a3452 1
				src->wscale = pf_get_wscale(m, pd);
d3539 1
a3539 1
		if (pf_modulate_sack(m, pd, dst))
d3558 2
a3559 2
			if (pf_normalize_tcp_stateful(m, pd, reason,
			    *state, src, dst, copyback))
d3655 2
a3656 2
			if (pf_normalize_tcp_stateful(m, pd, reason,
			    *state, src, dst, copyback))
d3722 2
a3723 2
pf_tcp_track_sloppy(struct pf_state_peer *src, struct pf_state_peer *dst,
	struct pf_state **state, struct pf_pdesc *pd, u_short *reason)
d3793 1
a3793 2
pf_test_state_tcp(struct pf_state **state, struct mbuf *m, struct pf_pdesc *pd,
    u_short *reason)
d3816 1
a3816 1
	STATE_LOOKUP(pd->kif, &key, pd->dir, *state, m);
d3928 1
a3928 1
		if (pf_tcp_track_sloppy(src, dst, state, pd, reason) == PF_DROP)
d3931 2
a3932 2
		if (pf_tcp_track_full(src, dst, state, m, pd, reason,
		    &copyback) == PF_DROP)
d3951 1
a3951 1
		m->m_pkthdr.rdomain = nk->rdomain;
d3957 1
a3957 1
		m_copyback(m, pd->off, sizeof(*th), th, M_NOWAIT);
d3963 1
a3963 1
pf_test_state_udp(struct pf_state **state, struct mbuf *m, struct pf_pdesc *pd)
d3984 1
a3984 1
	STATE_LOOKUP(pd->kif, &key, pd->dir, *state, m);
d4022 2
a4023 2
		m->m_pkthdr.rdomain = nk->rdomain;
		m_copyback(m, pd->off, sizeof(*uh), uh, M_NOWAIT);
d4030 2
a4031 2
pf_icmp_state_lookup(struct pf_state_key_cmp *key, struct pf_pdesc *pd,
    struct pf_state **state, struct mbuf *m, u_int16_t icmpid, u_int16_t type,
d4066 1
a4066 1
	STATE_LOOKUP(pd->kif, key, pd->dir, *state, m);
d4086 2
a4087 2
pf_test_state_icmp(struct pf_state **state, struct mbuf *m,
    struct pf_pdesc *pd, u_short *reason)
d4118 1
a4118 1
		ret = pf_icmp_state_lookup(&key, pd, state, m,
d4124 1
a4124 1
				ret = pf_icmp_state_lookup(&key, pd, state, m,
d4142 1
a4142 1
			m->m_pkthdr.rdomain = nk->rdomain;
d4169 1
a4169 1
				m_copyback(m, pd->off, ICMP_MINLEN,
d4189 3
a4191 2
				m_copyback(m, pd->off, sizeof(struct icmp6_hdr),
				    pd->hdr.icmp6, M_NOWAIT);
d4220 1
d4231 1
a4231 1
			if (!pf_pull_hdr(m, ipoff2, &h2, sizeof(h2),
d4259 1
a4259 1
			if (!pf_pull_hdr(m, ipoff2, &h2_6, sizeof(h2_6),
d4267 1
a4267 1
			if (pf_walk_header6(m, &h2_6, &pd2.off, &extoff2,
d4292 1
a4292 1
			if (!pf_pull_hdr(m, pd2.off, &th, 8, NULL, reason,
d4307 1
a4307 1
			STATE_LOOKUP(pd2.kif, &key, pd2.dir, *state, m);
d4377 1
a4377 1
				m->m_pkthdr.rdomain = nk->rdomain;
d4393 1
a4393 1
					m_copyback(m, pd->off, ICMP_MINLEN,
d4395 1
a4395 1
					m_copyback(m, ipoff2, sizeof(h2),
d4401 1
a4401 1
					m_copyback(m, pd->off,
d4404 1
a4404 1
					m_copyback(m, ipoff2, sizeof(h2_6),
d4409 1
a4409 1
				m_copyback(m, pd2.off, 8, &th, M_NOWAIT);
d4418 1
a4418 1
			if (!pf_pull_hdr(m, pd2.off, &uh, sizeof(uh),
d4433 1
a4433 1
			STATE_LOOKUP(pd2.kif, &key, pd2.dir, *state, m);
d4452 1
a4452 1
				m->m_pkthdr.rdomain = nk->rdomain;
d4465 1
a4465 1
					m_copyback(m, pd->off, ICMP_MINLEN,
d4467 2
a4468 2
					m_copyback(m, ipoff2, sizeof(h2), &h2,
					    M_NOWAIT);
d4473 1
a4473 1
					m_copyback(m, pd->off,
d4476 1
a4476 1
					m_copyback(m, ipoff2, sizeof(h2_6),
d4481 1
a4481 1
				m_copyback(m, pd2.off, sizeof(uh), &uh,
d4496 1
a4496 1
			if (!pf_pull_hdr(m, pd2.off, &iih, ICMP_MINLEN,
d4507 1
a4507 1
			ret = pf_icmp_state_lookup(&key, &pd2, state, m,
d4534 1
a4534 1
				m->m_pkthdr.rdomain = nk->rdomain;
d4542 1
a4542 1
				m_copyback(m, pd->off, ICMP_MINLEN,
d4544 1
a4544 1
				m_copyback(m, ipoff2, sizeof(h2), &h2,
d4546 1
a4546 1
				m_copyback(m, pd2.off, ICMP_MINLEN, &iih,
d4562 1
a4562 1
			if (!pf_pull_hdr(m, pd2.off, &iih,
d4572 1
a4572 1
			ret = pf_icmp_state_lookup(&key, &pd2, state, m,
d4578 2
a4579 2
					ret = pf_icmp_state_lookup(&key, pd,
					    state, m, virtual_id, virtual_type,
d4611 1
a4611 1
				m->m_pkthdr.rdomain = nk->rdomain;
d4619 4
a4622 3
				m_copyback(m, pd->off, sizeof(struct icmp6_hdr),
				    pd->hdr.icmp6, M_NOWAIT);
				m_copyback(m, ipoff2, sizeof(h2_6), &h2_6,
d4624 2
a4625 2
				m_copyback(m, pd2.off, sizeof(struct icmp6_hdr),
				    &iih, M_NOWAIT);
d4639 1
a4639 1
			STATE_LOOKUP(pd2.kif, &key, pd2.dir, *state, m);
d4656 1
a4656 1
				m->m_pkthdr.rdomain = nk->rdomain;
d4667 1
a4667 1
					m_copyback(m, pd->off, ICMP_MINLEN,
d4669 2
a4670 2
					m_copyback(m, ipoff2, sizeof(h2), &h2,
					    M_NOWAIT);
d4675 1
a4675 1
					m_copyback(m, pd->off,
d4678 1
a4678 1
					m_copyback(m, ipoff2, sizeof(h2_6),
d4692 1
a4692 2
pf_test_state_other(struct pf_state **state, struct mbuf *m,
    struct pf_pdesc *pd)
d4710 1
a4710 1
	STATE_LOOKUP(pd->kif, &key, pd->dir, *state, m);
d4772 1
a4772 1
		m->m_pkthdr.rdomain = nk->rdomain;
d5555 2
a5556 3
pf_setup_pdesc(sa_family_t af, int dir, struct pfi_kif *kif,
    struct pf_pdesc *pd, void *pdhdrs, struct mbuf **m0, u_short *action,
    u_short *reason)
a5557 2
	struct mbuf *m = *m0;

d5563 1
d5573 1
a5573 1
		if (m->m_pkthdr.len < (int)sizeof(struct ip)) {
d5579 1
a5579 1
		h = mtod(m, struct ip *);
d5584 1
a5584 1
		    m->m_pkthdr.len < ntohs(h->ip_len)) {
d5596 2
a5597 2
		m = *m0;
		if (m == NULL) {
d5603 1
a5603 1
		h = mtod(m, struct ip *);
d5611 1
a5611 1
		pd->rdomain = rtable_l2(m->m_pkthdr.rdomain);
d5629 1
a5629 1
		if (m->m_pkthdr.len < (int)sizeof(struct ip6_hdr)) {
d5635 1
a5635 1
		h = mtod(m, struct ip6_hdr *);
d5638 1
a5638 1
		if (m->m_pkthdr.len <
d5645 1
a5645 1
		if (pf_walk_header6(m, h, &pd->off, &extoff, &fragoff, &nxt,
d5658 2
a5659 2
			m = *m0;
			if (m == NULL) {
d5666 1
a5666 1
			h = mtod(m, struct ip6_hdr *);
d5669 2
a5670 2
			if (pf_walk_header6(m, h, &pd->off, &extoff, &fragoff,
			    &nxt, &jumbolen, reason) != PF_PASS) {
d5713 1
a5713 1
		if (!pf_pull_hdr(m, pd->off, th, sizeof(*th),
d5731 1
a5731 1
		if (!pf_pull_hdr(m, pd->off, uh, sizeof(*uh),
d5747 1
a5747 1
		if (!pf_pull_hdr(m, pd->off, pd->hdr.icmp, ICMP_MINLEN,
d5762 1
a5762 1
		if (!pf_pull_hdr(m, pd->off, pd->hdr.icmp6, icmp_hlen,
d5777 1
a5777 1
		    !pf_pull_hdr(m, pd->off, pd->hdr.icmp6, icmp_hlen,
a5856 1
	struct mbuf		*m = *m0;
d5882 1
a5882 1
	if ((m->m_flags & M_PKTHDR) == 0)
d5886 1
a5886 1
	if (m->m_pkthdr.pf.flags & PF_TAG_GENERATED)
d5889 1
a5889 1
	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED_PACKET)
d5892 2
a5893 2
	if (m->m_pkthdr.pf.flags & PF_TAG_REFRAGMENTED) {
		m->m_pkthdr.pf.flags &= ~PF_TAG_REFRAGMENTED;
d5897 1
a5897 1
	if (pf_setup_pdesc(af, dir, kif, &pd, &pdhdrs, m0, &action, &reason)
a5900 1
		m = *m0;
a5904 1
	m = *m0;	/* pf_setup_pdesc -> pf_normalize messes with m0 */
d5913 1
a5913 1
		action = pf_test_rule(&r, &s, m, &pd, &a, &ruleset);
d5922 1
a5922 1
		action = pf_normalize_tcp(m, &pd);
d5925 1
a5925 1
		action = pf_test_state_tcp(&s, m, &pd, &reason);
d5934 1
a5934 1
			action = pf_test_rule(&r, &s, m, &pd, &a, &ruleset);
d5938 1
a5938 1
				pf_normalize_mss(m, &pd, s->max_mss);
d5940 1
a5940 1
			pf_normalize_mss(m, &pd, r->max_mss);
d5946 1
a5946 1
		action = pf_test_state_udp(&s, m, &pd);
d5955 1
a5955 1
			action = pf_test_rule(&r, &s, m, &pd, &a, &ruleset);
d5967 1
a5967 1
		action = pf_test_state_icmp(&s, m, &pd, &reason);
d5976 1
a5976 1
			action = pf_test_rule(&r, &s, m, &pd, &a, &ruleset);
d5988 1
a5988 1
		action = pf_test_state_icmp(&s, m, &pd, &reason);
d5997 1
a5997 1
			action = pf_test_rule(&r, &s, m, &pd, &a, &ruleset);
d6002 1
a6002 1
		action = pf_test_state_other(&s, m, &pd);
d6011 1
a6011 1
			action = pf_test_rule(&r, &s, m, &pd, &a, &ruleset);
d6028 1
a6028 1
			pf_scrub(m, s->state_flags, pd.af, s->min_ttl,
d6030 1
a6030 1
			pf_tag_packet(m, s->tag, s->rtableid[pd.didx]);
d6034 1
a6034 1
					 m->m_pkthdr.pf.prio = s->prio[1];
d6038 1
a6038 1
					 m->m_pkthdr.pf.prio = s->prio[0];
d6041 1
a6041 1
			pf_scrub(m, r->scrub_flags, pd.af, r->min_ttl,
d6046 1
a6046 1
					 m->m_pkthdr.pf.prio = r->prio[1];
d6050 1
a6050 1
					 m->m_pkthdr.pf.prio = r->prio[0];
d6056 1
a6056 1
		m->m_pkthdr.pf.statekey = s->key[PF_SK_STACK];
d6060 2
a6061 2
		m->m_pkthdr.pf.qid = qid;
		m->m_pkthdr.pf.hdr = mtod(m, caddr_t);	/* hints for ecn */
d6074 1
a6074 1
			m->m_pkthdr.pf.flags |= PF_TAG_TRANSLATE_LOCALHOST;
d6077 1
a6077 1
		m->m_pkthdr.pf.flags |= PF_TAG_REROUTE;
d6082 2
a6083 2
		if ((divert = pf_get_divert(m))) {
			m->m_pkthdr.pf.flags |= PF_TAG_DIVERTED;
d6093 1
a6093 1
		if ((divert = pf_get_divert(m)))
d6103 1
a6103 1
			PFLOG_PACKET(m, reason, r, a, ruleset, &pd);
d6107 2
a6108 2
					PFLOG_PACKET(m, reason,
					    ri->r, a, ruleset, &pd);
d6124 1
a6124 1
			divert_packet(m, pd.dir);
d6128 1
a6128 1
			divert6_packet(m, pd.dir);
d6156 2
a6157 1
		if ((mtag = m_tag_find(m, PACKET_TAG_PF_REASSEMBLED, NULL)))
@


1.780
log
@Check the protocol header length for tcp, udp, icmp, icmp6 in
pf_setup_pdesc().  It is better to check and bail out early than
to rely on pf_pull_hdr() later.
ok henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.779 2011/09/20 15:17:26 bluhm Exp $ */
a1862 1

d1870 6
a1875 5
	struct tcphdr	 *th = pd->hdr.tcp;
	int hlen = (th->th_off << 2) - sizeof(*th), thoptlen = hlen;
	u_int8_t opts[MAX_TCPOPTLEN], *opt = opts;
	int copyback = 0, i, olen;
	struct sackblk sack;
d2721 1
a2721 1
#define PF_TEST_ATTRIB(t, a) 			\
d2843 2
a2844 1
			PF_TEST_ATTRIB(((r->flagset & th->th_flags) != r->flags),
d2848 1
a2848 1
		    	    r->os_fingerprint)),
d2890 1
a2890 1
		} 
d4206 1
a4206 2

		struct pf_pdesc	pd2;
d4208 1
a4208 1
		struct ip	h2;
d4211 3
a4213 3
		struct ip6_hdr	h2_6;
		int		fragoff2, extoff2;
		u_int32_t	jumbolen;
d4216 1
a4216 1
		int		ipoff2;
d4333 2
a4334 2
			    (!SEQ_GEQ(src->seqhi, seq) ||
			    !SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws)))) {
@


1.779
log
@pf_setup_pdesc() panics if address family is neither AF_INET nor
AF_INET6.  So remove useless af switch defaults here and there.
Always use "switch(af)" instead of "if (af) else" for af dependent
code.  Always use AF_ defines instead of PF_ when checking af values.
ok claudio mpf henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.778 2011/09/20 10:51:18 bluhm Exp $ */
d5721 6
d5740 1
a5740 1
		    ntohs(uh->uh_ulen) > m->m_pkthdr.len - pd->off ||
d5755 5
d5785 5
@


1.778
log
@Put kif and dir into pdesc an use this instead of passing the values
around.  This is a mechanical change.  Initialize pd2 and use it
where appropriate.
ok henning on an earlier version; ok mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.777 2011/09/19 12:51:52 bluhm Exp $ */
a1778 5
	default:
		*icmp_dir = PF_IN;
		*virtual_type = type;
		*virtual_id = 0;
		break;
a2494 3

	default:
		return (-1);
d2682 6
a2687 1
	if (pd->af == AF_INET6) {
d2690 1
a2690 3
	} else {
		MD5Update(&ctx, (char *)&pd->src->v4, sizeof(struct in_addr));
		MD5Update(&ctx, (char *)&pd->dst->v4, sizeof(struct in_addr));
a4876 2
	default:
		return (0);
a4946 2
	default:
		return (0);
a5324 2
	default:
		return (1);
d6113 2
a6114 1
		if (pd.af == AF_INET)
d6116 1
d6118 1
a6118 1
		if (pd.af == AF_INET6)
d6120 3
a6122 1
#endif
d6129 2
a6130 1
			if (pd.af == AF_INET)
d6132 1
d6134 1
a6134 1
			if (pd.af == AF_INET6)
d6136 3
a6138 1
#endif
@


1.777
log
@Consolidate pf function parameters.  Move off and hdrlen into pdesc
and change their type from int to u_int32_t.  Do not pass struct
tcphdr *th and sa_family_t af, it is in pd anyway.  Do not use af
and pd->af intermixed, the latter makes clear where it comes from.
Do not calculate the packet length again if pd already has it.  Use
pd2.off instead of off2.
go go go go don't stop henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.776 2011/09/18 13:50:13 bluhm Exp $ */
d181 1
a181 2
			    int, struct pfi_kif *, struct mbuf *,
			    struct pf_pdesc *, struct pf_rule **,
d186 3
a188 3
			    struct mbuf *, int *, struct pfi_kif *,
			    struct pf_state **, int, struct pf_rule_slist *,
			    struct pf_rule_actions *, struct pf_src_node *[]);
d193 1
a193 2
			    struct pfi_kif *, struct mbuf *,
			    struct pf_pdesc *, u_short *, int *);
d197 1
a197 2
int			 pf_test_state_tcp(struct pf_state **, int,
			    struct pfi_kif *, struct mbuf *,
d199 1
a199 2
int			 pf_test_state_udp(struct pf_state **, int,
			    struct pfi_kif *, struct mbuf *,
d203 3
a205 4
			    struct mbuf *, int, struct pfi_kif *, u_int16_t,
			    u_int16_t, int, int *, int, int);
int			 pf_test_state_icmp(struct pf_state **, int,
			    struct pfi_kif *, struct mbuf *,
d207 2
a208 2
int			 pf_test_state_other(struct pf_state **, int,
			    struct pfi_kif *, struct mbuf *, struct pf_pdesc *);
d237 1
a237 2
void			 pf_counters_inc(int, int,
			    struct pf_pdesc *, struct pfi_kif *,
d2429 1
a2429 1
pf_socket_lookup(int direction, struct pf_pdesc *pd)
d2459 1
a2459 1
	if (direction == PF_IN) {
d2735 2
a2736 3
pf_test_rule(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct pfi_kif *kif, struct mbuf *m, struct pf_pdesc *pd,
    struct pf_rule **am, struct pf_ruleset **rsm)
d2770 1
a2770 1
	if (direction == PF_IN && pf_check_congestion(ifq)) {
d2814 1
a2814 1
		PF_TEST_ATTRIB((pfi_kif_match(r->kif, kif) == r->ifnot),
d2816 1
a2816 1
		PF_TEST_ATTRIB((r->direction && r->direction != direction),
d2826 1
a2826 1
		    r->src.neg, kif, act.rtableid)),
d2869 1
a2869 1
			    pf_socket_lookup(direction, pd), 1)) &&
d2876 1
a2876 1
			    pf_socket_lookup(direction, pd), 1)) &&
d2929 2
a2930 2
					PFLOG_PACKET(kif, m, direction,
					    reason, r, a, ruleset, pd);
d2937 2
a2938 2
					PFLOG_PACKET(kif, m, direction,
					    reason, r, a, ruleset, pd);
d2966 1
a2966 1
		PFLOG_PACKET(kif, m, direction, reason, r, a, ruleset, pd);
d2991 1
a2991 1
				    pd->eh, kif->pfik_ifp);
d3033 2
a3034 2
		action = pf_create_state(r, a, nr, pd, &skw, &sks, m,
		    &rewrite, kif, sm, tag, &rules, &act, sns);
d3063 1
a3063 1
	    direction == PF_OUT && pfsync_up()) {
d3092 3
a3094 3
    struct mbuf *m, int *rewrite, struct pfi_kif *kif,
    struct pf_state **sm, int tag, struct pf_rule_slist *rules,
    struct pf_rule_actions *act, struct pf_src_node *sns[PF_SN_MAX])
d3214 1
a3214 1
	if (pf_state_insert(BOUND_IFACE(r, kif), *skw, *sks, s)) {
d3408 2
a3409 2
	struct pf_state **state, struct pfi_kif *kif, struct mbuf *m,
	struct pf_pdesc *pd, u_short *reason, int *copyback)
d3698 1
a3698 1
				    pd->rdomain, pd->eh, kif->pfik_ifp);
d3800 2
a3801 2
pf_test_state_tcp(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, struct pf_pdesc *pd, u_short *reason)
d3812 1
a3812 1
	if (direction == PF_IN)	{	/* wire side, straight */
d3824 1
a3824 1
	STATE_LOOKUP(kif, &key, direction, *state, m);
d3826 1
a3826 1
	if (direction == (*state)->direction) {
d3837 1
a3837 1
		if (direction != (*state)->direction) {
d3866 1
a3866 1
		if (direction == (*state)->direction) {
d3939 1
a3939 1
		if (pf_tcp_track_full(src, dst, state, kif, m, pd, reason,
d3971 1
a3971 2
pf_test_state_udp(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, struct pf_pdesc *pd)
d3980 1
a3980 1
	if (direction == PF_IN)	{	/* wire side, straight */
d3992 1
a3992 1
	STATE_LOOKUP(kif, &key, direction, *state, m);
d3994 1
a3994 1
	if (direction == (*state)->direction) {
d4039 2
a4040 3
    struct pf_state **state, struct mbuf *m, int direction, struct pfi_kif *kif,
    u_int16_t icmpid, u_int16_t type, int icmp_dir, int *iidx, int multi,
    int inner)
d4074 1
a4074 1
	STATE_LOOKUP(kif, key, direction, *state, m);
d4078 2
a4079 2
	    (((!inner && (*state)->direction == direction) ||
	    (inner && (*state)->direction != direction)) ?
d4094 2
a4095 2
pf_test_state_icmp(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, struct pf_pdesc *pd, u_short *reason)
d4126 2
a4127 2
		ret = pf_icmp_state_lookup(&key, pd, state, m, direction,
		    kif, virtual_id, virtual_type, icmp_dir, &iidx,
d4133 2
a4134 2
				    direction, kif, virtual_id, virtual_type,
				    icmp_dir, &iidx, multi, 0);
d4223 2
d4226 2
d4230 2
a4231 2
		pd2.sidx = (direction == PF_IN) ? 1 : 0;
		pd2.didx = (direction == PF_IN) ? 0 : 1;
d4314 1
a4314 1
			STATE_LOOKUP(kif, &key, direction, *state, m);
d4316 1
a4316 1
			if (direction == (*state)->direction) {
d4440 1
a4440 1
			STATE_LOOKUP(kif, &key, direction, *state, m);
d4515 2
a4516 2
			    direction, kif, virtual_id, virtual_type,
			    icmp_dir, &iidx, PF_ICMP_MULTI_NONE, 1);
d4580 2
a4581 2
			    direction, kif, virtual_id, virtual_type,
			    icmp_dir, &iidx, PF_ICMP_MULTI_NONE, 1);
d4586 1
a4586 2
					    state, m, direction, kif,
					    virtual_id, virtual_type,
d4645 1
a4645 1
			STATE_LOOKUP(kif, &key, direction, *state, m);
d4698 2
a4699 2
pf_test_state_other(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, struct pf_pdesc *pd)
d4707 1
a4707 1
	if (direction == PF_IN)	{
d4717 1
a4717 1
	STATE_LOOKUP(kif, &key, direction, *state, m);
d4719 1
a4719 1
	if (direction == (*state)->direction) {
d5568 3
a5570 2
pf_setup_pdesc(sa_family_t af, int dir, struct pf_pdesc *pd, void *pdhdrs,
    struct mbuf **m0, u_short *action, u_short *reason)
d5578 1
d5799 1
a5799 2
pf_counters_inc(int dir, int action, struct pf_pdesc *pd,
    struct pfi_kif *kif, struct pf_state *s,
d5803 4
a5806 3
	kif->pfik_bytes[pd->af == AF_INET6][dir == PF_OUT][action != PF_PASS]
	    += pd->tot_len;
	kif->pfik_packets[pd->af == AF_INET6][dir == PF_OUT][action != PF_PASS]++;
d5809 1
a5809 1
		dirndx = (dir == PF_OUT);
d5824 1
a5824 1
			dirndx = (dir == s->direction) ? 0 : 1;
d5838 1
a5838 1
			    pd->af, pd->tot_len, dir == PF_OUT,
d5845 1
a5845 1
			    pd->af, pd->tot_len, dir == PF_OUT,
d5897 2
a5898 1
	if (pf_setup_pdesc(af, dir, &pd, &pdhdrs, m0, &action, &reason) == -1) {
d5915 1
a5915 1
		action = pf_test_rule(&r, &s, dir, kif, m, &pd, &a, &ruleset);
d5924 1
a5924 1
		action = pf_normalize_tcp(dir, m, &pd);
d5927 1
a5927 1
		action = pf_test_state_tcp(&s, dir, kif, m, &pd, &reason);
d5936 1
a5936 2
			action = pf_test_rule(&r, &s, dir, kif,
			    m, &pd, &a, &ruleset);
d5948 1
a5948 1
		action = pf_test_state_udp(&s, dir, kif, m, &pd);
d5957 1
a5957 2
			action = pf_test_rule(&r, &s, dir, kif,
			    m, &pd, &a, &ruleset);
d5969 1
a5969 1
		action = pf_test_state_icmp(&s, dir, kif, m, &pd, &reason);
d5978 1
a5978 2
			action = pf_test_rule(&r, &s, dir, kif,
			    m, &pd, &a, &ruleset);
d5990 1
a5990 1
		action = pf_test_state_icmp(&s, dir, kif, m, &pd, &reason);
d5999 1
a5999 2
			action = pf_test_rule(&r, &s, dir, kif,
			    m, &pd, &a, &ruleset);
d6004 1
a6004 1
		action = pf_test_state_other(&s, dir, kif, m, &pd);
d6013 1
a6013 2
			action = pf_test_rule(&r, &s, dir, kif,
			    m, &pd, &a, &ruleset);
d6057 1
a6057 1
	if (dir == PF_IN && s && s->key[PF_SK_STACK])
d6078 1
a6078 1
	if (pd.destchg && dir == PF_OUT)
d6081 1
a6081 1
	if (dir == PF_IN && action == PF_PASS && r->divert.port) {
d6105 1
a6105 1
			PFLOG_PACKET(kif, m, dir, reason, r, a, ruleset, &pd);
d6109 1
a6109 1
					PFLOG_PACKET(kif, m, dir, reason,
d6114 1
a6114 1
	pf_counters_inc(dir, action, &pd, kif, s, r, a);
d6125 1
a6125 1
			divert_packet(m, dir);
d6128 1
a6128 1
			divert6_packet(m, dir);
d6137 1
a6137 1
				pf_route(m0, r, dir, kif->pfik_ifp, s);
d6140 1
a6140 1
				pf_route6(m0, r, dir, kif->pfik_ifp, s);
@


1.776
log
@Move the pdesc initialization code into pf_setup_pdesc().  Unify
some IPv4 and IPv6 code.  Make sure that both code paths set the
same fields in the same order.
ok mpf henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.775 2011/09/18 10:40:55 bluhm Exp $ */
d155 2
a156 2
int			 pf_modulate_sack(struct mbuf *, int, struct pf_pdesc *,
			    struct tcphdr *, struct pf_state_peer *);
d181 1
a181 1
			    int, struct pfi_kif *, struct mbuf *, int,
d183 1
a183 1
			    struct pf_ruleset **, int);
d187 1
a187 1
			    struct mbuf *, int, int *, struct pfi_kif *,
d194 1
a194 1
			    struct pfi_kif *, struct mbuf *, int,
d200 1
a200 1
			    struct pfi_kif *, struct mbuf *, int,
d203 1
a203 1
			    struct pfi_kif *, struct mbuf *, int,
d210 1
a210 1
			    struct pfi_kif *, struct mbuf *, int,
d218 2
a219 4
u_int8_t		 pf_get_wscale(struct mbuf *, int, u_int16_t,
			    sa_family_t);
u_int16_t		 pf_get_mss(struct mbuf *, int, u_int16_t,
			    sa_family_t);
d1880 1
a1880 2
pf_modulate_sack(struct mbuf *m, int off, struct pf_pdesc *pd,
    struct tcphdr *th, struct pf_state_peer *dst)
d1882 1
d1889 2
a1890 2
	if (hlen < TCPOLEN_SACKLEN ||
	    !pf_pull_hdr(m, off + sizeof(*th), opts, hlen, NULL, NULL, pd->af))
d1928 1
a1928 1
		m_copyback(m, off + sizeof(*th), thoptlen, opts, M_NOWAIT);
d2517 1
a2517 1
pf_get_wscale(struct mbuf *m, int off, u_int16_t th_off, sa_family_t af)
d2519 1
d2525 1
a2525 1
	hlen = th_off << 2;		/* hlen <= sizeof(hdr) */
d2528 1
a2528 1
	if (!pf_pull_hdr(m, off, hdr, hlen, NULL, NULL, af))
d2558 1
a2558 1
pf_get_mss(struct mbuf *m, int off, u_int16_t th_off, sa_family_t af)
d2560 1
d2566 1
a2566 1
	hlen = th_off << 2;	/* hlen <= sizeof(hdr) */
d2569 1
a2569 1
	if (!pf_pull_hdr(m, off, hdr, hlen, NULL, NULL, af))
d2742 2
a2743 3
    struct pfi_kif *kif, struct mbuf *m, int off,
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    int hdrlen)
a2745 1
	sa_family_t		 af = pd->af;
d2773 1
a2773 1
	if (af == AF_INET6)
d2828 1
a2828 1
		PF_TEST_ATTRIB((r->af && r->af != af),
d2832 1
a2832 1
		PF_TEST_ATTRIB((PF_MISMATCHAW(&r->src.addr, &pd->nsaddr, af,
d2835 1
a2835 1
		PF_TEST_ATTRIB((PF_MISMATCHAW(&r->dst.addr, &pd->ndaddr, af,
d2858 1
a2858 1
			    !pf_osfp_match(pf_osfp_fingerprint(pd, m, off, th),
a2984 3
			int		 len = 0;
			struct ip	*h4;
			struct ip6_hdr	*h6;
d2986 2
a2987 12
			switch (af) {
			case AF_INET:
				h4 = mtod(m, struct ip *);
				len = ntohs(h4->ip_len) - off;
				break;
			case AF_INET6:
				h6 = mtod(m, struct ip6_hdr *);
				len = ntohs(h6->ip6_plen) - (off - sizeof(*h6));
				break;
			}

			if (pf_check_proto_cksum(m, off, len, IPPROTO_TCP, af))
d2994 1
a2994 1
				pf_send_tcp(r, af, pd->dst,
d3001 1
a3001 1
		    ICMP_INFOTYPE(icmptype)) && af == AF_INET &&
d3004 1
a3004 1
			    r->return_icmp & 255, af, r, pd->rdomain);
d3007 1
a3007 1
		    icmptype != ND_REDIRECT)) && af == AF_INET6 &&
d3010 1
a3010 1
			    r->return_icmp6 & 255, af, r, pd->rdomain);
d3040 1
a3040 1
		action = pf_create_state(r, a, nr, pd, &skw, &sks, m, off,
d3065 2
a3066 2
	if (rewrite && hdrlen)
		m_copyback(m, off, hdrlen, pd->hdr.any, M_NOWAIT);
d3099 1
a3099 1
    struct mbuf *m, int off, int *rewrite, struct pfi_kif *kif,
d3161 1
a3161 2
			s->src.wscale = pf_get_wscale(m, off,
			    th->th_off, pd->af);
d3201 1
a3201 1
		    pf_normalize_tcp_init(m, off, pd, th, &s->src, &s->dst)) {
d3206 1
a3206 1
		    pf_normalize_tcp_stateful(m, off, pd, &reason, th, s,
d3261 1
a3261 1
		mss = pf_get_mss(m, off, th->th_off, pd->af);
d3415 1
a3415 1
	struct pf_state **state, struct pfi_kif *kif, struct mbuf *m, int off,
d3442 1
a3442 1
			if (pf_normalize_tcp_init(m, off, pd, th, src, dst)) {
d3466 1
a3466 2
				src->wscale = pf_get_wscale(m, off, th->th_off,
				    pd->af);
d3553 1
a3553 1
		if (pf_modulate_sack(m, off, pd, th, dst))
d3572 1
a3572 1
			if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
d3669 1
a3669 1
			if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
d3808 1
a3808 2
    struct mbuf *m, int off, struct pf_pdesc *pd,
    u_short *reason)
d3946 1
a3946 1
		if (pf_tcp_track_full(src, dst, state, kif, m, off, pd, reason,
d3972 1
a3972 1
		m_copyback(m, off, sizeof(*th), th, M_NOWAIT);
d3979 1
a3979 1
    struct mbuf *m, int off, struct pf_pdesc *pd)
d4039 1
a4039 1
		m_copyback(m, off, sizeof(*uh), uh, M_NOWAIT);
d4104 1
a4104 1
    struct mbuf *m, int off, struct pf_pdesc *pd, u_short *reason)
d4186 1
a4186 1
				m_copyback(m, off, ICMP_MINLEN,
d4206 1
a4206 2
				m_copyback(m, off,
				    sizeof(struct icmp6_hdr),
a4230 1
		int		off2;
d4241 1
a4241 1
			ipoff2 = off + ICMP_MINLEN;
d4259 1
a4259 1
			off2 = ipoff2 + (h2.ip_hl << 2);
d4269 1
a4269 1
			ipoff2 = off + sizeof(struct icmp6_hdr);
d4278 2
a4279 2
			off2 = ipoff2;
			if (pf_walk_header6(m, &h2_6, &off2, &extoff2,
d4304 1
a4304 1
			if (!pf_pull_hdr(m, off2, &th, 8, NULL, reason,
d4405 1
a4405 1
					m_copyback(m, off, ICMP_MINLEN,
d4413 1
a4413 1
					m_copyback(m, off,
d4421 1
a4421 1
				m_copyback(m, off2, 8, &th, M_NOWAIT);
d4430 1
a4430 1
			if (!pf_pull_hdr(m, off2, &uh, sizeof(uh),
d4477 1
a4477 1
					m_copyback(m, off, ICMP_MINLEN,
d4485 1
a4485 1
					m_copyback(m, off,
d4493 2
a4494 1
				m_copyback(m, off2, sizeof(uh), &uh, M_NOWAIT);
d4508 1
a4508 1
			if (!pf_pull_hdr(m, off2, &iih, ICMP_MINLEN,
d4554 2
a4555 2
				m_copyback(m, off, ICMP_MINLEN, pd->hdr.icmp,
				    M_NOWAIT);
d4558 1
a4558 1
				m_copyback(m, off2, ICMP_MINLEN, &iih,
d4574 1
a4574 1
			if (!pf_pull_hdr(m, off2, &iih,
d4632 1
a4632 1
				m_copyback(m, off, sizeof(struct icmp6_hdr),
d4636 1
a4636 1
				m_copyback(m, off2, sizeof(struct icmp6_hdr),
d4679 1
a4679 1
					m_copyback(m, off, ICMP_MINLEN,
d4687 1
a4687 1
					m_copyback(m, off,
d5575 1
a5575 1
    struct mbuf **m0, u_short *action, u_short *reason, int *off, int *hdrlen)
a5584 2
	*off = 0;
	*hdrlen = 0;
d5586 1
a5586 1
	switch (af) {
d5599 1
a5599 1
		*off = h->ip_hl << 2;
d5601 2
a5602 2
		if (*off < (int)sizeof(struct ip) ||
		    *off > ntohs(h->ip_len) ||
d5623 1
a5623 1
		*off = h->ip_hl << 2;
d5655 1
a5655 1
		*off = 0;
d5664 1
a5664 1
		if (pf_walk_header6(m, h, off, &extoff, &fragoff, &nxt,
d5686 1
a5686 1
			*off = 0;
d5688 2
a5689 2
			if (pf_walk_header6(m, h, off, &extoff, &fragoff, &nxt,
			    &jumbolen, reason) != PF_PASS) {
d5721 1
a5721 1
		panic("pf_setup_pdesc called with illegal af %u", af);
d5732 2
a5733 1
		if (!pf_pull_hdr(m, *off, th, sizeof(*th), action, reason, af))
d5735 2
a5736 2
		*hdrlen = sizeof(*th);
		pd->p_len = pd->tot_len - *off - (th->th_off << 2);
d5744 2
a5745 1
		if (!pf_pull_hdr(m, *off, uh, sizeof(*uh), action, reason, af))
d5747 1
a5747 1
		*hdrlen = sizeof(*uh);
d5749 1
a5749 1
		    ntohs(uh->uh_ulen) > m->m_pkthdr.len - *off ||
d5760 2
a5761 2
		if (!pf_pull_hdr(m, *off, pd->hdr.icmp, ICMP_MINLEN,
		    action, reason, af))
d5763 1
a5763 1
		*hdrlen = ICMP_MINLEN;
d5770 2
a5771 2
		if (!pf_pull_hdr(m, *off, pd->hdr.icmp6, icmp_hlen,
		    action, reason, af))
d5785 2
a5786 2
		    !pf_pull_hdr(m, *off, pd->hdr.icmp6, icmp_hlen,
		    action, reason, af))
d5788 1
a5788 1
		*hdrlen = icmp_hlen;
a5865 1
	int			 off, hdrlen;
d5901 1
a5901 2
	if (pf_setup_pdesc(af, dir, &pd, &pdhdrs, m0, &action, &reason, &off,
	    &hdrlen) == -1) {
d5918 1
a5918 2
		action = pf_test_rule(&r, &s, dir, kif,
		    m, off, &pd, &a, &ruleset, hdrlen);
d5927 1
a5927 1
		action = pf_normalize_tcp(dir, m, off, &pd);
d5930 1
a5930 2
		action = pf_test_state_tcp(&s, dir, kif, m, off, &pd,
		    &reason);
d5940 1
a5940 1
			    m, off, &pd, &a, &ruleset, hdrlen);
d5944 1
a5944 1
				pf_normalize_mss(m, off, &pd, s->max_mss);
d5946 1
a5946 1
			pf_normalize_mss(m, off, &pd, r->max_mss);
d5952 1
a5952 1
		action = pf_test_state_udp(&s, dir, kif, m, off, &pd);
d5962 1
a5962 1
			    m, off, &pd, &a, &ruleset, hdrlen);
d5967 1
a5967 1
		if (af != AF_INET) {
d5974 1
a5974 2
		action = pf_test_state_icmp(&s, dir, kif, m, off, &pd,
		    &reason);
d5984 1
a5984 1
			    m, off, &pd, &a, &ruleset, hdrlen);
d5989 1
a5989 1
		if (af != AF_INET6) {
d5996 1
a5996 2
		action = pf_test_state_icmp(&s, dir, kif, m, off, &pd,
		    &reason);
d6006 1
a6006 1
			    m, off, &pd, &a, &ruleset, hdrlen);
d6020 2
a6021 2
			action = pf_test_rule(&r, &s, dir, kif, m, off,
			    &pd, &a, &ruleset, hdrlen);
d6081 3
a6083 3
		if ((af == AF_INET && (ntohl(pd.dst->v4.s_addr) >>
		    IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) || (af == AF_INET6 &&
		    IN6_IS_ADDR_LOOPBACK(&pd.dst->v6)))
d6132 1
a6132 1
		if (af == AF_INET)
d6135 1
a6135 1
		if (af == AF_INET6)
d6144 1
a6144 1
			if (af == AF_INET)
d6147 1
a6147 1
			if (af == AF_INET6)
@


1.775
log
@Move the call to pf_test_rule() for fragments that have not been
reassembled by normalization from pf_setup_pdesc() to pf_test().
This simplifies the paramter list of pf_setup_pdesc() as it can
concentrate on its job filling the pf_pdesc struct.
ok henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.774 2011/09/17 16:01:55 bluhm Exp $ */
d127 4
a130 1
/* cannot fold into pf_pdesc directly, unknown storage size outside pf.c */
d5593 2
a5594 2
pf_setup_pdesc(sa_family_t af, int dir, struct pf_pdesc *pd, struct mbuf **m0,
    u_short *action, u_short *reason, int *off, int *hdrlen)
d5598 8
a5605 2
	if (pd->hdr.any == NULL)
		panic("pf_setup_pdesc: no storage for headers provided");
a5606 2
	*hdrlen = 0;
	pd->af = af;
a5647 1
		pd->sport = pd->dport = NULL;
d5649 1
a5649 3
		pd->dir = dir;
		pd->sidx = (dir == PF_IN) ? 0 : 1;
		pd->didx = (dir == PF_IN) ? 1 : 0;
a5650 1
		pd->tot_len = ntohs(h->ip_len);
d5730 2
a5731 4
		pd->sport = pd->dport = NULL;
		pd->dir = dir;
		pd->sidx = (dir == PF_IN) ? 0 : 1;
		pd->didx = (dir == PF_IN) ? 1 : 0;
d5733 1
a5733 2
		pd->tot_len = ntohs(h->ip6_plen) + sizeof(struct ip6_hdr);
		pd->virtual_proto = pd->proto = nxt;
d5884 1
a5884 1
	union pf_headers	 hdrs;
a5891 2
	memset(&pd, 0, sizeof(pd));
	pd.hdr.any = &hdrs;
d5921 2
a5922 2
	if (pf_setup_pdesc(af, dir, &pd, m0, &action, &reason, &off, &hdrlen)
	    == -1) {
@


1.774
log
@The pd->ip_sum and pd->proto_sum fields are not needed.  Replace
the one occurrence in pf_test_state_icmp() that uses pd2.ip_sum by
a local variable.  Remove ip_sum and proto_sum from struct pf_pdesc.
ok claudio henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.773 2011/09/17 11:34:49 henning Exp $ */
d5591 1
a5591 3
    u_short *action, u_short *reason, struct pfi_kif *kif, struct pf_rule **a,
    struct pf_rule **r, struct pf_state **s, struct pf_ruleset **ruleset,
    int *off, int *hdrlen)
a5749 13
	case PF_VPROTO_FRAGMENT:
		/*
		 * handle fragments that aren't reassembled by
		 * normalization
		 */
		if (kif == NULL || r == NULL)	/* pflog */
			*action = PF_DROP;
		else
			*action = pf_test_rule(r, s, dir, kif,
			    m, *off, pd, a, ruleset, *hdrlen);
		if (*action != PF_PASS)
			REASON_SET(reason, PFRES_FRAG);
		return (-1);
d5923 2
a5924 2
	if (pf_setup_pdesc(af, dir, &pd, m0, &action, &reason, kif, &a, &r, &s,
	    &ruleset, &off, &hdrlen) == -1) {
d5934 13
a5946 1
	switch (pd.proto) {
@


1.773
log
@move initialisation of pd->nsaddr and pd->ndaddr from pf_test_rule to
pf_setup_pdesc. fixes logging of packets passed statefully. ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.772 2011/09/17 10:12:37 bluhm Exp $ */
d4245 1
d4281 1
a4281 1
			pd2.ip_sum = &h2.ip_sum;
d4303 1
a4303 1
			pd2.ip_sum = NULL;
d4401 1
a4401 1
					    pd2.ip_sum, icmpsum, 0, pd2.af);
d4414 1
a4414 1
					    pd2.ip_sum, icmpsum, 0, pd2.af);
d4476 1
a4476 1
					    pd2.ip_sum, icmpsum, 1, pd2.af);
d4489 1
a4489 1
					    pd2.ip_sum, icmpsum, 1, pd2.af);
d4557 1
a4557 1
					    pd2.ip_sum, icmpsum, 0, AF_INET);
d4568 1
a4568 1
					    pd2.ip_sum, icmpsum, 0, AF_INET);
d4635 1
a4635 1
					    pd2.ip_sum, icmpsum, 0, AF_INET6);
d4646 1
a4646 1
					    pd2.ip_sum, icmpsum, 0, AF_INET6);
d4679 1
a4679 1
					    pd2.ip_sum, icmpsum, 0, pd2.af);
d4690 1
a4690 1
					    pd2.ip_sum, icmpsum, 0, pd2.af);
a5643 2
		pd->ip_sum = &h->ip_sum;
		pd->proto_sum = NULL;
a5729 2
		pd->ip_sum = NULL;
		pd->proto_sum = NULL;
@


1.772
log
@Deduplicate IPv4 and IPv6 code that handles fragments that have not
been reassembled by normalization.
ok henning claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.771 2011/08/30 00:40:47 mikeb Exp $ */
a2764 3
	PF_ACPY(&pd->nsaddr, pd->src, pd->af);
	PF_ACPY(&pd->ndaddr, pd->dst, pd->af);

a2781 8
	case IPPROTO_TCP:
		pd->nsport = th->th_sport;
		pd->ndport = th->th_dport;
		break;
	case IPPROTO_UDP:
		pd->nsport = pd->hdr.udp->uh_sport;
		pd->ndport = pd->hdr.udp->uh_dport;
		break;
a2811 3
	default:
		pd->nsport = pd->ndport = 0;
		break;
d5751 3
d5830 6
@


1.771
log
@Add support for one shot rules that remove themselves from an active
ruleset after match.  In case this is the only rule in the anchor,
the anchor will be destroyed automatically after the rule is matched.
This is an extremely handy technique for firewall proxies.

ok henning, mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.770 2011/08/03 12:28:40 mpf Exp $ */
d5669 1
a5669 5
		if (h->ip_off & htons(IP_MF | IP_OFFMASK)) {
			/*
			 * handle fragments that aren't reassembled by
			 * normalization
			 */
d5671 1
a5671 9
			if (kif == NULL || r == NULL)	/* pflog */
				*action = PF_DROP;
			else
				*action = pf_test_rule(r, s, dir, kif,
				    m, *off, pd, a, ruleset, *hdrlen);
			if (*action != PF_PASS)
				REASON_SET(reason, PFRES_FRAG);
			return (-1);
		}
d5754 1
a5754 5
		if (fragoff != 0) {
			/*
			 * handle fragments that aren't reassembled by
			 * normalization
			 */
d5756 1
a5756 9
			if (kif == NULL || r == NULL)	/* pflog */
				*action = PF_DROP;
			else
				*action = pf_test_rule(r, s, dir, kif,
				    m, *off, pd, a, ruleset, *hdrlen);
			if (*action != PF_PASS)
				REASON_SET(reason, PFRES_FRAG);
			return (-1);
		}
d5765 14
a5778 1
	switch (pd->proto) {
@


1.770
log
@Remove redundant prototype for pf_socket_lookup().
It's already in pfvar.h
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.769 2011/07/27 00:26:10 mcbride Exp $ */
d3107 3
@


1.769
log
@Add support for weighted round-robin in load balancing pools and tables.
Diff from zinke@@ with a some minor cleanup.
ok henning claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.768 2011/07/24 12:13:10 mcbride Exp $ */
a214 1
int			 pf_socket_lookup(int, struct pf_pdesc *);
@


1.768
log
@OS fingerprinting can only be done on rules that explicitly specify TCP
now, put it in the IPPROTO_TCP case of the pf_test_rule() inner loop.

ok henning sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.767 2011/07/23 21:17:47 bluhm Exp $ */
d2945 1
a2945 1
				if (pf_get_transaddr(r, pd, sns) == -1) {
a2948 6
				/* 
				 * We need to save this rule pointer, 
				 * otherwise the counter decrease
				 * would not work for SLB.
				 */
				nr = r;
d2980 1
a2980 1
	if (pf_get_transaddr(r, pd, sns) == -1) {
@


1.767
log
@Replace the IPv6 header walking loop in pf_test_state_icmp() with
the common function pf_walk_header6().  For that, pf_walk_header6()
can now extract both the information wether it is a fragment and
the final protocol if it is the first fragment.  This allows to
match the icmp6 too big packet of a first fragment to the reassembled
packet's state.  This is neccesary if a refragmented fragment is
to big for the Path-MTU.
Note that pd.proto contains the real protocol number for the first
fragment and IPPROTO_FRAGMENT for later fragments.  pd.virtual_protocol
is set to PF_VPROTO_FRAGMENT for all fragments.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.766 2011/07/22 14:57:31 mcbride Exp $ */
d2871 4
a2918 5
			TAILQ_NEXT(r, entries));
		PF_TEST_ATTRIB((r->os_fingerprint != PF_OSFP_ANY &&
		    (pd->virtual_proto != IPPROTO_TCP || !pf_osfp_match(
		    pf_osfp_fingerprint(pd, m, off, th),
		    r->os_fingerprint))),
@


1.766
log
@Sync 'block return' behaviour for ICMP packets with our IP stack:
Rather than silently dropping ALL icmp packets, return icmp/icmp6 error
for 'informational' message types (but continue dropping ICMP errors
unconditionally).

ok markus sthen henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.765 2011/07/22 13:05:29 henning Exp $ */
d229 2
a230 2
int			 pf_walk_header6(struct mbuf *, u_int8_t *, int *,
			    int *, u_int32_t *, u_short *);
d4261 2
a4262 1
		int		terminal = 0;
d4312 7
a4318 1
			pd2.proto = h2_6.ip6_nxt;
a4321 37
			off2 = ipoff2 + sizeof(h2_6);
			do {
				switch (pd2.proto) {
				case IPPROTO_FRAGMENT:
					/*
					 * ICMPv6 error messages for
					 * non-first fragments
					 */
					REASON_SET(reason, PFRES_FRAG);
					return (PF_DROP);
				case IPPROTO_AH:
				case IPPROTO_HOPOPTS:
				case IPPROTO_ROUTING:
				case IPPROTO_DSTOPTS: {
					/* get next header and header length */
					struct ip6_ext opt6;

					if (!pf_pull_hdr(m, off2, &opt6,
					    sizeof(opt6), NULL, reason,
					    pd2.af)) {
						DPFPRINTF(LOG_NOTICE,
						    "ICMPv6 short opt");
						return (PF_DROP);
					}
					if (pd2.proto == IPPROTO_AH)
						off2 += (opt6.ip6e_len + 2) * 4;
					else
						off2 += (opt6.ip6e_len + 1) * 8;
					pd2.proto = opt6.ip6e_nxt;
					/* goto the next header */
					break;
				}
				default:
					terminal++;
					break;
				}
			} while (!terminal);
d5493 2
a5494 2
pf_walk_header6(struct mbuf *m, u_int8_t *nxt, int *off, int *extoff,
    u_int32_t *jumbolen, u_short *reason)
d5496 1
a5498 1
	struct ip6_hdr		*h = mtod(m, struct ip6_hdr *);
d5501 2
a5503 2
	*off = sizeof(struct ip6_hdr);
	*extoff = 0;
d5508 5
d5519 12
a5530 1
			return (PF_PASS);
d5540 6
d5560 6
d5568 4
a5571 2
			*extoff = *off;
			if (*nxt == IPPROTO_HOPOPTS) {
d5589 12
d5695 1
a5695 1
		int		 extoff;
d5707 1
d5716 2
a5717 2
		if (pf_walk_header6(m, &nxt, off, &extoff, &jumbolen, reason)
		    != PF_PASS) {
d5722 1
a5722 1
		if (pf_status.reass && nxt == IPPROTO_FRAGMENT) {
d5724 2
a5725 2
			if (pf_normalize_ip6(m0, dir, *off, extoff, reason) !=
			    PF_PASS) {
d5736 6
a5741 3
			/* recalc offset, refetch header, then update pd */
			if (pf_walk_header6(m, &nxt, off, &extoff, &jumbolen,
			    reason) != PF_PASS) {
a5744 1
			h = mtod(m, struct ip6_hdr *);
d5771 1
a5771 1
		if (pd->proto == IPPROTO_FRAGMENT) {
@


1.765
log
@fix typos, martin pelikan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.764 2011/07/09 17:42:19 bluhm Exp $ */
d3034 2
a3035 1
		} else if (pd->proto != IPPROTO_ICMP && af == AF_INET &&
d3039 3
a3041 1
		else if (pd->proto != IPPROTO_ICMPV6 && af == AF_INET6 &&
@


1.764
log
@If ipv4+icmp6 or ipv6+icmp packets were embedded into an icmp
payload, we missed to drop them.  While there, also add a reason
to the corresponding check in pf_test().
ok mcbride@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.763 2011/07/08 18:50:51 henning Exp $ */
d2595 1
a2595 1
pf_calc_mss(struct pf_addr *addr, sa_family_t af, int rtabelid, u_int16_t offer)
d2618 1
a2618 1
		ro.ro_tableid = rtabelid;
d2631 1
a2631 1
		ro6.ro_tableid = rtabelid;
@


1.763
log
@surprisingly, we use pf as classifier for the new priority queueing
implementation. ok ryan mpf sthen and also testing pea and halex looked
at it and commented as well
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.762 2011/07/07 20:46:36 bluhm Exp $ */
d4564 5
d4630 5
d6001 1
a6001 1
		if (af == AF_INET6) {
d6003 1
d6024 1
a6024 1
		if (af == AF_INET) {
d6026 1
@


1.762
log
@There were two loops in pf_setup_pdesc() and pf_normalize_ip6()
walking over the IPv6 header chain.  Merge them into one loop,
adjust some length checks and fix IPv6 jumbo option handling.  Also
allow strange but legal IPv6 packets with plen=0 passing through
pf.  IPv6 jumbo packets still get dropped.
testing dhill@@; ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.761 2011/07/07 00:47:18 mcbride Exp $ */
d1976 2
d2100 2
d2724 4
d2770 1
d3170 2
d6065 1
a6065 1
			if (pqid || (pd.tos & IPTOS_LOWDELAY))
d6067 3
a6069 1
			else
d6071 3
d6077 1
a6077 1
			if (pqid || (pd.tos & IPTOS_LOWDELAY))
d6079 3
a6081 1
			else
d6083 3
@


1.761
log
@Fold pf_test_fragment() into pf_test_rule(), reduce code and fixes
a bunch of bugs with fragment handling not being in sync with the
rest of the ruleset.

Much feedback from mpf, bluhm & markus
Thanks to Tony Sarendal for help with testing

ok bluhm; various previous versions ok henning, claudio, mpf, markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.760 2011/07/05 19:53:43 mikeb Exp $ */
d227 4
d5436 136
d5659 3
a5661 1
		int		 terminal = 0;
d5670 4
a5673 2
		/* packet reassembly */
		if (pf_normalize_ip6(m0, dir, reason) != PF_PASS) {
d5675 1
d5678 4
a5681 4
		m = *m0;
		if (m == NULL) {
			/* packet sits in reassembly queue, no error */
			*action = PF_PASS;
d5685 23
a5707 1
		h = mtod(m, struct ip6_hdr *);
d5713 1
a5713 1
		if (htons(h->ip6_plen) == 0) {
d5730 1
a5730 16
		*off = ((caddr_t)h - m->m_data) + sizeof(struct ip6_hdr);
		pd->virtual_proto = pd->proto = h->ip6_nxt;
		do {
			switch (pd->proto) {
			case IPPROTO_FRAGMENT:
				pd->virtual_proto = PF_VPROTO_FRAGMENT;
				if (kif == NULL || r == NULL)	/* pflog */
					*action = PF_DROP;
				else
					*action = pf_test_rule(r, s, dir, kif,
					    m, *off, pd, a, ruleset, *hdrlen);
				if (*action != PF_PASS)
					REASON_SET(reason, PFRES_FRAG);
				return (-1);
			case IPPROTO_ROUTING: {
				struct ip6_rthdr rthdr;
d5732 15
a5746 50
				if (pd->badopts++) {
					DPFPRINTF(LOG_NOTICE,
					    "IPv6 more than one rthdr");
					*action = PF_DROP;
					REASON_SET(reason, PFRES_IPOPTIONS);
					return (-1);
				}
				if (!pf_pull_hdr(m, *off, &rthdr, sizeof(rthdr),
				    NULL, reason, pd->af)) {
					DPFPRINTF(LOG_NOTICE,
					    "IPv6 short rthdr");
					*action = PF_DROP;
					REASON_SET(reason, PFRES_SHORT);
					return (-1);
				}
				if (rthdr.ip6r_type == IPV6_RTHDR_TYPE_0) {
					DPFPRINTF(LOG_NOTICE,
					    "IPv6 rthdr0");
					*action = PF_DROP;
					REASON_SET(reason, PFRES_IPOPTIONS);
					return (-1);
				}
				/* FALLTHROUGH */
			}
			case IPPROTO_AH:
			case IPPROTO_HOPOPTS:
			case IPPROTO_DSTOPTS: {
				/* get next header and header length */
				struct ip6_ext	opt6;

				if (!pf_pull_hdr(m, *off, &opt6, sizeof(opt6),
				    NULL, reason, pd->af)) {
					DPFPRINTF(LOG_NOTICE,
					    "IPv6 short opt");
					*action = PF_DROP;
					return (-1);
				}
				if (pd->proto == IPPROTO_AH)
					*off += (opt6.ip6e_len + 2) * 4;
				else
					*off += (opt6.ip6e_len + 1) * 8;
				pd->virtual_proto = pd->proto = opt6.ip6e_nxt;
				/* goto the next header */
				break;
			}
			default:
				terminal++;
				break;
			}
		} while (!terminal);
@


1.760
log
@add missing ifdefs for INET6;  diff from form, ok henning, bluhm, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.759 2011/07/04 18:12:51 bluhm Exp $ */
a188 4
int			 pf_test_fragment(struct pf_rule **, int,
			    struct pfi_kif *, struct mbuf *,
			    struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
d1466 3
a1472 3
		if (cur->dst.neg != prev->dst.neg ||
		    pf_addr_wrap_neq(&cur->dst.addr, &prev->dst.addr))
			PF_SET_SKIP_STEPS(PF_SKIP_DST_ADDR);
d2718 8
d2772 1
a2772 1
	switch (pd->proto) {
d2812 1
a2812 1
		pd->nsport = pd->ndport;
d2822 83
a2904 59
		if (pfi_kif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->onrdomain >= 0  &&
		    (r->onrdomain == pd->rdomain) == r->ifnot)
			r = r->skip[PF_SKIP_RDOM].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, &pd->nsaddr, af,
		    r->src.neg, kif, act.rtableid))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		/* tcp/udp only. port_op always 0 in other cases */
		else if (r->src.port_op && !pf_match_port(r->src.port_op,
		    r->src.port[0], r->src.port[1], pd->nsport))
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, &pd->ndaddr, af,
		    r->dst.neg, NULL, act.rtableid))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		/* tcp/udp only. port_op always 0 in other cases */
		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
		    r->dst.port[0], r->dst.port[1], pd->ndport))
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		/* icmp only. type always 0 in other cases */
		else if (r->type && r->type != icmptype + 1)
			r = TAILQ_NEXT(r, entries);
		/* icmp only. type always 0 in other cases */
		else if (r->code && r->code != icmpcode + 1)
			r = TAILQ_NEXT(r, entries);
		else if (r->tos && !(r->tos == pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if (pd->proto == IPPROTO_TCP &&
		    (r->flagset & th->th_flags) != r->flags)
			r = TAILQ_NEXT(r, entries);
		/* tcp/udp only. uid.op always 0 in other cases */
		else if (r->uid.op && (pd->lookup.done || (pd->lookup.done =
		    pf_socket_lookup(direction, pd), 1)) &&
		    !pf_match_uid(r->uid.op, r->uid.uid[0], r->uid.uid[1],
		    pd->lookup.uid))
			r = TAILQ_NEXT(r, entries);
		/* tcp/udp only. gid.op always 0 in other cases */
		else if (r->gid.op && (pd->lookup.done || (pd->lookup.done =
		    pf_socket_lookup(direction, pd), 1)) &&
		    !pf_match_gid(r->gid.op, r->gid.gid[0], r->gid.gid[1],
		    pd->lookup.gid))
			r = TAILQ_NEXT(r, entries);
		else if (r->prob &&
		    r->prob <= arc4random_uniform(UINT_MAX - 1) + 1)
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag && !pf_match_tag(m, r, &tag))
			r = TAILQ_NEXT(r, entries);
		else if (r->rcv_kif && !pf_match_rcvif(m, r))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY &&
		    (pd->proto != IPPROTO_TCP || !pf_osfp_match(
d2906 52
a2957 1
		    r->os_fingerprint)))
d2959 3
a2961 40
		else {
			if (r->tag)
				tag = r->tag;
			if (r->anchor == NULL) {
				lastr = r;
				if (r->action == PF_MATCH) {
					if ((ri = pool_get(&pf_rule_item_pl,
					    PR_NOWAIT)) == NULL) {
						REASON_SET(&reason,
						    PFRES_MEMORY);
						goto cleanup;
					}
					ri->r = r;
					/* order is irrelevant */
					SLIST_INSERT_HEAD(&rules, ri, entry);
					pf_rule_to_actions(r, &act);
					if (pf_get_transaddr(r, pd, sns) ==
					    -1) {
						REASON_SET(&reason,
						    PFRES_MEMORY);
						goto cleanup;
					}
					/* 
					 * We need to save this rule pointer, 
					 * otherwise the counter decrease
					 * would not work for SLB.
					 */
					nr = r;
					if (r->log || act.log & PF_LOG_MATCHES)
						PFLOG_PACKET(kif, m, direction,
						    reason, r, a, ruleset, pd);
				} else {
					match = 1;
					*rm = r;
					*am = a;
					*rsm = ruleset;
					if (act.log & PF_LOG_MATCHES)
						PFLOG_PACKET(kif, m, direction,
						    reason, r, a, ruleset, pd);
				}
d2963 1
a2963 7
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				pf_step_into_anchor(&asd, &ruleset,
				    &r, &a, &match);
		}
d2983 2
a2984 1
	if ((r->action == PF_DROP) &&
d3047 2
a3048 1
	if (!state_icmp && r->keep_state) {
a3427 86
pf_test_fragment(struct pf_rule **rm, int direction, struct pfi_kif *kif,
    struct mbuf *m, struct pf_pdesc *pd, struct pf_rule **am,
    struct pf_ruleset **rsm)
{
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	sa_family_t		 af = pd->af;
	u_short			 reason;
	int			 tag = -1;
	int			 asd = 0;
	int			 match = 0;

	r = TAILQ_FIRST(pf_main_ruleset.rules.active.ptr);
	while (r != NULL) {
		r->evaluations++;
		if (pfi_kif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->onrdomain >= 0  &&
		    (r->onrdomain == pd->rdomain) == r->ifnot)
			r = r->skip[PF_SKIP_RDOM].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af,
		    r->src.neg, kif, pd->rdomain))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af,
		    r->dst.neg, NULL, pd->rdomain))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->tos && !(r->tos == pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
		else if (pd->proto == IPPROTO_UDP &&
		    (r->src.port_op || r->dst.port_op))
			r = TAILQ_NEXT(r, entries);
		else if (pd->proto == IPPROTO_TCP &&
		    (r->src.port_op || r->dst.port_op || r->flagset))
			r = TAILQ_NEXT(r, entries);
		else if ((pd->proto == IPPROTO_ICMP ||
		    pd->proto == IPPROTO_ICMPV6) &&
		    (r->type || r->code))
			r = TAILQ_NEXT(r, entries);
		else if (r->prob && r->prob <=
		    (arc4random() % (UINT_MAX - 1) + 1))
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag && !pf_match_tag(m, r, &tag))
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->anchor == NULL) {
				match = 1;
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				pf_step_into_anchor(&asd, &ruleset,
				    &r, &a, &match);
		}
		if (r == NULL && pf_step_out_of_anchor(&asd, &ruleset,
		    &r, &a, &match))
			break;
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&reason, PFRES_MATCH);

	if (r->log)
		PFLOG_PACKET(kif, m, direction, reason, r, a, ruleset, pd);

	if (r->action == PF_DROP)
		return (PF_DROP);

	pf_tag_packet(m, tag, -1);

	return (PF_PASS);
}

int
d5434 2
a5435 1
    struct pf_rule **r, struct pf_ruleset **ruleset, int *off, int *hdrlen)
d5488 1
a5488 1
		pd->proto = h->ip_p;
d5503 1
d5507 2
a5508 2
				*action = pf_test_fragment(r, dir, kif,
				     m, pd, a, ruleset);
d5564 1
a5564 1
		pd->proto = h->ip6_nxt;
d5568 1
d5572 2
a5573 2
					*action = pf_test_fragment(r, dir, kif,
					     m, pd, a, ruleset);
d5621 1
a5621 1
				pd->proto = opt6.ip6e_nxt;
d5806 1
a5806 1
	if (pf_setup_pdesc(af, dir, &pd, m0, &action, &reason, kif, &a, &r,
@


1.759
log
@Rename the pf_pdesc field rh_cnt to badopts as it is also used for
IPv4 options now.
ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.758 2011/07/04 16:26:23 bluhm Exp $ */
d2758 1
d2761 1
d5719 1
d5744 1
d6065 1
d6068 1
d6077 1
d6080 1
d6085 1
d6092 1
@


1.758
log
@IPv4 packets with IP options get dropped and no state is created.
IPv6 packets with routing headers get also dropped.  Use the same
fix for them to avoid that a state is created.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.757 2011/07/04 06:54:49 claudio Exp $ */
d3000 1
a3000 1
	if (r->action == PF_PASS && pd->rh_cnt && ! r->allow_opts) {
d5541 1
a5541 1
			pd->rh_cnt++;
d5623 1
a5623 1
				if (pd->rh_cnt++) {
d5966 1
a5966 1
			if (action == PF_PASS && pd.rh_cnt &&
@


1.757
log
@Bye bye pf_test6(). Only one pf_test function for both IPv4 and v6.
The functions were 95% identical anyway. While there use struct pf_addr
in struct pf_divert instead of some union which is the same.
OK bluhm@@ mcbride@@ and most probably henning@@ as well
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.756 2011/07/03 23:37:55 zinke Exp $ */
d3000 6
a3005 10
	if (r->action == PF_PASS && af == AF_INET && ! r->allow_opts) {
		struct ip	*h4 = mtod(m, struct ip *);

		if (h4->ip_hl > 5) {
			REASON_SET(&reason, PFRES_IPOPTIONS);
			pd->pflog |= PF_LOG_FORCE;
			DPFPRINTF(LOG_NOTICE, "dropping packet with "
			    "ip options in pf_test_rule()");
			goto cleanup;
		}
@


1.756
log
@bring in least-states load balancing algorithm

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.755 2011/07/03 23:33:38 bluhm Exp $ */
d5154 1
a5154 1
		if (pf_test(PF_OUT, ifp, &m0, NULL) != PF_PASS)
d5319 1
a5319 1
		if (pf_test6(PF_OUT, ifp, &m0, NULL) != PF_PASS)
d5544 2
a5800 1
#ifdef INET
d5802 1
a5802 1
pf_test(int dir, struct ifnet *ifp, struct mbuf **m0,
d5814 1
d5851 1
a5851 1
	if (pf_setup_pdesc(AF_INET, dir, &pd, m0, &action, &reason, kif, &a, &r,
d5908 6
d5930 5
a5934 82
		action = PF_DROP;
		DPFPRINTF(LOG_NOTICE,
		    "dropping IPv4 packet with ICMPv6 payload");
		goto done;
	}

	default:
		action = pf_test_state_other(&s, dir, kif, m, &pd);
		if (action == PF_PASS) {
#if NPFSYNC > 0
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			pd.pflog |= s->log;
		} else if (s == NULL)
			action = pf_test_rule(&r, &s, dir, kif, m, off,
			    &pd, &a, &ruleset, hdrlen);
		break;
	}

done:
	if (action != PF_DROP) {
		if (s) {
			/* The non-state case is handled in pf_test_rule() */
			struct ip	*h = mtod(m, struct ip *);
			if (action == PF_PASS && h->ip_hl > 5 &&
			    !(s->state_flags & PFSTATE_ALLOWOPTS)) {
				action = PF_DROP;
				REASON_SET(&reason, PFRES_IPOPTIONS);
				pd.pflog |= PF_LOG_FORCE;
				DPFPRINTF(LOG_NOTICE, "dropping packet with "
				    "ip options in pf_test()");
			}

			pf_scrub(m, s->state_flags, pd.af, s->min_ttl,
			    s->set_tos);
			pf_tag_packet(m, s->tag, s->rtableid[pd.didx]);
			if (pqid || (pd.tos & IPTOS_LOWDELAY))
				qid = s->pqid;
			else
				qid = s->qid;
		} else {
			pf_scrub(m, r->scrub_flags, pd.af, r->min_ttl,
			    r->set_tos);
			if (pqid || (pd.tos & IPTOS_LOWDELAY))
				qid = r->pqid;
			else
				qid = r->qid;
		}
	}

	if (dir == PF_IN && s && s->key[PF_SK_STACK])
		m->m_pkthdr.pf.statekey = s->key[PF_SK_STACK];

#ifdef ALTQ
	if (action == PF_PASS && qid) {
		m->m_pkthdr.pf.qid = qid;
		m->m_pkthdr.pf.hdr = mtod(m, caddr_t);	/* hints for ecn */
	}
#endif /* ALTQ */

	/*
	 * connections redirected to loopback should not match sockets
	 * bound specifically to loopback due to security implications,
	 * see tcp_input() and in_pcblookup_listen().
	 */
	if (pd.destchg &&
	    (ntohl(pd.dst->v4.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
		m->m_pkthdr.pf.flags |= PF_TAG_TRANSLATE_LOCALHOST;
	/* We need to redo the route lookup on outgoing routes. */
	if (pd.destchg && dir == PF_OUT)
		m->m_pkthdr.pf.flags |= PF_TAG_REROUTE;

	if (dir == PF_IN && action == PF_PASS && r->divert.port) {
		struct pf_divert *divert;

		if ((divert = pf_get_divert(m))) {
			m->m_pkthdr.pf.flags |= PF_TAG_DIVERTED;
			divert->port = r->divert.port;
			divert->rdomain = pd.rdomain;
			divert->addr.ipv4 = r->divert.addr.v4;
a5935 165
	}

	if (action == PF_PASS && r->divert_packet.port) {
		struct pf_divert *divert;

		if ((divert = pf_get_divert(m)))
			divert->port = r->divert_packet.port;

		action = PF_DIVERT;
	}

	if (pd.pflog) {
		struct pf_rule_item	*ri;

		if (pd.pflog & PF_LOG_FORCE || r->log & PF_LOG_ALL)
			PFLOG_PACKET(kif, m, dir, reason, r, a, ruleset, &pd);
		if (s) {
			SLIST_FOREACH(ri, &s->match_rules, entry)
				if (ri->r->log & PF_LOG_ALL)
					PFLOG_PACKET(kif, m, dir, reason,
					    ri->r, a, ruleset, &pd);
		}
	}

	pf_counters_inc(dir, action, &pd, kif, s, r, a);

	switch (action) {
	case PF_SYNPROXY_DROP:
		m_freem(*m0);
	case PF_DEFER:
		*m0 = NULL;
		action = PF_PASS;
		break;
	case PF_DIVERT:
		divert_packet(m, dir);
		*m0 = NULL;
		action = PF_PASS;
		break;
	default:
		/* pf_route can free the mbuf causing *m0 to become NULL */
		if (r->rt)
			pf_route(m0, r, dir, kif->pfik_ifp, s);
		break;
	}

	return (action);
}
#endif /* INET */

#ifdef INET6
int
pf_test6(int fwdir, struct ifnet *ifp, struct mbuf **m0,
    struct ether_header *eh)
{
	struct pfi_kif		*kif;
	u_short			 action, reason = 0;
	struct mbuf		*m = *m0;
	struct m_tag		*mtag;
	struct pf_rule		*a = NULL, *r = &pf_default_rule;
	struct pf_state		*s = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_pdesc		 pd;
	union pf_headers	 hdrs;
	int			 off, hdrlen;
	int			 dir = (fwdir == PF_FWD) ? PF_OUT : fwdir;
	u_int32_t		 qid, pqid = 0;

	if (!pf_status.running)
		return (PF_PASS);

	memset(&pd, 0, sizeof(pd));
	pd.hdr.any = &hdrs;
	if (ifp->if_type == IFT_CARP && ifp->if_carpdev)
		kif = (struct pfi_kif *)ifp->if_carpdev->if_pf_kif;
	else
		kif = (struct pfi_kif *)ifp->if_pf_kif;

	if (kif == NULL) {
		DPFPRINTF(LOG_ERR,
		    "pf_test6: kif == NULL, if_xname %s", ifp->if_xname);
		return (PF_DROP);
	}
	if (kif->pfik_flags & PFI_IFLAG_SKIP)
		return (PF_PASS);

#ifdef DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("non-M_PKTHDR is passed to pf_test6");
#endif /* DIAGNOSTIC */

	if (m->m_pkthdr.pf.flags & PF_TAG_GENERATED)
		return (PF_PASS);

	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED_PACKET)
		return (PF_PASS);

	if (m->m_pkthdr.pf.flags & PF_TAG_REFRAGMENTED) {
		m->m_pkthdr.pf.flags &= ~PF_TAG_REFRAGMENTED;
		return (PF_PASS);
	}

	if (pf_setup_pdesc(AF_INET6, dir, &pd, m0, &action, &reason, kif, &a,
	    &r, &ruleset, &off, &hdrlen) == -1) {
		if (action == PF_PASS)
			return (PF_PASS);
		m = *m0;
		pd.pflog |= PF_LOG_FORCE;
		goto done;
	}
	pd.eh = eh;
	m = *m0;	/* pf_setup_pdesc -> pf_normalize messes with m0 */

	switch (pd.proto) {

	case IPPROTO_TCP: {
		if ((pd.hdr.tcp->th_flags & TH_ACK) && pd.p_len == 0)
			pqid = 1;
		action = pf_normalize_tcp(dir, m, off, &pd);
		if (action == PF_DROP)
			goto done;
		action = pf_test_state_tcp(&s, dir, kif, m, off, &pd,
		    &reason);
		if (action == PF_PASS) {
#if NPFSYNC > 0
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			pd.pflog |= s->log;
		} else if (s == NULL)
			action = pf_test_rule(&r, &s, dir, kif,
			    m, off, &pd, &a, &ruleset, hdrlen);

		if (s) {
			if (s->max_mss)
				pf_normalize_mss(m, off, &pd, s->max_mss);
		} else if (r->max_mss)
			pf_normalize_mss(m, off, &pd, r->max_mss);

		break;
	}

	case IPPROTO_UDP: {
		action = pf_test_state_udp(&s, dir, kif, m, off, &pd);
		if (action == PF_PASS) {
#if NPFSYNC > 0
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			pd.pflog |= s->log;
		} else if (s == NULL)
			action = pf_test_rule(&r, &s, dir, kif,
			    m, off, &pd, &a, &ruleset, hdrlen);
		break;
	}

	case IPPROTO_ICMP: {
		action = PF_DROP;
		DPFPRINTF(LOG_NOTICE,
		    "dropping IPv6 packet with ICMPv4 payload");
		goto done;
	}

	case IPPROTO_ICMPV6: {
d5969 1
a5969 1
			/* handle dangerous IPv6 extension headers. */
d5976 1
a5976 1
				    "dangerous v6 headers");
d6002 1
a6002 1
		m->m_pkthdr.pf.hdr = mtod(m, caddr_t); /* add hints for ecn */
d6006 10
a6015 3
	if (pd.destchg &&
	    IN6_IS_ADDR_LOOPBACK(&pd.dst->v6))
		m->m_pkthdr.pf.flags |= PF_TAG_TRANSLATE_LOCALHOST;
d6027 1
a6027 1
			divert->addr.ipv6 = r->divert.addr.v6;
d6063 4
a6066 1
		divert6_packet(m, dir);
d6071 7
a6077 3
		/* pf_route6 can free the mbuf causing *m0 to become NULL */
		if (r->rt)
			pf_route6(m0, r, dir, kif->pfik_ifp, s);
d6082 5
a6086 3
	if (pf_status.reass && action == PF_PASS && *m0 && fwdir == PF_FWD &&
	    (mtag = m_tag_find(m, PACKET_TAG_PF_REASSEMBLED, NULL)) != NULL)
		action = pf_refragment6(m0, mtag, fwdir);
a6089 1
#endif /* INET6 */
@


1.755
log
@In pf_setup_pdesc() the code for analysing TCP and UDP headers was
the same for v4 and v6.  Deduplicate by moving the protocol switch
after the address family switch.
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.754 2011/07/03 18:42:45 henning Exp $ */
d182 4
a185 4
			    struct pf_pdesc *, struct pf_state_key **,
			    struct pf_state_key **, struct mbuf *, int,
			    int *, struct pfi_kif *, struct pf_state **, int,
			    struct pf_rule_slist *,
d1126 3
d2659 1
d2667 1
d2730 3
a2732 1
	struct pf_rule		*r, *a = NULL;
d2900 6
d3022 1
a3022 1
		action = pf_create_state(r, a, pd, &skw, &sks, m, off,
d3076 4
a3079 4
pf_create_state(struct pf_rule *r, struct pf_rule *a, struct pf_pdesc *pd,
    struct pf_state_key **skw, struct pf_state_key **sks, struct mbuf *m,
    int off, int *rewrite, struct pfi_kif *kif, struct pf_state **sm,
    int tag, struct pf_rule_slist *rules,
d3102 1
@


1.754
log
@garbage collect unused parameter to PFLOG_PACKET
i found this somewhere in my forest, I don't really remember writing it, the
context indicates I did this in iceland... getting this is to make a 1000+
lines diff less painful (how do I always end up with those)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.753 2011/07/03 18:08:02 claudio Exp $ */
a5544 40

		switch (h->ip_p) {
		case IPPROTO_TCP: {
			struct tcphdr	*th = pd->hdr.tcp;

			if (!pf_pull_hdr(m, *off, th, sizeof(*th),
			    action, reason, AF_INET))
				return (-1);
			*hdrlen = sizeof(*th);
			pd->p_len = pd->tot_len - *off - (th->th_off << 2);
			pd->sport = &th->th_sport;
			pd->dport = &th->th_dport;
			break;
		}
		case IPPROTO_UDP: {
			struct udphdr	*uh = pd->hdr.udp;

			if (!pf_pull_hdr(m, *off, uh, sizeof(*uh),
			    action, reason, AF_INET))
				return (-1);
			*hdrlen = sizeof(*uh);
			if (uh->uh_dport == 0 ||
			    ntohs(uh->uh_ulen) > m->m_pkthdr.len - *off ||
			    ntohs(uh->uh_ulen) < sizeof(struct udphdr)) {
				*action = PF_DROP;
				REASON_SET(reason, PFRES_SHORT);
				return (-1);
			}
			pd->sport = &uh->uh_sport;
			pd->dport = &uh->uh_dport;
			break;
		}
		case IPPROTO_ICMP: {
			if (!pf_pull_hdr(m, *off, pd->hdr.icmp, ICMP_MINLEN,
			    action, reason, AF_INET))
				return (-1);
			*hdrlen = ICMP_MINLEN;
			break;
		}
		}
d5661 11
d5673 10
a5682 3
		switch (pd->proto) {
		case IPPROTO_TCP: {
			struct tcphdr	*th = pd->hdr.tcp;
d5684 9
a5692 8
			if (!pf_pull_hdr(m, *off, th, sizeof(*th),
			    action, reason, AF_INET6))
				return (-1);
			*hdrlen = sizeof(*th);
			pd->p_len = pd->tot_len - *off - (th->th_off << 2);
			pd->sport = &th->th_sport;
			pd->dport = &th->th_dport;
			break;
d5694 13
a5706 2
		case IPPROTO_UDP: {
			struct udphdr	*uh = pd->hdr.udp;
d5708 8
a5715 13
			if (!pf_pull_hdr(m, *off, uh, sizeof(*uh),
			    action, reason, AF_INET6))
				return (-1);
			*hdrlen = sizeof(*uh);
			if (uh->uh_dport == 0 ||
			    ntohs(uh->uh_ulen) > m->m_pkthdr.len - *off ||
			    ntohs(uh->uh_ulen) < sizeof(struct udphdr)) {
				*action = PF_DROP;
				REASON_SET(reason, PFRES_SHORT);
				return (-1);
			}
			pd->sport = &uh->uh_sport;
			pd->dport = &uh->uh_dport;
d5717 3
a5719 23
		}
		case IPPROTO_ICMPV6: {
			size_t	icmp_hlen = sizeof(struct icmp6_hdr);

			if (!pf_pull_hdr(m, *off, pd->hdr.icmp6, icmp_hlen,
			    action, reason, AF_INET6))
				return (-1);
			/* ICMP headers we look further into to match state */
			switch (pd->hdr.icmp6->icmp6_type) {
			case MLD_LISTENER_QUERY:
			case MLD_LISTENER_REPORT:
				icmp_hlen = sizeof(struct mld_hdr);
				break;
			case ND_NEIGHBOR_SOLICIT:
			case ND_NEIGHBOR_ADVERT:
				icmp_hlen = sizeof(struct nd_neighbor_solicit);
				break;
			}
			if (icmp_hlen > sizeof(struct icmp6_hdr) &&
			    !pf_pull_hdr(m, *off, pd->hdr.icmp6, icmp_hlen,
			    action, reason, AF_INET6))
				return (-1);
			*hdrlen = icmp_hlen;
d5722 5
a5726 1
		}
a5728 4
#endif
	default:
		panic("pf_setup_pdesc called with illegal af %u", af);

@


1.753
log
@Refactor the fragment handling in pf_setup_pdesc() so that AF_INET
and AF_INET6 are doing the fragment handling the same way. Makes
code more readable.
With and OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.752 2011/07/01 21:00:40 bluhm Exp $ */
d2894 2
a2895 3
						PFLOG_PACKET(kif, h, m,
						    direction, reason, r,
						    a, ruleset, pd);
d2902 2
a2903 3
						PFLOG_PACKET(kif, h, m,
						    direction, reason, r,
						    a, ruleset, pd);
d2930 1
a2930 2
		PFLOG_PACKET(kif, h, m, direction, reason,
		    r, a, ruleset, pd);
d3453 1
a3453 1
		PFLOG_PACKET(kif, h, m, direction, reason, r, a, ruleset, pd);
d6041 1
a6041 2
			PFLOG_PACKET(kif, h, m, dir, reason, r, a,
			    ruleset, &pd);
d6045 2
a6046 2
					PFLOG_PACKET(kif, h, m, dir,
					    reason, ri->r, a, ruleset, &pd);
d6292 1
a6292 2
			PFLOG_PACKET(kif, h, m, dir, reason, r, a,
			    ruleset, &pd);
d6296 2
a6297 2
					PFLOG_PACKET(kif, h, m, dir,
					    reason, ri->r, a, ruleset, &pd);
@


1.752
log
@The pf_headers union may also contain a mld_hdr or nd_neighbor_solicit
struct.  List those types explicitly to make sure that the union
contains enough memory.  Before we were just lucky.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.751 2011/06/23 19:10:40 claudio Exp $ */
d5498 2
a5499 1
		    *off > ntohs(h->ip_len)) {
d5505 16
d5535 10
a5544 13
			if (!pf_status.reass) {
				/*
				 * handle fragments that aren't reassembled by
				 * normalization
				 */
				if (kif == NULL || r == NULL)	/* pflog */
					*action = PF_DROP;
				else
					*action = pf_test_fragment(r, dir, kif,
					     m, pd, a, ruleset);
				if (*action == PF_PASS)
					/* m is still valid, return success */
					return (0);
d5546 1
a5546 21
				return (-1);
			}
			/* packet reassembly */
			if (pf_normalize_ip(m0, dir, reason) != PF_PASS) {
				*action = PF_DROP;
				return (-1);
			}
			m = *m0;
			if (m == NULL) {
				/* packet sits in reassembly queue, no error */
				*action = PF_PASS;
				return (-1);
			}
			/* refetch header, recalc offset and update pd */
			h = mtod(m, struct ip *);
			*off = h->ip_hl << 2;
			pd->src = (struct pf_addr *)&h->ip_src;
			pd->dst = (struct pf_addr *)&h->ip_dst;
			pd->ip_sum = &h->ip_sum;
			pd->tot_len = ntohs(h->ip_len);
			pd->tos = h->ip_tos;
d5604 1
a5604 2
		if (pf_status.reass &&
		    pf_normalize_ip6(m0, dir, reason) != PF_PASS) {
d5648 1
a5648 1
				if (*action == PF_DROP)
@


1.751
log
@Set pd->af very early in pf_setup_pdesc() since the AF is used in
the pflog code and not setting it will cause a panic in pf_setup_pdesc().
Fixes dhill's crashes with funky v6 packets. OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.750 2011/06/21 08:59:47 bluhm Exp $ */
d134 2
@


1.750
log
@There is no need to handle fragmented TCP reset packets in a special
way.  Remove PFDESC_IP_REAS and pf_pdesc flags completely.
ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.749 2011/06/20 19:03:41 claudio Exp $ */
d5479 1
a5510 1
		pd->af = AF_INET;
a5640 1
		pd->af = AF_INET6;
@


1.749
log
@More cleanup in pf_test/pf_test6 this time mostly the fragment
handling. More to come to make the two codepathes a bit more identical.
tested by many (esp. krw@@ and sthen@@) input and OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.748 2011/06/14 10:14:01 mcbride Exp $ */
d3620 1
a3620 2
	    (orig_seq == src->seqlo + 1) || (orig_seq + 1 == src->seqlo) ||
	    (pd->flags & PFDESC_IP_REAS) == 0)) {
d5533 1
a5533 1
			if (pf_normalize_ip(m0, dir, reason, pd) != PF_PASS) {
d5609 1
a5609 1
		    pf_normalize_ip6(m0, dir, reason, pd) != PF_PASS) {
@


1.748
log
@KNF (no change in .o files)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.747 2011/06/02 22:08:40 sthen Exp $ */
d5470 1
a5470 1
pf_setup_pdesc(sa_family_t af, int dir, struct pf_pdesc *pd, struct mbuf *m,
d5474 2
d5485 7
d5494 3
a5496 1
		if (*off < (int)sizeof(*h)) {
d5501 1
d5516 37
a5552 3
		/* fragments not reassembled handled later */
		if (h->ip_off & htons(IP_MF | IP_OFFMASK))
			return (0);
d5601 20
d5622 12
a5837 1
	struct ip		*h;
a5868 7
	if (m->m_pkthdr.len < (int)sizeof(*h)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_SHORT);
		pd.pflog |= PF_LOG_FORCE;
		goto done;
	}

d5880 1
a5880 14
	/* packet reassembly here if 1) enabled 2) we deal with a fragment */
	h = mtod(m, struct ip *);
	if (pf_status.reass &&
	    (h->ip_off & htons(IP_MF | IP_OFFMASK)) &&
	    pf_normalize_ip(m0, dir, kif, &reason, &pd) != PF_PASS) {
		action = PF_DROP;
		goto done;
	}
	m = *m0;	/* pf_normalize messes with m0 */
	if (m == NULL)
		return (PF_PASS);
	h = mtod(m, struct ip *);

	if (pf_setup_pdesc(AF_INET, dir, &pd, m, &action, &reason, kif, &a, &r,
d5882 4
a5885 2
		if (action != PF_PASS)
			pd.pflog |= PF_LOG_FORCE;
d5889 1
a5889 7

	/* handle fragments that didn't get reassembled by normalization */
	if (h->ip_off & htons(IP_MF | IP_OFFMASK)) {
		action = pf_test_fragment(&r, dir, kif, m,
		    &pd, &a, &ruleset);
		goto done;
	}
d5896 1
a5896 1
		action = pf_normalize_tcp(dir, kif, m, 0, off, h, &pd);
d5978 1
d6011 1
a6011 1
		m->m_pkthdr.pf.hdr = h;	/* hints for ecn */
a6094 1
	struct ip6_hdr		*h;
a6126 7
	if (m->m_pkthdr.len < (int)sizeof(*h)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_SHORT);
		pd.pflog |= PF_LOG_FORCE;
		goto done;
	}

d6138 5
a6142 19
	/* packet reassembly */
	if (pf_status.reass &&
	    pf_normalize_ip6(m0, fwdir, kif, &reason, &pd) != PF_PASS) {
		action = PF_DROP;
		goto done;
	}
	m = *m0;	/* pf_normalize messes with m0 */
	if (m == NULL)
		return (PF_PASS);
	h = mtod(m, struct ip6_hdr *);

#if 1
	/*
	 * we do not support jumbogram yet.  if we keep going, zero ip6_plen
	 * will do something bad, so drop the packet for now.
	 */
	if (htons(h->ip6_plen) == 0) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_NORM);
a6145 8
#endif

	if (pf_setup_pdesc(AF_INET6, dir, &pd, m, &action, &reason, kif, &a, &r,
	    &ruleset, &off, &hdrlen) == -1) {
		if (action != PF_PASS)
			pd.pflog |= PF_LOG_FORCE;
		goto done;
	}
d6147 1
d6154 1
a6154 1
		action = pf_normalize_tcp(dir, kif, m, 0, off, h, &pd);
d6268 1
a6268 1
		m->m_pkthdr.pf.hdr = h; /* add hints for ecn */
@


1.747
log
@When checking to see if a rule is referenced by any source-tracking nodes,
actually check how many src nodes reference it, rather than checking the
max_src_nodes for the rule which makes no sense. From Martin Pelikan.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.746 2011/05/25 06:48:12 claudio Exp $ */
d205 3
a207 3
			    struct pf_pdesc *, struct pf_state **, struct mbuf *,
			    int, struct pfi_kif *, u_int16_t, u_int16_t,
			    int, int *, int, int);
d2990 1
a2990 1
			
d3273 1
a3273 1
			    saddr, sport, 0, pd->af);	
d4018 1
a4018 1
			pf_change_ap(pd->dst, &th->th_dport, &th->th_sum,	
d4629 1
a4629 1
                                       pf_change_icmp(pd2.dst, NULL, saddr,
d4682 1
a4682 1
			 	    ((virtual_type ==
d5118 2
a5119 1
			if (pf_map_addr(AF_INET, r, (struct pf_addr *)&ip->ip_src,
d5704 1
a5704 1
{ 
@


1.746
log
@Don't do last minute changes to diffs. Revert the argument change to
pf_scrub in the rule (no-state) case. Since the action (a) may be NULL
for e.g. the implicit pass rule. Should fix the panics seen by other
people.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.745 2011/05/24 14:01:51 claudio Exp $ */
d596 1
a596 1
		    sn->rule.ptr->max_src_nodes <= 0)
@


1.745
log
@Merge pf_scrub_ip() and pf_scrub_ip6() into a single function.  Call
pf_scrub with the right arugments in the rule case so that match
rules will work as expected.  As a benefit allow setting the tos
on IPv6 packets as well.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.744 2011/05/22 13:21:24 claudio Exp $ */
d5941 2
a5942 2
			pf_scrub(m, a->scrub_flags, pd.af, a->min_ttl,
			    a->set_tos);
d6227 2
a6228 2
			pf_scrub(m, a->scrub_flags, pd.af, a->min_ttl,
			    a->set_tos);
@


1.744
log
@Do not pass AF specific information to pf_test_rule() and PFLOG_PACKET()
because either the info is already available in struct pd or easy
to figure out.  Makes pf_test() and pf_test6() even more similar
(with the target to remove one of them in the near future).
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.743 2011/05/13 14:31:16 oga Exp $ */
d5933 2
a5934 1
			pf_scrub_ip(m, s->state_flags, s->min_ttl, s->set_tos);
d5941 2
a5942 1
			pf_scrub_ip(m, r->scrub_flags, r->min_ttl, r->set_tos);
d6219 2
a6220 1
			pf_scrub_ip6(m, s->min_ttl);
d6227 2
a6228 1
			pf_scrub_ip6(m, r->min_ttl);
@


1.743
log
@Revert the pf->socket linking diff.

at least krw@@, pirofti@@ and todd@@ have been seeing panics (todd and krw
with xxxterm not sure about pirofti) involving pool corruption while
using this commit.

krw and todd confirm that this backout fixes the problem.

ok blambert@@ krw@@, todd@@ henning@@ and kettenis@@

	    Double link between pf states and sockets.  Henning has
	    already implemented half of it.  The additional part is: -
	    The pf state lookup for outgoing packets is optimized by
	    using mbuf->inp->state.
	    - For incomming tcp, udp, raw, raw6 packets the socket
	    lookup always is optimized by using mbuf->state->inp.
	    - All protocols establish the link for incomming packets.
	    - All protocols set the inp in the mbuf for outgoing packets.
	      This allows the linkage beginning with the first packet
	      for outgoing connections.
	    - In case of divert states, delete the state when the socket
	      closes.  Otherwise new connections could match on old
	      states instead of being diverted to the listen socket.
	    ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.742 2011/04/24 19:36:54 bluhm Exp $ */
d178 1
a178 1
			    struct pf_ruleset **, struct ifqueue *, int);
d2719 1
a2719 1
    struct ifqueue *ifq, int hdrlen)
d2731 1
d2749 3
d2892 1
a2892 1
						PFLOG_PACKET(kif, h, m, af,
d2901 1
a2901 1
						PFLOG_PACKET(kif, h, m, af,
d2930 1
a2930 1
		PFLOG_PACKET(kif, h, m, af, direction, reason,
d3454 1
a3454 2
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset,
		    pd);
d5804 5
d5811 2
a5812 1
	if (pf_status.reass && (h->ip_off & htons(IP_MF | IP_OFFMASK)) &&
d5837 1
a5837 1
	switch (h->ip_p) {
d5856 1
a5856 1
			    m, off, &pd, &a, &ruleset, &ipintrq, hdrlen);
d5878 1
a5878 1
			    m, off, &pd, &a, &ruleset, &ipintrq, hdrlen);
d5894 1
a5894 1
			    m, off, &pd, &a, &ruleset, &ipintrq, hdrlen);
d5916 1
a5916 1
			    &pd, &a, &ruleset, &ipintrq, hdrlen);
d5994 1
a5994 1
			PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, r, a,
d5999 1
a5999 1
					PFLOG_PACKET(kif, h, m, AF_INET, dir,
d6140 1
a6140 1
			    m, off, &pd, &a, &ruleset, &ip6intrq, hdrlen);
d6162 1
a6162 1
			    m, off, &pd, &a, &ruleset, &ip6intrq, hdrlen);
d6174 2
a6175 2
		action = pf_test_state_icmp(&s, dir, kif,
		    m, off, &pd, &reason);
d6185 1
a6185 1
			    m, off, &pd, &a, &ruleset, &ip6intrq, hdrlen);
d6200 1
a6200 1
			    &pd, &a, &ruleset, &ip6intrq, hdrlen);
a6204 10
	/* handle dangerous IPv6 extension headers. */
	if (action == PF_PASS && pd.rh_cnt &&
	    !((s && s->state_flags & PFSTATE_ALLOWOPTS) || r->allow_opts)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_IPOPTIONS);
		pd.pflog |= PF_LOG_FORCE;
		DPFPRINTF(LOG_NOTICE,
		    "dropping packet with dangerous v6 headers");
	}

d6207 10
d6218 1
a6230 2
	if (s && s->tag)
		pf_tag_packet(m, s ? s->tag : 0, s->rtableid[pd.didx]);
d6273 1
a6273 1
			PFLOG_PACKET(kif, h, m, AF_INET6, dir, reason, r, a,
d6278 1
a6278 1
					PFLOG_PACKET(kif, h, m, AF_INET6, dir,
@


1.742
log
@Double link between pf states and sockets.  Henning has already
implemented half of it.  The additional part is:
- The pf state lookup for outgoing packets is optimized by using
  mbuf->inp->state.
- For incomming tcp, udp, raw, raw6 packets the socket lookup always
  is optimized by using mbuf->state->inp.
- All protocols establish the link for incomming packets.
- All protocols set the inp in the mbuf for outgoing packets.
  This allows the linkage beginning with the first packet for
  outgoing connections.
- In case of divert states, delete the state when the socket closes.
  Otherwise new connections could match on old states instead of
  being diverted to the listen socket.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.741 2011/04/23 10:00:36 bluhm Exp $ */
a955 3
	else if (dir == PF_OUT && m->m_pkthdr.pf.inp &&
	   ((struct inpcb *)m->m_pkthdr.pf.inp)->inp_pf_sk)
	       sk = ((struct inpcb *)m->m_pkthdr.pf.inp)->inp_pf_sk;
a965 3
		} else if (dir == PF_OUT && m->m_pkthdr.pf.inp && !sk->inp) {
			((struct inpcb *)m->m_pkthdr.pf.inp)->inp_pf_sk = sk;
			sk->inp = m->m_pkthdr.pf.inp;
d969 1
a969 1
	if (dir == PF_OUT) {
a970 2
		m->m_pkthdr.pf.inp = NULL;
	}
a5940 7
	if (dir == PF_OUT && m->m_pkthdr.pf.inp &&
	    !((struct inpcb *)m->m_pkthdr.pf.inp)->inp_pf_sk &&
	    s && s->key[PF_SK_STACK] && !s->key[PF_SK_STACK]->inp) {
		((struct inpcb *)m->m_pkthdr.pf.inp)->inp_pf_sk =
		    s->key[PF_SK_STACK];
		s->key[PF_SK_STACK]->inp = m->m_pkthdr.pf.inp;
	}
a6225 7
	if (dir == PF_OUT && m->m_pkthdr.pf.inp &&
	    !((struct inpcb *)m->m_pkthdr.pf.inp)->inp_pf_sk &&
	    s && s->key[PF_SK_STACK] && !s->key[PF_SK_STACK]->inp) {
		((struct inpcb *)m->m_pkthdr.pf.inp)->inp_pf_sk =
		    s->key[PF_SK_STACK];
		s->key[PF_SK_STACK]->inp = m->m_pkthdr.pf.inp;
	}
a6321 1
	m->m_pkthdr.pf.inp = NULL;
@


1.741
log
@pf_scrub_ip() does not modify the given mbuf pointer.  So don't
pass a pointer to a pointer to make the code in pf_test() clearer.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.740 2011/04/12 10:47:29 mikeb Exp $ */
d956 3
d969 3
d975 1
a975 1
	if (dir == PF_OUT)
d977 2
d5949 7
d6241 7
d6344 1
@


1.740
log
@put the accepted socket of a diverted connection into the routing domain
of a connection originator.  this allows one to query the source rdomain
with a SO_RTABLE socket option.  figured out with reyk, ok claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.739 2011/04/07 19:35:05 miod Exp $ */
d5924 1
a5924 1
			pf_scrub_ip(&m, s->state_flags, s->min_ttl, s->set_tos);
d5931 1
a5931 1
			pf_scrub_ip(&m, r->scrub_flags, r->min_ttl, r->set_tos);
d6208 1
a6208 1
			pf_scrub_ip6(&m, s->min_ttl);
d6214 1
a6214 1
			pf_scrub_ip6(&m, r->min_ttl);
@


1.739
log
@Correctly initialize local variables in pf_check_proto_cksum(), even for
less blessed and non-loved protocols; temporary fix for correctness until
the henning tornado rampages this function.
"pls commit, ok" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.738 2011/04/06 13:18:39 claudio Exp $ */
d5967 1
d6247 1
@


1.738
log
@Allow PF to filter on the rdomain a packet belongs to. This allows to
write rules like "pass in on rdomain 1".
Tested by phessler@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.737 2011/04/05 20:36:59 henning Exp $ */
d5372 1
a5372 1
		flag_ok = flag_bad = 0;
@


1.737
log
@in pf_check_proto_cksum, consider packets with the CSUM_OUT flags set
to be ok. there is no checksum we could verify and for the moment these
are locally generated packets anyway. and this really is just the stupid
'stealth bridge detection' countermeasure shit (when you want a "stealth"
bridge and explictely ask pf to return RSTs/icmp errors, you need to
seek medical help in any case).
this is needed so that we eventually can move the in_proto_cksum_out (and
its ipvshit counterpart once we get it) calls to after the pf_test calls
in the output routines
ok dlg fondue-kinda-ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.736 2011/04/05 18:01:21 henning Exp $ */
d1455 3
d2807 3
d3394 3
@


1.736
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.735 2011/04/05 15:51:41 sthen Exp $ */
d5339 1
d5345 1
a5345 1
	u_int16_t flag_ok, flag_bad;
d5351 1
d5356 1
d5368 1
a5368 1
	if (m->m_pkthdr.csum_flags & flag_ok)
@


1.735
log
@handle ACK prioritization for v6, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.734 2011/04/05 13:48:18 mikeb Exp $ */
d5165 1
a5165 1
		if (m0->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
d5167 1
a5167 1
		else if (m0->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
@


1.734
log
@ditch fastroute, an ipf feature that made its way into pf before
route-to and friends were introduced making it obsolete. one even
has to look it up int the ipf manual to get and idea what it's
supposed to do.  reuse some kernel bits for the upcoming nat64
stuff.  "kill it with fire" from mcbride, "what mcbride said"
from mpf, "kill kill kill" and ok henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.733 2011/04/04 17:44:43 henning Exp $ */
d6024 1
d6102 2
d6194 1
a6194 1
		if (s)
d6196 5
a6200 1
		else
d6202 5
d6215 3
a6217 7
	if (action == PF_PASS && s && s->qid) {
		if (pd.tos & IPTOS_LOWDELAY)
			m->m_pkthdr.pf.qid = s->pqid;
		else
			m->m_pkthdr.pf.qid = s->qid;
		/* add hints for ecn */
		m->m_pkthdr.pf.hdr = h;
@


1.733
log
@de-guttenberg our stack a bit
we don't need 7 f***ing copies of the same code to do the protocol checksums
(or not, depending on hw capabilities). claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.732 2011/04/04 14:16:48 henning Exp $ */
d2643 1
a2643 1
	if (!r->rt || r->rt == PF_FASTROUTE)
d5090 1
a5090 1
	if (r->rt == PF_FASTROUTE) {
d5102 2
d5267 1
a5267 2
	/* Cheat. XXX why only in the v6 case??? */
	if (r->rt == PF_FASTROUTE) {
@


1.732
log
@and stop special casing the bridge for the ip cksum hardware offload
decision here too, just like in ip_output, pointless.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.731 2011/04/04 14:00:16 henning Exp $ */
d5153 1
a5153 14
	/* Catch routing changes wrt. hardware checksumming for TCP or UDP. */
	if (m0->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_TCPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m0);
			m0->m_pkthdr.csum_flags &= ~M_TCPV4_CSUM_OUT; /* Clr */
		}
	} else if (m0->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_UDPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m0);
			m0->m_pkthdr.csum_flags &= ~M_UDPV4_CSUM_OUT; /* Clr */
		}
	}
@


1.731
log
@there is no point at all in updating the ip checksum. it is always
recalculated in all output pathes anyway (why did it take us 10 years to
notice?). ok claudio definate ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.730 2011/03/24 20:09:44 bluhm Exp $ */
d5170 1
a5170 2
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    ifp->if_bridge == NULL) {
@


1.730
log
@Reassemble IPv6 fragments in pf.  In the forward case, pf refragments
the packets with the same maximum size.  This allows the sender to
determine the optimal fragment size by Path MTU Discovery.
testing sthen@@ matthieu@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.729 2011/03/07 23:30:18 bluhm Exp $ */
d148 2
a149 2
			    u_int16_t *, u_int16_t *, struct pf_addr *,
			    u_int16_t, u_int8_t, sa_family_t);
d161 1
a161 1
			    u_int16_t *, u_int8_t, sa_family_t);
d1526 1
a1526 1
pf_change_ap(struct pf_addr *a, u_int16_t *p, u_int16_t *ic, u_int16_t *pc,
a1538 4
		*ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
		    ao.addr16[0], an->addr16[0], 0),
		    ao.addr16[1], an->addr16[1], 0);
		*p = pn;
d1573 3
a1575 2
	*c = pf_cksum_fixup(pf_cksum_fixup(*c, ao / 65536, an / 65536, u),
	    ao % 65536, an % 65536, u);
d1790 1
a1790 1
    u_int16_t *ic, u_int16_t *hc, u_int8_t u, sa_family_t af)
d1819 1
d1846 1
a1846 1
	/* Outer ip address, fix outer ip or icmpv6 checksum, if necessary. */
a1848 8
		switch (af) {
#ifdef INET
		case AF_INET:
			*hc = pf_cksum_fixup(pf_cksum_fixup(*hc,
			    ooa.addr16[0], oa->addr16[0], 0),
			    ooa.addr16[1], oa->addr16[1], 0);
			break;
#endif /* INET */
d1850 1
a1850 1
		case AF_INET6:
a1861 1
			break;
a1862 1
		}
d3262 2
a3263 2
			pf_change_ap(pd->src, pd->sport, pd->ip_sum,
			    &pd->hdr.tcp->th_sum, saddr, sport, 0, pd->af);	
d3267 2
a3268 2
			pf_change_ap(pd->dst, pd->dport, pd->ip_sum,
			    &pd->hdr.tcp->th_sum, daddr, dport, 0, pd->af);
d3275 2
a3276 2
			pf_change_ap(pd->src, pd->sport, pd->ip_sum,
			    &pd->hdr.udp->uh_sum, saddr, sport, 1, pd->af);
d3280 2
a3281 2
			pf_change_ap(pd->dst, pd->dport, pd->ip_sum,
			    &pd->hdr.udp->uh_sum, daddr, dport, 1, pd->af);
d3293 1
a3293 1
			pf_change_a(&pd->src->v4.s_addr, pd->ip_sum,
d3298 1
a3298 1
			pf_change_a(&pd->dst->v4.s_addr, pd->ip_sum,
d3340 1
a3340 1
				pf_change_a(&pd->src->v4.s_addr, pd->ip_sum,
d3345 1
a3345 1
				pf_change_a(&pd->dst->v4.s_addr, pd->ip_sum,
d3354 1
a3354 1
				pf_change_a6(pd->src, pd->ip_sum, saddr, 0);
d3358 1
a3358 1
				pf_change_a6(pd->dst, pd->ip_sum, daddr, 0);
d3999 2
a4000 4
			pf_change_ap(pd->src, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &nk->addr[pd->sidx],
			    nk->port[pd->sidx], 0, pd->af);

d4006 2
a4007 3
			pf_change_ap(pd->dst, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &nk->addr[pd->didx],
			    nk->port[pd->didx], 0, pd->af);
d4071 2
a4072 4
			pf_change_ap(pd->src, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &nk->addr[pd->sidx],
			    nk->port[pd->sidx], 1, pd->af);

d4078 2
a4079 3
			pf_change_ap(pd->dst, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &nk->addr[pd->didx],
			    nk->port[pd->didx], 1, pd->af);
d4208 1
a4208 2
					pf_change_a(&saddr->v4.s_addr,
					    pd->ip_sum,
d4213 1
a4213 2
					pf_change_a(&daddr->v4.s_addr,
					    pd->ip_sum,
d4457 1
a4457 2
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
d4470 1
a4470 2
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
d4532 1
a4532 2
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 1, pd2.af);
d4545 1
a4545 2
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 1, pd2.af);
d4608 1
a4608 2
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET);
d4619 1
a4619 2
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET);
d4681 1
a4681 2
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET6);
d4692 1
a4692 2
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET6);
d4725 1
a4725 2
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
d4736 1
a4736 2
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
d4821 1
a4821 2
				pf_change_a(&pd->src->v4.s_addr,
				    pd->ip_sum,
d4825 1
a4825 2
				pf_change_a(&pd->dst->v4.s_addr,
				    pd->ip_sum,
@


1.729
log
@Declare the inline function pf_addr_compare() non-static in pfvar.h
to make it reusable by pf fragment reassembly.  No functional change.
discussed with henning@@, claudio@@, deraadt@@, kettenis@@
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.728 2011/03/05 01:53:16 bluhm Exp $ */
d6054 1
a6054 1
pf_test6(int dir, struct ifnet *ifp, struct mbuf **m0,
d6060 1
d6068 1
d6106 5
d6112 2
a6113 1
	if (pf_normalize_ip6(m0, dir, kif, &reason, &pd) != PF_PASS) {
d6318 5
@


1.728
log
@The function pf_tag_packet() never fails.  Remove a redundant check
and make it void.
ok henning@@, markus@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.727 2011/02/23 15:46:14 mikeb Exp $ */
a299 2
static __inline int pf_addr_compare(struct pf_addr *, struct pf_addr *,
	sa_family_t);
d316 1
a316 1
static __inline int
@


1.727
log
@fixup source address rewriting for the icmp errors with the rdr-to setup.
problem was reported by babut at yandex dot ru in the pr 6564, tested by
the pr originator and me, ok henning mcbride.  shaves off a bunch of XXXs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.726 2011/02/14 11:01:36 sthen Exp $ */
d2296 1
a2296 1
int
a2298 2
	if (tag <= 0 && rtableid < 0)
		return (0);
a2302 2

	return (0);
d2987 1
a2987 4
	if (pf_tag_packet(m, tag, act.rtableid)) {
		REASON_SET(&reason, PFRES_MEMORY);
		goto cleanup;
	}
d3461 1
a3461 4
	if (pf_tag_packet(m, tag, -1)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}
@


1.726
log
@Add missing byte-order swap to pf_match_addr_range. Without this, rules
using address ranges (e.g. "10.1.1.1 - 10.1.1.5") did not match addresses
correctly on little-endian systems.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.725 2011/02/06 23:12:12 bluhm Exp $ */
d4501 1
a4501 2
					    NULL, /* XXX Inbound NAT? */
					    &nk->addr[pd2.didx],
d4578 1
a4578 2
					    NULL, /* XXX Inbound NAT? */
					    &nk->addr[pd2.didx],
d4654 1
a4654 1
                                       pf_change_icmp(pd2.dst, NULL, NULL,
d4729 1
a4729 1
					pf_change_icmp(pd2.dst, NULL, NULL,
d4775 1
a4775 2
					pf_change_icmp(pd2.src, NULL,
					    NULL, /* XXX Inbound NAT? */
@


1.725
log
@pf_translate() may be called from pflog_packet().  Make sure that
IPv4-ICMP6 and IPv6-ICMP packets are not rewritten in case they are
dropped and logged.
spotted by mikeb@@; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.724 2011/02/06 13:08:49 bluhm Exp $ */
d2183 2
a2184 2
		if ((a->addr32[0] < b->addr32[0]) ||
		    (a->addr32[0] > e->addr32[0]))
d2194 1
a2194 1
			if (a->addr32[i] > b->addr32[i])
d2196 1
a2196 1
			else if (a->addr32[i] < b->addr32[i])
d2200 1
a2200 1
			if (a->addr32[i] < e->addr32[i])
d2202 1
a2202 1
			else if (a->addr32[i] > e->addr32[i])
@


1.724
log
@pf_test() and pf_test6() drop IPv4-ICMP6 and IPv6-ICMP packets.  Do
not do the same check in pf_test_rule() again.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.723 2011/02/05 17:29:05 bluhm Exp $ */
d3309 4
d3339 13
a3351 12
		if (pd->af == AF_INET6) {
			if (PF_ANEQ(saddr, pd->src, pd->af)) {
				pf_change_a6(pd->src,
				    &pd->hdr.icmp6->icmp6_cksum, saddr, 0);
				rewrite = 1;
			}
			if (PF_ANEQ(daddr, pd->dst, pd->af)) {
				pf_change_a6(pd->dst,
				    &pd->hdr.icmp6->icmp6_cksum, daddr, 0);
				rewrite = 1;
			}
			break;
d3353 1
a3353 1
		/* FALLTHROUGH */
@


1.723
log
@When a packet with an unusual protocol number got rewritten, the
header lenght was uninitialized.  This resulted in a panic in
m_clget().  Initialize hdrlen with 0 and call m_copyback() only if
necessary.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.722 2011/01/22 11:43:57 bluhm Exp $ */
a2778 2
		if (pd->af != AF_INET)
			break;
a2793 2
		if (af != AF_INET6)
			break;
@


1.722
log
@Pf must not scrub packets which will be dropped anyway.
ok henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.721 2011/01/19 11:39:56 bluhm Exp $ */
d3050 1
a3050 1
	if (rewrite)
d5520 1
@


1.721
log
@Give pf_normalize_ip() the same 3 way semantics as pf_test().
- PF_DROP, the packet is bad, the mbuf still exists and must be freed.
- PF_PASS and *m0 is NULL, the packet has been processed, not an error.
- PF_PASS and *m0 is not NULL, continue with packet processing.
This fixes a potential mbuf use after free.
ok henning@@ markus@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.720 2011/01/11 13:35:58 mcbride Exp $ */
d5958 11
d5970 12
a5981 9
	if (s) {
		/* The non-state case is handled in pf_test_rule() */
		if (action == PF_PASS && h->ip_hl > 5 &&
	    	    !(s->state_flags & PFSTATE_ALLOWOPTS)) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_IPOPTIONS);
			pd.pflog |= PF_LOG_FORCE;
			DPFPRINTF(LOG_NOTICE, "dropping packet with "
			    "ip options in pf_test()");
a5982 13

		pf_scrub_ip(&m, s->state_flags, s->min_ttl, s->set_tos);
		pf_tag_packet(m, s->tag, s->rtableid[pd.didx]);
		if (pqid || (pd.tos & IPTOS_LOWDELAY))
			qid = s->pqid;
		else
			qid = s->qid;
	} else {
		pf_scrub_ip(&m, r->scrub_flags, r->min_ttl, r->set_tos);
		if (pqid || (pd.tos & IPTOS_LOWDELAY))
			qid = r->pqid;
		else
			qid = r->qid;
d6240 6
a6245 5
	if (s)
		pf_scrub_ip6(&m, s->min_ttl);
	else
		pf_scrub_ip6(&m, r->min_ttl);

@


1.720
log
@Perform IP options check in pf_test_rule(), before creating state.

ok claudio henning dlg miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.719 2011/01/10 18:57:59 bluhm Exp $ */
d5855 2
d6122 2
@


1.719
log
@If pf_test() was called recursively, the global variable pf_hdrs
could be used multiple times for different packets.  This happened
when pflow(4) was used.  Instead of a global variable, store the
pf_headers in a local variable on the stack.
david@@ found the bug, narrowed it down and tested the fix.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.718 2011/01/10 10:26:38 mcbride Exp $ */
d3003 12
d5800 1
a5800 1
	u_short			 action, reason = 0, pflog = 0;
d5837 1
a5837 1
		pflog |= PF_LOG_FORCE;
d5860 1
a5860 1
			pflog |= PF_LOG_FORCE;
d5888 1
a5888 1
			pflog |= s->log;
d5910 1
a5910 1
			pflog |= s->log;
d5926 1
a5926 1
			pflog |= s->log;
d5948 1
a5948 1
			pflog |= s->log;
a5955 8
	if (action == PF_PASS && h->ip_hl > 5 &&
	    !((s && s->state_flags & PFSTATE_ALLOWOPTS) || r->allow_opts)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_IPOPTIONS);
		pflog |= PF_LOG_FORCE;
		DPFPRINTF(LOG_NOTICE,
		    "pf: dropping packet with ip options");
	}
d5958 10
d6023 1
a6023 1
	if (pflog) {
d6026 1
a6026 1
		if (pflog & PF_LOG_FORCE || r->log & PF_LOG_ALL)
d6068 1
a6068 1
	u_short			 action, reason = 0, pflog = 0;
d6104 1
a6104 1
		pflog |= PF_LOG_FORCE;
d6130 1
a6130 1
		pflog |= PF_LOG_FORCE;
d6138 1
a6138 1
			pflog |= PF_LOG_FORCE;
d6157 1
a6157 1
			pflog |= s->log;
d6179 1
a6179 1
			pflog |= s->log;
d6202 1
a6202 1
			pflog |= s->log;
d6217 1
a6217 1
			pflog |= s->log;
d6230 1
a6230 1
		pflog |= PF_LOG_FORCE;
d6283 1
a6283 1
	if (pflog) {
d6286 1
a6286 1
		if (pflog & PF_LOG_FORCE || r->log & PF_LOG_ALL)
@


1.718
log
@DPFPRINTF already adds the "pf: ", no need to put it in the error
string.

ok henning dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.717 2011/01/05 17:36:55 bluhm Exp $ */
d128 1
a128 1
union {
d135 1
a135 1
} pf_hdrs;
d5795 1
d5803 1
a5803 1
	pd.hdr.any = &pf_hdrs;
d6061 1
d6068 1
a6068 1
	pd.hdr.any = &pf_hdrs;
@


1.717
log
@Remove mbuf ptr save dance in pf_test6().  It was a leftover with
misleading comment that did nothing.
ok henning@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.716 2010/12/31 12:21:36 bluhm Exp $ */
d4307 1
a4307 1
				    "pf: ICMP error message too short (ip)");
d4335 1
a4335 1
				    "pf: ICMP error message too short (ip6)");
d4363 1
a4363 1
						    "pf: ICMPv6 short opt");
d4399 1
a4399 1
				    "pf: ICMP error message too short (tcp)");
d4528 1
a4528 1
				    "pf: ICMP error message too short (udp)");
d4603 1
a4603 1
				    "pf: ICMP error message too short (icmp)");
d4666 1
a4666 2
				    "pf: ICMP error message too short "
				    "(icmp6)");
d5615 1
a5615 1
					    "pf: IPv6 more than one rthdr");
d5623 1
a5623 1
					    "pf: IPv6 short rthdr");
d5630 1
a5630 1
					    "pf: IPv6 rthdr0");
d5646 1
a5646 1
					    "pf: IPv6 short opt");
d5923 1
a5923 1
		    "pf: dropping IPv4 packet with ICMPv6 payload");
d6173 1
a6173 1
		    "pf: dropping IPv6 packet with ICMPv4 payload");
d6216 1
a6216 1
		    "pf: dropping packet with dangerous v6 headers");
@


1.716
log
@Address comparisson is implemented twice in pf.c.  Put this into a
common function pf_addr_compare().
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.715 2010/12/24 20:12:56 henning Exp $ */
d6055 1
a6055 1
	struct mbuf		*m = *m0, *n = NULL;
a6119 3
	/* ptr to original, normalization can get us a new one */
	n = m;

a6209 6
	/* if normalization got us a new mbuf, free original */
	if (n != m) {
		m_freem(n);
		n = NULL;
	}

@


1.715
log
@in pf_src_connlimit, the indices to sk->addr were swapped.
tracked down and diff sent by Robert B Mills <rbmills at sdf.lonestar.org>
thanks, very good work! ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.714 2010/12/07 11:39:40 jsg Exp $ */
d300 2
d319 1
a319 1
pf_src_compare(struct pf_src_node *a, struct pf_src_node *b)
d321 1
a321 11
	int	diff;

	if (a->rule.ptr > b->rule.ptr)
		return (1);
	if (a->rule.ptr < b->rule.ptr)
		return (-1);
	if ((diff = a->type - b->type) != 0)
		return (diff);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
d324 1
a324 1
		if (a->addr.addr32[0] > b->addr.addr32[0])
d326 1
a326 1
		if (a->addr.addr32[0] < b->addr.addr32[0])
d332 1
a332 1
		if (a->addr.addr32[3] > b->addr.addr32[3])
d334 1
a334 1
		if (a->addr.addr32[3] < b->addr.addr32[3])
d336 1
a336 1
		if (a->addr.addr32[2] > b->addr.addr32[2])
d338 1
a338 1
		if (a->addr.addr32[2] < b->addr.addr32[2])
d340 1
a340 1
		if (a->addr.addr32[1] > b->addr.addr32[1])
d342 1
a342 1
		if (a->addr.addr32[1] < b->addr.addr32[1])
d344 1
a344 1
		if (a->addr.addr32[0] > b->addr.addr32[0])
d346 1
a346 1
		if (a->addr.addr32[0] < b->addr.addr32[0])
d354 18
d648 4
a651 51
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
			return (1);
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
			return (-1);
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
			return (1);
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
			return (-1);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->addr[0].addr32[3] > b->addr[0].addr32[3])
			return (1);
		if (a->addr[0].addr32[3] < b->addr[0].addr32[3])
			return (-1);
		if (a->addr[1].addr32[3] > b->addr[1].addr32[3])
			return (1);
		if (a->addr[1].addr32[3] < b->addr[1].addr32[3])
			return (-1);
		if (a->addr[0].addr32[2] > b->addr[0].addr32[2])
			return (1);
		if (a->addr[0].addr32[2] < b->addr[0].addr32[2])
			return (-1);
		if (a->addr[1].addr32[2] > b->addr[1].addr32[2])
			return (1);
		if (a->addr[1].addr32[2] < b->addr[1].addr32[2])
			return (-1);
		if (a->addr[0].addr32[1] > b->addr[0].addr32[1])
			return (1);
		if (a->addr[0].addr32[1] < b->addr[0].addr32[1])
			return (-1);
		if (a->addr[1].addr32[1] > b->addr[1].addr32[1])
			return (1);
		if (a->addr[1].addr32[1] < b->addr[1].addr32[1])
			return (-1);
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
			return (1);
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
			return (-1);
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
			return (1);
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}

a655 1

a657 1

@


1.714
log
@remove a bunch of unused arguments
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.713 2010/09/24 02:28:10 henning Exp $ */
d488 1
a488 1
				    PF_AEQ(&sn->addr, &sk->addr[0], sk->af)) ||
d490 1
a490 1
				    PF_AEQ(&sn->addr, &sk->addr[1], sk->af))) &&
@


1.713
log
@itojun picked exactly the right reason in that REASON_SET call. really no
reason to question himself by adding an XXX
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.712 2010/09/24 02:22:37 henning Exp $ */
d177 1
a177 1
			    void *, struct pf_pdesc *, struct pf_rule **,
d183 1
a183 1
			    int, struct pf_rule_slist *,
d188 1
a188 1
			    struct pfi_kif *, struct mbuf *, void *,
d200 1
a200 1
			    void *, struct pf_pdesc *, u_short *);
d203 1
a203 1
			    void *, struct pf_pdesc *);
d210 1
a210 1
			    void *, struct pf_pdesc *, u_short *);
d214 1
a214 2
			    struct ifnet *, struct pf_state *,
			    struct pf_pdesc *);
d216 1
a216 2
			    struct ifnet *, struct pf_state *,
			    struct pf_pdesc *);
d2771 1
a2771 1
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
d3053 1
a3053 1
		    &rewrite, kif, sm, tag, hdrlen, &rules, &act, sns);
d3067 1
a3067 1
			    virtual_type, icmp_dir, m);
d3109 1
a3109 1
    int tag, int hdrlen, struct pf_rule_slist *rules,
d3299 1
a3299 1
    int icmp_dir, struct mbuf *m)
d3417 1
a3417 1
    struct mbuf *m, void *h, struct pf_pdesc *pd, struct pf_rule **am,
d3899 1
a3899 1
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
d4074 1
a4074 1
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd)
d4202 1
a4202 1
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd, u_short *reason)
d5114 1
a5114 1
    struct pf_state *s, struct pf_pdesc *pd)
d5309 1
a5309 1
    struct pf_state *s, struct pf_pdesc *pd)
d5646 1
a5646 1
					     m, h, pd, a, ruleset);
d5894 1
a5894 1
		action = pf_test_fragment(&r, dir, kif, m, h,
d5907 1
a5907 1
		action = pf_test_state_tcp(&s, dir, kif, m, off, h, &pd,
d5918 1
a5918 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq, hdrlen);
d5930 1
a5930 1
		action = pf_test_state_udp(&s, dir, kif, m, off, h, &pd);
d5940 1
a5940 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq, hdrlen);
d5945 1
a5945 1
		action = pf_test_state_icmp(&s, dir, kif, m, off, h, &pd,
d5956 1
a5956 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq, hdrlen);
d5977 1
a5977 1
			action = pf_test_rule(&r, &s, dir, kif, m, off, h,
d6079 1
a6079 1
			pf_route(m0, r, dir, kif->pfik_ifp, s, &pd);
d6176 1
a6176 1
		action = pf_test_state_tcp(&s, dir, kif, m, off, h, &pd,
d6187 1
a6187 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq, hdrlen);
d6199 1
a6199 1
		action = pf_test_state_udp(&s, dir, kif, m, off, h, &pd);
d6209 1
a6209 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq, hdrlen);
d6222 1
a6222 1
		    m, off, h, &pd, &reason);
d6232 1
a6232 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq, hdrlen);
d6246 1
a6246 1
			action = pf_test_rule(&r, &s, dir, kif, m, off, h,
d6347 1
a6347 1
			pf_route6(m0, r, dir, kif->pfik_ifp, s, &pd);
@


1.712
log
@use pd->rdomain for the PF_MISMATCHAW checks in pf_test_fragment instead of
hardcoding 0.
roughly almost a bit equivalent to what pf_test_rule does. changing the
rdomain for not reassembled fragments is not going to work ever, so the
full dance pf_test_rule does doesn't make sense here.
speaking of sense, I don't see anything remotely resembling sense in
pf filtering on fragments without reassembling them first.
with/ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.711 2010/09/24 02:15:00 henning Exp $ */
d6155 1
a6155 1
		REASON_SET(&reason, PFRES_NORM);	/*XXX*/
@


1.711
log
@no need to pf_tag_packet in the stateless case in pf_test since
pf_test_rule will have done it already, as correctly XXX-comment noted by
claudio almost a year ago.
pf_test6 (which is scarily different there) didn't have that at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.710 2010/09/24 02:06:47 henning Exp $ */
d3442 1
a3442 1
		    r->src.neg, kif, /* XXX rdomain */ 0))
d3445 1
a3445 1
		    r->dst.neg, NULL, /* XXX rdomain */ 0))
@


1.710
log
@hello, this is captain obvious speaking:
/*  XXX This does NOT affect pass rules! */
SLIST_FOREACH(ri, &s->match_rules, entry) {
...
delete that comment, entirely superfluous
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.709 2010/09/24 01:56:12 henning Exp $ */
a6002 2
		/* XXX tag not needed since it is done in pf_test_rule ??? */
		pf_tag_packet(m, r->tag, r->rtableid);
@


1.709
log
@remove misleading XXX comment. it is pretty clear by now that
pf_compare_state_keys will stay, we play safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.708 2010/09/24 01:53:22 henning Exp $ */
a5801 6
			/*
			 * We want to increase counters on _all_ rules
			 * that were matched during processing. 
			 *  XXX This does NOT affect pass rules!
			 *  XXX Change this in pf_test_rule()?
			 */
@


1.708
log
@nicer linewraps, purely cosmetic
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.707 2010/09/24 00:55:48 jsg Exp $ */
a947 1
/* XXX debug function, intended to be removed one day */
@


1.707
log
@kill some unused arguments to pf_create_state
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.706 2010/09/23 14:17:02 mcbride Exp $ */
d3056 1
a3056 2
		    &rewrite, kif, sm, tag, hdrlen,
		    &rules, &act, sns);
d3112 2
a3113 3
    int tag, int hdrlen,
    struct pf_rule_slist *rules, struct pf_rule_actions *act,
    struct pf_src_node *sns[PF_SN_MAX])
@


1.706
log
@Break out rule counter update code into a separate function, makes the
behaviour consistent between IPv4 and IPv6.

From martin.pelikan@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.705 2010/09/22 05:58:29 henning Exp $ */
d183 1
a183 1
			    u_int16_t, u_int16_t, int, struct pf_rule_slist *,
a2794 1
	u_int16_t		 bproto_sum = 0, bip_sum;
d3056 1
a3056 1
		    &rewrite, kif, sm, tag, bproto_sum, bip_sum, hdrlen,
d3113 1
a3113 1
    int tag, u_int16_t bproto_sum, u_int16_t bip_sum, int hdrlen,
@


1.705
log
@add a new log opt PF_LOG_MATCHES
forces logging on all subsequent matching rules
real ok theo assumed oks ryan and dlg bikeshedding everyone in the room
implementation time ~ 1 minute
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.704 2010/09/22 02:12:36 henning Exp $ */
d242 4
d5776 58
d5847 2
a5848 2
	int			 off, hdrlen, dirndx, pqid = 0;
	u_int16_t		 qid;
d6076 1
a6076 42
	kif->pfik_bytes[0][dir == PF_OUT][action != PF_PASS] += pd.tot_len;
	kif->pfik_packets[0][dir == PF_OUT][action != PF_PASS]++;

	if (action == PF_PASS || r->action == PF_DROP) {
		dirndx = (dir == PF_OUT);
		r->packets[dirndx]++;
		r->bytes[dirndx] += pd.tot_len;
		if (a != NULL) {
			a->packets[dirndx]++;
			a->bytes[dirndx] += pd.tot_len;
		}
		if (s != NULL) {
			struct pf_rule_item	*ri;
			struct pf_sn_item	*sni;

			SLIST_FOREACH(sni, &s->src_nodes, next) {
				sni->sn->packets[dirndx]++;
				sni->sn->bytes[dirndx] += pd.tot_len;
			}
			dirndx = (dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd.tot_len;
			SLIST_FOREACH(ri, &s->match_rules, entry) {
				ri->r->packets[dirndx]++;
				ri->r->bytes[dirndx] += pd.tot_len;
			}
		}
		if (r->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(r->src.addr.p.tbl,
			    (s == NULL) ? pd.src :
			    &s->key[(s->direction == PF_IN)]->
				addr[(s->direction == PF_OUT)],
			    pd.af, pd.tot_len, dir == PF_OUT,
			    r->action == PF_PASS, r->src.neg);
		if (r->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(r->dst.addr.p.tbl,
			    (s == NULL) ? pd.dst :
			    &s->key[(s->direction == PF_IN)]->
				addr[(s->direction == PF_IN)],
			    pd.af, pd.tot_len, dir == PF_OUT,
			    r->action == PF_PASS, r->dst.neg);
	}
d6114 1
a6114 1
	int			 off, hdrlen, dirndx;
d6344 1
a6344 35
	kif->pfik_bytes[1][dir == PF_OUT][action != PF_PASS] += pd.tot_len;
	kif->pfik_packets[1][dir == PF_OUT][action != PF_PASS]++;

	if (action == PF_PASS || r->action == PF_DROP) {
		dirndx = (dir == PF_OUT);
		r->packets[dirndx]++;
		r->bytes[dirndx] += pd.tot_len;
		if (a != NULL) {
			a->packets[dirndx]++;
			a->bytes[dirndx] += pd.tot_len;
		}
		if (s != NULL) {
			struct pf_sn_item	*sni;

			SLIST_FOREACH(sni, &s->src_nodes, next) {
				sni->sn->packets[dirndx]++;
				sni->sn->bytes[dirndx] += pd.tot_len;
			}
			dirndx = (dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd.tot_len;
		}
		if (r->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(r->src.addr.p.tbl,
			    (s == NULL) ? pd.src :
			    &s->key[(s->direction == PF_IN)]->addr[0],
			    pd.af, pd.tot_len, dir == PF_OUT,
			    r->action == PF_PASS, r->src.neg);
		if (r->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(r->dst.addr.p.tbl,
			    (s == NULL) ? pd.dst :
			    &s->key[(s->direction == PF_IN)]->addr[1],
			    pd.af, pd.tot_len, dir == PF_OUT,
			    r->action == PF_PASS, r->dst.neg);
	}
@


1.704
log
@various whitespace fixes that my hands did while i was looking for sth
else and an unneeded if (r)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.703 2010/09/21 11:29:12 henning Exp $ */
d2942 1
a2942 1
					if (r->log)
d2951 4
d2980 1
a2980 1
	if (r->log)
@


1.703
log
@assert copyrights / bump years
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.702 2010/09/21 10:43:41 henning Exp $ */
a1490 1

a1573 1

a2140 1

a2338 1

d2969 4
a2972 6
	if (r) {
		pf_rule_to_actions(r, &act);
		if (pf_get_transaddr(r, pd, sns) == -1) {
			REASON_SET(&reason, PFRES_MEMORY);
			goto cleanup;
		}
a2973 1

a3675 1

a3715 1

a3776 1

a3783 1

@


1.702
log
@after ruleset eval is done, we must apply actions from the last matching
pass or block rule, not the last matching rule. triggered by pr6401.
this means that, for example, a rdr-to on a pass rule can override an
rdr-to on a match rule that comes later in the ruleset. but that's the
semantics: for block and pass rules, the last matching one wins, aka
actions are applied after we're done with ruleset eval, and match rules'
actions are applied on the fly. discussion with dlg and claudio, ok dlg ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.701 2010/09/21 10:37:33 henning Exp $ */
d5 1
a5 1
 * Copyright (c) 2002 - 2008 Henning Brauer
@


1.701
log
@do not increment states_tot on match rules. it is purely cosmetic, this
value is used in verbose "show rules" output as "states creations", but
match rules never create state. states_cur aka "States" is needed and
correct, match rules are being associated with states. ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.700 2010/09/21 07:04:24 henning Exp $ */
d2972 4
a2975 4
	/* apply actions for last matching rule */
	if (lastr && lastr->action != PF_MATCH) {
		pf_rule_to_actions(lastr, &act);
		if (pf_get_transaddr(lastr, pd, sns) == -1) {
@


1.700
log
@make "match log" rules log on the fly. thus you can log and see the packet
as it is in the very same moment pf hits that match rule. really awesome
with multiple rdr-to and the like. ok dlg - ryan would ok it too if he was
here right now
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.699 2010/09/21 04:09:33 henning Exp $ */
d284 1
a284 1
		SLIST_FOREACH(mrm, &s->match_rules, entry) {	\
a285 2
			mrm->r->states_tot++;			\
		}						\
@


1.699
log
@remove now obsolete XXX comment
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.698 2010/09/21 03:42:17 henning Exp $ */
d2948 4
d2985 3
a2987 11
	if (act.log) {
		struct pf_rule_item *mr;

		if (r->log)
			PFLOG_PACKET(kif, h, m, af, direction, reason,
			    r, a, ruleset, pd);
		SLIST_FOREACH(mr, &rules, entry)
			if (mr->r->log)
				PFLOG_PACKET(kif, h, m, af, direction, reason,
				    mr->r, a, ruleset, pd);
	}
@


1.698
log
@make pf_translate (void so far) return 1 if it actually changed something
and 0 if it didn't so we know wether we have to rewrite or not.
ok ryan dlg
and in just an hour from now on this might have reached cvs eventually
from njetwork challenged j2k10 in japan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.697 2010/09/21 02:51:35 henning Exp $ */
a2983 1
		/* XXX this is BEFORE nat/rdr are actually applied! */ 
@


1.697
log
@factor our the code to set up pf_pdesc, a central structure in pf carrying
information about the packet we're currently dealing with, into its own
function. ok ryan dlg and additional testing sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.696 2010/08/05 17:21:19 bluhm Exp $ */
a186 3
void			 pf_translate(struct pf_pdesc *, struct pf_addr *,
			    u_int16_t, struct pf_addr *, u_int16_t, u_int16_t,
			    int, struct mbuf *);
d3075 1
a3075 1
			pf_translate(pd,
a3078 1
			rewrite = 1;
d3308 1
a3308 1
void
d3313 7
d3325 1
a3325 1
		if (PF_ANEQ(saddr, pd->src, pd->af) || *pd->sport != sport)
d3327 4
a3330 2
			    &pd->hdr.tcp->th_sum, saddr, sport, 0, pd->af);
		if (PF_ANEQ(daddr, pd->dst, pd->af) || *pd->dport != dport)
d3333 2
d3338 1
a3338 1
		if (PF_ANEQ(saddr, pd->src, pd->af) || *pd->sport != sport)
d3341 3
a3343 1
		if (PF_ANEQ(daddr, pd->dst, pd->af) || *pd->dport != dport)
d3346 2
d3352 1
a3352 1
		if (PF_ANEQ(saddr, pd->src, pd->af))
d3355 3
a3357 1
		if (PF_ANEQ(daddr, pd->dst, pd->af))
d3360 2
d3370 1
d3379 1
a3379 1
			if (PF_ANEQ(saddr, pd->src, pd->af))
d3382 3
a3384 1
			if (PF_ANEQ(daddr, pd->dst, pd->af))
d3387 2
d3398 1
a3398 1
			if (PF_ANEQ(saddr, pd->src, pd->af))
d3401 3
a3403 1
			if (PF_ANEQ(daddr, pd->dst, pd->af))
d3406 2
d3412 1
a3412 1
			if (PF_ANEQ(saddr, pd->src, pd->af))
d3414 3
a3416 1
			if (PF_ANEQ(daddr, pd->dst, pd->af))
d3418 2
d3424 1
@


1.696
log
@In pf_icmp_mapping() the ICMP and ICMPv6 types shared the same
number space.  In fact they are independent and must be handled
separately.  Fix traceroute via pf by splitting pf_icmp_mapping()
into IPv4 and IPv6 sections.
ok henning@@ mcbride@@; tested mcbride@@; sure deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.695 2010/07/02 02:40:16 blambert Exp $ */
d127 11
d178 1
a178 1
			    struct pf_ruleset **, struct ifqueue *);
d2781 1
a2781 1
    struct ifqueue *ifq)
d2794 1
a2794 1
	int			 rewrite = 0, hdrlen = 0;
a2819 1
		hdrlen = sizeof(*th);
a2823 1
		hdrlen = sizeof(*pd->hdr.udp);
a2828 1
		hdrlen = ICMP_MINLEN;
a2845 1
		hdrlen = sizeof(*pd->hdr.icmp6);
d2860 1
a2860 1
		pd->nsport = pd->ndport = hdrlen = 0;
d5527 230
d5770 1
a5770 1
	int			 off, dirndx, pqid = 0;
d5777 1
d5819 4
a5822 5
	off = h->ip_hl << 2;
	if (off < (int)sizeof(*h)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_SHORT);
		pflog |= PF_LOG_FORCE;
a5824 13

	pd.src = (struct pf_addr *)&h->ip_src;
	pd.dst = (struct pf_addr *)&h->ip_dst;
	pd.sport = pd.dport = NULL;
	pd.ip_sum = &h->ip_sum;
	pd.proto_sum = NULL;
	pd.proto = h->ip_p;
	pd.dir = dir;
	pd.sidx = (dir == PF_IN) ? 0 : 1;
	pd.didx = (dir == PF_IN) ? 1 : 0;
	pd.af = AF_INET;
	pd.tos = h->ip_tos;
	pd.tot_len = ntohs(h->ip_len);
a5825 1
	pd.rdomain = rtable_l2(m->m_pkthdr.rdomain);
d5837 1
a5837 11
		struct tcphdr	th;

		pd.hdr.tcp = &th;
		if (!pf_pull_hdr(m, off, &th, sizeof(th),
		    &action, &reason, AF_INET)) {
			if (action != PF_PASS)
				pflog |= PF_LOG_FORCE;
			goto done;
		}
		pd.p_len = pd.tot_len - off - (th.th_off << 2);
		if ((th.th_flags & TH_ACK) && pd.p_len == 0)
a5838 2
		pd.sport = &th.th_sport;
		pd.dport = &th.th_dport;
d5853 1
a5853 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
a5864 18
		struct udphdr	uh;

		pd.hdr.udp = &uh;
		if (!pf_pull_hdr(m, off, &uh, sizeof(uh),
		    &action, &reason, AF_INET)) {
			if (action != PF_PASS)
				pflog |= PF_LOG_FORCE;
			goto done;
		}
		if (uh.uh_dport == 0 ||
		    ntohs(uh.uh_ulen) > m->m_pkthdr.len - off ||
		    ntohs(uh.uh_ulen) < sizeof(struct udphdr)) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_SHORT);
			goto done;
		}
		pd.sport = &uh.uh_sport;
		pd.dport = &uh.uh_dport;
d5875 1
a5875 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
a5879 9
		struct icmp	ih;

		pd.hdr.icmp = &ih;
		if (!pf_pull_hdr(m, off, &ih, ICMP_MINLEN,
		    &action, &reason, AF_INET)) {
			if (action != PF_PASS)
				pflog |= PF_LOG_FORCE;
			goto done;
		}
d5891 1
a5891 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
d5913 1
a5913 1
			    &pd, &a, &ruleset, &ipintrq);
d6078 1
a6078 1
	int			 off, terminal = 0, dirndx, rh_cnt = 0;
d6084 1
a6136 81
	pd.src = (struct pf_addr *)&h->ip6_src;
	pd.dst = (struct pf_addr *)&h->ip6_dst;
	pd.sport = pd.dport = NULL;
	pd.ip_sum = NULL;
	pd.proto_sum = NULL;
	pd.dir = dir;
	pd.sidx = (dir == PF_IN) ? 0 : 1;
	pd.didx = (dir == PF_IN) ? 1 : 0;
	pd.af = AF_INET6;
	pd.tos = 0;
	pd.tot_len = ntohs(h->ip6_plen) + sizeof(struct ip6_hdr);
	pd.eh = eh;

	off = ((caddr_t)h - m->m_data) + sizeof(struct ip6_hdr);
	pd.proto = h->ip6_nxt;
	do {
		switch (pd.proto) {
		case IPPROTO_FRAGMENT:
			action = pf_test_fragment(&r, dir, kif, m, h,
			    &pd, &a, &ruleset);
			if (action == PF_DROP)
				REASON_SET(&reason, PFRES_FRAG);
			goto done;
		case IPPROTO_ROUTING: {
			struct ip6_rthdr rthdr;

			if (rh_cnt++) {
				DPFPRINTF(LOG_NOTICE,
				    "pf: IPv6 more than one rthdr");
				action = PF_DROP;
				REASON_SET(&reason, PFRES_IPOPTIONS);
				pflog |= PF_LOG_FORCE;
				goto done;
			}
			if (!pf_pull_hdr(m, off, &rthdr, sizeof(rthdr), NULL,
			    &reason, pd.af)) {
				DPFPRINTF(LOG_NOTICE,
				    "pf: IPv6 short rthdr");
				action = PF_DROP;
				REASON_SET(&reason, PFRES_SHORT);
				pflog |= PF_LOG_FORCE;
				goto done;
			}
			if (rthdr.ip6r_type == IPV6_RTHDR_TYPE_0) {
				DPFPRINTF(LOG_NOTICE,
				    "pf: IPv6 rthdr0");
				action = PF_DROP;
				REASON_SET(&reason, PFRES_IPOPTIONS);
				pflog |= PF_LOG_FORCE;
				goto done;
			}
			/* FALLTHROUGH */
		}
		case IPPROTO_AH:
		case IPPROTO_HOPOPTS:
		case IPPROTO_DSTOPTS: {
			/* get next header and header length */
			struct ip6_ext	opt6;

			if (!pf_pull_hdr(m, off, &opt6, sizeof(opt6),
			    NULL, &reason, pd.af)) {
				DPFPRINTF(LOG_NOTICE,
				    "pf: IPv6 short opt");
				action = PF_DROP;
				pflog |= PF_LOG_FORCE;
				goto done;
			}
			if (pd.proto == IPPROTO_AH)
				off += (opt6.ip6e_len + 2) * 4;
			else
				off += (opt6.ip6e_len + 1) * 8;
			pd.proto = opt6.ip6e_nxt;
			/* goto the next header */
			break;
		}
		default:
			terminal++;
			break;
		}
	} while (!terminal);

d6140 8
a6150 12
		struct tcphdr	th;

		pd.hdr.tcp = &th;
		if (!pf_pull_hdr(m, off, &th, sizeof(th),
		    &action, &reason, AF_INET6)) {
			if (action != PF_PASS)
				pflog |= PF_LOG_FORCE;
			goto done;
		}
		pd.p_len = pd.tot_len - off - (th.th_off << 2);
		pd.sport = &th.th_sport;
		pd.dport = &th.th_dport;
d6165 1
a6165 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
a6176 18
		struct udphdr	uh;

		pd.hdr.udp = &uh;
		if (!pf_pull_hdr(m, off, &uh, sizeof(uh),
		    &action, &reason, AF_INET6)) {
			if (action != PF_PASS)
				pflog |= PF_LOG_FORCE;
			goto done;
		}
		if (uh.uh_dport == 0 ||
		    ntohs(uh.uh_ulen) > m->m_pkthdr.len - off ||
		    ntohs(uh.uh_ulen) < sizeof(struct udphdr)) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_SHORT);
			goto done;
		}
		pd.sport = &uh.uh_sport;
		pd.dport = &uh.uh_dport;
d6187 1
a6187 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
a6198 32
		union {
			struct icmp6_hdr		icmp6;
			struct mld_hdr			mld;
			struct nd_neighbor_solicit	nd;
		} ih;
		size_t	icmp_hlen = sizeof(struct icmp6_hdr);

		pd.hdr.icmp6 = &ih.icmp6;
		if (!pf_pull_hdr(m, off, &ih, icmp_hlen,
		    &action, &reason, AF_INET6)) {
			if (action != PF_PASS)
				pflog |= PF_LOG_FORCE;
			goto done;
		}
		/* ICMP headers we look further into to match state */
		switch (ih.icmp6.icmp6_type) {
		case MLD_LISTENER_QUERY:
		case MLD_LISTENER_REPORT:
			icmp_hlen = sizeof(struct mld_hdr);
			break;
		case ND_NEIGHBOR_SOLICIT:
		case ND_NEIGHBOR_ADVERT:
			icmp_hlen = sizeof(struct nd_neighbor_solicit);
			break;
		}
		if (icmp_hlen > sizeof(struct icmp6_hdr) &&
		    !pf_pull_hdr(m, off, &ih, icmp_hlen,
		    &action, &reason, AF_INET6)) {
			if (action != PF_PASS)
				pflog |= PF_LOG_FORCE;
			goto done;
		}
d6210 1
a6210 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
d6225 1
a6225 1
			    &pd, &a, &ruleset, &ip6intrq);
d6237 1
a6237 1
	if (action == PF_PASS && rh_cnt &&
@


1.696.2.1
log
@Merge PF fix from -current.  Thanks jsg@@ mcbride@@ for testing.

----
Add missing byte-order swap to pf_match_addr_range. Without this, rules
using address ranges (e.g. "10.1.1.1 - 10.1.1.5") did not match addresses
correctly on little-endian systems.  ok henning@@
----
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.696 2010/08/05 17:21:19 bluhm Exp $ */
d2218 2
a2219 2
		if ((ntohl(a->addr32[0]) < ntohl(b->addr32[0])) ||
		    (ntohl(a->addr32[0]) > ntohl(e->addr32[0])))
d2229 1
a2229 1
			if (ntohl(a->addr32[i]) > ntohl(b->addr32[i]))
d2231 1
a2231 1
			else if (ntohl(a->addr32[i]) < ntohl(b->addr32[i]))
d2235 1
a2235 1
			if (ntohl(a->addr32[i]) < ntohl(e->addr32[i]))
d2237 1
a2237 1
			else if (ntohl(a->addr32[i]) > ntohl(e->addr32[i]))
@


1.695
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.694 2010/07/01 19:45:29 henning Exp $ */
d1643 1
a1643 1
    int *icmp_dir, int *multi, u_int16_t *icmpid, u_int16_t *icmptype)
d1654 24
a1677 7
	switch (type) {
	case ICMP_ECHO:
		*icmp_dir = PF_IN;
	case ICMP_ECHOREPLY:
		*icmptype = ICMP_ECHO;
		*icmpid = pd->hdr.icmp->icmp_id;
		break;
d1679 6
a1684 6
	case ICMP_TSTAMP:
		*icmp_dir = PF_IN;
	case ICMP_TSTAMPREPLY:
		*icmptype = ICMP_TSTAMP;
		*icmpid = pd->hdr.icmp->icmp_id;
		break;
d1686 6
a1691 6
	case ICMP_IREQ:
		*icmp_dir = PF_IN;
	case ICMP_IREQREPLY:
		*icmptype = ICMP_IREQ;
		*icmpid = pd->hdr.icmp->icmp_id;
		break;
d1693 6
a1698 6
	case ICMP_MASKREQ:
		*icmp_dir = PF_IN;
	case ICMP_MASKREPLY:
		*icmptype = ICMP_MASKREQ;
		*icmpid = pd->hdr.icmp->icmp_id;
		break;
d1700 6
a1705 6
	case ICMP_IPV6_WHEREAREYOU:
		*icmp_dir = PF_IN;
	case ICMP_IPV6_IAMHERE:
		*icmptype = ICMP_IPV6_WHEREAREYOU;
		*icmpid = 0; /* Nothing sane to match on! */
		break;
d1707 12
a1718 6
	case ICMP_MOBILE_REGREQUEST:
		*icmp_dir = PF_IN;
	case ICMP_MOBILE_REGREPLY:
		*icmptype = ICMP_MOBILE_REGREQUEST;
		*icmpid = 0; /* Nothing sane to match on! */
		break;
d1720 10
a1729 5
	case ICMP_ROUTERSOLICIT:
		*icmp_dir = PF_IN;
	case ICMP_ROUTERADVERT:
		*icmptype = ICMP_ROUTERSOLICIT;
		*icmpid = 0; /* Nothing sane to match on! */
d1731 1
a1731 1

d1733 8
a1740 6
	case ICMP6_ECHO_REQUEST:
		*icmp_dir = PF_IN;
	case ICMP6_ECHO_REPLY:
		*icmptype = ICMP6_ECHO_REQUEST;
		*icmpid = pd->hdr.icmp6->icmp6_id;
		break;
d1742 13
a1754 4
	case MLD_LISTENER_QUERY:
		*icmp_dir = PF_IN;
	case MLD_LISTENER_REPORT: {
		struct mld_hdr *mld = (void *)pd->hdr.icmp6;
d1756 10
a1765 8
		*icmptype = MLD_LISTENER_QUERY;
		/* generate fake id for these messages */
		*icmpid = (mld->mld_addr.s6_addr32[0] ^
			mld->mld_addr.s6_addr32[1] ^
			mld->mld_addr.s6_addr32[2] ^
			mld->mld_addr.s6_addr32[3]) & 0xffff;
		break;
	}
d1767 6
a1772 7
	/* ICMP6_FQDN and ICMP6_NI query/reply are the same type as ICMP6_WRU */
	case ICMP6_WRUREQUEST:
		*icmp_dir = PF_IN;
	case ICMP6_WRUREPLY:
		*icmptype = ICMP6_WRUREQUEST;
		*icmpid = 0; /* Nothing sane to match on! */
		break;
d1774 14
a1787 6
	case MLD_MTRACE:
		*icmp_dir = PF_IN;
	case MLD_MTRACE_RESP:
		*icmptype = MLD_MTRACE;
		*icmpid = 0; /* Nothing sane to match on! */
		break;
d1789 25
a1813 12
	case ND_NEIGHBOR_SOLICIT:
		*icmp_dir = PF_IN;
	case ND_NEIGHBOR_ADVERT: {
		struct nd_neighbor_solicit *nd = (void *)pd->hdr.icmp6;

		*icmptype = ND_NEIGHBOR_SOLICIT;
		*multi = PF_ICMP_MULTI_SOLICITED;
		/* generate fake id for these messages */
		*icmpid = (nd->nd_ns_target.s6_addr32[0] ^
			nd->nd_ns_target.s6_addr32[1] ^
			nd->nd_ns_target.s6_addr32[2] ^
			nd->nd_ns_target.s6_addr32[3]) & 0xffff;
a1814 2
	}

a1815 23
	/* These ICMP types map to other connections */
	case ICMP_UNREACH:
	case ICMP_SOURCEQUENCH:
	case ICMP_REDIRECT:
	case ICMP_TIMXCEED:
	case ICMP_PARAMPROB:
#ifdef INET6
	/*
	 * ICMP6_TIME_EXCEEDED is the same type as ICMP_UNREACH
	 * ND_REDIRECT can't be in this list because the triggering packet
	 * header is optional.
	 */
	case ICMP6_PACKET_TOO_BIG:
#endif /* INET6 */
		/* These will not be used, but set them anyways */
		*icmp_dir = PF_IN;
		*icmptype = type;
		*icmpid = 0;
		return (1);	/* These types are matched to other state */
	/*
	 * All remaining ICMP types get their own states,
	 * and will only match in one direction.
	 */
d1818 2
a1819 2
		*icmptype = type;
		*icmpid = 0;
d1822 2
a1823 2
	HTONS(*icmptype);
	return (0);
d4644 1
a4644 1
				    (virtual_type == ICMP_ECHO &&
d4647 1
a4647 1
					    (virtual_type == ICMP_ECHO) ?
d4650 2
a4651 2
					    (virtual_type == ICMP_ECHO) ?
					    nk->port[iidx] : NULL, NULL,
d4717 2
a4718 1
			 	    ((virtual_type == ICMP6_ECHO_REQUEST) &&
d4721 2
a4722 1
					    (virtual_type == ICMP6_ECHO_REQUEST)
d4725 3
a4727 2
					    (virtual_type == ICMP6_ECHO_REQUEST)
					    ? nk->port[iidx] : NULL, NULL,
@


1.694
log
@g/c unused param to pf_translate
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.693 2010/06/27 21:58:35 henning Exp $ */
d1932 1
a1932 1
		m_copyback(m, off + sizeof(*th), thoptlen, opts);
d3050 1
a3050 1
		m_copyback(m, off, hdrlen, pd->hdr.any);
d4011 1
a4011 1
		m_copyback(m, off, sizeof(*th), th);
d4081 1
a4081 1
		m_copyback(m, off, sizeof(*uh), uh);
d4231 1
a4231 1
				    pd->hdr.icmp);
d4252 1
a4252 1
				    pd->hdr.icmp6);
d4484 1
a4484 1
					    pd->hdr.icmp);
d4486 1
a4486 1
					    &h2);
d4493 1
a4493 1
					    pd->hdr.icmp6);
d4495 1
a4495 1
					    &h2_6);
d4499 1
a4499 1
				m_copyback(m, off2, 8, &th);
d4559 3
a4561 2
					    pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2), &h2);
d4568 1
a4568 1
					    pd->hdr.icmp6);
d4570 1
a4570 1
					    &h2_6);
d4574 1
a4574 1
				m_copyback(m, off2, sizeof(uh), &uh);
d4631 6
a4636 3
				m_copyback(m, off, ICMP_MINLEN, pd->hdr.icmp);
				m_copyback(m, ipoff2, sizeof(h2), &h2);
				m_copyback(m, off2, ICMP_MINLEN, &iih);
d4705 3
a4707 2
				    pd->hdr.icmp6);
				m_copyback(m, ipoff2, sizeof(h2_6), &h2_6);
d4709 1
a4709 1
				    &iih);
d4755 3
a4757 2
					    pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2), &h2);
d4764 1
a4764 1
					    pd->hdr.icmp6);
d4766 1
a4766 1
					    &h2_6);
@


1.693
log
@fix a comment and add a new one to make clear what the mbuf ptr save dance
is for, it is not very obvious... with ryan and jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.692 2010/06/27 01:39:43 henning Exp $ */
d178 1
a178 1
			    int, struct mbuf *, int);
d3038 1
a3038 1
			    virtual_type, icmp_dir, m, off);
d3272 1
a3272 1
    int icmp_dir, struct mbuf *m, int off)
@


1.692
log
@stuff nsaddr/ndaddr/nsport/ndport (addrs/ports after NAT, used a lot while
walking the ruleset and up until state is fully set up) into pf_pdesc instead
of passing around those 4 seperately all the time, also shrinks the argument
count for a few functions that have/partialy had an insane count of arguments.
kinda preparational since we'll need them elsewhere too, soon
ok ryan jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.691 2010/05/07 13:33:16 claudio Exp $ */
d5988 2
a5989 3
	/* if there's no routing header, use unmodified mbuf for checksumming */
	if (!n)
		n = m;
d6135 1
@


1.691
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.690 2010/02/04 14:10:12 sthen Exp $ */
d171 2
a172 4
			    struct pf_addr *, u_int16_t, struct pf_addr *,
			    u_int16_t, int *, struct pfi_kif *,
			    struct pf_state **, int, u_int16_t, u_int16_t,
			    int, struct pf_rule_slist *,
d174 2
d829 2
a830 4
pf_state_key_setup(struct pf_pdesc *pd,
	struct pf_state_key **skw, struct pf_state_key **sks,
	struct pf_addr **saddr, struct pf_addr **daddr,
	u_int16_t *sport, u_int16_t *dport, int rtableid)
d849 3
a851 3
	if (PF_ANEQ(*saddr, pd->src, pd->af) ||
	    PF_ANEQ(*daddr, pd->dst, pd->af) ||
	    *sport != pd->osport || *dport != pd->odport ||
d857 4
a860 4
		PF_ACPY(&sk2->addr[pd->sidx], *saddr, pd->af);
		PF_ACPY(&sk2->addr[pd->didx], *daddr, pd->af);
		sk2->port[pd->sidx] = *sport;
		sk2->port[pd->didx] = *dport;
a2736 1
	struct pf_addr		 saddr, daddr;
d2752 1
a2752 1
	u_int16_t		 sport, dport, virtual_type, virtual_id;
d2756 2
a2757 2
	PF_ACPY(&saddr, pd->src, pd->af);
	PF_ACPY(&daddr, pd->dst, pd->af);
d2771 2
a2772 2
		sport = th->th_sport;
		dport = th->th_dport;
d2776 2
a2777 2
		sport = pd->hdr.udp->uh_sport;
		dport = pd->hdr.udp->uh_dport;
d2790 2
a2791 2
			sport = virtual_id;
			dport = virtual_type;
d2793 2
a2794 2
			sport = virtual_type;
			dport = virtual_id;
d2808 2
a2809 2
			sport = virtual_id;
			dport = virtual_type;
d2811 2
a2812 2
			sport = virtual_type;
			dport = virtual_id;
d2817 1
a2817 1
		sport = dport = hdrlen = 0;
d2821 2
a2822 2
	pd->osport = sport;
	pd->odport = dport;
d2835 1
a2835 1
		else if (PF_MISMATCHAW(&r->src.addr, &saddr, af,
d2840 1
a2840 1
		    r->src.port[0], r->src.port[1], sport))
d2842 1
a2842 1
		else if (PF_MISMATCHAW(&r->dst.addr, &daddr, af,
d2847 1
a2847 1
		    r->dst.port[0], r->dst.port[1], dport))
d2902 2
a2903 3
					if (pf_get_transaddr(r, pd,
					    &saddr, &sport, &daddr, &dport,
					    sns) == -1) {
d2933 1
a2933 2
		if (pf_get_transaddr(lastr, pd, &saddr, &sport, &daddr,
		    &dport, sns) == -1) {
d3022 3
a3024 3
		action = pf_create_state(r, a, pd, &skw, &sks, m,
		    off, &saddr, sport, &daddr, dport, &rewrite, kif, sm, tag,
		    bproto_sum, bip_sum, hdrlen, &rules, &act, sns);
d3080 1
a3080 2
    int off, struct pf_addr *saddr, u_int16_t sport, struct pf_addr *daddr,
    u_int16_t dport, int *rewrite, struct pfi_kif *kif, struct pf_state **sm,
d3196 1
a3196 2
	if (pf_state_key_setup(pd, skw, sks, &saddr, &daddr, &sport, &dport,
	    act->rtableid)) {
@


1.690
log
@pf_get_sport() picks a random port from the port range specified in a
nat rule. It should check to see if it's in-use (i.e. matches an existing
PF state), if it is, it cycles sequentially through other ports until
it finds a free one. However the check was being done with the state
keys the wrong way round so it was never actually finding the state
to be in-use.

- switch the keys to correct this, avoiding random state collisions
with nat. Fixes PR 6300 and problems reported by robert@@ and viq.

- check pf_get_sport() return code in pf_test(); if port allocation
fails the packet should be dropped rather than sent out untranslated.

Help/ok claudio@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.689 2010/01/18 23:52:46 mcbride Exp $ */
d216 1
a216 1
u_int16_t		 pf_calc_mss(struct pf_addr *, sa_family_t,
d2603 1
a2603 1
pf_calc_mss(struct pf_addr *addr, sa_family_t af, u_int16_t offer)
a2616 1
	/* XXX needs to know about routing domain or actually rtableid */
d2626 2
a2627 1
		rtalloc_noclone(&ro, NO_CLONING);
d2639 2
a2640 1
		rtalloc_noclone((struct route *)&ro6, NO_CLONING);
d2764 1
a2764 1
	act.rtableid = -1;
d2839 1
a2839 1
		    r->src.neg, kif))
d2846 1
a2846 1
		    r->dst.neg, NULL))
d3242 3
d3249 2
a3250 2
		mss = pf_calc_mss(pd->src, pd->af, mss);
		mss = pf_calc_mss(pd->dst, pd->af, mss);
d3387 1
a3387 1
		    r->src.neg, kif))
d3390 1
a3390 1
		    r->dst.neg, NULL))
d4920 2
a4921 1
pf_routable(struct pf_addr *addr, sa_family_t af, struct pfi_kif *kif)
a4937 1
	/* XXX needs to know about routing domain or actually rtableid */
d4940 1
d4974 1
a4974 1
	rtalloc_noclone((struct route *)&ro, NO_CLONING);
d5009 2
a5010 1
pf_rtlabel_match(struct pf_addr *addr, sa_family_t af, struct pf_addr_wrap *aw)
a5020 1
	/* XXX needs to know about routing domain or actually rtableid */
d5022 1
d5042 1
a5042 1
	rtalloc_noclone((struct route *)&ro, NO_CLONING);
d5104 1
@


1.690.2.1
log
@Merge PF fix from -current.  Thanks jsg@@ mcbride@@ for testing.

----
Add missing byte-order swap to pf_match_addr_range. Without this, rules
using address ranges (e.g. "10.1.1.1 - 10.1.1.5") did not match addresses
correctly on little-endian systems.  ok henning@@
----
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.690 2010/02/04 14:10:12 sthen Exp $ */
d2184 2
a2185 2
		if ((ntohl(a->addr32[0]) < ntohl(b->addr32[0])) ||
		    (ntohl(a->addr32[0]) > ntohl(e->addr32[0])))
d2195 1
a2195 1
			if (ntohl(a->addr32[i]) > ntohl(b->addr32[i]))
d2197 1
a2197 1
			else if (ntohl(a->addr32[i]) < ntohl(b->addr32[i]))
d2201 1
a2201 1
			if (ntohl(a->addr32[i]) < ntohl(e->addr32[i]))
d2203 1
a2203 1
			else if (ntohl(a->addr32[i]) > ntohl(e->addr32[i]))
@


1.689
log
@Convert pf debug logging to using log()/addlog(), a single standardised
definition of DPFPRINTF(), and log priorities from syslog.h. Old debug
levels will still work for now, but will eventually be phased out.

discussed with henning, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.688 2010/01/14 20:43:19 mcbride Exp $ */
d2904 7
a2910 2
					pf_get_transaddr(r, pd, &saddr, &sport,
					    &daddr, &dport, sns);
d2936 5
a2940 2
		pf_get_transaddr(lastr, pd, &saddr, &sport, &daddr, &dport,
		    sns);
@


1.688
log
@henning and I are both dumbasses, testing &foo against NULL is pointless.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.687 2010/01/14 01:19:46 mcbride Exp $ */
d54 1
a98 2
#define DPFPRINTF(n, x)	if (pf_status.debug >= (n)) printf x

d437 3
a439 2
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf_src_connlimit: blocking address ");
d492 2
a493 2
			if (pf_status.debug >= PF_DEBUG_MISC)
				printf(", %u states killed", killed);
d495 2
a496 2
		if (pf_status.debug >= PF_DEBUG_MISC)
			printf("\n");
d547 3
a549 2
			if (pf_status.debug >= PF_DEBUG_MISC) {
				printf("pf: src_tree insert failed: ");
d551 1
a551 1
				printf("\n");
d728 3
a730 2
					if (pf_status.debug >= PF_DEBUG_MISC) {
						printf("pf: %s key attach "
d740 1
a740 1
						printf(", existing: ");
d746 1
a746 1
						printf("\n");
d877 2
a878 2
	if (pf_status.debug >= PF_DEBUG_NOISY) {
		printf("pf: key setup: ");
d880 1
a880 1
		printf("\n");
d913 2
a914 2
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: "
d917 1
a917 1
			printf("\n");
d954 17
a970 13
		printf("pf: state key linking mismatch! dir=%s, "
		    "if=%s, stored af=%u, a0: ",
		    dir == PF_OUT ? "OUT" : "IN", kif->pfik_name, a->af);
		pf_print_host(&a->addr[0], a->port[0], a->af);
		printf(", a1: ");
		pf_print_host(&a->addr[1], a->port[1], a->af);
		printf(", proto=%u", a->proto);
		printf(", found af=%u, a0: ", b->af);
		pf_print_host(&b->addr[0], b->port[0], b->af);
		printf(", a1: ");
		pf_print_host(&b->addr[1], b->port[1], b->af);
		printf(", proto=%u", b->proto);
		printf(".\n");
d983 2
a984 2
	if (pf_status.debug >= PF_DEBUG_NOISY) {
		printf("pf: key search, if=%s: ", kif->pfik_name);
d986 1
a986 1
		printf("\n");
d1301 1
a1301 1
		printf("%u.%u.%u.%u", (a>>24)&255, (a>>16)&255,
d1305 1
a1305 1
			printf(":%u", p);
d1337 1
a1337 1
					printf(":");
d1339 1
a1339 1
					printf(":");
d1342 1
a1342 1
				printf("%x", b);
d1344 1
a1344 1
					printf(":");
d1349 1
a1349 1
			printf("[%u]", p);
d1378 1
a1378 1
		printf("IPv4");
d1381 1
a1381 1
		printf("IPv6");
d1384 1
a1384 1
		printf("TCP");
d1387 1
a1387 1
		printf("UDP");
d1390 1
a1390 1
		printf("ICMP");
d1393 1
a1393 1
		printf("ICMPv6");
d1396 1
a1396 1
		printf("%u", proto);
d1401 1
a1401 1
		printf(" in");
d1404 1
a1404 1
		printf(" out");
d1408 1
a1408 1
		printf(" wire: (%d) ", skw->rdomain);
d1410 1
a1410 1
		printf(" ");
d1414 1
a1414 1
		printf(" stack: (%d) ", sks->rdomain);
d1417 1
a1417 1
			printf(" ");
d1420 1
a1420 1
			printf("-");
d1424 1
a1424 1
			printf(" [lo=%u high=%u win=%u modulator=%u",
d1428 1
a1428 1
				printf(" wscale=%u",
d1430 2
a1431 2
			printf("]");
			printf(" [lo=%u high=%u win=%u modulator=%u",
d1435 1
a1435 1
				printf(" wscale=%u",
d1437 1
a1437 1
			printf("]");
d1439 1
a1439 1
		printf(" %u:%u", s->src.state, s->dst.state);
d1441 1
a1441 1
			printf(" @@%d", s->rule.ptr->nr);
d1449 1
a1449 1
		printf(" ");
d1451 1
a1451 1
		printf("F");
d1453 1
a1453 1
		printf("S");
d1455 1
a1455 1
		printf("R");
d1457 1
a1457 1
		printf("P");
d1459 1
a1459 1
		printf("A");
d1461 1
a1461 1
		printf("U");
d1463 1
a1463 1
		printf("E");
d1465 1
a1465 1
		printf("W");
d1542 1
a1542 1
		printf("invalid address type: %d\n", aw1->type);
d2288 3
a2290 3
		DPFPRINTF(PF_DEBUG_URGENT,
		    ("pf_test_via: kif == NULL, @@%d via %s\n", r->nr,
		    r->rcv_ifname));
d2322 1
a2322 1
		printf("pf_step_into_anchor: stack overflow\n");
d3186 2
a3187 2
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf_normalize_tcp_stateful failed on first pkt\n"));
d3684 2
a3685 2
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: loose state match: ");
d3688 1
a3688 1
			printf(" seq=%u (%u) ack=%u len=%u ackskew=%d "
d3739 2
a3740 2
		} else if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: BAD state: ");
d3743 1
a3743 1
			printf(" seq=%u (%u) ack=%u len=%u ackskew=%d "
d3749 1
a3749 1
			printf("pf: State failure on: %c %c %c %c | %c %c\n",
d3960 2
a3961 2
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state reuse ");
d3964 1
a3964 1
			printf("\n");
d4127 3
a4129 2
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: icmp type %d in wrong direction (%d): ",
d4132 1
a4132 1
			printf("\n");
d4284 2
a4285 3
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short "
				    "(ip)\n"));
d4312 2
a4313 3
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short "
				    "(ip6)\n"));
d4340 2
a4341 2
						DPFPRINTF(PF_DEBUG_MISC,
						    ("pf: ICMPv6 short opt\n"));
d4376 2
a4377 3
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short "
				    "(tcp)\n"));
d4415 3
a4417 2
				if (pf_status.debug >= PF_DEBUG_MISC) {
					printf("pf: BAD ICMP %d:%d ",
d4420 1
a4420 1
					printf(" -> ");
d4422 1
a4422 1
					printf(" state: ");
d4424 1
a4424 1
					printf(" seq=%u\n", seq);
d4429 3
a4431 2
				if (pf_status.debug >= PF_DEBUG_NOISY) {
					printf("pf: OK ICMP %d:%d ",
d4434 1
a4434 1
					printf(" -> ");
d4436 1
a4436 1
					printf(" state: ");
d4438 1
a4438 1
					printf(" seq=%u\n", seq);
d4505 2
a4506 3
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short "
				    "(udp)\n"));
d4579 2
a4580 3
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short i"
				    "(icmp)\n"));
d4639 3
a4641 3
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short "
				    "(icmp6)\n"));
d5077 2
a5078 2
		DPFPRINTF(PF_DEBUG_URGENT,
		    ("pf_route: m0->m_len < sizeof(struct ip)\n"));
d5107 2
a5108 2
				DPFPRINTF(PF_DEBUG_URGENT,
				    ("pf_route: pf_map_addr() failed.\n"));
d5133 2
a5134 2
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf_route: m0->m_len < sizeof(struct ip)\n"));
d5267 2
a5268 2
		DPFPRINTF(PF_DEBUG_URGENT,
		    ("pf_route6: m0->m_len < sizeof(struct ip6_hdr)\n"));
d5290 2
a5291 2
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf_route6: pf_map_addr() failed.\n"));
d5313 2
a5314 2
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf_route6: m0->m_len < sizeof(struct ip6_hdr)\n"));
d5473 1
a5473 1
	u_short			 action, reason = 0, log = 0;
d5493 2
a5494 2
		DPFPRINTF(PF_DEBUG_URGENT,
		    ("pf_test: kif == NULL, if_xname %s\n", ifp->if_xname));
d5508 1
a5508 1
		log |= PF_LOG_FORCE;
d5532 1
a5532 1
		log |= PF_LOG_FORCE;
d5567 1
a5567 1
				log |= PF_LOG_FORCE;
d5586 1
a5586 1
			log |= s->log;
d5607 1
a5607 1
				log |= PF_LOG_FORCE;
d5626 1
a5626 1
			log |= s->log;
d5640 1
a5640 1
				log |= PF_LOG_FORCE;
d5651 1
a5651 1
			log |= s->log;
d5660 2
a5661 2
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping IPv4 packet with ICMPv6 payload\n"));
d5673 1
a5673 1
			log |= s->log;
d5685 3
a5687 3
		log |= PF_LOG_FORCE;
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping packet with ip options\n"));
d5748 1
a5748 1
	if (log) {
d5751 1
a5751 1
		if (log & PF_LOG_FORCE || r->log & PF_LOG_ALL)
d5834 1
a5834 1
	u_short			 action, reason = 0, log = 0;
d5853 2
a5854 2
		DPFPRINTF(PF_DEBUG_URGENT,
		    ("pf_test6: kif == NULL, if_xname %s\n", ifp->if_xname));
d5868 1
a5868 1
		log |= PF_LOG_FORCE;
d5894 1
a5894 1
		log |= PF_LOG_FORCE;
d5926 2
a5927 2
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: IPv6 more than one rthdr\n"));
d5930 1
a5930 1
				log |= PF_LOG_FORCE;
d5935 2
a5936 2
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: IPv6 short rthdr\n"));
d5939 1
a5939 1
				log |= PF_LOG_FORCE;
d5943 2
a5944 2
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: IPv6 rthdr0\n"));
d5947 1
a5947 1
				log |= PF_LOG_FORCE;
d5960 2
a5961 2
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: IPv6 short opt\n"));
d5963 1
a5963 1
				log |= PF_LOG_FORCE;
d5993 1
a5993 1
				log |= PF_LOG_FORCE;
d6010 1
a6010 1
			log |= s->log;
d6031 1
a6031 1
				log |= PF_LOG_FORCE;
d6050 1
a6050 1
			log |= s->log;
d6059 2
a6060 2
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping IPv6 packet with ICMPv4 payload\n"));
d6076 1
a6076 1
				log |= PF_LOG_FORCE;
d6094 1
a6094 1
				log |= PF_LOG_FORCE;
d6105 1
a6105 1
			log |= s->log;
d6120 1
a6120 1
			log |= s->log;
d6138 3
a6140 3
		log |= PF_LOG_FORCE;;
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping packet with dangerous v6 headers\n"));
d6191 1
a6191 1
	if (log) {
d6194 1
a6194 1
		if (log & PF_LOG_FORCE || r->log & PF_LOG_ALL)
@


1.687
log
@When printing states in debug output, print the rule number that created
it if we have it.

Requested by dlg, ok henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.686 2010/01/14 01:06:14 henning Exp $ */
d791 1
a791 1
	if (&s->key[idx] == NULL)
@


1.686
log
@i forgot to remove a now obsolete comment in pf_create_state about
incorrect error handling
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.685 2010/01/14 00:00:05 henning Exp $ */
d1434 2
@


1.685
log
@in pf_create_state, when we fixed the leaks, we were a bit too trigger
happy and went to use after free instead. ryan and I think we found the
reason - just freeing that state keys in the error path is wrong as well,
since pf_state_key_setup could have found existing, identical state keys
and linked our state to these. if we now free them the other state that
hung of these state keys would point back to the freed state keys. so
instead of manually trying to free the state keys just call
pf_state_key_detach which has all the magic checks.
with and ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.684 2010/01/13 23:45:14 henning Exp $ */
a3167 1
	/* XXX on error all these should goto csfailed after extra cleanup */
@


1.684
log
@in pf_state_key_detach, ensure that the state key pointer on the state
is not null, to be safe and to be able to call this with half setup
states. with and ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.683 2010/01/12 03:20:51 mcbride Exp $ */
d3193 3
a3195 4
		if (*skw != *sks)
			pool_put(&pf_state_key_pl, *skw);
		pool_put(&pf_state_key_pl, *sks);
		*skw = *sks = NULL;
@


1.683
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.682 2010/01/11 04:07:07 henning Exp $ */
d790 3
@


1.682
log
@"final" leak in state creation: in pf_state_key_setup, if we actually
need two state keys (NAT case), and we succeed allocating the first one
but fail getting the second we'd leak the first one. obvious and thus ok'd
by dlg ryan and theo within seconds
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.681 2010/01/11 03:52:03 henning Exp $ */
a107 1
struct pf_palist	 pf_pabuf[3];
a114 1
u_int32_t		 ticket_pabuf;
d128 1
a128 1
struct pool		 pf_src_tree_pl, pf_rule_pl, pf_pooladdr_pl;
d1522 1
d2658 1
a2658 1
		s->rt_kif = r->route.cur->kif;
d2665 1
a2665 1
		s->rt_kif = r->route.cur->kif;
a5096 5
		if (TAILQ_EMPTY(&r->route.list)) {
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf_route: TAILQ_EMPTY(&r->route.list)\n"));
			goto bad;
		}
d5098 7
a5104 2
			pf_map_addr(AF_INET, r, (struct pf_addr *)&ip->ip_src,
			    &naddr, NULL, &sn, &r->route, PF_SN_ROUTE);
d5107 2
a5108 2
			ifp = r->route.cur->kif ?
			    r->route.cur->kif->pfik_ifp : NULL;
d5119 1
a5279 5
	if (TAILQ_EMPTY(&r->route.list)) {
		DPFPRINTF(PF_DEBUG_URGENT,
		    ("pf_route6: TAILQ_EMPTY(&r->route.list)\n"));
		goto bad;
	}
d5281 6
a5286 2
		pf_map_addr(AF_INET6, r, (struct pf_addr *)&ip6->ip6_src,
		    &naddr, NULL, &sn, &r->route, PF_SN_ROUTE);
d5290 1
a5290 1
		ifp = r->route.cur->kif ? r->route.cur->kif->pfik_ifp : NULL;
@


1.681
log
@fix a bug in pf_create_state that was a major source of amusement for me
over the last couple of weeks (ever since I found it): when we are out of
memory for the state keys we leak the state. oh the irony.
instead of just fixing that one case rework the error handling in the entire
function. verified painfully by yours truly by forcefully exercising each
and every error path in there. ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.680 2009/12/24 04:24:19 dlg Exp $ */
d852 2
a853 1
		if ((sk2 = pf_alloc_state_key(PR_NOWAIT | PR_ZERO)) == NULL)
d855 1
a855 1

@


1.680
log
@add support to pf for filtering a packet by the interface it was received
on. use the received-on IFNAME filter option on a pf.conf rule to restrict
which packet the interface had to be received on. eg:

  pass out on em0 from $foo to $bar received-on fxp0

ive been running this in production for a week now. i find it particularly
usefull with interface groups.

no objections, and a few "i like"s from henning, claudio, deraadt, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.679 2009/12/14 12:31:45 henning Exp $ */
d831 1
d853 1
a853 1
			return (ENOMEM); /* caller must handle cleanup */
a881 1

a1038 1

d3170 1
a3170 4
			pf_src_tree_remove_state(s);
			STATE_DEC_COUNTERS(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
d3177 2
a3178 6
			    ("pf_normalize_tcp_stateful failed on first pkt"));
			pf_normalize_tcp_cleanup(s);
			pf_src_tree_remove_state(s);
			STATE_DEC_COUNTERS(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
d3184 4
a3187 2
	    act->rtableid))
		goto csfailed;	/* XXX leaks */
d3190 4
a3193 2
		if (pd->proto == IPPROTO_TCP)
			pf_normalize_tcp_cleanup(s);
d3195 1
a3195 4
		pf_src_tree_remove_state(s);
		STATE_DEC_COUNTERS(s);
		pool_put(&pf_state_pl, s);
		return (PF_DROP);
a3241 10
	/* skw/sks checks obsolete */
	if (*skw != NULL) {
		pool_put(&pf_state_key_pl, *skw);
		*skw = NULL;
	}
	if (*sks != NULL) {
		pool_put(&pf_state_key_pl, *sks);
		*sks = NULL;
	}

d3245 6
@


1.679
log
@fix sticky-address - by pretty much re-implementing it. still following
the original approach using a source tracking node.
the reimplementation i smore flexible than the original one, we now have an
slist of source tracking nodes per state. that is cheap because more than
one entry will be an absolute exception.
ok beck and jsg, also stress tested by Sebastian Benoit <benoit-lists at fb12.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.678 2009/12/08 08:26:33 sthen Exp $ */
d236 1
d2264 24
d2870 2
@


1.678
log
@move "pf: key search" and "pf: key setup" messages to PF_DEBUG_NOISY
instead of MISC. "makes a little bit more sense" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.677 2009/11/26 14:34:49 dlg Exp $ */
d132 1
a132 1
struct pool		 pf_altq_pl, pf_rule_item_pl;
d178 1
a178 1
			    struct pf_rule_actions *);
d319 2
d409 5
a413 1
	int bad = 0;
d415 1
a415 1
	(*state)->src_node->conn++;
d417 1
a417 1
	pf_add_threshold(&(*state)->src_node->conn_rate);
d420 1
a420 2
	    (*state)->rule.ptr->max_src_conn <
	    (*state)->src_node->conn) {
d426 1
a426 1
	    pf_check_threshold(&(*state)->src_node->conn_rate)) {
d441 1
a441 1
			pf_print_host(&(*state)->src_node->addr, 0,
d451 1
a451 1
			p.pfra_ip4addr = (*state)->src_node->addr.v4;
d457 1
a457 1
			p.pfra_ip6addr = (*state)->src_node->addr.v6;
d481 1
a481 2
				    PF_AEQ(&(*state)->src_node->addr,
					&sk->addr[0], sk->af)) ||
d483 1
a483 2
				    PF_AEQ(&(*state)->src_node->addr,
					&sk->addr[1], sk->af))) &&
d508 2
a509 1
    struct pf_addr *src, sa_family_t af)
d515 1
d517 3
a519 3
		if (rule->rule_flag & PFRULE_RULESRCTRACK ||
		    rule->nat.opts & PF_POOL_STICKYADDR ||
		    rule->rdr.opts & PF_POOL_STICKYADDR)
a520 2
		else
			k.rule.ptr = NULL;
d537 1
d539 3
a541 3
		if (rule->rule_flag & PFRULE_RULESRCTRACK ||
		    rule->nat.opts & PF_POOL_STICKYADDR ||
		    rule->rdr.opts & PF_POOL_STICKYADDR)
a542 2
		else
			(*sn)->rule.ptr = NULL;
d544 2
a556 1
		(*sn)->ruletype = rule->action;
d571 48
d1117 1
a1117 10
			if (cur->rule.ptr != NULL) {
				cur->rule.ptr->src_nodes--;
				if (cur->rule.ptr->states_cur <= 0 &&
				    cur->rule.ptr->max_src_nodes <= 0)
					pf_rm_rule(NULL, cur->rule.ptr);
			}
			RB_REMOVE(pf_src_tree, &tree_src_tracking, cur);
			pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
			pf_status.src_nodes--;
			pool_put(&pf_src_tree_pl, cur);
d1128 2
a1129 1
	u_int32_t timeout;
d1131 2
a1132 1
	if (s->src_node != NULL) {
d1134 2
a1135 2
			--s->src_node->conn;
		if (--s->src_node->states <= 0) {
d1140 1
a1140 1
			s->src_node->expire = time_second + timeout;
d1142 1
a1143 1
	s->src_node = NULL;
d2633 1
a2633 1
		    &r->route);
d2640 1
a2640 1
		    &r->route);
d2709 1
d2727 1
d2868 1
a2868 1
					    &daddr, &dport);
d2894 2
a2895 1
		pf_get_transaddr(lastr, pd, &saddr, &sport, &daddr, &dport);
d2903 1
d2973 8
d2983 1
a2983 1
		    bproto_sum, bip_sum, hdrlen, &rules, &act);
d3042 2
a3043 1
    struct pf_rule_slist *rules, struct pf_rule_actions *act)
a3045 1
	struct pf_src_node	*sn = NULL;
d3049 1
d3057 1
a3057 8
	/* src node for filter rule */
	if ((r->rule_flag & PFRULE_SRCTRACK ||
	    r->rdr.opts & PF_POOL_STICKYADDR ||
	    r->nat.opts & PF_POOL_STICKYADDR) &&
	    pf_insert_src_node(&sn, r, pd->src, pd->af) != 0) {
		REASON_SET(&reason, PFRES_SRCLIMIT);
		goto csfailed;
	}
d3139 1
a3139 4
	if (sn != NULL) {
		s->src_node = sn;
		s->src_node->states++;
	}
d3166 1
a3166 1
		goto csfailed;
d3179 18
d3222 1
d3232 4
a3235 6
	if (sn != NULL && sn->states == 0 && sn->expire == 0) {
		RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
		pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
		pf_status.src_nodes--;
		pool_put(&pf_src_tree_pl, sn);
	}
d3600 1
a3600 1
				    (*state)->src_node != NULL &&
d3756 1
a3756 1
			    (*state)->src_node != NULL &&
d3772 1
a3772 1
			if ((*state)->src_node != NULL &&
d3871 1
a3871 1
		} else if ((*state)->src_node != NULL &&
d5088 1
a5088 1
			    &naddr, NULL, &sn, &r->route);
d5270 1
a5270 1
		    &naddr, NULL, &sn, &r->route);
d5752 1
d5754 3
a5756 3
			if (s->src_node != NULL) {
				s->src_node->packets[dirndx]++;
				s->src_node->bytes[dirndx] += pd.tot_len;
d6194 5
a6198 3
			if (s->src_node != NULL) {
				s->src_node->packets[dirndx]++;
				s->src_node->bytes[dirndx] += pd.tot_len;
@


1.677
log
@magical fix for a fault which reliably brings my firewalls down. i think
not having sks and sks set to NULL causes random memory to be pool_put().

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.676 2009/11/23 18:41:21 henning Exp $ */
d820 1
a820 1
	if (pf_status.debug >= PF_DEBUG_MISC) {
d923 1
a923 1
	if (pf_status.debug >= PF_DEBUG_MISC) {
@


1.676
log
@with the old code we initialized the state keys early in some cases
and thus had to get rid of them if we didn't create state. this is no
longer the case, kill dead code. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.675 2009/11/23 18:10:43 henning Exp $ */
d2666 1
a2666 1
	struct pf_state_key	*skw, *sks;
@


1.675
log
@one kinda-missing log |= PFLOG_FORCE in the v6 case, spotted by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.674 2009/11/23 18:04:10 henning Exp $ */
d2666 1
a2666 1
	struct pf_state_key	*skw = NULL, *sks = NULL;
a2944 4
		if (sks != NULL)
			pool_put(&pf_state_key_pl, sks);
		if (skw != NULL)
			pool_put(&pf_state_key_pl, skw);
a2971 4
	if (sks != NULL)
		pool_put(&pf_state_key_pl, sks);
	if (skw != NULL)
		pool_put(&pf_state_key_pl, skw);
@


1.674
log
@sync the handling of the log flag from pf_test (where it is correct)
to pf_test6 (where it is wrong in some edge cases, for match rules and
logs a packet twice in some cases). ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.673 2009/11/23 17:22:11 henning Exp $ */
d5814 1
@


1.673
log
@pf_test_fragment: we need to bail out if action == PF_DROP, not
if action != PF_PASS. same was changed in pf_test_rule a while back
but the fragment case was forgotten. since everybody reassembles nobody
ran into this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.672 2009/11/23 17:18:05 henning Exp $ */
d5788 1
a5788 1
		log = 1;
d5849 1
a5849 1
				log = 1;
d5858 1
a5858 1
				log = 1;
d5866 1
a5866 1
				log = 1;
d5882 1
a5882 1
				log = 1;
d5911 2
a5912 1
			log = action != PF_PASS;
d5929 1
a5929 1
			log = s->log;
d5949 2
a5950 1
			log = action != PF_PASS;
d5969 1
a5969 1
			log = s->log;
d5994 2
a5995 1
			log = action != PF_PASS;
d6012 2
a6013 1
			log = action != PF_PASS;
d6024 1
a6024 1
			log = s->log;
d6039 1
a6039 1
			log = s->log;
d6057 1
a6057 1
		log = 1;
d6110 13
a6122 3
	if (log)
		PFLOG_PACKET(kif, h, m, AF_INET6, dir, reason, r, a, ruleset,
		    &pd);
@


1.672
log
@sync some comments with reality
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.671 2009/11/23 16:03:10 henning Exp $ */
d3345 1
a3345 1
	if (r->action != PF_PASS)	/* XXX wrong */
@


1.671
log
@remove the nat_rule pointer on pf_state and pf_pdesc, obsolete after
the NAT rewrite and ever since then only checked in a couple of plaes
but never set. same for nat_src_node on pf_state.
with this the NAT rewrite made pf over 1000 lines shorter.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.670 2009/11/22 22:34:50 henning Exp $ */
d663 1
a663 2
	KASSERT(s->key[idx] == NULL);	/* XXX handle this? */

a1108 1
		/* XXX wire key the right one? */
d3035 1
a3035 1
	s->rtableid[pd->sidx] = -1;	/* return traffic is routed normaly */
d3345 1
a3345 1
	if (r->action != PF_PASS)
@


1.670
log
@cleanup after the NAT changes. we used to have multiple rulesets (scrub,
NAT, filter). now we only have one. no need for an array any more. simplifies
the code quite a bit.
in the process fix the abuse of PF_RULESET_* by (surprise, isn't it) the
table code.
written at the filesystem hackathon in stockholm, committed from the
hardware hackathon in portugal. ok gcc and jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.669 2009/11/21 20:54:27 henning Exp $ */
a277 4
		if (s->nat_rule.ptr != NULL) {			\
			s->nat_rule.ptr->states_cur++;		\
			s->nat_rule.ptr->states_tot++;		\
		}						\
a286 2
		if (s->nat_rule.ptr != NULL)			\
			s->nat_rule.ptr->states_cur--;		\
d1100 1
a1100 10
	if (s->nat_src_node != s->src_node && s->nat_src_node != NULL) {
		if (--s->nat_src_node->states <= 0) {
			timeout = s->rule.ptr->timeout[PFTM_SRC_NODE];
			if (!timeout)
				timeout =
				    pf_default_rule.timeout[PFTM_SRC_NODE];
			s->nat_src_node->expire = time_second + timeout;
		}
	}
	s->src_node = s->nat_src_node = NULL;
a1149 4
	if (cur->nat_rule.ptr != NULL)
		if (--cur->nat_rule.ptr->states_cur <= 0 &&
			cur->nat_rule.ptr->src_nodes <= 0)
			pf_rm_rule(NULL, cur->nat_rule.ptr);
d5399 1
a5399 1
	struct pf_rule		*a = NULL, *r = &pf_default_rule, *tr, *nr;
a5671 1
		struct pf_rule		*lr;
d5674 2
a5675 7
		if (s != NULL && s->nat_rule.ptr != NULL &&
		    s->nat_rule.ptr->log & PF_LOG_ALL)
			lr = s->nat_rule.ptr;
		else
			lr = r;
		if (log & PF_LOG_FORCE || lr->log & PF_LOG_ALL)
			PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, lr, a,
a5698 4
			if (s->nat_rule.ptr != NULL) {
				s->nat_rule.ptr->packets[dirndx]++;
				s->nat_rule.ptr->bytes[dirndx] += pd.tot_len;
			}
a5702 4
			if (s->nat_src_node != NULL) {
				s->nat_src_node->packets[dirndx]++;
				s->nat_src_node->bytes[dirndx] += pd.tot_len;
			}
d5711 2
a5712 6
		tr = r;
		nr = (s != NULL) ? s->nat_rule.ptr : pd.nat_rule;
		if (nr != NULL && r == &pf_default_rule)
			tr = nr;
		if (tr->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->src.addr.p.tbl,
d5717 3
a5719 3
			    r->action == PF_PASS, tr->src.neg);
		if (tr->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->dst.addr.p.tbl,
d5724 1
a5724 1
			    r->action == PF_PASS, tr->dst.neg);
d5759 1
a5759 1
	struct pf_rule		*a = NULL, *r = &pf_default_rule, *tr, *nr;
d6108 2
a6109 9
	if (log) {
		struct pf_rule *lr;

		if (s != NULL && s->nat_rule.ptr != NULL &&
		    s->nat_rule.ptr->log & PF_LOG_ALL)
			lr = s->nat_rule.ptr;
		else
			lr = r;
		PFLOG_PACKET(kif, h, m, AF_INET6, dir, reason, lr, a, ruleset,
a6110 1
	}
a6123 4
			if (s->nat_rule.ptr != NULL) {
				s->nat_rule.ptr->packets[dirndx]++;
				s->nat_rule.ptr->bytes[dirndx] += pd.tot_len;
			}
a6127 4
			if (s->nat_src_node != NULL) {
				s->nat_src_node->packets[dirndx]++;
				s->nat_src_node->bytes[dirndx] += pd.tot_len;
			}
d6132 2
a6133 6
		tr = r;
		nr = (s != NULL) ? s->nat_rule.ptr : pd.nat_rule;
		if (nr != NULL && r == &pf_default_rule)
			tr = nr;
		if (tr->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->src.addr.p.tbl,
d6137 3
a6139 3
			    r->action == PF_PASS, tr->src.neg);
		if (tr->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->dst.addr.p.tbl,
d6143 1
a6143 1
			    r->action == PF_PASS, tr->dst.neg);
@


1.669
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.668 2009/11/05 20:50:14 michele Exp $ */
d2254 1
a2254 1
pf_step_into_anchor(int *depth, struct pf_ruleset **rs, int n,
d2285 1
a2285 1
	*r = TAILQ_FIRST((*rs)->rules[n].active.ptr);
d2289 1
a2289 1
pf_step_out_of_anchor(int *depth, struct pf_ruleset **rs, int n,
d2308 1
a2308 1
				*r = TAILQ_FIRST((*rs)->rules[n].active.ptr);
d2766 1
a2766 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2856 1
a2856 1
				    PF_RULESET_FILTER, &r, &a, &match);
d2859 1
a2859 1
		    PF_RULESET_FILTER, &r, &a, &match))
d3303 1
a3303 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d3350 1
a3350 1
				    PF_RULESET_FILTER, &r, &a, &match);
d3353 1
a3353 1
		    PF_RULESET_FILTER, &r, &a, &match))
@


1.668
log
@IPv6 support for divert sockets.

tested by phessler@@ pyr@@
ok claudio@@
"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.667 2009/11/03 10:59:04 claudio Exp $ */
d179 1
a179 1
void			pf_translate(struct pf_pdesc *, struct pf_addr *,
d190 1
a190 1
int			pf_tcp_track_sloppy(struct pf_state_peer *,
@


1.667
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.666 2009/10/29 10:28:27 jsg Exp $ */
d94 1
d5834 3
d6136 9
d6207 5
@


1.666
log
@I missed updating a line for the AF_INET6 route case when
splitting things out into a seperate pool.
Problem noticed and fix tested by sthen@@

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.665 2009/10/28 20:11:01 jsg Exp $ */
d157 2
a158 2
			    u_int16_t, u_short, struct ether_header *,
			    struct ifnet *, int);
d160 1
a160 1
			    sa_family_t, struct pf_rule *, int);
d640 3
d783 1
a783 1
	u_int16_t *sport, u_int16_t *dport)
d786 1
d797 3
d803 2
a804 1
	    *sport != pd->osport || *dport != pd->odport) {	/* NAT */
d814 1
d900 1
a900 1
	    a->port[1] == b->port[0])
a1120 4
	/*
	 * XXX XXX XXX state needs to know routing domain so that states
	 * XXX XXX XXX can not float between domain. May simplify other code.
	 */
d1131 2
a1132 2
		    TH_RST|TH_ACK, 0, 0, 0, 1, cur->tag, 0, NULL, NULL,
		    cur->rtableid);
d1376 1
a1376 1
		printf(" wire: ");
d1382 1
a1382 1
		printf(" stack: ");
d1908 1
a1908 2
    u_int16_t rtag, u_short rdom, struct ether_header *eh, struct ifnet *ifp,
    int rtableid)
a1947 3
	if (rtableid >= 0)
		m->m_pkthdr.pf.rtableid = rtableid;

d2060 1
a2060 1
    struct pf_rule *r, int rtableid)
a2067 1
	m0->m_pkthdr.rdomain = m->m_pkthdr.rdomain;
d2069 1
a2069 2
	if (rtableid >= 0)
		m0->m_pkthdr.pf.rtableid = rtableid;
d2247 1
a2247 1
		m->m_pkthdr.pf.rtableid = rtableid;
d2429 4
d2434 1
a2434 1
		    /* XXX */ 0);
d2437 1
a2437 1
			    NULL, 0);
d2919 2
a2920 2
				    r->return_ttl, 1, 0, m->m_pkthdr.rdomain,
				    pd->eh, kif->pfik_ifp, act.rtableid);
d2925 1
a2925 1
			    r->return_icmp & 255, af, r, act.rtableid);
d2929 1
a2929 1
			    r->return_icmp6 & 255, af, r, act.rtableid);
d2939 3
d3054 2
a3055 1
	s->rtableid = act->rtableid;
d3145 2
a3146 1
	if (pf_state_key_setup(pd, skw, sks, &saddr, &daddr, &sport, &dport))
d3176 2
a3177 1
		    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, 0, /* XXX */ 0, NULL, NULL, act->rtableid);
d3674 1
a3674 2
				    m->m_pkthdr.rdomain, pd->eh,
				    kif->pfik_ifp, (*state)->rtableid);
d3788 1
d3827 1
a3827 1
			    0, /* XXX */ 0, NULL, NULL, (*state)->rtableid);
d3857 2
a3858 2
			    (*state)->src.mss, 0, 0, (*state)->tag, /* XXX */ 0,
			    NULL, NULL, (*state)->rtableid);
d3873 1
a3873 2
			    (*state)->tag, /* XXX */ 0, NULL, NULL,
			    (*state)->rtableid);
d3879 1
a3879 1
			    0, /* XXX */ 0, NULL, NULL, (*state)->rtableid);
d3931 2
a3932 1
		if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], pd->af))
d3939 1
d3960 1
d4006 2
a4007 1
		if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], pd->af))
d4014 1
d4029 1
d4132 4
d4210 1
d4324 1
d4396 5
d4452 1
d4475 5
d4554 5
d4624 5
d4649 1
d4669 5
d4717 1
d4759 1
d4789 4
d5490 1
d5633 1
a5633 1
		pf_tag_packet(m, s->tag, s->rtableid);
d5640 1
d6098 2
a6099 2
	if (s && (s->tag || s->rtableid))
		pf_tag_packet(m, s ? s->tag : 0, s->rtableid);
@


1.665
log
@Add a dedicated pf pool for route options as suggested by henning,
which unbreaks ie route-to after the recent pf changes.

With much help debugging and pointing out of missing bits from claudio@@

ok claudio@@ "looks good" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.664 2009/10/06 21:21:48 claudio Exp $ */
d2613 1
a2613 1
		    &r->rdr);
@


1.664
log
@Redo the route lookup in the output (and IPv6 forwarding) path if the
destination of a packet was changed by pf. This allows for some evil
games with rdr-to or nat-to but is mostly needed for better rdomain/rtable
support. This is a first step and more work and cleanup is needed.

Here a list of what works and what does not (needs a patched pfctl):
pass out rdr-to:
from local rdr-to local addr works (if state tracking on lo0 is done)
from remote rdr-to local addr does NOT work
from local rdr-to remote works
from remote rdr-to remote works

pass in nat-to:
from remote nat-to local addr does NOT work
from remote nat-to non-local addr works
non-local is an IP that is routed to the FW but is not assigned on the FW.
The non working cases need some magic to correctly rewrite the incomming
packet since the rewriting would happen outbound which is too late.

"time to get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.663 2009/10/04 16:08:37 michele Exp $ */
d107 1
a107 1
struct pf_palist	 pf_pabuf[2];
d2605 3
a2607 2
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL, &sn, &r->rdr);
		s->rt_kif = r->rdr.cur->kif;
d2614 1
a2614 1
		s->rt_kif = r->rdr.cur->kif;
d4992 1
a4992 1
		if (TAILQ_EMPTY(&r->rdr.list)) {
d4994 1
a4994 1
			    ("pf_route: TAILQ_EMPTY(&r->rdr.list)\n"));
d4999 1
a4999 1
			    &naddr, NULL, &sn, &r->rdr);
d5002 2
a5003 2
			ifp = r->rdr.cur->kif ?
			    r->rdr.cur->kif->pfik_ifp : NULL;
d5174 1
a5174 1
	if (TAILQ_EMPTY(&r->rdr.list)) {
d5176 1
a5176 1
		    ("pf_route6: TAILQ_EMPTY(&r->rdr.list)\n"));
d5181 1
a5181 1
		    &naddr, NULL, &sn, &r->rdr);
d5185 1
a5185 1
		ifp = r->rdr.cur->kif ? r->rdr.cur->kif->pfik_ifp : NULL;
@


1.663
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.662 2009/09/16 12:28:19 henning Exp $ */
d3198 3
d3922 2
d3994 2
d4127 1
a4127 1
				    AF_INET))
d4131 2
d4157 1
a4157 1
				    &nk->addr[pd->didx], AF_INET6))
d4161 2
d4718 1
a4718 1
			if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], AF_INET))
d4723 2
d4731 2
a4732 1
			if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], AF_INET6))
d4734 2
d5607 1
a5607 4
	if (dir == PF_IN && action == PF_PASS && (pd.proto == IPPROTO_TCP ||
	    pd.proto == IPPROTO_UDP) && s != NULL && s->nat_rule.ptr != NULL &&
	    (s->nat_rule.ptr->action == PF_RDR ||
	    s->nat_rule.ptr->action == PF_BINAT) &&
d5610 3
d6059 1
a6059 4
	if (dir == PF_IN && action == PF_PASS && (pd.proto == IPPROTO_TCP ||
	    pd.proto == IPPROTO_UDP) && s != NULL && s->nat_rule.ptr != NULL &&
	    (s->nat_rule.ptr->action == PF_RDR ||
	    s->nat_rule.ptr->action == PF_BINAT) &&
d6062 3
@


1.662
log
@style: in pf_test_state_other, fix indentation, kill excessive newlines,
add break in the last case block
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.661 2009/09/16 12:26:55 henning Exp $ */
d78 1
d5386 3
d5608 9
d5695 5
@


1.661
log
@fix copy & paste error from almost a year ago (bad ryan)
PF_ANEQ call in pf_test_state_other in the IPVshit case used AF_INET, found
by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.660 2009/09/08 17:52:17 michele Exp $ */
a4705 2


d4711 1
a4711 2

				break;
a4716 1

d4719 1
@


1.660
log
@I had not enough oks to commit this diff.
Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.658 2009/09/01 13:42:00 henning Exp $ */
d4718 1
a4718 1
			if (PF_ANEQ(pd->src, &nk->addr[pd->sidx], AF_INET))
d4721 1
a4721 1
			if (PF_ANEQ(pd->dst, &nk->addr[pd->didx], AF_INET))
@


1.659
log
@Add support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 8000

test, bugfix and ok by reyk@@
manpage help and ok by jmc@@
no objections from many others.
@
text
@a77 1
#include <netinet/ip_divert.h>
a5387 3
	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED_PACKET)
		return (PF_PASS);

a5606 9
	if (action == PF_PASS && r->divert_packet.port) {
		struct pf_divert *divert;

		if ((divert = pf_get_divert(m)))
			divert->port = r->divert_packet.port;

		action = PF_DIVERT;
	}

a5684 5
		*m0 = NULL;
		action = PF_PASS;
		break;
	case PF_DIVERT:
		divert_packet(m, dir);
@


1.658
log
@the diff theo calls me insanae for:
rewrite of the NAT code, basically. nat and rdr become actions on regular
rules, seperate nat/rdr/binat rules do not exist any more.
match in on $intf rdr-to 1.2.3.4
match out on $intf nat-to 5.6.7.8
the code is capable of doing nat and rdr in any direction, but we prevent
this in pfctl for now, there are implications that need to be documented
better.
the address rewrite happens inline, subsequent rules will see the already
changed addresses. nat / rdr can be applied multiple times as well.
match in on $intf rdr-to 1.2.3.4
match in on $intf to 1.2.3.4 rdr-to 5.6.7.8
help and ok dlg sthen claudio, reyk tested too
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.657 2009/07/28 11:22:33 henning Exp $ */
d78 1
d5389 3
d5611 9
d5698 5
@


1.657
log
@do not leak pf_rule_item_pl items in pf_test_rule() when
1) at least one match rule matched the packet and
2) we do not create state
found by me while fixing the pool_get problem, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.655 2009/06/26 19:39:49 markus Exp $ */
d106 1
a106 1
struct pf_palist	 pf_pabuf;
d170 4
a173 5
			    struct pf_rule *, struct pf_pdesc *,
			    struct pf_src_node *, struct pf_state_key *,
			    struct pf_state_key *, struct pf_state_key *,
			    struct pf_state_key *, struct mbuf *, int,
			    u_int16_t, u_int16_t, int *, struct pfi_kif *,
d177 3
d517 2
a518 1
		    rule->rpool.opts & PF_POOL_STICKYADDR)
d540 2
a541 1
		    rule->rpool.opts & PF_POOL_STICKYADDR)
d776 1
a776 1
pf_state_key_setup(struct pf_pdesc *pd, struct pf_rule *nr,
d778 2
a779 3
	struct pf_state_key **skp, struct pf_state_key **nkp,
	struct pf_addr *saddr, struct pf_addr *daddr,
	u_int16_t sport, u_int16_t dport)
d781 1
a781 1
	KASSERT((*skp == NULL && *nkp == NULL));
d783 1
a783 1
	if ((*skp = pf_alloc_state_key(PR_NOWAIT | PR_ZERO)) == NULL)
d786 11
a796 9
	PF_ACPY(&(*skp)->addr[pd->sidx], saddr, pd->af);
	PF_ACPY(&(*skp)->addr[pd->didx], daddr, pd->af);
	(*skp)->port[pd->sidx] = sport;
	(*skp)->port[pd->didx] = dport;
	(*skp)->proto = pd->proto;
	(*skp)->af = pd->af;

	if (nr != NULL) {
		if ((*nkp = pf_alloc_state_key(PR_NOWAIT | PR_ZERO)) == NULL)
d799 6
a804 7
		/* XXX maybe just bcopy and TAILQ_INIT(&(*nkp)->states) */
		PF_ACPY(&(*nkp)->addr[0], &(*skp)->addr[0], pd->af);
		PF_ACPY(&(*nkp)->addr[1], &(*skp)->addr[1], pd->af);
		(*nkp)->port[0] = (*skp)->port[0];
		(*nkp)->port[1] = (*skp)->port[1];
		(*nkp)->proto = pd->proto;
		(*nkp)->af = pd->af;
d806 1
a806 1
		*nkp = *skp;
d809 2
a810 2
		*skw = *skp;
		*sks = *nkp;
d812 8
a819 2
		*sks = *skp;
		*skw = *nkp;
d821 1
a832 1

d919 5
d1587 12
a1598 11
	*c = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
	    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
	    pf_cksum_fixup(pf_cksum_fixup(*c,
	    ao.addr16[0], an->addr16[0], u),
	    ao.addr16[1], an->addr16[1], u),
	    ao.addr16[2], an->addr16[2], u),
	    ao.addr16[3], an->addr16[3], u),
	    ao.addr16[4], an->addr16[4], u),
	    ao.addr16[5], an->addr16[5], u),
	    ao.addr16[6], an->addr16[6], u),
	    ao.addr16[7], an->addr16[7], u);
d1613 1
d1734 1
a1734 1
		*icmptype = htons(type);
d2604 2
a2605 2
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL, &sn);
		s->rt_kif = r->rpool.cur->kif;
d2610 3
a2612 2
		pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL, &sn);
		s->rt_kif = r->rpool.cur->kif;
d2673 2
a2674 2
	struct pf_rule		*nr = NULL, *lastr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
a2679 1
	struct pf_src_node	*nsn = NULL;
a2681 1
	struct pf_state_key	*sk = NULL, *nk = NULL;
d2693 3
d2720 1
a2720 1
		hdrlen = sizeof(*pd->hdr.icmp);
d2757 3
a2760 136

	/* check packet for BINAT/NAT/RDR */
	if ((nr = pf_get_translation(pd, m, off, direction, kif, &nsn,
	    &skw, &sks, &sk, &nk, saddr, daddr, sport, dport)) != NULL) {
		if (nk == NULL || sk == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
			goto cleanup;
		}

		if (pd->ip_sum)
			bip_sum = *pd->ip_sum;

		switch (pd->proto) {
		case IPPROTO_TCP:
			bproto_sum = th->th_sum;
			pd->proto_sum = &th->th_sum;

			if (PF_ANEQ(saddr, &nk->addr[pd->sidx], af) ||
			    nk->port[pd->sidx] != sport) {
				pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
				    &th->th_sum, &nk->addr[pd->sidx],
				    nk->port[pd->sidx], 0, af);
				pd->sport = &th->th_sport;
				sport = th->th_sport;
			}

			if (PF_ANEQ(daddr, &nk->addr[pd->didx], af) ||
			    nk->port[pd->didx] != dport) {
				pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
				    &th->th_sum, &nk->addr[pd->didx],
				    nk->port[pd->didx], 0, af);
				dport = th->th_dport;
				pd->dport = &th->th_dport;
			}
			rewrite++;
			break;
		case IPPROTO_UDP:
			bproto_sum = pd->hdr.udp->uh_sum;
			pd->proto_sum = &pd->hdr.udp->uh_sum;

			if (PF_ANEQ(saddr, &nk->addr[pd->sidx], af) ||
			    nk->port[pd->sidx] != sport) {
				pf_change_ap(saddr, &pd->hdr.udp->uh_sport,
				    pd->ip_sum, &pd->hdr.udp->uh_sum,
				    &nk->addr[pd->sidx],
				    nk->port[pd->sidx], 1, af);
				sport = pd->hdr.udp->uh_sport;
				pd->sport = &pd->hdr.udp->uh_sport;
			}

			if (PF_ANEQ(daddr, &nk->addr[pd->didx], af) ||
			    nk->port[pd->didx] != dport) {
				pf_change_ap(daddr, &pd->hdr.udp->uh_dport,
				    pd->ip_sum, &pd->hdr.udp->uh_sum,
				    &nk->addr[pd->didx],
				    nk->port[pd->didx], 1, af);
				dport = pd->hdr.udp->uh_dport;
				pd->dport = &pd->hdr.udp->uh_dport;
			}
			rewrite++;
			break;
#ifdef INET
		case IPPROTO_ICMP:
			if (af != AF_INET)
				break;

			if (PF_ANEQ(saddr, &nk->addr[pd->sidx], AF_INET))
				pf_change_a(&saddr->v4.s_addr, pd->ip_sum,
				    nk->addr[pd->sidx].v4.s_addr, 0);

			if (PF_ANEQ(daddr, &nk->addr[pd->didx], AF_INET))
				pf_change_a(&daddr->v4.s_addr, pd->ip_sum,
				    nk->addr[pd->didx].v4.s_addr, 0);

			if (virtual_type == ICMP_ECHO &&
			     nk->port[pd->sidx] != pd->hdr.icmp->icmp_id) {
				pd->hdr.icmp->icmp_cksum = pf_cksum_fixup(
				    pd->hdr.icmp->icmp_cksum, sport,
				    nk->port[pd->sidx], 0);
				pd->hdr.icmp->icmp_id = nk->port[pd->sidx];
				pd->sport = &pd->hdr.icmp->icmp_id;
			}
			m_copyback(m, off, ICMP_MINLEN, pd->hdr.icmp);
			break;
#endif /* INET */
#ifdef INET6
		case IPPROTO_ICMPV6:
			if (af != AF_INET6)
				break;

			if (PF_ANEQ(saddr, &nk->addr[pd->sidx], AF_INET6))
				pf_change_a6(saddr, &pd->hdr.icmp6->icmp6_cksum,
				    &nk->addr[pd->sidx], 0);

			if (PF_ANEQ(daddr, &nk->addr[pd->didx], AF_INET6))
				pf_change_a6(daddr, &pd->hdr.icmp6->icmp6_cksum,
				    &nk->addr[pd->didx], 0);
			rewrite++;
			break;
#endif /* INET */
		default:
			switch (af) {
#ifdef INET
			case AF_INET:
				if (PF_ANEQ(saddr,
				    &nk->addr[pd->sidx], AF_INET))
					pf_change_a(&saddr->v4.s_addr,
					    pd->ip_sum,
					    nk->addr[pd->sidx].v4.s_addr, 0);

				if (PF_ANEQ(daddr,
				    &nk->addr[pd->didx], AF_INET))
					pf_change_a(&daddr->v4.s_addr,
					    pd->ip_sum,
					    nk->addr[pd->didx].v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				if (PF_ANEQ(saddr,
				    &nk->addr[pd->sidx], AF_INET6))
					PF_ACPY(saddr, &nk->addr[pd->sidx], af);

				if (PF_ANEQ(daddr,
				    &nk->addr[pd->didx], AF_INET6))
					PF_ACPY(saddr, &nk->addr[pd->didx], af);
				break;
#endif /* INET */
			}
			break;
		}
		if (nr->natpass)
			r = NULL;
		pd->nat_rule = nr;
	}

d2771 1
a2771 1
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af,
d2778 1
a2778 1
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af,
d2836 2
d2861 1
a2861 1
	if (lastr && lastr->action != PF_MATCH)
d2863 2
d2868 1
a2868 1
	if (act.log || (nr != NULL && nr->log)) {
a2870 2
		if (rewrite)
			m_copyback(m, off, hdrlen, pd->hdr.any);
d2873 1
a2873 1
			    r->log ? r : nr, a, ruleset, pd);
a2883 14
		/* undo NAT changes, if they have taken place */
		if (nr != NULL) {
			PF_ACPY(saddr, &sk->addr[pd->sidx], af);
			PF_ACPY(daddr, &sk->addr[pd->didx], af);
			if (pd->sport)
				*pd->sport = sk->port[pd->sidx];
			if (pd->dport)
				*pd->dport = sk->port[pd->didx];
			if (pd->proto_sum)
				*pd->proto_sum = bproto_sum;
			if (pd->ip_sum)
				*pd->ip_sum = bip_sum;
			m_copyback(m, off, hdrlen, pd->hdr.any);
		}
d2935 1
a2935 1
	if (!state_icmp && (r->keep_state || nr != NULL)) {
d2937 4
a2940 3
		action = pf_create_state(r, nr, a, pd, nsn, skw, sks, nk, sk, m,
		    off, sport, dport, &rewrite, kif, sm, tag, bproto_sum,
		    bip_sum, hdrlen, &rules, &act);
d2943 13
d2957 4
a2960 4
		if (sk != NULL)
			pool_put(&pf_state_key_pl, sk);
		if (nk != NULL)
			pool_put(&pf_state_key_pl, nk);
d2988 4
a2991 4
	if (sk != NULL)
		pool_put(&pf_state_key_pl, sk);
	if (nk != NULL)
		pool_put(&pf_state_key_pl, nk);
d3001 6
a3006 7
pf_create_state(struct pf_rule *r, struct pf_rule *nr, struct pf_rule *a,
    struct pf_pdesc *pd, struct pf_src_node *nsn, struct pf_state_key *skw,
    struct pf_state_key *sks, struct pf_state_key *nk, struct pf_state_key *sk,
    struct mbuf *m, int off, u_int16_t sport, u_int16_t dport, int *rewrite,
    struct pfi_kif *kif, struct pf_state **sm, int tag, u_int16_t bproto_sum,
    u_int16_t bip_sum, int hdrlen, struct pf_rule_slist *rules,
    struct pf_rule_actions *act)
d3022 2
a3023 1
	    r->rpool.opts & PF_POOL_STICKYADDR) &&
a3027 6
	/* src node for translation rule */
	if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
	    pf_insert_src_node(&nsn, nr, &sk->addr[pd->sidx], pd->af)) {
		REASON_SET(&reason, PFRES_SRCLIMIT);
		goto csfailed;
	}
a3033 1
	s->nat_rule.ptr = nr;
a3051 2
	if (nr != NULL)
		s->log |= nr->log & PF_LOG_ALL;
a3111 6
	if (nsn != NULL) {
		/* XXX We only modify one side for now. */
		PF_ACPY(&nsn->raddr, &nk->addr[1], pd->af);
		s->nat_src_node = nsn;
		s->nat_src_node->states++;
	}
d3136 1
a3136 2
	if (sk == NULL && pf_state_key_setup(pd, nr, &skw, &sks, &sk, &nk,
	    pd->src, pd->dst, sport, dport))
d3139 1
a3139 1
	if (pf_state_insert(BOUND_IFACE(r, kif), skw, sks, s)) {
a3157 17
		/* undo NAT changes, if they have taken place */
		if (nr != NULL) {
			struct pf_state_key *skt = s->key[PF_SK_WIRE];
			if (pd->dir == PF_OUT)
				skt = s->key[PF_SK_STACK];
			PF_ACPY(pd->src, &skt->addr[pd->sidx], pd->af);
			PF_ACPY(pd->dst, &skt->addr[pd->didx], pd->af);
			if (pd->sport)
				*pd->sport = skt->port[pd->sidx];
			if (pd->dport)
				*pd->dport = skt->port[pd->didx];
			if (pd->proto_sum)
				*pd->proto_sum = bproto_sum;
			if (pd->ip_sum)
				*pd->ip_sum = bip_sum;
			m_copyback(m, off, hdrlen, pd->hdr.any);
		}
d3174 8
a3181 4
	if (sk != NULL)
		pool_put(&pf_state_key_pl, sk);
	if (nk != NULL)
		pool_put(&pf_state_key_pl, nk);
d3189 83
a3271 5
	if (nsn != sn && nsn != NULL && nsn->states == 0 && nsn->expire == 0) {
		RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
		pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
		pf_status.src_nodes--;
		pool_put(&pf_src_tree_pl, nsn);
a3272 1
	return (PF_DROP);
d4039 1
a4039 1
	if ((*state)->rule.ptr->type && 
d4080 1
a4080 1
	
d4128 2
a4129 1
					    pd->hdr.icmp->icmp_cksum, icmpid,
d4977 1
a4977 1
		if (TAILQ_EMPTY(&r->rpool.list)) {
d4979 1
a4979 1
			    ("pf_route: TAILQ_EMPTY(&r->rpool.list)\n"));
d4984 1
a4984 1
			    &naddr, NULL, &sn);
d4987 2
a4988 2
			ifp = r->rpool.cur->kif ?
			    r->rpool.cur->kif->pfik_ifp : NULL;
d5159 1
a5159 1
	if (TAILQ_EMPTY(&r->rpool.list)) {
d5161 1
a5161 1
		    ("pf_route6: TAILQ_EMPTY(&r->rpool.list)\n"));
d5166 1
a5166 1
		    &naddr, NULL, &sn);
d5170 1
a5170 1
		ifp = r->rpool.cur->kif ? r->rpool.cur->kif->pfik_ifp : NULL;
d5442 2
d5486 2
d5863 2
d5906 2
@


1.656
log
@check that pool_get actually gives us memory in pf_test_rule.
introduced by yours truly (no idea how that could happpen), problem
found by sthen the hard way, fix by me. ok dlg
@
text
@d3073 4
d3104 4
@


1.655
log
@invert direction for inner icmp state lookups (e.g. traceroute with icmp)
ok henning, jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.654 2009/06/22 17:04:02 jsing Exp $ */
d2679 1
a2874 1
	SLIST_INIT(&rules);
d2940 6
a2945 2
					ri = pool_get(&pf_rule_item_pl,
					    PR_NOWAIT);
d3100 1
@


1.655.4.1
log
@MFC, ok deraadt
----------------------------
revision 1.656
date: 2009/07/28 11:20:09;  author: henning;  state: Exp;  lines: +9 -4
check that pool_get actually gives us memory in pf_test_rule.
introduced by yours truly (no idea how that could happpen), problem
found by sthen the hard way, fix by me. ok dlg
----------------------------
revision 1.657
date: 2009/07/28 11:22:33;  author: henning;  state: Exp;  lines: +8 -0
do not leak pf_rule_item_pl items in pf_test_rule() when
1) at least one match rule matched the packet and
2) we do not create state
found by me while fixing the pool_get problem, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.657 2009/07/28 11:22:33 henning Exp $ */
a2678 1
	SLIST_INIT(&rules);
d2874 1
d2940 2
a2941 6
					if ((ri = pool_get(&pf_rule_item_pl,
					    PR_NOWAIT)) == NULL) {
						REASON_SET(&reason,
						    PFRES_MEMORY);
						goto cleanup;
					}
a3068 4
		while ((ri = SLIST_FIRST(&rules))) {
			SLIST_REMOVE_HEAD(&rules, entry);
			pool_put(&pf_rule_item_pl, ri);
		}
a3095 5
	while ((ri = SLIST_FIRST(&rules))) {
		SLIST_REMOVE_HEAD(&rules, entry);
		pool_put(&pf_rule_item_pl, ri);
	}

@


1.654
log
@Check that the address family is appropriate before processing ICMPv4 and
ICMPv6 messages.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.653 2009/06/22 16:55:14 jsing Exp $ */
d198 1
a198 1
			    int, int *, int);
d4053 2
a4054 1
    u_int16_t icmpid, u_int16_t type, int icmp_dir, int *iidx, int multi)
d4091 2
a4092 1
	    (((*state)->direction == direction) ?
d4140 1
a4140 1
		    PF_ICMP_MULTI_NONE);
d4146 1
a4146 1
				    icmp_dir, &iidx, multi);
d4537 1
a4537 1
			    icmp_dir, &iidx, PF_ICMP_MULTI_NONE);
d4592 1
a4592 1
			    icmp_dir, &iidx, PF_ICMP_MULTI_NONE);
d4599 1
a4599 1
					    icmp_dir, &iidx, multi);
@


1.653
log
@Always drop ICMPv6 in IPv4 datagrams, not only when compiled with INET6.

Suggested by Max Laier.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.652 2009/06/22 13:55:39 jsing Exp $ */
d2801 3
d2825 3
@


1.652
log
@Fix scrub max-mss for IPv6 traffic.

spotted by naddy@@

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.650 2009/06/08 02:36:06 sthen Exp $ */
a5564 1
#ifdef INET6
a5570 1
#endif
@


1.651
log
@in pf_print_state_parts, do not use skw->proto to print the protocol
but our local copy proto that we very carefully set beforehands. skw
being NULL is perfectly valid there.
@
text
@d5918 7
@


1.650
log
@"do not call PF_ANEQ with af=0, dragons". fixes a problem with skip
steps found with the recent pfvar.h commit to check address families.
from & commit req by henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.649 2009/06/05 00:05:21 claudio Exp $ */
d1343 1
a1343 1
		printf("%u", skw->proto);
@


1.649
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.648 2009/05/18 20:37:13 bluhm Exp $ */
d1471 1
a1471 1
		if (PF_ANEQ(&aw1->v.a.addr, &aw2->v.a.addr, 0))
d1473 1
a1473 1
		if (PF_ANEQ(&aw1->v.a.mask, &aw2->v.a.mask, 0))
@


1.648
log
@The routing table index rtableid has type unsigned int in the routing
code.  In pf rtableid == -1 means don't change the rtableid because
of this rule.  So it has to be signed int there.  Before the value
is passed from pf to route it is always checked to be >= 0.  Change
the type to int in pf and to u_int in netinet and netinet6 to make
the checks work.  Otherwise -1 may be used as an array index and
the kernel crashes.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.647 2009/04/30 12:54:32 henning Exp $ */
d156 2
a157 2
			    u_int16_t, struct ether_header *, struct ifnet *,
			    int);
d1096 4
d1110 1
a1110 1
		    TH_RST|TH_ACK, 0, 0, 0, 1, cur->tag, NULL, NULL,
d1885 2
a1886 1
    u_int16_t rtag, struct ether_header *eh, struct ifnet *ifp, int rtableid)
d1924 1
d2049 1
d2412 2
a2413 1
		inp = in_pcbhashlookup(tb, saddr->v4, sport, daddr->v4, dport);
d2416 1
a2416 1
			    NULL);
d2537 1
d3030 2
a3031 2
				    r->return_ttl, 1, 0, pd->eh, kif->pfik_ifp,
				    act.rtableid);
d3292 1
a3292 2
		    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, 0, NULL, NULL,
		    act->rtableid);
d3705 2
a3706 1
				    pd->eh, kif->pfik_ifp, (*state)->rtableid);
d3858 1
a3858 1
			    0, NULL, NULL, (*state)->rtableid);
d3888 2
a3889 2
			    (*state)->src.mss, 0, 0, (*state)->tag, NULL, NULL,
			    (*state)->rtableid);
d3904 2
a3905 1
			    (*state)->tag, NULL, NULL, (*state)->rtableid);
d3911 1
a3911 1
			    0, NULL, NULL, (*state)->rtableid);
d4840 1
d4922 1
@


1.647
log
@treat log as what it is, a flag variable. effectively a noop now but stops
us relying on where we are setting it. ok ryan dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.644 2009/04/15 13:10:38 henning Exp $ */
d157 1
a157 1
			    u_int);
d159 1
a159 1
			    sa_family_t, struct pf_rule *, u_int);
d1881 1
a1881 1
    u_int16_t rtag, struct ether_header *eh, struct ifnet *ifp, u_int rtableid)
d2035 1
a2035 1
    struct pf_rule *r, u_int rtableid)
@


1.646
log
@print the type of the icmp message we're bitching about when debugging is
turned up in pf_icmp_state_lookup.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.645 2009/04/17 18:37:06 henning Exp $ */
d5411 1
a5411 1
		log = PF_LOG_FORCE;
d5432 1
a5432 1
		log = PF_LOG_FORCE;
d5466 1
a5466 1
				log = PF_LOG_FORCE;
d5483 1
a5483 1
			log = s->log;
d5504 1
a5504 1
				log = PF_LOG_FORCE;
d5521 1
a5521 1
			log = s->log;
d5535 1
a5535 1
				log = PF_LOG_FORCE;
d5546 1
a5546 1
			log = s->log;
d5570 1
a5570 1
			log = s->log;
d5582 1
a5582 1
		log = PF_LOG_FORCE;
d5644 1
a5644 1
		if (log == PF_LOG_FORCE || lr->log & PF_LOG_ALL)
@


1.645
log
@move the lastr = r assignment behind the anchor rule check so we don't
ever try to aplly options from the anchor rule if it was the last matching
one but the last matching real rule. it is right but despite begging nobody
has the balls to ok it ;(
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.644 2009/04/15 13:10:38 henning Exp $ */
d4078 1
a4078 1
			    icmp_dir);
@


1.644
log
@little dose of scrubbing after the monster changes:
correctly inherit queue stuff, tag, rtableid from the rule if we have no
state
some logic simplification and removal of redundant checks
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.643 2009/04/15 05:14:45 david Exp $ */
a2919 1
			lastr = r;
d2923 1
@


1.643
log
@move OK ICMP to NOISY level, makes it easier to run at MISC level; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.642 2009/04/14 19:39:56 grange Exp $ */
d5384 1
d5587 1
a5587 1
	if (s)
d5589 6
a5594 1
	else
d5596 6
a5601 3

	if (s && (s->tag || s->rtableid))
		pf_tag_packet(m, s ? s->tag : 0, s->rtableid);
d5607 3
a5609 7
	if (action == PF_PASS && s && s->qid) {
		if (pqid || (pd.tos & IPTOS_LOWDELAY))
			m->m_pkthdr.pf.qid = s->pqid;
		else
			m->m_pkthdr.pf.qid = s->qid;
		/* add hints for ecn */
		m->m_pkthdr.pf.hdr = h;
@


1.642
log
@Correctly handle the case when state might be NULL in pf_test like
all other code do. Should fix pr 6121.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.641 2009/04/11 23:42:05 jsing Exp $ */
d4368 1
a4368 1
				if (pf_status.debug >= PF_DEBUG_MISC) {
@


1.641
log
@Avoid dereferencing a null pointer when pf attempts to translate a
specifically crafted IP datagram.

Problem noted by Sebastian Rother.

ok henning@@ mcbride@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.639 2009/03/15 19:40:41 miod Exp $ */
d5642 6
a5647 4
		SLIST_FOREACH(ri, &s->match_rules, entry)
			if (ri->r->log & PF_LOG_ALL)
				PFLOG_PACKET(kif, h, m, AF_INET, dir, reason,
				    ri->r, a, ruleset, &pd);
@


1.640
log
@1) scrub rules are completely gone.
2) packet reassembly: only one method remains, full reassembly. crop
and drop-ovl are gone.
.  set reassemble yes|no [no-df]
if no-df is given fragments (and only fragments!) with the df bit set
have it cleared before entering the fragment cache, and thus the
reassembled packet doesn't have df set either. it does NOT touch
non-fragmented packets.
3) regular rules can have scrub options.
.  pass scrub(no-df, min-ttl 64, max-mss 1400, set-tos lowdelay)
.  match scrub(reassemble tcp, random-id)
of course all options are optional. the individual options still do
what they used to do on scrub rules, but everything is stateful now.
4) match rules
"match" is a new action, just like pass and block are, and can be used
like they do. opposed to pass or block, they do NOT change the
pass/block state of a packet. i. e.
.  pass
.  match
passes the packet, and
.  block
.  match
blocks it.
Every time (!) a match rule matches, i. e. not only when it is the
last matching rule, the following actions are set:
-queue assignment. can be overwritten later, the last rule that set a
queue wins. note how this is different from the last matching rule
wins, if the last matching rule has no queue assignments and the
second last matching rule was a match rule with queue assignments,
these assignments are taken.
-rtable assignments. works the same as queue assignments.
-set-tos, min-ttl, max-mss, no-df, random-id, reassemble tcp, all work
like the above
-logging. every matching rule causes the packet to be logged. this
 means a single packet can get logged more than once (think multiple log
 interfaces with different receivers, like pflogd and spamlogd)
.
almost entirely hacked at n2k9 in basel, could not be committed close to
release. this really should have been multiple diffs, but splitting them
now is not feasible any more. input from mcbride and dlg, and frantzen
about the fragment handling.
speedup around 7% for the common case, the more the more scrub rules
were in use.
manpage not up to date, being worked on.
@
text
@d5552 9
d5930 7
@


1.639
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.638 2009/03/14 23:44:09 mcbride Exp $ */
d130 1
a130 1
struct pool		 pf_altq_pl;
d156 2
a157 1
			    u_int16_t, struct ether_header *, struct ifnet *);
d159 1
a159 1
			    sa_family_t, struct pf_rule *);
d163 2
d176 2
a177 1
			    int);
d265 17
a281 12
#define STATE_INC_COUNTERS(s)				\
	do {						\
		s->rule.ptr->states_cur++;		\
		s->rule.ptr->states_tot++;		\
		if (s->anchor.ptr != NULL) {		\
			s->anchor.ptr->states_cur++;	\
			s->anchor.ptr->states_tot++;	\
		}					\
		if (s->nat_rule.ptr != NULL) {		\
			s->nat_rule.ptr->states_cur++;	\
			s->nat_rule.ptr->states_tot++;	\
		}					\
d284 10
a293 7
#define STATE_DEC_COUNTERS(s)				\
	do {						\
		if (s->nat_rule.ptr != NULL)		\
			s->nat_rule.ptr->states_cur--;	\
		if (s->anchor.ptr != NULL)		\
			s->anchor.ptr->states_cur--;	\
		s->rule.ptr->states_cur--;		\
d1106 2
a1107 1
		    TH_RST|TH_ACK, 0, 0, 0, 1, cur->tag, NULL, NULL);
d1127 2
d1146 7
d1881 1
a1881 1
    u_int16_t rtag, struct ether_header *eh, struct ifnet *ifp)
d1920 2
a1921 2
	if (r != NULL && r->rtableid >= 0)
		m->m_pkthdr.pf.rtableid = r->rtableid;
d2035 1
a2035 1
    struct pf_rule *r)
d2044 2
a2045 2
	if (r->rtableid >= 0)
		m0->m_pkthdr.pf.rtableid = r->rtableid;
d2620 20
d2646 1
a2646 1
	struct pf_rule		*nr = NULL;
d2651 2
d2657 1
d2660 1
a2660 1
	int			 tag = -1, rtableid = -1;
d2668 2
d2859 1
d2920 1
a2922 2
			if (r->rtableid >= 0)
				rtableid = r->rtableid;
d2924 14
a2937 4
				match = 1;
				*rm = r;
				*am = a;
				*rsm = ruleset;
d2953 4
d2959 3
a2961 1
	if (r->log || (nr != NULL && nr->log)) {
d2964 7
a2970 2
		PFLOG_PACKET(kif, h, m, af, direction, reason, r->log ? r : nr,
		    a, ruleset, pd);
d3021 2
a3022 1
				    r->return_ttl, 1, 0, pd->eh, kif->pfik_ifp);
d3027 1
a3027 1
			    r->return_icmp & 255, af, r);
d3031 1
a3031 1
			    r->return_icmp6 & 255, af, r);
d3037 1
a3037 1
	if (pf_tag_packet(m, tag, rtableid)) {
d3042 1
a3042 2
	if (!state_icmp && (r->keep_state || nr != NULL ||
	    (pd->flags & PFDESC_TCP_NORM))) {
d3046 1
a3046 1
		    bip_sum, hdrlen);
d3090 2
a3091 1
    u_int16_t bip_sum, int hdrlen)
d3126 1
d3134 8
a3141 1
	s->log = r->log & PF_LOG_ALL;
d3212 2
a3213 2
		if ((pd->flags & PFDESC_TCP_NORM) && pf_normalize_tcp_init(m,
		    off, pd, th, &s->src, &s->dst)) {
d3220 1
a3220 1
		if ((pd->flags & PFDESC_TCP_NORM) && s->src.scrub &&
d3283 2
a3284 1
		    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, 0, NULL, NULL);
d3426 1
a3426 1
		if ((pd->flags & PFDESC_TCP_NORM || dst->scrub) &&
d3697 1
a3697 1
				    pd->eh, kif->pfik_ifp);
d3849 1
a3849 1
			    0, NULL, NULL);
d3879 2
a3880 1
			    (*state)->src.mss, 0, 0, (*state)->tag, NULL, NULL);
d3895 1
a3895 1
			    (*state)->tag, NULL, NULL);
d3901 1
a3901 1
			    0, NULL, NULL);
d5410 1
a5410 1
		log = 1;
d5417 4
a5420 2
	/* We do IP header normalization and packet reassembly here */
	if (pf_normalize_ip(m0, dir, kif, &reason, &pd) != PF_PASS) {
d5431 1
a5431 1
		log = 1;
d5464 2
a5465 1
			log = action != PF_PASS;
d5486 7
d5502 2
a5503 1
			log = action != PF_PASS;
d5533 2
a5534 1
			log = action != PF_PASS;
d5572 1
a5572 1
		log = 1;
d5577 7
a5583 2
	if ((s && s->tag) || r->rtableid)
		pf_tag_packet(m, s ? s->tag : 0, r->rtableid);
d5589 1
a5589 1
	if (action == PF_PASS && r->qid) {
d5591 1
a5591 1
			m->m_pkthdr.pf.qid = r->pqid;
d5593 1
a5593 1
			m->m_pkthdr.pf.qid = r->qid;
d5622 2
a5623 1
		struct pf_rule *lr;
d5630 7
a5636 2
		PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, lr, a, ruleset,
		    &pd);
d5651 2
d5668 4
d5758 1
a5758 1
	/* We do IP header normalization and packet reassembly here */
d6000 7
a6006 2
	if ((s && s->tag) || r->rtableid)
		pf_tag_packet(m, s ? s->tag : 0, r->rtableid);
d6012 1
a6012 1
	if (action == PF_PASS && r->qid) {
d6014 1
a6014 1
			m->m_pkthdr.pf.qid = r->pqid;
d6016 1
a6016 1
			m->m_pkthdr.pf.qid = r->qid;
@


1.638
log
@Some ICMP types that also have icmp_id, pointed out by markus@@

ok henning markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.637 2009/03/09 13:53:09 mcbride Exp $ */
d807 1
a807 1
	splassert(IPL_SOFTNET);
d1084 1
a1084 1
	splassert(IPL_SOFTNET);
d1114 1
a1114 1
	splassert(IPL_SOFTNET);
@


1.637
log
@Make the DIOCSETIFFLAG, DIOCSETLIMIT, and DIOCSETTIMEOUT ioctls
transactional, closing PRs 4941 and 5910.  Minor flag day, requires rebuild
of userland tools that use struct pfi_kif.

ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.636 2009/03/07 01:15:41 mcbride Exp $ */
d1584 1
a1584 1
		*icmpid = 0; /* Time is not a secret. */
d1591 1
a1591 1
		*icmpid = 0; /* Nothing sane to match on! */
d1598 1
a1598 1
		*icmpid = 0; /* Nothing sane to match on! */
@


1.636
log
@Make sure pd2 has a pointer to the icmp header in the payload; fixes
panic seen with some some icmp types in icmp error message payloads.

Reported by david@@ and insan.praja@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.635 2009/03/05 03:09:37 mcbride Exp $ */
d233 5
a237 5
	{ &pf_state_pl, PFSTATE_HIWAT },
	{ &pf_src_tree_pl, PFSNODE_HIWAT },
	{ &pf_frent_pl, PFFRAG_FRENT_HIWAT },
	{ &pfr_ktable_pl, PFR_KTABLE_HIWAT },
	{ &pfr_kentry_pl, PFR_KENTRY_HIWAT }
@


1.635
log
@Stricter state checking for ICMP and ICMPv6 packets: include the ICMP type
in one port of the state key, using the type to determine which side should
be the id, and which should be the type. Also:
- Handle ICMP6 messages which are typically sent to multicast addresses but
  recieve unicast replies, by doing fallthrough lookups against the correct
  multicast address.
- Clear up some mistaken assumptions in the PF code:
   - Not all ICMP packets have an icmp_id, so simulate one based on other
     data if we can, otherwise set it to 0.
   - Don't modify the icmp id field in NAT unless it's echo
   - Use the full range of possible id's when NATing icmp6 echoy

ok henning marco
testing matthieu todd
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.634 2009/02/27 12:37:45 henning Exp $ */
d4434 1
a4434 1
			icmpid = iih.icmp_id;
d4490 1
@


1.634
log
@fix quick reuse of tcp states.
when we, for a new state, hit an existing tcp state which is in FIN_WAIT_2
on both ends do not fail but insert the new state anyway and unlink the
old one afterwards. pimp error message a bit, too.
problem found with NAT by viq <viq@@viq.ath.cx>
ok theo markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.633 2009/02/16 00:31:25 dlg Exp $ */
d146 2
d191 4
d240 3
d1560 148
d2618 2
a2619 2
	int			 state_icmp = 0;
	u_int16_t		 sport, dport;
a2643 1
		sport = dport = pd->hdr.icmp->icmp_id;
d2647 9
a2655 7

		if (icmptype == ICMP_UNREACH ||
		    icmptype == ICMP_SOURCEQUENCH ||
		    icmptype == ICMP_REDIRECT ||
		    icmptype == ICMP_TIMXCEED ||
		    icmptype == ICMP_PARAMPROB)
			state_icmp++;
a2661 1
		sport = dport = pd->hdr.icmp6->icmp6_id;
d2665 9
a2673 6

		if (icmptype == ICMP6_DST_UNREACH ||
		    icmptype == ICMP6_PACKET_TOO_BIG ||
		    icmptype == ICMP6_TIME_EXCEEDED ||
		    icmptype == ICMP6_PARAM_PROB)
			state_icmp++;
a2744 1
			nk->port[0] = nk->port[1];
d2753 2
a2754 1
			if (nk->port[1] != pd->hdr.icmp->icmp_id) {
d2757 2
a2758 2
				    nk->port[1], 0);
				pd->hdr.icmp->icmp_id = nk->port[1];
a2765 1
			nk->port[0] = nk->port[1];
d3956 53
d4013 1
a4013 1
	u_int16_t	 icmpid, *icmpsum;
d4015 1
a4015 1
	int		 state_icmp = 0;
a4023 7

		if (icmptype == ICMP_UNREACH ||
		    icmptype == ICMP_SOURCEQUENCH ||
		    icmptype == ICMP_REDIRECT ||
		    icmptype == ICMP_TIMXCEED ||
		    icmptype == ICMP_PARAMPROB)
			state_icmp++;
a4030 6

		if (icmptype == ICMP6_DST_UNREACH ||
		    icmptype == ICMP6_PACKET_TOO_BIG ||
		    icmptype == ICMP6_TIME_EXCEEDED ||
		    icmptype == ICMP6_PARAM_PROB)
			state_icmp++;
d4034 3
a4036 3

	if (!state_icmp) {

d4041 13
a4053 9
		key.af = pd->af;
		key.proto = pd->proto;
		key.port[0] = key.port[1] = icmpid;
		if (direction == PF_IN)	{	/* wire side, straight */
			PF_ACPY(&key.addr[0], pd->src, key.af);
			PF_ACPY(&key.addr[1], pd->dst, key.af);
		} else {			/* stack side, reverse */
			PF_ACPY(&key.addr[1], pd->src, key.af);
			PF_ACPY(&key.addr[0], pd->dst, key.af);
a4055 2
		STATE_LOOKUP(kif, &key, direction, *state, m);

d4078 1
a4078 1
				if (nk->port[0] !=
d4083 2
a4084 3
					    nk->port[pd->sidx], 0);
					pd->hdr.icmp->icmp_id =
					    nk->port[pd->sidx];
d4434 9
a4442 7
			key.af = pd2.af;
			key.proto = IPPROTO_ICMP;
			PF_ACPY(&key.addr[pd2.sidx], pd2.src, key.af);
			PF_ACPY(&key.addr[pd2.didx], pd2.dst, key.af);
			key.port[0] = key.port[1] = iih.icmp_id;

			STATE_LOOKUP(kif, &key, direction, *state, m);
d4452 5
a4456 2
				    nk->port[pd2.sidx] != iih.icmp_id)
					pf_change_icmp(pd2.src, &iih.icmp_id,
d4458 2
a4459 1
					    nk->port[pd2.sidx], NULL,
d4464 3
a4466 6
				    &nk->addr[pd2.didx], pd2.af) ||
				    nk->port[pd2.didx] != iih.icmp_id)
					pf_change_icmp(pd2.dst, &iih.icmp_id,
					    NULL, /* XXX Inbound NAT? */
					    &nk->addr[pd2.didx],
					    nk->port[pd2.didx], NULL,
d4490 17
a4506 7
			key.af = pd2.af;
			key.proto = IPPROTO_ICMPV6;
			PF_ACPY(&key.addr[pd2.sidx], pd2.src, key.af);
			PF_ACPY(&key.addr[pd2.didx], pd2.dst, key.af);
			key.port[0] = key.port[1] = iih.icmp6_id;

			STATE_LOOKUP(kif, &key, direction, *state, m);
d4516 5
a4520 2
				    nk->port[pd2.sidx] != iih.icmp6_id)
					pf_change_icmp(pd2.src, &iih.icmp6_id,
d4522 2
a4523 1
					    nk->port[pd2.sidx], NULL,
d4528 3
a4530 6
				    &nk->addr[pd2.didx], pd2.af) ||
				    nk->port[pd2.didx] != iih.icmp6_id)
					pf_change_icmp(pd2.dst, &iih.icmp6_id,
					    NULL, /* XXX Inbound NAT? */
					    &nk->addr[pd2.didx],
					    nk->port[pd2.didx], NULL,
d5815 6
a5820 1
		struct icmp6_hdr	ih;
d5822 19
a5840 2
		pd.hdr.icmp6 = &ih;
		if (!pf_pull_hdr(m, off, &ih, sizeof(ih),
@


1.634.2.1
log
@Avoid dereferencing a null pointer when pf attempts to translate a
specifically crafted IP datagram.

Problem noted by Sebastian Rother.

fix from jsing. ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.634 2009/02/27 12:37:45 henning Exp $ */
a5245 9
#ifdef INET6
	case IPPROTO_ICMPV6: {
		action = PF_DROP;
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping IPv4 packet with ICMPv6 payload\n"));
		goto done;
	}
#endif

a5597 7
	}

	case IPPROTO_ICMP: {
		action = PF_DROP;
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping IPv6 packet with ICMPv4 payload\n"));
		goto done;
@


1.633
log
@pfsync v5, mostly written at n2k9, but based on work done at n2k8.

WARNING: THIS BREAKS COMPATIBILITY WITH THE PREVIOUS VERSION OF PFSYNC

this is a new variant of the protocol and a large reworking of the
pfsync code to address some performance issues. the single largest
benefit comes from having multiple pfsync messages of different
types handled in a single packet. pfsyncs handling of pf states is
highly optimised now, along with packet parsing and construction.

huggz for beck@@ for testing.
huge thanks to mcbride@@ for his help during development and for
finding all the bugs during the initial tests.
thanks to peter sutton for letting me get credit for this work.

ok beck@@ mcbride@@ "good." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.632 2009/01/30 17:27:20 naddy Exp $ */
d637 1
d646 29
a674 10
				if (pf_status.debug >= PF_DEBUG_MISC) {
					printf(
					    "pf: %s key attach failed on %s: ",
					    (idx == PF_SK_WIRE) ?
					    "wire" : "stack",
					    s->kif->pfik_name);
					pf_print_state_parts(s,
					    (idx == PF_SK_WIRE) ? sk : NULL,
					    (idx == PF_SK_STACK) ? sk : NULL);
					printf("\n");
a675 2
				pool_put(&pf_state_key_pl, sk);
				return (-1);	/* collision! */
d693 4
@


1.632
log
@sync the part copied from ip_output: always initialize IP checksum
to zero for checksum offload; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.631 2009/01/30 10:32:26 dlg Exp $ */
a803 2
			if (s->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
d1071 1
a1071 2
	if (cur->creatorid == pf_status.hostid)
		pfsync_delete_state(cur);
d1086 1
a1086 3
	if (pfsyncif != NULL &&
	    (pfsyncif->sc_bulk_send_next == cur ||
	    pfsyncif->sc_bulk_terminator == cur))
d2811 14
d2884 1
d5348 2
a5349 2

	if (action == PF_SYNPROXY_DROP) {
d5351 1
d5354 2
a5355 1
	} else if (r->rt)
d5357 4
a5360 1
		pf_route(m0, r, dir, kif->pfik_ifp, s, &pd);
d5725 2
a5726 2

	if (action == PF_SYNPROXY_DROP) {
d5728 1
d5731 2
a5732 1
	} else if (r->rt)
d5734 4
a5737 1
		pf_route6(m0, r, dir, kif->pfik_ifp, s, &pd);
@


1.631
log
@sprinkle splassert(IPL_SOFTNET) around the code that inserts, unlinks, and
frees pf states.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.630 2009/01/29 15:12:28 pyr Exp $ */
d4746 1
d4751 1
a4751 2
		} else {
			ip->ip_sum = 0;
a4752 1
		}
@


1.630
log
@Split the address selection from pools away from pf.c and put it in
pf_lb.c. This will ease the process of adding more selection types
without bloatening pf.c even more.

ok and a weird death threat, henning@@
raised eyebrow, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.629 2009/01/27 17:33:07 mpf Exp $ */
d776 2
d1055 2
d1086 2
@


1.629
log
@If a packet translation was a NOP, undo separate NAT key and
pretend there was no match. This prevents pf_state_insert()
to fail with duplicate keys. OK henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.628 2009/01/16 23:43:01 david Exp $ */
a131 2
void			 pf_print_host(struct pf_addr *, u_int16_t, u_int8_t);

a156 10
struct pf_rule		*pf_match_translation(struct pf_pdesc *, struct mbuf *,
			    int, int, struct pfi_kif *,
			    struct pf_addr *, u_int16_t, struct pf_addr *,
			    u_int16_t, int);
struct pf_rule		*pf_get_translation(struct pf_pdesc *, struct mbuf *,
			    int, int, struct pfi_kif *, struct pf_src_node **,
			    struct pf_state_key **, struct pf_state_key **,
			    struct pf_state_key **, struct pf_state_key **,
			    struct pf_addr *, struct pf_addr *,
			    u_int16_t, u_int16_t);
a157 5
int			 pf_state_key_setup(struct pf_pdesc *, struct pf_rule *,
			    struct pf_state_key **, struct pf_state_key **,
			    struct pf_state_key **, struct pf_state_key **,
			    struct pf_addr *, struct pf_addr *,
			    u_int16_t, u_int16_t);
a193 14
void			 pf_step_into_anchor(int *, struct pf_ruleset **, int,
			    struct pf_rule **, struct pf_rule **, int *);
int			 pf_step_out_of_anchor(int *, struct pf_ruleset **,
			     int, struct pf_rule **, struct pf_rule **,
			     int *);
void			 pf_hash(struct pf_addr *, struct pf_addr *,
			    struct pf_poolhashkey *, sa_family_t);
int			 pf_map_addr(u_int8_t, struct pf_rule *,
			    struct pf_addr *, struct pf_addr *,
			    struct pf_addr *, struct pf_src_node **);
int			 pf_get_sport(sa_family_t, u_int8_t, struct pf_rule *,
			    struct pf_addr *, struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t*, u_int16_t, u_int16_t,
			    struct pf_src_node **);
a2155 582

#define mix(a,b,c) \
	do {					\
		a -= b; a -= c; a ^= (c >> 13);	\
		b -= c; b -= a; b ^= (a << 8);	\
		c -= a; c -= b; c ^= (b >> 13);	\
		a -= b; a -= c; a ^= (c >> 12);	\
		b -= c; b -= a; b ^= (a << 16);	\
		c -= a; c -= b; c ^= (b >> 5);	\
		a -= b; a -= c; a ^= (c >> 3);	\
		b -= c; b -= a; b ^= (a << 10);	\
		c -= a; c -= b; c ^= (b >> 15);	\
	} while (0)

/*
 * hash function based on bridge_hash in if_bridge.c
 */
void
pf_hash(struct pf_addr *inaddr, struct pf_addr *hash,
    struct pf_poolhashkey *key, sa_family_t af)
{
	u_int32_t	a = 0x9e3779b9, b = 0x9e3779b9, c = key->key32[0];

	switch (af) {
#ifdef INET
	case AF_INET:
		a += inaddr->addr32[0];
		b += key->key32[1];
		mix(a, b, c);
		hash->addr32[0] = c + key->key32[2];
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		a += inaddr->addr32[0];
		b += inaddr->addr32[2];
		mix(a, b, c);
		hash->addr32[0] = c;
		a += inaddr->addr32[1];
		b += inaddr->addr32[3];
		c += key->key32[1];
		mix(a, b, c);
		hash->addr32[1] = c;
		a += inaddr->addr32[2];
		b += inaddr->addr32[1];
		c += key->key32[2];
		mix(a, b, c);
		hash->addr32[2] = c;
		a += inaddr->addr32[3];
		b += inaddr->addr32[0];
		c += key->key32[3];
		mix(a, b, c);
		hash->addr32[3] = c;
		break;
#endif /* INET6 */
	}
}

int
pf_map_addr(sa_family_t af, struct pf_rule *r, struct pf_addr *saddr,
    struct pf_addr *naddr, struct pf_addr *init_addr, struct pf_src_node **sn)
{
	unsigned char		 hash[16];
	struct pf_pool		*rpool = &r->rpool;
	struct pf_addr		*raddr = &rpool->cur->addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.v.a.mask;
	struct pf_pooladdr	*acur = rpool->cur;
	struct pf_src_node	 k;

	if (*sn == NULL && r->rpool.opts & PF_POOL_STICKYADDR &&
	    (r->rpool.opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		k.af = af;
		PF_ACPY(&k.addr, saddr, af);
		if (r->rule_flag & PFRULE_RULESRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR)
			k.rule.ptr = r;
		else
			k.rule.ptr = NULL;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		*sn = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
		if (*sn != NULL && !PF_AZERO(&(*sn)->raddr, af)) {
			PF_ACPY(naddr, &(*sn)->raddr, af);
			if (pf_status.debug >= PF_DEBUG_MISC) {
				printf("pf_map_addr: src tracking maps ");
				pf_print_host(&k.addr, 0, af);
				printf(" to ");
				pf_print_host(naddr, 0, af);
				printf("\n");
			}
			return (0);
		}
	}

	if (rpool->cur->addr.type == PF_ADDR_NOROUTE)
		return (1);
	if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
		switch (af) {
#ifdef INET
		case AF_INET:
			if (rpool->cur->addr.p.dyn->pfid_acnt4 < 1 &&
			    (rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN)
				return (1);
			 raddr = &rpool->cur->addr.p.dyn->pfid_addr4;
			 rmask = &rpool->cur->addr.p.dyn->pfid_mask4;
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			if (rpool->cur->addr.p.dyn->pfid_acnt6 < 1 &&
			    (rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN)
				return (1);
			raddr = &rpool->cur->addr.p.dyn->pfid_addr6;
			rmask = &rpool->cur->addr.p.dyn->pfid_mask6;
			break;
#endif /* INET6 */
		}
	} else if (rpool->cur->addr.type == PF_ADDR_TABLE) {
		if ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN)
			return (1); /* unsupported */
	} else {
		raddr = &rpool->cur->addr.v.a.addr;
		rmask = &rpool->cur->addr.v.a.mask;
	}

	switch (rpool->opts & PF_POOL_TYPEMASK) {
	case PF_POOL_NONE:
		PF_ACPY(naddr, raddr, af);
		break;
	case PF_POOL_BITMASK:
		PF_POOLMASK(naddr, raddr, rmask, saddr, af);
		break;
	case PF_POOL_RANDOM:
		if (init_addr != NULL && PF_AZERO(init_addr, af)) {
			switch (af) {
#ifdef INET
			case AF_INET:
				rpool->counter.addr32[0] = htonl(arc4random());
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				if (rmask->addr32[3] != 0xffffffff)
					rpool->counter.addr32[3] =
					    htonl(arc4random());
				else
					break;
				if (rmask->addr32[2] != 0xffffffff)
					rpool->counter.addr32[2] =
					    htonl(arc4random());
				else
					break;
				if (rmask->addr32[1] != 0xffffffff)
					rpool->counter.addr32[1] =
					    htonl(arc4random());
				else
					break;
				if (rmask->addr32[0] != 0xffffffff)
					rpool->counter.addr32[0] =
					    htonl(arc4random());
				break;
#endif /* INET6 */
			}
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af);
			PF_ACPY(init_addr, naddr, af);

		} else {
			PF_AINC(&rpool->counter, af);
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af);
		}
		break;
	case PF_POOL_SRCHASH:
		pf_hash(saddr, (struct pf_addr *)&hash, &rpool->key, af);
		PF_POOLMASK(naddr, raddr, rmask, (struct pf_addr *)&hash, af);
		break;
	case PF_POOL_ROUNDROBIN:
		if (rpool->cur->addr.type == PF_ADDR_TABLE) {
			if (!pfr_pool_get(rpool->cur->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af))
				goto get_addr;
		} else if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
			if (!pfr_pool_get(rpool->cur->addr.p.dyn->pfid_kt,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af))
				goto get_addr;
		} else if (pf_match_addr(0, raddr, rmask, &rpool->counter, af))
			goto get_addr;

	try_next:
		if ((rpool->cur = TAILQ_NEXT(rpool->cur, entries)) == NULL)
			rpool->cur = TAILQ_FIRST(&rpool->list);
		if (rpool->cur->addr.type == PF_ADDR_TABLE) {
			rpool->tblidx = -1;
			if (pfr_pool_get(rpool->cur->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af)) {
				/* table contains no address of type 'af' */
				if (rpool->cur != acur)
					goto try_next;
				return (1);
			}
		} else if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
			rpool->tblidx = -1;
			if (pfr_pool_get(rpool->cur->addr.p.dyn->pfid_kt,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af)) {
				/* table contains no address of type 'af' */
				if (rpool->cur != acur)
					goto try_next;
				return (1);
			}
		} else {
			raddr = &rpool->cur->addr.v.a.addr;
			rmask = &rpool->cur->addr.v.a.mask;
			PF_ACPY(&rpool->counter, raddr, af);
		}

	get_addr:
		PF_ACPY(naddr, &rpool->counter, af);
		if (init_addr != NULL && PF_AZERO(init_addr, af))
			PF_ACPY(init_addr, naddr, af);
		PF_AINC(&rpool->counter, af);
		break;
	}
	if (*sn != NULL)
		PF_ACPY(&(*sn)->raddr, naddr, af);

	if (pf_status.debug >= PF_DEBUG_MISC &&
	    (rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		printf("pf_map_addr: selected address ");
		pf_print_host(naddr, 0, af);
		printf("\n");
	}

	return (0);
}

int
pf_get_sport(sa_family_t af, u_int8_t proto, struct pf_rule *r,
    struct pf_addr *saddr, struct pf_addr *daddr, u_int16_t dport,
    struct pf_addr *naddr, u_int16_t *nport, u_int16_t low, u_int16_t high,
    struct pf_src_node **sn)
{
	struct pf_state_key_cmp	key;
	struct pf_addr		init_addr;
	u_int16_t		cut;

	bzero(&init_addr, sizeof(init_addr));
	if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn))
		return (1);

	if (proto == IPPROTO_ICMP) {
		low = 1;
		high = 65535;
	}

	do {
		key.af = af;
		key.proto = proto;
		PF_ACPY(&key.addr[1], daddr, key.af);
		PF_ACPY(&key.addr[0], naddr, key.af);
		key.port[1] = dport;

		/*
		 * port search; start random, step;
		 * similar 2 portloop in in_pcbbind
		 */
		if (!(proto == IPPROTO_TCP || proto == IPPROTO_UDP ||
		    proto == IPPROTO_ICMP)) {
			key.port[0] = dport;
			if (pf_find_state_all(&key, PF_IN, NULL) == NULL)
				return (0);
		} else if (low == 0 && high == 0) {
			key.port[0] = *nport;
			if (pf_find_state_all(&key, PF_IN, NULL) == NULL)
				return (0);
		} else if (low == high) {
			key.port[0] = htons(low);
			if (pf_find_state_all(&key, PF_IN, NULL) == NULL) {
				*nport = htons(low);
				return (0);
			}
		} else {
			u_int16_t tmp;

			if (low > high) {
				tmp = low;
				low = high;
				high = tmp;
			}
			/* low < high */
			cut = arc4random_uniform(1 + high - low) + low;
			/* low <= cut <= high */
			for (tmp = cut; tmp <= high; ++(tmp)) {
				key.port[0] = htons(tmp);
				if (pf_find_state_all(&key, PF_IN, NULL) ==
				    NULL && !in_baddynamic(tmp, proto)) {
					*nport = htons(tmp);
					return (0);
				}
			}
			for (tmp = cut - 1; tmp >= low; --(tmp)) {
				key.port[0] = htons(tmp);
				if (pf_find_state_all(&key, PF_IN, NULL) ==
				    NULL && !in_baddynamic(tmp, proto)) {
					*nport = htons(tmp);
					return (0);
				}
			}
		}

		switch (r->rpool.opts & PF_POOL_TYPEMASK) {
		case PF_POOL_RANDOM:
		case PF_POOL_ROUNDROBIN:
			if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn))
				return (1);
			break;
		case PF_POOL_NONE:
		case PF_POOL_SRCHASH:
		case PF_POOL_BITMASK:
		default:
			return (1);
		}
	} while (! PF_AEQ(&init_addr, naddr, af) );
	return (1);					/* none available */
}

struct pf_rule *
pf_match_translation(struct pf_pdesc *pd, struct mbuf *m, int off,
    int direction, struct pfi_kif *kif, struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport, int rs_num)
{
	struct pf_rule		*r, *rm = NULL;
	struct pf_ruleset	*ruleset = NULL;
	int			 tag = -1;
	int			 rtableid = -1;
	int			 asd = 0;

	r = TAILQ_FIRST(pf_main_ruleset.rules[rs_num].active.ptr);
	while (r && rm == NULL) {
		struct pf_rule_addr	*src = NULL, *dst = NULL;
		struct pf_addr_wrap	*xdst = NULL;

		if (r->action == PF_BINAT && direction == PF_IN) {
			src = &r->dst;
			if (r->rpool.cur != NULL)
				xdst = &r->rpool.cur->addr;
		} else {
			src = &r->src;
			dst = &r->dst;
		}

		r->evaluations++;
		if (pfi_kif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != pd->af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&src->addr, saddr, pd->af,
		    src->neg, kif))
			r = r->skip[src == &r->src ? PF_SKIP_SRC_ADDR :
			    PF_SKIP_DST_ADDR].ptr;
		else if (src->port_op && !pf_match_port(src->port_op,
		    src->port[0], src->port[1], sport))
			r = r->skip[src == &r->src ? PF_SKIP_SRC_PORT :
			    PF_SKIP_DST_PORT].ptr;
		else if (dst != NULL &&
		    PF_MISMATCHAW(&dst->addr, daddr, pd->af, dst->neg, NULL))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (xdst != NULL && PF_MISMATCHAW(xdst, daddr, pd->af,
		    0, NULL))
			r = TAILQ_NEXT(r, entries);
		else if (dst != NULL && dst->port_op &&
		    !pf_match_port(dst->port_op, dst->port[0],
		    dst->port[1], dport))
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else if (r->match_tag && !pf_match_tag(m, r, &tag))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY && (pd->proto !=
		    IPPROTO_TCP || !pf_osfp_match(pf_osfp_fingerprint(pd, m,
		    off, pd->hdr.tcp), r->os_fingerprint)))
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->rtableid >= 0)
				rtableid = r->rtableid;
			if (r->anchor == NULL) {
				rm = r;
			} else
				pf_step_into_anchor(&asd, &ruleset, rs_num,
				    &r, NULL, NULL);
		}
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset, rs_num, &r,
			    NULL, NULL);
	}
	if (pf_tag_packet(m, tag, rtableid))
		return (NULL);
	if (rm != NULL && (rm->action == PF_NONAT ||
	    rm->action == PF_NORDR || rm->action == PF_NOBINAT))
		return (NULL);
	return (rm);
}

struct pf_rule *
pf_get_translation(struct pf_pdesc *pd, struct mbuf *m, int off, int direction,
    struct pfi_kif *kif, struct pf_src_node **sn,
    struct pf_state_key **skw, struct pf_state_key **sks,
    struct pf_state_key **skp, struct pf_state_key **nkp,
    struct pf_addr *saddr, struct pf_addr *daddr,
    u_int16_t sport, u_int16_t dport)
{
	struct pf_rule	*r = NULL;


	if (direction == PF_OUT) {
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
		    sport, daddr, dport, PF_RULESET_BINAT);
		if (r == NULL)
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sport, daddr, dport, PF_RULESET_NAT);
	} else {
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
		    sport, daddr, dport, PF_RULESET_RDR);
		if (r == NULL)
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sport, daddr, dport, PF_RULESET_BINAT);
	}

	if (r != NULL) {
		struct pf_addr	*naddr;
		u_int16_t	*nport;

		if (pf_state_key_setup(pd, r, skw, sks, skp, nkp,
		    saddr, daddr, sport, dport))
			return r;

		/* XXX We only modify one side for now. */
		naddr = &(*nkp)->addr[1];
		nport = &(*nkp)->port[1];

		switch (r->action) {
		case PF_NONAT:
		case PF_NOBINAT:
		case PF_NORDR:
			return (NULL);
		case PF_NAT:
			if (pf_get_sport(pd->af, pd->proto, r, saddr,
			    daddr, dport, naddr, nport, r->rpool.proxy_port[0],
			    r->rpool.proxy_port[1], sn)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: NAT proxy port allocation "
				    "(%u-%u) failed\n",
				    r->rpool.proxy_port[0],
				    r->rpool.proxy_port[1]));
				return (NULL);
			}
			break;
		case PF_BINAT:
			switch (direction) {
			case PF_OUT:
				if (r->rpool.cur->addr.type == PF_ADDR_DYNIFTL){
					switch (pd->af) {
#ifdef INET
					case AF_INET:
						if (r->rpool.cur->addr.p.dyn->
						    pfid_acnt4 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_addr4,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_mask4,
						    saddr, AF_INET);
						break;
#endif /* INET */
#ifdef INET6
					case AF_INET6:
						if (r->rpool.cur->addr.p.dyn->
						    pfid_acnt6 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_addr6,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_mask6,
						    saddr, AF_INET6);
						break;
#endif /* INET6 */
					}
				} else
					PF_POOLMASK(naddr,
					    &r->rpool.cur->addr.v.a.addr,
					    &r->rpool.cur->addr.v.a.mask,
					    saddr, pd->af);
				break;
			case PF_IN:
				if (r->src.addr.type == PF_ADDR_DYNIFTL) {
					switch (pd->af) {
#ifdef INET
					case AF_INET:
						if (r->src.addr.p.dyn->
						    pfid_acnt4 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->src.addr.p.dyn->
						    pfid_addr4,
						    &r->src.addr.p.dyn->
						    pfid_mask4,
						    daddr, AF_INET);
						break;
#endif /* INET */
#ifdef INET6
					case AF_INET6:
						if (r->src.addr.p.dyn->
						    pfid_acnt6 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->src.addr.p.dyn->
						    pfid_addr6,
						    &r->src.addr.p.dyn->
						    pfid_mask6,
						    daddr, AF_INET6);
						break;
#endif /* INET6 */
					}
				} else
					PF_POOLMASK(naddr,
					    &r->src.addr.v.a.addr,
					    &r->src.addr.v.a.mask, daddr,
					    pd->af);
				break;
			}
			break;
		case PF_RDR: {
			if (pf_map_addr(pd->af, r, saddr, naddr, NULL, sn))
				return (NULL);
			if ((r->rpool.opts & PF_POOL_TYPEMASK) ==
			    PF_POOL_BITMASK)
				PF_POOLMASK(naddr, naddr,
				    &r->rpool.cur->addr.v.a.mask, daddr,
				    pd->af);

			if (r->rpool.proxy_port[1]) {
				u_int32_t	tmp_nport;

				tmp_nport = ((ntohs(dport) -
				    ntohs(r->dst.port[0])) %
				    (r->rpool.proxy_port[1] -
				    r->rpool.proxy_port[0] + 1)) +
				    r->rpool.proxy_port[0];

				/* wrap around if necessary */
				if (tmp_nport > 65535)
					tmp_nport -= 65535;
				*nport = htons((u_int16_t)tmp_nport);
			} else if (r->rpool.proxy_port[0])
				*nport = htons(r->rpool.proxy_port[0]);
			break;
		}
		default:
			return (NULL);
		}
		/* 
		 * Translation was a NOP.
		 * Undo separate NAT key and pretend there was no match.
		 */
		if (!bcmp(*skp, *nkp, sizeof(struct pf_state_key_cmp))) {
			pool_put(&pf_state_key_pl, *nkp);
			*skw = *sks = *nkp = *skp;
			return (NULL);
		}
	}

	return (r);
}
@


1.628
log
@In pf_test_rule(), if we don't create a state, free any state keys that
may have been allocated earlier by pf_get_translation().  Fixes a
pf_state_key_pl leak triggered by certain ICMP types matching a NAT
rule.  Finally located with the help of pool_walk().
ok henning@@ dlg@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.627 2008/11/24 13:22:09 mikeb Exp $ */
d2754 9
@


1.627
log
@Fix splasserts seen in pr 5987 by propagating a flag that discribes
whether we're called from the interrupt context to the functions
performing allocations.

Looked at by mpf@@ and henning@@, tested by mpf@@ and Antti Harri,
the pr originator.

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.626 2008/11/21 18:01:30 claudio Exp $ */
d3403 5
@


1.626
log
@Change rn_mpath_next() to be able to walk over the full multipath list
not only over routes of the same prio. This makes it possible to modify
rt_mpath_matchgate() so that if only gateway is specified without a specific
priority it will scan the full list and not only the first routes.
This is also needed for upcoming link state tracking.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.625 2008/10/28 22:57:01 mpf Exp $ */
d1186 1
a1186 1
	if ((aw->p.tbl = pfr_attach_table(rs, aw->v.tblname)) == NULL)
@


1.625
log
@Always skip "urpf-failed" test for IPv6 link local addresses.
We could re-embed the scope-id before we do the route lookup,
but then we would just find the very interface we've received
the packet on anyway.
OK markus@@, claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.624 2008/10/23 22:22:43 deraadt Exp $ */
d5156 1
a5156 1
			rn = rn_mpath_next(rn);
@


1.624
log
@use the correct idiom for NFOO things which come from "foo.h" files
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.623 2008/10/02 15:12:45 jsing Exp $ */
d5110 6
@


1.623
log
@When redirect is used with sticky-address and a matching pass rule uses
reply-to, the sticky-address in the source tracking pool is overwritten
with the reply-to address, resulting in new connections being incorrectly
redirected to the reply-to host (instead of the sticky-address host).

Prevent this by passing a NULL source node reference to pf_map_addr() when
looking up the reply-to host, thus preventing the NAT source node from
being overwritten.

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.620 2008/09/10 09:10:17 henning Exp $ */
d844 1
a844 1
#if NPFSYNC
d1095 1
a1095 1
#if NPFLOW
d1099 1
a1099 1
#if NPFSYNC
d1113 1
a1113 1
#if NPFSYNC
d5736 1
a5736 1
#if NPFSYNC
d5766 1
a5766 1
#if NPFSYNC
d5790 1
a5790 1
#if NPFSYNC
d5805 1
a5805 1
#if NPFSYNC
d6109 1
a6109 1
#if NPFSYNC
d6139 1
a6139 1
#if NPFSYNC
d6163 1
a6163 1
#if NPFSYNC
d6178 1
a6178 1
#if NPFSYNC
@


1.622
log
@Teach PF pf_print_state_parts() about IPv4 in IP and IPv6 in IP
encapsulation. Decapitalise the 'v' in ICMPv6 whilst here.

ok henning@@
@
text
@d2972 1
d2980 1
a2980 2
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL,
		    &s->nat_src_node);
d2986 1
a2986 2
		pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL,
		    &s->nat_src_node);
@


1.621
log
@remove dead stores and newly created unused variables.

fix potential use of uninitialized value in trunk_port_ioctl() function.

Found by LLVM/Clang Static Analyzer.

ok mpf@@ henning@@
@
text
@d1297 6
d1313 1
a1313 1
		printf("ICMPV6");
@


1.620
log
@re-enable the state key linking. i believe the bugs that hit us shortly
before release are fixed, and the extra check i added prevents incorrect
linking if there are still cases with tunnels, tho none of the testers
saw these yet, except for an icmp case that will be fixed shortly. the
extra check prevents misbehavior there.
if you see 'pf: state key linking mismatch' messages please report them to
me along with ifconfig -A and mention if you do any routing or nat tricks.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.619 2008/09/09 13:56:39 henning Exp $ */
a3038 1
	u_int16_t		 nport = 0;
a3098 1
	nport = sport;
a5404 1
	int			 error = 0;
d5487 1
a5487 1
		error = nd6_output(ifp, ifp, m0, dst, NULL);
@


1.619
log
@welcome pflow(4), a netflow v5 compatible flow export interface.
flows export data gathered from pf states.
initial implementation by Joerg Goltermann <jg@@osn.de>, guidance and many
changes by me. 'put it in' theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.618 2008/09/03 12:57:19 henning Exp $ */
a5827 1
#if 0
a5829 1
#endif
a6206 1
#if 0
a6208 1
#endif
@


1.618
log
@before linking state keys compare them to verify they actually are the
exact reverse of each other. if there is a mismatch don't erstablish the
link and print enough so that we should be able to find the culprit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.617 2008/09/02 17:35:16 chl Exp $ */
d41 1
d82 1
d1095 4
d3462 2
@


1.617
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.616 2008/08/26 12:17:10 henning Exp $ */
d245 2
d856 31
d903 3
a905 1
		if (dir == PF_OUT && m->m_pkthdr.pf.statekey) {
@


1.616
log
@introduce a function to be called when addressing information has changed,
pf_pkt_addr_changed. atm just clears the state key pointer.
calling this is cleaner than having other parts of the stack clearing
pointers in the pf part of the mbuf packet header directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.615 2008/08/22 00:35:08 bluhm Exp $ */
d2998 1
a2998 1
	u_int16_t		 nport = 0, bport = 0;
d3059 1
a3059 1
	bport = nport = sport;
@


1.615
log
@Make pf_print_host() print IPv6 addresses correctly.
ok mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.614 2008/08/02 12:34:37 henning Exp $ */
d6277 10
@


1.614
log
@do not write the pf state key pointer to the pkhdr.
effectively disables state key linking and pcb linking - unfortunatly,
there seems to be a bug somewhere in there or triggered by it that
we haven't tracked down yet, so we disable this for now to be on the safe
side for release.
lots of testing and analysis from todd and david.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.613 2008/07/22 12:31:35 henning Exp $ */
d1192 2
a1193 2
		u_int8_t i, curstart = 255, curend = 0,
		    maxstart = 0, maxend = 0;
d1198 1
a1198 2
				else
					curend = i;
d1200 4
a1203 7
				if (curstart) {
					if ((curend - curstart) >
					    (maxend - maxstart)) {
						maxstart = curstart;
						maxend = curend;
						curstart = 255;
					}
d1205 1
d1208 5
d1215 4
a1218 7
				if (maxend != 7) {
					if (i == maxstart)
						printf(":");
				} else {
					if (i == maxend)
						printf(":");
				}
@


1.614.2.1
log
@Avoid dereferencing a null pointer when pf attempts to translate a
specifically crafted IP datagram.

Problem noted by Sebastian Rother.

fix from jsing. ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.614 2008/08/02 12:34:37 henning Exp $ */
a5757 9
#ifdef INET6
	case IPPROTO_ICMPV6: {
		action = PF_DROP;
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping IPv4 packet with ICMPv6 payload\n"));
		goto done;
	}
#endif

a6106 7
	}

	case IPPROTO_ICMP: {
		action = PF_DROP;
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping IPv6 packet with ICMPv4 payload\n"));
		goto done;
@


1.613
log
@after pf_state_key_atach nothing must use the state keys passed to it any
more, since they might have been invalidated and free'd.
one synproxy errorpath did so, however. just get the state keys from the
state itself. ok david mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.612 2008/07/21 15:58:59 david Exp $ */
d5786 1
d5789 1
d6167 1
d6170 1
@


1.612
log
@some whitespace cleanup I did while looking through the code
ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.611 2008/07/21 15:56:55 david Exp $ */
d3540 5
a3544 2
			PF_ACPY(pd->src, &sk->addr[pd->sidx], pd->af);
			PF_ACPY(pd->dst, &sk->addr[pd->didx], pd->af);
d3546 1
a3546 1
				*pd->sport = sk->port[pd->sidx];
d3548 1
a3548 1
				*pd->dport = sk->port[pd->didx];
@


1.611
log
@fix typo that broke rdr rules (without pass) with non-TCP/UDP/ICMP protocols
ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.610 2008/07/14 13:29:45 henning Exp $ */
d210 1
a210 1
			    struct pf_rule **, struct pf_rule **,  int *);
d677 1
a677 1
		     			    s->kif->pfik_name);
d2013 1
a2013 1
    struct pf_rule **r, struct pf_rule **a,  int *match)
d2077 1
a2077 1
		if (f->r->anchor->match || (match  != NULL && *match))
d3061 1
a3061 1
	/* check  packet for BINAT/NAT/RDR */
@


1.610
log
@m_copy can return NULL, so check for it
problem found by "Adrian M. Whatley" <amw> and "Stephan A. Rickauer"
<stephan.rickauer>, both @@ni.phys.ethz.ch
fix by me, ok mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.609 2008/07/10 07:41:21 djm Exp $ */
d3163 1
a3163 1
					    nk->addr[pd->didx].v4.s_addr, 0);
@


1.609
log
@check pf NAT source port allocation against net.inet.(tcp|udp).baddynamic
lists; prevents use of ports corresponding to well-known services.

replace a couple of arc4random()%N with arc4random_uniform(N) that
missed the first round.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.608 2008/07/10 05:44:54 david Exp $ */
d1822 3
a1824 1
	m0 = m_copy(m, 0, M_COPYALL);
@


1.608
log
@In pf_state_insert(), if the first pf_state_key_attach() fails, the
state key is freed by pf_state_key_attach().  But in the case of NAT,
there are two state keys allocated, so we must free the second key
manually.  Fixes a pf_state_key_pl leak seen in certain cases with
pfsync or with pf state-insert errors.
ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.607 2008/07/05 16:57:50 david Exp $ */
d2432 1
a2432 1
			cut = htonl(arc4random()) % (1 + high - low) + low;
d2437 1
a2437 1
				    NULL) {
d2445 1
a2445 1
				    NULL) {
d3238 2
a3239 2
		else if (r->prob && r->prob <=
		    (arc4random() % (UINT_MAX - 1) + 1))
@


1.607
log
@in pf_state_key_attach(), when there is already an existing state key that
can be used and we return the state key back to the pool, don't insert
state items into the tailq using that garbage state key.
this makes things much happier for me.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.606 2008/07/04 00:56:48 henning Exp $ */
d805 3
a807 4
	if (pf_state_key_attach(skw, s, PF_SK_WIRE))
		return (-1);

	if (skw == sks)
d809 5
a813 1
	else {
@


1.606
log
@in pf_state_key_attach(), when we find that there already is a state key
that we can attach the state to, make sure to not overwrite the state key
pointer in the state that was just set to the existing state key with the
state key that was supplied with the state and just free'd (well, pool_put'd).
by the time we clean up the state and try to follow it to RB_REMOVE etc
we'd follow that garbage pointer to either an unrelated state key or the old
state key still sitting unused in the pool.
should fix the RB_REMOVE panics some people have been seeing.
"clearly ok, please commit" ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.605 2008/07/04 00:09:31 henning Exp $ */
d699 1
a699 1
		TAILQ_INSERT_TAIL(&sk->states, si, entry);
d701 1
a701 1
		TAILQ_INSERT_HEAD(&sk->states, si, entry);
@


1.605
log
@remove prototype for nonexistant function
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.604 2008/07/03 15:46:23 henning Exp $ */
d688 2
a689 2
	}
	s->key[idx] = sk;
@


1.604
log
@link pf state keys to tcp pcbs and vice versa.
when we first do a pcb lookup and we have a pointer to a pf state key
in the mbuf header, store the state key pointer in the pcb and a pointer
to the pcb we just found in the state key. when either the state key
or the pcb is removed, clear the pointers.
on subsequent packets inbound we can skip the pcb lookup and just use the
pointer from the state key.
on subsequent packets outbound we can skip the state key lookup and use
the pointer from the pcb.
about 8% speedup with 100 concurrent tcp sessions, should help much more
with more tcp sessions.
ok markus ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.603 2008/07/01 13:07:02 mcbride Exp $ */
a167 2
struct pf_state_key	*pf_state_key_insert(struct pf_state_key *,
			    struct pf_state *);
@


1.603
log
@Don't return immediately if we're actually passing the traffic, we want to
ensure that the packet gets rewritten correctly first.

As usual, problem pointed out by david
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.602 2008/07/01 12:56:19 mcbride Exp $ */
d738 2
@


1.602
log
@PF_DT_SKIP_STATETREE is no longer used.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.601 2008/06/29 08:42:15 mcbride Exp $ */
d3353 1
@


1.601
log
@Simplify state creation code; merge state import/export code between pfsync
and the state-related pf(4) ioctls, and make functions in state creation and
destruction paths more robust in error conditions.

All values in struct pfsync_state now in network byte order, as with pfsync.

testing by david
ok henning, systat parts ok canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.600 2008/06/26 03:56:20 mcbride Exp $ */
a318 2

#define	PF_DT_SKIP_STATETREE	0x01
@


1.600
log
@Fix sticky-address on rdr; With the current nat code, we always use the same
address in the NATed state key for translation regardless of direction.

Report and testing by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.599 2008/06/21 02:05:46 mcbride Exp $ */
d167 1
a167 1
void			 pf_detach_state(struct pf_state *, int);
d175 1
a175 2
void			 pf_state_key_detach(struct pf_state_key *,
			    struct pf_state *, int);
a249 2
void			 pf_keyins_err(struct pf_state *, struct pf_state_key *,
			    struct pf_state_key *, char *, u_int8_t);
a577 11
void
pf_keyins_err(struct pf_state *s, struct pf_state_key *skw,
    struct pf_state_key *sks, char *side, u_int8_t direction)
{
	if (pf_status.debug >= PF_DEBUG_MISC) {
		printf("pf: %s key insert failed: ", side, s->kif->pfik_name);
		pf_print_state_parts(s, skw, sks);
		printf("\n");
	}
}

d663 2
a664 3
void
pf_attach_state(struct pf_state_key *sk, struct pf_state *s, int tail,
    int where)
d667 3
d671 23
a693 4
	if (where == PF_SK_WIRE || where == PF_SK_BOTH)
		s->key[PF_SK_WIRE] = sk;
	if (where == PF_SK_STACK || where == PF_SK_BOTH)
		s->key[PF_SK_STACK] = sk;
d695 4
a698 1
	si = pool_get(&pf_state_item_pl, PR_NOWAIT);
d702 1
a702 1
	if (tail)
d706 1
d710 1
a710 1
pf_detach_state(struct pf_state *s, int flags)
d715 2
a716 4
	if (s->key[PF_SK_STACK] != NULL) {
		pf_state_key_detach(s->key[PF_SK_STACK], s, flags);
		s->key[PF_SK_STACK] = NULL;
	}
d718 2
a719 4
	if (s->key[PF_SK_WIRE] != NULL) {
		pf_state_key_detach(s->key[PF_SK_WIRE], s, flags);
		s->key[PF_SK_WIRE] = NULL;
	}
d723 1
a723 1
pf_state_key_detach(struct pf_state_key *sk, struct pf_state *s, int flags)
d727 14
a740 12
	for (si = TAILQ_FIRST(&sk->states); si->s != s;
	    si = TAILQ_NEXT(si, entry));

	TAILQ_REMOVE(&sk->states, si, entry);
	pool_put(&pf_state_item_pl, si);

	if (TAILQ_EMPTY(&sk->states)) {
		if (!(flags & PF_DT_SKIP_STATETREE))
			RB_REMOVE(pf_state_tree, &pf_statetbl, sk);
		if (sk->reverse)
			sk->reverse->reverse = NULL;
		pool_put(&pf_state_key_pl, sk);
d742 1
d746 1
a746 1
pf_alloc_state_key(void)
d750 1
a750 1
	if ((sk = pool_get(&pf_state_key_pl, PR_NOWAIT | PR_ZERO)) == NULL)
a756 22
struct pf_state_key *
pf_state_key_insert(struct pf_state_key *sk, struct pf_state *s)
{
	struct pf_state_key	*cur;
	struct pf_state_item	*si;

	if (sk && (cur = RB_INSERT(pf_state_tree, &pf_statetbl, sk)) != NULL) {
		/* key exists. check for same kif, if none, add to key */
		TAILQ_FOREACH(si, &cur->states, entry)
			if (si->s->kif == s->kif &&
			    si->s->direction == s->direction) {
				/* collision! */
				pf_detach_state(s, PF_DT_SKIP_STATETREE);
				return (NULL);
			}
		pf_detach_state(s, PF_DT_SKIP_STATETREE);
		return (cur);
	}
	return (sk);
}


d766 1
a766 1
	if ((*skp = pf_alloc_state_key()) == NULL)
d777 2
a778 2
		if ((*nkp = pf_alloc_state_key()) == NULL)
			return (ENOMEM); /* cleanup handled in pf_test_rule() */
a804 2
	struct pf_state_key	*nskw, *nsks;

d807 1
a807 5
	KASSERT((sks != NULL));
	KASSERT((skw != NULL));

	if ((nskw = pf_state_key_insert(skw, s)) == NULL) {
		pf_keyins_err(s, skw, sks, "wire", s->direction);
a808 1
	}
d810 5
a814 5
	if (skw == sks) {
		pf_attach_state(nskw, s, kif == pfi_all ? 1 : 0, PF_SK_BOTH);
	} else {
		if ((nsks = pf_state_key_insert(sks, s)) == NULL) {
			pf_keyins_err(s, skw, sks, "stack", s->direction);
a816 2
		pf_attach_state(nskw, s, kif == pfi_all ? 1 : 0, PF_SK_WIRE);
		pf_attach_state(nsks, s, kif == pfi_all ? 1 : 0, PF_SK_STACK);
d832 1
a832 1
		pf_detach_state(s, 0);
d1063 1
a1063 1
	pf_detach_state(cur, 0);
d3342 1
a3342 1
		return (PF_DROP);
d3346 1
a3346 1
		return (PF_DROP);
a3354 3
		if (action == PF_DROP)
			goto cleanup;
		if (action != PF_PASS)
d3564 5
d4941 4
@


1.599
log
@Only do state key linking on the outbound path.
Fixes stateful filtering on enc0.

Problem report, testing, and ok david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.598 2008/06/16 01:16:04 henning Exp $ */
d3425 1
a3425 3
	    ((pd->dir == PF_OUT && pf_insert_src_node(&nsn, nr,
	    &sks->addr[0], pd->af) != 0) || (pd->dir == PF_IN &&
	    pf_insert_src_node(&nsn, nr, &skw->addr[0], pd->af) != 0))) {
d3506 2
a3507 4
		if (pd->dir == PF_IN)
			PF_ACPY(&nsn->raddr, &nk->addr[0], pd->af);
		else
			PF_ACPY(&nsn->raddr, &nk->addr[1], pd->af);
@


1.598
log
@when freeing a state key sk1, look wether it is linked to another state key
sk2 and reset sk2's link back to sk1
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.597 2008/06/12 18:41:41 henning Exp $ */
d890 1
a890 1
		if (m->m_pkthdr.pf.statekey) {
@


1.597
log
@fix synproxy.
the factored out pf_create_state() could return PF_PASS, _DROP, and
_SYNPROXY_DROP. We were treating the latter the same as _PASS and thus
passing the original SYN which we of course don't want in the synproxy
case.
breakage reported by sakurai-san, headscratching with and ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.596 2008/06/11 17:52:37 henning Exp $ */
d729 2
@


1.596
log
@when we establish the mapping from a state key, do it both ways, aka
key1->reverse = key2; and key2->reverse = key1;
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.595 2008/06/11 04:04:19 henning Exp $ */
d3369 3
a3371 2
	    (pd->flags & PFDESC_TCP_NORM)))
		if (pf_create_state(r, nr, a, pd, nsn, skw, sks, nk, sk, m,
d3373 2
a3374 1
		    bip_sum, hdrlen) == PF_DROP)
d3376 3
@


1.595
log
@factor out state creation code for readability; make it static inline
to not hurt performance while passing the 20 args (sigh)
ok theo ryan, ok + feedback jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.594 2008/06/11 03:36:33 henning Exp $ */
d888 1
a888 1
		if (m->m_pkthdr.pf.statekey)
d891 2
@


1.594
log
@superfluous to check for m != NULL in pf_find_state, it is plain
impossible that m is NULL here since all callers dereference it
unconditionally beforehands, and find state without and mbuf doesn't
make sense in the first place
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.593 2008/06/11 03:28:10 henning Exp $ */
d182 8
a3011 1
	u_int16_t		 mss = tcp_mssdflt;
a3365 1
/* XXX state creation should be really factored out */
d3367 4
a3370 9
	    (pd->flags & PFDESC_TCP_NORM))) {
		/* create new state */
		struct pf_state	*s = NULL;
		struct pf_src_node *sn = NULL;

		/* check maximums */
		if (r->max_states && (r->states_cur >= r->max_states)) {
			pf_status.lcounters[LCNT_STATES]++;
			REASON_SET(&reason, PFRES_MAXSTATES);
d3372 7
a3378 20
		}
		/* src node for filter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0) {
			REASON_SET(&reason, PFRES_SRCLIMIT);
			goto cleanup;
		}
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &sks->addr[0], af) != 0) ||
		    (direction == PF_IN &&
		    pf_insert_src_node(&nsn, nr, &skw->addr[0], af) != 0))) {
			REASON_SET(&reason, PFRES_SRCLIMIT);
			goto cleanup;
		}
		s = pool_get(&pf_state_pl, PR_NOWAIT | PR_ZERO);
		if (s == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
d3380 100
a3479 72
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			if (sk != NULL)
				pool_put(&pf_state_key_pl, sk);
			if (nk != NULL)
				pool_put(&pf_state_key_pl, nk);
			return (PF_DROP);
		}
		s->rule.ptr = r;
		s->nat_rule.ptr = nr;
		s->anchor.ptr = a;
		STATE_INC_COUNTERS(s);
		if (r->allow_opts)
			s->state_flags |= PFSTATE_ALLOWOPTS;
		if (r->rule_flag & PFRULE_STATESLOPPY)
			s->state_flags |= PFSTATE_SLOPPY;
		s->log = r->log & PF_LOG_ALL;
		if (nr != NULL)
			s->log |= nr->log & PF_LOG_ALL;
		switch (pd->proto) {
		case IPPROTO_TCP:
			s->src.seqlo = ntohl(th->th_seq);
			s->src.seqhi = s->src.seqlo + pd->p_len + 1;
			if ((th->th_flags & (TH_SYN|TH_ACK)) ==
			TH_SYN && r->keep_state == PF_STATE_MODULATE) {
				/* Generate sequence number modulator */
				if ((s->src.seqdiff = pf_tcp_iss(pd) -
				    s->src.seqlo) == 0)
					s->src.seqdiff = 1;
				pf_change_a(&th->th_seq, &th->th_sum,
				    htonl(s->src.seqlo + s->src.seqdiff), 0);
				rewrite = 1;
			} else
				s->src.seqdiff = 0;
			if (th->th_flags & TH_SYN) {
				s->src.seqhi++;
				s->src.wscale = pf_get_wscale(m, off,
				    th->th_off, af);
			}
			s->src.max_win = MAX(ntohs(th->th_win), 1);
			if (s->src.wscale & PF_WSCALE_MASK) {
				/* Remove scale factor from initial window */
				int win = s->src.max_win;
				win += 1 << (s->src.wscale & PF_WSCALE_MASK);
				s->src.max_win = (win - 1) >>
				    (s->src.wscale & PF_WSCALE_MASK);
			}
			if (th->th_flags & TH_FIN)
				s->src.seqhi++;
			s->dst.seqhi = 1;
			s->dst.max_win = 1;
			s->src.state = TCPS_SYN_SENT;
			s->dst.state = TCPS_CLOSED;
			s->timeout = PFTM_TCP_FIRST_PACKET;
			break;
		case IPPROTO_UDP:
			s->src.state = PFUDPS_SINGLE;
			s->dst.state = PFUDPS_NO_TRAFFIC;
			s->timeout = PFTM_UDP_FIRST_PACKET;
			break;
		case IPPROTO_ICMP:
d3481 1
a3481 1
		case IPPROTO_ICMPV6:
d3483 7
a3489 48
			s->timeout = PFTM_ICMP_FIRST_PACKET;
			break;
		default:
			s->src.state = PFOTHERS_SINGLE;
			s->dst.state = PFOTHERS_NO_TRAFFIC;
			s->timeout = PFTM_OTHER_FIRST_PACKET;
		}

		s->creation = time_second;
		s->expire = time_second;

		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			if (direction == PF_IN)
				PF_ACPY(&nsn->raddr, &nk->addr[0], af);
			else
				PF_ACPY(&nsn->raddr, &nk->addr[1], af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if (pd->proto == IPPROTO_TCP) {
			if ((pd->flags & PFDESC_TCP_NORM) &&
			    pf_normalize_tcp_init(m, off, pd, th, &s->src,
			    &s->dst)) {
				REASON_SET(&reason, PFRES_MEMORY);
				pf_src_tree_remove_state(s);
				STATE_DEC_COUNTERS(s);
				pool_put(&pf_state_pl, s);
				return (PF_DROP);
			}
			if ((pd->flags & PFDESC_TCP_NORM) && s->src.scrub &&
			    pf_normalize_tcp_stateful(m, off, pd, &reason,
			    th, s, &s->src, &s->dst, &rewrite)) {
				/* This really shouldn't happen!!! */
				DPFPRINTF(PF_DEBUG_URGENT,
				    ("pf_normalize_tcp_stateful failed on "
				    "first pkt"));
				pf_normalize_tcp_cleanup(s);
				pf_src_tree_remove_state(s);
				STATE_DEC_COUNTERS(s);
				pool_put(&pf_state_pl, s);
				return (PF_DROP);
			}
		}
		s->direction = direction;
d3491 2
a3492 3
		if (sk == NULL && pf_state_key_setup(pd, nr,
		    &skw, &sks, &sk, &nk, saddr, daddr, sport, dport))
			goto cleanup;
d3494 16
a3509 4
		if (pf_state_insert(BOUND_IFACE(r, kif), skw, sks, s)) {
			if (pd->proto == IPPROTO_TCP)
				pf_normalize_tcp_cleanup(s);
			REASON_SET(&reason, PFRES_STATEINS);
d3514 15
a3528 2
		} else
			*sm = s;
d3530 14
a3543 1
		pf_set_rt_ifp(s, saddr);	/* needs s->state_key set */
d3545 21
a3565 33
		if (tag > 0) {
			pf_tag_ref(tag);
			s->tag = tag;
		}
		if (pd->proto == IPPROTO_TCP &&
		    (th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
		    r->keep_state == PF_STATE_SYNPROXY) {
			s->src.state = PF_TCPS_PROXY_SRC;
			/* undo NAT changes, if they have taken place */
			if (nr != NULL) {
				PF_ACPY(saddr, &sk->addr[pd->sidx], af);
				PF_ACPY(daddr, &sk->addr[pd->didx], af);
				if (pd->sport)
					*pd->sport = sk->port[pd->sidx];
				if (pd->dport)
					*pd->dport = sk->port[pd->didx];
				if (pd->proto_sum)
					*pd->proto_sum = bproto_sum;
				if (pd->ip_sum)
					*pd->ip_sum = bip_sum;
				m_copyback(m, off, hdrlen, pd->hdr.any);
			}
			s->src.seqhi = htonl(arc4random());
			/* Find mss option */
			mss = pf_get_mss(m, off, th->th_off, af);
			mss = pf_calc_mss(saddr, af, mss);
			mss = pf_calc_mss(daddr, af, mss);
			s->src.mss = mss;
			pf_send_tcp(r, af, daddr, saddr, th->th_dport,
			    th->th_sport, s->src.seqhi, ntohl(th->th_seq) + 1,
			    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, 0, NULL, NULL);
			REASON_SET(&reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
d3567 11
d3580 1
a3580 3
	/* copy back packet headers if we performed NAT operations */
	if (rewrite)
		m_copyback(m, off, hdrlen, pd->hdr.any);
d3582 14
a3595 1
	return (PF_PASS);
@


1.593
log
@after finding a state in the outbound path clear the statekey pointer
in the header so it cannot get used again in case of somewhat weird
reflection + mbuf-reuse-without-pkthdr-clearing cases. it looks like
gif falls into the latter category.
discussed with and ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.591 2008/06/11 02:54:05 henning Exp $ */
d873 1
a873 1
	if (dir == PF_OUT && m && m->m_pkthdr.pf.statekey &&
d880 1
a880 1
		if (m && m->m_pkthdr.pf.statekey)
d885 1
a885 1
	if (dir == PF_OUT && m)
@


1.592
log
@extra paranoia:
1) only set the state key in the mbuf header in the inbound case
2) only use it in the outbound case
discussed with and ok theo
@
text
@d885 3
@


1.591
log
@yuck, fix a last minute collision
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.590 2008/06/11 02:46:34 henning Exp $ */
d873 1
a873 1
	if (m && m->m_pkthdr.pf.statekey &&
d5764 1
a5764 1
	if (s && s->key[PF_SK_STACK])
d6143 1
a6143 1
	if (s && s->key[PF_SK_STACK])
@


1.590
log
@store a pointer to the stack side state key in the mbuf packet
header inbound. on the outbound side, we take that and look for the key
that is the exact opposite, and store that mapping in the state key. on
subsequent packets we don't have to do the lookup on outbound any more.
almost unable to get real benchmarks going here, we know for sure this
gives a more than 5% increase in forwarding performance.
many thanks to ckuethe for stress- and performance-testing.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.589 2008/06/10 22:59:13 reyk Exp $ */
d4084 1
a4084 1
	STATE_LOOKUP(kif, &key, direction, *state);
@


1.589
log
@Handle the closing of half connections where we don't see the full
bidirectional FIN/ACK+ACK handshake.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.588 2008/06/10 22:39:31 mcbride Exp $ */
d203 1
a203 1
			    struct pfi_kif *, struct pf_pdesc *);
d241 1
a241 1
			    struct pf_state_key_cmp *, u_int);
d258 1
a258 1
#define STATE_LOOKUP(i, k, d, s)					\
d260 1
a260 1
		s = pf_find_state(i, k, d);			\
d865 2
a866 1
pf_find_state(struct pfi_kif *kif, struct pf_state_key_cmp *key, u_int dir)
d873 11
a883 3
	if ((sk = RB_FIND(pf_state_tree, &pf_statetbl,
	    (struct pf_state_key *)key)) == NULL)
		return (NULL);
d4250 1
a4250 1
	STATE_LOOKUP(kif, &key, direction, *state);
d4351 1
a4351 1
		STATE_LOOKUP(kif, &key, direction, *state);
d4548 1
a4548 1
			STATE_LOOKUP(kif, &key, direction, *state);
d4670 1
a4670 1
			STATE_LOOKUP(kif, &key, direction, *state);
d4738 1
a4738 1
			STATE_LOOKUP(kif, &key, direction, *state);
d4791 1
a4791 1
			STATE_LOOKUP(kif, &key, direction, *state);
d4835 1
a4835 1
			STATE_LOOKUP(kif, &key, direction, *state);
d4886 1
a4886 1
    struct pf_pdesc *pd)
d4903 1
a4903 1
	STATE_LOOKUP(kif, &key, direction, *state);
d5737 1
a5737 1
		action = pf_test_state_other(&s, dir, kif, &pd);
d5764 3
d6110 1
a6110 1
		action = pf_test_state_other(&s, dir, kif, &pd);
d6142 3
@


1.588
log
@Simplify code slightly; use PR_ZERO with pool_get() rather than bzero().

ok mpf henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.587 2008/06/10 21:14:39 reyk Exp $ */
d4016 9
@


1.587
log
@Handle a special sloppy case where we only see one half of the
connection. If there is a ACK after the initial SYN without ever
seeing a packet from the destination, set the connection to
established.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.586 2008/06/10 20:05:13 henning Exp $ */
d530 1
a530 1
			(*sn) = pool_get(&pf_src_tree_pl, PR_NOWAIT);
a534 1
		bzero(*sn, sizeof(struct pf_src_node));
d730 1
a730 1
	if ((sk = pool_get(&pf_state_key_pl, PR_NOWAIT)) == NULL)
a731 1
	bzero(sk, sizeof(*sk));
d3376 1
a3376 1
		s = pool_get(&pf_state_pl, PR_NOWAIT);
a3398 1
		bzero(s, sizeof(*s));
@


1.586
log
@remove a debug check& printf that should not have gone in in the first
place
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.585 2008/06/10 19:32:13 henning Exp $ */
d4003 1
a4003 1
		} else if (dst->state == TCPS_CLOSING)
d4005 15
@


1.585
log
@save somespace in the state by collapsing two 8 bit ints used as booleans
into one 8 bit flags field.
shrinks the state structure by 4 bytes on 32bit archs
ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.584 2008/06/10 04:26:31 henning Exp $ */
a714 2

/* XXX DEBUG */ if (!si) { printf("pf_state_key_detach, si NULL\n"); }
@


1.584
log
@in pf_test_state_icmp when trying tomatch icmp errors to tcp sessions
do not verify the sequence number against the state if the state is sloppy
and thus doesn't have that information.
independently pointed out by frantzen and ryan, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.582 2008/06/09 07:07:16 djm Exp $ */
d3408 2
a3409 1
		s->allow_opts = r->allow_opts;
d3411 1
a3411 1
			s->sloppy = 1;
d4166 1
a4166 1
	if ((*state)->sloppy) {
d4543 2
a4544 1
			if (!(*state)->sloppy && (!SEQ_GEQ(src->seqhi, seq) ||
d5725 1
a5725 1
	    !((s && s->allow_opts) || r->allow_opts)) {
d6101 1
a6101 1
	    !((s && s->allow_opts) || r->allow_opts)) {
@


1.583
log
@implement a sloppy tcpstate tracker which does not look at sequence
numbers at all. scary consequences; only tobe used in very specific
situations where you don't see all packets of a connection, e. g.
asymmetric routing. ok ryan reyk theo
@
text
@d4542 2
a4543 2
			if (!SEQ_GEQ(src->seqhi, seq) ||
			    !SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws))) {
@


1.582
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.581 2008/06/08 21:30:44 henning Exp $ */
d186 1
a186 1
int			 pf_tcp_seqtrack_full(struct pf_state_peer *,
d190 3
d3409 2
d3656 1
a3656 1
pf_tcp_seqtrack_full(struct pf_state_peer *src, struct pf_state_peer *dst,
d3984 47
d4165 8
a4172 3
	if (pf_tcp_seqtrack_full(src, dst, state, kif, m, off, pd, reason,
	    &copyback) == PF_DROP)
		return (PF_DROP);
@


1.581
log
@factor out the tcp sequence number tracking from pf_test_state_tcp
ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.580 2008/06/08 17:23:19 henning Exp $ */
d2950 1
a2950 1
		arc4random_bytes(pf_tcp_secret, sizeof(pf_tcp_secret));
@


1.580
log
@null pointer check before deref
almost nobody ran into that because it is ipv6 only
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.579 2008/06/02 11:38:22 mcbride Exp $ */
d186 4
d3651 3
a3653 3
pf_test_state_tcp(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
    u_short *reason)
a3654 1
	struct pf_state_key_cmp	 key;
a3659 127
	int			 copyback = 0;
	struct pf_state_peer	*src, *dst;
	struct pf_state_key	*sk;

	key.af = pd->af;
	key.proto = IPPROTO_TCP;
	if (direction == PF_IN)	{	/* wire side, straight */
		PF_ACPY(&key.addr[0], pd->src, key.af);
		PF_ACPY(&key.addr[1], pd->dst, key.af);
		key.port[0] = th->th_sport;
		key.port[1] = th->th_dport;
	} else {			/* stack side, reverse */
		PF_ACPY(&key.addr[1], pd->src, key.af);
		PF_ACPY(&key.addr[0], pd->dst, key.af);
		key.port[1] = th->th_sport;
		key.port[0] = th->th_dport;
	}

	STATE_LOOKUP(kif, &key, direction, *state);

	if (direction == (*state)->direction) {
		src = &(*state)->src;
		dst = &(*state)->dst;
	} else {
		src = &(*state)->dst;
		dst = &(*state)->src;
	}

	sk = (*state)->key[pd->didx];

	if ((*state)->src.state == PF_TCPS_PROXY_SRC) {
		if (direction != (*state)->direction) {
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		}
		if (th->th_flags & TH_SYN) {
			if (ntohl(th->th_seq) != (*state)->src.seqlo) {
				REASON_SET(reason, PFRES_SYNPROXY);
				return (PF_DROP);
			}
			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    (*state)->src.seqhi, ntohl(th->th_seq) + 1,
			    TH_SYN|TH_ACK, 0, (*state)->src.mss, 0, 1,
			    0, NULL, NULL);
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		} else if (!(th->th_flags & TH_ACK) ||
		    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
		    (ntohl(th->th_seq) != (*state)->src.seqlo + 1)) {
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_DROP);
		} else if ((*state)->src_node != NULL &&
		    pf_src_connlimit(state)) {
			REASON_SET(reason, PFRES_SRCLIMIT);
			return (PF_DROP);
		} else
			(*state)->src.state = PF_TCPS_PROXY_DST;
	}
	if ((*state)->src.state == PF_TCPS_PROXY_DST) {
		if (direction == (*state)->direction) {
			if (((th->th_flags & (TH_SYN|TH_ACK)) != TH_ACK) ||
			    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
			    (ntohl(th->th_seq) != (*state)->src.seqlo + 1)) {
				REASON_SET(reason, PFRES_SYNPROXY);
				return (PF_DROP);
			}
			(*state)->src.max_win = MAX(ntohs(th->th_win), 1);
			if ((*state)->dst.seqhi == 1)
				(*state)->dst.seqhi = htonl(arc4random());
			pf_send_tcp((*state)->rule.ptr, pd->af,
			    &sk->addr[pd->sidx], &sk->addr[pd->didx],
			    sk->port[pd->sidx], sk->port[pd->didx],
			    (*state)->dst.seqhi, 0, TH_SYN, 0,
			    (*state)->src.mss, 0, 0, (*state)->tag, NULL, NULL);
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		} else if (((th->th_flags & (TH_SYN|TH_ACK)) !=
		    (TH_SYN|TH_ACK)) ||
		    (ntohl(th->th_ack) != (*state)->dst.seqhi + 1)) {
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_DROP);
		} else {
			(*state)->dst.max_win = MAX(ntohs(th->th_win), 1);
			(*state)->dst.seqlo = ntohl(th->th_seq);
			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    ntohl(th->th_ack), ntohl(th->th_seq) + 1,
			    TH_ACK, (*state)->src.max_win, 0, 0, 0,
			    (*state)->tag, NULL, NULL);
			pf_send_tcp((*state)->rule.ptr, pd->af,
			    &sk->addr[pd->sidx], &sk->addr[pd->didx],
			    sk->port[pd->sidx], sk->port[pd->didx],
			    (*state)->src.seqhi + 1, (*state)->src.seqlo + 1,
			    TH_ACK, (*state)->dst.max_win, 0, 0, 1,
			    0, NULL, NULL);
			(*state)->src.seqdiff = (*state)->dst.seqhi -
			    (*state)->src.seqlo;
			(*state)->dst.seqdiff = (*state)->src.seqhi -
			    (*state)->dst.seqlo;
			(*state)->src.seqhi = (*state)->src.seqlo +
			    (*state)->dst.max_win;
			(*state)->dst.seqhi = (*state)->dst.seqlo +
			    (*state)->src.max_win;
			(*state)->src.wscale = (*state)->dst.wscale = 0;
			(*state)->src.state = (*state)->dst.state =
			    TCPS_ESTABLISHED;
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		}
	}

	if (((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN) &&
	    dst->state >= TCPS_FIN_WAIT_2 &&
	    src->state >= TCPS_FIN_WAIT_2) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state reuse ");
			pf_print_state(*state);
			pf_print_flags(th->th_flags);
			printf("\n");
		}
		/* XXX make sure it's the same direction ?? */
		(*state)->src.state = (*state)->dst.state = TCPS_CLOSED;
		pf_unlink_state(*state);
		*state = NULL;
		return (PF_DROP);
	}
d3694 1
a3694 1
			copyback = 1;
d3746 1
a3746 1
			copyback = 1;
d3792 1
a3792 1
			copyback = 1;
d3812 1
a3812 1
			    *state, src, dst, &copyback))
d3905 2
a3906 3
			    direction == PF_IN ? "in" : "out",
			    direction == (*state)->direction ?
				"fwd" : "rev");
d3911 1
a3911 1
			    *state, src, dst, &copyback))
d3960 2
a3961 3
			    direction == PF_IN ? "in" : "out",
			    direction == (*state)->direction ?
				"fwd" : "rev");
d3975 39
a4013 1
	/* Any packets which have gotten here are to be passed */
d4015 101
@


1.579
log
@Fix synproxy breakage introduced with the state table reorganization.
Bug report and testing from Otto Bretz.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.578 2008/05/30 14:22:48 henning Exp $ */
d3061 2
a3062 1
		bip_sum = *pd->ip_sum;
@


1.578
log
@trivial KNF before we go further
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.577 2008/05/29 01:00:53 mcbride Exp $ */
d3523 1
d3525 11
a3535 14
				if (PF_ANEQ(pd->src, &nk->addr[0], pd->af) ||
				    nk->port[0] != th->th_sport)
					pf_change_ap(pd->src, &th->th_sport,
					    pd->ip_sum, &th->th_sum,
					    &nk->addr[0], nk->port[0],
					    0, pd->af);
				if (PF_ANEQ(pd->dst, &nk->addr[1], pd->af) ||
				    nk->port[1] != th->th_dport)
					pf_change_ap(pd->dst, &th->th_dport,
					    pd->ip_sum, &th->th_sum,
					    &nk->addr[1], nk->port[1],
					    0, pd->af);
				sport = th->th_sport;
				dport = th->th_dport;
d3658 1
d3684 2
d3726 3
a3728 2
			pf_send_tcp((*state)->rule.ptr, pd->af, &key.addr[0],
			    &key.addr[1], key.port[0], key.port[1],
d3746 3
a3748 2
			pf_send_tcp((*state)->rule.ptr, pd->af, &key.addr[0],
			    &key.addr[1], key.port[0], key.port[1],
@


1.577
log
@Second half of PF state table rearrangement.
- Mechanical change: Use arrays for state key pointers in pf_state, and
  addr/port in pf_state_key, to allow the use of indexes.
- Fix NAT, pfsync, pfctl, and tcpdump to handle the new state structures.
  In struct pfsync_state, both state keys are included even when identical.
- Also fix some bugs discovered in the existing code during testing.
  (in particular, "block return" for TCP packets was not returning an RST)

ok henning beck deraadt
tested by otto dlg beck laurent

Special thanks to users Manuel Pata and Emilio Perea who did enough testing
to actually find some bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.575 2008/05/18 11:54:04 mcbride Exp $ */
d2948 2
a2949 1
		MD5Update(&pf_tcp_secret_ctx, pf_tcp_secret, sizeof(pf_tcp_secret));
d5151 1
a5151 1
			m0->m_pkthdr.csum_flags &= ~M_TCPV4_CSUM_OUT; /* Clear */
d5157 1
a5157 1
			m0->m_pkthdr.csum_flags &= ~M_UDPV4_CSUM_OUT; /* Clear */
@


1.576
log
@rewrite the state table logic.
complete the split off of the layer 3/4 adressing information from the extra
information in the actual state. a state key holds a list of states, and a
state points to two state keys - they're only different in the NAT case.
More specificially, it deprecates the (often difficult to understand)
concept of lan, ext, and gwy addresses, replacing them with WIRE and
STACK side address tuples.  (af, proto, saddr, daddr, sport, dport).
Concept first brought up some years ago on a ferry ride in bc by ryan and
me, I spent some time over the last year getting closer, and finally
got it completed in japan with ryan. dlg also took part, helped a lot,
and saved us 8 bytes.
This commit removes support for any kind of NAT as well as pfsync.
It also paves the road for some code simplification and some very cool
future stuff.
ok ryan beck, tested by many
@
text
@d163 4
a166 3
			    struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t *);
d168 7
d229 2
d236 2
a237 2
void			 pf_stateins_err(struct pf_state_key *,
			    struct pfi_kif *);
d251 1
a251 1
#define STATE_LOOKUP()							\
d253 2
a254 2
		*state = pf_find_state(kif, &key, direction);		\
		if (*state == NULL || (*state)->timeout == PFTM_PURGE)	\
d256 7
a262 7
		if (direction == PF_OUT &&				\
		    (((*state)->rule.ptr->rt == PF_ROUTETO &&		\
		    (*state)->rule.ptr->direction == PF_OUT) ||		\
		    ((*state)->rule.ptr->rt == PF_REPLYTO &&		\
		    (*state)->rule.ptr->direction == PF_IN)) &&		\
		    (*state)->rt_kif != NULL &&				\
		    (*state)->rt_kif != kif)				\
a265 8
#define	STATE_TRANSLATE(sk) \
	(sk)->lan.addr.addr32[0] != (sk)->gwy.addr.addr32[0] || \
	((sk)->af == AF_INET6 && \
	((sk)->lan.addr.addr32[1] != (sk)->gwy.addr.addr32[1] || \
	(sk)->lan.addr.addr32[2] != (sk)->gwy.addr.addr32[2] || \
	(sk)->lan.addr.addr32[3] != (sk)->gwy.addr.addr32[3])) || \
	(sk)->lan.port != (sk)->gwy.port

d437 1
a437 1
			    (*state)->key_wire->af);
d441 2
a442 2
		p.pfra_af = (*state)->key_wire->af;
		switch ((*state)->key_wire->af) {
d467 1
a467 1
				sk = st->key_wire;
d474 2
a475 3
				    (*state)->key_wire->af &&
				    (((*state)->direction ==
				        PF_OUT &&
d477 1
a477 1
				        &sk->addr1, sk->af)) ||
d480 1
a480 1
				        &sk->addr2, sk->af))) &&
d568 2
a569 1
pf_stateins_err(struct pf_state_key *sk, struct pfi_kif *kif)
d572 2
a573 7
		printf("pf: state insert failed: %s", kif->pfik_name);
		printf(" addr1: ");
		pf_print_host(&sk->addr1, sk->port1,
		    sk->af);
		printf(" addr2: ");
		pf_print_host(&sk->addr2, sk->port2,
		    sk->af);
d592 1
a592 1
		if (a->addr1.addr32[0] > b->addr1.addr32[0])
d594 1
a594 1
		if (a->addr1.addr32[0] < b->addr1.addr32[0])
d596 1
a596 1
		if (a->addr2.addr32[0] > b->addr2.addr32[0])
d598 1
a598 1
		if (a->addr2.addr32[0] < b->addr2.addr32[0])
d604 1
a604 1
		if (a->addr1.addr32[3] > b->addr1.addr32[3])
d606 1
a606 1
		if (a->addr1.addr32[3] < b->addr1.addr32[3])
d608 1
a608 1
		if (a->addr2.addr32[3] > b->addr2.addr32[3])
d610 1
a610 1
		if (a->addr2.addr32[3] < b->addr2.addr32[3])
d612 1
a612 1
		if (a->addr1.addr32[2] > b->addr1.addr32[2])
d614 1
a614 1
		if (a->addr1.addr32[2] < b->addr1.addr32[2])
d616 1
a616 1
		if (a->addr2.addr32[2] > b->addr2.addr32[2])
d618 1
a618 1
		if (a->addr2.addr32[2] < b->addr2.addr32[2])
d620 1
a620 1
		if (a->addr1.addr32[1] > b->addr1.addr32[1])
d622 1
a622 1
		if (a->addr1.addr32[1] < b->addr1.addr32[1])
d624 1
a624 1
		if (a->addr2.addr32[1] > b->addr2.addr32[1])
d626 1
a626 1
		if (a->addr2.addr32[1] < b->addr2.addr32[1])
d628 1
a628 1
		if (a->addr1.addr32[0] > b->addr1.addr32[0])
d630 1
a630 1
		if (a->addr1.addr32[0] < b->addr1.addr32[0])
d632 1
a632 1
		if (a->addr2.addr32[0] > b->addr2.addr32[0])
d634 1
a634 1
		if (a->addr2.addr32[0] < b->addr2.addr32[0])
d640 1
a640 1
	if ((diff = a->port1 - b->port1) != 0)
d642 1
a642 1
	if ((diff = a->port2 - b->port2) != 0)
d670 3
a672 3
		s->key_wire = sk;
	if (where == PF_SK_STACK || where == PF_SK_BOTH)	
		s->key_stack = sk;
d687 11
a697 7
	if (s->key_wire == s->key_stack) {
		pf_state_key_detach(s->key_wire, s, flags);
		s->key_wire = s->key_stack = NULL;
	} else {
		pf_state_key_detach(s->key_stack, s, flags);
		pf_state_key_detach(s->key_wire, s, flags);
		s->key_wire = s->key_stack = NULL;
d734 2
a735 3
int
pf_state_insert(struct pfi_kif *kif, struct pf_state_key *sk,
    struct pf_state *s)
d740 1
a740 3
	s->kif = kif;

	if ((cur = RB_INSERT(pf_state_tree, &pf_statetbl, sk)) != NULL) {
d743 2
a744 2
			if (si->s->kif == kif &&
			   si->s->direction == s->direction) {
a745 1
				pf_stateins_err(sk, kif);
d747 1
a747 1
				return (-1);
d750 75
a824 2
		/* RYAN PF_SK_BOTH not gut for nat shitz */
		pf_attach_state(cur, s, kif == pfi_all ? 1 : 0, PF_SK_BOTH);
a847 1
#ifdef XXX_PFSYNC_FIXED
a849 1
#endif
d857 1
a857 1
	
d876 2
a877 2
		    ((dir == si->s->direction && si->s->key_wire == sk) ||
		    (dir != si->s->direction && si->s->key_stack == sk))) 
d879 1
d894 12
a905 4
		ret = TAILQ_FIRST(&sk->states);
		if (more != NULL)
			TAILQ_FOREACH(si, &sk->states, entry)
				(*more)++;
a906 1

d1042 5
a1046 3
		pf_send_tcp(cur->rule.ptr, cur->key_wire->af,
		    &cur->key_wire->addr2, &cur->key_wire->addr1,
		    cur->key_wire->port2, cur->key_wire->port1,
d1233 17
a1249 2
	struct pf_state_key *sk = s->key_wire;
	switch (sk->proto) {
d1251 1
a1251 1
		printf("TCP ");
d1254 1
a1254 1
		printf("UDP ");
d1257 1
a1257 1
		printf("ICMP ");
d1260 1
a1260 1
		printf("ICMPV6 ");
d1263 1
a1263 1
		printf("%u ", sk->proto);
d1266 42
a1307 18
	pf_print_host(&sk->addr1, sk->port1, sk->af);
	printf(" ");
	pf_print_host(&sk->addr2, sk->port2, sk->af);
#ifdef RYAN_NAT
	printf(" ");
	pf_print_host(&sk->addr2, sk->ext.port, sk->af);
#endif
	printf(" [lo=%u high=%u win=%u modulator=%u", s->src.seqlo,
	    s->src.seqhi, s->src.max_win, s->src.seqdiff);
	if (s->src.wscale && s->dst.wscale)
		printf(" wscale=%u", s->src.wscale & PF_WSCALE_MASK);
	printf("]");
	printf(" [lo=%u high=%u win=%u modulator=%u", s->dst.seqlo,
	    s->dst.seqhi, s->dst.max_win, s->dst.seqdiff);
	if (s->src.wscale && s->dst.wscale)
		printf(" wscale=%u", s->dst.wscale & PF_WSCALE_MASK);
	printf("]");
	printf(" %u:%u", s->src.state, s->dst.state);
d1514 2
a1515 1
	PF_ACPY(&ooa, oa, af);
d1564 4
a1567 3
	/* Change outer ip address, fix outer ip or icmpv6 checksum. */
	PF_ACPY(oa, na, af);
	switch (af) {
d1569 5
a1573 5
	case AF_INET:
		*hc = pf_cksum_fixup(pf_cksum_fixup(*hc,
		    ooa.addr16[0], oa->addr16[0], 0),
		    ooa.addr16[1], oa->addr16[1], 0);
		break;
d1576 13
a1588 13
	case AF_INET6:
		*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*ic,
		    ooa.addr16[0], oa->addr16[0], u),
		    ooa.addr16[1], oa->addr16[1], u),
		    ooa.addr16[2], oa->addr16[2], u),
		    ooa.addr16[3], oa->addr16[3], u),
		    ooa.addr16[4], oa->addr16[4], u),
		    ooa.addr16[5], oa->addr16[5], u),
		    ooa.addr16[6], oa->addr16[6], u),
		    ooa.addr16[7], oa->addr16[7], u);
		break;
d1590 1
a2376 1
#ifdef RYAN_NAT
d2393 3
a2395 3
		PF_ACPY(&key.addr2, daddr, key.af);
		PF_ACPY(&key.addr1, naddr, key.af);
		key.port2 = dport;
d2403 1
a2403 1
			key.gwy.port = dport;
d2407 1
a2407 1
			key.gwy.port = *nport;
d2411 1
a2411 1
			key.gwy.port = htons(low);
d2428 1
a2428 1
				key.gwy.port = htons(tmp);
d2436 1
a2436 1
				key.gwy.port = htons(tmp);
a2457 1
#endif
d2545 4
a2548 3
    struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport,
    struct pf_addr *naddr, u_int16_t *nport)
d2552 1
d2568 11
d2921 1
a2921 1
	switch (s->key_wire->af) {
a2974 1
	u_int16_t		 bport, nport = 0;
d2980 2
d2990 2
d2994 1
a2999 2
	sport = dport = hdrlen = 0;

d3016 1
d3030 1
a3030 1
		if (pd->af != AF_INET6)
d3044 3
d3051 18
a3068 8
	if (direction == PF_OUT) {
		bport = nport = sport;
		/* check outgoing packet for BINAT/NAT */
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
		    saddr, sport, daddr, dport, &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
			switch (pd->proto) {
			case IPPROTO_TCP:
d3070 3
a3072 1
				    &th->th_sum, &pd->naddr, nport, 0, af);
d3074 18
a3091 3
				rewrite++;
				break;
			case IPPROTO_UDP:
d3094 2
a3095 1
				    &pd->naddr, nport, 1, af);
d3097 14
a3110 2
				rewrite++;
				break;
d3112 3
a3114 1
			case IPPROTO_ICMP:
d3116 7
a3122 1
				    pd->naddr.v4.s_addr, 0);
d3124 7
a3130 4
				    pd->hdr.icmp->icmp_cksum, sport, nport, 0);
				pd->hdr.icmp->icmp_id = nport;
				m_copyback(m, off, ICMP_MINLEN, pd->hdr.icmp);
				break;
d3133 3
a3135 1
			case IPPROTO_ICMPV6:
d3137 7
a3143 3
				    &pd->naddr, 0);
				rewrite++;
				break;
d3145 2
a3146 2
			default:
				switch (af) {
d3148 3
a3150 1
				case AF_INET:
d3152 2
a3153 11
					    pd->ip_sum, pd->naddr.v4.s_addr, 0);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					PF_ACPY(saddr, &pd->naddr, af);
					break;
#endif /* INET */
				}
				break;
			}
d3155 5
a3159 28
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	} else {
		bport = nport = dport;
		/* check incoming packet for BINAT/RDR */
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, sport, daddr, dport, &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
			switch (pd->proto) {
			case IPPROTO_TCP:
				pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
				    &th->th_sum, &pd->naddr, nport, 0, af);
				dport = th->th_dport;
				rewrite++;
				break;
			case IPPROTO_UDP:
				pf_change_ap(daddr, &pd->hdr.udp->uh_dport,
				    pd->ip_sum, &pd->hdr.udp->uh_sum,
				    &pd->naddr, nport, 1, af);
				dport = pd->hdr.udp->uh_dport;
				rewrite++;
				break;
#ifdef INET
			case IPPROTO_ICMP:
				pf_change_a(&daddr->v4.s_addr, pd->ip_sum,
				    pd->naddr.v4.s_addr, 0);
d3163 8
a3170 4
			case IPPROTO_ICMPV6:
				pf_change_a6(daddr, &pd->hdr.icmp6->icmp6_cksum,
				    &pd->naddr, 0);
				rewrite++;
a3171 8
#endif /* INET6 */
			default:
				switch (af) {
#ifdef INET
				case AF_INET:
					pf_change_a(&daddr->v4.s_addr,
					    pd->ip_sum, pd->naddr.v4.s_addr, 0);
					break;
a3172 7
#ifdef INET6
				case AF_INET6:
					PF_ACPY(daddr, &pd->naddr, af);
					break;
#endif /* INET */
				}
				break;
d3174 1
a3174 4

			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
d3176 3
d3280 11
a3290 71
			if (direction == PF_OUT) {
				switch (pd->proto) {
				case IPPROTO_TCP:
					pf_change_ap(saddr, &th->th_sport,
					    pd->ip_sum, &th->th_sum,
					    &pd->baddr, bport, 0, af);
					sport = th->th_sport;
					rewrite++;
					break;
				case IPPROTO_UDP:
					pf_change_ap(saddr,
					    &pd->hdr.udp->uh_sport, pd->ip_sum,
					    &pd->hdr.udp->uh_sum, &pd->baddr,
					    bport, 1, af);
					sport = pd->hdr.udp->uh_sport;
					rewrite++;
					break;
				case IPPROTO_ICMP:
#ifdef INET6
				case IPPROTO_ICMPV6:
#endif
					/* nothing! */
					break;
				default:
					switch (af) {
					case AF_INET:
						pf_change_a(&saddr->v4.s_addr,
						    pd->ip_sum,
						    pd->baddr.v4.s_addr, 0);
						break;
					case AF_INET6:
						PF_ACPY(saddr, &pd->baddr, af);
						break;
					}
				}
			} else {
				switch (pd->proto) {
				case IPPROTO_TCP:
					pf_change_ap(daddr, &th->th_dport,
					    pd->ip_sum, &th->th_sum,
					    &pd->baddr, bport, 0, af);
					dport = th->th_dport;
					rewrite++;
					break;
				case IPPROTO_UDP:
					pf_change_ap(daddr,
					    &pd->hdr.udp->uh_dport, pd->ip_sum,
					    &pd->hdr.udp->uh_sum, &pd->baddr,
					    bport, 1, af);
					dport = pd->hdr.udp->uh_dport;
					rewrite++;
					break;
				case IPPROTO_ICMP:
#ifdef INET6
				case IPPROTO_ICMPV6:
#endif
					/* nothing! */
					break;
				default:
					switch (af) {
					case AF_INET:
						pf_change_a(&daddr->v4.s_addr,
						    pd->ip_sum,
						    pd->baddr.v4.s_addr, 0);
						break;
					case AF_INET6:
						PF_ACPY(daddr, &pd->baddr, af);
						break;
					}
				}
			}
a3346 1
		struct pf_state_key *sk = NULL;
d3365 3
a3367 2
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0))) {
d3388 1
a3388 1
			if (sk != NULL) {
d3390 2
a3391 1
			}
d3464 4
a3467 1
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
d3497 2
a3498 2
		if ((sk = pf_alloc_state_key()) == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
a3499 43
		}
		sk->proto = pd->proto;
		sk->af = af;
		if (direction == PF_IN) {
			PF_ACPY(&sk->addr1, saddr, af);
			PF_ACPY(&sk->addr2, daddr, af);
			switch (pd->proto) {
			case IPPROTO_ICMP:
#ifdef INET6
			case IPPROTO_ICMPV6:
#endif
				sk->port1 = nport;
				sk->port2 = 0;
				break;
			default:
				sk->port1 = sport;
				sk->port2 = dport;
			}
			if (nr != NULL) {
/* RYAN NAT */
			}
		} else {
			PF_ACPY(&sk->addr2, saddr, af);
			PF_ACPY(&sk->addr1, daddr, af);
			switch (pd->proto) {
			case IPPROTO_ICMP:
#ifdef INET6
			case IPPROTO_ICMPV6:
#endif
				sk->port2 = nport;
				sk->port1 = 0;
				break;
			default:
				sk->port2 = sport;
				sk->port1 = dport;
			}
			if (nr != NULL) {
/* RYAN NAT */
			}
		}

		pf_attach_state(sk, s, 0, PF_SK_BOTH);
		pf_set_rt_ifp(s, saddr);	/* needs s->state_key set */
d3501 1
a3501 1
		if (pf_state_insert(BOUND_IFACE(r, kif), sk, s)) {
d3511 3
d3523 14
a3536 11
				if (direction == PF_OUT) {
					pf_change_ap(saddr, &th->th_sport,
					    pd->ip_sum, &th->th_sum, &pd->baddr,
					    bport, 0, af);
					sport = th->th_sport;
				} else {
					pf_change_ap(daddr, &th->th_dport,
					    pd->ip_sum, &th->th_sum, &pd->baddr,
					    bport, 0, af);
					sport = th->th_dport;
				}
d3663 4
a3666 4
		PF_ACPY(&key.addr1, pd->src, key.af);
		PF_ACPY(&key.addr2, pd->dst, key.af);
		key.port1 = th->th_sport;
		key.port2 = th->th_dport;
d3668 4
a3671 4
		PF_ACPY(&key.addr2, pd->src, key.af);
		PF_ACPY(&key.addr1, pd->dst, key.af);
		key.port2 = th->th_sport;
		key.port1 = th->th_dport;
d3674 1
a3674 1
	STATE_LOOKUP();
d3724 2
a3725 2
			pf_send_tcp((*state)->rule.ptr, pd->af, &key.addr1,
			    &key.addr2, key.port1, key.port2,
d3743 2
a3744 2
			pf_send_tcp((*state)->rule.ptr, pd->af, &key.addr1,
			    &key.addr2, key.port1, key.port2,
a4098 1
#ifdef RYAN_NAT
d4100 5
a4104 2
	if (STATE_TRANSLATE((*state)->state_key)) {
		if (direction == PF_OUT)
d4106 5
a4110 3
			    &th->th_sum, &(*state)->state_key->gwy.addr,
			    (*state)->state_key->gwy.port, 0, pd->af);
		else
d4112 2
a4113 2
			    &th->th_sum, &(*state)->state_key->addr1,
			    (*state)->state_key->lan.port, 0, pd->af);
a4115 1
#endif
d4135 4
a4138 4
		PF_ACPY(&key.addr1, pd->src, key.af);
		PF_ACPY(&key.addr2, pd->dst, key.af);
		key.port1 = uh->uh_sport;
		key.port2 = uh->uh_dport;
d4140 4
a4143 4
		PF_ACPY(&key.addr2, pd->src, key.af);
		PF_ACPY(&key.addr1, pd->dst, key.af);
		key.port2 = uh->uh_sport;
		key.port1 = uh->uh_dport;
d4146 1
a4146 1
	STATE_LOOKUP();
a4168 1
#ifdef RYAN_NAT
d4170 5
a4174 2
	if (STATE_TRANSLATE((*state)->state_key)) {
		if (direction == PF_OUT)
d4176 5
a4180 3
			    &uh->uh_sum, &(*state)->state_key->gwy.addr,
			    (*state)->state_key->gwy.port, 1, pd->af);
		else
d4182 2
a4183 2
			    &uh->uh_sum, &(*state)->state_key->addr1,
			    (*state)->state_key->lan.port, 1, pd->af);
a4185 1
#endif
d4194 1
d4238 1
d4240 2
a4241 4
			PF_ACPY(&key.addr1, pd->src, key.af);
			PF_ACPY(&key.addr2, pd->dst, key.af);
			key.port1 = icmpid;
			key.port2 = 0;
d4243 2
a4244 4
			PF_ACPY(&key.addr2, pd->src, key.af);
			PF_ACPY(&key.addr1, pd->dst, key.af);
			key.port2 = 0;
			key.port1 = icmpid;
d4247 1
a4247 1
		STATE_LOOKUP();
a4251 1
#ifdef RYAN_NAT
d4253 4
a4256 3
		if (STATE_TRANSLATE((*state)->state_key)) {
			if (direction == PF_OUT) {
				switch (pd->af) {
d4258 3
a4260 1
				case AF_INET:
d4263 10
a4272 1
					    (*state)->state_key->gwy.addr.v4.s_addr, 0);
d4276 1
a4276 1
					    (*state)->state_key->gwy.port, 0);
d4278 6
a4283 4
					    (*state)->state_key->gwy.port;
					m_copyback(m, off, ICMP_MINLEN,
					    pd->hdr.icmp);
					break;
d4286 3
a4288 1
				case AF_INET6:
d4291 4
a4294 26
					    &(*state)->state_key->gwy.addr, 0);
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
					    pd->hdr.icmp6);
					break;
#endif /* INET6 */
				}
			} else {
				switch (pd->af) {
#ifdef INET
				case AF_INET:
					pf_change_a(&daddr->v4.s_addr,
					    pd->ip_sum,
					    (*state)->state_key->addr1.v4.s_addr, 0);
					pd->hdr.icmp->icmp_cksum =
					    pf_cksum_fixup(
					    pd->hdr.icmp->icmp_cksum, icmpid,
					    (*state)->state_key->lan.port, 0);
					pd->hdr.icmp->icmp_id =
					    (*state)->state_key->lan.port;
					m_copyback(m, off, ICMP_MINLEN,
					    pd->hdr.icmp);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
d4297 6
a4302 5
					    &(*state)->state_key->addr1, 0);
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
					    pd->hdr.icmp6);
					break;
a4303 1
				}
a4305 1
#endif /* RYAN_NAT */
d4326 3
d4439 4
a4442 11
			if (direction == PF_IN)	{	/* wire, straight */
				PF_ACPY(&key.addr1, pd2.src, key.af);
				PF_ACPY(&key.addr2, pd2.dst, key.af);
				key.port1 = th.th_sport;
				key.port2 = th.th_dport;
			} else {			/* stack, reverse */
				PF_ACPY(&key.addr2, pd2.src, key.af);
				PF_ACPY(&key.addr1, pd2.dst, key.af);
				key.port2 = th.th_sport;
				key.port1 = th.th_dport;
			}
d4444 1
a4444 1
			STATE_LOOKUP();
d4481 11
d4494 9
a4502 3
#ifdef RYAN_NAT
			if (STATE_TRANSLATE((*state)->state_key)) {
				if (direction == PF_IN) {
d4504 2
a4505 2
					    daddr, &(*state)->state_key->addr1,
					    (*state)->state_key->lan.port, NULL,
d4508 4
a4511 1
				} else {
d4513 3
a4515 2
					    saddr, &(*state)->state_key->gwy.addr,
					    (*state)->state_key->gwy.port, NULL,
a4517 1
				}
d4520 1
a4520 1
#endif
d4560 16
a4575 16
			if (direction == PF_IN)	{	/* wire, straight */
				PF_ACPY(&key.addr1, pd2.src, key.af);
				PF_ACPY(&key.addr2, pd2.dst, key.af);
				key.port1 = uh.uh_sport;
				key.port2 = uh.uh_dport;
			} else {			/* stack, reverse */
				PF_ACPY(&key.addr2, pd2.src, key.af);
				PF_ACPY(&key.addr1, pd2.dst, key.af);
				key.port2 = uh.uh_sport;
				key.port1 = uh.uh_dport;
			}

			STATE_LOOKUP();
#ifdef RYAN_NAT
			if (STATE_TRANSLATE((*state)->state_key)) {
				if (direction == PF_IN) {
d4577 2
a4578 4
					    daddr,
					    &(*state)->state_key->addr1,
					    (*state)->state_key->lan.port,
					    &uh.uh_sum,
d4581 4
a4584 1
				} else {
d4586 3
a4588 3
					    saddr,
					    &(*state)->state_key->gwy.addr,
					    (*state)->state_key->gwy.port, &uh.uh_sum,
d4591 1
a4591 1
				}
a4611 1
#endif
d4629 15
a4643 23
			if (direction == PF_IN)	{	/* wire, straight */
				PF_ACPY(&key.addr1, pd2.src, key.af);
				PF_ACPY(&key.addr2, pd2.dst, key.af);
				key.port1 = 0;
				key.port2 = iih.icmp_id;
			} else {			/* stack, reverse */
				PF_ACPY(&key.addr2, pd2.src, key.af);
				PF_ACPY(&key.addr1, pd2.dst, key.af);
				key.port2 = 0;
				key.port1 = iih.icmp_id;
			}

printf("pf: state search icmp repl: %s", kif->pfik_name);
printf(" addr1: ");
pf_print_host(&key.addr1, key.port1, pd->af);
printf(" addr2: ");
pf_print_host(&key.addr2, key.port2, pd->af);
printf("\n");
			STATE_LOOKUP();

#ifdef RYAN_NAT
			if (STATE_TRANSLATE((*state)->state_key)) {
				if (direction == PF_IN) {
d4645 2
a4646 3
					    daddr,
					    &(*state)->state_key->addr1,
					    (*state)->state_key->lan.port, NULL,
d4649 4
a4652 1
				} else {
d4654 3
a4656 3
					    saddr,
					    &(*state)->state_key->gwy.addr,
					    (*state)->state_key->gwy.port, NULL,
d4659 1
a4659 1
				}
a4663 1
#endif
d4682 15
a4696 17
			if (direction == PF_IN)	{
				PF_ACPY(&key.addr1, pd2.dst, key.af);
				PF_ACPY(&key.addr2, pd2.src, key.af);
				key.port1 = 0;
				key.port2 = iih.icmp6_id;
			} else {
				PF_ACPY(&key.addr2, pd2.src, key.af);
				PF_ACPY(&key.addr1, pd2.dst, key.af);
				key.port2 = 0;
				key.port1 = iih.icmp6_id;
			}

			STATE_LOOKUP();

#ifdef RYAN_NAT
			if (STATE_TRANSLATE((*state)->state_key)) {
				if (direction == PF_IN) {
d4698 2
a4699 3
					    daddr,
					    &(*state)->state_key->addr1,
					    (*state)->state_key->lan.port, NULL,
d4702 4
a4705 1
				} else {
d4707 3
a4709 2
					    saddr, &(*state)->state_key->gwy.addr,
					    (*state)->state_key->gwy.port, NULL,
d4712 1
a4712 1
				}
a4718 1
#endif
d4726 18
a4743 13
			if (direction == PF_IN)	{
				PF_ACPY(&key.addr1, pd2.src, key.af);
				PF_ACPY(&key.addr2, pd2.dst, key.af);
				key.port1 = 0;
				key.port2 = 0;
			} else {
				PF_ACPY(&key.addr2, pd2.src, key.af);
				PF_ACPY(&key.addr1, pd2.dst, key.af);
				key.port2 = 0;
				key.port1 = 0;
			}

			STATE_LOOKUP();
d4745 2
a4746 3
#ifdef RYAN_NAT
			if (STATE_TRANSLATE((*state)->state_key)) {
				if (direction == PF_IN) {
d4748 2
a4749 3
					    daddr,
					    &(*state)->state_key->addr1,
					    0, NULL,
d4752 1
a4752 8
				} else {
					pf_change_icmp(pd2.dst, NULL,
					    saddr,
					    &(*state)->state_key->gwy.addr,
					    0, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				}
a4771 1
#endif
d4789 3
a4791 4
		PF_ACPY(&key.addr1, pd->src, key.af);
		PF_ACPY(&key.addr2, pd->dst, key.af);
		key.port1 = 0;
		key.port2 = 0;
d4793 3
a4795 4
		PF_ACPY(&key.addr2, pd->src, key.af);
		PF_ACPY(&key.addr1, pd->dst, key.af);
		key.port2 = 0;
		key.port1 = 0;
d4798 1
a4798 1
	STATE_LOOKUP();
a4820 1
#ifdef RYAN_NAT
d4822 4
a4825 3
	if (STATE_TRANSLATE((*state)->state_key)) {
		if (direction == PF_OUT)
			switch (pd->af) {
d4827 2
a4828 1
			case AF_INET:
d4831 1
a4831 1
				    (*state)->state_key->gwy.addr.v4.s_addr,
d4833 3
a4835 13
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(pd->src,
				    &(*state)->state_key->gwy.addr, pd->af);
				break;
#endif /* INET6 */
			}
		else
			switch (pd->af) {
#ifdef INET
			case AF_INET:
d4838 1
a4838 1
				    (*state)->state_key->addr1.v4.s_addr,
d4840 1
d4844 6
a4849 4
			case AF_INET6:
				PF_ACPY(pd->dst,
				    &(*state)->state_key->addr1, pd->af);
				break;
d4851 1
a4851 1
			}
a4852 1
#endif
d5526 1
a5526 1
	PF_ACPY(&pd.baddr, dir == PF_OUT ? pd.src : pd.dst, AF_INET);
d5528 1
d5530 3
d5734 2
a5735 22
		if (nr != NULL) {
			struct pf_addr *x;
			/*
			 * XXX: we need to make sure that the addresses
			 * passed to pfr_update_stats() are the same than
			 * the addresses used during matching (pfr_match)
			 */
			if (r == &pf_default_rule) {
				tr = nr;
				x = (s == NULL || s->direction == dir) ?
				    &pd.baddr : &pd.naddr;
			} else
				x = (s == NULL || s->direction == dir) ?
				    &pd.naddr : &pd.baddr;
			if (x == &pd.baddr || s == NULL) {
				/* we need to change the address */
				if (dir == PF_OUT)
					pd.src = x;
				else
					pd.dst = x;
			}
		}
d5737 6
a5742 5
			pfr_update_stats(tr->src.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ?
			    pd.src : pd.dst, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->src.neg);
d5744 6
a5749 4
			pfr_update_stats(tr->dst.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.dst : pd.src, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->dst.neg);
d5834 1
a5834 1
	PF_ACPY(&pd.baddr, dir == PF_OUT ? pd.src : pd.dst, AF_INET6);
d5836 4
d6105 2
a6106 22
		if (nr != NULL) {
			struct pf_addr *x;
			/*
			 * XXX: we need to make sure that the addresses
			 * passed to pfr_update_stats() are the same than
			 * the addresses used during matching (pfr_match)
			 */
			if (r == &pf_default_rule) {
				tr = nr;
				x = (s == NULL || s->direction == dir) ?
				    &pd.baddr : &pd.naddr;
			} else {
				x = (s == NULL || s->direction == dir) ?
				    &pd.naddr : &pd.baddr;
			}
			if (x == &pd.baddr || s == NULL) {
				if (dir == PF_OUT)
					pd.src = x;
				else
					pd.dst = x;
			}
		}
d6108 5
a6112 4
			pfr_update_stats(tr->src.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.src : pd.dst, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->src.neg);
d6114 5
a6118 4
			pfr_update_stats(tr->dst.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.dst : pd.src, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->dst.neg);
@


1.575
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.574 2008/05/15 19:40:37 markus Exp $ */
d5 1
a5 1
 * Copyright (c) 2002,2003 Henning Brauer
d101 1
a101 2
struct pf_state_tree_lan_ext	 pf_statetbl_lan_ext;
struct pf_state_tree_ext_gwy	 pf_statetbl_ext_gwy;
d127 1
a127 1
struct pool		 pf_state_pl, pf_state_key_pl;
d166 2
a167 1
void			 pf_attach_state(struct pf_state_key *,
a168 1
void			 pf_detach_state(struct pf_state *, int);
d226 1
a226 1
void			 pf_stateins_err(const char *, struct pf_state *,
d291 1
a291 3
static __inline int pf_state_compare_lan_ext(struct pf_state_key *,
	struct pf_state_key *);
static __inline int pf_state_compare_ext_gwy(struct pf_state_key *,
d302 1
a302 4
RB_GENERATE(pf_state_tree_lan_ext, pf_state_key,
    entry_lan_ext, pf_state_compare_lan_ext);
RB_GENERATE(pf_state_tree_ext_gwy, pf_state_key,
    entry_ext_gwy, pf_state_compare_ext_gwy);
d306 1
a306 2
#define	PF_DT_SKIP_LANEXT	0x01
#define	PF_DT_SKIP_EXTGWY	0x02
a351 151
static __inline int
pf_state_compare_lan_ext(struct pf_state_key *a, struct pf_state_key *b)
{
	int	diff;

	if ((diff = a->proto - b->proto) != 0)
		return (diff);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->lan.addr.addr32[0] > b->lan.addr.addr32[0])
			return (1);
		if (a->lan.addr.addr32[0] < b->lan.addr.addr32[0])
			return (-1);
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->lan.addr.addr32[3] > b->lan.addr.addr32[3])
			return (1);
		if (a->lan.addr.addr32[3] < b->lan.addr.addr32[3])
			return (-1);
		if (a->ext.addr.addr32[3] > b->ext.addr.addr32[3])
			return (1);
		if (a->ext.addr.addr32[3] < b->ext.addr.addr32[3])
			return (-1);
		if (a->lan.addr.addr32[2] > b->lan.addr.addr32[2])
			return (1);
		if (a->lan.addr.addr32[2] < b->lan.addr.addr32[2])
			return (-1);
		if (a->ext.addr.addr32[2] > b->ext.addr.addr32[2])
			return (1);
		if (a->ext.addr.addr32[2] < b->ext.addr.addr32[2])
			return (-1);
		if (a->lan.addr.addr32[1] > b->lan.addr.addr32[1])
			return (1);
		if (a->lan.addr.addr32[1] < b->lan.addr.addr32[1])
			return (-1);
		if (a->ext.addr.addr32[1] > b->ext.addr.addr32[1])
			return (1);
		if (a->ext.addr.addr32[1] < b->ext.addr.addr32[1])
			return (-1);
		if (a->lan.addr.addr32[0] > b->lan.addr.addr32[0])
			return (1);
		if (a->lan.addr.addr32[0] < b->lan.addr.addr32[0])
			return (-1);
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}

	if ((diff = a->lan.port - b->lan.port) != 0)
		return (diff);
	if ((diff = a->ext.port - b->ext.port) != 0)
		return (diff);

	return (0);
}

static __inline int
pf_state_compare_ext_gwy(struct pf_state_key *a, struct pf_state_key *b)
{
	int	diff;

	if ((diff = a->proto - b->proto) != 0)
		return (diff);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		if (a->gwy.addr.addr32[0] > b->gwy.addr.addr32[0])
			return (1);
		if (a->gwy.addr.addr32[0] < b->gwy.addr.addr32[0])
			return (-1);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->ext.addr.addr32[3] > b->ext.addr.addr32[3])
			return (1);
		if (a->ext.addr.addr32[3] < b->ext.addr.addr32[3])
			return (-1);
		if (a->gwy.addr.addr32[3] > b->gwy.addr.addr32[3])
			return (1);
		if (a->gwy.addr.addr32[3] < b->gwy.addr.addr32[3])
			return (-1);
		if (a->ext.addr.addr32[2] > b->ext.addr.addr32[2])
			return (1);
		if (a->ext.addr.addr32[2] < b->ext.addr.addr32[2])
			return (-1);
		if (a->gwy.addr.addr32[2] > b->gwy.addr.addr32[2])
			return (1);
		if (a->gwy.addr.addr32[2] < b->gwy.addr.addr32[2])
			return (-1);
		if (a->ext.addr.addr32[1] > b->ext.addr.addr32[1])
			return (1);
		if (a->ext.addr.addr32[1] < b->ext.addr.addr32[1])
			return (-1);
		if (a->gwy.addr.addr32[1] > b->gwy.addr.addr32[1])
			return (1);
		if (a->gwy.addr.addr32[1] < b->gwy.addr.addr32[1])
			return (-1);
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		if (a->gwy.addr.addr32[0] > b->gwy.addr.addr32[0])
			return (1);
		if (a->gwy.addr.addr32[0] < b->gwy.addr.addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}

	if ((diff = a->ext.port - b->ext.port) != 0)
		return (diff);
	if ((diff = a->gwy.port - b->gwy.port) != 0)
		return (diff);

	return (0);
}

static __inline int
pf_state_compare_id(struct pf_state *a, struct pf_state *b)
{
	if (a->id > b->id)
		return (1);
	if (a->id < b->id)
		return (-1);
	if (a->creatorid > b->creatorid)
		return (1);
	if (a->creatorid < b->creatorid)
		return (-1);

	return (0);
}

a371 71
struct pf_state *
pf_find_state_byid(struct pf_state_cmp *key)
{
	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	return (RB_FIND(pf_state_tree_id, &tree_id, (struct pf_state *)key));
}

struct pf_state *
pf_find_state(struct pfi_kif *kif, struct pf_state_key_cmp *key, u_int dir)
{
	struct pf_state_key	*sk;
	struct pf_state		*s;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	switch (dir) {
	case PF_OUT:
		sk = RB_FIND(pf_state_tree_lan_ext, &pf_statetbl_lan_ext,
		    (struct pf_state_key *)key);
		break;
	case PF_IN:
		sk = RB_FIND(pf_state_tree_ext_gwy, &pf_statetbl_ext_gwy,
		    (struct pf_state_key *)key);
		break;
	default:
		panic("pf_find_state");
	}

	/* list is sorted, if-bound states before floating ones */
	if (sk != NULL)
		TAILQ_FOREACH(s, &sk->states, next)
			if (s->kif == pfi_all || s->kif == kif)
				return (s);

	return (NULL);
}

struct pf_state *
pf_find_state_all(struct pf_state_key_cmp *key, u_int dir, int *more)
{
	struct pf_state_key	*sk;
	struct pf_state		*s, *ret = NULL;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	switch (dir) {
	case PF_OUT:
		sk = RB_FIND(pf_state_tree_lan_ext,
		    &pf_statetbl_lan_ext, (struct pf_state_key *)key);
		break;
	case PF_IN:
		sk = RB_FIND(pf_state_tree_ext_gwy,
		    &pf_statetbl_ext_gwy, (struct pf_state_key *)key);
		break;
	default:
		panic("pf_find_state_all");
	}

	if (sk != NULL) {
		ret = TAILQ_FIRST(&sk->states);
		if (more == NULL)
			return (ret);

		TAILQ_FOREACH(s, &sk->states, next)
			(*more)++;
	}

	return (ret);
}

d435 1
a435 1
			    (*state)->state_key->af);
d439 2
a440 2
		p.pfra_af = (*state)->state_key->af;
		switch ((*state)->state_key->af) {
d465 1
a465 1
				sk = st->state_key;
d472 3
a474 3
				    (*state)->state_key->af &&
				    (((*state)->state_key->direction ==
					PF_OUT &&
d476 2
a477 2
					&sk->lan.addr, sk->af)) ||
				    ((*state)->state_key->direction == PF_IN &&
d479 1
a479 1
					&sk->ext.addr, sk->af))) &&
d567 1
a567 1
pf_stateins_err(const char *tree, struct pf_state *s, struct pfi_kif *kif)
a568 2
	struct pf_state_key	*sk = s->state_key;

d570 3
a572 6
		printf("pf: state insert failed: %s %s", tree, kif->pfik_name);
		printf(" lan: ");
		pf_print_host(&sk->lan.addr, sk->lan.port,
		    sk->af);
		printf(" gwy: ");
		pf_print_host(&sk->gwy.addr, sk->gwy.port,
d574 2
a575 2
		printf(" ext: ");
		pf_print_host(&sk->ext.addr, sk->ext.port,
a576 2
		if (s->sync_flags & PFSTATE_FROMSYNC)
			printf(" (from sync)");
d581 152
d734 2
a735 1
pf_insert_state(struct pfi_kif *kif, struct pf_state *s)
d738 1
a738 1
	struct pf_state		*sp;
a739 1
	KASSERT(s->state_key != NULL);
d742 1
a742 2
	if ((cur = RB_INSERT(pf_state_tree_lan_ext, &pf_statetbl_lan_ext,
	    s->state_key)) != NULL) {
d744 6
a749 5
		TAILQ_FOREACH(sp, &cur->states, next)
			if (sp->kif == kif) {	/* collision! */
				pf_stateins_err("tree_lan_ext", s, kif);
				pf_detach_state(s,
				    PF_DT_SKIP_LANEXT|PF_DT_SKIP_EXTGWY);
d752 3
a754 11
		pf_detach_state(s, PF_DT_SKIP_LANEXT|PF_DT_SKIP_EXTGWY);
		pf_attach_state(cur, s, kif == pfi_all ? 1 : 0);
	}

	/* if cur != NULL, we already found a state key and attached to it */
	if (cur == NULL && (cur = RB_INSERT(pf_state_tree_ext_gwy,
	    &pf_statetbl_ext_gwy, s->state_key)) != NULL) {
		/* must not happen. we must have found the sk above! */
		pf_stateins_err("tree_ext_gwy", s, kif);
		pf_detach_state(s, PF_DT_SKIP_EXTGWY);
		return (-1);
d778 1
d781 1
d785 52
d965 4
a968 3
		pf_send_tcp(cur->rule.ptr, cur->state_key->af,
		    &cur->state_key->ext.addr, &cur->state_key->lan.addr,
		    cur->state_key->ext.port, cur->state_key->lan.port,
d1155 1
a1155 1
	struct pf_state_key *sk = s->state_key;
d1173 1
a1173 1
	pf_print_host(&sk->lan.addr, sk->lan.port, sk->af);
d1175 2
a1176 1
	pf_print_host(&sk->gwy.addr, sk->gwy.port, sk->af);
d1178 2
a1179 1
	pf_print_host(&sk->ext.addr, sk->ext.port, sk->af);
d2257 1
d2274 3
a2276 3
		PF_ACPY(&key.ext.addr, daddr, key.af);
		PF_ACPY(&key.gwy.addr, naddr, key.af);
		key.ext.port = dport;
d2339 1
a2339 1

d2790 1
a2790 1
	switch (s->state_key->af) {
a2807 47
void
pf_attach_state(struct pf_state_key *sk, struct pf_state *s, int tail)
{
	s->state_key = sk;

	/* list is sorted, if-bound states before floating */
	if (tail)
		TAILQ_INSERT_TAIL(&sk->states, s, next);
	else
		TAILQ_INSERT_HEAD(&sk->states, s, next);
}

void
pf_detach_state(struct pf_state *s, int flags)
{
	struct pf_state_key	*sk = s->state_key;

	if (sk == NULL)
		return;

	s->state_key = NULL;
	TAILQ_REMOVE(&sk->states, s, next);
	if (TAILQ_EMPTY(&sk->states)) {
		if (!(flags & PF_DT_SKIP_EXTGWY))
			RB_REMOVE(pf_state_tree_ext_gwy,
			    &pf_statetbl_ext_gwy, sk);
		if (!(flags & PF_DT_SKIP_LANEXT))
			RB_REMOVE(pf_state_tree_lan_ext,
			    &pf_statetbl_lan_ext, sk);
		pool_put(&pf_state_key_pl, sk);
	}
}

struct pf_state_key *
pf_alloc_state_key(struct pf_state *s)
{
	struct pf_state_key	*sk;

	if ((sk = pool_get(&pf_state_key_pl, PR_NOWAIT)) == NULL)
		return (NULL);
	bzero(sk, sizeof(*sk));
	TAILQ_INIT(&sk->states);
	pf_attach_state(sk, s, 0);

	return (sk);
}

d3249 1
d3398 1
d3400 1
a3400 1
		if ((sk = pf_alloc_state_key(s)) == NULL) {
a3403 1

a3404 1
		sk->direction = direction;
d3406 3
a3408 3
		if (direction == PF_OUT) {
			PF_ACPY(&sk->gwy.addr, saddr, af);
			PF_ACPY(&sk->ext.addr, daddr, af);
d3414 2
a3415 2
				sk->gwy.port = nport;
				sk->ext.port = 0;
d3418 2
a3419 2
				sk->gwy.port = sport;
				sk->ext.port = dport;
d3422 1
a3422 5
				PF_ACPY(&sk->lan.addr, &pd->baddr, af);
				sk->lan.port = bport;
			} else {
				PF_ACPY(&sk->lan.addr, &sk->gwy.addr, af);
				sk->lan.port = sk->gwy.port;
d3425 2
a3426 2
			PF_ACPY(&sk->lan.addr, daddr, af);
			PF_ACPY(&sk->ext.addr, saddr, af);
d3432 2
a3433 2
				sk->lan.port = nport;
				sk->ext.port = 0;
d3436 2
a3437 2
				sk->lan.port = dport;
				sk->ext.port = sport;
d3440 1
a3440 5
				PF_ACPY(&sk->gwy.addr, &pd->baddr, af);
				sk->gwy.port = bport;
			} else {
				PF_ACPY(&sk->gwy.addr, &sk->lan.addr, af);
				sk->gwy.port = sk->lan.port;
d3444 1
d3447 1
a3447 1
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
d3602 10
a3611 10
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = th->th_sport;
		key.gwy.port = th->th_dport;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = th->th_sport;
		key.ext.port = th->th_dport;
d3616 1
a3616 1
	if (direction == (*state)->state_key->direction) {
d3625 1
a3625 1
		if (direction != (*state)->state_key->direction) {
d3654 1
a3654 10
		struct pf_state_host *src, *dst;

		if (direction == PF_OUT) {
			src = &(*state)->state_key->gwy;
			dst = &(*state)->state_key->ext;
		} else {
			src = &(*state)->state_key->ext;
			dst = &(*state)->state_key->lan;
		}
		if (direction == (*state)->state_key->direction) {
d3664 2
a3665 2
			pf_send_tcp((*state)->rule.ptr, pd->af, &src->addr,
			    &dst->addr, src->port, dst->port,
d3683 2
a3684 2
			pf_send_tcp((*state)->rule.ptr, pd->af, &src->addr,
			    &dst->addr, src->port, dst->port,
d3965 1
a3965 1
			    direction == (*state)->state_key->direction ?
d4021 1
a4021 1
			    direction == (*state)->state_key->direction ?
d4038 2
d4048 1
a4048 1
			    &th->th_sum, &(*state)->state_key->lan.addr,
d4050 6
a4056 4
	} else if (copyback) {
		/* Copyback sequence modulation or stateful scrub changes */
		m_copyback(m, off, sizeof(*th), th);
	}
d4071 10
a4080 10
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = uh->uh_sport;
		key.gwy.port = uh->uh_dport;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = uh->uh_sport;
		key.ext.port = uh->uh_dport;
d4085 1
a4085 1
	if (direction == (*state)->state_key->direction) {
d4106 1
d4115 1
a4115 1
			    &uh->uh_sum, &(*state)->state_key->lan.addr,
d4119 1
a4127 1
	struct pf_addr	*saddr = pd->src, *daddr = pd->dst;
d4171 10
a4180 10
		if (direction == PF_IN)	{
			PF_ACPY(&key.ext.addr, pd->src, key.af);
			PF_ACPY(&key.gwy.addr, pd->dst, key.af);
			key.ext.port = 0;
			key.gwy.port = icmpid;
		} else {
			PF_ACPY(&key.lan.addr, pd->src, key.af);
			PF_ACPY(&key.ext.addr, pd->dst, key.af);
			key.lan.port = icmpid;
			key.ext.port = 0;
d4188 1
d4225 1
a4225 1
					    (*state)->state_key->lan.addr.v4.s_addr, 0);
d4240 1
a4240 1
					    &(*state)->state_key->lan.addr, 0);
d4249 1
a4249 1

d4380 10
a4389 10
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = th.th_dport;
				key.gwy.port = th.th_sport;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = th.th_dport;
				key.ext.port = th.th_sport;
d4394 1
a4394 1
			if (direction == (*state)->state_key->direction) {
d4431 1
d4435 1
a4435 1
					    daddr, &(*state)->state_key->lan.addr,
d4448 1
a4448 1

d4488 10
a4497 10
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = uh.uh_dport;
				key.gwy.port = uh.uh_sport;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = uh.uh_dport;
				key.ext.port = uh.uh_sport;
d4501 1
a4501 1

d4506 1
a4506 1
					    &(*state)->state_key->lan.addr,
d4539 1
a4539 1

d4557 18
a4574 12
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = 0;
				key.gwy.port = iih.icmp_id;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = iih.icmp_id;
				key.ext.port = 0;
			}

d4577 1
d4582 1
a4582 1
					    &(*state)->state_key->lan.addr,
d4598 1
a4598 1

d4618 4
a4621 4
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = 0;
				key.gwy.port = iih.icmp6_id;
d4623 4
a4626 4
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = iih.icmp6_id;
				key.ext.port = 0;
d4631 1
d4636 1
a4636 1
					    &(*state)->state_key->lan.addr,
d4653 1
a4653 1

d4662 4
a4665 4
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = 0;
				key.gwy.port = 0;
d4667 4
a4670 4
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = 0;
				key.ext.port = 0;
d4675 1
d4680 1
a4680 1
					    &(*state)->state_key->lan.addr,
d4711 1
a4711 1

d4729 4
a4732 4
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = 0;
		key.gwy.port = 0;
d4734 4
a4737 4
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = 0;
		key.ext.port = 0;
d4742 1
a4742 1
	if (direction == (*state)->state_key->direction) {
d4763 1
d4789 1
a4789 1
				    (*state)->state_key->lan.addr.v4.s_addr,
d4796 1
a4796 1
				    &(*state)->state_key->lan.addr, pd->af);
d4801 1
a4801 1

a5420 1
	struct pf_state_key	*sk = NULL;
a5660 1
			sk = s->state_key;
d5673 1
a5673 1
			dirndx = (dir == sk->direction) ? 0 : 1;
d5688 1
a5688 1
				x = (sk == NULL || sk->direction == dir) ?
d5691 1
a5691 1
				x = (sk == NULL || sk->direction == dir) ?
d5702 2
a5703 2
			pfr_update_stats(tr->src.addr.p.tbl, (sk == NULL ||
			    sk->direction == dir) ?
d5708 2
a5709 2
			pfr_update_stats(tr->dst.addr.p.tbl, (sk == NULL ||
			    sk->direction == dir) ? pd.dst : pd.src, pd.af,
a5737 1
	struct pf_state_key	*sk = NULL;
a6044 1
			sk = s->state_key;
d6057 1
a6057 1
			dirndx = (dir == sk->direction) ? 0 : 1;
d6072 1
a6072 1
				x = (s == NULL || sk->direction == dir) ?
d6075 1
a6075 1
				x = (s == NULL || sk->direction == dir) ?
d6086 2
a6087 2
			pfr_update_stats(tr->src.addr.p.tbl, (sk == NULL ||
			    sk->direction == dir) ? pd.src : pd.dst, pd.af,
d6091 2
a6092 2
			pfr_update_stats(tr->dst.addr.p.tbl, (sk == NULL ||
			    sk->direction == dir) ? pd.dst : pd.src, pd.af,
@


1.574
log
@divert for ipv6; ok henning, pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.573 2008/05/09 02:44:54 markus Exp $ */
d534 1
a534 1
	
d703 1
a703 1
				        PF_OUT &&
d705 1
a705 1
				        &sk->lan.addr, sk->af)) ||
d708 1
a708 1
				        &sk->ext.addr, sk->af))) &&
d940 2
a941 2
	 struct pf_src_node		*cur, *next;
	 int				 locked = waslocked;
d943 2
a944 2
	 for (cur = RB_MIN(pf_src_tree, &tree_src_tracking); cur; cur = next) {
		 next = RB_NEXT(pf_src_tree, &tree_src_tracking, cur);
d946 19
a964 19
		 if (cur->states <= 0 && cur->expire <= time_second) {
			 if (! locked) {
				 rw_enter_write(&pf_consistency_lock);
			 	 next = RB_NEXT(pf_src_tree,
				     &tree_src_tracking, cur);
				 locked = 1;
			 }
			 if (cur->rule.ptr != NULL) {
				 cur->rule.ptr->src_nodes--;
				 if (cur->rule.ptr->states_cur <= 0 &&
				     cur->rule.ptr->max_src_nodes <= 0)
					 pf_rm_rule(NULL, cur->rule.ptr);
			 }
			 RB_REMOVE(pf_src_tree, &tree_src_tracking, cur);
			 pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
			 pf_status.src_nodes--;
			 pool_put(&pf_src_tree_pl, cur);
		 }
	 }
d966 1
a966 1
	 if (locked && !waslocked)
d1056 1
a1056 1
	int 			 locked = 0;
d5465 1
a5465 1
        struct m_tag    *mtag;
d5467 2
a5468 2
        if ((mtag = m_tag_find(m, PACKET_TAG_PF_DIVERT, NULL)) == NULL)
                return (NULL);
d5470 1
a5470 1
        return ((struct pf_divert *)(mtag + 1));
d5476 1
a5476 1
        struct m_tag    *mtag;
d5478 8
a5485 8
        if ((mtag = m_tag_find(m, PACKET_TAG_PF_DIVERT, NULL)) == NULL) {
                mtag = m_tag_get(PACKET_TAG_PF_DIVERT, sizeof(struct pf_divert),
                    M_NOWAIT);
                if (mtag == NULL)
                        return (NULL);
                bzero(mtag + 1, sizeof(struct pf_divert));
                m_tag_prepend(m, mtag);
        }
d5487 1
a5487 1
        return ((struct pf_divert *)(mtag + 1));
@


1.573
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.572 2008/05/07 07:07:29 markus Exp $ */
d2669 2
a2670 1
			inp = in6_pcblookup_listen(tb, &daddr->v6, dport, 0);
@


1.572
log
@scrub packets based on tags; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.571 2008/05/07 06:15:26 markus Exp $ */
d221 1
d2657 2
a2658 1
			inp = in_pcblookup_listen(tb, daddr->v4, dport, 0);
d5461 28
d5707 10
d6092 10
@


1.571
log
@backout last change, it's already there....
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.569 2008/05/06 03:45:21 mpf Exp $ */
a189 1
int			 pf_match_tag(struct mbuf *, struct pf_rule *, int *);
@


1.570
log
@Kill state if we get SYN for a state that has been closed from both sides.
ok henning@@
@
text
@a3814 16
	if (((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN) &&
	    dst->state >= TCPS_FIN_WAIT_2 &&
	    src->state >= TCPS_FIN_WAIT_2) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state reuse ");
			pf_print_state(*state);
			pf_print_flags(th->th_flags);
			printf("\n");
		}
		/* XXX make sure it's the same direction ?? */
		(*state)->src.state = (*state)->dst.state = TCPS_CLOSED;
		pf_unlink_state(*state);
		*state = NULL;
		return (PF_DROP);
	}

@


1.569
log
@Add a counter to record how many states have been created by a rule.
It shows up in pfctl verbose mode and in the 7th field of the labels
output.  Also remove the label printing for scrub rules, as they
do not support labels.
OK dhartmei@@ (on an earlier version), henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.568 2008/05/05 13:00:43 henning Exp $ */
d3797 16
@


1.568
log
@remove a useless refcnt in pf_state_key.
when it is in fact only used to delete the state key when the number of
attached states (in a tailq) drops to zero, we can as well test for the
queue beeing empty.
this is a leftover from some early version that did things differently.
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.567 2008/02/20 23:40:13 henning Exp $ */
d270 10
a279 5
		s->rule.ptr->states++;			\
		if (s->anchor.ptr != NULL)		\
			s->anchor.ptr->states++;	\
		if (s->nat_rule.ptr != NULL)		\
			s->nat_rule.ptr->states++;	\
d285 1
a285 1
			s->nat_rule.ptr->states--;	\
d287 2
a288 2
			s->anchor.ptr->states--;	\
		s->rule.ptr->states--;			\
d921 1
a921 1
		states = state->rule.ptr->states;
d955 1
a955 1
				 if (cur->rule.ptr->states <= 0 &&
d1031 1
a1031 1
	if (--cur->rule.ptr->states <= 0 &&
d1035 1
a1035 1
		if (--cur->nat_rule.ptr->states <= 0 &&
d1039 1
a1039 1
		if (--cur->anchor.ptr->states <= 0)
d3336 1
a3336 1
		if (r->max_states && (r->states >= r->max_states)) {
@


1.567
log
@make return-rst work correctly in the IPv6 case again.
broken by me almost a year ago with the proto_checksum changes :(
problem noticed & fix tested by Helmut Schneider <jumper99@@gmx.de>
narrowed down & ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.566 2008/02/16 12:22:19 markus Exp $ */
a2838 1
	sk->refcnt++;
d2857 1
a2857 1
	if (--sk->refcnt == 0) {
@


1.567.2.1
log
@Avoid dereferencing a null pointer when pf attempts to translate a
specifically crafted IP datagram.

Problem noted by Sebastian Rother.

fix from jsing. ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.567 2008/02/20 23:40:13 henning Exp $ */
a5622 9
#ifdef INET6
	case IPPROTO_ICMPV6: {
		action = PF_DROP;
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping IPv4 packet with ICMPv6 payload\n"));
		goto done;
	}
#endif

a5971 7
	}

	case IPPROTO_ICMP: {
		action = PF_DROP;
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping IPv6 packet with ICMPv4 payload\n"));
		goto done;
@


1.566
log
@switch to RFC 1948 style ISN, too; ok mcbride, dhartmei, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.565 2007/11/22 02:01:46 henning Exp $ */
d3279 3
a3281 1
			struct ip	*h = mtod(m, struct ip *);
d3283 12
a3294 2
			if (pf_check_proto_cksum(m, off,
			    ntohs(h->ip_len) - off, IPPROTO_TCP, AF_INET))
@


1.565
log
@pf_src_tree_remove_state() is called upon pf_insert_state() failures.
but pf_insert_state does fiddle with the state's state_key pointer - it
has too -, and can leave it at NULL. pf_src_tree_remove_state()
tried to grab the protocol from it. fortunately that is superfluous here,
since tcp_est will never be set in the non-tcp case - it is only touched
in pf_src_connlimit which in turn is only ever called from pf_test_tcp().
ok mcbride + identical diff from pascoe, but he was a few minutes late :)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.564 2007/11/18 21:53:47 deraadt Exp $ */
d54 2
d115 5
d170 1
d2883 28
d3378 3
a3380 3
				while ((s->src.seqdiff =
				    tcp_rndiss_next() - s->src.seqlo) == 0)
					;
d3825 2
a3826 1
			while ((src->seqdiff = tcp_rndiss_next() - seq) == 0)
@


1.564
log
@backout 1.562 since it triggers the problem described in pr 5648
please close the pr after another solution is found for both problems
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.561 2007/10/31 21:15:27 mpf Exp $ */
d819 2
d963 2
a964 4
		if (s->state_key->proto == IPPROTO_TCP) {
			if (s->src.tcp_est)
				--s->src_node->conn;
		}
@


1.563
log
@in pf_test_fragment(), ignore protocol-specific criteria for packets of
different protocols. from Max Laier. ok markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.562 2007/11/11 23:58:43 pascoe Exp $ */
a818 1
				pf_detach_state(s, PF_DT_SKIP_LANEXT|PF_DT_SKIP_EXTGWY);
@


1.562
log
@Don't leak pfstatekey upon insert conflict (most often caused via pfsync).

tested david@@, ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.561 2007/10/31 21:15:27 mpf Exp $ */
d3566 11
a3576 3
		else if (r->src.port_op || r->dst.port_op ||
		    r->flagset || r->type || r->code ||
		    r->os_fingerprint != PF_OSFP_ANY)
@


1.561
log
@'block return' must not send anything on blocked icmp packets.
Noticed by Kai_Doernemann_at_genua.de
OK henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.560 2007/10/25 21:36:21 mpf Exp $ */
d819 1
@


1.560
log
@Fix probability rules w/ numbers (e.g probability 0.4).
Add support for probablities of 0% and 100%.
With and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.559 2007/09/18 18:45:59 markus Exp $ */
d3258 2
a3259 1
		} else if ((af == AF_INET) && r->return_icmp)
d3262 2
a3263 1
		else if ((af == AF_INET6) && r->return_icmp6)
@


1.559
log
@allow state reuse for tcp if both sides are in FIN_WAIT_2 and a new SYN
arrives; ok dhartmei, henning, feedback aaron
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.558 2007/09/07 20:34:10 bluhm Exp $ */
d3116 2
a3117 1
		else if (r->prob && r->prob <= arc4random())
d3567 2
a3568 1
		else if (r->prob && r->prob <= arc4random())
@


1.558
log
@Do not recalculate TCP payload length in pf_test_rule() as it has
been cached in pd->p_len.
ok henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.557 2007/08/30 13:07:06 henning Exp $ */
d3733 16
@


1.557
log
@mechanic change:
there is a 1:1 mapping between direction and the tree the states get
attached to. there is no need to have anything outside the state insertion/
deletion/lookup routinbes know about these internals. so just pass the
direction to the lookup functions and let them pick the right tree.
ok dhartmei markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.556 2007/08/30 10:43:43 dhartmei Exp $ */
a3275 1
		u_int16_t	 len;
a3333 1
			len = pd->tot_len - off - (th->th_off << 2);
d3335 1
a3335 1
			s->src.seqhi = s->src.seqlo + len + 1;
@


1.556
log
@handle address ranges in skip step calculation
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.555 2007/08/30 09:28:48 dhartmei Exp $ */
d217 1
a217 1
			    struct pf_state_key_cmp *, u_int8_t);
d236 1
a236 4
		if (direction == PF_IN)					\
			*state = pf_find_state(kif, &key, PF_EXT_GWY);	\
		else							\
			*state = pf_find_state(kif, &key, PF_LAN_EXT);	\
d526 1
a526 1
pf_find_state(struct pfi_kif *kif, struct pf_state_key_cmp *key, u_int8_t tree)
d533 2
a534 2
	switch (tree) {
	case PF_LAN_EXT:
d538 1
a538 1
	case PF_EXT_GWY:
d556 1
a556 1
pf_find_state_all(struct pf_state_key_cmp *key, u_int8_t tree, int *more)
d563 2
a564 2
	switch (tree) {
	case PF_LAN_EXT:
d568 1
a568 1
	case PF_EXT_GWY:
d2306 1
a2306 1
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL)
d2310 1
a2310 1
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL)
d2314 1
a2314 1
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL) {
d2331 1
a2331 1
				if (pf_find_state_all(&key, PF_EXT_GWY, NULL) ==
d2339 1
a2339 1
				if (pf_find_state_all(&key, PF_EXT_GWY, NULL) ==
@


1.555
log
@add support for address ranges ("from 10.1.2.50 - 10.1.3.75") in from/to
criteria. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.554 2007/08/28 16:09:12 henning Exp $ */
d1298 1
@


1.554
log
@showing this diff is shameful...

        if (r != NULL && r->rtableid >= 0)
-               m->m_pkthdr.pf.rtableid = m->m_pkthdr.pf.rtableid;
+               m->m_pkthdr.pf.rtableid = r->rtableid;

fortunately it is in pf_send_tcp and thus the effect is very limited, RSTs
sent due to "block return(-rst)" could be routed using the main routing
table instead of an alternate one specified on the block rule.
spotted by Janjaap van Velthooven <janjaap@@stack.nl>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.553 2007/08/23 11:15:49 dhartmei Exp $ */
d1791 38
@


1.553
log
@allow RSTs with th_seq == seqlo +- 1, reduces the amount of 'loose state'
messages, add 'dir=' part to 'loose state' message, ok henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.550 2007/07/10 15:58:37 kurt Exp $ */
d1601 1
a1601 1
		m->m_pkthdr.pf.rtableid = m->m_pkthdr.pf.rtableid;
@


1.552
log
@don't access th_flags when it isn't available (only 8 bytes of the
header are required in the ICMP error). ok deraadt@@, henning@@
@
text
@d3845 2
a3846 1
	    (orig_seq == src->seqlo + 1) || (pd->flags & PFDESC_IP_REAS) == 0)) {
d3941 6
a3946 3
			    "pkts=%llu:%llu\n", seq, orig_seq, ack, pd->p_len,
			    ackskew, (*state)->packets[0],
			    (*state)->packets[1]);
@


1.552.2.1
log
@MFC: rev 1.565 (me)
fix a memory leak
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.565 2007/11/22 02:01:46 henning Exp $ */
a821 2
				pf_detach_state(s,
				    PF_DT_SKIP_LANEXT|PF_DT_SKIP_EXTGWY);
d964 4
a967 2
		if (s->src.tcp_est)
			--s->src_node->conn;
@


1.551
log
@Don't drop outgoing packets in case of a congested input queue.
OK markus@@, mcbride@@, "sounds reasonable" henning@@
@
text
@d4372 1
a4372 2
			if (src->wscale && dst->wscale &&
			    !(th.th_flags & TH_SYN))
@


1.550
log
@adjust pf_find_state_all() so that it works correctly for the new global
table/state tail queue design. corrects ftp-proxy errors "server lookup
failed (no rdr?)" okay henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.549 2007/07/04 08:14:14 mpf Exp $ */
d2863 1
a2863 1
	if (pf_check_congestion(ifq)) {
@


1.549
log
@No m_copyback for ICMP and "other" protocols on rdr/binat.
Fixes ICMP packet payload corruption on rdr.

OK henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.548 2007/06/25 13:57:18 henning Exp $ */
a562 1
	struct pfi_kif		*kif;
d568 2
a569 12
		TAILQ_FOREACH(kif, &pfi_statehead, pfik_w_states) {
			sk = RB_FIND(pf_state_tree_lan_ext,
			    &pf_statetbl_lan_ext, (struct pf_state_key *)key);
			if (sk == NULL)
				continue;
			ret = TAILQ_FIRST(&sk->states);
			if (more == NULL)
				return (ret);
			else
				TAILQ_FOREACH(s, &sk->states, next)
					(*more)++;
		}
d572 2
a573 12
		TAILQ_FOREACH(kif, &pfi_statehead, pfik_w_states) {
			sk = RB_FIND(pf_state_tree_ext_gwy,
			    &pf_statetbl_ext_gwy, (struct pf_state_key *)key);
			if (sk == NULL)
				continue;
			ret = TAILQ_FIRST(&sk->states);
			if (more == NULL)
				return (ret);
			else
				TAILQ_FOREACH(s, &sk->states, next)
					(*more)++;
		}
d577 9
@


1.548
log
@pretty mechanical change: now that the state tables use seperate state
keys that can map to multiple states (last not least for ifbound) we don't
need state tables hanging off each struct kif representing an interface
any more. use two globals for the two tables. ok markus ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.547 2007/06/24 11:17:13 mcbride Exp $ */
a2897 1
		hdrlen = sizeof(*pd->hdr.icmp);
a3036 1
			rewrite++;
@


1.547
log
@Save some bytes and make code more readable by removing junk union and
unused ifname (this information is in struct pf_state_sync now).

Also a bit of KNF on the pf_state struct.

ok mpf@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.546 2007/06/21 11:55:54 henning Exp $ */
d98 4
d538 1
a538 1
		sk = RB_FIND(pf_state_tree_lan_ext, &pfi_all->pfik_lan_ext,
d542 1
a542 1
		sk = RB_FIND(pf_state_tree_ext_gwy, &pfi_all->pfik_ext_gwy,
d571 1
a571 1
			    &pfi_all->pfik_lan_ext, (struct pf_state_key *)key);
d585 1
a585 1
			    &pfi_all->pfik_ext_gwy, (struct pf_state_key *)key);
d828 1
a828 1
	if ((cur = RB_INSERT(pf_state_tree_lan_ext, &pfi_all->pfik_lan_ext,
d842 1
a842 1
	    &pfi_all->pfik_ext_gwy, s->state_key)) != NULL) {
d2829 1
a2829 1
			    &pfi_all->pfik_ext_gwy, sk);
d2832 1
a2832 1
			    &pfi_all->pfik_lan_ext, sk);
@


1.546
log
@reimplement interface bound states in a non-retarded way.
previously, we had a set of state tables attached to each interface. so for
every packet we had to do a lookup in the tables for the interface, and
afterwards in the global tables.
since we split state keys and states now, use only the global tables, and
put the actual states in a tail queue attached to the state key. sort the
list so that ifbound states come before global ones. on lookup, we only
have to compare the interface pointer on the actual states and use the
first one where either the interface matches or the state is not interface
bound. thus, if you don't actually use ifbound states, and there is only
one state per state key, the overhead is close to zero, where we had extra
lookups before. in addition to a much cleaner design (that'll allow for more
goodies later) this gives us ~12.5% more forwarding performance.
mostly hacked at c2k7, lots of help, testing and ok mcbride & markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.545 2007/06/20 14:14:17 mpf Exp $ */
d548 1
a548 1
			if (s->u.s.kif == pfi_all || s->u.s.kif == kif)
d822 1
a822 1
	s->u.s.kif = kif;
d828 1
a828 1
			if (sp->u.s.kif == kif) {	/* collision! */
d861 1
a861 1
	TAILQ_INSERT_TAIL(&state_list, s, u.s.entry_list);
d1040 2
a1041 2
	pfi_kif_unref(cur->u.s.kif, PFI_KIF_REF_STATE);
	TAILQ_REMOVE(&state_list, cur, u.s.entry_list);
d1065 1
a1065 1
		next = TAILQ_NEXT(cur, u.s.entry_list);
@


1.545
log
@Allow "log" for nat rules without "pass".
OK henning@@, ``passt scho'' markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.544 2007/06/15 08:18:59 henning Exp $ */
d156 3
d212 1
a212 1
struct pf_state		*pf_find_state_recurse(struct pfi_kif *,
d215 2
d233 1
a233 2
			*state = pf_find_state_recurse(			\
			    kif, &key, PF_EXT_GWY);			\
d235 1
a235 2
			*state = pf_find_state_recurse(			\
			    kif, &key, PF_LAN_EXT);			\
d298 3
d525 1
a525 2
pf_find_state_recurse(struct pfi_kif *kif, struct pf_state_key_cmp *key,
    u_int8_t tree)
d527 2
a528 1
	struct pf_state_key *sk;
d534 3
a536 7
		if ((sk = RB_FIND(pf_state_tree_lan_ext, &kif->pfik_lan_ext,
		    (struct pf_state_key *)key)) != NULL)
			return (sk->state);
		if ((sk = RB_FIND(pf_state_tree_lan_ext, &pfi_all->pfik_lan_ext,
		    (struct pf_state_key *)key)) != NULL)
			return (sk->state);
		return (NULL);
d538 3
a540 7
		if ((sk = RB_FIND(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy,
		    (struct pf_state_key *)key)) != NULL)
			return (sk->state);
		if ((sk = RB_FIND(pf_state_tree_ext_gwy, &pfi_all->pfik_ext_gwy,
		    (struct pf_state_key *)key)) != NULL)
			return (sk->state);
		return (NULL);
d542 1
a542 1
		panic("pf_find_state_recurse");
d544 8
d557 2
a558 1
	struct pf_state_key	*sk, *sks = NULL;
d567 1
a567 1
			    &kif->pfik_lan_ext, (struct pf_state_key *)key);
d570 1
d572 4
a575 3
				return (sk->state);
			sks = sk;
			(*more)++;
d581 1
a581 1
			    &kif->pfik_ext_gwy, (struct pf_state_key *)key);
d584 1
d586 4
a589 3
				return (sk->state);
			sks = sk;
			(*more)++;
d595 2
a596 4
	if (sks != NULL)
		return (sks->state);
	else
		return (NULL);
d793 22
d818 2
a819 1
	struct pf_state_key *sk;
d822 1
a822 1
	sk = s->state_key;
d824 10
a833 19
	/* Thou MUST NOT insert multiple duplicate keys */
	s->u.s.kif = kif;
	if (RB_INSERT(pf_state_tree_lan_ext, &kif->pfik_lan_ext, sk)) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: tree_lan_ext");
			printf(" lan: ");
			pf_print_host(&sk->lan.addr, sk->lan.port,
			    sk->af);
			printf(" gwy: ");
			pf_print_host(&sk->gwy.addr, sk->gwy.port,
			    sk->af);
			printf(" ext: ");
			pf_print_host(&sk->ext.addr, sk->ext.port,
			    sk->af);
			if (s->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
			printf("\n");
		}
		return (-1);
d836 6
a841 17
	if (RB_INSERT(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy, sk)) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: tree_ext_gwy");
			printf(" lan: ");
			pf_print_host(&sk->lan.addr, sk->lan.port,
			    sk->af);
			printf(" gwy: ");
			pf_print_host(&sk->gwy.addr, sk->gwy.port,
			    sk->af);
			printf(" ext: ");
			pf_print_host(&sk->ext.addr, sk->ext.port,
			    sk->af);
			if (s->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
			printf("\n");
		}
		RB_REMOVE(pf_state_tree_lan_ext, &kif->pfik_lan_ext, sk);
d858 1
a858 2
		RB_REMOVE(pf_state_tree_lan_ext, &kif->pfik_lan_ext, sk);
		RB_REMOVE(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy, sk);
a1006 4
	RB_REMOVE(pf_state_tree_ext_gwy,
	    &cur->u.s.kif->pfik_ext_gwy, cur->state_key);
	RB_REMOVE(pf_state_tree_lan_ext,
	    &cur->u.s.kif->pfik_lan_ext, cur->state_key);
d1014 1
a1043 1
	pool_put(&pf_state_key_pl, cur->state_key);
d2799 34
d2841 2
a2842 2
	sk->state = s;
	s->state_key = sk;
@


1.544
log
@in pf_test_rule, before handling IPPROTO_ICMP / IPPROTO_ICMPV6, check that
the packet is of the expected address family (AF_INET / AF_INET6).
crafted IPv4 packets with IPPROTO_ICMPV6 can make us crash otherwise.
misbehaviour provoked by Adrian Close <adrian@@close.wattle.id.au> playing
with nmap; he also helped us big time debugging the problem. thanks!
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.543 2007/06/09 18:30:47 henning Exp $ */
d3085 1
a3085 1
	if (r->log || (nr != NULL && nr->natpass && nr->log)) {
@


1.543
log
@fix wrong argument passing to m_copyback for the log case
(&ptr instead of ptr). should fix pflog breakage seen by bob
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.542 2007/06/09 16:32:00 henning Exp $ */
d2835 2
d2850 2
d2867 2
a2880 3
	default:
		sport = dport = hdrlen = 0;
		break;
@


1.542
log
@sizeof(ptr) is no good if you want sizeof(*ptr). icmp/icmpv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.541 2007/06/02 01:28:55 henning Exp $ */
d3084 1
a3084 1
			m_copyback(m, off, hdrlen, &pd->hdr.any);
@


1.541
log
@pf_set_rt_ifp accesses state key data, so must be called later
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.540 2007/06/01 18:44:22 henning Exp $ */
d2849 1
a2849 1
		hdrlen = sizeof(pd->hdr.icmp);
d2864 1
a2864 1
		hdrlen = sizeof(pd->hdr.icmp6);
@


1.540
log
@factor out duplicated code to allocate state key and cross-reference it
with a state entry into a new pf_alloc_state_key() function and use it
everywhere. makes upcoming changes way easier and is cleaner anyway.
conceptually agreed by ryan, but he's on the road now ;(
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.539 2007/06/01 18:01:59 henning Exp $ */
a3319 1
		pf_set_rt_ifp(s, saddr);
d3407 2
@


1.539
log
@fold pf_test_tcp(), pf_test_udp(), pf_test_icmp(), pf_test_other() into
one - pf_test_rule(). now we have one place to make things clearer and
maybe find another few performance bits :)
shrinks i386 GENERIC by 11K, no measurable performance impact or gain.
lots lots lots lots lots of testing and headbanging with ryan,
performance testing ckuethe. ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.538 2007/06/01 00:52:38 henning Exp $ */
d2792 14
a3231 6
		/* state key */
		sk = pool_get(&pf_state_key_pl, PR_NOWAIT);
		if (sk == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
			goto cleanup;
		}
a3254 3
		bzero(sk, sizeof(*sk));
		sk->state = s;
		s->state_key = sk;
a3262 49
		sk->proto = pd->proto;
		sk->direction = direction;
		sk->af = af;
		if (direction == PF_OUT) {
			PF_ACPY(&sk->gwy.addr, saddr, af);
			PF_ACPY(&sk->ext.addr, daddr, af);
			switch (pd->proto) {
			case IPPROTO_ICMP:
#ifdef INET6
			case IPPROTO_ICMPV6:
#endif
				sk->gwy.port = nport;
				sk->ext.port = 0;
				break;
			default:
				sk->gwy.port = sport;
				sk->ext.port = dport;
			}
			if (nr != NULL) {
				PF_ACPY(&sk->lan.addr, &pd->baddr, af);
				sk->lan.port = bport;
			} else {
				PF_ACPY(&sk->lan.addr, &sk->gwy.addr, af);
				sk->lan.port = sk->gwy.port;
			}
		} else {
			PF_ACPY(&sk->lan.addr, daddr, af);
			PF_ACPY(&sk->ext.addr, saddr, af);
			switch (pd->proto) {
			case IPPROTO_ICMP:
#ifdef INET6
			case IPPROTO_ICMPV6:
#endif
				sk->lan.port = nport;
				sk->ext.port = 0;
				break;
			default:
				sk->lan.port = dport;
				sk->ext.port = sport;
			}
			if (nr != NULL) {
				PF_ACPY(&sk->gwy.addr, &pd->baddr, af);
				sk->gwy.port = bport;
			} else {
				PF_ACPY(&sk->gwy.addr, &sk->lan.addr, af);
				sk->gwy.port = sk->lan.port;
			}
		}

d3354 55
@


1.538
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.537 2007/05/31 18:48:05 mcbride Exp $ */
d156 1
a156 1
int			 pf_test_tcp(struct pf_rule **, struct pf_state **,
a159 12
int			 pf_test_udp(struct pf_rule **, struct pf_state **,
			    int, struct pfi_kif *, struct mbuf *, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **, struct ifqueue *);
int			 pf_test_icmp(struct pf_rule **, struct pf_state **,
			    int, struct pfi_kif *, struct mbuf *, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **, struct ifqueue *);
int			 pf_test_other(struct pf_rule **, struct pf_state **,
			    int, struct pfi_kif *, struct mbuf *, int, void *,
			    struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **, struct ifqueue *);
d2793 1
a2793 1
pf_test_tcp(struct pf_rule **rm, struct pf_state **sm, int direction,
a2799 1
	struct tcphdr		*th = pd->hdr.tcp;
d2805 1
d2807 1
a2807 1
	int			 rewrite = 0;
a2808 1
	u_int16_t		 mss = tcp_mssdflt;
d2811 4
d2821 45
d2869 1
a2869 1
		bport = nport = th->th_sport;
d2872 1
a2872 2
		    saddr, th->th_sport, daddr, th->th_dport,
		    &pd->naddr, &nport)) != NULL) {
d2874 48
a2921 3
			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &pd->naddr, nport, 0, af);
			rewrite++;
d2927 1
a2927 1
		bport = nport = th->th_dport;
d2930 1
a2930 2
		    saddr, th->th_sport, daddr, th->th_dport,
		    &pd->naddr, &nport)) != NULL) {
d2932 44
a2975 2
			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &pd->naddr, nport, 0, af);
d2991 1
a2991 1
		else if (r->proto && r->proto != IPPROTO_TCP)
d2996 1
d2998 1
a2998 1
		    r->src.port[0], r->src.port[1], th->th_sport))
d3003 1
d3005 1
a3005 1
		    r->dst.port[0], r->dst.port[1], th->th_dport))
d3007 6
d3017 2
a3018 1
		else if ((r->flagset & th->th_flags) != r->flags)
d3020 1
d3026 1
d3036 4
a3039 2
		else if (r->os_fingerprint != PF_OSFP_ANY && !pf_osfp_match(
		    pf_osfp_fingerprint(pd, m, off, th), r->os_fingerprint))
d3070 1
a3070 1
			m_copyback(m, off, sizeof(*th), th);
d3082 34
a3115 3
				pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
				    &th->th_sum, &pd->baddr, bport, 0, af);
				rewrite++;
d3117 34
a3150 3
				pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
				    &th->th_sum, &pd->baddr, bport, 0, af);
				rewrite++;
d3153 2
a3154 1
		if (((r->rule_flag & PFRULE_RETURNRST) ||
d3189 2
a3190 2
	if (r->keep_state || nr != NULL ||
	    (pd->flags & PFDESC_TCP_NORM)) {
a3196 2
		len = pd->tot_len - off - (th->th_off << 2);

d3258 1
a3258 1
		sk->proto = IPPROTO_TCP;
a3262 1
			sk->gwy.port = th->th_sport;		/* sport */
d3264 12
a3275 1
			sk->ext.port = th->th_dport;
a3284 1
			sk->lan.port = th->th_dport;
d3286 12
a3297 1
			sk->ext.port = th->th_sport;
d3307 52
a3358 16
		s->src.seqlo = ntohl(th->th_seq);
		s->src.seqhi = s->src.seqlo + len + 1;
		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
		    r->keep_state == PF_STATE_MODULATE) {
			/* Generate sequence number modulator */
			while ((s->src.seqdiff =
			    tcp_rndiss_next() - s->src.seqlo) == 0)
				;
			pf_change_a(&th->th_seq, &th->th_sum,
			    htonl(s->src.seqlo + s->src.seqdiff), 0);
			rewrite = 1;
		} else
			s->src.seqdiff = 0;
		if (th->th_flags & TH_SYN) {
			s->src.seqhi++;
			s->src.wscale = pf_get_wscale(m, off, th->th_off, af);
d3360 1
a3360 14
		s->src.max_win = MAX(ntohs(th->th_win), 1);
		if (s->src.wscale & PF_WSCALE_MASK) {
			/* Remove scale factor from initial window */
			int win = s->src.max_win;
			win += 1 << (s->src.wscale & PF_WSCALE_MASK);
			s->src.max_win = (win - 1) >>
			    (s->src.wscale & PF_WSCALE_MASK);
		}
		if (th->th_flags & TH_FIN)
			s->src.seqhi++;
		s->dst.seqhi = 1;
		s->dst.max_win = 1;
		s->src.state = TCPS_SYN_SENT;
		s->dst.state = TCPS_CLOSED;
d3363 1
a3363 1
		s->timeout = PFTM_TCP_FIRST_PACKET;
d3374 23
a3396 19
		if ((pd->flags & PFDESC_TCP_NORM) && pf_normalize_tcp_init(m,
		    off, pd, th, &s->src, &s->dst)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pf_src_tree_remove_state(s);
			STATE_DEC_COUNTERS(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
		if ((pd->flags & PFDESC_TCP_NORM) && s->src.scrub &&
		    pf_normalize_tcp_stateful(m, off, pd, &reason, th, s,
		    &s->src, &s->dst, &rewrite)) {
			/* This really shouldn't happen!!! */
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf_normalize_tcp_stateful failed on first pkt"));
			pf_normalize_tcp_cleanup(s);
			pf_src_tree_remove_state(s);
			STATE_DEC_COUNTERS(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
d3399 2
a3400 1
			pf_normalize_tcp_cleanup(s);
d3412 2
a3413 1
		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
d3421 1
d3426 1
d3445 1
a3445 906
		m_copyback(m, off, sizeof(*th), th);

	return (PF_PASS);
}

int
pf_test_udp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
{
	struct pf_rule		*nr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct udphdr		*uh = pd->hdr.udp;
	u_int16_t		 bport, nport = 0;
	sa_family_t		 af = pd->af;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_src_node	*nsn = NULL;
	u_short			 reason;
	int			 rewrite = 0;
	int			 tag = -1, rtableid = -1;
	int			 asd = 0;
	int			 match = 0;

	if (pf_check_congestion(ifq)) {
		REASON_SET(&reason, PFRES_CONGEST);
		return (PF_DROP);
	}

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

	if (direction == PF_OUT) {
		bport = nport = uh->uh_sport;
		/* check outgoing packet for BINAT/NAT */
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
		    saddr, uh->uh_sport, daddr, uh->uh_dport,
		    &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &pd->naddr, nport, 1, af);
			rewrite++;
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	} else {
		bport = nport = uh->uh_dport;
		/* check incoming packet for BINAT/RDR */
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, uh->uh_sport, daddr, uh->uh_dport, &pd->naddr,
		    &nport)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &pd->naddr, nport, 1, af);
			rewrite++;
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	}

	while (r != NULL) {
		r->evaluations++;
		if (pfi_kif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != IPPROTO_UDP)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af,
		    r->src.neg, kif))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (r->src.port_op && !pf_match_port(r->src.port_op,
		    r->src.port[0], r->src.port[1], uh->uh_sport))
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af,
		    r->dst.neg, NULL))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
		    r->dst.port[0], r->dst.port[1], uh->uh_dport))
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else if (r->tos && !(r->tos == pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if (r->uid.op && (pd->lookup.done || (pd->lookup.done =
		    pf_socket_lookup(direction, pd), 1)) &&
		    !pf_match_uid(r->uid.op, r->uid.uid[0], r->uid.uid[1],
		    pd->lookup.uid))
			r = TAILQ_NEXT(r, entries);
		else if (r->gid.op && (pd->lookup.done || (pd->lookup.done =
		    pf_socket_lookup(direction, pd), 1)) &&
		    !pf_match_gid(r->gid.op, r->gid.gid[0], r->gid.gid[1],
		    pd->lookup.gid))
			r = TAILQ_NEXT(r, entries);
		else if (r->prob && r->prob <= arc4random())
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag && !pf_match_tag(m, r, &tag))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->rtableid >= 0)
				rtableid = r->rtableid;
			if (r->anchor == NULL) {
				match = 1;
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				pf_step_into_anchor(&asd, &ruleset,
				    PF_RULESET_FILTER, &r, &a, &match);
		}
		if (r == NULL && pf_step_out_of_anchor(&asd, &ruleset,
		    PF_RULESET_FILTER, &r, &a, &match))
			break;
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&reason, PFRES_MATCH);

	if (r->log || (nr != NULL && nr->natpass && nr->log)) {
		if (rewrite)
			m_copyback(m, off, sizeof(*uh), uh);
		PFLOG_PACKET(kif, h, m, af, direction, reason, r->log ? r : nr,
		    a, ruleset, pd);
	}

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		/* undo NAT changes, if they have taken place */
		if (nr != NULL) {
			if (direction == PF_OUT) {
				pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
				    &uh->uh_sum, &pd->baddr, bport, 1, af);
				rewrite++;
			} else {
				pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
				    &uh->uh_sum, &pd->baddr, bport, 1, af);
				rewrite++;
			}
		}
		if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
	}

	if (r->action == PF_DROP)
		return (PF_DROP);

	if (pf_tag_packet(m, tag, rtableid)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

	if (r->keep_state || nr != NULL) {
		/* create new state */
		struct pf_state	*s = NULL;
		struct pf_state_key *sk = NULL;
		struct pf_src_node *sn = NULL;

		/* check maximums */
		if (r->max_states && (r->states >= r->max_states)) {
			pf_status.lcounters[LCNT_STATES]++;
			REASON_SET(&reason, PFRES_MAXSTATES);
			goto cleanup;
		}
		/* src node for filter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0) {
			REASON_SET(&reason, PFRES_SRCLIMIT);
			goto cleanup;
		}
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0))) {
			REASON_SET(&reason, PFRES_SRCLIMIT);
			goto cleanup;
		}
		/* state key */
		sk = pool_get(&pf_state_key_pl, PR_NOWAIT);
		if (sk == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
			goto cleanup;
		}
		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			if (sk != NULL) {
				pool_put(&pf_state_key_pl, sk);
			}
			return (PF_DROP);
		}
		bzero(s, sizeof(*s));
		bzero(sk, sizeof(*sk));
		sk->state = s;
		s->state_key = sk;
		s->rule.ptr = r;
		s->nat_rule.ptr = nr;
		s->anchor.ptr = a;
		STATE_INC_COUNTERS(s);
		s->allow_opts = r->allow_opts;
		s->log = r->log & PF_LOG_ALL;
		if (nr != NULL)
			s->log |= nr->log & PF_LOG_ALL;
		sk->proto = IPPROTO_UDP;
		sk->direction = direction;
		sk->af = af;
		if (direction == PF_OUT) {
			PF_ACPY(&sk->gwy.addr, saddr, af);
			sk->gwy.port = uh->uh_sport;
			PF_ACPY(&sk->ext.addr, daddr, af);
			sk->ext.port = uh->uh_dport;
			if (nr != NULL) {
				PF_ACPY(&sk->lan.addr, &pd->baddr, af);
				sk->lan.port = bport;
			} else {
				PF_ACPY(&sk->lan.addr, &sk->gwy.addr, af);
				sk->lan.port = sk->gwy.port;
			}
		} else {
			PF_ACPY(&sk->lan.addr, daddr, af);
			sk->lan.port = uh->uh_dport;
			PF_ACPY(&sk->ext.addr, saddr, af);
			sk->ext.port = uh->uh_sport;
			if (nr != NULL) {
				PF_ACPY(&sk->gwy.addr, &pd->baddr, af);
				sk->gwy.port = bport;
			} else {
				PF_ACPY(&sk->gwy.addr, &sk->lan.addr, af);
				sk->gwy.port = sk->lan.port;
			}
		}
		s->src.state = PFUDPS_SINGLE;
		s->dst.state = PFUDPS_NO_TRAFFIC;
		s->creation = time_second;
		s->expire = time_second;
		s->timeout = PFTM_UDP_FIRST_PACKET;
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
			REASON_SET(&reason, PFRES_STATEINS);
			pf_src_tree_remove_state(s);
			STATE_DEC_COUNTERS(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
		if (tag > 0) {
			pf_tag_ref(tag);
			s->tag = tag;
		}
	}

	/* copy back packet headers if we performed NAT operations */
	if (rewrite)
		m_copyback(m, off, sizeof(*uh), uh);

	return (PF_PASS);
}

int
pf_test_icmp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
{
	struct pf_rule		*nr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_src_node	*nsn = NULL;
	u_short			 reason;
	u_int16_t		 icmpid, bport, nport = 0;
	sa_family_t		 af = pd->af;
	u_int8_t		 icmptype, icmpcode;
	int			 state_icmp = 0;
	int			 tag = -1, rtableid = -1;
#ifdef INET6
	int			 rewrite = 0;
#endif /* INET6 */
	int			 asd = 0;
	int			 match = 0;

	if (pf_check_congestion(ifq)) {
		REASON_SET(&reason, PFRES_CONGEST);
		return (PF_DROP);
	}

	switch (pd->proto) {
#ifdef INET
	case IPPROTO_ICMP:
		icmptype = pd->hdr.icmp->icmp_type;
		icmpcode = pd->hdr.icmp->icmp_code;
		icmpid = pd->hdr.icmp->icmp_id;

		if (icmptype == ICMP_UNREACH ||
		    icmptype == ICMP_SOURCEQUENCH ||
		    icmptype == ICMP_REDIRECT ||
		    icmptype == ICMP_TIMXCEED ||
		    icmptype == ICMP_PARAMPROB)
			state_icmp++;
		break;
#endif /* INET */
#ifdef INET6
	case IPPROTO_ICMPV6:
		icmptype = pd->hdr.icmp6->icmp6_type;
		icmpcode = pd->hdr.icmp6->icmp6_code;
		icmpid = pd->hdr.icmp6->icmp6_id;

		if (icmptype == ICMP6_DST_UNREACH ||
		    icmptype == ICMP6_PACKET_TOO_BIG ||
		    icmptype == ICMP6_TIME_EXCEEDED ||
		    icmptype == ICMP6_PARAM_PROB)
			state_icmp++;
		break;
#endif /* INET6 */
	}

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

	if (direction == PF_OUT) {
		bport = nport = icmpid;
		/* check outgoing packet for BINAT/NAT */
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
		    saddr, icmpid, daddr, icmpid, &pd->naddr, &nport)) !=
		    NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&saddr->v4.s_addr, pd->ip_sum,
				    pd->naddr.v4.s_addr, 0);
				pd->hdr.icmp->icmp_cksum = pf_cksum_fixup(
				    pd->hdr.icmp->icmp_cksum, icmpid, nport, 0);
				pd->hdr.icmp->icmp_id = nport;
				m_copyback(m, off, ICMP_MINLEN, pd->hdr.icmp);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				pf_change_a6(saddr, &pd->hdr.icmp6->icmp6_cksum,
				    &pd->naddr, 0);
				rewrite++;
				break;
#endif /* INET6 */
			}
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	} else {
		bport = nport = icmpid;
		/* check incoming packet for BINAT/RDR */
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, icmpid, daddr, icmpid, &pd->naddr, &nport)) !=
		    NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&daddr->v4.s_addr,
				    pd->ip_sum, pd->naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				pf_change_a6(daddr, &pd->hdr.icmp6->icmp6_cksum,
				    &pd->naddr, 0);
				rewrite++;
				break;
#endif /* INET6 */
			}
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	}

	while (r != NULL) {
		r->evaluations++;
		if (pfi_kif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af,
		    r->src.neg, kif))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af,
		    r->dst.neg, NULL))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->type && r->type != icmptype + 1)
			r = TAILQ_NEXT(r, entries);
		else if (r->code && r->code != icmpcode + 1)
			r = TAILQ_NEXT(r, entries);
		else if (r->tos && !(r->tos == pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if (r->prob && r->prob <= arc4random())
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag && !pf_match_tag(m, r, &tag))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->rtableid >= 0)
				rtableid = r->rtableid;
			if (r->anchor == NULL) {
				match = 1;
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				pf_step_into_anchor(&asd, &ruleset,
				    PF_RULESET_FILTER, &r, &a, &match);
		}
		if (r == NULL && pf_step_out_of_anchor(&asd, &ruleset,
		    PF_RULESET_FILTER, &r, &a, &match))
			break;
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&reason, PFRES_MATCH);

	if (r->log || (nr != NULL && nr->natpass && nr->log)) {
#ifdef INET6
		if (rewrite)
			m_copyback(m, off, sizeof(struct icmp6_hdr),
			    pd->hdr.icmp6);
#endif /* INET6 */
		PFLOG_PACKET(kif, h, m, af, direction, reason, r->log ? r : nr,
		    a, ruleset, pd);
	}

	if (r->action != PF_PASS)
		return (PF_DROP);

	if (pf_tag_packet(m, tag, rtableid)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

	if (!state_icmp && (r->keep_state || nr != NULL)) {
		/* create new state */
		struct pf_state	*s = NULL;
		struct pf_state_key *sk = NULL;
		struct pf_src_node *sn = NULL;

		/* check maximums */
		if (r->max_states && (r->states >= r->max_states)) {
			pf_status.lcounters[LCNT_STATES]++;
			REASON_SET(&reason, PFRES_MAXSTATES);
			goto cleanup;
		}
		/* src node for filter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0) {
			REASON_SET(&reason, PFRES_SRCLIMIT);
			goto cleanup;
		}
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0))) {
			REASON_SET(&reason, PFRES_SRCLIMIT);
			goto cleanup;
		}
		/* state key */
		sk = pool_get(&pf_state_key_pl, PR_NOWAIT);
		if (sk == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
			goto cleanup;
		}
		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			if (sk != NULL) {
				pool_put(&pf_state_key_pl, sk);
			}
			return (PF_DROP);
		}
		bzero(s, sizeof(*s));
		bzero(sk, sizeof(*sk));
		sk->state = s;
		s->state_key = sk;
		s->rule.ptr = r;
		s->nat_rule.ptr = nr;
		s->anchor.ptr = a;
		STATE_INC_COUNTERS(s);
		s->allow_opts = r->allow_opts;
		s->log = r->log & PF_LOG_ALL;
		if (nr != NULL)
			s->log |= nr->log & PF_LOG_ALL;
		sk->proto = pd->proto;
		sk->direction = direction;
		sk->af = af;
		if (direction == PF_OUT) {
			PF_ACPY(&sk->gwy.addr, saddr, af);
			sk->gwy.port = nport;
			PF_ACPY(&sk->ext.addr, daddr, af);
			sk->ext.port = 0;
			if (nr != NULL) {
				PF_ACPY(&sk->lan.addr, &pd->baddr, af);
				sk->lan.port = bport;
			} else {
				PF_ACPY(&sk->lan.addr, &sk->gwy.addr, af);
				sk->lan.port = sk->gwy.port;
			}
		} else {
			PF_ACPY(&sk->lan.addr, daddr, af);
			sk->lan.port = nport;
			PF_ACPY(&sk->ext.addr, saddr, af);
			sk->ext.port = 0; 
			if (nr != NULL) {
				PF_ACPY(&sk->gwy.addr, &pd->baddr, af);
				sk->gwy.port = bport;
			} else {
				PF_ACPY(&sk->gwy.addr, &sk->lan.addr, af);
				sk->gwy.port = sk->lan.port;
			}
		}
		s->creation = time_second;
		s->expire = time_second;
		s->timeout = PFTM_ICMP_FIRST_PACKET;
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
			REASON_SET(&reason, PFRES_STATEINS);
			pf_src_tree_remove_state(s);
			STATE_DEC_COUNTERS(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
		if (tag > 0) {
			pf_tag_ref(tag);
			s->tag = tag;
		}
	}

#ifdef INET6
	/* copy back packet headers if we performed IPv6 NAT operations */
	if (rewrite)
		m_copyback(m, off, sizeof(struct icmp6_hdr),
		    pd->hdr.icmp6);
#endif /* INET6 */

	return (PF_PASS);
}

int
pf_test_other(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct pfi_kif *kif, struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
    struct pf_rule **am, struct pf_ruleset **rsm, struct ifqueue *ifq)
{
	struct pf_rule		*nr = NULL;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_src_node	*nsn = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	sa_family_t		 af = pd->af;
	u_short			 reason;
	int			 tag = -1, rtableid = -1;
	int			 asd = 0;
	int			 match = 0;

	if (pf_check_congestion(ifq)) {
		REASON_SET(&reason, PFRES_CONGEST);
		return (PF_DROP);
	}

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

	if (direction == PF_OUT) {
		/* check outgoing packet for BINAT/NAT */
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&saddr->v4.s_addr, pd->ip_sum,
				    pd->naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(saddr, &pd->naddr, af);
				break;
#endif /* INET6 */
			}
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	} else {
		/* check incoming packet for BINAT/RDR */
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&daddr->v4.s_addr,
				    pd->ip_sum, pd->naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(daddr, &pd->naddr, af);
				break;
#endif /* INET6 */
			}
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	}

	while (r != NULL) {
		r->evaluations++;
		if (pfi_kif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af,
		    r->src.neg, kif))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af,
		    r->dst.neg, NULL))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->tos && !(r->tos == pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if (r->prob && r->prob <= arc4random())
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag && !pf_match_tag(m, r, &tag))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->rtableid >= 0)
				rtableid = r->rtableid;
			if (r->anchor == NULL) {
				match = 1;
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				pf_step_into_anchor(&asd, &ruleset,
				    PF_RULESET_FILTER, &r, &a, &match);
		}
		if (r == NULL && pf_step_out_of_anchor(&asd, &ruleset,
		    PF_RULESET_FILTER, &r, &a, &match))
			break;
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&reason, PFRES_MATCH);

	if (r->log || (nr != NULL && nr->natpass && nr->log))
		PFLOG_PACKET(kif, h, m, af, direction, reason, r->log ? r : nr,
		    a, ruleset, pd);

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		struct pf_addr *a = NULL;

		if (nr != NULL) {
			if (direction == PF_OUT)
				a = saddr;
			else
				a = daddr;
		}
		if (a != NULL) {
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&a->v4.s_addr, pd->ip_sum,
				    pd->baddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(a, &pd->baddr, af);
				break;
#endif /* INET6 */
			}
		}
		if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
	}

	if (r->action != PF_PASS)
		return (PF_DROP);

	if (pf_tag_packet(m, tag, rtableid)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

	if (r->keep_state || nr != NULL) {
		/* create new state */
		struct pf_state	*s = NULL;
		struct pf_state_key *sk = NULL;
		struct pf_src_node *sn = NULL;

		/* check maximums */
		if (r->max_states && (r->states >= r->max_states)) {
			pf_status.lcounters[LCNT_STATES]++;
			REASON_SET(&reason, PFRES_MAXSTATES);
			goto cleanup;
		}
		/* src node for filter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0) {
			REASON_SET(&reason, PFRES_SRCLIMIT);
			goto cleanup;
		}
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0))) {
			REASON_SET(&reason, PFRES_SRCLIMIT);
			goto cleanup;
		}
		/* state key */
		sk = pool_get(&pf_state_key_pl, PR_NOWAIT);
		if (sk == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
			goto cleanup;
		}
		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			if (sk != NULL) {
				pool_put(&pf_state_key_pl, sk);
			}
			return (PF_DROP);
		}
		bzero(s, sizeof(*s));
		bzero(sk, sizeof(*sk));
		sk->state = s;
		s->state_key = sk;
		s->rule.ptr = r;
		s->nat_rule.ptr = nr;
		s->anchor.ptr = a;
		STATE_INC_COUNTERS(s);
		s->allow_opts = r->allow_opts;
		s->log = r->log & PF_LOG_ALL;
		if (nr != NULL)
			s->log |= nr->log & PF_LOG_ALL;
		sk->proto = pd->proto;
		sk->direction = direction;
		sk->af = af;
		if (direction == PF_OUT) {
			PF_ACPY(&sk->gwy.addr, saddr, af);
			PF_ACPY(&sk->ext.addr, daddr, af);
			if (nr != NULL)
				PF_ACPY(&sk->lan.addr, &pd->baddr, af);
			else
				PF_ACPY(&sk->lan.addr, &sk->gwy.addr, af);
		} else {
			PF_ACPY(&sk->lan.addr, daddr, af);
			PF_ACPY(&sk->ext.addr, saddr, af);
			if (nr != NULL)
				PF_ACPY(&sk->gwy.addr, &pd->baddr, af);
			else
				PF_ACPY(&sk->gwy.addr, &sk->lan.addr, af);
		}
		s->src.state = PFOTHERS_SINGLE;
		s->dst.state = PFOTHERS_NO_TRAFFIC;
		s->creation = time_second;
		s->expire = time_second;
		s->timeout = PFTM_OTHER_FIRST_PACKET;
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
			REASON_SET(&reason, PFRES_STATEINS);
			pf_src_tree_remove_state(s);
			STATE_DEC_COUNTERS(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
		if (tag > 0) {
			pf_tag_ref(tag);
			s->tag = tag;
		}
	}
d5404 1
a5404 1
			action = pf_test_tcp(&r, &s, dir, kif,
d5434 1
a5434 1
			action = pf_test_udp(&r, &s, dir, kif,
d5458 1
a5458 1
			action = pf_test_icmp(&r, &s, dir, kif,
d5473 1
a5473 1
			action = pf_test_other(&r, &s, dir, kif, m, off, h,
d5779 1
a5779 1
			action = pf_test_tcp(&r, &s, dir, kif,
d5809 1
a5809 1
			action = pf_test_udp(&r, &s, dir, kif,
d5833 1
a5833 1
			action = pf_test_icmp(&r, &s, dir, kif,
d5848 1
a5848 1
			action = pf_test_other(&r, &s, dir, kif, m, off, h,
@


1.537
log
@Move the state id and creatorid (used mainly by pfsync) into struct pf_state.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.536 2007/05/31 06:22:40 mcbride Exp $ */
d1720 1
a1720 1
		ip6_output(m, NULL, NULL, 0, NULL, NULL);
d5798 1
a5798 1
		ip6_output(m0, NULL, NULL, 0, NULL, NULL);
@


1.536
log
@Unbreak pf.c compilation on gcc 2.95 architectures. Found by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.535 2007/05/31 04:11:42 mcbride Exp $ */
d291 2
a292 2
static __inline int pf_state_compare_id(struct pf_state_key *,
	struct pf_state_key *);
d301 1
a301 1
    u.s.entry_lan_ext, pf_state_compare_lan_ext);
d303 3
a305 3
    u.s.entry_ext_gwy, pf_state_compare_ext_gwy);
RB_GENERATE(pf_state_tree_id, pf_state_key,
    u.s.entry_id, pf_state_compare_id);
d488 1
a488 1
pf_state_compare_id(struct pf_state_key *a, struct pf_state_key *b)
d523 1
a523 1
pf_find_state_byid(struct pf_state_key_cmp *key)
a524 1
	struct pf_state_key *sk;
d527 1
a527 2
	sk = RB_FIND(pf_state_tree_id, &tree_id, (struct pf_state_key *)key);
	return (sk ? sk->state : NULL);
a634 1
	struct pf_state_key *sk;
d690 3
d694 2
a695 2

			RB_FOREACH(sk, pf_state_tree_id, &tree_id) {
d712 3
a714 5
				    (*state)->rule.ptr ==
				    sk->state->rule.ptr)) {
					sk->state->timeout = PFTM_PURGE;
					sk->state->src.state =
					    sk->state->dst.state =
d845 3
a847 3
	if (sk->id == 0 && sk->creatorid == 0) {
		sk->id = htobe64(pf_status.stateid++);
		sk->creatorid = pf_status.hostid;
d849 1
a849 1
	if (RB_INSERT(pf_state_tree_id, &tree_id, sk) != NULL) {
d853 1
a853 1
			    betoh64(sk->id), ntohl(sk->creatorid));
d1012 1
a1012 1
	RB_REMOVE(pf_state_tree_id, &tree_id, cur->state_key);
d1014 1
a1014 1
	if (cur->state_key->creatorid == pf_status.hostid)
@


1.535
log
@First step of rearranging pf's state table internals...

- Split pf_state into pf_state (used for tracking connection information),
  and pf_state_key (used for searching the state table)

- Use pfsync_state in the ioctl for userland access to the state
  table. This will sheild userland somewhat from future changes.

ok henning@@ toby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.534 2007/05/29 00:50:41 henning Exp $ */
d801 2
d804 1
a806 1
	struct pf_state_key *sk = s->state_key;
@


1.534
log
@gain us another 10+% of performance.
boring details:
long time ago (in r1.313) code was added to handle protocol checksums:
> Check protocol (TCP/UDP/ICMP/ICMP6) checksums of all incoming packets,
> and drop packets with invalid checksums. Without such a check, pf would
> return RST/ICMP errors even for packets with invalid checksums, which
> could be used to detect the presence of the firewall, reported by
> "Ed White" in http://www.phrack.org/phrack/60/p60-0x0c.txt.
that meant we did the checksumming for each and every packet traversing pf.
now only do the checksumming right before we send an RST back, so in all
other cases we save that work.
ok bob theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.533 2007/05/28 17:16:39 henning Exp $ */
d116 3
a118 2
struct pool		 pf_src_tree_pl, pf_rule_pl;
struct pool		 pf_state_pl, pf_altq_pl, pf_pooladdr_pl;
d222 1
a222 1
			    struct pf_state_cmp *, u_int8_t);
d257 7
a263 7
#define	STATE_TRANSLATE(s) \
	(s)->lan.addr.addr32[0] != (s)->gwy.addr.addr32[0] || \
	((s)->af == AF_INET6 && \
	((s)->lan.addr.addr32[1] != (s)->gwy.addr.addr32[1] || \
	(s)->lan.addr.addr32[2] != (s)->gwy.addr.addr32[2] || \
	(s)->lan.addr.addr32[3] != (s)->gwy.addr.addr32[3])) || \
	(s)->lan.port != (s)->gwy.port
d287 6
a292 6
static __inline int pf_state_compare_lan_ext(struct pf_state *,
	struct pf_state *);
static __inline int pf_state_compare_ext_gwy(struct pf_state *,
	struct pf_state *);
static __inline int pf_state_compare_id(struct pf_state *,
	struct pf_state *);
d300 1
a300 1
RB_GENERATE(pf_state_tree_lan_ext, pf_state,
d302 1
a302 1
RB_GENERATE(pf_state_tree_ext_gwy, pf_state,
d304 1
a304 1
RB_GENERATE(pf_state_tree_id, pf_state,
d352 1
a352 1
pf_state_compare_lan_ext(struct pf_state *a, struct pf_state *b)
d420 1
a420 1
pf_state_compare_ext_gwy(struct pf_state *a, struct pf_state *b)
d488 1
a488 1
pf_state_compare_id(struct pf_state *a, struct pf_state *b)
d523 1
a523 1
pf_find_state_byid(struct pf_state_cmp *key)
d525 1
d527 3
a529 1
	return (RB_FIND(pf_state_tree_id, &tree_id, (struct pf_state *)key));
d533 2
a534 1
pf_find_state_recurse(struct pfi_kif *kif, struct pf_state_cmp *key, u_int8_t tree)
d536 1
a536 1
	struct pf_state *s;
d542 6
a547 6
		if ((s = RB_FIND(pf_state_tree_lan_ext, &kif->pfik_lan_ext,
		    (struct pf_state *)key)) != NULL)
			return (s);
		if ((s = RB_FIND(pf_state_tree_lan_ext, &pfi_all->pfik_lan_ext,
		    (struct pf_state *)key)) != NULL)
			return (s);
d550 6
a555 6
		if ((s = RB_FIND(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy,
		    (struct pf_state *)key)) != NULL)
			return (s);
		if ((s = RB_FIND(pf_state_tree_ext_gwy, &pfi_all->pfik_ext_gwy,
		    (struct pf_state *)key)) != NULL)
			return (s);
d563 1
a563 1
pf_find_state_all(struct pf_state_cmp *key, u_int8_t tree, int *more)
d565 2
a566 2
	struct pf_state *s, *ss = NULL;
	struct pfi_kif	*kif;
d573 3
a575 3
			s = RB_FIND(pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext, (struct pf_state *)key);
			if (s == NULL)
d578 2
a579 2
				return (s);
			ss = s;
d582 1
a582 1
		return (ss);
d585 3
a587 3
			s = RB_FIND(pf_state_tree_ext_gwy,
			    &kif->pfik_ext_gwy, (struct pf_state *)key);
			if (s == NULL)
d590 2
a591 2
				return (s);
			ss = s;
d594 1
a594 1
		return (ss);
d598 4
d637 1
a637 1
	struct pf_state	*s;
d668 1
a668 1
			    (*state)->af);
d672 2
a673 2
		p.pfra_af = (*state)->af;
		switch ((*state)->af) {
d695 1
a695 1
			RB_FOREACH(s, pf_state_tree_id, &tree_id) {
d701 4
a704 2
				if (s->af == (*state)->af &&
				    (((*state)->direction == PF_OUT &&
d706 2
a707 2
				    &s->lan.addr, s->af)) ||
				    ((*state)->direction == PF_IN &&
d709 1
a709 1
				    &s->ext.addr, s->af))) &&
d712 5
a716 3
				    (*state)->rule.ptr == s->rule.ptr)) {
					s->timeout = PFTM_PURGE;
					s->src.state = s->dst.state =
d799 1
a799 1
pf_insert_state(struct pfi_kif *kif, struct pf_state *state)
d801 2
d804 3
a806 2
	state->u.s.kif = kif;
	if (RB_INSERT(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state)) {
d810 2
a811 2
			pf_print_host(&state->lan.addr, state->lan.port,
			    state->af);
d813 2
a814 2
			pf_print_host(&state->gwy.addr, state->gwy.port,
			    state->af);
d816 3
a818 3
			pf_print_host(&state->ext.addr, state->ext.port,
			    state->af);
			if (state->sync_flags & PFSTATE_FROMSYNC)
d825 1
a825 1
	if (RB_INSERT(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy, state)) {
d829 2
a830 2
			pf_print_host(&state->lan.addr, state->lan.port,
			    state->af);
d832 2
a833 2
			pf_print_host(&state->gwy.addr, state->gwy.port,
			    state->af);
d835 3
a837 3
			pf_print_host(&state->ext.addr, state->ext.port,
			    state->af);
			if (state->sync_flags & PFSTATE_FROMSYNC)
d841 1
a841 1
		RB_REMOVE(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state);
d845 3
a847 3
	if (state->id == 0 && state->creatorid == 0) {
		state->id = htobe64(pf_status.stateid++);
		state->creatorid = pf_status.hostid;
d849 1
a849 1
	if (RB_INSERT(pf_state_tree_id, &tree_id, state) != NULL) {
d853 2
a854 2
			    betoh64(state->id), ntohl(state->creatorid));
			if (state->sync_flags & PFSTATE_FROMSYNC)
d858 2
a859 2
		RB_REMOVE(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state);
		RB_REMOVE(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy, state);
d862 1
a862 1
	TAILQ_INSERT_TAIL(&state_list, state, u.s.entry_list);
d867 1
a867 1
	pfsync_insert_state(state);
d973 1
a973 1
		if (s->proto == IPPROTO_TCP) {
d1002 3
a1004 3
		pf_send_tcp(cur->rule.ptr, cur->af,
		    &cur->ext.addr, &cur->lan.addr,
		    cur->ext.port, cur->lan.port,
d1009 1
a1009 1
	    &cur->u.s.kif->pfik_ext_gwy, cur);
d1011 2
a1012 2
	    &cur->u.s.kif->pfik_lan_ext, cur);
	RB_REMOVE(pf_state_tree_id, &tree_id, cur);
d1014 1
a1014 1
	if (cur->creatorid == pf_status.hostid)
d1048 1
d1195 2
a1196 1
	switch (s->proto) {
d1210 1
a1210 1
		printf("%u ", s->proto);
d1213 1
a1213 1
	pf_print_host(&s->lan.addr, s->lan.port, s->af);
d1215 1
a1215 1
	pf_print_host(&s->gwy.addr, s->gwy.port, s->af);
d1217 1
a1217 1
	pf_print_host(&s->ext.addr, s->ext.port, s->af);
d2256 1
a2256 1
	struct pf_state_cmp	key;
d2786 1
a2786 1
	switch (s->af) {
d2997 1
d3023 6
d3046 3
d3052 3
d3063 3
a3065 3
		s->proto = IPPROTO_TCP;
		s->direction = direction;
		s->af = af;
d3067 4
a3070 4
			PF_ACPY(&s->gwy.addr, saddr, af);
			s->gwy.port = th->th_sport;		/* sport */
			PF_ACPY(&s->ext.addr, daddr, af);
			s->ext.port = th->th_dport;
d3072 2
a3073 2
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
				s->lan.port = bport;
d3075 2
a3076 2
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
				s->lan.port = s->gwy.port;
d3079 4
a3082 4
			PF_ACPY(&s->lan.addr, daddr, af);
			s->lan.port = th->th_dport;
			PF_ACPY(&s->ext.addr, saddr, af);
			s->ext.port = th->th_sport;
d3084 2
a3085 2
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
				s->gwy.port = bport;
d3087 2
a3088 2
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
				s->gwy.port = s->lan.port;
d3371 1
d3395 6
d3418 3
d3424 3
d3435 3
a3437 3
		s->proto = IPPROTO_UDP;
		s->direction = direction;
		s->af = af;
d3439 4
a3442 4
			PF_ACPY(&s->gwy.addr, saddr, af);
			s->gwy.port = uh->uh_sport;
			PF_ACPY(&s->ext.addr, daddr, af);
			s->ext.port = uh->uh_dport;
d3444 2
a3445 2
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
				s->lan.port = bport;
d3447 2
a3448 2
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
				s->lan.port = s->gwy.port;
d3451 4
a3454 4
			PF_ACPY(&s->lan.addr, daddr, af);
			s->lan.port = uh->uh_dport;
			PF_ACPY(&s->ext.addr, saddr, af);
			s->ext.port = uh->uh_sport;
d3456 2
a3457 2
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
				s->gwy.port = bport;
d3459 2
a3460 2
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
				s->gwy.port = s->lan.port;
d3695 1
d3719 6
d3742 3
d3748 3
d3759 3
a3761 3
		s->proto = pd->proto;
		s->direction = direction;
		s->af = af;
d3763 4
a3766 4
			PF_ACPY(&s->gwy.addr, saddr, af);
			s->gwy.port = nport;
			PF_ACPY(&s->ext.addr, daddr, af);
			s->ext.port = 0;
d3768 2
a3769 2
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
				s->lan.port = bport;
d3771 2
a3772 2
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
				s->lan.port = s->gwy.port;
d3775 4
a3778 4
			PF_ACPY(&s->lan.addr, daddr, af);
			s->lan.port = nport;
			PF_ACPY(&s->ext.addr, saddr, af);
			s->ext.port = 0; 
d3780 2
a3781 2
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
				s->gwy.port = bport;
d3783 2
a3784 2
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
				s->gwy.port = s->lan.port;
d3995 1
d4019 6
d4042 3
d4048 3
d4059 3
a4061 3
		s->proto = pd->proto;
		s->direction = direction;
		s->af = af;
d4063 2
a4064 2
			PF_ACPY(&s->gwy.addr, saddr, af);
			PF_ACPY(&s->ext.addr, daddr, af);
d4066 1
a4066 1
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
d4068 1
a4068 1
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
d4070 2
a4071 2
			PF_ACPY(&s->lan.addr, daddr, af);
			PF_ACPY(&s->ext.addr, saddr, af);
d4073 1
a4073 1
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
d4075 1
a4075 1
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
d4192 1
a4192 1
	struct pf_state_cmp	 key;
d4217 1
a4217 1
	if (direction == (*state)->direction) {
d4226 1
a4226 1
		if (direction != (*state)->direction) {
d4258 2
a4259 2
			src = &(*state)->gwy;
			dst = &(*state)->ext;
d4261 2
a4262 2
			src = &(*state)->ext;
			dst = &(*state)->lan;
d4264 1
a4264 1
		if (direction == (*state)->direction) {
d4610 2
a4611 1
			    direction == (*state)->direction ? "fwd" : "rev");
d4628 1
a4628 1
	if (STATE_TRANSLATE(*state)) {
d4631 2
a4632 2
			    &th->th_sum, &(*state)->gwy.addr,
			    (*state)->gwy.port, 0, pd->af);
d4635 2
a4636 2
			    &th->th_sum, &(*state)->lan.addr,
			    (*state)->lan.port, 0, pd->af);
d4651 1
a4651 1
	struct pf_state_cmp	 key;
d4670 1
a4670 1
	if (direction == (*state)->direction) {
d4692 1
a4692 1
	if (STATE_TRANSLATE(*state)) {
d4695 2
a4696 2
			    &uh->uh_sum, &(*state)->gwy.addr,
			    (*state)->gwy.port, 1, pd->af);
d4699 2
a4700 2
			    &uh->uh_sum, &(*state)->lan.addr,
			    (*state)->lan.port, 1, pd->af);
d4715 1
a4715 1
	struct pf_state_cmp key;
d4773 1
a4773 1
		if (STATE_TRANSLATE(*state)) {
d4780 1
a4780 1
					    (*state)->gwy.addr.v4.s_addr, 0);
d4784 1
a4784 1
					    (*state)->gwy.port, 0);
d4786 1
a4786 1
					    (*state)->gwy.port;
d4795 1
a4795 1
					    &(*state)->gwy.addr, 0);
d4808 1
a4808 1
					    (*state)->lan.addr.v4.s_addr, 0);
d4812 1
a4812 1
					    (*state)->lan.port, 0);
d4814 1
a4814 1
					    (*state)->lan.port;
d4823 1
a4823 1
					    &(*state)->lan.addr, 0);
d4977 1
a4977 1
			if (direction == (*state)->direction) {
d5015 1
a5015 1
			if (STATE_TRANSLATE(*state)) {
d5018 2
a5019 2
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, NULL,
d5024 2
a5025 2
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, NULL,
d5085 1
a5085 1
			if (STATE_TRANSLATE(*state)) {
d5088 4
a5091 2
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, &uh.uh_sum,
d5096 3
a5098 2
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, &uh.uh_sum,
d5154 1
a5154 1
			if (STATE_TRANSLATE(*state)) {
d5157 3
a5159 2
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, NULL,
d5164 3
a5166 2
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, NULL,
d5207 1
a5207 1
			if (STATE_TRANSLATE(*state)) {
d5210 3
a5212 2
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, NULL,
d5217 2
a5218 2
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, NULL,
d5250 1
a5250 1
			if (STATE_TRANSLATE(*state)) {
d5253 2
a5254 1
					    daddr, &(*state)->lan.addr,
d5260 2
a5261 1
					    saddr, &(*state)->gwy.addr,
d5298 1
a5298 1
	struct pf_state_cmp	 key;
d5316 1
a5316 1
	if (direction == (*state)->direction) {
d5338 1
a5338 1
	if (STATE_TRANSLATE(*state)) {
d5344 2
a5345 1
				    pd->ip_sum, (*state)->gwy.addr.v4.s_addr,
d5351 2
a5352 1
				PF_ACPY(pd->src, &(*state)->gwy.addr, pd->af);
d5361 2
a5362 1
				    pd->ip_sum, (*state)->lan.addr.v4.s_addr,
d5368 2
a5369 1
				PF_ACPY(pd->dst, &(*state)->lan.addr, pd->af);
d5966 1
d6197 1
d6210 1
a6210 1
			dirndx = (dir == s->direction) ? 0 : 1;
d6225 1
a6225 1
				x = (s == NULL || s->direction == dir) ?
d6228 1
a6228 1
				x = (s == NULL || s->direction == dir) ?
d6239 3
a6241 2
			pfr_update_stats(tr->src.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.src : pd.dst, pd.af,
d6245 2
a6246 2
			pfr_update_stats(tr->dst.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.dst : pd.src, pd.af,
d6275 1
d6573 1
d6586 1
a6586 1
			dirndx = (dir == s->direction) ? 0 : 1;
d6601 1
a6601 1
				x = (s == NULL || s->direction == dir) ?
d6604 1
a6604 1
				x = (s == NULL || s->direction == dir) ?
d6615 2
a6616 2
			pfr_update_stats(tr->src.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.src : pd.dst, pd.af,
d6620 2
a6621 2
			pfr_update_stats(tr->dst.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.dst : pd.src, pd.af,
@


1.533
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.532 2007/05/27 21:17:38 dlg Exp $ */
d2942 2
a2943 1
			u_int32_t ack = ntohl(th->th_seq) + pd->p_len;
d2945 13
a2957 8
			if (th->th_flags & TH_SYN)
				ack++;
			if (th->th_flags & TH_FIN)
				ack++;
			pf_send_tcp(r, af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    ntohl(th->th_ack), ack, TH_RST|TH_ACK, 0, 0,
			    r->return_ttl, 1, 0, pd->eh, kif->pfik_ifp);
a5962 6
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    ntohs(h->ip_len) - off, IPPROTO_TCP, AF_INET)) {
			REASON_SET(&reason, PFRES_PROTCKSUM);
			action = PF_DROP;
			goto done;
		}
a5992 6
		if (dir == PF_IN && uh.uh_sum && pf_check_proto_cksum(m,
		    off, ntohs(h->ip_len) - off, IPPROTO_UDP, AF_INET)) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_PROTCKSUM);
			goto done;
		}
a6022 6
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    ntohs(h->ip_len) - off, IPPROTO_ICMP, AF_INET)) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_PROTCKSUM);
			goto done;
		}
a6336 7
		if (dir == PF_IN && pf_check_proto_cksum(n, off,
		    ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_TCP, AF_INET6)) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_PROTCKSUM);
			goto done;
		}
a6364 7
		if (dir == PF_IN && uh.uh_sum && pf_check_proto_cksum(n,
		    off, ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_UDP, AF_INET6)) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_PROTCKSUM);
			goto done;
		}
a6392 7
			goto done;
		}
		if (dir == PF_IN && pf_check_proto_cksum(n, off,
		    ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_ICMPV6, AF_INET6)) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_PROTCKSUM);
@


1.532
log
@get rid of static.

ok claudio@@ reyk@@ henning@@ ja ja ja mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.531 2007/05/27 18:30:02 pyr Exp $ */
d186 1
a186 2
int			 pf_match_tag(struct mbuf *, struct pf_rule *,
			     struct pf_mtag *, int *);
a1567 1
	struct pf_mtag	*pf_mtag;
a1590 4
	if ((pf_mtag = pf_get_mtag(m)) == NULL) {
		m_freem(m);
		return;
	}
d1592 2
a1593 3
		pf_mtag->flags |= PF_TAG_GENERATED;

	pf_mtag->tag = rtag;
d1596 1
a1596 1
		pf_mtag->rtableid = r->rtableid;
d1600 1
a1600 1
		pf_mtag->qid = r->qid;
d1602 1
a1602 2
		pf_mtag->af = af;
		pf_mtag->hdr = mtod(m, struct ip *);
a1711 1
	struct pf_mtag	*pf_mtag;
d1715 1
a1715 4

	if ((pf_mtag = pf_get_mtag(m0)) == NULL)
		return;
	pf_mtag->flags |= PF_TAG_GENERATED;
d1718 1
a1718 1
		pf_mtag->rtableid = r->rtableid;
d1722 1
a1722 1
		pf_mtag->qid = r->qid;
d1724 1
a1724 2
		pf_mtag->af = af;
		pf_mtag->hdr = mtod(m0, struct ip *);
a1838 28
struct pf_mtag *
pf_find_mtag(struct mbuf *m)
{
	struct m_tag	*mtag;

	if ((mtag = m_tag_find(m, PACKET_TAG_PF, NULL)) == NULL)
		return (NULL);

	return ((struct pf_mtag *)(mtag + 1));
}

struct pf_mtag *
pf_get_mtag(struct mbuf *m)
{
	struct m_tag	*mtag;

	if ((mtag = m_tag_find(m, PACKET_TAG_PF, NULL)) == NULL) {
		mtag = m_tag_get(PACKET_TAG_PF, sizeof(struct pf_mtag),
		    M_NOWAIT);
		if (mtag == NULL)
			return (NULL);
		bzero(mtag + 1, sizeof(struct pf_mtag));
		m_tag_prepend(m, mtag);
	}

	return ((struct pf_mtag *)(mtag + 1));
}

d1840 1
a1840 2
pf_match_tag(struct mbuf *m, struct pf_rule *r, struct pf_mtag *pf_mtag,
    int *tag)
d1843 1
a1843 1
		*tag = pf_mtag->tag;
d1850 1
a1850 1
pf_tag_packet(struct mbuf *m, struct pf_mtag *pf_mtag, int tag, int rtableid)
a1854 3
	if (pf_mtag == NULL)
		if ((pf_mtag = pf_get_mtag(m)) == NULL)
			return (1);
d1856 1
a1856 1
		pf_mtag->tag = tag;
d1858 1
a1858 1
		pf_mtag->rtableid = rtableid;
d2375 1
a2375 1
		else if (r->match_tag && !pf_match_tag(m, r, pd->pf_mtag, &tag))
d2396 1
a2396 1
	if (pf_tag_packet(m, pd->pf_mtag, tag, rtableid))
d2884 1
a2884 1
		else if (r->match_tag && !pf_match_tag(m, r, pd->pf_mtag, &tag))
d2963 1
a2963 1
	if (pf_tag_packet(m, pd->pf_mtag, tag, rtableid)) {
d3262 1
a3262 1
		else if (r->match_tag && !pf_match_tag(m, r, pd->pf_mtag, &tag))
d3326 1
a3326 1
	if (pf_tag_packet(m, pd->pf_mtag, tag, rtableid)) {
d3593 1
a3593 1
		else if (r->match_tag && !pf_match_tag(m, r, pd->pf_mtag, &tag))
d3637 1
a3637 1
	if (pf_tag_packet(m, pd->pf_mtag, tag, rtableid)) {
d3852 1
a3852 1
		else if (r->match_tag && !pf_match_tag(m, r, pd->pf_mtag, &tag))
d3924 1
a3924 1
	if (pf_tag_packet(m, pd->pf_mtag, tag, rtableid)) {
d4071 1
a4071 1
		else if (r->match_tag && !pf_match_tag(m, r, pd->pf_mtag, &tag))
d4103 1
a4103 1
	if (pf_tag_packet(m, pd->pf_mtag, tag, -1)) {
d5486 1
a5486 1
	if (pd->pf_mtag->routed++ > 3) {
d5677 1
a5677 1
	if (pd->pf_mtag->routed++ > 3) {
d5708 1
a5708 1
		pd->pf_mtag->flags |= PF_TAG_GENERATED;
a5884 8
	if ((pd.pf_mtag = pf_get_mtag(m)) == NULL) {
		DPFPRINTF(PF_DEBUG_URGENT,
		    ("pf_test: pf_get_mtag returned NULL\n"));
		return (PF_DROP);
	}
	if (pd.pf_mtag->flags & PF_TAG_GENERATED)
		return (PF_PASS);

d5910 3
d6076 1
a6076 1
		pf_tag_packet(m, pd.pf_mtag, s ? s->tag : 0, r->rtableid);
d6081 1
a6081 1
			pd.pf_mtag->qid = r->pqid;
d6083 1
a6083 1
			pd.pf_mtag->qid = r->qid;
d6085 1
a6085 2
		pd.pf_mtag->af = AF_INET;
		pd.pf_mtag->hdr = h;
d6099 1
a6099 1
		pd.pf_mtag->flags |= PF_TAG_TRANSLATE_LOCALHOST;
a6208 8
	if ((pd.pf_mtag = pf_get_mtag(m)) == NULL) {
		DPFPRINTF(PF_DEBUG_URGENT,
		    ("pf_test6: pf_get_mtag returned NULL\n"));
		return (PF_DROP);
	}
	if (pd.pf_mtag->flags & PF_TAG_GENERATED)
		return (PF_PASS);

d6234 3
d6475 1
a6475 1
		pf_tag_packet(m, pd.pf_mtag, s ? s->tag : 0, r->rtableid);
d6480 1
a6480 1
			pd.pf_mtag->qid = r->pqid;
d6482 1
a6482 1
			pd.pf_mtag->qid = r->qid;
d6484 1
a6484 2
		pd.pf_mtag->af = AF_INET6;
		pd.pf_mtag->hdr = h;
d6493 1
a6493 1
		pd.pf_mtag->flags |= PF_TAG_TRANSLATE_LOCALHOST;
@


1.531
log
@clarify things by passing kif->pfik_ifp around in pf_test{,6} instead
of reassigning a struct ifnet pointer.
discussed with and ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.530 2007/05/26 20:12:02 henning Exp $ */
d188 2
d1908 1
a1908 1
static void
@


1.530
log
@add comments indicating why we do m = *m0; again after pf_normalize, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.529 2007/05/08 23:36:25 mcbride Exp $ */
d5937 3
a5939 1
		ifp = ifp->if_carpdev;
a5940 1
	kif = (struct pfi_kif *)ifp->if_pf_kif;
d6233 1
a6233 1
		pf_route(m0, r, dir, ifp, s, &pd);
d6267 3
a6269 1
		ifp = ifp->if_carpdev;
a6270 1
	kif = (struct pfi_kif *)ifp->if_pf_kif;
d6633 1
a6633 1
		pf_route6(m0, r, dir, ifp, s, &pd);
@


1.529
log
@block ALL packets with rthdr0 in pf_test6(). We already do this
in ip6_input(), but pf_test6() is called from bridge code as well.

ok dhartmei@@ henning@@ deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.527 2007/02/22 15:23:23 pyr Exp $ */
d5965 1
a5965 1
	m = *m0;
d6294 1
a6294 1
	m = *m0;
@


1.528
log
@Routing headers are dangerous. Deal with them the same way as IPv4 options:
drop all packets with routing headers unless the matching rule explicitly
specifies 'allow-opts'.

ok dhartmei@@ henning@@ deraadt@@ claudio@@
@
text
@d6348 8
@


1.527
log
@make urpf-failed work with multipath routes.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.526 2007/02/19 10:18:58 pyr Exp $ */
d6251 1
a6251 1
	int			 off, terminal = 0, dirndx;
a6329 3
			struct ip6_rthdr0 rthdr0;
			struct in6_addr finaldst;
			struct ip6_hdr *ip6;
d6331 8
d6344 1
a6347 43
			if (rthdr.ip6r_type == IPV6_RTHDR_TYPE_0) {
				if (!pf_pull_hdr(m, off, &rthdr0,
				    sizeof(rthdr0), NULL, &reason, pd.af)) {
					DPFPRINTF(PF_DEBUG_MISC,
					    ("pf: IPv6 short rthdr0\n"));
					action = PF_DROP;
					log = 1;
					goto done;
				}
				if (rthdr0.ip6r0_segleft != 0) {
					if (!pf_pull_hdr(m, off +
					    sizeof(rthdr0) +
					    rthdr0.ip6r0_len * 8 -
					    sizeof(finaldst), &finaldst,
					    sizeof(finaldst), NULL,
					    &reason, pd.af)) {
						DPFPRINTF(PF_DEBUG_MISC,
						    ("pf: IPv6 short rthdr0\n"));
						action = PF_DROP;
						log = 1;
						goto done;
					}

					n = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
					if (!n) {
						DPFPRINTF(PF_DEBUG_MISC,
						    ("pf: mbuf shortage\n"));
						action = PF_DROP;
						log = 1;
						goto done;
					}
					n = m_pullup(n, sizeof(struct ip6_hdr));
					if (!n) {
						DPFPRINTF(PF_DEBUG_MISC,
						    ("pf: mbuf shortage\n"));
						action = PF_DROP;
						log = 1;
						goto done;
					}
					ip6 = mtod(n, struct ip6_hdr *);
					ip6->ip6_dst = finaldst;
				}
			}
d6508 9
a6516 1
	/* XXX handle IPv6 options, if not allowed.  not implemented. */
@


1.526
log
@add handling of skip steps for urpf-failed addresses.
ok dharthmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.525 2007/02/14 00:53:48 jsg Exp $ */
d58 1
d5387 3
a5389 1
	int ret = 1;
d5391 1
d5397 3
d5401 1
d5409 2
d5418 2
d5426 4
d5433 9
d5443 10
a5452 11
		/* XXX doesn't try to grok multipath */
		if (kif != NULL && (kif->pfik_ifp == NULL ||
		    kif->pfik_ifp != ro.ro_rt->rt_ifp))
			ret = 0;
		/*
		 * If the interface is a carp one check if the packet was 
		 * seen on the underlying interface
		 */
		if (kif != NULL && ret == 0) {
			if (ro.ro_rt->rt_ifp->if_type == IFT_CARP &&
			    ro.ro_rt->rt_ifp->if_carpdev == kif->pfik_ifp)
d5454 2
a5455 2
		}
		RTFREE(ro.ro_rt);
d5458 3
a5460 1

@


1.525
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.524 2007/02/08 15:24:24 itojun Exp $ */
d1299 1
@


1.524
log
@compute pseudo-header checksum based on flnal destination as
ip6_dst (i'm bit skeptical about checksumming when the box is not the
final destination).
drop IPv6 jumbograms, as it could cause various funny symptoms due to
ip6_plen being 0 (yup, we should properly handle it instead).

ok by deraadt, naddy, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.523 2006/12/22 13:24:52 reyk Exp $ */
d6358 1
a6358 1
			/* fallthrough */
@


1.523
log
@add special handling for "urpf-failed" with carp interfaces.  the
unicast reverse path forwarding (URPF) check drops packets coming in
on an interface other than that which holds the route back to the
packet's source address.  this caused problems with routes bound to a
carp interface instead of the underlying interface.  this diff
validates the underlying carpdev if the route is bound to a carp
interface.

from Pierre-Yves Ritschard (pyr at spootnik.org)

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.522 2006/12/21 12:26:51 dhartmei Exp $ */
d6218 1
a6218 1
	struct mbuf		*m = *m0;
d6270 12
d6301 59
a6361 1
		case IPPROTO_ROUTING:
d6388 4
d6403 1
a6403 1
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
d6438 1
a6438 1
		if (dir == PF_IN && uh.uh_sum && pf_check_proto_cksum(m,
d6475 1
a6475 1
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
d6513 6
a6518 1
	/* XXX handle IPv6 options, if not allowed. not implemented. */
@


1.522
log
@in pf_route(), initialize ro to NULL at the beginning. if left un-
initialized, it might equal &iproute by chance, causing a panic
when rtfree() is then mistakenly called.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.521 2006/12/14 20:40:54 dhartmei Exp $ */
d5421 9
@


1.521
log
@in "BAD/loose state" messages, also print the packet's original sequence
number, it can differ from the sequence number being tested (for packets
without payload), and both matter in explaining why a packet mismatched.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.520 2006/12/13 09:01:59 itojun Exp $ */
d5478 1
a5478 1
	struct route		*ro;
@


1.520
log
@use IN6_IS_SCOPE_EMBED to check kernel-internal form addresses
(s6_addr16[1] filled)
ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.519 2006/11/16 13:17:15 henning Exp $ */
d4517 4
a4520 3
			printf(" seq=%u ack=%u len=%u ackskew=%d "
			    "pkts=%llu:%llu\n", seq, ack, pd->p_len, ackskew,
			    (*state)->packets[0], (*state)->packets[1]);
d4570 1
a4570 1
			printf(" seq=%u ack=%u len=%u ackskew=%d "
d4572 1
a4572 1
			    seq, ack, pd->p_len, ackskew,
@


1.519
log
@conditional for appending the pf mbuf tag in pf_test/pf_test6 was wrong,
we need to do so whenever we do have a (pf) tag != 0 on the state OR (that
part was missing) when rtableid on the rule is nonzero.
problem noticed by Andreas Lundin <lunde@@dreamhosted.se> testing the
multiple routing tables enabling diff, ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.518 2006/10/31 14:49:01 henning Exp $ */
d5757 1
a5757 1
	if (IN6_IS_ADDR_LINKLOCAL(&dst->sin6_addr))
@


1.518
log
@make pfsync a clonable too, but prevent more than one instance from
beeing created for now - much more work would be required to change that
input & ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.517 2006/10/27 13:56:51 mcbride Exp $ */
d6085 2
a6086 2
	if (s && s->tag)
		pf_tag_packet(m, pd.pf_mtag, s->tag, r->rtableid);
d6431 2
a6432 2
	if (s && s->tag)
		pf_tag_packet(m, pd.pf_mtag, s->tag, r->rtableid);
@


1.517
log
@Split ruleset manipulation functions out into pf_ruleset.c to allow them to
be imported into pfctl. This is a precursor to separating ruleset parsing
from loading in pfctl, and tons of good things will come from it.

2 minor changes aside from cut-n-paste and #define portability magic:

- instead of defining the global pf_main_ruleset, define pf_main_anchor
  (which contains the pf_main_ruleset)

- allow pf_find_or_create_ruleset() to return the pf_main_ruleset if it's
  passed an empty anchor name.

ok henning dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.516 2006/10/11 08:42:31 mcbride Exp $ */
d1009 3
a1011 2
	if (pfsyncif.sc_bulk_send_next == cur ||
	    pfsyncif.sc_bulk_terminator == cur)
@


1.516
log
@Allow the 'quick' keyword on an anchor. IFF there is a matching rule inside
the anchor, terminate ruleset evaluation when stepping out of the anchor.

This means that if you absolutely want the anchor to be terminal, you
probably want to use a 'block all' or 'pass all' rule at the start of the
anchor.

ok dhartmei@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.515 2006/09/18 09:53:05 markus Exp $ */
a96 2
struct pf_anchor_global	 pf_anchors;
struct pf_ruleset	 pf_main_ruleset;
a289 1
static __inline int pf_anchor_compare(struct pf_anchor *, struct pf_anchor *);
a302 2
RB_GENERATE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare);
RB_GENERATE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare);
a496 8
}

static __inline int
pf_anchor_compare(struct pf_anchor *a, struct pf_anchor *b)
{
	int c = strcmp(a->path, b->path);

	return (c ? (c < 0 ? -1 : 1) : 0);
@


1.515
log
@allow RST from TCP client, even if client does not send data after SYN;
ok frantzen, dhartmei, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.514 2006/09/18 07:03:35 dhartmei Exp $ */
d189 3
d1918 1
a1918 1
    struct pf_rule **r, struct pf_rule **a)
d1922 3
d1951 1
a1951 1
static void
d1953 1
a1953 1
    struct pf_rule **r, struct pf_rule **a)
d1956 1
d1963 5
d1982 2
d1986 2
d2442 2
a2443 1
				pf_step_into_anchor(&asd, &ruleset, rs_num, &r, NULL);
d2446 2
a2447 1
			pf_step_out_of_anchor(&asd, &ruleset, rs_num, &r, NULL);
d2858 1
d2948 1
d2957 1
a2957 1
				    PF_RULESET_FILTER, &r, &a);
d2959 3
a2961 3
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset,
			    PF_RULESET_FILTER, &r, &a);
d3238 1
d3325 1
d3334 1
a3334 1
				    PF_RULESET_FILTER, &r, &a);
d3336 3
a3338 3
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset,
			    PF_RULESET_FILTER, &r, &a);
d3523 1
d3656 1
d3665 1
a3665 1
				    PF_RULESET_FILTER, &r, &a);
d3667 3
a3669 3
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset,
			    PF_RULESET_FILTER, &r, &a);
d3828 1
d3915 1
d3924 1
a3924 1
				    PF_RULESET_FILTER, &r, &a);
d3926 3
a3928 3
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset,
			    PF_RULESET_FILTER, &r, &a);
d4097 1
d4128 1
d4137 1
a4137 1
				    PF_RULESET_FILTER, &r, &a);
d4139 3
a4141 3
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset,
			    PF_RULESET_FILTER, &r, &a);
@


1.514
log
@fix tos (type-of-service) comparisons. for rules which use 'tos x', compare
for equality (ip_tos == x). for priority queue assignment, compare AND-wise
(ip_tos & IPTOS_LOWDELAY). this matters mostly for cases where the reserved
bits in ip_tos are used (RFC791, 1349) and more than a single bit is set.
from Steve Welham, closes PR5226 and PR5227.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.513 2006/07/06 13:25:40 henning Exp $ */
d4407 2
a4408 2
	    (pd->flags & PFDESC_IP_REAS) == 0)) {
	    /* Require an exact sequence match on resets when possible */
@


1.513
log
@allow rules to point to an alternate routing table, and tag packets
matching that rule so that the forwarding code later can use the
alternate routing table fo lookups (not implemented yet).
the tagging is "sticky", every matching rule modifies, just like the
regular "tag". ok claudio hshoexer, hacked at r2k6
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.512 2006/05/17 14:50:47 henning Exp $ */
d2900 1
a2900 1
		else if (r->tos && !(r->tos & pd->tos))
d3278 1
a3278 1
		else if (r->tos && !(r->tos & pd->tos))
d3617 1
a3617 1
		else if (r->tos && !(r->tos & pd->tos))
d3874 1
a3874 1
		else if (r->tos && !(r->tos & pd->tos))
d4089 1
a4089 1
		else if (r->tos && !(r->tos & pd->tos))
d6074 1
a6074 1
		if (pqid || pd.tos == IPTOS_LOWDELAY)
d6420 1
a6420 1
		if (pd.tos == IPTOS_LOWDELAY)
@


1.512
log
@missing rtlabel support in pf_addr_wrap_neq()
PR5122 Jann Fischer <jfi@@openbsd.de>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.511 2006/03/14 11:09:42 djm Exp $ */
d1604 1
d1607 3
d1734 3
d1897 1
a1897 1
pf_tag_packet(struct mbuf *m, struct pf_mtag *pf_mtag, int tag)
d1899 1
a1899 1
	if (tag <= 0)
d1905 4
a1908 1
	pf_mtag->tag = tag;
d2368 1
d2421 2
d2431 1
a2431 1
	if (pf_tag_packet(m, pd->pf_mtag, tag))
d2837 1
a2837 1
	int			 tag = -1;
d2926 2
d2996 1
a2996 1
	if (pf_tag_packet(m, pd->pf_mtag, tag)) {
d3216 1
a3216 1
	int			 tag = -1;
d3301 2
d3357 1
a3357 1
	if (pf_tag_packet(m, pd->pf_mtag, tag)) {
d3496 1
a3496 1
	int			 tag = -1;
d3630 2
d3666 1
a3666 1
	if (pf_tag_packet(m, pd->pf_mtag, tag)) {
d3802 1
a3802 1
	int			 tag = -1;
d3887 2
d3951 1
a3951 1
	if (pf_tag_packet(m, pd->pf_mtag, tag)) {
d4128 1
a4128 1
	if (pf_tag_packet(m, pd->pf_mtag, tag)) {
d6070 1
a6070 1
		pf_tag_packet(m, pd.pf_mtag, s->tag);
d6416 1
a6416 1
		pf_tag_packet(m, pd.pf_mtag, s->tag);
@


1.511
log
@implement a Unicast Reverse Path Forwarding (uRPF) check for pf(4)
which optionally verifies that a packet is received on the interface
that holds the route back to the packet's source address. This makes
it an automatic ingress filter, but only when routing is fully
symmetric.

bugfix feedback claudio@@; ok claudio@@ and dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.510 2006/02/07 18:41:14 dhartmei Exp $ */
d1311 2
@


1.510
log
@mention source of pf_modulate_sack() in comment, no code change,
ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.509 2006/01/31 03:40:31 frantzen Exp $ */
d2381 2
a2382 1
		else if (PF_MISMATCHAW(&src->addr, saddr, pd->af, src->neg))
d2390 1
a2390 1
		    PF_MISMATCHAW(&dst->addr, daddr, pd->af, dst->neg))
d2392 2
a2393 1
		else if (xdst != NULL && PF_MISMATCHAW(xdst, daddr, pd->af, 0))
d2873 2
a2874 1
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.neg))
d2879 2
a2880 1
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.neg))
d3249 2
a3250 1
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.neg))
d3255 2
a3256 1
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.neg))
d3588 2
a3589 1
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.neg))
d3591 2
a3592 1
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.neg))
d3847 2
a3848 1
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.neg))
d3850 2
a3851 1
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.neg))
d4060 2
a4061 1
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.neg))
d4063 2
a4064 1
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.neg))
d5342 1
a5342 1
pf_routable(struct pf_addr *addr, sa_family_t af)
d5345 1
d5376 5
d5382 2
a5383 2
		return (1);
	}
d5385 1
a5385 1
	return (0);
@


1.509
log
@the TCP SACK option needs sequence number modulation
ok dhartmei@@ and beck@@.  help + testing from kpfaff AT palloys.com.pl
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.508 2005/11/14 09:18:55 pascoe Exp $ */
d1500 1
@


1.508
log
@fix spello
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.507 2005/11/04 08:24:15 mcbride Exp $ */
d130 2
d1497 57
d4341 19
@


1.507
log
@crank pf_state and pf_src_node byte and packet counters to u_in64_t, since
we're breaking pfsync compatibility this cycle anyways.

Requested by djm@@, ok henning@@, 'wheee!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.506 2005/10/26 03:47:33 mcbride Exp $ */
d2935 1
a2935 1
		/* src node for flter rule */
d3288 1
a3288 1
		/* src node for flter rule */
d3593 1
a3593 1
		/* src node for flter rule */
d3874 1
a3874 1
		/* src node for flter rule */
@


1.506
log
@Instead of using arc4random() to modulate the TCP isn, call tcp_rndiss_next()
and calculate the modulator. This ensures that modulated initial sequence
numbers have the same properties regarding separation and non-repetition as
those generated by our TCP stack.

ok markus@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.505 2005/10/25 11:19:35 henning Exp $ */
d4387 2
a4388 2
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d:%d\n",
			    seq, ack, pd->p_len, ackskew,
d4439 3
a4441 2
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d:%d "
			    "dir=%s,%s\n", seq, ack, pd->p_len, ackskew,
@


1.505
log
@mtag in pf_route is now only used for IPSEC, so #ifdef it
From: Mike Belopuhov <mkb@@crypt.org.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.504 2005/10/17 08:43:35 henning Exp $ */
d3012 2
a3013 1
			while ((s->src.seqdiff = htonl(arc4random())) == 0)
d4194 1
a4194 1
			while ((src->seqdiff = htonl(arc4random())) == 0)
@


1.504
log
@make pf use one mbuf tag instead of 6 distinct ones. use a little struct
in the data part for the data from the previously distinct tags.
look up the tag early and carry a pointer to it around.
makes the code easier and saves some tag lookups and thus helps performance,
as proven by tests run by Schberle Dniel <Schoeberle.Daniel@@aamtech.hu>
Initially hacked up somewhere over the atlantic ocean in an A330
early testing reyk and moritz, "put it in" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.503 2005/09/28 01:46:32 pascoe Exp $ */
a5337 1
	struct m_tag		*mtag;
d5346 3
@


1.503
log
@Improve the safety of pf IOCTLs, taking into account that some paths can sleep.

- Introduces a rw_lock in pfioctl so that we can have concurrent readers
  but only one process performing updates at a time;

- Separates state expiry into "unlink" and "free" parts; anyone can unlink
  a state/src node from the RB trees at any time, but a state can only be
  freed whilst the write lock is held;

- Converts state_updates into list state_list containing all states,
  regardless of whether they are "linked" or "unlinked";

- Introduces a new PFTM_UNLINKED state that is used on the "unlinked" states
  to signal that they can be freed;

- Converts pf_purge_expired_state to an "unlink" state routine, which only
  unlinks the state from the RB trees.  Freeing the state/src nodes is left
  to the purge thread, which runs whilst holding a write lock, such that all
  "next" references remain valid;

- Converts pfsync_bulk_update and DIOCGETSTATES to walk state_list rather
  than the RB trees;

- Converts the purge thread to use the new state_list and perform a partial
  purge every second, with the target rate a full state table walk every
  PFTM_INTERVAL seconds.

seen by mcbride, henning, dhartmei pre-3.8, but too intrusive for then
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.502 2005/08/22 11:54:25 dhartmei Exp $ */
a184 1
struct pf_tag		*pf_get_tag(struct mbuf *);
d186 1
a186 1
			     struct pf_tag **, int *);
d197 2
a198 1
			    struct ifnet *, struct pf_state *);
d200 2
a201 1
			    struct ifnet *, struct pf_state *);
a214 1
static int		 pf_add_mbuf_tag(struct mbuf *, u_int);
d991 1
a991 1
	if (cur->src.state == PF_TCPS_PROXY_DST)
d997 1
d1511 2
a1512 1
	char *opt;
d1536 7
a1542 2
	if (tag) {
		struct m_tag	*mtag;
a1543 12
		mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
		if (mtag == NULL) {
			m_freem(m);
			return;
		}
		m_tag_prepend(m, mtag);
	}
	if (rtag)
		if (pf_tag_packet(m, NULL, rtag)) {
			m_freem(m);
			return;
		}
d1546 4
a1549 12
		struct m_tag	*mtag;
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m, struct ip *);
			m_tag_prepend(m, mtag);
		}
d1659 1
a1659 1
	struct m_tag	*mtag;
a1661 3
	mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
	if (mtag == NULL)
		return;
d1663 2
a1664 2
	if (m0 == NULL) {
		m_tag_free(mtag);
d1666 1
a1666 2
	}
	m_tag_prepend(m0, mtag);
d1670 4
a1673 11
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m0, struct ip *);
			m_tag_prepend(m0, mtag);
		}
d1788 2
a1789 2
struct pf_tag *
pf_get_tag(struct mbuf *m)
d1793 1
a1793 3
	if ((mtag = m_tag_find(m, PACKET_TAG_PF_TAG, NULL)) != NULL)
		return ((struct pf_tag *)(mtag + 1));
	else
d1795 19
d1817 2
a1818 1
pf_match_tag(struct mbuf *m, struct pf_rule *r, struct pf_tag **pftag, int *tag)
d1820 2
a1821 7
	if (*tag == -1) {	/* find mbuf tag */
		*pftag = pf_get_tag(m);
		if (*pftag != NULL)
			*tag = (*pftag)->tag;
		else
			*tag = 0;
	}
d1828 1
a1828 1
pf_tag_packet(struct mbuf *m, struct pf_tag *pftag, int tag)
a1829 2
	struct m_tag	*mtag;

d1833 2
a1834 3
	if (pftag == NULL) {
		mtag = m_tag_get(PACKET_TAG_PF_TAG, sizeof(*pftag), M_NOWAIT);
		if (mtag == NULL)
d1836 1
a1836 4
		((struct pf_tag *)(mtag + 1))->tag = tag;
		m_tag_prepend(m, mtag);
	} else
		pftag->tag = tag;
a2294 1
	struct pf_tag		*pftag = NULL;
d2337 1
a2337 1
		else if (r->match_tag && !pf_match_tag(m, r, &pftag, &tag))
d2354 1
a2354 1
	if (pf_tag_packet(m, pftag, tag))
a2759 1
	struct pf_tag		*pftag = NULL;
d2839 1
a2839 1
		else if (r->match_tag && !pf_match_tag(m, r, &pftag, &tag))
d2915 1
a2915 1
	if (pf_tag_packet(m, pftag, tag)) {
a3133 1
	struct pf_tag		*pftag = NULL;
d3210 1
a3210 1
		else if (r->match_tag && !pf_match_tag(m, r, &pftag, &tag))
d3271 1
a3271 1
	if (pf_tag_packet(m, pftag, tag)) {
a3409 1
	struct pf_tag		*pftag = NULL;
d3535 1
a3535 1
		else if (r->match_tag && !pf_match_tag(m, r, &pftag, &tag))
d3576 1
a3576 1
	if (pf_tag_packet(m, pftag, tag)) {
a3711 1
	struct pf_tag		*pftag = NULL;
d3788 1
a3788 1
		else if (r->match_tag && !pf_match_tag(m, r, &pftag, &tag))
d3857 1
a3857 1
	if (pf_tag_packet(m, pftag, tag)) {
a3974 1
	struct pf_tag		*pftag = NULL;
d4001 1
a4001 1
		else if (r->match_tag && !pf_match_tag(m, r, &pftag, &tag))
d4032 1
a4032 1
	if (pf_tag_packet(m, pftag, tag)) {
d5335 1
a5335 1
    struct pf_state *s)
d5352 4
a5355 16
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
d5527 1
a5527 1
    struct pf_state *s)
a5529 1
	struct m_tag		*mtag;
d5543 4
a5546 16
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
d5572 1
a5572 1
	/* Cheat. */
d5574 1
a5574 4
		mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
		if (mtag == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
a5731 14
static int
pf_add_mbuf_tag(struct mbuf *m, u_int tag)
{
	struct m_tag *mtag;

	if (m_tag_find(m, tag, NULL) != NULL)
		return (0);
	mtag = m_tag_get(tag, 0, M_NOWAIT);
	if (mtag == NULL)
		return (1);
	m_tag_prepend(m, mtag);
	return (0);
}

d5747 10
a5756 2
	if (!pf_status.running ||
	    (m_tag_find(m, PACKET_TAG_PF_GENERATED, NULL) != NULL))
a5775 1
	memset(&pd, 0, sizeof(pd));
d5946 1
a5946 1
		pf_tag_packet(m, pf_get_tag(m), s->tag);
d5950 7
a5956 15
		struct m_tag	*mtag;
		struct altq_tag	*atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			if (pqid || pd.tos == IPTOS_LOWDELAY)
				atag->qid = r->pqid;
			else
				atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = AF_INET;
			atag->hdr = h;
			m_tag_prepend(m, mtag);
		}
d5969 2
a5970 5
	    (ntohl(pd.dst->v4.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET &&
	    pf_add_mbuf_tag(m, PACKET_TAG_PF_TRANSLATE_LOCALHOST)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_MEMORY);
	}
d6055 1
a6055 1
		pf_route(m0, r, dir, ifp, s);
d6076 10
a6085 2
	if (!pf_status.running ||
	    (m_tag_find(m, PACKET_TAG_PF_GENERATED, NULL) != NULL))
a6104 1
	memset(&pd, 0, sizeof(pd));
d6292 1
a6292 1
		pf_tag_packet(m, pf_get_tag(m), s->tag);
d6296 7
a6302 15
		struct m_tag	*mtag;
		struct altq_tag	*atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			if (pd.tos == IPTOS_LOWDELAY)
				atag->qid = r->pqid;
			else
				atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = AF_INET6;
			atag->hdr = h;
			m_tag_prepend(m, mtag);
		}
d6310 2
a6311 5
	    IN6_IS_ADDR_LOOPBACK(&pd.dst->v6) &&
	    pf_add_mbuf_tag(m, PACKET_TAG_PF_TRANSLATE_LOCALHOST)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_MEMORY);
	}
d6396 1
a6396 1
		pf_route6(m0, r, dir, ifp, s);
@


1.502
log
@when nat'ing icmp 'connections', replace icmp id with proxy values
(similar to proxy ports for tcp/udp). not all clients use per-invokation
random ids, this allows multiple concurrent connections from such clients.
thanks for testing to Rod Whitworth, "looks ok" markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.501 2005/08/22 09:48:05 dhartmei Exp $ */
d52 1
d292 1
a292 1
struct pf_state_queue state_updates;
d852 1
a852 2
	TAILQ_INSERT_HEAD(&state_updates, state, u.s.entry_updates);

d865 1
a865 1
	int s;
d868 2
a869 2
		tsleep(pf_purge_thread, PWAIT, "pftm",
		    pf_default_rule.timeout[PFTM_INTERVAL] * hz);
d871 12
a882 3
		pf_purge_expired_states();
		pf_purge_expired_fragments();
		pf_purge_expired_src_nodes();
d900 1
d925 1
a925 1
pf_purge_expired_src_nodes(void)
d928 1
d934 6
d952 3
d987 1
d989 1
a989 1
pf_purge_expired_state(struct pf_state *cur)
d1003 2
a1004 1
	pfsync_delete_state(cur);
d1006 1
d1008 13
d1033 1
a1033 1
	TAILQ_REMOVE(&state_updates, cur, u.s.entry_updates);
d1042 1
a1042 1
pf_purge_expired_states(void)
d1044 14
a1057 1
	struct pf_state		*cur, *next;
d1059 17
a1075 5
	for (cur = RB_MIN(pf_state_tree_id, &tree_id);
	    cur; cur = next) {
		next = RB_NEXT(pf_state_tree_id, &tree_id, cur);
		if (pf_state_expires(cur) <= time_second)
			pf_purge_expired_state(cur);
d1077 3
@


1.502.2.1
log
@MFC:
Fix by frantzen@@

the TCP SACK option needs sequence number modulation
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.502 2005/08/22 11:54:25 dhartmei Exp $ */
a128 2
int			 pf_modulate_sack(struct mbuf *, int, struct pf_pdesc *,
			    struct tcphdr *, struct pf_state_peer *);
a1429 57

/*
 * Need to modulate the sequence numbers in the TCP SACK option
 */
int
pf_modulate_sack(struct mbuf *m, int off, struct pf_pdesc *pd,
    struct tcphdr *th, struct pf_state_peer *dst)
{
	int hlen = (th->th_off << 2) - sizeof(*th), thoptlen = hlen;
	u_int8_t opts[MAX_TCPOPTLEN], *opt = opts;
	int copyback = 0, i, olen;
	struct sackblk sack;

#define TCPOLEN_SACKLEN	(TCPOLEN_SACK + 2)
	if (hlen < TCPOLEN_SACKLEN ||
	    !pf_pull_hdr(m, off + sizeof(*th), opts, hlen, NULL, NULL, pd->af))
		return 0;

	while (hlen >= TCPOLEN_SACKLEN) {
		olen = opt[1];
		switch (*opt) {
		case TCPOPT_EOL:	/* FALLTHROUGH */
		case TCPOPT_NOP:
			opt++;
			hlen--;
			break;
		case TCPOPT_SACK:
			if (olen > hlen)
				olen = hlen;
			if (olen >= TCPOLEN_SACKLEN) {
				for (i = 2; i + TCPOLEN_SACK <= olen;
				    i += TCPOLEN_SACK) {
					memcpy(&sack, &opt[i], sizeof(sack));
					pf_change_a(&sack.start, &th->th_sum,
					    htonl(ntohl(sack.start) -
					    dst->seqdiff), 0);
					pf_change_a(&sack.end, &th->th_sum,
					    htonl(ntohl(sack.end) -
					    dst->seqdiff), 0);
					memcpy(&opt[i], &sack, sizeof(sack));
				}
				copyback = 1;
			}
			/* FALLTHROUGH */
		default:
			if (olen < 2)
				olen = 2;
			hlen -= olen;
			opt += olen;
		}
	}

	if (copyback)
		m_copyback(m, off + sizeof(*th), thoptlen, opts);
	return (copyback);
}

a4239 19


	/*
	 * Need to demodulate the sequence numbers in any TCP SACK options
	 * (Selective ACK). We could optionally validate the SACK values
	 * against the current ACK window, either forwards or backwards, but
	 * I'm not confident that SACK has been implemented properly
	 * everywhere. It wouldn't surprise me if several stacks accidently
	 * SACK too far backwards of previously ACKed data. There really aren't
	 * any security implications of bad SACKing unless the target stack
	 * doesn't validate the option length correctly. Someone trying to
	 * spoof into a TCP connection won't bother blindly sending SACK
	 * options anyway.
	 */
	if (dst->seqdiff && (th->th_off << 2) > sizeof(struct tcphdr)) {
		if (pf_modulate_sack(m, off, pd, th, dst))
			copyback = 1;
	}

@


1.501
log
@fix rdr to bitmask replacement address pool. patch from Max Laier,
reported by Boris Polevoy, tested by Jean Debogue, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.500 2005/08/18 10:28:13 pascoe Exp $ */
d2164 5
d2180 2
a2181 1
		if (!(proto == IPPROTO_TCP || proto == IPPROTO_UDP)) {
d3362 1
a3362 1
	u_int16_t		 icmpid;
d3411 1
d3414 2
a3415 1
		    saddr, icmpid, daddr, icmpid, &pd->naddr, NULL)) != NULL) {
d3422 4
d3441 1
d3444 2
a3445 1
		    saddr, icmpid, daddr, icmpid, &pd->naddr, NULL)) != NULL) {
d3597 1
a3597 1
			s->gwy.port = icmpid;
d3599 2
a3600 2
			s->ext.port = icmpid;
			if (nr != NULL)
d3602 2
a3603 1
			else
d3605 2
a3606 1
			s->lan.port = icmpid;
d3609 1
a3609 1
			s->lan.port = icmpid;
d3611 2
a3612 2
			s->ext.port = icmpid;
			if (nr != NULL)
d3614 2
a3615 1
			else
d3617 2
a3618 1
			s->gwy.port = icmpid;
d4548 1
a4548 1
			key.ext.port = icmpid;
d4554 1
a4554 1
			key.ext.port = icmpid;
d4563 1
a4563 1
		if (PF_ANEQ(&(*state)->lan.addr, &(*state)->gwy.addr, pd->af)) {
d4571 8
d4599 8
d4930 1
a4930 1
				key.ext.port = iih.icmp_id;
d4936 1
a4936 1
				key.ext.port = iih.icmp_id;
d4981 1
a4981 1
				key.ext.port = iih.icmp6_id;
d4987 1
a4987 1
				key.ext.port = iih.icmp6_id;
@


1.500
log
@Rearrange pf_state and pfi_kif so that the parts of the structure needed
to search for a particular entry in the RB trees are at the start of the
structure.

This permits us to place a much smaller structure on the stack in the
interrupt paths that match packets against state entries.

ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.499 2005/08/11 05:09:29 joel Exp $ */
d2430 5
@


1.499
log
@Only decrement the max-src-conn counter for tcp connections that reached
"established" state. Requires recompiling pfctl, etc.


ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.498 2005/07/31 05:20:56 pascoe Exp $ */
d215 1
a215 1
			    struct pf_state *, u_int8_t);
d527 1
a527 1
pf_find_state_byid(struct pf_state *key)
d530 1
a530 1
	return (RB_FIND(pf_state_tree_id, &tree_id, key));
d534 1
a534 1
pf_find_state_recurse(struct pfi_kif *kif, struct pf_state *key, u_int8_t tree)
d543 1
a543 1
		    key)) != NULL)
d546 1
a546 1
		    key)) != NULL)
d551 1
a551 1
		    key)) != NULL)
d554 1
a554 1
		    key)) != NULL)
d563 1
a563 1
pf_find_state_all(struct pf_state *key, u_int8_t tree, int *more)
d574 1
a574 1
			    &kif->pfik_lan_ext, key);
d586 1
a586 1
			    &kif->pfik_ext_gwy, key);
d2156 1
a2156 1
	struct pf_state		key;
d3981 1
a3981 1
	struct pf_state		 key;
d4418 1
a4418 1
	struct pf_state		 key;
d4482 1
a4482 1
	struct pf_state	 key;
d5041 1
a5041 1
	struct pf_state		 key;
@


1.498
log
@Perform pf state/rule/table expiry in a kernel thread instead of running
it out of a timeout handler.

This means we will have process context, required when using the oldnointr
pool allocator.

Addresses pr4186, pr4273.

ok dhartmei@@ henning@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.497 2005/07/31 03:30:55 pascoe Exp $ */
d637 1
d944 1
a944 2
			if (s->src.state == PF_TCPS_PROXY_DST ||
			    s->timeout >= PFTM_TCP_ESTABLISHED)
@


1.497
log
@Change the API for icmp_do_error so that it takes the mtu directly, rather
than a pointer to struct ifnet containing it.

Saves a 448 byte stack allocation in ip_forward which previously faked up
a struct ifnet just for this purpose.

idea ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.496 2005/07/29 06:26:43 pascoe Exp $ */
a108 2
struct timeout		 pf_expire_to;			/* expire timeout */

d862 1
a862 1
pf_purge_timeout(void *arg)
d864 1
a864 2
	struct timeout	*to = arg;
	int		 s;
d866 9
a874 7
	s = splsoftnet();
	pf_purge_expired_states();
	pf_purge_expired_fragments();
	pf_purge_expired_src_nodes();
	splx(s);

	timeout_add(to, pf_default_rule.timeout[PFTM_INTERVAL] * hz);
@


1.496
log
@Use one "struct pf_state key" declaration at top of pf_test_state_icmp,
instead of allocating it as a temp var in six mutually exclusive code paths.

Saves 784 bytes of kernel stack (on i386).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.495 2005/07/21 08:02:26 markus Exp $ */
d1641 1
a1641 1
		icmp_error(m0, type, code, 0, (void *)NULL);
d5418 1
a5418 1
			    ifp);
@


1.495
log
@account ipv4 packets with wrong tcp/udp/icmp checksums and udp
packets with invalid uh_len; ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.494 2005/07/04 08:28:04 markus Exp $ */
d4483 1
a4520 2
		struct pf_state		key;

a4695 1
			struct pf_state		 key;
a4811 1
			struct pf_state		key;
a4877 1
			struct pf_state		key;
a4928 1
			struct pf_state		key;
a4979 2
			struct pf_state		key;

@


1.494
log
@restrict the tcp.finwait timeout (45s) to state combinations where we have
seen a FIN from both sides (whether ACKed or not) and use tcp.closing (900s)
for half closed connections.  otherwise half closed connections will time out
within 45s. ok dhartmei, henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.493 2005/06/13 20:17:25 henning Exp $ */
d5792 1
d5829 1
d5836 1
d5865 1
d6192 1
@


1.493
log
@make the packet and byte counters on rules and src nodes per direction,
matches the counters on states now. also fix the counting on scrub rules
where we previously did not handle the byte counters at all.
extend pfctl -sl output to include the new seperate in/out counters
hacked on the ferry from Earls Cove to Saltery Bay
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.492 2005/05/27 17:22:40 dhartmei Exp $ */
d4276 2
a4277 2
		else if (src->state >= TCPS_FIN_WAIT_2 ||
		    dst->state >= TCPS_FIN_WAIT_2)
@


1.492
log
@log two pairs of uid/pid through pflog: the uid/pid of the process that
inserted the rule which causes the logging. secondly, the uid/pid of the
process in case the logged packet is delivered to/from a local socket.
a lookup of the local socket can be forced for logged packets with a new
option, 'log (user)'. make tcpdump print the additional information when
-e and -v is used. note: this changes the pflog header struct, rebuild all
dependancies. ok bob@@, henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.491 2005/05/26 15:29:48 dhartmei Exp $ */
d5958 3
a5960 2
		r->packets++;
		r->bytes += pd.tot_len;
d5962 2
a5963 2
			a->packets++;
			a->bytes += pd.tot_len;
a5965 3
			dirndx = (dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd.tot_len;
d5967 2
a5968 2
				s->nat_rule.ptr->packets++;
				s->nat_rule.ptr->bytes += pd.tot_len;
d5971 2
a5972 2
				s->src_node->packets++;
				s->src_node->bytes += pd.tot_len;
d5975 2
a5976 2
				s->nat_src_node->packets++;
				s->nat_src_node->bytes += pd.tot_len;
d5978 3
d6302 3
a6304 2
		r->packets++;
		r->bytes += pd.tot_len;
d6306 2
a6307 2
			a->packets++;
			a->bytes += pd.tot_len;
a6309 3
			dirndx = (dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd.tot_len;
d6311 2
a6312 2
				s->nat_rule.ptr->packets++;
				s->nat_rule.ptr->bytes += pd.tot_len;
d6315 2
a6316 2
				s->src_node->packets++;
				s->src_node->bytes += pd.tot_len;
d6319 2
a6320 2
				s->nat_src_node->packets++;
				s->nat_src_node->bytes += pd.tot_len;
d6322 3
@


1.491
log
@support 'log' and 'log-all' in 'nat/rdr/binat pass' rules. original patch
from camield@@. use #defines PF_LOG, PF_LOGALL instead of magic constants.
ok frantzen@@, camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.490 2005/05/23 23:28:53 dhartmei Exp $ */
d51 1
d202 1
a202 2
int			 pf_socket_lookup(uid_t *, gid_t *,
			    int, struct pf_pdesc *);
d2458 1
a2458 1
pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, struct pf_pdesc *pd)
d2465 5
a2469 2
	*uid = UID_MAX;
	*gid = GID_MAX;
d2472 2
d2479 2
d2486 1
a2486 1
		return (0);
d2507 1
a2507 1
				return (0);
d2518 1
a2518 1
				return (0);
d2524 1
a2524 1
		return (0);
d2526 3
a2528 2
	*uid = inp->inp_socket->so_euid;
	*gid = inp->inp_socket->so_egid;
a2698 3
	int			 lookup = -1;
	uid_t			 uid;
	gid_t			 gid;
d2772 2
a2773 2
		else if (r->uid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d2775 1
a2775 1
		    uid))
d2777 2
a2778 2
		else if (r->gid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d2780 1
a2780 1
		    gid))
d2817 1
a2817 1
		    a, ruleset);
d2920 1
a2920 1
		s->log = r->log & PF_LOGALL;
d2922 1
a2922 1
			s->log |= nr->log & PF_LOGALL;
a3073 3
	int			 lookup = -1;
	uid_t			 uid;
	gid_t			 gid;
d3144 2
a3145 2
		else if (r->uid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d3147 1
a3147 1
		    uid))
d3149 2
a3150 2
		else if (r->gid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d3152 1
a3152 1
		    gid))
d3188 1
a3188 1
		    a, ruleset);
d3273 1
a3273 1
		s->log = r->log & PF_LOGALL;
d3275 1
a3275 1
			s->log |= nr->log & PF_LOGALL;
d3509 1
a3509 1
		    a, ruleset);
d3571 1
a3571 1
		s->log = r->log & PF_LOGALL;
d3573 1
a3573 1
			s->log |= nr->log & PF_LOGALL;
d3754 1
a3754 1
		    a, ruleset);
d3849 1
a3849 1
		s->log = r->log & PF_LOGALL;
d3851 1
a3851 1
			s->log |= nr->log & PF_LOGALL;
d3963 2
a3964 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d5946 1
a5946 1
		    s->nat_rule.ptr->log & PF_LOGALL)
d5950 2
a5951 1
		PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, lr, a, ruleset);
d6289 1
a6289 1
		    s->nat_rule.ptr->log & PF_LOGALL)
d6293 2
a6294 1
		PFLOG_PACKET(kif, h, m, AF_INET6, dir, reason, lr, a, ruleset);
@


1.490
log
@change pool allocation of table entries, no longer use the oldnointr
allocator and two pools, but PR_WAITOK when called from non-interrupt
context (ioctl). add configurable hard limits for tables and table
entries (set limit tables/table-entries), defaulting to 1000/100000.
ok aaron@@, henning@@, mcbride@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.489 2005/05/21 21:03:57 henning Exp $ */
d2808 1
a2808 1
	if (r->log) {
d2811 2
a2812 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d2915 3
a2917 1
		s->log = r->log & 2;
d3182 1
a3182 1
	if (r->log) {
d3185 2
a3186 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d3271 3
a3273 1
		s->log = r->log & 2;
d3500 1
a3500 1
	if (r->log) {
d3506 2
a3507 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d3569 3
a3571 1
		s->log = r->log & 2;
d3750 3
a3752 2
	if (r->log)
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d3847 3
a3849 1
		s->log = r->log & 2;
d5939 10
a5948 2
	if (log)
		PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, r, a, ruleset);
d6281 10
a6290 2
	if (log)
		PFLOG_PACKET(kif, h, m, AF_INET6, dir, reason, r, a, ruleset);
@


1.489
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.488 2005/04/25 17:55:51 brad Exp $ */
d221 3
d227 3
a229 1
	{ &pf_frent_pl, PFFRAG_FRENT_HIWAT }
@


1.488
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.487 2005/04/22 09:53:18 dhartmei Exp $ */
d255 2
a256 3
#define BOUND_IFACE(r, k) (((r)->rule_flag & PFRULE_IFBOUND) ? (k) :   \
	((r)->rule_flag & PFRULE_GRBOUND) ? (k)->pfik_parent :	       \
	(k)->pfik_parent->pfik_parent)
d539 6
a544 6
		for (; kif != NULL; kif = kif->pfik_parent) {
			s = RB_FIND(pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext, key);
			if (s != NULL)
				return (s);
		}
d547 6
a552 6
		for (; kif != NULL; kif = kif->pfik_parent) {
			s = RB_FIND(pf_state_tree_ext_gwy,
			    &kif->pfik_ext_gwy, key);
			if (s != NULL)
				return (s);
		}
d851 1
a851 1
	pfi_attach_state(kif);
d992 1
a992 1
	pfi_detach_state(cur->u.s.kif);
d2257 1
a2257 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d2738 1
a2738 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d3112 1
a3112 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d3439 1
a3439 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d3690 1
a3690 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d3899 1
a3899 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d5704 1
a5704 1
	kif = pfi_index2kif[ifp->if_index];
d6023 1
a6023 1
	kif = pfi_index2kif[ifp->if_index];
@


1.487
log
@When synproxy completes the replayed handshake and modifies the state
into a normal one, it sets both peers' sequence windows. Fix a bug where
the previously advertised windows are applied to the wrong side (i.e.
peer A's seqhi is peer A's seqlo plus peer B's, not A's, window). This
went undetected because mostly the windows are similar and/or re-
advertised soon. But there are (rare) cases where a synproxy'd connection
would stall right after handshake. Found by Gleb Smirnoff.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.486 2005/04/15 12:59:40 joel Exp $ */
d5372 1
a5372 1
	if (m0->m_pkthdr.csum & M_TCPV4_CSUM_OUT) {
d5376 1
a5376 1
			m0->m_pkthdr.csum &= ~M_TCPV4_CSUM_OUT; /* Clear */
d5378 1
a5378 1
	} else if (m0->m_pkthdr.csum & M_UDPV4_CSUM_OUT) {
d5382 1
a5382 1
			m0->m_pkthdr.csum &= ~M_UDPV4_CSUM_OUT; /* Clear */
d5389 1
a5389 1
			m0->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
d5396 1
a5396 1
		if (m0->m_pkthdr.csum & M_TCPV4_CSUM_OUT)
d5398 1
a5398 1
		else if (m0->m_pkthdr.csum & M_UDPV4_CSUM_OUT)
d5615 1
a5615 1
	if (m->m_pkthdr.csum & flag_ok)
d5617 1
a5617 1
	if (m->m_pkthdr.csum & flag_bad)
d5652 1
a5652 1
		m->m_pkthdr.csum |= flag_bad;
d5671 1
a5671 1
	m->m_pkthdr.csum |= flag_ok;
@


1.486
log
@Try this again.

When synproxy sends packets to the destination host, make sure to copy
the 'tag' from the original state entry into the outgoing mbuf.

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.485 2005/04/14 08:21:01 henning Exp $ */
d4080 2
a4082 2
			(*state)->dst.seqhi = (*state)->dst.seqlo +
			    (*state)->dst.max_win;
@


1.485
log
@back out last, some breakage crept in
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.483 2005/03/15 17:38:43 dhartmei Exp $ */
d142 1
a142 1
			    struct ether_header *, struct ifnet *);
d972 1
a972 1
		    TH_RST|TH_ACK, 0, 0, 0, 1, NULL, NULL);
d1432 1
a1432 1
    struct ether_header *eh, struct ifnet *ifp)
d1477 5
d2840 1
a2840 1
			    r->return_ttl, 1, pd->eh, kif->pfik_ifp);
d3040 1
a3040 1
			    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, NULL, NULL);
d4016 1
a4016 1
			    NULL, NULL);
d4054 1
a4054 1
			    (*state)->src.mss, 0, 0, NULL, NULL);
d4069 1
a4069 1
			    NULL, NULL);
d4074 1
a4074 1
			    NULL, NULL);
d4353 1
a4353 1
				    (*state)->rule.ptr->return_ttl, 1,
@


1.484
log
@When synproxy sends packets to the destination host, make sure to copy
the 'tag' from the original state entry into the outgoing mbuf.

ok henning@@ dhartmei@@
@
text
@d142 1
a142 1
			    int, struct ether_header *, struct ifnet *);
d972 1
a972 1
		    TH_RST|TH_ACK, 0, 0, 0, 1, cur->tag, NULL, NULL);
d1432 1
a1432 1
    int rtag, struct ether_header *eh, struct ifnet *ifp)
a1476 5
	if (rtag)
		if (pf_tag_packet(m, NULL, rtag)) {
			m_freem(m);
			return;
		}
d2835 1
a2835 1
			    r->return_ttl, 1, 0, pd->eh, kif->pfik_ifp);
d3035 1
a3035 2
			    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, s->tag, 
			    NULL, NULL);
d4011 1
a4011 1
			    0, (*state)->tag, NULL, NULL);
d4049 1
a4049 1
			    (*state)->src.mss, 0, 0, (*state)->tag, NULL, NULL);
d4063 1
a4063 1
			    TH_ACK, (*state)->src.max_win, 0, 0, 0, 0,
d4069 1
a4069 1
			    (*state)->tag, NULL, NULL);
@


1.483
log
@byte order of mss, only affects synproxy code path, from John L. Scarfone
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.482 2005/03/04 11:01:32 dhartmei Exp $ */
d142 1
a142 1
			    struct ether_header *, struct ifnet *);
d972 1
a972 1
		    TH_RST|TH_ACK, 0, 0, 0, 1, NULL, NULL);
d1432 1
a1432 1
    struct ether_header *eh, struct ifnet *ifp)
d1477 5
d2840 1
a2840 1
			    r->return_ttl, 1, pd->eh, kif->pfik_ifp);
d3040 2
a3041 1
			    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, NULL, NULL);
d4017 1
a4017 1
			    NULL, NULL);
d4055 1
a4055 1
			    (*state)->src.mss, 0, 0, NULL, NULL);
d4069 1
a4069 1
			    TH_ACK, (*state)->src.max_win, 0, 0, 0,
d4075 1
a4075 1
			    NULL, NULL);
@


1.483.2.1
log
@MFC:
Fix by pascoe@@

Perform pf state/rule/table expiry in a kernel thread instead of running
it out of a timeout handler.

This means we will have process context, required when using the oldnointr
pool allocator.

Addresses pr4186, pr4273.

ok dhartmei@@ deraadt@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.483 2005/03/15 17:38:43 dhartmei Exp $ */
a50 1
#include <sys/proc.h>
d108 2
d860 1
a860 1
pf_purge_thread(void *v)
d862 8
a869 1
	int s;
d871 1
a871 9
	for (;;) {
		tsleep(pf_purge_thread, PWAIT, "pftm",
		    pf_default_rule.timeout[PFTM_INTERVAL] * hz);
		s = splsoftnet();
		pf_purge_expired_states();
		pf_purge_expired_fragments();
		pf_purge_expired_src_nodes();
		splx(s);
	}
@


1.482
log
@add state's tag for IPv6, too. spotted by markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.481 2005/03/03 07:13:39 dhartmei Exp $ */
d2580 1
@


1.481
log
@when tagging, apply the same tag to all packets matching a state entry
(not just to the initial packet). note: kernel/userland abi change
(rebuild pfctl). ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.480 2005/02/27 15:08:39 dhartmei Exp $ */
d6223 3
@


1.480
log
@support 'tagged' in translation rules, non-delayed tag lookup
ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.479 2005/01/30 00:02:30 dhartmei Exp $ */
d995 2
d3008 4
d3312 4
d3602 4
d3874 4
d5884 3
@


1.479
log
@Add some more reason counters and use them instead of overloading the
'memory' one, which helps debugging. Alters the kernel/userland ABI,
rebuild pfctl and tcpdump. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.478 2005/01/20 18:07:33 dhartmei Exp $ */
d187 1
a187 1
			     struct pf_rule *, struct pf_tag **, int *);
d1750 1
a1750 2
pf_match_tag(struct mbuf *m, struct pf_rule *r, struct pf_rule *nat_rule,
    struct pf_tag **pftag, int *tag)
a1757 2
		if (nat_rule != NULL && nat_rule->tag)
			*tag = nat_rule->tag;
d2232 2
d2276 2
d2282 4
a2285 1
		else if (r->anchor == NULL)
d2287 3
a2289 2
		else
			pf_step_into_anchor(&asd, &ruleset, rs_num, &r, NULL);
d2293 2
d2769 1
a2769 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d3138 1
a3138 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d3450 1
a3450 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d3694 1
a3694 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d3902 1
a3902 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, NULL, &pftag, &tag))
@


1.478
log
@Use the packet's address family instead of the rule's when selecting a
replacement address for an rdr rule. Some rdr rules have no address family
(when the replacement is a table and no other criterion implies one AF).
In this case, pf would fail to select a replacement address and drop the
packet due to translation failure. Found by Gustavo A. Baratto.
ok mcbride@@, henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.477 2005/01/07 18:58:39 mcbride Exp $ */
d182 1
a182 1
			    void *, struct pf_pdesc *);
d2686 2
a2687 1
	if (pf_check_congestion(ifq))
d2689 1
d2854 1
d2860 2
a2861 1
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
d2863 1
d2868 2
a2869 1
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
d2871 1
d2874 1
a2888 1
			REASON_SET(&reason, PFRES_MEMORY);
d2992 1
a2992 1
			REASON_SET(&reason, PFRES_MEMORY);
d3022 1
d3057 2
a3058 1
	if (pf_check_congestion(ifq))
d3060 1
d3204 1
d3210 2
a3211 1
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
d3213 1
d3218 2
a3219 1
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
d3221 1
d3224 1
a3238 1
			REASON_SET(&reason, PFRES_MEMORY);
d3292 1
a3292 1
			REASON_SET(&reason, PFRES_MEMORY);
d3331 2
a3332 1
	if (pf_check_congestion(ifq))
d3334 1
d3496 1
d3502 2
a3503 1
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
d3505 1
d3510 2
a3511 1
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
d3513 1
d3516 1
a3530 1
			REASON_SET(&reason, PFRES_MEMORY);
d3578 1
a3578 1
			REASON_SET(&reason, PFRES_MEMORY);
d3613 2
a3614 1
	if (pf_check_congestion(ifq))
d3616 1
d3768 1
d3774 2
a3775 1
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
d3777 1
d3782 2
a3783 1
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
d3785 1
d3788 1
a3802 1
			REASON_SET(&reason, PFRES_MEMORY);
d3846 1
a3846 1
			REASON_SET(&reason, PFRES_MEMORY);
d3973 2
a3974 1
		if (direction != (*state)->direction)
d3976 1
d3978 2
a3979 1
			if (ntohl(th->th_seq) != (*state)->src.seqlo)
d3981 1
d3987 1
d3991 2
a3992 1
		    (ntohl(th->th_seq) != (*state)->src.seqlo + 1))
d3994 3
a3996 1
		else if ((*state)->src_node != NULL && pf_src_connlimit(state))
d3998 1
a3998 1
		else
d4014 2
a4015 1
			    (ntohl(th->th_seq) != (*state)->src.seqlo + 1))
d4017 1
d4025 1
d4029 2
a4030 1
		    (ntohl(th->th_ack) != (*state)->dst.seqhi + 1))
d4032 1
a4032 1
		else {
d4056 1
d4218 2
a4219 1
				    pf_src_connlimit(state))
d4221 1
d4346 1
d4434 1
a4434 1
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd)
d4570 1
a4570 1
			    NULL, NULL, pd2.af)) {
d4580 2
a4581 1
			if (h2.ip_off & htons(IP_OFFMASK))
d4583 1
d4599 1
a4599 1
			    NULL, NULL, pd2.af)) {
d4617 1
d4627 2
a4628 1
					    sizeof(opt6), NULL, NULL, pd2.af)) {
d4664 2
a4665 1
			if (!pf_pull_hdr(m, off2, &th, 8, NULL, NULL, pd2.af)) {
d4722 1
d4774 1
a4774 1
			    NULL, NULL, pd2.af)) {
d4841 1
a4841 1
			    NULL, NULL, pd2.af)) {
d4893 1
a4893 1
			    sizeof(struct icmp6_hdr), NULL, NULL, pd2.af)) {
d5682 3
a5684 1
	if (kif == NULL)
d5686 1
d5821 2
a5822 1
		action = pf_test_state_icmp(&s, dir, kif, m, off, h, &pd);
d5855 1
a5855 1
		REASON_SET(&reason, PFRES_SHORT);
d5998 3
a6000 1
	if (kif == NULL)
d6002 1
d6054 1
a6054 1
			    NULL, NULL, pd.af)) {
a6057 1
				REASON_SET(&reason, PFRES_SHORT);
d6090 1
d6125 1
d6161 1
d6165 1
a6165 1
		    m, off, h, &pd);
@


1.477
log
@Make carp(4) traffic always appear on the physical (carpdev) interface
from pf's perspective.

ok pascoe@@ dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.476 2004/12/22 17:17:55 dhartmei Exp $ */
d2412 1
a2412 1
			if (pf_map_addr(r->af, r, saddr, naddr, NULL, sn))
@


1.476
log
@Introduce 'set skip on <ifspec>' to support a list of interfaces where no
packet filtering should occur (like loopback, for instance).
Code from Max Laier, with minor improvements based on feedback from
deraadt@@. ok mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.475 2004/12/17 17:32:28 dhartmei Exp $ */
d5627 3
d5938 3
@


1.475
log
@ICMP state entries use the ICMP ID as port for the unique state key. When
checking for a usable key, construct the key in the same way. Otherwise,
a colliding key might be missed or a state insertion might be refused even
though it could be inserted. The second case triggers the endless loop
fixed by 1.474, possibly allowing a NATed LAN client to lock up the kernel.
Report and test data by Srebrenko Sehic.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.474 2004/12/14 03:49:06 mcbride Exp $ */
d5630 2
d5939 2
@


1.474
log
@Initialise init_addr in pf_map_addr() in the PF_POOL_ROUNDROBIN,
prevents a possible endless loop in pf_get_sport() with 'static-port'

Reported by adm at celeritystorm dot com in FreeBSD PR74930, debugging
by dhartmei@@

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.473 2004/12/11 11:45:44 mpf Exp $ */
d2169 1
a2169 1
			key.gwy.port = 0;
d3354 1
a3354 1
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
d3378 1
a3378 1
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
@


1.473
log
@Handle errors in pf_route{,6} more gracefully.
Proposed by mcbride.
ok henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.472 2004/12/10 22:13:25 henning Exp $ */
d2125 2
@


1.472
log
@allow pf to filter on route labels
pass in from route dtag keep state queue reallyslow
tested by Gabriel Kihlman <gk@@stacken.kth.se> and
Michael Knudsen <e@@molioner.dk> and ryan
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.471 2004/12/07 18:02:03 mcbride Exp $ */
d5211 6
a5216 2
	if (m0->m_len < sizeof(struct ip))
		panic("pf_route: m0->m_len < sizeof(struct ip)");
d5239 5
a5243 2
		if (TAILQ_EMPTY(&r->rpool.list))
			panic("pf_route: TAILQ_EMPTY(&r->rpool.list)");
d5266 5
a5270 2
		if (m0->m_len < sizeof(struct ip))
			panic("pf_route: m0->m_len < sizeof(struct ip)");
d5415 5
a5419 2
	if (m0->m_len < sizeof(struct ip6_hdr))
		panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
d5439 5
a5443 2
	if (TAILQ_EMPTY(&r->rpool.list))
		panic("pf_route6: TAILQ_EMPTY(&r->rpool.list)");
d5465 5
a5469 2
		if (m0->m_len < sizeof(struct ip6_hdr))
			panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
d5938 1
a5938 1
		panic("non-M_PKTHDR is passed to pf_test");
@


1.471
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.470 2004/12/07 10:33:41 dhartmei Exp $ */
d5119 43
@


1.470
log
@re-commit mcbride@@'s 'flush global', this time without the breakage in
pfvar.h. builds kernel and userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.469 2004/12/07 09:36:16 deraadt Exp $ */
d638 1
a638 1
    	    (*state)->rule.ptr->max_src_conn <
d687 1
a687 1
			
d3864 2
a3865 1
		else if (r->match_tag && !pf_match_tag(m, r, NULL, &pftag, &tag))
@


1.469
log
@tree does not compile, spotted by dlg (not obvious how to fix)
----
Change the default for 'overload <table> flush' to flush only states from the
offending source created by the rule. 'flush global' flushes all states
originating from the offending source. ABI change, requires kernel and pfctl
to be in sync.

ok deraadt@@ henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.467 2004/12/06 23:28:38 dhartmei Exp $ */
d685 1
a685 1
		if ((*state)->rule.ptr->rule_flag & PFRULE_SRCTRACK_FLUSH) {
d690 3
a692 3
				 * Kill all states from this source.
				 *
				 * XXX Kill states _to_ the source?
d700 4
a703 1
                                    &s->ext.addr, s->af)))) {
@


1.468
log
@Change the default for 'overload <table> flush' to flush only states from the
offending source created by the rule. 'flush global' flushes all states
originating from the offending source. ABI change, requires kernel and pfctl
to be in sync.

ok deraadt@@ henning@@ dhartmei@@
@
text
@d685 1
a685 1
		if ((*state)->rule.ptr->flush) {
d690 3
a692 3
				 * Kill states from this source.  (Only those
				 * from the same rule if PF_FLUSH_GLOBAL is not
				 * set)
d700 1
a700 4
                                    &s->ext.addr, s->af))) &&
				    ((*state)->rule.ptr->flush &
				    PF_FLUSH_GLOBAL ||
				    (*state)->rule.ptr == s->rule.ptr)) {
@


1.467
log
@support max-src-conn-rate with synproxy, ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.466 2004/12/05 12:12:01 dhartmei Exp $ */
d685 1
a685 1
		if ((*state)->rule.ptr->rule_flag & PFRULE_SRCTRACK_FLUSH) {
d690 3
a692 3
				 * Kill all states from this source.
				 *
				 * XXX Kill states _to_ the source?
d700 4
a703 1
                                    &s->ext.addr, s->af)))) {
@


1.466
log
@IPv6 packets can contain headers (like options) before the TCP/UDP/ICMP6
header. pf finds the first TCP/UDP/ICMP6 header to filter by traversing
the header chain. In the case where headers are skipped, the protocol
checksum verification used the wrong length (included the skipped headers),
leading to incorrectly mismatching checksums. Such IPv6 packets with
headers were silently dropped. Reported by Bernhard Schmidt. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.465 2004/12/04 07:49:48 mcbride Exp $ */
d937 3
a939 2
		    if (s->timeout >= PFTM_TCP_ESTABLISHED )
			--s->src_node->conn;
d3953 2
d4166 1
a4166 1
			if (dst->state == TCPS_SYN_SENT)
d4168 5
a4172 1
			else if (dst->state == TCPS_CLOSING)
d4192 1
a4192 5
		else {
			if ((*state)->timeout != PFTM_TCP_ESTABLISHED &&
			    (*state)->src_node != NULL &&
			    pf_src_connlimit(state))
				return (PF_DROP);
a4193 1
		}
@


1.465
log
@Add kernel code to keep track of tcp connections which have completed
the 3-way handshake. Allow limits on both total connections and connection
rate, put offenders in a table which can be used in the ruleset, and optionally
kill existing states. Rate tracking code from dhartmei@@.

Adds a second pool for table entries using the default allocator, which
allows entries to be added at splsoftnet().

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.464 2004/11/24 00:36:10 dhartmei Exp $ */
d5472 1
a5472 1
		switch (af) {
d5950 2
a5951 1
		    ntohs(h->ip6_plen), IPPROTO_TCP, AF_INET6)) {
d5984 2
a5985 1
		    off, ntohs(h->ip6_plen), IPPROTO_UDP, AF_INET6)) {
d6019 2
a6020 1
		    ntohs(h->ip6_plen), IPPROTO_ICMPV6, AF_INET6)) {
@


1.464
log
@fix a bug that leads to a crash when binat rules of the form
'binat from ... to ... -> (if)' are used, where the interface
is dynamic. reported by kos(at)bastard(dot)net, analyzed by
Pyun YongHyeon
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.463 2004/11/19 18:20:10 dhartmei Exp $ */
d122 5
d218 1
d230 1
a230 1
			*state = pf_find_state_recurse(		\
d233 1
a233 1
			*state = pf_find_state_recurse(		\
d235 1
a235 1
		if (*state == NULL)					\
d598 122
d741 2
d746 5
d776 2
a777 1
		    (*sn)->states >= rule->max_src_states)
d779 1
d936 4
d2844 2
a2845 1
		if (r->max_states && (r->states >= r->max_states))
d2847 1
d3186 2
a3187 1
		if (r->max_states && (r->states >= r->max_states))
d3189 1
d3471 2
a3472 1
		if (r->max_states && (r->states >= r->max_states))
d3474 1
d3736 2
a3737 1
		if (r->max_states && (r->states >= r->max_states))
d3739 1
d4185 5
a4189 1
		else
d4191 1
a4295 1

@


1.463
log
@remove superfluous m_tag_copy/m_tag_prepend, already covered by m_copym2()
reported by Joerg Sonnenberger, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.462 2004/11/12 19:44:44 dhartmei Exp $ */
d2227 1
a2227 1
				if (r->rpool.cur->addr.type == PF_ADDR_DYNIFTL){
@


1.462
log
@The flag to re-filter pf-generated packets was set wrong by synproxy
for ACKs. It should filter the ACK replayed to the server, instead of
of the one to the client. Thanks to Daniel Polak for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.461 2004/11/07 01:16:52 dhartmei Exp $ */
a5002 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
a5196 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
@


1.461
log
@For RST generated due to state mismatch during handshake, don't set
th_flags TH_ACK and leave th_ack 0, just like the RST generated by
the stack in this case. Fixes the Raptor workaround. ok beck@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.460 2004/09/29 10:32:33 dhartmei Exp $ */
d3839 1
a3839 1
			    TH_ACK, (*state)->src.max_win, 0, 0, 1,
d3844 1
a3844 1
			    TH_ACK, (*state)->dst.max_win, 0, 0, 0,
@


1.460
log
@reset anchor pointer to NULL when stepping back into the main ruleset,
fixes pflog attributing states wrongly to anchors and pfctl -vvsn/sr
showing wrong state counters for anchor rules. found by camield@@,
ok henning@@, -stable candidate
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.459 2004/09/20 19:56:01 henning Exp $ */
d4112 1
a4112 7
			if (!(th->th_flags & TH_RST)) {
				u_int32_t ack = ntohl(th->th_seq) + pd->p_len;

				if (th->th_flags & TH_SYN)
					ack++;
				if (th->th_flags & TH_FIN)
					ack++;
d4115 2
a4116 2
				    th->th_sport, ntohl(th->th_ack), ack,
				    TH_RST|TH_ACK, 0, 0,
a4118 1
			}
@


1.459
log
@pf_routable(), used for the no-route keyword, was a v4 only implementation,
and behaved incorrectly when used with v6. impliment the v6 case too.
ok canacar mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.458 2004/09/17 21:49:15 mcbride Exp $ */
d1696 2
@


1.458
log
@Clean up reference counting wrt state creation and destruction. Fixes
problems with adaptive timeouts, max-states limits, and rules not being
freed from memory.

Diff from Chris Pascoe.

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.457 2004/07/11 15:54:21 itojun Exp $ */
d4930 4
d4935 1
a4935 1
	int			 ret = 0;
d4938 20
a4957 5
	dst = satosin(&ro.ro_dst);
	dst->sin_family = af;
	dst->sin_len = sizeof(*dst);
	dst->sin_addr = addr->v4;
	rtalloc_noclone(&ro, NO_CLONING);
a4959 1
		ret = 1;
d4961 1
d4964 1
a4964 1
	return (ret);
@


1.457
log
@backout IPv6 reass-on-scrub patch (more work needs to be done).
requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.454 2004/06/22 07:35:19 cedric Exp $ */
d253 18
a2733 3
		r->states++;
		if (a != NULL)
			a->states++;
a2735 2
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
d2737 1
d2816 1
d2828 1
d2836 1
a3073 3
		r->states++;
		if (a != NULL)
			a->states++;
a3075 2
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
d3077 1
d3126 1
a3356 3
		r->states++;
		if (a != NULL)
			a->states++;
a3358 2
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
d3360 1
d3403 1
a3619 3
		r->states++;
		if (a != NULL)
			a->states++;
a3621 2
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
d3623 1
d3662 1
@


1.457.2.1
log
@MFC:
Fix by dhartmei@@

reset anchor pointer to NULL when stepping back into the main ruleset,
fixes pflog attributing states wrongly to anchors and pfctl -vvsn/sr
showing wrong state counters for anchor rules. found by camield@@

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.457 2004/07/11 15:54:21 itojun Exp $ */
a1677 2
		if (*depth == 0 && a != NULL)
			*a = NULL;
@


1.457.2.2
log
@MFC:
Fix by dhartmei@@

For RST generated due to state mismatch during handshake, don't set
th_flags TH_ACK and leave th_ack 0, just like the RST generated by
the stack in this case. Fixes the Raptor workaround.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.457.2.1 2004/11/06 00:39:35 brad Exp $ */
d4104 7
a4110 1
			if (!(th->th_flags & TH_RST))
d4113 2
a4114 2
				    th->th_sport, ntohl(th->th_ack), 0,
				    TH_RST, 0, 0,
d4117 1
@


1.457.2.3
log
@MFC:
Fix by dhartmei@@

The flag to re-filter pf-generated packets was set wrong by synproxy
for ACKs. It should filter the ACK replayed to the server, instead of
of the one to the client.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.457.2.2 2004/11/13 23:46:26 brad Exp $ */
d3831 1
a3831 1
			    TH_ACK, (*state)->src.max_win, 0, 0, 0,
d3836 1
a3836 1
			    TH_ACK, (*state)->dst.max_win, 0, 0, 1,
@


1.457.2.4
log
@MFC:
Fix by dhartmei@@

fix a bug that leads to a crash when binat rules of the form
'binat from ... to ... -> (if)' are used, where the interface
is dynamic. reported by kos(at)bastard(dot)net, analyzed by
Pyun YongHyeon

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.457.2.3 2004/11/13 23:48:51 brad Exp $ */
d2209 1
a2209 1
				if (r->src.addr.type == PF_ADDR_DYNIFTL) {
@


1.457.2.5
log
@MFC:
Fix by mcbride@@

Initialise init_addr in pf_map_addr() in the PF_POOL_ROUNDROBIN,
prevents a possible endless loop in pf_get_sport() with 'static-port'

Reported by adm at celeritystorm dot com in FreeBSD PR74930, debugging
by dhartmei@@

ok mcbride@@ dhartmei@@ deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.457.2.4 2004/11/28 06:21:44 brad Exp $ */
a1961 2
		if (init_addr != NULL && PF_AZERO(init_addr, af))
			PF_ACPY(init_addr, naddr, af);
@


1.457.2.6
log
@MFC:
Fix by dhartmei@@

IPv6 packets can contain headers (like options) before the TCP/UDP/ICMP6
header. pf finds the first TCP/UDP/ICMP6 header to filter by traversing
the header chain. In the case where headers are skipped, the protocol
checksum verification used the wrong length (included the skipped headers),
leading to incorrectly mismatching checksums. Such IPv6 packets with
headers were silently dropped. Reported by Bernhard Schmidt.

ok deraadt@@ dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.457.2.5 2004/12/16 02:04:55 brad Exp $ */
d5778 1
a5778 2
		    ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_TCP, AF_INET6)) {
d5811 1
a5811 2
		    off, ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_UDP, AF_INET6)) {
d5845 1
a5845 2
		    ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_ICMPV6, AF_INET6)) {
@


1.457.2.7
log
@MFC:
Fix by dhartmei@@

ICMP state entries use the ICMP ID as port for the unique state key. When
checking for a usable key, construct the key in the same way. Otherwise,
a colliding key might be missed or a state insertion might be refused even
though it could be inserted. The second case triggers the endless loop
fixed by 1.474, possibly allowing a NATed LAN client to lock up the kernel.
Report and test data by Srebrenko Sehic.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.457.2.6 2004/12/19 18:48:57 brad Exp $ */
d2006 1
a2006 1
			key.gwy.port = dport;
d3191 1
a3191 1
		    saddr, icmpid, daddr, icmpid, &pd->naddr, NULL)) != NULL) {
d3215 1
a3215 1
		    saddr, icmpid, daddr, icmpid, &pd->naddr, NULL)) != NULL) {
@


1.457.2.8
log
@MFC:
Fix by dhartmei@@

Use the packet's address family instead of the rule's when selecting a
replacement address for an rdr rule. Some rdr rules have no address family
(when the replacement is a table and no other criterion implies one AF).
In this case, pf would fail to select a replacement address and drop the
packet due to translation failure. Found by Gustavo A. Baratto.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.457.2.7 2005/01/06 14:11:56 brad Exp $ */
d2249 1
a2249 1
			if (pf_map_addr(pd->af, r, saddr, naddr, NULL, sn))
@


1.456
log
@correct "scrub in" behavior for IPv6.
remaining TODO:
- "forward" case kernel behavior (IPv4 too), then pfctl syntax change
- red-black tree
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.455 2004/06/25 00:42:58 itojun Exp $ */
a55 1
#include <net/netisr.h>
d1303 1
a1303 1
		struct m_tag *mtag;
d5683 1
a5683 2
	struct mbuf		*m = *m0, *n;
	struct mbuf		*frag;
d5712 2
a5713 9
	/*
	 * We do IP header normalization and packet reassembly here.
	 * due to KAME mbuf handling rule, pf_normalize_ip6 may lose mbuf,
	 * so keep a copy here.
	 */
	frag = NULL;
	n = m_copym(*m0, 0, M_COPYALL, M_DONTWAIT);
	m = *m0;
	if (pf_normalize_ip6(m0, dir, kif, &reason, &pd, &frag) != PF_PASS) {
a5714 4
		if (!*m0)
			*m0 = n;
		else
			m_freem(n);
a5716 4
	if (!*m0)
		*m0 = n;
	else
		m_freem(n);
d5733 6
a5762 1
		case IPPROTO_FRAGMENT:
a5989 71
	/*
	 * it's the tricky part - how to return value is different by caller
	 */
	switch (dir) {
	case PF_IN:
		if (frag) {
			int s;
			struct mbuf *q, *r;
			struct m_tag *mtag;

			if (action != PF_PASS) {
				for (q = frag; q; q = r) {
					r = q->m_nextpkt;
					q->m_nextpkt = NULL;
					m_freem(q);
					q = NULL;
				}
				return (action);
			}

			for (q = frag; q; q = r) {
				r = q->m_nextpkt;
				q->m_nextpkt = NULL;

				mtag = m_tag_get(PACKET_TAG_PF_FRAGCACHE,
				    0, M_NOWAIT);
				if (mtag == NULL) {
					s = splimp();
					IF_DROP(&ip6intrq);
					splx(s);
					m_freem(q);
					q = NULL;
					continue;
				}
				m_tag_prepend(q, mtag);

				s = splimp();
				IF_ENQUEUE(&ip6intrq, q);
				q = NULL;
				splx(s);
			}
			schednetisr(NETISR_IPV6);

			m_freem(*m0);
			*m0 = NULL;
		}
		return (PF_PASS);

	case PF_OUT:
		if (frag) {
			struct mbuf *q, *r;
			for (q = frag; q; q = r) {
				r = q->m_nextpkt;
				q->m_nextpkt = NULL;
				m_freem(q);
				q = NULL;
			}
		}
		break;

	case PF_FORWARD:
		if (action == PF_PASS) {
			if (frag) {
				m_freem(*m0);
				*m0 = NULL;
				*m0 = frag;
			} else
				(*m0)->m_nextpkt = NULL;
		}
		break;
	}
@


1.455
log
@IPv6 reassembly on "scrub" directive.

caveats: (to be addressed soon)
- "scrub in" should queue fragments back into ip6intrq again, but
  somehow it does not happen - the packet is kept inside reass queue.
  need investigation
- ip6_forwarding path is not tested
- does not use red-black tree.  somehow red-black tree behaved badly
  and was not robust.  performance issue, the above one is more
  important.

good things:
- "scrub out" is perfectly ok
- i think now we can inspect upper-layer protocol fields (tcp port)
  even if ip6 packet is fragmented.
- reass queue will be cleaned up properly by timeout (60sec).  we might
  want to impose pool limit as well
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.454 2004/06/22 07:35:19 cedric Exp $ */
d6047 2
a6048 3
			return (PF_PASS);
		} else
			break;
@


1.454
log
@Pull the plug on source-based routing until remaining bugs are eradicated.
No need to reconfig kernel or rebuild userland stuff.
requested deraadt@@, help beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.453 2004/06/21 23:50:36 tholo Exp $ */
d56 1
d1304 1
a1304 1
		struct m_tag	*mtag;
d5684 2
a5685 1
	struct mbuf		*m = *m0;
d5714 9
a5722 2
	/* We do IP header normalization and packet reassembly here */
	if (pf_normalize_ip6(m0, dir, kif, &reason, &pd) != PF_PASS) {
d5724 4
d5730 4
a5749 6
		case IPPROTO_FRAGMENT:
			action = pf_test_fragment(&r, dir, kif, m, h,
			    &pd, &a, &ruleset);
			if (action == PF_DROP)
				REASON_SET(&reason, PFRES_FRAG);
			goto done;
d5774 1
d6002 72
@


1.453
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.452 2004/06/21 19:26:01 mcbride Exp $ */
d202 2
a203 2
u_int16_t		 pf_calc_mss(struct pf_addr *, struct pf_addr *,
			    sa_family_t, u_int16_t);
d2418 1
a2418 2
pf_calc_mss(struct pf_addr *saddr, struct pf_addr *daddr, sa_family_t af,
    u_int16_t offer)
d2421 1
a2421 1
	struct sockaddr_rtin	*dst;
d2437 4
a2440 5
		dst = satortin(&ro.ro_dst);
		dst->rtin_family = AF_INET;
		dst->rtin_len = sizeof(*dst);
		dst->rtin_dst = daddr->v4;
		dst->rtin_src = saddr->v4;
d2452 1
a2452 1
		dst6->sin6_addr = daddr->v6;
d2841 2
a2842 2
			mss = pf_calc_mss(saddr, daddr, af, mss);
			mss = pf_calc_mss(daddr, saddr, af, mss);
a5001 1
		satortin(&ro->ro_dst)->rtin_src = ip->ip_src;
a5002 1
		satortin(&ro->ro_dst)->rtin_src.s_addr = 0;
@


1.452
log
@Get rid of pf_test_eh() wrapper.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.451 2004/06/10 14:22:54 dhartmei Exp $ */
d615 1
a615 1
		(*sn)->creation = time.tv_sec;
d726 1
a726 1
		return (time.tv_sec);
d747 1
a747 1
			return (time.tv_sec);
d760 1
a760 1
		 if (cur->states <= 0 && cur->expire <= time.tv_sec) {
d786 1
a786 1
			s->src_node->expire = time.tv_sec + timeout;
d795 1
a795 1
			s->nat_src_node->expire = time.tv_sec + timeout;
d845 1
a845 1
		if (pf_state_expires(cur) <= time.tv_sec)
d2787 2
a2788 2
		s->creation = time.tv_sec;
		s->expire = time.tv_sec;
d3099 2
a3100 2
		s->creation = time.tv_sec;
		s->expire = time.tv_sec;
d3379 2
a3380 2
		s->creation = time.tv_sec;
		s->expire = time.tv_sec;
d3641 2
a3642 2
		s->creation = time.tv_sec;
		s->expire = time.tv_sec;
d4015 1
a4015 1
		(*state)->expire = time.tv_sec;
d4203 1
a4203 1
	(*state)->expire = time.tv_sec;
d4288 1
a4288 1
		(*state)->expire = time.tv_sec;
d4826 1
a4826 1
	(*state)->expire = time.tv_sec;
@


1.451
log
@rename struct pf_rule_addr member 'not' to 'neg', as 'not' is a reserved
keyword in C++. ok henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.450 2004/06/06 16:49:08 cedric Exp $ */
d5038 1
a5038 1
		if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
d5231 1
a5231 1
		if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
d5375 1
a5375 7
pf_test(int dir, struct ifnet *ifp, struct mbuf **m0)
{
	return pf_test_eh(dir, ifp, m0, NULL);
}

int
pf_test_eh(int dir, struct ifnet *ifp, struct mbuf **m0,
d5682 1
a5682 7
pf_test6(int dir, struct ifnet *ifp, struct mbuf **m0)
{
	return pf_test6_eh(dir, ifp, m0, NULL);
}

int
pf_test6_eh(int dir, struct ifnet *ifp, struct mbuf **m0,
@


1.450
log
@extend routing table to be able to match and route packets based on
their *source* IP address in addition to their destination address.
routing table "destination" now contains a "struct sockaddr_rtin"
for IPv4 instead of a "struct sockaddr_in".
the routing socket has been extended in a backward-compatible way.
todo: PMTU enhancements, IPv6. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.449 2004/05/19 17:50:51 dhartmei Exp $ */
d1036 1
a1036 1
		if (cur->src.not != prev->src.not ||
d1043 1
a1043 1
		if (cur->dst.not != prev->dst.not ||
d2094 1
a2094 1
		else if (PF_MISMATCHAW(&src->addr, saddr, pd->af, src->not))
d2102 1
a2102 1
		    PF_MISMATCHAW(&dst->addr, daddr, pd->af, dst->not))
d2567 1
a2567 1
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
d2572 1
a2572 1
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
d2929 1
a2929 1
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
d2934 1
a2934 1
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
d3247 1
a3247 1
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
d3249 1
a3249 1
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
d3489 1
a3489 1
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.not))
d3491 1
a3491 1
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.not))
d3691 1
a3691 1
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.not))
d3693 1
a3693 1
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.not))
d5665 1
a5665 1
			    tr->src.not);
d5670 1
a5670 1
			    tr->dst.not);
d5989 1
a5989 1
			    tr->src.not);
d5994 1
a5994 1
			    tr->dst.not);
@


1.449
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.448 2004/05/11 07:34:11 dhartmei Exp $ */
d202 2
a203 2
u_int16_t		 pf_calc_mss(struct pf_addr *, sa_family_t,
				u_int16_t);
d2418 2
a2419 1
pf_calc_mss(struct pf_addr *addr, sa_family_t af, u_int16_t offer)
d2422 1
a2422 1
	struct sockaddr_in	*dst;
d2438 5
a2442 4
		dst = (struct sockaddr_in *)&ro.ro_dst;
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = addr->v4;
d2454 1
a2454 1
		dst6->sin6_addr = addr->v6;
d2843 2
a2844 2
			mss = pf_calc_mss(saddr, af, mss);
			mss = pf_calc_mss(daddr, af, mss);
d5004 1
d5006 1
@


1.448
log
@pf_cksum_fixup() was called without last argument from normalization,
also fixup checksum when random-id modifies ip_id. This would previously
lead to incorrect checksums for packets modified by scrub random-id.
From Pyun YongHyeon. ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.447 2004/05/11 07:06:52 dhartmei Exp $ */
d95 1
a95 1
struct pf_anchorqueue	 pf_anchors;
d110 7
d260 1
d274 2
d472 8
d1624 37
a1660 16
#define PF_STEP_INTO_ANCHOR(r, a, s, n)					\
	do {								\
		if ((r) == NULL || (r)->anchor == NULL ||		\
		    (s) != NULL || (a) != NULL)				\
			panic("PF_STEP_INTO_ANCHOR");			\
		(a) = (r);						\
		(s) = TAILQ_FIRST(&(r)->anchor->rulesets);		\
		(r) = NULL;						\
		while ((s) != NULL && ((r) =				\
		    TAILQ_FIRST((s)->rules[n].active.ptr)) == NULL)	\
			(s) = TAILQ_NEXT((s), entries);			\
		if ((r) == NULL) {					\
			(r) = TAILQ_NEXT((a), entries);			\
			(a) = NULL;					\
		}							\
	} while (0)
d1662 20
a1681 13
#define PF_STEP_OUT_OF_ANCHOR(r, a, s, n)				\
	do {								\
		if ((r) != NULL || (a) == NULL || (s) == NULL)		\
			panic("PF_STEP_OUT_OF_ANCHOR");			\
		(s) = TAILQ_NEXT((s), entries);				\
		while ((s) != NULL && ((r) =				\
		    TAILQ_FIRST((s)->rules[n].active.ptr)) == NULL)	\
			(s) = TAILQ_NEXT((s), entries);			\
		if ((r) == NULL) {					\
			(r) = TAILQ_NEXT((a), entries);			\
			(a) = NULL;					\
		}							\
	} while (0)
d2066 1
a2066 1
	struct pf_rule		*r, *rm = NULL, *anchorrule = NULL;
d2068 1
d2117 3
a2119 4
			PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset, rs_num);
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
			    rs_num);
d2517 1
d2609 2
a2610 2
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
d2612 3
a2614 3
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
d2879 1
d2968 2
a2969 2
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
d2971 3
a2973 3
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
d3147 1
d3274 2
a3275 2
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
d3277 3
a3279 3
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
d3423 1
d3512 2
a3513 2
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
d3515 3
a3517 3
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
d3675 1
d3712 2
a3713 2
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
d3715 3
a3717 3
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
@


1.447
log
@change pf_route() loop detection: introduce a counter (number of times
a packet is routed already) in the mbuf tag, allow at most four times.
Fixes some legitimate cases broken by the previous change. ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.446 2004/05/05 23:16:03 frantzen Exp $ */
a114 2
u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t,
			    u_int8_t);
@


1.446
log
@Use RFC1323 PAWS timestamps as a logical extension to the conventional TCP
sequence numbers by taking advantage of the maximum 1KHz clock as an upperbound
on the timestamp.  Typically gains 10 to 18 bits of additional security against
blind data insertion attacks.  More if the TS Echo wasn't optional :-(
Enabled with:  scrub on !lo0 all reassemble tcp
ok dhartmei@@.  documentation help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.445 2004/04/28 02:51:58 cedric Exp $ */
d4897 1
a4902 1
	struct m_tag		*mtag;
d4911 18
d4930 1
a4930 10
		m0 = *m;
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
		}
		m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT);
		if (m0 == NULL)
d4932 3
a4980 1

a4983 7
	if (m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL) != NULL)
		goto bad;
	mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
	if (mtag == NULL)
		goto bad;
	m_tag_prepend(m0, mtag);

d5108 18
d5127 1
a5127 10
		m0 = *m;
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
		}
		m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT);
		if (m0 == NULL)
d5129 3
a5173 1

d5178 7
a5184 11
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
			if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
				goto bad;
			else if (m0 == NULL)
				goto done;
		}
@


1.445
log
@make return-rst work on pure bridges. ok dhartmei@@ henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.444 2004/04/28 02:43:08 pb Exp $ */
a113 2
void			 pf_print_state(struct pf_state *);
void			 pf_print_flags(u_int8_t);
d2761 5
a2765 2
		    pf_normalize_tcp_stateful(m, off, pd, &reason, th, &s->src,
		    &s->dst, &rewrite)) {
d3930 6
d4020 6
a4090 5
	if (dst->scrub || src->scrub) {
		if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
		    src, dst, &copyback))
			return (PF_DROP);
	}
@


1.444
log
@Dont step into INET6 code, just because af != AF_INET
Also comment #endif properly while being here

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.443 2004/04/27 18:28:07 frantzen Exp $ */
d71 1
d133 2
a134 1
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t, int);
d795 1
a795 1
		    TH_RST|TH_ACK, 0, 0, 0, 1);
a830 1

d1252 2
a1253 1
    u_int8_t flags, u_int16_t win, u_int16_t mss, u_int8_t ttl, int tag)
d1378 22
a1399 2
		ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL,
		    (void *)NULL);
d2613 1
a2613 1
			    r->return_ttl, 1);
d2800 1
a2800 1
			    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1);
d3736 2
a3737 1
			    TH_SYN|TH_ACK, 0, (*state)->src.mss, 0, 1);
d3767 1
a3767 1
			    (*state)->src.mss, 0, 0);
d3779 2
a3780 1
			    TH_ACK, (*state)->src.max_win, 0, 0, 1);
d3784 2
a3785 1
			    TH_ACK, (*state)->dst.max_win, 0, 0, 0);
d4051 2
a4052 1
				    (*state)->rule.ptr->return_ttl, 1);
d5305 7
d5367 1
d5618 7
d5671 1
@


1.443
log
@validate the sequence numbers on TCP resets are an exact match.  check is only
enabled when we're doing full frag reassembly and thus have full seq info
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.442 2004/04/26 02:03:38 mcbride Exp $ */
d482 1
a482 1
#endif
d1311 1
a1311 1
#endif
d1426 1
a1426 1
#endif
d1771 3
a1773 1
		if (af == AF_INET) {
d1780 4
a1783 1
		} else {
d1790 2
d2108 3
a2110 1
					if (pd->af == AF_INET) {
d2120 4
a2123 1
					} else {
d2133 2
d2144 3
a2146 1
					if (pd->af == AF_INET) {
d2156 4
a2159 1
					} else {
d2169 2
d2246 1
d2255 1
d5210 1
d5226 1
d5300 1
a5300 1
#endif
d5369 1
a5369 1
#endif
d5403 1
a5403 1
#endif
d5431 1
a5431 1
#endif
d5446 1
a5446 1
#endif
d5484 1
a5484 1
#endif
d5605 1
a5605 1
#endif
d5696 1
a5696 1
#endif
d5730 1
a5730 1
#endif
d5759 1
a5759 1
#endif
d5774 1
a5774 1
#endif
d5805 1
a5805 1
#endif
@


1.442
log
@Prevent biases in arc4random() from disclosing the byte order of the firewall.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.441 2004/04/26 00:12:27 cedric Exp $ */
d3652 1
a3652 1
	u_int32_t		 ack, end, seq;
d3765 1
a3765 1
	seq = ntohl(th->th_seq);
d3875 1
a3875 1
	    (ackskew <= (MAXACKWINDOW << sws))) {
d3877 3
d5286 1
a5286 1
	if (pf_normalize_ip(m0, dir, kif, &reason) != PF_PASS) {
d5591 1
a5591 1
	if (pf_normalize_ip6(m0, dir, kif, &reason) != PF_PASS) {
@


1.441
log
@anchor refcounting. ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.440 2004/04/25 18:45:57 dhartmei Exp $ */
d1806 1
a1806 1
				rpool->counter.addr32[0] = arc4random();
d1812 2
a1813 1
					rpool->counter.addr32[3] = arc4random();
d1817 2
a1818 1
					rpool->counter.addr32[2] = arc4random();
d1822 2
a1823 1
					rpool->counter.addr32[1] = arc4random();
d1827 2
a1828 1
					rpool->counter.addr32[0] = arc4random();
d1953 1
a1953 1
			cut = arc4random() % (1 + high - low) + low;
d2672 1
a2672 1
			while ((s->src.seqdiff = arc4random()) == 0)
d2747 1
a2747 1
			s->src.seqhi = arc4random();
d3717 1
a3717 1
				(*state)->dst.seqhi = arc4random();
d3779 1
a3779 1
			while ((src->seqdiff = arc4random()) == 0)
@


1.440
log
@prevent an endless loop with route-to lo0, fixes PR 3736,
ok pb@@, henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.439 2004/04/25 18:09:29 pb Exp $ */
a1066 15
void
pf_update_anchor_rules()
{
	struct pf_rule	*rule;
	int		 i;

	for (i = 0; i < PF_RULESET_MAX; ++i)
		TAILQ_FOREACH(rule, pf_main_ruleset.rules[i].active.ptr,
		    entries)
			if (rule->anchorname[0])
				rule->anchor = pf_find_anchor(rule->anchorname);
			else
				rule->anchor = NULL;
}

a2037 2
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
a2502 2
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
a2858 2
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
a3163 2
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
a3400 2
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
a3602 2
			r = TAILQ_NEXT(r, entries);
		else if (r->anchorname[0] && r->anchor == NULL)
@


1.439
log
@get rid of a complete state tree walk at state expire while in splnet()

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.438 2004/04/25 02:32:35 pb Exp $ */
d4936 6
a4941 9
	mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
	if (mtag == NULL) {
		struct m_tag *mtag;

		mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
		if (mtag == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
	}
d4943 1
a4943 1
	if (oifp != ifp && mtag == NULL) {
@


1.438
log
@sync 'other' in test6, too.

ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.437 2004/04/25 00:34:08 dhartmei Exp $ */
d786 36
d830 2
a831 33
		if (pf_state_expires(cur) <= time.tv_sec) {
			if (cur->src.state == PF_TCPS_PROXY_DST)
				pf_send_tcp(cur->rule.ptr, cur->af,
				    &cur->ext.addr, &cur->lan.addr,
				    cur->ext.port, cur->lan.port,
				    cur->src.seqhi, cur->src.seqlo + 1,
				    TH_RST|TH_ACK, 0, 0, 0, 1);
			RB_REMOVE(pf_state_tree_ext_gwy,
			    &cur->u.s.kif->pfik_ext_gwy, cur);
			RB_REMOVE(pf_state_tree_lan_ext,
			    &cur->u.s.kif->pfik_lan_ext, cur);
			RB_REMOVE(pf_state_tree_id, &tree_id, cur);
#if NPFSYNC
			pfsync_delete_state(cur);
#endif
			pf_src_tree_remove_state(cur);
			if (--cur->rule.ptr->states <= 0 &&
			    cur->rule.ptr->src_nodes <= 0)
				pf_rm_rule(NULL, cur->rule.ptr);
			if (cur->nat_rule.ptr != NULL)
				if (--cur->nat_rule.ptr->states <= 0 &&
					cur->nat_rule.ptr->src_nodes <= 0)
					pf_rm_rule(NULL, cur->nat_rule.ptr);
			if (cur->anchor.ptr != NULL)
				if (--cur->anchor.ptr->states <= 0)
					pf_rm_rule(NULL, cur->anchor.ptr);
			pf_normalize_tcp_cleanup(cur);
			pfi_detach_state(cur->u.s.kif);
			TAILQ_REMOVE(&state_updates, cur, u.s.entry_updates);
			pool_put(&pf_state_pl, cur);
			pf_status.fcounters[FCNT_STATE_REMOVALS]++;
			pf_status.states--;
		}
@


1.437
log
@don't add PF_GENERATED tag to synproxy generated packets for the second
handshake, so they can match rules (and create state) on another interface.
ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.436 2004/04/24 23:22:54 cedric Exp $ */
d5765 3
@


1.436
log
@Add "probability xxx" rule modifier. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.435 2004/04/17 00:13:36 henning Exp $ */
d132 1
a132 1
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t);
d799 2
a800 2
				    cur->src.seqhi, cur->src.seqlo + 1, 0,
				    TH_RST|TH_ACK, 0, 0);
d1261 1
a1261 1
    u_int8_t flags, u_int16_t win, u_int16_t mss, u_int8_t ttl)
a1263 1
	struct m_tag	*mtag;
a1292 3
	mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
	if (mtag == NULL)
		return;
d1294 1
a1294 2
	if (m == NULL) {
		m_tag_free(mtag);
d1296 9
a1305 1
	m_tag_prepend(m, mtag);
d1308 1
d2578 1
a2578 1
			    r->return_ttl);
d2765 1
a2765 1
			    TH_SYN|TH_ACK, 0, s->src.mss, 0);
d3709 1
a3709 1
			    TH_SYN|TH_ACK, 0, (*state)->src.mss, 0);
d3739 1
a3739 1
			    (*state)->src.mss, 0);
d3751 1
a3751 1
			    TH_ACK, (*state)->src.max_win, 0, 0);
d3755 1
a3755 1
			    TH_ACK, (*state)->dst.max_win, 0, 0);
d4018 1
a4018 1
				    (*state)->rule.ptr->return_ttl);
@


1.435
log
@when the input queue congestion flag is set stop evaluating the ruleset
and block unconditionally.
when the inout queue is full, newly arriving packets are dropped anyway,
and while the input queue is full we obviously have a CPU laod problem.
with this change, we allow the machine to recover gracefully, dropping a few
packets fast instead of a lot slowly over a long time while processing rather
old stuff in the input queue, giving somebody a chance to log in on the
console and fix stuff instead of going completely unresponsive, and as a nice
side effect, let established connections alone.
ok kjc@@ markus@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.434 2004/04/05 08:19:49 dhartmei Exp $ */
d2507 2
d2865 2
d3172 2
d3411 2
d3615 2
@


1.434
log
@make pftag ** (pass pointer by reference), otherwise it's never updated.
the parameter serves only as optimization to cache m_tag_get() results.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.433 2004/03/26 22:20:57 dhartmei Exp $ */
d147 1
a147 1
			    struct pf_ruleset **);
d151 1
a151 1
			    struct pf_ruleset **);
d155 1
a155 1
			    struct pf_ruleset **);
d159 1
a159 1
			    struct pf_ruleset **);
d208 1
d2415 2
a2416 1
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
d2435 3
d2774 2
a2775 1
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
d2793 3
d3041 2
a3042 1
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
d3060 3
d3323 1
a3323 1
    struct pf_rule **am, struct pf_ruleset **rsm)
d3335 3
d5354 1
a5354 1
			    m, off, h, &pd, &a, &ruleset);
d5388 1
a5388 1
			    m, off, h, &pd, &a, &ruleset);
d5416 1
a5416 1
			    m, off, h, &pd, &a, &ruleset);
d5431 1
a5431 1
			    &pd, &a, &ruleset);
d5681 1
a5681 1
			    m, off, h, &pd, &a, &ruleset);
d5715 1
a5715 1
			    m, off, h, &pd, &a, &ruleset);
d5744 1
a5744 1
			    m, off, h, &pd, &a, &ruleset);
d5756 1
a5756 1
			    &pd, &a, &ruleset);
d5871 9
@


1.433
log
@Properly m_copyback() modified TCP sequence number after demodulation
ok mcbride@@, henning@@, cedric@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.432 2004/03/25 03:03:49 mcbride Exp $ */
d177 1
a177 1
			     struct pf_rule *, struct pf_tag *, int *);
d1557 1
a1557 1
    struct pf_tag *pftag, int *tag)
d1560 3
a1562 3
		pftag = pf_get_tag(m);
		if (pftag != NULL)
			*tag = pftag->tag;
d2502 1
a2502 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
d2854 1
a2854 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
d3155 1
a3155 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
d3389 1
a3389 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
d3592 1
a3592 1
		else if (r->match_tag && !pf_match_tag(m, r, NULL, pftag, &tag))
@


1.433.2.1
log
@MFC:
Fix by dhartmei@@

prevent an endless loop with route-to lo0, fixes PR 3736

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.433 2004/03/26 22:20:57 dhartmei Exp $ */
d4901 9
a4909 6
	if (m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL) != NULL)
		goto bad;
	mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
	if (mtag == NULL)
		goto bad;
	m_tag_prepend(m0, mtag);
d4911 1
a4911 1
	if (oifp != ifp) {
@


1.433.2.2
log
@MFC:
Fix by dhartmei@@

change pf_route() loop detection: introduce a counter (number of times
a packet is routed already) in the mbuf tag, allow at most four times.
Fixes some legitimate cases broken by the previous change.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.433.2.1 2004/04/30 21:46:33 brad Exp $ */
a4824 1
	struct m_tag		*mtag;
d4830 1
d4839 8
a4846 6
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
d4848 2
a4849 13
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
a4850 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
d4897 1
d4901 7
d5032 8
a5039 6
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
d5041 2
a5042 13
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
a5043 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
d5086 1
d5091 11
a5101 7
		if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip6_hdr))
			panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
		ip6 = mtod(m0, struct ip6_hdr *);
@


1.433.2.3
log
@MFC:
Fix by dhartmei@@

For RST generated due to state mismatch during handshake, don't set
th_flags TH_ACK and leave th_ack 0, just like the RST generated by
the stack in this case. Fixes the Raptor workaround.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.433.2.2 2004/07/17 03:22:34 brad Exp $ */
d3977 7
a3983 1
			if (!(th->th_flags & TH_RST))
d3986 2
a3987 2
				    th->th_sport, ntohl(th->th_ack), 0,
				    TH_RST, 0, 0,
d3989 1
@


1.433.2.4
log
@MFC:
Fix by dhartmei@@

fix a bug that leads to a crash when binat rules of the form
'binat from ... to ... -> (if)' are used, where the interface
is dynamic. reported by kos(at)bastard(dot)net, analyzed by
Pyun YongHyeon

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.433.2.3 2004/11/13 23:24:37 brad Exp $ */
d2132 1
a2132 1
				if (r->src.addr.type == PF_ADDR_DYNIFTL) {
@


1.433.2.5
log
@MFC:
Fix by mcbride@@

Initialise init_addr in pf_map_addr() in the PF_POOL_ROUNDROBIN,
prevents a possible endless loop in pf_get_sport() with 'static-port'

Reported by adm at celeritystorm dot com in FreeBSD PR74930, debugging
by dhartmei@@

ok mcbride@@ dhartmei@@ deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.433.2.4 2004/11/28 19:55:33 brad Exp $ */
a1889 2
		if (init_addr != NULL && PF_AZERO(init_addr, af))
			PF_ACPY(init_addr, naddr, af);
@


1.433.2.6
log
@MFC:
Fix by dhartmei@@

IPv6 packets can contain headers (like options) before the TCP/UDP/ICMP6
header. pf finds the first TCP/UDP/ICMP6 header to filter by traversing
the header chain. In the case where headers are skipped, the protocol
checksum verification used the wrong length (included the skipped headers),
leading to incorrectly mismatching checksums. Such IPv6 packets with
headers were silently dropped. Reported by Bernhard Schmidt.

ok deraadt@@ dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.433.2.5 2004/12/16 02:05:39 brad Exp $ */
d5649 1
a5649 2
		    ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_TCP, AF_INET6)) {
d5682 1
a5682 2
		    off, ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_UDP, AF_INET6)) {
d5716 1
a5716 2
		    ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_ICMPV6, AF_INET6)) {
@


1.433.2.7
log
@MFC:
Fix by dhartmei@@

ICMP state entries use the ICMP ID as port for the unique state key. When
checking for a usable key, construct the key in the same way. Otherwise,
a colliding key might be missed or a state insertion might be refused even
though it could be inserted. The second case triggers the endless loop
fixed by 1.474, possibly allowing a NATed LAN client to lock up the kernel.
Report and test data by Srebrenko Sehic.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.433.2.6 2004/12/19 18:52:27 brad Exp $ */
d1934 1
a1934 1
			key.gwy.port = dport;
d3087 1
a3087 1
		    saddr, icmpid, daddr, icmpid, &pd->naddr, NULL)) != NULL) {
d3111 1
a3111 1
		    saddr, icmpid, daddr, icmpid, &pd->naddr, NULL)) != NULL) {
@


1.433.2.8
log
@MFC:
Fix by dhartmei@@

Use the packet's address family instead of the rule's when selecting a
replacement address for an rdr rule. Some rdr rules have no address family
(when the replacement is a table and no other criterion implies one AF).
In this case, pf would fail to select a replacement address and drop the
packet due to translation failure. Found by Gustavo A. Baratto.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.433.2.7 2005/01/06 14:15:43 brad Exp $ */
d2165 1
a2165 1
			if (pf_map_addr(pd->af, r, saddr, naddr, NULL, sn))
@


1.432
log
@Fix icmp checksum when sequence number modlation is being used.
Also fix a daddr vs saddr cut-n-paste error in ICMP error handling.

From dhartmei@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.431 2004/03/22 04:54:17 mcbride Exp $ */
d4323 1
d4369 1
a4369 1
			if (src->seqdiff)
d4372 2
d4404 4
a4426 2
				m_copyback(m, off2, 8, &th);
			} else if (src->seqdiff) {
@


1.431
log
@Support for best effort bulk transfers of states when pfsync syncif is
configured.  This this allows pfsync+carp clusters to come up gracefully
without killing active connections. pfsync now prevents carp from
preempting to become master until the state table has sync'd.

ABI change, any application which use struct pf_state must be recompiled.

Reminded about this by Christian Gut. Thanks to beck@@ cedric@@ and dhartmei@@
for testing and comments.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.430 2004/03/11 10:15:26 mcbride Exp $ */
d4369 1
a4369 1
				pf_change_a(&th.th_seq, &th.th_sum,
d4390 1
a4390 1
					    saddr, &(*state)->lan.addr,
@


1.430
log
@Don't call pf_src_tree_remove_state() on error in pf_insert_state(),
it's also called in the function which calls pf_insert_state().

Pointed out by Patrick Latifi, ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.429 2004/03/09 21:44:40 mcbride Exp $ */
d258 1
d673 1
d821 1
@


1.429
log
@KNF, ok cedric@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.428 2004/02/24 12:09:34 mcbride Exp $ */
a631 1
		pf_src_tree_remove_state(state);
a651 1
		pf_src_tree_remove_state(state);
d779 1
@


1.428
log
@Remove redundant logging from pf_test_other().

ok henning@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.427 2004/02/24 06:53:30 mcbride Exp $ */
d486 1
a486 1
	return RB_FIND(pf_state_tree_id, &tree_id, key);
d1865 1
a1865 1
				/* table contain no address of type 'af' */
d1875 1
a1875 1
				/* table contain no address of type 'af' */
a1982 1
			break;
a2085 1
			break;
a2182 1
			break;
d2281 1
a2281 1
			/* fallthrough */
d2288 1
d2318 1
a2318 1
			/* fallthrough */
d2325 1
@


1.427
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.426 2004/02/20 19:22:03 mcbride Exp $ */
a3546 3
			if (r->log)
				PFLOG_PACKET(kif, h, m, af, direction, reason,
				    r, a, ruleset);
@


1.426
log
@Make pfsync deal with clearing states bound to a group or interface (eg
pfctl -i fxp0 -Fs). Also don't send out individual state deletions if we're
sending a clear message, move pfsync_clear_states() inside splnet, and fix
if_pfsync.h includes in  pf.c and pf_ioctl.c.

ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.425 2004/02/19 07:41:45 kjc Exp $ */
d601 2
a602 2
		 pf_status.scounters[SCNT_SRC_NODE_INSERT]++;
		 pf_status.src_nodes++;
@


1.425
log
@the 2nd round of the qid assignment change.
make the semantics in line with the tag assignment, which simplifies
the id management in pf.

ok, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.424 2004/02/10 22:42:57 dhartmei Exp $ */
d75 2
d78 1
@


1.424
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.423 2004/02/10 20:20:01 itojun Exp $ */
a83 4
#ifdef ALTQ
#include <altq/if_altq.h>
#endif

a1053 27
}

void
pf_rule_set_qid(struct pf_rulequeue *rules)
{
	struct pf_rule *rule;

	TAILQ_FOREACH(rule, rules, entries)
		if (rule->qname[0] != 0) {
			rule->qid = pf_qname_to_qid(rule->qname);
			if (rule->pqname[0] != 0)
				rule->pqid = pf_qname_to_qid(rule->pqname);
			else
				rule->pqid = rule->qid;
		}
}

u_int32_t
pf_qname_to_qid(char *qname)
{
	struct pf_altq		*altq;

	TAILQ_FOREACH(altq, pf_altqs_active, entries)
		if (!strcmp(altq->qname, qname))
			return (altq->qid);

	return (0);
@


1.423
log
@plug mbuf leak (ip_fragment() always free mbuf on error).  tested by cedric,
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.422 2004/02/10 18:49:10 henning Exp $ */
d561 1
a561 1
	struct pf_src_node  k;
d1772 1
a1772 1
	struct pf_pooladdr      *acur = rpool->cur;
d5267 9
a5275 9
	struct pfi_kif	  *kif;
	u_short		   action, reason = 0, log = 0;
	struct mbuf	  *m = *m0;
	struct ip	  *h;
	struct pf_rule	  *a = NULL, *r = &pf_default_rule, *tr, *nr;
	struct pf_state	  *s = NULL;
	struct pf_ruleset *ruleset = NULL;
	struct pf_pdesc	   pd;
	int		   off, dirndx, pqid = 0;
d5572 9
a5580 9
	struct pfi_kif	  *kif;
	u_short		   action, reason = 0, log = 0;
	struct mbuf	  *m = *m0;
	struct ip6_hdr	  *h;
	struct pf_rule	  *a = NULL, *r = &pf_default_rule, *tr, *nr;
	struct pf_state	  *s = NULL;
	struct pf_ruleset *ruleset = NULL;
	struct pf_pdesc    pd;
	int		   off, terminal = 0, dirndx;
@


1.422
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.421 2004/02/04 10:43:18 mcbride Exp $ */
d5009 2
a5010 1
	if (error)
d5012 1
@


1.421
log
@Fix a number of bugs with setting pool limits which I introduced with
source-tracking. Found by Pyun YongHyeon.
Also add support to pfctl to set the src-nodes pool limit.

"Luckily" some of the bugs cancel each other out; update kernel before
pfctl.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.420 2004/02/02 12:47:50 cedric Exp $ */
d527 1
a527 1
	switch(tree) {
d768 2
a769 1
				timeout = pf_default_rule.timeout[PFTM_SRC_NODE];
d777 2
a778 1
				timeout = pf_default_rule.timeout[PFTM_SRC_NODE];
d2256 1
a2256 1
	switch(pd->af) {
d2423 2
a2424 1
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL, &s->nat_src_node);
d2430 2
a2431 1
		pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL, &s->nat_src_node);
d2780 2
a2781 2
			    th->th_sport, s->src.seqhi,
			    ntohl(th->th_seq) + 1, TH_SYN|TH_ACK, 0, s->src.mss, 0);
d3738 2
a3739 1
			    (*state)->dst.seqhi, 0, TH_SYN, 0, (*state)->src.mss, 0);
d4390 2
a4391 1
			if (src->wscale && dst->wscale && !(th.th_flags & TH_SYN))
d4794 2
a4795 1
		if (m->m_pkthdr.len < off + len || ntohs(h->ip_len) < off + len) {
d5165 2
a5166 1
pf_check_proto_cksum(struct mbuf *m, int off, int len, u_int8_t p, sa_family_t af)
@


1.420
log
@Do not evaluate pfi_index2kif[ifp->if_index] if PF is disabled.
Safer and faster since we know that ifp->if_index can potentially
be garbage. ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.419 2004/01/27 09:31:15 markus Exp $ */
d210 5
a214 2
struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] =
    { { &pf_state_pl, PFSTATE_HIWAT }, { &pf_frent_pl, PFFRAG_FRENT_HIWAT } };
@


1.419
log
@drop packet if kif == NULL; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.418 2004/01/06 20:24:33 dhartmei Exp $ */
d5254 1
a5254 1
	struct pfi_kif	  *kif = pfi_index2kif[ifp->if_index];
d5268 1
d5559 1
a5559 1
	struct pfi_kif	  *kif = pfi_index2kif[ifp->if_index];
d5573 1
@


1.418
log
@Drop UDP packets with destination port 0, or zero or oversized payload
length (same as udp_input() does, if pf is not enabled). Found by
Pyun YongHyeon. ok cedric@@, ho@@, henning@@ and markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.417 2004/01/05 18:41:47 dhartmei Exp $ */
d5268 3
d5571 3
@


1.417
log
@0 -> (void *)NULL for last argument of icmp_error(), which is of type
struct ifnet *, from Pyun YongHyeon
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.416 2004/01/04 12:56:33 cedric Exp $ */
d5364 6
d5684 6
@


1.416
log
@better macro name (IF_LOCKED -> BOUND_IFACE). from markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.415 2003/12/31 22:14:42 deraadt Exp $ */
d1457 1
a1457 1
		icmp_error(m0, type, code, 0, 0);
@


1.415
log
@spacing.  note this, cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.414 2003/12/31 11:18:25 cedric Exp $ */
d241 1
a241 1
#define LOCKED_IF(r, k) (((r)->rule_flag & PFRULE_IFBOUND) ? (k) :    \
d2744 1
a2744 1
		if (pf_insert_state(LOCKED_IF(r, kif), s)) {
d3033 1
a3033 1
		if (pf_insert_state(LOCKED_IF(r, kif), s)) {
d3308 1
a3308 1
		if (pf_insert_state(LOCKED_IF(r, kif), s)) {
d3566 1
a3566 1
		if (pf_insert_state(LOCKED_IF(r, kif), s)) {
@


1.414
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.413 2003/12/19 16:12:43 henning Exp $ */
d244 1
a244 1
	
d2036 1
a2036 1
		if (r->kif != NULL && 
@


1.413
log
@i wrote much of these, assert my copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.412 2003/12/18 16:07:38 dhartmei Exp $ */
a101 1
struct ifnet		*status_ifp;
d110 1
a110 1
struct pool		 pf_src_tree_pl, pf_rule_pl, pf_addr_pl;
d137 1
a137 1
			    int, int, struct ifnet *,
d141 1
a141 1
			    int, int, struct ifnet *, struct pf_src_node **,
d146 1
a146 1
			    int, struct ifnet *, struct mbuf *, int,
d150 1
a150 1
			    int, struct ifnet *, struct mbuf *, int,
d154 1
a154 1
			    int, struct ifnet *, struct mbuf *, int,
d158 1
a158 1
			    int, struct ifnet *, struct mbuf *, int, void *,
d162 1
a162 1
			    struct ifnet *, struct mbuf *, void *,
d166 1
a166 1
			    struct ifnet *, struct mbuf *, int,
d169 1
a169 1
			    struct ifnet *, struct mbuf *, int,
d172 1
a172 1
			    struct ifnet *, struct mbuf *, int,
d175 1
a175 1
			    struct ifnet *, struct pf_pdesc *);
d207 2
a208 1

d216 2
a217 1
			*state = pf_find_state(&key, PF_EXT_GWY);	\
d219 2
a220 1
			*state = pf_find_state(&key, PF_LAN_EXT);	\
d228 2
a229 2
		    (*state)->rt_ifp != NULL &&				\
		    (*state)->rt_ifp != ifp)				\
d241 4
d254 1
a254 2
struct pf_state_tree_lan_ext tree_lan_ext;
struct pf_state_tree_ext_gwy tree_ext_gwy;
d259 1
a259 1
    entry_lan_ext, pf_state_compare_lan_ext);
d261 1
a261 1
    entry_ext_gwy, pf_state_compare_ext_gwy);
d263 1
a263 1
    entry_id, pf_state_compare_id);
d481 8
a488 1
pf_find_state(struct pf_state *key, u_int8_t tree)
d490 1
a490 1
	struct pf_state	*s;
d496 7
a502 2
		s = RB_FIND(pf_state_tree_lan_ext, &tree_lan_ext, key);
		break;
d504 7
a510 5
		s = RB_FIND(pf_state_tree_ext_gwy, &tree_ext_gwy, key);
		break;
	case PF_ID:
		s = RB_FIND(pf_state_tree_id, &tree_id, key);
		break;
d512 1
a512 3
		/* XXX should we just return NULL? */
		panic("pf_find_state");
		break;
d514 7
d522 30
a551 1
	return (s);
d610 1
a610 1
pf_insert_state(struct pf_state *state)
d613 2
a614 1
	if (RB_INSERT(pf_state_tree_lan_ext, &tree_lan_ext, state)) {
d634 1
a634 1
	if (RB_INSERT(pf_state_tree_ext_gwy, &tree_ext_gwy, state) != NULL) {
d650 1
a650 1
		RB_REMOVE(pf_state_tree_lan_ext, &tree_lan_ext, state);
d668 2
a669 2
		RB_REMOVE(pf_state_tree_lan_ext, &tree_lan_ext, state);
		RB_REMOVE(pf_state_tree_ext_gwy, &tree_ext_gwy, state);
d675 1
d784 3
a786 2
	for (cur = RB_MIN(pf_state_tree_ext_gwy, &tree_ext_gwy); cur; cur = next) {
		next = RB_NEXT(pf_state_tree_ext_gwy, &tree_ext_gwy, cur);
d795 4
a798 2
			RB_REMOVE(pf_state_tree_ext_gwy, &tree_ext_gwy, cur);
			RB_REMOVE(pf_state_tree_lan_ext, &tree_lan_ext, cur);
a799 1

d815 1
d1001 1
a1001 1
		if (cur->ifp != prev->ifp || cur->ifnot != prev->ifnot)
d1044 1
a1044 5
		if (aw1->p.dyn->ifp != aw2->p.dyn->ifp)
			return (1);
		if (PF_ANEQ(&aw1->v.a.mask, &aw2->v.a.mask, 0))
			return (1);
		return (0);
d1796 17
a1812 4
	if (rpool->cur->addr.type == PF_ADDR_DYNIFTL &&
	    rpool->cur->addr.p.dyn->undefined)
		return (1);
	if (rpool->cur->addr.type == PF_ADDR_TABLE) {
d1872 5
d1893 10
d1954 1
a1954 1
			if (pf_find_state(&key, PF_EXT_GWY) == NULL)
d1958 1
a1958 1
			if (pf_find_state(&key, PF_EXT_GWY) == NULL) {
a1959 1
			}
d1962 1
a1962 1
			if (pf_find_state(&key, PF_EXT_GWY) == NULL) {
d1979 1
a1979 1
				if (pf_find_state(&key, PF_EXT_GWY) ==
d1987 1
a1987 1
				if (pf_find_state(&key, PF_EXT_GWY) ==
d2015 1
a2015 1
    int direction, struct ifnet *ifp, struct pf_addr *saddr, u_int16_t sport,
d2036 2
a2037 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d2083 1
a2083 1
    struct ifnet *ifp, struct pf_src_node **sn,
d2091 1
a2091 1
		r = pf_match_translation(pd, m, off, direction, ifp, saddr,
d2094 1
a2094 1
			r = pf_match_translation(pd, m, off, direction, ifp,
d2097 1
a2097 1
		r = pf_match_translation(pd, m, off, direction, ifp, saddr,
d2100 1
a2100 1
			r = pf_match_translation(pd, m, off, direction, ifp,
d2126 23
a2148 5
				if (r->rpool.cur->addr.type ==
				    PF_ADDR_DYNIFTL &&
				    r->rpool.cur->addr.p.dyn->undefined)
					return (NULL);
				else
d2155 23
a2177 4
				if (r->src.addr.type == PF_ADDR_DYNIFTL &&
				    r->src.addr.p.dyn->undefined)
					return (NULL);
				else
d2412 1
a2412 1
	s->rt_ifp = NULL;
d2419 1
a2419 1
		s->rt_ifp = r->rpool.cur->ifp;
d2425 1
a2425 1
		s->rt_ifp = r->rpool.cur->ifp;
d2433 1
a2433 1
    struct ifnet *ifp, struct mbuf *m, int off, void *h,
d2458 1
a2458 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, ifp, &nsn,
d2472 1
a2472 1
		if ((nr = pf_get_translation(pd, m, off, PF_IN, ifp, &nsn,
d2487 2
a2488 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d2556 1
a2556 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
d2744 1
a2744 1
		if (pf_insert_state(s)) {
d2788 1
a2788 1
    struct ifnet *ifp, struct mbuf *m, int off, void *h,
d2812 1
a2812 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, ifp, &nsn,
d2826 1
a2826 1
		if ((nr = pf_get_translation(pd, m, off, PF_IN, ifp, &nsn,
d2841 2
a2842 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d2907 1
a2907 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
d3033 1
a3033 1
		if (pf_insert_state(s)) {
d3051 1
a3051 1
    struct ifnet *ifp, struct mbuf *m, int off, void *h,
d3104 1
a3104 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, ifp, &nsn,
d3128 1
a3128 1
		if ((nr = pf_get_translation(pd, m, off, PF_IN, ifp, &nsn,
d3154 2
a3155 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d3211 1
a3211 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
d3308 1
a3308 1
		if (pf_insert_state(s)) {
d3329 1
a3329 1
    struct ifnet *ifp, struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
d3346 1
a3346 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, ifp, &nsn,
d3368 1
a3368 1
		if ((nr = pf_get_translation(pd, m, off, PF_IN, ifp, &nsn,
d3392 2
a3393 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d3440 1
a3440 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
d3566 1
a3566 1
		if (pf_insert_state(s)) {
d3569 1
a3569 1
				PFLOG_PACKET(ifp, h, m, af, direction, reason,
d3582 1
a3582 1
pf_test_fragment(struct pf_rule **rm, int direction, struct ifnet *ifp,
d3596 2
a3597 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d3642 1
a3642 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
d3656 1
a3656 1
pf_test_state_tcp(struct pf_state **state, int direction, struct ifnet *ifp,
d4064 1
a4064 1
pf_test_state_udp(struct pf_state **state, int direction, struct ifnet *ifp,
d4125 1
a4125 1
pf_test_state_icmp(struct pf_state **state, int direction, struct ifnet *ifp,
d4682 1
a4682 1
pf_test_state_other(struct pf_state **state, int direction, struct ifnet *ifp,
d4903 2
a4904 1
			ifp = r->rpool.cur->ifp;
d4909 1
a4909 1
			ifp = s->rt_ifp;
d5095 1
a5095 1
		ifp = r->rpool.cur->ifp;
d5100 1
a5100 1
		ifp = s->rt_ifp;
d5254 1
d5282 1
a5282 1
	if (pf_normalize_ip(m0, dir, ifp, &reason) != PF_PASS) {
d5308 1
a5308 1
		action = pf_test_fragment(&r, dir, ifp, m, h,
d5332 1
a5332 1
		action = pf_normalize_tcp(dir, ifp, m, 0, off, h, &pd);
d5335 1
a5335 1
		action = pf_test_state_tcp(&s, dir, ifp, m, off, h, &pd,
d5345 1
a5345 1
			action = pf_test_tcp(&r, &s, dir, ifp,
d5364 1
a5364 1
		action = pf_test_state_udp(&s, dir, ifp, m, off, h, &pd);
d5373 1
a5373 1
			action = pf_test_udp(&r, &s, dir, ifp,
d5392 1
a5392 1
		action = pf_test_state_icmp(&s, dir, ifp, m, off, h, &pd);
a5396 1

d5401 1
a5401 1
			action = pf_test_icmp(&r, &s, dir, ifp,
d5407 1
a5407 1
		action = pf_test_state_other(&s, dir, ifp, &pd);
d5416 1
a5416 1
			action = pf_test_other(&r, &s, dir, ifp, m, off, h,
d5467 1
a5467 1
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r, a, ruleset);
d5469 2
a5470 4
	if (ifp == status_ifp) {
		pf_status.bcounters[0][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[0][dir == PF_OUT][action != PF_PASS]++;
	}
d5549 1
d5577 1
a5577 1
	if (pf_normalize_ip6(m0, dir, ifp, &reason) != PF_PASS) {
d5597 1
a5597 1
			action = pf_test_fragment(&r, dir, ifp, m, h,
d5649 1
a5649 1
		action = pf_normalize_tcp(dir, ifp, m, 0, off, h, &pd);
d5652 1
a5652 1
		action = pf_test_state_tcp(&s, dir, ifp, m, off, h, &pd,
d5662 1
a5662 1
			action = pf_test_tcp(&r, &s, dir, ifp,
d5681 1
a5681 1
		action = pf_test_state_udp(&s, dir, ifp, m, off, h, &pd);
d5690 1
a5690 1
			action = pf_test_udp(&r, &s, dir, ifp,
d5709 1
a5709 1
		action = pf_test_state_icmp(&s, dir, ifp,
d5719 1
a5719 1
			action = pf_test_icmp(&r, &s, dir, ifp,
d5725 1
a5725 1
		action = pf_test_state_other(&s, dir, ifp, &pd);
d5731 1
a5731 1
			action = pf_test_other(&r, &s, dir, ifp, m, off, h,
d5770 1
a5770 1
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r, a, ruleset);
d5772 2
a5773 4
	if (ifp == status_ifp) {
		pf_status.bcounters[1][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[1][dir == PF_OUT][action != PF_PASS]++;
	}
@


1.412
log
@resolve compiler warnings, from Pyun YongHyeon, ok cedric@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.411 2003/12/15 09:10:25 henning Exp $ */
d5 1
@


1.411
log
@ryan left a few for me ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.410 2003/12/15 07:28:25 mcbride Exp $ */
d607 1
a607 1
			    "id: %016x creatorid: %08x",
@


1.410
log
@Fix whitespace screwups before henning wakes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.409 2003/12/15 07:11:30 mcbride Exp $ */
d1735 1
a1735 1
			return(0);
d2067 1
a2067 1
 			if (pf_map_addr(r->af, r, saddr, naddr, NULL, sn))
d2448 1
a2448 1
			  	  &th->th_sum, &pd->baddr, bport, 0, af);
d2499 1
a2499 1
	    	    r->rpool.opts & PF_POOL_STICKYADDR) &&
d2832 1
a2832 1
	    	    r->rpool.opts & PF_POOL_STICKYADDR) &&
d3113 1
a3113 1
	    	    r->rpool.opts & PF_POOL_STICKYADDR) &&
d3375 1
a3375 1
	    	    r->rpool.opts & PF_POOL_STICKYADDR) &&
@


1.409
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.408 2003/12/15 00:02:03 mcbride Exp $ */
d519 1
a519 1
		    rule->src_nodes < rule->max_src_nodes) 
d705 1
a705 1
	if (s->src_node != NULL) {           
d708 2
a709 2
			if (!timeout)           
				timeout = pf_default_rule.timeout[PFTM_SRC_NODE];                                               
d712 1
a712 1
	}             
d2499 2
a2500 2
	    	    r->rpool.opts & PF_POOL_STICKYADDR) && 
		    pf_insert_src_node(&sn, r, saddr, af) != 0) 
d2504 1
a2504 1
		    ((direction == PF_OUT && 
d2832 2
a2833 2
	    	    r->rpool.opts & PF_POOL_STICKYADDR) && 
		    pf_insert_src_node(&sn, r, saddr, af) != 0) 
d2837 1
a2837 1
		    ((direction == PF_OUT && 
d2985 1
a2985 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, ifp, &nsn, 
d3113 2
a3114 2
	    	    r->rpool.opts & PF_POOL_STICKYADDR) && 
		    pf_insert_src_node(&sn, r, saddr, af) != 0) 
d3118 1
a3118 1
		    ((direction == PF_OUT && 
d3375 2
a3376 2
	    	    r->rpool.opts & PF_POOL_STICKYADDR) && 
		    pf_insert_src_node(&sn, r, saddr, af) != 0) 
d3380 1
a3380 1
		    ((direction == PF_OUT && 
d5676 1
a5676 1
	                }
@


1.408
log
@Add support to track stateful connections by source ip. This allows us
to:
- Ensure that clients get a consistent IP mapping with load-balanced
  translation/routing rules
- Limit the number of simultaneous connections a client can make
- Limit the number of clients which can connect through a rule

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.407 2003/12/12 20:05:45 cedric Exp $ */
d243 2
d249 1
d256 2
d439 15
d488 3
d571 2
d591 2
d600 18
d740 1
d3918 2
a3919 2
		if (pf_normalize_tcp_stateful(m, off, pd, reason, th, src, dst,
		    &copyback))
d5217 3
d5245 3
d5273 4
d5289 3
d5536 3
d5564 3
d5593 3
@


1.407
log
@Move PF interface code to new net/pf_if.c
Expect improvements in this area soon.
ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.406 2003/12/11 13:13:27 cedric Exp $ */
d110 1
a110 1
struct pool		 pf_rule_pl, pf_addr_pl;
d141 1
a141 1
			    int, int, struct ifnet *,
d178 1
a178 2
			     struct pf_rule *, struct pf_rule *,
			     struct pf_tag *, int *);
d181 1
a181 1
int			 pf_map_addr(u_int8_t, struct pf_pool *,
d183 2
a184 2
			    struct pf_addr *);
int			 pf_get_sport(sa_family_t, u_int8_t, struct pf_pool *,
d186 2
a187 1
			    struct pf_addr *, u_int16_t*, u_int16_t, u_int16_t);
d238 1
d240 1
a240 1
			struct pf_state *);
d242 1
a242 1
			struct pf_state *);
d244 1
d248 1
d255 44
d478 55
d550 1
d569 1
d590 1
d633 46
d699 3
a701 1
			if (--cur->rule.ptr->states <= 0)
d704 2
a705 1
				if (--cur->nat_rule.ptr->states <= 0)
d1476 2
a1477 2
pf_match_tag(struct mbuf *m, struct pf_rule *r, struct pf_rule *nat,
    struct pf_rule *rdr, struct pf_tag *pftag, int *tag)
d1485 2
a1486 4
		if (nat != NULL && nat->tag)
			*tag = nat->tag;
		if (rdr != NULL && rdr->tag)
			*tag = rdr->tag;
d1570 1
a1570 1
pf_addr_inc(struct pf_addr *addr, u_int8_t af)
d1659 2
a1660 2
pf_map_addr(u_int8_t af, struct pf_pool *rpool, struct pf_addr *saddr,
    struct pf_addr *naddr, struct pf_addr *init_addr)
d1663 29
a1691 3
	struct pf_addr		*raddr;
	struct pf_addr		*rmask;
	struct pf_pooladdr	*acur = rpool->cur;
d1785 2
d1790 1
a1790 1
		printf("pf_map_addr: selected address: ");
d1799 1
a1799 1
pf_get_sport(sa_family_t af, u_int8_t proto, struct pf_pool *rpool,
d1801 2
a1802 1
    struct pf_addr *naddr, u_int16_t *nport, u_int16_t low, u_int16_t high)
d1809 1
a1809 1
	if (pf_map_addr(af, rpool, saddr, naddr, &init_addr))
d1867 1
a1867 1
		switch (rpool->opts & PF_POOL_TYPEMASK) {
d1870 1
a1870 1
			if (pf_map_addr(af, rpool, saddr, naddr, &init_addr))
d1955 1
a1955 1
    struct ifnet *ifp,
d1984 1
a1984 1
			if (pf_get_sport(pd->af, pd->proto, &r->rpool, saddr,
d1986 1
a1986 1
			    r->rpool.proxy_port[1])) {
d2021 1
a2021 1
			if (pf_map_addr(r->af, &r->rpool, saddr, naddr, NULL))
d2253 1
a2253 2
		pf_map_addr(AF_INET, &r->rpool, saddr,
		    &s->rt_addr, NULL);
d2259 1
a2259 2
		pf_map_addr(AF_INET6, &r->rpool, saddr,
		    &s->rt_addr, NULL);
d2271 1
a2271 1
	struct pf_rule		*nat = NULL, *rdr = NULL;
d2281 1
d2293 1
a2293 1
		if ((nat = pf_get_translation(pd, m, off, PF_OUT, ifp,
d2300 1
a2300 1
			if (nat->natpass)
d2302 1
a2302 1
			pd->nat_rule = nat;
d2307 2
a2308 2
		if ((rdr = pf_get_translation(pd, m, off, PF_IN, ifp, saddr,
		    th->th_sport, daddr, th->th_dport,
d2314 1
a2314 1
			if (rdr->natpass)
d2316 1
a2316 1
			pd->nat_rule = rdr;
d2357 1
a2357 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
d2399 10
a2408 8
		if (nat != NULL) {
			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &pd->baddr, bport, 0, af);
			rewrite++;
		} else if (rdr != NULL) {
			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &pd->baddr, bport, 0, af);
			rewrite++;
d2439 1
a2439 1
	if (r->keep_state || nat != NULL || rdr != NULL ||
d2444 1
d2447 16
a2462 2
		if (!r->max_states || r->states < r->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
d2464 14
d2486 1
a2486 4
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
d2500 1
a2500 1
			if (nat != NULL) {
d2512 1
a2512 1
			if (rdr != NULL) {
d2555 9
a2563 1

d2567 1
d2575 1
d2582 1
d2590 11
a2600 8
			if (nat != NULL)
				pf_change_ap(saddr, &th->th_sport,
				    pd->ip_sum, &th->th_sum, &pd->baddr,
				    bport, 0, af);
			else if (rdr != NULL)
				pf_change_ap(daddr, &th->th_dport,
				    pd->ip_sum, &th->th_sum, &pd->baddr,
				    bport, 0, af);
d2626 1
a2626 1
	struct pf_rule		*nat = NULL, *rdr = NULL;
d2636 1
d2647 1
a2647 1
		if ((nat = pf_get_translation(pd, m, off, PF_OUT, ifp,
d2654 1
a2654 1
			if (nat->natpass)
d2656 1
a2656 1
			pd->nat_rule = nat;
d2661 3
a2663 3
		if ((rdr = pf_get_translation(pd, m, off, PF_IN, ifp, saddr,
		    uh->uh_sport, daddr, uh->uh_dport, &pd->naddr, &nport))
		    != NULL) {
d2668 1
a2668 1
			if (rdr->natpass)
d2670 1
a2670 1
			pd->nat_rule = rdr;
d2709 1
a2709 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
d2749 10
a2758 8
		if (nat != NULL) {
			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &pd->baddr, bport, 1, af);
			rewrite++;
		} else if (rdr != NULL) {
			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &pd->baddr, bport, 1, af);
			rewrite++;
d2776 1
a2776 1
	if (r->keep_state || nat != NULL || rdr != NULL) {
d2779 1
d2781 15
a2795 2
		if (!r->max_states || r->states < r->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
d2797 14
d2819 1
a2819 4
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
d2833 1
a2833 1
			if (nat != NULL) {
d2845 1
a2845 1
			if (rdr != NULL) {
d2859 9
d2870 1
d2889 1
a2889 1
	struct pf_rule		*nat = NULL, *rdr = NULL;
d2893 1
d2939 2
a2940 2
		if ((nat = pf_get_translation(pd, m, off, PF_OUT, ifp, saddr, 0,
		    daddr, 0, &pd->naddr, NULL)) != NULL) {
d2957 1
a2957 1
			if (nat->natpass)
d2959 1
a2959 1
			pd->nat_rule = nat;
d2963 2
a2964 2
		if ((rdr = pf_get_translation(pd, m, off, PF_IN, ifp, saddr, 0,
		    daddr, 0, &pd->naddr, NULL)) != NULL) {
d2981 1
a2981 1
			if (rdr->natpass)
d2983 1
a2983 1
			pd->nat_rule = rdr;
d3010 1
a3010 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
d3057 1
a3057 2
	if (!state_icmp && (r->keep_state ||
	    nat != NULL || rdr != NULL)) {
d3060 1
d3062 15
a3076 2
		if (!r->max_states || r->states < r->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
d3078 14
d3100 1
a3100 4
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
d3114 1
a3114 1
			if (nat != NULL)
d3124 1
a3124 1
			if (rdr != NULL)
d3134 9
d3145 1
d3167 1
a3167 1
	struct pf_rule		*nat = NULL, *rdr = NULL;
d3170 1
d3181 2
a3182 2
		if ((nat = pf_get_translation(pd, m, off, PF_OUT, ifp, saddr, 0,
		    daddr, 0, &pd->naddr, NULL)) != NULL) {
d3197 1
a3197 1
			if (nat->natpass)
d3199 1
a3199 1
			pd->nat_rule = nat;
d3203 2
a3204 2
		if ((rdr = pf_get_translation(pd, m, off, PF_IN, ifp, saddr, 0,
		    daddr, 0, &pd->naddr, NULL)) != NULL) {
d3219 1
a3219 1
			if (rdr->natpass)
d3221 1
a3221 1
			pd->nat_rule = rdr;
d3244 1
a3244 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
d3282 6
a3287 4
		if (nat != NULL)
			a = saddr;
		else if (rdr != NULL)
			a = daddr;
d3319 1
a3319 1
	if (r->keep_state || nat != NULL || rdr != NULL) {
d3322 1
d3324 15
a3338 2
		if (!r->max_states || r->states < r->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
d3340 14
d3362 1
a3362 4
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
d3374 1
a3374 1
			if (nat != NULL)
d3381 1
a3381 1
			if (rdr != NULL)
d3392 9
d3406 1
d3450 1
a3450 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, NULL, NULL, pftag, &tag))
d4682 1
d4734 2
a4735 3
			pf_map_addr(AF_INET, &r->rpool,
			    (struct pf_addr *)&ip->ip_src,
			    &naddr, NULL);
d4875 1
d4924 2
a4925 2
		pf_map_addr(AF_INET6, &r->rpool,
		    (struct pf_addr *)&ip6->ip6_src, &naddr, NULL);
d5310 8
d5604 8
@


1.406
log
@Fix PR3587 and other related problems with NAT and table stats.
PPL that have that problem and cannot upgrade to -current could
just comment out the assertion in pfr_update_stats().
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.405 2003/12/08 07:07:35 mcbride Exp $ */
a112 1
void			 pf_dynaddr_update(void *);
a594 95
}

int
pf_dynaddr_setup(struct pf_addr_wrap *aw, sa_family_t af)
{
	if (aw->type != PF_ADDR_DYNIFTL)
		return (0);
	aw->p.dyn = pool_get(&pf_addr_pl, PR_NOWAIT);
	if (aw->p.dyn == NULL)
		return (1);
	bcopy(aw->v.ifname, aw->p.dyn->ifname, sizeof(aw->p.dyn->ifname));
	aw->p.dyn->ifp = ifunit(aw->p.dyn->ifname);
	if (aw->p.dyn->ifp == NULL) {
		pool_put(&pf_addr_pl, aw->p.dyn);
		aw->p.dyn = NULL;
		return (1);
	}
	aw->p.dyn->addr = &aw->v.a.addr;
	aw->p.dyn->af = af;
	aw->p.dyn->undefined = 1;
	aw->p.dyn->hook_cookie = hook_establish(
	    aw->p.dyn->ifp->if_addrhooks, 1,
	    pf_dynaddr_update, aw->p.dyn);
	if (aw->p.dyn->hook_cookie == NULL) {
		pool_put(&pf_addr_pl, aw->p.dyn);
		aw->p.dyn = NULL;
		return (1);
	}
	pf_dynaddr_update(aw->p.dyn);
	return (0);
}

void
pf_dynaddr_update(void *p)
{
	struct pf_addr_dyn	*ad = (struct pf_addr_dyn *)p;
	struct ifaddr		*ia;
	int			 s, changed = 0;

	if (ad == NULL || ad->ifp == NULL)
		panic("pf_dynaddr_update");
	s = splsoftnet();
	TAILQ_FOREACH(ia, &ad->ifp->if_addrlist, ifa_list)
		if (ia->ifa_addr != NULL &&
		    ia->ifa_addr->sa_family == ad->af) {
			if (ad->af == AF_INET) {
				struct in_addr *a, *b;

				a = &ad->addr->v4;
				b = &((struct sockaddr_in *)ia->ifa_addr)
				    ->sin_addr;
				if (ad->undefined ||
				    memcmp(a, b, sizeof(*a))) {
					bcopy(b, a, sizeof(*a));
					changed = 1;
				}
			} else if (ad->af == AF_INET6) {
				struct in6_addr *a, *b;

				a = &ad->addr->v6;
				b = &((struct sockaddr_in6 *)ia->ifa_addr)
				    ->sin6_addr;
				if (ad->undefined ||
				    memcmp(a, b, sizeof(*a))) {
					bcopy(b, a, sizeof(*a));
					changed = 1;
				}
			}
			if (changed)
				ad->undefined = 0;
			break;
		}
	if (ia == NULL)
		ad->undefined = 1;
	splx(s);
}

void
pf_dynaddr_remove(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL)
		return;
	hook_disestablish(aw->p.dyn->ifp->if_addrhooks,
	    aw->p.dyn->hook_cookie);
	pool_put(&pf_addr_pl, aw->p.dyn);
	aw->p.dyn = NULL;
}

void
pf_dynaddr_copyout(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL)
		return;
	bcopy(aw->p.dyn->ifname, aw->v.ifname, sizeof(aw->v.ifname));
	aw->p.dyn = (struct pf_addr_dyn *)1;
@


1.405
log
@Mbuf tag tcp and udp packets which are translated to localhost, and
use the the presence of this tag to reverse the match order in
in{6}_pcblookup_listen(). Some daemons (such as portmap) do a double
bind, binding to both * and localhost in order to differentiate local
from non-local connections, and potentially granting more privilege to
local ones. This change ensures that redirected connections to localhost
do not appear local to such a daemon.

Bulk of changes from dhartmei@@, some changes markus@@

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.404 2003/11/28 01:06:59 mcbride Exp $ */
a2189 1
	struct pf_addr		 baddr, naddr;
d2211 2
a2212 2
		    &naddr, &nport)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
d2214 1
a2214 1
			    &th->th_sum, &naddr, nport, 0, af);
d2218 1
d2225 2
a2226 2
		    &naddr, &nport)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
d2228 1
a2228 1
			    &th->th_sum, &naddr, nport, 0, af);
d2232 1
d2318 1
a2318 1
			    &th->th_sum, &baddr, bport, 0, af);
d2322 1
a2322 1
			    &th->th_sum, &baddr, bport, 0, af);
d2390 1
a2390 1
				PF_ACPY(&s->lan.addr, &baddr, af);
d2402 1
a2402 1
				PF_ACPY(&s->gwy.addr, &baddr, af);
d2470 1
a2470 1
				    pd->ip_sum, &th->th_sum, &baddr,
d2474 1
a2474 1
				    pd->ip_sum, &th->th_sum, &baddr,
a2502 1
	struct pf_addr		 baddr, naddr;
d2523 2
a2524 2
		    &naddr, &nport)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
d2526 1
a2526 1
			    &uh->uh_sum, &naddr, nport, 1, af);
d2530 1
d2536 1
a2536 1
		    uh->uh_sport, daddr, uh->uh_dport, &naddr, &nport))
d2538 1
a2538 1
			PF_ACPY(&baddr, daddr, af);
d2540 1
a2540 1
			    &uh->uh_sum, &naddr, nport, 1, af);
d2544 1
d2626 1
a2626 1
			    &uh->uh_sum, &baddr, bport, 1, af);
d2630 1
a2630 1
			    &uh->uh_sum, &baddr, bport, 1, af);
d2682 1
a2682 1
				PF_ACPY(&s->lan.addr, &baddr, af);
d2694 1
a2694 1
				PF_ACPY(&s->gwy.addr, &baddr, af);
a2728 1
	struct pf_addr		 baddr, naddr;
d2777 2
a2778 2
		    daddr, 0, &naddr, NULL)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
d2783 1
a2783 1
				    naddr.v4.s_addr, 0);
d2789 1
a2789 1
				    &naddr, 0);
d2796 1
d2801 2
a2802 2
		    daddr, 0, &naddr, NULL)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
d2807 1
a2807 1
				    pd->ip_sum, naddr.v4.s_addr, 0);
d2813 1
a2813 1
				    &naddr, 0);
d2820 1
d2929 1
a2929 1
				PF_ACPY(&s->lan.addr, &baddr, af);
d2939 1
a2939 1
				PF_ACPY(&s->gwy.addr, &baddr, af);
a2974 1
	struct pf_addr		 baddr, naddr;
d2985 2
a2986 2
		    daddr, 0, &naddr, NULL)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
d2991 1
a2991 1
				    naddr.v4.s_addr, 0);
d2996 1
a2996 1
				PF_ACPY(saddr, &naddr, af);
d3002 1
d3007 2
a3008 2
		    daddr, 0, &naddr, NULL)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
d3013 1
a3013 1
				    pd->ip_sum, naddr.v4.s_addr, 0);
d3018 1
a3018 1
				PF_ACPY(daddr, &naddr, af);
d3024 1
d3095 1
a3095 1
				    baddr.v4.s_addr, 0);
d3100 1
a3100 1
				PF_ACPY(a, &baddr, af);
d3152 1
a3152 1
				PF_ACPY(&s->lan.addr, &baddr, af);
d3159 1
a3159 1
				PF_ACPY(&s->gwy.addr, &baddr, af);
d4858 1
a4858 1
	struct pf_rule	  *a = NULL, *r = &pf_default_rule, *tr;
d4899 1
d5078 34
a5112 13
	tr = r;
	if (r == &pf_default_rule && s != NULL && s->nat_rule.ptr != NULL)
		tr = s->nat_rule.ptr;
	if (tr->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->src.not);
	if (tr->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->dst.not);
d5134 1
a5134 1
	struct pf_rule	  *a = NULL, *r = &pf_default_rule, *tr;
d5167 1
d5365 34
a5399 13
	tr = r;
	if (r == &pf_default_rule && s != NULL && s->nat_rule.ptr != NULL)
		tr = s->nat_rule.ptr;
	if (tr->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->src.not);
	if (tr->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->dst.not);
@


1.404
log
@More pf stats fixups:
- Don't double count double count icmp packets.
- We only want to increment rule and state counters if we're  passing
  the packet, unless it's a 'drop' rule.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.403 2003/11/21 01:47:16 mcbride Exp $ */
d207 1
d2005 1
a2005 1
			inp = in_pcblookup_listen(tb, daddr->v4, dport);
d2015 1
a2015 1
			inp = in6_pcblookup_listen(tb, &daddr->v6, dport);
d4833 14
d5034 15
d5303 10
@


1.403
log
@Remove redundant arguments to pf_sockaddr_lookup(); proto and af are already
included in pd.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.402 2003/11/21 01:43:43 mcbride Exp $ */
a4968 2
			r->packets++;
			r->bytes += ntohs(h->ip_len);
a4969 4
			if (a != NULL) {
				a->packets++;
				a->bytes += ntohs(h->ip_len);
			}
d5027 15
a5041 13
	r->packets++;
	r->bytes += pd.tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd.tot_len;
	}
	if (s != NULL) {
		dirndx = (dir == s->direction) ? 0 : 1;
		s->packets[dirndx]++;
		s->bytes[dirndx] += pd.tot_len;
		if (s->nat_rule.ptr != NULL) {
			s->nat_rule.ptr->packets++;
			s->nat_rule.ptr->bytes += pd.tot_len;
a5230 2
			r->packets++;
			r->bytes += h->ip6_plen;
d5282 15
a5296 13
	r->packets++;
	r->bytes += pd.tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd.tot_len;
	}
	if (s != NULL) {
		dirndx = (dir == s->direction) ? 0 : 1;
		s->packets[dirndx]++;
		s->bytes[dirndx] += pd.tot_len;
		if (s->nat_rule.ptr != NULL) {
			s->nat_rule.ptr->packets++;
			s->nat_rule.ptr->bytes += pd.tot_len;
@


1.402
log
@Remove unused "ipoff" arguments.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.401 2003/11/16 23:23:16 mcbride Exp $ */
d193 1
a193 1
int			 pf_socket_lookup(uid_t *, gid_t *, int, sa_family_t,
d1965 1
a1965 2
pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, sa_family_t af,
    int proto, struct pf_pdesc *pd)
d1974 1
a1974 1
	switch (proto) {
d2000 1
a2000 1
	switch(af) {
d2262 1
a2262 2
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP,
		    pd), 1)) &&
d2267 1
a2267 2
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP,
		    pd), 1)) &&
d2571 1
a2571 2
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP,
		    pd), 1)) &&
d2576 1
a2576 2
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP,
		    pd), 1)) &&
@


1.401
log
@pf_test() and pf_test6() consistency:
- Fix anchor anchor accounting for IPv4 TCP and all IPv6 protocols.
- Make stateful connections work for generic protocols on IPv6.

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.400 2003/11/09 11:25:01 dhartmei Exp $ */
d147 1
a147 1
			    int, struct ifnet *, struct mbuf *, int, int,
d151 1
a151 1
			    int, struct ifnet *, struct mbuf *, int, int,
d155 1
a155 1
			    int, struct ifnet *, struct mbuf *, int, int,
d167 1
a167 1
			    struct ifnet *, struct mbuf *, int, int,
d170 1
a170 1
			    struct ifnet *, struct mbuf *, int, int,
d173 1
a173 1
			    struct ifnet *, struct mbuf *, int, int,
d2185 1
a2185 1
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
d2499 1
a2499 1
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
d2726 1
a2726 1
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
d3260 1
a3260 1
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd,
d3668 1
a3668 1
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d3729 1
a3729 1
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d4920 1
a4920 1
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd,
d4928 1
a4928 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4946 1
a4946 1
		action = pf_test_state_udp(&s, dir, ifp, m, 0, off, h, &pd);
d4953 1
a4953 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4971 1
a4971 1
		action = pf_test_state_icmp(&s, dir, ifp, m, 0, off, h, &pd);
d4984 1
a4984 1
			    m, 0, off, h, &pd, &a, &ruleset);
d5185 1
a5185 1
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd,
d5193 1
a5193 1
			    m, 0, off, h, &pd, &a, &ruleset);
d5211 1
a5211 1
		action = pf_test_state_udp(&s, dir, ifp, m, 0, off, h, &pd);
d5218 1
a5218 1
			    m, 0, off, h, &pd, &a, &ruleset);
d5237 1
a5237 1
		    m, 0, off, h, &pd);
d5246 1
a5246 1
			    m, 0, off, h, &pd, &a, &ruleset);
@


1.400
log
@remove stale forward declaration
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.399 2003/11/04 21:43:15 markus Exp $ */
d4924 1
d5189 1
d5214 1
d5242 1
d5251 8
a5258 2
		action = pf_test_other(&r, &s, dir, ifp, m, off, h,
		    &pd, &a, &ruleset);
@


1.399
log
@add in(6)_pcblookup_listen() and replace all calls to in_pcblookup()
with either in(6)_pcbhashlookup() or in(6)_pcblookup_listen();
in_pcblookup is now only used by bind(2); speeds up pcb lookup for
listening sockets; from Claudio Jeker
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.398 2003/11/03 07:50:00 cedric Exp $ */
a88 1
struct pf_state_tree;
@


1.398
log
@pf_route() can change output NIC, so we need to check its capabilities.
good candidate for 3.X errata.
ok dhartmei@@ henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.397 2003/10/31 10:34:47 mcbride Exp $ */
d2006 1
a2006 2
			inp = in_pcblookup(tb, &saddr->v4, sport, &daddr->v4,
			    dport, INPLOOKUP_WILDCARD);
d2016 1
a2016 2
			inp = in_pcblookup(tb, &saddr->v6, sport, &daddr->v6,
			    dport, INPLOOKUP_WILDCARD | INPLOOKUP_IPV6);
@


1.397
log
@Remove remenants of pf_tree stuff that I missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.396 2003/10/29 15:35:08 dhartmei Exp $ */
d4542 28
@


1.396
log
@fix binat for incoming connections when a netblock (not just a single
address) is used for source in the binat rule. closes PR 3535, reported
by Karl O.Pinc. ok henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.395 2003/10/25 20:27:07 mcbride Exp $ */
d111 1
a111 1
struct pool		 pf_tree_pl, pf_rule_pl, pf_addr_pl;
@


1.395
log
@Build state search indexes directly on pf_state instead of pf_tree_node.
This saves more than 30% memory on state entries, and simplifies the state
insertion and removal code as well.

NOTE: This changes the pf API; userland tools must be updated to match.

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.394 2003/10/10 15:26:40 dhartmei Exp $ */
d1930 1
a1930 1
					    &r->src.addr.v.a.mask, saddr,
@


1.394
log
@make sure pd is initialized before use (or byte counters may increase
by random values). ok mcbride@@, cedric@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.393 2003/10/02 05:47:30 itojun Exp $ */
d216 1
a216 1
			*state = pf_find_state(&tree_ext_gwy, &key);	\
d218 1
a218 1
			*state = pf_find_state(&tree_lan_ext, &key);	\
d239 12
a250 2
static __inline int pf_state_compare(struct pf_tree_node *,
			struct pf_tree_node *);
d252 67
a318 2
struct pf_state_tree tree_lan_ext, tree_ext_gwy;
RB_GENERATE(pf_state_tree, pf_tree_node, entry, pf_state_compare);
d321 1
a321 1
pf_state_compare(struct pf_tree_node *a, struct pf_tree_node *b)
d332 1
a332 1
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
d334 1
a334 1
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
d336 1
a336 1
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
d338 1
a338 1
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
d344 1
a344 1
		if (a->addr[0].addr32[3] > b->addr[0].addr32[3])
d346 1
a346 1
		if (a->addr[0].addr32[3] < b->addr[0].addr32[3])
d348 1
a348 1
		if (a->addr[1].addr32[3] > b->addr[1].addr32[3])
d350 1
a350 1
		if (a->addr[1].addr32[3] < b->addr[1].addr32[3])
d352 1
a352 1
		if (a->addr[0].addr32[2] > b->addr[0].addr32[2])
d354 1
a354 1
		if (a->addr[0].addr32[2] < b->addr[0].addr32[2])
d356 1
a356 1
		if (a->addr[1].addr32[2] > b->addr[1].addr32[2])
d358 1
a358 1
		if (a->addr[1].addr32[2] < b->addr[1].addr32[2])
d360 1
a360 1
		if (a->addr[0].addr32[1] > b->addr[0].addr32[1])
d362 1
a362 1
		if (a->addr[0].addr32[1] < b->addr[0].addr32[1])
d364 1
a364 1
		if (a->addr[1].addr32[1] > b->addr[1].addr32[1])
d366 1
a366 1
		if (a->addr[1].addr32[1] < b->addr[1].addr32[1])
d368 1
a368 1
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
d370 1
a370 1
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
d372 1
a372 1
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
d374 1
a374 1
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
d380 1
a380 1
	if ((diff = a->port[0] - b->port[0]) != 0)
d382 1
a382 1
	if ((diff = a->port[1] - b->port[1]) != 0)
d409 1
a409 1
pf_find_state(struct pf_state_tree *tree, struct pf_tree_node *key)
d411 1
a411 1
	struct pf_tree_node	*k;
d414 15
a428 5
	k = RB_FIND(pf_state_tree, tree, key);
	if (k)
		return (k->state);
	else
		return (NULL);
a433 13
	struct pf_tree_node	*keya, *keyb;

	keya = pool_get(&pf_tree_pl, PR_NOWAIT);
	if (keya == NULL)
		return (-1);
	keya->state = state;
	keya->proto = state->proto;
	keya->af = state->af;
	PF_ACPY(&keya->addr[0], &state->lan.addr, state->af);
	keya->port[0] = state->lan.port;
	PF_ACPY(&keya->addr[1], &state->ext.addr, state->af);
	keya->port[1] = state->ext.port;

d435 1
a435 1
	if (RB_INSERT(pf_state_tree, &tree_lan_ext, keya) != NULL) {
a448 9
		pool_put(&pf_tree_pl, keya);
		return (-1);
	}

	keyb = pool_get(&pf_tree_pl, PR_NOWAIT);
	if (keyb == NULL) {
		/* Need to pull out the other state */
		RB_REMOVE(pf_state_tree, &tree_lan_ext, keya);
		pool_put(&pf_tree_pl, keya);
a450 7
	keyb->state = state;
	keyb->proto = state->proto;
	keyb->af = state->af;
	PF_ACPY(&keyb->addr[0], &state->ext.addr, state->af);
	keyb->port[0] = state->ext.port;
	PF_ACPY(&keyb->addr[1], &state->gwy.addr, state->af);
	keyb->port[1] = state->gwy.port;
d452 1
a452 1
	if (RB_INSERT(pf_state_tree, &tree_ext_gwy, keyb) != NULL) {
d466 1
a466 3
		RB_REMOVE(pf_state_tree, &tree_lan_ext, keya);
		pool_put(&pf_tree_pl, keya);
		pool_put(&pf_tree_pl, keyb);
d531 1
a531 2
	struct pf_tree_node	*cur, *peer, *next;
	struct pf_tree_node	 key;
d533 2
a534 2
	for (cur = RB_MIN(pf_state_tree, &tree_ext_gwy); cur; cur = next) {
		next = RB_NEXT(pf_state_tree, &tree_ext_gwy, cur);
d536 6
a541 11
		if (pf_state_expires(cur->state) <= time.tv_sec) {
			if (cur->state->src.state == PF_TCPS_PROXY_DST)
				pf_send_tcp(cur->state->rule.ptr,
				    cur->state->af,
				    &cur->state->ext.addr,
				    &cur->state->lan.addr,
				    cur->state->ext.port,
				    cur->state->lan.port,
				    cur->state->src.seqhi,
				    cur->state->src.seqlo + 1,
					0,
d543 2
a544 17
			RB_REMOVE(pf_state_tree, &tree_ext_gwy, cur);

			/* Need this key's peer (in the other tree) */
			key.state = cur->state;
			key.proto = cur->state->proto;
			key.af = cur->state->af;
			PF_ACPY(&key.addr[0], &cur->state->lan.addr,
			    cur->state->af);
			key.port[0] = cur->state->lan.port;
			PF_ACPY(&key.addr[1], &cur->state->ext.addr,
			    cur->state->af);
			key.port[1] = cur->state->ext.port;

			peer = RB_FIND(pf_state_tree, &tree_lan_ext, &key);
			KASSERT(peer);
			KASSERT(peer->state == cur->state);
			RB_REMOVE(pf_state_tree, &tree_lan_ext, peer);
d547 1
a547 1
			pfsync_delete_state(cur->state);
d549 10
a558 14
			if (--cur->state->rule.ptr->states <= 0)
				pf_rm_rule(NULL, cur->state->rule.ptr);
			if (cur->state->nat_rule.ptr != NULL)
				if (--cur->state->nat_rule.ptr->states <= 0)
					pf_rm_rule(NULL,
					    cur->state->nat_rule.ptr);
			if (cur->state->anchor.ptr != NULL)
				if (--cur->state->anchor.ptr->states <= 0)
					pf_rm_rule(NULL,
					    cur->state->anchor.ptr);
			pf_normalize_tcp_cleanup(cur->state);
			pool_put(&pf_state_pl, cur->state);
			pool_put(&pf_tree_pl, cur);
			pool_put(&pf_tree_pl, peer);
d1719 1
a1719 1
	struct pf_tree_node	key;
d1730 3
a1732 3
		PF_ACPY(&key.addr[0], daddr, key.af);
		PF_ACPY(&key.addr[1], naddr, key.af);
		key.port[0] = dport;
d1739 2
a1740 2
			key.port[1] = 0;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL)
d1743 2
a1744 2
			key.port[1] = *nport;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
d1748 2
a1749 2
			key.port[1] = htons(low);
			if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
d1765 2
a1766 2
				key.port[1] = htons(tmp);
				if (pf_find_state(&tree_ext_gwy, &key) ==
d1773 2
a1774 2
				key.port[1] = htons(tmp);
				if (pf_find_state(&tree_ext_gwy, &key) ==
d3266 1
a3266 1
	struct pf_tree_node	 key;
d3277 11
a3287 4
	PF_ACPY(&key.addr[0], pd->src, key.af);
	PF_ACPY(&key.addr[1], pd->dst, key.af);
	key.port[0] = th->th_sport;
	key.port[1] = th->th_dport;
d3674 1
a3674 1
	struct pf_tree_node	 key;
d3679 11
a3689 4
	PF_ACPY(&key.addr[0], pd->src, key.af);
	PF_ACPY(&key.addr[1], pd->dst, key.af);
	key.port[0] = uh->uh_sport;
	key.port[1] = uh->uh_dport;
d3775 1
a3775 1
		struct pf_tree_node	key;
d3779 11
a3789 4
		PF_ACPY(&key.addr[0], saddr, key.af);
		PF_ACPY(&key.addr[1], daddr, key.af);
		key.port[0] = icmpid;
		key.port[1] = icmpid;
d3948 1
a3948 1
			struct pf_tree_node	 key;
d3966 11
a3976 4
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = th.th_dport;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = th.th_sport;
d4057 1
a4057 1
			struct pf_tree_node	key;
d4069 11
a4079 4
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = uh.uh_dport;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = uh.uh_sport;
d4124 1
a4124 1
			struct pf_tree_node	key;
d4136 11
a4146 4
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = iih.icmp_id;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = iih.icmp_id;
d4176 1
a4176 1
			struct pf_tree_node	key;
d4188 11
a4198 4
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = iih.icmp6_id;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = iih.icmp6_id;
d4228 1
a4228 1
			struct pf_tree_node	key;
d4232 11
a4242 4
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = 0;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = 0;
d4292 1
a4292 1
	struct pf_tree_node	 key;
d4296 11
a4306 4
	PF_ACPY(&key.addr[0], pd->src, key.af);
	PF_ACPY(&key.addr[1], pd->dst, key.af);
	key.port[0] = 0;
	key.port[1] = 0;
@


1.393
log
@correct endian handling of ip->ip_off.
do not try to send incomplete fragments on ENOBUFS case
(behavior change from 4.4bsd).
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.392 2003/09/26 21:44:08 cedric Exp $ */
d4742 1
a4765 1
	memset(&pd, 0, sizeof(pd));
d4984 1
a4999 1
	memset(&pd, 0, sizeof(pd));
@


1.392
log
@Rearchitecture of the userland/kernel IOCTL interface for transactions.
This brings us close to 100% atomicity for a "pfctl -f pf.conf" command.
(some splxxx work remain in the kernel). Basically, improvements are:

   - Anchors/Rulesets cannot disappear unexpectedly anymore.
   - No more leftover in the kernel if "pfctl -f" fail.
   - Commit is now done in a single atomic IOCTL.

WARNING: The kernel code is fully backward compatible, but the new
pfctl/authpf userland utilities will only run on a new kernel.

The following ioctls are deprecated (i.e. will be deleted sooner or
later, depending on how many 3rd party utilities use them and how soon
they can be upgraded):

   - DIOCBEGINRULES
   - DIOCCOMMITRULES
   - DIOCBEGINALTQS
   - DIOCCOMMITALTQS
   - DIOCRINABEGIN
   - DIOCRINADEFINE

They are replaced by the following ioctls (yes, PF(4) will follow)
which operate on a vector of rulesets:

   - DIOCXBEGIN
   - DIOCXCOMMIT
   - DIOCXROLLBACK

Ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.391 2003/09/26 14:48:19 mcbride Exp $ */
d4484 1
a4484 1
	if (error == EMSGSIZE)
@


1.391
log
@Move statistics counters from individual pf_test_<proto>() and
pf_test_state_<proto>() to pf_test() and pf_test6(). Reduce
code redundancy, and fix the following bugs:

- ICMP packets were not being accounted for correctly (missing
  statistics code in pf_test_state_icmp()
- Some packets were not being counted in the loginterface statistics

NOTE: Under some situations with route-to, packets may get counted
once on the original interface, and once on the pf-routed interface.
This can be dealt with by rules which specify the each interface
explicitly.

ok cedric@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.390 2003/09/24 17:18:03 mcbride Exp $ */
d106 1
@


1.390
log
@Remove state setup no-ops.

ok cedric@@ frantzen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.389 2003/09/01 15:08:39 henning Exp $ */
a2276 6
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
a2416 2
		s->packets[0] = 1;
		s->bytes[0] = pd->tot_len;
a2586 6
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
a2680 2
		s->packets[0] = 1;
		s->bytes[0] = pd->tot_len;
a2849 6
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
a2920 2
		s->packets[0] = 1;
		s->bytes[0] = pd->tot_len;
a3048 6
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
d3050 1
a3140 2
		s->packets[0] = 1;
		s->bytes[0] = pd->tot_len;
a3214 6
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
d3216 1
d3241 1
a3241 1
	int			 ackskew, dirndx;
a3256 1
		dirndx = 0;
a3259 1
		dirndx = 1;
a3456 3
		(*state)->packets[dirndx]++;
		(*state)->bytes[dirndx] += pd->tot_len;

a3540 3
		(*state)->packets[dirndx]++;
		(*state)->bytes[dirndx] += pd->tot_len;

a3628 10
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
	}
a3638 1
	int			dirndx;
a3651 1
		dirndx = 0;
a3654 1
		dirndx = 1;
a3656 3
	(*state)->packets[dirndx]++;
	(*state)->bytes[dirndx] += pd->tot_len;

a3682 10
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
	}
d3693 1
a3693 1
	int		 state_icmp = 0, dirndx;
a3741 3
		dirndx = (direction == (*state)->direction) ? 0 : 1;
		(*state)->packets[dirndx]++;
		(*state)->bytes[dirndx] += pd->tot_len;
a4206 1
	int			dirndx;
a4219 1
		dirndx = 0;
a4222 1
		dirndx = 1;
a4224 3
	(*state)->packets[dirndx]++;
	(*state)->bytes[dirndx] += pd->tot_len;

a4271 10
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
	}
d4730 1
a4730 2
	int		   off;
	int		   pqid = 0;
d4801 1
a4801 1
			break;
a4880 5
	if (ifp == status_ifp) {
		pf_status.bcounters[0][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[0][dir == PF_OUT][action != PF_PASS]++;
	}

a4881 14
	tr = r;
	if (r == &pf_default_rule && s != NULL && s->nat_rule.ptr != NULL)
		tr = s->nat_rule.ptr;
	if (tr->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->src.not);
	if (tr->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->dst.not);

d4914 35
d4972 1
a4972 1
	int		   off, terminal = 0;
d5065 1
a5065 1
			break;
a5133 5
	if (ifp == status_ifp) {
		pf_status.bcounters[1][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[1][dir == PF_OUT][action != PF_PASS]++;
	}

a5134 14
	tr = r;
	if (r == &pf_default_rule && s != NULL && s->nat_rule.ptr != NULL)
		tr = s->nat_rule.ptr;
	if (tr->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->src.not);
	if (tr->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->dst.not);

d5159 35
@


1.389
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.388 2003/09/01 10:41:38 cedric Exp $ */
a2415 1
		s->dst.seqlo = 0;	/* Haven't seen these yet */
a2417 1
		s->dst.seqdiff = 0;	/* Defer random generation */
a2689 4
		s->src.seqlo = 0;
		s->src.seqhi = 0;
		s->src.seqdiff = 0;
		s->src.max_win = 0;
a2690 4
		s->dst.seqlo = 0;
		s->dst.seqhi = 0;
		s->dst.seqdiff = 0;
		s->dst.max_win = 0;
a2939 10
		s->src.seqlo = 0;
		s->src.seqhi = 0;
		s->src.seqdiff = 0;
		s->src.max_win = 0;
		s->src.state = 0;
		s->dst.seqlo = 0;
		s->dst.seqhi = 0;
		s->dst.seqdiff = 0;
		s->dst.max_win = 0;
		s->dst.state = 0;
a3151 1
			s->gwy.port = 0;
a3152 1
			s->ext.port = 0;
a3156 1
			s->lan.port = 0;
a3158 1
			s->lan.port = 0;
a3159 1
			s->ext.port = 0;
a3163 1
			s->gwy.port = 0;
a3164 4
		s->src.seqlo = 0;
		s->src.seqhi = 0;
		s->src.seqdiff = 0;
		s->src.max_win = 0;
a3165 4
		s->dst.seqlo = 0;
		s->dst.seqhi = 0;
		s->dst.seqdiff = 0;
		s->dst.max_win = 0;
@


1.389.2.1
log
@MFC:
Fix by dhartmei@@

fix binat for incoming connections when a netblock (not just a single
address) is used for source in the binat rule. closes PR 3535, reported
by Karl O.Pinc. ok henning@@, cedric@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.389 2003/09/01 15:08:39 henning Exp $ */
d1900 1
a1900 1
					    &r->src.addr.v.a.mask, daddr,
@


1.389.2.2
log
@MFC:
Fix by itojun@@

plug mbuf leak (ip_fragment() always free mbuf on error).

missing pieces from my previous commit.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.389.2.1 2003/10/31 06:06:29 brad Exp $ */
d4606 1
a4606 2
	if (error) {
		m0 = NULL;
a4607 1
	}
@


1.389.2.3
log
@MFC:
Fix by dhartmei@@ and mcbride@@

1.433
Properly m_copyback() modified TCP sequence number after demodulation

1.432
Fix icmp checksum when sequence number modlation is being used.
Also fix a daddr vs saddr cut-n-paste error in ICMP error handling.

Fixes PR 3724

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.389.2.2 2004/03/14 00:13:42 brad Exp $ */
a4006 1
			int			 copyback = 0;
d4044 2
a4045 2
			if (src->seqdiff) {
				pf_change_a(&th.th_seq, icmpsum,
a4046 2
				copyback = 1;
			}
d4066 1
a4066 1
					    daddr, &(*state)->lan.addr,
a4076 4
				copyback = 1;
			}

			if (copyback) {
d4096 2
@


1.389.2.4
log
@MFC:
Fix by dhartmei@@

prevent an endless loop with route-to lo0, fixes PR 3736

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.389.2.3 2004/04/10 09:38:19 brad Exp $ */
d4556 9
a4564 6
	if (m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL) != NULL)
		goto bad;
	mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
	if (mtag == NULL)
		goto bad;
	m_tag_prepend(m0, mtag);
d4566 1
a4566 1
	if (oifp != ifp) {
@


1.389.2.5
log
@MFC:
Fix by dhartmei@@

change pf_route() loop detection: introduce a counter (number of times
a packet is routed already) in the mbuf tag, allow at most four times.
Fixes some legitimate cases broken by the previous change.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.389.2.4 2004/04/30 23:27:57 brad Exp $ */
a4480 1
	struct m_tag		*mtag;
d4486 1
d4494 8
a4501 6
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
d4503 2
a4504 13
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
a4505 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
d4552 1
d4556 7
d4658 8
a4665 6
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
d4667 2
a4668 13
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
a4669 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
d4712 1
d4717 11
a4727 7
		if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip6_hdr))
			panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
		ip6 = mtod(m0, struct ip6_hdr *);
@


1.388
log
@Make nat rule update the table counters when no filtering rule is used.
This is mostly to support the new "nat pass" rule.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.387 2003/08/28 09:41:03 cedric Exp $ */
d1587 1
a1587 1
	    	if ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN)
@


1.387
log
@fix "pfctl -vvsr" output for rules with tables inside anchors.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.386 2003/08/21 19:12:07 frantzen Exp $ */
d4849 1
a4849 1
	struct pf_rule	  *a = NULL, *r = &pf_default_rule;
d5011 5
a5015 2
	if (r->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->src.addr.p.tbl,
d5018 3
a5020 3
		    r->src.not);
	if (r->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->dst.addr.p.tbl,
d5023 1
a5023 1
		    r->dst.not);
d5076 1
a5076 1
	struct pf_rule	  *a = NULL, *r = &pf_default_rule;
d5248 5
a5252 2
	if (r->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->src.addr.p.tbl,
d5255 3
a5257 3
		    r->src.not);
	if (r->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->dst.addr.p.tbl,
d5260 1
a5260 1
		    r->dst.not);
@


1.386
log
@Add Michal Zalewski's p0f v2 style passive OS fingerprinting to PF.
Exposes the source IP's operating system to the filter language.
Interesting policy decisions are now enforceable:
.	block proto tcp from any os SCO
.	block proto tcp from any os Windows to any port smtp
.	rdr ... from any os "Windows 98" to port WWW -> 127.0.0.1 port 8001
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.385 2003/08/18 11:01:41 dhartmei Exp $ */
d557 3
a559 1
	if (aw->type != PF_ADDR_TABLE || aw->p.tbl == NULL)
d561 5
a565 2
	aw->p.tblcnt = (aw->p.tbl->pfrkt_flags & PFR_TFLAG_ACTIVE) ?
		aw->p.tbl->pfrkt_cnt : -1;
@


1.385
log
@prevent looutput() feedback of broadcast/multicast packets if they are
pf routed. prevents a kernel lockup with some (non-sensical) route-to
rules. report and debugging by mpech@@. ok itojun@@, henning@@, mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.384 2003/08/17 15:36:48 dhartmei Exp $ */
d137 2
a138 1
struct pf_rule		*pf_match_translation(int, struct ifnet *, u_int8_t,
d140 3
a142 2
			    u_int16_t, sa_family_t, int);
struct pf_rule		*pf_get_translation(int, struct ifnet *, u_int8_t,
d145 1
a145 1
			    struct pf_addr *, u_int16_t *, sa_family_t);
d159 1
a159 1
			    int, struct ifnet *, struct mbuf *, void *,
d1766 3
a1768 3
pf_match_translation(int direction, struct ifnet *ifp, u_int8_t proto,
    struct pf_addr *saddr, u_int16_t sport, struct pf_addr *daddr,
    u_int16_t dport, sa_family_t af, int rs_num)
d1793 1
a1793 1
		else if (r->af && r->af != af)
d1795 1
a1795 1
		else if (r->proto && r->proto != proto)
d1797 1
a1797 1
		else if (PF_MISMATCHAW(&src->addr, saddr, af, src->not))
d1805 1
a1805 1
		    PF_MISMATCHAW(&dst->addr, daddr, af, dst->not))
d1807 1
a1807 1
		else if (xdst != NULL && PF_MISMATCHAW(xdst, daddr, af, 0))
d1813 4
d1834 2
a1835 1
pf_get_translation(int direction, struct ifnet *ifp, u_int8_t proto,
d1838 1
a1838 1
    struct pf_addr *naddr, u_int16_t *nport, sa_family_t af)
d1843 2
a1844 2
		r = pf_match_translation(direction, ifp, proto,
		    saddr, sport, daddr, dport, af, PF_RULESET_BINAT);
d1846 2
a1847 2
			r = pf_match_translation(direction, ifp, proto,
			    saddr, sport, daddr, dport, af, PF_RULESET_NAT);
d1849 2
a1850 2
		r = pf_match_translation(direction, ifp, proto,
		    saddr, sport, daddr, dport, af, PF_RULESET_RDR);
d1852 2
a1853 2
			r = pf_match_translation(direction, ifp, proto,
			    saddr, sport, daddr, dport, af, PF_RULESET_BINAT);
d1864 2
a1865 2
			if (pf_get_sport(af, proto, &r->rpool, saddr, daddr,
			    dport, naddr, nport, r->rpool.proxy_port[0],
d1886 1
a1886 1
					    saddr, af);
d1895 2
a1896 1
					    &r->src.addr.v.a.mask, saddr, af);
d2178 1
a2178 1
		if ((nat = pf_get_translation(PF_OUT, ifp, IPPROTO_TCP,
d2180 1
a2180 1
		    &naddr, &nport, af)) != NULL) {
d2191 3
a2193 3
		if ((rdr = pf_get_translation(PF_IN, ifp, IPPROTO_TCP,
		    saddr, th->th_sport, daddr, th->th_dport,
		    &naddr, &nport, af)) != NULL) {
d2247 3
d2501 1
a2501 1
		if ((nat = pf_get_translation(PF_OUT, ifp, IPPROTO_UDP,
d2503 1
a2503 1
		    &naddr, &nport, af)) != NULL) {
d2514 3
a2516 3
		if ((rdr = pf_get_translation(PF_IN, ifp, IPPROTO_UDP,
		    saddr, uh->uh_sport, daddr, uh->uh_dport,
		    &naddr, &nport, af)) != NULL) {
d2568 2
d2773 2
a2774 2
		if ((nat = pf_get_translation(PF_OUT, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d2796 2
a2797 2
		if ((rdr = pf_get_translation(PF_IN, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d2847 2
d2981 1
a2981 1
    struct ifnet *ifp, struct mbuf *m, void *h, struct pf_pdesc *pd,
d2998 2
a2999 2
		if ((nat = pf_get_translation(PF_OUT, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d3019 2
a3020 2
		if ((rdr = pf_get_translation(PF_IN, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d3064 2
d3247 2
a3248 1
		    r->flagset || r->type || r->code)
d4995 1
a4995 1
			action = pf_test_other(&r, &s, dir, ifp, m, h,
d5229 1
a5229 1
		action = pf_test_other(&r, &s, dir, ifp, m, h,
@


1.384
log
@Missing break, change NULL -> 0 for int parameter (no functional
changes), from Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.383 2003/08/14 19:00:12 jason Exp $ */
d4528 18
a4545 16
	if (oifp != ifp) {
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
			if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
				goto bad;
			else if (m0 == NULL)
				goto done;
			if (m0->m_len < sizeof(struct ip))
				panic("pf_route: m0->m_len < "
				    "sizeof(struct ip)");
			ip = mtod(m0, struct ip *);
		}
@


1.383
log
@m_copyback()'s 4th arg is const void *, nuke (caddr_t) casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.382 2003/08/09 14:56:48 cedric Exp $ */
d1220 1
d4664 1
a4664 1
		ip6_output(m0, NULL, NULL, NULL, NULL, NULL);
@


1.382
log
@This patch remove the restriction that tables cannot be used in routing or
redirection rules...

The advantage of using tables in redirection/routing rules is not efficiency,
in fact it will run slower than straight address pools. However, this brings
a lot of flexibility to PF, allowing simple scripts/daemons to add/remove
addresses from redirection/routing pools easily.

This implementation support all table features, including cidr blocks and
negated addresses. So specifying { 10.0.0.0/29 !10.0.0.0 !10.0.0.7 } will
correctly round-robin between the six addresses: .1, .2, .3, .4, .5, .6.

Tables can also be combined with simple addresses, so the following rule
will work as expected: "nat on foo0 -> { 1.1.1.1 <bar> }"

ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.381 2003/08/07 14:20:50 henning Exp $ */
d2270 1
a2270 1
			m_copyback(m, off, sizeof(*th), (caddr_t)th);
d2458 1
a2458 1
		m_copyback(m, off, sizeof(*th), (caddr_t)th);
d2588 1
a2588 1
			m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
d2699 1
a2699 1
		m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
d2867 1
a2867 1
			    (caddr_t)pd->hdr.icmp6);
d2957 1
a2957 1
		    (caddr_t)pd->hdr.icmp6);
d3677 1
a3677 1
		m_copyback(m, off, sizeof(*th), (caddr_t)th);
d3680 1
a3680 1
		m_copyback(m, off, sizeof(*th), (caddr_t)th);
d3750 1
a3750 1
		m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
d3846 1
a3846 1
					    (caddr_t)pd->hdr.icmp6);
d3866 1
a3866 1
					    (caddr_t)pd->hdr.icmp6);
d4057 1
a4057 1
					    (caddr_t)pd->hdr.icmp);
d4059 1
a4059 1
					    (caddr_t)&h2);
d4066 1
a4066 1
					    (caddr_t)pd->hdr.icmp6);
d4068 1
a4068 1
					    (caddr_t)&h2_6);
d4072 1
a4072 1
				m_copyback(m, off2, 8, (caddr_t)&th);
d4074 1
a4074 1
				m_copyback(m, off2, 8, (caddr_t)&th);
d4119 2
a4120 3
					    (caddr_t)pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2),
					    (caddr_t)&h2);
d4127 1
a4127 1
					    (caddr_t)pd->hdr.icmp6);
d4129 1
a4129 1
					    (caddr_t)&h2_6);
d4133 1
a4133 2
				m_copyback(m, off2, sizeof(uh),
				    (caddr_t)&uh);
d4175 3
a4177 6
				m_copyback(m, off, ICMP_MINLEN,
				    (caddr_t)pd->hdr.icmp);
				m_copyback(m, ipoff2, sizeof(h2),
				    (caddr_t)&h2);
				m_copyback(m, off2, ICMP_MINLEN,
				    (caddr_t)&iih);
d4221 2
a4222 3
				    (caddr_t)pd->hdr.icmp6);
				m_copyback(m, ipoff2, sizeof(h2_6),
				    (caddr_t)&h2_6);
d4224 1
a4224 1
				    (caddr_t)&iih);
d4261 2
a4262 3
					    (caddr_t)pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2),
					    (caddr_t)&h2);
d4269 1
a4269 1
					    (caddr_t)pd->hdr.icmp6);
d4271 1
a4271 1
					    (caddr_t)&h2_6);
@


1.381
log
@make pf_match take u_int32_t instead of u_int16_t
it's not only used to ,atch on ports any more but uid/gid as well, and uid_t/gid_t are u_int32_t.
found by aaron@@
ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.380 2003/07/29 20:56:55 dhartmei Exp $ */
a178 7

#ifdef INET6
void			 pf_poolmask(struct pf_addr *, struct pf_addr*,
			    struct pf_addr *, struct pf_addr *, u_int8_t);
void			 pf_addr_inc(struct pf_addr *, sa_family_t);
#endif /* INET6 */

d1569 3
a1571 2
	struct pf_addr		*raddr = &rpool->cur->addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.v.a.mask;
d1573 1
a1573 2
	if (rpool->cur->addr.type == PF_ADDR_NOROUTE ||
	    rpool->cur->addr.type == PF_ADDR_TABLE)
d1578 7
d1633 21
a1653 4
		if (pf_match_addr(0, &rpool->cur->addr.v.a.addr,
		    &rpool->cur->addr.v.a.mask, &rpool->counter, af)) {
			PF_ACPY(naddr, &rpool->counter, af);
			PF_AINC(&rpool->counter, af);
d1655 3
a1657 7
			if ((rpool->cur =
			    TAILQ_NEXT(rpool->cur, entries)) == NULL)
				rpool->cur = TAILQ_FIRST(&rpool->list);
			PF_ACPY(naddr, &rpool->cur->addr.v.a.addr, af);
			PF_ACPY(&rpool->counter,
			    &rpool->cur->addr.v.a.addr, af);
			PF_AINC(&rpool->counter, af);
d1659 4
@


1.380
log
@Set pf_state->rt_ifp when creating the state entry, instead of doing it
later on, when another packet matches the state. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.379 2003/07/29 00:51:32 cedric Exp $ */
d1325 1
a1325 1
pf_match(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
@


1.379
log
@More aggressive and easier to understand skip steps for addresses.
Help daniel@@ mcbride@@
Ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.378 2003/07/19 13:08:58 cedric Exp $ */
d206 2
d2099 26
d2393 1
d2671 1
d2927 1
d3166 1
a4506 6
			if (s->rt_ifp == NULL) {
				pf_map_addr(AF_INET, &r->rpool,
				    (struct pf_addr *)&ip->ip_src,
				    &s->rt_addr, NULL);
				s->rt_ifp = r->rpool.cur->ifp;
			}
a4666 6
		if (s->rt_ifp == NULL) {
			pf_map_addr(AF_INET6, &r->rpool,
			    (struct pf_addr *)&ip6->ip6_src,
			    &s->rt_addr, NULL);
			s->rt_ifp = r->rpool.cur->ifp;
		}
@


1.378
log
@Simplify struct pf_pooladdr to include struct pf_addr_wrap directly
instead of indirectly trough struct pf_rule_addr.

Ryan McBride says:
If I'm not mistaken, the code _used_ to use the ports in pf_rule_addr as
well. The code was changed to fix some of the bugs with port ranges, but
it was too late in the release cycle to make kernel API changes, so the
structure was left as is.

Needless to say: KERNEL/USERLAND SYNC REQUIRED.

ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.377 2003/07/12 09:36:23 dhartmei Exp $ */
d208 3
d814 2
a815 11
		if (cur->src.addr.type == PF_ADDR_DYNIFTL ||
		    prev->src.addr.type == PF_ADDR_DYNIFTL ||
		    cur->src.addr.type == PF_ADDR_TABLE ||
		    prev->src.addr.type == PF_ADDR_TABLE ||
		    cur->src.not != prev->src.not ||
		    (cur->src.addr.type == PF_ADDR_NOROUTE) !=
		    (prev->src.addr.type == PF_ADDR_NOROUTE) ||
		    !PF_AEQ(&cur->src.addr.v.a.addr,
		    &prev->src.addr.v.a.addr, 0) ||
		    !PF_AEQ(&cur->src.addr.v.a.mask,
		    &prev->src.addr.v.a.mask, 0))
d821 2
a822 11
		if (cur->dst.addr.type == PF_ADDR_DYNIFTL ||
		    prev->dst.addr.type == PF_ADDR_DYNIFTL ||
		    cur->dst.addr.type == PF_ADDR_TABLE ||
		    prev->dst.addr.type == PF_ADDR_TABLE ||
		    cur->dst.not != prev->dst.not ||
		    (cur->dst.addr.type == PF_ADDR_NOROUTE) !=
		    (prev->dst.addr.type == PF_ADDR_NOROUTE) ||
		    !PF_AEQ(&cur->dst.addr.v.a.addr,
		    &prev->dst.addr.v.a.addr, 0) ||
		    !PF_AEQ(&cur->dst.addr.v.a.mask,
		    &prev->dst.addr.v.a.mask, 0))
d834 28
@


1.377
log
@Remove two htons(), which were meant as ntohs(), and are wrong since
ip_ouput() flipped byte order. From Pyun YongHyeon. ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.376 2003/07/09 22:03:15 itojun Exp $ */
d1561 2
a1562 2
	struct pf_addr		*raddr = &rpool->cur->addr.addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.addr.v.a.mask;
d1564 2
a1565 2
	if (rpool->cur->addr.addr.type == PF_ADDR_NOROUTE ||
	    rpool->cur->addr.addr.type == PF_ADDR_TABLE)
d1567 2
a1568 2
	if (rpool->cur->addr.addr.type == PF_ADDR_DYNIFTL &&
	    rpool->cur->addr.addr.p.dyn->undefined)
d1618 2
a1619 2
		if (pf_match_addr(0, &rpool->cur->addr.addr.v.a.addr,
		    &rpool->cur->addr.addr.v.a.mask, &rpool->counter, af)) {
d1626 1
a1626 1
			PF_ACPY(naddr, &rpool->cur->addr.addr.v.a.addr, af);
d1628 1
a1628 1
			    &rpool->cur->addr.addr.v.a.addr, af);
d1741 1
d1746 1
a1746 1
				dst = &r->rpool.cur->addr;
d1771 3
a1773 2
			r = dst == &r->dst ? r->skip[PF_SKIP_DST_ADDR].ptr :
			    TAILQ_NEXT(r, entries);
d1777 1
a1777 2
			r = dst == &r->dst ? r->skip[PF_SKIP_DST_PORT].ptr :
			    TAILQ_NEXT(r, entries);
d1838 1
a1838 1
				if (r->rpool.cur->addr.addr.type ==
d1840 1
a1840 1
				    r->rpool.cur->addr.addr.p.dyn->undefined)
d1844 2
a1845 2
					    &r->rpool.cur->addr.addr.v.a.addr,
					    &r->rpool.cur->addr.addr.v.a.mask,
@


1.376
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.375 2003/07/04 10:57:27 markus Exp $ */
a4496 2
		ip->ip_len = htons((u_int16_t)ip->ip_len);
		ip->ip_off = htons((u_int16_t)ip->ip_off);
@


1.375
log
@cosmetic changes to keep the different code paths in sync; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.374 2003/07/04 10:39:30 henning Exp $ */
d1194 2
a1195 2
		h->ip_len = len;
		h->ip_off = ip_mtudisc ? IP_DF : 0;
d3847 1
a3847 1
			if (ntohs(h2.ip_off) & IP_OFFMASK)
d4330 1
a4330 1
		u_int16_t	 fragoff = (h->ip_off & IP_OFFMASK) << 3;
d4341 1
a4341 1
		if (m->m_pkthdr.len < off + len || h->ip_len < off + len) {
d4496 1
a4496 1
	if (ip->ip_len <= ifp->if_mtu) {
d4520 1
a4520 1
	if (ip->ip_off & IP_DF) {
d4827 1
a4827 1
	pd.tot_len = h->ip_len;
d4830 1
a4830 1
	if (h->ip_off & (IP_MF | IP_OFFMASK)) {
d4848 1
a4848 1
		    h->ip_len - off, IPPROTO_TCP, AF_INET)) {
d4879 1
a4879 1
		    off, h->ip_len - off, IPPROTO_UDP, AF_INET)) {
d4904 1
a4904 1
		    h->ip_len - off, IPPROTO_ICMP, AF_INET)) {
d4912 1
a4912 1
			r->bytes += h->ip_len;
d4916 1
a4916 1
				a->bytes += h->ip_len;
@


1.374
log
@-add a "natpass" field to pf_rule
-if natpass is nonzero on nat/rdr/binat rules, do not evaluate the filter
ruleset, but set the rulepointer to the default rule (which is a pass rule)

in cooperation with daniel.

ok dhartmei@@ cedric@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.373 2003/07/04 08:24:52 markus Exp $ */
a2173 2
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
d2177 2
d2567 2
a2568 1
		if (s == NULL)
d2570 1
a2574 1

d2826 2
a2827 1
		if (s == NULL)
d2829 1
a2833 1

d3064 2
a3065 1
		if (s == NULL)
d3067 1
a3071 1

d3604 1
a3604 1
	/* translate source/destination address, if needed */
d3646 2
a3647 2
	key.port[0] = pd->hdr.udp->uh_sport;
	key.port[1] = pd->hdr.udp->uh_dport;
d3765 1
a3765 1
		/* translate source/destination address, if needed */
@


1.373
log
@bad redundant copy; ok daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.372 2003/06/29 23:37:12 itojun Exp $ */
d2105 2
d2117 2
d2130 2
a2134 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2424 2
d2436 2
d2449 2
a2453 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2693 2
d2715 2
d2738 2
a2742 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2914 2
d2934 2
d2955 2
a2959 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
@


1.372
log
@normalize IPv6 packet (no reass, but it is a start).  dhartmei & henning ok
- length, jumbo payload option
- TTL ("hoplimit" in IPv6 terminology) rewrite
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.371 2003/06/29 12:25:03 itojun Exp $ */
a2289 1
				s->lan.addr = baddr;
@


1.371
log
@unused global. dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.370 2003/06/28 00:27:10 itojun Exp $ */
d5005 5
@


1.370
log
@remove duplicated prototype (they are in pfvar.h).  dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.369 2003/06/24 13:55:13 henning Exp $ */
a101 1
struct pf_tagnames	 pf_tagnames;
@


1.369
log
@in the ipv6 case, allow route-to to route to link-local addresses

from KOZUKA Masahiro <ma-kun@@kozuka.jp> with a minor adjustment from itojun

ok itojun@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.368 2003/06/24 13:52:50 henning Exp $ */
a113 7
void			 pf_addrcpy(struct pf_addr *, struct pf_addr *,
			    sa_family_t);
int			 pf_insert_state(struct pf_state *);
struct pf_state		*pf_find_state(struct pf_state_tree *,
			    struct pf_tree_node *);
void			 pf_purge_expired_states(void);
void			 pf_purge_timeout(void *);
a175 3
void			 pf_calc_skip_steps(struct pf_rulequeue *);
void			 pf_rule_set_qid(struct pf_rulequeue *);
u_int32_t		 pf_qname_to_qid(char *);
@


1.368
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.367 2003/06/21 09:07:01 djm Exp $ */
d80 1
d4651 2
d4654 1
a4654 2
		error = (*ifp->if_output)(ifp, m0, (struct sockaddr *)dst,
		    NULL);
@


1.367
log
@count packets and bidirectionally on state entries, allowing for fine-grained
traffic reporting w/ pfsync; ok dhartmei@@

Note: ABI change (new fields in struct pf_state), requires a rebuild of
pfctl and tcpdump.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.366 2003/06/20 18:24:57 dhartmei Exp $ */
d1105 1
a1105 1
	
d3513 1
a3513 1
			    seq, ack, pd->p_len, ackskew, 
@


1.366
log
@Add MSS support to the synproxy. The client's MSS is sent to the server,
the server's MSS is guessed based on the routing table and interface MTU.

Fine patch entirely from Krists Krilovs <pow@@pow.za.net>, ok frantzen@@

Note: ABI change (new field in struct pf_state), requires a pfctl rebuild
(and tcpdump for pfsync).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.365 2003/06/20 17:38:24 dhartmei Exp $ */
d2355 2
a2356 2
		s->packets = 1;
		s->bytes = pd->tot_len;
d2626 2
a2627 2
		s->packets = 1;
		s->bytes = pd->tot_len;
d2875 2
a2876 2
		s->packets = 1;
		s->bytes = pd->tot_len;
d3107 2
a3108 2
		s->packets = 1;
		s->bytes = pd->tot_len;
d3212 1
a3212 1
	int			 ackskew;
d3228 1
d3232 1
d3430 2
a3431 2
		(*state)->packets++;
		(*state)->bytes += pd->tot_len;
d3512 3
a3514 2
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d\n",
			    seq, ack, pd->p_len, ackskew, (*state)->packets);
d3517 2
a3518 2
		(*state)->packets++;
		(*state)->bytes += pd->tot_len;
d3567 1
a3567 1
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d "
d3569 1
a3569 1
			    ++(*state)->packets,
d3628 1
d3642 1
d3646 1
d3649 2
a3650 2
	(*state)->packets++;
	(*state)->bytes += pd->tot_len;
d3698 1
a3698 1
	int		 state_icmp = 0;
d3747 3
a3749 2
		(*state)->packets++;
		(*state)->bytes += pd->tot_len;
d4222 1
d4236 1
d4240 1
d4243 2
a4244 2
	(*state)->packets++;
	(*state)->bytes += pd->tot_len;
@


1.365
log
@Extend 'BAD ICMP' debug message, include icmp type/code and outer IP header
addresses. ok mcbride@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.364 2003/06/14 07:23:15 dhartmei Exp $ */
d141 1
a141 1
			    u_int8_t, u_int16_t, u_int8_t);
d212 4
d502 1
d1087 1
a1087 1
    u_int8_t flags, u_int16_t win, u_int8_t ttl)
d1091 1
a1091 1
	int		 len;
d1099 1
d1101 5
d1109 1
a1109 1
		len = sizeof(struct ip) + sizeof(struct tcphdr);
d1114 1
a1114 1
		len = sizeof(struct ip6_hdr) + sizeof(struct tcphdr);
d1155 1
a1155 1
		h->ip_len = htons(sizeof(*th));
d1168 1
a1168 1
		h6->ip6_plen = htons(sizeof(*th));
d1182 1
a1182 1
	th->th_off = sizeof(*th) >> 2;
d1186 8
d1216 1
a1216 1
		    sizeof(struct ip6_hdr), sizeof(*th));
d2005 88
d2113 1
d2245 1
a2245 1
			    ntohl(th->th_ack), ack, TH_RST|TH_ACK, 0,
d2390 5
d2397 1
a2397 1
			    ntohl(th->th_seq) + 1, TH_SYN|TH_ACK, 0, 0);
d3242 1
a3242 1
			    TH_SYN|TH_ACK, 0, 0);
d3271 1
a3271 1
			    (*state)->dst.seqhi, 0, TH_SYN, 0, 0);
d3283 1
a3283 1
			    TH_ACK, (*state)->src.max_win, 0);
d3287 1
a3287 1
			    TH_ACK, (*state)->dst.max_win, 0);
d3554 1
a3554 1
				    TH_RST|TH_ACK, 0,
@


1.364
log
@Use source's window scaling factor (instead of destination's) when
comparing ackskew, otherwise legitimate low acks can get blocked. Was
triggered when asymmetric scale factors where used in combination with
SACK. Report and logs provided by Peter Galbavy. ok frantzen@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.363 2003/06/10 22:05:03 dhartmei Exp $ */
d3832 6
a3837 1
					printf("pf: BAD ICMP state: ");
@


1.363
log
@It would kind of help if the flags member was initialized, otherwise random
rules create state. Truly hard to spot. Unless you run the code, of course.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.362 2003/06/09 11:14:46 mcbride Exp $ */
d3312 1
a3312 1
	    (ackskew <= (MAXACKWINDOW << dws))) {
d3461 1
a3461 1
			    (ackskew <= MAXACKWINDOW) ? ' ' : '4',
@


1.362
log
@Attempt to resolve byte order confusion in nat code once and for all.

- pf_get_sport() leaves the translated port in the packet in network byte order
- merge code for the p1=0 p2=0 case and static-port case in pr_get_sport()

NOTE: people who use the static-port keyword in their pf.conf need to make sure pfctl is updated along with their kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.361 2003/06/03 12:34:04 henning Exp $ */
d4679 1
d4889 1
@


1.361
log
@move some prototypes to pfvar.h. needed soon.
pf_tagname2tag, pf_tag2tagname, pf_tag_unref, pf_tag_packet
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.360 2003/05/18 19:58:56 henning Exp $ */
a1662 4
		} else if (rpool->opts & PF_POOL_STATICPORT) {
			key.port[1] = *nport;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL)
				return (0);
a1665 1
				NTOHS(*nport);
d1671 1
a1671 1
				*nport = low;
d1675 2
a1677 2
				u_int16_t tmp;

d1685 5
a1689 3
			for (*nport = cut; *nport <= high; ++(*nport)) {
				key.port[1] = htons(*nport);
				if (pf_find_state(&tree_ext_gwy, &key) == NULL)
d1691 1
d1693 5
a1697 3
			for (*nport = cut - 1; *nport >= low; --(*nport)) {
				key.port[1] = htons(*nport);
				if (pf_find_state(&tree_ext_gwy, &key) == NULL)
d1699 1
@


1.360
log
@speed hack: delay fetching the mbuf tag until we really need it (hit a
"tagged X" rule), and only get it when we really need it. simplifies code too.

ok dhartmei@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.359 2003/05/18 18:33:28 dhartmei Exp $ */
a188 2
int			 pf_tag_packet(struct mbuf *, struct pf_tag *,
			     int);
@


1.359
log
@Merge pf_send_ack() and _send_syn() into a generic _send_tcp().
In the SYN proxy, generate ACKs with proper window sizes after the
handshakes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.358 2003/05/17 21:15:23 dhartmei Exp $ */
d186 3
d190 1
a190 1
			     u_int16_t);
d1365 21
a1385 1
pf_tag_packet(struct mbuf *m, struct pf_tag *pftag, u_int16_t tag)
d1389 1
a1389 1
	if (tag == 0)
d2005 2
a2006 8
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
a2031 5
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

d2075 1
a2075 2
		    ((!r->match_tag_not && r->match_tag != tag) ||
		    (r->match_tag_not && r->match_tag == tag)))
d2315 2
a2316 8
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
a2341 5
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

d2381 1
a2381 2
		    ((!r->match_tag_not && r->match_tag != tag) ||
		    (r->match_tag_not && r->match_tag == tag)))
d2546 2
a2547 2
	struct pf_tag		*pftag;
	u_int16_t		 tag;
a2551 6
	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;

a2625 5
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

d2651 1
a2651 2
		    ((!r->match_tag_not && r->match_tag != tag) ||
		    (r->match_tag_not && r->match_tag == tag)))
d2795 2
a2796 8
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
a2837 5
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

d2859 1
a2859 2
		    ((!r->match_tag_not && r->match_tag != tag) ||
		    (r->match_tag_not && r->match_tag == tag)))
d3020 2
a3021 8
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
d3045 1
a3045 2
		    ((!r->match_tag_not && r->match_tag != tag) ||
		    (r->match_tag_not && r->match_tag == tag)))
@


1.358
log
@Correct two comment typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.357 2003/05/17 03:04:45 mcbride Exp $ */
d138 4
a141 6
void			 pf_send_syn(sa_family_t, const struct pf_addr *,
			    const struct pf_addr *, u_int16_t, u_int16_t,
			    u_int32_t);
void			 pf_send_ack(int, struct tcphdr *,
			    struct pf_pdesc *, sa_family_t, u_int8_t,
			    struct pf_rule *, u_int8_t, u_int32_t);
d488 10
d1078 4
a1081 3
pf_send_syn(sa_family_t af, const struct pf_addr *saddr,
    const struct pf_addr *daddr, u_int16_t sport, u_int16_t dport,
    u_int32_t isn)
d1117 15
d1168 2
a1169 2
	th->th_seq = htonl(isn);
	th->th_ack = 0;
d1171 2
a1172 4
	th->th_flags = TH_SYN;
	th->th_win = htons(1);
	th->th_sum = 0;
	th->th_urp = 0;
d1183 1
a1183 2
		h->ip_ttl = ip_defttl;
		h->ip_sum = 0;
d1186 2
a1206 145
pf_send_ack(int off, struct tcphdr *th, struct pf_pdesc *pd, sa_family_t af,
    u_int8_t return_ttl, struct pf_rule *r, u_int8_t flags, u_int32_t isn)
{
	struct mbuf	*m;
	struct m_tag	*mtag;
	int		 len;
#ifdef INET
	struct ip	*h2;
#endif /* INET */
#ifdef INET6
	struct ip6_hdr	*h2_6;
#endif /* INET6 */
	struct tcphdr	*th2;

	switch (af) {
#ifdef INET
	case AF_INET:
		len = sizeof(struct ip) + sizeof(struct tcphdr);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		len = sizeof(struct ip6_hdr) + sizeof(struct tcphdr);
		break;
#endif /* INET6 */
	}

	/* don't reply to RST packets */
	if (th->th_flags & TH_RST)
		return;

	/* create outgoing mbuf */
	mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
	if (mtag == NULL)
		return;
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	if (m == NULL) {
		m_tag_free(mtag);
		return;
	}
	m_tag_prepend(m, mtag);
	m->m_data += max_linkhdr;
	m->m_pkthdr.len = m->m_len = len;
	m->m_pkthdr.rcvif = NULL;
	bzero(m->m_data, len);
	switch (af) {
#ifdef INET
	case AF_INET:
		h2 = mtod(m, struct ip *);

		/* IP header fields included in the TCP checksum */
		h2->ip_p = IPPROTO_TCP;
		h2->ip_len = htons(sizeof(*th2));
		h2->ip_src.s_addr = pd->dst->v4.s_addr;
		h2->ip_dst.s_addr = pd->src->v4.s_addr;

		th2 = (struct tcphdr *)((caddr_t)h2 + sizeof(struct ip));
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		h2_6 = mtod(m, struct ip6_hdr *);

		/* IP header fields included in the TCP checksum */
		h2_6->ip6_nxt = IPPROTO_TCP;
		h2_6->ip6_plen = htons(sizeof(*th2));
		memcpy(&h2_6->ip6_src, pd->dst, sizeof(struct in6_addr));
		memcpy(&h2_6->ip6_dst, pd->src, sizeof(struct in6_addr));

		th2 = (struct tcphdr *)((caddr_t)h2_6 + sizeof(struct ip6_hdr));
		break;
#endif /* INET6 */
	}

	/* TCP header */
	th2->th_sport = th->th_dport;
	th2->th_dport = th->th_sport;
	if (th->th_flags & TH_ACK) {
		th2->th_seq = th->th_ack;
		th2->th_flags = flags;
	} else {
		int tlen = pd->p_len;
		if (th->th_flags & TH_SYN)
			tlen++;
		if (th->th_flags & TH_FIN)
			tlen++;
		th2->th_ack = htonl(ntohl(th->th_seq) + tlen);
		th2->th_flags = TH_ACK | flags;
		if (flags & TH_SYN)
			th2->th_seq = htonl(isn);
	}
	th2->th_off = sizeof(*th2) >> 2;

#ifdef ALTQ
	if (r->qid) {
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m, struct ip *);
			m_tag_prepend(m, mtag);
		}
	}
#endif

	switch (af) {
#ifdef INET
	case AF_INET:
		/* TCP checksum */
		th2->th_sum = in_cksum(m, len);

		/* Finish the IP header */
		h2->ip_v = 4;
		h2->ip_hl = sizeof(*h2) >> 2;
		if (!return_ttl)
			return_ttl = ip_defttl;
		h2->ip_ttl = return_ttl;
		h2->ip_sum = 0;
		h2->ip_len = len;
		h2->ip_off = ip_mtudisc ? IP_DF : 0;
		ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL,
		    (void *)NULL);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		/* TCP checksum */
		th2->th_sum = in6_cksum(m, IPPROTO_TCP,
		    sizeof(struct ip6_hdr), sizeof(*th));

		h2_6->ip6_vfc |= IPV6_VERSION;
		if (!return_ttl)
			return_ttl = IPV6_DEFHLIM;
		h2_6->ip6_hlim = return_ttl;

		ip6_output(m, NULL, NULL, 0, NULL, NULL);
#endif /* INET6 */
	}
}

void
d2116 14
a2129 5
		if ((r->rule_flag & PFRULE_RETURNRST) ||
		    (r->rule_flag & PFRULE_RETURN))
			pf_send_ack(off, th, pd, af,
			    r->return_ttl, r, TH_RST, 0);
		else if ((af == AF_INET) && r->return_icmp)
d2272 3
a2274 2
			pf_send_ack(off, th, pd, af, r->return_ttl, r,
			    TH_SYN, s->src.seqhi);
d3159 4
a3162 2
			pf_send_ack(off, th, pd, pd->af, 0, (*state)->rule.ptr,
			    TH_SYN, (*state)->src.seqhi);
d3172 9
d3186 1
d3189 3
a3191 8
			if (direction == PF_OUT)
				pf_send_syn(pd->af, &(*state)->gwy.addr,
				    &(*state)->ext.addr, (*state)->gwy.port,
				    (*state)->ext.port, (*state)->dst.seqhi);
			else
				pf_send_syn(pd->af, &(*state)->ext.addr,
				    &(*state)->lan.addr, (*state)->ext.port,
				    (*state)->lan.port, (*state)->dst.seqhi);
d3200 8
a3207 2
			pf_send_ack(off, th, pd, pd->af, 0,
			    (*state)->rule.ptr, 0, 0);
d3464 13
a3476 2
			pf_send_ack(off, th, pd, pd->af, 0,
			    (*state)->rule.ptr, TH_RST, 0);
@


1.357
log
@With rdr we want the source IP from the packet, not the source IP from
the rule. Fixes rdr with address pools using bitmask and source-hash
address selection methods.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.356 2003/05/17 02:01:20 henning Exp $ */
d2228 1
a2228 1
		/* undo NAT/RST changes, if they have taken place */
d2537 1
a2537 1
		/* undo NAT/RST changes, if they have taken place */
@


1.356
log
@allow inverse matching on tags

ok dhartmei@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.355 2003/05/17 01:08:50 dhartmei Exp $ */
d1950 1
a1950 2
			if (pf_map_addr(r->af, &r->rpool,
			    &r->src.addr.v.a.addr, naddr, NULL))
@


1.355
log
@Add an 'action' code that allows the SYN proxy to swallow/drop a packet
without causing EHOSTUNREACH to be delivered to local sockets, so it works
for outgoing connections originating on the same host. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.354 2003/05/16 17:15:17 dhartmei Exp $ */
d2185 3
a2187 1
		else if (r->match_tag && r->match_tag != tag)
d2493 3
a2495 1
		else if (r->match_tag && r->match_tag != tag)
d2775 3
a2777 1
		else if (r->match_tag && r->match_tag != tag)
d2995 3
a2997 1
		else if (r->match_tag && r->match_tag != tag)
d3188 3
a3190 1
		else if (r->match_tag && r->match_tag != tag)
@


1.354
log
@TCP SYN proxy. Instead of 'keep state' or 'modulate state', one can use
'synproxy state' for TCP connections. pf will complete the TCP handshake
with the active endpoint before passing any packets to the passive end-
point, preventing spoofed SYN floods from reaching the passive endpoint.

No additional memory requirements, no cookies needed, random initial
sequence numbers, uses the existing sequence number modulators to translate
packets after the handshakes.

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.353 2003/05/14 23:46:45 frantzen Exp $ */
a2371 1
		/* SYN proxy handling */
d2386 1
a2386 1
			return (PF_DROP);
d3258 1
a3258 1
			return (PF_DROP);
d3264 1
a3264 1
			return (PF_DROP);
d3288 1
a3288 1
			return (PF_DROP);
d3294 1
d3302 4
a3305 3
			/* XXX */
			(*state)->src.seqhi = (*state)->src.seqlo + 65536;
			(*state)->dst.seqhi = (*state)->dst.seqlo + 65536;
d3309 1
a3309 1
			return (PF_DROP);
d4777 1
a4777 1
		ACTION_SET(&action, PF_DROP);
d4909 1
a4909 1
		pf_status.pcounters[0][dir == PF_OUT][action]++;
d4924 1
a4924 1
	if (action != PF_DROP && h->ip_hl > 5 &&
d4934 1
a4934 1
	if (action != PF_DROP && r->qid) {
d4956 6
a4961 2
	/* pf_route can free the mbuf causing *m0 to become NULL */
	if (r->rt)
d5137 1
a5137 1
		pf_status.pcounters[1][dir == PF_OUT][action]++;
d5155 1
a5155 1
	if (action != PF_DROP && r->qid) {
d5177 6
a5182 2
	/* pf_route6 can free the mbuf causing *m0 to become NULL */
	if (r->rt)
@


1.353
log
@- modulate TCP Timestamps so they can't be used to detect NAT and to preclude
remote uptime determination
- scrub modifier "reassemble tcp" turns on stateful TCP normalizations
ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.352 2003/05/14 21:50:56 henning Exp $ */
a61 1
#include <netinet/tcp_fsm.h>
d138 4
a141 1
void			 pf_send_reset(int, struct tcphdr *,
d143 1
a143 1
			    struct pf_rule *);
d1070 116
a1185 2
pf_send_reset(int off, struct tcphdr *th, struct pf_pdesc *pd, sa_family_t af,
    u_int8_t return_ttl, struct pf_rule *r)
d1263 1
a1263 1
		th2->th_flags = TH_RST;
d1271 3
a1273 1
		th2->th_flags = TH_RST | TH_ACK;
d2239 2
a2240 2
			pf_send_reset(off, th, pd, af,
			    r->return_ttl, r);
d2372 17
d3257 55
d3337 1
a3337 1
		if (dst->seqdiff) {
d3553 2
a3554 2
			pf_send_reset(off, th, pd, pd->af, 0,
			    (*state)->rule.ptr);
@


1.352
log
@tag on each matching rule, not just the last one.

idea from theo.

to speed that up the real mbuf tag is not written until we hit the last match
but an internal variable is used to track the tag.

this can be used to split classification and policy enforcement, for example.
and much much much more...

ok dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.351 2003/05/14 08:42:00 canacar Exp $ */
a130 2
void			 pf_change_a(u_int32_t *, u_int16_t *, u_int32_t,
			    u_int8_t);
a181 2
void			*pf_pull_hdr(struct mbuf *, int, void *, int,
			    u_short *, u_short *, sa_family_t);
d946 2
d949 1
a949 1
pf_change_a(u_int32_t *a, u_int16_t *c, u_int32_t an, u_int8_t u)
d951 1
a951 1
	u_int32_t	ao = *a;
d953 2
a954 1
	*a = an;
d2139 2
a2140 1
	if (r->keep_state || nat != NULL || rdr != NULL) {
d2235 1
a2235 1
		    pd, th, &s->src, &s->dst)) {
d2240 7
d3102 1
d3140 1
a3140 1
			if (pf_normalize_tcp_init(m, pd, th, src, dst)) {
d3154 1
d3206 1
d3389 3
a3391 2
	if ((pd->flags & PFDESC_TCP_NORM) && (dst->scrub || src->scrub)) {
		if (pf_normalize_tcp_stateful(m, pd, reason, th, src, dst))
d3408 2
a3409 2
	} else if (src->seqdiff) {
		/* Copyback sequence modulation */
@


1.351
log
@Use official (from pcap people) link type for pflog.
With this change, the log header format also changes.
The new log format is extendible and allows logging
of the originating anchor and ruleset information.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.350 2003/05/14 04:51:10 henning Exp $ */
d189 3
a191 2
int			 pf_match_tag(struct mbuf *, struct pf_rule *,
			     struct pf_rule *);
d1355 11
d1367 1
a1367 1
pf_match_tag(struct mbuf *m, struct pf_rule *r, struct pf_rule *nat)
a1369 1
	struct pf_tag	*pftag;
d1371 2
a1372 2
	if (nat != NULL && nat->tag == r->match_tag)
		return (1);
d1374 3
a1376 3
	if ((mtag = m_tag_find(m, PACKET_TAG_PF_TAG, NULL)) != NULL) {
		pftag = (struct pf_tag *)(mtag + 1);
		if (pftag->tag == r->match_tag)
d1378 5
a1382 1
	}
d1988 8
d2021 5
d2068 1
a2068 1
		else if (r->match_tag && !pf_match_tag(m, r, nat))
d2071 2
d2135 5
d2274 8
d2307 5
d2350 1
a2350 1
		else if (r->match_tag && !pf_match_tag(m, r, nat))
d2355 2
d2414 5
d2515 2
d2521 6
d2601 5
d2630 1
a2630 1
		else if (r->match_tag && !pf_match_tag(m, r, nat))
d2635 2
d2676 5
d2774 8
d2823 5
d2848 1
a2848 1
		else if (r->match_tag && !pf_match_tag(m, r, nat))
d2853 2
d2919 5
d3009 8
d3039 1
a3039 1
		else if (r->match_tag && !pf_match_tag(m, r, NULL))
d3076 5
a4548 1
	struct m_tag	  *mtag;
a4730 14
	if (action != PF_DROP && r->tag) {
		struct pf_tag	*pftag;

		mtag = m_tag_get(PACKET_TAG_PF_TAG, sizeof(*pftag), M_NOWAIT);
		if (mtag == NULL) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_MEMORY);
		} else {
			pftag = (struct pf_tag *)(mtag + 1);
			pftag->tag = r->tag;
			m_tag_prepend(m, mtag);
		}
	}

a4767 1
	struct m_tag	  *mtag;
a4946 14

	if (action != PF_DROP && r->tag) {
		struct pf_tag	*pftag;

		mtag = m_tag_get(PACKET_TAG_PF_TAG, sizeof(*pftag), M_NOWAIT);
		if (mtag == NULL) {
			action = PF_DROP;
			REASON_SET(&reason, PFRES_MEMORY);
		} else {
			pftag = (struct pf_tag *)(mtag + 1);
			pftag->tag = r->tag;
			m_tag_prepend(m, mtag);
		}
	}
@


1.350
log
@2 lines of code bring us tags on nat rules

ok dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.349 2003/05/13 17:45:23 henning Exp $ */
d153 8
a160 6
int			 pf_test_tcp(struct pf_rule **, struct pf_state **, int,
			    struct ifnet *, struct mbuf *, int, int, void *,
			    struct pf_pdesc *, struct pf_rule **);
int			 pf_test_udp(struct pf_rule **, struct pf_state **, int,
			    struct ifnet *, struct mbuf *, int, int, void *,
			    struct pf_pdesc *, struct pf_rule **);
d163 2
a164 1
			    void *, struct pf_pdesc *, struct pf_rule **);
d167 2
a168 1
			    struct pf_pdesc *, struct pf_rule **);
d171 2
a172 1
			    struct pf_pdesc *, struct pf_rule **);
d1958 1
a1958 1
    struct pf_pdesc *pd, struct pf_rule **am)
d2046 1
d2060 1
d2073 1
a2073 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2224 1
a2224 1
    struct pf_pdesc *pd, struct pf_rule **am)
d2310 1
d2324 1
d2337 1
a2337 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2448 1
a2448 1
    struct pf_pdesc *pd, struct pf_rule **am)
d2570 1
d2584 1
d2600 1
a2600 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2690 1
a2690 1
    struct pf_rule **am)
d2768 1
d2782 1
d2792 1
a2792 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2895 1
a2895 1
				    a ? a : r);
d2907 2
a2908 1
    struct mbuf *m, void *h, struct pf_pdesc *pd, struct pf_rule **am)
d2944 1
d2958 1
d2968 1
a2968 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d4439 10
a4448 9
	u_short		 action, reason = 0, log = 0;
	struct mbuf	*m = *m0;
	struct m_tag	*mtag;
	struct ip	*h;
	struct pf_rule	*a = NULL, *r = &pf_default_rule;
	struct pf_state	*s = NULL;
	struct pf_pdesc	 pd;
	int		 off;
	int		 pqid = 0;
d4492 2
a4493 1
		action = pf_test_fragment(&r, dir, ifp, m, h, &pd, &a);
d4526 1
a4526 1
			    m, 0, off, h, &pd, &a);
d4551 1
a4551 1
			    m, 0, off, h, &pd, &a);
d4582 1
a4582 1
			    m, 0, off, h, &pd, &a);
d4593 2
a4594 1
			action = pf_test_other(&r, &s, dir, ifp, m, h, &pd, &a);
d4659 1
a4659 1
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, a ? a : r);
d4673 9
a4681 8
	u_short		 action, reason = 0, log = 0;
	struct mbuf	*m = *m0;
	struct m_tag	*mtag;
	struct ip6_hdr	*h;
	struct pf_rule	*a = NULL, *r = &pf_default_rule;
	struct pf_state	*s = NULL;
	struct pf_pdesc pd;
	int		off, terminal = 0;
d4714 2
a4715 1
			action = pf_test_fragment(&r, dir, ifp, m, h, &pd, &a);
d4776 1
a4776 1
			    m, 0, off, h, &pd, &a);
d4800 1
a4800 1
			    m, 0, off, h, &pd, &a);
d4827 1
a4827 1
			    m, 0, off, h, &pd, &a);
d4832 2
a4833 1
		action = pf_test_other(&r, &s, dir, ifp, m, h, &pd, &a);
d4891 1
a4891 1
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, a ? a : r);
@


1.349
log
@add support for tagging packets with arbitary tags and filtering based on
those tags later on.

ok dhartmei@@ pb@@ mcbride@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.348 2003/05/12 22:53:47 frantzen Exp $ */
d184 2
a185 1
int			 pf_match_tag(struct mbuf *, struct pf_rule *);
d1350 1
a1350 1
pf_match_tag(struct mbuf *m, struct pf_rule *r)
d1355 3
d2035 1
a2035 1
		else if (r->match_tag && !pf_match_tag(m, r))
d2295 1
a2295 1
		else if (r->match_tag && !pf_match_tag(m, r))
d2553 1
a2553 1
		else if (r->match_tag && !pf_match_tag(m, r))
d2749 1
a2749 1
		else if (r->match_tag && !pf_match_tag(m, r))
d2922 1
a2922 1
		else if (r->match_tag && !pf_match_tag(m, r))
@


1.348
log
@- TCP window scaling is not applied to the SYNs' window so we must retract the
initial maximum window by the scaling factor.  otherwise our view of the
allowable sequence window is too big.  back out the scaling factor adjustment
from the max window if the other endpoint rejects window scaling
- window scale the forward ACK skew check
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.347 2003/05/12 17:49:03 mcbride Exp $ */
d102 1
d184 1
d1348 14
d2031 2
d2291 2
d2549 2
d2745 2
d2918 2
d4421 1
d4601 14
d4652 1
d4829 14
@


1.347
log
@Reorder IPv6 address comparisons to check the least significant parts
first. The least significant portions of the IPv6 address are more
likely to differ than the more significant ones, since in most
situations half the addresses (either the source or the destination)
will be in the local subnet.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.346 2003/05/12 01:25:31 dhartmei Exp $ */
d2148 8
a2157 1
		s->src.max_win = MAX(ntohs(th->th_win), 1);
d2999 18
a3016 1
			src->wscale = pf_get_wscale(m, off, th->th_off, pd->af);
d3079 2
a3080 2
	    /* Acking not more than one window back */
	    (ackskew <= MAXACKWINDOW)) {
@


1.346
log
@Adaptive timeout value scaling. Allows to reduce timeout values as the
number of state table entries grows, so entries time out faster before
the table fills up. Works both globally and per-rule. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.345 2003/05/11 20:44:03 frantzen Exp $ */
d268 1
a268 1
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
d270 1
a270 1
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
d272 1
a272 1
		if (a->addr[0].addr32[1] > b->addr[0].addr32[1])
d274 1
a274 1
		if (a->addr[0].addr32[1] < b->addr[0].addr32[1])
d280 1
a280 1
		if (a->addr[0].addr32[3] > b->addr[0].addr32[3])
d282 1
a282 1
		if (a->addr[0].addr32[3] < b->addr[0].addr32[3])
d284 1
a284 1
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
d286 1
a286 1
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
d292 1
a292 1
		if (a->addr[1].addr32[2] > b->addr[1].addr32[2])
d294 1
a294 1
		if (a->addr[1].addr32[2] < b->addr[1].addr32[2])
d296 1
a296 1
		if (a->addr[1].addr32[3] > b->addr[1].addr32[3])
d298 1
a298 1
		if (a->addr[1].addr32[3] < b->addr[1].addr32[3])
@


1.345
log
@the start of stateful TCP scrubbing.  dynamically determine the highest TTL of
each side of the TCP connection and prevent it from being reduced
ok pb@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.344 2003/05/11 01:17:15 dhartmei Exp $ */
a237 3
#define TIMEOUT(r,i) \
	((r)->timeout[(i)] ? (r)->timeout[(i)] : pf_default_rule.timeout[(i)])

d437 36
d482 1
a482 1
		if (cur->state->expire <= (unsigned)time.tv_sec) {
d2158 2
a2159 1
		s->expire = s->creation + TIMEOUT(r, PFTM_TCP_FIRST_PACKET);
d2386 2
a2387 1
		s->expire = s->creation + TIMEOUT(r, PFTM_UDP_FIRST_PACKET);
d2621 2
a2622 1
		s->expire = s->creation + TIMEOUT(r, PFTM_ICMP_FIRST_PACKET);
d2839 2
a2840 1
		s->expire = s->creation + TIMEOUT(r, PFTM_OTHER_FIRST_PACKET);
d3090 1
d3093 1
a3093 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_CLOSED);
d3096 1
a3096 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_FIN_WAIT);
d3099 1
a3099 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_OPENING);
d3102 1
a3102 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_CLOSING);
d3104 1
a3104 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_ESTABLISHED);
d3272 1
d3274 1
a3274 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_UDP_MULTIPLE);
d3276 1
a3276 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_UDP_SINGLE);
d3362 2
a3363 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_ICMP_ERROR_REPLY);
d3857 1
d3859 1
a3859 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_OTHER_MULTIPLE);
d3861 1
a3861 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_OTHER_SINGLE);
@


1.344
log
@Use sizeof(struct icmp6_hdr) instead of ICMP_MINLEN for IPv6, both are
8 bytes, but the former is more appropriate. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.343 2003/05/10 23:32:48 dhartmei Exp $ */
d169 1
a169 1
			    void *, struct pf_pdesc *);
a197 2
int			 pf_normalize_tcp(int, struct ifnet *, struct mbuf *,
			    int, int, void *, struct pf_pdesc *);
d481 1
d2128 7
d2136 1
d2888 2
a2889 1
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d2932 8
d3168 5
d4415 2
a4416 1
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd);
d4647 2
a4648 1
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd);
@


1.343
log
@Pass ICMP error messages referring to non-TCP/UDP/ICMP packets statefully,
instead of just dropping them. ok frantzen@@, henning@@, pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.342 2003/05/10 23:04:31 dhartmei Exp $ */
d2511 1
a2511 1
			m_copyback(m, off, ICMP_MINLEN,
d2593 1
a2593 1
		m_copyback(m, off, ICMP_MINLEN,
d3328 2
a3329 1
					m_copyback(m, off, ICMP_MINLEN,
d3348 2
a3349 1
					m_copyback(m, off, ICMP_MINLEN,
d3543 2
a3544 1
					m_copyback(m, off, ICMP_MINLEN,
d3605 2
a3606 1
					m_copyback(m, off, ICMP_MINLEN,
d3673 2
a3674 2
			if (!pf_pull_hdr(m, off2, &iih, ICMP_MINLEN,
			    NULL, NULL, pd2.af)) {
d3704 1
a3704 1
				m_copyback(m, off, ICMP_MINLEN,
d3708 1
a3708 1
				m_copyback(m, off2, ICMP_MINLEN,
d3753 2
a3754 1
					m_copyback(m, off, ICMP_MINLEN,
@


1.342
log
@Support return-icmp for 'other' protocols (non-TCP/UDP/ICMP), for instance
stock OpenBSD stack returns 'protocol unreachable'.
ok frantzen@@, henning@@, pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.341 2003/05/10 22:33:33 dhartmei Exp $ */
d999 1
a999 1
	/* Change outer ip address, fix outer ipv4 or icmpv6 checksum. */
d3712 49
a3760 4
		default:
			DPFPRINTF(PF_DEBUG_MISC,
			    ("pf: ICMP error message for bad proto\n"));
			return (PF_DROP);
a3761 1

@


1.341
log
@Prepare pf_change_icmp() for parameter ip == NULL use.
ok frantzen@@, henning@@, pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.340 2003/05/06 21:21:23 dhartmei Exp $ */
d2702 32
@


1.340
log
@Fix a bug that prevents rdr/binat (but not nat) from working for protocols
other than TCP, UDP and ICMP (for instance GRE).
Reported by Gunnar Helliesen. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.339 2003/04/30 12:30:27 cedric Exp $ */
a947 2
	u_int32_t	opc;
	u_int16_t	oip = *ip;
a951 2
	if (pc != NULL)
		opc = *pc;
d953 14
a966 6
	*ip = np;
	if (pc != NULL)
		*pc = pf_cksum_fixup(*pc, oip, *ip, u);
	*ic = pf_cksum_fixup(*ic, oip, *ip, 0);
	if (pc != NULL)
		*ic = pf_cksum_fixup(*ic, opc, *pc, 0);
a967 1
	/* Change inner ip address, fix inner ipv4 and icmp checksums. */
@


1.339
log
@Allow tables to be loaded into anchors.
Most pfctl table commands (excluding 'show' and 'flush') support the "-a"
modifier.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.338 2003/04/25 17:41:25 dhartmei Exp $ */
d2633 1
@


1.338
log
@Fix nat proxy port allocation. In case a range was manually specified,
ports outside that range could be used with a probability inversely
proportional to the size of the specified range (occured often with
very small, rarely with larger ranges).
Reported by Gopakumar Pillai, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.337 2003/04/11 14:40:57 henning Exp $ */
a119 2
int			 pf_tbladdr_setup(struct pf_addr_wrap *);
void			 pf_tbladdr_remove(struct pf_addr_wrap *);
d493 1
a493 1
pf_tbladdr_setup(struct pf_addr_wrap *aw)
d497 1
a497 1
	if ((aw->p.tbl = pfr_attach_table(aw->v.tblname)) == NULL)
@


1.337
log
@set/update the queue IDs on filter rules (qid and pqid) on
-DIOCCHANGERULE (just the affected rule)
-DIOCCOMMITRULES (all filter rules that get committed - one anchor or main rs)
-DIOCCOMMITALTQS (all filter rules, main set plus all anchors)

This fixes a whole bunch of issues.
previously, this was done in userland at load time. This worked fine for the
usual case, full ruleset load. It did not work inside anchors, as the queue
name <-> queue ID mapping is unknown there. Also, if the queue definitions
were changed without reloading the rules too (pfctl -A), the queue IDs on
the rules were not updated.
The three ioctls mentioned above are all entry points where the mapping is
touched.

helpful discussion with dhartmei@@ and cedric@@ helped verifying my approach
for this fix was right.

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.336 2003/04/09 18:21:58 henning Exp $ */
a1552 1
	int			step;
d1591 6
a1596 6
			if (low < high) {
				step = 1;
				cut = arc4random() % (1 + high - low) + low;
			} else {
				step = -1;
				cut = arc4random() % (1 + low - high) + high;
d1598 4
a1601 4

			*nport = cut - step;
			do {
				*nport += step;
d1605 2
a1606 6
			} while (*nport != low && *nport != high);

			step = -step;
			*nport = cut;
			do {
				*nport += step;
d1610 1
a1610 1
			} while (*nport != low && *nport != high);
@


1.336
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.335 2003/04/09 15:32:59 cedric Exp $ */
d183 2
d808 27
@


1.335
log
@Change pf_state structure to point to both a rule and the anchor,
so states created by rules in anchors correctly use rule options like
routing and (soon) queues...
Rule number bumped to 32 bit value.
USERLAND NEED TO BE RECOMPILED.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.334 2003/04/05 20:24:58 cedric Exp $ */
d4345 1
a4345 1
			}	
@


1.334
log
@Stick pf_default_rule everytime a packet pass because of the
implicit "pass all" first rule match and remove all "r == NULL"
tests which are now useless.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.330 2003/04/03 13:17:24 cedric Exp $ */
d156 1
a156 1
			    struct pf_pdesc *);
d159 1
a159 1
			    struct pf_pdesc *);
d162 1
a162 1
			    void *, struct pf_pdesc *);
d165 1
a165 1
			    struct pf_pdesc *);
d168 1
a168 1
			    struct pf_pdesc *);
d475 8
a482 3
			if (cur->state->nat_rule != NULL)
				if (--cur->state->nat_rule->states <= 0)
					pf_rm_rule(NULL, cur->state->nat_rule);
d1876 1
a1876 1
    struct pf_pdesc *pd)
d1887 1
a1887 1
	struct pf_rule		*r, *rs = &pf_default_rule, *anchorrule = NULL;
d1961 1
a1961 1
				rs = (anchorrule == NULL ? r : anchorrule);
d1966 1
a1966 1
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
d1969 2
a1970 2
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
d1974 1
d1978 3
a1980 3
	if (rs != r) {
		rs->packets++;
		rs->bytes += pd->tot_len;
d1987 1
a1987 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d2032 4
a2035 4
		if (rs != NULL)
			rs->states++;

		s->rule.ptr = rs;
d2037 1
a2037 1
			s->nat_rule = nat;
d2039 4
a2042 3
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
d2122 1
a2122 1
    struct pf_pdesc *pd)
d2133 1
a2133 1
	struct pf_rule		*r, *rs = &pf_default_rule, *anchorrule = NULL;
d2205 1
a2205 1
				rs = (anchorrule == NULL ? r : anchorrule);
d2210 1
a2210 1
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
d2213 2
a2214 2
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
d2218 1
d2222 3
a2224 3
	if (rs != r) {
		rs->packets++;
		rs->bytes += pd->tot_len;
d2231 1
a2231 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d2267 3
a2269 2
		if (rs != NULL)
			rs->states++;
d2271 1
a2271 1
		s->rule.ptr = rs;
d2273 1
a2273 1
			s->nat_rule = nat;
d2275 4
a2278 3
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
d2341 1
a2341 1
    struct pf_pdesc *pd)
d2346 1
a2346 1
	struct pf_rule		*r, *rs = &pf_default_rule, *anchorrule = NULL;
d2460 1
a2460 1
				rs = (anchorrule == NULL ? r : anchorrule);
d2465 1
a2465 1
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
d2468 2
a2469 2
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
d2473 1
d2477 3
a2479 3
	if (rs != r) {
		rs->packets++;
		rs->bytes += pd->tot_len;
d2489 1
a2489 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d2505 3
a2507 2
		if (rs != NULL)
			rs->states++;
d2509 1
a2509 1
		s->rule.ptr = rs;
d2511 1
a2511 1
			s->nat_rule = nat;
d2513 4
a2516 3
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
d2577 2
a2578 1
    struct ifnet *ifp, struct mbuf *m, void *h, struct pf_pdesc *pd)
d2581 1
a2581 1
	struct pf_rule		*r, *rs = &pf_default_rule, *anchorrule = NULL;
d2652 1
a2652 1
				rs = (anchorrule == NULL ? r : anchorrule);
d2657 1
a2657 1
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
d2660 2
a2661 2
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
d2665 1
d2669 3
a2671 3
	if (rs != r) {
		rs->packets++;
		rs->bytes += pd->tot_len;
d2675 1
a2675 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d2689 3
a2691 2
		if (rs != NULL)
			rs->states++;
d2693 1
a2693 1
		s->rule.ptr = rs;
d2695 1
a2695 1
			s->nat_rule = nat;
d2697 4
a2700 3
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
d2745 1
a2745 1
				    rs);
d2757 1
a2757 1
    struct mbuf *m, void *h, struct pf_pdesc *pd)
d2759 1
a2759 1
	struct pf_rule		*r, *rs = &pf_default_rule, *anchorrule = NULL;
d2790 1
a2790 1
				rs = (anchorrule == NULL ? r : anchorrule);
d2795 1
a2795 1
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
d2798 2
a2799 2
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
d2803 1
d2807 3
a2809 3
	if (rs != r) {
		rs->packets++;
		rs->bytes += pd->tot_len;
d2813 1
a2813 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d3114 7
a3120 3
	if ((*state)->nat_rule != NULL) {
		(*state)->nat_rule->packets++;
		(*state)->nat_rule->bytes += pd->tot_len;
d3182 7
a3188 3
	if ((*state)->nat_rule != NULL) {
		(*state)->nat_rule->packets++;
		(*state)->nat_rule->bytes += pd->tot_len;
d3740 7
a3746 3
	if ((*state)->nat_rule != NULL) {
		(*state)->nat_rule->packets++;
		(*state)->nat_rule->bytes += pd->tot_len;
d4213 1
a4213 1
	struct pf_rule	*r = &pf_default_rule;
d4261 1
a4261 1
		action = pf_test_fragment(&r, dir, ifp, m, h, &pd);
d4293 1
a4293 1
			    m, 0, off, h, &pd);
d4314 1
d4318 1
a4318 1
			    m, 0, off, h, &pd);
d4341 5
d4349 1
a4349 1
			    m, 0, off, h, &pd);
d4357 1
d4360 1
a4360 1
			action = pf_test_other(&r, &s, dir, ifp, m, h, &pd);
d4411 1
a4411 1
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r);
d4428 1
a4428 1
	struct pf_rule	*r = &pf_default_rule;
d4464 1
a4464 1
			action = pf_test_fragment(&r, dir, ifp, m, h, &pd);
d4524 1
a4524 1
			    m, 0, off, h, &pd);
d4548 1
a4548 1
			    m, 0, off, h, &pd);
d4575 1
a4575 1
			    m, 0, off, h, &pd);
d4580 1
a4580 1
		action = pf_test_other(&r, &s, dir, ifp, m, h, &pd);
d4624 1
a4624 1
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r);
@


1.333
log
@Replace the timeout variables by the content of the timeout
field of a new pf_default_rule structure.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.332 2003/04/05 20:18:23 cedric Exp $ */
a222 1
		    (*state)->rule.ptr != NULL &&			\
d241 1
a241 1
	(((r) && (r)->timeout[(i)]) ? (r)->timeout[(i)] : pf_default_rule.timeout[(i)])
d473 2
a474 3
			if (cur->state->rule.ptr != NULL)
				if (--cur->state->rule.ptr->states <= 0)
					pf_rm_rule(NULL, cur->state->rule.ptr);
d1085 1
a1085 1
	if (r != NULL && r->qid) {
d1153 1
a1153 1
	if (r != NULL && r->qid) {
d1882 1
a1882 1
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
a1886 2
	*rm = NULL;

d1970 27
a1996 39
	if (r != NULL) {
		r->packets++;
		r->bytes += pd->tot_len;
		if (rs != r) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);

		if (r->log) {
			if (rewrite)
				m_copyback(m, off, sizeof(*th), (caddr_t)th);
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
		}

		if ((r->action == PF_DROP) &&
		    ((r->rule_flag & PFRULE_RETURNRST) ||
		    (r->rule_flag & PFRULE_RETURNICMP) ||
		    (r->rule_flag & PFRULE_RETURN))) {
			/* undo NAT/RST changes, if they have taken place */
			if (nat != NULL) {
				pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
				    &th->th_sum, &baddr, bport, 0, af);
				rewrite++;
			} else if (rdr != NULL) {
				pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
				    &th->th_sum, &baddr, bport, 0, af);
				rewrite++;
			}
			if ((r->rule_flag & PFRULE_RETURNRST) ||
			    (r->rule_flag & PFRULE_RETURN))
				pf_send_reset(off, th, pd, af,
				    r->return_ttl, r);
			else if ((af == AF_INET) && r->return_icmp)
				pf_send_icmp(m, r->return_icmp >> 8,
				    r->return_icmp & 255, af, r);
			else if ((af == AF_INET6) && r->return_icmp6)
				pf_send_icmp(m, r->return_icmp6 >> 8,
				    r->return_icmp6 & 255, af, r);
d1998 11
d2010 2
a2011 3
		if (r->action == PF_DROP)
			return (PF_DROP);
	}
d2013 1
a2013 2
	if ((r != NULL && r->keep_state) ||
	    nat != NULL || rdr != NULL) {
d2019 1
a2019 2
		if (r == NULL || !r->max_states ||
		    r->states < r->max_states)
d2036 2
a2037 2
		s->allow_opts = r && r->allow_opts;
		s->log = r && (r->log & 2);
d2071 1
a2071 1
		    r != NULL && r->keep_state == PF_STATE_MODULATE) {
d2126 1
a2126 1
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
a2130 2
	*rm = NULL;

d2212 26
a2237 34
	if (r != NULL) {
		r->packets++;
		r->bytes += pd->tot_len;
		if (rs != r) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);

		if (r->log) {
			if (rewrite)
				m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
		}

		if ((r->action == PF_DROP) &&
		    ((r->rule_flag & PFRULE_RETURNICMP) ||
		    (r->rule_flag & PFRULE_RETURN))) {
			/* undo NAT/RST changes, if they have taken place */
			if (nat != NULL) {
				pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
				    &uh->uh_sum, &baddr, bport, 1, af);
				rewrite++;
			} else if (rdr != NULL) {
				pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
				    &uh->uh_sum, &baddr, bport, 1, af);
				rewrite++;
			}
			if ((af == AF_INET) && r->return_icmp)
				pf_send_icmp(m, r->return_icmp >> 8,
				    r->return_icmp & 255, af, r);
			else if ((af == AF_INET6) && r->return_icmp6)
				pf_send_icmp(m, r->return_icmp6 >> 8,
				    r->return_icmp6 & 255, af, r);
d2239 7
d2247 2
a2248 3
		if (r->action == PF_DROP)
			return (PF_DROP);
	}
d2250 1
a2250 2
	if ((r != NULL && r->keep_state) ||
	    nat != NULL || rdr != NULL) {
d2254 1
a2254 2
		if (r == NULL || !r->max_states ||
		    r->states < r->max_states)
d2269 2
a2270 2
		s->allow_opts = r && r->allow_opts;
		s->log = r && (r->log & 2);
d2336 1
a2336 1
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
a2346 2
	*rm = NULL;

d2464 7
a2470 8
	if (r != NULL) {
		r->packets++;
		r->bytes += pd->tot_len;
		if (rs != r) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);
d2472 1
a2472 1
		if (r->log) {
d2474 3
a2476 3
			if (rewrite)
				m_copyback(m, off, ICMP_MINLEN,
				    (caddr_t)pd->hdr.icmp6);
d2478 2
a2479 2
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
		}
d2481 2
a2482 3
		if (r->action != PF_PASS)
			return (PF_DROP);
	}
d2484 1
a2484 1
	if (!state_icmp && ((r != NULL && r->keep_state) ||
d2489 1
a2489 2
		if (r == NULL || !r->max_states ||
		    r->states < r->max_states)
d2504 2
a2505 2
		s->allow_opts = r && r->allow_opts;
		s->log = r && (r->log & 2);
d2567 1
a2567 1
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
a2573 2
	*rm = NULL;

d2652 9
a2660 10
	if (r != NULL) {
		r->packets++;
		r->bytes += pd->tot_len;
		if (rs != r) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);
		if (r->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d2662 2
a2663 3
		if (r->action != PF_PASS)
			return (PF_DROP);
	}
d2665 1
a2665 2
	if ((r != NULL && r->keep_state) || nat != NULL ||
	    rdr != NULL) {
d2669 1
a2669 2
		if (r == NULL || !r->max_states ||
		    r->states < r->max_states)
d2684 2
a2685 2
		s->allow_opts = r && r->allow_opts;
		s->log = r && (r->log & 2);
d2726 1
a2726 1
			if (r && r->log)
d2742 1
a2742 1
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
d2745 1
a2745 2

	*rm = NULL;
d2787 9
a2795 2
	if (r != NULL) {
		u_short	reason;
d2797 2
a2798 13
		r->packets++;
		r->bytes += pd->tot_len;
		if (rs != r) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);
		if (r->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);

		if (r->action != PF_PASS)
			return (PF_DROP);
	}
d3094 2
a3095 4
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
d3158 2
a3159 4
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
d3712 2
a3713 4
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
d4183 1
a4183 1
	struct pf_rule	*r = NULL;
d4308 2
a4309 4
			if (r != NULL) {
				r->packets++;
				r->bytes += h->ip_len;
			}
d4333 1
a4333 1
	if (r != NULL && r->src.addr.type == PF_ADDR_TABLE)
d4338 1
a4338 1
	if (r != NULL && r->dst.addr.type == PF_ADDR_TABLE)
d4345 1
a4345 1
	    !((s && s->allow_opts) || (r && r->allow_opts))) {
d4354 1
a4354 1
	if (action != PF_DROP && r != NULL && r->qid) {
d4373 2
a4374 11
	if (log) {
		if (r == NULL) {
			struct pf_rule	r0;

			r0.ifp = ifp;
			r0.action = action;
			r0.nr = -1;
			PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, &r0);
		} else
			PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r);
	}
d4377 1
a4377 1
	if (r != NULL && r->rt)
d4391 1
a4391 1
	struct pf_rule	*r = NULL;
d4533 2
a4534 4
			if (r != NULL) {
				r->packets++;
				r->bytes += h->ip6_plen;
			}
d4553 1
a4553 1
	if (r != NULL && r->src.addr.type == PF_ADDR_TABLE)
d4558 1
a4558 1
	if (r != NULL && r->dst.addr.type == PF_ADDR_TABLE)
d4567 1
a4567 1
	if (action != PF_DROP && r != NULL && r->qid) {
d4586 2
a4587 11
	if (log) {
		if (r == NULL) {
			struct pf_rule	r0;

			r0.ifp = ifp;
			r0.action = action;
			r0.nr = -1;
			PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, &r0);
		} else
			PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r);
	}
d4590 1
a4590 1
	if (r != NULL && r->rt)
@


1.332
log
@Cleanup by replacing a bunch of "(*rm)" by just "r"
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.331 2003/04/03 15:27:17 cedric Exp $ */
a107 22
/* Timeouts */
int			 pftm_tcp_first_packet = 120;	/* First TCP packet */
int			 pftm_tcp_opening = 30;		/* No response yet */
int			 pftm_tcp_established = 24*60*60;  /* established */
int			 pftm_tcp_closing = 15 * 60;	/* Half closed */
int			 pftm_tcp_fin_wait = 45;	/* Got both FINs */
int			 pftm_tcp_closed = 90;		/* Got a RST */

int			 pftm_udp_first_packet = 60;	/* First UDP packet */
int			 pftm_udp_single = 30;		/* Unidirectional */
int			 pftm_udp_multiple = 60;	/* Bidirectional */

int			 pftm_icmp_first_packet = 20;	/* First ICMP packet */
int			 pftm_icmp_error_reply = 10;	/* Got error response */

int			 pftm_other_first_packet = 60;	/* First packet */
int			 pftm_other_single = 30;	/* Unidirectional */
int			 pftm_other_multiple = 60;	/* Bidirectional */

int			 pftm_frag = 30;		/* Fragment expire */

int			 pftm_interval = 10;		/* expire interval */
a109 11
int			*pftm_timeouts[PFTM_MAX] = { &pftm_tcp_first_packet,
				&pftm_tcp_opening, &pftm_tcp_established,
				&pftm_tcp_closing, &pftm_tcp_fin_wait,
				&pftm_tcp_closed, &pftm_udp_first_packet,
				&pftm_udp_single, &pftm_udp_multiple,
				&pftm_icmp_first_packet, &pftm_icmp_error_reply,
				&pftm_other_first_packet, &pftm_other_single,
				&pftm_other_multiple, &pftm_frag,
				&pftm_interval };


d242 1
a242 1
	(((r) && (r)->timeout[(i)]) ? (r)->timeout[(i)] : *pftm_timeouts[(i)])
d440 1
a440 1
	timeout_add(to, pftm_interval * hz);
@


1.331
log
@Back out my last change, which was incorrect or incomplete.
States can still be created without a rule for people who have only
NAT rules, for example.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.329 2003/03/31 13:15:27 cedric Exp $ */
d2005 1
d2007 4
a2010 4
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
d2016 1
a2016 1
		if ((*rm)->log) {
d2022 4
a2025 4
		if (((*rm)->action == PF_DROP) &&
		    (((*rm)->rule_flag & PFRULE_RETURNRST) ||
		    ((*rm)->rule_flag & PFRULE_RETURNICMP) ||
		    ((*rm)->rule_flag & PFRULE_RETURN))) {
d2036 2
a2037 2
			if (((*rm)->rule_flag & PFRULE_RETURNRST) ||
			    ((*rm)->rule_flag & PFRULE_RETURN))
d2039 7
a2045 7
				    (*rm)->return_ttl, *rm);
			else if ((af == AF_INET) && (*rm)->return_icmp)
				pf_send_icmp(m, (*rm)->return_icmp >> 8,
				    (*rm)->return_icmp & 255, af, *rm);
			else if ((af == AF_INET6) && (*rm)->return_icmp6)
				pf_send_icmp(m, (*rm)->return_icmp6 >> 8,
				    (*rm)->return_icmp6 & 255, af, *rm);
d2048 1
a2048 1
		if ((*rm)->action == PF_DROP)
d2052 1
a2052 1
	if (((*rm != NULL) && (*rm)->keep_state) ||
d2059 2
a2060 2
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
d2077 2
a2078 2
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
d2112 1
a2112 1
		    *rm != NULL && (*rm)->keep_state == PF_STATE_MODULATE) {
d2135 1
a2135 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_TCP_FIRST_PACKET);
d2253 1
d2255 4
a2258 4
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
d2264 1
a2264 1
		if ((*rm)->log) {
d2270 3
a2272 3
		if (((*rm)->action == PF_DROP) &&
		    (((*rm)->rule_flag & PFRULE_RETURNICMP) ||
		    ((*rm)->rule_flag & PFRULE_RETURN))) {
d2283 6
a2288 6
			if ((af == AF_INET) && (*rm)->return_icmp)
				pf_send_icmp(m, (*rm)->return_icmp >> 8,
				    (*rm)->return_icmp & 255, af, *rm);
			else if ((af == AF_INET6) && (*rm)->return_icmp6)
				pf_send_icmp(m, (*rm)->return_icmp6 >> 8,
				    (*rm)->return_icmp6 & 255, af, *rm);
d2291 1
a2291 1
		if ((*rm)->action == PF_DROP)
d2295 1
a2295 1
	if ((*rm != NULL && (*rm)->keep_state) ||
d2300 2
a2301 2
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
d2316 2
a2317 2
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
d2357 1
a2357 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_UDP_FIRST_PACKET);
d2511 1
d2513 4
a2516 4
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
d2522 1
a2522 1
		if ((*rm)->log) {
d2531 1
a2531 1
		if ((*rm)->action != PF_PASS)
d2535 1
a2535 1
	if (!state_icmp && ((*rm != NULL && (*rm)->keep_state) ||
d2540 2
a2541 2
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
d2556 2
a2557 2
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
d2593 1
a2593 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_ICMP_FIRST_PACKET);
d2704 1
d2706 4
a2709 4
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
d2714 1
a2714 1
		if ((*rm)->log)
d2717 1
a2717 1
		if ((*rm)->action != PF_PASS)
d2721 1
a2721 1
	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL ||
d2726 2
a2727 2
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
d2742 2
a2743 2
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
d2779 1
a2779 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_OTHER_FIRST_PACKET);
d2784 1
a2784 1
			if (*rm && (*rm)->log)
d2844 1
d2846 1
a2846 1
	if (*rm != NULL) {
d2849 3
a2851 3
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
d2856 1
a2856 1
		if ((*rm)->log)
d2859 1
a2859 1
		if ((*rm)->action != PF_PASS)
@


1.330
log
@Remove (state->rule.ptr != NULL) tests: this is always true now.
ok dhartmei@@
@
text
@d256 1
d507 3
a509 2
			if (--cur->state->rule.ptr->states <= 0)
				pf_rm_rule(NULL, cur->state->rule.ptr);
d3152 4
a3155 2
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
d3218 4
a3221 2
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
d3774 4
a3777 2
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
@


1.329
log
@Only delete rule structure when no state refer to it.
Fix a bunch of issues.
Removal of unneeded (r != null) tests coming soon...
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.328 2003/03/21 12:47:36 cedric Exp $ */
a255 1
		    (*state)->rule.ptr != NULL &&			\
d506 2
a507 3
			if (cur->state->rule.ptr != NULL)
				if (--cur->state->rule.ptr->states <= 0)
					pf_rm_rule(NULL, cur->state->rule.ptr);
d3150 2
a3151 4
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
d3214 2
a3215 4
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
d3768 2
a3769 4
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
@


1.328
log
@- Add missing "\n" to some pf_table.c printf()
- Fix two problems with pfr_update_stats().

Filtering was done properly, only stats were wrong.
People should upgrade their kernel if:
  - They use bidirectional rules (without "in" or "out") with tables.
  - They use tables in negated statements, like "block from !<foo>"

Thanks to David Krause for discovering the problem.
Ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.327 2003/03/09 20:26:12 frantzen Exp $ */
d508 2
a509 1
				cur->state->rule.ptr->states--;
d511 2
a512 1
				cur->state->nat_rule->states--;
@


1.328.2.1
log
@Pull patch from -current:
Fix by dhartmei@@

Fix a bug that prevents rdr/binat (but not nat) from working for protocols
other than TCP, UDP and ICMP (for instance GRE).
Reported by Gunnar Helliesen.

Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.340 2003/05/06 21:21:23 dhartmei Exp $ */
a2645 1
			PF_ACPY(&baddr, daddr, af);
@


1.328.2.2
log
@Fix by dhartmei@@

apply correct window scaling to ackskew

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.328.2.1 2003/05/31 00:57:50 margarida Exp $ */
d2984 1
a2984 1
	    (ackskew <= (MAXACKWINDOW << sws))) {
d3126 1
a3126 1
			    (ackskew <= (MAXACKWINDOW << sws)) ? ' ' : '4',
@


1.328.2.3
log
@MFC:
Fix by dhartmei@@

Fix nat proxy port allocation. In case a range was manually specified,
ports outside that range could be used with a probability inversely
proportional to the size of the specified range (occured often with
very small, rarely with larger ranges).
Reported by Gopakumar Pillai, ok henning@@

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.328.2.2 2003/06/15 20:35:45 brad Exp $ */
d1552 1
d1591 7
a1597 2
			if (low > high) {
				u_int16_t tmp;
d1599 3
a1601 8
				tmp = low;
				low = high;
				high = tmp;
			}
			/* low < high */
			cut = arc4random() % (1 + high - low) + low;
			/* low <= cut <= high */
			for (*nport = cut; *nport <= high; ++(*nport)) {
d1605 6
a1610 2
			}
			for (*nport = cut - 1; *nport >= low; --(*nport)) {
d1614 1
a1614 1
			}
@


1.328.2.4
log
@MFC:
Fix by mcbride@@

With rdr we want the source IP from the packet, not the source IP from
the rule. Fixes rdr with address pools using bitmask and source-hash
address selection methods.

ok dhartmei@@ henning@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.328.2.3 2003/07/10 22:34:28 brad Exp $ */
d1759 2
a1760 1
			if (pf_map_addr(r->af, &r->rpool, saddr, naddr, NULL))
@


1.328.2.5
log
@MFC:
Fix by dhartmei@@

fix binat for incoming connections when a netblock (not just a single
address) is used for source in the binat rule. closes PR 3535, reported
by Karl O.Pinc. ok henning@@, cedric@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.328.2.4 2003/08/09 18:23:10 brad Exp $ */
d1754 1
a1754 1
					    &r->src.addr.v.a.mask, daddr, af);
@


1.328.2.6
log
@MFC:
Fix by itojun@@

plug mbuf leak (ip_fragment() always free mbuf on error).

missing pieces from my previous commit.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.328.2.5 2003/10/31 06:36:16 brad Exp $ */
d3992 1
a3992 2
	if (error) {
		m0 = NULL;
a3993 1
	}
@


1.327
log
@tighten the TCP state code in relation to a FIN before any server responses
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.326 2003/03/04 11:23:43 pb Exp $ */
d4399 1
a4399 1
		    (r->direction == dir) ? pd.src : pd.dst, pd.af,
d4404 1
a4404 1
		    (r->direction == dir) ? pd.dst : pd.src, pd.af,
d4630 1
a4630 1
		    (r->direction == dir) ? pd.src : pd.dst, pd.af,
d4635 1
a4635 1
		    (r->direction == dir) ? pd.dst : pd.src, pd.af,
@


1.326
log
@(really) support user/group rules with 'inet6'

pointed out by hugh

ok dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.325 2003/03/02 12:00:39 dhartmei Exp $ */
d3025 4
a3032 4
		else if (src->state < TCPS_ESTABLISHED ||
		    dst->state < TCPS_ESTABLISHED)
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_OPENING);
@


1.325
log
@Use priority queue for TCP ACKs that have no payload. Very useful on
asymmetric links. ok henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.324 2003/02/27 13:35:57 henning Exp $ */
a1804 2
	if (af != AF_INET)
		return (0);
d1831 25
a1855 6
	inp = in_pcbhashlookup(tb, saddr->v4, sport, daddr->v4, dport);
	if (inp == NULL) {
		inp = in_pcblookup(tb, &saddr->v4, sport, &daddr->v4, dport,
		    INPLOOKUP_WILDCARD);
		if (inp == NULL)
			return (0);
@


1.324
log
@make packet classification for altq work in the IPv6 case

ok dhartmei@@ cedric@@ + "looks good" mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.323 2003/02/27 12:56:04 cedric Exp $ */
d4232 1
d4297 2
d4408 1
a4408 1
			if (pd.tos == IPTOS_LOWDELAY)
@


1.323
log
@Repair IPv6 support for tables.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.322 2003/02/25 17:54:06 mcbride Exp $ */
d4620 20
@


1.322
log
@- Handle src and dst comparisons correctly for binat so that it works
  properly in _both_ directions.
- Handle skip steps properly with binat. (since we're swapping around
  src and dst comparisons, we can't use them in all cases)

fix from dhartmei@@

ok dhartmei@@ henning@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.321 2003/02/16 21:30:13 deraadt Exp $ */
d4608 11
@


1.321
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.320 2003/02/12 14:41:07 jason Exp $ */
d1645 1
a1645 1
		struct pf_rule_addr	*src = NULL;
d1648 1
d1650 2
a1651 2
				src = &r->rpool.cur->addr;
		} else
d1653 2
d1666 16
a1681 12
		else if (src != NULL &&
		    PF_MISMATCHAW(&src->addr, saddr, af, src->not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (src != NULL && src->port_op &&
		    !pf_match_port(src->port_op, src->port[0],
		    src->port[1], sport))
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
		    r->dst.port[0], r->dst.port[1], dport))
			r = r->skip[PF_SKIP_DST_PORT].ptr;
@


1.320
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.319 2003/02/12 12:50:29 mcbride Exp $ */
d355 1
a355 1
	switch(af) {
d646 1
a646 1
	switch(af) {
d1411 1
a1411 1
	} while(0)
d1722 1
a1722 1
		            dport, naddr, nport, r->rpool.proxy_port[0],
@


1.319
log
@Make r.rpool.proxy_port[] a consistent byte order to match cleanup in
pfctl.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.318 2003/02/12 03:02:23 mcbride Exp $ */
a144 1
struct pool		 pfr_ktable_pl, pfr_kentry_pl;
@


1.318
log
@Fix a bunch of pf_route() bugs:

- pass back a pointer to state created in pf_test_{tcp|udp|icmp|other}()
  so that pf_route()/pf_route6() can peek at it.
- put the PACKET_TAG_PF_ROUTED tag onto the packets _before_ we call
  pf_test()/pf_test6() again to prevent looping.
- Call pf_test6() in pf_route6() instead of pf_test() for obvious reasons.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.317 2003/02/09 16:21:00 dhartmei Exp $ */
d1767 3
a1769 3
				    (ntohs(r->rpool.proxy_port[1]) -
				    ntohs(r->rpool.proxy_port[0]) + 1)) +
				    ntohs(r->rpool.proxy_port[0]);
d1776 1
a1776 1
				*nport = r->rpool.proxy_port[0];
@


1.317
log
@Slightly less noisy debug printf from pf_map_addr(), ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.316 2003/02/05 13:07:20 mcbride Exp $ */
d188 12
a199 8
int			 pf_test_tcp(struct pf_rule **, int, struct ifnet *,
			    struct mbuf *, int, int, void *, struct pf_pdesc *);
int			 pf_test_udp(struct pf_rule **, int, struct ifnet *,
			    struct mbuf *, int, int, void *, struct pf_pdesc *);
int			 pf_test_icmp(struct pf_rule **, int, struct ifnet *,
			    struct mbuf *, int, int, void *, struct pf_pdesc *);
int			 pf_test_other(struct pf_rule **, int, struct ifnet *,
			    struct mbuf *, void *, struct pf_pdesc *);
d1879 3
a1881 2
pf_test_tcp(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d2116 2
a2117 1
		}
d2128 3
a2130 2
pf_test_udp(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d2337 2
a2338 1
		}
d2349 3
a2351 2
pf_test_icmp(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d2572 2
a2573 1
		}
d2587 2
a2588 2
pf_test_other(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, void *h, struct pf_pdesc *pd)
d2760 2
a2761 1
		}
d3852 8
d3922 4
a3929 4
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
d4023 8
a4088 4
			if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
				goto bad;
			else if (m0 == NULL)
				goto done;
d4093 4
d4298 2
a4299 1
			action = pf_test_tcp(&r, dir, ifp, m, 0, off, h, &pd);
d4322 2
a4323 1
			action = pf_test_udp(&r, dir, ifp, m, 0, off, h, &pd);
d4350 2
a4351 1
			action = pf_test_icmp(&r, dir, ifp, m, 0, off, h, &pd);
d4361 1
a4361 1
			action = pf_test_other(&r, dir, ifp, m, h, &pd);
d4533 2
a4534 1
			action = pf_test_tcp(&r, dir, ifp, m, 0, off, h, &pd);
d4557 2
a4558 1
			action = pf_test_udp(&r, dir, ifp, m, 0, off, h, &pd);
d4576 2
a4577 1
		action = pf_test_state_icmp(&s, dir, ifp, m, 0, off, h, &pd);
d4586 2
a4587 1
			action = pf_test_icmp(&r, dir, ifp, m, 0, off, h, &pd);
d4592 1
a4592 1
		action = pf_test_other(&r, dir, ifp, m, h, &pd);
@


1.316
log
@Remove the confusing and more-or-less unnecessary temporary
struct pf_pooladdr *cur. It was being used incorrectly in the
round-robin case, which meant that the previous address was being selected,
rather than the reall current one.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.315 2003/02/01 15:20:16 dhartmei Exp $ */
d1532 2
a1533 1
	if (pf_status.debug >= PF_DEBUG_MISC) {
@


1.315
log
@Make it build without INET6 again.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.314 2003/01/31 19:36:39 dhartmei Exp $ */
a1458 1
	struct pf_pooladdr	*cur = rpool->cur;
d1462 2
a1463 2
	if (cur->addr.addr.type == PF_ADDR_NOROUTE ||
	    cur->addr.addr.type == PF_ADDR_TABLE)
d1465 2
a1466 2
	if (cur->addr.addr.type == PF_ADDR_DYNIFTL &&
	    cur->addr.addr.p.dyn->undefined)
d1516 2
a1517 2
		if (pf_match_addr(0, &cur->addr.addr.v.a.addr,
		    &cur->addr.addr.v.a.mask, &rpool->counter, af)) {
d1524 3
a1526 2
			PF_ACPY(naddr, &cur->addr.addr.v.a.addr, af);
			PF_ACPY(&rpool->counter, &cur->addr.addr.v.a.addr, af);
@


1.314
log
@The fix introduced with 1.294 to solve issues with route-to in
combination with translations was too broad and broke some
more complex setups (creating two states for one connection on
two interfaces, using modulate state for each, and additionally
using route-to/reply-to on one of them), so narrow it to the
cases where it's needed. Reported by henric@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.313 2003/01/31 19:22:11 dhartmei Exp $ */
d4121 1
d4123 1
d4153 1
d4159 1
d4175 1
d4179 1
@


1.313
log
@Check protocol (TCP/UDP/ICMP/ICMP6) checksums of all incoming packets,
and drop packets with invalid checksums. Without such a check, pf would
return RST/ICMP errors even for packets with invalid checksums, which
could be used to detect the presence of the firewall, reported by
"Ed White" in http://www.phrack.org/phrack/60/p60-0x0c.txt.

To minimize the cost of checksum calculations, mbuf flags set by
network interfaces capable of hardware checksumming are honoured,
and set when pf performs the calculation, so the TCP/IP stack itself
will not repeat the calculation for the same packet later on.

ok mcbride@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.312 2003/01/31 19:09:12 dhartmei Exp $ */
d252 2
a253 1
		if ((*state)->rule.ptr != NULL &&			\
d255 1
a255 1
		    (*state)->rule.ptr->direction == direction) ||	\
d257 1
a257 1
		    (*state)->rule.ptr->direction != direction)) &&	\
@


1.312
log
@Send a RST when an invalid packet matches a TCP state during the
handshake. Solves the issues with the "ACK+1000000 cookie scheme",
which depends on RFC 763 (p39, Reset Generation, 2. non-synchronized
state, "reset is sent"). ok henning@@, camield@@ and (I guess ;)
frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.311 2003/01/25 22:48:45 mcbride Exp $ */
d70 1
d238 2
d4097 83
d4249 5
d4276 5
d4299 5
d4481 5
d4508 5
d4529 5
@


1.311
log
@Fix the behaviour of rdr rules which redirect to a range of ports;
Stop overloading PF_OP_RRG as a flag where it doesn't make sense, and
makes the port mapping more flexble, allows mapping a destination port range
of one size to an other of a different size.

Fixes and additional testing courtesy of dhartmei@@

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.310 2003/01/24 15:55:36 dhartmei Exp $ */
d3064 9
a3072 1
		if (pf_status.debug >= PF_DEBUG_MISC) {
@


1.310
log
@Sigh, pf_pull_hdr (aka pf_pull_hair) doesn't do an m_pullup, it merely
copies the data to the specified buffer. So, for TCP options, provide
an sufficiently large buffer and copy to there.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.309 2003/01/24 15:05:31 dhartmei Exp $ */
d1753 1
a1753 1
			if (r->dst.port_op == PF_OP_RRG) {
d1755 7
a1761 2
				tmp_nport = ntohs(r->rpool.proxy_port[0]) +
				    (ntohs(dport) - ntohs(r->dst.port[0]));
@


1.309
log
@Move the mbuf pullup for TCP options to the beginning of TCP handling,
doing it later can invalidate pointers to mbuf data. This fixes subtle
breakage just introduced (with 1.306).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.308 2003/01/24 11:30:00 dhartmei Exp $ */
d235 1
a235 1
u_int8_t		 pf_get_wscale(struct mbuf *, int, struct tcphdr *,
d1826 1
a1826 1
pf_get_wscale(struct mbuf *m, int off, struct tcphdr *th, sa_family_t af)
d1829 1
d1833 2
a1834 2
	hlen = th->th_off << 2;
	if (hlen <= sizeof(*th))
d1836 4
a1839 2
	opt = (u_int8_t *)(th + 1);
	hlen -= sizeof(*th);
d2082 1
a2082 1
			s->src.wscale = pf_get_wscale(m, off, th, af);
d2875 1
a2875 1
			src->wscale = pf_get_wscale(m, off, th, pd->af);
a4142 1
		int		hlen;
d4150 1
a4150 7
		hlen = th.th_off << 2;
		if (hlen > sizeof(th) && !pf_pull_hdr(m, off, &th, hlen,
		    &action, &reason, AF_INET)) {
			log = action != PF_PASS;
			goto done;
		}
		pd.p_len = pd.tot_len - off - hlen;
a4359 1
		int		hlen;
d4367 1
a4367 7
		hlen = th.th_off << 2;
		if (hlen > sizeof(th) && !pf_pull_hdr(m, off, &th, hlen,
		    &action, &reason, AF_INET6)) {
			log = action != PF_PASS;
			goto done;
		}
		pd.p_len = pd.tot_len - off - hlen;
@


1.308
log
@Fix wscale support, the first version didn't really work right.
Interestingly, our own stack uses wscale 1 quite regularly, and I now
suspect that this is what caused most of the state failures I've seen.
They were quite rare, but with working wscale support, they are reduced
even more. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.307 2003/01/23 13:36:17 dhartmei Exp $ */
d1832 1
a1832 1
	hlen = th->th_off * 4;
a1834 2
	if (!pf_pull_hdr(m, off, th, hlen, NULL, NULL, af))
		return (0);
d4140 1
d4148 7
a4154 1
		pd.p_len = pd.tot_len - off - (th.th_off << 2);
d4364 1
d4372 7
a4378 1
		pd.p_len = pd.tot_len - off - (th.th_off << 2);
@


1.307
log
@Fix a bug where the kernel crashes when translating IPv6 ICMP packets.
This only happens when using nat/rdr/binat on IPv6 connections, which
hasn't been used before, obviously. But it does work now.
Reported and confirmed by evilted@@efnet, ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.306 2003/01/21 22:23:49 dhartmei Exp $ */
d2820 1
a2820 1
	u_int32_t		 win = ntohs(th->th_win);
d2822 1
d2843 6
d2889 2
a2890 2
		    SEQ_GEQ(end + MAX(1, dst->max_win), src->seqhi))
			src->seqhi = end + MAX(1, dst->max_win);
a2908 3
	if (src->wscale && dst->wscale && !(th->th_flags & TH_SYN))
		win <<= src->wscale & PF_WSCALE_MASK;

d2934 1
a2934 1
	    SEQ_GEQ(seq, src->seqlo - dst->max_win) &&
d2951 2
a2952 2
		if (SEQ_GEQ(ack + win, dst->seqhi))
			dst->seqhi = ack + MAX(win, 1);
d3041 2
a3042 2
		if (SEQ_GEQ(ack + win, dst->seqhi))
			dst->seqhi = ack + MAX(win, 1);
d3069 2
a3070 1
			    SEQ_GEQ(seq, src->seqlo - dst->max_win) ? ' ': '2',
d3387 1
d3418 5
d3430 1
a3430 1
			    !SEQ_GEQ(seq, src->seqlo - dst->max_win)) {
@


1.306
log
@Support for TCP window scaling (RFC 1323). ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.305 2003/01/19 13:52:18 henning Exp $ */
d942 1
a942 1
	u_int32_t	opc, oh2c = *h2c;
d961 3
a963 1
	case AF_INET:
d970 1
d972 1
a989 1
	*ic = pf_cksum_fixup(*ic, oh2c, *h2c, 0);
@


1.305
log
@format string fixes
inspired by Thorsten Glaser via fries@@

ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.304 2003/01/18 06:31:59 mcbride Exp $ */
d235 2
d725 1
a725 1
	printf(" [lo=%u high=%u win=%u modulator=%u]", s->src.seqlo,
d727 4
a730 1
	printf(" [lo=%u high=%u win=%u modulator=%u]", s->dst.seqlo,
d732 3
d1822 38
d2076 1
a2076 1
		if (th->th_flags & TH_SYN)
d2078 2
d2817 1
a2817 1
	u_int16_t		 win = ntohs(th->th_win);
d2862 1
a2862 1
		if (th->th_flags & TH_SYN)
d2864 2
d2898 3
@


1.304
log
@Argh! KNF.

pointed out in advance by dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.303 2003/01/18 05:07:45 mcbride Exp $ */
d723 1
a723 1
	printf(" [lo=%lu high=%lu win=%u modulator=%u]", s->src.seqlo,
d725 1
a725 1
	printf(" [lo=%lu high=%lu win=%u modulator=%u]", s->dst.seqlo,
d2967 1
a2967 1
			printf(" seq=%lu ack=%lu len=%u ackskew=%d pkts=%d\n",
d3002 1
a3002 1
			printf(" seq=%lu ack=%lu len=%u ackskew=%d pkts=%d "
d3367 1
a3367 1
					printf(" seq=%lu\n", seq);
@


1.303
log
@Make nat behave the way it used to by copying back the random source port
correctly. Also remove some extra cruft in pf_get_sport related to the
"static-port" behaviour.

bug report from mpech@@ and form@@
testing cedric@@
"looks sane to me" henning@@
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.302 2003/01/09 15:58:35 dhartmei Exp $ */
d1703 1
a1703 1
		            dport, naddr, nport,r->rpool.proxy_port[0],
@


1.302
log
@(whitespace) KNF, re-fold -w 80
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.301 2003/01/09 10:40:44 cedric Exp $ */
d224 3
a226 4
int			 pf_get_sport(sa_family_t, u_int8_t,
			    struct pf_pool *, struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t, struct pf_addr *,
			    u_int16_t*, u_int16_t, u_int16_t);
d1528 2
a1529 3
    struct pf_addr *saddr, u_int16_t sport, struct pf_addr *daddr,
    u_int16_t dport, struct pf_addr *naddr, u_int16_t *nport, u_int16_t low,
    u_int16_t high)
d1556 2
a1557 3
			key.port[1] = sport;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
				*nport = ntohs(sport);
a1558 1
			}
d1702 2
a1703 3
			if (pf_get_sport(af, proto,
			    &r->rpool, saddr, sport, daddr,
			    dport, naddr, nport, r->rpool.proxy_port[0],
d1842 1
a1842 1
			    &th->th_sum, &naddr, th->th_sport, 0, af);
d2087 1
a2087 1
			    &uh->uh_sum, &naddr, uh->uh_sport, 1, af);
@


1.301
log
@Add support for active/inactive tablesets in the kernel.
Add table definition/initialisation construct in pfctl parser.
Add and fix documentation for pf.4 and pf.conf.5.
Tested on i386 and sparc64 by myself, macppc by Daniel.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.300 2003/01/07 00:21:07 dhartmei Exp $ */
d786 1
a786 1
		    cur->src.not !=  prev->src.not ||
d789 4
a792 2
		    !PF_AEQ(&cur->src.addr.v.a.addr, &prev->src.addr.v.a.addr, 0) ||
		    !PF_AEQ(&cur->src.addr.v.a.mask, &prev->src.addr.v.a.mask, 0))
d802 1
a802 1
		    cur->dst.not !=  prev->dst.not ||
d805 4
a808 2
		    !PF_AEQ(&cur->dst.addr.v.a.addr, &prev->dst.addr.v.a.addr, 0) ||
		    !PF_AEQ(&cur->dst.addr.v.a.mask, &prev->dst.addr.v.a.mask, 0))
d903 1
a903 1
	   ao % 65536, an % 65536, u);
d1132 1
a1132 1
		  (void *)NULL);
d1384 10
a1393 10
	do {				    \
		a -= b; a -= c; a ^= (c >> 13); \
		b -= c; b -= a; b ^= (a << 8);  \
		c -= a; c -= b; c ^= (b >> 13); \
		a -= b; a -= c; a ^= (c >> 12); \
		b -= c; b -= a; b ^= (a << 16); \
		c -= a; c -= b; c ^= (b >> 5);  \
		a -= b; a -= c; a ^= (c >> 3);  \
		b -= c; b -= a; b ^= (a << 10); \
		c -= a; c -= b; c ^= (b >> 15); \
d1736 2
a1737 1
					PF_POOLMASK(naddr, &r->src.addr.v.a.addr,
d1749 2
a1750 2
				tmp_nport = ntohs(r->rpool.proxy_port[0])
				    + (ntohs(dport) - ntohs(r->dst.port[0]));
d3831 2
a3832 1
				panic("pf_route: m0->m_len < sizeof(struct ip)");
@


1.300
log
@Remove table name hashing (pass the name in each ioctl instead), and
introduce reference counting for tables, they are now automatically
created and deleted through referencing rules. Diff partly from cedric@@.
ok mcbride@@, henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.299 2003/01/06 10:08:36 deraadt Exp $ */
d529 9
@


1.299
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.298 2003/01/05 22:14:23 dhartmei Exp $ */
d153 2
d513 19
d775 2
d789 2
a1195 3
	if (m->addr32[0] == PF_TABLE_MASK)
		return (pfr_match_addr(a, m, b, af) != n);

d1436 3
d1635 2
a1636 3
		else if (src != NULL && !PF_AZERO(&src->addr.v.a.mask, af) &&
		    !PF_MATCHA(src->not,
		    &src->addr.v.a.addr, &src->addr.v.a.mask, saddr, af))
d1642 1
a1642 3
		else if (!PF_AZERO(&r->dst.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->dst.not,
		    &r->dst.addr.v.a.addr, &r->dst.addr.v.a.mask, daddr, af))
d1861 1
a1861 7
		else if (r->src.addr.type == PF_ADDR_NOROUTE &&
		    pf_routable(saddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (r->src.addr.type != PF_ADDR_NOROUTE &&
		    !PF_AZERO(&r->src.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->src.not, &r->src.addr.v.a.addr,
		    &r->src.addr.v.a.mask, saddr, af))
d1866 1
a1866 7
		else if (r->dst.addr.type == PF_ADDR_NOROUTE &&
		    pf_routable(daddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (r->dst.addr.type != PF_ADDR_NOROUTE &&
		    !PF_AZERO(&r->dst.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->dst.not, &r->dst.addr.v.a.addr,
		    &r->dst.addr.v.a.mask, daddr, af))
d2106 1
a2106 7
		else if (r->src.addr.type == PF_ADDR_NOROUTE &&
		    pf_routable(saddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (r->src.addr.type != PF_ADDR_NOROUTE &&
		    !PF_AZERO(&r->src.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->src.not, &r->src.addr.v.a.addr,
		    &r->src.addr.v.a.mask, saddr, af))
d2111 1
a2111 7
		else if (r->dst.addr.type == PF_ADDR_NOROUTE &&
		    pf_routable(daddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (r->dst.addr.type != PF_ADDR_NOROUTE &&
		    !PF_AZERO(&r->dst.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->dst.not, &r->dst.addr.v.a.addr,
		    &r->dst.addr.v.a.mask, daddr, af))
d2375 1
a2375 7
		else if (r->src.addr.type == PF_ADDR_NOROUTE &&
		    pf_routable(saddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (r->src.addr.type != PF_ADDR_NOROUTE &&
		    !PF_AZERO(&r->src.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->src.not, &r->src.addr.v.a.addr,
		    &r->src.addr.v.a.mask, saddr, af))
d2377 1
a2377 7
		else if (r->dst.addr.type == PF_ADDR_NOROUTE &&
		    pf_routable(daddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (r->dst.addr.type != PF_ADDR_NOROUTE &&
		    !PF_AZERO(&r->dst.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->dst.not, &r->dst.addr.v.a.addr,
		    &r->dst.addr.v.a.mask, daddr, af))
d2570 1
a2570 7
		else if (r->src.addr.type == PF_ADDR_NOROUTE &&
		    pf_routable(pd->src, af))
			r = TAILQ_NEXT(r, entries);
		else if (r->src.addr.type != PF_ADDR_NOROUTE &&
		    !PF_AZERO(&r->src.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->src.not, &r->src.addr.v.a.addr,
		    &r->src.addr.v.a.mask, pd->src, af))
d2572 1
a2572 7
		else if (r->dst.addr.type == PF_ADDR_NOROUTE &&
		    pf_routable(pd->dst, af))
			r = TAILQ_NEXT(r, entries);
		else if (r->src.addr.type != PF_ADDR_NOROUTE &&
		    !PF_AZERO(&r->dst.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->dst.not, &r->dst.addr.v.a.addr,
		    &r->dst.addr.v.a.mask, pd->dst, af))
d2707 1
a2707 7
		else if (r->src.addr.type == PF_ADDR_NOROUTE &&
		    pf_routable(pd->src, af))
			r = TAILQ_NEXT(r, entries);
		else if (r->src.addr.type != PF_ADDR_NOROUTE &&
		    !PF_AZERO(&r->src.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->src.not, &r->src.addr.v.a.addr,
		    &r->src.addr.v.a.mask, pd->src, af))
d2709 1
a2709 7
		else if (r->dst.addr.type == PF_ADDR_NOROUTE &&
		    pf_routable(pd->dst, af))
			r = TAILQ_NEXT(r, entries);
		else if (r->src.addr.type != PF_ADDR_NOROUTE &&
		    !PF_AZERO(&r->dst.addr.v.a.mask, af) &&
		    !PF_MATCHA(r->dst.not, &r->dst.addr.v.a.addr,
		    &r->dst.addr.v.a.mask, pd->dst, af))
d4141 10
a4150 10
	if (r != NULL &&  r->src.addr.v.a.mask.addr32[0] == PF_TABLE_MASK)
		pfr_update_stats(&r->src.addr.v.a.addr, &r->src.addr.v.a.mask,
		    (r->direction == dir) ? pd.src : pd.dst,
		    pd.af, pd.tot_len, dir == PF_OUT,
		    r->action == PF_PASS, r->src.not);
	if (r != NULL && r->dst.addr.v.a.mask.addr32[0] == PF_TABLE_MASK)
		pfr_update_stats(&r->dst.addr.v.a.addr, &r->dst.addr.v.a.mask,
		    (r->direction == dir) ? pd.dst : pd.src,
		    pd.af, pd.tot_len, dir == PF_OUT,
		    r->action == PF_PASS, r->dst.not);
@


1.298
log
@Move ifname from pf_addr to pf_addr_wrap, prepare pf_addr_wrap for table
name. ok henning@@, mcbride@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.297 2003/01/04 17:40:51 dhartmei Exp $ */
d755 1
a755 1
		    (cur->src.addr.type == PF_ADDR_NOROUTE) != 
@


1.297
log
@move noroute from flag in pf_rule_addr into type in pf_addr_wrap.
ok henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.296 2003/01/04 16:35:00 dhartmei Exp $ */
d513 1
a513 1
	if (aw->addr_dyn == NULL)
d515 2
a516 2
	aw->addr_dyn = pool_get(&pf_addr_pl, PR_NOWAIT);
	if (aw->addr_dyn == NULL)
d518 5
a522 6
	bcopy(aw->addr.pfa.ifname, aw->addr_dyn->ifname,
	    sizeof(aw->addr_dyn->ifname));
	aw->addr_dyn->ifp = ifunit(aw->addr_dyn->ifname);
	if (aw->addr_dyn->ifp == NULL) {
		pool_put(&pf_addr_pl, aw->addr_dyn);
		aw->addr_dyn = NULL;
d525 9
a533 9
	aw->addr_dyn->addr = &aw->addr;
	aw->addr_dyn->af = af;
	aw->addr_dyn->undefined = 1;
	aw->addr_dyn->hook_cookie = hook_establish(
	    aw->addr_dyn->ifp->if_addrhooks, 1,
	    pf_dynaddr_update, aw->addr_dyn);
	if (aw->addr_dyn->hook_cookie == NULL) {
		pool_put(&pf_addr_pl, aw->addr_dyn);
		aw->addr_dyn = NULL;
d536 1
a536 1
	pf_dynaddr_update(aw->addr_dyn);
d588 1
a588 1
	if (aw->addr_dyn == NULL)
d590 4
a593 4
	hook_disestablish(aw->addr_dyn->ifp->if_addrhooks,
	    aw->addr_dyn->hook_cookie);
	pool_put(&pf_addr_pl, aw->addr_dyn);
	aw->addr_dyn = NULL;
d599 1
a599 1
	if (aw->addr_dyn == NULL)
d601 2
a602 3
	bcopy(aw->addr_dyn->ifname, aw->addr.pfa.ifname,
	    sizeof(aw->addr.pfa.ifname));
	aw->addr_dyn = (struct pf_addr_dyn *)1;
d752 2
a753 2
		if (cur->src.addr.addr_dyn != NULL ||
		    prev->src.addr.addr_dyn != NULL ||
d757 2
a758 2
		    !PF_AEQ(&cur->src.addr.addr, &prev->src.addr.addr, 0) ||
		    !PF_AEQ(&cur->src.addr.mask, &prev->src.addr.mask, 0))
d764 2
a765 2
		if (cur->dst.addr.addr_dyn != NULL ||
		    prev->dst.addr.addr_dyn != NULL ||
d769 2
a770 2
		    !PF_AEQ(&cur->dst.addr.addr, &prev->dst.addr.addr, 0) ||
		    !PF_AEQ(&cur->dst.addr.mask, &prev->dst.addr.mask, 0))
d1411 2
a1412 2
	struct pf_addr		*raddr = &rpool->cur->addr.addr.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.addr.mask;
d1414 2
a1415 2
	if (cur->addr.addr.addr_dyn != NULL &&
	    cur->addr.addr.addr_dyn->undefined)
d1465 2
a1466 2
		if (pf_match_addr(0, &cur->addr.addr.addr, &cur->addr.addr.mask,
		    &rpool->counter, af)) {
d1473 2
a1474 2
			PF_ACPY(naddr, &cur->addr.addr.addr, af);
			PF_ACPY(&rpool->counter, &cur->addr.addr.addr, af);
d1610 1
a1610 1
		else if (src != NULL && !PF_AZERO(&src->addr.mask, af) &&
d1612 1
a1612 1
		    &src->addr.addr, &src->addr.mask, saddr, af))
d1618 1
a1618 1
		else if (!PF_AZERO(&r->dst.addr.mask, af) &&
d1620 1
a1620 1
		    &r->dst.addr.addr, &r->dst.addr.mask, daddr, af))
d1686 3
a1688 2
				if (r->rpool.cur->addr.addr.addr_dyn != NULL &&
				    r->rpool.cur->addr.addr.addr_dyn->undefined)
d1692 2
a1693 2
					    &r->rpool.cur->addr.addr.addr,
					    &r->rpool.cur->addr.addr.mask,
d1697 2
a1698 2
				if (r->src.addr.addr_dyn != NULL &&
				    r->src.addr.addr_dyn->undefined)
d1701 2
a1702 2
					PF_POOLMASK(naddr, &r->src.addr.addr,
					    &r->src.addr.mask, saddr, af);
d1708 1
a1708 1
			    &r->src.addr.addr, naddr, NULL))
d1843 3
a1845 2
		    !PF_AZERO(&r->src.addr.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.addr.mask, saddr, af))
d1854 3
a1856 2
		    !PF_AZERO(&r->dst.addr.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.addr.mask, daddr, af))
d2100 3
a2102 2
		    !PF_AZERO(&r->src.addr.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.addr.mask, saddr, af))
d2111 3
a2113 2
		    !PF_AZERO(&r->dst.addr.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.addr.mask, daddr, af))
d2381 3
a2383 2
		    !PF_AZERO(&r->src.addr.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.addr.mask, saddr, af))
d2389 3
a2391 2
		    !PF_AZERO(&r->dst.addr.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.addr.mask, daddr, af))
d2588 3
a2590 2
		    !PF_AZERO(&r->src.addr.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.addr.mask, pd->src, af))
d2596 3
a2598 2
		    !PF_AZERO(&r->dst.addr.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.addr.mask, pd->dst, af))
d2737 3
a2739 2
		    !PF_AZERO(&r->src.addr.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.addr.mask, pd->src, af))
d2745 3
a2747 2
		    !PF_AZERO(&r->dst.addr.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.addr.mask, pd->dst, af))
d4179 2
a4180 2
	if (r != NULL &&  r->src.addr.mask.addr32[0] == PF_TABLE_MASK)
		pfr_update_stats(&r->src.addr.addr, &r->src.addr.mask,
d4184 2
a4185 2
	if (r != NULL && r->dst.addr.mask.addr32[0] == PF_TABLE_MASK)
		pfr_update_stats(&r->dst.addr.addr, &r->dst.addr.mask,
@


1.296
log
@Honour noroute in skip step calculation, found by cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.295 2003/01/03 19:31:43 deraadt Exp $ */
d757 2
a758 1
		    cur->src.noroute !=  prev->src.noroute ||
d769 2
a770 1
		    cur->dst.noroute !=  prev->dst.noroute ||
d1840 2
a1841 1
		else if (r->src.noroute && pf_routable(saddr, af))
d1843 1
a1843 1
		else if (!r->src.noroute &&
d1850 2
a1851 1
		else if (r->dst.noroute && pf_routable(daddr, af))
d1853 1
a1853 1
		else if (!r->dst.noroute &&
d2095 2
a2096 1
		else if (r->src.noroute && pf_routable(saddr, af))
d2098 1
a2098 1
		else if (!r->src.noroute &&
d2105 2
a2106 1
		else if (r->dst.noroute && pf_routable(daddr, af))
d2108 1
a2108 1
		else if (!r->dst.noroute &&
d2374 2
a2375 1
		else if (r->src.noroute && pf_routable(saddr, af))
d2377 1
a2377 1
		else if (!r->src.noroute &&
d2381 2
a2382 1
		else if (r->dst.noroute && pf_routable(daddr, af))
d2384 1
a2384 1
		else if (!r->dst.noroute &&
d2579 2
a2580 1
		else if (r->src.noroute && pf_routable(pd->src, af))
d2582 1
a2582 1
		else if (!r->src.noroute &&
d2586 2
a2587 1
		else if (r->dst.noroute && pf_routable(pd->dst, af))
d2589 1
a2589 1
		else if (!r->src.noroute &&
d2726 2
a2727 1
		else if (r->src.noroute && pf_routable(pd->src, af))
d2729 1
a2729 1
		else if (!r->src.noroute &&
d2733 2
a2734 1
		else if (r->dst.noroute && pf_routable(pd->dst, af))
d2736 1
a2736 1
		else if (!r->src.noroute &&
@


1.295
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.294 2003/01/02 01:56:56 dhartmei Exp $ */
d757 1
d768 1
d2094 2
a2095 3
		    !PF_AZERO(&r->src.addr.mask, af) &&
		    !PF_MATCHA(r->src.not, &r->src.addr.addr, &r->src.addr.mask,
		    saddr, af))
d2103 2
a2104 3
		    !PF_AZERO(&r->dst.addr.mask, af) &&
		    !PF_MATCHA(r->dst.not, &r->dst.addr.addr, &r->dst.addr.mask,
			daddr, af))
@


1.294
log
@When route-to/reply-to is used in combination with address translation,
pf_test() may be called twice for the same packet. In this case, make
sure the translation is only applied in the second call. This solves
the problem with state insert failures where the second pf_test() call
tried to insert another state entry after the first call's translation.
ok henning@@, mcbride@@, thanks to Joe Nall for additional testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.293 2003/01/01 16:09:29 henning Exp $ */
d1804 1
a1804 1
	            saddr, th->th_sport, daddr, th->th_dport,
d1815 1
a1815 1
	            saddr, th->th_sport, daddr, th->th_dport,
d2057 1
a2057 1
	            saddr, uh->uh_sport, daddr, uh->uh_dport,
d2068 1
a2068 1
	            saddr, uh->uh_sport, daddr, uh->uh_dport,
d2315 1
a2315 1
	            saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d2336 1
a2336 1
	            saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d2523 1
a2523 1
	            saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d2542 1
a2542 1
	            saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d2864 4
a2867 3
	    /* Many stacks (ours included) will set the ACK number in an
	     * FIN|ACK if the SYN times out -- no sequence to ACK.
	     */
@


1.293
log
@use a #define for the default state table size
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.292 2003/01/01 04:26:19 dhartmei Exp $ */
d238 18
d2789 1
a2789 6
	if (direction == PF_IN)
		*state = pf_find_state(&tree_ext_gwy, &key);
	else
		*state = pf_find_state(&tree_lan_ext, &key);
	if (*state == NULL)
		return (PF_DROP);
d3069 1
a3069 6
	if (direction == PF_IN)
		*state = pf_find_state(&tree_ext_gwy, &key);
	else
		*state = pf_find_state(&tree_lan_ext, &key);
	if (*state == NULL)
		return (PF_DROP);
d3174 1
a3174 6
		if (direction == PF_IN)
			*state = pf_find_state(&tree_ext_gwy, &key);
		else
			*state = pf_find_state(&tree_lan_ext, &key);
		if (*state == NULL)
			return (PF_DROP);
d3353 1
a3353 6
			if (direction == PF_IN)
				*state = pf_find_state(&tree_ext_gwy, &key);
			else
				*state = pf_find_state(&tree_lan_ext, &key);
			if (*state == NULL)
				return (PF_DROP);
d3438 1
a3438 6
			if (direction == PF_IN)
				*state = pf_find_state(&tree_ext_gwy, &key);
			else
				*state = pf_find_state(&tree_lan_ext, &key);
			if (*state == NULL)
				return (PF_DROP);
d3499 1
a3499 6
			if (direction == PF_IN)
				*state = pf_find_state(&tree_ext_gwy, &key);
			else
				*state = pf_find_state(&tree_lan_ext, &key);
			if (*state == NULL)
				return (PF_DROP);
d3547 1
a3547 6
			if (direction == PF_IN)
				*state = pf_find_state(&tree_ext_gwy, &key);
			else
				*state = pf_find_state(&tree_lan_ext, &key);
			if (*state == NULL)
				return (PF_DROP);
d3598 1
a3598 6
	if (direction == PF_IN)
		*state = pf_find_state(&tree_ext_gwy, &key);
	else
		*state = pf_find_state(&tree_lan_ext, &key);
	if (*state == NULL)
		return (PF_DROP);
@


1.292
log
@Remove skip step for action (scrub vs. non-scrub), as scrub rules are
stored in a separate list now. Regress tests still pass after
sed "s/ a=end / /g", other skip steps are not affected.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.291 2003/01/01 03:53:22 dhartmei Exp $ */
d236 1
a236 1
    { { &pf_state_pl, 10000 }, { &pf_frent_pl, PFFRAG_FRENT_HIWAT } };
@


1.291
log
@Fix breakage from PF_RULESET_MAX increase, regress tests match again.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.290 2002/12/31 19:18:41 mcbride Exp $ */
a727 3
		if ((cur->action == PF_SCRUB && prev->action != PF_SCRUB) ||
		    (cur->action != PF_SCRUB && prev->action == PF_SCRUB))
			PF_SET_SKIP_STEPS(PF_SKIP_ACTION);
d1809 1
a1809 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION].ptr;
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
d2062 1
a2062 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION].ptr;
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
d2341 1
a2341 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION].ptr;
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
d2544 1
a2544 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION].ptr;
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
d2689 1
a2689 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION].ptr;
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
@


1.290
log
@Split scrub rules out from the filter rules in the kernel.
Precursor to removing rule.action from skip steps.

Also a couple of other small fixes:
- s/PF_RULESET_RULE/PF_RULESET_FILTER/
- replacement of 4 with PF_RULESET_MAX in pfvar.h struct ruleset {
- error handling in ioctl of an invalid value in rule.action
- counting evaluations and matching packets for scrub rules

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.289 2002/12/31 00:00:44 dhartmei Exp $ */
d773 3
a775 3
	for (i = 0; i < 4; i++) {
		TAILQ_FOREACH(rule,
		    pf_main_ruleset.rules[i].active.ptr, entries) {
a779 2
		}
	}
@


1.289
log
@Use a default state table limit of 10000 entries. This is safe for all
normal configurations, and sufficient for many. You can always increase
it, if you need more concurrent states and have enough memory (65000 for
64MB RAM, for instance). Suggested earlier by henning@@. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.288 2002/12/29 20:07:34 cedric Exp $ */
d1811 1
a1811 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_RULE].active.ptr);
d1872 1
a1872 1
				    PF_RULESET_RULE);
d1876 1
a1876 1
			    PF_RULESET_RULE);
d2066 1
a2066 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_RULE].active.ptr);
d2127 1
a2127 1
				    PF_RULESET_RULE);
d2131 1
a2131 1
			    PF_RULESET_RULE);
d2347 1
a2347 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_RULE].active.ptr);
d2392 1
a2392 1
				    PF_RULESET_RULE);
d2396 1
a2396 1
			    PF_RULESET_RULE);
d2552 1
a2552 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_RULE].active.ptr);
d2593 1
a2593 1
				    PF_RULESET_RULE);
d2597 1
a2597 1
			    PF_RULESET_RULE);
d2699 1
a2699 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_RULE].active.ptr);
d2741 1
a2741 1
				    PF_RULESET_RULE);
d2745 1
a2745 1
			    PF_RULESET_RULE);
@


1.288
log
@Add support for radix tables for source and destination of PF rules.
ok dhartmei@@, mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.287 2002/12/27 21:43:58 mcbride Exp $ */
d236 1
a236 1
    { { &pf_state_pl, UINT_MAX }, { &pf_frent_pl, PFFRAG_FRENT_HIWAT } };
@


1.287
log
@Fixups for pf_route and pf_route6.
- pull the route-to ifp from the current pf_pooladdr (not the last one)
  with stateful rules
- remove unnecessary PF_ACPY and PF_AZERO

ok dhartme@@ on pf_route version, pf_route6 is the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.286 2002/12/27 16:55:15 dhartmei Exp $ */
d144 1
d742 2
a743 4
		    !PF_AEQ(&cur->src.addr.addr, &prev->src.addr.addr,
		    cur->af) ||
		    !PF_AEQ(&cur->src.addr.mask, &prev->src.addr.mask,
		    cur->af))
d752 2
a753 4
		    !PF_AEQ(&cur->dst.addr.addr, &prev->dst.addr.addr,
		    cur->af) ||
		    !PF_AEQ(&cur->dst.addr.mask, &prev->dst.addr.mask,
		    cur->af))
d1156 3
d4194 11
@


1.286
log
@Handle binat-anchor rules in pf_match_translation(), they don't have a
redirection target address. Reported by Michael Lucas. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.285 2002/12/27 15:20:30 dhartmei Exp $ */
a3842 1
				s->rt_ifp = r->rpool.cur->ifp;
d3845 2
a3846 3
				    &naddr, NULL);
				if (!PF_AZERO(&naddr, AF_INET))
					PF_ACPY(&s->rt_addr, &naddr, AF_INET);
a4001 1
			s->rt_ifp = r->rpool.cur->ifp;
d4004 2
a4005 3
			    &naddr, NULL);
			if (!PF_AZERO(&naddr, AF_INET6))
				PF_ACPY(&s->rt_addr, &naddr, AF_INET6);
d4009 1
a4009 1
			    &naddr, AF_INET6);
@


1.285
log
@Initialize rt_ifp in newly allocated pf_state objects to NULL.
Solves the crashes in pf_route() with -current.
Reports from Michael Lucas and Bjorn Runaker.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.284 2002/12/26 16:21:37 mcbride Exp $ */
d1579 4
a1582 3
		if (r->action == PF_BINAT && direction == PF_IN)
			src = &r->rpool.cur->addr;
		else
d1595 1
a1595 1
		else if (!PF_AZERO(&src->addr.mask, af) &&
d1599 3
a1601 2
		else if (src->port_op && !pf_match_port(src->port_op,
		    src->port[0], src->port[1], sport))
@


1.284
log
@Prettier debug printing in pf_map_addr.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.283 2002/12/26 15:51:51 dhartmei Exp $ */
d1936 1
d2182 1
d2429 1
d2623 1
d3876 1
a3876 1
	if ((u_int16_t)ip->ip_len <= ifp->if_mtu) {
@


1.283
log
@Additional sanity checks for pf_route(). Please report when any of these
panics should occur. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.282 2002/12/23 13:15:18 mcbride Exp $ */
d1466 1
a1466 1
		printf("pf_map_addr: selected address:");
@


1.282
log
@Change from array to single pf_pabuf (no longer need multiple buffers as
we don't need the second list of addresses for DIOCCHANGE* operations)

Also get rid of a bug where DIOCBEGINADDRS clears pabuf[1] when pabuf[0]
is the one being used.

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.281 2002/12/22 02:37:58 mcbride Exp $ */
d3783 1
a3783 1
	struct ifnet		*ifp;
a3785 1
	int			 hlen;
d3788 4
d3802 2
a3804 1
	hlen = ip->ip_hl << 2;
d3826 12
a3837 2
		if (!TAILQ_EMPTY(&r->rpool.list)) {
			if (s == NULL) {
d3842 1
a3842 16
					dst->sin_addr.s_addr = naddr.v4.s_addr;
				ifp = r->rpool.cur->ifp;
			} else {
				if (s->rt_ifp == NULL) {
					s->rt_ifp = r->rpool.cur->ifp;
					pf_map_addr(AF_INET, &r->rpool,
					    (struct pf_addr *)&ip->ip_src,
					    &naddr, NULL);
					if (!PF_AZERO(&naddr, AF_INET))
						PF_ACPY(&s->rt_addr, &naddr,
						    AF_INET);
				}
				if (!PF_AZERO(&s->rt_addr, AF_INET))
					dst->sin_addr.s_addr =
					    s->rt_addr.v4.s_addr;
				ifp = s->rt_ifp;
d3844 4
d3861 7
a3867 7
			else {
				mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0,
				    M_NOWAIT);
				if (mtag == NULL)
					goto bad;
				m_tag_prepend(m0, mtag);
			}
d3881 1
a3881 1
			ip->ip_sum = in_cksum(m0, hlen);
d3948 1
a3948 1
	struct ifnet		*ifp;
d3952 3
a3954 2
	if (m == NULL)
		return;
d3966 2
a3976 28
	if (!TAILQ_EMPTY(&r->rpool.list)) {
		if (s == NULL) {
			pf_map_addr(AF_INET6, &r->rpool,
			    (struct pf_addr *)&ip6->ip6_src, &naddr, NULL);
			if (!PF_AZERO(&naddr, AF_INET6)) {
				PF_ACPY(
				    (struct pf_addr *)&dst->sin6_addr,
				    &naddr, AF_INET6);
			}
			ifp = r->rpool.cur->ifp;
		} else {
			if (s->rt_ifp == NULL) {
				s->rt_ifp = r->rpool.cur->ifp;
				pf_map_addr(AF_INET6, &r->rpool,
				    (struct pf_addr *)&ip6->ip6_src,
				    &naddr, NULL);
				if (!PF_AZERO(&naddr, AF_INET6))
					PF_ACPY(&s->rt_addr, &naddr, AF_INET6);
			}
			if (!PF_AZERO(&s->rt_addr, AF_INET6)) {
				PF_ACPY(
				    (struct pf_addr *)&dst->sin6_addr,
				    &naddr, AF_INET6);
			}
			ifp = s->rt_ifp;
		}
	}

d3987 24
d4021 4
a4024 7
			else {
				mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0,
				    M_NOWAIT);
				if (mtag == NULL)
					goto bad;
				m_tag_prepend(m0, mtag);
			}
d4234 1
a4234 1
	if (r && r->rt)
d4408 1
a4408 1
	if (r && r->rt)
@


1.281
log
@Handle rdr rules with unspecified proxy ports correctly. Also don't
print the port number in pf_print_host if it's 0 (like when
pf_print_host is called from pf_map_addr)

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.280 2002/12/19 12:46:06 dhartmei Exp $ */
d97 1
a97 1
struct pf_palist	 pf_pabuf[2];
@


1.280
log
@Replace skip step calculation so it scales O(n) instead of O(n*n).
Loading large rulesets consists of two phases. First, the rules are
parsed and added, one by one, to the inactive ruleset. The machine
remains responsive during that phase. Then, the new ruleset is
activated, and the skip steps are calculated. The machine locks up
during that phase. This second phase is greatly reduced with the new
algorithm. With the old one, calculation could take 30s for 12k rules,
with the new one, 100k rules take less than 1s. For small rulesets
(less than 1000 rules), the gain is insignificant.

ok mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.279 2002/12/19 11:05:11 dhartmei Exp $ */
d595 6
a600 3
		p = ntohs(p);
		printf("%u.%u.%u.%u:%u", (a>>24)&255, (a>>16)&255,
		    (a>>8)&255, a&255, p);
d642 4
a645 2
		p = ntohs(p);
		printf("[%u]", p);
a1688 2
			u_int32_t	tmp_nport;

d1693 10
a1702 6
			tmp_nport = ntohs(r->rpool.proxy_port[0])
			    + (ntohs(dport) - ntohs(r->dst.port[0]));
			/* wrap around if necessary */
			if (tmp_nport > 65535)
				tmp_nport -= 65535;
			*nport = htons((u_int16_t)tmp_nport);
@


1.279
log
@fix 'no nat/rdr/binat' evaluation. from mcbride@@, slightly modified :)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.278 2002/12/19 10:49:54 dhartmei Exp $ */
d702 7
a708 9
#define		 PF_CALC_SKIP_STEP(i, c) \
		do { \
			if (a & 1 << i) { \
				if (c) \
					r->skip[i].ptr = TAILQ_NEXT(s, entries); \
				else \
					a ^= 1 << i; \
			} \
		} while (0)
d713 2
a714 2
	struct pf_rule	*r, *s;
	int		 a, i;
d716 44
a759 45
	r = TAILQ_FIRST(rules);
	while (r != NULL) {
		a = 0;
		for (i = 0; i < PF_SKIP_COUNT; ++i) {
			a |= 1 << i;
			r->skip[i].ptr = TAILQ_NEXT(r, entries);
		}
		s = TAILQ_NEXT(r, entries);
		while (a && s != NULL) {
			PF_CALC_SKIP_STEP(PF_SKIP_ACTION,
			    (s->action == PF_SCRUB && r->action == PF_SCRUB) ||
			    (s->action != PF_SCRUB && r->action != PF_SCRUB));
			PF_CALC_SKIP_STEP(PF_SKIP_IFP,
			    s->ifp == r->ifp && s->ifnot == r->ifnot);
			PF_CALC_SKIP_STEP(PF_SKIP_DIR,
			    s->direction == r->direction);
			PF_CALC_SKIP_STEP(PF_SKIP_AF, s->af == r->af);
			PF_CALC_SKIP_STEP(PF_SKIP_PROTO, s->proto == r->proto);
			PF_CALC_SKIP_STEP(PF_SKIP_SRC_ADDR,
			    s->src.addr.addr_dyn == NULL &&
			    r->src.addr.addr_dyn == NULL &&
			    PF_AEQ(&s->src.addr.addr, &r->src.addr.addr,
			    r->af) &&
			    PF_AEQ(&s->src.addr.mask, &r->src.addr.mask,
			    r->af) &&
			    s->src.not == r->src.not);
			PF_CALC_SKIP_STEP(PF_SKIP_SRC_PORT,
			    s->src.port[0] == r->src.port[0] &&
			    s->src.port[1] == r->src.port[1] &&
			    s->src.port_op == r->src.port_op);
			PF_CALC_SKIP_STEP(PF_SKIP_DST_ADDR,
			    s->dst.addr.addr_dyn == NULL &&
			    r->dst.addr.addr_dyn == NULL &&
			    PF_AEQ(&s->dst.addr.addr, &r->dst.addr.addr,
			    r->af) &&
			    PF_AEQ(&s->dst.addr.mask, &r->dst.addr.mask,
			    r->af) &&
			    s->dst.not == r->dst.not);
			PF_CALC_SKIP_STEP(PF_SKIP_DST_PORT,
			    s->dst.port[0] == r->dst.port[0] &&
			    s->dst.port[1] == r->dst.port[1] &&
			    s->dst.port_op == r->dst.port_op);
			s = TAILQ_NEXT(s, entries);
		}
		r = TAILQ_NEXT(r, entries);
d761 2
@


1.278
log
@Initialize pf_state.nat_rule to NULL if there's no translation used.
Found by markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.277 2002/12/18 19:40:41 dhartmei Exp $ */
d1581 1
a1581 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION].ptr;
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
d1614 3
@


1.277
log
@Store translation rule pointer in state entries, so pfctl -vsn can print
evaluation, packet, byte and state entry counters similar to -vsr. Helps
verify whether/how often translation rules are evaluated/matched.
ok frantzen@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.276 2002/12/18 18:35:30 dhartmei Exp $ */
d1935 1
a1935 1
		else if (rdr != NULL)
d2180 1
a2180 1
		else if (rdr != NULL)
d2426 1
a2426 1
		else if (rdr != NULL)
d2619 1
a2619 1
		else if (rdr != NULL)
@


1.276
log
@When logging packets matched by rules within anchors, use the anchor rule
(in the main set) number, not the number of the rule within the anchor.
Eventually, both will get logged. But as long as we only log one number,
this makes more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.275 2002/12/18 16:59:47 henning Exp $ */
d480 2
d1933 6
d2178 6
d2424 6
d2617 6
d3036 4
d3107 4
d3686 4
@


1.275
log
@big KNF round
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.274 2002/12/18 16:28:40 dhartmei Exp $ */
d1880 1
a1880 1
			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
d2128 1
a2128 1
			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
d2389 1
a2389 1
			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
d2577 1
a2577 1
			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
d2641 1
a2641 1
				    *rm);
d2720 1
a2720 1
			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
@


1.274
log
@Pass skip step values through ioctl interface, pfctl -vvsr shows them,
main purpose is making them regress-testable.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.273 2002/12/18 16:03:25 henning Exp $ */
d209 1
d215 1
d233 1
a236 1

d257 1
a257 1
	int diff;
d345 1
a345 1
	struct pf_tree_node *k;
d358 1
a358 1
	struct pf_tree_node *keya, *keyb;
d436 2
a437 2
	struct timeout *to = arg;
	int s;
d450 2
a451 2
	struct pf_tree_node *cur, *peer, *next;
	struct pf_tree_node key;
d523 3
a525 3
	struct pf_addr_dyn *ad = (struct pf_addr_dyn *)p;
	struct ifaddr *ia;
	int s, changed = 0;
d713 2
a714 2
	struct pf_rule *r, *s;
	int a, i;
d767 2
a768 2
	struct pf_rule *rule;
	int i;
d784 1
a784 1
	u_int32_t l;
d800 2
a801 2
	struct pf_addr ao;
	u_int16_t po = *p;
d843 1
a843 1
	u_int32_t ao = *a;
d854 1
a854 1
	struct pf_addr ao;
d878 3
a880 3
	struct pf_addr oia, ooa;
	u_int32_t opc, oh2c = *h2c;
	u_int16_t oip = *ip;
d956 3
a958 3
	struct mbuf *m;
	struct m_tag *mtag;
	int len;
d960 1
a960 1
	struct ip *h2;
d963 1
a963 1
	struct ip6_hdr *h2_6;
d965 1
a965 1
	struct tcphdr *th2;
d1099 2
a1100 2
	struct m_tag *mtag;
	struct mbuf *m0;
d1151 2
a1152 1
	int match = 0;
d1347 1
a1347 1
	u_int32_t a = 0x9e3779b9, b = 0x9e3779b9, c = key->key32[0];
d1388 4
a1391 4
	unsigned char hash[16];
	struct pf_pooladdr *cur = rpool->cur;
	struct pf_addr *raddr = &rpool->cur->addr.addr.addr;
	struct pf_addr *rmask = &rpool->cur->addr.addr.mask;
a1396 1

d1474 2
a1475 3
	struct pf_tree_node key;
	struct pf_addr init_addr;

a1483 1

d1566 2
a1567 2
	struct pf_rule *r, *rm = NULL, *anchorrule = NULL;
	struct pf_ruleset *ruleset = NULL;
d1571 1
a1571 1
		struct pf_rule_addr *src = NULL;
d1623 1
a1623 1
	struct pf_rule *r = NULL;
d1682 1
a1682 1
			u_int32_t tmp_nport;
d1709 4
a1712 4
	struct pf_addr *saddr, *daddr;
	u_int16_t sport, dport;
	struct inpcbtable *tb;
	struct inpcb *inp;
d1736 1
a1736 1
		u_int16_t p;
d1760 13
a1772 12
	struct pf_rule *nat = NULL, *rdr = NULL;
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr, naddr;
	struct tcphdr *th = pd->hdr.tcp;
	u_int16_t bport, nport = 0;
	sa_family_t af = pd->af;
	int lookup = -1;
	uid_t uid;
	gid_t gid;
	struct pf_rule *r, *rs = NULL, *anchorrule = NULL;
	struct pf_ruleset *ruleset = NULL;
	u_short reason;
	int rewrite = 0;
d1916 2
a1917 2
		u_int16_t len;
		struct pf_state *s = NULL;
d2008 13
a2020 12
	struct pf_rule *nat = NULL, *rdr = NULL;
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr, naddr;
	struct udphdr *uh = pd->hdr.udp;
	u_int16_t bport, nport = 0;
	sa_family_t af = pd->af;
	int lookup = -1;
	uid_t uid;
	gid_t gid;
	struct pf_rule *r, *rs = NULL, *anchorrule = NULL;
	struct pf_ruleset *ruleset = NULL;
	u_short reason;
	int rewrite = 0;
d2159 1
a2159 1
		struct pf_state *s = NULL;
d2232 10
a2241 9
	struct pf_rule *nat = NULL, *rdr = NULL;
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr, naddr;
	struct pf_rule *r, *rs = NULL, *anchorrule = NULL;
	struct pf_ruleset *ruleset = NULL;
	u_short reason;
	u_int16_t icmpid;
	sa_family_t af = pd->af;
	u_int8_t icmptype, icmpcode;
	int state_icmp = 0;
d2243 1
a2243 1
	int rewrite = 0;
d2399 1
a2399 1
		struct pf_state *s = NULL;
d2471 7
a2477 7
	struct pf_rule *nat = NULL, *rdr = NULL;
	struct pf_rule *r, *rs = NULL, *anchorrule = NULL;
	struct pf_ruleset *ruleset = NULL;
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr, naddr;
	sa_family_t af = pd->af;
	u_short reason;

d2586 1
a2586 1
		struct pf_state *s = NULL;
d2654 3
a2656 3
	struct pf_rule *r, *rs = NULL, *anchorrule = NULL;
	struct pf_ruleset *ruleset = NULL;
	sa_family_t af = pd->af;
d2710 1
a2710 1
		u_short reason;
d2733 6
a2738 6
	struct pf_tree_node key;
	struct tcphdr *th = pd->hdr.tcp;
	u_int16_t win = ntohs(th->th_win);
	u_int32_t ack, end, seq;
	int ackskew;
	struct pf_state_peer *src, *dst;
d3017 3
a3019 3
	struct pf_state_peer *src, *dst;
	struct pf_tree_node key;
	struct udphdr *uh = pd->hdr.udp;
d3084 4
a3087 4
	struct pf_addr *saddr = pd->src, *daddr = pd->dst;
	u_int16_t icmpid, *icmpsum;
	u_int8_t icmptype;
	int state_icmp = 0;
d3125 1
a3125 1
		struct pf_tree_node key;
d3197 1
a3197 1
		struct pf_pdesc pd2;
d3199 1
a3199 1
		struct ip h2;
d3202 2
a3203 2
		struct ip6_hdr h2_6;
		int terminal = 0;
d3205 2
a3206 2
		int ipoff2;
		int off2;
d3294 4
a3297 4
			struct tcphdr th;
			u_int32_t seq;
			struct pf_tree_node key;
			struct pf_state_peer *src, *dst;
d3390 2
a3391 2
			struct udphdr uh;
			struct pf_tree_node key;
d3456 2
a3457 2
			struct icmp iih;
			struct pf_tree_node key;
d3509 2
a3510 2
			struct icmp6_hdr iih;
			struct pf_tree_node key;
d3573 2
a3574 2
	struct pf_state_peer *src, *dst;
	struct pf_tree_node key;
d3667 2
a3668 2
		struct ip *h = mtod(m, struct ip *);
		u_int16_t fragoff = (h->ip_off & IP_OFFMASK) << 3;
d3689 2
a3690 1
		struct ip6_hdr *h = mtod(m, struct ip6_hdr *);
d3707 5
a3711 7
pf_routable(addr, af)
	struct pf_addr *addr;
	sa_family_t af;
{
	struct sockaddr_in *dst;
	struct route ro;
	int ret = 0;
d3733 10
a3742 10
	struct mbuf *m0, *m1;
	struct route iproute;
	struct route *ro;
	struct sockaddr_in *dst;
	struct ip *ip;
	struct ifnet *ifp;
	struct m_tag *mtag;
	struct pf_addr naddr;
	int hlen;
	int error = 0;
d3894 9
a3902 9
	struct mbuf *m0;
	struct m_tag *mtag;
	struct route_in6 ip6route;
	struct route_in6 *ro;
	struct sockaddr_in6 *dst;
	struct ip6_hdr *ip6;
	struct ifnet *ifp;
	struct pf_addr naddr;
	int error = 0;
d4014 7
a4020 7
	u_short action, reason = 0, log = 0;
	struct mbuf *m = *m0;
	struct ip *h;
	struct pf_rule *r = NULL;
	struct pf_state *s = NULL;
	struct pf_pdesc pd;
	int off;
d4071 2
a4072 1
		struct tcphdr th;
a4073 1

d4093 2
a4094 1
		struct udphdr uh;
a4095 1

d4111 2
a4112 1
		struct icmp ih;
a4113 1

d4159 2
a4160 2
		struct m_tag *mtag;
		struct altq_tag *atag;
d4179 2
a4180 1
			struct pf_rule r0;
d4201 5
a4205 5
	u_short action, reason = 0, log = 0;
	struct mbuf *m = *m0;
	struct ip6_hdr *h;
	struct pf_rule *r = NULL;
	struct pf_state *s = NULL;
d4207 1
a4207 1
	int off, terminal = 0;
d4249 1
a4249 1
			struct ip6_ext opt6;
d4277 2
a4278 1
		struct tcphdr th;
a4279 1

d4299 2
a4300 1
		struct udphdr uh;
a4301 1

d4317 2
a4318 1
		struct icmp6_hdr ih;
a4319 1

d4353 2
a4354 1
			struct pf_rule r0;
@


1.273
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.272 2002/12/18 14:41:37 mcbride Exp $ */
d702 1
a702 1
					r->skip[i] = TAILQ_NEXT(s, entries); \
d719 1
a719 1
			r->skip[i] = TAILQ_NEXT(r, entries);
d1580 1
a1580 1
			r = r->skip[PF_SKIP_ACTION];
d1583 1
a1583 1
			r = r->skip[PF_SKIP_IFP];
d1585 1
a1585 1
			r = r->skip[PF_SKIP_DIR];
d1587 1
a1587 1
			r = r->skip[PF_SKIP_AF];
d1589 1
a1589 1
			r = r->skip[PF_SKIP_PROTO];
d1593 1
a1593 1
			r = r->skip[PF_SKIP_SRC_ADDR];
d1596 1
a1596 1
			r = r->skip[PF_SKIP_SRC_PORT];
d1600 1
a1600 1
			r = r->skip[PF_SKIP_DST_ADDR];
d1603 1
a1603 1
			r = r->skip[PF_SKIP_DST_PORT];
d1803 1
a1803 1
			r = r->skip[PF_SKIP_ACTION];
d1806 1
a1806 1
			r = r->skip[PF_SKIP_IFP];
d1808 1
a1808 1
			r = r->skip[PF_SKIP_DIR];
d1810 1
a1810 1
			r = r->skip[PF_SKIP_AF];
d1812 1
a1812 1
			r = r->skip[PF_SKIP_PROTO];
d1818 1
a1818 1
			r = r->skip[PF_SKIP_SRC_ADDR];
d1821 1
a1821 1
			r = r->skip[PF_SKIP_SRC_PORT];
d1827 1
a1827 1
			r = r->skip[PF_SKIP_DST_ADDR];
d1830 1
a1830 1
			r = r->skip[PF_SKIP_DST_PORT];
d2050 1
a2050 1
			r = r->skip[PF_SKIP_ACTION];
d2053 1
a2053 1
			r = r->skip[PF_SKIP_IFP];
d2055 1
a2055 1
			r = r->skip[PF_SKIP_DIR];
d2057 1
a2057 1
			r = r->skip[PF_SKIP_AF];
d2059 1
a2059 1
			r = r->skip[PF_SKIP_PROTO];
d2066 1
a2066 1
			r = r->skip[PF_SKIP_SRC_ADDR];
d2069 1
a2069 1
			r = r->skip[PF_SKIP_SRC_PORT];
d2076 1
a2076 1
			r = r->skip[PF_SKIP_DST_ADDR];
d2079 1
a2079 1
			r = r->skip[PF_SKIP_DST_PORT];
d2323 1
a2323 1
			r = r->skip[PF_SKIP_ACTION];
d2326 1
a2326 1
			r = r->skip[PF_SKIP_IFP];
d2328 1
a2328 1
			r = r->skip[PF_SKIP_DIR];
d2330 1
a2330 1
			r = r->skip[PF_SKIP_AF];
d2332 1
a2332 1
			r = r->skip[PF_SKIP_PROTO];
d2338 1
a2338 1
			r = r->skip[PF_SKIP_SRC_ADDR];
d2344 1
a2344 1
			r = r->skip[PF_SKIP_DST_ADDR];
d2521 1
a2521 1
			r = r->skip[PF_SKIP_ACTION];
d2524 1
a2524 1
			r = r->skip[PF_SKIP_IFP];
d2526 1
a2526 1
			r = r->skip[PF_SKIP_DIR];
d2528 1
a2528 1
			r = r->skip[PF_SKIP_AF];
d2530 1
a2530 1
			r = r->skip[PF_SKIP_PROTO];
d2536 1
a2536 1
			r = r->skip[PF_SKIP_SRC_ADDR];
d2542 1
a2542 1
			r = r->skip[PF_SKIP_DST_ADDR];
d2661 1
a2661 1
			r = r->skip[PF_SKIP_ACTION];
d2664 1
a2664 1
			r = r->skip[PF_SKIP_IFP];
d2666 1
a2666 1
			r = r->skip[PF_SKIP_DIR];
d2668 1
a2668 1
			r = r->skip[PF_SKIP_AF];
d2670 1
a2670 1
			r = r->skip[PF_SKIP_PROTO];
d2676 1
a2676 1
			r = r->skip[PF_SKIP_SRC_ADDR];
d2682 1
a2682 1
			r = r->skip[PF_SKIP_DST_ADDR];
@


1.272
log
@Match the rule protocol against the actual protocol of the packet, not just
tcp. A silly copy/paste error by yours truly located by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.271 2002/12/17 12:30:13 mcbride Exp $ */
d177 1
a177 1
struct pf_rule 		*pf_match_translation(int, struct ifnet *, u_int8_t,
@


1.271
log
@Merge pf_nat/pf_binat/pf_rdr structs into pf_rule. Simplifies code, allows
skip steps on translation rules.

Also:
- Require a ticket for DIOCCHANGERULE operations to prevent races.
- Remove pf_compare_* functions from pf_ioctl.c. DIOCCHANGE* operations
  use a rule number, and comparisons happen in userland.

Testing and fixes from dhartmei@@ and frantzen@@

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.270 2002/12/13 21:48:30 henning Exp $ */
d1588 1
a1588 1
		else if (r->proto && r->proto != IPPROTO_TCP)
@


1.270
log
@add pqueue and pqid to pf_rule.
this allows for a second queue on pf_rule.
assign packets with tos 0x10 (lowdelay) to this one.
if the second queue isn't specified set pqid = qid

idea dhartmei@@
ok dhartmei@@ frantzen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.269 2002/12/06 00:47:32 dhartmei Exp $ */
d142 2
a143 3
struct pool		 pf_tree_pl, pf_rule_pl, pf_nat_pl, pf_sport_pl;
struct pool		 pf_rdr_pl, pf_state_pl, pf_binat_pl, pf_addr_pl;
struct pool		 pf_altq_pl, pf_pooladdr_pl;
a152 1

d177 4
a180 2
u_int16_t		 pf_map_port_range(struct pf_rdr *, u_int16_t);
struct pf_nat		*pf_get_nat(struct ifnet *, u_int8_t,
a183 6
struct pf_binat		*pf_get_binat(int, struct ifnet *, u_int8_t,
			    struct pf_addr *, struct pf_addr *,
			    struct pf_addr *, sa_family_t);
struct pf_rdr		*pf_get_rdr(struct ifnet *, u_int8_t,
			    struct pf_addr *, struct pf_addr *, u_int16_t,
			    struct pf_addr *, sa_family_t);
d766 10
a775 27
	struct pf_nat *nat;
	struct pf_rdr *rdr;
	struct pf_binat *binat;

	TAILQ_FOREACH(rule, pf_main_ruleset.rules.active.ptr, entries) {
		if (rule->anchorname[0])
			rule->anchor = pf_find_anchor(rule->anchorname);
		else
			rule->anchor = NULL;
	}
	TAILQ_FOREACH(nat, pf_main_ruleset.nats.active.ptr, entries) {
		if (nat->anchorname[0])
			nat->anchor = pf_find_anchor(nat->anchorname);
		else
			nat->anchor = NULL;
	}
	TAILQ_FOREACH(rdr, pf_main_ruleset.rdrs.active.ptr, entries) {
		if (rdr->anchorname[0])
			rdr->anchor = pf_find_anchor(rdr->anchorname);
		else
			rdr->anchor = NULL;
	}
	TAILQ_FOREACH(binat, pf_main_ruleset.binats.active.ptr, entries) {
		if (binat->anchorname[0])
			binat->anchor = pf_find_anchor(binat->anchorname);
		else
			binat->anchor = NULL;
d1193 2
d1244 2
a1245 2
		while ((s) != NULL &&					\
		    ((r) = TAILQ_FIRST((s)->n.active.ptr)) == NULL)	\
d1258 2
a1259 2
		while ((s) != NULL &&					\
		    ((r) = TAILQ_FIRST((s)->n.active.ptr)) == NULL)	\
d1387 2
a1388 2
	struct pf_addr *raddr = &rpool->cur->addr.addr;
	struct pf_addr *rmask = &rpool->cur->addr.mask;
d1390 2
a1391 1
	if (cur->addr.addr_dyn != NULL && cur->addr.addr_dyn->undefined)
d1442 1
a1442 1
		if (pf_match_addr(0, &cur->addr.addr, &cur->addr.mask,
d1450 2
a1451 2
			PF_ACPY(naddr, &cur->addr.addr, af);
			PF_ACPY(&rpool->counter, &cur->addr.addr, af);
d1561 4
a1564 4
struct pf_nat *
pf_get_nat(struct ifnet *ifp, u_int8_t proto, struct pf_addr *saddr,
    u_int16_t sport, struct pf_addr *daddr, u_int16_t dport,
    struct pf_addr *naddr, u_int16_t *nport, sa_family_t af)
d1566 1
a1566 1
	struct pf_nat *n, *nm = NULL, *anchorrule = NULL;
d1569 44
a1612 32
	n = TAILQ_FIRST(pf_main_ruleset.nats.active.ptr);
	while (n && nm == NULL) {
		if (((n->ifp == NULL) || (n->ifp == ifp && !n->ifnot) ||
		    (n->ifp != ifp && n->ifnot)) &&
		    (!n->proto || n->proto == proto) &&
		    (!n->af || n->af == af) &&
		    (n->src.addr.addr_dyn == NULL ||
		    !n->src.addr.addr_dyn->undefined) &&
		    PF_MATCHA(n->src.not, &n->src.addr.addr, &n->src.addr.mask,
		    saddr, af) &&
		    (!n->src.port_op ||
		    (proto != IPPROTO_TCP && proto != IPPROTO_UDP) ||
		    pf_match_port(n->src.port_op, n->src.port[0],
		    n->src.port[1], sport)) &&
		    (n->dst.addr.addr_dyn == NULL ||
		    !n->dst.addr.addr_dyn->undefined) &&
		    PF_MATCHA(n->dst.not, &n->dst.addr.addr, &n->dst.addr.mask,
		    daddr, af) &&
		    (!n->dst.port_op ||
		    (proto != IPPROTO_TCP && proto != IPPROTO_UDP) ||
		    pf_match_port(n->dst.port_op, n->dst.port[0],
		    n->dst.port[1], dport)) &&
		    (!n->anchorname[0] || n->anchor != NULL)) {
			if (n->anchor == NULL)
				nm = n;
			else
				PF_STEP_INTO_ANCHOR(n, anchorrule, ruleset,
				    nats);
		} else
			n = TAILQ_NEXT(n, entries);
		if (n == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(n, anchorrule, ruleset, nats);
d1614 1
a1614 18
	if (nm) {
		if (nm->no)
			return (NULL);
		else {
			if (pf_get_sport(af, proto,
			    &nm->rpool, saddr, sport, daddr,
			    dport, naddr, nport, nm->proxy_port[0],
			    nm->proxy_port[1])) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: NAT proxy port allocation "
				    "(%u-%u) failed\n",
				    nm->proxy_port[0],
				    nm->proxy_port[1]));
			}
		}
	}

	return (nm);
d1617 5
a1621 4
struct pf_binat *
pf_get_binat(int direction, struct ifnet *ifp, u_int8_t proto,
    struct pf_addr *saddr, struct pf_addr *daddr, struct pf_addr *naddr,
    sa_family_t af)
d1623 1
a1623 2
	struct pf_binat *b, *bm = NULL, *anchorrule = NULL;
	struct pf_ruleset *ruleset = NULL;
d1625 12
a1636 29
	b = TAILQ_FIRST(pf_main_ruleset.binats.active.ptr);
	while (b && bm == NULL) {
		struct pf_addr_wrap *src;

		if (direction == PF_OUT)
			src = &b->saddr;
		else
			src = &b->raddr;

		if (b->ifp == ifp &&
		    (!b->proto || b->proto == proto) &&
		    (!b->af || b->af == af) &&
		    (src->addr_dyn == NULL ||
		    !src->addr_dyn->undefined) &&
		    PF_MATCHA(0, &src->addr, &src->mask, saddr, af) &&
		    (b->daddr.addr_dyn == NULL ||
		    !b->daddr.addr_dyn->undefined) &&
		    PF_MATCHA(b->dnot, &b->daddr.addr, &b->daddr.mask,
		    daddr, af) &&
		    (!b->anchorname[0] || b->anchor != NULL)) {
			if (b->anchor == NULL)
				bm = b;
			else
				PF_STEP_INTO_ANCHOR(b, anchorrule, ruleset,
				    binats);
		} else
			b = TAILQ_NEXT(b, entries);
		if (b == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(b, anchorrule, ruleset, binats);
d1639 5
a1643 2
	if (bm) {
		if (bm->no)
d1645 11
a1655 4
		switch (direction) {
		case PF_OUT:
			if (bm->raddr.addr_dyn != NULL &&
			    bm->raddr.addr_dyn->undefined)
d1657 23
a1679 3
			else
				PF_POOLMASK(naddr, &bm->raddr.addr,
				    &bm->raddr.mask, saddr, af);
d1681 5
a1685 3
		case PF_IN:
			if (bm->saddr.addr_dyn != NULL &&
			    bm->saddr.addr_dyn->undefined)
d1687 7
a1693 3
			else
				PF_POOLMASK(naddr, &bm->saddr.addr,
				    &bm->saddr.mask, saddr, af);
d1696 1
a1696 44
	}

	return (bm);
}

struct pf_rdr *
pf_get_rdr(struct ifnet *ifp, u_int8_t proto, struct pf_addr *saddr,
    struct pf_addr *daddr, u_int16_t dport, struct pf_addr *naddr,
    sa_family_t af)
{
	struct pf_rdr *r, *rm = NULL, *anchorrule = NULL;
	struct pf_ruleset *ruleset = NULL;

	r = TAILQ_FIRST(pf_main_ruleset.rdrs.active.ptr);
	while (r && rm == NULL) {
		if (((r->ifp == NULL) || (r->ifp == ifp && !r->ifnot) ||
		    (r->ifp != ifp && r->ifnot)) &&
		    (!r->proto || r->proto == proto) &&
		    (!r->af || r->af == af) &&
		    (r->saddr.addr_dyn == NULL ||
		    !r->saddr.addr_dyn->undefined) &&
		    PF_MATCHA(r->snot, &r->saddr.addr, &r->saddr.mask,
		    saddr, af) &&
		    (r->daddr.addr_dyn == NULL ||
		    !r->daddr.addr_dyn->undefined) &&
		    PF_MATCHA(r->dnot, &r->daddr.addr, &r->daddr.mask,
		    daddr, af) &&
		    ((!r->dport2 && (!r->dport || dport == r->dport)) ||
		    (r->dport2 && (ntohs(dport) >= ntohs(r->dport)) &&
		    ntohs(dport) <= ntohs(r->dport2))) &&
		    (!r->anchorname[0] || r->anchor != NULL)) {
			if (r->anchor == NULL)
				rm = r;
			else
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
				    rdrs);
		} else
			r = TAILQ_NEXT(r, entries);
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset, rdrs);
	}
	if (rm) {
		if (rm->no || pf_map_addr(rm->af, &rm->rpool,
		    &rm->saddr.addr, naddr, NULL))
d1698 2
d1702 1
a1702 13
	return (rm);
}

u_int16_t
pf_map_port_range(struct pf_rdr *rdr, u_int16_t port)
{
	u_int32_t nport;

	nport = ntohs(rdr->rport) - ntohs(rdr->dport) + ntohs(port);
	/* wrap around if necessary */
	if (nport > 65535)
		nport -= 65535;
	return (htons((u_int16_t)nport));
d1760 1
a1760 3
	struct pf_nat *nat = NULL;
	struct pf_binat *binat = NULL;
	struct pf_rdr *rdr = NULL;
d1777 4
a1780 3
		/* check outgoing packet for BINAT */
		if ((binat = pf_get_binat(PF_OUT, ifp, IPPROTO_TCP,
		    saddr, daddr, &naddr, af)) != NULL) {
d1786 5
a1790 3
		/* check outgoing packet for NAT */
		else if ((nat = pf_get_nat(ifp, IPPROTO_TCP,
		    saddr, th->th_sport, daddr, th->th_dport,
a1791 17
			PF_ACPY(&baddr, saddr, af);
			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &naddr, htons(nport),
			    0, af);
			rewrite++;
		}
	} else {
		/* check incoming packet for RDR */
		if ((rdr = pf_get_rdr(ifp, IPPROTO_TCP, saddr, daddr,
		    th->th_dport, &naddr, af)) != NULL) {
			bport = th->th_dport;
			if (rdr->opts & PF_RPORT_RANGE)
				nport = pf_map_port_range(rdr, th->th_dport);
			else if (rdr->rport)
				nport = rdr->rport;
			else
				nport = bport;
a1796 9
		/* check incoming packet for BINAT */
		else if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_TCP,
		    daddr, saddr, &naddr, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
			bport = th->th_dport;
			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &naddr, th->th_dport, 0, af);
			rewrite++;
		}
d1799 1
a1799 1
	r = TAILQ_FIRST(pf_main_ruleset.rules.active.ptr);
d1860 1
a1860 1
				    rules);
d1863 2
a1864 1
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset, rules);
d1887 1
a1887 2
			if (nat != NULL ||
			    (binat != NULL && direction == PF_OUT)) {
d1891 1
a1891 2
			} else if (rdr != NULL ||
			    (binat != NULL && direction == PF_IN)) {
d1912 2
a1913 2
	if (((*rm != NULL) && (*rm)->keep_state) || nat != NULL ||
	    binat != NULL || rdr != NULL) {
d1940 1
a1940 1
			if (nat != NULL || binat != NULL) {
d1953 1
a1953 1
			if (binat != NULL ||rdr != NULL) {
d2007 1
a2007 3
	struct pf_nat *nat = NULL;
	struct pf_binat *binat = NULL;
	struct pf_rdr *rdr = NULL;
d2024 4
a2027 3
		/* check outgoing packet for BINAT */
		if ((binat = pf_get_binat(PF_OUT, ifp, IPPROTO_UDP,
		    saddr, daddr, &naddr, af)) != NULL) {
d2033 5
a2037 3
		/* check outgoing packet for NAT */
		else if ((nat = pf_get_nat(ifp, IPPROTO_UDP,
		    saddr, uh->uh_sport, daddr, uh->uh_dport,
a2038 18
			PF_ACPY(&baddr, saddr, af);
			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &naddr, htons(nport),
			    1, af);
			rewrite++;
		}
	} else {
		/* check incoming packet for RDR */
		if ((rdr = pf_get_rdr(ifp, IPPROTO_UDP, saddr, daddr,
		    uh->uh_dport, &naddr, af)) != NULL) {
			bport = uh->uh_dport;
			if (rdr->opts & PF_RPORT_RANGE)
				nport = pf_map_port_range(rdr, uh->uh_dport);
			else if (rdr->rport)
				nport = rdr->rport;
			else
				nport = bport;

a2043 9
		/* check incoming packet for BINAT */
		else if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_UDP,
		    daddr, saddr, &naddr, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
			bport = uh->uh_dport;
			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &naddr, uh->uh_dport, 1, af);
			rewrite++;
		}
d2046 1
a2046 1
	r = TAILQ_FIRST(pf_main_ruleset.rules.active.ptr);
d2107 1
a2107 1
				    rules);
d2110 2
a2111 1
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset, rules);
d2133 1
a2133 2
			if (nat != NULL ||
			    (binat != NULL && direction == PF_OUT)) {
d2137 1
a2137 2
			} else if (rdr != NULL ||
			    (binat != NULL && direction == PF_IN)) {
d2154 2
a2155 2
	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL ||
	    binat != NULL || rdr != NULL) {
d2178 1
a2178 1
			if (nat != NULL || binat != NULL) {
d2190 1
a2190 1
			if (binat != NULL || rdr != NULL) {
d2230 1
a2230 3
	struct pf_nat *nat = NULL;
	struct pf_binat *binat = NULL;
	struct pf_rdr *rdr = NULL;
d2276 3
a2278 3
		/* check outgoing packet for BINAT */
		if ((binat = pf_get_binat(PF_OUT, ifp, IPPROTO_ICMP,
		    saddr, daddr, &naddr, af)) != NULL) {
a2295 20
		/* check outgoing packet for NAT */
		else if ((nat = pf_get_nat(ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&saddr->v4.s_addr,
				    pd->ip_sum, naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				pf_change_a6(saddr, &pd->hdr.icmp6->icmp6_cksum,
				    &naddr, 0);
				rewrite++;
				break;
#endif /* INET6 */
			}
		}
d2297 3
a2299 23
		/* check incoming packet for RDR */
		if ((rdr = pf_get_rdr(ifp, pd->proto,
		    saddr, daddr, 0, &naddr, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&daddr->v4.s_addr,
				    pd->ip_sum, naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				pf_change_a6(daddr, &pd->hdr.icmp6->icmp6_cksum,
				    &naddr, 0);
				rewrite++;
				break;
#endif /* INET6 */
			}
		}
		/* check incoming packet for BINAT */
		else if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_ICMP,
		    daddr, saddr, &naddr, af)) != NULL) {
d2319 1
a2319 1
	r = TAILQ_FIRST(pf_main_ruleset.rules.active.ptr);
d2364 1
a2364 1
				    rules);
d2367 2
a2368 1
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset, rules);
d2394 1
a2394 1
	    nat != NULL || rdr != NULL || binat != NULL)) {
d2417 1
a2417 1
			if (nat != NULL || binat != NULL)
d2427 1
a2427 1
			if (binat != NULL || rdr != NULL)
d2468 1
a2470 3
	struct pf_nat *nat = NULL;
	struct pf_binat *binat = NULL;
	struct pf_rdr *rdr = NULL;
d2479 3
a2481 3
		/* check outgoing packet for BINAT */
		if ((binat = pf_get_binat(PF_OUT, ifp, pd->proto,
		    saddr, daddr, &naddr, af)) != NULL) {
a2496 18
		/* check outgoing packet for NAT */
		else if ((nat = pf_get_nat(ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&saddr->v4.s_addr,
				    pd->ip_sum, naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(saddr, &naddr, af);
				break;
#endif /* INET6 */
			}
		}
d2498 3
a2500 22
		/* check incoming packet for RDR */
		if ((rdr = pf_get_rdr(ifp, pd->proto,
		    saddr, daddr, 0, &naddr, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&daddr->v4.s_addr,
				    pd->ip_sum, naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(daddr, &naddr, af);
				break;
#endif /* INET6 */
			}
		}
		/* check incoming packet for BINAT */
		else if ((binat = pf_get_binat(PF_IN, ifp, pd->proto,
		    daddr, saddr, &naddr, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
d2517 1
a2517 1
	r = TAILQ_FIRST(pf_main_ruleset.rules.active.ptr);
d2558 1
a2558 1
				    rules);
d2561 2
a2562 1
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset, rules);
d2581 1
a2581 1
	    rdr != NULL || binat != NULL) {
d2604 1
a2604 1
			if (nat != NULL || binat != NULL)
d2614 1
a2614 1
			if (binat != NULL || rdr != NULL)
d2657 1
a2657 1
	r = TAILQ_FIRST(pf_main_ruleset.rules.active.ptr);
d2699 1
a2699 1
				    rules);
d2702 2
a2703 1
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset, rules);
d3775 1
a3775 1
		if (!TAILQ_EMPTY(&r->rt_pool.list)) {
d3777 1
a3777 1
				pf_map_addr(AF_INET, &r->rt_pool,
d3782 1
a3782 1
				ifp = r->rt_pool.cur->ifp;
d3785 2
a3786 2
					s->rt_ifp = r->rt_pool.cur->ifp;
					pf_map_addr(AF_INET, &r->rt_pool,
d3924 1
a3924 1
	if (!TAILQ_EMPTY(&r->rt_pool.list)) {
d3926 1
a3926 1
			pf_map_addr(AF_INET6, &r->rt_pool,
d3933 1
a3933 1
			ifp = r->rt_pool.cur->ifp;
d3936 2
a3937 2
				s->rt_ifp = r->rt_pool.cur->ifp;
				pf_map_addr(AF_INET6, &r->rt_pool,
@


1.269
log
@Introduce anchors and named rule sets, allowing to load additional rule
sets with pfctl and evaluate them from the main rule set using a new type
of rule (which will support conditional evaluation soon). Makes
maintenance of sub-rulesets simpler for pfctl and daemons.

Idea and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.268 2002/12/03 15:52:33 mickey Exp $ */
d4353 4
a4356 1
			atag->qid = r->qid;
@


1.268
log
@no need to mh_align (while it's wrong), cleaner mtu setting; dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.267 2002/12/01 19:54:32 mcbride Exp $ */
d94 4
a97 9
struct pf_rulequeue	 pf_rules[2];
struct pf_rulequeue	*pf_rules_active;
struct pf_rulequeue	*pf_rules_inactive;
struct pf_natqueue	*pf_nats_active;
struct pf_natqueue	*pf_nats_inactive;
struct pf_binatqueue	*pf_binats_active;
struct pf_binatqueue	*pf_binats_inactive;
struct pf_rdrqueue	*pf_rdrs_active;
struct pf_rdrqueue	*pf_rdrs_inactive;
a102 8
u_int32_t		 ticket_rules_active;
u_int32_t		 ticket_rules_inactive;
u_int32_t		 ticket_nats_active;
u_int32_t		 ticket_nats_inactive;
u_int32_t		 ticket_binats_active;
u_int32_t		 ticket_binats_inactive;
u_int32_t		 ticket_rdrs_active;
u_int32_t		 ticket_rdrs_inactive;
d138 2
a139 1
				&pftm_other_multiple, &pftm_frag, &pftm_interval };
d198 3
a200 2
int			 pf_test_fragment(struct pf_rule **, int, struct ifnet *,
			    struct mbuf *, void *, struct pf_pdesc *);
d237 2
a238 2
struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] = { { &pf_state_pl, UINT_MAX },
	{ &pf_frent_pl, PFFRAG_FRENT_HIWAT } };
a257 7
struct pf_rulequeue		 pf_rules[2];
struct pf_natqueue		 pf_nats[2];
struct pf_binatqueue		 pf_binats[2];
struct pf_rdrqueue		 pf_rdrs[2];
struct pf_altqqueue		 pf_altqs[2];
struct pf_palist		 pf_pabuf[2];

d741 4
a744 2
			    PF_AEQ(&s->src.addr.addr, &r->src.addr.addr, r->af) &&
			    PF_AEQ(&s->src.addr.mask, &r->src.addr.mask, r->af) &&
d753 4
a756 2
			    PF_AEQ(&s->dst.addr.addr, &r->dst.addr.addr, r->af) &&
			    PF_AEQ(&s->dst.addr.mask, &r->dst.addr.mask, r->af) &&
d768 34
d916 1
a916 1
	/* Change inner ip address, fix inner ipv4 checksum and icmp checksum. */
d1257 31
d1586 2
a1587 1
	struct pf_nat *n, *nm = NULL;
d1589 1
a1589 1
	n = TAILQ_FIRST(pf_nats_active);
d1610 8
a1617 3
		    n->dst.port[1], dport)))
			nm = n;
		else
d1619 2
d1647 2
a1648 1
	struct pf_binat *b, *bm = NULL;
d1650 1
a1650 1
	b = TAILQ_FIRST(pf_binats_active);
d1652 8
a1659 1
		if (direction == PF_OUT && b->ifp == ifp &&
d1662 3
a1664 3
		    (b->saddr.addr_dyn == NULL ||
		    !b->saddr.addr_dyn->undefined) &&
		    PF_MATCHA(0, &b->saddr.addr, &b->saddr.mask, saddr, af) &&
d1668 8
a1675 14
			daddr, af))
			bm = b;
		else if (direction == PF_IN && b->ifp == ifp &&
		    (!b->proto || b->proto == proto) &&
		    (!b->af || b->af == af) &&
		    (b->raddr.addr_dyn == NULL ||
		    !b->raddr.addr_dyn->undefined) &&
		    PF_MATCHA(0, &b->raddr.addr, &b->raddr.mask, saddr, af) &&
		    (b->daddr.addr_dyn == NULL ||
		    !b->daddr.addr_dyn->undefined) &&
		    PF_MATCHA(b->dnot, &b->daddr.addr, &b->daddr.mask,
			daddr, af))
			bm = b;
		else
d1677 2
d1712 2
a1713 1
	struct pf_rdr *r, *rm = NULL;
d1715 1
a1715 1
	r = TAILQ_FIRST(pf_rdrs_active);
d1731 8
a1738 3
		    ntohs(dport) <= ntohs(r->dport2))))
			rm = r;
		else
d1740 2
d1829 2
a1830 1
	struct pf_rule *r;
d1883 1
a1883 1
	r = TAILQ_FIRST(pf_rules_active);
d1891 1
a1891 1
		else if (r->direction != direction)
d1922 4
a1925 3
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP, pd),
		    1)) && !pf_match_uid(r->uid.op, r->uid.uid[0],
		    r->uid.uid[1], uid))
d1928 6
a1933 3
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP, pd),
		    1)) && !pf_match_gid(r->gid.op, r->gid.gid[0],
		    r->gid.gid[1], gid))
d1936 9
a1944 4
			*rm = r;
			if ((*rm)->quick)
				break;
			r = TAILQ_NEXT(r, entries);
d1946 2
d1953 4
d2011 2
a2012 2
		if (*rm != NULL)
			(*rm)->states++;
d2014 1
a2014 1
		s->rule.ptr = *rm;
d2102 2
a2103 1
	struct pf_rule *r;
d2157 1
a2157 1
	r = TAILQ_FIRST(pf_rules_active);
d2165 1
a2165 1
		else if (r->direction != direction)
d2196 4
a2199 3
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP, pd),
		    1)) && !pf_match_uid(r->uid.op, r->uid.uid[0],
		    r->uid.uid[1], uid))
d2202 6
a2207 3
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP, pd),
		    1)) && !pf_match_gid(r->gid.op, r->gid.gid[0],
		    r->gid.gid[1], gid))
d2210 9
a2218 4
			*rm = r;
			if ((*rm)->quick)
				break;
			r = TAILQ_NEXT(r, entries);
d2220 2
d2227 4
d2276 2
a2277 2
		if (*rm != NULL)
			(*rm)->states++;
d2279 1
a2279 1
		s->rule.ptr = *rm;
d2346 2
a2347 1
	struct pf_rule *r;
d2473 1
a2473 1
	r = TAILQ_FIRST(pf_rules_active);
d2481 1
a2481 1
		else if (r->direction != direction)
d2507 2
d2510 9
a2518 4
			*rm = r;
			if ((*rm)->quick)
				break;
			r = TAILQ_NEXT(r, entries);
d2520 2
d2527 4
d2556 2
a2557 2
		if (*rm != NULL)
			(*rm)->states++;
d2559 1
a2559 1
		s->rule.ptr = *rm;
d2621 2
a2622 1
	struct pf_rule *r;
d2709 1
a2709 1
	r = TAILQ_FIRST(pf_rules_active);
d2717 1
a2717 1
		else if (r->direction != direction)
d2739 2
d2742 9
a2750 4
			*rm = r;
			if ((*rm)->quick)
				break;
			r = TAILQ_NEXT(r, entries);
d2752 2
d2759 4
d2781 2
a2782 2
		if (*rm != NULL)
			(*rm)->states++;
d2784 1
a2784 1
		s->rule.ptr = *rm;
d2842 2
a2843 1
	struct pf_rule *r;
d2848 1
a2848 1
	r = TAILQ_FIRST(pf_rules_active);
d2856 1
a2856 1
		else if (r->direction != direction)
d2879 2
d2882 9
a2890 4
			*rm = r;
			if ((*rm)->quick)
				break;
			r = TAILQ_NEXT(r, entries);
d2892 2
d2901 4
d3405 2
a3406 1
				    ("pf: ICMP error message too short (ip)\n"));
d3409 4
a3412 1
			/* ICMP error messages don't refer to non-first fragments */
d3432 2
a3433 1
				    ("pf: ICMP error message too short (ip6)\n"));
d3493 2
a3494 1
				    ("pf: ICMP error message too short (tcp)\n"));
d3583 2
a3584 1
				    ("pf: ICMP error message too short (udp)\n"));
d3649 2
a3650 1
				    ("pf: ICMP error message too short (icmp)\n"));
d3702 2
a3703 1
				    ("pf: ICMP error message too short (icmp6)\n"));
d3809 2
a3810 1
				    pd->ip_sum, (*state)->gwy.addr.v4.s_addr, 0);
d3824 2
a3825 1
				    pd->ip_sum, (*state)->lan.addr.v4.s_addr, 0);
d4331 2
a4332 2
		pf_status.bcounters[0][dir] += pd.tot_len;
		pf_status.pcounters[0][dir][action]++;
d4528 2
a4529 2
		pf_status.bcounters[1][dir] += pd.tot_len;
		pf_status.pcounters[1][dir][action]++;
@


1.267
log
@- Clean up pf_ioctl mainly by adding new functions to handle cleaning and
  freeing rules. Fixes a number of potential memory leaks and other bugs.
- Add new pool_ticket to insure that address pools don't get messed
  with by someone else while we add rules.
- Add a second address pool buffer, so that DIOCCHANGE* operations which use
  pf_compare* will work correctly.

Excellent bug report and anaylsis from DJ Gregor.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.266 2002/12/01 01:20:02 mcbride Exp $ */
d450 1
a450 1
	/* pfsync_insert_state(state); */
d498 1
a498 1
			/* pfsync_delete_state(cur->state); */
@


1.266
log
@pfsync currently causes kernel faults, so we don't want to call these functions

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.265 2002/11/29 18:25:22 mickey Exp $ */
d274 1
a274 1
struct pf_palist		 pf_pabuf;
@


1.265
log
@expose state table changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.264 2002/11/28 12:07:37 mcbride Exp $ */
d450 1
a450 1
	pfsync_insert_state(state);
d498 1
a498 1
			pfsync_delete_state(cur->state);
@


1.264
log
@- MD5 too slow, replace with pf_hash (based on hash from if_bridge.c)
- Always fold the key in

Many fixes & suggestions from camield@@

ok mickey@@ camield@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.263 2002/11/24 22:45:48 mcbride Exp $ */
d39 1
a54 1
#include <net/if_pflog.h>
d73 2
d449 3
d497 3
@


1.263
log
@move } outside #ifdef INET6

unbreaks compiling kernel without IPv6 support.
how embarassing, spotted by Chris Kuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.262 2002/11/23 09:37:01 deraadt Exp $ */
a48 1
#include <sys/md5k.h>
d229 2
d1286 57
a1346 1
	MD5_CTX context;
d1399 1
a1399 22
	case PF_POOL_SRCKEYHASH:
		bzero(&context, sizeof(context));
		MD5Init(&context);
		switch (af) {
#ifdef INET
		case AF_INET:
			MD5Update(&context, (unsigned char *)&saddr->v4,
			    sizeof(saddr->v4));
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			MD5Update(&context, (unsigned char *)&saddr->v6,
			    sizeof(saddr->v6));
			break;
#endif /* INET6 */
		}
		if ((rpool->opts & PF_POOL_TYPEMASK) ==
		    PF_POOL_SRCKEYHASH)
			MD5Update(&context, (unsigned char *)&rpool->key,
			    sizeof(rpool->key));
		MD5Final(hash, &context);
d1422 1
a1422 1
        }
a1511 1
		case PF_POOL_SRCKEYHASH:
@


1.262
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.261 2002/11/23 05:48:01 mcbride Exp $ */
d1331 1
a1332 1
#endif /* INET6 */
@


1.261
log
@pass a pointer to the hash, not the first chunk of it
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.260 2002/11/23 05:16:58 mcbride Exp $ */
d159 2
a160 2
int		 	 pf_insert_state(struct pf_state *);
struct pf_state 	*pf_find_state(struct pf_state_tree *,
d741 1
a741 1
			PF_CALC_SKIP_STEP(PF_SKIP_IFP, 
d1237 1
a1237 1
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]); 
d1242 1
a1242 1
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]); 
d1244 1
a1244 1
		((rmask->addr32[1] ^ 0xffffffff ) & saddr->addr32[1]); 
d1246 1
a1246 1
		((rmask->addr32[2] ^ 0xffffffff ) & saddr->addr32[2]); 
d1248 1
a1248 1
		((rmask->addr32[3] ^ 0xffffffff ) & saddr->addr32[3]); 
d1259 1
a1259 1
		addr->addr32[0] = htonl(ntohl(addr->addr32[0]) + 1); 
d1270 2
a1271 2
			  		    htonl(ntohl(addr->addr32[0]) + 1); 
				} else 
d1276 1
a1276 1
				    htonl(ntohl(addr->addr32[2]) + 1); 
d1279 1
a1279 2
			    htonl(ntohl(addr->addr32[3]) + 1); 
		
d1294 2
a1295 2
	
 	if (cur->addr.addr_dyn != NULL && cur->addr.addr_dyn->undefined)
d1304 1
a1304 1
		PF_POOLMASK(naddr, raddr, rmask, saddr, af); 
d1310 1
a1310 1
			case AF_INET: 
d1312 1
a1312 1
				break;	
d1315 2
a1316 2
			case AF_INET6: 
				if (rmask->addr32[3] != 0xffffffff) 
d1320 1
a1320 1
				if (rmask->addr32[2] != 0xffffffff) 
d1324 1
a1324 1
				if (rmask->addr32[1] != 0xffffffff) 
d1328 1
a1328 1
				if (rmask->addr32[0] != 0xffffffff) 
d1330 1
a1330 1
				break;	
d1333 1
a1333 1
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af); 
d1338 1
a1338 1
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af); 
d1347 1
a1347 1
		case AF_INET: 
d1350 1
a1350 1
			break;  
d1353 1
a1353 1
		case AF_INET6: 
d1356 1
a1356 1
			break;  
d1364 1
a1364 1
		PF_POOLMASK(naddr, raddr, rmask, (struct pf_addr *)&hash, af); 
d1368 1
a1368 1
		    &rpool->counter, af)) {	
d1415 3
a1417 3
		/* 
		 * port search; start random, step; 
		 * similar 2 portloop in in_pcbbind 
d1421 1
a1421 1
			if (pf_find_state(&tree_ext_gwy, &key) == NULL) 
d1423 1
a1423 1
		} else if (rpool->opts & PF_POOL_STATICPORT) { 
d1524 1
a1524 1
			if (pf_get_sport(af, proto, 
d1585 1
a1585 1
				    &bm->raddr.mask, saddr, af); 
d1593 1
a1593 1
				    &bm->saddr.mask, saddr, af); 
d1597 1
a1597 1
	
d1863 1
a1863 1
		if ((*rm)->action == PF_DROP) 
d2093 1
a2093 1
		if (((*rm)->action == PF_DROP) && 
d2116 1
a2116 1
		if ((*rm)->action == PF_DROP) 
d3773 1
a3773 1
 				ifp = r->rt_pool.cur->ifp;
d3776 1
a3776 1
 					s->rt_ifp = r->rt_pool.cur->ifp;
d3780 1
a3780 1
					if (!PF_AZERO(&naddr, AF_INET)) 
d3783 1
a3783 1
				} 
d3924 1
a3924 1
 			ifp = r->rt_pool.cur->ifp;
d3927 1
a3927 1
 				s->rt_ifp = r->rt_pool.cur->ifp;
d3931 1
a3931 1
				if (!PF_AZERO(&naddr, AF_INET6)) 
d3933 1
a3933 1
			} 
d4175 1
a4175 1
	if (r && r->rt) 
@


1.260
log
@kernel code to allow multiple redirection addresses to be specified for nat
and rdr, as well as route-to, dup-to and reply-to.

Addresses can be allocated in a number of ways:
- masking out the network portion of the address and replacing it
- randomly assigning an address in the block
- hashing the source address and a key to determine the redirection address
- iterating through the addresses sequentially (this is the only allocation
  scheme which works when a list of addresses is specified)

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.259 2002/11/22 09:54:35 henning Exp $ */
d1365 1
a1365 1
		PF_POOLMASK(naddr, raddr, rmask, (struct pf_addr *)hash, af); 
@


1.259
log
@on block rules, let queue apply to the RST packets in the return-rst case
and the returned icmp packets in the return-icmp case

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.258 2002/10/29 19:51:04 mickey Exp $ */
d49 1
d117 1
d155 1
a155 1
struct pool		 pf_altq_pl;
d193 2
a194 1
			    struct pf_addr *, u_int16_t, sa_family_t);
d200 1
a200 1
			    sa_family_t);
d227 2
a228 1
			    struct pf_addr *, struct pf_addr *, sa_family_t);
d230 3
d234 3
a236 2
			    struct pf_addr *, struct pf_addr *,
			    u_int16_t, u_int16_t *, u_int16_t, u_int16_t);
d240 1
a240 1
			    struct ifnet *);
d242 1
a242 1
			    struct ifnet *);
d271 1
d751 1
a751 1
			    PF_AEQ(&s->src.mask, &r->src.mask, r->af) &&
d761 1
a761 1
			    PF_AEQ(&s->dst.mask, &r->dst.mask, r->af) &&
d1252 32
d1287 110
a1396 3
pf_get_sport(sa_family_t af, u_int8_t proto,
    struct pf_addr *daddr, struct pf_addr *raddr,
    u_int16_t dport, u_int16_t *port, u_int16_t low, u_int16_t high)
d1399 1
d1404 2
a1405 24
	if (!(proto == IPPROTO_TCP || proto == IPPROTO_UDP))
		return (EINVAL);
	if (low == 0 && high == 0) {
		NTOHS(*port);
		return (0);
	}
	if (low == high) {
		*port = low;
		return (0);
	}

	key.af = af;
	key.proto = proto;
	PF_ACPY(&key.addr[0], daddr, key.af);
	PF_ACPY(&key.addr[1], raddr, key.af);
	key.port[0] = dport;

	/* port search; start random, step; similar 2 portloop in in_pcbbind */
	if (low == high) {
		key.port[1] = htons(low);
		if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
			*port = low;
			return (0);
		}
a1406 7
	} else if (low < high) {
		step = 1;
		cut = arc4random() % (1 + high - low) + low;
	} else {
		step = -1;
		cut = arc4random() % (1 + low - high) + high;
	}
a1407 1
	*port = cut - step;
a1408 5
		*port += step;
		key.port[1] = htons(*port);
		if (pf_find_state(&tree_ext_gwy, &key) == NULL)
			return (0);
	} while (*port != low && *port != high);
d1410 74
a1483 8
	step = -step;
	*port = cut;
	do {
		*port += step;
		key.port[1] = htons(*port);
		if (pf_find_state(&tree_ext_gwy, &key) == NULL)
			return (0);
	} while (*port != low && *port != high);
d1490 2
a1491 1
    u_int16_t sport, struct pf_addr *daddr, u_int16_t dport, sa_family_t af)
d1503 1
a1503 1
		    PF_MATCHA(n->src.not, &n->src.addr.addr, &n->src.mask,
d1511 1
a1511 1
		    PF_MATCHA(n->dst.not, &n->dst.addr.addr, &n->dst.mask,
d1521 17
a1537 3
	if (nm && (nm->no || (nm->raddr.addr_dyn != NULL &&
	    nm->raddr.addr_dyn->undefined)))
		return (NULL);
d1555 1
a1555 1
		    PF_MATCHA(0, &b->saddr.addr, &b->smask, saddr, af) &&
d1558 2
a1559 1
		    PF_MATCHA(b->dnot, &b->daddr.addr, &b->dmask, daddr, af))
d1566 1
a1566 1
		    PF_MATCHA(0, &b->raddr.addr, &b->rmask, saddr, af) &&
d1569 2
a1570 1
		    PF_MATCHA(b->dnot, &b->daddr.addr, &b->dmask, daddr, af))
d1575 1
d1586 1
a1586 1
				    &bm->rmask, saddr, af); 
d1594 1
a1594 1
				    &bm->smask, saddr, af); 
d1598 1
a1598 1

d1604 2
a1605 1
    struct pf_addr *daddr, u_int16_t dport, sa_family_t af)
d1617 2
a1618 1
		    PF_MATCHA(r->snot, &r->saddr.addr, &r->smask, saddr, af) &&
d1621 2
a1622 1
		    PF_MATCHA(r->dnot, &r->daddr.addr, &r->dmask, daddr, af) &&
d1630 6
a1635 3
	if (rm && (rm->no || (rm->raddr.addr_dyn != NULL &&
	    rm->raddr.addr_dyn->undefined)))
		return (NULL);
d1718 1
a1718 1
	int rewrite = 0, error;
d1723 1
a1727 1
			bport = th->th_sport;
d1734 2
a1735 12
		    saddr, th->th_sport, daddr, th->th_dport, af)) != NULL) {
			bport = nport = th->th_sport;
			error = pf_get_sport(af, IPPROTO_TCP, daddr,
			    &nat->raddr.addr, th->th_dport, &nport,
			    nat->proxy_port[0], nat->proxy_port[1]);
			if (error) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: NAT proxy port allocation "
				    "(tcp %u-%u) failed\n",
				    nat->proxy_port[0], nat->proxy_port[1]));
				return (PF_DROP);
			}
d1738 1
a1738 1
			    &th->th_sum, &nat->raddr.addr, htons(nport),
d1745 1
a1745 1
		    th->th_dport, af)) != NULL) {
d1755 1
a1755 1
			    &th->th_sum, &rdr->raddr.addr, nport, 0, af);
d1786 2
a1787 2
		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.mask, saddr, af))
d1795 2
a1796 2
		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.mask, daddr, af))
d1975 1
a1975 1
	int rewrite = 0, error;
d1980 1
a1984 1
			bport = uh->uh_sport;
d1991 2
a1992 12
		    saddr, uh->uh_sport, daddr, uh->uh_dport, af)) != NULL) {
			bport = nport = uh->uh_sport;
			error = pf_get_sport(af, IPPROTO_UDP, daddr,
			    &nat->raddr.addr, uh->uh_dport, &nport,
			    nat->proxy_port[0], nat->proxy_port[1]);
			if (error) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: NAT proxy port allocation "
				    "(udp %u-%u) failed\n",
				    nat->proxy_port[0], nat->proxy_port[1]));
				return (PF_DROP);
			}
d1995 1
a1995 1
			    &uh->uh_sum, &nat->raddr.addr, htons(nport),
d2002 1
a2002 1
		    uh->uh_dport, af)) != NULL) {
d2013 1
a2013 1
			    &uh->uh_sum, &rdr->raddr.addr, nport, 1, af);
d2044 2
a2045 2
		    !PF_AZERO(&r->src.mask, af) &&
		    !PF_MATCHA(r->src.not, &r->src.addr.addr, &r->src.mask,
d2054 2
a2055 2
		    !PF_AZERO(&r->dst.mask, af) &&
		    !PF_MATCHA(r->dst.not, &r->dst.addr.addr, &r->dst.mask,
d2266 1
a2266 1
		    saddr, 0, daddr, 0, af)) != NULL) {
d2272 1
a2272 1
				    pd->ip_sum, nat->raddr.addr.v4.s_addr, 0);
d2278 1
a2278 1
				    &nat->raddr.addr, 0);
d2287 1
a2287 1
		    saddr, daddr, 0, af)) != NULL) {
d2293 1
a2293 1
				    pd->ip_sum, rdr->raddr.addr.v4.s_addr, 0);
d2299 1
a2299 1
				    &rdr->raddr.addr, 0);
d2344 2
a2345 2
		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.mask, saddr, af))
d2350 2
a2351 2
		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.mask, daddr, af))
d2494 1
a2494 1
		    saddr, 0, daddr, 0, af)) != NULL) {
d2500 1
a2500 1
				    pd->ip_sum, nat->raddr.addr.v4.s_addr, 0);
d2505 1
a2505 1
				PF_ACPY(saddr, &nat->raddr.addr, af);
d2513 1
a2513 1
		    saddr, daddr, 0, af)) != NULL) {
d2519 1
a2519 1
				    pd->ip_sum, rdr->raddr.addr.v4.s_addr, 0);
d2524 1
a2524 1
				PF_ACPY(daddr, &rdr->raddr.addr, af);
d2566 2
a2567 2
		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.mask, pd->src, af))
d2572 2
a2573 2
		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.mask, pd->dst, af))
d2691 2
a2692 2
		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.mask, pd->src, af))
d2697 2
a2698 2
		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.mask, pd->dst, af))
d3720 2
a3721 1
pf_route(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp)
d3728 1
a3728 1
	struct ifnet *ifp = r->rt_ifp;
d3730 1
d3767 24
a3790 2
		if (!PF_AZERO(&r->rt_addr, AF_INET))
			dst->sin_addr.s_addr = r->rt_addr.v4.s_addr;
d3881 2
a3882 1
pf_route6(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp)
d3890 2
a3891 1
	struct ifnet *ifp = r->rt_ifp;
d3916 27
a3942 2
	if (!PF_AZERO(&r->rt_addr, AF_INET6))
		dst->sin6_addr = r->rt_addr.v6;
d4176 2
a4177 2
	if (r && r->rt)
		pf_route(m0, r, dir, ifp);
d4350 1
a4350 1
		pf_route6(m0, r, dir, ifp);
@


1.258
log
@keep all pflog goodies in pflog sources, avoids code duplications; okski frantzen@@ and dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.257 2002/10/22 12:23:35 mcbride Exp $ */
d184 2
a185 1
			    struct pf_pdesc *, sa_family_t, u_int8_t);
d187 1
a187 1
			    sa_family_t);
d937 1
a937 1
    u_int8_t return_ttl)
d1027 16
d1079 2
a1080 1
pf_send_icmp(struct mbuf *m, u_int8_t type, u_int8_t code, sa_family_t af)
d1094 17
d1661 1
a1661 1
				    (*rm)->return_ttl);
d1664 1
a1664 1
				    (*rm)->return_icmp & 255, af);
d1667 1
a1667 1
				    (*rm)->return_icmp6 & 255, af);
d1927 1
a1927 1
				    (*rm)->return_icmp & 255, af);
d1930 1
a1930 1
				    (*rm)->return_icmp6 & 255, af);
d3913 1
a3913 1
	if (action != PF_DROP && r && r->qid) {
@


1.257
log
@Convert "int af" and "u_int8_t af" declarations and function arguments
to the more correct and descriptive "sa_family_t af"

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.256 2002/10/20 13:08:29 mcbride Exp $ */
d37 3
a73 3
#include "bpfilter.h"
#include "pflog.h"

a239 18

#if NPFLOG > 0
#define	PFLOG_PACKET(i,x,a,b,c,d,e) \
	do { \
		if (b == AF_INET) { \
			HTONS(((struct ip *)x)->ip_len); \
			HTONS(((struct ip *)x)->ip_off); \
			pflog_packet(i,a,b,c,d,e); \
			NTOHS(((struct ip *)x)->ip_len); \
			NTOHS(((struct ip *)x)->ip_off); \
		} else { \
			pflog_packet(i,a,b,c,d,e); \
		} \
	} while (0)
#else
#define	PFLOG_PACKET(i,x,a,b,c,d,e)	((void)0)
#endif

a349 43

int
pflog_packet(struct ifnet *ifp, struct mbuf *m, sa_family_t af, u_short dir,
    u_short reason, struct pf_rule *rm)
{
#if NBPFILTER > 0
	struct ifnet *ifn;
	struct pfloghdr hdr;
	struct mbuf m1;

	if (ifp == NULL || m == NULL || rm == NULL)
		return (-1);

	hdr.af = htonl(af);
	memcpy(hdr.ifname, ifp->if_xname, sizeof(hdr.ifname));

	hdr.rnr = htons(rm->nr);
	hdr.reason = htons(reason);
	hdr.dir = htons(dir);
	hdr.action = htons(rm->action);

#ifdef INET
	if (af == AF_INET && dir == PF_OUT) {
		struct ip *ip;

		ip = mtod(m, struct ip *);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	}
#endif /* INET */

	m1.m_next = m;
	m1.m_len = PFLOG_HDRLEN;
	m1.m_data = (char *) &hdr;

	ifn = &(pflogif[0].sc_if);

	if (ifn->if_bpf)
		bpf_mtap(ifn->if_bpf, &m1);
#endif

	return (0);
}
@


1.256
log
@Move pf_compare_(rules|nats|binats|rdrs) to pf_ioctl.c. Simplifies and
reduces cross-file dependancies.

ok dhartmei@@ ish@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.255 2002/10/14 12:58:27 henning Exp $ */
d156 1
a156 1
			    u_int8_t);
d172 1
a172 1
			    u_int16_t, u_int8_t, int);
d182 1
a182 1
			    u_int16_t *, u_int8_t, int);
d184 3
a186 2
			    struct pf_pdesc *, int, u_int8_t);
void			 pf_send_icmp(struct mbuf *, u_int8_t, u_int8_t, int);
d190 1
a190 1
			    struct pf_addr *, u_int16_t, int);
d193 1
a193 1
			    struct pf_addr *, int);
d195 2
a196 1
			    struct pf_addr *, struct pf_addr *, u_int16_t, int);
d219 1
a219 1
			    u_short *, u_short *, int);
d223 1
a223 1
			    struct pf_addr *, struct pf_addr *, u_int8_t);
d225 1
a225 1
int			 pf_get_sport(u_int8_t, u_int8_t,
d234 2
a235 2
int			 pf_socket_lookup(uid_t *, gid_t *, int, int, int,
			     struct pf_pdesc *);
d351 1
a351 1
pf_addrcpy(struct pf_addr *dst, struct pf_addr *src, u_int8_t af)
d370 1
a370 1
pflog_packet(struct ifnet *ifp, struct mbuf *m, int af, u_short dir,
d554 1
a554 1
pf_dynaddr_setup(struct pf_addr_wrap *aw, u_int8_t af)
d651 1
a651 1
pf_print_host(struct pf_addr *addr, u_int16_t p, u_int8_t af)
d841 1
a841 1
    struct pf_addr *an, u_int16_t pn, u_int8_t u, int af)
d919 1
a919 1
    u_int16_t *ic, u_int16_t *hc, u_int8_t u, int af)
d996 1
a996 1
pf_send_reset(int off, struct tcphdr *th, struct pf_pdesc *pd, int af,
d1123 1
a1123 1
pf_send_icmp(struct mbuf *m, u_int8_t type, u_int8_t code, int af)
d1158 1
a1158 1
    struct pf_addr *b, int af)
d1248 1
a1248 1
    struct pf_addr *rmask, struct pf_addr *saddr, u_int8_t af)
d1272 1
a1272 1
pf_get_sport(u_int8_t af, u_int8_t proto,
d1336 1
a1336 1
    u_int16_t sport, struct pf_addr *daddr, u_int16_t dport, int af)
d1374 2
a1375 1
    struct pf_addr *saddr, struct pf_addr *daddr, struct pf_addr *naddr, int af)
d1432 1
a1432 1
    struct pf_addr *daddr, u_int16_t dport, int af)
d1474 2
a1475 2
pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, int af, int proto,
    struct pf_pdesc *pd)
d1533 2
a1534 1
	u_int16_t bport, nport = 0, af = pd->af;
d1800 2
a1801 1
	u_int16_t bport, nport = 0, af = pd->af;
d2045 2
a2046 1
	u_int16_t icmpid, af = pd->af;
d2309 1
a2309 1
	u_int8_t af = pd->af;
d2512 1
a2512 1
	u_int8_t af = pd->af;
d3493 1
a3493 1
    u_short *actionp, u_short *reasonp, int af)
d3539 1
a3539 1
	int af;
@


1.255
log
@Allow one to specify a netblock in a binat rule:

binat on fxp0 from 192.168.0.32/27 to any -> 10.0.7.128/27

Both the network mask on the source and redirect addresses MUST be the
same, and it works by essentially combining the network section of the
redirect address with the host section of the source address.

from ryan

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.254 2002/10/08 05:12:08 kjc Exp $ */
a156 6
int			 pf_compare_rules(struct pf_rule *,
			    struct pf_rule *);
int			 pf_compare_nats(struct pf_nat *, struct pf_nat *);
int			 pf_compare_binats(struct pf_binat *,
			    struct pf_binat *);
int			 pf_compare_rdrs(struct pf_rdr *, struct pf_rdr *);
a365 125

int
pf_compare_rules(struct pf_rule *a, struct pf_rule *b)
{
	if (a->return_icmp != b->return_icmp ||
	    a->return_icmp6 != b->return_icmp6 ||
	    a->action != b->action ||
	    a->direction != b->direction ||
	    a->log != b->log ||
	    a->quick != b->quick ||
	    a->keep_state != b->keep_state ||
	    a->af != b->af ||
	    a->proto != b->proto ||
	    a->type != b->type ||
	    a->code != b->code ||
	    a->flags != b->flags ||
	    a->flagset != b->flagset ||
	    a->rule_flag != b->rule_flag ||
	    a->min_ttl != b->min_ttl ||
	    a->tos != b->tos ||
	    a->allow_opts != b->allow_opts)
		return (1);
	if (PF_ANEQ(&a->src.addr.addr, &b->src.addr.addr, a->af) ||
	    PF_ANEQ(&a->src.mask, &b->src.mask, a->af) ||
	    a->src.port[0] != b->src.port[0] ||
	    a->src.port[1] != b->src.port[1] ||
	    a->src.not != b->src.not ||
	    a->src.port_op != b->src.port_op)
		return (1);
	if (PF_ANEQ(&a->dst.addr.addr, &b->dst.addr.addr, a->af) ||
	    PF_ANEQ(&a->dst.mask, &b->dst.mask, a->af) ||
	    a->dst.port[0] != b->dst.port[0] ||
	    a->dst.port[1] != b->dst.port[1] ||
	    a->dst.not != b->dst.not ||
	    a->dst.port_op != b->dst.port_op)
		return (1);
	if (strcmp(a->ifname, b->ifname))
		return (1);
	if (a->ifnot != b->ifnot)
		return (1);
	return (0);
}

int
pf_compare_nats(struct pf_nat *a, struct pf_nat *b)
{
	if (a->proto != b->proto ||
	    a->af != b->af ||
	    a->ifnot != b->ifnot ||
	    a->no != b->no)
		return (1);
	if (PF_ANEQ(&a->src.addr.addr, &b->src.addr.addr, a->af) ||
	    PF_ANEQ(&a->src.mask, &b->src.mask, a->af) ||
	    a->src.port[0] != b->src.port[0] ||
	    a->src.port[1] != b->src.port[1] ||
	    a->src.not != b->src.not ||
	    a->src.port_op != b->src.port_op)
		return (1);
	if (PF_ANEQ(&a->dst.addr.addr, &b->dst.addr.addr, a->af) ||
	    PF_ANEQ(&a->dst.mask, &b->dst.mask, a->af) ||
	    a->dst.port[0] != b->dst.port[0] ||
	    a->dst.port[1] != b->dst.port[1] ||
	    a->dst.not != b->dst.not ||
	    a->dst.port_op != b->dst.port_op)
		return (1);
	if (PF_ANEQ(&a->raddr.addr, &b->raddr.addr, a->af))
		return (1);
	if (strcmp(a->ifname, b->ifname))
		return (1);
	return (0);
}

int
pf_compare_binats(struct pf_binat *a, struct pf_binat *b)
{
	if (a->proto != b->proto ||
	    a->dnot != b->dnot ||
	    a->af != b->af ||
	    a->no != b->no)
		return (1);
	if (PF_ANEQ(&a->saddr.addr, &b->saddr.addr, a->af))
		return (1);
	if (PF_ANEQ(&a->smask, &b->smask, a->af))
		return (1);
	if (PF_ANEQ(&a->daddr.addr, &b->daddr.addr, a->af))
		return (1);
	if (PF_ANEQ(&a->dmask, &b->dmask, a->af))
		return (1);
	if (PF_ANEQ(&a->raddr.addr, &b->raddr.addr, a->af))
		return (1);
	if (PF_ANEQ(&a->rmask, &b->rmask, a->af))
		return (1);
	if (strcmp(a->ifname, b->ifname))
		return (1);
	return (0);
}

int
pf_compare_rdrs(struct pf_rdr *a, struct pf_rdr *b)
{
	if (a->dport != b->dport ||
	    a->dport2 != b->dport2 ||
	    a->rport != b->rport ||
	    a->proto != b->proto ||
	    a->af != b->af ||
	    a->snot != b->snot ||
	    a->dnot != b->dnot ||
	    a->ifnot != b->ifnot ||
	    a->opts != b->opts ||
	    a->no != b->no)
		return (1);
	if (PF_ANEQ(&a->saddr.addr, &b->saddr.addr, a->af))
		return (1);
	if (PF_ANEQ(&a->smask, &b->smask, a->af))
		return (1);
	if (PF_ANEQ(&a->daddr.addr, &b->daddr.addr, a->af))
		return (1);
	if (PF_ANEQ(&a->dmask, &b->dmask, a->af))
		return (1);
	if (PF_ANEQ(&a->raddr.addr, &b->raddr.addr, a->af))
		return (1);
	if (strcmp(a->ifname, b->ifname))
		return (1);
	return (0);
}
@


1.254
log
@the first step of pf/altq merge.
this commit is to allow further development in both userland and kernel.

the goal is to replace altq's classifier by pf(4).
- make pf tag a queue id to mbuf and make altq read the queue id
- merge altq config into pf.conf(5)

ok dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.253 2002/10/07 14:53:00 dhartmei Exp $ */
d197 2
a198 1
			    struct pf_addr *, struct pf_addr *, int);
d225 4
d454 2
d462 2
d1374 26
d1503 1
a1503 1
    struct pf_addr *saddr, struct pf_addr *daddr, int af)
a1505 3
	struct pf_addr fullmask;

	memset(&fullmask, 0xff, sizeof(fullmask));
d1514 1
a1514 1
		    PF_MATCHA(0, &b->saddr.addr, &fullmask, saddr, af) &&
d1524 1
a1524 1
		    PF_MATCHA(0, &b->raddr.addr, &fullmask, saddr, af) &&
d1532 23
a1554 8
	if (bm && bm->no)
		return (NULL);
	if (bm && direction == PF_OUT && bm->raddr.addr_dyn != NULL &&
	    bm->raddr.addr_dyn->undefined)
		return (NULL);
	if (bm && direction == PF_IN && bm->saddr.addr_dyn != NULL &&
	    bm->saddr.addr_dyn->undefined)
		return (NULL);
d1659 1
a1659 1
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
d1674 1
a1674 1
		    saddr, daddr, af)) != NULL) {
d1678 1
a1678 1
			    &th->th_sum, &binat->raddr.addr, th->th_sport, 0, af);
d1719 1
a1719 1
		    daddr, saddr, af)) != NULL) {
d1723 1
a1723 1
			    &th->th_sum, &binat->saddr.addr, th->th_dport, 0, af);
d1925 1
a1925 1
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
d1940 1
a1940 1
		    saddr, daddr, af)) != NULL) {
d1944 1
a1944 1
			    &uh->uh_sum, &binat->raddr.addr, uh->uh_sport, 1, af);
d1986 1
a1986 1
		    daddr, saddr, af)) != NULL) {
d1990 1
a1990 1
			    &uh->uh_sum, &binat->saddr.addr, uh->uh_dport, 1, af);
d2168 1
a2168 1
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
d2213 1
a2213 1
		    saddr, daddr, af)) != NULL) {
d2219 1
a2219 1
				    binat->raddr.addr.v4.s_addr, 0);
d2225 1
a2225 1
				    &binat->raddr.addr, 0);
d2274 1
a2274 1
		    daddr, saddr, af)) != NULL) {
d2280 1
a2280 1
				    pd->ip_sum, binat->saddr.addr.v4.s_addr, 0);
d2286 1
a2286 1
				    &binat->saddr.addr, 0);
d2433 1
a2433 1
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
d2443 1
a2443 1
		    saddr, daddr, af)) != NULL) {
d2449 1
a2449 1
				    binat->raddr.addr.v4.s_addr, 0);
d2454 1
a2454 1
				PF_ACPY(saddr, &binat->raddr.addr, af);
d2498 1
a2498 1
		    daddr, saddr, af)) != NULL) {
d2504 1
a2504 1
				    pd->ip_sum, binat->saddr.addr.v4.s_addr, 0);
d2509 1
a2509 1
				PF_ACPY(daddr, &binat->saddr.addr, af);
@


1.253
log
@-Wsign-compare clean
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.252 2002/10/07 13:23:45 henning Exp $ */
d80 4
d101 2
d114 2
d153 1
d278 1
d4015 17
@


1.252
log
@set block-policy [drop|return]
drop is default, same behaviour as before

support
block drop
to override a return policy
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.248 2002/10/07 12:39:29 dhartmei Exp $ */
d633 1
a633 1
		if (cur->state->expire <= time.tv_sec) {
d3590 2
a3591 1
		    (ntohs(h->ip6_plen) + sizeof(struct ip6_hdr)) < off + len) {
d3837 1
a3837 1
	if (m0->m_pkthdr.len <= ifp->if_mtu) {
d3880 1
a3880 1
	if (m->m_pkthdr.len < sizeof(*h)) {
d3896 1
a3896 1
	if (off < sizeof(*h)) {
d4046 1
a4046 1
	if (m->m_pkthdr.len < sizeof(*h)) {
@


1.251
log
@support a generic return
block return in|out ...
acts like return-rst on tcp, like return-icmp on udp and like an ordinary
block on anything else

ok dhartmei@@
@
text
@@


1.250
log
@make return-icmp work for rules covering both v4 and v6
-new field "return_icmp6" inpf_rule
-parser accepts
block return-icmp(ipv4-icmpcode, ipv6-icmpcode)

ok and some input dhartmei@@
@
text
@d1740 2
a1741 1
		    ((*rm)->rule_flag & PFRULE_RETURNICMP))) {
d1754 2
a1755 1
			if ((*rm)->rule_flag & PFRULE_RETURNRST)
d2006 2
a2007 1
		    ((*rm)->rule_flag & PFRULE_RETURNICMP)) {
@


1.249
log
@use a new rule_flag PFRULE_RETURNICMP to decide wether to return-icmp or not
instead of just testing return_icmp > 0

ok dhartmei@@
@
text
@d362 1
d1756 1
a1756 1
			else if ((*rm)->return_icmp)
d1759 3
d2017 1
a2017 1
			if ((*rm)->return_icmp)
d2020 3
@


1.248
log
@Add 'reply-to' to filter rules, similar to route-to, but applying to
replies (packets that flow in the opposite direction of the packet that
created state), used for symmetric routing enforcement.
Document how route-to and reply-to work in context of stateful filtering.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.247 2002/10/05 21:17:57 dhartmei Exp $ */
d1739 1
a1739 1
		    (*rm)->return_icmp)) {
d1755 1
a1755 1
			else
d1999 2
a2000 1
		if (((*rm)->action == PF_DROP) && (*rm)->return_icmp) {
d2013 3
a2015 2
			pf_send_icmp(m, (*rm)->return_icmp >> 8,
			    (*rm)->return_icmp & 255, af);
@


1.247
log
@Allow filtering based on IP header's tos field.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.246 2002/10/04 17:45:55 ish Exp $ */
d3634 1
a3634 1
		if (r->direction != dir)
d3773 1
a3773 1
		if (r->direction != dir)
@


1.246
log
@[to the right branch this time]
To detect routing loops use the actual outgoing interface and not the
interface that the rule is to apply to (as there may not be one).
- noticed by mcbride@@countersiege.com
- ok dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.245 2002/09/27 17:57:53 henning Exp $ */
d375 1
d1702 2
d1966 2
d2255 2
d2473 2
d2598 2
d3895 1
d4047 1
@


1.245
log
@daddr was used where saddr was meant while checking incoming packets for
binat.
pointed out by Ryan McBride, mcbride at countersiege dot com, Thanks!

ok frantzen@@ pb@@ jasoni@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.244 2002/09/11 05:38:47 itojun Exp $ */
d220 4
a223 2
void			 pf_route(struct mbuf **, struct pf_rule *, int);
void			 pf_route6(struct mbuf **, struct pf_rule *, int);
d3606 1
a3606 1
pf_route(struct mbuf **m, struct pf_rule *r, int dir)
d3658 1
a3658 1
	if (r->ifp != ifp) {
d3743 1
a3743 1
pf_route6(struct mbuf **m, struct pf_rule *r, int dir)
d3792 1
a3792 1
	if (r->ifp != ifp) {
d3994 1
a3994 1
		pf_route(m0, r, dir);
d4166 1
a4166 1
		pf_route6(m0, r, dir);
@


1.244
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.243 2002/08/28 15:43:02 pefo Exp $ */
d1918 1
a1918 1
		    daddr, daddr, af)) != NULL) {
@


1.243
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.242 2002/08/12 16:41:25 dhartmei Exp $ */
d3153 1
a3153 1
						return(PF_DROP);
@


1.242
log
@Use state tree instead of separate (flat) list to find NAT proxy ports,
allows to use the same proxy port with different external peers.
From Ryan McBride
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.241 2002/08/08 14:31:51 dhartmei Exp $ */
d1208 2
a1209 1
		ip_output(m, NULL, NULL, 0, NULL, NULL);
@


1.241
log
@th_flags doesn't have to be equal to TH_SYN to generate modulator, it's
sufficient if TH_SYN is set and TH_ACK is unset, ignore TH_ECN etc.
ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.240 2002/07/24 17:56:03 dhartmei Exp $ */
a107 2
struct pf_port_list	 pf_tcp_ports;
struct pf_port_list	 pf_udp_ports;
d215 3
a217 6

int			 pf_get_sport(u_int8_t, u_int16_t, u_int16_t,
			    u_int16_t *);
void			 pf_put_sport(u_int8_t, u_int16_t);
int			 pf_add_sport(struct pf_port_list *, u_int16_t);
int			 pf_chk_sport(struct pf_port_list *, u_int16_t);
a647 4
			/* release NAT resources */
			if (STATE_TRANSLATE(cur->state))
				pf_put_sport(cur->state->proto,
					htons(cur->state->gwy.port));
d828 3
d1351 3
a1353 1
pf_chk_sport(struct pf_port_list *plist, u_int16_t port)
d1355 1
a1355 24
	struct pf_port_node	*pnode;

	LIST_FOREACH(pnode, plist, next) {
		if (pnode->port == port)
			return (1);
	}

	return (0);
}

int
pf_add_sport(struct pf_port_list *plist, u_int16_t port)
{
	struct pf_port_node *pnode;

	pnode = pool_get(&pf_sport_pl, PR_NOWAIT);
	if (pnode == NULL)
		return (ENOMEM);

	pnode->port = port;
	LIST_INSERT_HEAD(plist, pnode, next);

	return (0);
}
a1356 26
void
pf_put_sport(u_int8_t proto, u_int16_t port)
{
	struct pf_port_list	*plist;
	struct pf_port_node	*pnode;

	if (proto == IPPROTO_TCP)
		plist = &pf_tcp_ports;
	else if (proto == IPPROTO_UDP)
		plist = &pf_udp_ports;
	else
		return;

	LIST_FOREACH(pnode, plist, next) {
		if (pnode->port == port) {
			LIST_REMOVE(pnode, next);
			pool_put(&pf_sport_pl, pnode);
			break;
		}
	}
}

int
pf_get_sport(u_int8_t proto, u_int16_t low, u_int16_t high, u_int16_t *port)
{
	struct pf_port_list	*plist;
d1360 2
d1371 5
a1375 6
	if (proto == IPPROTO_TCP)
		plist = &pf_tcp_ports;
	else if (proto == IPPROTO_UDP)
		plist = &pf_udp_ports;
	else
		return (EINVAL);
d1379 5
a1383 3
		*port = low;
		if (!pf_chk_sport(plist, *port))
			goto found;
d1396 3
a1398 2
		if (!pf_chk_sport(plist, *port))
			goto found;
d1405 3
a1407 2
		if (!pf_chk_sport(plist, *port))
			goto found;
a1410 3

found:
	return (pf_add_sport(plist, *port));
d1623 3
a1625 2
			error = pf_get_sport(IPPROTO_TCP, nat->proxy_port[0],
			    nat->proxy_port[1], &nport);
d1754 1
a1754 3
		if ((*rm)->action == PF_DROP) {
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_TCP, nport);
a1755 1
		}
a1768 2
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_TCP, nport);
d1810 1
a1810 1
		if (th->th_flags & TH_SYN && !(th->th_flags & TH_ACK) &&
a1835 2
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_TCP, nport);
d1882 3
a1884 2
			error = pf_get_sport(IPPROTO_UDP, nat->proxy_port[0],
			    nat->proxy_port[1], &nport);
d2008 1
a2008 3
		if ((*rm)->action == PF_DROP) {
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_UDP, nport);
a2009 1
		}
d2020 1
a2020 3
		if (s == NULL) {
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_UDP, nport);
a2021 1
		}
a2070 2
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_UDP, nport);
@


1.240
log
@Use host order when adding packet size to interface statistics counter.
Only affects pfctl -si output for IPv6. And some whitespace KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.239 2002/07/15 18:07:17 henning Exp $ */
d1865 2
a1866 2
		if (th->th_flags == TH_SYN && *rm != NULL
		    && (*rm)->keep_state == PF_STATE_MODULATE) {
@


1.239
log
@add u_int8_t ifnot to struct pf_rule to support matching packets on any
interface except the given one. adjust the pf_test_* functions and
pf_skip_step accordingly.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.238 2002/07/15 17:52:44 henning Exp $ */
d114 1
a114 1
int			 pftm_tcp_established = 24*60*60;  /* established  */
d224 1
a224 1
			     int, int, void *, struct pf_pdesc *);
d2118 1
a2118 1
		s->src.seqlo  = 0;
d2323 1
a2323 1
		(*rm)->bytes +=  pd->tot_len;
d2718 1
a2718 1
		/* First packet from this end.  Set its state */
d2872 1
a2872 1
		 * since packet floods will also be caught here.  We don't
d3215 1
a3215 1
						    ("pf:  ICMPv6 short opt\n"));
d4207 1
a4207 1
		pf_status.bcounters[1][dir] += h->ip6_plen;
@


1.238
log
@remove duplicated interface check in test_icmp

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.237 2002/07/12 15:52:26 art Exp $ */
d396 2
d904 2
a905 1
			PF_CALC_SKIP_STEP(PF_SKIP_IFP, s->ifp == r->ifp);
d1721 2
a1722 1
		else if (r->ifp != NULL && r->ifp != ifp)
d1987 2
a1988 1
		else if (r->ifp != NULL && r->ifp != ifp)
d2286 2
a2287 1
		else if (r->ifp != NULL && r->ifp != ifp)
d2506 2
a2507 1
		else if (r->ifp != NULL && r->ifp != ifp)
d2629 2
a2630 1
		else if (r->ifp != NULL && r->ifp != ifp)
@


1.237
log
@Remove duplicate function declarations (they are in pfvar.h).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.236 2002/07/10 22:17:58 itojun Exp $ */
a2300 2
		else if (r->ifp != NULL && r->ifp != ifp)
			r = TAILQ_NEXT(r, entries);
@


1.236
log
@let IPv6 fragment go through based on normal rulesets.
TODO: sort-of normalization against fragments for inspection
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.235 2002/06/14 21:35:00 todd Exp $ */
a160 1
int			 pf_dynaddr_setup(struct pf_addr_wrap *, u_int8_t);
a161 2
void			 pf_dynaddr_remove(struct pf_addr_wrap *);
void			 pf_dynaddr_copyout(struct pf_addr_wrap *);
@


1.235
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.234 2002/06/11 02:42:27 frantzen Exp $ */
d3197 4
a3200 1
					/* XXX we don't handle fagments yet */
d4100 3
a4102 3
			/* XXX we don't handle fragments yet */
			action = PF_DROP;
			REASON_SET(&reason, PFRES_FRAG);
@


1.234
log
@enumerate UDP and OTHER state levels (similar to tcp_fsm.h)
ok dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.233 2002/06/11 02:12:37 dhartmei Exp $ */
d2802 1
a2802 1
		/* syncronize sequencing */
d2892 1
a2892 1
		/* syncronize sequencing */
@


1.233
log
@Make NAT proxy port range configurable per rule, for instance privileged
source ports can mapped to privileged proxy ports, or source port 500
to proxy port 500. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.232 2002/06/11 02:02:21 dhartmei Exp $ */
d2120 1
a2120 1
		s->src.state = 1;
d2125 1
a2125 1
		s->dst.state = 0;
d2590 1
a2590 1
		s->src.state = 1;
d2595 1
a2595 1
		s->dst.state = 0;
d2992 4
a2995 4
	if (src->state < 1)
		src->state = 1;
	if (dst->state == 1)
		dst->state = 2;
d2998 1
a2998 1
	if (src->state == 2 && dst->state == 2)
d3535 4
a3538 4
	if (src->state < 1)
		src->state = 1;
	if (dst->state == 1)
		dst->state = 2;
d3541 1
a3541 1
	if (src->state == 2 && dst->state == 2)
@


1.232
log
@Don't panic when pf_insert_state() detects an attempt to insert a
duplicate key. Instead, log according to log level and return gracefully.
ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.231 2002/06/11 01:58:31 dhartmei Exp $ */
d1413 9
d1673 8
a1680 4
			bport = th->th_sport;
			error = pf_get_sport(IPPROTO_TCP, 50001,
			    65535, &nport);
			if (error)
d1682 1
d1937 8
a1944 4
			bport = uh->uh_sport;
			error = pf_get_sport(IPPROTO_UDP, 50001,
			    65535, &nport);
			if (error)
d1946 1
@


1.231
log
@KNF return x -> return (x), ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.230 2002/06/10 19:31:44 dhartmei Exp $ */
d554 17
a570 3
	if (RB_INSERT(pf_state_tree, &tree_lan_ext, keya) != NULL)
		panic("Multiple identical states in PF state table");

d577 1
a577 1
		return -1;
d587 19
a605 2
	if (RB_INSERT(pf_state_tree, &tree_ext_gwy, keyb) != NULL)
		panic("Multiple identical states in PF state table");
d609 1
a609 1
	return 0;
@


1.230
log
@Allow ports to be specified in nat rules, useful later on for individual
proxy port ranges.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.229 2002/06/10 17:05:10 dhartmei Exp $ */
d289 1
a289 1
			return 1;
d291 1
a291 1
			return -1;
d293 1
a293 1
			return 1;
d295 1
a295 1
			return -1;
d301 1
a301 1
			return 1;
d303 1
a303 1
			return -1;
d305 1
a305 1
			return 1;
d307 1
a307 1
			return -1;
d309 1
a309 1
			return 1;
d311 1
a311 1
			return -1;
d313 1
a313 1
			return 1;
d315 1
a315 1
			return -1;
d317 1
a317 1
			return 1;
d319 1
a319 1
			return -1;
d321 1
a321 1
			return 1;
d323 1
a323 1
			return -1;
d325 1
a325 1
			return 1;
d327 1
a327 1
			return -1;
d329 1
a329 1
			return 1;
d331 1
a331 1
			return -1;
d544 1
a544 1
		return -1;
d911 1
a911 1
		return 0x0000;
d916 1
a916 1
		return 0xFFFF;
d1281 1
a1281 1
		return (p > a1) && (p < a2);
d1283 1
a1283 1
		return (p < a1) || (p > a2);
d1547 1
a1547 1
	return htons((u_int16_t)nport);
@


1.229
log
@Don't #include <sys/malloc.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.228 2002/06/09 20:20:58 dhartmei Exp $ */
d190 2
a191 1
			    struct pf_addr *, struct pf_addr *, int);
d1426 1
a1426 1
    struct pf_addr *daddr, int af)
d1440 4
d1447 5
a1451 1
		    daddr, af))
d1632 1
a1632 1
		    saddr, daddr, af)) != NULL) {
d1891 1
a1891 1
		    saddr, daddr, af)) != NULL) {
d2168 1
a2168 1
		    saddr, daddr, af)) != NULL) {
d2395 1
a2395 1
		    saddr, daddr, af)) != NULL) {
@


1.228
log
@Make pf_nat.saddr/daddr a pf_rule_addr instead of pf_addr_wrap, so it
includes ports and operator.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.227 2002/06/09 10:55:59 pb Exp $ */
a43 1
#include <sys/malloc.h>
@


1.227
log
@reapply patch from jasoni@@ for ICMP6_PACKET_TOO_BIG

both have been lost, due to diff thinking about reversing those
lines after merge

tested
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.222 2002/06/09 01:49:42 jasoni Exp $ */
a406 2
	    a->snot != b->snot ||
	    a->dnot != b->dnot ||
d410 6
a415 1
	if (PF_ANEQ(&a->saddr.addr, &b->saddr.addr, a->af))
d417 6
a422 5
	if (PF_ANEQ(&a->smask, &b->smask, a->af))
		return (1);
	if (PF_ANEQ(&a->daddr.addr, &b->daddr.addr, a->af))
		return (1);
	if (PF_ANEQ(&a->dmask, &b->dmask, a->af))
d1436 8
a1443 6
		    (n->saddr.addr_dyn == NULL ||
		    !n->saddr.addr_dyn->undefined) &&
		    PF_MATCHA(n->snot, &n->saddr.addr, &n->smask, saddr, af) &&
		    (n->daddr.addr_dyn == NULL ||
		    !n->daddr.addr_dyn->undefined) &&
		    PF_MATCHA(n->dnot, &n->daddr.addr, &n->dmask, daddr, af))
@


1.226
log
@reapply patch from jasoni@@ for pf_route[6]
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.221 2002/06/09 01:44:31 jasoni Exp $ */
d3807 7
a3813 4
	} else if (r->rt != PF_DUPTO)
		icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
	else
		goto bad;
@


1.225
log
@
split ioctl functions out of pf.c into pf_ioctl.c

frantzen@@, dhartmei@@ ok, tested kernel & userland.

checked for colliding commits
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.220 2002/06/08 07:58:06 dhartmei Exp $ */
a3691 1
		error = EMSGSIZE;
d3693 6
a3698 1
		goto bad;
d3801 2
a3802 3
	 * Do not fragment packets (yet).  Not much is done here for dealing
	 * with errors.  Actions on errors depend on whether the packet
	 * was generated locally or being forwarded.
d3807 4
a3810 2
	} else
		m_freem(m0);
@


1.224
log
@
uncommit, broken (by corrupt diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.222 2002/06/09 01:49:42 jasoni Exp $ */
a40 1
#include <sys/fcntl.h>
a84 6
struct pf_port_node {
	LIST_ENTRY(pf_port_node)	next;
	u_int16_t			port;
};
LIST_HEAD(pf_port_list, pf_port_node);

a88 3
TAILQ_HEAD(pf_natqueue, pf_nat)		pf_nats[2];
TAILQ_HEAD(pf_binatqueue, pf_binat)	pf_binats[2];
TAILQ_HEAD(pf_rdrqueue, pf_rdr)		pf_rdrs[2];
a148 6
struct pf_pool_limit {
	void		*pp;
	unsigned	 limit;
} pf_pool_limits[PF_LIMIT_MAX] = { { &pf_state_pl, UINT_MAX },
				   { &pf_frent_pl, PFFRAG_FRENT_HIWAT } };

a170 5
void			 pfattach(int);
int			 pfopen(dev_t, int, int, struct proc *);
int			 pfclose(dev_t, int, int, struct proc *);
int			 pfioctl(dev_t, u_long, caddr_t, int, struct proc *);

d232 3
d267 2
a268 2
RB_HEAD(pf_state_tree, pf_tree_node) tree_lan_ext, tree_ext_gwy;
RB_PROTOTYPE(pf_state_tree, pf_tree_node, entry, pf_state_compare);
d271 5
a841 1410
void
pfattach(int num)
{
	pool_init(&pf_tree_pl, sizeof(struct pf_tree_node), 0, 0, 0, "pftrpl",
	    NULL);
	pool_init(&pf_rule_pl, sizeof(struct pf_rule), 0, 0, 0, "pfrulepl",
	    &pool_allocator_nointr);
	pool_init(&pf_nat_pl, sizeof(struct pf_nat), 0, 0, 0, "pfnatpl",
	    &pool_allocator_nointr);
	pool_init(&pf_binat_pl, sizeof(struct pf_binat), 0, 0, 0, "pfbinatpl",
	    &pool_allocator_nointr);
	pool_init(&pf_rdr_pl, sizeof(struct pf_rdr), 0, 0, 0, "pfrdrpl",
	    &pool_allocator_nointr);
	pool_init(&pf_state_pl, sizeof(struct pf_state), 0, 0, 0, "pfstatepl",
	    NULL);
	pool_init(&pf_sport_pl, sizeof(struct pf_port_node), 0, 0, 0, "pfsport",
	    NULL);
	pool_init(&pf_addr_pl, sizeof(struct pf_addr_dyn), 0, 0, 0, "pfaddr",
	    NULL);

	TAILQ_INIT(&pf_rules[0]);
	TAILQ_INIT(&pf_rules[1]);
	TAILQ_INIT(&pf_nats[0]);
	TAILQ_INIT(&pf_nats[1]);
	TAILQ_INIT(&pf_binats[0]);
	TAILQ_INIT(&pf_binats[1]);
	TAILQ_INIT(&pf_rdrs[0]);
	TAILQ_INIT(&pf_rdrs[1]);
	pf_rules_active = &pf_rules[0];
	pf_rules_inactive = &pf_rules[1];
	pf_nats_active = &pf_nats[0];
	pf_nats_inactive = &pf_nats[1];
	pf_binats_active = &pf_binats[0];
	pf_binats_inactive = &pf_binats[1];
	pf_rdrs_active = &pf_rdrs[0];
	pf_rdrs_inactive = &pf_rdrs[1];

	LIST_INIT(&pf_tcp_ports);
	LIST_INIT(&pf_udp_ports);

	timeout_set(&pf_expire_to, pf_purge_timeout, &pf_expire_to);
	timeout_add(&pf_expire_to, pftm_interval * hz);

	pf_normalize_init();
	pf_status.debug = PF_DEBUG_URGENT;
}

int
pfopen(dev_t dev, int flags, int fmt, struct proc *p)
{
	if (minor(dev) >= 1)
		return (ENXIO);
	return (0);
}

int
pfclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	if (minor(dev) >= 1)
		return (ENXIO);
	return (0);
}

int
pfioctl(dev_t dev, u_long cmd, caddr_t addr, int flags, struct proc *p)
{
	int error = 0;
	int s;

	/* XXX keep in sync with switch() below */
	if (securelevel > 1)
		switch (cmd) {
		case DIOCGETRULES:
		case DIOCGETRULE:
		case DIOCGETNATS:
		case DIOCGETNAT:
		case DIOCGETBINATS:
		case DIOCGETBINAT:
		case DIOCGETRDRS:
		case DIOCGETRDR:
		case DIOCGETSTATE:
		case DIOCSETSTATUSIF:
		case DIOCGETSTATUS:
		case DIOCCLRSTATUS:
		case DIOCNATLOOK:
		case DIOCSETDEBUG:
		case DIOCGETSTATES:
		case DIOCGETTIMEOUT:
		case DIOCCLRRULECTRS:
		case DIOCGETLIMIT:
			break;
		default:
			return (EPERM);
		}

	if (!(flags & FWRITE))
		switch (cmd) {
		case DIOCGETRULES:
		case DIOCGETRULE:
		case DIOCGETNATS:
		case DIOCGETNAT:
		case DIOCGETRDRS:
		case DIOCGETRDR:
		case DIOCGETSTATE:
		case DIOCGETSTATUS:
		case DIOCGETSTATES:
		case DIOCGETTIMEOUT:
		case DIOCGETBINATS:
		case DIOCGETBINAT:
		case DIOCGETLIMIT:
			break;
		default:
			return (EACCES);
		}

	switch (cmd) {

	case DIOCSTART:
		if (pf_status.running)
			error = EEXIST;
		else {
			u_int32_t states = pf_status.states;
			bzero(&pf_status, sizeof(struct pf_status));
			pf_status.running = 1;
			pf_status.states = states;
			pf_status.since = time.tv_sec;
			DPFPRINTF(PF_DEBUG_MISC, ("pf: started\n"));
		}
		break;

	case DIOCSTOP:
		if (!pf_status.running)
			error = ENOENT;
		else {
			pf_status.running = 0;
			DPFPRINTF(PF_DEBUG_MISC, ("pf: stopped\n"));
		}
		break;

	case DIOCBEGINRULES: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_rule *rule;

		while ((rule = TAILQ_FIRST(pf_rules_inactive)) != NULL) {
			TAILQ_REMOVE(pf_rules_inactive, rule, entries);
			pf_dynaddr_remove(&rule->src.addr);
			pf_dynaddr_remove(&rule->dst.addr);
			pool_put(&pf_rule_pl, rule);
		}
		*ticket = ++ticket_rules_inactive;
		break;
	}

	case DIOCADDRULE: {
		struct pfioc_rule *pr = (struct pfioc_rule *)addr;
		struct pf_rule *rule, *tail;

		if (pr->ticket != ticket_rules_inactive) {
			error = EBUSY;
			break;
		}
		rule = pool_get(&pf_rule_pl, PR_NOWAIT);
		if (rule == NULL) {
			error = ENOMEM;
			break;
		}
		bcopy(&pr->rule, rule, sizeof(struct pf_rule));
#ifndef INET
		if (rule->af == AF_INET) {
			pool_put(&pf_rule_pl, rule);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (rule->af == AF_INET6) {
			pool_put(&pf_rule_pl, rule);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
		tail = TAILQ_LAST(pf_rules_inactive, pf_rulequeue);
		if (tail)
			rule->nr = tail->nr + 1;
		else
			rule->nr = 0;
		if (rule->ifname[0]) {
			rule->ifp = ifunit(rule->ifname);
			if (rule->ifp == NULL) {
				pool_put(&pf_rule_pl, rule);
				error = EINVAL;
				break;
			}
		} else
			rule->ifp = NULL;
		if (rule->rt_ifname[0]) {
			rule->rt_ifp = ifunit(rule->rt_ifname);
			if (rule->rt_ifname == NULL) {
				pool_put(&pf_rule_pl, rule);
				error = EINVAL;
				break;
			}
		} else
			rule->rt_ifp = NULL;
		if (pf_dynaddr_setup(&rule->src.addr, rule->af) ||
		    pf_dynaddr_setup(&rule->dst.addr, rule->af)) {
			pf_dynaddr_remove(&rule->src.addr);
			pf_dynaddr_remove(&rule->dst.addr);
			pool_put(&pf_rule_pl, rule);
			error = EINVAL;
			break;
		}
		rule->evaluations = rule->packets = rule->bytes = 0;
		TAILQ_INSERT_TAIL(pf_rules_inactive, rule, entries);
		break;
	}

	case DIOCCOMMITRULES: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_rulequeue *old_rules;
		struct pf_rule *rule;
		struct pf_tree_node *n;

		if (*ticket != ticket_rules_inactive) {
			error = EBUSY;
			break;
		}

		/* Swap rules, keep the old. */
		s = splsoftnet();
		/*
		 * Rules are about to get freed, clear rule pointers in states
		 */
		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
			n->state->rule.ptr = NULL;
		old_rules = pf_rules_active;
		pf_rules_active = pf_rules_inactive;
		pf_rules_inactive = old_rules;
		ticket_rules_active = ticket_rules_inactive;
		pf_calc_skip_steps(pf_rules_active);
		splx(s);

		/* Purge the old rule list. */
		while ((rule = TAILQ_FIRST(old_rules)) != NULL) {
			TAILQ_REMOVE(old_rules, rule, entries);
			pf_dynaddr_remove(&rule->src.addr);
			pf_dynaddr_remove(&rule->dst.addr);
			pool_put(&pf_rule_pl, rule);
		}
		break;
	}

	case DIOCGETRULES: {
		struct pfioc_rule *pr = (struct pfioc_rule *)addr;
		struct pf_rule *tail;

		s = splsoftnet();
		tail = TAILQ_LAST(pf_rules_active, pf_rulequeue);
		if (tail)
			pr->nr = tail->nr + 1;
		else
			pr->nr = 0;
		pr->ticket = ticket_rules_active;
		splx(s);
		break;
	}

	case DIOCGETRULE: {
		struct pfioc_rule *pr = (struct pfioc_rule *)addr;
		struct pf_rule *rule;

		if (pr->ticket != ticket_rules_active) {
			error = EBUSY;
			break;
		}
		s = splsoftnet();
		rule = TAILQ_FIRST(pf_rules_active);
		while ((rule != NULL) && (rule->nr != pr->nr))
			rule = TAILQ_NEXT(rule, entries);
		if (rule == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(rule, &pr->rule, sizeof(struct pf_rule));
		pf_dynaddr_copyout(&pr->rule.src.addr);
		pf_dynaddr_copyout(&pr->rule.dst.addr);
		splx(s);
		break;
	}

	case DIOCCHANGERULE: {
		struct pfioc_changerule *pcr = (struct pfioc_changerule *)addr;
		struct pf_rule *oldrule = NULL, *newrule = NULL;
		u_int32_t nr = 0;

		if (pcr->action < PF_CHANGE_ADD_HEAD ||
		    pcr->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcr->action != PF_CHANGE_REMOVE) {
			newrule = pool_get(&pf_rule_pl, PR_NOWAIT);
			if (newrule == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcr->newrule, newrule, sizeof(struct pf_rule));
#ifndef INET
			if (newrule->af == AF_INET) {
				pool_put(&pf_rule_pl, newrule);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newrule->af == AF_INET6) {
				pool_put(&pf_rule_pl, newrule);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			if (newrule->ifname[0]) {
				newrule->ifp = ifunit(newrule->ifname);
				if (newrule->ifp == NULL) {
					pool_put(&pf_rule_pl, newrule);
					error = EINVAL;
					break;
				}
			} else
				newrule->ifp = NULL;
			if (newrule->rt_ifname[0]) {
				newrule->rt_ifp = ifunit(newrule->rt_ifname);
				if (newrule->rt_ifname == NULL) {
					pool_put(&pf_rule_pl, newrule);
					error = EINVAL;
					break;
				}
			} else
				newrule->rt_ifp = NULL;
			if (pf_dynaddr_setup(&newrule->src.addr, newrule->af) ||
			    pf_dynaddr_setup(&newrule->dst.addr, newrule->af)) {
				pf_dynaddr_remove(&newrule->src.addr);
				pf_dynaddr_remove(&newrule->dst.addr);
				pool_put(&pf_rule_pl, newrule);
				error = EINVAL;
				break;
			}
			newrule->evaluations = newrule->packets = 0;
			newrule->bytes = 0;
		}

		s = splsoftnet();

		if (pcr->action == PF_CHANGE_ADD_HEAD)
			oldrule = TAILQ_FIRST(pf_rules_active);
		else if (pcr->action == PF_CHANGE_ADD_TAIL)
			oldrule = TAILQ_LAST(pf_rules_active, pf_rulequeue);
		else {
			oldrule = TAILQ_FIRST(pf_rules_active);
			while ((oldrule != NULL) && pf_compare_rules(oldrule,
			    &pcr->oldrule))
				oldrule = TAILQ_NEXT(oldrule, entries);
			if (oldrule == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcr->action == PF_CHANGE_REMOVE) {
			struct pf_tree_node *n;

			RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
				if (n->state->rule.ptr == oldrule)
					n->state->rule.ptr = NULL;
			TAILQ_REMOVE(pf_rules_active, oldrule, entries);
			pf_dynaddr_remove(&oldrule->src.addr);
			pf_dynaddr_remove(&oldrule->dst.addr);
			pool_put(&pf_rule_pl, oldrule);
		} else {
			if (oldrule == NULL)
				TAILQ_INSERT_TAIL(pf_rules_active, newrule,
				    entries);
			else if (pcr->action == PF_CHANGE_ADD_HEAD ||
			    pcr->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldrule, newrule, entries);
			else
				TAILQ_INSERT_AFTER(pf_rules_active, oldrule,
				    newrule, entries);
		}

		TAILQ_FOREACH(oldrule, pf_rules_active, entries)
			oldrule->nr = nr++;

		pf_calc_skip_steps(pf_rules_active);

		ticket_rules_active++;
		splx(s);
		break;
	}

	case DIOCBEGINNATS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_nat *nat;

		while ((nat = TAILQ_FIRST(pf_nats_inactive)) != NULL) {
			pf_dynaddr_remove(&nat->saddr);
			pf_dynaddr_remove(&nat->daddr);
			pf_dynaddr_remove(&nat->raddr);
			TAILQ_REMOVE(pf_nats_inactive, nat, entries);
			pool_put(&pf_nat_pl, nat);
		}
		*ticket = ++ticket_nats_inactive;
		break;
	}

	case DIOCADDNAT: {
		struct pfioc_nat *pn = (struct pfioc_nat *)addr;
		struct pf_nat *nat;

		if (pn->ticket != ticket_nats_inactive) {
			error = EBUSY;
			break;
		}
		nat = pool_get(&pf_nat_pl, PR_NOWAIT);
		if (nat == NULL) {
			error = ENOMEM;
			break;
		}
		bcopy(&pn->nat, nat, sizeof(struct pf_nat));
#ifndef INET
		if (nat->af == AF_INET) {
			pool_put(&pf_nat_pl, nat);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (nat->af == AF_INET6) {
			pool_put(&pf_nat_pl, nat);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
		if (nat->ifname[0]) {
			nat->ifp = ifunit(nat->ifname);
			if (nat->ifp == NULL) {
				pool_put(&pf_nat_pl, nat);
				error = EINVAL;
				break;
			}
		} else
			nat->ifp = NULL;
		if (pf_dynaddr_setup(&nat->saddr, nat->af) ||
		    pf_dynaddr_setup(&nat->daddr, nat->af) ||
		    pf_dynaddr_setup(&nat->raddr, nat->af)) {
			pf_dynaddr_remove(&nat->saddr);
			pf_dynaddr_remove(&nat->daddr);
			pf_dynaddr_remove(&nat->raddr);
			pool_put(&pf_nat_pl, nat);
			error = EINVAL;
			break;
		}
		TAILQ_INSERT_TAIL(pf_nats_inactive, nat, entries);
		break;
	}

	case DIOCCOMMITNATS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_natqueue *old_nats;
		struct pf_nat *nat;

		if (*ticket != ticket_nats_inactive) {
			error = EBUSY;
			break;
		}

		/* Swap nats, keep the old. */
		s = splsoftnet();
		old_nats = pf_nats_active;
		pf_nats_active = pf_nats_inactive;
		pf_nats_inactive = old_nats;
		ticket_nats_active = ticket_nats_inactive;
		splx(s);

		/* Purge the old nat list */
		while ((nat = TAILQ_FIRST(old_nats)) != NULL) {
			pf_dynaddr_remove(&nat->saddr);
			pf_dynaddr_remove(&nat->daddr);
			pf_dynaddr_remove(&nat->raddr);
			TAILQ_REMOVE(old_nats, nat, entries);
			pool_put(&pf_nat_pl, nat);
		}
		break;
	}

	case DIOCGETNATS: {
		struct pfioc_nat *pn = (struct pfioc_nat *)addr;
		struct pf_nat *nat;

		pn->nr = 0;
		s = splsoftnet();
		TAILQ_FOREACH(nat, pf_nats_active, entries)
			pn->nr++;
		pn->ticket = ticket_nats_active;
		splx(s);
		break;
	}

	case DIOCGETNAT: {
		struct pfioc_nat *pn = (struct pfioc_nat *)addr;
		struct pf_nat *nat;
		u_int32_t nr;

		if (pn->ticket != ticket_nats_active) {
			error = EBUSY;
			break;
		}
		nr = 0;
		s = splsoftnet();
		nat = TAILQ_FIRST(pf_nats_active);
		while ((nat != NULL) && (nr < pn->nr)) {
			nat = TAILQ_NEXT(nat, entries);
			nr++;
		}
		if (nat == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(nat, &pn->nat, sizeof(struct pf_nat));
		pf_dynaddr_copyout(&pn->nat.saddr);
		pf_dynaddr_copyout(&pn->nat.daddr);
		pf_dynaddr_copyout(&pn->nat.raddr);
		splx(s);
		break;
	}

	case DIOCCHANGENAT: {
		struct pfioc_changenat *pcn = (struct pfioc_changenat *)addr;
		struct pf_nat *oldnat = NULL, *newnat = NULL;

		if (pcn->action < PF_CHANGE_ADD_HEAD ||
		    pcn->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcn->action != PF_CHANGE_REMOVE) {
			newnat = pool_get(&pf_nat_pl, PR_NOWAIT);
			if (newnat == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcn->newnat, newnat, sizeof(struct pf_nat));
#ifndef INET
			if (newnat->af == AF_INET) {
				pool_put(&pf_nat_pl, newnat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newnat->af == AF_INET6) {
				pool_put(&pf_nat_pl, newnat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			if (newnat->ifname[0]) {
				newnat->ifp = ifunit(newnat->ifname);
				if (newnat->ifp == NULL) {
					pool_put(&pf_nat_pl, newnat);
					error = EINVAL;
					break;
				}
			} else
				newnat->ifp = NULL;
			if (pf_dynaddr_setup(&newnat->saddr, newnat->af) ||
			    pf_dynaddr_setup(&newnat->daddr, newnat->af) ||
			    pf_dynaddr_setup(&newnat->raddr, newnat->af)) {
				pf_dynaddr_remove(&newnat->saddr);
				pf_dynaddr_remove(&newnat->daddr);
				pf_dynaddr_remove(&newnat->raddr);
				pool_put(&pf_nat_pl, newnat);
				error = EINVAL;
				break;
			}
		}

		s = splsoftnet();

		if (pcn->action == PF_CHANGE_ADD_HEAD)
			oldnat = TAILQ_FIRST(pf_nats_active);
		else if (pcn->action == PF_CHANGE_ADD_TAIL)
			oldnat = TAILQ_LAST(pf_nats_active, pf_natqueue);
		else {
			oldnat = TAILQ_FIRST(pf_nats_active);
			while ((oldnat != NULL) && pf_compare_nats(oldnat,
			    &pcn->oldnat))
				oldnat = TAILQ_NEXT(oldnat, entries);
			if (oldnat == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcn->action == PF_CHANGE_REMOVE) {
			pf_dynaddr_remove(&oldnat->saddr);
			pf_dynaddr_remove(&oldnat->daddr);
			pf_dynaddr_remove(&oldnat->raddr);
			TAILQ_REMOVE(pf_nats_active, oldnat, entries);
			pool_put(&pf_nat_pl, oldnat);
		} else {
			if (oldnat == NULL)
				TAILQ_INSERT_TAIL(pf_nats_active, newnat,
				    entries);
			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
			    pcn->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldnat, newnat, entries);
			else
				TAILQ_INSERT_AFTER(pf_nats_active, oldnat,
				    newnat, entries);
		}

		ticket_nats_active++;
		splx(s);
		break;
	}

	case DIOCBEGINBINATS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_binat *binat;

		while ((binat = TAILQ_FIRST(pf_binats_inactive)) != NULL) {
			TAILQ_REMOVE(pf_binats_inactive, binat, entries);
			pf_dynaddr_remove(&binat->saddr);
			pf_dynaddr_remove(&binat->daddr);
			pf_dynaddr_remove(&binat->raddr);
			pool_put(&pf_binat_pl, binat);
		}
		*ticket = ++ticket_binats_inactive;
		break;
	}

	case DIOCADDBINAT: {
		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
		struct pf_binat *binat;

		if (pb->ticket != ticket_binats_inactive) {
			error = EBUSY;
			break;
		}
		binat = pool_get(&pf_binat_pl, PR_NOWAIT);
		if (binat == NULL) {
			error = ENOMEM;
			break;
		}
		bcopy(&pb->binat, binat, sizeof(struct pf_binat));
#ifndef INET
		if (binat->af == AF_INET) {
			pool_put(&pf_binat_pl, binat);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (binat->af == AF_INET6) {
			pool_put(&pf_binat_pl, binat);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
		if (binat->ifname[0]) {
			binat->ifp = ifunit(binat->ifname);
			if (binat->ifp == NULL) {
				pool_put(&pf_binat_pl, binat);
				error = EINVAL;
				break;
			}
		} else
			binat->ifp = NULL;
		if (pf_dynaddr_setup(&binat->saddr, binat->af) ||
		    pf_dynaddr_setup(&binat->daddr, binat->af) ||
		    pf_dynaddr_setup(&binat->raddr, binat->af)) {
			pf_dynaddr_remove(&binat->saddr);
			pf_dynaddr_remove(&binat->daddr);
			pf_dynaddr_remove(&binat->raddr);
			pool_put(&pf_binat_pl, binat);
			error = EINVAL;
			break;
		}
		TAILQ_INSERT_TAIL(pf_binats_inactive, binat, entries);
		break;
	}

	case DIOCCOMMITBINATS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_binatqueue *old_binats;
		struct pf_binat *binat;

		if (*ticket != ticket_binats_inactive) {
			error = EBUSY;
			break;
		}

		/* Swap binats, keep the old. */
		s = splsoftnet();
		old_binats = pf_binats_active;
		pf_binats_active = pf_binats_inactive;
		pf_binats_inactive = old_binats;
		ticket_binats_active = ticket_binats_inactive;
		splx(s);

		/* Purge the old binat list */
		while ((binat = TAILQ_FIRST(old_binats)) != NULL) {
			TAILQ_REMOVE(old_binats, binat, entries);
			pf_dynaddr_remove(&binat->saddr);
			pf_dynaddr_remove(&binat->daddr);
			pf_dynaddr_remove(&binat->raddr);
			pool_put(&pf_binat_pl, binat);
		}
		break;
	}

	case DIOCGETBINATS: {
		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
		struct pf_binat *binat;

		pb->nr = 0;
		s = splsoftnet();
		TAILQ_FOREACH(binat, pf_binats_active, entries)
			pb->nr++;
		pb->ticket = ticket_binats_active;
		splx(s);
		break;
	}

	case DIOCGETBINAT: {
		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
		struct pf_binat *binat;
		u_int32_t nr;

		if (pb->ticket != ticket_binats_active) {
			error = EBUSY;
			break;
		}
		nr = 0;
		s = splsoftnet();
		binat = TAILQ_FIRST(pf_binats_active);
		while ((binat != NULL) && (nr < pb->nr)) {
			binat = TAILQ_NEXT(binat, entries);
			nr++;
		}
		if (binat == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(binat, &pb->binat, sizeof(struct pf_binat));
		pf_dynaddr_copyout(&pb->binat.saddr);
		pf_dynaddr_copyout(&pb->binat.daddr);
		pf_dynaddr_copyout(&pb->binat.raddr);
		splx(s);
		break;
	}

	case DIOCCHANGEBINAT: {
		struct pfioc_changebinat *pcn = (struct pfioc_changebinat *)addr;
		struct pf_binat *oldbinat = NULL, *newbinat = NULL;

		if (pcn->action < PF_CHANGE_ADD_HEAD ||
		    pcn->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcn->action != PF_CHANGE_REMOVE) {
			newbinat = pool_get(&pf_binat_pl, PR_NOWAIT);
			if (newbinat == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcn->newbinat, newbinat,
				sizeof(struct pf_binat));
#ifndef INET
			if (newbinat->af == AF_INET) {
				pool_put(&pf_binat_pl, newbinat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newbinat->af == AF_INET6) {
				pool_put(&pf_binat_pl, newbinat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			if (newbinat->ifname[0]) {
				newbinat->ifp = ifunit(newbinat->ifname);
				if (newbinat->ifp == NULL) {
					pool_put(&pf_binat_pl, newbinat);
					error = EINVAL;
					break;
				}
			} else
				newbinat->ifp = NULL;
			if (pf_dynaddr_setup(&newbinat->saddr, newbinat->af) ||
			    pf_dynaddr_setup(&newbinat->daddr, newbinat->af) ||
			    pf_dynaddr_setup(&newbinat->raddr, newbinat->af)) {
				pf_dynaddr_remove(&newbinat->saddr);
				pf_dynaddr_remove(&newbinat->daddr);
				pf_dynaddr_remove(&newbinat->raddr);
				pool_put(&pf_binat_pl, newbinat);
				error = EINVAL;
				break;
			}
		}

		s = splsoftnet();

		if (pcn->action == PF_CHANGE_ADD_HEAD)
			oldbinat = TAILQ_FIRST(pf_binats_active);
		else if (pcn->action == PF_CHANGE_ADD_TAIL)
			oldbinat = TAILQ_LAST(pf_binats_active, pf_binatqueue);
		else {
			oldbinat = TAILQ_FIRST(pf_binats_active);
			while ((oldbinat != NULL) && pf_compare_binats(oldbinat,
			    &pcn->oldbinat))
				oldbinat = TAILQ_NEXT(oldbinat, entries);
			if (oldbinat == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcn->action == PF_CHANGE_REMOVE) {
			TAILQ_REMOVE(pf_binats_active, oldbinat, entries);
			pf_dynaddr_remove(&oldbinat->saddr);
			pf_dynaddr_remove(&oldbinat->daddr);
			pf_dynaddr_remove(&oldbinat->raddr);
			pool_put(&pf_binat_pl, oldbinat);
		} else {
			if (oldbinat == NULL)
				TAILQ_INSERT_TAIL(pf_binats_active, newbinat,
				    entries);
			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
			    pcn->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldbinat, newbinat,
				    entries);
			else
				TAILQ_INSERT_AFTER(pf_binats_active, oldbinat,
				    newbinat, entries);
		}

		ticket_binats_active++;
		splx(s);
		break;
	}

	case DIOCBEGINRDRS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_rdr *rdr;

		while ((rdr = TAILQ_FIRST(pf_rdrs_inactive)) != NULL) {
			TAILQ_REMOVE(pf_rdrs_inactive, rdr, entries);
			pf_dynaddr_remove(&rdr->saddr);
			pf_dynaddr_remove(&rdr->daddr);
			pf_dynaddr_remove(&rdr->raddr);
			pool_put(&pf_rdr_pl, rdr);
		}
		*ticket = ++ticket_rdrs_inactive;
		break;
	}

	case DIOCADDRDR: {
		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
		struct pf_rdr *rdr;

		if (pr->ticket != ticket_rdrs_inactive) {
			error = EBUSY;
			break;
		}
		rdr = pool_get(&pf_rdr_pl, PR_NOWAIT);
		if (rdr == NULL) {
			error = ENOMEM;
			break;
		}
		bcopy(&pr->rdr, rdr, sizeof(struct pf_rdr));
#ifndef INET
		if (rdr->af == AF_INET) {
			pool_put(&pf_rdr_pl, rdr);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (rdr->af == AF_INET6) {
			pool_put(&pf_rdr_pl, rdr);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
		if (rdr->ifname[0]) {
			rdr->ifp = ifunit(rdr->ifname);
			if (rdr->ifp == NULL) {
				pool_put(&pf_rdr_pl, rdr);
				error = EINVAL;
				break;
			}
		} else
			rdr->ifp = NULL;
		if (pf_dynaddr_setup(&rdr->saddr, rdr->af) ||
		    pf_dynaddr_setup(&rdr->daddr, rdr->af) ||
		    pf_dynaddr_setup(&rdr->raddr, rdr->af)) {
			pf_dynaddr_remove(&rdr->saddr);
			pf_dynaddr_remove(&rdr->daddr);
			pf_dynaddr_remove(&rdr->raddr);
			pool_put(&pf_rdr_pl, rdr);
			error = EINVAL;
			break;
		}
		TAILQ_INSERT_TAIL(pf_rdrs_inactive, rdr, entries);
		break;
	}

	case DIOCCOMMITRDRS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_rdrqueue *old_rdrs;
		struct pf_rdr *rdr;

		if (*ticket != ticket_rdrs_inactive) {
			error = EBUSY;
			break;
		}

		/* Swap rdrs, keep the old. */
		s = splsoftnet();
		old_rdrs = pf_rdrs_active;
		pf_rdrs_active = pf_rdrs_inactive;
		pf_rdrs_inactive = old_rdrs;
		ticket_rdrs_active = ticket_rdrs_inactive;
		splx(s);

		/* Purge the old rdr list */
		while ((rdr = TAILQ_FIRST(old_rdrs)) != NULL) {
			TAILQ_REMOVE(old_rdrs, rdr, entries);
			pf_dynaddr_remove(&rdr->saddr);
			pf_dynaddr_remove(&rdr->daddr);
			pf_dynaddr_remove(&rdr->raddr);
			pool_put(&pf_rdr_pl, rdr);
		}
		break;
	}

	case DIOCGETRDRS: {
		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
		struct pf_rdr *rdr;

		pr->nr = 0;
		s = splsoftnet();
		TAILQ_FOREACH(rdr, pf_rdrs_active, entries)
			pr->nr++;
		pr->ticket = ticket_rdrs_active;
		splx(s);
		break;
	}

	case DIOCGETRDR: {
		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
		struct pf_rdr *rdr;
		u_int32_t nr;

		if (pr->ticket != ticket_rdrs_active) {
			error = EBUSY;
			break;
		}
		nr = 0;
		s = splsoftnet();
		rdr = TAILQ_FIRST(pf_rdrs_active);
		while ((rdr != NULL) && (nr < pr->nr)) {
			rdr = TAILQ_NEXT(rdr, entries);
			nr++;
		}
		if (rdr == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(rdr, &pr->rdr, sizeof(struct pf_rdr));
		pf_dynaddr_copyout(&pr->rdr.saddr);
		pf_dynaddr_copyout(&pr->rdr.daddr);
		pf_dynaddr_copyout(&pr->rdr.raddr);
		splx(s);
		break;
	}

	case DIOCCHANGERDR: {
		struct pfioc_changerdr *pcn = (struct pfioc_changerdr *)addr;
		struct pf_rdr *oldrdr = NULL, *newrdr = NULL;

		if (pcn->action < PF_CHANGE_ADD_HEAD ||
		    pcn->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcn->action != PF_CHANGE_REMOVE) {
			newrdr = pool_get(&pf_rdr_pl, PR_NOWAIT);
			if (newrdr == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcn->newrdr, newrdr, sizeof(struct pf_rdr));
#ifndef INET
			if (newrdr->af == AF_INET) {
				pool_put(&pf_rdr_pl, newrdr);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newrdr->af == AF_INET6) {
				pool_put(&pf_rdr_pl, newrdr);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			if (newrdr->ifname[0]) {
				newrdr->ifp = ifunit(newrdr->ifname);
				if (newrdr->ifp == NULL) {
					pool_put(&pf_rdr_pl, newrdr);
					error = EINVAL;
					break;
				}
			} else
				newrdr->ifp = NULL;
			if (pf_dynaddr_setup(&newrdr->saddr, newrdr->af) ||
			    pf_dynaddr_setup(&newrdr->daddr, newrdr->af) ||
			    pf_dynaddr_setup(&newrdr->raddr, newrdr->af)) {
				pf_dynaddr_remove(&newrdr->saddr);
				pf_dynaddr_remove(&newrdr->daddr);
				pf_dynaddr_remove(&newrdr->raddr);
				pool_put(&pf_rdr_pl, newrdr);
				error = EINVAL;
				break;
			}
		}

		s = splsoftnet();

		if (pcn->action == PF_CHANGE_ADD_HEAD)
			oldrdr = TAILQ_FIRST(pf_rdrs_active);
		else if (pcn->action == PF_CHANGE_ADD_TAIL)
			oldrdr = TAILQ_LAST(pf_rdrs_active, pf_rdrqueue);
		else {
			oldrdr = TAILQ_FIRST(pf_rdrs_active);
			while ((oldrdr != NULL) && pf_compare_rdrs(oldrdr,
			    &pcn->oldrdr))
				oldrdr = TAILQ_NEXT(oldrdr, entries);
			if (oldrdr == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcn->action == PF_CHANGE_REMOVE) {
			TAILQ_REMOVE(pf_rdrs_active, oldrdr, entries);
			pf_dynaddr_remove(&oldrdr->saddr);
			pf_dynaddr_remove(&oldrdr->daddr);
			pf_dynaddr_remove(&oldrdr->raddr);
			pool_put(&pf_rdr_pl, oldrdr);
		} else {
			if (oldrdr == NULL)
				TAILQ_INSERT_TAIL(pf_rdrs_active, newrdr,
				    entries);
			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
			    pcn->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldrdr, newrdr, entries);
			else
				TAILQ_INSERT_AFTER(pf_rdrs_active, oldrdr,
				    newrdr, entries);
		}

		ticket_rdrs_active++;
		splx(s);
		break;
	}

	case DIOCCLRSTATES: {
		struct pf_tree_node *n;

		s = splsoftnet();
		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
			n->state->expire = 0;
		pf_purge_expired_states();
		pf_status.states = 0;
		splx(s);
		break;
	}

	case DIOCKILLSTATES: {
		struct pf_tree_node *n;
		struct pf_state *st;
		struct pfioc_state_kill *psk =
		    (struct pfioc_state_kill *)addr;
		int killed = 0;

		s = splsoftnet();
		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy) {
			st = n->state;
			if ((!psk->psk_af || st->af == psk->psk_af) &&
			    (!psk->psk_proto || psk->psk_proto == st->proto) &&
			    PF_MATCHA(psk->psk_src.not, &psk->psk_src.addr.addr,
			    &psk->psk_src.mask, &st->lan.addr, st->af) &&
			    PF_MATCHA(psk->psk_dst.not, &psk->psk_dst.addr.addr,
			    &psk->psk_dst.mask, &st->ext.addr, st->af) &&
			    (psk->psk_src.port_op == 0 ||
			    pf_match_port(psk->psk_src.port_op,
			    psk->psk_src.port[0], psk->psk_src.port[1],
			    st->lan.port)) &&
			    (psk->psk_dst.port_op == 0 ||
			    pf_match_port(psk->psk_dst.port_op,
			    psk->psk_dst.port[0], psk->psk_dst.port[1],
			    st->ext.port))) {
				st->expire = 0;
				killed++;
			}
		}
		pf_purge_expired_states();
		splx(s);
		psk->psk_af = killed;
		break;
	}

	case DIOCADDSTATE: {
		struct pfioc_state *ps = (struct pfioc_state *)addr;
		struct pf_state *state;

		state = pool_get(&pf_state_pl, PR_NOWAIT);
		if (state == NULL) {
			error = ENOMEM;
			break;
		}
		s = splsoftnet();
		bcopy(&ps->state, state, sizeof(struct pf_state));
		state->rule.ptr = NULL;
		state->creation = time.tv_sec;
		state->expire += state->creation;
		state->packets = 0;
		state->bytes = 0;
		if (pf_insert_state(state)) {
			pool_put(&pf_state_pl, state);
			error = ENOMEM;
		}
		splx(s);
	}

	case DIOCGETSTATE: {
		struct pfioc_state *ps = (struct pfioc_state *)addr;
		struct pf_tree_node *n;
		u_int32_t nr;
		int secs;

		nr = 0;
		s = splsoftnet();
		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy) {
			if (nr >= ps->nr)
				break;
			nr++;
		}
		if (n == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(n->state, &ps->state, sizeof(struct pf_state));
		if (n->state->rule.ptr == NULL)
			ps->state.rule.nr = -1;
		else
			ps->state.rule.nr = n->state->rule.ptr->nr;
		splx(s);
		secs = time.tv_sec;
		ps->state.creation = secs - ps->state.creation;
		if (ps->state.expire <= secs)
			ps->state.expire = 0;
		else
			ps->state.expire -= secs;
		break;
	}

	case DIOCGETSTATES: {
		struct pfioc_states *ps = (struct pfioc_states *)addr;
		struct pf_tree_node *n;
		struct pf_state *p, pstore;
		u_int32_t nr = 0;
		int space = ps->ps_len;

		if (space == 0) {
			s = splsoftnet();
			RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
				nr++;
			splx(s);
			ps->ps_len = sizeof(struct pf_state) * nr;
			return (0);
		}

		s = splsoftnet();
		p = ps->ps_states;
		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy) {
			int secs = time.tv_sec;

			if ((nr + 1) * sizeof(*p) > ps->ps_len)
				break;

			bcopy(n->state, &pstore, sizeof(pstore));
			if (n->state->rule.ptr == NULL)
				pstore.rule.nr = -1;
			else
				pstore.rule.nr = n->state->rule.ptr->nr;
			pstore.creation = secs - pstore.creation;
			if (pstore.expire <= secs)
				pstore.expire = 0;
			else
				pstore.expire -= secs;
			error = copyout(&pstore, p, sizeof(*p));
			if (error) {
				splx(s);
				goto fail;
			}
			p++;
			nr++;
		}
		ps->ps_len = sizeof(struct pf_state) * nr;
		splx(s);
		break;
	}

	case DIOCSETSTATUSIF: {
		struct pfioc_if *pi = (struct pfioc_if *)addr;
		struct ifnet *ifp;

		if ((ifp = ifunit(pi->ifname)) == NULL)
			error = EINVAL;
		else
			status_ifp = ifp;
		break;
	}

	case DIOCGETSTATUS: {
		struct pf_status *s = (struct pf_status *)addr;
		bcopy(&pf_status, s, sizeof(struct pf_status));
		break;
	}

	case DIOCCLRSTATUS: {
		u_int32_t running = pf_status.running;
		u_int32_t states = pf_status.states;
		u_int32_t since = pf_status.since;
		u_int32_t debug = pf_status.debug;

		bzero(&pf_status, sizeof(struct pf_status));
		pf_status.running = running;
		pf_status.states = states;
		pf_status.since = since;
		pf_status.debug = debug;
		break;
	}

	case DIOCNATLOOK: {
		struct pfioc_natlook *pnl = (struct pfioc_natlook *)addr;
		struct pf_state *st;
		struct pf_tree_node key;
		int direction = pnl->direction;

		key.af = pnl->af;
		key.proto = pnl->proto;

		/*
		 * userland gives us source and dest of connetion, reverse
		 * the lookup so we ask for what happens with the return
		 * traffic, enabling us to find it in the state tree.
		 */
		PF_ACPY(&key.addr[1], &pnl->saddr, pnl->af);
		key.port[1] = pnl->sport;
		PF_ACPY(&key.addr[0], &pnl->daddr, pnl->af);
		key.port[0] = pnl->dport;

		if (!pnl->proto ||
		    PF_AZERO(&pnl->saddr, pnl->af) ||
		    PF_AZERO(&pnl->daddr, pnl->af) ||
		    !pnl->dport || !pnl->sport)
			error = EINVAL;
		else {
			s = splsoftnet();
			if (direction == PF_IN)
				st = pf_find_state(&tree_ext_gwy, &key);
			else
				st = pf_find_state(&tree_lan_ext, &key);
			if (st != NULL) {
				if (direction  == PF_IN) {
					PF_ACPY(&pnl->rsaddr, &st->lan.addr,
					    st->af);
					pnl->rsport = st->lan.port;
					PF_ACPY(&pnl->rdaddr, &pnl->daddr,
					    pnl->af);
					pnl->rdport = pnl->dport;
				} else {
					PF_ACPY(&pnl->rdaddr, &st->gwy.addr,
					    st->af);
					pnl->rdport = st->gwy.port;
					PF_ACPY(&pnl->rsaddr, &pnl->saddr,
					    pnl->af);
					pnl->rsport = pnl->sport;
				}
			} else
				error = ENOENT;
			splx(s);
		}
		break;
	}

	case DIOCSETTIMEOUT: {
		struct pfioc_tm *pt = (struct pfioc_tm *)addr;
		int old;

		if (pt->timeout < 0 || pt->timeout >= PFTM_MAX ||
		    pt->seconds < 0) {
			error = EINVAL;
			goto fail;
		}
		old = *pftm_timeouts[pt->timeout];
		*pftm_timeouts[pt->timeout] = pt->seconds;
		pt->seconds = old;
		break;
	}

	case DIOCGETTIMEOUT: {
		struct pfioc_tm *pt = (struct pfioc_tm *)addr;

		if (pt->timeout < 0 || pt->timeout >= PFTM_MAX) {
			error = EINVAL;
			goto fail;
		}
		pt->seconds = *pftm_timeouts[pt->timeout];
		break;
	}

	case DIOCGETLIMIT: {
		struct pfioc_limit *pl = (struct pfioc_limit *)addr;

		if (pl->index < 0 || pl->index >= PF_LIMIT_MAX) {
			error = EINVAL;
			goto fail;
		}
		pl->limit = pf_pool_limits[pl->index].limit;
		break;
	}

	case DIOCSETLIMIT: {
		struct pfioc_limit *pl = (struct pfioc_limit *)addr;
		int old_limit;

		if (pl->index < 0 || pl->index >= PF_LIMIT_MAX) {
			error = EINVAL;
			goto fail;
		}
		if (pool_sethardlimit(pf_pool_limits[pl->index].pp,
		    pl->limit, NULL, 0) != 0) {
			error = EBUSY;
			goto fail;
		}
		old_limit = pf_pool_limits[pl->index].limit;
		pf_pool_limits[pl->index].limit = pl->limit;
		pl->limit = old_limit;
		break;
	}

	case DIOCSETDEBUG: {
		u_int32_t *level = (u_int32_t *)addr;
		pf_status.debug = *level;
		break;
	}

	case DIOCCLRRULECTRS: {
		struct pf_rule *rule;

		s = splsoftnet();
		TAILQ_FOREACH(rule, pf_rules_active, entries)
			rule->evaluations = rule->packets =
			    rule->bytes = 0;
		splx(s);
		break;
	}

	default:
		error = ENODEV;
		break;
	}
fail:

	return (error);
}

d3692 1
d3694 1
a3694 6
		if (r->rt != PF_DUPTO) {
			icmp_error(m0, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG, 0,
			    ifp);
			goto done;
		} else
			goto bad;
d3797 3
a3799 2
	 * If the packet is too large for the outgoing interface,
	 * send back an icmp6 error.
d3804 2
a3805 7
	} else {
		in6_ifstat_inc(ifp, ifs6_in_toobig);
		if (r->rt != PF_DUPTO)
			icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
		else
			goto bad;
	}
@


1.223
log
@
new file sys/net/pf_ioctl.c

functions moved from pf.c to there

ok dhartmei@@, frantzen@@

testing myself + henning@@, kernel & userland utils fine
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.220 2002/06/08 07:58:06 dhartmei Exp $ */
d41 1
d86 6
d96 3
d159 6
d187 5
a252 3
struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] = { { &pf_state_pl, UINT_MAX },
	{ &pf_frent_pl, PFFRAG_FRENT_HIWAT } };

d285 2
a286 2

struct pf_state_tree tree_lan_ext, tree_ext_gwy;
a288 5
struct pf_rulequeue		 pf_rules[2];
struct pf_natqueue		 pf_nats[2];
struct pf_binatqueue		 pf_binats[2];
struct pf_rdrqueue		 pf_rdrs[2];

d853 1410
@


1.222
log
@increment ifs6_in_toobig if ipv6 packet too large for interface in
pf_route6().
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.221 2002/06/09 01:44:31 jasoni Exp $ */
a40 1
#include <sys/fcntl.h>
a84 6
struct pf_port_node {
	LIST_ENTRY(pf_port_node)	next;
	u_int16_t			port;
};
LIST_HEAD(pf_port_list, pf_port_node);

a88 3
TAILQ_HEAD(pf_natqueue, pf_nat)		pf_nats[2];
TAILQ_HEAD(pf_binatqueue, pf_binat)	pf_binats[2];
TAILQ_HEAD(pf_rdrqueue, pf_rdr)		pf_rdrs[2];
a148 6
struct pf_pool_limit {
	void		*pp;
	unsigned	 limit;
} pf_pool_limits[PF_LIMIT_MAX] = { { &pf_state_pl, UINT_MAX },
				   { &pf_frent_pl, PFFRAG_FRENT_HIWAT } };

a170 5
void			 pfattach(int);
int			 pfopen(dev_t, int, int, struct proc *);
int			 pfclose(dev_t, int, int, struct proc *);
int			 pfioctl(dev_t, u_long, caddr_t, int, struct proc *);

d232 3
d267 2
a268 2
RB_HEAD(pf_state_tree, pf_tree_node) tree_lan_ext, tree_ext_gwy;
RB_PROTOTYPE(pf_state_tree, pf_tree_node, entry, pf_state_compare);
d271 5
a839 1410
}

void
pfattach(int num)
{
	pool_init(&pf_tree_pl, sizeof(struct pf_tree_node), 0, 0, 0, "pftrpl",
	    NULL);
	pool_init(&pf_rule_pl, sizeof(struct pf_rule), 0, 0, 0, "pfrulepl",
	    &pool_allocator_nointr);
	pool_init(&pf_nat_pl, sizeof(struct pf_nat), 0, 0, 0, "pfnatpl",
	    &pool_allocator_nointr);
	pool_init(&pf_binat_pl, sizeof(struct pf_binat), 0, 0, 0, "pfbinatpl",
	    &pool_allocator_nointr);
	pool_init(&pf_rdr_pl, sizeof(struct pf_rdr), 0, 0, 0, "pfrdrpl",
	    &pool_allocator_nointr);
	pool_init(&pf_state_pl, sizeof(struct pf_state), 0, 0, 0, "pfstatepl",
	    NULL);
	pool_init(&pf_sport_pl, sizeof(struct pf_port_node), 0, 0, 0, "pfsport",
	    NULL);
	pool_init(&pf_addr_pl, sizeof(struct pf_addr_dyn), 0, 0, 0, "pfaddr",
	    NULL);

	TAILQ_INIT(&pf_rules[0]);
	TAILQ_INIT(&pf_rules[1]);
	TAILQ_INIT(&pf_nats[0]);
	TAILQ_INIT(&pf_nats[1]);
	TAILQ_INIT(&pf_binats[0]);
	TAILQ_INIT(&pf_binats[1]);
	TAILQ_INIT(&pf_rdrs[0]);
	TAILQ_INIT(&pf_rdrs[1]);
	pf_rules_active = &pf_rules[0];
	pf_rules_inactive = &pf_rules[1];
	pf_nats_active = &pf_nats[0];
	pf_nats_inactive = &pf_nats[1];
	pf_binats_active = &pf_binats[0];
	pf_binats_inactive = &pf_binats[1];
	pf_rdrs_active = &pf_rdrs[0];
	pf_rdrs_inactive = &pf_rdrs[1];

	LIST_INIT(&pf_tcp_ports);
	LIST_INIT(&pf_udp_ports);

	timeout_set(&pf_expire_to, pf_purge_timeout, &pf_expire_to);
	timeout_add(&pf_expire_to, pftm_interval * hz);

	pf_normalize_init();
	pf_status.debug = PF_DEBUG_URGENT;
}

int
pfopen(dev_t dev, int flags, int fmt, struct proc *p)
{
	if (minor(dev) >= 1)
		return (ENXIO);
	return (0);
}

int
pfclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	if (minor(dev) >= 1)
		return (ENXIO);
	return (0);
}

int
pfioctl(dev_t dev, u_long cmd, caddr_t addr, int flags, struct proc *p)
{
	int error = 0;
	int s;

	/* XXX keep in sync with switch() below */
	if (securelevel > 1)
		switch (cmd) {
		case DIOCGETRULES:
		case DIOCGETRULE:
		case DIOCGETNATS:
		case DIOCGETNAT:
		case DIOCGETBINATS:
		case DIOCGETBINAT:
		case DIOCGETRDRS:
		case DIOCGETRDR:
		case DIOCGETSTATE:
		case DIOCSETSTATUSIF:
		case DIOCGETSTATUS:
		case DIOCCLRSTATUS:
		case DIOCNATLOOK:
		case DIOCSETDEBUG:
		case DIOCGETSTATES:
		case DIOCGETTIMEOUT:
		case DIOCCLRRULECTRS:
		case DIOCGETLIMIT:
			break;
		default:
			return (EPERM);
		}

	if (!(flags & FWRITE))
		switch (cmd) {
		case DIOCGETRULES:
		case DIOCGETRULE:
		case DIOCGETNATS:
		case DIOCGETNAT:
		case DIOCGETRDRS:
		case DIOCGETRDR:
		case DIOCGETSTATE:
		case DIOCGETSTATUS:
		case DIOCGETSTATES:
		case DIOCGETTIMEOUT:
		case DIOCGETBINATS:
		case DIOCGETBINAT:
		case DIOCGETLIMIT:
			break;
		default:
			return (EACCES);
		}

	switch (cmd) {

	case DIOCSTART:
		if (pf_status.running)
			error = EEXIST;
		else {
			u_int32_t states = pf_status.states;
			bzero(&pf_status, sizeof(struct pf_status));
			pf_status.running = 1;
			pf_status.states = states;
			pf_status.since = time.tv_sec;
			DPFPRINTF(PF_DEBUG_MISC, ("pf: started\n"));
		}
		break;

	case DIOCSTOP:
		if (!pf_status.running)
			error = ENOENT;
		else {
			pf_status.running = 0;
			DPFPRINTF(PF_DEBUG_MISC, ("pf: stopped\n"));
		}
		break;

	case DIOCBEGINRULES: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_rule *rule;

		while ((rule = TAILQ_FIRST(pf_rules_inactive)) != NULL) {
			TAILQ_REMOVE(pf_rules_inactive, rule, entries);
			pf_dynaddr_remove(&rule->src.addr);
			pf_dynaddr_remove(&rule->dst.addr);
			pool_put(&pf_rule_pl, rule);
		}
		*ticket = ++ticket_rules_inactive;
		break;
	}

	case DIOCADDRULE: {
		struct pfioc_rule *pr = (struct pfioc_rule *)addr;
		struct pf_rule *rule, *tail;

		if (pr->ticket != ticket_rules_inactive) {
			error = EBUSY;
			break;
		}
		rule = pool_get(&pf_rule_pl, PR_NOWAIT);
		if (rule == NULL) {
			error = ENOMEM;
			break;
		}
		bcopy(&pr->rule, rule, sizeof(struct pf_rule));
#ifndef INET
		if (rule->af == AF_INET) {
			pool_put(&pf_rule_pl, rule);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (rule->af == AF_INET6) {
			pool_put(&pf_rule_pl, rule);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
		tail = TAILQ_LAST(pf_rules_inactive, pf_rulequeue);
		if (tail)
			rule->nr = tail->nr + 1;
		else
			rule->nr = 0;
		if (rule->ifname[0]) {
			rule->ifp = ifunit(rule->ifname);
			if (rule->ifp == NULL) {
				pool_put(&pf_rule_pl, rule);
				error = EINVAL;
				break;
			}
		} else
			rule->ifp = NULL;
		if (rule->rt_ifname[0]) {
			rule->rt_ifp = ifunit(rule->rt_ifname);
			if (rule->rt_ifname == NULL) {
				pool_put(&pf_rule_pl, rule);
				error = EINVAL;
				break;
			}
		} else
			rule->rt_ifp = NULL;
		if (pf_dynaddr_setup(&rule->src.addr, rule->af) ||
		    pf_dynaddr_setup(&rule->dst.addr, rule->af)) {
			pf_dynaddr_remove(&rule->src.addr);
			pf_dynaddr_remove(&rule->dst.addr);
			pool_put(&pf_rule_pl, rule);
			error = EINVAL;
			break;
		}
		rule->evaluations = rule->packets = rule->bytes = 0;
		TAILQ_INSERT_TAIL(pf_rules_inactive, rule, entries);
		break;
	}

	case DIOCCOMMITRULES: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_rulequeue *old_rules;
		struct pf_rule *rule;
		struct pf_tree_node *n;

		if (*ticket != ticket_rules_inactive) {
			error = EBUSY;
			break;
		}

		/* Swap rules, keep the old. */
		s = splsoftnet();
		/*
		 * Rules are about to get freed, clear rule pointers in states
		 */
		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
			n->state->rule.ptr = NULL;
		old_rules = pf_rules_active;
		pf_rules_active = pf_rules_inactive;
		pf_rules_inactive = old_rules;
		ticket_rules_active = ticket_rules_inactive;
		pf_calc_skip_steps(pf_rules_active);
		splx(s);

		/* Purge the old rule list. */
		while ((rule = TAILQ_FIRST(old_rules)) != NULL) {
			TAILQ_REMOVE(old_rules, rule, entries);
			pf_dynaddr_remove(&rule->src.addr);
			pf_dynaddr_remove(&rule->dst.addr);
			pool_put(&pf_rule_pl, rule);
		}
		break;
	}

	case DIOCGETRULES: {
		struct pfioc_rule *pr = (struct pfioc_rule *)addr;
		struct pf_rule *tail;

		s = splsoftnet();
		tail = TAILQ_LAST(pf_rules_active, pf_rulequeue);
		if (tail)
			pr->nr = tail->nr + 1;
		else
			pr->nr = 0;
		pr->ticket = ticket_rules_active;
		splx(s);
		break;
	}

	case DIOCGETRULE: {
		struct pfioc_rule *pr = (struct pfioc_rule *)addr;
		struct pf_rule *rule;

		if (pr->ticket != ticket_rules_active) {
			error = EBUSY;
			break;
		}
		s = splsoftnet();
		rule = TAILQ_FIRST(pf_rules_active);
		while ((rule != NULL) && (rule->nr != pr->nr))
			rule = TAILQ_NEXT(rule, entries);
		if (rule == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(rule, &pr->rule, sizeof(struct pf_rule));
		pf_dynaddr_copyout(&pr->rule.src.addr);
		pf_dynaddr_copyout(&pr->rule.dst.addr);
		splx(s);
		break;
	}

	case DIOCCHANGERULE: {
		struct pfioc_changerule *pcr = (struct pfioc_changerule *)addr;
		struct pf_rule *oldrule = NULL, *newrule = NULL;
		u_int32_t nr = 0;

		if (pcr->action < PF_CHANGE_ADD_HEAD ||
		    pcr->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcr->action != PF_CHANGE_REMOVE) {
			newrule = pool_get(&pf_rule_pl, PR_NOWAIT);
			if (newrule == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcr->newrule, newrule, sizeof(struct pf_rule));
#ifndef INET
			if (newrule->af == AF_INET) {
				pool_put(&pf_rule_pl, newrule);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newrule->af == AF_INET6) {
				pool_put(&pf_rule_pl, newrule);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			if (newrule->ifname[0]) {
				newrule->ifp = ifunit(newrule->ifname);
				if (newrule->ifp == NULL) {
					pool_put(&pf_rule_pl, newrule);
					error = EINVAL;
					break;
				}
			} else
				newrule->ifp = NULL;
			if (newrule->rt_ifname[0]) {
				newrule->rt_ifp = ifunit(newrule->rt_ifname);
				if (newrule->rt_ifname == NULL) {
					pool_put(&pf_rule_pl, newrule);
					error = EINVAL;
					break;
				}
			} else
				newrule->rt_ifp = NULL;
			if (pf_dynaddr_setup(&newrule->src.addr, newrule->af) ||
			    pf_dynaddr_setup(&newrule->dst.addr, newrule->af)) {
				pf_dynaddr_remove(&newrule->src.addr);
				pf_dynaddr_remove(&newrule->dst.addr);
				pool_put(&pf_rule_pl, newrule);
				error = EINVAL;
				break;
			}
			newrule->evaluations = newrule->packets = 0;
			newrule->bytes = 0;
		}

		s = splsoftnet();

		if (pcr->action == PF_CHANGE_ADD_HEAD)
			oldrule = TAILQ_FIRST(pf_rules_active);
		else if (pcr->action == PF_CHANGE_ADD_TAIL)
			oldrule = TAILQ_LAST(pf_rules_active, pf_rulequeue);
		else {
			oldrule = TAILQ_FIRST(pf_rules_active);
			while ((oldrule != NULL) && pf_compare_rules(oldrule,
			    &pcr->oldrule))
				oldrule = TAILQ_NEXT(oldrule, entries);
			if (oldrule == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcr->action == PF_CHANGE_REMOVE) {
			struct pf_tree_node *n;

			RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
				if (n->state->rule.ptr == oldrule)
					n->state->rule.ptr = NULL;
			TAILQ_REMOVE(pf_rules_active, oldrule, entries);
			pf_dynaddr_remove(&oldrule->src.addr);
			pf_dynaddr_remove(&oldrule->dst.addr);
			pool_put(&pf_rule_pl, oldrule);
		} else {
			if (oldrule == NULL)
				TAILQ_INSERT_TAIL(pf_rules_active, newrule,
				    entries);
			else if (pcr->action == PF_CHANGE_ADD_HEAD ||
			    pcr->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldrule, newrule, entries);
			else
				TAILQ_INSERT_AFTER(pf_rules_active, oldrule,
				    newrule, entries);
		}

		TAILQ_FOREACH(oldrule, pf_rules_active, entries)
			oldrule->nr = nr++;

		pf_calc_skip_steps(pf_rules_active);

		ticket_rules_active++;
		splx(s);
		break;
	}

	case DIOCBEGINNATS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_nat *nat;

		while ((nat = TAILQ_FIRST(pf_nats_inactive)) != NULL) {
			pf_dynaddr_remove(&nat->saddr);
			pf_dynaddr_remove(&nat->daddr);
			pf_dynaddr_remove(&nat->raddr);
			TAILQ_REMOVE(pf_nats_inactive, nat, entries);
			pool_put(&pf_nat_pl, nat);
		}
		*ticket = ++ticket_nats_inactive;
		break;
	}

	case DIOCADDNAT: {
		struct pfioc_nat *pn = (struct pfioc_nat *)addr;
		struct pf_nat *nat;

		if (pn->ticket != ticket_nats_inactive) {
			error = EBUSY;
			break;
		}
		nat = pool_get(&pf_nat_pl, PR_NOWAIT);
		if (nat == NULL) {
			error = ENOMEM;
			break;
		}
		bcopy(&pn->nat, nat, sizeof(struct pf_nat));
#ifndef INET
		if (nat->af == AF_INET) {
			pool_put(&pf_nat_pl, nat);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (nat->af == AF_INET6) {
			pool_put(&pf_nat_pl, nat);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
		if (nat->ifname[0]) {
			nat->ifp = ifunit(nat->ifname);
			if (nat->ifp == NULL) {
				pool_put(&pf_nat_pl, nat);
				error = EINVAL;
				break;
			}
		} else
			nat->ifp = NULL;
		if (pf_dynaddr_setup(&nat->saddr, nat->af) ||
		    pf_dynaddr_setup(&nat->daddr, nat->af) ||
		    pf_dynaddr_setup(&nat->raddr, nat->af)) {
			pf_dynaddr_remove(&nat->saddr);
			pf_dynaddr_remove(&nat->daddr);
			pf_dynaddr_remove(&nat->raddr);
			pool_put(&pf_nat_pl, nat);
			error = EINVAL;
			break;
		}
		TAILQ_INSERT_TAIL(pf_nats_inactive, nat, entries);
		break;
	}

	case DIOCCOMMITNATS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_natqueue *old_nats;
		struct pf_nat *nat;

		if (*ticket != ticket_nats_inactive) {
			error = EBUSY;
			break;
		}

		/* Swap nats, keep the old. */
		s = splsoftnet();
		old_nats = pf_nats_active;
		pf_nats_active = pf_nats_inactive;
		pf_nats_inactive = old_nats;
		ticket_nats_active = ticket_nats_inactive;
		splx(s);

		/* Purge the old nat list */
		while ((nat = TAILQ_FIRST(old_nats)) != NULL) {
			pf_dynaddr_remove(&nat->saddr);
			pf_dynaddr_remove(&nat->daddr);
			pf_dynaddr_remove(&nat->raddr);
			TAILQ_REMOVE(old_nats, nat, entries);
			pool_put(&pf_nat_pl, nat);
		}
		break;
	}

	case DIOCGETNATS: {
		struct pfioc_nat *pn = (struct pfioc_nat *)addr;
		struct pf_nat *nat;

		pn->nr = 0;
		s = splsoftnet();
		TAILQ_FOREACH(nat, pf_nats_active, entries)
			pn->nr++;
		pn->ticket = ticket_nats_active;
		splx(s);
		break;
	}

	case DIOCGETNAT: {
		struct pfioc_nat *pn = (struct pfioc_nat *)addr;
		struct pf_nat *nat;
		u_int32_t nr;

		if (pn->ticket != ticket_nats_active) {
			error = EBUSY;
			break;
		}
		nr = 0;
		s = splsoftnet();
		nat = TAILQ_FIRST(pf_nats_active);
		while ((nat != NULL) && (nr < pn->nr)) {
			nat = TAILQ_NEXT(nat, entries);
			nr++;
		}
		if (nat == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(nat, &pn->nat, sizeof(struct pf_nat));
		pf_dynaddr_copyout(&pn->nat.saddr);
		pf_dynaddr_copyout(&pn->nat.daddr);
		pf_dynaddr_copyout(&pn->nat.raddr);
		splx(s);
		break;
	}

	case DIOCCHANGENAT: {
		struct pfioc_changenat *pcn = (struct pfioc_changenat *)addr;
		struct pf_nat *oldnat = NULL, *newnat = NULL;

		if (pcn->action < PF_CHANGE_ADD_HEAD ||
		    pcn->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcn->action != PF_CHANGE_REMOVE) {
			newnat = pool_get(&pf_nat_pl, PR_NOWAIT);
			if (newnat == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcn->newnat, newnat, sizeof(struct pf_nat));
#ifndef INET
			if (newnat->af == AF_INET) {
				pool_put(&pf_nat_pl, newnat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newnat->af == AF_INET6) {
				pool_put(&pf_nat_pl, newnat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			if (newnat->ifname[0]) {
				newnat->ifp = ifunit(newnat->ifname);
				if (newnat->ifp == NULL) {
					pool_put(&pf_nat_pl, newnat);
					error = EINVAL;
					break;
				}
			} else
				newnat->ifp = NULL;
			if (pf_dynaddr_setup(&newnat->saddr, newnat->af) ||
			    pf_dynaddr_setup(&newnat->daddr, newnat->af) ||
			    pf_dynaddr_setup(&newnat->raddr, newnat->af)) {
				pf_dynaddr_remove(&newnat->saddr);
				pf_dynaddr_remove(&newnat->daddr);
				pf_dynaddr_remove(&newnat->raddr);
				pool_put(&pf_nat_pl, newnat);
				error = EINVAL;
				break;
			}
		}

		s = splsoftnet();

		if (pcn->action == PF_CHANGE_ADD_HEAD)
			oldnat = TAILQ_FIRST(pf_nats_active);
		else if (pcn->action == PF_CHANGE_ADD_TAIL)
			oldnat = TAILQ_LAST(pf_nats_active, pf_natqueue);
		else {
			oldnat = TAILQ_FIRST(pf_nats_active);
			while ((oldnat != NULL) && pf_compare_nats(oldnat,
			    &pcn->oldnat))
				oldnat = TAILQ_NEXT(oldnat, entries);
			if (oldnat == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcn->action == PF_CHANGE_REMOVE) {
			pf_dynaddr_remove(&oldnat->saddr);
			pf_dynaddr_remove(&oldnat->daddr);
			pf_dynaddr_remove(&oldnat->raddr);
			TAILQ_REMOVE(pf_nats_active, oldnat, entries);
			pool_put(&pf_nat_pl, oldnat);
		} else {
			if (oldnat == NULL)
				TAILQ_INSERT_TAIL(pf_nats_active, newnat,
				    entries);
			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
			    pcn->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldnat, newnat, entries);
			else
				TAILQ_INSERT_AFTER(pf_nats_active, oldnat,
				    newnat, entries);
		}

		ticket_nats_active++;
		splx(s);
		break;
	}

	case DIOCBEGINBINATS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_binat *binat;

		while ((binat = TAILQ_FIRST(pf_binats_inactive)) != NULL) {
			TAILQ_REMOVE(pf_binats_inactive, binat, entries);
			pf_dynaddr_remove(&binat->saddr);
			pf_dynaddr_remove(&binat->daddr);
			pf_dynaddr_remove(&binat->raddr);
			pool_put(&pf_binat_pl, binat);
		}
		*ticket = ++ticket_binats_inactive;
		break;
	}

	case DIOCADDBINAT: {
		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
		struct pf_binat *binat;

		if (pb->ticket != ticket_binats_inactive) {
			error = EBUSY;
			break;
		}
		binat = pool_get(&pf_binat_pl, PR_NOWAIT);
		if (binat == NULL) {
			error = ENOMEM;
			break;
		}
		bcopy(&pb->binat, binat, sizeof(struct pf_binat));
#ifndef INET
		if (binat->af == AF_INET) {
			pool_put(&pf_binat_pl, binat);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (binat->af == AF_INET6) {
			pool_put(&pf_binat_pl, binat);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
		if (binat->ifname[0]) {
			binat->ifp = ifunit(binat->ifname);
			if (binat->ifp == NULL) {
				pool_put(&pf_binat_pl, binat);
				error = EINVAL;
				break;
			}
		} else
			binat->ifp = NULL;
		if (pf_dynaddr_setup(&binat->saddr, binat->af) ||
		    pf_dynaddr_setup(&binat->daddr, binat->af) ||
		    pf_dynaddr_setup(&binat->raddr, binat->af)) {
			pf_dynaddr_remove(&binat->saddr);
			pf_dynaddr_remove(&binat->daddr);
			pf_dynaddr_remove(&binat->raddr);
			pool_put(&pf_binat_pl, binat);
			error = EINVAL;
			break;
		}
		TAILQ_INSERT_TAIL(pf_binats_inactive, binat, entries);
		break;
	}

	case DIOCCOMMITBINATS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_binatqueue *old_binats;
		struct pf_binat *binat;

		if (*ticket != ticket_binats_inactive) {
			error = EBUSY;
			break;
		}

		/* Swap binats, keep the old. */
		s = splsoftnet();
		old_binats = pf_binats_active;
		pf_binats_active = pf_binats_inactive;
		pf_binats_inactive = old_binats;
		ticket_binats_active = ticket_binats_inactive;
		splx(s);

		/* Purge the old binat list */
		while ((binat = TAILQ_FIRST(old_binats)) != NULL) {
			TAILQ_REMOVE(old_binats, binat, entries);
			pf_dynaddr_remove(&binat->saddr);
			pf_dynaddr_remove(&binat->daddr);
			pf_dynaddr_remove(&binat->raddr);
			pool_put(&pf_binat_pl, binat);
		}
		break;
	}

	case DIOCGETBINATS: {
		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
		struct pf_binat *binat;

		pb->nr = 0;
		s = splsoftnet();
		TAILQ_FOREACH(binat, pf_binats_active, entries)
			pb->nr++;
		pb->ticket = ticket_binats_active;
		splx(s);
		break;
	}

	case DIOCGETBINAT: {
		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
		struct pf_binat *binat;
		u_int32_t nr;

		if (pb->ticket != ticket_binats_active) {
			error = EBUSY;
			break;
		}
		nr = 0;
		s = splsoftnet();
		binat = TAILQ_FIRST(pf_binats_active);
		while ((binat != NULL) && (nr < pb->nr)) {
			binat = TAILQ_NEXT(binat, entries);
			nr++;
		}
		if (binat == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(binat, &pb->binat, sizeof(struct pf_binat));
		pf_dynaddr_copyout(&pb->binat.saddr);
		pf_dynaddr_copyout(&pb->binat.daddr);
		pf_dynaddr_copyout(&pb->binat.raddr);
		splx(s);
		break;
	}

	case DIOCCHANGEBINAT: {
		struct pfioc_changebinat *pcn = (struct pfioc_changebinat *)addr;
		struct pf_binat *oldbinat = NULL, *newbinat = NULL;

		if (pcn->action < PF_CHANGE_ADD_HEAD ||
		    pcn->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcn->action != PF_CHANGE_REMOVE) {
			newbinat = pool_get(&pf_binat_pl, PR_NOWAIT);
			if (newbinat == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcn->newbinat, newbinat,
				sizeof(struct pf_binat));
#ifndef INET
			if (newbinat->af == AF_INET) {
				pool_put(&pf_binat_pl, newbinat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newbinat->af == AF_INET6) {
				pool_put(&pf_binat_pl, newbinat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			if (newbinat->ifname[0]) {
				newbinat->ifp = ifunit(newbinat->ifname);
				if (newbinat->ifp == NULL) {
					pool_put(&pf_binat_pl, newbinat);
					error = EINVAL;
					break;
				}
			} else
				newbinat->ifp = NULL;
			if (pf_dynaddr_setup(&newbinat->saddr, newbinat->af) ||
			    pf_dynaddr_setup(&newbinat->daddr, newbinat->af) ||
			    pf_dynaddr_setup(&newbinat->raddr, newbinat->af)) {
				pf_dynaddr_remove(&newbinat->saddr);
				pf_dynaddr_remove(&newbinat->daddr);
				pf_dynaddr_remove(&newbinat->raddr);
				pool_put(&pf_binat_pl, newbinat);
				error = EINVAL;
				break;
			}
		}

		s = splsoftnet();

		if (pcn->action == PF_CHANGE_ADD_HEAD)
			oldbinat = TAILQ_FIRST(pf_binats_active);
		else if (pcn->action == PF_CHANGE_ADD_TAIL)
			oldbinat = TAILQ_LAST(pf_binats_active, pf_binatqueue);
		else {
			oldbinat = TAILQ_FIRST(pf_binats_active);
			while ((oldbinat != NULL) && pf_compare_binats(oldbinat,
			    &pcn->oldbinat))
				oldbinat = TAILQ_NEXT(oldbinat, entries);
			if (oldbinat == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcn->action == PF_CHANGE_REMOVE) {
			TAILQ_REMOVE(pf_binats_active, oldbinat, entries);
			pf_dynaddr_remove(&oldbinat->saddr);
			pf_dynaddr_remove(&oldbinat->daddr);
			pf_dynaddr_remove(&oldbinat->raddr);
			pool_put(&pf_binat_pl, oldbinat);
		} else {
			if (oldbinat == NULL)
				TAILQ_INSERT_TAIL(pf_binats_active, newbinat,
				    entries);
			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
			    pcn->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldbinat, newbinat,
				    entries);
			else
				TAILQ_INSERT_AFTER(pf_binats_active, oldbinat,
				    newbinat, entries);
		}

		ticket_binats_active++;
		splx(s);
		break;
	}

	case DIOCBEGINRDRS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_rdr *rdr;

		while ((rdr = TAILQ_FIRST(pf_rdrs_inactive)) != NULL) {
			TAILQ_REMOVE(pf_rdrs_inactive, rdr, entries);
			pf_dynaddr_remove(&rdr->saddr);
			pf_dynaddr_remove(&rdr->daddr);
			pf_dynaddr_remove(&rdr->raddr);
			pool_put(&pf_rdr_pl, rdr);
		}
		*ticket = ++ticket_rdrs_inactive;
		break;
	}

	case DIOCADDRDR: {
		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
		struct pf_rdr *rdr;

		if (pr->ticket != ticket_rdrs_inactive) {
			error = EBUSY;
			break;
		}
		rdr = pool_get(&pf_rdr_pl, PR_NOWAIT);
		if (rdr == NULL) {
			error = ENOMEM;
			break;
		}
		bcopy(&pr->rdr, rdr, sizeof(struct pf_rdr));
#ifndef INET
		if (rdr->af == AF_INET) {
			pool_put(&pf_rdr_pl, rdr);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (rdr->af == AF_INET6) {
			pool_put(&pf_rdr_pl, rdr);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
		if (rdr->ifname[0]) {
			rdr->ifp = ifunit(rdr->ifname);
			if (rdr->ifp == NULL) {
				pool_put(&pf_rdr_pl, rdr);
				error = EINVAL;
				break;
			}
		} else
			rdr->ifp = NULL;
		if (pf_dynaddr_setup(&rdr->saddr, rdr->af) ||
		    pf_dynaddr_setup(&rdr->daddr, rdr->af) ||
		    pf_dynaddr_setup(&rdr->raddr, rdr->af)) {
			pf_dynaddr_remove(&rdr->saddr);
			pf_dynaddr_remove(&rdr->daddr);
			pf_dynaddr_remove(&rdr->raddr);
			pool_put(&pf_rdr_pl, rdr);
			error = EINVAL;
			break;
		}
		TAILQ_INSERT_TAIL(pf_rdrs_inactive, rdr, entries);
		break;
	}

	case DIOCCOMMITRDRS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_rdrqueue *old_rdrs;
		struct pf_rdr *rdr;

		if (*ticket != ticket_rdrs_inactive) {
			error = EBUSY;
			break;
		}

		/* Swap rdrs, keep the old. */
		s = splsoftnet();
		old_rdrs = pf_rdrs_active;
		pf_rdrs_active = pf_rdrs_inactive;
		pf_rdrs_inactive = old_rdrs;
		ticket_rdrs_active = ticket_rdrs_inactive;
		splx(s);

		/* Purge the old rdr list */
		while ((rdr = TAILQ_FIRST(old_rdrs)) != NULL) {
			TAILQ_REMOVE(old_rdrs, rdr, entries);
			pf_dynaddr_remove(&rdr->saddr);
			pf_dynaddr_remove(&rdr->daddr);
			pf_dynaddr_remove(&rdr->raddr);
			pool_put(&pf_rdr_pl, rdr);
		}
		break;
	}

	case DIOCGETRDRS: {
		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
		struct pf_rdr *rdr;

		pr->nr = 0;
		s = splsoftnet();
		TAILQ_FOREACH(rdr, pf_rdrs_active, entries)
			pr->nr++;
		pr->ticket = ticket_rdrs_active;
		splx(s);
		break;
	}

	case DIOCGETRDR: {
		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
		struct pf_rdr *rdr;
		u_int32_t nr;

		if (pr->ticket != ticket_rdrs_active) {
			error = EBUSY;
			break;
		}
		nr = 0;
		s = splsoftnet();
		rdr = TAILQ_FIRST(pf_rdrs_active);
		while ((rdr != NULL) && (nr < pr->nr)) {
			rdr = TAILQ_NEXT(rdr, entries);
			nr++;
		}
		if (rdr == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(rdr, &pr->rdr, sizeof(struct pf_rdr));
		pf_dynaddr_copyout(&pr->rdr.saddr);
		pf_dynaddr_copyout(&pr->rdr.daddr);
		pf_dynaddr_copyout(&pr->rdr.raddr);
		splx(s);
		break;
	}

	case DIOCCHANGERDR: {
		struct pfioc_changerdr *pcn = (struct pfioc_changerdr *)addr;
		struct pf_rdr *oldrdr = NULL, *newrdr = NULL;

		if (pcn->action < PF_CHANGE_ADD_HEAD ||
		    pcn->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcn->action != PF_CHANGE_REMOVE) {
			newrdr = pool_get(&pf_rdr_pl, PR_NOWAIT);
			if (newrdr == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcn->newrdr, newrdr, sizeof(struct pf_rdr));
#ifndef INET
			if (newrdr->af == AF_INET) {
				pool_put(&pf_rdr_pl, newrdr);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newrdr->af == AF_INET6) {
				pool_put(&pf_rdr_pl, newrdr);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			if (newrdr->ifname[0]) {
				newrdr->ifp = ifunit(newrdr->ifname);
				if (newrdr->ifp == NULL) {
					pool_put(&pf_rdr_pl, newrdr);
					error = EINVAL;
					break;
				}
			} else
				newrdr->ifp = NULL;
			if (pf_dynaddr_setup(&newrdr->saddr, newrdr->af) ||
			    pf_dynaddr_setup(&newrdr->daddr, newrdr->af) ||
			    pf_dynaddr_setup(&newrdr->raddr, newrdr->af)) {
				pf_dynaddr_remove(&newrdr->saddr);
				pf_dynaddr_remove(&newrdr->daddr);
				pf_dynaddr_remove(&newrdr->raddr);
				pool_put(&pf_rdr_pl, newrdr);
				error = EINVAL;
				break;
			}
		}

		s = splsoftnet();

		if (pcn->action == PF_CHANGE_ADD_HEAD)
			oldrdr = TAILQ_FIRST(pf_rdrs_active);
		else if (pcn->action == PF_CHANGE_ADD_TAIL)
			oldrdr = TAILQ_LAST(pf_rdrs_active, pf_rdrqueue);
		else {
			oldrdr = TAILQ_FIRST(pf_rdrs_active);
			while ((oldrdr != NULL) && pf_compare_rdrs(oldrdr,
			    &pcn->oldrdr))
				oldrdr = TAILQ_NEXT(oldrdr, entries);
			if (oldrdr == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcn->action == PF_CHANGE_REMOVE) {
			TAILQ_REMOVE(pf_rdrs_active, oldrdr, entries);
			pf_dynaddr_remove(&oldrdr->saddr);
			pf_dynaddr_remove(&oldrdr->daddr);
			pf_dynaddr_remove(&oldrdr->raddr);
			pool_put(&pf_rdr_pl, oldrdr);
		} else {
			if (oldrdr == NULL)
				TAILQ_INSERT_TAIL(pf_rdrs_active, newrdr,
				    entries);
			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
			    pcn->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldrdr, newrdr, entries);
			else
				TAILQ_INSERT_AFTER(pf_rdrs_active, oldrdr,
				    newrdr, entries);
		}

		ticket_rdrs_active++;
		splx(s);
		break;
	}

	case DIOCCLRSTATES: {
		struct pf_tree_node *n;

		s = splsoftnet();
		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
			n->state->expire = 0;
		pf_purge_expired_states();
		pf_status.states = 0;
		splx(s);
		break;
	}

	case DIOCKILLSTATES: {
		struct pf_tree_node *n;
		struct pf_state *st;
		struct pfioc_state_kill *psk =
		    (struct pfioc_state_kill *)addr;
		int killed = 0;

		s = splsoftnet();
		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy) {
			st = n->state;
			if ((!psk->psk_af || st->af == psk->psk_af) &&
			    (!psk->psk_proto || psk->psk_proto == st->proto) &&
			    PF_MATCHA(psk->psk_src.not, &psk->psk_src.addr.addr,
			    &psk->psk_src.mask, &st->lan.addr, st->af) &&
			    PF_MATCHA(psk->psk_dst.not, &psk->psk_dst.addr.addr,
			    &psk->psk_dst.mask, &st->ext.addr, st->af) &&
			    (psk->psk_src.port_op == 0 ||
			    pf_match_port(psk->psk_src.port_op,
			    psk->psk_src.port[0], psk->psk_src.port[1],
			    st->lan.port)) &&
			    (psk->psk_dst.port_op == 0 ||
			    pf_match_port(psk->psk_dst.port_op,
			    psk->psk_dst.port[0], psk->psk_dst.port[1],
			    st->ext.port))) {
				st->expire = 0;
				killed++;
			}
		}
		pf_purge_expired_states();
		splx(s);
		psk->psk_af = killed;
		break;
	}

	case DIOCADDSTATE: {
		struct pfioc_state *ps = (struct pfioc_state *)addr;
		struct pf_state *state;

		state = pool_get(&pf_state_pl, PR_NOWAIT);
		if (state == NULL) {
			error = ENOMEM;
			break;
		}
		s = splsoftnet();
		bcopy(&ps->state, state, sizeof(struct pf_state));
		state->rule.ptr = NULL;
		state->creation = time.tv_sec;
		state->expire += state->creation;
		state->packets = 0;
		state->bytes = 0;
		if (pf_insert_state(state)) {
			pool_put(&pf_state_pl, state);
			error = ENOMEM;
		}
		splx(s);
	}

	case DIOCGETSTATE: {
		struct pfioc_state *ps = (struct pfioc_state *)addr;
		struct pf_tree_node *n;
		u_int32_t nr;
		int secs;

		nr = 0;
		s = splsoftnet();
		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy) {
			if (nr >= ps->nr)
				break;
			nr++;
		}
		if (n == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(n->state, &ps->state, sizeof(struct pf_state));
		if (n->state->rule.ptr == NULL)
			ps->state.rule.nr = -1;
		else
			ps->state.rule.nr = n->state->rule.ptr->nr;
		splx(s);
		secs = time.tv_sec;
		ps->state.creation = secs - ps->state.creation;
		if (ps->state.expire <= secs)
			ps->state.expire = 0;
		else
			ps->state.expire -= secs;
		break;
	}

	case DIOCGETSTATES: {
		struct pfioc_states *ps = (struct pfioc_states *)addr;
		struct pf_tree_node *n;
		struct pf_state *p, pstore;
		u_int32_t nr = 0;
		int space = ps->ps_len;

		if (space == 0) {
			s = splsoftnet();
			RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
				nr++;
			splx(s);
			ps->ps_len = sizeof(struct pf_state) * nr;
			return (0);
		}

		s = splsoftnet();
		p = ps->ps_states;
		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy) {
			int secs = time.tv_sec;

			if ((nr + 1) * sizeof(*p) > ps->ps_len)
				break;

			bcopy(n->state, &pstore, sizeof(pstore));
			if (n->state->rule.ptr == NULL)
				pstore.rule.nr = -1;
			else
				pstore.rule.nr = n->state->rule.ptr->nr;
			pstore.creation = secs - pstore.creation;
			if (pstore.expire <= secs)
				pstore.expire = 0;
			else
				pstore.expire -= secs;
			error = copyout(&pstore, p, sizeof(*p));
			if (error) {
				splx(s);
				goto fail;
			}
			p++;
			nr++;
		}
		ps->ps_len = sizeof(struct pf_state) * nr;
		splx(s);
		break;
	}

	case DIOCSETSTATUSIF: {
		struct pfioc_if *pi = (struct pfioc_if *)addr;
		struct ifnet *ifp;

		if ((ifp = ifunit(pi->ifname)) == NULL)
			error = EINVAL;
		else
			status_ifp = ifp;
		break;
	}

	case DIOCGETSTATUS: {
		struct pf_status *s = (struct pf_status *)addr;
		bcopy(&pf_status, s, sizeof(struct pf_status));
		break;
	}

	case DIOCCLRSTATUS: {
		u_int32_t running = pf_status.running;
		u_int32_t states = pf_status.states;
		u_int32_t since = pf_status.since;
		u_int32_t debug = pf_status.debug;

		bzero(&pf_status, sizeof(struct pf_status));
		pf_status.running = running;
		pf_status.states = states;
		pf_status.since = since;
		pf_status.debug = debug;
		break;
	}

	case DIOCNATLOOK: {
		struct pfioc_natlook *pnl = (struct pfioc_natlook *)addr;
		struct pf_state *st;
		struct pf_tree_node key;
		int direction = pnl->direction;

		key.af = pnl->af;
		key.proto = pnl->proto;

		/*
		 * userland gives us source and dest of connetion, reverse
		 * the lookup so we ask for what happens with the return
		 * traffic, enabling us to find it in the state tree.
		 */
		PF_ACPY(&key.addr[1], &pnl->saddr, pnl->af);
		key.port[1] = pnl->sport;
		PF_ACPY(&key.addr[0], &pnl->daddr, pnl->af);
		key.port[0] = pnl->dport;

		if (!pnl->proto ||
		    PF_AZERO(&pnl->saddr, pnl->af) ||
		    PF_AZERO(&pnl->daddr, pnl->af) ||
		    !pnl->dport || !pnl->sport)
			error = EINVAL;
		else {
			s = splsoftnet();
			if (direction == PF_IN)
				st = pf_find_state(&tree_ext_gwy, &key);
			else
				st = pf_find_state(&tree_lan_ext, &key);
			if (st != NULL) {
				if (direction  == PF_IN) {
					PF_ACPY(&pnl->rsaddr, &st->lan.addr,
					    st->af);
					pnl->rsport = st->lan.port;
					PF_ACPY(&pnl->rdaddr, &pnl->daddr,
					    pnl->af);
					pnl->rdport = pnl->dport;
				} else {
					PF_ACPY(&pnl->rdaddr, &st->gwy.addr,
					    st->af);
					pnl->rdport = st->gwy.port;
					PF_ACPY(&pnl->rsaddr, &pnl->saddr,
					    pnl->af);
					pnl->rsport = pnl->sport;
				}
			} else
				error = ENOENT;
			splx(s);
		}
		break;
	}

	case DIOCSETTIMEOUT: {
		struct pfioc_tm *pt = (struct pfioc_tm *)addr;
		int old;

		if (pt->timeout < 0 || pt->timeout >= PFTM_MAX ||
		    pt->seconds < 0) {
			error = EINVAL;
			goto fail;
		}
		old = *pftm_timeouts[pt->timeout];
		*pftm_timeouts[pt->timeout] = pt->seconds;
		pt->seconds = old;
		break;
	}

	case DIOCGETTIMEOUT: {
		struct pfioc_tm *pt = (struct pfioc_tm *)addr;

		if (pt->timeout < 0 || pt->timeout >= PFTM_MAX) {
			error = EINVAL;
			goto fail;
		}
		pt->seconds = *pftm_timeouts[pt->timeout];
		break;
	}

	case DIOCGETLIMIT: {
		struct pfioc_limit *pl = (struct pfioc_limit *)addr;

		if (pl->index < 0 || pl->index >= PF_LIMIT_MAX) {
			error = EINVAL;
			goto fail;
		}
		pl->limit = pf_pool_limits[pl->index].limit;
		break;
	}

	case DIOCSETLIMIT: {
		struct pfioc_limit *pl = (struct pfioc_limit *)addr;
		int old_limit;

		if (pl->index < 0 || pl->index >= PF_LIMIT_MAX) {
			error = EINVAL;
			goto fail;
		}
		if (pool_sethardlimit(pf_pool_limits[pl->index].pp,
		    pl->limit, NULL, 0) != 0) {
			error = EBUSY;
			goto fail;
		}
		old_limit = pf_pool_limits[pl->index].limit;
		pf_pool_limits[pl->index].limit = pl->limit;
		pl->limit = old_limit;
		break;
	}

	case DIOCSETDEBUG: {
		u_int32_t *level = (u_int32_t *)addr;
		pf_status.debug = *level;
		break;
	}

	case DIOCCLRRULECTRS: {
		struct pf_rule *rule;

		s = splsoftnet();
		TAILQ_FOREACH(rule, pf_rules_active, entries)
			rule->evaluations = rule->packets =
			    rule->bytes = 0;
		splx(s);
		break;
	}

	default:
		error = ENODEV;
		break;
	}
fail:

	return (error);
@


1.221
log
@in pf_route{6}, if too large for outgoing interface and not allowed to
fragment, send the proper icmp error.
- ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.220 2002/06/08 07:58:06 dhartmei Exp $ */
d5230 7
a5236 4
	} else if (r->rt != PF_DUPTO)
		icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
	else
		goto bad;
@


1.220
log
@Make state timeouts configurable per rule, like

  pass in from any to any port www keep state (tcp.established 60)

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.219 2002/06/07 22:53:37 pb Exp $ */
a5114 1
		error = EMSGSIZE;
d5116 6
a5121 1
		goto bad;
d5224 2
a5225 3
	 * Do not fragment packets (yet).  Not much is done here for dealing
	 * with errors.  Actions on errors depend on whether the packet
	 * was generated locally or being forwarded.
d5230 4
a5233 2
	} else
		m_freem(m0);
@


1.219
log
@
add the possibility to configure a TTL while return-rst

ok dhartmei@@, ipv6 part itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.218 2002/06/07 21:46:08 jasoni Exp $ */
d280 2
a281 1

d3250 1
a3250 1
		s->expire = s->creation + pftm_tcp_first_packet;
d3486 1
a3486 1
		s->expire = s->creation + pftm_udp_first_packet;
d3748 1
a3748 1
		s->expire = s->creation + pftm_icmp_first_packet;
d3956 1
a3956 1
		s->expire = s->creation + pftm_other_first_packet;
d4188 2
a4189 1
			(*state)->expire = time.tv_sec + pftm_tcp_closed;
d4192 2
a4193 1
			(*state)->expire = time.tv_sec + pftm_tcp_fin_wait;
d4196 2
a4197 1
			(*state)->expire = time.tv_sec + pftm_tcp_closing;
d4200 2
a4201 1
			(*state)->expire = time.tv_sec + pftm_tcp_opening;
d4203 2
a4204 1
			(*state)->expire = time.tv_sec + pftm_tcp_established;
d4358 2
a4359 1
		(*state)->expire = time.tv_sec + pftm_udp_multiple;
d4361 2
a4362 1
		(*state)->expire = time.tv_sec + pftm_udp_single;
d4447 2
a4448 1
		(*state)->expire = time.tv_sec + pftm_icmp_error_reply;
d4901 2
a4902 1
		(*state)->expire = time.tv_sec + pftm_other_multiple;
d4904 2
a4905 1
		(*state)->expire = time.tv_sec + pftm_other_single;
@


1.218
log
@in pf_route{6}, do not pass thru pf_test again if the outgoing
interface has not changed
- ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.217 2002/06/07 21:25:35 dhartmei Exp $ */
d208 1
a208 1
			    struct pf_pdesc *, int);
d2495 2
a2496 1
pf_send_reset(int off, struct tcphdr *th, struct pf_pdesc *pd, int af)
d2595 3
a2597 1
		h2->ip_ttl = ip_defttl;
d2611 3
a2613 1
		h2_6->ip6_hlim = 128;
d3159 2
a3160 1
				pf_send_reset(off, th, pd, af);
@


1.217
log
@Add "(max <number>)" option for "keep/modulate state" to limit the number
of concurrent connections a rule can create. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.216 2002/06/07 21:14:02 frantzen Exp $ */
d5055 4
a5058 9
	mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
	if (mtag == NULL) {
		if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		else {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
d5060 9
a5068 1
			m_tag_prepend(m0, mtag);
d5185 4
a5188 9
	mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
	if (mtag == NULL) {
		if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		else {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
d5190 9
a5198 1
			m_tag_prepend(m0, mtag);
@


1.216
log
@switch from AVL tree's to herr Provos' red-black trees
with suggestions from provos@@
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.215 2002/06/07 20:59:20 dhartmei Exp $ */
a630 1

d635 2
a636 1

d3171 1
a3171 1
		struct pf_state *s;
d3174 3
a3176 1
		s = pool_get(&pf_state_pl, PR_NOWAIT);
d3183 2
d3424 1
a3424 1
		struct pf_state *s;
d3426 3
a3428 1
		s = pool_get(&pf_state_pl, PR_NOWAIT);
d3434 2
d3693 1
a3693 1
		struct pf_state *s;
d3695 3
a3697 1
		s = pool_get(&pf_state_pl, PR_NOWAIT);
d3700 2
d3901 1
a3901 1
		struct pf_state *s;
d3903 3
a3905 1
		s = pool_get(&pf_state_pl, PR_NOWAIT);
d3908 2
@


1.215
log
@Call pf_test() from pf_route() to filter (and translate) routed packets,
too. Use mbuf tag to prevent loops. Suggested by Darren Reed. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.214 2002/06/07 18:45:59 pb Exp $ */
d84 1
a84 13

/*
 * Tree data structure
 */

struct pf_tree_node {
	struct pf_tree_key	 key;
	struct pf_state		*state;
	struct pf_tree_node	*parent;
	struct pf_tree_node	*left;
	struct pf_tree_node	*right;
	int			 balance;
};
a107 1
struct pf_tree_node	*tree_lan_ext, *tree_ext_gwy;
a164 2
int			 pf_tree_key_compare(struct pf_tree_key *,
			    struct pf_tree_key *);
d173 3
a175 7
void			 pf_tree_rotate_left(struct pf_tree_node **);
void			 pf_tree_rotate_right(struct pf_tree_node **);
struct pf_tree_node	*pf_tree_first(struct pf_tree_node *);
struct pf_tree_node	*pf_tree_next(struct pf_tree_node *);
struct pf_tree_node	*pf_tree_search(struct pf_tree_node *,
			    struct pf_tree_key *);
void			 pf_insert_state(struct pf_state *);
d280 10
a289 2
int
pf_tree_key_compare(struct pf_tree_key *a, struct pf_tree_key *b)
d291 1
a291 1
	register int diff;
a488 162
void
pf_tree_rotate_left(struct pf_tree_node **n)
{
	struct pf_tree_node *q = *n, *p = (*n)->parent;

	(*n)->parent = (*n)->right;
	*n = (*n)->right;
	(*n)->parent = p;
	q->right = (*n)->left;
	if (q->right)
		q->right->parent = q;
	(*n)->left = q;
	q->balance--;
	if ((*n)->balance > 0)
		q->balance -= (*n)->balance;
	(*n)->balance--;
	if (q->balance < 0)
		(*n)->balance += q->balance;
}

void
pf_tree_rotate_right(struct pf_tree_node **n)
{
	struct pf_tree_node *q = *n, *p = (*n)->parent;

	(*n)->parent = (*n)->left;
	*n = (*n)->left;
	(*n)->parent = p;
	q->left = (*n)->right;
	if (q->left)
		q->left->parent = q;
	(*n)->right = q;
	q->balance++;
	if ((*n)->balance < 0)
		q->balance -= (*n)->balance;
	(*n)->balance++;
	if (q->balance > 0)
		(*n)->balance += q->balance;
}

int
pf_tree_insert(struct pf_tree_node **n, struct pf_tree_node *p,
    struct pf_tree_key *key, struct pf_state *state)
{
	int deltaH = 0;

	if (*n == NULL) {
		*n = pool_get(&pf_tree_pl, PR_NOWAIT);
		if (*n == NULL)
			return (0);
		bcopy(key, &(*n)->key, sizeof(struct pf_tree_key));
		(*n)->state = state;
		(*n)->balance = 0;
		(*n)->parent = p;
		(*n)->left = (*n)->right = NULL;
		deltaH = 1;
	} else if (pf_tree_key_compare(key, &(*n)->key) > 0) {
		if (pf_tree_insert(&(*n)->right, *n, key, state)) {
			(*n)->balance++;
			if ((*n)->balance == 1)
				deltaH = 1;
			else if ((*n)->balance == 2) {
				if ((*n)->right->balance == -1)
					pf_tree_rotate_right(&(*n)->right);
				pf_tree_rotate_left(n);
			}
		}
	} else {
		if (pf_tree_insert(&(*n)->left, *n, key, state)) {
			(*n)->balance--;
			if ((*n)->balance == -1)
				deltaH = 1;
			else if ((*n)->balance == -2) {
				if ((*n)->left->balance == 1)
					pf_tree_rotate_left(&(*n)->left);
				pf_tree_rotate_right(n);
			}
		}
	}
	return (deltaH);
}

int
pf_tree_remove(struct pf_tree_node **n, struct pf_tree_node *p,
    struct pf_tree_key *key)
{
	int deltaH = 0;
	int c;

	if (*n == NULL)
		return (0);
	c = pf_tree_key_compare(key, &(*n)->key);
	if (c < 0) {
		if (pf_tree_remove(&(*n)->left, *n, key)) {
			(*n)->balance++;
			if ((*n)->balance == 0)
				deltaH = 1;
			else if ((*n)->balance == 2) {
				if ((*n)->right->balance == -1)
					pf_tree_rotate_right(&(*n)->right);
				pf_tree_rotate_left(n);
				if ((*n)->balance == 0)
					deltaH = 1;
			}
		}
	} else if (c > 0) {
		if (pf_tree_remove(&(*n)->right, *n, key)) {
			(*n)->balance--;
			if ((*n)->balance == 0)
				deltaH = 1;
			else if ((*n)->balance == -2) {
				if ((*n)->left->balance == 1)
					pf_tree_rotate_left(&(*n)->left);
				pf_tree_rotate_right(n);
				if ((*n)->balance == 0)
					deltaH = 1;
			}
		}
	} else {
		if ((*n)->right == NULL) {
			struct pf_tree_node *n0 = *n;

			*n = (*n)->left;
			if (*n != NULL)
				(*n)->parent = p;
			pool_put(&pf_tree_pl, n0);
			deltaH = 1;
		} else if ((*n)->left == NULL) {
			struct pf_tree_node *n0 = *n;

			*n = (*n)->right;
			if (*n != NULL)
				(*n)->parent = p;
			pool_put(&pf_tree_pl, n0);
			deltaH = 1;
		} else {
			struct pf_tree_node **qq = &(*n)->left;

			while ((*qq)->right != NULL)
				qq = &(*qq)->right;
			bcopy(&(*qq)->key, &(*n)->key,
			    sizeof(struct pf_tree_key));
			(*n)->state = (*qq)->state;
			bcopy(key, &(*qq)->key, sizeof(struct pf_tree_key));
			if (pf_tree_remove(&(*n)->left, *n, key)) {
				(*n)->balance++;
				if ((*n)->balance == 0)
					deltaH = 1;
				else if ((*n)->balance == 2) {
					if ((*n)->right->balance == -1)
						pf_tree_rotate_right(
						    &(*n)->right);
					pf_tree_rotate_left(n);
					if ((*n)->balance == 0)
						deltaH = 1;
				}
			}
		}
	}
	return (deltaH);
}

d532 2
a533 35
struct pf_tree_node *
pf_tree_first(struct pf_tree_node *n)
{
	if (n == NULL)
		return (NULL);
	while (n->parent)
		n = n->parent;
	while (n->left)
		n = n->left;
	return (n);
}

struct pf_tree_node *
pf_tree_next(struct pf_tree_node *n)
{
	if (n == NULL)
		return (NULL);
	if (n->right) {
		n = n->right;
		while (n->left)
			n = n->left;
	} else {
		if (n->parent && (n == n->parent->left))
			n = n->parent;
		else {
			while (n->parent && (n == n->parent->right))
				n = n->parent;
			n = n->parent;
		}
	}
	return (n);
}

struct pf_tree_node *
pf_tree_search(struct pf_tree_node *n, struct pf_tree_key *key)
d535 1
a535 1
	int c;
a536 5
	while (n && (c = pf_tree_key_compare(&n->key, key)))
		if (c > 0)
			n = n->left;
		else
			n = n->right;
d538 3
a540 9
	return (n);
}

struct pf_state *
pf_find_state(struct pf_tree_node *n, struct pf_tree_key *key)
{
	n = pf_tree_search(n, key);
	if (n)
		return (n->state);
d545 1
a545 1
void
d548 35
a582 2
	struct pf_tree_key key;
	struct pf_state *s;
a583 50
	key.af = state->af;
	key.proto = state->proto;
	PF_ACPY(&key.addr[0], &state->lan.addr, state->af);
	key.port[0] = state->lan.port;
	PF_ACPY(&key.addr[1], &state->ext.addr, state->af);
	key.port[1] = state->ext.port;
	/* sanity checks can be removed later, should never occur */
	if ((s = pf_find_state(tree_lan_ext, &key)) != NULL) {
		if (pf_status.debug >= PF_DEBUG_URGENT) {
			printf("pf: ERROR! insert invalid\n");
			printf("    key already in tree_lan_ext\n");
			printf("    key: proto = %u, lan = ", state->proto);
			pf_print_host(&key.addr[0], key.port[0], key.af);
			printf(", ext = ");
			pf_print_host(&key.addr[1], key.port[1], key.af);
			printf("\n    state: ");
			pf_print_state(s);
			printf("\n");
		}
	} else {
		pf_tree_insert(&tree_lan_ext, NULL, &key, state);
		if (pf_find_state(tree_lan_ext, &key) != state)
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf: ERROR! insert failed\n"));
	}

	key.af = state->af;
	key.proto = state->proto;
	PF_ACPY(&key.addr[0], &state->ext.addr, state->af);
	key.port[0] = state->ext.port;
	PF_ACPY(&key.addr[1], &state->gwy.addr, state->af);
	key.port[1] = state->gwy.port;
	if ((s = pf_find_state(tree_ext_gwy, &key)) != NULL) {
		if (pf_status.debug >= PF_DEBUG_URGENT) {
			printf("pf: ERROR! insert invalid\n");
			printf("    key already in tree_ext_gwy\n");
			printf("    key: proto = %u, ext = ", state->proto);
			pf_print_host(&key.addr[0], key.port[0], key.af);
			printf(", gwy = ");
			pf_print_host(&key.addr[1], key.port[1], key.af);
			printf("\n    state: ");
			pf_print_state(s);
			printf("\n");
		}
	} else {
		pf_tree_insert(&tree_ext_gwy, NULL, &key, state);
		if (pf_find_state(tree_ext_gwy, &key) != state)
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf: ERROR! insert failed\n"));
	}
d586 1
d606 5
a610 2
	struct pf_tree_node *cur, *next;
	struct pf_tree_key key;
a611 2
	cur = pf_tree_first(tree_ext_gwy);
	while (cur != NULL) {
d613 5
a618 1
			key.proto = cur->state->proto;
d625 8
a632 8
			/* remove state from second tree */
			if (pf_find_state(tree_lan_ext, &key) != cur->state)
				DPFPRINTF(PF_DEBUG_URGENT,
				    ("pf: ERROR: remove invalid!\n"));
			pf_tree_remove(&tree_lan_ext, NULL, &key);
			if (pf_find_state(tree_lan_ext, &key) != NULL)
				DPFPRINTF(PF_DEBUG_URGENT,
				    ("pf: ERROR: remove failed\n"));
d636 1
a636 1
			/* free state */
d638 2
a639 17
			/*
			 * remove state from tree being traversed, use next
			 * state's key to search after removal, since removal
			 * can invalidate pointers.
			 */
			next = pf_tree_next(cur);
			if (next) {
				key = next->key;
				pf_tree_remove(&tree_ext_gwy, NULL, &cur->key);
				cur = pf_tree_search(tree_ext_gwy, &key);
				if (cur == NULL)
					DPFPRINTF(PF_DEBUG_URGENT,
					    ("pf: ERROR: next not found\n"));
			} else {
				pf_tree_remove(&tree_ext_gwy, NULL, &cur->key);
				cur = NULL;
			}
d642 1
a642 2
		} else
			cur = pf_tree_next(cur);
d1087 1
a1087 2
		for (n = pf_tree_first(tree_ext_gwy); n != NULL;
		    n = pf_tree_next(n))
d1228 1
a1228 2
			for (n = pf_tree_first(tree_ext_gwy); n != NULL;
			    n = pf_tree_next(n))
d1953 1
a1953 2
		for (n = pf_tree_first(tree_ext_gwy); n != NULL;
		    n = pf_tree_next(n))
d1969 1
a1969 2
		for (n = pf_tree_first(tree_ext_gwy); n != NULL;
		    n = pf_tree_next(n)) {
d2011 4
a2014 1
		pf_insert_state(state);
d2026 3
a2028 3
		n = pf_tree_first(tree_ext_gwy);
		while ((n != NULL) && (nr < ps->nr)) {
			n = pf_tree_next(n);
d2060 1
a2060 3
			n = pf_tree_first(tree_ext_gwy);
			while (n != NULL) {
				n = pf_tree_next(n);
a2061 1
			}
d2069 1
a2069 2
		n = pf_tree_first(tree_ext_gwy);
		while (n && (nr + 1) * sizeof(*p) <= ps->ps_len) {
d2072 3
a2091 1
			n = pf_tree_next(n);
d2132 1
a2132 1
		struct pf_tree_key key;
d2156 1
a2156 1
				st = pf_find_state(tree_ext_gwy, &key);
d2158 1
a2158 1
				st = pf_find_state(tree_lan_ext, &key);
d3178 1
d3242 7
a3248 1
		pf_insert_state(s);
d3474 7
a3480 1
		pf_insert_state(s);
d3732 5
a3736 1
		pf_insert_state(s);
d3759 2
a3875 2
		u_short reason;

d3936 8
a3943 1
		pf_insert_state(s);
d4014 1
a4014 1
	struct pf_tree_key key;
d4021 2
a4022 2
	key.af	    = pd->af;
	key.proto   = IPPROTO_TCP;
d4029 1
a4029 1
		*state = pf_find_state(tree_ext_gwy, &key);
d4031 1
a4031 1
		*state = pf_find_state(tree_lan_ext, &key);
d4294 1
a4294 1
	struct pf_tree_key key;
d4297 2
a4298 2
	key.af	    = pd->af;
	key.proto   = IPPROTO_UDP;
d4305 1
a4305 1
		*state = pf_find_state(tree_ext_gwy, &key);
d4307 1
a4307 1
		*state = pf_find_state(tree_lan_ext, &key);
d4399 1
a4399 1
		struct pf_tree_key key;
d4401 2
a4402 2
		key.af      = pd->af;
		key.proto   = pd->proto;
d4409 1
a4409 1
			*state = pf_find_state(tree_ext_gwy, &key);
d4411 1
a4411 1
			*state = pf_find_state(tree_lan_ext, &key);
d4561 1
a4561 1
			struct pf_tree_key key;
d4576 1
a4576 1
			key.proto   = IPPROTO_TCP;
d4583 1
a4583 1
				*state = pf_find_state(tree_ext_gwy, &key);
d4585 1
a4585 1
				*state = pf_find_state(tree_lan_ext, &key);
d4655 1
a4655 1
			struct pf_tree_key key;
d4665 1
a4665 1
			key.proto   = IPPROTO_UDP;
d4672 1
a4672 1
				*state = pf_find_state(tree_ext_gwy, &key);
d4674 1
a4674 1
				*state = pf_find_state(tree_lan_ext, &key);
d4720 1
a4720 1
			struct pf_tree_key key;
d4730 1
a4730 1
			key.proto   = IPPROTO_ICMP;
d4737 1
a4737 1
				*state = pf_find_state(tree_ext_gwy, &key);
d4739 1
a4739 1
				*state = pf_find_state(tree_lan_ext, &key);
d4772 1
a4772 1
			struct pf_tree_key key;
d4782 1
a4782 1
			key.proto   = IPPROTO_ICMPV6;
d4789 1
a4789 1
				*state = pf_find_state(tree_ext_gwy, &key);
d4791 1
a4791 1
				*state = pf_find_state(tree_lan_ext, &key);
d4835 1
a4835 1
	struct pf_tree_key key;
d4837 2
a4838 2
	key.af	    = pd->af;
	key.proto   = pd->proto;
d4845 1
a4845 1
		*state = pf_find_state(tree_ext_gwy, &key);
d4847 1
a4847 1
		*state = pf_find_state(tree_lan_ext, &key);
@


1.214
log
@sync behaviour about DF bit between ip_output()/tcp_response()
and pf_send_reset() while sending a RST

ok dhartmei@@, itojun@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.213 2002/06/01 04:06:47 hugh Exp $ */
d5218 1
d5262 14
d5388 14
@


1.213
log
@ECN flag support for pf. Committed in consultation with Daniel.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.212 2002/05/31 20:58:25 itojun Exp $ */
d2844 1
a2844 1
		h2->ip_off = 0;
@


1.212
log
@respect rmx_mtu (cached PMTUD result) on outbound.  deraadt/angelos ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.211 2002/05/31 19:45:17 deraadt Exp $ */
d1092 4
@


1.211
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.210 2002/05/28 17:28:14 jasoni Exp $ */
d5289 1
a5289 1
	error = ip_fragment(m0, ifp);
@


1.210
log
@remove duplicated fragmentation code in favour of ip_fragment()..
- ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.209 2002/05/19 22:31:28 deraadt Exp $ */
d5302 1
a5302 1
	
@


1.209
log
@KNF again
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.208 2002/05/12 02:21:14 itojun Exp $ */
d5212 1
a5212 1
	struct ip *ip, *mhip;
d5215 1
a5215 1
	int len, off, error = 0;
d5287 4
a5290 3
	len = (ifp->if_mtu - hlen) &~ 7;
	if (len < 8) {
		error = EMSGSIZE;
a5291 9
	}
	/*
	 * If we are doing fragmentation, we can't defer TCP/UDP
	 * checksumming; compute the checksum and clear the flag.
	 */
	if (m0->m_pkthdr.csum & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
		in_delayed_cksum(m0);
		m0->m_pkthdr.csum &= ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
	}
d5293 8
a5300 86
	{
	    int mhlen, firstlen = len;
	    struct mbuf **mnext = &m0->m_nextpkt;

	    /*
	     * Loop through length of segment after first fragment,
	     * make new header and copy data of each part and link onto chain.
	     */
	    m1 = m0;
	    mhlen = sizeof (struct ip);
	    for (off = hlen + len; off < (u_int16_t)ip->ip_len; off += len) {
		    MGETHDR(m0, M_DONTWAIT, MT_HEADER);
		    if (m0 == 0) {
			    error = ENOBUFS;
			    ipstat.ips_odropped++;
			    goto sendorfree;
		    }
		    *mnext = m0;
		    mnext = &m0->m_nextpkt;
		    m0->m_data += max_linkhdr;
		    mhip = mtod(m0, struct ip *);
		    *mhip = *ip;
		    /* we must inherit MCAST and BCAST flags */
		    m0->m_flags |= m1->m_flags & (M_MCAST|M_BCAST);
		    if (hlen > sizeof (struct ip)) {
			    mhlen = ip_optcopy(ip, mhip) + sizeof (struct ip);
			    mhip->ip_hl = mhlen >> 2;
		    }
		    m0->m_len = mhlen;
		    mhip->ip_off = ((off - hlen) >> 3) + (ip->ip_off & ~IP_MF);
		    if (ip->ip_off & IP_MF)
			    mhip->ip_off |= IP_MF;
		    if (off + len >= (u_int16_t)ip->ip_len)
			    len = (u_int16_t)ip->ip_len - off;
		    else
			    mhip->ip_off |= IP_MF;
		    mhip->ip_len = htons((u_int16_t)(len + mhlen));
		    m0->m_next = m_copy(m1, off, len);
		    if (m0->m_next == 0) {
			    error = ENOBUFS;/* ??? */
			    ipstat.ips_odropped++;
			    goto sendorfree;
		    }
		    m0->m_pkthdr.len = mhlen + len;
		    m0->m_pkthdr.rcvif = (struct ifnet *)0;
		    mhip->ip_off = htons((u_int16_t)mhip->ip_off);
		    if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
			ifp->if_bridge == NULL) {
			    m0->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
			    ipstat.ips_outhwcsum++;
		    } else {
			    mhip->ip_sum = 0;
			    mhip->ip_sum = in_cksum(m0, mhlen);
		    }
		    ipstat.ips_ofragments++;
	    }
	    /*
	     * Update first fragment by trimming what's been copied out
	     * and updating header, then send each fragment (in order).
	     */
	    m0 = m1;
	    m_adj(m0, hlen + firstlen - (u_int16_t)ip->ip_len);
	    m0->m_pkthdr.len = hlen + firstlen;
	    ip->ip_len = htons((u_int16_t)m0->m_pkthdr.len);
	    ip->ip_off = htons((u_int16_t)(ip->ip_off | IP_MF));
	    if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		ifp->if_bridge == NULL) {
		    m0->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
		    ipstat.ips_outhwcsum++;
	    } else {
		    ip->ip_sum = 0;
		    ip->ip_sum = in_cksum(m0, hlen);
	    }
sendorfree:
	    for (m0 = m1; m0; m0 = m1) {
		    m1 = m0->m_nextpkt;
		    m0->m_nextpkt = 0;
		    if (error == 0)
			    error = (*ifp->if_output)(ifp, m0, sintosa(dst),
				NULL);
		    else
			    m_freem(m0);
	    }

	    if (error == 0)
		    ipstat.ips_fragmented++;
d5302 3
@


1.208
log
@correct AH header chasing.  ok dhartmei@@openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.207 2002/05/12 00:54:56 dhartmei Exp $ */
d943 1
a943 1
					changed = 1;		
d954 1
a954 1
					changed = 1;		
@


1.207
log
@Add gid based filtering, reduce to one (effective) uid, rename parser
keywords to 'user' and 'group'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.206 2002/05/09 19:58:42 dhartmei Exp $ */
a103 9
/* structure for ipsec and ipv6 option header template */
struct _opt6 {
	u_int8_t	opt6_nxt;	/* next header */
	u_int8_t	opt6_hlen;	/* header extension length */
	u_int16_t       _pad;
	u_int32_t       ah_spi;		/* security parameter index
					   for authentication header */
};

d4751 1
a4751 1
					struct _opt6 opt6;
d4759 5
a4763 2
					pd2.proto = opt6.opt6_nxt;
					off2 += (opt6.opt6_hlen + 1) * 8;
d5691 1
a5691 1
			struct _opt6 opt6;
d5702 5
a5706 2
			pd.proto = opt6.opt6_nxt;
			off += (opt6.opt6_hlen + 1) * 8;
@


1.206
log
@Introduce user based filtering. Rules can specify ruid and euid (real and
effective user ID) much like ports. The user of a packet is either the
user that opens an outgoing connection, the one that listens on a socket,
or 'unknown' if the firewall is not a connection endpoint (for forwarded
connections). Socket uid lookup code from jwk@@bug.it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.205 2002/05/05 21:40:22 dhartmei Exp $ */
d279 1
a279 1
int			 pf_user_lookup(uid_t *, uid_t *, int, int, int,
d2975 1
a2975 1
pf_match_uid(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t u)
d2983 8
d3206 1
a3206 1
pf_user_lookup(uid_t *ruid, uid_t *euid, int direction, int af, int proto,
d3214 2
a3215 1
	*ruid = *euid = UID_MAX;
d3251 2
a3252 2
	*ruid = inp->inp_socket->so_ruid;
	*euid = inp->inp_socket->so_euid;
d3266 3
a3268 2
	int xuid = -1;
	uid_t ruid, euid;
d3361 4
a3364 4
		else if (r->ruid.op && (xuid != -1 || (xuid =
		    pf_user_lookup(&ruid, &euid, direction, af, IPPROTO_TCP, pd),
		    1)) && !pf_match_uid(r->ruid.op, r->ruid.uid[0],
		    r->ruid.uid[1], ruid))
d3366 4
a3369 4
		else if (r->euid.op && (xuid != -1 || (xuid =
		    pf_user_lookup(&ruid, &euid, direction, af, IPPROTO_TCP, pd),
		    1)) && !pf_match_uid(r->euid.op, r->euid.uid[0],
		    r->euid.uid[1], euid))
d3513 3
a3515 2
	int xuid = -1;
	uid_t ruid, euid;
d3609 4
a3612 4
		else if (r->ruid.op && (xuid != -1 || (xuid =
		    pf_user_lookup(&ruid, &euid, direction, af, IPPROTO_UDP, pd),
		    1)) && !pf_match_uid(r->ruid.op, r->ruid.uid[0],
		    r->ruid.uid[1], ruid))
d3614 4
a3617 4
		else if (r->euid.op && (xuid != -1 || (xuid =
		    pf_user_lookup(&ruid, &euid, direction, af, IPPROTO_UDP, pd),
		    1)) && !pf_match_uid(r->euid.op, r->euid.uid[0],
		    r->euid.uid[1], euid))
@


1.205
log
@Instead of returning a useless kernel space pointer for the rule that
created the state from DIOCGETSTATE(S), return the integer rule number,
Print rule number (if existant) from pfctl -vss. Suggested by Jeff Nathan.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.204 2002/04/24 18:10:25 dhartmei Exp $ */
d43 1
d279 2
d2942 1
a2942 1
pf_match_port(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
a2943 3
	NTOHS(a1);
	NTOHS(a2);
	NTOHS(p);
d2966 17
d3197 49
d3256 3
a3259 1
	u_int16_t bport, nport = 0, af = pd->af;
d3351 10
d3503 2
d3597 10
@


1.204
log
@Add dynamic (in-kernel) interface name -> address translation. Instead of
using just the interface name instead of an address and reloading the rule
set whenever the interface changes its address, the interface name can be
put in parentheses, and the kernel will keep track of changes and update
rules. There is no additional cost for evaluating rules (per packet),
the cost occurs when an interface changes address (and the rules are
traversed and updated where necessary).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.203 2002/04/23 14:32:22 dhartmei Exp $ */
d1335 1
a1335 1
			n->state->rule = NULL;
d1477 2
a1478 2
				if (n->state->rule == oldrule)
					n->state->rule = NULL;
d2256 1
a2256 1
		state->rule = NULL;
d2284 4
d2324 4
d3345 1
a3345 1
		s->rule = *rm;
d3573 1
a3573 1
		s->rule = *rm;
d3829 1
a3829 1
		s->rule = *rm;
d4029 1
a4029 1
		s->rule = *rm;
d4409 3
a4411 3
	if ((*state)->rule != NULL) {
		(*state)->rule->packets++;
		(*state)->rule->bytes += pd->tot_len;
d4474 3
a4476 3
	if ((*state)->rule != NULL) {
		(*state)->rule->packets++;
		(*state)->rule->bytes += pd->tot_len;
d5030 3
a5032 3
	if ((*state)->rule != NULL) {
		(*state)->rule->packets++;
		(*state)->rule->bytes += pd->tot_len;
d5454 1
a5454 1
			r = s->rule;
d5472 1
a5472 1
			r = s->rule;
d5490 1
a5490 1
			r = s->rule;
d5504 1
a5504 1
			r = s->rule;
d5635 1
a5635 1
			r = s->rule;
d5653 1
a5653 1
			r = s->rule;
d5671 1
a5671 1
			r = s->rule;
@


1.203
log
@Allow explicit filtering of fragments when they are not reassembled.
Document fragment handling in the man page. Short version: if you're
scrubbing everything (as is recommended, in general), nothing changes.
If you want to deal with fragments manually, read the man page.
ok frantzen.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.202 2002/04/20 10:13:57 fgsch Exp $ */
d178 1
a178 1
struct pool		 pf_rdr_pl, pf_state_pl, pf_binat_pl;
d205 4
d412 6
a417 1
	if (memcmp(&a->src, &b->src, sizeof(struct pf_rule_addr)))
d419 6
a424 1
	if (memcmp(&a->dst, &b->dst, sizeof(struct pf_rule_addr)))
d441 1
a441 1
	if (PF_ANEQ(&a->saddr, &b->saddr, a->af))
d445 1
a445 1
	if (PF_ANEQ(&a->daddr, &b->daddr, a->af))
d449 1
a449 1
	if (PF_ANEQ(&a->raddr, &b->raddr, a->af))
d464 1
a464 1
	if (PF_ANEQ(&a->saddr, &b->saddr, a->af))
d466 1
a466 1
	if (PF_ANEQ(&a->daddr, &b->daddr, a->af))
d470 1
a470 1
	if (PF_ANEQ(&a->raddr, &b->raddr, a->af))
d491 1
a491 1
	if (PF_ANEQ(&a->saddr, &b->saddr, a->af))
d495 1
a495 1
	if (PF_ANEQ(&a->daddr, &b->daddr, a->af))
d499 1
a499 1
	if (PF_ANEQ(&a->raddr, &b->raddr, a->af))
d896 97
d1117 2
d1245 2
a1285 1
		rule->ifp = NULL;
d1304 8
d1346 2
d1386 2
a1423 1
			newrule->ifp = NULL;
d1431 2
a1432 2
			}
			newrule->rt_ifp = NULL;
d1440 9
d1480 2
d1510 3
d1557 10
d1591 3
d1635 3
a1672 1
			newnat->ifp = NULL;
d1680 11
d1713 3
d1741 3
d1787 10
d1822 3
d1865 3
a1903 1
			newbinat->ifp = NULL;
d1911 11
d1945 3
d1973 3
d2019 10
d2054 3
d2097 3
a2134 1
			newrdr->ifp = NULL;
d2142 11
d2176 3
d2223 1
a2223 1
			    PF_MATCHA(psk->psk_src.not, &psk->psk_src.addr,
d2225 1
a2225 1
			    PF_MATCHA(psk->psk_dst.not, &psk->psk_dst.addr,
d2539 3
a2541 1
			    PF_AEQ(&s->src.addr, &r->src.addr, r->af) &&
d2549 3
a2551 1
			    PF_AEQ(&s->dst.addr, &r->dst.addr, r->af) &&
d3068 6
a3073 2
		    PF_MATCHA(n->snot, &n->saddr, &n->smask, saddr, af) &&
		    PF_MATCHA(n->dnot, &n->daddr, &n->dmask, daddr, af))
d3078 2
a3079 1
	if (nm && nm->no)
d3098 6
a3103 2
		    PF_MATCHA(0, &b->saddr, &fullmask, saddr, af) &&
		    PF_MATCHA(b->dnot, &b->daddr, &b->dmask, daddr, af))
d3108 6
a3113 2
		    PF_MATCHA(0, &b->raddr, &fullmask, saddr, af) &&
		    PF_MATCHA(b->dnot, &b->daddr, &b->dmask, daddr, af))
d3120 6
d3141 6
a3146 2
		    PF_MATCHA(r->snot, &r->saddr, &r->smask, saddr, af) &&
		    PF_MATCHA(r->dnot, &r->daddr, &r->dmask, daddr, af) &&
d3154 2
a3155 1
	if (rm && rm->no)
d3196 1
a3196 1
			    &th->th_sum, &binat->raddr, th->th_sport, 0, af);
d3209 2
a3210 1
			    &th->th_sum, &nat->raddr, htons(nport), 0, af);
d3226 1
a3226 1
			    &th->th_sum, &rdr->raddr, nport, 0, af);
d3235 1
a3235 1
			    &th->th_sum, &binat->saddr, th->th_dport, 0, af);
d3257 1
a3257 1
		    &r->src.addr, &r->src.mask, saddr, af))
d3266 1
a3266 1
		    &r->dst.addr, &r->dst.mask, daddr, af))
d3430 1
a3430 1
			    &uh->uh_sum, &binat->raddr, uh->uh_sport, 1, af);
d3443 2
a3444 1
			    &uh->uh_sum, &nat->raddr, htons(nport), 1, af);
d3461 1
a3461 1
			    &uh->uh_sum, &rdr->raddr, nport, 1, af);
d3470 1
a3470 1
			    &uh->uh_sum, &binat->saddr, uh->uh_dport, 1, af);
d3492 1
a3492 1
		    !PF_MATCHA(r->src.not, &r->src.addr, &r->src.mask,
d3502 1
a3502 1
		    !PF_MATCHA(r->dst.not, &r->dst.addr, &r->dst.mask,
d3678 1
a3678 1
				    binat->raddr.v4.s_addr, 0);
d3684 1
a3684 1
				    &binat->raddr, 0);
d3698 1
a3698 1
				    pd->ip_sum, nat->raddr.v4.s_addr, 0);
d3704 1
a3704 1
				    &nat->raddr, 0);
d3719 1
a3719 1
				    pd->ip_sum, rdr->raddr.v4.s_addr, 0);
d3725 1
a3725 1
				    &rdr->raddr, 0);
d3739 1
a3739 1
				    pd->ip_sum, binat->saddr.v4.s_addr, 0);
d3745 1
a3745 1
				    &binat->saddr, 0);
d3770 1
a3770 1
		    &r->src.addr, &r->src.mask, saddr, af))
d3776 1
a3776 1
		    &r->dst.addr, &r->dst.mask, daddr, af))
d3897 1
a3897 1
				    binat->raddr.v4.s_addr, 0);
d3902 1
a3902 1
				PF_ACPY(saddr, &binat->raddr, af);
d3915 1
a3915 1
				    pd->ip_sum, nat->raddr.v4.s_addr, 0);
d3920 1
a3920 1
				PF_ACPY(saddr, &nat->raddr, af);
d3934 1
a3934 1
				    pd->ip_sum, rdr->raddr.v4.s_addr, 0);
d3939 1
a3939 1
				PF_ACPY(daddr, &rdr->raddr, af);
d3952 1
a3952 1
				    pd->ip_sum, binat->saddr.v4.s_addr, 0);
d3957 1
a3957 1
				PF_ACPY(daddr, &binat->saddr, af);
d3981 1
a3981 1
		    &r->src.addr, &r->src.mask, pd->src, af))
d3987 1
a3987 1
		    &r->dst.addr, &r->dst.mask, pd->dst, af))
d4094 1
a4094 1
		    &r->src.addr, &r->src.mask, pd->src, af))
d4100 1
a4100 1
		    &r->dst.addr, &r->dst.mask, pd->dst, af))
@


1.202
log
@All calls to pool_get(9) should use PR_xx flags, not M_xx.
millert dhartmei ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.201 2002/04/08 17:49:43 jason Exp $ */
d248 2
d3010 2
d3246 2
d3522 2
d3727 2
d3807 61
d5160 6
@


1.201
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.200 2002/03/31 13:02:08 dhartmei Exp $ */
d2737 1
a2737 1
	pnode = pool_get(&pf_sport_pl, M_NOWAIT);
@


1.201.2.1
log
@Pull in patch from current:
Fix (henning):
daddr was used where saddr was meant while checking incoming udp packets for
binat.
pointed out by Ryan McBride, mcbride at countersiege dot com, Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.201 2002/04/08 17:49:43 jason Exp $ */
d3200 1
a3200 1
		    daddr, saddr, af)) != NULL) {
@


1.200
log
@Use ip_defttl as ttl for return-rst instead of an arbitrary hardcoded
value (128). This matches the stack's default setting and honours
sysctl net.inet.ip.ttl, making RSTs generated by pf harder to
distinguish from RSTs sent by the real destination.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.199 2002/03/30 06:21:00 dhartmei Exp $ */
d30 4
@


1.199
log
@Initialize sequence number high limit from 1 to the real value with the
first packet. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.198 2002/03/27 18:16:21 mickey Exp $ */
d2593 1
a2593 1
		h2->ip_ttl = 128;
@


1.198
log
@implement a "no-route" keyword.
usage semantics are analogous w/ "any", meaning is
"any ip address for which there is no route in the
current routing table", could be used in both from and to.
typical usage would be (assuming symmetrical routing):
block in from no-route to any
also doc "any" in the pf.conf.5, include in regress, etc.
tested by me on i386 and sparc.
dhartmei@@ and frantzen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.197 2002/03/26 20:24:51 dhartmei Exp $ */
d3862 2
a3863 1
		if (SEQ_GEQ(end + MAX(1, dst->max_win), src->seqhi))
@


1.197
log
@Change default logging level from none to urgent. Should never print
anything, and if it does, it should be reported.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.196 2002/03/25 23:33:13 dhartmei Exp $ */
d2986 4
a2989 1
		else if (!PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
d2995 4
a2998 1
		else if (!PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
d3218 4
a3221 1
		else if (!PF_AZERO(&r->src.mask, af) &&
d3228 4
a3231 1
		else if (!PF_AZERO(&r->dst.mask, af) &&
d3494 4
a3497 1
		else if (!PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
d3500 4
a3503 1
		else if (!PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
d3703 4
a3706 1
		else if (!PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
d3709 4
a3712 1
		else if (!PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
d4737 24
@


1.196
log
@Ignore 'keep state' for ICMP errors whose inner headers mismatch state
but are passed by rules. Found by Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.195 2002/03/25 22:03:01 frantzen Exp $ */
d1025 1
@


1.195
log
@add ioctl DIOCKILLSTATES to shootdown a subset of the state table.  allows
discrimination on src/dst ips and netmask, src/dst port range and protocol.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.194 2002/03/08 11:32:52 mpech Exp $ */
d3347 1
d3360 7
d3374 6
d3519 2
a3520 2
	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL ||
	    rdr != NULL || binat != NULL) {
@


1.194
log
@Fix arc4random() usage; add more randomness to pf_get_sport().

dhartmei@@, provos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.193 2002/02/26 07:25:33 dhartmei Exp $ */
d1968 35
@


1.193
log
@Add optional pool memory hard limits, mainly as temporary solution
until pool exhaustion causes problems no more.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.192 2002/02/23 00:03:58 art Exp $ */
d2751 1
a2751 1
		cut = arc4random() % (high - low) + low;
d2754 1
a2754 1
		cut = arc4random() % (low - high) + high;
@


1.192
log
@Pools that are only used in the ioctls can use the nointr allocator.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.191 2002/02/17 21:48:05 dhartmei Exp $ */
d176 6
d1069 1
d1072 1
a1072 1
			return EPERM;
d1089 1
d2172 30
@


1.191
log
@Calculate IP checksum and copyback modified headers before logging a
packet. Closes PR2402. Note that checksums were only wrong in the
logged packet, packets that were passed got a valid checksum anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.190 2002/02/15 15:42:52 art Exp $ */
d983 1
a983 1
	    NULL);
d985 1
a985 1
	    NULL);
d987 1
a987 1
	    NULL);
d989 1
a989 1
	    NULL);
@


1.190
log
@pf only uses seconds for time measuring. There is no need to call microtime
on every packet. Use time.tv_sec to get seconds. In the places where
it seemed to matter, make sure that time doesn't change under our feet.

And it's really unnecessary to do a test on every packet when the test will
only fire once every 10 seconds. That's a real waste of time, that's
what we have timeouts for.

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.189 2002/02/14 19:46:49 deraadt Exp $ */
d662 10
d2939 3
a2941 2
		/* XXX will log packet before rewrite */
		if ((*rm)->log)
d2943 1
d3165 3
a3167 2
		/* XXX will log packet before rewrite */
		if ((*rm)->log)
d3169 1
d3419 6
a3424 2
		/* XXX will log packet before rewrite */
		if ((*rm)->log)
d3426 1
@


1.189
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.188 2002/02/14 15:32:11 dhartmei Exp $ */
a124 1
struct timeval		 pftv;
a127 1
u_int32_t		 pf_last_purge;
d161 1
d194 1
d793 14
d814 1
a814 1
		if (cur->state->expire <= pftv.tv_sec) {
d1005 3
d1087 1
a1087 2
			microtime(&pftv);
			pf_status.since = pftv.tv_sec;
a1962 1
		microtime(&pftv);
d1965 2
a1966 2
		state->creation = pftv.tv_sec;
		state->expire += pftv.tv_sec;
d1977 1
d1993 3
a1995 3
		microtime(&pftv);
		ps->state.creation = pftv.tv_sec - ps->state.creation;
		if (ps->state.expire <= pftv.tv_sec)
d1998 1
a1998 1
			ps->state.expire -= pftv.tv_sec;
a2020 1
		microtime(&pftv);
d2025 2
d2028 2
a2029 2
			pstore.creation = pftv.tv_sec - pstore.creation;
			if (pstore.expire <= pftv.tv_sec)
d2032 1
a2032 1
				pstore.expire -= pftv.tv_sec;
d3032 2
a3033 2
		s->creation = pftv.tv_sec;
		s->expire = pftv.tv_sec + pftm_tcp_first_packet;
d3234 2
a3235 2
		s->creation = pftv.tv_sec;
		s->expire = pftv.tv_sec + pftm_udp_first_packet;
d3459 2
a3460 2
		s->creation = pftv.tv_sec;
		s->expire = pftv.tv_sec + pftm_icmp_first_packet;
d3651 2
a3652 2
		s->creation = pftv.tv_sec;
		s->expire = pftv.tv_sec + pftm_other_first_packet;
d3815 1
a3815 1
			(*state)->expire = pftv.tv_sec + pftm_tcp_closed;
d3818 1
a3818 1
			(*state)->expire = pftv.tv_sec + pftm_tcp_fin_wait;
d3821 1
a3821 1
			(*state)->expire = pftv.tv_sec + pftm_tcp_closing;
d3824 1
a3824 1
			(*state)->expire = pftv.tv_sec + pftm_tcp_opening;
d3826 1
a3826 1
			(*state)->expire = pftv.tv_sec + pftm_tcp_established;
d3980 1
a3980 1
		(*state)->expire = pftv.tv_sec + pftm_udp_multiple;
d3982 1
a3982 1
		(*state)->expire = pftv.tv_sec + pftm_udp_single;
d4067 1
a4067 1
		(*state)->expire = pftv.tv_sec + pftm_icmp_error_reply;
d4517 1
a4517 1
		(*state)->expire = pftv.tv_sec + pftm_other_multiple;
d4519 1
a4519 1
		(*state)->expire = pftv.tv_sec + pftm_other_single;
a4899 8
	/* purge expire states */
	microtime(&pftv);
	if (pftv.tv_sec - pf_last_purge >= pftm_interval) {
		pf_purge_expired_states();
		pf_purge_expired_fragments();
		pf_last_purge = pftv.tv_sec;
	}

a5057 8

	/* purge expire states */
	microtime(&pftv);
	if (pftv.tv_sec - pf_last_purge >= pftm_interval) {
		pf_purge_expired_states();
		pf_purge_expired_fragments();
		pf_last_purge = pftv.tv_sec;
	}
@


1.188
log
@Add skip steps for rule action (pass/block vs. scrub) and direction
(in vs. out). This speeds up rule set evaluation considerably, because
the rules set used to be linearly traversed (even twice) when looking
for scrub rules. Ok frantzen@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.187 2002/02/11 16:22:48 dhartmei Exp $ */
d3904 1
a3904 1
		 	   (*state)->gwy.port, 0, pd->af);
d4059 1
a4059 1
				    	    pd->ip_sum,
@


1.187
log
@Remove unused function prototype, from Jason Ish
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.186 2002/02/11 16:21:26 dhartmei Exp $ */
d2191 3
d2195 2
a2873 4
		if (r->action == PF_SCRUB) {
			r = TAILQ_NEXT(r, entries);
			continue;
		}
d2875 3
a2877 1
		if (r->ifp != NULL && r->ifp != ifp)
d2879 2
a2896 2
		else if (r->direction != direction)
			r = TAILQ_NEXT(r, entries);
a3097 4
		if (r->action == PF_SCRUB) {
			r = TAILQ_NEXT(r, entries);
			continue;
		}
d3099 3
a3101 2

		if (r->ifp != NULL && r->ifp != ifp)
d3103 2
a3122 2
		else if (r->direction != direction)
			r = TAILQ_NEXT(r, entries);
a3351 4
		if (r->action == PF_SCRUB) {
			r = TAILQ_NEXT(r, entries);
			continue;
		}
d3353 3
a3355 1
		if (r->ifp != NULL && r->ifp != ifp)
d3357 2
a3368 2
		else if (r->direction != direction)
			r = TAILQ_NEXT(r, entries);
a3549 4
		if (r->action == PF_SCRUB) {
			r = TAILQ_NEXT(r, entries);
			continue;
		}
d3551 3
a3553 1
		if (r->ifp != NULL && r->ifp != ifp)
d3555 2
a3566 2
		else if (r->direction != direction)
			r = TAILQ_NEXT(r, entries);
@


1.186
log
@Remove ancient comment regarding memcmp(), from Jason Ish
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.185 2002/01/23 00:39:48 art Exp $ */
a178 2
int			 pf_compare_addr(struct pf_addr *, struct pf_addr *,
			    u_int8_t);
@


1.185
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.184 2002/01/12 01:34:49 jasoni Exp $ */
a295 4
	/*
	 * could use memcmp(), but with the best manual order, we can
	 * minimize the average number of compares. what is faster?
	 */
@


1.184
log
@- Only apply fastroute and route-to if we are going in the same
direction as the rule.
- ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.183 2002/01/09 11:30:53 dhartmei Exp $ */
a961 1
	/* XXX - no M_* tags, but they are not used anyway */
d963 1
a963 1
	    0, NULL, NULL, 0);
d965 1
a965 1
	    0, NULL, NULL, 0);
d967 1
a967 1
	    0, NULL, NULL, 0);
d969 1
a969 1
	    0, NULL, NULL, 0);
d971 1
a971 1
	    0, NULL, NULL, 0);
d973 1
a973 1
	    0, NULL, NULL, 0);
d975 1
a975 1
	    0, NULL, NULL, 0);
@


1.183
log
@Add labels to rules. These are arbitrary names (not to be confused with
tags that will be used to tag packets later on). Add pfctl -z to clear
per-rule counters. Add pfctl -s labels to output per-rule counters in
terse format and only for rules that have labels. Suggested by
Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.182 2002/01/08 09:31:55 dhartmei Exp $ */
d262 2
a263 2
void			 pf_route(struct mbuf *, struct pf_rule *);
void			 pf_route6(struct mbuf *, struct pf_rule *);
d4604 1
a4604 1
pf_route(struct mbuf *m, struct pf_rule *r)
a4614 3
	if (m == NULL)
		return;

d4616 1
a4616 1
		m0 = m_copym2(m, 0, M_COPYALL, M_NOWAIT);
d4619 5
a4623 2
	} else
		m0 = m;
d4788 2
d4802 1
a4802 1
pf_route6(struct mbuf *m, struct pf_rule *r)
d4817 1
a4817 1
		m0 = m_copym2(m, 0, M_COPYALL, M_NOWAIT);
d4820 5
a4824 2
	} else
		m0 = m;
d4863 2
d5032 3
a5034 8
	/* pf_route can free the mbuf causing *m to become NULL */
	if (r && r->rt) {
		pf_route(m, r);
		if (r->rt != PF_DUPTO) {
			/* m0 already freed */
			*m0 = NULL;
		}
	}
d5209 3
a5211 8
	/* pf_route6 can free the mbuf causing *m to become NULL */
	if (r && r->rt) {
		pf_route6(m, r);
		if (r->rt != PF_DUPTO) {
			/* m0 already freed */
			*m0 = NULL;
		}
	}
@


1.182
log
@Add "no nat/rdr/binat" to nat.conf. The first matching rule applies.
If it is a "no" rule, no translation occurs. Useful to exclude certain
packets from translation. Suggested by Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.181 2001/12/31 16:46:39 mickey Exp $ */
d1042 1
d2150 11
@


1.181
log
@only require write mode for modifying ioctls; dhartmei@@, frantzen@@, deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.180 2001/12/18 00:14:20 jasoni Exp $ */
d418 2
a419 1
	    a->ifnot != b->ifnot)
d439 5
a451 4
	if (a->proto != b->proto ||
	    a->dnot != b->dnot ||
	    a->af != b->af)
		return (1);
d468 2
a469 1
	    a->opts != b->opts)
d2721 2
d2752 2
d2778 2
@


1.180
log
@Update rt_ifp in DIOCCHANGERULE.
- noticed by DJ Gregor <gregor.7@@osu.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.179 2001/12/11 03:08:47 jasoni Exp $ */
a1019 3
	if (!(flags & FWRITE))
		return (EACCES);

d1042 19
@


1.180.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.185 2002/01/23 00:39:48 art Exp $ */
d262 2
a263 2
void			 pf_route(struct mbuf **, struct pf_rule *, int);
void			 pf_route6(struct mbuf **, struct pf_rule *, int);
d418 1
a418 2
	    a->ifnot != b->ifnot ||
	    a->no != b->no)
a437 5
	if (a->proto != b->proto ||
	    a->dnot != b->dnot ||
	    a->af != b->af ||
	    a->no != b->no)
		return (1);
d446 4
d466 1
a466 2
	    a->opts != b->opts ||
	    a->no != b->no)
d959 1
d961 1
a961 1
	    NULL);
d963 1
a963 1
	    NULL);
d965 1
a965 1
	    NULL);
d967 1
a967 1
	    NULL);
d969 1
a969 1
	    NULL);
d971 1
a971 1
	    NULL);
d973 1
a973 1
	    NULL);
d1020 3
a1041 1
		case DIOCCLRRULECTRS:
a1046 19
	if (!(flags & FWRITE))
		switch (cmd) {
		case DIOCGETRULES:
		case DIOCGETRULE:
		case DIOCGETNATS:
		case DIOCGETNAT:
		case DIOCGETRDRS:
		case DIOCGETRDR:
		case DIOCGETSTATE:
		case DIOCGETSTATUS:
		case DIOCGETSTATES:
		case DIOCGETTIMEOUT:
		case DIOCGETBINATS:
		case DIOCGETBINAT:
			break;
		default:
			return (EACCES);
		}

a2132 11
	case DIOCCLRRULECTRS: {
		struct pf_rule *rule;

		s = splsoftnet();
		TAILQ_FOREACH(rule, pf_rules_active, entries)
			rule->evaluations = rule->packets =
			    rule->bytes = 0;
		splx(s);
		break;
	}

a2701 2
	if (nm && nm->no)
		return (NULL);
a2730 2
	if (bm && bm->no)
		return (NULL);
a2754 2
	if (rm && rm->no)
		return (NULL);
d4567 1
a4567 1
pf_route(struct mbuf **m, struct pf_rule *r, int dir)
d4578 3
d4582 1
a4582 1
		m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT);
d4585 2
a4586 5
	} else {
		if (r->direction != dir)
			return;
		m0 = *m;
	}
a4750 2
	if (r->rt != PF_DUPTO)
		*m = NULL;
d4763 1
a4763 1
pf_route6(struct mbuf **m, struct pf_rule *r, int dir)
d4778 1
a4778 1
		m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT);
d4781 2
a4782 5
	} else {
		if (r->direction != dir)
			return;
		m0 = *m;
	}
a4820 2
	if (r->rt != PF_DUPTO)
		*m = NULL;
d4988 8
a4995 3
	/* pf_route can free the mbuf causing *m0 to become NULL */
	if (r && r->rt)
		pf_route(m0, r, dir);
d5170 8
a5177 3
	/* pf_route6 can free the mbuf causing *m0 to become NULL */
	if (r && r->rt)
		pf_route6(m0, r, dir);
@


1.180.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.180.2.1 2002/01/31 22:55:44 niklas Exp $ */
a30 4
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d37 1
a38 1
#include <sys/socketvar.h>
d79 28
a106 1
struct pf_state_tree;
d112 3
d124 2
d129 1
a162 1
struct timeout		 pf_expire_to;			/* expire timeout */
d175 1
a175 1
struct pool		 pf_rdr_pl, pf_state_pl, pf_binat_pl, pf_addr_pl;
d177 4
d189 7
a195 3
int		 	 pf_insert_state(struct pf_state *);
struct pf_state 	*pf_find_state(struct pf_state_tree *,
			    struct pf_tree_node *);
a196 5
void			 pf_purge_timeout(void *);
int			 pf_dynaddr_setup(struct pf_addr_wrap *, u_int8_t);
void			 pf_dynaddr_update(void *);
void			 pf_dynaddr_remove(struct pf_addr_wrap *);
void			 pf_dynaddr_copyout(struct pf_addr_wrap *);
d202 5
d223 1
a223 1
			    struct pf_pdesc *, int, u_int8_t);
a239 2
int			 pf_test_fragment(struct pf_rule **, int, struct ifnet *,
			    struct mbuf *, void *, struct pf_pdesc *);
a263 5
int			 pf_socket_lookup(uid_t *, gid_t *, int, int, int,
			     struct pf_pdesc *);
struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] = { { &pf_state_pl, UINT_MAX },
	{ &pf_frent_pl, PFFRAG_FRENT_HIWAT } };

d291 2
a292 16
#define TIMEOUT(r,i) \
	(((r) && (r)->timeout[(i)]) ? (r)->timeout[(i)] : *pftm_timeouts[(i)])

static __inline int pf_state_compare(struct pf_tree_node *,
			struct pf_tree_node *);

struct pf_state_tree tree_lan_ext, tree_ext_gwy;
RB_GENERATE(pf_state_tree, pf_tree_node, entry, pf_state_compare);

struct pf_rulequeue		 pf_rules[2];
struct pf_natqueue		 pf_nats[2];
struct pf_binatqueue		 pf_binats[2];
struct pf_rdrqueue		 pf_rdrs[2];

static __inline int
pf_state_compare(struct pf_tree_node *a, struct pf_tree_node *b)
d294 1
a294 1
	int diff;
d296 4
d402 1
a402 6
	if (PF_ANEQ(&a->src.addr.addr, &b->src.addr.addr, a->af) ||
	    PF_ANEQ(&a->src.mask, &b->src.mask, a->af) ||
	    a->src.port[0] != b->src.port[0] ||
	    a->src.port[1] != b->src.port[1] ||
	    a->src.not != b->src.not ||
	    a->src.port_op != b->src.port_op)
d404 1
a404 6
	if (PF_ANEQ(&a->dst.addr.addr, &b->dst.addr.addr, a->af) ||
	    PF_ANEQ(&a->dst.mask, &b->dst.mask, a->af) ||
	    a->dst.port[0] != b->dst.port[0] ||
	    a->dst.port[1] != b->dst.port[1] ||
	    a->dst.not != b->dst.not ||
	    a->dst.port_op != b->dst.port_op)
d421 1
a421 1
	if (PF_ANEQ(&a->saddr.addr, &b->saddr.addr, a->af))
d425 1
a425 1
	if (PF_ANEQ(&a->daddr.addr, &b->daddr.addr, a->af))
d429 1
a429 1
	if (PF_ANEQ(&a->raddr.addr, &b->raddr.addr, a->af))
d444 1
a444 1
	if (PF_ANEQ(&a->saddr.addr, &b->saddr.addr, a->af))
d446 1
a446 1
	if (PF_ANEQ(&a->daddr.addr, &b->daddr.addr, a->af))
d450 1
a450 1
	if (PF_ANEQ(&a->raddr.addr, &b->raddr.addr, a->af))
d471 1
a471 1
	if (PF_ANEQ(&a->saddr.addr, &b->saddr.addr, a->af))
d475 1
a475 1
	if (PF_ANEQ(&a->daddr.addr, &b->daddr.addr, a->af))
d479 1
a479 1
	if (PF_ANEQ(&a->raddr.addr, &b->raddr.addr, a->af))
d486 162
a667 10
#ifdef INET
	if (af == AF_INET && dir == PF_OUT) {
		struct ip *ip;

		ip = mtod(m, struct ip *);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	}
#endif /* INET */

d681 2
a682 2
struct pf_state *
pf_find_state(struct pf_state_tree *tree, struct pf_tree_node *key)
d684 8
a691 1
	struct pf_tree_node *k;
d693 4
a696 5
	pf_status.fcounters[FCNT_STATE_SEARCH]++;
	k = RB_FIND(pf_state_tree, tree, key);
	if (k)
		return (k->state);
	else
d698 14
d714 2
a715 2
int
pf_insert_state(struct pf_state *state)
d717 1
a717 1
	struct pf_tree_node *keya, *keyb;
d719 8
a726 30
	keya = pool_get(&pf_tree_pl, PR_NOWAIT);
	if (keya == NULL)
		return -1;
	keya->state = state;
	keya->proto = state->proto;
	keya->af = state->af;
	PF_ACPY(&keya->addr[0], &state->lan.addr, state->af);
	keya->port[0] = state->lan.port;
	PF_ACPY(&keya->addr[1], &state->ext.addr, state->af);
	keya->port[1] = state->ext.port;

	/* Thou MUST NOT insert multiple duplicate keys */
	if (RB_INSERT(pf_state_tree, &tree_lan_ext, keya) != NULL)
		panic("Multiple identical states in PF state table");


	keyb = pool_get(&pf_tree_pl, PR_NOWAIT);
	if (keyb == NULL) {
		/* Need to pull out the other state */
		RB_REMOVE(pf_state_tree, &tree_lan_ext, keya);
		pool_put(&pf_tree_pl, keya);
		return -1;
	}
	keyb->state = state;
	keyb->proto = state->proto;
	keyb->af = state->af;
	PF_ACPY(&keyb->addr[0], &state->ext.addr, state->af);
	keyb->port[0] = state->ext.port;
	PF_ACPY(&keyb->addr[1], &state->gwy.addr, state->af);
	keyb->port[1] = state->gwy.port;
d728 8
a735 6
	if (RB_INSERT(pf_state_tree, &tree_ext_gwy, keyb) != NULL)
		panic("Multiple identical states in PF state table");

	pf_status.fcounters[FCNT_STATE_INSERT]++;
	pf_status.states++;
	return 0;
d739 1
a739 1
pf_purge_timeout(void *arg)
d741 2
a742 2
	struct timeout *to = arg;
	int s;
d744 52
a795 6
	s = splsoftnet();
	pf_purge_expired_states();
	pf_purge_expired_fragments();
	splx(s);

	timeout_add(to, pftm_interval * hz);
d801 2
a802 2
	struct pf_tree_node *cur, *peer, *next;
	struct pf_tree_node key;
d804 4
a807 8
	for (cur = RB_MIN(pf_state_tree, &tree_ext_gwy); cur; cur = next) {
		next = RB_NEXT(pf_state_tree, &tree_ext_gwy, cur);

		if (cur->state->expire <= time.tv_sec) {
			RB_REMOVE(pf_state_tree, &tree_ext_gwy, cur);

			/* Need this key's peer (in the other tree) */
			key.state = cur->state;
a808 1
			key.af = cur->state->af;
d815 8
a822 7

			peer = RB_FIND(pf_state_tree, &tree_lan_ext, &key);
			KASSERT(peer);
			KASSERT(peer->state == cur->state);
			RB_REMOVE(pf_state_tree, &tree_lan_ext, peer);

			/* release NAT resources */
d826 1
a826 2
			if (cur->state->rule.ptr != NULL)
				cur->state->rule.ptr->states--;
d828 17
a844 2
			pool_put(&pf_tree_pl, cur);
			pool_put(&pf_tree_pl, peer);
d847 2
a848 30
		}
	}
}

int
pf_dynaddr_setup(struct pf_addr_wrap *aw, u_int8_t af)
{
	if (aw->addr_dyn == NULL)
		return (0);
	aw->addr_dyn = pool_get(&pf_addr_pl, PR_NOWAIT);
	if (aw->addr_dyn == NULL)
		return (1);
	bcopy(aw->addr.pfa.ifname, aw->addr_dyn->ifname,
	    sizeof(aw->addr_dyn->ifname));
	aw->addr_dyn->ifp = ifunit(aw->addr_dyn->ifname);
	if (aw->addr_dyn->ifp == NULL) {
		pool_put(&pf_addr_pl, aw->addr_dyn);
		aw->addr_dyn = NULL;
		return (1);
	}
	aw->addr_dyn->addr = &aw->addr;
	aw->addr_dyn->af = af;
	aw->addr_dyn->undefined = 1;
	aw->addr_dyn->hook_cookie = hook_establish(
	    aw->addr_dyn->ifp->if_addrhooks, 1,
	    pf_dynaddr_update, aw->addr_dyn);
	if (aw->addr_dyn->hook_cookie == NULL) {
		pool_put(&pf_addr_pl, aw->addr_dyn);
		aw->addr_dyn = NULL;
		return (1);
a849 68
	pf_dynaddr_update(aw->addr_dyn);
	return (0);
}

void
pf_dynaddr_update(void *p)
{
	struct pf_addr_dyn *ad = (struct pf_addr_dyn *)p;
	struct ifaddr *ia;
	int s, changed = 0;

	if (ad == NULL || ad->ifp == NULL)
		panic("pf_dynaddr_update");
	s = splsoftnet();
	TAILQ_FOREACH(ia, &ad->ifp->if_addrlist, ifa_list)
		if (ia->ifa_addr != NULL &&
		    ia->ifa_addr->sa_family == ad->af) {
			if (ad->af == AF_INET) {
				struct in_addr *a, *b;

				a = &ad->addr->v4;
				b = &((struct sockaddr_in *)ia->ifa_addr)
				    ->sin_addr;
				if (ad->undefined ||
				    memcmp(a, b, sizeof(*a))) {
					bcopy(b, a, sizeof(*a));
					changed = 1;
				}
			} else if (ad->af == AF_INET6) {
				struct in6_addr *a, *b;

				a = &ad->addr->v6;
				b = &((struct sockaddr_in6 *)ia->ifa_addr)
				    ->sin6_addr;
				if (ad->undefined ||
				    memcmp(a, b, sizeof(*a))) {
					bcopy(b, a, sizeof(*a));
					changed = 1;
				}
			}
			if (changed)
				ad->undefined = 0;
			break;
		}
	if (ia == NULL)
		ad->undefined = 1;
	splx(s);
}

void
pf_dynaddr_remove(struct pf_addr_wrap *aw)
{
	if (aw->addr_dyn == NULL)
		return;
	hook_disestablish(aw->addr_dyn->ifp->if_addrhooks,
	    aw->addr_dyn->hook_cookie);
	pool_put(&pf_addr_pl, aw->addr_dyn);
	aw->addr_dyn = NULL;
}

void
pf_dynaddr_copyout(struct pf_addr_wrap *aw)
{
	if (aw->addr_dyn == NULL)
		return;
	bcopy(aw->addr_dyn->ifname, aw->addr.pfa.ifname,
	    sizeof(aw->addr.pfa.ifname));
	aw->addr_dyn = (struct pf_addr_dyn *)1;
d909 1236
a2144 1
}
d2146 3
a2148 6
void
pf_print_state(struct pf_state *s)
{
	switch (s->proto) {
	case IPPROTO_TCP:
		printf("TCP ");
d2150 10
a2159 5
	case IPPROTO_UDP:
		printf("UDP ");
		break;
	case IPPROTO_ICMP:
		printf("ICMP ");
d2161 2
d2164 1
a2164 1
		printf("%u ", s->proto);
d2167 1
a2167 11
	pf_print_host(&s->lan.addr, s->lan.port, s->af);
	printf(" ");
	pf_print_host(&s->gwy.addr, s->gwy.port, s->af);
	printf(" ");
	pf_print_host(&s->ext.addr, s->ext.port, s->af);
	printf(" [lo=%lu high=%lu win=%u modulator=%u]", s->src.seqlo,
	    s->src.seqhi, s->src.max_win, s->src.seqdiff);
	printf(" [lo=%lu high=%lu win=%u modulator=%u]", s->dst.seqlo,
	    s->dst.seqhi, s->dst.max_win, s->dst.seqdiff);
	printf(" %u:%u", s->src.state, s->dst.state);
}
d2169 1
a2169 21
void
pf_print_flags(u_int8_t f)
{
	if (f)
		printf(" ");
	if (f & TH_FIN)
		printf("F");
	if (f & TH_SYN)
		printf("S");
	if (f & TH_RST)
		printf("R");
	if (f & TH_PUSH)
		printf("P");
	if (f & TH_ACK)
		printf("A");
	if (f & TH_URG)
		printf("U");
	if (f & TH_ECE)
		printf("E");
	if (f & TH_CWR)
		printf("W");
a2196 3
			PF_CALC_SKIP_STEP(PF_SKIP_ACTION,
			    (s->action == PF_SCRUB && r->action == PF_SCRUB) ||
			    (s->action != PF_SCRUB && r->action != PF_SCRUB));
a2197 2
			PF_CALC_SKIP_STEP(PF_SKIP_DIR,
			    s->direction == r->direction);
d2201 1
a2201 3
			    s->src.addr.addr_dyn == NULL &&
			    r->src.addr.addr_dyn == NULL &&
			    PF_AEQ(&s->src.addr.addr, &r->src.addr.addr, r->af) &&
d2209 1
a2209 3
			    s->dst.addr.addr_dyn == NULL &&
			    r->dst.addr.addr_dyn == NULL &&
			    PF_AEQ(&s->dst.addr.addr, &r->dst.addr.addr, r->af) &&
d2394 1
a2394 2
pf_send_reset(int off, struct tcphdr *th, struct pf_pdesc *pd, int af,
    u_int8_t return_ttl)
d2493 1
a2493 3
		if (!return_ttl)
			return_ttl = ip_defttl;
		h2->ip_ttl = return_ttl;
d2496 1
a2496 1
		h2->ip_off = ip_mtudisc ? IP_DF : 0;
d2507 1
a2507 3
		if (!return_ttl)
			return_ttl = IPV6_DEFHLIM;
		h2_6->ip6_hlim = return_ttl;
d2589 1
a2589 1
pf_match(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
d2591 3
a2615 25
pf_match_port(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
{
	NTOHS(a1);
	NTOHS(a2);
	NTOHS(p);
	return (pf_match(op, a1, a2, p));
}

int
pf_match_uid(u_int8_t op, uid_t a1, uid_t a2, uid_t u)
{
	if (u == UID_MAX && op != PF_OP_EQ && op != PF_OP_NE)
		return (0);
	return (pf_match(op, a1, a2, u));
}

int
pf_match_gid(u_int8_t op, gid_t a1, gid_t a2, gid_t g)
{
	if (g == GID_MAX && op != PF_OP_EQ && op != PF_OP_NE)
		return (0);
	return (pf_match(op, a1, a2, g));
}

int
d2633 1
a2633 1
	pnode = pool_get(&pf_sport_pl, PR_NOWAIT);
d2687 1
a2687 1
		cut = arc4random() % (1 + high - low) + low;
d2690 1
a2690 1
		cut = arc4random() % (1 + low - high) + high;
d2726 2
a2727 6
		    (n->saddr.addr_dyn == NULL ||
		    !n->saddr.addr_dyn->undefined) &&
		    PF_MATCHA(n->snot, &n->saddr.addr, &n->smask, saddr, af) &&
		    (n->daddr.addr_dyn == NULL ||
		    !n->daddr.addr_dyn->undefined) &&
		    PF_MATCHA(n->dnot, &n->daddr.addr, &n->dmask, daddr, af))
d2732 1
a2732 2
	if (nm && (nm->no || (nm->raddr.addr_dyn != NULL &&
	    nm->raddr.addr_dyn->undefined)))
d2751 2
a2752 6
		    (b->saddr.addr_dyn == NULL ||
		    !b->saddr.addr_dyn->undefined) &&
		    PF_MATCHA(0, &b->saddr.addr, &fullmask, saddr, af) &&
		    (b->daddr.addr_dyn == NULL ||
		    !b->daddr.addr_dyn->undefined) &&
		    PF_MATCHA(b->dnot, &b->daddr.addr, &b->dmask, daddr, af))
d2757 2
a2758 6
		    (b->raddr.addr_dyn == NULL ||
		    !b->raddr.addr_dyn->undefined) &&
		    PF_MATCHA(0, &b->raddr.addr, &fullmask, saddr, af) &&
		    (b->daddr.addr_dyn == NULL ||
		    !b->daddr.addr_dyn->undefined) &&
		    PF_MATCHA(b->dnot, &b->daddr.addr, &b->dmask, daddr, af))
a2764 6
	if (bm && direction == PF_OUT && bm->raddr.addr_dyn != NULL &&
	    bm->raddr.addr_dyn->undefined)
		return (NULL);
	if (bm && direction == PF_IN && bm->saddr.addr_dyn != NULL &&
	    bm->saddr.addr_dyn->undefined)
		return (NULL);
d2780 2
a2781 6
		    (r->saddr.addr_dyn == NULL ||
		    !r->saddr.addr_dyn->undefined) &&
		    PF_MATCHA(r->snot, &r->saddr.addr, &r->smask, saddr, af) &&
		    (r->daddr.addr_dyn == NULL ||
		    !r->daddr.addr_dyn->undefined) &&
		    PF_MATCHA(r->dnot, &r->daddr.addr, &r->dmask, daddr, af) &&
d2789 1
a2789 2
	if (rm && (rm->no || (rm->raddr.addr_dyn != NULL &&
	    rm->raddr.addr_dyn->undefined)))
a2805 50
int
pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, int af, int proto,
    struct pf_pdesc *pd)
{
	struct pf_addr *saddr, *daddr;
	u_int16_t sport, dport;
	struct inpcbtable *tb;
	struct inpcb *inp;

	*uid = UID_MAX;
	*gid = GID_MAX;
	if (af != AF_INET)
		return (0);
	switch (proto) {
	case IPPROTO_TCP:
		sport = pd->hdr.tcp->th_sport;
		dport = pd->hdr.tcp->th_dport;
		tb = &tcbtable;
		break;
	case IPPROTO_UDP:
		sport = pd->hdr.udp->uh_sport;
		dport = pd->hdr.udp->uh_dport;
		tb = &udbtable;
		break;
	default:
		return (0);
	}
	if (direction == PF_IN) {
		saddr = pd->src;
		daddr = pd->dst;
	} else {
		u_int16_t p;

		p = sport;
		sport = dport;
		dport = p;
		saddr = pd->dst;
		daddr = pd->src;
	}
	inp = in_pcbhashlookup(tb, saddr->v4, sport, daddr->v4, dport);
	if (inp == NULL) {
		inp = in_pcblookup(tb, &saddr->v4, sport, &daddr->v4, dport,
		    INPLOOKUP_WILDCARD);
		if (inp == NULL)
			return (0);
	}
	*uid = inp->inp_socket->so_euid;
	*gid = inp->inp_socket->so_egid;
	return (1);
}
d2816 1
a2817 4
	int lookup = -1;
	uid_t uid;
	gid_t gid;
	struct pf_rule *r;
d2830 1
a2830 1
			    &th->th_sum, &binat->raddr.addr, th->th_sport, 0, af);
d2843 1
a2843 2
			    &th->th_sum, &nat->raddr.addr, htons(nport),
			    0, af);
d2859 1
a2859 1
			    &th->th_sum, &rdr->raddr.addr, nport, 0, af);
d2868 1
a2868 1
			    &th->th_sum, &binat->saddr.addr, th->th_dport, 0, af);
d2875 4
d2880 1
a2880 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION];
		else if (r->ifp != NULL && r->ifp != ifp)
a2881 2
		else if (r->direction != direction)
			r = r->skip[PF_SKIP_DIR];
d2886 2
a2887 5
		else if (r->src.noroute && pf_routable(saddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (!r->src.noroute &&
		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.mask, saddr, af))
d2892 2
a2893 5
		else if (r->dst.noroute && pf_routable(daddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (!r->dst.noroute &&
		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.mask, daddr, af))
d2898 1
a2898 1
		else if (r->rule_flag & PFRULE_FRAGMENT)
a2901 10
		else if (r->uid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP, pd),
		    1)) && !pf_match_uid(r->uid.op, r->uid.uid[0],
		    r->uid.uid[1], uid))
			r = TAILQ_NEXT(r, entries);
		else if (r->gid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP, pd),
		    1)) && !pf_match_gid(r->gid.op, r->gid.gid[0],
		    r->gid.gid[1], gid))
			r = TAILQ_NEXT(r, entries);
d2915 2
a2916 3
		if ((*rm)->log) {
			if (rewrite)
				m_copyback(m, off, sizeof(*th), (caddr_t)th);
a2917 1
		}
d2935 1
a2935 2
				pf_send_reset(off, th, pd, af,
				    (*rm)->return_ttl);
d2952 1
a2952 1
		struct pf_state *s = NULL;
d2955 1
a2955 3
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
a2958 1
			REASON_SET(&reason, PFRES_MEMORY);
a2960 2
		if (*rm != NULL)
			(*rm)->states++;
d2962 1
a2962 1
		s->rule.ptr = *rm;
d3018 2
a3019 2
		s->creation = time.tv_sec;
		s->expire = s->creation + TIMEOUT(*rm, PFTM_TCP_FIRST_PACKET);
d3022 1
a3022 7
		if (pf_insert_state(s)) {
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_TCP, nport);
			REASON_SET(&reason, PFRES_MEMORY);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
a3041 3
	int lookup = -1;
	uid_t uid;
	gid_t gid;
d3055 1
a3055 1
			    &uh->uh_sum, &binat->raddr.addr, uh->uh_sport, 1, af);
d3068 1
a3068 2
			    &uh->uh_sum, &nat->raddr.addr, htons(nport),
			    1, af);
d3085 1
a3085 1
			    &uh->uh_sum, &rdr->raddr.addr, nport, 1, af);
d3094 1
a3094 1
			    &uh->uh_sum, &binat->saddr.addr, uh->uh_dport, 1, af);
d3101 4
d3106 2
a3107 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION];
		else if (r->ifp != NULL && r->ifp != ifp)
a3108 2
		else if (r->direction != direction)
			r = r->skip[PF_SKIP_DIR];
d3113 2
a3114 5
		else if (r->src.noroute && pf_routable(saddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (!r->src.noroute &&
		    !PF_AZERO(&r->src.mask, af) &&
		    !PF_MATCHA(r->src.not, &r->src.addr.addr, &r->src.mask,
d3120 2
a3121 5
		else if (r->dst.noroute && pf_routable(daddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (!r->dst.noroute &&
		    !PF_AZERO(&r->dst.mask, af) &&
		    !PF_MATCHA(r->dst.not, &r->dst.addr.addr, &r->dst.mask,
d3127 1
a3127 11
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if (r->uid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP, pd),
		    1)) && !pf_match_uid(r->uid.op, r->uid.uid[0],
		    r->uid.uid[1], uid))
			r = TAILQ_NEXT(r, entries);
		else if (r->gid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP, pd),
		    1)) && !pf_match_gid(r->gid.op, r->gid.gid[0],
		    r->gid.gid[1], gid))
d3142 2
a3143 3
		if ((*rm)->log) {
			if (rewrite)
				m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
a3144 1
		}
d3173 1
a3173 1
		struct pf_state *s = NULL;
d3175 1
a3175 3
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
a3180 2
		if (*rm != NULL)
			(*rm)->states++;
d3182 1
a3182 1
		s->rule.ptr = *rm;
d3223 2
a3224 2
		s->creation = time.tv_sec;
		s->expire = s->creation + TIMEOUT(*rm, PFTM_UDP_FIRST_PACKET);
d3227 1
a3227 7
		if (pf_insert_state(s)) {
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_UDP, nport);
			REASON_SET(&reason, PFRES_MEMORY);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
a3248 1
	int state_icmp = 0;
a3260 7

		if (icmptype == ICMP_UNREACH ||
		    icmptype == ICMP_SOURCEQUENCH ||
		    icmptype == ICMP_REDIRECT ||
		    icmptype == ICMP_TIMXCEED ||
		    icmptype == ICMP_PARAMPROB)
			state_icmp++;
a3267 6

		if (icmptype == ICMP6_DST_UNREACH ||
		    icmptype == ICMP6_PACKET_TOO_BIG ||
		    icmptype == ICMP6_TIME_EXCEEDED ||
		    icmptype == ICMP6_PARAM_PROB)
			state_icmp++;
d3281 1
a3281 1
				    binat->raddr.addr.v4.s_addr, 0);
d3287 1
a3287 1
				    &binat->raddr.addr, 0);
d3301 1
a3301 1
				    pd->ip_sum, nat->raddr.addr.v4.s_addr, 0);
d3307 1
a3307 1
				    &nat->raddr.addr, 0);
d3322 1
a3322 1
				    pd->ip_sum, rdr->raddr.addr.v4.s_addr, 0);
d3328 1
a3328 1
				    &rdr->raddr.addr, 0);
d3342 1
a3342 1
				    pd->ip_sum, binat->saddr.addr.v4.s_addr, 0);
d3348 1
a3348 1
				    &binat->saddr.addr, 0);
d3358 4
d3363 1
a3363 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION];
		else if (r->ifp != NULL && r->ifp != ifp)
a3364 2
		else if (r->direction != direction)
			r = r->skip[PF_SKIP_DIR];
d3369 2
a3370 5
		else if (r->src.noroute && pf_routable(saddr, af))
			r = TAILQ_NEXT(r, entries);
		else if (!r->src.noroute &&
		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.mask, saddr, af))
d3372 4
a3375 1
		else if (r->dst.noroute && pf_routable(daddr, af))
a3376 4
		else if (!r->dst.noroute &&
		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.mask, daddr, af))
			r = r->skip[PF_SKIP_DST_ADDR];
a3382 2
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
d3396 2
a3397 6
		if ((*rm)->log) {
#ifdef INET6
			if (rewrite)
				m_copyback(m, off, ICMP_MINLEN,
				    (caddr_t)pd->hdr.icmp6);
#endif /* INET6 */
a3398 1
		}
d3404 2
a3405 2
	if (!state_icmp && ((*rm != NULL && (*rm)->keep_state) ||
	    nat != NULL || rdr != NULL || binat != NULL)) {
d3407 1
a3407 1
		struct pf_state *s = NULL;
d3409 1
a3409 3
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
a3411 2
		if (*rm != NULL)
			(*rm)->states++;
d3413 1
a3413 1
		s->rule.ptr = *rm;
d3450 2
a3451 2
		s->creation = time.tv_sec;
		s->expire = s->creation + TIMEOUT(*rm, PFTM_ICMP_FIRST_PACKET);
d3454 1
a3454 5
		if (pf_insert_state(s)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
a3476 2
	u_short reason;

d3489 1
a3489 1
				    binat->raddr.addr.v4.s_addr, 0);
d3494 1
a3494 1
				PF_ACPY(saddr, &binat->raddr.addr, af);
d3507 1
a3507 1
				    pd->ip_sum, nat->raddr.addr.v4.s_addr, 0);
d3512 1
a3512 1
				PF_ACPY(saddr, &nat->raddr.addr, af);
d3526 1
a3526 1
				    pd->ip_sum, rdr->raddr.addr.v4.s_addr, 0);
d3531 1
a3531 1
				PF_ACPY(daddr, &rdr->raddr.addr, af);
d3544 1
a3544 1
				    pd->ip_sum, binat->saddr.addr.v4.s_addr, 0);
d3549 1
a3549 1
				PF_ACPY(daddr, &binat->saddr.addr, af);
d3558 4
d3563 1
a3563 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION];
		else if (r->ifp != NULL && r->ifp != ifp)
a3564 2
		else if (r->direction != direction)
			r = r->skip[PF_SKIP_DIR];
d3569 2
a3570 5
		else if (r->src.noroute && pf_routable(pd->src, af))
			r = TAILQ_NEXT(r, entries);
		else if (!r->src.noroute &&
		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.mask, pd->src, af))
d3572 2
a3573 5
		else if (r->dst.noroute && pf_routable(pd->dst, af))
			r = TAILQ_NEXT(r, entries);
		else if (!r->src.noroute &&
		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.mask, pd->dst, af))
d3575 1
a3575 1
		else if (r->rule_flag & PFRULE_FRAGMENT)
d3586 2
d3601 1
a3601 1
		struct pf_state *s = NULL;
d3603 1
a3603 3
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
a3605 2
		if (*rm != NULL)
			(*rm)->states++;
d3607 1
a3607 1
		s->rule.ptr = *rm;
d3644 2
a3645 2
		s->creation = time.tv_sec;
		s->expire = s->creation + TIMEOUT(*rm, PFTM_OTHER_FIRST_PACKET);
d3648 1
a3648 69
		if (pf_insert_state(s)) {
			REASON_SET(&reason, PFRES_MEMORY);
			if (*rm && (*rm)->log)
				PFLOG_PACKET(ifp, h, m, af, direction, reason,
				    *rm);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
	}

	return (PF_PASS);
}

int
pf_test_fragment(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, void *h, struct pf_pdesc *pd)
{
	struct pf_rule *r;
	u_int8_t af = pd->af;

	*rm = NULL;

	r = TAILQ_FIRST(pf_rules_active);
	while (r != NULL) {
		r->evaluations++;
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION];
		else if (r->ifp != NULL && r->ifp != ifp)
			r = r->skip[PF_SKIP_IFP];
		else if (r->direction != direction)
			r = r->skip[PF_SKIP_DIR];
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF];
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO];
		else if (r->src.noroute && pf_routable(pd->src, af))
			r = TAILQ_NEXT(r, entries);
		else if (!r->src.noroute &&
		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr.addr, &r->src.mask, pd->src, af))
			r = r->skip[PF_SKIP_SRC_ADDR];
		else if (r->dst.noroute && pf_routable(pd->dst, af))
			r = TAILQ_NEXT(r, entries);
		else if (!r->src.noroute &&
		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr.addr, &r->dst.mask, pd->dst, af))
			r = r->skip[PF_SKIP_DST_ADDR];
		else if (r->src.port_op || r->dst.port_op ||
		    r->flagset || r->type || r->code)
			r = TAILQ_NEXT(r, entries);
		else {
			*rm = r;
			if ((*rm)->quick)
				break;
			r = TAILQ_NEXT(r, entries);
		}
	}

	if (*rm != NULL) {
		u_short reason;

		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		REASON_SET(&reason, PFRES_MATCH);
		if ((*rm)->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);

		if ((*rm)->action != PF_PASS)
			return (PF_DROP);
d3658 1
a3658 1
	struct pf_tree_node key;
d3665 2
a3666 2
	key.af = pd->af;
	key.proto = IPPROTO_TCP;
d3673 1
a3673 1
		*state = pf_find_state(&tree_ext_gwy, &key);
d3675 1
a3675 1
		*state = pf_find_state(&tree_lan_ext, &key);
d3724 1
a3724 2
		if (src->seqhi == 1 ||
		    SEQ_GEQ(end + MAX(1, dst->max_win), src->seqhi))
d3808 1
a3808 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_CLOSED);
d3811 1
a3811 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_FIN_WAIT);
d3814 1
a3814 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_CLOSING);
d3817 1
a3817 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_OPENING);
d3819 1
a3819 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_ESTABLISHED);
d3914 1
a3914 1
			    (*state)->gwy.port, 0, pd->af);
d3925 3
a3927 3
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
d3937 1
a3937 1
	struct pf_tree_node key;
d3940 2
a3941 2
	key.af = pd->af;
	key.proto = IPPROTO_UDP;
d3948 1
a3948 1
		*state = pf_find_state(&tree_ext_gwy, &key);
d3950 1
a3950 1
		*state = pf_find_state(&tree_lan_ext, &key);
d3973 1
a3973 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_UDP_MULTIPLE);
d3975 1
a3975 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_UDP_SINGLE);
d3990 3
a3992 3
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
d4042 1
a4042 1
		struct pf_tree_node key;
d4044 2
a4045 2
		key.af = pd->af;
		key.proto = pd->proto;
d4052 1
a4052 1
			*state = pf_find_state(&tree_ext_gwy, &key);
d4054 1
a4054 1
			*state = pf_find_state(&tree_lan_ext, &key);
d4060 1
a4060 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_ICMP_ERROR_REPLY);
d4069 1
a4069 1
					    pd->ip_sum,
d4175 1
a4175 1
					struct ip6_ext opt6;
d4183 2
a4184 5
					if (pd2.proto == IPPROTO_AH)
						off2 += (opt6.ip6e_len + 2) * 4;
					else
						off2 += (opt6.ip6e_len + 1) * 8;
					pd2.proto = opt6.ip6e_nxt;
d4201 1
a4201 1
			struct pf_tree_node key;
d4216 1
a4216 1
			key.proto = IPPROTO_TCP;
d4223 1
a4223 1
				*state = pf_find_state(&tree_ext_gwy, &key);
d4225 1
a4225 1
				*state = pf_find_state(&tree_lan_ext, &key);
d4295 1
a4295 1
			struct pf_tree_node key;
d4305 1
a4305 1
			key.proto = IPPROTO_UDP;
d4312 1
a4312 1
				*state = pf_find_state(&tree_ext_gwy, &key);
d4314 1
a4314 1
				*state = pf_find_state(&tree_lan_ext, &key);
d4360 1
a4360 1
			struct pf_tree_node key;
d4370 1
a4370 1
			key.proto = IPPROTO_ICMP;
d4377 1
a4377 1
				*state = pf_find_state(&tree_ext_gwy, &key);
d4379 1
a4379 1
				*state = pf_find_state(&tree_lan_ext, &key);
d4412 1
a4412 1
			struct pf_tree_node key;
d4422 1
a4422 1
			key.proto = IPPROTO_ICMPV6;
d4429 1
a4429 1
				*state = pf_find_state(&tree_ext_gwy, &key);
d4431 1
a4431 1
				*state = pf_find_state(&tree_lan_ext, &key);
d4475 1
a4475 1
	struct pf_tree_node key;
d4477 2
a4478 2
	key.af = pd->af;
	key.proto = pd->proto;
d4485 1
a4485 1
		*state = pf_find_state(&tree_ext_gwy, &key);
d4487 1
a4487 1
		*state = pf_find_state(&tree_lan_ext, &key);
d4510 1
a4510 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_OTHER_MULTIPLE);
d4512 1
a4512 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_OTHER_SINGLE);
d4546 3
a4548 3
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
a4600 24
int
pf_routable(addr, af)
	struct pf_addr *addr;
	int af;
{
	struct sockaddr_in *dst;
	struct route ro;
	int ret = 0;

	bzero(&ro, sizeof(ro));
	dst = satosin(&ro.ro_dst);
	dst->sin_family = af;
	dst->sin_len = sizeof(*dst);
	dst->sin_addr = addr->v4;
	rtalloc_noclone(&ro, NO_CLONING);

	if (ro.ro_rt != NULL) {
		ret = 1;
		RTFREE(ro.ro_rt);
	}

	return (ret);
}

d4609 1
a4609 1
	struct ip *ip;
a4610 1
	struct m_tag *mtag;
d4612 1
a4612 1
	int error = 0;
a4653 17
	if (r->ifp != ifp) {
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
				goto bad;
			else if (m0 == NULL)
				goto done;
			else {
				mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0,
				    M_NOWAIT);
				if (mtag == NULL)
					goto bad;
				m_tag_prepend(m0, mtag);
			}
		}
	}

d4684 13
d4698 83
a4780 4
	m1 = m0;
	error = ip_fragment(m0, ifp, ifp->if_mtu);
	if (error == EMSGSIZE)
		goto bad;
d4782 2
a4783 8
	for (m0 = m1; m0; m0 = m1) {
		m1 = m0->m_nextpkt;
		m0->m_nextpkt = 0;
		if (error == 0)
			error = (*ifp->if_output)(ifp, m0, sintosa(dst),
			    NULL);
		else
			m_freem(m0);
a4785 3
	if (error == 0)
		ipstat.ips_fragmented++;

a4849 17
	if (r->ifp != ifp) {
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
				goto bad;
			else if (m0 == NULL)
				goto done;
			else {
				mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0,
				    M_NOWAIT);
				if (mtag == NULL)
					goto bad;
				m_tag_prepend(m0, mtag);
			}
		}
	}

d4893 8
a4930 6
	/* handle fragments that didn't get reassembled by normalization */
	if (h->ip_off & (IP_MF | IP_OFFMASK)) {
		action = pf_test_fragment(&r, dir, ifp, m, h, &pd);
		goto done;
	}

d4948 1
a4948 1
			r = s->rule.ptr;
d4966 1
a4966 1
			r = s->rule.ptr;
d4984 1
a4984 1
			r = s->rule.ptr;
d4998 1
a4998 1
			r = s->rule.ptr;
d5060 8
d5098 1
a5098 1
			struct ip6_ext opt6;
d5109 2
a5110 5
			if (pd.proto == IPPROTO_AH)
				off += (opt6.ip6e_len + 2) * 4;
			else
				off += (opt6.ip6e_len + 1) * 8;
			pd.proto = opt6.ip6e_nxt;
d5137 1
a5137 1
			r = s->rule.ptr;
d5155 1
a5155 1
			r = s->rule.ptr;
d5173 1
a5173 1
			r = s->rule.ptr;
@


1.180.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.180.2.2 2002/06/11 03:30:45 art Exp $ */
d44 1
a80 4
#ifdef ALTQ
#include <altq/if_altq.h>
#endif

a97 2
struct pf_altqqueue	*pf_altqs_active;
struct pf_altqqueue	*pf_altqs_inactive;
d109 2
a110 2
u_int32_t		 ticket_altqs_active;
u_int32_t		 ticket_altqs_inactive;
d115 1
a115 1
int			 pftm_tcp_established = 24*60*60;  /* established */
a147 1
struct pool		 pf_altq_pl;
d150 7
a156 1
			    sa_family_t);
d162 1
d164 2
d175 1
a175 1
			    u_int16_t, u_int8_t, sa_family_t);
d185 1
a185 1
			    u_int16_t *, u_int8_t, sa_family_t);
d187 2
a188 3
			    struct pf_pdesc *, sa_family_t, u_int8_t);
void			 pf_send_icmp(struct mbuf *, u_int8_t, u_int8_t,
			    sa_family_t);
d191 1
a191 2
			    struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t, sa_family_t);
d193 1
a193 2
			    struct pf_addr *, struct pf_addr *,
			    struct pf_addr *, sa_family_t);
d195 1
a195 2
			    struct pf_addr *, struct pf_addr *, u_int16_t,
			    sa_family_t);
d218 1
a218 1
			    u_short *, u_short *, sa_family_t);
d220 6
a225 7
#ifdef INET6
void			 pf_poolmask(struct pf_addr *, struct pf_addr*,
			    struct pf_addr *, struct pf_addr *, sa_family_t);
#endif /* INET6 */
int			 pf_get_sport(sa_family_t, u_int8_t,
			    struct pf_addr *, struct pf_addr *,
			    u_int16_t, u_int16_t *, u_int16_t, u_int16_t);
d227 5
a231 7
			    int, int, void *, struct pf_pdesc *);
void			 pf_route(struct mbuf **, struct pf_rule *, int,
			    struct ifnet *);
void			 pf_route6(struct mbuf **, struct pf_rule *, int,
			    struct ifnet *);
int			 pf_socket_lookup(uid_t *, gid_t *, int, sa_family_t,
			    int, struct pf_pdesc *);
a274 1
struct pf_altqqueue		 pf_altqs[2];
d289 1
a289 1
			return (1);
d291 1
a291 1
			return (-1);
d293 1
a293 1
			return (1);
d295 1
a295 1
			return (-1);
d301 1
a301 1
			return (1);
d303 1
a303 1
			return (-1);
d305 1
a305 1
			return (1);
d307 1
a307 1
			return (-1);
d309 1
a309 1
			return (1);
d311 1
a311 1
			return (-1);
d313 1
a313 1
			return (1);
d315 1
a315 1
			return (-1);
d317 1
a317 1
			return (1);
d319 1
a319 1
			return (-1);
d321 1
a321 1
			return (1);
d323 1
a323 1
			return (-1);
d325 1
a325 1
			return (1);
d327 1
a327 1
			return (-1);
d329 1
a329 1
			return (1);
d331 1
a331 1
			return (-1);
d346 1
a346 1
pf_addrcpy(struct pf_addr *dst, struct pf_addr *src, sa_family_t af)
d365 114
a478 1
pflog_packet(struct ifnet *ifp, struct mbuf *m, sa_family_t af, u_short dir,
d540 1
a540 1
		return (-1);
d550 3
a552 17
	if (RB_INSERT(pf_state_tree, &tree_lan_ext, keya) != NULL) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: tree_lan_ext");
			printf(" lan: ");
			pf_print_host(&state->lan.addr, state->lan.port,
			    state->af);
			printf(" gwy: ");
			pf_print_host(&state->gwy.addr, state->gwy.port,
			    state->af);
			printf(" ext: ");
			pf_print_host(&state->ext.addr, state->ext.port,
			    state->af);
			printf("\n");
		}
		pool_put(&pf_tree_pl, keya);
		return (-1);
	}
d559 1
a559 1
		return (-1);
d569 2
a570 19
	if (RB_INSERT(pf_state_tree, &tree_ext_gwy, keyb) != NULL) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: tree_ext_gwy");
			printf(" lan: ");
			pf_print_host(&state->lan.addr, state->lan.port,
			    state->af);
			printf(" gwy: ");
			pf_print_host(&state->gwy.addr, state->gwy.port,
			    state->af);
			printf(" ext: ");
			pf_print_host(&state->ext.addr, state->ext.port,
			    state->af);
			printf("\n");
		}
		RB_REMOVE(pf_state_tree, &tree_lan_ext, keya);
		pool_put(&pf_tree_pl, keya);
		pool_put(&pf_tree_pl, keyb);
		return (-1);
	}
d574 1
a574 1
	return (0);
d600 1
a600 1
		if (cur->state->expire <= (unsigned)time.tv_sec) {
d619 4
d635 1
a635 1
pf_dynaddr_setup(struct pf_addr_wrap *aw, sa_family_t af)
d732 1
a732 1
pf_print_host(struct pf_addr *addr, u_int16_t p, sa_family_t af)
a802 3
	case IPPROTO_ICMPV6:
		printf("ICMPV6 ");
		break;
d870 1
a870 2
			PF_CALC_SKIP_STEP(PF_SKIP_IFP, 
			    s->ifp == r->ifp && s->ifnot == r->ifnot);
d907 1
a907 1
		return (0x0000);
d912 1
a912 1
		return (0xFFFF);
d918 1
a918 1
    struct pf_addr *an, u_int16_t pn, u_int8_t u, sa_family_t af)
d996 1
a996 1
    u_int16_t *ic, u_int16_t *hc, u_int8_t u, sa_family_t af)
d1073 1
a1073 1
pf_send_reset(int off, struct tcphdr *th, struct pf_pdesc *pd, sa_family_t af,
d1179 1
a1179 2
		ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL,
		  (void *)NULL);
d1199 1
a1199 1
pf_send_icmp(struct mbuf *m, u_int8_t type, u_int8_t code, sa_family_t af)
d1234 1
a1234 1
    struct pf_addr *b, sa_family_t af)
d1277 1
a1277 1
		return ((p > a1) && (p < a2));
d1279 1
a1279 1
		return ((p < a1) || (p > a2));
d1321 28
a1348 1
#ifdef INET6
d1350 1
a1350 2
pf_poolmask(struct pf_addr *naddr, struct pf_addr *raddr,
    struct pf_addr *rmask, struct pf_addr *saddr, sa_family_t af)
d1352 16
a1367 17
	switch (af) {
#ifdef INET
	case AF_INET:
		naddr->addr32[0] = (raddr->addr32[0] & rmask->addr32[0]) |
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]); 
		break;
#endif /* INET */
	case AF_INET6:
		naddr->addr32[0] = (raddr->addr32[0] & rmask->addr32[0]) |
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]); 
		naddr->addr32[1] = (raddr->addr32[1] & rmask->addr32[1]) |
		((rmask->addr32[1] ^ 0xffffffff ) & saddr->addr32[1]); 
		naddr->addr32[2] = (raddr->addr32[2] & rmask->addr32[2]) |
		((rmask->addr32[2] ^ 0xffffffff ) & saddr->addr32[2]); 
		naddr->addr32[3] = (raddr->addr32[3] & rmask->addr32[3]) |
		((rmask->addr32[3] ^ 0xffffffff ) & saddr->addr32[3]); 
		break;
a1369 1
#endif /* INET6 */
d1372 1
a1372 3
pf_get_sport(sa_family_t af, u_int8_t proto,
    struct pf_addr *daddr, struct pf_addr *raddr,
    u_int16_t dport, u_int16_t *port, u_int16_t low, u_int16_t high)
d1374 1
a1374 2
	struct pf_tree_node key;

d1378 5
a1382 1
	if (!(proto == IPPROTO_TCP || proto == IPPROTO_UDP))
a1383 14
	if (low == 0 && high == 0) {
		NTOHS(*port);
		return (0);
	}
	if (low == high) {
		*port = low;
		return (0);
	}

	key.af = af;
	key.proto = proto;
	PF_ACPY(&key.addr[0], daddr, key.af);
	PF_ACPY(&key.addr[1], raddr, key.af);
	key.port[0] = dport;
d1387 3
a1389 5
		key.port[1] = htons(low);
		if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
			*port = low;
			return (0);
		}
d1402 2
a1403 3
		key.port[1] = htons(*port);
		if (pf_find_state(&tree_ext_gwy, &key) == NULL)
			return (0);
d1410 2
a1411 3
		key.port[1] = htons(*port);
		if (pf_find_state(&tree_ext_gwy, &key) == NULL)
			return (0);
d1415 3
d1422 1
a1422 1
    u_int16_t sport, struct pf_addr *daddr, u_int16_t dport, sa_family_t af)
d1432 6
a1437 16
		    (n->src.addr.addr_dyn == NULL ||
		    !n->src.addr.addr_dyn->undefined) &&
		    PF_MATCHA(n->src.not, &n->src.addr.addr, &n->src.mask,
		    saddr, af) &&
		    (!n->src.port_op ||
		    (proto != IPPROTO_TCP && proto != IPPROTO_UDP) ||
		    pf_match_port(n->src.port_op, n->src.port[0],
		    n->src.port[1], sport)) &&
		    (n->dst.addr.addr_dyn == NULL ||
		    !n->dst.addr.addr_dyn->undefined) &&
		    PF_MATCHA(n->dst.not, &n->dst.addr.addr, &n->dst.mask,
		    daddr, af) &&
		    (!n->dst.port_op ||
		    (proto != IPPROTO_TCP && proto != IPPROTO_UDP) ||
		    pf_match_port(n->dst.port_op, n->dst.port[0],
		    n->dst.port[1], dport)))
d1450 1
a1450 2
    struct pf_addr *saddr, struct pf_addr *daddr, struct pf_addr *naddr,
    sa_family_t af)
d1453 3
d1464 1
a1464 1
		    PF_MATCHA(0, &b->saddr.addr, &b->smask, saddr, af) &&
d1474 1
a1474 1
		    PF_MATCHA(0, &b->raddr.addr, &b->rmask, saddr, af) &&
d1482 8
a1489 23
	if (bm) {
		if (bm->no)
			return (NULL);
		switch (direction) {
		case PF_OUT:
			if (bm->raddr.addr_dyn != NULL &&
			    bm->raddr.addr_dyn->undefined)
				return (NULL);
			else
				PF_POOLMASK(naddr, &bm->raddr.addr,
				    &bm->rmask, saddr, af); 
			break;
		case PF_IN:
			if (bm->saddr.addr_dyn != NULL &&
			    bm->saddr.addr_dyn->undefined)
				return (NULL);
			else
				PF_POOLMASK(naddr, &bm->saddr.addr,
				    &bm->smask, saddr, af); 
			break;
		}
	}

d1495 1
a1495 1
    struct pf_addr *daddr, u_int16_t dport, sa_family_t af)
d1533 1
a1533 1
	return (htons((u_int16_t)nport));
d1537 2
a1538 2
pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, sa_family_t af,
    int proto, struct pf_pdesc *pd)
d1594 1
a1594 1
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr, naddr;
d1596 1
a1596 2
	u_int16_t bport, nport = 0;
	sa_family_t af = pd->af;
d1609 1
a1609 1
		    saddr, daddr, &naddr, af)) != NULL) {
d1613 1
a1613 1
			    &th->th_sum, &naddr, th->th_sport, 0, af);
d1618 5
a1622 10
		    saddr, th->th_sport, daddr, th->th_dport, af)) != NULL) {
			bport = nport = th->th_sport;
			error = pf_get_sport(af, IPPROTO_TCP, daddr,
			    &nat->raddr.addr, th->th_dport, &nport,
			    nat->proxy_port[0], nat->proxy_port[1]);
			if (error) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: NAT proxy port allocation "
				    "(tcp %u-%u) failed\n",
				    nat->proxy_port[0], nat->proxy_port[1]));
a1623 1
			}
d1648 1
a1648 1
		    daddr, saddr, &naddr, af)) != NULL) {
d1652 1
a1652 1
			    &th->th_sum, &naddr, th->th_dport, 0, af);
d1662 1
a1662 2
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
a1687 2
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
d1723 1
a1723 2
		    ((*rm)->rule_flag & PFRULE_RETURNICMP) ||
		    ((*rm)->rule_flag & PFRULE_RETURN))) {
d1736 1
a1736 2
			if (((*rm)->rule_flag & PFRULE_RETURNRST) ||
			    ((*rm)->rule_flag & PFRULE_RETURN))
d1739 1
a1739 1
			else if ((af == AF_INET) && (*rm)->return_icmp)
a1741 3
			else if ((af == AF_INET6) && (*rm)->return_icmp6)
				pf_send_icmp(m, (*rm)->return_icmp6 >> 8,
				    (*rm)->return_icmp6 & 255, af);
d1744 3
a1746 1
		if ((*rm)->action == PF_DROP) 
d1748 1
d1762 2
d1805 2
a1806 2
		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
		    *rm != NULL && (*rm)->keep_state == PF_STATE_MODULATE) {
d1831 2
d1853 1
a1853 1
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr, naddr;
d1855 1
a1855 2
	u_int16_t bport, nport = 0;
	sa_family_t af = pd->af;
d1868 1
a1868 1
		    saddr, daddr, &naddr, af)) != NULL) {
d1872 1
a1872 1
			    &uh->uh_sum, &naddr, uh->uh_sport, 1, af);
d1877 5
a1881 10
		    saddr, uh->uh_sport, daddr, uh->uh_dport, af)) != NULL) {
			bport = nport = uh->uh_sport;
			error = pf_get_sport(af, IPPROTO_UDP, daddr,
			    &nat->raddr.addr, uh->uh_dport, &nport,
			    nat->proxy_port[0], nat->proxy_port[1]);
			if (error) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: NAT proxy port allocation "
				    "(udp %u-%u) failed\n",
				    nat->proxy_port[0], nat->proxy_port[1]));
a1882 1
			}
d1908 1
a1908 1
		    daddr, saddr, &naddr, af)) != NULL) {
d1912 1
a1912 1
			    &uh->uh_sum, &naddr, uh->uh_dport, 1, af);
d1922 1
a1922 2
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
a1949 2
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
d1981 1
a1981 3
		if (((*rm)->action == PF_DROP) && 
		    (((*rm)->rule_flag & PFRULE_RETURNICMP) ||
		    ((*rm)->rule_flag & PFRULE_RETURN))) {
d1994 2
a1995 6
			if ((af == AF_INET) && (*rm)->return_icmp)
				pf_send_icmp(m, (*rm)->return_icmp >> 8,
				    (*rm)->return_icmp & 255, af);
			else if ((af == AF_INET6) && (*rm)->return_icmp6)
				pf_send_icmp(m, (*rm)->return_icmp6 >> 8,
				    (*rm)->return_icmp6 & 255, af);
d1998 3
a2000 1
		if ((*rm)->action == PF_DROP) 
d2002 1
d2013 3
a2015 1
		if (s == NULL)
d2017 1
d2052 1
a2052 1
		s->src.seqlo = 0;
d2056 1
a2056 1
		s->src.state = PFUDPS_SINGLE;
d2061 1
a2061 1
		s->dst.state = PFUDPS_NO_TRAFFIC;
d2067 2
d2089 1
a2089 1
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr, naddr;
d2092 1
a2092 2
	u_int16_t icmpid;
	sa_family_t af = pd->af;
d2134 1
a2134 1
		    saddr, daddr, &naddr, af)) != NULL) {
d2140 1
a2140 1
				    naddr.v4.s_addr, 0);
d2146 1
a2146 1
				    &naddr, 0);
d2154 1
a2154 1
		    saddr, 0, daddr, 0, af)) != NULL) {
d2195 1
a2195 1
		    daddr, saddr, &naddr, af)) != NULL) {
d2201 1
a2201 1
				    pd->ip_sum, naddr.v4.s_addr, 0);
d2207 1
a2207 1
				    &naddr, 0);
d2220 1
a2220 2
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d2240 2
a2245 2
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
d2258 1
a2258 1
		(*rm)->bytes += pd->tot_len;
d2353 2
a2354 2
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr, naddr;
	sa_family_t af = pd->af;
d2363 1
a2363 1
		    saddr, daddr, &naddr, af)) != NULL) {
d2369 1
a2369 1
				    naddr.v4.s_addr, 0);
d2374 1
a2374 1
				PF_ACPY(saddr, &naddr, af);
d2381 1
a2381 1
		    saddr, 0, daddr, 0, af)) != NULL) {
d2418 1
a2418 1
		    daddr, saddr, &naddr, af)) != NULL) {
d2424 1
a2424 1
				    pd->ip_sum, naddr.v4.s_addr, 0);
d2429 1
a2429 1
				PF_ACPY(daddr, &naddr, af);
d2441 1
a2441 2
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
a2460 2
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
d2526 1
a2526 1
		s->src.state = PFOTHERS_SINGLE;
d2531 1
a2531 1
		s->dst.state = PFOTHERS_NO_TRAFFIC;
d2554 1
a2554 1
	sa_family_t af = pd->af;
d2563 1
a2563 2
		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
a2582 2
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
d2651 1
a2651 1
		/* First packet from this end. Set its state */
d2738 1
a2738 1
		/* synchronize sequencing */
d2805 1
a2805 1
		 * since packet floods will also be caught here. We don't
d2828 1
a2828 1
		/* synchronize sequencing */
d2928 4
a2931 4
	if (src->state < PFUDPS_SINGLE)
		src->state = PFUDPS_SINGLE;
	if (dst->state == PFUDPS_SINGLE)
		dst->state = PFUDPS_MULTIPLE;
d2934 1
a2934 1
	if (src->state == PFUDPS_MULTIPLE && dst->state == PFUDPS_MULTIPLE)
d3133 1
a3133 4
					/*
					 * ICMPv6 error messages for
					 * non-first fragments
					 */
d3145 2
a3146 2
						    ("pf: ICMPv6 short opt\n"));
						return (PF_DROP);
d3471 4
a3474 4
	if (src->state < PFOTHERS_SINGLE)
		src->state = PFOTHERS_SINGLE;
	if (dst->state == PFOTHERS_SINGLE)
		dst->state = PFOTHERS_MULTIPLE;
d3477 1
a3477 1
	if (src->state == PFOTHERS_MULTIPLE && dst->state == PFOTHERS_MULTIPLE)
d3529 1
a3529 1
    u_short *actionp, u_short *reasonp, sa_family_t af)
d3558 1
a3558 2
		    (ntohs(h->ip6_plen) + sizeof(struct ip6_hdr)) <
		    (unsigned)(off + len)) {
d3574 1
a3574 1
	sa_family_t af;
d3597 1
a3597 1
pf_route(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp)
d3614 1
a3614 1
		if ((r->rt == PF_REPLYTO) == (r->direction == dir))
d3649 1
a3649 1
	if (oifp != ifp) {
d3692 1
d3694 1
a3694 6
		if (r->rt != PF_DUPTO) {
			icmp_error(m0, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG, 0,
			    ifp);
			goto done;
		} else
			goto bad;
d3730 1
a3730 1
pf_route6(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp)
d3749 1
a3749 1
		if ((r->rt == PF_REPLYTO) == (r->direction == dir))
d3779 1
a3779 1
	if (oifp != ifp) {
d3797 3
a3799 2
	 * If the packet is too large for the outgoing interface,
	 * send back an icmp6 error.
d3801 1
a3801 1
	if ((u_long)m0->m_pkthdr.len <= ifp->if_mtu) {
d3804 2
a3805 7
	} else {
		in6_ifstat_inc(ifp, ifs6_in_toobig);
		if (r->rt != PF_DUPTO)
			icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
		else
			goto bad;
	}
d3839 1
a3839 1
	if (m->m_pkthdr.len < (int)sizeof(*h)) {
d3855 1
a3855 1
	if (off < (int)sizeof(*h)) {
a3866 1
	pd.tos = h->ip_tos;
a3963 17
#ifdef ALTQ
	if (action != PF_DROP && r && r->qid) {
		struct m_tag *mtag;
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = AF_INET;
			atag->hdr = h;
			m_tag_prepend(m, mtag);
		}
	}
#endif

d3977 1
a3977 1
		pf_route(m0, r, dir, ifp);
d4004 1
a4004 1
	if (m->m_pkthdr.len < (int)sizeof(*h)) {
a4017 1
	pd.tos = 0;
d4025 3
a4027 3
			action = pf_test_fragment(&r, dir, ifp, m, h, &pd);
			if (action == PF_DROP)
				REASON_SET(&reason, PFRES_FRAG);
d4129 1
a4129 1
		pf_status.bcounters[1][dir] += pd.tot_len;
d4149 1
a4149 1
		pf_route6(m0, r, dir, ifp);
@


1.180.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a36 4
#include "bpfilter.h"
#include "pflog.h"
#include "pfsync.h"

d51 1
d59 1
a66 1
#include <netinet/icmp_var.h>
d70 3
a72 2
#include <net/if_pflog.h>
#include <net/if_pfsync.h>
d92 9
a100 4
struct pf_anchorqueue	 pf_anchors;
struct pf_ruleset	 pf_main_ruleset;
struct pf_altqqueue	 pf_altqs[2];
struct pf_palist	 pf_pabuf;
a103 1
struct pf_tagnames	 pf_tagnames;
d106 8
a115 1
u_int32_t		 ticket_pabuf;
d117 22
d141 13
a153 2
struct pool		 pf_tree_pl, pf_rule_pl, pf_addr_pl;
struct pool		 pf_state_pl, pf_altq_pl, pf_pooladdr_pl;
d157 2
a158 2
int			 pf_insert_state(struct pf_state *);
struct pf_state		*pf_find_state(struct pf_state_tree *,
d163 1
d173 2
d183 2
a184 6
void			 pf_send_syn(sa_family_t, const struct pf_addr *,
			    const struct pf_addr *, u_int16_t, u_int16_t,
			    u_int32_t);
void			 pf_send_ack(int, struct tcphdr *,
			    struct pf_pdesc *, sa_family_t, u_int8_t,
			    struct pf_rule *, u_int8_t, u_int32_t);
d186 3
a188 5
			    sa_family_t, struct pf_rule *);
struct pf_rule		*pf_match_translation(int, struct ifnet *, u_int8_t,
			    struct pf_addr *, u_int16_t, struct pf_addr *,
			    u_int16_t, sa_family_t, int);
struct pf_rule		*pf_get_translation(int, struct ifnet *, u_int8_t,
d190 17
a206 22
			    struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t *, sa_family_t);
int			 pf_test_tcp(struct pf_rule **, struct pf_state **,
			    int, struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
int			 pf_test_udp(struct pf_rule **, struct pf_state **,
			    int, struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
int			 pf_test_icmp(struct pf_rule **, struct pf_state **,
			    int, struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
int			 pf_test_other(struct pf_rule **, struct pf_state **,
			    int, struct ifnet *, struct mbuf *, void *,
			    struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
int			 pf_test_fragment(struct pf_rule **, int,
			    struct ifnet *, struct mbuf *, void *,
			    struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
d209 1
a209 1
			    void *, struct pf_pdesc *, u_short *);
d218 2
a220 6
void			 pf_rule_set_qid(struct pf_rulequeue *);
u_int32_t		 pf_qname_to_qid(char *);
struct pf_tag		*pf_get_tag(struct mbuf *);
int			 pf_tag_packet(struct mbuf *, struct pf_tag *,
			     u_int16_t);

d223 1
a223 2
			    struct pf_addr *, struct pf_addr *, u_int8_t);
void			 pf_addr_inc(struct pf_addr *, sa_family_t);
d225 1
a225 4

void			 pf_hash(struct pf_addr *, struct pf_addr *,
			    struct pf_poolhashkey *, sa_family_t);
int			 pf_map_addr(u_int8_t, struct pf_pool *,
d227 3
a229 4
			    struct pf_addr *);
int			 pf_get_sport(sa_family_t, u_int8_t, struct pf_pool *,
			    struct pf_addr *, struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t*, u_int16_t, u_int16_t);
d231 1
a231 1
			    struct ifnet *, struct pf_state *);
d233 1
a233 1
			    struct ifnet *, struct pf_state *);
d236 3
a238 4
u_int8_t		 pf_get_wscale(struct mbuf *, int, u_int16_t,
			    sa_family_t);
int			 pf_check_proto_cksum(struct mbuf *, int, int,
			    u_int8_t, sa_family_t);
a239 2
struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] =
    { { &pf_state_pl, PFSTATE_HIWAT }, { &pf_frent_pl, PFFRAG_FRENT_HIWAT } };
d241 12
a252 16
#define STATE_LOOKUP()							\
	do {								\
		if (direction == PF_IN)					\
			*state = pf_find_state(&tree_ext_gwy, &key);	\
		else							\
			*state = pf_find_state(&tree_lan_ext, &key);	\
		if (*state == NULL)					\
			return (PF_DROP);				\
		if (direction == PF_OUT &&				\
		    (((*state)->rule.ptr->rt == PF_ROUTETO &&		\
		    (*state)->rule.ptr->direction == PF_OUT) ||		\
		    ((*state)->rule.ptr->rt == PF_REPLYTO &&		\
		    (*state)->rule.ptr->direction == PF_IN)) &&		\
		    (*state)->rt_ifp != NULL &&				\
		    (*state)->rt_ifp != ifp)				\
			return (PF_PASS);				\
d254 3
d266 3
d275 6
d284 1
a284 1
	int	diff;
d305 1
a305 1
		if (a->addr[0].addr32[3] > b->addr[0].addr32[3])
d307 1
a307 1
		if (a->addr[0].addr32[3] < b->addr[0].addr32[3])
d309 1
a309 1
		if (a->addr[1].addr32[3] > b->addr[1].addr32[3])
d311 1
a311 1
		if (a->addr[1].addr32[3] < b->addr[1].addr32[3])
d317 1
a317 1
		if (a->addr[1].addr32[2] > b->addr[1].addr32[2])
d319 1
a319 1
		if (a->addr[1].addr32[2] < b->addr[1].addr32[2])
d321 1
a321 1
		if (a->addr[0].addr32[1] > b->addr[0].addr32[1])
d323 1
a323 1
		if (a->addr[0].addr32[1] < b->addr[0].addr32[1])
d329 1
a329 1
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
d331 1
a331 1
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
d333 1
a333 1
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
d335 1
a335 1
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
d353 1
a353 1
	switch (af) {
d369 43
d415 1
a415 1
	struct pf_tree_node	*k;
d428 1
a428 1
	struct pf_tree_node	*keya, *keyb;
a496 3
#if NPFSYNC
	pfsync_insert_state(state);
#endif
d503 2
a504 2
	struct timeout	*to = arg;
	int		 s;
d511 1
a511 37
	timeout_add(to, pf_default_rule.timeout[PFTM_INTERVAL] * hz);
}

u_int32_t
pf_state_expires(const struct pf_state *state)
{
	u_int32_t	timeout;
	u_int32_t	start;
	u_int32_t	end;
	u_int32_t	states;

	/* handle all PFTM_* > PFTM_MAX here */
	if (state->timeout == PFTM_PURGE)
		return (time.tv_sec);
	if (state->timeout == PFTM_UNTIL_PACKET)
		return (0);
	KASSERT(state->timeout < PFTM_MAX);
	timeout = state->rule.ptr->timeout[state->timeout];
	if (!timeout)
		timeout = pf_default_rule.timeout[state->timeout];
	start = state->rule.ptr->timeout[PFTM_ADAPTIVE_START];
	if (start) {
		end = state->rule.ptr->timeout[PFTM_ADAPTIVE_END];
		states = state->rule.ptr->states;
	} else {
		start = pf_default_rule.timeout[PFTM_ADAPTIVE_START];
		end = pf_default_rule.timeout[PFTM_ADAPTIVE_END];
		states = pf_status.states;
	}
	if (end && states > start && start < end) {
		if (states < end)
			return (state->expire + timeout * (end - states) /
			    (end - start));
		else
			return (time.tv_sec);
	}
	return (state->expire + timeout);
d517 2
a518 2
	struct pf_tree_node	*cur, *peer, *next;
	struct pf_tree_node	 key;
d523 1
a523 1
		if (pf_state_expires(cur->state) <= time.tv_sec) {
d542 2
a543 14
#if NPFSYNC
			pfsync_delete_state(cur->state);
#endif
			if (--cur->state->rule.ptr->states <= 0)
				pf_rm_rule(NULL, cur->state->rule.ptr);
			if (cur->state->nat_rule.ptr != NULL)
				if (--cur->state->nat_rule.ptr->states <= 0)
					pf_rm_rule(NULL,
					    cur->state->nat_rule.ptr);
			if (cur->state->anchor.ptr != NULL)
				if (--cur->state->anchor.ptr->states <= 0)
					pf_rm_rule(NULL,
					    cur->state->anchor.ptr);
			pf_normalize_tcp_cleanup(cur->state);
a553 28
pf_tbladdr_setup(struct pf_ruleset *rs, struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_TABLE)
		return (0);
	if ((aw->p.tbl = pfr_attach_table(rs, aw->v.tblname)) == NULL)
		return (1);
	return (0);
}

void
pf_tbladdr_remove(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_TABLE || aw->p.tbl == NULL)
		return;
	pfr_detach_table(aw->p.tbl);
	aw->p.tbl = NULL;
}

void
pf_tbladdr_copyout(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_TABLE || aw->p.tbl == NULL)
		return;
	aw->p.tblcnt = (aw->p.tbl->pfrkt_flags & PFR_TFLAG_ACTIVE) ?
		aw->p.tbl->pfrkt_cnt : -1;
}

int
d556 1
a556 1
	if (aw->type != PF_ADDR_DYNIFTL)
d558 2
a559 2
	aw->p.dyn = pool_get(&pf_addr_pl, PR_NOWAIT);
	if (aw->p.dyn == NULL)
d561 6
a566 5
	bcopy(aw->v.ifname, aw->p.dyn->ifname, sizeof(aw->p.dyn->ifname));
	aw->p.dyn->ifp = ifunit(aw->p.dyn->ifname);
	if (aw->p.dyn->ifp == NULL) {
		pool_put(&pf_addr_pl, aw->p.dyn);
		aw->p.dyn = NULL;
d569 9
a577 9
	aw->p.dyn->addr = &aw->v.a.addr;
	aw->p.dyn->af = af;
	aw->p.dyn->undefined = 1;
	aw->p.dyn->hook_cookie = hook_establish(
	    aw->p.dyn->ifp->if_addrhooks, 1,
	    pf_dynaddr_update, aw->p.dyn);
	if (aw->p.dyn->hook_cookie == NULL) {
		pool_put(&pf_addr_pl, aw->p.dyn);
		aw->p.dyn = NULL;
d580 1
a580 1
	pf_dynaddr_update(aw->p.dyn);
d587 3
a589 3
	struct pf_addr_dyn	*ad = (struct pf_addr_dyn *)p;
	struct ifaddr		*ia;
	int			 s, changed = 0;
d632 1
a632 1
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL)
d634 4
a637 4
	hook_disestablish(aw->p.dyn->ifp->if_addrhooks,
	    aw->p.dyn->hook_cookie);
	pool_put(&pf_addr_pl, aw->p.dyn);
	aw->p.dyn = NULL;
d643 1
a643 1
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL)
d645 3
a647 2
	bcopy(aw->p.dyn->ifname, aw->v.ifname, sizeof(aw->v.ifname));
	aw->p.dyn = (struct pf_addr_dyn *)1;
d653 1
a653 1
	switch (af) {
d657 3
a659 6
		printf("%u.%u.%u.%u", (a>>24)&255, (a>>16)&255,
		    (a>>8)&255, a&255);
		if (p) {
			p = ntohs(p);
			printf(":%u", p);
		}
d701 2
a702 4
		if (p) {
			p = ntohs(p);
			printf("[%u]", p);
		}
d734 1
a734 1
	printf(" [lo=%u high=%u win=%u modulator=%u", s->src.seqlo,
d736 1
a736 4
	if (s->src.wscale && s->dst.wscale)
		printf(" wscale=%u", s->src.wscale & PF_WSCALE_MASK);
	printf("]");
	printf(" [lo=%u high=%u win=%u modulator=%u", s->dst.seqlo,
a737 3
	if (s->src.wscale && s->dst.wscale)
		printf(" wscale=%u", s->dst.wscale & PF_WSCALE_MASK);
	printf("]");
d764 9
a772 7
#define	PF_SET_SKIP_STEPS(i)					\
	do {							\
		while (head[i] != cur) {			\
			head[i]->skip[i].ptr = cur;		\
			head[i] = TAILQ_NEXT(head[i], entries);	\
		}						\
	} while (0)
d777 2
a778 2
	struct pf_rule *cur, *prev, *head[PF_SKIP_COUNT];
	int i;
d780 41
a820 49
	cur = TAILQ_FIRST(rules);
	prev = cur;
	for (i = 0; i < PF_SKIP_COUNT; ++i)
		head[i] = cur;
	while (cur != NULL) {

		if (cur->ifp != prev->ifp || cur->ifnot != prev->ifnot)
			PF_SET_SKIP_STEPS(PF_SKIP_IFP);
		if (cur->direction != prev->direction)
			PF_SET_SKIP_STEPS(PF_SKIP_DIR);
		if (cur->af != prev->af)
			PF_SET_SKIP_STEPS(PF_SKIP_AF);
		if (cur->proto != prev->proto)
			PF_SET_SKIP_STEPS(PF_SKIP_PROTO);
		if (cur->src.addr.type == PF_ADDR_DYNIFTL ||
		    prev->src.addr.type == PF_ADDR_DYNIFTL ||
		    cur->src.addr.type == PF_ADDR_TABLE ||
		    prev->src.addr.type == PF_ADDR_TABLE ||
		    cur->src.not != prev->src.not ||
		    (cur->src.addr.type == PF_ADDR_NOROUTE) !=
		    (prev->src.addr.type == PF_ADDR_NOROUTE) ||
		    !PF_AEQ(&cur->src.addr.v.a.addr,
		    &prev->src.addr.v.a.addr, 0) ||
		    !PF_AEQ(&cur->src.addr.v.a.mask,
		    &prev->src.addr.v.a.mask, 0))
			PF_SET_SKIP_STEPS(PF_SKIP_SRC_ADDR);
		if (cur->src.port[0] != prev->src.port[0] ||
		    cur->src.port[1] != prev->src.port[1] ||
		    cur->src.port_op != prev->src.port_op)
			PF_SET_SKIP_STEPS(PF_SKIP_SRC_PORT);
		if (cur->dst.addr.type == PF_ADDR_DYNIFTL ||
		    prev->dst.addr.type == PF_ADDR_DYNIFTL ||
		    cur->dst.addr.type == PF_ADDR_TABLE ||
		    prev->dst.addr.type == PF_ADDR_TABLE ||
		    cur->dst.not != prev->dst.not ||
		    (cur->dst.addr.type == PF_ADDR_NOROUTE) !=
		    (prev->dst.addr.type == PF_ADDR_NOROUTE) ||
		    !PF_AEQ(&cur->dst.addr.v.a.addr,
		    &prev->dst.addr.v.a.addr, 0) ||
		    !PF_AEQ(&cur->dst.addr.v.a.mask,
		    &prev->dst.addr.v.a.mask, 0))
			PF_SET_SKIP_STEPS(PF_SKIP_DST_ADDR);
		if (cur->dst.port[0] != prev->dst.port[0] ||
		    cur->dst.port[1] != prev->dst.port[1] ||
		    cur->dst.port_op != prev->dst.port_op)
			PF_SET_SKIP_STEPS(PF_SKIP_DST_PORT);

		prev = cur;
		cur = TAILQ_NEXT(cur, entries);
a821 44
	for (i = 0; i < PF_SKIP_COUNT; ++i)
		PF_SET_SKIP_STEPS(i);
}

void
pf_rule_set_qid(struct pf_rulequeue *rules)
{
	struct pf_rule *rule;

	TAILQ_FOREACH(rule, rules, entries)
		if (rule->qname[0] != 0) {
			rule->qid = pf_qname_to_qid(rule->qname);
			if (rule->pqname[0] != 0)
				rule->pqid = pf_qname_to_qid(rule->pqname);
			else
				rule->pqid = rule->qid;
		}
}

u_int32_t
pf_qname_to_qid(char *qname)
{
	struct pf_altq		*altq;

	TAILQ_FOREACH(altq, pf_altqs_active, entries)
		if (!strcmp(altq->qname, qname))
			return (altq->qid);

	return (0);
}

void
pf_update_anchor_rules()
{
	struct pf_rule	*rule;
	int		 i;

	for (i = 0; i < PF_RULESET_MAX; ++i)
		TAILQ_FOREACH(rule, pf_main_ruleset.rules[i].active.ptr,
		    entries)
			if (rule->anchorname[0])
				rule->anchor = pf_find_anchor(rule->anchorname);
			else
				rule->anchor = NULL;
d827 1
a827 1
	u_int32_t	l;
d843 2
a844 2
	struct pf_addr	ao;
	u_int16_t	po = *p;
a882 2

/* Changes a u_int32_t.  Uses a void * so there are no align restrictions */
d884 1
a884 1
pf_change_a(void *a, u_int16_t *c, u_int32_t an, u_int8_t u)
d886 1
a886 1
	u_int32_t	ao;
d888 1
a888 2
	memcpy(&ao, a, sizeof(ao));
	memcpy(a, &an, sizeof(u_int32_t));
d890 1
a890 1
	    ao % 65536, an % 65536, u);
d897 1
a897 1
	struct pf_addr	ao;
d921 3
a923 1
	struct pf_addr	oia, ooa;
d928 2
d931 6
a936 14
	if (ip != NULL) {
		u_int16_t	oip = *ip;
		u_int32_t	opc;

		if (pc != NULL)
			opc = *pc;
		*ip = np;
		if (pc != NULL)
			*pc = pf_cksum_fixup(*pc, oip, *ip, u);
		*ic = pf_cksum_fixup(*ic, oip, *ip, 0);
		if (pc != NULL)
			*ic = pf_cksum_fixup(*ic, opc, *pc, 0);
	}
	/* Change inner ip address, fix inner ip and icmp checksums. */
d938 1
d941 1
a941 3
	case AF_INET: {
		u_int32_t	 oh2c = *h2c;

a947 1
		*ic = pf_cksum_fixup(*ic, oh2c, *h2c, 0);
a948 1
	}
d966 2
a967 1
	/* Change outer ip address, fix outer ip or icmpv6 checksum. */
d996 2
a997 116
pf_send_syn(sa_family_t af, const struct pf_addr *saddr,
    const struct pf_addr *daddr, u_int16_t sport, u_int16_t dport,
    u_int32_t isn)
{
	struct mbuf	*m;
	struct m_tag	*mtag;
	int		 len;
#ifdef INET
	struct ip	*h;
#endif /* INET */
#ifdef INET6
	struct ip6_hdr	*h6;
#endif /* INET6 */
	struct tcphdr	*th;

	switch (af) {
#ifdef INET
	case AF_INET:
		len = sizeof(struct ip) + sizeof(struct tcphdr);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		len = sizeof(struct ip6_hdr) + sizeof(struct tcphdr);
		break;
#endif /* INET6 */
	}

	/* create outgoing mbuf */
	mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
	if (mtag == NULL)
		return;
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	if (m == NULL) {
		m_tag_free(mtag);
		return;
	}
	m_tag_prepend(m, mtag);
	m->m_data += max_linkhdr;
	m->m_pkthdr.len = m->m_len = len;
	m->m_pkthdr.rcvif = NULL;
	bzero(m->m_data, len);
	switch (af) {
#ifdef INET
	case AF_INET:
		h = mtod(m, struct ip *);

		/* IP header fields included in the TCP checksum */
		h->ip_p = IPPROTO_TCP;
		h->ip_len = htons(sizeof(*th));
		h->ip_src.s_addr = saddr->v4.s_addr;
		h->ip_dst.s_addr = daddr->v4.s_addr;

		th = (struct tcphdr *)((caddr_t)h + sizeof(struct ip));
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		h6 = mtod(m, struct ip6_hdr *);

		/* IP header fields included in the TCP checksum */
		h6->ip6_nxt = IPPROTO_TCP;
		h6->ip6_plen = htons(sizeof(*th));
		memcpy(&h6->ip6_src, &saddr->v6, sizeof(struct in6_addr));
		memcpy(&h6->ip6_dst, &daddr->v6, sizeof(struct in6_addr));

		th = (struct tcphdr *)((caddr_t)h6 + sizeof(struct ip6_hdr));
		break;
#endif /* INET6 */
	}

	/* TCP header */
	th->th_sport = sport;
	th->th_dport = dport;
	th->th_seq = htonl(isn);
	th->th_ack = 0;
	th->th_off = sizeof(*th) >> 2;
	th->th_flags = TH_SYN;
	th->th_win = htons(1);
	th->th_sum = 0;
	th->th_urp = 0;

	switch (af) {
#ifdef INET
	case AF_INET:
		/* TCP checksum */
		th->th_sum = in_cksum(m, len);

		/* Finish the IP header */
		h->ip_v = 4;
		h->ip_hl = sizeof(*h) >> 2;
		h->ip_ttl = ip_defttl;
		h->ip_sum = 0;
		h->ip_len = len;
		h->ip_off = ip_mtudisc ? IP_DF : 0;
		ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL,
		    (void *)NULL);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		/* TCP checksum */
		th->th_sum = in6_cksum(m, IPPROTO_TCP,
		    sizeof(struct ip6_hdr), sizeof(*th));

		h6->ip6_vfc |= IPV6_VERSION;
		h6->ip6_hlim = IPV6_DEFHLIM;

		ip6_output(m, NULL, NULL, 0, NULL, NULL);
#endif /* INET6 */
	}
}

void
pf_send_ack(int off, struct tcphdr *th, struct pf_pdesc *pd, sa_family_t af,
    u_int8_t return_ttl, struct pf_rule *r, u_int8_t flags, u_int32_t isn)
d999 3
a1001 3
	struct mbuf	*m;
	struct m_tag	*mtag;
	int		 len;
d1003 1
a1003 1
	struct ip	*h2;
d1006 1
a1006 1
	struct ip6_hdr	*h2_6;
d1008 1
a1008 1
	struct tcphdr	*th2;
d1075 1
a1075 1
		th2->th_flags = flags;
d1083 1
a1083 3
		th2->th_flags = TH_ACK | flags;
		if (flags & TH_SYN)
			th2->th_seq = htonl(isn);
a1086 16
#ifdef ALTQ
	if (r->qid) {
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m, struct ip *);
			m_tag_prepend(m, mtag);
		}
	}
#endif

d1103 1
a1103 1
		    (void *)NULL);
d1123 1
a1123 2
pf_send_icmp(struct mbuf *m, u_int8_t type, u_int8_t code, sa_family_t af,
    struct pf_rule *r)
d1125 2
a1126 2
	struct m_tag	*mtag;
	struct mbuf	*m0;
a1136 17

#ifdef ALTQ
	if (r->qid) {
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m0, struct ip *);
			m_tag_prepend(m0, mtag);
		}
	}
#endif

d1160 1
a1160 2
	int	match = 0;

a1203 2
	case PF_OP_RRG:
		return ((p >= a1) && (p <= a2));
a1244 62
struct pf_tag *
pf_get_tag(struct mbuf *m)
{
	struct m_tag	*mtag;

	if ((mtag = m_tag_find(m, PACKET_TAG_PF_TAG, NULL)) != NULL)
		return ((struct pf_tag *)(mtag + 1));
	else
		return (NULL);
}

int
pf_tag_packet(struct mbuf *m, struct pf_tag *pftag, u_int16_t tag)
{
	struct m_tag	*mtag;

	if (tag == 0)
		return (0);

	if (pftag == NULL) {
		mtag = m_tag_get(PACKET_TAG_PF_TAG, sizeof(*pftag), M_NOWAIT);
		if (mtag == NULL)
			return (1);
		((struct pf_tag *)(mtag + 1))->tag = tag;
		m_tag_prepend(m, mtag);
	} else
		pftag->tag = tag;

	return (0);
}

#define PF_STEP_INTO_ANCHOR(r, a, s, n)					\
	do {								\
		if ((r) == NULL || (r)->anchor == NULL ||		\
		    (s) != NULL || (a) != NULL)				\
			panic("PF_STEP_INTO_ANCHOR");			\
		(a) = (r);						\
		(s) = TAILQ_FIRST(&(r)->anchor->rulesets);		\
		(r) = NULL;						\
		while ((s) != NULL && ((r) =				\
		    TAILQ_FIRST((s)->rules[n].active.ptr)) == NULL)	\
			(s) = TAILQ_NEXT((s), entries);			\
		if ((r) == NULL) {					\
			(r) = TAILQ_NEXT((a), entries);			\
			(a) = NULL;					\
		}							\
	} while (0)

#define PF_STEP_OUT_OF_ANCHOR(r, a, s, n)				\
	do {								\
		if ((r) != NULL || (a) == NULL || (s) == NULL)		\
			panic("PF_STEP_OUT_OF_ANCHOR");			\
		(s) = TAILQ_NEXT((s), entries);				\
		while ((s) != NULL && ((r) =				\
		    TAILQ_FIRST((s)->rules[n].active.ptr)) == NULL)	\
			(s) = TAILQ_NEXT((s), entries);			\
		if ((r) == NULL) {					\
			(r) = TAILQ_NEXT((a), entries);			\
			(a) = NULL;					\
		}							\
	} while (0)

d1254 1
a1254 1
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]);
d1259 1
a1259 1
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]);
d1261 1
a1261 1
		((rmask->addr32[1] ^ 0xffffffff ) & saddr->addr32[1]);
d1263 1
a1263 1
		((rmask->addr32[2] ^ 0xffffffff ) & saddr->addr32[2]);
d1265 1
a1265 1
		((rmask->addr32[3] ^ 0xffffffff ) & saddr->addr32[3]);
d1269 1
d1271 4
a1274 2
void
pf_addr_inc(struct pf_addr *addr, u_int8_t af)
d1276 1
a1276 28
	switch (af) {
#ifdef INET
	case AF_INET:
		addr->addr32[0] = htonl(ntohl(addr->addr32[0]) + 1);
		break;
#endif /* INET */
	case AF_INET6:
		if (addr->addr32[3] == 0xffffffff) {
			addr->addr32[3] = 0;
			if (addr->addr32[2] == 0xffffffff) {
				addr->addr32[2] = 0;
				if (addr->addr32[1] == 0xffffffff) {
					addr->addr32[1] = 0;
					addr->addr32[0] =
					    htonl(ntohl(addr->addr32[0]) + 1);
				} else
					addr->addr32[1] =
					    htonl(ntohl(addr->addr32[1]) + 1);
			} else
				addr->addr32[2] =
				    htonl(ntohl(addr->addr32[2]) + 1);
		} else
			addr->addr32[3] =
			    htonl(ntohl(addr->addr32[3]) + 1);
		break;
	}
}
#endif /* INET6 */
d1278 2
a1279 12
#define mix(a,b,c) \
	do {					\
		a -= b; a -= c; a ^= (c >> 13);	\
		b -= c; b -= a; b ^= (a << 8);	\
		c -= a; c -= b; c ^= (b >> 13);	\
		a -= b; a -= c; a ^= (c >> 12);	\
		b -= c; b -= a; b ^= (a << 16);	\
		c -= a; c -= b; c ^= (b >> 5);	\
		a -= b; a -= c; a ^= (c >> 3);	\
		b -= c; b -= a; b ^= (a << 10);	\
		c -= a; c -= b; c ^= (b >> 15);	\
	} while (0)
d1281 9
a1289 41
/*
 * hash function based on bridge_hash in if_bridge.c
 */
void
pf_hash(struct pf_addr *inaddr, struct pf_addr *hash,
    struct pf_poolhashkey *key, sa_family_t af)
{
	u_int32_t	a = 0x9e3779b9, b = 0x9e3779b9, c = key->key32[0];

	switch (af) {
#ifdef INET
	case AF_INET:
		a += inaddr->addr32[0];
		b += key->key32[1];
		mix(a, b, c);
		hash->addr32[0] = c + key->key32[2];
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		a += inaddr->addr32[0];
		b += inaddr->addr32[2];
		mix(a, b, c);
		hash->addr32[0] = c;
		a += inaddr->addr32[1];
		b += inaddr->addr32[3];
		c += key->key32[1];
		mix(a, b, c);
		hash->addr32[1] = c;
		a += inaddr->addr32[2];
		b += inaddr->addr32[1];
		c += key->key32[2];
		mix(a, b, c);
		hash->addr32[2] = c;
		a += inaddr->addr32[3];
		b += inaddr->addr32[0];
		c += key->key32[3];
		mix(a, b, c);
		hash->addr32[3] = c;
		break;
#endif /* INET6 */
a1290 1
}
d1292 13
a1304 10
int
pf_map_addr(u_int8_t af, struct pf_pool *rpool, struct pf_addr *saddr,
    struct pf_addr *naddr, struct pf_addr *init_addr)
{
	unsigned char		 hash[16];
	struct pf_addr		*raddr = &rpool->cur->addr.addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.addr.v.a.mask;

	if (rpool->cur->addr.addr.type == PF_ADDR_NOROUTE ||
	    rpool->cur->addr.addr.type == PF_ADDR_TABLE)
d1306 6
a1311 65
	if (rpool->cur->addr.addr.type == PF_ADDR_DYNIFTL &&
	    rpool->cur->addr.addr.p.dyn->undefined)
		return (1);

	switch (rpool->opts & PF_POOL_TYPEMASK) {
	case PF_POOL_NONE:
		PF_ACPY(naddr, raddr, af);
		break;
	case PF_POOL_BITMASK:
		PF_POOLMASK(naddr, raddr, rmask, saddr, af);
		break;
	case PF_POOL_RANDOM:
		if (init_addr != NULL && PF_AZERO(init_addr, af)) {
			switch (af) {
#ifdef INET
			case AF_INET:
				rpool->counter.addr32[0] = arc4random();
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				if (rmask->addr32[3] != 0xffffffff)
					rpool->counter.addr32[3] = arc4random();
				else
					break;
				if (rmask->addr32[2] != 0xffffffff)
					rpool->counter.addr32[2] = arc4random();
				else
					break;
				if (rmask->addr32[1] != 0xffffffff)
					rpool->counter.addr32[1] = arc4random();
				else
					break;
				if (rmask->addr32[0] != 0xffffffff)
					rpool->counter.addr32[0] = arc4random();
				break;
#endif /* INET6 */
			}
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af);
			PF_ACPY(init_addr, naddr, af);

		} else {
			PF_AINC(&rpool->counter, af);
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af);
		}
		break;
	case PF_POOL_SRCHASH:
		pf_hash(saddr, (struct pf_addr *)&hash, &rpool->key, af);
		PF_POOLMASK(naddr, raddr, rmask, (struct pf_addr *)&hash, af);
		break;
	case PF_POOL_ROUNDROBIN:
		if (pf_match_addr(0, &rpool->cur->addr.addr.v.a.addr,
		    &rpool->cur->addr.addr.v.a.mask, &rpool->counter, af)) {
			PF_ACPY(naddr, &rpool->counter, af);
			PF_AINC(&rpool->counter, af);
		} else {
			if ((rpool->cur =
			    TAILQ_NEXT(rpool->cur, entries)) == NULL)
				rpool->cur = TAILQ_FIRST(&rpool->list);
			PF_ACPY(naddr, &rpool->cur->addr.addr.v.a.addr, af);
			PF_ACPY(&rpool->counter,
			    &rpool->cur->addr.addr.v.a.addr, af);
			PF_AINC(&rpool->counter, af);
		}
		break;
d1314 7
a1320 22
	if (pf_status.debug >= PF_DEBUG_MISC &&
	    (rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		printf("pf_map_addr: selected address: ");
		pf_print_host(naddr, 0, af);
		printf("\n");
	}

	return (0);
}

int
pf_get_sport(sa_family_t af, u_int8_t proto, struct pf_pool *rpool,
    struct pf_addr *saddr, struct pf_addr *daddr, u_int16_t dport,
    struct pf_addr *naddr, u_int16_t *nport, u_int16_t low, u_int16_t high)
{
	struct pf_tree_node	key;
	struct pf_addr		init_addr;
	u_int16_t		cut;

	bzero(&init_addr, sizeof(init_addr));
	if (pf_map_addr(af, rpool, saddr, naddr, &init_addr))
		return (1);
d1322 2
d1325 5
a1329 5
		key.af = af;
		key.proto = proto;
		PF_ACPY(&key.addr[0], daddr, key.af);
		PF_ACPY(&key.addr[1], naddr, key.af);
		key.port[0] = dport;
d1331 2
a1332 27
		/*
		 * port search; start random, step;
		 * similar 2 portloop in in_pcbbind
		 */
		if (!(proto == IPPROTO_TCP || proto == IPPROTO_UDP)) {
			key.port[1] = 0;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL)
				return (0);
		} else if (rpool->opts & PF_POOL_STATICPORT) {
			key.port[1] = *nport;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL)
				return (0);
		} else if (low == 0 && high == 0) {
			key.port[1] = *nport;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
				NTOHS(*nport);
				return (0);
			}
		} else if (low == high) {
			key.port[1] = htons(low);
			if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
				*nport = low;
				return (0);
			}
		} else {
			if (low > high) {
				u_int16_t tmp;
d1334 37
a1370 18
				tmp = low;
				low = high;
				high = tmp;
			}
			/* low < high */
			cut = arc4random() % (1 + high - low) + low;
			/* low <= cut <= high */
			for (*nport = cut; *nport <= high; ++(*nport)) {
				key.port[1] = htons(*nport);
				if (pf_find_state(&tree_ext_gwy, &key) == NULL)
					return (0);
			}
			for (*nport = cut - 1; *nport >= low; --(*nport)) {
				key.port[1] = htons(*nport);
				if (pf_find_state(&tree_ext_gwy, &key) == NULL)
					return (0);
			}
		}
d1372 43
a1414 5
		switch (rpool->opts & PF_POOL_TYPEMASK) {
		case PF_POOL_RANDOM:
		case PF_POOL_ROUNDROBIN:
			if (pf_map_addr(af, rpool, saddr, naddr, &init_addr))
				return (1);
d1416 7
a1422 5
		case PF_POOL_NONE:
		case PF_POOL_SRCHASH:
		case PF_POOL_BITMASK:
		default:
			return (1);
d1425 1
a1425 1
	} while (! PF_AEQ(&init_addr, naddr, af) );
d1427 1
a1427 1
	return (1);					/* none available */
d1430 3
a1432 4
struct pf_rule *
pf_match_translation(int direction, struct ifnet *ifp, u_int8_t proto,
    struct pf_addr *saddr, u_int16_t sport, struct pf_addr *daddr,
    u_int16_t dport, sa_family_t af, int rs_num)
d1434 1
a1434 2
	struct pf_rule		*r, *rm = NULL, *anchorrule = NULL;
	struct pf_ruleset	*ruleset = NULL;
d1436 1
a1436 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[rs_num].active.ptr);
d1438 15
a1452 38
		struct pf_rule_addr	*src = NULL, *dst = NULL;

		if (r->action == PF_BINAT && direction == PF_IN) {
			src = &r->dst;
			if (r->rpool.cur != NULL)
				dst = &r->rpool.cur->addr;
		} else {
			src = &r->src;
			dst = &r->dst;
		}

		r->evaluations++;
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&src->addr, saddr, af, src->not))
			r = r->skip[src == &r->src ? PF_SKIP_SRC_ADDR :
			    PF_SKIP_DST_ADDR].ptr;
		else if (src->port_op && !pf_match_port(src->port_op,
		    src->port[0], src->port[1], sport))
			r = r->skip[src == &r->src ? PF_SKIP_SRC_PORT :
			    PF_SKIP_DST_PORT].ptr;
		else if (dst != NULL &&
		    PF_MISMATCHAW(&dst->addr, daddr, af, dst->not))
			r = dst == &r->dst ? r->skip[PF_SKIP_DST_ADDR].ptr :
			    TAILQ_NEXT(r, entries);
		else if (dst != NULL && dst->port_op &&
		    !pf_match_port(dst->port_op, dst->port[0],
		    dst->port[1], dport))
			r = dst == &r->dst ? r->skip[PF_SKIP_DST_PORT].ptr :
			    TAILQ_NEXT(r, entries);
		else if (r->anchorname[0] && r->anchor == NULL)
a1453 7
		else if (r->anchor == NULL)
				rm = r;
		else
			PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset, rs_num);
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
			    rs_num);
d1455 2
a1456 2
	if (rm != NULL && (rm->action == PF_NONAT ||
	    rm->action == PF_NORDR || rm->action == PF_NOBINAT))
d1461 2
a1462 5
struct pf_rule *
pf_get_translation(int direction, struct ifnet *ifp, u_int8_t proto,
    struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport,
    struct pf_addr *naddr, u_int16_t *nport, sa_family_t af)
d1464 1
a1464 85
	struct pf_rule	*r = NULL;

	if (direction == PF_OUT) {
		r = pf_match_translation(direction, ifp, proto,
		    saddr, sport, daddr, dport, af, PF_RULESET_BINAT);
		if (r == NULL)
			r = pf_match_translation(direction, ifp, proto,
			    saddr, sport, daddr, dport, af, PF_RULESET_NAT);
	} else {
		r = pf_match_translation(direction, ifp, proto,
		    saddr, sport, daddr, dport, af, PF_RULESET_RDR);
		if (r == NULL)
			r = pf_match_translation(direction, ifp, proto,
			    saddr, sport, daddr, dport, af, PF_RULESET_BINAT);
	}

	if (r != NULL) {
		switch (r->action) {
		case PF_NONAT:
		case PF_NOBINAT:
		case PF_NORDR:
			return (NULL);
			break;
		case PF_NAT:
			if (pf_get_sport(af, proto, &r->rpool, saddr, daddr,
			    dport, naddr, nport, r->rpool.proxy_port[0],
			    r->rpool.proxy_port[1])) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: NAT proxy port allocation "
				    "(%u-%u) failed\n",
				    r->rpool.proxy_port[0],
				    r->rpool.proxy_port[1]));
				return (NULL);
			}
			break;
		case PF_BINAT:
			switch (direction) {
			case PF_OUT:
				if (r->rpool.cur->addr.addr.type ==
				    PF_ADDR_DYNIFTL &&
				    r->rpool.cur->addr.addr.p.dyn->undefined)
					return (NULL);
				else
					PF_POOLMASK(naddr,
					    &r->rpool.cur->addr.addr.v.a.addr,
					    &r->rpool.cur->addr.addr.v.a.mask,
					    saddr, af);
				break;
			case PF_IN:
				if (r->src.addr.type == PF_ADDR_DYNIFTL &&
				    r->src.addr.p.dyn->undefined)
					return (NULL);
				else
					PF_POOLMASK(naddr,
					    &r->src.addr.v.a.addr,
					    &r->src.addr.v.a.mask, saddr, af);
				break;
			}
			break;
		case PF_RDR: {
			if (pf_map_addr(r->af, &r->rpool, saddr, naddr, NULL))
				return (NULL);

			if (r->rpool.proxy_port[1]) {
				u_int32_t	tmp_nport;

				tmp_nport = ((ntohs(dport) -
				    ntohs(r->dst.port[0])) %
				    (r->rpool.proxy_port[1] -
				    r->rpool.proxy_port[0] + 1)) +
				    r->rpool.proxy_port[0];

				/* wrap around if necessary */
				if (tmp_nport > 65535)
					tmp_nport -= 65535;
				*nport = htons((u_int16_t)tmp_nport);
			} else if (r->rpool.proxy_port[0])
				*nport = htons(r->rpool.proxy_port[0]);
			break;
		}
		default:
			return (NULL);
			break;
		}
	}
d1466 5
a1470 1
	return (r);
d1477 4
a1480 4
	struct pf_addr		*saddr, *daddr;
	u_int16_t		 sport, dport;
	struct inpcbtable	*tb;
	struct inpcb		*inp;
d1484 2
d1504 1
a1504 1
		u_int16_t	p;
d1512 6
a1517 25
	switch(af) {
	case AF_INET:
		inp = in_pcbhashlookup(tb, saddr->v4, sport, daddr->v4, dport);
		if (inp == NULL) {
			inp = in_pcblookup(tb, &saddr->v4, sport, &daddr->v4,
			    dport, INPLOOKUP_WILDCARD);
			if (inp == NULL)
				return (0);
		}
		break;
#ifdef INET6
	case AF_INET6:
		inp = in6_pcbhashlookup(tb, &saddr->v6, sport, &daddr->v6,
		    dport);
		if (inp == NULL) {
			inp = in_pcblookup(tb, &saddr->v6, sport, &daddr->v6,
			    dport, INPLOOKUP_WILDCARD | INPLOOKUP_IPV6);
			if (inp == NULL)
				return (0);
		}
		break;
#endif /* INET6 */

	default:
		return (0);
d1524 3
a1526 2
u_int8_t
pf_get_wscale(struct mbuf *m, int off, u_int16_t th_off, sa_family_t af)
d1528 13
a1540 4
	int		 hlen;
	u_int8_t	 hdr[60];
	u_int8_t	*opt, optlen;
	u_int8_t	 wscale = 0;
d1542 1
a1542 57
	hlen = th_off << 2;		/* hlen <= sizeof(hdr) */
	if (hlen <= sizeof(struct tcphdr))
		return (0);
	if (!pf_pull_hdr(m, off, hdr, hlen, NULL, NULL, af))
		return (0);
	opt = hdr + sizeof(struct tcphdr);
	hlen -= sizeof(struct tcphdr);
	while (hlen >= 3) {
		switch (*opt) {
		case TCPOPT_EOL:
		case TCPOPT_NOP:
			++opt;
			--hlen;
			break;
		case TCPOPT_WINDOW:
			wscale = opt[2];
			if (wscale > TCP_MAX_WINSHIFT)
				wscale = TCP_MAX_WINSHIFT;
			wscale |= PF_WSCALE_FLAG;
			/* fallthrough */
		default:
			optlen = opt[1];
			if (optlen < 2)
				optlen = 2;
			hlen -= optlen;
			opt += optlen;
		}
	}
	return (wscale);
}

int
pf_test_tcp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
{
	struct pf_rule		*nat = NULL, *rdr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct pf_addr		 baddr, naddr;
	struct tcphdr		*th = pd->hdr.tcp;
	u_int16_t		 bport, nport = 0;
	sa_family_t		 af = pd->af;
	int			 lookup = -1;
	uid_t			 uid;
	gid_t			 gid;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	u_short			 reason;
	int			 rewrite = 0;
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
d1545 23
a1567 5
		bport = nport = th->th_sport;
		/* check outgoing packet for BINAT/NAT */
		if ((nat = pf_get_translation(PF_OUT, ifp, IPPROTO_TCP,
		    saddr, th->th_sport, daddr, th->th_dport,
		    &naddr, &nport, af)) != NULL) {
d1570 2
a1571 1
			    &th->th_sum, &naddr, nport, 0, af);
d1575 10
a1584 5
		bport = nport = th->th_dport;
		/* check incoming packet for BINAT/RDR */
		if ((rdr = pf_get_translation(PF_IN, ifp, IPPROTO_TCP,
		    saddr, th->th_sport, daddr, th->th_dport,
		    &naddr, &nport, af)) != NULL) {
d1587 10
a1596 1
			    &th->th_sum, &naddr, nport, 0, af);
d1601 1
a1601 6
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d1604 3
a1606 1
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
d1608 3
a1610 3
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
d1612 1
a1612 1
			r = r->skip[PF_SKIP_AF].ptr;
d1614 7
a1620 3
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
d1623 7
a1629 3
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
d1632 1
a1632 1
			r = r->skip[PF_SKIP_DST_PORT].ptr;
d1640 3
a1642 4
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP,
		    pd), 1)) &&
		    !pf_match_uid(r->uid.op, r->uid.uid[0], r->uid.uid[1],
		    uid))
d1645 3
a1647 4
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP,
		    pd), 1)) &&
		    !pf_match_gid(r->gid.op, r->gid.gid[0], r->gid.gid[1],
		    gid))
d1649 4
a1652 5
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag &&
		    ((!r->match_tag_not && r->match_tag != tag) ||
		    (r->match_tag_not && r->match_tag == tag)))
a1653 49
		else {
			if (r->tag)
				tag = r->tag;
			if (r->anchor == NULL) {
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);

	if (r->log) {
		if (rewrite)
			m_copyback(m, off, sizeof(*th), (caddr_t)th);
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
	}

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNRST) ||
	    (r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		/* undo NAT/RST changes, if they have taken place */
		if (nat != NULL) {
			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &baddr, bport, 0, af);
			rewrite++;
		} else if (rdr != NULL) {
			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &baddr, bport, 0, af);
			rewrite++;
a1654 10
		if ((r->rule_flag & PFRULE_RETURNRST) ||
		    (r->rule_flag & PFRULE_RETURN))
			pf_send_ack(off, th, pd, af,
			    r->return_ttl, r, TH_RST, 0);
		else if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
d1657 38
a1694 2
	if (r->action == PF_DROP)
		return (PF_DROP);
d1696 2
a1697 3
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
d1700 2
a1701 2
	if (r->keep_state || nat != NULL || rdr != NULL ||
	    (pd->flags & PFDESC_TCP_NORM)) {
d1703 2
a1704 2
		u_int16_t	 len;
		struct pf_state	*s = NULL;
d1707 2
a1708 1
		if (!r->max_states || r->states < r->max_states)
d1714 6
a1719 14
		bzero(s, sizeof(*s));
		r->states++;
		if (a != NULL)
			a->states++;
		s->rule.ptr = r;
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d1728 1
a1728 1
			if (nat != NULL) {
d1741 1
a1741 1
			if (rdr != NULL) {
d1753 1
a1753 1
		    r->keep_state == PF_STATE_MODULATE) {
d1762 1
a1762 1
		if (th->th_flags & TH_SYN) {
a1763 10
			s->src.wscale = pf_get_wscale(m, off, th->th_off, af);
		}
		s->src.max_win = MAX(ntohs(th->th_win), 1);
		if (s->src.wscale & PF_WSCALE_MASK) {
			/* Remove scale factor from initial window */
			int win = s->src.max_win;
			win += 1 << (s->src.wscale & PF_WSCALE_MASK);
			s->src.max_win = (win - 1) >>
			    (s->src.wscale & PF_WSCALE_MASK);
		}
d1766 1
d1774 1
a1774 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_TCP_FIRST_PACKET;
a1776 14

		if ((pd->flags & PFDESC_TCP_NORM) && pf_normalize_tcp_init(m,
		    off, pd, th, &s->src, &s->dst)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
		if ((pd->flags & PFDESC_TCP_NORM) && s->src.scrub &&
		    pf_normalize_tcp_stateful(m, off, pd, &reason, th, &s->src,
		    &s->dst, &rewrite)) {
			pf_normalize_tcp_cleanup(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
a1777 1
			pf_normalize_tcp_cleanup(s);
a1780 17
		} else
			*sm = s;
		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
		    r->keep_state == PF_STATE_SYNPROXY) {
			s->src.state = PF_TCPS_PROXY_SRC;
			if (nat != NULL)
				pf_change_ap(saddr, &th->th_sport,
				    pd->ip_sum, &th->th_sum, &baddr,
				    bport, 0, af);
			else if (rdr != NULL)
				pf_change_ap(daddr, &th->th_dport,
				    pd->ip_sum, &th->th_sum, &baddr,
				    bport, 0, af);
			s->src.seqhi = arc4random();
			pf_send_ack(off, th, pd, af, r->return_ttl, r,
			    TH_SYN, s->src.seqhi);
			return (PF_SYNPROXY_DROP);
d1792 18
a1809 25
pf_test_udp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
{
	struct pf_rule		*nat = NULL, *rdr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct pf_addr		 baddr, naddr;
	struct udphdr		*uh = pd->hdr.udp;
	u_int16_t		 bport, nport = 0;
	sa_family_t		 af = pd->af;
	int			 lookup = -1;
	uid_t			 uid;
	gid_t			 gid;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	u_short			 reason;
	int			 rewrite = 0;
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
d1812 23
a1834 5
		bport = nport = uh->uh_sport;
		/* check outgoing packet for BINAT/NAT */
		if ((nat = pf_get_translation(PF_OUT, ifp, IPPROTO_UDP,
		    saddr, uh->uh_sport, daddr, uh->uh_dport,
		    &naddr, &nport, af)) != NULL) {
d1837 2
a1838 1
			    &uh->uh_sum, &naddr, nport, 1, af);
d1842 19
a1860 5
		bport = nport = uh->uh_dport;
		/* check incoming packet for BINAT/RDR */
		if ((rdr = pf_get_translation(PF_IN, ifp, IPPROTO_UDP,
		    saddr, uh->uh_sport, daddr, uh->uh_dport,
		    &naddr, &nport, af)) != NULL) {
d1862 1
d1864 1
a1864 1
			    &uh->uh_sum, &naddr, nport, 1, af);
d1869 1
a1869 6
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d1872 3
a1874 1
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
d1876 3
a1878 3
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
d1880 1
a1880 1
			r = r->skip[PF_SKIP_AF].ptr;
d1882 8
a1889 3
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
d1892 8
a1899 3
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
d1902 1
a1902 1
			r = r->skip[PF_SKIP_DST_PORT].ptr;
d1908 3
a1910 4
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP,
		    pd), 1)) &&
		    !pf_match_uid(r->uid.op, r->uid.uid[0], r->uid.uid[1],
		    uid))
d1913 3
a1915 4
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP,
		    pd), 1)) &&
		    !pf_match_gid(r->gid.op, r->gid.gid[0], r->gid.gid[1],
		    gid))
d1917 4
a1920 3
		else if (r->match_tag &&
		    ((!r->match_tag_not && r->match_tag != tag) ||
		    (r->match_tag_not && r->match_tag == tag)))
a1921 50
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->anchor == NULL) {
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);

	if (r->log) {
		if (rewrite)
			m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
	}

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		/* undo NAT/RST changes, if they have taken place */
		if (nat != NULL) {
			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &baddr, bport, 1, af);
			rewrite++;
		} else if (rdr != NULL) {
			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &baddr, bport, 1, af);
			rewrite++;
a1922 6
		if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
d1925 33
a1957 2
	if (r->action == PF_DROP)
		return (PF_DROP);
d1959 2
a1960 3
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
d1963 2
a1964 1
	if (r->keep_state || nat != NULL || rdr != NULL) {
d1966 1
a1966 1
		struct pf_state	*s = NULL;
d1968 2
a1969 1
		if (!r->max_states || r->states < r->max_states)
d1973 6
a1978 15
		bzero(s, sizeof(*s));
		r->states++;
		if (a != NULL)
			a->states++;

		s->rule.ptr = r;
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d1987 1
a1987 1
			if (nat != NULL) {
d1999 1
a1999 1
			if (rdr != NULL) {
d2018 1
a2018 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_UDP_FIRST_PACKET;
d2025 1
a2025 2
		} else
			*sm = s;
d2036 13
a2048 16
pf_test_icmp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
{
	struct pf_rule		*nat = NULL, *rdr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct pf_addr		 baddr, naddr;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	u_short			 reason;
	u_int16_t		 icmpid;
	sa_family_t		 af = pd->af;
	u_int8_t		 icmptype, icmpcode;
	int			 state_icmp = 0;
	struct pf_tag		*pftag;
	u_int16_t		 tag;
d2050 1
a2050 1
	int			 rewrite = 0;
d2053 1
a2053 5
	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
d2086 3
a2088 3
		/* check outgoing packet for BINAT/NAT */
		if ((nat = pf_get_translation(PF_OUT, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d2106 20
d2127 23
a2149 3
		/* check incoming packet for BINAT/RDR */
		if ((rdr = pf_get_translation(PF_IN, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d2169 1
a2169 6
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2172 3
a2174 1
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
d2176 3
a2178 3
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
d2180 1
a2180 1
			r = r->skip[PF_SKIP_AF].ptr;
d2182 13
a2194 5
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
d2203 4
a2206 3
		else if (r->match_tag &&
		    ((!r->match_tag_not && r->match_tag != tag) ||
		    (r->match_tag_not && r->match_tag == tag)))
d2208 1
a2208 39
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->anchor == NULL) {
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);

	if (r->log) {
#ifdef INET6
		if (rewrite)
			m_copyback(m, off, sizeof(struct icmp6_hdr),
			    (caddr_t)pd->hdr.icmp6);
#endif /* INET6 */
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
d2211 13
a2223 2
	if (r->action != PF_PASS)
		return (PF_DROP);
d2225 2
a2226 3
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
d2229 2
a2230 2
	if (!state_icmp && (r->keep_state ||
	    nat != NULL || rdr != NULL)) {
d2232 1
a2232 1
		struct pf_state	*s = NULL;
d2234 2
a2235 1
		if (!r->max_states || r->states < r->max_states)
d2239 6
a2244 15
		bzero(s, sizeof(*s));
		r->states++;
		if (a != NULL)
			a->states++;

		s->rule.ptr = r;
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d2253 1
a2253 1
			if (nat != NULL)
d2263 1
a2263 1
			if (rdr != NULL)
d2280 1
a2280 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_ICMP_FIRST_PACKET;
d2287 1
a2287 2
		} else
			*sm = s;
d2293 1
a2293 1
		m_copyback(m, off, sizeof(struct icmp6_hdr),
d2301 13
a2313 19
pf_test_other(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct ifnet *ifp, struct mbuf *m, void *h, struct pf_pdesc *pd,
    struct pf_rule **am, struct pf_ruleset **rsm)
{
	struct pf_rule		*nat = NULL, *rdr = NULL;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct pf_addr		 baddr, naddr;
	sa_family_t		 af = pd->af;
	u_short			 reason;
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
d2316 3
a2318 3
		/* check outgoing packet for BINAT/NAT */
		if ((nat = pf_get_translation(PF_OUT, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d2334 18
d2353 21
a2373 3
		/* check incoming packet for BINAT/RDR */
		if ((rdr = pf_get_translation(PF_IN, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d2391 1
a2391 6
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2394 3
a2396 1
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
d2398 3
a2400 3
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
d2402 1
a2402 1
			r = r->skip[PF_SKIP_AF].ptr;
d2404 13
a2416 5
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
a2420 6
		else if (r->match_tag &&
		    ((!r->match_tag_not && r->match_tag != tag) ||
		    (r->match_tag_not && r->match_tag == tag)))
			r = TAILQ_NEXT(r, entries);
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
d2422 2
a2423 46
			if (r->tag)
				tag = r->tag;
			if (r->anchor == NULL) {
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);
	if (r->log)
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		struct pf_addr *a = NULL;

		if (nat != NULL)
			a = saddr;
		else if (rdr != NULL)
			a = daddr;
		if (a != NULL) {
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&a->v4.s_addr, pd->ip_sum,
				    baddr.v4.s_addr, 0);
d2425 1
a2425 7
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(a, &baddr, af);
				break;
#endif /* INET6 */
			}
a2426 6
		if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
d2429 6
a2434 2
	if (r->action != PF_PASS)
		return (PF_DROP);
d2436 2
a2437 3
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
d2440 2
a2441 1
	if (r->keep_state || nat != NULL || rdr != NULL) {
d2443 1
a2443 1
		struct pf_state	*s = NULL;
d2445 2
a2446 1
		if (!r->max_states || r->states < r->max_states)
d2450 6
a2455 15
		bzero(s, sizeof(*s));
		r->states++;
		if (a != NULL)
			a->states++;

		s->rule.ptr = r;
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d2464 1
a2464 1
			if (nat != NULL)
d2474 1
a2474 1
			if (rdr != NULL)
d2491 1
a2491 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_OTHER_FIRST_PACKET;
d2496 1
a2496 1
			if (r->log)
d2498 1
a2498 1
				    r, a, ruleset);
d2501 1
a2501 2
		} else
			*sm = s;
d2509 1
a2509 2
    struct mbuf *m, void *h, struct pf_pdesc *pd, struct pf_rule **am,
    struct pf_ruleset **rsm)
d2511 4
a2514 12
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	sa_family_t		 af = pd->af;
	u_short			 reason;
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
d2516 1
a2516 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2519 3
a2521 1
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
d2523 3
a2525 3
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
d2527 1
a2527 1
			r = r->skip[PF_SKIP_AF].ptr;
d2529 13
a2541 5
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
d2547 4
a2550 3
		else if (r->match_tag &&
		    ((!r->match_tag_not && r->match_tag != tag) ||
		    (r->match_tag_not && r->match_tag == tag)))
d2552 5
a2556 31
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->anchor == NULL) {
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);
	if (r->log)
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
d2558 5
a2562 2
	if (r->action != PF_PASS)
		return (PF_DROP);
d2564 2
a2565 3
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
d2573 1
a2573 2
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd,
    u_short *reason)
d2575 6
a2580 8
	struct pf_tree_node	 key;
	struct tcphdr		*th = pd->hdr.tcp;
	u_int16_t		 win = ntohs(th->th_win);
	u_int32_t		 ack, end, seq;
	u_int8_t		 sws, dws;
	int			 ackskew;
	int			 copyback = 0;
	struct pf_state_peer	*src, *dst;
d2589 6
a2594 1
	STATE_LOOKUP();
a2603 63
	if ((*state)->src.state == PF_TCPS_PROXY_SRC) {
		if (direction != (*state)->direction)
			return (PF_SYNPROXY_DROP);
		if (th->th_flags & TH_SYN) {
			if (ntohl(th->th_seq) != (*state)->src.seqlo)
				return (PF_DROP);
			pf_send_ack(off, th, pd, pd->af, 0, (*state)->rule.ptr,
			    TH_SYN, (*state)->src.seqhi);
			return (PF_SYNPROXY_DROP);
		} else if (!(th->th_flags & TH_ACK) ||
		    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
		    (ntohl(th->th_seq) != (*state)->src.seqlo + 1))
			return (PF_DROP);
		else
			(*state)->src.state = PF_TCPS_PROXY_DST;
	}
	if ((*state)->src.state == PF_TCPS_PROXY_DST) {
		if (direction == (*state)->direction) {
			if (((th->th_flags & (TH_SYN|TH_ACK)) != TH_ACK) ||
			    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
			    (ntohl(th->th_seq) != (*state)->src.seqlo + 1))
				return (PF_DROP);
			if ((*state)->dst.seqhi == 1)
				(*state)->dst.seqhi = arc4random();
			if (direction == PF_OUT)
				pf_send_syn(pd->af, &(*state)->gwy.addr,
				    &(*state)->ext.addr, (*state)->gwy.port,
				    (*state)->ext.port, (*state)->dst.seqhi);
			else
				pf_send_syn(pd->af, &(*state)->ext.addr,
				    &(*state)->lan.addr, (*state)->ext.port,
				    (*state)->lan.port, (*state)->dst.seqhi);
			return (PF_SYNPROXY_DROP);
		} else if (((th->th_flags & (TH_SYN|TH_ACK)) !=
		    (TH_SYN|TH_ACK)) ||
		    (ntohl(th->th_ack) != (*state)->dst.seqhi + 1))
			return (PF_DROP);
		else {
			(*state)->dst.max_win = MAX(ntohs(th->th_win), 1);
			(*state)->dst.seqlo = ntohl(th->th_seq);
			pf_send_ack(off, th, pd, pd->af, 0,
			    (*state)->rule.ptr, 0, 0);
			(*state)->src.seqdiff = (*state)->dst.seqhi -
			    (*state)->src.seqlo;
			(*state)->dst.seqdiff = (*state)->src.seqhi -
			    (*state)->dst.seqlo;
			(*state)->src.seqhi = (*state)->src.seqlo +
			    (*state)->src.max_win;
			(*state)->dst.seqhi = (*state)->dst.seqlo +
			    (*state)->dst.max_win;
			(*state)->src.wscale = (*state)->dst.wscale = 0;
			(*state)->src.state = (*state)->dst.state =
			    TCPS_ESTABLISHED;
			return (PF_SYNPROXY_DROP);
		}
	}

	if (src->wscale && dst->wscale && !(th->th_flags & TH_SYN)) {
		sws = src->wscale & PF_WSCALE_MASK;
		dws = dst->wscale & PF_WSCALE_MASK;
	} else
		sws = dws = 0;

a2613 8
		if ((pd->flags & PFDESC_TCP_NORM || dst->scrub) &&
		    src->scrub == NULL) {
			if (pf_normalize_tcp_init(m, off, pd, th, src, dst)) {
				REASON_SET(reason, PFRES_MEMORY);
				return (PF_DROP);
			}
		}

d2615 1
a2615 1
		if (dst->seqdiff && !src->seqdiff) {
a2621 1
			copyback = 1;
d2627 1
a2627 1
		if (th->th_flags & TH_SYN) {
a2628 19
			if (dst->wscale & PF_WSCALE_FLAG) {
				src->wscale = pf_get_wscale(m, off, th->th_off,
				    pd->af);
				if (src->wscale & PF_WSCALE_FLAG) {
					/* Remove scale factor from initial
					 * window */
					sws = src->wscale & PF_WSCALE_MASK;
					win = ((u_int32_t)win + (1 << sws) - 1)
					    >> sws;
					dws = dst->wscale & PF_WSCALE_MASK;
				} else {
					/* fixup other window */
					dst->max_win <<= dst->wscale &
					    PF_WSCALE_MASK;
					/* in case of a retrans SYN|ACK */
					dst->wscale = 0;
				}
			}
		}
d2642 2
a2643 2
		    SEQ_GEQ(end + MAX(1, dst->max_win << dws), src->seqhi))
			src->seqhi = end + MAX(1, dst->max_win << dws);
a2653 1
			copyback = 1;
d2669 3
a2671 4
		/*
		 * Many stacks (ours included) will set the ACK number in an
		 * FIN|ACK if the SYN times out -- no sequence to ACK.
		 */
d2686 1
a2686 1
	    SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws)) &&
d2689 2
a2690 2
	    /* Acking not more than one reassembled fragment backwards */
	    (ackskew <= (MAXACKWINDOW << dws))) {
d2703 2
a2704 2
		if (SEQ_GEQ(ack + (win << sws), dst->seqhi))
			dst->seqhi = ack + MAX((win << sws), 1);
a2723 1
		(*state)->expire = time.tv_sec;
d2726 2
a2727 1
			(*state)->timeout = PFTM_TCP_CLOSED;
d2730 6
a2735 1
			(*state)->timeout = PFTM_TCP_FIN_WAIT;
d2738 2
a2739 4
			(*state)->timeout = PFTM_TCP_OPENING;
		else if (src->state >= TCPS_CLOSING ||
		    dst->state >= TCPS_CLOSING)
			(*state)->timeout = PFTM_TCP_CLOSING;
d2741 2
a2742 1
			(*state)->timeout = PFTM_TCP_ESTABLISHED;
d2779 1
a2779 1
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d\n",
d2793 2
a2794 2
		if (SEQ_GEQ(ack + (win << sws), dst->seqhi))
			dst->seqhi = ack + MAX((win << sws), 1);
d2810 1
a2810 9
		if ((*state)->dst.state == TCPS_SYN_SENT &&
		    (*state)->src.state == TCPS_SYN_SENT) {
			/* Send RST for state mismatches during handshake */
			pf_send_ack(off, th, pd, pd->af, 0,
			    (*state)->rule.ptr, TH_RST, 0);
			src->seqlo = 0;
			src->seqhi = 1;
			src->max_win = 1;
		} else if (pf_status.debug >= PF_DEBUG_MISC) {
d2814 1
a2814 1
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d "
d2821 1
a2821 2
			    SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws)) ?
			    ' ': '2',
a2829 6
	if (dst->scrub || src->scrub) {
		if (pf_normalize_tcp_stateful(m, off, pd, reason, th, src, dst,
		    &copyback))
			return (PF_DROP);
	}

d2843 2
a2844 2
	} else if (copyback) {
		/* Copyback sequence modulation or stateful scrub changes */
d2848 3
a2850 9
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
d2859 3
a2861 3
	struct pf_state_peer	*src, *dst;
	struct pf_tree_node	 key;
	struct udphdr		*uh = pd->hdr.udp;
d2870 6
a2875 1
	STATE_LOOKUP();
a2894 1
	(*state)->expire = time.tv_sec;
d2896 2
a2897 1
		(*state)->timeout = PFTM_UDP_MULTIPLE;
d2899 2
a2900 1
		(*state)->timeout = PFTM_UDP_SINGLE;
d2915 3
a2917 9
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
d2926 4
a2929 4
	struct pf_addr	*saddr = pd->src, *daddr = pd->dst;
	u_int16_t	 icmpid, *icmpsum;
	u_int8_t	 icmptype;
	int		 state_icmp = 0;
d2967 1
a2967 1
		struct pf_tree_node	key;
d2976 6
a2981 1
		STATE_LOOKUP();
d2985 2
a2986 2
		(*state)->expire = time.tv_sec;
		(*state)->timeout = PFTM_ICMP_ERROR_REPLY;
d3004 1
a3004 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3023 1
a3023 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3039 1
a3039 1
		struct pf_pdesc	pd2;
d3041 1
a3041 1
		struct ip	h2;
d3044 2
a3045 2
		struct ip6_hdr	h2_6;
		int		terminal = 0;
d3047 2
a3048 2
		int		ipoff2;
		int		off2;
d3060 1
a3060 2
				    ("pf: ICMP error message too short "
				    "(ip)\n"));
d3063 1
a3063 4
			/*
			 * ICMP error messages don't refer to non-first
			 * fragments
			 */
d3083 1
a3083 2
				    ("pf: ICMP error message too short "
				    "(ip6)\n"));
d3131 4
a3134 5
			struct tcphdr		 th;
			u_int32_t		 seq;
			struct pf_tree_node	 key;
			struct pf_state_peer	*src, *dst;
			u_int8_t		 dws;
d3143 1
a3143 2
				    ("pf: ICMP error message too short "
				    "(tcp)\n"));
d3154 6
a3159 1
			STATE_LOOKUP();
a3168 5
			if (src->wscale && dst->wscale && !(th.th_flags & TH_SYN))
				dws = dst->wscale & PF_WSCALE_MASK;
			else
				dws = 0;

d3176 1
a3176 1
			    !SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws))) {
d3180 1
a3180 1
					printf(" seq=%u\n", seq);
d3210 1
a3210 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3226 2
a3227 2
			struct udphdr		uh;
			struct pf_tree_node	key;
d3232 1
a3232 2
				    ("pf: ICMP error message too short "
				    "(udp)\n"));
d3243 6
a3248 1
			STATE_LOOKUP();
d3275 1
a3275 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3291 2
a3292 2
			struct icmp		iih;
			struct pf_tree_node	key;
d3297 1
a3297 2
				    ("pf: ICMP error message too short i"
				    "(icmp)\n"));
d3308 6
a3313 1
			STATE_LOOKUP();
d3343 2
a3344 2
			struct icmp6_hdr	iih;
			struct pf_tree_node	key;
d3346 2
a3347 2
			if (!pf_pull_hdr(m, off2, &iih,
			    sizeof(struct icmp6_hdr), NULL, NULL, pd2.af)) {
d3349 1
a3349 2
				    ("pf: ICMP error message too short "
				    "(icmp6)\n"));
d3360 6
a3365 1
			STATE_LOOKUP();
d3381 1
a3381 1
				m_copyback(m, off, sizeof(struct icmp6_hdr),
d3385 1
a3385 1
				m_copyback(m, off2, sizeof(struct icmp6_hdr),
d3393 5
a3397 46
		default: {
			struct pf_tree_node	key;

			key.af = pd2.af;
			key.proto = pd2.proto;
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = 0;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = 0;

			STATE_LOOKUP();

			if (STATE_TRANSLATE(*state)) {
				if (direction == PF_IN) {
					pf_change_icmp(pd2.src, NULL,
					    daddr, &(*state)->lan.addr,
					    0, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				} else {
					pf_change_icmp(pd2.dst, NULL,
					    saddr, &(*state)->gwy.addr,
					    0, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				}
				switch (pd2.af) {
#ifdef INET
				case AF_INET:
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2),
					    (caddr_t)&h2);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
					    (caddr_t)pd->hdr.icmp6);
					m_copyback(m, ipoff2, sizeof(h2_6),
					    (caddr_t)&h2_6);
					break;
#endif /* INET6 */
				}
			}
a3398 4
			return (PF_PASS);
			break;
		}
		}
d3406 2
a3407 2
	struct pf_state_peer	*src, *dst;
	struct pf_tree_node	 key;
d3416 6
a3421 1
	STATE_LOOKUP();
a3440 1
	(*state)->expire = time.tv_sec;
d3442 2
a3443 1
		(*state)->timeout = PFTM_OTHER_MULTIPLE;
d3445 2
a3446 1
		(*state)->timeout = PFTM_OTHER_SINGLE;
d3455 1
a3455 2
				    pd->ip_sum, (*state)->gwy.addr.v4.s_addr,
				    0);
d3469 1
a3469 2
				    pd->ip_sum, (*state)->lan.addr.v4.s_addr,
				    0);
d3480 3
a3482 9
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
d3498 2
a3499 2
		struct ip	*h = mtod(m, struct ip *);
		u_int16_t	 fragoff = (h->ip_off & IP_OFFMASK) << 3;
d3520 1
a3520 2
		struct ip6_hdr	*h = mtod(m, struct ip6_hdr *);

d3537 7
a3543 5
pf_routable(struct pf_addr *addr, sa_family_t af)
{
	struct sockaddr_in	*dst;
	struct route		 ro;
	int			 ret = 0;
d3562 1
a3562 2
pf_route(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp,
    struct pf_state *s)
d3564 9
a3572 13
	struct mbuf		*m0, *m1;
	struct route		 iproute;
	struct route		*ro;
	struct sockaddr_in	*dst;
	struct ip		*ip;
	struct ifnet		*ifp = NULL;
	struct m_tag		*mtag;
	struct pf_addr		 naddr;
	int			 error = 0;

	if (m == NULL || *m == NULL || r == NULL ||
	    (dir != PF_IN && dir != PF_OUT) || oifp == NULL)
		panic("pf_route: invalid parameters");
a3574 8
		m0 = *m;
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
		}
a3583 2
	if (m0->m_len < sizeof(struct ip))
		panic("pf_route: m0->m_len < sizeof(struct ip)");
d3585 1
d3607 2
a3608 21
		if (TAILQ_EMPTY(&r->rpool.list))
			panic("pf_route: TAILQ_EMPTY(&r->rpool.list)");
		if (s == NULL) {
			pf_map_addr(AF_INET, &r->rpool,
			    (struct pf_addr *)&ip->ip_src,
			    &naddr, NULL);
			if (!PF_AZERO(&naddr, AF_INET))
				dst->sin_addr.s_addr = naddr.v4.s_addr;
			ifp = r->rpool.cur->ifp;
		} else {
			if (s->rt_ifp == NULL) {
				pf_map_addr(AF_INET, &r->rpool,
				    (struct pf_addr *)&ip->ip_src,
				    &s->rt_addr, NULL);
				s->rt_ifp = r->rpool.cur->ifp;
			}
			if (!PF_AZERO(&s->rt_addr, AF_INET))
				dst->sin_addr.s_addr =
				    s->rt_addr.v4.s_addr;
			ifp = s->rt_ifp;
		}
a3616 4
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
d3621 7
a3627 4
			if (m0->m_len < sizeof(struct ip))
				panic("pf_route: m0->m_len < "
				    "sizeof(struct ip)");
			ip = mtod(m0, struct ip *);
d3632 1
a3632 1
	if (ip->ip_len <= ifp->if_mtu) {
d3641 1
a3641 1
			ip->ip_sum = in_cksum(m0, ip->ip_hl << 2);
d3699 1
a3699 2
pf_route6(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp,
    struct pf_state *s)
d3701 11
a3711 13
	struct mbuf		*m0;
	struct m_tag		*mtag;
	struct route_in6	 ip6route;
	struct route_in6	*ro;
	struct sockaddr_in6	*dst;
	struct ip6_hdr		*ip6;
	struct ifnet		*ifp = NULL;
	struct pf_addr		 naddr;
	int			 error = 0;

	if (m == NULL || *m == NULL || r == NULL ||
	    (dir != PF_IN && dir != PF_OUT) || oifp == NULL)
		panic("pf_route6: invalid parameters");
a3713 8
		m0 = *m;
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
		}
a3722 2
	if (m0->m_len < sizeof(struct ip6_hdr))
		panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
d3732 3
a3744 22
	if (TAILQ_EMPTY(&r->rpool.list))
		panic("pf_route6: TAILQ_EMPTY(&r->rpool.list)");
	if (s == NULL) {
		pf_map_addr(AF_INET6, &r->rpool,
		    (struct pf_addr *)&ip6->ip6_src, &naddr, NULL);
		if (!PF_AZERO(&naddr, AF_INET6))
			PF_ACPY((struct pf_addr *)&dst->sin6_addr,
			    &naddr, AF_INET6);
		ifp = r->rpool.cur->ifp;
	} else {
		if (s->rt_ifp == NULL) {
			pf_map_addr(AF_INET6, &r->rpool,
			    (struct pf_addr *)&ip6->ip6_src,
			    &s->rt_addr, NULL);
			s->rt_ifp = r->rpool.cur->ifp;
		}
		if (!PF_AZERO(&s->rt_addr, AF_INET6))
			PF_ACPY((struct pf_addr *)&dst->sin6_addr,
			    &s->rt_addr, AF_INET6);
		ifp = s->rt_ifp;
	}

d3751 1
a3751 5
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
			if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
d3755 7
a3790 89

/*
 * check protocol (tcp/udp/icmp/icmp6) checksum and set mbuf flag
 *   off is the offset where the protocol header starts
 *   len is the total length of protocol header plus payload
 * returns 0 when the checksum is valid, otherwise returns 1.
 */
int
pf_check_proto_cksum(struct mbuf *m, int off, int len, u_int8_t p, sa_family_t af)
{
	u_int16_t flag_ok, flag_bad;
	u_int16_t sum;

	switch (p) {
	case IPPROTO_TCP:
		flag_ok = M_TCP_CSUM_IN_OK;
		flag_bad = M_TCP_CSUM_IN_BAD;
		break;
	case IPPROTO_UDP:
		flag_ok = M_UDP_CSUM_IN_OK;
		flag_bad = M_UDP_CSUM_IN_BAD;
		break;
	case IPPROTO_ICMP:
#ifdef INET6
	case IPPROTO_ICMPV6:
#endif /* INET6 */
		flag_ok = flag_bad = 0;
		break;
	default:
		return (1);
	}
	if (m->m_pkthdr.csum & flag_ok)
		return (0);
	if (m->m_pkthdr.csum & flag_bad)
		return (1);
	if (off < sizeof(struct ip) || len < sizeof(struct udphdr))
		return (1);
	if (m->m_pkthdr.len < off + len)
		return (1);
		switch (af) {
	case AF_INET:
		if (p == IPPROTO_ICMP) {
			if (m->m_len < off)
				return (1);
			m->m_data += off;
			m->m_len -= off;
			sum = in_cksum(m, len);
			m->m_data -= off;
			m->m_len += off;
		} else {
			if (m->m_len < sizeof(struct ip))
				return (1);
			sum = in4_cksum(m, p, off, len);
		}
		break;
#ifdef INET6
	case AF_INET6:
		if (m->m_len < sizeof(struct ip6_hdr))
			return (1);
		sum = in6_cksum(m, p, off, len);
		break;
#endif /* INET6 */
	default:
		return (1);
	}
	if (sum) {
		m->m_pkthdr.csum |= flag_bad;
		switch (p) {
		case IPPROTO_TCP:
			tcpstat.tcps_rcvbadsum++;
			break;
		case IPPROTO_UDP:
			udpstat.udps_badsum++;
			break;
		case IPPROTO_ICMP:
			icmpstat.icps_checksum++;
			break;
#ifdef INET6
		case IPPROTO_ICMPV6:
			icmp6stat.icp6s_checksum++;
			break;
#endif /* INET6 */
		}
		return (1);
	}
	m->m_pkthdr.csum |= flag_ok;
	return (0);
}

d3795 7
a3801 9
	u_short		   action, reason = 0, log = 0;
	struct mbuf	  *m = *m0;
	struct ip	  *h;
	struct pf_rule	  *a = NULL, *r = &pf_default_rule;
	struct pf_state	  *s = NULL;
	struct pf_ruleset *ruleset = NULL;
	struct pf_pdesc	   pd;
	int		   off;
	int		   pqid = 0;
d3821 1
a3821 1
		action = PF_DROP;
d3845 1
a3845 2
		action = pf_test_fragment(&r, dir, ifp, m, h,
		    &pd, &a, &ruleset);
d3852 2
a3853 1
		struct tcphdr	th;
a3854 1
		pd.hdr.tcp = &th;
a3859 5
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    h->ip_len - off, IPPROTO_TCP, AF_INET)) {
			action = PF_DROP;
			goto done;
		}
a3860 2
		if ((th.th_flags & TH_ACK) && pd.p_len == 0)
			pqid = 1;
d3864 1
a3864 2
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd,
		    &reason);
d3869 1
a3869 2
			action = pf_test_tcp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a, &ruleset);
d3874 2
a3875 1
		struct udphdr	uh;
a3876 1
		pd.hdr.udp = &uh;
a3881 5
		if (dir == PF_IN && uh.uh_sum && pf_check_proto_cksum(m,
		    off, h->ip_len - off, IPPROTO_UDP, AF_INET)) {
			action = PF_DROP;
			goto done;
		}
a3884 1
			a = s->anchor.ptr;
d3887 1
a3887 2
			action = pf_test_udp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a, &ruleset);
d3892 2
a3893 1
		struct icmp	ih;
a3894 1
		pd.hdr.icmp = &ih;
a3899 5
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    h->ip_len - off, IPPROTO_ICMP, AF_INET)) {
			action = PF_DROP;
			goto done;
		}
d3903 3
a3905 6
			r->packets++;
			r->bytes += h->ip_len;
			a = s->anchor.ptr;
			if (a != NULL) {
				a->packets++;
				a->bytes += h->ip_len;
d3909 1
a3909 2
			action = pf_test_icmp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a, &ruleset);
a3916 1
			a = s->anchor.ptr;
d3919 1
a3919 2
			action = pf_test_other(&r, &s, dir, ifp, m, h,
			    &pd, &a, &ruleset);
d3924 2
a3925 2
		pf_status.bcounters[0][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[0][dir == PF_OUT][action != PF_PASS]++;
d3929 2
a3930 13
	if (r->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->src.not);
	if (r->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->dst.not);

	if (action == PF_PASS && h->ip_hl > 5 &&
	    !((s && s->allow_opts) || r->allow_opts)) {
d3939 3
a3941 3
	if (action == PF_PASS && r->qid) {
		struct m_tag	*mtag;
		struct altq_tag	*atag;
d3946 1
a3946 4
			if (pqid || pd.tos == IPTOS_LOWDELAY)
				atag->qid = r->pqid;
			else
				atag->qid = r->qid;
d3955 10
a3964 2
	if (log)
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r, a, ruleset);
d3966 3
a3968 7
	if (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} else if (r->rt)
		/* pf_route can free the mbuf causing *m0 to become NULL */
		pf_route(m0, r, dir, ifp, s);
d3978 7
a3984 8
	u_short		   action, reason = 0, log = 0;
	struct mbuf	  *m = *m0;
	struct ip6_hdr	  *h;
	struct pf_rule	  *a = NULL, *r = &pf_default_rule;
	struct pf_state	  *s = NULL;
	struct pf_ruleset *ruleset = NULL;
	struct pf_pdesc    pd;
	int		   off, terminal = 0;
d4017 1
a4017 2
			action = pf_test_fragment(&r, dir, ifp, m, h,
			    &pd, &a, &ruleset);
d4026 1
a4026 1
			struct ip6_ext	opt6;
d4054 2
a4055 1
		struct tcphdr	th;
a4056 1
		pd.hdr.tcp = &th;
a4061 5
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    ntohs(h->ip6_plen), IPPROTO_TCP, AF_INET6)) {
			action = PF_DROP;
			goto done;
		}
d4066 1
a4066 2
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd,
		    &reason);
d4071 1
a4071 2
			action = pf_test_tcp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a, &ruleset);
d4076 2
a4077 1
		struct udphdr	uh;
a4078 1
		pd.hdr.udp = &uh;
a4083 5
		if (dir == PF_IN && uh.uh_sum && pf_check_proto_cksum(m,
		    off, ntohs(h->ip6_plen), IPPROTO_UDP, AF_INET6)) {
			action = PF_DROP;
			goto done;
		}
d4089 1
a4089 2
			action = pf_test_udp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a, &ruleset);
d4094 2
a4095 1
		struct icmp6_hdr	ih;
a4096 1
		pd.hdr.icmp6 = &ih;
d4102 1
a4102 7
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    ntohs(h->ip6_plen), IPPROTO_ICMPV6, AF_INET6)) {
			action = PF_DROP;
			goto done;
		}
		action = pf_test_state_icmp(&s, dir, ifp,
		    m, 0, off, h, &pd);
d4105 4
a4108 2
			r->packets++;
			r->bytes += h->ip6_plen;
d4111 1
a4111 2
			action = pf_test_icmp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a, &ruleset);
d4116 1
a4116 2
		action = pf_test_other(&r, &s, dir, ifp, m, h,
		    &pd, &a, &ruleset);
d4121 2
a4122 2
		pf_status.bcounters[1][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[1][dir == PF_OUT][action != PF_PASS]++;
a4125 11
	if (r->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->src.not);
	if (r->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->dst.not);

d4128 9
a4136 17
#ifdef ALTQ
	if (action == PF_PASS && r->qid) {
		struct m_tag	*mtag;
		struct altq_tag	*atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			if (pd.tos == IPTOS_LOWDELAY)
				atag->qid = r->pqid;
			else
				atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = AF_INET6;
			atag->hdr = h;
			m_tag_prepend(m, mtag);
		}
a4137 4
#endif

	if (log)
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r, a, ruleset);
d4139 3
a4141 7
	if (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} else if (r->rt)
		/* pf_route6 can free the mbuf causing *m0 to become NULL */
		pf_route6(m0, r, dir, ifp, s);
@


1.179
log
@- Log packet while mbuf is still valid.
- If logging and r == NULL, use r0 leaving r untouched.
- Note that pf_route/pf_route6 can free the mbuf.
Thanks and ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.178 2001/12/10 18:28:32 dhartmei Exp $ */
d1248 9
@


1.178
log
@Add an ioctl to add state entries (DIOCADDSTATE) for proxies.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.177 2001/12/10 18:08:11 dhartmei Exp $ */
d4968 12
a4987 12
	if (log) {
		struct pf_rule r0;

		if (r == NULL) {
			r0.ifp = ifp;
			r0.action = action;
			r0.nr = -1;
			r = &r0;
		}
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r);
	}
	/* XXX (pf_rule *)r may now be invalid from the above log */
d5150 12
a5169 12
	if (log) {
		struct pf_rule r0;

		if (r == NULL) {
			r0.ifp = ifp;
			r0.action = action;
			r0.nr = -1;
			r = &r0;
		}
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r);
	}
	/* XXX (pf_rule *)r may now be invalid from the above log */
@


1.177
log
@Add stateful filtering for other (non-TCP/UDP/ICMP) protocol, based on
source/destination addresses/ports only.
Add RDR for ICMP. Add NAT/RDR/BINAT for other protocols.
Destination and redirection port(s) are now optional for RDR rules.
Not specifying destination port(s) means 'redirect all ports', not
specifying redirection port(s) means 'redirect to the original port'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.176 2001/12/03 18:47:46 dhartmei Exp $ */
d1026 18
a1043 20
		case DIOCSTART:
		case DIOCSTOP:
		case DIOCBEGINRULES:
		case DIOCADDRULE:
		case DIOCCOMMITRULES:
		case DIOCBEGINNATS:
		case DIOCADDNAT:
		case DIOCCOMMITNATS:
		case DIOCBEGINBINATS:
		case DIOCADDBINAT:
		case DIOCCOMMITBINATS:
		case DIOCBEGINRDRS:
		case DIOCADDRDR:
		case DIOCCOMMITRDRS:
		case DIOCCLRSTATES:
		case DIOCCHANGERULE:
		case DIOCCHANGENAT:
		case DIOCCHANGEBINAT:
		case DIOCCHANGERDR:
		case DIOCSETTIMEOUT:
d1913 21
@


1.176
log
@Don't reset pf_status.debug and .since on DIOCCLRSTATUS.
From Dries Schellekens. Closes PR 2227.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.175 2001/12/01 19:11:41 deraadt Exp $ */
d156 4
d170 2
a171 1
				&pftm_frag, &pftm_interval };
d249 2
d2720 1
a2720 1
		    ((!r->dport2 && dport == r->dport) ||
d2789 2
d2792 1
a2792 1
				nport = rdr->rport;
d3014 2
d3017 1
a3017 1
				nport = rdr->rport;
a3108 1
		u_int16_t len;
a3110 1
		len = pd->tot_len - off - sizeof(*uh);
d3179 1
d3250 20
d3271 1
a3271 1
		if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_ICMP,
d3340 2
a3341 1
	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL || binat != NULL) {
a3342 1
		u_int16_t len;
a3344 1
		len = pd->tot_len - off - ICMP_MINLEN;
d3370 1
a3370 1
			if (binat != NULL)
d3408 1
d3410 2
a3411 1
	struct pf_addr *saddr = pd->src, *daddr = pd->dst;
d3420 1
d3435 18
d3454 18
d3473 1
a3473 1
		if ((binat = pf_get_binat(PF_IN, ifp, pd->proto,
d3475 1
d3533 54
d4406 83
d4925 6
a4930 1
		action = pf_test_other(&r, dir, ifp, m, h, &pd);
@


1.175
log
@217 lines of diff for KNF, dhartmei, you are evil
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.174 2001/11/30 17:01:54 jasoni Exp $ */
d2000 1
a2000 1
		u_int8_t running = pf_status.running;
d2002 2
d2008 2
@


1.174
log
@only make a copy of the mbuf if the route rule is dup-to
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.173 2001/11/27 20:29:25 jasoni Exp $ */
d181 1
a181 1
int			 pf_compare_binats(struct pf_binat *, 
d347 1
a347 1
	
d372 1
a372 1
	} 
d853 1
a853 1
	} 
d880 1
a880 1
					if (i == maxstart) 
d1491 1
a1491 1
				     newnat, entries);
d1687 1
a1687 1
				TAILQ_INSERT_BEFORE(oldbinat, newbinat, 
d1691 1
a1691 1
				     newbinat, entries);
d1889 1
a1889 1
				     newrdr, entries);
d2028 1
a2028 1
		if (!pnl->proto || 
d2136 1
a2136 1
			    s->src.port[0] == r->src.port[0] &&	
d2204 1
a2204 1
       		    ao.addr16[6], an->addr16[6], u),
d2206 1
a2206 1
		    po, pn, u); 
d2226 1
a2226 1
        struct pf_addr ao;
d2240 1
a2240 1
       	    ao.addr16[6], an->addr16[6], u),
d2290 1
a2290 1
       		    oia.addr16[6], ia->addr16[6], u),
d2317 1
a2317 1
       		    ooa.addr16[6], oa->addr16[6], u),
d2391 1
a2391 1
		memcpy(&h2_6->ip6_dst, pd->src, sizeof(struct in6_addr));  
d2494 8
a2501 8
		if (((a->addr32[0] & m->addr32[0]) == 
		     (b->addr32[0] & m->addr32[0])) && 
		    ((a->addr32[1] & m->addr32[1]) == 
		     (b->addr32[1] & m->addr32[1])) && 
		    ((a->addr32[2] & m->addr32[2]) == 
		     (b->addr32[2] & m->addr32[2])) && 
		    ((a->addr32[3] & m->addr32[3]) == 
		     (b->addr32[3] & m->addr32[3]))) 
d2505 1
a2505 1
	} 
d2671 1
a2671 1
	struct pf_addr fullmask; 
d2683 1
a2683 1
                else if (direction == PF_IN && b->ifp == ifp &&
d2859 1
a2859 1
			else 
d2996 1
a2996 1
		if ((rdr = pf_get_rdr(ifp, IPPROTO_UDP, saddr, daddr, 
d3036 1
a3036 1
			saddr, af))
d3039 2
a3040 2
                    r->src.port[0], r->src.port[1], uh->uh_sport))
                        r = r->skip[PF_SKIP_SRC_PORT];
a3078 1
		
d3327 1
a3327 1
			if (nat != NULL || binat != NULL) 
d3936 1
a3936 1
		case AF_INET: 
d3961 1
a3961 1
			ipoff2 = off + sizeof(struct icmp6_hdr); 
d3964 1
a3964 1
                            NULL, NULL, pd2.af)) {
d3974 1
a3974 1
			do {			
d3976 1
a3976 1
				case IPPROTO_FRAGMENT: 
d4005 1
a4005 1
			
d4135 1
a4135 1
					pf_change_icmp(pd2.dst, &uh.uh_dport, 
d4312 1
a4312 1
		struct ip6_hdr *h = mtod(m, struct ip6_hdr *);	
d4315 4
a4318 4
                        ACTION_SET(actionp, PF_DROP);
                        REASON_SET(reasonp, PFRES_SHORT);
                        return (NULL);
                }
a4397 1
		
d4423 1
a4423 1
	
d4427 1
a4427 1
	    
d4507 1
a4507 1
	    
d4511 1
a4511 1
	
d4739 1
a4739 1
                }
d4805 1
a4805 1
	do {			
d4807 1
a4807 1
		case IPPROTO_FRAGMENT: 
d4852 2
a4853 2
                if (action == PF_DROP)
                        break;
d4913 1
a4913 1
done:   
d4921 1
a4921 1
                }
@


1.173
log
@typo - use correct mbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.172 2001/11/27 17:50:36 frantzen Exp $ */
d4344 6
a4349 3
	m0 = m_copym2(m, 0, M_COPYALL, M_NOWAIT);
	if (m0 == NULL)
		return;
d4541 6
a4546 3
	m0 = m_copym2(m, 0, M_COPYALL, M_NOWAIT);
	if (m0 == NULL)
		return;
d4739 1
a4739 1
			m_freem(*m0);
d4921 1
a4921 1
			m_freem(*m0);
@


1.172
log
@do pf_route() before logging in case the logging created a bogus rule
(fixes a recent panic)  OK dhartmei@@ jasoni@@ mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.171 2001/11/26 16:50:26 jasoni Exp $ */
d4499 1
a4499 1
		    m->m_nextpkt = 0;
@


1.171
log
@add fastroute options similar to what is found in ipf
ok dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.170 2001/11/21 19:00:24 dhartmei Exp $ */
d4730 8
d4749 1
a4749 7
	if (r && r->rt) {
		pf_route(m, r);
		if (r->rt != PF_DUPTO) {
			m_freem(*m0);
			*m0 = NULL;
                }
	}
d4912 8
d4931 1
a4931 7
	if (r && r->rt) {
		pf_route6(m, r);
		if (r->rt != PF_DUPTO) {
			m_freem(*m0);
			*m0 = NULL;
                }
	}
@


1.170
log
@Use pf_pull_hdr() instead of manual mbuf traversal. Fixes potential crashes
in pf_test6() for IPv6 packets with options.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.169 2001/11/20 09:27:58 mpech Exp $ */
d60 4
d255 2
d1122 9
d4329 259
d4741 7
d4920 7
@


1.169
log
@don't allow CHANGEBINAT ioctl in securelevel > 1

dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.168 2001/11/16 11:07:20 mickey Exp $ */
a4518 5
		while (off >= m->m_len) {
			off -= m->m_len;
			m = m->m_next;
		}

d4530 1
a4530 1
			struct _opt6 *opt6;
d4532 11
a4542 3
			opt6 = (struct _opt6 *)(mtod(m, caddr_t) + off);
			pd.proto = opt6->opt6_nxt;
			off += (opt6->opt6_hlen + 1) * 8;
@


1.168
log
@yes, signed substraction does not work because of underflows, revert the previous
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.166 2001/11/13 17:45:26 frantzen Exp $ */
d1010 1
d1030 1
@


1.167
log
@use substract when comparing keys, for ip addrs as well.
those happen as signed integers and seem to work fine.
saves whole bunch of useless code.
dhartmei@@ ok
@
text
@d285 1
a285 2
	 * minimize the average number of substractions and jumps.
	 * what is faster?
d294 8
a301 3
		if ((diff = a->addr[0].addr32[0] - b->addr[0].addr32[0]) ||
		    (diff = a->addr[1].addr32[0] - b->addr[1].addr32[0]))
			return diff;
d306 32
a337 10
		if ((diff = a->addr[0].addr32[0] - b->addr[0].addr32[0]) ||
		    (diff = a->addr[0].addr32[1] - b->addr[0].addr32[1]) ||
		    (diff = a->addr[0].addr32[2] - b->addr[0].addr32[2]) ||
		    (diff = a->addr[0].addr32[3] - b->addr[0].addr32[3]) ||
		    (diff = a->addr[1].addr32[0] - b->addr[1].addr32[0]) ||
		    (diff = a->addr[1].addr32[1] - b->addr[1].addr32[1]) ||
		    (diff = a->addr[1].addr32[2] - b->addr[1].addr32[2]) ||
		    (diff = a->addr[1].addr32[3] - b->addr[1].addr32[3]))
			return diff;

@


1.166
log
@fix pf from going off into the weeds on an ipv6 icmp packet with certain option
headers.  should fix pr #2172    ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.165 2001/11/06 11:48:29 dhartmei Exp $ */
d285 2
a286 1
	 * minimize the number of average compares. what is faster?
d295 3
a297 8
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
			return 1;
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
			return -1;
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
			return 1;
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
			return -1;
d302 10
a311 32
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
			return 1;
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
			return -1;
		if (a->addr[0].addr32[1] > b->addr[0].addr32[1])
			return 1;
		if (a->addr[0].addr32[1] < b->addr[0].addr32[1])
			return -1;
		if (a->addr[0].addr32[2] > b->addr[0].addr32[2])
			return 1;
		if (a->addr[0].addr32[2] < b->addr[0].addr32[2])
			return -1;
		if (a->addr[0].addr32[3] > b->addr[0].addr32[3])
			return 1;
		if (a->addr[0].addr32[3] < b->addr[0].addr32[3])
			return -1;
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
			return 1;
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
			return -1;
		if (a->addr[1].addr32[1] > b->addr[1].addr32[1])
			return 1;
		if (a->addr[1].addr32[1] < b->addr[1].addr32[1])
			return -1;
		if (a->addr[1].addr32[2] > b->addr[1].addr32[2])
			return 1;
		if (a->addr[1].addr32[2] < b->addr[1].addr32[2])
			return -1;
		if (a->addr[1].addr32[3] > b->addr[1].addr32[3])
			return 1;
		if (a->addr[1].addr32[3] < b->addr[1].addr32[3])
			return -1;
@


1.165
log
@Use #defines for skip step values. From dgregor@@net.ohio-state.edu.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.164 2001/10/24 09:07:38 dhartmei Exp $ */
d3957 1
a3958 5
				while (off >= m->m_len) {
					off -= m->m_len;
					m = m->m_next;
				}

d3968 1
a3968 1
					struct _opt6 *opt6;
d3970 8
a3977 3
					opt6 = (struct _opt6 *)(mtod(m, caddr_t) + off2);
					pd2.proto = opt6->opt6_nxt;
					off2 += (opt6->opt6_hlen + 1) * 8;
@


1.164
log
@Reset states counter when clearing states.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.163 2001/10/15 16:22:21 dhartmei Exp $ */
d2105 1
a2105 1
		for (i = 0; i < 7; ++i) {
d2111 4
a2114 4
			PF_CALC_SKIP_STEP(0, s->ifp == r->ifp);
			PF_CALC_SKIP_STEP(1, s->af == r->af);
			PF_CALC_SKIP_STEP(2, s->proto == r->proto);
			PF_CALC_SKIP_STEP(3,
d2118 1
a2118 1
			PF_CALC_SKIP_STEP(4,
d2122 1
a2122 1
			PF_CALC_SKIP_STEP(5,
d2126 1
a2126 1
			PF_CALC_SKIP_STEP(6,
d2787 1
a2787 1
			r = r->skip[0];
d2789 1
a2789 1
			r = r->skip[1];
d2791 1
a2791 1
			r = r->skip[2];
d2794 1
a2794 1
			r = r->skip[3];
d2797 1
a2797 1
			r = r->skip[4];
d2800 1
a2800 1
			r = r->skip[5];
d2803 1
a2803 1
			r = r->skip[6];
d3012 1
a3012 1
			r = r->skip[0];
d3014 1
a3014 1
			r = r->skip[1];
d3016 1
a3016 1
			r = r->skip[2];
d3020 1
a3020 1
			r = r->skip[3];
d3023 1
a3023 1
                        r = r->skip[4];
d3027 1
a3027 1
			r = r->skip[5];
d3030 1
a3030 1
			r = r->skip[6];
d3250 1
a3250 1
			r = r->skip[0];
d3252 1
a3252 1
			r = r->skip[1];
d3254 1
a3254 1
			r = r->skip[2];
d3257 1
a3257 1
			r = r->skip[3];
d3260 1
a3260 1
			r = r->skip[5];
d3411 1
a3411 1
			r = r->skip[0];
d3413 1
a3413 1
			r = r->skip[1];
d3415 1
a3415 1
			r = r->skip[2];
d3418 1
a3418 1
			r = r->skip[3];
d3421 1
a3421 1
			r = r->skip[5];
@


1.163
log
@Add 'allow-opts' to rules. Packets with IP options will be blocked by
default now, and can be allowed per rule. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.162 2001/10/13 23:07:19 dhartmei Exp $ */
d1888 1
@


1.163.2.1
log
@Pull in patch from current (Errata 006):
fix pf from going off into the weeds on an ipv6 icmp packet with certain option
headers.  should fix pr #2172    ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.166 2001/11/13 17:45:26 frantzen Exp $ */
a3955 1
			off2 = ipoff2 + sizeof(h2_6);
d3957 5
d3971 1
a3971 1
					struct _opt6 opt6;
d3973 3
a3975 8
					if (!pf_pull_hdr(m, off2, &opt6,
					    sizeof(opt6), NULL, NULL, pd2.af)) {
						DPFPRINTF(PF_DEBUG_MISC,
						    ("pf:  ICMPv6 short opt\n"));
						return(PF_DROP);
					}
					pd2.proto = opt6.opt6_nxt;
					off2 += (opt6.opt6_hlen + 1) * 8;
@


1.163.2.2
log
@Pull in patch from current:
Fix (dhartmei):
Use pf_pull_hdr() instead of manual mbuf traversal. Fixes potential crashes
in pf_test6() for IPv6 packets with options.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.163.2.1 2001/11/13 18:45:11 jason Exp $ */
d4516 5
d4532 1
a4532 1
			struct _opt6 opt6;
d4534 3
a4536 11
			if (!pf_pull_hdr(m, off, &opt6, sizeof(opt6),
			    NULL, NULL, pd.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: IPv6 short opt\n"));
				action = PF_DROP;
				REASON_SET(&reason, PFRES_SHORT);
				log = 1;
				goto done;
			}
			pd.proto = opt6.opt6_nxt;
			off += (opt6.opt6_hlen + 1) * 8;
@


1.163.2.3
log
@Pull in patches from current:
Fix (dhartmei, mpech):
- Reset states counter when clearing states.
- don't allow CHANGEBINAT ioctl in securelevel > 1; dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.163.2.2 2001/12/05 19:47:39 jason Exp $ */
a1009 1
	/* XXX keep in sync with switch() below */
a1028 1
		case DIOCCHANGEBINAT:
a1887 1
		pf_status.states = 0;
@


1.163.2.4
log
@Pull in patch from current:
Fix (dhartmei):
Don't reset pf_status.debug and .since on DIOCCLRSTATUS.
From Dries Schellekens. Closes PR 2227.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.163.2.3 2001/12/13 19:52:37 jason Exp $ */
d1985 1
a1985 1
		u_int32_t running = pf_status.running;
a1986 2
		u_int32_t since = pf_status.since;
		u_int32_t debug = pf_status.debug;
a1990 2
		pf_status.since = since;
		pf_status.debug = debug;
@


1.163.2.5
log
@MFC (henning@@):
daddr was used where saddr was meant while checking incoming udp packets for
binat.
pointed out by Ryan McBride, mcbride at countersiege dot com, Thanks!

ok frantzen@@ pb@@ jasoni@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.163.2.4 2002/02/21 04:23:24 jason Exp $ */
d3000 1
a3000 1
		    daddr, saddr, af)) != NULL) {
@


1.162
log
@Patch from Ryan McBride, fixes IPv6 return-rst problem, found by
Todd Fries. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.161 2001/10/02 08:44:21 dhartmei Exp $ */
d223 8
a230 8
int			 pf_test_tcp(int, struct ifnet *, struct mbuf *, int,
			    int, void *, struct pf_pdesc *);
int			 pf_test_udp(int, struct ifnet *, struct mbuf *, int,
			    int, void *, struct pf_pdesc *);
int			 pf_test_icmp(int, struct ifnet *, struct mbuf *,
			    int, int, void *, struct pf_pdesc *);
int			 pf_test_other(int, struct ifnet *, struct mbuf *,
			    void *, struct pf_pdesc *);
d386 2
a387 1
	    a->min_ttl != b->min_ttl)
d2715 2
a2716 2
pf_test_tcp(int direction, struct ifnet *ifp, struct mbuf *m,
    int ipoff, int off, void *h, struct pf_pdesc *pd)
d2723 1
a2723 1
	struct pf_rule *r, *rm = NULL;
d2728 2
d2808 2
a2809 2
			rm = r;
			if (rm->quick)
d2815 3
a2817 3
	if (rm != NULL) {
		rm->packets++;
		rm->bytes += pd->tot_len;
d2821 2
a2822 2
		if (rm->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rm);
d2824 3
a2826 2
		if ((rm->action == PF_DROP) &&
		    ((rm->rule_flag & PFRULE_RETURNRST) || rm->return_icmp)) {
d2839 1
a2839 1
			if (rm->rule_flag & PFRULE_RETURNRST)
d2842 2
a2843 2
				pf_send_icmp(m, rm->return_icmp >> 8,
				    rm->return_icmp & 255, af);
d2846 1
a2846 1
		if (rm->action == PF_DROP) {
d2853 2
a2854 1
	if (((rm != NULL) && rm->keep_state) || nat != NULL || binat != NULL || rdr != NULL) {
d2867 3
a2869 2
		s->rule = rm;
		s->log = rm && (rm->log & 2);
d2902 2
a2903 2
		if (th->th_flags == TH_SYN && rm != NULL
		    && rm->keep_state == PF_STATE_MODULATE) {
d2938 2
a2939 2
pf_test_udp(int direction, struct ifnet *ifp, struct mbuf *m,
    int ipoff, int off, void *h, struct pf_pdesc *pd)
d2947 1
a2947 1
	struct pf_rule *r, *rm = NULL;
d2951 2
d3033 2
a3034 2
			rm = r;
			if (rm->quick)
d3040 3
a3042 3
	if (rm != NULL) {
		rm->packets++;
		rm->bytes += pd->tot_len;
d3046 2
a3047 2
		if (rm->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rm);
d3049 1
a3049 1
		if ((rm->action == PF_DROP) && rm->return_icmp) {
d3063 2
a3064 2
			pf_send_icmp(m, rm->return_icmp >> 8,
			    rm->return_icmp & 255, af);
d3067 1
a3067 1
		if (rm->action == PF_DROP) {
d3074 2
a3075 1
	if ((rm != NULL && rm->keep_state) || nat != NULL || binat != NULL || rdr != NULL) {
d3088 3
a3090 2
		s->rule = rm;
		s->log = rm && (rm->log & 2);
d3144 2
a3145 2
pf_test_icmp(int direction, struct ifnet *ifp, struct mbuf *m,
    int ipoff, int off, void *h, struct pf_pdesc *pd)
d3150 1
a3150 1
	struct pf_rule *r, *rm = NULL;
d3158 2
d3269 2
a3270 2
			rm = r;
			if (rm->quick)
d3276 3
a3278 3
	if (rm != NULL) {
		rm->packets++;
		rm->bytes +=  pd->tot_len;
d3282 2
a3283 2
		if (rm->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rm);
d3285 1
a3285 1
		if (rm->action != PF_PASS)
d3289 1
a3289 1
	if ((rm != NULL && rm->keep_state) || nat != NULL || binat != NULL) {
d3299 3
a3301 2
		s->rule	 = rm;
		s->log	 = rm && (rm->log & 2);
d3354 2
a3355 2
pf_test_other(int direction, struct ifnet *ifp, struct mbuf *m,
    void *h, struct pf_pdesc *pd)
d3357 1
a3357 1
	struct pf_rule *r, *rm = NULL;
d3362 2
d3424 2
a3425 2
			rm = r;
			if (rm->quick)
d3431 1
a3431 1
	if (rm != NULL) {
d3434 2
a3435 2
		rm->packets++;
		rm->bytes += pd->tot_len;
d3437 2
a3438 2
		if (rm->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rm);
d3440 1
a3440 1
		if (rm->action != PF_PASS)
d4388 1
a4388 1
			action = pf_test_tcp(dir, ifp, m, 0, off, h, &pd);
d4406 1
a4406 1
			action = pf_test_udp(dir, ifp, m, 0, off, h, &pd);
d4428 1
a4428 1
			action = pf_test_icmp(dir, ifp, m, 0, off, h, &pd);
d4433 1
a4433 1
		action = pf_test_other(dir, ifp, m, h, &pd);
d4443 9
d4565 1
a4565 1
			action = pf_test_tcp(dir, ifp, m, 0, off, h, &pd);
d4583 1
a4583 1
			action = pf_test_udp(dir, ifp, m, 0, off, h, &pd);
d4605 1
a4605 1
			action = pf_test_icmp(dir, ifp, m, 0, off, h, &pd);
d4610 1
a4610 1
		action = pf_test_other(dir, ifp, m, h, &pd);
d4620 2
@


1.161
log
@Convert ip_off of the inner IP header to host order in pf_test_state_icmp().
Some of the IP header fields are already converted by ip_input.c (including
ip_off), but of course not for inner headers of ICMP packets. The other
fields which are left in network order are ok.

This broke state search for any ICMP error message who referred to an IP
header with the DF flag set, hence any ICMP_UNREACH_NEEDFRAG message.

Found by Andreas Gunnarsson <andreas@@crt.se>. Thank you.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.160 2001/09/30 03:49:18 frantzen Exp $ */
d2418 1
@


1.160
log
@Tune TCP fsm (99.7% - 99.9% accuracy over 1e6 connections)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.159 2001/09/27 17:49:12 dhartmei Exp $ */
d3914 1
a3914 1
			if (h2.ip_off & IP_OFFMASK)
@


1.159
log
@The skip steps array was one element short (since adding steps for af).
This invoked undefined behaviour under the proper circumstances.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.158 2001/09/27 15:15:17 dhartmei Exp $ */
d138 1
a138 1
int			 pftm_tcp_first_packet = 60;	/* First TCP packet */
d141 3
a143 3
int			 pftm_tcp_closing = 60 * 60;	/* Half closed */
int			 pftm_tcp_fin_wait = 2 * 60;	/* Got both FINs */
int			 pftm_tcp_closed = 1 * 60;	/* Got a RST */
@


1.158
log
@switch without break. This caused the 'ICMP too short' messages, since
both IPv4 and IPv6 cases were executed. 'switch considered harmful'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.157 2001/09/27 14:02:44 dhartmei Exp $ */
d2103 1
a2103 1
		for (i = 0; i < 6; ++i) {
@


1.157
log
@Fix th_ack calculation in pf_send_reset(). return-rst didn't work since
1.150 (at least for IPv4).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.156 2001/09/23 04:07:07 frantzen Exp $ */
d4273 1
d4285 1
@


1.156
log
@Bump up the tcp half closed timeout (single FIN) to an hour
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.155 2001/09/21 07:18:49 dhartmei Exp $ */
d2386 1
a2386 1
		int tlen = pd->p_len - off - (th->th_off << 2);
@


1.155
log
@Fix natlook (broke ftp-proxy) and a memory leak.
From Ryan McBride.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.154 2001/09/19 11:09:59 dhartmei Exp $ */
d141 1
a141 1
int			 pftm_tcp_closing = 5 * 60;	/* Got a FIN */
@


1.154
log
@Patch from Ryan McBride. Compile without INET6, remove unnecessary
rewrite++.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.153 2001/09/17 17:16:27 dhartmei Exp $ */
d1086 1
d1093 1
d1209 1
d1216 1
d1311 1
d1318 1
d1420 1
d1427 1
d1509 1
d1516 1
d1619 1
d1626 1
d1709 1
d1716 1
d1818 1
d1825 1
d2010 2
a2011 2
		    !PF_AZERO(&pnl->saddr, pnl->af) ||
		    !PF_AZERO(&pnl->daddr, pnl->af) ||
@


1.153
log
@icmpv6 nat fix, from Ryan McBride
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.152 2001/09/15 22:25:25 dhartmei Exp $ */
d3127 1
d3129 1
d3313 1
d3318 1
a3802 1
		int rewrite = 0;
d3838 2
a3839 1
					rewrite++;
d3857 2
a3858 1
					rewrite++;
a3863 6

		/* copy back packet headers if we performed IPv6 NAT */
		if (rewrite)
			m_copyback(m, off, ICMP_MINLEN,
			    (caddr_t)pd->hdr.icmp6);

@


1.152
log
@The inner protocol of IPv4 ICMP error messages was ignored, leading to
'ICMP error message for bad proto' messages and breaking traceroute etc.

Please increase debugging level (pfctl -x m) while testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.151 2001/09/15 16:47:07 dhartmei Exp $ */
d3127 1
d3162 1
d3182 1
d3203 1
d3311 5
d3799 1
d3835 1
d3853 1
d3859 6
@


1.151
log
@Don't use m_pkthdr.rcvif in pflog_packet(), it doesn't work for outgoing
packets and is obviously invalid (and not NULL) for IPv6 packets (hence
crashed). Pass ifp down instead.

sizeof(ih) instead of sizeof(&ih) for pf_pull_hdr() from pf_test6().
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.150 2001/09/15 03:54:40 frantzen Exp $ */
d3887 1
@


1.150
log
@IPv6 support from Ryan McBride (mcbride@@countersiege.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.149 2001/09/14 20:22:18 jasoni Exp $ */
d254 1
a254 1
#define	PFLOG_PACKET(x,a,b,c,d,e) \
d259 1
a259 1
			pflog_packet(a,b,c,d,e); \
d263 1
a263 1
			pflog_packet(a,b,c,d,e); \
d267 1
a267 1
#define	PFLOG_PACKET(x,a,b,c,d,e)	((void)0)
d632 2
a633 2
pflog_packet(struct mbuf *m, int af, u_short dir, u_short reason,
    struct pf_rule *rm)
d636 1
a636 1
	struct ifnet *ifn, *ifp = NULL;
d640 2
a641 2
	if (m == NULL)
		return(-1);
d644 1
a644 9
	/* Set the right interface name */
	if (rm != NULL)
		ifp = rm->ifp;
	if (m->m_pkthdr.rcvif != NULL)
		ifp = m->m_pkthdr.rcvif;
	if (ifp != NULL)
		memcpy(hdr.ifname, ifp->if_xname, sizeof(hdr.ifname));
	else
		strcpy(hdr.ifname, "unkn");
d2802 1
a2802 1
			PFLOG_PACKET(h, m, af, direction, reason, rm);
d3022 1
a3022 1
			PFLOG_PACKET(h, m, af, direction, reason, rm);
d3248 1
a3248 1
			PFLOG_PACKET(h, m, af, direction, reason, rm);
d3393 1
a3393 1
			PFLOG_PACKET(h, m, af, direction, reason, rm);
d4400 1
a4400 1
		PFLOG_PACKET(h, m, AF_INET, dir, reason, r);
d4530 1
a4530 1
		if (!pf_pull_hdr(m, off, &ih, sizeof(&ih),
d4568 1
a4568 1
		PFLOG_PACKET(h, m, AF_INET6, dir, reason, r);
@


1.149
log
@binat non icmp/udp/tcp protocols as well; ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.148 2001/09/11 22:20:48 dhartmei Exp $ */
d67 7
d95 9
d170 4
d189 1
a189 1
void			 pf_print_host(u_int32_t, u_int16_t);
d200 3
a202 2
void			 pf_change_ap(u_int32_t *, u_int16_t *, u_int16_t *,
			    u_int16_t *, u_int32_t, u_int16_t, u_int8_t);
d205 11
a215 5
void			 pf_change_icmp(u_int32_t *, u_int16_t *, u_int32_t *,
			    u_int32_t, u_int16_t, u_int16_t *, u_int16_t *,
			    u_int16_t *, u_int16_t *, u_int8_t);
void			 pf_send_reset(struct ip *, int, struct tcphdr *);
void			 pf_send_icmp(struct mbuf *, u_int8_t, u_int8_t);
d217 10
a226 10
struct pf_nat		*pf_get_nat(struct ifnet *, u_int8_t, u_int32_t,
			    u_int32_t);
struct pf_binat		*pf_get_binat(int direction, struct ifnet *, u_int8_t, 
			    u_int32_t, u_int32_t);
struct pf_rdr		*pf_get_rdr(struct ifnet *, u_int8_t, u_int32_t,
			    u_int32_t, u_int16_t);
int			 pf_test_tcp(int, struct ifnet *, struct mbuf *,
			    int, int, struct ip *, struct tcphdr *);
int			 pf_test_udp(int, struct ifnet *, struct mbuf *,
			    int, int, struct ip *, struct udphdr *);
d228 1
a228 1
			    int, int, struct ip *, struct icmp *);
d230 1
a230 1
			    struct ip *);
d233 1
a233 1
			    struct ip *, struct tcphdr *);
d236 1
a236 1
			    struct ip *, struct udphdr *);
d239 1
a239 1
			    struct ip *, struct icmp *);
d241 1
a241 1
			    u_short *, u_short *);
d250 2
a251 1
			     int, int, struct ip *, struct tcphdr *);
d256 9
a264 5
		HTONS((x)->ip_len); \
		HTONS((x)->ip_off); \
		pflog_packet(a,b,c,d,e); \
		NTOHS((x)->ip_len); \
		NTOHS((x)->ip_off); \
d271 6
a276 1
	((s)->lan.addr != (s)->gwy.addr || (s)->lan.port != (s)->gwy.port)
d289 53
a341 8
	if (a->addr[0].s_addr > b->addr[0].s_addr)
		return 1;
	if (a->addr[0].s_addr < b->addr[0].s_addr)
		return -1;
	if (a->addr[1].s_addr > b->addr[1].s_addr)
		return 1;
	if (a->addr[1].s_addr < b->addr[1].s_addr)
		return -1;
d350 20
d379 1
d400 2
a401 6
	if (a->saddr != b->saddr ||
	    a->smask != b->smask ||
	    a->daddr != b->daddr ||
	    a->dmask != b->dmask ||
	    a->raddr != b->raddr ||
	    a->proto != b->proto ||
d406 10
d424 11
a434 6
	if (a->saddr != b->saddr ||
	    a->daddr != b->daddr ||
	    a->dmask != b->dmask ||
	    a->raddr != b->raddr ||
	    a->proto != b->proto ||
	    a->dnot != b->dnot)
d444 1
a444 6
	if (a->saddr != b->saddr ||
	    a->smask != b->smask ||
	    a->daddr != b->daddr ||
	    a->dmask != b->dmask ||
	    a->raddr != b->raddr ||
	    a->dport != b->dport ||
d448 1
d454 10
d735 1
d737 1
a737 1
	key.addr[0].s_addr = state->lan.addr;
d739 1
a739 1
	key.addr[1].s_addr = state->ext.addr;
d747 1
a747 1
			pf_print_host(key.addr[0].s_addr, key.port[0]);
d749 1
a749 1
			pf_print_host(key.addr[1].s_addr, key.port[1]);
d761 1
d763 1
a763 1
	key.addr[0].s_addr = state->ext.addr;
d765 1
a765 1
	key.addr[1].s_addr = state->gwy.addr;
d772 1
a772 1
			pf_print_host(key.addr[0].s_addr, key.port[0]);
d774 1
a774 1
			pf_print_host(key.addr[1].s_addr, key.port[1]);
d798 1
d800 2
a801 1
			key.addr[0].s_addr = cur->state->lan.addr;
d803 2
a804 1
			key.addr[1].s_addr = cur->state->ext.addr;
d844 1
a844 1
pf_print_host(u_int32_t a, u_int16_t p)
d846 54
a899 4
	a = ntohl(a);
	p = ntohs(p);
	printf("%u.%u.%u.%u:%u", (a>>24)&255, (a>>16)&255, (a>>8)&255, a&255,
	    p);
d919 1
a919 1
	pf_print_host(s->lan.addr, s->lan.port);
d921 1
a921 1
	pf_print_host(s->gwy.addr, s->gwy.port);
d923 1
a923 1
	pf_print_host(s->ext.addr, s->ext.port);
d1092 12
d1213 12
d1313 12
d1420 12
d1507 12
d1613 14
a1626 2
			bcopy(&pcn->newbinat, newbinat, 
			    sizeof(struct pf_binat));
d1703 12
d1810 12
d1988 1
d1996 1
a1996 1
		key.addr[1].s_addr = pnl->saddr;
d1998 1
a1998 1
		key.addr[0].s_addr = pnl->daddr;
d2001 3
a2003 1
		if (!pnl->proto || !pnl->saddr || !pnl->daddr ||
d2014 2
a2015 1
					pnl->rsaddr = st->lan.addr;
d2017 2
a2018 1
					pnl->rdaddr = pnl->daddr;
d2021 2
a2022 1
					pnl->rdaddr = st->gwy.addr;
d2024 2
a2025 1
					pnl->rsaddr = pnl->saddr;
d2102 5
a2106 4
			PF_CALC_SKIP_STEP(1, s->proto == r->proto);
			PF_CALC_SKIP_STEP(2,
			    s->src.addr == r->src.addr &&
			    s->src.mask == r->src.mask &&
d2108 2
a2109 2
			PF_CALC_SKIP_STEP(3,
			    s->src.port[0] == r->src.port[0] &&
d2112 3
a2114 3
			PF_CALC_SKIP_STEP(4,
			    s->dst.addr == r->dst.addr &&
			    s->dst.mask == r->dst.mask &&
d2116 1
a2116 1
			PF_CALC_SKIP_STEP(5,
d2142 2
a2143 2
pf_change_ap(u_int32_t *a, u_int16_t *p, u_int16_t *ic, u_int16_t *pc,
    u_int32_t an, u_int16_t pn, u_int8_t u)
d2145 1
a2145 1
	u_int32_t ao = *a;
d2148 3
a2150 3
	*a = an;
	*ic = pf_cksum_fixup(pf_cksum_fixup(*ic, ao / 65536,
	    an / 65536, 0), ao % 65536, an % 65536, 0);
d2152 31
a2182 2
	*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc, ao / 65536,
	    an / 65536, u), ao % 65536, an % 65536, u), po, pn, u);
d2192 23
a2214 1
	    ao % 65536, an % 65536, u);
d2216 1
d2219 3
a2221 3
pf_change_icmp(u_int32_t *ia, u_int16_t *ip, u_int32_t *oa, u_int32_t na,
    u_int16_t np, u_int16_t *pc, u_int16_t *h2c, u_int16_t *ic, u_int16_t *hc,
    u_int8_t u)
d2223 2
a2224 1
	u_int32_t oia = *ia, ooa = *oa, opc, oh2c = *h2c;
d2227 3
d2239 29
a2267 6
	/* Change inner ip address, fix inner ip checksum and icmp checksum. */
	*ia = na;
	*h2c = pf_cksum_fixup(pf_cksum_fixup(*h2c, oia / 65536, *ia / 65536, 0),
	    oia % 65536, *ia % 65536, 0);
	*ic = pf_cksum_fixup(pf_cksum_fixup(*ic, oia / 65536, *ia / 65536, 0),
	    oia % 65536, *ia % 65536, 0);
d2269 26
a2294 4
	/* Change outer ip address, fix outer ip checksum. */
	*oa = na;
	*hc = pf_cksum_fixup(pf_cksum_fixup(*hc, ooa / 65536, *oa / 65536, 0),
	    ooa % 65536, *oa % 65536, 0);
d2298 1
a2298 1
pf_send_reset(struct ip *h, int off, struct tcphdr *th)
d2302 2
a2303 1
	int len = sizeof(struct ip) + sizeof(struct tcphdr);
d2305 4
d2311 13
d2342 23
a2364 1
	h2 = mtod(m, struct ip *);
d2366 4
a2369 5
	/* IP header fields included in the TCP checksum */
	h2->ip_p = IPPROTO_TCP;
	h2->ip_len = htons(sizeof(*th2));
	h2->ip_src.s_addr = h->ip_dst.s_addr;
	h2->ip_dst.s_addr = h->ip_src.s_addr;
a2371 1
	th2 = (struct tcphdr *)((caddr_t)h2 + sizeof(struct ip));
d2378 1
a2378 1
		int tlen = h->ip_len - off - (th->th_off << 2);
d2388 21
a2408 2
	/* TCP checksum */
	th2->th_sum = in_cksum(m, len);
d2410 5
a2414 8
	/* Finish the IP header */
	h2->ip_v = 4;
	h2->ip_hl = sizeof(*h2) >> 2;
	h2->ip_ttl = 128;
	h2->ip_sum = 0;
	h2->ip_len = len;
	h2->ip_off = 0;
	ip_output(m, NULL, NULL, 0, NULL, NULL);
d2418 1
a2418 1
pf_send_icmp(struct mbuf *m, u_int8_t type, u_int8_t code)
d2432 12
a2443 1
	icmp_error(m0, type, code, 0, 0);
d2452 2
a2453 1
pf_match_addr(u_int8_t n, u_int32_t a, u_int32_t m, u_int32_t b)
d2455 24
a2478 1
	if ((a & m) == (b & m)) {
d2618 2
a2619 1
pf_get_nat(struct ifnet *ifp, u_int8_t proto, u_int32_t saddr, u_int32_t daddr)
d2628 3
a2630 2
		    pf_match_addr(n->snot, n->saddr, n->smask, saddr) &&
		    pf_match_addr(n->dnot, n->daddr, n->dmask, daddr))
d2640 1
a2640 1
    u_int32_t saddr, u_int32_t daddr)
d2643 3
d2651 3
a2653 2
		    pf_match_addr(0, b->saddr, 0xffffffff, saddr) &&
		    pf_match_addr(b->dnot, b->daddr, b->dmask, daddr))
d2657 3
a2659 2
		    pf_match_addr(0, b->raddr, 0xffffffff, saddr) &&
		    pf_match_addr(b->dnot, b->daddr, b->dmask, daddr))
d2668 2
a2669 2
pf_get_rdr(struct ifnet *ifp, u_int8_t proto, u_int32_t saddr, u_int32_t daddr,
    u_int16_t dport)
d2678 3
a2680 2
		    pf_match_addr(r->snot, r->saddr, r->smask, saddr) &&
		    pf_match_addr(r->dnot, r->daddr, r->dmask, daddr) &&
d2703 1
d2706 1
a2706 1
    int ipoff, int off, struct ip *h, struct tcphdr *th)
d2711 2
a2712 2
	u_int32_t baddr;
	u_int16_t bport, nport = 0;
d2714 1
d2721 2
a2722 2
		    h->ip_src.s_addr, h->ip_dst.s_addr)) != NULL) {
			baddr = h->ip_src.s_addr;
d2724 2
a2725 3
			pf_change_ap(&h->ip_src.s_addr, &th->th_sport,
			    &h->ip_sum, &th->th_sum, binat->raddr, 
			    th->th_sport, 0);
d2730 1
a2730 2
		    h->ip_src.s_addr, h->ip_dst.s_addr)) != NULL) {
			baddr = h->ip_src.s_addr;
d2736 3
a2738 3
			pf_change_ap(&h->ip_src.s_addr, &th->th_sport,
			    &h->ip_sum, &th->th_sum, nat->raddr,
			    htons(nport), 0);
d2743 2
a2744 3
		if ((rdr = pf_get_rdr(ifp, IPPROTO_TCP, h->ip_src.s_addr,
		    h->ip_dst.s_addr, th->th_dport)) != NULL) {
			baddr = h->ip_dst.s_addr;
d2750 3
a2752 3

			pf_change_ap(&h->ip_dst.s_addr, &th->th_dport,
			    &h->ip_sum, &th->th_sum, rdr->raddr, nport, 0);
d2757 2
a2758 2
		    h->ip_dst.s_addr, h->ip_dst.s_addr)) != NULL) {
			baddr = h->ip_dst.s_addr;
d2760 2
a2761 3
			pf_change_ap(&h->ip_dst.s_addr, &th->th_dport,
			    &h->ip_sum, &th->th_sum, binat->saddr,
			    th->th_dport, 0);
d2775 1
a2775 1
		else if (r->proto && r->proto != h->ip_p)
d2777 1
a2777 2
		else if (r->src.mask && !pf_match_addr(r->src.not,
		    r->src.addr, r->src.mask, h->ip_src.s_addr))
d2779 3
a2783 3
			r = r->skip[3];
		else if (r->dst.mask && !pf_match_addr(r->dst.not,
		    r->dst.addr, r->dst.mask, h->ip_dst.s_addr))
d2785 3
d2790 1
a2790 1
			r = r->skip[5];
d2805 1
a2805 1
		rm->bytes += h->ip_len;
d2810 1
a2810 1
			PFLOG_PACKET(h, m, AF_INET, direction, reason, rm);
d2816 3
a2818 3
				(binat != NULL && direction == PF_OUT)) {
				pf_change_ap(&h->ip_src.s_addr, &th->th_sport,
				    &h->ip_sum, &th->th_sum, baddr, bport, 0);
d2821 3
a2823 3
				(binat != NULL && direction == PF_IN)) {
				pf_change_ap(&h->ip_dst.s_addr, &th->th_dport,
				    &h->ip_sum, &th->th_sum, baddr, bport, 0);
d2827 2
a2828 2
				pf_send_reset(h, off, th);
			else
d2830 1
a2830 1
				    rm->return_icmp & 255);
d2845 1
a2845 1
		len = h->ip_len - off - (th->th_off << 2);
d2857 1
d2859 1
a2859 1
			s->gwy.addr = h->ip_src.s_addr;
d2861 1
a2861 1
			s->ext.addr = h->ip_dst.s_addr;
d2864 1
d2868 1
a2868 1
				s->lan.addr = s->gwy.addr;
d2872 1
a2872 1
			s->lan.addr = h->ip_dst.s_addr;
d2874 1
a2874 1
			s->ext.addr = h->ip_src.s_addr;
d2876 2
a2877 2
			if (binat != NULL || rdr != NULL) {
				s->gwy.addr = baddr;
d2880 1
a2880 1
				s->gwy.addr = s->lan.addr;
d2911 1
a2911 1
		s->bytes = h->ip_len;
d2924 1
a2924 1
    int ipoff, int off, struct ip *h, struct udphdr *uh)
d2929 3
a2931 2
	u_int32_t baddr;
	u_int16_t bport, nport = 0;
d2939 2
a2940 2
		    h->ip_src.s_addr, h->ip_dst.s_addr)) != NULL) {
			baddr = h->ip_src.s_addr;
d2942 2
a2943 3
			pf_change_ap(&h->ip_src.s_addr, &uh->uh_sport,
			    &h->ip_sum, &uh->uh_sum, binat->raddr, 
			    uh->uh_sport, 1);
d2948 1
a2948 2
		    h->ip_src.s_addr, h->ip_dst.s_addr)) != NULL) {
			baddr = h->ip_src.s_addr;
d2954 3
a2956 3
			pf_change_ap(&h->ip_src.s_addr, &uh->uh_sport,
			    &h->ip_sum, &uh->uh_sum, nat->raddr,
			    htons(nport), 1);
d2961 2
a2962 3
		if ((rdr = pf_get_rdr(ifp, IPPROTO_UDP, h->ip_src.s_addr,
		    h->ip_dst.s_addr, uh->uh_dport)) != NULL) {
			baddr = h->ip_dst.s_addr;
d2969 3
a2971 4
			pf_change_ap(&h->ip_dst.s_addr, &uh->uh_dport,
			    &h->ip_sum, &uh->uh_sum, rdr->raddr,
			    nport, 1);

d2976 2
a2977 2
		    h->ip_dst.s_addr, h->ip_dst.s_addr)) != NULL) {
			baddr = h->ip_dst.s_addr;
d2979 2
a2980 3
			pf_change_ap(&h->ip_dst.s_addr, &uh->uh_dport,
			    &h->ip_sum, &uh->uh_sum, binat->saddr,
			    uh->uh_dport, 1);
d2992 1
d2995 1
a2995 1
		else if (r->proto && r->proto != h->ip_p)
d2997 1
a2997 2
		else if (r->src.mask && !pf_match_addr(r->src.not,
		    r->src.addr, r->src.mask, h->ip_src.s_addr))
d2999 4
d3004 6
a3009 5
		    r->src.port[0], r->src.port[1], uh->uh_sport))
			r = r->skip[3];
		else if (r->dst.mask && !pf_match_addr(r->dst.not,
		    r->dst.addr, r->dst.mask, h->ip_dst.s_addr))
			r = r->skip[4];
d3012 1
a3012 1
			r = r->skip[5];
d3025 1
a3025 1
		rm->bytes += h->ip_len;
d3030 1
a3030 1
			PFLOG_PACKET(h, m, AF_INET, direction, reason, rm);
d3036 2
a3037 2
				pf_change_ap(&h->ip_src.s_addr, &uh->uh_sport,
				    &h->ip_sum, &uh->uh_sum, baddr, bport, 1);
d3041 2
a3042 2
				pf_change_ap(&h->ip_dst.s_addr, &uh->uh_dport,
				    &h->ip_sum, &uh->uh_sum, baddr, bport, 1);
d3044 1
d3047 1
a3047 1
			    rm->return_icmp & 255);
d3062 1
a3062 1
		len = h->ip_len - off - sizeof(*uh);
d3074 1
d3076 1
a3076 1
			s->gwy.addr = h->ip_src.s_addr;
d3078 1
a3078 1
			s->ext.addr = h->ip_dst.s_addr;
d3081 1
a3081 1
				s->lan.addr = baddr;
d3084 1
a3084 1
				s->lan.addr = s->gwy.addr;
d3088 1
a3088 1
			s->lan.addr = h->ip_dst.s_addr;
d3090 1
a3090 1
			s->ext.addr = h->ip_src.s_addr;
d3093 1
a3093 1
				s->gwy.addr = baddr;
d3096 1
a3096 1
				s->gwy.addr = s->lan.addr;
d3113 1
a3113 1
		s->bytes = h->ip_len;
d3126 1
a3126 1
    int ipoff, int off, struct ip *h, struct icmp *ih)
d3130 1
a3130 1
	u_int32_t baddr;
d3133 19
d3156 16
a3171 4
		    h->ip_src.s_addr, h->ip_dst.s_addr)) != NULL) {
			baddr = h->ip_src.s_addr;
			pf_change_a(&h->ip_src.s_addr, &h->ip_sum, 
			    binat->raddr, 0);
d3174 17
a3190 4
		else if ((nat = pf_get_nat(ifp, IPPROTO_ICMP,
		    h->ip_src.s_addr, h->ip_dst.s_addr)) != NULL) {
			baddr = h->ip_src.s_addr;
			pf_change_a(&h->ip_src.s_addr, &h->ip_sum, nat->raddr, 0);
d3195 16
a3210 4
		    h->ip_dst.s_addr, h->ip_src.s_addr)) != NULL) {
			baddr = h->ip_dst.s_addr;
			pf_change_a(&h->ip_dst.s_addr, &h->ip_sum,
			    binat->saddr, 0);
d3223 1
a3223 1
		else if (r->proto && r->proto != h->ip_p)
d3225 1
a3225 2
		else if (r->src.mask && !pf_match_addr(r->src.not,
		    r->src.addr, r->src.mask, h->ip_src.s_addr))
d3227 6
a3232 3
		else if (r->dst.mask && !pf_match_addr(r->dst.not,
		    r->dst.addr, r->dst.mask, h->ip_dst.s_addr))
			r = r->skip[4];
d3235 3
a3237 1
		else if (r->type && r->type != ih->icmp_type + 1)
d3239 1
a3239 1
		else if (r->code && r->code != ih->icmp_code + 1)
d3251 1
a3251 1
		rm->bytes +=  h->ip_len;
d3256 1
a3256 1
			PFLOG_PACKET(h, m, AF_INET, direction, reason, rm);
a3264 1
		u_int16_t id;
d3267 1
a3267 2
		len = h->ip_len - off - ICMP_MINLEN;
		id = ih->icmp_id;
d3274 1
a3274 1
		s->proto = IPPROTO_ICMP;
d3276 1
d3278 6
a3283 6
			s->gwy.addr = h->ip_src.s_addr;
			s->gwy.port = id;
			s->ext.addr = h->ip_dst.s_addr;
			s->ext.port = id;
			if (nat != NULL || binat != NULL)
				s->lan.addr = baddr;
d3285 2
a3286 2
				s->lan.addr = s->gwy.addr;
			s->lan.port = id;
d3288 4
a3291 4
			s->lan.addr = h->ip_dst.s_addr;
			s->lan.port = id;
			s->ext.addr = h->ip_src.s_addr;
			s->ext.port = id;
d3293 1
a3293 1
				s->gwy.addr = baddr;
d3295 2
a3296 2
				s->gwy.addr = s->lan.addr;
			s->gwy.port = id;
d3311 1
a3311 1
		s->bytes = h->ip_len;
d3319 2
a3320 1
pf_test_other(int direction, struct ifnet *ifp, struct mbuf *m, struct ip *h)
d3324 2
d3329 15
a3343 4
		if ((binat = pf_get_binat(PF_OUT, ifp, NULL, h->ip_src.s_addr,
		     h->ip_dst.s_addr)) != NULL) {
			pf_change_a(&h->ip_src.s_addr, &h->ip_sum,
			    binat->raddr, 0);
d3347 15
a3361 4
		if ((binat = pf_get_binat(PF_IN, ifp, NULL, h->ip_dst.s_addr, 
		     h->ip_src.s_addr)) != NULL) {
			pf_change_a(&h->ip_dst.s_addr, &h->ip_sum,
			    binat->saddr, 0);
d3374 1
a3374 1
		else if (r->proto && r->proto != h->ip_p)
d3376 1
a3376 2
		else if (r->src.mask && !pf_match_addr(r->src.not,
		    r->src.addr, r->src.mask, h->ip_src.s_addr))
d3378 6
a3383 3
		else if (r->dst.mask && !pf_match_addr(r->dst.not,
		    r->dst.addr, r->dst.mask, h->ip_dst.s_addr))
			r = r->skip[4];
d3398 1
a3398 1
		rm->bytes += h->ip_len;
d3401 1
a3401 1
			PFLOG_PACKET(h, m, AF_INET, direction, reason, rm);
d3411 1
a3411 1
    struct mbuf *m, int ipoff, int off, struct ip *h, struct tcphdr *th)
d3414 1
a3414 1
	u_int16_t len = h->ip_len - off - (th->th_off << 2);
d3420 1
d3422 2
a3423 1
	key.addr[0] = h->ip_src;
a3424 1
	key.addr[1] = h->ip_dst;
d3464 1
a3464 1
		end = seq + len;
d3492 1
a3492 1
		end = seq + len;
d3531 1
a3531 1
		(*state)->bytes += h->ip_len;
d3612 1
a3612 1
			    seq, ack, len, ackskew, (*state)->packets);
d3616 1
a3616 1
		(*state)->bytes += h->ip_len;
d3647 1
a3647 1
			    "dir=%s,%s\n", seq, ack, len, ackskew,
d3667 3
a3669 4
			pf_change_ap(&h->ip_src.s_addr,
			    &th->th_sport, &h->ip_sum,
			    &th->th_sum, (*state)->gwy.addr,
			    (*state)->gwy.port, 0);
d3671 3
a3673 4
			pf_change_ap(&h->ip_dst.s_addr,
			    &th->th_dport, &h->ip_sum,
			    &th->th_sum, (*state)->lan.addr,
			    (*state)->lan.port, 0);
d3682 1
a3682 1
		(*state)->rule->bytes += h->ip_len;
d3689 1
a3689 1
    struct mbuf *m, int ipoff, int off, struct ip *h, struct udphdr *uh)
d3693 1
d3695 1
d3697 4
a3700 4
	key.addr[0] = h->ip_src;
	key.port[0] = uh->uh_sport;
	key.addr[1] = h->ip_dst;
	key.port[1] = uh->uh_dport;
d3718 1
a3718 1
	(*state)->bytes += h->ip_len;
d3735 3
a3737 3
			pf_change_ap(&h->ip_src.s_addr, &uh->uh_sport,
			    &h->ip_sum, &uh->uh_sum,
			    (*state)->gwy.addr, (*state)->gwy.port, 1);
d3739 3
a3741 3
			pf_change_ap(&h->ip_dst.s_addr, &uh->uh_dport,
			    &h->ip_sum, &uh->uh_sum,
			    (*state)->lan.addr, (*state)->lan.port, 1);
d3747 1
a3747 1
		(*state)->rule->bytes += h->ip_len;
d3754 1
a3754 1
    struct mbuf *m, int ipoff, int off, struct ip *h, struct icmp *ih)
d3756 36
a3791 5
	if (ih->icmp_type != ICMP_UNREACH &&
	    ih->icmp_type != ICMP_SOURCEQUENCH &&
	    ih->icmp_type != ICMP_REDIRECT &&
	    ih->icmp_type != ICMP_TIMXCEED &&
	    ih->icmp_type != ICMP_PARAMPROB) {
d3799 6
a3804 5
		key.proto   = IPPROTO_ICMP;
		key.addr[0] = h->ip_src;
		key.port[0] = ih->icmp_id;
		key.addr[1] = h->ip_dst;
		key.port[1] = ih->icmp_id;
d3814 1
a3814 1
		(*state)->bytes += h->ip_len;
d3818 36
a3853 7
		if ((*state)->lan.addr != (*state)->gwy.addr) {
			if (direction == PF_OUT)
				pf_change_a(&h->ip_src.s_addr,
				    &h->ip_sum, (*state)->gwy.addr, 0);
			else
				pf_change_a(&h->ip_dst.s_addr,
				    &h->ip_sum, (*state)->lan.addr, 0);
a3858 1

d3864 2
d3867 5
d3875 19
a3893 6
		ipoff2 = off + ICMP_MINLEN;	/* offset of h2 in mbuf chain */
		if (!pf_pull_hdr(m, ipoff2, &h2, sizeof(h2), NULL, NULL)) {
			DPFPRINTF(PF_DEBUG_MISC,
			    ("pf: ICMP error message too short (ip)\n"));
			return (PF_DROP);
		}
d3895 8
a3902 3
		/* ICMP error messages don't refer to non-first fragments */
		if (h2.ip_off & IP_OFFMASK)
			return (PF_DROP);
d3904 15
a3918 2
		/* offset of protocol header that follows h2 */
		off2 = ipoff2 + (h2.ip_hl << 2);
d3920 27
a3946 1
		switch (h2.ip_p) {
d3958 1
a3958 1
			if (!pf_pull_hdr(m, off2, &th, 8, NULL, NULL)) {
d3964 1
d3966 1
a3966 1
			key.addr[0] = h2.ip_dst;
d3968 1
a3968 1
			key.addr[1] = h2.ip_src;
d4004 2
a4005 3
					pf_change_icmp(&h2.ip_src.s_addr,
					    &th.th_sport, &h->ip_dst.s_addr,
					    (*state)->lan.addr,
d4007 2
a4008 2
					    &h2.ip_sum, &ih->icmp_cksum,
					    &h->ip_sum, 0);
d4010 2
a4011 3
					pf_change_icmp(&h2.ip_dst.s_addr,
					    &th.th_dport, &h->ip_src.s_addr,
					    (*state)->gwy.addr,
d4013 20
a4032 2
					    &h2.ip_sum, &ih->icmp_cksum,
					    &h->ip_sum, 0);
a4033 2
				m_copyback(m, off, ICMP_MINLEN, (caddr_t)ih);
				m_copyback(m, ipoff2, sizeof(h2), (caddr_t)&h2);
d4047 1
a4047 1
			    NULL, NULL)) {
d4053 1
d4055 1
a4055 1
			key.addr[0] = h2.ip_dst;
d4057 1
a4057 1
			key.addr[1] = h2.ip_src;
d4069 2
a4070 3
					pf_change_icmp(&h2.ip_src.s_addr,
					    &uh.uh_sport, &h->ip_dst.s_addr,
					    (*state)->lan.addr,
d4072 2
a4073 2
					    &h2.ip_sum, &ih->icmp_cksum,
					    &h->ip_sum, 1);
d4075 2
a4076 3
					pf_change_icmp(&h2.ip_dst.s_addr,
					    &uh.uh_dport, &h->ip_src.s_addr,
					    (*state)->gwy.addr,
d4078 20
a4097 2
					    &h2.ip_sum, &ih->icmp_cksum,
					    &h->ip_sum, 1);
a4098 3
				m_copyback(m, off, ICMP_MINLEN, (caddr_t)ih);
				m_copyback(m, ipoff2, sizeof(h2),
				    (caddr_t)&h2);
d4106 1
d4112 1
a4112 1
			    NULL, NULL)) {
d4118 1
d4120 1
a4120 1
			key.addr[0] = h2.ip_dst;
d4122 1
a4122 1
			key.addr[1] = h2.ip_src;
d4134 2
a4135 3
					pf_change_icmp(&h2.ip_src.s_addr,
					    &iih.icmp_id, &h->ip_dst.s_addr,
					    (*state)->lan.addr,
d4137 2
a4138 2
					    &h2.ip_sum, &ih->icmp_cksum,
					    &h->ip_sum, 0);
d4140 2
a4141 3
					pf_change_icmp(&h2.ip_dst.s_addr,
					    &iih.icmp_id, &h->ip_src.s_addr,
					    (*state)->gwy.addr,
d4143 2
a4144 2
					    &h2.ip_sum, &ih->icmp_cksum,
					    &h->ip_sum, 0);
d4146 2
a4147 1
				m_copyback(m, off, ICMP_MINLEN, (caddr_t)ih);
d4157 53
d4225 1
a4225 1
    u_short *actionp, u_short *reasonp)
d4227 16
a4242 7
	struct ip *h = mtod(m, struct ip *);
	u_int16_t fragoff = (h->ip_off & IP_OFFMASK) << 3;

	if (fragoff) {
		if (fragoff >= len)
			ACTION_SET(actionp, PF_PASS);
		else {
d4244 2
a4245 1
			REASON_SET(reasonp, PFRES_FRAG);
a4246 1
		return (NULL);
d4248 12
a4259 4
	if (m->m_pkthdr.len < off + len || h->ip_len < off + len) {
		ACTION_SET(actionp, PF_DROP);
		REASON_SET(reasonp, PFRES_SHORT);
		return (NULL);
d4265 1
d4274 1
d4317 7
d4328 1
d4330 2
a4331 1
		if (!pf_pull_hdr(m, off, &th, sizeof(th), &action, &reason)) {
d4335 2
a4336 1
		action = pf_normalize_tcp(dir, ifp, m, 0, off, h, &th);
d4339 1
a4339 1
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h , &th);
d4344 1
a4344 1
			action = pf_test_tcp(dir, ifp, m, 0, off, h , &th);
d4350 1
d4352 2
a4353 1
		if (!pf_pull_hdr(m, off, &uh, sizeof(uh), &action, &reason)) {
d4357 1
a4357 1
		action = pf_test_state_udp(&s, dir, ifp, m, 0, off, h, &uh);
d4362 1
a4362 1
			action = pf_test_udp(dir, ifp, m, 0, off, h, &uh);
d4368 1
d4370 2
a4371 1
		if (!pf_pull_hdr(m, off, &ih, ICMP_MINLEN, &action, &reason)) {
d4375 1
a4375 1
		action = pf_test_state_icmp(&s, dir, ifp, m, 0, off, h, &ih);
d4384 1
a4384 1
			action = pf_test_icmp(dir, ifp, m, 0, off, h, &ih);
d4389 1
a4389 1
		action = pf_test_other(dir, ifp, m, h);
d4394 2
a4395 2
		pf_status.bcounters[dir] += h->ip_len;
		pf_status.pcounters[dir][action]++;
d4412 169
@


1.148
log
@Undo BINAT translation when blocking with return-rst/-icmp.
Translate at most once. From Ryan McBride.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.147 2001/09/06 18:05:46 jasoni Exp $ */
d2781 17
@


1.147
log
@1:1 bidrectional NAT (binat); ok dhartmei@@ and frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.146 2001/09/05 19:12:59 dhartmei Exp $ */
d2280 1
a2280 1
		if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_TCP,
d2338 2
a2339 1
			if (nat != NULL) {
d2343 2
a2344 1
			} else if (rdr != NULL) {
d2499 1
a2499 1
		if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_UDP,
d2554 2
a2555 1
			if (nat != NULL) {
d2559 2
a2560 1
			} else if (rdr != NULL) {
@


1.146
log
@Handle uh_sum == 0x0000 correctly. Before, UDP packet checksums were
broken by NAT/RDR when unset by the sender. Fixes ntpdate behind NAT.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.145 2001/09/05 12:42:31 dhartmei Exp $ */
d93 1
d100 2
d114 2
d150 1
a150 1
struct pool		 pf_rdr_pl, pf_state_pl;
d157 2
d192 2
d313 15
d785 2
d798 2
d806 2
d852 3
d1258 172
d2167 24
d2231 1
d2240 10
d2251 1
a2251 1
		if ((nat = pf_get_nat(ifp, IPPROTO_TCP,
d2279 10
d2361 1
a2361 1
	if (((rm != NULL) && rm->keep_state) || nat != NULL || rdr != NULL) {
d2383 1
a2383 1
			if (nat != NULL) {
d2395 1
a2395 1
			if (rdr != NULL) {
d2446 1
d2455 10
d2466 1
a2466 1
		if ((nat = pf_get_nat(ifp, IPPROTO_UDP,
d2496 10
d2572 1
a2572 1
	if ((rm != NULL && rm->keep_state) || nat != NULL || rdr != NULL) {
d2594 1
a2594 1
			if (nat != NULL) {
d2606 1
a2606 1
			if (rdr != NULL) {
d2643 1
d2649 7
d2657 1
a2657 1
		if ((nat = pf_get_nat(ifp, IPPROTO_ICMP,
d2662 8
d2716 1
a2716 1
	if ((rm != NULL && rm->keep_state) || nat != NULL) {
d2737 1
a2737 1
			if (nat != NULL)
d2747 4
a2750 1
			s->gwy.addr = s->lan.addr;
@


1.145
log
@s/pf_natlook/pfioc_natlook (ioctl parameter struct)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.144 2001/09/04 12:32:53 dhartmei Exp $ */
d171 2
a172 1
u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t);
d174 3
a176 2
			    u_int16_t *, u_int32_t, u_int16_t);
void			 pf_change_a(u_int32_t *, u_int16_t *, u_int32_t);
d179 1
a179 1
			    u_int16_t *, u_int16_t *);
d1643 1
a1643 1
pf_cksum_fixup(u_int16_t cksum, u_int16_t old, u_int16_t new)
d1645 1
a1645 1
	u_int32_t l = cksum + old - new;
d1647 3
d1652 3
a1654 4
	if (l)
		return (l);
	else
		return (65535);
d1659 1
a1659 1
    u_int32_t an, u_int16_t pn)
d1666 1
a1666 1
	    an / 65536), ao % 65536, an % 65536);
d1669 1
a1669 2
	    an / 65536), ao % 65536, an % 65536),
	    po, pn);
d1673 1
a1673 1
pf_change_a(u_int32_t *a, u_int16_t *c, u_int32_t an)
d1678 2
a1679 2
	*c = pf_cksum_fixup(pf_cksum_fixup(*c, ao / 65536, an / 65536),
	    ao % 65536, an % 65536);
d1684 2
a1685 1
    u_int16_t np, u_int16_t *pc, u_int16_t *h2c, u_int16_t *ic, u_int16_t *hc)
d1695 2
a1696 2
		*pc = pf_cksum_fixup(*pc, oip, *ip);
	*ic = pf_cksum_fixup(*ic, oip, *ip);
d1698 1
a1698 1
		*ic = pf_cksum_fixup(*ic, opc, *pc);
d1701 5
a1705 5
	*h2c = pf_cksum_fixup(pf_cksum_fixup(*h2c, oia / 65536, *ia / 65536),
	    oia % 65536, *ia % 65536);
	*ic = pf_cksum_fixup(pf_cksum_fixup(*ic, oia / 65536, *ia / 65536),
	    oia % 65536, *ia % 65536);
	*ic = pf_cksum_fixup(*ic, oh2c, *h2c);
d1708 2
a1709 2
	*hc = pf_cksum_fixup(pf_cksum_fixup(*hc, ooa / 65536, *oa / 65536),
	    ooa % 65536, *oa % 65536);
d2020 2
a2021 1
			    &h->ip_sum, &th->th_sum, nat->raddr, htons(nport));
d2036 1
a2036 1
			    &h->ip_sum, &th->th_sum, rdr->raddr, nport);
d2090 1
a2090 1
				    &h->ip_sum, &th->th_sum, baddr, bport);
d2094 1
a2094 1
				    &h->ip_sum, &th->th_sum, baddr, bport);
d2162 1
a2162 1
			    htonl(s->src.seqlo + s->src.seqdiff));
d2214 2
a2215 1
			    &h->ip_sum, &uh->uh_sum, nat->raddr, htons(nport));
d2231 1
a2231 1
			    nport);
d2283 1
a2283 1
				    &h->ip_sum, &uh->uh_sum, baddr, bport);
d2287 1
a2287 1
				    &h->ip_sum, &uh->uh_sum, baddr, bport);
d2381 1
a2381 1
			pf_change_a(&h->ip_src.s_addr, &h->ip_sum, nat->raddr);
d2578 2
a2579 2
			    src->seqdiff));
			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack));
d2609 2
a2610 2
			    src->seqdiff));
			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack));
d2790 1
a2790 1
			    (*state)->gwy.port);
d2795 1
a2795 1
			    (*state)->lan.port);
d2857 1
a2857 1
			    (*state)->gwy.addr, (*state)->gwy.port);
d2861 1
a2861 1
			    (*state)->lan.addr, (*state)->lan.port);
d2909 1
a2909 1
				    &h->ip_sum, (*state)->gwy.addr);
d2912 1
a2912 1
				    &h->ip_sum, (*state)->lan.addr);
d2984 2
a2985 1
				pf_change_a(&th.th_seq, &th.th_sum, htonl(seq));
d3004 1
a3004 1
					    &h->ip_sum);
d3011 1
a3011 1
					    &h->ip_sum);
d3054 1
a3054 1
					    &h->ip_sum);
d3061 1
a3061 1
					    &h->ip_sum);
d3104 1
a3104 1
					    &h->ip_sum);
d3111 1
a3111 1
					    &h->ip_sum);
@


1.144
log
@Add skip steps for interface (ifp).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.143 2001/09/04 08:55:37 dhartmei Exp $ */
d1505 1
a1505 1
		struct pf_natlook *pnl = (struct pf_natlook *)addr;
@


1.143
log
@#define empty PFLOG_PACKET correctly (no side effects). Closes PR2044.
From Claus Assmann.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.142 2001/08/31 23:05:22 frantzen Exp $ */
d1610 1
a1610 1
		for (i = 0; i < 5; ++i) {
d1616 3
a1618 2
			PF_CALC_SKIP_STEP(0, s->proto == r->proto);
			PF_CALC_SKIP_STEP(1,
d1622 1
a1622 1
			PF_CALC_SKIP_STEP(2,
d1626 1
a1626 1
			PF_CALC_SKIP_STEP(3,
d1630 1
a1630 1
			PF_CALC_SKIP_STEP(4,
d2043 1
a2043 1
		if (r->proto && r->proto != h->ip_p)
d2045 2
d2049 1
a2049 1
			r = r->skip[1];
d2052 1
a2052 1
			r = r->skip[2];
d2055 1
a2055 1
			r = r->skip[3];
d2058 1
a2058 1
			r = r->skip[4];
a2060 2
		else if (r->ifp != NULL && r->ifp != ifp)
			r = TAILQ_NEXT(r, entries);
d2238 1
a2238 1
		if (r->proto && r->proto != h->ip_p)
d2240 2
d2244 1
a2244 1
			r = r->skip[1];
d2247 1
a2247 1
			r = r->skip[2];
d2250 1
a2250 1
			r = r->skip[3];
d2253 1
a2253 1
			r = r->skip[4];
a2255 2
		else if (r->ifp != NULL && r->ifp != ifp)
			r = TAILQ_NEXT(r, entries);
d2386 1
a2386 1
		if (r->proto && r->proto != h->ip_p)
d2388 2
d2392 1
a2392 1
			r = r->skip[1];
d2395 1
a2395 1
			r = r->skip[3];
a2397 2
		else if (r->ifp != NULL && r->ifp != ifp)
			r = TAILQ_NEXT(r, entries);
d2489 1
a2489 1
		if (r->proto && r->proto != h->ip_p)
d2491 2
d2495 1
a2495 1
			r = r->skip[1];
d2498 1
a2498 1
			r = r->skip[3];
a2499 2
			r = TAILQ_NEXT(r, entries);
		else if (r->ifp != NULL && r->ifp != ifp)
@


1.142
log
@Forgot to commit frag expire tuning before
Check for a short ip_hl.  Could have caused proto headers to overlap IP header.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.141 2001/08/28 08:12:17 dhartmei Exp $ */
d224 1
a224 1
#define	PFLOG_PACKET
@


1.141
log
@Add new ioctls to securelevel check, from Can Erkin Acar
<canacar@@eee.metu.edu.tr>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.140 2001/08/28 00:02:43 frantzen Exp $ */
d3196 6
@


1.140
log
@Bump state timeouts and allow tweaking them from pfctl.
(The state timeouts need some _serious_ tuning)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.139 2001/08/26 23:23:03 niklas Exp $ */
d824 3
@


1.139
log
@2nd uninitialized variable that bit me today
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.138 2001/08/25 21:54:25 frantzen Exp $ */
d116 28
d824 1
d1547 26
d2169 1
a2169 1
		s->expire = pftv.tv_sec + 60;
d2344 1
a2344 1
		s->expire = pftv.tv_sec + 30;
d2464 1
a2464 1
		s->expire = pftv.tv_sec + 20;
d2673 1
a2673 1
			(*state)->expire = pftv.tv_sec + 5;
d2676 2
a2677 2
			(*state)->expire = pftv.tv_sec + 15;
		else if (src->state >= TCPS_CLOSING &&
d2679 1
a2679 1
			(*state)->expire = pftv.tv_sec + 300;
d2682 1
a2682 1
			(*state)->expire = pftv.tv_sec + 30;
d2684 1
a2684 1
			(*state)->expire = pftv.tv_sec + 24*60*60;
d2838 1
a2838 1
		(*state)->expire = pftv.tv_sec + 60;
d2840 1
a2840 1
		(*state)->expire = pftv.tv_sec + 20;
d2893 1
a2893 1
		(*state)->expire = pftv.tv_sec + 10;
d3169 1
a3169 1
	/* purge expire states, at most once every 10 seconds */
d3171 1
a3171 1
	if (pftv.tv_sec - pf_last_purge >= 10) {
@


1.138
log
@PF ISN randomization.  Or in trekkie techno-babble, ISN phase modulation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.137 2001/08/22 03:02:25 frantzen Exp $ */
d3102 1
a3102 1
	struct pf_state *s;
@


1.137
log
@Correct the setup of the intial TCP state window and pre-validate th_ack
on an FIN|ACK close if the client has never responded.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.136 2001/08/22 00:26:10 frantzen Exp $ */
d695 4
a698 4
	printf(" [lo=%lu high=%lu win=%u]", s->src.seqlo, s->src.seqhi,
		 s->src.max_win);
	printf(" [lo=%lu high=%lu win=%u]", s->dst.seqlo, s->dst.seqhi,
		 s->dst.max_win);
d2089 13
a2101 2
		s->src.seqlo = ntohl(th->th_seq) + len;
		s->src.seqhi = s->src.seqlo + 1;
a2106 1

d2110 1
d2280 1
d2285 1
d2400 1
d2405 1
d2472 1
a2472 2
	u_int32_t seq = ntohl(th->th_seq), ack = ntohl(th->th_ack);
	u_int32_t end;
a2475 6
	end = seq + len;
	if (th->th_flags & TH_SYN)
		end++;
	if (th->th_flags & TH_FIN)
		end++;

d2503 1
d2506 20
a2525 1
		src->seqlo = end;
d2538 14
d2616 1
a2616 1
		if (src->state >= TCPS_FIN_WAIT_2 ||
d2619 3
d2732 3
d2736 1
a2893 1
			seq = ntohl(th.th_seq);
d2916 5
d2948 4
a2951 4
				m_copyback(m, ipoff2, sizeof(h2),
				    (caddr_t)&h2);
				m_copyback(m, off2, 8,
				    (caddr_t)&th);
@


1.136
log
@Fix panic in pf (was my fault) caused by a bad key compare optimization
Add debug output to track loose state matches
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.135 2001/08/21 17:25:59 deraadt Exp $ */
d2090 1
d2092 1
a2092 1
			s->src.seqlo++;
d2094 1
a2094 2
			s->src.seqlo++;
		s->src.seqhi = s->src.seqlo + 1;
d2515 7
a2521 3
	} else if (ack == 0 &&
	    (th->th_flags & (TH_ACK|TH_RST)) == (TH_ACK|TH_RST)) {
		/* broken tcp stacks do not set ack */
d2656 5
a2660 2
			printf(" seq=%lu ack=%lu len=%u ackskew=%d pkts=%d\n",
			    seq, ack, len, ackskew, (*state)->packets++);
@


1.135
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.134 2001/08/21 01:54:17 frantzen Exp $ */
d213 8
a220 4
	if ((diff = a->addr[0].s_addr - b->addr[0].s_addr) != 0)
		return (diff);
	if ((diff = a->addr[1].s_addr - b->addr[1].s_addr) != 0)
		return (diff);
d2612 8
@


1.134
log
@Pass closing TCP connections through looser state machine (handle Solaris'
stupid spurious ACK|FINs after a close)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.133 2001/08/19 20:25:22 dhartmei Exp $ */
d1004 1
a1004 1
				     newrule, entries);
d2647 2
a2648 2
	    		    SEQ_GEQ(src->seqhi + MAXACKWINDOW, end) ?' ' :'5',
	    		    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW) ?' ' :'6');
@


1.133
log
@Add new ioctls for adding/removing RDR and NAT rules to/from the active
rule sets.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.132 2001/08/19 20:00:39 frantzen Exp $ */
d2580 3
a2582 1
	} else if (dst->state < TCPS_SYN_SENT &&
d2589 9
a2597 4
		 * This is the check for stupid stacks that shotgun SYNs before
		 * their peer replies.  It also handles the case when PF
		 * catches an already established stream (the firewall
		 * rebooted, the state table was flushed, routes changed...)
d2600 7
a2606 5
		 * since packet floods will also be caught by the stupid stack
		 * check.  We won't update the ttl here to mitigate the
		 * damage of a packet flood -- the ttl will be updated when
		 * the peer ACKs (then we'll just assume the connection is
		 * valid)
@


1.132
log
@Quick optimization of pf_tree_key_compare (should half the instruction count)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.131 2001/08/19 19:46:08 dhartmei Exp $ */
d123 2
d251 40
d942 2
a943 2
		if (pcr->action < PF_CHANGERULE_ADD_HEAD ||
		    pcr->action > PF_CHANGERULE_REMOVE) {
d948 1
a948 1
		if (pcr->action != PF_CHANGERULE_REMOVE) {
d970 1
a970 1
		if (pcr->action == PF_CHANGERULE_ADD_HEAD)
d972 1
a972 1
		else if (pcr->action == PF_CHANGERULE_ADD_TAIL)
d986 1
a986 1
		if (pcr->action == PF_CHANGERULE_REMOVE) {
d999 2
a1000 2
			else if (pcr->action == PF_CHANGERULE_ADD_HEAD ||
			    pcr->action == PF_CHANGERULE_ADD_BEFORE)
d1121 66
d1287 66
@


1.131
log
@Make more money for mickey (count entire IP packets for statistics, not just
inner data).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.130 2001/08/19 19:08:35 frantzen Exp $ */
d203 2
d209 11
a219 20
	if (a->proto < b->proto)
		return (-1);
	if (a->proto > b->proto)
		return ( 1);
	if (a->addr[0].s_addr < b->addr[0].s_addr)
		return (-1);
	if (a->addr[0].s_addr > b->addr[0].s_addr)
		return ( 1);
	if (a->addr[1].s_addr < b->addr[1].s_addr)
		return (-1);
	if (a->addr[1].s_addr > b->addr[1].s_addr)
		return ( 1);
	if (a->port[0] < b->port[0])
		return (-1);
	if (a->port[0] > b->port[0])
		return ( 1);
	if (a->port[1] < b->port[1])
		return (-1);
	if (a->port[1] > b->port[1])
		return ( 1);
@


1.130
log
@Yet another batch of improvements and un-fuckups to the TCP state code.
Improved the state miss debug messages to cover the new checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.129 2001/08/19 19:03:58 dhartmei Exp $ */
d1843 1
a1843 1
		rm->bytes += h->ip_len - off - (th->th_off << 2);
d1934 1
a1934 1
		s->bytes = len;
d2025 1
a2025 1
		rm->bytes += h->ip_len - off - sizeof(*uh);
d2107 1
a2107 1
		s->bytes = len;
d2169 1
a2169 1
		rm->bytes +=  h->ip_len - off - ICMP_MINLEN;
d2225 1
a2225 1
		s->bytes = len;
d2369 1
a2369 1
		(*state)->bytes += len;
d2434 1
a2434 1
		(*state)->bytes += len;
d2495 1
a2495 1
		(*state)->rule->bytes += len;
a2503 1
	u_int16_t len = h->ip_len - off - sizeof(*uh);
d2529 1
a2529 1
	(*state)->bytes += len;
d2558 1
a2558 1
		(*state)->rule->bytes += len;
a2566 2
	u_int16_t len = h->ip_len - off - sizeof(*ih);

d2593 1
a2593 1
		(*state)->bytes += len;
d2940 1
a2940 1
				r->bytes += h->ip_len - off - sizeof(ih);
@


1.129
log
@Add per-rule byte counter, so mickey can do accounting. We're counting the
data part (without IP and TCP/UDP/ICMP headers), like the state counter does.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.128 2001/08/19 18:19:08 dhartmei Exp $ */
d2335 2
a2336 2
		if (SEQ_GEQ(seq + MAX(1, dst->max_win), src->seqhi))
			src->seqhi = seq + MAX(1, dst->max_win);
d2416 1
a2416 1
	    SEQ_GEQ(src->seqlo - MAXACKWINDOW, seq)) {
d2464 3
a2466 3
			printf(" seq=%lu ack=%lu len=%u ", seq, ack, len);
			printf("\n");
			printf("State failure: %c %c %c %c\n",
d2470 3
a2472 1
			    (ackskew <= MAXACKWINDOW) ? ' ' : '4');
@


1.128
log
@Add per-rule statistics (number of evaluations and number of packets).
Packets passed statefully will be counted using the rule that created
the state.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.127 2001/08/19 17:03:00 frantzen Exp $ */
d826 1
a826 1
		rule->packets = rule->evaluations = 0;
d929 2
a930 1
			newrule->packets = newrule->evaluations = 0;
d1843 1
d2025 1
d2169 1
d2268 1
d2491 4
d2555 4
d2939 4
a2957 2
	if (r != NULL)
		r->packets++;
@


1.127
log
@Unfuck some TCP state stuff that would drop the SYN|ACK.
Enumerated the TCP states.
Here's a mapping new->old tcp states if anyone gives a shit:
TCPS_CLOSED            0
TCPS_SYN_SENT          1
TCPS_ESTABLISHED       2
TCPS_CLOSING           3
TCPS_FIN_WAIT_2        4
TCPS_TIME_WAIT         5
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.126 2001/08/19 01:53:26 frantzen Exp $ */
d826 1
d929 1
d1811 1
d1841 1
d1994 1
d2022 1
d2139 1
d2165 1
d2239 1
d2263 1
d2941 2
@


1.126
log
@Loosened TCP state code which should allow stupid stacks to shotgun their
SYNs and provide better handling for pre-existing connections.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.125 2001/08/18 22:26:08 dhartmei Exp $ */
d56 1
d1923 2
a1924 2
		s->src.state = 1;
		s->dst.state = 0;
d2312 2
a2313 3
		src->max_win = 1;
		if (src->state < 1)
			src->state = 1;
d2320 4
a2323 2
		if (SEQ_GEQ(end + MAX(1, dst->max_win), dst->seqhi))
			dst->seqhi = end + dst->max_win;
d2343 1
a2343 1
#define MAXACKWINDOW (0xffff + 1500)
d2369 2
a2370 2
			if (src->state < 1)
				src->state = 1;
d2372 2
a2373 2
			if (src->state < 3)
				src->state = 3;
d2375 4
a2378 4
			if (dst->state == 1)
				dst->state = 2;
			else if (dst->state == 3)
				dst->state = 4;
d2381 1
a2381 1
			src->state = dst->state = 5;
d2384 2
a2385 1
		if (src->state >= 4 && dst->state >= 4)
d2387 2
a2388 1
		else if (src->state >= 3 && dst->state >= 3)
d2390 2
a2391 1
		else if (src->state < 2 || dst->state < 2)
d2398 1
a2398 1
	} else if (dst->state < 1 &&
d2437 2
a2438 2
			if (src->state < 3)
				src->state = 3;
d2440 1
a2440 1
			src->state = dst->state = 5;
@


1.125
log
@Add new ioctl for adding/removing individual rules to/from the active rule set.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.124 2001/08/18 21:09:13 deraadt Exp $ */
d2302 6
a2310 1
		src->seqhi = end + 1;
d2314 8
a2350 11
		if (ackskew < 0) {
			/* The sequencing algorithm is exteremely lossy
			 * when there is fragmentation since the full
			 * packet length can not be determined.  So we
			 * deduce how much data passed by what the
			 * other endpoint ACKs.  Thanks Guido!
			 * (Why MAXACKWINDOW is used)
			 */
			dst->seqlo = ack;
		}

d2391 45
a2435 14
		/* translate source/destination address, if needed */
		if (STATE_TRANSLATE(*state)) {
			if (direction == PF_OUT)
				pf_change_ap(&h->ip_src.s_addr,
				    &th->th_sport, &h->ip_sum,
				    &th->th_sum, (*state)->gwy.addr,
				    (*state)->gwy.port);
			else
				pf_change_ap(&h->ip_dst.s_addr,
				    &th->th_dport, &h->ip_sum,
				    &th->th_sum, (*state)->lan.addr,
				    (*state)->lan.port);
			m_copyback(m, off, sizeof(*th), (caddr_t)th);
		}
d2437 1
a2437 1
		return (PF_PASS);
d2454 18
@


1.124
log
@make pfctl -s state SCREAM; frantzen is now happy
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.123 2001/08/11 12:05:00 dhartmei Exp $ */
d120 2
d229 26
d896 78
@


1.123
log
@Add support for ICMP errors referring to ICMP queries/replies. Fixes
'ICMP error message for bad proto' messages. Reported by Mark Grimes
and Steve Rumble.

Add debugging level with ioctl interface and pfctl switch. Default
is 'None'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.122 2001/08/01 23:07:36 provos Exp $ */
d4 1
a4 1
 * Copyright (c) 2001, Daniel Hartmeier
d1120 44
d1247 1
@


1.122
log
@stateless tcp normalization along the lines of the normalization paper by
handley, paxon and kreibich; okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.121 2001/07/30 23:00:37 deraadt Exp $ */
d66 1
a66 2
int pf_debug = 0;
#define DPFPRINTF(x)	if (pf_debug) printf x
d500 11
a510 9
		printf("pf: ERROR! insert invalid\n");
		printf("    key already in tree_lan_ext\n");
		printf("    key: proto = %u, lan = ", state->proto);
		pf_print_host(key.addr[0].s_addr, key.port[0]);
		printf(", ext = ");
		pf_print_host(key.addr[1].s_addr, key.port[1]);
		printf("\n    state: ");
		pf_print_state(s);
		printf("\n");
d514 2
a515 1
			printf("pf: ERROR! insert failed\n");
d524 11
a534 9
		printf("pf: ERROR! insert invalid\n");
		printf("    key already in tree_ext_gwy\n");
		printf("    key: proto = %u, ext = ", state->proto);
		pf_print_host(key.addr[0].s_addr, key.port[0]);
		printf(", gwy = ");
		pf_print_host(key.addr[1].s_addr, key.port[1]);
		printf("\n    state: ");
		pf_print_state(s);
		printf("\n");
d538 2
a539 1
			printf("pf: ERROR! insert failed\n");
d561 2
a562 1
				printf("pf: ERROR: remove invalid!\n");
d565 2
a566 1
				printf("pf: ERROR: remove failed\n");
d583 2
a584 2
					printf(
					    "pf: ERROR: next not refound\n");
d743 1
a743 1
			printf("pf: started\n");
d752 1
a752 1
			printf("pf: stopped\n");
d1146 1
d1192 7
d2256 12
a2267 12
		/* XXX Remove these printfs before release */
		printf("pf: BAD state: ");
		pf_print_state(*state);
		pf_print_flags(th->th_flags);
		printf(" seq=%lu ack=%lu len=%u ", seq, ack, len);
		printf("\n");
		printf("State failure: %c %c %c %c\n",
		    SEQ_GEQ(src->seqhi, end) ? ' ' : '1',
		    SEQ_GEQ(seq, src->seqlo - dst->max_win) ? ' ': '2',
		    (ackskew >= -MAXACKWINDOW) ? ' ' : '3',
		    (ackskew <= MAXACKWINDOW) ? ' ' : '4');

d2392 2
a2393 1
			printf("pf: ICMP error message too short (ip)\n");
d2417 2
a2418 2
				printf("pf: "
				    "ICMP error message too short (tcp)\n");
d2446 5
a2450 4

				printf("pf: BAD ICMP state: ");
				pf_print_state(*state);
				printf(" seq=%lu\n", seq);
d2486 2
a2487 1
				printf("pf: ICMP error message too short (udp)\n");
d2530 50
d2581 2
a2582 1
			printf("pf: ICMP error message for bad proto\n");
@


1.121
log
@never before has a file so often deviated from KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.120 2001/07/29 12:53:17 dhartmei Exp $ */
a147 2
int			 pf_match_port(u_int8_t, u_int16_t, u_int16_t,
			    u_int16_t);
d179 2
d2602 3
@


1.120
log
@Implement rule skipping. This is a transparent evaluation optimization,
which reduces evaluation cost for sorted rules of similar parameters.
Preparation for rule duplication for parameter lists from pfctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.119 2001/07/25 12:22:28 dhartmei Exp $ */
d183 8
a190 8
#define		 PFLOG_PACKET(x,a,b,c,d,e) \
		do { \
			HTONS((x)->ip_len); \
			HTONS((x)->ip_off); \
			pflog_packet(a,b,c,d,e); \
			NTOHS((x)->ip_len); \
			NTOHS((x)->ip_off); \
		} while (0)
d192 1
a192 1
#define		 PFLOG_PACKET
d195 2
a196 3
#define		 STATE_TRANSLATE(s) \
		    ( (s)->lan.addr != (s)->gwy.addr || \
		      (s)->lan.port != (s)->gwy.port )
d1494 2
a1495 2
        int             	step;
        u_int16_t       	cut;
d1505 1
a1505 1
        if (low == high) {
d1507 1
a1507 1
                if (! pf_chk_sport(plist, *port))
d1510 22
a1531 22
        } else if (low < high) {
                step = 1;
                cut = arc4random() % (high - low) + low;
        } else {
                step = -1;
                cut = arc4random() % (low - high) + high;
        }

        *port = cut - step;
        do {
                *port += step;
                if (! pf_chk_sport(plist, *port))
                        goto found;
        } while (*port != low && *port != high);

        step = -step;
        *port = cut;
        do {
                *port += step;
                if (! pf_chk_sport(plist, *port))
                        goto found;
        } while (*port != low && *port != high);
d1536 1
a1536 1
        return (pf_add_sport(plist, *port));
@


1.119
log
@nat proxy port randomization by ben fleis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.118 2001/07/21 23:26:41 dhartmei Exp $ */
d174 1
d818 1
d1193 48
d1637 4
a1640 2
	TAILQ_FOREACH(r, pf_rules_active, entries) {
		if (r->action == PF_SCRUB)
d1642 22
a1663 6
		if (MATCH_TUPLE(h, r, direction, ifp) &&
		    ((th->th_flags & r->flagset) == r->flags) &&
		    (!r->dst.port_op || pf_match_port(r->dst.port_op,
		    r->dst.port[0], r->dst.port[1], th->th_dport)) &&
		    (!r->src.port_op || pf_match_port(r->src.port_op,
		    r->src.port[0], r->src.port[1], th->th_sport)) ) {
d1665 1
a1665 1
			if (r->quick)
d1667 1
d1818 4
a1821 2
	TAILQ_FOREACH(r, pf_rules_active, entries) {
		if (r->action == PF_SCRUB)
d1823 20
a1842 5
		if (MATCH_TUPLE(h, r, direction, ifp) &&
		    (!r->dst.port_op || pf_match_port(r->dst.port_op,
		    r->dst.port[0], r->dst.port[1], uh->uh_dport)) &&
		    (!r->src.port_op || pf_match_port(r->src.port_op,
		    r->src.port[0], r->src.port[1], uh->uh_sport))) {
d1844 1
a1844 1
			if (r->quick)
d1846 1
d1961 4
a1964 2
	TAILQ_FOREACH(r, pf_rules_active, entries) {
		if (r->action == PF_SCRUB)
d1966 18
a1983 3
		if (MATCH_TUPLE(h, r, direction, ifp) &&
		    (!r->type || (r->type == ih->icmp_type + 1)) &&
		    (!r->code || (r->code == ih->icmp_code + 1)) ) {
d1985 1
a1985 1
			if (r->quick)
d1987 1
d2059 4
a2062 2
	TAILQ_FOREACH(r, pf_rules_active, entries) {
		if (r->action == PF_SCRUB)
d2064 14
a2077 1
		if (MATCH_TUPLE(h, r, direction, ifp)) {
d2079 1
a2079 1
			if (r->quick)
d2081 1
@


1.118
log
@print additional debugging information for 'insert invalid' messages. occurs for some people (never for me), and I need more information. will be removed after the issue is resolved. please report these, if you get them.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.117 2001/07/19 00:07:36 krw Exp $ */
d60 1
d82 6
d113 2
a114 2
u_int16_t		 pf_next_port_tcp = 50001;
u_int16_t		 pf_next_port_udp = 50001;
d116 1
a116 1
struct pool		 pf_tree_pl, pf_rule_pl, pf_nat_pl;
d175 6
d194 4
d560 3
d660 2
d676 3
d1391 99
d1551 1
a1551 1
	u_int16_t bport, nport;
d1554 1
a1554 1
	int rewrite = 0;
d1562 4
d1567 1
a1567 2
			    &h->ip_sum, &th->th_sum, nat->raddr,
			    htons(pf_next_port_tcp));
d1628 3
a1630 1
		if (rm->action == PF_DROP)
d1632 1
d1635 1
a1635 1
	if (((rm != NULL) && rm->keep_state) || (nat != NULL) || (rdr != NULL)) {
d1642 3
a1644 1
		if (s == NULL)
d1646 1
d1654 1
a1654 1
			s->gwy.port = th->th_sport;
a1659 3
				pf_next_port_tcp++;
				if (pf_next_port_tcp == 65535)
					pf_next_port_tcp = 50001;
d1711 1
a1711 1
	u_int16_t bport, nport;
d1714 1
a1714 1
	int rewrite = 0;
d1722 4
d1727 1
a1727 2
			    &h->ip_sum, &uh->uh_sum, nat->raddr,
			    htons(pf_next_port_udp));
d1785 3
a1787 1
		if (rm->action == PF_DROP)
d1789 1
d1799 3
a1801 1
		if (s == NULL)
d1803 1
a1816 3
				pf_next_port_udp++;
				if (pf_next_port_udp == 65535)
					pf_next_port_udp = 50001;
d2104 1
a2104 2
		if ((*state)->lan.addr != (*state)->gwy.addr ||
		    (*state)->lan.port != (*state)->gwy.port) {
d2182 1
a2182 2
	if ((*state)->lan.addr != (*state)->gwy.addr ||
	    (*state)->lan.port != (*state)->gwy.port) {
d2317 1
a2317 2
			if ((*state)->lan.addr != (*state)->gwy.addr ||
			    (*state)->lan.port != (*state)->gwy.port) {
d2366 1
a2366 2
			if ((*state)->lan.addr != (*state)->gwy.addr ||
			    (*state)->lan.port != (*state)->gwy.port) {
@


1.117
log
@Fix/complete the handling of the binary ops >< and <> to behave
like the ipf operators.

The 'n >< m' construct (Include Range = PF_OP_IRG) should match
ports greater than n and less than m, not greater than or equal to
n and less than or equal to m.

The 'n <> m' construct (Exclude Range = PF_OP_XRG) should match
all ports less than n OR greater than m, not be treated as an
alias for ><.

Thus PF_OP_GL, which was used for both <> and >< is replaced with
PF_OP_IRG and PF_OP_XRG with the 'correct' semantics.

OK dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.116 2001/07/18 22:24:07 dhartmei Exp $ */
d124 1
a124 1
void			 pf_print_state(int, struct pf_state *);
d475 1
d483 1
a483 1
	if (pf_find_state(tree_lan_ext, &key) != NULL)
d485 9
a493 1
	else {
d504 1
a504 1
	if (pf_find_state(tree_ext_gwy, &key) != NULL)
d506 9
a514 1
	else {
d579 1
a579 1
pf_print_state(int direction, struct pf_state *s)
d581 14
d1988 1
a1988 1
		pf_print_state(direction, *state);
d2178 1
a2178 1
				pf_print_state(direction, *state);
@


1.116
log
@fix pf_get_rdr() for single port (dport2 == 0) rules. found by lebel@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.115 2001/07/17 21:54:25 provos Exp $ */
d1315 4
a1318 2
	case PF_OP_GL:
		return (p >= a1) && (p <= a2);
@


1.115
log
@normalize ip_off, make IP_DF stripping optional, return rst is a flag now.
okay markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.114 2001/07/17 20:34:51 provos Exp $ */
d1365 3
a1367 2
		    (ntohs(dport) >= ntohs(r->dport)) &&
		    (ntohs(dport) <= ntohs(r->dport2)))
@


1.114
log
@split ip normalization out into a separate file, okay dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.113 2001/07/15 23:05:04 dhartmei Exp $ */
d1449 1
a1449 1
		    (rm->return_rst || rm->return_icmp)) {
d1460 1
a1460 1
			if (rm->return_rst)
@


1.113
log
@increase src->state to 1 when creating state from intermediate (non-SYN) packets. this fixes one class of BAD state messages (where seqlo=0, seqhi=1).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.112 2001/07/14 10:36:53 dhartmei Exp $ */
a47 1
#include <net/pfvar.h>
d60 2
d73 1
a73 5
	struct pf_tree_key {
		struct in_addr	 addr[2];
		u_int16_t	 port[2];
		u_int8_t	 proto;
	}			 key;
a80 20
struct pf_frent {
	LIST_ENTRY(pf_frent) fr_next;
	struct ip *fr_ip;
	struct mbuf *fr_m;
};

#define PFFRAG_SEENLAST	0x0001		/* Seen the last fragment for this */

struct pf_fragment {
	TAILQ_ENTRY(pf_fragment) frag_next;
	struct in_addr	fr_src;
	struct in_addr	fr_dst;
	u_int8_t	fr_p;		/* protocol of this fragment */
	u_int8_t	fr_flags;	/* status flags */
	u_int16_t	fr_id;		/* fragment id for reassemble */
	u_int16_t	fr_max;		/* fragment data max */
	struct timeval	fr_timeout;
	LIST_HEAD(pf_fragq, pf_frent) fr_queue;
};

a84 2
TAILQ_HEAD(pf_fragqueue, pf_fragment)	pf_fragqueue;
TAILQ_HEAD(pf_rulequeue, pf_rule)	pf_rules[2];
d87 1
a94 1
struct pf_tree_node	*tree_fragment;
d110 1
a110 2
struct pool		 pf_rdr_pl, pf_state_pl, pf_frent_pl, pf_frag_pl;
int			 pf_nfrents;
a115 5
int			 pf_tree_insert(struct pf_tree_node **,
			    struct pf_tree_node *, struct pf_tree_key *,
			    struct pf_state *);
int			 pf_tree_remove(struct pf_tree_node **,
			    struct pf_tree_node *, struct pf_tree_key *);
a119 2
struct pf_state		*pf_find_state(struct pf_tree_node *,
			    struct pf_tree_key *);
a140 2
int			 pf_match_addr(u_int8_t, u_int32_t, u_int32_t,
			    u_int32_t);
a166 14
int			 pflog_packet(struct mbuf *, int, u_short, u_short,
			    struct pf_rule *);

int			 pf_normalize_ip(struct mbuf **, int, struct ifnet *,
			    u_short *);

void			 pf_purge_expired_fragments(void);
void			 pf_ip2key(struct pf_tree_key *, struct ip *);
void			 pf_remove_fragment(struct pf_fragment *);
void			 pf_flush_fragments(void);
void			 pf_free_fragment(struct pf_fragment *);
struct pf_fragment	*pf_find_fragment(struct ip *);
struct mbuf		*pf_reassemble(struct mbuf **, struct pf_fragment *,
			    struct pf_frent *, int);
a180 14
#define		MATCH_TUPLE(h,r,d,i) \
		( \
		  (r->direction == d) && \
		  (r->ifp == NULL || r->ifp == i) && \
		  (!r->proto || r->proto == h->ip_p) && \
		  (!r->src.mask || pf_match_addr(r->src.not, r->src.addr, \
		   r->src.mask, h->ip_src.s_addr)) && \
		  (!r->dst.mask || pf_match_addr(r->dst.not, r->dst.addr, \
		   r->dst.mask, h->ip_dst.s_addr)) \
		)

#define PFFRAG_FRENT_HIWAT	5000	/* Number of fragment entries */
#define PFFRAG_FRAG_HIWAT	1000	/* Number of fragmented packets */

a608 4
	pool_init(&pf_frent_pl, sizeof(struct pf_frent), 0, 0, 0, "pffrent",
	    0, NULL, NULL, 0);
	pool_init(&pf_frag_pl, sizeof(struct pf_fragment), 0, 0, 0, "pffrag",
	    0, NULL, NULL, 0);
a609 4
	pool_sethiwat(&pf_frag_pl, PFFRAG_FRAG_HIWAT);
	pool_sethardlimit(&pf_frent_pl, PFFRAG_FRENT_HIWAT, NULL, 0);

	TAILQ_INIT(&pf_fragqueue);
d622 2
a1373 14
#define ACTION_SET(a, x) \
	do { \
		if ((a) != NULL) \
			*(a) = (x); \
	} while (0)

#define REASON_SET(a, x) \
	do { \
		if ((a) != NULL) \
			*(a) = (x); \
		if (x < PFRES_MAX) \
			pf_status.counters[x]++; \
	} while (0)

a2231 408
}

#define FRAG_EXPIRE	30

void
pf_purge_expired_fragments(void)
{
	struct pf_fragment *frag;
	struct timeval now, expire;

	microtime(&now);

	timerclear(&expire);
	expire.tv_sec = FRAG_EXPIRE;
	timersub(&now, &expire, &expire);

	while ((frag = TAILQ_LAST(&pf_fragqueue, pf_fragqueue)) != NULL) {
		if (timercmp(&frag->fr_timeout, &expire, >))
			break;

		DPFPRINTF((__FUNCTION__": expiring %p\n", frag));
		pf_free_fragment(frag);
	}
}

/*
 *  Try to flush old fragments to make space for new ones
 */

void
pf_flush_fragments(void)
{
	struct pf_fragment *frag;
	int goal = pf_nfrents * 9 / 10;

	DPFPRINTF((__FUNCTION__": trying to free > %d frents\n",
		   pf_nfrents - goal));

	while (goal < pf_nfrents) {
		frag = TAILQ_LAST(&pf_fragqueue, pf_fragqueue);
		if (frag == NULL)
			break;
		pf_free_fragment(frag);
	}
}

/* Frees the fragments and all associated entries */

void
pf_free_fragment(struct pf_fragment *frag)
{
	struct pf_frent *frent;

	/* Free all fragments */
	for (frent = LIST_FIRST(&frag->fr_queue); frent;
	    frent = LIST_FIRST(&frag->fr_queue)) {
		LIST_REMOVE(frent, fr_next);

		m_freem(frent->fr_m);
		pool_put(&pf_frent_pl, frent);
		pf_nfrents--;
	}

	pf_remove_fragment(frag);
}

void
pf_ip2key(struct pf_tree_key *key, struct ip *ip)
{
	key->proto = ip->ip_p;
	key->addr[0] = ip->ip_src;
	key->addr[1] = ip->ip_dst;
	key->port[0] = ip->ip_id;
	key->port[1] = 0;
}

struct pf_fragment *
pf_find_fragment(struct ip *ip)
{
	struct pf_tree_key key;
	struct pf_fragment *frag;

	pf_ip2key(&key, ip);

	frag = (struct pf_fragment *)pf_find_state(tree_fragment, &key);

	if (frag != NULL) {
		microtime(&frag->fr_timeout);
		TAILQ_REMOVE(&pf_fragqueue, frag, frag_next);
		TAILQ_INSERT_HEAD(&pf_fragqueue, frag, frag_next);
	}

	return (frag);
}

/* Removes a fragment from the fragment queue and frees the fragment */

void
pf_remove_fragment(struct pf_fragment *frag)
{
	struct pf_tree_key key;

	key.proto = frag->fr_p;
	key.addr[0] = frag->fr_src;
	key.addr[1] = frag->fr_dst;
	key.port[0] = frag->fr_id;
	key.port[1] = 0;

	pf_tree_remove(&tree_fragment, NULL, &key);
	TAILQ_REMOVE(&pf_fragqueue, frag, frag_next);

	pool_put(&pf_frag_pl, frag);
}

struct mbuf *
pf_reassemble(struct mbuf **m0, struct pf_fragment *frag,
    struct pf_frent *frent, int mff)
{
	struct mbuf *m = *m0, *m2;
	struct pf_frent *frep, *frea, *next;
	struct ip *ip = frent->fr_ip;
	int hlen = ip->ip_hl << 2;
	u_int16_t off = ip->ip_off;
	u_int16_t max = ip->ip_len + off;

	/* Strip off ip header */
	m->m_data += hlen;
	m->m_len -= hlen;

	/* Create a new reassembly queue for this packet */
	if (frag == NULL) {
		struct pf_tree_key key;

		frag = pool_get(&pf_frag_pl, M_NOWAIT);
		if (frag == NULL) {
			pf_flush_fragments();
			frag = pool_get(&pf_frag_pl, M_NOWAIT);
			if (frag == NULL)
				goto drop_fragment;
		}

		frag->fr_flags = 0;
		frag->fr_max = 0;
		frag->fr_src = frent->fr_ip->ip_src;
		frag->fr_dst = frent->fr_ip->ip_dst;
		frag->fr_p = frent->fr_ip->ip_p;
		frag->fr_id = frent->fr_ip->ip_id;
		LIST_INIT(&frag->fr_queue);

		pf_ip2key(&key, frent->fr_ip);

		pf_tree_insert(&tree_fragment, NULL, &key,
		    (struct pf_state *)frag);
		TAILQ_INSERT_HEAD(&pf_fragqueue, frag, frag_next);

		/* We do not have a previous fragment */
		frep = NULL;
		goto insert;
	}

	/*
	 * Find a fragment after the current one:
	 *  - off contains the real shifted offset.
	 */
	LIST_FOREACH(frea, &frag->fr_queue, fr_next) {
		if (frea->fr_ip->ip_off > off)
			break;
		frep = frea;
	}

	KASSERT(frep != NULL || frea != NULL);

	if (frep != NULL) {
		u_int16_t precut;

		precut = frep->fr_ip->ip_off + frep->fr_ip->ip_len - off;
		if (precut > ip->ip_len)
			goto drop_fragment;
		if (precut) {
			m_adj(frent->fr_m, precut);

			DPFPRINTF((__FUNCTION__": overlap -%d\n", precut));
			/* Enforce 8 byte boundaries */
			off = ip->ip_off += precut;
			ip->ip_len -= precut;
		}
	}

	for (; frea != NULL && ip->ip_len + off > frea->fr_ip->ip_off;
	    frea = next) {
		u_int16_t aftercut;

		aftercut = (ip->ip_len + off) - frea->fr_ip->ip_off;
		DPFPRINTF((__FUNCTION__": adjust overlap %d\n", aftercut));
		if (aftercut < frea->fr_ip->ip_len) {
			frea->fr_ip->ip_len -= aftercut;
			frea->fr_ip->ip_off += aftercut;
			m_adj(frea->fr_m, aftercut);
			break;
		}

		/* This fragment is completely overlapped, loose it */
		next = LIST_NEXT(frea, fr_next);
		m_freem(frea->fr_m);
		LIST_REMOVE(frea, fr_next);
		pool_put(&pf_frent_pl, frea);
		pf_nfrents--;
	}

 insert:
	/* Update maxmimum data size */
	if (frag->fr_max < max)
		frag->fr_max = max;
	/* This is the last segment */
	if (!mff)
		frag->fr_flags |= PFFRAG_SEENLAST;

	if (frep == NULL)
		LIST_INSERT_HEAD(&frag->fr_queue, frent, fr_next);
	else
		LIST_INSERT_AFTER(frep, frent, fr_next);

	/* Check if we are completely reassembled */
	if (!(frag->fr_flags & PFFRAG_SEENLAST))
		return (NULL);

	/* Check if we have all the data */
	off = 0;
	for (frep = LIST_FIRST(&frag->fr_queue); frep; frep = next) {
		next = LIST_NEXT(frep, fr_next);

		off += frep->fr_ip->ip_len;
		if (off < frag->fr_max &&
		    (next == NULL || next->fr_ip->ip_off != off)) {
			DPFPRINTF((__FUNCTION__": missing fragment at %d, next %d, max %d\n",
				  off, next == NULL ? -1 : next->fr_ip->ip_off, frag->fr_max));
			return (NULL);
		}
	}
	DPFPRINTF((__FUNCTION__": %d < %d?\n", off, frag->fr_max));
	if (off < frag->fr_max)
		return (NULL);

	/* We have all the data */
	frent = LIST_FIRST(&frag->fr_queue);
	KASSERT(frent != NULL);
	if ((frent->fr_ip->ip_hl << 2) + off > IP_MAXPACKET) {
		DPFPRINTF((__FUNCTION__": drop: too big: %d\n", off));
		pf_free_fragment(frag);
		return (NULL);
	}
	next = LIST_NEXT(frent, fr_next);

	/* Magic from ip_input */
	ip = frent->fr_ip;
	m = frent->fr_m;
	m2 = m->m_next;
	m->m_next = NULL;
	m_cat(m, m2);
	pool_put(&pf_frent_pl, frent);
	pf_nfrents--;
	for (frent = next; frent != NULL; frent = next) {
		next = LIST_NEXT(frent, fr_next);

		m2 = frent->fr_m;
		pool_put(&pf_frent_pl, frent);
		pf_nfrents--;
		m_cat(m, m2);
	}

	ip->ip_src = frag->fr_src;
	ip->ip_dst = frag->fr_dst;

	/* Remove from fragment queue */
	pf_remove_fragment(frag);

	hlen = ip->ip_hl << 2;
	ip->ip_len = off + hlen;
	m->m_len += hlen;
	m->m_data -= hlen;

	/* some debugging cruft by sklower, below, will go away soon */
	/* XXX this should be done elsewhere */
	if (m->m_flags & M_PKTHDR) {
		int plen = 0;
		for (m2 = m; m2; m2 = m2->m_next)
			plen += m2->m_len;
		m->m_pkthdr.len = plen;
	}

	DPFPRINTF((__FUNCTION__": complete: %p(%d)\n", m, ip->ip_len));
	return (m);

 drop_fragment:
	/* Oops - fail safe - drop packet */
	m_freem(m);
	return (NULL);
}

int
pf_normalize_ip(struct mbuf **m0, int dir, struct ifnet *ifp, u_short *reason)
{
	struct mbuf *m = *m0;
	struct pf_rule *r;
	struct pf_frent *frent;
	struct pf_fragment *frag;
	struct ip *h = mtod(m, struct ip *);
	int mff = (h->ip_off & IP_MF), hlen = h->ip_hl << 2;
	u_int16_t fragoff = (h->ip_off & IP_OFFMASK) << 3;
	u_int16_t max;

	TAILQ_FOREACH(r, pf_rules_active, entries) {
		if ((r->action == PF_SCRUB) &&
		    MATCH_TUPLE(h, r, dir, ifp))
			break;
	}

	if (r == NULL)
		return (PF_PASS);

	/* Check for illegal packets */
	if (hlen < sizeof(struct ip))
		goto drop;

	if (hlen > h->ip_len)
		goto drop;

	/* We will need other tests here */
	if (!fragoff && !mff)
		goto no_fragment;

	/* Now we are dealing with a fragmented packet */
	frag = pf_find_fragment(h);

	/* This can not happen */
	if (h->ip_off & IP_DF) {
		DPFPRINTF((__FUNCTION__": IP_DF\n"));
		goto bad;
	}

	h->ip_len -= hlen;
	h->ip_off <<= 3;

	/* All fragments are 8 byte aligned */
	if (mff && (h->ip_len & 0x7)) {
		DPFPRINTF((__FUNCTION__": mff and %d\n", h->ip_len));
		goto bad;
	}

	max = fragoff + h->ip_len;
	/* Respect maximum length */
	if (max > IP_MAXPACKET) {
		DPFPRINTF((__FUNCTION__": max packet %d\n", max));
		goto bad;
	}
	/* Check if we saw the last fragment already */
	if (frag != NULL && (frag->fr_flags & PFFRAG_SEENLAST) &&
	    max > frag->fr_max)
		goto bad;

	/* Get an entry for the fragment queue */
	frent = pool_get(&pf_frent_pl, PR_NOWAIT);
	if (frent == NULL) {
		/* Try to clean up old fragments */
		pf_flush_fragments();
		frent = pool_get(&pf_frent_pl, PR_NOWAIT);
		if (frent == NULL) {
			REASON_SET(reason, PFRES_MEMORY);
			return (PF_DROP);
		}
	}
	pf_nfrents++;
	frent->fr_ip = h;
	frent->fr_m = m;

	/* Might return a completely reassembled mbuf, or NULL */
	DPFPRINTF((__FUNCTION__": reass frag %d @@ %d\n", h->ip_id, fragoff));
	*m0 = m = pf_reassemble(m0, frag, frent, mff);

	if (m == NULL)
		return (PF_DROP);

	h = mtod(m, struct ip *);

 no_fragment:
	if (dir != PF_OUT)
		return (PF_PASS);

	return (PF_PASS);

 drop:
	REASON_SET(reason, PFRES_NORM);
	if (r != NULL && r->log)
		PFLOG_PACKET(h, m, AF_INET, dir, *reason, r);
	return (PF_DROP);

 bad:
	DPFPRINTF((__FUNCTION__": dropping bad fragment\n"));

	/* Free assoicated fragments */
	if (frag != NULL)
		pf_free_fragment(frag);

	REASON_SET(reason, PFRES_FRAG);
	if (r != NULL && r->log)
		PFLOG_PACKET(h, m, AF_INET, dir, *reason, r);

	return (PF_DROP);
@


1.112
log
@use int instead of signed char. doesn't use more memory (padding occurs) and is actually faster.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.111 2001/07/13 23:44:08 fgsch Exp $ */
d1934 2
@


1.111
log
@indent.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.110 2001/07/13 01:52:10 deraadt Exp $ */
d81 1
a81 1
	signed char		 balance;
@


1.110
log
@everytime i clean in here, i get a 250 line diff...
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.109 2001/07/11 16:14:15 dhartmei Exp $ */
a2335 1

d2382 5
a2386 5
		key->proto = ip->ip_p;
		key->addr[0] = ip->ip_src;
		key->addr[1] = ip->ip_dst;
		key->port[0] = ip->ip_id;
		key->port[1] = 0;
d2392 2
a2393 2
		struct pf_tree_key key;
		struct pf_fragment *frag;
d2395 1
a2395 1
		pf_ip2key(&key, ip);
d2397 1
a2397 2
		frag = (struct pf_fragment *)pf_find_state(tree_fragment,
		    &key);
d2399 5
a2403 5
		if (frag != NULL) {
			microtime(&frag->fr_timeout);
			TAILQ_REMOVE(&pf_fragqueue, frag, frag_next);
			TAILQ_INSERT_HEAD(&pf_fragqueue, frag, frag_next);
		}
d2405 1
a2405 1
		return (frag);
d2413 1
a2413 1
		struct pf_tree_key key;
d2415 5
a2419 5
		key.proto = frag->fr_p;
		key.addr[0] = frag->fr_src;
		key.addr[1] = frag->fr_dst;
		key.port[0] = frag->fr_id;
		key.port[1] = 0;
d2421 2
a2422 2
		pf_tree_remove(&tree_fragment, NULL, &key);
		TAILQ_REMOVE(&pf_fragqueue, frag, frag_next);
d2424 1
a2424 1
		pool_put(&pf_frag_pl, frag);
@


1.109
log
@Simplify pf_pull_hdr(), don't use inner IP header's ip_len or ip_off
in case of pf_test_state_icmp(). This solves the "ICMP error message
too short" problems. Reported by ycchang and heko.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.108 2001/07/09 23:15:27 dhartmei Exp $ */
d679 1
a679 1
	
d1156 1
a1156 1
	
d1161 1
a1161 1
		 * the lookup so we ask for what happens with the return 
d1168 1
a1168 1
		
d1190 1
a1190 1
			} else 
d1434 1
a1434 1
		    (ntohs(dport) >= ntohs(r->dport)) && 
d1461 1
a1461 1
	
d1554 1
a1554 2
	if (((rm != NULL) && rm->keep_state) || (nat != NULL) || (rdr != NULL))
	    {
d1658 1
a1658 1
			    &h->ip_sum, &uh->uh_sum, rdr->raddr, 
d2328 1
a2328 1
	
d2351 1
a2351 1
	
d2397 1
a2397 1
		
d2406 1
a2406 1
		
d2416 1
a2416 1
		
d2447 1
a2447 1
		
d2486 1
a2486 1
	
d2506 1
a2506 1
		
d2536 1
a2536 1
	
d2545 1
a2545 1
		
d2590 1
a2590 1
	
a2605 1
	
d2607 1
a2607 1
	
d2641 1
a2641 1
	
d2645 1
a2645 1
	
d2657 1
a2657 1
	
d2698 1
a2698 1
	
d2702 1
a2702 1
	    
d2710 1
a2710 1
	
d2713 1
a2713 1
	
d2795 1
a2795 1
	
@


1.108
log
@do compare in host order. found by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.107 2001/07/09 10:30:57 dhartmei Exp $ */
d200 2
a201 2
void			*pf_pull_hdr(struct ifnet *, struct mbuf *, int, int,
			    void *, int, struct ip *, u_short *, u_short *);
d2170 1
a2170 2
		if (!pf_pull_hdr(ifp, m, 0, ipoff2, &h2, sizeof(h2), h,
		    NULL, NULL)) {
d2175 4
d2194 1
a2194 2
			if (!pf_pull_hdr(ifp, m, ipoff2, off2, &th, 8,
			    &h2, NULL, NULL)) {
d2262 2
a2263 2
			if (!pf_pull_hdr(ifp, m, ipoff2, off2, &uh, sizeof(uh),
			    &h2, NULL, NULL)) {
d2732 2
a2733 2
pf_pull_hdr(struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *p,
    int len, struct ip *h, u_short *actionp, u_short *reasonp)
d2735 1
a2737 6
	/* sanity check */
	if (ipoff > off) {
		ACTION_SET(actionp, PF_DROP);
		REASON_SET(reasonp, PFRES_BADOFF);
		return (NULL);
	}
d2747 1
a2747 1
	if (m->m_pkthdr.len < off + len || ipoff + h->ip_len < off + len) {
d2805 1
a2805 2
		if (!pf_pull_hdr(ifp, m, 0, off, &th, sizeof(th), h,
		    &action, &reason)) {
d2821 1
a2821 2
		if (!pf_pull_hdr(ifp, m, 0, off, &uh, sizeof(uh), h,
		    &action, &reason)) {
d2837 1
a2837 2
		if (!pf_pull_hdr(ifp, m, 0, off, &ih, ICMP_MINLEN, h,
		    &action, &reason)) {
@


1.107
log
@Extend nat/rdr syntax. Add source/destination selection. Make
interface optional. Suggested by rdump@@river.com.

nat [on [!] <ifname>] from (any | [!] <addr>[/<mask>]) to (any |
    [!] <addr>[/<mask>]) -> <addr> [proto (tcp | udp | icmp)]

rdr [on [!] <ifname>] from (any | [!] <addr>[/<mask>]) to (any |
    [!] <addr>[/<mask>]) port <a>[:<b>] -> <addr> port <c>[:*]
    [proto (tcp | udp | icmp)]
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.106 2001/07/07 01:56:09 marc Exp $ */
d1380 3
@


1.106
log
@get rid of compiler warning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.105 2001/07/06 23:01:30 dhartmei Exp $ */
d179 2
a180 1
struct pf_nat		*pf_get_nat(struct ifnet *, u_int8_t, u_int32_t);
d182 1
a182 1
			    u_int16_t);
d801 2
a802 1
		}
d903 9
a911 6
		nat->ifp = ifunit(nat->ifname);
		if (nat->ifp == NULL) {
			pool_put(&pf_nat_pl, nat);
			error = EINVAL;
			break;
		}
d1007 9
a1015 6
		rdr->ifp = ifunit(rdr->ifname);
		if (rdr->ifp == NULL) {
			pool_put(&pf_rdr_pl, rdr);
			error = EINVAL;
			break;
		}
d1400 1
a1400 1
pf_get_nat(struct ifnet *ifp, u_int8_t proto, u_int32_t addr)
d1406 1
a1406 1
		if (((n->ifp == ifp && !n->ifnot) ||
d1409 2
a1410 1
		    pf_match_addr(n->not, n->saddr, n->smask, addr))
d1419 2
a1420 1
pf_get_rdr(struct ifnet *ifp, u_int8_t proto, u_int32_t addr, u_int16_t port)
d1426 1
a1426 1
		if (((r->ifp == ifp && !r->ifnot) ||
d1429 4
a1432 3
		    pf_match_addr(r->not, r->daddr, r->dmask, addr) &&
		    (ntohs(port) >= ntohs(r->dport)) && 
		    (ntohs(port) <= ntohs(r->dport2)))
d1481 1
a1481 1
		    h->ip_src.s_addr)) != NULL) {
d1485 1
a1485 1
			    &h->ip_sum, &th->th_sum, nat->daddr,
d1491 2
a1492 2
		if ((rdr = pf_get_rdr(ifp, IPPROTO_TCP, h->ip_dst.s_addr,
		    th->th_dport)) != NULL) {
d1635 2
a1636 2
		if ((nat = pf_get_nat(ifp, IPPROTO_UDP, h->ip_src.s_addr)) !=
		    NULL) {
d1640 1
a1640 1
			    &h->ip_sum, &uh->uh_sum, nat->daddr,
d1646 2
a1647 2
		if ((rdr = pf_get_rdr(ifp, IPPROTO_UDP, h->ip_dst.s_addr,
		    uh->uh_dport)) != NULL) {
d1778 2
a1779 2
		if ((nat = pf_get_nat(ifp, IPPROTO_ICMP, h->ip_src.s_addr)) !=
		    NULL) {
d1781 1
a1781 1
			pf_change_a(&h->ip_src.s_addr, &h->ip_sum, nat->daddr);
@


1.105
log
@style change #2, avoid (a == b) == c
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.104 2001/07/06 22:45:32 dhartmei Exp $ */
d1356 1
a1356 1
	if (a & m == b & m) {
@


1.104
log
@style change #1, avoid ternary operator
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.103 2001/07/06 22:22:45 chris Exp $ */
d1348 5
d1356 11
a1366 1
	return (n == !((a & m) == (b & m)));
@


1.103
log
@theo requests less archaic style
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.102 2001/07/06 22:09:00 dhartmei Exp $ */
a480 1
	/* go up to root, so the caller can pass any node. useful? */
d515 4
a518 1
		n = (c > 0) ? n->left : n->right;
d527 4
a530 1
	return (n ? n->state : NULL);
d788 4
a791 1
		rule->nr = tail ? tail->nr + 1 : 0;
d844 4
a847 1
		pr->nr = tail ? tail->nr + 1 : 0;
d1166 4
a1169 2
			st = pf_find_state((direction == PF_IN) ? 
			    tree_ext_gwy : tree_lan_ext, &key);
d1203 4
a1206 1
	return (l ? l : 65535);
d1307 5
a1311 3
		int tlen = h->ip_len - off - (th->th_off << 2) +
		    ((th->th_flags & TH_SYN) ? 1 : 0) +
		    ((th->th_flags & TH_FIN) ? 1 : 0);
d1568 5
a1572 3
		s->src.seqlo = ntohl(th->th_seq) + len +
		    ((th->th_flags & TH_SYN) ? 1 : 0) +
		    ((th->th_flags & TH_FIN) ? 1 : 0);
d1803 4
a1806 1
			s->lan.addr = nat ? baddr : s->gwy.addr;
d1870 1
a1870 2
	u_int32_t end = seq + len + ((th->th_flags & TH_SYN) ? 1 : 0) +
	    ((th->th_flags & TH_FIN) ? 1 : 0);
d1874 6
d1886 4
a1889 2
	*state = pf_find_state((direction == PF_IN) ? tree_ext_gwy :
	    tree_lan_ext, &key);
d2035 4
a2038 2
	(*state) = pf_find_state((direction == PF_IN) ? tree_ext_gwy :
	    tree_lan_ext, &key);
d2106 4
a2109 2
		*state = pf_find_state((direction == PF_IN) ? tree_ext_gwy :
		    tree_lan_ext, &key);
d2176 4
a2179 2
			*state = pf_find_state((direction == PF_IN) ?
			    tree_ext_gwy : tree_lan_ext, &key);
d2183 7
a2189 4
			src = (direction == (*state)->direction) ?
			    &(*state)->dst : &(*state)->src;
			dst = (direction == (*state)->direction) ?
			    &(*state)->src : &(*state)->dst;
d2243 4
a2246 2
			*state = pf_find_state(direction == PF_IN ?
			    tree_ext_gwy : tree_lan_ext, &key);
@


1.102
log
@don't evaluate rules for packets that have state but mismatch seq range (could create duplicate state)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.101 2001/07/06 21:19:55 chris Exp $ */
d1365 2
a1366 1
		if (((n->ifp == ifp) == !n->ifnot) &&
d1383 2
a1384 1
		if (((r->ifp == ifp) == !r->ifnot) &&
@


1.101
log
@Allow negative match on interface name for nat and rdr
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.100 2001/07/06 17:40:34 provos Exp $ */
d190 9
a198 6
struct pf_state		*pf_test_state_tcp(int, struct ifnet *, struct mbuf *,
			    int, int, struct ip *, struct tcphdr *);
struct pf_state		*pf_test_state_udp(int, struct ifnet *, struct mbuf *,
			    int, int, struct ip *, struct udphdr *);
struct pf_state		*pf_test_state_icmp(int, struct ifnet *, struct mbuf *,
			    int, int, struct ip *, struct icmp *);
d1569 1
a1726 1
	int rewrite = 0;
a1733 1
			rewrite++;
d1837 3
a1839 3
struct pf_state *
pf_test_state_tcp(int direction, struct ifnet *ifp, struct mbuf *m,
    int ipoff, int off, struct ip *h, struct tcphdr *th)
a1840 1
	struct pf_state *s;
d1842 7
a1848 1
	int rewrite = 0;
d1856 4
a1859 10
	s = pf_find_state((direction == PF_IN) ? tree_ext_gwy : tree_lan_ext,
	    &key);
	if (s != NULL) {
		u_int16_t len = h->ip_len - off - (th->th_off << 2);
		u_int16_t win = ntohs(th->th_win);
		u_int32_t seq = ntohl(th->th_seq), ack = ntohl(th->th_ack);
		u_int32_t end = seq + len + ((th->th_flags & TH_SYN) ? 1 : 0) +
		    ((th->th_flags & TH_FIN) ? 1 : 0);
		int ackskew;
		struct pf_state_peer *src, *dst;
d1861 7
a1867 7
		if (direction == s->direction) {
			src = &s->src;
			dst = &s->dst;
		} else {
			src = &s->dst;
			dst = &s->src;
		}
d1869 6
a1874 6
		if (src->seqlo == 0) {
			/* First packet from this end.  Set its state */
			src->seqlo = end;
			src->seqhi = end + 1;
			src->max_win = 1;
		}
d1876 8
a1883 8
		if ((th->th_flags & TH_ACK) == 0) {
			/* Let it pass through the ack skew check */
			ack = dst->seqlo;
		} else if (ack == 0 &&
			(th->th_flags & (TH_ACK|TH_RST)) == (TH_ACK|TH_RST)) {
			/* broken tcp stacks do not set ack */
			ack = dst->seqlo;
		}
d1885 5
a1889 5
		if (seq == end) {
			/* Ease sequencing restrictions on no data packets */
			seq = src->seqlo;
			end = seq;
		}
d1891 1
a1891 1
		ackskew = dst->seqlo - ack;
d1894 19
a1912 19
		if (SEQ_GEQ(src->seqhi, end) &&
		    /* Last octet inside other's window space */
		    SEQ_GEQ(seq, src->seqlo - dst->max_win) &&
		    /* Retrans: not more than one window back */
		    (ackskew >= -MAXACKWINDOW) &&
		    /* Acking not more than one window back */
		    (ackskew <= MAXACKWINDOW)) {
		    /* Acking not more than one window forward */

			if (ackskew < 0) {
				/* The sequencing algorithm is exteremely lossy
				 * when there is fragmentation since the full
				 * packet length can not be determined.  So we
				 * deduce how much data passed by what the
				 * other endpoint ACKs.  Thanks Guido!
				 * (Why MAXACKWINDOW is used)
				 */
				dst->seqlo = ack;
			}
d1914 12
a1925 2
			s->packets++;
			s->bytes += len;
a1926 26
			/* update max window */
			if (src->max_win < win)
				src->max_win = win;
			/* syncronize sequencing */
			if (SEQ_GT(end, src->seqlo))
				src->seqlo = end;
			/* slide the window of what the other end can send */
			if (SEQ_GEQ(ack + win, dst->seqhi))
				dst->seqhi = ack + MAX(win, 1);


			/* update states */
			if (th->th_flags & TH_SYN)
				if (src->state < 1)
					src->state = 1;
			if (th->th_flags & TH_FIN)
				if (src->state < 3)
					src->state = 3;
			if (th->th_flags & TH_ACK) {
				if (dst->state == 1)
					dst->state = 2;
				else if (dst->state == 3)
					dst->state = 4;
			}
			if (th->th_flags & TH_RST)
				src->state = dst->state = 5;
d1928 15
a1942 9
			/* update expire time */
			if (src->state >= 4 && dst->state >= 4)
				s->expire = pftv.tv_sec + 5;
			else if (src->state >= 3 || dst->state >= 3)
				s->expire = pftv.tv_sec + 300;
			else if (src->state < 2 || dst->state < 2)
				s->expire = pftv.tv_sec + 30;
			else
				s->expire = pftv.tv_sec + 24*60*60;
d1944 9
a1952 15
			/* translate source/destination address, if needed */
			if (s->lan.addr != s->gwy.addr ||
			    s->lan.port != s->gwy.port) {
				if (direction == PF_OUT)
					pf_change_ap(&h->ip_src.s_addr,
					    &th->th_sport, &h->ip_sum,
					    &th->th_sum, s->gwy.addr,
					    s->gwy.port);
				else
					pf_change_ap(&h->ip_dst.s_addr,
					    &th->th_dport, &h->ip_sum,
					    &th->th_sum, s->lan.addr,
					    s->lan.port);
				rewrite++;
			}
d1954 14
a1967 13
		} else {
			/* XXX Remove these printfs before release */
			printf("pf: BAD state: ");
			pf_print_state(direction, s);
			pf_print_flags(th->th_flags);
			printf(" seq=%lu ack=%lu len=%u ", seq, ack, len);
			printf("\n");
			printf("State failure: %c %c %c %c\n",
			    SEQ_GEQ(src->seqhi, end) ? ' ' : '1',
			    SEQ_GEQ(seq, src->seqlo - dst->max_win) ? ' ': '2',
			    (ackskew >= -MAXACKWINDOW) ? ' ' : '3',
			    (ackskew <= MAXACKWINDOW) ? ' ' : '4');
			s = NULL;
d1970 14
a1983 3
		/* copy back packet headers if we performed NAT operations */
		if (rewrite)
			m_copyback(m, off, sizeof(*th), (caddr_t)th);
d1985 1
a1985 1
		return (s);
a1986 1
	return (NULL);
d1989 3
a1991 3
struct pf_state *
pf_test_state_udp(int direction, struct ifnet *ifp, struct mbuf *m,
    int ipoff, int off, struct ip *h, struct udphdr *uh)
d1993 2
a1994 1
	struct pf_state *s;
a1995 1
	int rewrite = 0;
d2003 12
a2014 13
	s = pf_find_state((direction == PF_IN) ? tree_ext_gwy : tree_lan_ext,
	    &key);
	if (s != NULL) {
		u_int16_t len = h->ip_len - off - sizeof(*uh);

		struct pf_state_peer *src, *dst;
		if (direction == s->direction) {
			src = &s->src;
			dst = &s->dst;
		} else {
			src = &s->dst;
			dst = &s->src;
		}
d2016 2
a2017 2
		s->packets++;
		s->bytes += len;
d2019 11
a2029 5
		/* update states */
		if (src->state < 1)
			src->state = 1;
		if (dst->state == 1)
			dst->state = 2;
d2031 7
a2037 3
		/* update expire time */
		if (src->state == 2 && dst->state == 2)
			s->expire = pftv.tv_sec + 60;
d2039 5
a2043 1
			s->expire = pftv.tv_sec + 20;
d2045 1
a2045 21
		/* translate source/destination address, if necessary */
		if (s->lan.addr != s->gwy.addr ||
		    s->lan.port != s->gwy.port) {
			if (direction == PF_OUT)
				pf_change_ap(&h->ip_src.s_addr, &uh->uh_sport,
				    &h->ip_sum, &uh->uh_sum,
				    s->gwy.addr, s->gwy.port);
			else
				pf_change_ap(&h->ip_dst.s_addr, &uh->uh_dport,
				    &h->ip_sum, &uh->uh_sum,
				    s->lan.addr, s->lan.port);
			rewrite++;
		}

		/* copy back packet headers if we performed NAT operations */
		if (rewrite)
			m_copyback(m, off, sizeof(*uh), (caddr_t)uh);

		return (s);
	}
	return (NULL);
d2048 3
a2050 3
struct pf_state *
pf_test_state_icmp(int direction, struct ifnet *ifp, struct mbuf *m,
    int ipoff, int off, struct ip *h, struct icmp *ih)
a2052 1
	int rewrite = 0;
a2063 1
		struct pf_state *s;
d2072 1
a2072 1
		s = pf_find_state((direction == PF_IN) ? tree_ext_gwy :
d2074 6
a2079 14
		if (s != NULL) {
			s->packets++;
			s->bytes += len;
			s->expire = pftv.tv_sec + 10;

			/* translate source/destination address, if needed */
			if (s->lan.addr != s->gwy.addr) {
				if (direction == PF_OUT)
					pf_change_a(&h->ip_src.s_addr,
					    &h->ip_sum, s->gwy.addr);
				else
					pf_change_a(&h->ip_dst.s_addr,
					    &h->ip_sum, s->lan.addr);
			}
d2081 8
a2088 1
			return (s);
d2090 2
a2091 1
		return (NULL);
d2108 1
a2108 1
			return (NULL);
a2117 1
			struct pf_state *s;
d2130 1
a2130 1
				return (NULL);
d2140 4
a2143 4
			s = pf_find_state((direction == PF_IN) ? tree_ext_gwy :
			    tree_lan_ext, &key);
			if (s == NULL)
				return (NULL);
d2145 4
a2148 2
			src = (direction == s->direction) ?  &s->dst : &s->src;
			dst = (direction == s->direction) ?  &s->src : &s->dst;
d2154 1
a2154 1
				pf_print_state(direction, s);
d2156 1
a2156 1
				return (NULL);
d2159 2
a2160 2
			if (s->lan.addr != s->gwy.addr ||
			    s->lan.port != s->gwy.port) {
d2164 4
a2167 3
					    s->lan.addr, s->lan.port,
					    NULL, &h2.ip_sum,
					    &ih->icmp_cksum, &h->ip_sum);
d2171 4
a2174 3
					    s->gwy.addr, s->gwy.port,
					    NULL, &h2.ip_sum,
					    &ih->icmp_cksum, &h->ip_sum);
d2176 1
a2176 8
				rewrite++;
			}

			/*
			 * copy back packet headers if we performed NAT
			 * operations
			 */
			if (rewrite) {
d2183 1
a2183 1
			return (s);
a2187 1
			struct pf_state *s;
d2193 1
a2193 1
				return (NULL);
d2202 4
a2205 4
			s = pf_find_state(direction == PF_IN ? tree_ext_gwy :
			    tree_lan_ext, &key);
			if (s == NULL)
				return (NULL);
d2207 2
a2208 2
			if (s->lan.addr != s->gwy.addr ||
			    s->lan.port != s->gwy.port) {
d2212 4
a2215 3
					    s->lan.addr, s->lan.port,
					    &uh.uh_sum, &h2.ip_sum,
					    &ih->icmp_cksum, &h->ip_sum);
d2219 4
a2222 3
					    s->gwy.addr, s->gwy.port,
					    &uh.uh_sum, &h2.ip_sum,
					    &ih->icmp_cksum, &h->ip_sum);
d2224 1
a2224 8
				rewrite++;
			}

			/*
			 * copy back packet headers if we performed NAT
			 * operations
			 */
			if (rewrite) {
d2231 1
a2231 1
			return (s);
d2236 1
a2236 1
			return (NULL);
a2237 1
		return (NULL);
d2741 2
a2742 2
		if ((s = pf_test_state_tcp(dir, ifp, m, 0, off, h, &th))) {
			action = PF_PASS;
d2745 2
a2746 2
		} else
			action = pf_test_tcp(dir, ifp, m, 0, off, h, &th);
d2758 2
a2759 2
		if ((s = pf_test_state_udp(dir, ifp, m, 0, off, h, &uh))) {
			action = PF_PASS;
d2762 1
a2762 1
		} else
d2775 2
a2776 2
		if ((s = pf_test_state_icmp(dir, ifp, m, 0, off, h, &ih))) {
			action = PF_PASS;
d2779 1
a2779 1
		} else
@


1.100
log
@some cleanup, okay dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.99 2001/07/05 21:39:29 provos Exp $ */
d1362 1
a1362 1
		if (n->ifp == ifp &&
d1379 1
a1379 1
		if (r->ifp == ifp &&
@


1.99
log
@initalize fragment correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.98 2001/07/04 20:00:38 dhartmei Exp $ */
d202 1
a202 1
			    struct ip *, u_short *);
a2280 3
		DPFPRINTF((__FUNCTION__": %d,%d > %d,%d\n",
			   frag->fr_timeout.tv_sec, frag->fr_timeout.tv_usec,
			   expire.tv_sec, expire.tv_usec));
a2420 1
		DPFPRINTF((__FUNCTION__": insert new fragment\n"));
d2444 2
a2445 1
		m_adj(frent->fr_m, precut);
d2447 5
a2451 3
		/* We enforce 8 byte boundaries, ip_off not converted yet */
		off = ip->ip_off += precut;
		ip->ip_len -= precut;
d2459 1
d2499 3
a2501 1
		    (next == NULL || next->fr_ip->ip_off != off))
d2503 1
a2527 1
		DPFPRINTF((__FUNCTION__": frent %p\n", frent));
d2567 1
a2567 2
pf_normalize_ip(struct mbuf **m0, int dir, struct ifnet *ifp, struct ip *h,
    u_short *reason)
d2573 1
d2596 1
a2596 1
		return (PF_PASS);
d2643 1
a2643 1
	DPFPRINTF((__FUNCTION__": reass frag @@ %d\n", fragoff));
d2646 10
a2655 1
	return (m == NULL ? PF_DROP : PF_PASS);
d2670 1
a2744 2
	h = mtod(m, struct ip *);

d2746 1
a2746 1
	if (pf_normalize_ip(m0, dir, ifp, h, &reason) != PF_PASS) {
@


1.98
log
@call ip_output() correctly, use ICMP_MINLEN, only m_copyback() where needed. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.97 2001/07/03 04:20:47 deraadt Exp $ */
d2411 1
@


1.97
log
@grr, you guys keep not obeying KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.96 2001/07/03 03:34:41 beck Exp $ */
d318 1
a318 1
		if (*n == NULL) {
a319 1
		}
d1276 1
a1276 1
	h2->ip_len = htons(sizeof(struct tcphdr));
d1301 1
a1301 2
	h2->ip_hl = sizeof(struct ip) >> 2;
	h2->ip_len = htons(len);
d1304 3
a1306 4

	/* IP header checksum */
	h2->ip_sum = in_cksum(m, sizeof(struct ip));
	ip_output(m, NULL, NULL, 0, NULL);
d1656 1
a1656 1
		len = h->ip_len - off - 8;
d1764 1
a1764 1
		len = h->ip_len - off - 8;
d1767 1
a1767 1
		if (s == NULL) {
d1769 1
a1769 1
		}
a1803 4
	/* copy back packet headers if we performed NAT operations */
	if (rewrite)
		m_copyback(m, off, sizeof(*ih), (caddr_t)ih);

d2010 1
a2010 1
		u_int16_t len = h->ip_len - off - 8;
d2117 1
a2117 1
		ipoff2 = off + 8;	/* offset of h2 in mbuf chain */
a2193 1
				m_copyback(m, off, sizeof(*ih), (caddr_t)ih);
a2247 1
				m_copyback(m, off, sizeof(*ih), (caddr_t)ih);
d2783 1
a2783 1
		if (!pf_pull_hdr(ifp, m, 0, off, &ih, sizeof(ih), h,
a2801 1
done:
d2806 2
@


1.96
log
@add DIOCNATLOOK ioctl and pf_natlook structure, this enables a userland
process recieving rdr'ed connections to look up the original destination
of the connection before it was redirected - this enables the writing
of transparent proxies.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.95 2001/07/02 19:19:49 provos Exp $ */
d124 7
a130 7
u_int32_t		 pf_last_purge = 0;
u_int32_t		 ticket_rules_active = 0;
u_int32_t		 ticket_rules_inactive = 0;
u_int32_t		 ticket_nats_active = 0;
u_int32_t		 ticket_nats_inactive = 0;
u_int32_t		 ticket_rdrs_active = 0;
u_int32_t		 ticket_rdrs_inactive = 0;
d134 2
a135 7
struct pool		 pf_tree_pl;
struct pool		 pf_rule_pl;
struct pool		 pf_nat_pl;
struct pool		 pf_rdr_pl;
struct pool		 pf_state_pl;
struct pool		 pf_frent_pl;
struct pool		 pf_frag_pl;
a137 4
/*
 * Prototypes
 */

d145 1
a145 1
int		 	 pf_tree_remove(struct pf_tree_node **,
d247 1
a247 1
	if (a->proto   < b->proto  )
d249 1
a249 1
	if (a->proto   > b->proto  )
d438 3
a440 3
        struct ifnet *ifn, *ifp = NULL;
        struct pfloghdr hdr;
        struct mbuf m1;
d445 1
a445 1
        hdr.af = htonl(af);
d461 3
a463 3
        m1.m_next = m;
        m1.m_len = PFLOG_HDRLEN;
        m1.m_data = (char *) &hdr;
d467 1
a467 1
        if (ifn->if_bpf)
d545 1
a545 1
	key.proto   = state->proto;
a556 1

d654 14
a667 14
        pool_init(&pf_tree_pl, sizeof(struct pf_tree_node), 0, 0, 0, "pftrpl",
                0, NULL, NULL, 0);
        pool_init(&pf_rule_pl, sizeof(struct pf_rule), 0, 0, 0, "pfrulepl",
                0, NULL, NULL, 0);
        pool_init(&pf_nat_pl, sizeof(struct pf_nat), 0, 0, 0, "pfnatpl",
                0, NULL, NULL, 0);
        pool_init(&pf_rdr_pl, sizeof(struct pf_rdr), 0, 0, 0, "pfrdrpl",
                0, NULL, NULL, 0);
        pool_init(&pf_state_pl, sizeof(struct pf_state), 0, 0, 0, "pfstatepl",
                0, NULL, NULL, 0);
        pool_init(&pf_frent_pl, sizeof(struct pf_frent), 0, 0, 0, "pffrent",
                0, NULL, NULL, 0);
        pool_init(&pf_frag_pl, sizeof(struct pf_fragment), 0, 0, 0, "pffrag",
                0, NULL, NULL, 0);
d1124 1
d1134 3
a1136 4
		int direction;
		
		direction   = pnl->direction;
		key.proto   = pnl->proto;
d1138 2
a1139 1
		/* userland gives us source and dest of connetion, reverse
d1148 2
a1149 2
		if (!pnl->proto || !pnl->saddr || !pnl->daddr 
		    || !pnl->dport || !pnl->sport)
d1154 1
a1154 1
					   tree_ext_gwy : tree_lan_ext, &key);
d1161 1
a1161 2
				}
				else {
d1185 1
d1197 1
d1211 1
d1223 3
a1225 1
	if (pc != NULL) opc = *pc;
d1228 2
a1229 1
	if (pc != NULL) *pc = pf_cksum_fixup(*pc, oip, *ip);
d1231 2
a1232 1
	if (pc != NULL) *ic = pf_cksum_fixup(*ic, opc, *pc);
a1308 1

d1455 1
a1455 2
			     &h->ip_sum, &th->th_sum, rdr->raddr, nport);
					     
d1489 1
a1489 2
			}
			else if (rdr != NULL) {
d1513 1
a1513 1
		if (s == NULL) {
d1515 5
a1519 5
		}
		s->rule		= rm;
		s->log		= rm && (rm->log & 2);
		s->proto	= IPPROTO_TCP;
		s->direction	= direction;
d1521 4
a1524 4
			s->gwy.addr	= h->ip_src.s_addr;
			s->gwy.port	= th->th_sport;
			s->ext.addr	= h->ip_dst.s_addr;
			s->ext.port	= th->th_dport;
d1526 2
a1527 2
				s->lan.addr	= baddr;
				s->lan.port	= bport;
d1532 2
a1533 2
				s->lan.addr	= s->gwy.addr;
				s->lan.port	= s->gwy.port;
d1536 4
a1539 4
			s->lan.addr	= h->ip_dst.s_addr;
			s->lan.port	= th->th_dport;
			s->ext.addr	= h->ip_src.s_addr;
			s->ext.port	= th->th_sport;
d1541 2
a1542 2
				s->gwy.addr	= baddr;
				s->gwy.port	= bport;
d1544 2
a1545 2
				s->gwy.addr	= s->lan.addr;
				s->gwy.port	= s->lan.port;
d1548 15
a1562 15
		s->src.seqlo	= ntohl(th->th_seq) + len +
			((th->th_flags & TH_SYN) ? 1 : 0) +
			((th->th_flags & TH_FIN) ? 1 : 0);
		s->src.seqhi	= s->src.seqlo + 1;
		s->src.max_win	= MAX(ntohs(th->th_win), 1);

		s->dst.seqlo	= 0;	/* Haven't seen these yet */
		s->dst.seqhi	= 1;
		s->dst.max_win	= 1;
		s->src.state	= 1;
		s->dst.state	= 0;
		s->creation	= pftv.tv_sec;
		s->expire	= pftv.tv_sec + 60;
		s->packets	= 1;
		s->bytes	= len;
a1568 1

d1641 1
a1641 2
			}
			else if (rdr != NULL) {
d1661 1
a1661 1
		if (s == NULL) {
d1663 5
a1667 5
		}
		s->rule		= rm;
		s->log		= rm && (rm->log & 2);
		s->proto	= IPPROTO_UDP;
		s->direction	= direction;
d1669 4
a1672 4
			s->gwy.addr	= h->ip_src.s_addr;
			s->gwy.port	= uh->uh_sport;
			s->ext.addr	= h->ip_dst.s_addr;
			s->ext.port	= uh->uh_dport;
d1674 2
a1675 2
				s->lan.addr	= baddr;
				s->lan.port	= bport;
d1680 2
a1681 2
				s->lan.addr	= s->gwy.addr;
				s->lan.port	= s->gwy.port;
d1684 4
a1687 4
			s->lan.addr	= h->ip_dst.s_addr;
			s->lan.port	= uh->uh_dport;
			s->ext.addr	= h->ip_src.s_addr;
			s->ext.port	= uh->uh_sport;
d1689 2
a1690 2
				s->gwy.addr	= baddr;
				s->gwy.port	= bport;
d1692 2
a1693 2
				s->gwy.addr	= s->lan.addr;
				s->gwy.port	= s->lan.port;
d1696 12
a1707 12
		s->src.seqlo 	= 0;
		s->src.seqhi	= 0;
		s->src.max_win	= 0;
		s->src.state	= 1;
		s->dst.seqlo	= 0;
		s->dst.seqhi	= 0;
		s->dst.max_win	= 0;
		s->dst.state	= 0;
		s->creation	= pftv.tv_sec;
		s->expire	= pftv.tv_sec + 30;
		s->packets	= 1;
		s->bytes	= len;
d1773 4
a1776 4
		s->rule		= rm;
		s->log		= rm && (rm->log & 2);
		s->proto	= IPPROTO_ICMP;
		s->direction	= direction;
d1778 6
a1783 6
			s->gwy.addr	= h->ip_src.s_addr;
			s->gwy.port	= id;
			s->ext.addr	= h->ip_dst.s_addr;
			s->ext.port	= id;
			s->lan.addr	= nat ? baddr : s->gwy.addr;
			s->lan.port	= id;
d1785 19
a1803 19
			s->lan.addr	= h->ip_dst.s_addr;
			s->lan.port	= id;
			s->ext.addr	= h->ip_src.s_addr;
			s->ext.port	= id;
			s->gwy.addr	= s->lan.addr;
			s->gwy.port	= id;
		}
		s->src.seqlo	= 0;
		s->src.seqhi	= 0;
		s->src.max_win	= 0;
		s->src.state	= 0;
		s->dst.seqlo	= 0;
		s->dst.seqhi	= 0;
		s->dst.max_win	= 0;
		s->dst.state	= 0;
		s->creation	= pftv.tv_sec;
		s->expire	= pftv.tv_sec + 20;
		s->packets	= 1;
		s->bytes	= len;
d2126 1
a2126 1
			      NULL, NULL)) {
d2759 1
a2759 1
		      &action, &reason)) {
d2776 1
a2776 1
		      &action, &reason)) {
d2793 1
a2793 1
		      &action, &reason)) {
@


1.95
log
@another memory leak
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.94 2001/07/02 19:18:40 provos Exp $ */
d1139 44
a1182 1

@


1.95.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.95 2001/07/02 19:19:49 provos Exp $ */
d4 1
a4 1
 * Copyright (c) 2001 Daniel Hartmeier
d48 1
a56 1
#include <netinet/tcp_fsm.h>
a60 3
#include <dev/rndvar.h>
#include <net/pfvar.h>

d64 2
a65 8
#ifdef INET6
#include <netinet/ip6.h>
#include <netinet/in_pcb.h>
#include <netinet/icmp6.h>
#endif /* INET6 */


#define DPFPRINTF(n, x)	if (pf_status.debug >= (n)) printf x
d72 5
a76 1
	struct pf_tree_key	 key;
d81 1
a81 1
	int			 balance;
d84 4
a87 3
struct pf_port_node {
	LIST_ENTRY(pf_port_node)	next;
	u_int16_t			port;
a88 1
LIST_HEAD(pf_port_list, pf_port_node);
d90 12
a101 7
/* structure for ipsec and ipv6 option header template */
struct _opt6 {
	u_int8_t	opt6_nxt;	/* next header */
	u_int8_t	opt6_hlen;	/* header extension length */
	u_int16_t       _pad;
	u_int32_t       ah_spi;		/* security parameter index
					   for authentication header */
d108 2
a110 1
TAILQ_HEAD(pf_binatqueue, pf_binat)	pf_binats[2];
a111 1
struct pf_rulequeue	 pf_rules[2];
a115 2
struct pf_binatqueue	*pf_binats_active;
struct pf_binatqueue	*pf_binats_inactive;
d119 1
d124 18
a141 38
u_int32_t		 pf_last_purge;
u_int32_t		 ticket_rules_active;
u_int32_t		 ticket_rules_inactive;
u_int32_t		 ticket_nats_active;
u_int32_t		 ticket_nats_inactive;
u_int32_t		 ticket_binats_active;
u_int32_t		 ticket_binats_inactive;
u_int32_t		 ticket_rdrs_active;
u_int32_t		 ticket_rdrs_inactive;
struct pf_port_list	 pf_tcp_ports;
struct pf_port_list	 pf_udp_ports;

/* Timeouts */
int			 pftm_tcp_first_packet = 120;	/* First TCP packet */
int			 pftm_tcp_opening = 30;		/* No response yet */
int			 pftm_tcp_established = 24*60*60;  /* established  */
int			 pftm_tcp_closing = 15 * 60;	/* Half closed */
int			 pftm_tcp_fin_wait = 45;	/* Got both FINs */
int			 pftm_tcp_closed = 90;		/* Got a RST */

int			 pftm_udp_first_packet = 60;	/* First UDP packet */
int			 pftm_udp_single = 30;		/* Unidirectional */
int			 pftm_udp_multiple = 60;	/* Bidirectional */

int			 pftm_icmp_first_packet = 20;	/* First ICMP packet */
int			 pftm_icmp_error_reply = 10;	/* Got error response */

int			 pftm_frag = 30;		/* Fragment expire */

int			 pftm_interval = 10;		/* expire interval */

int			*pftm_timeouts[PFTM_MAX] = { &pftm_tcp_first_packet,
				&pftm_tcp_opening, &pftm_tcp_established,
				&pftm_tcp_closing, &pftm_tcp_fin_wait,
				&pftm_tcp_closed, &pftm_udp_first_packet,
				&pftm_udp_single, &pftm_udp_multiple,
				&pftm_icmp_first_packet, &pftm_icmp_error_reply,
				&pftm_frag, &pftm_interval };
d143 3
a145 3

struct pool		 pf_tree_pl, pf_rule_pl, pf_nat_pl, pf_sport_pl;
struct pool		 pf_rdr_pl, pf_state_pl, pf_binat_pl;
a148 10
int			 pf_compare_addr(struct pf_addr *, struct pf_addr *,
			    u_int8_t);
void			 pf_addrcpy(struct pf_addr *, struct pf_addr *,
			    u_int8_t);
int			 pf_compare_rules(struct pf_rule *,
			    struct pf_rule *);
int			 pf_compare_nats(struct pf_nat *, struct pf_nat *);
int			 pf_compare_binats(struct pf_binat *, 
			    struct pf_binat *);
int			 pf_compare_rdrs(struct pf_rdr *, struct pf_rdr *);
d151 5
d160 2
d165 2
a166 2
void			 pf_print_host(struct pf_addr *, u_int16_t, u_int8_t);
void			 pf_print_state(struct pf_state *);
d174 13
a186 18
u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t,
			    u_int8_t);
void			 pf_change_ap(struct pf_addr *, u_int16_t *,
			    u_int16_t *, u_int16_t *, struct pf_addr *,
			    u_int16_t, u_int8_t, int);
void			 pf_change_a(u_int32_t *, u_int16_t *, u_int32_t,
			    u_int8_t);
#ifdef INET6
void			 pf_change_a6(struct pf_addr *, u_int16_t *,
			    struct pf_addr *, u_int8_t);
#endif /* INET6 */
void			 pf_change_icmp(struct pf_addr *, u_int16_t *,
			    struct pf_addr *, struct pf_addr *, u_int16_t,
			    u_int16_t *, u_int16_t *, u_int16_t *,
			    u_int16_t *, u_int8_t, int);
void			 pf_send_reset(int, struct tcphdr *,
			    struct pf_pdesc *, int);
void			 pf_send_icmp(struct mbuf *, u_int8_t, u_int8_t, int);
d188 21
a208 34
struct pf_nat		*pf_get_nat(struct ifnet *, u_int8_t,
			    struct pf_addr *, struct pf_addr *, int);
struct pf_binat		*pf_get_binat(int, struct ifnet *, u_int8_t,
			    struct pf_addr *, struct pf_addr *, int);
struct pf_rdr		*pf_get_rdr(struct ifnet *, u_int8_t,
			    struct pf_addr *, struct pf_addr *, u_int16_t, int);
int			 pf_test_tcp(struct pf_rule **, int, struct ifnet *,
			    struct mbuf *, int, int, void *, struct pf_pdesc *);
int			 pf_test_udp(struct pf_rule **, int, struct ifnet *,
			    struct mbuf *, int, int, void *, struct pf_pdesc *);
int			 pf_test_icmp(struct pf_rule **, int, struct ifnet *,
			    struct mbuf *, int, int, void *, struct pf_pdesc *);
int			 pf_test_other(struct pf_rule **, int, struct ifnet *,
			    struct mbuf *, void *, struct pf_pdesc *);
int			 pf_test_state_tcp(struct pf_state **, int,
			    struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *);
int			 pf_test_state_udp(struct pf_state **, int,
			    struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *);
int			 pf_test_state_icmp(struct pf_state **, int,
			    struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *);
void			*pf_pull_hdr(struct mbuf *, int, void *, int,
			    u_short *, u_short *, int);
void			 pf_calc_skip_steps(struct pf_rulequeue *);

int			 pf_get_sport(u_int8_t, u_int16_t, u_int16_t,
			    u_int16_t *);
void			 pf_put_sport(u_int8_t, u_int16_t);
int			 pf_add_sport(struct pf_port_list *, u_int16_t);
int			 pf_chk_sport(struct pf_port_list *, u_int16_t);
int			 pf_normalize_tcp(int, struct ifnet *, struct mbuf *,
			     int, int, void *, struct pf_pdesc *);
d210 11
d223 8
a230 12
#define	PFLOG_PACKET(i,x,a,b,c,d,e) \
	do { \
		if (b == AF_INET) { \
			HTONS(((struct ip *)x)->ip_len); \
			HTONS(((struct ip *)x)->ip_off); \
			pflog_packet(i,a,b,c,d,e); \
			NTOHS(((struct ip *)x)->ip_len); \
			NTOHS(((struct ip *)x)->ip_off); \
		} else { \
			pflog_packet(i,a,b,c,d,e); \
		} \
	} while (0)
d232 1
a232 1
#define	PFLOG_PACKET(i,x,a,b,c,d,e)	((void)0)
d235 13
a247 7
#define	STATE_TRANSLATE(s) \
	(s)->lan.addr.addr32[0] != (s)->gwy.addr.addr32[0] || \
	((s)->af == AF_INET6 && \
	((s)->lan.addr.addr32[1] != (s)->gwy.addr.addr32[1] || \
	(s)->lan.addr.addr32[2] != (s)->gwy.addr.addr32[2] || \
	(s)->lan.addr.addr32[3] != (s)->gwy.addr.addr32[3])) || \
	(s)->lan.port != (s)->gwy.port
a251 2
	register int diff;

d256 20
a275 180
	if ((diff = a->proto - b->proto) != 0)
		return (diff);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
			return 1;
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
			return -1;
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
			return 1;
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
			return -1;
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
			return 1;
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
			return -1;
		if (a->addr[0].addr32[1] > b->addr[0].addr32[1])
			return 1;
		if (a->addr[0].addr32[1] < b->addr[0].addr32[1])
			return -1;
		if (a->addr[0].addr32[2] > b->addr[0].addr32[2])
			return 1;
		if (a->addr[0].addr32[2] < b->addr[0].addr32[2])
			return -1;
		if (a->addr[0].addr32[3] > b->addr[0].addr32[3])
			return 1;
		if (a->addr[0].addr32[3] < b->addr[0].addr32[3])
			return -1;
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
			return 1;
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
			return -1;
		if (a->addr[1].addr32[1] > b->addr[1].addr32[1])
			return 1;
		if (a->addr[1].addr32[1] < b->addr[1].addr32[1])
			return -1;
		if (a->addr[1].addr32[2] > b->addr[1].addr32[2])
			return 1;
		if (a->addr[1].addr32[2] < b->addr[1].addr32[2])
			return -1;
		if (a->addr[1].addr32[3] > b->addr[1].addr32[3])
			return 1;
		if (a->addr[1].addr32[3] < b->addr[1].addr32[3])
			return -1;
		break;
#endif /* INET6 */
	}
	
	if ((diff = a->port[0] - b->port[0]) != 0)
		return (diff);
	if ((diff = a->port[1] - b->port[1]) != 0)
		return (diff);

	return (0);
}

#ifdef INET6
void
pf_addrcpy(struct pf_addr *dst, struct pf_addr *src, u_int8_t af)
{
	switch(af) {
#ifdef INET
	case AF_INET:
		dst->addr32[0] = src->addr32[0];
		break;
#endif /* INET */
	case AF_INET6:
		dst->addr32[0] = src->addr32[0];
		dst->addr32[1] = src->addr32[1];
		dst->addr32[2] = src->addr32[2];
		dst->addr32[3] = src->addr32[3];
		break;
	} 
}
#endif

int
pf_compare_rules(struct pf_rule *a, struct pf_rule *b)
{
	if (a->return_icmp != b->return_icmp ||
	    a->action != b->action ||
	    a->direction != b->direction ||
	    a->log != b->log ||
	    a->quick != b->quick ||
	    a->keep_state != b->keep_state ||
	    a->af != b->af ||
	    a->proto != b->proto ||
	    a->type != b->type ||
	    a->code != b->code ||
	    a->flags != b->flags ||
	    a->flagset != b->flagset ||
	    a->rule_flag != b->rule_flag ||
	    a->min_ttl != b->min_ttl ||
	    a->allow_opts != b->allow_opts)
		return (1);
	if (memcmp(&a->src, &b->src, sizeof(struct pf_rule_addr)))
		return (1);
	if (memcmp(&a->dst, &b->dst, sizeof(struct pf_rule_addr)))
		return (1);
	if (strcmp(a->ifname, b->ifname))
		return (1);
	return (0);
}

int
pf_compare_nats(struct pf_nat *a, struct pf_nat *b)
{
	if (a->proto != b->proto ||
	    a->af != b->af ||
	    a->snot != b->snot ||
	    a->dnot != b->dnot ||
	    a->ifnot != b->ifnot)
		return (1);
	if (PF_ANEQ(&a->saddr, &b->saddr, a->af))
		return (1);
	if (PF_ANEQ(&a->smask, &b->smask, a->af))
		return (1);
	if (PF_ANEQ(&a->daddr, &b->daddr, a->af))
		return (1);
	if (PF_ANEQ(&a->dmask, &b->dmask, a->af))
		return (1);
	if (PF_ANEQ(&a->raddr, &b->raddr, a->af))
		return (1);
	if (strcmp(a->ifname, b->ifname))
		return (1);
	return (0);
}

int
pf_compare_binats(struct pf_binat *a, struct pf_binat *b)
{
	if (PF_ANEQ(&a->saddr, &b->saddr, a->af))
		return (1);
	if (PF_ANEQ(&a->daddr, &b->daddr, a->af))
		return (1);
	if (PF_ANEQ(&a->dmask, &b->dmask, a->af))
		return (1);
	if (PF_ANEQ(&a->raddr, &b->raddr, a->af))
		return (1);
	if (a->proto != b->proto ||
	    a->dnot != b->dnot ||
	    a->af != b->af)
		return (1);
	if (strcmp(a->ifname, b->ifname))
		return (1);
	return (0);
}

int
pf_compare_rdrs(struct pf_rdr *a, struct pf_rdr *b)
{
	if (a->dport != b->dport ||
	    a->dport2 != b->dport2 ||
	    a->rport != b->rport ||
	    a->proto != b->proto ||
	    a->af != b->af ||
	    a->snot != b->snot ||
	    a->dnot != b->dnot ||
	    a->ifnot != b->ifnot ||
	    a->opts != b->opts)
		return (1);
	if (PF_ANEQ(&a->saddr, &b->saddr, a->af))
		return (1);
	if (PF_ANEQ(&a->smask, &b->smask, a->af))
		return (1);
	if (PF_ANEQ(&a->daddr, &b->daddr, a->af))
		return (1);
	if (PF_ANEQ(&a->dmask, &b->dmask, a->af))
		return (1);
	if (PF_ANEQ(&a->raddr, &b->raddr, a->af))
		return (1);
	if (strcmp(a->ifname, b->ifname))
		return (1);
d327 1
a327 1
		if (*n == NULL)
d329 1
d443 2
a444 2
pflog_packet(struct ifnet *ifp, struct mbuf *m, int af, u_short dir,
    u_short reason, struct pf_rule *rm)
d447 17
a463 9
	struct ifnet *ifn;
	struct pfloghdr hdr;
	struct mbuf m1;

	if (ifp == NULL || m == NULL || rm == NULL)
		return (-1);

	hdr.af = htonl(af);
	memcpy(hdr.ifname, ifp->if_xname, sizeof(hdr.ifname));
d470 3
a472 3
	m1.m_next = m;
	m1.m_len = PFLOG_HDRLEN;
	m1.m_data = (char *) &hdr;
d476 1
a476 1
	if (ifn->if_bpf)
d488 1
d523 1
a523 4
		if (c > 0)
			n = n->left;
		else
			n = n->right;
d532 1
a532 4
	if (n)
		return (n->state);
	else
		return (NULL);
a538 1
	struct pf_state *s;
a539 1
	key.af = state->af;
d541 1
a541 1
	PF_ACPY(&key.addr[0], &state->lan.addr, state->af);
d543 1
a543 1
	PF_ACPY(&key.addr[1], &state->ext.addr, state->af);
d546 3
a548 13
	if ((s = pf_find_state(tree_lan_ext, &key)) != NULL) {
		if (pf_status.debug >= PF_DEBUG_URGENT) {
			printf("pf: ERROR! insert invalid\n");
			printf("    key already in tree_lan_ext\n");
			printf("    key: proto = %u, lan = ", state->proto);
			pf_print_host(&key.addr[0], key.port[0], key.af);
			printf(", ext = ");
			pf_print_host(&key.addr[1], key.port[1], key.af);
			printf("\n    state: ");
			pf_print_state(s);
			printf("\n");
		}
	} else {
d551 1
a551 2
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf: ERROR! insert failed\n"));
d554 2
a555 3
	key.af = state->af;
	key.proto = state->proto;
	PF_ACPY(&key.addr[0], &state->ext.addr, state->af);
d557 1
a557 1
	PF_ACPY(&key.addr[1], &state->gwy.addr, state->af);
d559 3
a561 13
	if ((s = pf_find_state(tree_ext_gwy, &key)) != NULL) {
		if (pf_status.debug >= PF_DEBUG_URGENT) {
			printf("pf: ERROR! insert invalid\n");
			printf("    key already in tree_ext_gwy\n");
			printf("    key: proto = %u, ext = ", state->proto);
			pf_print_host(&key.addr[0], key.port[0], key.af);
			printf(", gwy = ");
			pf_print_host(&key.addr[1], key.port[1], key.af);
			printf("\n    state: ");
			pf_print_state(s);
			printf("\n");
		}
	} else {
d564 1
a564 2
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf: ERROR! insert failed\n"));
d566 1
a579 1
			key.af = cur->state->af;
d581 1
a581 2
			PF_ACPY(&key.addr[0], &cur->state->lan.addr,
			    cur->state->af);
d583 1
a583 2
			PF_ACPY(&key.addr[1], &cur->state->ext.addr,
			    cur->state->af);
d587 1
a587 2
				DPFPRINTF(PF_DEBUG_URGENT,
				    ("pf: ERROR: remove invalid!\n"));
d590 1
a590 5
				DPFPRINTF(PF_DEBUG_URGENT,
				    ("pf: ERROR: remove failed\n"));
			if (STATE_TRANSLATE(cur->state))
				pf_put_sport(cur->state->proto,
					htons(cur->state->gwy.port));
d604 2
a605 2
					DPFPRINTF(PF_DEBUG_URGENT,
					    ("pf: ERROR: next not found\n"));
d618 1
a618 1
pf_print_host(struct pf_addr *addr, u_int16_t p, u_int8_t af)
d620 4
a623 54
	switch(af) {
#ifdef INET
	case AF_INET: {
		u_int32_t a = ntohl(addr->addr32[0]);
		p = ntohs(p);
		printf("%u.%u.%u.%u:%u", (a>>24)&255, (a>>16)&255,
		    (a>>8)&255, a&255, p);
		break;
	} 
#endif /* INET */
#ifdef INET6
	case AF_INET6: {
		u_int16_t b;
		u_int8_t i, curstart = 255, curend = 0,
		    maxstart = 0, maxend = 0;
		for (i = 0; i < 8; i++) {
			if (!addr->addr16[i]) {
				if (curstart == 255)
					curstart = i;
				else
					curend = i;
			} else {
				if (curstart) {
					if ((curend - curstart) >
					    (maxend - maxstart)) {
						maxstart = curstart;
						maxend = curend;
						curstart = 255;
					}
				}
			}
		}
		for (i = 0; i < 8; i++) {
			if (i >= maxstart && i <= maxend) {
				if (maxend != 7) {
					if (i == maxstart) 
						printf(":");
				} else {
					if (i == maxend)
						printf(":");
				}
			} else {
				b = ntohs(addr->addr16[i]);
				printf("%x", b);
				if (i < 7)
					printf(":");
			}
		}
		p = ntohs(p);
		printf("[%u]", p);
		break;
	}
#endif /* INET6 */
	}
d627 1
a627 1
pf_print_state(struct pf_state *s)
d629 1
a629 15
	switch (s->proto) {
	case IPPROTO_TCP:
		printf("TCP ");
		break;
	case IPPROTO_UDP:
		printf("UDP ");
		break;
	case IPPROTO_ICMP:
		printf("ICMP ");
		break;
	default:
		printf("%u ", s->proto);
		break;
	}
	pf_print_host(&s->lan.addr, s->lan.port, s->af);
d631 1
a631 1
	pf_print_host(&s->gwy.addr, s->gwy.port, s->af);
d633 5
a637 5
	pf_print_host(&s->ext.addr, s->ext.port, s->af);
	printf(" [lo=%lu high=%lu win=%u modulator=%u]", s->src.seqlo,
	    s->src.seqhi, s->src.max_win, s->src.seqdiff);
	printf(" [lo=%lu high=%lu win=%u modulator=%u]", s->dst.seqlo,
	    s->dst.seqhi, s->dst.max_win, s->dst.seqdiff);
d664 14
a677 14
	pool_init(&pf_tree_pl, sizeof(struct pf_tree_node), 0, 0, 0, "pftrpl",
	    0, NULL, NULL, 0);
	pool_init(&pf_rule_pl, sizeof(struct pf_rule), 0, 0, 0, "pfrulepl",
	    0, NULL, NULL, 0);
	pool_init(&pf_nat_pl, sizeof(struct pf_nat), 0, 0, 0, "pfnatpl",
	    0, NULL, NULL, 0);
	pool_init(&pf_binat_pl, sizeof(struct pf_binat), 0, 0, 0, "pfbinatpl",
	    0, NULL, NULL, 0);
	pool_init(&pf_rdr_pl, sizeof(struct pf_rdr), 0, 0, 0, "pfrdrpl",
	    0, NULL, NULL, 0);
	pool_init(&pf_state_pl, sizeof(struct pf_state), 0, 0, 0, "pfstatepl",
	    0, NULL, NULL, 0);
	pool_init(&pf_sport_pl, sizeof(struct pf_port_node), 0, 0, 0, "pfsport",
	    0, NULL, NULL, 0);
d679 4
a686 2
	TAILQ_INIT(&pf_binats[0]);
	TAILQ_INIT(&pf_binats[1]);
a692 2
	pf_binats_active = &pf_binats[0];
	pf_binats_inactive = &pf_binats[1];
a694 5

	LIST_INIT(&pf_tcp_ports);
	LIST_INIT(&pf_udp_ports);

	pf_normalize_init();
a731 3
		case DIOCBEGINBINATS:
		case DIOCADDBINAT:
		case DIOCCOMMITBINATS:
a735 4
		case DIOCCHANGERULE:
		case DIOCCHANGENAT:
		case DIOCCHANGERDR:
		case DIOCSETTIMEOUT:
d751 1
a751 1
			DPFPRINTF(PF_DEBUG_MISC, ("pf: started\n"));
d760 1
a760 1
			DPFPRINTF(PF_DEBUG_MISC, ("pf: stopped\n"));
a789 14
#ifndef INET
		if (rule->af == AF_INET) {
			pool_put(&pf_rule_pl, rule);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (rule->af == AF_INET6) {
			pool_put(&pf_rule_pl, rule);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
d791 1
a791 4
		if (tail)
			rule->nr = tail->nr + 1;
		else
			rule->nr = 0;
d800 1
a800 3
		} else
			rule->ifp = NULL;
		rule->evaluations = rule->packets = rule->bytes = 0;
a827 1
		pf_calc_skip_steps(pf_rules_active);
d844 1
a844 4
		if (tail)
			pr->nr = tail->nr + 1;
		else
			pr->nr = 0;
a871 94
	case DIOCCHANGERULE: {
		struct pfioc_changerule *pcr = (struct pfioc_changerule *)addr;
		struct pf_rule *oldrule = NULL, *newrule = NULL;
		u_int32_t nr = 0;

		if (pcr->action < PF_CHANGE_ADD_HEAD ||
		    pcr->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcr->action != PF_CHANGE_REMOVE) {
			newrule = pool_get(&pf_rule_pl, PR_NOWAIT);
			if (newrule == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcr->newrule, newrule, sizeof(struct pf_rule));
#ifndef INET
			if (newrule->af == AF_INET) {
				pool_put(&pf_rule_pl, newrule);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newrule->af == AF_INET6) {
				pool_put(&pf_rule_pl, newrule);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			newrule->ifp = NULL;
			if (newrule->ifname[0]) {
				newrule->ifp = ifunit(newrule->ifname);
				if (newrule->ifp == NULL) {
					pool_put(&pf_rule_pl, newrule);
					error = EINVAL;
					break;
				}
			}
			newrule->evaluations = newrule->packets = 0;
			newrule->bytes = 0;
		}

		s = splsoftnet();

		if (pcr->action == PF_CHANGE_ADD_HEAD)
			oldrule = TAILQ_FIRST(pf_rules_active);
		else if (pcr->action == PF_CHANGE_ADD_TAIL)
			oldrule = TAILQ_LAST(pf_rules_active, pf_rulequeue);
		else {
			oldrule = TAILQ_FIRST(pf_rules_active);
			while ((oldrule != NULL) && pf_compare_rules(oldrule,
			    &pcr->oldrule))
				oldrule = TAILQ_NEXT(oldrule, entries);
			if (oldrule == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcr->action == PF_CHANGE_REMOVE) {
			struct pf_tree_node *n;

			for (n = pf_tree_first(tree_ext_gwy); n != NULL;
			    n = pf_tree_next(n))
				if (n->state->rule == oldrule)
					n->state->rule = NULL;
			TAILQ_REMOVE(pf_rules_active, oldrule, entries);
			pool_put(&pf_rule_pl, oldrule);
		} else {
			if (oldrule == NULL)
				TAILQ_INSERT_TAIL(pf_rules_active, newrule,
				    entries);
			else if (pcr->action == PF_CHANGE_ADD_HEAD ||
			    pcr->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldrule, newrule, entries);
			else
				TAILQ_INSERT_AFTER(pf_rules_active, oldrule,
				    newrule, entries);
		}

		TAILQ_FOREACH(oldrule, pf_rules_active, entries)
			oldrule->nr = nr++;

		pf_calc_skip_steps(pf_rules_active);

		ticket_rules_active++;
		splx(s);
		break;
	}

d898 2
a899 2
#ifndef INET
		if (nat->af == AF_INET) {
d901 1
a901 8
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (nat->af == AF_INET6) {
			pool_put(&pf_nat_pl, nat);
			error = EAFNOSUPPORT;
a903 10
#endif /* INET6 */
		if (nat->ifname[0]) {
			nat->ifp = ifunit(nat->ifname);
			if (nat->ifp == NULL) {
				pool_put(&pf_nat_pl, nat);
				error = EINVAL;
				break;
			}
		} else
			nat->ifp = NULL;
d973 1
a973 81
	case DIOCCHANGENAT: {
		struct pfioc_changenat *pcn = (struct pfioc_changenat *)addr;
		struct pf_nat *oldnat = NULL, *newnat = NULL;

		if (pcn->action < PF_CHANGE_ADD_HEAD ||
		    pcn->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcn->action != PF_CHANGE_REMOVE) {
			newnat = pool_get(&pf_nat_pl, PR_NOWAIT);
			if (newnat == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcn->newnat, newnat, sizeof(struct pf_nat));
#ifndef INET
			if (newnat->af == AF_INET) {
				pool_put(&pf_nat_pl, newnat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newnat->af == AF_INET6) {
				pool_put(&pf_nat_pl, newnat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			newnat->ifp = NULL;
			if (newnat->ifname[0]) {
				newnat->ifp = ifunit(newnat->ifname);
				if (newnat->ifp == NULL) {
					pool_put(&pf_nat_pl, newnat);
					error = EINVAL;
					break;
				}
			}
		}

		s = splsoftnet();

		if (pcn->action == PF_CHANGE_ADD_HEAD)
			oldnat = TAILQ_FIRST(pf_nats_active);
		else if (pcn->action == PF_CHANGE_ADD_TAIL)
			oldnat = TAILQ_LAST(pf_nats_active, pf_natqueue);
		else {
			oldnat = TAILQ_FIRST(pf_nats_active);
			while ((oldnat != NULL) && pf_compare_nats(oldnat,
			    &pcn->oldnat))
				oldnat = TAILQ_NEXT(oldnat, entries);
			if (oldnat == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcn->action == PF_CHANGE_REMOVE) {
			TAILQ_REMOVE(pf_nats_active, oldnat, entries);
			pool_put(&pf_nat_pl, oldnat);
		} else {
			if (oldnat == NULL)
				TAILQ_INSERT_TAIL(pf_nats_active, newnat,
				    entries);
			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
			    pcn->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldnat, newnat, entries);
			else
				TAILQ_INSERT_AFTER(pf_nats_active, oldnat,
				     newnat, entries);
		}

		ticket_nats_active++;
		splx(s);
		break;
	}

	case DIOCBEGINBINATS: {
d975 1
a975 1
		struct pf_binat *binat;
d977 3
a979 3
		while ((binat = TAILQ_FIRST(pf_binats_inactive)) != NULL) {
			TAILQ_REMOVE(pf_binats_inactive, binat, entries);
			pool_put(&pf_binat_pl, binat);
d981 1
a981 1
		*ticket = ++ticket_binats_inactive;
d985 3
a987 3
	case DIOCADDBINAT: {
		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
		struct pf_binat *binat;
d989 1
a989 1
		if (pb->ticket != ticket_binats_inactive) {
d993 2
a994 2
		binat = pool_get(&pf_binat_pl, PR_NOWAIT);
		if (binat == NULL) {
d998 5
a1002 5
		bcopy(&pb->binat, binat, sizeof(struct pf_binat));
#ifndef INET
		if (binat->af == AF_INET) {
			pool_put(&pf_binat_pl, binat);
			error = EAFNOSUPPORT;
d1005 1
a1005 18
#endif /* INET */
#ifndef INET6
		if (binat->af == AF_INET6) {
			pool_put(&pf_binat_pl, binat);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
		if (binat->ifname[0]) {
			binat->ifp = ifunit(binat->ifname);
			if (binat->ifp == NULL) {
				pool_put(&pf_binat_pl, binat);
				error = EINVAL;
				break;
			}
		} else
			binat->ifp = NULL;
		TAILQ_INSERT_TAIL(pf_binats_inactive, binat, entries);
d1009 1
a1009 1
	case DIOCCOMMITBINATS: {
d1011 2
a1012 2
		struct pf_binatqueue *old_binats;
		struct pf_binat *binat;
d1014 1
a1014 1
		if (*ticket != ticket_binats_inactive) {
d1019 1
a1019 1
		/* Swap binats, keep the old. */
d1021 4
a1024 4
		old_binats = pf_binats_active;
		pf_binats_active = pf_binats_inactive;
		pf_binats_inactive = old_binats;
		ticket_binats_active = ticket_binats_inactive;
d1027 4
a1030 4
		/* Purge the old binat list */
		while ((binat = TAILQ_FIRST(old_binats)) != NULL) {
			TAILQ_REMOVE(old_binats, binat, entries);
			pool_put(&pf_binat_pl, binat);
d1035 3
a1037 3
	case DIOCGETBINATS: {
		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
		struct pf_binat *binat;
d1039 1
a1039 1
		pb->nr = 0;
d1041 3
a1043 3
		TAILQ_FOREACH(binat, pf_binats_active, entries)
			pb->nr++;
		pb->ticket = ticket_binats_active;
d1048 3
a1050 3
	case DIOCGETBINAT: {
		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
		struct pf_binat *binat;
d1053 1
a1053 1
		if (pb->ticket != ticket_binats_active) {
d1059 3
a1061 3
		binat = TAILQ_FIRST(pf_binats_active);
		while ((binat != NULL) && (nr < pb->nr)) {
			binat = TAILQ_NEXT(binat, entries);
d1064 1
a1064 1
		if (binat == NULL) {
d1069 1
a1069 1
		bcopy(binat, &pb->binat, sizeof(struct pf_binat));
d1074 2
a1075 42
	case DIOCCHANGEBINAT: {
		struct pfioc_changebinat *pcn = (struct pfioc_changebinat *)addr;
		struct pf_binat *oldbinat = NULL, *newbinat = NULL;

		if (pcn->action < PF_CHANGE_ADD_HEAD ||
		    pcn->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcn->action != PF_CHANGE_REMOVE) {
			newbinat = pool_get(&pf_binat_pl, PR_NOWAIT);
			if (newbinat == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcn->newbinat, newbinat,
				sizeof(struct pf_binat));
#ifndef INET
			if (newbinat->af == AF_INET) {
				pool_put(&pf_binat_pl, newbinat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newbinat->af == AF_INET6) {
				pool_put(&pf_binat_pl, newbinat);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			newbinat->ifp = NULL;
			if (newbinat->ifname[0]) {
				newbinat->ifp = ifunit(newbinat->ifname);
				if (newbinat->ifp == NULL) {
					pool_put(&pf_binat_pl, newbinat);
					error = EINVAL;
					break;
				}
			}
		}
d1078 7
d1086 2
a1087 250
		if (pcn->action == PF_CHANGE_ADD_HEAD)
			oldbinat = TAILQ_FIRST(pf_binats_active);
		else if (pcn->action == PF_CHANGE_ADD_TAIL)
			oldbinat = TAILQ_LAST(pf_binats_active, pf_binatqueue);
		else {
			oldbinat = TAILQ_FIRST(pf_binats_active);
			while ((oldbinat != NULL) && pf_compare_binats(oldbinat,
			    &pcn->oldbinat))
				oldbinat = TAILQ_NEXT(oldbinat, entries);
			if (oldbinat == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcn->action == PF_CHANGE_REMOVE) {
			TAILQ_REMOVE(pf_binats_active, oldbinat, entries);
			pool_put(&pf_binat_pl, oldbinat);
		} else {
			if (oldbinat == NULL)
				TAILQ_INSERT_TAIL(pf_binats_active, newbinat,
				    entries);
			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
			    pcn->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldbinat, newbinat, 
				    entries);
			else
				TAILQ_INSERT_AFTER(pf_binats_active, oldbinat,
				     newbinat, entries);
		}

		ticket_binats_active++;
		splx(s);
		break;
	}

	case DIOCBEGINRDRS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_rdr *rdr;

		while ((rdr = TAILQ_FIRST(pf_rdrs_inactive)) != NULL) {
			TAILQ_REMOVE(pf_rdrs_inactive, rdr, entries);
			pool_put(&pf_rdr_pl, rdr);
		}
		*ticket = ++ticket_rdrs_inactive;
		break;
	}

	case DIOCADDRDR: {
		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
		struct pf_rdr *rdr;

		if (pr->ticket != ticket_rdrs_inactive) {
			error = EBUSY;
			break;
		}
		rdr = pool_get(&pf_rdr_pl, PR_NOWAIT);
		if (rdr == NULL) {
			error = ENOMEM;
			break;
		}
		bcopy(&pr->rdr, rdr, sizeof(struct pf_rdr));
#ifndef INET
		if (rdr->af == AF_INET) {
			pool_put(&pf_rdr_pl, rdr);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET */
#ifndef INET6
		if (rdr->af == AF_INET6) {
			pool_put(&pf_rdr_pl, rdr);
			error = EAFNOSUPPORT;
			break;
		}
#endif /* INET6 */
		if (rdr->ifname[0]) {
			rdr->ifp = ifunit(rdr->ifname);
			if (rdr->ifp == NULL) {
				pool_put(&pf_rdr_pl, rdr);
				error = EINVAL;
				break;
			}
		} else
			rdr->ifp = NULL;
		TAILQ_INSERT_TAIL(pf_rdrs_inactive, rdr, entries);
		break;
	}

	case DIOCCOMMITRDRS: {
		u_int32_t *ticket = (u_int32_t *)addr;
		struct pf_rdrqueue *old_rdrs;
		struct pf_rdr *rdr;

		if (*ticket != ticket_rdrs_inactive) {
			error = EBUSY;
			break;
		}

		/* Swap rdrs, keep the old. */
		s = splsoftnet();
		old_rdrs = pf_rdrs_active;
		pf_rdrs_active = pf_rdrs_inactive;
		pf_rdrs_inactive = old_rdrs;
		ticket_rdrs_active = ticket_rdrs_inactive;
		splx(s);

		/* Purge the old rdr list */
		while ((rdr = TAILQ_FIRST(old_rdrs)) != NULL) {
			TAILQ_REMOVE(old_rdrs, rdr, entries);
			pool_put(&pf_rdr_pl, rdr);
		}
		break;
	}

	case DIOCGETRDRS: {
		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
		struct pf_rdr *rdr;

		pr->nr = 0;
		s = splsoftnet();
		TAILQ_FOREACH(rdr, pf_rdrs_active, entries)
			pr->nr++;
		pr->ticket = ticket_rdrs_active;
		splx(s);
		break;
	}

	case DIOCGETRDR: {
		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
		struct pf_rdr *rdr;
		u_int32_t nr;

		if (pr->ticket != ticket_rdrs_active) {
			error = EBUSY;
			break;
		}
		nr = 0;
		s = splsoftnet();
		rdr = TAILQ_FIRST(pf_rdrs_active);
		while ((rdr != NULL) && (nr < pr->nr)) {
			rdr = TAILQ_NEXT(rdr, entries);
			nr++;
		}
		if (rdr == NULL) {
			error = EBUSY;
			splx(s);
			break;
		}
		bcopy(rdr, &pr->rdr, sizeof(struct pf_rdr));
		splx(s);
		break;
	}

	case DIOCCHANGERDR: {
		struct pfioc_changerdr *pcn = (struct pfioc_changerdr *)addr;
		struct pf_rdr *oldrdr = NULL, *newrdr = NULL;

		if (pcn->action < PF_CHANGE_ADD_HEAD ||
		    pcn->action > PF_CHANGE_REMOVE) {
			error = EINVAL;
			break;
		}

		if (pcn->action != PF_CHANGE_REMOVE) {
			newrdr = pool_get(&pf_rdr_pl, PR_NOWAIT);
			if (newrdr == NULL) {
				error = ENOMEM;
				break;
			}
			bcopy(&pcn->newrdr, newrdr, sizeof(struct pf_rdr));
#ifndef INET
			if (newrdr->af == AF_INET) {
				pool_put(&pf_rdr_pl, newrdr);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET */
#ifndef INET6
			if (newrdr->af == AF_INET6) {
				pool_put(&pf_rdr_pl, newrdr);
				error = EAFNOSUPPORT;
				break;
			}
#endif /* INET6 */
			newrdr->ifp = NULL;
			if (newrdr->ifname[0]) {
				newrdr->ifp = ifunit(newrdr->ifname);
				if (newrdr->ifp == NULL) {
					pool_put(&pf_rdr_pl, newrdr);
					error = EINVAL;
					break;
				}
			}
		}

		s = splsoftnet();

		if (pcn->action == PF_CHANGE_ADD_HEAD)
			oldrdr = TAILQ_FIRST(pf_rdrs_active);
		else if (pcn->action == PF_CHANGE_ADD_TAIL)
			oldrdr = TAILQ_LAST(pf_rdrs_active, pf_rdrqueue);
		else {
			oldrdr = TAILQ_FIRST(pf_rdrs_active);
			while ((oldrdr != NULL) && pf_compare_rdrs(oldrdr,
			    &pcn->oldrdr))
				oldrdr = TAILQ_NEXT(oldrdr, entries);
			if (oldrdr == NULL) {
				error = EINVAL;
				splx(s);
				break;
			}
		}

		if (pcn->action == PF_CHANGE_REMOVE) {
			TAILQ_REMOVE(pf_rdrs_active, oldrdr, entries);
			pool_put(&pf_rdr_pl, oldrdr);
		} else {
			if (oldrdr == NULL)
				TAILQ_INSERT_TAIL(pf_rdrs_active, newrdr,
				    entries);
			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
			    pcn->action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldrdr, newrdr, entries);
			else
				TAILQ_INSERT_AFTER(pf_rdrs_active, oldrdr,
				     newrdr, entries);
		}

		ticket_rdrs_active++;
		splx(s);
		break;
	}

	case DIOCCLRSTATES: {
		struct pf_tree_node *n;

		s = splsoftnet();
		for (n = pf_tree_first(tree_ext_gwy); n != NULL;
		    n = pf_tree_next(n))
			n->state->expire = 0;
		pf_purge_expired_states();
		pf_status.states = 0;
		splx(s);
		break;
	}

	case DIOCGETSTATE: {
		struct pfioc_state *ps = (struct pfioc_state *)addr;
a1113 44
	case DIOCGETSTATES: {
		struct pfioc_states *ps = (struct pfioc_states *)addr;
		struct pf_tree_node *n;
		struct pf_state *p, pstore;
		u_int32_t nr = 0;
		int space = ps->ps_len;

		if (space == 0) {
			s = splsoftnet();
			n = pf_tree_first(tree_ext_gwy);
			while (n != NULL) {
				n = pf_tree_next(n);
				nr++;
			}
			splx(s);
			ps->ps_len = sizeof(struct pf_state) * nr;
			return (0);
		}

		microtime(&pftv);
		s = splsoftnet();
		p = ps->ps_states;
		n = pf_tree_first(tree_ext_gwy);
		while (n && (nr + 1) * sizeof(*p) <= ps->ps_len) {
			bcopy(n->state, &pstore, sizeof(pstore));
			pstore.creation = pftv.tv_sec - pstore.creation;
			if (pstore.expire <= pftv.tv_sec)
				pstore.expire = 0;
			else
				pstore.expire -= pftv.tv_sec;
			error = copyout(&pstore, p, sizeof(*p));
			if (error) {
				splx(s);
				goto fail;
			}
			p++;
			nr++;
			n = pf_tree_next(n);
		}
		ps->ps_len = sizeof(struct pf_state) * nr;
		splx(s);
		break;
	}

a1133 1

a1139 85
	case DIOCNATLOOK: {
		struct pfioc_natlook *pnl = (struct pfioc_natlook *)addr;
		struct pf_state *st;
		struct pf_tree_key key;
		int direction = pnl->direction;

		key.af = pnl->af;
		key.proto = pnl->proto;

		/*
		 * userland gives us source and dest of connetion, reverse
		 * the lookup so we ask for what happens with the return
		 * traffic, enabling us to find it in the state tree.
		 */
		PF_ACPY(&key.addr[1], &pnl->saddr, pnl->af);
		key.port[1] = pnl->sport;
		PF_ACPY(&key.addr[0], &pnl->daddr, pnl->af);
		key.port[0] = pnl->dport;

		if (!pnl->proto || 
		    PF_AZERO(&pnl->saddr, pnl->af) ||
		    PF_AZERO(&pnl->daddr, pnl->af) ||
		    !pnl->dport || !pnl->sport)
			error = EINVAL;
		else {
			s = splsoftnet();
			if (direction == PF_IN)
				st = pf_find_state(tree_ext_gwy, &key);
			else
				st = pf_find_state(tree_lan_ext, &key);
			if (st != NULL) {
				if (direction  == PF_IN) {
					PF_ACPY(&pnl->rsaddr, &st->lan.addr,
					    st->af);
					pnl->rsport = st->lan.port;
					PF_ACPY(&pnl->rdaddr, &pnl->daddr,
					    pnl->af);
					pnl->rdport = pnl->dport;
				} else {
					PF_ACPY(&pnl->rdaddr, &st->gwy.addr,
					    st->af);
					pnl->rdport = st->gwy.port;
					PF_ACPY(&pnl->rsaddr, &pnl->saddr,
					    pnl->af);
					pnl->rsport = pnl->sport;
				}
			} else
				error = ENOENT;
			splx(s);
		}
		break;
	}

	case DIOCSETTIMEOUT: {
		struct pfioc_tm *pt = (struct pfioc_tm *)addr;
		int old;

		if (pt->timeout < 0 || pt->timeout >= PFTM_MAX ||
		    pt->seconds < 0) {
			error = EINVAL;
			goto fail;
		}
		old = *pftm_timeouts[pt->timeout];
		*pftm_timeouts[pt->timeout] = pt->seconds;
		pt->seconds = old;
		break;
	}

	case DIOCGETTIMEOUT: {
		struct pfioc_tm *pt = (struct pfioc_tm *)addr;

		if (pt->timeout < 0 || pt->timeout >= PFTM_MAX) {
			error = EINVAL;
			goto fail;
		}
		pt->seconds = *pftm_timeouts[pt->timeout];
		break;
	}

	case DIOCSETDEBUG: {
		u_int32_t *level = (u_int32_t *)addr;
		pf_status.debug = *level;
		break;
	}

a1143 1
fail:
a1147 50
#define		 PF_CALC_SKIP_STEP(i, c) \
		do { \
			if (a & 1 << i) { \
				if (c) \
					r->skip[i] = TAILQ_NEXT(s, entries); \
				else \
					a ^= 1 << i; \
			} \
		} while (0)

void
pf_calc_skip_steps(struct pf_rulequeue *rules)
{
	struct pf_rule *r, *s;
	int a, i;

	r = TAILQ_FIRST(rules);
	while (r != NULL) {
		a = 0;
		for (i = 0; i < 7; ++i) {
			a |= 1 << i;
			r->skip[i] = TAILQ_NEXT(r, entries);
		}
		s = TAILQ_NEXT(r, entries);
		while (a && s != NULL) {
			PF_CALC_SKIP_STEP(0, s->ifp == r->ifp);
			PF_CALC_SKIP_STEP(1, s->af == r->af);
			PF_CALC_SKIP_STEP(2, s->proto == r->proto);
			PF_CALC_SKIP_STEP(3,
			    PF_AEQ(&s->src.addr, &r->src.addr, r->af) &&
			    PF_AEQ(&s->src.mask, &r->src.mask, r->af) &&
			    s->src.not == r->src.not);
			PF_CALC_SKIP_STEP(4,
			    s->src.port[0] == r->src.port[0] &&	
			    s->src.port[1] == r->src.port[1] &&
			    s->src.port_op == r->src.port_op);
			PF_CALC_SKIP_STEP(5,
			    PF_AEQ(&s->dst.addr, &r->dst.addr, r->af) &&
			    PF_AEQ(&s->dst.mask, &r->dst.mask, r->af) &&
			    s->dst.not == r->dst.not);
			PF_CALC_SKIP_STEP(6,
			    s->dst.port[0] == r->dst.port[0] &&
			    s->dst.port[1] == r->dst.port[1] &&
			    s->dst.port_op == r->dst.port_op);
			s = TAILQ_NEXT(s, entries);
		}
		r = TAILQ_NEXT(r, entries);
	}
}

d1149 1
a1149 1
pf_cksum_fixup(u_int16_t cksum, u_int16_t old, u_int16_t new, u_int8_t udp)
d1151 1
a1151 5
	u_int32_t l;

	if (udp && !cksum)
		return 0x0000;
	l = cksum + old - new;
d1154 1
a1154 3
	if (udp && !l)
		return 0xFFFF;
	return (l);
d1158 2
a1159 2
pf_change_ap(struct pf_addr *a, u_int16_t *p, u_int16_t *ic, u_int16_t *pc,
    struct pf_addr *an, u_int16_t pn, u_int8_t u, int af)
d1161 1
a1161 1
	struct pf_addr ao;
d1163 3
a1165 4

	PF_ACPY(&ao, a, af);
	PF_ACPY(a, an, af);

d1167 3
a1169 31

	switch (af) {
#ifdef INET
	case AF_INET:
		*ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
		    ao.addr16[0], an->addr16[0], 0),
		    ao.addr16[1], an->addr16[1], 0);
		*p = pn;
		*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
		    ao.addr16[0], an->addr16[0], u),
		    ao.addr16[1], an->addr16[1], u),
		    po, pn, u);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
		    ao.addr16[0], an->addr16[0], u),
		    ao.addr16[1], an->addr16[1], u),
		    ao.addr16[2], an->addr16[2], u),
		    ao.addr16[3], an->addr16[3], u),
		    ao.addr16[4], an->addr16[4], u),
		    ao.addr16[5], an->addr16[5], u),
       		    ao.addr16[6], an->addr16[6], u),
		    ao.addr16[7], an->addr16[7], u),
		    po, pn, u); 
		break;
#endif /* INET6 */
	}
d1173 1
a1173 1
pf_change_a(u_int32_t *a, u_int16_t *c, u_int32_t an, u_int8_t u)
a1175 1

d1177 2
a1178 24
	*c = pf_cksum_fixup(pf_cksum_fixup(*c, ao / 65536, an / 65536, u),
	   ao % 65536, an % 65536, u);
}

#ifdef INET6
void
pf_change_a6(struct pf_addr *a, u_int16_t *c, struct pf_addr *an, u_int8_t u)
{
        struct pf_addr ao;

	PF_ACPY(&ao, a, AF_INET6);
	PF_ACPY(a, an, AF_INET6);

	*c = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
	    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
	    pf_cksum_fixup(pf_cksum_fixup(*c,
	    ao.addr16[0], an->addr16[0], u),
	    ao.addr16[1], an->addr16[1], u),
	    ao.addr16[2], an->addr16[2], u),
	    ao.addr16[3], an->addr16[3], u),
	    ao.addr16[4], an->addr16[4], u),
	    ao.addr16[5], an->addr16[5], u),
       	    ao.addr16[6], an->addr16[6], u),
	    ao.addr16[7], an->addr16[7], u);
a1179 1
#endif /* INET6 */
d1182 2
a1183 3
pf_change_icmp(struct pf_addr *ia, u_int16_t *ip, struct pf_addr *oa,
    struct pf_addr *na, u_int16_t np, u_int16_t *pc, u_int16_t *h2c,
    u_int16_t *ic, u_int16_t *hc, u_int8_t u, int af)
d1185 1
a1185 2
	struct pf_addr oia, ooa;
	u_int32_t opc, oh2c = *h2c;
d1187 1
a1187 6

	PF_ACPY(&oia, ia, af);
	PF_ACPY(&ooa, oa, af);

	if (pc != NULL)
		opc = *pc;
d1190 14
a1203 61
	if (pc != NULL)
		*pc = pf_cksum_fixup(*pc, oip, *ip, u);
	*ic = pf_cksum_fixup(*ic, oip, *ip, 0);
	if (pc != NULL)
		*ic = pf_cksum_fixup(*ic, opc, *pc, 0);
	PF_ACPY(ia, na, af);
	/* Change inner ip address, fix inner ipv4 checksum and icmp checksum. */
	switch (af) {
#ifdef INET
	case AF_INET:
		*h2c = pf_cksum_fixup(pf_cksum_fixup(*h2c,
		    oia.addr16[0], ia->addr16[0], 0),
		    oia.addr16[1], ia->addr16[1], 0);
		*ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
		    oia.addr16[0], ia->addr16[0], 0),
		    oia.addr16[1], ia->addr16[1], 0);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*ic,
		    oia.addr16[0], ia->addr16[0], u),
		    oia.addr16[1], ia->addr16[1], u),
		    oia.addr16[2], ia->addr16[2], u),
		    oia.addr16[3], ia->addr16[3], u),
		    oia.addr16[4], ia->addr16[4], u),
		    oia.addr16[5], ia->addr16[5], u),
       		    oia.addr16[6], ia->addr16[6], u),
		    oia.addr16[7], ia->addr16[7], u);
		break;
#endif /* INET6 */
	}
	*ic = pf_cksum_fixup(*ic, oh2c, *h2c, 0);
	/* Change outer ip address, fix outer ipv4 or icmpv6 checksum. */
	PF_ACPY(oa, na, af);
	switch (af) {
#ifdef INET
	case AF_INET:
		*hc = pf_cksum_fixup(pf_cksum_fixup(*hc,
		    ooa.addr16[0], oa->addr16[0], 0),
		    ooa.addr16[1], oa->addr16[1], 0);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*ic,
		    ooa.addr16[0], oa->addr16[0], u),
		    ooa.addr16[1], oa->addr16[1], u),
		    ooa.addr16[2], oa->addr16[2], u),
		    ooa.addr16[3], oa->addr16[3], u),
		    ooa.addr16[4], oa->addr16[4], u),
		    ooa.addr16[5], oa->addr16[5], u),
       		    ooa.addr16[6], oa->addr16[6], u),
		    ooa.addr16[7], oa->addr16[7], u);
		break;
#endif /* INET6 */
	}
d1207 1
a1207 1
pf_send_reset(int off, struct tcphdr *th, struct pf_pdesc *pd, int af)
d1211 1
a1211 2
	int len;
#ifdef INET
a1212 4
#endif /* INET */
#ifdef INET6
	struct ip6_hdr *h2_6;
#endif /* INET6 */
a1214 13
	switch (af) {
#ifdef INET
	case AF_INET:
		len = sizeof(struct ip) + sizeof(struct tcphdr);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		len = sizeof(struct ip6_hdr) + sizeof(struct tcphdr);
		break;
#endif /* INET6 */
	}

d1233 1
a1233 23
	switch (af) {
#ifdef INET
	case AF_INET:
		h2 = mtod(m, struct ip *);

		/* IP header fields included in the TCP checksum */
		h2->ip_p = IPPROTO_TCP;
		h2->ip_len = htons(sizeof(*th2));
		h2->ip_src.s_addr = pd->dst->v4.s_addr;
		h2->ip_dst.s_addr = pd->src->v4.s_addr;

		th2 = (struct tcphdr *)((caddr_t)h2 + sizeof(struct ip));
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		h2_6 = mtod(m, struct ip6_hdr *);

		/* IP header fields included in the TCP checksum */
		h2_6->ip6_nxt = IPPROTO_TCP;
		h2_6->ip6_plen = htons(sizeof(*th2));
		memcpy(&h2_6->ip6_src, pd->dst, sizeof(struct in6_addr));
		memcpy(&h2_6->ip6_dst, pd->src, sizeof(struct in6_addr));  
d1235 5
a1239 4
		th2 = (struct tcphdr *)((caddr_t)h2_6 + sizeof(struct ip6_hdr));
		break;
#endif /* INET6 */
	}
d1242 1
d1249 3
a1251 5
		int tlen = pd->p_len;
		if (th->th_flags & TH_SYN)
			tlen++;
		if (th->th_flags & TH_FIN)
			tlen++;
d1257 9
a1265 21
	switch (af) {
#ifdef INET
	case AF_INET:
		/* TCP checksum */
		th2->th_sum = in_cksum(m, len);

		/* Finish the IP header */
		h2->ip_v = 4;
		h2->ip_hl = sizeof(*h2) >> 2;
		h2->ip_ttl = 128;
		h2->ip_sum = 0;
		h2->ip_len = len;
		h2->ip_off = 0;
		ip_output(m, NULL, NULL, 0, NULL, NULL);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		/* TCP checksum */
		th2->th_sum = in6_cksum(m, IPPROTO_TCP,
		    sizeof(struct ip6_hdr), sizeof(*th));
d1267 2
a1268 2
		h2_6->ip6_vfc |= IPV6_VERSION;
		h2_6->ip6_hlim = 128;
d1270 1
a1270 3
		ip6_output(m, NULL, NULL, 0, NULL, NULL);
#endif /* INET6 */
	}
d1274 1
a1274 1
pf_send_icmp(struct mbuf *m, u_int8_t type, u_int8_t code, int af)
d1279 6
a1284 134
	mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
	if (mtag == NULL)
		return;
	m0 = m_copy(m, 0, M_COPYALL);
	if (m0 == NULL) {
		m_tag_free(mtag);
		return;
	}
	m_tag_prepend(m0, mtag);
	switch (af) {
#ifdef INET
	case AF_INET:
		icmp_error(m0, type, code, 0, 0);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		icmp6_error(m0, type, code, 0);
		break;
#endif /* INET6 */
	}
}

/*
 * Return 1 if the addresses a and b match (with mask m), otherwise return 0.
 * If n is 0, they match if they are equal. If n is != 0, they match if they
 * are different.
 */
int
pf_match_addr(u_int8_t n, struct pf_addr *a, struct pf_addr *m,
    struct pf_addr *b, int af)
{
	int match = 0;
	switch (af) {
#ifdef INET
	case AF_INET:
		if ((a->addr32[0] & m->addr32[0]) ==
		    (b->addr32[0] & m->addr32[0]))
			match++;
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (((a->addr32[0] & m->addr32[0]) == 
		     (b->addr32[0] & m->addr32[0])) && 
		    ((a->addr32[1] & m->addr32[1]) == 
		     (b->addr32[1] & m->addr32[1])) && 
		    ((a->addr32[2] & m->addr32[2]) == 
		     (b->addr32[2] & m->addr32[2])) && 
		    ((a->addr32[3] & m->addr32[3]) == 
		     (b->addr32[3] & m->addr32[3]))) 
			match++;
		break;
#endif /* INET6 */
	} 
	if (match) {
		if (n)
			return (0);
		else
			return (1);
	} else {
		if (n)
			return (1);
		else
			return (0);
	}
}

int
pf_match_port(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
{
	NTOHS(a1);
	NTOHS(a2);
	NTOHS(p);
	switch (op) {
	case PF_OP_IRG:
		return (p > a1) && (p < a2);
	case PF_OP_XRG:
		return (p < a1) || (p > a2);
	case PF_OP_EQ:
		return (p == a1);
	case PF_OP_NE:
		return (p != a1);
	case PF_OP_LT:
		return (p < a1);
	case PF_OP_LE:
		return (p <= a1);
	case PF_OP_GT:
		return (p > a1);
	case PF_OP_GE:
		return (p >= a1);
	}
	return (0); /* never reached */
}

int
pf_chk_sport(struct pf_port_list *plist, u_int16_t port)
{
	struct pf_port_node	*pnode;

	LIST_FOREACH(pnode, plist, next) {
		if (pnode->port == port)
			return (1);
	}

	return (0);
}

int
pf_add_sport(struct pf_port_list *plist, u_int16_t port)
{
	struct pf_port_node *pnode;

	pnode = pool_get(&pf_sport_pl, M_NOWAIT);
	if (pnode == NULL)
		return (ENOMEM);

	pnode->port = port;
	LIST_INSERT_HEAD(plist, pnode, next);

	return (0);
}

void
pf_put_sport(u_int8_t proto, u_int16_t port)
{
	struct pf_port_list	*plist;
	struct pf_port_node	*pnode;

	if (proto == IPPROTO_TCP)
		plist = &pf_tcp_ports;
	else if (proto == IPPROTO_UDP)
		plist = &pf_udp_ports;
	else
a1285 7

	LIST_FOREACH(pnode, plist, next) {
		if (pnode->port == port) {
			LIST_REMOVE(pnode, next);
			pool_put(&pf_sport_pl, pnode);
			break;
		}
d1287 2
d1292 1
a1292 1
pf_get_sport(u_int8_t proto, u_int16_t low, u_int16_t high, u_int16_t *port)
d1294 2
a1295 10
	struct pf_port_list	*plist;
	int			step;
	u_int16_t		cut;

	if (proto == IPPROTO_TCP)
		plist = &pf_tcp_ports;
	else if (proto == IPPROTO_UDP)
		plist = &pf_udp_ports;
	else
		return (EINVAL);
d1297 18
a1314 12
	/* port search; start random, step; similar 2 portloop in in_pcbbind */
	if (low == high) {
		*port = low;
		if (!pf_chk_sport(plist, *port))
			goto found;
		return (1);
	} else if (low < high) {
		step = 1;
		cut = arc4random() % (high - low) + low;
	} else {
		step = -1;
		cut = arc4random() % (low - high) + high;
d1316 1
a1316 20

	*port = cut - step;
	do {
		*port += step;
		if (!pf_chk_sport(plist, *port))
			goto found;
	} while (*port != low && *port != high);

	step = -step;
	*port = cut;
	do {
		*port += step;
		if (!pf_chk_sport(plist, *port))
			goto found;
	} while (*port != low && *port != high);

	return (1);					/* none available */

found:
	return (pf_add_sport(plist, *port));
d1320 1
a1320 2
pf_get_nat(struct ifnet *ifp, u_int8_t proto, struct pf_addr *saddr,
    struct pf_addr *daddr, int af)
d1326 1
a1326 2
		if (((n->ifp == NULL) || (n->ifp == ifp && !n->ifnot) ||
		    (n->ifp != ifp && n->ifnot)) &&
d1328 1
a1328 3
		    (!n->af || n->af == af) &&
		    PF_MATCHA(n->snot, &n->saddr, &n->smask, saddr, af) &&
		    PF_MATCHA(n->dnot, &n->daddr, &n->dmask, daddr, af))
a1335 29
struct pf_binat *
pf_get_binat(int direction, struct ifnet *ifp, u_int8_t proto,
    struct pf_addr *saddr, struct pf_addr *daddr, int af)
{
	struct pf_binat *b, *bm = NULL;
	struct pf_addr fullmask; 

	memset(&fullmask, 0xff, sizeof(fullmask));

	b = TAILQ_FIRST(pf_binats_active);
	while (b && bm == NULL) {
		if (direction == PF_OUT && b->ifp == ifp &&
		    (!b->proto || b->proto == proto) &&
		    (!b->af || b->af == af) &&
		    PF_MATCHA(0, &b->saddr, &fullmask, saddr, af) &&
		    PF_MATCHA(b->dnot, &b->daddr, &b->dmask, daddr, af))
			bm = b;
                else if (direction == PF_IN && b->ifp == ifp &&
		    (!b->proto || b->proto == proto) &&
		    (!b->af || b->af == af) &&
		    PF_MATCHA(0, &b->raddr, &fullmask, saddr, af) &&
		    PF_MATCHA(b->dnot, &b->daddr, &b->dmask, daddr, af))
			bm = b;
		else
			b = TAILQ_NEXT(b, entries);
	}
	return (bm);
}

d1337 1
a1337 2
pf_get_rdr(struct ifnet *ifp, u_int8_t proto, struct pf_addr *saddr,
    struct pf_addr *daddr, u_int16_t dport, int af)
d1343 1
a1343 2
		if (((r->ifp == NULL) || (r->ifp == ifp && !r->ifnot) ||
		    (r->ifp != ifp && r->ifnot)) &&
d1345 3
a1347 6
		    (!r->af || r->af == af) &&
		    PF_MATCHA(r->snot, &r->saddr, &r->smask, saddr, af) &&
		    PF_MATCHA(r->dnot, &r->daddr, &r->dmask, daddr, af) &&
		    ((!r->dport2 && dport == r->dport) ||
		    (r->dport2 && (ntohs(dport) >= ntohs(r->dport)) &&
		    ntohs(dport) <= ntohs(r->dport2))))
d1355 14
d1373 1
a1373 1

a1380 1

d1382 2
a1383 2
pf_test_tcp(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
a1385 1
	struct pf_binat *binat = NULL;
d1387 3
a1389 4
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
	struct tcphdr *th = pd->hdr.tcp;
	struct pf_rule *r;
	u_int16_t bport, nport = 0, af = pd->af;
d1391 1
a1391 3
	int rewrite = 0, error;

	*rm = NULL;
a1393 9
		/* check outgoing packet for BINAT */
		if ((binat = pf_get_binat(PF_OUT, ifp, IPPROTO_TCP,
		    saddr, daddr, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
			bport = th->th_sport;
			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &binat->raddr, th->th_sport, 0, af);
			rewrite++;
		}
d1395 3
a1397 2
		else if ((nat = pf_get_nat(ifp, IPPROTO_TCP,
		    saddr, daddr, af)) != NULL) {
d1399 3
a1401 7
			error = pf_get_sport(IPPROTO_TCP, 50001,
			    65535, &nport);
			if (error)
				return (PF_DROP);
			PF_ACPY(&baddr, saddr, af);
			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &nat->raddr, htons(nport), 0, af);
d1406 3
a1408 2
		if ((rdr = pf_get_rdr(ifp, IPPROTO_TCP, saddr, daddr,
		    th->th_dport, af)) != NULL) {
d1414 4
a1417 12
			PF_ACPY(&baddr, daddr, af);
			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &rdr->raddr, nport, 0, af);
			rewrite++;
		}
		/* check incoming packet for BINAT */
		else if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_TCP,
		    daddr, saddr, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
			bport = th->th_dport;
			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &binat->saddr, th->th_dport, 0, af);
d1422 2
a1423 4
	r = TAILQ_FIRST(pf_rules_active);
	while (r != NULL) {
		if (r->action == PF_SCRUB) {
			r = TAILQ_NEXT(r, entries);
d1425 8
a1432 27
		}
		r->evaluations++;
		if (r->ifp != NULL && r->ifp != ifp)
			r = r->skip[0];
		else if (r->af && r->af != af)
			r = r->skip[1];
		else if (r->proto && r->proto != IPPROTO_TCP)
			r = r->skip[2];
		else if (!PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr, &r->src.mask, saddr, af))
			r = r->skip[3];
		else if (r->src.port_op && !pf_match_port(r->src.port_op,
		    r->src.port[0], r->src.port[1], th->th_sport))
			r = r->skip[4];
		else if (!PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr, &r->dst.mask, daddr, af))
			r = r->skip[5];
		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
		    r->dst.port[0], r->dst.port[1], th->th_dport))
			r = r->skip[6];
		else if (r->direction != direction)
			r = TAILQ_NEXT(r, entries);
		else if ((r->flagset & th->th_flags) != r->flags)
			r = TAILQ_NEXT(r, entries);
		else {
			*rm = r;
			if ((*rm)->quick)
a1433 1
			r = TAILQ_NEXT(r, entries);
d1437 1
a1437 3
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
d1441 2
a1442 2
		if ((*rm)->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
d1444 2
a1445 3
		if (((*rm)->action == PF_DROP) &&
		    (((*rm)->rule_flag & PFRULE_RETURNRST) ||
		    (*rm)->return_icmp)) {
d1447 3
a1449 4
			if (nat != NULL ||
			    (binat != NULL && direction == PF_OUT)) {
				pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
				    &th->th_sum, &baddr, bport, 0, af);
d1451 4
a1454 4
			} else if (rdr != NULL ||
			    (binat != NULL && direction == PF_IN)) {
				pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
				    &th->th_sum, &baddr, bport, 0, af);
d1457 5
a1461 5
			if ((*rm)->rule_flag & PFRULE_RETURNRST)
				pf_send_reset(off, th, pd, af);
			else 
				pf_send_icmp(m, (*rm)->return_icmp >> 8,
				    (*rm)->return_icmp & 255, af);
d1464 1
a1464 3
		if ((*rm)->action == PF_DROP) {
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_TCP, nport);
a1465 1
		}
d1468 2
a1469 2
	if (((*rm != NULL) && (*rm)->keep_state) || nat != NULL ||
	    binat != NULL || rdr != NULL) {
d1474 1
a1474 1
		len = pd->tot_len - off - (th->th_off << 2);
a1476 2
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_TCP, nport);
d1479 4
a1482 7

		s->rule = *rm;
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
		s->proto = IPPROTO_TCP;
		s->direction = direction;
		s->af = af;
d1484 10
a1493 8
			PF_ACPY(&s->gwy.addr, saddr, af);
			s->gwy.port = th->th_sport;		/* sport */
			PF_ACPY(&s->ext.addr, daddr, af);
			s->ext.port = th->th_dport;
			if (nat != NULL || binat != NULL) {
				PF_ACPY(&s->lan.addr, &baddr, af);
				s->lan.addr = baddr;
				s->lan.port = bport;
d1495 2
a1496 2
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
				s->lan.port = s->gwy.port;
d1499 7
a1505 7
			PF_ACPY(&s->lan.addr, daddr, af);
			s->lan.port = th->th_dport;
			PF_ACPY(&s->ext.addr, saddr, af);
			s->ext.port = th->th_sport;
			if (binat != NULL ||rdr != NULL) {
				PF_ACPY(&s->gwy.addr, &baddr, af);
				s->gwy.port = bport;
d1507 2
a1508 2
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
				s->gwy.port = s->lan.port;
d1511 15
a1525 28

		s->src.seqlo = ntohl(th->th_seq);
		s->src.seqhi = s->src.seqlo + len + 1;
		if (th->th_flags == TH_SYN && *rm != NULL
		    && (*rm)->keep_state == PF_STATE_MODULATE) {
			/* Generate sequence number modulator */
			while ((s->src.seqdiff = arc4random()) == 0)
				;
			pf_change_a(&th->th_seq, &th->th_sum,
			    htonl(s->src.seqlo + s->src.seqdiff), 0);
			rewrite = 1;
		} else
			s->src.seqdiff = 0;
		if (th->th_flags & TH_SYN)
			s->src.seqhi++;
		if (th->th_flags & TH_FIN)
			s->src.seqhi++;
		s->src.max_win = MAX(ntohs(th->th_win), 1);
		s->dst.seqlo = 0;	/* Haven't seen these yet */
		s->dst.seqhi = 1;
		s->dst.max_win = 1;
		s->dst.seqdiff = 0;	/* Defer random generation */
		s->src.state = TCPS_SYN_SENT;
		s->dst.state = TCPS_CLOSED;
		s->creation = pftv.tv_sec;
		s->expire = pftv.tv_sec + pftm_tcp_first_packet;
		s->packets = 1;
		s->bytes = pd->tot_len;
d1537 2
a1538 2
pf_test_udp(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
a1540 1
	struct pf_binat *binat = NULL;
d1542 3
a1544 4
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
	struct udphdr *uh = pd->hdr.udp;
	u_int16_t bport, nport = 0, af = pd->af;
	struct pf_rule *r;
d1546 1
a1546 3
	int rewrite = 0, error;

	*rm = NULL;
a1548 9
		/* check outgoing packet for BINAT */
		if ((binat = pf_get_binat(PF_OUT, ifp, IPPROTO_UDP,
		    saddr, daddr, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
			bport = uh->uh_sport;
			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &binat->raddr, uh->uh_sport, 1, af);
			rewrite++;
		}
d1550 3
a1552 2
		else if ((nat = pf_get_nat(ifp, IPPROTO_UDP,
		    saddr, daddr, af)) != NULL) {
d1554 3
a1556 7
			error = pf_get_sport(IPPROTO_UDP, 50001,
			    65535, &nport);
			if (error)
				return (PF_DROP);
			PF_ACPY(&baddr, saddr, af);
			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &nat->raddr, htons(nport), 1, af);
d1561 3
a1563 2
		if ((rdr = pf_get_rdr(ifp, IPPROTO_UDP, saddr, daddr, 
		    uh->uh_dport, af)) != NULL) {
d1570 4
a1573 12
			PF_ACPY(&baddr, daddr, af);
			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &rdr->raddr, nport, 1, af);
			rewrite++;
		}
		/* check incoming packet for BINAT */
		else if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_UDP,
		    daddr, daddr, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
			bport = uh->uh_dport;
			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &binat->saddr, uh->uh_dport, 1, af);
d1578 2
a1579 4
	r = TAILQ_FIRST(pf_rules_active);
	while (r != NULL) {
		if (r->action == PF_SCRUB) {
			r = TAILQ_NEXT(r, entries);
d1581 7
a1587 28
		}
		r->evaluations++;

		if (r->ifp != NULL && r->ifp != ifp)
			r = r->skip[0];
		else if (r->af && r->af != af)
			r = r->skip[1];
		else if (r->proto && r->proto != IPPROTO_UDP)
			r = r->skip[2];
		else if (!PF_AZERO(&r->src.mask, af) &&
		    !PF_MATCHA(r->src.not, &r->src.addr, &r->src.mask,
			saddr, af))
			r = r->skip[3];
		else if (r->src.port_op && !pf_match_port(r->src.port_op,
                    r->src.port[0], r->src.port[1], uh->uh_sport))
                        r = r->skip[4];
		else if (!PF_AZERO(&r->dst.mask, af) &&
		    !PF_MATCHA(r->dst.not, &r->dst.addr, &r->dst.mask,
			daddr, af))
			r = r->skip[5];
		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
		    r->dst.port[0], r->dst.port[1], uh->uh_dport))
			r = r->skip[6];
		else if (r->direction != direction)
			r = TAILQ_NEXT(r, entries);
		else {
			*rm = r;
			if ((*rm)->quick)
a1588 1
			r = TAILQ_NEXT(r, entries);
d1592 1
a1592 3
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
d1596 2
a1597 2
		if ((*rm)->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
d1599 1
a1599 1
		if (((*rm)->action == PF_DROP) && (*rm)->return_icmp) {
d1601 3
a1603 4
			if (nat != NULL ||
			    (binat != NULL && direction == PF_OUT)) {
				pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
				    &uh->uh_sum, &baddr, bport, 1, af);
d1605 4
a1608 4
			} else if (rdr != NULL ||
			    (binat != NULL && direction == PF_IN)) {
				pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
				    &uh->uh_sum, &baddr, bport, 1, af);
a1609 1
		
d1611 2
a1612 2
			pf_send_icmp(m, (*rm)->return_icmp >> 8,
			    (*rm)->return_icmp & 255, af);
d1615 1
a1615 3
		if ((*rm)->action == PF_DROP) {
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_UDP, nport);
a1616 1
		}
d1619 1
a1619 2
	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL ||
	    binat != NULL || rdr != NULL) {
d1624 1
a1624 1
		len = pd->tot_len - off - sizeof(*uh);
a1626 2
			if (nport && nat != NULL)
				pf_put_sport(IPPROTO_UDP, nport);
d1629 4
a1632 7

		s->rule = *rm;
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
		s->proto = IPPROTO_UDP;
		s->direction = direction;
		s->af = af;
d1634 10
a1643 7
			PF_ACPY(&s->gwy.addr, saddr, af);
			s->gwy.port = uh->uh_sport;
			PF_ACPY(&s->ext.addr, daddr, af);
			s->ext.port = uh->uh_dport;
			if (nat != NULL || binat != NULL) {
				PF_ACPY(&s->lan.addr, &baddr, af);
				s->lan.port = bport;
d1645 2
a1646 2
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
				s->lan.port = s->gwy.port;
d1649 7
a1655 7
			PF_ACPY(&s->lan.addr, daddr, af);
			s->lan.port = uh->uh_dport;
			PF_ACPY(&s->ext.addr, saddr, af);
			s->ext.port = uh->uh_sport;
			if (binat != NULL || rdr != NULL) {
				PF_ACPY(&s->gwy.addr, &baddr, af);
				s->gwy.port = bport;
d1657 2
a1658 2
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
				s->gwy.port = s->lan.port;
d1661 12
a1672 14
		s->src.seqlo  = 0;
		s->src.seqhi = 0;
		s->src.seqdiff = 0;
		s->src.max_win = 0;
		s->src.state = 1;
		s->dst.seqlo = 0;
		s->dst.seqhi = 0;
		s->dst.seqdiff = 0;
		s->dst.max_win = 0;
		s->dst.state = 0;
		s->creation = pftv.tv_sec;
		s->expire = pftv.tv_sec + pftm_udp_first_packet;
		s->packets = 1;
		s->bytes = pd->tot_len;
d1684 2
a1685 2
pf_test_icmp(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d1688 2
a1689 3
	struct pf_binat *binat = NULL;
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
	struct pf_rule *r;
a1690 3
	u_int16_t icmpid, af = pd->af;
	u_int8_t icmptype, icmpcode;
#ifdef INET6
a1691 20
#endif /* INET6 */

	*rm = NULL;

	switch (pd->proto) {
#ifdef INET
	case IPPROTO_ICMP:
		icmptype = pd->hdr.icmp->icmp_type;
		icmpcode = pd->hdr.icmp->icmp_code;
		icmpid = pd->hdr.icmp->icmp_id;
		break;
#endif /* INET */
#ifdef INET6
	case IPPROTO_ICMPV6:
		icmptype = pd->hdr.icmp6->icmp6_type;
		icmpcode = pd->hdr.icmp6->icmp6_code;
		icmpid = pd->hdr.icmp6->icmp6_id;
		break;
#endif /* INET6 */
	}
a1693 20
		/* check outgoing packet for BINAT */
		if ((binat = pf_get_binat(PF_OUT, ifp, IPPROTO_ICMP,
		    saddr, daddr, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&saddr->v4.s_addr, pd->ip_sum,
				    binat->raddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				pf_change_a6(saddr, &pd->hdr.icmp6->icmp6_cksum,
				    &binat->raddr, 0);
				rewrite++;
				break;
#endif /* INET6 */
			}
		}
d1695 5
a1699 39
		else if ((nat = pf_get_nat(ifp, pd->proto,
		    saddr, daddr, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&saddr->v4.s_addr,
				    pd->ip_sum, nat->raddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				pf_change_a6(saddr, &pd->hdr.icmp6->icmp6_cksum,
				    &nat->raddr, 0);
				rewrite++;
				break;
#endif /* INET6 */
			}
		}
	} else {
		/* check incoming packet for BINAT */
		if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_ICMP,
		    daddr, saddr, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&daddr->v4.s_addr,
				    pd->ip_sum, binat->saddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				pf_change_a6(daddr, &pd->hdr.icmp6->icmp6_cksum,
				    &binat->saddr, 0);
				rewrite++;
				break;
#endif /* INET6 */
			}
d1703 2
a1704 4
	r = TAILQ_FIRST(pf_rules_active);
	while (r != NULL) {
		if (r->action == PF_SCRUB) {
			r = TAILQ_NEXT(r, entries);
d1706 5
a1710 25
		}
		r->evaluations++;
		if (r->ifp != NULL && r->ifp != ifp)
			r = r->skip[0];
		else if (r->af && r->af != af)
			r = r->skip[1];
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[2];
		else if (!PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr, &r->src.mask, saddr, af))
			r = r->skip[3];
		else if (!PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr, &r->dst.mask, daddr, af))
			r = r->skip[5];
		else if (r->direction != direction)
			r = TAILQ_NEXT(r, entries);
		else if (r->ifp != NULL && r->ifp != ifp)
			r = TAILQ_NEXT(r, entries);
		else if (r->type && r->type != icmptype + 1)
			r = TAILQ_NEXT(r, entries);
		else if (r->code && r->code != icmpcode + 1)
			r = TAILQ_NEXT(r, entries);
		else {
			*rm = r;
			if ((*rm)->quick)
a1711 1
			r = TAILQ_NEXT(r, entries);
d1715 1
a1715 3
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes +=  pd->tot_len;
d1719 2
a1720 2
		if ((*rm)->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
d1722 1
a1722 1
		if ((*rm)->action != PF_PASS)
d1726 1
a1726 1
	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL || binat != NULL) {
d1729 1
d1732 2
a1733 1
		len = pd->tot_len - off - ICMP_MINLEN;
d1735 1
a1735 1
		if (s == NULL)
d1737 5
a1741 7

		s->rule = *rm;
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
		s->proto = pd->proto;
		s->direction = direction;
		s->af = af;
d1743 6
a1748 9
			PF_ACPY(&s->gwy.addr, saddr, af);
			s->gwy.port = icmpid;
			PF_ACPY(&s->ext.addr, daddr, af);
			s->ext.port = icmpid;
			if (nat != NULL || binat != NULL) 
				PF_ACPY(&s->lan.addr, &baddr, af);
			else
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
			s->lan.port = icmpid;
d1750 19
a1768 24
			PF_ACPY(&s->lan.addr, daddr, af);
			s->lan.port = icmpid;
			PF_ACPY(&s->ext.addr, saddr, af);
			s->ext.port = icmpid;
			if (binat != NULL)
				PF_ACPY(&s->gwy.addr, &baddr, af);
			else
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
			s->gwy.port = icmpid;
		}
		s->src.seqlo = 0;
		s->src.seqhi = 0;
		s->src.seqdiff = 0;
		s->src.max_win = 0;
		s->src.state = 0;
		s->dst.seqlo = 0;
		s->dst.seqhi = 0;
		s->dst.seqdiff = 0;
		s->dst.max_win = 0;
		s->dst.state = 0;
		s->creation = pftv.tv_sec;
		s->expire = pftv.tv_sec + pftm_icmp_first_packet;
		s->packets = 1;
		s->bytes = pd->tot_len;
d1772 1
a1772 2
#ifdef INET6
	/* copy back packet headers if we performed IPv6 NAT operations */
d1774 1
a1774 3
		m_copyback(m, off, ICMP_MINLEN,
		    (caddr_t)pd->hdr.icmp6);
#endif /* INET6 */
d1780 1
a1780 2
pf_test_other(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, void *h, struct pf_pdesc *pd)
d1782 1
a1782 44
	struct pf_rule *r;
	struct pf_binat *binat = NULL;
	struct pf_addr *saddr = pd->src, *daddr = pd->dst;
	u_int8_t af = pd->af;

	*rm = NULL;

	if (direction == PF_OUT) {
		/* check outgoing packet for BINAT */
		if ((binat = pf_get_binat(PF_OUT, ifp, pd->proto,
		    saddr, daddr, af)) != NULL) {
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&saddr->v4.s_addr, pd->ip_sum,
				    binat->raddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(saddr, &binat->raddr, af);
				break;
#endif /* INET6 */
			}
		}
	} else {
		/* check incoming packet for BINAT */
		if ((binat = pf_get_binat(PF_IN, ifp, pd->proto,
		    daddr, saddr, af)) != NULL) {
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&daddr->v4.s_addr,
				    pd->ip_sum, binat->saddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(daddr, &binat->saddr, af);
				break;
#endif /* INET6 */
			}
		}
	}
d1784 2
a1785 4
	r = TAILQ_FIRST(pf_rules_active);
	while (r != NULL) {
		if (r->action == PF_SCRUB) {
			r = TAILQ_NEXT(r, entries);
d1787 3
a1789 19
		}
		r->evaluations++;
		if (r->ifp != NULL && r->ifp != ifp)
			r = r->skip[0];
		else if (r->af && r->af != af)
			r = r->skip[1];
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[2];
		else if (!PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
		    &r->src.addr, &r->src.mask, pd->src, af))
			r = r->skip[3];
		else if (!PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
		    &r->dst.addr, &r->dst.mask, pd->dst, af))
			r = r->skip[5];
		else if (r->direction != direction)
			r = TAILQ_NEXT(r, entries);
		else {
			*rm = r;
			if ((*rm)->quick)
a1790 1
			r = TAILQ_NEXT(r, entries);
d1794 1
a1794 1
	if (*rm != NULL) {
a1796 2
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
d1798 2
a1799 2
		if ((*rm)->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
d1801 1
a1801 1
		if ((*rm)->action != PF_PASS)
d1807 3
a1809 3
int
pf_test_state_tcp(struct pf_state **state, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d1811 1
d1813 1
a1813 5
	struct tcphdr *th = pd->hdr.tcp;
	u_int16_t win = ntohs(th->th_win);
	u_int32_t ack, end, seq;
	int ackskew;
	struct pf_state_peer *src, *dst;
a1814 1
	key.af	    = pd->af;
d1816 1
a1816 2
	PF_ACPY(&key.addr[0], pd->src, key.af);
	PF_ACPY(&key.addr[1], pd->dst, key.af);
d1818 1
d1821 14
a1834 33
	if (direction == PF_IN)
		*state = pf_find_state(tree_ext_gwy, &key);
	else
		*state = pf_find_state(tree_lan_ext, &key);
	if (*state == NULL)
		return (PF_DROP);

	if (direction == (*state)->direction) {
		src = &(*state)->src;
		dst = &(*state)->dst;
	} else {
		src = &(*state)->dst;
		dst = &(*state)->src;
	}

	/*
	 * Sequence tracking algorithm from Guido van Rooij's paper:
	 *   http://www.madison-gurkha.com/publications/tcp_filtering/
	 *	tcp_filtering.ps
	 */

	seq = ntohl(th->th_seq);
	if (src->seqlo == 0) {
		/* First packet from this end.  Set its state */

		/* Deferred generation of sequence number modulator */
		if (dst->seqdiff) {
			while ((src->seqdiff = arc4random()) == 0)
				;
			ack = ntohl(th->th_ack) - dst->seqdiff;
			pf_change_a(&th->th_seq, &th->th_sum, htonl(seq +
			    src->seqdiff), 0);
			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack), 0);
d1836 2
a1837 1
			ack = ntohl(th->th_ack);
d1840 2
a1841 74
		end = seq + pd->p_len;
		if (th->th_flags & TH_SYN)
			end++;
		if (th->th_flags & TH_FIN)
			end++;

		src->seqlo = seq;
		if (src->state < TCPS_SYN_SENT)
			src->state = TCPS_SYN_SENT;

		/*
		 * May need to slide the window (seqhi may have been set by
		 * the crappy stack check or if we picked up the connection
		 * after establishment)
		 */
		if (SEQ_GEQ(end + MAX(1, dst->max_win), src->seqhi))
			src->seqhi = end + MAX(1, dst->max_win);
		if (win > src->max_win)
			src->max_win = win;

	} else {
		ack = ntohl(th->th_ack) - dst->seqdiff;
		if (src->seqdiff) {
			/* Modulate sequence numbers */
			pf_change_a(&th->th_seq, &th->th_sum, htonl(seq +
			    src->seqdiff), 0);
			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack), 0);
		}
		end = seq + pd->p_len;
		if (th->th_flags & TH_SYN)
			end++;
		if (th->th_flags & TH_FIN)
			end++;
	}

	if ((th->th_flags & TH_ACK) == 0) {
		/* Let it pass through the ack skew check */
		ack = dst->seqlo;
	} else if ((ack == 0 &&
	    (th->th_flags & (TH_ACK|TH_RST)) == (TH_ACK|TH_RST)) ||
	    /* broken tcp stacks do not set ack */
	    (dst->state < TCPS_SYN_SENT)) {
	    /* Many stacks (ours included) will set the ACK number in an
	     * FIN|ACK if the SYN times out -- no sequence to ACK.
	     */
		ack = dst->seqlo;
	}

	if (seq == end) {
		/* Ease sequencing restrictions on no data packets */
		seq = src->seqlo;
		end = seq;
	}

	ackskew = dst->seqlo - ack;

#define MAXACKWINDOW (0xffff + 1500)	/* 1500 is an arbitrary fudge factor */
	if (SEQ_GEQ(src->seqhi, end) &&
	    /* Last octet inside other's window space */
	    SEQ_GEQ(seq, src->seqlo - dst->max_win) &&
	    /* Retrans: not more than one window back */
	    (ackskew >= -MAXACKWINDOW) &&
	    /* Acking not more than one window back */
	    (ackskew <= MAXACKWINDOW)) {
	    /* Acking not more than one window forward */

		(*state)->packets++;
		(*state)->bytes += pd->tot_len;

		/* update max window */
		if (src->max_win < win)
			src->max_win = win;
		/* syncronize sequencing */
		if (SEQ_GT(end, src->seqlo))
d1843 2
a1844 17
		/* slide the window of what the other end can send */
		if (SEQ_GEQ(ack + win, dst->seqhi))
			dst->seqhi = ack + MAX(win, 1);


		/* update states */
		if (th->th_flags & TH_SYN)
			if (src->state < TCPS_SYN_SENT)
				src->state = TCPS_SYN_SENT;
		if (th->th_flags & TH_FIN)
			if (src->state < TCPS_CLOSING)
				src->state = TCPS_CLOSING;
		if (th->th_flags & TH_ACK) {
			if (dst->state == TCPS_SYN_SENT)
				dst->state = TCPS_ESTABLISHED;
			else if (dst->state == TCPS_CLOSING)
				dst->state = TCPS_FIN_WAIT_2;
a1845 2
		if (th->th_flags & TH_RST)
			src->state = dst->state = TCPS_TIME_WAIT;
d1847 77
a1923 15
		/* update expire time */
		if (src->state >= TCPS_FIN_WAIT_2 &&
		    dst->state >= TCPS_FIN_WAIT_2)
			(*state)->expire = pftv.tv_sec + pftm_tcp_closed;
		else if (src->state >= TCPS_FIN_WAIT_2 ||
		    dst->state >= TCPS_FIN_WAIT_2)
			(*state)->expire = pftv.tv_sec + pftm_tcp_fin_wait;
		else if (src->state >= TCPS_CLOSING ||
		    dst->state >= TCPS_CLOSING)
			(*state)->expire = pftv.tv_sec + pftm_tcp_closing;
		else if (src->state < TCPS_ESTABLISHED ||
		    dst->state < TCPS_ESTABLISHED)
			(*state)->expire = pftv.tv_sec + pftm_tcp_opening;
		else
			(*state)->expire = pftv.tv_sec + pftm_tcp_established;
d1925 15
a1939 1
		/* Fall through to PASS packet */
d1941 2
a1942 65
	} else if ((dst->state < TCPS_SYN_SENT ||
		dst->state >= TCPS_FIN_WAIT_2 ||
		src->state >= TCPS_FIN_WAIT_2) &&
	    SEQ_GEQ(src->seqhi + MAXACKWINDOW, end) &&
	    /* Within a window forward of the originating packet */
	    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW)) {
	    /* Within a window backward of the originating packet */

		/*
		 * This currently handles three situations:
		 *  1) Stupid stacks will shotgun SYNs before their peer
		 *     replies.
		 *  2) When PF catches an already established stream (the
		 *     firewall rebooted, the state table was flushed, routes
		 *     changed...)
		 *  3) Packets get funky immediately after the connection
		 *     closes (this should catch Solaris spurious ACK|FINs
		 *     that web servers like to spew after a close)
		 *
		 * This must be a little more careful than the above code
		 * since packet floods will also be caught here.  We don't
		 * update the TTL here to mitigate the damage of a packet
		 * flood and so the same code can handle awkward establishment
		 * and a loosened connection close.
		 * In the establishment case, a correct peer response will
		 * validate the connection, go through the normal state code
		 * and keep updating the state TTL.
		 */

		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: loose state match: ");
			pf_print_state(*state);
			pf_print_flags(th->th_flags);
			printf(" seq=%lu ack=%lu len=%u ackskew=%d pkts=%d\n",
			    seq, ack, pd->p_len, ackskew, (*state)->packets);
		}

		(*state)->packets++;
		(*state)->bytes += pd->tot_len;

		/* update max window */
		if (src->max_win < win)
			src->max_win = win;
		/* syncronize sequencing */
		if (SEQ_GT(end, src->seqlo))
			src->seqlo = end;
		/* slide the window of what the other end can send */
		if (SEQ_GEQ(ack + win, dst->seqhi))
			dst->seqhi = ack + MAX(win, 1);

		/*
		 * Cannot set dst->seqhi here since this could be a shotgunned
		 * SYN and not an already established connection.
		 */

		if (th->th_flags & TH_FIN)
			if (src->state < TCPS_CLOSING)
				src->state = TCPS_CLOSING;
		if (th->th_flags & TH_RST)
			src->state = dst->state = TCPS_TIME_WAIT;

		/* Fall through to PASS packet */

	} else {
		if (pf_status.debug >= PF_DEBUG_MISC) {
d1944 1
a1944 1
			pf_print_state(*state);
d1946 3
a1948 6
			printf(" seq=%lu ack=%lu len=%u ackskew=%d pkts=%d "
			    "dir=%s,%s\n", seq, ack, pd->p_len, ackskew,
			    ++(*state)->packets,
			    direction == PF_IN ? "in" : "out",
			    direction == (*state)->direction ? "fwd" : "rev");
			printf("pf: State failure on: %c %c %c %c | %c %c\n",
d1952 2
a1953 3
			    (ackskew <= MAXACKWINDOW) ? ' ' : '4',
			    SEQ_GEQ(src->seqhi + MAXACKWINDOW, end) ?' ' :'5',
			    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW) ?' ' :'6');
a1954 4
		return (PF_DROP);
	}

	/* Any packets which have gotten here are to be passed */
d1956 3
a1958 15
	/* translate source/destination address, if needed */
	if (STATE_TRANSLATE(*state)) {
		if (direction == PF_OUT)
			pf_change_ap(pd->src, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &(*state)->gwy.addr,
		 	   (*state)->gwy.port, 0, pd->af);
		else
			pf_change_ap(pd->dst, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &(*state)->lan.addr,
			    (*state)->lan.port, 0, pd->af);
		m_copyback(m, off, sizeof(*th), (caddr_t)th);
	} else if (src->seqdiff) {
		/* Copyback sequence modulation */
		m_copyback(m, off, sizeof(*th), (caddr_t)th);
	}
d1960 1
a1960 3
	if ((*state)->rule != NULL) {
		(*state)->rule->packets++;
		(*state)->rule->bytes += pd->tot_len;
d1962 1
a1962 1
	return (PF_PASS);
d1965 3
a1967 3
int
pf_test_state_udp(struct pf_state **state, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d1969 1
a1969 1
	struct pf_state_peer *src, *dst;
d1971 1
a1971 1
	struct udphdr *uh = pd->hdr.udp;
a1972 1
	key.af	    = pd->af;
d1974 21
a1994 4
	PF_ACPY(&key.addr[0], pd->src, key.af);
	PF_ACPY(&key.addr[1], pd->dst, key.af);
	key.port[0] = pd->hdr.udp->uh_sport;
	key.port[1] = pd->hdr.udp->uh_dport;
d1996 5
a2000 14
	if (direction == PF_IN)
		*state = pf_find_state(tree_ext_gwy, &key);
	else
		*state = pf_find_state(tree_lan_ext, &key);
	if (*state == NULL)
		return (PF_DROP);

	if (direction == (*state)->direction) {
		src = &(*state)->src;
		dst = &(*state)->dst;
	} else {
		src = &(*state)->dst;
		dst = &(*state)->src;
	}
d2002 5
a2006 2
	(*state)->packets++;
	(*state)->bytes += pd->tot_len;
d2008 13
a2020 11
	/* update states */
	if (src->state < 1)
		src->state = 1;
	if (dst->state == 1)
		dst->state = 2;

	/* update expire time */
	if (src->state == 2 && dst->state == 2)
		(*state)->expire = pftv.tv_sec + pftm_udp_multiple;
	else
		(*state)->expire = pftv.tv_sec + pftm_udp_single;
d2022 3
a2024 12
	/* translate source/destination address, if necessary */
	if (STATE_TRANSLATE(*state)) {
		if (direction == PF_OUT)
			pf_change_ap(pd->src, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &(*state)->gwy.addr,
			    (*state)->gwy.port, 1, pd->af);
		else
			pf_change_ap(pd->dst, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &(*state)->lan.addr,
			    (*state)->lan.port, 1, pd->af);
		m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
	}
d2026 1
a2026 3
	if ((*state)->rule != NULL) {
		(*state)->rule->packets++;
		(*state)->rule->bytes += pd->tot_len;
d2028 1
a2028 1
	return (PF_PASS);
d2031 3
a2033 3
int
pf_test_state_icmp(struct pf_state **state, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d2035 2
a2036 34
	struct pf_addr *saddr = pd->src, *daddr = pd->dst;
	u_int16_t icmpid, *icmpsum;
	u_int8_t icmptype;
	int state_icmp = 0;

	switch (pd->proto) {
#ifdef INET
	case IPPROTO_ICMP:
		icmptype = pd->hdr.icmp->icmp_type;
		icmpid = pd->hdr.icmp->icmp_id;
		icmpsum = &pd->hdr.icmp->icmp_cksum;

		if (icmptype == ICMP_UNREACH ||
		    icmptype == ICMP_SOURCEQUENCH ||
		    icmptype == ICMP_REDIRECT ||
		    icmptype == ICMP_TIMXCEED ||
		    icmptype == ICMP_PARAMPROB)
			state_icmp++;
		break;
#endif /* INET */
#ifdef INET6
	case IPPROTO_ICMPV6:
		icmptype = pd->hdr.icmp6->icmp6_type;
		icmpid = pd->hdr.icmp6->icmp6_id;
		icmpsum = &pd->hdr.icmp6->icmp6_cksum;

		if (icmptype == ICMP6_DST_UNREACH ||
		    icmptype == ICMP6_PACKET_TOO_BIG ||
		    icmptype == ICMP6_TIME_EXCEEDED ||
		    icmptype == ICMP6_PARAM_PROB)
			state_icmp++;
		break;
#endif /* INET6 */
	}
d2038 5
a2042 1
	if (!state_icmp) {
d2048 1
d2051 22
a2072 13
		key.af      = pd->af;
		key.proto   = pd->proto;
		PF_ACPY(&key.addr[0], saddr, key.af);
		PF_ACPY(&key.addr[1], daddr, key.af);
		key.port[0] = icmpid;
		key.port[1] = icmpid;

		if (direction == PF_IN)
			*state = pf_find_state(tree_ext_gwy, &key);
		else
			*state = pf_find_state(tree_lan_ext, &key);
		if (*state == NULL)
			return (PF_DROP);
d2074 1
a2074 45
		(*state)->packets++;
		(*state)->bytes += pd->tot_len;
		(*state)->expire = pftv.tv_sec + pftm_icmp_error_reply;

		/* translate source/destination address, if needed */
		if (PF_ANEQ(&(*state)->lan.addr, &(*state)->gwy.addr, pd->af)) {
			if (direction == PF_OUT) {
				switch (pd->af) {
#ifdef INET
				case AF_INET:
					pf_change_a(&saddr->v4.s_addr,
				    	    pd->ip_sum,
					    (*state)->gwy.addr.v4.s_addr, 0);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					pf_change_a6(saddr,
					    &pd->hdr.icmp6->icmp6_cksum,
					    &(*state)->gwy.addr, 0);
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp6);
					break;
#endif /* INET6 */
				}
			} else {
				switch (pd->af) {
#ifdef INET
				case AF_INET:
					pf_change_a(&daddr->v4.s_addr,
					    pd->ip_sum,
					    (*state)->lan.addr.v4.s_addr, 0);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					pf_change_a6(daddr,
					    &pd->hdr.icmp6->icmp6_cksum,
					    &(*state)->lan.addr, 0);
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp6);
					break;
#endif /* INET6 */
				}
			}
d2076 1
d2078 1
a2078 1
		return (PF_PASS);
a2079 1
	} else {
a2084 2
		struct pf_pdesc pd2;
#ifdef INET
a2085 5
#endif /* INET */
#ifdef INET6
		struct ip6_hdr h2_6;
		int terminal = 0;
#endif /* INET6 */
d2089 9
a2097 45
		pd2.af = pd->af;
		switch (pd->af) {
#ifdef INET
		case AF_INET: 
			/* offset of h2 in mbuf chain */
			ipoff2 = off + ICMP_MINLEN;

			if (!pf_pull_hdr(m, ipoff2, &h2, sizeof(h2),
			    NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short (ip)\n"));
				return (PF_DROP);
			}
			/* ICMP error messages don't refer to non-first fragments */
			if (ntohs(h2.ip_off) & IP_OFFMASK)
				return (PF_DROP);

			/* offset of protocol header that follows h2 */
			off2 = ipoff2 + (h2.ip_hl << 2);

			pd2.proto = h2.ip_p;
			pd2.src = (struct pf_addr *)&h2.ip_src;
			pd2.dst = (struct pf_addr *)&h2.ip_dst;
			pd2.ip_sum = &h2.ip_sum;
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			ipoff2 = off + sizeof(struct icmp6_hdr); 

			if (!pf_pull_hdr(m, ipoff2, &h2_6, sizeof(h2_6),
                            NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short (ip6)\n"));
				return (PF_DROP);
			}
			pd2.proto = h2_6.ip6_nxt;
			pd2.src = (struct pf_addr *)&h2_6.ip6_src;
			pd2.dst = (struct pf_addr *)&h2_6.ip6_dst;
			pd2.ip_sum = NULL;
			do {			
				while (off >= m->m_len) {
					off -= m->m_len;
					m = m->m_next;
				}
d2099 1
a2099 27
				switch (pd2.proto) {
				case IPPROTO_FRAGMENT: 
					/* XXX we don't handle fagments yet */
					return (PF_DROP);
				case IPPROTO_AH:
				case IPPROTO_HOPOPTS:
				case IPPROTO_ROUTING:
				case IPPROTO_DSTOPTS: {
					/* get next header and header length */
					struct _opt6 *opt6;

					opt6 = (struct _opt6 *)(mtod(m, caddr_t) + off2);
					pd2.proto = opt6->opt6_nxt;
					off2 += (opt6->opt6_hlen + 1) * 8;
					/* goto the next header */
					break;
				}
				default:
					terminal++;
					break;
				}
			} while (!terminal);
			break;
#endif /* INET6 */
		}
			
		switch (pd2.proto) {
d2103 1
d2112 5
a2116 4
			if (!pf_pull_hdr(m, off2, &th, 8, NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short (tcp)\n"));
				return (PF_DROP);
d2118 1
a2119 1
			key.af = pd2.af;
d2121 1
a2121 1
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
d2123 1
a2123 1
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
d2126 4
a2129 14
			if (direction == PF_IN)
				*state = pf_find_state(tree_ext_gwy, &key);
			else
				*state = pf_find_state(tree_lan_ext, &key);
			if (*state == NULL)
				return (PF_DROP);

			if (direction == (*state)->direction) {
				src = &(*state)->dst;
				dst = &(*state)->src;
			} else {
				src = &(*state)->src;
				dst = &(*state)->dst;
			}
d2131 2
a2132 5
			/* Demodulate sequence number */
			seq = ntohl(th.th_seq) - src->seqdiff;
			if (src->seqdiff)
				pf_change_a(&th.th_seq, &th.th_sum,
				    htonl(seq), 0);
d2136 5
a2140 6
				if (pf_status.debug >= PF_DEBUG_MISC) {
					printf("pf: BAD ICMP state: ");
					pf_print_state(*state);
					printf(" seq=%lu\n", seq);
				}
				return (PF_DROP);
d2143 2
a2144 1
			if (STATE_TRANSLATE(*state)) {
d2146 5
a2150 5
					pf_change_icmp(pd2.src, &th.th_sport,
					    saddr, &(*state)->lan.addr,
					    (*state)->lan.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
d2152 5
a2156 5
					pf_change_icmp(pd2.dst, &th.th_dport,
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
d2158 13
a2170 21
				switch (pd2.af) {
#ifdef INET
				case AF_INET:
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2),
					    (caddr_t)&h2);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp6);
					m_copyback(m, ipoff2, sizeof(h2_6),
					    (caddr_t)&h2_6);
					break;
#endif /* INET6 */
				}
				m_copyback(m, off2, 8, (caddr_t)&th);
			} else if (src->seqdiff) {
				m_copyback(m, off2, 8, (caddr_t)&th);
d2173 1
a2173 1
			return (PF_PASS);
d2178 1
d2181 4
a2184 5
			if (!pf_pull_hdr(m, off2, &uh, sizeof(uh),
			    NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short (udp)\n"));
				return (PF_DROP);
a2186 1
			key.af = pd2.af;
d2188 1
a2188 1
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
d2190 1
a2190 1
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
d2193 4
a2196 6
			if (direction == PF_IN)
				*state = pf_find_state(tree_ext_gwy, &key);
			else
				*state = pf_find_state(tree_lan_ext, &key);
			if (*state == NULL)
				return (PF_DROP);
d2198 2
a2199 1
			if (STATE_TRANSLATE(*state)) {
d2201 5
a2205 5
					pf_change_icmp(pd2.src, &uh.uh_sport,
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, &uh.uh_sum,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 1, pd2.af);
d2207 5
a2211 23
					pf_change_icmp(pd2.dst, &uh.uh_dport, 
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, &uh.uh_sum,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 1, pd2.af);
				}
				switch (pd2.af) {
#ifdef INET
				case AF_INET:
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2),
					    (caddr_t)&h2);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp6);
					m_copyback(m, ipoff2, sizeof(h2_6),
					    (caddr_t)&h2_6);
					break;
#endif /* INET6 */
d2213 11
d2228 1
a2228 1
			return (PF_PASS);
d2231 5
a2235 4
#ifdef INET
		case IPPROTO_ICMP: {
			struct icmp iih;
			struct pf_tree_key key;
d2237 2
a2238 6
			if (!pf_pull_hdr(m, off2, &iih, ICMP_MINLEN,
			    NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short (icmp)\n"));
				return (PF_DROP);
			}
d2240 1
a2240 6
			key.af = pd2.af;
			key.proto   = IPPROTO_ICMP;
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = iih.icmp_id;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = iih.icmp_id;
d2242 5
a2246 6
			if (direction == PF_IN)
				*state = pf_find_state(tree_ext_gwy, &key);
			else
				*state = pf_find_state(tree_lan_ext, &key);
			if (*state == NULL)
				return (PF_DROP);
d2248 1
a2248 21
			if (STATE_TRANSLATE(*state)) {
				if (direction == PF_IN) {
					pf_change_icmp(pd2.src, &iih.icmp_id,
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET);
				} else {
					pf_change_icmp(pd2.dst, &iih.icmp_id,
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET);
				}
				m_copyback(m, off, ICMP_MINLEN,
				    (caddr_t)pd->hdr.icmp);
				m_copyback(m, ipoff2, sizeof(h2),
				    (caddr_t)&h2);
				m_copyback(m, off2, ICMP_MINLEN,
				    (caddr_t)&iih);
			}
d2250 9
a2258 1
			return (PF_PASS);
a2259 6
		}
#endif /* INET */
#ifdef INET6
		case IPPROTO_ICMPV6: {
			struct icmp6_hdr iih;
			struct pf_tree_key key;
d2261 3
a2263 6
			if (!pf_pull_hdr(m, off2, &iih, ICMP_MINLEN,
			    NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short (icmp6)\n"));
				return (PF_DROP);
			}
d2265 1
a2265 6
			key.af = pd2.af;
			key.proto   = IPPROTO_ICMPV6;
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = iih.icmp6_id;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = iih.icmp6_id;
d2267 3
a2269 6
			if (direction == PF_IN)
				*state = pf_find_state(tree_ext_gwy, &key);
			else
				*state = pf_find_state(tree_lan_ext, &key);
			if (*state == NULL)
				return (PF_DROP);
d2271 5
a2275 21
			if (STATE_TRANSLATE(*state)) {
				if (direction == PF_IN) {
					pf_change_icmp(pd2.src, &iih.icmp6_id,
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET6);
				} else {
					pf_change_icmp(pd2.dst, &iih.icmp6_id,
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET6);
				}
				m_copyback(m, off, ICMP_MINLEN,
				    (caddr_t)pd->hdr.icmp6);
				m_copyback(m, ipoff2, sizeof(h2_6),
				    (caddr_t)&h2_6);
				m_copyback(m, off2, ICMP_MINLEN,
				    (caddr_t)&iih);
			}
d2277 6
a2282 1
			return (PF_PASS);
d2284 15
a2298 7
		}
#endif /* INET6 */
		default:
			DPFPRINTF(PF_DEBUG_MISC,
			    ("pf: ICMP error message for bad proto\n"));
			return (PF_DROP);
		}
d2300 3
d2304 12
d2318 2
a2319 7
/*
 * ipoff and off are measured from the start of the mbuf chain.
 * h must be at "ipoff" on the mbuf chain.
 */
void *
pf_pull_hdr(struct mbuf *m, int off, void *p, int len,
    u_short *actionp, u_short *reasonp, int af)
d2321 12
a2332 14
	switch (af) {
#ifdef INET
	case AF_INET: {
		struct ip *h = mtod(m, struct ip *);
		u_int16_t fragoff = (h->ip_off & IP_OFFMASK) << 3;

		if (fragoff) {
			if (fragoff >= len)
				ACTION_SET(actionp, PF_PASS);
			else {
				ACTION_SET(actionp, PF_DROP);
				REASON_SET(reasonp, PFRES_FRAG);
			}
			return (NULL);
d2334 67
a2400 6
		if (m->m_pkthdr.len < off + len || h->ip_len < off + len) {
			ACTION_SET(actionp, PF_DROP);
			REASON_SET(reasonp, PFRES_SHORT);
			return (NULL);
		}
		break;
d2402 9
a2410 11
#endif /* INET */
#ifdef INET6
	case AF_INET6: {
		struct ip6_hdr *h = mtod(m, struct ip6_hdr *);	
		if (m->m_pkthdr.len < off + len ||
		    (ntohs(h->ip6_plen) + sizeof(struct ip6_hdr)) < off + len) {
                        ACTION_SET(actionp, PF_DROP);
                        REASON_SET(reasonp, PFRES_SHORT);
                        return (NULL);
                }
		break;
a2411 5
#endif /* INET6 */
	}
	m_copydata(m, off, len, p);
	return (p);
}
d2413 26
a2438 11
#ifdef INET
int
pf_test(int dir, struct ifnet *ifp, struct mbuf **m0)
{
	u_short action, reason = 0, log = 0;
	struct mbuf *m = *m0;
	struct ip *h;
	struct pf_rule *r = NULL;
	struct pf_state *s = NULL;
	struct pf_pdesc pd;
	int off;
d2440 15
a2454 3
	if (!pf_status.running ||
	    (m_tag_find(m, PACKET_TAG_PF_GENERATED, NULL) != NULL))
		return (PF_PASS);
d2456 8
a2463 4
#ifdef DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("non-M_PKTHDR is passed to pf_test");
#endif
d2465 9
a2473 6
	/* purge expire states */
	microtime(&pftv);
	if (pftv.tv_sec - pf_last_purge >= pftm_interval) {
		pf_purge_expired_states();
		pf_purge_expired_fragments();
		pf_last_purge = pftv.tv_sec;
d2475 3
d2479 7
a2485 5
	if (m->m_pkthdr.len < sizeof(*h)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_SHORT);
		log = 1;
		goto done;
d2487 1
d2489 16
a2504 4
	/* We do IP header normalization and packet reassembly here */
	if (pf_normalize_ip(m0, dir, ifp, &reason) != PF_PASS) {
		ACTION_SET(&action, PF_DROP);
		goto done;
a2505 2
	m = *m0;
	h = mtod(m, struct ip *);
d2507 18
a2524 6
	off = h->ip_hl << 2;
	if (off < sizeof(*h)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_SHORT);
		log = 1;
		goto done;
d2527 9
a2535 6
	pd.src = (struct pf_addr *)&h->ip_src;
	pd.dst = (struct pf_addr *)&h->ip_dst;
	pd.ip_sum = &h->ip_sum;
	pd.proto = h->ip_p;
	pd.af = AF_INET;
	pd.tot_len = h->ip_len;
d2537 11
a2547 5
	switch (h->ip_p) {

	case IPPROTO_TCP: {
		struct tcphdr th;
		pd.hdr.tcp = &th;
d2549 3
a2551 8
		if (!pf_pull_hdr(m, off, &th, sizeof(th),
		    &action, &reason, AF_INET)) {
			log = action != PF_PASS;
			goto done;
		}
		pd.p_len = pd.tot_len - off - (th.th_off << 2);
		action = pf_normalize_tcp(dir, ifp, m, 0, off, h, &pd);
		if (action == PF_DROP)
a2552 7
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd);
		if (action == PF_PASS) {
			r = s->rule;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_tcp(&r, dir, ifp, m, 0, off, h, &pd);
		break;
d2555 2
a2556 3
	case IPPROTO_UDP: {
		struct udphdr uh;
		pd.hdr.udp = &uh;
d2558 3
a2560 13
		if (!pf_pull_hdr(m, off, &uh, sizeof(uh),
		    &action, &reason, AF_INET)) {
			log = action != PF_PASS;
			goto done;
		}
		action = pf_test_state_udp(&s, dir, ifp, m, 0, off, h, &pd);
		if (action == PF_PASS) {
			r = s->rule;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_udp(&r, dir, ifp, m, 0, off, h, &pd);
		break;
	}
d2562 9
a2570 3
	case IPPROTO_ICMP: {
		struct icmp ih;
		pd.hdr.icmp = &ih;
d2572 4
a2575 16
		if (!pf_pull_hdr(m, off, &ih, ICMP_MINLEN,
		    &action, &reason, AF_INET)) {
			log = action != PF_PASS;
			goto done;
		}
		action = pf_test_state_icmp(&s, dir, ifp, m, 0, off, h, &pd);
		if (action == PF_PASS) {
			r = s->rule;
			if (r != NULL) {
				r->packets++;
				r->bytes += h->ip_len;
			}
			log = s->log;
		} else if (s == NULL)
			action = pf_test_icmp(&r, dir, ifp, m, 0, off, h, &pd);
		break;
d2578 30
a2607 3
	default:
		action = pf_test_other(&r, dir, ifp, m, h, &pd);
		break;
d2609 22
d2632 2
a2633 4
	if (ifp == status_ifp) {
		pf_status.bcounters[0][dir] += pd.tot_len;
		pf_status.pcounters[0][dir][action]++;
	}
d2635 2
a2636 9
done:
	if (action != PF_DROP && h->ip_hl > 5 &&
	    !((s && s->allow_opts) || (r && r->allow_opts))) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_SHORT);
		log = 1;
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping packet with ip options\n"));
	}
d2638 9
a2646 2
	if (log) {
		struct pf_rule r0;
d2648 12
a2659 5
		if (r == NULL) {
			r0.ifp = ifp;
			r0.action = action;
			r0.nr = -1;
			r = &r0;
d2661 6
a2666 1
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r);
d2668 2
a2669 1
	return (action);
a2670 1
#endif /* INET */
a2671 1
#ifdef INET6
d2673 1
a2673 1
pf_test6(int dir, struct ifnet *ifp, struct mbuf **m0)
d2677 1
a2677 1
	struct ip6_hdr *h;
d2679 2
a2680 3
	struct pf_state *s = NULL;
	struct pf_pdesc pd;
	int off, terminal = 0;
d2691 1
a2691 1
	/* purge expire states */
d2693 1
a2693 1
	if (pftv.tv_sec - pf_last_purge >= pftm_interval) {
d2706 7
d2714 3
a2716 1
	h = mtod(m, struct ip6_hdr *);
d2718 1
a2718 40
	pd.src = (struct pf_addr *)&h->ip6_src;
	pd.dst = (struct pf_addr *)&h->ip6_dst;
	pd.ip_sum = NULL;
	pd.af = AF_INET6;
	pd.tot_len = ntohs(h->ip6_plen) + sizeof(struct ip6_hdr);

	off = ((caddr_t)h - m->m_data) + sizeof(struct ip6_hdr);
	pd.proto = h->ip6_nxt;
	do {			
		while (off >= m->m_len) {
			off -= m->m_len;
			m = m->m_next;
		}

		switch (pd.proto) {
		case IPPROTO_FRAGMENT: 
			/* XXX we don't handle fragments yet */
			action = PF_DROP;
			REASON_SET(&reason, PFRES_FRAG);
			goto done;
		case IPPROTO_AH:
		case IPPROTO_HOPOPTS:
		case IPPROTO_ROUTING:
		case IPPROTO_DSTOPTS: {
			/* get next header and header length */
			struct _opt6 *opt6;

			opt6 = (struct _opt6 *)(mtod(m, caddr_t) + off);
			pd.proto = opt6->opt6_nxt;
			off += (opt6->opt6_hlen + 1) * 8;
			/* goto the next header */
			break;
		}
		default:
			terminal++;
			break;
		}
	} while (!terminal);

	switch (pd.proto) {
a2721 1
		pd.hdr.tcp = &th;
d2723 2
a2724 2
		if (!pf_pull_hdr(m, off, &th, sizeof(th),
		    &action, &reason, AF_INET6)) {
d2728 2
a2729 6
		pd.p_len = pd.tot_len - off - (th.th_off << 2);
		action = pf_normalize_tcp(dir, ifp, m, 0, off, h, &pd);
                if (action == PF_DROP)
                        break;
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd);
		if (action == PF_PASS) {
d2732 2
a2733 2
		} else if (s == NULL)
			action = pf_test_tcp(&r, dir, ifp, m, 0, off, h, &pd);
a2738 1
		pd.hdr.udp = &uh;
d2740 2
a2741 2
		if (!pf_pull_hdr(m, off, &uh, sizeof(uh),
		    &action, &reason, AF_INET6)) {
d2745 2
a2746 2
		action = pf_test_state_udp(&s, dir, ifp, m, 0, off, h, &pd);
		if (action == PF_PASS) {
d2749 2
a2750 2
		} else if (s == NULL)
			action = pf_test_udp(&r, dir, ifp, m, 0, off, h, &pd);
d2754 2
a2755 3
	case IPPROTO_ICMPV6: {
		struct icmp6_hdr ih;
		pd.hdr.icmp6 = &ih;
d2757 2
a2758 2
		if (!pf_pull_hdr(m, off, &ih, sizeof(ih),
		    &action, &reason, AF_INET6)) {
d2762 2
a2763 2
		action = pf_test_state_icmp(&s, dir, ifp, m, 0, off, h, &pd);
		if (action == PF_PASS) {
a2764 4
			if (r != NULL) {
				r->packets++;
				r->bytes += h->ip6_plen;
			}
d2766 2
a2767 2
		} else if (s == NULL)
			action = pf_test_icmp(&r, dir, ifp, m, 0, off, h, &pd);
d2772 1
a2772 1
		action = pf_test_other(&r, dir, ifp, m, h, &pd);
d2776 1
d2778 2
a2779 2
		pf_status.bcounters[1][dir] += h->ip6_plen;
		pf_status.pcounters[1][dir][action]++;
a2780 4

done:   
	/* XXX handle IPv6 options, if not allowed. not implemented. */

d2790 1
a2790 1
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r);
a2793 1
#endif /* INET6 */
@


1.95.2.2
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d2105 1
a2105 1
		for (i = 0; i < PF_SKIP_COUNT; ++i) {
d2111 4
a2114 4
			PF_CALC_SKIP_STEP(PF_SKIP_IFP, s->ifp == r->ifp);
			PF_CALC_SKIP_STEP(PF_SKIP_AF, s->af == r->af);
			PF_CALC_SKIP_STEP(PF_SKIP_PROTO, s->proto == r->proto);
			PF_CALC_SKIP_STEP(PF_SKIP_SRC_ADDR,
d2118 1
a2118 1
			PF_CALC_SKIP_STEP(PF_SKIP_SRC_PORT,
d2122 1
a2122 1
			PF_CALC_SKIP_STEP(PF_SKIP_DST_ADDR,
d2126 1
a2126 1
			PF_CALC_SKIP_STEP(PF_SKIP_DST_PORT,
d2787 1
a2787 1
			r = r->skip[PF_SKIP_IFP];
d2789 1
a2789 1
			r = r->skip[PF_SKIP_AF];
d2791 1
a2791 1
			r = r->skip[PF_SKIP_PROTO];
d2794 1
a2794 1
			r = r->skip[PF_SKIP_SRC_ADDR];
d2797 1
a2797 1
			r = r->skip[PF_SKIP_SRC_PORT];
d2800 1
a2800 1
			r = r->skip[PF_SKIP_DST_ADDR];
d2803 1
a2803 1
			r = r->skip[PF_SKIP_DST_PORT];
d3012 1
a3012 1
			r = r->skip[PF_SKIP_IFP];
d3014 1
a3014 1
			r = r->skip[PF_SKIP_AF];
d3016 1
a3016 1
			r = r->skip[PF_SKIP_PROTO];
d3020 1
a3020 1
			r = r->skip[PF_SKIP_SRC_ADDR];
d3023 1
a3023 1
                        r = r->skip[PF_SKIP_SRC_PORT];
d3027 1
a3027 1
			r = r->skip[PF_SKIP_DST_ADDR];
d3030 1
a3030 1
			r = r->skip[PF_SKIP_DST_PORT];
d3250 1
a3250 1
			r = r->skip[PF_SKIP_IFP];
d3252 1
a3252 1
			r = r->skip[PF_SKIP_AF];
d3254 1
a3254 1
			r = r->skip[PF_SKIP_PROTO];
d3257 1
a3257 1
			r = r->skip[PF_SKIP_SRC_ADDR];
d3260 1
a3260 1
			r = r->skip[PF_SKIP_DST_ADDR];
d3411 1
a3411 1
			r = r->skip[PF_SKIP_IFP];
d3413 1
a3413 1
			r = r->skip[PF_SKIP_AF];
d3415 1
a3415 1
			r = r->skip[PF_SKIP_PROTO];
d3418 1
a3418 1
			r = r->skip[PF_SKIP_SRC_ADDR];
d3421 1
a3421 1
			r = r->skip[PF_SKIP_DST_ADDR];
@


1.95.2.3
log
@Merge in -current
@
text
@a59 4
#include <netinet/in_pcb.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/udp_var.h>
d177 1
a177 1
int			 pf_compare_binats(struct pf_binat *,
a250 2
void			 pf_route(struct mbuf *, struct pf_rule *);
void			 pf_route6(struct mbuf *, struct pf_rule *);
d285 1
a285 1
	 * minimize the average number of compares. what is faster?
d341 1
a341 1

d366 1
a366 1
	}
d847 1
a847 1
	}
d874 1
a874 1
					if (i == maxstart)
a1009 1
	/* XXX keep in sync with switch() below */
a1028 1
		case DIOCCHANGEBINAT:
a1113 9
		if (rule->rt_ifname[0]) {
			rule->rt_ifp = ifunit(rule->rt_ifname);
			if (rule->rt_ifname == NULL) {
				pool_put(&pf_rule_pl, rule);
				error = EINVAL;
				break;
			}
		} else
			rule->rt_ifp = NULL;
d1474 1
a1474 1
				    newnat, entries);
d1670 1
a1670 1
				TAILQ_INSERT_BEFORE(oldbinat, newbinat,
d1674 1
a1674 1
				    newbinat, entries);
d1872 1
a1872 1
				    newrdr, entries);
d1983 1
a1983 1
		u_int32_t running = pf_status.running;
a1984 2
		u_int32_t since = pf_status.since;
		u_int32_t debug = pf_status.debug;
a1988 2
		pf_status.since = since;
		pf_status.debug = debug;
d2011 1
a2011 1
		if (!pnl->proto ||
d2119 1
a2119 1
			    s->src.port[0] == r->src.port[0] &&
d2187 1
a2187 1
		    ao.addr16[6], an->addr16[6], u),
d2189 1
a2189 1
		    po, pn, u);
d2209 1
a2209 1
	struct pf_addr ao;
d2223 1
a2223 1
	    ao.addr16[6], an->addr16[6], u),
d2273 1
a2273 1
		    oia.addr16[6], ia->addr16[6], u),
d2300 1
a2300 1
		    ooa.addr16[6], oa->addr16[6], u),
d2374 1
a2374 1
		memcpy(&h2_6->ip6_dst, pd->src, sizeof(struct in6_addr));
d2477 8
a2484 8
		if (((a->addr32[0] & m->addr32[0]) ==
		     (b->addr32[0] & m->addr32[0])) &&
		    ((a->addr32[1] & m->addr32[1]) ==
		     (b->addr32[1] & m->addr32[1])) &&
		    ((a->addr32[2] & m->addr32[2]) ==
		     (b->addr32[2] & m->addr32[2])) &&
		    ((a->addr32[3] & m->addr32[3]) ==
		     (b->addr32[3] & m->addr32[3])))
d2488 1
a2488 1
	}
d2654 1
a2654 1
	struct pf_addr fullmask;
d2666 1
a2666 1
		else if (direction == PF_IN && b->ifp == ifp &&
d2842 1
a2842 1
			else
d2979 1
a2979 1
		if ((rdr = pf_get_rdr(ifp, IPPROTO_UDP, saddr, daddr,
d3019 1
a3019 1
		    saddr, af))
d3022 2
a3023 2
		    r->src.port[0], r->src.port[1], uh->uh_sport))
			r = r->skip[PF_SKIP_SRC_PORT];
d3062 1
d3311 1
a3311 1
			if (nat != NULL || binat != NULL)
d3920 1
a3920 1
		case AF_INET:
d3945 1
a3945 1
			ipoff2 = off + sizeof(struct icmp6_hdr);
d3948 1
a3948 1
			    NULL, NULL, pd2.af)) {
d3957 6
a3962 2
			off2 = ipoff2 + sizeof(h2_6);
			do {
d3964 1
a3964 1
				case IPPROTO_FRAGMENT:
d3972 1
a3972 1
					struct _opt6 opt6;
d3974 3
a3976 8
					if (!pf_pull_hdr(m, off2, &opt6,
					    sizeof(opt6), NULL, NULL, pd2.af)) {
						DPFPRINTF(PF_DEBUG_MISC,
						    ("pf:  ICMPv6 short opt\n"));
						return(PF_DROP);
					}
					pd2.proto = opt6.opt6_nxt;
					off2 += (opt6.opt6_hlen + 1) * 8;
d3988 1
a3988 1

d4118 1
a4118 1
					pf_change_icmp(pd2.dst, &uh.uh_dport,
d4295 1
a4295 1
		struct ip6_hdr *h = mtod(m, struct ip6_hdr *);
d4298 4
a4301 4
			ACTION_SET(actionp, PF_DROP);
			REASON_SET(reasonp, PFRES_SHORT);
			return (NULL);
		}
a4310 264
void
pf_route(struct mbuf *m, struct pf_rule *r)
{
	struct mbuf *m0, *m1;
	struct route iproute;
	struct route *ro;
	struct sockaddr_in *dst;
	struct ip *ip, *mhip;
	struct ifnet *ifp = r->rt_ifp;
	int hlen;
	int len, off, error = 0;

	if (m == NULL)
		return;

	if (r->rt == PF_DUPTO) {
		m0 = m_copym2(m, 0, M_COPYALL, M_NOWAIT);
		if (m0 == NULL)
			return;
	} else
		m0 = m;

	ip = mtod(m0, struct ip *);
	hlen = ip->ip_hl << 2;

	ro = &iproute;
	bzero((caddr_t)ro, sizeof(*ro));
	dst = satosin(&ro->ro_dst);
	dst->sin_family = AF_INET;
	dst->sin_len = sizeof(*dst);
	dst->sin_addr = ip->ip_dst;

	if (r->rt == PF_FASTROUTE) {
		rtalloc(ro);
		if (ro->ro_rt == 0) {
			ipstat.ips_noroute++;
			goto bad;
		}

		ifp = ro->ro_rt->rt_ifp;
		ro->ro_rt->rt_use++;

		if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			dst = satosin(ro->ro_rt->rt_gateway);
	} else {
		if (!PF_AZERO(&r->rt_addr, AF_INET))
			dst->sin_addr.s_addr = r->rt_addr.v4.s_addr;
	}

	if (ifp == NULL)
		goto bad;

	/* Copied from ip_output. */
	if ((u_int16_t)ip->ip_len <= ifp->if_mtu) {
		ip->ip_len = htons((u_int16_t)ip->ip_len);
		ip->ip_off = htons((u_int16_t)ip->ip_off);
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    ifp->if_bridge == NULL) {
			m0->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
			ipstat.ips_outhwcsum++;
		} else {
			ip->ip_sum = 0;
			ip->ip_sum = in_cksum(m0, hlen);
		}
		/* Update relevant hardware checksum stats for TCP/UDP */
		if (m0->m_pkthdr.csum & M_TCPV4_CSUM_OUT)
			tcpstat.tcps_outhwcsum++;
		else if (m0->m_pkthdr.csum & M_UDPV4_CSUM_OUT)
			udpstat.udps_outhwcsum++;
		error = (*ifp->if_output)(ifp, m0, sintosa(dst), NULL);
		goto done;
	}

	/*
	 * Too large for interface; fragment if possible.
	 * Must be able to put at least 8 bytes per fragment.
	 */
	if (ip->ip_off & IP_DF) {
		error = EMSGSIZE;
		ipstat.ips_cantfrag++;
		goto bad;
	}
	len = (ifp->if_mtu - hlen) &~ 7;
	if (len < 8) {
		error = EMSGSIZE;
		goto bad;
	}
	/*
	 * If we are doing fragmentation, we can't defer TCP/UDP
	 * checksumming; compute the checksum and clear the flag.
	 */
	if (m0->m_pkthdr.csum & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
		in_delayed_cksum(m0);
		m0->m_pkthdr.csum &= ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
	}

	{
	    int mhlen, firstlen = len;
	    struct mbuf **mnext = &m0->m_nextpkt;

	    /*
	     * Loop through length of segment after first fragment,
	     * make new header and copy data of each part and link onto chain.
	     */
	    m1 = m0;
	    mhlen = sizeof (struct ip);
	    for (off = hlen + len; off < (u_int16_t)ip->ip_len; off += len) {
		    MGETHDR(m0, M_DONTWAIT, MT_HEADER);
		    if (m0 == 0) {
			    error = ENOBUFS;
			    ipstat.ips_odropped++;
			    goto sendorfree;
		    }
		    *mnext = m0;
		    mnext = &m0->m_nextpkt;
		    m0->m_data += max_linkhdr;
		    mhip = mtod(m0, struct ip *);
		    *mhip = *ip;
		    /* we must inherit MCAST and BCAST flags */
		    m0->m_flags |= m1->m_flags & (M_MCAST|M_BCAST);
		    if (hlen > sizeof (struct ip)) {
			    mhlen = ip_optcopy(ip, mhip) + sizeof (struct ip);
			    mhip->ip_hl = mhlen >> 2;
		    }
		    m0->m_len = mhlen;
		    mhip->ip_off = ((off - hlen) >> 3) + (ip->ip_off & ~IP_MF);
		    if (ip->ip_off & IP_MF)
			    mhip->ip_off |= IP_MF;
		    if (off + len >= (u_int16_t)ip->ip_len)
			    len = (u_int16_t)ip->ip_len - off;
		    else
			    mhip->ip_off |= IP_MF;
		    mhip->ip_len = htons((u_int16_t)(len + mhlen));
		    m0->m_next = m_copy(m1, off, len);
		    if (m0->m_next == 0) {
			    error = ENOBUFS;/* ??? */
			    ipstat.ips_odropped++;
			    goto sendorfree;
		    }
		    m0->m_pkthdr.len = mhlen + len;
		    m0->m_pkthdr.rcvif = (struct ifnet *)0;
		    mhip->ip_off = htons((u_int16_t)mhip->ip_off);
		    if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
			ifp->if_bridge == NULL) {
			    m0->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
			    ipstat.ips_outhwcsum++;
		    } else {
			    mhip->ip_sum = 0;
			    mhip->ip_sum = in_cksum(m0, mhlen);
		    }
		    ipstat.ips_ofragments++;
	    }
	    /*
	     * Update first fragment by trimming what's been copied out
	     * and updating header, then send each fragment (in order).
	     */
	    m0 = m1;
	    m_adj(m0, hlen + firstlen - (u_int16_t)ip->ip_len);
	    m0->m_pkthdr.len = hlen + firstlen;
	    ip->ip_len = htons((u_int16_t)m0->m_pkthdr.len);
	    ip->ip_off = htons((u_int16_t)(ip->ip_off | IP_MF));
	    if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		ifp->if_bridge == NULL) {
		    m0->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
		    ipstat.ips_outhwcsum++;
	    } else {
		    ip->ip_sum = 0;
		    ip->ip_sum = in_cksum(m0, hlen);
	    }
sendorfree:
	    for (m0 = m1; m0; m0 = m1) {
		    m1 = m0->m_nextpkt;
		    m0->m_nextpkt = 0;
		    if (error == 0)
			    error = (*ifp->if_output)(ifp, m0, sintosa(dst),
				NULL);
		    else
			    m_freem(m0);
	    }

	    if (error == 0)
		    ipstat.ips_fragmented++;
	}

done:
	if (ro == &iproute && ro->ro_rt)
		RTFREE(ro->ro_rt);
	return;

bad:
	m_freem(m0);
	goto done;
}
#endif /* INET */

#ifdef INET6
void
pf_route6(struct mbuf *m, struct pf_rule *r)
{
	struct mbuf *m0;
	struct m_tag *mtag;
	struct route_in6 ip6route;
	struct route_in6 *ro;
	struct sockaddr_in6 *dst;
	struct ip6_hdr *ip6;
	struct ifnet *ifp = r->rt_ifp;
	int error = 0;

	if (m == NULL)
		return;

	if (r->rt == PF_DUPTO) {
		m0 = m_copym2(m, 0, M_COPYALL, M_NOWAIT);
		if (m0 == NULL)
			return;
	} else
		m0 = m;

	ip6 = mtod(m0, struct ip6_hdr *);

	ro = &ip6route;
	bzero((caddr_t)ro, sizeof(*ro));
	dst = (struct sockaddr_in6 *)&ro->ro_dst;
	dst->sin6_family = AF_INET6;
	dst->sin6_len = sizeof(*dst);
	dst->sin6_addr = ip6->ip6_dst;

	if (!PF_AZERO(&r->rt_addr, AF_INET6))
		dst->sin6_addr = r->rt_addr.v6;

	/* Cheat. */
	if (r->rt == PF_FASTROUTE) {
		mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
		if (mtag == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
		ip6_output(m0, NULL, NULL, NULL, NULL, NULL);
		return;
	}

	if (ifp == NULL)
		goto bad;

	/*
	 * Do not fragment packets (yet).  Not much is done here for dealing
	 * with errors.  Actions on errors depend on whether the packet
	 * was generated locally or being forwarded.
	 */
	if (m0->m_pkthdr.len <= ifp->if_mtu) {
		error = (*ifp->if_output)(ifp, m0, (struct sockaddr *)dst,
		    NULL);
	} else
		m_freem(m0);

done:
	return;

bad:
	m_freem(m0);
	goto done;
}
#endif /* INET6 */

#ifdef INET
a4452 8
	if (r && r->rt) {
		pf_route(m, r);
		if (r->rt != PF_DUPTO) {
			/* m0 already freed */
			*m0 = NULL;
		}
	}

a4463 1
	/* XXX (pf_rule *)r may now be invalid from the above log */
d4515 6
a4520 1
	do {
d4522 1
a4522 1
		case IPPROTO_FRAGMENT:
d4532 1
a4532 1
			struct _opt6 opt6;
d4534 3
a4536 11
			if (!pf_pull_hdr(m, off, &opt6, sizeof(opt6),
			    NULL, NULL, pd.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: IPv6 short opt\n"));
				action = PF_DROP;
				REASON_SET(&reason, PFRES_SHORT);
				log = 1;
				goto done;
			}
			pd.proto = opt6.opt6_nxt;
			off += (opt6.opt6_hlen + 1) * 8;
d4559 2
a4560 2
		if (action == PF_DROP)
			break;
d4620 1
a4620 1
done:
a4622 8
	if (r && r->rt) {
		pf_route6(m, r);
		if (r->rt != PF_DUPTO) {
			/* m0 already freed */
			*m0 = NULL;
		}
	}

a4633 1
	/* XXX (pf_rule *)r may now be invalid from the above log */
@


1.95.2.4
log
@Merge in trunk
@
text
@d125 1
d129 1
a155 4
int			 pftm_other_first_packet = 60;	/* First packet */
int			 pftm_other_single = 30;	/* Unidirectional */
int			 pftm_other_multiple = 60;	/* Bidirectional */

a158 1
struct timeout		 pf_expire_to;			/* expire timeout */
d166 1
a166 2
				&pftm_other_first_packet, &pftm_other_single,
				&pftm_other_multiple, &pftm_frag, &pftm_interval };
a171 6
struct pf_pool_limit {
	void		*pp;
	unsigned	 limit;
} pf_pool_limits[PF_LIMIT_MAX] = { { &pf_state_pl, UINT_MAX },
				   { &pf_frent_pl, PFFRAG_FRENT_HIWAT } };

d174 2
a191 1
void			 pf_purge_timeout(void *);
a243 2
int			 pf_test_state_other(struct pf_state **, int,
			    struct ifnet *, struct pf_pdesc *);
d255 2
a256 2
void			 pf_route(struct mbuf **, struct pf_rule *, int);
void			 pf_route6(struct mbuf **, struct pf_rule *, int);
d289 4
d411 1
a411 2
	    a->ifnot != b->ifnot ||
	    a->no != b->no)
a430 5
	if (a->proto != b->proto ||
	    a->dnot != b->dnot ||
	    a->af != b->af ||
	    a->no != b->no)
		return (1);
d439 4
d459 1
a459 2
	    a->opts != b->opts ||
	    a->no != b->no)
a657 10
#ifdef INET
	if (af == AF_INET && dir == PF_OUT) {
		struct ip *ip;

		ip = mtod(m, struct ip *);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	}
#endif /* INET */

a788 14
pf_purge_timeout(void *arg)
{
	struct timeout *to = arg;
	int s;

	s = splsoftnet();
	pf_purge_expired_states();
	pf_purge_expired_fragments();
	splx(s);

	timeout_add(to, pftm_interval * hz);
}

void
d796 1
a796 1
		if (cur->state->expire <= time.tv_sec) {
d952 1
d954 1
a954 1
	    NULL);
d956 1
a956 1
	    &pool_allocator_nointr);
d958 1
a958 1
	    &pool_allocator_nointr);
d960 1
a960 1
	    &pool_allocator_nointr);
d962 1
a962 1
	    &pool_allocator_nointr);
d964 1
a964 1
	    NULL);
d966 1
a966 1
	    NULL);
a987 3
	timeout_set(&pf_expire_to, pf_purge_timeout, &pf_expire_to);
	timeout_add(&pf_expire_to, pftm_interval * hz);

d1013 3
d1019 21
a1039 41
		case DIOCGETRULES:
		case DIOCGETRULE:
		case DIOCGETNATS:
		case DIOCGETNAT:
		case DIOCGETBINATS:
		case DIOCGETBINAT:
		case DIOCGETRDRS:
		case DIOCGETRDR:
		case DIOCGETSTATE:
		case DIOCSETSTATUSIF:
		case DIOCGETSTATUS:
		case DIOCCLRSTATUS:
		case DIOCNATLOOK:
		case DIOCSETDEBUG:
		case DIOCGETSTATES:
		case DIOCGETTIMEOUT:
		case DIOCCLRRULECTRS:
		case DIOCGETLIMIT:
			break;
		default:
			return (EPERM);
		}

	if (!(flags & FWRITE))
		switch (cmd) {
		case DIOCGETRULES:
		case DIOCGETRULE:
		case DIOCGETNATS:
		case DIOCGETNAT:
		case DIOCGETRDRS:
		case DIOCGETRDR:
		case DIOCGETSTATE:
		case DIOCGETSTATUS:
		case DIOCGETSTATES:
		case DIOCGETTIMEOUT:
		case DIOCGETBINATS:
		case DIOCGETBINAT:
		case DIOCGETLIMIT:
			break;
		default:
			return (EACCES);
d1052 2
a1053 1
			pf_status.since = time.tv_sec;
a1247 9
			newrule->rt_ifp = NULL;
			if (newrule->rt_ifname[0]) {
				newrule->rt_ifp = ifunit(newrule->rt_ifname);
				if (newrule->rt_ifname == NULL) {
					pool_put(&pf_rule_pl, newrule);
					error = EINVAL;
					break;
				}
			}
a1909 20
	case DIOCADDSTATE: {
		struct pfioc_state *ps = (struct pfioc_state *)addr;
		struct pf_state *state;

		state = pool_get(&pf_state_pl, PR_NOWAIT);
		if (state == NULL) {
			error = ENOMEM;
			break;
		}
		s = splsoftnet();
		bcopy(&ps->state, state, sizeof(struct pf_state));
		state->rule = NULL;
		state->creation = time.tv_sec;
		state->expire += state->creation;
		state->packets = 0;
		state->bytes = 0;
		pf_insert_state(state);
		splx(s);
	}

a1913 1
		int secs;
d1929 3
a1931 3
		secs = time.tv_sec;
		ps->state.creation = secs - ps->state.creation;
		if (ps->state.expire <= secs)
d1934 1
a1934 1
			ps->state.expire -= secs;
d1957 1
a1961 2
			int secs = time.tv_sec;

d1963 2
a1964 2
			pstore.creation = secs - pstore.creation;
			if (pstore.expire <= secs)
d1967 1
a1967 1
				pstore.expire -= secs;
a2091 30
	case DIOCGETLIMIT: {
		struct pfioc_limit *pl = (struct pfioc_limit *)addr;

		if (pl->index < 0 || pl->index >= PF_LIMIT_MAX) {
			error = EINVAL;
			goto fail;
		}
		pl->limit = pf_pool_limits[pl->index].limit;
		break;
	}

	case DIOCSETLIMIT: {
		struct pfioc_limit *pl = (struct pfioc_limit *)addr;
		int old_limit;

		if (pl->index < 0 || pl->index >= PF_LIMIT_MAX) {
			error = EINVAL;
			goto fail;
		}
		if (pool_sethardlimit(pf_pool_limits[pl->index].pp,
		    pl->limit, NULL, 0) != 0) {
			error = EBUSY;
			goto fail;
		}
		old_limit = pf_pool_limits[pl->index].limit;
		pf_pool_limits[pl->index].limit = pl->limit;
		pl->limit = old_limit;
		break;
	}

a2097 11
	case DIOCCLRRULECTRS: {
		struct pf_rule *rule;

		s = splsoftnet();
		TAILQ_FOREACH(rule, pf_rules_active, entries)
			rule->evaluations = rule->packets =
			    rule->bytes = 0;
		splx(s);
		break;
	}

a2131 3
			PF_CALC_SKIP_STEP(PF_SKIP_ACTION,
			    (s->action == PF_SCRUB && r->action == PF_SCRUB) ||
			    (s->action != PF_SCRUB && r->action != PF_SCRUB));
a2132 2
			PF_CALC_SKIP_STEP(PF_SKIP_DIR,
			    s->direction == r->direction);
a2666 2
	if (nm && nm->no)
		return (NULL);
a2695 2
	if (bm && bm->no)
		return (NULL);
d2713 1
a2713 1
		    ((!r->dport2 && (!r->dport || dport == r->dport)) ||
a2719 2
	if (rm && rm->no)
		return (NULL);
d2782 1
a2782 1
			else if (rdr->rport)
a2783 2
			else
				nport = bport;
d2802 4
d2807 1
a2807 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION];
		else if (r->ifp != NULL && r->ifp != ifp)
a2808 2
		else if (r->direction != direction)
			r = r->skip[PF_SKIP_DIR];
d2825 2
d2842 2
a2843 3
		if ((*rm)->log) {
			if (rewrite)
				m_copyback(m, off, sizeof(*th), (caddr_t)th);
a2844 1
		}
d2945 2
a2946 2
		s->creation = time.tv_sec;
		s->expire = s->creation + pftm_tcp_first_packet;
d3005 1
a3005 1
			else if (rdr->rport)
a3006 2
			else
				nport = bport;
d3026 4
d3031 2
a3032 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION];
		else if (r->ifp != NULL && r->ifp != ifp)
a3033 2
		else if (r->direction != direction)
			r = r->skip[PF_SKIP_DIR];
d3052 2
d3067 2
a3068 3
		if ((*rm)->log) {
			if (rewrite)
				m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
a3069 1
		}
d3098 1
d3101 1
d3150 2
a3151 2
		s->creation = time.tv_sec;
		s->expire = s->creation + pftm_udp_first_packet;
a3169 1
	struct pf_rdr *rdr = NULL;
a3239 20
		/* check incoming packet for RDR */
		if ((rdr = pf_get_rdr(ifp, pd->proto,
		    saddr, daddr, 0, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&daddr->v4.s_addr,
				    pd->ip_sum, rdr->raddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				pf_change_a6(daddr, &pd->hdr.icmp6->icmp6_cksum,
				    &rdr->raddr, 0);
				rewrite++;
				break;
#endif /* INET6 */
			}
		}
d3241 1
a3241 1
		else if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_ICMP,
d3264 4
d3269 1
a3269 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION];
		else if (r->ifp != NULL && r->ifp != ifp)
a3270 2
		else if (r->direction != direction)
			r = r->skip[PF_SKIP_DIR];
d3281 2
d3302 2
a3303 6
		if ((*rm)->log) {
#ifdef INET6
			if (rewrite)
				m_copyback(m, off, ICMP_MINLEN,
				    (caddr_t)pd->hdr.icmp6);
#endif /* INET6 */
a3304 1
		}
d3310 1
a3310 2
	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL ||
	    rdr != NULL || binat != NULL) {
d3312 1
d3315 1
d3341 1
a3341 1
			if (binat != NULL || rdr != NULL)
d3357 2
a3358 2
		s->creation = time.tv_sec;
		s->expire = s->creation + pftm_icmp_first_packet;
a3378 1
	struct pf_nat *nat = NULL;
d3380 1
a3380 2
	struct pf_rdr *rdr = NULL;
	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
a3388 1
			PF_ACPY(&baddr, saddr, af);
a3402 18
		/* check outgoing packet for NAT */
		else if ((nat = pf_get_nat(ifp, pd->proto,
		    saddr, daddr, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&saddr->v4.s_addr,
				    pd->ip_sum, nat->raddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(saddr, &nat->raddr, af);
				break;
#endif /* INET6 */
			}
		}
a3403 18
		/* check incoming packet for RDR */
		if ((rdr = pf_get_rdr(ifp, pd->proto,
		    saddr, daddr, 0, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&daddr->v4.s_addr,
				    pd->ip_sum, rdr->raddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(daddr, &rdr->raddr, af);
				break;
#endif /* INET6 */
			}
		}
d3405 1
a3405 1
		else if ((binat = pf_get_binat(PF_IN, ifp, pd->proto,
a3406 1
			PF_ACPY(&baddr, daddr, af);
d3425 4
d3430 1
a3430 3
		if (r->action == PF_SCRUB)
			r = r->skip[PF_SKIP_ACTION];
		else if (r->ifp != NULL && r->ifp != ifp)
a3431 2
		else if (r->direction != direction)
			r = r->skip[PF_SKIP_DIR];
d3442 2
a3463 54

	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL ||
	    rdr != NULL || binat != NULL) {
		/* create new state */
		struct pf_state *s;

		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL)
			return (PF_DROP);

		s->rule = *rm;
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
		s->proto = pd->proto;
		s->direction = direction;
		s->af = af;
		if (direction == PF_OUT) {
			PF_ACPY(&s->gwy.addr, saddr, af);
			s->gwy.port = 0;
			PF_ACPY(&s->ext.addr, daddr, af);
			s->ext.port = 0;
			if (nat != NULL || binat != NULL)
				PF_ACPY(&s->lan.addr, &baddr, af);
			else
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
			s->lan.port = 0;
		} else {
			PF_ACPY(&s->lan.addr, daddr, af);
			s->lan.port = 0;
			PF_ACPY(&s->ext.addr, saddr, af);
			s->ext.port = 0;
			if (binat != NULL || rdr != NULL)
				PF_ACPY(&s->gwy.addr, &baddr, af);
			else
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
			s->gwy.port = 0;
		}
		s->src.seqlo = 0;
		s->src.seqhi = 0;
		s->src.seqdiff = 0;
		s->src.max_win = 0;
		s->src.state = 1;
		s->dst.seqlo = 0;
		s->dst.seqhi = 0;
		s->dst.seqdiff = 0;
		s->dst.max_win = 0;
		s->dst.state = 0;
		s->creation = time.tv_sec;
		s->expire = s->creation + pftm_other_first_packet;
		s->packets = 1;
		s->bytes = pd->tot_len;
		pf_insert_state(s);
	}

d3621 1
a3621 1
			(*state)->expire = time.tv_sec + pftm_tcp_closed;
d3624 1
a3624 1
			(*state)->expire = time.tv_sec + pftm_tcp_fin_wait;
d3627 1
a3627 1
			(*state)->expire = time.tv_sec + pftm_tcp_closing;
d3630 1
a3630 1
			(*state)->expire = time.tv_sec + pftm_tcp_opening;
d3632 1
a3632 1
			(*state)->expire = time.tv_sec + pftm_tcp_established;
d3727 1
a3727 1
			    (*state)->gwy.port, 0, pd->af);
d3786 1
a3786 1
		(*state)->expire = time.tv_sec + pftm_udp_multiple;
d3788 1
a3788 1
		(*state)->expire = time.tv_sec + pftm_udp_single;
d3873 1
a3873 1
		(*state)->expire = time.tv_sec + pftm_icmp_error_reply;
d3882 1
a3882 1
					    pd->ip_sum,
a4282 83
int
pf_test_state_other(struct pf_state **state, int direction, struct ifnet *ifp,
    struct pf_pdesc *pd)
{
	struct pf_state_peer *src, *dst;
	struct pf_tree_key key;

	key.af	    = pd->af;
	key.proto   = pd->proto;
	PF_ACPY(&key.addr[0], pd->src, key.af);
	PF_ACPY(&key.addr[1], pd->dst, key.af);
	key.port[0] = 0;
	key.port[1] = 0;

	if (direction == PF_IN)
		*state = pf_find_state(tree_ext_gwy, &key);
	else
		*state = pf_find_state(tree_lan_ext, &key);
	if (*state == NULL)
		return (PF_DROP);

	if (direction == (*state)->direction) {
		src = &(*state)->src;
		dst = &(*state)->dst;
	} else {
		src = &(*state)->dst;
		dst = &(*state)->src;
	}

	(*state)->packets++;
	(*state)->bytes += pd->tot_len;

	/* update states */
	if (src->state < 1)
		src->state = 1;
	if (dst->state == 1)
		dst->state = 2;

	/* update expire time */
	if (src->state == 2 && dst->state == 2)
		(*state)->expire = time.tv_sec + pftm_other_multiple;
	else
		(*state)->expire = time.tv_sec + pftm_other_single;

	/* translate source/destination address, if necessary */
	if (STATE_TRANSLATE(*state)) {
		if (direction == PF_OUT)
			switch (pd->af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&pd->src->v4.s_addr,
				    pd->ip_sum, (*state)->gwy.addr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(pd->src, &(*state)->gwy.addr, pd->af);
				break;
#endif /* INET6 */
			}
		else
			switch (pd->af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&pd->dst->v4.s_addr,
				    pd->ip_sum, (*state)->lan.addr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(pd->dst, &(*state)->lan.addr, pd->af);
				break;
#endif /* INET6 */
			}
	}

	if ((*state)->rule != NULL) {
		(*state)->rule->packets++;
		(*state)->rule->bytes += pd->tot_len;
	}
	return (PF_PASS);
}

d4333 1
a4333 1
pf_route(struct mbuf **m, struct pf_rule *r, int dir)
d4344 3
d4348 1
a4348 1
		m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT);
d4351 2
a4352 5
	} else {
		if (r->direction != dir)
			return;
		m0 = *m;
	}
a4516 2
	if (r->rt != PF_DUPTO)
		*m = NULL;
d4529 1
a4529 1
pf_route6(struct mbuf **m, struct pf_rule *r, int dir)
d4544 1
a4544 1
		m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT);
d4547 2
a4548 5
	} else {
		if (r->direction != dir)
			return;
		m0 = *m;
	}
a4586 2
	if (r->rt != PF_DUPTO)
		*m = NULL;
d4616 8
d4719 1
a4719 6
		action = pf_test_state_other(&s, dir, ifp, &pd);
		if (action == PF_PASS) {
			r = s->rule;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_other(&r, dir, ifp, m, h, &pd);
d4738 8
d4747 2
a4749 1
			struct pf_rule r0;
d4753 3
a4755 3
			PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, &r0);
		} else
			PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r);
d4757 1
a4757 5

	/* pf_route can free the mbuf causing *m0 to become NULL */
	if (r && r->rt)
		pf_route(m0, r, dir);

d4783 8
d4920 8
d4929 2
a4931 1
			struct pf_rule r0;
d4935 3
a4937 3
			PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, &r0);
		} else
			PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r);
d4939 1
a4939 5

	/* pf_route6 can free the mbuf causing *m0 to become NULL */
	if (r && r->rt)
		pf_route6(m0, r, dir);

@


1.95.2.5
log
@Merge in -current from roughly a week ago
@
text
@d2751 1
a2751 1
		cut = arc4random() % (1 + high - low) + low;
d2754 1
a2754 1
		cut = arc4random() % (1 + low - high) + high;
@


1.95.2.6
log
@Sync the SMP branch with 3.3
@
text
@a30 4
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a32 4
#include "bpfilter.h"
#include "pflog.h"
#include "pfsync.h"

d37 1
a38 1
#include <sys/socketvar.h>
d40 1
d48 1
a63 1
#include <netinet/icmp_var.h>
d67 3
a69 2
#include <net/if_pflog.h>
#include <net/if_pfsync.h>
a76 3
#ifdef ALTQ
#include <altq/if_altq.h>
#endif
d78 5
d84 23
a106 2
#define DPFPRINTF(n, x)	if (pf_status.debug >= (n)) printf x
struct pf_state_tree;
d112 13
a124 6
struct pf_anchorqueue	 pf_anchors;
struct pf_ruleset	 pf_main_ruleset;
struct pf_altqqueue	 pf_altqs[2];
struct pf_palist	 pf_pabuf;
struct pf_altqqueue	*pf_altqs_active;
struct pf_altqqueue	*pf_altqs_inactive;
d128 10
a137 3
u_int32_t		 ticket_altqs_active;
u_int32_t		 ticket_altqs_inactive;
u_int32_t		 ticket_pabuf;
d142 1
a142 1
int			 pftm_tcp_established = 24*60*60;  /* established */
d170 1
a170 2
				&pftm_other_multiple, &pftm_frag,
				&pftm_interval };
d173 2
a174 2
struct pool		 pf_tree_pl, pf_rule_pl, pf_addr_pl;
struct pool		 pf_state_pl, pf_altq_pl, pf_pooladdr_pl;
d176 8
d185 14
a198 4
			    sa_family_t);
int			 pf_insert_state(struct pf_state *);
struct pf_state		*pf_find_state(struct pf_state_tree *,
			    struct pf_tree_node *);
d201 1
a201 3
int			 pf_tbladdr_setup(struct pf_addr_wrap *);
void			 pf_tbladdr_remove(struct pf_addr_wrap *);
void			 pf_dynaddr_update(void *);
d206 5
d215 1
a215 1
			    u_int16_t, u_int8_t, sa_family_t);
d225 1
a225 1
			    u_int16_t *, u_int8_t, sa_family_t);
d227 17
a243 26
			    struct pf_pdesc *, sa_family_t, u_int8_t,
			    struct pf_rule *);
void			 pf_send_icmp(struct mbuf *, u_int8_t, u_int8_t,
			    sa_family_t, struct pf_rule *);
struct pf_rule		*pf_match_translation(int, struct ifnet *, u_int8_t,
			    struct pf_addr *, u_int16_t, struct pf_addr *,
			    u_int16_t, sa_family_t, int);
struct pf_rule		*pf_get_translation(int, struct ifnet *, u_int8_t,
			    struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t *, sa_family_t);
int			 pf_test_tcp(struct pf_rule **, struct pf_state **, int,
			    struct ifnet *, struct mbuf *, int, int, void *,
			    struct pf_pdesc *);
int			 pf_test_udp(struct pf_rule **, struct pf_state **, int,
			    struct ifnet *, struct mbuf *, int, int, void *,
			    struct pf_pdesc *);
int			 pf_test_icmp(struct pf_rule **, struct pf_state **,
			    int, struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *);
int			 pf_test_other(struct pf_rule **, struct pf_state **,
			    int, struct ifnet *, struct mbuf *, void *,
			    struct pf_pdesc *);
int			 pf_test_fragment(struct pf_rule **, int,
			    struct ifnet *, struct mbuf *, void *,
			    struct pf_pdesc *);
d256 1
a256 1
			    u_short *, u_short *, sa_family_t);
d259 5
a263 14
#ifdef INET6
void			 pf_poolmask(struct pf_addr *, struct pf_addr*,
			    struct pf_addr *, struct pf_addr *, u_int8_t);
void			 pf_addr_inc(struct pf_addr *, sa_family_t);
#endif /* INET6 */

void			 pf_hash(struct pf_addr *, struct pf_addr *,
			    struct pf_poolhashkey *, sa_family_t);
int			 pf_map_addr(u_int8_t, struct pf_pool *,
			    struct pf_addr *, struct pf_addr *,
			    struct pf_addr *);
int			 pf_get_sport(sa_family_t, u_int8_t, struct pf_pool *,
			    struct pf_addr *, struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t*, u_int16_t, u_int16_t);
d265 17
a281 32
			    int, int, void *, struct pf_pdesc *);
void			 pf_route(struct mbuf **, struct pf_rule *, int,
			    struct ifnet *, struct pf_state *);
void			 pf_route6(struct mbuf **, struct pf_rule *, int,
			    struct ifnet *, struct pf_state *);
int			 pf_socket_lookup(uid_t *, gid_t *, int, sa_family_t,
			    int, struct pf_pdesc *);
u_int8_t		 pf_get_wscale(struct mbuf *, int, u_int16_t,
			    sa_family_t);
int			 pf_check_proto_cksum(struct mbuf *, int, int,
			    u_int8_t, sa_family_t);

struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] =
    { { &pf_state_pl, PFSTATE_HIWAT }, { &pf_frent_pl, PFFRAG_FRENT_HIWAT } };

#define STATE_LOOKUP()							\
	do {								\
		if (direction == PF_IN)					\
			*state = pf_find_state(&tree_ext_gwy, &key);	\
		else							\
			*state = pf_find_state(&tree_lan_ext, &key);	\
		if (*state == NULL)					\
			return (PF_DROP);				\
		if (direction == PF_OUT &&				\
		    (*state)->rule.ptr != NULL &&			\
		    (((*state)->rule.ptr->rt == PF_ROUTETO &&		\
		    (*state)->rule.ptr->direction == PF_OUT) ||		\
		    ((*state)->rule.ptr->rt == PF_REPLYTO &&		\
		    (*state)->rule.ptr->direction == PF_IN)) &&		\
		    (*state)->rt_ifp != NULL &&				\
		    (*state)->rt_ifp != ifp)				\
			return (PF_PASS);				\
d283 3
d295 2
a296 11
#define TIMEOUT(r,i) \
	(((r) && (r)->timeout[(i)]) ? (r)->timeout[(i)] : *pftm_timeouts[(i)])

static __inline int pf_state_compare(struct pf_tree_node *,
			struct pf_tree_node *);

struct pf_state_tree tree_lan_ext, tree_ext_gwy;
RB_GENERATE(pf_state_tree, pf_tree_node, entry, pf_state_compare);

static __inline int
pf_state_compare(struct pf_tree_node *a, struct pf_tree_node *b)
d298 1
a298 1
	int	diff;
d308 1
a308 1
			return (1);
d310 1
a310 1
			return (-1);
d312 1
a312 1
			return (1);
d314 1
a314 1
			return (-1);
d320 1
a320 1
			return (1);
d322 1
a322 1
			return (-1);
d324 1
a324 1
			return (1);
d326 1
a326 1
			return (-1);
d328 1
a328 1
			return (1);
d330 1
a330 1
			return (-1);
d332 1
a332 1
			return (1);
d334 1
a334 1
			return (-1);
d336 1
a336 1
			return (1);
d338 1
a338 1
			return (-1);
d340 1
a340 1
			return (1);
d342 1
a342 1
			return (-1);
d344 1
a344 1
			return (1);
d346 1
a346 1
			return (-1);
d348 1
a348 1
			return (1);
d350 1
a350 1
			return (-1);
d365 1
a365 1
pf_addrcpy(struct pf_addr *dst, struct pf_addr *src, sa_family_t af)
d367 1
a367 1
	switch (af) {
d383 30
a412 2
struct pf_state *
pf_find_state(struct pf_state_tree *tree, struct pf_tree_node *key)
d414 21
a434 1
	struct pf_tree_node	*k;
d436 19
a454 6
	pf_status.fcounters[FCNT_STATE_SEARCH]++;
	k = RB_FIND(pf_state_tree, tree, key);
	if (k)
		return (k->state);
	else
		return (NULL);
d458 50
a507 1
pf_insert_state(struct pf_state *state)
d509 1
a509 1
	struct pf_tree_node	*keya, *keyb;
d511 20
a530 10
	keya = pool_get(&pf_tree_pl, PR_NOWAIT);
	if (keya == NULL)
		return (-1);
	keya->state = state;
	keya->proto = state->proto;
	keya->af = state->af;
	PF_ACPY(&keya->addr[0], &state->lan.addr, state->af);
	keya->port[0] = state->lan.port;
	PF_ACPY(&keya->addr[1], &state->ext.addr, state->af);
	keya->port[1] = state->ext.port;
d532 31
a562 14
	/* Thou MUST NOT insert multiple duplicate keys */
	if (RB_INSERT(pf_state_tree, &tree_lan_ext, keya) != NULL) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: tree_lan_ext");
			printf(" lan: ");
			pf_print_host(&state->lan.addr, state->lan.port,
			    state->af);
			printf(" gwy: ");
			pf_print_host(&state->gwy.addr, state->gwy.port,
			    state->af);
			printf(" ext: ");
			pf_print_host(&state->ext.addr, state->ext.port,
			    state->af);
			printf("\n");
a563 2
		pool_put(&pf_tree_pl, keya);
		return (-1);
d565 42
d608 15
a622 14
	keyb = pool_get(&pf_tree_pl, PR_NOWAIT);
	if (keyb == NULL) {
		/* Need to pull out the other state */
		RB_REMOVE(pf_state_tree, &tree_lan_ext, keya);
		pool_put(&pf_tree_pl, keya);
		return (-1);
	}
	keyb->state = state;
	keyb->proto = state->proto;
	keyb->af = state->af;
	PF_ACPY(&keyb->addr[0], &state->ext.addr, state->af);
	keyb->port[0] = state->ext.port;
	PF_ACPY(&keyb->addr[1], &state->gwy.addr, state->af);
	keyb->port[1] = state->gwy.port;
d624 19
a642 13
	if (RB_INSERT(pf_state_tree, &tree_ext_gwy, keyb) != NULL) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: tree_ext_gwy");
			printf(" lan: ");
			pf_print_host(&state->lan.addr, state->lan.port,
			    state->af);
			printf(" gwy: ");
			pf_print_host(&state->gwy.addr, state->gwy.port,
			    state->af);
			printf(" ext: ");
			pf_print_host(&state->ext.addr, state->ext.port,
			    state->af);
			printf("\n");
a643 4
		RB_REMOVE(pf_state_tree, &tree_lan_ext, keya);
		pool_put(&pf_tree_pl, keya);
		pool_put(&pf_tree_pl, keyb);
		return (-1);
d645 1
a645 7

	pf_status.fcounters[FCNT_STATE_INSERT]++;
	pf_status.states++;
#if NPFSYNC
	pfsync_insert_state(state);
#endif
	return (0);
d648 3
a650 2
void
pf_purge_timeout(void *arg)
d652 4
a655 2
	struct timeout	*to = arg;
	int		 s;
d657 2
a658 4
	s = splsoftnet();
	pf_purge_expired_states();
	pf_purge_expired_fragments();
	splx(s);
d660 2
a661 2
	timeout_add(to, pftm_interval * hz);
}
d663 4
a666 5
void
pf_purge_expired_states(void)
{
	struct pf_tree_node	*cur, *peer, *next;
	struct pf_tree_node	 key;
d668 3
a670 2
	for (cur = RB_MIN(pf_state_tree, &tree_ext_gwy); cur; cur = next) {
		next = RB_NEXT(pf_state_tree, &tree_ext_gwy, cur);
d672 5
a676 2
		if (cur->state->expire <= (unsigned)time.tv_sec) {
			RB_REMOVE(pf_state_tree, &tree_ext_gwy, cur);
d678 3
a680 10
			/* Need this key's peer (in the other tree) */
			key.state = cur->state;
			key.proto = cur->state->proto;
			key.af = cur->state->af;
			PF_ACPY(&key.addr[0], &cur->state->lan.addr,
			    cur->state->af);
			key.port[0] = cur->state->lan.port;
			PF_ACPY(&key.addr[1], &cur->state->ext.addr,
			    cur->state->af);
			key.port[1] = cur->state->ext.port;
d682 1
a682 4
			peer = RB_FIND(pf_state_tree, &tree_lan_ext, &key);
			KASSERT(peer);
			KASSERT(peer->state == cur->state);
			RB_REMOVE(pf_state_tree, &tree_lan_ext, peer);
d684 2
a685 2
#if NPFSYNC
			pfsync_delete_state(cur->state);
d687 32
a718 9
			if (cur->state->rule.ptr != NULL)
				cur->state->rule.ptr->states--;
			if (cur->state->nat_rule != NULL)
				cur->state->nat_rule->states--;
			pool_put(&pf_state_pl, cur->state);
			pool_put(&pf_tree_pl, cur);
			pool_put(&pf_tree_pl, peer);
			pf_status.fcounters[FCNT_STATE_REMOVALS]++;
			pf_status.states--;
d721 1
d724 2
a725 2
int
pf_tbladdr_setup(struct pf_addr_wrap *aw)
d727 9
a735 5
	if (aw->type != PF_ADDR_TABLE)
		return (0);
	if ((aw->p.tbl = pfr_attach_table(aw->v.tblname)) == NULL)
		return (1);
	return (0);
d738 2
a739 2
void
pf_tbladdr_remove(struct pf_addr_wrap *aw)
d741 5
a745 4
	if (aw->type != PF_ADDR_TABLE || aw->p.tbl == NULL)
		return;
	pfr_detach_table(aw->p.tbl);
	aw->p.tbl = NULL;
d749 1
a749 1
pf_tbladdr_copyout(struct pf_addr_wrap *aw)
d751 2
a752 5
	if (aw->type != PF_ADDR_TABLE || aw->p.tbl == NULL)
		return;
	aw->p.tblcnt = (aw->p.tbl->pfrkt_flags & PFR_TFLAG_ACTIVE) ?
		aw->p.tbl->pfrkt_cnt : -1;
}
d754 49
a802 14
int
pf_dynaddr_setup(struct pf_addr_wrap *aw, sa_family_t af)
{
	if (aw->type != PF_ADDR_DYNIFTL)
		return (0);
	aw->p.dyn = pool_get(&pf_addr_pl, PR_NOWAIT);
	if (aw->p.dyn == NULL)
		return (1);
	bcopy(aw->v.ifname, aw->p.dyn->ifname, sizeof(aw->p.dyn->ifname));
	aw->p.dyn->ifp = ifunit(aw->p.dyn->ifname);
	if (aw->p.dyn->ifp == NULL) {
		pool_put(&pf_addr_pl, aw->p.dyn);
		aw->p.dyn = NULL;
		return (1);
d804 2
a805 13
	aw->p.dyn->addr = &aw->v.a.addr;
	aw->p.dyn->af = af;
	aw->p.dyn->undefined = 1;
	aw->p.dyn->hook_cookie = hook_establish(
	    aw->p.dyn->ifp->if_addrhooks, 1,
	    pf_dynaddr_update, aw->p.dyn);
	if (aw->p.dyn->hook_cookie == NULL) {
		pool_put(&pf_addr_pl, aw->p.dyn);
		aw->p.dyn = NULL;
		return (1);
	}
	pf_dynaddr_update(aw->p.dyn);
	return (0);
d809 1
a809 1
pf_dynaddr_update(void *p)
d811 2
a812 3
	struct pf_addr_dyn	*ad = (struct pf_addr_dyn *)p;
	struct ifaddr		*ia;
	int			 s, changed = 0;
a813 2
	if (ad == NULL || ad->ifp == NULL)
		panic("pf_dynaddr_update");
d815 3
a817 16
	TAILQ_FOREACH(ia, &ad->ifp->if_addrlist, ifa_list)
		if (ia->ifa_addr != NULL &&
		    ia->ifa_addr->sa_family == ad->af) {
			if (ad->af == AF_INET) {
				struct in_addr *a, *b;

				a = &ad->addr->v4;
				b = &((struct sockaddr_in *)ia->ifa_addr)
				    ->sin_addr;
				if (ad->undefined ||
				    memcmp(a, b, sizeof(*a))) {
					bcopy(b, a, sizeof(*a));
					changed = 1;
				}
			} else if (ad->af == AF_INET6) {
				struct in6_addr *a, *b;
d819 1
a819 16
				a = &ad->addr->v6;
				b = &((struct sockaddr_in6 *)ia->ifa_addr)
				    ->sin6_addr;
				if (ad->undefined ||
				    memcmp(a, b, sizeof(*a))) {
					bcopy(b, a, sizeof(*a));
					changed = 1;
				}
			}
			if (changed)
				ad->undefined = 0;
			break;
		}
	if (ia == NULL)
		ad->undefined = 1;
	splx(s);
d823 1
a823 1
pf_dynaddr_remove(struct pf_addr_wrap *aw)
d825 2
a826 7
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL)
		return;
	hook_disestablish(aw->p.dyn->ifp->if_addrhooks,
	    aw->p.dyn->hook_cookie);
	pool_put(&pf_addr_pl, aw->p.dyn);
	aw->p.dyn = NULL;
}
d828 46
a873 7
void
pf_dynaddr_copyout(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL)
		return;
	bcopy(aw->p.dyn->ifname, aw->v.ifname, sizeof(aw->v.ifname));
	aw->p.dyn = (struct pf_addr_dyn *)1;
d877 1
a877 1
pf_print_host(struct pf_addr *addr, u_int16_t p, sa_family_t af)
d879 1
a879 1
	switch (af) {
d883 3
a885 6
		printf("%u.%u.%u.%u", (a>>24)&255, (a>>16)&255,
		    (a>>8)&255, a&255);
		if (p) {
			p = ntohs(p);
			printf(":%u", p);
		}
d927 2
a928 4
		if (p) {
			p = ntohs(p);
			printf("[%u]", p);
		}
a947 3
	case IPPROTO_ICMPV6:
		printf("ICMPV6 ");
		break;
d957 1
a957 1
	printf(" [lo=%u high=%u win=%u modulator=%u", s->src.seqlo,
d959 1
a959 4
	if (s->src.wscale && s->dst.wscale)
		printf(" wscale=%u", s->src.wscale & PF_WSCALE_MASK);
	printf("]");
	printf(" [lo=%u high=%u win=%u modulator=%u", s->dst.seqlo,
a960 3
	if (s->src.wscale && s->dst.wscale)
		printf(" wscale=%u", s->dst.wscale & PF_WSCALE_MASK);
	printf("]");
a980 4
	if (f & TH_ECE)
		printf("E");
	if (f & TH_CWR)
		printf("W");
a982 8
#define	PF_SET_SKIP_STEPS(i)					\
	do {							\
		while (head[i] != cur) {			\
			head[i]->skip[i].ptr = cur;		\
			head[i] = TAILQ_NEXT(head[i], entries);	\
		}						\
	} while (0)

d984 1
a984 1
pf_calc_skip_steps(struct pf_rulequeue *rules)
d986 31
a1016 2
	struct pf_rule *cur, *prev, *head[PF_SKIP_COUNT];
	int i;
d1018 2
a1019 5
	cur = TAILQ_FIRST(rules);
	prev = cur;
	for (i = 0; i < PF_SKIP_COUNT; ++i)
		head[i] = cur;
	while (cur != NULL) {
d1021 2
a1022 40
		if (cur->ifp != prev->ifp || cur->ifnot != prev->ifnot)
			PF_SET_SKIP_STEPS(PF_SKIP_IFP);
		if (cur->direction != prev->direction)
			PF_SET_SKIP_STEPS(PF_SKIP_DIR);
		if (cur->af != prev->af)
			PF_SET_SKIP_STEPS(PF_SKIP_AF);
		if (cur->proto != prev->proto)
			PF_SET_SKIP_STEPS(PF_SKIP_PROTO);
		if (cur->src.addr.type == PF_ADDR_DYNIFTL ||
		    prev->src.addr.type == PF_ADDR_DYNIFTL ||
		    cur->src.addr.type == PF_ADDR_TABLE ||
		    prev->src.addr.type == PF_ADDR_TABLE ||
		    cur->src.not != prev->src.not ||
		    (cur->src.addr.type == PF_ADDR_NOROUTE) !=
		    (prev->src.addr.type == PF_ADDR_NOROUTE) ||
		    !PF_AEQ(&cur->src.addr.v.a.addr,
		    &prev->src.addr.v.a.addr, 0) ||
		    !PF_AEQ(&cur->src.addr.v.a.mask,
		    &prev->src.addr.v.a.mask, 0))
			PF_SET_SKIP_STEPS(PF_SKIP_SRC_ADDR);
		if (cur->src.port[0] != prev->src.port[0] ||
		    cur->src.port[1] != prev->src.port[1] ||
		    cur->src.port_op != prev->src.port_op)
			PF_SET_SKIP_STEPS(PF_SKIP_SRC_PORT);
		if (cur->dst.addr.type == PF_ADDR_DYNIFTL ||
		    prev->dst.addr.type == PF_ADDR_DYNIFTL ||
		    cur->dst.addr.type == PF_ADDR_TABLE ||
		    prev->dst.addr.type == PF_ADDR_TABLE ||
		    cur->dst.not != prev->dst.not ||
		    (cur->dst.addr.type == PF_ADDR_NOROUTE) !=
		    (prev->dst.addr.type == PF_ADDR_NOROUTE) ||
		    !PF_AEQ(&cur->dst.addr.v.a.addr,
		    &prev->dst.addr.v.a.addr, 0) ||
		    !PF_AEQ(&cur->dst.addr.v.a.mask,
		    &prev->dst.addr.v.a.mask, 0))
			PF_SET_SKIP_STEPS(PF_SKIP_DST_ADDR);
		if (cur->dst.port[0] != prev->dst.port[0] ||
		    cur->dst.port[1] != prev->dst.port[1] ||
		    cur->dst.port_op != prev->dst.port_op)
			PF_SET_SKIP_STEPS(PF_SKIP_DST_PORT);
d1024 1
a1024 5
		prev = cur;
		cur = TAILQ_NEXT(cur, entries);
	}
	for (i = 0; i < PF_SKIP_COUNT; ++i)
		PF_SET_SKIP_STEPS(i);
d1027 2
a1028 2
void
pf_update_anchor_rules()
d1030 4
a1033 2
	struct pf_rule	*rule;
	int		 i;
d1035 6
a1040 7
	for (i = 0; i < PF_RULESET_MAX; ++i)
		TAILQ_FOREACH(rule, pf_main_ruleset.rules[i].active.ptr,
		    entries)
			if (rule->anchorname[0])
				rule->anchor = pf_find_anchor(rule->anchorname);
			else
				rule->anchor = NULL;
d1043 2
a1044 2
u_int16_t
pf_cksum_fixup(u_int16_t cksum, u_int16_t old, u_int16_t new, u_int8_t udp)
d1046 1244
a2289 1
	u_int32_t	l;
d2292 1
a2292 1
		return (0x0000);
d2297 1
a2297 1
		return (0xFFFF);
d2303 1
a2303 1
    struct pf_addr *an, u_int16_t pn, u_int8_t u, sa_family_t af)
d2305 2
a2306 2
	struct pf_addr	ao;
	u_int16_t	po = *p;
d2348 1
a2348 1
	u_int32_t	ao = *a;
d2352 1
a2352 1
	    ao % 65536, an % 65536, u);
d2359 1
a2359 1
	struct pf_addr	ao;
d2381 1
a2381 1
    u_int16_t *ic, u_int16_t *hc, u_int8_t u, sa_family_t af)
d2383 3
a2385 3
	struct pf_addr	oia, ooa;
	u_int32_t	opc;
	u_int16_t	oip = *ip;
d2400 1
a2400 1
	/* Change inner ip address, fix inner ipv4 and icmp checksums. */
d2403 1
a2403 3
	case AF_INET: {
		u_int32_t	 oh2c = *h2c;

a2409 1
		*ic = pf_cksum_fixup(*ic, oh2c, *h2c, 0);
a2410 1
	}
d2428 1
d2458 1
a2458 2
pf_send_reset(int off, struct tcphdr *th, struct pf_pdesc *pd, sa_family_t af,
    u_int8_t return_ttl, struct pf_rule *r)
d2460 3
a2462 3
	struct mbuf	*m;
	struct m_tag	*mtag;
	int		 len;
d2464 1
a2464 1
	struct ip	*h2;
d2467 1
a2467 1
	struct ip6_hdr	*h2_6;
d2469 1
a2469 1
	struct tcphdr	*th2;
a2547 16
#ifdef ALTQ
	if (r != NULL && r->qid) {
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m, struct ip *);
			m_tag_prepend(m, mtag);
		}
	}
#endif

d2557 1
a2557 3
		if (!return_ttl)
			return_ttl = ip_defttl;
		h2->ip_ttl = return_ttl;
d2560 2
a2561 3
		h2->ip_off = ip_mtudisc ? IP_DF : 0;
		ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL,
		    (void *)NULL);
d2571 1
a2571 3
		if (!return_ttl)
			return_ttl = IPV6_DEFHLIM;
		h2_6->ip6_hlim = return_ttl;
d2579 1
a2579 2
pf_send_icmp(struct mbuf *m, u_int8_t type, u_int8_t code, sa_family_t af,
    struct pf_rule *r)
d2581 2
a2582 2
	struct m_tag	*mtag;
	struct mbuf	*m0;
a2592 17

#ifdef ALTQ
	if (r != NULL && r->qid) {
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m0, struct ip *);
			m_tag_prepend(m0, mtag);
		}
	}
#endif

d2614 1
a2614 1
    struct pf_addr *b, sa_family_t af)
d2616 1
a2616 2
	int	match = 0;

d2653 1
a2653 1
pf_match(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
d2655 3
d2660 1
a2660 1
		return ((p > a1) && (p < a2));
d2662 1
a2662 3
		return ((p < a1) || (p > a2));
	case PF_OP_RRG:
		return ((p >= a1) && (p <= a2));
d2676 1
a2676 171
	return (0); /* never reached */
}

int
pf_match_port(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
{
	NTOHS(a1);
	NTOHS(a2);
	NTOHS(p);
	return (pf_match(op, a1, a2, p));
}

int
pf_match_uid(u_int8_t op, uid_t a1, uid_t a2, uid_t u)
{
	if (u == UID_MAX && op != PF_OP_EQ && op != PF_OP_NE)
		return (0);
	return (pf_match(op, a1, a2, u));
}

int
pf_match_gid(u_int8_t op, gid_t a1, gid_t a2, gid_t g)
{
	if (g == GID_MAX && op != PF_OP_EQ && op != PF_OP_NE)
		return (0);
	return (pf_match(op, a1, a2, g));
}

#define PF_STEP_INTO_ANCHOR(r, a, s, n)					\
	do {								\
		if ((r) == NULL || (r)->anchor == NULL ||		\
		    (s) != NULL || (a) != NULL)				\
			panic("PF_STEP_INTO_ANCHOR");			\
		(a) = (r);						\
		(s) = TAILQ_FIRST(&(r)->anchor->rulesets);		\
		(r) = NULL;						\
		while ((s) != NULL && ((r) =				\
		    TAILQ_FIRST((s)->rules[n].active.ptr)) == NULL)	\
			(s) = TAILQ_NEXT((s), entries);			\
		if ((r) == NULL) {					\
			(r) = TAILQ_NEXT((a), entries);			\
			(a) = NULL;					\
		}							\
	} while (0)

#define PF_STEP_OUT_OF_ANCHOR(r, a, s, n)				\
	do {								\
		if ((r) != NULL || (a) == NULL || (s) == NULL)		\
			panic("PF_STEP_OUT_OF_ANCHOR");			\
		(s) = TAILQ_NEXT((s), entries);				\
		while ((s) != NULL && ((r) =				\
		    TAILQ_FIRST((s)->rules[n].active.ptr)) == NULL)	\
			(s) = TAILQ_NEXT((s), entries);			\
		if ((r) == NULL) {					\
			(r) = TAILQ_NEXT((a), entries);			\
			(a) = NULL;					\
		}							\
	} while (0)

#ifdef INET6
void
pf_poolmask(struct pf_addr *naddr, struct pf_addr *raddr,
    struct pf_addr *rmask, struct pf_addr *saddr, sa_family_t af)
{
	switch (af) {
#ifdef INET
	case AF_INET:
		naddr->addr32[0] = (raddr->addr32[0] & rmask->addr32[0]) |
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]);
		break;
#endif /* INET */
	case AF_INET6:
		naddr->addr32[0] = (raddr->addr32[0] & rmask->addr32[0]) |
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]);
		naddr->addr32[1] = (raddr->addr32[1] & rmask->addr32[1]) |
		((rmask->addr32[1] ^ 0xffffffff ) & saddr->addr32[1]);
		naddr->addr32[2] = (raddr->addr32[2] & rmask->addr32[2]) |
		((rmask->addr32[2] ^ 0xffffffff ) & saddr->addr32[2]);
		naddr->addr32[3] = (raddr->addr32[3] & rmask->addr32[3]) |
		((rmask->addr32[3] ^ 0xffffffff ) & saddr->addr32[3]);
		break;
	}
}

void
pf_addr_inc(struct pf_addr *addr, u_int8_t af)
{
	switch (af) {
#ifdef INET
	case AF_INET:
		addr->addr32[0] = htonl(ntohl(addr->addr32[0]) + 1);
		break;
#endif /* INET */
	case AF_INET6:
		if (addr->addr32[3] == 0xffffffff) {
			addr->addr32[3] = 0;
			if (addr->addr32[2] == 0xffffffff) {
				addr->addr32[2] = 0;
				if (addr->addr32[1] == 0xffffffff) {
					addr->addr32[1] = 0;
					addr->addr32[0] =
					    htonl(ntohl(addr->addr32[0]) + 1);
				} else
					addr->addr32[1] =
					    htonl(ntohl(addr->addr32[1]) + 1);
			} else
				addr->addr32[2] =
				    htonl(ntohl(addr->addr32[2]) + 1);
		} else
			addr->addr32[3] =
			    htonl(ntohl(addr->addr32[3]) + 1);
		break;
	}
}
#endif /* INET6 */

#define mix(a,b,c) \
	do {					\
		a -= b; a -= c; a ^= (c >> 13);	\
		b -= c; b -= a; b ^= (a << 8);	\
		c -= a; c -= b; c ^= (b >> 13);	\
		a -= b; a -= c; a ^= (c >> 12);	\
		b -= c; b -= a; b ^= (a << 16);	\
		c -= a; c -= b; c ^= (b >> 5);	\
		a -= b; a -= c; a ^= (c >> 3);	\
		b -= c; b -= a; b ^= (a << 10);	\
		c -= a; c -= b; c ^= (b >> 15);	\
	} while (0)

/*
 * hash function based on bridge_hash in if_bridge.c
 */
void
pf_hash(struct pf_addr *inaddr, struct pf_addr *hash,
    struct pf_poolhashkey *key, sa_family_t af)
{
	u_int32_t	a = 0x9e3779b9, b = 0x9e3779b9, c = key->key32[0];

	switch (af) {
#ifdef INET
	case AF_INET:
		a += inaddr->addr32[0];
		b += key->key32[1];
		mix(a, b, c);
		hash->addr32[0] = c + key->key32[2];
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		a += inaddr->addr32[0];
		b += inaddr->addr32[2];
		mix(a, b, c);
		hash->addr32[0] = c;
		a += inaddr->addr32[1];
		b += inaddr->addr32[3];
		c += key->key32[1];
		mix(a, b, c);
		hash->addr32[1] = c;
		a += inaddr->addr32[2];
		b += inaddr->addr32[1];
		c += key->key32[2];
		mix(a, b, c);
		hash->addr32[2] = c;
		a += inaddr->addr32[3];
		b += inaddr->addr32[0];
		c += key->key32[3];
		mix(a, b, c);
		hash->addr32[3] = c;
		break;
#endif /* INET6 */
	}
d2680 1
a2680 2
pf_map_addr(u_int8_t af, struct pf_pool *rpool, struct pf_addr *saddr,
    struct pf_addr *naddr, struct pf_addr *init_addr)
d2682 1
a2682 3
	unsigned char		 hash[16];
	struct pf_addr		*raddr = &rpool->cur->addr.addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.addr.v.a.mask;
d2684 3
a2686 75
	if (rpool->cur->addr.addr.type == PF_ADDR_NOROUTE ||
	    rpool->cur->addr.addr.type == PF_ADDR_TABLE)
		return (1);
	if (rpool->cur->addr.addr.type == PF_ADDR_DYNIFTL &&
	    rpool->cur->addr.addr.p.dyn->undefined)
		return (1);

	switch (rpool->opts & PF_POOL_TYPEMASK) {
	case PF_POOL_NONE:
		PF_ACPY(naddr, raddr, af);
		break;
	case PF_POOL_BITMASK:
		PF_POOLMASK(naddr, raddr, rmask, saddr, af);
		break;
	case PF_POOL_RANDOM:
		if (init_addr != NULL && PF_AZERO(init_addr, af)) {
			switch (af) {
#ifdef INET
			case AF_INET:
				rpool->counter.addr32[0] = arc4random();
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				if (rmask->addr32[3] != 0xffffffff)
					rpool->counter.addr32[3] = arc4random();
				else
					break;
				if (rmask->addr32[2] != 0xffffffff)
					rpool->counter.addr32[2] = arc4random();
				else
					break;
				if (rmask->addr32[1] != 0xffffffff)
					rpool->counter.addr32[1] = arc4random();
				else
					break;
				if (rmask->addr32[0] != 0xffffffff)
					rpool->counter.addr32[0] = arc4random();
				break;
#endif /* INET6 */
			}
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af);
			PF_ACPY(init_addr, naddr, af);

		} else {
			PF_AINC(&rpool->counter, af);
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af);
		}
		break;
	case PF_POOL_SRCHASH:
		pf_hash(saddr, (struct pf_addr *)&hash, &rpool->key, af);
		PF_POOLMASK(naddr, raddr, rmask, (struct pf_addr *)&hash, af);
		break;
	case PF_POOL_ROUNDROBIN:
		if (pf_match_addr(0, &rpool->cur->addr.addr.v.a.addr,
		    &rpool->cur->addr.addr.v.a.mask, &rpool->counter, af)) {
			PF_ACPY(naddr, &rpool->counter, af);
			PF_AINC(&rpool->counter, af);
		} else {
			if ((rpool->cur =
			    TAILQ_NEXT(rpool->cur, entries)) == NULL)
				rpool->cur = TAILQ_FIRST(&rpool->list);
			PF_ACPY(naddr, &rpool->cur->addr.addr.v.a.addr, af);
			PF_ACPY(&rpool->counter,
			    &rpool->cur->addr.addr.v.a.addr, af);
			PF_AINC(&rpool->counter, af);
		}
		break;
	}

	if (pf_status.debug >= PF_DEBUG_MISC &&
	    (rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		printf("pf_map_addr: selected address: ");
		pf_print_host(naddr, 0, af);
		printf("\n");
d2693 1
a2693 3
pf_get_sport(sa_family_t af, u_int8_t proto, struct pf_pool *rpool,
    struct pf_addr *saddr, struct pf_addr *daddr, u_int16_t dport,
    struct pf_addr *naddr, u_int16_t *nport, u_int16_t low, u_int16_t high)
d2695 1
a2695 8
	struct pf_tree_node	key;
	struct pf_addr		init_addr;
	int			step;
	u_int16_t		cut;

	bzero(&init_addr, sizeof(init_addr));
	if (pf_map_addr(af, rpool, saddr, naddr, &init_addr))
		return (1);
d2697 3
a2699 6
	do {
		key.af = af;
		key.proto = proto;
		PF_ACPY(&key.addr[0], daddr, key.af);
		PF_ACPY(&key.addr[1], naddr, key.af);
		key.port[0] = dport;
d2701 2
a2702 32
		/*
		 * port search; start random, step;
		 * similar 2 portloop in in_pcbbind
		 */
		if (!(proto == IPPROTO_TCP || proto == IPPROTO_UDP)) {
			key.port[1] = 0;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL)
				return (0);
		} else if (rpool->opts & PF_POOL_STATICPORT) {
			key.port[1] = *nport;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL)
				return (0);
		} else if (low == 0 && high == 0) {
			key.port[1] = *nport;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
				NTOHS(*nport);
				return (0);
			}
		} else if (low == high) {
			key.port[1] = htons(low);
			if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
				*nport = low;
				return (0);
			}
		} else {
			if (low < high) {
				step = 1;
				cut = arc4random() % (1 + high - low) + low;
			} else {
				step = -1;
				cut = arc4random() % (1 + low - high) + high;
			}
d2704 1
a2704 34
			*nport = cut - step;
			do {
				*nport += step;
				key.port[1] = htons(*nport);
				if (pf_find_state(&tree_ext_gwy, &key) == NULL)
					return (0);
			} while (*nport != low && *nport != high);

			step = -step;
			*nport = cut;
			do {
				*nport += step;
				key.port[1] = htons(*nport);
				if (pf_find_state(&tree_ext_gwy, &key) == NULL)
					return (0);
			} while (*nport != low && *nport != high);
		}

		switch (rpool->opts & PF_POOL_TYPEMASK) {
		case PF_POOL_RANDOM:
		case PF_POOL_ROUNDROBIN:
			if (pf_map_addr(af, rpool, saddr, naddr, &init_addr))
				return (1);
			break;
		case PF_POOL_NONE:
		case PF_POOL_SRCHASH:
		case PF_POOL_BITMASK:
		default:
			return (1);
			break;
		}
	} while (! PF_AEQ(&init_addr, naddr, af) );

	return (1);					/* none available */
d2707 2
a2708 4
struct pf_rule *
pf_match_translation(int direction, struct ifnet *ifp, u_int8_t proto,
    struct pf_addr *saddr, u_int16_t sport, struct pf_addr *daddr,
    u_int16_t dport, sa_family_t af, int rs_num)
d2710 2
a2711 2
	struct pf_rule		*r, *rm = NULL, *anchorrule = NULL;
	struct pf_ruleset	*ruleset = NULL;
d2713 6
a2718 3
	r = TAILQ_FIRST(pf_main_ruleset.rules[rs_num].active.ptr);
	while (r && rm == NULL) {
		struct pf_rule_addr	*src = NULL, *dst = NULL;
d2720 5
a2724 7
		if (r->action == PF_BINAT && direction == PF_IN) {
			src = &r->dst;
			if (r->rpool.cur != NULL)
				dst = &r->rpool.cur->addr;
		} else {
			src = &r->src;
			dst = &r->dst;
a2725 36

		r->evaluations++;
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&src->addr, saddr, af, src->not))
			r = r->skip[src == &r->src ? PF_SKIP_SRC_ADDR :
			    PF_SKIP_DST_ADDR].ptr;
		else if (src->port_op && !pf_match_port(src->port_op,
		    src->port[0], src->port[1], sport))
			r = r->skip[src == &r->src ? PF_SKIP_SRC_PORT :
			    PF_SKIP_DST_PORT].ptr;
		else if (dst != NULL &&
		    PF_MISMATCHAW(&dst->addr, daddr, af, dst->not))
			r = dst == &r->dst ? r->skip[PF_SKIP_DST_ADDR].ptr :
			    TAILQ_NEXT(r, entries);
		else if (dst != NULL && dst->port_op &&
		    !pf_match_port(dst->port_op, dst->port[0],
		    dst->port[1], dport))
			r = dst == &r->dst ? r->skip[PF_SKIP_DST_PORT].ptr :
			    TAILQ_NEXT(r, entries);
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
		else if (r->anchor == NULL)
				rm = r;
		else
			PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset, rs_num);
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
			    rs_num);
a2726 4
	if (rm != NULL && (rm->action == PF_NONAT ||
	    rm->action == PF_NORDR || rm->action == PF_NOBINAT))
		return (NULL);
	return (rm);
d2729 2
a2730 5
struct pf_rule *
pf_get_translation(int direction, struct ifnet *ifp, u_int8_t proto,
    struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport,
    struct pf_addr *naddr, u_int16_t *nport, sa_family_t af)
d2732 10
a2741 1
	struct pf_rule	*r = NULL;
d2743 9
a2751 6
	if (direction == PF_OUT) {
		r = pf_match_translation(direction, ifp, proto,
		    saddr, sport, daddr, dport, af, PF_RULESET_BINAT);
		if (r == NULL)
			r = pf_match_translation(direction, ifp, proto,
			    saddr, sport, daddr, dport, af, PF_RULESET_NAT);
d2753 2
a2754 5
		r = pf_match_translation(direction, ifp, proto,
		    saddr, sport, daddr, dport, af, PF_RULESET_RDR);
		if (r == NULL)
			r = pf_match_translation(direction, ifp, proto,
			    saddr, sport, daddr, dport, af, PF_RULESET_BINAT);
d2757 16
a2772 70
	if (r != NULL) {
		switch (r->action) {
		case PF_NONAT:
		case PF_NOBINAT:
		case PF_NORDR:
			return (NULL);
			break;
		case PF_NAT:
			if (pf_get_sport(af, proto, &r->rpool, saddr, daddr,
			    dport, naddr, nport, r->rpool.proxy_port[0],
			    r->rpool.proxy_port[1])) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: NAT proxy port allocation "
				    "(%u-%u) failed\n",
				    r->rpool.proxy_port[0],
				    r->rpool.proxy_port[1]));
				return (NULL);
			}
			break;
		case PF_BINAT:
			switch (direction) {
			case PF_OUT:
				if (r->rpool.cur->addr.addr.type ==
				    PF_ADDR_DYNIFTL &&
				    r->rpool.cur->addr.addr.p.dyn->undefined)
					return (NULL);
				else
					PF_POOLMASK(naddr,
					    &r->rpool.cur->addr.addr.v.a.addr,
					    &r->rpool.cur->addr.addr.v.a.mask,
					    saddr, af);
				break;
			case PF_IN:
				if (r->src.addr.type == PF_ADDR_DYNIFTL &&
				    r->src.addr.p.dyn->undefined)
					return (NULL);
				else
					PF_POOLMASK(naddr,
					    &r->src.addr.v.a.addr,
					    &r->src.addr.v.a.mask, saddr, af);
				break;
			}
			break;
		case PF_RDR: {
			if (pf_map_addr(r->af, &r->rpool,
			    &r->src.addr.v.a.addr, naddr, NULL))
				return (NULL);

			if (r->rpool.proxy_port[1]) {
				u_int32_t	tmp_nport;

				tmp_nport = ((ntohs(dport) -
				    ntohs(r->dst.port[0])) %
				    (r->rpool.proxy_port[1] -
				    r->rpool.proxy_port[0] + 1)) +
				    r->rpool.proxy_port[0];

				/* wrap around if necessary */
				if (tmp_nport > 65535)
					tmp_nport -= 65535;
				*nport = htons((u_int16_t)tmp_nport);
			} else if (r->rpool.proxy_port[0])
				*nport = htons(r->rpool.proxy_port[0]);
			break;
		}
		default:
			return (NULL);
			break;
		}
	}
d2774 2
a2775 1
	return (r);
d2778 17
a2794 24
int
pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, sa_family_t af,
    int proto, struct pf_pdesc *pd)
{
	struct pf_addr		*saddr, *daddr;
	u_int16_t		 sport, dport;
	struct inpcbtable	*tb;
	struct inpcb		*inp;

	*uid = UID_MAX;
	*gid = GID_MAX;
	switch (proto) {
	case IPPROTO_TCP:
		sport = pd->hdr.tcp->th_sport;
		dport = pd->hdr.tcp->th_dport;
		tb = &tcbtable;
		break;
	case IPPROTO_UDP:
		sport = pd->hdr.udp->uh_sport;
		dport = pd->hdr.udp->uh_dport;
		tb = &udbtable;
		break;
	default:
		return (0);
d2796 4
a2799 5
	if (direction == PF_IN) {
		saddr = pd->src;
		daddr = pd->dst;
	} else {
		u_int16_t	p;
d2801 25
a2825 5
		p = sport;
		sport = dport;
		dport = p;
		saddr = pd->dst;
		daddr = pd->src;
d2827 10
a2836 22
	switch(af) {
	case AF_INET:
		inp = in_pcbhashlookup(tb, saddr->v4, sport, daddr->v4, dport);
		if (inp == NULL) {
			inp = in_pcblookup(tb, &saddr->v4, sport, &daddr->v4,
			    dport, INPLOOKUP_WILDCARD);
			if (inp == NULL)
				return (0);
		}
		break;
#ifdef INET6
	case AF_INET6:
		inp = in6_pcbhashlookup(tb, &saddr->v6, sport, &daddr->v6,
		    dport);
		if (inp == NULL) {
			inp = in_pcblookup(tb, &saddr->v6, sport, &daddr->v6,
			    dport, INPLOOKUP_WILDCARD | INPLOOKUP_IPV6);
			if (inp == NULL)
				return (0);
		}
		break;
#endif /* INET6 */
d2838 14
a2851 2
	default:
		return (0);
d2853 3
a2855 3
	*uid = inp->inp_socket->so_euid;
	*gid = inp->inp_socket->so_egid;
	return (1);
d2858 2
a2859 2
u_int8_t
pf_get_wscale(struct mbuf *m, int off, u_int16_t th_off, sa_family_t af)
d2861 1
a2861 4
	int		 hlen;
	u_int8_t	 hdr[60];
	u_int8_t	*opt, optlen;
	u_int8_t	 wscale = 0;
d2863 5
a2867 29
	hlen = th_off << 2;		/* hlen <= sizeof(hdr) */
	if (hlen <= sizeof(struct tcphdr))
		return (0);
	if (!pf_pull_hdr(m, off, hdr, hlen, NULL, NULL, af))
		return (0);
	opt = hdr + sizeof(struct tcphdr);
	hlen -= sizeof(struct tcphdr);
	while (hlen >= 3) {
		switch (*opt) {
		case TCPOPT_EOL:
		case TCPOPT_NOP:
			++opt;
			--hlen;
			break;
		case TCPOPT_WINDOW:
			wscale = opt[2];
			if (wscale > TCP_MAX_WINSHIFT)
				wscale = TCP_MAX_WINSHIFT;
			wscale |= PF_WSCALE_FLAG;
			/* fallthrough */
		default:
			optlen = opt[1];
			if (optlen < 2)
				optlen = 2;
			hlen -= optlen;
			opt += optlen;
		}
	}
	return (wscale);
d2870 1
d2872 2
a2873 3
pf_test_tcp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
    struct pf_pdesc *pd)
d2875 9
a2883 13
	struct pf_rule		*nat = NULL, *rdr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct pf_addr		 baddr, naddr;
	struct tcphdr		*th = pd->hdr.tcp;
	u_int16_t		 bport, nport = 0;
	sa_family_t		 af = pd->af;
	int			 lookup = -1;
	uid_t			 uid;
	gid_t			 gid;
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
	struct pf_ruleset	*ruleset = NULL;
	u_short			 reason;
	int			 rewrite = 0;
d2888 17
a2904 5
		bport = nport = th->th_sport;
		/* check outgoing packet for BINAT/NAT */
		if ((nat = pf_get_translation(PF_OUT, ifp, IPPROTO_TCP,
		    saddr, th->th_sport, daddr, th->th_dport,
		    &naddr, &nport, af)) != NULL) {
d2907 1
a2907 1
			    &th->th_sum, &naddr, nport, 0, af);
d2911 18
a2928 5
		bport = nport = th->th_dport;
		/* check incoming packet for BINAT/RDR */
		if ((rdr = pf_get_translation(PF_IN, ifp, IPPROTO_TCP,
		    saddr, th->th_sport, daddr, th->th_dport,
		    &naddr, &nport, af)) != NULL) {
d2930 1
d2932 1
a2932 1
			    &th->th_sum, &naddr, nport, 0, af);
d2937 1
a2937 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2940 6
a2945 5
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
d2947 1
a2947 1
			r = r->skip[PF_SKIP_AF].ptr;
d2949 4
a2952 3
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
d2955 4
a2958 3
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
d2961 1
a2961 5
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
d2964 4
a2967 11
		else if (r->uid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP,
		    pd), 1)) &&
		    !pf_match_uid(r->uid.op, r->uid.uid[0], r->uid.uid[1],
		    uid))
			r = TAILQ_NEXT(r, entries);
		else if (r->gid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP,
		    pd), 1)) &&
		    !pf_match_gid(r->gid.op, r->gid.gid[0], r->gid.gid[1],
		    gid))
a2968 12
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->anchor == NULL) {
				*rm = r;
				rs = (anchorrule == NULL ? r : anchorrule);
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
				    PF_RULESET_FILTER);
a2969 3
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
			    PF_RULESET_FILTER);
a2974 4
		if (rs != *rm) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
d2980 1
a2980 1
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d2985 1
a2985 2
		    ((*rm)->rule_flag & PFRULE_RETURNICMP) ||
		    ((*rm)->rule_flag & PFRULE_RETURN))) {
d2987 2
a2988 1
			if (nat != NULL) {
d2992 2
a2993 1
			} else if (rdr != NULL) {
d2998 3
a3000 5
			if (((*rm)->rule_flag & PFRULE_RETURNRST) ||
			    ((*rm)->rule_flag & PFRULE_RETURN))
				pf_send_reset(off, th, pd, af,
				    (*rm)->return_ttl, *rm);
			else if ((af == AF_INET) && (*rm)->return_icmp)
d3002 1
a3002 4
				    (*rm)->return_icmp & 255, af, *rm);
			else if ((af == AF_INET6) && (*rm)->return_icmp6)
				pf_send_icmp(m, (*rm)->return_icmp6 >> 8,
				    (*rm)->return_icmp6 & 255, af, *rm);
d3005 3
a3007 1
		if ((*rm)->action == PF_DROP)
d3009 1
d3012 2
a3013 2
	if (((*rm != NULL) && (*rm)->keep_state) ||
	    nat != NULL || rdr != NULL) {
d3015 2
a3016 2
		u_int16_t	 len;
		struct pf_state	*s = NULL;
d3019 1
a3019 3
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
d3021 2
a3022 1
			REASON_SET(&reason, PFRES_MEMORY);
d3025 2
a3026 11
		bzero(s, sizeof(*s));
		if (rs != NULL)
			rs->states++;

		s->rule.ptr = rs;
		if (nat != NULL)
			s->nat_rule = nat;
		else
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
d3037 1
a3037 1
			if (nat != NULL) {
d3050 1
a3050 1
			if (rdr != NULL) {
d3061 2
a3062 2
		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
		    *rm != NULL && (*rm)->keep_state == PF_STATE_MODULATE) {
d3071 1
a3071 1
		if (th->th_flags & TH_SYN) {
a3072 2
			s->src.wscale = pf_get_wscale(m, off, th->th_off, af);
		}
d3083 1
a3083 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_TCP_FIRST_PACKET);
d3086 1
a3086 6
		if (pf_insert_state(s)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
d3097 2
a3098 3
pf_test_udp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
    struct pf_pdesc *pd)
d3100 9
a3108 13
	struct pf_rule		*nat = NULL, *rdr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct pf_addr		 baddr, naddr;
	struct udphdr		*uh = pd->hdr.udp;
	u_int16_t		 bport, nport = 0;
	sa_family_t		 af = pd->af;
	int			 lookup = -1;
	uid_t			 uid;
	gid_t			 gid;
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
	struct pf_ruleset	*ruleset = NULL;
	u_short			 reason;
	int			 rewrite = 0;
d3113 17
a3129 5
		bport = nport = uh->uh_sport;
		/* check outgoing packet for BINAT/NAT */
		if ((nat = pf_get_translation(PF_OUT, ifp, IPPROTO_UDP,
		    saddr, uh->uh_sport, daddr, uh->uh_dport,
		    &naddr, &nport, af)) != NULL) {
d3132 1
a3132 1
			    &uh->uh_sum, &naddr, nport, 1, af);
d3136 19
a3154 5
		bport = nport = uh->uh_dport;
		/* check incoming packet for BINAT/RDR */
		if ((rdr = pf_get_translation(PF_IN, ifp, IPPROTO_UDP,
		    saddr, uh->uh_sport, daddr, uh->uh_dport,
		    &naddr, &nport, af)) != NULL) {
d3156 1
d3158 1
a3158 1
			    &uh->uh_sum, &naddr, nport, 1, af);
d3163 1
a3163 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d3166 6
a3171 5
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
d3173 1
a3173 1
			r = r->skip[PF_SKIP_AF].ptr;
d3175 5
a3179 3
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
d3182 5
a3186 3
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
d3189 5
a3193 2
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else if (r->tos && !(r->tos & pd->tos))
a3194 26
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if (r->uid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP,
		    pd), 1)) &&
		    !pf_match_uid(r->uid.op, r->uid.uid[0], r->uid.uid[1],
		    uid))
			r = TAILQ_NEXT(r, entries);
		else if (r->gid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP,
		    pd), 1)) &&
		    !pf_match_gid(r->gid.op, r->gid.gid[0], r->gid.gid[1],
		    gid))
			r = TAILQ_NEXT(r, entries);
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->anchor == NULL) {
				*rm = r;
				rs = (anchorrule == NULL ? r : anchorrule);
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
				    PF_RULESET_FILTER);
a3195 3
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
			    PF_RULESET_FILTER);
a3200 4
		if (rs != *rm) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
d3206 1
a3206 1
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d3209 1
a3209 3
		if (((*rm)->action == PF_DROP) &&
		    (((*rm)->rule_flag & PFRULE_RETURNICMP) ||
		    ((*rm)->rule_flag & PFRULE_RETURN))) {
d3211 2
a3212 1
			if (nat != NULL) {
d3216 2
a3217 1
			} else if (rdr != NULL) {
d3222 2
a3223 6
			if ((af == AF_INET) && (*rm)->return_icmp)
				pf_send_icmp(m, (*rm)->return_icmp >> 8,
				    (*rm)->return_icmp & 255, af, *rm);
			else if ((af == AF_INET6) && (*rm)->return_icmp6)
				pf_send_icmp(m, (*rm)->return_icmp6 >> 8,
				    (*rm)->return_icmp6 & 255, af, *rm);
d3226 3
a3228 1
		if ((*rm)->action == PF_DROP)
d3230 1
d3233 2
a3234 2
	if ((*rm != NULL && (*rm)->keep_state) ||
	    nat != NULL || rdr != NULL) {
d3236 1
a3236 1
		struct pf_state	*s = NULL;
d3238 4
a3241 4
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL)
d3243 3
a3245 11
		bzero(s, sizeof(*s));
		if (rs != NULL)
			rs->states++;

		s->rule.ptr = rs;
		if (nat != NULL)
			s->nat_rule = nat;
		else
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
d3256 1
a3256 1
			if (nat != NULL) {
d3268 1
a3268 1
			if (rdr != NULL) {
d3276 1
a3276 1
		s->src.seqlo = 0;
d3280 1
a3280 1
		s->src.state = PFUDPS_SINGLE;
d3285 1
a3285 1
		s->dst.state = PFUDPS_NO_TRAFFIC;
d3287 1
a3287 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_UDP_FIRST_PACKET);
d3290 1
a3290 6
		if (pf_insert_state(s)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
d3301 2
a3302 3
pf_test_icmp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
    struct pf_pdesc *pd)
d3304 8
a3311 10
	struct pf_rule		*nat = NULL, *rdr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct pf_addr		 baddr, naddr;
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
	struct pf_ruleset	*ruleset = NULL;
	u_short			 reason;
	u_int16_t		 icmpid;
	sa_family_t		 af = pd->af;
	u_int8_t		 icmptype, icmpcode;
	int			 state_icmp = 0;
d3313 1
a3313 1
	int			 rewrite = 0;
a3323 7

		if (icmptype == ICMP_UNREACH ||
		    icmptype == ICMP_SOURCEQUENCH ||
		    icmptype == ICMP_REDIRECT ||
		    icmptype == ICMP_TIMXCEED ||
		    icmptype == ICMP_PARAMPROB)
			state_icmp++;
a3330 6

		if (icmptype == ICMP6_DST_UNREACH ||
		    icmptype == ICMP6_PACKET_TOO_BIG ||
		    icmptype == ICMP6_TIME_EXCEEDED ||
		    icmptype == ICMP6_PARAM_PROB)
			state_icmp++;
d3336 3
a3338 3
		/* check outgoing packet for BINAT/NAT */
		if ((nat = pf_get_translation(PF_OUT, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d3344 21
a3364 1
				    naddr.v4.s_addr, 0);
d3370 1
a3370 1
				    &naddr, 0);
d3377 23
a3399 3
		/* check incoming packet for BINAT/RDR */
		if ((rdr = pf_get_translation(PF_IN, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d3405 1
a3405 1
				    pd->ip_sum, naddr.v4.s_addr, 0);
d3411 1
a3411 1
				    &naddr, 0);
d3419 1
a3419 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d3422 6
a3427 5
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
d3429 1
a3429 1
			r = r->skip[PF_SKIP_AF].ptr;
d3431 9
a3439 5
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
d3444 4
a3447 1
		else if (r->tos && !(r->tos & pd->tos))
a3448 14
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->anchor == NULL) {
				*rm = r;
				rs = (anchorrule == NULL ? r : anchorrule);
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
				    PF_RULESET_FILTER);
a3449 3
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
			    PF_RULESET_FILTER);
d3454 1
a3454 5
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
d3463 1
a3463 1
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d3470 2
a3471 2
	if (!state_icmp && ((*rm != NULL && (*rm)->keep_state) ||
	    nat != NULL || rdr != NULL)) {
d3473 1
a3473 1
		struct pf_state	*s = NULL;
d3475 1
a3475 3
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
d3478 2
a3479 11
		bzero(s, sizeof(*s));
		if (rs != NULL)
			rs->states++;

		s->rule.ptr = rs;
		if (nat != NULL)
			s->nat_rule = nat;
		else
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
d3490 1
a3490 1
			if (nat != NULL)
d3500 1
a3500 1
			if (rdr != NULL)
d3517 1
a3517 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_ICMP_FIRST_PACKET);
d3520 1
a3520 6
		if (pf_insert_state(s)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
d3534 2
a3535 2
pf_test_other(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct ifnet *ifp, struct mbuf *m, void *h, struct pf_pdesc *pd)
d3537 6
a3542 7
	struct pf_rule		*nat = NULL, *rdr = NULL;
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct pf_addr		 baddr, naddr;
	sa_family_t		 af = pd->af;
	u_short			 reason;
d3547 3
a3549 3
		/* check outgoing packet for BINAT/NAT */
		if ((nat = pf_get_translation(PF_OUT, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d3555 19
a3573 1
				    naddr.v4.s_addr, 0);
d3578 1
a3578 1
				PF_ACPY(saddr, &naddr, af);
d3584 22
a3605 3
		/* check incoming packet for BINAT/RDR */
		if ((rdr = pf_get_translation(PF_IN, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d3610 1
a3610 1
				    pd->ip_sum, naddr.v4.s_addr, 0);
d3615 1
a3615 1
				PF_ACPY(daddr, &naddr, af);
d3622 1
a3622 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d3625 6
a3630 5
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
d3632 1
a3632 1
			r = r->skip[PF_SKIP_AF].ptr;
d3634 11
a3644 8
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->rule_flag & PFRULE_FRAGMENT)
a3645 12
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->anchor == NULL) {
				*rm = r;
				rs = (anchorrule == NULL ? r : anchorrule);
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
				    PF_RULESET_FILTER);
a3646 3
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
			    PF_RULESET_FILTER);
d3650 2
a3653 4
		if (rs != *rm) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
d3656 1
a3656 1
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d3663 1
a3663 1
	    rdr != NULL) {
d3665 1
a3665 1
		struct pf_state	*s = NULL;
d3667 1
a3667 3
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
d3670 2
a3671 11
		bzero(s, sizeof(*s));
		if (rs != NULL)
			rs->states++;

		s->rule.ptr = rs;
		if (nat != NULL)
			s->nat_rule = nat;
		else
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
d3682 1
a3682 1
			if (nat != NULL)
d3692 1
a3692 1
			if (rdr != NULL)
d3702 1
a3702 1
		s->src.state = PFOTHERS_SINGLE;
d3707 1
a3707 1
		s->dst.state = PFOTHERS_NO_TRAFFIC;
d3709 1
a3709 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_OTHER_FIRST_PACKET);
d3712 1
a3712 78
		if (pf_insert_state(s)) {
			REASON_SET(&reason, PFRES_MEMORY);
			if (*rm && (*rm)->log)
				PFLOG_PACKET(ifp, h, m, af, direction, reason,
				    rs);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
	}

	return (PF_PASS);
}

int
pf_test_fragment(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, void *h, struct pf_pdesc *pd)
{
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
	struct pf_ruleset	*ruleset = NULL;
	sa_family_t		 af = pd->af;

	*rm = NULL;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
	while (r != NULL) {
		r->evaluations++;
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->src.port_op || r->dst.port_op ||
		    r->flagset || r->type || r->code)
			r = TAILQ_NEXT(r, entries);
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->anchor == NULL) {
				*rm = r;
				rs = (anchorrule == NULL ? r : anchorrule);
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
			    PF_RULESET_FILTER);
	}

	if (*rm != NULL) {
		u_short	reason;

		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);
		if ((*rm)->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);

		if ((*rm)->action != PF_PASS)
			return (PF_DROP);
d3722 6
a3727 7
	struct pf_tree_node	 key;
	struct tcphdr		*th = pd->hdr.tcp;
	u_int16_t		 win = ntohs(th->th_win);
	u_int32_t		 ack, end, seq;
	u_int8_t		 sws, dws;
	int			 ackskew;
	struct pf_state_peer	*src, *dst;
d3729 2
a3730 2
	key.af = pd->af;
	key.proto = IPPROTO_TCP;
d3736 6
a3741 1
	STATE_LOOKUP();
a3750 6
	if (src->wscale && dst->wscale && !(th->th_flags & TH_SYN)) {
		sws = src->wscale & PF_WSCALE_MASK;
		dws = dst->wscale & PF_WSCALE_MASK;
	} else
		sws = dws = 0;

d3759 1
a3759 1
		/* First packet from this end. Set its state */
d3774 1
a3774 1
		if (th->th_flags & TH_SYN) {
a3775 2
			src->wscale = pf_get_wscale(m, off, th->th_off, pd->af);
		}
d3788 2
a3789 3
		if (src->seqhi == 1 ||
		    SEQ_GEQ(end + MAX(1, dst->max_win << dws), src->seqhi))
			src->seqhi = end + MAX(1, dst->max_win << dws);
d3815 3
a3817 4
		/*
		 * Many stacks (ours included) will set the ACK number in an
		 * FIN|ACK if the SYN times out -- no sequence to ACK.
		 */
d3832 1
a3832 1
	    SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws)) &&
d3845 1
a3845 1
		/* synchronize sequencing */
d3849 2
a3850 2
		if (SEQ_GEQ(ack + (win << sws), dst->seqhi))
			dst->seqhi = ack + MAX((win << sws), 1);
d3872 1
a3872 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_CLOSED);
d3875 4
a3878 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_FIN_WAIT);
d3881 1
a3881 6
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_OPENING);
		else if (src->state >= TCPS_CLOSING ||
		    dst->state >= TCPS_CLOSING)
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_CLOSING);
d3883 1
a3883 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_ESTABLISHED);
d3907 1
a3907 1
		 * since packet floods will also be caught here. We don't
d3920 1
a3920 1
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d\n",
d3930 1
a3930 1
		/* synchronize sequencing */
d3934 2
a3935 2
		if (SEQ_GEQ(ack + (win << sws), dst->seqhi))
			dst->seqhi = ack + MAX((win << sws), 1);
d3951 1
a3951 9
		if ((*state)->dst.state == TCPS_SYN_SENT &&
		    (*state)->src.state == TCPS_SYN_SENT) {
			/* Send RST for state mismatches during handshake */
			pf_send_reset(off, th, pd, pd->af, 0,
			    (*state)->rule.ptr);
			src->seqlo = 0;
			src->seqhi = 1;
			src->max_win = 1;
		} else if (pf_status.debug >= PF_DEBUG_MISC) {
d3955 1
a3955 1
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d "
d3962 1
a3962 2
			    SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws)) ?
			    ' ': '2',
d3989 3
a3991 7
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->nat_rule != NULL) {
		(*state)->nat_rule->packets++;
		(*state)->nat_rule->bytes += pd->tot_len;
d4000 3
a4002 3
	struct pf_state_peer	*src, *dst;
	struct pf_tree_node	 key;
	struct udphdr		*uh = pd->hdr.udp;
d4004 2
a4005 2
	key.af = pd->af;
	key.proto = IPPROTO_UDP;
d4011 6
a4016 1
	STATE_LOOKUP();
d4030 4
a4033 4
	if (src->state < PFUDPS_SINGLE)
		src->state = PFUDPS_SINGLE;
	if (dst->state == PFUDPS_SINGLE)
		dst->state = PFUDPS_MULTIPLE;
d4036 2
a4037 3
	if (src->state == PFUDPS_MULTIPLE && dst->state == PFUDPS_MULTIPLE)
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_UDP_MULTIPLE);
d4039 1
a4039 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_UDP_SINGLE);
d4054 3
a4056 7
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->nat_rule != NULL) {
		(*state)->nat_rule->packets++;
		(*state)->nat_rule->bytes += pd->tot_len;
d4065 4
a4068 4
	struct pf_addr	*saddr = pd->src, *daddr = pd->dst;
	u_int16_t	 icmpid, *icmpsum;
	u_int8_t	 icmptype;
	int		 state_icmp = 0;
d4106 1
a4106 1
		struct pf_tree_node	key;
d4108 2
a4109 2
		key.af = pd->af;
		key.proto = pd->proto;
d4115 6
a4120 1
		STATE_LOOKUP();
d4124 1
a4124 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_ICMP_ERROR_REPLY);
d4177 1
a4177 1
		struct pf_pdesc	pd2;
d4179 1
a4179 1
		struct ip	h2;
d4182 2
a4183 2
		struct ip6_hdr	h2_6;
		int		terminal = 0;
d4185 2
a4186 2
		int		ipoff2;
		int		off2;
d4198 1
a4198 2
				    ("pf: ICMP error message too short "
				    "(ip)\n"));
d4201 1
a4201 4
			/*
			 * ICMP error messages don't refer to non-first
			 * fragments
			 */
d4221 1
a4221 2
				    ("pf: ICMP error message too short "
				    "(ip6)\n"));
d4232 1
a4232 4
					/*
					 * ICMPv6 error messages for
					 * non-first fragments
					 */
d4239 1
a4239 1
					struct ip6_ext opt6;
d4244 2
a4245 2
						    ("pf: ICMPv6 short opt\n"));
						return (PF_DROP);
d4247 2
a4248 5
					if (pd2.proto == IPPROTO_AH)
						off2 += (opt6.ip6e_len + 2) * 4;
					else
						off2 += (opt6.ip6e_len + 1) * 8;
					pd2.proto = opt6.ip6e_nxt;
d4263 4
a4266 5
			struct tcphdr		 th;
			u_int32_t		 seq;
			struct pf_tree_node	 key;
			struct pf_state_peer	*src, *dst;
			u_int8_t		 dws;
d4275 1
a4275 2
				    ("pf: ICMP error message too short "
				    "(tcp)\n"));
d4280 1
a4280 1
			key.proto = IPPROTO_TCP;
d4286 6
a4291 1
			STATE_LOOKUP();
a4300 5
			if (src->wscale && dst->wscale && !(th.th_flags & TH_SYN))
				dws = dst->wscale & PF_WSCALE_MASK;
			else
				dws = 0;

d4308 1
a4308 1
			    !SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws))) {
d4312 1
a4312 1
					printf(" seq=%u\n", seq);
d4358 2
a4359 2
			struct udphdr		uh;
			struct pf_tree_node	key;
d4364 1
a4364 2
				    ("pf: ICMP error message too short "
				    "(udp)\n"));
d4369 1
a4369 1
			key.proto = IPPROTO_UDP;
d4375 6
a4380 1
			STATE_LOOKUP();
d4423 2
a4424 2
			struct icmp		iih;
			struct pf_tree_node	key;
d4429 1
a4429 2
				    ("pf: ICMP error message too short i"
				    "(icmp)\n"));
d4434 1
a4434 1
			key.proto = IPPROTO_ICMP;
d4440 6
a4445 1
			STATE_LOOKUP();
d4475 2
a4476 2
			struct icmp6_hdr	iih;
			struct pf_tree_node	key;
d4481 1
a4481 2
				    ("pf: ICMP error message too short "
				    "(icmp6)\n"));
d4486 1
a4486 1
			key.proto = IPPROTO_ICMPV6;
d4492 6
a4497 1
			STATE_LOOKUP();
d4538 2
a4539 2
	struct pf_state_peer	*src, *dst;
	struct pf_tree_node	 key;
d4541 2
a4542 2
	key.af = pd->af;
	key.proto = pd->proto;
d4548 6
a4553 1
	STATE_LOOKUP();
d4567 4
a4570 4
	if (src->state < PFOTHERS_SINGLE)
		src->state = PFOTHERS_SINGLE;
	if (dst->state == PFOTHERS_SINGLE)
		dst->state = PFOTHERS_MULTIPLE;
d4573 2
a4574 3
	if (src->state == PFOTHERS_MULTIPLE && dst->state == PFOTHERS_MULTIPLE)
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_OTHER_MULTIPLE);
d4576 1
a4576 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_OTHER_SINGLE);
d4585 1
a4585 2
				    pd->ip_sum, (*state)->gwy.addr.v4.s_addr,
				    0);
d4599 1
a4599 2
				    pd->ip_sum, (*state)->lan.addr.v4.s_addr,
				    0);
d4610 3
a4612 7
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->nat_rule != NULL) {
		(*state)->nat_rule->packets++;
		(*state)->nat_rule->bytes += pd->tot_len;
d4623 1
a4623 1
    u_short *actionp, u_short *reasonp, sa_family_t af)
d4628 2
a4629 2
		struct ip	*h = mtod(m, struct ip *);
		u_int16_t	 fragoff = (h->ip_off & IP_OFFMASK) << 3;
d4650 1
a4650 2
		struct ip6_hdr	*h = mtod(m, struct ip6_hdr *);

d4652 1
a4652 2
		    (ntohs(h->ip6_plen) + sizeof(struct ip6_hdr)) <
		    (unsigned)(off + len)) {
a4664 22
int
pf_routable(struct pf_addr *addr, sa_family_t af)
{
	struct sockaddr_in	*dst;
	struct route		 ro;
	int			 ret = 0;

	bzero(&ro, sizeof(ro));
	dst = satosin(&ro.ro_dst);
	dst->sin_family = af;
	dst->sin_len = sizeof(*dst);
	dst->sin_addr = addr->v4;
	rtalloc_noclone(&ro, NO_CLONING);

	if (ro.ro_rt != NULL) {
		ret = 1;
		RTFREE(ro.ro_rt);
	}

	return (ret);
}

d4667 1
a4667 2
pf_route(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp,
    struct pf_state *s)
d4669 8
a4676 13
	struct mbuf		*m0, *m1;
	struct route		 iproute;
	struct route		*ro;
	struct sockaddr_in	*dst;
	struct ip		*ip;
	struct ifnet		*ifp = NULL;
	struct m_tag		*mtag;
	struct pf_addr		 naddr;
	int			 error = 0;

	if (m == NULL || *m == NULL || r == NULL ||
	    (dir != PF_IN && dir != PF_OUT) || oifp == NULL)
		panic("pf_route: invalid parameters");
a4678 8
		m0 = *m;
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
		}
d4683 1
a4683 1
		if ((r->rt == PF_REPLYTO) == (r->direction == dir))
a4687 2
	if (m0->m_len < sizeof(struct ip))
		panic("pf_route: m0->m_len < sizeof(struct ip)");
d4689 1
d4711 2
a4712 21
		if (TAILQ_EMPTY(&r->rpool.list))
			panic("pf_route: TAILQ_EMPTY(&r->rpool.list)");
		if (s == NULL) {
			pf_map_addr(AF_INET, &r->rpool,
			    (struct pf_addr *)&ip->ip_src,
			    &naddr, NULL);
			if (!PF_AZERO(&naddr, AF_INET))
				dst->sin_addr.s_addr = naddr.v4.s_addr;
			ifp = r->rpool.cur->ifp;
		} else {
			if (s->rt_ifp == NULL) {
				pf_map_addr(AF_INET, &r->rpool,
				    (struct pf_addr *)&ip->ip_src,
				    &s->rt_addr, NULL);
				s->rt_ifp = r->rpool.cur->ifp;
			}
			if (!PF_AZERO(&s->rt_addr, AF_INET))
				dst->sin_addr.s_addr =
				    s->rt_addr.v4.s_addr;
			ifp = s->rt_ifp;
		}
a4717 18
	if (oifp != ifp) {
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
			if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
				goto bad;
			else if (m0 == NULL)
				goto done;
			if (m0->m_len < sizeof(struct ip))
				panic("pf_route: m0->m_len < "
				    "sizeof(struct ip)");
			ip = mtod(m0, struct ip *);
		}
	}

d4719 1
a4719 1
	if (ip->ip_len <= ifp->if_mtu) {
d4728 1
a4728 1
			ip->ip_sum = in_cksum(m0, ip->ip_hl << 2);
d4744 1
d4746 1
a4746 6
		if (r->rt != PF_DUPTO) {
			icmp_error(m0, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG, 0,
			    ifp);
			goto done;
		} else
			goto bad;
d4748 3
a4750 4

	m1 = m0;
	error = ip_fragment(m0, ifp, ifp->if_mtu);
	if (error == EMSGSIZE)
d4752 93
d4846 2
a4847 8
	for (m0 = m1; m0; m0 = m1) {
		m1 = m0->m_nextpkt;
		m0->m_nextpkt = 0;
		if (error == 0)
			error = (*ifp->if_output)(ifp, m0, sintosa(dst),
			    NULL);
		else
			m_freem(m0);
a4849 3
	if (error == 0)
		ipstat.ips_fragmented++;

d4865 1
a4865 2
pf_route6(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp,
    struct pf_state *s)
d4867 11
a4877 13
	struct mbuf		*m0;
	struct m_tag		*mtag;
	struct route_in6	 ip6route;
	struct route_in6	*ro;
	struct sockaddr_in6	*dst;
	struct ip6_hdr		*ip6;
	struct ifnet		*ifp = NULL;
	struct pf_addr		 naddr;
	int			 error = 0;

	if (m == NULL || *m == NULL || r == NULL ||
	    (dir != PF_IN && dir != PF_OUT) || oifp == NULL)
		panic("pf_route6: invalid parameters");
a4879 8
		m0 = *m;
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
		}
d4884 1
a4884 1
		if ((r->rt == PF_REPLYTO) == (r->direction == dir))
a4888 2
	if (m0->m_len < sizeof(struct ip6_hdr))
		panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
d4898 3
a4910 22
	if (TAILQ_EMPTY(&r->rpool.list))
		panic("pf_route6: TAILQ_EMPTY(&r->rpool.list)");
	if (s == NULL) {
		pf_map_addr(AF_INET6, &r->rpool,
		    (struct pf_addr *)&ip6->ip6_src, &naddr, NULL);
		if (!PF_AZERO(&naddr, AF_INET6))
			PF_ACPY((struct pf_addr *)&dst->sin6_addr,
			    &naddr, AF_INET6);
		ifp = r->rpool.cur->ifp;
	} else {
		if (s->rt_ifp == NULL) {
			pf_map_addr(AF_INET6, &r->rpool,
			    (struct pf_addr *)&ip6->ip6_src,
			    &s->rt_addr, NULL);
			s->rt_ifp = r->rpool.cur->ifp;
		}
		if (!PF_AZERO(&s->rt_addr, AF_INET6))
			PF_ACPY((struct pf_addr *)&dst->sin6_addr,
			    &s->rt_addr, AF_INET6);
		ifp = s->rt_ifp;
	}

a4913 14
	if (oifp != ifp) {
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
			if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
				goto bad;
			else if (m0 == NULL)
				goto done;
		}
	}

d4915 3
a4917 2
	 * If the packet is too large for the outgoing interface,
	 * send back an icmp6 error.
d4919 1
a4919 1
	if ((u_long)m0->m_pkthdr.len <= ifp->if_mtu) {
d4922 2
a4923 7
	} else {
		in6_ifstat_inc(ifp, ifs6_in_toobig);
		if (r->rt != PF_DUPTO)
			icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
		else
			goto bad;
	}
a4935 89

/*
 * check protocol (tcp/udp/icmp/icmp6) checksum and set mbuf flag
 *   off is the offset where the protocol header starts
 *   len is the total length of protocol header plus payload
 * returns 0 when the checksum is valid, otherwise returns 1.
 */
int
pf_check_proto_cksum(struct mbuf *m, int off, int len, u_int8_t p, sa_family_t af)
{
	u_int16_t flag_ok, flag_bad;
	u_int16_t sum;

	switch (p) {
	case IPPROTO_TCP:
		flag_ok = M_TCP_CSUM_IN_OK;
		flag_bad = M_TCP_CSUM_IN_BAD;
		break;
	case IPPROTO_UDP:
		flag_ok = M_UDP_CSUM_IN_OK;
		flag_bad = M_UDP_CSUM_IN_BAD;
		break;
	case IPPROTO_ICMP:
#ifdef INET6
	case IPPROTO_ICMPV6:
#endif /* INET6 */
		flag_ok = flag_bad = 0;
		break;
	default:
		return (1);
	}
	if (m->m_pkthdr.csum & flag_ok)
		return (0);
	if (m->m_pkthdr.csum & flag_bad)
		return (1);
	if (off < sizeof(struct ip) || len < sizeof(struct udphdr))
		return (1);
	if (m->m_pkthdr.len < off + len)
		return (1);
		switch (af) {
	case AF_INET:
		if (p == IPPROTO_ICMP) {
			if (m->m_len < off)
				return (1);
			m->m_data += off;
			m->m_len -= off;
			sum = in_cksum(m, len);
			m->m_data -= off;
			m->m_len += off;
		} else {
			if (m->m_len < sizeof(struct ip))
				return (1);
			sum = in4_cksum(m, p, off, len);
		}
		break;
#ifdef INET6
	case AF_INET6:
		if (m->m_len < sizeof(struct ip6_hdr))
			return (1);
		sum = in6_cksum(m, p, off, len);
		break;
#endif /* INET6 */
	default:
		return (1);
	}
	if (sum) {
		m->m_pkthdr.csum |= flag_bad;
		switch (p) {
		case IPPROTO_TCP:
			tcpstat.tcps_rcvbadsum++;
			break;
		case IPPROTO_UDP:
			udpstat.udps_badsum++;
			break;
		case IPPROTO_ICMP:
			icmpstat.icps_checksum++;
			break;
#ifdef INET6
		case IPPROTO_ICMPV6:
			icmp6stat.icp6s_checksum++;
			break;
#endif /* INET6 */
		}
		return (1);
	}
	m->m_pkthdr.csum |= flag_ok;
	return (0);
}

d4940 7
a4946 8
	u_short		 action, reason = 0, log = 0;
	struct mbuf	*m = *m0;
	struct ip	*h;
	struct pf_rule	*r = NULL;
	struct pf_state	*s = NULL;
	struct pf_pdesc	 pd;
	int		 off;
	int		 pqid = 0;
d4957 1
a4957 1
	if (m->m_pkthdr.len < (int)sizeof(*h)) {
d4973 1
a4973 1
	if (off < (int)sizeof(*h)) {
a4984 1
	pd.tos = h->ip_tos;
a4986 6
	/* handle fragments that didn't get reassembled by normalization */
	if (h->ip_off & (IP_MF | IP_OFFMASK)) {
		action = pf_test_fragment(&r, dir, ifp, m, h, &pd);
		goto done;
	}

d4990 2
a4991 1
		struct tcphdr	th;
a4992 1
		pd.hdr.tcp = &th;
a4997 5
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    h->ip_len - off, IPPROTO_TCP, AF_INET)) {
			action = PF_DROP;
			goto done;
		}
a4998 2
		if ((th.th_flags & TH_ACK) && pd.p_len == 0)
			pqid = 1;
d5004 1
a5004 1
			r = s->rule.ptr;
d5007 1
a5007 2
			action = pf_test_tcp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd);
d5012 2
a5013 1
		struct udphdr	uh;
a5014 1
		pd.hdr.udp = &uh;
a5019 5
		if (dir == PF_IN && uh.uh_sum && pf_check_proto_cksum(m,
		    off, h->ip_len - off, IPPROTO_UDP, AF_INET)) {
			action = PF_DROP;
			goto done;
		}
d5022 1
a5022 1
			r = s->rule.ptr;
d5025 1
a5025 2
			action = pf_test_udp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd);
d5030 2
a5031 1
		struct icmp	ih;
a5032 1
		pd.hdr.icmp = &ih;
a5037 5
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    h->ip_len - off, IPPROTO_ICMP, AF_INET)) {
			action = PF_DROP;
			goto done;
		}
d5040 1
a5040 1
			r = s->rule.ptr;
d5047 1
a5047 2
			action = pf_test_icmp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd);
d5054 1
a5054 1
			r = s->rule.ptr;
d5057 1
a5057 1
			action = pf_test_other(&r, &s, dir, ifp, m, h, &pd);
d5062 2
a5063 2
		pf_status.bcounters[0][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[0][dir == PF_OUT][action]++;
a5066 11
	if (r != NULL && r->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->src.not);
	if (r != NULL && r->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->dst.not);

a5075 20
#ifdef ALTQ
	if (action != PF_DROP && r != NULL && r->qid) {
		struct m_tag	*mtag;
		struct altq_tag	*atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			if (pqid || pd.tos == IPTOS_LOWDELAY)
				atag->qid = r->pqid;
			else
				atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = AF_INET;
			atag->hdr = h;
			m_tag_prepend(m, mtag);
		}
	}
#endif

d5078 1
a5078 2
			struct pf_rule	r0;

d5088 2
a5089 2
	if (r != NULL && r->rt)
		pf_route(m0, r, dir, ifp, s);
d5099 5
a5103 5
	u_short		 action, reason = 0, log = 0;
	struct mbuf	*m = *m0;
	struct ip6_hdr	*h;
	struct pf_rule	*r = NULL;
	struct pf_state	*s = NULL;
d5105 1
a5105 1
	int		off, terminal = 0;
d5116 1
a5116 1
	if (m->m_pkthdr.len < (int)sizeof(*h)) {
a5129 1
	pd.tos = 0;
d5137 3
a5139 3
			action = pf_test_fragment(&r, dir, ifp, m, h, &pd);
			if (action == PF_DROP)
				REASON_SET(&reason, PFRES_FRAG);
d5146 1
a5146 1
			struct ip6_ext	opt6;
d5157 2
a5158 5
			if (pd.proto == IPPROTO_AH)
				off += (opt6.ip6e_len + 2) * 4;
			else
				off += (opt6.ip6e_len + 1) * 8;
			pd.proto = opt6.ip6e_nxt;
d5171 2
a5172 1
		struct tcphdr	th;
a5173 1
		pd.hdr.tcp = &th;
a5178 5
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    ntohs(h->ip6_plen), IPPROTO_TCP, AF_INET6)) {
			action = PF_DROP;
			goto done;
		}
d5185 1
a5185 1
			r = s->rule.ptr;
d5188 1
a5188 2
			action = pf_test_tcp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd);
d5193 2
a5194 1
		struct udphdr	uh;
a5195 1
		pd.hdr.udp = &uh;
a5200 5
		if (dir == PF_IN && uh.uh_sum && pf_check_proto_cksum(m,
		    off, ntohs(h->ip6_plen), IPPROTO_UDP, AF_INET6)) {
			action = PF_DROP;
			goto done;
		}
d5203 1
a5203 1
			r = s->rule.ptr;
d5206 1
a5206 2
			action = pf_test_udp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd);
d5211 2
a5212 1
		struct icmp6_hdr	ih;
a5213 1
		pd.hdr.icmp6 = &ih;
d5219 1
a5219 7
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    ntohs(h->ip6_plen), IPPROTO_ICMPV6, AF_INET6)) {
			action = PF_DROP;
			goto done;
		}
		action = pf_test_state_icmp(&s, dir, ifp,
		    m, 0, off, h, &pd);
d5221 1
a5221 1
			r = s->rule.ptr;
d5228 1
a5228 2
			action = pf_test_icmp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd);
d5233 1
a5233 1
		action = pf_test_other(&r, &s, dir, ifp, m, h, &pd);
d5238 2
a5239 2
		pf_status.bcounters[1][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[1][dir == PF_OUT][action]++;
a5242 11
	if (r != NULL && r->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->src.not);
	if (r != NULL && r->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->dst.not);

a5244 20
#ifdef ALTQ
	if (action != PF_DROP && r != NULL && r->qid) {
		struct m_tag	*mtag;
		struct altq_tag	*atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			if (pd.tos == IPTOS_LOWDELAY)
				atag->qid = r->pqid;
			else
				atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = AF_INET6;
			atag->hdr = h;
			m_tag_prepend(m, mtag);
		}
	}
#endif

d5247 1
a5247 2
			struct pf_rule	r0;

d5257 2
a5258 2
	if (r != NULL && r->rt)
		pf_route6(m0, r, dir, ifp, s);
@


1.95.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.95.2.6 2003/03/28 00:41:28 niklas Exp $ */
d108 22
d132 11
d153 2
d189 1
a189 1
			    struct pf_pdesc *, struct pf_rule **);
d192 1
a192 1
			    struct pf_pdesc *, struct pf_rule **);
d195 1
a195 1
			    void *, struct pf_pdesc *, struct pf_rule **);
d198 1
a198 1
			    struct pf_pdesc *, struct pf_rule **);
d201 1
a201 1
			    struct pf_pdesc *, struct pf_rule **);
d204 1
a204 1
			    void *, struct pf_pdesc *, u_short *);
a215 2
void			 pf_rule_set_qid(struct pf_rulequeue *);
u_int32_t		 pf_qname_to_qid(char *);
d231 2
d256 1
d274 3
d307 1
a307 1
		if (a->addr[0].addr32[3] > b->addr[0].addr32[3])
d309 1
a309 1
		if (a->addr[0].addr32[3] < b->addr[0].addr32[3])
d311 1
a311 1
		if (a->addr[1].addr32[3] > b->addr[1].addr32[3])
d313 1
a313 1
		if (a->addr[1].addr32[3] < b->addr[1].addr32[3])
d319 1
a319 1
		if (a->addr[1].addr32[2] > b->addr[1].addr32[2])
d321 1
a321 1
		if (a->addr[1].addr32[2] < b->addr[1].addr32[2])
d323 1
a323 1
		if (a->addr[0].addr32[1] > b->addr[0].addr32[1])
d325 1
a325 1
		if (a->addr[0].addr32[1] < b->addr[0].addr32[1])
d331 1
a331 1
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
d333 1
a333 1
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
d335 1
a335 1
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
d337 1
a337 1
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
d473 1
a473 37
	timeout_add(to, pf_default_rule.timeout[PFTM_INTERVAL] * hz);
}

u_int32_t
pf_state_expires(const struct pf_state *state)
{
	u_int32_t	timeout;
	u_int32_t	start;
	u_int32_t	end;
	u_int32_t	states;

	/* handle all PFTM_* > PFTM_MAX here */
	if (state->timeout == PFTM_PURGE)
		return (time.tv_sec);
	if (state->timeout == PFTM_UNTIL_PACKET)
		return (0);
	KASSERT(state->timeout < PFTM_MAX);
	timeout = state->rule.ptr->timeout[state->timeout];
	if (!timeout)
		timeout = pf_default_rule.timeout[state->timeout];
	start = state->rule.ptr->timeout[PFTM_ADAPTIVE_START];
	if (start) {
		end = state->rule.ptr->timeout[PFTM_ADAPTIVE_END];
		states = state->rule.ptr->states;
	} else {
		start = pf_default_rule.timeout[PFTM_ADAPTIVE_START];
		end = pf_default_rule.timeout[PFTM_ADAPTIVE_END];
		states = pf_status.states;
	}
	if (end && states > start && start < end) {
		if (states < end)
			return (state->expire + timeout * (end - states) /
			    (end - start));
		else
			return (time.tv_sec);
	}
	return (state->expire + timeout);
d485 1
a485 1
		if (pf_state_expires(cur->state) <= time.tv_sec) {
d507 4
a510 11
			if (--cur->state->rule.ptr->states <= 0)
				pf_rm_rule(NULL, cur->state->rule.ptr);
			if (cur->state->nat_rule.ptr != NULL)
				if (--cur->state->nat_rule.ptr->states <= 0)
					pf_rm_rule(NULL,
					    cur->state->nat_rule.ptr);
			if (cur->state->anchor.ptr != NULL)
				if (--cur->state->anchor.ptr->states <= 0)
					pf_rm_rule(NULL,
					    cur->state->anchor.ptr);
			pf_normalize_tcp_cleanup(cur->state);
d521 1
a521 1
pf_tbladdr_setup(struct pf_ruleset *rs, struct pf_addr_wrap *aw)
d525 1
a525 1
	if ((aw->p.tbl = pfr_attach_table(rs, aw->v.tblname)) == NULL)
a836 27
pf_rule_set_qid(struct pf_rulequeue *rules)
{
	struct pf_rule *rule;

	TAILQ_FOREACH(rule, rules, entries)
		if (rule->qname[0] != 0) {
			rule->qid = pf_qname_to_qid(rule->qname);
			if (rule->pqname[0] != 0)
				rule->pqid = pf_qname_to_qid(rule->pqname);
			else
				rule->pqid = rule->qid;
		}
}

u_int32_t
pf_qname_to_qid(char *qname)
{
	struct pf_altq		*altq;

	TAILQ_FOREACH(altq, pf_altqs_active, entries)
		if (!strcmp(altq->qname, qname))
			return (altq->qid);

	return (0);
}

void
d949 2
d955 2
d958 6
a963 14
	if (ip != NULL) {
		u_int16_t	oip = *ip;
		u_int32_t	opc;

		if (pc != NULL)
			opc = *pc;
		*ip = np;
		if (pc != NULL)
			*pc = pf_cksum_fixup(*pc, oip, *ip, u);
		*ic = pf_cksum_fixup(*ic, oip, *ip, 0);
		if (pc != NULL)
			*ic = pf_cksum_fixup(*ic, opc, *pc, 0);
	}
	/* Change inner ip address, fix inner ip and icmp checksums. */
d965 1
d997 1
a997 1
	/* Change outer ip address, fix outer ip or icmpv6 checksum. */
d1118 1
a1118 1
	if (r->qid) {
d1186 1
a1186 1
	if (r->qid) {
d1552 1
d1591 7
a1597 2
			if (low > high) {
				u_int16_t tmp;
d1599 3
a1601 8
				tmp = low;
				low = high;
				high = tmp;
			}
			/* low < high */
			cut = arc4random() % (1 + high - low) + low;
			/* low <= cut <= high */
			for (*nport = cut; *nport <= high; ++(*nport)) {
d1605 6
a1610 2
			}
			for (*nport = cut - 1; *nport >= low; --(*nport)) {
d1614 1
a1614 1
			}
d1904 1
a1904 1
    struct pf_pdesc *pd, struct pf_rule **am)
d1915 1
a1915 1
	struct pf_rule		*r, *a = NULL;
d1920 2
d1991 1
a1991 1
				*am = a;
d1996 1
a1996 1
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
d1999 2
a2000 2
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
a2002 2
	r = *rm;
	a = *am;
d2004 39
a2042 27
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);

	if (r->log) {
		if (rewrite)
			m_copyback(m, off, sizeof(*th), (caddr_t)th);
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
	}

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNRST) ||
	    (r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		/* undo NAT/RST changes, if they have taken place */
		if (nat != NULL) {
			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &baddr, bport, 0, af);
			rewrite++;
		} else if (rdr != NULL) {
			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &baddr, bport, 0, af);
			rewrite++;
d2044 3
a2046 10
		if ((r->rule_flag & PFRULE_RETURNRST) ||
		    (r->rule_flag & PFRULE_RETURN))
			pf_send_reset(off, th, pd, af,
			    r->return_ttl, r);
		else if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
d2049 2
a2050 4
	if (r->action == PF_DROP)
		return (PF_DROP);

	if (r->keep_state || nat != NULL || rdr != NULL) {
d2056 2
a2057 1
		if (!r->max_states || r->states < r->max_states)
d2064 4
a2067 4
		r->states++;
		if (a != NULL)
			a->states++;
		s->rule.ptr = r;
d2069 1
a2069 1
			s->nat_rule.ptr = nat;
d2071 5
a2075 6
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d2109 1
a2109 1
		    r->keep_state == PF_STATE_MODULATE) {
d2132 1
a2132 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_TCP_FIRST_PACKET;
a2134 7

		if ((pd->flags & PFDESC_TCP_NORM) && pf_normalize_tcp_init(m,
		    pd, th, &s->src, &s->dst)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
a2135 1
			pf_normalize_tcp_cleanup(s);
d2153 1
a2153 1
    struct pf_pdesc *pd, struct pf_rule **am)
d2164 1
a2164 1
	struct pf_rule		*r, *a = NULL;
d2169 2
d2238 1
a2238 1
				*am = a;
d2243 1
a2243 1
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
d2246 2
a2247 2
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
a2249 2
	r = *rm;
	a = *am;
d2251 34
a2284 26
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);

	if (r->log) {
		if (rewrite)
			m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
	}

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		/* undo NAT/RST changes, if they have taken place */
		if (nat != NULL) {
			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &baddr, bport, 1, af);
			rewrite++;
		} else if (rdr != NULL) {
			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &baddr, bport, 1, af);
			rewrite++;
d2286 3
a2288 6
		if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
d2291 2
a2292 4
	if (r->action == PF_DROP)
		return (PF_DROP);

	if (r->keep_state || nat != NULL || rdr != NULL) {
d2296 2
a2297 1
		if (!r->max_states || r->states < r->max_states)
d2302 2
a2303 3
		r->states++;
		if (a != NULL)
			a->states++;
d2305 1
a2305 1
		s->rule.ptr = r;
d2307 1
a2307 1
			s->nat_rule.ptr = nat;
d2309 5
a2313 6
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d2353 1
a2353 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_UDP_FIRST_PACKET;
d2374 1
a2374 1
    struct pf_pdesc *pd, struct pf_rule **am)
d2379 1
a2379 1
	struct pf_rule		*r, *a = NULL;
d2390 2
d2495 1
a2495 1
				*am = a;
d2500 1
a2500 1
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
d2503 2
a2504 2
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
a2506 2
	r = *rm;
	a = *am;
d2508 8
a2515 7
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);
d2517 1
a2517 1
	if (r->log) {
d2519 3
a2521 3
		if (rewrite)
			m_copyback(m, off, sizeof(struct icmp6_hdr),
			    (caddr_t)pd->hdr.icmp6);
d2523 5
a2527 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2530 1
a2530 4
	if (r->action != PF_PASS)
		return (PF_DROP);

	if (!state_icmp && (r->keep_state ||
d2535 2
a2536 1
		if (!r->max_states || r->states < r->max_states)
d2541 2
a2542 3
		r->states++;
		if (a != NULL)
			a->states++;
d2544 1
a2544 1
		s->rule.ptr = r;
d2546 1
a2546 1
			s->nat_rule.ptr = nat;
d2548 5
a2552 6
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d2588 1
a2588 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_ICMP_FIRST_PACKET;
d2602 1
a2602 1
		m_copyback(m, off, sizeof(struct icmp6_hdr),
d2611 1
a2611 2
    struct ifnet *ifp, struct mbuf *m, void *h, struct pf_pdesc *pd,
    struct pf_rule **am)
d2614 1
a2614 1
	struct pf_rule		*r, *a = NULL;
d2621 2
a2645 1
			PF_ACPY(&baddr, daddr, af);
d2687 1
a2687 1
				*am = a;
d2692 1
a2692 1
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
d2695 2
a2696 2
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
a2698 2
	r = *rm;
	a = *am;
d2700 10
a2709 14
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);
	if (r->log)
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		struct pf_addr *a = NULL;
d2711 2
a2712 25
		if (nat != NULL)
			a = saddr;
		else if (rdr != NULL)
			a = daddr;
		if (a != NULL) {
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&a->v4.s_addr, pd->ip_sum,
				    baddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(a, &baddr, af);
				break;
#endif /* INET6 */
			}
		}
		if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
d2715 2
a2716 4
	if (r->action != PF_PASS)
		return (PF_DROP);

	if (r->keep_state || nat != NULL || rdr != NULL) {
d2720 2
a2721 1
		if (!r->max_states || r->states < r->max_states)
d2726 2
a2727 3
		r->states++;
		if (a != NULL)
			a->states++;
d2729 1
a2729 1
		s->rule.ptr = r;
d2731 1
a2731 1
			s->nat_rule.ptr = nat;
d2733 5
a2737 6
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d2773 1
a2773 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_OTHER_FIRST_PACKET;
d2778 1
a2778 1
			if (r->log)
d2780 1
a2780 1
				    a ? a : r);
d2792 1
a2792 1
    struct mbuf *m, void *h, struct pf_pdesc *pd, struct pf_rule **am)
d2794 1
a2794 1
	struct pf_rule		*r, *a = NULL;
d2797 2
a2798 1
	u_short			 reason;
d2826 1
a2826 1
				*am = a;
d2831 1
a2831 1
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
d2834 2
a2835 2
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
a2837 2
	r = *rm;
	a = *am;
d2839 12
a2850 9
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);
	if (r->log)
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2852 3
a2854 2
	if (r->action != PF_PASS)
		return (PF_DROP);
d2861 1
a2861 2
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd,
    u_short *reason)
a2903 8
		if ((pd->flags & PFDESC_TCP_NORM || dst->scrub) &&
		    src->scrub == NULL) {
			if (pf_normalize_tcp_init(m, pd, th, src, dst)) {
				REASON_SET(reason, PFRES_MEMORY);
				return (PF_DROP);
			}
		}

a3016 1
		(*state)->expire = time.tv_sec;
d3019 2
a3020 1
			(*state)->timeout = PFTM_TCP_CLOSED;
d3023 2
a3024 1
			(*state)->timeout = PFTM_TCP_FIN_WAIT;
d3027 2
a3028 1
			(*state)->timeout = PFTM_TCP_OPENING;
d3031 2
a3032 1
			(*state)->timeout = PFTM_TCP_CLOSING;
d3034 2
a3035 1
			(*state)->timeout = PFTM_TCP_ESTABLISHED;
a3131 5
	if ((pd->flags & PFDESC_TCP_NORM) && (dst->scrub || src->scrub)) {
		if (pf_normalize_tcp_stateful(m, pd, reason, th, src, dst))
			return (PF_DROP);
	}

d3150 7
a3156 9
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
a3195 1
	(*state)->expire = time.tv_sec;
d3197 2
a3198 1
		(*state)->timeout = PFTM_UDP_MULTIPLE;
d3200 2
a3201 1
		(*state)->timeout = PFTM_UDP_SINGLE;
d3216 7
a3222 9
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
d3285 2
a3286 2
		(*state)->expire = time.tv_sec;
		(*state)->timeout = PFTM_ICMP_ERROR_REPLY;
d3304 1
a3304 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3323 1
a3323 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3517 1
a3517 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3578 1
a3578 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3645 2
a3646 2
			if (!pf_pull_hdr(m, off2, &iih,
			    sizeof(struct icmp6_hdr), NULL, NULL, pd2.af)) {
d3676 1
a3676 1
				m_copyback(m, off, sizeof(struct icmp6_hdr),
d3680 1
a3680 1
				m_copyback(m, off2, sizeof(struct icmp6_hdr),
d3688 5
a3692 2
		default: {
			struct pf_tree_node	key;
a3693 48
			key.af = pd2.af;
			key.proto = pd2.proto;
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = 0;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = 0;

			STATE_LOOKUP();

			if (STATE_TRANSLATE(*state)) {
				if (direction == PF_IN) {
					pf_change_icmp(pd2.src, NULL,
					    daddr, &(*state)->lan.addr,
					    0, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				} else {
					pf_change_icmp(pd2.dst, NULL,
					    saddr, &(*state)->gwy.addr,
					    0, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				}
				switch (pd2.af) {
#ifdef INET
				case AF_INET:
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2),
					    (caddr_t)&h2);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
					    (caddr_t)pd->hdr.icmp6);
					m_copyback(m, ipoff2, sizeof(h2_6),
					    (caddr_t)&h2_6);
					break;
#endif /* INET6 */
				}
			}

			return (PF_PASS);
			break;
		}
		}
a3730 1
	(*state)->expire = time.tv_sec;
d3732 2
a3733 1
		(*state)->timeout = PFTM_OTHER_MULTIPLE;
d3735 2
a3736 1
		(*state)->timeout = PFTM_OTHER_SINGLE;
d3772 7
a3778 9
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
d4245 1
a4245 1
	struct pf_rule	*a = NULL, *r = &pf_default_rule;
d4293 1
a4293 1
		action = pf_test_fragment(&r, dir, ifp, m, h, &pd, &a);
d4319 1
a4319 2
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd,
		    &reason);
d4325 1
a4325 1
			    m, 0, off, h, &pd, &a);
a4345 1
			a = s->anchor.ptr;
d4349 1
a4349 1
			    m, 0, off, h, &pd, &a);
d4370 3
a4372 6
			r->packets++;
			r->bytes += h->ip_len;
			a = s->anchor.ptr;
			if (a != NULL) {
				a->packets++;
				a->bytes += h->ip_len;
d4377 1
a4377 1
			    m, 0, off, h, &pd, &a);
a4384 1
			a = s->anchor.ptr;
d4387 1
a4387 1
			action = pf_test_other(&r, &s, dir, ifp, m, h, &pd, &a);
d4397 1
a4397 1
	if (r->src.addr.type == PF_ADDR_TABLE)
d4402 1
a4402 1
	if (r->dst.addr.type == PF_ADDR_TABLE)
d4409 1
a4409 1
	    !((s && s->allow_opts) || r->allow_opts)) {
d4418 1
a4418 1
	if (action != PF_DROP && r->qid) {
d4437 11
a4447 2
	if (log)
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, a ? a : r);
d4450 1
a4450 1
	if (r->rt)
d4464 1
a4464 1
	struct pf_rule	*a = NULL, *r = &pf_default_rule;
d4500 1
a4500 1
			action = pf_test_fragment(&r, dir, ifp, m, h, &pd, &a);
d4554 1
a4554 2
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd,
		    &reason);
d4560 1
a4560 1
			    m, 0, off, h, &pd, &a);
d4584 1
a4584 1
			    m, 0, off, h, &pd, &a);
d4606 4
a4609 2
			r->packets++;
			r->bytes += h->ip6_plen;
d4613 1
a4613 1
			    m, 0, off, h, &pd, &a);
d4618 1
a4618 1
		action = pf_test_other(&r, &s, dir, ifp, m, h, &pd, &a);
d4628 1
a4628 1
	if (r->src.addr.type == PF_ADDR_TABLE)
d4633 1
a4633 1
	if (r->dst.addr.type == PF_ADDR_TABLE)
d4642 1
a4642 1
	if (action != PF_DROP && r->qid) {
d4661 11
a4671 2
	if (log)
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, a ? a : r);
d4674 1
a4674 1
	if (r->rt)
@


1.95.2.8
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a101 1
struct pf_tagnames	 pf_tagnames;
d130 2
d152 6
a157 8
int			 pf_test_tcp(struct pf_rule **, struct pf_state **,
			    int, struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
int			 pf_test_udp(struct pf_rule **, struct pf_state **,
			    int, struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
d160 1
a160 2
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
d163 1
a163 2
			    struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
d166 1
a166 2
			    struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
d178 2
a182 3
struct pf_tag		*pf_get_tag(struct mbuf *);
int			 pf_tag_packet(struct mbuf *, struct pf_tag *,
			     u_int16_t);
a940 2

/* Changes a u_int32_t.  Uses a void * so there are no align restrictions */
d942 1
a942 1
pf_change_a(void *a, u_int16_t *c, u_int32_t an, u_int8_t u)
d944 1
a944 1
	u_int32_t	ao;
d946 1
a946 2
	memcpy(&ao, a, sizeof(ao));
	memcpy(a, &an, sizeof(u_int32_t));
a1345 31
struct pf_tag *
pf_get_tag(struct mbuf *m)
{
	struct m_tag	*mtag;

	if ((mtag = m_tag_find(m, PACKET_TAG_PF_TAG, NULL)) != NULL)
		return ((struct pf_tag *)(mtag + 1));
	else
		return (NULL);
}

int
pf_tag_packet(struct mbuf *m, struct pf_tag *pftag, u_int16_t tag)
{
	struct m_tag	*mtag;

	if (tag == 0)
		return (0);

	if (pftag == NULL) {
		mtag = m_tag_get(PACKET_TAG_PF_TAG, sizeof(*pftag), M_NOWAIT);
		if (mtag == NULL)
			return (1);
		((struct pf_tag *)(mtag + 1))->tag = tag;
		m_tag_prepend(m, mtag);
	} else
		pftag->tag = tag;

	return (0);
}

d1933 1
a1933 1
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
a1947 8
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
a1972 5
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

a2014 2
		else if (r->match_tag && r->match_tag != tag)
			r = TAILQ_NEXT(r, entries);
a2015 2
			if (r->tag)
				tag = r->tag;
a2018 1
				*rsm = ruleset;
a2031 1
	ruleset = *rsm;
d2044 1
a2044 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
d2076 1
a2076 7
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

	if (r->keep_state || nat != NULL || rdr != NULL ||
	    (pd->flags & PFDESC_TCP_NORM)) {
a2147 8
		s->src.max_win = MAX(ntohs(th->th_win), 1);
		if (s->src.wscale & PF_WSCALE_MASK) {
			/* Remove scale factor from initial window */
			int win = s->src.max_win;
			win += 1 << (s->src.wscale & PF_WSCALE_MASK);
			s->src.max_win = (win - 1) >>
			    (s->src.wscale & PF_WSCALE_MASK);
		}
d2150 1
d2164 1
a2164 1
		    off, pd, th, &s->src, &s->dst)) {
a2168 7
		if ((pd->flags & PFDESC_TCP_NORM) && s->src.scrub &&
		    pf_normalize_tcp_stateful(m, off, pd, &reason, th, &s->src,
		    &s->dst, &rewrite)) {
			pf_normalize_tcp_cleanup(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
d2188 1
a2188 1
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
a2202 8
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
a2227 5
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

a2265 2
		else if (r->match_tag && r->match_tag != tag)
			r = TAILQ_NEXT(r, entries);
a2268 2
			if (r->tag)
				tag = r->tag;
a2271 1
				*rsm = ruleset;
a2284 1
	ruleset = *rsm;
d2297 1
a2297 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
a2323 5
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

d2408 1
a2408 1
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
a2419 2
	struct pf_tag		*pftag;
	u_int16_t		 tag;
a2423 6
	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;

a2497 5
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

a2521 2
		else if (r->match_tag && r->match_tag != tag)
			r = TAILQ_NEXT(r, entries);
a2524 2
			if (r->tag)
				tag = r->tag;
a2527 1
				*rsm = ruleset;
a2540 1
	ruleset = *rsm;
d2556 1
a2556 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
a2561 5
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

d2646 1
a2646 1
    struct pf_rule **am, struct pf_ruleset **rsm)
a2654 8
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
a2695 5
	if (nat != NULL && nat->tag)
		tag = nat->tag;
	if (rdr != NULL && rdr->tag)
		tag = rdr->tag;

a2715 2
		else if (r->match_tag && r->match_tag != tag)
			r = TAILQ_NEXT(r, entries);
a2718 2
			if (r->tag)
				tag = r->tag;
a2721 1
				*rsm = ruleset;
a2734 1
	ruleset = *rsm;
d2744 1
a2744 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
a2780 5
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

d2847 1
a2847 1
				    r, a, ruleset);
d2859 1
a2859 2
    struct mbuf *m, void *h, struct pf_pdesc *pd, struct pf_rule **am,
    struct pf_ruleset **rsm)
a2864 8
	struct pf_tag		*pftag;
	u_int16_t		 tag;

	pftag = pf_get_tag(m);
	if (pftag != NULL)
		tag = pftag->tag;
	else
		tag = 0;
a2886 2
		else if (r->match_tag && r->match_tag != tag)
			r = TAILQ_NEXT(r, entries);
a2892 1
				*rsm = ruleset;
a2905 1
	ruleset = *rsm;
d2915 1
a2915 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
a2919 5
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

a2933 1
	int			 copyback = 0;
d2971 1
a2971 1
			if (pf_normalize_tcp_init(m, off, pd, th, src, dst)) {
a2984 1
			copyback = 1;
d2992 1
a2992 18
			if (dst->wscale & PF_WSCALE_FLAG) {
				src->wscale = pf_get_wscale(m, off, th->th_off,
				    pd->af);
				if (src->wscale & PF_WSCALE_FLAG) {
					/* Remove scale factor from initial
					 * window */
					sws = src->wscale & PF_WSCALE_MASK;
					win = ((u_int32_t)win + (1 << sws) - 1)
					    >> sws;
					dws = dst->wscale & PF_WSCALE_MASK;
				} else {
					/* fixup other window */
					dst->max_win <<= dst->wscale &
					    PF_WSCALE_MASK;
					/* in case of a retrans SYN|ACK */
					dst->wscale = 0;
				}
			}
a3018 1
			copyback = 1;
d3055 2
a3056 2
	    /* Acking not more than one reassembled fragment backwards */
	    (ackskew <= (MAXACKWINDOW << dws))) {
d3201 2
a3202 3
	if (dst->scrub || src->scrub) {
		if (pf_normalize_tcp_stateful(m, off, pd, reason, th, src, dst,
		    &copyback))
d3219 2
a3220 2
	} else if (copyback) {
		/* Copyback sequence modulation or stateful scrub changes */
d4369 8
a4376 9
	u_short		   action, reason = 0, log = 0;
	struct mbuf	  *m = *m0;
	struct ip	  *h;
	struct pf_rule	  *a = NULL, *r = &pf_default_rule;
	struct pf_state	  *s = NULL;
	struct pf_ruleset *ruleset = NULL;
	struct pf_pdesc	   pd;
	int		   off;
	int		   pqid = 0;
d4420 1
a4420 2
		action = pf_test_fragment(&r, dir, ifp, m, h,
		    &pd, &a, &ruleset);
d4453 1
a4453 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4478 1
a4478 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4509 1
a4509 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4520 1
a4520 2
			action = pf_test_other(&r, &s, dir, ifp, m, h,
			    &pd, &a, &ruleset);
d4571 1
a4571 1
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r, a, ruleset);
d4585 7
a4591 8
	u_short		   action, reason = 0, log = 0;
	struct mbuf	  *m = *m0;
	struct ip6_hdr	  *h;
	struct pf_rule	  *a = NULL, *r = &pf_default_rule;
	struct pf_state	  *s = NULL;
	struct pf_ruleset *ruleset = NULL;
	struct pf_pdesc    pd;
	int		   off, terminal = 0;
d4624 1
a4624 2
			action = pf_test_fragment(&r, dir, ifp, m, h,
			    &pd, &a, &ruleset);
d4685 1
a4685 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4709 1
a4709 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4736 1
a4736 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4741 1
a4741 2
		action = pf_test_other(&r, &s, dir, ifp, m, h,
		    &pd, &a, &ruleset);
d4785 1
a4785 1
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r, a, ruleset);
@


1.95.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.95.2.8 2003/05/16 00:29:43 niklas Exp $ */
d62 1
d139 3
a141 4
void			 pf_send_tcp(const struct pf_rule *, sa_family_t,
			    const struct pf_addr *, const struct pf_addr *,
			    u_int16_t, u_int16_t, u_int32_t, u_int32_t,
			    u_int8_t, u_int16_t, u_int8_t);
d186 2
a187 3
int			 pf_match_tag(struct mbuf *, struct pf_rule *,
			     struct pf_rule *, struct pf_rule *,
			     struct pf_tag *, int *);
a487 10
			if (cur->state->src.state == PF_TCPS_PROXY_DST)
				pf_send_tcp(cur->state->rule.ptr,
				    cur->state->af,
				    &cur->state->ext.addr,
				    &cur->state->lan.addr,
				    cur->state->ext.port,
				    cur->state->lan.port,
				    cur->state->src.seqhi,
				    cur->state->src.seqlo + 1,
				    TH_RST|TH_ACK, 0, 0);
d1068 2
a1069 4
pf_send_tcp(const struct pf_rule *r, sa_family_t af,
    const struct pf_addr *saddr, const struct pf_addr *daddr,
    u_int16_t sport, u_int16_t dport, u_int32_t seq, u_int32_t ack,
    u_int8_t flags, u_int16_t win, u_int8_t ttl)
d1075 1
a1075 1
	struct ip	*h;
d1078 1
a1078 1
	struct ip6_hdr	*h6;
d1080 1
a1080 1
	struct tcphdr	*th;
d1095 4
a1108 15
#ifdef ALTQ
	if (r != NULL && r->qid) {
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m, struct ip *);
			m_tag_prepend(m, mtag);
		}
	}
#endif
d1116 1
a1116 1
		h = mtod(m, struct ip *);
d1119 4
a1122 4
		h->ip_p = IPPROTO_TCP;
		h->ip_len = htons(sizeof(*th));
		h->ip_src.s_addr = saddr->v4.s_addr;
		h->ip_dst.s_addr = daddr->v4.s_addr;
d1124 1
a1124 1
		th = (struct tcphdr *)((caddr_t)h + sizeof(struct ip));
d1129 1
a1129 1
		h6 = mtod(m, struct ip6_hdr *);
d1132 4
a1135 4
		h6->ip6_nxt = IPPROTO_TCP;
		h6->ip6_plen = htons(sizeof(*th));
		memcpy(&h6->ip6_src, &saddr->v6, sizeof(struct in6_addr));
		memcpy(&h6->ip6_dst, &daddr->v6, sizeof(struct in6_addr));
d1137 1
a1137 1
		th = (struct tcphdr *)((caddr_t)h6 + sizeof(struct ip6_hdr));
d1143 31
a1173 7
	th->th_sport = sport;
	th->th_dport = dport;
	th->th_seq = htonl(seq);
	th->th_ack = htonl(ack);
	th->th_off = sizeof(*th) >> 2;
	th->th_flags = flags;
	th->th_win = htons(win);
d1179 1
a1179 1
		th->th_sum = in_cksum(m, len);
d1182 8
a1189 7
		h->ip_v = 4;
		h->ip_hl = sizeof(*h) >> 2;
		h->ip_tos = IPTOS_LOWDELAY;
		h->ip_len = len;
		h->ip_off = ip_mtudisc ? IP_DF : 0;
		h->ip_ttl = ttl ? ttl : ip_defttl;
		h->ip_sum = 0;
d1197 1
a1197 1
		th->th_sum = in6_cksum(m, IPPROTO_TCP,
d1200 4
a1203 2
		h6->ip6_vfc |= IPV6_VERSION;
		h6->ip6_hlim = IPV6_DEFHLIM;
d1366 1
a1366 21
pf_match_tag(struct mbuf *m, struct pf_rule *r, struct pf_rule *nat,
    struct pf_rule *rdr, struct pf_tag *pftag, int *tag)
{
	if (*tag == -1) {	/* find mbuf tag */
		pftag = pf_get_tag(m);
		if (pftag != NULL)
			*tag = pftag->tag;
		else
			*tag = 0;
		if (nat != NULL && nat->tag)
			*tag = nat->tag;
		if (rdr != NULL && rdr->tag)
			*tag = rdr->tag;
	}

	return ((!r->match_tag_not && r->match_tag == *tag) ||
	    (r->match_tag_not && r->match_tag != *tag));
}

int
pf_tag_packet(struct mbuf *m, struct pf_tag *pftag, int tag)
d1370 1
a1370 1
	if (tag <= 0)
d1832 2
a1833 1
			if (pf_map_addr(r->af, &r->rpool, saddr, naddr, NULL))
d1987 8
a1994 2
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
d2020 5
d2067 1
a2067 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
d2109 1
a2109 1
		/* undo NAT changes, if they have taken place */
d2119 5
a2123 14
		if (((r->rule_flag & PFRULE_RETURNRST) ||
		    (r->rule_flag & PFRULE_RETURN)) &&
		    !(th->th_flags & TH_RST)) {
			u_int32_t ack = ntohl(th->th_seq) + pd->p_len;

			if (th->th_flags & TH_SYN)
				ack++;
			if (th->th_flags & TH_FIN)
				ack++;
			pf_send_tcp(r, af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    ntohl(th->th_ack), ack, TH_RST|TH_ACK, 0,
			    r->return_ttl);
		} else if ((af == AF_INET) && r->return_icmp)
a2253 17
		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
		    r->keep_state == PF_STATE_SYNPROXY) {
			s->src.state = PF_TCPS_PROXY_SRC;
			if (nat != NULL)
				pf_change_ap(saddr, &th->th_sport,
				    pd->ip_sum, &th->th_sum, &baddr,
				    bport, 0, af);
			else if (rdr != NULL)
				pf_change_ap(daddr, &th->th_dport,
				    pd->ip_sum, &th->th_sum, &baddr,
				    bport, 0, af);
			s->src.seqhi = arc4random();
			pf_send_tcp(r, af, daddr, saddr, th->th_dport,
			    th->th_sport, s->src.seqhi,
			    ntohl(th->th_seq) + 1, TH_SYN|TH_ACK, 0, 0);
			return (PF_SYNPROXY_DROP);
		}
d2281 8
a2288 2
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
d2314 5
d2357 1
a2357 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
d2400 1
a2400 1
		/* undo NAT changes, if they have taken place */
d2522 2
a2523 2
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
d2528 6
d2608 5
d2637 1
a2637 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
d2781 8
a2788 2
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
d2830 5
d2855 1
a2855 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
d3016 8
a3023 2
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
d3046 1
a3046 2
		else if (r->match_tag &&
		    !pf_match_tag(m, r, NULL, NULL, pftag, &tag))
a3121 70
	if ((*state)->src.state == PF_TCPS_PROXY_SRC) {
		if (direction != (*state)->direction)
			return (PF_SYNPROXY_DROP);
		if (th->th_flags & TH_SYN) {
			if (ntohl(th->th_seq) != (*state)->src.seqlo)
				return (PF_DROP);
			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    (*state)->src.seqhi, ntohl(th->th_seq) + 1,
			    TH_SYN|TH_ACK, 0, 0);
			return (PF_SYNPROXY_DROP);
		} else if (!(th->th_flags & TH_ACK) ||
		    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
		    (ntohl(th->th_seq) != (*state)->src.seqlo + 1))
			return (PF_DROP);
		else
			(*state)->src.state = PF_TCPS_PROXY_DST;
	}
	if ((*state)->src.state == PF_TCPS_PROXY_DST) {
		struct pf_state_host *src, *dst;

		if (direction == PF_OUT) {
			src = &(*state)->gwy;
			dst = &(*state)->ext;
		} else {
			src = &(*state)->ext;
			dst = &(*state)->lan;
		}
		if (direction == (*state)->direction) {
			if (((th->th_flags & (TH_SYN|TH_ACK)) != TH_ACK) ||
			    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
			    (ntohl(th->th_seq) != (*state)->src.seqlo + 1))
				return (PF_DROP);
			(*state)->src.max_win = MAX(ntohs(th->th_win), 1);
			if ((*state)->dst.seqhi == 1)
				(*state)->dst.seqhi = arc4random();
			pf_send_tcp((*state)->rule.ptr, pd->af, &src->addr,
			    &dst->addr, src->port, dst->port,
			    (*state)->dst.seqhi, 0, TH_SYN, 0, 0);
			return (PF_SYNPROXY_DROP);
		} else if (((th->th_flags & (TH_SYN|TH_ACK)) !=
		    (TH_SYN|TH_ACK)) ||
		    (ntohl(th->th_ack) != (*state)->dst.seqhi + 1))
			return (PF_DROP);
		else {
			(*state)->dst.max_win = MAX(ntohs(th->th_win), 1);
			(*state)->dst.seqlo = ntohl(th->th_seq);
			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    ntohl(th->th_ack), ntohl(th->th_seq) + 1,
			    TH_ACK, (*state)->src.max_win, 0);
			pf_send_tcp((*state)->rule.ptr, pd->af, &src->addr,
			    &dst->addr, src->port, dst->port,
			    (*state)->src.seqhi + 1, (*state)->src.seqlo + 1,
			    TH_ACK, (*state)->dst.max_win, 0);
			(*state)->src.seqdiff = (*state)->dst.seqhi -
			    (*state)->src.seqlo;
			(*state)->dst.seqdiff = (*state)->src.seqhi -
			    (*state)->dst.seqlo;
			(*state)->src.seqhi = (*state)->src.seqlo +
			    (*state)->src.max_win;
			(*state)->dst.seqhi = (*state)->dst.seqlo +
			    (*state)->dst.max_win;
			(*state)->src.wscale = (*state)->dst.wscale = 0;
			(*state)->src.state = (*state)->dst.state =
			    TCPS_ESTABLISHED;
			return (PF_SYNPROXY_DROP);
		}
	}

d3147 1
a3147 1
		if (dst->seqdiff && !src->seqdiff) {
d3363 2
a3364 13
			if (!(th->th_flags & TH_RST)) {
				u_int32_t ack = ntohl(th->th_seq) + pd->p_len;

				if (th->th_flags & TH_SYN)
					ack++;
				if (th->th_flags & TH_FIN)
					ack++;
				pf_send_tcp((*state)->rule.ptr, pd->af,
				    pd->dst, pd->src, th->th_dport,
				    th->th_sport, ntohl(th->th_ack), ack,
				    TH_RST|TH_ACK, 0,
				    (*state)->rule.ptr->return_ttl);
			}
d4586 1
a4586 1
		action = PF_DROP;
d4718 1
a4718 1
		pf_status.pcounters[0][dir == PF_OUT][action != PF_PASS]++;
d4733 1
a4733 1
	if (action == PF_PASS && h->ip_hl > 5 &&
d4743 1
a4743 1
	if (action == PF_PASS && r->qid) {
d4765 2
a4766 6
	if (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} else if (r->rt)
		/* pf_route can free the mbuf causing *m0 to become NULL */
d4942 1
a4942 1
		pf_status.pcounters[1][dir == PF_OUT][action != PF_PASS]++;
d4960 1
a4960 1
	if (action == PF_PASS && r->qid) {
d4982 2
a4983 6
	if (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} else if (r->rt)
		/* pf_route6 can free the mbuf causing *m0 to become NULL */
@


1.95.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a4 1
 * Copyright (c) 2002,2003 Henning Brauer
a79 1
#include <netinet6/nd6.h>
d88 1
d101 2
a105 1
int			 altqs_inactive_open;
d110 1
a110 1
struct pool		 pf_src_tree_pl, pf_rule_pl;
d113 8
d141 1
a141 1
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t);
d144 1
a144 2
struct pf_rule		*pf_match_translation(struct pf_pdesc *, struct mbuf *,
			    int, int, struct pfi_kif *,
d146 2
a147 3
			    u_int16_t, int);
struct pf_rule		*pf_get_translation(struct pf_pdesc *, struct mbuf *,
			    int, int, struct pfi_kif *, struct pf_src_node **,
d150 1
a150 1
			    struct pf_addr *, u_int16_t *);
d152 1
a152 1
			    int, struct pfi_kif *, struct mbuf *, int,
d156 1
a156 1
			    int, struct pfi_kif *, struct mbuf *, int,
d160 1
a160 1
			    int, struct pfi_kif *, struct mbuf *, int,
d164 1
a164 1
			    int, struct pfi_kif *, struct mbuf *, int, void *,
d168 1
a168 1
			    struct pfi_kif *, struct mbuf *, void *,
d172 1
a172 1
			    struct pfi_kif *, struct mbuf *, int,
d175 1
a175 1
			    struct pfi_kif *, struct mbuf *, int,
d178 1
a178 1
			    struct pfi_kif *, struct mbuf *, int,
d181 4
a184 1
			    struct pfi_kif *, struct pf_pdesc *);
d187 9
a195 1
			     struct pf_rule *, struct pf_tag *, int *);
d198 1
a198 1
int			 pf_map_addr(u_int8_t, struct pf_rule *,
d200 2
a201 2
			    struct pf_addr *, struct pf_src_node **);
int			 pf_get_sport(sa_family_t, u_int8_t, struct pf_rule *,
d203 1
a203 2
			    struct pf_addr *, u_int16_t*, u_int16_t, u_int16_t,
			    struct pf_src_node **);
d208 1
a208 1
int			 pf_socket_lookup(uid_t *, gid_t *,
a211 6
u_int16_t		 pf_get_mss(struct mbuf *, int, u_int16_t,
			    sa_family_t);
u_int16_t		 pf_calc_mss(struct pf_addr *, sa_family_t,
				u_int16_t);
void			 pf_set_rt_ifp(struct pf_state *,
			    struct pf_addr *);
a213 5
int			 pf_addr_wrap_neq(struct pf_addr_wrap *,
			    struct pf_addr_wrap *);
static int		 pf_add_mbuf_tag(struct mbuf *, u_int);
struct pf_state		*pf_find_state_recurse(struct pfi_kif *,
			    struct pf_state *, u_int8_t);
d221 1
a221 2
			*state = pf_find_state_recurse(		\
			    kif, &key, PF_EXT_GWY);			\
d223 1
a223 2
			*state = pf_find_state_recurse(		\
			    kif, &key, PF_LAN_EXT);			\
d231 2
a232 2
		    (*state)->rt_kif != NULL &&				\
		    (*state)->rt_kif != kif)				\
d244 2
a245 132
#define BOUND_IFACE(r, k) (((r)->rule_flag & PFRULE_IFBOUND) ? (k) :   \
	((r)->rule_flag & PFRULE_GRBOUND) ? (k)->pfik_parent :	       \
	(k)->pfik_parent->pfik_parent)

static __inline int pf_src_compare(struct pf_src_node *, struct pf_src_node *);
static __inline int pf_state_compare_lan_ext(struct pf_state *,
	struct pf_state *);
static __inline int pf_state_compare_ext_gwy(struct pf_state *,
	struct pf_state *);
static __inline int pf_state_compare_id(struct pf_state *,
	struct pf_state *);

struct pf_src_tree tree_src_tracking;

struct pf_state_tree_id tree_id;

RB_GENERATE(pf_src_tree, pf_src_node, entry, pf_src_compare);
RB_GENERATE(pf_state_tree_lan_ext, pf_state,
    u.s.entry_lan_ext, pf_state_compare_lan_ext);
RB_GENERATE(pf_state_tree_ext_gwy, pf_state,
    u.s.entry_ext_gwy, pf_state_compare_ext_gwy);
RB_GENERATE(pf_state_tree_id, pf_state,
    u.s.entry_id, pf_state_compare_id);

static __inline int
pf_src_compare(struct pf_src_node *a, struct pf_src_node *b)
{
	int	diff;

	if (a->rule.ptr > b->rule.ptr)
		return (1);
	if (a->rule.ptr < b->rule.ptr)
		return (-1);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->addr.addr32[0] > b->addr.addr32[0])
			return (1);
		if (a->addr.addr32[0] < b->addr.addr32[0])
			return (-1);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->addr.addr32[3] > b->addr.addr32[3])
			return (1);
		if (a->addr.addr32[3] < b->addr.addr32[3])
			return (-1);
		if (a->addr.addr32[2] > b->addr.addr32[2])
			return (1);
		if (a->addr.addr32[2] < b->addr.addr32[2])
			return (-1);
		if (a->addr.addr32[1] > b->addr.addr32[1])
			return (1);
		if (a->addr.addr32[1] < b->addr.addr32[1])
			return (-1);
		if (a->addr.addr32[0] > b->addr.addr32[0])
			return (1);
		if (a->addr.addr32[0] < b->addr.addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}
	return (0);
}

static __inline int
pf_state_compare_lan_ext(struct pf_state *a, struct pf_state *b)
{
	int	diff;

	if ((diff = a->proto - b->proto) != 0)
		return (diff);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->lan.addr.addr32[0] > b->lan.addr.addr32[0])
			return (1);
		if (a->lan.addr.addr32[0] < b->lan.addr.addr32[0])
			return (-1);
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->lan.addr.addr32[3] > b->lan.addr.addr32[3])
			return (1);
		if (a->lan.addr.addr32[3] < b->lan.addr.addr32[3])
			return (-1);
		if (a->ext.addr.addr32[3] > b->ext.addr.addr32[3])
			return (1);
		if (a->ext.addr.addr32[3] < b->ext.addr.addr32[3])
			return (-1);
		if (a->lan.addr.addr32[2] > b->lan.addr.addr32[2])
			return (1);
		if (a->lan.addr.addr32[2] < b->lan.addr.addr32[2])
			return (-1);
		if (a->ext.addr.addr32[2] > b->ext.addr.addr32[2])
			return (1);
		if (a->ext.addr.addr32[2] < b->ext.addr.addr32[2])
			return (-1);
		if (a->lan.addr.addr32[1] > b->lan.addr.addr32[1])
			return (1);
		if (a->lan.addr.addr32[1] < b->lan.addr.addr32[1])
			return (-1);
		if (a->ext.addr.addr32[1] > b->ext.addr.addr32[1])
			return (1);
		if (a->ext.addr.addr32[1] < b->ext.addr.addr32[1])
			return (-1);
		if (a->lan.addr.addr32[0] > b->lan.addr.addr32[0])
			return (1);
		if (a->lan.addr.addr32[0] < b->lan.addr.addr32[0])
			return (-1);
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}

	if ((diff = a->lan.port - b->lan.port) != 0)
		return (diff);
	if ((diff = a->ext.port - b->ext.port) != 0)
		return (diff);
d247 2
a248 2
	return (0);
}
d251 1
a251 1
pf_state_compare_ext_gwy(struct pf_state *a, struct pf_state *b)
d262 1
a262 1
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
d264 1
a264 1
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
d266 1
a266 1
		if (a->gwy.addr.addr32[0] > b->gwy.addr.addr32[0])
d268 1
a268 1
		if (a->gwy.addr.addr32[0] < b->gwy.addr.addr32[0])
d274 1
a274 1
		if (a->ext.addr.addr32[3] > b->ext.addr.addr32[3])
d276 1
a276 1
		if (a->ext.addr.addr32[3] < b->ext.addr.addr32[3])
d278 1
a278 1
		if (a->gwy.addr.addr32[3] > b->gwy.addr.addr32[3])
d280 1
a280 1
		if (a->gwy.addr.addr32[3] < b->gwy.addr.addr32[3])
d282 1
a282 1
		if (a->ext.addr.addr32[2] > b->ext.addr.addr32[2])
d284 1
a284 1
		if (a->ext.addr.addr32[2] < b->ext.addr.addr32[2])
d286 1
a286 1
		if (a->gwy.addr.addr32[2] > b->gwy.addr.addr32[2])
d288 1
a288 1
		if (a->gwy.addr.addr32[2] < b->gwy.addr.addr32[2])
d290 1
a290 1
		if (a->ext.addr.addr32[1] > b->ext.addr.addr32[1])
d292 1
a292 1
		if (a->ext.addr.addr32[1] < b->ext.addr.addr32[1])
d294 1
a294 1
		if (a->gwy.addr.addr32[1] > b->gwy.addr.addr32[1])
d296 1
a296 1
		if (a->gwy.addr.addr32[1] < b->gwy.addr.addr32[1])
d298 1
a298 1
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
d300 1
a300 1
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
d302 1
a302 1
		if (a->gwy.addr.addr32[0] > b->gwy.addr.addr32[0])
d304 1
a304 1
		if (a->gwy.addr.addr32[0] < b->gwy.addr.addr32[0])
d310 1
a310 1
	if ((diff = a->ext.port - b->ext.port) != 0)
d312 1
a312 1
	if ((diff = a->gwy.port - b->gwy.port) != 0)
a317 15
static __inline int
pf_state_compare_id(struct pf_state *a, struct pf_state *b)
{
	if (a->id > b->id)
		return (1);
	if (a->id < b->id)
		return (-1);
	if (a->creatorid > b->creatorid)
		return (1);
	if (a->creatorid < b->creatorid)
		return (-1);

	return (0);
}

d339 1
a339 1
pf_find_state_byid(struct pf_state *key)
d341 1
a341 8
	pf_status.fcounters[FCNT_STATE_SEARCH]++;
	return RB_FIND(pf_state_tree_id, &tree_id, key);
}

struct pf_state *
pf_find_state_recurse(struct pfi_kif *kif, struct pf_state *key, u_int8_t tree)
{
	struct pf_state *s;
d344 4
a347 9

	switch (tree) {
	case PF_LAN_EXT:
		for (; kif != NULL; kif = kif->pfik_parent) {
			s = RB_FIND(pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext, key);
			if (s != NULL)
				return (s);
		}
a348 49
	case PF_EXT_GWY:
		for (; kif != NULL; kif = kif->pfik_parent) {
			s = RB_FIND(pf_state_tree_ext_gwy,
			    &kif->pfik_ext_gwy, key);
			if (s != NULL)
				return (s);
		}
		return (NULL);
	default:
		panic("pf_find_state_recurse");
	}
}

struct pf_state *
pf_find_state_all(struct pf_state *key, u_int8_t tree, int *more)
{
	struct pf_state *s, *ss = NULL;
	struct pfi_kif	*kif;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	switch(tree) {
	case PF_LAN_EXT:
		TAILQ_FOREACH(kif, &pfi_statehead, pfik_w_states) {
			s = RB_FIND(pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext, key);
			if (s == NULL)
				continue;
			if (more == NULL)
				return (s);
			ss = s;
			(*more)++;
		}
		return (ss);
	case PF_EXT_GWY:
		TAILQ_FOREACH(kif, &pfi_statehead, pfik_w_states) {
			s = RB_FIND(pf_state_tree_ext_gwy,
			    &kif->pfik_ext_gwy, key);
			if (s == NULL)
				continue;
			if (more == NULL)
				return (s);
			ss = s;
			(*more)++;
		}
		return (ss);
	default:
		panic("pf_find_state_all");
	}
d352 1
a352 2
pf_insert_src_node(struct pf_src_node **sn, struct pf_rule *rule,
    struct pf_addr *src, sa_family_t af)
d354 1
a354 1
	struct pf_src_node  k;
d356 10
a365 48
	if (*sn == NULL) {
		k.af = af;
		PF_ACPY(&k.addr, src, af);
		if (rule->rule_flag & PFRULE_RULESRCTRACK ||
		    rule->rpool.opts & PF_POOL_STICKYADDR)
			k.rule.ptr = rule;
		else
			k.rule.ptr = NULL;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		*sn = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
	}
	if (*sn == NULL) {
		if (!rule->max_src_nodes ||
		    rule->src_nodes < rule->max_src_nodes)
			(*sn) = pool_get(&pf_src_tree_pl, PR_NOWAIT);
		if ((*sn) == NULL)
			return (-1);
		bzero(*sn, sizeof(struct pf_src_node));
		(*sn)->af = af;
		if (rule->rule_flag & PFRULE_RULESRCTRACK ||
		    rule->rpool.opts & PF_POOL_STICKYADDR)
			(*sn)->rule.ptr = rule;
		else
			(*sn)->rule.ptr = NULL;
		PF_ACPY(&(*sn)->addr, src, af);
		if (RB_INSERT(pf_src_tree,
		    &tree_src_tracking, *sn) != NULL) {
			if (pf_status.debug >= PF_DEBUG_MISC) {
				printf("pf: src_tree insert failed: ");
				pf_print_host(&(*sn)->addr, 0, af);
				printf("\n");
			}
			pool_put(&pf_src_tree_pl, *sn);
			return (-1);
		}
		(*sn)->creation = time.tv_sec;
		(*sn)->ruletype = rule->action;
		if ((*sn)->rule.ptr != NULL)
			(*sn)->rule.ptr->src_nodes++;
		 pf_status.scounters[SCNT_SRC_NODE_INSERT]++;
		 pf_status.src_nodes++;
	} else {
		if (rule->max_src_states &&
		    (*sn)->states >= rule->max_src_states)
			return (-1);
	}
	return (0);
}
a366 3
int
pf_insert_state(struct pfi_kif *kif, struct pf_state *state)
{
d368 1
a368 2
	state->u.s.kif = kif;
	if (RB_INSERT(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state)) {
a379 2
			if (state->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
d382 9
a390 1
		pf_src_tree_remove_state(state);
d393 7
d401 1
a401 1
	if (RB_INSERT(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy, state)) {
a412 2
			if (state->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
d415 3
a417 20
		RB_REMOVE(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state);
		pf_src_tree_remove_state(state);
		return (-1);
	}

	if (state->id == 0 && state->creatorid == 0) {
		state->id = htobe64(pf_status.stateid++);
		state->creatorid = pf_status.hostid;
	}
	if (RB_INSERT(pf_state_tree_id, &tree_id, state) != NULL) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: "
			    "id: %016llx creatorid: %08x",
			    betoh64(state->id), ntohl(state->creatorid));
			if (state->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
			printf("\n");
		}
		RB_REMOVE(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state);
		RB_REMOVE(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy, state);
a422 1
	pfi_attach_state(kif);
a437 1
	pf_purge_expired_src_nodes();
d480 1
a480 1
pf_purge_expired_src_nodes(void)
d482 2
a483 1
	 struct pf_src_node		*cur, *next;
d485 2
a486 2
	 for (cur = RB_MIN(pf_src_tree, &tree_src_tracking); cur; cur = next) {
		 next = RB_NEXT(pf_src_tree, &tree_src_tracking, cur);
d488 12
a499 37
		 if (cur->states <= 0 && cur->expire <= time.tv_sec) {
			 if (cur->rule.ptr != NULL) {
				 cur->rule.ptr->src_nodes--;
				 if (cur->rule.ptr->states <= 0 &&
				     cur->rule.ptr->max_src_nodes <= 0)
					 pf_rm_rule(NULL, cur->rule.ptr);
			 }
			 RB_REMOVE(pf_src_tree, &tree_src_tracking, cur);
			 pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
			 pf_status.src_nodes--;
			 pool_put(&pf_src_tree_pl, cur);
		 }
	 }
}

void
pf_src_tree_remove_state(struct pf_state *s)
{
	u_int32_t timeout;

	if (s->src_node != NULL) {
		if (--s->src_node->states <= 0) {
			timeout = s->rule.ptr->timeout[PFTM_SRC_NODE];
			if (!timeout)
				timeout = pf_default_rule.timeout[PFTM_SRC_NODE];
			s->src_node->expire = time.tv_sec + timeout;
		}
	}
	if (s->nat_src_node != s->src_node && s->nat_src_node != NULL) {
		if (--s->nat_src_node->states <= 0) {
			timeout = s->rule.ptr->timeout[PFTM_SRC_NODE];
			if (!timeout)
				timeout = pf_default_rule.timeout[PFTM_SRC_NODE];
			s->nat_src_node->expire = time.tv_sec + timeout;
		}
	}
}
d501 15
a515 4
void
pf_purge_expired_states(void)
{
	struct pf_state		*cur, *next;
a516 16
	for (cur = RB_MIN(pf_state_tree_id, &tree_id);
	    cur; cur = next) {
		next = RB_NEXT(pf_state_tree_id, &tree_id, cur);

		if (pf_state_expires(cur) <= time.tv_sec) {
			if (cur->src.state == PF_TCPS_PROXY_DST)
				pf_send_tcp(cur->rule.ptr, cur->af,
				    &cur->ext.addr, &cur->lan.addr,
				    cur->ext.port, cur->lan.port,
				    cur->src.seqhi, cur->src.seqlo + 1, 0,
				    TH_RST|TH_ACK, 0, 0);
			RB_REMOVE(pf_state_tree_ext_gwy,
			    &cur->u.s.kif->pfik_ext_gwy, cur);
			RB_REMOVE(pf_state_tree_lan_ext,
			    &cur->u.s.kif->pfik_lan_ext, cur);
			RB_REMOVE(pf_state_tree_id, &tree_id, cur);
d518 1
a518 1
			pfsync_delete_state(cur);
d520 14
a533 14
			pf_src_tree_remove_state(cur);
			if (--cur->rule.ptr->states <= 0 &&
			    cur->rule.ptr->src_nodes <= 0)
				pf_rm_rule(NULL, cur->rule.ptr);
			if (cur->nat_rule.ptr != NULL)
				if (--cur->nat_rule.ptr->states <= 0 &&
					cur->nat_rule.ptr->src_nodes <= 0)
					pf_rm_rule(NULL, cur->nat_rule.ptr);
			if (cur->anchor.ptr != NULL)
				if (--cur->anchor.ptr->states <= 0)
					pf_rm_rule(NULL, cur->anchor.ptr);
			pf_normalize_tcp_cleanup(cur);
			pfi_detach_state(cur->u.s.kif);
			pool_put(&pf_state_pl, cur);
d562 91
a652 1
	struct pfr_ktable *kt = aw->p.tbl;
d654 4
a657 1
	if (aw->type != PF_ADDR_TABLE || kt == NULL)
d659 2
a660 5
	if (!(kt->pfrkt_flags & PFR_TFLAG_ACTIVE) && kt->pfrkt_root != NULL)
		kt = kt->pfrkt_root;
	aw->p.tbl = NULL;
	aw->p.tblcnt = (kt->pfrkt_flags & PFR_TFLAG_ACTIVE) ?
		kt->pfrkt_cnt : -1;
d808 1
a808 1
		if (cur->kif != prev->kif || cur->ifnot != prev->ifnot)
d816 11
a826 2
		if (cur->src.not != prev->src.not ||
		    pf_addr_wrap_neq(&cur->src.addr, &prev->src.addr))
d832 11
a842 2
		if (cur->dst.not != prev->dst.not ||
		    pf_addr_wrap_neq(&cur->dst.addr, &prev->dst.addr))
a855 24
int
pf_addr_wrap_neq(struct pf_addr_wrap *aw1, struct pf_addr_wrap *aw2)
{
	if (aw1->type != aw2->type)
		return (1);
	switch (aw1->type) {
	case PF_ADDR_ADDRMASK:
		if (PF_ANEQ(&aw1->v.a.addr, &aw2->v.a.addr, 0))
			return (1);
		if (PF_ANEQ(&aw1->v.a.mask, &aw2->v.a.mask, 0))
			return (1);
		return (0);
	case PF_ADDR_DYNIFTL:
		return (aw1->p.dyn->pfid_kt != aw2->p.dyn->pfid_kt);
	case PF_ADDR_NOROUTE:
		return (0);
	case PF_ADDR_TABLE:
		return (aw1->p.tbl != aw2->p.tbl);
	default:
		printf("invalid address type: %d\n", aw1->type);
		return (1);
	}
}

d1082 1
a1082 1
    u_int8_t flags, u_int16_t win, u_int16_t mss, u_int8_t ttl)
d1086 1
a1086 1
	int		 len, tlen;
a1093 6
	char *opt;

	/* maximum segment size tcp option */
	tlen = sizeof(struct tcphdr);
	if (mss)
		tlen += 4;
d1098 1
a1098 1
		len = sizeof(struct ip) + tlen;
d1103 1
a1103 1
		len = sizeof(struct ip6_hdr) + tlen;
d1144 1
a1144 1
		h->ip_len = htons(tlen);
d1157 1
a1157 1
		h6->ip6_plen = htons(tlen);
d1171 1
a1171 1
	th->th_off = tlen >> 2;
a1174 8
	if (mss) {
		opt = (char *)(th + 1);
		opt[0] = TCPOPT_MAXSEG;
		opt[1] = 4;
		HTONS(mss);
		bcopy((caddr_t)&mss, (caddr_t)(opt + 2), 2);
	}

d1185 2
a1186 2
		h->ip_len = htons(len);
		h->ip_off = htons(ip_mtudisc ? IP_DF : 0);
d1197 1
a1197 1
		    sizeof(struct ip6_hdr), tlen);
a1202 1
		break;
d1243 1
a1243 1
		icmp_error(m0, type, code, 0, (void *)NULL);
d1301 1
a1301 1
pf_match(u_int8_t op, u_int32_t a1, u_int32_t a2, u_int32_t p)
d1363 2
a1364 2
pf_match_tag(struct mbuf *m, struct pf_rule *r, struct pf_rule *nat_rule,
    struct pf_tag *pftag, int *tag)
d1372 4
a1375 2
		if (nat_rule != NULL && nat_rule->tag)
			*tag = nat_rule->tag;
d1459 1
a1459 1
pf_addr_inc(struct pf_addr *addr, sa_family_t af)
d1548 2
a1549 2
pf_map_addr(sa_family_t af, struct pf_rule *r, struct pf_addr *saddr,
    struct pf_addr *naddr, struct pf_addr *init_addr, struct pf_src_node **sn)
d1552 2
a1553 29
	struct pf_pool		*rpool = &r->rpool;
	struct pf_addr		*raddr = &rpool->cur->addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.v.a.mask;
	struct pf_pooladdr      *acur = rpool->cur;
	struct pf_src_node	 k;

	if (*sn == NULL && r->rpool.opts & PF_POOL_STICKYADDR &&
	    (r->rpool.opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		k.af = af;
		PF_ACPY(&k.addr, saddr, af);
		if (r->rule_flag & PFRULE_RULESRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR)
			k.rule.ptr = r;
		else
			k.rule.ptr = NULL;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		*sn = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
		if (*sn != NULL && !PF_AZERO(&(*sn)->raddr, af)) {
			PF_ACPY(naddr, &(*sn)->raddr, af);
			if (pf_status.debug >= PF_DEBUG_MISC) {
				printf("pf_map_addr: src tracking maps ");
				pf_print_host(&k.addr, 0, af);
				printf(" to ");
				pf_print_host(naddr, 0, af);
				printf("\n");
			}
			return (0);
		}
	}
d1555 5
a1559 1
	if (rpool->cur->addr.type == PF_ADDR_NOROUTE)
a1560 23
	if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
		if (af == AF_INET) {
			if (rpool->cur->addr.p.dyn->pfid_acnt4 < 1 &&
			    (rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN)
				return (1);
			 raddr = &rpool->cur->addr.p.dyn->pfid_addr4;
			 rmask = &rpool->cur->addr.p.dyn->pfid_mask4;
		} else {
			if (rpool->cur->addr.p.dyn->pfid_acnt6 < 1 &&
			    (rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN)
				return (1);
			raddr = &rpool->cur->addr.p.dyn->pfid_addr6;
			rmask = &rpool->cur->addr.p.dyn->pfid_mask6;
		}
	} else if (rpool->cur->addr.type == PF_ADDR_TABLE) {
		if ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN)
			return (1); /* unsupported */
	} else {
		raddr = &rpool->cur->addr.v.a.addr;
		rmask = &rpool->cur->addr.v.a.mask;
	}
d1609 4
a1612 36
		if (rpool->cur->addr.type == PF_ADDR_TABLE) {
			if (!pfr_pool_get(rpool->cur->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af))
				goto get_addr;
		} else if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
			if (!pfr_pool_get(rpool->cur->addr.p.dyn->pfid_kt,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af))
				goto get_addr;
		} else if (pf_match_addr(0, raddr, rmask, &rpool->counter, af))
			goto get_addr;

	try_next:
		if ((rpool->cur = TAILQ_NEXT(rpool->cur, entries)) == NULL)
			rpool->cur = TAILQ_FIRST(&rpool->list);
		if (rpool->cur->addr.type == PF_ADDR_TABLE) {
			rpool->tblidx = -1;
			if (pfr_pool_get(rpool->cur->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af)) {
				/* table contain no address of type 'af' */
				if (rpool->cur != acur)
					goto try_next;
				return (1);
			}
		} else if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
			rpool->tblidx = -1;
			if (pfr_pool_get(rpool->cur->addr.p.dyn->pfid_kt,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af)) {
				/* table contain no address of type 'af' */
				if (rpool->cur != acur)
					goto try_next;
				return (1);
			}
d1614 7
a1620 3
			raddr = &rpool->cur->addr.v.a.addr;
			rmask = &rpool->cur->addr.v.a.mask;
			PF_ACPY(&rpool->counter, raddr, af);
a1621 4

	get_addr:
		PF_ACPY(naddr, &rpool->counter, af);
		PF_AINC(&rpool->counter, af);
a1623 2
	if (*sn != NULL)
		PF_ACPY(&(*sn)->raddr, naddr, af);
d1627 1
a1627 1
		printf("pf_map_addr: selected address ");
d1636 1
a1636 1
pf_get_sport(sa_family_t af, u_int8_t proto, struct pf_rule *r,
d1638 1
a1638 2
    struct pf_addr *naddr, u_int16_t *nport, u_int16_t low, u_int16_t high,
    struct pf_src_node **sn)
d1640 1
a1640 1
	struct pf_state		key;
d1645 1
a1645 1
	if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn))
d1651 3
a1653 3
		PF_ACPY(&key.ext.addr, daddr, key.af);
		PF_ACPY(&key.gwy.addr, naddr, key.af);
		key.ext.port = dport;
d1660 6
a1665 2
			key.gwy.port = 0;
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL)
d1668 3
a1670 2
			key.gwy.port = *nport;
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL)
d1672 1
d1674 3
a1676 3
			key.gwy.port = htons(low);
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL) {
				*nport = htons(low);
d1680 2
a1681 1
			u_int16_t tmp;
a1682 1
			if (low > high) {
d1690 3
a1692 5
			for (tmp = cut; tmp <= high; ++(tmp)) {
				key.gwy.port = htons(tmp);
				if (pf_find_state_all(&key, PF_EXT_GWY, NULL) ==
				    NULL) {
					*nport = htons(tmp);
a1693 1
				}
d1695 3
a1697 5
			for (tmp = cut - 1; tmp >= low; --(tmp)) {
				key.gwy.port = htons(tmp);
				if (pf_find_state_all(&key, PF_EXT_GWY, NULL) ==
				    NULL) {
					*nport = htons(tmp);
a1698 1
				}
d1702 1
a1702 1
		switch (r->rpool.opts & PF_POOL_TYPEMASK) {
d1705 1
a1705 1
			if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn))
d1721 3
a1723 3
pf_match_translation(struct pf_pdesc *pd, struct mbuf *m, int off,
    int direction, struct pfi_kif *kif, struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport, int rs_num)
a1730 1
		struct pf_addr_wrap	*xdst = NULL;
d1735 1
a1735 1
				xdst = &r->rpool.cur->addr;
d1742 2
a1743 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d1747 1
a1747 1
		else if (r->af && r->af != pd->af)
d1749 1
a1749 1
		else if (r->proto && r->proto != pd->proto)
d1751 1
a1751 1
		else if (PF_MISMATCHAW(&src->addr, saddr, pd->af, src->not))
d1759 3
a1761 4
		    PF_MISMATCHAW(&dst->addr, daddr, pd->af, dst->not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (xdst != NULL && PF_MISMATCHAW(xdst, daddr, pd->af, 0))
			r = TAILQ_NEXT(r, entries);
d1765 2
a1766 5
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else if (r->os_fingerprint != PF_OSFP_ANY && (pd->proto !=
		    IPPROTO_TCP || !pf_osfp_match(pf_osfp_fingerprint(pd, m,
		    off, pd->hdr.tcp), r->os_fingerprint)))
			r = TAILQ_NEXT(r, entries);
d1784 1
a1784 2
pf_get_translation(struct pf_pdesc *pd, struct mbuf *m, int off, int direction,
    struct pfi_kif *kif, struct pf_src_node **sn,
d1787 1
a1787 1
    struct pf_addr *naddr, u_int16_t *nport)
d1792 2
a1793 2
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
		    sport, daddr, dport, PF_RULESET_BINAT);
d1795 2
a1796 2
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sport, daddr, dport, PF_RULESET_NAT);
d1798 2
a1799 2
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
		    sport, daddr, dport, PF_RULESET_RDR);
d1801 2
a1802 2
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sport, daddr, dport, PF_RULESET_BINAT);
d1813 3
a1815 3
			if (pf_get_sport(pd->af, pd->proto, r, saddr,
			    daddr, dport, naddr, nport, r->rpool.proxy_port[0],
			    r->rpool.proxy_port[1], sn)) {
d1827 5
a1831 23
				if (r->rpool.cur->addr.type == PF_ADDR_DYNIFTL){
					if (pd->af == AF_INET) {
						if (r->rpool.cur->addr.p.dyn->
						    pfid_acnt4 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_addr4,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_mask4,
						    saddr, AF_INET);
					} else {
						if (r->rpool.cur->addr.p.dyn->
						    pfid_acnt6 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_addr6,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_mask6,
						    saddr, AF_INET6);
					}
				} else
d1833 3
a1835 3
					    &r->rpool.cur->addr.v.a.addr,
					    &r->rpool.cur->addr.v.a.mask,
					    saddr, pd->af);
d1838 4
a1841 23
				if (r->rpool.cur->addr.type == PF_ADDR_DYNIFTL){
					if (pd->af == AF_INET) {
						if (r->src.addr.p.dyn->
						    pfid_acnt4 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->src.addr.p.dyn->
						    pfid_addr4,
						    &r->src.addr.p.dyn->
						    pfid_mask4,
						    daddr, AF_INET);
					} else {
						if (r->src.addr.p.dyn->
						    pfid_acnt6 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->src.addr.p.dyn->
						    pfid_addr6,
						    &r->src.addr.p.dyn->
						    pfid_mask6,
						    daddr, AF_INET6);
					}
				} else
d1844 1
a1844 2
					    &r->src.addr.v.a.mask, daddr,
					    pd->af);
d1849 1
a1849 1
			if (pf_map_addr(r->af, r, saddr, naddr, NULL, sn))
d1879 2
a1880 1
pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, struct pf_pdesc *pd)
d1889 1
a1889 1
	switch (pd->proto) {
d1915 1
a1915 1
	switch(pd->af) {
d1919 2
a1920 1
			inp = in_pcblookup_listen(tb, daddr->v4, dport, 0);
d1930 2
a1931 1
			inp = in6_pcblookup_listen(tb, &daddr->v6, dport, 0);
d1982 1
a1982 113
	return (wscale);
}

u_int16_t
pf_get_mss(struct mbuf *m, int off, u_int16_t th_off, sa_family_t af)
{
	int		 hlen;
	u_int8_t	 hdr[60];
	u_int8_t	*opt, optlen;
	u_int16_t	 mss = tcp_mssdflt;

	hlen = th_off << 2;	/* hlen <= sizeof(hdr) */
	if (hlen <= sizeof(struct tcphdr))
		return (0);
	if (!pf_pull_hdr(m, off, hdr, hlen, NULL, NULL, af))
		return (0);
	opt = hdr + sizeof(struct tcphdr);
	hlen -= sizeof(struct tcphdr);
	while (hlen >= TCPOLEN_MAXSEG) {
		switch (*opt) {
		case TCPOPT_EOL:
		case TCPOPT_NOP:
			++opt;
			--hlen;
			break;
		case TCPOPT_MAXSEG:
			bcopy((caddr_t)(opt + 2), (caddr_t)&mss, 2);
			/* fallthrough */
		default:
			optlen = opt[1];
			if (optlen < 2)
				optlen = 2;
			hlen -= optlen;
			opt += optlen;
		}
	}
	return (mss);
}

u_int16_t
pf_calc_mss(struct pf_addr *addr, sa_family_t af, u_int16_t offer)
{
#ifdef INET
	struct sockaddr_in	*dst;
	struct route		 ro;
#endif /* INET */
#ifdef INET6
	struct sockaddr_in6	*dst6;
	struct route_in6	 ro6;
#endif /* INET6 */
	struct rtentry		*rt = NULL;
	int			 hlen;
	u_int16_t		 mss = tcp_mssdflt;

	switch (af) {
#ifdef INET
	case AF_INET:
		hlen = sizeof(struct ip);
		bzero(&ro, sizeof(ro));
		dst = (struct sockaddr_in *)&ro.ro_dst;
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = addr->v4;
		rtalloc_noclone(&ro, NO_CLONING);
		rt = ro.ro_rt;
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		hlen = sizeof(struct ip6_hdr);
		bzero(&ro6, sizeof(ro6));
		dst6 = (struct sockaddr_in6 *)&ro6.ro_dst;
		dst6->sin6_family = AF_INET6;
		dst6->sin6_len = sizeof(*dst6);
		dst6->sin6_addr = addr->v6;
		rtalloc_noclone((struct route *)&ro6, NO_CLONING);
		rt = ro6.ro_rt;
		break;
#endif /* INET6 */
	}

	if (rt && rt->rt_ifp) {
		mss = rt->rt_ifp->if_mtu - hlen - sizeof(struct tcphdr);
		mss = max(tcp_mssdflt, mss);
		RTFREE(rt);
	}
	mss = min(mss, offer);
	mss = max(mss, 64);		/* sanity - at least max opt space */
	return (mss);
}

void
pf_set_rt_ifp(struct pf_state *s, struct pf_addr *saddr)
{
	struct pf_rule *r = s->rule.ptr;

	s->rt_kif = NULL;
	if (!r->rt || r->rt == PF_FASTROUTE)
		return;
	switch (s->af) {
#ifdef INET
	case AF_INET:
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL, &s->nat_src_node);
		s->rt_kif = r->rpool.cur->kif;
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL, &s->nat_src_node);
		s->rt_kif = r->rpool.cur->kif;
		break;
#endif /* INET6 */
	}
d1987 1
a1987 1
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
d1990 1
a1990 1
	struct pf_rule		*nr = NULL;
d1992 1
a2000 1
	struct pf_src_node	*nsn = NULL;
a2004 3
	u_int16_t		 mss = tcp_mssdflt;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2009 1
a2009 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
d2011 2
a2012 2
		    &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
d2014 1
a2014 1
			    &th->th_sum, &pd->naddr, nport, 0, af);
a2015 3
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
d2020 1
a2020 1
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
d2022 2
a2023 2
		    &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
d2025 1
a2025 1
			    &th->th_sum, &pd->naddr, nport, 0, af);
a2026 3
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
d2030 1
d2033 2
a2034 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d2059 2
a2060 1
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d2065 2
a2066 1
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
a2069 2
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
			r = TAILQ_NEXT(r, entries);
d2072 2
a2073 2
		else if (r->os_fingerprint != PF_OSFP_ANY && !pf_osfp_match(
		    pf_osfp_fingerprint(pd, m, off, th), r->os_fingerprint))
d2097 6
d2107 2
a2108 2
			m_copyback(m, off, sizeof(*th), th);
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d2116 8
a2123 10
		if (nr != NULL) {
			if (direction == PF_OUT) {
				pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
				    &th->th_sum, &pd->baddr, bport, 0, af);
				rewrite++;
			} else {
				pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
				    &th->th_sum, &pd->baddr, bport, 0, af);
				rewrite++;
			}
d2136 1
a2136 1
			    ntohl(th->th_ack), ack, TH_RST|TH_ACK, 0, 0,
d2154 1
a2154 1
	if (r->keep_state || nr != NULL ||
a2158 1
		struct pf_src_node *sn = NULL;
d2161 2
a2162 16

		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
a2163 14
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
d2172 4
a2175 1
		s->nat_rule.ptr = nr;
d2189 3
a2191 2
			if (nr != NULL) {
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
d2202 2
a2203 2
			if (nr != NULL) {
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
d2237 1
d2240 1
d2246 3
a2248 10
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
a2251 1
			pf_src_tree_remove_state(s);
a2258 1
			pf_src_tree_remove_state(s);
d2262 1
a2262 1
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
a2264 1
			pf_src_tree_remove_state(s);
d2272 8
a2279 11
			if (nr != NULL) {
				if (direction == PF_OUT) {
					pf_change_ap(saddr, &th->th_sport,
					    pd->ip_sum, &th->th_sum, &pd->baddr,
					    bport, 0, af);
				} else {
					pf_change_ap(daddr, &th->th_dport,
					    pd->ip_sum, &th->th_sum, &pd->baddr,
					    bport, 0, af);
				}
			}
a2280 5
			/* Find mss option */
			mss = pf_get_mss(m, off, th->th_off, af);
			mss = pf_calc_mss(saddr, af, mss);
			mss = pf_calc_mss(daddr, af, mss);
			s->src.mss = mss;
d2283 1
a2283 1
			    ntohl(th->th_seq) + 1, TH_SYN|TH_ACK, 0, s->src.mss, 0);
d2290 1
a2290 1
		m_copyback(m, off, sizeof(*th), th);
d2297 1
a2297 1
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
d2300 1
a2300 1
	struct pf_rule		*nr = NULL;
d2302 1
a2310 1
	struct pf_src_node	*nsn = NULL;
a2315 2
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

d2319 1
a2319 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
d2321 2
a2322 2
		    &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
d2324 1
a2324 1
			    &uh->uh_sum, &pd->naddr, nport, 1, af);
a2325 3
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
d2330 4
a2333 4
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, uh->uh_sport, daddr, uh->uh_dport, &pd->naddr,
		    &nport)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
d2335 1
a2335 1
			    &uh->uh_sum, &pd->naddr, nport, 1, af);
a2336 3
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
d2340 1
d2343 2
a2344 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d2367 2
a2368 1
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d2373 2
a2374 1
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d2378 2
a2379 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
a2382 2
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
d2405 6
d2415 2
a2416 2
			m_copyback(m, off, sizeof(*uh), uh);
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d2423 8
a2430 10
		if (nr != NULL) {
			if (direction == PF_OUT) {
				pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
				    &uh->uh_sum, &pd->baddr, bport, 1, af);
				rewrite++;
			} else {
				pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
				    &uh->uh_sum, &pd->baddr, bport, 1, af);
				rewrite++;
			}
d2448 1
a2448 1
	if (r->keep_state || nr != NULL) {
a2450 1
		struct pf_src_node *sn = NULL;
d2452 3
a2454 31
		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL) {
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			REASON_SET(&reason, PFRES_MEMORY);
a2455 1
		}
d2460 1
d2462 4
a2465 1
		s->nat_rule.ptr = nr;
d2479 2
a2480 2
			if (nr != NULL) {
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
d2491 2
a2492 2
			if (nr != NULL) {
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
d2499 4
d2504 4
d2512 3
a2514 11
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
a2515 1
			pf_src_tree_remove_state(s);
d2524 1
a2524 1
		m_copyback(m, off, sizeof(*uh), uh);
d2531 1
a2531 1
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
d2534 1
a2534 1
	struct pf_rule		*nr = NULL;
d2536 1
a2538 1
	struct pf_src_node	*nsn = NULL;
a2579 2
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

d2582 3
a2584 3
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
d2589 1
a2589 1
				    pd->naddr.v4.s_addr, 0);
d2595 1
a2595 1
				    &pd->naddr, 0);
a2599 3
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
d2603 3
a2605 3
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
d2610 1
a2610 1
				    pd->ip_sum, pd->naddr.v4.s_addr, 0);
d2616 1
a2616 1
				    &pd->naddr, 0);
a2620 3
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
d2624 1
d2627 2
a2628 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d2648 2
a2649 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
a2652 2
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
d2675 6
d2687 1
a2687 1
			    pd->hdr.icmp6);
d2689 1
a2689 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d2700 2
a2701 1
	if (!state_icmp && (r->keep_state || nr != NULL)) {
a2703 1
		struct pf_src_node *sn = NULL;
d2705 3
a2707 31
		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL) {
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			REASON_SET(&reason, PFRES_MEMORY);
a2708 1
		}
d2713 1
d2715 4
a2718 1
		s->nat_rule.ptr = nr;
d2732 2
a2733 2
			if (nr != NULL)
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
d2742 2
a2743 2
			if (nr != NULL)
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
d2748 10
d2761 3
a2763 11
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
a2764 1
			pf_src_tree_remove_state(s);
d2775 1
a2775 1
		    pd->hdr.icmp6);
d2783 1
a2783 1
    struct pfi_kif *kif, struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
d2786 1
a2786 1
	struct pf_rule		*nr = NULL;
a2788 1
	struct pf_src_node	*nsn = NULL;
d2790 1
a2795 2
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

d2798 3
a2800 3
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
d2805 1
a2805 1
				    pd->naddr.v4.s_addr, 0);
d2810 1
a2810 1
				PF_ACPY(saddr, &pd->naddr, af);
a2813 3
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
d2817 3
a2819 3
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
d2824 1
a2824 1
				    pd->ip_sum, pd->naddr.v4.s_addr, 0);
d2829 1
a2829 1
				PF_ACPY(daddr, &pd->naddr, af);
a2832 3
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
d2836 1
d2839 2
a2840 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d2856 2
a2857 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
a2860 2
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
d2883 6
a2889 1

d2891 1
a2891 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d2898 4
a2901 6
		if (nr != NULL) {
			if (direction == PF_OUT)
				a = saddr;
			else
				a = daddr;
		}
d2907 1
a2907 1
				    pd->baddr.v4.s_addr, 0);
d2912 1
a2912 1
				PF_ACPY(a, &pd->baddr, af);
d2933 1
a2933 1
	if (r->keep_state || nr != NULL) {
a2935 1
		struct pf_src_node *sn = NULL;
d2937 3
a2939 31
		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL) {
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			REASON_SET(&reason, PFRES_MEMORY);
a2940 1
		}
d2945 1
d2947 4
a2950 1
		s->nat_rule.ptr = nr;
d2961 1
d2963 3
a2965 2
			if (nr != NULL)
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
d2968 1
d2971 1
d2973 3
a2975 2
			if (nr != NULL)
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
d2978 1
d2980 4
d2985 4
d2993 3
a2995 11
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
d2998 1
a2998 1
				PFLOG_PACKET(kif, h, m, af, direction, reason,
a2999 1
			pf_src_tree_remove_state(s);
d3010 1
a3010 1
pf_test_fragment(struct pf_rule **rm, int direction, struct pfi_kif *kif,
d3024 2
a3025 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d3040 1
a3040 2
		    r->flagset || r->type || r->code ||
		    r->os_fingerprint != PF_OSFP_ANY)
d3042 2
a3043 1
		else if (r->match_tag && !pf_match_tag(m, r, NULL, pftag, &tag))
d3067 6
a3073 1

d3075 1
a3075 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d3089 2
a3090 2
pf_test_state_tcp(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
d3093 1
a3093 1
	struct pf_state		 key;
d3104 4
a3107 11
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = th->th_sport;
		key.gwy.port = th->th_dport;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = th->th_sport;
		key.ext.port = th->th_dport;
	}
d3128 1
a3128 1
			    TH_SYN|TH_ACK, 0, (*state)->src.mss, 0);
d3157 1
a3157 1
			    (*state)->dst.seqhi, 0, TH_SYN, 0, (*state)->src.mss, 0);
d3169 1
a3169 1
			    TH_ACK, (*state)->src.max_win, 0, 0);
d3173 1
a3173 1
			    TH_ACK, (*state)->dst.max_win, 0, 0);
d3311 1
a3311 1
	    (ackskew <= (MAXACKWINDOW << sws))) {
d3314 3
d3396 2
a3397 3
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d:%d\n",
			    seq, ack, pd->p_len, ackskew,
			    (*state)->packets[0], (*state)->packets[1]);
d3400 3
d3440 1
a3440 1
				    TH_RST|TH_ACK, 0, 0,
d3450 1
a3450 1
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d:%d "
d3452 1
a3452 1
			    (*state)->packets[0], (*state)->packets[1],
d3460 1
a3460 1
			    (ackskew <= (MAXACKWINDOW << sws)) ? ' ' : '4',
d3468 2
a3469 2
		if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
		    src, dst, &copyback))
d3475 1
a3475 1
	/* translate source/destination address, if necessary */
d3485 1
a3485 1
		m_copyback(m, off, sizeof(*th), th);
d3488 1
a3488 1
		m_copyback(m, off, sizeof(*th), th);
d3491 10
d3505 2
a3506 2
pf_test_state_udp(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd)
d3509 1
a3509 1
	struct pf_state		 key;
d3514 4
a3517 11
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = uh->uh_sport;
		key.gwy.port = uh->uh_dport;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = uh->uh_sport;
		key.ext.port = uh->uh_dport;
	}
d3529 3
d3555 1
a3555 1
		m_copyback(m, off, sizeof(*uh), uh);
d3558 10
d3572 2
a3573 2
pf_test_state_icmp(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd)
d3616 1
a3616 1
		struct pf_state		key;
d3620 4
a3623 11
		if (direction == PF_IN)	{
			PF_ACPY(&key.ext.addr, pd->src, key.af);
			PF_ACPY(&key.gwy.addr, pd->dst, key.af);
			key.ext.port = icmpid;
			key.gwy.port = icmpid;
		} else {
			PF_ACPY(&key.lan.addr, pd->src, key.af);
			PF_ACPY(&key.ext.addr, pd->dst, key.af);
			key.lan.port = icmpid;
			key.ext.port = icmpid;
		}
d3627 2
d3632 1
a3632 1
		/* translate source/destination address, if necessary */
d3650 1
a3650 1
					    pd->hdr.icmp6);
d3670 1
a3670 1
					    pd->hdr.icmp6);
d3714 1
a3714 1
			if (h2.ip_off & htons(IP_OFFMASK))
d3784 1
a3784 1
			struct pf_state		 key;
d3802 4
a3805 11
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = th.th_dport;
				key.gwy.port = th.th_sport;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = th.th_dport;
				key.ext.port = th.th_sport;
			}
d3831 1
a3831 6
					printf("pf: BAD ICMP %d:%d ",
					    icmptype, pd->hdr.icmp->icmp_code);
					pf_print_host(pd->src, 0, pd->af);
					printf(" -> ");
					pf_print_host(pd->dst, 0, pd->af);
					printf(" state: ");
d3856 1
a3856 1
					    pd->hdr.icmp);
d3858 1
a3858 1
					    &h2);
d3865 1
a3865 1
					    pd->hdr.icmp6);
d3867 1
a3867 1
					    &h2_6);
d3871 1
a3871 1
				m_copyback(m, off2, 8, &th);
d3873 1
a3873 1
				m_copyback(m, off2, 8, &th);
d3881 1
a3881 1
			struct pf_state		key;
d3893 4
a3896 11
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = uh.uh_dport;
				key.gwy.port = uh.uh_sport;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = uh.uh_dport;
				key.ext.port = uh.uh_sport;
			}
d3918 3
a3920 2
					    pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2), &h2);
d3927 1
a3927 1
					    pd->hdr.icmp6);
d3929 1
a3929 1
					    &h2_6);
d3933 2
a3934 1
				m_copyback(m, off2, sizeof(uh), &uh);
d3943 1
a3943 1
			struct pf_state		key;
d3955 4
a3958 11
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = iih.icmp_id;
				key.gwy.port = iih.icmp_id;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = iih.icmp_id;
				key.ext.port = iih.icmp_id;
			}
d3976 6
a3981 3
				m_copyback(m, off, ICMP_MINLEN, pd->hdr.icmp);
				m_copyback(m, ipoff2, sizeof(h2), &h2);
				m_copyback(m, off2, ICMP_MINLEN, &iih);
d3991 1
a3991 1
			struct pf_state		key;
d4003 4
a4006 11
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = iih.icmp6_id;
				key.gwy.port = iih.icmp6_id;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = iih.icmp6_id;
				key.ext.port = iih.icmp6_id;
			}
d4025 3
a4027 2
				    pd->hdr.icmp6);
				m_copyback(m, ipoff2, sizeof(h2_6), &h2_6);
d4029 1
a4029 1
				    &iih);
d4037 1
a4037 1
			struct pf_state		key;
d4041 4
a4044 11
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = 0;
				key.gwy.port = 0;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = 0;
				key.ext.port = 0;
			}
d4066 3
a4068 2
					    pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2), &h2);
d4075 1
a4075 1
					    pd->hdr.icmp6);
d4077 1
a4077 1
					    &h2_6);
d4091 1
a4091 1
pf_test_state_other(struct pf_state **state, int direction, struct pfi_kif *kif,
d4095 1
a4095 1
	struct pf_state		 key;
d4099 4
a4102 11
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = 0;
		key.gwy.port = 0;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = 0;
		key.ext.port = 0;
	}
d4114 3
d4164 10
d4189 1
a4189 1
		u_int16_t	 fragoff = (ntohs(h->ip_off) & IP_OFFMASK) << 3;
d4200 1
a4200 1
		if (m->m_pkthdr.len < off + len || ntohs(h->ip_len) < off + len) {
a4261 1
	struct pf_src_node	*sn = NULL;
d4313 3
a4315 2
			pf_map_addr(AF_INET, r, (struct pf_addr *)&ip->ip_src,
			    &naddr, NULL, &sn);
d4318 1
a4318 2
			ifp = r->rpool.cur->kif ?
			    r->rpool.cur->kif->pfik_ifp : NULL;
d4320 6
d4329 1
a4329 1
			ifp = s->rt_kif ? s->rt_kif->pfik_ifp : NULL;
d4336 16
a4351 18
	mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
	if (mtag == NULL) {
		struct m_tag *mtag;

		mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
		if (mtag == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
	}

	if (oifp != ifp && mtag == NULL) {
		if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip))
			panic("pf_route: m0->m_len < sizeof(struct ip)");
		ip = mtod(m0, struct ip *);
d4355 3
a4357 29
#ifdef IPSEC
	/*
	 * If deferred crypto processing is needed, check that the
	 * interface supports it.
	 */
	if ((mtag = m_tag_find(m0, PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED, NULL))
	    != NULL && (ifp->if_capabilities & IFCAP_IPSEC) == 0) {
		/* Notify IPsec to do its own crypto. */
		ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
		goto bad;
	}
#endif /* IPSEC */

	/* Catch routing changes wrt. hardware checksumming for TCP or UDP. */
	if (m0->m_pkthdr.csum & M_TCPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_TCPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m0);
			m0->m_pkthdr.csum &= ~M_TCPV4_CSUM_OUT; /* Clear */
		}
	} else if (m0->m_pkthdr.csum & M_UDPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_UDPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m0);
			m0->m_pkthdr.csum &= ~M_UDPV4_CSUM_OUT; /* Clear */
		}
	}

	if (ntohs(ip->ip_len) <= ifp->if_mtu) {
d4379 1
a4379 1
	if (ip->ip_off & htons(IP_DF)) {
d4391 1
a4391 1
	if (error)
a4432 1
	struct pf_src_node	*sn = NULL;
d4474 1
a4474 1
		ip6_output(m0, NULL, NULL, 0, NULL, NULL);
d4481 2
a4482 2
		pf_map_addr(AF_INET6, r, (struct pf_addr *)&ip6->ip6_src,
		    &naddr, NULL, &sn);
d4486 1
a4486 1
		ifp = r->rpool.cur->kif ? r->rpool.cur->kif->pfik_ifp : NULL;
d4488 6
d4497 1
a4497 1
		ifp = s->rt_kif ? s->rt_kif->pfik_ifp : NULL;
a4520 2
	if (IN6_IS_ADDR_LINKLOCAL(&dst->sin6_addr))
		dst->sin6_addr.s6_addr16[1] = htons(ifp->if_index);
d4522 2
a4523 1
		error = nd6_output(ifp, ifp, m0, dst, NULL);
a4631 14
static int
pf_add_mbuf_tag(struct mbuf *m, u_int tag)
{
	struct m_tag *mtag;

	if (m_tag_find(m, tag, NULL) != NULL)
		return (0);
	mtag = m_tag_get(tag, 0, M_NOWAIT);
	if (mtag == NULL)
		return (1);
	m_tag_prepend(m, mtag);
	return (0);
}

a4635 1
	struct pfi_kif	  *kif;
d4639 1
a4639 1
	struct pf_rule	  *a = NULL, *r = &pf_default_rule, *tr, *nr;
d4643 2
a4644 1
	int		   off, dirndx, pqid = 0;
a4649 4
	kif = pfi_index2kif[ifp->if_index];
	if (kif == NULL)
		return (PF_DROP);

a4654 1
	memset(&pd, 0, sizeof(pd));
d4663 1
a4663 1
	if (pf_normalize_ip(m0, dir, kif, &reason) != PF_PASS) {
a4679 1
	PF_ACPY(&pd.baddr, dir == PF_OUT ? pd.src : pd.dst, AF_INET);
d4684 1
a4684 1
	pd.tot_len = ntohs(h->ip_len);
d4687 2
a4688 2
	if (h->ip_off & htons(IP_MF | IP_OFFMASK)) {
		action = pf_test_fragment(&r, dir, kif, m, h,
d4705 1
a4705 1
		    ntohs(h->ip_len) - off, IPPROTO_TCP, AF_INET)) {
d4712 1
a4712 1
		action = pf_normalize_tcp(dir, kif, m, 0, off, h, &pd);
d4714 2
a4715 2
			goto done;
		action = pf_test_state_tcp(&s, dir, kif, m, off, h, &pd,
a4717 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
a4718 1
			a = s->anchor.ptr;
d4721 2
a4722 2
			action = pf_test_tcp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset);
d4736 1
a4736 7
		    off, ntohs(h->ip_len) - off, IPPROTO_UDP, AF_INET)) {
			action = PF_DROP;
			goto done;
		}
		if (uh.uh_dport == 0 ||
		    ntohs(uh.uh_ulen) > m->m_pkthdr.len - off ||
		    ntohs(uh.uh_ulen) < sizeof(struct udphdr)) {
d4740 1
a4740 1
		action = pf_test_state_udp(&s, dir, kif, m, off, h, &pd);
a4741 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
d4746 2
a4747 2
			action = pf_test_udp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset);
d4761 1
a4761 1
		    ntohs(h->ip_len) - off, IPPROTO_ICMP, AF_INET)) {
d4765 1
a4765 1
		action = pf_test_state_icmp(&s, dir, kif, m, off, h, &pd);
a4766 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
d4768 2
d4771 4
d4777 2
a4778 2
			action = pf_test_icmp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset);
d4783 1
a4783 1
		action = pf_test_state_other(&s, dir, kif, &pd);
a4784 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
d4789 1
a4789 1
			action = pf_test_other(&r, &s, dir, kif, m, off, h,
d4794 5
d4800 11
a4839 15
	/*
	 * connections redirected to loopback should not match sockets
	 * bound specifically to loopback due to security implications,
	 * see tcp_input() and in_pcblookup_listen().
	 */
	if (dir == PF_IN && action == PF_PASS && (pd.proto == IPPROTO_TCP ||
	    pd.proto == IPPROTO_UDP) && s != NULL && s->nat_rule.ptr != NULL &&
	    (s->nat_rule.ptr->action == PF_RDR ||
	    s->nat_rule.ptr->action == PF_BINAT) &&
	    (ntohl(pd.dst->v4.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET &&
	    pf_add_mbuf_tag(m, PACKET_TAG_PF_TRANSLATE_LOCALHOST)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_MEMORY);
	}

d4841 1
a4841 65
		PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, r, a, ruleset);

	kif->pfik_bytes[0][dir == PF_OUT][action != PF_PASS] += pd.tot_len;
	kif->pfik_packets[0][dir == PF_OUT][action != PF_PASS]++;

	if (action == PF_PASS || r->action == PF_DROP) {
		r->packets++;
		r->bytes += pd.tot_len;
		if (a != NULL) {
			a->packets++;
			a->bytes += pd.tot_len;
		}
		if (s != NULL) {
			dirndx = (dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd.tot_len;
			if (s->nat_rule.ptr != NULL) {
				s->nat_rule.ptr->packets++;
				s->nat_rule.ptr->bytes += pd.tot_len;
			}
			if (s->src_node != NULL) {
				s->src_node->packets++;
				s->src_node->bytes += pd.tot_len;
			}
			if (s->nat_src_node != NULL) {
				s->nat_src_node->packets++;
				s->nat_src_node->bytes += pd.tot_len;
			}
		}
		tr = r;
		nr = (s != NULL) ? s->nat_rule.ptr : pd.nat_rule;
		if (nr != NULL) {
			struct pf_addr *x;
			/*
			 * XXX: we need to make sure that the addresses
			 * passed to pfr_update_stats() are the same than
			 * the addresses used during matching (pfr_match)
			 */
			if (r == &pf_default_rule) {
				tr = nr;
				x = (s == NULL || s->direction == dir) ?
				    &pd.baddr : &pd.naddr;
			} else
				x = (s == NULL || s->direction == dir) ?
				    &pd.naddr : &pd.baddr;
			if (x == &pd.baddr || s == NULL) {
				/* we need to change the address */
				if (dir == PF_OUT)
					pd.src = x;
				else
					pd.dst = x;
			}
		}
		if (tr->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->src.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.src : pd.dst, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->src.not);
		if (tr->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->dst.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.dst : pd.src, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->dst.not);
	}

a4858 1
	struct pfi_kif	  *kif;
d4862 1
a4862 1
	struct pf_rule	  *a = NULL, *r = &pf_default_rule, *tr, *nr;
d4866 1
a4866 1
	int		   off, terminal = 0, dirndx;
a4871 4
	kif = pfi_index2kif[ifp->if_index];
	if (kif == NULL)
		return (PF_DROP);

a4876 1
	memset(&pd, 0, sizeof(pd));
a4883 5
	/* We do IP header normalization and packet reassembly here */
	if (pf_normalize_ip6(m0, dir, kif, &reason) != PF_PASS) {
		action = PF_DROP;
		goto done;
	}
a4888 1
	PF_ACPY(&pd.baddr, dir == PF_OUT ? pd.src : pd.dst, AF_INET6);
d4899 1
a4899 1
			action = pf_test_fragment(&r, dir, kif, m, h,
d4951 1
a4951 1
		action = pf_normalize_tcp(dir, kif, m, 0, off, h, &pd);
d4953 2
a4954 2
			goto done;
		action = pf_test_state_tcp(&s, dir, kif, m, off, h, &pd,
a4956 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
a4957 1
			a = s->anchor.ptr;
d4960 2
a4961 2
			action = pf_test_tcp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset);
d4979 1
a4979 7
		if (uh.uh_dport == 0 ||
		    ntohs(uh.uh_ulen) > m->m_pkthdr.len - off ||
		    ntohs(uh.uh_ulen) < sizeof(struct udphdr)) {
			action = PF_DROP;
			goto done;
		}
		action = pf_test_state_udp(&s, dir, kif, m, off, h, &pd);
a4980 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
a4981 1
			a = s->anchor.ptr;
d4984 2
a4985 2
			action = pf_test_udp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset);
d5003 2
a5004 2
		action = pf_test_state_icmp(&s, dir, kif,
		    m, off, h, &pd);
a5005 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
d5007 2
a5008 1
			a = s->anchor.ptr;
d5011 2
a5012 2
			action = pf_test_icmp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset);
d5017 2
a5018 8
		action = pf_test_state_other(&s, dir, kif, &pd);
		if (action == PF_PASS) {
			r = s->rule.ptr;
			a = s->anchor.ptr;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_other(&r, &s, dir, kif, m, off, h,
			    &pd, &a, &ruleset);
d5022 5
d5028 11
a5060 10
	if (dir == PF_IN && action == PF_PASS && (pd.proto == IPPROTO_TCP ||
	    pd.proto == IPPROTO_UDP) && s != NULL && s->nat_rule.ptr != NULL &&
	    (s->nat_rule.ptr->action == PF_RDR ||
	    s->nat_rule.ptr->action == PF_BINAT) &&
	    IN6_IS_ADDR_LOOPBACK(&pd.dst->v6) &&
	    pf_add_mbuf_tag(m, PACKET_TAG_PF_TRANSLATE_LOCALHOST)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_MEMORY);
	}

d5062 1
a5062 65
		PFLOG_PACKET(kif, h, m, AF_INET6, dir, reason, r, a, ruleset);

	kif->pfik_bytes[1][dir == PF_OUT][action != PF_PASS] += pd.tot_len;
	kif->pfik_packets[1][dir == PF_OUT][action != PF_PASS]++;

	if (action == PF_PASS || r->action == PF_DROP) {
		r->packets++;
		r->bytes += pd.tot_len;
		if (a != NULL) {
			a->packets++;
			a->bytes += pd.tot_len;
		}
		if (s != NULL) {
			dirndx = (dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd.tot_len;
			if (s->nat_rule.ptr != NULL) {
				s->nat_rule.ptr->packets++;
				s->nat_rule.ptr->bytes += pd.tot_len;
			}
			if (s->src_node != NULL) {
				s->src_node->packets++;
				s->src_node->bytes += pd.tot_len;
			}
			if (s->nat_src_node != NULL) {
				s->nat_src_node->packets++;
				s->nat_src_node->bytes += pd.tot_len;
			}
		}
		tr = r;
		nr = (s != NULL) ? s->nat_rule.ptr : pd.nat_rule;
		if (nr != NULL) {
			struct pf_addr *x;
			/*
			 * XXX: we need to make sure that the addresses
			 * passed to pfr_update_stats() are the same than
			 * the addresses used during matching (pfr_match)
			 */
			if (r == &pf_default_rule) {
				tr = nr;
				x = (s == NULL || s->direction == dir) ?
				    &pd.baddr : &pd.naddr;
			} else {
				x = (s == NULL || s->direction == dir) ?
				    &pd.naddr : &pd.baddr;
			}
			if (x == &pd.baddr || s == NULL) {
				if (dir == PF_OUT)
					pd.src = x;
				else
					pd.dst = x;
			}
		}
		if (tr->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->src.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.src : pd.dst, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->src.not);
		if (tr->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->dst.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.dst : pd.src, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->dst.not);
	}

@


1.95.2.11
log
@Merge with the trunk
@
text
@a70 1
#include <netinet/if_ether.h>
a74 2

#if NPFSYNC > 0
a75 1
#endif /* NPFSYNC > 0 */
d84 4
d95 1
a95 1
struct pf_anchor_global	 pf_anchors;
a109 7
struct pf_anchor_stackframe {
	struct pf_ruleset			*rs;
	struct pf_rule				*r;
	struct pf_anchor_node			*parent;
	struct pf_anchor			*child;
} pf_anchor_stack[64];

d114 2
d117 2
d133 1
a133 2
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t, int,
			    struct ether_header *, struct ifnet *);
d148 1
a148 1
			    struct pf_ruleset **, struct ifqueue *);
d152 1
a152 1
			    struct pf_ruleset **, struct ifqueue *);
d156 1
a156 1
			    struct pf_ruleset **, struct ifqueue *);
d160 1
a160 1
			    struct pf_ruleset **, struct ifqueue *);
d178 1
a178 1
			     struct pf_rule *, struct pf_tag **, int *);
a208 1
int			 pf_check_congestion(struct ifqueue *);
d210 2
a211 5
struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] = {
	{ &pf_state_pl, PFSTATE_HIWAT },
	{ &pf_src_tree_pl, PFSNODE_HIWAT },
	{ &pf_frent_pl, PFFRAG_FRENT_HIWAT }
};
a251 1
static __inline int pf_anchor_compare(struct pf_anchor *, struct pf_anchor *);
a255 1
struct pf_state_queue state_updates;
a263 2
RB_GENERATE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare);
RB_GENERATE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare);
a459 8
static __inline int
pf_anchor_compare(struct pf_anchor *a, struct pf_anchor *b)
{
	int c = strcmp(a->path, b->path);

	return (c ? (c < 0 ? -1 : 1) : 0);
}

d478 1
a478 1
#endif /* INET6 */
d484 1
a484 1
	return (RB_FIND(pf_state_tree_id, &tree_id, key));
d524 1
a524 1
	switch (tree) {
d558 1
a558 1
	struct pf_src_node	k;
d599 2
a600 2
		pf_status.scounters[SCNT_SRC_NODE_INSERT]++;
		pf_status.src_nodes++;
d630 1
d651 1
a671 1
	TAILQ_INSERT_HEAD(&state_updates, state, u.s.entry_updates);
d765 1
a765 2
				timeout =
				    pf_default_rule.timeout[PFTM_SRC_NODE];
d773 1
a773 2
				timeout =
				    pf_default_rule.timeout[PFTM_SRC_NODE];
a776 37
	s->src_node = s->nat_src_node = NULL;
}

void
pf_purge_expired_state(struct pf_state *cur)
{
	if (cur->src.state == PF_TCPS_PROXY_DST)
		pf_send_tcp(cur->rule.ptr, cur->af,
		    &cur->ext.addr, &cur->lan.addr,
		    cur->ext.port, cur->lan.port,
		    cur->src.seqhi, cur->src.seqlo + 1,
		    TH_RST|TH_ACK, 0, 0, 0, 1, NULL, NULL);
	RB_REMOVE(pf_state_tree_ext_gwy,
	    &cur->u.s.kif->pfik_ext_gwy, cur);
	RB_REMOVE(pf_state_tree_lan_ext,
	    &cur->u.s.kif->pfik_lan_ext, cur);
	RB_REMOVE(pf_state_tree_id, &tree_id, cur);
#if NPFSYNC
	pfsync_delete_state(cur);
#endif
	pf_src_tree_remove_state(cur);
	if (--cur->rule.ptr->states <= 0 &&
	    cur->rule.ptr->src_nodes <= 0)
		pf_rm_rule(NULL, cur->rule.ptr);
	if (cur->nat_rule.ptr != NULL)
		if (--cur->nat_rule.ptr->states <= 0 &&
			cur->nat_rule.ptr->src_nodes <= 0)
			pf_rm_rule(NULL, cur->nat_rule.ptr);
	if (cur->anchor.ptr != NULL)
		if (--cur->anchor.ptr->states <= 0)
			pf_rm_rule(NULL, cur->anchor.ptr);
	pf_normalize_tcp_cleanup(cur);
	pfi_detach_state(cur->u.s.kif);
	TAILQ_REMOVE(&state_updates, cur, u.s.entry_updates);
	pool_put(&pf_state_pl, cur);
	pf_status.fcounters[FCNT_STATE_REMOVALS]++;
	pf_status.states--;
d787 33
a819 2
		if (pf_state_expires(cur) <= time.tv_sec)
			pf_purge_expired_state(cur);
d1055 42
d1281 1
a1281 2
    u_int8_t flags, u_int16_t win, u_int16_t mss, u_int8_t ttl, int tag,
    struct ether_header *eh, struct ifnet *ifp)
d1284 1
d1314 3
d1318 2
a1319 1
	if (m == NULL)
a1320 9
	if (tag) {
		struct m_tag	*mtag;

		mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
		if (mtag == NULL) {
			m_freem(m);
			return;
		}
		m_tag_prepend(m, mtag);
d1322 1
a1324 1
		struct m_tag	*mtag;
d1337 1
a1337 1
#endif /* ALTQ */
d1402 2
a1403 22
		if (eh == NULL) {
			ip_output(m, (void *)NULL, (void *)NULL, 0,
			    (void *)NULL, (void *)NULL);
		} else {
			struct route		 ro;
			struct rtentry		 rt;
			struct ether_header	*e = (void *)ro.ro_dst.sa_data;

			if (ifp == NULL) {
				m_freem(m);
				return;
			}
			rt.rt_ifp = ifp;
			ro.ro_rt = &rt;
			ro.ro_dst.sa_len = sizeof(ro.ro_dst);
			ro.ro_dst.sa_family = pseudo_AF_HDRCMPLT;
			bcopy(eh->ether_dhost, e->ether_shost, ETHER_ADDR_LEN);
			bcopy(eh->ether_shost, e->ether_dhost, ETHER_ADDR_LEN);
			e->ether_type = eh->ether_type;
			ip_output(m, (void *)NULL, &ro, IP_ROUTETOETHER,
			    (void *)NULL, (void *)NULL);
		}
d1452 1
a1452 1
#endif /* ALTQ */
d1578 1
a1578 1
    struct pf_tag **pftag, int *tag)
d1581 3
a1583 3
		*pftag = pf_get_tag(m);
		if (*pftag != NULL)
			*tag = (*pftag)->tag;
d1614 16
a1629 31
static void
pf_step_into_anchor(int *depth, struct pf_ruleset **rs, int n,
    struct pf_rule **r, struct pf_rule **a)
{
	struct pf_anchor_stackframe	*f;

	if (*depth >= sizeof(pf_anchor_stack) /
	    sizeof(pf_anchor_stack[0])) {
		printf("pf_step_into_anchor: stack overflow\n");
		*r = TAILQ_NEXT(*r, entries);
		return;
	} else if (*depth == 0 && a != NULL)
		*a = *r;
	f = pf_anchor_stack + (*depth)++;
	f->rs = *rs;
	f->r = *r;
	if ((*r)->anchor_wildcard) {
		f->parent = &(*r)->anchor->children;
		if ((f->child = RB_MIN(pf_anchor_node, f->parent)) ==
		    NULL) {
			*r = NULL;
			return;
		}
		*rs = &f->child->ruleset;
	} else {
		f->parent = NULL;
		f->child = NULL;
		*rs = &(*r)->anchor->ruleset;
	}
	*r = TAILQ_FIRST((*rs)->rules[n].active.ptr);
}
d1631 13
a1643 26
static void
pf_step_out_of_anchor(int *depth, struct pf_ruleset **rs, int n,
    struct pf_rule **r, struct pf_rule **a)
{
	struct pf_anchor_stackframe	*f;

	do {
		if (*depth <= 0)
			break;
		f = pf_anchor_stack + *depth - 1;
		if (f->parent != NULL && f->child != NULL) {
			f->child = RB_NEXT(pf_anchor_node, f->parent, f->child);
			if (f->child != NULL) {
				*rs = &f->child->ruleset;
				*r = TAILQ_FIRST((*rs)->rules[n].active.ptr);
				if (*r == NULL)
					continue;
				else
					break;
			}
		}
		(*depth)--;
		*rs = f->rs;
		*r = TAILQ_NEXT(f->r, entries);
	} while (*r == NULL);
}
d1767 1
a1767 1
	struct pf_pooladdr	*acur = rpool->cur;
d1797 1
a1797 3
		switch (af) {
#ifdef INET
		case AF_INET:
d1804 1
a1804 4
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
a1810 2
			break;
#endif /* INET6 */
d1832 1
a1832 1
				rpool->counter.addr32[0] = htonl(arc4random());
d1838 1
a1838 2
					rpool->counter.addr32[3] =
					    htonl(arc4random());
d1842 1
a1842 2
					rpool->counter.addr32[2] =
					    htonl(arc4random());
d1846 1
a1846 2
					rpool->counter.addr32[1] =
					    htonl(arc4random());
d1850 1
a1850 2
					rpool->counter.addr32[0] =
					    htonl(arc4random());
d1888 1
a1888 1
				/* table contains no address of type 'af' */
d1898 1
a1898 1
				/* table contains no address of type 'af' */
d1975 1
a1975 1
			cut = htonl(arc4random()) % (1 + high - low) + low;
d2006 1
d2018 1
a2018 1
	struct pf_rule		*r, *rm = NULL;
a2019 1
	int			 asd = 0;
d2065 2
d2070 4
a2073 3
			pf_step_into_anchor(&asd, &ruleset, rs_num, &r, NULL);
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset, rs_num, &r, NULL);
d2110 1
d2127 1
a2127 3
					switch (pd->af) {
#ifdef INET
					case AF_INET:
d2137 1
a2137 4
						break;
#endif /* INET */
#ifdef INET6
					case AF_INET6:
a2146 2
						break;
#endif /* INET6 */
d2156 1
a2156 3
					switch (pd->af) {
#ifdef INET
					case AF_INET:
d2166 1
a2166 4
						break;
#endif /* INET */
#ifdef INET6
					case AF_INET6:
a2175 2
						break;
#endif /* INET6 */
d2208 1
d2251 1
a2251 2
	switch (pd->af) {
#ifdef INET
a2259 1
#endif /* INET */
d2307 1
a2307 1
			/* FALLTHROUGH */
a2313 1
			break;
d2343 1
a2343 1
			/* FALLTHROUGH */
a2349 1
			break;
d2418 1
a2418 2
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL,
		    &s->nat_src_node);
d2424 1
a2424 2
		pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL,
		    &s->nat_src_node);
d2434 1
a2434 2
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
a2451 4
	int			 asd = 0;

	if (pf_check_congestion(ifq))
		return (PF_DROP);
d2522 1
a2522 1
		else if (r->prob && r->prob <= arc4random())
d2524 1
a2524 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d2540 2
a2541 2
				pf_step_into_anchor(&asd, &ruleset,
				    PF_RULESET_FILTER, &r, &a);
d2543 3
a2545 3
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset,
			    PF_RULESET_FILTER, &r, &a);
d2587 1
a2587 1
			    r->return_ttl, 1, pd->eh, kif->pfik_ifp);
d2691 1
a2691 1
			while ((s->src.seqdiff = htonl(arc4random())) == 0)
d2737 2
a2738 5
		    pf_normalize_tcp_stateful(m, off, pd, &reason, th, s,
		    &s->src, &s->dst, &rewrite)) {
			/* This really shouldn't happen!!! */
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf_normalize_tcp_stateful failed on first pkt"));
d2766 1
a2766 1
			s->src.seqhi = htonl(arc4random());
d2773 2
a2774 2
			    th->th_sport, s->src.seqhi, ntohl(th->th_seq) + 1,
			    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, NULL, NULL);
d2789 1
a2789 2
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
a2805 4
	int			 asd = 0;

	if (pf_check_congestion(ifq))
		return (PF_DROP);
d2874 1
a2874 1
		else if (r->prob && r->prob <= arc4random())
d2876 1
a2876 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d2891 2
a2892 2
				pf_step_into_anchor(&asd, &ruleset,
				    PF_RULESET_FILTER, &r, &a);
d2894 3
a2896 3
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset,
			    PF_RULESET_FILTER, &r, &a);
d3052 1
a3052 2
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
a3068 4
	int			 asd = 0;

	if (pf_check_congestion(ifq))
		return (PF_DROP);
d3175 1
a3175 1
		else if (r->prob && r->prob <= arc4random())
d3177 1
a3177 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d3192 2
a3193 2
				pf_step_into_anchor(&asd, &ruleset,
				    PF_RULESET_FILTER, &r, &a);
d3195 3
a3197 3
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset,
			    PF_RULESET_FILTER, &r, &a);
d3330 1
a3330 1
    struct pf_rule **am, struct pf_ruleset **rsm, struct ifqueue *ifq)
a3340 4
	int			 asd = 0;

	if (pf_check_congestion(ifq))
		return (PF_DROP);
d3409 1
a3409 1
		else if (r->prob && r->prob <= arc4random())
d3411 1
a3411 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d3426 2
a3427 2
				pf_step_into_anchor(&asd, &ruleset,
				    PF_RULESET_FILTER, &r, &a);
d3429 3
a3431 3
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset,
			    PF_RULESET_FILTER, &r, &a);
d3568 3
a3591 1
	int			 asd = 0;
d3615 1
a3615 1
		else if (r->prob && r->prob <= arc4random())
d3617 1
a3617 1
		else if (r->match_tag && !pf_match_tag(m, r, NULL, &pftag, &tag))
d3628 2
a3629 2
				pf_step_into_anchor(&asd, &ruleset,
				    PF_RULESET_FILTER, &r, &a);
d3631 3
a3633 3
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset,
			    PF_RULESET_FILTER, &r, &a);
d3663 1
a3663 1
	u_int32_t		 ack, end, seq, orig_seq;
d3702 1
a3702 2
			    TH_SYN|TH_ACK, 0, (*state)->src.mss, 0, 1,
			    NULL, NULL);
d3728 1
a3728 1
				(*state)->dst.seqhi = htonl(arc4random());
d3731 1
a3731 2
			    (*state)->dst.seqhi, 0, TH_SYN, 0,
			    (*state)->src.mss, 0, 0, NULL, NULL);
d3743 1
a3743 2
			    TH_ACK, (*state)->src.max_win, 0, 0, 1,
			    NULL, NULL);
d3747 1
a3747 2
			    TH_ACK, (*state)->dst.max_win, 0, 0, 0,
			    NULL, NULL);
d3775 1
a3775 1
	orig_seq = seq = ntohl(th->th_seq);
d3789 1
a3789 1
			while ((src->seqdiff = htonl(arc4random())) == 0)
d3885 1
a3885 1
	    (ackskew <= (MAXACKWINDOW << sws)) &&
a3886 9
	    ((th->th_flags & TH_RST) == 0 || orig_seq == src->seqlo ||
	    (pd->flags & PFDESC_IP_REAS) == 0)) {
	    /* Require an exact sequence match on resets when possible */

		if (dst->scrub || src->scrub) {
			if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
			    *state, src, dst, &copyback))
				return (PF_DROP);
		}
a3971 6
		if (dst->scrub || src->scrub) {
			if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
			    *state, src, dst, &copyback))
				return (PF_DROP);
		}

d4010 1
a4010 2
				    (*state)->rule.ptr->return_ttl, 1,
				    pd->eh, kif->pfik_ifp);
d4036 5
a4344 1
			int			 copyback = 0;
d4382 1
a4382 2
			if (src->wscale && dst->wscale &&
			    !(th.th_flags & TH_SYN))
d4389 2
a4390 2
			if (src->seqdiff) {
				pf_change_a(&th.th_seq, icmpsum,
a4391 2
				copyback = 1;
			}
d4411 1
a4411 1
					    daddr, &(*state)->lan.addr,
a4421 4
				copyback = 1;
			}

			if (copyback) {
d4442 2
d4785 1
a4785 2
		if (m->m_pkthdr.len < off + len ||
		    ntohs(h->ip_len) < off + len) {
a4839 1
	struct m_tag		*mtag;
d4845 1
d4854 8
a4861 6
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
d4863 2
a4864 13
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
a4865 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
d4912 1
d4916 11
a4926 1
	if (oifp != ifp) {
d4999 1
a4999 2
	if (error) {
		m0 = NULL;
a5000 1
	}
d5048 8
a5055 14
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
d5057 2
a5058 5
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
a5059 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
d5102 1
d5107 11
a5117 7
		if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip6_hdr))
			panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
		ip6 = mtod(m0, struct ip6_hdr *);
d5155 1
a5155 2
pf_check_proto_cksum(struct mbuf *m, int off, int len, u_int8_t p,
    sa_family_t af)
a5186 1
#ifdef INET
a5201 1
#endif /* INET */
d5254 9
a5262 16
	return pf_test_eh(dir, ifp, m0, NULL);
}

int
pf_test_eh(int dir, struct ifnet *ifp, struct mbuf **m0,
    struct ether_header *eh)
{
	struct pfi_kif		*kif;
	u_short			 action, reason = 0, log = 0;
	struct mbuf		*m = *m0;
	struct ip		*h;
	struct pf_rule		*a = NULL, *r = &pf_default_rule, *tr, *nr;
	struct pf_state		*s = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_pdesc		 pd;
	int			 off, dirndx, pqid = 0;
d5275 1
a5275 1
#endif /* DIAGNOSTIC */
d5286 1
a5286 1
	if (pf_normalize_ip(m0, dir, kif, &reason, &pd) != PF_PASS) {
a5308 1
	pd.eh = eh;
d5344 1
a5344 1
#endif /* NPFSYNC */
d5350 1
a5350 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
d5378 1
a5378 1
#endif /* NPFSYNC */
d5384 1
a5384 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
d5406 1
a5406 1
#endif /* NPFSYNC */
d5412 1
a5412 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
d5421 1
a5421 1
#endif /* NPFSYNC */
d5427 1
a5427 1
			    &pd, &a, &ruleset, &ipintrq);
d5459 1
a5459 1
#endif /* ALTQ */
d5559 9
a5567 16
	return pf_test6_eh(dir, ifp, m0, NULL);
}

int
pf_test6_eh(int dir, struct ifnet *ifp, struct mbuf **m0,
    struct ether_header *eh)
{
	struct pfi_kif		*kif;
	u_short			 action, reason = 0, log = 0;
	struct mbuf		*m = *m0;
	struct ip6_hdr		*h;
	struct pf_rule		*a = NULL, *r = &pf_default_rule, *tr, *nr;
	struct pf_state		*s = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_pdesc		 pd;
	int			 off, terminal = 0, dirndx;
d5580 1
a5580 1
#endif /* DIAGNOSTIC */
d5591 1
a5591 1
	if (pf_normalize_ip6(m0, dir, kif, &reason, &pd) != PF_PASS) {
a5604 1
	pd.eh = eh;
d5671 1
a5671 1
#endif /* NPFSYNC */
d5677 1
a5677 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
d5705 1
a5705 1
#endif /* NPFSYNC */
d5711 1
a5711 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
d5734 1
a5734 1
#endif /* NPFSYNC */
d5740 1
a5740 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
a5746 3
#if NPFSYNC
			pfsync_update_state(s);
#endif /* NPFSYNC */
d5752 1
a5752 1
			    &pd, &a, &ruleset, &ip6intrq);
d5777 1
a5777 1
#endif /* ALTQ */
a5866 9

int
pf_check_congestion(struct ifqueue *ifq)
{
	if (ifq->ifq_congestion)
		return (1);
	else
		return (0);
}
@


1.95.2.12
log
@sync to head
@
text
@d202 2
a203 2
u_int16_t		 pf_calc_mss(struct pf_addr *, struct pf_addr *,
			    sa_family_t, u_int16_t);
d2418 1
a2418 2
pf_calc_mss(struct pf_addr *saddr, struct pf_addr *daddr, sa_family_t af,
    u_int16_t offer)
d2421 1
a2421 1
	struct sockaddr_rtin	*dst;
d2437 4
a2440 5
		dst = satortin(&ro.ro_dst);
		dst->rtin_family = AF_INET;
		dst->rtin_len = sizeof(*dst);
		dst->rtin_dst = daddr->v4;
		dst->rtin_src = saddr->v4;
d2452 1
a2452 1
		dst6->sin6_addr = daddr->v6;
d2841 2
a2842 2
			mss = pf_calc_mss(saddr, daddr, af, mss);
			mss = pf_calc_mss(daddr, saddr, af, mss);
a5001 1
		satortin(&ro->ro_dst)->rtin_src = ip->ip_src;
a5002 1
		satortin(&ro->ro_dst)->rtin_src.s_addr = 0;
@


1.95.2.13
log
@sync to HEAD
@
text
@d1036 1
a1036 1
		if (cur->src.neg != prev->src.neg ||
d1043 1
a1043 1
		if (cur->dst.neg != prev->dst.neg ||
d2094 1
a2094 1
		else if (PF_MISMATCHAW(&src->addr, saddr, pd->af, src->neg))
d2102 1
a2102 1
		    PF_MISMATCHAW(&dst->addr, daddr, pd->af, dst->neg))
d2567 1
a2567 1
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.neg))
d2572 1
a2572 1
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.neg))
d2929 1
a2929 1
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.neg))
d2934 1
a2934 1
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.neg))
d3247 1
a3247 1
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.neg))
d3249 1
a3249 1
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.neg))
d3489 1
a3489 1
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.neg))
d3491 1
a3491 1
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.neg))
d3691 1
a3691 1
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.neg))
d3693 1
a3693 1
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.neg))
d5665 1
a5665 1
			    tr->src.neg);
d5670 1
a5670 1
			    tr->dst.neg);
d5989 1
a5989 1
			    tr->src.neg);
d5994 1
a5994 1
			    tr->dst.neg);
@


1.94
log
@fix memory leak
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.93 2001/07/01 23:31:31 dugsong Exp $ */
d1283 2
a1284 1
	if (m0 == NULL)
d1286 1
@


1.93
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.92 2001/07/01 23:04:44 dhartmei Exp $ */
d1224 2
a1225 1
	if (m == NULL)
d1227 1
@


1.92
log
@tag packets generated by pf (return-rst, return-icmp) so they are not filtered, use existing icmp_error() and ip_output(). ok dugsong@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.91 2001/07/01 17:16:03 kjell Exp $ */
d55 1
a1595 3
			struct mbuf *m0;
			struct m_tag *mtag;

@


1.91
log
@Add port ranges to the rdr directive. Connections can be redirected
to either a range of the same size, or a single port. Redirects
between ranges of different sizes are not supported. Eg:

rdr dc0 10.0.0.0/24 port 60000:61000 -> 127.0.0.1 port 65530:* proto udp
rdr xl0 0.0.0.0/0 port 6660:6669 -> 127.0.0.1 port 6667 proto tcp

This replaces the wildcard port patch (when port = 0), as it should no
longer be necessary. ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.90 2001/07/01 11:22:45 dhartmei Exp $ */
d180 2
a181 2
void			 pf_send_reset(int, struct ifnet *, struct ip *, int,
			    struct tcphdr *);
d1206 1
a1206 2
pf_send_reset(int direction, struct ifnet *ifp, struct ip *h, int off,
    struct tcphdr *th)
d1209 1
d1219 3
d1225 1
d1267 8
a1274 20
	if (direction == PF_IN) {
		/* set up route and send RST out through the same interface */
		struct route iproute;
		struct route *ro = &iproute;
		struct sockaddr_in *dst;
		int error;

		bzero(ro, sizeof(*ro));
		dst = (struct sockaddr_in *)&ro->ro_dst;
		dst->sin_family = AF_INET;
		dst->sin_addr = h2->ip_dst;
		dst->sin_len = sizeof(*dst);
		rtalloc(ro);
		if (ro->ro_rt != NULL)
			ro->ro_rt->rt_use++;
        	error = (*ifp->if_output)(ifp, m, (struct sockaddr *)dst,
		    ro->ro_rt);
	} else {
		/* send RST through the loopback interface */
		struct sockaddr_in dst;
d1276 8
a1283 6
		dst.sin_family = AF_INET;
		dst.sin_addr = h2->ip_dst;
		dst.sin_len = sizeof(struct sockaddr_in);
		m->m_pkthdr.rcvif = ifp;
		looutput(lo0ifp, m, sintosa(&dst), NULL);
	}
d1439 2
a1440 1
		if (rm->action == PF_DROP_RST) {
d1452 5
a1456 3

			pf_send_reset(direction, ifp, h, off, th);
			return (PF_DROP);
d1594 20
a1613 1
		if (rm->action != PF_PASS)
d2100 1
a2100 1
			u_int32_t seq, end;
a2116 3
			end = seq + h2.ip_len - ((h2.ip_hl + th.th_off)<<2) +
				((th.th_flags & TH_SYN) ? 1 : 0) +
				((th.th_flags & TH_FIN) ? 1 : 0);
d2132 1
a2132 1
			if (!SEQ_GEQ(src->seqhi, end) ||
d2680 2
a2681 1
	if (!pf_status.running)
@


1.90
log
@for ICMP error messages refering to TCP packets, only use the first 8 bytes of the TCP header. drop ackskew test and th_sum update.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.89 2001/06/29 16:48:02 niklas Exp $ */
d186 1
d1347 2
a1348 1
		    ((r->dport == 0) || (r->dport == port)))
d1370 12
d1389 1
a1389 1
	u_int16_t bport;
d1411 5
d1417 2
a1418 2
			    &h->ip_sum, &th->th_sum, rdr->raddr, 
			    rdr->rport ? rdr->rport : th->th_dport);
d1541 1
a1541 1
	u_int16_t bport;
d1563 5
d1570 2
a1571 1
			    rdr->rport ? rdr->rport : uh->uh_dport);
@


1.89
log
@Prepend pf_ to limit potential namespace problems, shorten some lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.88 2001/06/29 12:57:02 provos Exp $ */
d1183 1
a1183 1
	u_int32_t oia = *ia, ooa = *oa, opc = *pc, oh2c = *h2c;
d1185 1
d1188 1
a1188 1
	*pc = pf_cksum_fixup(*pc, oip, *ip);
d1190 1
a1190 1
	*ic = pf_cksum_fixup(*ic, opc, *pc);
d2049 1
a2049 1
			printf("pf: ICMP error message too short\n");
a2062 1
			int ackskew;
d2064 6
a2069 1
			if (!pf_pull_hdr(ifp, m, ipoff2, off2, &th, sizeof(th),
d2072 1
a2072 1
				    "ICMP error message too short\n");
a2093 4
			if ((th.th_flags & TH_ACK) == 0 && th.th_ack == 0)
				ackskew = 0;
			else
				ackskew = dst->seqlo - ntohl(th.th_ack);
d2095 1
a2095 3
			    !SEQ_GEQ(seq, src->seqlo - dst->max_win) ||
			    !(ackskew >= -MAXACKWINDOW) ||
			    !(ackskew <= MAXACKWINDOW)) {
a2098 1
				pf_print_flags(th.th_flags);
d2109 1
a2109 1
					    &th.th_sum, &h2.ip_sum,
d2115 1
a2115 1
					    &th.th_sum, &h2.ip_sum,
d2129 1
a2129 1
				m_copyback(m, off2, sizeof(th),
d2143 1
a2143 1
				printf("pf: ICMP error message too short\n");
@


1.88
log
@list instead of tailq for frents, use pool hardlimits, correctly free
after complete reassembly
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.87 2001/06/28 22:49:49 provos Exp $ */
d146 1
a146 1
int			 tree_key_compare(struct pf_tree_key *,
d148 10
a157 5
void			 tree_rotate_left(struct pf_tree_node **);
void			 tree_rotate_right(struct pf_tree_node **);
int			 tree_insert(struct pf_tree_node **, struct pf_tree_node *,
			    struct pf_tree_key *, struct pf_state *);
int		 	 tree_remove(struct pf_tree_node **, struct pf_tree_node *,
d159 8
a166 10
struct pf_tree_node	*tree_first(struct pf_tree_node *);
struct pf_tree_node	*tree_next(struct pf_tree_node *);
struct pf_tree_node	*tree_search(struct pf_tree_node *, struct pf_tree_key *);
struct pf_state		*find_state(struct pf_tree_node *, struct pf_tree_key *);
void			 insert_state(struct pf_state *);
void			 purge_expired_states(void);

void			 print_host(u_int32_t, u_int16_t);
void			 print_state(int, struct pf_state *);
void			 print_flags(u_int8_t);
d173 2
a174 2
u_int16_t		 cksum_fixup(u_int16_t, u_int16_t, u_int16_t);
void			 change_ap(u_int32_t *, u_int16_t *, u_int16_t *,
d176 2
a177 2
void			 change_a(u_int32_t *, u_int16_t *, u_int32_t);
void			 change_icmp(u_int32_t *, u_int16_t *, u_int32_t *,
d180 1
a180 1
void			 send_reset(int, struct ifnet *, struct ip *, int,
d182 7
a188 4
int			 match_addr(u_int8_t, u_int32_t, u_int32_t, u_int32_t);
int			 match_port(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
struct pf_nat		*get_nat(struct ifnet *, u_int8_t, u_int32_t);
struct pf_rdr		*get_rdr(struct ifnet *, u_int8_t, u_int32_t, u_int16_t);
d203 2
a204 2
void			*pull_hdr(struct ifnet *, struct mbuf *, int, int, void *,
			    int, struct ip *, u_short *, u_short *);
d211 1
a211 1
void			 purge_expired_fragments(void);
d238 1
a238 1
		  (!r->src.mask || match_addr(r->src.not, r->src.addr, \
d240 1
a240 1
		  (!r->dst.mask || match_addr(r->dst.not, r->dst.addr, \
d248 1
a248 1
tree_key_compare(struct pf_tree_key *a, struct pf_tree_key *b)
d278 1
a278 1
tree_rotate_left(struct pf_tree_node **n)
d298 1
a298 1
tree_rotate_right(struct pf_tree_node **n)
d318 1
a318 1
tree_insert(struct pf_tree_node **n, struct pf_tree_node *p,
d334 2
a335 2
	} else if (tree_key_compare(key, &(*n)->key) > 0) {
		if (tree_insert(&(*n)->right, *n, key, state)) {
d341 2
a342 2
					tree_rotate_right(&(*n)->right);
				tree_rotate_left(n);
d346 1
a346 1
		if (tree_insert(&(*n)->left, *n, key, state)) {
d352 2
a353 2
					tree_rotate_left(&(*n)->left);
				tree_rotate_right(n);
d361 1
a361 1
tree_remove(struct pf_tree_node **n, struct pf_tree_node *p,
d369 1
a369 1
	c = tree_key_compare(key, &(*n)->key);
d371 1
a371 1
		if (tree_remove(&(*n)->left, *n, key)) {
d377 2
a378 2
					tree_rotate_right(&(*n)->right);
				tree_rotate_left(n);
d384 1
a384 1
		if (tree_remove(&(*n)->right, *n, key)) {
d390 2
a391 2
					tree_rotate_left(&(*n)->left);
				tree_rotate_right(n);
d418 2
a419 1
			bcopy(&(*qq)->key, &(*n)->key, sizeof(struct pf_tree_key));
d422 1
a422 1
			if (tree_remove(&(*n)->left, *n, key)) {
d428 3
a430 2
						tree_rotate_right(&(*n)->right);
					tree_rotate_left(n);
d482 1
a482 1
tree_first(struct pf_tree_node *n)
d495 1
a495 1
tree_next(struct pf_tree_node *n)
d516 1
a516 1
tree_search(struct pf_tree_node *n, struct pf_tree_key *key)
d520 1
a520 1
	while (n && (c = tree_key_compare(&n->key, key)))
d527 1
a527 1
find_state(struct pf_tree_node *n, struct pf_tree_key *key)
d529 1
a529 1
	n = tree_search(n, key);
d534 1
a534 1
insert_state(struct pf_state *state)
d544 1
a544 1
	if (find_state(tree_lan_ext, &key) != NULL)
d547 2
a548 2
		tree_insert(&tree_lan_ext, NULL, &key, state);
		if (find_state(tree_lan_ext, &key) != state)
d557 1
a557 1
	if (find_state(tree_ext_gwy, &key) != NULL)
d560 2
a561 2
		tree_insert(&tree_ext_gwy, NULL, &key, state);
		if (find_state(tree_ext_gwy, &key) != state)
d570 1
a570 1
purge_expired_states(void)
d575 1
a575 1
	cur = tree_first(tree_ext_gwy);
d584 1
a584 1
			if (find_state(tree_lan_ext, &key) != cur->state)
d586 2
a587 2
			tree_remove(&tree_lan_ext, NULL, &key);
			if (find_state(tree_lan_ext, &key) != NULL)
d596 1
a596 1
			next = tree_next(cur);
d599 2
a600 2
				tree_remove(&tree_ext_gwy, NULL, &cur->key);
				cur = tree_search(tree_ext_gwy, &key);
d602 2
a603 1
					printf("pf: ERROR: next not refound\n");
d605 1
a605 1
				tree_remove(&tree_ext_gwy, NULL, &cur->key);
d611 1
a611 1
			cur = tree_next(cur);
d616 1
a616 1
print_host(u_int32_t a, u_int16_t p)
d620 2
a621 1
	printf("%u.%u.%u.%u:%u", (a>>24)&255, (a>>16)&255, (a>>8)&255, a&255, p);
d625 1
a625 1
print_state(int direction, struct pf_state *s)
d627 1
a627 1
	print_host(s->lan.addr, s->lan.port);
d629 1
a629 1
	print_host(s->gwy.addr, s->gwy.port);
d631 1
a631 1
	print_host(s->ext.addr, s->ext.port);
d640 1
a640 1
print_flags(u_int8_t f)
d816 5
a820 2
		/* Rules are about to get freed, clear rule pointers in states */
		for (n = tree_first(tree_ext_gwy); n != NULL; n = tree_next(n))
d1076 2
a1077 1
		for (n = tree_first(tree_ext_gwy); n != NULL; n = tree_next(n))
d1079 1
a1079 1
		purge_expired_states();
d1091 1
a1091 1
		n = tree_first(tree_ext_gwy);
d1093 1
a1093 1
			n = tree_next(n);
d1147 1
a1147 1
cksum_fixup(u_int16_t cksum, u_int16_t old, u_int16_t new)
d1156 1
a1156 1
change_ap(u_int32_t *a, u_int16_t *p, u_int16_t *ic, u_int16_t *pc,
d1162 1
a1162 1
	*ic = cksum_fixup(cksum_fixup(*ic, ao / 65536,
d1165 1
a1165 1
	*pc = cksum_fixup(cksum_fixup(cksum_fixup(*pc, ao / 65536,
d1171 1
a1171 1
change_a(u_int32_t *a, u_int16_t *c, u_int32_t an)
d1175 1
a1175 1
	*c = cksum_fixup(cksum_fixup(*c, ao / 65536, an / 65536),
d1180 1
a1180 1
change_icmp(u_int32_t *ia, u_int16_t *ip, u_int32_t *oa, u_int32_t na,
d1187 3
a1189 3
	*pc = cksum_fixup(*pc, oip, *ip);
	*ic = cksum_fixup(*ic, oip, *ip);
	*ic = cksum_fixup(*ic, opc, *pc);
d1192 1
a1192 1
	*h2c = cksum_fixup(cksum_fixup(*h2c, oia / 65536, *ia / 65536),
d1194 1
a1194 1
	*ic = cksum_fixup(cksum_fixup(*ic, oia / 65536, *ia / 65536),
d1196 1
a1196 1
	*ic = cksum_fixup(*ic, oh2c, *h2c);
d1199 1
a1199 1
	*hc = cksum_fixup(cksum_fixup(*hc, ooa / 65536, *oa / 65536),
d1204 1
a1204 1
send_reset(int direction, struct ifnet *ifp, struct ip *h, int off,
d1291 1
a1291 1
match_addr(u_int8_t n, u_int32_t a, u_int32_t m, u_int32_t b)
d1297 1
a1297 1
match_port(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
d1319 1
a1319 1
get_nat(struct ifnet *ifp, u_int8_t proto, u_int32_t addr)
d1327 1
a1327 1
		    match_addr(n->not, n->saddr, n->smask, addr))
d1336 1
a1336 1
get_rdr(struct ifnet *ifp, u_int8_t proto, u_int32_t addr, u_int16_t port)
d1344 1
a1344 1
		    match_addr(r->not, r->daddr, r->dmask, addr) &&
d1381 1
a1381 1
		if ((nat = get_nat(ifp, IPPROTO_TCP,
d1385 3
a1387 2
			change_ap(&h->ip_src.s_addr, &th->th_sport, &h->ip_sum,
			    &th->th_sum, nat->daddr, htons(pf_next_port_tcp));
d1392 1
a1392 1
		if ((rdr = get_rdr(ifp, IPPROTO_TCP, h->ip_dst.s_addr,
d1396 1
a1396 1
			change_ap(&h->ip_dst.s_addr, &th->th_dport,
d1408 4
a1411 4
		    (!r->dst.port_op || match_port(r->dst.port_op, r->dst.port[0],
		    r->dst.port[1], th->th_dport)) &&
		    (!r->src.port_op || match_port(r->src.port_op, r->src.port[0],
		    r->src.port[1], th->th_sport)) ) {
d1428 1
a1428 1
				change_ap(&h->ip_src.s_addr, &th->th_sport,
d1433 1
a1433 1
				change_ap(&h->ip_dst.s_addr, &th->th_dport,
d1438 1
a1438 1
			send_reset(direction, ifp, h, off, th);
d1446 2
a1447 1
	if (((rm != NULL) && rm->keep_state) || (nat != NULL) || (rdr != NULL)) {
d1504 1
a1504 1
		insert_state(s);
d1528 2
a1529 1
		if ((nat = get_nat(ifp, IPPROTO_UDP, h->ip_src.s_addr)) != NULL) {
d1532 3
a1534 2
			change_ap(&h->ip_src.s_addr, &uh->uh_sport, &h->ip_sum,
			    &uh->uh_sum, nat->daddr, htons(pf_next_port_udp));
d1539 1
a1539 1
		if ((rdr = get_rdr(ifp, IPPROTO_UDP, h->ip_dst.s_addr,
d1543 1
a1543 1
			change_ap(&h->ip_dst.s_addr, &uh->uh_dport,
d1554 4
a1557 4
		    (!r->dst.port_op || match_port(r->dst.port_op, r->dst.port[0],
		    r->dst.port[1], uh->uh_dport)) &&
		    (!r->src.port_op || match_port(r->src.port_op, r->src.port[0],
		    r->src.port[1], uh->uh_sport)) ) {
d1629 1
a1629 1
		insert_state(s);
d1651 2
a1652 1
		if ((nat = get_nat(ifp, IPPROTO_ICMP, h->ip_src.s_addr)) != NULL) {
d1654 1
a1654 1
			change_a(&h->ip_src.s_addr, &h->ip_sum, nat->daddr);
d1725 1
a1725 1
		insert_state(s);
d1777 1
a1777 1
	s = find_state((direction == PF_IN) ? tree_ext_gwy : tree_lan_ext,
d1885 1
a1885 1
					change_ap(&h->ip_src.s_addr,
d1890 1
a1890 1
					change_ap(&h->ip_dst.s_addr,
d1900 2
a1901 2
			print_state(direction, s);
			print_flags(th->th_flags);
d1935 1
a1935 1
	s = find_state((direction == PF_IN) ? tree_ext_gwy : tree_lan_ext,
d1968 1
a1968 1
				change_ap(&h->ip_src.s_addr, &uh->uh_sport,
d1972 1
a1972 1
				change_ap(&h->ip_dst.s_addr, &uh->uh_dport,
d2013 1
a2013 1
		s = find_state((direction == PF_IN) ? tree_ext_gwy :
d2023 2
a2024 2
					change_a(&h->ip_src.s_addr, &h->ip_sum,
					    s->gwy.addr);
d2026 2
a2027 2
					change_a(&h->ip_dst.s_addr, &h->ip_sum,
					    s->lan.addr);
d2046 1
a2046 1
		if (!pull_hdr(ifp, m, 0, ipoff2, &h2, sizeof(h2), h,
d2064 1
a2064 1
			if (!pull_hdr(ifp, m, ipoff2, off2, &th, sizeof(th),
d2081 1
a2081 1
			s = find_state((direction == PF_IN) ? tree_ext_gwy :
d2099 2
a2100 2
				print_state(direction, s);
				print_flags(th.th_flags);
d2108 1
a2108 1
					change_icmp(&h2.ip_src.s_addr,
d2114 1
a2114 1
					change_icmp(&h2.ip_dst.s_addr,
d2143 1
a2143 1
			if (!pull_hdr(ifp, m, ipoff2, off2, &uh, sizeof(uh),
d2155 1
a2155 1
			s = find_state(direction == PF_IN ? tree_ext_gwy :
d2163 1
a2163 1
					change_icmp(&h2.ip_src.s_addr,
d2169 1
a2169 1
					change_icmp(&h2.ip_dst.s_addr,
d2205 1
a2205 1
purge_expired_fragments(void)
d2288 2
a2289 1
		frag = (struct pf_fragment *)find_state(tree_fragment, &key);
d2313 1
a2313 1
		tree_remove(&tree_fragment, NULL, &key);
d2355 2
a2356 1
		tree_insert(&tree_fragment, NULL, &key, (struct pf_state *)frag);
d2605 1
a2605 1
pull_hdr(struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *p,
d2655 2
a2656 2
		purge_expired_states();
		purge_expired_fragments();
d2684 1
a2684 1
		if (!pull_hdr(ifp, m, 0, off, &th, sizeof(th), h,
d2701 1
a2701 1
		if (!pull_hdr(ifp, m, 0, off, &uh, sizeof(uh), h,
d2718 1
a2718 1
		if (!pull_hdr(ifp, m, 0, off, &ih, sizeof(ih), h,
@


1.87
log
@lower hiwat limits, enforce hi water mark
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.86 2001/06/28 22:38:16 dhartmei Exp $ */
d84 1
a84 1
	TAILQ_ENTRY(pf_frent) fr_next;
d100 1
a100 1
	TAILQ_HEAD(pf_fragq, pf_frent) fr_queue;
d668 1
a668 1
	pool_sethiwat(&pf_frent_pl, PFFRAG_FRENT_HIWAT);
d2231 2
d2239 3
a2241 3
	for (frent = TAILQ_FIRST(&frag->fr_queue); frent;
	    frent = TAILQ_FIRST(&frag->fr_queue)) {
		TAILQ_REMOVE(&frag->fr_queue, frent, fr_next);
a2248 1
	pool_put(&pf_frag_pl, frag);
d2280 2
d2295 2
d2331 1
a2331 1
		TAILQ_INIT(&frag->fr_queue);
d2348 1
a2348 1
	TAILQ_FOREACH(frea, &frag->fr_queue, fr_next) {
d2382 1
a2382 1
		next = TAILQ_NEXT(frea, fr_next);
d2384 1
a2384 1
		TAILQ_REMOVE(&frag->fr_queue, frea, fr_next);
d2398 1
a2398 1
		TAILQ_INSERT_HEAD(&frag->fr_queue, frent, fr_next);
d2400 1
a2400 1
		TAILQ_INSERT_AFTER(&frag->fr_queue, frep, frent, fr_next);
d2408 2
a2409 2
	for (frep = TAILQ_FIRST(&frag->fr_queue); frep; frep = next) {
		next = TAILQ_NEXT(frep, fr_next);
d2421 1
a2421 1
	frent = TAILQ_FIRST(&frag->fr_queue);
d2428 1
a2428 1
	next = TAILQ_NEXT(frent, fr_next);
d2437 1
d2440 1
a2440 1
		next = TAILQ_NEXT(frent, fr_next);
a2549 2
	if (pf_nfrents > PFFRAG_FRENT_HIWAT)
		pf_flush_fragments();
@


1.86
log
@add tree traversal code (new pf_tree_node->parent), dump states TAILQ and traverse a tree instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.85 2001/06/28 22:36:09 dugsong Exp $ */
d238 2
a239 2
#define PFFRAG_FRENT_HIWAT	10000	/* Number of fragment entries */
#define PFFRAG_FRAG_HIWAT	3000	/* Number of fragmented packets */
d2314 6
a2319 2
		if (frag == NULL)
			goto drop_fragment;
d2544 2
@


1.85
log
@wrap 5-tuple rule match with MATCH_TUPLE. from ben fleis <ben@@monkey.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.84 2001/06/28 22:17:42 provos Exp $ */
d76 1
a76 1
	void			*state;
a110 1
TAILQ_HEAD(pf_statequeue, pf_state)	pf_states;
d133 8
a140 8
struct pool		pf_tree_pl;
struct pool		pf_rule_pl;
struct pool		pf_nat_pl;
struct pool		pf_rdr_pl;
struct pool		pf_state_pl;
struct pool		pf_frent_pl;
struct pool		pf_frag_pl;
int			pf_nfrents;
d146 67
a212 62
int		 tree_key_compare(struct pf_tree_key *, struct pf_tree_key *);
void		 tree_rotate_left(struct pf_tree_node **);
void		 tree_rotate_right(struct pf_tree_node **);
int		 tree_insert(struct pf_tree_node **, struct pf_tree_key *,
		    void *);
int		 tree_remove(struct pf_tree_node **, struct pf_tree_key *);
void		*find_state(struct pf_tree_node *, struct pf_tree_key *);
void		 insert_state(struct pf_state *);
void		 purge_expired_states(void);

void		 print_host(u_int32_t, u_int16_t);
void		 print_state(int, struct pf_state *);
void		 print_flags(u_int8_t);

void		 pfattach(int);
int		 pfopen(dev_t, int, int, struct proc *);
int		 pfclose(dev_t, int, int, struct proc *);
int		 pfioctl(dev_t, u_long, caddr_t, int, struct proc *);

u_int16_t	 cksum_fixup(u_int16_t, u_int16_t, u_int16_t);
void		 change_ap(u_int32_t *, u_int16_t *, u_int16_t *, u_int16_t *,
		    u_int32_t, u_int16_t);
void		 change_a(u_int32_t *, u_int16_t *, u_int32_t);
void		 change_icmp(u_int32_t *, u_int16_t *, u_int32_t *, u_int32_t,
		    u_int16_t, u_int16_t *, u_int16_t *, u_int16_t *,
		    u_int16_t *);
void		 send_reset(int, struct ifnet *, struct ip *, int,
		    struct tcphdr *);
int		 match_addr(u_int8_t, u_int32_t, u_int32_t, u_int32_t);
int		 match_port(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
struct pf_nat	*get_nat(struct ifnet *, u_int8_t, u_int32_t);
struct pf_rdr	*get_rdr(struct ifnet *, u_int8_t, u_int32_t, u_int16_t);
int		 pf_test_tcp(int, struct ifnet *, struct mbuf *,
		    int, int, struct ip *, struct tcphdr *);
int		 pf_test_udp(int, struct ifnet *, struct mbuf *,
		    int, int, struct ip *, struct udphdr *);
int		 pf_test_icmp(int, struct ifnet *, struct mbuf *,
		    int, int, struct ip *, struct icmp *);
int		 pf_test_other(int, struct ifnet *, struct mbuf *,
		    struct ip *);
struct pf_state	*pf_test_state_tcp(int, struct ifnet *, struct mbuf *,
		    int, int, struct ip *, struct tcphdr *);
struct pf_state	*pf_test_state_udp(int, struct ifnet *, struct mbuf *,
		    int, int, struct ip *, struct udphdr *);
struct pf_state	*pf_test_state_icmp(int, struct ifnet *, struct mbuf *,
		    int, int, struct ip *, struct icmp *);
void		*pull_hdr(struct ifnet *, struct mbuf *, int, int, void *, int,
		    struct ip *, u_short *, u_short *);
int		 pflog_packet(struct mbuf *, int, u_short, u_short,
		    struct pf_rule *);

int		 pf_normalize_ip(struct mbuf **, int, struct ifnet *,
		    struct ip *, u_short *);

void		 purge_expired_fragments(void);
void		 pf_ip2key(struct pf_tree_key *, struct ip *);
void		 pf_remove_fragment(struct pf_fragment *);
void		 pf_flush_fragments(void);
void		 pf_free_fragment(struct pf_fragment *);
struct pf_fragment *pf_find_fragment(struct ip *);
struct mbuf	*pf_reassemble(struct mbuf **, struct pf_fragment *,
		    struct pf_frent *, int);
d272 1
a272 1
tree_rotate_left(struct pf_tree_node **p)
d274 1
a274 1
	struct pf_tree_node *q = *p;
d276 7
a282 3
	*p = (*p)->right;
	q->right = (*p)->left;
	(*p)->left = q;
d284 3
a286 3
	if ((*p)->balance > 0)
		q->balance -= (*p)->balance;
	(*p)->balance--;
d288 1
a288 1
		(*p)->balance += q->balance;
d292 1
a292 1
tree_rotate_right(struct pf_tree_node **p)
d294 1
a294 1
	struct pf_tree_node *q = *p;
d296 7
a302 3
	*p = (*p)->left;
	q->left = (*p)->right;
	(*p)->right = q;
d304 3
a306 3
	if ((*p)->balance < 0)
		q->balance -= (*p)->balance;
	(*p)->balance++;
d308 1
a308 1
		(*p)->balance += q->balance;
d312 2
a313 1
tree_insert(struct pf_tree_node **p, struct pf_tree_key *key, void *state)
d317 3
a319 3
	if (*p == NULL) {
		*p = pool_get(&pf_tree_pl, PR_NOWAIT);
		if (*p == NULL) {
d322 5
a326 4
		bcopy(key, &(*p)->key, sizeof(struct pf_tree_key));
		(*p)->state = state;
		(*p)->balance = 0;
		(*p)->left = (*p)->right = NULL;
d328 4
a331 4
	} else if (tree_key_compare(key, &(*p)->key) > 0) {
		if (tree_insert(&(*p)->right, key, state)) {
			(*p)->balance++;
			if ((*p)->balance == 1)
d333 4
a336 4
			else if ((*p)->balance == 2) {
				if ((*p)->right->balance == -1)
					tree_rotate_right(&(*p)->right);
				tree_rotate_left(p);
d340 3
a342 3
		if (tree_insert(&(*p)->left, key, state)) {
			(*p)->balance--;
			if ((*p)->balance == -1)
d344 4
a347 4
			else if ((*p)->balance == -2) {
				if ((*p)->left->balance == 1)
					tree_rotate_left(&(*p)->left);
				tree_rotate_right(p);
d355 2
a356 1
tree_remove(struct pf_tree_node **p, struct pf_tree_key *key)
d361 1
a361 1
	if (*p == NULL)
d363 1
a363 1
	c = tree_key_compare(key, &(*p)->key);
d365 3
a367 3
		if (tree_remove(&(*p)->left, key)) {
			(*p)->balance++;
			if ((*p)->balance == 0)
d369 5
a373 5
			else if ((*p)->balance == 2) {
				if ((*p)->right->balance == -1)
					tree_rotate_right(&(*p)->right);
				tree_rotate_left(p);
				if ((*p)->balance == 0)
d378 3
a380 3
		if (tree_remove(&(*p)->right, key)) {
			(*p)->balance--;
			if ((*p)->balance == 0)
d382 5
a386 5
			else if ((*p)->balance == -2) {
				if ((*p)->left->balance == 1)
					tree_rotate_left(&(*p)->left);
				tree_rotate_right(p);
				if ((*p)->balance == 0)
d391 2
a392 2
		if ((*p)->right == NULL) {
			struct pf_tree_node *p0 = *p;
d394 4
a397 2
			*p = (*p)->left;
			pool_put(&pf_tree_pl, p0);
d399 2
a400 2
		} else if ((*p)->left == NULL) {
			struct pf_tree_node *p0 = *p;
d402 4
a405 2
			*p = (*p)->right;
			pool_put(&pf_tree_pl, p0);
d408 1
a408 1
			struct pf_tree_node **qq = &(*p)->left;
d412 2
a413 2
			bcopy(&(*qq)->key, &(*p)->key, sizeof(struct pf_tree_key));
			(*p)->state = (*qq)->state;
d415 3
a417 3
			if (tree_remove(&(*p)->left, key)) {
				(*p)->balance++;
				if ((*p)->balance == 0)
d419 5
a423 5
				else if ((*p)->balance == 2) {
					if ((*p)->right->balance == -1)
						tree_rotate_right(&(*p)->right);
					tree_rotate_left(p);
					if ((*p)->balance == 0)
d473 36
a508 2
void *
find_state(struct pf_tree_node *p, struct pf_tree_key *key)
d512 2
a513 2
	while (p && (c = tree_key_compare(&p->key, key)))
		p = (c > 0) ? p->left : p->right;
d515 8
a522 1
	return (p ? p->state : NULL);
d539 1
a539 1
		tree_insert(&tree_lan_ext, &key, state);
d552 1
a552 1
		tree_insert(&tree_ext_gwy, &key, state);
a556 2
	TAILQ_INSERT_TAIL(&pf_states, state, entries);

d564 1
a565 1
	struct pf_state *cur, *next;
d567 12
a578 12
	for (cur = TAILQ_FIRST(&pf_states); cur != NULL; cur = next) {
		next = TAILQ_NEXT(cur, entries);
		if (cur->expire <= pftv.tv_sec) {
			key.proto = cur->proto;
			key.addr[0].s_addr = cur->lan.addr;
			key.port[0] = cur->lan.port;
			key.addr[1].s_addr = cur->ext.addr;
			key.port[1] = cur->ext.port;
			/* sanity checks can be removed later */
			if (find_state(tree_lan_ext, &key) != cur)
				printf("pf: ERROR! remove invalid\n");
			tree_remove(&tree_lan_ext, &key);
d580 19
a598 14
				printf("pf: ERROR! remove failed\n");
			key.proto   = cur->proto;
			key.addr[0].s_addr = cur->ext.addr;
			key.port[0] = cur->ext.port;
			key.addr[1].s_addr = cur->gwy.addr;
			key.port[1] = cur->gwy.port;
			if (find_state(tree_ext_gwy, &key) != cur)
				printf("pf: ERROR! remove invalid\n");
			tree_remove(&tree_ext_gwy, &key);
			if (find_state(tree_ext_gwy, &key) != NULL)
				printf("pf: ERROR! remove failed\n");
			TAILQ_REMOVE(&pf_states, cur, entries);
			pool_put(&pf_state_pl, cur);
			cur = next;
d601 2
a602 1
		}
a676 1
	TAILQ_INIT(&pf_states);
d797 1
a797 1
		struct pf_state *state;
d807 2
a808 1
		TAILQ_FOREACH(state, &pf_states, entries) state->rule = NULL;
d1060 2
a1061 1
		struct pf_state *state;
d1063 2
a1064 2
		TAILQ_FOREACH(state, &pf_states, entries)
			state->expire = 0;
d1072 1
a1072 1
		struct pf_state *state;
d1077 3
a1079 3
		state = TAILQ_FIRST(&pf_states);
		while ((state != NULL) && (nr < ps->nr)) {
			state = TAILQ_NEXT(state, entries);
d1082 1
a1082 1
		if (state == NULL) {
d1087 1
a1087 1
		bcopy(state, &ps->state, sizeof(struct pf_state));
d2268 1
a2268 1
		frag = find_state(tree_fragment, &key);
d2290 1
a2290 1
		tree_remove(&tree_fragment, &key);
a2316 1
		microtime(&frag->fr_timeout);
d2326 1
a2326 1
		tree_insert(&tree_fragment, &key, frag);
@


1.84
log
@forgot to init fr_timeout
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.83 2001/06/28 21:53:41 provos Exp $ */
d223 11
d1326 1
a1326 3
		if (r->direction == direction &&
		    (r->ifp == NULL || r->ifp == ifp) &&
		    (!r->proto || r->proto == IPPROTO_TCP) &&
a1327 4
		    ((!r->src.addr && !r->src.mask) || match_addr(r->src.not, r->src.addr,
		    r->src.mask, h->ip_src.s_addr)) &&
		    ((!r->dst.addr && !r->dst.mask) || match_addr(r->dst.not, r->dst.addr,
		    r->dst.mask, h->ip_dst.s_addr)) &&
d1470 1
a1470 7
		if ((r->direction == direction) &&
		    ((r->ifp == NULL) || (r->ifp == ifp)) &&
		    (!r->proto || (r->proto == IPPROTO_UDP)) &&
		    ((!r->src.addr && !r->src.mask) || match_addr(r->src.not, r->src.addr,
		    r->src.mask, h->ip_src.s_addr)) &&
		    ((!r->dst.addr && !r->dst.mask) || match_addr(r->dst.not, r->dst.addr,
		    r->dst.mask, h->ip_dst.s_addr)) &&
d1578 1
a1578 7
		if ((r->direction == direction) &&
		    ((r->ifp == NULL) || (r->ifp == ifp)) &&
		    (!r->proto || (r->proto == IPPROTO_ICMP)) &&
		    ((!r->src.addr && !r->src.mask) || match_addr(r->src.not, r->src.addr,
		    r->src.mask, h->ip_src.s_addr)) &&
		    ((!r->dst.addr && !r->dst.mask) || match_addr(r->dst.not, r->dst.addr,
		    r->dst.mask, h->ip_dst.s_addr)) &&
d1659 1
a1659 9
		if ((r->direction == direction) &&
		    ((r->ifp == NULL) || (r->ifp == ifp)) &&
		    (!r->proto || (r->proto == h->ip_p)) &&
		    ((!r->src.addr && !r->src.mask) ||
		    match_addr(r->src.not, r->src.addr,
		    r->src.mask, h->ip_src.s_addr)) &&
		    ((!r->dst.addr && !r->dst.mask) ||
		    match_addr(r->dst.not, r->dst.addr,
		    r->dst.mask, h->ip_dst.s_addr))) {
d2417 2
a2418 7
		if ((r->direction == dir) && (r->action == PF_SCRUB) &&
		    ((r->ifp == NULL) || (r->ifp == ifp)) &&
		    (!r->proto || (r->proto == h->ip_p)) &&
		    ((!r->src.addr && !r->src.mask) || match_addr(r->src.not, r->src.addr,
		    r->src.mask, h->ip_src.s_addr)) &&
		    ((!r->dst.addr && !r->dst.mask) || match_addr(r->dst.not, r->dst.addr,
		    r->dst.mask, h->ip_dst.s_addr)) )
@


1.83
log
@first stab at packet normalization.  includes full ip reassembly.
okay dhartmei@@, dugsong@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.82 2001/06/28 10:04:19 hugh Exp $ */
d2267 1
@


1.82
log
@Disallow filter modification when the system is "highly secure".
Passed by dhartmei.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.81 2001/06/27 22:41:25 dhartmei Exp $ */
d63 3
d83 20
d107 1
d119 1
d139 3
d151 1
a151 1
		    struct pf_state *);
d153 1
a153 1
struct pf_state	*find_state(struct pf_tree_node *, struct pf_tree_key *);
d198 12
d223 3
d289 1
a289 1
tree_insert(struct pf_tree_node **p, struct pf_tree_key *key, struct pf_state *state)
d443 1
a443 1
struct pf_state *
d587 9
d1312 3
a1314 2
	r = TAILQ_FIRST(pf_rules_active);
	while (r != NULL) {
a1330 1
		r = TAILQ_NEXT(r, entries);
d1463 2
d1577 2
d1664 2
d2133 391
d2559 1
a2559 1
pf_test(int dir, struct ifnet *ifp, struct mbuf *m)
d2562 1
d2580 1
d2590 1
d2593 8
@


1.81
log
@change pf_tree_key->addr[2] from u_int32_t to struct in_addr for Niels
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.80 2001/06/27 22:05:20 jasoni Exp $ */
d583 17
@


1.80
log
@in rdr rules, let port 0 be the port wildcard; ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.79 2001/06/27 21:34:57 dhartmei Exp $ */
d69 1
a69 1
		u_int32_t	 addr[2];
d74 1
d194 1
a194 1
	if (a->addr[0] < b->addr[0])
d196 1
a196 1
	if (a->addr[0] > b->addr[0])
d198 1
a198 1
	if (a->addr[1] < b->addr[1])
d200 1
a200 1
	if (a->addr[1] > b->addr[1])
d417 1
a417 1
	key.addr[0] = state->lan.addr;
d419 1
a419 1
	key.addr[1] = state->ext.addr;
d431 1
a431 1
	key.addr[0] = state->ext.addr;
d433 1
a433 1
	key.addr[1] = state->gwy.addr;
d459 1
a459 1
			key.addr[0] = cur->lan.addr;
d461 1
a461 1
			key.addr[1] = cur->ext.addr;
d470 1
a470 1
			key.addr[0] = cur->ext.addr;
d472 1
a472 1
			key.addr[1] = cur->gwy.addr;
d1628 1
a1628 1
	key.addr[0] = h->ip_src.s_addr;
d1630 1
a1630 1
	key.addr[1] = h->ip_dst.s_addr;
d1786 1
a1786 1
	key.addr[0] = h->ip_src.s_addr;
d1788 1
a1788 1
	key.addr[1] = h->ip_dst.s_addr;
d1864 1
a1864 1
		key.addr[0] = h->ip_src.s_addr;
d1866 1
a1866 1
		key.addr[1] = h->ip_dst.s_addr;
d1932 1
a1932 1
			key.addr[0] = h2.ip_dst.s_addr;
d1934 1
a1934 1
			key.addr[1] = h2.ip_src.s_addr;
d2006 1
a2006 1
			key.addr[0] = h2.ip_dst.s_addr;
d2008 1
a2008 1
			key.addr[1] = h2.ip_src.s_addr;
@


1.79
log
@change pf_tree_node->state to void *, so Niels can use a tree for fragment handling
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.78 2001/06/27 16:07:16 provos Exp $ */
d1185 1
a1185 1
		    r->dport == port)
d1236 2
a1237 1
			    &h->ip_sum, &th->th_sum, rdr->raddr, rdr->rport);
d1386 2
a1387 1
			    &h->ip_sum, &uh->uh_sum, rdr->raddr, rdr->rport);
@


1.78
log
@use proper icmp define
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.77 2001/06/27 10:31:51 kjell Exp $ */
d73 1
a73 1
	struct pf_state		*state;
@


1.77
log
@add -z flag for zeroing statistics. -s status no longer resets anything
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.76 2001/06/27 10:27:43 kjell Exp $ */
d1536 1
a1536 1
		id = ih->icmp_hun.ih_idseq.icd_id;
d1862 1
a1862 1
		key.port[0] = ih->icmp_hun.ih_idseq.icd_id;
d1864 1
a1864 1
		key.port[1] = ih->icmp_hun.ih_idseq.icd_id;
@


1.76
log
@add microtime, which seems to have gotten lost.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.75 2001/06/27 04:24:43 deraadt Exp $ */
d965 5
a971 6

		bcopy(&pf_status, s, sizeof(struct pf_status));
		if (s->since)
			s->since = pftv.tv_sec - s->since;
		else
			s->since = 0;
a974 1
		pf_status.since = pftv.tv_sec;
@


1.75
log
@big KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.73 2001/06/27 03:47:01 dugsong Exp $ */
a589 1

d593 1
d943 1
@


1.74
log
@remove unneccessary check in ioctl
@
text
@d12 1
a12 1
 *      notice, this list of conditions and the following disclaimer. 
d16 1
a16 1
 *      with the distribution. 
d406 1
a406 1
	pf_status.state_searches++;
d444 1
a444 1
	pf_status.state_inserts++;
d481 1
a481 1
			pf_status.state_removals++;
d582 1
a582 1
	
d991 1
a991 1
	l = (l >> 16) + (l & 65535); 
d994 1
a994 1
}  
d997 2
a998 2
change_ap(u_int32_t *a, u_int16_t *p, u_int16_t *ic, u_int16_t *pc, u_int32_t an,
    u_int16_t pn)
d1003 2
a1004 1
	*ic = cksum_fixup(cksum_fixup(*ic, ao / 65536, an / 65536), ao % 65536, an % 65536);
d1006 2
a1007 1
	*pc = cksum_fixup(cksum_fixup(cksum_fixup(*pc, ao / 65536, an / 65536), ao % 65536, an % 65536),
d1016 2
a1017 1
	*c = cksum_fixup(cksum_fixup(*c, ao / 65536, an / 65536), ao % 65536, an % 65536);
d1033 4
a1036 2
	*h2c = cksum_fixup(cksum_fixup(*h2c, oia / 65536, *ia / 65536), oia % 65536, *ia % 65536);
	*ic = cksum_fixup(cksum_fixup(*ic, oia / 65536, *ia / 65536), oia % 65536, *ia % 65536);
d1040 2
a1041 1
	*hc = cksum_fixup(cksum_fixup(*hc, ooa / 65536, *oa / 65536), ooa % 65536, *oa % 65536);
d1108 1
d1122 1
a1128 1
	return;
d1525 1
a1525 1
		
d1587 1
a1587 1
	
d1592 6
a1597 4
		    ((!r->src.addr && !r->src.mask) || match_addr(r->src.not, r->src.addr,
			r->src.mask, h->ip_src.s_addr)) &&
		    ((!r->dst.addr && !r->dst.mask) || match_addr(r->dst.not, r->dst.addr,
			r->dst.mask, h->ip_dst.s_addr))) {
d1603 1
a1603 1
	
d1606 1
a1607 1
		
d1610 1
a1610 1
		
d1631 2
a1632 1
	s = find_state((direction == PF_IN) ? tree_ext_gwy : tree_lan_ext, &key);
d1638 1
a1638 1
			((th->th_flags & TH_FIN) ? 1 : 0);
d1654 1
a1654 1
			src->max_win = 1;	
d1662 1
a1662 1
			/* According to Guido, broken tcp stacks dont set ack */
d1676 7
a1682 7
				/* Last octet inside other's window space */
			SEQ_GEQ(seq, src->seqlo - dst->max_win) &&
				/* Retrans: not more than one window back */
			(ackskew >= -MAXACKWINDOW) &&
				/* Acking not more than one window back */
			(ackskew <= MAXACKWINDOW)) {
				/* Acking not more than one window forward */
d1688 3
a1690 3
				 * deduce how much data passed by what the other
				 * endpoint ACKs.  Thanks Guido!
				 *  (Why MAXACKWINDOW is used)
d1735 1
a1735 1
			/* translate source/destination address, if necessary */
d1739 4
a1742 3
					change_ap(&h->ip_src.s_addr, &th->th_sport,
					    &h->ip_sum, &th->th_sum,
					    s->gwy.addr, s->gwy.port);
d1744 4
a1747 3
					change_ap(&h->ip_dst.s_addr, &th->th_dport,
					    &h->ip_sum, &th->th_sum,
					    s->lan.addr, s->lan.port);
d1759 4
a1762 4
				SEQ_GEQ(src->seqhi, end) ? ' ' : '1',
				SEQ_GEQ(seq, src->seqlo - dst->max_win)?' ':'2',
				(ackskew >= -MAXACKWINDOW) ? ' ' : '3',
				(ackskew <= MAXACKWINDOW) ? ' ' : '4');
d1789 2
a1790 1
	s = find_state((direction == PF_IN) ? tree_ext_gwy : tree_lan_ext, &key);
a1791 1

a1857 1

a1869 1

d1874 1
a1874 1
			/* translate source/destination address, if necessary */
d1948 3
a1950 3
				!SEQ_GEQ(seq, src->seqlo - dst->max_win) ||
				!(ackskew >= -MAXACKWINDOW) ||
				!(ackskew <= MAXACKWINDOW)) {
d1964 3
a1966 3
					    s->lan.addr, s->lan.port, &th.th_sum,
					    &h2.ip_sum, &ih->icmp_cksum,
					    &h->ip_sum);
d1970 3
a1972 3
					    s->gwy.addr, s->gwy.port, &th.th_sum,
					    &h2.ip_sum, &ih->icmp_cksum,
					    &h->ip_sum);
d2019 3
a2021 3
					    s->lan.addr, s->lan.port, &uh.uh_sum,
					    &h2.ip_sum, &ih->icmp_cksum,
					    &h->ip_sum);
d2025 3
a2027 3
					    s->gwy.addr, s->gwy.port, &uh.uh_sum,
					    &h2.ip_sum, &ih->icmp_cksum,
					    &h->ip_sum);
d2184 2
a2185 2
		pf_status.bytes[dir] += h->ip_len;
		pf_status.packets[dir][action]++;
@


1.73
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.72 2001/06/27 03:39:11 provos Exp $ */
a582 6
	if ((cmd != DIOCSTART) && (cmd != DIOCSTOP) && (cmd != DIOCCLRSTATES)) {
		if (addr == NULL) {
			return (EINVAL);
		}
	}

d590 1
@


1.72
log
@for other protocols, keep correct track of match stats
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.71 2001/06/27 03:24:23 dugsong Exp $ */
d1602 1
a1602 1
		ACTION_SET(&reason, PFRES_MATCH);
@


1.71
log
@handle non-TCP/UDP/ICMP protocols
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.70 2001/06/27 02:13:43 provos Exp $ */
d1601 3
d1605 1
a1605 2
			PFLOG_PACKET(h, m, AF_INET, direction,
			    PFRES_MATCH, rm);
@


1.70
log
@remove print_ip, its unused
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.69 2001/06/27 02:10:17 provos Exp $ */
d156 2
d1581 30
d2171 1
a2171 1
		action = PF_PASS;
@


1.69
log
@clean up TAILQ usage
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.68 2001/06/27 01:57:17 provos Exp $ */
a127 1
void		 print_ip(struct ifnet *, struct ip *);
a482 20
}

void
print_ip(struct ifnet *ifp, struct ip *h)
{
	u_int32_t a;
	printf(" %s:", ifp->if_xname);
	a = ntohl(h->ip_src.s_addr);
	printf(" %u.%u.%u.%u", (a>>24)&255, (a>>16)&255, (a>>8)&255, a&255);
	a = ntohl(h->ip_dst.s_addr);
	printf(" -> %u.%u.%u.%u", (a>>24)&255, (a>>16)&255, (a>>8)&255, a&255);
	printf(" hl=%u len=%u id=%u", h->ip_hl << 2, h->ip_len - (h->ip_hl << 2),
	 h->ip_id);
	if (h->ip_off & IP_RF)
		printf(" RF");
	if (h->ip_off & IP_DF)
		printf(" DF");
	if (h->ip_off & IP_MF)
		printf(" MF");
	printf(" off=%u proto=%u\n", (h->ip_off & IP_OFFMASK) << 3, h->ip_p);
@


1.68
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.67 2001/06/27 01:55:54 provos Exp $ */
d453 2
a454 2
	cur = TAILQ_FIRST(&pf_states);
	while (cur != NULL) {
a476 1
			next = TAILQ_NEXT(cur, entries);
d482 1
a482 2
		} else
			cur = TAILQ_NEXT(cur, entries);
d804 1
a804 2
		nat = TAILQ_FIRST(pf_nats_active);
		while (nat != NULL) {
a805 2
			nat = TAILQ_NEXT(nat, entries);
		}
d905 1
a905 2
		rdr = TAILQ_FIRST(pf_rdrs_active);
		while (rdr != NULL) {
a906 2
			rdr = TAILQ_NEXT(rdr, entries);
		}
d939 1
a939 1
		struct pf_state *state = TAILQ_FIRST(&pf_states);
d941 1
a941 1
		while (state != NULL) {
a942 2
			state = TAILQ_NEXT(state, entries);
		}
d1408 1
a1408 2
	r = TAILQ_FIRST(pf_rules_active);
	while (r != NULL) {
a1423 1
		r = TAILQ_NEXT(r, entries);
d1520 1
a1520 2
	r = TAILQ_FIRST(pf_rules_active);
	while (r != NULL) {
a1533 1
		r = TAILQ_NEXT(r, entries);
@


1.67
log
@only set reason code match if there was a rule that we matched
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.66 2001/06/26 23:26:24 provos Exp $ */
d1918 1
a1918 1
				return NULL;
d1996 1
a1996 1
				return NULL;
d2066 1
a2066 1
		return NULL;
@


1.66
log
@update match counts
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.65 2001/06/26 22:56:02 dugsong Exp $ */
d1290 2
a1291 1
	REASON_SET(&reason, PFRES_MATCH);
d1293 19
a1311 15
	/* XXX will log packet before rewrite */
	if ((rm != NULL) && rm->log)
		PFLOG_PACKET(h, m, AF_INET, direction, reason, rm);

	if ((rm != NULL) && (rm->action == PF_DROP_RST)) {
		/* undo NAT/RST changes, if they have taken place */
		if (nat != NULL) {
			change_ap(&h->ip_src.s_addr, &th->th_sport,
			    &h->ip_sum, &th->th_sum, baddr, bport);
			rewrite++;
		}
		else if (rdr != NULL) {
			change_ap(&h->ip_dst.s_addr, &th->th_dport,
			    &h->ip_sum, &th->th_sum, baddr, bport);
			rewrite++;
d1314 2
a1315 2
		send_reset(direction, ifp, h, off, th);
		return (PF_DROP);
a1317 3
	if ((rm != NULL) && (rm->action == PF_DROP))
		return (PF_DROP);

d1438 2
a1439 1
	REASON_SET(&reason, PFRES_MATCH);
d1441 3
a1443 3
	/* XXX will log packet before rewrite */
	if (rm != NULL && rm->log)
		PFLOG_PACKET(h, m, AF_INET, direction, reason, rm);
d1445 3
a1447 2
	if (rm != NULL && rm->action != PF_PASS)
		return (PF_DROP);
d1550 2
a1551 1
	REASON_SET(&reason, PFRES_MATCH);
d1553 7
a1559 6
	/* XXX will log packet before rewrite */
	if (rm != NULL && rm->log)
		PFLOG_PACKET(h, m, AF_INET, direction, reason, rm);

	if (rm != NULL && rm->action != PF_PASS)
		return (PF_DROP);
@


1.65
log
@name comparison operators
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.64 2001/06/26 22:26:12 deraadt Exp $ */
d1221 14
d1244 1
d1290 2
d1294 1
a1294 1
		PFLOG_PACKET(h, m, AF_INET, direction, PFRES_MATCH, rm);
d1392 1
d1436 2
d1440 1
a1440 1
		PFLOG_PACKET(h, m, AF_INET, direction, PFRES_MATCH, rm);
d1516 1
d1546 2
d1550 1
a1550 1
		PFLOG_PACKET(h, m, AF_INET, direction, PFRES_MATCH, rm);
a2044 15


#define ACTION_SET(a, x) \
	do { \
		if ((a) != NULL) \
			*(a) = (x); \
	} while (0)

#define REASON_SET(a, x) \
	do { \
		if ((a) != NULL) \
			*(a) = (x); \
		if (x < PFRES_MAX) \
			pf_status.counters[x]++; \
	} while (0)
@


1.64
log
@array of counters indexed by reason codes
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.63 2001/06/26 21:47:40 dhartmei Exp $ */
d1168 1
a1168 1
	case 1:
d1170 1
a1170 1
	case 2:
d1172 1
a1172 1
	case 3:
d1174 3
a1176 3
	case 4:
		return (p <  a1);
	case 5:
d1178 3
a1180 3
	case 6:
		return (p >  a1);
	case 7:
@


1.63
log
@rules have numbers now, use them. add two spl locks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.62 2001/06/26 20:56:36 provos Exp $ */
d2023 14
a2036 1
#define SAVE_SET(a,x)	do { if ((a) != NULL) *(a) = (x); } while (0)
d2044 1
a2044 1
    int len, struct ip *h, u_short *action, u_short *reason)
d2050 2
a2051 2
		SAVE_SET(action, PF_DROP);
		SAVE_SET(reason, PFRES_BADOFF);
d2056 1
a2056 1
			SAVE_SET(action, PF_PASS);
d2058 2
a2059 2
			SAVE_SET(action, PF_DROP);
			SAVE_SET(reason, PFRES_FRAG);
d2064 2
a2065 2
		SAVE_SET(action, PF_DROP);
		SAVE_SET(reason, PFRES_SHORT);
d2098 1
a2098 1
		reason = PFRES_SHORT;
@


1.62
log
@rule nr is in rule now
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.61 2001/06/26 20:50:26 dhartmei Exp $ */
d706 1
a706 1
		struct pf_rule *rule;
d709 2
a710 6
		pr->nr = 0;
		rule = TAILQ_FIRST(pf_rules_active);
		while (rule != NULL) {
			pr->nr++;
			rule = TAILQ_NEXT(rule, entries);
		}
a718 1
		u_int32_t nr;
a724 1
		nr = 0;
d726 1
a726 1
		while ((rule != NULL) && (nr < pr->nr)) {
a727 2
			nr++;
		}
d804 1
a805 1
		pn->nr = 0;
d825 1
a826 1
		nr = 0;
d908 1
a909 1
		pr->nr = 0;
d929 1
a930 1
		nr = 0;
d948 1
d954 1
d964 1
d972 1
d976 1
a1229 1
	u_int16_t nr = 1, mnr = 0;
a1268 1
			mnr = nr;
a1272 1
		nr++;
a1374 1
	u_int16_t nr = 1, mnr = 0;
a1411 1
			mnr = nr;
a1415 1
		nr++;
a1495 1
	u_int16_t nr = 1, mnr = 0;
a1518 1
			mnr = nr;
a1522 1
		nr++;
@


1.61
log
@add rule nr for Niels
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.60 2001/06/26 20:06:36 provos Exp $ */
d165 1
a165 1
int		 pflog_packet(struct mbuf *, int, u_short, u_short, short,
d169 1
a169 1
#define		 PFLOG_PACKET(x,a,b,c,d,e,f) \
d173 1
a173 1
			pflog_packet(a,b,c,d,e,f); \
d359 1
a359 1
    short nr, struct pf_rule *rm)
d380 1
a380 1
	hdr.rnr = htons(nr);
d1283 1
a1283 1
		PFLOG_PACKET(h, m, AF_INET, direction, PFRES_MATCH, mnr, rm);
d1429 1
a1429 1
		PFLOG_PACKET(h, m, AF_INET, direction, PFRES_MATCH, mnr, rm);
d1539 1
a1539 1
		PFLOG_PACKET(h, m, AF_INET, direction, PFRES_MATCH, mnr, rm);
d2174 1
d2177 1
a2177 1
		PFLOG_PACKET(h, m, AF_INET, dir, reason, -1, r);
@


1.60
log
@pass rule to logging for state matches
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.59 2001/06/26 19:51:04 provos Exp $ */
d648 1
a648 1
		struct pf_rule *rule;
d660 2
@


1.59
log
@log-all causes state matches to log packets to pflog
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.58 2001/06/26 19:43:14 dhartmei Exp $ */
d2074 1
d2115 1
d2132 1
d2149 1
d2167 1
a2167 1
		struct pf_rule r;
d2169 6
a2174 3
		r.ifp = ifp;
		r.action = action;
		PFLOG_PACKET(h, m, AF_INET, dir, reason, -1, &r);
@


1.58
log
@add rule pointer and log option to states
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.57 2001/06/26 19:09:43 provos Exp $ */
d2070 1
a2070 1
pf_test(int direction, struct ifnet *ifp, struct mbuf *m)
d2074 1
d2109 1
a2109 1
			log = 1;
d2112 1
a2112 1
		if (pf_test_state_tcp(direction, ifp, m, 0, off, h, &th))
d2114 3
a2116 3
		else
			action = pf_test_tcp(direction, ifp, m, 0, off, h,
			    &th);
d2125 1
a2125 1
			log = 1;
d2128 1
a2128 1
		if (pf_test_state_udp(direction, ifp, m, 0, off, h, &uh))
d2130 3
a2132 3
		else
			action = pf_test_udp(direction, ifp, m, 0, off, h,
			    &uh);
d2141 1
a2141 1
			log = 1;
d2144 1
a2144 1
		if (pf_test_state_icmp(direction, ifp, m, 0, off, h, &ih))
d2146 3
a2148 3
		else
			action = pf_test_icmp(direction, ifp, m, 0, off, h,
			    &ih);
d2159 2
a2160 2
		pf_status.bytes[direction] += h->ip_len;
		pf_status.packets[direction][action]++;
d2162 1
a2162 1
	if (log && action != PF_PASS) {
d2167 1
a2167 1
		PFLOG_PACKET(h, m, AF_INET, direction, reason, -1, &r);
@


1.57
log
@get rid of another printf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.56 2001/06/26 19:01:55 provos Exp $ */
d677 1
d686 2
d1313 2
d1442 2
d1554 2
@


1.56
log
@use reasons in pull_hdr, default log if pull_hdr fails. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.55 2001/06/26 18:17:53 deraadt Exp $ */
a2082 1
		printf("pf: ip header too short\n");
d2084 2
@


1.55
log
@no longer pass around **m
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.54 2001/06/26 17:45:57 provos Exp $ */
d164 2
a165 2
		    struct ip *, int *);
int		 pflog_packet(struct mbuf *, int, u_short, u_short, u_short,
d359 1
a359 1
    u_short nr, struct pf_rule *rm)
a1865 1
		int dummy;
d1868 2
a1869 1
		if (!pull_hdr(ifp, m, 0, ipoff2, &h2, sizeof(h2), h, &dummy)) {
d1887 1
a1887 1
			    &h2, &dummy)) {
d1966 1
a1966 1
			    &h2, &dummy)) {
d2024 2
d2032 1
a2032 1
    int len, struct ip *h, int *action)
d2038 2
a2039 2
		printf("pf: assumption failed on header location");
		*action = PF_DROP;
d2044 1
a2044 1
			*action = PF_PASS;
d2046 2
a2047 3
			*action = PF_DROP;
			printf("pf: dropping following fragment");
			print_ip(ifp, h);
d2052 2
a2053 3
		*action = PF_DROP;
		printf("pf: dropping short packet");
		print_ip(ifp, h);
d2057 1
a2057 1
	return p;
d2063 1
a2063 1
	int action;
d2096 3
a2098 1
		if (!pull_hdr(ifp, m, 0, off, &th, sizeof(th), h, &action))
d2100 1
d2112 3
a2114 1
		if (!pull_hdr(ifp, m, 0, off, &uh, sizeof(uh), h, &action))
d2116 1
d2128 3
a2130 1
		if (!pull_hdr(ifp, m, 0, off, &ih, sizeof(ih), h, &action))
d2132 1
d2150 7
@


1.54
log
@deal with NULL rule being passed to logging
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.53 2001/06/26 15:58:42 provos Exp $ */
d151 1
a151 1
int		 pf_test_tcp(int, struct ifnet *, struct mbuf **,
d153 1
a153 1
int		 pf_test_udp(int, struct ifnet *, struct mbuf **,
d155 1
a155 1
int		 pf_test_icmp(int, struct ifnet *, struct mbuf **,
d157 1
a157 1
struct pf_state	*pf_test_state_tcp(int, struct ifnet *, struct mbuf **,
d159 1
a159 1
struct pf_state	*pf_test_state_udp(int, struct ifnet *, struct mbuf **,
d161 1
a161 1
struct pf_state	*pf_test_state_icmp(int, struct ifnet *, struct mbuf **,
d163 1
a163 1
void		*pull_hdr(struct ifnet *, struct mbuf **, int, int, void *, int,
a164 1
int		 pf_test(int, struct ifnet *, struct mbuf **);
d1220 1
a1220 1
pf_test_tcp(int direction, struct ifnet *ifp, struct mbuf **m,
d1278 1
a1278 1
		PFLOG_PACKET(h, *m, AF_INET, direction, PFRES_MATCH, mnr, rm);
d1360 1
a1360 1
		m_copyback((*m), off, sizeof(*th), (caddr_t)th);
d1366 1
a1366 1
pf_test_udp(int direction, struct ifnet *ifp, struct mbuf **m,
d1422 1
a1422 1
		PFLOG_PACKET(h, *m, AF_INET, direction, PFRES_MATCH, mnr, rm);
d1484 1
a1484 1
		m_copyback((*m), off, sizeof(*uh), (caddr_t)uh);
d1490 1
a1490 1
pf_test_icmp(int direction, struct ifnet *ifp, struct mbuf **m,
d1530 1
a1530 1
		PFLOG_PACKET(h, *m, AF_INET, direction, PFRES_MATCH, mnr, rm);
d1581 1
a1581 1
		m_copyback((*m), off, sizeof(*ih), (caddr_t)ih);
d1587 1
a1587 1
pf_test_state_tcp(int direction, struct ifnet *ifp, struct mbuf **m,
d1734 1
a1734 1
			m_copyback((*m), off, sizeof(*th), (caddr_t)th);
d1742 1
a1742 1
pf_test_state_udp(int direction, struct ifnet *ifp, struct mbuf **m,
d1800 1
a1800 1
			m_copyback((*m), off, sizeof(*uh), (caddr_t)uh);
d1808 1
a1808 1
pf_test_state_icmp(int direction, struct ifnet *ifp, struct mbuf **m,
d1950 2
a1951 2
				m_copyback((*m), off, sizeof(*ih), (caddr_t)ih);
				m_copyback((*m), ipoff2, sizeof(h2),
d1953 1
a1953 1
				m_copyback((*m), off2, sizeof(th),
d2005 2
a2006 2
				m_copyback((*m), off, sizeof(*ih), (caddr_t)ih);
				m_copyback((*m), ipoff2, sizeof(h2),
d2008 1
a2008 1
				m_copyback((*m), off2, sizeof(uh),
d2029 1
a2029 1
pull_hdr(struct ifnet *ifp, struct mbuf **m, int ipoff, int off, void *p,
d2050 1
a2050 1
	if ((*m)->m_pkthdr.len < off + len || ipoff + h->ip_len < off + len) {
d2056 1
a2056 1
	m_copydata((*m), off, len, p);
d2061 1
a2061 1
pf_test(int direction, struct ifnet *ifp, struct mbuf **m)
d2071 1
a2071 1
	if (((*m)->m_flags & M_PKTHDR) == 0)
d2082 1
a2082 1
	if ((*m)->m_pkthdr.len < sizeof(*h)) {
d2087 1
a2087 1
	h = mtod(*m, struct ip *);
@


1.53
log
@fix logging.  the ip header is contained in the first mbuf. itojun and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.52 2001/06/26 15:35:41 provos Exp $ */
d363 1
a363 1
        struct ifnet *ifn, *ifp = rm->ifp;
d372 2
@


1.52
log
@forgot htons
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.51 2001/06/26 15:33:00 provos Exp $ */
d1358 1
a1358 2
	if (rewrite) {
		m_copyback((*m), ipoff, sizeof(*h), (caddr_t)h);
a1359 1
	}
d1482 1
a1482 2
	if (rewrite) {
		m_copyback((*m), ipoff, sizeof(*h), (caddr_t)h);
a1483 1
	}
d1579 1
a1579 2
	if (rewrite) {
		m_copyback((*m), ipoff, sizeof(*h), (caddr_t)h);
a1580 1
	}
d1732 1
a1732 2
		if (rewrite) {
			m_copyback((*m), ipoff, sizeof(*h), (caddr_t)h);
a1733 1
		}
d1798 1
a1798 2
		if (rewrite) {
			m_copyback((*m), ipoff, sizeof(*h), (caddr_t)h);
a1799 1
		}
a1848 1
				rewrite++;
a1850 7
			/*
			 * copy back packet headers if we performed NAT
			 * operations
			 */
			if (rewrite)
				m_copyback((*m), ipoff, sizeof(*h), (caddr_t)h);

a1948 1
				m_copyback((*m), ipoff, sizeof(*h), (caddr_t)h);
a2003 1
				m_copyback((*m), ipoff, sizeof(*h), (caddr_t)h);
d2063 1
a2063 1
	struct ip h;
d2081 1
a2081 1
	if ((*m)->m_pkthdr.len < sizeof(h)) {
d2086 1
a2086 1
	m_copydata((*m), 0, sizeof(h), (caddr_t)&h);
d2088 1
a2088 1
	off = h.ip_hl << 2;
d2090 1
a2090 1
	switch (h.ip_p) {
d2095 1
a2095 1
		if (!pull_hdr(ifp, m, 0, off, &th, sizeof(th), &h, &action))
d2097 1
a2097 1
		if (pf_test_state_tcp(direction, ifp, m, 0, off, &h, &th))
d2100 1
a2100 1
			action = pf_test_tcp(direction, ifp, m, 0, off, &h,
d2108 1
a2108 1
		if (!pull_hdr(ifp, m, 0, off, &uh, sizeof(uh), &h, &action))
d2110 1
a2110 1
		if (pf_test_state_udp(direction, ifp, m, 0, off, &h, &uh))
d2113 1
a2113 1
			action = pf_test_udp(direction, ifp, m, 0, off, &h,
d2121 1
a2121 1
		if (!pull_hdr(ifp, m, 0, off, &ih, sizeof(ih), &h, &action))
d2123 1
a2123 1
		if (pf_test_state_icmp(direction, ifp, m, 0, off, &h, &ih))
d2126 1
a2126 1
			action = pf_test_icmp(direction, ifp, m, 0, off, &h,
d2138 1
a2138 1
		pf_status.bytes[direction] += h.ip_len;
@


1.51
log
@add a subreason to the link header to allow us to determine why a packet was
dropped or passed.  from discussion with theo and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.50 2001/06/26 12:27:16 wilfried Exp $ */
d379 2
a382 1
	hdr.rnr = htonl(nr);
@


1.50
log
@allow 0.0.0.0/x in rules
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.49 2001/06/26 11:17:31 dhartmei Exp $ */
d166 1
a166 1
int		 pflog_packet(struct mbuf *, int, short,int,
d170 1
a170 1
#define		 PFLOG_PACKET(x,a,b,c,d,e) \
d174 1
a174 1
			pflog_packet(a,b,c,d,e); \
d359 2
a360 1
pflog_packet(struct mbuf *m, int af, short dir, int nr, struct pf_rule *rm)
d1276 1
a1276 1
		PFLOG_PACKET(h, *m, AF_INET, direction, mnr, rm);
d1422 1
a1422 1
		PFLOG_PACKET(h, *m, AF_INET, direction, mnr, rm);
d1532 1
a1532 1
		PFLOG_PACKET(h, *m, AF_INET, direction, mnr, rm);
@


1.49
log
@more suitable error values when DIOCSTART/STOP fail; peters@@telia.net
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.48 2001/06/26 06:58:28 markus Exp $ */
d1256 1
a1256 1
		    (!r->src.addr || match_addr(r->src.not, r->src.addr,
d1258 1
a1258 1
		    (!r->dst.addr || match_addr(r->dst.not, r->dst.addr,
d1402 1
a1402 1
		    (!r->src.addr || match_addr(r->src.not, r->src.addr,
d1404 1
a1404 1
		    (!r->dst.addr || match_addr(r->dst.not, r->dst.addr,
d1514 1
a1514 1
		    (!r->src.addr || match_addr(r->src.not, r->src.addr,
d1516 1
a1516 1
		    (!r->dst.addr || match_addr(r->dst.not, r->dst.addr,
@


1.48
log
@no // comments
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.47 2001/06/26 05:03:36 itojun Exp $ */
d611 1
a611 1
			error = EINVAL;
d624 1
a624 1
			error = EINVAL;
@


1.47
log
@avoid useless m_copyback
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.46 2001/06/26 05:02:11 itojun Exp $ */
d1721 1
a1721 1
			// XXX Remove these printfs before release
@


1.46
log
@use m_copydata for 1st ip header too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.45 2001/06/26 04:57:34 itojun Exp $ */
d1864 1
a1864 1
			if (rewrite) {
a1865 2
				m_copyback((*m), off, sizeof(*ih), (caddr_t)ih);
			}
@


1.45
log
@avoid m_pulldown (and mbuf alloc/free).
- copy the data content of mbuf to local data structure by m_copydata.
- if we did any NAT operation, copy the updated content back by m_copyback.

XXX PFLOG_PACKET will now log the original packet, before the NAT.
 is it correct?
XXX does not do m_copyback on PF_DROP case.  is it okay?
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.44 2001/06/26 04:24:45 itojun Exp $ */
d2083 1
a2083 1
	struct ip *h = mtod(*m, struct ip *);
d2101 6
a2106 1
	off = h->ip_hl << 2;
d2108 1
a2108 7
	/* ensure we have at least the complete ip header pulled up */
	if ((*m)->m_len < off)
		if ((*m = m_pullup(*m, off)) == NULL) {
			printf("pf: pullup ip header failed\n");
			action = PF_DROP;
			goto done;
		}
d2110 1
a2110 1
	switch (h->ip_p) {
d2115 1
a2115 1
		if (!pull_hdr(ifp, m, 0, off, &th, sizeof(th), h, &action))
d2117 1
a2117 1
		if (pf_test_state_tcp(direction, ifp, m, 0, off, h, &th))
d2120 2
a2121 1
			action = pf_test_tcp(direction, ifp, m, 0, off, h, &th);
d2128 1
a2128 1
		if (!pull_hdr(ifp, m, 0, off, &uh, sizeof(uh), h, &action))
d2130 1
a2130 1
		if (pf_test_state_udp(direction, ifp, m, 0, off, h, &uh))
d2133 2
a2134 1
			action = pf_test_udp(direction, ifp, m, 0, off, h, &uh);
d2141 1
a2141 1
		if (!pull_hdr(ifp, m, 0, off, &ih, sizeof(ih), h, &action))
d2143 1
a2143 1
		if (pf_test_state_icmp(direction, ifp, m, 0, off, h, &ih))
d2146 2
a2147 1
			action = pf_test_icmp(direction, ifp, m, 0, off, h, &ih);
d2158 1
a2158 1
		pf_status.bytes[direction] += h->ip_len;
@


1.44
log
@pass ip header offset to child functions.  a preparation for
m_pulldown -> m_copydata transition.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.43 2001/06/26 04:17:11 frantzen Exp $ */
d163 1
a163 1
void		*pull_hdr(struct ifnet *, struct mbuf **, int, int, int,
d1226 1
d1236 1
d1246 1
d1273 1
d1279 1
a1279 1
		if (nat != NULL)
d1282 3
a1284 1
		else if (rdr != NULL)
d1287 3
d1355 6
d1374 1
d1383 1
d1393 1
d1419 1
d1481 6
d1498 1
d1505 1
d1529 1
d1580 6
d1595 1
d1717 1
d1735 6
d1752 1
d1800 7
d1819 1
d1857 10
d1880 2
a1881 1
		struct ip *h2;
d1885 2
a1886 3
		off += 8;	/* offset of h2 in mbuf chain */
		h2 = pull_hdr(ifp, m, 0, off, sizeof(*h2), h, &dummy);
		if (!h2) {
d1892 1
a1892 1
		off2 = off + (h2->ip_hl << 2);
d1894 1
a1894 1
		switch (h2->ip_p) {
d1896 1
a1896 1
			struct tcphdr *th;
d1903 2
a1904 3
			th = pull_hdr(ifp, m, off, off2, sizeof(*th), h2,
			    &dummy);
			if (!th) {
d1909 4
a1912 4
			seq = ntohl(th->th_seq);
			end = seq + h2->ip_len - ((h2->ip_hl + th->th_off)<<2) +
				((th->th_flags & TH_SYN) ? 1 : 0) +
				((th->th_flags & TH_FIN) ? 1 : 0);
d1915 4
a1918 4
			key.addr[0] = h2->ip_dst.s_addr;
			key.port[0] = th->th_dport;
			key.addr[1] = h2->ip_src.s_addr;
			key.port[1] = th->th_sport;
d1928 1
a1928 1
			if ((th->th_flags & TH_ACK) == 0 && th->th_ack == 0)
d1931 1
a1931 1
				ackskew = dst->seqlo - ntohl(th->th_ack);
d1939 1
a1939 1
				print_flags(th->th_flags);
d1947 4
a1950 4
					change_icmp(&h2->ip_src.s_addr,
					    &th->th_sport, &h->ip_dst.s_addr,
					    s->lan.addr, s->lan.port, &th->th_sum,
					    &h2->ip_sum, &ih->icmp_cksum,
d1953 4
a1956 4
					change_icmp(&h2->ip_dst.s_addr,
					    &th->th_dport, &h->ip_src.s_addr,
					    s->gwy.addr, s->gwy.port, &th->th_sum,
					    &h2->ip_sum, &ih->icmp_cksum,
d1959 14
d1974 1
d1979 1
a1979 1
			struct udphdr *uh;
d1983 2
a1984 3
			uh = pull_hdr(ifp, m, off, off2, sizeof(*uh), h2,
			    &dummy);
			if (!uh) {
d1990 4
a1993 4
			key.addr[0] = h2->ip_dst.s_addr;
			key.port[0] = uh->uh_dport;
			key.addr[1] = h2->ip_src.s_addr;
			key.port[1] = uh->uh_sport;
d2003 4
a2006 4
					change_icmp(&h2->ip_src.s_addr,
					    &uh->uh_sport, &h->ip_dst.s_addr,
					    s->lan.addr, s->lan.port, &uh->uh_sum,
					    &h2->ip_sum, &ih->icmp_cksum,
d2009 4
a2012 4
					change_icmp(&h2->ip_dst.s_addr,
					    &uh->uh_dport, &h->ip_src.s_addr,
					    s->gwy.addr, s->gwy.port, &uh->uh_sum,
					    &h2->ip_sum, &ih->icmp_cksum,
d2015 14
d2030 1
d2048 2
a2049 2
pull_hdr(struct ifnet *ifp, struct mbuf **m, int ipoff, int off, int len,
    struct ip *h, int *action)
a2051 2
	struct mbuf *n;
	int newoff;
d2075 2
a2076 12
	/*
	 * XXX should use m_copydata, but NAT portion tries to touch mbuf
	 * directly
	 */
	n = m_pulldown((*m), off, len, &newoff);
	if (!n) {
		printf("pf: pullup proto header failed\n");
		*action = PF_DROP;
		*m = NULL;
		return (NULL);
	}
	return (mtod(n, char *) + newoff);
d2114 1
a2114 2
		struct tcphdr *th = pull_hdr(ifp, m, 0, off, sizeof(*th), h,
		    &action);
d2116 1
a2116 1
		if (th == NULL)
d2118 1
a2118 1
		if (pf_test_state_tcp(direction, ifp, m, 0, off, h, th))
d2121 1
a2121 1
			action = pf_test_tcp(direction, ifp, m, 0, off, h, th);
d2126 1
a2126 2
		struct udphdr *uh = pull_hdr(ifp, m, 0, off, sizeof(*uh), h,
		    &action);
d2128 1
a2128 1
		if (uh == NULL)
d2130 1
a2130 1
		if (pf_test_state_udp(direction, ifp, m, 0, off, h, uh))
d2133 1
a2133 1
			action = pf_test_udp(direction, ifp, m, 0, off, h, uh);
d2138 1
a2138 2
		struct icmp *ih = pull_hdr(ifp, m, 0, off, sizeof(*ih), h,
		    &action);
d2140 1
a2140 1
		if (ih == NULL)
d2142 1
a2142 1
		if (pf_test_state_icmp(direction, ifp, m, 0, off, h, ih))
d2145 1
a2145 1
			action = pf_test_icmp(direction, ifp, m, 0, off, h, ih);
@


1.43
log
@Replicated TCP sequence tracking code in PF from Guido's IPF paper.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.42 2001/06/26 04:02:50 provos Exp $ */
d151 2
a152 2
int		 pf_test_tcp(int, struct ifnet *, struct mbuf **, int,
		    struct ip *, struct tcphdr *);
d154 1
a154 1
		    int, struct ip *, struct udphdr *);
d156 7
a162 7
		    int, struct ip *, struct icmp *);
struct pf_state	*pf_test_state_tcp(int, struct ifnet *, struct mbuf **, int,
		    struct ip *, struct tcphdr *);
struct pf_state	*pf_test_state_udp(int, struct ifnet *, struct mbuf **, int,
		    struct ip *, struct udphdr *);
struct pf_state	*pf_test_state_icmp(int, struct ifnet *, struct mbuf **, int,
		    struct ip *, struct icmp *);
d1217 2
a1218 2
pf_test_tcp(int direction, struct ifnet *ifp, struct mbuf **m, int off,
    struct ip *h, struct tcphdr *th)
d1350 2
a1351 2
pf_test_udp(int direction, struct ifnet *ifp, struct mbuf **m, int off,
    struct ip *h, struct udphdr *uh)
d1466 2
a1467 2
pf_test_icmp(int direction, struct ifnet *ifp, struct mbuf **m, int off,
	     struct ip *h, struct icmp *ih)
d1556 2
a1557 2
pf_test_state_tcp(int direction, struct ifnet *ifp, struct mbuf **m, int off,
    struct ip *h, struct tcphdr *th)
d1705 2
a1706 2
pf_test_state_udp(int direction, struct ifnet *ifp, struct mbuf **m, int off,
    struct ip *h, struct udphdr *uh)
d1765 2
a1766 2
pf_test_state_icmp(int direction, struct ifnet *ifp, struct mbuf **m, int off,
    struct ip *h, struct icmp *ih)
d2042 1
a2042 1
		if (pf_test_state_tcp(direction, ifp, m, off, h, th))
d2045 1
a2045 1
			action = pf_test_tcp(direction, ifp, m, off, h, th);
d2055 1
a2055 1
		if (pf_test_state_udp(direction, ifp, m, off, h, uh))
d2058 1
a2058 1
			action = pf_test_udp(direction, ifp, m, off, h, uh);
d2068 1
a2068 1
		if (pf_test_state_icmp(direction, ifp, m, off, h, ih))
d2071 1
a2071 1
			action = pf_test_icmp(direction, ifp, m, off, h, ih);
@


1.42
log
@sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.41 2001/06/26 04:00:29 provos Exp $ */
d56 1
d521 4
a524 2
	printf(" [%lu+%lu]", s->src.seqlo, s->src.seqhi - s->src.seqlo);
	printf(" [%lu+%lu]", s->dst.seqlo, s->dst.seqhi - s->dst.seqlo);
d1328 3
a1330 1
		s->src.seqlo	= ntohl(th->th_seq) + len; /* ??? */
d1332 5
a1337 2
		s->dst.seqlo	= 0;
		s->dst.seqhi	= 0;
d1447 1
a1447 1
		s->src.seqlo	= 0;
d1449 1
d1453 1
d1539 1
d1543 1
d1571 1
d1573 3
d1586 44
a1629 10
		/* some senders do that instead of ACKing FIN */
		if (th->th_flags == TH_RST && !ack && !len &&
		    (seq == src->seqhi || seq == src->seqhi-1) &&
		    src->state >= 4 && dst->state >= 3)
			ack = dst->seqhi;

		if ((dst->seqhi >= dst->seqlo ?
		    (ack >= dst->seqlo) && (ack <= dst->seqhi) :
		    (ack >= dst->seqlo) || (ack <= dst->seqhi)) ||
		    (seq == src->seqlo) || (seq == src->seqlo-1)) {
d1634 10
a1643 10
			/* update sequence number range */
			if (th->th_flags & TH_ACK)
				dst->seqlo = ack;
			if (th->th_flags & (TH_SYN | TH_FIN))
				len++;
			if (th->th_flags & TH_SYN) {
				src->seqhi = seq + len;
				src->seqlo = src->seqhi - 1;
			} else if (seq + len - src->seqhi < 65536)
				src->seqhi = seq + len;
d1652 1
a1652 1
			if ((th->th_flags & TH_ACK) && ack == dst->seqhi) {
d1685 1
d1691 5
d1836 1
a1836 1
			u_int32_t seq;
d1839 2
a1840 1
			struct pf_state_peer *src;
d1850 3
d1866 10
a1876 3
			if ((src->seqhi >= src->seqlo ?
			    (seq < src->seqlo) || (seq > src->seqhi) :
			    (seq < src->seqlo) && (seq > src->seqhi))) {
@


1.41
log
@pflog_packet fails on NULL mbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.40 2001/06/26 00:11:00 dhartmei Exp $ */
d365 1
a365 1
	if (mbuf == NULL)
@


1.40
log
@mea culpa
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.39 2001/06/25 23:02:20 provos Exp $ */
d364 3
@


1.39
log
@extend the logging via a new link header type.  export interface, direction,
action and rule nr.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.38 2001/06/25 22:53:39 dhartmei Exp $ */
d561 1
@


1.38
log
@remaining lists converted to TAILQs
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.37 2001/06/25 22:08:03 dhartmei Exp $ */
d60 1
d165 2
a166 1
int		 pflog_packet(struct mbuf *, int, int);
d168 2
a169 1
#define		 PFLOG_PACKET(x,a,b,c) \
d173 1
a173 1
			pflog_packet(a,b,c); \
d177 3
d358 1
a358 1
pflog_packet(struct mbuf *m, int af, int action)
d361 1
a361 1
        struct ifnet *ifn;
d366 11
d382 1
a382 11
	switch (action) {
	case PF_DROP_RST:
	case PF_DROP:
		ifn = &(pflogif[0].sc_if);
		break;
	case PF_PASS:
		ifn = &(pflogif[1].sc_if);
		break;
	default:
		return (-1);
	}
d1264 1
a1264 1
		PFLOG_PACKET(h, *m, AF_INET, rm->action);
d1390 1
a1390 1
		PFLOG_PACKET(h, *m, AF_INET, rm->action);
d1489 1
a1489 1
		PFLOG_PACKET(h, *m, AF_INET, rm->action);
@


1.37
log
@use TAILQ instead of homegrown list, other lists will follow
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.36 2001/06/25 20:48:17 provos Exp $ */
d82 3
d87 4
a90 5
struct pf_nat		*pf_nathead_active;
struct pf_nat		*pf_nathead_inactive;
struct pf_rdr		*pf_rdrhead_active;
struct pf_rdr		*pf_rdrhead_inactive;
struct pf_state		*pf_statehead;
d427 1
a427 2
	state->next = pf_statehead;
	pf_statehead = state;
d437 1
a437 1
	struct pf_state *cur = pf_statehead, *prev = NULL;
d439 1
d463 2
a464 1
			(prev ? prev->next : pf_statehead) = cur->next;
d466 1
a466 1
			cur = (prev ? prev->next : pf_statehead);
d469 2
a470 4
		} else {
			prev = cur;
			cur = cur->next;
		}
d550 4
d556 4
d726 1
d728 3
a730 4
		while (pf_nathead_inactive != NULL) {
			struct pf_nat *next = pf_nathead_inactive->next;
			pool_put(&pf_nat_pl, pf_nathead_inactive);
			pf_nathead_inactive = next;
d756 1
a756 2
		nat->next = pf_nathead_inactive;
		pf_nathead_inactive = nat;
d762 2
d769 2
d772 3
a774 7
		while (pf_nathead_active != NULL) {
			struct pf_nat *next = pf_nathead_active->next;
			pool_put(&pf_nat_pl, pf_nathead_active);
			pf_nathead_active = next;
		}
		pf_nathead_active = pf_nathead_inactive;
		pf_nathead_inactive = NULL;
d777 6
a790 1
		nat = pf_nathead_active;
d792 1
d795 1
a795 1
			nat = nat->next;
a811 1
		nat = pf_nathead_active;
d813 1
d815 1
a815 1
			nat = nat->next;
d830 1
d832 3
a834 4
		while (pf_rdrhead_inactive != NULL) {
			struct pf_rdr *next = pf_rdrhead_inactive->next;
			pool_put(&pf_rdr_pl, pf_rdrhead_inactive);
			pf_rdrhead_inactive = next;
d860 1
a860 2
		rdr->next = pf_rdrhead_inactive;
		pf_rdrhead_inactive = rdr;
d866 2
d873 2
d876 3
a878 7
		while (pf_rdrhead_active != NULL) {
			struct pf_rdr *next = pf_rdrhead_active->next;
			pool_put(&pf_rdr_pl, pf_rdrhead_active);
			pf_rdrhead_active = next;
		}
		pf_rdrhead_active = pf_rdrhead_inactive;
		pf_rdrhead_inactive = NULL;
d881 6
a894 1
		rdr = pf_rdrhead_active;
d896 1
d899 1
a899 1
			rdr = rdr->next;
a915 1
		rdr = pf_rdrhead_active;
d917 1
d919 1
a919 1
			rdr = rdr->next;
d933 1
a933 1
		struct pf_state *state = pf_statehead;
d936 1
a936 1
			state = state->next;
a946 1
		state = pf_statehead;
d948 1
d950 1
a950 1
			state = state->next;
d1170 1
a1170 1
	struct pf_nat *n = pf_nathead_active, *nm = NULL;
d1172 1
d1179 1
a1179 1
			n = n->next;
d1187 3
a1189 1
	struct pf_rdr *r = pf_rdrhead_active, *rm = NULL;
d1197 1
a1197 1
			r = r->next;
@


1.36
log
@first stab at packet logging for pf.  inspired by late night dreams of art.
we just pass drop and passed packets to different pseudo interface that
can be listened to with bpf.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.35 2001/06/25 19:53:37 art Exp $ */
d81 3
a83 4
struct pf_rule		*pf_rulehead_active;
struct pf_rule		*pf_rulehead_inactive;
struct pf_rule		*pf_ruletail_active;
struct pf_rule		*pf_ruletail_inactive;
d547 4
d610 1
d612 3
a614 4
		while (pf_rulehead_inactive != NULL) {
			struct pf_rule *next = pf_rulehead_inactive->next;
			pool_put(&pf_rule_pl, pf_rulehead_inactive);
			pf_rulehead_inactive = next;
d643 1
a643 6
		rule->next = NULL;
		if (pf_ruletail_inactive != NULL) {
			pf_ruletail_inactive->next = rule;
			pf_ruletail_inactive = rule;
		} else
			pf_rulehead_inactive = pf_ruletail_inactive = rule;
d649 2
a650 1
		struct pf_rule *old_rules;
d659 3
a661 5
		old_rules = pf_rulehead_active;
		pf_rulehead_active = pf_rulehead_inactive;
		pf_ruletail_active = pf_ruletail_inactive;
		pf_rulehead_inactive = NULL;
		pf_ruletail_inactive = NULL;
d666 3
a668 5
		while (old_rules != NULL) {
			struct pf_rule *next = old_rules->next;

			pool_put(&pf_rule_pl, old_rules);
			old_rules = next;
a669 1

a677 1
		rule = pf_rulehead_active;
d679 1
d682 1
a682 1
			rule = rule->next;
a698 1
		rule = pf_rulehead_active;
d700 1
d702 1
a702 1
			rule = rule->next;
d1188 1
a1188 1
	struct pf_rule *r = pf_rulehead_active, *rm = NULL;
d1211 1
d1230 1
a1230 1
		r = r->next;
d1316 1
a1316 1
	struct pf_rule *r = pf_rulehead_active, *rm = NULL;
d1338 1
d1356 1
a1356 1
		r = r->next;
d1428 1
a1428 1
	struct pf_rule *r = pf_rulehead_active, *rm = NULL;
d1439 1
d1455 1
a1455 1
		r = r->next;
@


1.35
log
@Unnecessary gotos.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.34 2001/06/25 19:22:26 art Exp $ */
d46 1
d49 1
d59 2
d148 6
a153 6
int		 pf_test_tcp(int, struct ifnet *, int, struct ip *,
		    struct tcphdr *);
int		 pf_test_udp(int, struct ifnet *, int, struct ip *,
		    struct udphdr *);
int		 pf_test_icmp(int, struct ifnet *, int, struct ip *,
		    struct icmp *);
d163 10
d350 33
d1187 2
a1188 2
pf_test_tcp(int direction, struct ifnet *ifp, int off, struct ip *h,
    struct tcphdr *th)
d1239 2
a1240 19
	if ((rm != NULL) && rm->log) {
		u_int32_t seq = ntohl(th->th_seq);
		u_int16_t len = h->ip_len - off - (th->th_off << 2);

		printf("pf: @@%u", mnr);
		printf(" %s %s", rm->action ? "block" : "pass",
		    direction ? "out" : "in");
		printf(" on %s proto tcp", ifp->if_xname);
		printf(" from ");
		print_host(h->ip_src.s_addr, th->th_sport);
		printf(" to ");
		print_host(h->ip_dst.s_addr, th->th_dport);
		print_flags(th->th_flags);
		if (len || (th->th_flags & (TH_SYN | TH_FIN | TH_RST)))
			printf(" %lu:%lu(%u)", seq, seq + len, len);
		if (th->th_ack)
			printf(" ack=%lu", ntohl(th->th_ack));
		printf("\n");
	}
d1314 2
a1315 2
pf_test_udp(int direction, struct ifnet *ifp, int off, struct ip *h,
    struct udphdr *uh)
d1364 2
a1365 11
	if (rm != NULL && rm->log) {
		printf("pf: @@%u", mnr);
		printf(" %s %s", rm->action ? "block" : "pass", direction ? "out" :
		    "in");
		printf(" on %s proto udp", ifp->if_xname);
		printf(" from ");
		print_host(h->ip_src.s_addr, uh->uh_sport);
		printf(" to ");
		print_host(h->ip_dst.s_addr, uh->uh_dport);
		printf("\n");
	}
d1427 2
a1428 2
pf_test_icmp(int direction, struct ifnet *ifp, int off, struct ip *h,
    struct icmp *ih)
d1462 2
a1463 12
	if (rm != NULL && rm->log) {
		printf("pf: @@%u", mnr);
		printf(" %s %s", rm->action ? "block" : "pass", direction ? "in" :
		    "out");
		printf(" on %s proto icmp", ifp->if_xname);
		printf(" from ");
		print_host(h->ip_src.s_addr, 0);
		printf(" to ");
		print_host(h->ip_dst.s_addr, 0);
		printf(" type %u/%u", ih->icmp_type, ih->icmp_code);
		printf("\n");
	}
d1948 1
a1948 1
			action = pf_test_tcp(direction, ifp, off, h, th);
d1961 1
a1961 1
			action = pf_test_udp(direction, ifp, off, h, uh);
d1974 1
a1974 1
			action = pf_test_icmp(direction, ifp, off, h, ih);
@


1.34
log
@Rework COMMITRULES.
First we swap in the new rules, then we free the old (freeing can be done
outside splnet).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.33 2001/06/25 17:17:04 dhartmei Exp $ */
d576 1
a576 1
			goto done;
d581 1
a581 1
			goto done;
d590 1
a590 1
				goto done;
d608 1
a608 1
			goto done;
d655 1
a655 1
			goto done;
d667 1
a667 1
			goto done;
d692 1
a692 1
			goto done;
d697 1
a697 1
			goto done;
d704 1
a704 1
			goto done;
d716 1
a716 1
			goto done;
d754 1
a754 1
			goto done;
d766 1
a766 1
			goto done;
d791 1
a791 1
			goto done;
d796 1
a796 1
			goto done;
d803 1
a803 1
			goto done;
d815 1
a815 1
			goto done;
d853 1
a853 1
			goto done;
d865 1
a865 1
			goto done;
d895 1
a895 1
			goto done;
a938 1
done:
@


1.33
log
@revised ioctl interface, first getopt version of pfctl
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.32 2001/06/25 16:53:20 jasoni Exp $ */
d604 1
d610 2
d613 1
a613 5
		while (pf_rulehead_active != NULL) {
			struct pf_rule *next = pf_rulehead_active->next;
			pool_put(&pf_rule_pl, pf_rulehead_active);
			pf_rulehead_active = next;
		}
d620 9
@


1.32
log
@display correct direction in log
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.31 2001/06/25 10:07:14 art Exp $ */
d77 9
a85 4
struct pf_rule		*pf_rulehead;
struct pf_nat		*pf_nathead;
struct pf_rdr		*pf_rdrhead;
struct pf_state		*pfstatehead;
d92 6
d379 2
a380 2
	state->next = pfstatehead;
	pfstatehead = state;
d390 1
a390 1
	struct pf_state *cur = pfstatehead, *prev = NULL;
d415 1
a415 1
			(prev ? prev->next : pfstatehead) = cur->next;
d417 1
a417 1
			cur = (prev ? prev->next : pfstatehead);
a522 2
	struct pfioc *ub;
	void *kb = NULL;
d529 1
a529 2
		ub = (struct pfioc *)addr;
		if (ub == NULL)
a530 6
		kb = malloc(ub->size, M_DEVBUF, M_NOWAIT);
		if (kb == NULL)
			return (ENOMEM);
		if (copyin(ub->buffer, kb, ub->size)) {
			free(kb, M_DEVBUF);
			return (EIO);
a533 8
	s = splsoftnet();

	microtime(&pftv);
	if (pftv.tv_sec - pf_last_purge >= 10) {
		purge_expired_states();
		pf_last_purge = pftv.tv_sec;
	}

d558 32
a589 14
	case DIOCSETRULES: {
		struct pf_rule *rules = (struct pf_rule *)kb, *ruletail = NULL;
		u_int16_t n;
		while (pf_rulehead != NULL) {
			struct pf_rule *next = pf_rulehead->next;
			pool_put(&pf_rule_pl, pf_rulehead);
			pf_rulehead = next;
		}
		for (n = 0; n < ub->entries; ++n) {
			struct pf_rule *rule;

			rule = pool_get(&pf_rule_pl, PR_NOWAIT);
			if (rule == NULL) {
				error = ENOMEM;
a591 16
			bcopy(rules + n, rule, sizeof(struct pf_rule));
			rule->ifp = NULL;
			if (rule->ifname[0]) {
				rule->ifp = ifunit(rule->ifname);
				if (rule->ifp == NULL) {
					pool_put(&pf_rule_pl, rule);
					error = EINVAL;
					goto done;
				}
			}
			rule->next = NULL;
			if (ruletail != NULL) {
				ruletail->next = rule;
				ruletail = rule;
			} else
				pf_rulehead = ruletail = rule;
d593 28
d625 8
a632 6
		struct pf_rule *rules = (struct pf_rule *)kb;
		struct pf_rule *rule = pf_rulehead;
		u_int16_t n = 0;
		while ((rule != NULL) && (n < ub->entries)) {
			bcopy(rule, rules + n, sizeof(struct pf_rule));
			n++;
d635 2
a636 1
		ub->entries = n;
d640 37
a676 5
	case DIOCSETNAT: {
		struct pf_nat *nats = (struct pf_nat *)kb;
		u_int16_t n;
		while (pf_nathead != NULL) {
			struct pf_nat *next = pf_nathead->next;
d678 19
a696 2
			pool_put(&pf_nat_pl, pf_nathead);
			pf_nathead = next;
d698 7
a704 2
		for (n = 0; n < ub->entries; ++n) {
			struct pf_nat *nat;
d706 27
a732 14
			nat = pool_get(&pf_nat_pl, PR_NOWAIT);
			if (nat == NULL) {
				error = ENOMEM;
				goto done;
			}
			bcopy(nats + n, nat, sizeof(struct pf_nat));
			nat->ifp = ifunit(nat->ifname);
			if (nat->ifp == NULL) {
				pool_put(&pf_nat_pl, nat);
				error = EINVAL;
				goto done;
			}
			nat->next = pf_nathead;
			pf_nathead = nat;
d734 2
d740 12
a751 6
		struct pf_nat *nats = (struct pf_nat *)kb;
		struct pf_nat *nat = pf_nathead;
		u_int16_t n = 0;
		while ((nat != NULL) && (n < ub->entries)) {
			bcopy(nat, nats + n, sizeof(struct pf_nat));
			n++;
d753 6
d760 2
a761 1
		ub->entries = n;
d765 2
a766 5
	case DIOCSETRDR: {
		struct pf_rdr *rdrs = (struct pf_rdr *)kb;
		u_int16_t n;
		while (pf_rdrhead != NULL) {
			struct pf_rdr *next = pf_rdrhead->next;
d768 4
a771 2
			pool_put(&pf_rdr_pl, pf_rdrhead);
			pf_rdrhead = next;
d773 31
a803 2
		for (n = 0; n < ub->entries; ++n) {
			struct pf_rdr *rdr;
d805 27
a831 14
			rdr = pool_get(&pf_rdr_pl, PR_NOWAIT);
			if (rdr == NULL) {
				error = ENOMEM;
				goto done;
			}
			bcopy(rdrs + n, rdr, sizeof(struct pf_rdr));
			rdr->ifp = ifunit(rdr->ifname);
			if (rdr->ifp == NULL) {
				pool_put(&pf_rdr_pl, rdr);
				error = EINVAL;
				goto done;
			}
			rdr->next = pf_rdrhead;
			pf_rdrhead = rdr;
d833 2
d839 12
a850 6
		struct pf_rdr *rdrs = (struct pf_rdr *)kb;
		struct pf_rdr *rdr = pf_rdrhead;
		u_int16_t n = 0;
		while ((rdr != NULL) && (n < ub->entries)) {
			bcopy(rdr, rdrs + n, sizeof(struct pf_rdr));
			n++;
d852 6
d859 2
a860 1
		ub->entries = n;
d865 1
a865 1
		struct pf_state *state = pfstatehead;
d874 2
a875 2
	case DIOCGETSTATES: {
		struct pf_state *states = (struct pf_state *)kb;
d877 5
a881 10
		u_int16_t n = 0;
		state = pfstatehead;
		while ((state != NULL) && (n < ub->entries)) {
			bcopy(state, states + n, sizeof(struct pf_state));
			states[n].creation = pftv.tv_sec - states[n].creation;
			if (states[n].expire <= pftv.tv_sec)
				states[n].expire = 0;
			else
				states[n].expire -= pftv.tv_sec;
			n++;
d883 1
d885 10
a894 1
		ub->entries = n;
d899 4
a902 3
		char *ifname = (char *)kb;
		struct ifnet *ifp = ifunit(ifname);
		if (ifp == NULL)
d910 1
a910 1
		struct pf_status *st = (struct pf_status *)kb;
d913 6
a918 3
		bcopy(&pf_status, st, sizeof(struct pf_status));
		st->since = st->since ? pftv.tv_sec - st->since : 0;
		ub->entries = 1;
a931 6
	splx(s);
	if (kb != NULL) {
		if (copyout(kb, ub->buffer, ub->size))
			error = EIO;
		free(kb, M_DEVBUF);
	}
d1103 1
a1103 1
	struct pf_nat *n = pf_nathead, *nm = NULL;
d1119 1
a1119 1
	struct pf_rdr *r = pf_rdrhead, *rm = NULL;
d1140 1
a1140 1
	struct pf_rule *r = pf_rulehead, *rm = NULL;
d1284 1
a1284 1
	struct pf_rule *r = pf_rulehead, *rm = NULL;
d1404 1
a1404 1
	struct pf_rule *r = pf_rulehead, *rm = NULL;
@


1.31
log
@Rename the rest of the structs to be consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.30 2001/06/25 09:57:08 art Exp $ */
d1023 1
a1023 1
		    direction ? "in" : "out");
d1161 2
a1162 2
		printf(" %s %s", rm->action ? "block" : "pass", direction ? "in" :
		    "out");
@


1.30
log
@fix -> cksum_fixup
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.29 2001/06/25 09:46:20 art Exp $ */
d1344 1
a1344 1
		struct state_peer *src, *dst;
d1450 1
a1450 1
		struct state_peer *src, *dst;
d1567 1
a1567 1
			struct state_peer *src;
@


1.29
log
@No c++ comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.28 2001/06/25 09:35:52 art Exp $ */
d120 1
a120 1
u_int16_t	 fix(u_int16_t, u_int16_t, u_int16_t);
d768 1
a768 1
fix(u_int16_t cksum, u_int16_t old, u_int16_t new)
d783 1
a783 1
	*ic = fix(fix(*ic, ao / 65536, an / 65536), ao % 65536, an % 65536);
d785 1
a785 1
	*pc = fix(fix(fix(*pc, ao / 65536, an / 65536), ao % 65536, an % 65536),
d794 1
a794 1
	*c = fix(fix(*c, ao / 65536, an / 65536), ao % 65536, an % 65536);
d805 3
a807 3
	*pc = fix(*pc, oip, *ip);
	*ic = fix(*ic, oip, *ip);
	*ic = fix(*ic, opc, *pc);
d810 3
a812 3
	*h2c = fix(fix(*h2c, oia / 65536, *ia / 65536), oia % 65536, *ia % 65536);
	*ic = fix(fix(*ic, oia / 65536, *ia / 65536), oia % 65536, *ia % 65536);
	*ic = fix(*ic, oh2c, *h2c);
d815 1
a815 1
	*hc = fix(fix(*hc, ooa / 65536, *oa / 65536), ooa % 65536, *oa % 65536);
@


1.28
log
@Even more global variables with too common names.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.27 2001/06/25 09:31:07 art Exp $ */
d109 1
d114 1
d119 1
d803 1
a803 1
	// change inner protocol port, fix inner protocol checksum
d808 1
a808 1
	// change inner ip address, fix inner ip checksum and icmp checksum
d813 1
a813 1
	// change outer ip address, fix outer ip checksum
d1092 1
a1092 1
		s->src.seqlo	= ntohl(th->th_seq) + len; // ???
@


1.27
log
@More renaming.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.26 2001/06/25 09:23:30 art Exp $ */
d86 3
a88 3
u_int32_t		 last_purge = 0;
u_int16_t		 next_port_tcp = 50001;
u_int16_t		 next_port_udp = 50001;
d532 1
a532 1
	if (pftv.tv_sec - last_purge >= 10) {
d534 1
a534 1
		last_purge = pftv.tv_sec;
d979 1
a979 1
			    &th->th_sum, nat->daddr, htons(next_port_tcp));
d1069 3
a1071 3
				next_port_tcp++;
				if (next_port_tcp == 65535)
					next_port_tcp = 50001;
d1122 1
a1122 1
			    &uh->uh_sum, nat->daddr, htons(next_port_udp));
d1191 3
a1193 3
				next_port_udp++;
				if (next_port_udp == 65535)
					next_port_udp = 50001;
d1733 1
a1733 1
	if (pftv.tv_sec - last_purge >= 10) {
d1735 1
a1735 1
		last_purge = pftv.tv_sec;
@


1.26
log
@Avoid common names. Needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.25 2001/06/25 08:58:21 art Exp $ */
d78 2
a79 2
struct nat		*nathead;
struct rdr		*rdrhead;
d128 2
a129 2
struct nat	*get_nat(struct ifnet *, u_int8_t, u_int32_t);
struct rdr	*get_rdr(struct ifnet *, u_int8_t, u_int32_t, u_int16_t);
d481 1
a481 1
        pool_init(&pf_nat_pl, sizeof(struct nat), 0, 0, 0, "pfnatpl",
d483 1
a483 1
        pool_init(&pf_rdr_pl, sizeof(struct rdr), 0, 0, 0, "pfrdrpl",
d611 1
a611 1
		struct nat *nats = (struct nat *)kb;
d613 2
a614 2
		while (nathead != NULL) {
			struct nat *next = nathead->next;
d616 2
a617 2
			pool_put(&pf_nat_pl, nathead);
			nathead = next;
d620 1
a620 1
			struct nat *nat;
d627 1
a627 1
			bcopy(nats + n, nat, sizeof(struct nat));
d634 2
a635 2
			nat->next = nathead;
			nathead = nat;
d641 2
a642 2
		struct nat *nats = (struct nat *)kb;
		struct nat *nat = nathead;
d645 1
a645 1
			bcopy(nat, nats + n, sizeof(struct nat));
d654 1
a654 1
		struct rdr *rdrs = (struct rdr *)kb;
d656 2
a657 2
		while (rdrhead != NULL) {
			struct rdr *next = rdrhead->next;
d659 2
a660 2
			pool_put(&pf_rdr_pl, rdrhead);
			rdrhead = next;
d663 1
a663 1
			struct rdr *rdr;
d670 1
a670 1
			bcopy(rdrs + n, rdr, sizeof(struct rdr));
d677 2
a678 2
			rdr->next = rdrhead;
			rdrhead = rdr;
d684 2
a685 2
		struct rdr *rdrs = (struct rdr *)kb;
		struct rdr *rdr = rdrhead;
d688 1
a688 1
			bcopy(rdr, rdrs + n, sizeof(struct rdr));
d929 1
a929 1
struct nat *
d932 1
a932 1
	struct nat *n = nathead, *nm = NULL;
d945 1
a945 1
struct rdr *
d948 1
a948 1
	struct rdr *r = rdrhead, *rm = NULL;
d965 2
a966 2
	struct nat *nat = NULL;
	struct rdr *rdr = NULL;
d1109 2
a1110 2
	struct nat *nat = NULL;
	struct rdr *rdr = NULL;
d1231 1
a1231 1
	struct nat *nat = NULL;
@


1.25
log
@rename tree_node -> pf_tree_node
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.24 2001/06/25 08:42:08 art Exp $ */
d62 1
a62 1
	struct tree_key {
d67 1
a67 1
	struct state		*state;
d77 1
a77 1
struct rule		*rulehead;
d80 1
a80 1
struct state		*statehead;
d83 1
a83 1
struct status		 status;
d100 1
a100 1
int		 tree_key_compare(struct tree_key *, struct tree_key *);
d103 5
a107 5
int		 tree_insert(struct pf_tree_node **, struct tree_key *,
		    struct state *);
int		 tree_remove(struct pf_tree_node **, struct tree_key *);
struct state	*find_state(struct pf_tree_node *, struct tree_key *);
void		 insert_state(struct state *);
d111 1
a111 1
void		 print_state(int, struct state *);
d136 1
a136 1
struct state	*pf_test_state_tcp(int, struct ifnet *, struct mbuf **, int,
d138 1
a138 1
struct state	*pf_test_state_udp(int, struct ifnet *, struct mbuf **, int,
d140 1
a140 1
struct state	*pf_test_state_icmp(int, struct ifnet *, struct mbuf **, int,
d147 1
a147 1
tree_key_compare(struct tree_key *a, struct tree_key *b)
d209 1
a209 1
tree_insert(struct pf_tree_node **p, struct tree_key *key, struct state *state)
d218 1
a218 1
		bcopy(key, &(*p)->key, sizeof(struct tree_key));
d250 1
a250 1
tree_remove(struct pf_tree_node **p, struct tree_key *key)
d302 1
a302 1
			bcopy(&(*qq)->key, &(*p)->key, sizeof(struct tree_key));
d304 1
a304 1
			bcopy(key, &(*qq)->key, sizeof(struct tree_key));
d322 2
a323 2
struct state *
find_state(struct pf_tree_node *p, struct tree_key *key)
d329 1
a329 1
	status.state_searches++;
d334 1
a334 1
insert_state(struct state *state)
d336 1
a336 1
	struct tree_key key;
d365 2
a366 2
	state->next = statehead;
	statehead = state;
d368 2
a369 2
	status.state_inserts++;
	status.states++;
d375 2
a376 2
	struct tree_key key;
	struct state *cur = statehead, *prev = NULL;
d401 1
a401 1
			(prev ? prev->next : statehead) = cur->next;
d403 3
a405 3
			cur = (prev ? prev->next : statehead);
			status.state_removals++;
			status.states--;
d442 1
a442 1
print_state(int direction, struct state *s)
d479 1
a479 1
        pool_init(&pf_rule_pl, sizeof(struct rule), 0, 0, 0, "pfrulepl",
d485 1
a485 1
        pool_init(&pf_state_pl, sizeof(struct state), 0, 0, 0, "pfstatepl",
d540 1
a540 1
		if (status.running)
d543 5
a547 5
			u_int32_t states = status.states;
			bzero(&status, sizeof(struct status));
			status.running = 1;
			status.states = states;
			status.since = pftv.tv_sec;
d553 1
a553 1
		if (!status.running)
d556 1
a556 1
			status.running = 0;
d562 1
a562 1
		struct rule *rules = (struct rule *)kb, *ruletail = NULL;
d564 4
a567 4
		while (rulehead != NULL) {
			struct rule *next = rulehead->next;
			pool_put(&pf_rule_pl, rulehead);
			rulehead = next;
d570 1
a570 1
			struct rule *rule;
d577 1
a577 1
			bcopy(rules + n, rule, sizeof(struct rule));
d592 1
a592 1
				rulehead = ruletail = rule;
d598 2
a599 2
		struct rule *rules = (struct rule *)kb;
		struct rule *rule = rulehead;
d602 1
a602 1
			bcopy(rule, rules + n, sizeof(struct rule));
d697 1
a697 1
		struct state *state = statehead;
d707 2
a708 2
		struct state *states = (struct state *)kb;
		struct state *state;
d710 1
a710 1
		state = statehead;
d712 1
a712 1
			bcopy(state, states + n, sizeof(struct state));
d736 4
a739 4
		struct status *st = (struct status *)kb;
		u_int8_t running = status.running;
		u_int32_t states = status.states;
		bcopy(&status, st, sizeof(struct status));
d742 4
a745 4
		bzero(&status, sizeof(struct status));
		status.running = running;
		status.states = states;
		status.since = pftv.tv_sec;
d969 1
a969 1
	struct rule *r = rulehead, *rm = NULL;
d1052 1
a1052 1
		struct state *s;
d1113 1
a1113 1
	struct rule *r = rulehead, *rm = NULL;
d1174 1
a1174 1
		struct state *s;
d1233 1
a1233 1
	struct rule *r = rulehead, *rm = NULL;
d1283 1
a1283 1
		struct state *s;
d1324 1
a1324 1
struct state *
d1328 2
a1329 2
	struct state *s;
	struct tree_key key;
d1429 1
a1429 1
struct state *
d1433 2
a1434 2
	struct state *s;
	struct tree_key key;
d1489 1
a1489 1
struct state *
d1506 2
a1507 2
		struct state *s;
		struct tree_key key;
d1562 2
a1563 2
			struct state *s;
			struct tree_key key;
d1619 2
a1620 2
			struct state *s;
			struct tree_key key;
d1723 1
a1723 1
	if (!status.running)
d1796 2
a1797 2
		status.bytes[direction] += h->ip_len;
		status.packets[direction][action]++;
@


1.24
log
@more
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.23 2001/06/25 08:39:48 art Exp $ */
d61 1
a61 1
struct tree_node {
d68 2
a69 2
	struct tree_node	*left;
	struct tree_node	*right;
d81 1
a81 1
struct tree_node	*tree_lan_ext, *tree_ext_gwy;
d101 3
a103 3
void		 tree_rotate_left(struct tree_node **);
void		 tree_rotate_right(struct tree_node **);
int		 tree_insert(struct tree_node **, struct tree_key *,
d105 2
a106 2
int		 tree_remove(struct tree_node **, struct tree_key *);
struct state	*find_state(struct tree_node *, struct tree_key *);
d177 1
a177 1
tree_rotate_left(struct tree_node **p)
d179 1
a179 1
	struct tree_node *q = *p;
d193 1
a193 1
tree_rotate_right(struct tree_node **p)
d195 1
a195 1
	struct tree_node *q = *p;
d209 1
a209 1
tree_insert(struct tree_node **p, struct tree_key *key, struct state *state)
d250 1
a250 1
tree_remove(struct tree_node **p, struct tree_key *key)
d286 1
a286 1
			struct tree_node *p0 = *p;
d292 1
a292 1
			struct tree_node *p0 = *p;
d298 1
a298 1
			struct tree_node **qq = &(*p)->left;
d323 1
a323 1
find_state(struct tree_node *p, struct tree_key *key)
d477 1
a477 1
        pool_init(&pf_tree_pl, sizeof(struct tree_node), 0, 0, 0, "pftrpl",
@


1.23
log
@no point using a char here.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.22 2001/06/25 05:28:03 kjell Exp $ */
d100 1
a100 1
signed char	 tree_key_compare(struct tree_key *, struct tree_key *);
d146 1
a146 1
signed char
d253 1
a253 1
	signed char c;
@


1.22
log
@packetfilter -> pf in messages
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.21 2001/06/25 01:52:55 mickey Exp $ */
d325 1
a325 1
	signed char c;
@


1.21
log
@remove inlines they are plain wrong
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.20 2001/06/25 01:00:35 provos Exp $ */
d345 1
a345 1
		printf("packetfilter: ERROR! insert invalid\n");
d349 1
a349 1
			printf("packetfilter: ERROR! insert failed\n");
d358 1
a358 1
		printf("packetfilter: ERROR! insert invalid\n");
d362 1
a362 1
			printf("packetfilter: ERROR! insert failed\n");
d387 1
a387 1
				printf("packetfilter: ERROR! remove invalid\n");
d390 1
a390 1
				printf("packetfilter: ERROR! remove failed\n");
d397 1
a397 1
				printf("packetfilter: ERROR! remove invalid\n");
d400 1
a400 1
				printf("packetfilter: ERROR! remove failed\n");
d548 1
a548 1
			printf("packetfilter: started\n");
d557 1
a557 1
			printf("packetfilter: stopped\n");
d1018 1
a1018 1
		printf("packetfilter: @@%u", mnr);
d1157 1
a1157 1
		printf("packetfilter: @@%u", mnr);
d1264 1
a1264 1
		printf("packetfilter: @@%u", mnr);
d1416 1
a1416 1
			printf("packetfilter: BAD state: ");
d1551 1
a1551 1
			printf("packetfilter: ICMP error message too short\n");
d1569 1
a1569 1
				printf("packetfilter: "
d1591 1
a1591 1
				printf("packetfilter: BAD ICMP state: ");
d1625 1
a1625 2
				printf("packetfilter: "
				    "ICMP error message too short\n");
d1660 1
a1660 1
			printf("packetfilter: ICMP error message for bad proto\n");
d1682 1
a1682 1
		printf("packetfilter: assumption failed on header location");
d1691 1
a1691 1
			printf("packetfilter: dropping following fragment");
d1698 1
a1698 1
		printf("packetfilter: dropping short packet");
d1708 1
a1708 1
		printf("packetfilter: pullup proto header failed\n");
d1743 1
a1743 1
			printf("packetfilter: pullup ip header failed\n");
@


1.20
log
@do not drop unsupported protocol. default to pass. needs to be configurable
later.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.19 2001/06/25 00:14:57 niklas Exp $ */
d146 1
a146 1
inline signed char
d176 1
a176 1
inline void
d192 1
a192 1
inline void
d322 1
a322 1
inline struct state *
d413 1
a413 1
inline void
d764 1
a764 1
inline u_int16_t
d901 1
a901 1
inline int
d907 1
a907 1
inline int
@


1.19
log
@Some KNF, do not have a char fiel between pointers, it creates
padding.  Do not inline expensive functions, esp. not such declared after
first use.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.18 2001/06/25 00:02:54 dhartmei Exp $ */
d1791 1
a1791 3
		printf("packetfilter: dropping unsupported protocol");
		print_ip(ifp, h);
		action = PF_DROP;
@


1.18
log
@use only ioctl return values found in errno.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.17 2001/06/24 23:56:32 itojun Exp $ */
a67 1
	signed char		 balance;
d70 1
d100 45
a144 47
signed char	 tree_key_compare (struct tree_key *a, struct tree_key *b);
void		 tree_rotate_left (struct tree_node **p);
void		 tree_rotate_right (struct tree_node **p);
int		 tree_insert (struct tree_node **p, struct tree_key *key,
		    struct state *state);
int		 tree_remove (struct tree_node **p, struct tree_key *key);
struct state	*find_state (struct tree_node *p, struct tree_key *key);
void		 insert_state (struct state *state);
void		 purge_expired_states (void);
void		 print_ip (struct ifnet *ifp, struct ip *h);
void		 print_host (u_int32_t a, u_int16_t p);
void		 print_state (int direction, struct state *s);
void		 print_flags (u_int8_t f);
void		 pfattach (int num);
int		 pfopen (dev_t dev, int flags, int fmt, struct proc *p);
int		 pfclose (dev_t dev, int flags, int fmt, struct proc *p);
int		 pfioctl (dev_t dev, u_long cmd, caddr_t addr, int flags,
		    struct proc *p);
u_int16_t	 fix (u_int16_t cksum, u_int16_t old, u_int16_t new);
void		 change_ap (u_int32_t *a, u_int16_t *p, u_int16_t *ic, u_int16_t
		    *pc, u_int32_t an, u_int16_t pn);
void		 change_a (u_int32_t *a, u_int16_t *c, u_int32_t an);
void		 change_icmp (u_int32_t *ia, u_int16_t *ip, u_int32_t *oa,
		    u_int32_t na, u_int16_t np, u_int16_t *pc, u_int16_t *h2c,
		    u_int16_t *ic, u_int16_t *hc);
void		 send_reset (int direction, struct ifnet *ifp, struct ip *h,
		    int off, struct tcphdr *th);
int		 match_addr (u_int8_t n, u_int32_t a, u_int32_t m, u_int32_t b);
int		 match_port (u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p);
struct nat	*get_nat (struct ifnet *ifp, u_int8_t proto, u_int32_t addr);
struct rdr	*get_rdr (struct ifnet *ifp, u_int8_t proto, u_int32_t addr,
		    u_int16_t port);
int		 pf_test_tcp (int direction, struct ifnet *ifp, int,
		    struct ip *h, struct tcphdr *th);
int		 pf_test_udp (int direction, struct ifnet *ifp, int,
		    struct ip *h, struct udphdr *uh);
int		 pf_test_icmp (int direction, struct ifnet *ifp, int,
		    struct ip *h, struct icmp *ih);
struct state	*pf_test_state_tcp (int direction, struct ifnet *ifp,
		    struct mbuf **, int, struct ip *h, struct tcphdr *th);
struct state	*pf_test_state_udp (int direction, struct ifnet *ifp,
		    struct mbuf **, int, struct ip *h, struct udphdr *uh);
struct state	*pf_test_state_icmp (int direction, struct ifnet *ifp,
		    struct mbuf **, int, struct ip *h, struct icmp *ih);
inline void	*pull_hdr (struct ifnet *ifp, struct mbuf **m, int, int, int,
		    struct ip *h, int *action);
int		 pf_test (int direction, struct ifnet *ifp, struct mbuf **m);
d154 1
a154 1
		return -1;
d156 1
a156 1
		return  1;
d158 1
a158 1
		return -1;
d160 1
a160 1
		return  1;
d162 1
a162 1
		return -1;
d164 1
a164 1
		return  1;
d166 1
a166 1
		return -1;
d168 1
a168 1
		return  1;
d170 1
a170 1
		return -1;
d172 2
a173 2
		return  1;
	return 0;
d216 1
a216 1
			return 0;
d246 1
a246 1
	return deltaH;
d256 1
a256 1
		return 0;
d319 1
a319 1
	return deltaH;
d330 1
a330 1
	return p ? p->state : NULL;
d514 1
a514 1
		return EACCES;
d519 1
a519 1
			return EINVAL;
d522 1
a522 1
			return ENOMEM;
d525 1
a525 1
			return EIO;
d761 1
a761 1
	return error;
d770 1
a770 1
	return l ? l : 65535;
d904 1
a904 1
	return n == !((a & m) == (b & m));
d914 1
a914 1
		return p == a1;
d916 1
a916 1
		return p != a1;
d918 1
a918 1
		return p <  a1;
d920 1
a920 1
		return p <= a1;
d922 1
a922 1
		return p >  a1;
d924 1
a924 1
		return p >= a1;
d926 1
a926 1
	return 0; /* never reached */
d942 1
a942 1
	return nm;
d958 1
a958 1
	return rm;
d1043 1
a1043 1
		return PF_DROP;
d1047 1
a1047 1
		return PF_DROP;
d1057 1
a1057 1
			return PF_DROP;
d1102 1
a1102 1
	return PF_PASS;
d1169 1
a1169 1
		return PF_DROP;
d1179 1
a1179 1
			return PF_DROP;
d1224 1
a1224 1
	return PF_PASS;
d1277 1
a1277 1
		return PF_DROP;
d1289 1
a1289 1
			return PF_DROP;
d1321 1
a1321 1
	return PF_PASS;
d1424 1
a1424 1
		return s;
d1426 1
a1426 1
	return NULL;
d1484 1
a1484 1
		return s;
d1486 1
a1486 1
	return NULL;
d1533 1
a1533 1
			return s;
d1535 1
a1535 1
		return NULL;
d1552 1
a1552 1
			return NULL;
d1584 1
a1584 1
				return NULL;
d1595 1
a1595 1
				return NULL;
d1614 1
a1614 1
			return s;
d1639 1
a1639 1
				return NULL;
d1657 1
a1657 1
			return s;
d1662 1
a1662 1
			return NULL;
d1664 1
a1664 1
		return NULL;
d1673 1
a1673 1
inline void *
d1695 1
a1695 1
		return NULL;
d1701 1
a1701 1
		return NULL;
d1712 1
a1712 1
		return NULL;
d1714 1
a1714 1
	return mtod(n, char *) + newoff;
d1725 1
a1725 1
		return PF_PASS;
d1802 1
a1802 1
	return action;
@


1.17
log
@do not refer uninitialized var
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.16 2001/06/24 23:50:11 itojun Exp $ */
d521 1
a521 1
			return ERROR_INVALID_PARAMETERS;
d524 1
a524 1
			return ERROR_MALLOC;
d527 1
a527 1
			return ERROR_INVALID_PARAMETERS;
d543 1
a543 1
			error = ERROR_ALREADY_RUNNING;
d556 1
a556 1
			error = ERROR_NOT_RUNNING;
d576 1
a576 1
				error = ERROR_MALLOC;
d585 1
a585 1
					error = ERROR_INVALID_PARAMETERS;
d626 1
a626 1
				error = ERROR_MALLOC;
d633 1
a633 1
				error = ERROR_INVALID_PARAMETERS;
d669 1
a669 1
				error = ERROR_MALLOC;
d676 1
a676 1
				error = ERROR_INVALID_PARAMETERS;
d731 1
a731 1
			error = ERROR_INVALID_PARAMETERS;
d752 1
a752 1
		error = ERROR_INVALID_OP;
d760 1
a760 1
			error = ERROR_INVALID_PARAMETERS;
@


1.16
log
@printf string fix
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.15 2001/06/24 23:48:53 itojun Exp $ */
a1552 4
			printf("packetfilter: ICMP error message too short\n");
			return NULL;
		}
		if (len < off2) {
@


1.15
log
@remove assumption that protocol header follows the ip header.
always pass "off" around.

pull_hdr: remove asumption that ip header is on the top of mbuf.
we use pull_hdr on icmp payload (= original ip packet) parsing.

avoid mbuf overrun on icmp parsing.  never use pointer operations to get
the pointer to next header.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.14 2001/06/24 23:43:59 art Exp $ */
d1689 1
a1689 1
		printf("packetfilter: dropping following fragment");
@


1.14
log
@rename ioctlbuffer to pfioc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.13 2001/06/24 23:29:14 dhartmei Exp $ */
d126 1
a126 1
		    struct tcphdr *th);
d132 10
a141 10
int		 pf_test_tcp (int direction, struct ifnet *ifp, struct ip *h,
		    struct tcphdr *th);
int		 pf_test_udp (int direction, struct ifnet *ifp, struct ip *h,
		    struct udphdr *uh);
int		 pf_test_icmp (int direction, struct ifnet *ifp, struct ip *h,
		    struct icmp *ih);
struct state	*pf_test_state_tcp (int direction, struct ifnet *ifp, struct ip *h,
		    struct tcphdr *th);
struct state	*pf_test_state_udp (int direction, struct ifnet *ifp, struct ip *h,
		    struct udphdr *uh);
d143 3
a145 3
		    struct ip *h, struct icmp *ih);
void		*pull_hdr (struct ifnet *ifp, struct mbuf **m, struct ip *h,
		    int off, int *action, u_int8_t len);
d818 2
a819 1
send_reset(int direction, struct ifnet *ifp, struct ip *h, struct tcphdr *th)
d854 1
a854 1
		int tlen = h->ip_len - ((h->ip_hl + th->th_off) << 2) +
d964 2
a965 1
pf_test_tcp(int direction, struct ifnet *ifp, struct ip *h, struct tcphdr *th)
d1018 1
a1018 1
		u_int16_t len = h->ip_len - ((h->ip_hl + th->th_off) << 2);
d1044 1
a1044 1
		send_reset(direction, ifp, h, th);
d1056 1
a1056 1
		len = h->ip_len - ((h->ip_hl + th->th_off) << 2);
d1108 2
a1109 1
pf_test_udp(int direction, struct ifnet *ifp, struct ip *h, struct udphdr *uh)
d1178 1
a1178 1
		len = h->ip_len - (h->ip_hl << 2) - 8;
d1230 2
a1231 1
pf_test_icmp(int direction, struct ifnet *ifp, struct ip *h, struct icmp *ih)
d1287 1
a1287 1
		len = h->ip_len - (h->ip_hl << 2) - 8;
d1327 2
a1328 1
pf_test_state_tcp(int direction, struct ifnet *ifp, struct ip *h, struct tcphdr *th)
d1341 1
a1341 1
		u_int16_t len = h->ip_len - ((h->ip_hl + th->th_off) << 2);
d1432 2
a1433 1
pf_test_state_udp(int direction, struct ifnet *ifp, struct ip *h, struct udphdr *uh)
d1447 1
a1447 1
		u_int16_t len = h->ip_len - (h->ip_hl << 2) - 8;
d1492 2
a1493 1
pf_test_state_icmp(int direction, struct ifnet *ifp, struct ip *h, struct icmp *ih)
d1495 1
a1495 1
	u_int16_t len = h->ip_len - (h->ip_hl << 2) - 8;
d1546 11
a1556 2
		struct ip *h2 = (struct ip *)(((char *)ih) + 8);
		if (len < 28) {
d1560 4
d1566 2
a1567 2
			struct tcphdr *th = (struct tcphdr *)(((char *)h2) + 20);
			u_int32_t seq = ntohl(th->th_seq);
d1572 9
d1624 1
a1624 1
			struct udphdr *uh = (struct udphdr *)(((char *)h2) + 20);
d1628 8
d1675 4
d1680 2
a1681 2
pull_hdr(struct ifnet *ifp, struct mbuf **m, struct ip *h, int off, int *action,
    u_int8_t len)
d1687 6
d1703 1
a1703 1
	if ((*m)->m_pkthdr.len < off + len || h->ip_len < off + len) {
d1758 2
a1759 2
		struct tcphdr *th = pull_hdr(ifp, m, h, off, &action,
		    sizeof(*th));
d1763 1
a1763 1
		if (pf_test_state_tcp(direction, ifp, h, th))
d1766 1
a1766 1
			action = pf_test_tcp(direction, ifp, h, th);
d1771 2
a1772 2
		struct udphdr *uh = pull_hdr(ifp, m, h, off, &action,
		    sizeof(*uh));
d1776 1
a1776 1
		if (pf_test_state_udp(direction, ifp, h, uh))
d1779 1
a1779 1
			action = pf_test_udp(direction, ifp, h, uh);
d1784 2
a1785 2
		struct icmp *ih = pull_hdr(ifp, m, h, off, &action,
		    sizeof(*ih));
d1789 1
a1789 1
		if (pf_test_state_icmp(direction, ifp, h, ih))
d1792 1
a1792 1
			action = pf_test_icmp(direction, ifp, h, ih);
@


1.13
log
@u_long/u_short and memcpy/memset changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.12 2001/06/24 23:26:14 art Exp $ */
d511 1
a511 1
	struct ioctlbuffer *ub;
d519 1
a519 1
		ub = (struct ioctlbuffer *)addr;
@


1.12
log
@fix error returns from open and close
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.11 2001/06/24 23:10:23 deraadt Exp $ */
d118 1
a118 1
u_short		 fix (u_short cksum, u_short old, u_short new);
d220 1
a220 1
		memcpy(&(*p)->key, key, sizeof(struct tree_key));
d304 1
a304 1
			memcpy(&(*p)->key, &(*qq)->key, sizeof(struct tree_key));
d306 1
a306 1
			memcpy(&(*qq)->key, key, sizeof(struct tree_key));
d546 1
a546 1
			memset(&status, 0, sizeof(struct status));
d579 1
a579 1
			memcpy(rule, rules + n, sizeof(struct rule));
d604 1
a604 1
			memcpy(rules + n, rule, sizeof(struct rule));
d629 1
a629 1
			memcpy(nat, nats + n, sizeof(struct nat));
d647 1
a647 1
			memcpy(nats + n, nat, sizeof(struct nat));
d672 1
a672 1
			memcpy(rdr, rdrs + n, sizeof(struct rdr));
d690 1
a690 1
			memcpy(rdrs + n, rdr, sizeof(struct rdr));
d714 1
a714 1
			memcpy(states + n, state, sizeof(struct state));
d741 1
a741 1
		memcpy(st, &status, sizeof(struct status));
d744 1
a744 1
		memset(&status, 0, sizeof(struct status));
d766 2
a767 2
inline u_short
fix(u_short cksum, u_short old, u_short new)
d769 1
a769 1
	u_long l = cksum + old - new;
@


1.11
log
@more attempts at cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.10 2001/06/24 22:42:18 art Exp $ */
d495 2
a496 2
		return ENXIO;
	return NO_ERROR;
d503 2
a504 2
		return ENXIO;
	return NO_ERROR;
d510 1
a510 1
	int error = NO_ERROR;
@


1.10
log
@Use pool for state, tree, nat, rdr, etc.
Remove some unnecessary printfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.9 2001/06/24 22:12:05 deraadt Exp $ */
d329 1
a329 1
	while ((p != NULL) && (c = tree_key_compare(&p->key, key)))
d836 1
a836 1
	bzero((caddr_t)m->m_data, len);
d880 1
a880 1
		bzero((caddr_t)ro, sizeof(*ro));
d934 4
a937 3
	while ((n != NULL) && (nm == NULL)) {
		if ((n->ifp == ifp) &&
		    (!n->proto || (n->proto == proto)) &&
d950 3
a952 3
	while ((r != NULL) && (rm == NULL)) {
		if ((r->ifp == ifp) &&
		    (!r->proto || (r->proto == proto)) &&
d954 1
a954 1
		    (r->dport == port))
d974 2
a975 1
		if ((nat = get_nat(ifp, IPPROTO_TCP, h->ip_src.s_addr)) != NULL) {
d993 3
a995 3
		if ((r->direction == direction) &&
		    ((r->ifp == NULL) || (r->ifp == ifp)) &&
		    (!r->proto || (r->proto == IPPROTO_TCP)) &&
d1017 1
d1019 2
a1020 2
		printf(" %s %s", rm->action ? "block" : "pass", direction ? "in" :
		    "out");
d1155 1
a1155 1
	if ((rm != NULL) && rm->log) {
d1167 1
a1167 1
	if ((rm != NULL) && (rm->action != PF_PASS))
d1170 1
a1170 1
	if (((rm != NULL) && rm->keep_state) || (nat != NULL) || (rdr != NULL)) {
d1261 1
a1261 1
	if ((rm != NULL) && rm->log) {
d1274 1
a1274 1
	if ((rm != NULL) && (rm->action != PF_PASS))
d1277 1
a1277 1
	if (((rm != NULL) && rm->keep_state) || (nat != NULL)) {
d1349 3
a1351 3
		if ((th->th_flags == TH_RST) && !ack && !len &&
		    ((seq == src->seqhi) || (seq == src->seqhi-1)) &&
		    (src->state >= 4) && (dst->state >= 3))
d1370 1
a1370 1
			} else if ((seq + len) - src->seqhi < 65536)
d1380 1
a1380 1
			if ((th->th_flags & TH_ACK) && (ack == dst->seqhi)) {
d1390 1
a1390 1
			if ((src->state >= 4) && (dst->state >= 4))
d1392 1
a1392 1
			else if ((src->state >= 3) || (dst->state >= 3))
d1394 1
a1394 1
			else if ((src->state < 2) || (dst->state < 2))
d1400 2
a1401 2
			if ((s->lan.addr != s->gwy.addr)
			    || (s->lan.port != s->gwy.port)) {
d1462 1
a1462 1
		if ((src->state == 2) && (dst->state == 2))
d1468 2
a1469 2
		if ((s->lan.addr != s->gwy.addr)
		    || (s->lan.port != s->gwy.port)) {
d1490 5
a1494 5
	if ((ih->icmp_type != ICMP_UNREACH) &&
	    (ih->icmp_type != ICMP_SOURCEQUENCH) &&
	    (ih->icmp_type != ICMP_REDIRECT) &&
	    (ih->icmp_type != ICMP_TIMXCEED) &&
	    (ih->icmp_type != ICMP_PARAMPROB)) {
d1575 2
a1576 2
			if ((s->lan.addr != s->gwy.addr) ||
			    (s->lan.port != s->gwy.port)) {
d1605 1
a1605 1
			s = find_state((direction == PF_IN) ? tree_ext_gwy :
d1610 2
a1611 2
			if ((s->lan.addr != s->gwy.addr) ||
			    (s->lan.port != s->gwy.port)) {
d1693 1
a1693 1
	if ((pftv.tv_sec - last_purge) >= 10) {
@


1.9
log
@more cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.8 2001/06/24 21:50:29 deraadt Exp $ */
d42 1
d90 6
d216 1
a216 1
		*p = malloc(sizeof(struct tree_node), M_DEVBUF, M_NOWAIT);
a217 1
			printf("packetfilter: malloc() failed\n");
d289 1
d291 1
a291 1
			free(p0, M_DEVBUF);
d295 1
d297 1
a297 1
			free(p0, M_DEVBUF);
d301 1
d404 1
a404 1
			free(cur, M_DEVBUF);
d478 11
a488 2
	memset(&status, 0, sizeof(struct status));
	printf("packetfilter: attached\n");
d568 1
a568 1
			free(rulehead, M_DEVBUF);
d573 2
a574 1
			rule = malloc(sizeof(struct rule), M_DEVBUF, M_NOWAIT);
d584 1
a584 1
					free(rule, M_DEVBUF);
d617 2
a618 1
			free(nathead, M_DEVBUF);
d623 2
a624 1
			nat = malloc(sizeof(struct nat), M_DEVBUF, M_NOWAIT);
d632 1
a632 1
				free(nat, M_DEVBUF);
d660 2
a661 1
			free(rdrhead, M_DEVBUF);
d666 2
a667 1
			rdr = malloc(sizeof(struct rdr), M_DEVBUF, M_NOWAIT);
d675 1
a675 1
				free(rdr, M_DEVBUF);
d1048 5
a1052 2
		u_int16_t len = h->ip_len - ((h->ip_hl + th->th_off) << 2);
		struct state *s = malloc(sizeof(struct state), M_DEVBUF, M_NOWAIT);
a1053 1
			printf("packetfilter: malloc() failed\n");
d1169 2
a1170 3
		u_int16_t len = h->ip_len - (h->ip_hl << 2) - 8;
		struct state *s = malloc(sizeof(struct state),
		    M_DEVBUF, M_NOWAIT);
d1172 2
a1174 1
			printf("packetfilter: malloc() failed\n");
d1276 7
a1282 3
		u_int16_t len = h->ip_len - (h->ip_hl << 2) - 8;
		u_int16_t id = ih->icmp_hun.ih_idseq.icd_id;
		struct state *s = malloc(sizeof(struct state), M_DEVBUF, M_NOWAIT);
a1283 1
			printf("packetfilter: malloc() failed\n");
@


1.8
log
@pack structures better; dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.7 2001/06/24 21:29:29 dhartmei Exp $ */
a61 1
		u_int8_t	 proto;
d64 1
d68 2
a69 2
	struct tree_node	*left,
				*right;
d76 6
a81 7
struct rule		*rulehead = NULL;
struct nat		*nathead = NULL;
struct rdr		*rdrhead = NULL;
struct state		*statehead = NULL;
struct tree_node	*tree_lan_ext = NULL,
			*tree_ext_gwy = NULL;
struct timeval		 tv;
d83 2
a84 1
struct ifnet		*status_ifp = NULL;
d86 2
a87 2
u_int16_t		 next_port_tcp = 50001,
			 next_port_udp = 50001;
a140 2
/* ------------------------------------------------------------------------ */

d175 1
d191 1
d207 1
d250 1
d370 1
d372 1
a372 1
		if (cur->expire <= tv.tv_sec) {
a405 2
/* ------------------------------------------------------------------------ */

d417 6
a422 3
	if (h->ip_off & IP_RF) printf(" RF");
	if (h->ip_off & IP_DF) printf(" DF");
	if (h->ip_off & IP_MF) printf(" MF");
d450 14
a463 7
	if (f) printf(" ");
	if (f & TH_FIN ) printf("F");
	if (f & TH_SYN ) printf("S");
	if (f & TH_RST ) printf("R");
	if (f & TH_PUSH) printf("P");
	if (f & TH_ACK ) printf("A");
	if (f & TH_URG ) printf("U");
a465 2
/* ------------------------------------------------------------------------ */

a472 2
/* ------------------------------------------------------------------------ */

a480 2
/* ------------------------------------------------------------------------ */

a488 2
/* ------------------------------------------------------------------------ */

d515 2
a516 2
	microtime(&tv);
	if (tv.tv_sec - last_purge >= 10) {
d518 1
a518 1
		last_purge = tv.tv_sec;
d531 1
a531 1
			status.since = tv.tv_sec;
d692 2
a693 2
			states[n].creation = tv.tv_sec - states[n].creation;
			if (states[n].expire <= tv.tv_sec)
d696 1
a696 1
				states[n].expire -= tv.tv_sec;
d719 1
a719 1
		st->since = st->since ? tv.tv_sec - st->since : 0;
d724 1
a724 1
		status.since = tv.tv_sec;
a742 2
/* ------------------------------------------------------------------------ */

a793 2
/* ------------------------------------------------------------------------ */

a878 2
/* ------------------------------------------------------------------------ */

a906 2
/* ------------------------------------------------------------------------ */

a937 2
/* ------------------------------------------------------------------------ */

d1003 2
a1004 1
		if (th->th_ack) printf(" ack=%lu", ntohl(th->th_ack));
d1067 2
a1068 2
		s->creation	= tv.tv_sec;
		s->expire	= tv.tv_sec + 60;
d1145 3
a1147 1
		struct state *s = malloc(sizeof(struct state), M_DEVBUF, M_NOWAIT);
d1188 2
a1189 2
		s->creation	= tv.tv_sec;
		s->expire	= tv.tv_sec + 30;
d1281 2
a1282 2
		s->creation	= tv.tv_sec;
		s->expire	= tv.tv_sec + 20;
a1290 2
/* ------------------------------------------------------------------------ */

d1360 1
a1360 1
				s->expire = tv.tv_sec + 5;
d1362 1
a1362 1
				s->expire = tv.tv_sec + 300;
d1364 1
a1364 1
				s->expire = tv.tv_sec + 30;
d1366 1
a1366 1
				s->expire = tv.tv_sec + 24*60*60;
d1432 1
a1432 1
			s->expire = tv.tv_sec + 60;
d1434 1
a1434 1
			s->expire = tv.tv_sec + 20;
d1485 1
a1485 1
			s->expire = tv.tv_sec + 10;
a1606 2
/* ------------------------------------------------------------------------ */

d1661 2
a1662 2
	microtime(&tv);
	if ((tv.tv_sec - last_purge) >= 10) {
d1664 1
a1664 1
		last_purge = tv.tv_sec;
d1682 1
d1695 1
d1708 1
a1731 3

/* ------------------------------------------------------------------------ */

@


1.7
log
@REGENTS? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.6 2001/06/24 21:16:02 itojun Exp $ */
d150 20
a169 10
	if (a->proto   < b->proto  ) return -1;
	if (a->proto   > b->proto  ) return  1;
	if (a->addr[0] < b->addr[0]) return -1;
	if (a->addr[0] > b->addr[0]) return  1;
	if (a->addr[1] < b->addr[1]) return -1;
	if (a->addr[1] > b->addr[1]) return  1;
	if (a->port[0] < b->port[0]) return -1;
	if (a->port[0] > b->port[0]) return  1;
	if (a->port[1] < b->port[1]) return -1;
	if (a->port[1] > b->port[1]) return  1;
d317 1
d892 14
a905 7
		case 1: return (p >= a1) && (p <= a2);
		case 2: return p == a1;
		case 3: return p != a1;
		case 4: return p <  a1;
		case 5: return p <= a1;
		case 6: return p >  a1;
		case 7: return p >= a1;
a1310 1

d1313 1
a1314 1
		struct peer *src, *dst;
d1418 1
a1418 1
		struct peer *src, *dst;
d1525 1
a1525 1
			struct peer *src;
@


1.6
log
@on pull_hdr(), check short m->m_pkthdr.len.  fix mesasge (it's not the first
fragment, it's too short packet)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.5 2001/06/24 21:10:24 itojun Exp $ */
d22 1
a22 1
 * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
@


1.5
log
@backout m_copydata portion.  NAT code assumes that they can touch the mbuf
directly.  use m_pulldown instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1 2001/06/24 19:48:58 kjell Exp $ */
d1616 1
a1616 1
	if ((h->ip_len - off) < len) {
d1618 1
a1618 1
		printf("packetfilter: dropping first fragment");
@


1.4
log
@pull_hdr() now takes header offset explicitly, to help header chain parsing
(v6, ipsec)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.3 2001/06/24 20:49:40 itojun Exp $ */
d138 1
a138 1
		    int, int *action, u_int8_t len, void *);
d1599 2
a1600 2
pull_hdr(struct ifnet *ifp, struct mbuf **m, struct ip *h, int off,
    int *action, u_int8_t len, void *header)
d1603 2
d1622 7
a1628 1
	if (off + len > (*m)->m_pkthdr.len) {
d1630 1
d1633 1
a1633 2
	m_copydata(*m, off, len, header);
	return header;
d1646 5
a1657 5
#ifdef DIAGNOSTIC
	if (((*m)->m_flags & M_PKTHDR) == 0)
		panic("pf_test called with non-header mbuf");
#endif

d1671 3
a1673 2
		struct tcphdr th;
		if (pull_hdr(ifp, m, h, off, &action, 20, &th) == NULL)
d1675 1
a1675 1
		if (pf_test_state_tcp(direction, ifp, h, &th))
d1678 1
a1678 1
			action = pf_test_tcp(direction, ifp, h, &th);
d1683 3
a1685 2
		struct udphdr uh;
		if (pull_hdr(ifp, m, h, off, &action, 8, &uh) == NULL)
d1687 1
a1687 1
		if (pf_test_state_udp(direction, ifp, h, &uh))
d1690 1
a1690 1
			action = pf_test_udp(direction, ifp, h, &uh);
d1695 3
a1697 2
		struct icmp ih;
		if (pull_hdr(ifp, m, h, off, &action, 8, &ih) == NULL)
d1699 1
a1699 1
		if (pf_test_state_icmp(direction, ifp, h, &ih))
d1702 1
a1702 1
			action = pf_test_icmp(direction, ifp, h, &ih);
@


1.3
log
@drop if packet is too short
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.2 2001/06/24 20:47:37 itojun Exp $ */
d138 1
a138 1
		    int *action, u_int8_t len, void *);
d1599 2
a1600 2
pull_hdr(struct ifnet *ifp, struct mbuf **m, struct ip *h, int *action,
    u_int8_t len, void *header)
d1602 1
a1602 2
	u_int16_t hl = h->ip_hl << 2;
	u_int16_t off = (h->ip_off & IP_OFFMASK) << 3;
d1604 2
a1605 2
	if (off) {
		if (off >= len)
d1614 1
a1614 1
	if ((h->ip_len - hl) < len) {
d1620 1
a1620 1
	if (hl + len > (*m)->m_pkthdr.len) {
d1624 1
a1624 1
	m_copydata(*m, hl, len, header);
d1633 1
d1650 2
d1653 2
a1654 2
	if ((*m)->m_len < (h->ip_hl << 2))
		if ((*m = m_pullup(*m, h->ip_hl << 2)) == NULL) {
d1664 1
a1664 1
		if (pull_hdr(ifp, m, h, &action, 20, &th) == NULL)
d1675 1
a1675 1
		if (pull_hdr(ifp, m, h, &action, 8, &uh) == NULL)
d1686 1
a1686 1
		if (pull_hdr(ifp, m, h, &action, 8, &ih) == NULL)
@


1.2
log
@check M_PKTHDR (DIAGNOSTIC)
avoid m_pullup for headers other than IPv4 header itself (will be critical
for IPv6 and and chained headers like headers after AH).  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.1 2001/06/24 19:48:58 kjell Exp $ */
d1621 2
a1622 1
	if (hl + len > (*m)->m_pkthdr.len)
d1624 1
@


1.1
log
@Initial import of pf, an all-new ipf-compatable packet filter.
Insane amounts of work done my dhartmei. Great work!
@
text
@d1 1
a1 1
/*	$OpenBSD: packetfilter.c,v 1.20 2001/06/23 20:11:00 dhartmei Exp $ */
d138 1
a138 1
		    int *action, u_int8_t len);
d1600 1
a1600 1
    u_int8_t len)
d1604 1
d1621 4
a1624 7
	if ((*m)->m_len < (hl + len))
		if ((*m = m_pullup(*m, hl + len)) == NULL) {
			printf("packetfilter: pullup proto header failed\n");
			*action = PF_DROP;
			return NULL;
		}
	return mtod(*m, char *) + hl;
d1643 5
d1659 2
a1660 2
		struct tcphdr *th = pull_hdr(ifp, m, h, &action, 20);
		if (th == NULL)
d1662 1
a1662 1
		if (pf_test_state_tcp(direction, ifp, h, th))
d1665 1
a1665 1
			action = pf_test_tcp(direction, ifp, h, th);
d1670 2
a1671 2
		struct udphdr *uh = pull_hdr(ifp, m, h, &action, 8);
		if (uh == NULL)
d1673 1
a1673 1
		if (pf_test_state_udp(direction, ifp, h, uh))
d1676 1
a1676 1
			action = pf_test_udp(direction, ifp, h, uh);
d1681 2
a1682 2
		struct icmp *ih = pull_hdr(ifp, m, h, &action, 8);
		if (ih == NULL)
d1684 1
a1684 1
		if (pf_test_state_icmp(direction, ifp, h, ih))
d1687 1
a1687 1
			action = pf_test_icmp(direction, ifp, h, ih);
@

