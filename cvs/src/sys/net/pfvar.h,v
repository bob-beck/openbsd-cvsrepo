head	1.457;
access;
symbols
	OPENBSD_6_1:1.450.0.4
	OPENBSD_6_1_BASE:1.450
	OPENBSD_6_0:1.434.0.4
	OPENBSD_6_0_BASE:1.434
	OPENBSD_5_9:1.430.0.2
	OPENBSD_5_9_BASE:1.430
	OPENBSD_5_8:1.419.0.4
	OPENBSD_5_8_BASE:1.419
	OPENBSD_5_7:1.413.0.2
	OPENBSD_5_7_BASE:1.413
	OPENBSD_5_6:1.401.0.4
	OPENBSD_5_6_BASE:1.401
	OPENBSD_5_5:1.397.0.4
	OPENBSD_5_5_BASE:1.397
	OPENBSD_5_4:1.389.0.2
	OPENBSD_5_4_BASE:1.389
	OPENBSD_5_3:1.376.0.2
	OPENBSD_5_3_BASE:1.376
	OPENBSD_5_2:1.366.0.2
	OPENBSD_5_2_BASE:1.366
	OPENBSD_5_1_BASE:1.362
	OPENBSD_5_1:1.362.0.2
	OPENBSD_5_0:1.343.0.2
	OPENBSD_5_0_BASE:1.343
	OPENBSD_4_9:1.320.0.2
	OPENBSD_4_9_BASE:1.320
	OPENBSD_4_8:1.311.0.2
	OPENBSD_4_8_BASE:1.311
	OPENBSD_4_7:1.307.0.2
	OPENBSD_4_7_BASE:1.307
	OPENBSD_4_6:1.290.0.4
	OPENBSD_4_6_BASE:1.290
	OPENBSD_4_5:1.283.0.2
	OPENBSD_4_5_BASE:1.283
	OPENBSD_4_4:1.276.0.2
	OPENBSD_4_4_BASE:1.276
	OPENBSD_4_3:1.259.0.2
	OPENBSD_4_3_BASE:1.259
	OPENBSD_4_2:1.254.0.2
	OPENBSD_4_2_BASE:1.254
	OPENBSD_4_1:1.244.0.2
	OPENBSD_4_1_BASE:1.244
	OPENBSD_4_0:1.236.0.2
	OPENBSD_4_0_BASE:1.236
	OPENBSD_3_9:1.233.0.2
	OPENBSD_3_9_BASE:1.233
	OPENBSD_3_8:1.229.0.2
	OPENBSD_3_8_BASE:1.229
	OPENBSD_3_7:1.213.0.2
	OPENBSD_3_7_BASE:1.213
	OPENBSD_3_6:1.202.0.2
	OPENBSD_3_6_BASE:1.202
	SMP_SYNC_A:1.196
	SMP_SYNC_B:1.195
	OPENBSD_3_5:1.187.0.2
	OPENBSD_3_5_BASE:1.187
	OPENBSD_3_4:1.170.0.2
	OPENBSD_3_4_BASE:1.170
	UBC_SYNC_A:1.152
	OPENBSD_3_3:1.136.0.2
	OPENBSD_3_3_BASE:1.136
	OPENBSD_3_2:1.89.0.2
	OPENBSD_3_2_BASE:1.89
	OPENBSD_3_1:1.66.0.2
	OPENBSD_3_1_BASE:1.66
	UBC_SYNC_B:1.100
	UBC:1.58.0.2
	UBC_BASE:1.58
	OPENBSD_3_0:1.54.0.2
	OPENBSD_3_0_BASE:1.54
	SMP:1.28.0.2;
locks; strict;
comment	@ * @;


1.457
date	2017.05.30.19.40.54;	author henning;	state Exp;
branches;
next	1.456;
commitid	SkcuZLctRxWo2Nfu;

1.456
date	2017.05.30.19.37.54;	author henning;	state Exp;
branches;
next	1.455;
commitid	TZX21WHCToJLlT7I;

1.455
date	2017.05.30.08.10.01;	author henning;	state Exp;
branches;
next	1.454;
commitid	GYgDkoLPhuNZoaW6;

1.454
date	2017.05.28.16.43.45;	author bluhm;	state Exp;
branches;
next	1.453;
commitid	2nvtDSXE6XBBUlgS;

1.453
date	2017.05.15.12.26.00;	author mpi;	state Exp;
branches;
next	1.452;
commitid	WMZaI3vIHNC1J8ol;

1.452
date	2017.05.15.11.23.25;	author mikeb;	state Exp;
branches;
next	1.451;
commitid	MV7SeE82QLGXQJBO;

1.451
date	2017.05.02.12.27.37;	author mikeb;	state Exp;
branches;
next	1.450;
commitid	rOAHa272RNs62JfW;

1.450
date	2017.03.17.17.19.17;	author mpi;	state Exp;
branches;
next	1.449;
commitid	CxqvXOMqotM60GAI;

1.449
date	2017.02.22.16.12.12;	author mpi;	state Exp;
branches;
next	1.448;
commitid	hC9Ip17kRQ7AHhW7;

1.448
date	2017.01.30.17.41.34;	author benno;	state Exp;
branches;
next	1.447;
commitid	jxfz0zamCXSbKEUx;

1.447
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.446;
commitid	6c6qq5OdS4VVnyVM;

1.446
date	2016.12.29.13.01.48;	author bluhm;	state Exp;
branches;
next	1.445;
commitid	niqDyzVo4a11cYNV;

1.445
date	2016.11.22.19.29.54;	author procter;	state Exp;
branches;
next	1.444;
commitid	Wwno1dT3ILCyVgb1;

1.444
date	2016.11.14.13.25.01;	author bluhm;	state Exp;
branches;
next	1.443;
commitid	B8d5g57KBGx1yYQP;

1.443
date	2016.10.27.21.41.20;	author bluhm;	state Exp;
branches;
next	1.442;
commitid	RZerTDpaYI8sgJZ6;

1.442
date	2016.10.26.21.07.22;	author bluhm;	state Exp;
branches;
next	1.441;
commitid	aaKAr0kv3QWNHoVo;

1.441
date	2016.10.18.13.28.01;	author henning;	state Exp;
branches;
next	1.440;
commitid	E0MSCxfVE1cKcqjo;

1.440
date	2016.09.27.04.57.17;	author dlg;	state Exp;
branches;
next	1.439;
commitid	irzdR7hwk1GHVaEu;

1.439
date	2016.09.27.02.51.12;	author dlg;	state Exp;
branches;
next	1.438;
commitid	bZuzILta8BoFCDiT;

1.438
date	2016.09.03.17.11.40;	author sashan;	state Exp;
branches;
next	1.437;
commitid	JAk2J5vzbGC5EyfM;

1.437
date	2016.09.03.14.34.13;	author bluhm;	state Exp;
branches;
next	1.436;
commitid	fHiu9tHFVSDnxj0u;

1.436
date	2016.08.20.08.34.30;	author procter;	state Exp;
branches;
next	1.435;
commitid	zLszZ8lmZ7zIfSnw;

1.435
date	2016.08.17.03.24.12;	author procter;	state Exp;
branches;
next	1.434;
commitid	NB7EODatRadIbwDM;

1.434
date	2016.07.19.13.30.51;	author henning;	state Exp;
branches;
next	1.433;
commitid	lJXg4BoRhsrygvYM;

1.433
date	2016.07.18.19.11.18;	author henning;	state Exp;
branches;
next	1.432;
commitid	eQpjIFzeyzGKCU43;

1.432
date	2016.07.18.13.17.44;	author bluhm;	state Exp;
branches;
next	1.431;
commitid	LlSukCQvQcHux9Yv;

1.431
date	2016.03.29.10.34.42;	author sashan;	state Exp;
branches;
next	1.430;
commitid	3oT5Q5z024mhykOL;

1.430
date	2016.01.31.00.18.07;	author sashan;	state Exp;
branches;
next	1.429;
commitid	XnM42P9Sq7TQR88T;

1.429
date	2016.01.07.22.23.13;	author sashan;	state Exp;
branches;
next	1.428;
commitid	uGcSilygSiLkUqPZ;

1.428
date	2015.12.23.21.04.55;	author jasper;	state Exp;
branches;
next	1.427;
commitid	fJOVhuW2zBjxPtee;

1.427
date	2015.12.22.13.33.26;	author sashan;	state Exp;
branches;
next	1.426;
commitid	oBRhtWcDV0ThviVT;

1.426
date	2015.12.03.14.05.28;	author bluhm;	state Exp;
branches;
next	1.425;
commitid	Qo1JIwCdJHaA2LFI;

1.425
date	2015.12.03.09.49.15;	author bluhm;	state Exp;
branches;
next	1.424;
commitid	6HkfIaw2ROsrfw1Q;

1.424
date	2015.12.02.16.00.42;	author sashan;	state Exp;
branches;
next	1.423;
commitid	uojPT94sS2Q9I95I;

1.423
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.422;
commitid	eYnPulzvLjDImPCa;

1.422
date	2015.10.30.11.33.55;	author mikeb;	state Exp;
branches;
next	1.421;
commitid	b90TPnSXmdusuD88;

1.421
date	2015.10.13.19.32.32;	author sashan;	state Exp;
branches;
next	1.420;
commitid	2CkJMFIEZK18G5IB;

1.420
date	2015.08.19.21.22.41;	author sashan;	state Exp;
branches;
next	1.419;
commitid	YGKggp2X8s4irKok;

1.419
date	2015.07.20.01.18.33;	author mcbride;	state Exp;
branches;
next	1.418;
commitid	vUhxln3IyKWnKmPF;

1.418
date	2015.07.19.01.58.19;	author sashan;	state Exp;
branches;
next	1.417;
commitid	c3fH8E2IvSIMTGY0;

1.417
date	2015.07.17.19.46.05;	author sashan;	state Exp;
branches;
next	1.416;
commitid	iJrcFATGGqEdEcit;

1.416
date	2015.07.16.21.14.21;	author mpi;	state Exp;
branches;
next	1.415;
commitid	VGPlklxThaST7mIm;

1.415
date	2015.06.05.13.22.34;	author mikeb;	state Exp;
branches;
next	1.414;
commitid	OE0CVnFL4x2RZU75;

1.414
date	2015.04.11.13.00.12;	author dlg;	state Exp;
branches;
next	1.413;
commitid	uT17hi9tQuyDqgaw;

1.413
date	2015.02.15.10.40.53;	author sthen;	state Exp;
branches;
next	1.412;
commitid	OpoITiuX3vpRh3Pp;

1.412
date	2015.02.12.01.24.10;	author henning;	state Exp;
branches;
next	1.411;
commitid	9O1PirN7lXfubwO8;

1.411
date	2015.02.10.09.28.40;	author henning;	state Exp;
branches;
next	1.410;
commitid	UCQxCe3lrdmzEpqK;

1.410
date	2015.02.10.06.45.55;	author henning;	state Exp;
branches;
next	1.409;
commitid	eD7tXFa7upGCZ3zN;

1.409
date	2015.02.07.06.27.46;	author pelikan;	state Exp;
branches;
next	1.408;
commitid	sJbPAXjql41rCF3R;

1.408
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.407;
commitid	VK3ncyiP3NS1N4Sy;

1.407
date	2015.01.15.23.56.58;	author deraadt;	state Exp;
branches;
next	1.406;
commitid	84OjHwikwLMXYbE9;

1.406
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.405;
commitid	PYnSnAqgemmk34E3;

1.405
date	2014.12.19.13.04.08;	author reyk;	state Exp;
branches;
next	1.404;
commitid	ctnssYdFDfym7i2Z;

1.404
date	2014.12.19.05.36.28;	author tedu;	state Exp;
branches;
next	1.403;
commitid	FclwmuvOyWeTJgyk;

1.403
date	2014.09.08.18.10.01;	author bluhm;	state Exp;
branches;
next	1.402;
commitid	tdFK7WByUuQ5GiDs;

1.402
date	2014.08.12.15.29.33;	author mikeb;	state Exp;
branches;
next	1.401;
commitid	VQXfMjKroH5JkPuJ;

1.401
date	2014.07.02.13.02.08;	author mikeb;	state Exp;
branches;
next	1.400;
commitid	kDJuJfsejT8omMVZ;

1.400
date	2014.06.25.16.21.20;	author mikeb;	state Exp;
branches;
next	1.399;
commitid	jAxcy0jCm4KoeB0n;

1.399
date	2014.04.22.14.41.03;	author mpi;	state Exp;
branches;
next	1.398;

1.398
date	2014.04.19.12.59.53;	author henning;	state Exp;
branches;
next	1.397;

1.397
date	2014.01.21.01.50.07;	author henning;	state Exp;
branches;
next	1.396;

1.396
date	2014.01.20.02.57.50;	author henning;	state Exp;
branches;
next	1.395;

1.395
date	2014.01.03.12.48.58;	author pelikan;	state Exp;
branches;
next	1.394;

1.394
date	2014.01.03.12.43.09;	author pelikan;	state Exp;
branches;
next	1.393;

1.393
date	2013.12.22.16.49.29;	author deraadt;	state Exp;
branches;
next	1.392;

1.392
date	2013.11.19.17.30.08;	author mikeb;	state Exp;
branches;
next	1.391;

1.391
date	2013.10.12.12.13.11;	author henning;	state Exp;
branches;
next	1.390;

1.390
date	2013.10.12.11.55.46;	author henning;	state Exp;
branches;
next	1.389;

1.389
date	2013.07.23.22.47.10;	author bluhm;	state Exp;
branches;
next	1.388;

1.388
date	2013.07.05.13.07.58;	author blambert;	state Exp;
branches;
next	1.387;

1.387
date	2013.07.04.00.19.01;	author guenther;	state Exp;
branches;
next	1.386;

1.386
date	2013.07.02.05.57.37;	author guenther;	state Exp;
branches;
next	1.385;

1.385
date	2013.07.02.01.42.01;	author guenther;	state Exp;
branches;
next	1.384;

1.384
date	2013.06.26.09.12.39;	author henning;	state Exp;
branches;
next	1.383;

1.383
date	2013.06.04.19.03.12;	author henning;	state Exp;
branches;
next	1.382;

1.382
date	2013.06.03.15.00.00;	author henning;	state Exp;
branches;
next	1.381;

1.381
date	2013.06.03.01.41.04;	author henning;	state Exp;
branches;
next	1.380;

1.380
date	2013.06.01.21.18.02;	author henning;	state Exp;
branches;
next	1.379;

1.379
date	2013.05.10.11.36.24;	author mikeb;	state Exp;
branches;
next	1.378;

1.378
date	2013.05.03.15.33.47;	author florian;	state Exp;
branches;
next	1.377;

1.377
date	2013.03.11.19.48.40;	author sthen;	state Exp;
branches;
next	1.376;

1.376
date	2013.01.17.00.48.04;	author henning;	state Exp;
branches;
next	1.375;

1.375
date	2012.12.29.14.53.06;	author markus;	state Exp;
branches;
next	1.374;

1.374
date	2012.11.06.12.32.41;	author henning;	state Exp;
branches;
next	1.373;

1.373
date	2012.11.01.07.55.56;	author henning;	state Exp;
branches;
next	1.372;

1.372
date	2012.10.30.12.09.05;	author florian;	state Exp;
branches;
next	1.371;

1.371
date	2012.10.08.17.41.55;	author camield;	state Exp;
branches;
next	1.370;

1.370
date	2012.10.05.12.32.27;	author camield;	state Exp;
branches;
next	1.369;

1.369
date	2012.09.20.09.43.49;	author camield;	state Exp;
branches;
next	1.368;

1.368
date	2012.09.18.10.11.53;	author henning;	state Exp;
branches;
next	1.367;

1.367
date	2012.07.26.12.25.31;	author mikeb;	state Exp;
branches;
next	1.366;

1.366
date	2012.07.13.11.14.04;	author henning;	state Exp;
branches;
next	1.365;

1.365
date	2012.07.10.09.38.22;	author henning;	state Exp;
branches;
next	1.364;

1.364
date	2012.07.07.16.24.32;	author henning;	state Exp;
branches;
next	1.363;

1.363
date	2012.04.03.15.09.04;	author mikeb;	state Exp;
branches;
next	1.362;

1.362
date	2012.02.03.01.57.51;	author bluhm;	state Exp;
branches;
next	1.361;

1.361
date	2012.01.26.20.16.06;	author bluhm;	state Exp;
branches;
next	1.360;

1.360
date	2012.01.16.16.38.01;	author bluhm;	state Exp;
branches;
next	1.359;

1.359
date	2012.01.15.22.55.35;	author bluhm;	state Exp;
branches;
next	1.358;

1.358
date	2011.12.12.21.30.27;	author mikeb;	state Exp;
branches;
next	1.357;

1.357
date	2011.11.29.10.17.52;	author dlg;	state Exp;
branches;
next	1.356;

1.356
date	2011.11.28.01.04.50;	author dlg;	state Exp;
branches;
next	1.355;

1.355
date	2011.11.26.03.28.46;	author mcbride;	state Exp;
branches;
next	1.354;

1.354
date	2011.10.13.18.23.40;	author claudio;	state Exp;
branches;
next	1.353;

1.353
date	2011.10.07.17.10.08;	author henning;	state Exp;
branches;
next	1.352;

1.352
date	2011.10.07.14.02.48;	author henning;	state Exp;
branches;
next	1.351;

1.351
date	2011.09.28.17.15.45;	author bluhm;	state Exp;
branches;
next	1.350;

1.350
date	2011.09.22.14.57.12;	author bluhm;	state Exp;
branches;
next	1.349;

1.349
date	2011.09.20.10.51.18;	author bluhm;	state Exp;
branches;
next	1.348;

1.348
date	2011.09.19.12.51.52;	author bluhm;	state Exp;
branches;
next	1.347;

1.347
date	2011.09.18.13.50.13;	author bluhm;	state Exp;
branches;
next	1.346;

1.346
date	2011.09.18.10.40.55;	author bluhm;	state Exp;
branches;
next	1.345;

1.345
date	2011.09.17.16.01.55;	author bluhm;	state Exp;
branches;
next	1.344;

1.344
date	2011.08.30.00.40.47;	author mikeb;	state Exp;
branches;
next	1.343;

1.343
date	2011.08.03.00.01.30;	author dlg;	state Exp;
branches;
next	1.342;

1.342
date	2011.08.02.13.13.57;	author mcbride;	state Exp;
branches;
next	1.341;

1.341
date	2011.07.27.00.26.10;	author mcbride;	state Exp;
branches;
next	1.340;

1.340
date	2011.07.08.18.50.52;	author henning;	state Exp;
branches;
next	1.339;

1.339
date	2011.07.07.20.46.37;	author bluhm;	state Exp;
branches;
next	1.338;

1.338
date	2011.07.07.00.47.19;	author mcbride;	state Exp;
branches;
next	1.337;

1.337
date	2011.07.04.18.12.51;	author bluhm;	state Exp;
branches;
next	1.336;

1.336
date	2011.07.04.06.54.49;	author claudio;	state Exp;
branches;
next	1.335;

1.335
date	2011.07.03.23.37.55;	author zinke;	state Exp;
branches;
next	1.334;

1.334
date	2011.06.21.08.59.47;	author bluhm;	state Exp;
branches;
next	1.333;

1.333
date	2011.06.20.19.03.41;	author claudio;	state Exp;
branches;
next	1.332;

1.332
date	2011.05.24.14.01.52;	author claudio;	state Exp;
branches;
next	1.331;

1.331
date	2011.05.22.13.21.24;	author claudio;	state Exp;
branches;
next	1.330;

1.330
date	2011.05.17.12.44.05;	author mikeb;	state Exp;
branches;
next	1.329;

1.329
date	2011.04.23.10.00.36;	author bluhm;	state Exp;
branches;
next	1.328;

1.328
date	2011.04.22.15.49.28;	author bluhm;	state Exp;
branches;
next	1.327;

1.327
date	2011.04.12.10.47.29;	author mikeb;	state Exp;
branches;
next	1.326;

1.326
date	2011.04.06.13.18.39;	author claudio;	state Exp;
branches;
next	1.325;

1.325
date	2011.04.05.13.48.18;	author mikeb;	state Exp;
branches;
next	1.324;

1.324
date	2011.03.25.10.54.22;	author claudio;	state Exp;
branches;
next	1.323;

1.323
date	2011.03.24.20.09.44;	author bluhm;	state Exp;
branches;
next	1.322;

1.322
date	2011.03.07.23.30.19;	author bluhm;	state Exp;
branches;
next	1.321;

1.321
date	2011.03.05.01.53.16;	author bluhm;	state Exp;
branches;
next	1.320;

1.320
date	2011.01.11.13.35.58;	author mcbride;	state Exp;
branches;
next	1.319;

1.319
date	2010.12.07.11.39.40;	author jsg;	state Exp;
branches;
next	1.318;

1.318
date	2010.10.23.15.38.18;	author tedu;	state Exp;
branches;
next	1.317;

1.317
date	2010.10.18.15.55.28;	author deraadt;	state Exp;
branches;
next	1.316;

1.316
date	2010.10.17.12.14.28;	author jsing;	state Exp;
branches;
next	1.315;

1.315
date	2010.09.22.05.58.29;	author henning;	state Exp;
branches;
next	1.314;

1.314
date	2010.09.21.11.29.12;	author henning;	state Exp;
branches;
next	1.313;

1.313
date	2010.09.21.03.42.17;	author henning;	state Exp;
branches;
next	1.312;

1.312
date	2010.09.21.02.51.35;	author henning;	state Exp;
branches;
next	1.311;

1.311
date	2010.06.28.23.21.41;	author mcbride;	state Exp;
branches;
next	1.310;

1.310
date	2010.06.27.01.39.43;	author henning;	state Exp;
branches;
next	1.309;

1.309
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.308;

1.308
date	2010.04.28.12.46.18;	author robert;	state Exp;
branches;
next	1.307;

1.307
date	2010.01.20.21.41.17;	author mcbride;	state Exp;
branches;
next	1.306;

1.306
date	2010.01.18.23.52.46;	author mcbride;	state Exp;
branches;
next	1.305;

1.305
date	2010.01.13.01.54.38;	author jsg;	state Exp;
branches;
next	1.304;

1.304
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.303;

1.303
date	2009.12.24.04.24.19;	author dlg;	state Exp;
branches;
next	1.302;

1.302
date	2009.12.14.12.31.45;	author henning;	state Exp;
branches;
next	1.301;

1.301
date	2009.11.24.13.23.55;	author henning;	state Exp;
branches;
next	1.300;

1.300
date	2009.11.23.16.03.10;	author henning;	state Exp;
branches;
next	1.299;

1.299
date	2009.11.22.22.34.50;	author henning;	state Exp;
branches;
next	1.298;

1.298
date	2009.11.03.17.41.02;	author claudio;	state Exp;
branches;
next	1.297;

1.297
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.296;

1.296
date	2009.10.28.20.11.01;	author jsg;	state Exp;
branches;
next	1.295;

1.295
date	2009.10.06.21.21.48;	author claudio;	state Exp;
branches;
next	1.294;

1.294
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.293;

1.293
date	2009.09.08.17.52.17;	author michele;	state Exp;
branches;
next	1.292;

1.292
date	2009.09.08.17.00.41;	author michele;	state Exp;
branches;
next	1.291;

1.291
date	2009.09.01.13.42.00;	author henning;	state Exp;
branches;
next	1.290;

1.290
date	2009.06.25.09.30.28;	author sthen;	state Exp;
branches;
next	1.289;

1.289
date	2009.06.08.02.39.15;	author henning;	state Exp;
branches;
next	1.288;

1.288
date	2009.06.08.01.55.42;	author henning;	state Exp;
branches;
next	1.287;

1.287
date	2009.06.08.00.50.30;	author henning;	state Exp;
branches;
next	1.286;

1.286
date	2009.05.18.20.37.13;	author bluhm;	state Exp;
branches;
next	1.285;

1.285
date	2009.04.06.12.05.55;	author henning;	state Exp;
branches;
next	1.284;

1.284
date	2009.03.09.13.53.10;	author mcbride;	state Exp;
branches;
next	1.283;

1.283
date	2009.02.16.00.31.25;	author dlg;	state Exp;
branches;
next	1.282;

1.282
date	2009.01.29.15.12.28;	author pyr;	state Exp;
branches;
next	1.281;

1.281
date	2008.11.24.13.22.09;	author mikeb;	state Exp;
branches;
next	1.280;

1.280
date	2008.10.08.06.24.50;	author mcbride;	state Exp;
branches;
next	1.279;

1.279
date	2008.09.22.10.22.19;	author mpf;	state Exp;
branches;
next	1.278;

1.278
date	2008.09.09.13.56.39;	author henning;	state Exp;
branches;
next	1.277;

1.277
date	2008.08.26.12.17.10;	author henning;	state Exp;
branches;
next	1.276;

1.276
date	2008.07.03.15.46.23;	author henning;	state Exp;
branches;
next	1.275;

1.275
date	2008.06.29.08.42.15;	author mcbride;	state Exp;
branches;
next	1.274;

1.274
date	2008.06.11.02.46.35;	author henning;	state Exp;
branches;
next	1.273;

1.273
date	2008.06.10.20.55.02;	author mcbride;	state Exp;
branches;
next	1.272;

1.272
date	2008.06.10.19.32.14;	author henning;	state Exp;
branches;
next	1.271;

1.271
date	2008.06.10.04.24.17;	author henning;	state Exp;
branches;
next	1.270;

1.270
date	2008.05.30.14.22.48;	author henning;	state Exp;
branches;
next	1.269;

1.269
date	2008.05.29.01.00.53;	author mcbride;	state Exp;
branches;
next	1.268;

1.268
date	2008.05.29.00.28.08;	author henning;	state Exp;
branches;
next	1.267;

1.267
date	2008.05.18.11.54.04;	author mcbride;	state Exp;
branches;
next	1.266;

1.266
date	2008.05.09.13.59.31;	author mpf;	state Exp;
branches;
next	1.265;

1.265
date	2008.05.09.02.44.54;	author markus;	state Exp;
branches;
next	1.264;

1.264
date	2008.05.08.08.05.16;	author deraadt;	state Exp;
branches;
next	1.263;

1.263
date	2008.05.07.07.07.29;	author markus;	state Exp;
branches;
next	1.262;

1.262
date	2008.05.07.06.23.30;	author markus;	state Exp;
branches;
next	1.261;

1.261
date	2008.05.06.03.45.22;	author mpf;	state Exp;
branches;
next	1.260;

1.260
date	2008.05.05.13.00.43;	author henning;	state Exp;
branches;
next	1.259;

1.259
date	2007.12.02.12.08.04;	author pascoe;	state Exp;
branches;
next	1.258;

1.258
date	2007.09.27.22.24.05;	author mpf;	state Exp;
branches;
next	1.257;

1.257
date	2007.08.31.12.37.50;	author thib;	state Exp;
branches;
next	1.256;

1.256
date	2007.08.30.13.07.06;	author henning;	state Exp;
branches;
next	1.255;

1.255
date	2007.08.30.09.28.48;	author dhartmei;	state Exp;
branches;
next	1.254;

1.254
date	2007.07.13.09.17.48;	author markus;	state Exp;
branches;
next	1.253;

1.253
date	2007.06.25.13.57.18;	author henning;	state Exp;
branches;
next	1.252;

1.252
date	2007.06.24.11.17.13;	author mcbride;	state Exp;
branches;
next	1.251;

1.251
date	2007.06.21.11.55.54;	author henning;	state Exp;
branches;
next	1.250;

1.250
date	2007.06.11.11.18.14;	author henning;	state Exp;
branches;
next	1.249;

1.249
date	2007.06.01.18.44.23;	author henning;	state Exp;
branches;
next	1.248;

1.248
date	2007.05.31.22.45.36;	author mcbride;	state Exp;
branches;
next	1.247;

1.247
date	2007.05.31.18.48.05;	author mcbride;	state Exp;
branches;
next	1.246;

1.246
date	2007.05.31.04.11.42;	author mcbride;	state Exp;
branches;
next	1.245;

1.245
date	2007.05.28.17.16.39;	author henning;	state Exp;
branches;
next	1.244;

1.244
date	2007.02.23.21.31.51;	author deraadt;	state Exp;
branches;
next	1.243;

1.243
date	2007.02.09.11.20.39;	author henning;	state Exp;
branches;
next	1.242;

1.242
date	2006.12.13.05.10.15;	author itojun;	state Exp;
branches;
next	1.241;

1.241
date	2006.11.20.14.25.11;	author mcbride;	state Exp;
branches;
next	1.240;

1.240
date	2006.10.27.13.56.51;	author mcbride;	state Exp;
branches;
next	1.239;

1.239
date	2006.10.25.11.26.47;	author henning;	state Exp;
branches;
next	1.238;

1.238
date	2006.10.17.14.08.17;	author reyk;	state Exp;
branches;
next	1.237;

1.237
date	2006.10.11.08.42.31;	author mcbride;	state Exp;
branches;
next	1.236;

1.236
date	2006.07.06.13.25.40;	author henning;	state Exp;
branches;
next	1.235;

1.235
date	2006.05.28.02.45.45;	author mcbride;	state Exp;
branches;
next	1.234;

1.234
date	2006.03.14.11.09.42;	author djm;	state Exp;
branches;
next	1.233;

1.233
date	2005.11.04.08.24.15;	author mcbride;	state Exp;
branches;
next	1.232;

1.232
date	2005.10.27.12.34.40;	author mcbride;	state Exp;
branches;
next	1.231;

1.231
date	2005.10.17.08.43.35;	author henning;	state Exp;
branches;
next	1.230;

1.230
date	2005.09.28.01.46.33;	author pascoe;	state Exp;
branches;
next	1.229;

1.229
date	2005.08.18.10.28.14;	author pascoe;	state Exp;
branches;
next	1.228;

1.228
date	2005.08.11.05.09.30;	author joel;	state Exp;
branches;
next	1.227;

1.227
date	2005.08.02.12.40.42;	author pascoe;	state Exp;
branches;
next	1.226;

1.226
date	2005.07.31.05.20.57;	author pascoe;	state Exp;
branches;
next	1.225;

1.225
date	2005.06.30.20.52.20;	author sturm;	state Exp;
branches;
next	1.224;

1.224
date	2005.06.13.20.54.50;	author henning;	state Exp;
branches;
next	1.223;

1.223
date	2005.06.13.20.17.25;	author henning;	state Exp;
branches;
next	1.222;

1.222
date	2005.06.05.20.47.46;	author henning;	state Exp;
branches;
next	1.221;

1.221
date	2005.05.27.21.41.03;	author mpf;	state Exp;
branches;
next	1.220;

1.220
date	2005.05.27.17.22.41;	author dhartmei;	state Exp;
branches;
next	1.219;

1.219
date	2005.05.26.15.29.48;	author dhartmei;	state Exp;
branches;
next	1.218;

1.218
date	2005.05.25.06.50.05;	author henning;	state Exp;
branches;
next	1.217;

1.217
date	2005.05.23.23.28.53;	author dhartmei;	state Exp;
branches;
next	1.216;

1.216
date	2005.05.23.22.30.21;	author henning;	state Exp;
branches;
next	1.215;

1.215
date	2005.05.22.18.23.04;	author henning;	state Exp;
branches;
next	1.214;

1.214
date	2005.05.21.21.03.57;	author henning;	state Exp;
branches;
next	1.213;

1.213
date	2005.03.03.07.13.39;	author dhartmei;	state Exp;
branches
	1.213.2.1;
next	1.212;

1.212
date	2005.01.30.00.02.30;	author dhartmei;	state Exp;
branches;
next	1.211;

1.211
date	2005.01.05.18.09.54;	author mcbride;	state Exp;
branches;
next	1.210;

1.210
date	2004.12.22.17.17.55;	author dhartmei;	state Exp;
branches;
next	1.209;

1.209
date	2004.12.10.22.13.26;	author henning;	state Exp;
branches;
next	1.208;

1.208
date	2004.12.07.10.33.41;	author dhartmei;	state Exp;
branches;
next	1.207;

1.207
date	2004.12.07.09.36.16;	author deraadt;	state Exp;
branches;
next	1.206;

1.206
date	2004.12.07.05.30.26;	author mcbride;	state Exp;
branches;
next	1.205;

1.205
date	2004.12.04.07.49.48;	author mcbride;	state Exp;
branches;
next	1.204;

1.204
date	2004.11.16.20.07.57;	author mcbride;	state Exp;
branches;
next	1.203;

1.203
date	2004.09.21.16.59.12;	author aaron;	state Exp;
branches;
next	1.202;

1.202
date	2004.07.12.00.50.22;	author itojun;	state Exp;
branches;
next	1.201;

1.201
date	2004.07.11.15.54.21;	author itojun;	state Exp;
branches;
next	1.200;

1.200
date	2004.06.25.10.10.14;	author itojun;	state Exp;
branches;
next	1.199;

1.199
date	2004.06.25.00.42.58;	author itojun;	state Exp;
branches;
next	1.198;

1.198
date	2004.06.21.19.26.01;	author mcbride;	state Exp;
branches;
next	1.197;

1.197
date	2004.06.14.20.53.27;	author cedric;	state Exp;
branches;
next	1.196;

1.196
date	2004.06.10.14.22.54;	author dhartmei;	state Exp;
branches;
next	1.195;

1.195
date	2004.05.19.17.50.52;	author dhartmei;	state Exp;
branches;
next	1.194;

1.194
date	2004.05.11.07.34.11;	author dhartmei;	state Exp;
branches;
next	1.193;

1.193
date	2004.05.05.23.16.03;	author frantzen;	state Exp;
branches;
next	1.192;

1.192
date	2004.04.28.02.51.58;	author cedric;	state Exp;
branches;
next	1.191;

1.191
date	2004.04.27.18.28.07;	author frantzen;	state Exp;
branches;
next	1.190;

1.190
date	2004.04.26.00.12.28;	author cedric;	state Exp;
branches;
next	1.189;

1.189
date	2004.04.25.18.09.30;	author pb;	state Exp;
branches;
next	1.188;

1.188
date	2004.04.24.23.22.54;	author cedric;	state Exp;
branches;
next	1.187;

1.187
date	2004.03.22.04.54.18;	author mcbride;	state Exp;
branches;
next	1.186;

1.186
date	2004.02.20.19.22.03;	author mcbride;	state Exp;
branches;
next	1.185;

1.185
date	2004.02.19.21.29.51;	author cedric;	state Exp;
branches;
next	1.184;

1.184
date	2004.02.19.07.41.45;	author kjc;	state Exp;
branches;
next	1.183;

1.183
date	2004.02.10.22.42.57;	author dhartmei;	state Exp;
branches;
next	1.182;

1.182
date	2004.02.10.18.49.10;	author henning;	state Exp;
branches;
next	1.181;

1.181
date	2004.02.04.10.43.18;	author mcbride;	state Exp;
branches;
next	1.180;

1.180
date	2003.12.31.11.18.25;	author cedric;	state Exp;
branches;
next	1.179;

1.179
date	2003.12.15.09.10.26;	author henning;	state Exp;
branches;
next	1.178;

1.178
date	2003.12.15.07.11.30;	author mcbride;	state Exp;
branches;
next	1.177;

1.177
date	2003.12.15.00.02.04;	author mcbride;	state Exp;
branches;
next	1.176;

1.176
date	2003.12.12.20.05.45;	author cedric;	state Exp;
branches;
next	1.175;

1.175
date	2003.12.11.13.13.27;	author cedric;	state Exp;
branches;
next	1.174;

1.174
date	2003.11.08.00.45.34;	author mcbride;	state Exp;
branches;
next	1.173;

1.173
date	2003.10.31.10.34.47;	author mcbride;	state Exp;
branches;
next	1.172;

1.172
date	2003.10.25.20.27.07;	author mcbride;	state Exp;
branches;
next	1.171;

1.171
date	2003.09.26.21.44.09;	author cedric;	state Exp;
branches;
next	1.170;

1.170
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.169;

1.169
date	2003.08.22.15.19.23;	author henning;	state Exp;
branches;
next	1.168;

1.168
date	2003.08.22.14.59.30;	author frantzen;	state Exp;
branches;
next	1.167;

1.167
date	2003.08.21.19.12.08;	author frantzen;	state Exp;
branches;
next	1.166;

1.166
date	2003.08.09.14.56.48;	author cedric;	state Exp;
branches;
next	1.165;

1.165
date	2003.08.07.14.20.50;	author henning;	state Exp;
branches;
next	1.164;

1.164
date	2003.07.31.22.25.55;	author cedric;	state Exp;
branches;
next	1.163;

1.163
date	2003.07.19.13.08.58;	author cedric;	state Exp;
branches;
next	1.162;

1.162
date	2003.07.04.10.39.31;	author henning;	state Exp;
branches;
next	1.161;

1.161
date	2003.07.03.11.48.39;	author itojun;	state Exp;
branches;
next	1.160;

1.160
date	2003.06.30.19.09.25;	author henning;	state Exp;
branches;
next	1.159;

1.159
date	2003.06.30.10.50.16;	author henning;	state Exp;
branches;
next	1.158;

1.158
date	2003.06.29.23.37.12;	author itojun;	state Exp;
branches;
next	1.157;

1.157
date	2003.06.21.09.07.01;	author djm;	state Exp;
branches;
next	1.156;

1.156
date	2003.06.20.18.24.57;	author dhartmei;	state Exp;
branches;
next	1.155;

1.155
date	2003.06.09.11.14.46;	author mcbride;	state Exp;
branches;
next	1.154;

1.154
date	2003.06.08.09.41.08;	author cedric;	state Exp;
branches;
next	1.153;

1.153
date	2003.06.03.12.34.04;	author henning;	state Exp;
branches;
next	1.152;

1.152
date	2003.05.17.02.01.21;	author henning;	state Exp;
branches;
next	1.151;

1.151
date	2003.05.17.01.08.50;	author dhartmei;	state Exp;
branches;
next	1.150;

1.150
date	2003.05.16.17.15.17;	author dhartmei;	state Exp;
branches;
next	1.149;

1.149
date	2003.05.14.23.46.45;	author frantzen;	state Exp;
branches;
next	1.148;

1.148
date	2003.05.14.08.42.00;	author canacar;	state Exp;
branches;
next	1.147;

1.147
date	2003.05.13.17.45.24;	author henning;	state Exp;
branches;
next	1.146;

1.146
date	2003.05.12.22.11.18;	author dhartmei;	state Exp;
branches;
next	1.145;

1.145
date	2003.05.12.17.49.03;	author mcbride;	state Exp;
branches;
next	1.144;

1.144
date	2003.05.12.01.25.31;	author dhartmei;	state Exp;
branches;
next	1.143;

1.143
date	2003.05.11.20.44.03;	author frantzen;	state Exp;
branches;
next	1.142;

1.142
date	2003.04.30.12.30.27;	author cedric;	state Exp;
branches;
next	1.141;

1.141
date	2003.04.27.16.02.08;	author cedric;	state Exp;
branches;
next	1.140;

1.140
date	2003.04.11.14.40.57;	author henning;	state Exp;
branches;
next	1.139;

1.139
date	2003.04.09.15.32.59;	author cedric;	state Exp;
branches;
next	1.138;

1.138
date	2003.04.05.20.20.58;	author cedric;	state Exp;
branches;
next	1.137;

1.137
date	2003.03.31.13.15.27;	author cedric;	state Exp;
branches;
next	1.136;

1.136
date	2003.03.03.14.33.17;	author cedric;	state Exp;
branches;
next	1.135;

1.135
date	2003.02.08.20.13.20;	author dhartmei;	state Exp;
branches;
next	1.134;

1.134
date	2003.01.21.22.23.49;	author dhartmei;	state Exp;
branches;
next	1.133;

1.133
date	2003.01.15.16.28.56;	author cedric;	state Exp;
branches;
next	1.132;

1.132
date	2003.01.10.16.09.19;	author cedric;	state Exp;
branches;
next	1.131;

1.131
date	2003.01.09.15.58.35;	author dhartmei;	state Exp;
branches;
next	1.130;

1.130
date	2003.01.09.10.40.45;	author cedric;	state Exp;
branches;
next	1.129;

1.129
date	2003.01.07.00.21.07;	author dhartmei;	state Exp;
branches;
next	1.128;

1.128
date	2003.01.06.14.19.40;	author cedric;	state Exp;
branches;
next	1.127;

1.127
date	2003.01.05.22.14.23;	author dhartmei;	state Exp;
branches;
next	1.126;

1.126
date	2003.01.04.17.40.50;	author dhartmei;	state Exp;
branches;
next	1.125;

1.125
date	2003.01.03.10.39.09;	author cedric;	state Exp;
branches;
next	1.124;

1.124
date	2003.01.02.11.43.20;	author mcbride;	state Exp;
branches;
next	1.123;

1.123
date	2003.01.01.16.09.29;	author henning;	state Exp;
branches;
next	1.122;

1.122
date	2003.01.01.14.16.56;	author cedric;	state Exp;
branches;
next	1.121;

1.121
date	2003.01.01.04.26.19;	author dhartmei;	state Exp;
branches;
next	1.120;

1.120
date	2002.12.31.19.18.41;	author mcbride;	state Exp;
branches;
next	1.119;

1.119
date	2002.12.29.20.07.34;	author cedric;	state Exp;
branches;
next	1.118;

1.118
date	2002.12.23.13.15.18;	author mcbride;	state Exp;
branches;
next	1.117;

1.117
date	2002.12.22.19.59.13;	author mcbride;	state Exp;
branches;
next	1.116;

1.116
date	2002.12.22.02.33.14;	author mcbride;	state Exp;
branches;
next	1.115;

1.115
date	2002.12.18.19.40.41;	author dhartmei;	state Exp;
branches;
next	1.114;

1.114
date	2002.12.18.19.04.38;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2002.12.18.16.28.40;	author dhartmei;	state Exp;
branches;
next	1.112;

1.112
date	2002.12.17.12.30.13;	author mcbride;	state Exp;
branches;
next	1.111;

1.111
date	2002.12.16.08.49.22;	author kjc;	state Exp;
branches;
next	1.110;

1.110
date	2002.12.13.21.48.31;	author henning;	state Exp;
branches;
next	1.109;

1.109
date	2002.12.12.14.08.52;	author henning;	state Exp;
branches;
next	1.108;

1.108
date	2002.12.06.00.47.32;	author dhartmei;	state Exp;
branches;
next	1.107;

1.107
date	2002.12.01.19.54.32;	author mcbride;	state Exp;
branches;
next	1.106;

1.106
date	2002.11.29.18.25.23;	author mickey;	state Exp;
branches;
next	1.105;

1.105
date	2002.11.28.12.07.37;	author mcbride;	state Exp;
branches;
next	1.104;

1.104
date	2002.11.26.11.28.13;	author mcbride;	state Exp;
branches;
next	1.103;

1.103
date	2002.11.23.09.37.02;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2002.11.23.05.16.58;	author mcbride;	state Exp;
branches;
next	1.101;

1.101
date	2002.11.02.16.56.50;	author mcbride;	state Exp;
branches;
next	1.100;

1.100
date	2002.10.22.12.23.35;	author mcbride;	state Exp;
branches;
next	1.99;

1.99
date	2002.10.20.13.08.29;	author mcbride;	state Exp;
branches;
next	1.98;

1.98
date	2002.10.14.12.58.28;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2002.10.10.12.29.33;	author mickey;	state Exp;
branches;
next	1.96;

1.96
date	2002.10.08.05.12.08;	author kjc;	state Exp;
branches;
next	1.95;

1.95
date	2002.10.07.13.23.46;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2002.10.07.13.18.40;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2002.10.07.13.15.02;	author henning;	state Exp;
branches;
next	1.92;

1.92
date	2002.10.07.12.59.54;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2002.10.07.12.39.29;	author dhartmei;	state Exp;
branches;
next	1.90;

1.90
date	2002.10.05.21.17.57;	author dhartmei;	state Exp;
branches;
next	1.89;

1.89
date	2002.08.12.16.41.25;	author dhartmei;	state Exp;
branches;
next	1.88;

1.88
date	2002.07.15.18.07.17;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2002.06.11.18.03.25;	author frantzen;	state Exp;
branches;
next	1.86;

1.86
date	2002.06.11.02.42.27;	author frantzen;	state Exp;
branches;
next	1.85;

1.85
date	2002.06.11.02.27.19;	author frantzen;	state Exp;
branches;
next	1.84;

1.84
date	2002.06.11.02.12.37;	author dhartmei;	state Exp;
branches;
next	1.83;

1.83
date	2002.06.11.01.58.00;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2002.06.09.20.20.58;	author dhartmei;	state Exp;
branches;
next	1.81;

1.81
date	2002.06.09.08.53.08;	author pb;	state Exp;
branches;
next	1.80;

1.80
date	2002.06.09.04.50.27;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2002.06.09.04.44.35;	author pb;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.08.07.58.06;	author dhartmei;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.07.23.06.21;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2002.06.07.22.53.37;	author pb;	state Exp;
branches;
next	1.75;

1.75
date	2002.06.07.21.25.35;	author dhartmei;	state Exp;
branches;
next	1.74;

1.74
date	2002.06.07.21.14.02;	author frantzen;	state Exp;
branches;
next	1.73;

1.73
date	2002.05.19.22.31.28;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2002.05.12.00.54.56;	author dhartmei;	state Exp;
branches;
next	1.71;

1.71
date	2002.05.09.21.58.12;	author jasoni;	state Exp;
branches;
next	1.70;

1.70
date	2002.05.09.19.58.42;	author dhartmei;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.05.21.40.22;	author dhartmei;	state Exp;
branches;
next	1.68;

1.68
date	2002.04.24.18.10.25;	author dhartmei;	state Exp;
branches;
next	1.67;

1.67
date	2002.04.23.14.32.22;	author dhartmei;	state Exp;
branches;
next	1.66;

1.66
date	2002.03.27.18.16.21;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2002.03.25.22.03.01;	author frantzen;	state Exp;
branches;
next	1.64;

1.64
date	2002.02.26.07.25.33;	author dhartmei;	state Exp;
branches;
next	1.63;

1.63
date	2002.02.14.23.53.32;	author dhartmei;	state Exp;
branches;
next	1.62;

1.62
date	2002.02.14.15.32.11;	author dhartmei;	state Exp;
branches;
next	1.61;

1.61
date	2002.01.11.20.13.11;	author mickey;	state Exp;
branches;
next	1.60;

1.60
date	2002.01.09.11.30.53;	author dhartmei;	state Exp;
branches;
next	1.59;

1.59
date	2002.01.08.09.31.55;	author dhartmei;	state Exp;
branches;
next	1.58;

1.58
date	2001.12.10.18.28.32;	author dhartmei;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2001.12.10.18.08.11;	author dhartmei;	state Exp;
branches;
next	1.56;

1.56
date	2001.11.26.16.50.26;	author jasoni;	state Exp;
branches;
next	1.55;

1.55
date	2001.11.06.11.48.29;	author dhartmei;	state Exp;
branches;
next	1.54;

1.54
date	2001.10.15.16.22.21;	author dhartmei;	state Exp;
branches;
next	1.53;

1.53
date	2001.09.27.17.49.12;	author dhartmei;	state Exp;
branches;
next	1.52;

1.52
date	2001.09.15.16.47.07;	author dhartmei;	state Exp;
branches;
next	1.51;

1.51
date	2001.09.15.03.54.40;	author frantzen;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.06.18.05.46;	author jasoni;	state Exp;
branches;
next	1.49;

1.49
date	2001.09.05.12.42.31;	author dhartmei;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.04.12.32.53;	author dhartmei;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.28.00.02.43;	author frantzen;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.25.21.54.26;	author frantzen;	state Exp;
branches;
next	1.45;

1.45
date	2001.08.21.17.25.59;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2001.08.19.20.25.22;	author dhartmei;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.19.19.03.58;	author dhartmei;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.19.18.19.08;	author dhartmei;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.18.22.26.08;	author dhartmei;	state Exp;
branches;
next	1.40;

1.40
date	2001.08.18.21.09.13;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.08.11.12.04.59;	author dhartmei;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.01.23.07.36;	author provos;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.29.12.53.17;	author dhartmei;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.19.00.07.36;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.17.22.22.15;	author provos;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.17.21.54.26;	author provos;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.17.20.34.51;	author provos;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.09.10.30.56;	author dhartmei;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.06.21.19.56;	author chris;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.06.08.26.57;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.03.03.34.42;	author beck;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.01.23.04.44;	author dhartmei;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.07.01.17.16.03;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.29.03.09.14;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.29.00.27.47;	author dhartmei;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.28.21.53.42;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.27.10.31.51;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.27.04.29.21;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.26.22.56.03;	author dugsong;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.26.22.51.02;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.26.22.26.13;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.26.20.50.26;	author dhartmei;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.26.19.43.14;	author dhartmei;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.26.19.01.55;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.26.18.17.53;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.26.15.33.01;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.26.04.17.11;	author frantzen;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.25.22.53.39;	author dhartmei;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.25.22.08.03;	author dhartmei;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.25.17.17.03;	author dhartmei;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.25.10.07.15;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.09.31.07;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.25.09.23.32;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.25.00.02.54;	author dhartmei;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.24.23.44.00;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.24.21.50.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.24.21.32.17;	author dhartmei;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.24.21.24.13;	author kjell;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.24.19.48.58;	author kjell;	state Exp;
branches;
next	;

1.28.2.1
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2001.11.13.22.59.58;	author niklas;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.28.2.4;

1.28.2.4
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.28.2.5;

1.28.2.5
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.28.2.6;

1.28.2.6
date	2003.05.13.19.36.16;	author ho;	state Exp;
branches;
next	1.28.2.7;

1.28.2.7
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.28.2.8;

1.28.2.8
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.28.2.9;

1.28.2.9
date	2004.02.19.10.57.22;	author niklas;	state Exp;
branches;
next	1.28.2.10;

1.28.2.10
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.28.2.11;

1.28.2.11
date	2004.06.13.08.50.17;	author niklas;	state Exp;
branches;
next	;

1.58.2.1
date	2002.01.31.22.55.44;	author niklas;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.58.2.3;

1.58.2.3
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.58.2.4;

1.58.2.4
date	2003.05.19.22.29.54;	author tedu;	state Exp;
branches;
next	;

1.213.2.1
date	2005.10.07.19.56.15;	author brad;	state Exp;
branches;
next	;


desc
@@


1.457
log
@remove XXX from the comments marking "holes" in the ioctls. I see very
very little value in these comments at all, but the XXX is just wrong and
in the way when looking for real XXXs. phessler agrees
@
text
@/*	$OpenBSD: pfvar.h,v 1.456 2017/05/30 19:37:54 henning Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002 - 2013 Henning Brauer <henning@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef _NET_PFVAR_H_
#define _NET_PFVAR_H_

#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/rwlock.h>
#include <sys/syslimits.h>
#include <sys/refcnt.h>

#include <netinet/in.h>

#include <net/radix.h>
#include <net/route.h>

struct ip;
struct ip6_hdr;

#define	PF_TCPS_PROXY_SRC	((TCP_NSTATES)+0)
#define	PF_TCPS_PROXY_DST	((TCP_NSTATES)+1)

#define	PF_MD5_DIGEST_LENGTH	16
#ifdef MD5_DIGEST_LENGTH
#if PF_MD5_DIGEST_LENGTH != MD5_DIGEST_LENGTH
#error md5 digest length mismatch
#endif
#endif

typedef struct refcnt	pf_refcnt_t;
#define	PF_REF_INIT(_x)	refcnt_init(&(_x))
#define	PF_REF_TAKE(_x)	refcnt_take(&(_x))
#define	PF_REF_RELE(_x)	refcnt_rele(&(_x))

enum	{ PF_INOUT, PF_IN, PF_OUT, PF_FWD };
enum	{ PF_PASS, PF_DROP, PF_SCRUB, PF_NOSCRUB, PF_NAT, PF_NONAT,
	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR, PF_SYNPROXY_DROP, PF_DEFER,
	  PF_MATCH, PF_DIVERT, PF_RT, PF_AFRT };
enum	{ PF_TRANS_RULESET, PF_TRANS_ALTQ, PF_TRANS_TABLE };
enum	{ PF_OP_NONE, PF_OP_IRG, PF_OP_EQ, PF_OP_NE, PF_OP_LT,
	  PF_OP_LE, PF_OP_GT, PF_OP_GE, PF_OP_XRG, PF_OP_RRG };
enum	{ PF_CHANGE_NONE, PF_CHANGE_ADD_HEAD, PF_CHANGE_ADD_TAIL,
	  PF_CHANGE_ADD_BEFORE, PF_CHANGE_ADD_AFTER,
	  PF_CHANGE_REMOVE, PF_CHANGE_GET_TICKET };
enum	{ PF_GET_NONE, PF_GET_CLR_CNTR };
enum	{ PF_SK_WIRE, PF_SK_STACK, PF_SK_BOTH };

/*
 * Note about PFTM_*: real indices into pf_rule.timeout[] come before
 * PFTM_MAX, special cases afterwards. See pf_state_expires().
 */
enum	{ PFTM_TCP_FIRST_PACKET, PFTM_TCP_OPENING, PFTM_TCP_ESTABLISHED,
	  PFTM_TCP_CLOSING, PFTM_TCP_FIN_WAIT, PFTM_TCP_CLOSED,
	  PFTM_UDP_FIRST_PACKET, PFTM_UDP_SINGLE, PFTM_UDP_MULTIPLE,
	  PFTM_ICMP_FIRST_PACKET, PFTM_ICMP_ERROR_REPLY,
	  PFTM_OTHER_FIRST_PACKET, PFTM_OTHER_SINGLE,
	  PFTM_OTHER_MULTIPLE, PFTM_FRAG, PFTM_INTERVAL,
	  PFTM_ADAPTIVE_START, PFTM_ADAPTIVE_END, PFTM_SRC_NODE,
	  PFTM_TS_DIFF, PFTM_MAX, PFTM_PURGE, PFTM_UNLINKED };

/* PFTM default values */
#define PFTM_TCP_FIRST_PACKET_VAL	120	/* First TCP packet */
#define PFTM_TCP_OPENING_VAL		30	/* No response yet */
#define PFTM_TCP_ESTABLISHED_VAL	24*60*60/* Established */
#define PFTM_TCP_CLOSING_VAL		15 * 60	/* Half closed */
#define PFTM_TCP_FIN_WAIT_VAL		45	/* Got both FINs */
#define PFTM_TCP_CLOSED_VAL		90	/* Got a RST */
#define PFTM_UDP_FIRST_PACKET_VAL	60	/* First UDP packet */
#define PFTM_UDP_SINGLE_VAL		30	/* Unidirectional */
#define PFTM_UDP_MULTIPLE_VAL		60	/* Bidirectional */
#define PFTM_ICMP_FIRST_PACKET_VAL	20	/* First ICMP packet */
#define PFTM_ICMP_ERROR_REPLY_VAL	10	/* Got error response */
#define PFTM_OTHER_FIRST_PACKET_VAL	60	/* First packet */
#define PFTM_OTHER_SINGLE_VAL		30	/* Unidirectional */
#define PFTM_OTHER_MULTIPLE_VAL		60	/* Bidirectional */
#define PFTM_FRAG_VAL			60	/* Fragment expire */
#define PFTM_INTERVAL_VAL		10	/* Expire interval */
#define PFTM_SRC_NODE_VAL		0	/* Source tracking */
#define PFTM_TS_DIFF_VAL		30	/* Allowed TS diff */

enum	{ PF_NOPFROUTE, PF_ROUTETO, PF_DUPTO, PF_REPLYTO };
enum	{ PF_LIMIT_STATES, PF_LIMIT_SRC_NODES, PF_LIMIT_FRAGS,
	  PF_LIMIT_TABLES, PF_LIMIT_TABLE_ENTRIES, PF_LIMIT_MAX };
#define PF_POOL_IDMASK		0x0f
enum	{ PF_POOL_NONE, PF_POOL_BITMASK, PF_POOL_RANDOM,
	  PF_POOL_SRCHASH, PF_POOL_ROUNDROBIN, PF_POOL_LEASTSTATES };
enum	{ PF_ADDR_ADDRMASK, PF_ADDR_NOROUTE, PF_ADDR_DYNIFTL,
	  PF_ADDR_TABLE, PF_ADDR_RTLABEL, PF_ADDR_URPFFAILED,
	  PF_ADDR_RANGE, PF_ADDR_NONE };
#define PF_POOL_TYPEMASK	0x0f
#define PF_POOL_STICKYADDR	0x20
#define	PF_WSCALE_FLAG		0x80
#define	PF_WSCALE_MASK		0x0f

#define PF_POOL_DYNTYPE(_o)						\
	((((_o) & PF_POOL_TYPEMASK) == PF_POOL_ROUNDROBIN) ||		\
	(((_o) & PF_POOL_TYPEMASK) == PF_POOL_LEASTSTATES) ||		\
	(((_o) & PF_POOL_TYPEMASK) == PF_POOL_RANDOM) ||		\
	(((_o) & PF_POOL_TYPEMASK) == PF_POOL_SRCHASH))

#define	PF_LOG			0x01
#define	PF_LOG_ALL		0x02
#define	PF_LOG_SOCKET_LOOKUP	0x04
#define	PF_LOG_FORCE		0x08
#define	PF_LOG_MATCHES		0x10

struct pf_addr {
	union {
		struct in_addr		v4;
		struct in6_addr		v6;
		u_int8_t		addr8[16];
		u_int16_t		addr16[8];
		u_int32_t		addr32[4];
	} pfa;		    /* 128-bit address */
#define v4	pfa.v4
#define v6	pfa.v6
#define addr8	pfa.addr8
#define addr16	pfa.addr16
#define addr32	pfa.addr32
};

#define	PF_TABLE_NAME_SIZE	 32

#define PFI_AFLAG_NETWORK	0x01
#define PFI_AFLAG_BROADCAST	0x02
#define PFI_AFLAG_PEER		0x04
#define PFI_AFLAG_MODEMASK	0x07
#define PFI_AFLAG_NOALIAS	0x08

struct pf_addr_wrap {
	union {
		struct {
			struct pf_addr		 addr;
			struct pf_addr		 mask;
		}			 a;
		char			 ifname[IFNAMSIZ];
		char			 tblname[PF_TABLE_NAME_SIZE];
		char			 rtlabelname[RTLABEL_LEN];
		u_int32_t		 rtlabel;
	}			 v;
	union {
		struct pfi_dynaddr	*dyn;
		struct pfr_ktable	*tbl;
		int			 dyncnt;
		int			 tblcnt;
	}			 p;
	u_int8_t		 type;		/* PF_ADDR_* */
	u_int8_t		 iflags;	/* PFI_AFLAG_* */
};

#ifdef _KERNEL
struct pfi_dynaddr {
	TAILQ_ENTRY(pfi_dynaddr)	 entry;
	struct pf_addr			 pfid_addr4;
	struct pf_addr			 pfid_mask4;
	struct pf_addr			 pfid_addr6;
	struct pf_addr			 pfid_mask6;
	struct pfr_ktable		*pfid_kt;
	struct pfi_kif			*pfid_kif;
	void				*pfid_hook_cookie;
	int				 pfid_net;	/* mask or 128 */
	int				 pfid_acnt4;	/* address count IPv4 */
	int				 pfid_acnt6;	/* address count IPv6 */
	sa_family_t			 pfid_af;	/* rule af */
	u_int8_t			 pfid_iflags;	/* PFI_AFLAG_* */
};
#endif /* _KERNEL */


/*
 * Logging macros
 */

#ifndef PF_DEBUGNAME
#define PF_DEBUGNAME "pf: "
#endif

#ifdef _KERNEL
#define	DPFPRINTF(n, format, x...)					\
	do {								\
		if (pf_status.debug >= (n)) {				\
			log(n, PF_DEBUGNAME);				\
			addlog(format, ##x);				\
			addlog("\n");					\
		}							\
	} while (0)
#else
#ifdef PFDEBUG
#define	DPFPRINTF(n, format, x...)					\
	do {								\
		fprintf(stderr, format, ##x);				\
		fprintf(stderr, "\n");					\
	} while (0)
#else
#define	DPFPRINTF(n, format, x...)	((void)0)
#endif /* PFDEBUG */
#endif /* _KERNEL */


/*
 * Address manipulation macros
 */

#define PF_AEQ(a, b, c) \
	((c == AF_INET && (a)->addr32[0] == (b)->addr32[0]) || \
	(c == AF_INET6 && \
	(a)->addr32[3] == (b)->addr32[3] && \
	(a)->addr32[2] == (b)->addr32[2] && \
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[0] == (b)->addr32[0])) \

#define PF_ANEQ(a, b, c) \
	((c == AF_INET && (a)->addr32[0] != (b)->addr32[0]) || \
	(c == AF_INET6 && \
	((a)->addr32[3] != (b)->addr32[3] || \
	(a)->addr32[2] != (b)->addr32[2] || \
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[0] != (b)->addr32[0]))) \

#define PF_AZERO(a, c) \
	((c == AF_INET && !(a)->addr32[0]) || \
	(c == AF_INET6 && \
	!(a)->addr32[0] && !(a)->addr32[1] && \
	!(a)->addr32[2] && !(a)->addr32[3] )) \

#define PF_MATCHA(n, a, m, b, f) \
	pf_match_addr(n, a, m, b, f)

#define PF_ACPY(a, b, f) \
	pf_addrcpy(a, b, f)

#define PF_AINC(a, f) \
	pf_addr_inc(a, f)

#define PF_POOLMASK(a, b, c, d, f) \
	pf_poolmask(a, b, c, d, f)


#define	PF_MISMATCHAW(aw, x, af, neg, ifp, rtid)			\
	(								\
		(((aw)->type == PF_ADDR_NOROUTE &&			\
		    pf_routable((x), (af), NULL, (rtid))) ||		\
		(((aw)->type == PF_ADDR_URPFFAILED && (ifp) != NULL &&	\
		    pf_routable((x), (af), (ifp), (rtid))) ||		\
		((aw)->type == PF_ADDR_RTLABEL &&			\
		    !pf_rtlabel_match((x), (af), (aw), (rtid))) ||	\
		((aw)->type == PF_ADDR_TABLE &&				\
		    !pfr_match_addr((aw)->p.tbl, (x), (af))) ||		\
		((aw)->type == PF_ADDR_DYNIFTL &&			\
		    !pfi_match_addr((aw)->p.dyn, (x), (af))) ||		\
		((aw)->type == PF_ADDR_RANGE &&				\
		    !pf_match_addr_range(&(aw)->v.a.addr,		\
		    &(aw)->v.a.mask, (x), (af))) ||			\
		((aw)->type == PF_ADDR_ADDRMASK &&			\
		    !PF_AZERO(&(aw)->v.a.mask, (af)) &&			\
		    !PF_MATCHA(0, &(aw)->v.a.addr,			\
		    &(aw)->v.a.mask, (x), (af))))) !=			\
		(neg)							\
	)

struct pf_rule_uid {
	uid_t		 uid[2];
	u_int8_t	 op;
};

struct pf_rule_gid {
	uid_t		 gid[2];
	u_int8_t	 op;
};

struct pf_rule_addr {
	struct pf_addr_wrap	 addr;
	u_int16_t		 port[2];
	u_int8_t		 neg;
	u_int8_t		 port_op;
	u_int16_t		 weight;
};

struct pf_poolhashkey {
	union {
		u_int8_t		key8[16];
		u_int16_t		key16[8];
		u_int32_t		key32[4];
	} pfk;		    /* 128-bit hash key */
#define key8	pfk.key8
#define key16	pfk.key16
#define key32	pfk.key32
};

struct pf_pool {
	struct pf_addr_wrap	 addr;
	struct pf_poolhashkey	 key;
	struct pf_addr		 counter;
	char			 ifname[IFNAMSIZ];
	struct pfi_kif		*kif;
	int			 tblidx;
	u_int64_t		 states;
	int			 curweight;
	u_int16_t		 weight;
	u_int16_t		 proxy_port[2];
	u_int8_t		 port_op;
	u_int8_t		 opts;
};

/* A packed Operating System description for fingerprinting */
typedef u_int32_t pf_osfp_t;
#define PF_OSFP_ANY	((pf_osfp_t)0)
#define PF_OSFP_UNKNOWN	((pf_osfp_t)-1)
#define PF_OSFP_NOMATCH	((pf_osfp_t)-2)

struct pf_osfp_entry {
	SLIST_ENTRY(pf_osfp_entry) fp_entry;
	pf_osfp_t		fp_os;
	int			fp_enflags;
#define PF_OSFP_EXPANDED	0x001		/* expanded entry */
#define PF_OSFP_GENERIC		0x002		/* generic signature */
#define PF_OSFP_NODETAIL	0x004		/* no p0f details */
#define PF_OSFP_LEN	32
	u_char			fp_class_nm[PF_OSFP_LEN];
	u_char			fp_version_nm[PF_OSFP_LEN];
	u_char			fp_subtype_nm[PF_OSFP_LEN];
};
#define PF_OSFP_ENTRY_EQ(a, b) \
    ((a)->fp_os == (b)->fp_os && \
    memcmp((a)->fp_class_nm, (b)->fp_class_nm, PF_OSFP_LEN) == 0 && \
    memcmp((a)->fp_version_nm, (b)->fp_version_nm, PF_OSFP_LEN) == 0 && \
    memcmp((a)->fp_subtype_nm, (b)->fp_subtype_nm, PF_OSFP_LEN) == 0)

/* handle pf_osfp_t packing */
#define _FP_RESERVED_BIT	1  /* For the special negative #defines */
#define _FP_UNUSED_BITS		1
#define _FP_CLASS_BITS		10 /* OS Class (Windows, Linux) */
#define _FP_VERSION_BITS	10 /* OS version (95, 98, NT, 2.4.54, 3.2) */
#define _FP_SUBTYPE_BITS	10 /* patch level (NT SP4, SP3, ECN patch) */
#define PF_OSFP_UNPACK(osfp, class, version, subtype) do { \
	(class) = ((osfp) >> (_FP_VERSION_BITS+_FP_SUBTYPE_BITS)) & \
	    ((1 << _FP_CLASS_BITS) - 1); \
	(version) = ((osfp) >> _FP_SUBTYPE_BITS) & \
	    ((1 << _FP_VERSION_BITS) - 1);\
	(subtype) = (osfp) & ((1 << _FP_SUBTYPE_BITS) - 1); \
} while(0)
#define PF_OSFP_PACK(osfp, class, version, subtype) do { \
	(osfp) = ((class) & ((1 << _FP_CLASS_BITS) - 1)) << (_FP_VERSION_BITS \
	    + _FP_SUBTYPE_BITS); \
	(osfp) |= ((version) & ((1 << _FP_VERSION_BITS) - 1)) << \
	    _FP_SUBTYPE_BITS; \
	(osfp) |= (subtype) & ((1 << _FP_SUBTYPE_BITS) - 1); \
} while(0)

/* the fingerprint of an OSes TCP SYN packet */
typedef u_int64_t	pf_tcpopts_t;
struct pf_os_fingerprint {
	SLIST_HEAD(pf_osfp_enlist, pf_osfp_entry) fp_oses; /* list of matches */
	pf_tcpopts_t		fp_tcpopts;	/* packed TCP options */
	u_int16_t		fp_wsize;	/* TCP window size */
	u_int16_t		fp_psize;	/* ip->ip_len */
	u_int16_t		fp_mss;		/* TCP MSS */
	u_int16_t		fp_flags;
#define PF_OSFP_WSIZE_MOD	0x0001		/* Window modulus */
#define PF_OSFP_WSIZE_DC	0x0002		/* Window don't care */
#define PF_OSFP_WSIZE_MSS	0x0004		/* Window multiple of MSS */
#define PF_OSFP_WSIZE_MTU	0x0008		/* Window multiple of MTU */
#define PF_OSFP_PSIZE_MOD	0x0010		/* packet size modulus */
#define PF_OSFP_PSIZE_DC	0x0020		/* packet size don't care */
#define PF_OSFP_WSCALE		0x0040		/* TCP window scaling */
#define PF_OSFP_WSCALE_MOD	0x0080		/* TCP window scale modulus */
#define PF_OSFP_WSCALE_DC	0x0100		/* TCP window scale dont-care */
#define PF_OSFP_MSS		0x0200		/* TCP MSS */
#define PF_OSFP_MSS_MOD		0x0400		/* TCP MSS modulus */
#define PF_OSFP_MSS_DC		0x0800		/* TCP MSS dont-care */
#define PF_OSFP_DF		0x1000		/* IPv4 don't fragment bit */
#define PF_OSFP_TS0		0x2000		/* Zero timestamp */
#define PF_OSFP_INET6		0x4000		/* IPv6 */
	u_int8_t		fp_optcnt;	/* TCP option count */
	u_int8_t		fp_wscale;	/* TCP window scaling */
	u_int8_t		fp_ttl;		/* IPv4 TTL */
#define PF_OSFP_MAXTTL_OFFSET	40
/* TCP options packing */
#define PF_OSFP_TCPOPT_NOP	0x0		/* TCP NOP option */
#define PF_OSFP_TCPOPT_WSCALE	0x1		/* TCP window scaling option */
#define PF_OSFP_TCPOPT_MSS	0x2		/* TCP max segment size opt */
#define PF_OSFP_TCPOPT_SACK	0x3		/* TCP SACK OK option */
#define PF_OSFP_TCPOPT_TS	0x4		/* TCP timestamp option */
#define PF_OSFP_TCPOPT_BITS	3		/* bits used by each option */
#define PF_OSFP_MAX_OPTS \
    (sizeof(((struct pf_os_fingerprint *)0)->fp_tcpopts) * 8) \
    / PF_OSFP_TCPOPT_BITS

	SLIST_ENTRY(pf_os_fingerprint)	fp_next;
};

struct pf_osfp_ioctl {
	struct pf_osfp_entry	fp_os;
	pf_tcpopts_t		fp_tcpopts;	/* packed TCP options */
	u_int16_t		fp_wsize;	/* TCP window size */
	u_int16_t		fp_psize;	/* ip->ip_len */
	u_int16_t		fp_mss;		/* TCP MSS */
	u_int16_t		fp_flags;
	u_int8_t		fp_optcnt;	/* TCP option count */
	u_int8_t		fp_wscale;	/* TCP window scaling */
	u_int8_t		fp_ttl;		/* IPv4 TTL */

	int			fp_getnum;	/* DIOCOSFPGET number */
};

struct pf_rule_actions {
	int		rtableid;
	u_int16_t	qid;
	u_int16_t	pqid;
	u_int16_t	max_mss;
	u_int16_t	flags;
	u_int8_t	log;
	u_int8_t	set_tos;
	u_int8_t	min_ttl;
	u_int8_t	set_prio[2];
	u_int8_t	pad[3];
};

union pf_rule_ptr {
	struct pf_rule		*ptr;
	u_int32_t		 nr;
};

#define	PF_ANCHOR_NAME_SIZE	 64

struct pf_rule {
	struct pf_rule_addr	 src;
	struct pf_rule_addr	 dst;
#define PF_SKIP_IFP		0
#define PF_SKIP_DIR		1
#define PF_SKIP_RDOM		2
#define PF_SKIP_AF		3
#define PF_SKIP_PROTO		4
#define PF_SKIP_SRC_ADDR	5
#define PF_SKIP_DST_ADDR	6
#define PF_SKIP_SRC_PORT	7
#define PF_SKIP_DST_PORT	8
#define PF_SKIP_COUNT		9
	union pf_rule_ptr	 skip[PF_SKIP_COUNT];
#define PF_RULE_LABEL_SIZE	 64
	char			 label[PF_RULE_LABEL_SIZE];
#define PF_QNAME_SIZE		 64
	char			 ifname[IFNAMSIZ];
	char			 rcv_ifname[IFNAMSIZ];
	char			 qname[PF_QNAME_SIZE];
	char			 pqname[PF_QNAME_SIZE];
#define	PF_TAG_NAME_SIZE	 64
	char			 tagname[PF_TAG_NAME_SIZE];
	char			 match_tagname[PF_TAG_NAME_SIZE];

	char			 overload_tblname[PF_TABLE_NAME_SIZE];

	TAILQ_ENTRY(pf_rule)	 entries;
	struct pf_pool		 nat;
	struct pf_pool		 rdr;
	struct pf_pool		 route;

	u_int64_t		 evaluations;
	u_int64_t		 packets[2];
	u_int64_t		 bytes[2];

	struct pfi_kif		*kif;
	struct pfi_kif		*rcv_kif;
	struct pf_anchor	*anchor;
	struct pfr_ktable	*overload_tbl;

	pf_osfp_t		 os_fingerprint;

	int			 rtableid;
	int			 onrdomain;
	u_int32_t		 timeout[PFTM_MAX];
	u_int32_t		 states_cur;
	u_int32_t		 states_tot;
	u_int32_t		 max_states;
	u_int32_t		 src_nodes;
	u_int32_t		 max_src_nodes;
	u_int32_t		 max_src_states;
	u_int32_t		 max_src_conn;
	struct {
		u_int32_t		limit;
		u_int32_t		seconds;
	}			 max_src_conn_rate;
	u_int32_t		 qid;
	u_int32_t		 pqid;
	u_int32_t		 rt_listid;
	u_int32_t		 nr;
	u_int32_t		 prob;
	uid_t			 cuid;
	pid_t			 cpid;

	u_int16_t		 return_icmp;
	u_int16_t		 return_icmp6;
	u_int16_t		 max_mss;
	u_int16_t		 tag;
	u_int16_t		 match_tag;
	u_int16_t		 scrub_flags;

	struct pf_rule_uid	 uid;
	struct pf_rule_gid	 gid;

	u_int32_t		 rule_flag;
	u_int8_t		 action;
	u_int8_t		 direction;
	u_int8_t		 log;
	u_int8_t		 logif;
	u_int8_t		 quick;
	u_int8_t		 ifnot;
	u_int8_t		 match_tag_not;

#define PF_STATE_NORMAL		0x1
#define PF_STATE_MODULATE	0x2
#define PF_STATE_SYNPROXY	0x3
	u_int8_t		 keep_state;
	sa_family_t		 af;
	u_int8_t		 proto;
	u_int8_t		 type;
	u_int8_t		 code;
	u_int8_t		 flags;
	u_int8_t		 flagset;
	u_int8_t		 min_ttl;
	u_int8_t		 allow_opts;
	u_int8_t		 rt;
	u_int8_t		 return_ttl;
	u_int8_t		 tos;
	u_int8_t		 set_tos;
	u_int8_t		 anchor_relative;
	u_int8_t		 anchor_wildcard;

#define PF_FLUSH		0x01
#define PF_FLUSH_GLOBAL		0x02
	u_int8_t		 flush;
	u_int8_t		 prio;
	u_int8_t		 set_prio[2];
	sa_family_t		 naf;
	u_int8_t		 rcvifnot;
	u_int8_t		 pad[2];

	struct {
		struct pf_addr		addr;
		u_int16_t		port;
	}			divert, divert_packet;

	SLIST_ENTRY(pf_rule)	 gcle;
	struct pf_ruleset	*ruleset;
	time_t			 exptime;
};

/* rule flags */
#define	PFRULE_DROP		0x0000
#define	PFRULE_RETURNRST	0x0001
#define	PFRULE_FRAGMENT		0x0002
#define	PFRULE_RETURNICMP	0x0004
#define	PFRULE_RETURN		0x0008
#define	PFRULE_NOSYNC		0x0010
#define PFRULE_SRCTRACK		0x0020  /* track source states */
#define PFRULE_RULESRCTRACK	0x0040  /* per rule */

/* rule flags again */
#define PFRULE_IFBOUND		0x00010000	/* if-bound */
#define PFRULE_STATESLOPPY	0x00020000	/* sloppy state tracking */
#define PFRULE_PFLOW		0x00040000
#define PFRULE_ONCE		0x00100000	/* one shot rule */
#define PFRULE_AFTO		0x00200000	/* af-to rule */
#define	PFRULE_EXPIRED		0x00400000	/* one shot rule hit by pkt */

#define PFSTATE_HIWAT		10000	/* default state table size */
#define PFSTATE_ADAPT_START	6000	/* default adaptive timeout start */
#define PFSTATE_ADAPT_END	12000	/* default adaptive timeout end */


struct pf_threshold {
	u_int32_t	limit;
#define	PF_THRESHOLD_MULT	1000
#define PF_THRESHOLD_MAX	0xffffffff / PF_THRESHOLD_MULT
	u_int32_t	seconds;
	u_int32_t	count;
	u_int32_t	last;
};

struct pf_rule_item {
	SLIST_ENTRY(pf_rule_item)	 entry;
	struct pf_rule			*r;
};

SLIST_HEAD(pf_rule_slist, pf_rule_item);

enum pf_sn_types { PF_SN_NONE, PF_SN_NAT, PF_SN_RDR, PF_SN_ROUTE, PF_SN_MAX };

struct pf_src_node {
	RB_ENTRY(pf_src_node)	 entry;
	struct pf_addr		 addr;
	struct pf_addr		 raddr;
	union pf_rule_ptr	 rule;
	struct pfi_kif		*kif;
	u_int64_t		 bytes[2];
	u_int64_t		 packets[2];
	u_int32_t		 states;
	u_int32_t		 conn;
	struct pf_threshold	 conn_rate;
	int32_t			 creation;
	int32_t			 expire;
	sa_family_t		 af;
	sa_family_t		 naf;
	u_int8_t		 type;
};

struct pf_sn_item {
	SLIST_ENTRY(pf_sn_item)	 next;
	struct pf_src_node	*sn;
};

SLIST_HEAD(pf_sn_head, pf_sn_item);

#define PFSNODE_HIWAT		10000	/* default source node table size */

struct pf_state_scrub {
	struct timeval	pfss_last;	/* time received last packet	*/
	u_int32_t	pfss_tsecr;	/* last echoed timestamp	*/
	u_int32_t	pfss_tsval;	/* largest timestamp		*/
	u_int32_t	pfss_tsval0;	/* original timestamp		*/
	u_int16_t	pfss_flags;
#define PFSS_TIMESTAMP	0x0001		/* modulate timestamp		*/
#define PFSS_PAWS	0x0010		/* stricter PAWS checks		*/
#define PFSS_PAWS_IDLED	0x0020		/* was idle too long.  no PAWS	*/
#define PFSS_DATA_TS	0x0040		/* timestamp on data packets	*/
#define PFSS_DATA_NOTS	0x0080		/* no timestamp on data packets	*/
	u_int8_t	pfss_ttl;	/* stashed TTL			*/
	u_int8_t	pad;
	u_int32_t	pfss_ts_mod;	/* timestamp modulation		*/
};

struct pf_state_host {
	struct pf_addr	addr;
	u_int16_t	port;
	u_int16_t	pad;
};

struct pf_state_peer {
	struct pf_state_scrub	*scrub;	/* state is scrubbed		*/
	u_int32_t	seqlo;		/* Max sequence number sent	*/
	u_int32_t	seqhi;		/* Max the other end ACKd + win	*/
	u_int32_t	seqdiff;	/* Sequence number modulator	*/
	u_int16_t	max_win;	/* largest window (pre scaling)	*/
	u_int16_t	mss;		/* Maximum segment size option	*/
	u_int8_t	state;		/* active state level		*/
	u_int8_t	wscale;		/* window scaling factor	*/
	u_int8_t	tcp_est;	/* Did we reach TCPS_ESTABLISHED */
	u_int8_t	pad[1];
};

TAILQ_HEAD(pf_state_queue, pf_state);

/* keep synced with struct pf_state_key, used in RB_FIND */
struct pf_state_key_cmp {
	struct pf_addr	 addr[2];
	u_int16_t	 port[2];
	u_int16_t	 rdomain;
	sa_family_t	 af;
	u_int8_t	 proto;
};

struct pf_state_item {
	TAILQ_ENTRY(pf_state_item)	 entry;
	struct pf_state			*s;
};

TAILQ_HEAD(pf_statelisthead, pf_state_item);

struct pf_state_key {
	struct pf_addr	 addr[2];
	u_int16_t	 port[2];
	u_int16_t	 rdomain;
	sa_family_t	 af;
	u_int8_t	 proto;

	RB_ENTRY(pf_state_key)	 entry;
	struct pf_statelisthead	 states;
	struct pf_state_key	*reverse;
	struct inpcb		*inp;
	pf_refcnt_t		 refcnt;
	u_int8_t		 removed;
};
#define PF_REVERSED_KEY(key, family)				\
	((key[PF_SK_WIRE]->af != key[PF_SK_STACK]->af) &&	\
	 (key[PF_SK_WIRE]->af != (family)))

/* keep synced with struct pf_state, used in RB_FIND */
struct pf_state_cmp {
	u_int64_t		 id;
	u_int32_t		 creatorid;
	u_int8_t		 direction;
	u_int8_t		 pad[3];
};

struct pf_state {
	u_int64_t		 id;
	u_int32_t		 creatorid;
	u_int8_t		 direction;
	u_int8_t		 pad[3];

	TAILQ_ENTRY(pf_state)	 sync_list;
	TAILQ_ENTRY(pf_state)	 entry_list;
	RB_ENTRY(pf_state)	 entry_id;
	struct pf_state_peer	 src;
	struct pf_state_peer	 dst;
	struct pf_rule_slist	 match_rules;
	union pf_rule_ptr	 rule;
	union pf_rule_ptr	 anchor;
	union pf_rule_ptr	 natrule;
	struct pf_addr		 rt_addr;
	struct pf_sn_head	 src_nodes;
	struct pf_state_key	*key[2];	/* addresses stack and wire  */
	struct pfi_kif		*kif;
	struct pfi_kif		*rt_kif;
	u_int64_t		 packets[2];
	u_int64_t		 bytes[2];
	int32_t			 creation;
	int32_t			 expire;
	int32_t			 pfsync_time;
	u_int16_t		 qid;
	u_int16_t		 pqid;
	u_int16_t		 tag;
	u_int16_t		 state_flags;
#define	PFSTATE_ALLOWOPTS	0x0001
#define	PFSTATE_SLOPPY		0x0002
#define	PFSTATE_PFLOW		0x0004
#define	PFSTATE_NOSYNC		0x0008
#define	PFSTATE_ACK		0x0010
#define	PFSTATE_NODF		0x0020
#define	PFSTATE_SETTOS		0x0040
#define	PFSTATE_RANDOMID	0x0080
#define	PFSTATE_SCRUB_TCP	0x0100
#define	PFSTATE_SETPRIO		0x0200
#define	PFSTATE_SCRUBMASK (PFSTATE_NODF|PFSTATE_RANDOMID|PFSTATE_SCRUB_TCP)
#define	PFSTATE_SETMASK   (PFSTATE_SETTOS|PFSTATE_SETPRIO)
	u_int8_t		 log;
	u_int8_t		 timeout;
	u_int8_t		 sync_state; /* PFSYNC_S_x */
	u_int8_t		 sync_updates;
	int			 rtableid[2];	/* rtables stack and wire */
	u_int8_t		 min_ttl;
	u_int8_t		 set_tos;
	u_int8_t		 set_prio[2];
	u_int16_t		 max_mss;
	u_int16_t		 if_index_in;
	u_int16_t		 if_index_out;
	u_int8_t		 pad2[2];
};

/*
 * Unified state structures for pulling states out of the kernel
 * used by pfsync(4) and the pf(4) ioctl.
 */
struct pfsync_state_scrub {
	u_int16_t	pfss_flags;
	u_int8_t	pfss_ttl;	/* stashed TTL		*/
#define PFSYNC_SCRUB_FLAG_VALID		0x01
	u_int8_t	scrub_flag;
	u_int32_t	pfss_ts_mod;	/* timestamp modulation	*/
} __packed;

struct pfsync_state_peer {
	struct pfsync_state_scrub scrub;	/* state is scrubbed	*/
	u_int32_t	seqlo;		/* Max sequence number sent	*/
	u_int32_t	seqhi;		/* Max the other end ACKd + win	*/
	u_int32_t	seqdiff;	/* Sequence number modulator	*/
	u_int16_t	max_win;	/* largest window (pre scaling)	*/
	u_int16_t	mss;		/* Maximum segment size option	*/
	u_int8_t	state;		/* active state level		*/
	u_int8_t	wscale;		/* window scaling factor	*/
	u_int8_t	pad[6];
} __packed;

struct pfsync_state_key {
	struct pf_addr	 addr[2];
	u_int16_t	 port[2];
	u_int16_t	 rdomain;
	sa_family_t	 af;
	u_int8_t	 pad;
};

struct pfsync_state {
	u_int64_t	 id;
	char		 ifname[IFNAMSIZ];
	struct pfsync_state_key	key[2];
	struct pfsync_state_peer src;
	struct pfsync_state_peer dst;
	struct pf_addr	 rt_addr;
	u_int32_t	 rule;
	u_int32_t	 anchor;
	u_int32_t	 nat_rule;
	u_int32_t	 creation;
	u_int32_t	 expire;
	u_int32_t	 packets[2][2];
	u_int32_t	 bytes[2][2];
	u_int32_t	 creatorid;
	int32_t		 rtableid[2];
	u_int16_t	 max_mss;
	sa_family_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
	u_int8_t	 log;
	u_int8_t	 pad0;
	u_int8_t	 timeout;
	u_int8_t	 sync_flags;
	u_int8_t	 updates;
	u_int8_t	 min_ttl;
	u_int8_t	 set_tos;
	u_int16_t	 state_flags;
	u_int8_t	 set_prio[2];
} __packed;

#define PFSYNC_FLAG_SRCNODE	0x04
#define PFSYNC_FLAG_NATSRCNODE	0x08

/* for copies to/from network byte order */
/* ioctl interface also uses network byte order */
#define pf_state_peer_hton(s,d) do {		\
	(d)->seqlo = htonl((s)->seqlo);		\
	(d)->seqhi = htonl((s)->seqhi);		\
	(d)->seqdiff = htonl((s)->seqdiff);	\
	(d)->max_win = htons((s)->max_win);	\
	(d)->mss = htons((s)->mss);		\
	(d)->state = (s)->state;		\
	(d)->wscale = (s)->wscale;		\
	if ((s)->scrub) {						\
		(d)->scrub.pfss_flags =					\
		    htons((s)->scrub->pfss_flags & PFSS_TIMESTAMP);	\
		(d)->scrub.pfss_ttl = (s)->scrub->pfss_ttl;		\
		(d)->scrub.pfss_ts_mod = htonl((s)->scrub->pfss_ts_mod);\
		(d)->scrub.scrub_flag = PFSYNC_SCRUB_FLAG_VALID;	\
	}								\
} while (0)

#define pf_state_peer_ntoh(s,d) do {		\
	(d)->seqlo = ntohl((s)->seqlo);		\
	(d)->seqhi = ntohl((s)->seqhi);		\
	(d)->seqdiff = ntohl((s)->seqdiff);	\
	(d)->max_win = ntohs((s)->max_win);	\
	(d)->mss = ntohs((s)->mss);		\
	(d)->state = (s)->state;		\
	(d)->wscale = (s)->wscale;		\
	if ((s)->scrub.scrub_flag == PFSYNC_SCRUB_FLAG_VALID &&		\
	    (d)->scrub != NULL) {					\
		(d)->scrub->pfss_flags =				\
		    ntohs((s)->scrub.pfss_flags) & PFSS_TIMESTAMP;	\
		(d)->scrub->pfss_ttl = (s)->scrub.pfss_ttl;		\
		(d)->scrub->pfss_ts_mod = ntohl((s)->scrub.pfss_ts_mod);\
	}								\
} while (0)

#define pf_state_counter_hton(s,d) do {				\
	d[0] = htonl((s>>32)&0xffffffff);			\
	d[1] = htonl(s&0xffffffff);				\
} while (0)

#define pf_state_counter_from_pfsync(s)				\
	(((u_int64_t)(s[0])<<32) | (u_int64_t)(s[1]))

#define pf_state_counter_ntoh(s,d) do {				\
	d = ntohl(s[0]);					\
	d = d<<32;						\
	d += ntohl(s[1]);					\
} while (0)

TAILQ_HEAD(pf_rulequeue, pf_rule);

struct pf_anchor;

struct pf_ruleset {
	struct {
		struct pf_rulequeue	 queues[2];
		struct {
			struct pf_rulequeue	*ptr;
			struct pf_rule		**ptr_array;
			u_int32_t		 rcount;
			u_int32_t		 ticket;
			int			 open;
		}			 active, inactive;
	}			 rules;
	struct pf_anchor	*anchor;
	u_int32_t		 tticket;
	int			 tables;
	int			 topen;
};

RB_HEAD(pf_anchor_global, pf_anchor);
RB_HEAD(pf_anchor_node, pf_anchor);
struct pf_anchor {
	RB_ENTRY(pf_anchor)	 entry_global;
	RB_ENTRY(pf_anchor)	 entry_node;
	struct pf_anchor	*parent;
	struct pf_anchor_node	 children;
	char			 name[PF_ANCHOR_NAME_SIZE];
	char			 path[PATH_MAX];
	struct pf_ruleset	 ruleset;
	int			 refcnt;	/* anchor rules */
	int			 match;
};
RB_PROTOTYPE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare)
RB_PROTOTYPE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare)

#define PF_RESERVED_ANCHOR	"_pf"

#define PFR_TFLAG_PERSIST	0x00000001
#define PFR_TFLAG_CONST		0x00000002
#define PFR_TFLAG_ACTIVE	0x00000004
#define PFR_TFLAG_INACTIVE	0x00000008
#define PFR_TFLAG_REFERENCED	0x00000010
#define PFR_TFLAG_REFDANCHOR	0x00000020
#define PFR_TFLAG_COUNTERS	0x00000040
/* Adjust masks below when adding flags. */
#define PFR_TFLAG_USRMASK	0x00000043
#define PFR_TFLAG_SETMASK	0x0000003C
#define PFR_TFLAG_ALLMASK	0x0000007F

struct pfr_table {
	char			 pfrt_anchor[PATH_MAX];
	char			 pfrt_name[PF_TABLE_NAME_SIZE];
	u_int32_t		 pfrt_flags;
	u_int8_t		 pfrt_fback;
};

enum { PFR_FB_NONE, PFR_FB_MATCH, PFR_FB_ADDED, PFR_FB_DELETED,
	PFR_FB_CHANGED, PFR_FB_CLEARED, PFR_FB_DUPLICATE,
	PFR_FB_NOTMATCH, PFR_FB_CONFLICT, PFR_FB_NOCOUNT, PFR_FB_MAX };

struct pfr_addr {
	union {
		struct in_addr	 _pfra_ip4addr;
		struct in6_addr	 _pfra_ip6addr;
	}		 pfra_u;
	char		 pfra_ifname[IFNAMSIZ];
	u_int32_t	 pfra_states;
	u_int16_t	 pfra_weight;
	u_int8_t	 pfra_af;
	u_int8_t	 pfra_net;
	u_int8_t	 pfra_not;
	u_int8_t	 pfra_fback;
	u_int8_t	 pfra_type;
	u_int8_t	 pad[7];
};
#define	pfra_ip4addr	pfra_u._pfra_ip4addr
#define	pfra_ip6addr	pfra_u._pfra_ip6addr

enum { PFR_DIR_IN, PFR_DIR_OUT, PFR_DIR_MAX };
enum { PFR_OP_BLOCK, PFR_OP_MATCH, PFR_OP_PASS, PFR_OP_ADDR_MAX,
    PFR_OP_TABLE_MAX };
#define PFR_OP_XPASS	PFR_OP_ADDR_MAX

struct pfr_astats {
	struct pfr_addr	 pfras_a;
	u_int64_t	 pfras_packets[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t	 pfras_bytes[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	time_t		 pfras_tzero;
};

enum { PFR_REFCNT_RULE, PFR_REFCNT_ANCHOR, PFR_REFCNT_MAX };

struct pfr_tstats {
	struct pfr_table pfrts_t;
	u_int64_t	 pfrts_packets[PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_bytes[PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_match;
	u_int64_t	 pfrts_nomatch;
	time_t		 pfrts_tzero;
	int		 pfrts_cnt;
	int		 pfrts_refcnt[PFR_REFCNT_MAX];
};
#define	pfrts_name	pfrts_t.pfrt_name
#define pfrts_flags	pfrts_t.pfrt_flags

struct pfr_kcounters {
	u_int64_t		 pfrkc_packets[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t		 pfrkc_bytes[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t		 states;
};

/*
 * XXX ip_ipsp.h's sockaddr_union should be converted to sockaddr *
 * passing with correct sa_len, then a good approach for cleaning this
 * will become more clear.
 */
union pfsockaddr_union {
	struct sockaddr		sa;
	struct sockaddr_in	sin;
	struct sockaddr_in6	sin6;
};

SLIST_HEAD(pfr_kentryworkq, pfr_kentry);
struct _pfr_kentry {
	struct radix_node	 _pfrke_node[2];
	union pfsockaddr_union	 _pfrke_sa;
	SLIST_ENTRY(pfr_kentry)	 _pfrke_workq;
	struct pfr_kcounters	*_pfrke_counters;
	time_t			 _pfrke_tzero;
	u_int8_t		 _pfrke_af;
	u_int8_t		 _pfrke_net;
	u_int8_t		 _pfrke_flags;
	u_int8_t		 _pfrke_type;
};
#define PFRKE_FLAG_NOT		0x01
#define PFRKE_FLAG_MARK		0x02

/* pfrke_type */
enum { PFRKE_PLAIN, PFRKE_ROUTE, PFRKE_COST, PFRKE_MAX };

struct pfr_kentry {
	union {
		struct _pfr_kentry	_ke;
	} u;
};
#define pfrke_node	u._ke._pfrke_node
#define pfrke_sa	u._ke._pfrke_sa
#define pfrke_workq	u._ke._pfrke_workq
#define pfrke_counters	u._ke._pfrke_counters
#define pfrke_tzero	u._ke._pfrke_tzero
#define pfrke_af	u._ke._pfrke_af
#define pfrke_net	u._ke._pfrke_net
#define pfrke_flags	u._ke._pfrke_flags
#define pfrke_type	u._ke._pfrke_type

struct pfr_kentry_route {
	union {
		struct _pfr_kentry	_ke;
	} u;

	struct pfi_kif		*kif;
};

struct pfr_kentry_cost {
	union {
		struct _pfr_kentry	_ke;
	} u;

	struct pfi_kif		*kif;
	/* Above overlaps with pfr_kentry route */

	u_int16_t		 weight;
};

struct pfr_kentry_all {
	union {
		struct _pfr_kentry		_ke;
		struct pfr_kentry_route		kr;
		struct pfr_kentry_cost		kc;
	} u;
};
#define pfrke_rkif	u.kr.kif

SLIST_HEAD(pfr_ktableworkq, pfr_ktable);
RB_HEAD(pfr_ktablehead, pfr_ktable);
struct pfr_ktable {
	struct pfr_tstats	 pfrkt_ts;
	RB_ENTRY(pfr_ktable)	 pfrkt_tree;
	SLIST_ENTRY(pfr_ktable)	 pfrkt_workq;
	struct radix_node_head	*pfrkt_ip4;
	struct radix_node_head	*pfrkt_ip6;
	struct pfr_ktable	*pfrkt_shadow;
	struct pfr_ktable	*pfrkt_root;
	struct pf_ruleset	*pfrkt_rs;
	long			 pfrkt_larg;
	int			 pfrkt_nflags;
	u_int64_t		 pfrkt_refcntcost;
	u_int16_t		 pfrkt_gcdweight;
	u_int16_t		 pfrkt_maxweight;
};
#define pfrkt_t		pfrkt_ts.pfrts_t
#define pfrkt_name	pfrkt_t.pfrt_name
#define pfrkt_anchor	pfrkt_t.pfrt_anchor
#define pfrkt_ruleset	pfrkt_t.pfrt_ruleset
#define pfrkt_flags	pfrkt_t.pfrt_flags
#define pfrkt_cnt	pfrkt_ts.pfrts_cnt
#define pfrkt_refcnt	pfrkt_ts.pfrts_refcnt
#define pfrkt_packets	pfrkt_ts.pfrts_packets
#define pfrkt_bytes	pfrkt_ts.pfrts_bytes
#define pfrkt_match	pfrkt_ts.pfrts_match
#define pfrkt_nomatch	pfrkt_ts.pfrts_nomatch
#define pfrkt_tzero	pfrkt_ts.pfrts_tzero

RB_HEAD(pf_state_tree, pf_state_key);
RB_PROTOTYPE(pf_state_tree, pf_state_key, entry, pf_state_compare_key)

RB_HEAD(pf_state_tree_ext_gwy, pf_state_key);
RB_PROTOTYPE(pf_state_tree_ext_gwy, pf_state_key,
    entry_ext_gwy, pf_state_compare_ext_gwy)

RB_HEAD(pfi_ifhead, pfi_kif);

/* state tables */
extern struct pf_state_tree	 pf_statetbl;

/* keep synced with pfi_kif, used in RB_FIND */
struct pfi_kif_cmp {
	char				 pfik_name[IFNAMSIZ];
};

struct ifnet;
struct ifg_group;

struct pfi_kif {
	char				 pfik_name[IFNAMSIZ];
	RB_ENTRY(pfi_kif)		 pfik_tree;
	u_int64_t			 pfik_packets[2][2][2];
	u_int64_t			 pfik_bytes[2][2][2];
	time_t				 pfik_tzero;
	int				 pfik_flags;
	int				 pfik_flags_new;
	void				*pfik_ah_cookie;
	struct ifnet			*pfik_ifp;
	struct ifg_group		*pfik_group;
	int				 pfik_states;
	int				 pfik_rules;
	int				 pfik_routes;
	TAILQ_HEAD(, pfi_dynaddr)	 pfik_dynaddrs;
};

enum pfi_kif_refs {
	PFI_KIF_REF_NONE,
	PFI_KIF_REF_STATE,
	PFI_KIF_REF_RULE,
	PFI_KIF_REF_ROUTE
};

#define PFI_IFLAG_SKIP		0x0100	/* skip filtering on interface */
#define PFI_IFLAG_ANY		0x0200	/* match any non-loopback interface */

/* flags for RDR options */
#define PF_DPORT_RANGE	0x01		/* Dest port uses range */
#define PF_RPORT_RANGE	0x02		/* RDR'ed port uses range */

/* Reasons code for passing/dropping a packet */
#define PFRES_MATCH	0		/* Explicit match of a rule */
#define PFRES_BADOFF	1		/* Bad offset for pull_hdr */
#define PFRES_FRAG	2		/* Dropping following fragment */
#define PFRES_SHORT	3		/* Dropping short packet */
#define PFRES_NORM	4		/* Dropping by normalizer */
#define PFRES_MEMORY	5		/* Dropped due to lacking mem */
#define PFRES_TS	6		/* Bad TCP Timestamp (RFC1323) */
#define PFRES_CONGEST	7		/* Congestion */
#define PFRES_IPOPTIONS 8		/* IP option */
#define PFRES_PROTCKSUM 9		/* Protocol checksum invalid */
#define PFRES_BADSTATE	10		/* State mismatch */
#define PFRES_STATEINS	11		/* State insertion failure */
#define PFRES_MAXSTATES	12		/* State limit */
#define PFRES_SRCLIMIT	13		/* Source node/conn limit */
#define PFRES_SYNPROXY	14		/* SYN proxy */
#define PFRES_TRANSLATE	15		/* No translation address available */
#define PFRES_NOROUTE	16		/* No route found for PBR action */
#define PFRES_MAX	17		/* total+1 */

#define PFRES_NAMES { \
	"match", \
	"bad-offset", \
	"fragment", \
	"short", \
	"normalize", \
	"memory", \
	"bad-timestamp", \
	"congestion", \
	"ip-option", \
	"proto-cksum", \
	"state-mismatch", \
	"state-insert", \
	"state-limit", \
	"src-limit", \
	"synproxy", \
	"translate", \
	"no-route", \
	NULL \
}

/* Counters for other things we want to keep track of */
#define LCNT_STATES		0	/* states */
#define LCNT_SRCSTATES		1	/* max-src-states */
#define LCNT_SRCNODES		2	/* max-src-nodes */
#define LCNT_SRCCONN		3	/* max-src-conn */
#define LCNT_SRCCONNRATE	4	/* max-src-conn-rate */
#define LCNT_OVERLOAD_TABLE	5	/* entry added to overload table */
#define LCNT_OVERLOAD_FLUSH	6	/* state entries flushed */
#define LCNT_MAX		7	/* total+1 */

#define LCNT_NAMES { \
	"max states per rule", \
	"max-src-states", \
	"max-src-nodes", \
	"max-src-conn", \
	"max-src-conn-rate", \
	"overload table insertion", \
	"overload flush states", \
	NULL \
}

/* UDP state enumeration */
#define PFUDPS_NO_TRAFFIC	0
#define PFUDPS_SINGLE		1
#define PFUDPS_MULTIPLE		2

#define PFUDPS_NSTATES		3	/* number of state levels */

#define PFUDPS_NAMES { \
	"NO_TRAFFIC", \
	"SINGLE", \
	"MULTIPLE", \
	NULL \
}

/* Other protocol state enumeration */
#define PFOTHERS_NO_TRAFFIC	0
#define PFOTHERS_SINGLE		1
#define PFOTHERS_MULTIPLE	2

#define PFOTHERS_NSTATES	3	/* number of state levels */

#define PFOTHERS_NAMES { \
	"NO_TRAFFIC", \
	"SINGLE", \
	"MULTIPLE", \
	NULL \
}

#define FCNT_STATE_SEARCH	0
#define FCNT_STATE_INSERT	1
#define FCNT_STATE_REMOVALS	2
#define FCNT_MAX		3

#define SCNT_SRC_NODE_SEARCH	0
#define SCNT_SRC_NODE_INSERT	1
#define SCNT_SRC_NODE_REMOVALS	2
#define SCNT_MAX		3

#define ACTION_SET(a, x) \
	do { \
		if ((a) != NULL) \
			*(a) = (x); \
	} while (0)

#define REASON_SET(a, x) \
	do { \
		if ((void *)(a) != NULL) { \
			*(a) = (x); \
			if (x < PFRES_MAX) \
				pf_status.counters[x]++; \
		} \
	} while (0)

struct pf_status {
	u_int64_t	counters[PFRES_MAX];
	u_int64_t	lcounters[LCNT_MAX];	/* limit counters */
	u_int64_t	fcounters[FCNT_MAX];
	u_int64_t	scounters[SCNT_MAX];
	u_int64_t	pcounters[2][2][3];
	u_int64_t	bcounters[2][2];
	u_int64_t	stateid;
	time_t		since;
	u_int32_t	running;
	u_int32_t	states;
	u_int32_t	src_nodes;
	u_int32_t	debug;
	u_int32_t	hostid;
	u_int32_t	reass;			/* reassembly */
	char		ifname[IFNAMSIZ];
	u_int8_t	pf_chksum[PF_MD5_DIGEST_LENGTH];
};

#define PF_REASS_ENABLED	0x01
#define PF_REASS_NODF		0x02

#define PF_PRIO_ZERO		0xff		/* match "prio 0" packets */

struct pf_queue_bwspec {
	u_int		absolute;
	u_int		percent;
};

struct pf_queue_scspec {
	struct pf_queue_bwspec	m1;
	struct pf_queue_bwspec	m2;
	u_int			d;
};

struct pf_queue_fqspec {
	u_int		flows;
	u_int		quantum;
	u_int		target;
	u_int		interval;
};

struct pf_queuespec {
	TAILQ_ENTRY(pf_queuespec)	 entries;
	char				 qname[PF_QNAME_SIZE];
	char				 parent[PF_QNAME_SIZE];
	char				 ifname[IFNAMSIZ];
	struct pf_queue_scspec		 realtime;
	struct pf_queue_scspec		 linkshare;
	struct pf_queue_scspec		 upperlimit;
	struct pf_queue_fqspec		 flowqueue;
	struct pfi_kif			*kif;
	u_int				 flags;
	u_int				 qlimit;
	u_int32_t			 qid;
	u_int32_t			 parent_qid;
};

#define PFQS_FLOWQUEUE			0x0001
#define PFQS_DEFAULT			0x1000 /* maps to HFSC_DEFAULTCLASS */

struct priq_opts {
	int		flags;
};

struct hfsc_opts {
	/* real-time service curve */
	u_int		rtsc_m1;	/* slope of the 1st segment in bps */
	u_int		rtsc_d;		/* the x-projection of m1 in msec */
	u_int		rtsc_m2;	/* slope of the 2nd segment in bps */
	/* link-sharing service curve */
	u_int		lssc_m1;
	u_int		lssc_d;
	u_int		lssc_m2;
	/* upper-limit service curve */
	u_int		ulsc_m1;
	u_int		ulsc_d;
	u_int		ulsc_m2;
	int		flags;
};

struct pfq_ops {
	void		*(*pfq_alloc)(struct ifnet *);
	int		 (*pfq_addqueue)(void *, struct pf_queuespec *);
	void		 (*pfq_free)(void *);
	int		 (*pfq_qstats)(struct pf_queuespec *, void *, int *);
};

struct pf_tagname {
	TAILQ_ENTRY(pf_tagname)	entries;
	char			name[PF_TAG_NAME_SIZE];
	u_int16_t		tag;
	int			ref;
};

struct pf_divert {
	struct pf_addr	addr;
	u_int16_t	port;
	u_int16_t	rdomain;
};

/* Fragment entries reference mbuf clusters, so base the default on that. */
#define PFFRAG_FRENT_HIWAT	(NMBCLUSTERS / 16) /* Number of entries */
#define PFFRAG_FRAG_HIWAT	(NMBCLUSTERS / 32) /* Number of packets */

#define PFR_KTABLE_HIWAT	1000	/* Number of tables */
#define PFR_KENTRY_HIWAT	200000	/* Number of table entries */
#define PFR_KENTRY_HIWAT_SMALL	100000	/* Number of entries for tiny hosts */

/*
 * ioctl parameter structures
 */

struct pfioc_rule {
	u_int32_t	 action;
	u_int32_t	 ticket;
	u_int32_t	 nr;
	char		 anchor[PATH_MAX];
	char		 anchor_call[PATH_MAX];
	struct pf_rule	 rule;
};

struct pfioc_natlook {
	struct pf_addr	 saddr;
	struct pf_addr	 daddr;
	struct pf_addr	 rsaddr;
	struct pf_addr	 rdaddr;
	u_int16_t	 rdomain;
	u_int16_t	 rrdomain;
	u_int16_t	 sport;
	u_int16_t	 dport;
	u_int16_t	 rsport;
	u_int16_t	 rdport;
	sa_family_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
};

struct pfioc_state {
	struct pfsync_state	state;
};

struct pfioc_src_node_kill {
	sa_family_t psnk_af;
	struct pf_rule_addr psnk_src;
	struct pf_rule_addr psnk_dst;
	u_int		    psnk_killed;
};

struct pfioc_state_kill {
	struct pf_state_cmp	psk_pfcmp;
	sa_family_t		psk_af;
	int			psk_proto;
	struct pf_rule_addr	psk_src;
	struct pf_rule_addr	psk_dst;
	char			psk_ifname[IFNAMSIZ];
	char			psk_label[PF_RULE_LABEL_SIZE];
	u_int			psk_killed;
	u_int16_t		psk_rdomain;
};

struct pfioc_states {
	int	ps_len;
	union {
		caddr_t			 psu_buf;
		struct pfsync_state	*psu_states;
	} ps_u;
#define ps_buf		ps_u.psu_buf
#define ps_states	ps_u.psu_states
};

struct pfioc_src_nodes {
	int	psn_len;
	union {
		caddr_t		 psu_buf;
		struct pf_src_node	*psu_src_nodes;
	} psn_u;
#define psn_buf		psn_u.psu_buf
#define psn_src_nodes	psn_u.psu_src_nodes
};

struct pfioc_tm {
	int		 timeout;
	int		 seconds;
};

struct pfioc_limit {
	int		 index;
	unsigned	 limit;
};

struct pfioc_ruleset {
	u_int32_t	 nr;
	char		 path[PATH_MAX];
	char		 name[PF_ANCHOR_NAME_SIZE];
};

struct pfioc_trans {
	int		 size;	/* number of elements */
	int		 esize; /* size of each element in bytes */
	struct pfioc_trans_e {
		int		type;
		char		anchor[PATH_MAX];
		u_int32_t	ticket;
	}		*array;
};

struct pfioc_queue {
	u_int32_t		ticket;
	u_int			nr;
	struct pf_queuespec	queue;
};

struct pfioc_qstats {
	u_int32_t		 ticket;
	u_int32_t		 nr;
	struct pf_queuespec	 queue;
	void			*buf;
	int			 nbytes;
};

#define PFR_FLAG_DUMMY		0x00000002
#define PFR_FLAG_FEEDBACK	0x00000004
#define PFR_FLAG_CLSTATS	0x00000008
#define PFR_FLAG_ADDRSTOO	0x00000010
#define PFR_FLAG_REPLACE	0x00000020
#define PFR_FLAG_ALLRSETS	0x00000040
#define PFR_FLAG_ALLMASK	0x0000007F
#ifdef _KERNEL
#define PFR_FLAG_USERIOCTL	0x10000000
#endif

struct pfioc_table {
	struct pfr_table	 pfrio_table;
	void			*pfrio_buffer;
	int			 pfrio_esize;
	int			 pfrio_size;
	int			 pfrio_size2;
	int			 pfrio_nadd;
	int			 pfrio_ndel;
	int			 pfrio_nchange;
	int			 pfrio_flags;
	u_int32_t		 pfrio_ticket;
};
#define	pfrio_exists	pfrio_nadd
#define	pfrio_nzero	pfrio_nadd
#define	pfrio_nmatch	pfrio_nadd
#define pfrio_naddr	pfrio_size2
#define pfrio_setflag	pfrio_size2
#define pfrio_clrflag	pfrio_nadd

struct pfioc_iface {
	char	 pfiio_name[IFNAMSIZ];
	void	*pfiio_buffer;
	int	 pfiio_esize;
	int	 pfiio_size;
	int	 pfiio_nzero;
	int	 pfiio_flags;
};


/*
 * ioctl operations
 */

#define DIOCSTART	_IO  ('D',  1)
#define DIOCSTOP	_IO  ('D',  2)
#define DIOCADDRULE	_IOWR('D',  4, struct pfioc_rule)
#define DIOCGETRULES	_IOWR('D',  6, struct pfioc_rule)
#define DIOCGETRULE	_IOWR('D',  7, struct pfioc_rule)
/* cut 8 - 17 */
#define DIOCCLRSTATES	_IOWR('D', 18, struct pfioc_state_kill)
#define DIOCGETSTATE	_IOWR('D', 19, struct pfioc_state)
#define DIOCSETSTATUSIF _IOWR('D', 20, struct pfioc_iface)
#define DIOCGETSTATUS	_IOWR('D', 21, struct pf_status)
#define DIOCCLRSTATUS	_IOWR('D', 22, struct pfioc_iface)
#define DIOCNATLOOK	_IOWR('D', 23, struct pfioc_natlook)
#define DIOCSETDEBUG	_IOWR('D', 24, u_int32_t)
#define DIOCGETSTATES	_IOWR('D', 25, struct pfioc_states)
#define DIOCCHANGERULE	_IOWR('D', 26, struct pfioc_rule)
/* cut 27 - 28 */
#define DIOCSETTIMEOUT	_IOWR('D', 29, struct pfioc_tm)
#define DIOCGETTIMEOUT	_IOWR('D', 30, struct pfioc_tm)
#define DIOCADDSTATE	_IOWR('D', 37, struct pfioc_state)
/* cut 38 */
#define DIOCGETLIMIT	_IOWR('D', 39, struct pfioc_limit)
#define DIOCSETLIMIT	_IOWR('D', 40, struct pfioc_limit)
#define DIOCKILLSTATES	_IOWR('D', 41, struct pfioc_state_kill)
/* cut 42 - 57 */
#define	DIOCGETRULESETS	_IOWR('D', 58, struct pfioc_ruleset)
#define	DIOCGETRULESET	_IOWR('D', 59, struct pfioc_ruleset)
#define	DIOCRCLRTABLES	_IOWR('D', 60, struct pfioc_table)
#define	DIOCRADDTABLES	_IOWR('D', 61, struct pfioc_table)
#define	DIOCRDELTABLES	_IOWR('D', 62, struct pfioc_table)
#define	DIOCRGETTABLES	_IOWR('D', 63, struct pfioc_table)
#define	DIOCRGETTSTATS	_IOWR('D', 64, struct pfioc_table)
#define DIOCRCLRTSTATS  _IOWR('D', 65, struct pfioc_table)
#define	DIOCRCLRADDRS	_IOWR('D', 66, struct pfioc_table)
#define	DIOCRADDADDRS	_IOWR('D', 67, struct pfioc_table)
#define	DIOCRDELADDRS	_IOWR('D', 68, struct pfioc_table)
#define	DIOCRSETADDRS	_IOWR('D', 69, struct pfioc_table)
#define	DIOCRGETADDRS	_IOWR('D', 70, struct pfioc_table)
#define	DIOCRGETASTATS	_IOWR('D', 71, struct pfioc_table)
#define DIOCRCLRASTATS  _IOWR('D', 72, struct pfioc_table)
#define	DIOCRTSTADDRS	_IOWR('D', 73, struct pfioc_table)
#define	DIOCRSETTFLAGS	_IOWR('D', 74, struct pfioc_table)
#define DIOCRINADEFINE	_IOWR('D', 77, struct pfioc_table)
#define DIOCOSFPFLUSH	_IO('D', 78)
#define DIOCOSFPADD	_IOWR('D', 79, struct pf_osfp_ioctl)
#define DIOCOSFPGET	_IOWR('D', 80, struct pf_osfp_ioctl)
#define DIOCXBEGIN      _IOWR('D', 81, struct pfioc_trans)
#define DIOCXCOMMIT     _IOWR('D', 82, struct pfioc_trans)
#define DIOCXROLLBACK   _IOWR('D', 83, struct pfioc_trans)
#define DIOCGETSRCNODES	_IOWR('D', 84, struct pfioc_src_nodes)
#define DIOCCLRSRCNODES	_IO('D', 85)
#define DIOCSETHOSTID	_IOWR('D', 86, u_int32_t)
#define DIOCIGETIFACES	_IOWR('D', 87, struct pfioc_iface)
#define DIOCSETIFFLAG	_IOWR('D', 89, struct pfioc_iface)
#define DIOCCLRIFFLAG	_IOWR('D', 90, struct pfioc_iface)
#define DIOCKILLSRCNODES	_IOWR('D', 91, struct pfioc_src_node_kill)
#define DIOCSETREASS	_IOWR('D', 92, u_int32_t)
#define DIOCADDQUEUE	_IOWR('D', 93, struct pfioc_queue)
#define DIOCGETQUEUES	_IOWR('D', 94, struct pfioc_queue)
#define DIOCGETQUEUE	_IOWR('D', 95, struct pfioc_queue)
#define DIOCGETQSTATS	_IOWR('D', 96, struct pfioc_qstats)

#ifdef _KERNEL

struct pf_pdesc;

RB_HEAD(pf_src_tree, pf_src_node);
RB_PROTOTYPE(pf_src_tree, pf_src_node, entry, pf_src_compare);
extern struct pf_src_tree tree_src_tracking;

RB_HEAD(pf_state_tree_id, pf_state);
RB_PROTOTYPE(pf_state_tree_id, pf_state,
    entry_id, pf_state_compare_id);
extern struct pf_state_tree_id tree_id;
extern struct pf_state_queue state_list;

TAILQ_HEAD(pf_queuehead, pf_queuespec);
extern struct pf_queuehead		  pf_queues[2];
extern struct pf_queuehead		 *pf_queues_active, *pf_queues_inactive;

extern u_int32_t		 ticket_pabuf;
extern struct pool		 pf_src_tree_pl, pf_sn_item_pl, pf_rule_pl;
extern struct pool		 pf_state_pl, pf_state_key_pl, pf_state_item_pl,
				    pf_rule_item_pl, pf_queue_pl;
extern struct pool		 pf_state_scrub_pl;
extern struct ifnet		*sync_ifp;
extern struct pf_rule		 pf_default_rule;

extern int			 pf_tbladdr_setup(struct pf_ruleset *,
				    struct pf_addr_wrap *);
extern void			 pf_tbladdr_remove(struct pf_addr_wrap *);
extern void			 pf_tbladdr_copyout(struct pf_addr_wrap *);
extern void			 pf_calc_skip_steps(struct pf_rulequeue *);
extern void			 pf_purge_thread(void *);
extern void			 pf_purge_expired_src_nodes();
extern void			 pf_purge_expired_states(u_int32_t);
extern void			 pf_purge_expired_rules();
extern void			 pf_remove_state(struct pf_state *);
extern void			 pf_remove_divert_state(struct pf_state_key *);
extern void			 pf_free_state(struct pf_state *);
extern int			 pf_state_insert(struct pfi_kif *,
				    struct pf_state_key **,
				    struct pf_state_key **,
				    struct pf_state *);
int				 pf_insert_src_node(struct pf_src_node **,
				    struct pf_rule *, enum pf_sn_types,
				    sa_family_t, struct pf_addr *,
				    struct pf_addr *);
void				 pf_remove_src_node(struct pf_src_node *);
struct pf_src_node		*pf_get_src_node(struct pf_state *,
				    enum pf_sn_types);
void				 pf_src_tree_remove_state(struct pf_state *);
void				 pf_state_rm_src_node(struct pf_state *,
				    struct pf_src_node *);

extern struct pf_state		*pf_find_state_byid(struct pf_state_cmp *);
extern struct pf_state		*pf_find_state_all(struct pf_state_key_cmp *,
				    u_int, int *);
extern void			 pf_state_export(struct pfsync_state *,
				    struct pf_state *);
extern void			 pf_print_state(struct pf_state *);
extern void			 pf_print_flags(u_int8_t);
extern void			 pf_addrcpy(struct pf_addr *, struct pf_addr *,
				    sa_family_t);
void				 pf_rm_rule(struct pf_rulequeue *,
				    struct pf_rule *);
void				 pf_purge_rule(struct pf_rule *);
struct pf_divert		*pf_find_divert(struct mbuf *);
int				 pf_setup_pdesc(struct pf_pdesc *, sa_family_t,
				    int, struct pfi_kif *, struct mbuf *,
				    u_short *);

int	pf_test(sa_family_t, int, struct ifnet *, struct mbuf **);

void	pf_poolmask(struct pf_addr *, struct pf_addr*,
	    struct pf_addr *, struct pf_addr *, sa_family_t);
void	pf_addr_inc(struct pf_addr *, sa_family_t);

void   *pf_pull_hdr(struct mbuf *, int, void *, int, u_short *, u_short *,
	    sa_family_t);
#define PF_HI (true)
#define PF_LO (!PF_HI)
#define PF_ALGNMNT(off) (((off) % 2) == 0 ? PF_HI : PF_LO)
int	pf_patch_8(struct pf_pdesc *, u_int8_t *, u_int8_t, bool);
int	pf_patch_16(struct pf_pdesc *, u_int16_t *, u_int16_t);
int	pf_patch_16_unaligned(struct pf_pdesc *, void *, u_int16_t, bool);
int	pf_patch_32(struct pf_pdesc *, u_int32_t *, u_int32_t);
int	pf_patch_32_unaligned(struct pf_pdesc *, void *, u_int32_t, bool);
int	pflog_packet(struct pf_pdesc *, u_int8_t, struct pf_rule *,
	    struct pf_rule *, struct pf_ruleset *, struct pf_rule *);
void	pf_send_deferred_syn(struct pf_state *);
int	pf_match_addr(u_int8_t, struct pf_addr *, struct pf_addr *,
	    struct pf_addr *, sa_family_t);
int	pf_match_addr_range(struct pf_addr *, struct pf_addr *,
	    struct pf_addr *, sa_family_t);
int	pf_match(u_int8_t, u_int32_t, u_int32_t, u_int32_t);
int	pf_match_port(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
int	pf_match_uid(u_int8_t, uid_t, uid_t, uid_t);
int	pf_match_gid(u_int8_t, gid_t, gid_t, gid_t);

int	pf_refragment6(struct mbuf **, struct m_tag *mtag,
	    struct sockaddr_in6 *, struct ifnet *, struct rtentry *);
void	pf_normalize_init(void);
int	pf_normalize_ip(struct pf_pdesc *, u_short *);
int	pf_normalize_ip6(struct pf_pdesc *, u_short *);
int	pf_normalize_tcp(struct pf_pdesc *);
void	pf_normalize_tcp_cleanup(struct pf_state *);
int	pf_normalize_tcp_init(struct pf_pdesc *, struct pf_state_peer *);
int	pf_normalize_tcp_stateful(struct pf_pdesc *, u_short *,
	    struct pf_state *, struct pf_state_peer *, struct pf_state_peer *,
	    int *);
int	pf_normalize_mss(struct pf_pdesc *, u_int16_t);
void	pf_scrub(struct mbuf *, u_int16_t, sa_family_t, u_int8_t, u_int8_t);
int32_t	pf_state_expires(const struct pf_state *);
void	pf_purge_expired_fragments(void);
int	pf_routable(struct pf_addr *addr, sa_family_t af, struct pfi_kif *,
	    int);
int	pf_rtlabel_match(struct pf_addr *, sa_family_t, struct pf_addr_wrap *,
	    int);
int	pf_socket_lookup(struct pf_pdesc *);
struct pf_state_key *pf_alloc_state_key(int);
int	pf_ouraddr(struct mbuf *);
void	pf_pkt_addr_changed(struct mbuf *);
struct inpcb *pf_inp_lookup(struct mbuf *);
void	pf_inp_link(struct mbuf *, struct inpcb *);
void	pf_inp_unlink(struct inpcb *);
int	pf_state_key_attach(struct pf_state_key *, struct pf_state *, int);
int	pf_translate(struct pf_pdesc *, struct pf_addr *, u_int16_t,
	    struct pf_addr *, u_int16_t, u_int16_t, int);
int	pf_translate_af(struct pf_pdesc *);
void	pf_route(struct pf_pdesc *, struct pf_rule *, struct pf_state *);
void	pf_route6(struct pf_pdesc *, struct pf_rule *, struct pf_state *);

void	pfr_initialize(void);
int	pfr_match_addr(struct pfr_ktable *, struct pf_addr *, sa_family_t);
void	pfr_update_stats(struct pfr_ktable *, struct pf_addr *,
	    struct pf_pdesc *, int, int);
int	pfr_pool_get(struct pf_pool *, struct pf_addr **,
	    struct pf_addr **, sa_family_t);
int	pfr_states_increase(struct pfr_ktable *, struct pf_addr *, int);
int	pfr_states_decrease(struct pfr_ktable *, struct pf_addr *, int);
struct pfr_kentry *
	pfr_kentry_byaddr(struct pfr_ktable *, struct pf_addr *, sa_family_t,
	    int);
void	pfr_dynaddr_update(struct pfr_ktable *, struct pfi_dynaddr *);
struct pfr_ktable *
	pfr_attach_table(struct pf_ruleset *, char *, int);
void	pfr_detach_table(struct pfr_ktable *);
int	pfr_clr_tables(struct pfr_table *, int *, int);
int	pfr_add_tables(struct pfr_table *, int, int *, int);
int	pfr_del_tables(struct pfr_table *, int, int *, int);
int	pfr_get_tables(struct pfr_table *, struct pfr_table *, int *, int);
int	pfr_get_tstats(struct pfr_table *, struct pfr_tstats *, int *, int);
int	pfr_clr_tstats(struct pfr_table *, int, int *, int);
int	pfr_set_tflags(struct pfr_table *, int, int, int, int *, int *, int);
int	pfr_clr_addrs(struct pfr_table *, int *, int);
int	pfr_insert_kentry(struct pfr_ktable *, struct pfr_addr *, time_t);
int	pfr_add_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_del_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_set_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, int *, int *, int, u_int32_t);
int	pfr_get_addrs(struct pfr_table *, struct pfr_addr *, int *, int);
int	pfr_get_astats(struct pfr_table *, struct pfr_astats *, int *, int);
int	pfr_clr_astats(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_tst_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_ina_begin(struct pfr_table *, u_int32_t *, int *, int);
int	pfr_ina_rollback(struct pfr_table *, u_int32_t, int *, int);
int	pfr_ina_commit(struct pfr_table *, u_int32_t, int *, int *, int);
int	pfr_ina_define(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, u_int32_t, int);

extern struct pfi_kif		*pfi_all;

void		 pfi_initialize(void);
struct pfi_kif	*pfi_kif_find(const char *);
struct pfi_kif	*pfi_kif_get(const char *);
void		 pfi_kif_ref(struct pfi_kif *, enum pfi_kif_refs);
void		 pfi_kif_unref(struct pfi_kif *, enum pfi_kif_refs);
int		 pfi_kif_match(struct pfi_kif *, struct pfi_kif *);
void		 pfi_attach_ifnet(struct ifnet *);
void		 pfi_detach_ifnet(struct ifnet *);
void		 pfi_attach_ifgroup(struct ifg_group *);
void		 pfi_detach_ifgroup(struct ifg_group *);
void		 pfi_group_change(const char *);
int		 pfi_match_addr(struct pfi_dynaddr *, struct pf_addr *,
		    sa_family_t);
int		 pfi_dynaddr_setup(struct pf_addr_wrap *, sa_family_t);
void		 pfi_dynaddr_remove(struct pf_addr_wrap *);
void		 pfi_dynaddr_copyout(struct pf_addr_wrap *);
void		 pfi_update_status(const char *, struct pf_status *);
int		 pfi_get_ifaces(const char *, struct pfi_kif *, int *);
int		 pfi_set_flags(const char *, int);
int		 pfi_clear_flags(const char *, int);
void		 pfi_xcommit(void);

int		 pf_match_tag(struct mbuf *, struct pf_rule *, int *);
u_int16_t	 pf_tagname2tag(char *, int);
void		 pf_tag2tagname(u_int16_t, char *);
void		 pf_tag_ref(u_int16_t);
void		 pf_tag_unref(u_int16_t);
void		 pf_tag_packet(struct mbuf *, int, int);
int		 pf_addr_compare(struct pf_addr *, struct pf_addr *,
		    sa_family_t);

extern struct pf_status	pf_status;
extern struct pool	pf_frent_pl, pf_frag_pl;

struct pf_pool_limit {
	void		*pp;
	unsigned	 limit;
	unsigned	 limit_new;
};
extern struct pf_pool_limit	pf_pool_limits[PF_LIMIT_MAX];

#endif /* _KERNEL */

extern struct pf_anchor_global	pf_anchors;
extern struct pf_anchor		pf_main_anchor;
#define pf_main_ruleset		pf_main_anchor.ruleset

struct tcphdr;

/* these ruleset functions can be linked into userland programs (pfctl) */
void			 pf_init_ruleset(struct pf_ruleset *);
int			 pf_anchor_setup(struct pf_rule *,
			    const struct pf_ruleset *, const char *);
int			 pf_anchor_copyout(const struct pf_ruleset *,
			    const struct pf_rule *, struct pfioc_rule *);
void			 pf_anchor_remove(struct pf_rule *);
void			 pf_remove_if_empty_ruleset(struct pf_ruleset *);
struct pf_anchor	*pf_find_anchor(const char *);
struct pf_ruleset	*pf_find_ruleset(const char *);
struct pf_ruleset	*pf_find_or_create_ruleset(const char *);
void			 pf_rs_initialize(void);

#ifdef _KERNEL
int			 pf_anchor_copyout(const struct pf_ruleset *,
			    const struct pf_rule *, struct pfioc_rule *);
void			 pf_anchor_remove(struct pf_rule *);
#endif /* _KERNEL */

/* The fingerprint functions can be linked into userland programs (tcpdump) */
int	pf_osfp_add(struct pf_osfp_ioctl *);
#ifdef _KERNEL
struct pf_osfp_enlist *
	pf_osfp_fingerprint(struct pf_pdesc *);
#endif /* _KERNEL */
struct pf_osfp_enlist *
	pf_osfp_fingerprint_hdr(const struct ip *, const struct ip6_hdr *,
	    const struct tcphdr *);
void	pf_osfp_flush(void);
int	pf_osfp_get(struct pf_osfp_ioctl *);
void	pf_osfp_initialize(void);
int	pf_osfp_match(struct pf_osfp_enlist *, pf_osfp_t);
struct pf_os_fingerprint *
	pf_osfp_validate(void);

#ifdef _KERNEL
void			 pf_print_host(struct pf_addr *, u_int16_t,
			    sa_family_t);
int			 pf_get_transaddr(struct pf_rule *, struct pf_pdesc *,
			    struct pf_src_node **, struct pf_rule **);
int			 pf_map_addr(sa_family_t, struct pf_rule *,
			    struct pf_addr *, struct pf_addr *,
			    struct pf_addr *, struct pf_src_node **,
			    struct pf_pool *, enum pf_sn_types);
int			 pf_postprocess_addr(struct pf_state *);

struct pf_state_key	*pf_state_key_ref(struct pf_state_key *);
void			 pf_state_key_unref(struct pf_state_key *);
int			 pf_state_key_isvalid(struct pf_state_key *);
void			 pf_pkt_unlink_state_key(struct mbuf *);
void			 pf_pkt_state_key_ref(struct mbuf *);

struct mbuf *		 pf_build_tcp(const struct pf_rule *, sa_family_t,
			    const struct pf_addr *, const struct pf_addr *,
			    u_int16_t, u_int16_t, u_int32_t, u_int32_t,
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t, int,
			    u_int16_t, u_int, u_int);
void			 pf_send_tcp(const struct pf_rule *, sa_family_t,
			    const struct pf_addr *, const struct pf_addr *,
			    u_int16_t, u_int16_t, u_int32_t, u_int32_t,
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t, int,
			    u_int16_t, u_int);
#endif /* _KERNEL */

#endif /* _NET_PFVAR_H_ */
@


1.456
log
@g/c DIOCCLRRULECTRS
kinda deprecated for a decade now, nothing in base uses it, nothing in
ports uses it (thanks sthen)
ok phessler sashan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.455 2017/05/30 08:10:01 henning Exp $ */
d1548 1
a1548 1
/* XXX cut 8 - 17 */
d1558 1
a1558 1
/* XXX cut 27 - 28 */
d1562 1
a1562 1
/* XXX cut 38 */
d1566 1
a1566 1
/* XXX cut 42 - 57 */
@


1.455
log
@teach pf_build_tcp() about SACK, ok & with sashan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.453 2017/05/15 12:26:00 mpi Exp $ */
d1562 1
a1562 1
#define DIOCCLRRULECTRS	_IO  ('D', 38)
@


1.454
log
@Fix bad white spaces, wrap long lines, kill some empty lines.
@
text
@d1884 1
a1884 1
			    u_int16_t, u_int);
@


1.453
log
@Enable the NET_LOCK(), take 3.

Recursions are still marked as XXXSMP.

ok deraadt@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.452 2017/05/15 11:23:25 mikeb Exp $ */
a182 1

d712 1
a712 1
	u_int8_t	 	 removed;
d978 2
a979 1
enum { PFR_OP_BLOCK, PFR_OP_MATCH, PFR_OP_PASS, PFR_OP_ADDR_MAX, PFR_OP_TABLE_MAX };
d1605 1
a1844 1

d1864 2
a1865 2
void			 pf_print_host(struct pf_addr *, u_int16_t, sa_family_t);

a1867 1

a1871 1

a1889 1

@


1.452
log
@Hook up FQ-CoDel to the tree and enable configuration in the pfctl(8)

OK sthen, visa
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.451 2017/05/02 12:27:37 mikeb Exp $ */
d1635 1
a1635 1
extern void			 pf_purge_expired_src_nodes(int);
d1637 1
a1637 1
extern void			 pf_purge_expired_rules(int);
a1810 1
extern struct rwlock	pf_consistency_lock;
@


1.451
log
@Provide pluggable queueing interface for pf

By hiding H-FSC behind pfq_ops structure similar to the ifq_ops,
we provide a possibility to plug alternative queueing interfaces
for use in pf.  This reduces amount of H-FSC specific code in the
pf ioctl handler

While here, change the the order of elements in hfsc_class_stats
to provide some compatibility between queue stat structures of
different traffic conditioners.

No objections from henning@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.450 2017/03/17 17:19:17 mpi Exp $ */
d1313 7
d1328 1
d1335 3
@


1.450
log
@Revert the NET_LOCK() and bring back pf's contention lock for release.

For the moment the NET_LOCK() is always taken by threads running under
KERNEL_LOCK().  That means it doesn't buy us anything except a possible
deadlock that we did not spot.  So make sure this doesn't happen, we'll
have plenty of time in the next release cycle to stress test it.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.449 2017/02/22 16:12:12 mpi Exp $ */
d1346 7
@


1.449
log
@Amend a misleading comment mentioning ``ipintrq''.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.448 2017/01/30 17:41:34 benno Exp $ */
d1617 1
a1617 1
extern void			 pf_purge_expired_src_nodes();
d1619 1
a1619 1
extern void			 pf_purge_expired_rules();
d1793 1
@


1.448
log
@removes the pf_consistency_lock and protects the users with
NET_LOCK().  pfioctl() will need the NET_LOCK() anyway. So better keep
things simple until we're going to redesign PF for a MP world.
fixes the crash reported by Kaya Saman.
ok mpi@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.447 2017/01/24 10:08:30 krw Exp $ */
d1171 1
a1171 1
#define PFRES_CONGEST	7		/* Congestion (of ipintrq) */
@


1.447
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.446 2016/12/29 13:01:48 bluhm Exp $ */
d1617 1
a1617 1
extern void			 pf_purge_expired_src_nodes(int);
d1619 1
a1619 1
extern void			 pf_purge_expired_rules(int);
a1792 1
extern struct rwlock	pf_consistency_lock;
@


1.446
log
@In pf_refragment6() use the valid route from pf_route6() instead
of calling rtalloc() again.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.445 2016/11/22 19:29:54 procter Exp $ */
d64 1
a64 1
#define	PF_REF_RELE(_x)	refcnt_rele(&(_x)) 
@


1.445
log
@Fold union pf_headers buffer into struct pf_pdesc (enabled by pfvar_priv.h).
Prevent pf_socket_lookup() reading uninitialised header buffers on fragments.
OK blum@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.444 2016/11/14 13:25:01 bluhm Exp $ */
d1684 1
a1684 1
	    struct sockaddr_in6 *, struct ifnet *);
@


1.444
log
@Instead of passing an extra mbuf pointer to pf_route(), it should
just use pd->m.  Then pf_test() can also operate on pd.m and set
the *m0 value in the caller just before it returns.
OK sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.443 2016/10/27 21:41:20 bluhm Exp $ */
d1651 3
a1653 3
int				 pf_setup_pdesc(struct pf_pdesc *, void *,
				    sa_family_t, int, struct pfi_kif *,
				    struct mbuf *, u_short *);
@


1.443
log
@Pass a struct pf_pdesc to pf_route() like it is done in the other
pf functions.  That means less parameters, more consistency and
later we can call functions that need a pd from pf_route().
OK sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.442 2016/10/26 21:07:22 bluhm Exp $ */
d1713 2
a1714 4
void	pf_route(struct mbuf **, struct pf_pdesc *, struct pf_rule *,
	    struct pf_state *);
void	pf_route6(struct mbuf **, struct pf_pdesc *, struct pf_rule *,
	    struct pf_state *);
@


1.442
log
@Put union pf_headers and struct pf_pdesc into separate header file
pfvar_priv.h.  The pf_headers had to be defined in multiple .c files
before.  In pfvar.h it would have unknown storage size, this file
is included in too many places.  The idea is to have a private pf
header that is only included in the pf part of the kernel.  For now
it contains pf_pdesc and pf_headers, it may be extended later.
discussion, input and OK henning@@ procter@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.441 2016/10/18 13:28:01 henning Exp $ */
d1713 4
a1716 4
void	pf_route(struct mbuf **, struct pf_rule *, int,
	    struct ifnet *, struct pf_state *);
void	pf_route6(struct mbuf **, struct pf_rule *, int,
	   struct ifnet *, struct pf_state *);
@


1.441
log
@split pf_send_tcp() into the part that builds the mbuf and the actual
sending, needed soon. ok sashan mikeb lteo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.440 2016/09/27 04:57:17 dlg Exp $ */
a1158 57
struct pf_pdesc {
	struct {
		int	 done;
		uid_t	 uid;
		gid_t	 gid;
		pid_t	 pid;
	}		 lookup;
	u_int64_t	 tot_len;	/* Make Mickey money */
	union {
		struct tcphdr		*tcp;
		struct udphdr		*udp;
		struct icmp		*icmp;
#ifdef INET6
		struct icmp6_hdr	*icmp6;
#endif /* INET6 */
		void			*any;
	} hdr;

	struct pf_addr	 nsaddr;	/* src address after NAT */
	struct pf_addr	 ndaddr;	/* dst address after NAT */

	struct pfi_kif	*kif;		/* incoming interface */
	struct mbuf	*m;		/* mbuf containing the packet */
	struct pf_addr	*src;		/* src address */
	struct pf_addr	*dst;		/* dst address */
	u_int16_t	*pcksum;	/* proto cksum */
	u_int16_t	*sport;
	u_int16_t	*dport;
	u_int16_t	 osport;
	u_int16_t	 odport;
	u_int16_t	 nsport;	/* src port after NAT */
	u_int16_t	 ndport;	/* dst port after NAT */

	u_int32_t	 off;		/* protocol header offset */
	u_int32_t	 hdrlen;	/* protocol header length */
	u_int32_t	 p_len;		/* length of protocol payload */
	u_int32_t	 extoff;	/* extentsion header offset */
	u_int32_t	 fragoff;	/* fragment header offset */
	u_int32_t	 jumbolen;	/* length from v6 jumbo header */
	u_int32_t	 badopts;	/* v4 options or v6 routing headers */

	u_int16_t	 rdomain;	/* original routing domain */
	u_int16_t	 virtual_proto;
#define PF_VPROTO_FRAGMENT	256
	sa_family_t	 af;
	sa_family_t	 naf;
	u_int8_t	 proto;
	u_int8_t	 tos;
	u_int8_t	 ttl;
	u_int8_t	 dir;		/* direction */
	u_int8_t	 sidx;		/* key index for source */
	u_int8_t	 didx;		/* key index for destination */
	u_int8_t	 destchg;	/* flag set when destination changed */
	u_int8_t	 pflog;		/* flags for packet logging */
};


d1587 2
d1809 2
@


1.440
log
@roll back turning RB into RBT until i get better at this process.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.439 2016/09/27 02:51:12 dlg Exp $ */
d1919 11
@


1.439
log
@move pf from the RB macros to the RBT functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.438 2016/09/03 17:11:40 sashan Exp $ */
d622 1
a622 1
	RBT_ENTRY(pf_src_node)	 entry;
d685 1
a685 1
/* keep synced with struct pf_state_key, used in RBT_FIND */
d708 1
a708 1
	RBT_ENTRY(pf_state_key)	 entry;
d719 1
a719 1
/* keep synced with struct pf_state, used in RBT_FIND */
d735 1
a735 1
	RBT_ENTRY(pf_state)	 entry_id;
d919 2
a920 2
RBT_HEAD(pf_anchor_global, pf_anchor);
RBT_HEAD(pf_anchor_node, pf_anchor);
d922 2
a923 2
	RBT_ENTRY(pf_anchor)	 entry_global;
	RBT_ENTRY(pf_anchor)	 entry_node;
d932 2
a933 2
RBT_PROTOTYPE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare)
RBT_PROTOTYPE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare)
d1083 1
a1083 1
RBT_HEAD(pfr_ktablehead, pfr_ktable);
d1086 1
a1086 1
	RBT_ENTRY(pfr_ktable)	 pfrkt_tree;
d1112 2
a1113 2
RBT_HEAD(pf_state_tree, pf_state_key);
RBT_PROTOTYPE(pf_state_tree, pf_state_key, entry, pf_state_compare_key)
d1115 2
a1116 2
RBT_HEAD(pf_state_tree_ext_gwy, pf_state_key);
RBT_PROTOTYPE(pf_state_tree_ext_gwy, pf_state_key,
d1119 1
a1119 1
RBT_HEAD(pfi_ifhead, pfi_kif);
d1124 1
a1124 1
/* keep synced with pfi_kif, used in RBT_FIND */
d1134 1
a1134 1
	RBT_ENTRY(pfi_kif)		 pfik_tree;
d1644 2
a1645 2
RBT_HEAD(pf_src_tree, pf_src_node);
RBT_PROTOTYPE(pf_src_tree, pf_src_node, entry, pf_src_compare);
d1648 2
a1649 2
RBT_HEAD(pf_state_tree_id, pf_state);
RBT_PROTOTYPE(pf_state_tree_id, pf_state,
d1845 2
a1846 2
int		 pf_addr_compare(const struct pf_addr *,
		    const struct pf_addr *, sa_family_t);
@


1.438
log
@Let purge thread to remove once rules, not packets.
Thanks mikeb@@ for idea to add expire time.

OK mpi@@, OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.437 2016/09/03 14:34:13 bluhm Exp $ */
d622 1
a622 1
	RB_ENTRY(pf_src_node)	 entry;
d685 1
a685 1
/* keep synced with struct pf_state_key, used in RB_FIND */
d708 1
a708 1
	RB_ENTRY(pf_state_key)	 entry;
d719 1
a719 1
/* keep synced with struct pf_state, used in RB_FIND */
d735 1
a735 1
	RB_ENTRY(pf_state)	 entry_id;
d919 2
a920 2
RB_HEAD(pf_anchor_global, pf_anchor);
RB_HEAD(pf_anchor_node, pf_anchor);
d922 2
a923 2
	RB_ENTRY(pf_anchor)	 entry_global;
	RB_ENTRY(pf_anchor)	 entry_node;
d932 2
a933 2
RB_PROTOTYPE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare)
RB_PROTOTYPE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare)
d1083 1
a1083 1
RB_HEAD(pfr_ktablehead, pfr_ktable);
d1086 1
a1086 1
	RB_ENTRY(pfr_ktable)	 pfrkt_tree;
d1112 2
a1113 2
RB_HEAD(pf_state_tree, pf_state_key);
RB_PROTOTYPE(pf_state_tree, pf_state_key, entry, pf_state_compare_key)
d1115 2
a1116 2
RB_HEAD(pf_state_tree_ext_gwy, pf_state_key);
RB_PROTOTYPE(pf_state_tree_ext_gwy, pf_state_key,
d1119 1
a1119 1
RB_HEAD(pfi_ifhead, pfi_kif);
d1124 1
a1124 1
/* keep synced with pfi_kif, used in RB_FIND */
d1134 1
a1134 1
	RB_ENTRY(pfi_kif)		 pfik_tree;
d1644 2
a1645 2
RB_HEAD(pf_src_tree, pf_src_node);
RB_PROTOTYPE(pf_src_tree, pf_src_node, entry, pf_src_compare);
d1648 2
a1649 2
RB_HEAD(pf_state_tree_id, pf_state);
RB_PROTOTYPE(pf_state_tree_id, pf_state,
d1845 2
a1846 2
int		 pf_addr_compare(struct pf_addr *, struct pf_addr *,
		    sa_family_t);
@


1.437
log
@Reduce the factor of the limits derived form NMBCLUSTERS.  We want
the additional clusters in the socket buffer and not elsewhere.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.436 2016/08/20 08:34:30 procter Exp $ */
d574 4
d596 1
d1674 1
d1704 1
a1704 3
void				 pf_purge_rule(struct pf_ruleset *,
				    struct pf_rule *, struct pf_ruleset *,
				    struct pf_rule *);
@


1.436
log
@Push 'field changed' guards into 'change field' functions;
optimise pf_patch_32(); simplify pf_match_addr()
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.435 2016/08/17 03:24:12 procter Exp $ */
d1414 2
a1415 2
#define PFFRAG_FRENT_HIWAT	(NMBCLUSTERS / 4) /* Number of entries */
#define PFFRAG_FRAG_HIWAT	(NMBCLUSTERS / 8) /* Number of packets */
@


1.435
log
@Reintroduce 5.3-style checksum modification to preserve end-to-end checksums
when fiddling with packets but without the mess that motivated Henning to
remove it. Affects only this one aspect of Henning's checksum work. Also tweak
the basic algorithm and supply a correctness argument.

OK dlg@@ deraadt@@ sthen@@; no objection henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.434 2016/07/19 13:30:51 henning Exp $ */
d1717 5
a1721 5
void	pf_patch_8(struct pf_pdesc *, u_int8_t *, u_int8_t, bool);
void	pf_patch_16(struct pf_pdesc *, u_int16_t *, u_int16_t);
void	pf_patch_16_unaligned(struct pf_pdesc *, void *, u_int16_t, bool);
void	pf_patch_32(struct pf_pdesc *, u_int32_t *, u_int32_t);
void	pf_patch_32_unaligned(struct pf_pdesc *, void *, u_int32_t, bool);
@


1.434
log
@don't hide globals between function prototypes; ok phessler benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.433 2016/07/18 19:11:18 henning Exp $ */
a1207 4
	u_int8_t	 csum_status;	/* proto cksum ok/bad/unchecked */
#define	PF_CSUM_UNKNOWN	0
#define	PF_CSUM_BAD	1
#define	PF_CSUM_OK	2
d1714 8
a1721 3
void	pf_change_a(struct pf_pdesc *, void *, u_int32_t);
int	pf_check_proto_cksum(struct pf_pdesc *, int, int, u_int8_t,
	    sa_family_t);
a1908 2

void			 pf_cksum(struct pf_pdesc *, struct mbuf *);
@


1.433
log
@no more cbq_opts - CBQ is gone, ok mpi phessler benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.431 2016/03/29 10:34:42 sashan Exp $ */
d1658 7
a1669 4
extern struct pool		 pf_src_tree_pl, pf_sn_item_pl, pf_rule_pl;
extern struct pool		 pf_state_pl, pf_state_key_pl, pf_state_item_pl,
				    pf_rule_item_pl, pf_queue_pl;
extern struct pool		 pf_state_scrub_pl;
a1697 3

extern struct ifnet		*sync_ifp;
extern struct pf_rule		 pf_default_rule;
@


1.432
log
@Hide pf internals by moving code from in_ouraddr() to pf_ouraddr().
OK mpi@@ sashan@@
@
text
@a1383 12
struct cbq_opts {
	u_int		minburst;
	u_int		maxburst;
	u_int		pktsize;
	u_int		maxpktsize;
	u_int		ns_per_byte;
	u_int		maxidle;
	int		minidle;
	u_int		offtime;
	int		flags;
};

@


1.431
log
@- packet must keep reference to statekey
  this is the second attempt to get it in, the first
  attempt got backed out on Jan 31 2016

  the change also contains fixes contributed by Stefan Kempf
  in earlier iteration.

OK srhen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.430 2016/01/31 00:18:07 sashan Exp $ */
d1766 1
@


1.430
log
@- m_pkthdr.pf.statekey changes are not ready for 5.9, I must back them out

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.428 2015/12/23 21:04:55 jasper Exp $ */
d41 3
d61 5
d707 2
d1922 6
a1928 1

@


1.429
log
@- retrying to commit earlier change, which got backed out

    - yet another tiny step towards MP PF. This time we need to make sure
      statekey attached to packet stays around, while accepted packet is
      routed through IP stack.

  this time I'm also bringing fix contributed by Stefan Kempf. Stefan's fix
  makes sure we grab reference in m_dup_pkthdr()

OK bluhm@@
@
text
@a40 3
#include <sys/refcnt.h>

#include <netinet/in.h>
a57 5
typedef struct refcnt	pf_refcnt_t;
#define	PF_REF_INIT(_x)	refcnt_init(&(_x))
#define	PF_REF_TAKE(_x)	refcnt_take(&(_x))
#define	PF_REF_RELE(_x)	refcnt_rele(&(_x)) 

a698 2
	pf_refcnt_t		 refcnt;
	u_int8_t	 	 removed;
d1912 1
a1912 5
struct pf_state_key	*pf_state_key_ref(struct pf_state_key *);
void			 pf_state_key_unref(struct pf_state_key *);
int			 pf_state_key_isvalid(struct pf_state_key *);
void			 pf_pkt_unlink_state_key(struct mbuf *);
void			 pf_pkt_state_key_ref(struct mbuf *);
a1913 1
#endif /* _KERNEL */
@


1.428
log
@revert previous:
----------------------------------------------------------------------
revision 1.961
date: 2015/12/22 13:33:26;  author: sashan;  state: Exp;  lines: +153 -44;
commitid: oBRhtWcDV0ThviVT;
- yet another tiny step towards MP PF. This time we need to make sure
  statekey attached to packet stays around, while accepted packet is
  routed through IP stack.

OK mpi@@, henning@@
----------------------------------------------------------------------

there have been multiple reports of KASSERT(!pf_state_key_isvalid(sk)) being
triggered without much effort, so back this out for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.426 2015/12/03 14:05:28 bluhm Exp $ */
d41 3
d61 5
d707 2
d1922 6
a1928 1

@


1.427
log
@- yet another tiny step towards MP PF. This time we need to make sure
  statekey attached to packet stays around, while accepted packet is
  routed through IP stack.

OK mpi@@, henning@@
@
text
@a40 3
#include <sys/refcnt.h>

#include <netinet/in.h>
a57 5
typedef struct refcnt	pf_refcnt_t;
#define	PF_REF_INIT(_x)	refcnt_init(&(_x))
#define	PF_REF_TAKE(_x)	refcnt_take(&(_x))
#define	PF_REF_RELE(_x)	refcnt_rele(&(_x)) 

a698 2
	pf_refcnt_t		 refcnt;
	u_int8_t	 	 removed;
d1912 1
a1912 4
struct pf_state_key	*pf_state_key_ref(struct pf_state_key *);
void			 pf_state_key_unref(struct pf_state_key *);
int			 pf_state_key_isvalid(struct pf_state_key *);
void			 pf_pkt_unlink_state_key(struct mbuf *);
a1913 1
#endif /* _KERNEL */
@


1.426
log
@To avoid that the stack manipules the pf statekeys directly, introduce
pf_inp_...() lookup, link and unlink functions as an interface.
Locking can be added to them later.  Remove the first linking at
the beginning of tcp_input() and udp_input() as it is not necessary.
It will be done later anyway.  That code was a relict, from the
time before I had added the second linking.
Input from mikeb@@ and sashan@@;  OK sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.425 2015/12/03 09:49:15 bluhm Exp $ */
d41 3
d61 5
d707 2
d1922 5
a1927 1

@


1.425
log
@Rename pf_unlink_state() to pf_remove_state() so the name does not
collide with the statekey to inp unlinking.
OK sashan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.424 2015/12/02 16:00:42 sashan Exp $ */
d1757 3
@


1.424
log
@- hide PF internals to pf_unlink_divert_state() from in_pcb.c

OK mpi@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.423 2015/11/20 03:35:23 dlg Exp $ */
d1672 2
a1673 2
extern void			 pf_unlink_state(struct pf_state *);
extern void			 pf_unlink_divert_state(struct pf_state_key *);
@


1.423
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.422 2015/10/30 11:33:55 mikeb Exp $ */
d1673 1
@


1.422
log
@Clean up handling of 'clear states' pfsync packets.

If interface was specified in the packet only if-bound states
attached to this interface must be purged.

ok mpi, looked at by sasha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.421 2015/10/13 19:32:32 sashan Exp $ */
a1659 3
extern int			 pf_free_queues(struct pf_queuehead *,
				    struct ifnet *);
extern int			 pf_remove_queues(struct ifnet *);
@


1.421
log
@- pf_insert_src_node(): global argument (arg6) is useless, function
  always gets pointer to rule.

- pf_remove_src_node(): function should always remove matching src node,
  regardless the sn->rule.ptr being NULL or valid rule

- sn->rule.ptr is never NULL, spotted by mpi and Richard Procter _von_ gmail.com

OK mpi@@, OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.420 2015/08/19 21:22:41 sashan Exp $ */
d1813 1
@


1.420
log
@PF must keep IPv6 fragment size as chosen by sender also for packets,
which are routed on behalf route-to action.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.419 2015/07/20 01:18:33 mcbride Exp $ */
d1684 1
a1684 1
				    struct pf_addr *, int);
@


1.419
log
@INET6 is here to stay, so stop hauling around never-compiled code
to optimize for an INET-only kernel, as well as the fantasy unicorn
INET6-only kernel. (INET-only kernel still works)

prompted by deraadt
ok bluhm sashan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.418 2015/07/19 01:58:19 sashan Exp $ */
d1737 2
a1738 1
int	pf_refragment6(struct mbuf **, struct m_tag *mtag);
@


1.418
log
@unused arguments at pf_normalize_tcp_init() and pf_refragment6()

OK deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.417 2015/07/17 19:46:05 sashan Exp $ */
a227 21
#ifdef _KERNEL
#ifndef INET6
#define PF_INET_ONLY
#endif /* ! INET6 */

#ifdef INET6
#endif /* INET6 */

#ifdef INET6
#define PF_INET_INET6
#endif /* INET6 */

#else

#define PF_INET_INET6

#endif /* _KERNEL */

/* Both IPv4 and IPv6 */
#ifdef PF_INET_INET6

a261 70
#else

/* Just IPv6 */

#ifdef PF_INET6_ONLY

#define PF_AEQ(a, b, c) \
	((a)->addr32[3] == (b)->addr32[3] && \
	(a)->addr32[2] == (b)->addr32[2] && \
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[0] == (b)->addr32[0]) \

#define PF_ANEQ(a, b, c) \
	((a)->addr32[3] != (b)->addr32[3] || \
	(a)->addr32[2] != (b)->addr32[2] || \
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[0] != (b)->addr32[0]) \

#define PF_AZERO(a, c) \
	(!(a)->addr32[0] && \
	!(a)->addr32[1] && \
	!(a)->addr32[2] && \
	!(a)->addr32[3] ) \

#define PF_MATCHA(n, a, m, b, f) \
	pf_match_addr(n, a, m, b, f)

#define PF_ACPY(a, b, f) \
	pf_addrcpy(a, b, f)

#define PF_AINC(a, f) \
	pf_addr_inc(a, f)

#define PF_POOLMASK(a, b, c, d, f) \
	pf_poolmask(a, b, c, d, f)

#else

/* Just IPv4 */
#ifdef PF_INET_ONLY

#define PF_AEQ(a, b, c) \
	((a)->addr32[0] == (b)->addr32[0])

#define PF_ANEQ(a, b, c) \
	((a)->addr32[0] != (b)->addr32[0])

#define PF_AZERO(a, c) \
	(!(a)->addr32[0])

#define PF_MATCHA(n, a, m, b, f) \
	pf_match_addr(n, a, m, b, f)

#define PF_ACPY(a, b, f) \
	(a)->v4.s_addr = (b)->v4.s_addr

#define PF_AINC(a, f) \
	do { \
		(a)->addr32[0] = htonl(ntohl((a)->addr32[0]) + 1); \
	} while (0)

#define PF_POOLMASK(a, b, c, d, f) \
	do { \
		(a)->addr32[0] = ((b)->addr32[0] & (c)->addr32[0]) | \
		(((c)->addr32[0] ^ 0xffffffff ) & (d)->addr32[0]); \
	} while (0)

#endif /* PF_INET_ONLY */
#endif /* PF_INET6_ONLY */
#endif /* PF_INET_INET6 */
@


1.417
log
@sa_family_t should not be confused with u_int8_t

ok deraadt@@, ok floarian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.416 2015/07/16 21:14:21 mpi Exp $ */
d1828 1
a1828 1
int	pf_refragment6(struct mbuf **, struct m_tag *mtag, int);
d1834 1
a1834 2
int	pf_normalize_tcp_init(struct pf_pdesc *, struct pf_state_peer *,
	    struct pf_state_peer *);
@


1.416
log
@Kill IP_ROUTETOETHER.

This pseudo-option is a hack to support return-rst on bridge(4).  It
passes Ethernet information via a "struct route" through ip_output().

"struct route" is slowly dying...

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.415 2015/06/05 13:22:34 mikeb Exp $ */
d1794 1
a1794 1
				    u_int8_t);
d1987 1
a1987 1
void			 pf_print_host(struct pf_addr *, u_int16_t, u_int8_t);
@


1.415
log
@Improve error handling and recovery during state insertion

Reshuffle the code around a bit and greatly improve error handling
fixing a few bugs along the way.

Problem reported by and fix was written with Alexandr Nedvedicky.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.414 2015/04/11 13:00:12 dlg Exp $ */
a1257 2
	struct ether_header
			*eh;
d1805 1
a1805 2
int	pf_test(sa_family_t, int, struct ifnet *, struct mbuf **,
	    struct ether_header *);
@


1.414
log
@the hfsc pools are only used in hfsc.c, so move the init of them
there instead of pf_ioctl.c.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.413 2015/02/15 10:40:53 sthen Exp $ */
d1319 2
a1320 1
#define PFRES_MAX	16		/* total+1 */
d1339 1
@


1.413
log
@Rather than using 0xff as a placeholder for "don't check prio", use 0xff to
mean "prio is 0". This avoids the need for code changes in programs which add
pf rules (as was done in pfctl but not other programs) to handle the new
"check prio" functionality. Specifically this unbreaks ftp-proxy.

Use of #define rather than magic 0xff suggested by benno.
ok benno "if henning doesnt like it he can change it when he recovers from jet-lag"

(this file missed from previous commit, noticed by daniel@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.412 2015/02/12 01:24:10 henning Exp $ */
a1762 2
extern struct pool		 hfsc_class_pl, hfsc_classq_pl,
				    hfsc_internal_sc_pl;
@


1.412
log
@change log(matches) semantics slightly to make it more useful. since it
is a debug tool change of semantics not considered problematic.
up until now, log(matches) forced logging on subsequent matching rules,
the actual logging used the log settings from that matched rule.
now, log(matches) causes subsequent matches to be logged with the log settings
from the log(matches) rule. in particular (this was the driving point),
log(matches, to pflog23) allows you to have the trace log going to a seperate
pflog interface, not clobbering your regular pflogs, actually not affecting
them at all.
long conversation with bluhm about it, which didn't lead to a single bit
changed in the diff but was very very helpful. ok bluhm as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.408 2015/01/24 00:29:06 deraadt Exp $ */
d1436 2
@


1.411
log
@include the "set prio" values.
no real compat issue since we're using spare bytes.
old -> new ends up with set prio (0, 0) equivalent
new -> old is entirely harmless, old ignores the prios.
requested by Alexey Suslikov <alexey.suslikov at gmail>
ok phessler pelikan dlg
@
text
@d1818 1
a1818 1
	    struct pf_rule *, struct pf_ruleset *);
@


1.410
log
@since we inherit prio (as in, the queuing priority) from outside sources,
i. e. on vlan interfaces, it is useful to be able to match on it -
effectively matching on classification done elsewhere.
i thought i had long implemented that, but chrisz@@ asking for it made
me notice that wasn't the case.
tests by chrisz, ok phessler pelikan
@
text
@d918 1
a918 1
	u_int8_t	 pad[2];
@


1.409
log
@make RB_PROTOTYPE usage ISO C compliant by removing useless semicolons

fixes some compiler warnings, tested by amd64 base build

ok beck
@
text
@d647 1
d651 1
a651 1
	u_int8_t		 pad[3];
@


1.408
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.407 2015/01/15 23:56:58 deraadt Exp $ */
d1007 2
a1008 2
RB_PROTOTYPE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare);
RB_PROTOTYPE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare);
d1188 1
a1188 1
RB_PROTOTYPE(pf_state_tree, pf_state_key, entry, pf_state_compare_key);
d1192 1
a1192 1
    entry_ext_gwy, pf_state_compare_ext_gwy);
@


1.407
log
@Stop including <sys/param.h> and other stuff.  Assume this will be included
with sys limits in scope, so use PATH_MAX instead.
ok millert guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.406 2014/12/23 03:24:08 tedu Exp $ */
a43 2
#include <netinet/ip_ipsp.h>
#include <netinet/tcp_fsm.h>
d1085 11
d1099 1
a1099 1
	union sockaddr_union	 _pfrke_sa;
@


1.406
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.405 2014/12/19 13:04:08 reyk Exp $ */
a36 2
#include <sys/param.h>
#include <sys/types.h>
d40 1
d1004 1
a1004 1
	char			 path[MAXPATHLEN];
d1027 1
a1027 1
	char			 pfrt_anchor[MAXPATHLEN];
d1514 2
a1515 2
	char		 anchor[MAXPATHLEN];
	char		 anchor_call[MAXPATHLEN];
d1590 1
a1590 1
	char		 path[MAXPATHLEN];
d1599 1
a1599 1
		char		anchor[MAXPATHLEN];
@


1.405
log
@Support source-hash and random with tables and dynifs; not just pools.
This finally allows to use source-hash for dynamic loadbalancing, eg.
"rdr-to <hosts> source-hash", instead of just round-robin and least-states.

An older pre-siphash version of this diff was tested by many people.

OK tedu@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.404 2014/12/19 05:36:28 tedu Exp $ */
a231 1
#ifdef INET
a234 1
#endif /* INET */
a236 3
#ifndef INET
#define PF_INET6_ONLY
#endif /* ! INET */
a238 1
#ifdef INET
a241 1
#endif /* INET */
@


1.404
log
@add messages to #error so we know what's what (and so unifdef doesn't poop)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.403 2014/09/08 18:10:01 bluhm Exp $ */
d120 6
@


1.403
log
@When logging a packet to a listener on the pflog0 interface, the
function pflog_bpfcopy() is setting up a packet description with
pf_setup_pdesc().  When pf_setup_pdesc() is droppig a bad packet,
it increments the the pf status counters.  This way bad packets
could be accounted multiple times.  Now pflog_bpfcopy() passes a
reason pointer NULL to indicate that no accounting should be done.
From Florian Riehm; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.402 2014/08/12 15:29:33 mikeb Exp $ */
d57 1
a57 1
#error
@


1.402
log
@Finally implement what's stated in the man page regarding parent
anchors for "once" rules: "In case this is the only rule in the
anchor, the anchor will be destroyed automatically after the rule
is matched."  Employ an additional pointer pair to keep track of
the parent ruleset containing the anchor that we want to remove.

OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.401 2014/07/02 13:02:08 mikeb Exp $ */
d1400 1
a1400 1
		if ((void *)(a) != NULL) \
d1402 3
a1404 2
		if (x < PFRES_MAX) \
			pf_status.counters[x]++; \
@


1.401
log
@better indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.400 2014/06/25 16:21:20 mikeb Exp $ */
d1789 1
@


1.400
log
@pf_translate doesn't use the mbuf argument anymore.

From Alexandr Nedvedicky <alexandr ! nedvedicky at oracle ! com>.  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.399 2014/04/22 14:41:03 mpi Exp $ */
d1937 3
a1939 3
extern struct pf_anchor_global  pf_anchors;
extern struct pf_anchor        pf_main_anchor;
#define pf_main_ruleset	pf_main_anchor.ruleset
@


1.399
log
@Remove some altq tentacles.

ok pelikan@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.398 2014/04/19 12:59:53 henning Exp $ */
d1843 1
a1843 1
	    struct pf_addr *, u_int16_t, u_int16_t, int, struct mbuf *);
@


1.398
log
@shrink pf by 445 lines.
while there, get rid of the altq ioctls and assciated now obsolete code
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.397 2014/01/21 01:50:07 henning Exp $ */
a1485 28
struct pf_altq {
	char			 ifname[IFNAMSIZ];

	void			*altq_disc;	/* discipline-specific state */
	TAILQ_ENTRY(pf_altq)	 entries;

	/* scheduler spec */
	u_int8_t		 scheduler;	/* scheduler type */
	u_int16_t		 tbrsize;	/* tokenbucket regulator size */
	u_int32_t		 ifbandwidth;	/* interface bandwidth */

	/* queue spec */
	char			 qname[PF_QNAME_SIZE];	/* queue name */
	char			 parent[PF_QNAME_SIZE];	/* parent name */
	u_int32_t		 parent_qid;	/* parent queue id */
	u_int32_t		 bandwidth;	/* queue bandwidth */
	u_int8_t		 priority;	/* priority */
	u_int16_t		 qlimit;	/* queue size limit */
	u_int16_t		 flags;		/* misc flags */
	union {
		struct cbq_opts		 cbq_opts;
		struct priq_opts	 priq_opts;
		struct hfsc_opts	 hfsc_opts;
	} pq_u;

	u_int32_t		 qid;		/* return value */
};

a1588 15
struct pfioc_altq {
	u_int32_t	 action;
	u_int32_t	 ticket;
	u_int32_t	 nr;
	struct pf_altq	 altq;
};

struct pfioc_altqstats {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	void		*buf;
	int		 nbytes;
	u_int8_t	 scheduler;
};

a1738 6
TAILQ_HEAD(pf_altqqueue, pf_altq);
extern struct pf_altqqueue		  pf_altqs[2];

extern u_int32_t		 ticket_altqs_active;
extern u_int32_t		 ticket_altqs_inactive;
extern int			 altqs_inactive_open;
a1739 2
extern struct pf_altqqueue	*pf_altqs_active;
extern struct pf_altqqueue	*pf_altqs_inactive;
d1750 1
a1750 1
				    pf_altq_pl, pf_rule_item_pl, pf_queue_pl;
@


1.397
log
@introduce a way to match "any" interface, excluding loopback ones.
pfi_kif_get annotates the kif with a flag indicating it is the "any" match
pfi_kif_match obeys that flag
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.396 2014/01/20 02:57:50 henning Exp $ */
d1721 1
a1721 1
/* XXX cut 26 - 28 */
d1729 1
a1729 8
#define DIOCSTARTALTQ	_IO  ('D', 42)
#define DIOCSTOPALTQ	_IO  ('D', 43)
#define DIOCADDALTQ	_IOWR('D', 45, struct pfioc_altq)
#define DIOCGETALTQS	_IOWR('D', 47, struct pfioc_altq)
#define DIOCGETALTQ	_IOWR('D', 48, struct pfioc_altq)
#define DIOCCHANGEALTQ	_IOWR('D', 49, struct pfioc_altq)
#define DIOCGETALTQSTATS	_IOWR('D', 50, struct pfioc_altqstats)
/* XXX cut 51 - 57 */
@


1.396
log
@support negated matches on the rcvif, ok dlg benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.394 2014/01/03 12:43:09 pelikan Exp $ */
d1225 1
@


1.395
log
@Switch frequently allocated structs from malloc(M_DEVBUF) to separate pools.

ok henning, "looks fine" mikeb, input from guenther.
@
text
@d653 2
@


1.394
log
@Make queues disappear correctly on interfaces being destroyed.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.393 2013/12/22 16:49:29 deraadt Exp $ */
d1807 2
@


1.393
log
@change pf_osfp_entry strings to unsigned, to help userland
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.392 2013/11/19 17:30:08 mikeb Exp $ */
d1795 3
@


1.392
log
@provide forward declarations for structures ifnet and ifg_group;
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.391 2013/10/12 12:13:11 henning Exp $ */
d438 3
a440 3
	char			fp_class_nm[PF_OSFP_LEN];
	char			fp_version_nm[PF_OSFP_LEN];
	char			fp_subtype_nm[PF_OSFP_LEN];
@


1.391
log
@new bandwidth shaping subsystem, kernel side
uses hfsc behind the scenes; altq stays in parallel for a migration phase.
if.h even more messy for the transition, but eventuelly it should become
readable...
looked over & tested by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.390 2013/10/12 11:55:46 henning Exp $ */
d1194 3
@


1.390
log
@give tagname2tag and its siblings an extra "create" parameter. if 1, it
behaves like before and creates the mapping if needed. if 0, lookup only.
looked over by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.389 2013/07/23 22:47:10 bluhm Exp $ */
d5 1
a5 1
 * Copyright (c) 2002 - 2010 Henning Brauer
d1422 26
d1618 1
a1618 1
struct pfioc_qstats {
d1642 14
d1729 1
a1729 1
#define DIOCGETQSTATS	_IOWR('D', 50, struct pfioc_qstats)
d1763 4
d1779 4
d1799 1
a1799 1
				    pf_altq_pl, pf_rule_item_pl;
@


1.389
log
@Do not reset the fragment timeout each time a fragment arrives.
Start the expire counter when the queue is created by the first
fragment and drop it if the packet could not be reassembled within
60 seconds.
Reported by Antonios Atlasis; OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.388 2013/07/05 13:07:58 blambert Exp $ */
d1915 1
a1915 1
u_int16_t	 pf_tagname2tag(char *);
@


1.388
log
@Collect and display 'match' counters for pf tables.

While here, fix pf table displays to fit within 80 chars.

Manpage input jmc@@

ok henning@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.387 2013/07/04 00:19:01 guenther Exp $ */
d102 1
a102 1
#define PFTM_FRAG_VAL			30	/* Fragment expire */
@


1.387
log
@Re-commit: use time_t for storing time_t values.  This is an ABI
change for pf, but that's fine at this time.  You'll need to rebuild
pf userland after updating your kernel.

change to 'since' member ok henning@@
rest ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.386 2013/07/02 05:57:37 guenther Exp $ */
d1056 1
a1056 1
enum { PFR_OP_BLOCK, PFR_OP_PASS, PFR_OP_ADDR_MAX, PFR_OP_TABLE_MAX };
d1851 2
a1852 2
void	pfr_update_stats(struct pfr_ktable *, struct pf_addr *, sa_family_t,
	    u_int64_t, int, int, int);
@


1.386
log
@Revert previous: sizeof(time_t) != sizeof(long) on LP64, so there was
an ABI change involved.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.385 2013/07/02 01:42:01 guenther Exp $ */
d1063 1
a1063 1
	long		 pfras_tzero;
d1074 1
a1074 1
	long		 pfrts_tzero;
d1093 1
a1093 1
	long			 _pfrke_tzero;
d1200 1
a1200 1
	u_int32_t			 pfik_tzero;
d1408 1
a1411 1
	u_int32_t	since;
d1872 1
a1872 1
int	pfr_insert_kentry(struct pfr_ktable *, struct pfr_addr *, long);
@


1.385
log
@Use time_t for storing time_t values.  No change to the underlying
type**, so no ABI change.

ok henning@@ deraadt@@

** ...yet
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.384 2013/06/26 09:12:39 henning Exp $ */
d1063 1
a1063 1
	time_t		 pfras_tzero;
d1074 1
a1074 1
	time_t		 pfrts_tzero;
d1093 1
a1093 1
	time_t			 _pfrke_tzero;
d1200 1
a1200 1
	time_t				 pfik_tzero;
d1872 1
a1872 1
int	pfr_insert_kentry(struct pfr_ktable *, struct pfr_addr *, time_t);
@


1.384
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.383 2013/06/04 19:03:12 henning Exp $ */
d1063 1
a1063 1
	long		 pfras_tzero;
d1074 1
a1074 1
	long		 pfrts_tzero;
d1093 1
a1093 1
	long			 _pfrke_tzero;
d1200 1
a1200 1
	u_int32_t			 pfik_tzero;
d1872 1
a1872 1
int	pfr_insert_kentry(struct pfr_ktable *, struct pfr_addr *, long);
@


1.383
log
@add a pointer to the protocol checksum header field to pf_pdesc and set
it up in pf_setup_pdesc(). ok ryan benno mikeb bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.380 2013/06/01 21:18:02 henning Exp $ */
d1277 4
d1283 1
a1779 2
extern u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t,
				    u_int8_t);
d1803 3
a1805 1
void	pf_change_a(void *, u_int16_t *, u_int32_t, u_int8_t);
d1842 1
a1842 1
	    struct pf_addr *, u_int16_t, u_int16_t, int);
d1988 2
@


1.382
log
@put back the match member to the anchor stack struct - userland (pfctl)
uses it. that is so incedibly wrong...
sorry for the breakage, folks. found by tedu, SMSing me out of my breakfast
bob
@
text
@d1248 1
@


1.381
log
@fix anchor quick with nested anchors. we lost the quick flag as soon as
we stepped into a child anchor.
simplify the logic, get rid of the match flag in the anchor stack, just
use the match variable we already had (and used in a boolean style) to track
the nest level we had a match at. when a child anchor had a match we also
have a match in the current anchor, so update the match level accordingly,
and thus correctly honour the quick flag.
reported by, along with the right idea on how to fix this, by Sean Gallagher
\sean at teletech.com.au/, who also helped testing the fix. ok ryan & benno
@
text
@d1007 1
@


1.380
log
@pf_step_{into,out_of}_anchor() are only ever called from pf_test_rule()
these days, so:
-move the prototypes from pfvar.h to pf.c
-remove the now useless null point checks for *match, it is always provided
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.378 2013/05/03 15:33:47 florian Exp $ */
a1006 1
	int			 match;
@


1.379
log
@Since pf_state_key_attach can decide to free the provided state
key we need to sync our state key pointers with whatever values
the function will pick.  Not doing so will produce wrong results
if address translation must be applied afterwards and we happen
to have a state key collision.  Then pf_translate will follow an
old pointer and punch in garbage addresses into the packet.

Noticed, initial patch and tests by Vitaly Sinilin <vs @@ kp4 ! ru>
ok tedu, henning
@
text
@a1972 6
void			 pf_step_into_anchor(int *, struct pf_ruleset **,
			    struct pf_rule **, struct pf_rule **, int *);
int			 pf_step_out_of_anchor(int *, struct pf_ruleset **,
			     struct pf_rule **, struct pf_rule **,
			     int *);

@


1.378
log
@Export ingress/egress interface index in pflow(4).
Report that this is needed for some netflow collector and tests by
Chris Ivancic & Colin Ligertwood.

OK mikeb@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.377 2013/03/11 19:48:40 sthen Exp $ */
d1753 2
a1754 2
				    struct pf_state_key *,
				    struct pf_state_key *,
@


1.377
log
@Add a separate "translation" counter and use this rather than "memory"
when address translation fails due to no free ports in the configured range.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.376 2013/01/17 00:48:04 henning Exp $ */
d854 2
@


1.376
log
@first or second coming, commie or not commie, one m in coming is sufficient
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.374 2012/11/06 12:32:41 henning Exp $ */
d1296 2
a1297 1
#define PFRES_MAX	15		/* total+1 */
d1315 1
@


1.375
log
@pass pf_pool directly to pfr_pool_get(); simplifies the API;
ok henning@@, zinke@@, mikeb@@
@
text
@d1240 1
a1240 1
	struct pfi_kif	*kif;		/* incomming interface */
@


1.374
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.373 2012/11/01 07:55:56 henning Exp $ */
d1843 2
a1844 4
int	pfr_pool_get(struct pfr_ktable *, int *, struct pf_addr *,
	    struct pf_addr **, struct pf_addr **, struct pfi_kif **,
	    u_int64_t *, u_int16_t *, int *,
	    sa_family_t, int (*)(sa_family_t, struct pf_addr *));
@


1.373
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.371 2012/10/08 17:41:55 camield Exp $ */
d1770 2
d1795 1
a1795 1
void	pf_change_a(void *, u_int32_t);
d1832 1
a1832 1
	    struct pf_addr *, u_int16_t, u_int16_t, int, struct mbuf *);
a1985 2

void			 pf_cksum(struct pf_pdesc *, struct mbuf *);
@


1.372
log
@Use time_uptime for expiration values as time_second can be skewed at
runtime while time_uptime is monotonic. Prevent underflows in
pfsync(4) and pflow(4) by using signed variables.  pfsync(4) problem
pointed out by camield.

Diff originally by dlg, frag and pflow bits by me.

feedback dlg
man page tweak jmc

Various versions of the pflow bits tested by Hrvoje Popovski
(hrvoje AT srce DOT hr), thanks!

ok benno, henning, dlg
@
text
@a1769 2
extern u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t,
				    u_int8_t);
d1793 1
a1793 1
void	pf_change_a(void *, u_int16_t *, u_int32_t, u_int8_t);
d1830 1
a1830 1
	    struct pf_addr *, u_int16_t, u_int16_t, int);
d1984 2
@


1.371
log
@Forward declare struct m_tag in netinet/ip_ipsp.h so we don't need to
include sys/mbuf.h in net/pfvar.h.

Flagged by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.370 2012/10/05 12:32:27 camield Exp $ */
d711 2
a712 2
	u_int32_t		 creation;
	u_int32_t		 expire;
d826 3
a828 3
	u_int32_t		 creation;
	u_int32_t		 expire;
	u_int32_t		 pfsync_time;
d1821 1
a1821 2
u_int32_t
	pf_state_expires(const struct pf_state *);
@


1.370
log
@include sys/mbuf.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.369 2012/09/20 09:43:49 camield Exp $ */
a37 1
#include <sys/mbuf.h>
@


1.369
log
@Lower pf frags limit to not risk running out of mbuf clusters
when dealing with lots of IP fragments.

This sets the default to 25% of the mbuf cluster maximum (hint
from beck).  And the example in the manpage is sane now.

ok mikeb henning beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.368 2012/09/18 10:11:53 henning Exp $ */
d38 1
@


1.368
log
@prio 0 is valid, therefore, I chose an "impossible" value for prio meaning
"not set" and used a PF_PRIO_NOTSET define for it. now that means that
everything that creates a struct pf_rule doesn't get away with bzero'ing it,
which turned out to be not so nice. so get rid of PF_PRIO_NOTSET, instead,
make a rule+state flag PFSTATE_SETPRIO which indicates wether the prio
should be set. ok benno claudio mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.366 2012/07/13 11:14:04 henning Exp $ */
d1485 3
a1487 4
#define PFFRAG_FRENT_HIWAT	5000	/* Number of fragment entries */
#define PFFRAG_FRAG_HIWAT	1000	/* Number of fragmented packets */
#define PFFRAG_FRCENT_HIWAT	50000	/* Number of fragment cache entries */
#define PFFRAG_FRCACHE_HIWAT	10000	/* Number of fragment descriptors */
@


1.367
log
@rename all_state_flags to state_flags to finish the transition
to the 16 bit flags;  reminded by claudio, ok henning
@
text
@a650 1
#define PF_PRIO_NOTSET		0xff
d842 1
d844 1
@


1.366
log
@remove confuzzling comment
:dlg: the xxx can go
...and this time commit to the real repo and not the one on my laptop
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.362 2012/02/03 01:57:51 bluhm Exp $ */
d909 1
a909 1
	u_int8_t	 state_flags; /* XXX remove after 5.0 */
d915 1
a915 1
	u_int16_t	 all_state_flags;
@


1.365
log
@define a PFSTATE_SCRUBMASK. relying on numeric order of flags is stupid
and bound to break sooner or later.
@
text
@a846 2

	/* XXX */
a847 1

@


1.364
log
@rename prio in struct pf_rule and related structs to set_prio so it is
utterly clear this is not a filter criteria but a packet modification thing.
also preparation for upcoming changes, including one to unscrew this mess
(I should not have to touch half the tree for this - ifixitlater)
not user visible, ok gcc
@
text
@d843 1
@


1.363
log
@Fix kernel compilation with pf but without pfsync pseudo-device by
moving the state export functionality from pfsync code into pf.
Based on the initial diff diff by guenther, ok henning.
@
text
@d534 1
a534 1
	u_int8_t	prio[2];
d652 1
a652 1
	u_int8_t		 prio[2];
d853 1
a854 1
	u_int8_t		 prio[2];
@


1.362
log
@The kernel did not compile without INET6.  Put some #ifdefs into
pf to fix that.
- add #ifdef INET6 in obvious places
- af translation is only possible with both INET and INET6
- interleave #endif /* INET6 */ and closing brace correctly
- it is not necessary to #ifdef function prototypes
- do not compile af translate functions at all instead of empty stub,
  then the linker will report inconsistencies
- pf_poolmask() actually takes an sa_family_t not an u_int8_t argument
No binary change for GENERIC compiled with -O2 and -UDIAGNOSTIC.
reported by Olivier Cochard-Labbe; ok mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.361 2012/01/26 20:16:06 bluhm Exp $ */
d1768 2
@


1.361
log
@Clean up the pf normalization code:
- Let pf_normalize_ip() and pf_normalize_ip6() take the struct
  pf_pdesc pd as argument.
- Always check wether the mbuf got NULL after normalization to make
  the code more robust.
- Make the code structure of pf_normalize_ip6() more like
  pf_normalize_ip() to make the differences obvious.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.360 2012/01/16 16:38:01 bluhm Exp $ */
a1788 1
#ifdef INET6
d1790 1
a1790 1
	    struct pf_addr *, struct pf_addr *, u_int8_t);
a1791 1
#endif /* INET6 */
@


1.360
log
@Pass struct pf_pdesc to pf_walk_option6() and pf_walk_header6() to
make their argument list shorter.  Also fix a bug where pf_walk_option6()
used the outer header in the pd2 case.
ok henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.359 2012/01/15 22:55:35 bluhm Exp $ */
d1812 2
a1813 2
int	pf_normalize_ip(struct mbuf **, int, u_short *);
int	pf_normalize_ip6(struct mbuf **, int, int, int, u_short *);
@


1.359
log
@Calling pf_normalize_ip() from pf_setup_pdesc() was bad as the
latter is called from pf packet logging.  This resulted in normalization
and reassembly of bad packets to be logged.  So rearrange the code
and move the call to pf_test().
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.358 2011/12/12 21:30:27 mikeb Exp $ */
d1259 1
@


1.358
log
@fixup af-to regression with match rules

pfctl should not infer the af-to behavior from the af/naf difference.
instead, we should be clear that this is an af-to rule.  essentially
this change converts FOM_AFTO marker into a rule flag PFRULE_AFTO so
that we don't rely on ambiguous checks (like r->af != r->naf) when
setting things up.

positive review and comments from claudio, ok henning, sperreault
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.357 2011/11/29 10:17:52 dlg Exp $ */
d1257 2
d1783 1
a1783 1
				    struct mbuf **, u_short *, u_short *);
@


1.357
log
@use a u_int64_t for the state id in pfsync_state. this makes it consistent
with every other thing that stores the state id (including other pfsync
messages).

includes improvements to the systat code to consider the creatorid as well
as the state id in its cache to avoid collisions between states created on
different hosts.

tested by me in production and on amd64 talking to sparc64.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.356 2011/11/28 01:04:50 dlg Exp $ */
d676 1
@


1.356
log
@deprecate PFTM_UNTIL_PACKET. nothing in the tree uses it, and
pf_state_expires() handled it incorrectly.

discussed with mikeb@@
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.355 2011/11/26 03:28:46 mcbride Exp $ */
d890 1
a890 1
	u_int32_t	 id[2];
@


1.355
log
@Apply route-to to deferred packet; without this the first packet of a
connection does not observe the route-to option.

ok dlg mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.354 2011/10/13 18:23:40 claudio Exp $ */
d85 1
a85 2
	  PFTM_TS_DIFF, PFTM_MAX, PFTM_PURGE, PFTM_UNLINKED,
	  PFTM_UNTIL_PACKET };
@


1.354
log
@Since the IPv6 madness is not enough introduce NAT64 -- which is actually
"af-to" a generic IP version translator for pf(4).
Not everything perfect yet but lets fix these things in the tree.
Insane amount of work done by sperreault@@, mikeb@@ and reyk@@.
Looked over by mcbride@@ henning@@ and myself at eurobsdcon.
OK mcbride@@ and general put it in from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.353 2011/10/07 17:10:08 henning Exp $ */
d1834 4
@


1.353
log
@rename some vars and functions
unfortunately altq is one giant namespace violation. rename just those that
conflict with new stuff for now only to be found on my laptop. reduce pain,
the diff is huge already. ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.352 2011/10/07 14:02:48 henning Exp $ */
d64 1
a64 1
	  PF_MATCH, PF_DIVERT, PF_RT };
d654 1
a654 1
	u_int8_t		 pad;
d715 1
d793 3
d1263 1
d1266 1
d1833 1
@


1.352
log
@pf_poolqueue is long dead, remove corpses. from eurobsdcon, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.350 2011/09/22 14:57:12 bluhm Exp $ */
a1900 3
u_int32_t	 pf_qname2qid(char *);
void		 pf_qid2qname(u_int32_t, char *);
void		 pf_qid_unref(u_int32_t);
@


1.351
log
@As requested by henning, move the mbuf pointer into struct pf_pdesc.
Also sort pd to the beginning of the functions' parameter lists for
consistency.
ok henning
@
text
@a1717 1
TAILQ_HEAD(pf_poolqueue, pf_pool);
a1726 2
extern struct pf_poolqueue	*pf_pools_active;
extern struct pf_poolqueue	*pf_pools_inactive;
@


1.350
log
@As I have touched half of pf lines anyway, fix whitespaces now.
KNF, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.349 2011/09/20 10:51:18 bluhm Exp $ */
d1238 1
d1776 2
a1777 2
int				 pf_setup_pdesc(sa_family_t, int,
				    struct pfi_kif *, struct pf_pdesc *, void *,
d1792 2
a1793 2
int	pflog_packet(struct mbuf *, u_int8_t, struct pf_rule *,
	    struct pf_rule *, struct pf_ruleset *, struct pf_pdesc *);
d1808 1
a1808 1
int	pf_normalize_tcp(struct mbuf *, struct pf_pdesc *);
d1810 6
a1815 6
int	pf_normalize_tcp_init(struct mbuf *, struct pf_pdesc *,
	    struct pf_state_peer *, struct pf_state_peer *);
int	pf_normalize_tcp_stateful(struct mbuf *, struct pf_pdesc *,
	    u_short *, struct pf_state *, struct pf_state_peer *,
	    struct pf_state_peer *, int *);
int	pf_normalize_mss(struct mbuf *, struct pf_pdesc *, u_int16_t);
d1951 1
a1951 1
	pf_osfp_fingerprint(struct pf_pdesc *, struct mbuf *);
@


1.349
log
@Put kif and dir into pdesc an use this instead of passing the values
around.  This is a mechanical change.  Initialize pd2 and use it
where appropriate.
ok henning on an earlier version; ok mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.348 2011/09/19 12:51:52 bluhm Exp $ */
d199 1
a199 1
 
d413 1
a413 1
	struct pf_addr	 	 counter;
d418 1
a418 1
	int		 	 curweight;
d824 1
a824 1
	u_int32_t	 	 expire;
d931 1
a931 1
		(d)->scrub.pfss_flags = 				\
d947 1
a947 1
	if ((s)->scrub.scrub_flag == PFSYNC_SCRUB_FLAG_VALID && 	\
d1102 1
a1102 1
		struct _pfr_kentry	_ke;	
d1483 1
a1483 1
#define PFR_KENTRY_HIWAT_SMALL	100000	/* Number of table entries (tiny hosts) */
@


1.348
log
@Consolidate pf function parameters.  Move off and hdrlen into pdesc
and change their type from int to u_int32_t.  Do not pass struct
tcphdr *th and sa_family_t af, it is in pd anyway.  Do not use af
and pd->af intermixed, the latter makes clear where it comes from.
Do not calculate the packet length again if pd already has it.  Use
pd2.off instead of off2.
go go go go don't stop henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.347 2011/09/18 13:50:13 bluhm Exp $ */
d1237 1
d1776 2
a1777 2
				    struct pf_pdesc *, void *, struct mbuf **,
				    u_short *, u_short *);
d1791 2
a1792 3
int	pflog_packet(struct pfi_kif *, struct mbuf *, u_int8_t,
	    u_int8_t, struct pf_rule *, struct pf_rule *, struct pf_ruleset *,
	    struct pf_pdesc *);
d1807 1
a1807 1
int	pf_normalize_tcp(int, struct mbuf *, struct pf_pdesc *);
d1812 2
a1813 2
	    u_short *, struct pf_state *,
	    struct pf_state_peer *, struct pf_state_peer *, int *);
d1823 1
a1823 1
int	pf_socket_lookup(int, struct pf_pdesc *);
@


1.347
log
@Move the pdesc initialization code into pf_setup_pdesc().  Unify
some IPv4 and IPv6 code.  Make sure that both code paths set the
same fields in the same order.
ok mpf henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.346 2011/09/18 10:40:55 bluhm Exp $ */
d1248 3
a1250 1
	u_int32_t	 p_len;		/* total length of payload */
d1776 1
a1776 1
				    u_short *, u_short *, int *, int *);
d1807 1
a1807 1
int	pf_normalize_tcp(int, struct mbuf *, int, struct pf_pdesc *);
d1809 4
a1812 4
int	pf_normalize_tcp_init(struct mbuf *, int, struct pf_pdesc *,
	    struct tcphdr *, struct pf_state_peer *, struct pf_state_peer *);
int	pf_normalize_tcp_stateful(struct mbuf *, int, struct pf_pdesc *,
	    u_short *, struct tcphdr *, struct pf_state *,
d1814 1
a1814 1
int	pf_normalize_mss(struct mbuf *, int, struct pf_pdesc *, u_int16_t);
d1950 1
a1950 2
	pf_osfp_fingerprint(struct pf_pdesc *, struct mbuf *, int,
	    const struct tcphdr *);
@


1.346
log
@Move the call to pf_test_rule() for fragments that have not been
reassembled by normalization from pf_setup_pdesc() to pf_test().
This simplifies the paramter list of pf_setup_pdesc() as it can
concentrate on its job filling the pf_pdesc struct.
ok henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.345 2011/09/17 16:01:55 bluhm Exp $ */
d1773 1
a1773 1
				    struct pf_pdesc *, struct mbuf **,
@


1.345
log
@The pd->ip_sum and pd->proto_sum fields are not needed.  Replace
the one occurrence in pf_test_state_icmp() that uses pd2.ip_sum by
a local variable.  Remove ip_sum and proto_sum from struct pf_pdesc.
ok claudio henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.344 2011/08/30 00:40:47 mikeb Exp $ */
d1774 1
a1774 4
				    u_short *, u_short *, struct pfi_kif *,
				    struct pf_rule **, struct pf_rule **,
				    struct pf_state **, struct pf_ruleset **,
				    int *, int *);
@


1.344
log
@Add support for one shot rules that remove themselves from an active
ruleset after match.  In case this is the only rule in the anchor,
the anchor will be destroyed automatically after the rule is matched.
This is an extremely handy technique for firewall proxies.

ok henning, mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.343 2011/08/03 00:01:30 dlg Exp $ */
a1249 3

	u_int16_t	*ip_sum;
	u_int16_t	*proto_sum;
@


1.343
log
@someone (*cough*henning*cough*) made pf_state.state_flags a u_int16_t
without growing it in pfsync_state too.

to keep the wire format compat this uses some of the pad bytes to send
all the state flags on the wire as well as maintaining the old state_flags
field. after 5.0 we'll deprecate the original field and only use the new
one.

discussed with mcbride and deraadt and based on a diff from deraadt.
tested against an "old" pfsync locally.
ok mcbride@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.342 2011/08/02 13:13:57 mcbride Exp $ */
d676 1
d1771 2
@


1.342
log
@Replace one byte of padding with sa_family_t af in pfsync_state_key;
Reject states with pfsync_state->af == 0 in pfsync_state_import(), in
preparation for states which specify an address family in each state key
instead (change will take place post-5.0).

ok dlg henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.341 2011/07/27 00:26:10 mcbride Exp $ */
d906 1
a906 1
	u_int8_t	 state_flags;
d912 2
a913 1
	u_int8_t	 pad[4];
@


1.341
log
@Add support for weighted round-robin in load balancing pools and tables.
Diff from zinke@@ with a some minor cleanup.
ok henning claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.340 2011/07/08 18:50:52 henning Exp $ */
d881 2
a882 1
	u_int8_t	 pad[2];
@


1.340
log
@surprisingly, we use pf as classifier for the new priority queueing
implementation. ok ryan mpf sthen and also testing pea and halex looked
at it and commented as well
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.339 2011/07/07 20:46:37 bluhm Exp $ */
d396 1
d417 3
a419 1
	u_int32_t		 states;
a1012 1
#define PFR_TFLAG_COST		0x00000080
d1014 1
a1014 1
#define PFR_TFLAG_USRMASK	0x000000C3
d1016 1
a1016 1
#define PFR_TFLAG_ALLMASK	0x000000FF
d1036 1
d1076 1
d1128 1
a1128 1
	u_int32_t		 states;
d1153 3
d1835 2
a1836 1
	    u_int32_t *, sa_family_t, int (*)(sa_family_t, struct pf_addr *));
d1972 1
a1972 1
			    struct pf_src_node **);
@


1.339
log
@There were two loops in pf_setup_pdesc() and pf_normalize_ip6()
walking over the IPv6 header chain.  Merge them into one loop,
adjust some length checks and fix IPv6 jumbo option handling.  Also
allow strange but legal IPv6 packets with plen=0 passing through
pf.  IPv6 jumbo packets still get dropped.
testing dhill@@; ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.338 2011/07/07 00:47:19 mcbride Exp $ */
d528 1
d532 2
a533 2
	u_int8_t	pad[1];
	u_int16_t	flags;
d649 3
a651 1
	u_int8_t		 pad2[3];
d846 2
@


1.338
log
@Fold pf_test_fragment() into pf_test_rule(), reduce code and fixes
a bunch of bugs with fragment handling not being in sync with the
rest of the ruleset.

Much feedback from mpf, bluhm & markus
Thanks to Tony Sarendal for help with testing

ok bluhm; various previous versions ok henning, claudio, mpf, markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.337 2011/07/04 18:12:51 bluhm Exp $ */
d1793 1
a1793 1
int	pf_normalize_ip6(struct mbuf **, int, u_short *);
@


1.337
log
@Rename the pf_pdesc field rh_cnt to badopts as it is also used for
IPv4 options now.
ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.336 2011/07/04 06:54:49 claudio Exp $ */
d551 2
a552 2
#define PF_SKIP_SRC_PORT	6
#define PF_SKIP_DST_ADDR	7
d1240 2
d1762 2
a1763 1
				    struct pf_ruleset **, int *, int *);
@


1.336
log
@Bye bye pf_test6(). Only one pf_test function for both IPv4 and v6.
The functions were 95% identical anyway. While there use struct pf_addr
in struct pf_divert instead of some union which is the same.
OK bluhm@@ mcbride@@ and most probably henning@@ as well
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.335 2011/07/03 23:37:55 zinke Exp $ */
d1234 1
a1234 1
	u_int32_t	 rh_cnt;	/* # of routing headers */
@


1.335
log
@bring in least-states load balancing algorithm

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.334 2011/06/21 08:59:47 bluhm Exp $ */
d1454 1
a1454 4
	union {
		struct in_addr	ipv4;
		struct in6_addr	ipv6;
	}		addr;
d1762 2
a1763 3
#ifdef INET
int	pf_test(int, struct ifnet *, struct mbuf **, struct ether_header *);
#endif /* INET */
a1765 1
int	pf_test6(int, struct ifnet *, struct mbuf **, struct ether_header *);
@


1.334
log
@There is no need to handle fragmented TCP reset packets in a special
way.  Remove PFDESC_IP_REAS and pf_pdesc flags completely.
ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.333 2011/06/20 19:03:41 claudio Exp $ */
d113 1
a113 1
	  PF_POOL_SRCHASH, PF_POOL_ROUNDROBIN };
d416 1
d808 1
d1005 1
d1007 1
a1007 1
#define PFR_TFLAG_USRMASK	0x00000043
d1009 1
a1009 1
#define PFR_TFLAG_ALLMASK	0x0000007F
d1028 1
d1086 1
a1086 1
enum { PFRKE_PLAIN, PFRKE_ROUTE, PFRKE_MAX };
d1111 11
d1126 1
d1825 6
a1830 1
	    sa_family_t, int (*)(sa_family_t, struct pf_addr *));
d1967 2
@


1.333
log
@More cleanup in pf_test/pf_test6 this time mostly the fragment
handling. More to come to make the two codepathes a bit more identical.
tested by many (esp. krw@@ and sthen@@) input and OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.332 2011/05/24 14:01:52 claudio Exp $ */
a1223 2
	u_int16_t	 flags;
#define PFDESC_IP_REAS	0x0002		/* IP frags would've been reassembled */
d1778 2
a1779 2
int	pf_normalize_ip(struct mbuf **, int, u_short *, struct pf_pdesc *);
int	pf_normalize_ip6(struct mbuf **, int, u_short *, struct pf_pdesc *);
@


1.332
log
@Merge pf_scrub_ip() and pf_scrub_ip6() into a single function.  Call
pf_scrub with the right arugments in the rule case so that match
rules will work as expected.  As a benefit allow setting the tos
on IPv6 packets as well.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.331 2011/05/22 13:21:24 claudio Exp $ */
d1746 1
a1746 1
				    struct pf_pdesc *, struct mbuf *,
d1780 3
a1782 6
int	pf_normalize_ip(struct mbuf **, int, struct pfi_kif *, u_short *,
	    struct pf_pdesc *);
int	pf_normalize_ip6(struct mbuf **, int, struct pfi_kif *, u_short *,
	    struct pf_pdesc *);
int	pf_normalize_tcp(int, struct pfi_kif *, struct mbuf *, int, int, void *,
	    struct pf_pdesc *);
@


1.331
log
@Do not pass AF specific information to pf_test_rule() and PFLOG_PACKET()
because either the info is already available in struct pd or easy
to figure out.  Makes pf_test() and pf_test6() even more similar
(with the target to remove one of them in the near future).
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.330 2011/05/17 12:44:05 mikeb Exp $ */
d1793 1
a1793 2
void	pf_scrub_ip(struct mbuf *, u_int16_t, u_int8_t, u_int8_t);
void	pf_scrub_ip6(struct mbuf *, u_int8_t);
@


1.330
log
@exclude link local address from the dynamic interface address pool
so that rules like "pass out on vr1 inet6 nat-to (vr1)" won't map
to the non routable ipv6 link local address; with suggestions and
ok claudio, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.329 2011/04/23 10:00:36 bluhm Exp $ */
d1765 1
a1765 1
int	pflog_packet(struct pfi_kif *, struct mbuf *, sa_family_t, u_int8_t,
@


1.329
log
@pf_scrub_ip() does not modify the given mbuf pointer.  So don't
pass a pointer to a pointer to make the code in pf_test() clearer.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.328 2011/04/22 15:49:28 bluhm Exp $ */
d1815 1
a1815 1
	    sa_family_t);
@


1.328
log
@pf_pooladdr_pl does not exist anymore.  Remove its extern declaration.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.327 2011/04/12 10:47:29 mikeb Exp $ */
d1793 2
a1794 2
void	pf_scrub_ip(struct mbuf **, u_int16_t, u_int8_t, u_int8_t);
void	pf_scrub_ip6(struct mbuf **, u_int8_t);
@


1.327
log
@put the accepted socket of a diverted connection into the routing domain
of a connection originator.  this allows one to query the source rdomain
with a SO_RTABLE socket option.  figured out with reyk, ok claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.326 2011/04/06 13:18:39 claudio Exp $ */
d1708 1
a1708 1
				    pf_altq_pl, pf_pooladdr_pl, pf_rule_item_pl;
@


1.326
log
@Allow PF to filter on the rdomain a packet belongs to. This allows to
write rules like "pass in on rdomain 1".
Tested by phessler@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.325 2011/04/05 13:48:18 mikeb Exp $ */
d1445 1
@


1.325
log
@ditch fastroute, an ipf feature that made its way into pf before
route-to and friends were introduced making it obsolete. one even
has to look it up int the ipf manual to get and idea what it's
supposed to do.  reuse some kernel bits for the upcoming nat64
stuff.  "kill it with fire" from mcbride, "what mcbride said"
from mpf, "kill kill kill" and ok henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.324 2011/03/25 10:54:22 claudio Exp $ */
d546 8
a553 7
#define PF_SKIP_AF		2
#define PF_SKIP_PROTO		3
#define PF_SKIP_SRC_ADDR	4
#define PF_SKIP_SRC_PORT	5
#define PF_SKIP_DST_ADDR	6
#define PF_SKIP_DST_PORT	7
#define PF_SKIP_COUNT		8
d585 1
@


1.324
log
@Include original rdomain in DIOCNATLOOK. This allows userland proxies
to establish cross rdomain proxy sessions.
OK henning@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.323 2011/03/24 20:09:44 bluhm Exp $ */
d108 1
a108 1
enum	{ PF_NOPFROUTE, PF_FASTROUTE, PF_ROUTETO, PF_DUPTO, PF_REPLYTO };
@


1.323
log
@Reassemble IPv6 fragments in pf.  In the forward case, pf refragments
the packets with the same maximum size.  This allows the sender to
determine the optimal fragment size by Path MTU Discovery.
testing sthen@@ matthieu@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.322 2011/03/07 23:30:19 bluhm Exp $ */
d1473 1
@


1.322
log
@Declare the inline function pf_addr_compare() non-static in pfvar.h
to make it reusable by pf fragment reassembly.  No functional change.
discussed with henning@@, claudio@@, deraadt@@, kettenis@@
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.321 2011/03/05 01:53:16 bluhm Exp $ */
d61 1
a61 1
enum	{ PF_INOUT, PF_IN, PF_OUT };
d1774 1
@


1.321
log
@The function pf_tag_packet() never fails.  Remove a redundant check
and make it void.
ok henning@@, markus@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.320 2011/01/11 13:35:58 mcbride Exp $ */
d1874 2
@


1.320
log
@Perform IP options check in pf_test_rule(), before creating state.

ok claudio henning dlg miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.319 2010/12/07 11:39:40 jsg Exp $ */
d1870 1
a1870 1
int		 pf_tag_packet(struct mbuf *, int, int);
@


1.319
log
@remove a bunch of unused arguments
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.318 2010/10/23 15:38:18 tedu Exp $ */
d1231 1
@


1.318
log
@remove PFR_FLAG_ATOMIC.  not used, and doesn't work as advertised.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.317 2010/10/18 15:55:28 deraadt Exp $ */
d1801 1
a1801 1
	    struct pf_addr *, u_int16_t, u_int16_t, int, struct mbuf *);
@


1.317
log
@Revert non-compatible and undocumented bullshit commited by 3 developers
who decided to just do it on their own.  henning, mcbride, jsing -- shame
on you -- if you had shown this diff to just 1 other network developer,
the astounding mistake in it would have been noticed.  Start practicing
inclusionary development instead of going alone.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.315 2010/09/22 05:58:29 henning Exp $ */
a1564 1
#define PFR_FLAG_ATOMIC		0x00000001
@


1.316
log
@Add quirks support to operating system fingerprinting. tcpdump part
by mcbride@@.

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.314 2010/09/21 11:29:12 henning Exp $ */
a489 13
	u_int16_t		fp_quirks;
#define PF_OSFP_QUIRK_DATA	0x0001		/* SYN contains payload. */
#define PF_OSFP_QUIRK_SEQEQ	0x0002		/* SEQ no equals ACK no. */
#define PF_OSFP_QUIRK_SEQZERO	0x0004		/* SEQ no is zero. */
#define PF_OSFP_QUIRK_PAST	0x0008		/* Options past EOL. */
#define PF_OSFP_QUIRK_ZEROID	0x0010		/* IPv4 ID is zero. */
#define PF_OSFP_QUIRK_IPOPT	0x0020		/* IPv4 options specified. */
#define PF_OSFP_QUIRK_URG	0x0040		/* URG pointer non-zero. */
#define PF_OSFP_QUIRK_X2	0x0080		/* Used x2 field non-zero. */
#define PF_OSFP_QUIRK_ACKNO	0x0100		/* ACK no is non-zero. */
#define PF_OSFP_QUIRK_TS2	0x0200		/* Second non-zero timestamp. */
#define PF_OSFP_QUIRK_FLAGS	0x0400		/* Unusual flags set. */
#define PF_OSFP_QUIRK_BROKEN	0x0800		/* Broken options segment. */
a514 1
	u_int16_t		fp_quirks;
@


1.315
log
@add a new log opt PF_LOG_MATCHES
forces logging on all subsequent matching rules
real ok theo assumed oks ryan and dlg bikeshedding everyone in the room
implementation time ~ 1 minute
@
text
@d490 13
d528 1
@


1.314
log
@assert copyrights / bump years
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.313 2010/09/21 03:42:17 henning Exp $ */
d126 1
@


1.313
log
@make pf_translate (void so far) return 1 if it actually changed something
and 0 if it didn't so we know wether we have to rewrite or not.
ok ryan dlg
and in just an hour from now on this might have reached cvs eventually
from njetwork challenged j2k10 in japan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.312 2010/09/21 02:51:35 henning Exp $ */
d5 1
@


1.312
log
@factor our the code to set up pf_pdesc, a central structure in pf carrying
information about the packet we're currently dealing with, into its own
function. ok ryan dlg and additional testing sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.311 2010/06/28 23:21:41 mcbride Exp $ */
d1799 2
@


1.311
log
@Clean up iterface stats handling:
- 'make -Fi' reset ALL the interface statistics
     can be restricted with -i ifname
- 'make -Fa -i ifname' fail (it's meaningless)
- get rid of a silly little struct that's only used for one thing

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.310 2010/06/27 01:39:43 henning Exp $ */
d1214 1
d1739 5
@


1.310
log
@stuff nsaddr/ndaddr/nsport/ndport (addrs/ports after NAT, used a lot while
walking the ruleset and up until state is fully set up) into pf_pdesc instead
of passing around those 4 seperately all the time, also shrinks the argument
count for a few functions that have/partialy had an insane count of arguments.
kinda preparational since we'll need them elsewhere too, soon
ok ryan jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.309 2010/05/07 13:33:16 claudio Exp $ */
a1520 4
struct pfioc_if {
	char		 ifname[IFNAMSIZ];
};

d1615 1
a1615 1
#define DIOCSETSTATUSIF _IOWR('D', 20, struct pfioc_if)
d1617 1
a1617 1
#define DIOCCLRSTATUS	_IO  ('D', 22)
@


1.309
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.308 2010/04/28 12:46:18 robert Exp $ */
d1199 3
d1210 2
d1933 1
a1933 2
			    struct pf_addr *, u_int16_t *, struct pf_addr *,
			    u_int16_t *, struct pf_src_node **);
a1939 4
int			 pf_state_key_setup(struct pf_pdesc *,
			    struct pf_state_key **, struct pf_state_key **,
			    struct pf_addr **, struct pf_addr **,
			    u_int16_t *, u_int16_t *, int);
@


1.308
log
@Cast 'a' to (void *) in the REASON_SET macro. Makes gcc4 happy.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.307 2010/01/20 21:41:17 mcbride Exp $ */
d357 1
a357 1
#define	PF_MISMATCHAW(aw, x, af, neg, ifp)				\
d360 1
a360 1
		    pf_routable((x), (af), NULL)) ||			\
d362 1
a362 1
		    pf_routable((x), (af), (ifp))) ||			\
d364 1
a364 1
		    !pf_rtlabel_match((x), (af), (aw))) ||		\
d1784 4
a1787 2
int	pf_routable(struct pf_addr *addr, sa_family_t af, struct pfi_kif *);
int	pf_rtlabel_match(struct pf_addr *, sa_family_t, struct pf_addr_wrap *);
@


1.307
log
@One \ too many in pfvar.h. From Daniel Dickman <didickman@@gmail.com>

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.306 2010/01/18 23:52:46 mcbride Exp $ */
d1333 1
a1333 1
		if ((a) != NULL) \
@


1.306
log
@Convert pf debug logging to using log()/addlog(), a single standardised
definition of DPFPRINTF(), and log priorities from syslog.h. Old debug
levels will still work for now, but will eventually be phased out.

discussed with henning, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.305 2010/01/13 01:54:38 jsg Exp $ */
d208 1
a208 1
#ifdef PFDEBUG								\
@


1.305
log
@Remove extern reference to pf_pabuf which uses a struct
which no longer exists. Makes gcc4 kernels compile again.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.304 2010/01/12 03:20:51 mcbride Exp $ */
a66 1
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC, PF_DEBUG_NOISY };
d187 32
d224 1
@


1.304
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.303 2009/12/24 04:24:19 dlg Exp $ */
a1651 1
extern struct pf_palist			  pf_pabuf[3];
@


1.303
log
@add support to pf for filtering a packet by the interface it was received
on. use the received-on IFNAME filter option on a pf.conf rule to restrict
which packet the interface had to be received on. eg:

  pass out on em0 from $foo to $bar received-on fxp0

ive been running this in production for a week now. i find it particularly
usefull with interface groups.

no objections, and a few "i like"s from henning, claudio, deraadt, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.302 2009/12/14 12:31:45 henning Exp $ */
d116 1
a116 1
	  PF_ADDR_RANGE };
a363 9
struct pf_pooladdr {
	struct pf_addr_wrap		 addr;
	TAILQ_ENTRY(pf_pooladdr)	 entries;
	char				 ifname[IFNAMSIZ];
	struct pfi_kif			*kif;
};

TAILQ_HEAD(pf_palist, pf_pooladdr);

d376 1
a376 2
	struct pf_palist	 list;
	struct pf_pooladdr	*cur;
d378 3
a380 1
	struct pf_addr		 counter;
d988 1
d993 2
d1031 17
a1048 3
	struct radix_node	 pfrke_node[2];
	union sockaddr_union	 pfrke_sa;
	SLIST_ENTRY(pfr_kentry)	 pfrke_workq;
d1050 16
a1065 5
		
		struct pfr_kcounters		*pfrke_counters;
#if 0
		struct pfr_kroute		*pfrke_route;
#endif
d1067 2
a1068 5
	long			 pfrke_tzero;
	u_int8_t		 pfrke_af;
	u_int8_t		 pfrke_net;
	u_int8_t		 pfrke_not;
	u_int8_t		 pfrke_mark;
a1069 2
#define pfrke_counters	u.pfrke_counters
#define pfrke_route	u.pfrke_route
d1071 7
d1136 1
d1143 2
a1144 1
	PFI_KIF_REF_RULE
a1416 14
struct pfioc_pooladdr {
	u_int32_t		 action;
	u_int32_t		 ticket;
	u_int32_t		 nr;
	u_int32_t		 r_num;
	u_int8_t		 r_action;
	u_int8_t		 r_last;
	u_int8_t		 af;
	u_int8_t		 which;
	u_int8_t		 pad[3];
	char			 anchor[MAXPATHLEN];
	struct pf_pooladdr	 addr;
};

a1419 1
	u_int32_t	 pool_ticket;
d1604 1
a1604 6
#define DIOCBEGINADDRS	_IOWR('D', 51, struct pfioc_pooladdr)
#define DIOCADDADDR	_IOWR('D', 52, struct pfioc_pooladdr)
#define DIOCGETADDRS	_IOWR('D', 53, struct pfioc_pooladdr)
#define DIOCGETADDR	_IOWR('D', 54, struct pfioc_pooladdr)
#define DIOCCHANGEADDR	_IOWR('D', 55, struct pfioc_pooladdr)
/* XXX cut 55 - 57 */
d1765 2
a1766 1
	    struct pf_addr **, struct pf_addr **, sa_family_t);
@


1.302
log
@fix sticky-address - by pretty much re-implementing it. still following
the original approach using a source tracking node.
the reimplementation i smore flexible than the original one, we now have an
slist of source tracking nodes per state. that is cheap because more than
one entry will be an absolute exception.
ok beck and jsg, also stress tested by Sebastian Benoit <benoit-lists at fb12.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.301 2009/11/24 13:23:55 henning Exp $ */
d532 1
d551 1
@


1.301
log
@kill obsolete natpass
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.300 2009/11/23 16:03:10 henning Exp $ */
d661 2
d664 19
a682 14
	RB_ENTRY(pf_src_node) entry;
	struct pf_addr	 addr;
	struct pf_addr	 raddr;
	union pf_rule_ptr rule;
	struct pfi_kif	*kif;
	u_int64_t	 bytes[2];
	u_int64_t	 packets[2];
	u_int32_t	 states;
	u_int32_t	 conn;
	struct pf_threshold	conn_rate;
	u_int32_t	 creation;
	u_int32_t	 expire;
	sa_family_t	 af;
	u_int8_t	 ruletype;
d685 2
d778 1
a781 1
	struct pf_src_node	*src_node;
d1661 1
a1661 1
extern struct pool		 pf_src_tree_pl, pf_rule_pl;
d1674 7
a1680 3
extern int			 pf_insert_src_node(struct pf_src_node **,
				    struct pf_rule *, struct pf_addr *,
				    sa_family_t);
d1682 3
d1889 1
a1889 1
			    u_int16_t *);
d1894 1
a1894 1
			    struct pf_pool *);
@


1.300
log
@remove the nat_rule pointer on pf_state and pf_pdesc, obsolete after
the NAT rewrite and ever since then only checked in a couple of plaes
but never set. same for nat_src_node on pf_state.
with this the NAT rewrite made pf over 1000 lines shorter.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.299 2009/11/22 22:34:50 henning Exp $ */
d581 1
a593 1
	u_int8_t		 natpass;
d617 1
a617 2
	u_int16_t		 scrub_flags;
	u_int8_t		 pad2[2];
@


1.299
log
@cleanup after the NAT changes. we used to have multiple rulesets (scrub,
NAT, filter). now we only have one. no need for an array any more. simplifies
the code quite a bit.
in the process fix the abuse of PF_RULESET_* by (surprise, isn't it) the
table code.
written at the filesystem hackathon in stockholm, committed from the
hardware hackathon in portugal. ok gcc and jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.298 2009/11/03 17:41:02 claudio Exp $ */
a346 1

a394 1

a768 1
	union pf_rule_ptr	 nat_rule;
a773 1
	struct pf_src_node	*nat_src_node;
a1132 1
	struct pf_rule	*nat_rule;	/* nat/rdr rule applied to packet */
@


1.298
log
@Use u_int16_t for rdomains for everything. Using various types makes
everything just more complicated. Make sure the structs align nicely.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.297 2009/11/03 10:59:04 claudio Exp $ */
d64 1
a64 2
enum	{ PF_RULESET_FILTER, PF_RULESET_NAT, PF_RULESET_BINAT,
	  PF_RULESET_RDR, PF_RULESET_MAX };
d937 1
a937 1
	}			 rules[PF_RULESET_MAX];
a1504 2
#define PF_RULESET_ALTQ		(PF_RULESET_MAX)
#define PF_RULESET_TABLE	(PF_RULESET_MAX+1)
d1509 1
a1509 1
		int		rs_num;
d1743 1
a1831 1
int			 pf_get_ruleset_number(u_int8_t);
d1871 1
a1871 1
void			 pf_step_into_anchor(int *, struct pf_ruleset **, int,
d1874 1
a1874 1
			     int, struct pf_rule **, struct pf_rule **,
@


1.297
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.296 2009/10/28 20:11:01 jsg Exp $ */
a1148 1
	u_int		 rdomain;	/* original routing domain */
d1152 2
d1418 1
a1418 1
	int		 rdomain;
d1448 1
a1448 1
	int			psk_rdomain;
@


1.296
log
@Add a dedicated pf pool for route options as suggested by henning,
which unbreaks ie route-to after the recent pf changes.

With much help debugging and pointing out of missing bits from claudio@@

ok claudio@@ "looks good" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.295 2009/10/06 21:21:48 claudio Exp $ */
d725 1
a727 1
	u_int8_t	 pad[2];
d740 1
a742 1
	u_int8_t	 pad[2];
d804 1
a804 1
	int			 rtableid;
d837 2
d856 2
d866 3
d1149 1
d1417 1
d1447 1
d1891 1
a1891 1
			    u_int16_t *, u_int16_t *);
@


1.295
log
@Redo the route lookup in the output (and IPv6 forwarding) path if the
destination of a packet was changed by pf. This allows for some evil
games with rdr-to or nat-to but is mostly needed for better rdomain/rtable
support. This is a first step and more work and cleanup is needed.

Here a list of what works and what does not (needs a patched pfctl):
pass out rdr-to:
from local rdr-to local addr works (if state tracking on lo0 is done)
from remote rdr-to local addr does NOT work
from local rdr-to remote works
from remote rdr-to remote works

pass in nat-to:
from remote nat-to local addr does NOT work
from remote nat-to non-local addr works
non-local is an IP that is routed to the FW but is not assigned on the FW.
The non working cases need some magic to correctly rewrite the incomming
packet since the rewriting would happen outbound which is too late.

"time to get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.294 2009/10/04 16:08:37 michele Exp $ */
d63 1
a63 1
	  PF_MATCH, PF_DIVERT };
d546 1
a1632 1
extern struct pf_poolqueue		  pf_pools[2];
d1635 1
a1635 1
extern struct pf_palist			  pf_pabuf[2];
@


1.294
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.293 2009/09/08 17:52:17 michele Exp $ */
d1152 1
@


1.293
log
@I had not enough oks to commit this diff.
Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.291 2009/09/01 13:42:00 henning Exp $ */
d63 1
a63 1
	  PF_MATCH };
d625 1
a625 1
	}			divert;
@


1.292
log
@Add support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 8000

test, bugfix and ok by reyk@@
manpage help and ok by jmc@@
no objections from many others.
@
text
@d63 1
a63 1
	  PF_MATCH, PF_DIVERT };
d625 1
a625 1
	}			divert, divert_packet;
@


1.291
log
@the diff theo calls me insanae for:
rewrite of the NAT code, basically. nat and rdr become actions on regular
rules, seperate nat/rdr/binat rules do not exist any more.
match in on $intf rdr-to 1.2.3.4
match out on $intf nat-to 5.6.7.8
the code is capable of doing nat and rdr in any direction, but we prevent
this in pfctl for now, there are implications that need to be documented
better.
the address rewrite happens inline, subsequent rules will see the already
changed addresses. nat / rdr can be applied multiple times as well.
match in on $intf rdr-to 1.2.3.4
match in on $intf to 1.2.3.4 rdr-to 5.6.7.8
help and ok dlg sthen claudio, reyk tested too
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.290 2009/06/25 09:30:28 sthen Exp $ */
d63 1
a63 1
	  PF_MATCH };
d625 1
a625 1
	}			divert;
@


1.290
log
@scrub_flags is a u_int8_t, but PFSTATE_SCRUB_TCP is 0x0100, so the
"reassemble tcp" state option failed to work correctly. Increasing this
to u_int16_t fixes kernel/6178. ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.289 2009/06/08 02:39:15 henning Exp $ */
d544 2
a545 1
	struct pf_pool		 rpool;
d1135 4
a1138 2
	u_int16_t *sport;
	u_int16_t *dport;
d1386 2
d1634 1
a1634 1
extern struct pf_palist			  pf_pabuf;
d1868 5
a1872 1
int			 pf_map_addr(u_int8_t, struct pf_rule *,
d1874 2
a1875 7
			    struct pf_addr *, struct pf_src_node **);
struct pf_rule		*pf_get_translation(struct pf_pdesc *, struct mbuf *,
			    int, int, struct pfi_kif *, struct pf_src_node **,
			    struct pf_state_key **, struct pf_state_key **,
			    struct pf_state_key **, struct pf_state_key **,
			    struct pf_addr *, struct pf_addr *,
			    u_int16_t, u_int16_t);
d1877 1
a1877 2
int			 pf_state_key_setup(struct pf_pdesc *, struct pf_rule *,
			    struct pf_state_key **, struct pf_state_key **,
d1879 2
a1880 2
			    struct pf_addr *, struct pf_addr *,
			    u_int16_t, u_int16_t);
@


1.289
log
@bring back the fixed PF_AEQ/ANEQ/AZERO macros, the offending use has been
found by sthen and fixed, all other callers of these macros checked by both
of us
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.288 2009/06/08 01:55:42 henning Exp $ */
d507 2
a508 2
	u_int8_t	flags;
	u_int8_t	pad[2];
d618 2
a619 2
	u_int8_t		 scrub_flags;
	u_int8_t		 pad2[3];
d1718 1
a1718 1
void	pf_scrub_ip(struct mbuf **, u_int8_t, u_int8_t, u_int8_t);
@


1.288
log
@gah. something is not quite right, sthen sees strange behaviour fixed
by backing out the macro fix. something must rely on the broken behaviour
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.287 2009/06/08 00:50:30 henning Exp $ */
d223 2
a224 1
	((a)->addr32[3] == (b)->addr32[3] && \
d231 1
d235 1
a235 1
	(a)->addr32[0] != (b)->addr32[0])) \
d239 2
a240 1
	(!(a)->addr32[0] && !(a)->addr32[1] && \
@


1.287
log
@unfuck PF_AEQ PF_ANEQ PF_AZERO macos that got fucked when v6 support
was added in 2001. yes i got bitten by inet6 shit again.
in the ANEQ case, if af == AF_INET, (a)->addr32[0] != (b)->addr32[0]
is false when the adresses ARE equal. now it goes right in the
intended-for-v6 case and starts to compare the other addr32 fields -
in the v4 case I have garbage in them, so it reports all v4 as different
when they are in fact the same. fix by adding explicit af == INET6 test
before going on to compare the rest.
found the really hard way (many hours wasted, thought the bug was in my
new code) by me. ok sthen markus claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.286 2009/05/18 20:37:13 bluhm Exp $ */
d223 1
a223 2
	(c == AF_INET6 && \
	(a)->addr32[3] == (b)->addr32[3] && \
a229 1
	(c == AF_INET6 && \
d233 1
a233 1
	(a)->addr32[0] != (b)->addr32[0]))) \
d237 1
a237 2
	(c == AF_INET6 && \
	!(a)->addr32[0] && !(a)->addr32[1] && \
@


1.286
log
@The routing table index rtableid has type unsigned int in the routing
code.  In pf rtableid == -1 means don't change the rtableid because
of this rule.  So it has to be signed int there.  Before the value
is passed from pf to route it is always checked to be >= 0.  Change
the type to int in pf and to u_int in netinet and netinet6 to make
the checks work.  Otherwise -1 may be used as an array index and
the kernel crashes.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.285 2009/04/06 12:05:55 henning Exp $ */
d223 2
a224 1
	((a)->addr32[3] == (b)->addr32[3] && \
d231 1
d235 1
a235 1
	(a)->addr32[0] != (b)->addr32[0])) \
d239 2
a240 1
	(!(a)->addr32[0] && !(a)->addr32[1] && \
@


1.285
log
@1) scrub rules are completely gone.
2) packet reassembly: only one method remains, full reassembly. crop
and drop-ovl are gone.
.  set reassemble yes|no [no-df]
if no-df is given fragments (and only fragments!) with the df bit set
have it cleared before entering the fragment cache, and thus the
reassembled packet doesn't have df set either. it does NOT touch
non-fragmented packets.
3) regular rules can have scrub options.
.  pass scrub(no-df, min-ttl 64, max-mss 1400, set-tos lowdelay)
.  match scrub(reassemble tcp, random-id)
of course all options are optional. the individual options still do
what they used to do on scrub rules, but everything is stateful now.
4) match rules
"match" is a new action, just like pass and block are, and can be used
like they do. opposed to pass or block, they do NOT change the
pass/block state of a packet. i. e.
.  pass
.  match
passes the packet, and
.  block
.  match
blocks it.
Every time (!) a match rule matches, i. e. not only when it is the
last matching rule, the following actions are set:
-queue assignment. can be overwritten later, the last rule that set a
queue wins. note how this is different from the last matching rule
wins, if the last matching rule has no queue assignments and the
second last matching rule was a match rule with queue assignments,
these assignments are taken.
-rtable assignments. works the same as queue assignments.
-set-tos, min-ttl, max-mss, no-df, random-id, reassemble tcp, all work
like the above
-logging. every matching rule causes the packet to be logged. this
 means a single packet can get logged more than once (think multiple log
 interfaces with different receivers, like pflogd and spamlogd)
.
almost entirely hacked at n2k9 in basel, could not be committed close to
release. this really should have been multiple diffs, but splitting them
now is not feasible any more. input from mcbride and dlg, and frantzen
about the fragment handling.
speedup around 7% for the common case, the more the more scrub rules
were in use.
manpage not up to date, being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.284 2009/03/09 13:53:10 mcbride Exp $ */
d799 1
a799 1
	int16_t			 rtableid;
@


1.284
log
@Make the DIOCSETIFFLAG, DIOCSETLIMIT, and DIOCSETTIMEOUT ioctls
transactional, closing PRs 4941 and 5910.  Minor flag day, requires rebuild
of userland tools that use struct pfi_kif.

ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.283 2009/02/16 00:31:25 dlg Exp $ */
d62 4
a65 3
	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR, PF_SYNPROXY_DROP, PF_DEFER };
enum	{ PF_RULESET_SCRUB, PF_RULESET_FILTER, PF_RULESET_NAT,
	  PF_RULESET_BINAT, PF_RULESET_RDR, PF_RULESET_MAX };
d126 1
d496 11
d615 2
a633 8
/* scrub flags */
#define	PFRULE_NODF		0x0100
#define	PFRULE_FRAGCROP		0x0200	/* non-buffering frag cache */
#define	PFRULE_FRAGDROP		0x0400	/* drop funny fragments */
#define PFRULE_RANDOMID		0x0800
#define PFRULE_REASSEMBLE_TCP	0x1000
#define PFRULE_SET_TOS		0x2000

d653 7
d764 1
d779 2
d782 10
a792 6
	u_int8_t		 state_flags;
#define	PFSTATE_ALLOWOPTS	0x01
#define	PFSTATE_SLOPPY		0x02
#define	PFSTATE_PFLOW		0x04
#define	PFSTATE_NOSYNC		0x08
#define	PFSTATE_ACK		0x10
d798 5
a802 1
	u_int8_t		_tail[3];
d1138 1
a1138 3
	u_int16_t	 flags;		/* Let SCRUB trigger behavior in
					 * state code. Easier than tags */
#define PFDESC_TCP_NORM	0x0001		/* TCP shall be statefully scrubbed */
d1276 1
d1281 3
d1609 1
d1643 1
a1643 1
				    pf_altq_pl, pf_pooladdr_pl;
d1714 3
@


1.283
log
@pfsync v5, mostly written at n2k9, but based on work done at n2k8.

WARNING: THIS BREAKS COMPATIBILITY WITH THE PREVIOUS VERSION OF PFSYNC

this is a new variant of the protocol and a large reworking of the
pfsync code to address some performance issues. the single largest
benefit comes from having multiple pfsync messages of different
types handled in a single packet. pfsyncs handling of pf states is
highly optimised now, along with packet parsing and construction.

huggz for beck@@ for testing.
huge thanks to mcbride@@ for his help during development and for
finding all the bugs during the initial tests.
thanks to peter sutton for letting me get credit for this work.

ok beck@@ mcbride@@ "good." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.282 2009/01/29 15:12:28 pyr Exp $ */
d1066 1
d1753 1
d1772 1
@


1.282
log
@Split the address selection from pools away from pf.c and put it in
pf_lb.c. This will ease the process of adding more selection types
without bloatening pf.c even more.

ok and a weird death threat, henning@@
raised eyebrow, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.281 2008/11/24 13:22:09 mikeb Exp $ */
d62 1
a62 1
	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR, PF_SYNPROXY_DROP };
d745 1
d770 2
d773 5
a777 4
	u_int8_t		 sync_flags;
#define	PFSTATE_NOSYNC		0x01
#define	PFSTATE_FROMSYNC	0x02
#define	PFSTATE_STALE		0x04
a833 2
#define PFSYNC_FLAG_COMPRESS	0x01
#define PFSYNC_FLAG_STALE	0x02
d1662 1
@


1.281
log
@Fix splasserts seen in pr 5987 by propagating a flag that discribes
whether we're called from the interrupt context to the functions
performing allocations.

Looked at by mpf@@ and henning@@, tested by mpf@@ and Antti Harri,
the pr originator.

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.280 2008/10/08 06:24:50 mcbride Exp $ */
d1813 26
@


1.280
log
@Get rid of the second table entry pool (pfr_kentry_pl2); we're already
using the default interrupt handler for both, so there's no need to keep
table entries created in interrupt context separate.

ok henning art
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.279 2008/09/22 10:22:19 mpf Exp $ */
d1699 1
a1699 1
	pfr_attach_table(struct pf_ruleset *, char *);
@


1.279
log
@Reorder PFSTATE_PFLOW define:
It applies to state_flags, not to sync_flags.
OK henning@@, gollo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.278 2008/09/09 13:56:39 henning Exp $ */
a1007 1
	u_int8_t		 pfrke_intrpool;
@


1.278
log
@welcome pflow(4), a netflow v5 compatible flow export interface.
flows export data gathered from pf states.
initial implementation by Joerg Goltermann <jg@@osn.de>, guidance and many
changes by me. 'put it in' theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.277 2008/08/26 12:17:10 henning Exp $ */
d768 1
a773 1
#define	PFSTATE_PFLOW		0x08
@


1.277
log
@introduce a function to be called when addressing information has changed,
pf_pkt_addr_changed. atm just clears the state key pointer.
calling this is cleaner than having other parts of the stack clearing
pointers in the pf part of the mbuf packet header directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.276 2008/07/03 15:46:23 henning Exp $ */
d630 1
d770 4
a773 3
#define	PFSTATE_NOSYNC	 0x01
#define	PFSTATE_FROMSYNC 0x02
#define	PFSTATE_STALE	 0x04
@


1.276
log
@link pf state keys to tcp pcbs and vice versa.
when we first do a pcb lookup and we have a pointer to a pf state key
in the mbuf header, store the state key pointer in the pcb and a pointer
to the pcb we just found in the state key. when either the state key
or the pcb is removed, clear the pointers.
on subsequent packets inbound we can skip the pcb lookup and just use the
pointer from the state key.
on subsequent packets outbound we can skip the state key lookup and use
the pointer from the pcb.
about 8% speedup with 100 concurrent tcp sessions, should help much more
with more tcp sessions.
ok markus ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.275 2008/06/29 08:42:15 mcbride Exp $ */
d1688 1
@


1.275
log
@Simplify state creation code; merge state import/export code between pfsync
and the state-related pf(4) ioctls, and make functions in state creation and
destruction paths more robust in error conditions.

All values in struct pfsync_state now in network byte order, as with pfsync.

testing by david
ok henning, systat parts ok canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.274 2008/06/11 02:46:35 henning Exp $ */
d727 1
@


1.274
log
@store a pointer to the stack side state key in the mbuf packet
header inbound. on the outbound side, we take that and look for the key
that is the exact opposite, and store that mapping in the state key. on
subsequent packets we don't have to do the lookup on outbound any more.
almost unable to get real benchmarks going here, we know for sure this
gives a more than 5% increase in forwarding performance.
many thanks to ckuethe for stress- and performance-testing.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.273 2008/06/10 20:55:02 mcbride Exp $ */
d759 1
a759 1
	u_int32_t		 expire;
d832 8
a839 7
/* for copies to/from userland via pf_ioctl() */
#define pf_state_peer_to_pfsync(s,d) do {	\
	(d)->seqlo = (s)->seqlo;		\
	(d)->seqhi = (s)->seqhi;		\
	(d)->seqdiff = (s)->seqdiff;		\
	(d)->max_win = (s)->max_win;		\
	(d)->mss = (s)->mss;			\
d843 2
a844 2
		(d)->scrub.pfss_flags =					\
		    (s)->scrub->pfss_flags & PFSS_TIMESTAMP;		\
d846 1
a846 1
		(d)->scrub.pfss_ts_mod = (s)->scrub->pfss_ts_mod;	\
d851 5
a855 5
#define pf_state_peer_from_pfsync(s,d) do {	\
	(d)->seqlo = (s)->seqlo;		\
	(d)->seqhi = (s)->seqhi;		\
	(d)->seqdiff = (s)->seqdiff;		\
	(d)->max_win = (s)->max_win;		\
d859 1
a859 1
	if ((s)->scrub.scrub_flag == PFSYNC_SCRUB_FLAG_VALID &&		\
d864 1
a864 1
		(d)->scrub->pfss_ts_mod = (s)->scrub.pfss_ts_mod;	\
d868 3
a870 3
#define pf_state_counter_to_pfsync(s,d) do {			\
	d[0] = (s>>32)&0xffffffff;				\
	d[1] = s&0xffffffff;					\
d873 1
a873 1
#define pf_state_counter_from_pfsync(s)		\
d876 5
a880 1

d1686 2
a1687 2
struct pf_state_key *pf_alloc_state_key(void);
void	pf_attach_state(struct pf_state_key *, struct pf_state *, int, int);
@


1.273
log
@Make counters on table addresses optional and disabled by default.
Use the 'counters' table option in pf.conf if you actually need them.
If enabled, memory is not allocated until packets match an address.

This saves about 40% memory if counters are not being used, and paves the way
for some more significant cleanups coming soon.

ok henning mpf deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.272 2008/06/10 19:32:14 henning Exp $ */
d726 1
@


1.272
log
@save somespace in the state by collapsing two 8 bit ints used as booleans
into one 8 bit flags field.
shrinks the state structure by 4 bytes on 32bit archs
ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.271 2008/06/10 04:24:17 henning Exp $ */
d921 3
a923 1
#define PFR_TFLAG_USRMASK	0x00000003
d925 1
a925 1
#define PFR_TFLAG_ALLMASK	0x0000003F
d936 1
a936 1
	PFR_FB_NOTMATCH, PFR_FB_CONFLICT, PFR_FB_MAX };
d977 5
a985 2
	u_int64_t		 pfrke_packets[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t		 pfrke_bytes[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
d987 7
d1001 3
@


1.271
log
@implement a sloppy tcpstate tracker which does not look at sequence
numbers at all. scary consequences; only tobe used in very specific
situations where you don't see all packets of a connection, e. g.
asymmetric routing. ok ryan reyk theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.270 2008/05/30 14:22:48 henning Exp $ */
d762 3
a764 1
	u_int8_t		 allow_opts;
a766 2
	u_int8_t		 sloppy;	/* fold into flag w allow_opts*/
	u_int8_t		 pad2[3];
d820 1
a820 1
	u_int8_t	 allow_opts;
a823 2
	u_int8_t	 sloppy;	/* fold into flag with allow_opts */
	u_int8_t	 pad[3];
@


1.270
log
@trivial KNF before we go further
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.269 2008/05/29 01:00:53 mcbride Exp $ */
d629 1
d765 2
d824 2
@


1.269
log
@Second half of PF state table rearrangement.
- Mechanical change: Use arrays for state key pointers in pf_state, and
  addr/port in pf_state_key, to allow the use of indexes.
- Fix NAT, pfsync, pfctl, and tcpdump to handle the new state structures.
  In struct pfsync_state, both state keys are included even when identical.
- Also fix some bugs discovered in the existing code during testing.
  (in particular, "block return" for TCP packets was not returning an RST)

ok henning beck deraadt
tested by otto dlg beck laurent

Special thanks to users Manuel Pata and Emilio Perea who did enough testing
to actually find some bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.267 2008/05/18 11:54:04 mcbride Exp $ */
d1073 1
a1073 1
	struct ether_header	
@


1.268
log
@rewrite the state table logic.
complete the split off of the layer 3/4 adressing information from the extra
information in the actual state. a state key holds a list of states, and a
state points to two state keys - they're only different in the NAT case.
More specificially, it deprecates the (often difficult to understand)
concept of lan, ext, and gwy addresses, replacing them with WIRE and
STACK side address tuples.  (af, proto, saddr, daddr, sport, dport).
Concept first brought up some years ago on a ferry ride in bc by ryan and
me, I spent some time over the last year getting closer, and finally
got it completed in japan with ryan. dlg also took part, helped a lot,
and saved us 8 bytes.
This commit removes support for any kind of NAT as well as pfsync.
It also paves the road for some code simplification and some very cool
future stuff.
ok ryan beck, tested by many
@
text
@d72 1
a72 1
enum	{ PF_SK_NONE, PF_SK_WIRE, PF_SK_STACK, PF_SK_BOTH };
d702 2
a703 4
	struct pf_addr	 addr1;
	struct pf_addr	 addr2;
	u_int16_t	 port1;
	u_int16_t	 port2;
d717 2
a718 4
	struct pf_addr	 addr1;
	struct pf_addr	 addr2;
	u_int16_t	 port1;
	u_int16_t	 port2;
d749 1
a749 2
	struct pf_state_key	*key_wire;	/* addresses wire-side */
	struct pf_state_key	*key_stack;	/* addresses stack-side */
a780 6
struct pfsync_state_host {
	struct pf_addr	addr;
	u_int16_t	port;
	u_int16_t	pad[3];
} __packed;

d793 5
d801 1
a801 3
	struct pfsync_state_host lan;
	struct pfsync_state_host gwy;
	struct pfsync_state_host ext;
d1071 1
a1071 2
	struct pf_addr	 baddr;		/* address before translation */
	struct pf_addr	 naddr;		/* address after translation */
d1073 1
a1073 3
	struct pf_addr	*src;
	struct pf_addr	*dst;
	struct ether_header
d1075 7
d1083 1
a1083 1
	u_int32_t	 p_len;		/* total length of payload */
d1091 3
d1297 4
a1300 4
		struct in_addr   ipv4;
		struct in6_addr  ipv6;
	}               addr;
	u_int16_t       port;
d1594 3
a1596 1
				    struct pf_state_key *, struct pf_state *);
@


1.267
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.266 2008/05/09 13:59:31 mpf Exp $ */
d72 1
d702 4
a705 3
	struct pf_state_host lan;
	struct pf_state_host gwy;
	struct pf_state_host ext;
d708 6
a713 2
	u_int8_t	 direction;
	u_int8_t	 pad;
d716 1
a716 1
TAILQ_HEAD(pf_statelist, pf_state);
d719 4
a722 3
	struct pf_state_host lan;
	struct pf_state_host gwy;
	struct pf_state_host ext;
d725 1
a725 2
	u_int8_t	 direction;
	u_int8_t	 pad;
d727 2
a728 3
	RB_ENTRY(pf_state_key)	 entry_lan_ext;
	RB_ENTRY(pf_state_key)	 entry_ext_gwy;
	struct pf_statelist	 states;
a730 1

d733 4
a736 3
	u_int64_t	 id;
	u_int32_t	 creatorid;
	u_int32_t	 pad;
d742 2
a743 1
	u_int32_t		 pad;
a745 1
	TAILQ_ENTRY(pf_state)	 next;
d753 2
a754 1
	struct pf_state_key	*state_key;
d1022 2
a1023 3
RB_HEAD(pf_state_tree_lan_ext, pf_state_key);
RB_PROTOTYPE(pf_state_tree_lan_ext, pf_state_key,
    entry_lan_ext, pf_state_compare_lan_ext);
d1032 1
a1032 2
extern struct pf_state_tree_lan_ext	 pf_statetbl_lan_ext;
extern struct pf_state_tree_ext_gwy	 pf_statetbl_ext_gwy;
d1586 2
a1587 2
extern struct pool		 pf_state_pl, pf_state_key_pl, pf_altq_pl,
				    pf_pooladdr_pl;
d1594 2
a1595 2
extern int			 pf_insert_state(struct pfi_kif *,
				    struct pf_state *);
d1661 2
a1662 2
struct pf_state_key *
	pf_alloc_state_key(struct pf_state *);
@


1.266
log
@Add support to kill states by rule label or state id.
Fix printing of the state id in pfctl -ss -vv.
Remove the psnk_af hack to return the number of killed states.
OK markus, beck. "I like it" henning, deraadt.
Manpage help from jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.265 2008/05/09 02:44:54 markus Exp $ */
d331 1
a331 1
		    !pfi_match_addr((aw)->p.dyn, (x), (af))) || 	\
d334 1
a334 1
		    &(aw)->v.a.mask, (x), (af))) || 			\
d775 1
a775 1
#define PFSYNC_SCRUB_FLAG_VALID 	0x01
d825 1
a825 1
#define PFSYNC_FLAG_COMPRESS 	0x01
d840 1
a840 1
		(d)->scrub.pfss_flags = 				\
d856 1
a856 1
	if ((s)->scrub.scrub_flag == PFSYNC_SCRUB_FLAG_VALID && 	\
@


1.265
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.264 2008/05/08 08:05:16 deraadt Exp $ */
a1353 1
	/* XXX returns the number of src nodes killed in psnk_af */
d1357 1
d1361 1
a1361 1
	/* XXX returns the number of states killed in psk_af */
d1367 2
@


1.264
log
@reorder elements in pf_state_peer to avoid wasting memory.  cvs blame
shows that 3 developers screwed this up.  look carefully at this diff
and learn how to avoid wasting memory.  on a 64 bit architecture, each
of these was using 40 bytes instead of 32.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.263 2008/05/07 07:07:29 markus Exp $ */
d601 5
d1292 8
d1608 1
@


1.263
log
@scrub packets based on tags; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.262 2008/05/07 06:23:30 markus Exp $ */
d680 1
d685 1
a687 1
	u_int16_t	mss;		/* Maximum segment size option	*/
d689 1
a689 2
	struct pf_state_scrub	*scrub;	/* state is scrubbed		*/
	u_int8_t	pad[3];
@


1.262
log
@allow setting TOS with scrub; ok mcbride, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.261 2008/05/06 03:45:22 mpf Exp $ */
d1702 1
@


1.261
log
@Add a counter to record how many states have been created by a rule.
It shows up in pfctl verbose mode and in the 7th field of the labels
output.  Also remove the label printing for scrub rules, as they
do not support labels.
OK dhartmei@@ (on an earlier version), henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.260 2008/05/05 13:00:43 henning Exp $ */
d594 1
d619 1
@


1.260
log
@remove a useless refcnt in pf_state_key.
when it is in fact only used to delete the state key when the number of
attached states (in a tailq) drops to zero, we can as well test for the
queue beeing empty.
this is a leftover from some early version that did things differently.
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.259 2007/12/02 12:08:04 pascoe Exp $ */
d541 2
a542 1
	u_int32_t		 states;
@


1.259
log
@DIOC{GET,ADD}STATE incorrectly use a user provided pointer without using
copyin/out.  Change the API so that the state is included in the ioctl
argument, so the ioctl wrappers take care of copying memory as appropriate.

Also change the DIOCGETSTATE API to be more useful.  Instead of getting
an arbitrarily "numbered" state (using numbering that can change between
calls), instead search based on id and creatorid.  If you want to monitor
only a particular state, you can now use the bulk functions first to find
the appropriate id/creatorid and then fetch it directly from then on.

ok dlg@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.258 2007/09/27 22:24:05 mpf Exp $ */
a715 1
	u_short		 refcnt;	/* same size as if_index */	 
@


1.258
log
@Add loginterface support for groups.
Using a group sums up the statistics of all members.
Modify pfctl(1) slightly to allow a groupname "all",
which gives us an overall pf(4) statistic.

OK henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.257 2007/08/31 12:37:50 thib Exp $ */
d1335 1
a1335 2
	u_int32_t 	 nr;
	void		*state;
@


1.257
log
@zap unused "pf_tag" structure.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.256 2007/08/30 13:07:06 henning Exp $ */
d1696 1
a1696 2
void		 pfi_fill_oldstatus(struct pf_status *);
int		 pfi_clr_istats(const char *);
@


1.256
log
@mechanic change:
there is a 1:1 mapping between direction and the tree the states get
attached to. there is no need to have anything outside the state insertion/
deletion/lookup routinbes know about these internals. so just pass the
direction to the lookup functions and let them pick the right tree.
ok dhartmei markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.255 2007/08/30 09:28:48 dhartmei Exp $ */
a1275 4
};

struct pf_tag {
	u_int16_t	tag;		/* tag id */
@


1.255
log
@add support for address ranges ("from 10.1.2.50 - 10.1.3.75") in from/to
criteria. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.253 2007/06/25 13:57:18 henning Exp $ */
a60 1
enum	{ PF_LAN_EXT, PF_EXT_GWY, PF_ID };
d1586 1
a1586 1
				    u_int8_t, int *);
@


1.254
log
@remove obsolete pfi_statehead and pfik_w_states; ok henning@@
@
text
@d115 2
a116 1
	  PF_ADDR_TABLE, PF_ADDR_RTLABEL, PF_ADDR_URPFFAILED };
d333 3
d1618 2
@


1.253
log
@pretty mechanical change: now that the state tables use seperate state
keys that can map to multiple states (last not least for ifbound) we don't
need state tables hanging off each struct kif representing an interface
any more. use two globals for the two tables. ok markus ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.252 2007/06/24 11:17:13 mcbride Exp $ */
a1013 1
TAILQ_HEAD(pfi_statehead, pfi_kif);
a1031 1
	TAILQ_ENTRY(pfi_kif)		 pfik_w_states;
a1677 1
extern struct pfi_statehead	 pfi_statehead;
@


1.252
log
@Save some bytes and make code more readable by removing junk union and
unused ifname (this information is in struct pf_state_sync now).

Also a bit of KNF on the pf_state struct.

ok mpf@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.251 2007/06/21 11:55:54 henning Exp $ */
a757 1

d1017 4
a1032 2
	struct pf_state_tree_lan_ext	 pfik_lan_ext;
	struct pf_state_tree_ext_gwy	 pfik_ext_gwy;
@


1.251
log
@reimplement interface bound states in a non-retarded way.
previously, we had a set of state tables attached to each interface. so for
every packet we had to do a lookup in the tables for the interface, and
afterwards in the global tables.
since we split state keys and states now, use only the global tables, and
put the actual states in a tail queue attached to the state key. sort the
list so that ifbound states come before global ones. on lookup, we only
have to compare the interface pointer on the actual states and use the
first one where either the interface matches or the state is not interface
bound. thus, if you don't actually use ifbound states, and there is only
one state per state key, the overhead is close to zero, where we had extra
lookups before. in addition to a much cleaner design (that'll allow for more
goodies later) this gives us ~12.5% more forwarding performance.
mostly hacked at c2k7, lots of help, testing and ok mcbride & markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.250 2007/06/11 11:18:14 henning Exp $ */
d725 3
a727 3
	u_int64_t	 id;
	u_int32_t	 creatorid;
	u_int32_t	 pad;
d729 1
d732 6
d739 14
a752 4
	u_int8_t	 log;
	u_int8_t	 allow_opts;
	u_int8_t	 timeout;
	u_int8_t	 sync_flags;
a755 22
	union {
		struct {
			TAILQ_ENTRY(pf_state)	 entry_list;
			struct pfi_kif		*kif;
		} s;
		char	 ifname[IFNAMSIZ];
	} u;
	struct pf_state_peer src;
	struct pf_state_peer dst;
	union pf_rule_ptr rule;
	union pf_rule_ptr anchor;
	union pf_rule_ptr nat_rule;
	struct pf_addr	 rt_addr;
	struct pfi_kif	*rt_kif;
	struct pf_src_node	*src_node;
	struct pf_src_node	*nat_src_node;
	u_int64_t	 packets[2];
	u_int64_t	 bytes[2];
	u_int32_t	 creation;
	u_int32_t	 expire;
	u_int32_t	 pfsync_time;
	u_int16_t	 tag;
@


1.250
log
@move definitions for the flags in the mbuf header used by pf to mbuf.h
since we include the mbuf header parts for pf unconditionally, we should
be able to check them unconditionally as well. ok mcbride markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.249 2007/06/01 18:44:23 henning Exp $ */
d699 2
d712 2
a713 1
	struct pf_state	*state;
d729 1
@


1.249
log
@factor out duplicated code to allocate state key and cross-reference it
with a state entry into a new pf_alloc_state_key() function and use it
everywhere. makes upcoming changes way easier and is cleaner anyway.
conceptually agreed by ryan, but he's on the road now ;(
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.248 2007/05/31 22:45:36 mcbride Exp $ */
a1275 4

#define	PF_TAG_GENERATED		0x01
#define	PF_TAG_FRAGCACHE		0x02
#define	PF_TAG_TRANSLATE_LOCALHOST	0x04
@


1.248
log
@Make sure that pf_state_key and pf_state_key_cmp are in sync.

I am a retard for not testing properly and owe people beers tonight.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.247 2007/05/31 18:48:05 mcbride Exp $ */
d1645 2
@


1.247
log
@Move the state id and creatorid (used mainly by pfsync) into struct pf_state.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.246 2007/05/31 04:11:42 mcbride Exp $ */
a689 1
	u_int64_t	 id;
@


1.246
log
@First step of rearranging pf's state table internals...

- Split pf_state into pf_state (used for tracking connection information),
  and pf_state_key (used for searching the state table)

- Use pfsync_state in the ioctl for userland access to the state
  table. This will sheild userland somewhat from future changes.

ok henning@@ toby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.245 2007/05/28 17:16:39 henning Exp $ */
a690 1
	u_int32_t	 creatorid;
a700 2
	u_int64_t	 id;
	u_int32_t	 creatorid;
d709 2
a710 7
	union {
		struct {
			RB_ENTRY(pf_state_key)	 entry_lan_ext;
			RB_ENTRY(pf_state_key)	 entry_ext_gwy;
			RB_ENTRY(pf_state_key)	 entry_id;
		} s;
	} u;
d715 7
d723 5
d1011 1
a1011 1
    u.s.entry_lan_ext, pf_state_compare_lan_ext);
d1015 1
a1015 1
    u.s.entry_ext_gwy, pf_state_compare_ext_gwy);
d1548 2
a1549 2
RB_HEAD(pf_state_tree_id, pf_state_key);
RB_PROTOTYPE(pf_state_tree_id, pf_state_key,
d1588 1
a1588 1
extern struct pf_state		*pf_find_state_byid(struct pf_state_key_cmp *);
@


1.245
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.244 2007/02/23 21:31:51 deraadt Exp $ */
d688 2
a689 2
/* keep synced with struct pf_state, used in RB_FIND */
struct pf_state_cmp {
d701 1
a701 1
struct pf_state {
d711 14
a733 3
			RB_ENTRY(pf_state)	 entry_lan_ext;
			RB_ENTRY(pf_state)	 entry_ext_gwy;
			RB_ENTRY(pf_state)	 entry_id;
d756 108
d1005 2
a1006 2
RB_HEAD(pf_state_tree_lan_ext, pf_state);
RB_PROTOTYPE(pf_state_tree_lan_ext, pf_state,
d1009 2
a1010 2
RB_HEAD(pf_state_tree_ext_gwy, pf_state);
RB_PROTOTYPE(pf_state_tree_ext_gwy, pf_state,
d1339 2
a1340 2
	u_int32_t	 nr;
	struct pf_state	 state;
d1362 2
a1363 2
		caddr_t		 psu_buf;
		struct pf_state	*psu_states;
d1544 2
a1545 2
RB_HEAD(pf_state_tree_id, pf_state);
RB_PROTOTYPE(pf_state_tree_id, pf_state,
d1570 2
a1571 1
extern struct pool		 pf_state_pl, pf_altq_pl, pf_pooladdr_pl;
d1584 3
a1586 3
extern struct pf_state		*pf_find_state_byid(struct pf_state_cmp *);
extern struct pf_state		*pf_find_state_all(struct pf_state_cmp *key,
				    u_int8_t tree, int *more);
@


1.244
log
@if machine has more than 100MB of physmem, default the max table entries
to 200,000 instead of the conservative 100,000; ok dhartmei beck
tested by ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.243 2007/02/09 11:20:39 henning Exp $ */
a951 1
	struct pf_mtag	*pf_mtag;
a1158 10
struct pf_mtag {
	void		*hdr;		/* saved hdr pos in mbuf, for ECN */
	u_int		 rtableid;	/* alternate routing table id */
	u_int32_t	 qid;		/* queue id */
	u_int16_t	 tag;		/* tag id */
	u_int8_t	 flags;
	u_int8_t	 routed;
	sa_family_t	 af;		/* for ECN */
};

d1587 1
a1587 1
int		 pf_tag_packet(struct mbuf *, struct pf_mtag *, int, int);
a1590 2
struct pf_mtag	*pf_find_mtag(struct mbuf *);
struct pf_mtag	*pf_get_mtag(struct mbuf *);
@


1.243
log
@allow counters to be reset with DIOCGETRULES.
this allows an atomic read and reset counters, instead of read, reset in a
later ioctl and lose everything in between.
use the previously unused of pr->action. When it is set to PF_GET_CLR_CNTR,
the ioctl requires write permissions and counters are reset after they have
been copied out to userland.
obsoletes DIOCCLRRULECTRS, which only works for the main ruleset, but not
within anchors (yeah, that's how it all started)
ok dhartmei, mcbride and theo agree as well
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.242 2006/12/13 05:10:15 itojun Exp $ */
d1187 2
a1188 1
#define PFR_KENTRY_HIWAT	100000	/* Number of table entries */
@


1.242
log
@IPv6 passive OS fingerprinting.
reuses IPv4 signature file (assuming that TCP code is shared among IPv4/v6).
mcbride ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.241 2006/11/20 14:25:11 mcbride Exp $ */
d72 1
@


1.241
log
@ioctl to explicitly remove source tracking nodes,
diff from Berk D. Demir <bdd@@mindcast.org>

ok henning dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.240 2006/10/27 13:56:51 mcbride Exp $ */
d48 1
d456 1
d1648 2
a1649 1
	pf_osfp_fingerprint_hdr(const struct ip *, const struct tcphdr *);
@


1.240
log
@Split ruleset manipulation functions out into pf_ruleset.c to allow them to
be imported into pfctl. This is a precursor to separating ruleset parsing
from loading in pfctl, and tons of good things will come from it.

2 minor changes aside from cut-n-paste and #define portability magic:

- instead of defining the global pf_main_ruleset, define pf_main_anchor
  (which contains the pf_main_ruleset)

- allow pf_find_or_create_ruleset() to return the pf_main_ruleset if it's
  passed an empty anchor name.

ok henning dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.239 2006/10/25 11:26:47 henning Exp $ */
d1231 7
d1425 1
@


1.239
log
@add a "u_int8_t logif" to struct pfrule to select to which pflog interface
logs go. ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.238 2006/10/17 14:08:17 reyk Exp $ */
a1429 2
extern struct pf_anchor_global		  pf_anchors;
extern struct pf_ruleset		  pf_main_ruleset;
a1467 5
extern struct pf_anchor		*pf_find_anchor(const char *);
extern struct pf_ruleset	*pf_find_ruleset(const char *);
extern struct pf_ruleset	*pf_find_or_create_ruleset(const char *);
extern void			 pf_remove_if_empty_ruleset(
				    struct pf_ruleset *);
d1602 25
@


1.238
log
@increase max pf tag name size from 16 to 64 characters.

ok henning@@ dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.237 2006/10/11 08:42:31 mcbride Exp $ */
d566 1
@


1.237
log
@Allow the 'quick' keyword on an anchor. IFF there is a matching rule inside
the anchor, terminate ruleset evaluation when stepping out of the anchor.

This means that if you absolutely want the anchor to be terminal, you
probably want to use a 'block all' or 'pass all' rule at the start of the
anchor.

ok dhartmei@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.236 2006/07/06 13:25:40 henning Exp $ */
d510 1
a510 1
#define PF_QNAME_SIZE		 16
d514 1
a514 1
#define	PF_TAG_NAME_SIZE	 16
@


1.236
log
@allow rules to point to an alternate routing table, and tag packets
matching that rule so that the forwarding code later can use the
alternate routing table fo lookups (not implemented yet).
the tagging is "sticky", every matching rule modifies, just like the
regular "tag". ok claudio hshoexer, hacked at r2k6
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.235 2006/05/28 02:45:45 mcbride Exp $ */
d773 1
@


1.235
log
@Enable adaptive timeouts by default, with adaptive.start of 60% of the
state limit and adaptive.end of 120% of the state limit.
Explicitly setting the adaptive timeouts will override the default,
and it can be disabled by setting both adaptive.start and adaptive.end to 0.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.234 2006/03/14 11:09:42 djm Exp $ */
d533 1
d1157 1
d1591 1
a1591 1
int		 pf_tag_packet(struct mbuf *, struct pf_mtag *, int);
@


1.234
log
@implement a Unicast Reverse Path Forwarding (uRPF) check for pf(4)
which optionally verifies that a packet is received on the interface
that holds the route back to the packet's source address. This makes
it an automatic ingress filter, but only when routing is fully
symmetric.

bugfix feedback claudio@@; ok claudio@@ and dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.233 2005/11/04 08:24:15 mcbride Exp $ */
d614 2
@


1.233
log
@crank pf_state and pf_src_node byte and packet counters to u_in64_t, since
we're breaking pfsync compatibility this cycle anyways.

Requested by djm@@, ok henning@@, 'wheee!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.232 2005/10/27 12:34:40 mcbride Exp $ */
d113 1
a113 1
	  PF_ADDR_TABLE, PF_ADDR_RTLABEL };
d318 17
a334 15
#define	PF_MISMATCHAW(aw, x, af, neg)				\
	(							\
		(((aw)->type == PF_ADDR_NOROUTE &&		\
		    pf_routable((x), (af))) ||			\
		((aw)->type == PF_ADDR_RTLABEL &&		\
		    !pf_rtlabel_match((x), (af), (aw))) ||	\
		((aw)->type == PF_ADDR_TABLE &&			\
		    !pfr_match_addr((aw)->p.tbl, (x), (af))) ||	\
		((aw)->type == PF_ADDR_DYNIFTL &&		\
		    !pfi_match_addr((aw)->p.dyn, (x), (af))) || \
		((aw)->type == PF_ADDR_ADDRMASK &&		\
		    !PF_AZERO(&(aw)->v.a.mask, (af)) &&		\
		    !PF_MATCHA(0, &(aw)->v.a.addr,		\
		    &(aw)->v.a.mask, (x), (af)))) !=		\
		(neg)						\
d337 1
d1519 1
a1519 1
int	pf_routable(struct pf_addr *addr, sa_family_t af);
@


1.232
log
@Basic support for attaching states from pfsync to the correct rules.
Applies only to rules in the main ruleset (not anchors) if the ruleset
checksum matches. Necessary to fix the following for pfsync'd states:
	- per-rule limits on number of states
	- altq
	- rule-based settings such as timeouts

More work to do re: nat rules, src-nodes, etc.

NOTE: This is modifies the pfsync header and version number.
Tools which process pfsync packets must be recompiled, and firewalls with
different versions will not sync.

ok mpf@@ henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.231 2005/10/17 08:43:35 henning Exp $ */
d628 2
a629 2
	u_int32_t	 bytes[2];
	u_int32_t	 packets[2];
d727 2
a731 2
	u_int32_t	 packets[2];
	u_int32_t	 bytes[2];
@


1.231
log
@make pf use one mbuf tag instead of 6 distinct ones. use a little struct
in the data part for the data from the previously distinct tags.
look up the tag early and carry a pointer to it around.
makes the code easier and saves some tag lookups and thus helps performance,
as proven by tests run by Schberle Dniel <Schoeberle.Daniel@@aamtech.hu>
Initially hacked up somewhere over the atlantic ocean in an A330
early testing reyk and moritz, "put it in" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.230 2005/09/28 01:46:33 pascoe Exp $ */
d744 2
@


1.230
log
@Improve the safety of pf IOCTLs, taking into account that some paths can sleep.

- Introduces a rw_lock in pfioctl so that we can have concurrent readers
  but only one process performing updates at a time;

- Separates state expiry into "unlink" and "free" parts; anyone can unlink
  a state/src node from the RB trees at any time, but a state can only be
  freed whilst the write lock is held;

- Converts state_updates into list state_list containing all states,
  regardless of whether they are "linked" or "unlinked";

- Introduces a new PFTM_UNLINKED state that is used on the "unlinked" states
  to signal that they can be freed;

- Converts pf_purge_expired_state to an "unlink" state routine, which only
  unlinks the state from the RB trees.  Freeing the state/src nodes is left
  to the purge thread, which runs whilst holding a write lock, such that all
  "next" references remain valid;

- Converts pfsync_bulk_update and DIOCGETSTATES to walk state_list rather
  than the RB trees;

- Converts the purge thread to use the new state_list and perform a partial
  purge every second, with the target rate a full state table walk every
  PFTM_INTERVAL seconds.

seen by mcbride, henning, dhartmei pre-3.8, but too intrusive for then
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.229 2005/08/18 10:28:14 pascoe Exp $ */
d939 1
d1143 13
d1578 10
a1587 8
u_int16_t	pf_tagname2tag(char *);
void		pf_tag2tagname(u_int16_t, char *);
void		pf_tag_ref(u_int16_t);
void		pf_tag_unref(u_int16_t);
int		pf_tag_packet(struct mbuf *, struct pf_tag *, int);
u_int32_t	pf_qname2qid(char *);
void		pf_qid2qname(u_int32_t, char *);
void		pf_qid_unref(u_int32_t);
@


1.229
log
@Rearrange pf_state and pfi_kif so that the parts of the structure needed
to search for a particular entry in the RB trees are at the start of the
structure.

This permits us to place a much smaller structure on the stack in the
interrupt paths that match packets against state entries.

ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.228 2005/08/11 05:09:30 joel Exp $ */
d40 1
d83 2
a84 1
	  PFTM_TS_DIFF, PFTM_MAX, PFTM_PURGE, PFTM_UNTIL_PACKET };
d713 1
a713 1
			TAILQ_ENTRY(pf_state)	 entry_updates;
d1403 1
a1403 1
extern struct pf_state_queue state_updates;
d1430 4
a1433 3
extern void			 pf_purge_expired_src_nodes(void);
extern void			 pf_purge_expired_states(void);
extern void			 pf_purge_expired_state(struct pf_state *);
d1575 1
@


1.228
log
@Only decrement the max-src-conn counter for tcp connections that reached
"established" state. Requires recompiling pfctl, etc.


ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.227 2005/08/02 12:40:42 pascoe Exp $ */
d676 13
d691 15
a715 3
	struct pf_state_host lan;
	struct pf_state_host gwy;
	struct pf_state_host ext;
a729 1
	u_int32_t	 creatorid;
a730 11
	sa_family_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
	u_int8_t	 log;
	u_int8_t	 allow_opts;
	u_int8_t	 timeout;
	u_int8_t	 sync_flags;
#define	PFSTATE_NOSYNC	 0x01
#define	PFSTATE_FROMSYNC 0x02
#define	PFSTATE_STALE	 0x04
	u_int8_t	 pad;
d882 5
d888 1
a889 1
	char				 pfik_name[IFNAMSIZ];
d1437 2
a1438 2
extern struct pf_state		*pf_find_state_byid(struct pf_state *);
extern struct pf_state		*pf_find_state_all(struct pf_state *key,
@


1.227
log
@Instead of copying a table structure so we can mask off a bit before
"validating" it, pass the bits to be ignored down to the validating
function in its allowedflags argument.  Saves a 1kB+ stack allocation.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.226 2005/07/31 05:20:57 pascoe Exp $ */
d669 1
d671 1
@


1.226
log
@Perform pf state/rule/table expiry in a kernel thread instead of running
it out of a timeout handler.

This means we will have process context, required when using the oldnointr
pool allocator.

Addresses pr4186, pr4273.

ok dhartmei@@ henning@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.225 2005/06/30 20:52:20 sturm Exp $ */
d1504 1
a1504 1
	    int *, int *, int *, int);
@


1.225
log
@in order for pfvar.h not to conflict with openssl's crypto.h, use
PF_MD5_DIGEST_LENGTH instead of including crypto/md5.h

ok markus@@, henning@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.224 2005/06/13 20:54:50 henning Exp $ */
d1407 1
a1407 1
extern void			 pf_purge_timeout(void *);
@


1.224
log
@spurious XXX comment left over from interface abstraction code whacking
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.223 2005/06/13 20:17:25 henning Exp $ */
a44 1
#include <crypto/md5.h>
d51 7
d1057 1
a1057 1
	u_int8_t	pf_chksum[MD5_DIGEST_LENGTH];
@


1.223
log
@make the packet and byte counters on rules and src nodes per direction,
matches the counters on states now. also fix the counting on scrub rules
where we previously did not handle the byte counters at all.
extend pfctl -sl output to include the new seperate in/out counters
hacked on the ferry from Earls Cove to Saltery Bay
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.222 2005/06/05 20:47:46 henning Exp $ */
d866 1
a866 1
	u_int32_t			 pfik_tzero;	/* XXX */
@


1.222
log
@const'ify the char * parameter to pfi_kif_get and pfi_group_change
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.221 2005/05/27 21:41:03 mpf Exp $ */
d513 2
a514 2
	u_int64_t		 packets;
	u_int64_t		 bytes;
d620 2
a621 2
	u_int32_t	 bytes;
	u_int32_t	 packets;
@


1.221
log
@Calculate an MD5 checksum over the main pf ruleset.
This is the basis for further pfsync improvements,
to ensure that pf rules are in sync with the master.

"get it in" mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.220 2005/05/27 17:22:41 dhartmei Exp $ */
d1515 1
a1515 1
struct pfi_kif	*pfi_kif_get(char *);
d1523 1
a1523 1
void		 pfi_group_change(char *);
@


1.220
log
@log two pairs of uid/pid through pflog: the uid/pid of the process that
inserted the rule which causes the logging. secondly, the uid/pid of the
process in case the logged packet is delivered to/from a local socket.
a lookup of the local socket can be forced for logged packets with a new
option, 'log (user)'. make tcpdump print the additional information when
-e and -v is used. note: this changes the pflog header struct, rebuild all
dependancies. ok bob@@, henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.219 2005/05/26 15:29:48 dhartmei Exp $ */
d45 1
d1051 1
@


1.219
log
@support 'log' and 'log-all' in 'nat/rdr/binat pass' rules. original patch
from camield@@. use #defines PF_LOG, PF_LOGALL instead of magic constants.
ok frantzen@@, camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.218 2005/05/25 06:50:05 henning Exp $ */
d111 2
a112 1
#define	PF_LOGALL		0x02
d537 2
d887 6
d1444 2
a1445 1
	    u_int8_t, struct pf_rule *, struct pf_rule *, struct pf_ruleset *);
d1471 1
@


1.218
log
@when an interface joins or leaves a group call back into pf so it can
update the internal tables used for (ifgroup) notation
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.217 2005/05/23 23:28:53 dhartmei Exp $ */
d63 1
d109 3
@


1.217
log
@change pool allocation of table entries, no longer use the oldnointr
allocator and two pools, but PR_WAITOK when called from non-interrupt
context (ioctl). add configurable hard limits for tables and table
entries (set limit tables/table-entries), defaulting to 1000/100000.
ok aaron@@, henning@@, mcbride@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.216 2005/05/23 22:30:21 henning Exp $ */
d1506 1
@


1.216
log
@further cleanup: don't mimic ifnet and add hooks and the dohooks() stuff to
pf's interface abstraction, just attahc a linked list of the dynaddrs to
the respective kifs. makes things way easier and will be needed for the next
step, ryan jajajaja
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.215 2005/05/22 18:23:04 henning Exp $ */
d97 2
a98 1
enum	{ PF_LIMIT_STATES, PF_LIMIT_SRC_NODES, PF_LIMIT_FRAGS, PF_LIMIT_MAX };
d1114 3
@


1.215
log
@allow pf to match on interface groups
pass on mygroup ...
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.214 2005/05/21 21:03:57 henning Exp $ */
d155 13
a167 12
	struct pf_addr		 pfid_addr4;
	struct pf_addr		 pfid_mask4;
	struct pf_addr		 pfid_addr6;
	struct pf_addr		 pfid_mask6;
	struct pfr_ktable	*pfid_kt;
	struct pfi_kif		*pfid_kif;
	void			*pfid_hook_cookie;
	int			 pfid_net;	/* optional mask, or 128 */
	int			 pfid_acnt4;	/* address count, IPv4 */
	int			 pfid_acnt6;	/* address count, IPv6 */
	sa_family_t		 pfid_af;	/* rule address family */
	u_int8_t		 pfid_iflags;	/* PFI_AFLAG_* */
a861 1
	struct hook_desc_head		*pfik_ah_head;
d867 1
@


1.214
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.213 2005/03/03 07:13:39 dhartmei Exp $ */
d864 1
d1499 2
@


1.213
log
@when tagging, apply the same tag to all packets matching a state entry
(not just to the initial packet). note: kernel/userland abi change
(rebuild pfctl). ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.212 2005/01/30 00:02:30 dhartmei Exp $ */
a590 1
#define PFRULE_GRBOUND		0x00020000	/* group-bound */
a847 13
struct pfi_if {
	char				 pfif_name[IFNAMSIZ];
	u_int64_t			 pfif_packets[2][2][2];
	u_int64_t			 pfif_bytes[2][2][2];
	u_int64_t			 pfif_addcnt;
	u_int64_t			 pfif_delcnt;
	long				 pfif_tzero;
	int				 pfif_states;
	int				 pfif_rules;
	int				 pfif_flags;
};

TAILQ_HEAD(pfi_grouphead, pfi_kif);
d850 1
a851 1
	struct pfi_if			 pfik_if;
d853 5
a859 2
	struct pfi_grouphead		 pfik_grouphead;
	TAILQ_ENTRY(pfi_kif)		 pfik_instances;
a862 1
	struct pfi_kif			*pfik_parent;
d867 7
a873 15
#define pfik_name	pfik_if.pfif_name
#define pfik_packets	pfik_if.pfif_packets
#define pfik_bytes	pfik_if.pfif_bytes
#define pfik_tzero	pfik_if.pfif_tzero
#define pfik_flags	pfik_if.pfif_flags
#define pfik_addcnt	pfik_if.pfif_addcnt
#define pfik_delcnt	pfik_if.pfif_delcnt
#define pfik_states	pfik_if.pfif_states
#define pfik_rules	pfik_if.pfif_rules

#define PFI_IFLAG_GROUP		0x0001	/* group of interfaces */
#define PFI_IFLAG_INSTANCE	0x0002	/* single instance */
#define PFI_IFLAG_CLONABLE	0x0010	/* clonable group */
#define PFI_IFLAG_DYNAMIC	0x0020	/* dynamic group */
#define PFI_IFLAG_ATTACHED	0x0040	/* interface attached */
a874 1
#define PFI_IFLAG_SETABLE_MASK	0x0100	/* setable via DIOC{SET,CLR}IFFLAG */
a1263 5

#define PFI_FLAG_GROUP		0x0001	/* gets groups of interfaces */
#define PFI_FLAG_INSTANCE	0x0002	/* gets single interfaces */
#define PFI_FLAG_ALLMASK	0x0003

a1341 1
#define DIOCICLRISTATS  _IOWR('D', 88, struct pfioc_iface)
a1362 1
extern struct pfi_kif			**pfi_index2kif;
d1488 3
d1492 4
a1495 1
void		 pfi_attach_clone(struct if_clone *);
d1498 2
a1499 7
struct pfi_kif	*pfi_lookup_create(const char *);
struct pfi_kif	*pfi_lookup_if(const char *);
int		 pfi_maybe_destroy(struct pfi_kif *);
struct pfi_kif	*pfi_attach_rule(const char *);
void		 pfi_detach_rule(struct pfi_kif *);
void		 pfi_attach_state(struct pfi_kif *);
void		 pfi_detach_state(struct pfi_kif *);
d1501 1
a1502 1
void		 pfi_dynaddr_remove(struct pf_addr_wrap *);
d1504 2
a1505 2
int		 pfi_clr_istats(const char *, int *, int);
int		 pfi_get_ifaces(const char *, struct pfi_if *, int *, int);
a1507 4
int		 pfi_match_addr(struct pfi_dynaddr *, struct pf_addr *,
		    sa_family_t);

extern struct pfi_statehead	pfi_statehead;
@


1.213.2.1
log
@MFC:
Fix by pascoe@@

Perform pf state/rule/table expiry in a kernel thread instead of running
it out of a timeout handler.

This means we will have process context, required when using the oldnointr
pool allocator.

Addresses pr4186, pr4273.

ok dhartmei@@ deraadt@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.213 2005/03/03 07:13:39 dhartmei Exp $ */
d1408 1
a1408 1
extern void			 pf_purge_thread(void *);
@


1.212
log
@Add some more reason counters and use them instead of overloading the
'memory' one, which helps debugging. Alters the kernel/userland ABI,
rebuild pfctl and tcpdump. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.211 2005/01/05 18:09:54 mcbride Exp $ */
d689 1
d1542 1
@


1.211
log
@Define defaults for the timeouts ensure consistency between kernel
and userland.

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.211 2005/01/05 17:49:41 mcbride Exp $ */
d937 9
a945 1
#define PFRES_MAX	7		/* total+1 */
d955 8
@


1.210
log
@Introduce 'set skip on <ifspec>' to support a list of interfaces where no
packet filtering should occur (like loopback, for instance).
Code from Max Laier, with minor improvements based on feedback from
deraadt@@. ok mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.209 2004/12/10 22:13:26 henning Exp $ */
d75 21
@


1.209
log
@allow pf to filter on route labels
pass in from route dtag keep state queue reallyslow
tested by Gabriel Kihlman <gk@@stacken.kth.se> and
Michael Knudsen <e@@molioner.dk> and ryan
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.208 2004/12/07 10:33:41 dhartmei Exp $ */
d872 2
d1331 2
d1495 2
@


1.208
log
@re-commit mcbride@@'s 'flush global', this time without the breakage in
pfvar.h. builds kernel and userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.207 2004/12/07 09:36:16 deraadt Exp $ */
d42 1
d81 1
a81 1
	  PF_ADDR_TABLE };
d118 2
d285 2
d1436 1
@


1.207
log
@tree does not compile, spotted by dlg (not obvious how to fix)
----
Change the default for 'overload <table> flush' to flush only states from the
offending source created by the rule. 'flush global' flushes all states
originating from the offending source. ABI change, requires kernel and pfctl
to be in sync.

ok deraadt@@ henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.205 2004/12/04 07:49:48 mcbride Exp $ */
d540 4
a554 1
#define PFRULE_SRCTRACK_FLUSH	0x0080	/* flush for src_node->open_states */
@


1.206
log
@Change the default for 'overload <table> flush' to flush only states from the
offending source created by the rule. 'flush global' flushes all states
originating from the offending source. ABI change, requires kernel and pfctl
to be in sync.

ok deraadt@@ henning@@ dhartmei@@
@
text
@a539 4

#define PF_FLUSH		0x01
#define PF_FLUSH_GLOBAL		0x02
	u_int8_t		 flush;
d551 1
d1222 1
a1222 2
	int			 pfrio_size;	/* entries this transaction */
	int			 pfrio_tsize;	/* total entries */
d1447 6
a1452 6
int	pfr_add_addrs(struct pfr_table *, struct pfr_addr *, int, int, int *,
	    int, u_int32_t *);
int	pfr_del_addrs(struct pfr_table *, struct pfr_addr *, int, int, int *,
	    int, u_int32_t *);
int	pfr_set_addrs(struct pfr_table *, struct pfr_addr *, int, int, int *,
	    int *, int *, int *, int, u_int32_t *);
@


1.205
log
@Add kernel code to keep track of tcp connections which have completed
the 3-way handshake. Allow limits on both total connections and connection
rate, put offenders in a table which can be used in the ruleset, and optionally
kill existing states. Rate tracking code from dhartmei@@.

Adds a second pool for table entries using the default allocator, which
allows entries to be added at splsoftnet().

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.204 2004/11/16 20:07:57 mcbride Exp $ */
d540 4
a554 1
#define PFRULE_SRCTRACK_FLUSH	0x0080	/* flush for src_node->open_states */
d1225 2
a1226 1
	int			 pfrio_size;
d1451 6
a1456 6
int	pfr_add_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_del_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_set_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, int *, int *, int);
@


1.204
log
@Fix for PR3983
- Add a new PFSTATE_STALE flag to uncompressed state updates sent as a result
  of a stale state being detected, and prevent updates with this flag from
  generating similar messages.
- For the specific case where the state->src in the recieved update is ok but
  the state.dst is not, take the partial update, then "fail" to let the other
  peers pick up the better data that we have. From Chris Pascoe.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.203 2004/09/21 16:59:12 aaron Exp $ */
d473 2
d484 1
d494 5
d551 1
d566 10
d585 2
d781 1
d919 21
d994 1
d1446 1
@


1.203
log
@Implement "no scrub" to allow exclusion of specific traffic from scrub rules.
First match wins, just like "no {binat,nat,rdr}".  henning@@, dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.202 2004/07/12 00:50:22 itojun Exp $ */
d648 1
@


1.202
log
@remove PF_FORWARD (which was introduced by ipv6 reass-on-scrub).
daniel found it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.201 2004/07/11 15:54:21 itojun Exp $ */
d52 1
a52 1
enum	{ PF_PASS, PF_DROP, PF_SCRUB, PF_NAT, PF_NONAT,
@


1.201
log
@backout IPv6 reass-on-scrub patch (more work needs to be done).
requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.200 2004/06/25 10:10:14 itojun Exp $ */
d50 1
a50 1
enum	{ PF_INOUT, PF_IN, PF_OUT, PF_FORWARD };
@


1.200
log
@re-introduce PF_INOUT and move PF_FORWARD def to the end.
pfctl is assuming that the keyword == 0 in its parser! (see decl for "dir").
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.199 2004/06/25 00:42:58 itojun Exp $ */
d1370 1
a1370 1
	    struct pf_pdesc *, struct mbuf **);
@


1.199
log
@IPv6 reassembly on "scrub" directive.

caveats: (to be addressed soon)
- "scrub in" should queue fragments back into ip6intrq again, but
  somehow it does not happen - the packet is kept inside reass queue.
  need investigation
- ip6_forwarding path is not tested
- does not use red-black tree.  somehow red-black tree behaved badly
  and was not robust.  performance issue, the above one is more
  important.

good things:
- "scrub out" is perfectly ok
- i think now we can inspect upper-layer protocol fields (tcp port)
  even if ip6 packet is fragmented.
- reass queue will be cleaned up properly by timeout (60sec).  we might
  want to impose pool limit as well
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.198 2004/06/21 19:26:01 mcbride Exp $ */
d50 1
a50 1
enum	{ PF_FORWARD, PF_IN, PF_OUT };
@


1.198
log
@Get rid of pf_test_eh() wrapper.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.197 2004/06/14 20:53:27 cedric Exp $ */
d50 1
a50 1
enum	{ PF_INOUT, PF_IN, PF_OUT };
d1370 1
a1370 1
	    struct pf_pdesc *);
@


1.197
log
@Remove DIOCBEGINRULES, DIOCCOMMITRULES, DIOCBEGINALTQS, DIOCCOMMITALTQS,
DIOCRINABEGIN, DIOCRINACOMMIT ioctls.
Use DIOCXBEGIN/DIOCXCOMMIT/DIOCXROLLBACK instead.
ok beck@@ dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.196 2004/06/10 14:22:54 dhartmei Exp $ */
d1344 1
a1344 2
int	pf_test(int, struct ifnet *, struct mbuf **);
int	pf_test_eh(int, struct ifnet *, struct mbuf **, struct ether_header *);
d1348 1
a1348 2
int	pf_test6(int, struct ifnet *, struct mbuf **);
int	pf_test6_eh(int, struct ifnet *, struct mbuf **, struct ether_header *);
@


1.196
log
@rename struct pf_rule_addr member 'not' to 'neg', as 'not' is a reserved
keyword in C++. ok henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.195 2004/05/19 17:50:52 dhartmei Exp $ */
a1212 1
#define DIOCBEGINRULES	_IOWR('D',  3, struct pfioc_rule)
a1213 1
#define DIOCCOMMITRULES	_IOWR('D',  5, struct pfioc_rule)
a1235 1
#define DIOCBEGINALTQS	_IOWR('D', 44, u_int32_t)
a1236 1
#define DIOCCOMMITALTQS	_IOWR('D', 46, u_int32_t)
a1263 2
#define DIOCRINABEGIN	_IOWR('D', 75, struct pfioc_table)
#define DIOCRINACOMMIT	_IOWR('D', 76, struct pfioc_table)
@


1.195
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.194 2004/05/11 07:34:11 dhartmei Exp $ */
d278 1
a278 1
#define	PF_MISMATCHAW(aw, x, af, not)				\
d290 1
a290 1
		(not)						\
d306 1
a306 1
	u_int8_t		 not;
@


1.194
log
@pf_cksum_fixup() was called without last argument from normalization,
also fixup checksum when random-id modifies ip_id. This would previously
lead to incorrect checksums for packets modified by scrub random-id.
From Pyun YongHyeon. ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.193 2004/05/05 23:16:03 frantzen Exp $ */
d36 1
d448 2
a468 2
#define	PF_ANCHOR_NAME_SIZE	 16
	char			 anchorname[PF_ANCHOR_NAME_SIZE];
d530 2
a655 3
	TAILQ_ENTRY(pf_ruleset)	 entries;
#define PF_RULESET_NAME_SIZE	 16
	char			 name[PF_RULESET_NAME_SIZE];
d670 2
a671 2
TAILQ_HEAD(pf_rulesetqueue, pf_ruleset);

d673 4
a676 1
	TAILQ_ENTRY(pf_anchor)	 entries;
d678 2
a679 2
	struct pf_rulesetqueue	 rulesets;
	int			 tables;
d682 2
a683 2

TAILQ_HEAD(pf_anchorqueue, pf_anchor);
a685 1
#define PF_INTERFACE_RULESET	"_if"
d698 1
a698 2
	char			 pfrt_anchor[PF_ANCHOR_NAME_SIZE];
	char			 pfrt_ruleset[PF_RULESET_NAME_SIZE];
d1052 1
a1052 2
	char			 anchor[PF_ANCHOR_NAME_SIZE];
	char			 ruleset[PF_RULESET_NAME_SIZE];
d1061 2
a1062 2
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
d1143 1
a1143 1
struct pfioc_anchor {
d1145 1
a1148 6
struct pfioc_ruleset {
	u_int32_t	 nr;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 name[PF_RULESET_NAME_SIZE];
};

d1156 1
a1156 2
		char		anchor[PF_ANCHOR_NAME_SIZE];
		char		ruleset[PF_RULESET_NAME_SIZE];
d1250 1
a1250 2
#define	DIOCGETANCHORS	_IOWR('D', 56, struct pfioc_anchor)
#define	DIOCGETANCHOR	_IOWR('D', 57, struct pfioc_anchor)
d1294 1
a1294 1
extern struct pf_anchorqueue		  pf_anchors;
d1335 2
a1336 4
extern struct pf_ruleset	*pf_find_ruleset(char *, char *);
extern struct pf_ruleset	*pf_find_or_create_ruleset(
				    char[PF_ANCHOR_NAME_SIZE],
				    char[PF_RULESET_NAME_SIZE]);
@


1.193
log
@Use RFC1323 PAWS timestamps as a logical extension to the conventional TCP
sequence numbers by taking advantage of the maximum 1KHz clock as an upperbound
on the timestamp.  Typically gains 10 to 18 bits of additional security against
blind data insertion attacks.  More if the TS Echo wasn't optional :-(
Enabled with:  scrub on !lo0 all reassemble tcp
ok dhartmei@@.  documentation help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.192 2004/04/28 02:51:58 cedric Exp $ */
d1348 2
@


1.192
log
@make return-rst work on pure bridges. ok dhartmei@@ henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.191 2004/04/27 18:28:07 frantzen Exp $ */
d72 1
a72 1
	  PFTM_MAX, PFTM_PURGE, PFTM_UNTIL_PACKET };
d572 4
d577 6
a582 2
#define PFSS_TIMESTAMP	0x0001		/* modulate timestamp	*/
	u_int8_t	pfss_ttl;	/* stashed TTL		*/
d584 1
a584 1
	u_int32_t	pfss_ts_mod;	/* timestamp modulation	*/
d881 2
a882 1
#define PFRES_MAX	6		/* total+1 */
d891 1
d1339 2
d1392 2
a1393 2
	    u_short *, struct tcphdr *, struct pf_state_peer *,
	    struct pf_state_peer *, int *);
@


1.191
log
@validate the sequence numbers on TCP resets are an exact match.  check is only
enabled when we're doing full frag reassembly and thus have full seq info
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.190 2004/04/26 00:12:28 cedric Exp $ */
d849 2
d1346 1
d1351 1
@


1.190
log
@anchor refcounting. ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.189 2004/04/25 18:09:30 pb Exp $ */
d854 1
d1366 4
a1369 2
int	pf_normalize_ip(struct mbuf **, int, struct pfi_kif *, u_short *);
int	pf_normalize_ip6(struct mbuf **, int, struct pfi_kif *, u_short *);
@


1.189
log
@get rid of a complete state tree walk at state expire while in splnet()

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.188 2004/04/24 23:22:54 cedric Exp $ */
d669 1
a1309 1
extern void			 pf_update_anchor_rules(void);
@


1.188
log
@Add "probability xxx" rule modifier. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.187 2004/03/22 04:54:18 mcbride Exp $ */
d1316 1
@


1.187
log
@Support for best effort bulk transfers of states when pfsync syncif is
configured.  This this allows pfsync+carp clusters to come up gracefully
without killing active connections. pfsync now prevents carp from
preempting to become master until the state table has sync'd.

ABI change, any application which use struct pf_state must be recompiled.

Reminded about this by Christian Gut. Thanks to beck@@ cedric@@ and dhartmei@@
for testing and comments.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.186 2004/02/20 19:22:03 mcbride Exp $ */
d494 1
@


1.186
log
@Make pfsync deal with clearing states bound to a group or interface (eg
pfctl -i fxp0 -Fs). Also don't send out individual state deletions if we're
sending a clear message, move pfsync_clear_states() inside splnet, and fix
if_pfsync.h includes in  pf.c and pf_ioctl.c.

ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.185 2004/02/19 21:29:51 cedric Exp $ */
d595 2
d604 1
d623 1
d1284 1
@


1.185
log
@Makes pfctl -Fs and pfctl -w works with the optional -i specifier.
Kernel/Userland Sync needed. ok dhartmei@@ jmc@@ markus@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.184 2004/02/19 07:41:45 kjc Exp $ */
d1413 1
@


1.184
log
@the 2nd round of the qid assignment change.
make the semantics in line with the tag assignment, which simplifies
the id management in pf.

ok, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.183 2004/02/10 22:42:57 dhartmei Exp $ */
d1072 1
d1206 1
a1206 1
#define DIOCCLRSTATES	_IO  ('D', 18)
@


1.183
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.182 2004/02/10 18:49:10 henning Exp $ */
a1301 2
extern void			 pf_rule_set_qid(struct pf_rulequeue *);
extern u_int32_t		 pf_qname_to_qid(char *);
d1432 3
@


1.182
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.181 2004/02/04 10:43:18 mcbride Exp $ */
d561 1
a561 1
	u_int32_t        states;
d622 1
a622 1
	u_int32_t        creatorid;
d762 2
a763 2
#define pfrkt_anchor    pfrkt_t.pfrt_anchor
#define pfrkt_ruleset   pfrkt_t.pfrt_ruleset
d838 2
a839 2
	struct pf_addr   baddr;         /* address before translation */
	struct pf_addr   naddr;         /* address after translation */
@


1.181
log
@Fix a number of bugs with setting pool limits which I introduced with
source-tracking. Found by Pyun YongHyeon.
Also add support to pfctl to set the src-nodes pool limit.

"Luckily" some of the bugs cancel each other out; update kernel before
pfctl.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.180 2003/12/31 11:18:25 cedric Exp $ */
d783 2
a784 2
        u_int64_t			 pfif_packets[2][2][2];
        u_int64_t			 pfif_bytes[2][2][2];
d1184 6
a1189 6
	char			 pfiio_name[IFNAMSIZ];
        void                    *pfiio_buffer;
        int                      pfiio_esize;
        int                      pfiio_size;
	int			 pfiio_nzero;
        int                      pfiio_flags;
@


1.180
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.179 2003/12/15 09:10:26 henning Exp $ */
d567 2
@


1.179
log
@ryan left a few for me ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.178 2003/12/15 07:11:30 mcbride Exp $ */
d102 6
d118 1
a118 1
		struct pf_addr_dyn	*dyn;
d120 1
d124 1
d127 15
a141 7
struct pf_addr_dyn {
	char			 ifname[IFNAMSIZ];
	struct ifnet		*ifp;
	struct pf_addr		*addr;
	sa_family_t		 af;
	void			*hook_cookie;
	u_int8_t		 undefined;
a147 2
#ifdef _KERNEL

d284 1
a284 4
		    ((aw)->p.dyn->undefined ||			\
		    (!PF_AZERO(&(aw)->v.a.mask, (af)) &&	\
		    !PF_MATCHA(0, &(aw)->v.a.addr,		\
		    &(aw)->v.a.mask, (x), (af))))) ||		\
d313 1
a313 1
	struct ifnet			*ifp;
d479 1
a479 1
	struct ifnet		*ifp;
d547 4
d558 1
a558 1
	struct ifnet	*ifp;
d595 9
a603 3
	RB_ENTRY(pf_state) entry_lan_ext;
	RB_ENTRY(pf_state) entry_ext_gwy;
	RB_ENTRY(pf_state) entry_id;
d613 1
a613 1
	struct ifnet	*rt_ifp;
d666 3
d755 1
d771 54
d1153 3
d1177 14
d1265 2
a1272 10
RB_HEAD(pf_state_tree_lan_ext, pf_state);
RB_PROTOTYPE(pf_state_tree_lan_ext, pf_state,
    entry_lan_ext, pf_state_compare_lan_ext);
extern struct pf_state_tree_lan_ext tree_lan_ext;

RB_HEAD(pf_state_tree_ext_gwy, pf_state);
RB_PROTOTYPE(pf_state_tree_ext_gwy, pf_state,
    entry_ext_gwy, pf_state_compare_ext_gwy);
extern struct pf_state_tree_ext_gwy tree_ext_gwy;

d1278 2
a1279 2
extern struct pf_anchorqueue		 pf_anchors;
extern struct pf_ruleset		 pf_main_ruleset;
d1281 1
a1281 1
extern struct pf_poolqueue		 pf_pools[2];
d1283 3
a1285 3
extern struct pf_altqqueue		 pf_altqs[2];
extern struct pf_palist			 pf_pabuf;

d1303 1
a1303 1
extern struct pool		 pf_src_tree_pl, pf_rule_pl, pf_addr_pl;
d1309 2
a1310 1
extern int			 pf_insert_state(struct pf_state *);
d1315 3
a1317 1
extern struct pf_state		*pf_find_state(struct pf_state *, u_int8_t);
d1320 3
a1322 1
extern struct pf_ruleset	*pf_find_or_create_ruleset(char *, char *);
d1326 1
a1326 1
extern struct ifnet		*status_ifp, *sync_ifp;
d1347 1
a1347 1
int	pflog_packet(struct ifnet *, struct mbuf *, sa_family_t, u_int8_t,
d1357 3
a1359 3
int	pf_normalize_ip(struct mbuf **, int, struct ifnet *, u_short *);
int	pf_normalize_ip6(struct mbuf **, int, struct ifnet *, u_short *);
int	pf_normalize_tcp(int, struct ifnet *, struct mbuf *, int, int, void *,
d1377 1
d1407 20
a1426 3
int	pfi_dynaddr_setup(struct pf_addr_wrap *, sa_family_t);
void	pfi_dynaddr_copyout(struct pf_addr_wrap *);
void	pfi_dynaddr_remove(struct pf_addr_wrap *);
@


1.178
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.177 2003/12/15 00:02:04 mcbride Exp $ */
d830 2
a831 2
#define SCNT_SRC_NODE_REMOVALS	2	
#define SCNT_MAX		3	
d1054 1
a1054 1
#define PF_RULESET_TABLE 	(PF_RULESET_MAX+1)
@


1.177
log
@Add support to track stateful connections by source ip. This allows us
to:
- Ensure that clients get a consistent IP mapping with load-balanced
  translation/routing rules
- Limit the number of simultaneous connections a client can make
- Limit the number of clients which can connect through a rule

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.176 2003/12/12 20:05:45 cedric Exp $ */
d50 1
a50 1
enum	{ PF_LAN_EXT, PF_EXT_GWY };
d579 1
d582 1
d599 1
d606 4
a609 1
	u_int8_t	 pad[2];
d853 1
d859 1
d1166 3
a1168 3
#define DIOCGETSRCNODES		_IOWR('D', 84, struct pfioc_src_nodes)
#define DIOCCLRSRCNODES		_IO('D', 85)

d1185 5
d1233 1
a1233 1
extern struct ifnet		*status_ifp;
@


1.176
log
@Move PF interface code to new net/pf_if.c
Expect improvements in this area soon.
ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.175 2003/12/11 13:13:27 cedric Exp $ */
d71 2
a72 2
	  PFTM_ADAPTIVE_START, PFTM_ADAPTIVE_END, PFTM_MAX,
	  PFTM_PURGE, PFTM_UNTIL_PACKET };
d74 1
a74 1
enum	{ PF_LIMIT_STATES, PF_LIMIT_FRAGS, PF_LIMIT_MAX };
d81 1
a450 1
	u_int32_t		 timeout[PFTM_MAX];
d472 2
d476 3
d526 2
d538 14
d591 2
d822 4
d844 1
d849 1
d995 10
d1158 2
d1163 4
d1202 1
a1202 1
extern struct pool		 pf_rule_pl, pf_addr_pl;
d1206 1
d1209 4
@


1.175
log
@Fix PR3587 and other related problems with NAT and table stats.
PPL that have that problem and cannot upgrade to -current could
just comment out the assertion in pfr_update_stats().
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.174 2003/11/08 00:45:34 mcbride Exp $ */
a1152 4
extern int			 pf_dynaddr_setup(struct pf_addr_wrap *,
				    sa_family_t);
extern void			 pf_dynaddr_copyout(struct pf_addr_wrap *);
extern void			 pf_dynaddr_remove(struct pf_addr_wrap *);
d1249 4
@


1.174
log
@Add 'no-sync' state option to prevent state transition messages for states
created by this rule from appearing on the pfsync(4) interface. e.g.

pass in proto tcp to self flags S/SA keep state (no-sync)

ok cedric@@ henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.173 2003/10/31 10:34:47 mcbride Exp $ */
d728 3
@


1.173
log
@Remove remenants of pf_tree stuff that I missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.172 2003/10/25 20:27:07 mcbride Exp $ */
d520 1
@


1.172
log
@Build state search indexes directly on pf_state instead of pf_tree_node.
This saves more than 30% memory on state entries, and simplifies the state
insertion and removal code as well.

NOTE: This changes the pf API; userland tools must be updated to match.

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.171 2003/09/26 21:44:09 cedric Exp $ */
d1157 1
a1157 1
extern struct pool		 pf_tree_pl, pf_rule_pl, pf_addr_pl;
@


1.171
log
@Rearchitecture of the userland/kernel IOCTL interface for transactions.
This brings us close to 100% atomicity for a "pfctl -f pf.conf" command.
(some splxxx work remain in the kernel). Basically, improvements are:

   - Anchors/Rulesets cannot disappear unexpectedly anymore.
   - No more leftover in the kernel if "pfctl -f" fail.
   - Commit is now done in a single atomic IOCTL.

WARNING: The kernel code is fully backward compatible, but the new
pfctl/authpf userland utilities will only run on a new kernel.

The following ioctls are deprecated (i.e. will be deleted sooner or
later, depending on how many 3rd party utilities use them and how soon
they can be upgraded):

   - DIOCBEGINRULES
   - DIOCCOMMITRULES
   - DIOCBEGINALTQS
   - DIOCCOMMITALTQS
   - DIOCRINABEGIN
   - DIOCRINADEFINE

They are replaced by the following ioctls (yes, PF(4) will follow)
which operate on a vector of rulesets:

   - DIOCXBEGIN
   - DIOCXCOMMIT
   - DIOCXROLLBACK

Ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.170 2003/08/22 21:50:34 david Exp $ */
d50 1
d557 2
a581 9
struct pf_tree_node {
	RB_ENTRY(pf_tree_node) entry;
	struct pf_state	*state;
	struct pf_addr	 addr[2];
	u_int16_t	 port[2];
	sa_family_t	 af;
	u_int8_t	 proto;
};

d1118 9
a1126 3
RB_HEAD(pf_state_tree, pf_tree_node);
RB_PROTOTYPE(pf_state_tree, pf_tree_node, entry, pf_state_compare);
extern struct pf_state_tree tree_lan_ext, tree_ext_gwy;
d1139 1
a1139 1
extern int			 altqs_inactive_open;	
d1163 1
a1163 2
extern struct pf_state		*pf_find_state(struct pf_state_tree *,
				    struct pf_tree_node *);
@


1.170
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.169 2003/08/22 15:19:23 henning Exp $ */
d601 1
d1008 13
d1118 4
d1139 1
d1246 1
@


1.169
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.168 2003/08/22 14:59:30 frantzen Exp $ */
d867 1
a867 1
	u_int16_t		 tbrsize;	/* tokenbuket regulator size */
@


1.168
log
@don't expose pf_osfp_fingerprint() to ! _KERNEL.  tcpdump et al use
pf_osfp_fingerprint_hdr() which doesn't work on mbufs.
pointed out by Max Laier
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.167 2003/08/21 19:12:08 frantzen Exp $ */
d415 1
a415 1
	struct pf_osfp_entry 	fp_os;
@


1.167
log
@Add Michal Zalewski's p0f v2 style passive OS fingerprinting to PF.
Exposes the source IP's operating system to the filter language.
Interesting policy decisions are now enforceable:
.	block proto tcp from any os SCO
.	block proto tcp from any os Windows to any port smtp
.	rdr ... from any os "Windows 98" to port WWW -> 127.0.0.1 port 8001
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.166 2003/08/09 14:56:48 cedric Exp $ */
d1249 1
d1253 1
@


1.166
log
@This patch remove the restriction that tables cannot be used in routing or
redirection rules...

The advantage of using tables in redirection/routing rules is not efficiency,
in fact it will run slower than straight address pools. However, this brings
a lot of flexibility to PF, allowing simple scripts/daemons to add/remove
addresses from redirection/routing pools easily.

This implementation support all table features, including cidr blocks and
negated addresses. So specifying { 10.0.0.0/29 !10.0.0.0 !10.0.0.7 } will
correctly round-robin between the six addresses: .1, .2, .3, .4, .5, .6.

Tables can also be combined with simple addresses, so the following rule
will work as expected: "nat on foo0 -> { 1.1.1.1 <bar> }"

ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.165 2003/08/07 14:20:50 henning Exp $ */
d44 2
d56 1
a56 1
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC };
d327 102
d470 1
d1101 3
d1246 15
@


1.165
log
@make pf_match take u_int32_t instead of u_int16_t
it's not only used to ,atch on ports any more but uid/gid as well, and uid_t/gid_t are u_int32_t.
found by aaron@@
ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.164 2003/07/31 22:25:55 cedric Exp $ */
d319 1
d1057 4
a1060 1
#endif /* INET */
d1093 2
@


1.164
log
@Make table tickets per-ruleset instead of global.
Make table tickets u_int32_t for consistency with other parts of PF.
Ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.163 2003/07/19 13:08:58 cedric Exp $ */
d1065 1
a1065 1
int	pf_match(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
@


1.163
log
@Simplify struct pf_pooladdr to include struct pf_addr_wrap directly
instead of indirectly trough struct pf_rule_addr.

Ryan McBride says:
If I'm not mistaken, the code _used_ to use the ports in pf_rule_addr as
well. The code was changed to fix some of the bugs with port ranges, but
it was too late in the release cycle to make kernel API changes, so the
structure was left as is.

Needless to say: KERNEL/USERLAND SYNC REQUIRED.

ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.162 2003/07/04 10:39:31 henning Exp $ */
d498 1
d500 1
d920 1
a920 1
	int			 pfrio_ticket;
d1112 2
a1113 2
int	pfr_ina_begin(int *, int *, int);
int	pfr_ina_commit(int, int *, int *, int);
d1115 1
a1115 1
	    int *, int, int);
@


1.162
log
@-add a "natpass" field to pf_rule
-if natpass is nonzero on nat/rdr/binat rules, do not evaluate the filter
ruleset, but set the rulepointer to the default rule (which is a pass rule)

in cooperation with daniel.

ok dhartmei@@ cedric@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.161 2003/07/03 11:48:39 itojun Exp $ */
d295 1
a295 1
	struct pf_rule_addr		 addr;
@


1.161
log
@unused global.  dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.160 2003/06/30 19:09:25 henning Exp $ */
d388 1
@


1.160
log
@change that queue ID allocator so it always has the queues sorted by ID.
that allows us to get rid of the "tagid" global which stored the highest
tag ID in use.
when allocating a new ID scan the list for a free slot and only use
highest + 1 on failure instead of using highest + 1 from the beginning
scanning for a dup afterwards. this prevents ID space fragmentation better.

as a result this allows us do get rid of the pf_tag_purge() function
completely and let pf_tag_unref() remove an entry once the reference
counter reaches zero by itself.
after all it makes for easier code and is about 50% faster.

idea came up during a discussion on icb earlier today between cedric and
myself, which itself was particulary inspired by Darren Reed questioning the
need for pf_tag_purge on tech-net@@netbsd.

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.159 2003/06/30 10:50:16 henning Exp $ */
a787 2

TAILQ_HEAD(pf_tagnames, pf_tagname);
@


1.159
log
@move prototype for pf_tag_purge() to pfvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.158 2003/06/29 23:37:12 itojun Exp $ */
a1118 1
void		pf_tag_purge(void);
@


1.158
log
@normalize IPv6 packet (no reass, but it is a start).  dhartmei & henning ok
- length, jumbo payload option
- TTL ("hoplimit" in IPv6 terminology) rewrite
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.157 2003/06/21 09:07:01 djm Exp $ */
d1119 1
@


1.157
log
@count packets and bidirectionally on state entries, allowing for fine-grained
traffic reporting w/ pfsync; ok dhartmei@@

Note: ABI change (new fields in struct pf_state), requires a rebuild of
pfctl and tcpdump.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.156 2003/06/20 18:24:57 dhartmei Exp $ */
d1071 1
@


1.156
log
@Add MSS support to the synproxy. The client's MSS is sent to the server,
the server's MSS is guessed based on the routing table and interface MTU.

Fine patch entirely from Krists Krilovs <pow@@pow.za.net>, ok frantzen@@

Note: ABI change (new field in struct pf_state), requires a pfctl rebuild
(and tcpdump for pfsync).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.155 2003/06/09 11:14:46 mcbride Exp $ */
d461 2
a462 2
	u_int32_t	 packets;
	u_int32_t	 bytes;
@


1.155
log
@Attempt to resolve byte order confusion in nat code once and for all.

- pf_get_sport() leaves the translated port in the packet in network byte order
- merge code for the p1=0 p2=0 case and static-port case in pr_get_sport()

NOTE: people who use the static-port keyword in their pf.conf need to make sure pfctl is updated along with their kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.154 2003/06/08 09:41:08 cedric Exp $ */
d444 1
@


1.154
log
@A table in an anchor creates a real anchor: pfctl -sA works.
The following two pfctl functions work with an "-a" option:
  - pfctl [-a foo[:bar]] -sT
  - pfctl [-a foo[:bar]] -FT
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.153 2003/06/03 12:34:04 henning Exp $ */
a77 1
#define PF_POOL_STATICPORT	0x10
@


1.153
log
@move some prototypes to pfvar.h. needed soon.
pf_tagname2tag, pf_tag2tagname, pf_tag_unref, pf_tag_packet
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.152 2003/05/17 02:01:21 henning Exp $ */
d497 1
d506 1
d596 1
d906 2
a907 1
#define PFR_FLAG_ALLMASK	0x0000003F
d1037 5
d1090 1
a1090 1
int	pfr_clr_tables(int *, int);
d1093 2
a1094 2
int	pfr_get_tables(struct pfr_table *, int *, int);
int	pfr_get_tstats(struct pfr_tstats *, int *, int);
@


1.152
log
@allow inverse matching on tags

ok dhartmei@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.151 2003/05/17 01:08:50 dhartmei Exp $ */
d1105 5
@


1.151
log
@Add an 'action' code that allows the SYN proxy to swallow/drop a packet
without causing EHOSTUNREACH to be delivered to local sockets, so it works
for outgoing connections originating on the same host. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.150 2003/05/16 17:15:17 dhartmei Exp $ */
d388 1
@


1.150
log
@TCP SYN proxy. Instead of 'keep state' or 'modulate state', one can use
'synproxy state' for TCP connections. pf will complete the TCP handshake
with the active endpoint before passing any packets to the passive end-
point, preventing spoofed SYN floods from reaching the passive endpoint.

No additional memory requirements, no cookies needed, random initial
sequence numbers, uses the existing sequence number modulators to translate
packets after the handshakes.

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.149 2003/05/14 23:46:45 frantzen Exp $ */
d49 1
a49 1
	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR };
@


1.149
log
@- modulate TCP Timestamps so they can't be used to detect NAT and to preclude
remote uptime determination
- scrub modifier "reassemble tcp" turns on stateful TCP normalizations
ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.148 2003/05/14 08:42:00 canacar Exp $ */
d42 4
d391 1
@


1.148
log
@Use official (from pcap people) link type for pflog.
With this change, the log header format also changes.
The new log format is extendible and allows logging
of the originating anchor and ruleset information.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.147 2003/05/13 17:45:24 henning Exp $ */
d378 1
a391 1

a393 1
	u_int8_t		 rule_flag;
d401 13
a413 9
#define	PFRULE_DROP		0x00
#define	PFRULE_RETURNRST	0x01
#define	PFRULE_NODF		0x02
#define	PFRULE_FRAGMENT		0x04
#define	PFRULE_RETURNICMP	0x08
#define	PFRULE_FRAGCROP		0x10	/* non-buffering frag cache */
#define	PFRULE_FRAGDROP		0x20	/* drop funny fragments */
#define	PFRULE_RETURN		0x40
#define PFRULE_RANDOMID		0x80
d419 3
a421 1
	u_int8_t	pfss_ttl;	/* stashed TTL			*/
d423 1
a423 1
	u_int16_t	pad2;
d620 1
a620 1
#define PFDESC_TCP_NORM	0x0001		/* TCP was normalized */
d1042 3
d1059 1
a1059 3
int	pf_normalize_tcp_init(struct mbuf *, struct pf_pdesc *, struct tcphdr *,
	    struct pf_state_peer *, struct pf_state_peer *);
int	pf_normalize_tcp_stateful(struct mbuf *, struct pf_pdesc *, u_short *,
d1061 3
@


1.147
log
@add support for tagging packets with arbitary tags and filtering based on
those tags later on.

ok dhartmei@@ pb@@ mcbride@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.146 2003/05/12 22:11:18 dhartmei Exp $ */
d1037 2
a1038 2
int	pflog_packet(struct ifnet *, struct mbuf *, sa_family_t, u_short,
	    u_short, struct pf_rule *);
@


1.146
log
@Add comment about special (non-index) PFTM_* values.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.145 2003/05/12 17:49:03 mcbride Exp $ */
d348 4
d372 2
d763 13
@


1.145
log
@Reorder IPv6 address comparisons to check the least significant parts
first. The least significant portions of the IPv6 address are more
likely to differ than the more significant ones, since in most
situations half the addresses (either the source or the destination)
will be in the local subnet.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.144 2003/05/12 01:25:31 dhartmei Exp $ */
d54 4
@


1.144
log
@Adaptive timeout value scaling. Allows to reduce timeout values as the
number of state table entries grows, so entries time out faster before
the table fills up. Works both globally and per-rule. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.143 2003/05/11 20:44:03 frantzen Exp $ */
d152 2
a153 1
	((a)->addr32[0] == (b)->addr32[0] && \
d155 1
a155 2
	(a)->addr32[2] == (b)->addr32[2] && \
	(a)->addr32[3] == (b)->addr32[3])) \
d159 2
a160 1
	((a)->addr32[0] != (b)->addr32[0] || \
d162 1
a162 2
	(a)->addr32[2] != (b)->addr32[2] || \
	(a)->addr32[3] != (b)->addr32[3])) \
d188 2
a189 1
	((a)->addr32[0] == (b)->addr32[0] && \
d191 1
a191 2
	(a)->addr32[2] == (b)->addr32[2] && \
	(a)->addr32[3] == (b)->addr32[3]) \
d194 2
a195 1
	((a)->addr32[0] != (b)->addr32[0] || \
d197 1
a197 2
	(a)->addr32[2] != (b)->addr32[2] || \
	(a)->addr32[3] != (b)->addr32[3]) \
@


1.143
log
@the start of stateful TCP scrubbing.  dynamically determine the highest TTL of
each side of the TCP connection and prevent it from being reduced
ok pb@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.142 2003/04/30 12:30:27 cedric Exp $ */
d59 3
a61 1
	  PFTM_OTHER_MULTIPLE, PFTM_FRAG, PFTM_INTERVAL, PFTM_MAX };
d447 2
a448 1
	u_int8_t	 pad[3];
d1032 2
@


1.142
log
@Allow tables to be loaded into anchors.
Most pfctl table commands (excluding 'show' and 'flush') support the "-a"
modifier.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.141 2003/04/27 16:02:08 cedric Exp $ */
d402 7
d419 4
a422 3
	u_int16_t	max_win;
	u_int8_t	state;
	u_int8_t	wscale;
d602 1
d989 1
d1022 7
@


1.141
log
@Update the pfioc_table IOCTL structure.
Prepare for anchors, improve robustness.
WARNING: need to sync kernel/userland.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.140 2003/04/11 14:40:57 henning Exp $ */
d561 1
d566 2
d966 2
a967 1
extern int			 pf_tbladdr_setup(struct pf_addr_wrap *);
d1019 1
a1019 1
	pfr_attach_table(char *);
@


1.140
log
@set/update the queue IDs on filter rules (qid and pqid) on
-DIOCCHANGERULE (just the affected rule)
-DIOCCOMMITRULES (all filter rules that get committed - one anchor or main rs)
-DIOCCOMMITALTQS (all filter rules, main set plus all anchors)

This fixes a whole bunch of issues.
previously, this was done in userland at load time. This worked fine for the
usual case, full ruleset load. It did not work inside anchors, as the queue
name <-> queue ID mapping is unknown there. Also, if the queue definitions
were changed without reloading the rules too (pfctl -A), the queue IDs on
the rules were not updated.
The three ioctls mentioned above are all entry points where the mapping is
touched.

helpful discussion with dhartmei@@ and cedric@@ helped verifying my approach
for this fix was right.

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.139 2003/04/09 15:32:59 cedric Exp $ */
d482 1
d484 2
a485 2
#define	PFR_TFLAG_SETMASK	0x0000001C
#define PFR_TFLAG_ALLMASK	0x0000001F
d488 2
d492 1
d523 2
d533 1
a533 1
	int		 pfrts_refcnt;
d859 1
@


1.139
log
@Change pf_state structure to point to both a rule and the anchor,
so states created by rules in anchors correctly use rule options like
routing and (soon) queues...
Rule number bumped to 32 bit value.
USERLAND NEED TO BE RECOMPILED.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.138 2003/04/05 20:20:58 cedric Exp $ */
d964 2
@


1.138
log
@Replace the timeout variables by the content of the timeout
field of a new pf_default_rule structure.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.137 2003/03/31 13:15:27 cedric Exp $ */
d315 5
d332 1
a332 4
	union {
		struct pf_rule	*ptr;
		u_int32_t	 nr;
	}			 skip[PF_SKIP_COUNT];
d357 1
a358 1
	u_int16_t		 nr;
d423 3
a425 5
	union {
		struct pf_rule	*ptr;
		u_int32_t	 nr;
	} rule;
	struct pf_rule	*nat_rule;
@


1.137
log
@Only delete rule structure when no state refer to it.
Fix a bunch of issues.
Removal of unneeded (r != null) tests coming soon...
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.136 2003/03/03 14:33:17 cedric Exp $ */
a967 1
extern int			 pftm_interval;
d974 1
a974 1
extern int			*pftm_timeouts[PFTM_MAX];
@


1.136
log
@Make "pfctl -ss" output easier to parse. NO TRAFFIC -> NO_TRAFFIC.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.135 2003/02/08 20:13:20 dhartmei Exp $ */
d978 2
@


1.135
log
@Add scrub option 'random-id', which replaces IP IDs with random values
for outgoing packets that are not fragmented (after reassembly), to
compensate for predictable IDs generated by some hosts, and defeat
fingerprinting and NAT detection as described in the Bellovin paper
http://www.research.att.com/~smb/papers/fnat.pdf. ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.134 2003/01/21 22:23:49 dhartmei Exp $ */
d621 1
a621 1
	"NO TRAFFIC", \
d635 1
a635 1
	"NO TRAFFIC", \
@


1.134
log
@Support for TCP window scaling (RFC 1323). ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.133 2003/01/15 16:28:56 cedric Exp $ */
d396 1
@


1.133
log
@Fix a buglet when one "creates" a table which is already in the
referenced or inactive set. Flags were not updated correctly.
Tested on i386, sparc64. More regression tests coming.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.132 2003/01/10 16:09:19 cedric Exp $ */
d69 2
d411 1
a411 1
	u_int8_t	pad;
@


1.132
log
@Fix adding and deleting addresses in a table when there is a conflict with
the "negated" attribute of an address. The previous behaviour was incorrect
in both cases (too strict for the add command and too permissive for the
delete command).
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.131 2003/01/09 15:58:35 dhartmei Exp $ */
d552 1
@


1.131
log
@(whitespace) KNF, re-fold -w 80
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.130 2003/01/09 10:40:45 cedric Exp $ */
d490 1
a490 1
	PFR_FB_NOTMATCH, PFR_FB_MAX };
@


1.130
log
@Add support for active/inactive tablesets in the kernel.
Add table definition/initialisation construct in pfctl parser.
Add and fix documentation for pf.4 and pf.conf.5.
Tested on i386 and sparc64 by myself, macppc by Daniel.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.129 2003/01/07 00:21:07 dhartmei Exp $ */
d1025 1
a1025 1
int     pfr_ina_define(struct pfr_table *, struct pfr_addr *, int, int *,
@


1.129
log
@Remove table name hashing (pass the name in each ioctl instead), and
introduce reference counting for tables, they are now automatically
created and deleted through referencing rules. Diff partly from cedric@@.
ok mcbride@@, henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.128 2003/01/06 14:19:40 cedric Exp $ */
d99 1
d474 8
a481 5
#define PFR_TFLAG_PERSIST       0x00000001
#define PFR_TFLAG_CONST         0x00000002
#define PFR_TFLAG_ACTIVE        0x00000004
#define PFR_TFLAG_INACTIVE      0x00000008
#define PFR_TFLAG_ALLMASK       0x0000000F
d551 1
d842 1
a842 1
#define PFR_FLAG_RECURSE	0x00000010
d855 1
d860 3
a862 1
#define	pfrio_name	pfrio_table.pfrt_name
d926 4
a929 1

d954 1
d1009 1
d1023 4
a1026 3
int	pfr_wrap_table(struct pfr_table *, struct pf_addr_wrap *, int *,
	    int);
int	pfr_unwrap_table(struct pfr_table *, struct pf_addr_wrap *, int);
@


1.128
log
@Move initialisation of radix table globals in pfr_initialize()
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.127 2003/01/05 22:14:23 dhartmei Exp $ */
d247 18
d473 5
a477 1
#define	PF_TABLE_MASK		0xCAFEBABE
d481 1
d520 1
d523 1
a523 5

union pfr_hash {
	char		 pfrh_sha1[20];
	u_int32_t	 pfrh_int32[5];
};
a538 1
SLIST_HEAD(pfr_ktablehashq, pfr_ktable);
a542 1
	union pfr_hash		 pfrkt_hash;
a543 1
	SLIST_ENTRY(pfr_ktable)	 pfrkt_hashq;
d550 1
d552 1
a917 2
#define	DIOCRWRAPTABLE	_IOWR('D', 74, struct pfioc_table)
#define	DIOCRUNWRTABLE	_IOWR('D', 75, struct pfioc_table)
d941 5
a946 2
extern int			 pf_dynaddr_setup(struct pf_addr_wrap *,
				    u_int8_t);
a948 1
extern void			 pf_dynaddr_copyout(struct pf_addr_wrap *);
d985 6
a990 4
int	pfr_match_addr(struct pf_addr *, struct pf_addr *,
	    struct pf_addr *, sa_family_t);
void	pfr_update_stats(struct pf_addr *, struct pf_addr *,
	    struct pf_addr *, sa_family_t, u_int64_t, int, int, int);
@


1.127
log
@Move ifname from pf_addr to pf_addr_wrap, prepare pf_addr_wrap for table
name. ok henning@@, mcbride@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.126 2003/01/04 17:40:50 dhartmei Exp $ */
a931 1
extern struct pool		 pfr_ktable_pl, pfr_kentry_pl;
d965 1
@


1.126
log
@move noroute from flag in pf_rule_addr into type in pf_addr_wrap.
ok henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.125 2003/01/03 10:39:09 cedric Exp $ */
a76 1
		char			ifname[IFNAMSIZ];
d85 2
d88 12
a99 3
	struct pf_addr		 addr;
	struct pf_addr		 mask;
	struct pf_addr_dyn	*addr_dyn;
a455 1
#define	PF_TABLE_NAME_SIZE	128
@


1.125
log
@1) pfr_insert_kentries() cannot return ENOMEM anymore -> make it void.
2) add new PFR_FLAG_REPLACE for use by pfr_tst_addrs().
3) add new pfrio_nmatch alias to pfioc_table, set by pfr_tst_addrs().
Tested on i386, sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.124 2003/01/02 11:43:20 mcbride Exp $ */
d65 2
d90 1
a251 1
	u_int8_t		 noroute;
@


1.124
log
@Remove explicit numbering of enums.

ok fgsch@@ dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.123 2003/01/01 16:09:29 henning Exp $ */
d451 2
a452 1
	PFR_FB_CHANGED, PFR_FB_CLEARED, PFR_FB_DUPLICATE, PFR_FB_MAX };
d808 2
a809 1
#define PFR_FLAG_ALLMASK	0x0000001F
d823 1
d976 2
a977 1
int	pfr_tst_addrs(struct pfr_table *, struct pfr_addr *, int, int);
@


1.123
log
@use a #define for the default state table size
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.122 2003/01/01 14:16:56 cedric Exp $ */
d43 19
a61 19
enum	{ PF_IN=1, PF_OUT=2 };
enum	{ PF_PASS=0, PF_DROP=1, PF_SCRUB=2, PF_NAT=3, PF_NONAT=4,
	  PF_BINAT=5, PF_NOBINAT=6, PF_RDR=7, PF_NORDR=8 };
enum	{ PF_RULESET_SCRUB=0, PF_RULESET_FILTER=1, PF_RULESET_NAT=2,
	  PF_RULESET_BINAT=3, PF_RULESET_RDR=4, PF_RULESET_MAX=5 };
enum	{ PF_OP_IRG=1, PF_OP_EQ=2, PF_OP_NE=3, PF_OP_LT=4,
	  PF_OP_LE=5, PF_OP_GT=6, PF_OP_GE=7, PF_OP_XRG=8, PF_OP_RRG=9 };
enum	{ PF_DEBUG_NONE=0, PF_DEBUG_URGENT=1, PF_DEBUG_MISC=2 };
enum	{ PF_CHANGE_ADD_HEAD=1, PF_CHANGE_ADD_TAIL=2,
	  PF_CHANGE_ADD_BEFORE=3, PF_CHANGE_ADD_AFTER=4,
	  PF_CHANGE_REMOVE=5, PF_CHANGE_GET_TICKET=6 };
enum	{ PFTM_TCP_FIRST_PACKET=0, PFTM_TCP_OPENING=1, PFTM_TCP_ESTABLISHED=2,
	  PFTM_TCP_CLOSING=3, PFTM_TCP_FIN_WAIT=4, PFTM_TCP_CLOSED=5,
	  PFTM_UDP_FIRST_PACKET=6, PFTM_UDP_SINGLE=7, PFTM_UDP_MULTIPLE=8,
	  PFTM_ICMP_FIRST_PACKET=9, PFTM_ICMP_ERROR_REPLY=10,
	  PFTM_OTHER_FIRST_PACKET=11, PFTM_OTHER_SINGLE=12,
	  PFTM_OTHER_MULTIPLE=13, PFTM_FRAG=14, PFTM_INTERVAL=15, PFTM_MAX=16 };
enum	{ PF_FASTROUTE=1, PF_ROUTETO=2, PF_DUPTO=3, PF_REPLYTO=4 };
enum	{ PF_LIMIT_STATES=0, PF_LIMIT_FRAGS=1, PF_LIMIT_MAX=2 };
d63 2
a64 2
enum	{ PF_POOL_NONE=0, PF_POOL_BITMASK=1, PF_POOL_RANDOM=2,
	  PF_POOL_SRCHASH=3, PF_POOL_ROUNDROBIN=4 };
@


1.122
log
@Behaves correctly when duplicate addresses are given in the same ioctl.
(i.e: pfradix -a test 1.2.3.4 1.2.3.4). The ioctl can also report theses
duplicate to the caller using the new PFR_FB_DUPLICATE feedback tag.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.121 2003/01/01 04:26:19 dhartmei Exp $ */
d363 2
@


1.121
log
@Remove skip step for action (scrub vs. non-scrub), as scrub rules are
stored in a separate list now. Regress tests still pass after
sed "s/ a=end / /g", other skip steps are not affected.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.120 2002/12/31 19:18:41 mcbride Exp $ */
d449 1
a449 1
	PFR_FB_CHANGED, PFR_FB_CLEARED, PFR_FB_MAX };
@


1.120
log
@Split scrub rules out from the filter rules in the kernel.
Precursor to removing rule.action from skip steps.

Also a couple of other small fixes:
- s/PF_RULESET_RULE/PF_RULESET_FILTER/
- replacement of 4 with PF_RULESET_MAX in pfvar.h struct ruleset {
- error handling in ioctl of an invalid value in rule.action
- counting evaluations and matching packets for scrub rules

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.119 2002/12/29 20:07:34 cedric Exp $ */
d285 9
a293 10
#define PF_SKIP_ACTION		0
#define PF_SKIP_IFP		1
#define PF_SKIP_DIR		2
#define PF_SKIP_AF		3
#define PF_SKIP_PROTO		4
#define PF_SKIP_SRC_ADDR	5
#define PF_SKIP_SRC_PORT	6
#define PF_SKIP_DST_ADDR	7
#define PF_SKIP_DST_PORT	8
#define PF_SKIP_COUNT		9
@


1.119
log
@Add support for radix tables for source and destination of PF rules.
ok dhartmei@@, mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.118 2002/12/23 13:15:18 mcbride Exp $ */
d46 2
a47 2
enum	{ PF_RULESET_RULE=0, PF_RULESET_NAT=1, PF_RULESET_BINAT=2,
	  PF_RULESET_RDR=3, PF_RULESET_MAX=4 };
d428 1
a428 1
	}			 rules[4];
@


1.118
log
@Change from array to single pf_pabuf (no longer need multiple buffers as
we don't need the second list of addresses for DIOCCHANGE* operations)

Also get rid of a bug where DIOCBEGINADDRS clears pabuf[1] when pabuf[0]
is the one being used.

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.117 2002/12/22 19:59:13 mcbride Exp $ */
d40 3
d442 85
d801 21
d870 16
d917 1
d951 25
@


1.117
log
@pfioc_changealtq is not needed anymore; queues will eventually be
referenced by number in DIOCCHANGEALTQ (like rule and pooladdress)

"go for it" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.116 2002/12/22 02:33:14 mcbride Exp $ */
d774 1
a774 1
extern struct pf_palist			 pf_pabuf[2];
@


1.116
log
@mv PF_RULESET_MAX into the enum, slightly less confusing.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.115 2002/12/18 19:40:41 dhartmei Exp $ */
d688 1
a691 6
};

struct pfioc_changealtq {
	u_int32_t	 action;
	struct pf_altq	 oldaltq;
	struct pf_altq	 newaltq;
@


1.115
log
@Store translation rule pointer in state entries, so pfctl -vsn can print
evaluation, packet, byte and state entry counters similar to -vsr. Helps
verify whether/how often translation rules are evaluated/matched.
ok frantzen@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.114 2002/12/18 19:04:38 henning Exp $ */
d43 2
a44 3
enum	{ PF_RULESET_RULE=0, PF_RULESET_NAT=1,
	  PF_RULESET_BINAT=2, PF_RULESET_RDR=3 };
#define PF_RULESET_MAX		PF_RULESET_RDR + 1
@


1.114
log
@little style
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.113 2002/12/18 16:28:40 dhartmei Exp $ */
d388 1
@


1.113
log
@Pass skip step values through ioctl interface, pfctl -vvsr shows them,
main purpose is making them regress-testable.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.112 2002/12/17 12:30:13 mcbride Exp $ */
d666 2
a667 2
		caddr_t psu_buf;
		struct pf_state *psu_states;
d831 3
a833 2
extern struct pf_status pf_status;
extern struct pool pf_frent_pl, pf_frag_pl;
d838 1
a838 1
extern struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX];
@


1.112
log
@Merge pf_nat/pf_binat/pf_rdr structs into pf_rule. Simplifies code, allows
skip steps on translation rules.

Also:
- Require a ticket for DIOCCHANGERULE operations to prevent races.
- Remove pf_compare_* functions from pf_ioctl.c. DIOCCHANGE* operations
  use a rule number, and comparisons happen in userland.

Testing and fixes from dhartmei@@ and frantzen@@

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.111 2002/12/16 08:49:22 kjc Exp $ */
d293 4
a296 1
	struct pf_rule		*skip[PF_SKIP_COUNT];
@


1.111
log
@add options for 2 more queueing disciplines, PRIQ and HFSC.
ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.110 2002/12/13 21:48:31 henning Exp $ */
d41 5
a45 1
enum	{ PF_PASS=0, PF_DROP=1, PF_SCRUB=2 };
d47 1
a47 1
	  PF_OP_LE=5, PF_OP_GT=6, PF_OP_GE=7, PF_OP_XRG=8 };
d51 1
a51 1
	  PF_CHANGE_REMOVE=5 };
a59 1
enum    { PF_POOL_RULE_RT=0, PF_POOL_NAT_R=1, PF_POOL_RDR_R=2 };
a60 1
#define PF_POOL_LAST		0x10
d251 1
a251 1
	struct pf_addr_wrap		 addr;
d275 2
d304 1
a304 1
	struct pf_pool		 rt_pool;
a407 57

struct pf_nat {
	struct pf_rule_addr	 src;
	struct pf_rule_addr	 dst;
	struct pf_pool		 rpool;
	struct pf_pooladdr	*rcur;
	char			 ifname[IFNAMSIZ];
	char			 anchorname[PF_ANCHOR_NAME_SIZE];
	struct ifnet		*ifp;
	struct pf_anchor	*anchor;
	TAILQ_ENTRY(pf_nat)	 entries;
	u_int32_t		 rlistid;
	u_int16_t		 proxy_port[2];
	sa_family_t		 af;
	u_int8_t		 proto;
	u_int8_t		 ifnot;
	u_int8_t		 no;
};

struct pf_binat {
	char			 ifname[IFNAMSIZ];
	char			 anchorname[PF_ANCHOR_NAME_SIZE];
	struct ifnet		*ifp;
	struct pf_anchor	*anchor;
	TAILQ_ENTRY(pf_binat)	 entries;
	struct pf_addr_wrap	 saddr;
	struct pf_addr_wrap	 daddr;
	struct pf_addr_wrap	 raddr;
	sa_family_t		 af;
	u_int8_t		 proto;
	u_int8_t		 dnot;
	u_int8_t		 no;
};

struct pf_rdr {
	char			 ifname[IFNAMSIZ];
	char			 anchorname[PF_ANCHOR_NAME_SIZE];
	struct ifnet		*ifp;
	struct pf_anchor	*anchor;
	TAILQ_ENTRY(pf_rdr)	 entries;
	struct pf_addr_wrap	 saddr;
	struct pf_addr_wrap	 daddr;
	struct pf_pool		 rpool;
	struct pf_pooladdr	*rcur;
	u_int32_t		 rlistid;
	u_int16_t		 dport;
	u_int16_t		 dport2;
	u_int16_t		 rport;
	sa_family_t		 af;
	u_int8_t		 proto;
	u_int8_t		 snot;
	u_int8_t		 dnot;
	u_int8_t		 ifnot;
	u_int8_t		 opts;
	u_int8_t		 no;
};

a408 3
TAILQ_HEAD(pf_natqueue, pf_nat);
TAILQ_HEAD(pf_binatqueue, pf_binat);
TAILQ_HEAD(pf_rdrqueue, pf_rdr);
d422 1
a422 22
	}			 rules;
	struct {
		struct pf_natqueue	 queues[2];
		struct {
			struct pf_natqueue	*ptr;
			u_int32_t		 ticket;
		}			 active, inactive;
	}			 nats;
	struct {
		struct pf_rdrqueue	 queues[2];
		struct {
			struct pf_rdrqueue	*ptr;
			u_int32_t		 ticket;
		}			 active, inactive;
	}			 rdrs;
	struct {
		struct pf_binatqueue	 queues[2];
		struct {
			struct pf_binatqueue	*ptr;
			u_int32_t		 ticket;
		}			 active, inactive;
	}			 binats;
d611 1
d615 2
a616 1
	u_int8_t		 r_id;
a622 11
struct pfioc_changeaddr {
	u_int32_t		 action;
	u_int32_t		 r_num;
	u_int8_t		 r_id;
	u_int8_t		 af;
	char			 anchor[PF_ANCHOR_NAME_SIZE];
	char			 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_pooladdr	 newaddr;
	struct pf_pooladdr	 oldaddr;
};

d624 1
a632 27
struct pfioc_changerule {
	u_int32_t	 pool_ticket;
	u_int32_t	 action;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_rule	 oldrule;
	struct pf_rule	 newrule;
};

struct pfioc_nat {
	u_int32_t	 ticket;
	u_int32_t	 pool_ticket;
	u_int32_t	 nr;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_nat	 nat;
};

struct pfioc_changenat {
	u_int32_t	 pool_ticket;
	u_int32_t	 action;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_nat	 oldnat;
	struct pf_nat	 newnat;
};

a646 34
struct pfioc_binat {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_binat	 binat;
};

struct pfioc_changebinat {
	u_int32_t	 action;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_binat	 oldbinat;
	struct pf_binat	 newbinat;
};

struct pfioc_rdr {
	u_int32_t	 ticket;
	u_int32_t	 pool_ticket;
	u_int32_t	 nr;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_rdr	 rdr;
};

struct pfioc_changerdr {
	u_int32_t	 pool_ticket;
	u_int32_t	 action;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_rdr	 oldrdr;
	struct pf_rdr	 newrdr;
};

d727 1
a727 10
#define DIOCBEGINNATS	_IOWR('D',  8, struct pfioc_nat)
#define DIOCADDNAT	_IOWR('D',  9, struct pfioc_nat)
#define DIOCCOMMITNATS	_IOWR('D', 10, struct pfioc_nat)
#define DIOCGETNATS	_IOWR('D', 11, struct pfioc_nat)
#define DIOCGETNAT	_IOWR('D', 12, struct pfioc_nat)
#define DIOCBEGINRDRS	_IOWR('D', 13, struct pfioc_rdr)
#define DIOCADDRDR	_IOWR('D', 14, struct pfioc_rdr)
#define DIOCCOMMITRDRS	_IOWR('D', 15, struct pfioc_rdr)
#define DIOCGETRDRS	_IOWR('D', 16, struct pfioc_rdr)
#define DIOCGETRDR	_IOWR('D', 17, struct pfioc_rdr)
d736 2
a737 3
#define DIOCCHANGERULE	_IOWR('D', 26, struct pfioc_changerule)
#define DIOCCHANGENAT	_IOWR('D', 27, struct pfioc_changenat)
#define DIOCCHANGERDR	_IOWR('D', 28, struct pfioc_changerdr)
a739 6
#define DIOCBEGINBINATS	_IOWR('D', 31, struct pfioc_binat)
#define DIOCADDBINAT	_IOWR('D', 32, struct pfioc_binat)
#define DIOCCOMMITBINATS _IOWR('D', 33, struct pfioc_binat)
#define DIOCGETBINATS	_IOWR('D', 34, struct pfioc_binat)
#define DIOCGETBINAT	_IOWR('D', 35, struct pfioc_binat)
#define DIOCCHANGEBINAT	_IOWR('D', 36, struct pfioc_changebinat)
d758 1
a758 1
#define DIOCCHANGEADDR	_IOWR('D', 55, struct pfioc_changeaddr)
d792 2
a793 5
extern struct pool		 pf_tree_pl, pf_rule_pl, pf_nat_pl;
extern struct pool		 pf_rdr_pl, pf_state_pl, pf_binat_pl,
				    pf_addr_pl;
extern struct pool		 pf_altq_pl;
extern struct pool		 pf_pooladdr_pl;
@


1.110
log
@add pqueue and pqid to pf_rule.
this allows for a second queue on pf_rule.
assign packets with tos 0x10 (lowdelay) to this one.
if the second queue isn't specified set pqid = qid

idea dhartmei@@
ok dhartmei@@ frantzen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.108 2002/12/06 00:47:32 dhartmei Exp $ */
d630 4
d635 12
a646 6
	u_int		rt_m1;
	u_int		rt_d;
	u_int		rt_m2;
	u_int		ls_m1;
	u_int		ls_d;
	u_int		ls_m2;
d671 1
a672 1
		/* and other discipline specific options */
@


1.109
log
@minor KNF
@
text
@d296 1
d312 1
@


1.108
log
@Introduce anchors and named rule sets, allowing to load additional rule
sets with pfctl and evaluate them from the main rule set using a new type
of rule (which will support conditional evaluation soon). Makes
maintenance of sub-rulesets simpler for pfctl and daemons.

Idea and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.107 2002/12/01 19:54:32 mcbride Exp $ */
d468 1
a468 1
#define PF_RULESET_NAME_SIZE	 16 
@


1.107
log
@- Clean up pf_ioctl mainly by adding new functions to handle cleaning and
  freeing rules. Fixes a number of potential memory leaks and other bugs.
- Add new pool_ticket to insure that address pools don't get messed
  with by someone else while we add rules.
- Add a second address pool buffer, so that DIOCCHANGE* operations which use
  pf_compare* will work correctly.

Excellent bug report and anaylsis from DJ Gregor.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.106 2002/11/29 18:25:23 mickey Exp $ */
d40 1
a40 1
enum	{ PF_IN=0, PF_OUT=1 };
d296 2
d306 1
d409 1
d411 1
d423 1
d425 1
d438 1
d440 1
d460 50
d681 2
d691 2
d701 2
d707 6
a712 4
	u_int32_t		 pool_ticket;
	u_int32_t		 action;
	struct pf_rule		 oldrule;
	struct pf_rule		 newrule;
d719 2
d727 2
d750 2
d756 5
a760 3
	u_int32_t	action;
	struct pf_binat	oldbinat;
	struct pf_binat	newbinat;
d767 2
d775 2
d838 12
d856 1
a856 1
#define DIOCBEGINRULES	_IOWR('D',  3, u_int32_t)
d858 1
a858 1
#define DIOCCOMMITRULES	_IOWR('D',  5, u_int32_t)
d861 1
a861 1
#define DIOCBEGINNATS	_IOWR('D',  8, u_int32_t)
d863 1
a863 1
#define DIOCCOMMITNATS	_IOWR('D', 10, u_int32_t)
d866 1
a866 1
#define DIOCBEGINRDRS	_IOWR('D', 13, u_int32_t)
d868 1
a868 1
#define DIOCCOMMITRDRS	_IOWR('D', 15, u_int32_t)
d884 1
a884 1
#define DIOCBEGINBINATS	_IOWR('D', 31, u_int32_t)
d886 1
a886 1
#define DIOCCOMMITBINATS _IOWR('D', 33, u_int32_t)
d904 1
a904 1
#define DIOCBEGINADDRS	_IOWR('D', 51, u_int32_t)
d909 4
d920 2
a921 7
extern struct pf_rulequeue		 pf_rules[2];
TAILQ_HEAD(pf_natqueue, pf_nat);
extern struct pf_natqueue		 pf_nats[2];
TAILQ_HEAD(pf_binatqueue, pf_binat);
extern struct pf_binatqueue		 pf_binats[2];
TAILQ_HEAD(pf_rdrqueue, pf_rdr);
extern struct pf_rdrqueue		 pf_rdrs[2];
a928 10
extern u_int32_t		 ticket_rules_active;
extern u_int32_t		 ticket_rules_active;
extern u_int32_t		 ticket_rules_inactive;
extern u_int32_t		 ticket_nats_active;
extern u_int32_t		 ticket_nats_inactive;
extern u_int32_t		 ticket_binats_active;
extern u_int32_t		 ticket_binats_inactive;
extern u_int32_t		 ticket_rdrs_active;
extern u_int32_t		 ticket_rdrs_inactive;
extern u_int32_t		 ticket_rules_inactive;
a931 8
extern struct pf_rulequeue	*pf_rules_active;
extern struct pf_rulequeue	*pf_rules_inactive;
extern struct pf_natqueue	*pf_nats_active;
extern struct pf_natqueue	*pf_nats_inactive;
extern struct pf_binatqueue	*pf_binats_active;
extern struct pf_binatqueue	*pf_binats_inactive;
extern struct pf_rdrqueue	*pf_rdrs_active;
extern struct pf_rdrqueue	*pf_rdrs_inactive;
d940 1
d953 1
a980 1
extern struct pf_rulequeue *pf_rules_active;
@


1.106
log
@expose state table changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.105 2002/11/28 12:07:37 mcbride Exp $ */
d636 1
d642 1
d650 1
d656 1
d690 1
d696 1
d836 1
a836 1
extern struct pf_palist			 pf_pabuf;
@


1.105
log
@- MD5 too slow, replace with pf_hash (based on hash from if_bridge.c)
- Always fold the key in

Many fixes & suggestions from camield@@

ok mickey@@ camield@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.104 2002/11/26 11:28:13 mcbride Exp $ */
d374 1
a374 1
		u_int16_t	 nr;
@


1.104
log
@pass struct pfioc_changeaddr to DIOCCHANGEADDR
rather than struct pfioc_pooladdr

an obvious fix from dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.103 2002/11/23 09:37:02 deraadt Exp $ */
d60 1
a60 1
	  PF_POOL_SRCHASH=3, PF_POOL_SRCKEYHASH=4, PF_POOL_ROUNDROBIN=5 };
@


1.103
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.102 2002/11/23 05:16:58 mcbride Exp $ */
d811 1
a811 1
#define DIOCCHANGEADDR	_IOWR('D', 55, struct pfioc_pooladdr)
@


1.102
log
@kernel code to allow multiple redirection addresses to be specified for nat
and rdr, as well as route-to, dup-to and reply-to.

Addresses can be allocated in a number of ways:
- masking out the network portion of the address and replacing it
- randomly assigning an address in the block
- hashing the source address and a key to determine the redirection address
- iterating through the addresses sequentially (this is the only allocation
  scheme which works when a list of addresses is specified)

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.101 2002/11/02 16:56:50 mcbride Exp $ */
d12 1
a12 1
 *      notice, this list of conditions and the following disclaimer. 
d16 1
a16 1
 *      with the distribution. 
d56 1
a56 1
enum    { PF_POOL_RULE_RT=0, PF_POOL_NAT_R=1, PF_POOL_RDR_R=2 }; 
d249 1
a249 1
	struct pf_addr_wrap	 	 addr;
d618 1
a618 1
	u_int32_t	 	 nr;
d626 1
a626 1
	u_int32_t	 	 action;
d630 2
a631 2
	struct pf_pooladdr	 newaddr;	
	struct pf_pooladdr	 oldaddr;	
@


1.101
log
@Make PF_ANEQ(), PF_ANEQ() and PF_AZERO() check the whole address if af
is not set to AF_INET6 or AF_INET

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.100 2002/10/22 12:23:35 mcbride Exp $ */
d56 7
d82 1
d153 3
d162 1
d189 3
d215 5
d221 4
a224 4
       do { \
               (a)->addr32[0] = ((b)->addr32[0] & (c)->addr32[0]) | \
               (((c)->addr32[0] ^ 0xffffffff ) & (d)->addr32[0]); \
       } while (0)
a241 1
	struct pf_addr		 mask;
d248 28
a292 1
	struct pf_addr		 rt_addr;
a294 1
	char			 rt_ifname[IFNAMSIZ];
d297 1
a303 1
	struct ifnet		*rt_ifp;
d308 1
d376 2
d403 2
a404 1
	struct pf_addr_wrap	 raddr;
d408 1
a422 3
	struct pf_addr		 smask;
	struct pf_addr		 dmask;
	struct pf_addr		 rmask;
d435 3
a437 3
	struct pf_addr_wrap	 raddr;
	struct pf_addr		 smask;
	struct pf_addr		 dmask;
d616 18
d641 3
a643 3
	u_int32_t	 action;
	struct pf_rule	 oldrule;
	struct pf_rule	 newrule;
d807 5
d826 2
d830 1
d845 1
d856 2
d867 1
@


1.100
log
@Convert "int af" and "u_int8_t af" declarations and function arguments
to the more correct and descriptive "sa_family_t af"

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.99 2002/10/20 13:08:29 mcbride Exp $ */
d122 1
a122 1
	(c == AF_INET6 && (a)->addr32[0] == (b)->addr32[0] && \
d129 1
a129 1
	(c == AF_INET6 && ((a)->addr32[0] != (b)->addr32[0] || \
d132 1
a132 1
	(a)->addr32[3] != (b)->addr32[3]))) \
d136 2
a137 3
	(c == AF_INET6 && !(a)->addr32[0] && \
	!(a)->addr32[1] && !(a)->addr32[2] && \
	!(a)->addr32[3] )) \
@


1.99
log
@Move pf_compare_(rules|nats|binats|rdrs) to pf_ioctl.c. Simplifies and
reduces cross-file dependancies.

ok dhartmei@@ ish@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.98 2002/10/14 12:58:28 henning Exp $ */
d82 1
a82 1
	u_int8_t		 af;
d282 1
a282 1
	u_int8_t		 af;
d335 1
a335 1
	u_int8_t	 af;
d348 1
a348 1
	u_int8_t	 af;
d361 1
a361 1
	u_int8_t		 af;
d377 1
a377 1
	u_int8_t		 af;
d395 1
a395 1
	u_int8_t		 af;
d423 1
a423 1
	u_int8_t	 af;
d603 1
a603 1
	u_int8_t	 af;
d639 1
a639 1
	int			psk_af;
d811 2
a812 2
int	pflog_packet(struct ifnet *, struct mbuf *, int, u_short, u_short,
	    struct pf_rule *);
d814 1
a814 1
	    struct pf_addr *, int);
d823 1
a823 1
int	pf_routable(struct pf_addr *addr, int af);
@


1.98
log
@Allow one to specify a netblock in a binat rule:

binat on fxp0 from 192.168.0.32/27 to any -> 10.0.7.128/27

Both the network mask on the source and redirect addresses MUST be the
same, and it works by essentially combining the network section of the
redirect address with the host section of the source address.

from ryan

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.97 2002/10/10 12:29:33 mickey Exp $ */
a793 8
extern int			 pf_compare_rules(struct pf_rule *,
				    struct pf_rule *);
extern int			 pf_compare_nats(struct pf_nat *,
				    struct pf_nat *);
extern int			 pf_compare_binats(struct pf_binat *,
				    struct pf_binat *);
extern int			 pf_compare_rdrs(struct pf_rdr *,
				    struct pf_rdr *);
@


1.97
log
@padd pf_state; dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.96 2002/10/08 05:12:08 kjc Exp $ */
d146 3
d178 3
d201 5
d374 1
d376 1
@


1.96
log
@the first step of pf/altq merge.
this commit is to allow further development in both userland and kernel.

the goal is to replace altq's classifier by pf(4).
- make pf tag a queue id to mbuf and make altq read the queue id
- merge altq config into pf.conf(5)

ok dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.95 2002/10/07 13:23:46 henning Exp $ */
d329 1
@


1.95
log
@set block-policy [drop|return]
drop is default, same behaviour as before

support
block drop
to override a return policy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.91 2002/10/07 12:39:29 dhartmei Exp $ */
d237 1
d240 1
d252 1
d497 50
d655 20
d720 9
d743 2
d757 2
d767 2
d777 1
@


1.94
log
@support a generic return
block return in|out ...
acts like return-rst on tcp, like return-icmp on udp and like an ordinary
block on anything else

ok dhartmei@@
@
text
@d283 1
@


1.93
log
@make return-icmp work for rules covering both v4 and v6
-new field "return_icmp6" inpf_rule
-parser accepts
block return-icmp(ipv4-icmpcode, ipv6-icmpcode)

ok and some input dhartmei@@
@
text
@d289 1
@


1.92
log
@use a new rule_flag PFRULE_RETURNICMP to decide wether to return-icmp or not
instead of just testing return_icmp > 0

ok dhartmei@@
@
text
@d253 1
@


1.91
log
@Add 'reply-to' to filter rules, similar to route-to, but applying to
replies (packets that flow in the opposite direction of the packet that
created state), used for symmetric routing enforcement.
Document how route-to and reply-to work in context of stateful filtering.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.90 2002/10/05 21:17:57 dhartmei Exp $ */
d285 1
a285 1

@


1.90
log
@Allow filtering based on IP header's tos field.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.89 2002/08/12 16:41:25 dhartmei Exp $ */
d54 1
a54 1
enum	{ PF_FASTROUTE=1, PF_ROUTETO=2, PF_DUPTO=3 };
@


1.89
log
@Use state tree instead of separate (flat) list to find NAT proxy ports,
allows to use the same proxy port with different external peers.
From Ryan McBride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.88 2002/07/15 18:07:17 henning Exp $ */
d279 1
d405 1
@


1.88
log
@add u_int8_t ifnot to struct pf_rule to support matching packets on any
interface except the given one. adjust the pf_test_* functions and
pf_skip_step accordingly.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.87 2002/06/11 18:03:25 frantzen Exp $ */
a382 6
struct pf_port_node {
	LIST_ENTRY(pf_port_node)	next;
	u_int16_t			port;
};
LIST_HEAD(pf_port_list, pf_port_node);

a675 2
extern struct pf_port_list	 pf_tcp_ports;
extern struct pf_port_list	 pf_udp_ports;
d681 1
a681 1
extern struct pool		 pf_tree_pl, pf_rule_pl, pf_nat_pl, pf_sport_pl;
@


1.87
log
@split the grammar of scrub(fragcache) into scrub ... 'fragment reassemble',
'fragment crop' or a new 'fragment drop-ovl' which will drop overlapping
fragments and all corresponding ones
ok kjell@@ with feedback from kjell@@ and deraadt@@.  the rest are slacking
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.86 2002/06/11 02:42:27 frantzen Exp $ */
d262 1
@


1.86
log
@enumerate UDP and OTHER state levels (similar to tcp_fsm.h)
ok dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.85 2002/06/11 02:27:19 frantzen Exp $ */
d283 3
a285 1
#define	PFRULE_FRAGCACHE	0x10	/* non-buffering frag cache */
@


1.85
log
@SCRUB(fragcache) to do gap tracking and overlap pruning of IPv4 fragments
without the memory overhead of the conventional defrag in SCRUB
ok dhartmei@@, idea by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.84 2002/06/11 02:12:37 dhartmei Exp $ */
d429 28
@


1.84
log
@Make NAT proxy port range configurable per rule, for instance privileged
source ports can mapped to privileged proxy ports, or source port 500
to proxy port 500. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.83 2002/06/11 01:58:00 henning Exp $ */
d283 1
d466 2
@


1.83
log
@rework pfctl statistics display
move FCNT_NAMES from pfvar.h to pfctl_parser.h, only used by pfctl
some input by nick@@
ok frantzen@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.82 2002/06/09 20:20:58 dhartmei Exp $ */
d337 1
@


1.82
log
@Make pf_nat.saddr/daddr a pf_rule_addr instead of pf_addr_wrap, so it
includes ports and operator.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.81 2002/06/09 08:53:08 pb Exp $ */
a434 6
#define FCNT_NAMES { \
	"state searches", \
	"state inserts", \
	"state removals", \
	NULL \
}
d459 1
@


1.81
log
@
split ioctl functions out of pf.c into pf_ioctl.c

frantzen@@, dhartmei@@ ok, tested kernel & userland.

checked for colliding commits
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.78 2002/06/08 07:58:06 dhartmei Exp $ */
d331 3
a336 5
	struct pf_addr_wrap	 saddr;
	struct pf_addr_wrap	 daddr;
	struct pf_addr_wrap	 raddr;
	struct pf_addr		 smask;
	struct pf_addr		 dmask;
a338 2
	u_int8_t		 snot;
	u_int8_t		 dnot;
@


1.80
log
@This commit commit commit without testing has to STOP.  BE CAREFUL.
@
text
@d382 6
d623 1
d625 59
d710 5
@


1.79
log
@
uncommit, broken (by corrupt diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.77 2002/06/07 23:06:21 henning Exp $ */
d235 1
@


1.78
log
@Make state timeouts configurable per rule, like

  pass in from any to any port www keep state (tcp.established 60)

ok frantzen@@
@
text
@a234 1
	u_int32_t		 timeout[PFTM_MAX];
@


1.77
log
@increase rule label length from 32 to 64 chars
okay dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.76 2002/06/07 22:53:37 pb Exp $ */
d235 1
@


1.76
log
@
add the possibility to configure a TTL while return-rst

ok dhartmei@@, ipv6 part itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.75 2002/06/07 21:25:35 dhartmei Exp $ */
d233 1
a233 1
#define PF_RULE_LABEL_SIZE	 32
@


1.75
log
@Add "(max <number>)" option for "keep/modulate state" to limit the number
of concurrent connections a rule can create. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.74 2002/06/07 21:14:02 frantzen Exp $ */
a271 1

d276 1
@


1.74
log
@switch from AVL tree's to herr Provos' red-black trees
with suggestions from provos@@
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.73 2002/05/19 22:31:28 deraadt Exp $ */
d246 3
@


1.73
log
@KNF again
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.72 2002/05/12 00:54:56 dhartmei Exp $ */
d38 1
a295 1
	TAILQ_ENTRY(pf_state)	entries;
d316 10
a377 7
struct pf_tree_key {
	struct pf_addr	 addr[2];
	u_int16_t	 port[2];
	u_int8_t	 proto;
	u_int8_t	 af;
};

a621 8

struct pf_tree_node;
struct pf_state
	*pf_find_state(struct pf_tree_node *, struct pf_tree_key *);
int	pf_tree_insert(struct pf_tree_node **, struct pf_tree_node *,
	    struct pf_tree_key *, struct pf_state *);
int	pf_tree_remove(struct pf_tree_node **, struct pf_tree_node *,
	    struct pf_tree_key *);
@


1.72
log
@Add gid based filtering, reduce to one (effective) uid, rename parser
keywords to 'user' and 'group'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.71 2002/05/09 21:58:12 jasoni Exp $ */
d58 2
a59 2
		struct in_addr 		v4;
		struct in6_addr 	v6;
d286 1
a286 1
	u_int32_t	seqlo;		/* Max sequence number sent 	*/
d378 1
a378 1
	u_int64_t	 tot_len; 	/* Make Mickey money */
d391 1
a391 1
	u_int32_t	 p_len; 	/* total length of payload */
d458 1
a458 1
#define PFFRAG_FRENT_HIWAT	5000	/* Number of fragment entries */  
d571 1
a571 1
#define DIOCADDRULE	_IOWR('D',  4, struct pfioc_rule) 
d574 1
a574 1
#define DIOCGETRULE	_IOWR('D',  7, struct pfioc_rule) 
d576 1
a576 1
#define DIOCADDNAT	_IOWR('D',  9, struct pfioc_nat) 
d579 1
a579 1
#define DIOCGETNAT	_IOWR('D', 12, struct pfioc_nat) 
d581 1
a581 1
#define DIOCADDRDR	_IOWR('D', 14, struct pfioc_rdr) 
d584 1
a584 1
#define DIOCGETRDR	_IOWR('D', 17, struct pfioc_rdr) 
d640 1
a640 1
int	pf_routable(struct pf_addr *addr, int af); 
@


1.71
log
@Add a max-mss option to the scrub rule which will enforce a maximum mss
by lowering it to the given value.
- ok dhartmei@@, provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.70 2002/05/09 19:58:42 dhartmei Exp $ */
d204 5
d250 2
a251 2
	struct pf_rule_uid	 ruid;
	struct pf_rule_uid	 euid;
d634 2
a635 1
int	pf_match_uid(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
@


1.70
log
@Introduce user based filtering. Rules can specify ruid and euid (real and
effective user ID) much like ports. The user of a packet is either the
user that opens an outgoing connection, the one that listens on a socket,
or 'unknown' if the firewall is not a connection endpoint (for forwarded
connections). Socket uid lookup code from jwk@@bug.it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.69 2002/05/05 21:40:22 dhartmei Exp $ */
d243 1
@


1.69
log
@Instead of returning a useless kernel space pointer for the rule that
created the state from DIOCGETSTATE(S), return the integer rule number,
Print rule number (if existant) from pfctl -vss. Suggested by Jeff Nathan.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.68 2002/04/24 18:10:25 dhartmei Exp $ */
d199 5
d244 3
d626 1
d628 1
@


1.68
log
@Add dynamic (in-kernel) interface name -> address translation. Instead of
using just the interface name instead of an address and reloading the rule
set whenever the interface changes its address, the interface name can be
put in parentheses, and the kernel will keep track of changes and update
rules. There is no additional cost for evaluating rules (per packet),
the cost occurs when an interface changes address (and the rules are
traversed and updated where necessary).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.67 2002/04/23 14:32:22 dhartmei Exp $ */
d287 4
a290 1
	struct pf_rule	*rule;
@


1.67
log
@Allow explicit filtering of fragments when they are not reassembled.
Document fragment handling in the man page. Short version: if you're
scrubbing everything (as is recommended, in general), nothing changes.
If you want to deal with fragments manually, read the man page.
ok frantzen.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.66 2002/03/27 18:16:21 mickey Exp $ */
d63 1
d72 14
d200 6
a205 6
	struct pf_addr	addr;
	struct pf_addr	mask;
	u_int16_t	port[2];
	u_int8_t	not;
	u_int8_t	port_op;
	u_int8_t	noroute;
d209 2
a210 10
	char		 ifname[IFNAMSIZ];
	char		 rt_ifname[IFNAMSIZ];
#define PF_RULE_LABEL_SIZE	32
	char		 label[PF_RULE_LABEL_SIZE];
	struct ifnet	*ifp;
	struct ifnet	*rt_ifp;
	struct pf_rule_addr src;
	struct pf_rule_addr dst;
	struct pf_addr	 rt_addr;

d221 22
a242 14
	struct pf_rule	*skip[PF_SKIP_COUNT];
	TAILQ_ENTRY(pf_rule)	entries;

	u_int64_t	 evaluations;
	u_int64_t	 packets;
	u_int64_t	 bytes;

	u_int16_t	 nr;
	u_int16_t	 return_icmp;

	u_int8_t	 action;
	u_int8_t	 direction;
	u_int8_t	 log;
	u_int8_t	 quick;
d246 13
a258 13
	u_int8_t	 keep_state;
	u_int8_t	 af;
	u_int8_t	 proto;
	u_int8_t	 type;
	u_int8_t	 code;

	u_int8_t	 flags;
	u_int8_t	 flagset;

	u_int8_t	 rule_flag;
	u_int8_t	 min_ttl;	/* minimum ttl for packet normalize */
	u_int8_t	 allow_opts;
	u_int8_t	 rt;
d300 14
a313 14
	char		 ifname[IFNAMSIZ];
	struct ifnet	*ifp;
	TAILQ_ENTRY(pf_nat)	entries;
	struct pf_addr	 saddr;
	struct pf_addr	 smask;
	struct pf_addr	 daddr;
	struct pf_addr	 dmask;
	struct pf_addr	 raddr;
	u_int8_t	 af;
	u_int8_t	 proto;
	u_int8_t	 snot;
	u_int8_t	 dnot;
	u_int8_t	 ifnot;
	u_int8_t	 no;
d317 11
a327 11
	char		 ifname[IFNAMSIZ];
	struct ifnet	*ifp;
	TAILQ_ENTRY(pf_binat)	entries;
	struct pf_addr	 saddr;
	struct pf_addr	 daddr;
	struct pf_addr	 dmask;
	struct pf_addr	 raddr;
	u_int8_t	 af;
	u_int8_t	 proto;
	u_int8_t	 dnot;
	u_int8_t	 no;
d331 18
a348 18
	char		 ifname[IFNAMSIZ];
	struct ifnet	*ifp;
	TAILQ_ENTRY(pf_rdr)	entries;
	struct pf_addr	 saddr;
	struct pf_addr	 smask;
	struct pf_addr	 daddr;
	struct pf_addr	 dmask;
	struct pf_addr	 raddr;
	u_int16_t	 dport;
	u_int16_t	 dport2;
	u_int16_t	 rport;
	u_int8_t	 af;
	u_int8_t	 proto;
	u_int8_t	 snot;
	u_int8_t	 dnot;
	u_int8_t	 ifnot;
	u_int8_t	 opts;
	u_int8_t	 no;
@


1.66
log
@implement a "no-route" keyword.
usage semantics are analogous w/ "any", meaning is
"any ip address for which there is no route in the
current routing table", could be used in both from and to.
typical usage would be (assuming symmetrical routing):
block in from no-route to any
also doc "any" in the pf.conf.5, include in regress, etc.
tested by me on i386 and sparc.
dhartmei@@ and frantzen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.65 2002/03/25 22:03:01 frantzen Exp $ */
d248 1
@


1.65
log
@add ioctl DIOCKILLSTATES to shootdown a subset of the state table.  allows
discrimination on src/dst ips and netmask, src/dst port range and protocol.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.64 2002/02/26 07:25:33 dhartmei Exp $ */
d190 1
d604 1
@


1.64
log
@Add optional pool memory hard limits, mainly as temporary solution
until pool exhaustion causes problems no more.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.63 2002/02/14 23:53:32 dhartmei Exp $ */
d498 8
d574 1
@


1.63
log
@Reorder struct pf_pdesc members, saves 8 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.62 2002/02/14 15:32:11 dhartmei Exp $ */
d54 1
d424 3
d517 5
d564 2
d597 2
@


1.62
log
@Add skip steps for rule action (pass/block vs. scrub) and direction
(in vs. out). This speeds up rule set evaluation considerably, because
the rules set used to be linearly traversed (even twice) when looking
for scrub rules. Ok frantzen@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.61 2002/01/11 20:13:11 mickey Exp $ */
a342 3
	struct pf_addr	*src;
	struct pf_addr	*dst;
	u_int16_t	*ip_sum;
a343 6
	u_int32_t	 p_len; 	/* total length of payload */

	u_int16_t	 flags;		/* Let SCRUB trigger behavior in
					 * state code. Easier than tags */
	u_int8_t	 af;
	u_int8_t	 proto;
d353 8
@


1.61
log
@pad the pf_state_{host,peer} to a 32bit quantity; dhartmei@@ frantzen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.60 2002/01/09 11:30:53 dhartmei Exp $ */
d202 10
a211 8
#define PF_SKIP_IFP		0
#define PF_SKIP_AF		1
#define PF_SKIP_PROTO		2
#define PF_SKIP_SRC_ADDR	3
#define PF_SKIP_SRC_PORT	4
#define PF_SKIP_DST_ADDR	5
#define PF_SKIP_DST_PORT	6
#define PF_SKIP_COUNT		7
a279 13

#define		MATCH_TUPLE(h,r,d,i,a) \
		( \
		  (r->direction == d) && \
		  (r->ifp == NULL || r->ifp == i) && \
		  (!r->proto || r->proto == h->ip_p) && \
		  (!r->src.mask.addr32[0] || \
		   pf_match_addr(r->src.not, &(r)->src.addr, \
		   &(r)->src.mask, (struct pf_addr *)&h->ip_src.s_addr, a)) && \
		  (!r->dst.mask.addr32[0] || \
		   pf_match_addr(r->dst.not, &(r)->dst.addr, \
		   &(r)->dst.mask, (struct pf_addr *)&h->ip_dst.s_addr, a)) \
		)
@


1.60
log
@Add labels to rules. These are arbitrary names (not to be confused with
tags that will be used to tag packets later on). Add pfctl -z to clear
per-rule counters. Add pfctl -s labels to output per-rule counters in
terse format and only for rules that have labels. Suggested by
Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.59 2002/01/08 09:31:55 dhartmei Exp $ */
d248 1
d257 1
@


1.59
log
@Add "no nat/rdr/binat" to nat.conf. The first matching rule applies.
If it is a "no" rule, no translation occurs. Useful to exclude certain
packets from translation. Suggested by Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.58 2001/12/10 18:28:32 dhartmei Exp $ */
d194 2
d564 1
@


1.58
log
@Add an ioctl to add state entries (DIOCADDSTATE) for proxies.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.57 2001/12/10 18:08:11 dhartmei Exp $ */
d302 1
d316 1
d337 1
@


1.58.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.61 2002/01/11 20:13:11 mickey Exp $ */
a193 2
#define PF_RULE_LABEL_SIZE	32
	char		 label[PF_RULE_LABEL_SIZE];
a245 1
	u_int16_t	pad;
a253 1
	u_int8_t	pad;
a301 1
	u_int8_t	 no;
a314 1
	u_int8_t	 no;
a334 1
	u_int8_t	 no;
a558 1
#define DIOCCLRRULECTRS	_IO  ('D', 38)
@


1.58.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.58.2.1 2002/01/31 22:55:44 niklas Exp $ */
a37 1
#include <sys/tree.h>
a53 1
enum	{ PF_LIMIT_STATES=0, PF_LIMIT_FRAGS=1, PF_LIMIT_MAX=2 };
d57 2
a58 2
		struct in_addr		v4;
		struct in6_addr		v6;
a61 1
		char			ifname[IFNAMSIZ];
a69 14
struct pf_addr_wrap {
	struct pf_addr		 addr;
	struct pf_addr_dyn	*addr_dyn;
};

struct pf_addr_dyn {
	char			 ifname[IFNAMSIZ];
	struct ifnet		*ifp;
	struct pf_addr		*addr;
	u_int8_t		 af;
	void			*hook_cookie;
	u_int8_t		 undefined;
};

d183 6
a188 3
struct pf_rule_uid {
	uid_t		 uid[2];
	u_int8_t	 op;
d191 25
a215 4
struct pf_rule_gid {
	uid_t		 gid[2];
	u_int8_t	 op;
};
d217 2
a218 8
struct pf_rule_addr {
	struct pf_addr_wrap	 addr;
	struct pf_addr		 mask;
	u_int16_t		 port[2];
	u_int8_t		 not;
	u_int8_t		 port_op;
	u_int8_t		 noroute;
};
d220 4
a223 43
struct pf_rule {
	struct pf_rule_addr	 src;
	struct pf_rule_addr	 dst;
#define PF_SKIP_ACTION		0
#define PF_SKIP_IFP		1
#define PF_SKIP_DIR		2
#define PF_SKIP_AF		3
#define PF_SKIP_PROTO		4
#define PF_SKIP_SRC_ADDR	5
#define PF_SKIP_SRC_PORT	6
#define PF_SKIP_DST_ADDR	7
#define PF_SKIP_DST_PORT	8
#define PF_SKIP_COUNT		9
	struct pf_rule		*skip[PF_SKIP_COUNT];
#define PF_RULE_LABEL_SIZE	 64
	char			 label[PF_RULE_LABEL_SIZE];
	u_int32_t		 timeout[PFTM_MAX];
	struct pf_addr		 rt_addr;
	char			 ifname[IFNAMSIZ];
	char			 rt_ifname[IFNAMSIZ];
	TAILQ_ENTRY(pf_rule)	 entries;

	u_int64_t		 evaluations;
	u_int64_t		 packets;
	u_int64_t		 bytes;

	struct ifnet		*ifp;
	struct ifnet		*rt_ifp;

	u_int32_t		 states;
	u_int32_t		 max_states;

	u_int16_t		 nr;
	u_int16_t		 return_icmp;
	u_int16_t		 max_mss;

	struct pf_rule_uid	 uid;
	struct pf_rule_gid	 gid;

	u_int8_t		 action;
	u_int8_t		 direction;
	u_int8_t		 log;
	u_int8_t		 quick;
d227 13
a239 13
	u_int8_t		 keep_state;
	u_int8_t		 af;
	u_int8_t		 proto;
	u_int8_t		 type;
	u_int8_t		 code;

	u_int8_t		 flags;
	u_int8_t		 flagset;
	u_int8_t		 rule_flag;
	u_int8_t		 min_ttl;
	u_int8_t		 allow_opts;
	u_int8_t		 rt;
	u_int8_t		 return_ttl;
a243 1
#define	PFRULE_FRAGMENT		0x04
d252 1
a252 1
	u_int32_t	seqlo;		/* Max sequence number sent	*/
d261 1
d267 1
a267 4
	union {
		struct pf_rule	*ptr;
		u_int16_t	 nr;
	} rule;
d279 22
a300 5
struct pf_tree_node {
	RB_ENTRY(pf_tree_node) entry;
	struct pf_state	*state;
	struct pf_addr	 addr[2];
	u_int16_t	 port[2];
d303 4
d309 12
a320 16

struct pf_nat {
	char			 ifname[IFNAMSIZ];
	struct ifnet		*ifp;
	TAILQ_ENTRY(pf_nat)	 entries;
	struct pf_addr_wrap	 saddr;
	struct pf_addr_wrap	 daddr;
	struct pf_addr_wrap	 raddr;
	struct pf_addr		 smask;
	struct pf_addr		 dmask;
	u_int8_t		 af;
	u_int8_t		 proto;
	u_int8_t		 snot;
	u_int8_t		 dnot;
	u_int8_t		 ifnot;
	u_int8_t		 no;
d323 19
a341 12
struct pf_binat {
	char			 ifname[IFNAMSIZ];
	struct ifnet		*ifp;
	TAILQ_ENTRY(pf_binat)	 entries;
	struct pf_addr_wrap	 saddr;
	struct pf_addr_wrap	 daddr;
	struct pf_addr_wrap	 raddr;
	struct pf_addr		 dmask;
	u_int8_t		 af;
	u_int8_t		 proto;
	u_int8_t		 dnot;
	u_int8_t		 no;
d344 5
a348 24
struct pf_rdr {
	char			 ifname[IFNAMSIZ];
	struct ifnet		*ifp;
	TAILQ_ENTRY(pf_rdr)	 entries;
	struct pf_addr_wrap	 saddr;
	struct pf_addr_wrap	 daddr;
	struct pf_addr_wrap	 raddr;
	struct pf_addr		 smask;
	struct pf_addr		 dmask;
	u_int16_t		 dport;
	u_int16_t		 dport2;
	u_int16_t		 rport;
	u_int8_t		 af;
	u_int8_t		 proto;
	u_int8_t		 snot;
	u_int8_t		 dnot;
	u_int8_t		 ifnot;
	u_int8_t		 opts;
	u_int8_t		 no;
};

struct pf_port_node {
	LIST_ENTRY(pf_port_node)	next;
	u_int16_t			port;
a349 1
LIST_HEAD(pf_port_list, pf_port_node);
d354 10
a363 1
	u_int64_t	 tot_len;	/* Make Mickey money */
a372 8
	struct pf_addr	*src;
	struct pf_addr	*dst;
	u_int16_t	*ip_sum;
	u_int32_t	 p_len;		/* total length of payload */
	u_int16_t	 flags;		/* Let SCRUB trigger behavior in
					 * state code. Easier than tags */
	u_int8_t	 af;
	u_int8_t	 proto;
a434 3
#define PFFRAG_FRENT_HIWAT	5000	/* Number of fragment entries */
#define PFFRAG_FRAG_HIWAT	1000	/* Number of fragmented packets */

a505 8
struct pfioc_state_kill {
	/* XXX returns the number of states killed in psk_af */
	int			psk_af;
	int			psk_proto;
	struct pf_rule_addr	psk_src;
	struct pf_rule_addr	psk_dst;
};

a524 5
struct pfioc_limit {
	int		 index;
	unsigned	 limit;
};

d532 1
a532 1
#define DIOCADDRULE	_IOWR('D',  4, struct pfioc_rule)
d535 1
a535 1
#define DIOCGETRULE	_IOWR('D',  7, struct pfioc_rule)
d537 1
a537 1
#define DIOCADDNAT	_IOWR('D',  9, struct pfioc_nat)
d540 1
a540 1
#define DIOCGETNAT	_IOWR('D', 12, struct pfioc_nat)
d542 1
a542 1
#define DIOCADDRDR	_IOWR('D', 14, struct pfioc_rdr)
d545 1
a545 1
#define DIOCGETRDR	_IOWR('D', 17, struct pfioc_rdr)
a566 4
#define DIOCGETLIMIT	_IOWR('D', 39, struct pfioc_limit)
#define DIOCSETLIMIT	_IOWR('D', 40, struct pfioc_limit)
#define DIOCKILLSTATES	_IOWR('D', 41, struct pfioc_state_kill)

a568 59
RB_HEAD(pf_state_tree, pf_tree_node);
RB_PROTOTYPE(pf_state_tree, pf_tree_node, entry, pf_state_compare);
extern struct pf_state_tree tree_lan_ext, tree_ext_gwy;

extern struct pf_rulequeue		 pf_rules[2];
TAILQ_HEAD(pf_natqueue, pf_nat);
extern struct pf_natqueue		 pf_nats[2];
TAILQ_HEAD(pf_binatqueue, pf_binat);
extern struct pf_binatqueue		 pf_binats[2];
TAILQ_HEAD(pf_rdrqueue, pf_rdr);
extern struct pf_rdrqueue		 pf_rdrs[2];


extern u_int32_t		 ticket_rules_active;
extern u_int32_t		 ticket_rules_active;
extern u_int32_t		 ticket_rules_inactive;
extern u_int32_t		 ticket_nats_active;
extern u_int32_t		 ticket_nats_inactive;
extern u_int32_t		 ticket_binats_active;
extern u_int32_t		 ticket_binats_inactive;
extern u_int32_t		 ticket_rdrs_active;
extern u_int32_t		 ticket_rdrs_inactive;
extern u_int32_t		 ticket_rules_inactive;
extern struct pf_rulequeue	*pf_rules_active;
extern struct pf_rulequeue	*pf_rules_inactive;
extern struct pf_natqueue	*pf_nats_active;
extern struct pf_natqueue	*pf_nats_inactive;
extern struct pf_binatqueue	*pf_binats_active;
extern struct pf_binatqueue	*pf_binats_inactive;
extern struct pf_rdrqueue	*pf_rdrs_active;
extern struct pf_rdrqueue	*pf_rdrs_inactive;
extern struct pf_port_list	 pf_tcp_ports;
extern struct pf_port_list	 pf_udp_ports;
extern void			 pf_dynaddr_remove(struct pf_addr_wrap *);
extern int			 pf_dynaddr_setup(struct pf_addr_wrap *,
				    u_int8_t);
extern void			 pf_calc_skip_steps(struct pf_rulequeue *);
extern void			 pf_dynaddr_copyout(struct pf_addr_wrap *);
extern struct pool		 pf_tree_pl, pf_rule_pl, pf_nat_pl, pf_sport_pl;
extern struct pool		 pf_rdr_pl, pf_state_pl, pf_binat_pl,
				    pf_addr_pl;
extern void			 pf_purge_timeout(void *);
extern int			 pftm_interval;
extern int			 pf_compare_rules(struct pf_rule *,
				    struct pf_rule *);
extern int			 pf_compare_nats(struct pf_nat *,
				    struct pf_nat *);
extern int			 pf_compare_binats(struct pf_binat *,
				    struct pf_binat *);
extern int			 pf_compare_rdrs(struct pf_rdr *,
				    struct pf_rdr *);
extern void			 pf_purge_expired_states(void);
extern int			 pf_insert_state(struct pf_state *);
extern struct pf_state		*pf_find_state(struct pf_state_tree *,
				    struct pf_tree_node *);
extern struct ifnet		*status_ifp;
extern int			*pftm_timeouts[PFTM_MAX];
extern void			 pf_addrcpy(struct pf_addr *, struct pf_addr *,
				    u_int8_t);
d578 8
a589 1
int	pf_match(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
a590 2
int	pf_match_uid(u_int8_t, uid_t, uid_t, uid_t);
int	pf_match_gid(u_int8_t, gid_t, gid_t, gid_t);
a594 1
int	pf_routable(struct pf_addr *addr, int af);
a597 7
extern struct pool pf_frent_pl, pf_frag_pl;
struct pf_pool_limit {
	void		*pp;
	unsigned	 limit;
};
extern struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX];

@


1.58.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.58.2.2 2002/06/11 03:30:46 art Exp $ */
d54 1
a54 1
enum	{ PF_FASTROUTE=1, PF_ROUTETO=2, PF_DUPTO=3, PF_REPLYTO=4 };
d82 1
a82 1
	sa_family_t		 af;
a145 3
#define PF_POOLMASK(a, b, c, d, f) \
	pf_poolmask(a, b, c, d, f)

a174 3
#define PF_POOLMASK(a, b, c, d, f) \
	pf_poolmask(a, b, c, d, f)

a194 5
#define PF_POOLMASK(a, b, c, d, f) \
       do { \
               (a)->addr32[0] = ((b)->addr32[0] & (c)->addr32[0]) | \
               (((c)->addr32[0] ^ 0xffffffff ) & (d)->addr32[0]); \
       } while (0)
a236 1
#define PF_QNAME_SIZE		 16
a238 1
	char			 qname[PF_QNAME_SIZE];
a249 1
	u_int32_t		 qid;
a252 1
	u_int16_t		 return_icmp6;
a261 1
	u_int8_t		 ifnot;
d266 1
a266 1
	sa_family_t		 af;
a277 1
	u_int8_t		 tos;
a279 1
#define	PFRULE_DROP		0x00
a282 4
#define	PFRULE_RETURNICMP	0x08
#define	PFRULE_FRAGCROP		0x10	/* non-buffering frag cache */
#define	PFRULE_FRAGDROP		0x20	/* drop funny fragments */
#define	PFRULE_RETURN		0x40
d313 1
a313 1
	sa_family_t	 af;
a317 1
	u_int8_t	 pad[3];
d325 1
a325 1
	sa_family_t	 af;
a330 3
	struct pf_rule_addr	 src;
	struct pf_rule_addr	 dst;
	struct pf_addr_wrap	 raddr;
d334 6
a339 2
	u_int16_t		 proxy_port[2];
	sa_family_t		 af;
d341 2
a353 1
	struct pf_addr		 smask;
d355 1
a355 2
	struct pf_addr		 rmask;
	sa_family_t		 af;
d373 1
a373 1
	sa_family_t		 af;
d382 6
d407 1
a407 1
	sa_family_t	 af;
a408 1
	u_int8_t	 tos;
a433 28
/* UDP state enumeration */
#define PFUDPS_NO_TRAFFIC	0
#define PFUDPS_SINGLE		1
#define PFUDPS_MULTIPLE		2

#define PFUDPS_NSTATES		3	/* number of state levels */

#define PFUDPS_NAMES { \
	"NO TRAFFIC", \
	"SINGLE", \
	"MULTIPLE", \
	NULL \
}

/* Other protocol state enumeration */
#define PFOTHERS_NO_TRAFFIC	0
#define PFOTHERS_SINGLE		1
#define PFOTHERS_MULTIPLE	2

#define PFOTHERS_NSTATES	3	/* number of state levels */

#define PFOTHERS_NAMES { \
	"NO TRAFFIC", \
	"SINGLE", \
	"MULTIPLE", \
	NULL \
}

d439 6
a468 51
	char		ifname[IFNAMSIZ];
};

struct cbq_opts {
	u_int		minburst;
	u_int		maxburst;
	u_int		pktsize;
	u_int		maxpktsize;
	u_int		ns_per_byte;
	u_int		maxidle;
	int		minidle;
	u_int		offtime;
	int		flags;
};

struct hfsc_opts {
	u_int		rt_m1;
	u_int		rt_d;
	u_int		rt_m2;
	u_int		ls_m1;
	u_int		ls_d;
	u_int		ls_m2;
	int		flags;
};

struct pf_altq {
	char			 ifname[IFNAMSIZ];

	void			*altq_disc;	/* discipline-specific state */
	TAILQ_ENTRY(pf_altq)	 entries;

	/* scheduler spec */
	u_int8_t		 scheduler;	/* scheduler type */
	u_int16_t		 tbrsize;	/* tokenbuket regulator size */
	u_int32_t		 ifbandwidth;	/* interface bandwidth */

	/* queue spec */
	char			 qname[PF_QNAME_SIZE];	/* queue name */
	char			 parent[PF_QNAME_SIZE];	/* parent name */
	u_int32_t		 parent_qid;	/* parent queue id */
	u_int32_t		 bandwidth;	/* queue bandwidth */
	u_int8_t		 priority;	/* priority */
	u_int16_t		 qlimit;	/* queue size limit */
	u_int16_t		 flags;		/* misc flags */
	union {
		struct cbq_opts		 cbq_opts;
		struct hfsc_opts	 hfsc_opts;
		/* and other discipline specific options */
	} pq_u;

	u_int32_t		 qid;		/* return value */
a472 2
#define PFFRAG_FRCENT_HIWAT	50000	/* Number of fragment cache entries */
#define PFFRAG_FRCACHE_HIWAT	10000	/* Number of fragment descriptors */
d511 1
a511 1
	sa_family_t	 af;
d547 1
a547 1
	sa_family_t		psk_af;
a576 20
struct pfioc_altq {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	struct pf_altq	 altq;
};

struct pfioc_changealtq {
	u_int32_t	 action;
	struct pf_altq	 oldaltq;
	struct pf_altq	 newaltq;
};

struct pfioc_qstats {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	void		*buf;
	int		 nbytes;
	u_int8_t	 scheduler;
};

a621 9
#define DIOCSTARTALTQ	_IO  ('D', 42)
#define DIOCSTOPALTQ	_IO  ('D', 43)
#define DIOCBEGINALTQS	_IOWR('D', 44, u_int32_t)
#define DIOCADDALTQ	_IOWR('D', 45, struct pfioc_altq)
#define DIOCCOMMITALTQS	_IOWR('D', 46, u_int32_t)
#define DIOCGETALTQS	_IOWR('D', 47, struct pfioc_altq)
#define DIOCGETALTQ	_IOWR('D', 48, struct pfioc_altq)
#define DIOCCHANGEALTQ	_IOWR('D', 49, struct pfioc_altq)
#define DIOCGETQSTATS	_IOWR('D', 50, struct pfioc_qstats)
a635 2
TAILQ_HEAD(pf_altqqueue, pf_altq);
extern struct pf_altqqueue		 pf_altqs[2];
a647 2
extern u_int32_t		 ticket_altqs_active;
extern u_int32_t		 ticket_altqs_inactive;
d656 2
a657 2
extern struct pf_altqqueue	*pf_altqs_active;
extern struct pf_altqqueue	*pf_altqs_inactive;
d663 1
a663 1
extern struct pool		 pf_tree_pl, pf_rule_pl, pf_nat_pl;
a665 1
extern struct pool		 pf_altq_pl;
d668 8
d693 2
a694 2
int	pflog_packet(struct ifnet *, struct mbuf *, sa_family_t, u_short,
	    u_short, struct pf_rule *);
d696 1
a696 1
	    struct pf_addr *, sa_family_t);
d705 1
a705 1
int	pf_routable(struct pf_addr *addr, sa_family_t af);
@


1.58.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d12 1
a12 1
 *      notice, this list of conditions and the following disclaimer.
d16 1
a16 1
 *      with the distribution.
d40 16
a55 41
#include <net/radix.h>
#include <netinet/ip_ipsp.h>
#include <netinet/tcp_fsm.h>

#define	PF_TCPS_PROXY_SRC	((TCP_NSTATES)+0)
#define	PF_TCPS_PROXY_DST	((TCP_NSTATES)+1)

enum	{ PF_INOUT, PF_IN, PF_OUT };
enum	{ PF_PASS, PF_DROP, PF_SCRUB, PF_NAT, PF_NONAT,
	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR, PF_SYNPROXY_DROP };
enum	{ PF_RULESET_SCRUB, PF_RULESET_FILTER, PF_RULESET_NAT,
	  PF_RULESET_BINAT, PF_RULESET_RDR, PF_RULESET_MAX };
enum	{ PF_OP_NONE, PF_OP_IRG, PF_OP_EQ, PF_OP_NE, PF_OP_LT,
	  PF_OP_LE, PF_OP_GT, PF_OP_GE, PF_OP_XRG, PF_OP_RRG };
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC };
enum	{ PF_CHANGE_NONE, PF_CHANGE_ADD_HEAD, PF_CHANGE_ADD_TAIL,
	  PF_CHANGE_ADD_BEFORE, PF_CHANGE_ADD_AFTER,
	  PF_CHANGE_REMOVE, PF_CHANGE_GET_TICKET };
/*
 * Note about PFTM_*: real indices into pf_rule.timeout[] come before
 * PFTM_MAX, special cases afterwards. See pf_state_expires().
 */
enum	{ PFTM_TCP_FIRST_PACKET, PFTM_TCP_OPENING, PFTM_TCP_ESTABLISHED,
	  PFTM_TCP_CLOSING, PFTM_TCP_FIN_WAIT, PFTM_TCP_CLOSED,
	  PFTM_UDP_FIRST_PACKET, PFTM_UDP_SINGLE, PFTM_UDP_MULTIPLE,
	  PFTM_ICMP_FIRST_PACKET, PFTM_ICMP_ERROR_REPLY,
	  PFTM_OTHER_FIRST_PACKET, PFTM_OTHER_SINGLE,
	  PFTM_OTHER_MULTIPLE, PFTM_FRAG, PFTM_INTERVAL,
	  PFTM_ADAPTIVE_START, PFTM_ADAPTIVE_END, PFTM_MAX,
	  PFTM_PURGE, PFTM_UNTIL_PACKET };
enum	{ PF_NOPFROUTE, PF_FASTROUTE, PF_ROUTETO, PF_DUPTO, PF_REPLYTO };
enum	{ PF_LIMIT_STATES, PF_LIMIT_FRAGS, PF_LIMIT_MAX };
#define PF_POOL_IDMASK		0x0f
enum	{ PF_POOL_NONE, PF_POOL_BITMASK, PF_POOL_RANDOM,
	  PF_POOL_SRCHASH, PF_POOL_ROUNDROBIN };
enum	{ PF_ADDR_ADDRMASK, PF_ADDR_NOROUTE, PF_ADDR_DYNIFTL,
	  PF_ADDR_TABLE };
#define PF_POOL_TYPEMASK	0x0f
#define PF_POOL_STATICPORT	0x10
#define	PF_WSCALE_FLAG		0x80
#define	PF_WSCALE_MASK		0x0f
d64 1
a72 2
#define	PF_TABLE_NAME_SIZE	 32

d74 2
a75 14
	union {
		struct {
			struct pf_addr		 addr;
			struct pf_addr		 mask;
		}			 a;
		char			 ifname[IFNAMSIZ];
		char			 tblname[PF_TABLE_NAME_SIZE];
	}			 v;
	union {
		struct pf_addr_dyn	*dyn;
		struct pfr_ktable	*tbl;
		int			 tblcnt;
	}			 p;
	u_int8_t		 type;		/* PF_ADDR_* */
d122 2
a123 1
	((a)->addr32[3] == (b)->addr32[3] && \
d125 1
a125 2
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[0] == (b)->addr32[0])) \
d129 2
a130 1
	((a)->addr32[3] != (b)->addr32[3] || \
d132 1
a132 2
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[0] != (b)->addr32[0])) \
d136 3
a138 2
	(!(a)->addr32[0] && !(a)->addr32[1] && \
	!(a)->addr32[2] && !(a)->addr32[3] )) \
a145 3
#define PF_AINC(a, f) \
	pf_addr_inc(a, f)

a151 1

d155 2
a156 1
	((a)->addr32[3] == (b)->addr32[3] && \
d158 1
a158 2
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[0] == (b)->addr32[0]) \
d161 2
a162 1
	((a)->addr32[3] != (b)->addr32[3] || \
d164 1
a164 2
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[0] != (b)->addr32[0]) \
a177 3
#define PF_AINC(a, f) \
	pf_addr_inc(a, f)

a200 5
#define PF_AINC(a, f) \
	do { \
		(a)->addr32[0] = htonl(ntohl((a)->addr32[0]) + 1); \
	} while (0)

d202 4
a205 4
	do { \
		(a)->addr32[0] = ((b)->addr32[0] & (c)->addr32[0]) | \
		(((c)->addr32[0] ^ 0xffffffff ) & (d)->addr32[0]); \
	} while (0)
a210 18
#define	PF_MISMATCHAW(aw, x, af, not)				\
	(							\
		(((aw)->type == PF_ADDR_NOROUTE &&		\
		    pf_routable((x), (af))) ||			\
		((aw)->type == PF_ADDR_TABLE &&			\
		    !pfr_match_addr((aw)->p.tbl, (x), (af))) ||	\
		((aw)->type == PF_ADDR_DYNIFTL &&		\
		    ((aw)->p.dyn->undefined ||			\
		    (!PF_AZERO(&(aw)->v.a.mask, (af)) &&	\
		    !PF_MATCHA(0, &(aw)->v.a.addr,		\
		    &(aw)->v.a.mask, (x), (af))))) ||		\
		((aw)->type == PF_ADDR_ADDRMASK &&		\
		    !PF_AZERO(&(aw)->v.a.mask, (af)) &&		\
		    !PF_MATCHA(0, &(aw)->v.a.addr,		\
		    &(aw)->v.a.mask, (x), (af)))) !=		\
		(not)						\
	)

d223 1
d227 1
a227 35
};

struct pf_pooladdr {
	struct pf_rule_addr		 addr;
	TAILQ_ENTRY(pf_pooladdr)	 entries;
	char				 ifname[IFNAMSIZ];
	struct ifnet			*ifp;
};

TAILQ_HEAD(pf_palist, pf_pooladdr);

struct pf_poolhashkey {
	union {
		u_int8_t		key8[16];
		u_int16_t		key16[8];
		u_int32_t		key32[4];
	} pfk;		    /* 128-bit hash key */
#define key8	pfk.key8
#define key16	pfk.key16
#define key32	pfk.key32
};

struct pf_pool {
	struct pf_palist	 list;
	struct pf_pooladdr	*cur;
	struct pf_poolhashkey	 key;
	struct pf_addr		 counter;
	u_int16_t		 proxy_port[2];
	u_int8_t		 port_op;
	u_int8_t		 opts;
};

union pf_rule_ptr {
	struct pf_rule		*ptr;
	u_int32_t		 nr;
d233 11
a243 10
#define PF_SKIP_IFP		0
#define PF_SKIP_DIR		1
#define PF_SKIP_AF		2
#define PF_SKIP_PROTO		3
#define PF_SKIP_SRC_ADDR	4
#define PF_SKIP_SRC_PORT	5
#define PF_SKIP_DST_ADDR	6
#define PF_SKIP_DST_PORT	7
#define PF_SKIP_COUNT		8
	union pf_rule_ptr	 skip[PF_SKIP_COUNT];
d247 1
d250 1
a251 7
	char			 pqname[PF_QNAME_SIZE];
#define	PF_ANCHOR_NAME_SIZE	 16
	char			 anchorname[PF_ANCHOR_NAME_SIZE];
#define	PF_TAG_NAME_SIZE	 16
	char			 tagname[PF_TAG_NAME_SIZE];
	char			 match_tagname[PF_TAG_NAME_SIZE];

a252 1
	struct pf_pool		 rpool;
d259 1
a259 1
	struct pf_anchor	*anchor;
a263 3
	u_int32_t		 pqid;
	u_int32_t		 rt_listid;
	u_int32_t		 nr;
d265 1
a268 2
	u_int16_t		 tag;
	u_int16_t		 match_tag;
a272 1
	u_int32_t		 rule_flag;
a277 1
	u_int8_t		 match_tag_not;
a280 1
#define PF_STATE_SYNPROXY	0x3
d286 1
d289 1
d297 8
a304 24
/* rule flags */
#define	PFRULE_DROP		0x0000
#define	PFRULE_RETURNRST	0x0001
#define	PFRULE_FRAGMENT		0x0002
#define	PFRULE_RETURNICMP	0x0004
#define	PFRULE_RETURN		0x0008

/* scrub flags */
#define	PFRULE_NODF		0x0100
#define	PFRULE_FRAGCROP		0x0200	/* non-buffering frag cache */
#define	PFRULE_FRAGDROP		0x0400	/* drop funny fragments */
#define PFRULE_RANDOMID		0x0800
#define PFRULE_REASSEMBLE_TCP	0x1000

#define PFSTATE_HIWAT		10000	/* default state table size */


struct pf_state_scrub {
	u_int16_t	pfss_flags;
#define PFSS_TIMESTAMP	0x0001		/* modulate timestamp	*/
	u_int8_t	pfss_ttl;	/* stashed TTL		*/
	u_int8_t	pad;
	u_int32_t	pfss_ts_mod;	/* timestamp modulation	*/
};
d316 3
a318 4
	u_int16_t	max_win;	/* largest window (pre scaling)	*/
	u_int8_t	state;		/* active state level		*/
	u_int8_t	wscale;		/* window scaling factor	*/
	struct pf_state_scrub	*scrub;	/* state is scrubbed		*/
d327 4
a330 5
	union pf_rule_ptr rule;
	union pf_rule_ptr anchor;
	union pf_rule_ptr nat_rule;
	struct pf_addr	 rt_addr;
	struct ifnet	*rt_ifp;
d340 1
a340 2
	u_int8_t	 timeout;
	u_int8_t	 pad[2];
a351 1
TAILQ_HEAD(pf_rulequeue, pf_rule);
d353 13
a365 1
struct pf_anchor;
d367 15
a381 45
struct pf_ruleset {
	TAILQ_ENTRY(pf_ruleset)	 entries;
#define PF_RULESET_NAME_SIZE	 16
	char			 name[PF_RULESET_NAME_SIZE];
	struct {
		struct pf_rulequeue	 queues[2];
		struct {
			struct pf_rulequeue	*ptr;
			u_int32_t		 ticket;
		}			 active, inactive;
	}			 rules[PF_RULESET_MAX];
	struct pf_anchor	*anchor;
};

TAILQ_HEAD(pf_rulesetqueue, pf_ruleset);

struct pf_anchor {
	TAILQ_ENTRY(pf_anchor)	 entries;
	char			 name[PF_ANCHOR_NAME_SIZE];
	struct pf_rulesetqueue	 rulesets;
};

TAILQ_HEAD(pf_anchorqueue, pf_anchor);

#define PFR_TFLAG_PERSIST	0x00000001
#define PFR_TFLAG_CONST		0x00000002
#define PFR_TFLAG_ACTIVE	0x00000004
#define PFR_TFLAG_INACTIVE	0x00000008
#define PFR_TFLAG_REFERENCED	0x00000010
#define PFR_TFLAG_REFDANCHOR	0x00000020
#define PFR_TFLAG_USRMASK	0x00000003
#define PFR_TFLAG_SETMASK	0x0000003C
#define PFR_TFLAG_ALLMASK	0x0000003F

struct pfr_table {
	char			 pfrt_anchor[PF_ANCHOR_NAME_SIZE];
	char			 pfrt_ruleset[PF_RULESET_NAME_SIZE];
	char			 pfrt_name[PF_TABLE_NAME_SIZE];
	u_int32_t		 pfrt_flags;
	u_int8_t		 pfrt_fback;
};

enum { PFR_FB_NONE, PFR_FB_MATCH, PFR_FB_ADDED, PFR_FB_DELETED,
	PFR_FB_CHANGED, PFR_FB_CLEARED, PFR_FB_DUPLICATE,
	PFR_FB_NOTMATCH, PFR_FB_CONFLICT, PFR_FB_MAX };
d383 22
a404 77
struct pfr_addr {
	union {
		struct in_addr	 _pfra_ip4addr;
		struct in6_addr	 _pfra_ip6addr;
	}		 pfra_u;
	u_int8_t	 pfra_af;
	u_int8_t	 pfra_net;
	u_int8_t	 pfra_not;
	u_int8_t	 pfra_fback;
};
#define	pfra_ip4addr	pfra_u._pfra_ip4addr
#define	pfra_ip6addr	pfra_u._pfra_ip6addr

enum { PFR_DIR_IN, PFR_DIR_OUT, PFR_DIR_MAX };
enum { PFR_OP_BLOCK, PFR_OP_PASS, PFR_OP_ADDR_MAX, PFR_OP_TABLE_MAX };
#define PFR_OP_XPASS	PFR_OP_ADDR_MAX

struct pfr_astats {
	struct pfr_addr	 pfras_a;
	u_int64_t	 pfras_packets[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t	 pfras_bytes[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	long		 pfras_tzero;
};

enum { PFR_REFCNT_RULE, PFR_REFCNT_ANCHOR, PFR_REFCNT_MAX };

struct pfr_tstats {
	struct pfr_table pfrts_t;
	u_int64_t	 pfrts_packets[PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_bytes[PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_match;
	u_int64_t	 pfrts_nomatch;
	long		 pfrts_tzero;
	int		 pfrts_cnt;
	int		 pfrts_refcnt[PFR_REFCNT_MAX];
};
#define	pfrts_name	pfrts_t.pfrt_name
#define pfrts_flags	pfrts_t.pfrt_flags

SLIST_HEAD(pfr_kentryworkq, pfr_kentry);
struct pfr_kentry {
	struct radix_node	 pfrke_node[2];
	union sockaddr_union	 pfrke_sa;
	u_int64_t		 pfrke_packets[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t		 pfrke_bytes[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	SLIST_ENTRY(pfr_kentry)	 pfrke_workq;
	long			 pfrke_tzero;
	u_int8_t		 pfrke_af;
	u_int8_t		 pfrke_net;
	u_int8_t		 pfrke_not;
	u_int8_t		 pfrke_mark;
};

SLIST_HEAD(pfr_ktableworkq, pfr_ktable);
RB_HEAD(pfr_ktablehead, pfr_ktable);
struct pfr_ktable {
	struct pfr_tstats	 pfrkt_ts;
	RB_ENTRY(pfr_ktable)	 pfrkt_tree;
	SLIST_ENTRY(pfr_ktable)	 pfrkt_workq;
	struct radix_node_head	*pfrkt_ip4;
	struct radix_node_head	*pfrkt_ip6;
	struct pfr_ktable	*pfrkt_shadow;
	struct pfr_ktable	*pfrkt_root;
	int			 pfrkt_nflags;
};
#define pfrkt_t		pfrkt_ts.pfrts_t
#define pfrkt_name	pfrkt_t.pfrt_name
#define pfrkt_anchor    pfrkt_t.pfrt_anchor
#define pfrkt_ruleset   pfrkt_t.pfrt_ruleset
#define pfrkt_flags	pfrkt_t.pfrt_flags
#define pfrkt_cnt	pfrkt_ts.pfrts_cnt
#define pfrkt_refcnt	pfrkt_ts.pfrts_refcnt
#define pfrkt_packets	pfrkt_ts.pfrts_packets
#define pfrkt_bytes	pfrkt_ts.pfrts_bytes
#define pfrkt_match	pfrkt_ts.pfrts_match
#define pfrkt_nomatch	pfrkt_ts.pfrts_nomatch
#define pfrkt_tzero	pfrkt_ts.pfrts_tzero
a422 1
#define PFDESC_TCP_NORM	0x0001		/* TCP shall be statefully scrubbed */
d459 1
a459 1
	"NO_TRAFFIC", \
d473 1
a473 1
	"NO_TRAFFIC", \
a522 4
struct priq_opts {
	int		flags;
};

d524 6
a529 12
	/* real-time service curve */
	u_int		rtsc_m1;	/* slope of the 1st segment in bps */
	u_int		rtsc_d;		/* the x-projection of m1 in msec */
	u_int		rtsc_m2;	/* slope of the 2nd segment in bps */
	/* link-sharing service curve */
	u_int		lssc_m1;
	u_int		lssc_d;
	u_int		lssc_m2;
	/* upper-limit service curve */
	u_int		ulsc_m1;
	u_int		ulsc_d;
	u_int		ulsc_m2;
a553 1
		struct priq_opts	 priq_opts;
d555 1
a560 13
struct pf_tag {
	u_int16_t	tag;		/* tag id */
};

struct pf_tagname {
	TAILQ_ENTRY(pf_tagname)	entries;
	char			name[PF_TAG_NAME_SIZE];
	u_int16_t		tag;
	int			ref;
};

TAILQ_HEAD(pf_tagnames, pf_tagname);

d570 4
a573 11
struct pfioc_pooladdr {
	u_int32_t		 action;
	u_int32_t		 ticket;
	u_int32_t		 nr;
	u_int32_t		 r_num;
	u_int8_t		 r_action;
	u_int8_t		 r_last;
	u_int8_t		 af;
	char			 anchor[PF_ANCHOR_NAME_SIZE];
	char			 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_pooladdr	 addr;
d576 1
a576 1
struct pfioc_rule {
d578 5
a583 1
	u_int32_t	 pool_ticket;
d585 7
a591 3
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_rule	 rule;
d608 24
d648 2
a649 2
		caddr_t		 psu_buf;
		struct pf_state	*psu_states;
a669 1
	u_int32_t	 action;
d675 6
a688 39
struct pfioc_anchor {
	u_int32_t	 nr;
	char		 name[PF_ANCHOR_NAME_SIZE];
};

struct pfioc_ruleset {
	u_int32_t	 nr;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 name[PF_RULESET_NAME_SIZE];
};

#define PFR_FLAG_ATOMIC		0x00000001
#define PFR_FLAG_DUMMY		0x00000002
#define PFR_FLAG_FEEDBACK	0x00000004
#define PFR_FLAG_CLSTATS	0x00000008
#define PFR_FLAG_ADDRSTOO	0x00000010
#define PFR_FLAG_REPLACE	0x00000020
#define PFR_FLAG_ALLMASK	0x0000003F

struct pfioc_table {
	struct pfr_table	 pfrio_table;
	void			*pfrio_buffer;
	int			 pfrio_esize;
	int			 pfrio_size;
	int			 pfrio_size2;
	int			 pfrio_nadd;
	int			 pfrio_ndel;
	int			 pfrio_nchange;
	int			 pfrio_flags;
	int			 pfrio_ticket;
};
#define	pfrio_exists	pfrio_nadd
#define	pfrio_nzero	pfrio_nadd
#define	pfrio_nmatch	pfrio_nadd
#define pfrio_naddr	pfrio_size2
#define pfrio_setflag	pfrio_size2
#define pfrio_clrflag	pfrio_nadd


d695 1
a695 1
#define DIOCBEGINRULES	_IOWR('D',  3, struct pfioc_rule)
d697 1
a697 1
#define DIOCCOMMITRULES	_IOWR('D',  5, struct pfioc_rule)
d700 10
a709 1
/* XXX cut 8 - 17 */
d718 3
a720 2
#define DIOCCHANGERULE	_IOWR('D', 26, struct pfioc_rule)
/* XXX cut 26 - 28 */
d723 6
d743 1
a743 27
#define DIOCBEGINADDRS	_IOWR('D', 51, struct pfioc_pooladdr)
#define DIOCADDADDR	_IOWR('D', 52, struct pfioc_pooladdr)
#define DIOCGETADDRS	_IOWR('D', 53, struct pfioc_pooladdr)
#define DIOCGETADDR	_IOWR('D', 54, struct pfioc_pooladdr)
#define DIOCCHANGEADDR	_IOWR('D', 55, struct pfioc_pooladdr)
#define	DIOCGETANCHORS	_IOWR('D', 56, struct pfioc_anchor)
#define	DIOCGETANCHOR	_IOWR('D', 57, struct pfioc_anchor)
#define	DIOCGETRULESETS	_IOWR('D', 58, struct pfioc_ruleset)
#define	DIOCGETRULESET	_IOWR('D', 59, struct pfioc_ruleset)
#define	DIOCRCLRTABLES	_IOWR('D', 60, struct pfioc_table)
#define	DIOCRADDTABLES	_IOWR('D', 61, struct pfioc_table)
#define	DIOCRDELTABLES	_IOWR('D', 62, struct pfioc_table)
#define	DIOCRGETTABLES	_IOWR('D', 63, struct pfioc_table)
#define	DIOCRGETTSTATS	_IOWR('D', 64, struct pfioc_table)
#define DIOCRCLRTSTATS  _IOWR('D', 65, struct pfioc_table)
#define	DIOCRCLRADDRS	_IOWR('D', 66, struct pfioc_table)
#define	DIOCRADDADDRS	_IOWR('D', 67, struct pfioc_table)
#define	DIOCRDELADDRS	_IOWR('D', 68, struct pfioc_table)
#define	DIOCRSETADDRS	_IOWR('D', 69, struct pfioc_table)
#define	DIOCRGETADDRS	_IOWR('D', 70, struct pfioc_table)
#define	DIOCRGETASTATS	_IOWR('D', 71, struct pfioc_table)
#define DIOCRCLRASTATS  _IOWR('D', 72, struct pfioc_table)
#define	DIOCRTSTADDRS	_IOWR('D', 73, struct pfioc_table)
#define	DIOCRSETTFLAGS	_IOWR('D', 74, struct pfioc_table)
#define DIOCRINABEGIN	_IOWR('D', 75, struct pfioc_table)
#define DIOCRINACOMMIT	_IOWR('D', 76, struct pfioc_table)
#define DIOCRINADEFINE	_IOWR('D', 77, struct pfioc_table)
d750 7
a756 4
extern struct pf_anchorqueue		 pf_anchors;
extern struct pf_ruleset		 pf_main_ruleset;
TAILQ_HEAD(pf_poolqueue, pf_pool);
extern struct pf_poolqueue		 pf_pools[2];
a758 1
extern struct pf_palist			 pf_pabuf;
d761 10
d773 8
a780 1
extern u_int32_t		 ticket_pabuf;
d783 1
a783 6
extern struct pf_poolqueue	*pf_pools_active;
extern struct pf_poolqueue	*pf_pools_inactive;
extern int			 pf_tbladdr_setup(struct pf_ruleset *,
				    struct pf_addr_wrap *);
extern void			 pf_tbladdr_remove(struct pf_addr_wrap *);
extern void			 pf_tbladdr_copyout(struct pf_addr_wrap *);
d785 2
a786 1
				    sa_family_t);
d788 4
a791 8
extern void			 pf_dynaddr_remove(struct pf_addr_wrap *);
extern void			 pf_calc_skip_steps(struct pf_rulequeue *);
extern void			 pf_rule_set_qid(struct pf_rulequeue *);
extern u_int32_t		 pf_qname_to_qid(char *);
extern void			 pf_update_anchor_rules(void);
extern struct pool		 pf_tree_pl, pf_rule_pl, pf_addr_pl;
extern struct pool		 pf_state_pl, pf_altq_pl, pf_pooladdr_pl;
extern struct pool		 pf_state_scrub_pl;
d793 1
a797 1
extern struct pf_anchor		*pf_find_anchor(const char *);
d799 1
a799 1
extern struct pf_rule		 pf_default_rule;
a801 2
void				 pf_rm_rule(struct pf_rulequeue *,
				    struct pf_rule *);
d811 2
a812 5
void   *pf_pull_hdr(struct mbuf *, int, void *, int, u_short *, u_short *,
	    sa_family_t);
void	pf_change_a(void *, u_int16_t *, u_int32_t, u_int8_t);
int	pflog_packet(struct ifnet *, struct mbuf *, sa_family_t, u_int8_t,
	    u_int8_t, struct pf_rule *, struct pf_rule *, struct pf_ruleset *);
a821 10
int	pf_normalize_tcp(int, struct ifnet *, struct mbuf *, int, int, void *,
	    struct pf_pdesc *);
void	pf_normalize_tcp_cleanup(struct pf_state *);
int	pf_normalize_tcp_init(struct mbuf *, int, struct pf_pdesc *,
	    struct tcphdr *, struct pf_state_peer *, struct pf_state_peer *);
int	pf_normalize_tcp_stateful(struct mbuf *, int, struct pf_pdesc *,
	    u_short *, struct tcphdr *, struct pf_state_peer *,
	    struct pf_state_peer *, int *);
u_int32_t
	pf_state_expires(const struct pf_state *);
a823 34
void	pfr_initialize(void);
int	pfr_match_addr(struct pfr_ktable *, struct pf_addr *, sa_family_t);
void	pfr_update_stats(struct pfr_ktable *, struct pf_addr *, sa_family_t,
	    u_int64_t, int, int, int);
struct pfr_ktable *
	pfr_attach_table(struct pf_ruleset *, char *);
void	pfr_detach_table(struct pfr_ktable *);
int	pfr_clr_tables(int *, int);
int	pfr_add_tables(struct pfr_table *, int, int *, int);
int	pfr_del_tables(struct pfr_table *, int, int *, int);
int	pfr_get_tables(struct pfr_table *, int *, int);
int	pfr_get_tstats(struct pfr_tstats *, int *, int);
int	pfr_clr_tstats(struct pfr_table *, int, int *, int);
int	pfr_set_tflags(struct pfr_table *, int, int, int, int *, int *, int);
int	pfr_clr_addrs(struct pfr_table *, int *, int);
int	pfr_add_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_del_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_set_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, int *, int *, int);
int	pfr_get_addrs(struct pfr_table *, struct pfr_addr *, int *, int);
int	pfr_get_astats(struct pfr_table *, struct pfr_astats *, int *, int);
int	pfr_clr_astats(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_tst_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_ina_begin(int *, int *, int);
int	pfr_ina_commit(int, int *, int *, int);
int	pfr_ina_define(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, int, int);

extern struct pf_status	pf_status;
extern struct pool	pf_frent_pl, pf_frag_pl;
d825 3
d832 1
a832 1
extern struct pf_pool_limit	pf_pool_limits[PF_LIMIT_MAX];
@


1.57
log
@Add stateful filtering for other (non-TCP/UDP/ICMP) protocol, based on
source/destination addresses/ports only.
Add RDR for ICMP. Add NAT/RDR/BINAT for other protocols.
Destination and redirection port(s) are now optional for RDR rules.
Not specifying destination port(s) means 'redirect all ports', not
specifying redirection port(s) means 'redirect to the original port'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.56 2001/11/26 16:50:26 jasoni Exp $ */
d558 1
@


1.56
log
@add fastroute options similar to what is found in ipf
ok dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.55 2001/11/06 11:48:29 dhartmei Exp $ */
d50 3
a52 2
	  PFTM_ICMP_FIRST_PACKET=9, PFTM_ICMP_ERROR_REPLY=10, PFTM_FRAG=11,
	  PFTM_INTERVAL=12, PFTM_MAX=13 };
@


1.55
log
@Use #defines for skip step values. From dgregor@@net.ohio-state.edu.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.54 2001/10/15 16:22:21 dhartmei Exp $ */
d52 1
d192 1
d194 1
d197 1
d236 1
@


1.54
log
@Add 'allow-opts' to rules. Packets with IP options will be blocked by
default now, and can be allowed per rule. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.53 2001/09/27 17:49:12 dhartmei Exp $ */
d194 10
a203 1
	struct pf_rule	*skip[7];
@


1.53
log
@The skip steps array was one element short (since adding steps for af).
This invoked undefined behaviour under the proper circumstances.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.52 2001/09/15 16:47:07 dhartmei Exp $ */
a215 1
	
d222 1
d257 1
@


1.52
log
@Don't use m_pkthdr.rcvif in pflog_packet(), it doesn't work for outgoing
packets and is obviously invalid (and not NULL) for IPv6 packets (hence
crashed). Pass ifp down instead.

sizeof(ih) instead of sizeof(&ih) for pf_pull_hdr() from pf_test6().
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.51 2001/09/15 03:54:40 frantzen Exp $ */
d194 1
a194 1
	struct pf_rule	*skip[6];
@


1.51
log
@IPv6 support from Ryan McBride (mcbride@@countersiege.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.50 2001/09/06 18:05:46 jasoni Exp $ */
d561 2
a562 1
int	pflog_packet(struct mbuf *, int, u_short, u_short, struct pf_rule *);
@


1.50
log
@1:1 bidrectional NAT (binat); ok dhartmei@@ and frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.49 2001/09/05 12:42:31 dhartmei Exp $ */
d53 128
d182 2
a183 2
	u_int32_t	addr;
	u_int32_t	mask;
d212 1
d216 1
d229 1
a229 1
	u_int32_t	addr;
d253 1
d259 1
a259 1
#define		MATCH_TUPLE(h,r,d,i) \
d264 6
a269 4
		  (!r->src.mask || pf_match_addr(r->src.not, r->src.addr, \
		   r->src.mask, h->ip_src.s_addr)) && \
		  (!r->dst.mask || pf_match_addr(r->dst.not, r->dst.addr, \
		   r->dst.mask, h->ip_dst.s_addr)) \
d276 6
a281 5
	u_int32_t	 saddr;
	u_int32_t	 smask;
	u_int32_t	 daddr;
	u_int32_t	 dmask;
	u_int32_t	 raddr;
d292 5
a296 4
	u_int32_t	 saddr;
	u_int32_t	 daddr;
	u_int32_t	 dmask;
	u_int32_t	 raddr;
d305 5
a309 5
	u_int32_t	 saddr;
	u_int32_t	 smask;
	u_int32_t	 daddr;
	u_int32_t	 dmask;
	u_int32_t	 raddr;
d313 1
d322 1
a322 1
	struct in_addr	 addr[2];
d325 1
d330 22
d404 2
a405 2
	u_int64_t	pcounters[2][3];
	u_int64_t	bcounters[2];
d441 4
a444 4
	u_int32_t	 saddr;
	u_int32_t	 daddr;
	u_int32_t	 rsaddr;
	u_int32_t	 rdaddr;
d449 1
d461 3
a463 3
	u_int32_t	 action;
	struct pf_binat	 oldbinat;
	struct pf_binat	 newbinat;
d545 1
d547 5
d562 2
a563 1
int	pf_match_addr(u_int8_t, u_int32_t, u_int32_t, u_int32_t);
@


1.49
log
@s/pf_natlook/pfioc_natlook (ioctl parameter struct)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.48 2001/09/04 12:32:53 dhartmei Exp $ */
d154 12
d294 12
d376 6
@


1.48
log
@Add skip steps for interface (ifp).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.47 2001/08/28 00:02:43 frantzen Exp $ */
a138 14
struct pf_natlook {
	u_int32_t	saddr;
	u_int32_t	daddr;
	u_int32_t	rsaddr;
	u_int32_t	rdaddr;
	u_int16_t	sport;
	u_int16_t	dport;
	u_int16_t	rsport;
	u_int16_t	rdport;
	u_int8_t	proto;
	u_int8_t	direction;
};
	

d269 13
d344 1
a344 1
#define DIOCNATLOOK	_IOWR('D', 23, struct pf_natlook)
@


1.47
log
@Bump state timeouts and allow tweaking them from pfctl.
(The state timeouts need some _serious_ tuning)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.46 2001/08/25 21:54:26 frantzen Exp $ */
d66 1
a66 1
	struct pf_rule	*skip[5];
@


1.46
log
@PF ISN randomization.  Or in trekkie techno-babble, ISN phase modulation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.45 2001/08/21 17:25:59 deraadt Exp $ */
d47 5
d314 5
d351 2
@


1.45
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.44 2001/08/19 20:25:22 dhartmei Exp $ */
d76 2
d101 1
@


1.44
log
@Add new ioctls for adding/removing RDR and NAT rules to/from the active
rule sets.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.43 2001/08/19 19:03:58 dhartmei Exp $ */
d4 1
a4 1
 * Copyright (c) 2001, Daniel Hartmeier
@


1.43
log
@Add per-rule byte counter, so mickey can do accounting. We're counting the
data part (without IP and TCP/UDP/ICMP headers), like the state counter does.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.42 2001/08/19 18:19:08 dhartmei Exp $ */
d44 3
a46 3
enum	{ PF_CHANGERULE_ADD_HEAD=1, PF_CHANGERULE_ADD_TAIL=2,
	  PF_CHANGERULE_ADD_BEFORE=3, PF_CHANGERULE_ADD_AFTER=4,
	  PF_CHANGERULE_REMOVE=5 };
a257 1
	u_int32_t	 ticket;
d269 6
d281 6
d336 2
@


1.42
log
@Add per-rule statistics (number of evaluations and number of packets).
Packets passed statefully will be counted using the rule that created
the state.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.41 2001/08/18 22:26:08 dhartmei Exp $ */
d64 1
d66 1
a66 1
	u_int64_t	 evaluations;
@


1.41
log
@Add new ioctl for adding/removing individual rules to/from the active rule set.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.40 2001/08/18 21:09:13 deraadt Exp $ */
d63 3
@


1.40
log
@make pfctl -s state SCREAM; frantzen is now happy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.39 2001/08/11 12:04:59 dhartmei Exp $ */
d44 3
d253 7
d320 1
@


1.39
log
@Add support for ICMP errors referring to ICMP queries/replies. Fixes
'ICMP error message for bad proto' messages. Reported by Mark Grimes
and Steve Rumble.

Add debugging level with ioctl interface and pfctl switch. Default
is 'None'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.38 2001/08/01 23:07:36 provos Exp $ */
d267 10
d309 1
@


1.38
log
@stateless tcp normalization along the lines of the normalization paper by
handley, paxon and kreibich; okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.37 2001/07/29 12:53:17 dhartmei Exp $ */
d43 1
d237 1
d298 1
a321 1
extern int pf_debug;
@


1.37
log
@Implement rule skipping. This is a transparent evaluation optimization,
which reduces evaluation cost for sorted rules of similar parameters.
Preparation for rule duplication for parameter lists from pfctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.36 2001/07/19 00:07:36 krw Exp $ */
d311 1
@


1.36
log
@Fix/complete the handling of the binary ops >< and <> to behave
like the ipf operators.

The 'n >< m' construct (Include Range = PF_OP_IRG) should match
ports greater than n and less than m, not greater than or equal to
n and less than or equal to m.

The 'n <> m' construct (Exclude Range = PF_OP_XRG) should match
all ports less than n OR greater than m, not be treated as an
alias for ><.

Thus PF_OP_GL, which was used for both <> and >< is replaced with
PF_OP_IRG and PF_OP_XRG with the 'correct' semantics.

OK dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.35 2001/07/17 22:22:15 provos Exp $ */
d57 1
@


1.35
log
@support min-ttl, okay dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.34 2001/07/17 21:54:26 provos Exp $ */
d41 2
a42 2
enum	{ PF_OP_GL=1, PF_OP_EQ=2, PF_OP_NE=3, PF_OP_LT=4,
	  PF_OP_LE=5, PF_OP_GT=6, PF_OP_GE=7 };
@


1.34
log
@normalize ip_off, make IP_DF stripping optional, return rst is a flag now.
okay markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.33 2001/07/17 20:34:51 provos Exp $ */
d76 1
@


1.33
log
@split ip normalization out into a separate file, okay dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.31 2001/07/06 21:19:56 chris Exp $ */
d74 2
a75 1
	u_int8_t	 return_rst;
d77 3
@


1.32
log
@Extend nat/rdr syntax. Add source/destination selection. Make
interface optional. Suggested by rdump@@river.com.

nat [on [!] <ifname>] from (any | [!] <addr>[/<mask>]) to (any |
    [!] <addr>[/<mask>]) -> <addr> [proto (tcp | udp | icmp)]

rdr [on [!] <ifname>] from (any | [!] <addr>[/<mask>]) to (any |
    [!] <addr>[/<mask>]) port <a>[:<b>] -> <addr> port <c>[:*]
    [proto (tcp | udp | icmp)]
@
text
@d106 11
d165 8
d208 14
d295 18
@


1.31
log
@Allow negative match on interface name for nat and rdr
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.30 2001/07/06 08:26:57 deraadt Exp $ */
d127 2
d130 2
a131 1
	u_int8_t	 not;
d139 2
d148 2
a149 1
	u_int8_t	 not;
@


1.30
log
@do not use quad for counters
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.29 2001/07/03 03:34:42 beck Exp $ */
d129 1
d144 1
@


1.29
log
@add DIOCNATLOOK ioctl and pf_natlook structure, this enables a userland
process recieving rdr'ed connections to look up the original destination
of the connection before it was redirected - this enables the writing
of transparent proxies.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.28 2001/07/01 23:04:44 dhartmei Exp $ */
d182 4
a185 4
	quad_t		counters[PFRES_MAX];
	quad_t		fcounters[FCNT_MAX];
	quad_t		pcounters[2][3];
	quad_t		bcounters[2];
@


1.28
log
@tag packets generated by pf (return-rst, return-icmp) so they are not filtered, use existing icmp_error() and ip_output(). ok dugsong@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.27 2001/07/01 17:16:03 kjell Exp $ */
d106 14
d248 1
@


1.28.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.28 2001/07/01 23:04:44 dhartmei Exp $ */
d4 1
a4 1
 * Copyright (c) 2001 Daniel Hartmeier
d41 2
a42 139
enum	{ PF_OP_IRG=1, PF_OP_EQ=2, PF_OP_NE=3, PF_OP_LT=4,
	  PF_OP_LE=5, PF_OP_GT=6, PF_OP_GE=7, PF_OP_XRG=8 };
enum	{ PF_DEBUG_NONE=0, PF_DEBUG_URGENT=1, PF_DEBUG_MISC=2 };
enum	{ PF_CHANGE_ADD_HEAD=1, PF_CHANGE_ADD_TAIL=2,
	  PF_CHANGE_ADD_BEFORE=3, PF_CHANGE_ADD_AFTER=4,
	  PF_CHANGE_REMOVE=5 };
enum	{ PFTM_TCP_FIRST_PACKET=0, PFTM_TCP_OPENING=1, PFTM_TCP_ESTABLISHED=2,
	  PFTM_TCP_CLOSING=3, PFTM_TCP_FIN_WAIT=4, PFTM_TCP_CLOSED=5,
	  PFTM_UDP_FIRST_PACKET=6, PFTM_UDP_SINGLE=7, PFTM_UDP_MULTIPLE=8,
	  PFTM_ICMP_FIRST_PACKET=9, PFTM_ICMP_ERROR_REPLY=10, PFTM_FRAG=11,
	  PFTM_INTERVAL=12, PFTM_MAX=13 };

struct pf_addr {
	union {
		struct in_addr 		v4;
		struct in6_addr 	v6;
		u_int8_t		addr8[16];
		u_int16_t		addr16[8];
		u_int32_t		addr32[4];
	} pfa;		    /* 128-bit address */
#define v4	pfa.v4
#define v6	pfa.v6
#define addr8	pfa.addr8
#define addr16	pfa.addr16
#define addr32	pfa.addr32
};

/*
 * Address manipulation macros
 */

#ifdef _KERNEL

#ifdef INET
#ifndef INET6
#define PF_INET_ONLY
#endif /* ! INET6 */
#endif /* INET */

#ifdef INET6
#ifndef INET
#define PF_INET6_ONLY
#endif /* ! INET */
#endif /* INET6 */

#ifdef INET
#ifdef INET6
#define PF_INET_INET6
#endif /* INET6 */
#endif /* INET */

#else

#define PF_INET_INET6

#endif /* _KERNEL */

/* Both IPv4 and IPv6 */
#ifdef PF_INET_INET6

#define PF_AEQ(a, b, c) \
	((c == AF_INET && (a)->addr32[0] == (b)->addr32[0]) || \
	(c == AF_INET6 && (a)->addr32[0] == (b)->addr32[0] && \
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[2] == (b)->addr32[2] && \
	(a)->addr32[3] == (b)->addr32[3])) \

#define PF_ANEQ(a, b, c) \
	((c == AF_INET && (a)->addr32[0] != (b)->addr32[0]) || \
	(c == AF_INET6 && ((a)->addr32[0] != (b)->addr32[0] || \
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[2] != (b)->addr32[2] || \
	(a)->addr32[3] != (b)->addr32[3]))) \

#define PF_AZERO(a, c) \
	((c == AF_INET && !(a)->addr32[0]) || \
	(c == AF_INET6 && !(a)->addr32[0] && \
	!(a)->addr32[1] && !(a)->addr32[2] && \
	!(a)->addr32[3] )) \

#define PF_MATCHA(n, a, m, b, f) \
	pf_match_addr(n, a, m, b, f)

#define PF_ACPY(a, b, f) \
	pf_addrcpy(a, b, f)

#else

/* Just IPv6 */
#ifdef PF_INET6_ONLY

#define PF_AEQ(a, b, c) \
	((a)->addr32[0] == (b)->addr32[0] && \
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[2] == (b)->addr32[2] && \
	(a)->addr32[3] == (b)->addr32[3]) \

#define PF_ANEQ(a, b, c) \
	((a)->addr32[0] != (b)->addr32[0] || \
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[2] != (b)->addr32[2] || \
	(a)->addr32[3] != (b)->addr32[3]) \

#define PF_AZERO(a, c) \
	(!(a)->addr32[0] && \
	!(a)->addr32[1] && \
	!(a)->addr32[2] && \
	!(a)->addr32[3] ) \

#define PF_MATCHA(n, a, m, b, f) \
	pf_match_addr(n, a, m, b, f)

#define PF_ACPY(a, b, f) \
	pf_addrcpy(a, b, f)

#else

/* Just IPv4 */
#ifdef PF_INET_ONLY

#define PF_AEQ(a, b, c) \
	((a)->addr32[0] == (b)->addr32[0])

#define PF_ANEQ(a, b, c) \
	((a)->addr32[0] != (b)->addr32[0])

#define PF_AZERO(a, c) \
	(!(a)->addr32[0])

#define PF_MATCHA(n, a, m, b, f) \
	pf_match_addr(n, a, m, b, f)

#define PF_ACPY(a, b, f) \
	(a)->v4.s_addr = (b)->v4.s_addr


#endif /* PF_INET_ONLY */
#endif /* PF_INET6_ONLY */
#endif /* PF_INET_INET6 */
d45 2
a46 2
	struct pf_addr	addr;
	struct pf_addr	mask;
a56 1
	struct pf_rule	*skip[7];
a58 4
	u_int64_t	 evaluations;
	u_int64_t	 packets;
	u_int64_t	 bytes;

a66 2
#define PF_STATE_NORMAL		0x1
#define PF_STATE_MODULATE	0x2
a67 1
	u_int8_t	 af;
d74 1
a74 4

	u_int8_t	 rule_flag;
	u_int8_t	 min_ttl;	/* minimum ttl for packet normalize */
	u_int8_t	 allow_opts;
a76 3
#define	PFRULE_RETURNRST	0x01
#define	PFRULE_NODF		0x02

d78 1
a78 1
	struct pf_addr	addr;
a84 1
	u_int32_t	seqdiff;	/* Sequence number modulator	*/
a100 1
	u_int8_t	 af;
a103 1
	u_int8_t	 allow_opts;
a105 13
#define		MATCH_TUPLE(h,r,d,i,a) \
		( \
		  (r->direction == d) && \
		  (r->ifp == NULL || r->ifp == i) && \
		  (!r->proto || r->proto == h->ip_p) && \
		  (!r->src.mask.addr32[0] || \
		   pf_match_addr(r->src.not, &(r)->src.addr, \
		   &(r)->src.mask, (struct pf_addr *)&h->ip_src.s_addr, a)) && \
		  (!r->dst.mask.addr32[0] || \
		   pf_match_addr(r->dst.not, &(r)->dst.addr, \
		   &(r)->dst.mask, (struct pf_addr *)&h->ip_dst.s_addr, a)) \
		)

d110 3
a112 21
	struct pf_addr	 saddr;
	struct pf_addr	 smask;
	struct pf_addr	 daddr;
	struct pf_addr	 dmask;
	struct pf_addr	 raddr;
	u_int8_t	 af;
	u_int8_t	 proto;
	u_int8_t	 snot;
	u_int8_t	 dnot;
	u_int8_t	 ifnot;
};

struct pf_binat {
	char		 ifname[IFNAMSIZ];
	struct ifnet	*ifp;
	TAILQ_ENTRY(pf_binat)	entries;
	struct pf_addr	 saddr;
	struct pf_addr	 daddr;
	struct pf_addr	 dmask;
	struct pf_addr	 raddr;
	u_int8_t	 af;
d114 1
a114 1
	u_int8_t	 dnot;
d121 3
a123 5
	struct pf_addr	 saddr;
	struct pf_addr	 smask;
	struct pf_addr	 daddr;
	struct pf_addr	 dmask;
	struct pf_addr	 raddr;
a126 1
	u_int8_t	 af;
d128 1
a128 3
	u_int8_t	 snot;
	u_int8_t	 dnot;
	u_int8_t	 ifnot;
a131 31
struct pf_tree_key {
	struct pf_addr	 addr[2];
	u_int16_t	 port[2];
	u_int8_t	 proto;
	u_int8_t	 af;
};

TAILQ_HEAD(pf_rulequeue, pf_rule);

struct pf_pdesc {
	struct pf_addr	*src;
	struct pf_addr	*dst;
	u_int16_t	*ip_sum;
	u_int64_t	 tot_len; 	/* Make Mickey money */
	u_int32_t	 p_len; 	/* total length of payload */

	u_int16_t	 flags;		/* Let SCRUB trigger behavior in
					 * state code. Easier than tags */
	u_int8_t	 af;
	u_int8_t	 proto;
	union {
		struct tcphdr		*tcp;
		struct udphdr		*udp;
		struct icmp		*icmp;
#ifdef INET6
		struct icmp6_hdr	*icmp6;
#endif /* INET6 */
		void			*any;
	} hdr;
};

a166 14
#define ACTION_SET(a, x) \
	do { \
		if ((a) != NULL) \
			*(a) = (x); \
	} while (0)

#define REASON_SET(a, x) \
	do { \
		if ((a) != NULL) \
			*(a) = (x); \
		if (x < PFRES_MAX) \
			pf_status.counters[x]++; \
	} while (0)

d168 4
a171 4
	u_int64_t	counters[PFRES_MAX];
	u_int64_t	fcounters[FCNT_MAX];
	u_int64_t	pcounters[2][2][3];
	u_int64_t	bcounters[2][2];
a174 1
	u_int32_t	debug;
a186 6
struct pfioc_changerule {
	u_int32_t	 action;
	struct pf_rule	 oldrule;
	struct pf_rule	 newrule;
};

a192 32
struct pfioc_changenat {
	u_int32_t	 action;
	struct pf_nat	 oldnat;
	struct pf_nat	 newnat;
};

struct pfioc_natlook {
	struct pf_addr	 saddr;
	struct pf_addr	 daddr;
	struct pf_addr	 rsaddr;
	struct pf_addr	 rdaddr;
	u_int16_t	 sport;
	u_int16_t	 dport;
	u_int16_t	 rsport;
	u_int16_t	 rdport;
	u_int8_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
};

struct pfioc_binat {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	struct pf_binat	 binat;
};

struct pfioc_changebinat {
	u_int32_t	action;
	struct pf_binat	oldbinat;
	struct pf_binat	newbinat;
};

a198 6
struct pfioc_changerdr {
	u_int32_t	 action;
	struct pf_rdr	 oldrdr;
	struct pf_rdr	 newrdr;
};

a203 10
struct pfioc_states {
	int	ps_len;
	union {
		caddr_t psu_buf;
		struct pf_state *psu_states;
	} ps_u;
#define ps_buf		ps_u.psu_buf
#define ps_states	ps_u.psu_states
};

a207 5
struct pfioc_tm {
	int		 timeout;
	int		 seconds;
};

a233 14
#define DIOCNATLOOK	_IOWR('D', 23, struct pfioc_natlook)
#define DIOCSETDEBUG	_IOWR('D', 24, u_int32_t)
#define DIOCGETSTATES	_IOWR('D', 25, struct pfioc_states)
#define DIOCCHANGERULE	_IOWR('D', 26, struct pfioc_changerule)
#define DIOCCHANGENAT	_IOWR('D', 27, struct pfioc_changenat)
#define DIOCCHANGERDR	_IOWR('D', 28, struct pfioc_changerdr)
#define DIOCSETTIMEOUT	_IOWR('D', 29, struct pfioc_tm)
#define DIOCGETTIMEOUT	_IOWR('D', 30, struct pfioc_tm)
#define DIOCBEGINBINATS	_IOWR('D', 31, u_int32_t)
#define DIOCADDBINAT	_IOWR('D', 32, struct pfioc_binat)
#define DIOCCOMMITBINATS _IOWR('D', 33, u_int32_t)
#define DIOCGETBINATS	_IOWR('D', 34, struct pfioc_binat)
#define DIOCGETBINAT	_IOWR('D', 35, struct pfioc_binat)
#define DIOCCHANGEBINAT	_IOWR('D', 36, struct pfioc_changebinat)
a236 1
#ifdef INET
a237 23
#endif /* INET */

#ifdef INET6
int	pf_test6(int, struct ifnet *, struct mbuf **);
#endif /* INET */

struct pf_tree_node;
struct pf_state
	*pf_find_state(struct pf_tree_node *, struct pf_tree_key *);
int	pf_tree_insert(struct pf_tree_node **, struct pf_tree_node *,
	    struct pf_tree_key *, struct pf_state *);
int	pf_tree_remove(struct pf_tree_node **, struct pf_tree_node *,
	    struct pf_tree_key *);

int	pflog_packet(struct ifnet *, struct mbuf *, int, u_short, u_short,
	    struct pf_rule *);
int	pf_match_addr(u_int8_t, struct pf_addr *, struct pf_addr *,
	    struct pf_addr *, int);
int	pf_match_port(u_int8_t, u_int16_t, u_int16_t, u_int16_t);

void	pf_normalize_init(void);
int	pf_normalize_ip(struct mbuf **, int, struct ifnet *, u_short *);
void	pf_purge_expired_fragments(void);
a238 2
extern struct pf_rulequeue *pf_rules_active;
extern struct pf_status pf_status;
@


1.28.2.2
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d194 1
a194 10

#define PF_SKIP_IFP		0
#define PF_SKIP_AF		1
#define PF_SKIP_PROTO		2
#define PF_SKIP_SRC_ADDR	3
#define PF_SKIP_SRC_PORT	4
#define PF_SKIP_DST_ADDR	5
#define PF_SKIP_DST_PORT	6
#define PF_SKIP_COUNT		7
	struct pf_rule	*skip[PF_SKIP_COUNT];
@


1.28.2.3
log
@Merge in -current
@
text
@a51 1
enum	{ PF_FASTROUTE=1, PF_ROUTETO=2, PF_DUPTO=3 };
a190 1
	char		 rt_ifname[IFNAMSIZ];
a191 1
	struct ifnet	*rt_ifp;
a193 1
	struct pf_addr	 rt_addr;
a231 1
	u_int8_t	 rt;
@


1.28.2.4
log
@Merge in trunk
@
text
@d50 2
a51 3
	  PFTM_ICMP_FIRST_PACKET=9, PFTM_ICMP_ERROR_REPLY=10,
	  PFTM_OTHER_FIRST_PACKET=11, PFTM_OTHER_SINGLE=12,
	  PFTM_OTHER_MULTIPLE=13, PFTM_FRAG=14, PFTM_INTERVAL=15, PFTM_MAX=16 };
a52 1
enum	{ PF_LIMIT_STATES=0, PF_LIMIT_FRAGS=1, PF_LIMIT_MAX=2 };
a192 2
#define PF_RULE_LABEL_SIZE	32
	char		 label[PF_RULE_LABEL_SIZE];
d199 8
a206 10
#define PF_SKIP_ACTION		0
#define PF_SKIP_IFP		1
#define PF_SKIP_DIR		2
#define PF_SKIP_AF		3
#define PF_SKIP_PROTO		4
#define PF_SKIP_SRC_ADDR	5
#define PF_SKIP_SRC_PORT	6
#define PF_SKIP_DST_ADDR	7
#define PF_SKIP_DST_PORT	8
#define PF_SKIP_COUNT		9
a244 1
	u_int16_t	pad;
a252 1
	u_int8_t	pad;
d274 13
a300 1
	u_int8_t	 no;
a313 1
	u_int8_t	 no;
a333 1
	u_int8_t	 no;
d346 3
d350 6
a364 8
	struct pf_addr	*src;
	struct pf_addr	*dst;
	u_int16_t	*ip_sum;
	u_int32_t	 p_len; 	/* total length of payload */
	u_int16_t	 flags;		/* Let SCRUB trigger behavior in
					 * state code. Easier than tags */
	u_int8_t	 af;
	u_int8_t	 proto;
a426 3
#define PFFRAG_FRENT_HIWAT	5000	/* Number of fragment entries */  
#define PFFRAG_FRAG_HIWAT	1000	/* Number of fragmented packets */

a516 5
struct pfioc_limit {
	int		 index;
	unsigned	 limit;
};

a556 4
#define DIOCADDSTATE	_IOWR('D', 37, struct pfioc_state)
#define DIOCCLRRULECTRS	_IO  ('D', 38)
#define DIOCGETLIMIT	_IOWR('D', 39, struct pfioc_limit)
#define DIOCSETLIMIT	_IOWR('D', 40, struct pfioc_limit)
a587 2
extern struct pool pf_frent_pl, pf_frag_pl;

@


1.28.2.5
log
@Sync the SMP branch with 3.3
@
text
@d12 1
a12 1
 *      notice, this list of conditions and the following disclaimer.
d16 1
a16 1
 *      with the distribution.
a37 1
#include <sys/tree.h>
d39 16
a54 31
#include <net/radix.h>
#include <netinet/ip_ipsp.h>

enum	{ PF_INOUT, PF_IN, PF_OUT };
enum	{ PF_PASS, PF_DROP, PF_SCRUB, PF_NAT, PF_NONAT,
	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR };
enum	{ PF_RULESET_SCRUB, PF_RULESET_FILTER, PF_RULESET_NAT,
	  PF_RULESET_BINAT, PF_RULESET_RDR, PF_RULESET_MAX };
enum	{ PF_OP_NONE, PF_OP_IRG, PF_OP_EQ, PF_OP_NE, PF_OP_LT,
	  PF_OP_LE, PF_OP_GT, PF_OP_GE, PF_OP_XRG, PF_OP_RRG };
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC };
enum	{ PF_CHANGE_NONE, PF_CHANGE_ADD_HEAD, PF_CHANGE_ADD_TAIL,
	  PF_CHANGE_ADD_BEFORE, PF_CHANGE_ADD_AFTER,
	  PF_CHANGE_REMOVE, PF_CHANGE_GET_TICKET };
enum	{ PFTM_TCP_FIRST_PACKET, PFTM_TCP_OPENING, PFTM_TCP_ESTABLISHED,
	  PFTM_TCP_CLOSING, PFTM_TCP_FIN_WAIT, PFTM_TCP_CLOSED,
	  PFTM_UDP_FIRST_PACKET, PFTM_UDP_SINGLE, PFTM_UDP_MULTIPLE,
	  PFTM_ICMP_FIRST_PACKET, PFTM_ICMP_ERROR_REPLY,
	  PFTM_OTHER_FIRST_PACKET, PFTM_OTHER_SINGLE,
	  PFTM_OTHER_MULTIPLE, PFTM_FRAG, PFTM_INTERVAL, PFTM_MAX };
enum	{ PF_NOPFROUTE, PF_FASTROUTE, PF_ROUTETO, PF_DUPTO, PF_REPLYTO };
enum	{ PF_LIMIT_STATES, PF_LIMIT_FRAGS, PF_LIMIT_MAX };
#define PF_POOL_IDMASK		0x0f
enum	{ PF_POOL_NONE, PF_POOL_BITMASK, PF_POOL_RANDOM,
	  PF_POOL_SRCHASH, PF_POOL_ROUNDROBIN };
enum	{ PF_ADDR_ADDRMASK, PF_ADDR_NOROUTE, PF_ADDR_DYNIFTL,
	  PF_ADDR_TABLE };
#define PF_POOL_TYPEMASK	0x0f
#define PF_POOL_STATICPORT	0x10
#define	PF_WSCALE_FLAG		0x80
#define	PF_WSCALE_MASK		0x0f
d58 2
a59 2
		struct in_addr		v4;
		struct in6_addr		v6;
a70 28
#define	PF_TABLE_NAME_SIZE	 32

struct pf_addr_wrap {
	union {
		struct {
			struct pf_addr		 addr;
			struct pf_addr		 mask;
		}			 a;
		char			 ifname[IFNAMSIZ];
		char			 tblname[PF_TABLE_NAME_SIZE];
	}			 v;
	union {
		struct pf_addr_dyn	*dyn;
		struct pfr_ktable	*tbl;
		int			 tblcnt;
	}			 p;
	u_int8_t		 type;		/* PF_ADDR_* */
};

struct pf_addr_dyn {
	char			 ifname[IFNAMSIZ];
	struct ifnet		*ifp;
	struct pf_addr		*addr;
	sa_family_t		 af;
	void			*hook_cookie;
	u_int8_t		 undefined;
};

d106 1
a106 1
	((a)->addr32[0] == (b)->addr32[0] && \
d113 1
a113 1
	((a)->addr32[0] != (b)->addr32[0] || \
d116 1
a116 1
	(a)->addr32[3] != (b)->addr32[3])) \
d120 3
a122 2
	(!(a)->addr32[0] && !(a)->addr32[1] && \
	!(a)->addr32[2] && !(a)->addr32[3] )) \
a129 6
#define PF_AINC(a, f) \
	pf_addr_inc(a, f)

#define PF_POOLMASK(a, b, c, d, f) \
	pf_poolmask(a, b, c, d, f)

a132 1

a158 6
#define PF_AINC(a, f) \
	pf_addr_inc(a, f)

#define PF_POOLMASK(a, b, c, d, f) \
	pf_poolmask(a, b, c, d, f)

a178 10
#define PF_AINC(a, f) \
	do { \
		(a)->addr32[0] = htonl(ntohl((a)->addr32[0]) + 1); \
	} while (0)

#define PF_POOLMASK(a, b, c, d, f) \
	do { \
		(a)->addr32[0] = ((b)->addr32[0] & (c)->addr32[0]) | \
		(((c)->addr32[0] ^ 0xffffffff ) & (d)->addr32[0]); \
	} while (0)
a183 28
#define	PF_MISMATCHAW(aw, x, af, not)				\
	(							\
		(((aw)->type == PF_ADDR_NOROUTE &&		\
		    pf_routable((x), (af))) ||			\
		((aw)->type == PF_ADDR_TABLE &&			\
		    !pfr_match_addr((aw)->p.tbl, (x), (af))) ||	\
		((aw)->type == PF_ADDR_DYNIFTL &&		\
		    ((aw)->p.dyn->undefined ||			\
		    (!PF_AZERO(&(aw)->v.a.mask, (af)) &&	\
		    !PF_MATCHA(0, &(aw)->v.a.addr,		\
		    &(aw)->v.a.mask, (x), (af))))) ||		\
		((aw)->type == PF_ADDR_ADDRMASK &&		\
		    !PF_AZERO(&(aw)->v.a.mask, (af)) &&		\
		    !PF_MATCHA(0, &(aw)->v.a.addr,		\
		    &(aw)->v.a.mask, (x), (af)))) !=		\
		(not)						\
	)

struct pf_rule_uid {
	uid_t		 uid[2];
	u_int8_t	 op;
};

struct pf_rule_gid {
	uid_t		 gid[2];
	u_int8_t	 op;
};

d185 5
a189 4
	struct pf_addr_wrap	 addr;
	u_int16_t		 port[2];
	u_int8_t		 not;
	u_int8_t		 port_op;
d192 10
a201 6
struct pf_pooladdr {
	struct pf_rule_addr		 addr;
	TAILQ_ENTRY(pf_pooladdr)	 entries;
	char				 ifname[IFNAMSIZ];
	struct ifnet			*ifp;
};
d203 16
a218 1
TAILQ_HEAD(pf_palist, pf_pooladdr);
d220 2
a221 20
struct pf_poolhashkey {
	union {
		u_int8_t		key8[16];
		u_int16_t		key16[8];
		u_int32_t		key32[4];
	} pfk;		    /* 128-bit hash key */
#define key8	pfk.key8
#define key16	pfk.key16
#define key32	pfk.key32
};

struct pf_pool {
	struct pf_palist	 list;
	struct pf_pooladdr	*cur;
	struct pf_poolhashkey	 key;
	struct pf_addr		 counter;
	u_int16_t		 proxy_port[2];
	u_int8_t		 port_op;
	u_int8_t		 opts;
};
d223 4
a226 54
struct pf_rule {
	struct pf_rule_addr	 src;
	struct pf_rule_addr	 dst;
#define PF_SKIP_IFP		0
#define PF_SKIP_DIR		1
#define PF_SKIP_AF		2
#define PF_SKIP_PROTO		3
#define PF_SKIP_SRC_ADDR	4
#define PF_SKIP_SRC_PORT	5
#define PF_SKIP_DST_ADDR	6
#define PF_SKIP_DST_PORT	7
#define PF_SKIP_COUNT		8
	union {
		struct pf_rule	*ptr;
		u_int32_t	 nr;
	}			 skip[PF_SKIP_COUNT];
#define PF_RULE_LABEL_SIZE	 64
	char			 label[PF_RULE_LABEL_SIZE];
	u_int32_t		 timeout[PFTM_MAX];
#define PF_QNAME_SIZE		 16
	char			 ifname[IFNAMSIZ];
	char			 qname[PF_QNAME_SIZE];
	char			 pqname[PF_QNAME_SIZE];
#define	PF_ANCHOR_NAME_SIZE	 16
	char			 anchorname[PF_ANCHOR_NAME_SIZE];
	TAILQ_ENTRY(pf_rule)	 entries;
	struct pf_pool		 rpool;

	u_int64_t		 evaluations;
	u_int64_t		 packets;
	u_int64_t		 bytes;

	struct ifnet		*ifp;
	struct pf_anchor	*anchor;

	u_int32_t		 states;
	u_int32_t		 max_states;
	u_int32_t		 qid;
	u_int32_t		 pqid;
	u_int32_t		 rt_listid;

	u_int16_t		 nr;
	u_int16_t		 return_icmp;
	u_int16_t		 return_icmp6;
	u_int16_t		 max_mss;

	struct pf_rule_uid	 uid;
	struct pf_rule_gid	 gid;

	u_int8_t		 action;
	u_int8_t		 direction;
	u_int8_t		 log;
	u_int8_t		 quick;
	u_int8_t		 ifnot;
d230 13
a242 14
	u_int8_t		 keep_state;
	sa_family_t		 af;
	u_int8_t		 proto;
	u_int8_t		 type;
	u_int8_t		 code;

	u_int8_t		 flags;
	u_int8_t		 flagset;
	u_int8_t		 rule_flag;
	u_int8_t		 min_ttl;
	u_int8_t		 allow_opts;
	u_int8_t		 rt;
	u_int8_t		 return_ttl;
	u_int8_t		 tos;
a244 1
#define	PFRULE_DROP		0x00
a246 8
#define	PFRULE_FRAGMENT		0x04
#define	PFRULE_RETURNICMP	0x08
#define	PFRULE_FRAGCROP		0x10	/* non-buffering frag cache */
#define	PFRULE_FRAGDROP		0x20	/* drop funny fragments */
#define	PFRULE_RETURN		0x40
#define PFRULE_RANDOMID		0x80

#define PFSTATE_HIWAT		10000	/* default state table size */
d255 1
a255 1
	u_int32_t	seqlo;		/* Max sequence number sent	*/
d260 1
a260 1
	u_int8_t	wscale;
d264 1
d270 1
a270 7
	union {
		struct pf_rule	*ptr;
		u_int32_t	 nr;
	} rule;
	struct pf_rule	*nat_rule;
	struct pf_addr	 rt_addr;
	struct ifnet	*rt_ifp;
d275 1
a275 1
	sa_family_t	 af;
a279 1
	u_int8_t	 pad[3];
d282 53
a334 3
struct pf_tree_node {
	RB_ENTRY(pf_tree_node) entry;
	struct pf_state	*state;
a336 1
	sa_family_t	 af;
d338 1
a342 117
struct pf_anchor;

struct pf_ruleset {
	TAILQ_ENTRY(pf_ruleset)	 entries;
#define PF_RULESET_NAME_SIZE	 16
	char			 name[PF_RULESET_NAME_SIZE];
	struct {
		struct pf_rulequeue	 queues[2];
		struct {
			struct pf_rulequeue	*ptr;
			u_int32_t		 ticket;
		}			 active, inactive;
	}			 rules[PF_RULESET_MAX];
	struct pf_anchor	*anchor;
};

TAILQ_HEAD(pf_rulesetqueue, pf_ruleset);

struct pf_anchor {
	TAILQ_ENTRY(pf_anchor)	 entries;
	char			 name[PF_ANCHOR_NAME_SIZE];
	struct pf_rulesetqueue	 rulesets;
};

TAILQ_HEAD(pf_anchorqueue, pf_anchor);

#define PFR_TFLAG_PERSIST	0x00000001
#define PFR_TFLAG_CONST		0x00000002
#define PFR_TFLAG_ACTIVE	0x00000004
#define PFR_TFLAG_INACTIVE	0x00000008
#define PFR_TFLAG_REFERENCED	0x00000010
#define PFR_TFLAG_USRMASK	0x00000003
#define	PFR_TFLAG_SETMASK	0x0000001C
#define PFR_TFLAG_ALLMASK	0x0000001F

struct pfr_table {
	char			 pfrt_name[PF_TABLE_NAME_SIZE];
	u_int32_t		 pfrt_flags;
};

enum { PFR_FB_NONE, PFR_FB_MATCH, PFR_FB_ADDED, PFR_FB_DELETED,
	PFR_FB_CHANGED, PFR_FB_CLEARED, PFR_FB_DUPLICATE,
	PFR_FB_NOTMATCH, PFR_FB_CONFLICT, PFR_FB_MAX };

struct pfr_addr {
	union {
		struct in_addr	 _pfra_ip4addr;
		struct in6_addr	 _pfra_ip6addr;
	}		 pfra_u;
	u_int8_t	 pfra_af;
	u_int8_t	 pfra_net;
	u_int8_t	 pfra_not;
	u_int8_t	 pfra_fback;
};
#define	pfra_ip4addr	pfra_u._pfra_ip4addr
#define	pfra_ip6addr	pfra_u._pfra_ip6addr

enum { PFR_DIR_IN, PFR_DIR_OUT, PFR_DIR_MAX };
enum { PFR_OP_BLOCK, PFR_OP_PASS, PFR_OP_ADDR_MAX, PFR_OP_TABLE_MAX };
#define PFR_OP_XPASS	PFR_OP_ADDR_MAX

struct pfr_astats {
	struct pfr_addr	 pfras_a;
	u_int64_t	 pfras_packets[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t	 pfras_bytes[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	long		 pfras_tzero;
};

struct pfr_tstats {
	struct pfr_table pfrts_t;
	u_int64_t	 pfrts_packets[PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_bytes[PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_match;
	u_int64_t	 pfrts_nomatch;
	long		 pfrts_tzero;
	int		 pfrts_cnt;
	int		 pfrts_refcnt;
};
#define	pfrts_name	pfrts_t.pfrt_name
#define pfrts_flags	pfrts_t.pfrt_flags

SLIST_HEAD(pfr_kentryworkq, pfr_kentry);
struct pfr_kentry {
	struct radix_node	 pfrke_node[2];
	union sockaddr_union	 pfrke_sa;
	u_int64_t		 pfrke_packets[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t		 pfrke_bytes[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	SLIST_ENTRY(pfr_kentry)	 pfrke_workq;
	long			 pfrke_tzero;
	u_int8_t		 pfrke_af;
	u_int8_t		 pfrke_net;
	u_int8_t		 pfrke_not;
	u_int8_t		 pfrke_mark;
};

SLIST_HEAD(pfr_ktableworkq, pfr_ktable);
RB_HEAD(pfr_ktablehead, pfr_ktable);
struct pfr_ktable {
	struct pfr_tstats	 pfrkt_ts;
	RB_ENTRY(pfr_ktable)	 pfrkt_tree;
	SLIST_ENTRY(pfr_ktable)	 pfrkt_workq;
	struct radix_node_head	*pfrkt_ip4;
	struct radix_node_head	*pfrkt_ip6;
	struct pfr_ktable	*pfrkt_shadow;
	int			 pfrkt_nflags;
};
#define pfrkt_t		pfrkt_ts.pfrts_t
#define pfrkt_name	pfrkt_t.pfrt_name
#define pfrkt_flags	pfrkt_t.pfrt_flags
#define pfrkt_cnt	pfrkt_ts.pfrts_cnt
#define pfrkt_refcnt	pfrkt_ts.pfrts_refcnt
#define pfrkt_packets	pfrkt_ts.pfrts_packets
#define pfrkt_bytes	pfrkt_ts.pfrts_bytes
#define pfrkt_match	pfrkt_ts.pfrts_match
#define pfrkt_nomatch	pfrkt_ts.pfrts_nomatch
#define pfrkt_tzero	pfrkt_ts.pfrts_tzero

d344 1
a344 1
	u_int64_t	 tot_len;	/* Make Mickey money */
d357 1
a357 1
	u_int32_t	 p_len;		/* total length of payload */
d360 1
a360 1
	sa_family_t	 af;
a361 1
	u_int8_t	 tos;
a386 28
/* UDP state enumeration */
#define PFUDPS_NO_TRAFFIC	0
#define PFUDPS_SINGLE		1
#define PFUDPS_MULTIPLE		2

#define PFUDPS_NSTATES		3	/* number of state levels */

#define PFUDPS_NAMES { \
	"NO_TRAFFIC", \
	"SINGLE", \
	"MULTIPLE", \
	NULL \
}

/* Other protocol state enumeration */
#define PFOTHERS_NO_TRAFFIC	0
#define PFOTHERS_SINGLE		1
#define PFOTHERS_MULTIPLE	2

#define PFOTHERS_NSTATES	3	/* number of state levels */

#define PFOTHERS_NAMES { \
	"NO_TRAFFIC", \
	"SINGLE", \
	"MULTIPLE", \
	NULL \
}

d392 6
a421 61
	char		ifname[IFNAMSIZ];
};

struct cbq_opts {
	u_int		minburst;
	u_int		maxburst;
	u_int		pktsize;
	u_int		maxpktsize;
	u_int		ns_per_byte;
	u_int		maxidle;
	int		minidle;
	u_int		offtime;
	int		flags;
};

struct priq_opts {
	int		flags;
};

struct hfsc_opts {
	/* real-time service curve */
	u_int		rtsc_m1;	/* slope of the 1st segment in bps */
	u_int		rtsc_d;		/* the x-projection of m1 in msec */
	u_int		rtsc_m2;	/* slope of the 2nd segment in bps */
	/* link-sharing service curve */
	u_int		lssc_m1;
	u_int		lssc_d;
	u_int		lssc_m2;
	/* upper-limit service curve */
	u_int		ulsc_m1;
	u_int		ulsc_d;
	u_int		ulsc_m2;
	int		flags;
};

struct pf_altq {
	char			 ifname[IFNAMSIZ];

	void			*altq_disc;	/* discipline-specific state */
	TAILQ_ENTRY(pf_altq)	 entries;

	/* scheduler spec */
	u_int8_t		 scheduler;	/* scheduler type */
	u_int16_t		 tbrsize;	/* tokenbuket regulator size */
	u_int32_t		 ifbandwidth;	/* interface bandwidth */

	/* queue spec */
	char			 qname[PF_QNAME_SIZE];	/* queue name */
	char			 parent[PF_QNAME_SIZE];	/* parent name */
	u_int32_t		 parent_qid;	/* parent queue id */
	u_int32_t		 bandwidth;	/* queue bandwidth */
	u_int8_t		 priority;	/* priority */
	u_int16_t		 qlimit;	/* queue size limit */
	u_int16_t		 flags;		/* misc flags */
	union {
		struct cbq_opts		 cbq_opts;
		struct priq_opts	 priq_opts;
		struct hfsc_opts	 hfsc_opts;
	} pq_u;

	u_int32_t		 qid;		/* return value */
d424 1
a424 1
#define PFFRAG_FRENT_HIWAT	5000	/* Number of fragment entries */
a425 2
#define PFFRAG_FRCENT_HIWAT	50000	/* Number of fragment cache entries */
#define PFFRAG_FRCACHE_HIWAT	10000	/* Number of fragment descriptors */
d431 4
a434 11
struct pfioc_pooladdr {
	u_int32_t		 action;
	u_int32_t		 ticket;
	u_int32_t		 nr;
	u_int32_t		 r_num;
	u_int8_t		 r_action;
	u_int8_t		 r_last;
	u_int8_t		 af;
	char			 anchor[PF_ANCHOR_NAME_SIZE];
	char			 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_pooladdr	 addr;
d437 1
a437 1
struct pfioc_rule {
d439 5
a444 1
	u_int32_t	 pool_ticket;
d446 7
a452 3
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_rule	 rule;
d464 1
a464 1
	sa_family_t	 af;
d469 24
a497 8
struct pfioc_state_kill {
	/* XXX returns the number of states killed in psk_af */
	sa_family_t		psk_af;
	int			psk_proto;
	struct pf_rule_addr	psk_src;
	struct pf_rule_addr	psk_dst;
};

d501 2
a502 2
		caddr_t		 psu_buf;
		struct pf_state	*psu_states;
a521 53
struct pfioc_altq {
	u_int32_t	 action;
	u_int32_t	 ticket;
	u_int32_t	 nr;
	struct pf_altq	 altq;
};

struct pfioc_qstats {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	void		*buf;
	int		 nbytes;
	u_int8_t	 scheduler;
};

struct pfioc_anchor {
	u_int32_t	 nr;
	char		 name[PF_ANCHOR_NAME_SIZE];
};

struct pfioc_ruleset {
	u_int32_t	 nr;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 name[PF_RULESET_NAME_SIZE];
};

#define PFR_FLAG_ATOMIC		0x00000001
#define PFR_FLAG_DUMMY		0x00000002
#define PFR_FLAG_FEEDBACK	0x00000004
#define PFR_FLAG_CLSTATS	0x00000008
#define PFR_FLAG_ADDRSTOO	0x00000010
#define PFR_FLAG_REPLACE	0x00000020
#define PFR_FLAG_ALLMASK	0x0000003F

struct pfioc_table {
	struct pfr_table	 pfrio_table;
	void			*pfrio_buffer;
	int			 pfrio_size;
	int			 pfrio_size2;
	int			 pfrio_nadd;
	int			 pfrio_ndel;
	int			 pfrio_nchange;
	int			 pfrio_flags;
	int			 pfrio_ticket;
};
#define	pfrio_exists	pfrio_nadd
#define	pfrio_nzero	pfrio_nadd
#define	pfrio_nmatch	pfrio_nadd
#define pfrio_naddr	pfrio_size2
#define pfrio_setflag	pfrio_size2
#define pfrio_clrflag	pfrio_nadd


d528 3
a530 3
#define DIOCBEGINRULES	_IOWR('D',  3, struct pfioc_rule)
#define DIOCADDRULE	_IOWR('D',  4, struct pfioc_rule)
#define DIOCCOMMITRULES	_IOWR('D',  5, struct pfioc_rule)
d532 11
a542 2
#define DIOCGETRULE	_IOWR('D',  7, struct pfioc_rule)
/* XXX cut 8 - 17 */
d551 3
a553 2
#define DIOCCHANGERULE	_IOWR('D', 26, struct pfioc_rule)
/* XXX cut 26 - 28 */
d556 6
a565 37
#define DIOCKILLSTATES	_IOWR('D', 41, struct pfioc_state_kill)
#define DIOCSTARTALTQ	_IO  ('D', 42)
#define DIOCSTOPALTQ	_IO  ('D', 43)
#define DIOCBEGINALTQS	_IOWR('D', 44, u_int32_t)
#define DIOCADDALTQ	_IOWR('D', 45, struct pfioc_altq)
#define DIOCCOMMITALTQS	_IOWR('D', 46, u_int32_t)
#define DIOCGETALTQS	_IOWR('D', 47, struct pfioc_altq)
#define DIOCGETALTQ	_IOWR('D', 48, struct pfioc_altq)
#define DIOCCHANGEALTQ	_IOWR('D', 49, struct pfioc_altq)
#define DIOCGETQSTATS	_IOWR('D', 50, struct pfioc_qstats)
#define DIOCBEGINADDRS	_IOWR('D', 51, struct pfioc_pooladdr)
#define DIOCADDADDR	_IOWR('D', 52, struct pfioc_pooladdr)
#define DIOCGETADDRS	_IOWR('D', 53, struct pfioc_pooladdr)
#define DIOCGETADDR	_IOWR('D', 54, struct pfioc_pooladdr)
#define DIOCCHANGEADDR	_IOWR('D', 55, struct pfioc_pooladdr)
#define	DIOCGETANCHORS	_IOWR('D', 56, struct pfioc_anchor)
#define	DIOCGETANCHOR	_IOWR('D', 57, struct pfioc_anchor)
#define	DIOCGETRULESETS	_IOWR('D', 58, struct pfioc_ruleset)
#define	DIOCGETRULESET	_IOWR('D', 59, struct pfioc_ruleset)
#define	DIOCRCLRTABLES	_IOWR('D', 60, struct pfioc_table)
#define	DIOCRADDTABLES	_IOWR('D', 61, struct pfioc_table)
#define	DIOCRDELTABLES	_IOWR('D', 62, struct pfioc_table)
#define	DIOCRGETTABLES	_IOWR('D', 63, struct pfioc_table)
#define	DIOCRGETTSTATS	_IOWR('D', 64, struct pfioc_table)
#define DIOCRCLRTSTATS  _IOWR('D', 65, struct pfioc_table)
#define	DIOCRCLRADDRS	_IOWR('D', 66, struct pfioc_table)
#define	DIOCRADDADDRS	_IOWR('D', 67, struct pfioc_table)
#define	DIOCRDELADDRS	_IOWR('D', 68, struct pfioc_table)
#define	DIOCRSETADDRS	_IOWR('D', 69, struct pfioc_table)
#define	DIOCRGETADDRS	_IOWR('D', 70, struct pfioc_table)
#define	DIOCRGETASTATS	_IOWR('D', 71, struct pfioc_table)
#define DIOCRCLRASTATS  _IOWR('D', 72, struct pfioc_table)
#define	DIOCRTSTADDRS	_IOWR('D', 73, struct pfioc_table)
#define	DIOCRSETTFLAGS	_IOWR('D', 74, struct pfioc_table)
#define DIOCRINABEGIN	_IOWR('D', 75, struct pfioc_table)
#define DIOCRINACOMMIT	_IOWR('D', 76, struct pfioc_table)
#define DIOCRINADEFINE	_IOWR('D', 77, struct pfioc_table)
a567 42
RB_HEAD(pf_state_tree, pf_tree_node);
RB_PROTOTYPE(pf_state_tree, pf_tree_node, entry, pf_state_compare);
extern struct pf_state_tree tree_lan_ext, tree_ext_gwy;

extern struct pf_anchorqueue		 pf_anchors;
extern struct pf_ruleset		 pf_main_ruleset;
TAILQ_HEAD(pf_poolqueue, pf_pool);
extern struct pf_poolqueue		 pf_pools[2];
TAILQ_HEAD(pf_altqqueue, pf_altq);
extern struct pf_altqqueue		 pf_altqs[2];
extern struct pf_palist			 pf_pabuf;


extern u_int32_t		 ticket_altqs_active;
extern u_int32_t		 ticket_altqs_inactive;
extern u_int32_t		 ticket_pabuf;
extern struct pf_altqqueue	*pf_altqs_active;
extern struct pf_altqqueue	*pf_altqs_inactive;
extern struct pf_poolqueue	*pf_pools_active;
extern struct pf_poolqueue	*pf_pools_inactive;
extern int			 pf_tbladdr_setup(struct pf_addr_wrap *);
extern void			 pf_tbladdr_remove(struct pf_addr_wrap *);
extern void			 pf_tbladdr_copyout(struct pf_addr_wrap *);
extern int			 pf_dynaddr_setup(struct pf_addr_wrap *,
				    sa_family_t);
extern void			 pf_dynaddr_copyout(struct pf_addr_wrap *);
extern void			 pf_dynaddr_remove(struct pf_addr_wrap *);
extern void			 pf_calc_skip_steps(struct pf_rulequeue *);
extern void			 pf_update_anchor_rules(void);
extern struct pool		 pf_tree_pl, pf_rule_pl, pf_addr_pl;
extern struct pool		 pf_state_pl, pf_altq_pl, pf_pooladdr_pl;
extern void			 pf_purge_timeout(void *);
extern int			 pftm_interval;
extern void			 pf_purge_expired_states(void);
extern int			 pf_insert_state(struct pf_state *);
extern struct pf_state		*pf_find_state(struct pf_state_tree *,
				    struct pf_tree_node *);
extern struct pf_anchor		*pf_find_anchor(const char *);
extern struct ifnet		*status_ifp;
extern int			*pftm_timeouts[PFTM_MAX];
extern void			 pf_addrcpy(struct pf_addr *, struct pf_addr *,
				    u_int8_t);
d577 10
a586 2
int	pflog_packet(struct ifnet *, struct mbuf *, sa_family_t, u_short,
	    u_short, struct pf_rule *);
d588 1
a588 2
	    struct pf_addr *, sa_family_t);
int	pf_match(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
a589 2
int	pf_match_uid(u_int8_t, uid_t, uid_t, uid_t);
int	pf_match_gid(u_int8_t, gid_t, gid_t, gid_t);
a593 32
int	pf_routable(struct pf_addr *addr, sa_family_t af);
void	pfr_initialize(void);
int	pfr_match_addr(struct pfr_ktable *, struct pf_addr *, sa_family_t);
void	pfr_update_stats(struct pfr_ktable *, struct pf_addr *, sa_family_t,
	    u_int64_t, int, int, int);
struct pfr_ktable *
	pfr_attach_table(char *);
void	pfr_detach_table(struct pfr_ktable *);
int	pfr_clr_tables(int *, int);
int	pfr_add_tables(struct pfr_table *, int, int *, int);
int	pfr_del_tables(struct pfr_table *, int, int *, int);
int	pfr_get_tables(struct pfr_table *, int *, int);
int	pfr_get_tstats(struct pfr_tstats *, int *, int);
int	pfr_clr_tstats(struct pfr_table *, int, int *, int);
int	pfr_set_tflags(struct pfr_table *, int, int, int, int *, int *, int);
int	pfr_clr_addrs(struct pfr_table *, int *, int);
int	pfr_add_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_del_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_set_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, int *, int *, int);
int	pfr_get_addrs(struct pfr_table *, struct pfr_addr *, int *, int);
int	pfr_get_astats(struct pfr_table *, struct pfr_astats *, int *, int);
int	pfr_clr_astats(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_tst_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_ina_begin(int *, int *, int);
int	pfr_ina_commit(int, int *, int *, int);
int	pfr_ina_define(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, int, int);
d595 3
a597 8
extern struct pf_status	pf_status;
extern struct pool	pf_frent_pl, pf_frag_pl;

struct pf_pool_limit {
	void		*pp;
	unsigned	 limit;
};
extern struct pf_pool_limit	pf_pool_limits[PF_LIMIT_MAX];
@


1.28.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.28.2.5 2003/03/28 00:41:29 niklas Exp $ */
d59 1
a59 3
	  PFTM_OTHER_MULTIPLE, PFTM_FRAG, PFTM_INTERVAL,
	  PFTM_ADAPTIVE_START, PFTM_ADAPTIVE_END, PFTM_MAX,
	  PFTM_PURGE, PFTM_UNTIL_PACKET };
d150 2
a151 1
	((a)->addr32[3] == (b)->addr32[3] && \
d153 1
a153 2
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[0] == (b)->addr32[0])) \
d157 2
a158 1
	((a)->addr32[3] != (b)->addr32[3] || \
d160 1
a160 2
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[0] != (b)->addr32[0])) \
d186 2
a187 1
	((a)->addr32[3] == (b)->addr32[3] && \
d189 1
a189 2
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[0] == (b)->addr32[0]) \
d192 2
a193 1
	((a)->addr32[3] != (b)->addr32[3] || \
d195 1
a195 2
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[0] != (b)->addr32[0]) \
a314 5
union pf_rule_ptr {
	struct pf_rule		*ptr;
	u_int32_t		 nr;
};

d327 4
a330 1
	union pf_rule_ptr	 skip[PF_SKIP_COUNT];
a354 1
	u_int32_t		 nr;
d356 1
a399 7

struct pf_state_scrub {
	u_int8_t	pfss_ttl;	/* stashed TTL			*/
	u_int8_t	pad;
	u_int16_t	pad2;
};

d410 3
a412 4
	u_int16_t	max_win;	/* largest window (pre scaling)	*/
	u_int8_t	state;		/* active state level		*/
	u_int8_t	wscale;		/* window scaling factor	*/
	struct pf_state_scrub	*scrub;	/* state is scrubbed		*/
d421 5
a425 3
	union pf_rule_ptr rule;
	union pf_rule_ptr anchor;
	union pf_rule_ptr nat_rule;
d437 1
a437 2
	u_int8_t	 timeout;
	u_int8_t	 pad[2];
a481 1
#define PFR_TFLAG_REFDANCHOR	0x00000020
d483 2
a484 2
#define PFR_TFLAG_SETMASK	0x0000003C
#define PFR_TFLAG_ALLMASK	0x0000003F
a486 2
	char			 pfrt_anchor[PF_ANCHOR_NAME_SIZE];
	char			 pfrt_ruleset[PF_RULESET_NAME_SIZE];
a488 1
	u_int8_t		 pfrt_fback;
a518 2
enum { PFR_REFCNT_RULE, PFR_REFCNT_ANCHOR, PFR_REFCNT_MAX };

d527 1
a527 1
	int		 pfrts_refcnt[PFR_REFCNT_MAX];
a554 1
	struct pfr_ktable	*pfrkt_root;
a558 2
#define pfrkt_anchor    pfrkt_t.pfrt_anchor
#define pfrkt_ruleset   pfrkt_t.pfrt_ruleset
a584 1
#define PFDESC_TCP_NORM	0x0001		/* TCP was normalized */
a852 1
	int			 pfrio_esize;
d956 1
a956 2
extern int			 pf_tbladdr_setup(struct pf_ruleset *,
				    struct pf_addr_wrap *);
a963 2
extern void			 pf_rule_set_qid(struct pf_rulequeue *);
extern u_int32_t		 pf_qname_to_qid(char *);
a966 1
extern struct pool		 pf_state_scrub_pl;
d968 1
d975 1
a975 1
extern struct pf_rule		 pf_default_rule;
a977 2
void				 pf_rm_rule(struct pf_rulequeue *,
				    struct pf_rule *);
a997 9
int	pf_normalize_tcp(int, struct ifnet *, struct mbuf *, int, int, void *,
	    struct pf_pdesc *);
void	pf_normalize_tcp_cleanup(struct pf_state *);
int	pf_normalize_tcp_init(struct mbuf *, struct pf_pdesc *, struct tcphdr *,
	    struct pf_state_peer *, struct pf_state_peer *);
int	pf_normalize_tcp_stateful(struct mbuf *, struct pf_pdesc *, u_short *,
	    struct tcphdr *, struct pf_state_peer *, struct pf_state_peer *);
u_int32_t
	pf_state_expires(const struct pf_state *);
d1005 1
a1005 1
	pfr_attach_table(struct pf_ruleset *, char *);
@


1.28.2.7
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a53 4
/*
 * Note about PFTM_*: real indices into pf_rule.timeout[] come before
 * PFTM_MAX, special cases afterwards. See pf_state_expires().
 */
a343 4
#define	PF_TAG_NAME_SIZE	 16
	char			 tagname[PF_TAG_NAME_SIZE];
	char			 match_tagname[PF_TAG_NAME_SIZE];

a363 2
	u_int16_t		 tag;
	u_int16_t		 match_tag;
a367 1
	u_int32_t		 rule_flag;
d381 1
d384 1
d392 9
a400 13
/* rule flags */
#define	PFRULE_DROP		0x0000
#define	PFRULE_RETURNRST	0x0001
#define	PFRULE_FRAGMENT		0x0002
#define	PFRULE_RETURNICMP	0x0004
#define	PFRULE_RETURN		0x0008

/* scrub flags */
#define	PFRULE_NODF		0x0100
#define	PFRULE_FRAGCROP		0x0200	/* non-buffering frag cache */
#define	PFRULE_FRAGDROP		0x0400	/* drop funny fragments */
#define PFRULE_RANDOMID		0x0800
#define PFRULE_REASSEMBLE_TCP	0x1000
d406 1
a406 3
	u_int16_t	pfss_flags;
#define PFSS_TIMESTAMP	0x0001		/* modulate timestamp	*/
	u_int8_t	pfss_ttl;	/* stashed TTL		*/
d408 1
a408 1
	u_int32_t	pfss_ts_mod;	/* timestamp modulation	*/
d605 1
a605 1
#define PFDESC_TCP_NORM	0x0001		/* TCP shall be statefully scrubbed */
a753 13
struct pf_tag {
	u_int16_t	tag;		/* tag id */
};

struct pf_tagname {
	TAILQ_ENTRY(pf_tagname)	entries;
	char			name[PF_TAG_NAME_SIZE];
	u_int16_t		tag;
	int			ref;
};

TAILQ_HEAD(pf_tagnames, pf_tagname);

d1014 2
a1015 5
void   *pf_pull_hdr(struct mbuf *, int, void *, int, u_short *, u_short *,
	    sa_family_t);
void	pf_change_a(void *, u_int16_t *, u_int32_t, u_int8_t);
int	pflog_packet(struct ifnet *, struct mbuf *, sa_family_t, u_int8_t,
	    u_int8_t, struct pf_rule *, struct pf_rule *, struct pf_ruleset *);
d1028 3
a1030 1
int	pf_normalize_tcp_init(struct mbuf *, int, struct pf_pdesc *,
a1031 3
int	pf_normalize_tcp_stateful(struct mbuf *, int, struct pf_pdesc *,
	    u_short *, struct tcphdr *, struct pf_state_peer *,
	    struct pf_state_peer *, int *);
@


1.28.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.28.2.7 2003/05/16 00:29:44 niklas Exp $ */
a41 4
#include <netinet/tcp_fsm.h>

#define	PF_TCPS_PROXY_SRC	((TCP_NSTATES)+0)
#define	PF_TCPS_PROXY_DST	((TCP_NSTATES)+1)
d45 1
a45 1
	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR, PF_SYNPROXY_DROP };
a383 1
	u_int8_t		 match_tag_not;
a386 1
#define PF_STATE_SYNPROXY	0x3
a1098 5

u_int16_t	pf_tagname2tag(char *);
void		pf_tag2tagname(u_int16_t, char *);
void		pf_tag_unref(u_int16_t);
int		pf_tag_packet(struct mbuf *, struct pf_tag *, int);
@


1.28.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a43 2
struct ip;

a47 1
enum	{ PF_LAN_EXT, PF_EXT_GWY, PF_ID };
d54 1
a54 1
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC, PF_DEBUG_NOISY };
d68 2
a69 2
	  PFTM_ADAPTIVE_START, PFTM_ADAPTIVE_END, PFTM_SRC_NODE,
	  PFTM_MAX, PFTM_PURGE, PFTM_UNTIL_PACKET };
d71 1
a71 1
enum	{ PF_LIMIT_STATES, PF_LIMIT_SRC_NODES, PF_LIMIT_FRAGS, PF_LIMIT_MAX };
d78 1
a78 1
#define PF_POOL_STICKYADDR	0x20
a98 6
#define PFI_AFLAG_NETWORK	0x01
#define PFI_AFLAG_BROADCAST	0x02
#define PFI_AFLAG_PEER		0x04
#define PFI_AFLAG_MODEMASK	0x07
#define PFI_AFLAG_NOALIAS	0x08

d109 1
a109 1
		struct pfi_dynaddr	*dyn;
a110 1
		int			 dyncnt;
a113 1
	u_int8_t		 iflags;	/* PFI_AFLAG_* */
d116 7
a122 15
#ifdef _KERNEL

struct pfi_dynaddr {
	struct pf_addr		 pfid_addr4;
	struct pf_addr		 pfid_mask4;
	struct pf_addr		 pfid_addr6;
	struct pf_addr		 pfid_mask6;
	struct pfr_ktable	*pfid_kt;
	struct pfi_kif		*pfid_kif;
	void			*pfid_hook_cookie;
	int			 pfid_net;	/* optional mask, or 128 */
	int			 pfid_acnt4;	/* address count, IPv4 */
	int			 pfid_acnt6;	/* address count, IPv6 */
	sa_family_t		 pfid_af;	/* rule address family */
	u_int8_t		 pfid_iflags;	/* PFI_AFLAG_* */
d129 2
d267 4
a270 1
		    !pfi_match_addr((aw)->p.dyn, (x), (af))) || \
d296 1
a296 1
	struct pf_addr_wrap		 addr;
d299 1
a299 1
	struct pfi_kif			*kif;
a319 1
	int			 tblidx;
a324 102

/* A packed Operating System description for fingerprinting */
typedef u_int32_t pf_osfp_t;
#define PF_OSFP_ANY	((pf_osfp_t)0)
#define PF_OSFP_UNKNOWN	((pf_osfp_t)-1)
#define PF_OSFP_NOMATCH	((pf_osfp_t)-2)

struct pf_osfp_entry {
	SLIST_ENTRY(pf_osfp_entry) fp_entry;
	pf_osfp_t		fp_os;
	int			fp_enflags;
#define PF_OSFP_EXPANDED	0x001		/* expanded entry */
#define PF_OSFP_GENERIC		0x002		/* generic signature */
#define PF_OSFP_NODETAIL	0x004		/* no p0f details */
#define PF_OSFP_LEN	32
	char			fp_class_nm[PF_OSFP_LEN];
	char			fp_version_nm[PF_OSFP_LEN];
	char			fp_subtype_nm[PF_OSFP_LEN];
};
#define PF_OSFP_ENTRY_EQ(a, b) \
    ((a)->fp_os == (b)->fp_os && \
    memcmp((a)->fp_class_nm, (b)->fp_class_nm, PF_OSFP_LEN) == 0 && \
    memcmp((a)->fp_version_nm, (b)->fp_version_nm, PF_OSFP_LEN) == 0 && \
    memcmp((a)->fp_subtype_nm, (b)->fp_subtype_nm, PF_OSFP_LEN) == 0)

/* handle pf_osfp_t packing */
#define _FP_RESERVED_BIT	1  /* For the special negative #defines */
#define _FP_UNUSED_BITS		1
#define _FP_CLASS_BITS		10 /* OS Class (Windows, Linux) */
#define _FP_VERSION_BITS	10 /* OS version (95, 98, NT, 2.4.54, 3.2) */
#define _FP_SUBTYPE_BITS	10 /* patch level (NT SP4, SP3, ECN patch) */
#define PF_OSFP_UNPACK(osfp, class, version, subtype) do { \
	(class) = ((osfp) >> (_FP_VERSION_BITS+_FP_SUBTYPE_BITS)) & \
	    ((1 << _FP_CLASS_BITS) - 1); \
	(version) = ((osfp) >> _FP_SUBTYPE_BITS) & \
	    ((1 << _FP_VERSION_BITS) - 1);\
	(subtype) = (osfp) & ((1 << _FP_SUBTYPE_BITS) - 1); \
} while(0)
#define PF_OSFP_PACK(osfp, class, version, subtype) do { \
	(osfp) = ((class) & ((1 << _FP_CLASS_BITS) - 1)) << (_FP_VERSION_BITS \
	    + _FP_SUBTYPE_BITS); \
	(osfp) |= ((version) & ((1 << _FP_VERSION_BITS) - 1)) << \
	    _FP_SUBTYPE_BITS; \
	(osfp) |= (subtype) & ((1 << _FP_SUBTYPE_BITS) - 1); \
} while(0)

/* the fingerprint of an OSes TCP SYN packet */
typedef u_int64_t	pf_tcpopts_t;
struct pf_os_fingerprint {
	SLIST_HEAD(pf_osfp_enlist, pf_osfp_entry) fp_oses; /* list of matches */
	pf_tcpopts_t		fp_tcpopts;	/* packed TCP options */
	u_int16_t		fp_wsize;	/* TCP window size */
	u_int16_t		fp_psize;	/* ip->ip_len */
	u_int16_t		fp_mss;		/* TCP MSS */
	u_int16_t		fp_flags;
#define PF_OSFP_WSIZE_MOD	0x0001		/* Window modulus */
#define PF_OSFP_WSIZE_DC	0x0002		/* Window don't care */
#define PF_OSFP_WSIZE_MSS	0x0004		/* Window multiple of MSS */
#define PF_OSFP_WSIZE_MTU	0x0008		/* Window multiple of MTU */
#define PF_OSFP_PSIZE_MOD	0x0010		/* packet size modulus */
#define PF_OSFP_PSIZE_DC	0x0020		/* packet size don't care */
#define PF_OSFP_WSCALE		0x0040		/* TCP window scaling */
#define PF_OSFP_WSCALE_MOD	0x0080		/* TCP window scale modulus */
#define PF_OSFP_WSCALE_DC	0x0100		/* TCP window scale dont-care */
#define PF_OSFP_MSS		0x0200		/* TCP MSS */
#define PF_OSFP_MSS_MOD		0x0400		/* TCP MSS modulus */
#define PF_OSFP_MSS_DC		0x0800		/* TCP MSS dont-care */
#define PF_OSFP_DF		0x1000		/* IPv4 don't fragment bit */
#define PF_OSFP_TS0		0x2000		/* Zero timestamp */
	u_int8_t		fp_optcnt;	/* TCP option count */
	u_int8_t		fp_wscale;	/* TCP window scaling */
	u_int8_t		fp_ttl;		/* IPv4 TTL */
#define PF_OSFP_MAXTTL_OFFSET	40
/* TCP options packing */
#define PF_OSFP_TCPOPT_NOP	0x0		/* TCP NOP option */
#define PF_OSFP_TCPOPT_WSCALE	0x1		/* TCP window scaling option */
#define PF_OSFP_TCPOPT_MSS	0x2		/* TCP max segment size opt */
#define PF_OSFP_TCPOPT_SACK	0x3		/* TCP SACK OK option */
#define PF_OSFP_TCPOPT_TS	0x4		/* TCP timestamp option */
#define PF_OSFP_TCPOPT_BITS	3		/* bits used by each option */
#define PF_OSFP_MAX_OPTS \
    (sizeof(((struct pf_os_fingerprint *)0)->fp_tcpopts) * 8) \
    / PF_OSFP_TCPOPT_BITS

	SLIST_ENTRY(pf_os_fingerprint)	fp_next;
};

struct pf_osfp_ioctl {
	struct pf_osfp_entry	fp_os;
	pf_tcpopts_t		fp_tcpopts;	/* packed TCP options */
	u_int16_t		fp_wsize;	/* TCP window size */
	u_int16_t		fp_psize;	/* ip->ip_len */
	u_int16_t		fp_mss;		/* TCP MSS */
	u_int16_t		fp_flags;
	u_int8_t		fp_optcnt;	/* TCP option count */
	u_int8_t		fp_wscale;	/* TCP window scaling */
	u_int8_t		fp_ttl;		/* IPv4 TTL */

	int			fp_getnum;	/* DIOCOSFPGET number */
};


d345 1
d363 1
a363 1
	struct pfi_kif		*kif;
a365 3
	pf_osfp_t		 os_fingerprint;

	u_int32_t		 timeout[PFTM_MAX];
a367 3
	u_int32_t		 src_nodes;
	u_int32_t		 max_src_nodes;
	u_int32_t		 max_src_states;
a388 1
	u_int8_t		 natpass;
a412 3
#define	PFRULE_NOSYNC		0x0010
#define PFRULE_SRCTRACK		0x0020  /* track source states */
#define PFRULE_RULESRCTRACK	0x0040  /* per rule */
a420 4
/* rule flags again */
#define PFRULE_IFBOUND		0x00010000	/* if-bound */
#define PFRULE_GRBOUND		0x00020000	/* group-bound */

a422 14
struct pf_src_node {
	RB_ENTRY(pf_src_node) entry;
	struct pf_addr	 addr;
	struct pf_addr	 raddr;
	union pf_rule_ptr rule;
	struct pfi_kif	*kif;
	u_int32_t	 bytes;
	u_int32_t	 packets;
	u_int32_t        states;
	u_int32_t	 creation;
	u_int32_t	 expire;
	sa_family_t	 af;
	u_int8_t	 ruletype;
};
a444 1
	u_int16_t	mss;		/* Maximum segment size option	*/
a448 10
	u_int64_t	 id;
	union {
		struct {
			RB_ENTRY(pf_state)	 entry_lan_ext;
			RB_ENTRY(pf_state)	 entry_ext_gwy;
			RB_ENTRY(pf_state)	 entry_id;
			struct pfi_kif		*kif;
		} s;
		char	 ifname[IFNAMSIZ];
	} u;
d458 1
a458 3
	struct pfi_kif	*rt_kif;
	struct pf_src_node	*src_node;
	struct pf_src_node	*nat_src_node;
d461 2
a462 3
	u_int32_t	 packets[2];
	u_int32_t	 bytes[2];
	u_int32_t        creatorid;
d469 10
a478 4
	u_int8_t	 sync_flags;
#define	PFSTATE_NOSYNC	 0x01
#define	PFSTATE_FROMSYNC 0x02
	u_int8_t	 pad;
a493 1
			int			 open;
a496 3
	u_int32_t		 tticket;
	int			 tables;
	int			 topen;
a504 1
	int			 tables;
a508 3
#define PF_RESERVED_ANCHOR	"_pf"
#define PF_INTERFACE_RULESET	"_if"

a593 2
	struct pf_ruleset	*pfrkt_rs;
	long			 pfrkt_larg;
a608 54
RB_HEAD(pf_state_tree_lan_ext, pf_state);
RB_PROTOTYPE(pf_state_tree_lan_ext, pf_state,
    u.s.entry_lan_ext, pf_state_compare_lan_ext);

RB_HEAD(pf_state_tree_ext_gwy, pf_state);
RB_PROTOTYPE(pf_state_tree_ext_gwy, pf_state,
    u.s.entry_ext_gwy, pf_state_compare_ext_gwy);

struct pfi_if {
	char				 pfif_name[IFNAMSIZ];
        u_int64_t			 pfif_packets[2][2][2];
        u_int64_t			 pfif_bytes[2][2][2];
	u_int64_t			 pfif_addcnt;
	u_int64_t			 pfif_delcnt;
	long				 pfif_tzero;
	int				 pfif_states;
	int				 pfif_rules;
	int				 pfif_flags;
};

TAILQ_HEAD(pfi_grouphead, pfi_kif);
TAILQ_HEAD(pfi_statehead, pfi_kif);
RB_HEAD(pfi_ifhead, pfi_kif);
struct pfi_kif {
	struct pfi_if			 pfik_if;
	RB_ENTRY(pfi_kif)		 pfik_tree;
	struct pf_state_tree_lan_ext	 pfik_lan_ext;
	struct pf_state_tree_ext_gwy	 pfik_ext_gwy;
	struct pfi_grouphead		 pfik_grouphead;
	TAILQ_ENTRY(pfi_kif)		 pfik_instances;
	TAILQ_ENTRY(pfi_kif)		 pfik_w_states;
	struct hook_desc_head		*pfik_ah_head;
	void				*pfik_ah_cookie;
	struct pfi_kif			*pfik_parent;
	struct ifnet			*pfik_ifp;
	int				 pfik_states;
	int				 pfik_rules;
};
#define pfik_name	pfik_if.pfif_name
#define pfik_packets	pfik_if.pfif_packets
#define pfik_bytes	pfik_if.pfif_bytes
#define pfik_tzero	pfik_if.pfif_tzero
#define pfik_flags	pfik_if.pfif_flags
#define pfik_addcnt	pfik_if.pfif_addcnt
#define pfik_delcnt	pfik_if.pfif_delcnt
#define pfik_states	pfik_if.pfif_states
#define pfik_rules	pfik_if.pfif_rules

#define PFI_IFLAG_GROUP		0x0001	/* group of interfaces */
#define PFI_IFLAG_INSTANCE	0x0002	/* single instance */
#define PFI_IFLAG_CLONABLE	0x0010	/* clonable group */
#define PFI_IFLAG_DYNAMIC	0x0020	/* dynamic group */
#define PFI_IFLAG_ATTACHED	0x0040	/* interface attached */

a619 3
	struct pf_addr   baddr;         /* address before translation */
	struct pf_addr   naddr;         /* address after translation */
	struct pf_rule	*nat_rule;	/* nat/rdr rule applied to packet */
a687 4
#define SCNT_SRC_NODE_SEARCH	0
#define SCNT_SRC_NODE_INSERT	1
#define SCNT_SRC_NODE_REMOVALS	2
#define SCNT_MAX		3
a705 1
	u_int64_t	scounters[SCNT_MAX];
a707 1
	u_int64_t	stateid;
a709 1
	u_int32_t	src_nodes;
a711 1
	u_int32_t	hostid;
d755 1
a755 1
	u_int16_t		 tbrsize;	/* tokenbucket regulator size */
d786 2
a856 10
struct pfioc_src_nodes {
	int	psn_len;
	union {
		caddr_t		 psu_buf;
		struct pf_src_node	*psu_src_nodes;
	} psn_u;
#define psn_buf		psn_u.psu_buf
#define psn_src_nodes	psn_u.psu_src_nodes
};

a896 13
#define PF_RULESET_ALTQ		(PF_RULESET_MAX)
#define PF_RULESET_TABLE	(PF_RULESET_MAX+1)
struct pfioc_trans {
	int		 size;	/* number of elements */
	int		 esize; /* size of each element in bytes */
	struct pfioc_trans_e {
		int		rs_num;
		char		anchor[PF_ANCHOR_NAME_SIZE];
		char		ruleset[PF_RULESET_NAME_SIZE];
		u_int32_t	ticket;
	}		*array;
};

d903 1
a903 5
#define PFR_FLAG_ALLRSETS	0x00000040
#define PFR_FLAG_ALLMASK	0x0000007F
#ifdef _KERNEL
#define PFR_FLAG_USERIOCTL	0x10000000
#endif
d915 1
a915 1
	u_int32_t		 pfrio_ticket;
a924 14
#define PFI_FLAG_GROUP		0x0001	/* gets groups of interfaces */
#define PFI_FLAG_INSTANCE	0x0002	/* gets single interfaces */
#define PFI_FLAG_ALLMASK	0x0003

struct pfioc_iface {
	char			 pfiio_name[IFNAMSIZ];
        void                    *pfiio_buffer;
        int                      pfiio_esize;
        int                      pfiio_size;
	int			 pfiio_nzero;
        int                      pfiio_flags;
};


a989 11
#define DIOCOSFPFLUSH	_IO('D', 78)
#define DIOCOSFPADD	_IOWR('D', 79, struct pf_osfp_ioctl)
#define DIOCOSFPGET	_IOWR('D', 80, struct pf_osfp_ioctl)
#define DIOCXBEGIN      _IOWR('D', 81, struct pfioc_trans)
#define DIOCXCOMMIT     _IOWR('D', 82, struct pfioc_trans)
#define DIOCXROLLBACK   _IOWR('D', 83, struct pfioc_trans)
#define DIOCGETSRCNODES	_IOWR('D', 84, struct pfioc_src_nodes)
#define DIOCCLRSRCNODES	_IO('D', 85)
#define DIOCSETHOSTID	_IOWR('D', 86, u_int32_t)
#define DIOCIGETIFACES	_IOWR('D', 87, struct pfioc_iface)
#define DIOCICLRISTATS  _IOWR('D', 88, struct pfioc_iface)
d992 3
a994 8
RB_HEAD(pf_src_tree, pf_src_node);
RB_PROTOTYPE(pf_src_tree, pf_src_node, entry, pf_src_compare);
extern struct pf_src_tree tree_src_tracking;

RB_HEAD(pf_state_tree_id, pf_state);
RB_PROTOTYPE(pf_state_tree_id, pf_state,
    entry_id, pf_state_compare_id);
extern struct pf_state_tree_id tree_id;
d996 2
a997 2
extern struct pf_anchorqueue		  pf_anchors;
extern struct pf_ruleset		  pf_main_ruleset;
d999 1
a999 1
extern struct pf_poolqueue		  pf_pools[2];
d1001 3
a1003 3
extern struct pf_altqqueue		  pf_altqs[2];
extern struct pf_palist			  pf_pabuf;
extern struct pfi_kif			**pfi_index2kif;
a1006 1
extern int			 altqs_inactive_open;
d1016 4
d1024 1
a1024 1
extern struct pool		 pf_src_tree_pl, pf_rule_pl;
a1027 1
extern void			 pf_purge_expired_src_nodes(void);
d1029 3
a1031 9
extern int			 pf_insert_state(struct pfi_kif *,
				    struct pf_state *);
extern int			 pf_insert_src_node(struct pf_src_node **,
				    struct pf_rule *, struct pf_addr *,
				    sa_family_t);
void				 pf_src_tree_remove_state(struct pf_state *);
extern struct pf_state		*pf_find_state_byid(struct pf_state *);
extern struct pf_state		*pf_find_state_all(struct pf_state *key,
				    u_int8_t tree, int *more);
d1033 1
a1033 8
extern struct pf_ruleset	*pf_find_ruleset(char *, char *);
extern struct pf_ruleset	*pf_find_or_create_ruleset(
				    char[PF_ANCHOR_NAME_SIZE],
				    char[PF_RULESET_NAME_SIZE]);
extern void			 pf_remove_if_empty_ruleset(
				    struct pf_ruleset *);

extern struct ifnet		*sync_ifp;
d1046 1
a1046 4
void	pf_poolmask(struct pf_addr *, struct pf_addr*,
	    struct pf_addr *, struct pf_addr *, u_int8_t);
void	pf_addr_inc(struct pf_addr *, sa_family_t);
#endif /* INET6 */
d1051 1
a1051 1
int	pflog_packet(struct pfi_kif *, struct mbuf *, sa_family_t, u_int8_t,
d1055 1
a1055 1
int	pf_match(u_int8_t, u_int32_t, u_int32_t, u_int32_t);
d1061 2
a1062 3
int	pf_normalize_ip(struct mbuf **, int, struct pfi_kif *, u_short *);
int	pf_normalize_ip6(struct mbuf **, int, struct pfi_kif *, u_short *);
int	pf_normalize_tcp(int, struct pfi_kif *, struct mbuf *, int, int, void *,
a1077 3
int	pfr_pool_get(struct pfr_ktable *, int *, struct pf_addr *,
	    struct pf_addr **, struct pf_addr **, sa_family_t);
void	pfr_dynaddr_update(struct pfr_ktable *, struct pfi_dynaddr *);
d1081 1
a1081 1
int	pfr_clr_tables(struct pfr_table *, int *, int);
d1084 2
a1085 2
int	pfr_get_tables(struct pfr_table *, struct pfr_table *, int *, int);
int	pfr_get_tstats(struct pfr_table *, struct pfr_tstats *, int *, int);
d1101 2
a1102 3
int	pfr_ina_begin(struct pfr_table *, u_int32_t *, int *, int);
int	pfr_ina_rollback(struct pfr_table *, u_int32_t, int *, int);
int	pfr_ina_commit(struct pfr_table *, u_int32_t, int *, int *, int);
d1104 1
a1104 22
	    int *, u_int32_t, int);

void		 pfi_initialize(void);
void		 pfi_attach_clone(struct if_clone *);
void		 pfi_attach_ifnet(struct ifnet *);
void		 pfi_detach_ifnet(struct ifnet *);
struct pfi_kif	*pfi_lookup_create(const char *);
int		 pfi_maybe_destroy(struct pfi_kif *);
struct pfi_kif	*pfi_attach_rule(const char *);
void		 pfi_detach_rule(struct pfi_kif *);
void		 pfi_attach_state(struct pfi_kif *);
void		 pfi_detach_state(struct pfi_kif *);
int		 pfi_dynaddr_setup(struct pf_addr_wrap *, sa_family_t);
void		 pfi_dynaddr_copyout(struct pf_addr_wrap *);
void		 pfi_dynaddr_remove(struct pf_addr_wrap *);
void		 pfi_fill_oldstatus(struct pf_status *);
int		 pfi_clr_istats(const char *, int *, int);
int		 pfi_get_ifaces(const char *, struct pfi_if *, int *, int);
int		 pfi_match_addr(struct pfi_dynaddr *, struct pf_addr *,
		    sa_family_t);

extern struct pfi_statehead	pfi_statehead;
a1120 17

/* The fingerprint functions can be linked into userland programs (tcpdump) */
int	pf_osfp_add(struct pf_osfp_ioctl *);
#ifdef _KERNEL
struct pf_osfp_enlist *
	pf_osfp_fingerprint(struct pf_pdesc *, struct mbuf *, int,
	    const struct tcphdr *);
#endif /* _KERNEL */
struct pf_osfp_enlist *
	pf_osfp_fingerprint_hdr(const struct ip *, const struct tcphdr *);
void	pf_osfp_flush(void);
int	pf_osfp_get(struct pf_osfp_ioctl *);
void	pf_osfp_initialize(void);
int	pf_osfp_match(struct pf_osfp_enlist *, pf_osfp_t);
struct pf_os_fingerprint *
	pf_osfp_validate(void);

@


1.28.2.10
log
@Merge with the trunk
@
text
@a35 1
#include <sys/param.h>
d72 1
a72 1
	  PFTM_TS_DIFF, PFTM_MAX, PFTM_PURGE, PFTM_UNTIL_PACKET };
a446 2
#define	PF_ANCHOR_NAME_SIZE	 64

d466 2
a493 1
	u_int32_t		 prob;
a527 2
	u_int8_t		 anchor_relative;
	u_int8_t		 anchor_wildcard;
d561 1
a561 1
	u_int32_t	 states;
a567 2
#define PFSNODE_HIWAT		10000	/* default source node table size */

a568 4
	struct timeval	pfss_last;	/* time received last packet	*/
	u_int32_t	pfss_tsecr;	/* last echoed timestamp	*/
	u_int32_t	pfss_tsval;	/* largest timestamp		*/
	u_int32_t	pfss_tsval0;	/* original timestamp		*/
d570 2
a571 6
#define PFSS_TIMESTAMP	0x0001		/* modulate timestamp		*/
#define PFSS_PAWS	0x0010		/* stricter PAWS checks		*/
#define PFSS_PAWS_IDLED	0x0020		/* was idle too long.  no PAWS	*/
#define PFSS_DATA_TS	0x0040		/* timestamp on data packets	*/
#define PFSS_DATA_NOTS	0x0080		/* no timestamp on data packets	*/
	u_int8_t	pfss_ttl;	/* stashed TTL			*/
d573 1
a573 1
	u_int32_t	pfss_ts_mod;	/* timestamp modulation		*/
a592 2
TAILQ_HEAD(pf_state_queue, pf_state);

a599 1
			TAILQ_ENTRY(pf_state)	 entry_updates;
a617 1
	u_int32_t	 pfsync_time;
d620 1
a620 1
	u_int32_t	 creatorid;
d638 3
d655 2
a656 2
RB_HEAD(pf_anchor_global, pf_anchor);
RB_HEAD(pf_anchor_node, pf_anchor);
d658 1
a658 4
	RB_ENTRY(pf_anchor)	 entry_global;
	RB_ENTRY(pf_anchor)	 entry_node;
	struct pf_anchor	*parent;
	struct pf_anchor_node	 children;
d660 2
a661 3
	char			 path[MAXPATHLEN];
	struct pf_ruleset	 ruleset;
	int			 refcnt;	/* anchor rules */
d663 2
a664 2
RB_PROTOTYPE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare);
RB_PROTOTYPE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare);
d667 1
d680 2
a681 1
	char			 pfrt_anchor[MAXPATHLEN];
d760 2
a761 2
#define pfrkt_anchor	pfrkt_t.pfrt_anchor
#define pfrkt_ruleset	pfrkt_t.pfrt_ruleset
d781 2
a782 2
	u_int64_t			 pfif_packets[2][2][2];
	u_int64_t			 pfif_bytes[2][2][2];
d836 2
a837 2
	struct pf_addr	 baddr;		/* address before translation */
	struct pf_addr	 naddr;		/* address after translation */
a840 2
	struct ether_header
			*eh;
a845 1
#define PFDESC_IP_REAS	0x0002		/* IP frags would've been reassembled */
d862 1
a862 2
#define PFRES_TS	6		/* Bad TCP Timestamp (RFC1323) */
#define PFRES_MAX	7		/* total+1 */
a870 1
	"bad-timestamp", \
d1030 2
a1031 1
	char			 anchor[MAXPATHLEN];
d1040 2
a1041 2
	char		 anchor[MAXPATHLEN];
	char		 anchor_call[MAXPATHLEN];
a1069 1
	char			psk_ifname[IFNAMSIZ];
d1121 5
d1128 2
a1129 2
	char		 path[MAXPATHLEN];
	char		 name[PF_ANCHOR_NAME_SIZE];
d1139 2
a1140 1
		char		anchor[MAXPATHLEN];
d1182 6
a1187 6
	char	 pfiio_name[IFNAMSIZ];
	void	*pfiio_buffer;
	int	 pfiio_esize;
	int	 pfiio_size;
	int	 pfiio_nzero;
	int	 pfiio_flags;
d1203 1
a1203 1
#define DIOCCLRSTATES	_IOWR('D', 18, struct pfioc_state_kill)
d1234 2
a1235 1
/* XXX cut 55 - 57 */
a1276 1
extern struct pf_state_queue state_updates;
d1278 1
a1278 1
extern struct pf_anchor_global		  pf_anchors;
d1300 3
a1308 1
extern void			 pf_purge_expired_state(struct pf_state *);
a1317 2
extern void			 pf_print_state(struct pf_state *);
extern void			 pf_print_flags(u_int8_t);
d1319 4
a1322 2
extern struct pf_ruleset	*pf_find_ruleset(const char *);
extern struct pf_ruleset	*pf_find_or_create_ruleset(const char *);
a1324 2
extern u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t,
				    u_int8_t);
a1334 1
int	pf_test_eh(int, struct ifnet *, struct mbuf **, struct ether_header *);
a1338 1
int	pf_test6_eh(int, struct ifnet *, struct mbuf **, struct ether_header *);
d1357 2
a1358 4
int	pf_normalize_ip(struct mbuf **, int, struct pfi_kif *, u_short *,
	    struct pf_pdesc *);
int	pf_normalize_ip6(struct mbuf **, int, struct pfi_kif *, u_short *,
	    struct pf_pdesc *);
d1365 2
a1366 2
	    u_short *, struct tcphdr *, struct pf_state *,
	    struct pf_state_peer *, struct pf_state_peer *, int *);
a1411 1
struct pfi_kif	*pfi_lookup_if(const char *);
a1431 3
u_int32_t	pf_qname2qid(char *);
void		pf_qid2qname(u_int32_t, char *);
void		pf_qid_unref(u_int32_t);
@


1.28.2.11
log
@sync to HEAD
@
text
@d278 1
a278 1
#define	PF_MISMATCHAW(aw, x, af, neg)				\
d290 1
a290 1
		(neg)						\
d306 1
a306 1
	u_int8_t		 neg;
@


1.27
log
@Add port ranges to the rdr directive. Connections can be redirected
to either a range of the same size, or a single port. Redirects
between ranges of different sizes are not supported. Eg:

rdr dc0 10.0.0.0/24 port 60000:61000 -> 127.0.0.1 port 65530:* proto udp
rdr xl0 0.0.0.0/0 port 6660:6669 -> 127.0.0.1 port 6667 proto tcp

This replaces the wildcard port patch (when port = 0), as it should no
longer be necessary. ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.26 2001/06/29 03:09:14 angelos Exp $ */
d40 1
a40 1
enum	{ PF_PASS=0, PF_DROP=1, PF_DROP_RST=2, PF_SCRUB=3 };
d59 3
d74 1
a74 1
	u_int16_t	 nr;
@


1.26
log
@Fix PF_SCRUB enumerator.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.25 2001/06/29 00:27:47 dhartmei Exp $ */
d122 1
d126 1
d128 4
@


1.25
log
@fix counter/reason array usage
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.24 2001/06/28 21:53:42 provos Exp $ */
d40 1
a40 1
enum	{ PF_PASS=0, PF_DROP=1, PF_DROP_RST=2, PF_SCRUB };
@


1.24
log
@first stab at packet normalization.  includes full ip reassembly.
okay dhartmei@@, dugsong@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.23 2001/06/27 10:31:51 kjell Exp $ */
d149 1
a149 1
#define FCNT_MAX		4
@


1.23
log
@add -z flag for zeroing statistics. -s status no longer resets anything
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.22 2001/06/27 04:29:21 deraadt Exp $ */
d40 1
a40 1
enum	{ PF_PASS=0, PF_DROP=1, PF_DROP_RST=2 };
d132 3
a134 1
#define PFRES_MAX	4		/* total+1 */
d141 2
d228 1
a228 1
int	pf_test(int, struct ifnet *, struct mbuf *);
@


1.22
log
@state counter changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.21 2001/06/26 22:56:03 dugsong Exp $ */
d220 1
@


1.21
log
@name comparison operators
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.20 2001/06/26 22:51:02 deraadt Exp $ */
d142 12
d156 3
a159 2
	u_int32_t	bytes[2];
	u_int32_t	packets[2][2];
a160 3
	u_int32_t	state_inserts;
	u_int32_t	state_removals;
	u_int32_t	state_searches;
@


1.20
log
@fix PFRES_MAX handling
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.19 2001/06/26 22:26:13 deraadt Exp $ */
d41 2
@


1.19
log
@array of counters indexed by reason codes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.18 2001/06/26 20:50:26 dhartmei Exp $ */
d130 1
a130 1
#define PFRES_MAX	3		/* total */
@


1.18
log
@add rule nr for Niels
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.17 2001/06/26 19:43:14 dhartmei Exp $ */
d125 15
d141 1
a207 6

/* Reasons code for passing/dropping a packet */
#define PFRES_MATCH	0		/* Explicit match of a rule */
#define PFRES_BADOFF	1		/* Bad offset for pull_hdr */
#define PFRES_FRAG	2		/* Dropping following fragment */
#define PFRES_SHORT	3		/* Dropping short packet */
@


1.17
log
@add rule pointer and log option to states
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.16 2001/06/26 19:01:55 provos Exp $ */
d69 1
@


1.16
log
@use reasons in pull_hdr, default log if pull_hdr fails. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.15 2001/06/26 18:17:53 deraadt Exp $ */
d90 1
d97 1
@


1.15
log
@no longer pass around **m
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.14 2001/06/26 15:33:01 provos Exp $ */
d192 3
@


1.14
log
@add a subreason to the link header to allow us to determine why a packet was
dropped or passed.  from discussion with theo and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.13 2001/06/26 04:17:11 frantzen Exp $ */
d195 1
a195 1
int	pf_test(int, struct ifnet *, struct mbuf **);
@


1.13
log
@Replicated TCP sequence tracking code in PF from Guido's IPF paper.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.12 2001/06/25 22:53:39 dhartmei Exp $ */
d190 2
@


1.12
log
@remaining lists converted to TAILQs
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.11 2001/06/25 22:08:03 dhartmei Exp $ */
d77 3
a79 2
	u_int32_t	seqlo;
	u_int32_t	seqhi;
@


1.11
log
@use TAILQ instead of homegrown list, other lists will follow
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.10 2001/06/25 17:17:03 dhartmei Exp $ */
d83 1
a83 1
	struct pf_state	*next;
d100 1
a100 1
	struct pf_nat	*next;
d111 1
a111 1
	struct pf_rdr	*next;
@


1.10
log
@revised ioctl interface, first getopt version of pfctl
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.9 2001/06/25 10:07:15 art Exp $ */
d37 1
d55 1
a55 1
	struct pf_rule	*next;
@


1.9
log
@Rename the rest of the structs to be consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.8 2001/06/25 09:31:07 art Exp $ */
d132 1
a132 1
 * ioctl parameter structure
d135 25
a159 4
struct pfioc {
	u_int32_t	 size;
	u_int16_t	 entries;
	void		*buffer;
d168 19
a186 10
#define DIOCSETRULES	_IOWR('D',  3, struct pfioc)
#define DIOCGETRULES	_IOWR('D',  4, struct pfioc)
#define DIOCSETNAT	_IOWR('D',  5, struct pfioc)
#define DIOCGETNAT	_IOWR('D',  6, struct pfioc)
#define DIOCSETRDR	_IOWR('D',  7, struct pfioc)
#define DIOCGETRDR	_IOWR('D',  8, struct pfioc)
#define DIOCCLRSTATES	_IO  ('D',  9)
#define DIOCGETSTATES	_IOWR('D', 10, struct pfioc)
#define DIOCSETSTATUSIF _IOWR('D', 11, struct pfioc)
#define DIOCGETSTATUS	_IOWR('D', 12, struct pfioc)
@


1.8
log
@More renaming.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.7 2001/06/25 09:23:32 art Exp $ */
d41 1
a41 1
struct rule_addr {
d52 2
a53 2
	struct rule_addr src;
	struct rule_addr dst;
d70 1
a70 1
struct state_host {
d75 1
a75 1
struct state_peer {
d83 5
a87 5
	struct state_host lan;
	struct state_host gwy;
	struct state_host ext;
	struct state_peer src;
	struct state_peer dst;
@


1.7
log
@Avoid common names. Needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.6 2001/06/25 00:02:54 dhartmei Exp $ */
d96 1
a96 1
struct nat {
d99 1
a99 1
	struct nat	*next;
d107 1
a107 1
struct rdr {
d110 1
a110 1
	struct rdr	*next;
@


1.6
log
@use only ioctl return values found in errno.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.5 2001/06/24 23:44:00 art Exp $ */
d49 1
a49 1
struct rule {
d54 1
a54 1
	struct rule	*next;
d81 2
a82 2
struct state {
	struct state	*next;
d120 1
a120 1
struct status {
@


1.5
log
@rename ioctlbuffer to pfioc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.4 2001/06/24 21:50:29 deraadt Exp $ */
a156 14

/*
 * ioctl errors
 */

enum error_msg {
	NO_ERROR=0,
	ERROR_INVALID_OP=100,
	ERROR_ALREADY_RUNNING,
	ERROR_NOT_RUNNING,
	ERROR_INVALID_PARAMETERS,
	ERROR_MALLOC,
	MAX_ERROR_NUM
};
@


1.4
log
@pack structures better; dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.3 2001/06/24 21:32:17 dhartmei Exp $ */
d135 1
a135 1
struct ioctlbuffer {
d147 6
a152 6
#define DIOCSETRULES	_IOWR('D',  3, struct ioctlbuffer)
#define DIOCGETRULES	_IOWR('D',  4, struct ioctlbuffer)
#define DIOCSETNAT	_IOWR('D',  5, struct ioctlbuffer)
#define DIOCGETNAT	_IOWR('D',  6, struct ioctlbuffer)
#define DIOCSETRDR	_IOWR('D',  7, struct ioctlbuffer)
#define DIOCGETRDR	_IOWR('D',  8, struct ioctlbuffer)
d154 3
a156 3
#define DIOCGETSTATES	_IOWR('D', 10, struct ioctlbuffer)
#define DIOCSETSTATUSIF _IOWR('D', 11, struct ioctlbuffer)
#define DIOCGETSTATUS	_IOWR('D', 12, struct ioctlbuffer)
@


1.3
log
@REGENTS? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.2 2001/06/24 21:24:13 kjell Exp $ */
d41 8
d50 6
d60 1
a61 2
	char		 ifname[16];
	struct ifnet	*ifp;
d63 16
a78 13
	struct {
		u_int8_t	not;
		u_int32_t	addr,
				mask;
		u_int8_t	port_op;
		u_int16_t	port[2];
	}		 src,
			 dst;
	u_int8_t	 type,
			 code;
	u_int8_t	 flags,
			 flagset;
	struct rule	*next;
d82 10
a93 17
	struct host {
		u_int32_t	addr;
		u_int16_t	port;
	}		 lan,
			 gwy,
			 ext;
	struct peer {
		u_int32_t	seqlo,
				seqhi;
		u_int8_t	state;
	}		 src,
			 dst;
	u_int32_t	 creation,
			 expire;
	u_int32_t	 packets,
			 bytes;
	struct state	*next;
d97 1
a97 1
	char		 ifname[16];
d99 4
a104 4
	u_int32_t	 saddr,
			 smask,
			 daddr;
	struct nat	*next;
d108 1
a108 1
	char		 ifname[16];
d110 6
a117 6
	u_int32_t	 daddr,
			 dmask,
			 raddr;
	u_int16_t	 dport,
			 rport;
	struct rdr	*next;
d121 1
a121 1
	u_int8_t	running;
d124 4
a127 4
	u_int32_t	states,
			state_inserts,
			state_removals,
			state_searches;
d175 1
a175 1
int pf_test (int, struct ifnet *, struct mbuf **);
@


1.2
log
@PACKETFILTER_H now PFVAR_H. thanks smart
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.1 2001/06/24 19:48:58 kjell Exp $ */
d22 1
a22 1
 * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
@


1.1
log
@Initial import of pf, an all-new ipf-compatable packet filter.
Insane amounts of work done my dhartmei. Great work!
@
text
@d1 1
a1 1
/*	$OpenBSD: packetfilter.h,v 1.20 2001/06/23 19:55:00 dhartmei Exp $ */
d33 2
a34 2
#ifndef _NETINET_PACKETFILTER_H_
#define _NETINET_PACKETFILTER_H_
d170 1
a170 1
#endif /* _NET_PACKETFILTER_H_ */
@

