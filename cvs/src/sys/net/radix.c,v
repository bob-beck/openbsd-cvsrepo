head	1.56;
access;
symbols
	OPENBSD_6_1_BASE:1.56
	OPENBSD_6_0:1.52.0.6
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.30.0.6
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.4
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.2
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.4
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.21.0.8
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.18
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.16
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.56
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.55;
commitid	6c6qq5OdS4VVnyVM;

1.55
date	2016.11.14.08.54.19;	author mpi;	state Exp;
branches;
next	1.54;
commitid	SPJDraPFwXOZQLLT;

1.54
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.53;
commitid	RlO92XR575sygHqm;

1.53
date	2016.08.30.23.29.39;	author dlg;	state Exp;
branches;
next	1.52;
commitid	c5SjbZ19I7gBvQZB;

1.52
date	2015.11.06.18.07.57;	author mpi;	state Exp;
branches;
next	1.51;
commitid	VPXyKUac3MuBmK1w;

1.51
date	2015.11.04.09.50.21;	author mpi;	state Exp;
branches;
next	1.50;
commitid	vubJzb8H8Cr58s7n;

1.50
date	2015.10.08.08.41.58;	author mpi;	state Exp;
branches;
next	1.49;
commitid	OesGi9XmSKvtapL6;

1.49
date	2015.10.07.10.50.35;	author mpi;	state Exp;
branches;
next	1.48;
commitid	hPrd2a6fiZdlN2yP;

1.48
date	2015.09.04.08.43.39;	author mpi;	state Exp;
branches;
next	1.47;
commitid	qAevExm24QrBjVNL;

1.47
date	2015.08.30.10.39.16;	author mpi;	state Exp;
branches;
next	1.46;
commitid	avqdJydG8T8nvZhe;

1.46
date	2015.07.16.18.17.27;	author claudio;	state Exp;
branches;
next	1.45;
commitid	VvtF6H2REt7RsEKf;

1.45
date	2015.07.07.09.39.28;	author mpi;	state Exp;
branches;
next	1.44;
commitid	41wPKSuAp1Sz9eG9;

1.44
date	2015.03.04.15.53.29;	author claudio;	state Exp;
branches;
next	1.43;
commitid	HcUm5dlQngW9TTDu;

1.43
date	2014.12.02.18.11.56;	author tedu;	state Exp;
branches;
next	1.42;
commitid	R6VIBSqPh5FMhwGK;

1.42
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.41;
commitid	B4dZSbxas1X1IpXI;

1.41
date	2014.07.01.09.58.40;	author mpi;	state Exp;
branches;
next	1.40;
commitid	meWy2cEZOdubGAmJ;

1.40
date	2014.05.27.19.38.15;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2014.01.22.10.17.59;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2014.01.21.23.42.44;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2014.01.20.22.42.06;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.19.09.52.25;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.19.04.04.36;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2014.01.10.14.29.08;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.01.09.21.57.51;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2013.12.12.14.43.38;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.20.16.17.36;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2012.07.10.15.53.34;	author blambert;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.22.13.05.29;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.22.17.02.04;	author mpf;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.28.18.50.37;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2009.01.06.21.40.47;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.29.21.24.19;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.21.18.01.30;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.09.07.39.31;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.07.05.14.21;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.18.11.47.45;	author pascoe;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.06.17.37.28;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.15.16.40.09;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.25.20.02.39;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.25.02.48.03;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.25.01.38.10;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.25.00.31.40;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.25.00.30.02;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.19.06.57.17;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.27.00.33.34;	author henric;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.20.21.21.15;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.21.14.34.47;	author itojun;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.07.06.08.27.06;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.17.20.30.34;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	96.09.05.08.42.32;	author mickey;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	96.04.21.22.28.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.21.07.14;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches;
next	;

1.4.16.1
date	2001.05.14.22.40.04;	author niklas;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.4.16.3;

1.4.16.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.4.16.4;

1.4.16.4
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.4.16.5;

1.4.16.5
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.4.16.6;

1.4.16.6
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.4.16.7;

1.4.16.7
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.56
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: radix.c,v 1.55 2016/11/14 08:54:19 mpi Exp $	*/
/*	$NetBSD: radix.c,v 1.20 2003/08/07 16:32:56 agc Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)radix.c	8.6 (Berkeley) 10/17/95
 */

/*
 * Routines to build and maintain radix trees for routing lookups.
 */

#ifndef _KERNEL
#include "kern_compat.h"
#else
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/pool.h>
#endif

#include <net/radix.h>

static unsigned int max_keylen;
struct radix_node_head *mask_rnhead;
static char *addmask_key;
static char normal_chars[] = {0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, -1};
static char *rn_zeros, *rn_ones;

struct pool rtmask_pool;	/* pool for radix_mask structures */

#define rn_masktop (mask_rnhead->rnh_treetop)

static inline int rn_satisfies_leaf(char *, struct radix_node *, int);
static inline int rn_lexobetter(void *, void *);
static inline struct radix_mask *rn_new_radix_mask(struct radix_node *,
    struct radix_mask *);

struct radix_node *rn_insert(void *, struct radix_node_head *, int *,
    struct radix_node [2]);
struct radix_node *rn_newpair(void *, int, struct radix_node[2]);

static inline struct radix_node *rn_search(void *, struct radix_node *);
struct radix_node *rn_search_m(void *, struct radix_node *, void *);
int rn_add_dupedkey(struct radix_node *, struct radix_node_head *,
    struct radix_node [2], u_int8_t);
void rn_fixup_nodes(struct radix_node *);
static inline struct radix_node *rn_lift_node(struct radix_node *);
void rn_add_radix_mask(struct radix_node *, int);
int rn_del_radix_mask(struct radix_node *);
static inline void rn_swap_nodes(struct radix_node *, struct radix_node *);

/*
 * The data structure for the keys is a radix tree with one way
 * branching removed.  The index rn_b at an internal node n represents a bit
 * position to be tested.  The tree is arranged so that all descendants
 * of a node n have keys whose bits all agree up to position rn_b - 1.
 * (We say the index of n is rn_b.)
 *
 * There is at least one descendant which has a one bit at position rn_b,
 * and at least one with a zero there.
 *
 * A route is determined by a pair of key and mask.  We require that the
 * bit-wise logical and of the key and mask to be the key.
 * We define the index of a route to associated with the mask to be
 * the first bit number in the mask where 0 occurs (with bit number 0
 * representing the highest order bit).
 *
 * We say a mask is normal if every bit is 0, past the index of the mask.
 * If a node n has a descendant (k, m) with index(m) == index(n) == rn_b,
 * and m is a normal mask, then the route applies to every descendant of n.
 * If the index(m) < rn_b, this implies the trailing last few bits of k
 * before bit b are all 0, (and hence consequently true of every descendant
 * of n), so the route applies to all descendants of the node as well.
 *
 * Similar logic shows that a non-normal mask m such that
 * index(m) <= index(n) could potentially apply to many children of n.
 * Thus, for each non-host route, we attach its mask to a list at an internal
 * node as high in the tree as we can go.
 *
 * The present version of the code makes use of normal routes in short-
 * circuiting an explicit mask and compare operation when testing whether
 * a key satisfies a normal route, and also in remembering the unique leaf
 * that governs a subtree.
 */

static inline struct radix_node *
rn_search(void *v_arg, struct radix_node *head)
{
	struct radix_node *x = head;
	caddr_t v = v_arg;

	while (x->rn_b >= 0) {
		if (x->rn_bmask & v[x->rn_off])
			x = x->rn_r;
		else
			x = x->rn_l;
	}
	return (x);
}

struct radix_node *
rn_search_m(void *v_arg, struct radix_node *head, void *m_arg)
{
	struct radix_node *x = head;
	caddr_t v = v_arg;
	caddr_t m = m_arg;

	while (x->rn_b >= 0) {
		if ((x->rn_bmask & m[x->rn_off]) &&
		    (x->rn_bmask & v[x->rn_off]))
			x = x->rn_r;
		else
			x = x->rn_l;
	}
	return x;
}

int
rn_refines(void *m_arg, void *n_arg)
{
	caddr_t m = m_arg;
	caddr_t n = n_arg;
	caddr_t lim, lim2;
	int longer;
	int masks_are_equal = 1;

	lim2 = lim = n + *(u_char *)n;
	longer = (*(u_char *)n++) - (int)(*(u_char *)m++);
	if (longer > 0)
		lim -= longer;
	while (n < lim) {
		if (*n & ~(*m))
			return 0;
		if (*n++ != *m++)
			masks_are_equal = 0;
	}
	while (n < lim2)
		if (*n++)
			return 0;
	if (masks_are_equal && (longer < 0))
		for (lim2 = m - longer; m < lim2; )
			if (*m++)
				return 1;
	return (!masks_are_equal);
}

/* return a perfect match if m_arg is set, else do a regular rn_match */
struct radix_node *
rn_lookup(void *v_arg, void *m_arg, struct radix_node_head *head)
{
	struct radix_node *x, *tm;
	caddr_t netmask = 0;

	if (m_arg) {
		tm = rn_addmask(m_arg, 1, head->rnh_treetop->rn_off);
		if (tm == NULL)
			return (NULL);
		netmask = tm->rn_key;
	}
	x = rn_match(v_arg, head);
	if (x && netmask) {
		while (x && x->rn_mask != netmask)
			x = x->rn_dupedkey;
	}
	/* Never return internal nodes to the upper layer. */
	if (x && (x->rn_flags & RNF_ROOT))
		return (NULL);
	return x;
}

static inline int
rn_satisfies_leaf(char *trial, struct radix_node *leaf, int skip)
{
	char *cp = trial;
	char *cp2 = leaf->rn_key;
	char *cp3 = leaf->rn_mask;
	char *cplim;
	int length;

	length = min(*(u_char *)cp, *(u_char *)cp2);
	if (cp3 == NULL)
		cp3 = rn_ones;
	else
		length = min(length, *(u_char *)cp3);
	cplim = cp + length;
	cp += skip;
	cp2 += skip;
	cp3 += skip;
	while (cp < cplim) {
		if ((*cp ^ *cp2) & *cp3)
			return 0;
		cp++, cp2++, cp3++;
	}
	return 1;
}

struct radix_node *
rn_match(void *v_arg, struct radix_node_head *head)
{
	caddr_t v = v_arg;
	caddr_t cp, cp2, cplim;
	struct radix_node *top = head->rnh_treetop;
	struct radix_node *saved_t, *t;
	int off = top->rn_off;
	int vlen, matched_off;
	int test, b, rn_b;

	t = rn_search(v, top);
	/*
	 * See if we match exactly as a host destination
	 * or at least learn how many bits match, for normal mask finesse.
	 *
	 * It doesn't hurt us to limit how many bytes to check
	 * to the length of the mask, since if it matches we had a genuine
	 * match and the leaf we have is the most specific one anyway;
	 * if it didn't match with a shorter length it would fail
	 * with a long one.  This wins big for class B&C netmasks which
	 * are probably the most common case...
	 */
	if (t->rn_mask)
		vlen = *(u_char *)t->rn_mask;
	else
		vlen = *(u_char *)v;
	cp = v + off;
	cp2 = t->rn_key + off;
	cplim = v + vlen;
	for (; cp < cplim; cp++, cp2++)
		if (*cp != *cp2)
			goto on1;
	/*
	 * This extra grot is in case we are explicitly asked
	 * to look up the default.  Ugh!
	 */
	if (t->rn_flags & RNF_ROOT)
		t = t->rn_dupedkey;

	KASSERT(t == NULL || (t->rn_flags & RNF_ROOT) == 0);
	return t;
on1:
	test = (*cp ^ *cp2) & 0xff; /* find first bit that differs */
	for (b = 7; (test >>= 1) > 0;)
		b--;
	matched_off = cp - v;
	b += matched_off << 3;
	rn_b = -1 - b;
	/*
	 * If there is a host route in a duped-key chain, it will be first.
	 */
	saved_t = t;
	if (t->rn_mask == NULL)
		t = t->rn_dupedkey;
	for (; t; t = t->rn_dupedkey)
		/*
		 * Even if we don't match exactly as a host,
		 * we may match if the leaf we wound up at is
		 * a route to a net.
		 */
		if (t->rn_flags & RNF_NORMAL) {
			if (rn_b <= t->rn_b) {
				KASSERT((t->rn_flags & RNF_ROOT) == 0);
				return t;
			}
		} else if (rn_satisfies_leaf(v, t, matched_off)) {
			KASSERT((t->rn_flags & RNF_ROOT) == 0);
			return t;
		}
	t = saved_t;
	/* start searching up the tree */
	do {
		struct radix_mask *m;
		t = t->rn_p;
		m = t->rn_mklist;
		while (m) {
			/*
			 * If non-contiguous masks ever become important
			 * we can restore the masking and open coding of
			 * the search and satisfaction test and put the
			 * calculation of "off" back before the "do".
			 */
			if (m->rm_flags & RNF_NORMAL) {
				if (rn_b <= m->rm_b) {
					KASSERT((m->rm_leaf->rn_flags &
					    RNF_ROOT) == 0);
					return (m->rm_leaf);
				}
			} else {
				struct radix_node *x;
				off = min(t->rn_off, matched_off);
				x = rn_search_m(v, t, m->rm_mask);
				while (x && x->rn_mask != m->rm_mask)
					x = x->rn_dupedkey;
				if (x && rn_satisfies_leaf(v, x, off)) {
					KASSERT((x->rn_flags & RNF_ROOT) == 0);
					return x;
				}
			}
			m = m->rm_mklist;
		}
	} while (t != top);
	return NULL;
}

struct radix_node *
rn_newpair(void *v, int b, struct radix_node nodes[2])
{
	struct radix_node *tt = nodes, *t = nodes + 1;
	t->rn_b = b;
	t->rn_bmask = 0x80 >> (b & 7);
	t->rn_l = tt;
	t->rn_off = b >> 3;
	tt->rn_b = -1;
	tt->rn_key = v;
	tt->rn_p = t;
	tt->rn_flags = t->rn_flags = RNF_ACTIVE;
	return t;
}

struct radix_node *
rn_insert(void *v_arg, struct radix_node_head *head,
    int *dupentry, struct radix_node nodes[2])
{
	caddr_t v = v_arg;
	struct radix_node *top = head->rnh_treetop;
	struct radix_node *t, *tt;
	int off = top->rn_off;
	int b;

	t = rn_search(v_arg, top);
	/*
	 * Find first bit at which v and t->rn_key differ
	 */
    {
	caddr_t cp, cp2, cplim;
	int vlen, cmp_res;

	vlen =  *(u_char *)v;
	cp = v + off;
	cp2 = t->rn_key + off;
	cplim = v + vlen;

	while (cp < cplim)
		if (*cp2++ != *cp++)
			goto on1;
	*dupentry = 1;
	return t;
on1:
	*dupentry = 0;
	cmp_res = (cp[-1] ^ cp2[-1]) & 0xff;
	for (b = (cp - v) << 3; cmp_res; b--)
		cmp_res >>= 1;
    }
    {
	struct radix_node *p, *x = top;
	caddr_t cp = v;
	do {
		p = x;
		if (cp[x->rn_off] & x->rn_bmask)
			x = x->rn_r;
		else
			x = x->rn_l;
	} while (b > (unsigned int) x->rn_b); /* x->rn_b < b && x->rn_b >= 0 */
	t = rn_newpair(v_arg, b, nodes);
	tt = t->rn_l;
	if ((cp[p->rn_off] & p->rn_bmask) == 0)
		p->rn_l = t;
	else
		p->rn_r = t;
	x->rn_p = t;
	t->rn_p = p; /* frees x, p as temp vars below */
	if ((cp[t->rn_off] & t->rn_bmask) == 0) {
		t->rn_r = x;
	} else {
		t->rn_r = tt;
		t->rn_l = x;
	}
    }
	return (tt);
}

struct radix_node *
rn_addmask(void *n_arg, int search, int skip)
{
	caddr_t netmask = n_arg;
	struct radix_node *tm, *saved_tm;
	caddr_t cp, cplim;
	int b = 0, mlen, j;
	int maskduplicated, m0, isnormal;
	static int last_zeroed = 0;

	if ((mlen = *(u_char *)netmask) > max_keylen)
		mlen = max_keylen;
	if (skip == 0)
		skip = 1;
	if (mlen <= skip)
		return (mask_rnhead->rnh_nodes);	/* rn_zero root node */
	if (skip > 1)
		memcpy(addmask_key + 1, rn_ones + 1, skip - 1);
	if ((m0 = mlen) > skip)
		memcpy(addmask_key + skip, netmask + skip, mlen - skip);
	/*
	 * Trim trailing zeroes.
	 */
	for (cp = addmask_key + mlen; (cp > addmask_key) && cp[-1] == 0;)
		cp--;
	mlen = cp - addmask_key;
	if (mlen <= skip) {
		if (m0 >= last_zeroed)
			last_zeroed = mlen;
		return (mask_rnhead->rnh_nodes);
	}
	if (m0 < last_zeroed)
		memset(addmask_key + m0, 0, last_zeroed - m0);
	*addmask_key = last_zeroed = mlen;
	tm = rn_search(addmask_key, rn_masktop);
	if (memcmp(addmask_key, tm->rn_key, mlen) != 0)
		tm = NULL;
	if (tm || search)
		return (tm);
	tm = malloc(max_keylen + 2 * sizeof (*tm), M_RTABLE, M_NOWAIT | M_ZERO);
	if (tm == NULL)
		return (0);
	saved_tm = tm;
	netmask = cp = (caddr_t)(tm + 2);
	memcpy(cp, addmask_key, mlen);
	tm = rn_insert(cp, mask_rnhead, &maskduplicated, tm);
	if (maskduplicated) {
		log(LOG_ERR, "rn_addmask: mask impossibly already in tree\n");
		free(saved_tm, M_RTABLE, 0);
		return (tm);
	}
	/*
	 * Calculate index of mask, and check for normalcy.
	 */
	cplim = netmask + mlen;
	isnormal = 1;
	for (cp = netmask + skip; (cp < cplim) && *(u_char *)cp == 0xff;)
		cp++;
	if (cp != cplim) {
		for (j = 0x80; (j & *cp) != 0; j >>= 1)
			b++;
		if (*cp != normal_chars[b] || cp != (cplim - 1))
			isnormal = 0;
	}
	b += (cp - netmask) << 3;
	tm->rn_b = -1 - b;
	if (isnormal)
		tm->rn_flags |= RNF_NORMAL;
	return (tm);
}

/* rn_lexobetter: return a arbitrary ordering for non-contiguous masks */
static inline int
rn_lexobetter(void *m_arg, void *n_arg)
{
	u_char *mp = m_arg, *np = n_arg;

	/*
	 * Longer masks might not really be lexicographically better,
	 * but longer masks always have precedence since they must be checked
	 * first. The netmasks were normalized before calling this function and
	 * don't have unneeded trailing zeros.
	 */
	if (*mp > *np)
		return 1;
	if (*mp < *np)
		return 0;
	/*
	 * Must return the first difference between the masks
	 * to ensure deterministic sorting.
	 */
	return (memcmp(mp, np, *mp) > 0);
}

static inline struct radix_mask *
rn_new_radix_mask(struct radix_node *tt, struct radix_mask *next)
{
	struct radix_mask *m;

	m = pool_get(&rtmask_pool, PR_NOWAIT | PR_ZERO);
	if (m == NULL) {
		log(LOG_ERR, "Mask for route not entered\n");
		return (0);
	}
	m->rm_b = tt->rn_b;
	m->rm_flags = tt->rn_flags;
	if (tt->rn_flags & RNF_NORMAL)
		m->rm_leaf = tt;
	else
		m->rm_mask = tt->rn_mask;
	m->rm_mklist = next;
	tt->rn_mklist = m;
	return m;
}

/*
 * Find the point where the rn_mklist needs to be changed.
 */
static inline struct radix_node *
rn_lift_node(struct radix_node *t)
{
	struct radix_node *x = t;
	int b = -1 - t->rn_b;

	/* rewind possible dupedkey list to head */
	while (t->rn_b < 0)
		t = t->rn_p;

	/* can't lift node above head of dupedkey list, give up */
	if (b > t->rn_b)
		return (NULL);

	do {
		x = t;
		t = t->rn_p;
	} while (b <= t->rn_b && x != t);

	return (x);
}

void
rn_add_radix_mask(struct radix_node *tt, int keyduplicated)
{
	caddr_t netmask, mmask;
	struct radix_node *x;
	struct radix_mask *m, **mp;
	int b_leaf = tt->rn_b;

	/* Add new route to highest possible ancestor's list */
	if (tt->rn_mask == NULL)
		return; /* can't lift at all */
	x = rn_lift_node(tt);
	if (x == NULL)
		return; /* didn't lift either */

	/*
	 * Search through routes associated with node to
	 * insert new route according to index.
	 * Need same criteria as when sorting dupedkeys to avoid
	 * double loop on deletion.
	 */
	netmask = tt->rn_mask;
	for (mp = &x->rn_mklist; (m = *mp); mp = &m->rm_mklist) {
		if (m->rm_b < b_leaf)
			continue;
		if (m->rm_b > b_leaf)
			break;
		if (m->rm_flags & RNF_NORMAL) {
			if (keyduplicated) {
				if (m->rm_leaf->rn_p == tt)
					/* new route is better */
					m->rm_leaf = tt;
#ifdef DIAGNOSTIC
				else {
					struct radix_node *t;

					for (t = m->rm_leaf;
					    t && t->rn_mklist == m;
					    t = t->rn_dupedkey)
						if (t == tt)
							break;
					if (t == NULL) {
						log(LOG_ERR, "Non-unique "
						    "normal route on dupedkey, "
						    "mask not entered\n");
						return;
					}
				}
#endif
				m->rm_refs++;
				tt->rn_mklist = m;
				return;
			} else if (tt->rn_flags & RNF_NORMAL) {
				log(LOG_ERR, "Non-unique normal route,"
				    " mask not entered\n");
				return;
			}
			mmask = m->rm_leaf->rn_mask;
		} else
			mmask = m->rm_mask;
		if (mmask == netmask) {
			m->rm_refs++;
			tt->rn_mklist = m;
			return;
		}
		if (rn_refines(netmask, mmask) || rn_lexobetter(netmask, mmask))
			break;
	}
	*mp = rn_new_radix_mask(tt, *mp);
}

int
rn_add_dupedkey(struct radix_node *saved_tt, struct radix_node_head *head,
    struct radix_node *tt, u_int8_t prio)
{
	caddr_t netmask = tt->rn_mask;
	struct radix_node *x = saved_tt, *xp;
	int before = -1;
	int b_leaf = 0;

	if (netmask)
		b_leaf = tt->rn_b;

	for (xp = x; x; xp = x, x = x->rn_dupedkey) {
		if (x->rn_mask == netmask)
			return (-1);
		if (netmask == NULL ||
		    (x->rn_mask &&
		     ((b_leaf < x->rn_b) || /* index(netmask) > node */
		       rn_refines(netmask, x->rn_mask) ||
		       rn_lexobetter(netmask, x->rn_mask))))
			break;
	}
	/*
	 * If the mask is not duplicated, we wouldn't
	 * find it among possible duplicate key entries
	 * anyway, so the above test doesn't hurt.
	 *
	 * We sort the masks for a duplicated key the same way as
	 * in a masklist -- most specific to least specific.
	 * This may require the unfortunate nuisance of relocating
	 * the head of the list.
	 *
	 * We also reverse, or doubly link the list through the
	 * parent pointer.
	 */

	if ((x == saved_tt && before) || before == 1)
		before = 1;
	else
		before = 0;
	rn_link_dupedkey(tt, xp, before);

	return (0);
}

/*
 * Insert tt after x or in place of x if before is true.
 */
void
rn_link_dupedkey(struct radix_node *tt, struct radix_node *x, int before)
{
	if (before) {
		if (x->rn_p->rn_b > 0) {
			/* link in at head of list */
			tt->rn_dupedkey = x;
			tt->rn_flags = x->rn_flags;
			tt->rn_p = x->rn_p;
			x->rn_p = tt;
			if (tt->rn_p->rn_l == x)
				tt->rn_p->rn_l = tt;
			else
				tt->rn_p->rn_r = tt;
		} else {
			tt->rn_dupedkey = x;
			x->rn_p->rn_dupedkey = tt;
			tt->rn_p = x->rn_p;
			x->rn_p = tt;
		}
	} else {
		tt->rn_dupedkey = x->rn_dupedkey;
		x->rn_dupedkey = tt;
		tt->rn_p = x;
		if (tt->rn_dupedkey)
			tt->rn_dupedkey->rn_p = tt;
	}
}

/*
 * This function ensures that routes are properly promoted upwards.
 * It adjusts the rn_mklist of the parent node to make sure overlapping
 * routes can be found.
 *
 * There are two cases:
 * - leaf nodes with possible rn_dupedkey list
 * - internal nodes with maybe their own mklist
 * If the mask of the route is bigger than the current branch bit then
 * a rn_mklist entrie needs to be made.
 */
void
rn_fixup_nodes(struct radix_node *tt)
{
	struct radix_node *tp, *x;
	struct radix_mask *m, **mp;
	int b_leaf;

	tp = tt->rn_p;
	if (tp->rn_r == tt)
		x = tp->rn_l;
	else
		x = tp->rn_r;

	b_leaf = -1 - tp->rn_b;
	if (x->rn_b < 0) {	/* x is a leaf node */
		struct	radix_node *xx = NULL;

		for (mp = &tp->rn_mklist; x; xx = x, x = x->rn_dupedkey) {
			if (xx && xx->rn_mklist && xx->rn_mask == x->rn_mask &&
			    x->rn_mklist == 0) {
				/* multipath route */
				x->rn_mklist = xx->rn_mklist;
				x->rn_mklist->rm_refs++;
			}
			if (x->rn_mask && (x->rn_b >= b_leaf) &&
			    x->rn_mklist == 0) {
				*mp = m = rn_new_radix_mask(x, 0);
				if (m)
					mp = &m->rm_mklist;
			}
		}
	} else if (x->rn_mklist) {	/* x is an internal node */
		/*
		 * Skip over masks whose index is > that of new node
		 */
		for (mp = &x->rn_mklist; (m = *mp); mp = &m->rm_mklist)
			if (m->rm_b >= b_leaf)
				break;
		tp->rn_mklist = m;
		*mp = 0;
	}
}

struct radix_node *
rn_addroute(void *v_arg, void *n_arg, struct radix_node_head *head,
    struct radix_node treenodes[2], u_int8_t prio)
{
	caddr_t v = v_arg;
	struct radix_node *top = head->rnh_treetop;
	struct radix_node *tt, *saved_tt, *tm = NULL;
	int keyduplicated;

	/*
	 * In dealing with non-contiguous masks, there may be
	 * many different routes which have the same mask.
	 * We will find it useful to have a unique pointer to
	 * the mask to speed avoiding duplicate references at
	 * nodes and possibly save time in calculating indices.
	 */
	if (n_arg)  {
		if ((tm = rn_addmask(n_arg, 0, top->rn_off)) == 0)
			return (0);
	}

	tt = rn_insert(v, head, &keyduplicated, treenodes);

	if (keyduplicated) {
		saved_tt = tt;
		tt = treenodes;

		tt->rn_key = v_arg;
		tt->rn_b = -1;
		tt->rn_flags = RNF_ACTIVE;
	}

	/* Put mask into the node. */
	if (tm) {
		tt->rn_mask = tm->rn_key;
		tt->rn_b = tm->rn_b;
		tt->rn_flags |= tm->rn_flags & RNF_NORMAL;
	}

	/* Either insert into dupedkey list or as a leaf node.  */
	if (keyduplicated) {
		if (rn_add_dupedkey(saved_tt, head, tt, prio))
			return (NULL);
	} else {
		rn_fixup_nodes(tt);
	}

	/* finally insert a radix_mask element if needed */
	rn_add_radix_mask(tt, keyduplicated);
	return (tt);
}

/*
 * Cleanup mask list, tt points to route that needs to be cleaned
 */
int
rn_del_radix_mask(struct radix_node *tt)
{
	struct radix_node *x;
	struct radix_mask *m, *saved_m, **mp;

	/*
	 * Cleanup mask list from possible references to this route.
	 */
	saved_m = m = tt->rn_mklist;
	if (tt->rn_mask == NULL || m == NULL)
		return (0);

	if (tt->rn_flags & RNF_NORMAL) {
		if (m->rm_leaf != tt && m->rm_refs == 0) {
			log(LOG_ERR, "rn_delete: inconsistent normal "
			    "annotation\n");
			return (-1);
		}
		if (m->rm_leaf != tt) {
			if (--m->rm_refs >= 0)
				return (0);
			else
				log(LOG_ERR, "rn_delete: "
				    "inconsistent mklist refcount\n");
		}
		/*
		 * If we end up here tt should be m->rm_leaf and therefor
		 * tt should be the head of a multipath chain.
		 * If this is not the case the table is no longer consistent.
		 */
		if (m->rm_refs > 0) {
			if (tt->rn_dupedkey == NULL ||
			    tt->rn_dupedkey->rn_mklist != m) {
				log(LOG_ERR, "rn_delete: inconsistent "
				    "dupedkey list\n");
				return (-1);
			}
			m->rm_leaf = tt->rn_dupedkey;
			--m->rm_refs;
			return (0);
		}
		/* else tt is last and only route */
	} else {
		if (m->rm_mask != tt->rn_mask) {
			log(LOG_ERR, "rn_delete: inconsistent annotation\n");
			return (0);
		}
		if (--m->rm_refs >= 0)
			return (0);
	}

	/*
	 * No other references hold to the radix_mask remove it from
	 * the tree.
	 */
	x = rn_lift_node(tt);
	if (x == NULL)
		return (0);	/* Wasn't lifted at all */

	/* Finally eliminate the radix_mask from the tree */
	for (mp = &x->rn_mklist; (m = *mp); mp = &m->rm_mklist)
		if (m == saved_m) {
			*mp = m->rm_mklist;
			pool_put(&rtmask_pool, m);
			break;
		}

	if (m == NULL) {
		log(LOG_ERR, "rn_delete: couldn't find our annotation\n");
		if (tt->rn_flags & RNF_NORMAL)
			return (-1); /* Dangling ref to us */
	}

	return (0);
}

/* swap two internal nodes and fixup the parent and child pointers */
static inline void
rn_swap_nodes(struct radix_node *from, struct radix_node *to)
{
	*to = *from;
	if (from->rn_p->rn_l == from)
		from->rn_p->rn_l = to;
	else
		from->rn_p->rn_r = to;

	to->rn_l->rn_p = to;
	to->rn_r->rn_p = to;
}

struct radix_node *
rn_delete(void *v_arg, void *n_arg, struct radix_node_head *head,
    struct radix_node *rn)
{
	caddr_t v = v_arg;
	caddr_t netmask = n_arg;
	struct radix_node *top = head->rnh_treetop;
	struct radix_node *tt, *tp, *pp, *x;
	struct radix_node *dupedkey_tt, *saved_tt;
	int off = top->rn_off;
	int vlen;

	vlen =  *(u_char *)v;

	/*
	 * Implement a lookup similar to rn_lookup but we need to save
	 * the radix leaf node (where th rn_dupedkey list starts) so
	 * it is not possible to use rn_lookup.
	 */
	tt = rn_search(v, top);
	/* make sure the key is a perfect match */
	if (memcmp(v + off, tt->rn_key + off, vlen - off))
		return (NULL);

	/*
	 * Here, tt is the deletion target, and
	 * saved_tt is the head of the dupedkey chain.
	 * dupedkey_tt will point to the start of the multipath chain.
	 */
	saved_tt = tt;

	/*
	 * make tt point to the start of the rn_dupedkey list of multipath
	 * routes.
	 */
	if (netmask) {
		struct radix_node *tm;

		if ((tm = rn_addmask(netmask, 1, off)) == NULL)
			return (NULL);
		netmask = tm->rn_key;
		while (tt->rn_mask != netmask)
			if ((tt = tt->rn_dupedkey) == NULL)
				return (NULL);
	}

	/* save start of multi path chain for later use */
	dupedkey_tt = tt;

	KASSERT((tt->rn_flags & RNF_ROOT) == 0);

	/* remove possible radix_mask */
	if (rn_del_radix_mask(tt))
		return (NULL);

	/*
	 * Finally eliminate us from tree
	 */
	tp = tt->rn_p;
	if (saved_tt->rn_dupedkey) {
		if (tt == saved_tt) {
			x = saved_tt->rn_dupedkey;
			x->rn_p = tp;
			if (tp->rn_l == tt)
				tp->rn_l = x;
			else
				tp->rn_r = x;
			/* head changed adjust dupedkey pointer */
			dupedkey_tt = x;
		} else {
			x = saved_tt;
			/* dupedkey will change so adjust pointer */
			if (dupedkey_tt == tt)
				dupedkey_tt = tt->rn_dupedkey;
			tp->rn_dupedkey = tt->rn_dupedkey;
			if (tt->rn_dupedkey)
				tt->rn_dupedkey->rn_p = tp;
		}

		/*
		 * We may be holding an active internal node in the tree.
		 */
		if  (tt[1].rn_flags & RNF_ACTIVE)
			rn_swap_nodes(&tt[1], &x[1]);

		/* over and out */
		goto out;
	}

	/* non-rn_dupedkey case, remove tt and tp node from the tree */
	if (tp->rn_l == tt)
		x = tp->rn_r;
	else
		x = tp->rn_l;
	pp = tp->rn_p;
	if (pp->rn_r == tp)
		pp->rn_r = x;
	else
		pp->rn_l = x;
	x->rn_p = pp;

	/*
	 * Demote routes attached to us (actually on the internal parent node).
	 */
	if (tp->rn_mklist) {
		struct radix_mask *m, **mp;
		if (x->rn_b >= 0) {
			for (mp = &x->rn_mklist; (m = *mp);)
				mp = &m->rm_mklist;
			*mp = tp->rn_mklist;
		} else {
			/* If there are any key,mask pairs in a sibling
			   duped-key chain, some subset will appear sorted
			   in the same order attached to our mklist */
			for (m = tp->rn_mklist; m && x; x = x->rn_dupedkey)
				if (m == x->rn_mklist) {
					struct radix_mask *mm = m->rm_mklist;
					x->rn_mklist = 0;
					if (--(m->rm_refs) < 0)
						pool_put(&rtmask_pool, m);
					else if (m->rm_flags & RNF_NORMAL)
						/*
						 * don't progress because this
						 * a multipath route. Next
						 * route will use the same m.
						 */
						mm = m;
					m = mm;
				}
			if (m)
				log(LOG_ERR, "%s %p at %p\n",
				    "rn_delete: Orphaned Mask", m, x);
		}
	}

	/*
	 * We may be holding an active internal node in the tree.
	 * If so swap our internal node (t) with the parent node (tp)
	 * since that one was just removed from the tree.
	 */
	if (tp != &tt[1])
		rn_swap_nodes(&tt[1], tp);

	/* no rn_dupedkey list so no need to fixup multipath chains */
out:
	tt[0].rn_flags &= ~RNF_ACTIVE;
	tt[1].rn_flags &= ~RNF_ACTIVE;
	return (tt);
}

int
rn_walktree(struct radix_node_head *h, int (*f)(struct radix_node *, void *,
    u_int), void *w)
{
	int error;
	struct radix_node *base, *next;
	struct radix_node *rn = h->rnh_treetop;
	/*
	 * This gets complicated because we may delete the node
	 * while applying the function f to it, so we need to calculate
	 * the successor node in advance.
	 */
	/* First time through node, go left */
	while (rn->rn_b >= 0)
		rn = rn->rn_l;
	for (;;) {
		base = rn;
		/* If at right child go back up, otherwise, go right */
		while (rn->rn_p->rn_r == rn && (rn->rn_flags & RNF_ROOT) == 0)
			rn = rn->rn_p;
		/* Find the next *leaf* since next node might vanish, too */
		for (rn = rn->rn_p->rn_r; rn->rn_b >= 0;)
			rn = rn->rn_l;
		next = rn;
		/* Process leaves */
		while ((rn = base) != NULL) {
			base = rn->rn_dupedkey;
			if (!(rn->rn_flags & RNF_ROOT) &&
			    (error = (*f)(rn, w, h->rnh_rtableid)))
				return (error);
		}
		rn = next;
		if (rn->rn_flags & RNF_ROOT)
			return (0);
	}
	/* NOTREACHED */
}

int
rn_initmask(void)
{
	if (mask_rnhead != NULL)
		return (0);

	KASSERT(max_keylen > 0);

	mask_rnhead = malloc(sizeof(*mask_rnhead), M_RTABLE, M_NOWAIT);
	if (mask_rnhead == NULL)
		return (1);

	rn_inithead0(mask_rnhead, 0);
	return (0);
}

int
rn_inithead(void **head, int off)
{
	struct radix_node_head *rnh;

	if (*head != NULL)
		return (1);

	if (rn_initmask())
		panic("failed to initialize the mask tree");

	rnh = malloc(sizeof(*rnh), M_RTABLE, M_NOWAIT);
	if (rnh == NULL)
		return (0);
	*head = rnh;
	rn_inithead0(rnh, off);
	return (1);
}

int
rn_inithead0(struct radix_node_head *rnh, int offset)
{
	struct radix_node *t, *tt, *ttt;
	int off = offset * NBBY;

	memset(rnh, 0, sizeof(*rnh));
	t = rn_newpair(rn_zeros, off, rnh->rnh_nodes);
	ttt = rnh->rnh_nodes + 2;
	t->rn_r = ttt;
	t->rn_p = t;
	tt = t->rn_l;
	tt->rn_flags = t->rn_flags = RNF_ROOT | RNF_ACTIVE;
	tt->rn_b = -1 - off;
	*ttt = *tt;
	ttt->rn_key = rn_ones;
	rnh->rnh_treetop = t;
	return (1);
}

/*
 * rn_init() can be called multiple time with a different key length
 * as long as not radix tree head has been allocated.
 */
void
rn_init(unsigned int keylen)
{
	char *cp, *cplim;

	if (max_keylen == 0) {
		pool_init(&rtmask_pool, sizeof(struct radix_mask), 0,
		    IPL_SOFTNET, 0, "rtmask", NULL);
	}

	if (keylen <= max_keylen)
		return;

	KASSERT(mask_rnhead == NULL);

	free(rn_zeros, M_RTABLE, 3 * max_keylen);
	rn_zeros = mallocarray(3, keylen, M_RTABLE, M_NOWAIT | M_ZERO);
	if (rn_zeros == NULL)
		panic("cannot initialize a radix tree without memory");
	max_keylen = keylen;

	rn_ones = cp = rn_zeros + max_keylen;
	addmask_key = cplim = rn_ones + max_keylen;
	while (cp < cplim)
		*cp++ = -1;
}
@


1.55
log
@Remove radix_mpath dragons.

This code insn't used since ART is the default.

ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.54 2016/09/15 02:00:18 dlg Exp $	*/
d95 1
a95 1
 * 
d102 1
a102 1
 * 
d106 1
a106 1
 * node as high in the tree as we can go. 
d827 1
a827 1
			else 
@


1.54
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.53 2016/08/30 23:29:39 dlg Exp $	*/
a50 10
#if defined(ART) && !defined(SMALL_KERNEL)
#define SMALL_KERNEL
#endif

#ifndef SMALL_KERNEL
#include <sys/socket.h>
#include <net/route.h>
#include <net/radix_mpath.h>
#endif

a624 3
#ifndef SMALL_KERNEL
	struct radix_node *dupedkey_tt = NULL;
#endif
a631 40
#ifndef SMALL_KERNEL
		/* permit multipath, if enabled for the family */
		if (rn_mpath_capable(head) && netmask == x->rn_mask) {
			int mid;
			/*
			 * Try to insert the new node in the middle
			 * of the list of any preexisting multipaths,
			 * to reduce the number of path disruptions
			 * that occur as a result of an insertion,
			 * per RFC2992.
			 * Additionally keep the list sorted by route
			 * priority.
			 */
			before = 0;

			dupedkey_tt = x;
			x = rn_mpath_prio(x, prio);
			if (((struct rtentry *)x)->rt_priority !=
			    prio) {
				/*
				 * rn_mpath_prio returns the previous
				 * element if no element with the 
				 * requested priority exists. It could
				 * be that the previous element comes
				 * with a bigger priority.
				 */
				if (((struct rtentry *)x)->rt_priority > prio)
					before = 1;
				xp = x;
				break;
			}

			mid = rn_mpath_active_count(x) / 2;
			do {
				xp = x;
				x = rn_mpath_next(x, RMP_MODE_BYPRIO);
			} while (x && --mid > 0);
			break;
		}
#endif
a660 8

#ifndef SMALL_KERNEL
	/* adjust the flags of the possible multipath chain */
	if (!dupedkey_tt)
		dupedkey_tt = tt;
	if (rn_mpath_capable(head))
		rn_mpath_adj_mpflag(dupedkey_tt, prio);
#endif
a794 4
#ifndef SMALL_KERNEL
		if (rn_mpath_capable(head))
			rn_mpath_adj_mpflag(tt, prio);
#endif
a944 6
#ifndef SMALL_KERNEL
	/* if we got a hint use the hint from now on */
	if (rn)
		tt = rn;
#endif

a980 6
#ifndef SMALL_KERNEL
		/* adjust the flags of the multipath chain */
		if (rn_mpath_capable(head))
			rn_mpath_adj_mpflag(dupedkey_tt,
			    ((struct rtentry *)tt)->rt_priority);
#endif
@


1.53
log
@pool_setipl

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.52 2015/11/06 18:07:57 mpi Exp $	*/
d1226 2
a1227 3
		pool_init(&rtmask_pool, sizeof(struct radix_mask), 0, 0, 0,
		    "rtmask", NULL);
		pool_setipl(&rtmask_pool, IPL_SOFTNET);
@


1.52
log
@Do not compile net/radix_mpath.c in ART-enabled kernels.

In such kernels multipath routing support is independant from the data
structure used to perform the binary lookup.  Is is implemented as a
singly-listed list of route entries. This is possible because a "struct
rtentry" is no longer mapped 1:1 to a node in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.51 2015/11/04 09:50:21 mpi Exp $	*/
d1228 1
@


1.51
log
@Some tweaks to build the rtable API and backends in userland.

Needed by the regression tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.50 2015/10/08 08:41:58 mpi Exp $	*/
d50 4
@


1.50
log
@Use the radix API directly and get rid of the function pointers.  There
is no point in keeping an unused level of abstraction.

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.49 2015/10/07 10:50:35 mpi Exp $	*/
d39 3
d47 2
@


1.49
log
@Initialize the routing table before domains.

The routing table is not an optional component of the network stack
and initializing it inside the "routing domain" requires some ugly
introspection in the domain interface.

This put the rtable* layer at the same level of the if* level.  These
two subsystem are organized around the two global data structure used
in the network stack:

- the global &ifnet list, to be used in process context only, and
- the routing table which can be read in interrupt context.

This change makes the rtable_* layer domain-aware and extends the
"struct domain" such that INET, INET6 and MPLS can specify the length
of the binary key used in lookups.  This allows us to keep, or move
towards, AF-free route and rtable layers.

While here stop the madness and pass the size of the maximum key length
in *byte* to rn_inithead0().

ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.48 2015/09/04 08:43:39 mpi Exp $	*/
a1202 5
	rnh->rnh_addaddr = rn_addroute;
	rnh->rnh_deladdr = rn_delete;
	rnh->rnh_matchaddr = rn_match;
	rnh->rnh_lookup = rn_lookup;
	rnh->rnh_walktree = rn_walktree;
@


1.48
log
@Make every subsystem using a radix tree call rn_init() and pass the
length of the key as argument.

This way every consumer of the radix tree has a chance to explicitly
initialize the shared data structures and no longer rely on another
subsystem to do the initialization.

As a bonus ``dom_maxrtkey'' is no longer used an die.

ART kernels should now be fully usable because pf(4) and IPSEC properly
initialized the radix tree.

ok chris@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.47 2015/08/30 10:39:16 mpi Exp $	*/
d1188 1
a1188 1
rn_inithead0(struct radix_node_head *rnh, int off)
d1191 1
@


1.47
log
@Use a global table for domains instead of building a list at run time.

As a side effect there's no need to run if_attachdomain() after the
list of domains has been built.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.46 2015/07/16 18:17:27 claudio Exp $	*/
a41 1
#include <sys/domain.h>
d52 1
a52 1
int	max_keylen;
d1153 16
d1173 1
a1173 1
	if (*head)
d1175 4
d1183 2
a1184 1
	return rn_inithead0(rnh, off);
d1211 4
d1216 1
a1216 1
rn_init(void)
a1218 2
	struct domain *dom;
	int i;
d1220 6
a1225 1
	if (rn_zeros != NULL)
d1228 4
a1231 9
	pool_init(&rtmask_pool, sizeof(struct radix_mask), 0, 0, 0, "rtmask",
	    NULL);
	for (i = 0; (dom = domains[i]) != NULL; i++) {
		if (dom->dom_maxrtkey > max_keylen)
			max_keylen = dom->dom_maxrtkey;
	}
	if (max_keylen == 0)
		panic("radix functions require max_keylen be set");
	rn_zeros = mallocarray(3, max_keylen, M_RTABLE, M_NOWAIT | M_ZERO);
d1233 3
a1235 1
		panic("rn_init");
a1239 2
	if (rn_inithead((void *)&mask_rnhead, 0) == 0)
		panic("rn_init 2");
@


1.46
log
@Fix rn_match and there for the expoerted lookup functions in radix.c
to never return the internal RNF_ROOT nodes. This removes the checks
in the callee to verify that not an RNF_ROOT node was returned.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.45 2015/07/07 09:39:28 mpi Exp $	*/
d1196 4
d1203 1
a1203 1
	for (dom = domains; dom; dom = dom->dom_next)
a1205 4
	if (max_keylen == 0) {
		log(LOG_ERR,
		    "rn_init: radix functions require max_keylen be set\n");
		return;
d1207 2
@


1.45
log
@Do not return internal nodes to the upper layer in rn_lookup().

The limit between the radix layer and the route layer is somewhat
vague, if it exists at all.  This changes prevent rtrequest1(9) to
find and delete the root node (RNF_ROOT) when trying to delete a
non-existing default route:

# route delete 0.0.0.0
delete host 0.0.0.0
# route delete 0.0.0.0
route: writing to routing socket: No such process
delete host 0.0.0.0: not in table

Historically rn_delete() was a no-op when called with an internal
node as argument.  But there's no reason to manipulate such node.
In a better world rn_match() would contain such check, but let's
change the perfect-match function for the moment as this fixes a
bug and many dragons are lurking in there.

Fix a regression introduced by the big refactoring of r1.40 and
reported by tobias@@.

ok tobias@@, claudio@@, pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.44 2015/03/04 15:53:29 claudio Exp $	*/
d264 1
a264 1
	if ((t->rn_flags & RNF_ROOT) && t->rn_dupedkey)
d266 2
d289 2
a290 3
			if (rn_b <= t->rn_b)
				return t;
		} else if (rn_satisfies_leaf(v, t, matched_off))
d292 5
d311 3
a313 1
				if (rn_b <= m->rm_b)
d315 1
d322 2
a323 1
				if (x && rn_satisfies_leaf(v, x, off))
d325 1
d975 1
a975 1
		return (0);
d992 1
a992 1
			return (0);
d996 1
a996 1
				return (0);
d1012 1
a1012 1
		return (0);
@


1.44
log
@Make sure that rn_mpath_adj_mpflag() is called with the correct pointer
to the multipath chain when removing routes. This fixes the sbin/route
testcases 17-19 and fixes an annoying opsfd bug because of routes
wrongly marked as multipath ones.
OK deraadt, mpi, sthen, benno, phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.43 2014/12/02 18:11:56 tedu Exp $	*/
d195 3
@


1.43
log
@replace some malloc multiplies with mallocarry. ok deraadt henning
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.42 2014/07/12 18:44:22 tedu Exp $	*/
d1012 2
d1016 3
@


1.42
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.41 2014/07/01 09:58:40 mpi Exp $	*/
d1188 1
a1188 1
	rn_zeros = malloc(3 * max_keylen, M_RTABLE, M_NOWAIT | M_ZERO);
@


1.41
log
@KASSERT() the correct node if a hint is passed to rn_delete().

Fix a panic when trying to remove a route with the magical 0.0.0.0
destination.

looks ok to claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.40 2014/05/27 19:38:15 claudio Exp $	*/
d444 1
a444 1
		free(saved_tm, M_RTABLE);
@


1.40
log
@Big refactoring of the radix code (mainly rn_addroute but also part
of rn_delete was changed). The mpath code gets a much better
rn_mpath_next() function that allows looping through the dupedkey list
based on prio, any or only active routes. This solves the issues seen
with failed deletes of down routes.
Commit this now so that it gets tested. Both sthen@@ and blambert@@ agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.39 2014/01/22 10:17:59 claudio Exp $	*/
a984 2
	KASSERT((tt->rn_flags & RNF_ROOT) == 0);

d990 1
a990 1
	if (rn) 
d993 2
@


1.39
log
@Kill the RN_DEBUG code it is broken since rev 1.1 and not worth fixing.
OK mpi@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.38 2014/01/21 23:42:44 claudio Exp $	*/
d74 7
d177 1
d212 5
a216 2
	cplim = cp + length; cp3 += skip; cp2 += skip;
	for (cp += skip; cp < cplim; cp++, cp2++, cp3++)
d219 2
d411 1
a411 1
		return (mask_rnhead->rnh_nodes);
d511 5
a515 3
struct radix_node *
rn_addroute(void *v_arg, void *n_arg, struct radix_node_head *head,
    struct radix_node treenodes[2], u_int8_t prio)
d517 6
a522 9
	caddr_t v = v_arg;
	caddr_t netmask = n_arg;
	struct radix_node *top = head->rnh_treetop;
	struct radix_node *t, *tt, *tm = NULL, *x;
	struct radix_node *saved_tt;
	short b = 0, b_leaf = 0;
	int keyduplicated, prioinv = -1;
	caddr_t mmask;
	struct radix_mask *m, **mp;
d524 3
a526 14
	/*
	 * In dealing with non-contiguous masks, there may be
	 * many different routes which have the same mask.
	 * We will find it useful to have a unique pointer to
	 * the mask to speed avoiding duplicate references at
	 * nodes and possibly save time in calculating indices.
	 */
	if (netmask)  {
		if ((tm = rn_addmask(netmask, 0, top->rn_off)) == 0)
			return (0);
		b_leaf = tm->rn_b;
		b = -1 - tm->rn_b;
		netmask = tm->rn_key;
	}
d528 4
a531 1
	saved_tt = tt = rn_insert(v, head, &keyduplicated, treenodes);
d533 2
a534 35
	/*
	 * Deal with duplicated keys: attach node to previous instance
	 */
	if (keyduplicated) {
		for (t = tt; tt; t = tt, tt = tt->rn_dupedkey) {
#ifndef SMALL_KERNEL
			/* permit multipath, if enabled for the family */
			if (rn_mpath_capable(head) && netmask == tt->rn_mask) {
				int mid;
				/*
				 * Try to insert the new node in the middle
				 * of the list of any preexisting multipaths,
				 * to reduce the number of path disruptions
				 * that occur as a result of an insertion,
				 * per RFC2992.
				 * Additionally keep the list sorted by route
				 * priority.
				 */
				prioinv = 0;
				tt = rn_mpath_prio(tt, prio);
				if (((struct rtentry *)tt)->rt_priority !=
				    prio) {
					/*
					 * rn_mpath_prio returns the previous
					 * element if no element with the 
					 * requested priority exists. It could
					 * be that the previous element comes
					 * with a bigger priority.
					 */
					if (((struct rtentry *)tt)->
					    rt_priority > prio)
						prioinv = 1;
					t = tt;
					break;
				}
d536 7
a542 60
				mid = rn_mpath_active_count(tt) / 2;
				do {
					t = tt;
					tt = rn_mpath_next(tt, 0);
				} while (tt && --mid > 0);
				break;
			}
#endif
			if (tt->rn_mask == netmask)
				return (0);
			if (netmask == 0 ||
			    (tt->rn_mask &&
			     ((b_leaf < tt->rn_b) || /* index(netmask) > node */
			       rn_refines(netmask, tt->rn_mask) ||
			       rn_lexobetter(netmask, tt->rn_mask))))
				break;
		}
		/*
		 * If the mask is not duplicated, we wouldn't
		 * find it among possible duplicate key entries
		 * anyway, so the above test doesn't hurt.
		 *
		 * We sort the masks for a duplicated key the same way as
		 * in a masklist -- most specific to least specific.
		 * This may require the unfortunate nuisance of relocating
		 * the head of the list.
		 *
		 * We also reverse, or doubly link the list through the
		 * parent pointer.
		 */
		if (tt == saved_tt && prioinv) {
			struct	radix_node *xx;
			/* link in at head of list */
			(tt = treenodes)->rn_dupedkey = t;
			tt->rn_flags = t->rn_flags;
			tt->rn_p = xx = t->rn_p;
			t->rn_p = tt;
			if (xx->rn_l == t)
				xx->rn_l = tt;
			else
				xx->rn_r = tt;
			saved_tt = tt;
		} else if (prioinv == 1) {
			(tt = treenodes)->rn_dupedkey = t;
			if (t->rn_p == NULL)
				panic("rn_addroute: t->rn_p is NULL");
			t->rn_p->rn_dupedkey = tt;
			tt->rn_p = t->rn_p;
			t->rn_p = tt;
		} else {
			(tt = treenodes)->rn_dupedkey = t->rn_dupedkey;
			t->rn_dupedkey = tt;
			tt->rn_p = t;
			if (tt->rn_dupedkey)
				tt->rn_dupedkey->rn_p = tt;
		}
		tt->rn_key = (caddr_t) v;
		tt->rn_b = -1;
		tt->rn_flags = RNF_ACTIVE;
	}
a543 43
	/*
	 * Put mask in tree.
	 */
	if (netmask) {
		tt->rn_mask = netmask;
		tt->rn_b = tm->rn_b;
		tt->rn_flags |= tm->rn_flags & RNF_NORMAL;
	}
	t = saved_tt->rn_p;
	if (keyduplicated)
		goto on2;
	b_leaf = -1 - t->rn_b;
	if (t->rn_r == saved_tt)
		x = t->rn_l;
	else
		x = t->rn_r;
	/* Promote general routes from below */
	if (x->rn_b < 0) {
	    struct	radix_node *xx = NULL;
	    for (mp = &t->rn_mklist; x; xx = x, x = x->rn_dupedkey) {
		if (xx && xx->rn_mklist && xx->rn_mask == x->rn_mask &&
		    x->rn_mklist == 0) {
			/* multipath route, bump refcount on first mklist */
			x->rn_mklist = xx->rn_mklist;
			x->rn_mklist->rm_refs++;
		}
		if (x->rn_mask && (x->rn_b >= b_leaf) && x->rn_mklist == 0) {
			*mp = m = rn_new_radix_mask(x, 0);
			if (m)
				mp = &m->rm_mklist;
		}
	    }
	} else if (x->rn_mklist) {
		/*
		 * Skip over masks whose index is > that of new node
		 */
		for (mp = &x->rn_mklist; (m = *mp); mp = &m->rm_mklist)
			if (m->rm_b >= b_leaf)
				break;
		t->rn_mklist = m;
		*mp = 0;
	}
on2:
d545 6
a550 7
	if ((netmask == 0) || (b > t->rn_b ))
		return tt; /* can't lift at all */
	b_leaf = tt->rn_b;
	do {
		x = t;
		t = t->rn_p;
	} while (b <= t->rn_b && x != top);
d557 1
a563 1
			mmask = m->rm_leaf->rn_mask;
d570 5
a574 2
					for (t = m->rm_leaf; t;
						t = t->rn_dupedkey)
d581 1
a581 1
						return tt;
d587 1
a587 1
				return tt;
d591 1
a591 1
				return tt;
d593 1
d599 1
a599 1
			return tt;
d605 182
a786 1
	return tt;
d790 2
a791 2
rn_delete(void *v_arg, void *netmask_arg, struct radix_node_head *head,
    struct radix_node *rn)
a793 1
	caddr_t netmask = netmask_arg;
d795 2
a796 5
	struct radix_node *t, *p, *tm, *x, *tt;
	struct radix_mask *m, *saved_m, **mp;
	struct radix_node *dupedkey, *saved_tt;
	int off = top->rn_off;
	int b, vlen;
a797 5
	vlen =  *(u_char *)v;
	tt = rn_search(v, top);
	saved_tt = tt;
	if (memcmp(v + off, tt->rn_key + off, vlen - off))
		return (0);
d799 5
a803 1
	 * Delete our route from mask lists.
d805 2
a806 2
	if (netmask) {
		if ((tm = rn_addmask(netmask, 1, off)) == NULL)
a807 4
		netmask = tm->rn_key;
		while (tt->rn_mask != netmask)
			if ((tt = tt->rn_dupedkey) == NULL)
				return (0);
d809 25
d835 3
a837 4
	if (rn) {
		while (tt != rn)
			if ((tt = tt->rn_dupedkey) == NULL)
				return (0);
d839 22
a860 3
#endif
	if (tt->rn_mask == NULL || (saved_m = m = tt->rn_mklist) == NULL)
		goto on1;
d865 1
a865 1
			return (0);
d869 4
a872 1
				goto on1;
d874 5
a878 1
		/* tt is currently the head of the possible multipath chain */
d884 1
a884 1
				return (0);
d888 1
a888 1
			goto on1;
d894 1
a894 1
			goto on1;
d897 1
a897 1
			goto on1;
d899 10
a908 8
	b = -1 - tt->rn_b;
	t = saved_tt->rn_p;
	if (b > t->rn_b)
		goto on1; /* Wasn't lifted at all */
	do {
		x = t;
		t = t->rn_p;
	} while (b <= t->rn_b && x != top);
d915 1
d919 1
a919 1
			return (0); /* Dangling ref to us */
d921 49
a969 1
on1:
d971 2
a972 1
	 * Eliminate us from tree
d974 24
a997 1
	if (tt->rn_flags & RNF_ROOT)
d999 6
a1004 7
	t = tt->rn_p;
	dupedkey = saved_tt->rn_dupedkey;
	if (dupedkey) {
		/*
		 * Here, tt is the deletion target, and
		 * saved_tt is the head of the dupedkey chain.
		 */
d1006 4
a1009 4
			x = dupedkey;
			x->rn_p = t;
			if (t->rn_l == tt)
				t->rn_l = x;
d1011 1
a1011 1
				t->rn_r = x;
d1014 1
a1014 1
			t->rn_dupedkey = tt->rn_dupedkey;
d1016 1
a1016 12
				tt->rn_dupedkey->rn_p = t;
		}
		t = tt + 1;
		if  (t->rn_flags & RNF_ACTIVE) {
			*++x = *t;
			p = t->rn_p;
			if (p->rn_l == t)
				p->rn_l = x;
			else
				p->rn_r = x;
			x->rn_l->rn_p = x;
			x->rn_r->rn_p = x;
d1018 14
d1034 4
a1037 2
	if (t->rn_l == tt)
		x = t->rn_r;
d1039 4
a1042 4
		x = t->rn_l;
	p = t->rn_p;
	if (p->rn_r == t)
		p->rn_r = x;
d1044 3
a1046 2
		p->rn_l = x;
	x->rn_p = p;
d1048 1
a1048 1
	 * Demote routes attached to us.
d1050 2
a1051 1
	if (t->rn_mklist) {
d1055 1
a1055 1
			*mp = t->rn_mklist;
d1060 1
a1060 1
			for (m = t->rn_mklist; m && x; x = x->rn_dupedkey)
d1080 1
d1083 2
d1086 4
a1089 11
	x = tt + 1;
	if (t != x) {
		*t = *x;
		t->rn_l->rn_p = t;
		t->rn_r->rn_p = t;
		p = x->rn_p;
		if (p->rn_l == x)
			p->rn_l = t;
		else
			p->rn_r = t;
	}
d1091 1
a1091 1
	tt->rn_flags &= ~RNF_ACTIVE;
@


1.38
log
@Cleanup the abuse of x as the rn_addmask radix node. Since in most
cases x is just used as a temp variable. Main offender is rn_addmask()
which sets x once at the top uses it then late in the function and then
starts reuing it for various other stuff. While there fix some for loops
to while ones and fix one strange do { } while() loop.
And since rn_search() can not return NULL remove one extra check.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.37 2014/01/20 22:42:06 claudio Exp $	*/
a305 7
#ifdef RN_DEBUG
int	rn_nodenum;
struct	radix_node *rn_clist;
int	rn_saveinfo;
int	rn_debug =  1;
#endif

a317 7
#ifdef RN_DEBUG
	tt->rn_info = rn_nodenum++;
	t->rn_info = rn_nodenum++;
	tt->rn_twin = t;
	tt->rn_ybro = rn_clist;
	rn_clist = tt;
#endif
a364 4
#ifdef RN_DEBUG
	if (rn_debug)
		log(LOG_DEBUG, "rn_insert: Going In:\n"), traverse(p);
#endif
a378 4
#ifdef RN_DEBUG
	if (rn_debug)
		log(LOG_DEBUG, "rn_insert: Coming Out:\n"), traverse(p);
#endif
a620 8
#ifdef RN_DEBUG
		t=tt+1;
		tt->rn_info = rn_nodenum++;
		t->rn_info = rn_nodenum++;
		tt->rn_twin = t;
		tt->rn_ybro = rn_clist;
		rn_clist = tt;
#endif
a823 6
#ifdef RN_DEBUG
	/* Get us out of the creation list */
	for (t = rn_clist; t && t->rn_ybro != tt; t = t->rn_ybro)
		;
	if (t) t->rn_ybro = tt->rn_ybro;
#endif
a845 5
#ifndef RN_DEBUG
			*++x = *t;
			p = t->rn_p;
#else
			b = t->rn_info;
a846 1
			t->rn_info = b;
a847 1
#endif
a903 4
#ifndef RN_DEBUG
		*t = *x;
#else
		b = t->rn_info;
a904 2
		t->rn_info = b;
#endif
@


1.37
log
@Try to be more consistent in how various variables are setup and named.
Also remove a memset that is already happeing because we use PR_ZERO on
the allocation. Move two memmove to memcpy because the addrs can not
overlap. Make some simple helper functions static __inline and remove one
of the explicit rn_search inlines.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.36 2014/01/19 09:52:25 claudio Exp $	*/
d112 1
a112 1
	struct radix_node *x;
d115 1
a115 1
	for (x = head; x->rn_b >= 0;) {
d127 1
a127 1
	struct radix_node *x;
d131 1
a131 1
	for (x = head; x->rn_b >= 0;) {
d173 1
a173 1
	struct radix_node *x;
d177 4
a180 4
		x = rn_addmask(m_arg, 1, head->rnh_treetop->rn_off);
		if (x == NULL)
			return (0);
		netmask = x->rn_key;
d281 1
a281 1
		if (m) {
d288 13
a300 15
			do {
				if (m->rm_flags & RNF_NORMAL) {
					if (rn_b <= m->rm_b)
						return (m->rm_leaf);
				} else {
					struct radix_node *x;
					off = min(t->rn_off, matched_off);
					x = rn_search_m(v, t, m->rm_mask);
					while (x && x->rn_mask != m->rm_mask)
						x = x->rn_dupedkey;
					if (x && rn_satisfies_leaf(v, x, off))
						return x;
				}
				m = m->rm_mklist;
			} while (m);
d409 1
a409 1
	struct radix_node *x, *saved_x;
d439 7
a445 7
	x = rn_search(addmask_key, rn_masktop);
	if (memcmp(addmask_key, x->rn_key, mlen) != 0)
		x = 0;
	if (x || search)
		return (x);
	x = malloc(max_keylen + 2 * sizeof (*x), M_RTABLE, M_NOWAIT | M_ZERO);
	if ((saved_x = x) == NULL)
d447 2
a448 1
	netmask = cp = (caddr_t)(x + 2);
d450 1
a450 1
	x = rn_insert(cp, mask_rnhead, &maskduplicated, x);
d453 2
a454 2
		free(saved_x, M_RTABLE);
		return (x);
d470 1
a470 1
	x->rn_b = -1 - b;
d472 2
a473 2
		x->rn_flags |= RNF_NORMAL;
	return (x);
d527 1
a527 1
	struct radix_node *t, *x = NULL, *tt;
d542 1
a542 1
		if ((x = rn_addmask(netmask, 0, top->rn_off)) == 0)
d544 3
a546 3
		b_leaf = x->rn_b;
		b = -1 - x->rn_b;
		netmask = x->rn_key;
d548 3
a553 1
	saved_tt = tt = rn_insert(v, head, &keyduplicated, treenodes);
d655 1
d661 2
a662 2
		tt->rn_b = x->rn_b;
		tt->rn_flags |= x->rn_flags & RNF_NORMAL;
d767 1
a767 1
	struct radix_node *t, *p, *x, *tt;
d776 1
a776 2
	if (tt == NULL ||
	    memcmp(v + off, tt->rn_key + off, vlen - off))
d782 1
a782 1
		if ((x = rn_addmask(netmask, 1, off)) == NULL)
d784 1
a784 1
		netmask = x->rn_key;
@


1.36
log
@More cleanup in radix.c. Kill the rt_mkfreelist and replace it with a
radix_mask pool. With input and OK mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.35 2014/01/19 04:04:36 claudio Exp $	*/
d63 3
a65 3
static int rn_satisfies_leaf(char *, struct radix_node *, int);
static int rn_lexobetter(void *, void *);
static struct radix_mask *rn_new_radix_mask(struct radix_node *,
d71 2
a72 1
struct radix_node *rn_search(void *, struct radix_node *);
d109 1
a109 1
struct radix_node *
d113 1
a113 1
	caddr_t v;
d115 1
a115 1
	for (x = head, v = v_arg; x->rn_b >= 0;) {
d128 2
a129 1
	caddr_t v = v_arg, m = m_arg;
d144 4
a147 3
	caddr_t m = m_arg, n = n_arg;
	caddr_t lim, lim2 = lim = n + *(u_char *)n;
	int longer = (*(u_char *)n++) - (int)(*(u_char *)m++);
d150 2
d190 1
a190 1
static int
d193 3
a195 1
	char *cp = trial, *cp2 = leaf->rn_key, *cp3 = leaf->rn_mask;
d197 1
a197 1
	int length = min(*(u_char *)cp, *(u_char *)cp2);
d199 1
d215 5
a219 5
	struct radix_node *t = head->rnh_treetop, *x;
	caddr_t cp = v, cp2;
	caddr_t cplim;
	struct radix_node *saved_t, *top = t;
	int off = t->rn_off, vlen = *(u_char *)cp, matched_off;
d222 1
a222 10
	/*
	 * Open code rn_search(v, top) to avoid overhead of extra
	 * subroutine call.
	 */
	for (; t->rn_b >= 0; ) {
		if (t->rn_bmask & cp[t->rn_off])
			t = t->rn_r;
		else
			t = t->rn_l;
	}
d236 5
a240 1
	cp += off; cp2 = t->rn_key + off; cplim = v + vlen;
d293 1
d305 1
a305 1
	return 0;
d318 1
a318 1
	struct radix_node *tt = nodes, *t = tt + 1;
d324 1
a324 1
	tt->rn_key = (caddr_t)v;
d339 1
a339 1
	  int *dupentry, struct radix_node nodes[2])
d343 2
a344 3
	int head_off = top->rn_off, vlen = (int)*((u_char *)v);
	struct radix_node *t = rn_search(v_arg, top);
	caddr_t cp = v + head_off;
d346 2
a347 1
	struct radix_node *tt;
d352 7
a358 3
	caddr_t cp2 = t->rn_key + head_off;
	int cmp_res;
	caddr_t cplim = v + vlen;
d373 1
a373 1
	cp = v;
d380 1
a380 1
	} while (b > (unsigned) x->rn_b); /* x->rn_b < b && x->rn_b >= 0 */
d410 2
a411 2
	caddr_t netmask = (caddr_t)n_arg;
	struct radix_node *x;
a414 1
	struct radix_node *saved_x;
d424 1
a424 1
		memmove(addmask_key + 1, rn_ones + 1, skip - 1);
d426 1
a426 1
		memmove(addmask_key + skip, netmask + skip, mlen - skip);
d477 2
a478 1
static int	/* XXX: arbitrary ordering for non-contiguous masks */
d500 1
a500 1
static struct radix_mask *
a509 1
	memset(m, 0, sizeof *m);
d525 3
a527 1
	caddr_t v = (caddr_t)v_arg, netmask = (caddr_t)n_arg;
d529 1
a529 1
	struct radix_node *saved_tt, *top = head->rnh_treetop;
d762 3
d767 4
a770 9
	struct radix_node *dupedkey, *saved_tt, *top;
	caddr_t v, netmask;
	int b, head_off, vlen;

	v = v_arg;
	netmask = netmask_arg;
	x = head->rnh_treetop;
	tt = rn_search(v, x);
	head_off = x->rn_off;
d772 1
a773 1
	top = x;
d775 1
a775 1
	    memcmp(v + head_off, tt->rn_key + head_off, vlen - head_off))
d781 1
a781 1
		if ((x = rn_addmask(netmask, 1, head_off)) == NULL)
@


1.35
log
@Start to reduce the madness in radix.c. This only used by the kernel
since ages so remove the bits used for userland compiles. OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.34 2014/01/10 14:29:08 tedu Exp $	*/
d44 1
a53 1
struct radix_mask *rn_mkfreelist;
d59 2
a73 14
#define MKGet(m) do {                                                   \
	if (rn_mkfreelist) {                                            \
		m = rn_mkfreelist;                                      \
		rn_mkfreelist = (m)->rm_mklist;                         \
	} else                                                          \
		m = malloc(sizeof (*(m)), M_RTABLE, M_NOWAIT);          \
} while (0)

#define MKFree(m) do {                                                  \
	(m)->rm_mklist = rn_mkfreelist;                                 \
	rn_mkfreelist = (m);                                            \
} while (0)


d497 1
a497 1
	MKGet(m);
d832 1
a832 1
			MKFree(m);
d919 1
a919 1
						MKFree(m);
d1037 1
a1037 1
rn_init()
d1042 2
@


1.34
log
@replace the rest of the obsolete radix macros
sprinkle 0 -> NULL where obvious
ok millert mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.33 2014/01/09 21:57:51 tedu Exp $	*/
a38 1
#ifndef _NET_RADIX_H_
a39 1
#ifdef _KERNEL
a41 1
#define	M_DONTWAIT M_NOWAIT
a42 3
#else
#include <stdlib.h>
#endif
a44 1
#endif
a1051 1
#ifdef _KERNEL
a1056 1
#endif
@


1.33
log
@replace Bcopy macro with memmove and memcpy. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.32 2013/12/12 14:43:38 millert Exp $	*/
a66 2
#undef Bcmp
#define Bcmp(a, b, l) (l == 0 ? 0 : bcmp((caddr_t)(a), (caddr_t)(b), (u_long)l))
d79 14
d191 2
a192 1
		if ((x = rn_addmask(m_arg, 1, head->rnh_treetop->rn_off)) == 0)
d211 1
a211 1
	if (cp3 == 0)
d277 2
a278 1
	if ((saved_t = t)->rn_mask == 0)
d451 1
a451 1
		Bzero(addmask_key + m0, last_zeroed - m0);
d454 1
a454 1
	if (Bcmp(addmask_key, x->rn_key, mlen) != 0)
d458 2
a459 2
	R_Malloc(x, struct radix_node *, max_keylen + 2 * sizeof (*x));
	if ((saved_x = x) == 0)
a460 1
	Bzero(x, max_keylen + 2 * sizeof (*x));
d462 1
a462 1
	memmove(cp, addmask_key, mlen);
d466 1
a466 1
		Free(saved_x);
d517 1
a517 1
	if (m == 0) {
d521 1
a521 1
	Bzero(m, sizeof *m);
d786 2
a787 2
	if (tt == 0 ||
	    Bcmp(v + head_off, tt->rn_key + head_off, vlen - head_off))
d793 1
a793 1
		if ((x = rn_addmask(netmask, 1, head_off)) == 0)
d797 1
a797 1
			if ((tt = tt->rn_dupedkey) == 0)
d803 1
a803 1
			if ((tt = tt->rn_dupedkey) == 0)
d807 1
a807 1
	if (tt->rn_mask == 0 || (saved_m = m = tt->rn_mklist) == 0)
d854 1
a854 1
	if (m == 0) {
d1024 2
a1025 2
	R_Malloc(rnh, struct radix_node_head *, sizeof (*rnh));
	if (rnh == 0)
d1036 1
a1036 1
	Bzero(rnh, sizeof (*rnh));
d1071 1
a1071 1
	R_Malloc(rn_zeros, char *, 3 * max_keylen);
a1073 1
	Bzero(rn_zeros, 3 * max_keylen);
@


1.32
log
@Fix invalid size to memcmp() in rn_lexobetter() introduced when the
hand-rolled loop was converted to memcmp().  From Kieran Devlin.
OK markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.31 2013/10/20 16:17:36 claudio Exp $	*/
d422 1
a422 1
		Bcopy(rn_ones + 1, addmask_key + 1, skip - 1);
d424 1
a424 1
		Bcopy(netmask + skip, addmask_key + skip, mlen - skip);
d449 1
a449 1
	Bcopy(addmask_key, cp, mlen);
@


1.31
log
@Rename rn_mpath_count() to rn_mpath_active_count() since it will only
return the number of active aka RTF_UP multipath routes. OK grep & gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.30 2012/07/10 15:53:34 blambert Exp $	*/
d479 1
a479 1
	u_char *mp = m_arg, *np = n_arg, *lim;
d495 1
a495 2
	lim = mp + *mp;
	return (memcmp(mp, np, *lim) > 0);
@


1.30
log
@Place declarations for internal radix functions inside radix.c, stop
exporting them to the outside world via radix.h.

ok claudio@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.29 2011/07/22 13:05:29 henning Exp $	*/
d584 1
a584 1
				mid = rn_mpath_count(tt) / 2;
@


1.29
log
@fix typos, martin pelikan
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.28 2010/08/22 17:02:04 mpf Exp $	*/
d74 6
@


1.28
log
@Fix a 16 year old bug in the sorting routine for non-contiguous netmasks.
For masks of identical length rn_lexobetter() did not stop on the
first non-equal byte. This leads rn_addroute() to not detecting
duplicate entries and thus we might create a very long list of masks
to check for each node.
This can have a huge impact on IPsec performance, where non-contiguous
masks are used for the flow lookup.  In a setup with 1300 flows we
saw 400 duplicate masks and only a third of the expected throughput.
Lots of help in narrowing this down from markus@@.
Improved comments from claudio@@.
OK markus@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.27 2010/06/28 18:50:37 claudio Exp $	*/
d989 1
a989 1
			    (error = (*f)(rn, w, h->rnh_rtabelid)))
@


1.27
log
@Add the rtable id as an argument to rn_walktree(). Functions like
rt_if_remove_rtdelete() need to know the table id to be able to correctly
remove nodes.
Problem found by Andrea Parazzini and analyzed by Martin Pelikn.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.26 2009/01/06 21:40:47 claudio Exp $	*/
d475 6
d482 9
a490 6
		return 1;  /* not really, but need to check longer one first */
	if (*mp == *np)
		for (lim = mp + *mp; mp < lim;)
			if (*mp++ > *np++)
				return 1;
	return 0;
@


1.26
log
@Change the way way rn_mklists work (especially the RNF_NORMAL ones).
Until now RNF_NORMAL masks did not use the refcount because only one route
in a particular subtree could have this mask. With multipath routing this is
no longer correct. The result was wrong backtracking information beeing stored
in the radix tree and so cretain lookups ended up on the wrong multipath nodes.
Use rm_refs for RNF_NORMAL masks so that all multipath routes are able
to point to the same radix_mask entry. Additional logic ensures that rm_leaf
always points back to the head of the multipath rn_dupedkey chain.
Tested by dlg@@, gollo@@, david@@, sthen@@ and a few more
This can have my OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.25 2008/12/29 21:24:19 claudio Exp $	*/
d953 2
a954 2
rn_walktree(struct radix_node_head *h, int (*f)(struct radix_node *, void *),
    void *w)
d979 2
a980 1
			if (!(rn->rn_flags & RNF_ROOT) && (error = (*f)(rn, w)))
@


1.25
log
@At least try to make this code a bit easier to read. Don't fiddle with x
when xx can do the trick or in dlg's words: "xx was a copy of x so they
could use x for some temp working and restore it from xx later? yeesh"
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.24 2008/11/21 18:01:30 claudio Exp $	*/
d655 8
a662 1
	    for (mp = &t->rn_mklist; x; x = x->rn_dupedkey)
d668 1
d701 22
a722 1
			if (tt->rn_flags & RNF_NORMAL) {
d783 20
a802 3
		if (m->rm_leaf != tt || m->rm_refs > 0) {
			log(LOG_ERR, "rn_delete: inconsistent annotation\n");
			return 0;  /* dangling ref could cause disaster */
d804 1
d912 7
@


1.24
log
@Change rn_mpath_next() to be able to walk over the full multipath list
not only over routes of the same prio. This makes it possible to modify
rt_mpath_matchgate() so that if only gateway is specified without a specific
priority it will scan the full list and not only the first routes.
This is also needed for upcoming link state tracking.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.23 2008/05/09 07:39:31 claudio Exp $	*/
d600 1
a600 1
			struct	radix_node *xx = x;
d604 1
a604 1
			tt->rn_p = x = t->rn_p;
d606 2
a607 2
			if (x->rn_l == t)
				x->rn_l = tt;
d609 1
a609 1
				x->rn_r = tt;
a610 1
			x = xx;
@


1.23
log
@Fix a logic botch around prioinv that resulted in wrong ordering of more
specific routes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.22 2008/05/07 05:14:21 claudio Exp $	*/
d572 1
a572 1
					tt = rn_mpath_next(tt);
@


1.22
log
@Implement routing priorities. Every route inserted has a priority assigned
and the one route with the lowest number wins. This will be used by the
routing daemons to resolve the synchronisations issue in case of conflicts.
The nasty bits of this are in the multipath code. If no priority is specified
the kernel will choose an appropriate priority.

Looked at by a few people at n2k8 code is much older
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.21 2006/06/18 11:47:45 pascoe Exp $	*/
d514 1
a514 1
	int keyduplicated, prioinv = 0;
d551 1
d612 1
a612 1
		} else if (prioinv) {
@


1.21
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.20 2006/02/06 17:37:28 jmc Exp $	*/
d54 2
d508 1
a508 1
    struct radix_node treenodes[2])
d514 1
a514 1
	int keyduplicated;
d541 1
d548 2
d551 18
a568 1
				int mid = rn_mpath_count(tt) / 2;
d571 2
a572 3
					tt = tt->rn_dupedkey;
				} while (tt && t->rn_mask == tt->rn_mask
				    && --mid > 0);
d598 1
a598 1
		if (tt == saved_tt) {
d611 7
a720 3
#ifndef SMALL_KERNEL
	int mpath_enable = 0;
#endif
a724 13
#ifndef SMALL_KERNEL
	if (rn) {
		tt = rn;
		/*
		 * Is this route(rn) a rn->dupedkey chain? 
		 */
		if (rn_mpath_next(tt->rn_p))
			mpath_enable = 1;
		else
			tt = rn_search(v, x);
	} else
		tt = rn_search(v, x);
#else
a725 1
#endif
d744 7
d812 4
a815 8
			/* find node in front of tt on the chain */
			for (x = p = saved_tt; p && p->rn_dupedkey != tt;)
				p = p->rn_dupedkey;
			if (p) {
				p->rn_dupedkey = tt->rn_dupedkey;
				if (tt->rn_dupedkey)
					tt->rn_dupedkey->rn_p = p;
			} else log(LOG_ERR, "rn_delete: couldn't find us\n");
a836 10
#ifndef SMALL_KERNEL
	if (mpath_enable) {
		/*
		 * my parent dupedkey is NULL
		 * end of mpath route.
		 */
		t->rn_dupedkey = NULL;
		goto out;
	}
#endif
@


1.20
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.19 2005/05/15 16:40:09 henning Exp $	*/
d540 5
a544 3
				 * go down to the end of multipaths, so that
				 * new entry goes into the end of rn_dupedkey
				 * chain.
d546 1
d550 2
a551 1
				} while (tt && t->rn_mask == tt->rn_mask);
@


1.19
log
@ANSI, mostly from Toni Mueller <openbsd-tech@@oeko.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.18 2004/04/25 20:02:39 itojun Exp $	*/
d102 1
a102 1
 * circuiting an explict mask and compare operation when testing whether
@


1.18
log
@permit multiple default route.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.17 2004/04/25 02:48:03 itojun Exp $	*/
d108 1
a108 3
rn_search(v_arg, head)
	void *v_arg;
	struct radix_node *head;
d123 1
a123 3
rn_search_m(v_arg, head, m_arg)
	struct radix_node *head;
	void *v_arg, *m_arg;
d139 1
a139 2
rn_refines(m_arg, n_arg)
	void *m_arg, *n_arg;
d165 1
a165 3
rn_lookup(v_arg, m_arg, head)
	void *v_arg, *m_arg;
	struct radix_node_head *head;
d184 1
a184 4
rn_satisfies_leaf(trial, leaf, skip)
	char *trial;
	struct radix_node *leaf;
	int skip;
d202 1
a202 3
rn_match(v_arg, head)
	void *v_arg;
	struct radix_node_head *head;
d309 1
a309 4
rn_newpair(v, b, nodes)
	void *v;
	int b;
	struct radix_node nodes[2];
d331 2
a332 5
rn_insert(v_arg, head, dupentry, nodes)
	void *v_arg;
	struct radix_node_head *head;
	int *dupentry;
	struct radix_node nodes[2];
d397 1
a397 3
rn_addmask(n_arg, search, skip)
	int search, skip;
	void *n_arg;
d469 1
a469 2
rn_lexobetter(m_arg, n_arg)
	void *m_arg, *n_arg;
d483 1
a483 3
rn_new_radix_mask(tt, next)
	struct radix_node *tt;
	struct radix_mask *next;
d505 2
a506 4
rn_addroute(v_arg, n_arg, head, treenodes)
	void *v_arg, *n_arg;
	struct radix_node_head *head;
	struct radix_node treenodes[2];
d681 2
a682 4
rn_delete(v_arg, netmask_arg, head, rn)
	void *v_arg, *netmask_arg;
	struct radix_node_head *head;
	struct radix_node *rn;
d891 2
a892 4
rn_walktree(h, f, w)
	struct radix_node_head *h;
	int (*f)(struct radix_node *, void *);
	void *w;
d928 1
a928 3
rn_inithead(head, off)
	void **head;
	int off;
d942 1
a942 3
rn_inithead0(rnh, off)
	struct radix_node_head *rnh;
	int off;
@


1.17
log
@radix tree with multipath support.  from kame.  deraadt ok
user visible changes:
- you can add multiple routes with same key (route add A B then route add A C)
- you have to specify gateway address if there are multiple entries on the table
  (route delete A B, instead of route delete A)
kernel change:
- radix_node_head has an extra entry
- rnh_deladdr takes extra argument

TODO:
- actually take advantage of multipath (rtalloc -> rtalloc_mpath)
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.16 2004/04/25 01:38:10 brad Exp $	*/
d724 1
a724 1
	if (rn && (rn->rn_mask != rn_zeros)) {
d726 1
a726 1
		/* 
a727 1
		 * Only default route is an exception. (rn_mask)
@


1.16
log
@sync with NetBSD, mostly a Lite2 merge.

ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.15 2004/04/25 00:31:40 itojun Exp $	*/
d53 4
d561 15
d706 1
a706 1
rn_delete(v_arg, netmask_arg, head)
d709 1
d716 3
d723 14
d738 1
d847 10
@


1.15
log
@undo "oops" commit on 1.14 (radix_mpath).
@
text
@d1 2
a2 2
/*	$OpenBSD: radix.c,v 1.13 2003/12/19 06:57:17 brad Exp $	*/
/*	$NetBSD: radix.c,v 1.11 1996/03/16 23:55:36 christos Exp $	*/
d32 1
a32 1
 *	@@(#)radix.c	8.4 (Berkeley) 11/2/94
d38 2
a47 2
#include <stdlib.h>
#include <string.h>
d51 1
a63 1

d67 2
a68 1
						 struct radix_mask *);
d282 2
a283 1
		if ((m = t->rn_mklist) != NULL) {
d302 2
a303 1
			} while ((m = m->rm_mklist) != NULL);
d460 1
a460 1
		log(LOG_ERR, "rn_addmask: mask impossibly already in tree");
d575 3
d585 1
d595 3
d639 1
a639 1
		for (mp = &x->rn_mklist; (m = *mp) != NULL; mp = &m->rm_mklist)
d660 1
a660 1
	for (mp = &x->rn_mklist; (m = *mp) != NULL; mp = &m->rm_mklist) {
d668 2
a669 2
				log(LOG_ERR, "Non-unique normal route, "
				    "mask not entered\n");
d742 1
a742 1
	for (mp = &x->rn_mklist; (m = *mp) != NULL; mp = &m->rm_mklist)
d766 6
a771 1
	if ((dupedkey = saved_tt->rn_dupedkey) != 0) {
d780 1
d783 1
a783 1
			if (p)
d785 3
a787 2
			else
				log(LOG_ERR, "rn_delete: couldn't find us\n");
d824 1
a824 1
			for (mp = &x->rn_mklist; (m = *mp) != NULL;)
d841 1
a841 1
					    "rn_delete: Orphaned Mask", m, x);
d915 1
a915 1
	struct radix_node *t, *tt, *ttt;
d921 11
a932 1
	*head = rnh;
d975 1
a975 1
	if (rn_inithead((void **)&mask_rnhead, 0) == 0)
@


1.14
log
@indentation fix
@
text
@a51 4
#ifdef RADIX_MPATH
#include <net/radix_mpath.h>
#endif

a553 15
#ifdef RADIX_MPATH
			/* permit multipath, if enabled for the family */
			if (rn_mpath_capable(head) && netmask == tt->rn_mask) {
				/*
				 * go down to the end of multipaths, so that
				 * new entry goes into the end of rn_dupedkey
				 * chain.
				 */
				do {
					t = tt;
					tt = tt->rn_dupedkey;
				} while (tt && t->rn_mask == tt->rn_mask);
				break;
			}
#endif
d677 1
a677 1
rn_delete(v_arg, netmask_arg, head, rn)
a679 1
	struct radix_node *rn;
a685 3
#ifdef RADIX_MPATH
	int mpath_enable = 0;
#endif
a689 14
#ifdef RADIX_MPATH
	if (rn && (rn->rn_mask != rn_zeros)) {
		tt = rn;
		/* 
		 * Is this route(rn) a rn->dupedkey chain? 
		 * Only default route is an exception. (rn_mask)
		 */
		if (rn_mpath_next(tt->rn_p))
			mpath_enable = 1;
		else
			tt = rn_search(v, x);
	} else
		tt = rn_search(v, x);
#else
a690 1
#endif
a791 10
#ifdef RADIX_MPATH
	if (mpath_enable) {
		/*
		 * my parent dupedkey is NULL
		 * end of mpath route.
		 */
		t->rn_dupedkey = NULL;
		goto out;
	}
#endif
d898 1
a898 1

d904 1
a905 11
	return rn_inithead0(rnh, off);
}

int
rn_inithead0(rnh, off)
	struct radix_node_head *rnh;
	int off;
{
	register struct radix_node *t, *tt, *ttt;

	Bzero(rnh, sizeof (*rnh));
@


1.13
log
@rn_satsifies_leaf -> rn_satisfies_leaf

from itojun@@netbsd rev 1.15

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.12 2003/12/10 07:22:42 itojun Exp $	*/
d52 4
d302 1
a302 1
						    return x;
d558 15
d696 1
a696 1
rn_delete(v_arg, netmask_arg, head)
d699 1
d706 3
d713 14
d728 1
d830 10
d946 1
a946 1
	struct radix_node *t, *tt, *ttt;
d952 11
a963 1
	*head = rnh;
@


1.12
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.11 2003/08/27 00:33:34 henric Exp $	*/
d64 1
a64 1
static int rn_satsifies_leaf(char *, struct radix_node *, int);
d186 1
a186 1
rn_satsifies_leaf(trial, leaf, skip)
d274 1
a274 1
		} else if (rn_satsifies_leaf(v, t, matched_off))
d297 1
a297 1
					if (x && rn_satsifies_leaf(v, x, off))
@


1.11
log
@RNF_IGNORE can corrupt the radix tree when an interface is down, it
makes routing lookups slightly more expensive, and serves no useful
purpose.

ok itojun@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.10 2003/06/02 23:28:12 millert Exp $	*/
d107 2
a108 2
	register struct radix_node *x;
	register caddr_t v;
d124 2
a125 2
	register struct radix_node *x;
	register caddr_t v = v_arg, m = m_arg;
d141 2
a142 2
	register caddr_t m = m_arg, n = n_arg;
	register caddr_t lim, lim2 = lim = n + *(u_char *)n;
d169 1
a169 1
	register struct radix_node *x;
d188 1
a188 1
	register struct radix_node *leaf;
d191 1
a191 1
	register char *cp = trial, *cp2 = leaf->rn_key, *cp3 = leaf->rn_mask;
d212 2
a213 2
	register struct radix_node *t = head->rnh_treetop, *x;
	register caddr_t cp = v, cp2;
d217 1
a217 1
	register int test, b, rn_b;
d279 1
a279 1
		register struct radix_mask *m;
d319 1
a319 1
	register struct radix_node *tt = nodes, *t = tt + 1;
d348 3
a350 3
	register struct radix_node *t = rn_search(v_arg, top);
	register caddr_t cp = v + head_off;
	register int b;
d356 2
a357 2
	register caddr_t cp2 = t->rn_key + head_off;
	register int cmp_res;
d372 1
a372 1
	register struct radix_node *p, *x = top;
d413 3
a415 3
	register struct radix_node *x;
	register caddr_t cp, cplim;
	register int b = 0, mlen, j;
d485 1
a485 1
	register u_char *mp = m_arg, *np = n_arg, *lim;
d498 2
a499 2
	register struct radix_node *tt;
	register struct radix_mask *next;
d501 1
a501 1
	register struct radix_mask *m;
d527 1
a527 1
	register struct radix_node *t, *x = NULL, *tt;
d681 1
a681 1
	register struct radix_node *t, *p, *x, *tt;
d856 1
a856 1
	register int (*f)(struct radix_node *, void *);
d861 1
a861 1
	register struct radix_node *rn = h->rnh_treetop;
d897 2
a898 2
	register struct radix_node_head *rnh;
	register struct radix_node *t, *tt, *ttt;
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.9 2002/11/20 21:21:15 deraadt Exp $	*/
d265 1
a265 1
	for (; t && !(t->rn_flags & RNF_IGNORE); t = t->rn_dupedkey)
d290 1
a290 2
					if (rn_b <= m->rm_b &&
					    !(m->rm_flags & RNF_IGNORE))
d297 1
a297 2
					if (x && !(x->rn_flags & RNF_IGNORE) &&
					    rn_satsifies_leaf(v, x, off))
@


1.9
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.8 2002/03/14 01:27:10 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.7 2001/07/21 14:34:47 itojun Exp $	*/
d294 1
a294 1
					if (rn_b <= m->rm_b && 
d311 1
a311 1
		
d326 7
a332 3
	t->rn_b = b; t->rn_bmask = 0x80 >> (b & 7);
	t->rn_l = tt; t->rn_off = b >> 3;
	tt->rn_b = -1; tt->rn_key = (caddr_t)v; tt->rn_p = t;
d335 5
a339 2
	tt->rn_info = rn_nodenum++; t->rn_info = rn_nodenum++;
	tt->rn_twin = t; tt->rn_ybro = rn_clist; rn_clist = tt;
d358 1
a358 1
    	/*
d382 1
a382 1
		if (cp[x->rn_off] & x->rn_bmask) 
d384 2
a385 1
		else x = x->rn_l;
d391 2
a392 1
	t = rn_newpair(v_arg, b, nodes); tt = t->rn_l;
d397 2
a398 1
	x->rn_p = t; t->rn_p = p; /* frees x, p as temp vars below */
d402 2
a403 1
		t->rn_r = tt; t->rn_l = x;
d470 2
a471 1
	cplim = netmask + mlen; isnormal = 1;
d475 1
a475 1
		for (j = 0x80; (j & *cp) != 0; j >>= 1)  
d495 1
a495 1
	if (*mp == *np) 
d585 6
a590 2
			if (x->rn_l == t) x->rn_l = tt; else x->rn_r = tt;
			saved_tt = tt; x = xx;
d596 6
a601 2
		t=tt+1; tt->rn_info = rn_nodenum++; t->rn_info = rn_nodenum++;
		tt->rn_twin = t; tt->rn_ybro = rn_clist; rn_clist = tt;
d619 4
a622 1
	if (t->rn_r == saved_tt) x = t->rn_l; else x = t->rn_r;
d624 1
a624 1
	if (x->rn_b < 0) { 
d638 2
a639 1
		t->rn_mklist = m; *mp = 0;
d722 1
a722 1
	} else { 
d757 2
a758 1
	for (t = rn_clist; t && t->rn_ybro != tt; t = t->rn_ybro) {}
d764 6
a769 2
			x = dupedkey; x->rn_p = t;
			if (t->rn_l == tt) t->rn_l = x; else t->rn_r = x;
d773 4
a776 2
			if (p) p->rn_dupedkey = tt->rn_dupedkey;
			else log(LOG_ERR, "rn_delete: couldn't find us\n");
d781 2
a782 1
			*++x = *t; p = t->rn_p;
d784 4
a787 1
			b = t->rn_info; *++x = *t; t->rn_info = b; p = t->rn_p;
d789 6
a794 2
			if (p->rn_l == t) p->rn_l = x; else p->rn_r = x;
			x->rn_l->rn_p = x; x->rn_r->rn_p = x;
d798 4
a801 1
	if (t->rn_l == tt) x = t->rn_r; else x = t->rn_l;
d803 4
a806 1
	if (p->rn_r == t) p->rn_r = x; else p->rn_l = x;
d841 3
a843 1
		b = t->rn_info; *t = *x; t->rn_info = b;
d845 2
a846 1
		t->rn_l->rn_p = t; t->rn_r->rn_p = t;
d848 4
a851 1
		if (p->rn_l == x) p->rn_l = t; else p->rn_r = t;
@


1.7
log
@missing \n in a log() call
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.6 2001/07/06 08:27:06 deraadt Exp $	*/
d68 4
a71 4
static int rn_satsifies_leaf __P((char *, struct radix_node *, int));
static int rn_lexobetter __P((void *, void *));
static struct radix_mask *rn_new_radix_mask __P((struct radix_node *,
						 struct radix_mask *));
d811 1
a811 1
	register int (*f) __P((struct radix_node *, void *));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.7 2001/07/21 14:34:47 itojun Exp $	*/
d68 4
a71 4
static int rn_satsifies_leaf(char *, struct radix_node *, int);
static int rn_lexobetter(void *, void *);
static struct radix_mask *rn_new_radix_mask(struct radix_node *,
						 struct radix_mask *);
d811 1
a811 1
	register int (*f)(struct radix_node *, void *);
@


1.7.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d294 1
a294 1
					if (rn_b <= m->rm_b &&
d311 1
a311 1

d326 3
a328 7
	t->rn_b = b;
	t->rn_bmask = 0x80 >> (b & 7);
	t->rn_l = tt;
	t->rn_off = b >> 3;
	tt->rn_b = -1;
	tt->rn_key = (caddr_t)v;
	tt->rn_p = t;
d331 2
a332 5
	tt->rn_info = rn_nodenum++;
	t->rn_info = rn_nodenum++;
	tt->rn_twin = t;
	tt->rn_ybro = rn_clist;
	rn_clist = tt;
d351 1
a351 1
	/*
d375 1
a375 1
		if (cp[x->rn_off] & x->rn_bmask)
d377 1
a377 2
		else
			x = x->rn_l;
d383 1
a383 2
	t = rn_newpair(v_arg, b, nodes);
	tt = t->rn_l;
d388 1
a388 2
	x->rn_p = t;
	t->rn_p = p; /* frees x, p as temp vars below */
d392 1
a392 2
		t->rn_r = tt;
		t->rn_l = x;
d459 1
a459 2
	cplim = netmask + mlen;
	isnormal = 1;
d463 1
a463 1
		for (j = 0x80; (j & *cp) != 0; j >>= 1)
d483 1
a483 1
	if (*mp == *np)
d573 2
a574 6
			if (x->rn_l == t)
				x->rn_l = tt;
			else
				x->rn_r = tt;
			saved_tt = tt;
			x = xx;
d580 2
a581 6
		t=tt+1;
		tt->rn_info = rn_nodenum++;
		t->rn_info = rn_nodenum++;
		tt->rn_twin = t;
		tt->rn_ybro = rn_clist;
		rn_clist = tt;
d599 1
a599 4
	if (t->rn_r == saved_tt)
		x = t->rn_l;
	else
		x = t->rn_r;
d601 1
a601 1
	if (x->rn_b < 0) {
d615 1
a615 2
		t->rn_mklist = m;
		*mp = 0;
d698 1
a698 1
	} else {
d733 1
a733 2
	for (t = rn_clist; t && t->rn_ybro != tt; t = t->rn_ybro)
		;
d739 2
a740 6
			x = dupedkey;
			x->rn_p = t;
			if (t->rn_l == tt)
				t->rn_l = x;
			else
				t->rn_r = x;
d744 2
a745 4
			if (p)
				p->rn_dupedkey = tt->rn_dupedkey;
			else
				log(LOG_ERR, "rn_delete: couldn't find us\n");
d750 1
a750 2
			*++x = *t;
			p = t->rn_p;
d752 1
a752 4
			b = t->rn_info;
			*++x = *t;
			t->rn_info = b;
			p = t->rn_p;
d754 2
a755 6
			if (p->rn_l == t)
				p->rn_l = x;
			else
				p->rn_r = x;
			x->rn_l->rn_p = x;
			x->rn_r->rn_p = x;
d759 1
a759 4
	if (t->rn_l == tt)
		x = t->rn_r;
	else
		x = t->rn_l;
d761 1
a761 4
	if (p->rn_r == t)
		p->rn_r = x;
	else
		p->rn_l = x;
d796 1
a796 3
		b = t->rn_info;
		*t = *x;
		t->rn_info = b;
d798 1
a798 2
		t->rn_l->rn_p = t;
		t->rn_r->rn_p = t;
d800 1
a800 4
		if (p->rn_l == x)
			p->rn_l = t;
		else
			p->rn_r = t;
@


1.6
log
@fix userland side prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.5 2000/06/17 20:30:34 provos Exp $	*/
d640 2
a641 2
				log(LOG_ERR,
				   "Non-unique normal route, mask not entered");
@


1.5
log
@on ifconfig down ignore all routes pointing to the downed interface.
okay itojun@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.4 1996/09/05 08:42:32 mickey Exp $	*/
d50 2
@


1.4
log
@remove ';' after function close '}'
make it nicer w/ new routed.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.3 1996/04/21 22:28:43 deraadt Exp $	*/
d267 1
a267 1
	for (; t; t = t->rn_dupedkey)
d292 2
a293 1
					if (rn_b <= m->rm_b)
d300 2
a301 1
					if (x && rn_satsifies_leaf(v, x, off))
@


1.4.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.5 2000/06/17 20:30:34 provos Exp $	*/
d267 1
a267 1
	for (; t && !(t->rn_flags & RNF_IGNORE); t = t->rn_dupedkey)
d292 1
a292 2
					if (rn_b <= m->rm_b && 
					    !(m->rm_flags & RNF_IGNORE))
d299 1
a299 2
					if (x && !(x->rn_flags & RNF_IGNORE) &&
					    rn_satsifies_leaf(v, x, off))
@


1.4.16.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.4.16.1 2001/05/14 22:40:04 niklas Exp $	*/
a49 2
#include <stdlib.h>
#include <string.h>
d638 2
a639 2
				log(LOG_ERR, "Non-unique normal route, "
				    "mask not entered\n");
@


1.4.16.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 4
a71 4
static int rn_satsifies_leaf(char *, struct radix_node *, int);
static int rn_lexobetter(void *, void *);
static struct radix_mask *rn_new_radix_mask(struct radix_node *,
						 struct radix_mask *);
d811 1
a811 1
	register int (*f)(struct radix_node *, void *);
@


1.4.16.4
log
@Sync the SMP branch with 3.3
@
text
@d294 1
a294 1
					if (rn_b <= m->rm_b &&
d311 1
a311 1

d326 3
a328 7
	t->rn_b = b;
	t->rn_bmask = 0x80 >> (b & 7);
	t->rn_l = tt;
	t->rn_off = b >> 3;
	tt->rn_b = -1;
	tt->rn_key = (caddr_t)v;
	tt->rn_p = t;
d331 2
a332 5
	tt->rn_info = rn_nodenum++;
	t->rn_info = rn_nodenum++;
	tt->rn_twin = t;
	tt->rn_ybro = rn_clist;
	rn_clist = tt;
d351 1
a351 1
	/*
d375 1
a375 1
		if (cp[x->rn_off] & x->rn_bmask)
d377 1
a377 2
		else
			x = x->rn_l;
d383 1
a383 2
	t = rn_newpair(v_arg, b, nodes);
	tt = t->rn_l;
d388 1
a388 2
	x->rn_p = t;
	t->rn_p = p; /* frees x, p as temp vars below */
d392 1
a392 2
		t->rn_r = tt;
		t->rn_l = x;
d459 1
a459 2
	cplim = netmask + mlen;
	isnormal = 1;
d463 1
a463 1
		for (j = 0x80; (j & *cp) != 0; j >>= 1)
d483 1
a483 1
	if (*mp == *np)
d573 2
a574 6
			if (x->rn_l == t)
				x->rn_l = tt;
			else
				x->rn_r = tt;
			saved_tt = tt;
			x = xx;
d580 2
a581 6
		t=tt+1;
		tt->rn_info = rn_nodenum++;
		t->rn_info = rn_nodenum++;
		tt->rn_twin = t;
		tt->rn_ybro = rn_clist;
		rn_clist = tt;
d599 1
a599 4
	if (t->rn_r == saved_tt)
		x = t->rn_l;
	else
		x = t->rn_r;
d601 1
a601 1
	if (x->rn_b < 0) {
d615 1
a615 2
		t->rn_mklist = m;
		*mp = 0;
d698 1
a698 1
	} else {
d733 1
a733 2
	for (t = rn_clist; t && t->rn_ybro != tt; t = t->rn_ybro)
		;
d739 2
a740 6
			x = dupedkey;
			x->rn_p = t;
			if (t->rn_l == tt)
				t->rn_l = x;
			else
				t->rn_r = x;
d744 2
a745 4
			if (p)
				p->rn_dupedkey = tt->rn_dupedkey;
			else
				log(LOG_ERR, "rn_delete: couldn't find us\n");
d750 1
a750 2
			*++x = *t;
			p = t->rn_p;
d752 1
a752 4
			b = t->rn_info;
			*++x = *t;
			t->rn_info = b;
			p = t->rn_p;
d754 2
a755 6
			if (p->rn_l == t)
				p->rn_l = x;
			else
				p->rn_r = x;
			x->rn_l->rn_p = x;
			x->rn_r->rn_p = x;
d759 1
a759 4
	if (t->rn_l == tt)
		x = t->rn_r;
	else
		x = t->rn_l;
d761 1
a761 4
	if (p->rn_r == t)
		p->rn_r = x;
	else
		p->rn_l = x;
d796 1
a796 3
		b = t->rn_info;
		*t = *x;
		t->rn_info = b;
d798 1
a798 2
		t->rn_l->rn_p = t;
		t->rn_r->rn_p = t;
d800 1
a800 4
		if (p->rn_l == x)
			p->rn_l = t;
		else
			p->rn_r = t;
@


1.4.16.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.4.16.4 2003/03/28 00:41:29 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.16.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
a64 1
static int rn_satisfies_leaf(char *, struct radix_node *, int);
d107 2
a108 2
	struct radix_node *x;
	caddr_t v;
d124 2
a125 2
	struct radix_node *x;
	caddr_t v = v_arg, m = m_arg;
d141 2
a142 2
	caddr_t m = m_arg, n = n_arg;
	caddr_t lim, lim2 = lim = n + *(u_char *)n;
d169 1
a169 1
	struct radix_node *x;
d186 1
a186 1
rn_satisfies_leaf(trial, leaf, skip)
d188 1
a188 1
	struct radix_node *leaf;
d191 1
a191 1
	char *cp = trial, *cp2 = leaf->rn_key, *cp3 = leaf->rn_mask;
d212 2
a213 2
	struct radix_node *t = head->rnh_treetop, *x;
	caddr_t cp = v, cp2;
d217 1
a217 1
	int test, b, rn_b;
d265 1
a265 1
	for (; t; t = t->rn_dupedkey)
d274 1
a274 1
		} else if (rn_satisfies_leaf(v, t, matched_off))
d279 1
a279 1
		struct radix_mask *m;
d290 2
a291 1
					if (rn_b <= m->rm_b)
d298 2
a299 1
					if (x && rn_satisfies_leaf(v, x, off))
d321 1
a321 1
	struct radix_node *tt = nodes, *t = tt + 1;
d350 3
a352 3
	struct radix_node *t = rn_search(v_arg, top);
	caddr_t cp = v + head_off;
	int b;
d358 2
a359 2
	caddr_t cp2 = t->rn_key + head_off;
	int cmp_res;
d374 1
a374 1
	struct radix_node *p, *x = top;
d415 3
a417 3
	struct radix_node *x;
	caddr_t cp, cplim;
	int b = 0, mlen, j;
d487 1
a487 1
	u_char *mp = m_arg, *np = n_arg, *lim;
d500 2
a501 2
	struct radix_node *tt;
	struct radix_mask *next;
d503 1
a503 1
	struct radix_mask *m;
d529 1
a529 1
	struct radix_node *t, *x = NULL, *tt;
d683 1
a683 1
	struct radix_node *t, *p, *x, *tt;
d858 1
a858 1
	int (*f)(struct radix_node *, void *);
d863 1
a863 1
	struct radix_node *rn = h->rnh_treetop;
d899 2
a900 2
	struct radix_node_head *rnh;
	struct radix_node *t, *tt, *ttt;
@


1.4.16.7
log
@Merge with the trunk
@
text
@d2 1
a2 1
/*	$NetBSD: radix.c,v 1.20 2003/08/07 16:32:56 agc Exp $	*/
d32 1
a32 1
 *	@@(#)radix.c	8.6 (Berkeley) 10/17/95
a37 2

#ifndef _NET_RADIX_H_
d46 2
a50 5
#endif

#ifndef SMALL_KERNEL
#include <net/radix_mpath.h>
#endif
d63 1
d67 1
a67 2
    struct radix_mask *);

d281 1
a281 2
		m = t->rn_mklist;
		if (m) {
d298 1
a298 1
						return x;
d300 1
a300 2
				m = m->rm_mklist;
			} while (m);
d457 1
a457 1
		log(LOG_ERR, "rn_addmask: mask impossibly already in tree\n");
a553 15
#ifndef SMALL_KERNEL
			/* permit multipath, if enabled for the family */
			if (rn_mpath_capable(head) && netmask == tt->rn_mask) {
				/*
				 * go down to the end of multipaths, so that
				 * new entry goes into the end of rn_dupedkey
				 * chain.
				 */
				do {
					t = tt;
					tt = tt->rn_dupedkey;
				} while (tt && t->rn_mask == tt->rn_mask);
				break;
			}
#endif
a571 3
		 *
		 * We also reverse, or doubly link the list through the
		 * parent pointer.
a578 1
			t->rn_p = tt;
a587 3
			tt->rn_p = t;
			if (tt->rn_dupedkey)
				tt->rn_dupedkey->rn_p = tt;
d629 1
a629 1
		for (mp = &x->rn_mklist; (m = *mp); mp = &m->rm_mklist)
d650 1
a650 1
	for (mp = &x->rn_mklist; (m = *mp); mp = &m->rm_mklist) {
d658 2
a659 2
				log(LOG_ERR, "Non-unique normal route,"
				    " mask not entered\n");
d677 1
a677 1
rn_delete(v_arg, netmask_arg, head, rn)
a679 1
	struct radix_node *rn;
a685 3
#ifndef SMALL_KERNEL
	int mpath_enable = 0;
#endif
a689 13
#ifndef SMALL_KERNEL
	if (rn) {
		tt = rn;
		/*
		 * Is this route(rn) a rn->dupedkey chain? 
		 */
		if (rn_mpath_next(tt->rn_p))
			mpath_enable = 1;
		else
			tt = rn_search(v, x);
	} else
		tt = rn_search(v, x);
#else
a690 1
#endif
d732 1
a732 1
	for (mp = &x->rn_mklist; (m = *mp); mp = &m->rm_mklist)
d756 1
a756 6
	dupedkey = saved_tt->rn_dupedkey;
	if (dupedkey) {
		/*
		 * Here, tt is the deletion target, and
		 * saved_tt is the head of the dupedkey chain.
		 */
a764 1
			/* find node in front of tt on the chain */
d767 1
a767 1
			if (p) {
d769 2
a770 3
				if (tt->rn_dupedkey)
					tt->rn_dupedkey->rn_p = p;
			} else log(LOG_ERR, "rn_delete: couldn't find us\n");
a791 10
#ifndef SMALL_KERNEL
	if (mpath_enable) {
		/*
		 * my parent dupedkey is NULL
		 * end of mpath route.
		 */
		t->rn_dupedkey = NULL;
		goto out;
	}
#endif
d807 1
a807 1
			for (mp = &x->rn_mklist; (m = *mp);)
d824 1
a824 1
				    "rn_delete: Orphaned Mask", m, x);
d898 1
a898 1

d904 1
a905 11
	return rn_inithead0(rnh, off);
}

int
rn_inithead0(rnh, off)
	struct radix_node_head *rnh;
	int off;
{
	struct radix_node *t, *tt, *ttt;

	Bzero(rnh, sizeof (*rnh));
d948 1
a948 1
	if (rn_inithead((void *)&mask_rnhead, 0) == 0)
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.c,v 1.2 1996/03/03 21:07:14 niklas Exp $	*/
d119 1
a119 1
};
d137 1
a137 1
};
d306 1
a306 1
};
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: radix.c,v 1.10 1996/02/13 22:00:32 christos Exp $	*/
d780 1
a780 1
				log(LOG_ERR, "%s %x at %x\n",
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: radix.c,v 1.9 1995/05/17 15:50:06 mycroft Exp $	*/
d64 6
d187 1
a187 1
static
d283 1
a283 1
		if (m = t->rn_mklist) {
d302 1
a302 1
			} while (m = m->rm_mklist);
d517 1
a517 1
	register struct radix_node *t, *x, *tt;
d519 1
a519 1
	short b = 0, b_leaf;
d600 2
a601 1
			if (*mp = m = rn_new_radix_mask(x, 0))
d608 1
a608 1
		for (mp = &x->rn_mklist; m = *mp; mp = &m->rm_mklist)
d628 1
a628 1
	for (mp = &x->rn_mklist; m = *mp; mp = &m->rm_mklist) {
d710 1
a710 1
	for (mp = &x->rn_mklist; m = *mp; mp = &m->rm_mklist)
d733 1
a733 1
	if (dupedkey = saved_tt->rn_dupedkey) {
d764 1
a764 1
			for (mp = &x->rn_mklist; m = *mp;)
d807 1
a807 1
	register int (*f)();
d831 1
a831 1
		while (rn = base) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
