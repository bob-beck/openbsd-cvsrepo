head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.2
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.28.0.6
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.25.0.8
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2016.11.14.08.56.12;	author mpi;	state Exp;
branches;
next	1.28;
commitid	G823BsOPhKaqKuE7;

1.28
date	2015.11.04.09.50.21;	author mpi;	state Exp;
branches;
next	1.27;
commitid	vubJzb8H8Cr58s7n;

1.27
date	2015.10.08.08.41.58;	author mpi;	state Exp;
branches;
next	1.26;
commitid	OesGi9XmSKvtapL6;

1.26
date	2015.09.04.08.43.39;	author mpi;	state Exp;
branches;
next	1.25;
commitid	qAevExm24QrBjVNL;

1.25
date	2014.05.27.19.38.15;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.22.10.17.59;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.19.09.52.25;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2014.01.10.14.29.08;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.09.21.57.51;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.24.18.50.16;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2012.12.28.17.52.06;	author gsoares;	state Exp;
branches;
next	1.18;

1.18
date	2012.07.10.15.53.34;	author blambert;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.22.13.05.29;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.28.18.50.37;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.07.19.09.03;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.07.05.14.21;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.16.15.50.28;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.25.02.48.03;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.25.01.38.10;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.27.00.33.34;	author henric;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.03.16.10;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.09.06.16.39;	author angelos;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.06.17.20.30.34;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	96.09.05.08.42.34;	author mickey;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	96.03.03.21.07.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches;
next	;

1.3.16.1
date	2001.05.14.22.40.04;	author niklas;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2001.07.04.10.54.18;	author niklas;	state Exp;
branches;
next	1.3.16.3;

1.3.16.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.3.16.4;

1.3.16.4
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.3.16.5;

1.3.16.5
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.3.16.6;

1.3.16.6
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	;


desc
@@


1.29
log
@rnh_multipath can go, multipath support is dead.
@
text
@/*	$OpenBSD: radix.h,v 1.28 2015/11/04 09:50:21 mpi Exp $	*/
/*	$NetBSD: radix.h,v 1.8 1996/02/13 22:00:37 christos Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)radix.h	8.2 (Berkeley) 10/31/94
 */

#ifndef _NET_RADIX_H_
#define	_NET_RADIX_H_

/*
 * Radix search tree node layout.
 */

struct radix_node {
	struct	radix_mask *rn_mklist;	/* list of masks contained in subtree */
	struct	radix_node *rn_p;	/* parent */
	short	rn_b;			/* bit offset; -1-index(netmask) */
	char	rn_bmask;		/* node: mask for bit test*/
	u_char	rn_flags;		/* enumerated next */
#define RNF_NORMAL	1		/* leaf contains normal route */
#define RNF_ROOT	2		/* leaf is root leaf for tree */
#define RNF_ACTIVE	4		/* This node is alive (for rtfree) */
	union {
		struct {			/* leaf only data: */
			caddr_t	rn_Key;		/* object of search */
			caddr_t	rn_Mask;	/* netmask, if present */
			struct	radix_node *rn_Dupedkey;
		} rn_leaf;
		struct {			/* node only data: */
			int	rn_Off;		/* where to start compare */
			struct	radix_node *rn_L;/* progeny */
			struct	radix_node *rn_R;/* progeny */
		} rn_node;
	} rn_u;
};

#define rn_dupedkey rn_u.rn_leaf.rn_Dupedkey
#define rn_key rn_u.rn_leaf.rn_Key
#define rn_mask rn_u.rn_leaf.rn_Mask
#define rn_off rn_u.rn_node.rn_Off
#define rn_l rn_u.rn_node.rn_L
#define rn_r rn_u.rn_node.rn_R

/*
 * Annotations to tree concerning potential routes applying to subtrees.
 */

struct radix_mask {
	short	rm_b;			/* bit offset; -1-index(netmask) */
	char	rm_unused;		/* cf. rn_bmask */
	u_char	rm_flags;		/* cf. rn_flags */
	struct	radix_mask *rm_mklist;	/* more masks to try */
	union	{
		caddr_t	rmu_mask;		/* the mask */
		struct	radix_node *rmu_leaf;	/* for normal routes */
	}	rm_rmu;
	int	rm_refs;		/* # of references to this struct */
};

#define rm_mask rm_rmu.rmu_mask
#define rm_leaf rm_rmu.rmu_leaf		/* extra field would make 32 bytes */

struct radix_node_head {
	struct	radix_node *rnh_treetop;
	int	rnh_addrsize;		/* permit, but not require fixed keys */
	int	rnh_pktsize;		/* permit, but not require fixed keys */
	struct	radix_node rnh_nodes[3];/* empty tree for common case */
	u_int	rnh_rtableid;
};

void	rn_init(unsigned int);
int	rn_inithead(void **, int);
int	rn_inithead0(struct radix_node_head *, int);
int	rn_refines(void *, void *);
void	rn_link_dupedkey(struct radix_node *, struct radix_node *, int);

int	rn_walktree(struct radix_node_head *,
	    int (*)(struct radix_node *, void *, u_int), void *);

struct radix_node	*rn_addmask(void *, int, int);
struct radix_node	*rn_addroute(void *, void *, struct radix_node_head *,
			    struct radix_node [2], u_int8_t);
struct radix_node	*rn_delete(void *, void *, struct radix_node_head *,
			    struct radix_node *);
struct radix_node	*rn_lookup(void *, void *, struct radix_node_head *);
struct radix_node	*rn_match(void *, struct radix_node_head *);

#endif /* _NET_RADIX_H_ */
@


1.28
log
@Some tweaks to build the rtable API and backends in userland.

Needed by the regression tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.27 2015/10/08 08:41:58 mpi Exp $	*/
a95 1
	int	rnh_multipath;		/* multipath? */
@


1.27
log
@Use the radix API directly and get rid of the function pointers.  There
is no point in keeping an unused level of abstraction.

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.26 2015/09/04 08:43:39 mpi Exp $	*/
a99 2
#ifdef _KERNEL

a115 2

#endif /* _KERNEL */
@


1.26
log
@Make every subsystem using a radix tree call rn_init() and pass the
length of the key as argument.

This way every consumer of the radix tree has a chance to explicitly
initialize the shared data structures and no longer rely on another
subsystem to do the initialization.

As a bonus ``dom_maxrtkey'' is no longer used an die.

ART kernels should now be fully usable because pf(4) and IPSEC properly
initialized the radix tree.

ok chris@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.25 2014/05/27 19:38:15 claudio Exp $	*/
a94 16
					/* add based on sockaddr */
	struct	radix_node *(*rnh_addaddr)(void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[],
		     u_int8_t prio);
					/* remove based on sockaddr */
	struct	radix_node *(*rnh_deladdr)(void *v, void *mask,
		    struct radix_node_head *head, struct radix_node *rn);
					/* locate based on sockaddr */
	struct	radix_node *(*rnh_matchaddr)(void *v,
		    struct radix_node_head *head);
					/* locate based on sockaddr */
	struct	radix_node *(*rnh_lookup)(void *v, void *mask,
		    struct radix_node_head *head);
					/* traverse tree */
	int	(*rnh_walktree)(struct radix_node_head *,
		     int (*)(struct radix_node *, void *, u_int), void *);
@


1.25
log
@Big refactoring of the radix code (mainly rn_addroute but also part
of rn_delete was changed). The mpath code gets a much better
rn_mpath_next() function that allows looping through the dupedkey list
based on prio, any or only active routes. This solves the issues seen
with failed deletes of down routes.
Commit this now so that it gets tested. Both sthen@@ and blambert@@ agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.24 2014/01/22 10:17:59 claudio Exp $	*/
d118 1
a118 1
void	rn_init(void);
@


1.24
log
@Kill the RN_DEBUG code it is broken since rev 1.1 and not worth fixing.
OK mpi@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.23 2014/01/19 09:52:25 claudio Exp $	*/
d122 2
@


1.23
log
@More cleanup in radix.c. Kill the rt_mkfreelist and replace it with a
radix_mask pool. With input and OK mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.22 2014/01/10 14:29:08 tedu Exp $	*/
a62 5
#ifdef RN_DEBUG
	int rn_info;
	struct radix_node *rn_twin;
	struct radix_node *rn_ybro;
#endif
@


1.22
log
@replace the rest of the obsolete radix macros
sprinkle 0 -> NULL where obvious
ok millert mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.21 2014/01/09 21:57:51 tedu Exp $	*/
d81 1
a81 1
extern struct radix_mask {
d91 1
a91 1
} *rn_mkfreelist;
@


1.21
log
@replace Bcopy macro with memmove and memcpy. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.20 2013/10/24 18:50:16 deraadt Exp $	*/
a95 13
#define MKGet(m) do {							\
	if (rn_mkfreelist) {						\
		m = rn_mkfreelist;					\
		rn_mkfreelist = (m)->rm_mklist;				\
	} else								\
		R_Malloc(m, struct radix_mask *, sizeof (*(m)));	\
} while (0)

#define MKFree(m) do {							\
	(m)->rm_mklist = rn_mkfreelist;					\
	rn_mkfreelist = (m);						\
} while (0)

a121 4
#define Bcmp(a, b, n) bcmp(((caddr_t)(a)), ((caddr_t)(b)), (unsigned)(n))
#define Bzero(p, n) bzero((caddr_t)(p), (unsigned)(n));
#define R_Malloc(p, t, n) (p = (t) malloc((unsigned long)(n), M_RTABLE, M_NOWAIT))
#define Free(p) free((caddr_t)p, M_RTABLE);
@


1.20
log
@Move more stuff under _KERNEL
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.19 2012/12/28 17:52:06 gsoares Exp $	*/
a135 1
#define Bcopy(a, b, n) bcopy(((caddr_t)(a)), ((caddr_t)(b)), (unsigned)(n))
@


1.19
log
@change the malloc(9) flags from M_DONTWAIT to M_NOWAIT; OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.18 2012/07/10 15:53:34 blambert Exp $	*/
d157 1
@


1.18
log
@Place declarations for internal radix functions inside radix.c, stop
exporting them to the outside world via radix.h.

ok claudio@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.17 2011/07/22 13:05:29 henning Exp $	*/
d138 1
a138 1
#define R_Malloc(p, t, n) (p = (t) malloc((unsigned long)(n), M_RTABLE, M_DONTWAIT))
@


1.17
log
@fix typos, martin pelikan
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.16 2010/06/28 18:50:37 claudio Exp $	*/
a152 2
struct radix_node	*rn_insert(void *, struct radix_node_head *, int *,
			    struct radix_node [2]);
d155 1
a155 3
struct radix_node	*rn_newpair(void *, int, struct radix_node[2]);
struct radix_node	*rn_search(void *, struct radix_node *);
struct radix_node	*rn_search_m(void *, struct radix_node *, void *);
@


1.16
log
@Add the rtable id as an argument to rn_walktree(). Functions like
rt_if_remove_rtdelete() need to know the table id to be able to correctly
remove nodes.
Problem found by Andrea Parazzini and analyzed by Martin Pelikán.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.15 2008/11/07 19:09:03 deraadt Exp $	*/
d131 1
a131 1
	u_int	rnh_rtabelid;
@


1.15
log
@use do { } while (/* CONSTCOND */ 0) construct for all multi-line functional macros; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.14 2008/05/07 05:14:21 claudio Exp $	*/
d128 1
a128 1
		     int (*)(struct radix_node *, void *), void *);
d131 1
d146 1
a146 1
	    int (*)(struct radix_node *, void *), void *);
@


1.14
log
@Implement routing priorities. Every route inserted has a priority assigned
and the one route with the lowest number wins. This will be used by the
routing daemons to resolve the synchronisations issue in case of conflicts.
The nasty bits of this are in the multipath code. If no priority is specified
the kernel will choose an appropriate priority.

Looked at by a few people at n2k8 code is much older
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.13 2006/06/16 15:50:28 claudio Exp $	*/
d96 12
a107 8
#define MKGet(m) {\
	if (rn_mkfreelist) {\
		m = rn_mkfreelist; \
		rn_mkfreelist = (m)->rm_mklist; \
	} else \
		R_Malloc(m, struct radix_mask *, sizeof (*(m))); }\

#define MKFree(m) { (m)->rm_mklist = rn_mkfreelist; rn_mkfreelist = (m);}
@


1.13
log
@Cleanup radix.c, remove unused stuff, use nicer prototype definitions and
remove the ugly routed hacks. OK henning@@, hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.12 2004/04/25 02:48:03 itojun Exp $	*/
d111 2
a112 1
		     struct radix_node_head *head, struct radix_node nodes[]);
d145 1
a145 1
			    struct radix_node [2]);
@


1.12
log
@radix tree with multipath support.  from kame.  deraadt ok
user visible changes:
- you can add multiple routes with same key (route add A B then route add A C)
- you have to specify gateway address if there are multiple entries on the table
  (route delete A B, instead of route delete A)
kernel change:
- radix_node_head has an extra entry
- rnh_deladdr takes extra argument

TODO:
- actually take advantage of multipath (rtalloc -> rtalloc_mpath)
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.11 2004/04/25 01:38:10 brad Exp $	*/
a111 3
					/* add based on packet hdr */
	struct	radix_node *(*rnh_addpkt)(void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]);
a114 3
					/* remove based on packet hdr */
	struct	radix_node *(*rnh_delpkt)(void *v, void *mask,
		    struct radix_node_head *head);
a120 3
					/* locate based on packet hdr */
	struct	radix_node *(*rnh_matchpkt)(void *v,
		    struct radix_node_head *head);
d128 1
a128 8

#ifndef _KERNEL
#define Bcmp(a, b, n) bcmp(((char *)(a)), ((char *)(b)), (n))
#define Bcopy(a, b, n) bcopy(((char *)(a)), ((char *)(b)), (unsigned)(n))
#define Bzero(p, n) bzero((char *)(p), (int)(n));
#define R_Malloc(p, t, n) (p = (t) malloc((unsigned int)(n)))
#define Free(p) free((char *)p);
#else
a133 1
#endif /* !_KERNEL */
d135 20
a154 21
#if defined(_KERNEL) || defined(_ROUTED)
void	 rn_init(void);
int	 rn_inithead(void **, int);
int	 rn_inithead0(struct radix_node_head *, int);
int	 rn_refines(void *, void *);
int	 rn_walktree(struct radix_node_head *,
			  int (*)(struct radix_node *, void *), void *);
struct radix_node
	 *rn_addmask(void *, int, int),
	 *rn_addroute(void *, void *, struct radix_node_head *,
			struct radix_node [2]),
	 *rn_delete(void *, void *, struct radix_node_head *,
			struct radix_node *),
	 *rn_insert(void *, struct radix_node_head *, int *,
			struct radix_node [2]),
	 *rn_lookup(void *, void *, struct radix_node_head *),
	 *rn_match(void *, struct radix_node_head *),
	 *rn_newpair(void *, int, struct radix_node[2]),
	 *rn_search(void *, struct radix_node *),
	 *rn_search_m(void *, struct radix_node *, void *);
#endif /* define(_KERNEL) || defined(_ROUTED) */
@


1.11
log
@sync with NetBSD, mostly a Lite2 merge.

ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.10 2003/08/27 00:33:34 henric Exp $	*/
d117 1
a117 1
		    struct radix_node_head *head);
d134 1
d163 2
a164 1
	 *rn_delete(void *, void *, struct radix_node_head *),
@


1.10
log
@RNF_IGNORE can corrupt the radix tree when an interface is down, it
makes routing lookups slightly more expensive, and serves no useful
purpose.

ok itojun@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.9 2003/06/02 23:28:12 millert Exp $	*/
d62 1
a62 1
	}	rn_u;
d154 1
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.8 2002/03/15 01:20:04 millert Exp $	*/
a50 1
#define RNF_IGNORE	8		/* Ignore this entry (for if down) */
@


1.8
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.7 2002/03/14 03:16:10 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.6 2002/03/14 01:27:10 millert Exp $	*/
d114 2
a115 1
	struct	radix_node *(*rnh_addaddr)	/* add based on sockaddr */(void *v, void *mask,
d117 2
a118 1
	struct	radix_node *(*rnh_addpkt)	/* add based on packet hdr */(void *v, void *mask,
d120 17
a136 7
	struct	radix_node *(*rnh_deladdr)	/* remove based on sockaddr */(void *v, void *mask, struct radix_node_head *head);
	struct	radix_node *(*rnh_delpkt)	/* remove based on packet hdr */(void *v, void *mask, struct radix_node_head *head);
	struct	radix_node *(*rnh_matchaddr)	/* locate based on sockaddr */(void *v, struct radix_node_head *head);
	struct	radix_node *(*rnh_lookup)	/* locate based on sockaddr */(void *v, void *mask, struct radix_node_head *head);
	struct	radix_node *(*rnh_matchpkt)	/* locate based on packet hdr */(void *v, struct radix_node_head *head);
	int	(*rnh_walktree)			/* traverse tree */
		(struct radix_node_head *,
d138 1
a138 1
	struct	radix_node rnh_nodes[3];	/* empty tree for common case */
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.5 2001/06/09 06:16:39 angelos Exp $	*/
d124 2
a125 2
		__P((struct radix_node_head *,
		     int (*)(struct radix_node *, void *), void *));
d148 2
a149 2
int	 rn_walktree __P((struct radix_node_head *,
			  int (*)(struct radix_node *, void *), void *));
@


1.5
log
@By popular demand, protect from multiple inclusion, and fix to use the
same naming style.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.4 2000/06/17 20:30:34 provos Exp $	*/
d114 9
a122 16
	struct	radix_node *(*rnh_addaddr)	/* add based on sockaddr */
		__P((void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]));
	struct	radix_node *(*rnh_addpkt)	/* add based on packet hdr */
		__P((void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]));
	struct	radix_node *(*rnh_deladdr)	/* remove based on sockaddr */
		__P((void *v, void *mask, struct radix_node_head *head));
	struct	radix_node *(*rnh_delpkt)	/* remove based on packet hdr */
		__P((void *v, void *mask, struct radix_node_head *head));
	struct	radix_node *(*rnh_matchaddr)	/* locate based on sockaddr */
		__P((void *v, struct radix_node_head *head));
	struct	radix_node *(*rnh_lookup)	/* locate based on sockaddr */
		__P((void *v, void *mask, struct radix_node_head *head));
	struct	radix_node *(*rnh_matchpkt)	/* locate based on packet hdr */
		__P((void *v, struct radix_node_head *head));
d145 3
a147 3
void	 rn_init __P((void));
int	 rn_inithead __P((void **, int));
int	 rn_refines __P((void *, void *));
d151 11
a161 11
	 *rn_addmask __P((void *, int, int)),
	 *rn_addroute __P((void *, void *, struct radix_node_head *,
			struct radix_node [2])),
	 *rn_delete __P((void *, void *, struct radix_node_head *)),
	 *rn_insert __P((void *, struct radix_node_head *, int *,
			struct radix_node [2])),
	 *rn_lookup __P((void *, void *, struct radix_node_head *)),
	 *rn_match __P((void *, struct radix_node_head *)),
	 *rn_newpair __P((void *, int, struct radix_node[2])),
	 *rn_search __P((void *, struct radix_node *)),
	 *rn_search_m __P((void *, struct radix_node *, void *));
@


1.5.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.5 2001/06/09 06:16:39 angelos Exp $	*/
d114 20
a133 25
					/* add based on sockaddr */
	struct	radix_node *(*rnh_addaddr)(void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]);
					/* add based on packet hdr */
	struct	radix_node *(*rnh_addpkt)(void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]);
					/* remove based on sockaddr */
	struct	radix_node *(*rnh_deladdr)(void *v, void *mask,
		    struct radix_node_head *head);
					/* remove based on packet hdr */
	struct	radix_node *(*rnh_delpkt)(void *v, void *mask,
		    struct radix_node_head *head);
					/* locate based on sockaddr */
	struct	radix_node *(*rnh_matchaddr)(void *v,
		    struct radix_node_head *head);
					/* locate based on sockaddr */
	struct	radix_node *(*rnh_lookup)(void *v, void *mask,
		    struct radix_node_head *head);
					/* locate based on packet hdr */
	struct	radix_node *(*rnh_matchpkt)(void *v,
		    struct radix_node_head *head);
					/* traverse tree */
	int	(*rnh_walktree)(struct radix_node_head *,
		     int (*)(struct radix_node *, void *), void *);
	struct	radix_node rnh_nodes[3];/* empty tree for common case */
d152 5
a156 5
void	 rn_init(void);
int	 rn_inithead(void **, int);
int	 rn_refines(void *, void *);
int	 rn_walktree(struct radix_node_head *,
			  int (*)(struct radix_node *, void *), void *);
d158 11
a168 11
	 *rn_addmask(void *, int, int),
	 *rn_addroute(void *, void *, struct radix_node_head *,
			struct radix_node [2]),
	 *rn_delete(void *, void *, struct radix_node_head *),
	 *rn_insert(void *, struct radix_node_head *, int *,
			struct radix_node [2]),
	 *rn_lookup(void *, void *, struct radix_node_head *),
	 *rn_match(void *, struct radix_node_head *),
	 *rn_newpair(void *, int, struct radix_node[2]),
	 *rn_search(void *, struct radix_node *),
	 *rn_search_m(void *, struct radix_node *, void *);
@


1.4
log
@on ifconfig down ignore all routes pointing to the downed interface.
okay itojun@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.3 1996/09/05 08:42:34 mickey Exp $	*/
d170 1
a170 2

#endif /* !_NET_RADIX_H_ */
@


1.3
log
@remove ';' after function close '}'
make it nicer w/ new routed.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.2 1996/03/03 21:07:15 niklas Exp $	*/
d55 1
@


1.3.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.4 2000/06/17 20:30:34 provos Exp $	*/
a54 1
#define RNF_IGNORE	8		/* Ignore this entry (for if down) */
@


1.3.16.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.3.16.1 2001/05/14 22:40:04 niklas Exp $	*/
d170 2
a171 1
#endif /* _NET_RADIX_H_ */
@


1.3.16.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d114 20
a133 25
					/* add based on sockaddr */
	struct	radix_node *(*rnh_addaddr)(void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]);
					/* add based on packet hdr */
	struct	radix_node *(*rnh_addpkt)(void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]);
					/* remove based on sockaddr */
	struct	radix_node *(*rnh_deladdr)(void *v, void *mask,
		    struct radix_node_head *head);
					/* remove based on packet hdr */
	struct	radix_node *(*rnh_delpkt)(void *v, void *mask,
		    struct radix_node_head *head);
					/* locate based on sockaddr */
	struct	radix_node *(*rnh_matchaddr)(void *v,
		    struct radix_node_head *head);
					/* locate based on sockaddr */
	struct	radix_node *(*rnh_lookup)(void *v, void *mask,
		    struct radix_node_head *head);
					/* locate based on packet hdr */
	struct	radix_node *(*rnh_matchpkt)(void *v,
		    struct radix_node_head *head);
					/* traverse tree */
	int	(*rnh_walktree)(struct radix_node_head *,
		     int (*)(struct radix_node *, void *), void *);
	struct	radix_node rnh_nodes[3];/* empty tree for common case */
d152 5
a156 5
void	 rn_init(void);
int	 rn_inithead(void **, int);
int	 rn_refines(void *, void *);
int	 rn_walktree(struct radix_node_head *,
			  int (*)(struct radix_node *, void *), void *);
d158 11
a168 11
	 *rn_addmask(void *, int, int),
	 *rn_addroute(void *, void *, struct radix_node_head *,
			struct radix_node [2]),
	 *rn_delete(void *, void *, struct radix_node_head *),
	 *rn_insert(void *, struct radix_node_head *, int *,
			struct radix_node [2]),
	 *rn_lookup(void *, void *, struct radix_node_head *),
	 *rn_match(void *, struct radix_node_head *),
	 *rn_newpair(void *, int, struct radix_node[2]),
	 *rn_search(void *, struct radix_node *),
	 *rn_search_m(void *, struct radix_node *, void *);
@


1.3.16.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: radix.h,v 1.3.16.3 2002/03/28 14:57:37 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.16.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
@


1.3.16.6
log
@Merge with the trunk
@
text
@d62 1
a62 1
	} rn_u;
d117 1
a117 1
		    struct radix_node_head *head, struct radix_node *rn);
a133 1
	int	rnh_multipath;		/* multipath? */
a153 1
int	 rn_inithead0(struct radix_node_head *, int);
d161 1
a161 2
	 *rn_delete(void *, void *, struct radix_node_head *,
			struct radix_node *),
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d148 1
d150 1
d168 1
a168 1
#endif /* !_KERNEL */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: radix.h,v 1.7 1995/05/17 15:50:08 mycroft Exp $	*/
d130 2
a131 1
		__P((struct radix_node_head *head, int (*f)(), void *w));
d152 2
a153 1
int	 rn_walktree __P((struct radix_node_head *, int (*)(), void *));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
