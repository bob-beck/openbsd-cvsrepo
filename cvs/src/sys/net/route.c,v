head	1.365;
access;
symbols
	OPENBSD_6_1:1.354.0.4
	OPENBSD_6_1_BASE:1.354
	OPENBSD_6_0:1.313.0.4
	OPENBSD_6_0_BASE:1.313
	OPENBSD_5_9:1.295.0.2
	OPENBSD_5_9_BASE:1.295
	OPENBSD_5_8:1.217.0.4
	OPENBSD_5_8_BASE:1.217
	OPENBSD_5_7:1.207.0.2
	OPENBSD_5_7_BASE:1.207
	OPENBSD_5_6:1.175.0.4
	OPENBSD_5_6_BASE:1.175
	OPENBSD_5_5:1.153.0.4
	OPENBSD_5_5_BASE:1.153
	OPENBSD_5_4:1.144.0.2
	OPENBSD_5_4_BASE:1.144
	OPENBSD_5_3:1.141.0.2
	OPENBSD_5_3_BASE:1.141
	OPENBSD_5_2:1.137.0.2
	OPENBSD_5_2_BASE:1.137
	OPENBSD_5_1_BASE:1.135
	OPENBSD_5_1:1.135.0.2
	OPENBSD_5_0:1.132.0.2
	OPENBSD_5_0_BASE:1.132
	OPENBSD_4_9:1.128.0.2
	OPENBSD_4_9_BASE:1.128
	OPENBSD_4_8:1.125.0.2
	OPENBSD_4_8_BASE:1.125
	OPENBSD_4_7:1.115.0.2
	OPENBSD_4_7_BASE:1.115
	OPENBSD_4_6:1.109.0.4
	OPENBSD_4_6_BASE:1.109
	OPENBSD_4_5:1.104.0.2
	OPENBSD_4_5_BASE:1.104
	OPENBSD_4_4:1.95.0.2
	OPENBSD_4_4_BASE:1.95
	OPENBSD_4_3:1.87.0.2
	OPENBSD_4_3_BASE:1.87
	OPENBSD_4_2:1.84.0.2
	OPENBSD_4_2_BASE:1.84
	OPENBSD_4_1:1.81.0.4
	OPENBSD_4_1_BASE:1.81
	OPENBSD_4_0:1.81.0.2
	OPENBSD_4_0_BASE:1.81
	OPENBSD_3_9:1.63.0.2
	OPENBSD_3_9_BASE:1.63
	OPENBSD_3_8:1.54.0.2
	OPENBSD_3_8_BASE:1.54
	OPENBSD_3_7:1.50.0.2
	OPENBSD_3_7_BASE:1.50
	OPENBSD_3_6:1.49.0.2
	OPENBSD_3_6_BASE:1.49
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.41
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	UBC_SYNC_A:1.35
	OPENBSD_3_3:1.35.0.2
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.34
	UBC:1.27.0.2
	UBC_BASE:1.27
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	SMP:1.16.0.2
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.365
date	2017.08.02.07.42.11;	author mpi;	state Exp;
branches;
next	1.364;
commitid	8Aly3cwgEVQUOxip;

1.364
date	2017.07.30.18.18.08;	author florian;	state Exp;
branches;
next	1.363;
commitid	y8TT4YTxTvaF1bH8;

1.363
date	2017.07.30.18.16.14;	author florian;	state Exp;
branches;
next	1.362;
commitid	z0X2vKcxAWZuAxov;

1.362
date	2017.07.28.09.01.09;	author mpi;	state Exp;
branches;
next	1.361;
commitid	iy2G1kqVrXelHlw4;

1.361
date	2017.07.27.12.27.24;	author mpi;	state Exp;
branches;
next	1.360;
commitid	ozf3o60LM4kiygD4;

1.360
date	2017.07.24.09.20.32;	author mpi;	state Exp;
branches;
next	1.359;
commitid	pypIK0AyzCYk4rbB;

1.359
date	2017.06.09.12.56.43;	author mpi;	state Exp;
branches;
next	1.358;
commitid	QXIy2rZA5FPYfFIG;

1.358
date	2017.06.07.13.28.02;	author mpi;	state Exp;
branches;
next	1.357;
commitid	c48G09HN6s8XE6t3;

1.357
date	2017.05.27.09.51.18;	author claudio;	state Exp;
branches;
next	1.356;
commitid	wTAyy381CzjdeLej;

1.356
date	2017.05.16.12.24.01;	author mpi;	state Exp;
branches;
next	1.355;
commitid	SAe3SQ48vKH6r5FL;

1.355
date	2017.04.19.15.21.54;	author bluhm;	state Exp;
branches;
next	1.354;
commitid	86fZyVCZMRPZ29Fb;

1.354
date	2017.03.06.08.56.39;	author mpi;	state Exp;
branches;
next	1.353;
commitid	aDXuIkVsOPuafbD0;

1.353
date	2017.03.02.03.09.50;	author renato;	state Exp;
branches;
next	1.352;
commitid	15KE7F69zvHLMIyM;

1.352
date	2017.02.28.10.16.38;	author mpi;	state Exp;
branches;
next	1.351;
commitid	1MTgffo80QNP9gz7;

1.351
date	2017.02.15.18.53.29;	author bluhm;	state Exp;
branches;
next	1.350;
commitid	d023mNbncBsC7RAg;

1.350
date	2017.02.05.16.23.38;	author jca;	state Exp;
branches;
next	1.349;
commitid	b4PzKhPOLWkSDY9t;

1.349
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.348;
commitid	6c6qq5OdS4VVnyVM;

1.348
date	2017.01.24.04.45.35;	author phessler;	state Exp;
branches;
next	1.347;
commitid	uLGuXUQB5pEdL1x8;

1.347
date	2017.01.20.08.10.54;	author dlg;	state Exp;
branches;
next	1.346;
commitid	CNOX7FmsAKFjfz9O;

1.346
date	2017.01.19.04.06.26;	author phessler;	state Exp;
branches;
next	1.345;
commitid	MArKjXJKT1Tz41F6;

1.345
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.344;
commitid	QqHqT2WhCBWqYgGJ;

1.344
date	2016.12.17.14.26.53;	author mpi;	state Exp;
branches;
next	1.343;
commitid	77UvAVasoURJZmR6;

1.343
date	2016.12.14.20.35.20;	author stsp;	state Exp;
branches;
next	1.342;
commitid	27RhKD7QWaZXKCfA;

1.342
date	2016.12.04.09.46.39;	author stsp;	state Exp;
branches;
next	1.341;
commitid	QEDs9nuBjrCn0scE;

1.341
date	2016.12.02.11.19.17;	author mpi;	state Exp;
branches;
next	1.340;
commitid	spxMCD1Ha2K5VmwT;

1.340
date	2016.11.29.10.22.30;	author jsg;	state Exp;
branches;
next	1.339;
commitid	ZQetSMB5ilG2z10X;

1.339
date	2016.11.21.10.30.42;	author mpi;	state Exp;
branches;
next	1.338;
commitid	dsunvxH1DSUUN1eT;

1.338
date	2016.11.15.10.09.28;	author mpi;	state Exp;
branches;
next	1.337;
commitid	MFiyLck2CS5n94z9;

1.337
date	2016.11.14.12.45.30;	author mpi;	state Exp;
branches;
next	1.336;
commitid	hsxRQq9tdGw3cYpk;

1.336
date	2016.11.14.10.32.46;	author mpi;	state Exp;
branches;
next	1.335;
commitid	to0Je2i4V2FtpmS1;

1.335
date	2016.11.09.09.04.48;	author mpi;	state Exp;
branches;
next	1.334;
commitid	zv2B8XroCnaWYTvP;

1.334
date	2016.11.08.10.39.32;	author mpi;	state Exp;
branches;
next	1.333;
commitid	w4Gv21KtfyDgGNau;

1.333
date	2016.10.06.19.09.08;	author bluhm;	state Exp;
branches;
next	1.332;
commitid	IO8dsedjngxSg7J1;

1.332
date	2016.10.05.08.07.46;	author mpi;	state Exp;
branches;
next	1.331;
commitid	L5jTvy97I1N7acbr;

1.331
date	2016.10.04.14.04.19;	author mpi;	state Exp;
branches;
next	1.330;
commitid	gXQbDuFtHAj5VAfn;

1.330
date	2016.09.17.07.35.05;	author phessler;	state Exp;
branches;
next	1.329;
commitid	XybSw76BMA6y6rFn;

1.329
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.328;
commitid	RlO92XR575sygHqm;

1.328
date	2016.09.13.08.11.39;	author mpi;	state Exp;
branches;
next	1.327;
commitid	fiKWkCzatfL8oZcZ;

1.327
date	2016.09.08.09.11.43;	author mpi;	state Exp;
branches;
next	1.326;
commitid	biIw339ydR5mbWzJ;

1.326
date	2016.09.07.09.19.38;	author mpi;	state Exp;
branches;
next	1.325;
commitid	9fVVmzwGQ0PCp638;

1.325
date	2016.09.04.15.45.42;	author bluhm;	state Exp;
branches;
next	1.324;
commitid	kyA0Iv7ShwfAasmI;

1.324
date	2016.09.04.10.32.01;	author mpi;	state Exp;
branches;
next	1.323;
commitid	0JNLzz71W0Jm1WWQ;

1.323
date	2016.09.04.09.39.01;	author claudio;	state Exp;
branches;
next	1.322;
commitid	WcOp57BWVEJv93S4;

1.322
date	2016.09.03.14.20.26;	author phessler;	state Exp;
branches;
next	1.321;
commitid	m9T2f1BYzcUNRKPY;

1.321
date	2016.09.01.15.40.38;	author bluhm;	state Exp;
branches;
next	1.320;
commitid	8OxPuM4YcwHRFZy9;

1.320
date	2016.09.01.11.26.44;	author mpi;	state Exp;
branches;
next	1.319;
commitid	D9xUXuCVpAub3X0F;

1.319
date	2016.08.31.08.13.17;	author mpi;	state Exp;
branches;
next	1.318;
commitid	tRtOV3J3CJkKWyHY;

1.318
date	2016.08.30.23.29.39;	author dlg;	state Exp;
branches;
next	1.317;
commitid	c5SjbZ19I7gBvQZB;

1.317
date	2016.08.22.16.53.59;	author mpi;	state Exp;
branches;
next	1.316;
commitid	WKhPwyFDoZKlmBjP;

1.316
date	2016.08.22.16.01.52;	author mpi;	state Exp;
branches;
next	1.315;
commitid	Jx7agqiuXqs8RRGd;

1.315
date	2016.08.19.07.12.54;	author mpi;	state Exp;
branches;
next	1.314;
commitid	AJAjIW5z9tjrO3JT;

1.314
date	2016.08.16.09.01.14;	author mpi;	state Exp;
branches;
next	1.313;
commitid	kP4dOGxgzIWRYLmC;

1.313
date	2016.07.22.11.03.30;	author mpi;	state Exp;
branches;
next	1.312;
commitid	H9MCbA95MqCQ2moW;

1.312
date	2016.07.19.10.26.41;	author mpi;	state Exp;
branches;
next	1.311;
commitid	sWrKSlUK6tG3veUE;

1.311
date	2016.07.11.13.06.31;	author bluhm;	state Exp;
branches;
next	1.310;
commitid	s9vCFtJQBVcyR7KD;

1.310
date	2016.07.11.09.23.06;	author mpi;	state Exp;
branches;
next	1.309;
commitid	Z6QboMLW08GSdJ1F;

1.309
date	2016.06.14.09.48.52;	author mpi;	state Exp;
branches;
next	1.308;
commitid	dn8iB9zOSqejUgHj;

1.308
date	2016.06.14.09.44.41;	author mpi;	state Exp;
branches;
next	1.307;
commitid	jROApUVEsAXWIH7k;

1.307
date	2016.06.08.13.26.06;	author mpi;	state Exp;
branches;
next	1.306;
commitid	mpheQ41H2EUDpK1N;

1.306
date	2016.06.07.08.30.01;	author mpi;	state Exp;
branches;
next	1.305;
commitid	iEjOBpxsPFT8EwgE;

1.305
date	2016.06.03.10.34.07;	author mpi;	state Exp;
branches;
next	1.304;
commitid	AvyVPDZv2dJeOTvc;

1.304
date	2016.06.03.02.56.59;	author dlg;	state Exp;
branches;
next	1.303;
commitid	HDQtg6ec5B2YoCBq;

1.303
date	2016.06.01.06.40.27;	author dlg;	state Exp;
branches;
next	1.302;
commitid	TLTxlRvCZ3fIiHxs;

1.302
date	2016.05.31.07.42.39;	author mpi;	state Exp;
branches;
next	1.301;
commitid	xheSJoYLzM60cNlz;

1.301
date	2016.05.31.07.29.34;	author mpi;	state Exp;
branches;
next	1.300;
commitid	TRjHA6MBBHfUd8J1;

1.300
date	2016.05.02.22.15.49;	author jmatthew;	state Exp;
branches;
next	1.299;
commitid	Qe5v796bHPmQNEGf;

1.299
date	2016.04.27.14.47.27;	author mpi;	state Exp;
branches;
next	1.298;
commitid	ZVQDfnkyjDaQ3PD4;

1.298
date	2016.03.26.21.56.04;	author mpi;	state Exp;
branches;
next	1.297;
commitid	vJtQRrj5mFxFKXT0;

1.297
date	2016.03.26.21.41.18;	author mpi;	state Exp;
branches;
next	1.296;
commitid	Yq9ws3dOqiiOS9jT;

1.296
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.295;
commitid	Z6e4eqr6FuYFPnlL;

1.295
date	2016.02.26.07.54.39;	author deraadt;	state Exp;
branches;
next	1.294;
commitid	7Bf78Ad5W7tWbq65;

1.294
date	2016.02.24.22.41.53;	author mpi;	state Exp;
branches;
next	1.293;
commitid	eJx9U9f0eROcBU02;

1.293
date	2015.12.21.10.51.55;	author mpi;	state Exp;
branches;
next	1.292;
commitid	GLrMQPKEtr2rJZmH;

1.292
date	2015.12.11.08.58.23;	author mpi;	state Exp;
branches;
next	1.291;
commitid	xMorTtkNXsCCY1aU;

1.291
date	2015.12.09.09.23.08;	author mpi;	state Exp;
branches;
next	1.290;
commitid	VIp1KUuxB5NDdJ2m;

1.290
date	2015.12.09.09.02.02;	author mpi;	state Exp;
branches;
next	1.289;
commitid	po1LkuVtOgaplQKb;

1.289
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.288;
commitid	ILbVM1M3uPNjwswz;

1.288
date	2015.12.04.13.42.48;	author mpi;	state Exp;
branches;
next	1.287;
commitid	3gDu3mmUYYoaLpwn;

1.287
date	2015.12.03.21.57.59;	author mpi;	state Exp;
branches;
next	1.286;
commitid	nmbu8xP0zmz2PPN0;

1.286
date	2015.12.03.14.55.17;	author vgross;	state Exp;
branches;
next	1.285;
commitid	DukW6jeSHPpp8ZFD;

1.285
date	2015.12.03.14.26.27;	author mpi;	state Exp;
branches;
next	1.284;
commitid	8hGelczr1KICPBjU;

1.284
date	2015.12.03.14.19.55;	author mpi;	state Exp;
branches;
next	1.283;
commitid	Hw0CeagIhkCLzao6;

1.283
date	2015.12.02.16.49.58;	author bluhm;	state Exp;
branches;
next	1.282;
commitid	SB6GJECP4v4xqpvF;

1.282
date	2015.12.02.16.35.52;	author bluhm;	state Exp;
branches;
next	1.281;
commitid	i3XNpYhaQ8QndxLo;

1.281
date	2015.12.02.13.29.26;	author claudio;	state Exp;
branches;
next	1.280;
commitid	Hf3C2AvfIXmCAmHE;

1.280
date	2015.12.02.10.33.15;	author blambert;	state Exp;
branches;
next	1.279;
commitid	w1r96HtncG7YDkDP;

1.279
date	2015.12.02.09.17.47;	author mpi;	state Exp;
branches;
next	1.278;
commitid	qJCvM1BEJpKmZS7r;

1.278
date	2015.12.01.21.26.43;	author mpi;	state Exp;
branches;
next	1.277;
commitid	XfTOZsoiIJCcV93d;

1.277
date	2015.11.27.11.52.44;	author mpi;	state Exp;
branches;
next	1.276;
commitid	b6yEC4HO3KJwk5bP;

1.276
date	2015.11.23.10.52.43;	author mpi;	state Exp;
branches;
next	1.275;
commitid	UywgOyMnPH4kBv9g;

1.275
date	2015.11.20.13.12.14;	author jsg;	state Exp;
branches;
next	1.274;
commitid	HQVFBlfTpty9VvI1;

1.274
date	2015.11.18.14.13.52;	author mpi;	state Exp;
branches;
next	1.273;
commitid	a6JUdrfdhORyb0Np;

1.273
date	2015.11.18.13.05.58;	author mpi;	state Exp;
branches;
next	1.272;
commitid	7an8BPA21rELHV9E;

1.272
date	2015.11.18.12.45.59;	author mpi;	state Exp;
branches;
next	1.271;
commitid	nIzuRB3tADawhHBA;

1.271
date	2015.11.17.10.28.24;	author mpi;	state Exp;
branches;
next	1.270;
commitid	g16LJzH1oiViJNTw;

1.270
date	2015.11.11.11.25.16;	author mpi;	state Exp;
branches;
next	1.269;
commitid	4QHZVRDpVBWrikrc;

1.269
date	2015.11.09.10.26.26;	author mpi;	state Exp;
branches;
next	1.268;
commitid	xyXAt3vnFrCMLsjZ;

1.268
date	2015.11.04.10.13.55;	author mpi;	state Exp;
branches;
next	1.267;
commitid	Oc3Ukz7b9dDrzxGQ;

1.267
date	2015.11.02.14.40.09;	author mpi;	state Exp;
branches;
next	1.266;
commitid	RcfM7kXINWo9mOSk;

1.266
date	2015.10.30.09.39.42;	author bluhm;	state Exp;
branches;
next	1.265;
commitid	7wrRch1SS813fOcY;

1.265
date	2015.10.25.16.25.23;	author mpi;	state Exp;
branches;
next	1.264;
commitid	SLt00CvS6Obxq3nY;

1.264
date	2015.10.25.15.24.03;	author mpi;	state Exp;
branches;
next	1.263;
commitid	Df4ZvXK2PvtdyEEO;

1.263
date	2015.10.25.14.48.51;	author mpi;	state Exp;
branches;
next	1.262;
commitid	K8LYM6fzMmJYhMbi;

1.262
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.261;
commitid	G2nTzngqgXpQqcJB;

1.261
date	2015.10.25.10.05.09;	author bluhm;	state Exp;
branches;
next	1.260;
commitid	X8Mu7F8ZYc1VV9Gs;

1.260
date	2015.10.24.11.58.46;	author mpi;	state Exp;
branches;
next	1.259;
commitid	JFhYU2VjHxiDHltL;

1.259
date	2015.10.23.14.48.22;	author mpi;	state Exp;
branches;
next	1.258;
commitid	48hhBVY4KFPUIKJg;

1.258
date	2015.10.22.17.19.38;	author mpi;	state Exp;
branches;
next	1.257;
commitid	AaBRgz5QXsDW1oOO;

1.257
date	2015.10.22.16.49.26;	author mpi;	state Exp;
branches;
next	1.256;
commitid	iF5pxB5mJQyTo0iT;

1.256
date	2015.10.22.16.32.41;	author mpi;	state Exp;
branches;
next	1.255;
commitid	DexMWsZTRJL5gTNG;

1.255
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.254;
commitid	tp9bS9eCrwvRYjyO;

1.254
date	2015.10.21.08.21.06;	author mpi;	state Exp;
branches;
next	1.253;
commitid	71TdgU4IlI6Af8t3;

1.253
date	2015.10.16.12.36.02;	author mpi;	state Exp;
branches;
next	1.252;
commitid	a1X6l9sELONMc7ZU;

1.252
date	2015.10.14.10.18.03;	author mpi;	state Exp;
branches;
next	1.251;
commitid	a1b9MtjA17Q42mhh;

1.251
date	2015.10.14.10.09.30;	author mpi;	state Exp;
branches;
next	1.250;
commitid	PpW3O2bSAUrWDZcl;

1.250
date	2015.10.13.09.59.37;	author mpi;	state Exp;
branches;
next	1.249;
commitid	CQ73hoDsHjSnt7tt;

1.249
date	2015.10.07.10.50.35;	author mpi;	state Exp;
branches;
next	1.248;
commitid	hPrd2a6fiZdlN2yP;

1.248
date	2015.10.07.08.58.01;	author mpi;	state Exp;
branches;
next	1.247;
commitid	GKoAXayYcFsVd0Gd;

1.247
date	2015.10.07.08.43.36;	author mpi;	state Exp;
branches;
next	1.246;
commitid	iugr8QHoKuxcwPS9;

1.246
date	2015.10.01.22.21.48;	author mpi;	state Exp;
branches;
next	1.245;
commitid	YkrRUeFWUffUvtHv;

1.245
date	2015.09.30.10.47.39;	author mpi;	state Exp;
branches;
next	1.244;
commitid	WUO1sRUMphq24umq;

1.244
date	2015.09.28.08.36.24;	author mpi;	state Exp;
branches;
next	1.243;
commitid	wT9nmVgN3CsJH8u1;

1.243
date	2015.09.25.09.51.20;	author mpi;	state Exp;
branches;
next	1.242;
commitid	HqH3TPOggutnG6L9;

1.242
date	2015.09.23.08.49.46;	author mpi;	state Exp;
branches;
next	1.241;
commitid	24xqlqpNt9NPeWH3;

1.241
date	2015.09.22.10.05.00;	author mpi;	state Exp;
branches;
next	1.240;
commitid	4YNgwdy0uV5MHBHC;

1.240
date	2015.09.21.11.15.27;	author mpi;	state Exp;
branches;
next	1.239;
commitid	OOzPIn4D4L5WIenr;

1.239
date	2015.09.12.20.50.17;	author mpi;	state Exp;
branches;
next	1.238;
commitid	L7FukNYlBzoQuXvw;

1.238
date	2015.09.12.09.22.29;	author mpi;	state Exp;
branches;
next	1.237;
commitid	GAR4lJSojgv3R9c8;

1.237
date	2015.09.11.20.03.40;	author mpi;	state Exp;
branches;
next	1.236;
commitid	gdxQn9mvx6Ewpnzr;

1.236
date	2015.09.11.16.58.00;	author mpi;	state Exp;
branches;
next	1.235;
commitid	aN3TroyZ9FVMndjv;

1.235
date	2015.09.11.15.38.13;	author mpi;	state Exp;
branches;
next	1.234;
commitid	rmLkkl3INHr2Zsco;

1.234
date	2015.09.11.14.30.30;	author mpi;	state Exp;
branches;
next	1.233;
commitid	P3RUrOVTnmiTjRbk;

1.233
date	2015.09.10.17.35.46;	author dlg;	state Exp;
branches;
next	1.232;
commitid	ZNtQ4QcR5yS5VDfW;

1.232
date	2015.09.10.14.46.28;	author mpi;	state Exp;
branches;
next	1.231;
commitid	OvGNoUSFNycRTjL3;

1.231
date	2015.09.10.09.37.52;	author mpi;	state Exp;
branches;
next	1.230;
commitid	XtwwcD9BYqGnLyAl;

1.230
date	2015.09.04.08.43.39;	author mpi;	state Exp;
branches;
next	1.229;
commitid	qAevExm24QrBjVNL;

1.229
date	2015.09.03.09.50.26;	author mpi;	state Exp;
branches;
next	1.228;
commitid	8rD51WItUHq3rt2G;

1.228
date	2015.09.01.12.50.03;	author mpi;	state Exp;
branches;
next	1.227;
commitid	0rQttR3JylvtHQ0K;

1.227
date	2015.09.01.10.04.51;	author mpi;	state Exp;
branches;
next	1.226;
commitid	Icddi8rbttFIkqFj;

1.226
date	2015.08.30.10.39.16;	author mpi;	state Exp;
branches;
next	1.225;
commitid	avqdJydG8T8nvZhe;

1.225
date	2015.08.24.22.11.33;	author mpi;	state Exp;
branches;
next	1.224;
commitid	QLnmQaxOCmSULhEv;

1.224
date	2015.08.20.12.39.43;	author mpi;	state Exp;
branches;
next	1.223;
commitid	9IUogeilRo73xUDL;

1.223
date	2015.08.19.13.27.38;	author bluhm;	state Exp;
branches;
next	1.222;
commitid	t09qBDKQRv4jxgp3;

1.222
date	2015.08.19.10.42.37;	author mpi;	state Exp;
branches;
next	1.221;
commitid	VgZybWQZHOVf8GJ4;

1.221
date	2015.08.18.08.56.16;	author mpi;	state Exp;
branches;
next	1.220;
commitid	1AXHLyAT7NLoSCk8;

1.220
date	2015.08.17.09.50.12;	author mpi;	state Exp;
branches;
next	1.219;
commitid	R7NILl50JTJbvuUH;

1.219
date	2015.08.17.09.46.26;	author mpi;	state Exp;
branches;
next	1.218;
commitid	fNl4s3YsXWND4yAQ;

1.218
date	2015.08.17.09.41.24;	author mpi;	state Exp;
branches;
next	1.217;
commitid	J0DhJ1uClgUyUF8p;

1.217
date	2015.07.18.15.51.16;	author mpi;	state Exp;
branches;
next	1.216;
commitid	lwQKRpFyNEr7kjoF;

1.216
date	2015.07.16.18.17.27;	author claudio;	state Exp;
branches;
next	1.215;
commitid	VvtF6H2REt7RsEKf;

1.215
date	2015.06.29.11.04.16;	author mpi;	state Exp;
branches;
next	1.214;
commitid	P2QaCmJp3tp6snOy;

1.214
date	2015.06.22.09.07.11;	author mpi;	state Exp;
branches;
next	1.213;
commitid	2wBSXWFFG8pT0IN8;

1.213
date	2015.06.06.09.31.53;	author mpi;	state Exp;
branches;
next	1.212;
commitid	s2reBV7hfZ6x326r;

1.212
date	2015.05.26.12.19.51;	author mpi;	state Exp;
branches;
next	1.211;
commitid	iiHJitHd0U6t7lGT;

1.211
date	2015.05.26.12.02.11;	author mpi;	state Exp;
branches;
next	1.210;
commitid	9WuU7h03HJbKgrHx;

1.210
date	2015.05.15.12.00.57;	author claudio;	state Exp;
branches;
next	1.209;
commitid	Gl6pqKOqk2n9Lwhq;

1.209
date	2015.04.20.09.12.57;	author mpi;	state Exp;
branches;
next	1.208;
commitid	oN2T1tH1giKH0MgY;

1.208
date	2015.03.26.11.02.44;	author mpi;	state Exp;
branches;
next	1.207;
commitid	0DQqDmKCmYNj6g7x;

1.207
date	2015.02.12.11.19.57;	author mpi;	state Exp;
branches;
next	1.206;
commitid	z5akXzNjffvMaGPy;

1.206
date	2015.02.11.23.34.43;	author mpi;	state Exp;
branches;
next	1.205;
commitid	LEl6vk7rMjn9Mb2M;

1.205
date	2015.02.10.03.04.11;	author claudio;	state Exp;
branches;
next	1.204;
commitid	ZqwJXzuhdTGTSQJf;

1.204
date	2015.02.06.01.21.17;	author mpi;	state Exp;
branches;
next	1.203;
commitid	hYUJkvmCO3leeXRT;

1.203
date	2015.01.28.22.10.13;	author mpi;	state Exp;
branches;
next	1.202;
commitid	qWMiETGHDs7AwODS;

1.202
date	2015.01.26.11.36.38;	author mpi;	state Exp;
branches;
next	1.201;
commitid	NSAyjfvYLg4aQbwC;

1.201
date	2015.01.21.21.32.42;	author bluhm;	state Exp;
branches;
next	1.200;
commitid	WMWDo66NjFAlQV2r;

1.200
date	2015.01.18.14.51.43;	author mpi;	state Exp;
branches;
next	1.199;
commitid	1qdSaYU79Q4iG4pX;

1.199
date	2015.01.13.12.14.00;	author mpi;	state Exp;
branches;
next	1.198;
commitid	lUGbXdgL8k5aX0xx;

1.198
date	2015.01.08.15.05.44;	author mpi;	state Exp;
branches;
next	1.197;
commitid	56pEz00yDFZe07F8;

1.197
date	2015.01.08.14.29.18;	author mpi;	state Exp;
branches;
next	1.196;
commitid	WNXddVtZkuvCWdN4;

1.196
date	2014.12.29.11.53.58;	author mpi;	state Exp;
branches;
next	1.195;
commitid	QooprkoePgkbwZ3p;

1.195
date	2014.12.19.18.57.17;	author bluhm;	state Exp;
branches;
next	1.194;
commitid	Y7cEc5OLE6eDnM7U;

1.194
date	2014.12.08.10.46.14;	author mpi;	state Exp;
branches;
next	1.193;
commitid	ExaN0TCQ4X0c1lo6;

1.193
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.192;
commitid	t9FBKDfc4VDxpEy2;

1.192
date	2014.12.02.18.11.56;	author tedu;	state Exp;
branches;
next	1.191;
commitid	R6VIBSqPh5FMhwGK;

1.191
date	2014.11.24.12.43.54;	author mpi;	state Exp;
branches;
next	1.190;
commitid	xHA3kihmdbMHtfu3;

1.190
date	2014.11.10.10.38.46;	author mpi;	state Exp;
branches;
next	1.189;
commitid	eYxsfRp5ftfIG9QM;

1.189
date	2014.11.04.15.24.40;	author mpi;	state Exp;
branches;
next	1.188;
commitid	7WMzGcppcCD2uLp0;

1.188
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.187;
commitid	w0MRp28dmfD1ZzO8;

1.187
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.186;
commitid	6AYfDT0Lpez1LFQp;

1.186
date	2014.10.08.07.37.02;	author mpi;	state Exp;
branches;
next	1.185;
commitid	Zq5kNn2HIZzyRxfQ;

1.185
date	2014.10.02.12.21.20;	author mpi;	state Exp;
branches;
next	1.184;
commitid	p4G1dFGgnr2OBvws;

1.184
date	2014.10.01.08.38.29;	author mpi;	state Exp;
branches;
next	1.183;
commitid	mkIBhqTMwYoeokLb;

1.183
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.182;
commitid	HQcmytntiCJTHORs;

1.182
date	2014.09.03.08.51.01;	author mpi;	state Exp;
branches;
next	1.181;
commitid	8zZDLKeUZ4msbleT;

1.181
date	2014.08.26.15.09.26;	author mpi;	state Exp;
branches;
next	1.180;
commitid	vUkwiNO7ibijrifg;

1.180
date	2014.08.21.10.07.07;	author mpi;	state Exp;
branches;
next	1.179;
commitid	g4uyYL3Uc7Vd7FEo;

1.179
date	2014.08.19.12.49.41;	author mpi;	state Exp;
branches;
next	1.178;
commitid	4hSlcDXph8fUhqUG;

1.178
date	2014.08.14.09.01.47;	author mpi;	state Exp;
branches;
next	1.177;
commitid	xAyitDa7xkItKbjR;

1.177
date	2014.08.12.13.52.08;	author mpi;	state Exp;
branches;
next	1.176;
commitid	DfLTdnrRvTfPSDCZ;

1.176
date	2014.08.11.11.59.05;	author mpi;	state Exp;
branches;
next	1.175;
commitid	hd3GhrMDEgQk7VBd;

1.175
date	2014.07.29.12.18.41;	author mpi;	state Exp;
branches;
next	1.174;
commitid	QxM5HLkQs10iEeT9;

1.174
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.173;
commitid	B4dZSbxas1X1IpXI;

1.173
date	2014.07.12.17.57.26;	author mpi;	state Exp;
branches;
next	1.172;
commitid	ckR88Nymsqo0auLK;

1.172
date	2014.07.12.14.26.00;	author mpi;	state Exp;
branches;
next	1.171;
commitid	y5pjyU9NAzEZKp4W;

1.171
date	2014.06.16.19.47.21;	author mpi;	state Exp;
branches;
next	1.170;
commitid	deajIXmw3XdMzcAI;

1.170
date	2014.06.11.11.30.03;	author mpi;	state Exp;
branches;
next	1.169;
commitid	u5dv1nnY95B2omrl;

1.169
date	2014.06.11.11.29.01;	author mpi;	state Exp;
branches;
next	1.168;
commitid	UiNyUkv0g0JQt49O;

1.168
date	2014.05.27.19.38.15;	author claudio;	state Exp;
branches;
next	1.167;

1.167
date	2014.05.27.09.39.58;	author mpi;	state Exp;
branches;
next	1.166;

1.166
date	2014.05.21.14.48.28;	author mpi;	state Exp;
branches;
next	1.165;

1.165
date	2014.04.29.11.58.29;	author mpi;	state Exp;
branches;
next	1.164;

1.164
date	2014.04.25.10.41.09;	author mpi;	state Exp;
branches;
next	1.163;

1.163
date	2014.04.23.09.30.57;	author mpi;	state Exp;
branches;
next	1.162;

1.162
date	2014.04.22.12.35.00;	author mpi;	state Exp;
branches;
next	1.161;

1.161
date	2014.04.11.00.06.30;	author krw;	state Exp;
branches;
next	1.160;

1.160
date	2014.04.10.13.55.55;	author mpi;	state Exp;
branches;
next	1.159;

1.159
date	2014.04.10.13.47.21;	author mpi;	state Exp;
branches;
next	1.158;

1.158
date	2014.04.03.08.22.10;	author mpi;	state Exp;
branches;
next	1.157;

1.157
date	2014.03.27.10.39.23;	author mpi;	state Exp;
branches;
next	1.156;

1.156
date	2014.03.21.10.44.42;	author mpi;	state Exp;
branches;
next	1.155;

1.155
date	2014.03.18.10.47.34;	author mpi;	state Exp;
branches;
next	1.154;

1.154
date	2014.03.12.12.03.55;	author mpi;	state Exp;
branches;
next	1.153;

1.153
date	2014.02.12.12.50.13;	author mpi;	state Exp;
branches;
next	1.152;

1.152
date	2014.02.12.10.00.38;	author mpi;	state Exp;
branches;
next	1.151;

1.151
date	2014.01.23.10.16.30;	author mpi;	state Exp;
branches;
next	1.150;

1.150
date	2014.01.22.06.28.09;	author claudio;	state Exp;
branches;
next	1.149;

1.149
date	2014.01.10.14.29.08;	author tedu;	state Exp;
branches;
next	1.148;

1.148
date	2014.01.09.21.57.52;	author tedu;	state Exp;
branches;
next	1.147;

1.147
date	2013.10.20.13.21.57;	author claudio;	state Exp;
branches;
next	1.146;

1.146
date	2013.10.17.16.27.43;	author bluhm;	state Exp;
branches;
next	1.145;

1.145
date	2013.08.28.06.58.57;	author mpi;	state Exp;
branches;
next	1.144;

1.144
date	2013.03.28.23.10.05;	author tedu;	state Exp;
branches;
next	1.143;

1.143
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.142;

1.142
date	2013.03.07.09.03.16;	author mpi;	state Exp;
branches;
next	1.141;

1.141
date	2012.09.20.20.53.12;	author blambert;	state Exp;
branches;
next	1.140;

1.140
date	2012.09.19.16.14.01;	author blambert;	state Exp;
branches;
next	1.139;

1.139
date	2012.09.19.12.35.07;	author blambert;	state Exp;
branches;
next	1.138;

1.138
date	2012.09.18.08.16.33;	author blambert;	state Exp;
branches;
next	1.137;

1.137
date	2012.07.13.20.27.25;	author claudio;	state Exp;
branches;
next	1.136;

1.136
date	2012.05.09.06.50.55;	author markus;	state Exp;
branches;
next	1.135;

1.135
date	2011.12.06.12.58.34;	author blambert;	state Exp;
branches;
next	1.134;

1.134
date	2011.12.06.12.53.26;	author blambert;	state Exp;
branches;
next	1.133;

1.133
date	2011.12.06.12.48.51;	author blambert;	state Exp;
branches;
next	1.132;

1.132
date	2011.07.22.13.05.29;	author henning;	state Exp;
branches;
next	1.131;

1.131
date	2011.07.04.04.29.17;	author claudio;	state Exp;
branches;
next	1.130;

1.130
date	2011.04.04.16.06.13;	author blambert;	state Exp;
branches;
next	1.129;

1.129
date	2011.04.04.14.08.15;	author blambert;	state Exp;
branches;
next	1.128;

1.128
date	2010.11.16.19.39.17;	author bluhm;	state Exp;
branches;
next	1.127;

1.127
date	2010.08.25.14.07.24;	author claudio;	state Exp;
branches;
next	1.126;

1.126
date	2010.08.24.15.50.16;	author claudio;	state Exp;
branches;
next	1.125;

1.125
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.124;

1.124
date	2010.07.09.15.44.20;	author claudio;	state Exp;
branches;
next	1.123;

1.123
date	2010.07.02.00.20.49;	author jsg;	state Exp;
branches;
next	1.122;

1.122
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.121;

1.121
date	2010.06.29.21.28.37;	author reyk;	state Exp;
branches;
next	1.120;

1.120
date	2010.06.28.18.50.37;	author claudio;	state Exp;
branches;
next	1.119;

1.119
date	2010.06.04.11.05.13;	author blambert;	state Exp;
branches;
next	1.118;

1.118
date	2010.05.19.13.09.09;	author claudio;	state Exp;
branches;
next	1.117;

1.117
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.116;

1.116
date	2010.03.20.10.43.11;	author blambert;	state Exp;
branches;
next	1.115;

1.115
date	2010.02.09.16.31.14;	author claudio;	state Exp;
branches;
next	1.114;

1.114
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.113;

1.113
date	2009.10.26.17.14.24;	author mk;	state Exp;
branches;
next	1.112;

1.112
date	2009.10.10.22.08.26;	author dms;	state Exp;
branches;
next	1.111;

1.111
date	2009.09.01.06.10.01;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2009.07.28.20.54.57;	author claudio;	state Exp;
branches;
next	1.109;

1.109
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.108;

1.108
date	2009.05.31.04.07.03;	author claudio;	state Exp;
branches;
next	1.107;

1.107
date	2009.05.26.08.29.44;	author reyk;	state Exp;
branches;
next	1.106;

1.106
date	2009.05.18.20.37.13;	author bluhm;	state Exp;
branches;
next	1.105;

1.105
date	2009.03.15.19.40.41;	author miod;	state Exp;
branches;
next	1.104;

1.104
date	2009.02.27.13.15.40;	author claudio;	state Exp;
branches;
next	1.103;

1.103
date	2009.02.03.16.42.54;	author michele;	state Exp;
branches;
next	1.102;

1.102
date	2009.01.28.22.18.44;	author michele;	state Exp;
branches;
next	1.101;

1.101
date	2009.01.08.12.47.45;	author michele;	state Exp;
branches;
next	1.100;

1.100
date	2008.12.12.22.07.33;	author claudio;	state Exp;
branches;
next	1.99;

1.99
date	2008.11.24.12.53.53;	author claudio;	state Exp;
branches;
next	1.98;

1.98
date	2008.11.21.18.01.30;	author claudio;	state Exp;
branches;
next	1.97;

1.97
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.96;

1.96
date	2008.08.07.21.32.08;	author claudio;	state Exp;
branches;
next	1.95;

1.95
date	2008.08.01.05.08.07;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2008.07.28.13.25.10;	author claudio;	state Exp;
branches;
next	1.93;

1.93
date	2008.06.08.19.12.28;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2008.05.09.15.48.15;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2008.05.09.07.33.13;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2008.05.07.05.14.21;	author claudio;	state Exp;
branches;
next	1.89;

1.89
date	2008.05.07.02.45.24;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.05.13.06.37;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2008.01.05.19.08.19;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2007.09.17.05.06.20;	author pyr;	state Exp;
branches;
next	1.85;

1.85
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.14.18.31.49;	author reyk;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2007.05.08.20.57.19;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2007.05.08.18.46.37;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2006.06.19.08.14.06;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2006.06.17.17.20.00;	author pascoe;	state Exp;
branches;
next	1.79;

1.79
date	2006.06.16.16.49.39;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2006.06.15.16.33.02;	author henning;	state Exp;
branches;
next	1.77;

1.77
date	2006.06.06.15.36.07;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2006.06.01.05.21.06;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2006.05.31.02.02.22;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2006.05.31.01.35.11;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.20.20.43.57;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2006.04.26.17.02.13;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2006.04.22.19.43.06;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.22.14.37.44;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.20.10.03.49;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.06.13.36.03;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.06.13.34.03;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.06.13.29.28;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.06.13.24.09;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.06.13.22.20;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2006.02.01.13.47.22;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2005.11.29.02.59.42;	author jolan;	state Exp;
branches;
next	1.61;

1.61
date	2005.11.28.15.27.19;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2005.11.28.15.19.20;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2005.11.27.16.22.45;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2005.11.25.13.45.02;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2005.11.25.13.33.47;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2005.11.25.13.29.20;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2005.11.25.11.58.07;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2005.06.08.06.43.07;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2005.06.08.03.13.49;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2005.06.07.18.21.44;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2005.05.15.16.40.09;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2004.09.16.22.31.30;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.09.12.01.26;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2004.08.08.19.09.33;	author otto;	state Exp;
branches;
next	1.47;

1.47
date	2004.08.03.11.22.15;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.28.13.13.41;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2004.07.20.23.40.27;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.22.07.35.20;	author cedric;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.19.19.55.53;	author cedric;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.06.16.49.09;	author cedric;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.25.02.48.04;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.27.00.01.38;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2003.08.26.08.33.12;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2002.07.11.12.29.03;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.11.04.27.40;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.07.18.30.11;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.31.05.00.26;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.23.00.39.48;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.18.23.07.49;	author deraadt;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2001.12.10.06.10.53;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.20.18.46.50;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.29.06.33.06;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.19.06.37.36;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.11.07.52.06;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.09.03.15.25;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.09.03.06.55;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.21.22.19.07;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.23.16.37.52;	author art;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2000.03.22.16.50.24;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	99.09.13.22.33.51;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.07.05.20.17.05;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.02.25.18.56.48;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	99.02.24.22.35.23;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	99.02.05.01.57.32;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	99.02.04.00.54.03;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.01.08.00.56.06;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.01.07.22.18.59;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.12.31.04.25.13;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.12.31.04.19.03;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.09.21.03.52.42;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.07.27.23.30.33;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.02.20.01.07.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.21.07.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches;
next	;

1.16.2.1
date	2000.03.24.09.09.33;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.05.14.22.40.04;	author niklas;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.16.2.7;

1.16.2.7
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.16.2.8;

1.16.2.8
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.16.2.9;

1.16.2.9
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.16.2.10;

1.16.2.10
date	2004.06.07.20.41.38;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2000.05.29.18.22.31;	author jason;	state Exp;
branches;
next	;

1.27.2.1
date	2002.01.31.22.55.44;	author niklas;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;

1.34.2.1
date	2003.10.01.22.53.34;	author brad;	state Exp;
branches;
next	;

1.35.2.1
date	2003.10.01.20.36.55;	author margarida;	state Exp;
branches;
next	;

1.84.2.1
date	2008.01.11.12.41.26;	author henning;	state Exp;
branches;
next	;


desc
@@


1.365
log
@Move a sanity check that only makes sense for userland where it belongs.

ok bluhm@@, florian@@
@
text
@/*	$OpenBSD: route.c,v 1.364 2017/07/30 18:18:08 florian Exp $	*/
/*	$NetBSD: route.c,v 1.14 1996/02/13 22:00:46 christos Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1980, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)route.c	8.2 (Berkeley) 11/15/93
 */

/*
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/timeout.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/queue.h>
#include <sys/pool.h>
#include <sys/atomic.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_dl.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip_var.h>
#include <netinet/in_var.h>

#ifdef INET6
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/in6_var.h>
#endif

#ifdef MPLS
#include <netmpls/mpls.h>
#endif

#ifdef BFD
#include <net/bfd.h>
#endif

#define ROUNDUP(a) (a>0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

/* Give some jitter to hash, to avoid synchronization between routers. */
static uint32_t		rt_hashjitter;

extern unsigned int	rtmap_limit;

struct cpumem *		rtcounters;
int			rttrash;	/* routes not in table but not freed */
int			ifatrash;	/* ifas not in ifp list but not free */

struct pool		rtentry_pool;	/* pool for rtentry structures */
struct pool		rttimer_pool;	/* pool for rttimer structures */

void	rt_timer_init(void);
int	rt_setgwroute(struct rtentry *, u_int);
void	rt_putgwroute(struct rtentry *);
int	rtflushclone1(struct rtentry *, void *, u_int);
void	rtflushclone(unsigned int, struct rtentry *);
int	rt_ifa_purge_walker(struct rtentry *, void *, unsigned int);
struct rtentry *rt_match(struct sockaddr *, uint32_t *, int, unsigned int);
struct sockaddr *rt_plentosa(sa_family_t, int, struct sockaddr_in6 *);

#ifdef DDB
void	db_print_sa(struct sockaddr *);
void	db_print_ifa(struct ifaddr *);
int	db_show_rtentry(struct rtentry *, void *, unsigned int);
#endif

#define	LABELID_MAX	50000

struct rt_label {
	TAILQ_ENTRY(rt_label)	rtl_entry;
	char			rtl_name[RTLABEL_LEN];
	u_int16_t		rtl_id;
	int			rtl_ref;
};

TAILQ_HEAD(rt_labels, rt_label)	rt_labels = TAILQ_HEAD_INITIALIZER(rt_labels);

void
route_init(void)
{
	rtcounters = counters_alloc(rts_ncounters);

	pool_init(&rtentry_pool, sizeof(struct rtentry), 0, IPL_SOFTNET, 0,
	    "rtentry", NULL);

	while (rt_hashjitter == 0)
		rt_hashjitter = arc4random();

#ifdef BFD
	bfdinit();
#endif
}

/*
 * Returns 1 if the (cached) ``rt'' entry is still valid, 0 otherwise.
 */
int
rtisvalid(struct rtentry *rt)
{
	if (rt == NULL)
		return (0);

	if (!ISSET(rt->rt_flags, RTF_UP))
		return (0);

	if (ISSET(rt->rt_flags, RTF_GATEWAY)) {
		KASSERT(rt->rt_gwroute != NULL);
		KASSERT(!ISSET(rt->rt_gwroute->rt_flags, RTF_GATEWAY));
		if (!ISSET(rt->rt_gwroute->rt_flags, RTF_UP))
			return (0);
	}

	return (1);
}

/*
 * Do the actual lookup for rtalloc(9), do not use directly!
 *
 * Return the best matching entry for the destination ``dst''.
 *
 * "RT_RESOLVE" means that a corresponding L2 entry should
 *   be added to the routing table and resolved (via ARP or
 *   NDP), if it does not exist.
 */
struct rtentry *
rt_match(struct sockaddr *dst, uint32_t *src, int flags, unsigned int tableid)
{
	struct rtentry		*rt0, *rt = NULL;
	int			 error = 0;

	NET_ASSERT_LOCKED();

	rt = rtable_match(tableid, dst, src);
	if (rt != NULL) {
		if ((rt->rt_flags & RTF_CLONING) && ISSET(flags, RT_RESOLVE)) {
			struct rt_addrinfo	 info;

			rt0 = rt;

			memset(&info, 0, sizeof(info));
			info.rti_info[RTAX_DST] = dst;

			KERNEL_LOCK();
			/*
			 * The priority of cloned route should be different
			 * to avoid conflict with /32 cloning routes.
			 *
			 * It should also be higher to let the ARP layer find
			 * cloned routes instead of the cloning one.
			 */
			error = rtrequest(RTM_RESOLVE, &info,
			    rt->rt_priority - 1, &rt, tableid);
			if (error) {
				rtm_miss(RTM_MISS, &info, 0, RTP_NONE, 0,
				    error, tableid);
			} else {
				/* Inform listeners of the new route */
				rtm_send(rt, RTM_ADD, 0, tableid);
				rtfree(rt0);
			}
			KERNEL_UNLOCK();
		}
		rt->rt_use++;
	} else
		rtstat_inc(rts_unreach);
	return (rt);
}

/*
 * Originated from bridge_hash() in if_bridge.c
 */
#define mix(a, b, c) do {						\
	a -= b; a -= c; a ^= (c >> 13);					\
	b -= c; b -= a; b ^= (a << 8);					\
	c -= a; c -= b; c ^= (b >> 13);					\
	a -= b; a -= c; a ^= (c >> 12);					\
	b -= c; b -= a; b ^= (a << 16);					\
	c -= a; c -= b; c ^= (b >> 5);					\
	a -= b; a -= c; a ^= (c >> 3);					\
	b -= c; b -= a; b ^= (a << 10);					\
	c -= a; c -= b; c ^= (b >> 15);					\
} while (0)

int
rt_hash(struct rtentry *rt, struct sockaddr *dst, uint32_t *src)
{
	uint32_t a, b, c;

	if (src == NULL || !rtisvalid(rt) || !ISSET(rt->rt_flags, RTF_MPATH))
		return (-1);

	a = b = 0x9e3779b9;
	c = rt_hashjitter;

	switch (dst->sa_family) {
	case AF_INET:
	    {
		struct sockaddr_in *sin;

		if (!ipmultipath)
			return (-1);

		sin = satosin(dst);
		a += sin->sin_addr.s_addr;
		b += (src != NULL) ? src[0] : 0;
		mix(a, b, c);
		break;
	    }
#ifdef INET6
	case AF_INET6:
	    {
		struct sockaddr_in6 *sin6;

		if (!ip6_multipath)
			return (-1);

		sin6 = satosin6(dst);
		a += sin6->sin6_addr.s6_addr32[0];
		b += sin6->sin6_addr.s6_addr32[2];
		c += (src != NULL) ? src[0] : 0;
		mix(a, b, c);
		a += sin6->sin6_addr.s6_addr32[1];
		b += sin6->sin6_addr.s6_addr32[3];
		c += (src != NULL) ? src[1] : 0;
		mix(a, b, c);
		a += sin6->sin6_addr.s6_addr32[2];
		b += sin6->sin6_addr.s6_addr32[1];
		c += (src != NULL) ? src[2] : 0;
		mix(a, b, c);
		a += sin6->sin6_addr.s6_addr32[3];
		b += sin6->sin6_addr.s6_addr32[0];
		c += (src != NULL) ? src[3] : 0;
		mix(a, b, c);
		break;
	    }
#endif /* INET6 */
	}

	return (c & 0xffff);
}

/*
 * Allocate a route, potentially using multipath to select the peer.
 */
struct rtentry *
rtalloc_mpath(struct sockaddr *dst, uint32_t *src, unsigned int rtableid)
{
	return (rt_match(dst, src, RT_RESOLVE, rtableid));
}

/*
 * Look in the routing table for the best matching entry for
 * ``dst''.
 *
 * If a route with a gateway is found and its next hop is no
 * longer valid, try to cache it.
 */
struct rtentry *
rtalloc(struct sockaddr *dst, int flags, unsigned int rtableid)
{
	return (rt_match(dst, NULL, flags, rtableid));
}

/*
 * Cache the route entry corresponding to a reachable next hop in
 * the gateway entry ``rt''.
 */
int
rt_setgwroute(struct rtentry *rt, u_int rtableid)
{
	struct rtentry *nhrt;

	NET_ASSERT_LOCKED();

	KASSERT(ISSET(rt->rt_flags, RTF_GATEWAY));

	/* If we cannot find a valid next hop bail. */
	nhrt = rt_match(rt->rt_gateway, NULL, RT_RESOLVE, rtable_l2(rtableid));
	if (nhrt == NULL)
		return (ENOENT);

	/* Next hop entry must be on the same interface. */
	if (nhrt->rt_ifidx != rt->rt_ifidx) {
		rtfree(nhrt);
		return (EHOSTUNREACH);
	}

	/*
	 * Next hop must be reachable, this also prevents rtentry
	 * loops for example when rt->rt_gwroute points to rt.
	 */
	if (ISSET(nhrt->rt_flags, RTF_CLONING|RTF_GATEWAY)) {
		rtfree(nhrt);
		return (ENETUNREACH);
	}

	/* Next hop is valid so remove possible old cache. */
	rt_putgwroute(rt);
	KASSERT(rt->rt_gwroute == NULL);

	/*
	 * If the MTU of next hop is 0, this will reset the MTU of the
	 * route to run PMTUD again from scratch.
	 */
	if (!ISSET(rt->rt_locks, RTV_MTU) && (rt->rt_mtu > nhrt->rt_mtu))
		rt->rt_mtu = nhrt->rt_mtu;

	/*
	 * To avoid reference counting problems when writting link-layer
	 * addresses in an outgoing packet, we ensure that the lifetime
	 * of a cached entry is greater that the bigger lifetime of the
	 * gateway entries it is pointed by.
	 */
	nhrt->rt_flags |= RTF_CACHED;
	nhrt->rt_cachecnt++;

	rt->rt_gwroute = nhrt;

	return (0);
}

/*
 * Invalidate the cached route entry of the gateway entry ``rt''.
 */
void
rt_putgwroute(struct rtentry *rt)
{
	struct rtentry *nhrt = rt->rt_gwroute;

	NET_ASSERT_LOCKED();

	if (!ISSET(rt->rt_flags, RTF_GATEWAY) || nhrt == NULL)
		return;

	KASSERT(ISSET(nhrt->rt_flags, RTF_CACHED));
	KASSERT(nhrt->rt_cachecnt > 0);

	--nhrt->rt_cachecnt;
	if (nhrt->rt_cachecnt == 0)
		nhrt->rt_flags &= ~RTF_CACHED;

	rtfree(rt->rt_gwroute);
	rt->rt_gwroute = NULL;
}

void
rtref(struct rtentry *rt)
{
	atomic_inc_int(&rt->rt_refcnt);
}

void
rtfree(struct rtentry *rt)
{
	int		 refcnt;

	if (rt == NULL)
		return;

	refcnt = (int)atomic_dec_int_nv(&rt->rt_refcnt);
	if (refcnt <= 0) {
		KASSERT(!ISSET(rt->rt_flags, RTF_UP));
		KASSERT(!RT_ROOT(rt));
		atomic_dec_int(&rttrash);
		if (refcnt < 0) {
			printf("rtfree: %p not freed (neg refs)\n", rt);
			return;
		}

		KERNEL_LOCK();
		rt_timer_remove_all(rt);
		ifafree(rt->rt_ifa);
		rtlabel_unref(rt->rt_labelid);
#ifdef MPLS
		if (rt->rt_flags & RTF_MPLS)
			free(rt->rt_llinfo, M_TEMP, sizeof(struct rt_mpls));
#endif
		free(rt->rt_gateway, M_RTABLE, ROUNDUP(rt->rt_gateway->sa_len));
		free(rt_key(rt), M_RTABLE, rt_key(rt)->sa_len);
		KERNEL_UNLOCK();

		pool_put(&rtentry_pool, rt);
	}
}

void
ifafree(struct ifaddr *ifa)
{
	if (ifa == NULL)
		panic("ifafree");
	if (ifa->ifa_refcnt == 0) {
		ifatrash--;
		free(ifa, M_IFADDR, 0);
	} else
		ifa->ifa_refcnt--;
}

/*
 * Force a routing table entry to the specified
 * destination to go through the given gateway.
 * Normally called as a result of a routing redirect
 * message from the network layer.
 */
void
rtredirect(struct sockaddr *dst, struct sockaddr *gateway,
    struct sockaddr *src, struct rtentry **rtp, unsigned int rdomain)
{
	struct rtentry		*rt;
	int			 error = 0;
	enum rtstat_counters	 stat = rts_ncounters;
	struct rt_addrinfo	 info;
	struct ifaddr		*ifa;
	unsigned int		 ifidx = 0;
	int			 flags = RTF_GATEWAY|RTF_HOST;
	uint8_t			 prio = RTP_NONE;

	NET_ASSERT_LOCKED();

	/* verify the gateway is directly reachable */
	rt = rtalloc(gateway, 0, rdomain);
	if (!rtisvalid(rt) || ISSET(rt->rt_flags, RTF_GATEWAY)) {
		rtfree(rt);
		error = ENETUNREACH;
		goto out;
	}
	ifidx = rt->rt_ifidx;
	ifa = rt->rt_ifa;
	rtfree(rt);
	rt = NULL;

	rt = rtable_lookup(rdomain, dst, NULL, NULL, RTP_ANY);
	/*
	 * If the redirect isn't from our current router for this dst,
	 * it's either old or wrong.  If it redirects us to ourselves,
	 * we have a routing loop, perhaps as a result of an interface
	 * going down recently.
	 */
#define	equal(a1, a2) \
	((a1)->sa_len == (a2)->sa_len && \
	 bcmp((caddr_t)(a1), (caddr_t)(a2), (a1)->sa_len) == 0)
	if (rt != NULL && (!equal(src, rt->rt_gateway) || rt->rt_ifa != ifa))
		error = EINVAL;
	else if (ifa_ifwithaddr(gateway, rdomain) != NULL ||
	    (gateway->sa_family = AF_INET &&
	    in_broadcast(satosin(gateway)->sin_addr, rdomain)))
		error = EHOSTUNREACH;
	if (error)
		goto done;
	/*
	 * Create a new entry if we just got back a wildcard entry
	 * or the lookup failed.  This is necessary for hosts
	 * which use routing redirects generated by smart gateways
	 * to dynamically build the routing tables.
	 */
	if (rt == NULL)
		goto create;
	/*
	 * Don't listen to the redirect if it's
	 * for a route to an interface.
	 */
	if (ISSET(rt->rt_flags, RTF_GATEWAY)) {
		if (!ISSET(rt->rt_flags, RTF_HOST)) {
			/*
			 * Changing from route to net => route to host.
			 * Create new route, rather than smashing route to net.
			 */
create:
			rtfree(rt);
			flags |= RTF_DYNAMIC;
			bzero(&info, sizeof(info));
			info.rti_info[RTAX_DST] = dst;
			info.rti_info[RTAX_GATEWAY] = gateway;
			info.rti_ifa = ifa;
			info.rti_flags = flags;
			rt = NULL;
			error = rtrequest(RTM_ADD, &info, RTP_DEFAULT, &rt,
			    rdomain);
			if (error == 0) {
				flags = rt->rt_flags;
				prio = rt->rt_priority;
			}
			stat = rts_dynamic;
		} else {
			/*
			 * Smash the current notion of the gateway to
			 * this destination.  Should check about netmask!!!
			 */
			rt->rt_flags |= RTF_MODIFIED;
			flags |= RTF_MODIFIED;
			prio = rt->rt_priority;
			stat = rts_newgateway;
			rt_setgate(rt, gateway, rdomain);
		}
	} else
		error = EHOSTUNREACH;
done:
	if (rt) {
		if (rtp && !error)
			*rtp = rt;
		else
			rtfree(rt);
	}
out:
	if (error)
		rtstat_inc(rts_badredirect);
	else if (stat != rts_ncounters)
		rtstat_inc(stat);
	bzero((caddr_t)&info, sizeof(info));
	info.rti_info[RTAX_DST] = dst;
	info.rti_info[RTAX_GATEWAY] = gateway;
	info.rti_info[RTAX_AUTHOR] = src;
	KERNEL_LOCK();
	rtm_miss(RTM_REDIRECT, &info, flags, prio, ifidx, error, rdomain);
	KERNEL_UNLOCK();
}

/*
 * Delete a route and generate a message
 */
int
rtdeletemsg(struct rtentry *rt, struct ifnet *ifp, u_int tableid)
{
	int			error;
	struct rt_addrinfo	info;
	struct sockaddr_in6	sa_mask;

	KASSERT(rt->rt_ifidx == ifp->if_index);

	/*
	 * Request the new route so that the entry is not actually
	 * deleted.  That will allow the information being reported to
	 * be accurate (and consistent with route_output()).
	 */
	memset(&info, 0, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	if (!ISSET(rt->rt_flags, RTF_HOST))
		info.rti_info[RTAX_NETMASK] = rt_plen2mask(rt, &sa_mask);
	error = rtrequest_delete(&info, rt->rt_priority, ifp, &rt, tableid);
	KERNEL_LOCK();
	rtm_send(rt, RTM_DELETE, error, tableid);
	KERNEL_UNLOCK();
	if (error == 0)
		rtfree(rt);
	return (error);
}

static inline int
rtequal(struct rtentry *a, struct rtentry *b)
{
	if (a == b)
		return 1;

	if (memcmp(rt_key(a), rt_key(b), rt_key(a)->sa_len) == 0 &&
	    rt_plen(a) == rt_plen(b))
		return 1;
	else
		return 0;
}

int
rtflushclone1(struct rtentry *rt, void *arg, u_int id)
{
	struct rtentry *parent = arg;
	struct ifnet *ifp;
	int error;

	ifp = if_get(rt->rt_ifidx);

	/*
	 * This happens when an interface with a RTF_CLONING route is
	 * being detached.  In this case it's safe to bail because all
	 * the routes are being purged by rt_ifa_purge().
	 */
	if (ifp == NULL)
	        return 0;

	if (ISSET(rt->rt_flags, RTF_CLONED) && rtequal(rt->rt_parent, parent)) {
	        error = rtdeletemsg(rt, ifp, id);
	        if (error == 0)
			error = EAGAIN;
	} else
		error = 0;

	if_put(ifp);
	return error;
}

void
rtflushclone(unsigned int rtableid, struct rtentry *parent)
{

#ifdef DIAGNOSTIC
	if (!parent || (parent->rt_flags & RTF_CLONING) == 0)
		panic("rtflushclone: called with a non-cloning route");
#endif
	rtable_walk(rtableid, rt_key(parent)->sa_family, rtflushclone1, parent);
}

int
rtrequest_delete(struct rt_addrinfo *info, u_int8_t prio, struct ifnet *ifp,
    struct rtentry **ret_nrt, u_int tableid)
{
	struct rtentry	*rt;
	int		 error;

	NET_ASSERT_LOCKED();

	if (!rtable_exists(tableid))
		return (EAFNOSUPPORT);
	rt = rtable_lookup(tableid, info->rti_info[RTAX_DST],
	    info->rti_info[RTAX_NETMASK], info->rti_info[RTAX_GATEWAY], prio);
	if (rt == NULL)
		return (ESRCH);

	/* Make sure that's the route the caller want to delete. */
	if (ifp != NULL && ifp->if_index != rt->rt_ifidx) {
		rtfree(rt);
		return (ESRCH);
	}

#ifdef BFD
	if (ISSET(rt->rt_flags, RTF_BFD))
		bfdclear(rt);
#endif

	error = rtable_delete(tableid, info->rti_info[RTAX_DST],
	    info->rti_info[RTAX_NETMASK], rt);
	if (error != 0) {
		rtfree(rt);
		return (ESRCH);
	}

	/* Release next hop cache before flushing cloned entries. */
	rt_putgwroute(rt);

	/* Clean up any cloned children. */
	if (ISSET(rt->rt_flags, RTF_CLONING))
		rtflushclone(tableid, rt);

	rtfree(rt->rt_parent);
	rt->rt_parent = NULL;

	rt->rt_flags &= ~RTF_UP;

	KASSERT(ifp->if_index == rt->rt_ifidx);
	ifp->if_rtrequest(ifp, RTM_DELETE, rt);

	atomic_inc_int(&rttrash);

	if (ret_nrt != NULL)
		*ret_nrt = rt;
	else
		rtfree(rt);

	return (0);
}

int
rtrequest(int req, struct rt_addrinfo *info, u_int8_t prio,
    struct rtentry **ret_nrt, u_int tableid)
{
	struct ifnet		*ifp;
	struct rtentry		*rt, *crt;
	struct ifaddr		*ifa;
	struct sockaddr		*ndst;
	struct sockaddr_rtlabel	*sa_rl, sa_rl2;
	struct sockaddr_dl	 sa_dl = { sizeof(sa_dl), AF_LINK };
	int			 dlen, error;
#ifdef MPLS
	struct sockaddr_mpls	*sa_mpls;
#endif

	NET_ASSERT_LOCKED();

	if (!rtable_exists(tableid))
		return (EAFNOSUPPORT);
	if (info->rti_flags & RTF_HOST)
		info->rti_info[RTAX_NETMASK] = NULL;
	switch (req) {
	case RTM_DELETE:
		return (EINVAL);

	case RTM_RESOLVE:
		if (ret_nrt == NULL || (rt = *ret_nrt) == NULL)
			return (EINVAL);
		if ((rt->rt_flags & RTF_CLONING) == 0)
			return (EINVAL);
		KASSERT(rt->rt_ifa->ifa_ifp != NULL);
		info->rti_ifa = rt->rt_ifa;
		info->rti_flags = rt->rt_flags | (RTF_CLONED|RTF_HOST);
		info->rti_flags &= ~(RTF_CLONING|RTF_CONNECTED|RTF_STATIC);
		info->rti_info[RTAX_GATEWAY] = sdltosa(&sa_dl);
		info->rti_info[RTAX_LABEL] =
		    rtlabel_id2sa(rt->rt_labelid, &sa_rl2);
		/* FALLTHROUGH */

	case RTM_ADD:
		if (info->rti_ifa == NULL)
			return (EINVAL);
		ifa = info->rti_ifa;
		ifp = ifa->ifa_ifp;
		if (prio == 0)
			prio = ifp->if_priority + RTP_STATIC;

		dlen = info->rti_info[RTAX_DST]->sa_len;
		ndst = malloc(dlen, M_RTABLE, M_NOWAIT);
		if (ndst == NULL)
			return (ENOBUFS);

		if (info->rti_info[RTAX_NETMASK] != NULL)
			rt_maskedcopy(info->rti_info[RTAX_DST], ndst,
			    info->rti_info[RTAX_NETMASK]);
		else
			memcpy(ndst, info->rti_info[RTAX_DST], dlen);

		rt = pool_get(&rtentry_pool, PR_NOWAIT | PR_ZERO);
		if (rt == NULL) {
			free(ndst, M_RTABLE, dlen);
			return (ENOBUFS);
		}

		rt->rt_refcnt = 1;
		rt->rt_flags = info->rti_flags | RTF_UP;
		rt->rt_priority = prio;	/* init routing priority */
		LIST_INIT(&rt->rt_timer);

		/* Check the link state if the table supports it. */
		if (rtable_mpath_capable(tableid, ndst->sa_family) &&
		    !ISSET(rt->rt_flags, RTF_LOCAL) &&
		    (!LINK_STATE_IS_UP(ifp->if_link_state) ||
		    !ISSET(ifp->if_flags, IFF_UP))) {
			rt->rt_flags &= ~RTF_UP;
			rt->rt_priority |= RTP_DOWN;
		}

		if (info->rti_info[RTAX_LABEL] != NULL) {
			sa_rl = (struct sockaddr_rtlabel *)
			    info->rti_info[RTAX_LABEL];
			rt->rt_labelid = rtlabel_name2id(sa_rl->sr_label);
		}

#ifdef MPLS
		/* We have to allocate additional space for MPLS infos */
		if (info->rti_flags & RTF_MPLS &&
		    (info->rti_info[RTAX_SRC] != NULL ||
		    info->rti_info[RTAX_DST]->sa_family == AF_MPLS)) {
			struct rt_mpls *rt_mpls;

			sa_mpls = (struct sockaddr_mpls *)
			    info->rti_info[RTAX_SRC];

			rt->rt_llinfo = malloc(sizeof(struct rt_mpls),
			    M_TEMP, M_NOWAIT|M_ZERO);

			if (rt->rt_llinfo == NULL) {
				free(ndst, M_RTABLE, dlen);
				pool_put(&rtentry_pool, rt);
				return (ENOMEM);
			}

			rt_mpls = (struct rt_mpls *)rt->rt_llinfo;

			if (sa_mpls != NULL)
				rt_mpls->mpls_label = sa_mpls->smpls_label;

			rt_mpls->mpls_operation = info->rti_mpls;

			/* XXX: set experimental bits */

			rt->rt_flags |= RTF_MPLS;
		} else
			rt->rt_flags &= ~RTF_MPLS;
#endif

		ifa->ifa_refcnt++;
		rt->rt_ifa = ifa;
		rt->rt_ifidx = ifp->if_index;
		/*
		 * Copy metrics and a back pointer from the cloned
		 * route's parent.
		 */
		if (ISSET(rt->rt_flags, RTF_CLONED)) {
			rtref(*ret_nrt);
			rt->rt_parent = *ret_nrt;
			rt->rt_rmx = (*ret_nrt)->rt_rmx;
		}

		/*
		 * We must set rt->rt_gateway before adding ``rt'' to
		 * the routing table because the radix MPATH code use
		 * it to (re)order routes.
		 */
		if ((error = rt_setgate(rt, info->rti_info[RTAX_GATEWAY],
		    tableid))) {
			ifafree(ifa);
			rtfree(rt->rt_parent);
			rt_putgwroute(rt);
			free(rt->rt_gateway, M_RTABLE, 0);
			free(ndst, M_RTABLE, dlen);
			pool_put(&rtentry_pool, rt);
			return (error);
		}

		error = rtable_insert(tableid, ndst,
		    info->rti_info[RTAX_NETMASK], info->rti_info[RTAX_GATEWAY],
		    rt->rt_priority, rt);
		if (error != 0 &&
		    (crt = rtable_match(tableid, ndst, NULL)) != NULL) {
			/* overwrite cloned route */
			if (ISSET(crt->rt_flags, RTF_CLONED)) {
				struct ifnet *cifp;

				cifp = if_get(crt->rt_ifidx);
				KASSERT(cifp != NULL);
				rtdeletemsg(crt, cifp, tableid);
				if_put(cifp);

				error = rtable_insert(tableid, ndst,
				    info->rti_info[RTAX_NETMASK],
				    info->rti_info[RTAX_GATEWAY],
				    rt->rt_priority, rt);
			}
			rtfree(crt);
		}
		if (error != 0) {
			ifafree(ifa);
			rtfree(rt->rt_parent);
			rt_putgwroute(rt);
			free(rt->rt_gateway, M_RTABLE, 0);
			free(ndst, M_RTABLE, dlen);
			pool_put(&rtentry_pool, rt);
			return (EEXIST);
		}
		ifp->if_rtrequest(ifp, req, rt);

		if_group_routechange(info->rti_info[RTAX_DST],
			info->rti_info[RTAX_NETMASK]);

		if (ret_nrt != NULL)
			*ret_nrt = rt;
		else
			rtfree(rt);
		break;
	}

	return (0);
}

int
rt_setgate(struct rtentry *rt, struct sockaddr *gate, u_int rtableid)
{
	int glen = ROUNDUP(gate->sa_len);
	struct sockaddr *sa;

	if (rt->rt_gateway == NULL || glen > ROUNDUP(rt->rt_gateway->sa_len)) {
		sa = malloc(glen, M_RTABLE, M_NOWAIT);
		if (sa == NULL)
			return (ENOBUFS);
		free(rt->rt_gateway, M_RTABLE, 0);
		rt->rt_gateway = sa;
	}
	memmove(rt->rt_gateway, gate, glen);

	if (ISSET(rt->rt_flags, RTF_GATEWAY))
		return (rt_setgwroute(rt, rtableid));

	return (0);
}

/*
 * Return the route entry containing the next hop link-layer
 * address corresponding to ``rt''.
 */
struct rtentry *
rt_getll(struct rtentry *rt)
{
	if (ISSET(rt->rt_flags, RTF_GATEWAY)) {
		KASSERT(rt->rt_gwroute != NULL);
		return (rt->rt_gwroute);
	}

	return (rt);
}

void
rt_maskedcopy(struct sockaddr *src, struct sockaddr *dst,
    struct sockaddr *netmask)
{
	u_char	*cp1 = (u_char *)src;
	u_char	*cp2 = (u_char *)dst;
	u_char	*cp3 = (u_char *)netmask;
	u_char	*cplim = cp2 + *cp3;
	u_char	*cplim2 = cp2 + *cp1;

	*cp2++ = *cp1++; *cp2++ = *cp1++; /* copies sa_len & sa_family */
	cp3 += 2;
	if (cplim > cplim2)
		cplim = cplim2;
	while (cp2 < cplim)
		*cp2++ = *cp1++ & *cp3++;
	if (cp2 < cplim2)
		bzero((caddr_t)cp2, (unsigned)(cplim2 - cp2));
}

int
rt_ifa_add(struct ifaddr *ifa, int flags, struct sockaddr *dst)
{
	struct ifnet		*ifp = ifa->ifa_ifp;
	struct rtentry		*rt;
	struct sockaddr_rtlabel	 sa_rl;
	struct rt_addrinfo	 info;
	unsigned int		 rtableid = ifp->if_rdomain;
	uint8_t			 prio = ifp->if_priority + RTP_STATIC;
	int			 error;

	memset(&info, 0, sizeof(info));
	info.rti_ifa = ifa;
	info.rti_flags = flags | RTF_MPATH;
	info.rti_info[RTAX_DST] = dst;
	if (flags & RTF_LLINFO)
		info.rti_info[RTAX_GATEWAY] = sdltosa(ifp->if_sadl);
	else
		info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
	info.rti_info[RTAX_LABEL] = rtlabel_id2sa(ifp->if_rtlabelid, &sa_rl);

#ifdef MPLS
	if ((flags & RTF_MPLS) == RTF_MPLS)
		info.rti_mpls = MPLS_OP_POP;
#endif /* MPLS */

	if ((flags & RTF_HOST) == 0)
		info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;

	if (flags & (RTF_LOCAL|RTF_BROADCAST))
		prio = RTP_LOCAL;

	if (flags & RTF_CONNECTED)
		prio = ifp->if_priority + RTP_CONNECTED;

	error = rtrequest(RTM_ADD, &info, prio, &rt, rtableid);
	if (error == 0) {
		/*
		 * A local route is created for every address configured
		 * on an interface, so use this information to notify
		 * userland that a new address has been added.
		 */
		if (flags & RTF_LOCAL)
			rtm_addr(rt, RTM_NEWADDR, ifa);
		rtm_send(rt, RTM_ADD, 0, rtableid);
		rtfree(rt);
	}
	return (error);
}

int
rt_ifa_del(struct ifaddr *ifa, int flags, struct sockaddr *dst)
{
	struct ifnet		*ifp = ifa->ifa_ifp;
	struct rtentry		*rt;
	struct mbuf		*m = NULL;
	struct sockaddr		*deldst;
	struct rt_addrinfo	 info;
	struct sockaddr_rtlabel	 sa_rl;
	unsigned int		 rtableid = ifp->if_rdomain;
	uint8_t			 prio = ifp->if_priority + RTP_STATIC;
	int			 error;

#ifdef MPLS
	if ((flags & RTF_MPLS) == RTF_MPLS)
		/* MPLS routes only exist in rdomain 0 */
		rtableid = 0;
#endif /* MPLS */

	if ((flags & RTF_HOST) == 0 && ifa->ifa_netmask) {
		m = m_get(M_DONTWAIT, MT_SONAME);
		if (m == NULL)
			return (ENOBUFS);
		deldst = mtod(m, struct sockaddr *);
		rt_maskedcopy(dst, deldst, ifa->ifa_netmask);
		dst = deldst;
	}

	memset(&info, 0, sizeof(info));
	info.rti_ifa = ifa;
	info.rti_flags = flags;
	info.rti_info[RTAX_DST] = dst;
	if ((flags & RTF_LLINFO) == 0)
		info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
	info.rti_info[RTAX_LABEL] = rtlabel_id2sa(ifp->if_rtlabelid, &sa_rl);

	if ((flags & RTF_HOST) == 0)
		info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;

	if (flags & (RTF_LOCAL|RTF_BROADCAST))
		prio = RTP_LOCAL;

	if (flags & RTF_CONNECTED)
		prio = ifp->if_priority + RTP_CONNECTED;

	error = rtrequest_delete(&info, prio, ifp, &rt, rtableid);
	if (error == 0) {
		rtm_send(rt, RTM_DELETE, 0, rtableid);
		if (flags & RTF_LOCAL)
			rtm_addr(rt, RTM_DELADDR, ifa);
		rtfree(rt);
	}
	m_free(m);

	return (error);
}

/*
 * Add ifa's address as a local rtentry.
 */
int
rt_ifa_addlocal(struct ifaddr *ifa)
{
	struct rtentry *rt;
	u_int flags = RTF_HOST|RTF_LOCAL;
	int error = 0;

	/*
	 * If the configured address correspond to the magical "any"
	 * address do not add a local route entry because that might
	 * corrupt the routing tree which uses this value for the
	 * default routes.
	 */
	switch (ifa->ifa_addr->sa_family) {
	case AF_INET:
		if (satosin(ifa->ifa_addr)->sin_addr.s_addr == INADDR_ANY)
			return (0);
		break;
#ifdef INET6
	case AF_INET6:
		if (IN6_ARE_ADDR_EQUAL(&satosin6(ifa->ifa_addr)->sin6_addr,
		    &in6addr_any))
			return (0);
		break;
#endif
	default:
		break;
	}

	if (!ISSET(ifa->ifa_ifp->if_flags, (IFF_LOOPBACK|IFF_POINTOPOINT)))
		flags |= RTF_LLINFO;

	/* If there is no local entry, allocate one. */
	rt = rtalloc(ifa->ifa_addr, 0, ifa->ifa_ifp->if_rdomain);
	if (rt == NULL || ISSET(rt->rt_flags, flags) != flags)
		error = rt_ifa_add(ifa, flags, ifa->ifa_addr);
	rtfree(rt);

	return (error);
}

/*
 * Remove local rtentry of ifa's addresss if it exists.
 */
int
rt_ifa_dellocal(struct ifaddr *ifa)
{
	struct rtentry *rt;
	u_int flags = RTF_HOST|RTF_LOCAL;
	int error = 0;

	/*
	 * We do not add local routes for such address, so do not bother
	 * removing them.
	 */
	switch (ifa->ifa_addr->sa_family) {
	case AF_INET:
		if (satosin(ifa->ifa_addr)->sin_addr.s_addr == INADDR_ANY)
			return (0);
		break;
#ifdef INET6
	case AF_INET6:
		if (IN6_ARE_ADDR_EQUAL(&satosin6(ifa->ifa_addr)->sin6_addr,
		    &in6addr_any))
			return (0);
		break;
#endif
	default:
		break;
	}

	if (!ISSET(ifa->ifa_ifp->if_flags, (IFF_LOOPBACK|IFF_POINTOPOINT)))
		flags |= RTF_LLINFO;

	/*
	 * Before deleting, check if a corresponding local host
	 * route surely exists.  With this check, we can avoid to
	 * delete an interface direct route whose destination is same
	 * as the address being removed.  This can happen when removing
	 * a subnet-router anycast address on an interface attached
	 * to a shared medium.
	 */
	rt = rtalloc(ifa->ifa_addr, 0, ifa->ifa_ifp->if_rdomain);
	if (rt != NULL && ISSET(rt->rt_flags, flags) == flags)
		error = rt_ifa_del(ifa, flags, ifa->ifa_addr);
	rtfree(rt);

	return (error);
}

/*
 * Remove all addresses attached to ``ifa''.
 */
void
rt_ifa_purge(struct ifaddr *ifa)
{
	struct ifnet		*ifp = ifa->ifa_ifp;
	unsigned int		 rtableid;
	int			 i;

	KASSERT(ifp != NULL);

	for (rtableid = 0; rtableid < rtmap_limit; rtableid++) {
		/* skip rtables that are not in the rdomain of the ifp */
		if (rtable_l2(rtableid) != ifp->if_rdomain)
			continue;
		for (i = 1; i <= AF_MAX; i++) {
			rtable_walk(rtableid, i, rt_ifa_purge_walker, ifa);
		}
	}
}

int
rt_ifa_purge_walker(struct rtentry *rt, void *vifa, unsigned int rtableid)
{
	struct ifaddr		*ifa = vifa;
	struct ifnet		*ifp = ifa->ifa_ifp;
	int			 error;

	if (rt->rt_ifa != ifa)
		return (0);

	if ((error = rtdeletemsg(rt, ifp, rtableid))) {
		return (error);
	}

	return (EAGAIN);

}

/*
 * Route timer routines.  These routes allow functions to be called
 * for various routes at any time.  This is useful in supporting
 * path MTU discovery and redirect route deletion.
 *
 * This is similar to some BSDI internal functions, but it provides
 * for multiple queues for efficiency's sake...
 */

LIST_HEAD(, rttimer_queue)	rttimer_queue_head;
static int			rt_init_done = 0;

#define RTTIMER_CALLOUT(r)	{					\
	if (r->rtt_func != NULL) {					\
		(*r->rtt_func)(r->rtt_rt, r);				\
	} else {							\
		struct ifnet *ifp;					\
									\
		ifp = if_get(r->rtt_rt->rt_ifidx);			\
		if (ifp != NULL) 					\
			rtdeletemsg(r->rtt_rt, ifp, r->rtt_tableid);	\
		if_put(ifp);						\
	}								\
}

/*
 * Some subtle order problems with domain initialization mean that
 * we cannot count on this being run from rt_init before various
 * protocol initializations are done.  Therefore, we make sure
 * that this is run when the first queue is added...
 */

void
rt_timer_init(void)
{
	static struct timeout	rt_timer_timeout;

	if (rt_init_done)
		panic("rt_timer_init: already initialized");

	pool_init(&rttimer_pool, sizeof(struct rttimer), 0, IPL_SOFTNET, 0,
	    "rttmr", NULL);

	LIST_INIT(&rttimer_queue_head);
	timeout_set_proc(&rt_timer_timeout, rt_timer_timer, &rt_timer_timeout);
	timeout_add_sec(&rt_timer_timeout, 1);
	rt_init_done = 1;
}

struct rttimer_queue *
rt_timer_queue_create(u_int timeout)
{
	struct rttimer_queue	*rtq;

	if (rt_init_done == 0)
		rt_timer_init();

	if ((rtq = malloc(sizeof(*rtq), M_RTABLE, M_NOWAIT|M_ZERO)) == NULL)
		return (NULL);

	rtq->rtq_timeout = timeout;
	rtq->rtq_count = 0;
	TAILQ_INIT(&rtq->rtq_head);
	LIST_INSERT_HEAD(&rttimer_queue_head, rtq, rtq_link);

	return (rtq);
}

void
rt_timer_queue_change(struct rttimer_queue *rtq, long timeout)
{
	rtq->rtq_timeout = timeout;
}

void
rt_timer_queue_destroy(struct rttimer_queue *rtq)
{
	struct rttimer	*r;

	NET_ASSERT_LOCKED();

	while ((r = TAILQ_FIRST(&rtq->rtq_head)) != NULL) {
		LIST_REMOVE(r, rtt_link);
		TAILQ_REMOVE(&rtq->rtq_head, r, rtt_next);
		RTTIMER_CALLOUT(r);
		pool_put(&rttimer_pool, r);
		if (rtq->rtq_count > 0)
			rtq->rtq_count--;
		else
			printf("rt_timer_queue_destroy: rtq_count reached 0\n");
	}

	LIST_REMOVE(rtq, rtq_link);
	free(rtq, M_RTABLE, sizeof(*rtq));
}

unsigned long
rt_timer_queue_count(struct rttimer_queue *rtq)
{
	return (rtq->rtq_count);
}

void
rt_timer_remove_all(struct rtentry *rt)
{
	struct rttimer	*r;

	while ((r = LIST_FIRST(&rt->rt_timer)) != NULL) {
		LIST_REMOVE(r, rtt_link);
		TAILQ_REMOVE(&r->rtt_queue->rtq_head, r, rtt_next);
		if (r->rtt_queue->rtq_count > 0)
			r->rtt_queue->rtq_count--;
		else
			printf("rt_timer_remove_all: rtq_count reached 0\n");
		pool_put(&rttimer_pool, r);
	}
}

int
rt_timer_add(struct rtentry *rt, void (*func)(struct rtentry *,
    struct rttimer *), struct rttimer_queue *queue, u_int rtableid)
{
	struct rttimer	*r;
	long		 current_time;

	current_time = time_uptime;
	rt->rt_expire = time_uptime + queue->rtq_timeout;

	/*
	 * If there's already a timer with this action, destroy it before
	 * we add a new one.
	 */
	LIST_FOREACH(r, &rt->rt_timer, rtt_link) {
		if (r->rtt_func == func) {
			LIST_REMOVE(r, rtt_link);
			TAILQ_REMOVE(&r->rtt_queue->rtq_head, r, rtt_next);
			if (r->rtt_queue->rtq_count > 0)
				r->rtt_queue->rtq_count--;
			else
				printf("rt_timer_add: rtq_count reached 0\n");
			pool_put(&rttimer_pool, r);
			break;  /* only one per list, so we can quit... */
		}
	}

	r = pool_get(&rttimer_pool, PR_NOWAIT | PR_ZERO);
	if (r == NULL)
		return (ENOBUFS);

	r->rtt_rt = rt;
	r->rtt_time = current_time;
	r->rtt_func = func;
	r->rtt_queue = queue;
	r->rtt_tableid = rtableid;
	LIST_INSERT_HEAD(&rt->rt_timer, r, rtt_link);
	TAILQ_INSERT_TAIL(&queue->rtq_head, r, rtt_next);
	r->rtt_queue->rtq_count++;

	return (0);
}

void
rt_timer_timer(void *arg)
{
	struct timeout		*to = (struct timeout *)arg;
	struct rttimer_queue	*rtq;
	struct rttimer		*r;
	long			 current_time;
	int			 s;

	current_time = time_uptime;

	NET_LOCK(s);
	LIST_FOREACH(rtq, &rttimer_queue_head, rtq_link) {
		while ((r = TAILQ_FIRST(&rtq->rtq_head)) != NULL &&
		    (r->rtt_time + rtq->rtq_timeout) < current_time) {
			LIST_REMOVE(r, rtt_link);
			TAILQ_REMOVE(&rtq->rtq_head, r, rtt_next);
			RTTIMER_CALLOUT(r);
			pool_put(&rttimer_pool, r);
			if (rtq->rtq_count > 0)
				rtq->rtq_count--;
			else
				printf("rt_timer_timer: rtq_count reached 0\n");
		}
	}
	NET_UNLOCK(s);

	timeout_add_sec(to, 1);
}

u_int16_t
rtlabel_name2id(char *name)
{
	struct rt_label		*label, *p;
	u_int16_t		 new_id = 1;

	if (!name[0])
		return (0);

	TAILQ_FOREACH(label, &rt_labels, rtl_entry)
		if (strcmp(name, label->rtl_name) == 0) {
			label->rtl_ref++;
			return (label->rtl_id);
		}

	/*
	 * to avoid fragmentation, we do a linear search from the beginning
	 * and take the first free slot we find. if there is none or the list
	 * is empty, append a new entry at the end.
	 */
	TAILQ_FOREACH(p, &rt_labels, rtl_entry) {
		if (p->rtl_id != new_id)
			break;
		new_id = p->rtl_id + 1;
	}
	if (new_id > LABELID_MAX)
		return (0);

	label = malloc(sizeof(*label), M_RTABLE, M_NOWAIT|M_ZERO);
	if (label == NULL)
		return (0);
	strlcpy(label->rtl_name, name, sizeof(label->rtl_name));
	label->rtl_id = new_id;
	label->rtl_ref++;

	if (p != NULL)	/* insert new entry before p */
		TAILQ_INSERT_BEFORE(p, label, rtl_entry);
	else		/* either list empty or no free slot in between */
		TAILQ_INSERT_TAIL(&rt_labels, label, rtl_entry);

	return (label->rtl_id);
}

const char *
rtlabel_id2name(u_int16_t id)
{
	struct rt_label	*label;

	TAILQ_FOREACH(label, &rt_labels, rtl_entry)
		if (label->rtl_id == id)
			return (label->rtl_name);

	return (NULL);
}

struct sockaddr *
rtlabel_id2sa(u_int16_t labelid, struct sockaddr_rtlabel *sa_rl)
{
	const char	*label;

	if (labelid == 0 || (label = rtlabel_id2name(labelid)) == NULL)
		return (NULL);

	bzero(sa_rl, sizeof(*sa_rl));
	sa_rl->sr_len = sizeof(*sa_rl);
	sa_rl->sr_family = AF_UNSPEC;
	strlcpy(sa_rl->sr_label, label, sizeof(sa_rl->sr_label));

	return ((struct sockaddr *)sa_rl);
}

void
rtlabel_unref(u_int16_t id)
{
	struct rt_label	*p, *next;

	if (id == 0)
		return;

	TAILQ_FOREACH_SAFE(p, &rt_labels, rtl_entry, next) {
		if (id == p->rtl_id) {
			if (--p->rtl_ref == 0) {
				TAILQ_REMOVE(&rt_labels, p, rtl_entry);
				free(p, M_RTABLE, sizeof(*p));
			}
			break;
		}
	}
}

void
rt_if_track(struct ifnet *ifp)
{
	int i;
	u_int tid;

	for (tid = 0; tid < rtmap_limit; tid++) {
		/* skip rtables that are not in the rdomain of the ifp */
		if (rtable_l2(tid) != ifp->if_rdomain)
			continue;
		for (i = 1; i <= AF_MAX; i++) {
			if (!rtable_mpath_capable(tid, i))
				continue;

			rtable_walk(tid, i, rt_if_linkstate_change, ifp);
		}
	}
}

int
rt_if_linkstate_change(struct rtentry *rt, void *arg, u_int id)
{
	struct ifnet *ifp = arg;
	struct sockaddr_in6 sa_mask;

	if (rt->rt_ifidx != ifp->if_index)
		return (0);

	/* Local routes are always usable. */
	if (rt->rt_flags & RTF_LOCAL) {
		rt->rt_flags |= RTF_UP;
		return (0);
	}

	if (LINK_STATE_IS_UP(ifp->if_link_state) && ifp->if_flags & IFF_UP) {
		if (!(rt->rt_flags & RTF_UP)) {
			/* bring route up */
			rt->rt_flags |= RTF_UP;
			rtable_mpath_reprio(id, rt_key(rt),
			    rt_plen2mask(rt, &sa_mask),
			    rt->rt_priority & RTP_MASK, rt);
		}
	} else {
		if (rt->rt_flags & RTF_UP) {
			/*
			 * Remove redirected and cloned routes (mainly ARP)
			 * from down interfaces so we have a chance to get
			 * new routes from a better source.
			 */
			if (ISSET(rt->rt_flags, RTF_CLONED|RTF_DYNAMIC) &&
			    !ISSET(rt->rt_flags, RTF_CACHED|RTF_BFD)) {
				int error;

				if ((error = rtdeletemsg(rt, ifp, id)))
					return (error);
				return (EAGAIN);
			}
			/* take route down */
			rt->rt_flags &= ~RTF_UP;
			rtable_mpath_reprio(id, rt_key(rt),
			    rt_plen2mask(rt, &sa_mask),
			    rt->rt_priority | RTP_DOWN, rt);
		}
	}
	if_group_routechange(rt_key(rt), rt_plen2mask(rt, &sa_mask));

	return (0);
}

struct sockaddr *
rt_plentosa(sa_family_t af, int plen, struct sockaddr_in6 *sa_mask)
{
	struct sockaddr_in	*sin = (struct sockaddr_in *)sa_mask;
#ifdef INET6
	struct sockaddr_in6	*sin6 = (struct sockaddr_in6 *)sa_mask;
#endif

	KASSERT(plen >= 0 || plen == -1);

	if (plen == -1)
		return (NULL);

	memset(sa_mask, 0, sizeof(*sa_mask));

	switch (af) {
	case AF_INET:
		sin->sin_family = AF_INET;
		sin->sin_len = sizeof(struct sockaddr_in);
		in_prefixlen2mask(&sin->sin_addr, plen);
		break;
#ifdef INET6
	case AF_INET6:
		sin6->sin6_family = AF_INET6;
		sin6->sin6_len = sizeof(struct sockaddr_in6);
		in6_prefixlen2mask(&sin6->sin6_addr, plen);
		break;
#endif /* INET6 */
	default:
		return (NULL);
	}

	return ((struct sockaddr *)sa_mask);
}

struct sockaddr *
rt_plen2mask(struct rtentry *rt, struct sockaddr_in6 *sa_mask)
{
	return (rt_plentosa(rt_key(rt)->sa_family, rt_plen(rt), sa_mask));
}

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_output.h>

void
db_print_sa(struct sockaddr *sa)
{
	int len;
	u_char *p;

	if (sa == NULL) {
		db_printf("[NULL]");
		return;
	}

	p = (u_char *)sa;
	len = sa->sa_len;
	db_printf("[");
	while (len > 0) {
		db_printf("%d", *p);
		p++;
		len--;
		if (len)
			db_printf(",");
	}
	db_printf("]\n");
}

void
db_print_ifa(struct ifaddr *ifa)
{
	if (ifa == NULL)
		return;
	db_printf("  ifa_addr=");
	db_print_sa(ifa->ifa_addr);
	db_printf("  ifa_dsta=");
	db_print_sa(ifa->ifa_dstaddr);
	db_printf("  ifa_mask=");
	db_print_sa(ifa->ifa_netmask);
	db_printf("  flags=0x%x, refcnt=%d, metric=%d\n",
	    ifa->ifa_flags, ifa->ifa_refcnt, ifa->ifa_metric);
}

/*
 * Function to pass to rtalble_walk().
 * Return non-zero error to abort walk.
 */
int
db_show_rtentry(struct rtentry *rt, void *w, unsigned int id)
{
	db_printf("rtentry=%p", rt);

	db_printf(" flags=0x%x refcnt=%d use=%llu expire=%lld rtableid=%u\n",
	    rt->rt_flags, rt->rt_refcnt, rt->rt_use, rt->rt_expire, id);

	db_printf(" key="); db_print_sa(rt_key(rt));
	db_printf(" plen=%d", rt_plen(rt));
	db_printf(" gw="); db_print_sa(rt->rt_gateway);
	db_printf(" ifidx=%u ", rt->rt_ifidx);
	db_printf(" ifa=%p\n", rt->rt_ifa);
	db_print_ifa(rt->rt_ifa);

	db_printf(" gwroute=%p llinfo=%p\n", rt->rt_gwroute, rt->rt_llinfo);
	return (0);
}

/*
 * Function to print all the route trees.
 * Use this from ddb:  "call db_show_arptab"
 */
int
db_show_arptab(void)
{
	db_printf("Route tree for AF_INET\n");
	rtable_walk(0, AF_INET, db_show_rtentry, NULL);
	return (0);
}
#endif /* DDB */
@


1.364
log
@Enable mpath support in the Allotment Routing Table (ART) on the ramdisk.
OK mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.363 2017/07/30 18:16:14 florian Exp $	*/
a720 10
		rtfree(rt);
		return (ESRCH);
	}

	/*
	 * If we got multipath routes, we require users to specify
	 * a matching gateway.
	 */
	if ((rt->rt_flags & RTF_MPATH) &&
	    info->rti_info[RTAX_GATEWAY] == NULL) {
@


1.363
log
@Switch installer to Allotment Routing Table (ART).
Prompted by a bugreport by naddy that IPv6 autoconfiguration is broken
in the installer.
OK mpi, "go for it" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.362 2017/07/28 09:01:09 mpi Exp $	*/
a271 1
#ifndef SMALL_KERNEL
a352 1
#endif /* SMALL_KERNEL */
a724 1
#ifndef SMALL_KERNEL
a733 1
#endif
a840 1
#ifndef SMALL_KERNEL
a848 1
#endif
a1539 1
#ifndef SMALL_KERNEL
a1607 1
#endif
@


1.362
log
@Add an error argument to rtm_send() instead of rerolling it inside
rtdeletemsg().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.361 2017/07/27 12:27:24 mpi Exp $	*/
a1654 3
#ifndef ART
	return (rt_mask(rt));
#else
a1655 1
#endif /* ART */
@


1.361
log
@Export RTAX_IFP, RTAX_IFA and RTAX_LABEL to userland in rtdeletemsg().

Reduce differences with rtm_miss().

ok claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.360 2017/07/24 09:20:32 mpi Exp $	*/
d261 1
a261 1
				rtm_send(rt, RTM_ADD, tableid);
a629 1
	struct sockaddr_rtlabel	sa_rl;
a643 4
	info.rti_info[RTAX_LABEL] = rtlabel_id2sa(rt->rt_labelid, &sa_rl);
	info.rti_flags = rt->rt_flags;
	info.rti_info[RTAX_IFP] = sdltosa(ifp->if_sadl);
	info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
d646 1
a646 2
	rtm_miss(RTM_DELETE, &info, rt->rt_flags, rt->rt_priority, rt->rt_ifidx,
	    error, tableid);
d1069 1
a1069 1
		rtm_send(rt, RTM_ADD, rtableid);
d1122 1
a1122 1
		rtm_send(rt, RTM_DELETE, rtableid);
@


1.360
log
@rt_getifa() is only needed for routing commands submited by userland.

So rename it to rtm_getifa(), move it where it belongs and stop calling
it from rtrequest(9).  Route entries created by the kernel must always
specify the corresponding `ifa'.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.359 2017/06/09 12:56:43 mpi Exp $	*/
d630 1
a630 1
	unsigned int		ifidx;
d640 1
a640 1
	bzero((caddr_t)&info, sizeof(info));
d642 1
d645 1
a645 1
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
d647 2
a648 1
	ifidx = rt->rt_ifidx;
d651 1
a651 1
	rtm_miss(RTM_DELETE, &info, info.rti_flags, rt->rt_priority, ifidx,
@


1.359
log
@Replace rtrequest(RTM_DELETE...) rtrequest_delete() and do not even
try to remove a route from the table if it is and invalid cache.

This is a step towards decoupling code dealing with userland and kernel
inserted routes.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.358 2017/06/07 13:28:02 mpi Exp $	*/
a136 5
#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#include <net/if_enc.h>
#endif

a163 3
struct	ifaddr *ifa_ifwithroute(int, struct sockaddr *, struct sockaddr *,
		    u_int);

a708 114
struct ifaddr *
ifa_ifwithroute(int flags, struct sockaddr *dst, struct sockaddr *gateway,
    u_int rtableid)
{
	struct ifaddr	*ifa;

	if ((flags & RTF_GATEWAY) == 0) {
		/*
		 * If we are adding a route to an interface,
		 * and the interface is a pt to pt link
		 * we should search for the destination
		 * as our clue to the interface.  Otherwise
		 * we can use the local address.
		 */
		ifa = NULL;
		if (flags & RTF_HOST)
			ifa = ifa_ifwithdstaddr(dst, rtableid);
		if (ifa == NULL)
			ifa = ifa_ifwithaddr(gateway, rtableid);
	} else {
		/*
		 * If we are adding a route to a remote net
		 * or host, the gateway may still be on the
		 * other end of a pt to pt link.
		 */
		ifa = ifa_ifwithdstaddr(gateway, rtableid);
	}
	if (ifa == NULL) {
		if (gateway->sa_family == AF_LINK) {
			struct sockaddr_dl *sdl = satosdl(gateway);
			struct ifnet *ifp = if_get(sdl->sdl_index);

			if (ifp != NULL)
				ifa = ifaof_ifpforaddr(dst, ifp);
			if_put(ifp);
		} else {
			struct rtentry *rt;

			rt = rtalloc(gateway, RT_RESOLVE, rtable_l2(rtableid));
			if (rt != NULL)
				ifa = rt->rt_ifa;
			rtfree(rt);
		}
	}
	if (ifa == NULL)
		return (NULL);
	if (ifa->ifa_addr->sa_family != dst->sa_family) {
		struct ifaddr	*oifa = ifa;
		ifa = ifaof_ifpforaddr(dst, ifa->ifa_ifp);
		if (ifa == NULL)
			ifa = oifa;
	}
	return (ifa);
}

int
rt_getifa(struct rt_addrinfo *info, u_int rtid)
{
	struct ifnet	*ifp = NULL;

	/*
	 * ifp may be specified by sockaddr_dl when protocol address
	 * is ambiguous
	 */
	if (info->rti_info[RTAX_IFP] != NULL) {
		struct sockaddr_dl *sdl;

		sdl = satosdl(info->rti_info[RTAX_IFP]);
		ifp = if_get(sdl->sdl_index);
	}

#ifdef IPSEC
	/*
	 * If the destination is a PF_KEY address, we'll look
	 * for the existence of a encap interface number or address
	 * in the options list of the gateway. By default, we'll return
	 * enc0.
	 */
	if (info->rti_info[RTAX_DST] &&
	    info->rti_info[RTAX_DST]->sa_family == PF_KEY)
		info->rti_ifa = enc_getifa(rtid, 0);
#endif

	if (info->rti_ifa == NULL && info->rti_info[RTAX_IFA] != NULL)
		info->rti_ifa = ifa_ifwithaddr(info->rti_info[RTAX_IFA], rtid);

	if (info->rti_ifa == NULL) {
		struct sockaddr	*sa;

		if ((sa = info->rti_info[RTAX_IFA]) == NULL)
			if ((sa = info->rti_info[RTAX_GATEWAY]) == NULL)
				sa = info->rti_info[RTAX_DST];

		if (sa != NULL && ifp != NULL)
			info->rti_ifa = ifaof_ifpforaddr(sa, ifp);
		else if (info->rti_info[RTAX_DST] != NULL &&
		    info->rti_info[RTAX_GATEWAY] != NULL)
			info->rti_ifa = ifa_ifwithroute(info->rti_flags,
			    info->rti_info[RTAX_DST],
			    info->rti_info[RTAX_GATEWAY],
			    rtid);
		else if (sa != NULL)
			info->rti_ifa = ifa_ifwithroute(info->rti_flags,
			    sa, sa, rtid);
	}

	if_put(ifp);

	if (info->rti_ifa == NULL)
		return (ENETUNREACH);

	return (0);
}

d820 2
a821 2
		if (info->rti_ifa == NULL && (error = rt_getifa(info, tableid)))
			return (error);
@


1.358
log
@Grab the KERNEL_LOCK() around rtm*() functions.  Routing sockets globals
aren't protected by the NET_LOCK().

While here change lock assertions in rt_{set,put}gwroute(), the NET_LOCK()
is enough.

Tested by Hrvoje Popovski.

ok jmatthew@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.357 2017/05/27 09:51:18 claudio Exp $	*/
a170 2
int	rtrequest_delete(struct rt_addrinfo *, u_int8_t, struct ifnet *,
	    struct rtentry **, u_int);
d889 2
a890 10
	if (ifp == NULL) {
		ifp = if_get(rt->rt_ifidx);
		if (ifp != NULL) {
			ifp->if_rtrequest(ifp, RTM_DELETE, rt);
			if_put(ifp);
		}
	} else {
		KASSERT(ifp->if_index == rt->rt_ifidx);
		ifp->if_rtrequest(ifp, RTM_DELETE, rt);
	}
d925 1
a925 4
		error = rtrequest_delete(info, prio, NULL, ret_nrt, tableid);
		if (error)
			return (error);
		break;
d1403 11
a1413 10
#define RTTIMER_CALLOUT(r)	{				\
	if (r->rtt_func != NULL) {				\
		(*r->rtt_func)(r->rtt_rt, r);			\
	} else {						\
		struct rt_addrinfo info;			\
		bzero(&info, sizeof(info));			\
		info.rti_info[RTAX_DST] = rt_key(r->rtt_rt);	\
		rtrequest(RTM_DELETE, &info,			\
		    r->rtt_rt->rt_priority, NULL, r->rtt_tableid);	\
	}							\
@


1.357
log
@In ifa_ifwithroute() the rtalloc() needs to be done against the rdomain
so use rtable_l2() to get the right id. Fixes adding routes to rtables.
OK mpi@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.356 2017/05/16 12:24:01 mpi Exp $	*/
d388 1
a388 1
	KERNEL_ASSERT_LOCKED();
d445 1
a445 1
	KERNEL_ASSERT_LOCKED();
d627 1
d629 1
d658 1
d661 1
@


1.356
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.355 2017/04/19 15:21:54 bluhm Exp $	*/
d753 1
a753 1
			rt = rtalloc(gateway, RT_RESOLVE, rtableid);
@


1.355
log
@Use the rt_rmx defines that hide the struct rt_kmetrics indirection.
No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.354 2017/03/06 08:56:39 mpi Exp $	*/
d244 1
a244 1
	splsoftassert(IPL_SOFTNET);
d836 1
a836 1
	splsoftassert(IPL_SOFTNET);
d923 1
a923 1
	splsoftassert(IPL_SOFTNET);
@


1.354
log
@Prefix functions dealing with routing messages with 'rtm_' and keep
them all in net/rtsock.c.

This allows to easily spot which functions are doing a copyout(9)
when dealing with the routing midlayer.

ok phessler@@, bluhm@@, dhill@@, krw@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.353 2017/03/02 03:09:50 renato Exp $	*/
d1525 1
a1525 1
	rt->rt_rmx.rmx_expire = time_uptime + queue->rtq_timeout;
@


1.353
log
@Allow MPLS switching and VPLS across rdomains.

OK claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.352 2017/02/28 10:16:38 mpi Exp $	*/
d267 1
a267 1
				rt_missmsg(RTM_MISS, &info, 0, RTP_NONE, 0,
d271 1
a271 1
				rt_sendmsg(rt, RTM_ADD, tableid);
a501 25
rt_sendmsg(struct rtentry *rt, int cmd, u_int rtableid)
{
	struct rt_addrinfo	 info;
	struct ifnet		*ifp;
	struct sockaddr_rtlabel	 sa_rl;
	struct sockaddr_in6	 sa_mask;

	memset(&info, 0, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	if (!ISSET(rt->rt_flags, RTF_HOST))
		info.rti_info[RTAX_NETMASK] = rt_plen2mask(rt, &sa_mask);
	info.rti_info[RTAX_LABEL] = rtlabel_id2sa(rt->rt_labelid, &sa_rl);
	ifp = if_get(rt->rt_ifidx);
	if (ifp != NULL) {
		info.rti_info[RTAX_IFP] = sdltosa(ifp->if_sadl);
		info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
	}

	rt_missmsg(cmd, &info, rt->rt_flags, rt->rt_priority, rt->rt_ifidx, 0,
	    rtableid);
	if_put(ifp);
}

void
d627 1
a627 1
	rt_missmsg(RTM_REDIRECT, &info, flags, prio, ifidx, error, rdomain);
d656 1
a656 1
	rt_missmsg(RTM_DELETE, &info, info.rti_flags, rt->rt_priority, ifidx,
d1203 2
a1204 2
			rt_sendaddrmsg(rt, RTM_NEWADDR, ifa);
		rt_sendmsg(rt, RTM_ADD, rtableid);
d1257 1
a1257 1
		rt_sendmsg(rt, RTM_DELETE, rtableid);
d1259 1
a1259 1
			rt_sendaddrmsg(rt, RTM_DELADDR, ifa);
@


1.352
log
@Use rtable_match() rather than rtalloc(9) when adding a new route.

rtalloc(9) should be reserved for the hot path otherwise it's hard
to interpret the value of the 'use' counter.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.351 2017/02/15 18:53:29 bluhm Exp $	*/
d1207 1
a1207 1
	if ((flags & RTF_MPLS) == RTF_MPLS) {
a1208 4

		/* MPLS routes only exist in rdomain 0 */
		rtableid = 0;
	}
@


1.351
log
@Replace manual loops with FOREACH macro.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.350 2017/02/05 16:23:38 jca Exp $	*/
d1087 2
a1088 1
		if (error != 0 && (crt = rtalloc(ndst, 0, tableid)) != NULL) {
@


1.350
log
@Always allocate counters memory using type M_COUNTERS.

This makes the API simpler, and is probably more useful than spreading
counters memory other several types, making it harder to track.

Prodded by mpi, ok mpi@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.349 2017/01/24 10:08:30 krw Exp $	*/
d1559 1
a1559 2
	for (r = LIST_FIRST(&rt->rt_timer); r != NULL;
	     r = LIST_NEXT(r, rtt_link)) {
d1600 1
a1600 2
	for (rtq = LIST_FIRST(&rttimer_queue_head); rtq != NULL;
	     rtq = LIST_NEXT(rtq, rtq_link)) {
d1621 1
a1621 1
	struct rt_label		*label, *p = NULL;
d1638 5
a1642 6

	if (!TAILQ_EMPTY(&rt_labels))
		for (p = TAILQ_FIRST(&rt_labels); p != NULL &&
		    p->rtl_id == new_id; p = TAILQ_NEXT(p, rtl_entry))
			new_id = p->rtl_id + 1;

d1697 1
a1697 2
	for (p = TAILQ_FIRST(&rt_labels); p != NULL; p = next) {
		next = TAILQ_NEXT(p, rtl_entry);
@


1.349
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.348 2017/01/24 04:45:35 phessler Exp $	*/
d194 1
a194 1
	rtcounters = counters_alloc(rts_ncounters, M_COUNTERS);
@


1.348
log
@when we lose link, do not delete entries that have the RTF_BFD flag set

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.347 2017/01/20 08:10:54 dlg Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d66 1
a66 1
 * 
d70 1
a70 1
 * 
d78 4
a81 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d85 1
a85 1
 * 
d97 1
a97 1
 * 
d221 2
a222 2
	    	KASSERT(!ISSET(rt->rt_gwroute->rt_flags, RTF_GATEWAY));
	    	if (!ISSET(rt->rt_gwroute->rt_flags, RTF_UP))
d288 1
a288 1
	b -= c; b -= a; b ^= (a << 8); 					\
d292 2
a293 2
	c -= a; c -= b; c ^= (b >> 5); 					\
	a -= b; a -= c; a ^= (c >> 3); 					\
d554 1
a554 1
	int 			 flags = RTF_GATEWAY|RTF_HOST;
d1023 1
a1023 1
		/* We have to allocate additional space for MPLS infos */ 
d1452 1
a1452 1
/* 
d1739 1
a1739 1
	    	return (0);
@


1.347
log
@use per-cpu counters for rtstat.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.346 2017/01/19 04:06:26 phessler Exp $	*/
d1763 1
a1763 1
			    !ISSET(rt->rt_flags, RTF_CACHED)) {
@


1.346
log
@remove the BFD flag on a route *before* we actually delete the route

should fix a panic reported by Hrvoje Popovski
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.345 2016/12/19 08:36:49 mpi Exp $	*/
d153 1
a153 1
struct rtstat		rtstat;
d194 2
d278 1
a278 1
		rtstat.rts_unreach++;
d550 1
a550 1
	u_int32_t		*stat = NULL;
d622 1
a622 1
			stat = &rtstat.rts_dynamic;
d631 1
a631 1
			stat = &rtstat.rts_newgateway;
d645 3
a647 3
		rtstat.rts_badredirect++;
	else if (stat != NULL)
		(*stat)++;
@


1.345
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.344 2016/12/17 14:26:53 mpi Exp $	*/
d886 5
a896 5

#ifdef BFD
	if (ISSET(rt->rt_flags, RTF_BFD))
		bfdclear(rt);
#endif
@


1.344
log
@Insert RTF_CLONED routes at a higher priority than their partent to
prevent a mpath conflict for /32 RTF_CLONING routes.

Found the hardway by jsing@@ on Google Compute Engine.

ok bluhm@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.343 2016/12/14 20:35:20 stsp Exp $	*/
d555 1
a555 1
	splsoftassert(IPL_SOFTNET);
d1504 1
a1504 1
	splsoftassert(IPL_SOFTNET);
d1598 1
a1598 1
	s = splsoftnet();
d1613 1
a1613 1
	splx(s);
@


1.343
log
@Make 'route add default' show a nicer error message if the provided
gateway is not reachable (e.g. not on a local subnet).
ok millert@@ mikeb@@ mpi@@
(and shrugs by jca@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.342 2016/12/04 09:46:39 stsp Exp $	*/
d255 9
a263 2
			error = rtrequest(RTM_RESOLVE, &info, RTP_DEFAULT,
			    &rt, tableid);
d1056 8
a1063 9
		if (rt->rt_flags & RTF_CLONED) {
			/*
			 * Copy both metrics and a back pointer to the cloned
			 * route's parent.
			 */
			rt->rt_rmx = (*ret_nrt)->rt_rmx; /* copy metrics */
			rt->rt_priority = (*ret_nrt)->rt_priority;
			rt->rt_parent = *ret_nrt;	 /* Back ptr. to parent. */
			rtref(rt->rt_parent);
@


1.342
log
@Since net/route.c r1.337 interface priority factors into route priority
when RTF_CONNECTED routes are added to the routing table.
Specify a route priority calculated in the same way when deleting such routes.
Makes route add and delete code paths consistent again.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.341 2016/12/02 11:19:17 mpi Exp $	*/
d400 1
a400 1
		return (ELOOP);
@


1.341
log
@Assert that rt_match() is always called at IPL_SOFTNET rather than
calling splsoftnet() recursively.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.340 2016/11/29 10:22:30 jsg Exp $	*/
d1273 1
a1273 1
		prio = RTP_CONNECTED;
@


1.340
log
@m_free() and m_freem() test for NULL.  Simplify callers which had their own
NULL tests.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.339 2016/11/21 10:30:42 mpi Exp $	*/
d240 3
a242 1
	int			 s, error = 0;
a243 1
	s = splsoftnet();
a269 1
	splx(s);
@


1.339
log
@Kill rtioctl() stub, returning EOPNOTSUPP since tree import.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.338 2016/11/15 10:09:28 mpi Exp $	*/
d1282 1
a1282 2
	if (m != NULL)
		m_free(m);
@


1.338
log
@Properly initialize ``ifa''.

Note that dereferencing ``rt_ifa'' after calling rtfree(9) is generally
not safe.  In this case we rely on the fact that rtredirect() is still
serialized with interface ioctl(2)s.

This function cries for a rewrite.

Reported by and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.337 2016/11/14 12:45:30 mpi Exp $	*/
a728 6
}

int
rtioctl(u_long req, caddr_t data, struct proc *p)
{
	return (EOPNOTSUPP);
@


1.337
log
@Reflect interface priorities when inserting RTF_CONNECTED routes.

When multiple RTF_CLONING routes exist for a given subnet, bringing
one of the interfaces up/down could make impossible to insert new
ARP/NDP entries.

In this case the first RTF_CONNECTED route of the multipath list no
longer corresponded to the wired interface because it had the same
priority as the carp(4) route.

This is another regression of supporting multiple RTF_CONNECTED routes.

Fix a bug with a CARP setup reported by stsp@@

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.336 2016/11/14 10:32:46 mpi Exp $	*/
d558 1
@


1.336
log
@Automatically create a default lo(4) interface per rdomain.

In order to stop abusing lo0 for all rdomains, a new loopback interface
will be created every time a rdomain is created.  The unit number will
be the same as the rdomain, i.e. lo1 will be attached to rdomain 1.

If this loopback interface is already in use it wont be possible to create
the corresponding rdomain.

In order to know which lo(4) interface is attached to a rdomain, its index
is stored in the rtable/rdomain map.

This is a long overdue since the introduction of rtable/rdomain.  It also
fixes a recent regression due to resetting the rdomain of an incoming
packet reported by semarie@@, Andreas Bartelt and Nils Frohberg.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.335 2016/11/09 09:04:48 mpi Exp $	*/
d1218 1
a1218 1
		prio = RTP_CONNECTED;
@


1.335
log
@Do not call splsoftnet() recursively, this won't work with a lock.

Timers configured via rt_timer_add(9) always run at IPL_SOFTNET, so
assert that rather than calling splsoftnet().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.334 2016/11/08 10:39:32 mpi Exp $	*/
a199 2
	if (rtable_add(0) != 0)
		panic("route_init rtable_add");
@


1.334
log
@Use rtalloc(9) instead of ifa_ifwithnet().

ifa_ifwithnet() checks if a given address is directly connected.  This
function predates the introduction of the BSD routing table.  Nowdays
we can check if the route for the given address is marked as RTF_GATEWAY.

This works on OpenBSD because we always install RTF_CONNECTED routes
for subnets a and RTF_HOST route per p2p link.

ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.333 2016/10/06 19:09:08 bluhm Exp $	*/
d1505 2
@


1.333
log
@Remove redundant comments that say a function must be called at
splsoftnet() if the function does a splsoftassert(IPL_SOFTNET)
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.332 2016/10/05 08:07:46 mpi Exp $	*/
d553 3
a555 1
	if ((ifa = ifa_ifwithnet(gateway, rdomain)) == NULL) {
d559 4
a562 1
	ifidx = ifa->ifa_ifp->if_index;
@


1.332
log
@rt_timer_timer() needs a process context because it messes with the
routing table.

Found the hardway by Chris Jackman.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.331 2016/10/04 14:04:19 mpi Exp $	*/
a535 2
 *
 * N.B.: must be called at splsoftnet
@


1.331
log
@Correct the flag checks inside rt_ifa_addlocal(9) and rt_ifa_dellocal(9).

There's no need to insert an RTF_LOCAL route if it is already there, not
if a route with the same destination exist.

This fixes a KASSERT() triggered by adding an alias for an address already
present in the ARP cache as reported by weerd@@ and Peter J. Philipp.

This should also fix a KASSERT() triggered by a NDP change reported by
Sebastien Marie.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.330 2016/09/17 07:35:05 phessler Exp $	*/
d1468 1
a1468 1
	timeout_set(&rt_timer_timeout, rt_timer_timer, &rt_timer_timeout);
@


1.330
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.329 2016/09/15 02:00:18 dlg Exp $	*/
d1327 1
a1327 1
	/* If there is no loopback entry, allocate one. */
d1329 1
a1329 1
	if (rt == NULL || !ISSET(rt->rt_flags, flags))
d1378 1
a1378 1
	if (rt != NULL && ISSET(rt->rt_flags, flags))
@


1.329
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.328 2016/09/13 08:11:39 mpi Exp $	*/
d892 1
a892 1
		bfd_rtfree(rt);
@


1.328
log
@Stop creating a BFD descriptor when the route is created.

Since our BFD implementation relies on the existence of routes, it is much
easier to set the BFD parameters with RTM_CHANGE, especially if something
bad happen.

Discussed with and ok phessler@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.327 2016/09/08 09:11:43 mpi Exp $	*/
d194 2
a195 3
	pool_init(&rtentry_pool, sizeof(struct rtentry), 0, 0, 0, "rtentry",
	    NULL);
	pool_setipl(&rtentry_pool, IPL_SOFTNET);
d1464 2
a1465 3
	pool_init(&rttimer_pool, sizeof(struct rttimer), 0, 0, 0, "rttmr",
	    NULL);
	pool_setipl(&rttimer_pool, IPL_SOFTNET);
@


1.327
log
@Call bfd_rtfree() when the route entry has been removed from the table,
not before.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.326 2016/09/07 09:19:38 mpi Exp $	*/
a1100 5
#ifdef BFD
		if (error == 0 && ISSET(rt->rt_flags, RTF_BFD))
			error = bfd_rtalloc(rt);
			/* XXX this code will return EEXIST at the moment */
#endif
@


1.326
log
@Only free the old cached next hop route if the new one is valid.

Leaving a NULL pointer on a RTF_GATEWAY is no longer supported,
and a KASSERT() triggers.

Found the hardway by and ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.325 2016/09/04 15:45:42 bluhm Exp $	*/
a883 5
#ifdef BFD
	if (ISSET(rt->rt_flags, RTF_BFD))
		bfd_rtfree(rt);
#endif

d890 5
@


1.325
log
@Do not assume that an interface index of a route is still valid in
rtrequest_delete().  The inpcb has a cache of the route that still
exists when the interface has been detached.
kassert triggered from tcp timeout by awolk@@; OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.324 2016/09/04 10:32:01 mpi Exp $	*/
a384 1
	KASSERT(rt->rt_gwroute == NULL);
d406 4
d1145 1
a1145 2
	if (ISSET(rt->rt_flags, RTF_GATEWAY)) {
		rt_putgwroute(rt);
a1146 1
	}
@


1.324
log
@Purge routes attached to an address when this address is removed.

This is done to stop using stale ifa attached to routes, which is
the easiest way to make rtisvalid(9) MP-safe.

sthen@@ and henning@@ like it, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.323 2016/09/04 09:39:01 claudio Exp $	*/
d907 4
a910 3
		KASSERT(ifp != NULL);
		ifp->if_rtrequest(ifp, RTM_DELETE, rt);
		if_put(ifp);
@


1.323
log
@Make it possible to toggle RTF_BFD via RTM_CHANGE and fix some minor things
in bfd.c. Make bfd_rtfree() a void function.
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.322 2016/09/03 14:20:26 phessler Exp $	*/
d155 1
a162 1
int	rt_fixgwroute(struct rtentry *, void *, unsigned int);
d165 1
a165 1
int	rt_if_remove_rtdelete(struct rtentry *, void *, u_int);
a219 4
	/* Routes attached to stale ifas should be freed. */
	if (rt->rt_ifa == NULL || rt->rt_ifa->ifa_ifp == NULL)
		return (0);

a451 35
/*
 * Refresh cached entries of RTF_GATEWAY routes for a given interface.
 *
 * This clever logic is necessary to try to fix routes linked to stale
 * ifas.
 */
int
rt_fixgwroute(struct rtentry *rt, void *arg, unsigned int id)
{
	struct ifnet *ifp = arg;

	KERNEL_ASSERT_LOCKED();

	if (rt->rt_ifidx != ifp->if_index || !ISSET(rt->rt_flags, RTF_GATEWAY))
		return (0);

	/*
	 * If the gateway route is not stale, its associated cached
	 * is also not stale.
	 */
	if (rt->rt_ifa->ifa_ifp != NULL)
		return (0);

	/* If we can fix the cached next hop entry, we can fix the ifa. */
	if (rt_setgate(rt, rt->rt_gateway, ifp->if_rdomain) == 0) {
		struct ifaddr *ifa = rt->rt_gwroute->rt_ifa;

		ifafree(rt->rt_ifa);
		ifa->ifa_refcnt++;
		rt->rt_ifa = ifa;
	}

	return (0);
}

d522 2
a523 1
	if (ifa->ifa_refcnt == 0)
d525 1
a525 1
	else
d700 1
a700 1
	 * the routes are being purged by rt_if_remove().
d958 2
a959 16
		if (rt->rt_ifa->ifa_ifp) {
			info->rti_ifa = rt->rt_ifa;
		} else {
			/*
			 * The address of the cloning route is not longer
			 * configured on an interface, but its descriptor
			 * is still there because of reference counting.
			 *
			 * Try to find a similar active address and use
			 * it for the cloned route.  The cloning route
			 * will get the new address and interface later.
			 */
			info->rti_ifa = NULL;
			info->rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
		}

a1051 23
			 * If the ifa of the cloning route was stale, a
			 * successful lookup for an ifa with the same address
			 * has been made.  Use this ifa also for the cloning
			 * route.
			 */
			if ((*ret_nrt)->rt_ifa->ifa_ifp == NULL) {
				struct ifnet *ifp0;

				printf("%s RTM_RESOLVE: wrong ifa (%p) was (%p)"
				    "\n", __func__, ifa, (*ret_nrt)->rt_ifa);

				ifp0 = if_get((*ret_nrt)->rt_ifidx);
				KASSERT(ifp0 != NULL);
				ifp0->if_rtrequest(ifp0, RTM_DELETE, *ret_nrt);
				ifafree((*ret_nrt)->rt_ifa);
				if_put(ifp0);

				ifa->ifa_refcnt++;
				(*ret_nrt)->rt_ifa = ifa;
				(*ret_nrt)->rt_ifidx = ifp->if_index;
				ifp->if_rtrequest(ifp, RTM_ADD, *ret_nrt);
			}
			/*
a1224 2
		unsigned int i;

a1233 12

		/*
		 * Userland inserted routes stay in the table even
		 * if their corresponding ``ifa'' is no longer valid.
		 *
		 * Try to fix the stale RTF_GATEWAY entries in case
		 * their gateway match the newly inserted route.
		 */
		for (i = 0; i <= RT_TABLEID_MAX; i++) {
			rtable_walk(i, ifa->ifa_addr->sa_family,
			    rt_fixgwroute, ifp);
		}
d1390 40
a1709 32
}

void
rt_if_remove(struct ifnet *ifp)
{
	int			 i;
	u_int			 tid;

	for (tid = 0; tid < rtmap_limit; tid++) {
		/* skip rtables that are not in the rdomain of the ifp */
		if (rtable_l2(tid) != ifp->if_rdomain)
			continue;
		for (i = 1; i <= AF_MAX; i++) {
			rtable_walk(tid, i, rt_if_remove_rtdelete, ifp);
		}
	}
}

int
rt_if_remove_rtdelete(struct rtentry *rt, void *vifp, u_int id)
{
	struct ifnet	*ifp = vifp;
	int		 error;

	if (rt->rt_ifidx != ifp->if_index)
		return (0);

	if ((error = rtdeletemsg(rt, ifp, id)))
		return (error);

	return (EAGAIN);

@


1.322
log
@Add in the (disabled) kernel glue for BFD

OK claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.321 2016/09/01 15:40:38 bluhm Exp $	*/
d142 1
a142 1
#if BFD
d203 1
a203 1
#if BFD
d917 1
d919 1
a919 1
#if BFD
d921 1
a921 2
		(void)bfd_rtfree(rt);
#endif	/* BFD */
d1172 5
a1185 5
#if BFD
		if (ISSET(rt->rt_flags, RTF_BFD)) {
			error = bfd_rtalloc(rt, NULL);
		}
#endif
@


1.321
log
@Disable the RTF_UP kassert check in rtisvalid() for now as it can
be triggered from userland.  A gateway route is simply not valid
if its gwroute is not up.
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.320 2016/09/01 11:26:44 mpi Exp $	*/
d142 4
d203 3
d917 5
d1181 5
@


1.320
log
@Move the RTF_LOCAL check that only makes sense for userland to
route_output().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.319 2016/08/31 08:13:17 mpi Exp $	*/
a216 1
#ifdef DIAGNOSTIC
a218 1
	    	KASSERT(ISSET(rt->rt_gwroute->rt_flags, RTF_UP));
d220 2
a222 1
#endif /* DIAGNOSTIC */
@


1.319
log
@Do not flush RTF_CLONED children when adding a new route.

New RTF_CLONING routes don't have children, but the kernel might end up
removing routes from a compatible route.  This bug has been introduced
with the support for multiple RTF_CLONING routes.

Also make sure to release possible RTF_CACHED route *before* flushing
RTF_CLONED children when deleting a route.

KASSERT() reported by akfaew, sthen@@ and martijn@@

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.318 2016/08/30 23:29:39 dlg Exp $	*/
a911 11

	/*
	 * Since RTP_LOCAL cannot be set by userland, make
	 * sure that local routes are only modified by the
	 * kernel.
	 */
	if ((rt->rt_flags & (RTF_LOCAL|RTF_BROADCAST)) &&
	    (prio & RTP_MASK) != RTP_LOCAL) {
		rtfree(rt);
		return (EINVAL);
	}
@


1.318
log
@pool_setipl

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.317 2016/08/22 16:53:59 mpi Exp $	*/
d931 5
a935 2
	/* clean up any cloned children */
	if ((rt->rt_flags & RTF_CLONING) != 0)
a937 2
	rt_putgwroute(rt);

a1181 5

		if ((rt->rt_flags & RTF_CLONING) != 0) {
			/* clean up any cloned children */
			rtflushclone(tableid, rt);
		}
@


1.317
log
@Use rtalloc(9) instead of ifa_ifwithnet() to find an interface
when adding a route to gateway to ensure a most specific match.

This makes "# route add"  coherent to "# route get" even with
p2p interfaces.  Fix a problem reported by Mart Tnso.

This also fix rttest20 after the introduction of RTF_CACHED.

ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.316 2016/08/22 16:01:52 mpi Exp $	*/
d192 1
d1518 1
@


1.316
log
@Make the ``rt_gwroute'' pointer of RTF_GATEWAY entries immutable.

This means that no protection is needed to guarantee that the next hop
route wont be modified by CPU1 while CPU0 is dereferencing it in a L2
resolution functions.

While here also fix an ``ifa'' leak resulting in RTF_GATEWAY being always
invalid.

dlg@@ likes it, inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.315 2016/08/19 07:12:54 mpi Exp $	*/
d800 5
a804 8
			ifa = ifa_ifwithnet(gateway, rtableid);
		}
	}
	if (ifa == NULL) {
		struct rtentry	*rt = rtalloc(gateway, 0, rtableid);
		/* The gateway must be local if the same address family. */
		if (!rtisvalid(rt) || ((rt->rt_flags & RTF_GATEWAY) &&
		    rt_key(rt)->sa_family == dst->sa_family)) {
a805 1
			return (NULL);
a806 2
		ifa = rt->rt_ifa;
		rtfree(rt);
d808 2
@


1.315
log
@Do not seroize a struct needed for RTM_RESOLVE in the hot path.

ok phessler@@, bluhm@@, tedu@@, natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.314 2016/08/16 09:01:14 mpi Exp $	*/
d156 3
a158 1
void	rt_setgwroute(struct rtentry *, u_int);
d209 1
a209 7
#ifdef DIAGNOSTIC
	if (ISSET(rt->rt_flags, RTF_GATEWAY) && (rt->rt_gwroute != NULL) &&
	    ISSET(rt->rt_gwroute->rt_flags, RTF_GATEWAY))
	    	panic("next hop must be directly reachable");
#endif

	if ((rt->rt_flags & RTF_UP) == 0)
d216 7
a222 2
	if (ISSET(rt->rt_flags, RTF_GATEWAY) && !rtisvalid(rt->rt_gwroute))
		return (0);
a272 2
struct rtentry *_rtalloc(struct sockaddr *, uint32_t *, int, unsigned int);

d353 1
a353 1
	return (_rtalloc(dst, src, RT_RESOLVE, rtableid));
a356 6
struct rtentry *
rtalloc(struct sockaddr *dst, int flags, unsigned int rtableid)
{
	return (_rtalloc(dst, NULL, flags, rtableid));
}

d365 1
a365 1
_rtalloc(struct sockaddr *dst, uint32_t *src, int flags, unsigned int rtableid)
d367 1
a367 15
	struct rtentry *rt;

	rt = rt_match(dst, src, flags, rtableid);

	/* No match or route to host?  We're done. */
	if (rt == NULL || !ISSET(rt->rt_flags, RTF_GATEWAY))
		return (rt);

	/* Nothing to do if the next hop is valid. */
	if (rtisvalid(rt->rt_gwroute))
		return (rt);

	rt_setgwroute(rt, rtableid);

	return (rt);
d370 5
a374 1
void
d379 4
a382 2
	rtfree(rt->rt_gwroute);
	rt->rt_gwroute = NULL;
d384 1
a384 8
	/*
	 * If we cannot find a valid next hop, return the route
	 * with a gateway.
	 *
	 * XXX Some dragons hiding in the tree certainly depends on
	 * this behavior.  But it is safe since rt_checkgate() wont
	 * allow us to us this route later on.
	 */
d387 7
a393 1
		return;
d401 1
a401 7
		return;
	}

	/* Next hop entry must be UP and on the same interface. */
	if (!ISSET(nhrt->rt_flags, RTF_UP) || nhrt->rt_ifidx != rt->rt_ifidx) {
		rtfree(nhrt);
		return;
d412 4
a415 2
	 * Do not return the cached next-hop route, rt_checkgate() will
	 * do the magic for us.
d417 3
d421 61
d938 1
a938 2
	rtfree(rt->rt_gwroute);
	rt->rt_gwroute = NULL;
d1147 1
a1147 1
			rtfree(rt->rt_gwroute);
d1177 1
a1177 1
			rtfree(rt->rt_gwroute);
d1218 4
a1221 2
	if (ISSET(rt->rt_flags, RTF_GATEWAY))
		rt_setgwroute(rt, rtableid);
d1226 6
a1231 2
int
rt_checkgate(struct rtentry *rt, struct rtentry **rtp)
d1233 3
a1235 10
	struct rtentry *rt0;

	KASSERT(rt != NULL);

	rt0 = rt;

	if (rt->rt_flags & RTF_GATEWAY) {
		if (rt->rt_gwroute == NULL)
			return (EHOSTUNREACH);
		rt = rt->rt_gwroute;
d1238 1
a1238 6
	if (rt->rt_flags & RTF_REJECT)
		if (rt->rt_expire == 0 || time_uptime < rt->rt_expire)
			return (rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);

	*rtp = rt;
	return (0);
d1302 2
d1313 12
d1844 2
a1845 1
			if (ISSET(rt->rt_flags, RTF_CLONED|RTF_DYNAMIC)) {
@


1.314
log
@Mask the ``prio'' prior to comparing it to RTP_LOCAL.

This allows rt_if_remove() to remove RTF_BROACAST routes from down
interfaces.

Issue reported by Dimitris Papastamos on bugs@@

ok dlg@@, claudio@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.313 2016/07/22 11:03:30 mpi Exp $	*/
a238 1
	struct rt_addrinfo	 info;
a240 3
	bzero(&info, sizeof(info));
	info.rti_info[RTAX_DST] = dst;

d245 2
d248 4
@


1.313
log
@Check for errors when deleting routes inside rtable_walk() and abort
the walk if a route cannot be deleted.

Prevent an infinite recursion reported by Dimitris Papastamos.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.312 2016/07/19 10:26:41 mpi Exp $	*/
d876 1
a876 1
	    prio != RTP_LOCAL) {
@


1.312
log
@Return EAGAIN for every deleted route when detaching an interface.

Previously the code was "too clever" and returned EAGAIN only for
cloning route assuming that other deletion did not modify the tree.

Analysed by and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.311 2016/07/11 13:06:31 bluhm Exp $	*/
d691 3
a693 2
	        rtdeletemsg(rt, ifp, id);
		error = EAGAIN;
d1729 4
d1734 4
a1737 4
	if (rt->rt_ifidx == ifp->if_index) {
		rtdeletemsg(rt, ifp, id);
		return (EAGAIN);
	}
a1738 1
	return (0);
d1792 4
a1795 1
				rtdeletemsg(rt, ifp, id);
@


1.311
log
@Path MTU discovery was slightly broken.  I took two ICMP packets
to create and change the dynamic route.  This behavior was introduced
in net/route.c rev 1.269 when the gateway route allocation was moved
from rt_setgateway() to _rtalloc().  So rtrequest(RTM_ADD) could
return a route without a valid gateway route.  To fix this, call
rt_setgwroute() from _rtalloc() and rt_setgateway().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.310 2016/07/11 09:23:06 mpi Exp $	*/
a1723 6
/*
 * Note that deleting a RTF_CLONING route can trigger the
 * deletion of more entries, so we need to cancel the walk
 * and return EAGAIN.  The caller should restart the walk
 * as long as EAGAIN is returned.
 */
d1730 2
a1731 4
		int	cloning = (rt->rt_flags & RTF_CLONING);

		if (rtdeletemsg(rt, ifp, id) == 0 && cloning)
			return (EAGAIN);
@


1.310
log
@Revert the introduction of ``rt_addr''.

Being able to add route entries without configured addresses is a nice
feature but this is not my fight.  So I'd rather no add another pointer
to ``struct rtentry'' if I'm not removing another one.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.309 2016/06/14 09:48:52 mpi Exp $	*/
d156 1
d372 1
a372 1
	struct rtentry *rt, *nhrt;
d384 10
d405 1
a405 2
	nhrt = rt_match(rt->rt_gateway, NULL, flags | RT_RESOLVE,
	    rtable_l2(rtableid));
d407 1
a407 1
		return (rt);
d415 1
a415 1
		return (rt);
d421 1
a421 1
		return (rt);
a435 2

	return (rt);
d604 1
a604 1
			rt_setgate(rt, gateway);
d1097 2
a1098 1
		if ((error = rt_setgate(rt, info->rti_info[RTAX_GATEWAY]))) {
d1158 1
a1158 1
rt_setgate(struct rtentry *rt, struct sockaddr *gate)
d1172 2
a1173 2
	rtfree(rt->rt_gwroute);
	rt->rt_gwroute = NULL;
@


1.309
log
@Pass the configured ``ifa'' to rt_sendaddrmsg() instead of getting it via
``rt->rt_ifa'' later.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.308 2016/06/14 09:44:41 mpi Exp $	*/
a155 1
int	rt_setaddr(struct rtentry *, struct sockaddr *);
a461 1
		free(rt->rt_addr, M_RTABLE, ROUNDUP(rt->rt_addr->sa_len));
d487 1
a487 1
		info.rti_info[RTAX_IFA] = rt->rt_addr;
d957 1
a957 1
			info->rti_info[RTAX_IFA] = rt->rt_addr;
d1089 1
a1089 2
		if ((error = rt_setaddr(rt, ifa->ifa_addr)) ||
		    (error = rt_setgate(rt, info->rti_info[RTAX_GATEWAY]))) {
a1092 1
			free(rt->rt_addr, M_RTABLE, 0);
a1122 1
			free(rt->rt_addr, M_RTABLE, 0);
a1143 18

	return (0);
}

int
rt_setaddr(struct rtentry *rt, struct sockaddr *addr)
{
	int alen = ROUNDUP(addr->sa_len);
	struct sockaddr *sa;

	KASSERT(rt->rt_addr == NULL);

	sa = malloc(alen, M_RTABLE, M_NOWAIT);
	if (sa == NULL)
		return (ENOBUFS);

	memmove(sa, addr, alen);
	rt->rt_addr = sa;
@


1.308
log
@Store the source address associated with a route in its own chunk of
memory.

This will allow to unlink 'sruct rtentry' and 'struct ifaddr' to be able
to add route entries without needing an address.

ok sthen@@, visa@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.307 2016/06/08 13:26:06 mpi Exp $	*/
d1282 1
a1282 1
			rt_sendaddrmsg(rt, RTM_NEWADDR);
d1338 1
a1338 1
			rt_sendaddrmsg(rt, RTM_DELADDR);
@


1.307
log
@Revert previous, it breaks regression tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.306 2016/06/07 08:30:01 mpi Exp $	*/
d142 2
d156 1
a439 1
	struct ifaddr	*ifa;
d457 1
a457 3
		ifa = rt->rt_ifa;
		if (ifa)
			ifafree(ifa);
d463 2
a464 2
		if (rt->rt_gateway)
			free(rt->rt_gateway, M_RTABLE, 0);
d489 1
a489 1
		info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
a769 2
#define ROUNDUP(a) (a>0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

d959 1
a959 1
			info->rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
d1091 2
a1092 1
		if ((error = rt_setgate(rt, info->rti_info[RTAX_GATEWAY]))) {
d1096 1
d1127 1
d1149 18
@


1.306
log
@Use rtalloc(9) instead of ifa_ifwithnet() to find an interface
when adding a route to gateway to ensure a most specific match.

This makes "# route add"  coherent to "# route get" even with
p2p interfaces.  Fix a problem reported by Mart Tnso.

ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.305 2016/06/03 10:34:07 mpi Exp $	*/
d747 8
a754 5
			struct rtentry *rt;

			rt = rtalloc(gateway, RT_RESOLVE, rtableid);
			if (rt != NULL)
				ifa = rt->rt_ifa;
d756 1
d758 2
a760 2
	if (ifa == NULL)
		return (NULL);
@


1.305
log
@Remove superfluous parenthesis to shut up clang, from David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.304 2016/06/03 02:56:59 dlg Exp $	*/
d747 5
a751 8
			ifa = ifa_ifwithnet(gateway, rtableid);
		}
	}
	if (ifa == NULL) {
		struct rtentry	*rt = rtalloc(gateway, 0, rtableid);
		/* The gateway must be local if the same address family. */
		if (!rtisvalid(rt) || ((rt->rt_flags & RTF_GATEWAY) &&
		    rt_key(rt)->sa_family == dst->sa_family)) {
a752 1
			return (NULL);
a753 2
		ifa = rt->rt_ifa;
		rtfree(rt);
d755 2
@


1.304
log
@set rt_expire times against time_uptime, not time_second.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.303 2016/06/01 06:40:27 dlg Exp $	*/
d561 1
a561 1
	if ((rt == NULL))
@


1.303
log
@s/stall/stale/ in a comment about old interfaces.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.302 2016/05/31 07:42:39 mpi Exp $	*/
d1189 1
a1189 1
		if (rt->rt_expire == 0 || time_second < rt->rt_expire)
d1544 1
a1544 1
	rt->rt_rmx.rmx_expire = time_second + queue->rtq_timeout;
@


1.302
log
@Flush dynamic route entries attached to an interface when its link state
becomes DOWN.

This follows the same reasonning as for L2 (cloned) entries.

Hopefully enough to fix tedu@@'s stale RTF_DYNAMIC routes when switching
WiFi network during suspend/resume.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.301 2016/05/31 07:29:34 mpi Exp $	*/
d213 1
a213 1
	/* Routes attached to stall ifas should be freed. */
@


1.301
log
@Plug a route entry leak triggered under memory pressure.

Help to track the leak from Hrvoje Popovski, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.300 2016/05/02 22:15:49 jmatthew Exp $	*/
d1786 3
a1788 3
			 * Remove cloned routes (mainly arp) to
			 * down interfaces so we have a chance to
			 * clone a new route from a better source.
d1790 1
a1790 1
			if (rt->rt_flags & RTF_CLONED) {
@


1.300
log
@Simplify life for routing table implementations by requiring that rtable_walk
callbacks return EAGAIN if they modify the routing table.  While we're here,
simplify life for rtable_walk callers by moving the loop that restarts the
walk on EAGAIN into rtable_walk itself.

Flushing cloned routes on interface state changes becomes a bit more
inefficient, but this can be improved later.

ok mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.299 2016/04/27 14:47:27 mpi Exp $	*/
d1094 4
d1125 3
a1127 6
			if ((rt->rt_flags & RTF_CLONED) != 0 && rt->rt_parent)
				rtfree(rt->rt_parent);
			if (rt->rt_gwroute)
				rtfree(rt->rt_gwroute);
			if (rt->rt_gateway)
				free(rt->rt_gateway, M_RTABLE, 0);
d1167 2
a1168 4
	if (rt->rt_gwroute != NULL) {
		rtfree(rt->rt_gwroute);
		rt->rt_gwroute = NULL;
	}
@


1.299
log
@Remove unused arguments from rt_checkgate().

Since the rtalloc(9) rewrite no route lookup is done in this function so
there's no need for a destination or a rtable ID.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.298 2016/03/26 21:56:04 mpi Exp $	*/
d672 1
d684 1
a684 1
	if (ISSET(rt->rt_flags, RTF_CLONED) && rtequal(rt->rt_parent, parent))
d686 3
d691 1
a691 1
	return 0;
d1715 1
a1715 3
			while (rtable_walk(tid, i, rt_if_remove_rtdelete,
				ifp) == EAGAIN)
					;	/* nothing */
d1756 1
a1756 3
			while (rtable_walk(tid, i,
			    rt_if_linkstate_change, ifp) == EAGAIN)
				;	/* nothing */
d1793 1
a1793 1
				return (0);
@


1.298
log
@Always include the route priority in routing messages.

From Florian Riehm, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.297 2016/03/26 21:41:18 mpi Exp $	*/
d1171 1
a1171 2
rt_checkgate(struct ifnet *ifp, struct rtentry *rt, struct sockaddr *dst,
    unsigned int rtableid, struct rtentry **rtp)
@


1.297
log
@Do not populate RTAX_NETMASK when sending a routing message for RTF_HOST
entries.

This is a noop with the radix routing table because rt_mask() is always
NULL for RTF_HOST entries, but it preserves the old behavior with ART.

With the ART routing table host entry always have a prefix length equals
to the length of the address.

Fix a regression reported by semarie@@.

ok semarie@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.296 2016/03/07 18:44:00 naddy Exp $	*/
d251 2
a252 2
				rt_missmsg(RTM_MISS, &info, 0, 0, error,
				    tableid);
d492 2
a493 1
	rt_missmsg(cmd, &info, rt->rt_flags, rt->rt_ifidx, 0, rtableid);
d527 1
d584 1
a584 1
			if (error == 0)
d586 2
d596 1
d618 1
a618 1
	rt_missmsg(RTM_REDIRECT, &info, flags, ifidx, error, rdomain);
d647 2
a648 1
	rt_missmsg(RTM_DELETE, &info, info.rti_flags, ifidx, error, tableid);
@


1.296
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.295 2016/02/26 07:54:39 deraadt Exp $	*/
d483 2
a484 1
	info.rti_info[RTAX_NETMASK] = rt_plen2mask(rt, &sa_mask);
@


1.295
log
@L2 entries are always in the first table of a routing domain, this fixes
a regression introduced during 5.7 and 5.8 as reported by Jean-Daniel
Dupas on misc@@
diff provided by mpi, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.294 2016/02/24 22:41:53 mpi Exp $	*/
d1444 1
a1444 1
rt_timer_init()
@


1.294
log
@Fix ECMP routing by passing the correct destination address to the
hash routine.

Bug reported and fix analysed by Jean-Daniel Dupas <jddupas AT xooloo DOT net>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.293 2015/12/21 10:51:55 mpi Exp $	*/
d392 2
a393 1
	nhrt = rt_match(rt->rt_gateway, NULL, flags | RT_RESOLVE, rtableid);
@


1.293
log
@Pass the destination and mask to rtable_mpath_reprio() in order to not
use ``rt_node'' with ART.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.292 2015/12/11 08:58:23 mpi Exp $	*/
d286 1
a286 1
rt_hash(struct rtentry *rt, uint32_t *src)
a287 1
	struct sockaddr *dst = rt_key(rt);
@


1.292
log
@Do not pass a NULL ifp pointer to rtdeletemsg().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.291 2015/12/09 09:23:08 mpi Exp $	*/
d1774 3
a1776 1
			rtable_mpath_reprio(rt, rt->rt_priority & RTP_MASK);
d1791 3
a1793 1
			rtable_mpath_reprio(rt, rt->rt_priority | RTP_DOWN);
@


1.291
log
@Do not trigger a KASSERT() if the route we're trying to remove does not
exist and we get another matching one instead.

This bug has been here since the KAME area and recently exposed by a
refactoring at n2k15.  The problem is that rtrequest(9) does not check
on which interface the route entry is attached when issuing a RTM_DELETE.

So the kernel would end up deleting the route attached on a different ifp
when in_ifinit() fails.

This fix is currently a workaround, a better fix is in the pipeline.

Reported by Laurence Tratt <laurie AT tratt DOT net>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.290 2015/12/09 09:02:02 mpi Exp $	*/
d626 2
d1093 8
a1100 2
			if ((crt->rt_flags & RTF_CLONED) != 0) {
				rtdeletemsg(crt, NULL, tableid);
@


1.290
log
@Do not trigger a KASSERT() when destroying/detaching an interface with
RTF_CLONED routes attached.

In thise case if_get(9) can return NULL inside rtflushclone1() because
ifdetach() starts by clearing the interface pointer in the index map.

So it is perfectly correct to bail and we're not going to leak any route
entry because we're garbage collecting all of them.

Reported by daniel@@ and Aaron Miller <aaron DOT miller04 AT gmail DOT com>
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.289 2015/12/05 10:07:55 tedu Exp $	*/
d833 7
@


1.289
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.288 2015/12/04 13:42:48 mpi Exp $	*/
d648 3
d662 1
d664 14
a677 3
	if ((rt->rt_flags & RTF_CLONED) != 0 && (rt->rt_parent == parent ||
	    rtequal(rt->rt_parent, parent)))
		rtdeletemsg(rt, NULL, id);
@


1.288
log
@Move the KERNEL_LOCK from rt_match() to rtable_match().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.287 2015/12/03 21:57:59 mpi Exp $	*/
a1540 1
/* ARGSUSED */
@


1.287
log
@Get rid of rt_mask() and stop allocating a "struct sockaddr" for every
route entry in ART.

rt_plen() now represents the prefix length of a route entry and should
be used instead.

For now use a "struct sockaddr_in6" to represent the mask when needed,
this should be then replaced by the prefix length and RTA_NETMASK only
used for compatibility with userland.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.286 2015/12/03 14:55:17 vgross Exp $	*/
a242 1
	KERNEL_LOCK();
d247 1
a250 1
				rt0->rt_use++;
d258 1
a262 1
	KERNEL_UNLOCK();
@


1.286
log
@Remove broadcast matching from ifa_ifwithaddr(), use in_broadcast() where
required.

ok bluhm@@ mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.285 2015/12/03 14:26:27 mpi Exp $	*/
d125 1
d130 1
d158 2
d479 1
d484 1
a484 1
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
d535 1
a535 1
	rt = rtalloc(dst, 0, rdomain);
d559 1
a559 1
	if ((rt == NULL) || (rt_mask(rt) && rt_mask(rt)->sa_len < 2))
d625 1
d635 1
a635 1
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
d650 1
a650 1
	    memcmp(rt_mask(a), rt_mask(b), rt_mask(a)->sa_len) == 0)
d1731 1
d1764 1
a1764 1
	if_group_routechange(rt_key(rt), rt_mask(rt));
d1770 45
d1871 1
a1871 1
	db_printf(" mask="); db_print_sa(rt_mask(rt));
@


1.285
log
@Remove unused ``rt_tableid'' field from "struct rtentry".

This reduces the size of the structure by 8 bytes on amd64 now that
we are using an index instead of a pointer for reaching interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.284 2015/12/03 14:19:55 mpi Exp $	*/
d542 3
a544 1
	else if (ifa_ifwithaddr(gateway, rdomain) != NULL)
@


1.284
log
@Store an interface index instead of a pointer in the "struct rtentry".

These indexes are unique and should be used with if_get() to get a
pointer to the corresponding ``ifp''.  Such pointer is guaranteed to
be valid in a MP environment until if_put() is called.

ok claudio@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.283 2015/12/02 16:49:58 bluhm Exp $	*/
a955 1
		rt->rt_tableid = tableid;
@


1.283
log
@rtable_delete() does not use its prio parameter, so delete it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.282 2015/12/02 16:35:52 bluhm Exp $	*/
d1012 1
a1012 1
		rt->rt_ifp = ifp;
d1034 1
a1034 1
				(*ret_nrt)->rt_ifp = ifp;
@


1.282
log
@When destroying an interface, we have to wait until all references
are not used anymore.  This has to be done before any interface
fields become invalid.
As the route delete request cannot call if_get() anymore, pass down
the interface.  Split rtrequest_delete() into a separate function
that may take an existing inteface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.281 2015/12/02 13:29:26 claudio Exp $	*/
d835 1
a835 1
	    info->rti_info[RTAX_NETMASK], prio, rt);
@


1.281
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.280 2015/12/02 10:33:15 blambert Exp $	*/
a155 1

d158 2
d613 1
a613 1
rtdeletemsg(struct rtentry *rt, u_int tableid)
d626 2
a627 1
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
d631 1
a631 1
	error = rtrequest(RTM_DELETE, &info, rt->rt_priority, &rt, tableid);
d655 1
a655 1
		rtdeletemsg(rt, id);
d797 77
d896 3
a898 58
		rt = rtable_lookup(tableid, info->rti_info[RTAX_DST],
 		    info->rti_info[RTAX_NETMASK], info->rti_info[RTAX_GATEWAY],
 		    prio);
		if (rt == NULL)
			return (ESRCH);
#ifndef SMALL_KERNEL
		/*
		 * If we got multipath routes, we require users to specify
		 * a matching gateway.
		 */
		if ((rt->rt_flags & RTF_MPATH) &&
		    info->rti_info[RTAX_GATEWAY] == NULL) {
		    	rtfree(rt);
			return (ESRCH);
		}
#endif

		/*
		 * Since RTP_LOCAL cannot be set by userland, make
		 * sure that local routes are only modified by the
		 * kernel.
		 */
		if ((rt->rt_flags & (RTF_LOCAL|RTF_BROADCAST)) &&
		    prio != RTP_LOCAL) {
		    	rtfree(rt);
			return (EINVAL);
		}

		error = rtable_delete(tableid, info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_NETMASK], prio, rt);
		if (error != 0) {
		    	rtfree(rt);
			return (ESRCH);
		}

		/* clean up any cloned children */
		if ((rt->rt_flags & RTF_CLONING) != 0)
			rtflushclone(tableid, rt);

		rtfree(rt->rt_gwroute);
		rt->rt_gwroute = NULL;

		rtfree(rt->rt_parent);
		rt->rt_parent = NULL;

		rt->rt_flags &= ~RTF_UP;

		ifp = if_get(rt->rt_ifidx);
		KASSERT(ifp != NULL);
		ifp->if_rtrequest(ifp, RTM_DELETE, rt);
		if_put(ifp);

		atomic_inc_int(&rttrash);

		if (ret_nrt != NULL)
			*ret_nrt = rt;
		else
			rtfree(rt);
d1064 1
a1064 1
				rtdeletemsg(crt, tableid);
d1270 1
a1270 1
	error = rtrequest(RTM_DELETE, &info, prio, &rt, rtableid);
d1691 1
a1691 1
		if (rtdeletemsg(rt, id) == 0 && cloning)
d1748 1
a1748 1
				rtdeletemsg(rt, id);
@


1.280
log
@allocate route labels as M_RTABLE instead of M_TEMP

ok claudio@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.279 2015/12/02 09:17:47 mpi Exp $	*/
a225 4
 *
 * "RT_REPORT" indicates that a message should be sent to
 *   userland if no matching route has been found or if an
 *   error occured while adding a L2 entry.
d247 6
a252 1
				goto miss;
a253 3
			/* Inform listeners of the new route */
			rt_sendmsg(rt, RTM_ADD, tableid);
			rtfree(rt0);
d256 1
a256 1
	} else {
a257 4
miss:
		if (ISSET(flags, RT_REPORT))
			rt_missmsg(RTM_MISS, &info, 0, 0, error, tableid);
	}
d346 1
a346 1
	return (_rtalloc(dst, src, RT_REPORT|RT_RESOLVE, rtableid));
@


1.279
log
@Move multipath Hash-Threshold selection mechanism inside rtable_match().

This will helps for unlocking the routing table and will prevent further
mistake by keeping the multipath logic inside the rtable_* API.

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.278 2015/12/01 21:26:43 mpi Exp $	*/
d1578 1
a1578 1
	label = malloc(sizeof(*label), M_TEMP, M_NOWAIT|M_ZERO);
d1634 1
a1634 1
				free(p, M_TEMP, sizeof(*p));
@


1.278
log
@Kill redundant or unused arguments in rtredirect().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.277 2015/11/27 11:52:44 mpi Exp $	*/
a155 1
uint32_t	rt_hash(struct rtentry *, uint32_t *);
d243 1
a243 24
	rt = rtable_match(tableid, dst);

#ifndef SMALL_KERNEL
	/* Handle multipath routing if enabled for the specified protocol. */
	if (rt != NULL && ISSET(rt->rt_flags, RTF_MPATH) && src != NULL) {
		switch (dst->sa_family) {
		case AF_INET:
			if (!ipmultipath)
				break;
			rt = rtable_mpath_select(rt, rt_hash(rt, src) & 0xffff);
			break;
#ifdef INET6
		case AF_INET6:
			if (!ip6_multipath)
				break;
			rt = rtable_mpath_select(rt, rt_hash(rt, src) & 0xffff);
			break;
#endif
		default:
			break;
		};
	}
#endif /* SMALL_KERNEL */

d287 1
a287 1
uint32_t
d293 3
d304 3
d318 3
d343 1
a343 1
	return (c);
@


1.277
log
@Protect the growth of the routing table arrays used by rtable_get()
with SRPs.

This is a simplified version of the dynamically sizeable array of
pointers used by if_get() because routing table heads are never
freed.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.276 2015/11/23 10:52:43 mpi Exp $	*/
d532 1
a532 2
    struct sockaddr *netmask, int flags, struct sockaddr *src,
    struct rtentry **rtp, u_int rdomain)
d540 1
d560 1
a560 2
	if (!(flags & RTF_DONE) && rt &&
	     (!equal(src, rt->rt_gateway) || rt->rt_ifa != ifa))
d576 1
a576 1
	 * for a route to an interface. 
d578 2
a579 2
	if (rt->rt_flags & RTF_GATEWAY) {
		if (((rt->rt_flags & RTF_HOST) == 0) && (flags & RTF_HOST)) {
d586 1
a586 1
			flags |= RTF_GATEWAY | RTF_DYNAMIC;
a589 1
			info.rti_info[RTAX_NETMASK] = netmask;
a624 1
	info.rti_info[RTAX_NETMASK] = netmask;
@


1.276
log
@Include <sys/atomic.h> when atomic operations are used.

This has been masked because <sys/srp.h> is pulled unconditionally.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.275 2015/11/20 13:12:14 jsg Exp $	*/
d143 1
a143 1
extern unsigned int	rtables_id_max;
d1665 1
a1665 1
	for (tid = 0; tid <= rtables_id_max; tid++) {
d1705 1
a1705 1
	for (tid = 0; tid <= rtables_id_max; tid++) {
@


1.275
log
@Initialise the ifidx to 0 (no interface) in rtredirect() to avoid using
ifidx uninitialised for the gateway not directly reachable case.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.274 2015/11/18 14:13:52 mpi Exp $	*/
d116 1
@


1.274
log
@Do not dereference rt_ifp to call if_rtrequest.

This only happens under KERNEL_LOCK() so we know for sure that the
interface attached to a route entry is valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.273 2015/11/18 13:05:58 mpi Exp $	*/
d539 1
a539 1
	unsigned int		 ifidx;
@


1.273
log
@Revert previous workaround now that multipath route selection has been
fixed.

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.272 2015/11/18 12:45:59 mpi Exp $	*/
d821 1
d886 6
a891 1
		rt->rt_ifp->if_rtrequest(rt->rt_ifp, RTM_DELETE, rt);
d932 1
d934 1
a934 1
			prio = ifa->ifa_ifp->if_priority + RTP_STATIC;
d963 2
a964 2
		    (!LINK_STATE_IS_UP(ifa->ifa_ifp->if_link_state) ||
		    !ISSET(ifa->ifa_ifp->if_flags, IFF_UP))) {
d1011 1
a1011 1
		rt->rt_ifp = ifa->ifa_ifp;
d1020 8
a1027 4
				printf("rtrequest RTM_RESOLVE: wrong ifa (%p) "
				    "was (%p)\n", ifa, (*ret_nrt)->rt_ifa);
				(*ret_nrt)->rt_ifp->if_rtrequest(rt->rt_ifp,
				    RTM_DELETE, *ret_nrt);
d1029 3
d1033 2
a1034 4
				(*ret_nrt)->rt_ifp = ifa->ifa_ifp;
				ifa->ifa_refcnt++;
				(*ret_nrt)->rt_ifp->if_rtrequest(rt->rt_ifp,
				    RTM_ADD, *ret_nrt);
d1083 1
a1083 1
		rt->rt_ifp->if_rtrequest(rt->rt_ifp, req, rt);
@


1.272
log
@Multipath selection should be done before caching the next hop.

Fix a regression introduced by rtalloc(9) rewrite where only the
first route of a multipath chain had a valid next hop and could
be used.

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.271 2015/11/17 10:28:24 mpi Exp $	*/
d422 2
a423 8
	/* Next hop entry must be UP... */
	if (!ISSET(nhrt->rt_flags, RTF_UP)) {
		rtfree(nhrt);
		return (rt);
	}

	/* ...and on the same interface unless we have multiple gateways. */
	if (nhrt->rt_ifidx != rt->rt_ifidx && !ISSET(rt->rt_flags, RTF_MPATH)) {
@


1.271
log
@Unbreak next-hop caching on multipath setups.

When multiple gateways are in use, the next-hop entrie might not be
on the same interface.  This is due to the fact that ARP entries are
unique and attached to their cloning interface.

Found the hard way by and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.270 2015/11/11 11:25:16 mpi Exp $	*/
d154 2
a155 1
struct rtentry *rt_match(struct sockaddr *, int, unsigned int);
d232 1
a232 1
rt_match(struct sockaddr *dst, int flags, unsigned int tableid)
d244 23
d292 2
a294 1

d310 1
a310 1
static uint32_t
d366 3
a368 1
	struct rtentry *rt;
d370 4
a373 16
	rt = rtalloc(dst, RT_REPORT|RT_RESOLVE, rtableid);

	/* if the route does not exist or it is not multipath, don't care */
	if (rt == NULL || !ISSET(rt->rt_flags, RTF_MPATH))
		return (rt);

	/* check if multipath routing is enabled for the specified protocol */
	if (!(0
	    || (ipmultipath && dst->sa_family == AF_INET)
#ifdef INET6
	    || (ip6_multipath && dst->sa_family == AF_INET6)
#endif
	    ))
		return (rt);

	return (rtable_mpath_select(rt, rt_hash(rt, src) & 0xffff));
a374 1
#endif /* SMALL_KERNEL */
d384 1
a384 1
rtalloc(struct sockaddr *dst, int flags, unsigned int rtableid)
d388 1
a388 1
	rt = rt_match(dst, flags, rtableid);
d409 1
a409 1
	nhrt = rt_match(rt->rt_gateway, flags | RT_RESOLVE, rtableid);
@


1.270
log
@Remove an XXX that no longer makes sense, rt_ifp is now always the same
as rt_ifa->ifa_ifp.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.269 2015/11/09 10:26:26 mpi Exp $	*/
d408 8
a415 4
	/*
	 * Next hop entry must be UP and on the same interface.
	 */
	if (!ISSET(nhrt->rt_flags, RTF_UP) || nhrt->rt_ifidx != rt->rt_ifidx) {
@


1.269
log
@Rewrite rtalloc(9) to consider RTF_GATEWAY entries without valid next-
hop route as invalid.

Previously when such entrie was returned by rtalloc(9) a second route
lookup was done in rt_checkgate() very late in the journey of a packet.

In other words a single rtalloc(9) call can now result in multiple
route lookups if a RTF_GATEWAY entry is returned.

This is a step towards always calling L2 output functions with valid
destination information.

Tested by various including jmc@@, naddy@@, Hrvoje Popovski
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.268 2015/11/04 10:13:55 mpi Exp $	*/
a1668 5

	/*
	 * XXX There should be no need to check for rt_ifa belonging to this
	 * interface, because then rt_ifp is set, right?
	 */
@


1.268
log
@rtfree(9) accepts NULL pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.267 2015/11/02 14:40:09 mpi Exp $	*/
d154 1
d198 6
d211 3
d217 13
d231 1
a231 1
rtalloc(struct sockaddr *dst, int flags, unsigned int tableid)
d362 70
d595 1
a595 1
			rt_setgate(rt, gateway, rdomain);
d1027 1
a1027 2
		if ((error = rt_setgate(rt, info->rti_info[RTAX_GATEWAY],
		    tableid))) {
d1080 1
a1080 1
rt_setgate(struct rtentry *rt, struct sockaddr *gate, unsigned int tableid)
d1098 1
a1098 16
	if (rt->rt_flags & RTF_GATEWAY) {
		/* XXX is this actually valid to cross tables here? */
		rt->rt_gwroute = rtalloc(gate, RT_REPORT|RT_RESOLVE, tableid);
		/*
		 * If we switched gateways, grab the MTU from the new
		 * gateway route if the current MTU is 0 or greater
		 * than the MTU of gateway.
		 * Note that, if the MTU of gateway is 0, we will reset the
		 * MTU of the route to run PMTUD again from scratch. XXX
		 */
		if (rt->rt_gwroute && !(rt->rt_rmx.rmx_locks & RTV_MTU) &&
		    rt->rt_rmx.rmx_mtu &&
		    rt->rt_rmx.rmx_mtu > rt->rt_gwroute->rt_rmx.rmx_mtu) {
			rt->rt_rmx.rmx_mtu = rt->rt_gwroute->rt_rmx.rmx_mtu;
		}
	}
d1113 1
a1113 18
		if (rt->rt_gwroute && !(rt->rt_gwroute->rt_flags & RTF_UP)) {
			rtfree(rt->rt_gwroute);
			rt->rt_gwroute = NULL;
		}
		if (rt->rt_gwroute == NULL) {
			rt->rt_gwroute = rtalloc(rt->rt_gateway,
			    RT_REPORT|RT_RESOLVE, rtableid);
			if (rt->rt_gwroute == NULL)
				return (EHOSTUNREACH);
		}
		/*
		 * Next hop must be reachable, this also prevents rtentry
		 * loops, for example when rt->rt_gwroute points to rt.
		 */
		if (((rt->rt_gwroute->rt_flags & (RTF_UP|RTF_GATEWAY)) !=
		    RTF_UP) || (rt->rt_gwroute->rt_ifidx != ifp->if_index)) {
			rtfree(rt->rt_gwroute);
			rt->rt_gwroute = NULL;
a1114 1
		}
@


1.267
log
@Merge rtable_mpath_match() into rtable_lookup().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.266 2015/10/30 09:39:42 bluhm Exp $	*/
d480 1
a480 2
			if (rt)
				rtfree(rt);
d1238 1
a1238 2
	if (rt)
		rtfree(rt);
d1287 1
a1287 2
	if (rt)
		rtfree(rt);
@


1.266
log
@Rename rtrequest1() to rtrequest().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.265 2015/10/25 16:25:23 mpi Exp $	*/
d736 2
a737 1
		    info->rti_info[RTAX_NETMASK]);
a740 5
		rt = rtable_mpath_match(tableid, rt,
		    info->rti_info[RTAX_GATEWAY], prio);
		if (rt == NULL)
			return (ESRCH);

@


1.265
log
@I should not have committed this chunk.  Spotted by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.264 2015/10/25 15:24:03 mpi Exp $	*/
d223 1
a223 1
			error = rtrequest1(RTM_RESOLVE, &info, RTP_DEFAULT,
d490 1
a490 1
			error = rtrequest1(RTM_ADD, &info, RTP_DEFAULT, &rt,
d548 1
a548 1
	error = rtrequest1(RTM_DELETE, &info, rt->rt_priority, &rt, tableid);
d714 1
a714 1
rtrequest1(int req, struct rt_addrinfo *info, u_int8_t prio,
d913 1
a913 1
				printf("rtrequest1 RTM_RESOLVE: wrong ifa (%p) "
d1131 1
a1131 1
	error = rtrequest1(RTM_ADD, &info, prio, &rt, rtableid);
d1191 1
a1191 1
	error = rtrequest1(RTM_DELETE, &info, prio, &rt, rtableid);
d1318 1
a1318 1
		rtrequest1(RTM_DELETE, &info,			\
@


1.264
log
@Simple sizes for free(9).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.263 2015/10/25 14:48:51 mpi Exp $	*/
d736 1
a736 2
		    info->rti_info[RTAX_NETMASK], info->rti_info[RTAX_GATEWAY],
		    prio );
d739 16
@


1.263
log
@Merge rtable_mpath_conflict() into rtable_insert().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.262 2015/10/25 11:58:11 mpi Exp $	*/
d372 1
a372 1
			free(rt->rt_llinfo, M_TEMP, 0);
d376 1
a376 1
		free(rt_key(rt), M_RTABLE, 0);
d736 2
a737 6
		    info->rti_info[RTAX_NETMASK]);
		if (rt == NULL)
			return (ESRCH);
#ifndef SMALL_KERNEL
		rt = rtable_mpath_match(tableid, rt,
		    info->rti_info[RTAX_GATEWAY], prio);
a741 11
		 * If we got multipath routes, we require users to specify
		 * a matching gateway.
		 */
		if ((rt->rt_flags & RTF_MPATH) &&
		    info->rti_info[RTAX_GATEWAY] == NULL) {
		    	rtfree(rt);
			return (ESRCH);
		}
#endif

		/*
d1374 1
a1374 1
	free(rtq, M_RTABLE, 0);
d1560 1
a1560 1
				free(p, M_TEMP, 0);
@


1.262
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.261 2015/10/25 10:05:09 bluhm Exp $	*/
a839 9
#ifndef SMALL_KERNEL
		/* Do not permit exactly the same dst/mask/gw pair. */
		if (rtable_mpath_conflict(tableid, ndst,
		    info->rti_info[RTAX_NETMASK], info->rti_info[RTAX_GATEWAY],
		    prio, info->rti_flags & RTF_MPATH)) {
			free(ndst, M_RTABLE, dlen);
			return (EEXIST);
		}
#endif
d947 2
a948 1
		    info->rti_info[RTAX_NETMASK], rt->rt_priority, rt);
d955 1
@


1.261
log
@Instead of doing the the if_get() dance for rt_missmsg(), change the
function to take an interface index.
discussed with mpi@@;  OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.260 2015/10/24 11:58:46 mpi Exp $	*/
d785 1
a785 2
		if ((ifa = rt->rt_ifa) && ifa->ifa_rtrequest)
			ifa->ifa_rtrequest(RTM_DELETE, rt);
d924 2
a925 3
				if ((*ret_nrt)->rt_ifa->ifa_rtrequest)
					(*ret_nrt)->rt_ifa->ifa_rtrequest(
					    RTM_DELETE, *ret_nrt);
d930 2
a931 2
				if (ifa->ifa_rtrequest)
					ifa->ifa_rtrequest(RTM_ADD, *ret_nrt);
d979 1
a979 3

		if (ifa->ifa_rtrequest)
			ifa->ifa_rtrequest(req, rt);
@


1.260
log
@Some rt_ifp to rt_ifidx conversions.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.259 2015/10/23 14:48:22 mpi Exp $	*/
d238 1
a238 1
			rt_missmsg(RTM_MISS, &info, 0, NULL, error, tableid);
d401 1
a401 1
	rt_missmsg(cmd, &info, rt->rt_flags, ifp, 0, rtableid);
d434 1
a434 1
	struct ifnet		*ifp = NULL;
d443 1
a443 1
	ifp = ifa->ifa_ifp;
d524 1
a524 1
	rt_missmsg(RTM_REDIRECT, &info, flags, ifp, error, rdomain);
d535 1
a535 1
	struct ifnet		*ifp;
d547 1
a547 1
	ifp = if_get(rt->rt_ifidx);
d549 1
a549 1
	rt_missmsg(RTM_DELETE, &info, info.rti_flags, ifp, error, tableid);
a551 1
	if_put(ifp);
@


1.259
log
@Update route entries reference counters atomically.

This allows us to only grab the KERNEL_LOCK when the last reference
of an entry has been dropped.

For symmetry also grab the KERNEL_LOCK inside rtalloc(9).

ok dlg@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.258 2015/10/22 17:19:38 mpi Exp $	*/
d386 3
a388 2
	struct rt_addrinfo info;
	struct sockaddr_rtlabel sa_rl;
d395 3
a397 2
	if (rt->rt_ifp != NULL) {
		info.rti_info[RTAX_IFP] = sdltosa(rt->rt_ifp->if_sadl);
d401 2
a402 1
	rt_missmsg(cmd, &info, rt->rt_flags, rt->rt_ifp, 0, rtableid);
d547 1
a547 1
	ifp = rt->rt_ifp;
d552 1
d1068 1
a1068 1
		    RTF_UP) || (rt->rt_gwroute->rt_ifp != ifp)) {
d1623 1
a1623 1
	if (rt->rt_ifp == ifp) {
d1665 1
a1665 1
	if (rt->rt_ifp != ifp)
d1760 1
a1760 7

	db_printf(" ifp=%p ", rt->rt_ifp);
	if (rt->rt_ifp)
		db_printf("(%s)", rt->rt_ifp->if_xname);
	else
		db_printf("(NULL)");

@


1.258
log
@Use only one refcounting mechanism for route entries.

ok bluhm@@, dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.257 2015/10/22 16:49:26 mpi Exp $	*/
d218 1
d240 1
d342 1
a342 1
	rt->rt_refcnt++;
d349 1
d354 2
a355 1
	if (--rt->rt_refcnt <= 0) {
d358 2
a359 2
		rttrash--;
		if (rt->rt_refcnt < 0) {
d363 2
d377 2
d784 1
a784 1
		rttrash++;
@


1.257
log
@Only check for rt_ifp now that it is alays the same as rt_ifa->ifa_ifp.

ok millert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.256 2015/10/22 16:32:41 mpi Exp $	*/
d351 3
a353 7
	rt->rt_refcnt--;

	if (rt->rt_refcnt <= 0 && (rt->rt_flags & RTF_UP) == 0) {
		if (rt->rt_refcnt == 0 && RT_ACTIVE(rt))
			return; /* route still active but currently down */
		if (RT_ACTIVE(rt) || RT_ROOT(rt))
			panic("rtfree 2");
d845 1
d931 1
a931 1
			rt->rt_parent->rt_refcnt++;
@


1.256
log
@Kill dead code, ifa is specified and won't change.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.255 2015/10/22 15:37:47 bluhm Exp $	*/
d1656 1
a1656 2
	if ((rt->rt_ifp != ifp) &&
	    (rt->rt_ifa == NULL || rt->rt_ifa->ifa_ifp != ifp))
@


1.255
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.254 2015/10/21 08:21:06 mpi Exp $	*/
a1135 13
		if (rt->rt_ifa != ifa) {
			printf("%s: wrong ifa (%p) was (%p)\n", __func__,
			    ifa, rt->rt_ifa);
			if (rt->rt_ifa->ifa_rtrequest)
				rt->rt_ifa->ifa_rtrequest(RTM_DELETE, rt);
			ifafree(rt->rt_ifa);
			rt->rt_ifa = ifa;
			rt->rt_ifp = ifa->ifa_ifp;
			ifa->ifa_refcnt++;
			if (ifa->ifa_rtrequest)
				ifa->ifa_rtrequest(RTM_ADD, rt);
		}

@


1.254
log
@u_short -> unsigned int for rtableid.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.253 2015/10/16 12:36:02 mpi Exp $	*/
d391 1
a391 1
		info.rti_info[RTAX_IFP] =(struct sockaddr *)rt->rt_ifp->if_sadl;
d615 1
a615 1
			struct sockaddr_dl *sdl = (struct sockaddr_dl *)gateway;
d659 1
a659 1
		sdl = (struct sockaddr_dl *)info->rti_info[RTAX_IFP];
d811 1
a811 1
		info->rti_info[RTAX_GATEWAY] = (struct sockaddr *)&sa_dl;
d1111 1
a1111 1
		info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)ifp->if_sadl;
@


1.253
log
@If a DOWN route entry is passed to a L2 output function, be dumb and
simply use it.

In most of the cases doing a route lookup at this point is a noop as
it will return you the same DOWN entry you already have.

The exception is the case where the route has been removed from tree
since your kernel looked for it.  So what?  It's just a blue packet.

Note that this "exception" can only happen if your sending path does
not run under the KERNEL_LOCK.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.252 2015/10/14 10:18:03 mpi Exp $	*/
d1102 2
a1103 2
	u_short			 rtableid = ifp->if_rdomain;
	u_int8_t		 prio = ifp->if_priority + RTP_STATIC;
d1171 2
a1172 2
	u_short			 rtableid = ifp->if_rdomain;
	u_int8_t		 prio = ifp->if_priority + RTP_STATIC;
@


1.252
log
@Reset the RTF_CONNECTED flag when cloning an entry.

While here check for RTF_CLONED insted of RTM_RESOLVE when adding an
entry.

Found while debugging naddy@@'s NFS vs em(4) vs rtisvalid(9) issue.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.251 2015/10/14 10:09:30 mpi Exp $	*/
a1039 9

	if ((rt->rt_flags & RTF_UP) == 0) {
		rt = rtalloc(dst, RT_REPORT|RT_RESOLVE, rtableid);
		if (rt == NULL)
			return (EHOSTUNREACH);
		rt->rt_refcnt--;
		if (rt->rt_ifp != ifp)
			return (EHOSTUNREACH);
	}
@


1.251
log
@Rewrite the logic around the dymanic array of routing tables to help
turning rtable_get(9) MP-safe.

Use only one per-AF array, as suggested by claudio@@, pointing to an
array of pointers to the routing table heads.

Routing tables are now allocated/initialized per-AF.  This will let
us allocate routing table on-demand instead of always having an
AF_INET, AF_MPLS and AF_INET table as soon as a new rtableID is used.

This also get rid of the "void ***" madness.

ok dlg@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.250 2015/10/13 09:59:37 mpi Exp $	*/
d809 2
a810 2
		info->rti_flags = rt->rt_flags & ~(RTF_CLONING | RTF_STATIC);
		info->rti_flags |= RTF_CLONED;
a811 1
		info->rti_flags |= RTF_HOST;
d907 1
a907 1
		if (req == RTM_RESOLVE) {
@


1.250
log
@Make sure RTF_LOCAL route entries are UP when added to the tree.

This is required to maintain the original BSD behavior of locally
configured addresses being always reacheable.

Some interfaces are^w^W^Wem(4) is special and generally has a DOWN
link state when configured by netstart(8).  As a result all the
route entries cloned/added before its link state goes to UP are also
marked as DOWN.

Note that this problem was not present when local addresses were
attached to lo0.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.249 2015/10/07 10:50:35 mpi Exp $	*/
a141 1
extern void	     ***rtables;
a1657 3

	if (rtables == NULL)
		return;
@


1.249
log
@Initialize the routing table before domains.

The routing table is not an optional component of the network stack
and initializing it inside the "routing domain" requires some ugly
introspection in the domain interface.

This put the rtable* layer at the same level of the if* level.  These
two subsystem are organized around the two global data structure used
in the network stack:

- the global &ifnet list, to be used in process context only, and
- the routing table which can be read in interrupt context.

This change makes the rtable_* layer domain-aware and extends the
"struct domain" such that INET, INET6 and MPLS can specify the length
of the binary key used in lookups.  This allows us to keep, or move
towards, AF-free route and rtable layers.

While here stop the madness and pass the size of the maximum key length
in *byte* to rn_inithead0().

ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.248 2015/10/07 08:58:01 mpi Exp $	*/
d859 1
@


1.248
log
@Move route entry debug helpers where they belong.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.247 2015/10/07 08:43:36 mpi Exp $	*/
d140 1
a140 1
static uint32_t		   rt_hashjitter;
d142 2
a143 6
struct	rtstat		   rtstat;
void			***rt_tables;
u_int8_t		   af2rtafidx[AF_MAX+1];
u_int8_t		   rtafidx_max;
u_int			   rtbl_id_max = 0;
u_int			  *rt_tab2dom;	/* rt table to domain lookup table */
d145 1
a151 1
int	rtable_alloc(void ***, u_int);
a175 26
int
rtable_alloc(void ***table, u_int id)
{
	void		**p;
	struct domain	 *dom;
	int		  i;

	if ((p = mallocarray(rtafidx_max + 1, sizeof(void *), M_RTABLE,
	    M_NOWAIT|M_ZERO)) == NULL)
		return (ENOMEM);

	/* 2nd pass: attach */
	for (i = 0; (dom = domains[i]) != NULL; i++) {
		if (dom->dom_rtattach)
			dom->dom_rtattach(&p[af2rtafidx[dom->dom_family]],
			    dom->dom_rtoffset);
	}

	for (i = 0; i < rtafidx_max; i++)
		rtable_setid(p, id, i);

	*table = (void **)p;

	return (0);
}

a178 4
	struct domain	*dom;
	unsigned int	 keylen;
	int		 i;

a181 23
	/*
	 * Compute the maximum supported key length in case the routing
	 * table backend needs it.
	 */
	keylen = sizeof(struct sockaddr_in);
#ifdef INET6
	keylen = max(keylen, (sizeof(struct sockaddr_in6)));
#endif
#ifdef MPLS
	keylen = max(keylen, (sizeof(struct sockaddr_mpls)));
#endif

	rtable_init(keylen);

	bzero(af2rtafidx, sizeof(af2rtafidx));
	rtafidx_max = 1;	/* must have NULL at index 0, so start at 1 */

	/* find out how many tables to allocate */
	for (i = 0; (dom = domains[i]) != NULL; i++) {
		if (dom->dom_rtattach)
			af2rtafidx[dom->dom_family] = rtafidx_max++;
	}

a188 83
int
rtable_add(u_int id)
{
	void	*p, *q;

	splsoftassert(IPL_SOFTNET);

	if (id > RT_TABLEID_MAX)
		return (EINVAL);

	if (id == 0 || id > rtbl_id_max) {
		size_t	newlen;
		size_t	newlen2;

		if ((p = mallocarray(id + 1, sizeof(void *), M_RTABLE,
		    M_NOWAIT|M_ZERO)) == NULL)
			return (ENOMEM);
		newlen = sizeof(void *) * (id+1);
		if ((q = mallocarray(id + 1, sizeof(u_int), M_RTABLE,
		    M_NOWAIT|M_ZERO)) == NULL) {
			free(p, M_RTABLE, newlen);
			return (ENOMEM);
		}
		newlen2 = sizeof(u_int) * (id+1);
		if (rt_tables) {
			bcopy(rt_tables, p, sizeof(void *) * (rtbl_id_max+1));
			bcopy(rt_tab2dom, q, sizeof(u_int) * (rtbl_id_max+1));
			free(rt_tables, M_RTABLE, 0);
			free(rt_tab2dom, M_RTABLE, 0);
		}
		rt_tables = p;
		rt_tab2dom = q;
		rtbl_id_max = id;
	}

	if (rt_tables[id] != NULL)	/* already exists */
		return (EEXIST);

	rt_tab2dom[id] = 0;	/* use main table/domain by default */
	return (rtable_alloc(&rt_tables[id], id));
}

void *
rtable_get(u_int id, sa_family_t af)
{
	if (id > rtbl_id_max)
		return (NULL);
	return (rt_tables[id] ? rt_tables[id][af2rtafidx[af]] : NULL);
}

u_int
rtable_l2(u_int id)
{
	if (id > rtbl_id_max)
		return (0);
	return (rt_tab2dom[id]);
}

void
rtable_l2set(u_int id, u_int parent)
{
	splsoftassert(IPL_SOFTNET);

	if (!rtable_exists(id) || !rtable_exists(parent))
		return;
	rt_tab2dom[id] = parent;
}

int
rtable_exists(u_int id)	/* verify table with that ID exists */
{
	if (id > RT_TABLEID_MAX)
		return (0);

	if (id > rtbl_id_max)
		return (0);

	if (rt_tables[id] == NULL)
		return (0);

	return (1);
}

d1614 1
a1614 1
	for (tid = 0; tid <= rtbl_id_max; tid++) {
d1659 1
a1659 1
	if (rt_tables == NULL)
d1662 1
a1662 1
	for (tid = 0; tid <= rtbl_id_max; tid++) {
@


1.247
log
@Move the reference counting of a newly created route entry inside
rtable_insert().

inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.246 2015/10/01 22:21:48 mpi Exp $	*/
d163 6
d1859 85
@


1.246
log
@Revert previous, it also breaks naddy@@'s nested NFS setup.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.245 2015/09/30 10:47:39 mpi Exp $	*/
d1093 1
a1093 1
				}
d1111 1
a1111 4
		if (ret_nrt) {
			*ret_nrt = rt;
			rt->rt_refcnt++;
		}
d1119 5
@


1.245
log
@Do not try to refetch a route at the L2 layer if the given one is DOWN
and always return EHOSTUNREACH.

Please let me know if you find any new "No route to host" error.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.244 2015/09/28 08:36:24 mpi Exp $	*/
d1174 8
a1181 2
	if ((rt->rt_flags & RTF_UP) == 0)
		return (EHOSTUNREACH);
@


1.244
log
@Factors ou the route hashing code to implement Equal-Cost Multi-Path
for ART.

While here sync the two remaining mix() macros.

ok chris@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.243 2015/09/25 09:51:20 mpi Exp $	*/
d1174 2
a1175 8
	if ((rt->rt_flags & RTF_UP) == 0) {
		rt = rtalloc(dst, RT_REPORT|RT_RESOLVE, rtableid);
		if (rt == NULL)
			return (EHOSTUNREACH);
		rt->rt_refcnt--;
		if (rt->rt_ifp != ifp)
			return (EHOSTUNREACH);
	}
@


1.243
log
@Ensure that RTF_LOCAL route entries always stay UP.

Local route entries, being now attached to their corresponding interface,
are susceptible to be brought DOWN when a link state change occurs.  When
this happens locally configured addresses are no longer reachable.

So keep the previous (original) behavior by forcing such route entries to
always be UP.

ok sthen@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.242 2015/09/23 08:49:46 mpi Exp $	*/
d139 3
d233 3
d379 66
d468 1
a468 1
	return (rtable_mpath_select(rt, src));
@


1.242
log
@Always increment rt_use inside rtalloc(9) instead of doing it in some
specific places.

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.241 2015/09/22 10:05:00 mpi Exp $	*/
d1745 6
@


1.241
log
@When a connected route is deleted, pass the corresponding priority to
rtrequest1(9) otherwise the route will remain attached to a stale ifa.

Found by matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.240 2015/09/21 11:15:27 mpi Exp $	*/
d353 2
a354 1
			if (error)
d356 1
d361 1
@


1.240
log
@Set the correct priority for connected routes.

Found by benno@@.

ok phessler@@, claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.239 2015/09/12 20:50:17 mpi Exp $	*/
d1270 3
@


1.239
log
@Now that rtrequest1(9) properly sets RTF_UP for newly added route,
stop passing it in every rt_ifa_add(9) calls.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.238 2015/09/12 09:22:29 mpi Exp $	*/
d1197 3
@


1.238
log
@Use rtref(9) in rtable_match() before returning a route entry.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.237 2015/09/11 20:03:40 mpi Exp $	*/
d1319 1
a1319 1
		error = rt_ifa_add(ifa, RTF_UP | flags, ifa->ifa_addr);
@


1.237
log
@Stop supporting RTF_XRESOLVE, no daemon is doing resolution these
days.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.236 2015/09/11 16:58:00 mpi Exp $	*/
d339 1
a339 2
	struct rtentry		*rt;
	struct rtentry		*newrt = NULL;
a342 2
	s = splsoftnet();

d346 1
a348 1
		newrt = rt;
d350 1
d352 2
a353 4
			    &newrt, tableid);
			if (error) {
				newrt = rt;
				rt->rt_refcnt++;
a354 2
			}
			rt = newrt;
d357 2
a358 2
		} else
			rt->rt_refcnt++;
d366 1
a366 1
	return (newrt);
@


1.236
log
@Introduce rtref(9) use it in rtable_lookup() before returning a route
entry.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.235 2015/09/11 15:38:13 mpi Exp $	*/
d342 1
a342 1
	int			 s, error = 0, msgtype = RTM_MISS;
a360 4
			if (rt->rt_flags & RTF_XRESOLVE) {
				msgtype = RTM_RESOLVE;
				goto miss;
			}
d368 2
a369 5
		if (ISSET(flags, RT_REPORT)) {
			bzero((caddr_t)&info, sizeof(info));
			info.rti_info[RTAX_DST] = dst;
			rt_missmsg(msgtype, &info, 0, NULL, error, tableid);
		}
@


1.235
log
@Apply the link state change hook to RTF_LOCAL routes.

Checking for rt_ifp is currently not enough because RTF_LOCAL routes
still use a hack introduced in 1991 and have lo0ifp as rt_ifp pointer.

So also check for rt_ifa->ifa_ifp in this case.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.234 2015/09/11 14:30:30 mpi Exp $	*/
d411 6
d816 2
a817 1
		    info->rti_info[RTAX_GATEWAY] == NULL)
d819 1
d828 2
a829 1
		    prio != RTP_LOCAL)
d831 1
d835 2
a836 1
		if (error != 0)
d838 1
a838 6

		/*
		 * We need to hold a reference to ensure rtflushclone()
		 * wont free us through rt->rt_parent.
		 */
		rt->rt_refcnt++;
@


1.234
log
@Increment the reference count of CLONING routes before flushing all
their children to make sure they are still alive after rtfree(9)ing
rt->rt_parent.

Fix a use-after-fruit reported by stsp@@

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.233 2015/09/10 17:35:46 dlg Exp $	*/
d1740 3
a1742 2
	if (rt->rt_ifp != ifp)
		return (0);
@


1.233
log
@if_put after if_get

easy now that mpi@@ has removed the ifunit confusion.
ok mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.232 2015/09/10 14:46:28 mpi Exp $	*/
d828 6
a848 1
		rt->rt_refcnt++;
@


1.232
log
@Stop supporting RTAX_IFP arguments with an interface name in the
sdl_data field, a la link_addr(3).

route(8)-like applications wanting to specify an ifp must set sdl_index
to the corresponding interface index.

Not mixing if_get() and ifunit() makes our life easier.  The idea is to
have a minimum number of functions dealing w/ ifp refcount.  Hopefully
if_get() will be the only one.

ok mikeb@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.231 2015/09/10 09:37:52 mpi Exp $	*/
d687 1
d764 2
@


1.231
log
@Use rtfree(9) rather than decrementing the reference counter.

We know the parent wont be freed at this point because cloned
routes are always purged from the tree before parents.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.230 2015/09/04 08:43:39 mpi Exp $	*/
a684 2
			if (ifp == NULL)
				ifp = ifunit(sdl->sdl_data);
a726 2
		if (ifp == NULL)
			ifp = ifunit(sdl->sdl_data);
@


1.230
log
@Make every subsystem using a radix tree call rn_init() and pass the
length of the key as argument.

This way every consumer of the radix tree has a chance to explicitly
initialize the shared data structures and no longer rely on another
subsystem to do the initialization.

As a bonus ``dom_maxrtkey'' is no longer used an die.

ART kernels should now be fully usable because pf(4) and IPSEC properly
initialized the radix tree.

ok chris@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.229 2015/09/03 09:50:26 mpi Exp $	*/
d833 2
a834 4
		if (rt->rt_gwroute) {
			rtfree(rt->rt_gwroute);
			rt->rt_gwroute = NULL;
		}
d836 2
a837 4
		if (rt->rt_parent) {
			rt->rt_parent->rt_refcnt--;
			rt->rt_parent = NULL;
		}
@


1.229
log
@Unconditionally set the RTF_UP flags when adding a route to the table.

This makes dhclient(8) configured default routes usable without relying
on the link-state change hooks not present in RAMDISK kernels.

ok krw@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.228 2015/09/01 12:50:03 mpi Exp $	*/
d201 1
d206 14
a219 1
	rtable_init();	/* initialize all zeroes, all ones, mask table */
@


1.228
log
@Introduce rtisvalid(9) a function to check if a (cached) route entry
can be used or should be released by rtfree(9).

It currently checks if the route is UP and is not attached to a stall
ifa.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.227 2015/09/01 10:04:51 mpi Exp $	*/
d903 1
a903 1
		rt->rt_flags = info->rti_flags;
d909 6
a914 9
		if (rtable_mpath_capable(tableid, ndst->sa_family)) {
			/* check the link state since the table supports it */
			if (LINK_STATE_IS_UP(ifa->ifa_ifp->if_link_state) &&
			    ifa->ifa_ifp->if_flags & IFF_UP)
				rt->rt_flags |= RTF_UP;
			else {
				rt->rt_flags &= ~RTF_UP;
				rt->rt_priority |= RTP_DOWN;
			}
@


1.227
log
@Do not try to find a possible ``ifa'' in rt_ifal_del(9) and trust the
checks done in rtrequest1(9).

This chunk has been introduced in 1991 when rtrequest1(RTM_DELETE...)
was not doing a route lookup and no longer make any sense.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.226 2015/08/30 10:39:16 mpi Exp $	*/
d303 19
a680 2
		if (rt == NULL)
			return (NULL);
d682 2
a683 2
		if ((rt->rt_flags & RTF_GATEWAY) &&
		    rt_key(rt)->sa_family == dst->sa_family) {
a687 4
		if (ifa == NULL || ifa->ifa_ifp == NULL) {
			rtfree(rt);
			return (NULL);
		}
@


1.226
log
@Use a global table for domains instead of building a list at run time.

As a side effect there's no need to run if_attachdomain() after the
list of domains has been built.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.225 2015/08/24 22:11:33 mpi Exp $	*/
a1234 15
	}
	if ((rt = rtalloc(dst, 0, rtableid)) != NULL) {
		rt->rt_refcnt--;
#ifndef ART
		/* try to find the right route */
		while (rt && rt->rt_ifa != ifa)
			rt = (struct rtentry *)
			    ((struct radix_node *)rt)->rn_dupedkey;
		if (!rt) {
			if (m != NULL)
				(void) m_free(m);
			return (flags & RTF_HOST ? EHOSTUNREACH
						: ENETUNREACH);
		}
#endif
@


1.225
log
@Always increment the reference counter of the returned route entry in
rtrequest1(9).

This simplifies rtfree(9) dances and will prevent another CPU to free
the entry before we're done with it as soon as routing functions can
be executed in parallel.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.224 2015/08/20 12:39:43 mpi Exp $	*/
d176 1
a176 1
	u_int8_t	  i;
d183 1
a183 1
	for (dom = domains; dom != NULL; dom = dom->dom_next)
d187 1
d200 2
a201 1
	struct domain	 *dom;
d211 1
a211 1
	for (dom = domains; dom != NULL; dom = dom->dom_next)
d214 1
@


1.224
log
@Import an alternative routing table backend based on Yoichi Hariguchi's
ART implementation.

ART (Allotment Routing Table) is a multibit-trie algorithm invented by
D. Knuth while reviewing Yoichi's SMART [0] (Smart Multi-Array Routing
Table) paper.

This implementation, unlike the one from the KAME project, supports
variable stride lengths which makes it easier to adapt the consumed
memory/speed trade-off.  It also let you use a bigger first-level
table, what other algorithms such as POPTRIE [1] need to implement
separately.

Adaptation to the OpenBSD kernel has been done with two different data
structures.  ART nodes and route entries are managed separately which
makes the algorithm implementation free of any MULTIPATH logic.

This implementation does not include Path Compression.

[0] http://www.hariguchi.org/art/smart.pdf
[1] http://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p57.pdf

ok dlg@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.223 2015/08/19 13:27:38 bluhm Exp $	*/
a572 1

d574 1
a574 4

	/* Adjust the refcount */
	if (error == 0 && rt->rt_refcnt <= 0) {
		rt->rt_refcnt++;
a575 1
	}
d818 2
a819 1
		if (ret_nrt)
d821 1
a821 2
		else if (rt->rt_refcnt <= 0) {
			rt->rt_refcnt++;
a822 1
		}
d1268 1
a1268 4
		if (rt->rt_refcnt <= 0) {
			rt->rt_refcnt++;
			rtfree(rt);
		}
@


1.223
log
@Convert all calls to rtrequest1() and the following error check
into a common pattern.  In the man page clarify the usage of the
returned route.
OK mpi@@ mikeb@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.222 2015/08/19 10:42:37 mpi Exp $	*/
d1241 1
d1252 1
@


1.222
log
@Use rtfree(9) instead of decrementing rt_refcnt in rt_getifa().

Note that it is safe to keep a reference to the ifa pointed by a route
entry after freeing the entry iff the ifa is valid.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.221 2015/08/18 08:56:16 mpi Exp $	*/
d304 1
a304 1
	struct rtentry		*newrt = 0;
d306 3
a308 1
	int			 s = splsoftnet(), err = 0, msgtype = RTM_MISS;
d317 1
a317 1
			err = rtrequest1(RTM_RESOLVE, &info, RTP_DEFAULT,
d319 1
a319 1
			if (err) {
d324 2
a325 1
			if ((rt = newrt) && (rt->rt_flags & RTF_XRESOLVE)) {
d339 1
a339 1
			rt_missmsg(msgtype, &info, 0, NULL, err, tableid);
d516 1
a516 1
			if (rt != NULL)
d1152 1
a1152 1
	struct rtentry		*rt = NULL;
d1185 1
a1185 1
	if (error == 0 && rt != NULL) {
d1216 1
a1216 1
	struct rtentry		*rt, *nrt = NULL;
d1267 3
a1269 3
	error = rtrequest1(RTM_DELETE, &info, prio, &nrt, rtableid);
	if (error == 0 && (rt = nrt) != NULL) {
		rt_sendmsg(nrt, RTM_DELETE, rtableid);
d1271 1
a1271 1
			rt_sendaddrmsg(nrt, RTM_DELADDR);
@


1.221
log
@Remove PF_KEY-specific hacks from rtalloc(9).  They are dead since SPD
lookups use the radix API directly.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.220 2015/08/17 09:50:12 mpi Exp $	*/
a662 1
		rt->rt_refcnt--;
d665 2
a666 1
		    rt_key(rt)->sa_family == dst->sa_family)
d668 1
d670 2
a671 1
		if (ifa == NULL || ifa->ifa_ifp == NULL)
d673 2
@


1.220
log
@Remove unused variable in rt_ifa_add(), prodded by bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.219 2015/08/17 09:46:26 mpi Exp $	*/
d331 1
a331 7
		if (dst->sa_family != PF_KEY)
			rtstat.rts_unreach++;
	/*
	 * IP encapsulation does lots of lookups where we don't need nor want
	 * the RTM_MISSes that would be generated.  It causes RTM_MISS storms
	 * sent upward breaking user-level routing queries.
	 */
d333 1
a333 1
		if (ISSET(flags, RT_REPORT) && dst->sa_family != PF_KEY) {
@


1.219
log
@Convert two rt->rt_refcnt-- into rtfree(9) making sure the route entry
is freed when we no longer need it.

In this case both code paths are executed in process context and thus
serialized by the KERNEL_LOCK.  Since we are adding a route entry to
the table in both cases, rtfree(9) will not actually free the entry
because it is still RT_VALID.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.218 2015/08/17 09:41:24 mpi Exp $	*/
d1151 1
a1151 1
	struct rtentry		*rt, *nrt = NULL;
d1183 2
a1184 2
	error = rtrequest1(RTM_ADD, &info, prio, &nrt, rtableid);
	if (error == 0 && (rt = nrt) != NULL) {
@


1.218
log
@Match the free(3) semantic and accept NULL pointers in rtfree(9).

This will simplify upcoming conversions of rt_refcnt-- to rtfree(9).
Such conversions are needed for proper MP refcounting.

ok deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.217 2015/07/18 15:51:16 mpi Exp $	*/
a1184 1
		rt->rt_refcnt--;
d1204 3
a1206 2
			rt_sendaddrmsg(nrt, RTM_NEWADDR);
		rt_sendmsg(nrt, RTM_ADD, rtableid);
@


1.217
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.216 2015/07/16 18:17:27 claudio Exp $	*/
d382 2
a383 1
	KASSERT(rt != NULL);
@


1.216
log
@Fix rn_match and there for the expoerted lookup functions in radix.c
to never return the internal RNF_ROOT nodes. This removes the checks
in the callee to verify that not an RNF_ROOT node was returned.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.215 2015/06/29 11:04:16 mpi Exp $	*/
d123 6
d140 1
a140 1
struct	radix_node_head	***rt_tables;
d152 4
a155 4
int	rtable_init(struct radix_node_head ***, u_int);
int	rtflushclone1(struct radix_node *, void *, u_int);
void	rtflushclone(struct radix_node_head *, struct rtentry *);
int	rt_if_remove_rtdelete(struct radix_node *, void *, u_int);
d172 1
a172 1
rtable_init(struct radix_node_head ***table, u_int id)
d188 2
a189 1
	*table = (struct radix_node_head **)p;
d191 1
a191 4
	for (i = 0; i < rtafidx_max; i++) {
		if ((*table)[i] != NULL)
			(*table)[i]->rnh_rtableid = id;
	}
d203 1
a203 1
	rn_init();	/* initialize all zeroes, all ones, mask table */
d256 1
a256 1
	return (rtable_init(&rt_tables[id], id));
d259 1
a259 1
struct radix_node_head *
a302 1
	struct radix_node_head	*rnh;
a303 1
	struct radix_node	*rn;
d311 3
a313 3
	rnh = rtable_get(tableid, dst->sa_family);
	if (rnh && (rn = rnh->rnh_matchaddr((caddr_t)dst, rnh))) {
		newrt = rt = (struct rtentry *)rn;
d349 28
d387 1
a387 1
		if (rt->rt_refcnt == 0 && (rt->rt_nodes->rn_flags & RNF_ACTIVE))
d389 1
a389 1
		if (rt->rt_nodes->rn_flags & (RNF_ACTIVE | RNF_ROOT))
d597 1
a597 1
rtflushclone1(struct radix_node *rn, void *arg, u_int id)
d599 1
a599 1
	struct rtentry	*rt, *parent;
a600 2
	rt = (struct rtentry *)rn;
	parent = (struct rtentry *)arg;
d608 1
a608 1
rtflushclone(struct radix_node_head *rnh, struct rtentry *parent)
a613 2
	if (!rnh->rnh_walktree)
		panic("rtflushclone: no rnh_walktree");
d615 1
a615 1
	rnh->rnh_walktree(rnh, rtflushclone1, (void *)parent);
a751 2
	struct radix_node	*rn;
	struct radix_node_head	*rnh;
d763 1
a763 2
	if ((rnh = rtable_get(tableid, info->rti_info[RTAX_DST]->sa_family)) ==
	    NULL)
d769 3
a771 2
		if ((rn = rnh->rnh_lookup(info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_NETMASK], rnh)) == NULL)
a772 1
		rt = (struct rtentry *)rn;
d774 5
d780 2
a781 2
		 * if we got multipath routes, we require users to specify
		 * a matching RTAX_GATEWAY.
d783 3
a785 9
		if (rn_mpath_capable(rnh)) {
			rt = rt_mpath_matchgate(rt,
			    info->rti_info[RTAX_GATEWAY], prio);
			rn = (struct radix_node *)rt;
			if (!rt ||
			    (!info->rti_info[RTAX_GATEWAY] &&
			    rt->rt_flags & RTF_MPATH))
				return (ESRCH);
		}
d797 3
a799 2
		if ((rn = rnh->rnh_deladdr(info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_NETMASK], rnh, rn)) == NULL)
a800 1
		rt = (struct rtentry *)rn;
d804 1
a804 4
			rtflushclone(rnh, rt);

		if (rn->rn_flags & (RNF_ACTIVE | RNF_ROOT))
			panic ("rtrequest delete");
d877 6
a882 9
		if (rn_mpath_capable(rnh)) {
			/* do not permit exactly the same dst/mask/gw pair */
			if (rt_mpath_conflict(rnh, ndst,
			    info->rti_info[RTAX_NETMASK],
			    info->rti_info[RTAX_GATEWAY], prio,
			    info->rti_flags & RTF_MPATH)) {
				free(ndst, M_RTABLE, dlen);
				return (EEXIST);
			}
d897 1
a897 1
		if (rn_mpath_capable(rnh)) {
d993 3
a995 4
		rn = rnh->rnh_addaddr((caddr_t)ndst,
		    (caddr_t)info->rti_info[RTAX_NETMASK], rnh, rt->rt_nodes,
		    rt->rt_priority);
		if (rn == NULL && (crt = rtalloc(ndst, 0, tableid)) != NULL) {
d999 4
a1002 4
				rn = rnh->rnh_addaddr((caddr_t)ndst,
				    (caddr_t)info->rti_info[RTAX_NETMASK],
				    rnh, rt->rt_nodes, rt->rt_priority);
			}
d1005 1
a1005 1
		if (rn == 0) {
d1026 1
a1026 1
			rtflushclone(rnh, rt);
a1534 11
struct rtentry *
rt_lookup(struct sockaddr *dst, struct sockaddr *mask, u_int tableid)
{
	struct radix_node_head	*rnh;

	if ((rnh = rtable_get(tableid, dst->sa_family)) == NULL)
		return (NULL);

	return ((struct rtentry *)rnh->rnh_lookup(dst, mask, rnh));
}

a1663 1
	struct radix_node_head	*rnh;
d1670 2
a1671 3
			if ((rnh = rtable_get(tid, i)) != NULL)
				while ((*rnh->rnh_walktree)(rnh,
				    rt_if_remove_rtdelete, ifp) == EAGAIN)
d1684 1
a1684 1
rt_if_remove_rtdelete(struct radix_node *rn, void *vifp, u_int id)
a1686 1
	struct rtentry	*rt = (struct rtentry *)rn;
a1706 1
	struct radix_node_head *rnh;
d1718 6
a1723 7
			if ((rnh = rtable_get(tid, i)) != NULL) {
				if (!rn_mpath_capable(rnh))
					continue;
				while ((*rnh->rnh_walktree)(rnh,
				    rt_if_linkstate_change, ifp) == EAGAIN)
					;	/* nothing */
			}
d1729 1
a1729 1
rt_if_linkstate_change(struct radix_node *rn, void *arg, u_int id)
a1731 1
	struct rtentry *rt = (struct rtentry *)rn;
d1733 19
a1751 22
	if (rt->rt_ifp == ifp) {
		if (LINK_STATE_IS_UP(ifp->if_link_state) &&
		    ifp->if_flags & IFF_UP) {
			if (!(rt->rt_flags & RTF_UP)) {
				/* bring route up */
				rt->rt_flags |= RTF_UP;
				rn_mpath_reprio(rn, rt->rt_priority & RTP_MASK);
			}
		} else {
			if (rt->rt_flags & RTF_UP) {
				/*
				 * Remove cloned routes (mainly arp) to
				 * down interfaces so we have a chance to
				 * clone a new route from a better source.
				 */
				if (rt->rt_flags & RTF_CLONED) {
					rtdeletemsg(rt, id);
					return (0);
				}
				/* take route down */
				rt->rt_flags &= ~RTF_UP;
				rn_mpath_reprio(rn, rt->rt_priority | RTP_DOWN);
d1753 3
a1756 1
		if_group_routechange(rt_key(rt), rt_mask(rt));
d1758 1
@


1.215
log
@Never cache a RTF_GATEWAY route as next hop for a gateway route.

This prevents rtentry loops when rt->rt_gwroute points to rt leading
to an infamous "rtentry leak" panic, easily triggered by dhclient(8)
trying to remove a route after resuming a machine.

This bug is at least 20 years old!  4.4BSD-Lite2 had a fix for it in
its X.25 output routine but apparently it never made it into OpenBSD.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.214 2015/06/22 09:07:11 mpi Exp $	*/
d310 1
a310 2
	if (rnh && (rn = rnh->rnh_matchaddr((caddr_t)dst, rnh)) &&
	    ((rn->rn_flags & RNF_ROOT) == 0)) {
@


1.214
log
@rtrequest1(9) error code path cleanup.

Pass the length to free(9), do not violate the radix/route layer and
set the gateway of a route a bit later to simplify error code path.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.213 2015/06/06 09:31:53 mpi Exp $	*/
d1090 10
@


1.213
log
@Put the link-layer address back into the gateway field of RTF_LOCAL
routes.

Since such routes are also flagged with RTF_LLINFO various code path
assume correctly that they contain valid ARP or ND information.

This fixes the "arpresolve: unresolved and rt_expire == 0" issue
reported on tech@@ by mxb <mxb AT alumni DOT chalmers DOT se>.

ok claudio@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.212 2015/05/26 12:19:51 mpi Exp $	*/
d865 1
a865 1
				free(ndst, M_RTABLE, 0);
d872 1
a872 1
			free(ndst, M_RTABLE, 0);
a879 8
		rt->rt_nodes->rn_key = (caddr_t)ndst;

		if ((error = rt_setgate(rt, info->rti_info[RTAX_GATEWAY],
		    tableid))) {
			free(ndst, M_RTABLE, 0);
			pool_put(&rtentry_pool, rt);
			return (error);
		}
d914 1
a914 5
				if (rt->rt_gwroute)
					rtfree(rt->rt_gwroute);
				if (rt->rt_gateway)
					free(rt->rt_gateway, M_RTABLE, 0);
				free(rt_key(rt), M_RTABLE, 0);
d965 13
d999 1
a999 1
			free(rt_key(rt), M_RTABLE, 0);
@


1.212
log
@Store the IP address of the corresponding ifa in the rt_gateway field
of RTF_CLONING and RTF_BROASCAST routes to not create MPATH conflicts
when IP address aliases are used.

This change makes it possible to have multiple RTF_CLONING routes with
the same priority.  Note that any of the existing RTF_CLONING route
might be used by the kernel to create a RTF_CLONED route which should
not be a problem with aliases since they are attached to the same ifp.

This unbreak address aliases since the kernel supports multiple connected
routes for a subnet.

Found the hardway by djm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.211 2015/05/26 12:02:11 mpi Exp $	*/
d1124 1
a1126 1
	struct sockaddr_dl	 sa_dl = { sizeof(sa_dl), AF_LINK };
d1128 2
a1129 2
	u_short			 rtableid = ifa->ifa_ifp->if_rdomain;
	u_int8_t		 prio = ifa->ifa_ifp->if_priority + RTP_STATIC;
a1131 3
	sa_dl.sdl_type = ifa->ifa_ifp->if_type;
	sa_dl.sdl_index = ifa->ifa_ifp->if_index;

d1137 1
a1137 1
		info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)&sa_dl;
d1140 1
a1140 2
	info.rti_info[RTAX_LABEL] =
	    rtlabel_id2sa(ifa->ifa_ifp->if_rtlabelid, &sa_rl);
d1188 1
d1194 2
a1195 3
	struct sockaddr_dl	 sa_dl = { sizeof(sa_dl), AF_LINK };
	u_short			 rtableid = ifa->ifa_ifp->if_rdomain;
	u_int8_t		 prio = ifa->ifa_ifp->if_priority + RTP_STATIC;
a1225 3
	sa_dl.sdl_type = ifa->ifa_ifp->if_type;
	sa_dl.sdl_index = ifa->ifa_ifp->if_index;

d1230 1
a1230 3
	if (flags & RTF_LLINFO)
		info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)&sa_dl;
	else
d1232 1
a1232 2
	info.rti_info[RTAX_LABEL] =
	    rtlabel_id2sa(ifa->ifa_ifp->if_rtlabelid, &sa_rl);
@


1.211
log
@Normalize route destination before checking for MPATH conflicts.

This makes rt_mpath_conflict() work as expected when adding routes
with the same destination and the same netmask.

With and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.210 2015/05/15 12:00:57 claudio Exp $	*/
d732 1
d831 1
d834 1
a834 1
		info->rti_info[RTAX_GATEWAY] = rt->rt_gateway;
d1139 4
a1142 1
	info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)&sa_dl;
d1237 4
a1240 1
	info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)&sa_dl;
@


1.210
log
@Allow multiple connected/interface routes to exist at the same time.
Use the existing multipath code. Switch away from using the ifa address
when making the cloning route and instead put a dummy sockaddr_dl route
in. With this it is possible to use the same network on multiple interfaces
at the same time. So if wireless and ethernet share the same network
the system will use the wired connection as long as there is link.
Still missing is builtin proxy-arp for the other interface IPs to allow
hitless failover.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.209 2015/04/20 09:12:57 mpi Exp $	*/
d844 12
d859 1
a859 1
			if (rt_mpath_conflict(rnh, info->rti_info[RTAX_DST],
d863 1
d869 2
a870 7
		if (rt == NULL)
			return (ENOBUFS);

		dlen = info->rti_info[RTAX_DST]->sa_len;
		ndst = malloc(dlen, M_RTABLE, M_NOWAIT);
		if (ndst == NULL) {
			pool_put(&rtentry_pool, rt);
a878 1
		memcpy(ndst, info->rti_info[RTAX_DST], dlen);
d882 1
a885 4

		if (info->rti_info[RTAX_NETMASK] != NULL)
			rt_maskedcopy(info->rti_info[RTAX_DST], ndst,
			    info->rti_info[RTAX_NETMASK]);
@


1.209
log
@Remove a bad typo introduced in rev 1.185 and found by jsg@@.

Because of this semicolon, a local route was *always* created.  This
should have no impact except for IPv6 addresses on loopback interfaces
for which the IPv6 code was trying to create a route to "::1" twice.

This should now be fixed so we can fix the bug that was hidding a bug
who was hidding a bug... lalala...

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.208 2015/03/26 11:02:44 mpi Exp $	*/
d557 10
d574 2
a575 1
	if ((rt->rt_flags & RTF_CLONED) != 0 && rt->rt_parent == parent)
d1120 1
d1123 1
a1123 1
	u_int8_t		 prio = RTP_CONNECTED;
d1126 3
d1131 1
a1131 1
	info.rti_flags = flags;
d1133 1
a1133 1
	info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
d1188 1
d1190 1
a1190 1
	u_int8_t		 prio = RTP_CONNECTED;
d1221 3
d1228 1
d1733 9
@


1.208
log
@Use rt_ifa_add(9) and rt_ifa_del(9) to configure MPLS labels.

Since the removal of the link-layer ifa from "struct ifnet" it was
impossible to configure MPLS routes on mpe(4).  Because just like
enc(4), mpe(4) was abusing the link-layer ifa to attach its route
entries.

So explicitly pass a "glue" ifa to the routing layer.

From Rafael Zalamena who discovered this the hardway, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.207 2015/02/12 11:19:57 mpi Exp $	*/
d1271 1
a1271 1
	if (rt == NULL || !ISSET(rt->rt_flags, flags));
@


1.207
log
@When purging the routes corresponding to an ifp, skip the routing tables
of different routing domains.

The same change has been applied to rt_if_track() in r1.205.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.206 2015/02/11 23:34:43 mpi Exp $	*/
d1122 9
d1176 6
@


1.206
log
@Do not store the key and the gateway of a route entry in the same chunk
of memory.

The key (destination) is only set once, when the route is inserted in
the routing table, and does not need to change afterward.  The gateway
might change and rt_setgate() will do all the checks for you.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.205 2015/02/10 03:04:11 claudio Exp $	*/
d1616 3
@


1.205
log
@In rt_if_track skip rtables that are not in the rdomain of the ifp.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.204 2015/02/06 01:21:17 mpi Exp $	*/
d376 2
d500 1
a500 1
			rt_setgate(rt, rt_key(rt), gateway, rdomain);
d721 1
a721 1
	int			 error;
d848 7
d859 5
a863 2
		if ((error = rt_setgate(rt, info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_GATEWAY], tableid))) {
d867 2
a868 2
		ndst = rt_key(rt);
		if (info->rti_info[RTAX_NETMASK] != NULL) {
d871 1
a871 3
		} else
			memcpy(ndst, info->rti_info[RTAX_DST],
			    info->rti_info[RTAX_DST]->sa_len);
d907 2
d979 2
d1006 1
a1006 2
rt_setgate(struct rtentry *rt, struct sockaddr *dst, struct sockaddr *gate,
    u_int tableid)
d1008 2
a1009 2
	caddr_t	new, old;
	int	dlen = ROUNDUP(dst->sa_len), glen = ROUNDUP(gate->sa_len);
d1012 2
a1013 3
		old = (caddr_t)rt_key(rt);
		new = malloc(dlen + glen, M_RTABLE, M_NOWAIT);
		if (new == NULL)
d1015 2
a1016 4
		rt->rt_nodes->rn_key = new;
	} else {
		new = rt->rt_nodes->rn_key;
		old = NULL;
a1017 1
	rt->rt_gateway = (struct sockaddr *)(new + dlen);
d1019 1
a1019 4
	if (old) {
		memmove(new, dst, dlen);
		free(old, M_RTABLE, 0);
	}
@


1.204
log
@Change rt_mpath_conflict() to not rely on an initialized rtentry when
checking for actual conflict.

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.203 2015/01/28 22:10:13 mpi Exp $	*/
d1658 3
@


1.203
log
@Revert rtdeletemsg conversion.  It was not ok'd, I misunderstood bluhm@@'s
email.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.202 2015/01/26 11:36:38 mpi Exp $	*/
d829 13
a847 3

		if (prio == 0)
			prio = ifa->ifa_ifp->if_priority + RTP_STATIC;
a863 10
			/* do not permit exactly the same dst/mask/gw pair */
			if (rt_mpath_conflict(rnh, rt,
			    info->rti_info[RTAX_NETMASK],
			    info->rti_flags & RTF_MPATH)) {
				if (rt->rt_gwroute)
					rtfree(rt->rt_gwroute);
				free(rt_key(rt), M_RTABLE, 0);
				pool_put(&rtentry_pool, rt);
				return (EEXIST);
			}
@


1.202
log
@Do not always try to rtfree(9) route entries inside rtdeletemsg(9).

Instead check the error code returned by this function and let the
caller free the route entry when appropriate.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.201 2015/01/21 21:32:42 bluhm Exp $	*/
d547 5
a558 1
	int error;
d562 2
a563 9
	if ((rt->rt_flags & RTF_CLONED) != 0 && rt->rt_parent == parent) {
		error = rtdeletemsg(rt, id);

		/* Adjust the refcount */
		if (error == 0 && rt->rt_refcnt <= 0) {
			rt->rt_refcnt++;
			rtfree(rt);
		}
	}
d1634 2
a1635 11
		if (rtdeletemsg(rt, id) == 0) {

			/* Adjust the refcount */
			if (rt->rt_refcnt <= 0) {
				rt->rt_refcnt++;
				rtfree(rt);
			}

			if (cloning)
				return (EAGAIN);
		}
@


1.201
log
@Remove the useless variable ifa in rt_getifa().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.200 2015/01/18 14:51:43 mpi Exp $	*/
a546 5
	/* Adjust the refcount */
	if (error == 0 && rt->rt_refcnt <= 0) {
		rt->rt_refcnt++;
		rtfree(rt);
	}
d554 1
d558 9
a566 2
	if ((rt->rt_flags & RTF_CLONED) != 0 && rt->rt_parent == parent)
		rtdeletemsg(rt, id);
d1637 11
a1647 2
		if (rtdeletemsg(rt, id) == 0 && cloning)
			return (EAGAIN);
@


1.200
log
@Do not even try to dereference a NULL pointer.

Found the hard way by Peter N. M. Hansteen.

ok claudio@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.199 2015/01/13 12:14:00 mpi Exp $	*/
a652 1
	struct ifaddr	*ifa;
d703 1
a703 1
	if ((ifa = info->rti_ifa) == NULL)
@


1.199
log
@Restore sending RTM_ADD and RTM_DELETE messages to userland for every
route created/deleted with rt_ifa_add(9)/rt_ifa_del(9), not only for
RTF_LOCAL routes.

Regression introduced in r1.172 when restoring the original behavior
of RTM_NEWADDR/RTM_RTM_DELADDR reported by Florian Riehm.

Joint work with Florian Riehm, with input from and ok bluhm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.198 2015/01/08 15:05:44 mpi Exp $	*/
d1048 2
d1051 1
a1051 1
		if (rt == NULL || rt->rt_ifp != ifp)
@


1.198
log
@Include the Routing Table ID in "struct rtentry" and reorder the fields
such that there's no size change on, at least, amd64.

This will allow us to simplify some APIs and deprecate the remaining
flavors of "struct route".

ok claudio@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.197 2015/01/08 14:29:18 mpi Exp $	*/
d385 1
d387 1
a387 1
	bzero(&info, sizeof(info));
d391 1
d1143 2
a1144 1
			rt_newaddrmsg(RTM_ADD, ifa, error, nrt);
d1198 1
d1200 1
a1200 1
			rt_newaddrmsg(RTM_DELETE, ifa, error, nrt);
@


1.197
log
@Factorize various duplicated chunks of (old and horrible) code, checking
for the validity of a given outgoing route entry into a single function.

This change is inspired from FreeBSD r111767.  The function introduced
here, rt_checkgate(), should hopefully die in a near future.  Why should
it die?  Well, it is way too late to do such validity checks: if your
kernel can ends up in ether_output() with an invalid route, please do
not let it try to find a new one that might do the job.

Go read this function if you're wondering why you're getting messages
like:

"arpresolve: X.X.X.X: route without link local address"

Since this horrible logic has survived 20 years of copy & past and small
modifications for workarounds without a single clear commit message, let's
assume it is full of dragons and try to play safe.  This factorization is
not intended to change any behavior.

With much inputs from bluhm@@, tested by weerd@@ and florian@@ on setups
with p2p IPv6 interfaces.

ok bluhm@@, benno@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.196 2014/12/29 11:53:58 mpi Exp $	*/
d833 1
@


1.196
log
@Assert that rtrequest1(9) is always called at IPL_SOFTNET instead of
doing a spl dance.

This matters for RTM_DELETE because a deleted route entry is always
returned without having its reference counter increased when an `rtp'
argument is given.  In this case, we do not want to call splx() that
might free this route.

Inputs from millert@@, ok blambert@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.195 2014/12/19 18:57:17 bluhm Exp $	*/
d1032 39
@


1.195
log
@Do not report an EDQUOT "Disk quota exceeded" error from the routing
code.  Instead generate an ENOBUFS "No buffer space available" error
at the malloc(9) failure in rt_setgate(9) and propagate it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.194 2014/12/08 10:46:14 mpi Exp $	*/
a711 1
	int			 s = splsoftnet(); int error = 0;
d718 1
d722 2
a723 1
#define senderr(x) { error = x ; goto bad; }
d727 1
a727 1
		senderr(EAFNOSUPPORT);
d734 1
a734 1
			senderr(ESRCH);
d748 1
a748 1
				senderr(ESRCH);
d759 1
a759 1
			senderr(EINVAL);
d763 1
a763 1
			senderr(ESRCH);
d798 1
a798 1
			senderr(EINVAL);
d800 1
a800 1
			senderr(EINVAL);
d826 1
a826 1
			senderr(error);
d830 1
a830 1
			senderr(ENOBUFS);
d841 1
a841 1
			senderr(error);
d860 1
a860 1
				senderr(EEXIST);
d897 1
a897 1
				senderr(ENOMEM);
d967 1
a967 1
			senderr(EEXIST);
d985 2
a986 3
bad:
	splx(s);
	return (error);
@


1.194
log
@There's no good reason to keep into "struct ifnet" a pointer that's only
used by enc(4) devices to attach their routes.

ok sthen@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.193 2014/12/05 15:50:04 mpi Exp $	*/
d837 2
a838 2
		if (rt_setgate(rt, info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_GATEWAY], tableid)) {
d840 1
a840 1
			senderr(ENOBUFS);
d1000 1
a1000 1
			return 1;
@


1.193
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.192 2014/12/02 18:11:56 tedu Exp $	*/
a130 2

struct ifaddr	*encap_findgwifa(struct sockaddr *, u_int);
a164 20
#ifdef IPSEC
struct ifaddr *
encap_findgwifa(struct sockaddr *gw, u_int rdomain)
{
	struct ifnet	*encif;

	if ((encif = enc_getif(rdomain, 0)) == NULL)
		return (NULL);

	/*
	 * This is not a real link-layer address, it is an empty ifa of
	 * type AF_LINK.
	 * It is used when adding an encap route entry because RTM_ADD
	 * and rt_getifa() want an ifa to find an ifp to associate it to
	 * the route.
	 */
	return (encif->if_lladdr);
}
#endif

a589 11
#ifdef IPSEC
	/*
	 * If the destination is a PF_KEY address, we'll look
	 * for the existence of a encap interface number or address
	 * in the options list of the gateway. By default, we'll return
	 * enc0.
	 */
	if (dst && (dst->sa_family == PF_KEY))
		return (encap_findgwifa(gateway, rtableid));
#endif

d619 1
a619 1
				ifa = ifp->if_lladdr;
d666 12
@


1.192
log
@replace some malloc multiplies with mallocarry. ok deraadt henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.191 2014/11/24 12:43:54 mpi Exp $	*/
d118 1
@


1.191
log
@Rename rt_ifa_addloop() into rt_ifa_addlocal() and make it return an
error code on failure (unchecked for the moment).

ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.190 2014/11/10 10:38:46 mpi Exp $	*/
d193 1
a193 1
	if ((p = malloc(sizeof(void *) * (rtafidx_max + 1), M_RTABLE,
d245 2
a246 2
		size_t	newlen = sizeof(void *) * (id+1);
		size_t	newlen2 = sizeof(u_int) * (id+1);
d248 2
a249 1
		if ((p = malloc(newlen, M_RTABLE, M_NOWAIT|M_ZERO)) == NULL)
d251 4
a254 2
		if ((q = malloc(newlen2, M_RTABLE, M_NOWAIT|M_ZERO)) == NULL) {
			free(p, M_RTABLE, 0);
d257 1
@


1.190
log
@Plug a rtentry leak and change the name of the pool to something
understandable.

ok chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.189 2014/11/04 15:24:40 mpi Exp $	*/
d1185 1
a1185 1
 * Add ifa's address as a loopback rtentry.
d1187 2
a1188 2
void
rt_ifa_addloop(struct ifaddr *ifa)
d1192 1
d1203 1
a1203 1
			return;
d1209 1
a1209 1
			return;
d1222 1
a1222 1
		rt_ifa_add(ifa, RTF_UP | flags, ifa->ifa_addr);
d1225 2
d1230 1
a1230 1
 * Remove loopback rtentry of ifa's addresss if it exists.
d1232 2
a1233 2
void
rt_ifa_delloop(struct ifaddr *ifa)
d1237 1
d1246 1
a1246 1
			return;
d1252 1
a1252 1
			return;
d1272 1
a1272 1
		rt_ifa_del(ifa, flags, ifa->ifa_addr);
d1275 2
@


1.189
log
@Remove "pl" suffix on pool names.

ok dlg@@, uebayasi@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.188 2014/11/01 21:40:38 mpi Exp $	*/
d218 1
a218 1
	pool_init(&rtentry_pool, sizeof(struct rtentry), 0, 0, 0, "rtent",
d1223 1
a1223 1
		rt->rt_refcnt--;
d1270 1
a1270 1
		rt->rt_refcnt--;
@


1.188
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.187 2014/10/14 09:52:26 mpi Exp $	*/
d218 1
a218 1
	pool_init(&rtentry_pool, sizeof(struct rtentry), 0, 0, 0, "rtentpl",
d1312 1
a1312 1
	pool_init(&rttimer_pool, sizeof(struct rttimer), 0, 0, 0, "rttmrpl",
@


1.187
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.186 2014/10/08 07:37:02 mpi Exp $	*/
d314 1
a314 1
rtalloc1(struct sockaddr *dst, int flags, u_int tableid)
d330 1
a330 2
		if ((rt->rt_flags & RTF_CLONING) &&
		    ISSET(flags,  RT_REPORT | RT_NOCLONING) == RT_REPORT) {
d454 1
a454 1
	rt = rtalloc1(dst, 0, rdomain);
d653 1
a653 1
		struct rtentry	*rt = rtalloc1(gateway, 0, rtable_l2(rtableid));
d964 1
a964 1
		if (rn == NULL && (crt = rtalloc1(ndst, 0, tableid)) != NULL) {
d1034 1
a1034 1
		rt->rt_gwroute = rtalloc1(gate, RT_REPORT, rtable_l2(tableid));
d1142 1
a1142 1
	if ((rt = rtalloc1(dst, 0, rtableid)) != NULL) {
d1219 1
a1219 1
	rt = rtalloc1(ifa->ifa_addr, 0, ifa->ifa_ifp->if_rdomain);
d1266 1
a1266 1
	rt = rtalloc1(ifa->ifa_addr, 0, ifa->ifa_ifp->if_rdomain);
@


1.186
log
@Use rtalloc1() instead of rtalloc_noclone().

ok henning@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.185 2014/10/02 12:21:20 mpi Exp $	*/
d371 1
a371 2
	if (rt == NULL)
		panic("rtfree");
d790 2
a791 2
			rt = rt->rt_gwroute; RTFREE(rt);
			(rt = (struct rtentry *)rn)->rt_gwroute = NULL;
d973 1
a973 1
			RTFREE(crt);
d1030 1
a1030 1
		RTFREE(rt->rt_gwroute);
@


1.185
log
@Local routes that do not translate a protocol address into a link-layer
address should not be flagged with RTF_LLINFO.

With this fix, arp(8) will no longer report an incomplete entry for lo0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.184 2014/10/01 08:38:29 mpi Exp $	*/
a310 12
}

/*
 * Packet routing routines.
 */
void
rtalloc_noclone(struct route *ro)
{
	if (ro->ro_rt && ro->ro_rt->rt_ifp && (ro->ro_rt->rt_flags & RTF_UP))
		return;		/* cached route is still valid */
	ro->ro_rt = rtalloc1(&ro->ro_dst, RT_REPORT | RT_NOCLONING,
	    ro->ro_tableid);
@


1.184
log
@Use the modern way of checking if a local route exists.

With KAME's hack of ``loopbacked host route'' we were checking if the
associated interface was a loopback.  Now simply look for the correct
flags, which also helps reducing the number of ifp pointer derefences.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.183 2014/09/27 12:26:16 mpi Exp $	*/
d1205 1
d1229 3
d1234 2
a1235 3
	if (rt == NULL || (rt->rt_flags & (RTF_HOST|RTF_LLINFO|RTF_LOCAL)) == 0)
		rt_ifa_add(ifa, RTF_UP| RTF_HOST | RTF_LLINFO | RTF_LOCAL,
		    ifa->ifa_addr);
d1247 1
d1269 3
d1281 2
a1282 3
	if (rt != NULL && (rt->rt_flags & (RTF_HOST|RTF_LLINFO|RTF_LOCAL)) != 0)
		rt_ifa_del(ifa,  RTF_HOST | RTF_LLINFO | RTF_LOCAL,
		    ifa->ifa_addr);
@


1.183
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.182 2014/09/03 08:51:01 mpi Exp $	*/
d1230 1
a1230 2
	if (rt == NULL || (rt->rt_flags & RTF_HOST) == 0 ||
	    (rt->rt_ifp->if_flags & IFF_LOOPBACK) == 0)
d1266 1
a1266 1
	 * Before deleting, check if a corresponding loopbacked host
d1274 1
a1274 2
	if (rt != NULL && (rt->rt_flags & RTF_HOST) != 0 &&
	    (rt->rt_ifp->if_flags & IFF_LOOPBACK) != 0)
@


1.182
log
@Treat broadcast entries like local ones and give them the highest
route priority.

While here document a RTM_ADD message is only send to userland for
local entries.

ok mikeb@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.181 2014/08/26 15:09:26 mpi Exp $	*/
a322 8
}

void
rtalloc(struct route *ro)
{
	if (ro->ro_rt && ro->ro_rt->rt_ifp && (ro->ro_rt->rt_flags & RTF_UP))
		return;		/* cached route is still valid */
	ro->ro_rt = rtalloc1(&ro->ro_dst, RT_REPORT, ro->ro_tableid);
@


1.181
log
@Revert the addition of broadcast addresses, it apparently also corrupts
the tree.   Found by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.180 2014/08/21 10:07:07 mpi Exp $	*/
d794 2
a795 1
		if (rt->rt_flags & RTF_LOCAL && prio != RTP_LOCAL)
d1114 1
a1114 1
	if (flags & RTF_LOCAL)
d1132 6
d1188 1
a1188 1
	if (flags & RTF_LOCAL)
@


1.180
log
@If an ifa has as NULL ifp pointer then is should be considered as
invalid.  When such thing happens, it means that the address is no
longer configured on the system but still referenced by some routes.
So do not return such ifa in ifa_ifwithroute().

Fix a panic reported by Pierre Bardou.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.179 2014/08/19 12:49:41 mpi Exp $	*/
d794 1
a794 2
		if ((rt->rt_flags & (RTF_LOCAL | RTF_BROADCAST)) &&
		    prio != RTP_LOCAL)
d1113 1
a1113 1
	if (flags & (RTF_LOCAL|RTF_BROADCAST))
a1130 6

		/*
		 * A local route is created for every address configured
		 * on an interface, so use this information to notify
		 * userland that a new address has been added.
		 */
d1181 1
a1181 1
	if (flags & (RTF_LOCAL|RTF_BROADCAST))
d1232 1
a1232 1
	    (rt->rt_ifp->if_flags & IFF_LOOPBACK) == 0) {
a1234 7

		if ((ifa->ifa_ifp->if_flags & IFF_BROADCAST) &&
		    ifa->ifa_broadaddr)
			rt_ifa_add(ifa, RTF_UP | RTF_HOST | RTF_LLINFO |
			    RTF_BROADCAST, ifa->ifa_broadaddr);

	}
d1277 1
a1277 1
	    (rt->rt_ifp->if_flags & IFF_LOOPBACK) != 0) {
a1279 6

		if ((ifa->ifa_ifp->if_flags & IFF_BROADCAST) &&
		    ifa->ifa_broadaddr)
			rt_ifa_del(ifa, RTF_HOST | RTF_LLINFO | RTF_BROADCAST,
			    ifa->ifa_broadaddr);
	}
@


1.179
log
@When a local route entry is added for an ifa having a broadcast address,
also adds a broadcast entry flagged with RTF_BROADCAST.

Prior to this change broadcast entries were simple clonned ARP entries,
that would be deleted once their timer expired since they would always
be incomplete.

With this change they are now persistant and identifiable with a new flag.

Committing early to be able to deal with any potential fallout before we
start relying on this.

ok florian@@, mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.178 2014/08/14 09:01:47 mpi Exp $	*/
d683 2
a684 1
		if ((ifa = rt->rt_ifa) == NULL)
@


1.178
log
@No need for raw_cb.h
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.177 2014/08/12 13:52:08 mpi Exp $	*/
d793 2
a794 1
		if (rt->rt_flags & RTF_LOCAL && prio != RTP_LOCAL)
d1113 1
a1113 1
	if (flags & RTF_LOCAL)
d1131 6
d1187 1
a1187 1
	if (flags & RTF_LOCAL)
d1238 1
a1238 1
	    (rt->rt_ifp->if_flags & IFF_LOOPBACK) == 0)
d1241 7
d1290 1
a1290 1
	    (rt->rt_ifp->if_flags & IFF_LOOPBACK) != 0)
d1293 6
@


1.177
log
@route_cb is internal to rtsock.c
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.176 2014/08/11 11:59:05 mpi Exp $	*/
a119 1
#include <net/raw_cb.h>
@


1.176
log
@Put back the checks about RTF_LOCAL routes now that userland tools are
aware of them.

Original commit message was:

Reserve the highest route priority for kernel-managed routes and prevent
userland from playing with the local and broadcast flags.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.175 2014/07/29 12:18:41 mpi Exp $	*/
a134 1
struct	route_cb	   route_cb;
@


1.175
log
@Revert the checks about RTF_LOCAL routes.

Even if in the end we would like to be more strict about what userland
can do with kernel-managed route entries, most of the tools out there
are not yet ready for this.  Since RTF_LOCAL routes are for the moment
just like RTF_LLINFO routes without expire timer, allow userland tools
to remove/modify them.  In case they are missing, the good old cloning
mechanism will recreate what you need.

bluhm@@ and deraadt@@ agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.174 2014/07/12 18:44:22 tedu Exp $	*/
d789 8
@


1.174
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.173 2014/07/12 17:57:26 mpi Exp $	*/
a788 8

		/*
		 * Since RTP_LOCAL cannot be set by userland, make
		 * sure that local routes are only modified by the
		 * kernel.
		 */
		if (rt->rt_flags & RTF_LOCAL && prio != RTP_LOCAL)
			senderr(EINVAL);
@


1.173
log
@No INET6 in ramdisk, fix the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.172 2014/07/12 14:26:00 mpi Exp $	*/
d253 1
a253 1
			free(p, M_RTABLE);
d259 2
a260 2
			free(rt_tables, M_RTABLE);
			free(rt_tab2dom, M_RTABLE);
d415 1
a415 1
			free(rt->rt_llinfo, M_TEMP);
d417 1
a417 1
		free(rt_key(rt), M_RTABLE);
d445 1
a445 1
		free(ifa, M_IFADDR);
d895 1
a895 1
				free(rt_key(rt), M_RTABLE);
d932 1
a932 1
				free(rt_key(rt), M_RTABLE);
d1002 1
a1002 1
			free(rt_key(rt), M_RTABLE);
d1048 1
a1048 1
		free(old, M_RTABLE);
d1375 1
a1375 1
	free(rtq, M_RTABLE);
d1572 1
a1572 1
				free(p, M_TEMP);
@


1.172
log
@Always create a local route for every configured IPv4 address on the
machine and restore the original behavior of RTM_ADD and RTM_DELETE
by always generating one message per locally configured address.

This time, make sure the local route is removed during an address change,
since at least pppoe(4) do some funky magics with wildcard addresses that
might corrupt the routing tree, as found by naddy@@

Also do not add a local route if the specified address is 0.0.0.0, to
prevent a tree corruption, as found by guenther@@.

Putting this in now so that it gets tested, claudio@@ agrees.  Please
contact me if you find any route-related regression caused by this
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.171 2014/06/16 19:47:21 mpi Exp $	*/
d1219 1
d1225 1
d1257 1
d1263 1
@


1.171
log
@Revert "Always create a local route for every configured IPv4 address",
it introduces a regression with default routes & p2p interfaces.

Problem reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.170 2014/06/11 11:30:03 mpi Exp $	*/
d1132 2
a1133 1
		rt_newaddrmsg(RTM_ADD, ifa, error, nrt);
d1187 2
a1188 1
		rt_newaddrmsg(RTM_DELETE, ifa, error, nrt);
d1208 20
d1245 18
@


1.170
log
@Always create a local route for every configured IPv4 address on the
machine and restore the original behavior of RTM_ADD and RTM_DELETE
by always generating one message per locally configured address.

Tested by krw@@, jca@@ and florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.169 2014/06/11 11:29:01 mpi Exp $	*/
d1132 1
a1132 2
		if (flags & RTF_LOCAL)
			rt_newaddrmsg(RTM_ADD, ifa, error, nrt);
d1186 1
a1186 2
		if (flags & RTF_LOCAL)
			rt_newaddrmsg(RTM_DELETE, ifa, error, nrt);
@


1.169
log
@Flag local routes as such and make them use the highest possible
priority.

Tested by krw@@, jca@@ and florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.168 2014/05/27 19:38:15 claudio Exp $	*/
d1132 2
a1133 1
		rt_newaddrmsg(RTM_ADD, ifa, error, nrt);
d1187 2
a1188 1
		rt_newaddrmsg(RTM_DELETE, ifa, error, nrt);
@


1.168
log
@Big refactoring of the radix code (mainly rn_addroute but also part
of rn_delete was changed). The mpath code gets a much better
rn_mpath_next() function that allows looping through the dupedkey list
based on prio, any or only active routes. This solves the issues seen
with failed deletes of down routes.
Commit this now so that it gets tested. Both sthen@@ and blambert@@ agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.167 2014/05/27 09:39:58 mpi Exp $	*/
d1100 1
d1114 4
a1117 1
	error = rtrequest1(RTM_ADD, &info, RTP_CONNECTED, &nrt, rtableid);
d1146 1
d1181 4
a1184 1
	error = rtrequest1(RTM_DELETE, &info, RTP_CONNECTED, &nrt, rtableid);
d1210 2
a1211 1
		rt_ifa_add(ifa, RTF_UP| RTF_HOST | RTF_LLINFO, ifa->ifa_addr);
d1235 2
a1236 1
		rt_ifa_del(ifa,  RTF_HOST | RTF_LLINFO,  ifa->ifa_addr);
@


1.167
log
@Reserve the highest route priority for kernel-managed routes and prevent
userland from playing with the local and broadcast flags.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.166 2014/05/21 14:48:28 mpi Exp $	*/
d322 1
a322 1
		return;				 /* XXX */
d331 1
a331 1
		return;				 /* XXX */
d783 3
a785 1
			if (!rt)
a819 9
#ifndef SMALL_KERNEL
		if (rn_mpath_capable(rnh)) {
			if ((rn = rnh->rnh_lookup(info->rti_info[RTAX_DST],
			    info->rti_info[RTAX_NETMASK], rnh)) != NULL &&
			    rt_mpath_next((struct rtentry *)rn) == NULL)
				((struct rtentry *)rn)->rt_flags &= ~RTF_MPATH;
		}
#endif

a1006 12
#ifndef SMALL_KERNEL
		if (rn_mpath_capable(rnh) &&
		    (rn = rnh->rnh_lookup(info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_NETMASK], rnh)) != NULL &&
		    (rn = rn_mpath_prio(rn, prio)) != NULL) {
			if (rt_mpath_next((struct rtentry *)rn) == NULL)
				((struct rtentry *)rn)->rt_flags &= ~RTF_MPATH;
			else
				((struct rtentry *)rn)->rt_flags |= RTF_MPATH;
		}
#endif

a1617 8
}

struct rtentry *
rt_mpath_next(struct rtentry *rt)
{
	struct radix_node *rn = (struct radix_node *)rt;

	return ((struct rtentry *)rn_mpath_next(rn, 0));
@


1.166
log
@Fix IPsec route addition broken since the removal of the link-layer
addresses from the per-ifp list.

While here document why enc(4) needs a link-layer address, or at
least something that seems to be one.

Found the hard way and fix tested by naddy@@, ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.165 2014/04/29 11:58:29 mpi Exp $	*/
d787 9
@


1.165
log
@If you plan to write an obfuscated-by-design kernel / userland
interface, I suggest you have a look at the link-layer sockaddr
interface:

  /*
   * A Link-Level Sockaddr may specify the interface in one of two
   * ways: either by means of a system-provided index number (computed
   * anew and possibly differently on every reboot), or by a human-readable
   * string such as "il0" (for managerial convenience).
   [...]
   */

ifa_ifwithnet() was not only checking for the sdl_index in order
to get the corresponding ifp for AF_LINK sockaddr, it was also
iterating over all the addresses on your system!  But in this
case, the `address' field of "struct sockaddr_dl" is an interface
name set by link_addr(3).

How can this work?  Well because the kernel allocates an empty
`netmask' field for each interface's lladdr, so that you can
abuse a network comparison function to reimplement strcmp(3)...

So when the userland does not specify an interface index, try
harder to see if it passed an ifp name, but at least be explicit
and use ifunit().

Found the hard way by/ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.164 2014/04/25 10:41:09 mpi Exp $	*/
d177 8
a184 1
	return (TAILQ_FIRST(&encif->if_addrlist));
@


1.164
log
@Remove rti_ifp from rt_addrinfo, one less ifp pointer, say yay!

This pointer was only needed by rt_getifa() to find an address, so
turn it into a local variable.

ok henning@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.163 2014/04/23 09:30:57 mpi Exp $	*/
d661 2
d707 2
@


1.163
log
@You don't want to use ifa_ifwithroute(), it exists for to the routing
crazyness only.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.162 2014/04/22 12:35:00 mpi Exp $	*/
d694 1
d700 1
a700 1
	if (info->rti_ifp == NULL && info->rti_info[RTAX_IFP] != NULL) {
d704 1
a704 1
		info->rti_ifp = if_get(sdl->sdl_index);
d717 2
a718 2
		if (sa != NULL && info->rti_ifp != NULL)
			info->rti_ifa = ifaof_ifpforaddr(sa, info->rti_ifp);
a732 3
	if (info->rti_ifp == NULL)
		info->rti_ifp = ifa->ifa_ifp;

d829 4
a832 2
			 * The interface address at the cloning route
			 * is not longer referenced by an interface.
a839 1
		info->rti_ifp = rt->rt_ifp;
@


1.162
log
@ifa_ifwithroute() is the only magic place where an AF_LINK sockaddr
can be given to ifa_ifwithnet().

Handle this specific case directly and let ifa_ifwithnet() do only
one thing:  iterate on all the addresses of all the interfaces in a
given routing domain to return the most specific matching address.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.161 2014/04/11 00:06:30 krw Exp $	*/
d153 3
@


1.161
log
@Fix tree breakage.

With r1.160 route.c needs #include <net/if_dl.h> because bsd.rd and
friends don't pull in netmpls/mpls.h which is how bsd[.mp] get it.

ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.160 2014/04/10 13:55:55 mpi Exp $	*/
d653 11
a663 2
	if (ifa == NULL)
		ifa = ifa_ifwithnet(gateway, rtableid);
@


1.160
log
@Don't use ifa_ifwithnet() with obvious sockaddr_dl argument.  This
function should not deal with link-layer addresses and here there's
no reason to do it.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.159 2014/04/10 13:47:21 mpi Exp $	*/
d118 1
@


1.159
log
@Retire rtinit() an use rt_ifa_add(9) and rt_ifa_del(9) to manage
connected routes to prefixes/hosts.

Since the introduction of rt_ifa_addloop(9) and rt_ifa_delloop(9),
rtinit() was just a wrapper, so use the underlying functions
directly and document them.

Inputs from and ok mikeb@@, manpage tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.158 2014/04/03 08:22:10 mpi Exp $	*/
d686 6
a691 5
	if (info->rti_ifp == NULL && info->rti_info[RTAX_IFP] != NULL
	    && info->rti_info[RTAX_IFP]->sa_family == AF_LINK &&
	    (ifa = ifa_ifwithnet((struct sockaddr *)info->rti_info[RTAX_IFP],
	    rtid)) != NULL)
		info->rti_ifp = ifa->ifa_ifp;
@


1.158
log
@Introduce rt_ifa_{add,del}loop() to replace in6_{add,rem}loop().

Move these functions to a more generic place and make them reuse
existing code, they'll be soon used in IPv4 too.

Tested by Andr Lucas, Vigdis and sthen@@, thanks!

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.157 2014/03/27 10:39:23 mpi Exp $	*/
a152 3
int	rt_ifa_add(struct ifaddr *, int, struct sockaddr *);
int	rt_ifa_del(struct ifaddr *, int, struct sockaddr *);

a1076 22
}

/*
 * Set up a routing table entry, normally
 * for an interface.
 */
int
rtinit(struct ifaddr *ifa, int cmd, int flags)
{
	struct sockaddr		*dst;
	int error;

	KASSERT(cmd == RTM_ADD || cmd == RTM_DELETE);

	dst = flags & RTF_HOST ? ifa->ifa_dstaddr : ifa->ifa_addr;

	if (cmd == RTM_ADD)
		error = rt_ifa_add(ifa, flags, dst);
	else
		error = rt_ifa_del(ifa, flags, dst);

	return (error);
@


1.157
log
@Stop mixing interface address flags with routing entry ones.

Instead of always copying ifa_flags to the routing entry flags when
creating a route by calling rtinit(), explicitly pass the RTF_CLONING
flag when required.  This means ifa_flags are now *only* used to check
if an address has an associated route that was created by the kernel
auto-magically.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.156 2014/03/21 10:44:42 mpi Exp $	*/
d153 3
d1089 20
a1108 5
	struct rtentry		*rt;
	struct sockaddr		*dst, *deldst;
	struct mbuf		*m = NULL;
	struct rtentry		*nrt = NULL;
	int			 error;
a1109 1
	struct sockaddr_rtlabel	 sa_rl;
d1111 1
d1113 1
a1113 25
	dst = flags & RTF_HOST ? ifa->ifa_dstaddr : ifa->ifa_addr;
	if (cmd == RTM_DELETE) {
		if ((flags & RTF_HOST) == 0 && ifa->ifa_netmask) {
			m = m_get(M_DONTWAIT, MT_SONAME);
			if (m == NULL)
				return (ENOBUFS);
			deldst = mtod(m, struct sockaddr *);
			rt_maskedcopy(dst, deldst, ifa->ifa_netmask);
			dst = deldst;
		}
		if ((rt = rtalloc1(dst, 0, rtableid)) != NULL) {
			rt->rt_refcnt--;
			/* try to find the right route */
			while (rt && rt->rt_ifa != ifa)
				rt = (struct rtentry *)
				    ((struct radix_node *)rt)->rn_dupedkey;
			if (!rt) {
				if (m != NULL)
					(void) m_free(m);
				return (flags & RTF_HOST ? EHOSTUNREACH
							: ENETUNREACH);
			}
		}
	}
	bzero(&info, sizeof(info));
d1117 1
a1117 2
	if (cmd == RTM_ADD)
		info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
d1124 2
a1125 13
	error = rtrequest1(cmd, &info, RTP_CONNECTED, &nrt, rtableid);
	if (cmd == RTM_DELETE) {
		if (error == 0 && (rt = nrt) != NULL) {
			rt_newaddrmsg(cmd, ifa, error, nrt);
			if (rt->rt_refcnt <= 0) {
				rt->rt_refcnt++;
				rtfree(rt);
			}
		}
		if (m != NULL)
			(void) m_free(m);
	}
	if (cmd == RTM_ADD && error == 0 && (rt = nrt) != NULL) {
d1128 1
a1128 1
			printf("rtinit: wrong ifa (%p) was (%p)\n",
d1139 55
a1193 1
		rt_newaddrmsg(cmd, ifa, error, nrt);
d1195 3
d1199 41
@


1.156
log
@rt_timer* spring cleanup.

Rename and document rt_timer_count() into rt_timer_queue_count() to
be consistent with the other functions.  Remove unused argument from
rt_timer_queue_destroy(), clean the definitions and finally use the
same order in NAME and DESCRIPTION as requested by jmc@@.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.155 2014/03/18 10:47:34 mpi Exp $	*/
d1121 1
a1121 1
	info.rti_flags = flags | ifa->ifa_flags;
@


1.155
log
@Rename rt_gettable() into rtable_get(), swap its arguments to be
coherent with the existing rtable_* functions and document it.

While here fix some other manpage glitches pointed out by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.154 2014/03/12 12:03:55 mpi Exp $	*/
d147 1
d1236 1
a1236 1
rt_timer_queue_destroy(struct rttimer_queue *rtq, int destroy)
d1243 1
a1243 2
		if (destroy)
			RTTIMER_CALLOUT(r);
d1256 1
a1256 1
rt_timer_count(struct rttimer_queue *rtq)
@


1.154
log
@RTAX_IFP points to the "struct sockaddr_dl" corresponding to the
link-layer address of an interface.  This ugly structure is used
to export the interface's name and index, not only the link-layer
address as its name might suggest.

So instead reaching this descriptor by forcing and abusing the
position of the link-layer "struct ifaddr" in the per-interface
list, use the if_sadl pointer directly.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.153 2014/02/12 12:50:13 mpi Exp $	*/
d262 8
d336 1
a336 1
	rnh = rt_gettable(dst->sa_family, tableid);
d739 1
a739 1
	if ((rnh = rt_gettable(info->rti_info[RTAX_DST]->sa_family, tableid)) ==
a1320 8
struct radix_node_head *
rt_gettable(sa_family_t af, u_int id)
{
	if (id > rtbl_id_max)
		return (NULL);
	return (rt_tables[id] ? rt_tables[id][af2rtafidx[af]] : NULL);
}

d1326 1
a1326 1
	if ((rnh = rt_gettable(dst->sa_family, tableid)) == NULL)
d1465 1
a1465 1
			if ((rnh = rt_gettable(i, tid)) != NULL)
d1513 1
a1513 1
			if ((rnh = rt_gettable(i, tid)) != NULL) {
@


1.153
log
@Remove an old and unused define that should not be used.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.152 2014/02/12 10:00:38 mpi Exp $	*/
d412 1
a412 2
		info.rti_info[RTAX_IFP] =
		    TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
@


1.152
log
@Remove an old comment about bsdi4 and make it clear that netmasks are
not needed for routes to host.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.151 2014/01/23 10:16:30 mpi Exp $	*/
a132 2

#define	SA(p) ((struct sockaddr *)(p))
@


1.151
log
@Merge two chunks of code to inform listeners of a route change into a
new function, rt_sendmsg().  While here, in the v6 cases, pass the same
rtableid that was used for the request instead of dereferencing a pointer
after checking for it to be NULL.

ok krw@@ on a previous version, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.150 2014/01/22 06:28:09 claudio Exp $	*/
d1122 3
a1124 7
	/*
	 * XXX here, it seems that we are assuming that ifa_netmask is NULL
	 * for RTF_HOST.  bsdi4 passes NULL explicitly (via intermediate
	 * variable) when RTF_HOST is 1.  still not sure if i can safely
	 * change it to meet bsdi4 behavior.
	 */
	info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;
@


1.150
log
@Remove genmask support from the kernel. rtmsgs with RTA_GENMASK set will
now cause a EINVAL. The RTA_GENMASK and RTAX_GENMASK defines are kept for
compatibility reasons.
OK benno@@ and agreed by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.149 2014/01/10 14:29:08 tedu Exp $	*/
d348 1
a348 11
			bzero(&info, sizeof(info));
			info.rti_info[RTAX_DST] = rt_key(rt);
			info.rti_info[RTAX_NETMASK] = rt_mask(rt);
			info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
			if (rt->rt_ifp != NULL) {
				info.rti_info[RTAX_IFP] =
				    TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
				info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
			}
			rt_missmsg(RTM_ADD, &info, rt->rt_flags,
			    rt->rt_ifp, 0, tableid);
d402 18
@


1.149
log
@replace the rest of the obsolete radix macros
sprinkle 0 -> NULL where obvious
ok millert mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.148 2014/01/09 21:57:52 tedu Exp $	*/
d816 1
a816 2
		if ((info->rti_info[RTAX_NETMASK] = rt->rt_genmask) == NULL)
			info->rti_flags |= RTF_HOST;
@


1.148
log
@replace Bcopy macro with memmove and memcpy. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.147 2013/10/20 13:21:57 claudio Exp $	*/
d409 1
a409 1
		Free(rt_key(rt));
d856 1
a856 1
				Free(rt_key(rt));
d887 1
a887 1
			rt->rt_llinfo = (caddr_t)malloc(sizeof(struct rt_mpls),
d893 1
a893 1
				Free(rt_key(rt));
d963 1
a963 1
			Free(rt_key(rt));
d1009 1
a1009 1
		R_Malloc(new, caddr_t, dlen + glen);
d1021 1
a1021 1
		Free(old);
@


1.147
log
@rt_mpath_next() was always called with 0 in the last argument. So drop it.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.146 2013/10/17 16:27:43 bluhm Exp $	*/
d846 1
a846 1
			Bcopy(info->rti_info[RTAX_DST], ndst,
d1017 2
a1018 1
	Bcopy(gate, (rt->rt_gateway = (struct sockaddr *)(new + dlen)), glen);
d1020 1
a1020 1
		Bcopy(dst, new, dlen);
@


1.146
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.145 2013/08/28 06:58:57 mpi Exp $	*/
d776 1
a776 1
			    rt_mpath_next((struct rtentry *)rn, 0) == NULL)
d973 1
a973 1
			if (rt_mpath_next((struct rtentry *)rn, 0) == NULL)
d1551 1
a1551 1
rt_mpath_next(struct rtentry *rt, int all)
d1555 1
a1555 1
	return ((struct rtentry *)rn_mpath_next(rn, all));
@


1.145
log
@Remove unused argument from *rtrequest()

ok krw@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.144 2013/03/28 23:10:05 tedu Exp $	*/
a121 1
#include <netinet/in_var.h>
@


1.144
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.143 2013/03/28 16:45:16 tedu Exp $	*/
d784 1
a784 1
			ifa->ifa_rtrequest(RTM_DELETE, rt, info);
d928 1
a928 1
					    RTM_DELETE, *ret_nrt, NULL);
d934 1
a934 2
					ifa->ifa_rtrequest(RTM_ADD, *ret_nrt,
					    NULL);
d982 1
a982 1
			ifa->ifa_rtrequest(req, rt, info);
d1140 1
a1140 1
				rt->rt_ifa->ifa_rtrequest(RTM_DELETE, rt, NULL);
d1146 1
a1146 1
				ifa->ifa_rtrequest(RTM_ADD, rt, NULL);
@


1.143
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.142 2013/03/07 09:03:16 mpi Exp $	*/
d109 1
@


1.142
log
@Remove the IFAFREE() macro, the ifafree() function it was calling already
check for the reference counter.

ok mikeb@@, miod@@, pelikan@@, kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.141 2012/09/20 20:53:12 blambert Exp $	*/
a105 1
#include <sys/proc.h>
@


1.141
log
@Fix a pair of typos in comments.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.140 2012/09/19 16:14:01 blambert Exp $	*/
d404 1
a404 1
			IFAFREE(ifa);
d929 1
a929 1
				IFAFREE((*ret_nrt)->rt_ifa);
d960 1
a960 1
			IFAFREE(ifa);
d1142 1
a1142 1
			IFAFREE(rt->rt_ifa);
@


1.140
log
@Make rt_lookup return a pointer to an rtentry struct instead of
to a radix_node struct.

The radix tree pushdown continues.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.139 2012/09/19 12:35:07 blambert Exp $	*/
d1541 1
a1541 1
				/* take route done */
@


1.139
log
@More radix internals pushdown; place rn_mpath_next, which accepts and
returns radix_node pointers, inside a new rt_mpath_next, which accepts
and returns rtentry pointers, and start using that instead.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.138 2012/09/18 08:16:33 blambert Exp $	*/
d1322 1
a1322 1
struct radix_node *
d1330 1
a1330 1
	return (rnh->rnh_lookup(dst, mask, rnh));
@


1.138
log
@Wrap rtable_add() and rtable_l2set() calls inside ifioctl() inside softnet,
as functions that modify routing information shouldn't be interruptable by
network traffic.

Also make sure that both of those functions assert that they are called
at softnet. I'm reasonably sure that there shouldn't be any, but if there
is any codepath that was missed, we're going to be here for another 4 days
to deal with any fallout.

While here, move the multitude of "int s" declarations inside ifioctl to
the beginning of the function.

okay claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.137 2012/07/13 20:27:25 claudio Exp $	*/
d777 1
a777 1
			    rn_mpath_next(rn, 0) == NULL)
d975 1
a975 1
			if (rn_mpath_next(rn, 0) == NULL)
d1550 8
@


1.137
log
@Use NULL instead of 0 in pointer context. approvedz blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.136 2012/05/09 06:50:55 markus Exp $	*/
d228 1
a228 1
rtable_add(u_int id)	/* must be called at splsoftnet */
d232 2
d276 2
@


1.136
log
@backout 1.134 since it introduced a use-after-free for routing entries;
ok blambert@@ sthen@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.135 2011/12/06 12:58:34 blambert Exp $	*/
d645 1
a645 1
			return (0);
@


1.135
log
@Remove needless temporary variable for greater clarity.

testing sthen@@
ok sthen@@ henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.134 2011/12/06 12:53:26 blambert Exp $	*/
d554 1
a554 1
	error = rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, tableid);
d558 5
@


1.134
log
@don't duplicate rtfree actions taken by rtrequest1() in rtdeletemsg()

testing sthen@@
ok sthen@@ henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.133 2011/12/06 12:48:51 blambert Exp $	*/
d994 1
a994 1
rt_setgate(struct rtentry *rt0, struct sockaddr *dst, struct sockaddr *gate,
a998 1
	struct rtentry	*rt = rt0;
d1016 1
a1016 3
		rt = rt->rt_gwroute;
		RTFREE(rt);
		rt = rt0;
@


1.133
log
@simplify the somewhat-tangled conditional maze in rt_getifa()

testing sthen@@
ok sthen@@ henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.132 2011/07/22 13:05:29 henning Exp $	*/
d554 1
a554 1
	error = rtrequest1(RTM_DELETE, &info, rt->rt_priority, &rt, tableid);
a557 5
	/* Adjust the refcount */
	if (error == 0 && rt->rt_refcnt <= 0) {
		rt->rt_refcnt++;
		rtfree(rt);
	}
@


1.132
log
@fix typos, martin pelikan
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.131 2011/07/04 04:29:17 claudio Exp $	*/
a663 1
	int		 error = 0;
d697 8
a704 6
	if ((ifa = info->rti_ifa) != NULL) {
		if (info->rti_ifp == NULL)
			info->rti_ifp = ifa->ifa_ifp;
	} else
		error = ENETUNREACH;
	return (error);
@


1.131
log
@LINK_STATE cleanup. It is no longer needed to special case carp(4).
LINK_STATE_IS_UP() does the trick now for all cases.
OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.130 2011/04/04 16:06:13 blambert Exp $	*/
d200 1
a200 1
			(*table)[i]->rnh_rtabelid = id;
@


1.130
log
@previous commit replaced a malloc(new) with malloc(sizeof(*new)) which
leads to corrupted memory; backout to await a better fix
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.129 2011/04/04 14:08:15 blambert Exp $	*/
d857 2
a858 3
			if ((LINK_STATE_IS_UP(ifa->ifa_ifp->if_link_state) ||
			    ifa->ifa_ifp->if_link_state == LINK_STATE_UNKNOWN)
			    && ifa->ifa_ifp->if_flags & IFF_UP)
d1530 1
a1530 2
		if ((LINK_STATE_IS_UP(ifp->if_link_state) ||
		    ifp->if_link_state == LINK_STATE_UNKNOWN) &&
@


1.129
log
@stop using the stupid R_Malloc/Bcopy/Free macros, and just start using
malloc/bcopy/free, the way He Who Must Not Be Named intended.

"yes please" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.128 2010/11/16 19:39:17 bluhm Exp $	*/
d406 1
a406 1
		free(rt_key(rt), M_RTABLE);
d842 1
a842 1
			bcopy(info->rti_info[RTAX_DST], ndst,
d852 1
a852 1
				free(rt_key(rt), M_RTABLE);
d884 1
a884 1
			rt->rt_llinfo = malloc(sizeof(struct rt_mpls),
d890 1
a890 1
				free(rt_key(rt), M_RTABLE);
d961 1
a961 1
			free(rt_key(rt), M_RTABLE);
d1008 2
a1009 1
		if ((new = malloc(sizeof(*new), M_RTABLE, M_NOWAIT)) == NULL)
d1016 1
a1016 1
	bcopy(gate, (rt->rt_gateway = (struct sockaddr *)(new + dlen)), glen);
d1018 2
a1019 2
		bcopy(dst, new, dlen);
		free(old, M_RTABLE);
@


1.128
log
@If the interface address referenced by a cloning route did not point
to an interface any more, the kernel crashed with a null pointer
dereference.  This situation could be created by a strange sequence
of route and ifconfig commands.
Now when a cloning route references a stale interface address and
rtrequest1(RTM_RESOLVE) has to create a cloned route, it does a
lookup for a valid interface address with the same ip address.  The
new interface address and its interface are used for the new cloned
route and they replace the old ones at the cloning route.
ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.127 2010/08/25 14:07:24 claudio Exp $	*/
d406 1
a406 1
		Free(rt_key(rt));
d842 1
a842 1
			Bcopy(info->rti_info[RTAX_DST], ndst,
d852 1
a852 1
				Free(rt_key(rt));
d884 1
a884 1
			rt->rt_llinfo = (caddr_t)malloc(sizeof(struct rt_mpls),
d890 1
a890 1
				Free(rt_key(rt));
d961 1
a961 1
			Free(rt_key(rt));
d1008 1
a1008 2
		R_Malloc(new, caddr_t, dlen + glen);
		if (new == NULL)
d1015 1
a1015 1
	Bcopy(gate, (rt->rt_gateway = (struct sockaddr *)(new + dlen)), glen);
d1017 2
a1018 2
		Bcopy(dst, new, dlen);
		Free(old);
@


1.127
log
@Let rtable_add() return usefull errnos so that the ioctl handler and the
rtsock code can return a more reasonable error to the user.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.126 2010/08/24 15:50:16 claudio Exp $	*/
d795 14
a808 1
		ifa = rt->rt_ifa;
d816 1
a816 1
		goto makeroute;
d819 1
a819 1
		if (info->rti_ifa == 0 && (error = rt_getifa(info, tableid)))
a821 1
makeroute:
d913 20
@


1.126
log
@Only do the link state checking and RTF_UP dance if the routing table is
rn_mpath_capable(). Move code down into the mpath specific block.
Not all routing tables support multipath and therefor priorities.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.125 2010/07/09 16:58:06 reyk Exp $	*/
d188 1
a188 1
		return (-1);
d223 1
a223 1
	if (rtable_add(0) == -1)
d233 1
a233 1
		return (-1);
d240 1
a240 1
			return (-1);
d243 1
a243 1
			return (-1);
d257 1
a257 1
		return (-1);
a260 16
}

void
rtable_addif(struct ifnet *ifp, u_int id)
{
	/* make sure that the routing table exists */
	if (!rtable_exists(id)) {
		if (rtable_add(id) == -1)
			panic("rtable_addif: rtable_add");
	}
	if (id != rtable_l2(id)) {
		/* XXX we should probably flush the table */
		rtable_l2set(id, id);
	}

	ifp->if_rdomain = id;
@


1.125
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.124 2010/07/09 15:44:20 claudio Exp $	*/
a834 8
		if ((LINK_STATE_IS_UP(ifa->ifa_ifp->if_link_state) ||
		    ifa->ifa_ifp->if_link_state == LINK_STATE_UNKNOWN) &&
		    ifa->ifa_ifp->if_flags & IFF_UP)
			rt->rt_flags |= RTF_UP;
		else {
			rt->rt_flags &= ~RTF_UP;
			rt->rt_priority |= RTP_DOWN;
		}
d849 20
a868 9
		/* do not permit exactly the same dst/mask/gw pair */
		if (rn_mpath_capable(rnh) &&
		    rt_mpath_conflict(rnh, rt, info->rti_info[RTAX_NETMASK],
		    info->rti_flags & RTF_MPATH)) {
			if (rt->rt_gwroute)
				rtfree(rt->rt_gwroute);
			Free(rt_key(rt));
			pool_put(&rtentry_pool, rt);
			senderr(EEXIST);
@


1.124
log
@Add the rtableid to struct rttimer and therefor  make it available to
the callback functions. This fixes a problem where dynamic routes in
different tables would not get deleted because the callback was doing
the remove on the wrong table.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.123 2010/07/02 00:20:49 jsg Exp $	*/
d132 1
a132 1
struct ifaddr	*encap_findgwifa(struct sockaddr *);
d168 1
a168 1
encap_findgwifa(struct sockaddr *gw)
d172 1
a172 1
	if ((encif = enc_getif(0, 0)) == NULL)
d627 1
a627 1
		return (encap_findgwifa(gateway));
@


1.123
log
@remove prototype of okaytoclone, which got removed in 1.117
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.122 2010/07/01 02:09:45 reyk Exp $	*/
d1154 1
a1154 1
		    r->rtt_rt->rt_priority, NULL, 0 /* XXX */);	\
d1252 1
a1252 1
    struct rttimer *), struct rttimer_queue *queue)
d1286 1
@


1.122
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.121 2010/06/29 21:28:37 reyk Exp $	*/
a150 1
int	okaytoclone(u_int, int);
@


1.121
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.120 2010/06/28 18:50:37 claudio Exp $	*/
d173 1
a173 1
	if ((encif = enc_getif(0)) == NULL)
@


1.120
log
@Add the rtable id as an argument to rn_walktree(). Functions like
rt_if_remove_rtdelete() need to know the table id to be able to correctly
remove nodes.
Problem found by Andrea Parazzini and analyzed by Martin Pelikn.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.119 2010/06/04 11:05:13 blambert Exp $	*/
d171 6
a176 1
	return (TAILQ_FIRST(&encif[0].sc_if.if_addrlist));
d262 16
@


1.119
log
@rt_timer_queue_destroy() did not actually destroy, leading to a potential
memory leak due to misleading nomenclature. Change it to actually destroy,
not just clean, the the rt_timer_queue passed to it and adjust the correct
caller accordingly (i.e., no need to free the mem on our own now).

As a bonus, this gets rid of one of the ridiculous R_Malloc/Bzero/Free
cycles, and lets us sneak another bzero -> M_ZERO conversion in.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.118 2010/05/19 13:09:09 claudio Exp $	*/
d150 1
a150 1
int	rtable_init(struct radix_node_head ***);
d152 1
a152 1
int	rtflushclone1(struct radix_node *, void *);
d154 1
a154 1
int	rt_if_remove_rtdelete(struct radix_node *, void *);
d176 1
a176 1
rtable_init(struct radix_node_head ***table)
d180 1
d193 6
d203 1
a203 1
route_init()
d256 1
a256 1
	return (rtable_init(&rt_tables[id]));
d563 1
a563 1
rtflushclone1(struct radix_node *rn, void *arg)
d570 1
a570 1
		rtdeletemsg(rt, 0);
d1440 1
a1440 1
rt_if_remove_rtdelete(struct radix_node *rn, void *vifp)
d1448 1
a1448 1
		if (rtdeletemsg(rt, ifp->if_rdomain /* XXX wrong */) == 0 && cloning)
d1485 1
a1485 1
rt_if_linkstate_change(struct radix_node *rn, void *arg)
@


1.118
log
@Require RTF_MPLS to be set when a mpls route is added or changed.  To remove
only the MPLS bits from a route set rtm_fmask to RTF_MPLS.  Additionally check
if the nexthop is modified and in that case always remove the MPLS info since
the path changed.  This change makes life in userland a lot easier since the
routing daemons normaly don't know about MPLS and until now they destroyed
MPLS information when issuing RTM_CHANGEs.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.117 2010/05/07 13:33:16 claudio Exp $	*/
d1163 1
a1163 2
	R_Malloc(rtq, struct rttimer_queue *, sizeof *rtq);
	if (rtq == NULL)
a1164 1
	Bzero(rtq, sizeof *rtq);
d1198 1
a1198 4

	/*
	 * Caller is responsible for freeing the rttimer_queue structure.
	 */
@


1.117
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.116 2010/03/20 10:43:11 blambert Exp $	*/
d850 3
a852 2
		if (info->rti_info[RTAX_SRC] != NULL ||
		    info->rti_info[RTAX_DST]->sa_family == AF_MPLS) {
d879 2
a880 1
		}
@


1.116
log
@Don't leak memory when resizing routing table array

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.115 2010/02/09 16:31:14 claudio Exp $	*/
d283 3
a285 2
#include "pf.h"
#if NPF > 0
d287 1
a287 1
rtalloc_noclone(struct route *ro, int howstrict)
d290 3
a292 55
		return;		/* XXX */
	ro->ro_rt = rtalloc2(&ro->ro_dst, 1, howstrict);
}

int
okaytoclone(u_int flags, int howstrict)
{
	if (howstrict == ALL_CLONING)
		return (1);
	if (howstrict == ONNET_CLONING && !(flags & RTF_GATEWAY))
		return (1);
	return (0);
}

struct rtentry *
rtalloc2(struct sockaddr *dst, int report, int howstrict)
{
	struct radix_node_head	*rnh;
	struct rtentry		*rt;
	struct radix_node	*rn;
	struct rtentry		*newrt = 0;
	struct rt_addrinfo	 info;
	int			 s = splnet(), err = 0, msgtype = RTM_MISS;

	bzero(&info, sizeof(info));
	info.rti_info[RTAX_DST] = dst;

	rnh = rt_gettable(dst->sa_family, 0);
	if (rnh && (rn = rnh->rnh_matchaddr((caddr_t)dst, rnh)) &&
	    ((rn->rn_flags & RNF_ROOT) == 0)) {
		newrt = rt = (struct rtentry *)rn;
		if (report && (rt->rt_flags & RTF_CLONING) &&
		    okaytoclone(rt->rt_flags, howstrict)) {
			err = rtrequest1(RTM_RESOLVE, &info, RTP_DEFAULT,
			    &newrt, 0);
			if (err) {
				newrt = rt;
				rt->rt_refcnt++;
				goto miss;
			}
			if ((rt = newrt) && (rt->rt_flags & RTF_XRESOLVE)) {
				msgtype = RTM_RESOLVE;
				goto miss;
			}
		} else
			rt->rt_refcnt++;
	} else {
		rtstat.rts_unreach++;
miss:
		if (report) {
			rt_missmsg(msgtype, &info, 0, NULL, err, 0);
		}
	}
	splx(s);
	return (newrt);
a293 1
#endif /* NPF > 0 */
a294 3
/*
 * Packet routing routines.
 */
d300 1
a300 1
	ro->ro_rt = rtalloc1(&ro->ro_dst, 1, 0);
d304 1
a304 1
rtalloc1(struct sockaddr *dst, int report, u_int tableid)
d320 2
a321 1
		if (report && (rt->rt_flags & RTF_CLONING)) {
d356 1
a356 1
		if (report && dst->sa_family != PF_KEY) {
d981 1
a981 1
		rt->rt_gwroute = rtalloc1(gate, 1, rtable_l2(tableid));
@


1.115
log
@Correctly track RTF_UP on RTM_CHANGE. Since the interface can change
rt_if_linkstate_change() needs to be rerun for this route and the
resulting rt_flags need to copied to the rtm_flags for userland.
Problem found and diagnosed by Doran Mori. OK henning@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.114 2009/11/03 10:59:04 claudio Exp $	*/
d238 1
@


1.114
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.113 2009/10/26 17:14:24 mk Exp $	*/
a154 3
#ifndef SMALL_KERNEL
int	rt_if_linkstate_change(struct radix_node *, void *);
#endif
@


1.113
log
@Replace pool_get() + bzero() with pool_get(..., PR_ZERO).

`OK' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.112 2009/10/10 22:08:26 dms Exp $	*/
d143 1
d222 1
a222 1
	void	*p;
d229 1
d233 4
d239 1
d243 1
d250 1
d254 16
d644 1
a644 1
    u_int rdomain)
d669 1
a669 1
			ifa = ifa_ifwithdstaddr(dst, rdomain);
d671 1
a671 1
			ifa = ifa_ifwithaddr(gateway, rdomain);
d678 1
a678 1
		ifa = ifa_ifwithdstaddr(gateway, rdomain);
d681 1
a681 1
		ifa = ifa_ifwithnet(gateway, rdomain);
d683 1
a683 1
		struct rtentry	*rt = rtalloc1(gateway, 0, rdomain);
d706 1
a706 1
rt_getifa(struct rt_addrinfo *info, u_int rdom)
d718 1
a718 1
	    rdom)) != NULL)
d722 1
a722 1
		info->rti_ifa = ifa_ifwithaddr(info->rti_info[RTAX_IFA], rdom);
d738 1
a738 1
			    rdom);
d741 1
a741 1
			    sa, sa, rdom);
d851 1
a851 2
		if (info->rti_ifa == 0 && (error = rt_getifa(info,
		    /* XXX wrong because only rdomains allowed */ tableid)))
d1036 2
a1037 1
		rt->rt_gwroute = rtalloc1(gate, 1, tableid);
@


1.112
log
@fix mbuf leak in rtinit()
the mbuf got leaked when detaching an interface, spotted by theo.
fixed by me, diff refined by theo

eyeballed by claudio@@
'go ahead, commit this' by theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.111 2009/09/01 06:10:01 claudio Exp $	*/
d831 1
a831 1
		rt = pool_get(&rtentry_pool, PR_NOWAIT);
a833 1
		Bzero(rt, sizeof(*rt));
d1285 1
a1285 1
	r = pool_get(&rttimer_pool, PR_NOWAIT);
a1287 1
	Bzero(r, sizeof(*r));
@


1.111
log
@Make rtinit() cope when there is a more specific route available then
the one planned to remove. Do this by going through the dupedkey list
looking for the right ifa. Problem found by and OK dlg, OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.110 2009/07/28 20:54:57 claudio Exp $	*/
d1107 7
a1113 5
	if (cmd == RTM_DELETE && error == 0 && (rt = nrt) != NULL) {
		rt_newaddrmsg(cmd, ifa, error, nrt);
		if (rt->rt_refcnt <= 0) {
			rt->rt_refcnt++;
			rtfree(rt);
d1115 2
@


1.110
log
@Plug a memory leak when calling rtable_add(0) multiple times. Fixing this
even though adding an already existing routing table is not allowed.
Leak found by blambert@@, fix by myself. OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.109 2009/06/05 00:05:22 claudio Exp $	*/
d1078 5
a1082 1
			if (rt->rt_ifa != ifa) {
@


1.109
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.108 2009/05/31 04:07:03 claudio Exp $	*/
d231 1
a231 1
		if (id > 0) {
@


1.108
log
@Reenable interface state tracking now that I found and fixed the cause of
the rtfree panic seen by some people.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.107 2009/05/26 08:29:44 reyk Exp $	*/
d254 1
a254 1
	if (rt_tables[id] == NULL)	/* should not happen */
d453 1
a453 1
    struct rtentry **rtp)
d465 1
a465 1
	if ((ifa = ifa_ifwithnet(gateway)) == NULL) {
d470 1
a470 1
	rt = rtalloc1(dst, 0, 0);
d483 1
a483 1
	else if (ifa_ifwithaddr(gateway) != NULL)
d516 2
a517 1
			error = rtrequest1(RTM_ADD, &info, RTP_DEFAULT, &rt, 0);
d529 1
a529 1
			rt_setgate(rt, rt_key(rt), gateway, 0);
d550 1
a550 1
	rt_missmsg(RTM_REDIRECT, &info, flags, ifp, error, 0);
d618 2
a619 1
ifa_ifwithroute(int flags, struct sockaddr *dst, struct sockaddr *gateway)
d644 1
a644 1
			ifa = ifa_ifwithdstaddr(dst);
d646 1
a646 1
			ifa = ifa_ifwithaddr(gateway);
d653 1
a653 1
		ifa = ifa_ifwithdstaddr(gateway);
d656 1
a656 1
		ifa = ifa_ifwithnet(gateway);
d658 1
a658 1
		struct rtentry	*rt = rtalloc1(gateway, 0, 0);
d681 1
a681 1
rt_getifa(struct rt_addrinfo *info)
d692 2
a693 2
	    (ifa = ifa_ifwithnet((struct sockaddr *)info->rti_info[RTAX_IFP]))
	    != NULL)
d697 1
a697 1
		info->rti_ifa = ifa_ifwithaddr(info->rti_info[RTAX_IFA]);
d712 2
a713 1
			    info->rti_info[RTAX_GATEWAY]);
d716 1
a716 1
			    sa, sa);
d826 2
a827 1
		if (info->rti_ifa == 0 && (error = rt_getifa(info)))
d1064 1
d1076 1
a1076 1
		if ((rt = rtalloc1(dst, 0, 0)) != NULL) {
d1102 1
a1102 1
	error = rtrequest1(cmd, &info, RTP_CONNECTED, &nrt, 0);
d1297 2
d1441 1
d1444 8
a1451 5
	for (i = 1; i <= AF_MAX; i++)
		if ((rnh = rt_gettable(i, 0)) != NULL)
			while ((*rnh->rnh_walktree)(rnh,
			    rt_if_remove_rtdelete, ifp) == EAGAIN)
				;	/* nothing */
d1469 1
a1469 1
		if (rtdeletemsg(rt, 0) == 0 && cloning)
@


1.107
log
@inherit the route label on cloned routes

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.106 2009/05/18 20:37:13 bluhm Exp $	*/
a836 1
#if 0
a844 1
#endif
@


1.106
log
@The routing table index rtableid has type unsigned int in the routing
code.  In pf rtableid == -1 means don't change the rtableid because
of this rule.  So it has to be signed int there.  Before the value
is passed from pf to route it is always checked to be >= 0.  Change
the type to int in pf and to u_int in netinet and netinet6 to make
the checks work.  Otherwise -1 may be used as an array index and
the kernel crashes.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.105 2009/03/15 19:40:41 miod Exp $	*/
d733 1
a733 1
	struct sockaddr_rtlabel	*sa_rl;
d818 2
a1061 1
	const char		*label;
d1089 2
a1090 8
	if (ifa->ifa_ifp->if_rtlabelid &&
	    (label = rtlabel_id2name(ifa->ifa_ifp->if_rtlabelid)) != NULL) {
		bzero(&sa_rl, sizeof(sa_rl));
		sa_rl.sr_len = sizeof(sa_rl);
		sa_rl.sr_family = AF_UNSPEC;
		strlcpy(sa_rl.sr_label, label, sizeof(sa_rl.sr_label));
		info.rti_info[RTAX_LABEL] = (struct sockaddr *)&sa_rl;
	}
d1394 16
@


1.105
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.104 2009/02/27 13:15:40 claudio Exp $	*/
d1303 1
a1303 1
rt_lookup(struct sockaddr *dst, struct sockaddr *mask, int tableid)
@


1.104
log
@Do not check the link state when installing a route. This bit was missing in
the backout/disabling of the route link state tracking done a few days ago.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.103 2009/02/03 16:42:54 michele Exp $	*/
d462 1
a462 1
	splassert(IPL_SOFTNET);
@


1.103
log
@Use our own flags to set the operations and not RTF_PROTOX.
Switch the padding field into a MPLS one in rt_msghdr to store
relevant informations.

OK claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.102 2009/01/28 22:18:44 michele Exp $	*/
d835 1
d844 1
@


1.102
log
@Get rid of the ugly rtentry hack.

We can now act as edge node and allow ipv4 packets to
enter a Label Switched Path and not just forwarding
MPLS packets.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.101 2009/01/08 12:47:45 michele Exp $	*/
d900 1
a900 2
			rt_mpls->mpls_operation = rt->rt_flags &
			    (MPLS_OP_PUSH | MPLS_OP_POP | MPLS_OP_SWAP);
@


1.101
log
@Fix sockaddr_mpls structure.
Now it contains just the label as it must be.

This introduces a ugly hack in rtentry that will be removed
as soon as possible.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.100 2008/12/12 22:07:33 claudio Exp $	*/
d422 4
d829 1
d831 1
d876 5
a880 1
		if (info->rti_info[RTAX_SRC] != NULL) {
d883 23
a905 1
			rt->rt_mpls = sa_mpls->smpls_label;
@


1.100
log
@Introduce a if_priority that will be added to RTP_STATIC when routes are
added without an expilict priority. This allows to specify less prefered
interfaces that will only take over if the primary interface loses link.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.99 2008/11/24 12:53:53 claudio Exp $	*/
d124 4
d730 3
d868 8
@


1.99
log
@Implement link-state tracking on the routing table. Routes to interfaces
which are considered down will no be marked ~RTF_UP and so multipath routing
will start to work as expected and not pump 50% of the traffic to nirvana.
Most of the magic happens in rn_mpath_reprio() which fiddles with the
routing table internals. The rest is more straight forward.
get it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.98 2008/11/21 18:01:30 claudio Exp $	*/
d819 2
@


1.98
log
@Change rn_mpath_next() to be able to walk over the full multipath list
not only over routes of the same prio. This makes it possible to modify
rt_mpath_matchgate() so that if only gateway is specified without a specific
priority it will scan the full list and not only the first routes.
This is also needed for upcoming link state tracking.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.97 2008/09/10 14:01:23 blambert Exp $	*/
a146 1
int	rtdeletemsg(struct rtentry *, u_int);
d150 3
d404 2
d818 1
a818 1
		rt->rt_flags = RTF_UP | info->rti_flags;
d820 8
d1410 53
@


1.97
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.96 2008/08/07 21:32:08 claudio Exp $	*/
d774 1
a774 1
			    rn_mpath_next(rn) == NULL)
d890 1
a890 1
			if (rn_mpath_next(rn) == NULL)
@


1.96
log
@Remove workaround used for the 4.4 release. More route prio stuff is comming
soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.95 2008/08/01 05:08:07 henning Exp $	*/
d1113 1
a1113 1
	timeout_add(&rt_timer_timeout, hz);	/* every second */
d1280 1
a1280 1
	timeout_add(to, hz);		/* every second */
@


1.95
log
@force route priority to RTP_DEFAULT unconditionally, effectively disabling
route prios. playing safe for 4.4-release, as not all parts of the system
deal correctly with route prios yet. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.94 2008/07/28 13:25:10 claudio Exp $	*/
a722 3

	/* XXX hack for 4.4-release */
	prio = RTP_DEFAULT;
@


1.94
log
@Fix the tracking of RTF_MPATH. Until now the magic happend on the first route
and not on the routes with the right prio. So pick up the correct route by
calling rn_mpath_prio() first.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.93 2008/06/08 19:12:28 claudio Exp $	*/
d723 3
@


1.93
log
@First minimal cleanup of routing code, kill rtrequest() it got replaced with
rtrequest1() everywhere now. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.92 2008/05/09 15:48:15 claudio Exp $	*/
d888 2
a889 1
		    info->rti_info[RTAX_NETMASK], rnh)) != NULL) {
@


1.92
log
@replace rtrequest() with corresponding rtrequest1() replacement.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.91 2008/05/09 07:33:13 henning Exp $	*/
a664 15

int
rtrequest(int req, struct sockaddr *dst, struct sockaddr *gateway,
    struct sockaddr *netmask, int flags, struct rtentry **ret_nrt,
    u_int tableid)
{
	struct rt_addrinfo	info;

	bzero(&info, sizeof(info));
	info.rti_flags = flags;
	info.rti_info[RTAX_DST] = dst;
	info.rti_info[RTAX_GATEWAY] = gateway;
	info.rti_info[RTAX_NETMASK] = netmask;
	return (rtrequest1(req, &info, RTP_DEFAULT/*XXX*/, ret_nrt, tableid));
}
@


1.91
log
@when cloning, copy the priority from the parent to the cloned route,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.90 2008/05/07 05:14:21 claudio Exp $	*/
d284 3
d293 1
a293 1
			err = rtrequest(RTM_RESOLVE, dst, SA(0), SA(0), 0,
a309 2
			bzero((caddr_t)&info, sizeof(info));
			info.rti_info[RTAX_DST] = dst;
d339 3
d347 2
a348 2
			err = rtrequest(RTM_RESOLVE, dst, SA(NULL),
			    SA(NULL), 0, &newrt, tableid);
d1099 5
a1103 3
		rtrequest((int) RTM_DELETE,			\
		    (struct sockaddr *)rt_key(r->rtt_rt),	\
		    0, 0, 0, 0, 0);				\
@


1.90
log
@Implement routing priorities. Every route inserted has a priority assigned
and the one route with the lowest number wins. This will be used by the
routing daemons to resolve the synchronisations issue in case of conflicts.
The nasty bits of this are in the multipath code. If no priority is specified
the kernel will choose an appropriate priority.

Looked at by a few people at n2k8 code is much older
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.89 2008/05/07 02:45:24 claudio Exp $	*/
d868 1
@


1.89
log
@Redo rev 1.8 but this time with an additional fix to solve the dhclient crashes
seen by krw. This is a prerequisite for upcomming routing priorities:
Always compare the nexthop if one is specified even if it is a non-multipath
route. This mostly affects "route delete" and it will not remove the last
route if previous delete is redone. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.88 2008/05/05 13:06:37 henning Exp $	*/
d500 1
a500 1
			error = rtrequest1(RTM_ADD, &info, &rt, 0);
d557 1
a557 1
	error = rtrequest1(RTM_DELETE, &info, &rt, tableid);
d674 1
a674 1
	return (rtrequest1(req, &info, ret_nrt, tableid));
d723 2
a724 2
rtrequest1(int req, struct rt_addrinfo *info, struct rtentry **ret_nrt,
    u_int tableid)
d753 1
a753 1
			    info->rti_info[RTAX_GATEWAY]);
d826 1
d872 2
a873 1
		    (caddr_t)info->rti_info[RTAX_NETMASK], rnh, rt->rt_nodes);
d880 1
a880 1
				    rnh, rt->rt_nodes);
d1051 1
a1051 1
	error = rtrequest1(cmd, &info, &nrt, 0);
d1394 1
a1394 2
		if (rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway,
		    rt_mask(rt), 0, NULL, 0) == 0 && cloning)
@


1.88
log
@in rt_gettable, we unfortunately have to check for rt_tables[id] != NULL
before returning rt_tables[id][af2rtafidx[af]. when you created tables
and left a hole (0 and 2 exist, 1 does not) it is possible to hit that
case. issue found & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.87 2008/01/05 19:08:19 henning Exp $	*/
d1031 2
a1032 1
	info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
@


1.87
log
@make sure all callers of rtlabel_id2name check for a null return value.
all the original ones did, the recently added ones for labels per interface
didn't. no cookie for reyk ;(
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.86 2007/09/17 05:06:20 pyr Exp $	*/
d1241 1
a1241 1
	return (rt_tables[id][af2rtafidx[af]]);
@


1.86
log
@Do not take wild guesses at how if_enc's internal works, include
net/if_enc.h instead.
ok todd@@ and probably claudio who's in the train.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.85 2007/09/15 16:43:51 henning Exp $	*/
d1032 2
a1033 2
	if (ifa->ifa_ifp->if_rtlabelid) {
		label = rtlabel_id2name(ifa->ifa_ifp->if_rtlabelid);
@


1.85
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.84 2007/06/14 18:31:49 reyk Exp $	*/
d126 1
a127 1
extern struct ifnet encif;
d167 1
a167 1
	return (TAILQ_FIRST(&encif.if_addrlist));
@


1.84
log
@Add a new "rtlabel" option to ifconfig. It allows to specify a route label
which will be used for new interface routes. For example,
	ifconfig em0 10.1.1.0 255.255.255.0 rtlabel RING_1
will set the new interface address and attach the route label RING_1 to
the corresponding route.

manpage bits from jmc@@
ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.83 2007/05/08 20:57:19 claudio Exp $	*/
d178 1
a178 1
	    M_NOWAIT)) == NULL)
a179 1
	bzero(p, sizeof(void *) * (rtafidx_max + 1));
d223 1
a223 1
		if ((p = malloc(newlen, M_RTABLE, M_NOWAIT)) == NULL)
a224 1
		bzero(p, newlen);
d1316 1
a1316 2
	label = (struct rt_label *)malloc(sizeof(struct rt_label),
	    M_TEMP, M_NOWAIT);
a1318 1
	bzero(label, sizeof(struct rt_label));
@


1.84.2.1
log
@MFC, initial fix by Chris Cappucino, more complete fix by me:
make sure users of rtlabel_id2name() can deal with no label present,
by not calling it when the label id is 0 (initial fix) and also checking
for rtlabel_id2name() returning NULL (complete fix). original rtlabel code
had that all right, the newer rtlabel bound to an interface code not.
impact: local users can cause a kernel panic by using the SIOCGIFRTLABEL
ioctl on interfaces with no route label assigned.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.84 2007/06/14 18:31:49 reyk Exp $	*/
d1034 2
a1035 2
	if (ifa->ifa_ifp->if_rtlabelid &&
	    (label = rtlabel_id2name(ifa->ifa_ifp->if_rtlabelid)) != NULL) {
@


1.83
log
@wildcard is nowhere used anymore. Figured out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.82 2007/05/08 18:46:37 deraadt Exp $	*/
d1006 2
d1034 9
@


1.82
log
@rtalloc2() and  rtalloc_noclone() inside NPF > 0
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.81 2006/06/19 08:14:06 claudio Exp $	*/
a140 1
struct sockaddr		wildcard;	/* zero cookie for wildcard searches */
@


1.81
log
@Unbreak the tree. The code to set and unset the RTF_MPATH bit on all multipath
routes did not carefully check if the route lookup succeded or not and so
rn_mpath_next(rn) blowed up because rn was NULL. Check if rnh_lookup succeded
before touching rn in anyway. OK norby@@ initial diff by hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.80 2006/06/17 17:20:00 pascoe Exp $	*/
d257 2
d318 1
@


1.80
log
@When multipath routes are inserted, ensure that RTF_MPATH is set for any
previous route that may not have been inserted with the -mpath flag.

Similarly, when removing a multipath route and leaving only one route,
clear the RTF_MPATH flag so this is clear.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.79 2006/06/16 16:49:39 henning Exp $	*/
d894 3
a896 3
		if (rn_mpath_capable(rnh)) {
			rn = rnh->rnh_lookup(info->rti_info[RTAX_DST],
			    info->rti_info[RTAX_NETMASK], rnh);
@


1.79
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.78 2006/06/15 16:33:02 henning Exp $	*/
d781 9
d892 12
@


1.78
log
@put the multiple routing tables support back in, fixed.
problem before: with this, we are no longer using the address family as
array index directly, since only 3 of 31 address fanilies actually attach
a table, but we're using an address family to array index translation (just
another array). there, 0 meant "does not attach a table", thus rt_gettable
has to return a null pointer. unfortunately we were using array index 0 for
whatever af attaches first, and since the list is backwards,, that used to
be ipsec - execpt on ipsec-less ramdisks, where it was inet6, and since
route show blindly iterates over all address families, and all those
without a table pointed to index 0, we got 28 or 29 copies of the v6 table.
i had that right initally, and then i borked it later... re-spotted by
claudio.
ok norby hshoexer claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.77 2006/06/06 15:36:07 deraadt Exp $	*/
a146 1
int	rtable_add(u_int);
d148 1
a148 1
int	rtdeletemsg(struct rtentry *);
d242 15
d292 1
a292 1
			    &newrt);
d310 1
a310 1
			rt_missmsg(msgtype, &info, 0, NULL, err);
d325 1
a325 1
	ro->ro_rt = rtalloc1(&ro->ro_dst, 1);
d329 1
a329 1
rtalloc1(struct sockaddr *dst, int report)
d338 1
a338 1
	rnh = rt_gettable(dst->sa_family, 0);
d344 1
a344 1
			    SA(NULL), 0, &newrt);
d364 2
a365 1
			rt_missmsg(RTM_ADD, &info, rt->rt_flags, rt->rt_ifp, 0);
d380 1
a380 1
			rt_missmsg(msgtype, &info, 0, NULL, err);
d454 1
a454 1
	rt = rtalloc1(dst, 0);
d500 1
a500 1
			error = rtrequest1(RTM_ADD, &info, &rt);
d512 1
a512 1
			rt_setgate(rt, rt_key(rt), gateway);
d533 1
a533 1
	rt_missmsg(RTM_REDIRECT, &info, flags, ifp, error);
d540 1
a540 1
rtdeletemsg(struct rtentry *rt)
d557 1
a557 1
	error = rtrequest1(RTM_DELETE, &info, &rt);
d559 1
a559 1
	rt_missmsg(RTM_DELETE, &info, info.rti_flags, ifp, error);
d577 1
a577 1
		rtdeletemsg(rt);
d640 1
a640 1
		struct rtentry	*rt = rtalloc1(gateway, 0);
d664 2
a665 1
    struct sockaddr *netmask, int flags, struct rtentry **ret_nrt)
d674 1
a674 1
	return (rtrequest1(req, &info, ret_nrt));
d723 2
a724 1
rtrequest1(int req, struct rt_addrinfo *info, struct rtentry **ret_nrt)
d735 2
a736 1
	if ((rnh = rt_gettable(info->rti_info[RTAX_DST]->sa_family, 0)) == NULL)
d819 1
a819 1
		    info->rti_info[RTAX_GATEWAY])) {
d863 1
a863 1
		if (rn == NULL && (crt = rtalloc1(ndst, 0)) != NULL) {
d866 1
a866 1
				rtdeletemsg(crt);
d904 2
a905 1
rt_setgate(struct rtentry *rt0, struct sockaddr *dst, struct sockaddr *gate)
d933 1
a933 1
		rt->rt_gwroute = rtalloc1(gate, 1);
d994 1
a994 1
		if ((rt = rtalloc1(dst, 0)) != NULL) {
d1016 1
a1016 1
	error = rtrequest1(cmd, &info, &nrt);
d1061 1
a1061 1
		    0, 0, 0, 0);				\
d1362 1
a1362 1
		    rt_mask(rt), 0, NULL) == 0 && cloning)
@


1.77
log
@back out multiple routing table diffs (3 of 'em) because this makes
'route show' dump out repeated copies of the v6 routing table on ramdisks.
on some architectures it spins forever doing this, on others it just
goes for a long time printing the v6 routes over and over before terminating.
spotted by jmc and krw, backout diff tested by beck.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.73 2006/05/20 20:43:57 reyk Exp $	*/
d133 6
a138 3
struct	route_cb	 route_cb;
struct	rtstat		 rtstat;
struct	radix_node_head	*rt_tables[AF_MAX+1];
d146 2
d173 2
a174 2
void
rtable_init(void **table)
d176 9
a184 1
	struct domain *dom;
d187 1
a187 1
			dom->dom_rtattach(&table[dom->dom_family],
d189 3
d197 2
d202 39
a240 1
	rtable_init((void **)rt_tables);
d264 1
a264 1
	struct radix_node_head	*rnh = rt_tables[dst->sa_family];
d271 1
d317 1
a317 1
	struct radix_node_head	*rnh = rt_tables[dst->sa_family];
d324 1
d718 1
a718 1
	if ((rnh = rt_tables[info->rti_info[RTAX_DST]->sa_family]) == 0)
d1188 1
a1188 1
rt_gettable(sa_family_t af, int id)
d1190 1
a1190 2
	/* ignore id for now */
	return (rt_tables[af]);
d1203 1
d1320 2
a1321 3
	for (i = 1; i <= AF_MAX; i++) {
		rnh = rt_tables[i];
		if (rnh)
d1324 1
a1324 2
				;
	}
@


1.76
log
@use the table ID as array index directly, faster in the forwarding path
we trade higher memory consumption if the user doesn't use continous table
IDs, but in the worst case (table IDs 0 and 255, 64bit machine) that is 2KB
ok claudio ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.75 2006/05/31 02:02:22 henning Exp $	*/
d133 3
a135 6
struct	route_cb	   route_cb;
struct	rtstat		   rtstat;
struct	radix_node_head	***rt_tables;
u_int8_t		   af2rtafidx[AF_MAX+1];
u_int8_t		   rtafidx_max;
u_int			   rtbl_id_max = 0;
a142 2
int	rtable_init(struct radix_node_head ***);
int	rtable_add(u_int);
d168 2
a169 2
int
rtable_init(struct radix_node_head ***table)
d171 1
a171 9
	void		**p;
	struct domain	 *dom;

	if ((p = malloc(sizeof(void *) * (rtafidx_max + 1), M_RTABLE,
	    M_NOWAIT)) == NULL)
		return (-1);
	bzero(p, sizeof(void *) * (rtafidx_max + 1));

	/* 2nd pass: attach */
d174 1
a174 1
			dom->dom_rtattach(&p[af2rtafidx[dom->dom_family]],
a175 3

	*table = (struct radix_node_head **)p;
	return (0);
a180 2
	struct domain	 *dom;

d184 1
a184 39

	bzero(af2rtafidx, sizeof(af2rtafidx));
	rtafidx_max = 0;

	/* find out how many tables to allocate */
	for (dom = domains; dom != NULL; dom = dom->dom_next)
		if (dom->dom_rtattach)
			af2rtafidx[dom->dom_family] = rtafidx_max++;

	if (rtable_add(0) == -1)
		panic("route_init rtable_add");
}

int
rtable_add(u_int id)	/* must be called at splsoftnet */
{
	void	*p;

	if (id > RT_TABLEID_MAX)
		return (-1);

	if (id == 0 || id > rtbl_id_max) {
		size_t	newlen = sizeof(void *) * (id+1);

		if ((p = malloc(newlen, M_RTABLE, M_NOWAIT)) == NULL)
			return (-1);
		bzero(p, newlen);
		if (id > 0) {
			bcopy(rt_tables, p, sizeof(void *) * (rtbl_id_max+1));
			free(rt_tables, M_RTABLE);
		}
		rt_tables = p;
		rtbl_id_max = id;
	}

	if (rt_tables[id] != NULL)	/* already exists */
		return (-1);

	return (rtable_init(&rt_tables[id]));
d208 1
a208 1
	struct radix_node_head	*rnh;
a214 1
	rnh = rt_gettable(dst->sa_family, 0);
d260 1
a260 1
	struct radix_node_head	*rnh;
a266 1
	rnh = rt_gettable(dst->sa_family, 0);
d660 1
a660 1
	if ((rnh = rt_gettable(info->rti_info[RTAX_DST]->sa_family, 0)) == NULL)
d1130 1
a1130 1
rt_gettable(sa_family_t af, u_int id)
d1132 2
a1133 1
	return (rt_tables[id][af2rtafidx[af]]);
a1145 1

d1262 3
a1264 2
	for (i = 1; i <= AF_MAX; i++)
		if ((rnh = rt_gettable(i, 0)) != NULL)
d1267 2
a1268 1
				;	/* nothing */
@


1.75
log
@add comment indictation that rtable_add must be called at splsoftnet
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.74 2006/05/31 01:35:11 henning Exp $	*/
d138 1
a138 1
u_int			   rtbl_cnt = 0;
d147 1
a147 1
int	rtable_add(char *);
a154 1
#define	RTBL_CNT_INC	4	/* allocate rtables in chunks of 4 */
d211 1
a211 1
	if (rtable_add("main") == -1)
d216 1
a216 1
rtable_add(char *tblname)	/* must be called at splsoftnet */
a217 1
	u_int	 i;
d220 7
a226 8
	for (i = 0; i < rtbl_cnt; i++)
		if (rt_tables[i] == NULL)
			break;

	if (i == rtbl_cnt) {
		rtbl_cnt += RTBL_CNT_INC;
		if ((p = malloc(sizeof(void *) * rtbl_cnt, M_RTABLE,
		    M_NOWAIT)) == NULL)
d228 3
a230 3
		bzero(p, sizeof(void *) * rtbl_cnt);
		if (i > 0) {
			bcopy(rt_tables, p, sizeof(void *) * i);
d234 1
d237 4
a240 1
	return (rtable_init(&rt_tables[i]));
@


1.74
log
@move us to multiple routing table heads.
-instead of staticaly declaring the heads, allocate memory for them
-add second dimension to the routing table head array, table ID
-space saver: do not use the AF as array index directly, but have an
 AF->index translation array and only account for AFs actually attaching
 a routing table
note that whil ethat allows for multiple routing table heads, nothing uses
taht yet.
tested by many, ok claudio reyk norby mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.73 2006/05/20 20:43:57 reyk Exp $	*/
d217 1
a217 1
rtable_add(char *tblname)
@


1.73
log
@don't panic if the address familiy is not found in the rt_tables

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.72 2006/04/26 17:02:13 claudio Exp $	*/
d133 6
a138 3
struct	route_cb	 route_cb;
struct	rtstat		 rtstat;
struct	radix_node_head	*rt_tables[AF_MAX+1];
d146 2
d155 1
d174 2
a175 2
void
rtable_init(void **table)
d177 9
a185 1
	struct domain *dom;
d188 1
a188 1
			dom->dom_rtattach(&table[dom->dom_family],
d190 3
d198 2
d203 37
a239 1
	rtable_init((void **)rt_tables);
d263 1
a263 1
	struct radix_node_head	*rnh = rt_tables[dst->sa_family];
d270 1
d316 1
a316 1
	struct radix_node_head	*rnh = rt_tables[dst->sa_family];
d323 1
d717 1
a717 1
	if ((rnh = rt_tables[info->rti_info[RTAX_DST]->sa_family]) == 0)
d1187 1
a1187 1
rt_gettable(sa_family_t af, int id)
d1189 1
a1189 2
	/* ignore id for now */
	return (rt_tables[af]);
d1202 1
d1319 2
a1320 3
	for (i = 1; i <= AF_MAX; i++) {
		rnh = rt_tables[i];
		if (rnh)
d1323 1
a1323 2
				;
	}
@


1.72
log
@Missed the goto in the error path. This resulted in an access to a NULL
pointer and a panic later on. Be more careful Claudio! OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.71 2006/04/22 19:43:06 claudio Exp $	*/
d1141 2
a1142 1
	rnh = rt_gettable(dst->sa_family, tableid);
@


1.71
log
@Routes announced via rt_missmsg() do not have rtm_index set. While in most
cases harmless it is used by the IPv6 code. The result is that bgpd is unable
to assigning link local addresses to the correct interface. OK henning@@
Fix for PR 5063.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.70 2006/03/22 14:37:44 henning Exp $	*/
d371 1
d380 1
d460 1
a460 1
	rt_missmsg(RTM_REDIRECT, &info, flags, ifa->ifa_ifp, error);
@


1.70
log
@prevent anything outside rote.c from accessing the routing table heads
directly. rather provide a rt_lookup function for regular lookups,
and a rt_gettable for those that need access to the head for some reason.
the latter cases should be revisted later probably so that nothing outside
the routing core code accesses the heads at all...
tested claudio jolan me, ok claudio markus
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.69 2006/03/20 10:03:49 henning Exp $	*/
d239 1
a239 1
			rt_missmsg(msgtype, &info, 0, err);
d292 1
a292 1
			rt_missmsg(RTM_ADD, &info, rt->rt_flags, 0);
d307 1
a307 1
			rt_missmsg(msgtype, &info, 0, err);
d458 1
a458 1
	rt_missmsg(RTM_REDIRECT, &info, flags, error);
d469 1
d481 1
d484 1
a484 1
	rt_missmsg(RTM_DELETE, &info, info.rti_flags, error);
@


1.69
log
@introduce rt_if_remove which takes care of routing table updates for an
interface that is removed. use that from if.c and if_tun.c instead of
re-implementing in the latter case. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.68 2006/03/06 13:36:03 henning Exp $	*/
d1125 16
@


1.68
log
@get rid of questionable macro gore.
a 200+ lines diff, but no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.67 2006/03/06 13:34:03 henning Exp $	*/
d147 1
d1233 43
@


1.67
log
@change a questionable multi-level foo ? a : b construct into readable
code. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.66 2006/03/06 13:29:28 henning Exp $	*/
a597 11
/*
 * These (questionable) definitions of apparent local variables apply
 * to the next function.  XXXXXX!!!
 */
#define dst	info->rti_info[RTAX_DST]
#define gateway	info->rti_info[RTAX_GATEWAY]
#define netmask	info->rti_info[RTAX_NETMASK]
#define ifaaddr	info->rti_info[RTAX_IFA]
#define ifpaddr	info->rti_info[RTAX_IFP]
#define flags	info->rti_flags

d608 4
a611 3
	if (info->rti_ifp == NULL && ifpaddr != NULL
	    && ifpaddr->sa_family == AF_LINK &&
	    (ifa = ifa_ifwithnet((struct sockaddr *)ifpaddr)) != NULL)
d613 4
a616 2
	if (info->rti_ifa == NULL && ifaaddr != NULL)
		info->rti_ifa = ifa_ifwithaddr(ifaaddr);
d620 3
a622 3
		if ((sa = ifaaddr) == NULL)
			if ((sa = gateway) == NULL)
				sa = dst;
d626 5
a630 2
		else if (dst != NULL && gateway != NULL)
			info->rti_ifa = ifa_ifwithroute(flags, dst, gateway);
d632 2
a633 1
			info->rti_ifa = ifa_ifwithroute(flags, sa, sa);
d655 1
a655 1
	if ((rnh = rt_tables[dst->sa_family]) == 0)
d657 2
a658 2
	if (flags & RTF_HOST)
		netmask = 0;
d661 2
a662 1
		if ((rn = rnh->rnh_lookup(dst, netmask, rnh)) == NULL)
d671 2
a672 1
			rt = rt_mpath_matchgate(rt, gateway);
d678 2
a679 1
		if ((rn = rnh->rnh_deladdr(dst, netmask, rnh, rn)) == NULL)
d682 3
a684 2
		if ((rt->rt_flags & RTF_CLONING) != 0) {
			/* clean up any cloned children */
d686 1
a686 1
		}
d688 2
a689 2
			panic("rtrequest delete");
		rt = (struct rtentry *)rn;
d694 1
d699 1
d704 1
d719 5
a723 5
		flags = rt->rt_flags & ~(RTF_CLONING | RTF_STATIC);
		flags |= RTF_CLONED;
		gateway = rt->rt_gateway;
		if ((netmask = rt->rt_genmask) == NULL)
			flags |= RTF_HOST;
d735 1
a735 1
		rt->rt_flags = RTF_UP | flags;
d737 2
a738 1
		if (rt_setgate(rt, dst, gateway)) {
d743 3
a745 2
		if (netmask) {
			rt_maskedcopy(dst, ndst, netmask);
d747 2
a748 1
			Bcopy(dst, ndst, dst->sa_len);
d752 2
a753 1
		    rt_mpath_conflict(rnh, rt, netmask, flags & RTF_MPATH)) {
d780 2
a781 2
		rn = rnh->rnh_addaddr((caddr_t)ndst, (caddr_t)netmask,
		    rnh, rt->rt_nodes);
d787 2
a788 1
				    (caddr_t)netmask, rnh, rt->rt_nodes);
d813 2
a814 1
		if_group_routechange(dst, netmask);
a820 7

#undef dst
#undef gateway
#undef netmask
#undef ifaaddr
#undef ifpaddr
#undef flags
@


1.66
log
@more cleanup, again no binary change.
as the previous changes from a train ride to frankfurt a bit over a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.65 2006/03/06 13:24:09 henning Exp $	*/
d365 3
a368 1
	struct rtentry		*rt;
a369 2
	u_int32_t		*stat = NULL;
	int			 error = 0;
d628 4
a631 2
		sa = ifaaddr != NULL ? ifaaddr :
		    (gateway != NULL ? gateway : dst);
@


1.65
log
@cvhange a KASSERT into a if() .. panic() construct so the binary doesn't
change every time a line is added or removed. no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.64 2006/03/06 13:22:20 henning Exp $	*/
a159 1

a164 1

d234 2
a235 1
miss:		if (report) {
d302 2
a303 1
	miss:	if (report && dst->sa_family != PF_KEY) {
d320 1
d322 1
d365 1
d367 2
a369 3
	u_int32_t		*stat = NULL;
	struct rt_addrinfo	 info;
	struct ifaddr		*ifa;
a515 3
/*
* Routing table ioctl interface.
*/
d725 1
a725 1
	makeroute:
d892 1
a892 2
	struct sockaddr		*dst;
	struct sockaddr		*deldst;
a1026 1

a1056 1

d1078 1
a1078 1
	     struct rttimer *), struct rttimer_queue *queue)
@


1.64
log
@KNF, cleanup etc, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.63 2006/02/01 13:47:22 claudio Exp $	*/
d993 2
a994 1
	KASSERT(rt_init_done == 0);
@


1.63
log
@Initialize rmx_expire in rt_timer_add() so that dynamic routes (e.g. PMTU)
show a correct expire time in route(8). OK and idea mpf@@ looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.62 2005/11/29 02:59:42 jolan Exp $	*/
d127 2
a128 2
extern struct ifnet encif; 
struct ifaddr * encap_findgwifa(struct sockaddr *);
d133 14
a146 14
struct	route_cb route_cb;
struct	rtstat  rtstat;
struct	radix_node_head *rt_tables[AF_MAX+1];

int	rttrash;		/* routes not in table but not freed */
struct	sockaddr wildcard;	/* zero valued cookie for wildcard searches */

struct	pool rtentry_pool;	/* pool for rtentry structures */
struct	pool rttimer_pool;	/* pool for rttimer structures */

int okaytoclone(u_int, int);
int rtdeletemsg(struct rtentry *);
int rtflushclone1(struct radix_node *, void *);
void rtflushclone(struct radix_node_head *, struct rtentry *);
d209 6
a214 6
	struct radix_node_head *rnh = rt_tables[dst->sa_family];
	struct rtentry *rt;
	struct radix_node *rn;
	struct rtentry *newrt = 0;
	struct rt_addrinfo info;
	int  s = splnet(), err = 0, msgtype = RTM_MISS;
d260 6
a265 6
	struct radix_node_head *rnh = rt_tables[dst->sa_family];
	struct rtentry *rt;
	struct radix_node *rn;
	struct rtentry *newrt = 0;
	struct rt_addrinfo info;
	int  s = splsoftnet(), err = 0, msgtype = RTM_MISS;
d288 1
a288 1
				info.rti_info[RTAX_IFP] = 
d297 1
a297 1
		        rtstat.rts_unreach++;
d316 1
a316 1
	struct ifaddr *ifa;
d323 1
a323 1
			panic ("rtfree 2");
d363 5
a367 5
	struct rtentry *rt;
	int error = 0;
	u_int32_t *stat = NULL;
	struct rt_addrinfo info;
	struct ifaddr *ifa;
d411 1
a411 1
		create:
d414 1
a414 1
			flags |=  RTF_GATEWAY | RTF_DYNAMIC;
d464 2
a465 2
	int error;
	struct rt_addrinfo info;
d492 1
a492 1
	struct rtentry *rt, *parent;
d526 1
a526 1
	struct ifaddr *ifa;
d536 1
a536 1
		return encap_findgwifa(gateway);
d548 1
a548 1
		if (flags & RTF_HOST) 
d563 1
a563 1
		struct rtentry *rt = rtalloc1(gateway, 0);
d575 1
a575 1
		struct ifaddr *oifa = ifa;
d589 1
a589 1
	struct rt_addrinfo info;
d613 2
a614 2
	struct ifaddr *ifa;
	int error = 0;
d627 1
a627 1
		struct sockaddr *sa;
d649 6
a654 6
	int s = splsoftnet(); int error = 0;
	struct rtentry *rt, *crt;
	struct radix_node *rn;
	struct radix_node_head *rnh;
	struct ifaddr *ifa;
	struct sockaddr *ndst;
d687 1
a687 1
			panic ("rtrequest delete");
d822 3
a824 3
	caddr_t new, old;
	int dlen = ROUNDUP(dst->sa_len), glen = ROUNDUP(gate->sa_len);
	struct rtentry *rt = rt0;
d867 1
a867 1
	       struct sockaddr *netmask)
d869 5
a873 5
	u_char *cp1 = (u_char *)src;
	u_char *cp2 = (u_char *)dst;
	u_char *cp3 = (u_char *)netmask;
	u_char *cplim = cp2 + *cp3;
	u_char *cplim2 = cp2 + *cp1;
d892 7
a898 7
	struct rtentry *rt;
	struct sockaddr *dst;
	struct sockaddr *deldst;
	struct mbuf *m = NULL;
	struct rtentry *nrt = NULL;
	int error;
	struct rt_addrinfo info;
d944 1
a944 1
			       ifa, rt->rt_ifa);
d968 2
a969 2
LIST_HEAD(, rttimer_queue) rttimer_queue_head;
static int rt_init_done = 0;
d976 2
a977 2
			  (struct sockaddr *)rt_key(r->rtt_rt),	\
			  0, 0, 0, 0);				\
d991 1
a991 1
	static struct timeout rt_timer_timeout;
d1007 1
a1007 1
	struct rttimer_queue *rtq;
d1014 1
a1014 1
		return (NULL);		
d1035 1
a1035 1
	struct rttimer *r;
d1063 1
a1063 1
void     
d1066 1
a1066 1
	struct rttimer *r;
d1079 1
a1079 1
int      
d1083 2
a1084 2
	struct rttimer *r;
	long current_time;
d1119 1
a1119 1
	
d1127 5
a1131 5
	struct timeout *to = (struct timeout *)arg;
	struct rttimer_queue *rtq;
	struct rttimer *r;
	long current_time;
	int s;
d1136 1
a1136 1
	for (rtq = LIST_FIRST(&rttimer_queue_head); rtq != NULL; 
@


1.62
log
@something in the eurobsdcon route-a-thon broke my simple home network
router so back out the routing stuff to pre-eurobsdcon where my machine
doesn't crash immediately.

i am happy to test diffs and report success/failures but i am not happy
to have instantaneous crashes when i reboot with a new kernel that was
compiled from pristine sources.

if you are going to be an elitist asshole then you could at least make
sure your code works.

ok and "be crass towards them" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.54 2005/06/08 06:43:07 henning Exp $	*/
d1087 1
@


1.61
log
@more breakage
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.60 2005/11/28 15:19:20 markus Exp $	*/
d127 2
a128 2
extern struct ifnet encif;
struct ifaddr	*encap_findgwifa(struct sockaddr *);
d133 14
a146 15
struct route_cb		 route_cb;
struct rtstat		 rtstat;
struct radix_node_head	*rt_tables[AF_MAX+1];

int		rttrash;	/* routes not in table but not freed */
struct sockaddr	wildcard;	/* zero valued cookie for wildcard searches */

struct pool	rtentry_pool;	/* pool for rtentry structures */
struct pool	rttimer_pool;	/* pool for rttimer structures */

int	okaytoclone(u_int, int);
int	rtdeletemsg(struct rtentry *);
int	rtflushclone1(struct radix_node *, void *);
void	rtflushclone(struct radix_node_head *, struct rtentry *);
int	rt_if_remove_rtdelete(struct radix_node *, void *);
d160 1
d166 1
d172 1
a172 2
	struct domain	*dom;

d209 6
a214 6
	struct radix_node_head	*rnh = rt_tables[dst->sa_family];
	struct rtentry		*rt;
	struct radix_node	*rn;
	struct rtentry		*newrt = 0;
	struct rt_addrinfo	 info;
	int			 s, err = 0, msgtype = RTM_MISS;
a215 1
	s = splnet();
a235 1

d260 6
a265 6
	struct radix_node_head	*rnh = rt_tables[dst->sa_family];
	struct rtentry		*rt;
	struct radix_node	*rn;
	struct rtentry		*newrt = 0;
	struct rt_addrinfo	 info;
	int			 s, err = 0, msgtype = RTM_MISS;
a266 1
	s = splsoftnet();
d288 2
a289 2
				info.rti_info[RTAX_IFP] = TAILQ_FIRST
				    (&rt->rt_ifp->if_addrlist)->ifa_addr;
d297 1
a297 1
			rtstat.rts_unreach++;
d303 1
a303 1
miss:		if (report && dst->sa_family != PF_KEY) {
d316 1
a316 1
	struct ifaddr	*ifa;
a319 1

a320 1

d323 1
a323 1
			panic("rtfree 2");
d363 5
a367 5
	struct rtentry		*rt;
	struct rt_addrinfo	 info;
	struct ifaddr		*ifa;
	int			 error = 0;
	u_int32_t		*stat = NULL;
a385 1

d411 1
a411 1
create:
d464 2
a465 2
	int			error;
	struct rt_addrinfo	info;
d492 1
a492 1
	struct rtentry	*rt = (struct rtentry *)rn, *parent = arg;
d494 2
d511 1
a511 1
	rnh->rnh_walktree(rnh, rtflushclone1, parent);
d514 3
d526 1
a526 1
	struct ifaddr	*ifa;
d548 1
a548 1
		if (flags & RTF_HOST)
d563 2
a564 3
		struct rtentry *rt;

		if ((rt = rtalloc1(gateway, 0)) == NULL)
d576 2
a577 2

		if ((ifa = ifaof_ifpforaddr(dst, ifa->ifa_ifp)) == NULL)
d589 1
a589 1
	struct rt_addrinfo	info;
d599 11
d613 2
a614 2
	struct ifaddr	*ifa;
	int		 error = 0;
d620 3
a622 4
	if (info->rti_ifp == NULL && info->rti_info[RTAX_IFP] != NULL
	    && info->rti_info[RTAX_IFP]->sa_family == AF_LINK &&
	    (ifa = ifa_ifwithnet((struct sockaddr *)info->rti_info[RTAX_IFP]))
	    != NULL)
d624 2
a625 4

	if (info->rti_ifa == NULL && info->rti_info[RTAX_IFA] != NULL)
		info->rti_ifa = ifa_ifwithaddr(info->rti_info[RTAX_IFA]);

d629 2
a630 4
		if ((sa = info->rti_info[RTAX_IFA]) == NULL)
			if ((sa = info->rti_info[RTAX_GATEWAY]) == NULL)
				sa = info->rti_info[RTAX_DST];

d633 2
a634 5
		else if (info->rti_info[RTAX_DST] != NULL &&
		    info->rti_info[RTAX_GATEWAY] != NULL)
			info->rti_ifa = ifa_ifwithroute(info->rti_flags,
			    info->rti_info[RTAX_DST],
			    info->rti_info[RTAX_GATEWAY]);
d636 1
a636 2
			info->rti_ifa = ifa_ifwithroute(info->rti_flags,
			    sa, sa);
d649 6
a654 6
	int			 s, error = 0;
	struct rtentry		*rt, *crt;
	struct radix_node	*rn;
	struct radix_node_head	*rnh;
	struct ifaddr		*ifa;
	struct sockaddr		*ndst;
d658 1
a658 3
	s = splsoftnet();

	if ((rnh = rt_tables[info->rti_info[RTAX_DST]->sa_family]) == 0)
d660 2
a661 2
	if (info->rti_flags & RTF_HOST)
		info->rti_info[RTAX_NETMASK] = NULL;
d664 1
a664 2
		if ((rn = rnh->rnh_lookup(info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_NETMASK], rnh)) == NULL)
d673 1
a673 2
			rt = rt_mpath_matchgate(rt,
			    info->rti_info[RTAX_GATEWAY]);
d679 1
a679 2
		if ((rn = rnh->rnh_deladdr(info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_NETMASK], rnh, rn)) == NULL)
d682 2
a683 3

		/* clean up any cloned children */
		if ((rt->rt_flags & RTF_CLONING) != 0)
d685 1
a685 1

d688 1
a688 1

a692 1

a696 1

a700 1

d715 5
a719 5
		info->rti_flags = rt->rt_flags & ~(RTF_CLONING | RTF_STATIC);
		info->rti_flags |= RTF_CLONED;
		info->rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		if ((info->rti_info[RTAX_NETMASK] = rt->rt_genmask) == NULL)
			info->rti_flags |= RTF_HOST;
d726 1
a726 1
makeroute:
d731 1
a731 1
		rt->rt_flags = RTF_UP | info->rti_flags;
d733 1
a733 2
		if (rt_setgate(rt, info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_GATEWAY])) {
d738 2
a739 3
		if (info->rti_info[RTAX_NETMASK] != NULL) {
			rt_maskedcopy(info->rti_info[RTAX_DST], ndst,
			    info->rti_info[RTAX_NETMASK]);
d741 1
a741 2
			Bcopy(info->rti_info[RTAX_DST], ndst,
			    info->rti_info[RTAX_DST]->sa_len);
d745 1
a745 2
		    rt_mpath_conflict(rnh, rt, info->rti_info[RTAX_NETMASK],
		    info->rti_flags & RTF_MPATH)) {
d772 2
a773 2
		rn = rnh->rnh_addaddr((caddr_t)ndst,
		    (caddr_t)info->rti_info[RTAX_NETMASK], rnh, rt->rt_nodes);
d779 1
a779 2
				    (caddr_t)info->rti_info[RTAX_NETMASK],
				    rnh, rt->rt_nodes);
d804 1
a804 2
		if_group_routechange(info->rti_info[RTAX_DST],
			info->rti_info[RTAX_NETMASK]);
d812 7
d822 2
a823 2
	caddr_t		new, old;
	int		dlen, glen;
a825 3
	dlen = ROUNDUP(dst->sa_len);
	glen = ROUNDUP(gate->sa_len);

d869 5
a873 5
	u_char	*cp1 = (u_char *)src;
	u_char	*cp2 = (u_char *)dst;
	u_char	*cp3 = (u_char *)netmask;
	u_char	*cplim = cp2 + *cp3;
	u_char	*cplim2 = cp2 + *cp1;
d892 7
a898 6
	struct rtentry		*rt;
	struct sockaddr		*dst, *deldst;
	struct mbuf		*m = NULL;
	struct rtentry		*nrt = NULL;
	int			 error;
	struct rt_addrinfo	info;
d903 2
a904 1
			if ((m = m_get(M_DONTWAIT, MT_SONAME)) == NULL)
d914 3
a916 5
					m_free(m);
				if (flags & RTF_HOST)
					return (EHOSTUNREACH);
				else
					return (ENETUNREACH);
d944 1
a944 1
			    ifa, rt->rt_ifa);
d976 2
a977 2
		    (struct sockaddr *)rt_key(r->rtt_rt),	\
		    0, 0, 0, 0);				\
d991 1
a991 1
	static struct timeout	rt_timer_timeout;
d1007 1
a1007 1
	struct rttimer_queue	*rtq;
d1014 1
a1014 1
		return (NULL);
d1028 1
d1035 1
a1035 1
	struct rttimer	*r;
d1059 1
d1063 1
a1063 1
void
d1066 1
a1066 1
	struct rttimer	*r;
d1079 3
a1081 4
int
rt_timer_add(struct rtentry *rt,
    void (*func)(struct rtentry *, struct rttimer *),
    struct rttimer_queue *queue)
d1083 2
a1084 2
	struct rttimer	*r;
	long		 current_time;
d1106 2
a1107 1
	if ((r = pool_get(&rttimer_pool, PR_NOWAIT)) == NULL)
d1118 1
a1118 1

d1126 7
a1132 5
	struct timeout		*to = arg;
	struct rttimer_queue	*rtq;
	struct rttimer		*r;
	long			 current_time = time_uptime;
	int			 s;
d1135 1
a1135 1
	for (rtq = LIST_FIRST(&rttimer_queue_head); rtq != NULL;
a1229 61
}

void
rt_if_remove(struct ifnet *ifp)
{
	struct radix_node_head	*rnh;
	int			 i;

	for (i = 1; i <= AF_MAX; i++)
		if ((rnh = rt_tables[i]) != NULL)
			while ((*rnh->rnh_walktree)(rnh,
			    rt_if_remove_rtdelete, ifp) == EAGAIN)
				;
}

/*
 * Delete a route if it has a specific interface for output.
 * This function complies to the rn_walktree callback API.
 *
 * Note that deleting a RTF_CLONING route can trigger the
 * deletion of more entries, so we need to cancel the walk
 * and return EAGAIN.  The caller should restart the walk
 * as long as EAGAIN is returned.
 */
int
rt_if_remove_rtdelete(struct radix_node *rn, void *vifp)
{
	struct ifnet	*ifp = vifp;
	struct rtentry	*rt = (struct rtentry *)rn;

	if (rt->rt_ifp == ifp) {
		int	cloning = (rt->rt_flags & RTF_CLONING);

		if (rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway,
		    rt_mask(rt), 0, NULL) == 0 && cloning)
			return (EAGAIN);
	}

	/*
	 * XXX There should be no need to check for rt_ifa belonging to this
	 * interface, because then rt_ifp is set, right?
	 */

	return (0);
}

struct radix_node_head *
rt_gettable(sa_family_t af, int id)
{
	/* ignore id for now */
	return (rt_tables[af]);
}

struct radix_node *
rt_lookup(struct sockaddr *dst, struct sockaddr *mask, int tableid)
{
	struct radix_node_head	*rnh;

	rnh = rt_gettable(dst->sa_family, tableid);

	return (rnh->rnh_lookup(dst, mask, rnh));
@


1.60
log
@unbreak route deletion (from revision 1.55; obviously too much eyebleeding)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.59 2005/11/27 16:22:45 henning Exp $	*/
d579 1
a579 1
		if ((ifa = ifaof_ifpforaddr(dst, ifa->ifa_ifp)) == NULL);
@


1.59
log
@don't let anything outside route.c access the routing table heads directly,
but go through a provided wrapper.
also provide rt_lookup() instead of doing the lookup manually in many places.
ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.58 2005/11/25 13:45:02 henning Exp $	*/
d913 1
a913 1
			if ((m = m_get(M_DONTWAIT, MT_SONAME)) == NULL);
@


1.58
log
@move the code to delete routes having a specific interface as output
when the interface is deleted to a function in route.c, and replace
the copies of that code by calls to that function
from basel almost-hackathon
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.57 2005/11/25 13:33:47 henning Exp $	*/
d1283 16
@


1.57
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.56 2005/11/25 13:29:20 henning Exp $	*/
d147 1
d1238 45
@


1.56
log
@reduce eyebleeding, since we only borrow the code from our children
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.55 2005/11/25 11:58:07 henning Exp $	*/
d127 1
a127 1
extern struct ifnet encif; 
d299 1
a299 1
		        rtstat.rts_unreach++;
d327 1
a327 1
			panic ("rtfree 2");
d548 1
a548 1
		if (flags & RTF_HOST) 
d954 1
a954 1
			       ifa, rt->rt_ifa);
d986 2
a987 2
			  (struct sockaddr *)rt_key(r->rtt_rt),	\
			  0, 0, 0, 0);				\
d1024 1
a1024 1
		return (NULL);		
d1071 1
a1071 1
void     
d1087 1
a1087 1
int      
d1126 1
a1126 1
	
d1141 1
a1141 1
	for (rtq = LIST_FIRST(&rttimer_queue_head); rtq != NULL; 
@


1.55
log
@How can we dance when our humppa is feeding
How do we code while our eyes are bleeding
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.54 2005/06/08 06:43:07 henning Exp $	*/
a599 11
/*
 * These (questionable) definitions of apparent local variables apply
 * to the next function.  XXXXXX!!!
 */
#define dst	info->rti_info[RTAX_DST]
#define gateway	info->rti_info[RTAX_GATEWAY]
#define netmask	info->rti_info[RTAX_NETMASK]
#define ifaaddr	info->rti_info[RTAX_IFA]
#define ifpaddr	info->rti_info[RTAX_IFP]
#define flags	info->rti_flags

d603 2
a604 2
	struct ifaddr *ifa;
	int error = 0;
d610 4
a613 3
	if (info->rti_ifp == NULL && ifpaddr != NULL
	    && ifpaddr->sa_family == AF_LINK &&
	    (ifa = ifa_ifwithnet((struct sockaddr *)ifpaddr)) != NULL)
d615 4
a618 2
	if (info->rti_ifa == NULL && ifaaddr != NULL)
		info->rti_ifa = ifa_ifwithaddr(ifaaddr);
d622 4
a625 2
		sa = ifaaddr != NULL ? ifaaddr :
		    (gateway != NULL ? gateway : dst);
d628 5
a632 2
		else if (dst != NULL && gateway != NULL)
			info->rti_ifa = ifa_ifwithroute(flags, dst, gateway);
d634 2
a635 1
			info->rti_ifa = ifa_ifwithroute(flags, sa, sa);
d648 1
a648 1
	int s, error = 0;
d659 1
a659 1
	if ((rnh = rt_tables[dst->sa_family]) == 0)
d661 2
a662 2
	if (flags & RTF_HOST)
		netmask = 0;
d665 2
a666 1
		if ((rn = rnh->rnh_lookup(dst, netmask, rnh)) == NULL)
d675 2
a676 1
			rt = rt_mpath_matchgate(rt, gateway);
d682 2
a683 1
		if ((rn = rnh->rnh_deladdr(dst, netmask, rnh, rn)) == NULL)
d686 3
a688 2
		if ((rt->rt_flags & RTF_CLONING) != 0) {
			/* clean up any cloned children */
d690 1
a690 1
		}
d693 1
a693 1
		rt = (struct rtentry *)rn;
d698 1
d703 1
d708 1
d723 5
a727 5
		flags = rt->rt_flags & ~(RTF_CLONING | RTF_STATIC);
		flags |= RTF_CLONED;
		gateway = rt->rt_gateway;
		if ((netmask = rt->rt_genmask) == NULL)
			flags |= RTF_HOST;
d739 1
a739 1
		rt->rt_flags = RTF_UP | flags;
d741 2
a742 1
		if (rt_setgate(rt, dst, gateway)) {
d747 3
a749 2
		if (netmask) {
			rt_maskedcopy(dst, ndst, netmask);
d751 2
a752 1
			Bcopy(dst, ndst, dst->sa_len);
d756 2
a757 1
		    rt_mpath_conflict(rnh, rt, netmask, flags & RTF_MPATH)) {
d784 2
a785 2
		rn = rnh->rnh_addaddr((caddr_t)ndst, (caddr_t)netmask,
		    rnh, rt->rt_nodes);
d791 2
a792 1
				    (caddr_t)netmask, rnh, rt->rt_nodes);
d817 2
a818 1
		if_group_routechange(dst, netmask);
a824 7

#undef dst
#undef gateway
#undef netmask
#undef ifaaddr
#undef ifpaddr
#undef flags
@


1.54
log
@kill some leftover bits from netns and iso routing
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.53 2005/06/08 03:13:49 henning Exp $	*/
d128 1
a128 1
struct ifaddr * encap_findgwifa(struct sockaddr *);
d133 14
a146 14
struct	route_cb route_cb;
struct	rtstat  rtstat;
struct	radix_node_head *rt_tables[AF_MAX+1];

int	rttrash;		/* routes not in table but not freed */
struct	sockaddr wildcard;	/* zero valued cookie for wildcard searches */

struct	pool rtentry_pool;	/* pool for rtentry structures */
struct	pool rttimer_pool;	/* pool for rttimer structures */

int okaytoclone(u_int, int);
int rtdeletemsg(struct rtentry *);
int rtflushclone1(struct radix_node *, void *);
void rtflushclone(struct radix_node_head *, struct rtentry *);
a159 1

a164 1

d170 2
a171 1
	struct domain *dom;
d208 6
a213 6
	struct radix_node_head *rnh = rt_tables[dst->sa_family];
	struct rtentry *rt;
	struct radix_node *rn;
	struct rtentry *newrt = 0;
	struct rt_addrinfo info;
	int  s = splnet(), err = 0, msgtype = RTM_MISS;
d215 1
d236 1
d261 6
a266 6
	struct radix_node_head *rnh = rt_tables[dst->sa_family];
	struct rtentry *rt;
	struct radix_node *rn;
	struct rtentry *newrt = 0;
	struct rt_addrinfo info;
	int  s = splsoftnet(), err = 0, msgtype = RTM_MISS;
d268 1
d290 2
a291 2
				info.rti_info[RTAX_IFP] = 
				    TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
d305 1
a305 1
	miss:	if (report && dst->sa_family != PF_KEY) {
d318 1
a318 1
	struct ifaddr *ifa;
d322 1
d324 1
d367 5
a371 5
	struct rtentry *rt;
	int error = 0;
	u_int32_t *stat = NULL;
	struct rt_addrinfo info;
	struct ifaddr *ifa;
d390 1
d416 1
a416 1
		create:
d469 2
a470 2
	int error;
	struct rt_addrinfo info;
d497 1
a497 1
	struct rtentry *rt, *parent;
a498 2
	rt = (struct rtentry *)rn;
	parent = (struct rtentry *)arg;
d514 1
a514 1
	rnh->rnh_walktree(rnh, rtflushclone1, (void *)parent);
a516 3
/*
* Routing table ioctl interface.
*/
d526 1
a526 1
	struct ifaddr *ifa;
d563 3
a565 2
		struct rtentry *rt = rtalloc1(gateway, 0);
		if (rt == NULL)
d577 2
a578 2
		ifa = ifaof_ifpforaddr(dst, ifa->ifa_ifp);
		if (ifa == NULL)
d590 1
a590 1
	struct rt_addrinfo info;
d650 6
a655 6
	int s = splsoftnet(); int error = 0;
	struct rtentry *rt, *crt;
	struct radix_node *rn;
	struct radix_node_head *rnh;
	struct ifaddr *ifa;
	struct sockaddr *ndst;
d659 2
d729 1
a729 1
	makeroute:
d825 2
a826 2
	caddr_t new, old;
	int dlen = ROUNDUP(dst->sa_len), glen = ROUNDUP(gate->sa_len);
d829 3
d875 5
a879 5
	u_char *cp1 = (u_char *)src;
	u_char *cp2 = (u_char *)dst;
	u_char *cp3 = (u_char *)netmask;
	u_char *cplim = cp2 + *cp3;
	u_char *cplim2 = cp2 + *cp1;
d898 6
a903 7
	struct rtentry *rt;
	struct sockaddr *dst;
	struct sockaddr *deldst;
	struct mbuf *m = NULL;
	struct rtentry *nrt = NULL;
	int error;
	struct rt_addrinfo info;
d908 1
a908 2
			m = m_get(M_DONTWAIT, MT_SONAME);
			if (m == NULL)
d918 5
a922 3
					(void) m_free(m);
				return (flags & RTF_HOST ? EHOSTUNREACH
							: ENETUNREACH);
d997 1
a997 1
	static struct timeout rt_timer_timeout;
d1013 1
a1013 1
	struct rttimer_queue *rtq;
a1033 1

d1040 1
a1040 1
	struct rttimer *r;
a1063 1

d1070 1
a1070 1
	struct rttimer *r;
d1084 3
a1086 2
rt_timer_add(struct rtentry *rt, void (*func)(struct rtentry *,
	     struct rttimer *), struct rttimer_queue *queue)
d1088 2
a1089 2
	struct rttimer *r;
	long current_time;
d1111 1
a1111 2
	r = pool_get(&rttimer_pool, PR_NOWAIT);
	if (r == NULL)
d1130 5
a1134 7
	struct timeout *to = (struct timeout *)arg;
	struct rttimer_queue *rtq;
	struct rttimer *r;
	long current_time;
	int s;

	current_time = time_uptime;
@


1.53
log
@in rtlabel_name2id, handle the case of an empty name: return 0
label id 0 means "no label".
in pf_ioctl, where this is used to filter based on a label, this is an error
condition.
for the other 2 cases, messages on the routing socket, this allows for an
sockaddr_rtlabel to be always present for messages on the routing socket,
and when it is all zero it is exactly like if there was no sockaddr_rtlabel
at all.
ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.52 2005/06/07 18:21:44 henning Exp $	*/
a122 4

#ifdef NS
#include <netns/ns.h>
#endif
@


1.52
log
@introduce a default "external" interface group, containing the interface(s)
the the default route(s) point to.
handles IPv4 and IPv6 as well as multipath routes.
follows default route changes, of course.
eases writing pf rulesets especially on laptops etc. that use different
interfaces depending on the environment (wired, wireless, ...)
ok theo ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.51 2005/05/15 16:40:09 henning Exp $	*/
d1163 3
@


1.51
log
@ANSI, mostly from Toni Mueller <openbsd-tech@@oeko.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.50 2004/09/16 22:31:30 henning Exp $	*/
d807 2
@


1.50
log
@handle route labels on RTM_CHANGE, ok mcbride, prodded my markus some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.49 2004/08/09 12:01:26 otto Exp $	*/
d174 1
a174 2
rtable_init(table)
	void **table;
d193 1
a193 3
rtalloc_noclone(ro, howstrict)
	struct route *ro;
	int howstrict;
d201 1
a201 3
okaytoclone(flags, howstrict)
	u_int flags;
	int howstrict;
d211 1
a211 3
rtalloc2(dst, report,howstrict)
	struct sockaddr *dst;
	int report,howstrict;
d254 1
a254 2
rtalloc(ro)
	struct route *ro;
d262 1
a262 3
rtalloc1(dst, report)
	struct sockaddr *dst;
	int report;
d318 1
a318 2
rtfree(rt)
	struct rtentry *rt;
d344 1
a344 2
ifafree(ifa)
	struct ifaddr *ifa;
d363 3
a365 4
rtredirect(dst, gateway, netmask, flags, src, rtp)
	struct sockaddr *dst, *gateway, *netmask, *src;
	int flags;
	struct rtentry **rtp;
d466 1
a466 2
rtdeletemsg(rt)
	struct rtentry *rt;
d494 1
a494 3
rtflushclone1(rn, arg)
	struct radix_node *rn;
	void *arg;
d506 1
a506 3
rtflushclone(rnh, parent)
	struct radix_node_head *rnh;
	struct rtentry *parent;
d522 1
a522 4
rtioctl(req, data, p)
	u_long req;
	caddr_t data;
	struct proc *p;
d528 1
a528 3
ifa_ifwithroute(flags, dst, gateway)
	int flags;
	struct sockaddr	*dst, *gateway;
d590 2
a591 4
rtrequest(req, dst, gateway, netmask, flags, ret_nrt)
	int req, flags;
	struct sockaddr *dst, *gateway, *netmask;
	struct rtentry **ret_nrt;
d615 1
a615 2
rt_getifa(info)
	struct rt_addrinfo *info;
d651 1
a651 4
rtrequest1(req, info, ret_nrt)
	int req;
	struct rt_addrinfo *info;
	struct rtentry **ret_nrt;
d822 1
a822 3
rt_setgate(rt0, dst, gate)
	struct rtentry *rt0;
	struct sockaddr *dst, *gate;
d868 2
a869 2
rt_maskedcopy(src, dst, netmask)
	struct sockaddr *src, *dst, *netmask;
d892 1
a892 3
rtinit(ifa, cmd, flags)
	struct ifaddr *ifa;
	int cmd, flags;
d990 1
a990 1
void	 
d1007 1
a1007 2
rt_timer_queue_create(timeout)
	u_int	timeout;
d1028 1
a1028 3
rt_timer_queue_change(rtq, timeout)
	struct rttimer_queue *rtq;
	long timeout;
d1035 1
a1035 3
rt_timer_queue_destroy(rtq, destroy)
	struct rttimer_queue *rtq;
	int destroy;
d1059 1
a1059 2
rt_timer_count(rtq)
	struct rttimer_queue *rtq;
d1066 1
a1066 2
rt_timer_remove_all(rt)
	struct rtentry *rt;
d1082 2
a1083 4
rt_timer_add(rt, func, queue)
	struct rtentry *rt;
	void(*func)(struct rtentry *, struct rttimer *);
	struct rttimer_queue *queue;
d1126 1
a1126 2
rt_timer_timer(arg)
	void *arg;
@


1.49
log
@Change static functions to be non-static, for better backtraces.
ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.48 2004/08/08 19:09:33 otto Exp $	*/
a161 3

u_int16_t	 rtlabel_name2id(char *);
void		 rtlabel_unref(u_int16_t);
@


1.48
log
@Zero route info structure in rtredirect(), avoiding a panic on label
copy.
ok millert@@ deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.47 2004/08/03 11:22:15 henning Exp $	*/
d132 1
d147 4
a150 4
static int okaytoclone(u_int, int);
static int rtdeletemsg(struct rtentry *);
static int rtflushclone1(struct radix_node *, void *);
static void rtflushclone(struct radix_node_head *, struct rtentry *);
d163 2
a164 2
static u_int16_t	 rtlabel_name2id(char *);
static void		 rtlabel_unref(u_int16_t);
d168 1
a168 1
static struct ifaddr *
d206 1
a206 1
static int
d481 1
a481 1
static int
d510 1
a510 1
static int
d524 1
a524 1
static void
d1202 1
a1202 1
static u_int16_t
d1257 1
a1257 1
static void
@


1.47
log
@introduce route labels, allowing for up to 32 bytes of info to be attached
to a route.
the label is sent over the routing socket wrapped into a new
struct sockaddr_rtlabel, allowing for handling it like any other sockaddr.
struct rtentry only contains a (16 bit) label-ID, with the actual labels
kept outside the routing table.
ID allocator code inspired by my own code for altq and pf tags.
mostly hacked at the c2k4 hackathon, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.46 2004/07/28 13:13:41 markus Exp $	*/
d434 1
@


1.46
log
@pool(9) for rtentry and rttimer; similar to netbsd; ok mcbride, henning, pb
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.45 2004/07/20 23:40:27 art Exp $	*/
d114 1
d151 14
d350 1
d689 1
d787 7
d1198 75
@


1.45
log
@KASSERT instead of assert. Gives smaller RAMDISKS.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.44 2004/06/22 07:35:20 cedric Exp $	*/
d114 1
d142 3
d174 2
d336 1
a336 1
		Free(rt);
d744 1
a744 1
		R_Malloc(rt, struct rtentry *, sizeof(*rt));
d751 1
a751 1
			Free(rt);
d766 1
a766 1
			Free(rt);
d800 1
a800 1
			Free(rt);
a1006 1
#if 0
a1008 1
#endif
a1058 1
#if 0
a1059 3
#else
		free(r, M_RTABLE);
#endif
a1093 1
#if 0
a1094 3
#else
		free(r, M_RTABLE);
#endif
a1121 1
#if 0
a1122 3
#else
			free(r, M_RTABLE);
#endif
a1126 1
#if 0
a1127 3
#else
	r = (struct rttimer *)malloc(sizeof(*r), M_RTABLE, M_NOWAIT);
#endif
a1163 1
#if 0
a1164 3
#else
			free(r, M_RTABLE);
#endif
@


1.44
log
@Pull the plug on source-based routing until remaining bugs are eradicated.
No need to reconfig kernel or rebuild userland stuff.
requested deraadt@@, help beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.43 2004/06/21 23:50:37 tholo Exp $	*/
d999 1
a999 1
	assert(rt_init_done == 0);
@


1.43
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.42 2004/06/19 19:55:53 cedric Exp $	*/
a140 3
const struct sockaddr_rtin rt_defmask4 = { /* default IPv4 route mask */
            offsetof(struct sockaddr_rtin, rtin_src), 0, 0, { -1 }};

d671 2
a672 8
	if (flags & RTF_HOST) {
#ifdef SMALL_KERNEL
		netmask = (dst->sa_family == AF_INET) ? 
		    (struct sockaddr *)&rt_defmask4 : NULL;
#else
		sroute_verify_host(info);
#endif
	}
d729 1
a729 2
#ifdef SMALL_KERNEL
		if ((netmask = rt->rt_genmask) == NULL) {
a730 6
			if (dst->sa_family == AF_INET)
				netmask = (struct sockaddr *)&rt_defmask4;
		}
#else
		sroute_clone_route(info, rt_mask(rt), rt->rt_genmask);
#endif
@


1.42
log
@require RTF_MPATH to enter a multipath route with RTM_ADD.
route(8) takes a new -mpath modifier to enter a multipath route.
requested deraadt@@, ok itojun@@ mcbride@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.41 2004/06/06 16:49:09 cedric Exp $	*/
d1127 1
a1127 1
	current_time = mono_time.tv_sec;
d1182 1
a1182 1
	current_time = mono_time.tv_sec;
@


1.41
log
@extend routing table to be able to match and route packets based on
their *source* IP address in addition to their destination address.
routing table "destination" now contains a "struct sockaddr_rtin"
for IPv4 instead of a "struct sockaddr_in".
the routing socket has been extended in a backward-compatible way.
todo: PMTU enhancements, IPv6. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.40 2004/04/25 02:48:04 itojun Exp $	*/
d772 1
a772 1
		    rt_mpath_conflict(rnh, rt, netmask)) {
@


1.40
log
@radix tree with multipath support.  from kame.  deraadt ok
user visible changes:
- you can add multiple routes with same key (route add A B then route add A C)
- you have to specify gateway address if there are multiple entries on the table
  (route delete A B, instead of route delete A)
kernel change:
- radix_node_head has an extra entry
- rnh_deladdr takes extra argument

TODO:
- actually take advantage of multipath (rtalloc -> rtalloc_mpath)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.39 2003/12/10 07:22:42 itojun Exp $	*/
d141 3
d674 8
a681 2
	if (flags & RTF_HOST)
		netmask = 0;
d738 2
a739 1
		if ((netmask = rt->rt_genmask) == NULL)
d741 6
@


1.39
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.38 2003/08/27 00:01:38 itojun Exp $	*/
d675 16
a690 1
		if ((rn = rnh->rnh_deladdr(dst, netmask, rnh)) == NULL)
d753 11
@


1.38
log
@cut-and-paste error; henric
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.37 2003/08/26 08:33:12 itojun Exp $	*/
d176 1
a176 1
	register struct route *ro;
d198 1
a198 1
	register struct sockaddr *dst;
d201 3
a203 3
	register struct radix_node_head *rnh = rt_tables[dst->sa_family];
	register struct rtentry *rt;
	register struct radix_node *rn;
d243 1
a243 1
	register struct route *ro;
d252 1
a252 1
	register struct sockaddr *dst;
d255 3
a257 3
	register struct radix_node_head *rnh = rt_tables[dst->sa_family];
	register struct rtentry *rt;
	register struct radix_node *rn;
d310 1
a310 1
	register struct rtentry *rt;
d312 1
a312 1
	register struct ifaddr *ifa;
d336 1
a336 1
	register struct ifaddr *ifa;
d532 1
a532 1
	register struct ifaddr *ifa;
d662 3
a664 3
	register struct rtentry *rt, *crt;
	register struct radix_node *rn;
	register struct radix_node_head *rnh;
d802 1
a802 1
	register struct rtentry *rt = rt0;
d847 3
a849 3
	register u_char *cp1 = (u_char *)src;
	register u_char *cp2 = (u_char *)dst;
	register u_char *cp3 = (u_char *)netmask;
d869 1
a869 1
	register struct ifaddr *ifa;
d872 3
a874 3
	register struct rtentry *rt;
	register struct sockaddr *dst;
	register struct sockaddr *deldst;
@


1.37
log
@mark cloned route with RTF_CLONED.  remove RTF_CLONED route when clone parent
disappers.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.36 2003/06/02 23:28:12 millert Exp $	*/
a681 2
		if ((rn = rnh->rnh_deladdr(dst, netmask, rnh)) == NULL)
			senderr(ESRCH);
@


1.36
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.35 2003/02/12 14:41:07 jason Exp $	*/
d142 3
d455 61
d662 1
a662 1
	register struct rtentry *rt;
d677 7
d691 4
d710 2
d713 2
a714 1
		flags = rt->rt_flags & ~RTF_CLONING;
a739 9
		rn = rnh->rnh_addaddr((caddr_t)ndst, (caddr_t)netmask,
					rnh, rt->rt_nodes);
		if (rn == NULL) {
			if (rt->rt_gwroute)
				rtfree(rt->rt_gwroute);
			Free(rt_key(rt));
			Free(rt);
			senderr(EEXIST);
		}
d750 22
d778 4
@


1.35
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.34 2002/09/11 05:38:47 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.35.2.1
log
@Pull patch from -current:
Fixed by itojun@@

Fix on-link DoS by bogus ARP. Reported by Apple.

ok itojun@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.37 2003/08/26 08:33:12 itojun Exp $	*/
a145 3
static int rtdeletemsg(struct rtentry *);
static int rtflushclone1(struct radix_node *, void *);
static void rtflushclone(struct radix_node_head *, struct rtentry *);
a455 61
 * Delete a route and generate a message
 */
static int
rtdeletemsg(rt)
	struct rtentry *rt;
{
	int error;
	struct rt_addrinfo info;

	/*
	 * Request the new route so that the entry is not actually
	 * deleted.  That will allow the information being reported to
	 * be accurate (and consistent with route_output()).
	 */
	bzero((caddr_t)&info, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	info.rti_flags = rt->rt_flags;
	error = rtrequest1(RTM_DELETE, &info, &rt);

	rt_missmsg(RTM_DELETE, &info, info.rti_flags, error);

	/* Adjust the refcount */
	if (error == 0 && rt->rt_refcnt <= 0) {
		rt->rt_refcnt++;
		rtfree(rt);
	}
	return (error);
}

static int
rtflushclone1(rn, arg)
	struct radix_node *rn;
	void *arg;
{
	struct rtentry *rt, *parent;

	rt = (struct rtentry *)rn;
	parent = (struct rtentry *)arg;
	if ((rt->rt_flags & RTF_CLONED) != 0 && rt->rt_parent == parent)
		rtdeletemsg(rt);
	return 0;
}

static void
rtflushclone(rnh, parent)
	struct radix_node_head *rnh;
	struct rtentry *parent;
{

#ifdef DIAGNOSTIC
	if (!parent || (parent->rt_flags & RTF_CLONING) == 0)
		panic("rtflushclone: called with a non-cloning route");
	if (!rnh->rnh_walktree)
		panic("rtflushclone: no rnh_walktree");
#endif
	rnh->rnh_walktree(rnh, rtflushclone1, (void *)parent);
}

/*
d602 1
a602 1
	register struct rtentry *rt, *crt;
a616 5
		rt = (struct rtentry *)rn;
		if ((rt->rt_flags & RTF_CLONING) != 0) {
			/* clean up any cloned children */
			rtflushclone(rnh, rt);
		}
a623 4
		if (rt->rt_parent) {
			rt->rt_parent->rt_refcnt--;
			rt->rt_parent = NULL;
		}
a638 2
		if ((rt->rt_flags & RTF_CLONING) == 0)
			senderr(EINVAL);
d640 1
a640 2
		flags = rt->rt_flags & ~(RTF_CLONING | RTF_STATIC);
		flags |= RTF_CLONED;
d666 9
a684 22
			rt->rt_parent->rt_refcnt++;
		}
		rn = rnh->rnh_addaddr((caddr_t)ndst, (caddr_t)netmask,
		    rnh, rt->rt_nodes);
		if (rn == NULL && (crt = rtalloc1(ndst, 0)) != NULL) {
			/* overwrite cloned route */
			if ((crt->rt_flags & RTF_CLONED) != 0) {
				rtdeletemsg(crt);
				rn = rnh->rnh_addaddr((caddr_t)ndst,
				    (caddr_t)netmask, rnh, rt->rt_nodes);
			}
			RTFREE(crt);
		}
		if (rn == 0) {
			IFAFREE(ifa);
			if ((rt->rt_flags & RTF_CLONED) != 0 && rt->rt_parent)
				rtfree(rt->rt_parent);
			if (rt->rt_gwroute)
				rtfree(rt->rt_gwroute);
			Free(rt_key(rt));
			Free(rt);
			senderr(EEXIST);
a690 4
		}
		if ((rt->rt_flags & RTF_CLONING) != 0) {
			/* clean up any cloned children */
			rtflushclone(rnh, rt);
@


1.34
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.33 2002/07/11 12:29:03 art Exp $	*/
d137 4
@


1.34.2.1
log
@Pull patch from -current:
Fixed by itojun@@

Fix on-link DoS by bogus ARP. Reported by Apple.

ok itojun@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.34 2002/09/11 05:38:47 itojun Exp $	*/
a141 3
static int rtdeletemsg(struct rtentry *);
static int rtflushclone1(struct radix_node *, void *);
static void rtflushclone(struct radix_node_head *, struct rtentry *);
a451 61
 * Delete a route and generate a message
 */
static int
rtdeletemsg(rt)
	struct rtentry *rt;
{
	int error;
	struct rt_addrinfo info;

	/*
	 * Request the new route so that the entry is not actually
	 * deleted.  That will allow the information being reported to
	 * be accurate (and consistent with route_output()).
	 */
	bzero((caddr_t)&info, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	info.rti_flags = rt->rt_flags;
	error = rtrequest1(RTM_DELETE, &info, &rt);

	rt_missmsg(RTM_DELETE, &info, info.rti_flags, error);

	/* Adjust the refcount */
	if (error == 0 && rt->rt_refcnt <= 0) {
		rt->rt_refcnt++;
		rtfree(rt);
	}
	return (error);
}

static int
rtflushclone1(rn, arg)
	struct radix_node *rn;
	void *arg;
{
	struct rtentry *rt, *parent;

	rt = (struct rtentry *)rn;
	parent = (struct rtentry *)arg;
	if ((rt->rt_flags & RTF_CLONED) != 0 && rt->rt_parent == parent)
		rtdeletemsg(rt);
	return 0;
}

static void
rtflushclone(rnh, parent)
	struct radix_node_head *rnh;
	struct rtentry *parent;
{

#ifdef DIAGNOSTIC
	if (!parent || (parent->rt_flags & RTF_CLONING) == 0)
		panic("rtflushclone: called with a non-cloning route");
	if (!rnh->rnh_walktree)
		panic("rtflushclone: no rnh_walktree");
#endif
	rnh->rnh_walktree(rnh, rtflushclone1, (void *)parent);
}

/*
d598 1
a598 1
	register struct rtentry *rt, *crt;
a612 5
		rt = (struct rtentry *)rn;
		if ((rt->rt_flags & RTF_CLONING) != 0) {
			/* clean up any cloned children */
			rtflushclone(rnh, rt);
		}
a619 4
		if (rt->rt_parent) {
			rt->rt_parent->rt_refcnt--;
			rt->rt_parent = NULL;
		}
a634 2
		if ((rt->rt_flags & RTF_CLONING) == 0)
			senderr(EINVAL);
d636 1
a636 2
		flags = rt->rt_flags & ~(RTF_CLONING | RTF_STATIC);
		flags |= RTF_CLONED;
d662 9
a680 22
			rt->rt_parent->rt_refcnt++;
		}
		rn = rnh->rnh_addaddr((caddr_t)ndst, (caddr_t)netmask,
		    rnh, rt->rt_nodes);
		if (rn == NULL && (crt = rtalloc1(ndst, 0)) != NULL) {
			/* overwrite cloned route */
			if ((crt->rt_flags & RTF_CLONED) != 0) {
				rtdeletemsg(crt);
				rn = rnh->rnh_addaddr((caddr_t)ndst,
				    (caddr_t)netmask, rnh, rt->rt_nodes);
			}
			RTFREE(crt);
		}
		if (rn == 0) {
			IFAFREE(ifa);
			if ((rt->rt_flags & RTF_CLONED) != 0 && rt->rt_parent)
				rtfree(rt->rt_parent);
			if (rt->rt_gwroute)
				rtfree(rt->rt_gwroute);
			Free(rt_key(rt));
			Free(rt);
			senderr(EEXIST);
a686 4
		}
		if ((rt->rt_flags & RTF_CLONING) != 0) {
			/* clean up any cloned children */
			rtflushclone(rnh, rt);
@


1.33
log
@KNF.
From  Lurene Angela Grenier <lurene@@daemonkitty.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.32 2002/06/11 04:27:40 art Exp $	*/
d792 1
a792 1
				return(ENOBUFS);
@


1.32
log
@sprinkle splasserts where function comments tell us to.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.31 2002/06/07 18:30:11 art Exp $	*/
d148 1
a148 1
	return TAILQ_FIRST(&encif.if_addrlist);
d158 1
a158 1
	for (dom = domains; dom; dom = dom->dom_next)
d187 1
a187 1
		return 1;
d189 2
a190 2
		return 1;
	return 0;
d540 1
a540 1
	return rtrequest1(req, &info, ret_nrt);
d747 1
a747 1
	return 0;
d959 1
a959 1
	return rtq->rtq_count;
@


1.31
log
@There is absolutely no need to protect a reference to mono_time.tv_sec with splclock.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.30 2002/05/31 05:00:26 itojun Exp $	*/
d362 2
@


1.30
log
@revert incorrect rmx_mtu handling in 1.16 and 1.24.
do not try to copy if_mtu to rmx_mtu, as if_mtu can change via SIOCSIFMTU.
(as a result, rmx_mtu will be 0 most of the time)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.29 2002/03/14 01:27:10 millert Exp $	*/
a988 1
	int s;
a989 1
	s = splclock();
a990 1
	splx(s);
a1044 1
	s = splclock();
a1045 1
	splx(s);
@


1.29
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.28 2002/01/23 00:39:48 art Exp $	*/
a678 8
		} else if (!rt->rt_rmx.rmx_mtu &&
		    !(rt->rt_rmx.rmx_locks & RTV_MTU)) { /* XXX */
			if (rt->rt_gwroute) {
				rt->rt_rmx.rmx_mtu =
				    rt->rt_gwroute->rt_rmx.rmx_mtu;
			} else {
				rt->rt_rmx.rmx_mtu = ifa->ifa_ifp->if_mtu;
			}
d736 2
d740 2
a741 2
		    (rt->rt_rmx.rmx_mtu == 0 ||
		     rt->rt_rmx.rmx_mtu > rt->rt_gwroute->rt_rmx.rmx_mtu)) {
a834 1
			rt->rt_rmx.rmx_mtu = ifa->ifa_ifp->if_mtu;	/*XXX*/
@


1.28
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.27 2001/12/18 23:07:49 deraadt Exp $	*/
d141 1
a141 1
static int okaytoclone __P((u_int, int));
d991 1
a991 1
	void(*func) __P((struct rtentry *, struct rttimer *));
@


1.27
log
@NRL license cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.26 2001/12/10 06:10:53 jason Exp $	*/
d889 1
a889 1
	    0, NULL, NULL, M_RTABLE);
@


1.27.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.28 2002/01/23 00:39:48 art Exp $	*/
d889 1
a889 1
	    NULL);
@


1.27.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.27.2.1 2002/01/31 22:55:44 niklas Exp $	*/
d141 1
a141 1
static int okaytoclone(u_int, int);
d679 8
a743 2
		 * Note that, if the MTU of gateway is 0, we will reset the
		 * MTU of the route to run PMTUD again from scratch. XXX
d746 2
a747 2
		    rt->rt_rmx.rmx_mtu &&
		    rt->rt_rmx.rmx_mtu > rt->rt_gwroute->rt_rmx.rmx_mtu) {
d841 1
d991 1
a991 1
	void(*func)(struct rtentry *, struct rttimer *);
d996 1
d998 1
d1000 1
d1055 1
d1057 1
@


1.27.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.27.2.2 2002/06/11 03:30:46 art Exp $	*/
d148 1
a148 1
	return (TAILQ_FIRST(&encif.if_addrlist));
d158 1
a158 1
	for (dom = domains; dom != NULL; dom = dom->dom_next)
d187 1
a187 1
		return (1);
d189 2
a190 2
		return (1);
	return (0);
a362 2
	splassert(IPL_SOFTNET);

d538 1
a538 1
	return (rtrequest1(req, &info, ret_nrt));
d745 1
a745 1
	return (0);
d790 1
a790 1
				return (ENOBUFS);
d957 1
a957 1
	return (rtq->rtq_count);
@


1.27.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a136 4

struct	route_cb route_cb;
struct	rtstat  rtstat;
struct	radix_node_head *rt_tables[AF_MAX+1];
@


1.26
log
@use queue.h macros for TAILQ operations
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.25 2001/07/20 18:46:50 itojun Exp $	*/
d69 38
a106 10
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.25
log
@make equal() macro to check sa_len match, otherwise we will touch
the content of a2 beyond a2->sa_len mistakenly.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.24 2001/01/29 06:33:06 itojun Exp $	*/
d120 1
a120 1
	return encif.if_addrlist.tqh_first;
d253 1
a253 1
				    rt->rt_ifp->if_addrlist.tqh_first->ifa_addr;
@


1.24
log
@cleanup rmx_mtu handling (no #ifdef INET6).  from netbsd.
(same change is in kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.23 2001/01/19 06:37:36 itojun Exp $	*/
d347 3
a349 1
#define	equal(a1, a2) (bcmp((caddr_t)(a1), (caddr_t)(a2), (a1)->sa_len) == 0)
@


1.23
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.22 2000/12/11 07:52:06 itojun Exp $	*/
a629 3
if (!rt->rt_rmx.rmx_mtu && !(rt->rt_rmx.rmx_locks & RTV_MTU)) { /* XXX */
  rt->rt_rmx.rmx_mtu = ifa->ifa_ifp->if_mtu;
}
d649 8
d710 10
a802 6
#ifdef INET6
		/* Initialize Path MTU for IPv6 interface route */
		if (ifa->ifa_addr->sa_family == AF_INET6 &&
		    !rt->rt_rmx.rmx_mtu)
			rt->rt_rmx.rmx_mtu = ifa->ifa_ifp->if_mtu;
#endif /* INET6 */
@


1.22
log
@do not touch region after free
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.21 2000/12/09 03:15:25 itojun Exp $	*/
d246 11
d329 1
a329 1
	register struct rtentry *rt;
d374 2
d377 9
a385 3
			error = rtrequest((int)RTM_ADD, dst, gateway,
				    netmask, flags,
				    (struct rtentry **)0);
d501 64
d590 1
a590 1
			ifa->ifa_rtrequest(RTM_DELETE, rt, SA(NULL));
d611 3
a613 2
		if ((ifa = ifa_ifwithroute(flags, dst, gateway)) == NULL)
			senderr(ENETUNREACH);
d654 1
a654 1
			ifa->ifa_rtrequest(req, rt, SA(ret_nrt ? *ret_nrt : NULL));
d666 7
d744 1
d766 13
a778 4
	error = rtrequest(cmd, dst, ifa->ifa_addr, ifa->ifa_netmask,
			flags | ifa->ifa_flags, &nrt);
	if (m != NULL)
		(void) m_free(m);
d798 1
a798 2
				rt->rt_ifa->ifa_rtrequest(RTM_DELETE, rt,
				    SA(NULL));
d805 1
a805 1
				ifa->ifa_rtrequest(RTM_ADD, rt, SA(NULL));
@


1.21
log
@drop support for RTF_TUNNEL, which has no effect (NRL IPv6)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.20 2000/12/09 03:06:55 itojun Exp $	*/
d837 4
a845 4
		if (r->rtt_queue->rtq_count > 0)
			r->rtt_queue->rtq_count--;
		else
			printf("rt_timer_remove_all: rtq_count reached 0\n");
d872 4
a880 4
			if (r->rtt_queue->rtq_count > 0)
				r->rtt_queue->rtq_count--;
			else
				printf("rt_timer_add: rtq_count reached 0\n");
@


1.20
log
@supply counter for # of routing table timer entries.
(preparation for ICMPv6 too big dos prevention)  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.19 2000/05/21 22:19:07 provos Exp $	*/
d160 1
a160 1
	if (howstrict == ONNET_CLONING && !(flags & (RTF_GATEWAY|RTF_TUNNEL)))
d459 1
a459 1
		if (!(flags & RTF_TUNNEL) && (rt->rt_flags & RTF_GATEWAY) && 
a574 16
#ifdef INET6
		/* If we have a v4_in_v4 or a v4_in_v6 tunnel route
		 * then do some tunnel state (e.g. security state)
		 * initialization.
		 *
		 * Since IPV6 packets flow down this path, we don't
		 * want it using ipv4_tunnelsetup(rt) (since they
		 * have their own ipv6_tunnel_parent/child()
		 * routines which are called ipv6_rtrequest().)
		 *
		 * Thus, we check to see if the packet is to a v4
		 * destination.
		 */
		if (dst->sa_family == AF_INET && (rt->rt_flags & RTF_TUNNEL))
			ipv4_tunnelsetup(rt);
#endif /* INET6 */
a579 11
}

/*
 * Set up any tunnel states (e.g. security) information
 * for v4_in_v4 or v4_in_v6 tunnel routes.
 */
void
ipv4_tunnelsetup(rt)
	register struct rtentry *rt;
{
	/* XXX */
@


1.19
log
@deleting some routes created by imcp redirects could result in panic
fix from NetBSD:
Delay clearing of RTF_UP until after deleting rt_gwroute.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.18 2000/03/23 16:37:52 art Exp $	*/
d798 1
d801 1
a816 1

d834 4
d847 8
d869 4
d904 4
d919 1
d927 1
d960 4
@


1.18
log
@New timeout code.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.17 2000/03/22 16:50:24 itojun Exp $	*/
d346 1
a346 1
	 * or the the lookup failed.  This is necessary for hosts
a500 1
		rt->rt_flags &= ~RTF_UP;
d505 1
@


1.18.2.1
log
@Pull in patch from current:
Errata:
Certain routing table modifications by the superuser could cause a
system panic.
Fix (provos):
deleting some routes created by imcp redirects could result in panic
fix from NetBSD:
Delay clearing of RTF_UP until after deleting rt_gwroute.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.19 2000/05/21 22:19:07 provos Exp $	*/
d346 1
a346 1
	 * or the lookup failed.  This is necessary for hosts
d501 1
a505 1
		rt->rt_flags &= ~RTF_UP;
@


1.17
log
@remove bogus comment
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.16 1999/12/08 06:50:18 itojun Exp $	*/
d771 2
d781 2
a782 1
	timeout(rt_timer_timer, NULL, hz);  /* every second */
d914 1
d941 1
a941 1
	timeout(rt_timer_timer, NULL, hz);  /* every second */
@


1.16
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.15 1999/09/13 22:33:51 niklas Exp $	*/
a529 5

		/* The interface found in the previous statement may
		 * be overridden later by rt_setif.  See the code
		 * for case RTM_ADD in rtsock.c:route_output.
		 */
@


1.16.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d530 5
a775 2
	static struct timeout rt_timer_timeout;

d784 1
a784 2
	timeout_set(&rt_timer_timeout, rt_timer_timer, &rt_timer_timeout);
	timeout_add(&rt_timer_timeout, hz);	/* every second */
a915 1
	struct timeout *to = (struct timeout *)arg;
d942 1
a942 1
	timeout_add(to, hz);		/* every second */
@


1.16.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.24 2001/01/29 06:33:06 itojun Exp $	*/
d160 1
a160 1
	if (howstrict == ONNET_CLONING && !(flags & RTF_GATEWAY))
a245 11
			/* Inform listeners of the new route */
			bzero(&info, sizeof(info));
			info.rti_info[RTAX_DST] = rt_key(rt);
			info.rti_info[RTAX_NETMASK] = rt_mask(rt);
			info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
			if (rt->rt_ifp != NULL) {
				info.rti_info[RTAX_IFP] = 
				    rt->rt_ifp->if_addrlist.tqh_first->ifa_addr;
				info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
			}
			rt_missmsg(RTM_ADD, &info, rt->rt_flags, 0);
d318 1
a318 1
	struct rtentry *rt;
d346 1
a346 1
	 * or the lookup failed.  This is necessary for hosts
a362 2
			if (rt)
				rtfree(rt);
d364 3
a366 9
			info.rti_info[RTAX_DST] = dst;
			info.rti_info[RTAX_GATEWAY] = gateway;
			info.rti_info[RTAX_NETMASK] = netmask;
			info.rti_ifa = ifa;
			info.rti_flags = flags;
			rt = NULL;
			error = rtrequest1(RTM_ADD, &info, &rt);
			if (rt != NULL)
				flags = rt->rt_flags;
d459 1
a459 1
		if ((rt->rt_flags & RTF_GATEWAY) &&
a481 64
	struct rt_addrinfo info;

	bzero(&info, sizeof(info));
	info.rti_flags = flags;
	info.rti_info[RTAX_DST] = dst;
	info.rti_info[RTAX_GATEWAY] = gateway;
	info.rti_info[RTAX_NETMASK] = netmask;
	return rtrequest1(req, &info, ret_nrt);
}

/*
 * These (questionable) definitions of apparent local variables apply
 * to the next function.  XXXXXX!!!
 */
#define dst	info->rti_info[RTAX_DST]
#define gateway	info->rti_info[RTAX_GATEWAY]
#define netmask	info->rti_info[RTAX_NETMASK]
#define ifaaddr	info->rti_info[RTAX_IFA]
#define ifpaddr	info->rti_info[RTAX_IFP]
#define flags	info->rti_flags

int
rt_getifa(info)
	struct rt_addrinfo *info;
{
	struct ifaddr *ifa;
	int error = 0;

	/*
	 * ifp may be specified by sockaddr_dl when protocol address
	 * is ambiguous
	 */
	if (info->rti_ifp == NULL && ifpaddr != NULL
	    && ifpaddr->sa_family == AF_LINK &&
	    (ifa = ifa_ifwithnet((struct sockaddr *)ifpaddr)) != NULL)
		info->rti_ifp = ifa->ifa_ifp;
	if (info->rti_ifa == NULL && ifaaddr != NULL)
		info->rti_ifa = ifa_ifwithaddr(ifaaddr);
	if (info->rti_ifa == NULL) {
		struct sockaddr *sa;

		sa = ifaaddr != NULL ? ifaaddr :
		    (gateway != NULL ? gateway : dst);
		if (sa != NULL && info->rti_ifp != NULL)
			info->rti_ifa = ifaof_ifpforaddr(sa, info->rti_ifp);
		else if (dst != NULL && gateway != NULL)
			info->rti_ifa = ifa_ifwithroute(flags, dst, gateway);
		else if (sa != NULL)
			info->rti_ifa = ifa_ifwithroute(flags, sa, sa);
	}
	if ((ifa = info->rti_ifa) != NULL) {
		if (info->rti_ifp == NULL)
			info->rti_ifp = ifa->ifa_ifp;
	} else
		error = ENETUNREACH;
	return (error);
}

int
rtrequest1(req, info, ret_nrt)
	int req;
	struct rt_addrinfo *info;
	struct rtentry **ret_nrt;
{
d501 1
a505 1
		rt->rt_flags &= ~RTF_UP;
d507 1
a507 1
			ifa->ifa_rtrequest(RTM_DELETE, rt, info);
d528 2
a529 3
		if (info->rti_ifa == 0 && (error = rt_getifa(info)))
			senderr(error);
		ifa = info->rti_ifa;
d546 3
a567 8
		} else if (!rt->rt_rmx.rmx_mtu &&
		    !(rt->rt_rmx.rmx_locks & RTV_MTU)) { /* XXX */
			if (rt->rt_gwroute) {
				rt->rt_rmx.rmx_mtu =
				    rt->rt_gwroute->rt_rmx.rmx_mtu;
			} else {
				rt->rt_rmx.rmx_mtu = ifa->ifa_ifp->if_mtu;
			}
d570 1
a570 1
			ifa->ifa_rtrequest(req, rt, info);
d575 16
d598 10
a607 6
#undef dst
#undef gateway
#undef netmask
#undef ifaaddr
#undef ifpaddr
#undef flags
a640 10
		/*
		 * If we switched gateways, grab the MTU from the new
		 * gateway route if the current MTU is 0 or greater
		 * than the MTU of gateway.
		 */
		if (rt->rt_gwroute && !(rt->rt_rmx.rmx_locks & RTV_MTU) &&
		    (rt->rt_rmx.rmx_mtu == 0 ||
		     rt->rt_rmx.rmx_mtu > rt->rt_gwroute->rt_rmx.rmx_mtu)) {
			rt->rt_rmx.rmx_mtu = rt->rt_gwroute->rt_rmx.rmx_mtu;
		}
a679 1
	struct rt_addrinfo info;
d701 4
a704 13
	bzero(&info, sizeof(info));
	info.rti_ifa = ifa;
	info.rti_flags = flags | ifa->ifa_flags;
	info.rti_info[RTAX_DST] = dst;
	info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
	/*
	 * XXX here, it seems that we are assuming that ifa_netmask is NULL
	 * for RTF_HOST.  bsdi4 passes NULL explicitly (via intermediate
	 * variable) when RTF_HOST is 1.  still not sure if i can safely
	 * change it to meet bsdi4 behavior.
	 */
	info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;
	error = rtrequest1(cmd, &info, &nrt);
d714 6
d724 2
a725 1
				rt->rt_ifa->ifa_rtrequest(RTM_DELETE, rt, NULL);
d732 1
a732 1
				ifa->ifa_rtrequest(RTM_ADD, rt, NULL);
a797 1
	Bzero(rtq, sizeof *rtq);
a799 1
	rtq->rtq_count = 0;
d815 1
a832 4
		if (rtq->rtq_count > 0)
			rtq->rtq_count--;
		else
			printf("rt_timer_queue_destroy: rtq_count reached 0\n");
a841 8
unsigned long
rt_timer_count(rtq)
	struct rttimer_queue *rtq;
{

	return rtq->rtq_count;
}

a850 4
		if (r->rtt_queue->rtq_count > 0)
			r->rtt_queue->rtq_count--;
		else
			printf("rt_timer_remove_all: rtq_count reached 0\n");
a881 4
			if (r->rtt_queue->rtq_count > 0)
				r->rtt_queue->rtq_count--;
			else
				printf("rt_timer_add: rtq_count reached 0\n");
a897 1
	Bzero(r, sizeof(*r));
a904 1
	r->rtt_queue->rtq_count++;
a936 4
			if (rtq->rtq_count > 0)
				rtq->rtq_count--;
			else
				printf("rt_timer_timer: rtq_count reached 0\n");
@


1.16.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.16.2.2 2001/05/14 22:40:04 niklas Exp $	*/
d347 1
a347 3
#define	equal(a1, a2) \
	((a1)->sa_len == (a2)->sa_len && \
	 bcmp((caddr_t)(a1), (caddr_t)(a2), (a1)->sa_len) == 0)
@


1.16.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 10
a78 38
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */
d120 1
a120 1
	return TAILQ_FIRST(&encif.if_addrlist);
d253 1
a253 1
				    TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
d861 1
a861 1
	    NULL);
@


1.16.2.5
log
@Merge in -current from roughly a week ago
@
text
@d141 1
a141 1
static int okaytoclone(u_int, int);
d991 1
a991 1
	void(*func)(struct rtentry *, struct rttimer *);
@


1.16.2.6
log
@Sync the SMP branch with 3.3
@
text
@a137 4
struct	route_cb route_cb;
struct	rtstat  rtstat;
struct	radix_node_head *rt_tables[AF_MAX+1];

d148 1
a148 1
	return (TAILQ_FIRST(&encif.if_addrlist));
d158 1
a158 1
	for (dom = domains; dom != NULL; dom = dom->dom_next)
d187 1
a187 1
		return (1);
d189 2
a190 2
		return (1);
	return (0);
a362 2
	splassert(IPL_SOFTNET);

d538 1
a538 1
	return (rtrequest1(req, &info, ret_nrt));
d679 8
a743 2
		 * Note that, if the MTU of gateway is 0, we will reset the
		 * MTU of the route to run PMTUD again from scratch. XXX
d746 2
a747 2
		    rt->rt_rmx.rmx_mtu &&
		    rt->rt_rmx.rmx_mtu > rt->rt_gwroute->rt_rmx.rmx_mtu) {
d751 1
a751 1
	return (0);
d796 1
a796 1
				return (ENOBUFS);
d841 1
d964 1
a964 1
	return (rtq->rtq_count);
d996 1
d998 1
d1000 1
d1055 1
d1057 1
@


1.16.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.16.2.6 2003/03/28 00:41:29 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.16.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a141 3
static int rtdeletemsg(struct rtentry *);
static int rtflushclone1(struct radix_node *, void *);
static void rtflushclone(struct radix_node_head *, struct rtentry *);
d173 1
a173 1
	struct route *ro;
d195 1
a195 1
	struct sockaddr *dst;
d198 3
a200 3
	struct radix_node_head *rnh = rt_tables[dst->sa_family];
	struct rtentry *rt;
	struct radix_node *rn;
d240 1
a240 1
	struct route *ro;
d249 1
a249 1
	struct sockaddr *dst;
d252 3
a254 3
	struct radix_node_head *rnh = rt_tables[dst->sa_family];
	struct rtentry *rt;
	struct radix_node *rn;
d307 1
a307 1
	struct rtentry *rt;
d309 1
a309 1
	struct ifaddr *ifa;
d333 1
a333 1
	struct ifaddr *ifa;
a451 61
 * Delete a route and generate a message
 */
static int
rtdeletemsg(rt)
	struct rtentry *rt;
{
	int error;
	struct rt_addrinfo info;

	/*
	 * Request the new route so that the entry is not actually
	 * deleted.  That will allow the information being reported to
	 * be accurate (and consistent with route_output()).
	 */
	bzero((caddr_t)&info, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	info.rti_flags = rt->rt_flags;
	error = rtrequest1(RTM_DELETE, &info, &rt);

	rt_missmsg(RTM_DELETE, &info, info.rti_flags, error);

	/* Adjust the refcount */
	if (error == 0 && rt->rt_refcnt <= 0) {
		rt->rt_refcnt++;
		rtfree(rt);
	}
	return (error);
}

static int
rtflushclone1(rn, arg)
	struct radix_node *rn;
	void *arg;
{
	struct rtentry *rt, *parent;

	rt = (struct rtentry *)rn;
	parent = (struct rtentry *)arg;
	if ((rt->rt_flags & RTF_CLONED) != 0 && rt->rt_parent == parent)
		rtdeletemsg(rt);
	return 0;
}

static void
rtflushclone(rnh, parent)
	struct radix_node_head *rnh;
	struct rtentry *parent;
{

#ifdef DIAGNOSTIC
	if (!parent || (parent->rt_flags & RTF_CLONING) == 0)
		panic("rtflushclone: called with a non-cloning route");
	if (!rnh->rnh_walktree)
		panic("rtflushclone: no rnh_walktree");
#endif
	rnh->rnh_walktree(rnh, rtflushclone1, (void *)parent);
}

/*
d468 1
a468 1
	struct ifaddr *ifa;
d598 3
a600 3
	struct rtentry *rt, *crt;
	struct radix_node *rn;
	struct radix_node_head *rnh;
a612 5
		rt = (struct rtentry *)rn;
		if ((rt->rt_flags & RTF_CLONING) != 0) {
			/* clean up any cloned children */
			rtflushclone(rnh, rt);
		}
a619 4
		if (rt->rt_parent) {
			rt->rt_parent->rt_refcnt--;
			rt->rt_parent = NULL;
		}
a634 2
		if ((rt->rt_flags & RTF_CLONING) == 0)
			senderr(EINVAL);
d636 1
a636 2
		flags = rt->rt_flags & ~(RTF_CLONING | RTF_STATIC);
		flags |= RTF_CLONED;
d662 9
a680 22
			rt->rt_parent->rt_refcnt++;
		}
		rn = rnh->rnh_addaddr((caddr_t)ndst, (caddr_t)netmask,
		    rnh, rt->rt_nodes);
		if (rn == NULL && (crt = rtalloc1(ndst, 0)) != NULL) {
			/* overwrite cloned route */
			if ((crt->rt_flags & RTF_CLONED) != 0) {
				rtdeletemsg(crt);
				rn = rnh->rnh_addaddr((caddr_t)ndst,
				    (caddr_t)netmask, rnh, rt->rt_nodes);
			}
			RTFREE(crt);
		}
		if (rn == 0) {
			IFAFREE(ifa);
			if ((rt->rt_flags & RTF_CLONED) != 0 && rt->rt_parent)
				rtfree(rt->rt_parent);
			if (rt->rt_gwroute)
				rtfree(rt->rt_gwroute);
			Free(rt_key(rt));
			Free(rt);
			senderr(EEXIST);
a687 4
		if ((rt->rt_flags & RTF_CLONING) != 0) {
			/* clean up any cloned children */
			rtflushclone(rnh, rt);
		}
d709 1
a709 1
	struct rtentry *rt = rt0;
d754 3
a756 3
	u_char *cp1 = (u_char *)src;
	u_char *cp2 = (u_char *)dst;
	u_char *cp3 = (u_char *)netmask;
d776 1
a776 1
	struct ifaddr *ifa;
d779 3
a781 3
	struct rtentry *rt;
	struct sockaddr *dst;
	struct sockaddr *deldst;
@


1.16.2.9
log
@Merge with the trunk
@
text
@d675 1
a675 16
		if ((rn = rnh->rnh_lookup(dst, netmask, rnh)) == NULL)
			senderr(ESRCH);
		rt = (struct rtentry *)rn;
#ifndef SMALL_KERNEL
		/*
		 * if we got multipath routes, we require users to specify
		 * a matching RTAX_GATEWAY.
		 */
		if (rn_mpath_capable(rnh)) {
			rt = rt_mpath_matchgate(rt, gateway);
			rn = (struct radix_node *)rt;
			if (!rt)
				senderr(ESRCH);
		}
#endif
		if ((rn = rnh->rnh_deladdr(dst, netmask, rnh, rn)) == NULL)
a737 11
#ifndef SMALL_KERNEL
		/* do not permit exactly the same dst/mask/gw pair */
		if (rn_mpath_capable(rnh) &&
		    rt_mpath_conflict(rnh, rt, netmask)) {
			if (rt->rt_gwroute)
				rtfree(rt->rt_gwroute);
			Free(rt_key(rt));
			Free(rt);
			senderr(EEXIST);
		}
#endif
@


1.16.2.10
log
@sync to head
@
text
@a140 3
const struct sockaddr_rtin rt_defmask4 = { /* default IPv4 route mask */
            offsetof(struct sockaddr_rtin, rtin_src), 0, 0, { -1 }};

d671 2
a672 8
	if (flags & RTF_HOST) {
#ifdef SMALL_KERNEL
		netmask = (dst->sa_family == AF_INET) ? 
		    (struct sockaddr *)&rt_defmask4 : NULL;
#else
		sroute_verify_host(info);
#endif
	}
d729 1
a729 2
#ifdef SMALL_KERNEL
		if ((netmask = rt->rt_genmask) == NULL) {
a730 6
			if (dst->sa_family == AF_INET)
				netmask = (struct sockaddr *)&rt_defmask4;
		}
#else
		sroute_clone_route(info, rt_mask(rt), rt->rt_genmask);
#endif
@


1.15
log
@enc0 not encap0
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.14 1999/07/05 20:17:05 deraadt Exp $	*/
d5 29
d89 1
d283 1
d530 5
d541 1
d551 3
d689 3
a691 1
			m = m_get(M_WAIT, MT_SONAME);
d734 1
d742 201
@


1.14
log
@remove bogus entry from if_enc address list; and rename enc_softc to encif
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.13 1999/02/25 18:56:48 angelos Exp $	*/
d393 1
a393 1
	 * encap0.
@


1.13
log
@missing ifdef IPSEC
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.12 1999/02/24 22:35:23 angelos Exp $	*/
d75 1
a75 1
extern struct ifnet enc_softc; 
d90 1
a90 1
	return enc_softc.if_addrlist.tqh_first;
@


1.12
log
@Work with pfkey instead of pfencap
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.11 1999/02/05 01:57:32 angelos Exp $	*/
d85 2
d90 1
a90 1
    return enc_softc.if_addrlist.tqh_first;
d92 2
@


1.11
log
@Don't count IPsec-related "route misses", as we're not really finding
unreachable hosts/networks.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.10 1999/02/04 00:54:03 deraadt Exp $	*/
d73 3
a75 1
#include <net/encap.h>
d85 6
d215 1
a215 1
		if (dst->sa_family != AF_ENCAP)
d222 1
a222 1
	miss:	if (report && dst->sa_family != AF_ENCAP) {
d386 1
a386 1
	 * If the destination is a AF_ENCAP address, we'll look
d391 1
a391 1
	if (dst && (dst->sa_family == AF_ENCAP))
@


1.10
log
@deal with rts_* members being u_int32_ now; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.9 1999/01/08 00:56:06 deraadt Exp $	*/
d207 2
a208 1
		rtstat.rts_unreach++;
@


1.9
log
@INET6 support; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.7 1997/12/31 04:25:13 mickey Exp $	*/
d276 1
a276 1
	short *stat = NULL;
@


1.8
log
@in ifa_ifwithroute(), ensure we have a route to our gateway, for tunnels; cmetz
@
text
@d39 12
d81 2
d101 64
d241 2
a242 1
		IFAFREE(ifa);
d414 4
d513 5
a517 1
		if (req == RTM_RESOLVE)
d519 2
d527 16
d550 11
d664 6
d674 2
a675 1
			    rt->rt_ifa->ifa_rtrequest(RTM_DELETE, rt, SA(NULL));
d681 1
a681 1
			    ifa->ifa_rtrequest(RTM_ADD, rt, SA(NULL));
@


1.7
log
@use NULL for pointers, not (cast)(0); clandestine ones
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.6 1997/12/31 04:19:03 mickey Exp $	*/
d331 1
a331 1
		struct rtentry *rt = rtalloc1(dst, 0);
@


1.6
log
@NULL is not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.5 1997/09/21 03:52:42 niklas Exp $	*/
d115 2
a116 2
			err = rtrequest(RTM_RESOLVE, dst, SA(0),
			    SA(0), 0, &newrt);
d369 1
a369 1
		if ((rn = rnh->rnh_deladdr(dst, netmask, rnh)) == 0)
d377 1
a377 1
			(rt = (struct rtentry *)rn)->rt_gwroute = 0;
d380 1
a380 1
			ifa->ifa_rtrequest(RTM_DELETE, rt, SA(0));
d552 1
a552 1
			    rt->rt_ifa->ifa_rtrequest(RTM_DELETE, rt, SA(0));
d558 1
a558 1
			    ifa->ifa_rtrequest(RTM_ADD, rt, SA(0));
@


1.5
log
@Do not report RTM_MISS up on IP encapsulation implicit lookups.  This should
fix RARP as well as improving performance.  Chances are that it will fix
an error having to do with renumbering net interfaces too.  Thanks to
Angelos and Theo for help with the fix, and Martin and Phil for reassuring
it was a general bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.4 1997/07/27 23:30:33 niklas Exp $	*/
d151 1
a151 1
	if (rt == 0)
d197 1
a197 1
	short *stat = 0;
d202 1
a202 1
	if ((ifa = ifa_ifwithnet(gateway)) == 0) {
d217 1
a217 1
	else if (ifa_ifwithaddr(gateway))
d227 1
a227 1
	if ((rt == 0) || (rt_mask(rt) && rt_mask(rt)->sa_len < 2))
d315 1
a315 1
		ifa = 0;
d318 1
a318 1
		if (ifa == 0)
d328 1
a328 1
	if (ifa == 0)
d330 1
a330 1
	if (ifa == 0) {
d332 2
a333 2
		if (rt == 0)
			return (0);
d335 2
a336 2
		if ((ifa = rt->rt_ifa) == 0)
			return (0);
d341 1
a341 1
		if (ifa == 0)
d391 1
a391 1
		if (ret_nrt == 0 || (rt = *ret_nrt) == 0)
d396 1
a396 1
		if ((netmask = rt->rt_genmask) == 0)
d401 1
a401 1
		if ((ifa = ifa_ifwithroute(flags, dst, gateway)) == 0)
d405 1
a405 1
		if (rt == 0)
d420 1
a420 1
		if (rn == 0) {
d433 1
a433 1
			ifa->ifa_rtrequest(req, rt, SA(ret_nrt ? *ret_nrt : 0));
d454 1
a454 1
	if (rt->rt_gateway == 0 || glen > ROUNDUP(rt->rt_gateway->sa_len)) {
d457 1
a457 1
		if (new == 0)
d462 1
a462 1
		old = 0;
d469 5
a473 3
	if (rt->rt_gwroute) {
		rt = rt->rt_gwroute; RTFREE(rt);
		rt = rt0; rt->rt_gwroute = 0;
d513 2
a514 2
	struct mbuf *m = 0;
	struct rtentry *nrt = 0;
d528 1
a528 1
				if (m)
d537 1
a537 1
	if (m)
d539 1
a539 1
	if (cmd == RTM_DELETE && error == 0 && (rt = nrt)) {
d546 1
a546 1
	if (cmd == RTM_ADD && error == 0 && (rt = nrt)) {
@


1.4
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.3 1997/02/20 01:07:43 deraadt Exp $	*/
d116 1
a116 1
					      SA(0), 0, &newrt);
d130 6
a135 1
	miss:	if (report) {
@


1.3
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d359 1
a359 1
		senderr(ESRCH);
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d60 4
d290 12
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: route.c,v 1.13 1995/08/12 23:59:25 mycroft Exp $	*/
d150 1
a150 1
			printf("rtfree: %x not freed (neg refs)\n", rt);
d180 1
a180 1
int
d502 1
a502 1
		if (rt = rtalloc1(dst, 0)) {
d526 2
a527 2
			printf("rtinit: wrong ifa (%x) was (%x)\n", ifa,
				rt->rt_ifa);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
