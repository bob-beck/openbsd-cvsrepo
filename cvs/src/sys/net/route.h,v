head	1.167;
access;
symbols
	OPENBSD_6_2:1.167.0.2
	OPENBSD_6_2_BASE:1.167
	OPENBSD_6_1:1.160.0.4
	OPENBSD_6_1_BASE:1.160
	OPENBSD_6_0:1.141.0.4
	OPENBSD_6_0_BASE:1.141
	OPENBSD_5_9:1.132.0.2
	OPENBSD_5_9_BASE:1.132
	OPENBSD_5_8:1.109.0.4
	OPENBSD_5_8_BASE:1.109
	OPENBSD_5_7:1.105.0.2
	OPENBSD_5_7_BASE:1.105
	OPENBSD_5_6:1.95.0.4
	OPENBSD_5_6_BASE:1.95
	OPENBSD_5_5:1.87.0.4
	OPENBSD_5_5_BASE:1.87
	OPENBSD_5_4:1.78.0.4
	OPENBSD_5_4_BASE:1.78
	OPENBSD_5_3:1.78.0.2
	OPENBSD_5_3_BASE:1.78
	OPENBSD_5_2:1.76.0.2
	OPENBSD_5_2_BASE:1.76
	OPENBSD_5_1_BASE:1.75
	OPENBSD_5_1:1.75.0.6
	OPENBSD_5_0:1.75.0.4
	OPENBSD_5_0_BASE:1.75
	OPENBSD_4_9:1.75.0.2
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.72.0.2
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.66.0.2
	OPENBSD_4_7_BASE:1.66
	OPENBSD_4_6:1.63.0.4
	OPENBSD_4_6_BASE:1.63
	OPENBSD_4_5:1.59.0.2
	OPENBSD_4_5_BASE:1.59
	OPENBSD_4_4:1.51.0.2
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.6
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.46.0.4
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.167
date	2017.08.02.08.38.28;	author mpi;	state Exp;
branches;
next	1.166;
commitid	0t5KqFfZST8egyUb;

1.166
date	2017.07.30.18.18.08;	author florian;	state Exp;
branches;
next	1.165;
commitid	y8TT4YTxTvaF1bH8;

1.165
date	2017.07.30.18.16.14;	author florian;	state Exp;
branches;
next	1.164;
commitid	z0X2vKcxAWZuAxov;

1.164
date	2017.07.28.09.01.09;	author mpi;	state Exp;
branches;
next	1.163;
commitid	iy2G1kqVrXelHlw4;

1.163
date	2017.07.24.09.20.32;	author mpi;	state Exp;
branches;
next	1.162;
commitid	pypIK0AyzCYk4rbB;

1.162
date	2017.06.09.12.56.43;	author mpi;	state Exp;
branches;
next	1.161;
commitid	QXIy2rZA5FPYfFIG;

1.161
date	2017.05.21.16.33.53;	author jca;	state Exp;
branches;
next	1.160;
commitid	tvczjCIL8yXrPAUW;

1.160
date	2017.03.07.09.23.27;	author mpi;	state Exp;
branches;
next	1.159;
commitid	ilH9l7TRBZ95J9uu;

1.159
date	2017.03.06.08.56.39;	author mpi;	state Exp;
branches;
next	1.158;
commitid	aDXuIkVsOPuafbD0;

1.158
date	2017.03.03.15.48.02;	author bluhm;	state Exp;
branches;
next	1.157;
commitid	LtQeAWkATeJFPv2t;

1.157
date	2017.03.02.17.09.21;	author krw;	state Exp;
branches;
next	1.156;
commitid	8FJMneZtCagt8T1v;

1.156
date	2017.01.23.00.59.22;	author krw;	state Exp;
branches;
next	1.155;
commitid	PHzvV9N7VZRwbhtN;

1.155
date	2017.01.23.00.16.31;	author krw;	state Exp;
branches;
next	1.154;
commitid	GBTWCqJdzZicahE3;

1.154
date	2017.01.23.00.12.52;	author krw;	state Exp;
branches;
next	1.153;
commitid	WA0S3lsYYd8plEHP;

1.153
date	2017.01.22.03.47.20;	author krw;	state Exp;
branches;
next	1.152;
commitid	c0n2KkzMm9AhdPwI;

1.152
date	2017.01.20.08.10.54;	author dlg;	state Exp;
branches;
next	1.151;
commitid	CNOX7FmsAKFjfz9O;

1.151
date	2017.01.19.23.18.29;	author phessler;	state Exp;
branches;
next	1.150;
commitid	blN5b1tPhlkhcTy8;

1.150
date	2017.01.19.02.55.18;	author phessler;	state Exp;
branches;
next	1.149;
commitid	FEEIT8B0KV20os2Y;

1.149
date	2016.11.21.10.30.42;	author mpi;	state Exp;
branches;
next	1.148;
commitid	dsunvxH1DSUUN1eT;

1.148
date	2016.09.24.19.27.10;	author phessler;	state Exp;
branches;
next	1.147;
commitid	xFHL1u2ecZCDed8g;

1.147
date	2016.09.04.10.32.01;	author mpi;	state Exp;
branches;
next	1.146;
commitid	0JNLzz71W0Jm1WWQ;

1.146
date	2016.09.04.09.39.01;	author claudio;	state Exp;
branches;
next	1.145;
commitid	WcOp57BWVEJv93S4;

1.145
date	2016.09.03.14.20.26;	author phessler;	state Exp;
branches;
next	1.144;
commitid	m9T2f1BYzcUNRKPY;

1.144
date	2016.08.31.21.32.06;	author bluhm;	state Exp;
branches;
next	1.143;
commitid	KxHBN8DDpvk5Wp6b;

1.143
date	2016.08.31.08.13.49;	author mpi;	state Exp;
branches;
next	1.142;
commitid	13bALUZw6hgsynBo;

1.142
date	2016.08.22.16.01.52;	author mpi;	state Exp;
branches;
next	1.141;
commitid	Jx7agqiuXqs8RRGd;

1.141
date	2016.07.13.08.40.46;	author mpi;	state Exp;
branches;
next	1.140;
commitid	VkTTZG0LgjCK3eLa;

1.140
date	2016.07.11.13.06.31;	author bluhm;	state Exp;
branches;
next	1.139;
commitid	s9vCFtJQBVcyR7KD;

1.139
date	2016.07.11.09.23.06;	author mpi;	state Exp;
branches;
next	1.138;
commitid	Z6QboMLW08GSdJ1F;

1.138
date	2016.06.14.09.48.52;	author mpi;	state Exp;
branches;
next	1.137;
commitid	dn8iB9zOSqejUgHj;

1.137
date	2016.06.14.09.44.41;	author mpi;	state Exp;
branches;
next	1.136;
commitid	jROApUVEsAXWIH7k;

1.136
date	2016.06.03.02.56.59;	author dlg;	state Exp;
branches;
next	1.135;
commitid	HDQtg6ec5B2YoCBq;

1.135
date	2016.04.27.14.47.27;	author mpi;	state Exp;
branches;
next	1.134;
commitid	ZVQDfnkyjDaQ3PD4;

1.134
date	2016.03.30.10.13.14;	author mpi;	state Exp;
branches;
next	1.133;
commitid	xpsJgMCf9pVyesEt;

1.133
date	2016.03.26.21.56.04;	author mpi;	state Exp;
branches;
next	1.132;
commitid	vJtQRrj5mFxFKXT0;

1.132
date	2016.02.24.22.41.53;	author mpi;	state Exp;
branches;
next	1.131;
commitid	eJx9U9f0eROcBU02;

1.131
date	2016.01.18.15.38.52;	author mpi;	state Exp;
branches;
next	1.130;
commitid	wTiB8mlj2Llq0CHS;

1.130
date	2015.12.03.21.57.59;	author mpi;	state Exp;
branches;
next	1.129;
commitid	nmbu8xP0zmz2PPN0;

1.129
date	2015.12.03.16.27.32;	author mpi;	state Exp;
branches;
next	1.128;
commitid	wK6td35Fr7xdNzh3;

1.128
date	2015.12.03.14.26.27;	author mpi;	state Exp;
branches;
next	1.127;
commitid	8hGelczr1KICPBjU;

1.127
date	2015.12.03.14.19.55;	author mpi;	state Exp;
branches;
next	1.126;
commitid	Hw0CeagIhkCLzao6;

1.126
date	2015.12.02.16.35.53;	author bluhm;	state Exp;
branches;
next	1.125;
commitid	i3XNpYhaQ8QndxLo;

1.125
date	2015.12.02.13.29.26;	author claudio;	state Exp;
branches;
next	1.124;
commitid	Hf3C2AvfIXmCAmHE;

1.124
date	2015.12.02.09.17.47;	author mpi;	state Exp;
branches;
next	1.123;
commitid	qJCvM1BEJpKmZS7r;

1.123
date	2015.12.01.21.26.43;	author mpi;	state Exp;
branches;
next	1.122;
commitid	XfTOZsoiIJCcV93d;

1.122
date	2015.11.29.16.02.18;	author mpi;	state Exp;
branches;
next	1.121;
commitid	naczucYAeKE2Fq3l;

1.121
date	2015.11.09.10.26.26;	author mpi;	state Exp;
branches;
next	1.120;
commitid	xyXAt3vnFrCMLsjZ;

1.120
date	2015.11.06.17.55.55;	author mpi;	state Exp;
branches;
next	1.119;
commitid	rF3eCQCnoqyAKLl5;

1.119
date	2015.11.06.17.44.45;	author mpi;	state Exp;
branches;
next	1.118;
commitid	ovggDYXsChxiUYyD;

1.118
date	2015.10.30.09.39.42;	author bluhm;	state Exp;
branches;
next	1.117;
commitid	7wrRch1SS813fOcY;

1.117
date	2015.10.25.10.05.09;	author bluhm;	state Exp;
branches;
next	1.116;
commitid	X8Mu7F8ZYc1VV9Gs;

1.116
date	2015.10.24.11.47.07;	author mpi;	state Exp;
branches;
next	1.115;
commitid	qL0KYhN6NIpLQLwa;

1.115
date	2015.10.07.10.50.35;	author mpi;	state Exp;
branches;
next	1.114;
commitid	hPrd2a6fiZdlN2yP;

1.114
date	2015.10.03.18.57.11;	author renato;	state Exp;
branches;
next	1.113;
commitid	0rggjTKo2BkzYtPe;

1.113
date	2015.09.11.21.27.49;	author mpi;	state Exp;
branches;
next	1.112;
commitid	sZFeO2s9E0qmoH0K;

1.112
date	2015.09.11.16.58.00;	author mpi;	state Exp;
branches;
next	1.111;
commitid	aN3TroyZ9FVMndjv;

1.111
date	2015.09.01.12.50.03;	author mpi;	state Exp;
branches;
next	1.110;
commitid	0rQttR3JylvtHQ0K;

1.110
date	2015.08.20.12.39.43;	author mpi;	state Exp;
branches;
next	1.109;
commitid	9IUogeilRo73xUDL;

1.109
date	2015.07.18.15.51.16;	author mpi;	state Exp;
branches;
next	1.108;
commitid	lwQKRpFyNEr7kjoF;

1.108
date	2015.07.08.07.56.51;	author mpi;	state Exp;
branches;
next	1.107;
commitid	2410UDx2ojGksNwU;

1.107
date	2015.07.08.07.29.24;	author mpi;	state Exp;
branches;
next	1.106;
commitid	0FBc9JpvVcOPHG4o;

1.106
date	2015.05.05.09.41.43;	author mpi;	state Exp;
branches;
next	1.105;
commitid	5XGj7KJrHBHsoubn;

1.105
date	2015.02.11.23.34.43;	author mpi;	state Exp;
branches;
next	1.104;
commitid	LEl6vk7rMjn9Mb2M;

1.104
date	2015.01.13.12.14.00;	author mpi;	state Exp;
branches;
next	1.103;
commitid	lUGbXdgL8k5aX0xx;

1.103
date	2015.01.08.15.05.44;	author mpi;	state Exp;
branches;
next	1.102;
commitid	56pEz00yDFZe07F8;

1.102
date	2015.01.08.14.29.18;	author mpi;	state Exp;
branches;
next	1.101;
commitid	WNXddVtZkuvCWdN4;

1.101
date	2014.11.24.12.43.54;	author mpi;	state Exp;
branches;
next	1.100;
commitid	xHA3kihmdbMHtfu3;

1.100
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.99;
commitid	w0MRp28dmfD1ZzO8;

1.99
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.98;
commitid	6AYfDT0Lpez1LFQp;

1.98
date	2014.10.08.07.37.02;	author mpi;	state Exp;
branches;
next	1.97;
commitid	Zq5kNn2HIZzyRxfQ;

1.97
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.96;
commitid	HQcmytntiCJTHORs;

1.96
date	2014.08.12.13.52.08;	author mpi;	state Exp;
branches;
next	1.95;
commitid	DfLTdnrRvTfPSDCZ;

1.95
date	2014.07.29.12.18.41;	author mpi;	state Exp;
branches;
next	1.94;
commitid	QxM5HLkQs10iEeT9;

1.94
date	2014.05.09.09.23.56;	author mpi;	state Exp;
branches;
next	1.93;

1.93
date	2014.05.08.09.28.08;	author mpi;	state Exp;
branches;
next	1.92;

1.92
date	2014.04.25.10.41.09;	author mpi;	state Exp;
branches;
next	1.91;

1.91
date	2014.04.10.13.47.21;	author mpi;	state Exp;
branches;
next	1.90;

1.90
date	2014.04.03.08.22.10;	author mpi;	state Exp;
branches;
next	1.89;

1.89
date	2014.03.21.10.44.42;	author mpi;	state Exp;
branches;
next	1.88;

1.88
date	2014.03.18.10.47.34;	author mpi;	state Exp;
branches;
next	1.87;

1.87
date	2014.01.23.10.16.30;	author mpi;	state Exp;
branches;
next	1.86;

1.86
date	2014.01.22.06.28.09;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2014.01.20.22.44.41;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2014.01.20.22.11.42;	author bluhm;	state Exp;
branches;
next	1.83;

1.83
date	2013.10.31.18.10.21;	author bluhm;	state Exp;
branches;
next	1.82;

1.82
date	2013.10.24.18.50.16;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2013.10.24.11.14.35;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2013.10.20.13.21.57;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2013.10.20.12.35.47;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2012.09.19.16.14.01;	author blambert;	state Exp;
branches;
next	1.77;

1.77
date	2012.09.19.12.35.07;	author blambert;	state Exp;
branches;
next	1.76;

1.76
date	2012.03.17.10.16.41;	author dlg;	state Exp;
branches;
next	1.75;

1.75
date	2010.10.28.17.18.35;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2010.10.11.11.41.08;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2010.08.25.14.07.24;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2010.07.14.00.42.57;	author dlg;	state Exp;
branches;
next	1.71;

1.71
date	2010.07.09.15.44.20;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2010.06.29.21.28.37;	author reyk;	state Exp;
branches;
next	1.69;

1.69
date	2010.06.28.18.50.37;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2010.04.21.11.52.46;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2010.02.09.16.31.14;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2009.09.17.13.27.24;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2009.05.26.08.29.44;	author reyk;	state Exp;
branches;
next	1.61;

1.61
date	2009.05.18.20.37.13;	author bluhm;	state Exp;
branches;
next	1.60;

1.60
date	2009.03.31.01.31.26;	author dlg;	state Exp;
branches;
next	1.59;

1.59
date	2009.02.03.16.42.54;	author michele;	state Exp;
branches;
next	1.58;

1.58
date	2009.01.28.22.18.44;	author michele;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.28.12.34.09;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.08.12.47.45;	author michele;	state Exp;
branches;
next	1.55;

1.55
date	2008.12.12.22.07.33;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2008.11.24.12.53.53;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2008.11.07.19.09.03;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.15.20.11.05;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.08.19.12.28;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2008.05.07.05.14.21;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2008.04.23.10.55.14;	author norby;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.03.15.24.49;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2006.06.18.11.47.45;	author pascoe;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.16.16.52.08;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.16.16.49.39;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2006.06.15.16.33.02;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.06.15.36.07;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2006.06.01.05.21.06;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.31.01.35.11;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.22.19.43.07;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.30.09.53.43;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.22.14.37.44;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.20.10.03.49;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.23.14.15.53;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.29.02.59.42;	author jolan;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.27.16.22.45;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.25.13.45.02;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.25.19.25.06;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.08.06.43.07;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.27.17.18.20;	author mcbride;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.27.04.55.27;	author mcbride;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.26.22.37.34;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.16.22.31.30;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.16.00.21.11;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.03.11.22.15;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.19.19.55.53;	author cedric;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.06.16.49.09;	author cedric;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.04.22.50.18;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.25.02.48.04;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.15.10.47.55;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.26.08.33.12;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2003.01.17.17.48.25;	author camield;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.16.10;	author millert;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.09.06.16.39;	author angelos;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.01.19.06.37.36;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.09.03.15.25;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.09.03.06.55;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.17.00.21.12;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.05.16.00.34.40;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	99.02.04.00.04.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.01.08.00.56.06;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.02.22.01.23.29;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.21.07.20;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.40.04;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.54.19;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.7.2.8;

1.7.2.8
date	2004.06.07.20.41.38;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;

1.14.4.1
date	2003.10.01.22.53.34;	author brad;	state Exp;
branches;
next	;

1.16.2.1
date	2003.10.01.20.36.55;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.167
log
@Fix rtable regression tests.
@
text
@/*	$OpenBSD: route.h,v 1.166 2017/07/30 18:18:08 florian Exp $	*/
/*	$NetBSD: route.h,v 1.9 1996/02/13 22:00:49 christos Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)route.h	8.3 (Berkeley) 4/19/94
 */

#ifndef _NET_ROUTE_H_
#define _NET_ROUTE_H_

/*
 * Kernel resident routing tables.
 *
 * The routing tables are initialized when interface addresses
 * are set by making entries for all directly connected interfaces.
 */

/*
 * These numbers are used by reliable protocols for determining
 * retransmission behavior and are included in the routing structure.
 */
struct rt_kmetrics {
	u_int64_t	rmx_pksent;	/* packets sent using this route */
	int64_t		rmx_expire;	/* lifetime for route, e.g. redirect */
	u_int		rmx_locks;	/* Kernel must leave these values */
	u_int		rmx_mtu;	/* MTU for this path */
};

/*
 * Huge version for userland compatibility.
 */
struct rt_metrics {
	u_int64_t	rmx_pksent;	/* packets sent using this route */
	int64_t		rmx_expire;	/* lifetime for route, e.g. redirect */
	u_int		rmx_locks;	/* Kernel must leave these values */
	u_int		rmx_mtu;	/* MTU for this path */
	u_int		rmx_refcnt;	/* # references hold */
	/* some apps may still need these no longer used metrics */
	u_int		rmx_hopcount;	/* max hops expected */
	u_int		rmx_recvpipe;	/* inbound delay-bandwidth product */
	u_int		rmx_sendpipe;	/* outbound delay-bandwidth product */
	u_int		rmx_ssthresh;	/* outbound gateway buffer limit */
	u_int		rmx_rtt;	/* estimated round trip time */
	u_int		rmx_rttvar;	/* estimated rtt variance */
	u_int		rmx_pad;
};

/*
 * rmx_rtt and rmx_rttvar are stored as microseconds;
 * RTTTOPRHZ(rtt) converts to a value suitable for use
 * by a protocol slowtimo counter.
 */
#define	RTM_RTTUNIT	1000000	/* units for rtt, rttvar, as units per sec */
#define	RTTTOPRHZ(r)	((r) / (RTM_RTTUNIT / PR_SLOWHZ))

#include <sys/queue.h>
#include <net/rtable.h>

/*
 * We distinguish between routes to hosts and routes to networks,
 * preferring the former if available.  For each route we infer
 * the interface to use from the gateway address supplied when
 * the route was entered.  Routes that forward packets through
 * gateways are marked so that the output routines know to address the
 * gateway rather than the ultimate destination.
 */

struct rtentry {
#if !defined(_KERNEL) && !defined(ART)
	struct	radix_node rt_nodes[2];	/* tree glue, and other values */
#else
	struct sockaddr	*rt_dest;	/* destination */
	SRPL_ENTRY(rtentry) rt_next;	/* Next multipath entry to our dst. */
#endif
	struct sockaddr	*rt_gateway;	/* value */
	struct ifaddr	*rt_ifa;	/* the answer: interface addr to use */
	caddr_t		 rt_llinfo;	/* pointer to link level info cache or
					   to an MPLS structure */
	union {
		struct rtentry	*_nh;	/* implied entry for gatewayed routes */
		unsigned int	 _ref;	/* # gatewayed caching this route */
	} RT_gw;
#define rt_gwroute	 RT_gw._nh
#define rt_cachecnt	 RT_gw._ref
	struct rtentry	*rt_parent;	/* If cloned, parent of this route. */
	LIST_HEAD(, rttimer) rt_timer;  /* queue of timeouts for misc funcs */
	struct rt_kmetrics rt_rmx;	/* metrics used by rx'ing protocols */
	unsigned int	 rt_ifidx;	/* the answer: interface to use */
	unsigned int	 rt_flags;	/* up/down?, host/net */
	int		 rt_refcnt;	/* # held references */
#if defined(_KERNEL) || defined(ART)
	int		 rt_plen;	/* prefix length */
#endif
	uint16_t	 rt_labelid;	/* route label ID */
	uint8_t		 rt_priority;	/* routing priority to use */
};
#define	rt_use		rt_rmx.rmx_pksent
#define	rt_expire	rt_rmx.rmx_expire
#define	rt_locks	rt_rmx.rmx_locks
#define	rt_mtu		rt_rmx.rmx_mtu

/* bitmask values for rtm_flags */
#define	RTF_UP		0x1		/* route usable */
#define	RTF_GATEWAY	0x2		/* destination is a gateway */
#define	RTF_HOST	0x4		/* host entry (net otherwise) */
#define	RTF_REJECT	0x8		/* host or net unreachable */
#define	RTF_DYNAMIC	0x10		/* created dynamically (by redirect) */
#define	RTF_MODIFIED	0x20		/* modified dynamically (by redirect) */
#define RTF_DONE	0x40		/* message confirmed */
#define RTF_CLONING	0x100		/* generate new routes on use */
#define RTF_MULTICAST	0x200		/* route associated to a mcast addr. */
#define RTF_LLINFO	0x400		/* generated by ARP or ND */
#define RTF_STATIC	0x800		/* manually added */
#define RTF_BLACKHOLE	0x1000		/* just discard pkts (during updates) */
#define RTF_PROTO3	0x2000		/* protocol specific routing flag */
#define RTF_PROTO2	0x4000		/* protocol specific routing flag */
#define RTF_ANNOUNCE	RTF_PROTO2	/* announce L2 entry */
#define RTF_PROTO1	0x8000		/* protocol specific routing flag */
#define RTF_CLONED	0x10000		/* this is a cloned route */
#define RTF_CACHED	0x20000		/* cached by a RTF_GATEWAY entry */
#define RTF_MPATH	0x40000		/* multipath route or operation */
#define RTF_MPLS	0x100000	/* MPLS additional infos */
#define RTF_LOCAL	0x200000	/* route to a local address */
#define RTF_BROADCAST	0x400000	/* route associated to a bcast addr. */
#define RTF_CONNECTED	0x800000	/* interface route */
#define RTF_BFD		0x1000000	/* Link state controlled by BFD */

/* mask of RTF flags that are allowed to be modified by RTM_CHANGE */
#define RTF_FMASK	\
    (RTF_LLINFO | RTF_PROTO1 | RTF_PROTO2 | RTF_PROTO3 | RTF_BLACKHOLE | \
     RTF_REJECT | RTF_STATIC | RTF_MPLS | RTF_BFD)

/* Routing priorities used by the different routing protocols */
#define RTP_NONE	0	/* unset priority use sane default */
#define RTP_LOCAL	1	/* local address routes (must be the highest) */
#define RTP_CONNECTED	4	/* directly connected routes */
#define RTP_STATIC	8	/* static routes base priority */
#define RTP_EIGRP	28	/* EIGRP routes */
#define RTP_OSPF	32	/* OSPF routes */
#define RTP_ISIS	36	/* IS-IS routes */
#define RTP_RIP		40	/* RIP routes */
#define RTP_BGP		48	/* BGP routes */
#define RTP_DEFAULT	56	/* routes that have nothing set */
#define RTP_PROPOSAL_STATIC	57
#define RTP_PROPOSAL_DHCLIENT	58
#define RTP_PROPOSAL_SLAAC	59
#define RTP_MAX		63	/* maximum priority */
#define RTP_ANY		64	/* any of the above */
#define RTP_MASK	0x7f
#define RTP_DOWN	0x80	/* route/link is down */

/*
 * Routing statistics.
 */
struct	rtstat {
	u_int32_t rts_badredirect;	/* bogus redirect calls */
	u_int32_t rts_dynamic;		/* routes created by redirects */
	u_int32_t rts_newgateway;	/* routes modified by redirects */
	u_int32_t rts_unreach;		/* lookups which failed */
	u_int32_t rts_wildcard;		/* lookups satisfied by a wildcard */
};

/*
 * Routing Table Info.
 */
struct rt_tableinfo {
	u_short rti_tableid;	/* routing table id */
	u_short rti_domainid;	/* routing domain id */
};

/*
 * Structures for routing messages.
 */
struct rt_msghdr {
	u_short	rtm_msglen;	/* to skip over non-understood messages */
	u_char	rtm_version;	/* future binary compatibility */
	u_char	rtm_type;	/* message type */
	u_short	rtm_hdrlen;	/* sizeof(rt_msghdr) to skip over the header */
	u_short	rtm_index;	/* index for associated ifp */
	u_short rtm_tableid;	/* routing table id */
	u_char	rtm_priority;	/* routing priority */
	u_char	rtm_mpls;	/* MPLS additional infos */
	int	rtm_addrs;	/* bitmask identifying sockaddrs in msg */
	int	rtm_flags;	/* flags, incl. kern & message, e.g. DONE */
	int	rtm_fmask;	/* bitmask used in RTM_CHANGE message */
	pid_t	rtm_pid;	/* identify sender */
	int	rtm_seq;	/* for sender to identify action */
	int	rtm_errno;	/* why failed */
	u_int	rtm_inits;	/* which metrics we are initializing */
	struct	rt_metrics rtm_rmx; /* metrics themselves */
};
/* overload no longer used field */
#define rtm_use	rtm_rmx.rmx_pksent

#define RTM_VERSION	5	/* Up the ante and ignore older versions */

#define RTM_MAXSIZE	2048	/* Maximum size of an accepted route msg */

/* values for rtm_type */
#define RTM_ADD		0x1	/* Add Route */
#define RTM_DELETE	0x2	/* Delete Route */
#define RTM_CHANGE	0x3	/* Change Metrics or flags */
#define RTM_GET		0x4	/* Report Metrics */
#define RTM_LOSING	0x5	/* Kernel Suspects Partitioning */
#define RTM_REDIRECT	0x6	/* Told to use different route */
#define RTM_MISS	0x7	/* Lookup failed on this address */
#define RTM_LOCK	0x8	/* fix specified metrics */
#define RTM_RESOLVE	0xb	/* req to resolve dst to LL addr */
#define RTM_NEWADDR	0xc	/* address being added to iface */
#define RTM_DELADDR	0xd	/* address being removed from iface */
#define RTM_IFINFO	0xe	/* iface going up/down etc. */
#define RTM_IFANNOUNCE	0xf	/* iface arrival/departure */
#define RTM_DESYNC	0x10	/* route socket buffer overflow */
#define RTM_INVALIDATE	0x11	/* Invalidate cache of L2 route */
#define RTM_BFD		0x12	/* bidirectional forwarding detection */
#define RTM_PROPOSAL	0x13	/* proposal for netconfigd */

#define RTV_MTU		0x1	/* init or lock _mtu */
#define RTV_HOPCOUNT	0x2	/* init or lock _hopcount */
#define RTV_EXPIRE	0x4	/* init or lock _expire */
#define RTV_RPIPE	0x8	/* init or lock _recvpipe */
#define RTV_SPIPE	0x10	/* init or lock _sendpipe */
#define RTV_SSTHRESH	0x20	/* init or lock _ssthresh */
#define RTV_RTT		0x40	/* init or lock _rtt */
#define RTV_RTTVAR	0x80	/* init or lock _rttvar */

/*
 * Bitmask values for rtm_addrs.
 */
#define RTA_DST		0x1	/* destination sockaddr present */
#define RTA_GATEWAY	0x2	/* gateway sockaddr present */
#define RTA_NETMASK	0x4	/* netmask sockaddr present */
#define RTA_GENMASK	0x8	/* cloning mask sockaddr present */
#define RTA_IFP		0x10	/* interface name sockaddr present */
#define RTA_IFA		0x20	/* interface addr sockaddr present */
#define RTA_AUTHOR	0x40	/* sockaddr for author of redirect */
#define RTA_BRD		0x80	/* for NEWADDR, broadcast or p-p dest addr */
#define RTA_SRC		0x100	/* source sockaddr present */
#define RTA_SRCMASK	0x200	/* source netmask present */
#define RTA_LABEL	0x400	/* route label present */
#define RTA_BFD		0x800	/* bfd present */
#define RTA_DNS		0x1000	/* DNS Servers sockaddr present */
#define RTA_STATIC	0x2000	/* RFC 3442 encoded static routes present */
#define RTA_SEARCH	0x4000	/* RFC 3397 encoded search path present */

/*
 * Index offsets for sockaddr array for alternate internal encoding.
 */
#define RTAX_DST	0	/* destination sockaddr present */
#define RTAX_GATEWAY	1	/* gateway sockaddr present */
#define RTAX_NETMASK	2	/* netmask sockaddr present */
#define RTAX_GENMASK	3	/* cloning mask sockaddr present */
#define RTAX_IFP	4	/* interface name sockaddr present */
#define RTAX_IFA	5	/* interface addr sockaddr present */
#define RTAX_AUTHOR	6	/* sockaddr for author of redirect */
#define RTAX_BRD	7	/* for NEWADDR, broadcast or p-p dest addr */
#define RTAX_SRC	8	/* source sockaddr present */
#define RTAX_SRCMASK	9	/* source netmask present */
#define RTAX_LABEL	10	/* route label present */
#define RTAX_BFD	11	/* bfd present */
#define RTAX_DNS	12	/* DNS Server(s) sockaddr present */
#define RTAX_STATIC	13	/* RFC 3442 encoded static routes present */
#define RTAX_SEARCH	14	/* RFC 3397 encoded search path present */
#define RTAX_MAX	15	/* size of array to allocate */

/*
 * setsockopt defines used for the filtering.
 */
#define ROUTE_MSGFILTER	1	/* bitmask to specifiy which types should be
				   sent to the client. */
#define ROUTE_TABLEFILTER 2	/* change routing table the socket is listening
				   on, RTABLE_ANY listens on all tables. */

#define ROUTE_FILTER(m)	(1 << (m))
#define RTABLE_ANY	0xffffffff

#define	RTLABEL_LEN	32

struct sockaddr_rtlabel {
	u_int8_t	sr_len;			/* total length */
	sa_family_t	sr_family;		/* address family */
	char		sr_label[RTLABEL_LEN];
};

#define	RTDNS_LEN	128

struct sockaddr_rtdns {
	u_int8_t	sr_len;			/* total length */
	sa_family_t	sr_family;		/* address family */
	char		sr_dns[RTDNS_LEN];
};

#define	RTSTATIC_LEN	128

struct sockaddr_rtstatic {
	u_int8_t	sr_len;			/* total length */
	sa_family_t	sr_family;		/* address family */
	char		sr_static[RTSTATIC_LEN];
};

#define	RTSEARCH_LEN	128

struct sockaddr_rtsearch {
	u_int8_t	sr_len;			/* total length */
	sa_family_t	sr_family;		/* address family */
	char		sr_search[RTSEARCH_LEN];
};

/*
 * A route consists of a destination address and a reference
 * to a routing entry.  These are often held by protocols
 * in their control blocks, e.g. inpcb.
 */
struct route {
	struct	rtentry *ro_rt;
	u_long		 ro_tableid;	/* u_long because of alignment */
	struct	sockaddr ro_dst;
};

struct rt_addrinfo {
	int	rti_addrs;
	struct	sockaddr *rti_info[RTAX_MAX];
	int	rti_flags;
	struct	ifaddr *rti_ifa;
	struct	rt_msghdr *rti_rtm;
	u_char	rti_mpls;
};

#ifdef _KERNEL

#include <sys/percpu.h>

enum rtstat_counters {
	rts_badredirect,	/* bogus redirect calls */
	rts_dynamic,		/* routes created by redirects */
	rts_newgateway,		/* routes modified by redirects */
	rts_unreach,		/* lookups which failed */
	rts_wildcard,		/* lookups satisfied by a wildcard */

	rts_ncounters
};

static inline void
rtstat_inc(enum rtstat_counters c)
{
	extern struct cpumem *rtcounters;

	counters_inc(rtcounters, c);
}

/*
 * This structure, and the prototypes for the rt_timer_{init,remove_all,
 * add,timer} functions all used with the kind permission of BSDI.
 * These allow functions to be called for routes at specific times.
 */
struct rttimer {
	TAILQ_ENTRY(rttimer)	rtt_next;  /* entry on timer queue */
	LIST_ENTRY(rttimer)	rtt_link;  /* multiple timers per rtentry */
	struct rttimer_queue	*rtt_queue;/* back pointer to queue */
	struct rtentry		*rtt_rt;   /* Back pointer to the route */
	void			(*rtt_func)(struct rtentry *,
						 struct rttimer *);
	time_t			rtt_time; /* When this timer was registered */
	u_int			rtt_tableid;	/* routing table id of rtt_rt */
};

struct rttimer_queue {
	long				rtq_timeout;
	unsigned long			rtq_count;
	TAILQ_HEAD(, rttimer)		rtq_head;
	LIST_ENTRY(rttimer_queue)	rtq_link;
};

const char	*rtlabel_id2name(u_int16_t);
u_int16_t	 rtlabel_name2id(char *);
struct sockaddr	*rtlabel_id2sa(u_int16_t, struct sockaddr_rtlabel *);
void		 rtlabel_unref(u_int16_t);

/*
 * Values for additional argument to rtalloc()
 */
#define	RT_RESOLVE	1

extern struct rtstat rtstat;

struct mbuf;
struct socket;
struct ifnet;
struct sockaddr_in6;
struct bfd_config;

void	 route_init(void);
void	 rtm_ifchg(struct ifnet *);
void	 rtm_ifannounce(struct ifnet *, int);
void	 rtm_bfd(struct bfd_config *);
void	 rt_maskedcopy(struct sockaddr *,
	    struct sockaddr *, struct sockaddr *);
struct sockaddr *rt_plen2mask(struct rtentry *, struct sockaddr_in6 *);
void	 rtm_send(struct rtentry *, int, int, unsigned int);
void	 rtm_addr(struct rtentry *, int, struct ifaddr *);
void	 rtm_miss(int, struct rt_addrinfo *, int, uint8_t, u_int, int, u_int);
int	 rt_setgate(struct rtentry *, struct sockaddr *, u_int);
struct rtentry *rt_getll(struct rtentry *);

int			 rt_timer_add(struct rtentry *,
		             void(*)(struct rtentry *, struct rttimer *),
			     struct rttimer_queue *, u_int);
void			 rt_timer_remove_all(struct rtentry *);
struct rttimer_queue	*rt_timer_queue_create(u_int);
void			 rt_timer_queue_change(struct rttimer_queue *, long);
void			 rt_timer_queue_destroy(struct rttimer_queue *);
unsigned long		 rt_timer_queue_count(struct rttimer_queue *);
void			 rt_timer_timer(void *);

int	 rtisvalid(struct rtentry *);
int	 rt_hash(struct rtentry *, struct sockaddr *, uint32_t *);
struct	 rtentry *rtalloc_mpath(struct sockaddr *, uint32_t *, u_int);
struct	 rtentry *rtalloc(struct sockaddr *, int, unsigned int);
void	 rtref(struct rtentry *);
void	 rtfree(struct rtentry *);

int	 rt_ifa_add(struct ifaddr *, int, struct sockaddr *);
int	 rt_ifa_del(struct ifaddr *, int, struct sockaddr *);
void	 rt_ifa_purge(struct ifaddr *);
int	 rt_ifa_addlocal(struct ifaddr *);
int	 rt_ifa_dellocal(struct ifaddr *);
void	 rtredirect(struct sockaddr *, struct sockaddr *, struct sockaddr *, struct rtentry **, unsigned int);
int	 rtrequest(int, struct rt_addrinfo *, u_int8_t, struct rtentry **,
	     u_int);
int	 rtrequest_delete(struct rt_addrinfo *, u_int8_t, struct ifnet *,
	     struct rtentry **, u_int);
void	 rt_if_track(struct ifnet *);
int	 rt_if_linkstate_change(struct rtentry *, void *, u_int);
int	 rtdeletemsg(struct rtentry *, struct ifnet *, u_int);
#endif /* _KERNEL */

#endif /* _NET_ROUTE_H_ */
@


1.166
log
@Enable mpath support in the Allotment Routing Table (ART) on the ramdisk.
OK mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.165 2017/07/30 18:16:14 florian Exp $	*/
d96 1
a96 1
#ifndef _KERNEL
d118 1
a118 1
#ifdef _KERNEL
@


1.165
log
@Switch installer to Allotment Routing Table (ART).
Prompted by a bugreport by naddy that IPv6 autoconfiguration is broken
in the installer.
OK mpi, "go for it" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.164 2017/07/28 09:01:09 mpi Exp $	*/
a443 3
#ifdef SMALL_KERNEL
#define	 rtalloc_mpath(dst, s, rid) rtalloc((dst), RT_RESOLVE, (rid))
#else
a444 1
#endif
a458 1
#ifndef SMALL_KERNEL
a460 1
#endif
@


1.164
log
@Add an error argument to rtm_send() instead of rerolling it inside
rtdeletemsg().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.163 2017/07/24 09:20:32 mpi Exp $	*/
d96 1
a96 1
#ifndef ART
d118 1
a118 1
#ifdef ART
@


1.163
log
@rt_getifa() is only needed for routing commands submited by userland.

So rename it to rtm_getifa(), move it where it belongs and stop calling
it from rtrequest(9).  Route entries created by the kernel must always
specify the corresponding `ifa'.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.162 2017/06/09 12:56:43 mpi Exp $	*/
d426 1
a426 1
void	 rtm_send(struct rtentry *, int, u_int);
@


1.162
log
@Replace rtrequest(RTM_DELETE...) rtrequest_delete() and do not even
try to remove a route from the table if it is and invalid cache.

This is a step towards decoupling code dealing with userland and kernel
inserted routes.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.161 2017/05/21 16:33:53 jca Exp $	*/
a452 1
int	 rt_getifa(struct rt_addrinfo *, u_int);
@


1.161
log
@Fix copy/paste in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.160 2017/03/07 09:23:27 mpi Exp $	*/
d462 2
@


1.160
log
@Do not grab the NET_LOCK() for routing sockets operations.

The only function that need the lock is rtm_output() as it messes with
the routing table.  So grab the lock there since it is safe to sleep
in a process context.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.159 2017/03/06 08:56:39 mpi Exp $	*/
d247 1
a247 1
#define RTV_EXPIRE	0x4	/* init or lock _hopcount */
@


1.159
log
@Prefix functions dealing with routing messages with 'rtm_' and keep
them all in net/rtsock.c.

This allows to easily spot which functions are doing a copyout(9)
when dealing with the routing midlayer.

ok phessler@@, bluhm@@, dhill@@, krw@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.158 2017/03/03 15:48:02 bluhm Exp $	*/
a419 4
int	 route_output(struct mbuf *, struct socket *, struct sockaddr *,
	    struct mbuf *);
int	 route_usrreq(struct socket *, int, struct mbuf *,
			   struct mbuf *, struct mbuf *, struct proc *);
@


1.158
log
@Convert the variable argument list of the pr_output functions to
fixed parameters.
OK mpi@@ claudio@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.157 2017/03/02 17:09:21 krw Exp $	*/
d424 3
a426 3
void	 rt_ifmsg(struct ifnet *);
void	 rt_ifannouncemsg(struct ifnet *, int);
void	 rt_bfdmsg(struct bfd_config *);
d430 3
a432 3
void	 rt_sendmsg(struct rtentry *, int, u_int);
void	 rt_sendaddrmsg(struct rtentry *, int, struct ifaddr *);
void	 rt_missmsg(int, struct rt_addrinfo *, int, uint8_t, u_int, int, u_int);
a434 2
void	 rt_setmetrics(u_long, const struct rt_metrics *, struct rt_kmetrics *);
void	 rt_getmetrics(const struct rt_kmetrics *, struct rt_metrics *);
@


1.157
log
@Implement a new routing message RTM_PROPOSAL that communicates
information that can be used to configure an interface and
related network components.

ok bluhm@@, ok for various older versions mpi@@ florian@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.156 2017/01/23 00:59:22 krw Exp $	*/
d420 2
a421 1
int	 route_output(struct mbuf *, ...);
@


1.156
log
@Add comment above rtm_type #define's.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.155 2017/01/23 00:16:31 krw Exp $	*/
d171 3
d243 1
d269 3
d288 4
a291 1
#define RTAX_MAX	12	/* size of array to allocate */
d310 24
@


1.155
log
@Add comment above rtm_flags #define's.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.154 2017/01/23 00:12:52 krw Exp $	*/
d223 1
@


1.154
log
@Typo in comment. It's 'rtm_addrs', not 'rtm_addr'
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.153 2017/01/22 03:47:20 krw Exp $	*/
d129 1
@


1.153
log
@Zap some bad whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.152 2017/01/20 08:10:54 dlg Exp $	*/
d249 1
a249 1
 * Bitmask values for rtm_addr.
@


1.152
log
@use per-cpu counters for rtstat.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.151 2017/01/19 23:18:29 phessler Exp $	*/
d40 1
a40 1
 * 
d105 1
a105 1
					   to an MPLS structure */ 
d262 1
a262 1
#define RTA_BFD 	0x800	/* bfd present */
d342 1
a342 1
/* 
d349 1
a349 1
	LIST_ENTRY(rttimer) 	rtt_link;  /* multiple timers per rtentry */
d351 2
a352 2
	struct rtentry  	*rtt_rt;   /* Back pointer to the route */
	void            	(*rtt_func)(struct rtentry *, 
d354 1
a354 1
	time_t          	rtt_time; /* When this timer was registered */
@


1.151
log
@add hooks so we can query the current state of a BFD session

bfd session details are visible with "route -n get 192.0.2.1 -bfd"

OK mpi@@ deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.150 2017/01/19 02:55:18 phessler Exp $	*/
d321 20
@


1.150
log
@use a space instead of a tab, for consistancy

requested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.149 2016/11/21 10:30:42 mpi Exp $	*/
d262 1
d278 2
a279 1
#define RTAX_MAX	11	/* size of array to allocate */
@


1.149
log
@Kill rtioctl() stub, returning EOPNOTSUPP since tree import.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.148 2016/09/24 19:27:10 phessler Exp $	*/
d261 1
a261 1
#define	RTA_LABEL	0x400	/* route label present */
@


1.148
log
@a route message for BFD, so we can notify userland about the status.
currently used on state-transitions.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.147 2016/09/04 10:32:01 mpi Exp $	*/
a405 1
int	 rtioctl(u_long, caddr_t, struct proc *);
@


1.147
log
@Purge routes attached to an address when this address is removed.

This is done to stop using stale ifa attached to routes, which is
the easiest way to make rtisvalid(9) MP-safe.

sthen@@ and henning@@ like it, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.146 2016/09/04 09:39:01 claudio Exp $	*/
d359 1
d367 1
@


1.146
log
@Make it possible to toggle RTF_BFD via RTM_CHANGE and fix some minor things
in bfd.c. Make bfd_rtfree() a void function.
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.145 2016/09/03 14:20:26 phessler Exp $	*/
d401 1
a407 1
void	 rt_if_remove(struct ifnet *);
@


1.145
log
@Add in the (disabled) kernel glue for BFD

OK claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.144 2016/08/31 21:32:06 bluhm Exp $	*/
d157 1
a157 1
     RTF_REJECT | RTF_STATIC | RTF_MPLS)
@


1.144
log
@Remove unused RTF_MASK route flag.
Requested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.143 2016/08/31 08:13:49 mpi Exp $	*/
d152 1
d237 1
@


1.143
log
@G/C rt_defmask4.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.142 2016/08/22 16:01:52 mpi Exp $	*/
a135 1
#define RTF_MASK	0x80		/* subnet mask present */
@


1.142
log
@Make the ``rt_gwroute'' pointer of RTF_GATEWAY entries immutable.

This means that no protection is needed to guarantee that the next hop
route wont be modified by CPU1 while CPU0 is dereferencing it in a L2
resolution functions.

While here also fix an ``ifa'' leak resulting in RTF_GATEWAY being always
invalid.

dlg@@ likes it, inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.141 2016/07/13 08:40:46 mpi Exp $	*/
a352 1
extern const struct sockaddr_rtin rt_defmask4;
@


1.141
log
@Introduce RTF_MULTICAST and flag corresponding IPv6 routes as such
instead of abusing RTF_CLONING.

Fix a leak reporeted by Aaron Riekenberg on misc@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.140 2016/07/11 13:06:31 bluhm Exp $	*/
d106 6
a111 1
	struct rtentry	*rt_gwroute;	/* implied entry for gatewayed routes */
d147 1
d236 1
d373 1
a373 1
int	 rt_checkgate(struct rtentry *, struct rtentry **);
@


1.140
log
@Path MTU discovery was slightly broken.  I took two ICMP packets
to create and change the dynamic route.  This behavior was introduced
in net/route.c rev 1.269 when the gateway route allocation was moved
from rt_setgateway() to _rtalloc().  So rtrequest(RTM_ADD) could
return a route without a valid gateway route.  To fix this, call
rt_setgwroute() from _rtalloc() and rt_setgateway().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.139 2016/07/11 09:23:06 mpi Exp $	*/
d133 1
a133 1
/*			0x200		unused */
@


1.139
log
@Revert the introduction of ``rt_addr''.

Being able to add route entries without configured addresses is a nice
feature but this is not my fight.  So I'd rather no add another pointer
to ``struct rtentry'' if I'm not removing another one.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.138 2016/06/14 09:48:52 mpi Exp $	*/
d365 1
a365 1
int	 rt_setgate(struct rtentry *, struct sockaddr *);
@


1.138
log
@Pass the configured ``ifa'' to rt_sendaddrmsg() instead of getting it via
``rt->rt_ifa'' later.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.137 2016/06/14 09:44:41 mpi Exp $	*/
a101 1
	struct sockaddr *rt_addr;	/* the answer: address to use */
@


1.137
log
@Store the source address associated with a route in its own chunk of
memory.

This will allow to unlink 'sruct rtentry' and 'struct ifaddr' to be able
to add route entries without needing an address.

ok sthen@@, visa@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.136 2016/06/03 02:56:59 dlg Exp $	*/
d364 1
a364 1
void	 rt_sendaddrmsg(struct rtentry *, int);
@


1.136
log
@set rt_expire times against time_uptime, not time_second.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.135 2016/04/27 14:47:27 mpi Exp $	*/
d102 1
@


1.135
log
@Remove unused arguments from rt_checkgate().

Since the rtalloc(9) rewrite no route lookup is done in this function so
there's no need for a destination or a rtable ID.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.134 2016/03/30 10:13:14 mpi Exp $	*/
d367 2
a368 2
void	 rt_setmetrics(u_long, struct rt_metrics *, struct rt_kmetrics *);
void	 rt_getmetrics(struct rt_kmetrics *, struct rt_metrics *);
@


1.134
log
@Implement proxy ARP for ART based on mpath support.

Since mpath is not enabled in RAMDISK, proxy ARP won't work there either.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.133 2016/03/26 21:56:04 mpi Exp $	*/
d366 1
a366 2
int	 rt_checkgate(struct ifnet *, struct rtentry *, struct sockaddr *,
	    unsigned int, struct rtentry **);
@


1.133
log
@Always include the route priority in routing messages.

From Florian Riehm, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.132 2016/02/24 22:41:53 mpi Exp $	*/
d139 1
@


1.132
log
@Fix ECMP routing by passing the correct destination address to the
hash routine.

Bug reported and fix analysed by Jean-Daniel Dupas <jddupas AT xooloo DOT net>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.131 2016/01/18 15:38:52 mpi Exp $	*/
d363 1
a363 1
void	 rt_missmsg(int, struct rt_addrinfo *, int, u_int, int, u_int);
@


1.131
log
@Stop storing a backpointer to the corresponding ART node in each route
entry.

This pointer hasn't been used for some time and without it no external
reference count is needed to turn art_lookup() mpsafe.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.130 2015/12/03 21:57:59 mpi Exp $	*/
d381 1
a381 1
int	 rt_hash(struct rtentry *, uint32_t *);
@


1.130
log
@Get rid of rt_mask() and stop allocating a "struct sockaddr" for every
route entry in ART.

rt_plen() now represents the prefix length of a route entry and should
be used instead.

For now use a "struct sockaddr_in6" to represent the mask when needed,
this should be then replaced by the prefix length and RTA_NETMASK only
used for compatibility with userland.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.129 2015/12/03 16:27:32 mpi Exp $	*/
a98 1
	struct art_node	*rt_node;	/* ART entry */
d113 3
@


1.129
log
@Use SRPL_HEAD() and SRPL_ENTRY() to be consistent with and allow to
fallback to a SLIST.

ok dlg@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.128 2015/12/03 14:26:27 mpi Exp $	*/
a100 1
	struct sockaddr *rt_mask;	/* mask (radix tree compat) */
d348 1
d358 1
@


1.128
log
@Remove unused ``rt_tableid'' field from "struct rtentry".

This reduces the size of the structure by 8 bytes on amd64 now that
we are using an index instead of a pointer for reaching interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.127 2015/12/03 14:19:55 mpi Exp $	*/
d102 1
a102 1
	struct srpl_entry rt_next;	/* Next multipath entry to our dst. */
@


1.127
log
@Store an interface index instead of a pointer in the "struct rtentry".

These indexes are unique and should be used with if_get() to get a
pointer to the corresponding ``ifp''.  Such pointer is guaranteed to
be valid in a MP environment until if_put() is called.

ok claudio@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.126 2015/12/02 16:35:53 bluhm Exp $	*/
a113 1
	unsigned int	 rt_tableid;	/* routing table ID  */
@


1.126
log
@When destroying an interface, we have to wait until all references
are not used anymore.  This has to be done before any interface
fields become invalid.
As the route delete request cannot call if_get() anymore, pass down
the interface.  Split rtrequest_delete() into a separate function
that may take an existing inteface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.125 2015/12/02 13:29:26 claudio Exp $	*/
a104 2
	struct ifnet	*rt_ifp;	/* the answer: interface to use */
#define rt_ifidx rt_ifp->if_index
d112 1
d347 4
a350 2
struct	mbuf;
struct	socket;
a351 1

@


1.125
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.124 2015/12/02 09:17:47 mpi Exp $	*/
d403 1
a403 1
int	 rtdeletemsg(struct rtentry *, u_int);
@


1.124
log
@Move multipath Hash-Threshold selection mechanism inside rtable_match().

This will helps for unlocking the routing table and will prevent further
mistake by keeping the multipath logic inside the rtable_* API.

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.123 2015/12/01 21:26:43 mpi Exp $	*/
d343 1
a343 2
#define	RT_REPORT	0x1
#define	RT_RESOLVE	0x2
d381 1
a381 1
#define	 rtalloc_mpath(dst, s, rid) rtalloc((dst), RT_REPORT|RT_RESOLVE, (rid))
@


1.123
log
@Kill redundant or unused arguments in rtredirect().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.122 2015/11/29 16:02:18 mpi Exp $	*/
d380 1
@


1.122
log
@Convert the simple list of multipath route entries used by ART kernels
to a SRP list.

This turns the rtable_* layer mpsafe.  We now only need to protect the
ART implementation itself.

Note that route(8) regress tests will now fail due to a supplementary
reference taken by the SRPL_INIT(9) API.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.121 2015/11/09 10:26:26 mpi Exp $	*/
d395 1
a395 3
void	 rtredirect(struct sockaddr *, struct sockaddr *,
			 struct sockaddr *, int, struct sockaddr *,
			 struct rtentry **, u_int);
@


1.121
log
@Rewrite rtalloc(9) to consider RTF_GATEWAY entries without valid next-
hop route as invalid.

Previously when such entrie was returned by rtalloc(9) a second route
lookup was done in rt_checkgate() very late in the journey of a packet.

In other words a single rtalloc(9) call can now result in multiple
route lookups if a RTF_GATEWAY entry is returned.

This is a step towards always calling L2 output functions with valid
destination information.

Tested by various including jmc@@, naddy@@, Hrvoje Popovski
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.120 2015/11/06 17:55:55 mpi Exp $	*/
d102 1
a102 1
	SLIST_ENTRY(rtentry)  rt_next;	/* Next multipath entry to our dst. */
@


1.120
log
@Rename rt_mpath_next() into rtable_mpath_next() and provide an
implementation for ART based on the singly-linked list of route
entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.119 2015/11/06 17:44:45 mpi Exp $	*/
d122 2
d363 1
a363 1
int	 rt_setgate(struct rtentry *, struct sockaddr *, unsigned int);
@


1.119
log
@Use a SLIST instead of a LIST for MPATH route entries with ART.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.118 2015/10/30 09:39:42 bluhm Exp $	*/
a403 2

struct rtentry *rt_mpath_next(struct rtentry *);
@


1.118
log
@Rename rtrequest1() to rtrequest().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.117 2015/10/25 10:05:09 bluhm Exp $	*/
d102 1
a102 1
	LIST_ENTRY(rtentry)  rt_next;	/* Next multipath entry to our dst. */
@


1.117
log
@Instead of doing the the if_get() dance for rt_missmsg(), change the
function to take an interface index.
discussed with mpi@@;  OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.116 2015/10/24 11:47:07 mpi Exp $	*/
d396 1
a396 1
int	 rtrequest1(int, struct rt_addrinfo *, u_int8_t, struct rtentry **,
@


1.116
log
@Define ``rt_ifidx'' as rt_ifp->if_index to ease the transtion towards
getting rid of interface pointers in route entries.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.115 2015/10/07 10:50:35 mpi Exp $	*/
d360 1
a360 2
void	 rt_missmsg(int, struct rt_addrinfo *, int, struct ifnet *, int,
	    u_int);
@


1.115
log
@Initialize the routing table before domains.

The routing table is not an optional component of the network stack
and initializing it inside the "routing domain" requires some ugly
introspection in the domain interface.

This put the rtable* layer at the same level of the if* level.  These
two subsystem are organized around the two global data structure used
in the network stack:

- the global &ifnet list, to be used in process context only, and
- the routing table which can be read in interrupt context.

This change makes the rtable_* layer domain-aware and extends the
"struct domain" such that INET, INET6 and MPLS can specify the length
of the binary key used in lookups.  This allows us to keep, or move
towards, AF-free route and rtable layers.

While here stop the madness and pass the size of the maximum key length
in *byte* to rn_inithead0().

ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.114 2015/10/03 18:57:11 renato Exp $	*/
d106 1
@


1.114
log
@Enable eigrpd(8) and eigrpctl(8) in the builds

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.113 2015/09/11 21:27:49 mpi Exp $	*/
a348 4
int	 rtable_add(u_int);
u_int	 rtable_l2(u_int);
void	 rtable_l2set(u_int, u_int);
int	 rtable_exists(u_int);
@


1.113
log
@Now that the port tree is clean, RTF_XRESOLVE disapear.

ok sthen@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.112 2015/09/11 16:58:00 mpi Exp $	*/
d155 1
@


1.112
log
@Introduce rtref(9) use it in rtable_lookup() before returning a route
entry.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.111 2015/09/01 12:50:03 mpi Exp $	*/
d131 1
a131 1
#define RTF_XRESOLVE	0x200		/* external daemon resolves name */
@


1.111
log
@Introduce rtisvalid(9) a function to check if a (cached) route entry
can be used or should be released by rtfree(9).

It currently checks if the route is UP and is not attached to a stall
ifa.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.110 2015/08/20 12:39:43 mpi Exp $	*/
d387 1
@


1.110
log
@Import an alternative routing table backend based on Yoichi Hariguchi's
ART implementation.

ART (Allotment Routing Table) is a multibit-trie algorithm invented by
D. Knuth while reviewing Yoichi's SMART [0] (Smart Multi-Array Routing
Table) paper.

This implementation, unlike the one from the KAME project, supports
variable stride lengths which makes it easier to adapt the consumed
memory/speed trade-off.  It also let you use a bigger first-level
table, what other algorithms such as POPTRIE [1] need to implement
separately.

Adaptation to the OpenBSD kernel has been done with two different data
structures.  ART nodes and route entries are managed separately which
makes the algorithm implementation free of any MULTIPATH logic.

This implementation does not include Path Compression.

[0] http://www.hariguchi.org/art/smart.pdf
[1] http://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p57.pdf

ok dlg@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.109 2015/07/18 15:51:16 mpi Exp $	*/
d380 1
@


1.109
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.108 2015/07/08 07:56:51 mpi Exp $	*/
d96 1
d98 6
@


1.108
log
@Use a new RTF_CONNECTED flag for interface (connected) routes.

Recent changes to support multiple interface routes broke the
assumption made by all our userland routing daemons concerning
interface routes.  Historically such routes had a "gateway"
sockaddr of type AF_LINK.  But to be able to support multiple
interface routes as any other multipath routes, they now have
a unique "gateway" sockaddr containing their corresponding IP
address.

This self-describing flag should avoid ambiguity when dealing
with interface routes.

Issue reported by <mxb AT alumni DOT chalmers DOT se> and benno@@

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.107 2015/07/08 07:29:24 mpi Exp $	*/
a82 2
#ifdef _KERNEL

d84 1
a93 2
#include <net/radix.h>
#include <net/radix_mpath.h>
a96 2
#define	rt_key(r)	((struct sockaddr *)((r)->rt_nodes->rn_key))
#define	rt_mask(r)	((struct sockaddr *)((r)->rt_nodes->rn_mask))
a114 2
#endif /* _KERNEL */

d338 1
a341 1
struct radix_node_head *rtable_get(u_int, sa_family_t);
d375 2
d395 1
a395 1
int	 rt_if_linkstate_change(struct radix_node *, void *, u_int);
a397 2

struct rtentry		*rt_lookup(struct sockaddr *, struct sockaddr *, u_int);
@


1.107
log
@RTF_LOCAL and RTF_BROADCAST must not be settable by userland.

Note that current code is safe because an explicit check exists
in route_output().

Pointed out by claudio@@ while reviewing another diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.106 2015/05/05 09:41:43 mpi Exp $	*/
d143 1
@


1.106
log
@Flag user specified routes with an AF_LINK gateway as RTF_LLINFO.

This makes ND6 and ARP layers happy since they both check for this flag,
but is was redundant to provide route(8)'s "-llinfo" option when adding
a l2 route.

RTF_LLINFO is clearly redundant for userland tools, so only allow the
kernel to set it.

ok benno@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.105 2015/02/11 23:34:43 mpi Exp $	*/
d147 1
a147 1
     RTF_REJECT | RTF_STATIC | RTF_MPLS | RTF_LOCAL | RTF_BROADCAST)
@


1.105
log
@Do not store the key and the gateway of a route entry in the same chunk
of memory.

The key (destination) is only set once, when the route is inserted in
the routing table, and does not need to change afterward.  The gateway
might change and rt_setgate() will do all the checks for you.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.104 2015/01/13 12:14:00 mpi Exp $	*/
d146 1
a146 1
    (RTF_PROTO1 | RTF_PROTO2 | RTF_PROTO3 | RTF_BLACKHOLE | \
@


1.104
log
@Restore sending RTM_ADD and RTM_DELETE messages to userland for every
route created/deleted with rt_ifa_add(9)/rt_ifa_del(9), not only for
RTF_LOCAL routes.

Regression introduced in r1.172 when restoring the original behavior
of RTM_NEWADDR/RTM_RTM_DELADDR reported by Florian Riehm.

Joint work with Florian Riehm, with input from and ok bluhm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.103 2015/01/08 15:05:44 mpi Exp $	*/
d363 1
a363 2
int	 rt_setgate(struct rtentry *, struct sockaddr *,
	    struct sockaddr *, u_int);
@


1.103
log
@Include the Routing Table ID in "struct rtentry" and reorder the fields
such that there's no size change on, at least, amd64.

This will allow us to simplify some APIs and deprecate the remaining
flavors of "struct route".

ok claudio@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.102 2015/01/08 14:29:18 mpi Exp $	*/
d360 1
a362 1
void	 rt_newaddrmsg(int, struct ifaddr *, int, struct rtentry *);
@


1.102
log
@Factorize various duplicated chunks of (old and horrible) code, checking
for the validity of a given outgoing route entry into a single function.

This change is inspired from FreeBSD r111767.  The function introduced
here, rt_checkgate(), should hopefully die in a near future.  Why should
it die?  Well, it is way too late to do such validity checks: if your
kernel can ends up in ether_output() with an invalid route, please do
not let it try to find a new one that might do the job.

Go read this function if you're wondering why you're getting messages
like:

"arpresolve: X.X.X.X: route without link local address"

Since this horrible logic has survived 20 years of copy & past and small
modifications for workarounds without a single clear commit message, let's
assume it is full of dragons and try to play safe.  This factorization is
not intended to change any behavior.

With much inputs from bluhm@@, tested by weerd@@ and florian@@ on setups
with p2p IPv6 interfaces.

ok bluhm@@, benno@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.101 2014/11/24 12:43:54 mpi Exp $	*/
d102 4
a105 6
	struct	sockaddr *rt_gateway;	/* value */
	u_int	rt_flags;		/* up/down?, host/net */
	int	rt_refcnt;		/* # held references */
	struct	ifnet *rt_ifp;		/* the answer: interface to use */
	struct	ifaddr *rt_ifa;		/* the answer: interface addr to use */
	caddr_t	rt_llinfo;		/* pointer to link level info cache or
d107 2
a108 3
	struct	rt_kmetrics rt_rmx;	/* metrics used by rx'ing protocols */
	struct	rtentry *rt_gwroute;	/* implied entry for gatewayed routes */
	struct	rtentry *rt_parent;	/* If cloned, parent of this route. */
d110 6
a115 2
	u_int16_t rt_labelid;		/* route label ID */
	u_int8_t rt_priority;		/* routing priority to use */
@


1.101
log
@Rename rt_ifa_addloop() into rt_ifa_addlocal() and make it return an
error code on failure (unchecked for the moment).

ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.100 2014/11/01 21:40:38 mpi Exp $	*/
d116 2
a117 1
#define	rt_use	rt_rmx.rmx_pksent
d364 2
@


1.100
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.99 2014/10/14 09:52:26 mpi Exp $	*/
d385 2
a386 2
void	 rt_ifa_addloop(struct ifaddr *);
void	 rt_ifa_delloop(struct ifaddr *);
@


1.99
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.98 2014/10/08 07:37:02 mpi Exp $	*/
d334 1
a334 1
 * Values for additional argument to rtalloc1()
d337 1
a337 1
#define	RT_NOCLONING	0x2
d377 1
a377 1
#define	rtalloc_mpath(dst, s, rtableid)	rtalloc1((dst), RT_REPORT, (rtableid))
d379 1
a379 2
struct rtentry *
	 rtalloc1(struct sockaddr *, int, u_int);
d381 1
@


1.98
log
@Use rtalloc1() instead of rtalloc_noclone().

ok henning@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.97 2014/09/27 12:26:16 mpi Exp $	*/
a331 7

#define	RTFREE(rt) do {							\
	if ((rt)->rt_refcnt <= 1)					\
		rtfree(rt);						\
	else								\
		(rt)->rt_refcnt--;					\
} while (/* CONSTCOND */0)
@


1.97
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.96 2014/08/12 13:52:08 mpi Exp $	*/
a382 1
void	 rtalloc_noclone(struct route *);
@


1.96
log
@route_cb is internal to rtsock.c
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.95 2014/07/29 12:18:41 mpi Exp $	*/
a383 1
void	 rtalloc(struct route *);
d385 1
a385 1
#define	rtalloc_mpath(r, s)	rtalloc(r)
@


1.95
log
@Revert the checks about RTF_LOCAL routes.

Even if in the end we would like to be more strict about what userland
can do with kernel-managed route entries, most of the tools out there
are not yet ready for this.  Since RTF_LOCAL routes are for the moment
just like RTF_LLINFO routes without expire timer, allow userland tools
to remove/modify them.  In case they are missing, the good old cloning
mechanism will recreate what you need.

bluhm@@ and deraadt@@ agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.94 2014/05/09 09:23:56 mpi Exp $	*/
a345 8
struct route_cb {
	int	ip_count;
	int	ip6_count;
	int     mpls_count;
	int	any_count;
};

extern struct route_cb route_cb;
@


1.94
log
@We should use the highest possible priority for routes to local addresses.

Requested by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.93 2014/05/08 09:28:08 mpi Exp $	*/
d145 1
a145 1
     RTF_REJECT | RTF_STATIC | RTF_MPLS)
@


1.93
log
@Introduce two new route flags: RTF_LOCAL and RTF_BROADCAST.

Nothing use them for the moment, but here is the plan:

Since a route lookup is always necessary to output a packet it makes
sense to store all the information regarding how the packet should be
sent in the routing entry.  This will save us some expensive lookups
on address lists.

But once we have all the information about our addresses in the routing
table, we can even use it in the input path with the hope that the number
of lookups in the forwarding case can be reduce to one.

ok henning@@, chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.92 2014/04/25 10:41:09 mpi Exp $	*/
d149 1
a149 1
#define RTP_LOCAL	2	/* route to a local address */
@


1.92
log
@Remove rti_ifp from rt_addrinfo, one less ifp pointer, say yay!

This pointer was only needed by rt_getifa() to find an address, so
turn it into a local variable.

ok henning@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.91 2014/04/10 13:47:21 mpi Exp $	*/
d130 1
a130 1
#define RTF_LLINFO	0x400		/* generated by ARP or ESIS */
d139 2
a146 6
#ifndef _KERNEL
/* obsoleted */
#define RTF_SOURCE	0x20000		/* this route has a source selector */
#define RTF_TUNNEL	0x100000	/* Tunnelling bit. */
#endif

d149 1
@


1.91
log
@Retire rtinit() an use rt_ifa_add(9) and rt_ifa_del(9) to manage
connected routes to prefixes/hosts.

Since the introduction of rt_ifa_addloop(9) and rt_ifa_delloop(9),
rtinit() was just a wrapper, so use the underlying functions
directly and document them.

Inputs from and ok mikeb@@, manpage tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.90 2014/04/03 08:22:10 mpi Exp $	*/
a301 1
	struct	ifnet *rti_ifp;
@


1.90
log
@Introduce rt_ifa_{add,del}loop() to replace in6_{add,rem}loop().

Move these functions to a more generic place and make them reuse
existing code, they'll be soon used in IPv4 too.

Tested by Andr Lucas, Vigdis and sthen@@, thanks!

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.89 2014/03/21 10:44:42 mpi Exp $	*/
d404 2
a405 1
int	 rtinit(struct ifaddr *, int, int);
@


1.89
log
@rt_timer* spring cleanup.

Rename and document rt_timer_count() into rt_timer_queue_count() to
be consistent with the other functions.  Remove unused argument from
rt_timer_queue_destroy(), clean the definitions and finally use the
same order in NAME and DESCRIPTION as requested by jmc@@.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.88 2014/03/18 10:47:34 mpi Exp $	*/
d405 2
@


1.88
log
@Rename rt_gettable() into rtable_get(), swap its arguments to be
coherent with the existing rtable_* functions and document it.

While here fix some other manpage glitches pointed out by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.87 2014/01/23 10:16:30 mpi Exp $	*/
d384 11
a394 11
int      rt_timer_add(struct rtentry *,
             void(*)(struct rtentry *, struct rttimer *),
	     struct rttimer_queue *, u_int);
void	 rt_timer_init(void);
struct rttimer_queue *
	 rt_timer_queue_create(u_int);
void	 rt_timer_queue_change(struct rttimer_queue *, long);
void	 rt_timer_queue_destroy(struct rttimer_queue *, int);
void	 rt_timer_remove_all(struct rtentry *);
unsigned long	rt_timer_count(struct rttimer_queue *);
void	 rt_timer_timer(void *);
@


1.87
log
@Merge two chunks of code to inform listeners of a route change into a
new function, rt_sendmsg().  While here, in the v6 cases, pass the same
rtableid that was used for the request instead of dereferencing a pointer
after checking for it to be NULL.

ok krw@@ on a previous version, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.86 2014/01/22 06:28:09 claudio Exp $	*/
d364 1
d368 1
a417 1
struct radix_node_head	*rt_gettable(sa_family_t, u_int);
@


1.86
log
@Remove genmask support from the kernel. rtmsgs with RTA_GENMASK set will
now cause a EINVAL. The RTA_GENMASK and RTAX_GENMASK defines are kept for
compatibility reasons.
OK benno@@ and agreed by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.85 2014/01/20 22:44:41 claudio Exp $	*/
d374 1
@


1.85
log
@Remove an unneeded #ifndef bot radix.h and radix_mpath.h protect themself
from multiple inclusion. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.84 2014/01/20 22:11:42 bluhm Exp $	*/
a106 1
	struct	sockaddr *rt_genmask;	/* for generation of cloned routes */
@


1.84
log
@Get rid of the old routing message version 4 transition code before
5.5 release.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.83 2013/10/31 18:10:21 bluhm Exp $	*/
a94 1
#ifndef RNF_NORMAL
d97 1
a97 1
#endif
@


1.83
log
@Convert the route expire timestamp in kernel and routing message
to 64 bit.  Increase the routing message version from 4 to 5.  Add
a small compatibility layer that allows to set routes with old user
land and new kernel.  Old kernel with new user land does not work.

The compatibility layer ist not perfect, but it allows to configure
addresses with old ifconfig and new kernel.  Route get also works
in this setup.  dhclient hangs as messages for interface address
changes with old version are not generated.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.82 2013/10/24 18:50:16 deraadt Exp $	*/
a208 40

#if defined(_KERNEL) && ! defined(SMALL_KERNEL)
/*
 * Compatibility structures for version 4 messages.
 * Only needed for transition during OpenBSD 5.4-current.
 */
struct rt_ometrics {
	u_int64_t	rmx_pksent;	/* packets sent using this route */
	u_int		rmx_locks;	/* Kernel must leave these values */
	u_int		rmx_mtu;	/* MTU for this path */
	u_int		rmx_expire;	/* lifetime for route, e.g. redirect */
	u_int		rmx_refcnt;	/* # references hold */
	/* some apps may still need these no longer used metrics */
	u_int		rmx_hopcount;	/* max hops expected */
	u_int		rmx_recvpipe;	/* inbound delay-bandwidth product */
	u_int		rmx_sendpipe;	/* outbound delay-bandwidth product */
	u_int		rmx_ssthresh;	/* outbound gateway buffer limit */
	u_int		rmx_rtt;	/* estimated round trip time */
	u_int		rmx_rttvar;	/* estimated rtt variance */
};
struct rt_omsghdr {
	u_short	rtm_msglen;	/* to skip over non-understood messages */
	u_char	rtm_version;	/* future binary compatibility */
	u_char	rtm_type;	/* message type */
	u_short	rtm_hdrlen;	/* sizeof(rt_msghdr) to skip over the header */
	u_short	rtm_index;	/* index for associated ifp */
	u_short rtm_tableid;	/* routing table id */
	u_char	rtm_priority;	/* routing priority */
	u_char	rtm_mpls;	/* MPLS additional infos */
	int	rtm_addrs;	/* bitmask identifying sockaddrs in msg */
	int	rtm_flags;	/* flags, incl. kern & message, e.g. DONE */
	int	rtm_fmask;	/* bitmask used in RTM_CHANGE message */
	pid_t	rtm_pid;	/* identify sender */
	int	rtm_seq;	/* for sender to identify action */
	int	rtm_errno;	/* why failed */
	u_int	rtm_inits;	/* which metrics we are initializing */
	struct	rt_ometrics rtm_rmx; /* metrics themselves */
};
#define RTM_OVERSION	4	/* Provide backward compatibility */
#endif /* defined(_KERNEL) && ! defined(SMALL_KERNEL) */
@


1.82
log
@Move more stuff under _KERNEL
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.81 2013/10/24 11:14:35 deraadt Exp $	*/
d51 1
a53 2
	u_int		rmx_expire;	/* lifetime for route, e.g. redirect */
	u_int		rmx_pad;
d61 1
a63 1
	u_int		rmx_expire;	/* lifetime for route, e.g. redirect */
d72 1
d210 41
a250 1
#define RTM_VERSION	4	/* Up the ante and ignore older versions */
@


1.81
log
@Move obvious kernel prototypes (and structure's with kernel pointers,
obviously only used in the kernel) behind #ifdef _KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.80 2013/10/20 13:21:57 claudio Exp $	*/
a37 2
#include <sys/queue.h>

d84 3
@


1.80
log
@rt_mpath_next() was always called with 0 in the last argument. So drop it.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.79 2013/10/20 12:35:47 claudio Exp $	*/
a47 11
 * A route consists of a destination address and a reference
 * to a routing entry.  These are often held by protocols
 * in their control blocks, e.g. inpcb.
 */
struct route {
	struct	rtentry *ro_rt;
	u_long		 ro_tableid;	/* u_long because of alignment */
	struct	sockaddr ro_dst;
};

/*
d85 1
d119 2
d279 19
d308 1
a308 6
struct route_cb {
	int	ip_count;
	int	ip6_count;
	int     mpls_count;
	int	any_count;
};
a314 1

a332 9
#define	RTLABEL_LEN	32

struct sockaddr_rtlabel {
	u_int8_t	sr_len;			/* total length */
	sa_family_t	sr_family;		/* address family */
	char		sr_label[RTLABEL_LEN];
};

#ifdef _KERNEL
d351 7
d421 1
@


1.79
log
@Make sure that the RTM_DESYNC message is not filtered out. Also ensure that
rtm_flags and rtm_fmask do not change flags that are kernel specific (e.g.
RTF_CLONED). OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.78 2012/09/19 16:14:01 blambert Exp $	*/
d416 1
a416 1
struct rtentry *rt_mpath_next(struct rtentry *, int);
@


1.78
log
@Make rt_lookup return a pointer to an rtentry struct instead of
to a radix_node struct.

The radix tree pushdown continues.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.77 2012/09/19 12:35:07 blambert Exp $	*/
d152 1
a152 1
     RTF_REJECT | RTF_STATIC)
@


1.77
log
@More radix internals pushdown; place rn_mpath_next, which accepts and
returns radix_node pointers, inside a new rt_mpath_next, which accepts
and returns rtentry pointers, and start using that instead.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.76 2012/03/17 10:16:41 dlg Exp $	*/
d414 1
a414 1
struct radix_node	*rt_lookup(struct sockaddr *, struct sockaddr *, u_int);
@


1.76
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.75 2010/10/28 17:18:35 claudio Exp $	*/
d415 2
@


1.75
log
@Do not send route messages to userland processes that the kernel
rejects because of bad encoding. Userland processes trust that the
messages on the rtsock are correctly encoded. Moved some checks up
to do the suser() check as soon as possible.
After discussion with deraadt@@, OK deraadt@@ and sthen@@ (earlier version)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.74 2010/10/11 11:41:08 claudio Exp $	*/
a146 1
#define RTF_JUMBO	0x80000		/* try to use jumbo frames */
d151 1
a151 1
    (RTF_JUMBO | RTF_PROTO1 | RTF_PROTO2 | RTF_PROTO3 | RTF_BLACKHOLE | \
@


1.74
log
@Implement an rtsocket filter for rtableids. A process will initially
only get messages that are for the rtable the process is bound to.
Depending on the rtm_type the rdomain or rtable id are used for
comparison.  It is possible to change the filter with a setsockopt(s,
AF_ROUTE, ROUTE_TABLEFILTER,...) and if set to RTABLE_ANY the filter
is deactivated.  Additionally set the tableid in struct if_msghdr
to the rdomain id and use the process rtableid in the sysctl if no
table was specified.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.73 2010/08/25 14:07:24 claudio Exp $	*/
d219 2
@


1.73
log
@Let rtable_add() return usefull errnos so that the ioctl handler and the
rtsock code can return a more reasonable error to the user.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.72 2010/07/14 00:42:57 dlg Exp $	*/
d280 2
d284 1
@


1.72
log
@if we produce a lot of rtsock messages it is possible we will hit a
condition that prevents us from queuing it, which in turn means that
processes listening on the routing socket for changes to the kernel state
will get out of sync. currently this is handled by the following comment:

	/* should notify about lost packet */

this change introduces a new rtsock message called RTM_DESYNC that
notifies about lost packets and uses it instead of this comment.

when we detect loss we flush all the message in the routing socket and
attempt to queue an RTM_DESYNC message instead. to guarantee that we will
enqueue DESYNC we keep trying it when an attempt to enqueue or dequeue
any messages is made, and in the worst case a timeout tries to guarantee
that desync is added to the socket.

ive been running this in production for 2 or 3 weeks.
tested by sthen@@
ok sthen@@ claudio@@ deraadt@@
code written by andrew sallaway at the univeristy of queensland.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.71 2010/07/09 15:44:20 claudio Exp $	*/
a357 1
void	 rtable_addif(struct ifnet *, u_int);
@


1.71
log
@Add the rtableid to struct rttimer and therefor  make it available to
the callback functions. This fixes a problem where dynamic routes in
different tables would not get deleted because the callback was doing
the remove on the wrong table.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.70 2010/06/29 21:28:37 reyk Exp $	*/
d233 1
@


1.70
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.67 2010/04/21 11:52:46 claudio Exp $	*/
d313 1
d377 1
a377 1
	     struct rttimer_queue *);
@


1.69
log
@Add the rtable id as an argument to rn_walktree(). Functions like
rt_if_remove_rtdelete() need to know the table id to be able to correctly
remove nodes.
Problem found by Andrea Parazzini and analyzed by Martin Pelikn.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.68 2010/05/07 13:33:16 claudio Exp $	*/
d356 1
@


1.68
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.67 2010/04/21 11:52:46 claudio Exp $	*/
d403 1
a403 1
int	 rt_if_linkstate_change(struct radix_node *, void *);
@


1.67
log
@Implement a way to get information about a rtable. Currently only the rtableid
and rdomainid are returned. This is necessary to know where L2 information
of a table is stored (which will be needed soon by bgpd).
Also while there change the errno for non-existing routing tables to ENOENT.
'Fine' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.66 2010/02/09 16:31:14 claudio Exp $	*/
d54 1
d344 1
a344 1
 * Values for additional argument to rtalloc_noclone() and rtalloc2()
d346 2
a347 3
#define	ALL_CLONING 0
#define	ONNET_CLONING 1
#define	NO_CLONING 2
d384 1
d387 1
a387 1
#define	rtalloc_mpath(r, s, t)	rtalloc(r)
a390 3
void	 rtalloc_noclone(struct route *, int);
struct rtentry *
	 rtalloc2(struct sockaddr *, int, int);
@


1.66
log
@Correctly track RTF_UP on RTM_CHANGE. Since the interface can change
rt_if_linkstate_change() needs to be rerun for this route and the
resulting rt_flags need to copied to the rtm_flags for userland.
Problem found and diagnosed by Doran Mori. OK henning@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.65 2009/11/03 10:59:04 claudio Exp $	*/
d183 8
@


1.65
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.64 2009/09/17 13:27:24 claudio Exp $	*/
d397 1
@


1.64
log
@Remove the comaptibility structures for routing socket version 3.
The RTM_VERSION bump is 2 years ago and so there is no need for this.
Diff made by tedu@@ some time ago but got never commited so I do it now.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.63 2009/06/05 00:05:22 claudio Exp $	*/
d348 2
@


1.63
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.62 2009/05/26 08:29:44 reyk Exp $	*/
a208 33
/*
 * Comaptibility structures for version 3 messages.
 * Keep them till after OpenBSD 4.4
 */
struct rt_ometrics {
	u_long	rmx_locks;	/* Kernel must leave these values alone */
	u_long	rmx_mtu;	/* MTU for this path */
	u_long	rmx_hopcount;	/* max hops expected (deprecated) */
	u_long	rmx_expire;	/* lifetime for route, e.g. redirect */
	u_long	rmx_recvpipe;	/* inbound delay-bandwidth product */
	u_long	rmx_sendpipe;	/* outbound delay-bandwidth product */
	u_long	rmx_ssthresh;	/* outbound gateway buffer limit (deprecated) */
	u_long	rmx_rtt;	/* overloaded with rmx_rt_tableid */
	u_long	rmx_rttvar;	/* estimated rtt variance (deprecated) */
	u_long	rmx_pksent;	/* packets sent using this route */
};

struct rt_omsghdr {
	u_short	rtm_msglen;	/* to skip over non-understood messages */
	u_char	rtm_version;	/* future binary compatibility */
	u_char	rtm_type;	/* message type */
	u_short	rtm_index;	/* index for associated ifp */
	int	rtm_flags;	/* flags, incl. kern & message, e.g. DONE */
	int	rtm_addrs;	/* bitmask identifying sockaddrs in msg */
	pid_t	rtm_pid;	/* identify sender */
	int	rtm_seq;	/* for sender to identify action */
	int	rtm_errno;	/* why failed */
	int	rtm_fmask;	/* was once rtm_use */
	u_long	rtm_inits;	/* which metrics we are initializing */
	struct	rt_ometrics rtm_rmx; /* metrics themselves */
};

#define RTM_OVERSION	3	/* provide some minimal backward compat */
@


1.62
log
@inherit the route label on cloned routes

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.61 2009/05/18 20:37:13 bluhm Exp $	*/
a353 2
#define	RT_TABLEID_MAX	255

d417 1
a417 1
int	 rt_getifa(struct rt_addrinfo *);
d422 1
a422 1
			 struct rtentry **);
@


1.61
log
@The routing table index rtableid has type unsigned int in the routing
code.  In pf rtableid == -1 means don't change the rtableid because
of this rule.  So it has to be signed int there.  Before the value
is passed from pf to route it is always checked to be >= 0.  Change
the type to int in pf and to u_int in netinet and netinet6 to make
the checks work.  Otherwise -1 may be used as an array index and
the kernel crashes.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.60 2009/03/31 01:31:26 dlg Exp $	*/
d359 1
@


1.60
log
@claudio has spent too much time with the mbuf macros.

switch the rtsocket message filter specification so you can or the macros
converting the routing socket message types into the mask used by the
filter. ie:

-       ROUTE_SETFILTER(rtfilter, RTM_NEWADDR);
-       ROUTE_SETFILTER(rtfilter, RTM_DELADDR);
-       ROUTE_SETFILTER(rtfilter, RTM_IFINFO);
-       ROUTE_SETFILTER(rtfilter, RTM_IFANNOUNCE);
+       rtfilter = ROUTE_FILTER(RTM_NEWADDR) | ROUTE_FILTER(RTM_DELADDR) |
+           ROUTE_FILTER(RTM_IFINFO) | ROUTE_FILTER(RTM_IFANNOUNCE);

there's a manpage change coming.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.58 2009/01/28 22:18:44 michele Exp $	*/
d433 1
a433 1
struct radix_node	*rt_lookup(struct sockaddr *, struct sockaddr *, int);
@


1.59
log
@Use our own flags to set the operations and not RTF_PROTOX.
Switch the padding field into a MPLS one in rt_msghdr to store
relevant informations.

OK claudio@@ laurent@@
@
text
@d304 1
a304 1
#define ROUTE_SETFILTER(x, m)	(x) |= (1 << (m))
@


1.58
log
@Get rid of the ugly rtentry hack.

We can now act as edge node and allow ipv4 packets to
enter a Label Switched Path and not just forwarding
MPLS packets.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.57 2009/01/28 12:34:09 claudio Exp $	*/
d196 1
a196 1
	u_char	rtm_pad;
d313 1
@


1.57
log
@Implement basic routing socket filtering. It is possible to give a list --
actually a bitfield -- of routing messages a listener is interested in.
This list can be changed with a setsockopt(s, AF_ROUTE, ROUTE_MSGFILTER, ...)
call. OK henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.56 2009/01/08 12:47:45 michele Exp $	*/
d117 2
a118 1
	caddr_t	rt_llinfo;		/* pointer to link level info cache */
a124 4
#ifdef MPLS
	/* XXX: temporay hack, will be removed soon */
	u_int32_t rt_mpls;		/* MPLS outbound label */
#endif
d147 1
@


1.56
log
@Fix sockaddr_mpls structure.
Now it contains just the label as it must be.

This introduces a ugly hack in rtentry that will be removed
as soon as possible.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.55 2008/12/12 22:07:33 claudio Exp $	*/
d299 8
@


1.55
log
@Introduce a if_priority that will be added to RTP_STATIC when routes are
added without an expilict priority. This allows to specify less prefered
interfaces that will only take over if the primary interface loses link.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.54 2008/11/24 12:53:53 claudio Exp $	*/
d124 4
@


1.54
log
@Implement link-state tracking on the routing table. Routes to interfaces
which are considered down will no be marked ~RTF_UP and so multipath routing
will start to work as expected and not pump 50% of the traffic to nirvana.
Most of the magic happens in rn_mpath_reprio() which fiddles with the
routing table internals. The rest is more straight forward.
get it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.53 2008/11/07 19:09:03 deraadt Exp $	*/
d161 6
a166 6
#define RTP_STATIC	8	/* static routes */
#define RTP_OSPF	16	/* OSPF routes */
#define RTP_ISIS	20	/* IS-IS routes */
#define RTP_RIP		24	/* RIP routes */
#define RTP_BGP		32	/* BGP routes */
#define RTP_DEFAULT	48	/* routes that have nothing set */
@


1.53
log
@use do { } while (/* CONSTCOND */ 0) construct for all multi-line functional macros; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.52 2008/09/15 20:11:05 claudio Exp $	*/
d416 4
@


1.52
log
@Add RTP_MASK and RTP_DOWN needed for upcomming link state tracking.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.51 2008/06/08 19:12:28 claudio Exp $	*/
d350 6
a355 6
#define	RTFREE(rt) do { \
	if ((rt)->rt_refcnt <= 1) \
		rtfree(rt); \
	else \
		(rt)->rt_refcnt--; \
} while (0)
@


1.51
log
@First minimal cleanup of routing code, kill rtrequest() it got replaced with
rtrequest1() everywhere now. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.50 2008/05/23 15:51:12 thib Exp $	*/
d169 2
@


1.50
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.49 2008/05/07 05:14:21 claudio Exp $	*/
a410 3
int	 rtrequest(int, struct sockaddr *,
			struct sockaddr *, struct sockaddr *, int,
			struct rtentry **, u_int);
@


1.49
log
@Implement routing priorities. Every route inserted has a priority assigned
and the one route with the lowest number wins. This will be used by the
routing daemons to resolve the synchronisations issue in case of conflicts.
The nasty bits of this are in the multipath code. If no priority is specified
the kernel will choose an appropriate priority.

Looked at by a few people at n2k8 code is much older
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.48 2008/04/23 10:55:14 norby Exp $	*/
d372 1
a372 1
			   struct mbuf *, struct mbuf *);
@


1.48
log
@Import MPLS (Multi Protocol Label Switching)

MPLS support partly based on the (abandoned?) AYAME project.
Basic LSR (Label Switch Router) functionality is present, but not fully
functional yet.

It is currently possible to insert entries in the LIB (Label Information Base)
with route(8), but setting the operation type is not supported yet.

Imported to allow more people to work on this in the coming weeks.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.47 2007/09/03 15:24:49 claudio Exp $	*/
d115 1
a115 1
	struct	ifaddr *rt_ifa;		/* the answer: interface to use */
d123 1
a143 1
#define RTF_SOURCE	0x20000		/* this route has a source selector */
d154 2
a155 1
#define	RTF_TUNNEL	0x100000	/* Tunnelling bit. */
d158 12
d191 1
a191 1
	u_char	rtm_prio;	/* routing priority */
d414 2
a415 1
int	 rtrequest1(int, struct rt_addrinfo *, struct rtentry **, u_int);
@


1.47
log
@Bump RTM_VERSION to 4 and start a new aera of routing in OpenBSD :)
Changes include 64bit counters instead of u_long, routing table id in the header
of most messages, reserved routing priority field, added a hdrlen field to skip
over the header so that binary compatibility becomes easier.
A minimal backward support for old binaries is included to ease upgrades but
don't expect anything more than ifconfig, route and dhclient to correctly work.
OK henning@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.46 2006/06/18 11:47:45 pascoe Exp $	*/
d293 1
@


1.46
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.45 2006/06/16 16:52:08 henning Exp $	*/
d62 5
a66 4
	u_long	rmx_locks;	/* Kernel must leave these values alone */
	u_long	rmx_mtu;	/* MTU for this path */
	u_long	rmx_expire;	/* lifetime for route, e.g. redirect */
	u_long	rmx_pksent;	/* packets sent using this route */
d73 12
a84 10
	u_long	rmx_locks;	/* Kernel must leave these values alone */
	u_long	rmx_mtu;	/* MTU for this path */
	u_long	rmx_hopcount;	/* max hops expected */
	u_long	rmx_expire;	/* lifetime for route, e.g. redirect */
	u_long	rmx_recvpipe;	/* inbound delay-bandwidth product */
	u_long	rmx_sendpipe;	/* outbound delay-bandwidth product */
	u_long	rmx_ssthresh;	/* outbound gateway buffer limit (deprecated) */
	u_long	rmx_rtt;	/* estimated round trip time (deprecated) */
	u_long	rmx_rttvar;	/* estimated rtt variance (deprecated) */
	u_long	rmx_pksent;	/* packets sent using this route */
a85 3
/* XXX overloading some values that are no longer used. */
#define rmx_refcnt rmx_rttvar	/* # held references only used by sysctl */
#define	rmx_rt_tableid rmx_rtt	/* routing table ID */
d175 38
d219 1
a219 2
	int	rtm_use;	/* deprecated use rtm_rmx->rmx_pksent */
#define rtm_fmask	rtm_use	/* bitmask used in RTM_CHANGE message */
d221 1
a221 1
	struct	rt_metrics rtm_rmx; /* metrics themselves */
a222 2
/* overload no longer used field */
#define rtm_tableid	rtm_rmx.rmx_rt_tableid
d224 2
a225 1
#define RTM_VERSION	3	/* Up the ante and ignore older versions */
@


1.45
log
@pass the routing table ID over the routing socket, so we can start to
manipulate alternate tables from userland. new tables are created
implicitely when an RTM_ADD for that table is seen.
ok norby claudio hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.43 2006/06/15 16:33:02 henning Exp $	*/
d346 3
@


1.44
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d85 1
d186 2
@


1.43
log
@put the multiple routing tables support back in, fixed.
problem before: with this, we are no longer using the address family as
array index directly, since only 3 of 31 address fanilies actually attach
a table, but we're using an address family to array index translation (just
another array). there, 0 meant "does not attach a table", thus rt_gettable
has to return a null pointer. unfortunately we were using array index 0 for
whatever af attaches first, and since the list is backwards,, that used to
be ipsec - execpt on ipsec-less ramdisks, where it was inet6, and since
route show blindly iterates over all address families, and all those
without a table pointed to index 0, we got 28 or 29 copies of the v6 table.
i had that right initally, and then i borked it later... re-spotted by
claudio.
ok norby hshoexer claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.42 2006/06/06 15:36:07 deraadt Exp $	*/
d83 1
a83 1
/* XXX overloading rttvar as that value is no longer used. */
d288 2
a308 2
#define	RT_TABLEID_MAX	255

d315 2
d324 2
a325 1
void	 rt_missmsg(int, struct rt_addrinfo *, int, struct ifnet *, int);
d328 1
a328 1
			 struct sockaddr *);
d344 1
a344 1
	 rtalloc1(struct sockaddr *, int);
d357 2
a358 2
			struct rtentry **);
int	 rtrequest1(int, struct rt_addrinfo *, struct rtentry **);
@


1.42
log
@back out multiple routing table diffs (3 of 'em) because this makes
'route show' dump out repeated copies of the v6 routing table on ramdisks.
on some architectures it spins forever doing this, on others it just
goes for a long time printing the v6 routes over and over before terminating.
spotted by jmc and krw, backout diff tested by beck.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.39 2006/04/22 19:43:07 claudio Exp $	*/
d307 2
a338 1
void	 rtable_init(void **);
d358 1
a358 1
struct radix_node_head	*rt_gettable(sa_family_t, int);
@


1.41
log
@use the table ID as array index directly, faster in the forwarding path
we trade higher memory consumption if the user doesn't use continous table
IDs, but in the worst case (table IDs 0 and 255, 64bit machine) that is 2KB
ok claudio ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.40 2006/05/31 01:35:11 henning Exp $	*/
a306 2
#define	RT_TABLEID_MAX	255

d337 1
d357 1
a357 1
struct radix_node_head	*rt_gettable(sa_family_t, u_int);
@


1.40
log
@move us to multiple routing table heads.
-instead of staticaly declaring the heads, allocate memory for them
-add second dimension to the routing table head array, table ID
-space saver: do not use the AF as array index directly, but have an
 AF->index translation array and only account for AFs actually attaching
 a routing table
note that whil ethat allows for multiple routing table heads, nothing uses
taht yet.
tested by many, ok claudio reyk norby mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.39 2006/04/22 19:43:07 claudio Exp $	*/
d306 2
@


1.39
log
@Routes announced via rt_missmsg() do not have rtm_index set. While in most
cases harmless it is used by the IPv6 code. The result is that bgpd is unable
to assigning link local addresses to the correct interface. OK henning@@
Fix for PR 5063.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.38 2006/03/30 09:53:43 claudio Exp $	*/
a336 1
void	 rtable_init(void **);
d356 1
a356 1
struct radix_node_head	*rt_gettable(sa_family_t, int);
@


1.38
log
@In sysctl_dumpentry() pass the rt_refcnt by overloading rmx_rttvar.
This new rmx_refcnt can be used by route(8) to produce the same output
as netstat(1). OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.37 2006/03/22 14:37:44 henning Exp $	*/
d320 1
a320 1
void	 rt_missmsg(int, struct rt_addrinfo *, int, int);
@


1.37
log
@prevent anything outside rote.c from accessing the routing table heads
directly. rather provide a rt_lookup function for regular lookups,
and a rt_gettable for those that need access to the head for some reason.
the latter cases should be revisted later probably so that nothing outside
the routing core code accesses the heads at all...
tested claudio jolan me, ok claudio markus
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.36 2006/03/20 10:03:49 henning Exp $	*/
d78 3
a80 3
	u_long	rmx_ssthresh;	/* outbound gateway buffer limit */
	u_long	rmx_rtt;	/* estimated round trip time */
	u_long	rmx_rttvar;	/* estimated rtt variance */
d83 2
d162 1
a162 1
	u_int32_t rts_newgateway;		/* routes modified by redirects */
@


1.36
log
@introduce rt_if_remove which takes care of routing table updates for an
interface that is removed. use that from if.c and if_tun.c instead of
re-implementing in the latter case. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.35 2006/02/23 14:15:53 claudio Exp $	*/
a306 1
extern struct radix_node_head *rt_tables[];
d355 2
@


1.35
log
@Until now it was only possible to unset the RTF_JUMBO flag on a RTM_CHANGE
request. Extend the "hack" to include more flags (RTF_PROTO[123] flags,
RTF_BLACKHOLE, RTF_REJECT and RTF_STATIC). Because rtm_use is "abused" --
rtm_use was replaced long time ago with rtm_rmx->rmx_pksent -- it is now
forced to 0 in RTM_GET requests and sysctl_dumpentry(). This is done to
prevent false changes because of a reused RTM_GET message.
OK henning@@, mcbride@@, makes sense markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.34 2005/11/29 02:59:42 jolan Exp $	*/
d354 1
@


1.34
log
@something in the eurobsdcon route-a-thon broke my simple home network
router so back out the routing stuff to pre-eurobsdcon where my machine
doesn't crash immediately.

i am happy to test diffs and report success/failures but i am not happy
to have instantaneous crashes when i reboot with a new kernel that was
compiled from pristine sources.

if you are going to be an elitist asshole then you could at least make
sure your code works.

ok and "be crass towards them" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.31 2005/06/25 19:25:06 henning Exp $	*/
d144 5
d178 1
a178 1
	int	rtm_use;	/* from rtentry */
@


1.33
log
@don't let anything outside route.c access the routing table heads directly,
but go through a provided wrapper.
also provide rt_lookup() instead of doing the lookup manually in many places.
ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.32 2005/11/25 13:45:02 henning Exp $	*/
d302 1
a348 4
void	 rt_if_remove(struct ifnet *);

struct radix_node_head	*rt_gettable(sa_family_t, int);
struct radix_node	*rt_lookup(struct sockaddr *, struct sockaddr *, int);
@


1.32
log
@move the code to delete routes having a specific interface as output
when the interface is deleted to a function in route.c, and replace
the copies of that code by calls to that function
from basel almost-hackathon
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.31 2005/06/25 19:25:06 henning Exp $	*/
a301 1
extern struct radix_node_head *rt_tables[];
d349 3
@


1.31
log
@hide name2id prototypes in #ifdef _KERNEL, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.30 2005/06/08 06:43:07 henning Exp $	*/
d349 1
@


1.30
log
@kill some leftover bits from netns and iso routing
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.29 2005/05/27 17:18:20 mcbride Exp $	*/
d281 1
a285 1
#ifdef _KERNEL
@


1.29
log
@Add rtm_fmask define to make the (ab)use of rtm_use more obvious.

Suggestion from Cedric Berger

ok marius@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.28 2005/05/27 04:55:27 mcbride Exp $	*/
a246 2
	int	ns_count;
	int	iso_count;
@


1.28
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.27 2005/05/26 22:37:34 henning Exp $	*/
d174 1
@


1.27
log
@remove last races of SIOCADDRT and SIOCDELRT, the 4.3BSD routing table ioctls
theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.26 2004/09/16 22:31:30 henning Exp $	*/
d142 1
@


1.26
log
@handle route labels on RTM_CHANGE, ok mcbride, prodded my markus some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.24 2004/08/03 11:22:15 henning Exp $	*/
a122 14
/*
 * Following structure necessary for 4.3 compatibility;
 * We should eventually move it to a compat file.
 */
struct ortentry {
	u_int32_t rt_hash;		/* to speed lookups */
	struct sockaddr rt_dst;		/* key */
	struct sockaddr rt_gateway;	/* value */
	int16_t	  rt_flags;		/* up/down?, host/net */
	int16_t	  rt_refcnt;		/* # held references */
	u_int32_t rt_ouse;		/* raw # packets forwarded (was: rt_use) */
	struct ifnet *rt_ifp;		/* the answer: interface to use */
};

a186 2
#define RTM_OLDADD	0x9	/* caused by SIOCADDRT */
#define RTM_OLDDEL	0xa	/* caused by SIOCDELRT */
@


1.25
log
@ewps, kill the src route prototypes. was sitting in my tree for ages but
forgot to commit...
@
text
@d298 2
@


1.24
log
@introduce route labels, allowing for up to 32 bytes of info to be attached
to a route.
the label is sent over the routing socket wrapped into a new
struct sockaddr_rtlabel, allowing for handling it like any other sockaddr.
struct rtentry only contains a (16 bit) label-ID, with the actual labels
kept outside the routing table.
ID allocator code inspired by my own code for altq and pf tags.
mostly hacked at the c2k4 hackathon, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.23 2004/06/19 19:55:53 cedric Exp $	*/
a362 15

#ifndef SMALL_KERNEL
void	 sroute_verify_host(struct rt_addrinfo *);
void	 sroute_clone_route(struct rt_addrinfo *, struct sockaddr *,
	    struct sockaddr *);
void	 sroute_compact(struct rt_addrinfo *, int);
void	 sroute_expand(struct rt_addrinfo *);
struct sockaddr * 
	 sroute_clone_mask4(struct sockaddr *, struct sockaddr *);
#else
#define	 sroute_compact(ai, int)
#define	 sroute_expand(ai)
#define	 sroute_clone_mask4(old, gen) ((gen) != NULL ? (gen) : \
	    (struct sockaddr *)&rt_defmask4)
#endif
@


1.23
log
@require RTF_MPATH to enter a multipath route with RTM_ADD.
route(8) takes a new -mpath modifier to enter a multipath route.
requested deraadt@@, ok itojun@@ mcbride@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.22 2004/06/06 16:49:09 cedric Exp $	*/
d119 1
d231 1
d246 2
a247 1
#define RTAX_MAX	10	/* size of array to allocate */
d288 10
@


1.22
log
@extend routing table to be able to match and route packets based on
their *source* IP address in addition to their destination address.
routing table "destination" now contains a "struct sockaddr_rtin"
for IPv4 instead of a "struct sockaddr_in".
the routing socket has been extended in a backward-compatible way.
todo: PMTU enhancements, IPv6. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.21 2004/05/04 22:50:18 claudio Exp $	*/
d154 1
@


1.21
log
@The tcp specific routing metrics are almost never used so reduce the routing
table from these metrics. struct rt_msghdr used by the routing socket is not
affected and so most userland apps don't need to be changed.
some man page polishing by jmc@@
OK henning@@ markus@@ theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.20 2004/04/25 02:48:04 itojun Exp $	*/
d153 1
d227 2
d241 3
a243 1
#define RTAX_MAX	8	/* size of array to allocate */
d303 1
d349 16
@


1.20
log
@radix tree with multipath support.  from kame.  deraadt ok
user visible changes:
- you can add multiple routes with same key (route add A B then route add A C)
- you have to specify gateway address if there are multiple entries on the table
  (route delete A B, instead of route delete A)
kernel change:
- radix_node_head has an extra entry
- rnh_deladdr takes extra argument

TODO:
- actually take advantage of multipath (rtalloc -> rtalloc_mpath)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.19 2004/01/15 10:47:55 markus Exp $	*/
d61 10
a110 1
	u_long	rt_use;			/* raw # packets forwarded */
d115 1
a115 1
	struct	rt_metrics rt_rmx;	/* metrics used by rx'ing protocols */
d312 2
a313 1
void	 rt_setmetrics(u_long, struct rt_metrics *, struct rt_metrics *);
@


1.19
log
@add a RTM_IFANNOUNCE message; from netbsd; ok itojun, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.18 2003/08/26 08:33:12 itojun Exp $	*/
d92 1
@


1.18
log
@mark cloned route with RTF_CLONED.  remove RTF_CLONED route when clone parent
disappers.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.17 2003/06/02 23:28:12 millert Exp $	*/
d194 1
d295 1
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.16 2003/02/12 14:41:07 jason Exp $	*/
d142 1
@


1.16
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.15 2003/01/17 17:48:25 camield Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16.2.1
log
@Pull patch from -current:
Fixed by itojun@@

Fix on-link DoS by bogus ARP. Reported by Apple.

ok itojun@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.16 2003/02/12 14:41:07 jason Exp $	*/
a145 1
#define RTF_CLONED	0x10000		/* this is a cloned route */
@


1.15
log
@typo: bandwith -> bandwidth
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.14 2002/03/14 03:16:10 millert Exp $	*/
d287 3
a289 3
struct	route_cb route_cb;
struct	rtstat	rtstat;
struct	radix_node_head *rt_tables[AF_MAX+1];
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.13 2002/03/14 01:27:10 millert Exp $	*/
d70 2
a71 2
	u_long	rmx_recvpipe;	/* inbound delay-bandwith product */
	u_long	rmx_sendpipe;	/* outbound delay-bandwith product */
@


1.14.4.1
log
@Pull patch from -current:
Fixed by itojun@@

Fix on-link DoS by bogus ARP. Reported by Apple.

ok itojun@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.14 2002/03/14 03:16:10 millert Exp $	*/
a145 1
#define RTF_CLONED	0x10000		/* this is a cloned route */
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.12 2001/06/09 06:16:39 angelos Exp $	*/
d304 1
a304 1
int      rt_timer_add __P((struct rtentry *,
d306 1
a306 1
	     struct rttimer_queue *));
@


1.12
log
@By popular demand, protect from multiple inclusion, and fix to use the
same naming style.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.11 2001/01/19 06:37:36 itojun Exp $	*/
d260 2
a261 2
	void            	(*rtt_func) __P((struct rtentry *, 
						 struct rttimer *));
d292 12
a303 12
void	 route_init __P((void));
int	 route_output __P((struct mbuf *, ...));
int	 route_usrreq __P((struct socket *, int, struct mbuf *,
			   struct mbuf *, struct mbuf *));
void	 rt_ifmsg __P((struct ifnet *));
void	 rt_maskedcopy __P((struct sockaddr *,
	    struct sockaddr *, struct sockaddr *));
void	 rt_missmsg __P((int, struct rt_addrinfo *, int, int));
void	 rt_newaddrmsg __P((int, struct ifaddr *, int, struct rtentry *));
int	 rt_setgate __P((struct rtentry *, struct sockaddr *,
			 struct sockaddr *));
void	 rt_setmetrics __P((u_long, struct rt_metrics *, struct rt_metrics *));
d307 1
a307 1
void	 rt_timer_init __P((void));
d309 8
a316 8
	 rt_timer_queue_create __P((u_int));
void	 rt_timer_queue_change __P((struct rttimer_queue *, long));
void	 rt_timer_queue_destroy __P((struct rttimer_queue *, int));
void	 rt_timer_remove_all __P((struct rtentry *));
unsigned long	rt_timer_count __P((struct rttimer_queue *));
void	 rt_timer_timer __P((void *));
void	 rtable_init __P((void **));
void	 rtalloc __P((struct route *));
d318 2
a319 2
	 rtalloc1 __P((struct sockaddr *, int));
void	 rtalloc_noclone __P((struct route *, int));
d321 6
a326 6
	 rtalloc2 __P((struct sockaddr *, int, int));
void	 rtfree __P((struct rtentry *));
int	 rt_getifa __P((struct rt_addrinfo *));
int	 rtinit __P((struct ifaddr *, int, int));
int	 rtioctl __P((u_long, caddr_t, struct proc *));
void	 rtredirect __P((struct sockaddr *, struct sockaddr *,
d328 2
a329 2
			 struct rtentry **));
int	 rtrequest __P((int, struct sockaddr *,
d331 2
a332 2
			struct rtentry **));
int	 rtrequest1 __P((int, struct rt_addrinfo *, struct rtentry **));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.12 2001/06/09 06:16:39 angelos Exp $	*/
d260 2
a261 2
	void            	(*rtt_func)(struct rtentry *, 
						 struct rttimer *);
d292 13
a304 13
void	 route_init(void);
int	 route_output(struct mbuf *, ...);
int	 route_usrreq(struct socket *, int, struct mbuf *,
			   struct mbuf *, struct mbuf *);
void	 rt_ifmsg(struct ifnet *);
void	 rt_maskedcopy(struct sockaddr *,
	    struct sockaddr *, struct sockaddr *);
void	 rt_missmsg(int, struct rt_addrinfo *, int, int);
void	 rt_newaddrmsg(int, struct ifaddr *, int, struct rtentry *);
int	 rt_setgate(struct rtentry *, struct sockaddr *,
			 struct sockaddr *);
void	 rt_setmetrics(u_long, struct rt_metrics *, struct rt_metrics *);
int      rt_timer_add(struct rtentry *,
d306 2
a307 2
	     struct rttimer_queue *);
void	 rt_timer_init(void);
d309 8
a316 8
	 rt_timer_queue_create(u_int);
void	 rt_timer_queue_change(struct rttimer_queue *, long);
void	 rt_timer_queue_destroy(struct rttimer_queue *, int);
void	 rt_timer_remove_all(struct rtentry *);
unsigned long	rt_timer_count(struct rttimer_queue *);
void	 rt_timer_timer(void *);
void	 rtable_init(void **);
void	 rtalloc(struct route *);
d318 2
a319 2
	 rtalloc1(struct sockaddr *, int);
void	 rtalloc_noclone(struct route *, int);
d321 6
a326 6
	 rtalloc2(struct sockaddr *, int, int);
void	 rtfree(struct rtentry *);
int	 rt_getifa(struct rt_addrinfo *);
int	 rtinit(struct ifaddr *, int, int);
int	 rtioctl(u_long, caddr_t, struct proc *);
void	 rtredirect(struct sockaddr *, struct sockaddr *,
d328 2
a329 2
			 struct rtentry **);
int	 rtrequest(int, struct sockaddr *,
d331 2
a332 2
			struct rtentry **);
int	 rtrequest1(int, struct rt_addrinfo *, struct rtentry **);
@


1.12.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 2
a71 2
	u_long	rmx_recvpipe;	/* inbound delay-bandwidth product */
	u_long	rmx_sendpipe;	/* outbound delay-bandwidth product */
d287 3
a289 3
extern struct route_cb route_cb;
extern struct rtstat rtstat;
extern struct radix_node_head *rt_tables[];
@


1.11
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.10 2000/12/09 03:15:25 itojun Exp $	*/
d39 3
d334 1
@


1.10
log
@drop support for RTF_TUNNEL, which has no effect (NRL IPv6)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.9 2000/12/09 03:06:55 itojun Exp $	*/
d232 4
d320 1
d329 1
@


1.9
log
@supply counter for # of routing table timer entries.
(preparation for ICMPv6 too big dos prevention)  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.8 2000/05/17 00:21:12 deraadt Exp $	*/
d144 2
a145 5
/*
 * New IPv6 routing flags.
 *
 * PROTO1 and PROTO2 are used, and defined in netinet6/ipv6_var.h.
 */
d147 1
a323 1
void	 ipv4_tunnelsetup __P((struct rtentry *));
@


1.8
log
@crank rt_refcnt to 32 bits, no userland effects
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.7 1999/12/08 06:50:18 itojun Exp $	*/
d262 1
d308 1
@


1.7
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.6 1999/05/16 00:34:40 ho Exp $	*/
d100 1
a100 2
	short	rt_refcnt;		/* # held references */
	short	rt_filler;		/* XXX */
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.11 2001/01/19 06:37:36 itojun Exp $	*/
d100 2
a101 1
	int	rt_refcnt;		/* # held references */
d145 5
a149 2
#ifndef _KERNEL
/* obsoleted */
a150 1
#endif
a234 4
	int	rti_flags;
	struct	ifaddr *rti_ifa;
	struct	ifnet *rti_ifp;
	struct	rt_msghdr *rti_rtm;
a262 1
	unsigned long			rtq_count;
a307 1
unsigned long	rt_timer_count __P((struct rttimer_queue *));
a316 1
int	 rt_getifa __P((struct rt_addrinfo *));
d325 1
a325 1
int	 rtrequest1 __P((int, struct rt_addrinfo *, struct rtentry **));
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.7.2.1 2001/05/14 22:40:04 niklas Exp $	*/
a38 3
#ifndef _NET_ROUTE_H_
#define _NET_ROUTE_H_

a330 1
#endif /* _NET_ROUTE_H_ */
@


1.7.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d260 2
a261 2
	void            	(*rtt_func)(struct rtentry *, 
						 struct rttimer *);
d292 13
a304 13
void	 route_init(void);
int	 route_output(struct mbuf *, ...);
int	 route_usrreq(struct socket *, int, struct mbuf *,
			   struct mbuf *, struct mbuf *);
void	 rt_ifmsg(struct ifnet *);
void	 rt_maskedcopy(struct sockaddr *,
	    struct sockaddr *, struct sockaddr *);
void	 rt_missmsg(int, struct rt_addrinfo *, int, int);
void	 rt_newaddrmsg(int, struct ifaddr *, int, struct rtentry *);
int	 rt_setgate(struct rtentry *, struct sockaddr *,
			 struct sockaddr *);
void	 rt_setmetrics(u_long, struct rt_metrics *, struct rt_metrics *);
int      rt_timer_add(struct rtentry *,
d306 2
a307 2
	     struct rttimer_queue *);
void	 rt_timer_init(void);
d309 8
a316 8
	 rt_timer_queue_create(u_int);
void	 rt_timer_queue_change(struct rttimer_queue *, long);
void	 rt_timer_queue_destroy(struct rttimer_queue *, int);
void	 rt_timer_remove_all(struct rtentry *);
unsigned long	rt_timer_count(struct rttimer_queue *);
void	 rt_timer_timer(void *);
void	 rtable_init(void **);
void	 rtalloc(struct route *);
d318 2
a319 2
	 rtalloc1(struct sockaddr *, int);
void	 rtalloc_noclone(struct route *, int);
d321 6
a326 6
	 rtalloc2(struct sockaddr *, int, int);
void	 rtfree(struct rtentry *);
int	 rt_getifa(struct rt_addrinfo *);
int	 rtinit(struct ifaddr *, int, int);
int	 rtioctl(u_long, caddr_t, struct proc *);
void	 rtredirect(struct sockaddr *, struct sockaddr *,
d328 2
a329 2
			 struct rtentry **);
int	 rtrequest(int, struct sockaddr *,
d331 2
a332 2
			struct rtentry **);
int	 rtrequest1(int, struct rt_addrinfo *, struct rtentry **);
@


1.7.2.4
log
@Sync the SMP branch with 3.3
@
text
@d70 2
a71 2
	u_long	rmx_recvpipe;	/* inbound delay-bandwidth product */
	u_long	rmx_sendpipe;	/* outbound delay-bandwidth product */
d287 3
a289 3
extern struct route_cb route_cb;
extern struct rtstat rtstat;
extern struct radix_node_head *rt_tables[];
@


1.7.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.7.2.4 2003/03/28 00:41:29 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a141 1
#define RTF_CLONED	0x10000		/* this is a cloned route */
a192 1
#define RTM_IFANNOUNCE	0xf	/* iface arrival/departure */
a292 1
void	 rt_ifannouncemsg(struct ifnet *, int);
@


1.7.2.7
log
@Merge with the trunk
@
text
@a60 10
struct rt_kmetrics {
	u_long	rmx_locks;	/* Kernel must leave these values alone */
	u_long	rmx_mtu;	/* MTU for this path */
	u_long	rmx_expire;	/* lifetime for route, e.g. redirect */
	u_long	rmx_pksent;	/* packets sent using this route */
};

/*
 * Huge version for userland compatibility.
 */
a91 1
#include <net/radix_mpath.h>
d100 1
d105 1
a105 1
	struct	rt_kmetrics rt_rmx;	/* metrics used by rx'ing protocols */
d302 1
a302 2
void	 rt_setmetrics(u_long, struct rt_metrics *, struct rt_kmetrics *);
void	 rt_getmetrics(struct rt_kmetrics *, struct rt_metrics *);
@


1.7.2.8
log
@sync to head
@
text
@a152 1
#define RTF_SOURCE	0x20000		/* this route has a source selector */
a225 2
#define RTA_SRC		0x100	/* source sockaddr present */
#define RTA_SRCMASK	0x200	/* source netmask present */
d238 1
a238 3
#define RTAX_SRC	8	/* source sockaddr present */
#define RTAX_SRCMASK	9	/* source netmask present */
#define RTAX_MAX	10	/* size of array to allocate */
a297 1
extern const struct sockaddr_rtin rt_defmask4;
a342 16

#ifndef SMALL_KERNEL
void	 sroute_verify_host(struct rt_addrinfo *);
void	 sroute_clone_route(struct rt_addrinfo *, struct sockaddr *,
	    struct sockaddr *);
void	 sroute_compact(struct rt_addrinfo *, int);
void	 sroute_expand(struct rt_addrinfo *);
struct sockaddr * 
	 sroute_clone_mask4(struct sockaddr *, struct sockaddr *);
#else
#define	 sroute_compact(ai, int)
#define	 sroute_expand(ai)
#define	 sroute_clone_mask4(old, gen) ((gen) != NULL ? (gen) : \
	    (struct sockaddr *)&rt_defmask4)
#endif

@


1.6
log
@Add support for static ARP entries that cannot be overwritten.
Ordinary static ARPs that are overwritten will no longer still be static.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.5 1999/02/04 00:04:35 deraadt Exp $	*/
d39 2
d110 1
d239 1
d245 22
d299 10
@


1.5
log
@u_int32_t for routing statistics variables
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.4 1999/01/08 00:56:06 deraadt Exp $	*/
d138 1
@


1.4
log
@INET6 support; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.3 1998/02/22 01:23:29 niklas Exp $	*/
d152 5
a156 5
	short	rts_badredirect;	/* bogus redirect calls */
	short	rts_dynamic;		/* routes created by redirects */
	short	rts_newgateway;		/* routes modified by redirects */
	short	rts_unreach;		/* lookups which failed */
	short	rts_wildcard;		/* lookups satisfied by a wildcard */
d158 1
@


1.3
log
@Changes made for GCC 2.8 -Wall pleasures
@
text
@d1 1
a1 1
/*	$OpenBSD: route.h,v 1.2 1996/03/03 21:07:20 niklas Exp $	*/
d97 1
a97 1
	short	rt_flags;		/* up/down?, host/net */
d99 1
d107 1
d109 1
d121 1
a121 1
	u_int32_t rt_use;		/* raw # packets forwarded */
d141 6
d247 7
d275 3
d287 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d231 1
a231 1
#define	RTFREE(rt) \
d235 2
a236 1
		(rt)->rt_refcnt--;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: route.h,v 1.8 1995/03/26 20:30:19 jtc Exp $	*/
d243 3
a245 3
int	 route_output __P((struct mbuf *, struct socket *));
int	 route_usrreq __P((struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *));
d251 2
a252 2
int	 rt_setgate __P((struct rtentry *,
	    struct sockaddr *, struct sockaddr *));
d261 3
a263 2
int	 rtredirect __P((struct sockaddr *, struct sockaddr *,
	    struct sockaddr *, int, struct sockaddr *, struct rtentry **));
d265 2
a266 1
	    struct sockaddr *, struct sockaddr *, int, struct rtentry **));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
