head	1.238;
access;
symbols
	OPENBSD_6_1:1.235.0.4
	OPENBSD_6_1_BASE:1.235
	OPENBSD_6_0:1.194.0.4
	OPENBSD_6_0_BASE:1.194
	OPENBSD_5_9:1.186.0.2
	OPENBSD_5_9_BASE:1.186
	OPENBSD_5_8:1.166.0.4
	OPENBSD_5_8_BASE:1.166
	OPENBSD_5_7:1.157.0.2
	OPENBSD_5_7_BASE:1.157
	OPENBSD_5_6:1.150.0.4
	OPENBSD_5_6_BASE:1.150
	OPENBSD_5_5:1.139.0.4
	OPENBSD_5_5_BASE:1.139
	OPENBSD_5_4:1.126.0.2
	OPENBSD_5_4_BASE:1.126
	OPENBSD_5_3:1.123.0.2
	OPENBSD_5_3_BASE:1.123
	OPENBSD_5_2:1.119.0.2
	OPENBSD_5_2_BASE:1.119
	OPENBSD_5_1_BASE:1.118
	OPENBSD_5_1:1.118.0.4
	OPENBSD_5_0:1.118.0.2
	OPENBSD_5_0_BASE:1.118
	OPENBSD_4_9:1.114.0.2
	OPENBSD_4_9_BASE:1.114
	OPENBSD_4_8:1.105.0.2
	OPENBSD_4_8_BASE:1.105
	OPENBSD_4_7:1.97.0.2
	OPENBSD_4_7_BASE:1.97
	OPENBSD_4_6:1.92.0.4
	OPENBSD_4_6_BASE:1.92
	OPENBSD_4_5:1.84.0.2
	OPENBSD_4_5_BASE:1.84
	OPENBSD_4_4:1.75.0.2
	OPENBSD_4_4_BASE:1.75
	OPENBSD_4_3:1.68.0.2
	OPENBSD_4_3_BASE:1.68
	OPENBSD_4_2:1.63.0.4
	OPENBSD_4_2_BASE:1.63
	OPENBSD_4_1:1.63.0.2
	OPENBSD_4_1_BASE:1.63
	OPENBSD_4_0:1.62.0.2
	OPENBSD_4_0_BASE:1.62
	OPENBSD_3_9:1.53.0.2
	OPENBSD_3_9_BASE:1.53
	OPENBSD_3_8:1.48.0.2
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.42.0.2
	OPENBSD_3_6_BASE:1.42
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.24
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.238
date	2017.06.09.12.56.43;	author mpi;	state Exp;
branches;
next	1.237;
commitid	QXIy2rZA5FPYfFIG;

1.237
date	2017.04.19.15.21.54;	author bluhm;	state Exp;
branches;
next	1.236;
commitid	86fZyVCZMRPZ29Fb;

1.236
date	2017.04.05.13.35.18;	author deraadt;	state Exp;
branches;
next	1.235;
commitid	4O5LUh13nIhVt6oZ;

1.235
date	2017.03.16.10.13.11;	author mpi;	state Exp;
branches;
next	1.234;
commitid	CgACIxqZf9qWV6JJ;

1.234
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.233;
commitid	ZsxSSZJSFxZH81LL;

1.233
date	2017.03.09.16.53.20;	author mpi;	state Exp;
branches;
next	1.232;
commitid	s6HXgZg0czvufjfz;

1.232
date	2017.03.07.09.23.27;	author mpi;	state Exp;
branches;
next	1.231;
commitid	ilH9l7TRBZ95J9uu;

1.231
date	2017.03.07.06.58.55;	author claudio;	state Exp;
branches;
next	1.230;
commitid	wH1FprvmVurxi5KV;

1.230
date	2017.03.06.10.19.17;	author mpi;	state Exp;
branches;
next	1.229;
commitid	Hyu1wsw6aCc6M7ZD;

1.229
date	2017.03.06.08.56.39;	author mpi;	state Exp;
branches;
next	1.228;
commitid	aDXuIkVsOPuafbD0;

1.228
date	2017.03.03.15.48.02;	author bluhm;	state Exp;
branches;
next	1.227;
commitid	LtQeAWkATeJFPv2t;

1.227
date	2017.03.03.14.22.40;	author bluhm;	state Exp;
branches;
next	1.226;
commitid	acAffVaDeBPro8T9;

1.226
date	2017.03.02.17.09.21;	author krw;	state Exp;
branches;
next	1.225;
commitid	8FJMneZtCagt8T1v;

1.225
date	2017.03.02.09.37.04;	author mpi;	state Exp;
branches;
next	1.224;
commitid	i7i02LR2dyVd6Hgx;

1.224
date	2017.03.02.08.58.24;	author mpi;	state Exp;
branches;
next	1.223;
commitid	tz6lHk1OQ6UxADoY;

1.223
date	2017.02.22.19.34.42;	author dhill;	state Exp;
branches;
next	1.222;
commitid	8MQyAJVsE6ZNz4mh;

1.222
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.221;
commitid	UBL7uwpXqTP4EWIu;

1.221
date	2017.01.31.10.24.41;	author jca;	state Exp;
branches;
next	1.220;
commitid	A2smg1VkYafec3DU;

1.220
date	2017.01.24.00.17.14;	author claudio;	state Exp;
branches;
next	1.219;
commitid	B5D7G7PNSl7h0toG;

1.219
date	2017.01.23.07.27.21;	author dlg;	state Exp;
branches;
next	1.218;
commitid	GMRaunaipkxtJbHJ;

1.218
date	2017.01.23.01.26.09;	author dlg;	state Exp;
branches;
next	1.217;
commitid	3JbnbVjcNixwggnm;

1.217
date	2017.01.23.00.10.07;	author krw;	state Exp;
branches;
next	1.216;
commitid	iQ04yZ2y9RiANbVX;

1.216
date	2017.01.22.04.31.02;	author claudio;	state Exp;
branches;
next	1.215;
commitid	wyBGc1XNpiQJEqzv;

1.215
date	2017.01.21.03.44.46;	author claudio;	state Exp;
branches;
next	1.214;
commitid	auQJO238UgnlKZs2;

1.214
date	2017.01.20.08.10.54;	author dlg;	state Exp;
branches;
next	1.213;
commitid	CNOX7FmsAKFjfz9O;

1.213
date	2017.01.19.23.18.29;	author phessler;	state Exp;
branches;
next	1.212;
commitid	blN5b1tPhlkhcTy8;

1.212
date	2016.12.20.18.33.43;	author bluhm;	state Exp;
branches;
next	1.211;
commitid	xiXE7MGPpVXw2TS3;

1.211
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.210;
commitid	QqHqT2WhCBWqYgGJ;

1.210
date	2016.11.29.10.22.30;	author jsg;	state Exp;
branches;
next	1.209;
commitid	ZQetSMB5ilG2z10X;

1.209
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.208;
commitid	wuzpseLx3Ntn9R7b;

1.208
date	2016.10.18.11.05.45;	author bluhm;	state Exp;
branches;
next	1.207;
commitid	WheaZaRo7Rls5wW2;

1.207
date	2016.09.27.18.41.11;	author bluhm;	state Exp;
branches;
next	1.206;
commitid	EUiNTBHshE5AHhXC;

1.206
date	2016.09.24.19.27.10;	author phessler;	state Exp;
branches;
next	1.205;
commitid	xFHL1u2ecZCDed8g;

1.205
date	2016.09.17.07.35.05;	author phessler;	state Exp;
branches;
next	1.204;
commitid	XybSw76BMA6y6rFn;

1.204
date	2016.09.07.09.36.49;	author mpi;	state Exp;
branches;
next	1.203;
commitid	maggOul7Gx8kGBXs;

1.203
date	2016.09.05.15.12.30;	author claudio;	state Exp;
branches;
next	1.202;
commitid	9stAtK16gR2yeKoN;

1.202
date	2016.09.04.09.39.01;	author claudio;	state Exp;
branches;
next	1.201;
commitid	WcOp57BWVEJv93S4;

1.201
date	2016.09.01.17.00.38;	author claudio;	state Exp;
branches;
next	1.200;
commitid	yUj3wLfntVj2SryN;

1.200
date	2016.09.01.16.53.38;	author claudio;	state Exp;
branches;
next	1.199;
commitid	DY8BkUTMFBc2RyzJ;

1.199
date	2016.09.01.11.26.44;	author mpi;	state Exp;
branches;
next	1.198;
commitid	D9xUXuCVpAub3X0F;

1.198
date	2016.09.01.09.35.28;	author mpi;	state Exp;
branches;
next	1.197;
commitid	cnJvxabO3HVjp46U;

1.197
date	2016.09.01.09.22.58;	author mpi;	state Exp;
branches;
next	1.196;
commitid	sT1tK4q1huEK9XZy;

1.196
date	2016.08.23.13.07.26;	author mpi;	state Exp;
branches;
next	1.195;
commitid	d7GTvI4QkijD0IuA;

1.195
date	2016.08.22.16.01.52;	author mpi;	state Exp;
branches;
next	1.194;
commitid	Jx7agqiuXqs8RRGd;

1.194
date	2016.07.11.13.06.31;	author bluhm;	state Exp;
branches;
next	1.193;
commitid	s9vCFtJQBVcyR7KD;

1.193
date	2016.07.11.09.23.06;	author mpi;	state Exp;
branches;
next	1.192;
commitid	Z6QboMLW08GSdJ1F;

1.192
date	2016.06.14.09.48.52;	author mpi;	state Exp;
branches;
next	1.191;
commitid	dn8iB9zOSqejUgHj;

1.191
date	2016.06.14.09.44.41;	author mpi;	state Exp;
branches;
next	1.190;
commitid	jROApUVEsAXWIH7k;

1.190
date	2016.06.03.02.56.59;	author dlg;	state Exp;
branches;
next	1.189;
commitid	HDQtg6ec5B2YoCBq;

1.189
date	2016.06.01.12.06.49;	author mpi;	state Exp;
branches;
next	1.188;
commitid	lrgKeyCVpbahAlZ0;

1.188
date	2016.03.30.10.13.14;	author mpi;	state Exp;
branches;
next	1.187;
commitid	xpsJgMCf9pVyesEt;

1.187
date	2016.03.26.21.56.04;	author mpi;	state Exp;
branches;
next	1.186;
commitid	vJtQRrj5mFxFKXT0;

1.186
date	2016.01.12.09.27.46;	author mpi;	state Exp;
branches;
next	1.185;
commitid	yXqbKweZCu3A1llV;

1.185
date	2015.12.03.21.57.59;	author mpi;	state Exp;
branches;
next	1.184;
commitid	nmbu8xP0zmz2PPN0;

1.184
date	2015.12.03.14.19.55;	author mpi;	state Exp;
branches;
next	1.183;
commitid	Hw0CeagIhkCLzao6;

1.183
date	2015.11.18.14.13.52;	author mpi;	state Exp;
branches;
next	1.182;
commitid	a6JUdrfdhORyb0Np;

1.182
date	2015.11.09.10.26.26;	author mpi;	state Exp;
branches;
next	1.181;
commitid	xyXAt3vnFrCMLsjZ;

1.181
date	2015.11.02.14.40.09;	author mpi;	state Exp;
branches;
next	1.180;
commitid	RcfM7kXINWo9mOSk;

1.180
date	2015.10.30.09.39.42;	author bluhm;	state Exp;
branches;
next	1.179;
commitid	7wrRch1SS813fOcY;

1.179
date	2015.10.25.14.41.09;	author claudio;	state Exp;
branches;
next	1.178;
commitid	lvm0orbPN9p1pCRm;

1.178
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.177;
commitid	G2nTzngqgXpQqcJB;

1.177
date	2015.10.25.10.05.09;	author bluhm;	state Exp;
branches;
next	1.176;
commitid	X8Mu7F8ZYc1VV9Gs;

1.176
date	2015.10.24.11.58.47;	author mpi;	state Exp;
branches;
next	1.175;
commitid	JFhYU2VjHxiDHltL;

1.175
date	2015.10.23.13.41.41;	author bluhm;	state Exp;
branches;
next	1.174;
commitid	XPwHcwlm7RmqoU8d;

1.174
date	2015.10.23.10.22.29;	author claudio;	state Exp;
branches;
next	1.173;
commitid	T6PH2wUDdHyRNguI;

1.173
date	2015.10.22.17.19.38;	author mpi;	state Exp;
branches;
next	1.172;
commitid	AaBRgz5QXsDW1oOO;

1.172
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.171;
commitid	tp9bS9eCrwvRYjyO;

1.171
date	2015.09.21.11.27.08;	author mpi;	state Exp;
branches;
next	1.170;
commitid	DmX3LM4RWuUp26A2;

1.170
date	2015.09.11.16.58.00;	author mpi;	state Exp;
branches;
next	1.169;
commitid	aN3TroyZ9FVMndjv;

1.169
date	2015.08.24.22.11.33;	author mpi;	state Exp;
branches;
next	1.168;
commitid	QLnmQaxOCmSULhEv;

1.168
date	2015.08.19.13.27.38;	author bluhm;	state Exp;
branches;
next	1.167;
commitid	t09qBDKQRv4jxgp3;

1.167
date	2015.08.17.09.46.26;	author mpi;	state Exp;
branches;
next	1.166;
commitid	fNl4s3YsXWND4yAQ;

1.166
date	2015.07.18.21.58.06;	author mpi;	state Exp;
branches;
next	1.165;
commitid	Kzfel0QdKwFYiPuJ;

1.165
date	2015.07.18.15.51.16;	author mpi;	state Exp;
branches;
next	1.164;
commitid	lwQKRpFyNEr7kjoF;

1.164
date	2015.07.18.00.02.30;	author phessler;	state Exp;
branches;
next	1.163;
commitid	OtrLKmLKBvubsQoU;

1.163
date	2015.07.16.18.17.27;	author claudio;	state Exp;
branches;
next	1.162;
commitid	VvtF6H2REt7RsEKf;

1.162
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.161;
commitid	ncpqEGjDtSFuLAgn;

1.161
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.160;
commitid	J4OPNuggl4DOKGzM;

1.160
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.159;
commitid	h7z8lokZ0dFyuWpg;

1.159
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.158;
commitid	hN5bFCE56DrAjl99;

1.158
date	2015.05.05.09.41.43;	author mpi;	state Exp;
branches;
next	1.157;
commitid	5XGj7KJrHBHsoubn;

1.157
date	2015.02.11.23.34.43;	author mpi;	state Exp;
branches;
next	1.156;
commitid	LEl6vk7rMjn9Mb2M;

1.156
date	2015.01.13.12.14.00;	author mpi;	state Exp;
branches;
next	1.155;
commitid	lUGbXdgL8k5aX0xx;

1.155
date	2014.12.19.18.57.17;	author bluhm;	state Exp;
branches;
next	1.154;
commitid	Y7cEc5OLE6eDnM7U;

1.154
date	2014.12.11.08.55.10;	author mpi;	state Exp;
branches;
next	1.153;
commitid	pb53KAcjJQuzbJQe;

1.153
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.152;
commitid	t9FBKDfc4VDxpEy2;

1.152
date	2014.08.12.13.52.08;	author mpi;	state Exp;
branches;
next	1.151;
commitid	DfLTdnrRvTfPSDCZ;

1.151
date	2014.08.11.11.59.05;	author mpi;	state Exp;
branches;
next	1.150;
commitid	hd3GhrMDEgQk7VBd;

1.150
date	2014.07.29.12.18.41;	author mpi;	state Exp;
branches;
next	1.149;
commitid	QxM5HLkQs10iEeT9;

1.149
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.148;
commitid	B4dZSbxas1X1IpXI;

1.148
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.147;
commitid	EF98ch02VpFassUi;

1.147
date	2014.05.31.15.36.44;	author claudio;	state Exp;
branches;
next	1.146;
commitid	sszfLRgn4k0I3ew8;

1.146
date	2014.05.27.19.38.15;	author claudio;	state Exp;
branches;
next	1.145;

1.145
date	2014.05.27.09.39.58;	author mpi;	state Exp;
branches;
next	1.144;

1.144
date	2014.05.16.08.21.54;	author mpi;	state Exp;
branches;
next	1.143;

1.143
date	2014.04.25.10.41.09;	author mpi;	state Exp;
branches;
next	1.142;

1.142
date	2014.03.18.10.47.34;	author mpi;	state Exp;
branches;
next	1.141;

1.141
date	2014.03.17.10.24.40;	author mpi;	state Exp;
branches;
next	1.140;

1.140
date	2014.03.12.12.03.55;	author mpi;	state Exp;
branches;
next	1.139;

1.139
date	2014.02.13.22.01.50;	author bluhm;	state Exp;
branches;
next	1.138;

1.138
date	2014.02.12.13.01.50;	author henning;	state Exp;
branches;
next	1.137;

1.137
date	2014.01.22.06.28.09;	author claudio;	state Exp;
branches;
next	1.136;

1.136
date	2014.01.21.10.08.02;	author mpi;	state Exp;
branches;
next	1.135;

1.135
date	2014.01.20.22.11.42;	author bluhm;	state Exp;
branches;
next	1.134;

1.134
date	2014.01.19.11.20.46;	author claudio;	state Exp;
branches;
next	1.133;

1.133
date	2014.01.10.14.29.08;	author tedu;	state Exp;
branches;
next	1.132;

1.132
date	2014.01.09.21.57.52;	author tedu;	state Exp;
branches;
next	1.131;

1.131
date	2013.11.01.20.09.14;	author bluhm;	state Exp;
branches;
next	1.130;

1.130
date	2013.10.31.18.10.21;	author bluhm;	state Exp;
branches;
next	1.129;

1.129
date	2013.10.20.13.21.57;	author claudio;	state Exp;
branches;
next	1.128;

1.128
date	2013.10.20.12.35.48;	author claudio;	state Exp;
branches;
next	1.127;

1.127
date	2013.08.28.06.58.57;	author mpi;	state Exp;
branches;
next	1.126;

1.126
date	2013.05.17.11.13.37;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2013.03.15.20.45.34;	author tedu;	state Exp;
branches;
next	1.124;

1.124
date	2013.03.07.09.03.16;	author mpi;	state Exp;
branches;
next	1.123;

1.123
date	2012.09.20.20.53.13;	author blambert;	state Exp;
branches
	1.123.2.1;
next	1.122;

1.122
date	2012.09.19.16.14.01;	author blambert;	state Exp;
branches;
next	1.121;

1.121
date	2012.09.19.12.35.07;	author blambert;	state Exp;
branches;
next	1.120;

1.120
date	2012.09.17.19.00.36;	author blambert;	state Exp;
branches;
next	1.119;

1.119
date	2012.03.28.18.10.38;	author claudio;	state Exp;
branches;
next	1.118;

1.118
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.117;

1.117
date	2011.04.04.20.25.35;	author blambert;	state Exp;
branches;
next	1.116;

1.116
date	2011.04.03.17.01.23;	author jsing;	state Exp;
branches;
next	1.115;

1.115
date	2011.03.31.10.36.42;	author jasper;	state Exp;
branches;
next	1.114;

1.114
date	2011.02.14.12.53.27;	author tedu;	state Exp;
branches;
next	1.113;

1.113
date	2011.01.06.14.50.11;	author claudio;	state Exp;
branches;
next	1.112;

1.112
date	2011.01.06.14.45.07;	author claudio;	state Exp;
branches;
next	1.111;

1.111
date	2010.10.28.17.18.35;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2010.10.11.11.41.08;	author claudio;	state Exp;
branches;
next	1.109;

1.109
date	2010.09.08.08.20.45;	author claudio;	state Exp;
branches;
next	1.108;

1.108
date	2010.09.02.09.38.05;	author blambert;	state Exp;
branches;
next	1.107;

1.107
date	2010.08.25.14.07.24;	author claudio;	state Exp;
branches;
next	1.106;

1.106
date	2010.08.24.12.45.08;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2010.07.14.20.56.35;	author claudio;	state Exp;
branches
	1.105.2.1;
next	1.104;

1.104
date	2010.07.14.00.42.57;	author dlg;	state Exp;
branches;
next	1.103;

1.103
date	2010.07.09.15.36.54;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.101;

1.101
date	2010.06.28.18.50.37;	author claudio;	state Exp;
branches;
next	1.100;

1.100
date	2010.05.19.13.09.09;	author claudio;	state Exp;
branches;
next	1.99;

1.99
date	2010.04.21.11.52.46;	author claudio;	state Exp;
branches;
next	1.98;

1.98
date	2010.03.23.15.03.25;	author claudio;	state Exp;
branches;
next	1.97;

1.97
date	2010.02.09.16.34.57;	author claudio;	state Exp;
branches
	1.97.2.1;
next	1.96;

1.96
date	2010.02.09.16.31.14;	author claudio;	state Exp;
branches;
next	1.95;

1.95
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.94;

1.94
date	2009.09.17.13.27.24;	author claudio;	state Exp;
branches;
next	1.93;

1.93
date	2009.07.07.10.38.49;	author michele;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.26.10.14.24;	author blambert;	state Exp;
branches;
next	1.91;

1.91
date	2009.06.22.19.01.56;	author blambert;	state Exp;
branches;
next	1.90;

1.90
date	2009.06.20.10.39.52;	author blambert;	state Exp;
branches;
next	1.89;

1.89
date	2009.06.06.12.31.17;	author rainer;	state Exp;
branches;
next	1.88;

1.88
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.87;

1.87
date	2009.05.31.18.00.54;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.31.03.27.17;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2009.04.18.10.45.47;	author michele;	state Exp;
branches;
next	1.84;

1.84
date	2009.02.03.16.42.54;	author michele;	state Exp;
branches;
next	1.83;

1.83
date	2009.01.28.22.18.44;	author michele;	state Exp;
branches;
next	1.82;

1.82
date	2009.01.28.12.34.09;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2009.01.08.12.47.45;	author michele;	state Exp;
branches;
next	1.80;

1.80
date	2009.01.03.15.31.03;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2008.12.12.21.52.04;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2008.11.22.22.34.11;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2008.11.21.18.01.30;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2008.08.07.21.32.08;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2008.08.01.05.08.08;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2008.07.28.19.38.07;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.13.21.49.57;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2008.06.13.06.10.46;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.70;

1.70
date	2008.05.07.05.14.21;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2008.04.23.10.55.14;	author norby;	state Exp;
branches;
next	1.68;

1.68
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2007.09.09.12.01.58;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.08.16.55.05;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2007.09.07.11.15.19;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2007.09.03.15.24.49;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.62;

1.62
date	2006.06.16.17.45.37;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2006.06.16.16.52.08;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2006.06.16.16.49.39;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.30.21.58.28;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.22.19.43.07;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.31.17.30.39;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.30.09.53.43;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2006.03.30.08.28.16;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.22.14.37.44;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2006.02.23.14.15.53;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2006.02.02.13.59.45;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2005.11.29.02.59.42;	author jolan;	state Exp;
branches;
next	1.50;

1.50
date	2005.11.27.19.33.20;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.27.16.22.45;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2005.06.08.06.43.07;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2005.06.07.18.21.44;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.27.22.37.46;	author mcbride;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.27.07.11.21;	author mcbride;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.27.04.55.27;	author mcbride;	state Exp;
branches;
next	1.43;

1.43
date	2004.09.16.22.31.29;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.03.11.22.15;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.24.22.25.25;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.22.07.35.20;	author cedric;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.06.16.49.09;	author cedric;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.12.20.46.00;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.04.22.50.18;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.25.02.48.04;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.15.10.47.55;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.03.14.08.53;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.14.19.00.12;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.05.00.00.32;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.24.09.09.25;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.23.01.36.52;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.16.21.30.13;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.31.02.30.10;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.17.14.20.19;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.03.02.31.00;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.02.19.38.55;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.10.06.10.53;	author jason;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.21.12.22.57;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.04.23.21.10;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.16.12.53.34;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.19.06.37.37;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.13.21.58.11;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.12.01.27.11;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.17.04.15.29;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.07.06.08.04;	author itojun;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	98.08.24.20.39.40;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	98.05.18.21.10.21;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.12.15.10.13.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.12.12.09.04.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.28.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.21.07.21;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2000.02.20.11.57.21;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2000.03.24.09.09.33;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.05.14.22.40.04;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.07.04.10.54.20;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2001.11.13.22.59.58;	author niklas;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.9.2.9;

1.9.2.9
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.9.2.10;

1.9.2.10
date	2003.05.13.19.36.16;	author ho;	state Exp;
branches;
next	1.9.2.11;

1.9.2.11
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.9.2.12;

1.9.2.12
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.9.2.13;

1.9.2.13
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.9.2.14;

1.9.2.14
date	2004.06.07.20.41.38;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;

1.97.2.1
date	2011.01.13.15.57.32;	author jsg;	state Exp;
branches;
next	;

1.105.2.1
date	2011.01.13.15.53.46;	author jsg;	state Exp;
branches;
next	;

1.123.2.1
date	2013.05.17.11.34.49;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.238
log
@Replace rtrequest(RTM_DELETE...) rtrequest_delete() and do not even
try to remove a route from the table if it is and invalid cache.

This is a step towards decoupling code dealing with userland and kernel
inserted routes.

ok bluhm@@
@
text
@/*	$OpenBSD: rtsock.c,v 1.237 2017/04/19 15:21:54 bluhm Exp $	*/
/*	$NetBSD: rtsock.c,v 1.18 1996/03/29 00:32:10 cgd Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1988, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)rtsock.c	8.6 (Berkeley) 2/11/95
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/sysctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/domain.h>
#include <sys/protosw.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_var.h>
#include <net/route.h>
#include <net/raw_cb.h>

#include <netinet/in.h>

#ifdef MPLS
#include <netmpls/mpls.h>
#endif
#ifdef BFD
#include <net/bfd.h>
#endif

#include <sys/stdarg.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

struct sockaddr		route_dst = { 2, PF_ROUTE, };
struct sockaddr		route_src = { 2, PF_ROUTE, };

struct walkarg {
	int	w_op, w_arg, w_given, w_needed, w_tmemsize;
	caddr_t	w_where, w_tmem;
};

int	route_output(struct mbuf *, struct socket *, struct sockaddr *,
	    struct mbuf *);
int	route_ctloutput(int, struct socket *, int, int, struct mbuf *);
int	route_usrreq(struct socket *, int, struct mbuf *, struct mbuf *,
	    struct mbuf *, struct proc *);
void	route_input(struct mbuf *m0, struct socket *, sa_family_t);
int	route_arp_conflict(struct rtentry *, struct rt_addrinfo *);
int	route_cleargateway(struct rtentry *, void *, unsigned int);
void	route_senddesync(void *);

int	rtm_output(struct rt_msghdr *, struct rtentry **, struct rt_addrinfo *,
	    uint8_t, unsigned int);
struct rt_msghdr *rtm_report(struct rtentry *, u_char, int, int);
struct mbuf	*rtm_msg1(int, struct rt_addrinfo *);
int		 rtm_msg2(int, int, struct rt_addrinfo *, caddr_t,
		     struct walkarg *);
void		 rtm_xaddrs(caddr_t, caddr_t, struct rt_addrinfo *);
int		 rtm_validate_proposal(struct rt_addrinfo *);
void		 rtm_setmetrics(u_long, const struct rt_metrics *,
		     struct rt_kmetrics *);
void		 rtm_getmetrics(const struct rt_kmetrics *,
		     struct rt_metrics *);

int		 sysctl_iflist(int, struct walkarg *);
int		 sysctl_ifnames(struct walkarg *);
int		 sysctl_rtable_rtstat(void *, size_t *, void *);

struct routecb {
	struct rawcb	rcb;
	struct timeout	timeout;
	unsigned int	msgfilter;
	unsigned int	flags;
	u_int		rtableid;
};
#define	sotoroutecb(so)	((struct routecb *)(so)->so_pcb)

struct route_cb {
	int		ip_count;
	int		ip6_count;
	int		mpls_count;
	int		any_count;
};

struct route_cb route_cb;

/*
 * These flags and timeout are used for indicating to userland (via a
 * RTM_DESYNC msg) when the route socket has overflowed and messages
 * have been lost.
 */
#define ROUTECB_FLAG_DESYNC	0x1	/* Route socket out of memory */
#define ROUTECB_FLAG_FLUSH	0x2	/* Wait until socket is empty before
					   queueing more packets */

#define ROUTE_DESYNC_RESEND_TIMEOUT	(hz / 5)	/* In hz */

int
route_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control, struct proc *p)
{
	struct rawcb	*rp;
	struct routecb	*rop;
	int		 af;
	int		 error = 0;

	rp = sotorawcb(so);

	switch (req) {
	case PRU_RCVD:
		rop = (struct routecb *)rp;

		/*
		 * If we are in a FLUSH state, check if the buffer is
		 * empty so that we can clear the flag.
		 */
		if (((rop->flags & ROUTECB_FLAG_FLUSH) != 0) &&
		    ((sbspace(&rp->rcb_socket->so_rcv) ==
		    rp->rcb_socket->so_rcv.sb_hiwat)))
			rop->flags &= ~ROUTECB_FLAG_FLUSH;
		break;

	case PRU_DETACH:
		if (rp) {
			timeout_del(&((struct routecb *)rp)->timeout);
			af = rp->rcb_proto.sp_protocol;
			if (af == AF_INET)
				route_cb.ip_count--;
			else if (af == AF_INET6)
				route_cb.ip6_count--;
#ifdef MPLS
			else if (af == AF_MPLS)
				route_cb.mpls_count--;
#endif
			route_cb.any_count--;
		}
		/* FALLTHROUGH */
	default:
		error = raw_usrreq(so, req, m, nam, control, p);
	}

	return (error);
}

int
route_attach(struct socket *so, int proto)
{
	struct rawcb    *rp;
	struct routecb	*rop;
	int		 af;
	int		 error = 0;

	/*
	 * use the rawcb but allocate a routecb, this
	 * code does not care about the additional fields
	 * and works directly on the raw socket.
	 */
	rop = malloc(sizeof(struct routecb), M_PCB, M_WAITOK|M_ZERO);
	rp = &rop->rcb;
	so->so_pcb = rp;
	/* Init the timeout structure */
	timeout_set(&rop->timeout, route_senddesync, rp);

	if (curproc == NULL)
		error = EACCES;
	else
		error = raw_attach(so, proto);
	if (error) {
		free(rop, M_PCB, sizeof(struct routecb));
		return (error);
	}
	rop->rtableid = curproc->p_p->ps_rtableid;
	af = rp->rcb_proto.sp_protocol;
	if (af == AF_INET)
		route_cb.ip_count++;
	else if (af == AF_INET6)
		route_cb.ip6_count++;
#ifdef MPLS
	else if (af == AF_MPLS)
		route_cb.mpls_count++;
#endif
	rp->rcb_faddr = &route_src;
	route_cb.any_count++;
	soisconnected(so);
	so->so_options |= SO_USELOOPBACK;

	return (error);
}

int
route_ctloutput(int op, struct socket *so, int level, int optname,
    struct mbuf *m)
{
	struct routecb *rop = sotoroutecb(so);
	int error = 0;
	unsigned int tid;

	if (level != AF_ROUTE) {
		error = EINVAL;
		if (op == PRCO_SETOPT && m)
			m_free(m);
		return (error);
	}

	switch (op) {
	case PRCO_SETOPT:
		switch (optname) {
		case ROUTE_MSGFILTER:
			if (m == NULL || m->m_len != sizeof(unsigned int))
				error = EINVAL;
			else
				rop->msgfilter = *mtod(m, unsigned int *);
			break;
		case ROUTE_TABLEFILTER:
			if (m == NULL || m->m_len != sizeof(unsigned int)) {
				error = EINVAL;
				break;
			}
			tid = *mtod(m, unsigned int *);
			if (tid != RTABLE_ANY && !rtable_exists(tid))
				error = ENOENT;
			else
				rop->rtableid = tid;
			break;
		default:
			error = ENOPROTOOPT;
			break;
		}
		m_free(m);
		break;
	case PRCO_GETOPT:
		switch (optname) {
		case ROUTE_MSGFILTER:
			m->m_len = sizeof(unsigned int);
			*mtod(m, unsigned int *) = rop->msgfilter;
			break;
		case ROUTE_TABLEFILTER:
			m->m_len = sizeof(unsigned int);
			*mtod(m, unsigned int *) = rop->rtableid;
			break;
		default:
			error = ENOPROTOOPT;
			break;
		}
	}
	return (error);
}

void
route_senddesync(void *data)
{
	struct rawcb	*rp;
	struct routecb	*rop;
	struct mbuf	*desync_mbuf;

	rp = (struct rawcb *)data;
	rop = (struct routecb *)rp;

	/* If we are in a DESYNC state, try to send a RTM_DESYNC packet */
	if ((rop->flags & ROUTECB_FLAG_DESYNC) == 0)
		return;

	/*
	 * If we fail to alloc memory or if sbappendaddr()
	 * fails, re-add timeout and try again.
	 */
	desync_mbuf = rtm_msg1(RTM_DESYNC, NULL);
	if (desync_mbuf != NULL) {
		if (sbappendaddr(&rp->rcb_socket->so_rcv, &route_src,
		    desync_mbuf, NULL) != 0) {
			rop->flags &= ~ROUTECB_FLAG_DESYNC;
			sorwakeup(rp->rcb_socket);
			return;
		}
		m_freem(desync_mbuf);
	}
	/* Re-add timeout to try sending msg again */
	timeout_add(&rop->timeout, ROUTE_DESYNC_RESEND_TIMEOUT);
}

void
route_input(struct mbuf *m0, struct socket *so, sa_family_t sa_family)
{
	struct rawcb *rp;
	struct routecb *rop;
	struct rt_msghdr *rtm;
	struct mbuf *m = m0;
	int sockets = 0;
	struct socket *last = NULL;
	struct sockaddr *sosrc, *sodst;

	KERNEL_ASSERT_LOCKED();

	sosrc = &route_src;
	sodst = &route_dst;

	/* ensure that we can access the rtm_type via mtod() */
	if (m->m_len < offsetof(struct rt_msghdr, rtm_type) + 1) {
		m_freem(m);
		return;
	}

	LIST_FOREACH(rp, &rawcb, rcb_list) {
		if (rp->rcb_socket->so_state & SS_CANTRCVMORE)
			continue;
		if (rp->rcb_proto.sp_family != PF_ROUTE)
			continue;
		/* Check to see if we don't want our own messages. */
		if (so == rp->rcb_socket && !(so->so_options & SO_USELOOPBACK))
			continue;

		/*
		 * If route socket is bound to an address family only send
		 * messages that match the address family. Address family
		 * agnostic messages are always send.
		 */
		if (rp->rcb_proto.sp_protocol != AF_UNSPEC &&
		    sa_family != AF_UNSPEC &&
		    rp->rcb_proto.sp_protocol != sa_family)
			continue;
		/*
		 * We assume the lower level routines have
		 * placed the address in a canonical format
		 * suitable for a structure comparison.
		 *
		 * Note that if the lengths are not the same
		 * the comparison will fail at the first byte.
		 */
#define	equal(a1, a2) \
  (bcmp((caddr_t)(a1), (caddr_t)(a2), a1->sa_len) == 0)
		if (rp->rcb_laddr && !equal(rp->rcb_laddr, sodst))
			continue;
		if (rp->rcb_faddr && !equal(rp->rcb_faddr, sosrc))
			continue;

		/* filter messages that the process does not want */
		rop = (struct routecb *)rp;
		rtm = mtod(m, struct rt_msghdr *);
		/* but RTM_DESYNC can't be filtered */
		if (rtm->rtm_type != RTM_DESYNC && rop->msgfilter != 0 &&
		    !(rop->msgfilter & (1 << rtm->rtm_type)))
			continue;
		switch (rtm->rtm_type) {
		case RTM_IFANNOUNCE:
		case RTM_DESYNC:
			/* no tableid */
			break;
		case RTM_RESOLVE:
		case RTM_NEWADDR:
		case RTM_DELADDR:
		case RTM_IFINFO:
			/* check against rdomain id */
			if (rop->rtableid != RTABLE_ANY &&
			    rtable_l2(rop->rtableid) != rtm->rtm_tableid)
				continue;
			break;
		default:
			/* check against rtable id */
			if (rop->rtableid != RTABLE_ANY &&
			    rop->rtableid != rtm->rtm_tableid)
				continue;
			break;
		}

		/*
		 * Check to see if the flush flag is set. If so, don't queue
		 * any more messages until the flag is cleared.
		 */
		if ((rop->flags & ROUTECB_FLAG_FLUSH) != 0)
			continue;

		if (last) {
			struct mbuf *n;
			if ((n = m_copym(m, 0, M_COPYALL, M_NOWAIT)) != NULL) {
				if (sbspace(&last->so_rcv) < (2 * MSIZE) ||
				    sbappendaddr(&last->so_rcv, sosrc,
				    n, (struct mbuf *)NULL) == 0) {
					/*
					 * Flag socket as desync'ed and
					 * flush required
					 */
					sotoroutecb(last)->flags |=
					    ROUTECB_FLAG_DESYNC |
					    ROUTECB_FLAG_FLUSH;
					route_senddesync(sotorawcb(last));
					m_freem(n);
				} else {
					sorwakeup(last);
					sockets++;
				}
			}
		}
		last = rp->rcb_socket;
	}
	if (last) {
		if (sbspace(&last->so_rcv) < (2 * MSIZE) ||
		    sbappendaddr(&last->so_rcv, sosrc,
		    m, (struct mbuf *)NULL) == 0) {
			/* Flag socket as desync'ed and flush required */
			sotoroutecb(last)->flags |=
			    ROUTECB_FLAG_DESYNC | ROUTECB_FLAG_FLUSH;
			route_senddesync(sotorawcb(last));
			m_freem(m);
		} else {
			sorwakeup(last);
			sockets++;
		}
	} else
		m_freem(m);
}

struct rt_msghdr *
rtm_report(struct rtentry *rt, u_char type, int seq, int tableid)
{
	struct rt_msghdr	*rtm;
	struct rt_addrinfo	 info;
	struct sockaddr_rtlabel	 sa_rl;
	struct sockaddr_in6	 sa_mask;
#ifdef BFD
	struct sockaddr_bfd	 sa_bfd;
#endif
#ifdef MPLS
	struct sockaddr_mpls	 sa_mpls;
#endif
	struct ifnet		*ifp = NULL;
	int			 len;

	bzero(&info, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	info.rti_info[RTAX_NETMASK] = rt_plen2mask(rt, &sa_mask);
	info.rti_info[RTAX_LABEL] = rtlabel_id2sa(rt->rt_labelid, &sa_rl);
#ifdef BFD
	if (rt->rt_flags & RTF_BFD)
		info.rti_info[RTAX_BFD] = bfd2sa(rt, &sa_bfd);
#endif
#ifdef MPLS
	if (rt->rt_flags & RTF_MPLS) {
		bzero(&sa_mpls, sizeof(sa_mpls));
		sa_mpls.smpls_family = AF_MPLS;
		sa_mpls.smpls_len = sizeof(sa_mpls);
		sa_mpls.smpls_label = ((struct rt_mpls *)
		    rt->rt_llinfo)->mpls_label;
		info.rti_info[RTAX_SRC] = (struct sockaddr *)&sa_mpls;
		info.rti_mpls = ((struct rt_mpls *)
		    rt->rt_llinfo)->mpls_operation;
	}
#endif
	ifp = if_get(rt->rt_ifidx);
	if (ifp != NULL) {
		info.rti_info[RTAX_IFP] = sdltosa(ifp->if_sadl);
		info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
		if (ifp->if_flags & IFF_POINTOPOINT)
			info.rti_info[RTAX_BRD] = rt->rt_ifa->ifa_dstaddr;
	}
	if_put(ifp);
	/* RTAX_GENMASK, RTAX_AUTHOR, RTAX_SRCMASK ignored */

	/* build new route message */
	len = rtm_msg2(type, RTM_VERSION, &info, NULL, NULL);
	rtm = malloc(len, M_RTABLE, M_WAITOK | M_ZERO);

	rtm_msg2(type, RTM_VERSION, &info, (caddr_t)rtm, NULL);
	rtm->rtm_type = type;
	rtm->rtm_index = rt->rt_ifidx;
	rtm->rtm_tableid = tableid;
	rtm->rtm_priority = rt->rt_priority & RTP_MASK;
	rtm->rtm_flags = rt->rt_flags;
	rtm->rtm_pid = curproc->p_p->ps_pid;
	rtm->rtm_seq = seq;
	rtm_getmetrics(&rt->rt_rmx, &rtm->rtm_rmx);
	rtm->rtm_addrs = info.rti_addrs;
#ifdef MPLS
	rtm->rtm_mpls = info.rti_mpls;
#endif
	return rtm;
}

int
route_output(struct mbuf *m, struct socket *so, struct sockaddr *dstaddr,
    struct mbuf *control)
{
	struct rt_msghdr	*rtm = NULL;
	struct rtentry		*rt = NULL;
	struct rt_addrinfo	 info;
	int			 len, seq, error = 0;
	u_int			 tableid;
	u_int8_t		 prio;
	u_char			 vers, type;

	if (m == NULL || ((m->m_len < sizeof(int32_t)) &&
	    (m = m_pullup(m, sizeof(int32_t))) == 0))
		return (ENOBUFS);
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("route_output");
	len = m->m_pkthdr.len;
	if (len < offsetof(struct rt_msghdr, rtm_type) + 1 ||
	    len != mtod(m, struct rt_msghdr *)->rtm_msglen) {
		error = EINVAL;
		goto fail;
	}
	vers = mtod(m, struct rt_msghdr *)->rtm_version;
	switch (vers) {
	case RTM_VERSION:
		if (len < sizeof(struct rt_msghdr)) {
			error = EINVAL;
			goto fail;
		}
		if (len > RTM_MAXSIZE) {
			error = EMSGSIZE;
			goto fail;
		}
		rtm = malloc(len, M_RTABLE, M_WAITOK);
		m_copydata(m, 0, len, (caddr_t)rtm);
		break;
	default:
		error = EPROTONOSUPPORT;
		goto fail;
	}
	rtm->rtm_pid = curproc->p_p->ps_pid;
	if (rtm->rtm_hdrlen == 0)	/* old client */
		rtm->rtm_hdrlen = sizeof(struct rt_msghdr);
	if (len < rtm->rtm_hdrlen) {
		error = EINVAL;
		goto fail;
	}

	/* Verify that the caller is sending an appropriate message early */
	switch (rtm->rtm_type) {
	case RTM_ADD:
	case RTM_DELETE:
	case RTM_GET:
	case RTM_CHANGE:
	case RTM_LOCK:
	case RTM_PROPOSAL:
		break;
	default:
		error = EOPNOTSUPP;
		goto fail;
	}

	/*
	 * Verify that the caller has the appropriate privilege; RTM_GET
	 * is the only operation the non-superuser is allowed.
	 */
	if (rtm->rtm_type != RTM_GET && suser(curproc, 0) != 0) {
		error = EACCES;
		goto fail;
	}
	tableid = rtm->rtm_tableid;
	if (!rtable_exists(tableid)) {
		if (rtm->rtm_type == RTM_ADD) {
			if ((error = rtable_add(tableid)) != 0)
				goto fail;
		} else {
			error = EINVAL;
			goto fail;
		}
	}


	/* Do not let userland play with kernel-only flags. */
	if ((rtm->rtm_flags & (RTF_LOCAL|RTF_BROADCAST)) != 0) {
		error = EINVAL;
		goto fail;
	}

	/* make sure that kernel-only bits are not set */
	rtm->rtm_priority &= RTP_MASK;
	rtm->rtm_flags &= ~(RTF_DONE|RTF_CLONED|RTF_CACHED);
	rtm->rtm_fmask &= RTF_FMASK;

	if (rtm->rtm_priority != 0) {
		if (rtm->rtm_priority > RTP_MAX ||
		    rtm->rtm_priority == RTP_LOCAL) {
			error = EINVAL;
			goto fail;
		}
		prio = rtm->rtm_priority;
	} else if (rtm->rtm_type != RTM_ADD)
		prio = RTP_ANY;
	else if (rtm->rtm_flags & RTF_STATIC)
		prio = 0;
	else
		prio = RTP_DEFAULT;

	bzero(&info, sizeof(info));
	info.rti_addrs = rtm->rtm_addrs;
	rtm_xaddrs(rtm->rtm_hdrlen + (caddr_t)rtm, len + (caddr_t)rtm, &info);
	info.rti_flags = rtm->rtm_flags;
	if (rtm->rtm_type != RTM_PROPOSAL &&
	   (info.rti_info[RTAX_DST] == NULL ||
	    info.rti_info[RTAX_DST]->sa_family >= AF_MAX ||
	    (info.rti_info[RTAX_GATEWAY] != NULL &&
	    info.rti_info[RTAX_GATEWAY]->sa_family >= AF_MAX) ||
	    info.rti_info[RTAX_GENMASK] != NULL)) {
		error = EINVAL;
		goto fail;
	}
#ifdef MPLS
	info.rti_mpls = rtm->rtm_mpls;
#endif

	if (info.rti_info[RTAX_GATEWAY] != NULL &&
	    info.rti_info[RTAX_GATEWAY]->sa_family == AF_LINK &&
	    (info.rti_flags & RTF_CLONING) == 0) {
		info.rti_flags |= RTF_LLINFO;
	}

	/*
	 * Do not use goto flush before this point since the message itself
	 * may be not consistent and could cause unexpected behaviour in other
	 * userland clients. Use goto fail instead.
	 */

	/*
	 * Validate RTM_PROPOSAL and pass it along or error out.
	 */
	if (rtm->rtm_type == RTM_PROPOSAL) {
	       if (rtm_validate_proposal(&info) == -1) {
			error = EINVAL;
			goto fail;
	       }
	} else {
		error = rtm_output(rtm, &rt, &info, prio, tableid);
		if (!error) {
			type = rtm->rtm_type;
			seq = rtm->rtm_seq;
			free(rtm, M_RTABLE, 0);
			rtm = rtm_report(rt, type, seq, tableid);
		}
	}

	rtfree(rt);
	if (error) {
		rtm->rtm_errno = error;
	} else {
		rtm->rtm_flags |= RTF_DONE;
	}

	/*
	 * Check to see if we don't want our own messages.
	 */
	if (!(so->so_options & SO_USELOOPBACK)) {
		if (route_cb.any_count <= 1) {
			/* no other listener and no loopback of messages */
fail:
			free(rtm, M_RTABLE, 0);
			m_freem(m);
			return (error);
		}
	}
	if (rtm) {
		if (m_copyback(m, 0, rtm->rtm_msglen, rtm, M_NOWAIT)) {
			m_freem(m);
			m = NULL;
		} else if (m->m_pkthdr.len > rtm->rtm_msglen)
			m_adj(m, rtm->rtm_msglen - m->m_pkthdr.len);
		free(rtm, M_RTABLE, 0);
	}
	if (m)
		route_input(m, so, info.rti_info[RTAX_DST] ?
		    info.rti_info[RTAX_DST]->sa_family : AF_UNSPEC);

	return (error);
}

int
rtm_output(struct rt_msghdr *rtm, struct rtentry **prt,
    struct rt_addrinfo *info, uint8_t prio, unsigned int tableid)
{
	struct rtentry		*rt = *prt;
	struct ifnet		*ifp = NULL;
	struct ifaddr		*ifa = NULL;
#ifdef MPLS
	struct sockaddr_mpls	*psa_mpls;
#endif
	int			 plen, newgate = 0, error = 0;
	int			 s;

	NET_LOCK(s);
	switch (rtm->rtm_type) {
	case RTM_ADD:
		if (info->rti_info[RTAX_GATEWAY] == NULL) {
			error = EINVAL;
			break;
		}

		rt = rtable_match(tableid, info->rti_info[RTAX_DST], NULL);
		if ((error = route_arp_conflict(rt, info))) {
			rtfree(rt);
			rt = NULL;
			break;
		}

		/*
		 * We cannot go through a delete/create/insert cycle for
		 * cached route because this can lead to races in the
		 * receive path.  Instead we upade the L2 cache.
		 */
		if ((rt != NULL) && ISSET(rt->rt_flags, RTF_CACHED))
			goto change;

		rtfree(rt);
		rt = NULL;

		error = rtrequest(RTM_ADD, info, prio, &rt, tableid);
		if (error == 0)
			rtm_setmetrics(rtm->rtm_inits, &rtm->rtm_rmx,
			    &rt->rt_rmx);
		break;
	case RTM_DELETE:
		rt = rtable_lookup(tableid, info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_NETMASK], info->rti_info[RTAX_GATEWAY],
		    prio);
		if (rt == NULL) {
			error = ESRCH;
			break;
		}

		/* Detaching an interface requires the KERNEL_LOCK(). */
		ifp = if_get(rt->rt_ifidx);
		KASSERT(ifp != NULL);

		/*
		 * Invalidate the cache of automagically created and
		 * referenced L2 entries to make sure that ``rt_gwroute''
		 * pointer stays valid for other CPUs.
		 */
		if ((ISSET(rt->rt_flags, RTF_CACHED))) {
			ifp->if_rtrequest(ifp, RTM_INVALIDATE, rt);
			/* Reset the MTU of the gateway route. */
			rtable_walk(tableid, rt_key(rt)->sa_family,
			    route_cleargateway, rt);
			if_put(ifp);
			break;
		}

		/*
		 * Make sure that local routes are only modified by the
		 * kernel.
		 */
		if (ISSET(rt->rt_flags, RTF_LOCAL|RTF_BROADCAST)) {
			if_put(ifp);
			error = EINVAL;
			break;
		}

		rtfree(rt);
		rt = NULL;

		error = rtrequest_delete(info, prio, ifp, &rt, tableid);
		if_put(ifp);
		break;
	case RTM_CHANGE:
	case RTM_LOCK:
		rt = rtable_lookup(tableid, info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_NETMASK], info->rti_info[RTAX_GATEWAY],
		    prio);
#ifndef SMALL_KERNEL
		/*
		 * If we got multipath routes, we require users to specify
		 * a matching gateway.
		 */
		if ((rt != NULL) && ISSET(rt->rt_flags, RTF_MPATH) &&
		    (info->rti_info[RTAX_GATEWAY] == NULL)) {
			rtfree(rt);
			rt = NULL;
		}
#endif
		/*
		 * If RTAX_GATEWAY is the argument we're trying to
		 * change, try to find a compatible route.
		 */
		if ((rt == NULL) && (info->rti_info[RTAX_GATEWAY] != NULL) &&
		    (rtm->rtm_type == RTM_CHANGE)) {
			rt = rtable_lookup(tableid, info->rti_info[RTAX_DST],
			    info->rti_info[RTAX_NETMASK], NULL, prio);
#ifndef SMALL_KERNEL
			/* Ensure we don't pick a multipath one. */
			if ((rt != NULL) && ISSET(rt->rt_flags, RTF_MPATH)) {
				rtfree(rt);
				rt = NULL;
			}
#endif
		}

		if (rt == NULL) {
			error = ESRCH;
			break;
		}

		/*
		 * RTM_CHANGE/LOCK need a perfect match.
		 */
		plen = rtable_satoplen(info->rti_info[RTAX_DST]->sa_family,
		    info->rti_info[RTAX_NETMASK]);
		if (rt_plen(rt) != plen ) {
			error = ESRCH;
			break;
		}

		switch (rtm->rtm_type) {
		case RTM_CHANGE:
			if (info->rti_info[RTAX_GATEWAY] != NULL)
				if (rt->rt_gateway == NULL ||
				    bcmp(rt->rt_gateway,
				    info->rti_info[RTAX_GATEWAY],
				    info->rti_info[RTAX_GATEWAY]->sa_len)) {
					newgate = 1;
				}
			/*
			 * Check reachable gateway before changing the route.
			 * New gateway could require new ifaddr, ifp;
			 * flags may also be different; ifp may be specified
			 * by ll sockaddr when protocol address is ambiguous.
			 */
			if (newgate || info->rti_info[RTAX_IFP] != NULL ||
			    info->rti_info[RTAX_IFA] != NULL) {
				if ((error = rt_getifa(info, tableid)) != 0)
					break;
				ifa = info->rti_ifa;
				if (rt->rt_ifa != ifa) {
					ifp = if_get(rt->rt_ifidx);
					KASSERT(ifp != NULL);
					ifp->if_rtrequest(ifp, RTM_DELETE, rt);
					ifafree(rt->rt_ifa);
					if_put(ifp);

					ifa->ifa_refcnt++;
					rt->rt_ifa = ifa;
					rt->rt_ifidx = ifa->ifa_ifp->if_index;
#ifndef SMALL_KERNEL
					/* recheck link state after ifp change*/
					rt_if_linkstate_change(rt, ifa->ifa_ifp,
					    tableid);
#endif
				}
			}
change:
			if (info->rti_info[RTAX_GATEWAY] != NULL) {
				/*
				 * When updating the gateway, make sure it's
				 * valid.
				 */
				if (!newgate && rt->rt_gateway->sa_family !=
				    info->rti_info[RTAX_GATEWAY]->sa_family) {
				    	error = EINVAL;
					break;
				}

				error = rt_setgate(rt,
				    info->rti_info[RTAX_GATEWAY], tableid);
				if (error)
					break;
			}
#ifdef MPLS
			if ((rtm->rtm_flags & RTF_MPLS) &&
			    info->rti_info[RTAX_SRC] != NULL) {
				struct rt_mpls *rt_mpls;

				psa_mpls = (struct sockaddr_mpls *)
				    info->rti_info[RTAX_SRC];

				if (rt->rt_llinfo == NULL) {
					rt->rt_llinfo =
					    malloc(sizeof(struct rt_mpls),
					    M_TEMP, M_WAITOK | M_ZERO);
				}

				rt_mpls = (struct rt_mpls *)rt->rt_llinfo;

				if (psa_mpls != NULL) {
					rt_mpls->mpls_label =
					    psa_mpls->smpls_label;
				}

				rt_mpls->mpls_operation = info->rti_mpls;

				/* XXX: set experimental bits */

				rt->rt_flags |= RTF_MPLS;
			} else if (newgate || ((rtm->rtm_fmask & RTF_MPLS) &&
			    !(rtm->rtm_flags & RTF_MPLS))) {
				/* if gateway changed remove MPLS information */
				if (rt->rt_llinfo != NULL &&
				    rt->rt_flags & RTF_MPLS) {
					free(rt->rt_llinfo, M_TEMP, 0);
					rt->rt_llinfo = NULL;
					rt->rt_flags &= ~RTF_MPLS;
				}
			}
#endif

#ifdef BFD
			if (ISSET(rtm->rtm_flags, RTF_BFD)) {
				if ((error = bfdset(rt)))
					break;
			} else if (!ISSET(rtm->rtm_flags, RTF_BFD) &&
			    ISSET(rtm->rtm_fmask, RTF_BFD)) {
				bfdclear(rt);
			}
#endif

			/* Hack to allow some flags to be toggled */
			if (rtm->rtm_fmask)
				rt->rt_flags =
				    (rt->rt_flags & ~rtm->rtm_fmask) |
				    (rtm->rtm_flags & rtm->rtm_fmask);

			rtm_setmetrics(rtm->rtm_inits, &rtm->rtm_rmx,
			    &rt->rt_rmx);

			ifp = if_get(rt->rt_ifidx);
			KASSERT(ifp != NULL);
			ifp->if_rtrequest(ifp, RTM_ADD, rt);
			if_put(ifp);

			if (info->rti_info[RTAX_LABEL] != NULL) {
				char *rtlabel = ((struct sockaddr_rtlabel *)
				    info->rti_info[RTAX_LABEL])->sr_label;
				rtlabel_unref(rt->rt_labelid);
				rt->rt_labelid = rtlabel_name2id(rtlabel);
			}
			if_group_routechange(info->rti_info[RTAX_DST],
			    info->rti_info[RTAX_NETMASK]);
			/* FALLTHROUGH */
		case RTM_LOCK:
			rt->rt_locks &= ~(rtm->rtm_inits);
			rt->rt_locks |=
			    (rtm->rtm_inits & rtm->rtm_rmx.rmx_locks);
			break;
		}
		break;
	case RTM_GET:
		rt = rtable_lookup(tableid, info->rti_info[RTAX_DST],
		    info->rti_info[RTAX_NETMASK], info->rti_info[RTAX_GATEWAY],
		    prio);
		if (rt == NULL)
			error = ESRCH;
		break;
	}
	NET_UNLOCK(s);

	*prt = rt;
	return (error);
}

int
route_cleargateway(struct rtentry *rt, void *arg, unsigned int rtableid)
{
	struct rtentry *nhrt = arg;

	if (ISSET(rt->rt_flags, RTF_GATEWAY) && rt->rt_gwroute == nhrt &&
	    !ISSET(rt->rt_locks, RTV_MTU))
                rt->rt_mtu = 0;

	return (0);
}

/*
 * Check if the user request to insert an ARP entry does not conflict
 * with existing ones.
 *
 * Only two entries are allowed for a given IP address: a private one
 * (priv) and a public one (pub).
 */
int
route_arp_conflict(struct rtentry *rt, struct rt_addrinfo *info)
{
#ifdef ART
	int		 proxy = (info->rti_flags & RTF_ANNOUNCE);

	if ((info->rti_flags & RTF_LLINFO) == 0 ||
	    (info->rti_info[RTAX_DST]->sa_family != AF_INET))
		return (0);

	if (rt == NULL || !ISSET(rt->rt_flags, RTF_LLINFO))
		return (0);

	/* If the entry is cached, it can be updated. */
	if (ISSET(rt->rt_flags, RTF_CACHED))
		return (0);

	/*
	 * Same destination, not cached and both "priv" or "pub" conflict.
	 * If a second entry exists, it always conflict.
	 */
	if ((ISSET(rt->rt_flags, RTF_ANNOUNCE) == proxy) ||
	    ISSET(rt->rt_flags, RTF_MPATH))
		return (EEXIST);

	/* No conflict but an entry exist so we need to force mpath. */
	info->rti_flags |= RTF_MPATH;
#endif /* ART */
	return (0);
}

void
rtm_setmetrics(u_long which, const struct rt_metrics *in,
    struct rt_kmetrics *out)
{
	int64_t expire;

	if (which & RTV_MTU)
		out->rmx_mtu = in->rmx_mtu;
	if (which & RTV_EXPIRE) {
		expire = in->rmx_expire;
		if (expire != 0) {
			expire -= time_second;
			expire += time_uptime;
		}

		out->rmx_expire = expire;
	}
}

void
rtm_getmetrics(const struct rt_kmetrics *in, struct rt_metrics *out)
{
	int64_t expire;

	expire = in->rmx_expire;
	if (expire != 0) {
		expire -= time_uptime;
		expire += time_second;
	}

	bzero(out, sizeof(*out));
	out->rmx_locks = in->rmx_locks;
	out->rmx_mtu = in->rmx_mtu;
	out->rmx_expire = expire;
	out->rmx_pksent = in->rmx_pksent;
}

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))

void
rtm_xaddrs(caddr_t cp, caddr_t cplim, struct rt_addrinfo *rtinfo)
{
	struct sockaddr	*sa;
	int		 i;

	bzero(rtinfo->rti_info, sizeof(rtinfo->rti_info));
	for (i = 0; (i < RTAX_MAX) && (cp < cplim); i++) {
		if ((rtinfo->rti_addrs & (1 << i)) == 0)
			continue;
		rtinfo->rti_info[i] = sa = (struct sockaddr *)cp;
		ADVANCE(cp, sa);
	}
}

struct mbuf *
rtm_msg1(int type, struct rt_addrinfo *rtinfo)
{
	struct rt_msghdr	*rtm;
	struct mbuf		*m;
	int			 i;
	struct sockaddr		*sa;
	int			 len, dlen, hlen;

	switch (type) {
	case RTM_DELADDR:
	case RTM_NEWADDR:
		len = sizeof(struct ifa_msghdr);
		break;
	case RTM_IFINFO:
		len = sizeof(struct if_msghdr);
		break;
	case RTM_IFANNOUNCE:
		len = sizeof(struct if_announcemsghdr);
		break;
#ifdef BFD
	case RTM_BFD:
		len = sizeof(struct bfd_msghdr);
		break;
#endif
	default:
		len = sizeof(struct rt_msghdr);
		break;
	}
	if (len > MCLBYTES)
		panic("rtm_msg1");
	m = m_gethdr(M_DONTWAIT, MT_DATA);
	if (m && len > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			m = NULL;
		}
	}
	if (m == NULL)
		return (m);
	m->m_pkthdr.len = m->m_len = hlen = len;
	m->m_pkthdr.ph_ifidx = 0;
	rtm = mtod(m, struct rt_msghdr *);
	bzero(rtm, len);
	for (i = 0; i < RTAX_MAX; i++) {
		if (rtinfo == NULL || (sa = rtinfo->rti_info[i]) == NULL)
			continue;
		rtinfo->rti_addrs |= (1 << i);
		dlen = ROUNDUP(sa->sa_len);
		if (m_copyback(m, len, dlen, sa, M_NOWAIT)) {
			m_freem(m);
			return (NULL);
		}
		len += dlen;
	}
	rtm->rtm_msglen = len;
	rtm->rtm_hdrlen = hlen;
	rtm->rtm_version = RTM_VERSION;
	rtm->rtm_type = type;
	return (m);
}

int
rtm_msg2(int type, int vers, struct rt_addrinfo *rtinfo, caddr_t cp,
    struct walkarg *w)
{
	int		i;
	int		len, dlen, hlen, second_time = 0;
	caddr_t		cp0;

	rtinfo->rti_addrs = 0;
again:
	switch (type) {
	case RTM_DELADDR:
	case RTM_NEWADDR:
		len = sizeof(struct ifa_msghdr);
		break;
	case RTM_IFINFO:
		len = sizeof(struct if_msghdr);
		break;
	default:
		len = sizeof(struct rt_msghdr);
		break;
	}
	hlen = len;
	if ((cp0 = cp) != NULL)
		cp += len;
	for (i = 0; i < RTAX_MAX; i++) {
		struct sockaddr *sa;

		if ((sa = rtinfo->rti_info[i]) == NULL)
			continue;
		rtinfo->rti_addrs |= (1 << i);
		dlen = ROUNDUP(sa->sa_len);
		if (cp) {
			bcopy(sa, cp, (size_t)dlen);
			cp += dlen;
		}
		len += dlen;
	}
	/* align message length to the next natural boundary */
	len = ALIGN(len);
	if (cp == 0 && w != NULL && !second_time) {
		struct walkarg *rw = w;

		rw->w_needed += len;
		if (rw->w_needed <= 0 && rw->w_where) {
			if (rw->w_tmemsize < len) {
				free(rw->w_tmem, M_RTABLE, 0);
				rw->w_tmem = malloc(len, M_RTABLE, M_NOWAIT);
				if (rw->w_tmem)
					rw->w_tmemsize = len;
			}
			if (rw->w_tmem) {
				cp = rw->w_tmem;
				second_time = 1;
				goto again;
			} else
				rw->w_where = 0;
		}
	}
	if (cp && w)		/* clear the message header */
		bzero(cp0, hlen);

	if (cp) {
		struct rt_msghdr *rtm = (struct rt_msghdr *)cp0;

		rtm->rtm_version = RTM_VERSION;
		rtm->rtm_type = type;
		rtm->rtm_msglen = len;
		rtm->rtm_hdrlen = hlen;
	}
	return (len);
}

void
rtm_send(struct rtentry *rt, int cmd, u_int rtableid)
{
	struct rt_addrinfo	 info;
	struct ifnet		*ifp;
	struct sockaddr_rtlabel	 sa_rl;
	struct sockaddr_in6	 sa_mask;

	memset(&info, 0, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	if (!ISSET(rt->rt_flags, RTF_HOST))
		info.rti_info[RTAX_NETMASK] = rt_plen2mask(rt, &sa_mask);
	info.rti_info[RTAX_LABEL] = rtlabel_id2sa(rt->rt_labelid, &sa_rl);
	ifp = if_get(rt->rt_ifidx);
	if (ifp != NULL) {
		info.rti_info[RTAX_IFP] = sdltosa(ifp->if_sadl);
		info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
	}

	rtm_miss(cmd, &info, rt->rt_flags, rt->rt_priority, rt->rt_ifidx, 0,
	    rtableid);
	if_put(ifp);
}

/*
 * This routine is called to generate a message from the routing
 * socket indicating that a redirect has occurred, a routing lookup
 * has failed, or that a protocol has detected timeouts to a particular
 * destination.
 */
void
rtm_miss(int type, struct rt_addrinfo *rtinfo, int flags, uint8_t prio,
    u_int ifidx, int error, u_int tableid)
{
	struct rt_msghdr	*rtm;
	struct mbuf		*m;
	struct sockaddr		*sa = rtinfo->rti_info[RTAX_DST];

	if (route_cb.any_count == 0)
		return;
	m = rtm_msg1(type, rtinfo);
	if (m == NULL)
		return;
	rtm = mtod(m, struct rt_msghdr *);
	rtm->rtm_flags = RTF_DONE | flags;
	rtm->rtm_priority = prio;
	rtm->rtm_errno = error;
	rtm->rtm_tableid = tableid;
	rtm->rtm_addrs = rtinfo->rti_addrs;
	rtm->rtm_index = ifidx;
	route_input(m, NULL, sa ? sa->sa_family : AF_UNSPEC);
}

/*
 * This routine is called to generate a message from the routing
 * socket indicating that the status of a network interface has changed.
 */
void
rtm_ifchg(struct ifnet *ifp)
{
	struct if_msghdr	*ifm;
	struct mbuf		*m;

	if (route_cb.any_count == 0)
		return;
	m = rtm_msg1(RTM_IFINFO, NULL);
	if (m == NULL)
		return;
	ifm = mtod(m, struct if_msghdr *);
	ifm->ifm_index = ifp->if_index;
	ifm->ifm_tableid = ifp->if_rdomain;
	ifm->ifm_flags = ifp->if_flags;
	ifm->ifm_xflags = ifp->if_xflags;
	if_getdata(ifp, &ifm->ifm_data);
	ifm->ifm_addrs = 0;
	route_input(m, NULL, AF_UNSPEC);
}

/*
 * This is called to generate messages from the routing socket
 * indicating a network interface has had addresses associated with it.
 * if we ever reverse the logic and replace messages TO the routing
 * socket indicate a request to configure interfaces, then it will
 * be unnecessary as the routing socket will automatically generate
 * copies of it.
 */
void
rtm_addr(struct rtentry *rt, int cmd, struct ifaddr *ifa)
{
	struct ifnet		*ifp = ifa->ifa_ifp;
	struct mbuf		*m = NULL;
	struct rt_addrinfo	 info;
	struct ifa_msghdr	*ifam;

	if (route_cb.any_count == 0)
		return;

	memset(&info, 0, sizeof(info));
	info.rti_info[RTAX_IFA] = ifa->ifa_addr;
	info.rti_info[RTAX_IFP] = sdltosa(ifp->if_sadl);
	info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;
	info.rti_info[RTAX_BRD] = ifa->ifa_dstaddr;
	if ((m = rtm_msg1(cmd, &info)) == NULL)
		return;
	ifam = mtod(m, struct ifa_msghdr *);
	ifam->ifam_index = ifp->if_index;
	ifam->ifam_metric = ifa->ifa_metric;
	ifam->ifam_flags = ifa->ifa_flags;
	ifam->ifam_addrs = info.rti_addrs;
	ifam->ifam_tableid = ifp->if_rdomain;

	route_input(m, NULL,
	    ifa->ifa_addr ? ifa->ifa_addr->sa_family : AF_UNSPEC);
}

/*
 * This is called to generate routing socket messages indicating
 * network interface arrival and departure.
 */
void
rtm_ifannounce(struct ifnet *ifp, int what)
{
	struct if_announcemsghdr	*ifan;
	struct mbuf			*m;

	if (route_cb.any_count == 0)
		return;
	m = rtm_msg1(RTM_IFANNOUNCE, NULL);
	if (m == NULL)
		return;
	ifan = mtod(m, struct if_announcemsghdr *);
	ifan->ifan_index = ifp->if_index;
	strlcpy(ifan->ifan_name, ifp->if_xname, sizeof(ifan->ifan_name));
	ifan->ifan_what = what;
	route_input(m, NULL, AF_UNSPEC);
}

#ifdef BFD
/*
 * This is used to generate routing socket messages indicating
 * the state of a BFD session.
 */
void
rtm_bfd(struct bfd_config *bfd)
{
	struct bfd_msghdr	*bfdm;
	struct sockaddr_bfd	 sa_bfd;
	struct mbuf		*m;
	struct rt_addrinfo	 info;

	if (route_cb.any_count == 0)
		return;
	memset(&info, 0, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(bfd->bc_rt);
	info.rti_info[RTAX_IFA] = bfd->bc_rt->rt_ifa->ifa_addr;

	m = rtm_msg1(RTM_BFD, &info);
	if (m == NULL)
		return;
	bfdm = mtod(m, struct bfd_msghdr *);
	bfdm->bm_addrs = info.rti_addrs;

	bfd2sa(bfd->bc_rt, &sa_bfd);
	memcpy(&bfdm->bm_sa, &sa_bfd, sizeof(sa_bfd));

	route_input(m, NULL, info.rti_info[RTAX_DST]->sa_family);
}
#endif /* BFD */

/*
 * This is used in dumping the kernel table via sysctl().
 */
int
sysctl_dumpentry(struct rtentry *rt, void *v, unsigned int id)
{
	struct walkarg		*w = v;
	int			 error = 0, size;
	struct rt_addrinfo	 info;
	struct ifnet		*ifp;
#ifdef BFD
	struct sockaddr_bfd	 sa_bfd;
#endif
#ifdef MPLS
	struct sockaddr_mpls	 sa_mpls;
#endif
	struct sockaddr_rtlabel	 sa_rl;
	struct sockaddr_in6	 sa_mask;

	if (w->w_op == NET_RT_FLAGS && !(rt->rt_flags & w->w_arg))
		return 0;
	if (w->w_op == NET_RT_DUMP && w->w_arg) {
		u_int8_t prio = w->w_arg & RTP_MASK;
		if (w->w_arg < 0) {
			prio = (-w->w_arg) & RTP_MASK;
			/* Show all routes that are not this priority */
			if (prio == (rt->rt_priority & RTP_MASK))
				return 0;
		} else {
			if (prio != (rt->rt_priority & RTP_MASK) &&
			    prio != RTP_ANY)
				return 0;
		}
	}
	bzero(&info, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	info.rti_info[RTAX_NETMASK] = rt_plen2mask(rt, &sa_mask);
	ifp = if_get(rt->rt_ifidx);
	if (ifp != NULL) {
		info.rti_info[RTAX_IFP] = sdltosa(ifp->if_sadl);
		info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
		if (ifp->if_flags & IFF_POINTOPOINT)
			info.rti_info[RTAX_BRD] = rt->rt_ifa->ifa_dstaddr;
	}
	if_put(ifp);
	info.rti_info[RTAX_LABEL] = rtlabel_id2sa(rt->rt_labelid, &sa_rl);
#ifdef BFD
	if (rt->rt_flags & RTF_BFD)
		info.rti_info[RTAX_BFD] = bfd2sa(rt, &sa_bfd);
#endif
#ifdef MPLS
	if (rt->rt_flags & RTF_MPLS) {
		bzero(&sa_mpls, sizeof(sa_mpls));
		sa_mpls.smpls_family = AF_MPLS;
		sa_mpls.smpls_len = sizeof(sa_mpls);
		sa_mpls.smpls_label = ((struct rt_mpls *)
		    rt->rt_llinfo)->mpls_label;
		info.rti_info[RTAX_SRC] = (struct sockaddr *)&sa_mpls;
		info.rti_mpls = ((struct rt_mpls *)
		    rt->rt_llinfo)->mpls_operation;
	}
#endif

	size = rtm_msg2(RTM_GET, RTM_VERSION, &info, NULL, w);
	if (w->w_where && w->w_tmem && w->w_needed <= 0) {
		struct rt_msghdr *rtm = (struct rt_msghdr *)w->w_tmem;

		rtm->rtm_pid = curproc->p_p->ps_pid;
		rtm->rtm_flags = rt->rt_flags;
		rtm->rtm_priority = rt->rt_priority & RTP_MASK;
		rtm_getmetrics(&rt->rt_rmx, &rtm->rtm_rmx);
		/* Do not account the routing table's reference. */
		rtm->rtm_rmx.rmx_refcnt = rt->rt_refcnt - 1;
		rtm->rtm_index = rt->rt_ifidx;
		rtm->rtm_addrs = info.rti_addrs;
		rtm->rtm_tableid = id;
#ifdef MPLS
		rtm->rtm_mpls = info.rti_mpls;
#endif
		if ((error = copyout(rtm, w->w_where, size)) != 0)
			w->w_where = NULL;
		else
			w->w_where += size;
	}
	return (error);
}

int
sysctl_iflist(int af, struct walkarg *w)
{
	struct ifnet		*ifp;
	struct ifaddr		*ifa;
	struct rt_addrinfo	 info;
	int			 len, error = 0;

	bzero(&info, sizeof(info));
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (w->w_arg && w->w_arg != ifp->if_index)
			continue;
		/* Copy the link-layer address first */
		info.rti_info[RTAX_IFP] = sdltosa(ifp->if_sadl);
		len = rtm_msg2(RTM_IFINFO, RTM_VERSION, &info, 0, w);
		if (w->w_where && w->w_tmem && w->w_needed <= 0) {
			struct if_msghdr *ifm;

			ifm = (struct if_msghdr *)w->w_tmem;
			ifm->ifm_index = ifp->if_index;
			ifm->ifm_tableid = ifp->if_rdomain;
			ifm->ifm_flags = ifp->if_flags;
			if_getdata(ifp, &ifm->ifm_data);
			ifm->ifm_addrs = info.rti_addrs;
			error = copyout(ifm, w->w_where, len);
			if (error)
				return (error);
			w->w_where += len;
		}
		info.rti_info[RTAX_IFP] = NULL;
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			KASSERT(ifa->ifa_addr->sa_family != AF_LINK);
			if (af && af != ifa->ifa_addr->sa_family)
				continue;
			info.rti_info[RTAX_IFA] = ifa->ifa_addr;
			info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;
			info.rti_info[RTAX_BRD] = ifa->ifa_dstaddr;
			len = rtm_msg2(RTM_NEWADDR, RTM_VERSION, &info, 0, w);
			if (w->w_where && w->w_tmem && w->w_needed <= 0) {
				struct ifa_msghdr *ifam;

				ifam = (struct ifa_msghdr *)w->w_tmem;
				ifam->ifam_index = ifa->ifa_ifp->if_index;
				ifam->ifam_flags = ifa->ifa_flags;
				ifam->ifam_metric = ifa->ifa_metric;
				ifam->ifam_addrs = info.rti_addrs;
				error = copyout(w->w_tmem, w->w_where, len);
				if (error)
					return (error);
				w->w_where += len;
			}
		}
		info.rti_info[RTAX_IFA] = info.rti_info[RTAX_NETMASK] =
		    info.rti_info[RTAX_BRD] = NULL;
	}
	return (0);
}

int
sysctl_ifnames(struct walkarg *w)
{
	struct if_nameindex_msg ifn;
	struct ifnet *ifp;
	int error = 0;

	/* XXX ignore tableid for now */
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (w->w_arg && w->w_arg != ifp->if_index)
			continue;
		w->w_needed += sizeof(ifn);
		if (w->w_where && w->w_needed <= 0) {

			memset(&ifn, 0, sizeof(ifn));
			ifn.if_index = ifp->if_index;
			strlcpy(ifn.if_name, ifp->if_xname,
			    sizeof(ifn.if_name));
			error = copyout(&ifn, w->w_where, sizeof(ifn));
			if (error)
				return (error);
			w->w_where += sizeof(ifn);
		}
	}

	return (0);
}

int
sysctl_rtable(int *name, u_int namelen, void *where, size_t *given, void *new,
    size_t newlen)
{
	int			 i, error = EINVAL;
	u_char			 af;
	struct walkarg		 w;
	struct rt_tableinfo	 tableinfo;
	u_int			 tableid = 0;

	NET_ASSERT_LOCKED();

	if (new)
		return (EPERM);
	if (namelen < 3 || namelen > 4)
		return (EINVAL);
	af = name[0];
	bzero(&w, sizeof(w));
	w.w_where = where;
	w.w_given = *given;
	w.w_needed = 0 - w.w_given;
	w.w_op = name[1];
	w.w_arg = name[2];

	if (namelen == 4) {
		tableid = name[3];
		if (!rtable_exists(tableid))
			return (ENOENT);
	} else
		tableid = curproc->p_p->ps_rtableid;

	switch (w.w_op) {
	case NET_RT_DUMP:
	case NET_RT_FLAGS:
		for (i = 1; i <= AF_MAX; i++) {
			if (af != 0 && af != i)
				continue;

			error = rtable_walk(tableid, i, sysctl_dumpentry, &w);
			if (error == EAFNOSUPPORT)
				error = 0;
			if (error)
				break;
		}
		break;

	case NET_RT_IFLIST:
		error = sysctl_iflist(af, &w);
		break;

	case NET_RT_STATS:
		return (sysctl_rtable_rtstat(where, given, new));
	case NET_RT_TABLE:
		tableid = w.w_arg;
		if (!rtable_exists(tableid))
			return (ENOENT);
		memset(&tableinfo, 0, sizeof tableinfo);
		tableinfo.rti_tableid = tableid;
		tableinfo.rti_domainid = rtable_l2(tableid);
		error = sysctl_rdstruct(where, given, new,
		    &tableinfo, sizeof(tableinfo));
		return (error);
	case NET_RT_IFNAMES:
		error = sysctl_ifnames(&w);
		break;
	}
	free(w.w_tmem, M_RTABLE, 0);
	w.w_needed += w.w_given;
	if (where) {
		*given = w.w_where - (caddr_t)where;
		if (*given < w.w_needed)
			return (ENOMEM);
	} else
		*given = (11 * w.w_needed) / 10;

	return (error);
}

int
sysctl_rtable_rtstat(void *oldp, size_t *oldlenp, void *newp)
{
	extern struct cpumem *rtcounters;
	uint64_t counters[rts_ncounters];
	struct rtstat rtstat;
	uint32_t *words = (uint32_t *)&rtstat;
	int i;

	CTASSERT(sizeof(rtstat) == (nitems(counters) * sizeof(uint32_t)));
	memset(&rtstat, 0, sizeof rtstat);
	counters_read(rtcounters, counters, nitems(counters));

	for (i = 0; i < nitems(counters); i++)
		words[i] = (uint32_t)counters[i];

	return (sysctl_rdstruct(oldp, oldlenp, newp, &rtstat, sizeof(rtstat)));
}

int
rtm_validate_proposal(struct rt_addrinfo *info)
{
	if (info->rti_addrs & ~(RTA_NETMASK | RTA_IFA | RTA_DNS | RTA_STATIC |
	    RTA_SEARCH)) {
		return -1;
	}

	if (ISSET(info->rti_addrs, RTA_NETMASK)) {
		struct sockaddr *sa = info->rti_info[RTAX_NETMASK];
		if (sa == NULL)
			return -1;
		switch (sa->sa_family) {
		case AF_INET:
			if (sa->sa_len != sizeof(struct sockaddr_in))
				return -1;
			break;
		case AF_INET6:
			if (sa->sa_len != sizeof(struct sockaddr_in6))
				return -1;
			break;
		default:
			return -1;
		}
	}

	if (ISSET(info->rti_addrs, RTA_IFA)) {
		struct sockaddr *sa = info->rti_info[RTAX_IFA];
		if (sa == NULL)
			return -1;
		switch (sa->sa_family) {
		case AF_INET:
			if (sa->sa_len != sizeof(struct sockaddr_in))
				return -1;
			break;
		case AF_INET6:
			if (sa->sa_len != sizeof(struct sockaddr_in6))
				return -1;
			break;
		default:
			return -1;
		}
	}

	if (ISSET(info->rti_addrs, RTA_DNS)) {
		struct sockaddr_rtdns *rtdns =
		    (struct sockaddr_rtdns *)info->rti_info[RTAX_DNS];
		if (rtdns == NULL)
			return -1;
		if (rtdns->sr_len > sizeof(*rtdns))
			return -1;
		if (rtdns->sr_len <=
		    offsetof(struct sockaddr_rtdns, sr_dns))
			return -1;
	}

	if (ISSET(info->rti_addrs, RTA_STATIC)) {
		struct sockaddr_rtstatic *rtstatic =
		    (struct sockaddr_rtstatic *)info->rti_info[RTAX_STATIC];
		if (rtstatic == NULL)
			return -1;
		if (rtstatic->sr_len > sizeof(*rtstatic))
			return -1;
		if (rtstatic->sr_len <=
		    offsetof(struct sockaddr_rtstatic, sr_static))
			return -1;
	}

	if (ISSET(info->rti_addrs, RTA_SEARCH)) {
		struct sockaddr_rtsearch *rtsearch =
		    (struct sockaddr_rtsearch *)info->rti_info[RTAX_SEARCH];
		if (rtsearch == NULL)
			return -1;
		if (rtsearch->sr_len > sizeof(*rtsearch))
			return -1;
		if (rtsearch->sr_len <=
		    offsetof(struct sockaddr_rtsearch, sr_search))
			return -1;
	}

	return 0;
}

/*
 * Definitions of protocols supported in the ROUTE domain.
 */

extern	struct domain routedomain;		/* or at least forward */

struct protosw routesw[] = {
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &routedomain,
  .pr_flags	= PR_ATOMIC|PR_ADDR|PR_WANTRCVD,
  .pr_output	= route_output,
  .pr_ctloutput	= route_ctloutput,
  .pr_usrreq	= route_usrreq,
  .pr_attach	= route_attach,
  .pr_init	= raw_init,
  .pr_sysctl	= sysctl_rtable
}
};

struct domain routedomain = {
  .dom_family = PF_ROUTE,
  .dom_name = "route",
  .dom_init = route_init,
  .dom_protosw = routesw,
  .dom_protoswNPROTOSW = &routesw[nitems(routesw)]
};
@


1.237
log
@Use the rt_rmx defines that hide the struct rt_kmetrics indirection.
No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.236 2017/04/05 13:35:18 deraadt Exp $	*/
d775 8
d789 1
a789 3
		if ((rt != NULL) && (ISSET(rt->rt_flags, RTF_CACHED))) {
			ifp = if_get(rt->rt_ifidx);
			KASSERT(ifp != NULL);
a790 1
			if_put(ifp);
d794 1
d802 2
a803 2
		if ((rt != NULL) &&
		    ISSET(rt->rt_flags, RTF_LOCAL|RTF_BROADCAST)) {
d811 2
a812 3
		error = rtrequest(RTM_DELETE, info, prio, &rt, tableid);
		if (error != 0)
			break;
@


1.236
log
@When building counter memory in preparation to copy to userland, always
zero the buffers first.  All the current objects appear to be safe,
however future changes might introduce structure pads.
Discussed with guenther, ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.235 2017/03/16 10:13:11 mpi Exp $	*/
d983 2
a984 2
			rt->rt_rmx.rmx_locks &= ~(rtm->rtm_inits);
			rt->rt_rmx.rmx_locks |=
@


1.235
log
@Do not allow to change the gateway of an existing entry if the AF
family is incorrect.

Prevent bgpd(8) to corrupt ARP entries as reported by Joe Holden.

ok benno@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.234 2017/03/13 20:18:21 claudio Exp $	*/
d1645 1
d1677 1
a1677 1

@


1.234
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.233 2017/03/09 16:53:20 mpi Exp $	*/
d895 16
a910 4
			if (info->rti_info[RTAX_GATEWAY] != NULL && (error =
			    rt_setgate(rt, info->rti_info[RTAX_GATEWAY],
			    tableid)))
				break;
@


1.233
log
@Remove unecessary splsoftnet()/splx() dances.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.232 2017/03/07 09:23:27 mpi Exp $	*/
a168 40
	case PRU_ATTACH:
		/*
		 * use the rawcb but allocate a routecb, this
		 * code does not care about the additional fields
		 * and works directly on the raw socket.
		 */
		rop = malloc(sizeof(struct routecb), M_PCB, M_WAITOK|M_ZERO);
		rp = &rop->rcb;
		so->so_pcb = rp;
		/* Init the timeout structure */
		timeout_set(&rop->timeout, route_senddesync, rp);
		/*
		 * Don't call raw_usrreq() in the attach case, because
		 * we want to allow non-privileged processes to listen
		 * on and send "safe" commands to the routing socket.
		 */
		if (curproc == 0)
			error = EACCES;
		else
			error = raw_attach(so, (int)(long)nam);
		if (error) {
			free(rop, M_PCB, sizeof(struct routecb));
			return (error);
		}
		rop->rtableid = curproc->p_p->ps_rtableid;
		af = rp->rcb_proto.sp_protocol;
		if (af == AF_INET)
			route_cb.ip_count++;
		else if (af == AF_INET6)
			route_cb.ip6_count++;
#ifdef MPLS
		else if (af == AF_MPLS)
			route_cb.mpls_count++;
#endif
		rp->rcb_faddr = &route_src;
		route_cb.any_count++;
		soisconnected(so);
		so->so_options |= SO_USELOOPBACK;
		break;

d205 45
d1770 1
@


1.232
log
@Do not grab the NET_LOCK() for routing sockets operations.

The only function that need the lock is rtm_output() as it messes with
the routing table.  So grab the lock there since it is safe to sleep
in a process context.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.231 2017/03/07 06:58:55 claudio Exp $	*/
a308 1
	int		 s;
a322 1
		s = splsoftnet();
a326 1
			splx(s);
a328 1
		splx(s);
d342 1
a342 1
	int s, sockets = 0;
a428 1
				s = splsoftnet();
a444 1
				splx(s);
a449 1
		s = splsoftnet();
a461 1
		splx(s);
@


1.231
log
@Since route_input is no longer part of the protosw struct it is possible to
pass the socket to it and do the SO_USELOOPBACK check there. This removes
a the nasty hack in the output function where the sp_family is set to 0
temporarily.
OK bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.230 2017/03/06 10:19:17 mpi Exp $	*/
d101 2
d104 2
a165 2
	NET_ASSERT_LOCKED();

d350 2
d741 1
d743 1
d988 2
@


1.230
log
@Move the guts of route_output() meesing with the routing table in their
own function.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.229 2017/03/06 08:56:39 mpi Exp $	*/
d102 1
a102 1
void	route_input(struct mbuf *m0, sa_family_t);
d338 1
a338 1
route_input(struct mbuf *m0, sa_family_t sa_family)
d362 4
a544 1
	struct rawcb		*rp = NULL;
a709 3
		/* There is another listener, so construct message */
		rp = sotorawcb(so);
		rp->rcb_proto.sp_family = 0; /* Avoid us */
d720 1
a720 1
		route_input(m, info.rti_info[RTAX_DST] ?
a721 2
	if (rp)
		rp->rcb_proto.sp_family = PF_ROUTE; /* Readd us */
d1279 1
a1279 1
	route_input(m, sa ? sa->sa_family : AF_UNSPEC);
d1304 1
a1304 1
	route_input(m, AF_UNSPEC);
d1340 2
a1341 1
	route_input(m, ifa->ifa_addr ? ifa->ifa_addr->sa_family : AF_UNSPEC);
d1363 1
a1363 1
	route_input(m, AF_UNSPEC);
d1394 1
a1394 1
	route_input(m, info.rti_info[RTAX_DST]->sa_family);
@


1.229
log
@Prefix functions dealing with routing messages with 'rtm_' and keep
them all in net/rtsock.c.

This allows to easily spot which functions are doing a copyout(9)
when dealing with the routing midlayer.

ok phessler@@, bluhm@@, dhill@@, krw@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.228 2017/03/03 15:48:02 bluhm Exp $	*/
d107 2
d540 1
a540 3
	int			 plen, len, seq, newgate = 0, error = 0;
	struct ifnet		*ifp = NULL;
	struct ifaddr		*ifa = NULL;
a541 3
#ifdef MPLS
	struct sockaddr_mpls	*psa_mpls;
#endif
d679 39
a717 1
	       goto flush;
d719 20
d742 1
a742 1
		if (info.rti_info[RTAX_GATEWAY] == NULL) {
d744 1
a744 1
			goto flush;
d747 2
a748 2
		rt = rtable_match(tableid, info.rti_info[RTAX_DST], NULL);
		if ((error = route_arp_conflict(rt, &info))) {
d751 1
a751 1
			goto flush;
d765 1
a765 1
		error = rtrequest(RTM_ADD, &info, prio, &rt, tableid);
a768 2
		else
			goto flush;
d771 2
a772 2
		rt = rtable_lookup(tableid, info.rti_info[RTAX_DST],
		    info.rti_info[RTAX_NETMASK], info.rti_info[RTAX_GATEWAY],
d804 1
a804 1
		error = rtrequest(RTM_DELETE, &info, prio, &rt, tableid);
d806 1
a806 1
			goto flush;
d810 2
a811 2
		rt = rtable_lookup(tableid, info.rti_info[RTAX_DST],
		    info.rti_info[RTAX_NETMASK], info.rti_info[RTAX_GATEWAY],
d819 1
a819 1
		    (info.rti_info[RTAX_GATEWAY] == NULL)) {
d828 1
a828 1
		if ((rt == NULL) && (info.rti_info[RTAX_GATEWAY] != NULL) &&
d830 2
a831 2
			rt = rtable_lookup(tableid, info.rti_info[RTAX_DST],
			    info.rti_info[RTAX_NETMASK], NULL, prio);
d843 1
a843 1
			goto flush;
d849 2
a850 2
		plen = rtable_satoplen(info.rti_info[RTAX_DST]->sa_family,
		    info.rti_info[RTAX_NETMASK]);
d853 1
a853 1
			goto flush;
d858 1
a858 1
			if (info.rti_info[RTAX_GATEWAY] != NULL)
d861 2
a862 2
				    info.rti_info[RTAX_GATEWAY],
				    info.rti_info[RTAX_GATEWAY]->sa_len)) {
d871 5
a875 5
			if (newgate || info.rti_info[RTAX_IFP] != NULL ||
			    info.rti_info[RTAX_IFA] != NULL) {
				if ((error = rt_getifa(&info, tableid)) != 0)
					goto flush;
				ifa = info.rti_ifa;
d894 2
a895 2
			if (info.rti_info[RTAX_GATEWAY] != NULL && (error =
			    rt_setgate(rt, info.rti_info[RTAX_GATEWAY],
d897 1
a897 1
				goto flush;
d900 1
a900 1
			    info.rti_info[RTAX_SRC] != NULL) {
d904 1
a904 1
				    info.rti_info[RTAX_SRC];
d919 1
a919 1
				rt_mpls->mpls_operation = info.rti_mpls;
d939 1
a939 1
					goto flush;
d960 1
a960 1
			if (info.rti_info[RTAX_LABEL] != NULL) {
d962 1
a962 1
				    info.rti_info[RTAX_LABEL])->sr_label;
d966 2
a967 2
			if_group_routechange(info.rti_info[RTAX_DST],
			    info.rti_info[RTAX_NETMASK]);
d977 2
a978 2
		rt = rtable_lookup(tableid, info.rti_info[RTAX_DST],
		    info.rti_info[RTAX_NETMASK], info.rti_info[RTAX_GATEWAY],
d980 1
a980 1
		if (rt == NULL) {
a981 2
			goto flush;
		}
d984 1
a984 53

	/*
	 * From here on these vars need to be valid
	 * rt, rtm, error, so, m, tableid, sa_family
	 *
	 * Other notes:
	 * - to end up here previous calls passed OK, error is most probably 0
	 * - error cases take the flush route or in bad cases fail
	 * - fail does not report the message back but just fails the call
	 *   if the message is not valid then fail should be used
	 */

	type = rtm->rtm_type;
	seq = rtm->rtm_seq;
	free(rtm, M_RTABLE, 0);
	rtm = rtm_report(rt, type, seq, tableid);
flush:
	rtfree(rt);
	if (error) {
		rtm->rtm_errno = error;
	} else {
		rtm->rtm_flags |= RTF_DONE;
	}

	/*
	 * Check to see if we don't want our own messages.
	 */
	if (!(so->so_options & SO_USELOOPBACK)) {
		if (route_cb.any_count <= 1) {
			/* no other listener and no loopback of messages */
fail:
			free(rtm, M_RTABLE, 0);
			m_freem(m);
			return (error);
		}
		/* There is another listener, so construct message */
		rp = sotorawcb(so);
		rp->rcb_proto.sp_family = 0; /* Avoid us */
	}
	if (rtm) {
		if (m_copyback(m, 0, rtm->rtm_msglen, rtm, M_NOWAIT)) {
			m_freem(m);
			m = NULL;
		} else if (m->m_pkthdr.len > rtm->rtm_msglen)
			m_adj(m, rtm->rtm_msglen - m->m_pkthdr.len);
		free(rtm, M_RTABLE, 0);
	}
	if (m)
		route_input(m, info.rti_info[RTAX_DST] ?
		    info.rti_info[RTAX_DST]->sa_family : AF_UNSPEC);
	if (rp)
		rp->rcb_proto.sp_family = PF_ROUTE; /* Readd us */

@


1.228
log
@Convert the variable argument list of the pr_output functions to
fixed parameters.
OK mpi@@ claudio@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.227 2017/03/03 14:22:40 bluhm Exp $	*/
d105 1
d107 3
a109 2
struct mbuf	*rt_msg1(int, struct rt_addrinfo *);
int		 rt_msg2(int, int, struct rt_addrinfo *, caddr_t,
d111 6
a116 3
void		 rt_xaddrs(caddr_t, caddr_t, struct rt_addrinfo *);

void		 rt_proposalmsg(struct rt_msghdr *, struct rt_addrinfo *);
a121 2
int		 validate_proposal(struct rt_addrinfo *);

a150 2
void	rt_senddesync(void *);

d175 1
a175 1
		timeout_set(&((struct routecb *)rp)->timeout, rt_senddesync, rp);
d300 1
a300 1
rt_senddesync(void *data)
d318 1
a318 1
	desync_mbuf = rt_msg1(RTM_DESYNC, NULL);
d434 1
a434 1
					rt_senddesync((void *) sotorawcb(last));
d453 1
a453 1
			rt_senddesync((void *) sotorawcb(last));
d465 1
a465 1
rt_report(struct rtentry *rt, u_char type, int seq, int tableid)
d512 1
a512 1
	len = rt_msg2(type, RTM_VERSION, &info, NULL, NULL);
d515 1
a515 1
	rt_msg2(type, RTM_VERSION, &info, (caddr_t)rtm, NULL);
d523 1
a523 1
	rt_getmetrics(&rt->rt_rmx, &rtm->rtm_rmx);
d647 1
a647 1
	rt_xaddrs(rtm->rtm_hdrlen + (caddr_t)rtm, len + (caddr_t)rtm, &info);
d678 1
a678 1
	       if (validate_proposal(&info) == -1) {
d712 1
a712 1
			rt_setmetrics(rtm->rtm_inits, &rtm->rtm_rmx,
d899 1
a899 1
			rt_setmetrics(rtm->rtm_inits, &rtm->rtm_rmx,
d948 1
a948 1
	rtm = rt_report(rt, type, seq, tableid);
d1040 1
a1040 1
rt_setmetrics(u_long which, const struct rt_metrics *in,
d1059 1
a1059 1
rt_getmetrics(const struct rt_kmetrics *in, struct rt_metrics *out)
d1081 1
a1081 1
rt_xaddrs(caddr_t cp, caddr_t cplim, struct rt_addrinfo *rtinfo)
d1096 1
a1096 1
rt_msg1(int type, struct rt_addrinfo *rtinfo)
d1125 1
a1125 1
		panic("rt_msg1");
d1159 1
a1159 1
rt_msg2(int type, int vers, struct rt_addrinfo *rtinfo, caddr_t cp,
d1231 25
d1263 1
a1263 1
rt_missmsg(int type, struct rt_addrinfo *rtinfo, int flags, uint8_t prio,
d1272 1
a1272 1
	m = rt_msg1(type, rtinfo);
d1290 1
a1290 1
rt_ifmsg(struct ifnet *ifp)
d1297 1
a1297 1
	m = rt_msg1(RTM_IFINFO, NULL);
d1319 1
a1319 1
rt_sendaddrmsg(struct rtentry *rt, int cmd, struct ifaddr *ifa)
d1334 1
a1334 1
	if ((m = rt_msg1(cmd, &info)) == NULL)
d1351 1
a1351 1
rt_ifannouncemsg(struct ifnet *ifp, int what)
d1358 1
a1358 1
	m = rt_msg1(RTM_IFANNOUNCE, NULL);
d1374 1
a1374 1
rt_bfdmsg(struct bfd_config *bfd)
d1387 1
a1387 1
	m = rt_msg1(RTM_BFD, &info);
d1464 1
a1464 1
	size = rt_msg2(RTM_GET, RTM_VERSION, &info, NULL, w);
d1471 1
a1471 1
		rt_getmetrics(&rt->rt_rmx, &rtm->rtm_rmx);
d1502 1
a1502 1
		len = rt_msg2(RTM_IFINFO, RTM_VERSION, &info, 0, w);
d1525 1
a1525 1
			len = rt_msg2(RTM_NEWADDR, RTM_VERSION, &info, 0, w);
d1671 1
a1671 1
validate_proposal(struct rt_addrinfo *info)
@


1.227
log
@It is allowed to sleep in route_output() as we run in process context
and do no critical operations on global structures or per socket.
The route entry we are working on is reference counted.  Call
malloc(9) with M_WAITOK and remove the NULL result checks.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.226 2017/03/02 17:09:21 krw Exp $	*/
d531 2
a532 1
route_output(struct mbuf *m, ...)
a539 1
	struct socket		*so;
a543 1
	va_list			 ap;
a546 4

	va_start(ap, m);
	so = va_arg(ap, struct socket *);
	va_end(ap);
@


1.226
log
@Implement a new routing message RTM_PROPOSAL that communicates
information that can be used to configure an interface and
related network components.

ok bluhm@@, ok for various older versions mpi@@ florian@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.225 2017/03/02 09:37:04 mpi Exp $	*/
d512 1
a512 4
	/* XXX why can't we wait? Should be process context... */
	rtm = malloc(len, M_RTABLE, M_NOWAIT | M_ZERO);
	if (rtm == NULL)
		return NULL;
d575 1
a575 5
		rtm = malloc(len, M_RTABLE, M_NOWAIT);
		if (rtm == NULL) {
			error = ENOBUFS;
			goto fail;
		}
d860 1
a860 5
					    M_TEMP, M_NOWAIT|M_ZERO);
				}
				if (rt->rt_llinfo == NULL) {
					error = ENOMEM;
					goto flush;
d955 1
a955 4
	if (rtm == NULL) {
		error = ENOBUFS;
		goto fail;
	} else if (error) {
@


1.225
log
@Fix a rtentry leak in error path.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.224 2017/03/02 08:58:24 mpi Exp $	*/
d111 2
d117 2
d604 1
d660 2
a661 1
	if (info.rti_info[RTAX_DST] == NULL ||
d665 1
a665 1
	    info.rti_info[RTAX_GENMASK] != NULL) {
d684 12
d1661 83
@


1.224
log
@Convert domain declarations to C99 initializers.

ok dhill@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.223 2017/02/22 19:34:42 dhill Exp $	*/
d946 2
d951 4
a954 11
	}

flush:
	if (rt)
		rtfree(rt);
	if (rtm) {
		if (error)
			rtm->rtm_errno = error;
		else {
			rtm->rtm_flags |= RTF_DONE;
		}
@


1.223
log
@Use c99 struct initialization with protosw.

This makes it easier to grep for a member, such as .pr_usrreq, and know
which functions to review.

ok mpi@@ bluhm@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.222 2017/02/01 20:59:47 dhill Exp $	*/
d1669 7
a1675 3
struct domain routedomain =
    { PF_ROUTE, "route", route_init, 0, 0,
      routesw, &routesw[nitems(routesw)] };
@


1.222
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.221 2017/01/31 10:24:41 jca Exp $	*/
d1657 9
a1665 5
{ SOCK_RAW,	&routedomain,	0,		PR_ATOMIC|PR_ADDR|PR_WANTRCVD,
  0,		route_output,	0,		route_ctloutput,
  route_usrreq,
  raw_init,	0,		0,		0,
  sysctl_rtable,
@


1.221
log
@Use CTASSERT instead of KASSERT for a few sysctl that use the counters API

ok dlg@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.220 2017/01/24 00:17:14 claudio Exp $	*/
d101 1
a101 1
int	route_ctloutput(int, struct socket *, int, int, struct mbuf **);
d237 1
a237 1
    struct mbuf **mp)
a239 1
	struct mbuf *m = *mp;
d245 2
a246 2
		if (op == PRCO_SETOPT && *mp)
			m_free(*mp);
a278 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
a282 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
@


1.220
log
@Introduce rt_report() a function that generates a route message from an
rt_entry. Use this function in the success case of all route commands.
Reduce the goto madness in route_output and make the code hopefully a
bit easier to read and work with.
OK mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.219 2017/01/23 07:27:21 dlg Exp $	*/
d1643 1
a1643 1
	KASSERT(sizeof(rtstat) == (nitems(counters) * sizeof(uint32_t)));
@


1.219
log
@i botched the copyout to ifr->ifr_data in SIOCGIFDATA.

this lets pflogd run again.

rename if_data() to if_getdata() while here to make grepping for
things less noisy.

reported by jsg@@
worked through with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.218 2017/01/23 01:26:09 dlg Exp $	*/
d462 70
a536 1
	struct rtentry		*saved_nrt = NULL;
d538 1
a538 1
	int			 plen, len, newgate = 0, error = 0;
a542 5
	struct sockaddr_rtlabel	 sa_rl;
	struct sockaddr_in6	 sa_mask;
#ifdef BFD
	struct sockaddr_bfd	 sa_bfd;
#endif
d544 1
a544 1
	struct sockaddr_mpls	 sa_mpls, *psa_mpls;
d549 1
a549 1
	u_char			 vers;
d706 2
a707 2
		error = rtrequest(RTM_ADD, &info, prio, &saved_nrt, tableid);
		if (error == 0) {
d709 3
a711 7
			    &saved_nrt->rt_rmx);
			/* write back the priority the kernel used */
			rtm->rtm_priority = saved_nrt->rt_priority & RTP_MASK;
			rtm->rtm_index = saved_nrt->rt_ifidx;
			rtm->rtm_flags = saved_nrt->rt_flags;
			rtfree(saved_nrt);
		}
d731 1
a731 1
			goto report;
d741 1
a741 1
			goto report;
d748 1
a748 9
		if (error == 0)
			goto report;
		break;
	case RTM_GET:
		rt = rtable_lookup(tableid, info.rti_info[RTAX_DST],
		    info.rti_info[RTAX_NETMASK], info.rti_info[RTAX_GATEWAY],
		    prio);
		if (rt == NULL) {
			error = ESRCH;
a749 61
		}

report:
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] =
		    rt_plen2mask(rt, &sa_mask);
		info.rti_info[RTAX_LABEL] =
		    rtlabel_id2sa(rt->rt_labelid, &sa_rl);
#ifdef BFD
		if (rt->rt_flags & RTF_BFD)
			info.rti_info[RTAX_BFD] = bfd2sa(rt, &sa_bfd);
#endif
#ifdef MPLS
		if (rt->rt_flags & RTF_MPLS) {
			bzero(&sa_mpls, sizeof(sa_mpls));
			sa_mpls.smpls_family = AF_MPLS;
			sa_mpls.smpls_len = sizeof(sa_mpls);
			sa_mpls.smpls_label = ((struct rt_mpls *)
			    rt->rt_llinfo)->mpls_label;
			info.rti_info[RTAX_SRC] =
			    (struct sockaddr *)&sa_mpls;
			info.rti_mpls = ((struct rt_mpls *)
			    rt->rt_llinfo)->mpls_operation;
			rtm->rtm_mpls = info.rti_mpls;
		}
#endif
		info.rti_info[RTAX_IFP] = NULL;
		info.rti_info[RTAX_IFA] = NULL;
		ifp = if_get(rt->rt_ifidx);
		if (ifp != NULL && rtm->rtm_addrs & (RTA_IFP|RTA_IFA)) {
			info.rti_info[RTAX_IFP] = sdltosa(ifp->if_sadl);
			info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
			if (ifp->if_flags & IFF_POINTOPOINT)
				info.rti_info[RTAX_BRD] =
				    rt->rt_ifa->ifa_dstaddr;
			else
				info.rti_info[RTAX_BRD] = NULL;
		}
		if_put(ifp);
		len = rt_msg2(rtm->rtm_type, RTM_VERSION, &info, NULL,
		    NULL);
		if (len > rtm->rtm_msglen) {
			struct rt_msghdr	*new_rtm;
			new_rtm = malloc(len, M_RTABLE, M_NOWAIT);
			if (new_rtm == NULL) {
				error = ENOBUFS;
				goto flush;
			}
			memcpy(new_rtm, rtm, rtm->rtm_msglen);
			free(rtm, M_RTABLE, 0);
			rtm = new_rtm;
		}
		rt_msg2(rtm->rtm_type, RTM_VERSION, &info, (caddr_t)rtm,
		    NULL);
		rtm->rtm_flags = rt->rt_flags;
		rtm->rtm_use = 0;
		rtm->rtm_priority = rt->rt_priority & RTP_MASK;
		rtm->rtm_index = rt->rt_ifidx;
		rt_getmetrics(&rt->rt_rmx, &rtm->rtm_rmx);
		rtm->rtm_addrs = info.rti_addrs;
a900 3
			rtm->rtm_index = rt->rt_ifidx;
			rtm->rtm_priority = rt->rt_priority & RTP_MASK;
			rtm->rtm_flags = rt->rt_flags;
a919 1
			rtm->rtm_priority = rt->rt_priority & RTP_MASK;
d923 29
d955 2
a963 2
	if (rt)
		rtfree(rt);
d970 1
@


1.218
log
@merge the ifnet and ifqueue stats together when userland wants them.

a new if_data() function takes a pointer to ifnet and merges its
if_data and ifq statistics. it takes the ifq mutex around the reads
of the ifq stats so they get a consistent copy.

the ifnet and ifq stats are merged because some parts of the stack
still update the ifnet counters.

ok visa@@ (on an earlier diff) mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.217 2017/01/23 00:10:07 krw Exp $	*/
d1271 1
a1271 1
	if_data(ifp, &ifm->ifm_data);
d1476 1
a1476 1
			if_data(ifp, &ifm->ifm_data);
@


1.217
log
@Zap some bad whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.216 2017/01/22 04:31:02 claudio Exp $	*/
d1271 1
a1271 1
	ifm->ifm_data = ifp->if_data;
d1476 1
a1476 1
			ifm->ifm_data = ifp->if_data;
@


1.216
log
@Cleanup error handling. Do not use 'goto flush' early on since the message
is actually not syntactically valid, call 'goto fail' instead.
Remove unneeded rtable_exists() exists checks since those have been done
early on.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.215 2017/01/21 03:44:46 claudio Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d134 2
a135 2
 * These flags and timeout are used for indicating to userland (via a 
 * RTM_DESYNC msg) when the route socket has overflowed and messages 
d139 1
a139 1
#define ROUTECB_FLAG_FLUSH	0x2	/* Wait until socket is empty before 
d204 1
a204 1
		 * If we are in a FLUSH state, check if the buffer is 
d208 1
a208 1
		    ((sbspace(&rp->rcb_socket->so_rcv) == 
d280 1
a280 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);   
d285 1
a285 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);   
d313 1
a313 1
	 * If we fail to alloc memory or if sbappendaddr() 
d319 1
a319 1
		if (sbappendaddr(&rp->rcb_socket->so_rcv, &route_src, 
d343 1
a343 1
	
d412 1
a412 1
		 * Check to see if the flush flag is set. If so, don't queue 
d426 1
a426 1
					 * Flag socket as desync'ed and 
d429 2
a430 2
					sotoroutecb(last)->flags |= 
					    ROUTECB_FLAG_DESYNC | 
d449 1
a449 1
			sotoroutecb(last)->flags |= 
d772 2
a773 2
		    	rtfree(rt);
		    	rt = NULL;
d942 1
a942 1
		else { 
d1545 1
a1545 1
	u_char  		 af;
@


1.215
log
@Change route_input to a non-variadic function and just pass the address
family to it. Simplifies the code and disconnects route_input from protosw.
The rouing socket is special so no need to try to work like other protos.
With input from bluhm@@, OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.214 2017/01/20 08:10:54 dlg Exp $	*/
a490 1
	info.rti_info[RTAX_DST] = NULL;	/* for error handling (goto flush) */
d557 1
a557 1
				goto flush;
d560 1
a560 1
			goto flush;
d600 1
a600 1
		goto flush;
d612 5
a653 5
		if (!rtable_exists(tableid)) {
			error = EAFNOSUPPORT;
			goto flush;
		}

a691 4
		if (!rtable_exists(tableid)) {
			error = EAFNOSUPPORT;
			goto flush;
		}
a761 5
		if (!rtable_exists(tableid)) {
			error = EAFNOSUPPORT;
			goto flush;
		}

@


1.214
log
@use per-cpu counters for rtstat.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.213 2017/01/19 23:18:29 phessler Exp $	*/
a94 1
struct sockproto	route_proto = { PF_ROUTE, };
d102 1
a102 1
void	route_input(struct mbuf *m0, ...);
d334 1
a334 1
route_input(struct mbuf *m0, ...)
a341 2
	va_list ap;
	struct sockproto *proto;
d344 2
a345 5
	va_start(ap, m0);
	proto = va_arg(ap, struct sockproto *);
	sosrc = va_arg(ap, struct sockaddr *);
	sodst = va_arg(ap, struct sockaddr *);
	va_end(ap);
d356 1
a356 1
		if (rp->rcb_proto.sp_family != proto->sp_family)
d358 8
a365 2
		if (rp->rcb_proto.sp_protocol && proto->sp_protocol &&
		    rp->rcb_proto.sp_protocol != proto->sp_protocol)
a955 2
	if (info.rti_info[RTAX_DST])
		route_proto.sp_protocol = info.rti_info[RTAX_DST]->sa_family;
d971 1
a972 2
	if (rp)
		rp->rcb_proto.sp_family = 0; /* Avoid us */
d982 2
a983 1
		route_input(m, &route_proto, &route_src, &route_dst);
d985 1
a985 1
		rp->rcb_proto.sp_family = PF_ROUTE;
a1056 1
	/* RTV_PRIORITY handled before */
d1258 1
a1258 5
	if (sa == NULL)
		route_proto.sp_protocol = 0;
	else
		route_proto.sp_protocol = sa->sa_family;
	route_input(m, &route_proto, &route_src, &route_dst);
d1283 1
a1283 2
	route_proto.sp_protocol = 0;
	route_input(m, &route_proto, &route_src, &route_dst);
d1319 1
a1319 5
	if (ifa->ifa_addr == NULL)
		route_proto.sp_protocol = 0;
	else
		route_proto.sp_protocol = ifa->ifa_addr->sa_family;
	route_input(m, &route_proto, &route_src, &route_dst);
d1341 1
a1341 2
	route_proto.sp_protocol = 0;
	route_input(m, &route_proto, &route_src, &route_dst);
d1372 1
a1372 2
	route_proto.sp_protocol = info.rti_info[RTAX_DST]->sa_family;
	route_input(m, &route_proto, &route_src, &route_dst);
d1654 1
a1654 1
  route_input,	route_output,	0,		route_ctloutput,
@


1.213
log
@add hooks so we can query the current state of a BFD session

bfd session details are visible with "route -n get 192.0.2.1 -bfd"

OK mpi@@ deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.212 2016/12/20 18:33:43 bluhm Exp $	*/
d114 1
d1615 1
a1615 3
		error = sysctl_rdstruct(where, given, new,
		    &rtstat, sizeof(rtstat));
		return (error);
d1639 19
@


1.212
log
@A NET_LOCK() was is missing in tcp_sysctl() which shows up as spl
softnet assert failures.  It is better to place the lock into
net_sysctl() where all the protocol sysctls are called via pr_sysctl.
As calling sysctl(2) is in the slow path, doing fine grained locking
has no benefit.  Many sysctl cases copy out a struct.  Having a
lock around that keeps the struct consistent.  Put assertions in
the protocol sysctls that need it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.211 2016/12/19 08:36:49 mpi Exp $	*/
d475 3
d711 4
d1365 1
d1379 1
d1381 2
a1382 17
	bfdm->bm_mode = bfd->bc_mode;
	bfdm->bm_mintx = bfd->bc_mintx;
	bfdm->bm_minrx = bfd->bc_minrx;
	bfdm->bm_minecho = bfd->bc_minecho;
	bfdm->bm_multiplier = bfd->bc_multiplier;

	bfdm->bm_uptime = bfd->bc_time->tv_sec;
	bfdm->bm_lastuptime = bfd->bc_lastuptime;
	bfdm->bm_state = bfd->bc_state;
	bfdm->bm_remotestate = bfd->bc_neighbor->bn_rstate;
	bfdm->bm_laststate = bfd->bc_laststate;
	bfdm->bm_error = bfd->bc_error;

	bfdm->bm_localdiscr = bfd->bc_neighbor->bn_ldiscr;
	bfdm->bm_localdiag = bfd->bc_neighbor->bn_ldiag;
	bfdm->bm_remotediscr = bfd->bc_neighbor->bn_rdiscr;
	bfdm->bm_remotediag = bfd->bc_neighbor->bn_rdiag;
d1384 1
a1384 1
	route_proto.sp_protocol = 0;
d1399 3
d1436 4
@


1.211
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.210 2016/11/29 10:22:30 jsg Exp $	*/
d1566 1
a1566 1
	int			 i, s, error = EINVAL;
d1572 2
a1592 1
	s = splsoftnet();
a1614 1
		splx(s);
d1618 1
a1618 2
		if (!rtable_exists(tableid)) {
			splx(s);
a1619 1
		}
a1623 1
		splx(s);
a1628 1
	splx(s);
@


1.210
log
@m_free() and m_freem() test for NULL.  Simplify callers which had their own
NULL tests.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.209 2016/11/21 09:09:06 mpi Exp $	*/
d155 1
a155 1
	splsoftassert(IPL_SOFTNET);
@


1.209
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.208 2016/10/18 11:05:45 bluhm Exp $	*/
d275 1
a275 2
		if (m)
			m_free(m);
@


1.208
log
@Place splsoftnet() in route_input() to shut up splassert warnings
in sorwakeup().
Report from egorenar-dev at posteo.net; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.207 2016/09/27 18:41:11 bluhm Exp $	*/
d152 1
a152 1
	int		 s, af;
d155 2
a156 1
	s = splsoftnet();
a181 1
			splx(s);
a231 1
	splx(s);
@


1.207
log
@Protect sbappendaddr() and sorwakeup() with splsoftnet in
rt_senddesync().  This fixes a splassert warning seen by sthen@@.
Problem found by David Hill; OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.206 2016/09/24 19:27:10 phessler Exp $	*/
d342 1
a342 1
	int sockets = 0;
d422 1
d439 1
d445 1
d458 1
@


1.206
log
@a route message for BFD, so we can notify userland about the status.
currently used on state-transitions.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.205 2016/09/17 07:35:05 phessler Exp $	*/
d305 1
d311 12
a322 9
	if ((rop->flags & ROUTECB_FLAG_DESYNC) != 0) {
		/*
		 * If we fail to alloc memory or if sbappendaddr() 
		 * fails, re-add timeout and try again.
		 */
		desync_mbuf = rt_msg1(RTM_DESYNC, NULL);
		if ((desync_mbuf != NULL) && 
		    (sbappendaddr(&rp->rcb_socket->so_rcv, &route_src, 
		    desync_mbuf, (struct mbuf *)NULL) != 0)) {
d325 2
a326 4
		} else {
			m_freem(desync_mbuf);
			/* Re-add timeout to try sending msg again */
			timeout_add(&rop->timeout, ROUTE_DESYNC_RESEND_TIMEOUT);
d328 2
d331 2
@


1.205
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.204 2016/09/07 09:36:49 mpi Exp $	*/
d1103 5
d1340 46
@


1.204
log
@Rename rtable_mpath_next() into rtable_iterate() and make it do a proper
reference count.

rtable_iterate() frees the passed ``rt'' and returns the next one on the
multipath list or NULL if there's none.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.203 2016/09/05 15:12:30 claudio Exp $	*/
d888 1
a888 1
				if ((error = bfd_rtalloc(rt)))
d892 1
a892 1
				bfd_rtfree(rt);
@


1.203
log
@Kill raw_ctlinput() this function is INCOMPLETE since rev 1.1 and is not
needed. All callers using the protosw pr_ctlinput pointer do a NULL check
before so there is no need to provide the function.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.202 2016/09/04 09:39:01 claudio Exp $	*/
d998 1
a998 1
#if defined(ART) && !defined(SMALL_KERNEL)
d1017 1
a1017 1
	    (rtable_mpath_next(rt) != NULL))
d1022 1
a1022 1
#endif /* ART && !SMALL_KERNEL */
@


1.202
log
@Make it possible to toggle RTF_BFD via RTM_CHANGE and fix some minor things
in bfd.c. Make bfd_rtfree() a void function.
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.201 2016/09/01 17:00:38 claudio Exp $	*/
d1594 1
a1594 1
  route_input,	route_output,	raw_ctlinput,	route_ctloutput,
@


1.201
log
@No longer needed to special case RTM_GET in these if statements since
RTM_GET is no longer sharing this case block.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.200 2016/09/01 16:53:38 claudio Exp $	*/
d85 3
a541 1

d885 11
@


1.200
log
@Move RTM_GET into its own case block not intermixing it with RTM_CHANGE
and RTM_LOCK. This is start for more changes here. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.199 2016/09/01 11:26:44 mpi Exp $	*/
d760 1
a760 1
		 * a matching gateway, except for RTM_GET.
d763 1
a763 2
		    (info.rti_info[RTAX_GATEWAY] == NULL) &&
		    (rtm->rtm_type != RTM_GET)) {
d795 1
a795 1
		if (rtm->rtm_type != RTM_GET && rt_plen(rt) != plen ) {
@


1.199
log
@Move the RTF_LOCAL check that only makes sense for userland to
route_output().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.198 2016/09/01 09:35:28 mpi Exp $	*/
d679 68
a801 58
		case RTM_GET:
report:
			info.rti_info[RTAX_DST] = rt_key(rt);
			info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
			info.rti_info[RTAX_NETMASK] =
			    rt_plen2mask(rt, &sa_mask);
			info.rti_info[RTAX_LABEL] =
			    rtlabel_id2sa(rt->rt_labelid, &sa_rl);
#ifdef MPLS
			if (rt->rt_flags & RTF_MPLS) {
				bzero(&sa_mpls, sizeof(sa_mpls));
				sa_mpls.smpls_family = AF_MPLS;
				sa_mpls.smpls_len = sizeof(sa_mpls);
				sa_mpls.smpls_label = ((struct rt_mpls *)
				    rt->rt_llinfo)->mpls_label;
				info.rti_info[RTAX_SRC] =
				    (struct sockaddr *)&sa_mpls;
				info.rti_mpls = ((struct rt_mpls *)
				    rt->rt_llinfo)->mpls_operation;
				rtm->rtm_mpls = info.rti_mpls;
			}
#endif
			info.rti_info[RTAX_IFP] = NULL;
			info.rti_info[RTAX_IFA] = NULL;
			ifp = if_get(rt->rt_ifidx);
			if (ifp != NULL && rtm->rtm_addrs & (RTA_IFP|RTA_IFA)) {
				info.rti_info[RTAX_IFP] = sdltosa(ifp->if_sadl);
				info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
				if (ifp->if_flags & IFF_POINTOPOINT)
					info.rti_info[RTAX_BRD] =
					    rt->rt_ifa->ifa_dstaddr;
				else
					info.rti_info[RTAX_BRD] = NULL;
			}
			if_put(ifp);
			len = rt_msg2(rtm->rtm_type, RTM_VERSION, &info, NULL,
			    NULL);
			if (len > rtm->rtm_msglen) {
				struct rt_msghdr	*new_rtm;
				new_rtm = malloc(len, M_RTABLE, M_NOWAIT);
				if (new_rtm == NULL) {
					error = ENOBUFS;
					goto flush;
				}
				memcpy(new_rtm, rtm, rtm->rtm_msglen);
				free(rtm, M_RTABLE, 0);
				rtm = new_rtm;
			}
			rt_msg2(rtm->rtm_type, RTM_VERSION, &info, (caddr_t)rtm,
			    NULL);
			rtm->rtm_flags = rt->rt_flags;
			rtm->rtm_use = 0;
			rtm->rtm_priority = rt->rt_priority & RTP_MASK;
			rtm->rtm_index = rt->rt_ifidx;
			rt_getmetrics(&rt->rt_rmx, &rtm->rtm_rmx);
			rtm->rtm_addrs = info.rti_addrs;
			break;

@


1.198
log
@Use rtable_match() rather than rtalloc() when looking for an existing
entry in RTM_ADD.

rtable_match() does not modify the 'Use' counter of the route and unbreak
regression tests.

Breakage reported by bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.197 2016/09/01 09:22:58 mpi Exp $	*/
d660 11
@


1.197
log
@RTM_CHANGE should not allow to change the gateway of a mpath route.

Fix rttest13.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.196 2016/08/23 13:07:26 mpi Exp $	*/
d606 1
a606 1
		rt = rtalloc(info.rti_info[RTAX_DST], 0, tableid);
@


1.196
log
@Update the L2 content of a RTF_CACHED entry instead of going though
a create/delete/insert cycle as such entry cannot be deleted when
referenced.

Regression reported by and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.195 2016/08/22 16:01:52 mpi Exp $	*/
d678 1
a678 1
#ifdef SMALL_KERNEL
d698 7
@


1.195
log
@Make the ``rt_gwroute'' pointer of RTF_GATEWAY entries immutable.

This means that no protection is needed to guarantee that the next hop
route wont be modified by CPU1 while CPU0 is dereferencing it in a L2
resolution functions.

While here also fix an ``ifa'' leak resulting in RTF_GATEWAY being always
invalid.

dlg@@ likes it, inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.194 2016/07/11 13:06:31 bluhm Exp $	*/
d101 1
a101 1
int	route_arp_conflict(struct rt_addrinfo *, unsigned int);
d457 1
a457 1
	int			 plen, len, newgate, error = 0;
d605 5
a609 1
		if ((error = route_arp_conflict(&info, tableid)))
d611 13
a774 1
			newgate = 0;
d810 1
d956 1
a956 1
route_arp_conflict(struct rt_addrinfo *info, unsigned int tableid)
a958 1
	struct rtentry	*rt;
d965 5
a969 3
	rt = rtalloc(info->rti_info[RTAX_DST], 0, tableid);
	if (rt == NULL || !ISSET(rt->rt_flags, RTF_LLINFO)) {
		rtfree(rt);
a970 1
	}
d973 1
a973 1
	 * Same destination and both "priv" or "pub" conflict.
d977 1
a977 2
	    (rtable_mpath_next(rt) != NULL)) {
		rtfree(rt);
a978 1
	}
a981 1
	rtfree(rt);
@


1.194
log
@Path MTU discovery was slightly broken.  I took two ICMP packets
to create and change the dynamic route.  This behavior was introduced
in net/route.c rev 1.269 when the gateway route allocation was moved
from rt_setgateway() to _rtalloc().  So rtrequest(RTM_ADD) could
return a route without a valid gateway route.  To fix this, call
rt_setgwroute() from _rtalloc() and rt_setgateway().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.193 2016/07/11 09:23:06 mpi Exp $	*/
d102 1
d560 1
a560 1
	rtm->rtm_flags &= ~(RTF_DONE|RTF_CLONED);
d619 27
a776 6
			}
			if (info.rti_info[RTAX_GATEWAY] != NULL && (error =
			    rt_setgate(rt, info.rti_info[RTAX_GATEWAY],
			    tableid)))
				goto flush;
			if (ifa) {
d794 4
d917 12
@


1.193
log
@Revert the introduction of ``rt_addr''.

Being able to add route entries without configured addresses is a nice
feature but this is not my fight.  So I'd rather no add another pointer
to ``struct rtentry'' if I'm not removing another one.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.192 2016/06/14 09:48:52 mpi Exp $	*/
d751 2
a752 1
			    rt_setgate(rt, info.rti_info[RTAX_GATEWAY])))
@


1.192
log
@Pass the configured ``ifa'' to rt_sendaddrmsg() instead of getting it via
``rt->rt_ifa'' later.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.191 2016/06/14 09:44:41 mpi Exp $	*/
d698 1
a698 1
				info.rti_info[RTAX_IFA] = rt->rt_addr;
d1281 1
a1281 1
		info.rti_info[RTAX_IFA] = rt->rt_addr;
@


1.191
log
@Store the source address associated with a route in its own chunk of
memory.

This will allow to unlink 'sruct rtentry' and 'struct ifaddr' to be able
to add route entries without needing an address.

ok sthen@@, visa@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.190 2016/06/03 02:56:59 dlg Exp $	*/
d1189 1
a1189 1
rt_sendaddrmsg(struct rtentry *rt, int cmd)
a1190 1
	struct ifaddr		*ifa = rt->rt_ifa;
@


1.190
log
@set rt_expire times against time_uptime, not time_second.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.189 2016/06/01 12:06:49 mpi Exp $	*/
d698 1
a698 1
				info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
d1282 1
a1282 1
		info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
@


1.189
log
@Remove ART-specific hack now that route reference counts is similar
to the original BSD routing table.

All route(8) and arp(8) tests still pass.

Fix a harmless underflow reported by Hrvoje Popovski.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.188 2016/03/30 10:13:14 mpi Exp $	*/
d934 2
a935 1
rt_setmetrics(u_long which, struct rt_metrics *in, struct rt_kmetrics *out)
d937 2
d941 9
a949 2
	if (which & RTV_EXPIRE)
		out->rmx_expire = in->rmx_expire;
d954 1
a954 1
rt_getmetrics(struct rt_kmetrics *in, struct rt_metrics *out)
d956 8
d967 1
a967 1
	out->rmx_expire = in->rmx_expire;
@


1.188
log
@Implement proxy ARP for ART based on mpath support.

Since mpath is not enabled in RAMDISK, proxy ARP won't work there either.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.187 2016/03/26 21:56:04 mpi Exp $	*/
a1292 3
#ifdef ART
		rtm->rtm_rmx.rmx_refcnt--;
#endif
@


1.187
log
@Always include the route priority in routing messages.

From Florian Riehm, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.186 2016/01/12 09:27:46 mpi Exp $	*/
d101 1
d604 2
d890 41
@


1.186
log
@Compare if the prefix lengths are equal rather than checking if the
netmasks are non-NULL for RTM_CHANGE and RTM_LOCK.

Fix route(8) regressions tests 14 and 16 with ART kernels.  These tests
were failing because with ART, RTF_HOST routes always have a mask.

ok claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.185 2015/12/03 21:57:59 mpi Exp $	*/
d1066 2
a1067 2
rt_missmsg(int type, struct rt_addrinfo *rtinfo, int flags, u_int ifidx,
    int error, u_int tableid)
d1080 1
@


1.185
log
@Get rid of rt_mask() and stop allocating a "struct sockaddr" for every
route entry in ART.

rt_plen() now represents the prefix length of a route entry and should
be used instead.

For now use a "struct sockaddr_in6" to represent the mask when needed,
this should be then replaced by the prefix length and RTA_NETMASK only
used for compatibility with userland.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.184 2015/12/03 14:19:55 mpi Exp $	*/
d455 1
a455 1
	int			 len, newgate, error = 0;
d658 1
a658 7
		 * RTM_CHANGE/LOCK need a perfect match, rn_lookup()
		 * returns a perfect match in case a netmask is specified.
		 * For host routes only a longest prefix match is returned
		 * so it is necessary to compare the existence of the netmaks.
		 * If both have a netmask rn_lookup() did a perfect match and
		 * if none of them have a netmask both are host routes which is
		 * also a perfect match.
d660 3
a662 2
		if (rtm->rtm_type != RTM_GET && !rt_plen2mask(rt, &sa_mask) !=
		    !info.rti_info[RTAX_NETMASK]) {
d1248 3
@


1.184
log
@Store an interface index instead of a pointer in the "struct rtentry".

These indexes are unique and should be used with if_get() to get a
pointer to the corresponding ``ifp''.  Such pointer is guaranteed to
be valid in a MP environment until if_put() is called.

ok claudio@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.183 2015/11/18 14:13:52 mpi Exp $	*/
d80 2
d461 1
d666 2
a667 2
		if (rtm->rtm_type != RTM_GET &&
		    !rt_mask(rt) != !info.rti_info[RTAX_NETMASK]) {
d677 2
a678 1
			info.rti_info[RTAX_NETMASK] = rt_mask(rt);
d1200 1
d1220 1
a1220 1
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
@


1.183
log
@Do not dereference rt_ifp to call if_rtrequest.

This only happens under KERNEL_LOCK() so we know for sure that the
interface attached to a route entry is valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.182 2015/11/09 10:26:26 mpi Exp $	*/
d761 1
a761 1
					rt->rt_ifp = ifa->ifa_ifp;
@


1.182
log
@Rewrite rtalloc(9) to consider RTF_GATEWAY entries without valid next-
hop route as invalid.

Previously when such entrie was returned by rtalloc(9) a second route
lookup was done in rt_checkgate() very late in the journey of a packet.

In other words a single rtalloc(9) call can now result in multiple
route lookups if a RTF_GATEWAY entry is returned.

This is a step towards always calling L2 output functions with valid
destination information.

Tested by various including jmc@@, naddy@@, Hrvoje Popovski
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.181 2015/11/02 14:40:09 mpi Exp $	*/
d753 3
a755 2
					rt->rt_ifp->if_rtrequest(
					    rt->rt_ifp, RTM_DELETE, rt);
d757 3
a760 1
					ifa->ifa_refcnt++;
d764 1
a764 1
					rt_if_linkstate_change(rt, rt->rt_ifp,
d821 6
a826 1
			rt->rt_ifp->if_rtrequest(rt->rt_ifp, RTM_ADD, rt);
d831 1
a831 2
				rt->rt_labelid =
				    rtlabel_name2id(rtlabel);
@


1.181
log
@Merge rtable_mpath_match() into rtable_lookup().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.180 2015/10/30 09:39:42 bluhm Exp $	*/
d748 2
a749 3
			if (info.rti_info[RTAX_GATEWAY] != NULL &&
			    (error = rt_setgate(rt, info.rti_info[RTAX_GATEWAY],
			     tableid)))
@


1.180
log
@Rename rtrequest1() to rtrequest().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.179 2015/10/25 14:41:09 claudio Exp $	*/
d623 1
d625 22
a646 4
		    info.rti_info[RTAX_NETMASK]);
		if (rt == NULL) {
			error = ESRCH;
			goto flush;
d648 1
a648 3
#ifndef SMALL_KERNEL
		/* First find the right priority. */
		rt = rtable_mpath_match(tableid, rt, NULL, prio);
a652 32


		/*
		 * For RTM_CHANGE/LOCK, if we got multipath routes,
		 * a matching RTAX_GATEWAY is required.
		 * OR
		 * If a gateway is specified then RTM_GET and
		 * RTM_LOCK must match the gateway no matter
		 * what even in the non multipath case.
		 */
		if ((rt->rt_flags & RTF_MPATH) ||
		    (info.rti_info[RTAX_GATEWAY] && rtm->rtm_type !=
		     RTM_CHANGE)) {
			rt = rtable_mpath_match(tableid, rt,
			    info.rti_info[RTAX_GATEWAY], prio);
			if (rt == NULL) {
				error = ESRCH;
				goto flush;
			}
			/*
			 * Only RTM_GET may use an empty gateway
			 * on multipath routes
			 */
			if (info.rti_info[RTAX_GATEWAY] == NULL &&
			    rtm->rtm_type != RTM_GET) {
			    	rtfree(rt);
				rt = NULL;
				error = ESRCH;
				goto flush;
			}
		}
#endif
@


1.179
log
@Be more consisten with rtmsgs. Always set rtm_index (even in the RTM_GET
case) and always set rtm_pid to the pid of the requestor (even in the
sysctl code path).
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.178 2015/10/25 11:58:11 mpi Exp $	*/
d600 1
a600 1
		error = rtrequest1(RTM_ADD, &info, prio, &saved_nrt, tableid);
d612 1
a612 1
		error = rtrequest1(RTM_DELETE, &info, prio, &rt, tableid);
@


1.178
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.177 2015/10/25 10:05:09 bluhm Exp $	*/
a716 1
				rtm->rtm_index = ifp->if_index;
d737 1
d1251 1
@


1.177
log
@Instead of doing the the if_get() dance for rt_missmsg(), change the
function to take an interface index.
discussed with mpi@@;  OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.176 2015/10/24 11:58:47 mpi Exp $	*/
d769 2
a770 3
					if (rt->rt_ifa->ifa_rtrequest)
						rt->rt_ifa->ifa_rtrequest(
						    RTM_DELETE, rt);
d834 1
a834 2
			if (rt->rt_ifa && rt->rt_ifa->ifa_rtrequest)
				rt->rt_ifa->ifa_rtrequest(RTM_ADD, rt);
@


1.176
log
@Some rt_ifp to rt_ifidx conversions.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.175 2015/10/23 13:41:41 bluhm Exp $	*/
d1078 2
a1079 2
rt_missmsg(int type, struct rt_addrinfo *rtinfo, int flags,
    struct ifnet *ifp, int error, u_int tableid)
d1095 1
a1095 2
	if (ifp != NULL)
		rtm->rtm_index = ifp->if_index;
@


1.175
log
@It was possible to create a gateway route pointing to another gateway
route by changing the gateway.  Despite the error message when doing
so, the route did actually change.  The gateway is modified by
rt_setgate(), the error is created by rt_getifa().  Do these
operations the other way around.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.174 2015/10/23 10:22:29 claudio Exp $	*/
d606 1
a606 1
			rtm->rtm_index = saved_nrt->rt_ifp->if_index;
d708 2
a709 2
			if (rtm->rtm_addrs & (RTA_IFP | RTA_IFA) &&
			    (ifp = rt->rt_ifp) != NULL) {
d719 1
d832 1
a832 1
			rtm->rtm_index = rt->rt_ifp->if_index;
d1203 1
d1228 3
a1230 2
	if (rt->rt_ifp) {
		info.rti_info[RTAX_IFP] = sdltosa(rt->rt_ifp->if_sadl);
d1232 1
a1232 1
		if (rt->rt_ifp->if_flags & IFF_POINTOPOINT)
d1235 1
d1259 1
a1259 1
		rtm->rtm_index = rt->rt_ifp->if_index;
@


1.174
log
@Introduce a new sysctl NET_RT_IFNAMES that returns only ifnames to ifindex
mappings. This will be used by if_nameindex(3), if_nametoindex(3) and
if_indextoname(3) soon to fix the issues in pledge because of inet6 link
local addressing.
OK mpi@@ benno@@ deraadt@@
The libc version will follow soon so better start updating your kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.173 2015/10/22 17:19:38 mpi Exp $	*/
a749 4
			if (info.rti_info[RTAX_GATEWAY] != NULL &&
			    (error = rt_setgate(rt, info.rti_info[RTAX_GATEWAY],
			     tableid)))
				goto flush;
d751 2
a752 1
			 * new gateway could require new ifaddr, ifp;
d754 1
a754 1
			 * by ll sockaddr when protocol address is ambiguous
d762 4
@


1.173
log
@Use only one refcounting mechanism for route entries.

ok bluhm@@, dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.172 2015/10/22 15:37:47 bluhm Exp $	*/
d105 3
d1327 28
a1384 1

d1420 3
@


1.172
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.171 2015/09/21 11:27:08 mpi Exp $	*/
d1249 2
a1250 1
		rtm->rtm_rmx.rmx_refcnt = rt->rt_refcnt;
@


1.171
log
@Pass the correct variable to free(9) and while here add the size.

From David Hill, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.170 2015/09/11 16:58:00 mpi Exp $	*/
d75 1
d707 1
a707 2
				info.rti_info[RTAX_IFP] =
					(struct sockaddr *)ifp->if_sadl;
d1147 1
a1147 1
	info.rti_info[RTAX_IFP] = (struct sockaddr *)ifp->if_sadl;
d1223 1
a1223 2
		info.rti_info[RTAX_IFP] =
		    (struct sockaddr *)rt->rt_ifp->if_sadl;
d1277 1
a1277 1
		info.rti_info[RTAX_IFP] = (struct sockaddr *)ifp->if_sadl;
@


1.170
log
@Introduce rtref(9) use it in rtable_lookup() before returning a route
entry.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.169 2015/08/24 22:11:33 mpi Exp $	*/
d169 1
a169 1
			free(rp, M_PCB, 0);
@


1.169
log
@Always increment the reference counter of the returned route entry in
rtrequest1(9).

This simplifies rtfree(9) dances and will prevent another CPU to free
the entry before we're done with it as soon as routing functions can
be executed in parallel.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.168 2015/08/19 13:27:38 bluhm Exp $	*/
d657 1
a663 1
		rt->rt_refcnt++;
@


1.168
log
@Convert all calls to rtrequest1() and the following error check
into a common pattern.  In the man page clarify the usage of the
returned route.
OK mpi@@ mikeb@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.167 2015/08/17 09:46:26 mpi Exp $	*/
d596 1
a596 2
		error = rtrequest1(rtm->rtm_type, &info, prio, &saved_nrt,
		    tableid);
d608 2
a609 4
		error = rtrequest1(rtm->rtm_type, &info, prio, &saved_nrt,
		    tableid);
		if (error == 0) {
			(rt = saved_nrt)->rt_refcnt++;
a610 1
		}
@


1.167
log
@Convert two rt->rt_refcnt-- into rtfree(9) making sure the route entry
is freed when we no longer need it.

In this case both code paths are executed in process context and thus
serialized by the KERNEL_LOCK.  Since we are adding a route entry to
the table in both cases, rtfree(9) will not actually free the entry
because it is still RT_VALID.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.166 2015/07/18 21:58:06 mpi Exp $	*/
d598 1
a598 1
		if (error == 0 && saved_nrt) {
@


1.166
log
@NET_RT_DUMP is dumb and tries to iterates over all possible AF tables
of a given rtable if none is specified.  In this case do not return an
error if a table is missing for one of the ~30 funky AF defines we
have in <sys/socket.h>

Breakage found by and fix discussed with claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.165 2015/07/18 15:51:16 mpi Exp $	*/
a600 1
			saved_nrt->rt_refcnt--;
d605 1
@


1.165
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.164 2015/07/18 00:02:30 phessler Exp $	*/
d1366 2
@


1.164
log
@On systems with a full routing table (550k+), we often want to be able to
look at the routes with a priority, or to display all routes that do not
have a specific priority (normally, don't show bgp).

OK mpi@@ benno@@
previous versions OK deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.163 2015/07/16 18:17:27 claudio Exp $	*/
a447 1
	struct radix_node_head	*rnh;
d619 1
a619 2
		rnh = rtable_get(tableid, info.rti_info[RTAX_DST]->sa_family);
		if (rnh == NULL) {
d623 2
a624 2
		rt = rt_lookup(info.rti_info[RTAX_DST],
		    info.rti_info[RTAX_NETMASK], tableid);
d630 22
a651 4
		if (rn_mpath_capable(rnh)) {
			/* first find the right priority */
			rt = rt_mpath_matchgate(rt, NULL, prio);
			if (!rt) {
d656 2
a657 6
			 * For RTM_CHANGE/LOCK, if we got multipath routes,
			 * a matching RTAX_GATEWAY is required.
			 * OR
			 * If a gateway is specified then RTM_GET and
			 * RTM_LOCK must match the gateway no matter
			 * what even in the non multipath case.
d659 5
a663 19
			if ((rt->rt_flags & RTF_MPATH) ||
			    (info.rti_info[RTAX_GATEWAY] && rtm->rtm_type !=
			    RTM_CHANGE)) {
				rt = rt_mpath_matchgate(rt,
				    info.rti_info[RTAX_GATEWAY], prio);
				if (!rt) {
					error = ESRCH;
					goto flush;
				}
				/*
				 * only RTM_GET may use an empty gateway
				 * on multipath routes
				 */
				if (!info.rti_info[RTAX_GATEWAY] &&
				    rtm->rtm_type != RTM_GET) {
					rt = NULL;
					error = ESRCH;
					goto flush;
				}
d777 1
a777 2
					rt_if_linkstate_change(
					    (struct radix_node *)rt, rt->rt_ifp,
d1197 1
a1197 1
sysctl_dumpentry(struct radix_node *rn, void *v, u_int id)
a1199 1
	struct rtentry		*rt = (struct rtentry *)rn;
a1330 1
	struct radix_node_head	*rnh;
d1361 6
a1366 5
		for (i = 1; i <= AF_MAX; i++)
			if ((rnh = rtable_get(tableid, i)) != NULL &&
			    (af == 0 || af == i) &&
			    (error = (*rnh->rnh_walktree)(rnh,
			    sysctl_dumpentry, &w)))
d1368 1
@


1.163
log
@Fix rn_match and there for the expoerted lookup functions in radix.c
to never return the internal RNF_ROOT nodes. This removes the checks
in the callee to verify that not an RNF_ROOT node was returned.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.162 2015/07/15 22:16:42 deraadt Exp $	*/
d1213 13
@


1.162
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.161 2015/06/30 15:30:17 mpi Exp $	*/
a445 1
	struct radix_node	*rn = NULL;
d627 1
a627 2
		rn = (struct radix_node *)rt;
		if (rn == NULL || (rn->rn_flags & RNF_ROOT) != 0) {
a628 1
			rt = NULL;
a666 1
			rn = (struct radix_node *)rt;
@


1.161
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.160 2015/06/16 11:09:40 mpi Exp $	*/
d311 1
a311 2
			if (desync_mbuf)
				m_freem(desync_mbuf);
@


1.160
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.159 2015/05/13 10:42:46 jsg Exp $	*/
d405 1
a405 1
			if ((n = m_copy(m, 0, (int)M_COPYALL)) != NULL) {
@


1.159
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.158 2015/05/05 09:41:43 mpi Exp $	*/
d984 1
a984 1
	m->m_pkthdr.rcvif = NULL;
@


1.158
log
@Flag user specified routes with an AF_LINK gateway as RTF_LLINFO.

This makes ND6 and ARP layers happy since they both check for this flag,
but is was redundant to provide route(8)'s "-llinfo" option when adding
a l2 route.

RTF_LLINFO is clearly redundant for userland tools, so only allow the
kernel to set it.

ok benno@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.157 2015/02/11 23:34:43 mpi Exp $	*/
d307 1
a307 1
		    desync_mbuf, (struct mbuf *)0) != 0)) {
d408 1
a408 1
				    n, (struct mbuf *)0) == 0) {
d429 1
a429 1
		    m, (struct mbuf *)0) == 0) {
d471 1
a471 1
	if (m == 0 || ((m->m_len < sizeof(int32_t)) &&
d981 1
a981 1
	if (m == 0)
d1095 1
a1095 1
	if (m == 0)
d1124 1
a1124 1
	if (m == 0)
d1191 1
a1191 1
	if (m == 0)
@


1.157
log
@Do not store the key and the gateway of a route entry in the same chunk
of memory.

The key (destination) is only set once, when the route is inserted in
the routing table, and does not need to change afterward.  The gateway
might change and rt_setgate() will do all the checks for you.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.156 2015/01/13 12:14:00 mpi Exp $	*/
d586 6
@


1.156
log
@Restore sending RTM_ADD and RTM_DELETE messages to userland for every
route created/deleted with rt_ifa_add(9)/rt_ifa_del(9), not only for
RTF_LOCAL routes.

Regression introduced in r1.172 when restoring the original behavior
of RTM_NEWADDR/RTM_RTM_DELADDR reported by Florian Riehm.

Joint work with Florian Riehm, with input from and ok bluhm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.155 2014/12/19 18:57:17 bluhm Exp $	*/
d753 2
a754 2
			    (error = rt_setgate(rt, rt_key(rt),
			    info.rti_info[RTAX_GATEWAY], tableid)))
@


1.155
log
@Do not report an EDQUOT "Disk quota exceeded" error from the routing
code.  Instead generate an ENOBUFS "No buffer space available" error
at the malloc(9) failure in rt_setgate(9) and propagate it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.154 2014/12/11 08:55:10 mpi Exp $	*/
d1140 1
a1140 1
rt_newaddrmsg(int cmd, struct ifaddr *ifa, int error, struct rtentry *rt)
d1142 3
d1146 1
a1146 4
	struct sockaddr		*sa = NULL;
	int			 pass;
	struct mbuf		*m = NULL;
	struct ifnet		*ifp = ifa->ifa_ifp;
a1149 6
	for (pass = 1; pass < 3; pass++) {
		bzero(&info, sizeof(info));
		if ((cmd == RTM_ADD && pass == 1) ||
		    (cmd == RTM_DELETE && pass == 2)) {
			struct ifa_msghdr	*ifam;
			int			 ncmd;
d1151 13
a1163 4
			if (cmd == RTM_ADD)
				ncmd = RTM_NEWADDR;
			else
				ncmd = RTM_DELADDR;
d1165 5
a1169 42
			info.rti_info[RTAX_IFA] = sa = ifa->ifa_addr;
			info.rti_info[RTAX_IFP] =
			    (struct sockaddr *)ifp->if_sadl;
			info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;
			info.rti_info[RTAX_BRD] = ifa->ifa_dstaddr;
			if ((m = rt_msg1(ncmd, &info)) == NULL)
				continue;
			ifam = mtod(m, struct ifa_msghdr *);
			ifam->ifam_index = ifp->if_index;
			ifam->ifam_metric = ifa->ifa_metric;
			ifam->ifam_flags = ifa->ifa_flags;
			ifam->ifam_addrs = info.rti_addrs;
			ifam->ifam_tableid = ifp->if_rdomain;
		}
		if ((cmd == RTM_ADD && pass == 2) ||
		    (cmd == RTM_DELETE && pass == 1)) {
			struct rt_msghdr *rtm;
			struct sockaddr_rtlabel sa_rl;
			
			if (rt == 0)
				continue;
			info.rti_info[RTAX_NETMASK] = rt_mask(rt);
			info.rti_info[RTAX_DST] = sa = rt_key(rt);
			info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
			info.rti_info[RTAX_LABEL] =
			    rtlabel_id2sa(rt->rt_labelid, &sa_rl);
			if ((m = rt_msg1(cmd, &info)) == NULL)
				continue;
			rtm = mtod(m, struct rt_msghdr *);
			rtm->rtm_index = ifp->if_index;
			rtm->rtm_flags |= rt->rt_flags;
			rtm->rtm_priority = rt->rt_priority & RTP_MASK;
			rtm->rtm_errno = error;
			rtm->rtm_addrs = info.rti_addrs;
			rtm->rtm_tableid = ifp->if_rdomain;
		}
		if (sa == NULL)
			route_proto.sp_protocol = 0;
		else
			route_proto.sp_protocol = sa->sa_family;
		route_input(m, &route_proto, &route_src, &route_dst);
	}
@


1.154
log
@Do not change the interface of a route if it is not intended.

When a route change message is submitted, looks for a new ifa to attach
the route only if a gateway, an ifp or an ifa has been specified.

Fix a regression reported by Florian Riehm, ok bluhm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.153 2014/12/05 15:50:04 mpi Exp $	*/
d753 2
a754 3
			    rt_setgate(rt, rt_key(rt),
			    info.rti_info[RTAX_GATEWAY], tableid)) {
				error = EDQUOT;
a755 1
			}
@


1.153
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.152 2014/08/12 13:52:08 mpi Exp $	*/
a743 7
			/*
			 * new gateway could require new ifaddr, ifp;
			 * flags may also be different; ifp may be specified
			 * by ll sockaddr when protocol address is ambiguous
			 */
			if ((error = rt_getifa(&info, tableid)) != 0)
				goto flush;
d758 11
a768 1
			ifa = info.rti_ifa;
@


1.152
log
@route_cb is internal to rtsock.c
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.151 2014/08/11 11:59:05 mpi Exp $	*/
d75 1
@


1.151
log
@Put back the checks about RTF_LOCAL routes now that userland tools are
aware of them.

Original commit message was:

Reserve the highest route priority for kernel-managed routes and prevent
userland from playing with the local and broadcast flags.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.150 2014/07/29 12:18:41 mpi Exp $	*/
d111 9
@


1.150
log
@Revert the checks about RTF_LOCAL routes.

Even if in the end we would like to be more strict about what userland
can do with kernel-managed route entries, most of the tools out there
are not yet ready for this.  Since RTF_LOCAL routes are for the moment
just like RTF_LLINFO routes without expire timer, allow userland tools
to remove/modify them.  In case they are missing, the good old cloning
mechanism will recreate what you need.

bluhm@@ and deraadt@@ agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.149 2014/07/12 18:44:22 tedu Exp $	*/
d536 6
d548 2
a549 1
		if (rtm->rtm_priority > RTP_MAX) {
@


1.149
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.148 2014/07/08 17:19:25 deraadt Exp $	*/
a535 6
	/* Do not let userland play with kernel-only flags. */
	if ((rtm->rtm_flags & (RTF_LOCAL|RTF_BROADCAST)) != 0) {
		error = EINVAL;
		goto fail;
	}

d542 1
a542 2
		if (rtm->rtm_priority > RTP_MAX ||
		    rtm->rtm_priority == RTP_LOCAL) {
@


1.148
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.147 2014/05/31 15:36:44 claudio Exp $	*/
d159 1
a159 1
			free(rp, M_PCB);
d721 1
a721 1
				free(rtm, M_RTABLE);
d808 1
a808 1
					free(rt->rt_llinfo, M_TEMP);
d866 1
a866 1
			free(rtm, M_RTABLE);
d881 1
a881 1
		free(rtm, M_RTABLE);
d1034 1
a1034 1
				free(rw->w_tmem, M_RTABLE);
d1406 1
a1406 1
	free(w.w_tmem, M_RTABLE);
@


1.147
log
@Unbreak RTM_CHANGE. Unlike RTM_LOCK or RTM_GET it is OK to pass in a
new gateway for RTM_CHANGE if the route is not a multipath route.
Fixes issues found by benno@@, OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.146 2014/05/27 19:38:15 claudio Exp $	*/
d67 1
a72 3

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>
@


1.146
log
@Big refactoring of the radix code (mainly rn_addroute but also part
of rn_delete was changed). The mpath code gets a much better
rn_mpath_next() function that allows looping through the dupedkey list
based on prio, any or only active routes. This solves the issues seen
with failed deletes of down routes.
Commit this now so that it gets tested. Both sthen@@ and blambert@@ agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.145 2014/05/27 09:39:58 mpi Exp $	*/
a621 7
		/*
		 * for RTM_CHANGE/LOCK, if we got multipath routes,
		 * we require users to specify a matching RTAX_GATEWAY.
		 *
		 * for RTM_GET, info.rti_info[RTAX_GATEWAY] is optional
		 * even with multipath.
		 */
d623 2
a624 2
			rt = rt_mpath_matchgate(rt,
			    info.rti_info[RTAX_GATEWAY], prio);
a628 1

d630 6
a635 2
			 * only RTM_GET may use an empty gateway
			 * on multipath routes
d637 19
a655 6
			if (!info.rti_info[RTAX_GATEWAY] &&
			    rt->rt_flags & RTF_MPATH &&
			    rtm->rtm_type != RTM_GET) {
				rt = NULL;
				error = ESRCH;
				goto flush;
@


1.145
log
@Reserve the highest route priority for kernel-managed routes and prevent
userland from playing with the local and broadcast flags.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.144 2014/05/16 08:21:54 mpi Exp $	*/
a627 2
		 * if it is NULL the first match is returned (no need to
		 * call rt_mpath_matchgate).
d630 3
a632 5
			/* first find correct priority bucket */
			rn = rn_mpath_prio(rn, prio);
			rt = (struct rtentry *)rn;
			if (prio != RTP_ANY &&
			    (rt->rt_priority & RTP_MASK) != prio) {
a633 1
				rt->rt_refcnt++;
d637 8
a644 25
			/* if multipath routes */
			if (rt_mpath_next(rt)) { /* XXX ignores down routes */
				if (info.rti_info[RTAX_GATEWAY] != NULL) {
					rt = rt_mpath_matchgate(rt,
					    info.rti_info[RTAX_GATEWAY], prio);
				} else if (rtm->rtm_type != RTM_GET) {
					/*
					 * only RTM_GET may use an empty
					 * gateway  on multipath ...
					 */
					rt = NULL;
				}
			} else if ((info.rti_info[RTAX_GATEWAY] != NULL) &&
			    (rtm->rtm_type == RTM_GET ||
			     rtm->rtm_type == RTM_LOCK)) {
				/*
				 * ... but if a gateway is specified RTM_GET
				 * and RTM_LOCK must match the gateway no matter
				 * what.
				 */
				rt = rt_mpath_matchgate(rt,
				    info.rti_info[RTAX_GATEWAY], prio);
			}

			if (!rt) {
@


1.144
log
@Do not put any link-layer address on the per-ifp lists or on the RB-
Tree.

Since interfaces only support one link-layer address accessible via the
if_sadl member, there's no need to have it elsewhere.  This improves
various address lookups because the first element of the list, the link-
layer address, won't necessarily be discarded.

Finally remove the empty netmask associated to every link-layer address.
This hack was needed to (ab)use the address & netmask comparison code to
do a strcmp() on the interface name embedded in the sdl_data field.

ok henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.143 2014/04/25 10:41:09 mpi Exp $	*/
d537 7
d550 2
a551 1
		if (rtm->rtm_priority > RTP_MAX) {
@


1.143
log
@Remove rti_ifp from rt_addrinfo, one less ifp pointer, say yay!

This pointer was only needed by rt_getifa() to find an address, so
turn it into a local variable.

ok henning@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.142 2014/03/18 10:47:34 mpi Exp $	*/
d1320 1
a1320 2
			if (ifa->ifa_addr->sa_family == AF_LINK)
				continue;
@


1.142
log
@Rename rt_gettable() into rtable_get(), swap its arguments to be
coherent with the existing rtable_* functions and document it.

While here fix some other manpage glitches pointed out by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.141 2014/03/17 10:24:40 mpi Exp $	*/
d771 1
a771 1
					rt->rt_ifp = info.rti_ifp;
@


1.141
log
@Remove pre-rt_getifa() code to find the address descriptor (ifa) related
to a route entry, no need to do the work twice.

This chunk should have been deleted when post-4.4BSD changes from BSD/OS
4.2 were merged more than 10 years ago.

While here properly indent the following block.

tested by chris@@, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.140 2014/03/12 12:03:55 mpi Exp $	*/
d600 1
a600 1
		rnh = rt_gettable(info.rti_info[RTAX_DST]->sa_family, tableid);
d1384 1
a1384 1
			if ((rnh = rt_gettable(i, tableid)) != NULL &&
@


1.140
log
@RTAX_IFP points to the "struct sockaddr_dl" corresponding to the
link-layer address of an interface.  This ugly structure is used
to export the interface's name and index, not only the link-layer
address as its name might suggest.

So instead reaching this descriptor by forcing and abusing the
position of the link-layer "struct ifaddr" in the per-interface
list, use the if_sadl pointer directly.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.139 2014/02/13 22:01:50 bluhm Exp $	*/
d762 1
a762 13
			if (info.rti_info[RTAX_IFP] != NULL && (ifa =
			    ifa_ifwithnet(info.rti_info[RTAX_IFP], tableid)) &&
			    (ifp = ifa->ifa_ifp) && (info.rti_info[RTAX_IFA] ||
			    info.rti_info[RTAX_GATEWAY]))
				ifa = ifaof_ifpforaddr(info.rti_info[RTAX_IFA] ?
				    info.rti_info[RTAX_IFA] :
				    info.rti_info[RTAX_GATEWAY], ifp);
			else if ((info.rti_info[RTAX_IFA] != NULL && (ifa =
			    ifa_ifwithaddr(info.rti_info[RTAX_IFA], tableid)))||
			    (info.rti_info[RTAX_GATEWAY] != NULL && (ifa =
			    ifa_ifwithroute(rt->rt_flags, rt_key(rt),
				    info.rti_info[RTAX_GATEWAY], tableid))))
				ifp = ifa->ifa_ifp;
d764 8
a771 8
				struct ifaddr *oifa = rt->rt_ifa;
				if (oifa != ifa) {
				    if (oifa && oifa->ifa_rtrequest)
					oifa->ifa_rtrequest(RTM_DELETE, rt);
				    ifafree(rt->rt_ifa);
				    rt->rt_ifa = ifa;
				    ifa->ifa_refcnt++;
				    rt->rt_ifp = ifp;
d773 4
a776 3
				    /* recheck link state after ifp change */
				    rt_if_linkstate_change(
					(struct radix_node *)rt, ifp, tableid);
@


1.139
log
@Replace hand crafted routing label code with the rtlabel_id2sa()
function call.  Name sockaddr_rtlabel variable sa_rl everywhere.
OK mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.138 2014/02/12 13:01:50 henning Exp $	*/
d709 1
a709 1
				    TAILQ_FIRST(&ifp->if_addrlist)->ifa_addr;
d1171 1
a1171 1
			    TAILQ_FIRST(&ifp->if_addrlist)->ifa_addr;
d1259 1
a1259 1
		    TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
d1312 2
a1313 4
		ifa = TAILQ_FIRST(&ifp->if_addrlist);
		if (!ifa)
			continue;
		info.rti_info[RTAX_IFP] = ifa->ifa_addr;
d1330 3
a1332 1
		while ((ifa = TAILQ_NEXT(ifa, ifa_list)) != NULL) {
@


1.138
log
@Add rtlabel to rt_newaddrmsg, From: Florian Riehm <mail at friehm dot de>
ok bluhm claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.137 2014/01/22 06:28:09 claudio Exp $	*/
d449 1
a449 1
	struct sockaddr_rtlabel	 sa_rt;
a452 1
	const char		*label;
d688 2
a689 11

			if (rt->rt_labelid) {
				bzero(&sa_rt, sizeof(sa_rt));
				sa_rt.sr_len = sizeof(sa_rt);
				label = rtlabel_id2name(rt->rt_labelid);
				if (label != NULL)
					strlcpy(sa_rt.sr_label, label,
					    sizeof(sa_rt.sr_label));
				info.rti_info[RTAX_LABEL] =
				    (struct sockaddr *)&sa_rt;
			}
d1249 1
a1249 2
	struct sockaddr_rtlabel	 sa_rt;
	const char		*label;
d1264 1
a1264 11
	if (rt->rt_labelid) {
		bzero(&sa_rt, sizeof(sa_rt));
		sa_rt.sr_len = sizeof(sa_rt);
		label = rtlabel_id2name(rt->rt_labelid);
		if (label != NULL) {
			strlcpy(sa_rt.sr_label, label,
			    sizeof(sa_rt.sr_label));
			info.rti_info[RTAX_LABEL] =
			    (struct sockaddr *)&sa_rt;
		}
	}
@


1.137
log
@Remove genmask support from the kernel. rtmsgs with RTA_GENMASK set will
now cause a EINVAL. The RTA_GENMASK and RTAX_GENMASK defines are kept for
compatibility reasons.
OK benno@@ and agreed by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.136 2014/01/21 10:08:02 mpi Exp $	*/
d1196 1
d1203 2
@


1.136
log
@Substitute crazy defines and convert some 0 to NULL.

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.135 2014/01/20 22:11:42 bluhm Exp $	*/
d563 2
a564 1
	     info.rti_info[RTAX_GATEWAY]->sa_family >= AF_MAX)) {
a567 15
	if (info.rti_info[RTAX_GENMASK] != NULL) {
		struct radix_node	*t;
		t = rn_addmask(info.rti_info[RTAX_GENMASK], 0, 1);
		if (t && info.rti_info[RTAX_GENMASK]->sa_len >=
		    ((struct sockaddr *)t->rn_key)->sa_len &&
		    memcmp((caddr_t *)info.rti_info[RTAX_GENMASK] + 1,
		    (caddr_t *)t->rn_key + 1,
		    ((struct sockaddr *)t->rn_key)->sa_len) - 1)
			info.rti_info[RTAX_GENMASK] =
			    (struct sockaddr *)(t->rn_key);
		else {
			error = ENOBUFS;
			goto flush;
		}
	}
a583 1
			saved_nrt->rt_genmask = info.rti_info[RTAX_GENMASK];
a688 1
			info.rti_info[RTAX_GENMASK] = rt->rt_genmask;
a854 2
			if (info.rti_info[RTAX_GENMASK])
				rt->rt_genmask = info.rti_info[RTAX_GENMASK];
d1044 1
a1044 1
		if ((sa = rtinfo->rti_info[i]) == 0)
a1264 1
	info.rti_info[RTAX_GENMASK] = rt->rt_genmask;
@


1.135
log
@Get rid of the old routing message version 4 transition code before
5.5 release.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.134 2014/01/19 11:20:46 claudio Exp $	*/
a104 9
/* Sleazy use of local variables throughout file, warning!!!! */
#define dst	info.rti_info[RTAX_DST]
#define gate	info.rti_info[RTAX_GATEWAY]
#define netmask	info.rti_info[RTAX_NETMASK]
#define genmask	info.rti_info[RTAX_GENMASK]
#define ifpaddr	info.rti_info[RTAX_IFP]
#define ifaaddr	info.rti_info[RTAX_IFA]
#define brdaddr	info.rti_info[RTAX_BRD]

d463 1
a463 1
	dst = NULL;	/* for error handling (goto flush) */
d560 4
a563 2
	if (dst == 0 || dst->sa_family >= AF_MAX ||
	    (gate != 0 && gate->sa_family >= AF_MAX)) {
d567 1
a567 1
	if (genmask) {
d569 2
a570 2
		t = rn_addmask(genmask, 0, 1);
		if (t && genmask->sa_len >=
d572 2
a573 1
		    memcmp((caddr_t *)genmask + 1, (caddr_t *)t->rn_key + 1,
d575 2
a576 1
			genmask = (struct sockaddr *)(t->rn_key);
d588 1
a588 1
		if (gate == 0) {
d598 1
a598 1
			saved_nrt->rt_genmask = genmask;
d616 2
a617 1
		if ((rnh = rt_gettable(dst->sa_family, tableid)) == NULL) {
d621 2
a622 1
		rt = rt_lookup(dst, netmask, tableid);
d634 4
a637 3
		 * for RTM_GET, gate is optional even with multipath.
		 * if gate == NULL the first match is returned.
		 * (no need to call rt_mpath_matchgate if gate == NULL)
d652 4
a655 3
				if (gate)
					rt = rt_mpath_matchgate(rt, gate, prio);
				else if (rtm->rtm_type != RTM_GET)
d657 2
a658 2
					 * only RTM_GET may use an empty gate
					 * on multipath ...
d661 4
a664 2
			} else if (gate && (rtm->rtm_type == RTM_GET ||
			    rtm->rtm_type == RTM_LOCK))
d666 2
a667 2
				 * ... but if a gate is specified RTM_GET
				 * and RTM_LOCK must match the gate no matter
d670 3
a672 1
				rt = rt_mpath_matchgate(rt, gate, prio);
d692 2
a693 1
		if (rtm->rtm_type != RTM_GET && !rt_mask(rt) != !netmask) {
d701 4
a704 4
			dst = rt_key(rt);
			gate = rt->rt_gateway;
			netmask = rt_mask(rt);
			genmask = rt->rt_genmask;
d730 2
a731 2
			ifpaddr = 0;
			ifaaddr = 0;
d734 1
a734 1
				ifpaddr =
d736 1
a736 1
				ifaaddr = rt->rt_ifa->ifa_addr;
d738 2
a739 1
					brdaddr = rt->rt_ifa->ifa_dstaddr;
d741 1
a741 1
					brdaddr = 0;
d775 1
a775 1
			if (gate)
d777 3
a779 1
				    bcmp(rt->rt_gateway, gate, gate->sa_len))
d781 4
a784 1
			if (gate && rt_setgate(rt, rt_key(rt), gate, tableid)) {
d788 12
a799 9
			if (ifpaddr &&
			    (ifa = ifa_ifwithnet(ifpaddr, tableid)) &&
			    (ifp = ifa->ifa_ifp) && (ifaaddr || gate))
				ifa = ifaof_ifpforaddr(ifaaddr ? ifaaddr : gate,
				    ifp);
			else if ((ifaaddr &&
			    (ifa = ifa_ifwithaddr(ifaaddr, tableid))) ||
			    (gate && (ifa = ifa_ifwithroute(rt->rt_flags,
			    rt_key(rt), gate, tableid))))
d871 2
a872 2
			if (genmask)
				rt->rt_genmask = genmask;
d880 2
a881 1
			if_group_routechange(dst, netmask);
d901 2
a902 2
	if (dst)
		route_proto.sp_protocol = dst->sa_family;
d1197 5
a1201 4
			ifaaddr = sa = ifa->ifa_addr;
			ifpaddr = TAILQ_FIRST(&ifp->if_addrlist)->ifa_addr;
			netmask = ifa->ifa_netmask;
			brdaddr = ifa->ifa_dstaddr;
d1217 3
a1219 3
			netmask = rt_mask(rt);
			dst = sa = rt_key(rt);
			gate = rt->rt_gateway;
d1280 4
a1283 4
	dst = rt_key(rt);
	gate = rt->rt_gateway;
	netmask = rt_mask(rt);
	genmask = rt->rt_genmask;
d1285 3
a1287 2
		ifpaddr = TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
		ifaaddr = rt->rt_ifa->ifa_addr;
d1289 1
a1289 1
			brdaddr = rt->rt_ifa->ifa_dstaddr;
d1352 1
a1352 1
		ifpaddr = ifa->ifa_addr;
d1368 1
a1368 1
		ifpaddr = 0;
d1372 3
a1374 3
			ifaaddr = ifa->ifa_addr;
			netmask = ifa->ifa_netmask;
			brdaddr = ifa->ifa_dstaddr;
d1390 2
a1391 1
		ifaaddr = netmask = brdaddr = 0;
@


1.134
log
@RTF_MPATH is a flag userland needs to be able to pass in since it is used
to set multipath routes. So since more then 2 month multipath was broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.133 2014/01/10 14:29:08 tedu Exp $	*/
a103 5
#ifdef RTM_OVERSION
struct rt_msghdr *rtmsg_4to5(struct mbuf *, int *);
struct rt_omsghdr *rtmsg_5to4(struct rt_msghdr *);
void rt_ogetmetrics(struct rt_kmetrics *in, struct rt_ometrics *out);
#endif /* RTM_OVERSION */
a485 17
#ifdef RTM_OVERSION
	case RTM_OVERSION:
		if (len < sizeof(struct rt_omsghdr)) {
			error = EINVAL;
			goto fail;
		}
		if (len > RTM_MAXSIZE) {
			error = EMSGSIZE;
			goto fail;
		}
		rtm = rtmsg_4to5(m, &len);
		if (rtm == 0) {
			error = ENOBUFS;
			goto fail;
		}
		break;
#endif /* RTM_OVERSION */
a907 12
#ifdef RTM_OVERSION
		if (vers == RTM_OVERSION) {
			struct rt_omsghdr *ortm;

			if ((ortm = rtmsg_5to4(rtm)) == NULL ||
			    m_copyback(m, 0, ortm->rtm_msglen, ortm, M_NOWAIT)){
				m_freem(m);
				m = NULL;
			} else if (m->m_pkthdr.len > ortm->rtm_msglen)
				m_adj(m, ortm->rtm_msglen - m->m_pkthdr.len);
		} else
#endif /* RTM_OVERSION */
a942 12
#ifdef RTM_OVERSION
void
rt_ogetmetrics(struct rt_kmetrics *in, struct rt_ometrics *out)
{
	bzero(out, sizeof(*out));
	out->rmx_locks = in->rmx_locks;
	out->rmx_mtu = in->rmx_mtu;
	out->rmx_expire = (u_int)in->rmx_expire;
	out->rmx_pksent = in->rmx_pksent;
}
#endif /* RTM_OVERSION */

a1038 5
#ifdef RTM_OVERSION
		if (vers == RTM_OVERSION)
			len = sizeof(struct rt_omsghdr);
		else
#endif /* RTM_OVERSION */
a1081 10
#ifdef RTM_OVERSION
	if (cp && vers == RTM_OVERSION) {
		struct rt_omsghdr *rtm = (struct rt_omsghdr *)cp0;

		rtm->rtm_version = RTM_OVERSION;
		rtm->rtm_type = type;
		rtm->rtm_msglen = len;
		rtm->rtm_hdrlen = hlen;
	} else
#endif /* RTM_OVERSION */
a1317 21
#ifdef RTM_OVERSION
	size = rt_msg2(RTM_GET, RTM_OVERSION, &info, NULL, w);
	if (w->w_where && w->w_tmem && w->w_needed <= 0) {
		struct rt_omsghdr *rtm = (struct rt_omsghdr *)w->w_tmem;

		rtm->rtm_flags = rt->rt_flags;
		rtm->rtm_priority = rt->rt_priority & RTP_MASK;
		rt_ogetmetrics(&rt->rt_rmx, &rtm->rtm_rmx);
		rtm->rtm_rmx.rmx_refcnt = rt->rt_refcnt;
		rtm->rtm_index = rt->rt_ifp->if_index;
		rtm->rtm_addrs = info.rti_addrs;
		rtm->rtm_tableid = id;
#ifdef MPLS
		rtm->rtm_mpls = info.rti_mpls;
#endif
		if ((error = copyout(rtm, w->w_where, size)) != 0)
			w->w_where = NULL;
		else
			w->w_where += size;
	}
#endif
a1351 17
#ifdef RTM_OVERSION
		len = rt_msg2(RTM_IFINFO, RTM_OVERSION, &info, 0, w);
		if (w->w_where && w->w_tmem && w->w_needed <= 0) {
			struct if_msghdr *ifm;

			ifm = (struct if_msghdr *)w->w_tmem;
			ifm->ifm_index = ifp->if_index;
			ifm->ifm_tableid = ifp->if_rdomain;
			ifm->ifm_flags = ifp->if_flags;
			ifm->ifm_data = ifp->if_data;
			ifm->ifm_addrs = info.rti_addrs;
			error = copyout(ifm, w->w_where, len);
			if (error)
				return (error);
			w->w_where += len;
		}
#endif /* RTM_OVERSION */
a1372 16
#ifdef RTM_OVERSION
			len = rt_msg2(RTM_NEWADDR, RTM_OVERSION, &info, 0, w);
			if (w->w_where && w->w_tmem && w->w_needed <= 0) {
				struct ifa_msghdr *ifam;

				ifam = (struct ifa_msghdr *)w->w_tmem;
				ifam->ifam_index = ifa->ifa_ifp->if_index;
				ifam->ifam_flags = ifa->ifa_flags;
				ifam->ifam_metric = ifa->ifa_metric;
				ifam->ifam_addrs = info.rti_addrs;
				error = copyout(w->w_tmem, w->w_where, len);
				if (error)
					return (error);
				w->w_where += len;
			}
#endif /* RTM_OVERSION */
a1455 86

#ifdef RTM_OVERSION
struct rt_msghdr *
rtmsg_4to5(struct mbuf *m, int *len)
{
	struct rt_msghdr *rtm;
	struct rt_omsghdr ortm;

	*len += sizeof(struct rt_msghdr) - sizeof(struct rt_omsghdr);
	rtm = malloc(*len, M_RTABLE, M_NOWAIT);
	if (rtm == NULL)
		return (NULL);
	bzero(rtm, sizeof(struct rt_msghdr));
	m_copydata(m, 0, sizeof(struct rt_omsghdr), (caddr_t)&ortm);
	rtm->rtm_msglen = *len;
	rtm->rtm_version = RTM_VERSION;
	rtm->rtm_type = ortm.rtm_type;
	rtm->rtm_hdrlen = sizeof(struct rt_msghdr);

	rtm->rtm_index = ortm.rtm_index;
	rtm->rtm_tableid = ortm.rtm_tableid;
	rtm->rtm_priority = ortm.rtm_priority;
	rtm->rtm_mpls = ortm.rtm_mpls;
	rtm->rtm_addrs = ortm.rtm_addrs;
	rtm->rtm_flags = ortm.rtm_flags;
	rtm->rtm_fmask = ortm.rtm_fmask;
	rtm->rtm_pid = ortm.rtm_pid;
	rtm->rtm_seq = ortm.rtm_seq;
	rtm->rtm_errno = ortm.rtm_errno;
	rtm->rtm_inits = ortm.rtm_inits;

	/* copy just the interesting stuff ignore the rest */
	rtm->rtm_rmx.rmx_pksent = ortm.rtm_rmx.rmx_pksent;
	rtm->rtm_rmx.rmx_expire = (int64_t)ortm.rtm_rmx.rmx_expire;
	rtm->rtm_rmx.rmx_locks = ortm.rtm_rmx.rmx_locks;
	rtm->rtm_rmx.rmx_mtu = ortm.rtm_rmx.rmx_mtu;

	m_copydata(m, sizeof(struct rt_omsghdr),
	    *len - sizeof(struct rt_msghdr),
	    (caddr_t)rtm + sizeof(struct rt_msghdr));

	return (rtm);
}

struct rt_omsghdr *
rtmsg_5to4(struct rt_msghdr *rtm)
{
	struct rt_omsghdr *ortm;
	int len;

	len = rtm->rtm_msglen + sizeof(struct rt_omsghdr) -
	    sizeof(struct rt_msghdr);
	ortm = malloc(len, M_RTABLE, M_NOWAIT);
	if (ortm == NULL)
		return (NULL);
	bzero(ortm, sizeof(struct rt_omsghdr));
	ortm->rtm_msglen = len;
	ortm->rtm_version = RTM_OVERSION;
	ortm->rtm_type = rtm->rtm_type;
	ortm->rtm_hdrlen = sizeof(struct rt_omsghdr);

	ortm->rtm_index = rtm->rtm_index;
	ortm->rtm_tableid = rtm->rtm_tableid;
	ortm->rtm_priority = rtm->rtm_priority;
	ortm->rtm_mpls = rtm->rtm_mpls;
	ortm->rtm_addrs = rtm->rtm_addrs;
	ortm->rtm_flags = rtm->rtm_flags;
	ortm->rtm_fmask = rtm->rtm_fmask;
	ortm->rtm_pid = rtm->rtm_pid;
	ortm->rtm_seq = rtm->rtm_seq;
	ortm->rtm_errno = rtm->rtm_errno;
	ortm->rtm_inits = rtm->rtm_inits;

	/* copy just the interesting stuff ignore the rest */
	ortm->rtm_rmx.rmx_pksent = rtm->rtm_rmx.rmx_pksent;
	ortm->rtm_rmx.rmx_expire = (u_int)rtm->rtm_rmx.rmx_expire;
	ortm->rtm_rmx.rmx_locks = rtm->rtm_rmx.rmx_locks;
	ortm->rtm_rmx.rmx_mtu = rtm->rtm_rmx.rmx_mtu;

	memcpy((caddr_t)ortm + sizeof(struct rt_omsghdr),
	    (caddr_t)rtm + sizeof(struct rt_msghdr),
	    len - sizeof(struct rt_omsghdr));

	return (ortm);
}
#endif /* RTM_OVERSION */
@


1.133
log
@replace the rest of the obsolete radix macros
sprinkle 0 -> NULL where obvious
ok millert mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.132 2014/01/09 21:57:52 tedu Exp $	*/
d571 1
a571 1
	rtm->rtm_flags &= ~(RTF_DONE|RTF_CLONED|RTF_MPATH);
@


1.132
log
@replace Bcopy macro with memmove and memcpy. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.131 2013/11/01 20:09:14 bluhm Exp $	*/
d517 2
a518 2
		R_Malloc(rtm, struct rt_msghdr *, len);
		if (rtm == 0) {
d601 1
a601 1
		    Bcmp((caddr_t *)genmask + 1, (caddr_t *)t->rn_key + 1,
d765 2
a766 2
				R_Malloc(new_rtm, struct rt_msghdr *, len);
				if (new_rtm == 0) {
d771 2
a772 1
				Free(rtm); rtm = new_rtm;
d835 1
a835 1
					rt->rt_llinfo = (caddr_t)
d920 1
a920 2
			if (rtm)
				Free(rtm);
d947 1
a947 1
		Free(rtm);
d1117 1
a1117 2
				if (rw->w_tmem)
					free(rw->w_tmem, M_RTABLE);
d1560 1
a1560 2
	if (w.w_tmem)
		free(w.w_tmem, M_RTABLE);
d1580 1
a1580 1
	R_Malloc(rtm, struct rt_msghdr *, *len);
d1623 1
a1623 1
	R_Malloc(ortm, struct rt_omsghdr *, len);
@


1.131
log
@The old routing messages compatibility code did not work on strict
alignment architectures.  Use m_copydata() instead of mtod().
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.130 2013/10/31 18:10:21 bluhm Exp $	*/
d770 1
a770 1
				Bcopy(rtm, new_rtm, rtm->rtm_msglen);
@


1.130
log
@Convert the route expire timestamp in kernel and routing message
to 64 bit.  Increase the routing message version from 4 to 5.  Add
a small compatibility layer that allows to set routes with old user
land and new kernel.  Old kernel with new user land does not work.

The compatibility layer ist not perfect, but it allows to configure
addresses with old ifconfig and new kernel.  Route get also works
in this setup.  dhclient hangs as messages for interface address
changes with old version are not generated.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.129 2013/10/20 13:21:57 claudio Exp $	*/
d1579 1
a1579 1
	struct rt_omsghdr *ortm;
d1586 1
a1586 1
	ortm = mtod(m, struct rt_omsghdr *);
d1589 1
a1589 1
	rtm->rtm_type = ortm->rtm_type;
d1592 11
a1602 11
	rtm->rtm_index = ortm->rtm_index;
	rtm->rtm_tableid = ortm->rtm_tableid;
	rtm->rtm_priority = ortm->rtm_priority;
	rtm->rtm_mpls = ortm->rtm_mpls;
	rtm->rtm_addrs = ortm->rtm_addrs;
	rtm->rtm_flags = ortm->rtm_flags;
	rtm->rtm_fmask = ortm->rtm_fmask;
	rtm->rtm_pid = ortm->rtm_pid;
	rtm->rtm_seq = ortm->rtm_seq;
	rtm->rtm_errno = ortm->rtm_errno;
	rtm->rtm_inits = ortm->rtm_inits;
d1605 4
a1608 4
	rtm->rtm_rmx.rmx_pksent = ortm->rtm_rmx.rmx_pksent;
	rtm->rtm_rmx.rmx_expire = (int64_t)ortm->rtm_rmx.rmx_expire;
	rtm->rtm_rmx.rmx_locks = ortm->rtm_rmx.rmx_locks;
	rtm->rtm_rmx.rmx_mtu = ortm->rtm_rmx.rmx_mtu;
@


1.129
log
@rt_mpath_next() was always called with 0 in the last argument. So drop it.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.128 2013/10/20 12:35:48 claudio Exp $	*/
d104 5
d471 1
d489 19
a507 1
	switch (mtod(m, struct rt_msghdr *)->rtm_version) {
d930 12
d977 12
d1085 5
d1134 10
d1380 21
d1435 17
d1473 16
d1573 86
@


1.128
log
@Make sure that the RTM_DESYNC message is not filtered out. Also ensure that
rtm_flags and rtm_fmask do not change flags that are kernel specific (e.g.
RTF_CLONED). OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.127 2013/08/28 06:58:57 mpi Exp $	*/
d651 1
a651 1
			if (rt_mpath_next(rt, 0)) {
@


1.127
log
@Remove unused argument from *rtrequest()

ok krw@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.126 2013/05/17 11:13:37 krw Exp $	*/
d371 3
a373 2
		if (rop->msgfilter != 0 && !(rop->msgfilter & (1 <<
		    rtm->rtm_type)))
d547 2
d843 3
a845 3
			if (rtm->rtm_fmask & RTF_FMASK)
				rt->rt_flags = (rt->rt_flags &
				    ~rtm->rtm_fmask) |
@


1.126
log
@Do not attempt to delete the undeletable RNF_ROOT route.

Discovered & fix tested by Peter J Philip.

ok claudio@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.125 2013/03/15 20:45:34 tedu Exp $	*/
d786 1
a786 2
					oifa->ifa_rtrequest(RTM_DELETE, rt,
					    &info);
d851 1
a851 1
				rt->rt_ifa->ifa_rtrequest(RTM_ADD, rt, &info);
@


1.125
log
@change LIST_END to literal NULL for clarity.
ok claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.124 2013/03/07 09:03:16 mpi Exp $	*/
d624 1
@


1.124
log
@Remove the IFAFREE() macro, the ifafree() function it was calling already
check for the reference counter.

ok mikeb@@, miod@@, pelikan@@, kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.123 2012/09/20 20:53:13 blambert Exp $	*/
d1349 1
a1349 2
		while ((ifa = TAILQ_NEXT(ifa, ifa_list)) !=
		    TAILQ_END(&ifp->if_addrlist)) {
@


1.123
log
@Fix a pair of typos in comments.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.122 2012/09/19 16:14:01 blambert Exp $	*/
d787 1
a787 1
				    IFAFREE(rt->rt_ifa);
@


1.123.2.1
log
@MFC rtsock fix to OPENBSD_5_3:

-/--------------------------
revision 1.126
date: 2013/05/17 11:13:37;  author: krw;  state: Exp;  lines: +2 -1
Do not attempt to delete the undeletable RNF_ROOT route.

Discovered & fix tested by Peter J Philip.

ok claudio@@ blambert@@
-/--------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.123 2012/09/20 20:53:13 blambert Exp $	*/
a623 1
			rt = NULL;
@


1.122
log
@Make rt_lookup return a pointer to an rtentry struct instead of
to a radix_node struct.

The radix tree pushdown continues.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.121 2012/09/19 12:35:07 blambert Exp $	*/
d925 1
a925 1
	/* RTV_PRIORITY handled befor */
@


1.121
log
@More radix internals pushdown; place rn_mpath_next, which accepts and
returns radix_node pointers, inside a new rt_mpath_next, which accepts
and returns rtentry pointers, and start using that instead.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.120 2012/09/17 19:00:36 blambert Exp $	*/
d620 2
a621 1
		rn = rt_lookup(dst, netmask, tableid);
a625 1
		rt = (struct rtentry *)rn;
@


1.120
log
@Whitespace change (excess indentation).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.119 2012/03/28 18:10:38 claudio Exp $	*/
d647 1
a647 1
			if (rn_mpath_next(rn, 0)) {
@


1.119
log
@Use p_p->ps_pid as pid in the route header instead of the thread pid. Give
userland a chance to compare the value against getpid().
This unbreaks transmission for me. OK deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.118 2011/04/07 15:30:16 miod Exp $	*/
d684 2
a685 2
				error = ESRCH;
				goto flush;
@


1.118
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.117 2011/04/04 20:25:35 blambert Exp $	*/
d503 1
a503 1
	rtm->rtm_pid = curproc->p_pid;
@


1.117
log
@m_copyback is no longer a void function, so start using its error return
instead of coming at it sideways to detect failure.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.116 2011/04/03 17:01:23 jsing Exp $	*/
d536 1
a536 1
			if ((error = rtable_add(tableid)) != NULL)
@


1.116
log
@Always reserve space in the routing socket for a desync mbuf. This allows
a desync to be appended when the socket buffer becomes full, rather than
continuall retrying until space becomes available (which may be never).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.114 2011/02/14 12:53:27 tedu Exp $	*/
d903 1
a903 2
		m_copyback(m, 0, rtm->rtm_msglen, rtm, M_NOWAIT);
		if (m->m_pkthdr.len < rtm->rtm_msglen) {
d1002 4
a1005 1
		m_copyback(m, len, dlen, sa, M_NOWAIT);
a1006 4
	}
	if (m->m_pkthdr.len != len) {
		m_freem(m);
		return (NULL);
@


1.115
log
@- use nitems(); no binary change

ok claudio@@
@
text
@d406 2
a407 1
				if (sbappendaddr(&last->so_rcv, sosrc,
d427 2
a428 1
		if (sbappendaddr(&last->so_rcv, sosrc,
@


1.114
log
@free mbuf in failure case.  fix for pr6562.  ok claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.113 2011/01/06 14:50:11 claudio Exp $	*/
d1472 1
a1472 1
      routesw, &routesw[sizeof(routesw)/sizeof(routesw[0])] };
@


1.113
log
@dst my point to memory inside rt so move the check up before the
rtfree(rt). Without this the sp_protocol on RTM_DELETE is garbage
and rtsocket user that restrict the AF of the socket (like ospfd)
will not see a single one of the RTM_DELETE.
OK henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.112 2011/01/06 14:45:07 claudio Exp $	*/
d312 2
@


1.112
log
@Minor style nit
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.111 2010/10/28 17:18:35 claudio Exp $	*/
d877 2
a897 2
	if (dst)
		route_proto.sp_protocol = dst->sa_family;
@


1.111
log
@Do not send route messages to userland processes that the kernel
rejects because of bad encoding. Userland processes trust that the
messages on the rtsock are correctly encoded. Moved some checks up
to do the suser() check as soon as possible.
After discussion with deraadt@@, OK deraadt@@ and sthen@@ (earlier version)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.110 2010/10/11 11:41:08 claudio Exp $	*/
d348 1
a348 2
		if (rp->rcb_proto.sp_protocol  &&
		    proto->sp_protocol &&
@


1.110
log
@Implement an rtsocket filter for rtableids. A process will initially
only get messages that are for the rtable the process is bound to.
Depending on the rtm_type the rdomain or rtable id are used for
comparison.  It is possible to change the filter with a setsockopt(s,
AF_ROUTE, ROUTE_TABLEFILTER,...) and if set to RTABLE_ANY the filter
is deactivated.  Additionally set the tableid in struct if_msghdr
to the rdomain id and use the process rtableid in the sysctl if no
table was specified.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.109 2010/09/08 08:20:45 claudio Exp $	*/
d477 1
a477 1
		goto flush;
d483 5
a487 1
			goto flush;
d492 1
a492 1
			goto flush;
d498 1
a498 1
		goto flush;
d505 23
a527 1
		goto flush;
d547 1
a547 1
			goto flush;
a582 9
	/*
	 * Verify that the caller has the appropriate privilege; RTM_GET
	 * is the only operation the non-superuser is allowed.
	 */
	if (rtm->rtm_type != RTM_GET && suser(curproc, 0) != 0) {
		error = EACCES;
		goto flush;
	}

a867 4

	default:
		error = EOPNOTSUPP;
		break;
d886 1
@


1.109
log
@Switch the MPLS blocks for RTM_CHANGE. Do not always remove the MPLS
information if the gateway changes, since real MPLS routes need to
change gateway and outgoing label on topology changes. So if there is
MPLS information and an outgoing label do a proper change but if the
gateway of a non-MPLS route is changed remove the MPLS path since it is
no longer valid.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.108 2010/09/02 09:38:05 blambert Exp $	*/
d116 1
d119 1
a119 1
	struct timeout	timeout;
d155 2
a156 1
		rp = malloc(sizeof(struct routecb), M_PCB, M_WAITOK|M_ZERO);
d174 1
d233 1
d251 11
d273 1
a273 1
			m->m_len = sizeof(int);
d276 5
d323 1
d369 1
d371 1
a371 1
		    mtod(m, struct rt_msghdr *)->rtm_type)))
d373 21
d1124 1
d1324 1
d1388 2
a1389 1
	}
@


1.108
log
@don't attempt to enqueue routing messages on sockets marked SS_CANTRCVMORE

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.107 2010/08/25 14:07:24 claudio Exp $	*/
d736 1
a736 10
			/* if gateway changed remove MPLS information */
			if (newgate || ((rtm->rtm_fmask & RTF_MPLS) &&
			    !(rtm->rtm_flags & RTF_MPLS))) {
				if (rt->rt_llinfo != NULL &&
				    rt->rt_flags & RTF_MPLS) {
					free(rt->rt_llinfo, M_TEMP);
					rt->rt_llinfo = NULL;
					rt->rt_flags &= ~RTF_MPLS;
				}
			} else if ((rtm->rtm_flags & RTF_MPLS) &&
d765 9
@


1.107
log
@Let rtable_add() return usefull errnos so that the ioctl handler and the
rtsock code can return a more reasonable error to the user.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.106 2010/08/24 12:45:08 claudio Exp $	*/
d323 2
@


1.106
log
@last is a pointer so initialize to NULL and not 0. Also move initialization
up to the declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.105 2010/07/14 20:56:35 claudio Exp $	*/
d462 1
a462 2
			if (rtable_add(tableid)) {
				error = EINVAL;
a463 1
			}
@


1.105
log
@The append side of a socketbuffer is not allowed to call sbflush().
Learned the hard way. dlg@@ confirmed that it is save to just remove them,
the desync will still work but the reader needs to dequeue all packets first.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.104 2010/07/14 00:42:57 dlg Exp $	*/
d305 1
a305 1
	struct socket *last;
a321 1
	last = 0;
@


1.105.2.1
log
@MFC rtsock fix by claudio at claudio's request:

dst my point to memory inside rt so move the check up before the
rtfree(rt). Without this the sp_protocol on RTM_DELETE is garbage
and rtsocket user that restrict the AF of the socket (like ospfd)
will not see a single one of the RTM_DELETE.
OK henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.105 2010/07/14 20:56:35 claudio Exp $	*/
a822 2
	if (dst)
		route_proto.sp_protocol = dst->sa_family;
d841 2
@


1.104
log
@if we produce a lot of rtsock messages it is possible we will hit a
condition that prevents us from queuing it, which in turn means that
processes listening on the routing socket for changes to the kernel state
will get out of sync. currently this is handled by the following comment:

	/* should notify about lost packet */

this change introduces a new rtsock message called RTM_DESYNC that
notifies about lost packets and uses it instead of this comment.

when we detect loss we flush all the message in the routing socket and
attempt to queue an RTM_DESYNC message instead. to guarantee that we will
enqueue DESYNC we keep trying it when an attempt to enqueue or dequeue
any messages is made, and in the worst case a timeout tries to guarantee
that desync is added to the socket.

ive been running this in production for 2 or 3 weeks.
tested by sthen@@
ok sthen@@ claudio@@ deraadt@@
code written by andrew sallaway at the univeristy of queensland.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.103 2010/07/09 15:36:54 claudio Exp $	*/
a369 1
					sbflush(&last->so_rcv);
a385 1
			sbflush(&last->so_rcv);
@


1.103
log
@When protocol filtering is used on the rtsocket filter only messages that
actually have a protocol/address family set. Messages like RTM_IFINFO or
RTM_IFANNOUNCE are family independent and should not be filtered but
it is possible to use a ROUTE_MSGFILTER to filter these messages.
This allows to reduce the messages sent to AF_INET or AF_INET6 only daemons.
OK henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.102 2010/07/02 02:40:16 blambert Exp $	*/
d85 2
d117 2
d122 12
d140 1
d156 2
d187 13
d202 1
d270 29
d351 7
d362 10
a371 2
				    n, (struct mbuf *)0) == 0)
					/* should notify about lost packet */
d373 1
a373 1
				else {
d383 6
a388 1
		    m, (struct mbuf *)0) == 0)
d390 1
a390 1
		else {
d1404 1
a1404 1
{ SOCK_RAW,	&routedomain,	0,		PR_ATOMIC|PR_ADDR,
@


1.102
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.101 2010/06/28 18:50:37 claudio Exp $	*/
d265 1
@


1.101
log
@Add the rtable id as an argument to rn_walktree(). Functions like
rt_if_remove_rtdelete() need to know the table id to be able to correctly
remove nodes.
Problem found by Andrea Parazzini and analyzed by Martin Pelikn.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.100 2010/05/19 13:09:09 claudio Exp $	*/
d763 1
a763 1
		m_copyback(m, 0, rtm->rtm_msglen, rtm);
d863 1
a863 1
		m_copyback(m, len, dlen, sa);
@


1.100
log
@Require RTF_MPLS to be set when a mpls route is added or changed.  To remove
only the MPLS bits from a route set rtm_fmask to RTF_MPLS.  Additionally check
if the nexthop is modified and in that case always remove the MPLS info since
the path changed.  This change makes life in userland a lot easier since the
routing daemons normaly don't know about MPLS and until now they destroyed
MPLS information when issuing RTM_CHANGEs.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.99 2010/04/21 11:52:46 claudio Exp $	*/
d651 1
a651 1
					(struct radix_node *)rt, ifp);
d1107 1
a1107 1
sysctl_dumpentry(struct radix_node *rn, void *v)
d1166 1
@


1.99
log
@Implement a way to get information about a rtable. Currently only the rtableid
and rdomainid are returned. This is necessary to know where L2 information
of a table is stored (which will be needed soon by bgpd).
Also while there change the errno for non-existing routing tables to ENOENT.
'Fine' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.98 2010/03/23 15:03:25 claudio Exp $	*/
d82 1
a82 1
#endif /* MPLS */
d161 1
a161 1
#endif /* MPLS */
d178 1
a178 1
#endif /* MPLS */
d324 1
a324 1
	int			 len, error = 0;
d457 1
d459 1
a459 1
			rtm->rtm_priority = saved_nrt->rt_priority & RTP_MASK;
d619 5
a654 23

			/* XXX Hack to allow some flags to be toggled */
			if (rtm->rtm_fmask & RTF_FMASK)
				rt->rt_flags = (rt->rt_flags &
				    ~rtm->rtm_fmask) |
				    (rtm->rtm_flags & rtm->rtm_fmask);

			rt_setmetrics(rtm->rtm_inits, &rtm->rtm_rmx,
			    &rt->rt_rmx);
			rtm->rtm_index = rt->rt_ifp->if_index;
			rtm->rtm_priority = rt->rt_priority & RTP_MASK;
			rtm->rtm_flags = rt->rt_flags;
			if (rt->rt_ifa && rt->rt_ifa->ifa_rtrequest)
				rt->rt_ifa->ifa_rtrequest(RTM_ADD, rt, &info);
			if (genmask)
				rt->rt_genmask = genmask;
			if (info.rti_info[RTAX_LABEL] != NULL) {
				char *rtlabel = ((struct sockaddr_rtlabel *)
				    info.rti_info[RTAX_LABEL])->sr_label;
				rtlabel_unref(rt->rt_labelid);
				rt->rt_labelid =
				    rtlabel_name2id(rtlabel);
			}
d656 11
a666 1
			if (info.rti_info[RTAX_SRC] != NULL) {
d694 7
a700 5
			} else {
				if (rt->rt_llinfo != NULL &&
				    rt->rt_flags & RTF_MPLS) {
					free(rt->rt_llinfo, M_TEMP);
					rt->rt_llinfo = NULL;
d702 15
a716 2
					rt->rt_flags &= (~RTF_MPLS);
				}
a717 1
#endif
a738 4
#ifdef MPLS
			if (rt && rt->rt_flags & RTF_MPLS)
				rtm->rtm_flags |= RTF_MPLS;
#endif
@


1.98
log
@Set rtm_mpls on RTM_GET so that we get the correct options on mpls routes.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.97 2010/02/09 16:34:57 claudio Exp $	*/
d1240 1
d1258 1
a1258 1
			return (EINVAL);
d1281 12
@


1.97
log
@Set the rtm_priority when sending RTM_ADD/RTM_DELETE messages out in
rt_newaddrmsg(). Makes the routing daemons a bit less confused when
interfaces are reconfigured.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.96 2010/02/09 16:31:14 claudio Exp $	*/
d573 1
@


1.97.2.1
log
@MFC rtsock fix by claudio at claudio's request:

dst my point to memory inside rt so move the check up before the
rtfree(rt). Without this the sp_protocol on RTM_DELETE is garbage
and rtsocket user that restrict the AF of the socket (like ospfd)
will not see a single one of the RTM_DELETE.
OK henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.97 2010/02/09 16:34:57 claudio Exp $	*/
a737 2
	if (dst)
		route_proto.sp_protocol = dst->sa_family;
d756 2
@


1.96
log
@Correctly track RTF_UP on RTM_CHANGE. Since the interface can change
rt_if_linkstate_change() needs to be rerun for this route and the
resulting rt_flags need to copied to the rtm_flags for userland.
Problem found and diagnosed by Doran Mori. OK henning@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.95 2009/11/03 10:59:04 claudio Exp $	*/
d1063 1
@


1.95
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.94 2009/09/17 13:27:24 claudio Exp $	*/
d641 5
d659 1
@


1.94
log
@Remove the comaptibility structures for routing socket version 3.
The RTM_VERSION bump is 2 years ago and so there is no need for this.
Diff made by tedu@@ some time ago but got never commited so I do it now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.93 2009/07/07 10:38:49 michele Exp $	*/
d615 1
a615 2
			if ((error = rt_getifa(&info,
			    /* XXX wrong, only rdomain */ tableid)) != 0)
d621 2
a622 2
			if (ifpaddr && (ifa = ifa_ifwithnet(ifpaddr,
			    /* XXX again rtable vs. rdomain */ tableid)) &&
d626 2
a627 2
			else if ((ifaaddr && (ifa = ifa_ifwithaddr(ifaaddr,
			    /* XXX one more time */ tableid))) ||
d629 1
a629 1
			    rt_key(rt), gate, /* XXX again */ tableid))))
@


1.93
log
@When adding or changing a MPLS route, add RTF_MPLS flag to
routing message. We can then rely on that flag to spot out
MPLS routes coming from routing socket.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.92 2009/06/26 10:14:24 blambert Exp $	*/
a101 3
#ifndef SMALL_KERNEL
struct rt_msghdr *rtmsg_3to4(struct mbuf *, int *);
#endif
a366 13
#ifndef SMALL_KERNEL
	case RTM_OVERSION:
		if (len < sizeof(struct rt_omsghdr)) {
			error = EINVAL;
			goto flush;
		}
		rtm = rtmsg_3to4(m, &len);
		if (rtm == 0) {
			error = ENOBUFS;
			goto flush;
		}
		break;
#endif
d881 1
a881 6
#ifndef SMALL_KERNEL
		if (vers == RTM_OVERSION)
			len = sizeof(struct ifa_omsghdr);
		else
#endif
			len = sizeof(struct ifa_msghdr);
d884 1
a884 6
#ifndef SMALL_KERNEL
		if (vers == RTM_OVERSION)
			len = sizeof(struct if_omsghdr);
		else
#endif
			len = sizeof(struct if_msghdr);
d887 1
a887 6
#ifndef SMALL_KERNEL
		if (vers == RTM_OVERSION)
			len = sizeof(struct rt_omsghdr);
		else
#endif
			len = sizeof(struct rt_msghdr);
d931 1
a931 1
	if (cp && vers != RTM_OVERSION) {
a938 9
#ifndef SMALL_KERNEL
	if (cp && vers == RTM_OVERSION) {
		struct rt_omsghdr *rtm = (struct rt_omsghdr *)cp0;

		rtm->rtm_version = RTM_OVERSION;
		rtm->rtm_type = type;
		rtm->rtm_msglen = len;
	}
#endif
a1163 16
#ifndef SMALL_KERNEL
	size = rt_msg2(RTM_GET, RTM_OVERSION, &info, NULL, w);
	if (w->w_where && w->w_tmem && w->w_needed <= 0) {
		struct rt_omsghdr *rtm = (struct rt_omsghdr *)w->w_tmem;

		rtm->rtm_flags = rt->rt_flags;
		rtm->rtm_rmx.rmx_locks = rt->rt_rmx.rmx_locks;
		rtm->rtm_rmx.rmx_mtu = rt->rt_rmx.rmx_mtu;
		rtm->rtm_index = rt->rt_ifp->if_index;
		rtm->rtm_addrs = info.rti_addrs;
		if ((error = copyout(rtm, w->w_where, size)) != 0)
			w->w_where = NULL;
		else
			w->w_where += size;
	}
#endif
a1196 29
#ifndef SMALL_KERNEL
		len = rt_msg2(RTM_IFINFO, RTM_OVERSION, &info, 0, w);
		if (w->w_where && w->w_tmem && w->w_needed <= 0) {
			struct if_omsghdr *ifm;

			ifm = (struct if_omsghdr *)w->w_tmem;
			ifm->ifm_index = ifp->if_index;
			ifm->ifm_flags = ifp->if_flags;
			/* just init the most important types of if_data */
			ifm->ifm_data.ifi_type = ifp->if_data.ifi_type;
			ifm->ifm_data.ifi_addrlen = ifp->if_data.ifi_addrlen;
			ifm->ifm_data.ifi_hdrlen = ifp->if_data.ifi_hdrlen;
			ifm->ifm_data.ifi_link_state =
			    ifp->if_data.ifi_link_state;
			ifm->ifm_data.ifi_mtu = ifp->if_data.ifi_mtu;
			ifm->ifm_data.ifi_metric = ifp->if_data.ifi_metric;
			if (ifp->if_data.ifi_baudrate > ULONG_MAX)
				ifm->ifm_data.ifi_baudrate = ULONG_MAX;
			else
				ifm->ifm_data.ifi_baudrate =
				    ifp->if_data.ifi_baudrate;

			ifm->ifm_addrs = info.rti_addrs;
			error = copyout(ifm, w->w_where, len);
			if (error)
				return (error);
			w->w_where += len;
		}
#endif
a1218 16
#ifndef SMALL_KERNEL
			len = rt_msg2(RTM_NEWADDR, RTM_OVERSION, &info, 0, w);
			if (w->w_where && w->w_tmem && w->w_needed <= 0) {
				struct ifa_omsghdr *ifam;

				ifam = (struct ifa_omsghdr *)w->w_tmem;
				ifam->ifam_index = ifa->ifa_ifp->if_index;
				ifam->ifam_flags = ifa->ifa_flags;
				ifam->ifam_metric = ifa->ifa_metric;
				ifam->ifam_addrs = info.rti_addrs;
				error = copyout(w->w_tmem, w->w_where, len);
				if (error)
					return (error);
				w->w_where += len;
			}
#endif
a1288 37

#ifndef SMALL_KERNEL
struct rt_msghdr *
rtmsg_3to4(struct mbuf *m, int *len)
{
	struct rt_msghdr *rtm;
	struct rt_omsghdr *ortm;
	int slen;

	slen = *len - sizeof(struct rt_omsghdr);
	*len = sizeof(struct rt_msghdr) + slen;
	R_Malloc(rtm, struct rt_msghdr *, *len);
	if (rtm == 0)
		return (NULL);
	bzero(rtm, sizeof(struct rt_msghdr));
	ortm = mtod(m, struct rt_omsghdr *);
	rtm->rtm_msglen = sizeof(struct rt_msghdr) + slen;
	rtm->rtm_version = RTM_VERSION;
	rtm->rtm_type = ortm->rtm_type;
	rtm->rtm_hdrlen = sizeof(struct rt_msghdr);
	rtm->rtm_index = ortm->rtm_index;
	rtm->rtm_tableid = 0; /* XXX we only care about the main table */
	rtm->rtm_flags = ortm->rtm_flags;
	rtm->rtm_addrs = ortm->rtm_addrs;
	rtm->rtm_seq = ortm->rtm_seq;
	rtm->rtm_fmask = ortm->rtm_fmask;
	rtm->rtm_inits = ortm->rtm_inits;
	/* copy just the interesting stuff ignore the rest */
	rtm->rtm_rmx.rmx_locks = ortm->rtm_rmx.rmx_locks;
	rtm->rtm_rmx.rmx_mtu = ortm->rtm_rmx.rmx_mtu;

	m_copydata(m, sizeof(struct rt_omsghdr), slen,
	    ((caddr_t)rtm + sizeof(struct rt_msghdr)));

	return (rtm);
}
#endif
@


1.92
log
@the pr_usrreq implementation for routing sockets shares exactly one line
of code between cases, so stop pretending otherwise, and move the
if() dance to a switch, as is done in every other pr_usrreq I'm aware of.

ok claudio@@ michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.91 2009/06/22 19:01:56 blambert Exp $	*/
d741 5
a745 1
		else 
d747 1
@


1.91
log
@Remove unneeded sotorawpcb() call, as the PCB is unmolested between
malloc()ing it and calling that macro.

No functional change, just tightening things up a bit.

ok claudio@@ michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.90 2009/06/20 10:39:52 blambert Exp $	*/
d126 2
a128 2
	struct rawcb	*rp = sotorawcb(so);
	int		 s;
d130 10
a139 5
	/*
	 * use the rawcb but allocate a rooutecb, this code does not care
	 * about the additional fields and works directly on the raw socket.
	 */
	if (req == PRU_ATTACH) {
d142 5
a146 20
	}
	if (req == PRU_DETACH && rp) {
		int af = rp->rcb_proto.sp_protocol;
		if (af == AF_INET)
			route_cb.ip_count--;
		else if (af == AF_INET6)
			route_cb.ip6_count--;
#ifdef MPLS
		else if (af == AF_MPLS)
			route_cb.mpls_count--;
#endif /* MPLS */
		route_cb.any_count--;
	}
	s = splsoftnet();
	/*
	 * Don't call raw_usrreq() in the attach case, because
	 * we want to allow non-privileged processes to listen on
	 * and send "safe" commands to the routing socket.
	 */
	if (req == PRU_ATTACH) {
a150 5
	} else
		error = raw_usrreq(so, req, m, nam, control, p);

	if (req == PRU_ATTACH && rp) {
		int af = rp->rcb_proto.sp_protocol;
d156 1
d169 18
d188 1
@


1.90
log
@Decrement routing socket count in MPLS detach case

While here, fix whitespace (spaces -> tabs) issue spotted by michele@@

ok michele@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.89 2009/06/06 12:31:17 rainer Exp $	*/
a163 1
	rp = sotorawcb(so);
@


1.89
log
@when xflags got changed, tell the userland by routing sockets

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.88 2009/06/05 00:05:22 claudio Exp $	*/
d144 4
d177 2
a178 2
               else if (af == AF_MPLS)
                       route_cb.mpls_count++;
@


1.88
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.87 2009/05/31 18:00:54 claudio Exp $	*/
d1020 1
@


1.87
log
@Hide RTP_DOWN in the kernel and don't expose it to userland. Userland is
not smart enough to handle it in a sensible way. Make sure the kernel
selected routing priority is actually exported to userland or to help
daemons like bgpd to keep correctly track of the routes. This should fix
some of the rather strange errors seen by people having multipath routes
on their bgpd boxes. While there make the interface priority inheritance
on static routes work again.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.86 2009/05/31 03:27:17 claudio Exp $	*/
d623 2
a624 1
			if ((error = rt_getifa(&info)) != 0)
d630 2
a631 1
			if (ifpaddr && (ifa = ifa_ifwithnet(ifpaddr)) &&
d634 3
a636 2
							ifp);
			else if ((ifaaddr && (ifa = ifa_ifwithaddr(ifaaddr))) ||
d638 1
a638 1
			    rt_key(rt), gate))))
d1068 1
d1086 1
@


1.86
log
@Fix for the rtfree 2 panic seen by some people before the release. A missing
refcnt bump caused the panic to be triggered. While there also make the
priority so that the compare is working a bit better.
henning@@ cries in agony (I already gave up)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.85 2009/04/18 10:45:47 michele Exp $	*/
d412 1
a412 1
		prio = RTP_STATIC;
a415 3
	/* write back the priority the kernel used */
	 rtm->rtm_priority = prio;

d464 1
d466 1
d612 1
a612 1
			rtm->rtm_priority = rt->rt_priority;
d659 1
d716 1
d1172 1
a1172 1
		rtm->rtm_priority = rt->rt_priority;
@


1.85
log
@Make "route(8) change" aware of MPLS.
It is now possible to change routes' MPLS parameters via route change.

ok laurent@@, ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.84 2009/02/03 16:42:54 michele Exp $	*/
d504 2
a505 1
			if (prio != RTP_ANY && rt->rt_priority != prio) {
d507 1
@


1.84
log
@Use our own flags to set the operations and not RTF_PROTOX.
Switch the padding field into a MPLS one in rt_msghdr to store
relevant informations.

OK claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.83 2009/01/28 22:18:44 michele Exp $	*/
d326 1
a326 1
	struct sockaddr_mpls	 sa_mpls;
d669 16
d686 22
@


1.83
log
@Get rid of the ugly rtentry hack.

We can now act as edge node and allow ipv4 packets to
enter a Label Switched Path and not just forwarding
MPLS packets.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.82 2009/01/28 12:34:09 claudio Exp $	*/
d441 3
d578 2
d1121 2
a1130 6
#ifdef MPLS
		if (dst->sa_family == AF_MPLS) {
			rtm->rtm_flags |=
			    ((struct rt_mpls *)rt->rt_llinfo)->mpls_operation;
		}
#endif
d1136 3
a1149 6
#ifdef MPLS
		if (dst->sa_family == AF_MPLS) {
			rtm->rtm_flags |=
			    ((struct rt_mpls *)rt->rt_llinfo)->mpls_operation;
		}
#endif
@


1.82
log
@Implement basic routing socket filtering. It is possible to give a list --
actually a bitfield -- of routing messages a listener is interested in.
This list can be changed with a setsockopt(s, AF_ROUTE, ROUTE_MSGFILTER, ...)
call. OK henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.81 2009/01/08 12:47:45 michele Exp $	*/
a326 1
	struct sockaddr_mpls	*psa_mpls;
d567 1
a567 1
			if (rt->rt_mpls) {
d571 2
a572 1
				sa_mpls.smpls_label = rt->rt_mpls;
d664 1
a664 7
#ifdef MPLS
			if (info.rti_info[RTAX_SRC] != NULL) {
				psa_mpls = (struct sockaddr_mpls *)
				    info.rti_info[RTAX_SRC];
				rt->rt_mpls = psa_mpls->smpls_label;
			}
#endif
d1109 1
a1109 1
	if (rt->rt_mpls) {
d1113 2
a1114 1
		sa_mpls.smpls_label = rt->rt_mpls;
d1124 6
d1146 6
@


1.81
log
@Fix sockaddr_mpls structure.
Now it contains just the label as it must be.

This introduces a ugly hack in rtentry that will be removed
as soon as possible.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.80 2009/01/03 15:31:03 claudio Exp $	*/
d95 3
d115 7
d130 4
d135 1
a135 1
		rp = malloc(sizeof(*rp), M_PCB, M_WAITOK|M_ZERO);
d186 125
d723 1
a723 1
		raw_input(m, &route_proto, &route_src, &route_dst);
d956 1
a956 1
	raw_input(m, &route_proto, &route_src, &route_dst);
d980 1
a980 1
	raw_input(m, &route_proto, &route_src, &route_dst);
d1047 1
a1047 1
		raw_input(m, &route_proto, &route_src, &route_dst);
d1071 1
a1071 1
	raw_input(m, &route_proto, &route_src, &route_dst);
d1371 1
a1371 1
  raw_input,	route_output,	raw_ctlinput,	0,
@


1.80
log
@Write back the priority the kernel used. Fixes a problem seen in ospfd when
routes are added via route(8) -- those where added with the wrong priority
and so where not correctly tracked later on.
Found and tested by gollo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.79 2008/12/12 21:52:04 claudio Exp $	*/
d186 4
d428 10
a437 1

d525 7
d945 3
d975 9
@


1.79
log
@Make sure that incomming routing messages don't have RTP_DOWN set. Mask
the rtm_priority with RTP_MASK so that userland (e.g. arp) can issue a RTM_GET
and reissue the message as RTM_DELETE.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.78 2008/11/22 22:34:11 claudio Exp $	*/
d258 1
a258 1
	/* make sure that kernel only bits are not set */
d273 3
@


1.78
log
@Allow rt_msg1() to get a NULL as struct rt_addrinfo this simplifies a few
callers (plus an upcomming one). OK henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.77 2008/11/21 18:01:30 claudio Exp $	*/
d257 3
@


1.77
log
@Change rn_mpath_next() to be able to walk over the full multipath list
not only over routes of the same prio. This makes it possible to modify
rt_mpath_matchgate() so that if only gateway is specified without a specific
priority it will scan the full list and not only the first routes.
This is also needed for upcoming link state tracking.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.76 2008/08/07 21:32:08 claudio Exp $	*/
d645 1
a645 1
		if ((sa = rtinfo->rti_info[i]) == NULL)
a802 1
	struct rt_addrinfo	 info;
d806 1
a806 2
	bzero(&info, sizeof(info));
	m = rt_msg1(RTM_IFINFO, &info);
a894 1
	struct rt_addrinfo		 info;
d898 1
a898 2
	bzero(&info, sizeof(info));
	m = rt_msg1(RTM_IFANNOUNCE, &info);
@


1.76
log
@Remove workaround used for the 4.4 release. More route prio stuff is comming
soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.75 2008/08/01 05:08:08 henning Exp $	*/
d359 1
a359 1
			if (rn_mpath_next(rn)) {
@


1.75
log
@force route priority to RTP_DEFAULT unconditionally, effectively disabling
route prios. playing safe for 4.4-release, as not all parts of the system
deal correctly with route prios yet. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.74 2008/07/28 19:38:07 claudio Exp $	*/
a269 3

	/* XXX hack for 4.4-release */
	prio = RTP_DEFAULT;
@


1.74
log
@Align the route message length to the next natural boundary via ALIGN() to
ensure that the next message is nicely aligned as well. Some archs (sparc, m88k)have strict alignement issues since the inclusion of 64bit counters in the
messages because those values could end up on non aligned addresses.
Found and fix tested by miod@@, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.73 2008/06/13 21:49:57 claudio Exp $	*/
d270 3
@


1.73
log
@Change the logic when selecting routes on RTM_CHANGE & RTM_GET. RTM_CHANGE
can not supply the correct nexthop if the nexthop is changed. So if the
route we want to change is a non-multipath one allow the change to succeed.
This unbreaks RTM_CHANGE in most situations. Found by jsing@@ Ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.72 2008/06/13 06:10:46 claudio Exp $	*/
d716 2
@


1.72
log
@Cleanup a bit. Instead of doing dst = 0 in every error handling block init
it once at start instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.71 2008/05/23 15:51:12 thib Exp $	*/
d264 1
a264 1
	} else if (rtm->rtm_type == RTM_DELETE)
d349 28
a376 5
		if (rn_mpath_capable(rnh) &&
		    (rtm->rtm_type != RTM_GET || gate ||
		    rtm->rtm_priority != 0)) {
			rt = rt_mpath_matchgate(rt, gate, prio);
			rn = (struct radix_node *)rt;
d381 1
@


1.71
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.70 2008/05/07 05:14:21 claudio Exp $	*/
d195 1
a203 1
		dst = 0;
a209 1
			dst = 0;
a214 1
			dst = 0;
a222 1
			dst = 0;
a227 1
			dst = 0;
a233 1
		dst = 0;
a240 1
		dst = 0;
a248 1
				dst = 0;
a252 1
			dst = 0;
a259 1
			dst = 0;
@


1.70
log
@Implement routing priorities. Every route inserted has a priority assigned
and the one route with the lowest number wins. This will be used by the
routing daemons to resolve the synchronisations issue in case of conflicts.
The nasty bits of this are in the multipath code. If no priority is specified
the kernel will choose an appropriate priority.

Looked at by a few people at n2k8 code is much older
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.69 2008/04/23 10:55:14 norby Exp $	*/
d114 1
a114 1
    struct mbuf *control)
d144 1
a144 1
		error = raw_usrreq(so, req, m, nam, control);
@


1.69
log
@Import MPLS (Multi Protocol Label Switching)

MPLS support partly based on the (abandoned?) AYAME project.
Basic LSR (Label Switch Router) functionality is present, but not fully
functional yet.

It is currently possible to insert entries in the LIB (Label Information Base)
with route(8), but setting the operation type is not supported yet.

Imported to allow more people to work on this in the coming weeks.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.68 2007/09/15 16:43:51 henning Exp $	*/
d189 1
d266 14
d318 2
a319 1
		error = rtrequest1(rtm->rtm_type, &info, &saved_nrt, tableid);
d329 2
a330 1
		error = rtrequest1(rtm->rtm_type, &info, &saved_nrt, tableid);
d359 3
a361 2
		    (rtm->rtm_type != RTM_GET || gate)) {
			rt = rt_mpath_matchgate(rt, gate);
d433 1
d557 1
d939 1
@


1.68
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.67 2007/09/09 12:01:58 claudio Exp $	*/
d80 4
d158 4
@


1.67
log
@Only clear the message header if it is called from a sysctl walk. This
unbreaks RTM_GET. Problem reported by fkr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.66 2007/09/08 16:55:05 claudio Exp $	*/
d117 1
a117 1
		MALLOC(rp, struct rawcb *, sizeof(*rp), M_PCB, M_WAITOK);
a118 1
		bzero(so->so_pcb, sizeof(*rp));
@


1.66
log
@Clear the message header (and only the message header) in rt_msg2.
By doing so we ensure that all the memory is initialised and we no longer
have to ensure that none of the structure elements is forgotten in
sysctl_iflist() and sysctl_dumpentry().
This solves the route flush issues seen by aanriot@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.65 2007/09/07 11:15:19 claudio Exp $	*/
d694 1
a694 1
	if (cp)		/* clear the message header */
@


1.65
log
@Check if rtm_hdrlen is smaller then the passed message or it would be possible
to access uninitialised memory.
Set dst to 0 on error, the error path tries to access dst but dst is inited
later down the code. This fixes a kernel panic seen by aanriot@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.64 2007/09/03 15:24:49 claudio Exp $	*/
d694 3
a911 1
		rtm->rtm_use = 0;
a914 1
		rtm->rtm_errno = rtm->rtm_pid = rtm->rtm_seq = 0;
a926 1
		rtm->rtm_use = 0;
a929 1
		rtm->rtm_errno = rtm->rtm_pid = rtm->rtm_seq = 0;
@


1.64
log
@Bump RTM_VERSION to 4 and start a new aera of routing in OpenBSD :)
Changes include 64bit counters instead of u_long, routing table id in the header
of most messages, reserved routing priority field, added a hdrlen field to skip
over the header so that binary compatibility becomes easier.
A minimal backward support for old binaries is included to ease upgrades but
don't expect anything more than ifconfig, route and dhclient to correctly work.
OK henning@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.63 2007/02/14 00:53:48 jsg Exp $	*/
d237 5
d247 1
d252 1
@


1.63
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.62 2006/06/16 17:45:37 henning Exp $	*/
d91 7
a97 4
static struct mbuf
		*rt_msg1(int, struct rt_addrinfo *);
static int	 rt_msg2(int, struct rt_addrinfo *, caddr_t, struct walkarg *);
static void	 rt_xaddrs(caddr_t, caddr_t, struct rt_addrinfo *);
d193 1
a193 1
	if (len < sizeof(*rtm) ||
d199 31
a229 8
	R_Malloc(rtm, struct rt_msghdr *, len);
	if (rtm == 0) {
		dst = 0;
		error = ENOBUFS;
		goto flush;
	}
	m_copydata(m, 0, len, (caddr_t)rtm);
	if (rtm->rtm_version != RTM_VERSION) {
d235 2
d253 1
a253 1
	rt_xaddrs((caddr_t)(rtm + 1), len + (caddr_t)rtm, &info);
d385 2
a386 1
			len = rt_msg2(rtm->rtm_type, &info, NULL, NULL);
d397 2
a398 1
			rt_msg2(rtm->rtm_type, &info, (caddr_t)rtm, NULL);
d540 1
a540 1
static void
d555 1
a555 1
static struct mbuf *
d562 1
a562 1
	int			 len, dlen;
d591 1
a591 1
	m->m_pkthdr.len = m->m_len = len;
d608 1
d614 3
a616 2
static int
rt_msg2(int type, struct rt_addrinfo *rtinfo, caddr_t cp, struct walkarg *w)
d619 1
a619 1
	int		len, dlen, second_time = 0;
d627 6
a632 1
		len = sizeof(struct ifa_msghdr);
d635 6
a640 1
		len = sizeof(struct if_msghdr);
d643 6
a648 1
		len = sizeof(struct rt_msghdr);
d651 1
d687 1
a687 1
	if (cp) {
d693 1
d695 9
d897 1
a897 1
	size = rt_msg2(RTM_GET, &info, NULL, w);
d904 18
a921 1
		rtm->rtm_rmx.rmx_refcnt = (u_long)rt->rt_refcnt;
d930 1
d950 1
a950 2
		len = rt_msg2(RTM_IFINFO, &info, 0, w);
		ifpaddr = 0;
d964 30
d1001 1
a1001 1
			len = rt_msg2(RTM_NEWADDR, &info, 0, w);
d1015 16
d1101 37
@


1.62
log
@support passing the desired routing table ID via the sysctl interface
(NET_RT_DUMP & friends) too. keep supporting the old form (and imply id 0)
of course. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.61 2006/06/16 16:52:08 henning Exp $	*/
d429 1
a429 1
			/* fallthrough */
@


1.61
log
@pass the routing table ID over the routing socket, so we can start to
manipulate alternate tables from userland. new tables are created
implicitely when an RTM_ADD for that table is seen.
ok norby claudio hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.59 2006/05/30 21:58:28 claudio Exp $	*/
d924 1
d928 1
a928 1
	if (namelen != 3)
d938 6
d950 2
a951 1
			if ((rnh = rt_gettable(i, 0)) && (af == 0 || af == i) &&
@


1.60
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d178 1
a178 1
	u_int			 tableid = 0;
d210 13
d671 1
@


1.59
log
@Export the route labels via sysctl interface not only via RTM_GET.
OK henning@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.58 2006/04/22 19:43:07 claudio Exp $	*/
d178 1
d248 1
a248 1
		error = rtrequest1(rtm->rtm_type, &info, &saved_nrt);
d258 1
a258 1
		error = rtrequest1(rtm->rtm_type, &info, &saved_nrt);
d267 1
a267 1
		if ((rnh = rt_gettable(dst->sa_family, 0)) == NULL) {
d271 1
a271 1
		rn = rt_lookup(dst, netmask, 0);
d370 1
a370 1
			if (gate && rt_setgate(rt, rt_key(rt), gate)) {
d643 2
a644 2
rt_missmsg(int type, struct rt_addrinfo *rtinfo, int flags, struct ifnet *ifp,
    int error)
@


1.58
log
@Routes announced via rt_missmsg() do not have rtm_index set. While in most
cases harmless it is used by the IPv6 code. The result is that bgpd is unable
to assigning link local addresses to the correct interface. OK henning@@
Fix for PR 5063.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.57 2006/03/31 17:30:39 claudio Exp $	*/
d796 2
d812 12
@


1.57
log
@Add sysctl to retrieve the routing table statisitcs. Will be used by netstat
instead of kvm access. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.56 2006/03/30 09:53:43 claudio Exp $	*/
d642 2
a643 1
rt_missmsg(int type, struct rt_addrinfo *rtinfo, int flags, int error)
d658 2
@


1.56
log
@In sysctl_dumpentry() pass the rt_refcnt by overloading rmx_rttvar.
This new rmx_refcnt can be used by route(8) to produce the same output
as netstat(1). OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.55 2006/03/30 08:28:16 claudio Exp $	*/
d919 7
@


1.55
log
@Spelling in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.54 2006/03/22 14:37:44 henning Exp $	*/
d814 1
@


1.54
log
@prevent anything outside rote.c from accessing the routing table heads
directly. rather provide a rt_lookup function for regular lookups,
and a rt_gettable for those that need access to the head for some reason.
the latter cases should be revisted later probably so that nothing outside
the routing core code accesses the heads at all...
tested claudio jolan me, ok claudio markus
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.53 2006/02/23 14:15:53 claudio Exp $	*/
d303 1
a303 1
		 * if non of them have a netmask both are host routes which is
@


1.53
log
@Until now it was only possible to unset the RTF_JUMBO flag on a RTM_CHANGE
request. Extend the "hack" to include more flags (RTF_PROTO[123] flags,
RTF_BLACKHOLE, RTF_REJECT and RTF_STATIC). Because rtm_use is "abused" --
rtm_use was replaced long time ago with rtm_rmx->rmx_pksent -- it is now
forced to 0 in RTM_GET requests and sysctl_dumpentry(). This is done to
prevent false changes because of a reused RTM_GET message.
OK henning@@, mcbride@@, makes sense markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.52 2006/02/02 13:59:45 claudio Exp $	*/
d266 1
a266 1
		if ((rnh = rt_tables[dst->sa_family]) == 0) {
d270 1
a270 1
		rn = rnh->rnh_lookup(dst, netmask, rnh);
d910 1
a910 1
			if ((rnh = rt_tables[i]) && (af == 0 || af == i) &&
@


1.52
log
@Set rtm_index to the correct interface index for RTM_ADD and RTM_CHANGE.
bgpd and ospfd use this information to track the availability of a route.
Discussed with dlg@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.51 2005/11/29 02:59:42 jolan Exp $	*/
d356 1
d394 2
a395 2
			/* XXX Hack to allow the jumbo flag to be toggled */
			if (rtm->rtm_use & RTF_JUMBO)
d812 1
a812 1
		rtm->rtm_use = rt->rt_use;
@


1.51
log
@something in the eurobsdcon route-a-thon broke my simple home network
router so back out the routing stuff to pre-eurobsdcon where my machine
doesn't crash immediately.

i am happy to test diffs and report success/failures but i am not happy
to have instantaneous crashes when i reboot with a new kernel that was
compiled from pristine sources.

if you are going to be an elitist asshole then you could at least make
sure your code works.

ok and "be crass towards them" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.48 2005/06/08 06:43:07 henning Exp $	*/
d253 1
d401 1
@


1.50
log
@repair builds.  ramdisk kernels forgotten about again.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.49 2005/11/27 16:22:45 henning Exp $	*/
a167 1
#ifndef SMALL_KERNEL
a168 1
#endif
d265 1
a265 1
		if (rt_gettable(dst->sa_family, 0) == NULL) {
d269 1
a269 1
		rn = rt_lookup(dst, netmask, 0);
d907 1
a907 1
			if ((rnh = rt_gettable(i, 0)) && (af == 0 || af == i) &&
@


1.49
log
@don't let anything outside route.c access the routing table heads directly,
but go through a provided wrapper.
also provide rt_lookup() instead of doing the lookup manually in many places.
ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.48 2005/06/08 06:43:07 henning Exp $	*/
d168 1
d170 1
@


1.48
log
@kill some leftover bits from netns and iso routing
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.47 2005/06/07 18:21:44 henning Exp $	*/
d265 1
a265 1
		if ((rnh = rt_tables[dst->sa_family]) == 0) {
d269 1
a269 1
		rn = rnh->rnh_lookup(dst, netmask, rnh);
d907 1
a907 1
			if ((rnh = rt_tables[i]) && (af == 0 || af == i) &&
@


1.47
log
@introduce a default "external" interface group, containing the interface(s)
the the default route(s) point to.
handles IPv4 and IPv6 as well as multipath routes.
follows default route changes, of course.
eases writing pf rulesets especially on laptops etc. that use different
interfaces depending on the environment (wired, wireless, ...)
ok theo ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.46 2005/05/27 22:37:46 mcbride Exp $	*/
a123 4
		else if (af == AF_NS)
			route_cb.ns_count--;
		else if (af == AF_ISO)
			route_cb.iso_count--;
a151 4
		else if (af == AF_NS)
			route_cb.ns_count++;
		else if (af == AF_ISO)
			route_cb.iso_count++;
@


1.46
log
@Use rtm_fmask instead of rtm_use.

ok marius@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.45 2005/05/27 07:11:21 mcbride Exp $	*/
d419 1
@


1.45
log
@Allow us to clear the RTM_JUMBO flag as well as set it.

Reported by Cedric Berger
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.44 2005/05/27 04:55:27 mcbride Exp $	*/
d402 3
a404 2
				rt->rt_flags = (rt->rt_flags & ~rtm->rtm_use) |
				    (rtm->rtm_flags & rtm->rtm_use);
@


1.44
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.43 2004/09/16 22:31:29 henning Exp $	*/
d401 1
a401 1
			if (rtm->rtm_flags & RTF_JUMBO)
@


1.43
log
@handle route labels on RTM_CHANGE, ok mcbride, prodded my markus some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.42 2004/08/03 11:22:15 henning Exp $	*/
d399 6
@


1.42
log
@introduce route labels, allowing for up to 32 bytes of info to be attached
to a route.
the label is sent over the routing socket wrapped into a new
struct sockaddr_rtlabel, allowing for handling it like any other sockaddr.
struct rtentry only contains a (16 bit) label-ID, with the actual labels
kept outside the routing table.
ID allocator code inspired by my own code for altq and pf tags.
mostly hacked at the c2k4 hackathon, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.41 2004/06/24 22:25:25 henning Exp $	*/
d405 7
@


1.41
log
@KNF, cleanup, readability fixes... this hurt
ok itojun claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.40 2004/06/22 07:35:20 cedric Exp $	*/
d183 2
d325 12
@


1.40
log
@Pull the plug on source-based routing until remaining bugs are eradicated.
No need to reconfig kernel or rebuild userland stuff.
requested deraadt@@, help beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.39 2004/06/06 16:49:09 cedric Exp $	*/
d82 3
a84 3
struct	sockaddr route_dst = { 2, PF_ROUTE, };
struct	sockaddr route_src = { 2, PF_ROUTE, };
struct	sockproto route_proto = { PF_ROUTE, };
d91 4
a94 5
static struct mbuf *
		rt_msg1(int, struct rt_addrinfo *);
static int	rt_msg2(int,
		    struct rt_addrinfo *, caddr_t, struct walkarg *);
static void	rt_xaddrs(caddr_t, caddr_t, struct rt_addrinfo *);
a104 1
/*ARGSUSED*/
d106 6
a111 8
route_usrreq(so, req, m, nam, control)
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
{
	int error = 0;
	struct rawcb *rp = sotorawcb(so);
	int s;
d148 1
a148 1
			free((caddr_t)rp, M_PCB);
a168 1
/*ARGSUSED*/
d172 12
a183 11
	struct rt_msghdr *rtm = 0;
	struct radix_node *rn = 0;
	struct rtentry *rt = 0;
	struct rtentry *saved_nrt = 0;
	struct radix_node_head *rnh;
	struct rt_addrinfo info;
	int len, error = 0;
	struct ifnet *ifp = 0;
	struct ifaddr *ifa = 0;
	struct socket *so;
	va_list ap;
a188 1
#define senderr(e) do { error = e; goto flush;} while (0)
d190 1
a190 1
		       (m = m_pullup(m, sizeof(int32_t))) == 0))
d198 2
a199 1
		senderr(EINVAL);
d204 2
a205 1
		senderr(ENOBUFS);
d210 2
a211 1
		senderr(EPROTONOSUPPORT);
d214 1
d219 5
a223 4
	if (dst == 0 || (dst->sa_family >= AF_MAX))
		senderr(EINVAL);
	if (gate != 0 && (gate->sa_family >= AF_MAX))
		senderr(EINVAL);
d225 4
a228 3
		struct radix_node *t;
		t = rn_addmask((caddr_t)genmask, 0, 1);
		if (t && genmask->sa_len >= ((struct sockaddr *)t->rn_key)->sa_len &&
d232 4
a235 2
		else
			senderr(ENOBUFS);
d242 5
a246 2
	if (rtm->rtm_type != RTM_GET && suser(curproc, 0) != 0)
		senderr(EACCES);
a247 1

d249 4
a252 2
		if (gate == 0)
			senderr(EINVAL);
d255 2
a256 2
			rt_setmetrics(rtm->rtm_inits,
				&rtm->rtm_rmx, &saved_nrt->rt_rmx);
d272 2
a273 1
			senderr(EAFNOSUPPORT);
d277 2
a278 1
			senderr(ESRCH);
d294 4
a297 2
			if (!rt)
				senderr(ESRCH);
d312 2
a313 1
				senderr(ESRCH);
a316 1

d318 1
a318 1
		report:
d323 12
a334 14
			if (rtm->rtm_addrs & (RTA_IFP | RTA_IFA)) {
				if ((ifp = rt->rt_ifp) != NULL) {
					ifpaddr =
					    TAILQ_FIRST(&ifp->if_addrlist)->ifa_addr;
					ifaaddr = rt->rt_ifa->ifa_addr;
					if (ifp->if_flags & IFF_POINTOPOINT)
						brdaddr = rt->rt_ifa->ifa_dstaddr;
					else
						brdaddr = 0;
					rtm->rtm_index = ifp->if_index;
				} else {
					ifpaddr = 0;
					ifaaddr = 0;
				}
d336 1
a336 2
			len = rt_msg2(rtm->rtm_type, &info, (caddr_t)0,
				(struct walkarg *)0);
d338 1
a338 1
				struct rt_msghdr *new_rtm;
d340 4
a343 2
				if (new_rtm == 0)
					senderr(ENOBUFS);
d347 1
a347 2
			(void)rt_msg2(rtm->rtm_type, &info, (caddr_t)rtm,
				(struct walkarg *)0);
d360 5
a364 3
				senderr(error);
			if (gate && rt_setgate(rt, rt_key(rt), gate))
				senderr(EDQUOT);
d370 2
a371 2
				 (gate && (ifa = ifa_ifwithroute(rt->rt_flags,
							rt_key(rt), gate))))
d386 1
a386 1
					&rt->rt_rmx);
d388 1
a388 1
			       rt->rt_ifa->ifa_rtrequest(RTM_ADD, rt, &info);
d391 1
a391 3
			/*
			 * Fall into
			 */
d395 1
a395 1
				(rtm->rtm_inits & rtm->rtm_rmx.rmx_locks);
d401 2
a402 1
		senderr(EOPNOTSUPP);
d414 1
a414 2
    {
	struct rawcb *rp = 0;
d418 1
a418 1
	if ((so->so_options & SO_USELOOPBACK) == 0) {
d445 1
a445 1
    }
d450 6
a455 9
rt_setmetrics(which, in, out)
	u_long which;
	struct rt_metrics *in;
	struct rt_kmetrics *out;
{
#define metric(f, e) if (which & (f)) out->e = in->e;
	metric(RTV_MTU, rmx_mtu);
	metric(RTV_EXPIRE, rmx_expire);
#undef metric
d459 1
a459 3
rt_getmetrics(in, out)
        struct rt_kmetrics *in;
        struct rt_metrics *out;
a460 1
#define metric(e) out->e = in->e;
d462 4
a465 5
	metric(rmx_locks);
	metric(rmx_mtu);
	metric(rmx_expire);
	metric(rmx_pksent);
#undef metric
d473 1
a473 3
rt_xaddrs(cp, cplim, rtinfo)
	caddr_t cp, cplim;
	struct rt_addrinfo *rtinfo;
d475 2
a476 2
	struct sockaddr *sa;
	int i;
d488 7
a494 9
rt_msg1(type, rtinfo)
	int type;
	struct rt_addrinfo *rtinfo;
{
	struct rt_msghdr *rtm;
	struct mbuf *m;
	int i;
	struct sockaddr *sa;
	int len, dlen;
a496 1

a500 1

a503 1

a506 1

d509 1
d524 1
a524 1
	m->m_pkthdr.rcvif = 0;
d526 1
a526 1
	bzero((caddr_t)rtm, len);
d546 5
a550 9
rt_msg2(type, rtinfo, cp, w)
	int type;
	struct rt_addrinfo *rtinfo;
	caddr_t cp;
	struct walkarg *w;
{
	int i;
	int len, dlen, second_time = 0;
	caddr_t cp0;
a554 1

a558 1

a561 1

d564 1
d576 1
a576 1
			bcopy((caddr_t)sa, cp, (unsigned)dlen);
d589 1
a589 2
				rw->w_tmem = (caddr_t) malloc(len, M_RTABLE,
							      M_NOWAIT);
d618 5
a622 7
rt_missmsg(type, rtinfo, flags, error)
	int type, flags, error;
	struct rt_addrinfo *rtinfo;
{
	struct rt_msghdr *rtm;
	struct mbuf *m;
	struct sockaddr *sa = rtinfo->rti_info[RTAX_DST];
d633 4
a636 1
	route_proto.sp_protocol = sa ? sa->sa_family : 0;
d645 1
a645 2
rt_ifmsg(ifp)
	struct ifnet *ifp;
d647 3
a649 3
	struct if_msghdr *ifm;
	struct mbuf *m;
	struct rt_addrinfo info;
d653 1
a653 1
	bzero((caddr_t)&info, sizeof(info));
d675 7
a681 10
rt_newaddrmsg(cmd, ifa, error, rt)
	int cmd, error;
	struct ifaddr *ifa;
	struct rtentry *rt;
{
	struct rt_addrinfo info;
	struct sockaddr *sa = NULL;
	int pass;
	struct mbuf *m = NULL;
	struct ifnet *ifp = ifa->ifa_ifp;
d686 1
a686 1
		bzero((caddr_t)&info, sizeof(info));
d689 7
a695 2
			struct ifa_msghdr *ifam;
			int ncmd = cmd == RTM_ADD ? RTM_NEWADDR : RTM_DELADDR;
d726 4
a729 1
		route_proto.sp_protocol = sa ? sa->sa_family : 0;
d739 5
a743 7
rt_ifannouncemsg(ifp, what)
	struct ifnet *ifp;
	int what;
{
	struct if_announcemsghdr *ifan;
	struct mbuf *m;
	struct rt_addrinfo info;
d763 6
a768 8
sysctl_dumpentry(rn, v)
	struct radix_node *rn;
	void *v;
{
	struct walkarg *w = v;
	struct rtentry *rt = (struct rtentry *)rn;
	int error = 0, size;
	struct rt_addrinfo info;
d772 1
a772 1
	bzero((caddr_t)&info, sizeof(info));
d783 1
a783 1
	size = rt_msg2(RTM_GET, &info, 0, w);
d793 1
a793 1
		if ((error = copyout((caddr_t)rtm, w->w_where, size)) != 0)
d802 6
a807 8
sysctl_iflist(af, w)
	int	af;
	struct	walkarg *w;
{
	struct ifnet *ifp;
	struct ifaddr *ifa;
	struct	rt_addrinfo info;
	int	len, error = 0;
d809 1
a809 1
	bzero((caddr_t)&info, sizeof(info));
d817 1
a817 1
		len = rt_msg2(RTM_IFINFO, &info, (caddr_t)0, w);
d827 1
a827 1
			error = copyout((caddr_t)ifm, w->w_where, len);
d860 7
a866 12
sysctl_rtable(name, namelen, where, given, new, newlen)
	int	*name;
	u_int	namelen;
	void 	*where;
	size_t	*given;
	void	*new;
	size_t	newlen;
{
	struct radix_node_head *rnh;
	int	i, s, error = EINVAL;
	u_char  af;
	struct	walkarg w;
d873 1
a873 1
	Bzero(&w, sizeof(w));
d888 1
a888 2
							  sysctl_dumpentry,
							  &w)))
d900 1
a900 1
		*given = w.w_where - (caddr_t) where;
d903 1
a903 1
	} else {
d905 1
a905 1
	}
@


1.39
log
@extend routing table to be able to match and route packets based on
their *source* IP address in addition to their destination address.
routing table "destination" now contains a "struct sockaddr_rtin"
for IPv4 instead of a "struct sockaddr_in".
the routing socket has been extended in a backward-compatible way.
todo: PMTU enhancements, IPv6. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.38 2004/05/12 20:46:00 claudio Exp $	*/
a223 1
	sroute_compact(&info, rtm->rtm_type);
a326 1
			sroute_expand(&info);
a639 1
	sroute_expand(rtinfo);
a727 1
			sroute_expand(&info);
a793 1
	sroute_expand(&info);
@


1.38
log
@Rework a block readded by the multipath commit that should ensure that
RTM_CHANGE/LOCK only work on perfect matching routes. ppp and bgpd got
broken because of this. Most of the code in the "grotty" block is already
done by rn_lookup() only host routes need some special treatment.
OK cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.37 2004/05/04 22:50:18 claudio Exp $	*/
d224 1
d328 1
d642 1
d731 1
d798 1
@


1.37
log
@The tcp specific routing metrics are almost never used so reduce the routing
table from these metrics. struct rt_msghdr used by the routing socket is not
affected and so most userland apps don't need to be changed.
some man page polishing by jmc@@
OK henning@@ markus@@ theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.36 2004/04/25 02:48:04 itojun Exp $	*/
a242 8
	case RTM_DELETE:
		error = rtrequest1(rtm->rtm_type, &info, &saved_nrt);
		if (error == 0) {
			(rt = saved_nrt)->rt_refcnt++;
			goto report;
		}
		break;

d253 8
a260 1
		/* FALLTHROUGH */
a289 3
		if (rtm->rtm_type != RTM_GET) {/* XXX: too grotty */
			struct radix_node *rn;
			extern struct radix_node_head *mask_rnhead;
d291 10
a300 1
			if (Bcmp(dst, rt_key(rt), dst->sa_len) != 0)
a301 9
			if (netmask && (rn = rn_search(netmask,
					    mask_rnhead->rnh_treetop)))
				netmask = (struct sockaddr *)rn->rn_key;
			for (rn = rt->rt_nodes; rn; rn = rn->rn_dupedkey)
				if (netmask == (struct sockaddr *)rn->rn_mask)
					break;
			if (rn == 0)
				senderr(ETOOMANYREFS);
			rt = (struct rtentry *)rn;
a382 1
		case RTM_ADD:
@


1.36
log
@radix tree with multipath support.  from kame.  deraadt ok
user visible changes:
- you can add multiple routes with same key (route add A B then route add A C)
- you have to specify gateway address if there are multiple entries on the table
  (route delete A B, instead of route delete A)
kernel change:
- radix_node_head has an extra entry
- rnh_deladdr takes extra argument

TODO:
- actually take advantage of multipath (rtalloc -> rtalloc_mpath)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.35 2004/01/15 10:47:55 markus Exp $	*/
d344 1
a344 1
			rtm->rtm_rmx = rt->rt_rmx;
d448 2
a449 1
	struct rt_metrics *in, *out;
a451 6
	metric(RTV_RPIPE, rmx_recvpipe);
	metric(RTV_SPIPE, rmx_sendpipe);
	metric(RTV_SSTHRESH, rmx_ssthresh);
	metric(RTV_RTT, rmx_rtt);
	metric(RTV_RTTVAR, rmx_rttvar);
	metric(RTV_HOPCOUNT, rmx_hopcount);
d457 14
d805 1
a805 1
		rtm->rtm_rmx = rt->rt_rmx;
@


1.35
log
@add a RTM_IFANNOUNCE message; from netbsd; ok itojun, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.34 2004/01/03 14:08:53 espie Exp $	*/
d273 17
d291 16
@


1.34
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.33 2003/12/10 07:22:42 itojun Exp $	*/
d472 4
d702 27
@


1.33
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.32 2003/08/15 20:32:19 tedu Exp $	*/
d80 1
a80 1
#include <machine/stdarg.h>
@


1.32
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.31 2003/08/14 19:00:12 jason Exp $	*/
d109 1
a109 1
	register struct socket *so;
d113 2
a114 2
	register int error = 0;
	register struct rawcb *rp = sotorawcb(so);
d177 3
a179 3
	register struct rt_msghdr *rtm = 0;
	register struct radix_node *rn = 0;
	register struct rtentry *rt = 0;
d334 1
a334 1
				register struct ifaddr *oifa = rt->rt_ifa;
d377 1
a377 1
	register struct rawcb *rp = 0;
d415 1
a415 1
	register struct rt_metrics *in, *out;
d435 2
a436 2
	register caddr_t cp, cplim;
	register struct rt_addrinfo *rtinfo;
d438 2
a439 2
	register struct sockaddr *sa;
	register int i;
d453 1
a453 1
	register struct rt_addrinfo *rtinfo;
d455 4
a458 4
	register struct rt_msghdr *rtm;
	register struct mbuf *m;
	register int i;
	register struct sockaddr *sa;
d512 1
a512 1
	register struct rt_addrinfo *rtinfo;
d516 1
a516 1
	register int i;
d539 1
a539 1
		register struct sockaddr *sa;
d552 1
a552 1
		register struct walkarg *rw = w;
d573 1
a573 1
		register struct rt_msghdr *rtm = (struct rt_msghdr *)cp0;
d591 1
a591 1
	register struct rt_addrinfo *rtinfo;
d593 2
a594 2
	register struct rt_msghdr *rtm;
	register struct mbuf *m;
d616 1
a616 1
	register struct ifnet *ifp;
d618 1
a618 1
	register struct if_msghdr *ifm;
d648 2
a649 2
	register struct ifaddr *ifa;
	register struct rtentry *rt;
d663 1
a663 1
			register struct ifa_msghdr *ifam;
d680 1
a680 1
			register struct rt_msghdr *rtm;
d706 1
a706 1
	register void *v;
d708 2
a709 2
	register struct walkarg *w = v;
	register struct rtentry *rt = (struct rtentry *)rn;
d728 1
a728 1
		register struct rt_msghdr *rtm = (struct rt_msghdr *)w->w_tmem;
d747 1
a747 1
	register struct	walkarg *w;
d749 2
a750 2
	register struct ifnet *ifp;
	register struct ifaddr *ifa;
d765 1
a765 1
			register struct if_msghdr *ifm;
d786 1
a786 1
				register struct ifa_msghdr *ifam;
d813 1
a813 1
	register struct radix_node_head *rnh;
@


1.31
log
@m_copyback()'s 4th arg is const void *, nuke (caddr_t) casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.30 2003/07/05 00:00:32 itojun Exp $	*/
d239 1
a239 2
	if (rtm->rtm_type != RTM_GET &&
	    suser(curproc->p_ucred, &curproc->p_acflag) != 0)
@


1.30
log
@backout 1.29; problem reported by Rukh w/ userland ppp.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.29 2003/06/24 09:09:25 itojun Exp $	*/
d397 1
a397 1
		m_copyback(m, 0, rtm->rtm_msglen, (caddr_t)rtm);
d497 1
a497 1
		m_copyback(m, len, dlen, (caddr_t)sa);
@


1.29
log
@recover code that requires exact match on rtm_change/lock (lost in netbsd 1.16).
without it "route change X" would change less-specific route by mistake.
reported by jinmei@@kame, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.28 2003/06/02 23:28:12 millert Exp $	*/
a274 16
		if (rtm->rtm_type != RTM_GET) {/* XXX: too grotty */
			struct radix_node *rn;
			extern struct radix_node_head *mask_rnhead;

			if (Bcmp(dst, rt_key(rt), dst->sa_len) != 0)
				senderr(ESRCH);
			if (netmask && (rn = rn_search(netmask,
					    mask_rnhead->rnh_treetop)))
				netmask = (struct sockaddr *)rn->rn_key;
			for (rn = rt->rt_nodes; rn; rn = rn->rn_dupedkey)
				if (netmask == (struct sockaddr *)rn->rn_mask)
					break;
			if (rn == 0)
				senderr(ETOOMANYREFS);
			rt = (struct rtentry *)rn;
		}
@


1.28
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.27 2003/04/23 01:36:52 jason Exp $	*/
d275 16
@


1.27
log
@Move m_copyback() to uipc_mbuf where it makes some kinda sense; ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.26 2003/02/16 21:30:13 deraadt Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.26
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.25 2002/12/31 02:30:10 itojun Exp $	*/
a452 54
}

/*
 * Copy data from a buffer back into the indicated mbuf chain,
 * starting "off" bytes from the beginning, extending the mbuf
 * chain if necessary. The mbuf needs to be properly initialized
 * including the setting of m_len.
 */
void
m_copyback(m0, off, len, cp)
	struct	mbuf *m0;
	register int off;
	register int len;
	caddr_t cp;
{
	register int mlen;
	register struct mbuf *m = m0, *n;
	int totlen = 0;

	if (m0 == 0)
		return;
	while (off > (mlen = m->m_len)) {
		off -= mlen;
		totlen += mlen;
		if (m->m_next == 0) {
			n = m_getclr(M_DONTWAIT, m->m_type);
			if (n == 0)
				goto out;
			n->m_len = min(MLEN, len + off);
			m->m_next = n;
		}
		m = m->m_next;
	}
	while (len > 0) {
		mlen = min (m->m_len - off, len);
		bcopy(cp, off + mtod(m, caddr_t), (unsigned)mlen);
		cp += mlen;
		len -= mlen;
		mlen += off;
		off = 0;
		totlen += mlen;
		if (len == 0)
			break;
		if (m->m_next == 0) {
			n = m_get(M_DONTWAIT, m->m_type);
			if (n == 0)
				break;
			n->m_len = min(MLEN, len);
			m->m_next = n;
		}
		m = m->m_next;
	}
out:	if (((m = m0)->m_flags & M_PKTHDR) && (m->m_pkthdr.len < totlen))
		m->m_pkthdr.len = totlen;
@


1.25
log
@don't overrun user-supplied buffer.  from jinmei@@kame, deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.24 2002/07/17 14:20:19 art Exp $	*/
d280 1
a280 1
		switch(rtm->rtm_type) {
@


1.24
log
@Don't dereference freed memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.23 2002/07/03 02:31:00 mickey Exp $	*/
d786 1
a786 1
	if (w->w_where && w->w_tmem) {
d823 1
a823 1
		if (w->w_where && w->w_tmem) {
d844 1
a844 1
			if (w->w_where && w->w_tmem) {
@


1.23
log
@fix a null deref in sysctl_iflist()
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.22 2002/07/02 19:38:55 nate Exp $	*/
d396 4
a408 4
	if (rp)
		rp->rcb_proto.sp_family = 0; /* Avoid us */
	if (dst)
		route_proto.sp_protocol = dst->sa_family;
@


1.22
log
@inital -> initial
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.21 2002/03/15 18:19:52 millert Exp $	*/
d818 2
@


1.21
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.20 2002/03/14 01:27:10 millert Exp $	*/
d458 1
a458 1
 * chain if necessary. The mbuf needs to be properly initalized
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.19 2001/12/10 06:10:53 jason Exp $	*/
a178 1
#if __STDC__
a179 5
#else
route_output(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.19
log
@use queue.h macros for TAILQ operations
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.18 2001/11/06 19:53:20 miod Exp $	*/
d96 4
a99 4
		rt_msg1 __P((int, struct rt_addrinfo *));
static int	rt_msg2 __P((int,
		    struct rt_addrinfo *, caddr_t, struct walkarg *));
static void	rt_xaddrs __P((caddr_t, caddr_t, struct rt_addrinfo *));
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.19 2001/12/10 06:10:53 jason Exp $	*/
d96 4
a99 4
		rt_msg1(int, struct rt_addrinfo *);
static int	rt_msg2(int,
		    struct rt_addrinfo *, caddr_t, struct walkarg *);
static void	rt_xaddrs(caddr_t, caddr_t, struct rt_addrinfo *);
d179 1
d181 5
@


1.19.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.19.2.1 2002/06/11 03:30:46 art Exp $	*/
a395 4
	if (rp)
		rp->rcb_proto.sp_family = 0; /* Avoid us */
	if (dst)
		route_proto.sp_protocol = dst->sa_family;
d405 4
d458 1
a458 1
 * chain if necessary. The mbuf needs to be properly initialized
a817 2
		if (!ifa)
			continue;
@


1.19.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d280 1
a280 1
		switch (rtm->rtm_type) {
d455 54
d786 1
a786 1
	if (w->w_where && w->w_tmem && w->w_needed <= 0) {
d823 1
a823 1
		if (w->w_where && w->w_tmem && w->w_needed <= 0) {
d844 1
a844 1
			if (w->w_where && w->w_tmem && w->w_needed <= 0) {
@


1.18
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.17 2001/09/20 17:02:31 mpech Exp $	*/
d296 2
a297 1
					ifpaddr = ifp->if_addrlist.tqh_first->ifa_addr;
d732 1
a732 1
			ifpaddr = ifp->if_addrlist.tqh_first->ifa_addr;
d786 1
a786 1
		ifpaddr = rt->rt_ifp->if_addrlist.tqh_first->ifa_addr;
d820 1
a820 1
	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next) {
d823 1
a823 1
		ifa = ifp->if_addrlist.tqh_first;
d840 2
a841 1
		while ((ifa = ifa->ifa_list.tqe_next) != NULL) {
@


1.17
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.16 2001/07/21 12:22:57 itojun Exp $	*/
d77 1
a77 1
#include <vm/vm.h>
@


1.16
log
@repair validation on RTAX_GENMASK insertion.  has been broken since 44bsd.
(freebsd3 has a fix since 1999, but has insufficient validation on sa_len)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.15 2001/06/04 23:21:10 itojun Exp $	*/
d648 1
a648 1
 * socket indicating that a redirect has occured, a routing lookup
@


1.15
log
@adjust routing socket message (kernel -> user) to the right size.
with old code we may see junk at the end.  sync with kame, 4.4BSD bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.14 2001/05/16 12:53:34 ho Exp $	*/
d237 3
a239 1
		if (t && Bcmp(genmask, t->rn_key, *(u_char *)genmask) == 0)
@


1.14
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.13 2001/01/19 06:37:37 itojun Exp $	*/
d401 5
d412 2
a413 1
	raw_input(m, &route_proto, &route_src, &route_dst);
@


1.13
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.12 2000/12/13 21:58:11 provos Exp $	*/
d123 2
a124 3
		if ((so->so_pcb = rp) != NULL)
			bzero(so->so_pcb, sizeof(*rp));

@


1.12
log
@have add set locks, too. okay itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.11 2000/03/12 01:27:11 itojun Exp $	*/
a203 1
	bzero(&info, sizeof(info));
d227 1
d230 4
a233 1
	if (dst == 0)
d254 1
a254 2
		error = rtrequest(RTM_DELETE, dst, gate, netmask,
				rtm->rtm_flags, &saved_nrt);
d264 1
a264 2
		error = rtrequest(RTM_ADD, dst, gate, netmask,
					rtm->rtm_flags, &saved_nrt);
d305 1
a305 1
			    }
d325 7
a333 3
			/* new gateway could require new ifaddr, ifp;
			   flags may also be different; ifp may be specified
			   by ll sockaddr when protocol address is ambiguous */
d346 2
a347 2
					oifa->ifa_rtrequest(RTM_DELETE,
								rt, gate);
d357 1
a357 1
			       rt->rt_ifa->ifa_rtrequest(RTM_ADD, rt, gate);
@


1.11
log
@don't touch root radix node on RTM_*.  this can panic system from
non-root userland process, under certain routing table setup.
http://orange.kame.net/dev/query-pr.cgi?pr=217
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.10 2000/02/17 04:15:29 itojun Exp $	*/
d250 9
d270 1
a270 11
		break;

	case RTM_DELETE:
		error = rtrequest(RTM_DELETE, dst, gate, netmask,
				rtm->rtm_flags, &saved_nrt);
		if (error == 0) {
			(rt = saved_nrt)->rt_refcnt++;
			goto report;
		}
		break;

d358 1
@


1.10
log
@backout incomplete hack from KAME codebase (originally from bbn).

the hack tries to respect ifa or ifp passed to RTM_ADD.  However, the change
broke certain link-layers.  They include:
- midway ethernet card (en*), which uses sockaddr_dl in gateway portion
  to pass PVC information.  with the patch, the gateway portion will be
  overwritten by empty sockaddr_dl and PVC initialization will fail.
- IPv6, which can't set static ND table with the patch (ndp -s) with the
  similar reason.

There may be improved hack coming soon, hope the new one does not break others.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.9 2000/02/07 06:08:04 itojun Exp $	*/
d189 1
d205 1
a205 1
#define senderr(e) { error = e; goto flush;}
d277 3
a279 4
		} else if ((rt = (struct rtentry *)
				rnh->rnh_lookup(dst, netmask, rnh)) != NULL)
			rt->rt_refcnt++;
		else
d281 4
@


1.9
log
@make more check about mbuf len before rolling message for routing header.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.8 1999/12/08 06:50:18 itojun Exp $	*/
a99 2
static void rt_setif __P((struct rtentry *, struct sockaddr *,
	struct sockaddr *, struct sockaddr *));
d195 1
a254 29
			/* 
			 * If the route request specified an interface with
			 * IFA and/or IFP, we set the requested interface on
			 * the route with rt_setif.  It would be much better
			 * to do this inside rtrequest, but that would
			 * require passing the desired interface, in some
			 * form, to rtrequest.  Since rtrequest is called in
			 * so many places (roughly 40 in our source), adding
			 * a parameter is to much for us to swallow; this is
			 * something for the FreeBSD developers to tackle.
			 * Instead, we let rtrequest compute whatever
			 * interface it wants, then come in behind it and
			 * stick in the interface that we really want.  This
			 * works reasonably well except when rtrequest can't
			 * figure out what interface to use (with
			 * ifa_withroute) and returns ENETUNREACH.  Ideally
			 * it shouldn't matter if rtrequest can't figure out
			 * the interface if we're going to explicitly set it
			 * ourselves anyway.  But practically we can't
			 * recover here because rtrequest will not do any of
			 * the work necessary to add the route if it can't
			 * find an interface.  As long as there is a default
			 * route that leads to some interface, rtrequest will
			 * find an interface, so this problem should be
			 * rarely encountered.
			 * dwiggins@@bbn.com
			 */

			rt_setif(saved_nrt, ifpaddr, ifaaddr, gate);
a322 4

#if 1
			rt_setif(rt, ifpaddr, ifaaddr, gate);
#else
a345 1
#endif
a347 1
#if 0
a349 1
#endif
a421 50

/*
 * Set route's interface given ifpaddr, ifaaddr, and gateway.
 */
static void
rt_setif(rt, Ifpaddr, Ifaaddr, Gate)
	struct rtentry *rt;
	struct sockaddr *Ifpaddr, *Ifaaddr, *Gate;
{
	struct ifaddr *ifa = 0;
	struct ifnet  *ifp = 0;

	/* new gateway could require new ifaddr, ifp;
	   flags may also be different; ifp may be specified
	   by ll sockaddr when protocol address is ambiguous */
	if (Ifpaddr && (ifa = ifa_ifwithnet(Ifpaddr)) &&
	    (ifp = ifa->ifa_ifp) && (Ifaaddr || Gate))
		ifa = ifaof_ifpforaddr(Ifaaddr ? Ifaaddr : Gate,
					ifp);
	else if (Ifpaddr && (ifp = if_withname(Ifpaddr)) ) {
		ifa = Gate ? ifaof_ifpforaddr(Gate, ifp) :
				TAILQ_FIRST(&ifp->if_addrlist);
	}
	else if ((Ifaaddr && (ifa = ifa_ifwithaddr(Ifaaddr))) ||
		 (Gate && (ifa = ifa_ifwithroute(rt->rt_flags,
					rt_key(rt), Gate))))
		ifp = ifa->ifa_ifp;
	if (ifa) {
		register struct ifaddr *oifa = rt->rt_ifa;
		if (oifa != ifa) {
		    if (oifa && oifa->ifa_rtrequest)
			oifa->ifa_rtrequest(RTM_DELETE,
						rt, Gate);
		    IFAFREE(rt->rt_ifa);
		    rt->rt_ifa = ifa;
		    ifa->ifa_refcnt++;
		    rt->rt_ifp = ifp;
		    rt->rt_rmx.rmx_mtu = ifp->if_mtu;
		    if (rt->rt_ifa && rt->rt_ifa->ifa_rtrequest)
			rt->rt_ifa->ifa_rtrequest(RTM_ADD, rt, Gate);
		} else
			goto call_ifareq;
		return;
	}
      call_ifareq:
	/* XXX: to reset gateway to correct value, at RTM_CHANGE */
	if (rt->rt_ifa && rt->rt_ifa->ifa_rtrequest)
		rt->rt_ifa->ifa_rtrequest(RTM_ADD, rt, Gate);
}

@


1.9.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.10 2000/02/17 04:15:29 itojun Exp $	*/
d100 2
a196 1
	struct ifaddr *ifa = 0;
d256 29
d353 4
d380 1
d383 1
d386 1
d459 50
@


1.9.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a188 1
	register struct radix_node *rn = 0;
d204 1
a204 1
#define senderr(e) do { error = e; goto flush;} while (0)
d276 4
a279 3
		}
		rn = rnh->rnh_lookup(dst, netmask, rnh);
		if (rn == NULL || (rn->rn_flags & RNF_ROOT) != 0) {
a280 4
		}
		rt = (struct rtentry *)rn;
		rt->rt_refcnt++;

@


1.9.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.13 2001/01/19 06:37:37 itojun Exp $	*/
d204 1
a227 1
	bzero(&info, sizeof(info));
d230 1
a230 4
	info.rti_flags = rtm->rtm_flags;
	if (dst == 0 || (dst->sa_family >= AF_MAX))
		senderr(EINVAL);
	if (gate != 0 && (gate->sa_family >= AF_MAX))
a249 8
	case RTM_DELETE:
		error = rtrequest1(rtm->rtm_type, &info, &saved_nrt);
		if (error == 0) {
			(rt = saved_nrt)->rt_refcnt++;
			goto report;
		}
		break;

d253 2
a254 1
		error = rtrequest1(rtm->rtm_type, &info, &saved_nrt);
d261 11
a271 1
		/* FALLTHROUGH */
d305 1
a305 1
				}
a324 7
			/*
			 * new gateway could require new ifaddr, ifp;
			 * flags may also be different; ifp may be specified
			 * by ll sockaddr when protocol address is ambiguous
			 */
			if ((error = rt_getifa(&info)) != 0)
				senderr(error);
d327 3
d342 2
a343 2
					oifa->ifa_rtrequest(RTM_DELETE, rt,
					    &info);
d353 1
a353 1
			       rt->rt_ifa->ifa_rtrequest(RTM_ADD, rt, &info);
a358 1
		case RTM_ADD:
@


1.9.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.9.2.3 2001/05/14 22:40:04 niklas Exp $	*/
d123 3
a125 2
		so->so_pcb = rp;
		bzero(so->so_pcb, sizeof(*rp));
a401 5
		if (m->m_pkthdr.len < rtm->rtm_msglen) {
			m_freem(m);
			m = NULL;
		} else if (m->m_pkthdr.len > rtm->rtm_msglen)
			m_adj(m, rtm->rtm_msglen - m->m_pkthdr.len);
d408 1
a408 2
	if (m)
		raw_input(m, &route_proto, &route_src, &route_dst);
@


1.9.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.9.2.4 2001/07/04 10:54:20 niklas Exp $	*/
d237 1
a237 3
		if (t && genmask->sa_len >= ((struct sockaddr *)t->rn_key)->sa_len &&
		    Bcmp((caddr_t *)genmask + 1, (caddr_t *)t->rn_key + 1,
		    ((struct sockaddr *)t->rn_key)->sa_len) - 1)
d646 1
a646 1
 * socket indicating that a redirect has occurred, a routing lookup
@


1.9.2.6
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 1
a77 1
#include <uvm/uvm_extern.h>
@


1.9.2.7
log
@Merge in trunk
@
text
@d296 1
a296 2
					ifpaddr =
					    TAILQ_FIRST(&ifp->if_addrlist)->ifa_addr;
d731 1
a731 1
			ifpaddr = TAILQ_FIRST(&ifp->if_addrlist)->ifa_addr;
d785 1
a785 1
		ifpaddr = TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
d819 1
a819 1
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
d822 1
a822 1
		ifa = TAILQ_FIRST(&ifp->if_addrlist);
d839 1
a839 2
		while ((ifa = TAILQ_NEXT(ifa, ifa_list)) !=
		    TAILQ_END(&ifp->if_addrlist)) {
@


1.9.2.8
log
@Merge in -current from roughly a week ago
@
text
@d96 4
a99 4
		rt_msg1(int, struct rt_addrinfo *);
static int	rt_msg2(int,
		    struct rt_addrinfo *, caddr_t, struct walkarg *);
static void	rt_xaddrs(caddr_t, caddr_t, struct rt_addrinfo *);
d179 1
d181 5
@


1.9.2.9
log
@Sync the SMP branch with 3.3
@
text
@d280 1
a280 1
		switch (rtm->rtm_type) {
a395 4
	if (rp)
		rp->rcb_proto.sp_family = 0; /* Avoid us */
	if (dst)
		route_proto.sp_protocol = dst->sa_family;
d405 4
d458 1
a458 1
 * chain if necessary. The mbuf needs to be properly initialized
d786 1
a786 1
	if (w->w_where && w->w_tmem && w->w_needed <= 0) {
a817 2
		if (!ifa)
			continue;
d821 1
a821 1
		if (w->w_where && w->w_tmem && w->w_needed <= 0) {
d842 1
a842 1
			if (w->w_where && w->w_tmem && w->w_needed <= 0) {
@


1.9.2.10
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.9.2.9 2003/03/28 00:41:29 niklas Exp $	*/
d453 54
@


1.9.2.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.9.2.10 2003/05/13 19:36:16 ho Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.2.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 1
#include <sys/stdarg.h>
d109 1
a109 1
	struct socket *so;
d113 2
a114 2
	int error = 0;
	struct rawcb *rp = sotorawcb(so);
d177 3
a179 3
	struct rt_msghdr *rtm = 0;
	struct radix_node *rn = 0;
	struct rtentry *rt = 0;
d239 2
a240 1
	if (rtm->rtm_type != RTM_GET && suser(curproc, 0) != 0)
d335 1
a335 1
				struct ifaddr *oifa = rt->rt_ifa;
d378 1
a378 1
	struct rawcb *rp = 0;
d397 1
a397 1
		m_copyback(m, 0, rtm->rtm_msglen, rtm);
d416 1
a416 1
	struct rt_metrics *in, *out;
d436 2
a437 2
	caddr_t cp, cplim;
	struct rt_addrinfo *rtinfo;
d439 2
a440 2
	struct sockaddr *sa;
	int i;
d454 1
a454 1
	struct rt_addrinfo *rtinfo;
d456 4
a459 4
	struct rt_msghdr *rtm;
	struct mbuf *m;
	int i;
	struct sockaddr *sa;
a472 4
	case RTM_IFANNOUNCE:
		len = sizeof(struct if_announcemsghdr);
		break;

d497 1
a497 1
		m_copyback(m, len, dlen, sa);
d513 1
a513 1
	struct rt_addrinfo *rtinfo;
d517 1
a517 1
	int i;
d540 1
a540 1
		struct sockaddr *sa;
d553 1
a553 1
		struct walkarg *rw = w;
d574 1
a574 1
		struct rt_msghdr *rtm = (struct rt_msghdr *)cp0;
d592 1
a592 1
	struct rt_addrinfo *rtinfo;
d594 2
a595 2
	struct rt_msghdr *rtm;
	struct mbuf *m;
d617 1
a617 1
	struct ifnet *ifp;
d619 1
a619 1
	struct if_msghdr *ifm;
d649 2
a650 2
	struct ifaddr *ifa;
	struct rtentry *rt;
d664 1
a664 1
			struct ifa_msghdr *ifam;
d681 1
a681 1
			struct rt_msghdr *rtm;
a701 27
 * This is called to generate routing socket messages indicating
 * network interface arrival and departure.
 */
void
rt_ifannouncemsg(ifp, what)
	struct ifnet *ifp;
	int what;
{
	struct if_announcemsghdr *ifan;
	struct mbuf *m;
	struct rt_addrinfo info;

	if (route_cb.any_count == 0)
		return;
	bzero(&info, sizeof(info));
	m = rt_msg1(RTM_IFANNOUNCE, &info);
	if (m == 0)
		return;
	ifan = mtod(m, struct if_announcemsghdr *);
	ifan->ifan_index = ifp->if_index;
	strlcpy(ifan->ifan_name, ifp->if_xname, sizeof(ifan->ifan_name));
	ifan->ifan_what = what;
	route_proto.sp_protocol = 0;
	raw_input(m, &route_proto, &route_src, &route_dst);
}

/*
d707 1
a707 1
	void *v;
d709 2
a710 2
	struct walkarg *w = v;
	struct rtentry *rt = (struct rtentry *)rn;
d729 1
a729 1
		struct rt_msghdr *rtm = (struct rt_msghdr *)w->w_tmem;
d748 1
a748 1
	struct	walkarg *w;
d750 2
a751 2
	struct ifnet *ifp;
	struct ifaddr *ifa;
d766 1
a766 1
			struct if_msghdr *ifm;
d787 1
a787 1
				struct ifa_msghdr *ifam;
d814 1
a814 1
	struct radix_node_head *rnh;
@


1.9.2.13
log
@Merge with the trunk
@
text
@d243 8
d261 1
a261 8
		break;
	case RTM_DELETE:
		error = rtrequest1(rtm->rtm_type, &info, &saved_nrt);
		if (error == 0) {
			(rt = saved_nrt)->rt_refcnt++;
			goto report;
		}
		break;
a272 17
#ifndef SMALL_KERNEL
		/*
		 * for RTM_CHANGE/LOCK, if we got multipath routes,
		 * we require users to specify a matching RTAX_GATEWAY.
		 *
		 * for RTM_GET, gate is optional even with multipath.
		 * if gate == NULL the first match is returned.
		 * (no need to call rt_mpath_matchgate if gate == NULL)
		 */
		if (rn_mpath_capable(rnh) &&
		    (rtm->rtm_type != RTM_GET || gate)) {
			rt = rt_mpath_matchgate(rt, gate);
			rn = (struct radix_node *)rt;
			if (!rt)
				senderr(ESRCH);
		}
#endif
a274 13
		/*
		 * RTM_CHANGE/LOCK need a perfect match, rn_lookup()
		 * returns a perfect match in case a netmask is specified.
		 * For host routes only a longest prefix match is returned
		 * so it is necessary to compare the existence of the netmaks.
		 * If both have a netmask rn_lookup() did a perfect match and
		 * if non of them have a netmask both are host routes which is
		 * also a perfect match.
		 */
		if (rtm->rtm_type != RTM_GET && !rt_mask(rt) != !netmask) {
				senderr(ESRCH);
		}

d311 1
a311 1
			rt_getmetrics(&rt->rt_rmx, &rtm->rtm_rmx);
d354 1
d415 1
a415 2
	struct rt_metrics *in;
	struct rt_kmetrics *out;
d418 6
a428 14
void
rt_getmetrics(in, out)
        struct rt_kmetrics *in;
        struct rt_metrics *out;
{
#define metric(e) out->e = in->e;
	bzero(out, sizeof(*out));
	metric(rmx_locks);
	metric(rmx_mtu);
	metric(rmx_expire);
	metric(rmx_pksent);
#undef metric
}

d763 1
a763 1
		rt_getmetrics(&rt->rt_rmx, &rtm->rtm_rmx);
@


1.9.2.14
log
@sync to head
@
text
@a223 1
	sroute_compact(&info, rtm->rtm_type);
a326 1
			sroute_expand(&info);
a639 1
	sroute_expand(rtinfo);
a727 1
			sroute_expand(&info);
a793 1
	sroute_expand(&info);
@


1.8
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.7 1998/08/24 20:39:40 downsj Exp $	*/
a595 3
	m = m_gethdr(M_DONTWAIT, MT_DATA);
	if (m == 0)
		return (m);
d610 1
a610 1
	if (len > MHLEN)
d612 10
@


1.7
log
@Don't deref NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.6 1998/05/18 21:10:21 provos Exp $	*/
d5 29
d100 2
d133 2
d165 2
a196 1
	struct ifaddr *ifa = 0;
d204 1
a204 1

d256 29
d353 4
d380 1
d383 1
d386 1
d459 50
@


1.6
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.5 1997/12/15 10:13:03 deraadt Exp $	*/
d298 2
a299 2
				 (ifa = ifa_ifwithroute(rt->rt_flags,
							rt_key(rt), gate)))
@


1.5
log
@fix for route change crash; from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.4 1997/12/12 09:04:17 deraadt Exp $	*/
d414 2
a415 1
 * chain if necessary.
@


1.4
log
@permit non-root to use RTM_GET, but no other calls; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsock.c,v 1.2 1996/03/03 21:07:21 niklas Exp $	*/
d294 1
a294 1
			    (ifp = ifa->ifa_ifp))
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d109 13
a121 1
	error = raw_usrreq(so, req, m, nam, control);
d206 8
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: rtsock.c,v 1.17 1996/02/13 22:00:52 christos Exp $	*/
d371 1
a371 1
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(int32_t) - 1))) : sizeof(int32_t))
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: rtsock.c,v 1.16 1995/08/19 07:48:14 cgd Exp $	*/
d48 3
d55 2
d94 2
a95 2
		if (so->so_pcb = rp)
			bzero((caddr_t)so->so_pcb, sizeof(*rp));
d135 7
a141 3
route_output(m, so)
	register struct mbuf *m;
	struct socket *so;
d151 7
d223 2
a224 2
		} else if (rt = (struct rtentry *)
				rnh->rnh_lookup(dst, netmask, rnh))
d237 1
a237 1
				if (ifp = rt->rt_ifp) {
d523 1
a523 1
	if (cp0 = cp)
d546 3
a548 2
				if (rw->w_tmem = (caddr_t)
						malloc(len, M_RTABLE, M_NOWAIT))
d639 1
a639 1
	struct sockaddr *sa;
d641 1
a641 1
	struct mbuf *m;
d691 1
a691 1
sysctl_dumpentry(rn, w)
d693 1
a693 1
	register struct walkarg *w;
d695 1
d723 1
a723 1
		if (error = copyout((caddr_t)rtm, w->w_where, size))
d757 2
a758 1
			if (error = copyout((caddr_t)ifm, w->w_where, len))
d762 1
a762 1
		while (ifa = ifa->ifa_list.tqe_next) {
d777 2
a778 1
				if (error = copyout(w->w_tmem, w->w_where, len))
d791 2
a792 2
	int	namelen;
	caddr_t	where;
d794 1
a794 1
	caddr_t	*new;
d821 3
a823 2
			    (error = rnh->rnh_walktree(rnh,
							sysctl_dumpentry, &w)))
d835 1
a835 1
		*given = w.w_where - where;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
