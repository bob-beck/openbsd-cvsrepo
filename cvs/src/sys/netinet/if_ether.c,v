head	1.228;
access;
symbols
	OPENBSD_6_1:1.228.0.4
	OPENBSD_6_1_BASE:1.228
	OPENBSD_6_0:1.220.0.4
	OPENBSD_6_0_BASE:1.220
	OPENBSD_5_9:1.201.0.2
	OPENBSD_5_9_BASE:1.201
	OPENBSD_5_8:1.159.0.4
	OPENBSD_5_8_BASE:1.159
	OPENBSD_5_7:1.146.0.2
	OPENBSD_5_7_BASE:1.146
	OPENBSD_5_6:1.131.0.4
	OPENBSD_5_6_BASE:1.131
	OPENBSD_5_5:1.118.0.4
	OPENBSD_5_5_BASE:1.118
	OPENBSD_5_4:1.102.0.2
	OPENBSD_5_4_BASE:1.102
	OPENBSD_5_3:1.96.0.2
	OPENBSD_5_3_BASE:1.96
	OPENBSD_5_2:1.93.0.4
	OPENBSD_5_2_BASE:1.93
	OPENBSD_5_1_BASE:1.93
	OPENBSD_5_1:1.93.0.2
	OPENBSD_5_0:1.92.0.2
	OPENBSD_5_0_BASE:1.92
	OPENBSD_4_9:1.88.0.4
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.84.0.2
	OPENBSD_4_7_BASE:1.84
	OPENBSD_4_6:1.80.0.4
	OPENBSD_4_6_BASE:1.80
	OPENBSD_4_5:1.79.0.2
	OPENBSD_4_5_BASE:1.79
	OPENBSD_4_4:1.75.0.2
	OPENBSD_4_4_BASE:1.75
	OPENBSD_4_3:1.70.0.2
	OPENBSD_4_3_BASE:1.70
	OPENBSD_4_2:1.68.0.2
	OPENBSD_4_2_BASE:1.68
	OPENBSD_4_1:1.65.0.4
	OPENBSD_4_1_BASE:1.65
	OPENBSD_4_0:1.65.0.2
	OPENBSD_4_0_BASE:1.65
	OPENBSD_3_9:1.61.0.2
	OPENBSD_3_9_BASE:1.61
	OPENBSD_3_8:1.59.0.2
	OPENBSD_3_8_BASE:1.59
	OPENBSD_3_7:1.58.0.2
	OPENBSD_3_7_BASE:1.58
	OPENBSD_3_6:1.54.0.2
	OPENBSD_3_6_BASE:1.54
	SMP_SYNC_A:1.53
	SMP_SYNC_B:1.53
	OPENBSD_3_5:1.53.0.2
	OPENBSD_3_5_BASE:1.53
	OPENBSD_3_4:1.48.0.2
	OPENBSD_3_4_BASE:1.48
	UBC_SYNC_A:1.46
	OPENBSD_3_3:1.45.0.4
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.40.0.2
	OPENBSD_3_1_BASE:1.40
	UBC_SYNC_B:1.45
	UBC:1.35.0.2
	UBC_BASE:1.35
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	SMP:1.19.0.2
	SMP_BASE:1.19
	kame_19991208:1.19
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.6
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.228
date	2017.03.06.08.56.39;	author mpi;	state Exp;
branches;
next	1.227;
commitid	aDXuIkVsOPuafbD0;

1.227
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.226;
commitid	QqHqT2WhCBWqYgGJ;

1.226
date	2016.11.20.11.46.45;	author mpi;	state Exp;
branches;
next	1.225;
commitid	BDxTsoC7qPCCxoxV;

1.225
date	2016.11.07.09.19.46;	author mpi;	state Exp;
branches;
next	1.224;
commitid	8MXPiDh6e0wDQBK2;

1.224
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.223;
commitid	RlO92XR575sygHqm;

1.223
date	2016.09.07.09.36.49;	author mpi;	state Exp;
branches;
next	1.222;
commitid	maggOul7Gx8kGBXs;

1.222
date	2016.09.06.00.04.15;	author dlg;	state Exp;
branches;
next	1.221;
commitid	UqrCCAsrdk9XuY5o;

1.221
date	2016.08.22.16.01.52;	author mpi;	state Exp;
branches;
next	1.220;
commitid	Jx7agqiuXqs8RRGd;

1.220
date	2016.07.14.14.01.40;	author mpi;	state Exp;
branches;
next	1.219;
commitid	1s3cT3Ypvp8jrVOZ;

1.219
date	2016.07.13.16.45.19;	author mpi;	state Exp;
branches;
next	1.218;
commitid	rLX7PMZ4auGYbwG0;

1.218
date	2016.07.13.08.40.46;	author mpi;	state Exp;
branches;
next	1.217;
commitid	VkTTZG0LgjCK3eLa;

1.217
date	2016.07.11.09.23.06;	author mpi;	state Exp;
branches;
next	1.216;
commitid	Z6QboMLW08GSdJ1F;

1.216
date	2016.06.28.17.18.24;	author chris;	state Exp;
branches;
next	1.215;
commitid	WyHA21HjSsNdlXF8;

1.215
date	2016.06.14.09.44.41;	author mpi;	state Exp;
branches;
next	1.214;
commitid	jROApUVEsAXWIH7k;

1.214
date	2016.06.10.20.33.29;	author vgross;	state Exp;
branches;
next	1.213;
commitid	qJaxh4rw41tBg4CK;

1.213
date	2016.06.06.07.07.11;	author mpi;	state Exp;
branches;
next	1.212;
commitid	yV2Nk0eCVokWQa33;

1.212
date	2016.06.06.07.01.37;	author mpi;	state Exp;
branches;
next	1.211;
commitid	mnLuUpnr9sCjxcYm;

1.211
date	2016.06.03.02.56.59;	author dlg;	state Exp;
branches;
next	1.210;
commitid	HDQtg6ec5B2YoCBq;

1.210
date	2016.05.31.07.50.34;	author mpi;	state Exp;
branches;
next	1.209;
commitid	JZitDEJ6k3XYEJzU;

1.209
date	2016.05.23.09.23.43;	author mpi;	state Exp;
branches;
next	1.208;
commitid	LzX1zA9UFuN2pVXV;

1.208
date	2016.05.23.09.09.04;	author mpi;	state Exp;
branches;
next	1.207;
commitid	0KgdRgErhxOumVxB;

1.207
date	2016.05.18.20.15.14;	author mpi;	state Exp;
branches;
next	1.206;
commitid	GXDQtPDrSoQkUAr1;

1.206
date	2016.05.18.08.05.51;	author mpi;	state Exp;
branches;
next	1.205;
commitid	1GwLg5umc8H1kN3x;

1.205
date	2016.04.27.14.47.27;	author mpi;	state Exp;
branches;
next	1.204;
commitid	ZVQDfnkyjDaQ3PD4;

1.204
date	2016.03.30.10.13.14;	author mpi;	state Exp;
branches;
next	1.203;
commitid	xpsJgMCf9pVyesEt;

1.203
date	2016.03.24.07.15.10;	author mpi;	state Exp;
branches;
next	1.202;
commitid	fXyPmo0RhevmrTSx;

1.202
date	2016.03.07.11.00.36;	author mpi;	state Exp;
branches;
next	1.201;
commitid	Uq5gx2J1EnNGXZCu;

1.201
date	2016.01.21.03.34.05;	author dlg;	state Exp;
branches
	1.201.2.1;
next	1.200;
commitid	NAb926w4AZhowFwk;

1.200
date	2016.01.14.12.41.02;	author mpi;	state Exp;
branches;
next	1.199;
commitid	r8sAuIUT3EDp6iZD;

1.199
date	2016.01.08.13.53.24;	author mpi;	state Exp;
branches;
next	1.198;
commitid	l2mfiUCCi0ZhRviM;

1.198
date	2015.12.17.16.05.30;	author tedu;	state Exp;
branches;
next	1.197;
commitid	xg8Tg2GDTHwgoEFt;

1.197
date	2015.12.02.22.02.18;	author claudio;	state Exp;
branches;
next	1.196;
commitid	rS5pR4w4jw05YEth;

1.196
date	2015.12.02.21.09.06;	author claudio;	state Exp;
branches;
next	1.195;
commitid	vDP9S5dNL26x0cCP;

1.195
date	2015.12.02.18.38.19;	author claudio;	state Exp;
branches;
next	1.194;
commitid	vI26rDsmWwqJhPMx;

1.194
date	2015.12.02.16.35.53;	author bluhm;	state Exp;
branches;
next	1.193;
commitid	i3XNpYhaQ8QndxLo;

1.193
date	2015.12.02.13.29.26;	author claudio;	state Exp;
branches;
next	1.192;
commitid	Hf3C2AvfIXmCAmHE;

1.192
date	2015.12.02.09.28.46;	author mpi;	state Exp;
branches;
next	1.191;
commitid	JZ9Oq6VqPdZL5AYj;

1.191
date	2015.12.01.12.22.18;	author mpi;	state Exp;
branches;
next	1.190;
commitid	GDLfKcd5eCBWNroc;

1.190
date	2015.11.20.10.51.30;	author mpi;	state Exp;
branches;
next	1.189;
commitid	0KYJ20MZvrKAL8Qa;

1.189
date	2015.11.20.10.50.08;	author mpi;	state Exp;
branches;
next	1.188;
commitid	KeO8HU3IZV8ZExMt;

1.188
date	2015.11.18.13.58.02;	author mpi;	state Exp;
branches;
next	1.187;
commitid	uGqqOfOdbFUfC7aN;

1.187
date	2015.11.18.13.53.59;	author mpi;	state Exp;
branches;
next	1.186;
commitid	ZQMHTobXPzXsynNo;

1.186
date	2015.11.13.10.18.04;	author mpi;	state Exp;
branches;
next	1.185;
commitid	Ix3hlCTAP8RCy3Dw;

1.185
date	2015.11.06.23.45.21;	author bluhm;	state Exp;
branches;
next	1.184;
commitid	VJkSFfCYlZqgdBdQ;

1.184
date	2015.11.05.12.46.23;	author bluhm;	state Exp;
branches;
next	1.183;
commitid	3UJMhjq96CYymz2e;

1.183
date	2015.11.04.00.16.12;	author dlg;	state Exp;
branches;
next	1.182;
commitid	aQXA4smvvphJ8nX2;

1.182
date	2015.11.02.15.05.23;	author mpi;	state Exp;
branches;
next	1.181;
commitid	aK60XMOKqPFfSdCc;

1.181
date	2015.11.02.14.08.54;	author bluhm;	state Exp;
branches;
next	1.180;
commitid	fIBPL1TYgvJqK0kW;

1.180
date	2015.11.01.22.53.34;	author bluhm;	state Exp;
branches;
next	1.179;
commitid	SPUVPLtJBuItBhCm;

1.179
date	2015.10.27.15.22.58;	author mpi;	state Exp;
branches;
next	1.178;
commitid	JMeIgKwGCP5xUxZE;

1.178
date	2015.10.27.10.54.52;	author mpi;	state Exp;
branches;
next	1.177;
commitid	EPsWReN3UVNwuW8U;

1.177
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.176;
commitid	G2nTzngqgXpQqcJB;

1.176
date	2015.10.22.18.14.53;	author mpi;	state Exp;
branches;
next	1.175;
commitid	DNI907r4MGf6XEOm;

1.175
date	2015.10.22.16.44.54;	author mpi;	state Exp;
branches;
next	1.174;
commitid	jjvpHaNPWhqZPQGN;

1.174
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.173;
commitid	tp9bS9eCrwvRYjyO;

1.173
date	2015.10.22.13.30.29;	author mpi;	state Exp;
branches;
next	1.172;
commitid	EHE1hTlKKSkaEqck;

1.172
date	2015.10.13.10.21.27;	author mpi;	state Exp;
branches;
next	1.171;
commitid	gOaR1dUDkWu5fKW9;

1.171
date	2015.10.07.08.58.01;	author mpi;	state Exp;
branches;
next	1.170;
commitid	GKoAXayYcFsVd0Gd;

1.170
date	2015.09.28.08.26.58;	author mpi;	state Exp;
branches;
next	1.169;
commitid	vOxg1kFYQCx3gmKo;

1.169
date	2015.09.16.06.58.08;	author claudio;	state Exp;
branches;
next	1.168;
commitid	7RPFI7Zzhzo7BrYa;

1.168
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.167;
commitid	zZXiESHR0g5lNO0l;

1.167
date	2015.09.13.10.42.32;	author dlg;	state Exp;
branches;
next	1.166;
commitid	KU5edmiQtbtt0saW;

1.166
date	2015.09.12.20.26.07;	author mpi;	state Exp;
branches;
next	1.165;
commitid	UM7jfgLT8vWQUBm1;

1.165
date	2015.09.10.13.21.41;	author dlg;	state Exp;
branches;
next	1.164;
commitid	8uJIAeywclspTOj1;

1.164
date	2015.09.09.15.59.19;	author mpi;	state Exp;
branches;
next	1.163;
commitid	IvKEOpr8YLiKUZ39;

1.163
date	2015.09.09.10.53.54;	author claudio;	state Exp;
branches;
next	1.162;
commitid	oTWVEpnh5mhK4j9e;

1.162
date	2015.08.19.11.05.33;	author mpi;	state Exp;
branches;
next	1.161;
commitid	qsvtg1dg4IOC2Rma;

1.161
date	2015.08.19.10.50.14;	author mpi;	state Exp;
branches;
next	1.160;
commitid	X8WCgmO6WKuCjovJ;

1.160
date	2015.08.17.09.58.10;	author mpi;	state Exp;
branches;
next	1.159;
commitid	MqJQ3OEAaT3r4fe4;

1.159
date	2015.07.18.15.51.16;	author mpi;	state Exp;
branches;
next	1.158;
commitid	lwQKRpFyNEr7kjoF;

1.158
date	2015.07.17.18.35.25;	author mpi;	state Exp;
branches;
next	1.157;
commitid	gqulqyENqbWpC8yE;

1.157
date	2015.07.07.14.22.25;	author mpi;	state Exp;
branches;
next	1.156;
commitid	3I07yxm8LZZyAbu0;

1.156
date	2015.06.23.13.20.17;	author mpi;	state Exp;
branches;
next	1.155;
commitid	VHA7iwrVjcqP8Q9Q;

1.155
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.154;
commitid	h7z8lokZ0dFyuWpg;

1.154
date	2015.06.07.01.25.27;	author krw;	state Exp;
branches;
next	1.153;
commitid	7yzARhkDkBsYwsVv;

1.153
date	2015.05.26.11.55.34;	author mpi;	state Exp;
branches;
next	1.152;
commitid	8QnAzQ9Hy36HrfPt;

1.152
date	2015.05.15.12.00.57;	author claudio;	state Exp;
branches;
next	1.151;
commitid	Gl6pqKOqk2n9Lwhq;

1.151
date	2015.04.22.04.12.22;	author jsg;	state Exp;
branches;
next	1.150;
commitid	U4YBrw55dzsGoju8;

1.150
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.149;
commitid	c7ei8kPelCOOwHXy;

1.149
date	2015.03.24.12.58.43;	author mpi;	state Exp;
branches;
next	1.148;
commitid	YRb8NP3bqoft6Ioq;

1.148
date	2015.03.14.17.13.44;	author mpi;	state Exp;
branches;
next	1.147;
commitid	UCbOr3TpgfoUkbPj;

1.147
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.146;
commitid	p4LJxGKbi0BU2cG6;

1.146
date	2015.02.11.23.34.43;	author mpi;	state Exp;
branches;
next	1.145;
commitid	LEl6vk7rMjn9Mb2M;

1.145
date	2015.02.07.04.01.11;	author mpi;	state Exp;
branches;
next	1.144;
commitid	Dw62PsYgPPh4zI2x;

1.144
date	2015.02.05.03.01.03;	author mpi;	state Exp;
branches;
next	1.143;
commitid	DhkSbioeq059UWqq;

1.143
date	2015.01.28.22.10.13;	author mpi;	state Exp;
branches;
next	1.142;
commitid	qWMiETGHDs7AwODS;

1.142
date	2015.01.26.11.36.38;	author mpi;	state Exp;
branches;
next	1.141;
commitid	NSAyjfvYLg4aQbwC;

1.141
date	2015.01.13.12.16.18;	author mpi;	state Exp;
branches;
next	1.140;
commitid	NfBYnUDZ5EPdjiAT;

1.140
date	2015.01.08.14.29.18;	author mpi;	state Exp;
branches;
next	1.139;
commitid	WNXddVtZkuvCWdN4;

1.139
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.138;
commitid	zhW8jJrfVCoAthrR;

1.138
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.137;
commitid	t9FBKDfc4VDxpEy2;

1.137
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.136;
commitid	w0MRp28dmfD1ZzO8;

1.136
date	2014.09.03.08.53.54;	author mpi;	state Exp;
branches;
next	1.135;
commitid	tq2djhjx8YrD5tGO;

1.135
date	2014.08.26.15.09.26;	author mpi;	state Exp;
branches;
next	1.134;
commitid	vUkwiNO7ibijrifg;

1.134
date	2014.08.19.12.49.41;	author mpi;	state Exp;
branches;
next	1.133;
commitid	4hSlcDXph8fUhqUG;

1.133
date	2014.08.11.13.51.07;	author mpi;	state Exp;
branches;
next	1.132;
commitid	a2PeiXPSryHFEtwq;

1.132
date	2014.08.11.11.50.41;	author mpi;	state Exp;
branches;
next	1.131;
commitid	7QjMZmZFKw3RPrBA;

1.131
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.130;
commitid	B4dZSbxas1X1IpXI;

1.130
date	2014.07.12.14.26.00;	author mpi;	state Exp;
branches;
next	1.129;
commitid	y5pjyU9NAzEZKp4W;

1.129
date	2014.06.16.19.47.21;	author mpi;	state Exp;
branches;
next	1.128;
commitid	deajIXmw3XdMzcAI;

1.128
date	2014.06.11.11.30.03;	author mpi;	state Exp;
branches;
next	1.127;
commitid	u5dv1nnY95B2omrl;

1.127
date	2014.05.07.08.14.59;	author mpi;	state Exp;
branches;
next	1.126;

1.126
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.125;

1.125
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.124;

1.124
date	2014.04.10.14.36.25;	author mikeb;	state Exp;
branches;
next	1.123;

1.123
date	2014.03.27.10.39.23;	author mpi;	state Exp;
branches;
next	1.122;

1.122
date	2014.03.18.14.55.49;	author mikeb;	state Exp;
branches;
next	1.121;

1.121
date	2014.03.18.10.47.34;	author mpi;	state Exp;
branches;
next	1.120;

1.120
date	2014.03.11.10.31.29;	author mpi;	state Exp;
branches;
next	1.119;

1.119
date	2014.03.10.12.21.35;	author mpi;	state Exp;
branches;
next	1.118;

1.118
date	2014.01.22.06.28.09;	author claudio;	state Exp;
branches;
next	1.117;

1.117
date	2014.01.10.14.29.08;	author tedu;	state Exp;
branches;
next	1.116;

1.116
date	2014.01.09.21.57.52;	author tedu;	state Exp;
branches;
next	1.115;

1.115
date	2014.01.09.06.29.05;	author tedu;	state Exp;
branches;
next	1.114;

1.114
date	2013.12.31.03.24.44;	author tedu;	state Exp;
branches;
next	1.113;

1.113
date	2013.11.27.12.25.30;	author mpi;	state Exp;
branches;
next	1.112;

1.112
date	2013.11.21.09.08.38;	author mpi;	state Exp;
branches;
next	1.111;

1.111
date	2013.11.11.09.15.34;	author mpi;	state Exp;
branches;
next	1.110;

1.110
date	2013.10.31.18.10.21;	author bluhm;	state Exp;
branches;
next	1.109;

1.109
date	2013.10.28.12.33.32;	author mpi;	state Exp;
branches;
next	1.108;

1.108
date	2013.10.14.16.06.33;	author bluhm;	state Exp;
branches;
next	1.107;

1.107
date	2013.09.03.10.25.32;	author mpi;	state Exp;
branches;
next	1.106;

1.106
date	2013.08.29.13.24.43;	author mpi;	state Exp;
branches;
next	1.105;

1.105
date	2013.08.28.06.58.57;	author mpi;	state Exp;
branches;
next	1.104;

1.104
date	2013.08.09.06.01.52;	author mpi;	state Exp;
branches;
next	1.103;

1.103
date	2013.08.01.08.27.43;	author mpi;	state Exp;
branches;
next	1.102;

1.102
date	2013.07.04.08.22.19;	author mpi;	state Exp;
branches;
next	1.101;

1.101
date	2013.03.28.23.10.05;	author tedu;	state Exp;
branches;
next	1.100;

1.100
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.99;

1.99
date	2013.03.28.00.32.11;	author bluhm;	state Exp;
branches;
next	1.98;

1.98
date	2013.03.22.01.41.12;	author tedu;	state Exp;
branches;
next	1.97;

1.97
date	2013.03.07.09.03.16;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2012.10.18.00.36.22;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.94;

1.94
date	2012.10.05.12.30.43;	author camield;	state Exp;
branches;
next	1.93;

1.93
date	2011.09.18.11.17.58;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2011.07.05.23.15.15;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2011.07.05.21.40.38;	author dhill;	state Exp;
branches;
next	1.89;

1.89
date	2011.06.27.13.01.51;	author camield;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.22.00.41.55;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.28.18.50.37;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2010.04.06.18.16.31;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2010.02.08.13.32.50;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2010.01.13.05.27.19;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2009.10.17.12.20.17;	author mpf;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2008.12.24.08.26.27;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2008.10.31.21.08.33;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2008.10.30.09.39.05;	author gollo;	state Exp;
branches;
next	1.76;

1.76
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.06.13.29.43;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2008.05.11.03.50.23;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2008.05.09.15.48.59;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2008.05.09.07.32.39;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2008.04.24.11.36.38;	author dlg;	state Exp;
branches;
next	1.70;

1.70
date	2008.02.05.22.57.30;	author mpf;	state Exp;
branches;
next	1.69;

1.69
date	2007.11.06.21.52.00;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2007.03.25.16.43.22;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2007.03.18.23.23.17;	author mpf;	state Exp;
branches;
next	1.66;

1.66
date	2007.03.16.16.58.40;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2006.08.21.21.36.53;	author mpf;	state Exp;
branches;
next	1.64;

1.64
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.22.14.37.44;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2005.11.29.02.59.42;	author jolan;	state Exp;
branches;
next	1.60;

1.60
date	2005.11.27.16.22.45;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2005.07.25.01.10.37;	author pascoe;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.01.19.04.56;	author mcbride;	state Exp;
branches;
next	1.57;

1.57
date	2005.01.04.10.30.01;	author pascoe;	state Exp;
branches;
next	1.56;

1.56
date	2005.01.04.09.29.43;	author pascoe;	state Exp;
branches;
next	1.55;

1.55
date	2004.12.07.20.38.46;	author mcbride;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.18.09.23.14;	author ho;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.07.22.04.46;	author mcbride;	state Exp;
branches;
next	1.50;

1.50
date	2003.10.17.21.04.58;	author mcbride;	state Exp;
branches;
next	1.49;

1.49
date	2003.09.24.21.11.34;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2003.05.17.15.15.23;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.04.11.56.32;	author dhartmei;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches
	1.45.2.1
	1.45.4.1;
next	1.44;

1.44
date	2002.06.09.07.50.57;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.09.05.25.50;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.09.05.08.37;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2002.06.07.23.30.26;	author aaron;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.27.17.13.47;	author ian;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.14.03.16.11;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.26.20.24.58;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.15.15.27.17;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.08.06.15.15;	author jason;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.08.12.31.12;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.09.06.14.11;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.08.20.32.24;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.08.03.53.45;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.15.15.12.54;	author gluk;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.06.00.22.24;	author mickey;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.02.05.15.22.11;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.19.06.37.37;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.28.23.56.47;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.27.16.20.43;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.27.14.57.52;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.22.19.05.51;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.20.17.56.10;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.17.22.05.57;	author art;	state Exp;
branches;
next	1.19;

1.19
date	99.11.10.18.48.47;	author chris;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	99.08.08.02.42.59;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.08.02.22.51.15;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.07.18.21.36.40;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	99.05.16.00.34.40;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	99.03.13.21.15.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.09.28.23.09.56;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.08.01.03.53.01;	author flipk;	state Exp;
branches;
next	1.10;

1.10
date	97.07.24.22.59.35;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.21.07.52.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.11.22.23.14;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.05.22.11.48.45;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.10.12.31.19;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.28.58;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.03.03.22.30.24;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.06.15.55.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.28.22.42.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches;
next	;

1.19.2.1
date	2000.03.24.09.09.35;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.05.14.22.40.07;	author niklas;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.07.04.10.54.28;	author niklas;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2001.11.13.22.59.58;	author niklas;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.19.2.7;

1.19.2.7
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.19.2.8;

1.19.2.8
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.19.2.9;

1.19.2.9
date	2003.05.13.19.36.16;	author ho;	state Exp;
branches;
next	1.19.2.10;

1.19.2.10
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.19.2.11;

1.19.2.11
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.28.2.1
date	2001.05.16.04.06.01;	author jason;	state Exp;
branches;
next	;

1.35.2.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;

1.45.2.1
date	2003.08.24.23.20.37;	author brad;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2003.10.01.22.53.34;	author brad;	state Exp;
branches;
next	;

1.45.4.1
date	2003.05.12.04.07.20;	author margarida;	state Exp;
branches;
next	1.45.4.2;

1.45.4.2
date	2003.10.01.20.36.56;	author margarida;	state Exp;
branches;
next	;

1.48.2.1
date	2003.10.31.00.07.52;	author brad;	state Exp;
branches;
next	;

1.201.2.1
date	2016.07.14.11.13.14;	author mpi;	state Exp;
branches;
next	;
commitid	c3zMIeXyCizF4IZR;


desc
@@


1.228
log
@Prefix functions dealing with routing messages with 'rtm_' and keep
them all in net/rtsock.c.

This allows to easily spot which functions are doing a copyout(9)
when dealing with the routing midlayer.

ok phessler@@, bluhm@@, dhill@@, krw@@, claudio@@
@
text
@/*	$OpenBSD: if_ether.c,v 1.227 2016/12/19 08:36:49 mpi Exp $	*/
/*	$NetBSD: if_ether.c,v 1.31 1996/05/11 12:59:58 mycroft Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_ether.c	8.1 (Berkeley) 6/10/93
 */

/*
 * Ethernet address resolution protocol.
 * TODO:
 *	add "inuse/lock" bit (or ref. count) along with valid bit
 */

#include "carp.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/queue.h>
#include <sys/pool.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <net/if_types.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/if_ether.h>
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

struct llinfo_arp {
	LIST_ENTRY(llinfo_arp)	 la_list;
	struct rtentry		*la_rt;		/* backpointer to rtentry */
	long			 la_asked;	/* last time we QUERIED */
	struct mbuf_list	 la_ml;		/* packet hold queue */
};
#define LA_HOLD_QUEUE 10
#define LA_HOLD_TOTAL 100

/* timer values */
int	arpt_prune = (5 * 60);	/* walk list every 5 minutes */
int	arpt_keep = (20 * 60);	/* once resolved, cache for 20 minutes */
int	arpt_down = 20;		/* once declared down, don't send for 20 secs */

void arpinvalidate(struct rtentry *);
void arptfree(struct rtentry *);
void arptimer(void *);
struct rtentry *arplookup(struct in_addr *, int, int, unsigned int);
void in_arpinput(struct ifnet *, struct mbuf *);
void in_revarpinput(struct ifnet *, struct mbuf *);
int arpcache(struct ifnet *, struct ether_arp *, struct rtentry *);
void arpreply(struct ifnet *, struct mbuf *, struct in_addr *, uint8_t *);

struct niqueue arpinq = NIQUEUE_INITIALIZER(50, NETISR_ARP);

LIST_HEAD(, llinfo_arp) arp_list;
struct	pool arp_pool;		/* pool for llinfo_arp structures */
int	arp_maxtries = 5;
int	arpinit_done;
int	la_hold_total;

#ifdef NFSCLIENT
/* revarp state */
struct in_addr revarp_myip, revarp_srvip;
int revarp_finished;
unsigned int revarp_ifidx;
#endif /* NFSCLIENT */

/*
 * Timeout routine.  Age arp_tab entries periodically.
 */
/* ARGSUSED */
void
arptimer(void *arg)
{
	struct timeout *to = (struct timeout *)arg;
	struct llinfo_arp *la, *nla;
	int s;

	NET_LOCK(s);
	timeout_add_sec(to, arpt_prune);
	LIST_FOREACH_SAFE(la, &arp_list, la_list, nla) {
		struct rtentry *rt = la->la_rt;

		if (rt->rt_expire && rt->rt_expire <= time_uptime)
			arptfree(rt); /* timer has expired; clear */
	}
	NET_UNLOCK(s);
}

void
arp_rtrequest(struct ifnet *ifp, int req, struct rtentry *rt)
{
	struct sockaddr *gate = rt->rt_gateway;
	struct llinfo_arp *la = (struct llinfo_arp *)rt->rt_llinfo;
	struct ifaddr *ifa;

	if (!arpinit_done) {
		static struct timeout arptimer_to;

		arpinit_done = 1;
		pool_init(&arp_pool, sizeof(struct llinfo_arp), 0,
		    IPL_SOFTNET, 0, "arp", NULL);

		timeout_set_proc(&arptimer_to, arptimer, &arptimer_to);
		timeout_add_sec(&arptimer_to, 1);
	}

	if (ISSET(rt->rt_flags, RTF_GATEWAY|RTF_BROADCAST|RTF_MULTICAST))
		return;

	switch (req) {

	case RTM_ADD:
		if (rt->rt_flags & RTF_CLONING ||
		    ((rt->rt_flags & (RTF_LLINFO | RTF_LOCAL)) && !la)) {
			/*
			 * Give this route an expiration time, even though
			 * it's a "permanent" route, so that routes cloned
			 * from it do not need their expiration time set.
			 */
			rt->rt_expire = time_uptime;
			if ((rt->rt_flags & RTF_CLONING) != 0)
				break;
		}
		/*
		 * Announce a new entry if requested or warn the user
		 * if another station has this IP address.
		 */
		if (rt->rt_flags & (RTF_ANNOUNCE|RTF_LOCAL))
			arprequest(ifp,
			    &satosin(rt_key(rt))->sin_addr.s_addr,
			    &satosin(rt_key(rt))->sin_addr.s_addr,
			    (u_char *)LLADDR(satosdl(gate)));
		/*FALLTHROUGH*/
	case RTM_RESOLVE:
		if (gate->sa_family != AF_LINK ||
		    gate->sa_len < sizeof(struct sockaddr_dl)) {
			log(LOG_DEBUG, "%s: bad gateway value: %s\n", __func__,
			    ifp->if_xname);
			break;
		}
		satosdl(gate)->sdl_type = ifp->if_type;
		satosdl(gate)->sdl_index = ifp->if_index;
		if (la != 0)
			break; /* This happens on a route change */
		/*
		 * Case 2:  This route may come from cloning, or a manual route
		 * add with a LL address.
		 */
		la = pool_get(&arp_pool, PR_NOWAIT | PR_ZERO);
		rt->rt_llinfo = (caddr_t)la;
		if (la == NULL) {
			log(LOG_DEBUG, "%s: pool get failed\n", __func__);
			break;
		}

		ml_init(&la->la_ml);
		la->la_rt = rt;
		rt->rt_flags |= RTF_LLINFO;
		LIST_INSERT_HEAD(&arp_list, la, la_list);

		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if ((ifa->ifa_addr->sa_family == AF_INET) &&
			    ifatoia(ifa)->ia_addr.sin_addr.s_addr ==
			    satosin(rt_key(rt))->sin_addr.s_addr)
				break;
		}
		if (ifa) {
			KASSERT(ifa == rt->rt_ifa);
			rt->rt_expire = 0;
		}
		break;

	case RTM_DELETE:
		if (la == NULL)
			break;
		LIST_REMOVE(la, la_list);
		rt->rt_llinfo = NULL;
		rt->rt_flags &= ~RTF_LLINFO;
		la_hold_total -= ml_purge(&la->la_ml);
		pool_put(&arp_pool, la);
		break;

	case RTM_INVALIDATE:
		if (!ISSET(rt->rt_flags, RTF_LOCAL))
			arpinvalidate(rt);
		break;
	}
}

/*
 * Broadcast an ARP request. Caller specifies:
 *	- arp header source ip address
 *	- arp header target ip address
 *	- arp header source ethernet address
 */
void
arprequest(struct ifnet *ifp, u_int32_t *sip, u_int32_t *tip, u_int8_t *enaddr)
{
	struct mbuf *m;
	struct ether_header *eh;
	struct ether_arp *ea;
	struct sockaddr sa;

	if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
		return;
	m->m_len = sizeof(*ea);
	m->m_pkthdr.len = sizeof(*ea);
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;
	m->m_pkthdr.pf.prio = ifp->if_llprio;
	MH_ALIGN(m, sizeof(*ea));
	ea = mtod(m, struct ether_arp *);
	eh = (struct ether_header *)sa.sa_data;
	memset(ea, 0, sizeof(*ea));
	memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof(eh->ether_dhost));
	eh->ether_type = htons(ETHERTYPE_ARP);	/* if_output will not swap */
	ea->arp_hrd = htons(ARPHRD_ETHER);
	ea->arp_pro = htons(ETHERTYPE_IP);
	ea->arp_hln = sizeof(ea->arp_sha);	/* hardware address length */
	ea->arp_pln = sizeof(ea->arp_spa);	/* protocol address length */
	ea->arp_op = htons(ARPOP_REQUEST);
	memcpy(eh->ether_shost, enaddr, sizeof(eh->ether_shost));
	memcpy(ea->arp_sha, enaddr, sizeof(ea->arp_sha));
	memcpy(ea->arp_spa, sip, sizeof(ea->arp_spa));
	memcpy(ea->arp_tpa, tip, sizeof(ea->arp_tpa));
	sa.sa_family = pseudo_AF_HDRCMPLT;
	sa.sa_len = sizeof(sa);
	m->m_flags |= M_BCAST;
	ifp->if_output(ifp, m, &sa, NULL);
}

void
arpreply(struct ifnet *ifp, struct mbuf *m, struct in_addr *sip, uint8_t *eaddr)
{
	struct ether_header *eh;
	struct ether_arp *ea;
	struct sockaddr sa;

	ea = mtod(m, struct ether_arp *);
	ea->arp_op = htons(ARPOP_REPLY);
	ea->arp_pro = htons(ETHERTYPE_IP); /* let's be sure! */

	/* We're replying to a request. */
	memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
	memcpy(ea->arp_tpa, ea->arp_spa, sizeof(ea->arp_spa));

	memcpy(ea->arp_sha, eaddr, sizeof(ea->arp_sha));
	memcpy(ea->arp_spa, sip, sizeof(ea->arp_spa));

	eh = (struct ether_header *)sa.sa_data;
	memcpy(eh->ether_dhost, ea->arp_tha, sizeof(eh->ether_dhost));
	memcpy(eh->ether_shost, eaddr, sizeof(eh->ether_shost));
	eh->ether_type = htons(ETHERTYPE_ARP);
	sa.sa_family = pseudo_AF_HDRCMPLT;
	sa.sa_len = sizeof(sa);
	ifp->if_output(ifp, m, &sa, NULL);
}

/*
 * Resolve an IP address into an ethernet address.  If success,
 * desten is filled in.  If there is no entry in arptab,
 * set one up and broadcast a request for the IP address.
 * Hold onto this mbuf and resend it once the address
 * is finally resolved.  A return value of 0 indicates
 * that desten has been filled in and the packet should be sent
 * normally; A return value of EAGAIN indicates that the packet
 * has been taken over here, either now or for later transmission.
 * Any other return value indicates an error.
 */
int
arpresolve(struct ifnet *ifp, struct rtentry *rt0, struct mbuf *m,
    struct sockaddr *dst, u_char *desten)
{
	struct arpcom *ac = (struct arpcom *)ifp;
	struct llinfo_arp *la = NULL;
	struct sockaddr_dl *sdl;
	struct rtentry *rt = NULL;
	char addr[INET_ADDRSTRLEN];

	if (m->m_flags & M_BCAST) {	/* broadcast */
		memcpy(desten, etherbroadcastaddr, sizeof(etherbroadcastaddr));
		return (0);
	}
	if (m->m_flags & M_MCAST) {	/* multicast */
		ETHER_MAP_IP_MULTICAST(&satosin(dst)->sin_addr, desten);
		return (0);
	}

	rt = rt_getll(rt0);

	if (ISSET(rt->rt_flags, RTF_REJECT) &&
	    (rt->rt_expire == 0 || time_uptime < rt->rt_expire)) {
		m_freem(m);
		return (rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);
	}

	if (!ISSET(rt->rt_flags, RTF_LLINFO)) {
		log(LOG_DEBUG, "%s: %s: route contains no arp information\n",
		    __func__, inet_ntop(AF_INET, &satosin(rt_key(rt))->sin_addr,
		    addr, sizeof(addr)));
		m_freem(m);
		return (EINVAL);
	}

	sdl = satosdl(rt->rt_gateway);
	if (sdl->sdl_alen > 0 && sdl->sdl_alen != ETHER_ADDR_LEN) {
		log(LOG_DEBUG, "%s: %s: incorrect arp information\n", __func__,
		    inet_ntop(AF_INET, &satosin(dst)->sin_addr,
			addr, sizeof(addr)));
		goto bad;
	}

	/*
	 * Check the address family and length is valid, the address
	 * is resolved; otherwise, try to resolve.
	 */
	if ((rt->rt_expire == 0 || rt->rt_expire > time_uptime) &&
	    sdl->sdl_family == AF_LINK && sdl->sdl_alen != 0) {
		memcpy(desten, LLADDR(sdl), sdl->sdl_alen);
		return (0);
	}

	if (ifp->if_flags & IFF_NOARP)
		goto bad;

	/*
	 * There is an arptab entry, but no ethernet address
	 * response yet. Insert mbuf in hold queue if below limit
	 * if above the limit free the queue without queuing the new packet.
	 */
	la = (struct llinfo_arp *)rt->rt_llinfo;
	KASSERT(la != NULL);
	if (la_hold_total < LA_HOLD_TOTAL && la_hold_total < nmbclust / 64) {
		struct mbuf *mh;

		if (ml_len(&la->la_ml) >= LA_HOLD_QUEUE) {
			mh = ml_dequeue(&la->la_ml);
			la_hold_total--;
			m_freem(mh);
		}
		ml_enqueue(&la->la_ml, m);
		la_hold_total++;
	} else {
		la_hold_total -= ml_purge(&la->la_ml);
		m_freem(m);
	}

	/*
	 * Re-send the ARP request when appropriate.
	 */
#ifdef	DIAGNOSTIC
	if (rt->rt_expire == 0) {
		/* This should never happen. (Should it? -gwr) */
		printf("%s: unresolved and rt_expire == 0\n", __func__);
		/* Set expiration time to now (expired). */
		rt->rt_expire = time_uptime;
	}
#endif
	if (rt->rt_expire) {
		rt->rt_flags &= ~RTF_REJECT;
		if (la->la_asked == 0 || rt->rt_expire != time_uptime) {
			rt->rt_expire = time_uptime;
			if (la->la_asked++ < arp_maxtries)
				arprequest(ifp,
				    &satosin(rt->rt_ifa->ifa_addr)->sin_addr.s_addr,
				    &satosin(dst)->sin_addr.s_addr,
				    ac->ac_enaddr);
			else {
				rt->rt_flags |= RTF_REJECT;
				rt->rt_expire += arpt_down;
				la->la_asked = 0;
				la_hold_total -= ml_purge(&la->la_ml);
			}
		}
	}

	return (EAGAIN);

bad:
	m_freem(m);
	return (EINVAL);
}

/*
 * Common length and type checks are done here,
 * then the protocol-specific routine is called.
 */
void
arpinput(struct ifnet *ifp, struct mbuf *m)
{
	struct arphdr *ar;
	int len;

#ifdef DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("arpintr");
#endif

	len = sizeof(struct arphdr);
	if (m->m_len < len && (m = m_pullup(m, len)) == NULL)
		return;

	ar = mtod(m, struct arphdr *);
	if (ntohs(ar->ar_hrd) != ARPHRD_ETHER ||
	    ntohs(ar->ar_pro) != ETHERTYPE_IP) {
		m_freem(m);
		return;
	}

	len += 2 * (ar->ar_hln + ar->ar_pln);
	if (m->m_len < len && (m = m_pullup(m, len)) == NULL)
		return;

	niq_enqueue(&arpinq, m);
}

void
arpintr(void)
{
	struct mbuf_list ml;
	struct mbuf *m;
	struct ifnet *ifp;

	niq_delist(&arpinq, &ml);

	while ((m = ml_dequeue(&ml)) != NULL) {
		ifp = if_get(m->m_pkthdr.ph_ifidx);

		if (ifp != NULL)
			in_arpinput(ifp, m);
		else
			m_freem(m);

		if_put(ifp);
	}
}

/*
 * ARP for Internet protocols on Ethernet, RFC 826.
 * In addition, a sanity check is performed on the sender
 * protocol address, to catch impersonators.
 */
void
in_arpinput(struct ifnet *ifp, struct mbuf *m)
{
	struct ether_arp *ea;
	struct rtentry *rt = NULL;
	struct sockaddr_in sin;
	struct in_addr isaddr, itaddr;
	char addr[INET_ADDRSTRLEN];
	int op, target = 0;
	unsigned int rdomain;

	rdomain = rtable_l2(m->m_pkthdr.ph_rtableid);

	ea = mtod(m, struct ether_arp *);
	op = ntohs(ea->arp_op);
	if ((op != ARPOP_REQUEST) && (op != ARPOP_REPLY))
		goto out;

	memcpy(&itaddr, ea->arp_tpa, sizeof(itaddr));
	memcpy(&isaddr, ea->arp_spa, sizeof(isaddr));
	memset(&sin, 0, sizeof(sin));
	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;

	if (ETHER_IS_MULTICAST(&ea->arp_sha[0]) &&
	    !memcmp(ea->arp_sha, etherbroadcastaddr, sizeof(ea->arp_sha))) {
		inet_ntop(AF_INET, &isaddr, addr, sizeof(addr));
		log(LOG_ERR, "arp: ether address is broadcast for IP address "
		    "%s!\n", addr);
		goto out;
	}

	if (!memcmp(ea->arp_sha, LLADDR(ifp->if_sadl), sizeof(ea->arp_sha)))
		goto out;	/* it's from me, ignore it. */

	/* Check target against our interface addresses. */
	sin.sin_addr = itaddr;
	rt = rtalloc(sintosa(&sin), 0, rdomain);
	if (rtisvalid(rt) && ISSET(rt->rt_flags, RTF_LOCAL) &&
	    rt->rt_ifidx == ifp->if_index)
		target = 1;
	rtfree(rt);
	rt = NULL;

#if NCARP > 0
	if (target && op == ARPOP_REQUEST && ifp->if_type == IFT_CARP &&
	    !carp_iamatch(ifp))
		goto out;
#endif

	/* Do we have an ARP cache for the sender? Create if we are target. */
	rt = arplookup(&isaddr, target, 0, rdomain);

	/* Check sender against our interface addresses. */
	if (rtisvalid(rt) && ISSET(rt->rt_flags, RTF_LOCAL) &&
	    rt->rt_ifidx == ifp->if_index && isaddr.s_addr != INADDR_ANY) {
		inet_ntop(AF_INET, &isaddr, addr, sizeof(addr));
		log(LOG_ERR, "duplicate IP address %s sent from ethernet "
		    "address %s\n", addr, ether_sprintf(ea->arp_sha));
		itaddr = isaddr;
	} else if (rt != NULL) {
		int error;

		KERNEL_LOCK();
		error = arpcache(ifp, ea, rt);
		KERNEL_UNLOCK();
		if (error)
			goto out;
	}

	if (op == ARPOP_REQUEST) {
		uint8_t *eaddr;

		if (target) {
			/* We already have all info for the reply */
			eaddr = LLADDR(ifp->if_sadl);
		} else {
			rtfree(rt);
			rt = arplookup(&itaddr, 0, SIN_PROXY, rdomain);
			/*
			 * Protect from possible duplicates, only owner
			 * should respond
			 */
			if ((rt == NULL) || (rt->rt_ifidx != ifp->if_index))
				goto out;
			eaddr = LLADDR(satosdl(rt->rt_gateway));
		}
		arpreply(ifp, m, &itaddr, eaddr);
		rtfree(rt);
		return;
	}

out:
	rtfree(rt);
	m_freem(m);
}

int
arpcache(struct ifnet *ifp, struct ether_arp *ea, struct rtentry *rt)
{
	struct llinfo_arp *la = (struct llinfo_arp *)rt->rt_llinfo;
	struct sockaddr_dl *sdl = satosdl(rt->rt_gateway);
	struct in_addr *spa = (struct in_addr *)ea->arp_spa;
	char addr[INET_ADDRSTRLEN];
	struct ifnet *rifp;
	unsigned int len;
	int changed = 0;

	KERNEL_ASSERT_LOCKED();
	KASSERT(sdl != NULL);

	/*
	 * This can happen if the entry has been deleted by another CPU
	 * after we found it.
	 */
	if (la == NULL)
		return (0);

	if (sdl->sdl_alen > 0) {
		if (memcmp(ea->arp_sha, LLADDR(sdl), sdl->sdl_alen)) {
			if (ISSET(rt->rt_flags, RTF_PERMANENT_ARP|RTF_LOCAL)) {
				inet_ntop(AF_INET, spa, addr, sizeof(addr));
				log(LOG_WARNING, "arp: attempt to overwrite "
				   "permanent entry for %s by %s on %s\n", addr,
				   ether_sprintf(ea->arp_sha), ifp->if_xname);
				return (-1);
			} else if (rt->rt_ifidx != ifp->if_index) {
#if NCARP > 0
				if (ifp->if_type != IFT_CARP)
#endif
				{
					rifp = if_get(rt->rt_ifidx);
					if (rifp == NULL)
						return (-1);
					inet_ntop(AF_INET, spa, addr,
					    sizeof(addr));
					log(LOG_WARNING, "arp: attempt to "
					    "overwrite entry for %s on %s by "
					    "%s on %s\n", addr, rifp->if_xname,
					    ether_sprintf(ea->arp_sha),
					    ifp->if_xname);
					if_put(rifp);
				}
				return (-1);
			} else {
				inet_ntop(AF_INET, spa, addr, sizeof(addr));
				log(LOG_INFO, "arp info overwritten for %s by "
				    "%s on %s\n", addr,
				    ether_sprintf(ea->arp_sha), ifp->if_xname);
				rt->rt_expire = 1;/* no longer static */
			}
			changed = 1;
		}
	} else if (!if_isconnected(ifp, rt->rt_ifidx)) {
		rifp = if_get(rt->rt_ifidx);
		if (rifp == NULL)
			return (-1);
		inet_ntop(AF_INET, spa, addr, sizeof(addr));
		log(LOG_WARNING, "arp: attempt to add entry for %s on %s by %s"
		    " on %s\n", addr, rifp->if_xname,
		    ether_sprintf(ea->arp_sha), ifp->if_xname);
		if_put(rifp);
		return (-1);
	}
	sdl->sdl_alen = sizeof(ea->arp_sha);
	memcpy(LLADDR(sdl), ea->arp_sha, sizeof(ea->arp_sha));
	if (rt->rt_expire)
		rt->rt_expire = time_uptime + arpt_keep;
	rt->rt_flags &= ~RTF_REJECT;

	/* Notify userland that an ARP resolution has been done. */
	if (la->la_asked || changed) {
		KERNEL_LOCK();
		rtm_send(rt, RTM_RESOLVE, ifp->if_rdomain);
		KERNEL_UNLOCK();
	}

	la->la_asked = 0;
	while ((len = ml_len(&la->la_ml)) != 0) {
		struct mbuf *mh;

		mh = ml_dequeue(&la->la_ml);
		la_hold_total--;

		ifp->if_output(ifp, mh, rt_key(rt), rt);

		if (ml_len(&la->la_ml) == len) {
			/* mbuf is back in queue. Discard. */
			while ((mh = ml_dequeue(&la->la_ml)) != NULL) {
				la_hold_total--;
				m_freem(mh);
			}
			break;
		}
	}

	return (0);
}

void
arpinvalidate(struct rtentry *rt)
{
	struct llinfo_arp *la = (struct llinfo_arp *)rt->rt_llinfo;
	struct sockaddr_dl *sdl = satosdl(rt->rt_gateway);

	la_hold_total -= ml_purge(&la->la_ml);
	sdl->sdl_alen = 0;
	la->la_asked = 0;
}

/*
 * Free an arp entry.
 */
void
arptfree(struct rtentry *rt)
{
	struct ifnet *ifp;

	arpinvalidate(rt);

	ifp = if_get(rt->rt_ifidx);
	KASSERT(ifp != NULL);
	if (!ISSET(rt->rt_flags, RTF_STATIC|RTF_CACHED))
		rtdeletemsg(rt, ifp, ifp->if_rdomain);
	if_put(ifp);
}

/*
 * Lookup or enter a new address in arptab.
 */
struct rtentry *
arplookup(struct in_addr *inp, int create, int proxy, u_int tableid)
{
	struct rtentry *rt;
	struct sockaddr_inarp sin;
	int flags;

	memset(&sin, 0, sizeof(sin));
	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = inp->s_addr;
	sin.sin_other = proxy ? SIN_PROXY : 0;
	flags = (create) ? RT_RESOLVE : 0;

	rt = rtalloc((struct sockaddr *)&sin, flags, tableid);
	if (!rtisvalid(rt) || ISSET(rt->rt_flags, RTF_GATEWAY) ||
	    !ISSET(rt->rt_flags, RTF_LLINFO) ||
	    rt->rt_gateway->sa_family != AF_LINK) {
		rtfree(rt);
		return (NULL);
	}

	if (proxy && !ISSET(rt->rt_flags, RTF_ANNOUNCE)) {
#ifdef ART
		while ((rt = rtable_iterate(rt)) != NULL) {
			if (ISSET(rt->rt_flags, RTF_ANNOUNCE)) {
				break;
			}
		}
#endif /* ART */
	}

	return (rt);
}

/*
 * Check whether we do proxy ARP for this address and we point to ourselves.
 */
int
arpproxy(struct in_addr in, unsigned int rtableid)
{
	struct sockaddr_dl *sdl;
	struct rtentry *rt;
	struct ifnet *ifp;
	int found = 0;

	rt = arplookup(&in, 0, SIN_PROXY, rtableid);
	if (!rtisvalid(rt)) {
		rtfree(rt);
		return (0);
	}

	/* Check that arp information are correct. */
	sdl = satosdl(rt->rt_gateway);
	if (sdl->sdl_alen != ETHER_ADDR_LEN) {
		rtfree(rt);
		return (0);
	}

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL) {
		rtfree(rt);
		return (0);
	}

	if (!memcmp(LLADDR(sdl), LLADDR(ifp->if_sadl), sdl->sdl_alen))
		found = 1;

	if_put(ifp);
	rtfree(rt);
	return (found);
}

/*
 * Called from Ethernet interrupt handlers
 * when ether packet type ETHERTYPE_REVARP
 * is received.  Common length and type checks are done here,
 * then the protocol-specific routine is called.
 */
void
revarpinput(struct ifnet *ifp, struct mbuf *m)
{
	struct arphdr *ar;

	if (m->m_len < sizeof(struct arphdr))
		goto out;
	ar = mtod(m, struct arphdr *);
	if (ntohs(ar->ar_hrd) != ARPHRD_ETHER)
		goto out;
	if (m->m_len < sizeof(struct arphdr) + 2 * (ar->ar_hln + ar->ar_pln))
		goto out;
	switch (ntohs(ar->ar_pro)) {

	case ETHERTYPE_IP:
		in_revarpinput(ifp, m);
		return;

	default:
		break;
	}
out:
	m_freem(m);
}

/*
 * RARP for Internet protocols on Ethernet.
 * Algorithm is that given in RFC 903.
 * We are only using for bootstrap purposes to get an ip address for one of
 * our interfaces.  Thus we support no user-interface.
 *
 * Since the contents of the RARP reply are specific to the interface that
 * sent the request, this code must ensure that they are properly associated.
 *
 * Note: also supports ARP via RARP packets, per the RFC.
 */
void
in_revarpinput(struct ifnet *ifp, struct mbuf *m)
{
	struct ether_arp *ar;
	int op;

	ar = mtod(m, struct ether_arp *);
	op = ntohs(ar->arp_op);
	switch (op) {
	case ARPOP_REQUEST:
	case ARPOP_REPLY:	/* per RFC */
		niq_enqueue(&arpinq, m);
		return;
	case ARPOP_REVREPLY:
		break;
	case ARPOP_REVREQUEST:	/* handled by rarpd(8) */
	default:
		goto out;
	}
#ifdef NFSCLIENT
	if (revarp_ifidx == 0)
		goto out;
	if (revarp_ifidx != m->m_pkthdr.ph_ifidx) /* !same interface */
		goto out;
	if (revarp_finished)
		goto wake;
	if (memcmp(ar->arp_tha, LLADDR(ifp->if_sadl), sizeof(ar->arp_tha)))
		goto out;
	memcpy(&revarp_srvip, ar->arp_spa, sizeof(revarp_srvip));
	memcpy(&revarp_myip, ar->arp_tpa, sizeof(revarp_myip));
	revarp_finished = 1;
wake:	/* Do wakeup every time in case it was missed. */
	wakeup((caddr_t)&revarp_myip);
#endif /* NFSCLIENT */

out:
	m_freem(m);
}

/*
 * Send a RARP request for the ip address of the specified interface.
 * The request should be RFC 903-compliant.
 */
void
revarprequest(struct ifnet *ifp)
{
	struct sockaddr sa;
	struct mbuf *m;
	struct ether_header *eh;
	struct ether_arp *ea;
	struct arpcom *ac = (struct arpcom *)ifp;

	if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
		return;
	m->m_len = sizeof(*ea);
	m->m_pkthdr.len = sizeof(*ea);
	m->m_pkthdr.pf.prio = ifp->if_llprio;
	MH_ALIGN(m, sizeof(*ea));
	ea = mtod(m, struct ether_arp *);
	eh = (struct ether_header *)sa.sa_data;
	memset(ea, 0, sizeof(*ea));
	memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof(eh->ether_dhost));
	eh->ether_type = htons(ETHERTYPE_REVARP);
	ea->arp_hrd = htons(ARPHRD_ETHER);
	ea->arp_pro = htons(ETHERTYPE_IP);
	ea->arp_hln = sizeof(ea->arp_sha);	/* hardware address length */
	ea->arp_pln = sizeof(ea->arp_spa);	/* protocol address length */
	ea->arp_op = htons(ARPOP_REVREQUEST);
	memcpy(eh->ether_shost, ac->ac_enaddr, sizeof(ea->arp_tha));
	memcpy(ea->arp_sha, ac->ac_enaddr, sizeof(ea->arp_sha));
	memcpy(ea->arp_tha, ac->ac_enaddr, sizeof(ea->arp_tha));
	sa.sa_family = pseudo_AF_HDRCMPLT;
	sa.sa_len = sizeof(sa);
	m->m_flags |= M_BCAST;
	ifp->if_output(ifp, m, &sa, NULL);
}

#ifdef NFSCLIENT
/*
 * RARP for the ip address of the specified interface, but also
 * save the ip address of the server that sent the answer.
 * Timeout if no response is received.
 */
int
revarpwhoarewe(struct ifnet *ifp, struct in_addr *serv_in,
    struct in_addr *clnt_in)
{
	int result, count = 20;

	if (revarp_finished)
		return EIO;

	revarp_ifidx = ifp->if_index;
	while (count--) {
		revarprequest(ifp);
		result = tsleep((caddr_t)&revarp_myip, PSOCK, "revarp", hz/2);
		if (result != EWOULDBLOCK)
			break;
	}
	revarp_ifidx = 0;
	if (!revarp_finished)
		return ENETUNREACH;

	memcpy(serv_in, &revarp_srvip, sizeof(*serv_in));
	memcpy(clnt_in, &revarp_myip, sizeof(*clnt_in));
	return 0;
}

/* For compatibility: only saves interface address. */
int
revarpwhoami(struct in_addr *in, struct ifnet *ifp)
{
	struct in_addr server;
	return (revarpwhoarewe(ifp, &server, in));
}
#endif /* NFSCLIENT */
@


1.227
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.226 2016/11/20 11:46:45 mpi Exp $	*/
d653 1
a653 1
		rt_sendmsg(rt, RTM_RESOLVE, ifp->if_rdomain);
@


1.226
log
@Make rtable_iterate(9) mpsafe by using the new SRPL_NEXT(9).

ok dlg@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.225 2016/11/07 09:19:46 mpi Exp $	*/
d113 1
a114 1
	struct llinfo_arp *la, *nla;
d116 1
a116 1
	s = splsoftnet();
d124 1
a124 1
	splx(s);
@


1.225
log
@ARP and NDP timeouts mess with the routing table, so they need a process
context.

Convert them to timeout_set_proc(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.224 2016/09/15 02:00:18 dlg Exp $	*/
a733 1
		KERNEL_LOCK();
a738 1
		KERNEL_UNLOCK();
@


1.224
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.223 2016/09/07 09:36:49 mpi Exp $	*/
d141 1
a141 1
		timeout_set(&arptimer_to, arptimer, &arptimer_to);
@


1.223
log
@Rename rtable_mpath_next() into rtable_iterate() and make it do a proper
reference count.

rtable_iterate() frees the passed ``rt'' and returns the next one on the
multipath list or NULL if there's none.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.222 2016/09/06 00:04:15 dlg Exp $	*/
d138 2
a139 3
		pool_init(&arp_pool, sizeof(struct llinfo_arp), 0, 0, 0, "arp",
		    NULL);
		pool_setipl(&arp_pool, IPL_SOFTNET);
@


1.222
log
@pool_setipl for various netinet and netinet6 bits

thank you to everyone who helped reviewed these diffs

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.221 2016/08/22 16:01:52 mpi Exp $	*/
d734 1
a734 3
		struct rtentry *mrt = NULL;
#if defined(ART) && !defined(SMALL_KERNEL)
		mrt = rt;
d736 2
a737 3
		while ((mrt = rtable_mpath_next(mrt)) != NULL) {
			if (ISSET(mrt->rt_flags, RTF_ANNOUNCE)) {
				rtref(mrt);
d742 1
a742 3
#endif /* ART && !SMALL_KERNEL */
		rtfree(rt);
		return (mrt);
@


1.221
log
@Make the ``rt_gwroute'' pointer of RTF_GATEWAY entries immutable.

This means that no protection is needed to guarantee that the next hop
route wont be modified by CPU1 while CPU0 is dereferencing it in a L2
resolution functions.

While here also fix an ``ifa'' leak resulting in RTF_GATEWAY being always
invalid.

dlg@@ likes it, inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.220 2016/07/14 14:01:40 mpi Exp $	*/
d140 1
@


1.220
log
@Prevent a use-after-free by not updating an ARP entry that has been
removed from the table.

Currently the storage for L2 addresses is freed when an entry is
removed from the table.  That means that we cannot access this
chunk of memory between RTM_DELETE and rtfree(9).

Note that this doesn't apply to MPLS because the associated storage
is currently released by the last rtfree(9).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.219 2016/07/13 16:45:19 mpi Exp $	*/
d81 1
d219 6
a315 1
	int error;
d326 4
a329 2
	error = rt_checkgate(rt0, &rt);
	if (error) {
d331 1
a331 1
		return (error);
d678 12
a695 2
	struct llinfo_arp *la = (struct llinfo_arp *)rt->rt_llinfo;
	struct sockaddr_dl *sdl = satosdl(rt->rt_gateway);
d698 2
d701 2
a702 6
	if ((sdl != NULL) && (sdl->sdl_family == AF_LINK)) {
		sdl->sdl_alen = 0;
		la->la_asked = 0;
	}

	if (!ISSET(rt->rt_flags, RTF_STATIC))
@


1.219
log
@Move ARP processing back to the KERNEL_LOCK()ed task until the race
triggered by updating a cached, but removed from the table, entry is
properly fixed.

Diff from dlg@@, prodding deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.218 2016/07/13 08:40:46 mpi Exp $	*/
d214 1
a214 1
		rt->rt_llinfo = 0;
d533 6
a538 1
		if (arpcache(ifp, ea, rt))
d580 1
d582 7
@


1.218
log
@Introduce RTF_MULTICAST and flag corresponding IPv6 routes as such
instead of abusing RTF_CLONING.

Fix a leak reporeted by Aaron Riekenberg on misc@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.217 2016/07/11 09:23:06 mpi Exp $	*/
d89 2
d443 22
a464 1
	in_arpinput(ifp, m);
d814 1
a814 1
		in_arpinput(ifp, m);
@


1.217
log
@Revert the introduction of ``rt_addr''.

Being able to add route entries without configured addresses is a nice
feature but this is not my fight.  So I'd rather no add another pointer
to ``struct rtentry'' if I'm not removing another one.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.216 2016/06/28 17:18:24 chris Exp $	*/
d142 1
a142 1
	if (rt->rt_flags & (RTF_GATEWAY|RTF_BROADCAST))
@


1.216
log
@Add sysctl for arp timers: net.inet.ip.arptimeout (expire timer for resolved
entries) and net.inet.ip.arpdown (expire timer for unresolved entries)

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.215 2016/06/14 09:44:41 mpi Exp $	*/
d392 1
a392 1
				    &satosin(rt->rt_addr)->sin_addr.s_addr,
@


1.215
log
@Store the source address associated with a route in its own chunk of
memory.

This will allow to unlink 'sruct rtentry' and 'struct ifaddr' to be able
to add route entries without needing an address.

ok sthen@@, visa@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.214 2016/06/10 20:33:29 vgross Exp $	*/
d77 2
a78 2
int	arpt_prune = (5*60*1);	/* walk list every 5 minutes */
int	arpt_keep = (20*60);	/* once resolved, good for 20 more minutes */
@


1.214
log
@Add the "llprio" field to struct ifnet, and the corresponding keyword
to ifconfig.

"llprio" allows one to set the priority of packets that do not go through
pf(4), as the case is for arp(4) or bpf(4).

ok sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.213 2016/06/06 07:07:11 mpi Exp $	*/
d392 1
a392 1
				    &satosin(rt->rt_ifa->ifa_addr)->sin_addr.s_addr,
@


1.213
log
@Move logic to send ARP replies to arpreply().

ok florian@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.212 2016/06/06 07:01:37 mpi Exp $	*/
d238 1
d836 1
@


1.212
log
@Get rid of the ``enaddr'' argument of carp_iamatch().

It was only checked in balancing mode, which is currently broken, and is
no longer needed.

Discusssed with bluhm@@ and Florian Riehm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.211 2016/06/03 02:56:59 dlg Exp $	*/
d87 1
d259 27
a451 1
	struct ether_header *eh;
a452 1
	struct sockaddr sa;
a454 1
	uint8_t enaddr[ETHER_ADDR_LEN];
d480 1
a480 2
	memcpy(enaddr, LLADDR(ifp->if_sadl), ETHER_ADDR_LEN);
	if (!memcmp(ea->arp_sha, enaddr, sizeof(ea->arp_sha)))
d513 2
a514 2
	if (op != ARPOP_REQUEST)
		goto out;
d516 15
a530 17
	rtfree(rt);
	if (target) {
		/* We are the target and already have all info for the reply */
		memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
		memcpy(ea->arp_sha, LLADDR(ifp->if_sadl), sizeof(ea->arp_sha));
	} else {
		struct sockaddr_dl *sdl;

		rt = arplookup(&itaddr, 0, SIN_PROXY, rdomain);
		if (rt == NULL)
			goto out;
		/* protect from possible duplicates only owner should respond */
		if (rt->rt_ifidx != ifp->if_index)
			goto out;
		memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
		sdl = satosdl(rt->rt_gateway);
		memcpy(ea->arp_sha, LLADDR(sdl), sizeof(ea->arp_sha));
d532 1
a533 14

	memcpy(ea->arp_tpa, ea->arp_spa, sizeof(ea->arp_spa));
	memcpy(ea->arp_spa, &itaddr, sizeof(ea->arp_spa));
	ea->arp_op = htons(ARPOP_REPLY);
	ea->arp_pro = htons(ETHERTYPE_IP); /* let's be sure! */
	eh = (struct ether_header *)sa.sa_data;
	memcpy(eh->ether_dhost, ea->arp_tha, sizeof(eh->ether_dhost));
	memcpy(eh->ether_shost, enaddr, sizeof(eh->ether_shost));

	eh->ether_type = htons(ETHERTYPE_ARP);
	sa.sa_family = pseudo_AF_HDRCMPLT;
	sa.sa_len = sizeof(sa);
	ifp->if_output(ifp, m, &sa, NULL);
	return;
@


1.211
log
@set rt_expire times against time_uptime, not time_second.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.210 2016/05/31 07:50:34 mpi Exp $	*/
d470 1
a470 1
	    !carp_iamatch(ifp, enaddr))
@


1.210
log
@Stop creating and inserting a route entry for ARP and ND automagically.

Callers MUST do a route lookup before sending a packet.

Tested by Hrvoje Popovski, ok visa@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.209 2016/05/23 09:23:43 mpi Exp $	*/
d117 1
a117 1
		if (rt->rt_expire && rt->rt_expire <= time_second)
a135 7
		/*
		 * We generate expiration times from time.tv_sec
		 * so avoid accidently creating permanent routes.
		 */
		if (time_second == 0) {
			time_second++;
		}
d154 1
a154 1
			rt->rt_expire = time_second;
d315 1
a315 1
	if ((rt->rt_expire == 0 || rt->rt_expire > time_second) &&
d354 1
a354 1
		rt->rt_expire = time_second;
d359 2
a360 2
		if (la->la_asked == 0 || rt->rt_expire != time_second) {
			rt->rt_expire = time_second;
d593 1
a593 1
		rt->rt_expire = time_second + arpt_keep;
@


1.209
log
@Pass a 'struct in_addr *' to arplookup() instead of always dereferencing
one.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.208 2016/05/23 09:09:04 mpi Exp $	*/
a283 1
	struct mbuf *mh;
d285 1
a285 1
	int error, created = 0;
d296 5
a300 6
	if (rt0 != NULL) {
		error = rt_checkgate(rt0, &rt);
		if (error) {
			m_freem(m);
			return (error);
		}
d302 7
a308 8
		if ((rt->rt_flags & RTF_LLINFO) == 0) {
			log(LOG_DEBUG, "%s: %s: route contains no arp"
			    " information\n", __func__, inet_ntop(AF_INET,
				&satosin(rt_key(rt))->sin_addr, addr,
				sizeof(addr)));
			m_freem(m);
			return (EINVAL);
		}
a309 19
		la = (struct llinfo_arp *)rt->rt_llinfo;
		if (la == NULL)
			log(LOG_DEBUG, "%s: %s: route without link "
			    "local address\n", __func__, inet_ntop(AF_INET,
				&satosin(dst)->sin_addr, addr, sizeof(addr)));
	} else {
		rt = arplookup(&satosin(dst)->sin_addr, 1, 0, ifp->if_rdomain);
		if (rt != NULL) {
		    	created = 1;
			la = ((struct llinfo_arp *)rt->rt_llinfo);
		}
		if (la == NULL)
			log(LOG_DEBUG, "%s: %s: can't allocate llinfo\n",
			    __func__,
			    inet_ntop(AF_INET, &satosin(dst)->sin_addr,
				addr, sizeof(addr)));
	}
	if (la == NULL || rt == NULL)
		goto bad;
d317 1
a324 2
		if (created)
			rtfree(rt);
d327 1
d336 2
d339 2
d381 1
a381 2
	if (created)
		rtfree(rt);
a385 2
	if (created)
		rtfree(rt);
@


1.208
log
@Shorten en error string.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.207 2016/05/18 20:15:14 mpi Exp $	*/
d83 1
a83 1
struct rtentry *arplookup(u_int32_t, int, int, u_int);
d319 1
a319 2
		rt = arplookup(satosin(dst)->sin_addr.s_addr, 1, 0,
		    ifp->if_rdomain);
d502 2
a503 2
	/* Do we have an ARP cache for the sender?  Create if we are target. */
	rt = arplookup(isaddr.s_addr, target, 0, rdomain);
d528 1
a528 1
		rt = arplookup(itaddr.s_addr, 0, SIN_PROXY, rdomain);
d677 1
a677 1
arplookup(u_int32_t addr, int create, int proxy, u_int tableid)
d686 1
a686 1
	sin.sin_addr.s_addr = addr;
d729 1
a729 1
	rt = arplookup(in.s_addr, 0, SIN_PROXY, rtableid);
@


1.207
log
@Remove some superflous if_get(9)/if_put(9) dances now that ARP input
routines are call directly by ether_input().

ok visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.206 2016/05/18 08:05:51 mpi Exp $	*/
d510 2
a511 3
		log(LOG_ERR,
		   "duplicate IP address %s sent from ethernet address %s\n",
		   addr, ether_sprintf(ea->arp_sha));
@


1.206
log
@Move the code to update an ARP cache into its own function.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.205 2016/04/27 14:47:27 mpi Exp $	*/
d84 2
a85 2
void in_arpinput(struct mbuf *);
void in_revarpinput(struct mbuf *);
d416 1
a416 1
arpinput(struct mbuf *m)
d441 1
a441 1
	in_arpinput(m);
d450 1
a450 1
in_arpinput(struct mbuf *m)
a452 1
	struct ifnet *ifp;
a464 5
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL) {
		m_freem(m);
		return;
	}
a553 1
	if_put(ifp);
a557 1
	if_put(ifp);
d765 1
a765 1
revarpinput(struct mbuf *m)
d779 1
a779 1
		in_revarpinput(m);
d801 1
a801 1
in_revarpinput(struct mbuf *m)
a802 1
	struct ifnet *ifp = NULL;
d811 1
a811 1
		in_arpinput(m);
a825 3
	ifp = if_get(revarp_ifidx);
	if (ifp == NULL)
		goto out;
d833 1
a833 1
#endif
a836 1
	if_put(ifp);
@


1.205
log
@Remove unused arguments from rt_checkgate().

Since the rtalloc(9) rewrite no route lookup is done in this function so
there's no need for a destination or a rtable ID.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.204 2016/03/30 10:13:14 mpi Exp $	*/
d86 1
a454 1
	struct llinfo_arp *la = NULL;
a455 1
	struct sockaddr_dl *sdl;
a458 1
	struct mbuf *mh;
d461 2
a462 2
	int op, changed = 0, target = 0;
	unsigned int len, rdomain;
d482 6
a487 8
	if (ETHER_IS_MULTICAST(&ea->arp_sha[0])) {
		if (!memcmp(ea->arp_sha, etherbroadcastaddr,
		    sizeof (ea->arp_sha))) {
			inet_ntop(AF_INET, &isaddr, addr, sizeof(addr));
			log(LOG_ERR, "arp: ether address is broadcast for "
			    "IP address %s!\n", addr);
			goto out;
		}
d520 2
a521 57
	} else if (rt != NULL && (sdl = satosdl(rt->rt_gateway)) != NULL) {
		la = (struct llinfo_arp *)rt->rt_llinfo;
		if (sdl->sdl_alen) {
			if (memcmp(ea->arp_sha, LLADDR(sdl), sdl->sdl_alen)) {
				if (rt->rt_flags &
				    (RTF_PERMANENT_ARP|RTF_LOCAL)) {
					inet_ntop(AF_INET, &isaddr, addr,
					    sizeof(addr));
					log(LOG_WARNING, "arp: attempt to"
					   " overwrite permanent entry for %s"
					   " by %s on %s\n", addr,
					   ether_sprintf(ea->arp_sha),
					   ifp->if_xname);
					goto out;
				} else if (rt->rt_ifidx != ifp->if_index) {
#if NCARP > 0
					if (ifp->if_type != IFT_CARP)
#endif
					{
						struct ifnet *rifp = if_get(
						    rt->rt_ifidx);
						if (rifp == NULL)
							goto out;
						inet_ntop(AF_INET, &isaddr,
						    addr, sizeof(addr));
						log(LOG_WARNING, "arp: attempt"
						   " to overwrite entry for"
						   " %s on %s by %s on %s\n",
						   addr, rifp->if_xname,
						   ether_sprintf(ea->arp_sha),
						   ifp->if_xname);
						if_put(rifp);
					}
					goto out;
				} else {
					inet_ntop(AF_INET, &isaddr, addr,
					    sizeof(addr));
					log(LOG_INFO, "arp info overwritten for"
					   " %s by %s on %s\n", addr,
					   ether_sprintf(ea->arp_sha),
					   ifp->if_xname);
					rt->rt_expire = 1;/* no longer static */
				}
			changed = 1;
			}
		} else if (!if_isconnected(ifp, rt->rt_ifidx)) {
			struct ifnet *rifp = if_get(rt->rt_ifidx);
			if (rifp == NULL)
				goto out;
			inet_ntop(AF_INET, &isaddr, addr, sizeof(addr));
			log(LOG_WARNING,
			    "arp: attempt to add entry for %s "
			    "on %s by %s on %s\n", addr,
			    rifp->if_xname,
			    ether_sprintf(ea->arp_sha),
			    ifp->if_xname);
			if_put(rifp);
a522 28
		}
		sdl->sdl_alen = sizeof(ea->arp_sha);
		memcpy(LLADDR(sdl), ea->arp_sha, sizeof(ea->arp_sha));
		if (rt->rt_expire)
			rt->rt_expire = time_second + arpt_keep;
		rt->rt_flags &= ~RTF_REJECT;
		/* Notify userland that an ARP resolution has been done. */
		if (la->la_asked || changed) {
			KERNEL_LOCK();
			rt_sendmsg(rt, RTM_RESOLVE, ifp->if_rdomain);
			KERNEL_UNLOCK();
		}
		la->la_asked = 0;
		while ((len = ml_len(&la->la_ml)) != 0) {
			mh = ml_dequeue(&la->la_ml);
			la_hold_total--;

			ifp->if_output(ifp, mh, rt_key(rt), rt);

			if (ml_len(&la->la_ml) == len) {
				/* mbuf is back in queue. Discard. */
				while ((mh = ml_dequeue(&la->la_ml)) != NULL) {
					la_hold_total--;
					m_freem(mh);
				}
				break;
			}
		}
d525 2
a526 7
	if (op != ARPOP_REQUEST) {
out:
		rtfree(rt);
		if_put(ifp);
		m_freem(m);
		return;
	}
d534 2
d561 6
d569 93
@


1.204
log
@Implement proxy ARP for ART based on mpath support.

Since mpath is not enabled in RAMDISK, proxy ARP won't work there either.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.203 2016/03/24 07:15:10 mpi Exp $	*/
d297 1
a297 2
		error = rt_checkgate(ifp, rt0, dst,
		    m->m_pkthdr.ph_rtableid, &rt);
@


1.203
log
@Ensure that a found proxy ARP entry has the correct flag.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.202 2016/03/07 11:00:36 mpi Exp $	*/
d701 12
d714 1
a714 1
		return (NULL);
@


1.202
log
@Do not remove RTF_STATIC L2 entries from the routing table.

This restore the previous behavior without looking at the reference
counter of route entries.

Static entries might not have a cloning route to re-create them and
when their timer expires they were completly gone as found the hardway
by matthieu@@.

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.201 2016/01/21 03:34:05 dlg Exp $	*/
d699 6
@


1.201
log
@remove the arp_inuse and arp_allocated counters

we can get the same info from the arp pool:

# vmstat -m | grep -e ^arp -e ^Name
Name        Size Requests Fail    InUse Pgreq Pgrel Npage Hiwat Minpg Maxpg Idle
arp           56       84    0        6     1     0     1     1     0     8    0

Requests and InUse end up being the same:

# pstat -d d arp_allocated
arp_allocated at 0xffffffff81942084: 84
# pstat -d d arp_inuse
arp_inuse at 0xffffffff81942098: 6

ok bluhm@@ claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.200 2016/01/14 12:41:02 mpi Exp $	*/
d670 2
a671 1
	rtdeletemsg(rt, ifp, ifp->if_rdomain);
@


1.201.2.1
log
@Backport ARP race fix:

Move ARP processing back to the KERNEL_LOCK()ed task until the race
triggered by updating a cached, but removed from the table, entry is
properly fixed.

Diff from dlg@@, prodding deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.201 2016/01/21 03:34:05 dlg Exp $	*/
a86 2
struct niqueue arpinq = NIQUEUE_INITIALIZER(50, NETISR_ARP);

d441 1
a441 13
	niq_enqueue(&arpinq, m);
}

void
arpintr(void)
{
	struct mbuf_list ml;
	struct mbuf *m;

	niq_delist(&arpinq, &ml);

	while ((m = ml_dequeue(&ml)) != NULL)
		in_arpinput(m);
d793 1
a793 1
		niq_enqueue(&arpinq, m);
@


1.200
log
@Grab the KERNEL_LOCK before delivering a message to the routing socket
when an ARP resolution has been done.

Should hopefully fix the "receive 1" panic reported by benno@@ on bugs@@.

ok claudio@@, phessler@@, benno@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.199 2016/01/08 13:53:24 mpi Exp $	*/
a88 1
int	arp_inuse, arp_allocated;
d195 1
a195 2
		arp_inuse++;
		arp_allocated++;
a215 1
		arp_inuse--;
@


1.199
log
@Get rid of the arp and revarp input queues.

Packets of types ARP and REVARP are now processed in the softnet task,
directly from ether_input() and without holding the KERNEL_LOCK.

Tested by many, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.198 2015/12/17 16:05:30 tedu Exp $	*/
d593 2
a594 1
		if (la->la_asked || changed)
d596 2
@


1.198
log
@rm a bit more trailers code. no longer accept them as alias for ethernet.
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.197 2015/12/02 22:02:18 claudio Exp $	*/
a84 1
void revarpinput(struct mbuf *);
a88 3
/* XXX hate magic numbers */
struct	niqueue arpintrq = NIQUEUE_INITIALIZER(50, NETISR_ARP);
struct	niqueue rarpintrq = NIQUEUE_INITIALIZER(50, NETISR_ARP);
d419 1
a419 1
arpintr(void)
a420 1
	struct mbuf *m;
a423 1
	while ((m = niq_dequeue(&arpintrq)) != NULL) {
d425 2
a426 2
		if ((m->m_flags & M_PKTHDR) == 0)
			panic("arpintr");
d429 3
a431 9
		len = sizeof(struct arphdr);
		if (m->m_len < len && (m = m_pullup(m, len)) == NULL)
			continue;

		ar = mtod(m, struct arphdr *);
		if (ntohs(ar->ar_hrd) != ARPHRD_ETHER) {
			m_freem(m);
			continue;
		}
d433 3
a435 9
		len += 2 * (ar->ar_hln + ar->ar_pln);
		if (m->m_len < len && (m = m_pullup(m, len)) == NULL)
			continue;

		switch (ntohs(ar->ar_pro)) {
		case ETHERTYPE_IP:
			in_arpinput(m);
			continue;
		}
d437 1
d440 5
a444 2
	while ((m = niq_dequeue(&rarpintrq)) != NULL)
		revarpinput(m);
@


1.197
log
@Since we want to print the interface names in the log messages it is
required to do the if_get/if_put dance around the log() calls. These
were the last users of rt_ifp.
OK mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.196 2015/12/02 21:09:06 claudio Exp $	*/
a66 6
/*
 * ARP trailer negotiation.  Trailer protocol is not IP specific,
 * but ARP request/response use IP addresses.
 */
#define ETHERTYPE_IPTRAILERS ETHERTYPE_TRAIL

a450 1
		case ETHERTYPE_IPTRAILERS:
a773 1
	case ETHERTYPE_IPTRAILERS:
@


1.196
log
@More rt_ifp killing. There checks in in_arpinput() to verify that the
arp packet was recieved on the interface we expected. This is because
multicast and broadcast packets are sometimes forwarded on multiple
local interfaces. So simplify the checks and make them more generic
at the same time (in the SIN_PROXY case). For SIN_PROXY only the
interface holding the proxy arp route will answer to the requests.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.195 2015/12/02 18:38:19 claudio Exp $	*/
d568 4
d577 1
a577 1
						   addr, rt->rt_ifp->if_xname,
d580 1
d595 3
d602 1
a602 1
			    rt->rt_ifp->if_xname,
d605 1
@


1.195
log
@There is no reason for this carp magic in arpresolve. rt->rt_ifp has to
be the same as ifp or something is very broken. So remove this including
one more rt_ifp. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.194 2015/12/02 16:35:53 bluhm Exp $	*/
d563 1
a563 1
				} else if (rt->rt_ifp != ifp) {
d642 2
a643 2
#if NCARP > 0
		if (rt->rt_ifp->if_type == IFT_CARP && ifp->if_type != IFT_CARP)
a644 1
#endif
@


1.194
log
@When destroying an interface, we have to wait until all references
are not used anymore.  This has to be done before any interface
fields become invalid.
As the route delete request cannot call if_get() anymore, pass down
the interface.  Split rtrequest_delete() into a separate function
that may take an existing inteface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.193 2015/12/02 13:29:26 claudio Exp $	*/
a403 5
#if NCARP > 0
				    (rt->rt_ifp->if_type == IFT_CARP) ?
					((struct arpcom *) rt->rt_ifp->if_softc
					)->ac_enaddr :
#endif
@


1.193
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.192 2015/12/02 09:28:46 mpi Exp $	*/
d688 1
a688 1
	rtdeletemsg(rt, ifp->if_rdomain);
@


1.192
log
@Do not delete a conflicting & cloned route entry in the hot path.

Deleting a RTF_CLONED entry without deleting its corresponding RTF_CLONING
entry wont help as it will be cloned the next time arplookup() is executed.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.191 2015/12/01 12:22:18 mpi Exp $	*/
d707 1
a707 1
	flags = (create) ? (RT_REPORT|RT_RESOLVE) : 0;
@


1.191
log
@Remove backward compatibility for "older version of routed and gated".

ok millert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.190 2015/11/20 10:51:30 mpi Exp $	*/
d710 2
a711 3
	if (rt == NULL)
		return (NULL);
	if ((rt->rt_flags & RTF_GATEWAY) || (rt->rt_flags & RTF_LLINFO) == 0 ||
a712 2
		if (create && (rt->rt_flags & RTF_CLONED))
			rtdeletemsg(rt, tableid);
@


1.190
log
@This no longer depends on bridge.h, fewer "#ifdef NBRIDGE", say yeah!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.189 2015/11/20 10:50:08 mpi Exp $	*/
a163 8
		/*
		 * XXX: If this is a manually added route to interface
		 * such as older version of routed or gated might provide,
		 * restore cloning bit.
		 */
		if ((rt->rt_flags & RTF_HOST) == 0 && rt_mask(rt) &&
		    satosin(rt_mask(rt))->sin_addr.s_addr != 0xffffffff)
			rt->rt_flags |= RTF_CLONING;
@


1.189
log
@Fewer uses of rt_ifp.

Tested by and ok sthen@@,
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.188 2015/11/18 13:58:02 mpi Exp $	*/
a42 2
#include "bridge.h"

a64 3
#endif
#if NBRIDGE > 0
#include <net/if_bridge.h>
@


1.188
log
@Factorize the bits to check if a L2 route is connected, wether it is
attached to a carp(4) or bridge(4) member, to not dereference rt_ifp
directly.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.187 2015/11/18 13:53:59 mpi Exp $	*/
d624 1
a624 1
			rt_sendmsg(rt, RTM_RESOLVE, rt->rt_ifp->if_rdomain);
a682 1
	return;
d693 1
d695 1
d701 2
a702 1
	rtdeletemsg(rt, rt->rt_ifp->if_rdomain);
d747 2
a748 1
	if (rt == NULL)
d750 1
d759 6
a764 1
	ifp = rt->rt_ifp;
d768 1
@


1.187
log
@Make use of srp_enter()/srp_leave() in carp_iamatch() in preparation
for unlocking the ARP input path.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.186 2015/11/13 10:18:04 mpi Exp $	*/
d607 1
a607 12
		} else if (rt->rt_ifp != ifp &&
#if NBRIDGE > 0
		    !SAME_BRIDGE(ifp->if_bridgeport,
		    rt->rt_ifp->if_bridgeport) &&
#endif
#if NCARP > 0
		    !(rt->rt_ifp->if_type == IFT_CARP &&
		    rt->rt_ifp->if_carpdev == ifp) &&
		    !(ifp->if_type == IFT_CARP &&
		    ifp->if_carpdev == rt->rt_ifp) &&
#endif
		    1) {
@


1.186
log
@Sore the index of the interface used for revarp instead of a pointer to
its descriptor.  Get rid of a if_ref().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.185 2015/11/06 23:45:21 bluhm Exp $	*/
a495 1
	struct arpcom *ac;
d504 1
a504 4
	u_int8_t *enaddr = NULL;
#if NCARP > 0
	uint8_t *ethshost = NULL;
#endif
a515 2
	ac = (struct arpcom *)ifp;

d537 4
d549 1
a549 1
	
d552 1
a552 1
	    !carp_iamatch(ifp, &ethshost))
a555 5
	if (!enaddr)
		enaddr = ac->ac_enaddr;
	if (!memcmp(ea->arp_sha, enaddr, sizeof(ea->arp_sha)))
		goto out;	/* it's from me, ignore it. */

d666 1
a666 1
		memcpy(ea->arp_sha, enaddr, sizeof(ea->arp_sha));
d671 1
d674 1
a686 4
#if NCARP > 0
	if (ethshost)
		enaddr = ethshost;
#endif
@


1.185
log
@In in_arpinput() do not make an extra route lookup to check wether
the sender address is a local IP.  The arplookup() does this route
lookup anyway, so just check its result.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.184 2015/11/05 12:46:23 bluhm Exp $	*/
d113 1
a113 1
struct ifnet *revarp_ifp;
d829 1
d847 1
a847 1
	if (revarp_ifp == NULL)
d849 1
a849 1
	if (revarp_ifp->if_index != m->m_pkthdr.ph_ifidx) /* !same interface */
d853 4
a856 2
	if (memcmp(ar->arp_tha, ((struct arpcom *)revarp_ifp)->ac_enaddr,
	    sizeof(ar->arp_tha)))
d867 1
d922 1
a922 1
	revarp_ifp = if_ref(ifp);
d929 1
a929 2
	if_put(revarp_ifp);
	revarp_ifp = NULL;
@


1.184
log
@In in_arpinput() replace the loops over the interface addresses
with route lookups.  Check wether ARP sender or target protocol
address is a local IP address.  Remove the loop that checks wether
any IPv4 address is configured on the receiving interface.
input, test, OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.183 2015/11/04 00:16:12 dlg Exp $	*/
d510 1
a510 1
	int op, changed = 0, target = 0, sender = 0;
d543 1
a543 1
	/* First try: check target against our addresses */
a557 9
	/* Second try: check sender against our addresses */
	sin.sin_addr = isaddr;
	rt = rtalloc(sintosa(&sin), 0, rdomain);
	if (rtisvalid(rt) && ISSET(rt->rt_flags, RTF_LOCAL) &&
	    rt->rt_ifidx == ifp->if_index)
		sender = 1;
	rtfree(rt);
	rt = NULL;

d563 6
a568 1
	if (sender && isaddr.s_addr != INADDR_ANY) {
d574 1
a574 6
		goto reply;
	}

	/* Do we have an ARP cache for the sender?  Create if we are target. */
	rt = arplookup(isaddr.s_addr, target, 0, rdomain);
	if (rt != NULL && (sdl = satosdl(rt->rt_gateway)) != NULL) {
d660 1
a660 1
reply:
@


1.183
log
@use ml_purge to flush the arp hold lists instead of dequeue/free loops.

this is an interesting change because the loops have to decrement
the global hold count too. they looked like this:

	while ((mh = ml_dequeue(&la->la_ml)) != NULL) {
		la_hold_total--;
		m_freem(mh);
	}

because ml_purge returns how many mbufs were freed, we can do this:

	la_hold_total -= ml_purge(&la->la_ml);

ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.182 2015/11/02 15:05:23 mpi Exp $	*/
a499 1
	struct ifaddr *ifa;
d502 2
a503 1
	struct in_addr isaddr, itaddr, myaddr;
d510 4
a513 2
	int op, changed = 0;
	unsigned int len;
d529 3
d544 8
a551 9
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;

		if (itaddr.s_addr != ifatoia(ifa)->ia_addr.sin_addr.s_addr)
			continue;

		if (op == ARPOP_REPLY)
			break;
d553 3
a555 2
		if (ifp->if_type == IFT_CARP && !carp_iamatch(ifp, &ethshost))
			goto out;
a556 2
		break;
	}
d558 8
a565 22
	/* Second try: check source against our addresses */
	if (ifa == NULL) {
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET)
				continue;

			if (isaddr.s_addr ==
			    ifatoia(ifa)->ia_addr.sin_addr.s_addr)
				break;
		}
	}

	/* Third try: not one of our addresses, just find a usable ia */
	if (ifa == NULL) {
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family == AF_INET)
				break;
		}
	}

	if (ifa == NULL)
		goto out;
a568 2
	myaddr = ifatoia(ifa)->ia_addr.sin_addr;

d572 1
a572 1
	if (myaddr.s_addr != INADDR_ANY && isaddr.s_addr == myaddr.s_addr) {
d577 1
a577 1
		itaddr = myaddr;
d581 2
a582 2
	rt = arplookup(isaddr.s_addr, itaddr.s_addr == myaddr.s_addr, 0,
	    rtable_l2(m->m_pkthdr.ph_rtableid));
d679 2
a680 2
	if (itaddr.s_addr == myaddr.s_addr) {
		/* I am the target */
d684 1
a684 2
		rt = arplookup(itaddr.s_addr, 0, SIN_PROXY,
		    rtable_l2(m->m_pkthdr.ph_rtableid));
@


1.182
log
@Retire ARP load-balacing, thanks for all the fish!

One of the keys of our MP work relies on making OpenBSD's kernel simpler!
In this case turning ARP processing MP-safe is quite complicated due to
the way carp(4) is hooked in arpinput() and nowadays you'd better run
kitchensinkd(9) anyway :)

ok bluhm@@, claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.181 2015/11/02 14:08:54 bluhm Exp $	*/
a143 1
	struct mbuf *m;
d245 1
a245 4
		while ((m = ml_dequeue(&la->la_ml)) != NULL) {
			la_hold_total--;
			m_freem(m);
		}
d394 1
a394 4
		while ((mh = ml_dequeue(&la->la_ml)) != NULL) {
			la_hold_total--;
			m_freem(mh);
		}
d427 1
a427 4
				while ((mh = ml_dequeue(&la->la_ml)) != NULL) {
					la_hold_total--;
					m_freem(mh);
				}
@


1.181
log
@Rename the list of arp entries to arp_list.  This is consistent to
the other arp variables and nd6.  Convert a hand-crafted loop to
LIST_FOREACH_SAFE.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.180 2015/11/01 22:53:34 bluhm Exp $	*/
d517 1
a517 1
	u_int8_t *ether_shost = NULL;
d556 2
d559 2
a560 11
		if (ifp->if_type == IFT_CARP &&
		    ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) ==
		    (IFF_UP|IFF_RUNNING))) {
			if (op == ARPOP_REPLY)
				break;
			if (carp_iamatch(ifp, ea->arp_sha,
			    &enaddr, &ether_shost))
				break;
			else
				goto out;
		}
d726 2
a727 2
	if (ether_shost)
		enaddr = ether_shost;
@


1.180
log
@Replace the nd6 llinfo malloc(9) with pool_get(9) like arp does.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.179 2015/10/27 15:22:58 mpi Exp $	*/
d99 1
a99 1
LIST_HEAD(, llinfo_arp) llinfo_arp;
d129 1
a129 1
	for (la = LIST_FIRST(&llinfo_arp); la != NULL; la = nla) {
a131 1
		nla = LIST_NEXT(la, la_list);
d225 1
a225 1
		LIST_INSERT_HEAD(&llinfo_arp, la, la_list);
d508 1
a508 1
	struct llinfo_arp *la = 0;
@


1.179
log
@RIP arp_ifinit().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.178 2015/10/27 10:54:52 mpi Exp $	*/
d218 1
a218 1
			log(LOG_DEBUG, "%s: malloc failed\n", __func__);
@


1.178
log
@Move code around for clarity, no functional change.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.177 2015/10/25 11:58:11 mpi Exp $	*/
a821 5
}

void
arp_ifinit(struct arpcom *ac, struct ifaddr *ifa)
{
@


1.177
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.176 2015/10/22 18:14:53 mpi Exp $	*/
d539 10
d602 2
a603 9
	if (ETHER_IS_MULTICAST(&ea->arp_sha[0]))
		if (!memcmp(ea->arp_sha, etherbroadcastaddr,
		    sizeof (ea->arp_sha))) {
			inet_ntop(AF_INET, &isaddr, addr, sizeof(addr));
			log(LOG_ERR, "arp: ether address is broadcast for "
			    "IP address %s!\n", addr);
			goto out;
		}
	if (myaddr.s_addr && isaddr.s_addr == myaddr.s_addr) {
d611 1
@


1.176
log
@Drop historical comment and an old '#if notyet'.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.175 2015/10/22 16:44:54 mpi Exp $	*/
d140 1
a140 1
arp_rtrequest(int req, struct rtentry *rt)
a143 1
	struct ifnet *ifp = rt->rt_ifp;
a822 1
	ifa->ifa_rtrequest = arp_rtrequest;
@


1.175
log
@Make sure that the address matching the key (destination) of a route
entry is attached to this entry.

ok phessler@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.174 2015/10/22 15:37:47 bluhm Exp $	*/
d499 1
a499 2
 * ARP for Internet protocols on Ethernet.
 * Algorithm is that given in RFC 826.
a501 8
 * We no longer handle negotiations for use of trailer protocol:
 * Formerly, ARP replied for protocol type ETHERTYPE_TRAIL sent
 * along with IP replies if we wanted trailers sent to us,
 * and also sent them in response to IP replies.
 * This allowed either end to announce the desire to receive
 * trailer packets.
 * We no longer reply to requests for ETHERTYPE_TRAIL protocol either,
 * but formerly didn't normally send requests.
a535 7
#if notyet
	if ((op == ARPOP_REPLY) && (m->m_flags & (M_BCAST|M_MCAST))) {
		log(LOG_ERR,
		    "arp: received reply to broadcast or multicast address\n");
		goto out;
	}
#endif
@


1.174
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.173 2015/10/22 13:30:29 mpi Exp $	*/
d236 1
a237 10
			/*
			 * make sure to set rt->rt_ifa to the interface
			 * address we are using, otherwise we will have trouble
			 * with source address selection.
			 */
			if (ifa != rt->rt_ifa) {
				ifafree(rt->rt_ifa);
				ifa->ifa_refcnt++;
				rt->rt_ifa = ifa;
			}
@


1.173
log
@Do not pass an ``ia'' just to dereference ``ia_ifp''.

ok claudio@@, bluhm@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.172 2015/10/13 10:21:27 mpi Exp $	*/
a71 2
#define SDL(s) ((struct sockaddr_dl *)s)

d199 1
a199 1
			    (u_char *)LLADDR(SDL(gate)));
d208 2
a209 2
		SDL(gate)->sdl_type = ifp->if_type;
		SDL(gate)->sdl_index = ifp->if_index;
d374 1
a374 1
	sdl = SDL(rt->rt_gateway);
d636 1
a636 1
	if (rt != NULL && (sdl = SDL(rt->rt_gateway)) != NULL) {
d744 1
a744 1
		sdl = SDL(rt->rt_gateway);
d776 1
a776 1
	struct sockaddr_dl *sdl = SDL(rt->rt_gateway);
d832 1
a832 1
	sdl = (struct sockaddr_dl *)rt->rt_gateway;
@


1.172
log
@Simplify arptfree() to no longer look at the route entry's refcounter.

ARP entries with an expired timeout are now removed from the tree even
if they are cached somehwere else.  This also reduces differences with
NDP.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.171 2015/10/07 08:58:01 mpi Exp $	*/
d581 1
a581 1
			if (carp_iamatch(ifatoia(ifa), ea->arp_sha,
@


1.171
log
@Move route entry debug helpers where they belong.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.170 2015/09/28 08:26:58 mpi Exp $	*/
d94 1
a94 1
void arptfree(struct llinfo_arp *);
d136 1
a136 1
			arptfree(la); /* timer has expired; clear */
d775 1
a775 1
arptfree(struct llinfo_arp *la)
d777 2
a778 3
	struct rtentry *rt = la->la_rt;
	struct sockaddr_dl *sdl;
	u_int tid = 0;
d780 1
a780 4
	if (rt == NULL)
		panic("arptfree");
	if (rt->rt_refcnt > 0 && (sdl = SDL(rt->rt_gateway)) &&
	    sdl->sdl_family == AF_LINK) {
a782 2
		rt->rt_flags &= ~RTF_REJECT;
		return;
d785 1
a785 4
	if (rt->rt_ifp)
		tid = rt->rt_ifp->if_rdomain;

	rtdeletemsg(rt, tid);
@


1.170
log
@Do not manually decrement rt's refcounter in arplookup() and let the
callers rtfree(9) it.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.169 2015/09/16 06:58:08 claudio Exp $	*/
a117 8
#ifdef DDB

void	db_print_sa(struct sockaddr *);
void	db_print_ifa(struct ifaddr *);
void	db_print_llinfo(caddr_t);
int	db_show_rtentry(struct rtentry *, void *, unsigned int);
#endif

a1022 98

#ifdef DDB

#include <machine/db_machdep.h>
#include <ddb/db_output.h>

void
db_print_sa(struct sockaddr *sa)
{
	int len;
	u_char *p;

	if (sa == NULL) {
		db_printf("[NULL]");
		return;
	}

	p = (u_char *)sa;
	len = sa->sa_len;
	db_printf("[");
	while (len > 0) {
		db_printf("%d", *p);
		p++;
		len--;
		if (len)
			db_printf(",");
	}
	db_printf("]\n");
}

void
db_print_ifa(struct ifaddr *ifa)
{
	if (ifa == NULL)
		return;
	db_printf("  ifa_addr=");
	db_print_sa(ifa->ifa_addr);
	db_printf("  ifa_dsta=");
	db_print_sa(ifa->ifa_dstaddr);
	db_printf("  ifa_mask=");
	db_print_sa(ifa->ifa_netmask);
	db_printf("  flags=0x%x, refcnt=%d, metric=%d\n",
	    ifa->ifa_flags, ifa->ifa_refcnt, ifa->ifa_metric);
}

void
db_print_llinfo(caddr_t li)
{
	struct llinfo_arp *la;

	if (li == 0)
		return;
	la = (struct llinfo_arp *)li;
	db_printf("  la_rt=%p la_asked=0x%lx\n", la->la_rt, la->la_asked);
}

/*
 * Function to pass to rtalble_walk().
 * Return non-zero error to abort walk.
 */
int
db_show_rtentry(struct rtentry *rt, void *w, unsigned int id)
{
	db_printf("rtentry=%p", rt);

	db_printf(" flags=0x%x refcnt=%d use=%llu expire=%lld rtableid=%u\n",
	    rt->rt_flags, rt->rt_refcnt, rt->rt_use, rt->rt_expire, id);

	db_printf(" key="); db_print_sa(rt_key(rt));
	db_printf(" mask="); db_print_sa(rt_mask(rt));
	db_printf(" gw="); db_print_sa(rt->rt_gateway);

	db_printf(" ifp=%p ", rt->rt_ifp);
	if (rt->rt_ifp)
		db_printf("(%s)", rt->rt_ifp->if_xname);
	else
		db_printf("(NULL)");

	db_printf(" ifa=%p\n", rt->rt_ifa);
	db_print_ifa(rt->rt_ifa);

	db_printf(" gwroute=%p llinfo=%p\n", rt->rt_gwroute, rt->rt_llinfo);
	db_print_llinfo(rt->rt_llinfo);
	return (0);
}

/*
 * Function to print all the route trees.
 * Use this from ddb:  "call db_show_arptab"
 */
int
db_show_arptab(void)
{
	db_printf("Route tree for AF_INET\n");
	rtable_walk(0, AF_INET, db_show_rtentry, NULL);
	return (0);
}
#endif
@


1.169
log
@Fix uninitalized use of variable.
Issue _17 found by Maxime Villard Brainy scanner.
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.168 2015/09/13 17:53:44 mpi Exp $	*/
d331 1
a331 1
	struct llinfo_arp *la;
d336 1
a336 1
	int error;
d370 4
a373 3
		la = NULL;
		if ((rt = arplookup(satosin(dst)->sin_addr.s_addr, 1, 0,
		    ifp->if_rdomain)) != NULL)
d375 1
d382 2
a383 4
	if (la == NULL || rt == NULL) {
		m_freem(m);
		return (EINVAL);
	}
d389 1
a389 2
		m_freem(m);
		return (EINVAL);
d398 2
d402 2
a403 4
	if (ifp->if_flags & IFF_NOARP) {
		m_freem(m);
		return (EINVAL);
	}
d462 2
d465 6
d539 1
a539 1
	struct rtentry *rt;
d735 1
d740 2
d756 1
a824 1
	rt->rt_refcnt--;
d827 3
a829 6
		if (create) {
			if (rt->rt_refcnt <= 0 &&
			    (rt->rt_flags & RTF_CLONED) != 0) {
				rtdeletemsg(rt, tableid);
			}
		}
d852 2
a853 1
	if (sdl->sdl_alen != ETHER_ADDR_LEN)
d855 1
d861 1
@


1.168
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.167 2015/09/13 10:42:32 dlg Exp $	*/
d370 1
d374 1
a374 1
		else
@


1.167
log
@queue revarps to softnet so we can defer processing to a context with
the kernel lock.

"do it" claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.166 2015/09/12 20:26:07 mpi Exp $	*/
d312 1
a312 1
	if_output(ifp, m, &sa, NULL);
d712 1
a712 1
			if_output(ifp, mh, rt_key(rt), rt);
d762 1
a762 1
	if_output(ifp, m, &sa, NULL);
d977 1
a977 1
	if_output(ifp, m, &sa, NULL);
@


1.166
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.165 2015/09/10 13:21:41 dlg Exp $	*/
d98 2
d105 1
d504 3
@


1.165
log
@correctly hold and put a reference to the revarp ifp while trying
to get nfs working.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.164 2015/09/09 15:59:19 mpi Exp $	*/
a244 7
			 * XXX Since lo0 is in the default rdomain we
			 * should not (ab)use it for any route related
			 * to an interface of a different rdomain.
			 */
			rt->rt_ifp = lo0ifp;

			/*
d309 1
a309 1
	(*ifp->if_output)(ifp, m, &sa, (struct rtentry *)0);
d706 1
a706 1
			(*ifp->if_output)(ifp, mh, rt_key(rt), rt);
d756 1
a756 1
	(*ifp->if_output)(ifp, m, &sa, NULL);
d971 1
a971 1
	ifp->if_output(ifp, m, &sa, (struct rtentry *)0);
@


1.164
log
@Rewrite arpproxy() to no longer iterate on the global list of interfaces.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.163 2015/09/09 10:53:54 claudio Exp $	*/
a111 1
int revarp_in_progress;
d547 4
a550 2
	if (ifp == NULL)
		goto out;
d728 1
d764 1
a906 3
#ifdef NFSCLIENT
	struct ifnet *ifp;
#endif /* NFSCLIENT */
d924 1
a924 1
	if (!revarp_in_progress)
d926 1
a926 2
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp != revarp_ifp) /* !same interface */
d930 1
a930 1
	if (memcmp(ar->arp_tha, ((struct arpcom *)ifp)->ac_enaddr,
d996 1
a996 2
	revarp_ifp = ifp;
	revarp_in_progress = 1;
d1003 2
a1004 1
	revarp_in_progress = 0;
@


1.163
log
@Fix English in comment. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.162 2015/08/19 11:05:33 mpi Exp $	*/
d829 1
a829 1
arpproxy(struct in_addr in, u_int rdomain)
d831 1
a832 1
	struct llinfo_arp *la;
d836 1
a836 1
	rt = arplookup(in.s_addr, 0, SIN_PROXY, rdomain);
a838 1
	la = ((struct llinfo_arp *)rt->rt_llinfo);
d840 4
a843 3
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rdomain)
			continue;
d845 3
a847 7
		if (!memcmp(LLADDR((struct sockaddr_dl *)la->la_rt->rt_gateway),
		    LLADDR(ifp->if_sadl),
		    ETHER_ADDR_LEN)) {
			found = 1;
			break;
		}
	}
@


1.162
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.161 2015/08/19 10:50:14 mpi Exp $	*/
d603 1
a603 1
	/* Third try: not one of our addresses, just find an usable ia */
@


1.161
log
@Make arplookup() return a pointer to a "struct rtentry".

This is needed for proper refcounting of rtentries and reduce differences
with nd6_lookup().

Tweak and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.160 2015/08/17 09:58:10 mpi Exp $	*/
d641 12
a652 11
		    if (memcmp(ea->arp_sha, LLADDR(sdl), sdl->sdl_alen)) {
			if (rt->rt_flags &
			    (RTF_PERMANENT_ARP|RTF_LOCAL)) {
				inet_ntop(AF_INET, &isaddr, addr, sizeof(addr));
				log(LOG_WARNING,
				   "arp: attempt to overwrite permanent "
				   "entry for %s by %s on %s\n", addr,
				   ether_sprintf(ea->arp_sha),
				   ifp->if_xname);
				goto out;
			} else if (rt->rt_ifp != ifp) {
d654 1
a654 1
				if (ifp->if_type != IFT_CARP)
d656 16
a671 7
				{
					inet_ntop(AF_INET, &isaddr,
					    addr, sizeof(addr));
					log(LOG_WARNING,
					   "arp: attempt to overwrite entry for"
					   " %s on %s by %s on %s\n", addr,
					   rt->rt_ifp->if_xname,
d674 1
d676 1
a676 9
				goto out;
			} else {
				inet_ntop(AF_INET, &isaddr, addr, sizeof(addr));
				log(LOG_INFO,
				   "arp info overwritten for %s by %s on %s\n",
				   addr,
				   ether_sprintf(ea->arp_sha),
				   ifp->if_xname);
				rt->rt_expire = 1; /* no longer static */
a677 2
			changed = 1;
		    }
@


1.160
log
@Use __func__ rather than the function name in log(9) calls to remove
some grep output noise.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.159 2015/07/18 15:51:16 mpi Exp $	*/
d96 1
a96 1
struct llinfo_arp *arplookup(u_int32_t, int, int, u_int);
d375 1
a375 1
		if ((la = arplookup(satosin(dst)->sin_addr.s_addr, 1, 0,
d377 1
a377 1
			rt = la->la_rt;
d636 1
a636 1
	la = arplookup(isaddr.s_addr, itaddr.s_addr == myaddr.s_addr, 0,
d638 2
a639 1
	if (la && (rt = la->la_rt) && (sdl = SDL(rt->rt_gateway))) {
d734 1
a734 1
		la = arplookup(itaddr.s_addr, 0, SIN_PROXY,
d736 1
a736 1
		if (la == NULL)
a737 1
		rt = la->la_rt;
d793 1
a793 1
struct llinfo_arp *
d809 1
a809 1
		return (0);
d819 1
a819 1
		return (0);
d821 1
a821 1
	return ((struct llinfo_arp *)rt->rt_llinfo);
d830 1
d835 2
a836 2
	la = arplookup(in.s_addr, 0, SIN_PROXY, rdomain);
	if (la == NULL)
d838 1
@


1.159
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.158 2015/07/17 18:35:25 mpi Exp $	*/
d361 2
a362 2
			log(LOG_DEBUG, "arpresolve: %s: route contains no arp"
			    " information\n", inet_ntop(AF_INET,
d371 2
a372 2
			log(LOG_DEBUG, "arpresolve: %s: route without link "
			    "local address\n", inet_ntop(AF_INET,
d379 2
a380 2
			log(LOG_DEBUG,
			    "arpresolve: %s: can't allocate llinfo\n",
d437 1
a437 1
		printf("arpresolve: unresolved and rt_expire == 0\n");
@


1.158
log
@Announce an IP address after inserting its corresponding RTF_LOCAL
route and not during the SIOCSIFADDR ioctl.  This way addresses are
not announced when an error occurs.

ok chris@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.157 2015/07/07 14:22:25 mpi Exp $	*/
d121 1
a121 1
int	db_show_radix_node(struct radix_node *, void *, u_int);
d1080 1
a1080 1
 * Function to pass to rn_walktree().
d1084 1
a1084 1
db_show_radix_node(struct radix_node *rn, void *w, u_int id)
a1085 2
	struct rtentry *rt = (struct rtentry *)rn;

a1115 2
	struct radix_node_head *rnh;
	rnh = rtable_get(0, AF_INET);
d1117 1
a1117 5
	if (rnh == NULL) {
		db_printf(" (not initialized)\n");
		return (0);
	}
	rn_walktree(rnh, db_show_radix_node, NULL);
@


1.157
log
@Always use "ifp" instead of mixing it with "ac->ac_if" in in_arpinput().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.156 2015/06/23 13:20:17 mpi Exp $	*/
d199 5
a203 2
		/* Announce a new entry if requested. */
		if (rt->rt_flags & RTF_ANNOUNCE)
a855 6

	/* Warn the user if another station has this IP address. */
	arprequest(&ac->ac_if,
	    &satosin(ifa->ifa_addr)->sin_addr.s_addr,
	    &satosin(ifa->ifa_addr)->sin_addr.s_addr,
	    ac->ac_enaddr);
@


1.156
log
@Pass a "struct ifnet *" instead of a "struct arpcom *" to arpresolve().

Most of the ARP layer already take an ifp pointer and this makes clear
wich chunks of code are messing with ac_enaddr.

Note that our Ethernet code assume that these pointer are interchangeable
since the first element of the "struct arpcom" is a "struct ifnet".
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.155 2015/06/16 11:09:40 mpi Exp $	*/
d645 1
a645 1
				   ac->ac_if.if_xname);
d647 1
a647 1
			} else if (rt->rt_ifp != &ac->ac_if) {
d649 1
a649 1
				if (ac->ac_if.if_type != IFT_CARP)
d659 1
a659 1
					   ac->ac_if.if_xname);
d668 1
a668 1
				   ac->ac_if.if_xname);
d673 1
a673 1
		} else if (rt->rt_ifp != &ac->ac_if &&
d675 1
a675 1
		    !SAME_BRIDGE(ac->ac_if.if_bridgeport,
d680 3
a682 3
		    rt->rt_ifp->if_carpdev == &ac->ac_if) &&
		    !(ac->ac_if.if_type == IFT_CARP &&
		    ac->ac_if.if_carpdev == rt->rt_ifp) &&
d691 1
a691 1
			    ac->ac_if.if_xname);
d707 1
a707 1
			(*ac->ac_if.if_output)(&ac->ac_if, mh, rt_key(rt), rt);
d757 1
a757 1
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa, (struct rtentry *)0);
@


1.155
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.154 2015/06/07 01:25:27 krw Exp $	*/
d329 1
a329 1
arpresolve(struct arpcom *ac, struct rtentry *rt0, struct mbuf *m,
d332 1
d350 1
a350 1
		error = rt_checkgate(&ac->ac_if, rt0, dst,
d373 1
a373 1
		    ac->ac_if.if_rdomain)) != NULL)
d402 1
a402 1
	if (((struct ifnet *)ac)->if_flags & IFF_NOARP) {
d444 1
a444 1
				arprequest(&ac->ac_if,
@


1.154
log
@Replace a bunch of == 0 with == NULL in pointer tests. Nuke some
annoying trailing, leading and embedded whitespace. No change to
.o files.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.153 2015/05/26 11:55:34 mpi Exp $	*/
d525 2
a526 2
	struct ifnet *ifp = m->m_pkthdr.rcvif;
	struct arpcom *ac = (struct arpcom *)ifp;
d543 5
d929 1
a929 1
	ifp = m->m_pkthdr.rcvif;
@


1.153
log
@Do not create ARP entries for RTF_BROADCAST routes.

This has been done because historically routes to broadcast addresses
were cloned like any ARP entry.  But for obvious reasons, no matching
Ethernet address could ever be resolved.  That's why we played tricks
with the expire timer.

Now that a RTF_BROADCAST route is created per configured IPv4 address,
we need to differenciate duplicated one.  And by not creating an ARP
entry we are allowed to write the IP address in the rt_gateway field,
which prevents MPATH conflicts.

This change is part of a fix to unbreak aliases since the kernel support
multiple connected routes for a subnet.

Found the hardway by djm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.152 2015/05/15 12:00:57 claudio Exp $	*/
d263 1
a263 1
		if (la == 0)
d380 1
a380 1
	if (la == 0 || rt == 0) {
d688 1
a688 1
 		sdl->sdl_alen = sizeof(ea->arp_sha);
d726 1
a726 1
		if (la == 0)
d799 1
a799 1
	if (rt == 0)
d807 1
a807 1
			    	rtdeletemsg(rt, tableid);
d836 2
a837 2
		    	found = 1;
		    	break;
d1032 1
a1032 1
	if (sa == 0) {
d1053 1
a1053 1
	if (ifa == 0)
@


1.152
log
@Allow multiple connected/interface routes to exist at the same time.
Use the existing multipath code. Switch away from using the ifa address
when making the cloning route and instead put a dummy sockaddr_dl route
in. With this it is possible to use the same network on multiple interfaces
at the same time. So if wireless and ethernet share the same network
the system will use the wired connection as long as there is link.
Still missing is builtin proxy-arp for the other interface IPs to allow
hitless failover.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.151 2015/04/22 04:12:22 jsg Exp $	*/
d174 1
a174 1
	if (rt->rt_flags & RTF_GATEWAY)
a233 12
		/*
		 * Routes to broadcast addresses must be incomplete
		 * arp entries so that they won't be picked up, but
		 * since we expect them to always be present in the
		 * routing table, make sure arptimer() won't free
		 * them.
		 */
		if (rt->rt_flags & RTF_BROADCAST) {
			rt->rt_expire = 0;
			break;
		}

d633 1
a633 1
			    (RTF_PERMANENT_ARP|RTF_LOCAL|RTF_BROADCAST)) {
@


1.151
log
@Init rt to NULL in arpresolve().  Not a problem in practice
as la will be NULL when rt is uninitialised which should cause
the function to return, but makes the code easier to follow.

ok mpi@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.150 2015/04/10 13:58:20 dlg Exp $	*/
a123 2
static const struct sockaddr_dl null_sdl = { sizeof(null_sdl), AF_LINK };

a190 8
			 * Case 1: This route should come from a route to iface.
			 */
			rt_setgate(rt, (struct sockaddr *)&null_sdl,
			    ifp->if_rdomain);
			gate = rt->rt_gateway;
			SDL(gate)->sdl_type = ifp->if_type;
			SDL(gate)->sdl_index = ifp->if_index;
			/*
a253 4
			SDL(gate)->sdl_alen = ETHER_ADDR_LEN;
			memcpy(LLADDR(SDL(gate)),
			    ((struct arpcom *)ifp)->ac_enaddr, ETHER_ADDR_LEN);

@


1.150
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.149 2015/03/24 12:58:43 mpi Exp $	*/
d360 1
a360 1
	struct rtentry *rt;
@


1.149
log
@Convert hand-rolled mbuf list used to store packets until ARP
resolution is completed to ml_init(9) API.

Tested by kspillner@@, inputs & ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.148 2015/03/14 17:13:44 mpi Exp $	*/
d60 1
d101 2
a102 1
struct	ifqueue arpintrq;
a163 1
		IFQ_SET_MAXLEN(&arpintrq, 50);	/* XXX hate magic numbers */
d501 1
a501 1
	int s, len;
d503 1
a503 6
	for (;;) {
		s = splnet();
		IF_DEQUEUE(&arpintrq, m);
		splx(s);
		if (m == NULL)
			break;
@


1.148
log
@Check for the size of the supposed destination address when constructing
the Ethernet frame.  Prevent an overflow reported by Henk Jan Agteresch
on bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.147 2015/03/14 03:38:51 jsg Exp $	*/
a71 1
#define SRP(s) ((struct sockaddr_inarp *)s)
d79 9
d238 1
d294 1
a294 2
		while ((m = la->la_hold_head) != NULL) {
			la->la_hold_head = la->la_hold_head->m_nextpkt;
d436 3
a438 7
	if (la_hold_total < MAX_HOLD_TOTAL && la_hold_total < nmbclust / 64) {
		if (la->la_hold_count >= MAX_HOLD_QUEUE) {
			mh = la->la_hold_head;
			la->la_hold_head = la->la_hold_head->m_nextpkt;
			if (mh == la->la_hold_tail)
				la->la_hold_tail = NULL;
			la->la_hold_count--;
d442 1
a442 6
		if (la->la_hold_tail == NULL)
			la->la_hold_head = m;
		else
			la->la_hold_tail->m_nextpkt = m;
		la->la_hold_tail = m;
		la->la_hold_count++;
d445 1
a445 3
		while ((mh = la->la_hold_head) != NULL) {
			la->la_hold_head =
			    la->la_hold_head->m_nextpkt;
a448 2
		la->la_hold_tail = NULL;
		la->la_hold_count = 0;
d481 1
a481 3
				while ((mh = la->la_hold_head) != NULL) {
					la->la_hold_head =
					    la->la_hold_head->m_nextpkt;
a484 2
				la->la_hold_tail = NULL;
				la->la_hold_count = 0;
d564 1
a564 1
	struct mbuf *mh, *mt;
d571 1
d727 2
a728 4
		while ((mh = la->la_hold_head) != NULL) {
			if ((la->la_hold_head = mh->m_nextpkt) == NULL)
				la->la_hold_tail = NULL;
			la->la_hold_count--;
a729 1
			mt = la->la_hold_tail;
d733 1
a733 1
			if (la->la_hold_tail == mh) {
d735 5
a739 8
				la->la_hold_tail = mt;
				if (la->la_hold_tail)
					la->la_hold_tail->m_nextpkt = NULL;
				else
					la->la_hold_head = NULL;
				la->la_hold_count--;
				la_hold_total--;
				m_freem(mh);
d1103 1
a1103 2
	db_printf("  la_rt=%p la_hold_head=%p, la_asked=0x%lx\n",
	    la->la_rt, la->la_hold_head, la->la_asked);
@


1.147
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.146 2015/02/11 23:34:43 mpi Exp $	*/
d402 7
@


1.146
log
@Do not store the key and the gateway of a route entry in the same chunk
of memory.

The key (destination) is only set once, when the route is inserted in
the routing table, and does not need to change afterward.  The gateway
might change and rt_setgate() will do all the checks for you.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.145 2015/02/07 04:01:11 mpi Exp $	*/
a1060 1
#include <ddb/db_interface.h>
@


1.145
log
@Print a different error message if the route entry supposed to contain
ARP information is of a different kind.

ok sthen@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.144 2015/02/05 03:01:03 mpi Exp $	*/
d186 1
a186 1
			rt_setgate(rt, rt_key(rt), (struct sockaddr *)&null_sdl,
@


1.144
log
@Convert various rtrequest1(RTM_DELETE,...) calls to rtdeletemsg(9).

This unify some code and notify userland for free.

blambert@@ agrees, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.143 2015/01/28 22:10:13 mpi Exp $	*/
d371 9
@


1.143
log
@Revert rtdeletemsg conversion.  It was not ok'd, I misunderstood bluhm@@'s
email.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.142 2015/01/26 11:36:38 mpi Exp $	*/
d835 1
a835 9
				struct rt_addrinfo info;

				memset(&info, 0, sizeof(info));
				info.rti_info[RTAX_DST] = rt_key(rt);
				info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
				info.rti_info[RTAX_NETMASK] = rt_mask(rt);

				rtrequest1(RTM_DELETE, &info, rt->rt_priority,
				    NULL, tableid);
@


1.142
log
@Do not always try to rtfree(9) route entries inside rtdeletemsg(9).

Instead check the error code returned by this function and let the
caller free the route entry when appropriate.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.141 2015/01/13 12:16:18 mpi Exp $	*/
a791 1
	int error;
d806 1
a806 7
	error = rtdeletemsg(rt, tid);

	/* Adjust the refcount */
	if (error == 0 && rt->rt_refcnt <= 0) {
		rt->rt_refcnt++;
		rtfree(rt);
	}
@


1.141
log
@Only notify userland about resolved ARP entries if the Ethernet address
changed or if we asked for it.

Should reduce the RTM_RESOLVE storm seeing by claudio@@

With inputs from and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.140 2015/01/08 14:29:18 mpi Exp $	*/
d792 1
d807 7
a813 1
	rtdeletemsg(rt, tid);
@


1.140
log
@Factorize various duplicated chunks of (old and horrible) code, checking
for the validity of a given outgoing route entry into a single function.

This change is inspired from FreeBSD r111767.  The function introduced
here, rt_checkgate(), should hopefully die in a near future.  Why should
it die?  Well, it is way too late to do such validity checks: if your
kernel can ends up in ether_output() with an invalid route, please do
not let it try to find a new one that might do the job.

Go read this function if you're wondering why you're getting messages
like:

"arpresolve: X.X.X.X: route without link local address"

Since this horrible logic has survived 20 years of copy & past and small
modifications for workarounds without a single clear commit message, let's
assume it is full of dragons and try to play safe.  This factorization is
not intended to change any behavior.

With much inputs from bluhm@@, tested by weerd@@ and florian@@ on setups
with p2p IPv6 interfaces.

ok bluhm@@, benno@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.139 2014/12/19 17:14:40 tedu Exp $	*/
d563 1
a563 1
	int op;
d687 1
d715 3
a718 1
		rt_sendmsg(rt, RTM_RESOLVE, rt->rt_ifp->if_rdomain);
@


1.139
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.138 2014/12/05 15:50:04 mpi Exp $	*/
a83 1
#define	rt_expire rt_rmx.rmx_expire
d339 1
a339 1
 * is finally resolved.  A return value of 1 indicates
d341 3
a343 2
 * normally; a 0 return indicates that the packet has been
 * taken over here, either now or for later transmission.
d346 1
a346 1
arpresolve(struct arpcom *ac, struct rtentry *rt, struct mbuf *m,
d351 1
d354 1
d358 1
a358 1
		return (1);
d362 1
a362 1
		return (1);
d364 9
a372 1
	if (rt) {
d390 1
a390 1
		return (0);
d400 1
a400 1
		return 1;
d404 1
a404 1
		return 0;
d481 1
a481 1
	return (0);
@


1.138
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.137 2014/11/01 21:40:38 mpi Exp $	*/
a40 1
#ifdef INET
a1150 1
#endif /* INET */
@


1.137
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.136 2014/09/03 08:53:54 mpi Exp $	*/
d57 1
@


1.136
log
@Make sure broadcast entries won't be freed by the arp timer so we can
use them for address lookups.

While here do let in_arpinput() overwrite local or broadcast entries.

ok mikeb@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.135 2014/08/26 15:09:26 mpi Exp $	*/
d369 1
a369 1
		if ((la = arplookup(satosin(dst)->sin_addr.s_addr, RT_REPORT, 0,
d804 1
d811 3
a813 1
	rt = rtalloc1((struct sockaddr *)&sin, create, tableid);
@


1.135
log
@Revert the addition of broadcast addresses, it apparently also corrupts
the tree.   Found by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.134 2014/08/19 12:49:41 mpi Exp $	*/
d235 12
d644 2
a645 1
			if (rt->rt_flags & RTF_PERMANENT_ARP) {
@


1.134
log
@When a local route entry is added for an ifa having a broadcast address,
also adds a broadcast entry flagged with RTF_BROADCAST.

Prior to this change broadcast entries were simple clonned ARP entries,
that would be deleted once their timer expired since they would always
be incomplete.

With this change they are now persistant and identifiable with a new flag.

Committing early to be able to deal with any potential fallout before we
start relying on this.

ok florian@@, mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.133 2014/08/11 13:51:07 mpi Exp $	*/
a233 12

		/*
		 * Routes to broadcast addresses must be incomplete
		 * arp entries so that they won't be picked up, but
		 * since we expect them to always be present in the
		 * routing table, make sure arptimer() won't free
		 * them.
		 */
		if (rt->rt_flags & RTF_BROADCAST) {
			rt->rt_expire = 0;
			break;
		}
@


1.133
log
@Use the RTF_LOCAL flag instead of abusing the RTF_LLINFO flag when
adding local route entries.

This hack made sense when we didn't have the RTF_LOCAL flag, but since
some months it is set on every local route.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.132 2014/08/11 11:50:41 mpi Exp $	*/
d234 12
@


1.132
log
@Convert ARP llinfo allocation to pool(9).

ok henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.131 2014/07/12 18:44:23 tedu Exp $	*/
d183 1
a183 1
		    ((rt->rt_flags & RTF_LLINFO) && !la)) {
@


1.131
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.130 2014/07/12 14:26:00 mpi Exp $	*/
d53 2
d92 1
d153 2
d223 1
a223 1
		la = malloc(sizeof(*la), M_RTABLE, M_NOWAIT | M_ZERO);
d279 1
a279 1
		free(la, M_RTABLE, 0);
@


1.130
log
@Always create a local route for every configured IPv4 address on the
machine and restore the original behavior of RTM_ADD and RTM_DELETE
by always generating one message per locally configured address.

This time, make sure the local route is removed during an address change,
since at least pppoe(4) do some funky magics with wildcard addresses that
might corrupt the routing tree, as found by naddy@@

Also do not add a local route if the specified address is 0.0.0.0, to
prevent a tree corruption, as found by guenther@@.

Putting this in now so that it gets tested, claudio@@ agrees.  Please
contact me if you find any route-related regression caused by this
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.129 2014/06/16 19:47:21 mpi Exp $	*/
d274 1
a274 1
		free(la, M_RTABLE);
@


1.129
log
@Revert "Always create a local route for every configured IPv4 address",
it introduces a regression with default routes & p2p interfaces.

Problem reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.128 2014/06/11 11:30:03 mpi Exp $	*/
d177 2
a178 1
		if (rt->rt_flags & RTF_CLONING) {
d193 2
a194 1
			break;
@


1.128
log
@Always create a local route for every configured IPv4 address on the
machine and restore the original behavior of RTM_ADD and RTM_DELETE
by always generating one message per locally configured address.

Tested by krw@@, jca@@ and florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.127 2014/05/07 08:14:59 mpi Exp $	*/
d177 1
a177 2
		if (rt->rt_flags & RTF_CLONING ||
		    ((rt->rt_flags & RTF_LLINFO) && !la)) {
d192 1
a192 2
			if ((rt->rt_flags & RTF_CLONING) != 0)
				break;
@


1.127
log
@Kill the {nd6_,}useloopback buttons, using the loopback interface for
local traffic is not optional.

ok mikeb@@, stsp@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.126 2014/05/05 11:44:33 mpi Exp $	*/
d177 2
a178 1
		if (rt->rt_flags & RTF_CLONING) {
d193 2
a194 1
			break;
@


1.126
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.125 2014/04/14 09:06:42 mpi Exp $	*/
a92 1
int	useloopback = 1;	/* use loopback interface for local traffic */
a234 17
			/*
			 * This test used to be
			 *	if (lo0ifp->if_flags & IFF_UP)
			 * It allowed local traffic to be forced through
			 * the hardware by configuring the loopback down.
			 * However, it causes problems during network
			 * configuration for boards that can't receive
			 * packets they send.  It is now necessary to clear
			 * "useloopback" and remove the route to force
			 * traffic out to the hardware.
			 *
			 * In 4.4BSD, the above "if" statement checked
			 * rt->rt_ifa against rt_key(rt).  It was changed
			 * to the current form so that we can provide a
			 * better support for multiple IPv4 addresses on a
			 * interface.
			 */
d245 2
a246 2
			if (useloopback)
				rt->rt_ifp = lo0ifp;
@


1.125
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.124 2014/04/10 14:36:25 mikeb Exp $	*/
d257 6
@


1.124
log
@notify userland when arp entry is removed;  ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.123 2014/03/27 10:39:23 mpi Exp $	*/
d306 1
a306 1
	m->m_pkthdr.rdomain = ifp->if_rdomain;
d633 1
a633 1
	    rtable_l2(m->m_pkthdr.rdomain));
d732 1
a732 1
		    rtable_l2(m->m_pkthdr.rdomain));
@


1.123
log
@Stop mixing interface address flags with routing entry ones.

Instead of always copying ifa_flags to the routing entry flags when
creating a route by calling rtinit(), explicitly pass the RTF_CLONING
flag when required.  This means ifa_flags are now *only* used to check
if an address has an associated route that was created by the kernel
auto-magically.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.122 2014/03/18 14:55:49 mikeb Exp $	*/
a769 1
	struct rt_addrinfo info;
a780 3
	memset(&info, 0, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
d785 1
a785 1
	rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, tid);
@


1.122
log
@Notify userland via the routing socket when ARP resolution completes;
discussed with claudio@@ at n2k14, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.121 2014/03/18 10:47:34 mpi Exp $	*/
a869 1
	ifa->ifa_flags |= RTF_CLONING;
@


1.121
log
@Rename rt_gettable() into rtable_get(), swap its arguments to be
coherent with the existing rtable_* functions and document it.

While here fix some other manpage glitches pointed out by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.120 2014/03/11 10:31:29 mpi Exp $	*/
d697 1
@


1.120
log
@Remove gratuitous differences between arp and nd6 rtrequests,
no functional change.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.119 2014/03/10 12:21:35 mpi Exp $	*/
d1134 1
a1134 1
	rnh = rt_gettable(AF_INET, 0);
@


1.119
log
@if_lladdr -> if_sadl, no functional change.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.118 2014/01/22 06:28:09 claudio Exp $	*/
a137 3
/*
 * Parallel to llc_rtrequest.
 */
d143 1
d182 2
a183 3
			rt_setgate(rt, rt_key(rt),
			    (struct sockaddr *)&null_sdl,
			    rt->rt_ifp->if_rdomain);
d185 2
a186 2
			SDL(gate)->sdl_type = rt->rt_ifp->if_type;
			SDL(gate)->sdl_index = rt->rt_ifp->if_index;
d197 1
a197 1
			arprequest(rt->rt_ifp,
d205 2
a206 1
			log(LOG_DEBUG, "arp_rtrequest: bad gateway value\n");
d209 2
a210 2
		SDL(gate)->sdl_type = rt->rt_ifp->if_type;
		SDL(gate)->sdl_index = rt->rt_ifp->if_index;
d220 1
a220 1
			log(LOG_DEBUG, "arp_rtrequest: malloc failed\n");
d229 1
a229 1
		TAILQ_FOREACH(ifa, &rt->rt_ifp->if_addrlist, ifa_list) {
d256 1
a256 2
			    ((struct arpcom *)rt->rt_ifp)->ac_enaddr,
			    ETHER_ADDR_LEN);
@


1.118
log
@Remove genmask support from the kernel. rtmsgs with RTA_GENMASK set will
now cause a EINVAL. The RTA_GENMASK and RTAX_GENMASK defines are kept for
compatibility reasons.
OK benno@@ and agreed by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.117 2014/01/10 14:29:08 tedu Exp $	*/
d852 1
a852 1
		    LLADDR((struct sockaddr_dl *)ifp->if_lladdr->ifa_addr),
@


1.117
log
@replace the rest of the obsolete radix macros
sprinkle 0 -> NULL where obvious
ok millert mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.116 2014/01/09 21:57:52 tedu Exp $	*/
a1122 2

	db_printf(" genmask="); db_print_sa(rt->rt_genmask);
@


1.116
log
@replace Bcopy macro with memmove and memcpy. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.115 2014/01/09 06:29:05 tedu Exp $	*/
d219 1
a219 1
		R_Malloc(la, struct llinfo_arp *, sizeof(*la));
d221 1
a221 1
		if (la == 0) {
d225 2
a226 2
		arp_inuse++, arp_allocated++;
		Bzero(la, sizeof(*la));
d287 1
a287 1
		Free((caddr_t)la);
d775 1
a775 1
	if (rt == 0)
@


1.115
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.114 2013/12/31 03:24:44 tedu Exp $	*/
d256 4
a259 3
			Bcopy(((struct arpcom *)rt->rt_ifp)->ac_enaddr,
			    LLADDR(SDL(gate)),
			    SDL(gate)->sdl_alen = ETHER_ADDR_LEN);
@


1.114
log
@bcopy -> memcpy. reviewed with one fix from matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.113 2013/11/27 12:25:30 mpi Exp $	*/
d312 1
a312 1
	bzero((caddr_t)ea, sizeof (*ea));
d616 1
a616 1
	if (!bcmp((caddr_t)ea->arp_sha, enaddr, sizeof (ea->arp_sha)))
d619 1
a619 1
		if (!bcmp((caddr_t)ea->arp_sha, (caddr_t)etherbroadcastaddr,
d638 1
a638 1
		    if (bcmp(ea->arp_sha, LLADDR(sdl), sdl->sdl_alen)) {
d783 1
a783 1
	bzero(&info, sizeof(info));
d802 1
a802 1
	bzero(&sin, sizeof(sin));
d818 1
a818 1
				bzero(&info, sizeof(info));
d850 1
a850 1
		if (!bcmp(LLADDR((struct sockaddr_dl *)la->la_rt->rt_gateway),
d947 1
a947 1
	if (bcmp(ar->arp_tha, ((struct arpcom *)ifp)->ac_enaddr,
d981 1
a981 1
	bzero((caddr_t)ea, sizeof(*ea));
@


1.113
log
@Since r1.106 we have a local variable referencing the receiving interface,
use it instead of dereferencing the mbuf once again. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.112 2013/11/21 09:08:38 mpi Exp $	*/
d313 1
a313 2
	bcopy((caddr_t)etherbroadcastaddr, (caddr_t)eh->ether_dhost,
	    sizeof(eh->ether_dhost));
d320 4
a323 5
	bcopy((caddr_t)enaddr, (caddr_t)eh->ether_shost,
	      sizeof(eh->ether_shost));
	bcopy((caddr_t)enaddr, (caddr_t)ea->arp_sha, sizeof(ea->arp_sha));
	bcopy((caddr_t)sip, (caddr_t)ea->arp_spa, sizeof(ea->arp_spa));
	bcopy((caddr_t)tip, (caddr_t)ea->arp_tpa, sizeof(ea->arp_tpa));
d350 1
a350 2
		bcopy((caddr_t)etherbroadcastaddr, (caddr_t)desten,
		    sizeof(etherbroadcastaddr));
d384 1
a384 1
		bcopy(LLADDR(sdl), desten, sdl->sdl_alen);
d562 2
a563 2
	bcopy((caddr_t)ea->arp_tpa, (caddr_t)&itaddr, sizeof(itaddr));
	bcopy((caddr_t)ea->arp_spa, (caddr_t)&isaddr, sizeof(isaddr));
d693 2
a694 2
		bcopy(ea->arp_sha, LLADDR(sdl),
		    sdl->sdl_alen = sizeof(ea->arp_sha));
d729 2
a730 2
		bcopy(ea->arp_sha, ea->arp_tha, sizeof(ea->arp_sha));
		bcopy(enaddr, ea->arp_sha, sizeof(ea->arp_sha));
d739 1
a739 1
		bcopy(ea->arp_sha, ea->arp_tha, sizeof(ea->arp_sha));
d741 1
a741 1
		bcopy(LLADDR(sdl), ea->arp_sha, sizeof(ea->arp_sha));
d744 2
a745 2
	bcopy(ea->arp_spa, ea->arp_tpa, sizeof(ea->arp_spa));
	bcopy(&itaddr, ea->arp_spa, sizeof(ea->arp_spa));
d749 1
a749 1
	bcopy(ea->arp_tha, eh->ether_dhost, sizeof(eh->ether_dhost));
d754 1
a754 1
	bcopy(enaddr, eh->ether_shost, sizeof(eh->ether_shost));
d950 2
a951 4
	bcopy((caddr_t)ar->arp_spa, (caddr_t)&revarp_srvip,
	    sizeof(revarp_srvip));
	bcopy((caddr_t)ar->arp_tpa, (caddr_t)&revarp_myip,
	    sizeof(revarp_myip));
d982 1
a982 2
	bcopy((caddr_t)etherbroadcastaddr, (caddr_t)eh->ether_dhost,
	    sizeof(eh->ether_dhost));
d989 3
a991 6
	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)eh->ether_shost,
	   sizeof(ea->arp_tha));
	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)ea->arp_sha,
	   sizeof(ea->arp_sha));
	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)ea->arp_tha,
	   sizeof(ea->arp_tha));
d1025 2
a1026 2
	bcopy((caddr_t)&revarp_srvip, serv_in, sizeof(*serv_in));
	bcopy((caddr_t)&revarp_myip, clnt_in, sizeof(*clnt_in));
@


1.112
log
@Replace the last usage of IA_SIN() and kill this macro.

ok henning@@, sthen@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.111 2013/11/11 09:15:34 mpi Exp $	*/
d740 1
a740 2
		if (rt->rt_ifp->if_type == IFT_CARP &&
		    m->m_pkthdr.rcvif->if_type != IFT_CARP)
@


1.111
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.110 2013/10/31 18:10:21 bluhm Exp $	*/
d871 2
a872 2
	    &(IA_SIN(ifa)->sin_addr.s_addr),
	    &(IA_SIN(ifa)->sin_addr.s_addr),
@


1.110
log
@Convert the route expire timestamp in kernel and routing message
to 64 bit.  Increase the routing message version from 4 to 5.  Add
a small compatibility layer that allows to set routes with old user
land and new kernel.  Old kernel with new user land does not work.

The compatibility layer ist not perfect, but it allows to configure
addresses with old ifconfig and new kernel.  Route get also works
in this setup.  dhclient hangs as messages for interface address
changes with old version are not generated.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.109 2013/10/28 12:33:32 mpi Exp $	*/
d349 1
d364 2
a365 2
			    "local address\n",
			    inet_ntoa(satosin(dst)->sin_addr));
d373 2
a374 1
			    inet_ntoa(satosin(dst)->sin_addr));
d550 1
d624 1
d626 1
a626 1
			    "IP address %s!\n", inet_ntoa(isaddr));
d630 1
d633 1
a633 1
		   inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
d643 1
d646 1
a646 2
				   "entry for %s by %s on %s\n",
				   inet_ntoa(isaddr),
d654 3
d659 1
a659 2
					   " %s on %s by %s on %s\n",
					   inet_ntoa(isaddr),
d663 1
d666 1
d669 1
a669 1
				   inet_ntoa(isaddr),
d687 1
d690 2
a691 2
			    "on %s by %s on %s\n",
			    inet_ntoa(isaddr), rt->rt_ifp->if_xname,
@


1.109
log
@tedu FDDI support and the 3 flavors the driver for DEC devices, even
miod@@ cannot find two boards using the same media.

With precious punctuation review from guenther@@, thanks!

ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.108 2013/10/14 16:06:33 bluhm Exp $	*/
d1107 1
a1107 1
	db_printf(" flags=0x%x refcnt=%d use=%llu expire=%u rtableid %u\n",
@


1.108
log
@By passing invalid values in the routing message, root could crash
the kernel from user land.  Add a null pointer check as quick fix.
OK blambert@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.107 2013/09/03 10:25:32 mpi Exp $	*/
a56 1
#include <net/if_fddi.h>
d166 1
a166 16
	if (rt->rt_flags & RTF_GATEWAY) {
		if (req != RTM_ADD)
			return;

		/*
		 * linklayers with particular link MTU limitation.  it is a bit
		 * awkward to have FDDI handling here, we should split ARP from
		 * netinet/if_ether.c like NetBSD does.
		 */
		switch (rt->rt_ifp->if_type) {
		case IFT_FDDI:
			if (rt->rt_ifp->if_mtu > FDDIIPMTU)
				rt->rt_rmx.rmx_mtu = FDDIIPMTU;
			break;
		}

a167 1
	}
a195 12
			/*
			 * linklayers with particular link MTU limitation.
			 */
			switch (rt->rt_ifp->if_type) {
			case IFT_FDDI:
				if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0 &&
				    (rt->rt_rmx.rmx_mtu > FDDIIPMTU ||
				     (rt->rt_rmx.rmx_mtu == 0 &&
				      rt->rt_ifp->if_mtu > FDDIIPMTU)))
					rt->rt_rmx.rmx_mtu = FDDIIPMTU;
				break;
			}
@


1.107
log
@Use satosin() rather than the local SIN macro, no functional change.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.106 2013/08/29 13:24:43 mpi Exp $	*/
d194 1
a194 1
		if ((rt->rt_flags & RTF_HOST) == 0 &&
@


1.106
log
@Iterate over the interface's address list instead of the global list.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.105 2013/08/28 06:58:57 mpi Exp $	*/
a69 1
#define SIN(s) ((struct sockaddr_in *)s)
d195 1
a195 1
		    SIN(rt_mask(rt))->sin_addr.s_addr != 0xffffffff)
d230 2
a231 2
			    &SIN(rt_key(rt))->sin_addr.s_addr,
			    &SIN(rt_key(rt))->sin_addr.s_addr,
d385 1
a385 1
		ETHER_MAP_IP_MULTICAST(&SIN(dst)->sin_addr, desten);
d392 2
a393 1
			    "local address\n", inet_ntoa(SIN(dst)->sin_addr));
d395 1
a395 1
		if ((la = arplookup(SIN(dst)->sin_addr.s_addr, RT_REPORT, 0,
d401 1
a401 1
			    inet_ntoa(SIN(dst)->sin_addr));
d473 2
a474 2
				    &(SIN(rt->rt_ifa->ifa_addr)->sin_addr.s_addr),
				    &(SIN(dst)->sin_addr.s_addr),
@


1.105
log
@Remove unused argument from *rtrequest()

ok krw@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.104 2013/08/09 06:01:52 mpi Exp $	*/
a147 1
	struct in_ifaddr *ia;
d261 4
a264 4
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (ia->ia_ifp == rt->rt_ifp &&
			    SIN(rt_key(rt))->sin_addr.s_addr ==
			    (IA_SIN(ia))->sin_addr.s_addr)
d267 1
a267 1
		if (ia) {
a295 1
			ifa = &ia->ia_ifa;
d563 2
a564 1
	struct arpcom *ac = (struct arpcom *)m->m_pkthdr.rcvif;
d568 1
a568 1
	struct in_ifaddr *ia;
d595 5
a599 2
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
		if (itaddr.s_addr != ia->ia_addr.sin_addr.s_addr)
d603 2
a604 2
		if (ia->ia_ifp->if_type == IFT_CARP &&
		    ((ia->ia_ifp->if_flags & (IFF_UP|IFF_RUNNING)) ==
d606 8
a613 10
			if (ia->ia_ifp == m->m_pkthdr.rcvif) {
				if (op == ARPOP_REPLY)
					break;
				if (carp_iamatch(ia, ea->arp_sha,
				    &enaddr, &ether_shost))
					break;
				else
					goto out;
			}
		} else
d615 1
a615 2
			if (ia->ia_ifp == m->m_pkthdr.rcvif)
				break;
d619 3
a621 3
	if (ia == NULL) {
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (isaddr.s_addr != ia->ia_addr.sin_addr.s_addr)
d623 3
a625 1
			if (ia->ia_ifp == m->m_pkthdr.rcvif)
d631 2
a632 4
	if (ia == NULL) {
		struct ifaddr *ifa;

		TAILQ_FOREACH(ifa, &m->m_pkthdr.rcvif->if_addrlist, ifa_list) {
a635 2
		if (ifa)
			ia = (struct in_ifaddr *)ifa;
d638 1
a638 1
	if (ia == NULL)
d643 1
a643 1
	myaddr = ia->ia_addr.sin_addr;
@


1.104
log
@Constify the default null sockaddr_dl, no functional change.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.103 2013/08/01 08:27:43 mpi Exp $	*/
d144 1
a144 1
arp_rtrequest(int req, struct rtentry *rt, struct rt_addrinfo *info)
@


1.103
log
@Do not use a static variable to perform a lookup.  While this
is perfectly ok for the moment because there might be at most
one caller at a time, it wont be so as soon as this part of
the network stack is run in parallel.

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.102 2013/07/04 08:22:19 mpi Exp $	*/
d115 2
a147 1
	static struct sockaddr_dl null_sdl = {sizeof(null_sdl), AF_LINK};
d238 1
a238 1
		    gate->sa_len < sizeof(null_sdl)) {
@


1.102
log
@Rewrite the function used to determine if we do proxy ARP for one of
our addresses to reuse arplookup() and do only one list iteration.

Looks ok to claudio@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.101 2013/03/28 23:10:05 tedu Exp $	*/
d825 1
a825 1
	static struct sockaddr_inarp sin;
d827 1
@


1.101
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.100 2013/03/28 16:45:16 tedu Exp $	*/
d854 29
@


1.100
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.99 2013/03/28 00:32:11 bluhm Exp $	*/
d50 1
@


1.99
log
@Unfortunately the satosin, sintosa, ifatoia, satosin6, sin6tosa,
ifatoia6 macros do not check the source type.  They just cast
anything.  Remove needless casts and do not use those macros if the
source type does not match.  Remove duplicate defines.
No binary change.  OK kettenis@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.98 2013/03/22 01:41:12 tedu Exp $	*/
a51 1
#include <sys/proc.h>
a106 1
#include <uvm/uvm_extern.h>
@


1.98
log
@simple replacement of LIST_END with NULL. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.97 2013/03/07 09:03:16 mpi Exp $	*/
d832 1
a832 1
	rt = rtalloc1(sintosa(&sin), create, tableid);
@


1.97
log
@Remove the IFAFREE() macro, the ifafree() function it was calling already
check for the reference counter.

ok mikeb@@, miod@@, pelikan@@, kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.96 2012/10/18 00:36:22 deraadt Exp $	*/
d129 1
a129 2
	for (la = LIST_FIRST(&llinfo_arp); la != LIST_END(&llinfo_arp);
	    la = nla) {
@


1.96
log
@Move revarp code into #ifdef NFSCLIENT; saving space on some media.
Resurrect the rather silly "unplug my network device while I am
doing nfs diskless revarp" safety code which was disabled due to
a missing "ether.h" include, found by jsg
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.95 2012/10/05 17:17:04 camield Exp $	*/
d300 1
a300 1
				IFAFREE(rt->rt_ifa);
@


1.95
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.94 2012/10/05 12:30:43 camield Exp $	*/
d99 1
d101 2
a102 2
struct in_addr myip, srv_ip;
int myip_initialized;
d104 2
a105 1
struct ifnet *myip_ifp;
d917 1
d919 1
d936 1
d940 1
a940 1
	if (ifp != myip_ifp) /* !same interface */
d942 1
a942 1
	if (myip_initialized)
d947 5
a951 3
	bcopy((caddr_t)ar->arp_spa, (caddr_t)&srv_ip, sizeof(srv_ip));
	bcopy((caddr_t)ar->arp_tpa, (caddr_t)&myip, sizeof(myip));
	myip_initialized = 1;
d953 2
a954 1
	wakeup((caddr_t)&myip);
d1001 1
d1013 1
a1013 1
	if (myip_initialized)
d1016 1
a1016 1
	myip_ifp = ifp;
d1020 1
a1020 1
		result = tsleep((caddr_t)&myip, PSOCK, "revarp", hz/2);
d1025 1
a1025 1
	if (!myip_initialized)
d1028 2
a1029 2
	bcopy((caddr_t)&srv_ip, serv_in, sizeof(*serv_in));
	bcopy((caddr_t)&myip, clnt_in, sizeof(*clnt_in));
d1040 1
a1040 1

@


1.94
log
@missing NCARP define and fix indent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.93 2011/09/18 11:17:58 miod Exp $	*/
d66 3
d697 6
a702 2
		} else if (rt->rt_ifp != &ac->ac_if && !(ac->ac_if.if_bridge &&
		    (rt->rt_ifp->if_bridge == ac->ac_if.if_bridge)) &&
d706 3
a708 1
		    ac->ac_if.if_carpdev == rt->rt_ifp)) {
@


1.93
log
@Fix various format string types to as a minimum match the width of the
variables being processed.
ok bluhm@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.92 2011/07/06 02:42:28 henning Exp $	*/
d674 1
d676 1
d700 7
a706 7
		    log(LOG_WARNING,
			"arp: attempt to add entry for %s "
			"on %s by %s on %s\n",
			inet_ntoa(isaddr), rt->rt_ifp->if_xname,
			ether_sprintf(ea->arp_sha),
			ac->ac_if.if_xname);
		    goto out;
@


1.92
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.91 2011/07/05 23:15:15 henning Exp $	*/
d1090 1
a1090 1
	db_printf(" flags=0x%x refcnt=%d use=%ld expire=%ld rtableid %u\n",
@


1.91
log
@fix bizarre and mostly useless initialization of an ifqueue in BSS that
again makes assumptions of the ifqueue internals, ok ryan claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.90 2011/07/05 21:40:38 dhill Exp $	*/
d152 1
a152 1
		arpintrq.ifq_maxlen = 50;	/* XXX hate magic numbers */
@


1.90
log
@ansify

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.89 2011/06/27 13:01:51 camield Exp $	*/
d89 1
a89 1
struct	ifqueue arpintrq = {0, 0, 0, 50};
d152 1
@


1.89
log
@Mark ARP request broadcasts with M_BCAST in the mbuf flags.

Fixes a case in bridge_output() where ARP requests are not broadcast
on interfaces without the discovery flag.

ok claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.88 2010/07/22 00:41:55 deraadt Exp $	*/
d116 1
a116 2
arptimer(arg)
	void *arg;
d139 1
a139 4
arp_rtrequest(req, rt, info)
	int req;
	struct rtentry *rt;
	struct rt_addrinfo *info;
d324 1
a324 4
arprequest(ifp, sip, tip, enaddr)
	struct ifnet *ifp;
	u_int32_t *sip, *tip;
	u_int8_t *enaddr;
d370 2
a371 6
arpresolve(ac, rt, m, dst, desten)
	struct arpcom *ac;
	struct rtentry *rt;
	struct mbuf *m;
	struct sockaddr *dst;
	u_char *desten;
d501 1
a501 1
arpintr()
d557 1
a557 2
in_arpinput(m)
	struct mbuf *m;
d780 1
a780 2
arptfree(la)
	struct llinfo_arp *la;
d810 1
a810 4
arplookup(addr, create, proxy, tableid)
	u_int32_t addr;
	int create, proxy;
	u_int tableid;
d845 1
a845 3
arp_ifinit(ac, ifa)
	struct arpcom *ac;
	struct ifaddr *ifa;
d864 1
a864 2
revarpinput(m)
	struct mbuf *m;
d901 1
a901 2
in_revarpinput(m)
	struct mbuf *m;
d945 1
a945 2
revarprequest(ifp)
	struct ifnet *ifp;
d987 2
a988 4
revarpwhoarewe(ifp, serv_in, clnt_in)
	struct ifnet *ifp;
	struct in_addr *serv_in;
	struct in_addr *clnt_in;
d1014 1
a1014 3
revarpwhoami(in, ifp)
	struct in_addr *in;
	struct ifnet *ifp;
d1028 1
a1028 2
db_print_sa(sa)
	struct sockaddr *sa;
d1052 1
a1052 2
db_print_ifa(ifa)
	struct ifaddr *ifa;
d1067 1
a1067 2
db_print_llinfo(li)
	caddr_t li;
@


1.88
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.87 2010/06/28 18:50:37 claudio Exp $	*/
d362 1
d998 1
@


1.87
log
@Add the rtable id as an argument to rn_walktree(). Functions like
rt_if_remove_rtdelete() need to know the table id to be able to correctly
remove nodes.
Problem found by Andrea Parazzini and analyzed by Martin Pelikn.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.86 2010/05/07 13:33:16 claudio Exp $	*/
d90 1
a90 1
int	arp_inuse, arp_allocated, arp_intimer;
@


1.86
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.85 2010/04/06 18:16:31 deraadt Exp $	*/
d108 1
a108 1
int	db_show_radix_node(struct radix_node *, void *);
d1109 1
a1109 3
db_show_radix_node(rn, w)
	struct radix_node *rn;
	void *w;
d1115 2
a1116 2
	db_printf(" flags=0x%x refcnt=%d use=%ld expire=%ld\n",
	    rt->rt_flags, rt->rt_refcnt, rt->rt_use, rt->rt_expire);
d1143 1
a1143 1
db_show_arptab()
@


1.85
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.84 2010/02/08 13:32:50 claudio Exp $	*/
d402 1
a402 1
		if ((la = arplookup(SIN(dst)->sin_addr.s_addr, 1, 0,
@


1.84
log
@arpioctl() is not used sore remove it. Found by Gleydson Soares.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.83 2010/01/13 05:27:19 claudio Exp $	*/
d656 1
a656 1
	if (ETHER_IS_MULTICAST (&ea->arp_sha[0]))
@


1.83
log
@Remove special bridge code in in_arpinput() this is no longer needed since
we now correctly broadcast packets to all local ports.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.82 2009/11/03 10:59:04 claudio Exp $	*/
a856 9
}

int
arpioctl(cmd, data)
	u_long cmd;
	caddr_t data;
{

	return (EOPNOTSUPP);
@


1.82
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.81 2009/10/17 12:20:17 mpf Exp $	*/
a575 3
#if NBRIDGE > 0
	struct in_ifaddr *bridge_ia = NULL;
#endif
a622 25
#if NBRIDGE > 0
		/*
		 * If the interface we received the packet on
		 * is part of a bridge, check to see if we need
		 * to "bridge" the packet to ourselves at this
		 * layer.  Note we still prefer a perfect match,
		 * but allow this weaker match if necessary.
		 */
		if (m->m_pkthdr.rcvif->if_bridge != NULL) {
			if (m->m_pkthdr.rcvif->if_bridge ==
			    ia->ia_ifp->if_bridge)
				bridge_ia = ia;
#if NCARP > 0
			else if (ia->ia_ifp->if_carpdev != NULL &&
			    m->m_pkthdr.rcvif->if_bridge ==
			    ia->ia_ifp->if_carpdev->if_bridge) {
				if (carp_iamatch(ia, ea->arp_sha,
				    &enaddr, &ether_shost))
					bridge_ia = ia;
				else
					goto out;
			}
#endif
		}
#endif
a623 8

#if NBRIDGE > 0
	/* use bridge_ia if there was no direct match */
	if (ia == NULL && bridge_ia != NULL) {
		ia = bridge_ia;
		ac = (struct arpcom *)bridge_ia->ia_ifp;
	}
#endif
@


1.81
log
@Allow us to accept gratuitous ARP requests in cases where the
link-route points over the carp interface. (IP-less carpdev)
The descision whether to drop an ARP query is now expressed with
a goto out; rather than a second check later, which prevented
the carpdev case to work. Also add some comments to make
in_arpinput() easier to understand.
OK henning, markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.80 2009/06/05 00:05:22 claudio Exp $	*/
d707 1
a707 1
	    m->m_pkthdr.rdomain);
d792 1
a792 1
		    m->m_pkthdr.rdomain);
@


1.80
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.79 2008/12/24 08:26:27 claudio Exp $	*/
d604 1
d613 9
a621 5
			if (ia->ia_ifp == m->m_pkthdr.rcvif &&
			    (op == ARPOP_REPLY  ||
			    carp_iamatch(ia, ea->arp_sha,
			    &enaddr, &ether_shost)))
				break;
d641 7
a647 4
			    ia->ia_ifp->if_carpdev->if_bridge &&
			    carp_iamatch(ia, ea->arp_sha,
			    &enaddr, &ether_shost))
				bridge_ia = ia;
d654 1
d661 1
d671 2
a672 1
	if (ia == NULL && m->m_pkthdr.rcvif->if_type != IFT_CARP) {
d720 8
a727 6
				log(LOG_WARNING,
				   "arp: attempt to overwrite entry for %s "
				   "on %s by %s on %s\n",
				   inet_ntoa(isaddr), rt->rt_ifp->if_xname,
				   ether_sprintf(ea->arp_sha),
				   ac->ac_if.if_xname);
d782 1
a782 1
	out:
@


1.79
log
@Fix two mbuf leaks in arpresolve. The first one happens on IFF_NOARP
interfaces and is probably never hit. The other one happens when the
number of packets on the arp hold queue is exceeded. If arpresolve()
returns NULL the mbuf must be on the hold queue or freed.
Fixes the mbuf leak seen by dlg@@. Found with dlg@@'s insane mbuf leak
diff. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.78 2008/10/31 21:08:33 claudio Exp $	*/
d85 1
a85 1
struct llinfo_arp *arplookup(u_int32_t, int, int);
d203 2
a204 1
			    (struct sockaddr *)&null_sdl, 0);
d342 1
d402 2
a403 1
		if ((la = arplookup(SIN(dst)->sin_addr.s_addr, 1, 0)) != NULL)
d695 2
a696 1
	la = arplookup(isaddr.s_addr, itaddr.s_addr == myaddr.s_addr, 0);
d778 2
a779 1
		la = arplookup(itaddr.s_addr, 0, SIN_PROXY);
d820 1
d835 4
a838 1
	rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, 0);
d845 1
a845 1
arplookup(addr, create, proxy)
d848 1
d857 1
a857 1
	rt = rtalloc1(sintosa(&sin), create, 0);
d874 1
a874 1
				    NULL, 0);
@


1.78
log
@Be way more strict in the number of packets allowed to be queued in the
arp layer. With a lot of input from deraadt@@.
OK dlg@@, looks good gollo@@ + deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.77 2008/10/30 09:39:05 gollo Exp $	*/
d421 2
a422 1
	if (((struct ifnet *)ac)->if_flags & IFF_NOARP)
d424 1
d457 1
@


1.77
log
@Arpresolve could loose few packets during resolving an ethernet
address. This cvs commit introduces a queue that buffers a small
burst of packets and resending the packets in correct order when
the ethernet address is resolved. Code written by Armin Wolfermann
<aw@@osn.de>.

OK: claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.76 2008/09/10 14:01:23 blambert Exp $	*/
d93 2
a94 2
int	arpinit_done = 0;
int	la_hold_total = 0;
d98 3
a100 3
int myip_initialized = 0;
int revarp_in_progress = 0;
struct ifnet *myip_ifp = NULL;
d426 2
a427 1
	 * response yet. Insert mbuf in hold queue.
d429 10
a438 8
	if (la->la_hold_count >= MAX_HOLD_QUEUE) {
		mh = la->la_hold_head;
		la->la_hold_head = la->la_hold_head->m_nextpkt;
		la->la_hold_count--;
		la_hold_total--;
		m_freem(mh);
	}
	if (la_hold_total < MAX_HOLD_TOTAL) {
d446 9
d747 1
a747 1
			if (la->la_hold_tail && la->la_hold_tail == mh) {
@


1.76
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.75 2008/06/06 13:29:43 henning Exp $	*/
d94 1
d150 1
d311 5
a315 2
		if (la->la_hold)
			m_freem(la->la_hold);
d383 1
d426 1
a426 2
	 * response yet.  Replace the held mbuf with this
	 * latest one.
d428 17
a444 3
	if (la->la_hold)
		m_freem(la->la_hold);
	la->la_hold = m;
d474 8
d564 1
d726 19
a744 8
		if (la->la_hold) {
			struct mbuf *n = la->la_hold;
			la->la_hold = NULL;
			(*ac->ac_if.if_output)(&ac->ac_if, n, rt_key(rt), rt);
			if (la->la_hold == n) {
				/* n is back in la_hold. Discard. */
				m_freem(la->la_hold);
				la->la_hold = NULL;
d1107 2
a1108 2
	db_printf("  la_rt=%p la_hold=%p, la_asked=0x%lx\n",
	    la->la_rt, la->la_hold, la->la_asked);
@


1.75
log
@we must not hardcode the route priority in arplookup, it does not
just insert arp entries. the inserted routes will have the right
priority no matter what, most times cloned.
problem found by Joerg Goltermann <jg@@osn.de>, fix by his colleague
Armin Wolgermann <aw@@osn.de>, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.74 2008/05/11 03:50:23 krw Exp $	*/
d123 1
a123 1
	timeout_add(to, arpt_prune * hz);
d163 1
a163 1
		timeout_add(&arptimer_to, hz);
@


1.74
log
@Try harder to avoid corrupting the mbuf pool. Stuff any mbuf chain in
ln_hold or la_hold into temporary storage and null ln_hold or
la_hold before manually processing the mbuf chain. Discard the mbuf chain
if it is put back in the hold area.

ok claudio@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.73 2008/05/09 15:48:59 claudio Exp $	*/
a796 1
	rt->rt_priority = RTP_CONNECTED;
@


1.73
log
@more rtrequest() to rtrequest1() replacement.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.72 2008/05/09 07:32:39 henning Exp $	*/
d699 8
a706 3
			(*ac->ac_if.if_output)(&ac->ac_if, la->la_hold,
				rt_key(rt), rt);
			la->la_hold = 0;
@


1.72
log
@arp entries in the routing table should have priority RTF_CONNECTED
ok claudio theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.71 2008/04/24 11:36:38 dlg Exp $	*/
d755 1
d766 5
a770 2
	rtrequest(RTM_DELETE, rt_key(rt), (struct sockaddr *)0, rt_mask(rt),
	    0, (struct rtentry **)0, 0);
d798 9
a806 4
				rtrequest(RTM_DELETE,
				    (struct sockaddr *)rt_key(rt),
				    rt->rt_gateway, rt_mask(rt), rt->rt_flags,
				    0, 0);
@


1.71
log
@the softnet intr handlers check if the input queue has packets on
it by reading the queues head pointer. if that pointer is not null
then it takes splnet and dequeues a packet for handling. this is
bad because the ifqueue head is modified at splnet and the sofnet
handlers read it without holding splnet.

this removes that check of the head pointer and simply checks if
the dequeue gave us a packet or not before proceeding.

found while reading mpls code.
discussed with norby@@ and henning@@

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.70 2008/02/05 22:57:30 mpf Exp $	*/
d788 1
@


1.70
log
@Move carp load balancing (ARP/IP) to a simpler configuration scheme.
Instead of using the same IP on multiple interfaces, carp has to be
configured with the new "carpnodes" and "balancing" options.
 # ifconfig carp0 carpnodes 1:0,2:100,3:100 balancing ip carpdev sis0 192.168.5.50

Please note, that this is a flag day for anyone using carp balancing.
You'll need to adjust your configuration accordingly.

Addititionally this diff adds IPv6 NDP balancing support.

Tested and OK mcbride@@, reyk@@.
Manpage help by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.69 2007/11/06 21:52:00 miod Exp $	*/
d472 1
a472 1
	while (arpintrq.ifq_head) {
@


1.69
log
@Do not panic in arpintr() if IF_DEQUEUE returns NULL, this is perfectly legal
and can happen on slow mp systems under a lot of network load; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.68 2007/03/25 16:43:22 claudio Exp $	*/
a533 3
#if NCARP > 0
	u_int32_t count = 0, index = 0;
#endif
d538 3
a565 1
			index++;
d567 1
d569 1
a569 1
			    &count, index))
d592 1
a592 1
			    &count, index))
d734 2
a735 4
	if (ac->ac_if.if_type == IFT_CARP && ac->ac_if.if_flags & IFF_LINK1)
		bcopy(((struct arpcom *)ac->ac_if.if_carpdev)->ac_enaddr,
		    eh->ether_shost, sizeof(eh->ether_shost));
	else
d737 1
a737 1
		bcopy(enaddr, eh->ether_shost, sizeof(eh->ether_shost));
@


1.68
log
@Change the "can't allocate llinfo" to a better log message that includes
the problemantic IP address and a hopefully better reason message.
After discussion with dtucker@@, "fine with me" deraadt@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.67 2007/03/18 23:23:17 mpf Exp $	*/
d476 4
a479 1
		if (m == 0 || (m->m_flags & M_PKTHDR) == 0)
d481 1
@


1.67
log
@Add IP load balancing support for carp(4).
This provides a similar functionality as ARP balancing,
but also works for traffic that comes across routers.
IPv6 is supported as well.
The configuration scheme will change as soon we have sth better.

Also add support for changing the MAC address on carp(4)
interfaces. (code from mcbride)

Tested by pyr@@ and reyk@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.66 2007/03/16 16:58:40 deraadt Exp $	*/
d388 1
a388 1
	if (rt)
d390 4
a393 1
	else {
d396 4
a401 1
		log(LOG_DEBUG, "arpresolve: can't allocate llinfo\n");
@


1.66
log
@remove message that prints
        arplookup: unable to enter address for xxx.xxx.xxx.xxx
because it is absolutely useless in a modern world with cable modems
which leak arp packets over IP netblock zones; Anyone who used this as
a diagnostic for real problems has other tools to use; from discussion
with kitella, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.65 2006/08/21 21:36:53 mpf Exp $	*/
d723 8
a730 1
	bcopy(enaddr, eh->ether_shost, sizeof(eh->ether_shost));
@


1.65
log
@Answer ARP queries also for addresses on carp interfaces, if carps
physical interface shares a bridge with the interface that received it.
Patch based on a version from camield@@
Fixes PR 5178.
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.64 2006/06/16 16:49:40 henning Exp $	*/
a775 3
			log(LOG_DEBUG,
			    "arplookup: unable to enter address for %s\n",
			    inet_ntoa(sin.sin_addr));
@


1.64
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.63 2006/03/22 14:37:44 henning Exp $	*/
d573 13
a585 3
		if (m->m_pkthdr.rcvif->if_bridge != NULL &&
		    m->m_pkthdr.rcvif->if_bridge == ia->ia_ifp->if_bridge)
			bridge_ia = ia;
@


1.63
log
@prevent anything outside rote.c from accessing the routing table heads
directly. rather provide a rt_lookup function for regular lookups,
and a rt_gettable for those that need access to the head for some reason.
the latter cases should be revisted later probably so that nothing outside
the routing core code accesses the heads at all...
tested claudio jolan me, ok claudio markus
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.62 2006/03/04 22:40:16 brad Exp $	*/
d201 1
a201 1
					(struct sockaddr *)&null_sdl);
d741 1
a741 1
	    0, (struct rtentry **)0);
d759 1
a759 1
	rt = rtalloc1(sintosa(&sin), create);
d774 1
a774 1
				    0);
@


1.62
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.61 2005/11/29 02:59:42 jolan Exp $	*/
d1080 1
a1080 1
	rnh = rt_tables[AF_INET];
@


1.61
log
@something in the eurobsdcon route-a-thon broke my simple home network
router so back out the routing stuff to pre-eurobsdcon where my machine
doesn't crash immediately.

i am happy to test diffs and report success/failures but i am not happy
to have instantaneous crashes when i reboot with a new kernel that was
compiled from pristine sources.

if you are going to be an elitist asshole then you could at least make
sure your code works.

ok and "be crass towards them" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.59 2005/07/25 01:10:37 pascoe Exp $	*/
d467 1
a467 1
		s = splimp();
@


1.60
log
@don't let anything outside route.c access the routing table heads directly,
but go through a provided wrapper.
also provide rt_lookup() instead of doing the lookup manually in many places.
ryan ok
@
text
@d1080 1
a1080 1
	rnh = rt_gettable(AF_INET, 0);
@


1.59
log
@minor whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.58 2005/03/01 19:04:56 mcbride Exp $	*/
d1080 1
a1080 1
	rnh = rt_tables[AF_INET];
@


1.58
log
@Unbreak arp_input with carp; add back the call to carp_iamatch()
which was removed in rev 1.57. This makes arpbalance work again, and
ensures that only one carp host will reply to a given arp request.

ok mpf@@ pascoe@@ dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.57 2005/01/04 10:30:01 pascoe Exp $	*/
d559 1
a559 1
			    &count, index)) 
d561 1
a561 1
		} else 
d633 1
a633 1
		  	if (rt->rt_flags & RTF_PERMANENT_ARP) {
d642 1
a642 1
			        log(LOG_WARNING,
d652 1
a652 1
			    	   inet_ntoa(isaddr),
@


1.57
log
@Move processing of ARP packets for CARP addresses to the carp interface
instead of processing them in the parent interface.  This causes us to send
ARP packets on a carpdev with its virtual MAC address as the source, rather
than the parent's physical address.

Permits us to fail over cleanly when connected to devices that use the
source MAC address on a received ARP request to generate an ARP entry for
the requesting host, rather than going through the who-has/is-at procedure.

ok niklas@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.56 2005/01/04 09:29:43 pascoe Exp $	*/
d524 3
d552 13
a564 2
		if (ia->ia_ifp == m->m_pkthdr.rcvif)
			break;
d595 1
a595 1
	if (ia == NULL) {
d699 3
@


1.56
log
@Use pseudo_AF_HDRCMPLT for outgoing ARP messages, otherwise the provided
source MAC address we provide is ignored by ether_output.

ok mcbride@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.55 2004/12/07 20:38:46 mcbride Exp $	*/
d439 5
a561 8
#endif

#if NCARP > 0
		if (ac->ac_if.if_carp && ac->ac_if.if_type != IFT_CARP) {
			if (carp_iamatch(ac->ac_if.if_carp, ia,
			    &isaddr, &enaddr)) 
				break;
		}
@


1.55
log
@Convert carp(4) to behave more like a regular interface, much in the same
style as vlan(4). carp interfaces no longer require the physical interface
to be on the same subnet as the carp interface, or even that the physical
interface has an adress at all, so CARP can now be used on /30 networks.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.54 2004/06/21 23:50:37 tholo Exp $	*/
d353 1
a353 1
	sa.sa_family = AF_UNSPEC;
d701 1
a701 1
	sa.sa_family = AF_UNSPEC;
d913 1
a913 1
	sa.sa_family = AF_UNSPEC;
@


1.54
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.53 2003/12/18 09:23:14 ho Exp $	*/
d560 1
a560 1
		if (ac->ac_if.if_carp) {
d648 5
a652 1
		    (rt->rt_ifp->if_bridge == ac->ac_if.if_bridge))) {
@


1.53
log
@Permit ethernet multicast addresses, as used by some HA/failover solutions. Suggested by and ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.52 2003/12/10 07:22:43 itojun Exp $	*/
d129 1
a129 1
		if (rt->rt_expire && rt->rt_expire <= time.tv_sec)
d158 2
a159 2
		if (time.tv_sec == 0) {
			time.tv_sec++;
d210 1
a210 1
			rt->rt_expire = time.tv_sec;
d404 1
a404 1
	if ((rt->rt_expire == 0 || rt->rt_expire > time.tv_sec) &&
d428 1
a428 1
		rt->rt_expire = time.tv_sec;
d433 2
a434 2
		if (la->la_asked == 0 || rt->rt_expire != time.tv_sec) {
			rt->rt_expire = time.tv_sec;
d660 1
a660 1
			rt->rt_expire = time.tv_sec + arpt_keep;
@


1.52
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.51 2003/11/07 22:04:46 mcbride Exp $	*/
d604 1
a604 1
	if (ETHER_IS_MULTICAST (&ea->arp_sha[0])) {
d606 5
a610 10
		    sizeof (ea->arp_sha)))
		    log(LOG_ERR,
			"arp: ether address is broadcast for IP address %s!\n",
			inet_ntoa(isaddr));
		else
		    log(LOG_ERR,
			"arp: ether address is multicast for IP address %s!\n",
			inet_ntoa(isaddr));
		goto out;
	}
@


1.51
log
@Clean up carp_iamatch() behaviour so we don't reply to arp requests when
the interface is ifconfig'd down.

Patch from Marco Pfatschbacher
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.50 2003/10/17 21:04:58 mcbride Exp $	*/
d126 1
a126 1
		register struct rtentry *rt = la->la_rt;
d141 1
a141 1
	register struct rtentry *rt;
d144 2
a145 2
	register struct sockaddr *gate = rt->rt_gateway;
	register struct llinfo_arp *la = (struct llinfo_arp *)rt->rt_llinfo;
d323 3
a325 3
	register struct ifnet *ifp;
	register u_int32_t *sip, *tip;
	register u_int8_t *enaddr;
d327 3
a329 3
	register struct mbuf *m;
	register struct ether_header *eh;
	register struct ether_arp *ea;
d370 2
a371 2
	register struct arpcom *ac;
	register struct rtentry *rt;
d373 2
a374 2
	register struct sockaddr *dst;
	register u_char *desten;
d376 1
a376 1
	register struct llinfo_arp *la;
d457 2
a458 2
	register struct mbuf *m;
	register struct arphdr *ar;
d510 2
a511 2
	register struct ether_arp *ea;
	register struct arpcom *ac = (struct arpcom *)m->m_pkthdr.rcvif;
d513 2
a514 2
	register struct llinfo_arp *la = 0;
	register struct rtentry *rt;
d713 1
a713 1
	register struct llinfo_arp *la;
d715 2
a716 2
	register struct rtentry *rt = la->la_rt;
	register struct sockaddr_dl *sdl;
d739 1
a739 1
	register struct rtentry *rt;
@


1.50
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.49 2003/09/24 21:11:34 itojun Exp $	*/
a563 2
			else
				goto out;
@


1.49
log
@on-link DoS by bogus ARP.  reported by apple
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.48 2003/06/02 23:28:13 millert Exp $	*/
d42 1
d63 3
d96 3
a98 3
static struct in_addr myip, srv_ip;
static int myip_initialized = 0;
static int revarp_in_progress = 0;
d522 1
d558 10
d600 2
d604 1
a604 2
	if (!bcmp((caddr_t)ea->arp_sha, (caddr_t)ac->ac_enaddr,
	    sizeof (ea->arp_sha)))
d628 1
a628 1
		    if (bcmp((caddr_t)ea->arp_sha, LLADDR(sdl), sdl->sdl_alen)) {
d664 1
a664 1
		bcopy((caddr_t)ea->arp_sha, LLADDR(sdl),
d684 2
a685 4
		bcopy((caddr_t)ea->arp_sha, (caddr_t)ea->arp_tha,
		    sizeof(ea->arp_sha));
		bcopy((caddr_t)ac->ac_enaddr, (caddr_t)ea->arp_sha,
		    sizeof(ea->arp_sha));
d691 1
a691 2
		bcopy((caddr_t)ea->arp_sha, (caddr_t)ea->arp_tha,
		    sizeof(ea->arp_sha));
d693 1
a693 1
		bcopy(LLADDR(sdl), (caddr_t)ea->arp_sha, sizeof(ea->arp_sha));
d696 2
a697 2
	bcopy((caddr_t)ea->arp_spa, (caddr_t)ea->arp_tpa, sizeof(ea->arp_spa));
	bcopy((caddr_t)&itaddr, (caddr_t)ea->arp_spa, sizeof(ea->arp_spa));
d701 2
a702 4
	bcopy((caddr_t)ea->arp_tha, (caddr_t)eh->ether_dhost,
	    sizeof(eh->ether_dhost));
	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)eh->ether_shost,
	    sizeof(eh->ether_shost));
@


1.48
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.47 2003/05/17 15:15:23 itojun Exp $	*/
d743 1
a743 1
		if (create)
d747 8
@


1.48.2.1
log
@Pull patch from -current:
Fixed by itojun@@

Fix on-link DoS by bogus ARP. Reported by Apple.

ok itojun@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.48 2003/06/02 23:28:13 millert Exp $	*/
d743 1
a743 1
		if (create) {
a746 8
			if (rt->rt_refcnt <= 0 &&
			    (rt->rt_flags & RTF_CLONED) != 0) {
				rtrequest(RTM_DELETE,
				    (struct sockaddr *)rt_key(rt),
				    rt->rt_gateway, rt_mask(rt), rt->rt_flags,
				    0);
			}
		}
@


1.47
log
@don't send ARP for secondary IPv4 addresses, treat them as local.
kwesterback tdeval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.46 2003/05/04 11:56:32 dhartmei Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.46
log
@Free mbuf when dropping invalid ARP with ar_hrd != ARPHRD_ETHER, instead
of leaking. Reported by orjan.sjelvgren@@ignite.com. ok jason@@, krw@@ and
henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.45 2002/06/09 16:26:10 itojun Exp $	*/
d147 2
d257 8
a264 2
		if (SIN(rt_key(rt))->sin_addr.s_addr ==
		    (IA_SIN(rt->rt_ifa))->sin_addr.s_addr) {
d275 6
d288 11
@


1.45
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.44 2002/06/09 07:50:57 itojun Exp $	*/
d448 2
a449 1
		if (ntohs(ar->ar_hrd) != ARPHRD_ETHER)
d451 1
@


1.45.2.1
log
@MFC:
Fix by dhartmei@@

Free mbuf when dropping invalid ARP with ar_hrd != ARPHRD_ETHER, instead
of leaking. Reported by orjan.sjelvgren@@ignite.com. ok jason@@, krw@@ and
henning@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.45 2002/06/09 16:26:10 itojun Exp $	*/
d448 1
a448 2
		if (ntohs(ar->ar_hrd) != ARPHRD_ETHER) {
			m_freem(m);
a449 1
		}
@


1.45.2.2
log
@Pull patch from -current:
Fixed by itojun@@

Fix on-link DoS by bogus ARP. Reported by Apple.

ok itojun@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.45.2.1 2003/08/24 23:20:37 brad Exp $	*/
d722 1
a722 1
		if (create) {
a725 8
			if (rt->rt_refcnt <= 0 &&
			    (rt->rt_flags & RTF_CLONED) != 0) {
				rtrequest(RTM_DELETE,
				    (struct sockaddr *)rt_key(rt),
				    rt->rt_gateway, rt_mask(rt), rt->rt_flags,
				    0);
			}
		}
@


1.45.4.1
log
@Pull patch from -current:
Free mbuf when dropping invalid ARP with ar_hrd != ARPHRD_ETHER, instead
of leaking. Reported orjan.sjelvgren@@ignite.com.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.45 2002/06/09 16:26:10 itojun Exp $	*/
d448 1
a448 2
		if (ntohs(ar->ar_hrd) != ARPHRD_ETHER) {
			m_freem(m);
a449 1
		}
@


1.45.4.2
log
@Pull patch from -current:
Fixed by itojun@@

Fix on-link DoS by bogus ARP. Reported by Apple.

ok itojun@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.45.4.1 2003/05/12 04:07:20 margarida Exp $	*/
d722 1
a722 1
		if (create) {
a725 8
			if (rt->rt_refcnt <= 0 &&
			    (rt->rt_flags & RTF_CLONED) != 0) {
				rtrequest(RTM_DELETE,
				    (struct sockaddr *)rt_key(rt),
				    rt->rt_gateway, rt_mask(rt), rt->rt_flags,
				    0);
			}
		}
@


1.44
log
@support published arp entries again.  PR 2635 (confirmed by submitter).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.43 2002/06/09 05:25:50 itojun Exp $	*/
d593 1
a593 1
				   "entry for %s by %s on %s\n", 
d609 1
a609 1
			    	   inet_ntoa(isaddr), 
d891 2
a892 2
	
	if (myip_initialized) 
d906 1
a906 1
	
@


1.43
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.42 2002/06/09 05:08:37 itojun Exp $	*/
d546 11
@


1.42
log
@force FDDI link MTU be FDDI IPv4 MTU.  PR 2714.  jason ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.41 2002/06/07 23:30:26 aaron Exp $	*/
d212 1
a212 1
			switch (rt->rt_ifp->if_types) {
@


1.41
log
@Use LIST macros instead of accessing field members directly; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.40 2002/03/27 17:13:47 ian Exp $	*/
d60 2
d163 17
a179 1
	if (rt->rt_flags & RTF_GATEWAY)
d181 2
d209 12
@


1.40
log
@suppress "duplicate IP" message when booting machines with no initial IP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.39 2002/03/14 03:16:11 millert Exp $	*/
d122 2
a123 1
	for (la = llinfo_arp.lh_first; la != 0; la = nla) {
d126 1
a126 1
		nla = la->la_list.le_next;
@


1.39
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.38 2002/03/14 01:27:11 millert Exp $	*/
d535 1
a535 1
	if (isaddr.s_addr == myaddr.s_addr) {
@


1.38
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.37 2002/02/26 20:24:58 jason Exp $	*/
d897 1
a897 1
	p = (u_char*)sa;
@


1.37
log
@Cut/pasto: don't forget to scan for the source address
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.36 2002/02/15 15:27:17 jason Exp $	*/
d81 4
a84 4
void arptfree __P((struct llinfo_arp *));
void arptimer __P((void *));
struct llinfo_arp *arplookup __P((u_int32_t, int, int));
void in_arpinput __P((struct mbuf *));
d102 4
a105 4
void	db_print_sa __P((struct sockaddr *));
void	db_print_ifa __P((struct ifaddr *));
void	db_print_llinfo __P((caddr_t));
int	db_show_radix_node __P((struct radix_node *, void *));
@


1.36
log
@Clean up arpinput (based on similiar changes in NetBSD), also be sure to
setup the arpcom when we're allowing lazy matches on bridged interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.35 2001/12/08 06:15:15 jason Exp $	*/
d508 1
a508 1
			if (itaddr.s_addr != ia->ia_addr.sin_addr.s_addr)
@


1.35
log
@style: Use queue.h macro's for list traversal, convert several (&thing)->foo
to thing.foo under the principal less puncuation is easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.34 2001/11/06 19:53:20 miod Exp $	*/
d47 2
d455 4
a458 1
	struct in_ifaddr *ia, *maybe_ia = 0;
d475 2
d478 1
a478 1
	bcopy((caddr_t)ea->arp_tpa, (caddr_t)&itaddr, sizeof(itaddr));
d480 31
a510 6
		if (ia->ia_ifp == &ac->ac_if ||
		    (ia->ia_ifp->if_bridge &&
		    ia->ia_ifp->if_bridge == ac->ac_if.if_bridge)) {
			maybe_ia = ia;
			if (itaddr.s_addr == ia->ia_addr.sin_addr.s_addr ||
			    isaddr.s_addr == ia->ia_addr.sin_addr.s_addr)
d514 2
a515 1
	if (maybe_ia == 0)
d517 3
a519 1
	myaddr = ia ? ia->ia_addr.sin_addr : maybe_ia->ia_addr.sin_addr;
@


1.35.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.35 2001/12/08 06:15:15 jason Exp $	*/
a46 2
#include "bridge.h"

a57 2
#include <net/if_fddi.h>
#include <net/if_types.h>
d79 4
a82 4
void arptfree(struct llinfo_arp *);
void arptimer(void *);
struct llinfo_arp *arplookup(u_int32_t, int, int);
void in_arpinput(struct mbuf *);
d100 4
a103 4
void	db_print_sa(struct sockaddr *);
void	db_print_ifa(struct ifaddr *);
void	db_print_llinfo(caddr_t);
int	db_show_radix_node(struct radix_node *, void *);
d120 1
a120 2
	for (la = LIST_FIRST(&llinfo_arp); la != LIST_END(&llinfo_arp);
	    la = nla) {
d123 1
a123 1
		nla = LIST_NEXT(la, la_list);
d158 1
a158 17

	if (rt->rt_flags & RTF_GATEWAY) {
		if (req != RTM_ADD)
			return;

		/*
		 * linklayers with particular link MTU limitation.  it is a bit
		 * awkward to have FDDI handling here, we should split ARP from
		 * netinet/if_ether.c like NetBSD does.
		 */
		switch (rt->rt_ifp->if_type) {
		case IFT_FDDI:
			if (rt->rt_ifp->if_mtu > FDDIIPMTU)
				rt->rt_rmx.rmx_mtu = FDDIIPMTU;
			break;
		}

a159 2
	}

a185 12
			/*
			 * linklayers with particular link MTU limitation.
			 */
			switch (rt->rt_ifp->if_type) {
			case IFT_FDDI:
				if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0 &&
				    (rt->rt_rmx.rmx_mtu > FDDIIPMTU ||
				     (rt->rt_rmx.rmx_mtu == 0 &&
				      rt->rt_ifp->if_mtu > FDDIIPMTU)))
					rt->rt_rmx.rmx_mtu = FDDIIPMTU;
				break;
			}
d453 1
a453 4
	struct in_ifaddr *ia;
#if NBRIDGE > 0
	struct in_ifaddr *bridge_ia = NULL;
#endif
d470 1
a470 1

a471 2
	bcopy((caddr_t)ea->arp_spa, (caddr_t)&isaddr, sizeof(isaddr));

d473 6
a478 31
		if (itaddr.s_addr != ia->ia_addr.sin_addr.s_addr)
			continue;

		if (ia->ia_ifp == m->m_pkthdr.rcvif)
			break;
#if NBRIDGE > 0
		/*
		 * If the interface we received the packet on
		 * is part of a bridge, check to see if we need
		 * to "bridge" the packet to ourselves at this
		 * layer.  Note we still prefer a perfect match,
		 * but allow this weaker match if necessary.
		 */
		if (m->m_pkthdr.rcvif->if_bridge != NULL &&
		    m->m_pkthdr.rcvif->if_bridge == ia->ia_ifp->if_bridge)
			bridge_ia = ia;
#endif
	}

#if NBRIDGE > 0
	if (ia == NULL && bridge_ia != NULL) {
		ia = bridge_ia;
		ac = (struct arpcom *)bridge_ia->ia_ifp;
	}
#endif

	if (ia == NULL) {
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (isaddr.s_addr != ia->ia_addr.sin_addr.s_addr)
				continue;
			if (ia->ia_ifp == m->m_pkthdr.rcvif)
d482 1
a482 13

	if (ia == NULL) {
		struct ifaddr *ifa;

		TAILQ_FOREACH(ifa, &m->m_pkthdr.rcvif->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family == AF_INET)
				break;
		}
		if (ifa)
			ia = (struct in_ifaddr *)ifa;
	}

	if (ia == NULL)
d484 1
a484 3

	myaddr = ia->ia_addr.sin_addr;

d500 1
a500 1
	if (myaddr.s_addr && isaddr.s_addr == myaddr.s_addr) {
d862 1
a862 1
	p = (u_char *)sa;
@


1.35.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.35.2.1 2002/06/11 03:31:36 art Exp $	*/
d593 1
a593 1
				   "entry for %s by %s on %s\n",
d609 1
a609 1
			    	   inet_ntoa(isaddr),
d891 2
a892 2

	if (myip_initialized)
d906 1
a906 1

@


1.35.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d448 1
a448 2
		if (ntohs(ar->ar_hrd) != ARPHRD_ETHER) {
			m_freem(m);
a449 1
		}
@


1.34
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.33 2001/07/08 12:31:12 niklas Exp $	*/
d470 3
a472 3
	bcopy((caddr_t)ea->arp_spa, (caddr_t)&isaddr, sizeof (isaddr));
	bcopy((caddr_t)ea->arp_tpa, (caddr_t)&itaddr, sizeof (itaddr));
	for (ia = in_ifaddr.tqh_first; ia != 0; ia = ia->ia_list.tqe_next)
d481 1
d517 1
a517 1
				   (&ac->ac_if)->if_xname);
d525 1
a525 1
				   (&ac->ac_if)->if_xname);
d532 1
a532 1
				   (&ac->ac_if)->if_xname);
d543 1
a543 1
			(&ac->ac_if)->if_xname);
@


1.33
log
@Remove static from func decls
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.32 2001/06/09 06:14:11 angelos Exp $	*/
d98 1
a98 1
#include <vm/vm.h>
@


1.32
log
@Less aggressive include cleanup, so it won't piss of Theo again (one hopes)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.31 2001/06/08 20:32:24 deraadt Exp $	*/
d79 1
a79 1
static	void arptfree __P((struct llinfo_arp *));
d81 2
a82 2
static	struct llinfo_arp *arplookup __P((u_int32_t, int, int));
static	void in_arpinput __P((struct mbuf *));
d100 4
a103 4
static void db_print_sa __P((struct sockaddr *));
static void db_print_ifa __P((struct ifaddr *));
static void db_print_llinfo __P((caddr_t));
static int db_show_radix_node __P((struct radix_node *, void *));
d444 1
a444 1
static void
d599 1
a599 1
static void
d622 1
a622 1
static struct llinfo_arp *
d849 1
a849 1
static void
d874 1
a874 1
static void
d890 1
a890 1
static void
d907 1
a907 1
static int
@


1.31
log
@it is nice if the kernel compiles
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.29 2001/05/15 15:12:54 gluk Exp $	*/
a48 1
#include <sys/malloc.h>
a50 1
#include <sys/time.h>
a51 2
#include <sys/errno.h>
#include <sys/ioctl.h>
a59 1
#include <netinet/in_systm.h>
a60 1
#include <netinet/ip.h>
@


1.30
log
@Cut down on include files.
@
text
@d48 2
d52 1
d54 2
d57 1
d64 1
d66 1
@


1.29
log
@Accept ARP packet coming from bridge interface without IP address
configured. But deny such a packet if it coming on "wrong" bridge.

Reported and tested by form@@
ho@@, jason@@ Ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.28 2001/02/06 00:22:24 mickey Exp $	*/
a47 2
#include <sys/systm.h>
#include <sys/malloc.h>
a49 1
#include <sys/time.h>
a50 2
#include <sys/errno.h>
#include <sys/ioctl.h>
a51 1
#include <sys/proc.h>
a57 1
#include <netinet/in_systm.h>
a58 1
#include <netinet/ip.h>
@


1.28
log
@allow changing number of loopbacks in ukc.
change rest of the code to use lo0ifp pointing
to the corresponding struct ifnet.
itojun@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.27 2001/02/05 15:22:11 jason Exp $	*/
d541 2
a542 1
		} else if (rt->rt_ifp != &ac->ac_if) {
@


1.28.2.1
log
@Pull in patch from current:
Fix (gluk):
Accept ARP packet coming from bridge interface without IP address
configured. But deny such a packet if it coming on "wrong" bridge.

Reported and tested by form@@
ho@@, jason@@ Ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.28 2001/02/06 00:22:24 mickey Exp $	*/
d541 1
a541 2
		} else if (rt->rt_ifp != &ac->ac_if && !(ac->ac_if.if_bridge &&
		    (rt->rt_ifp->if_bridge == ac->ac_if.if_bridge))) {
@


1.27
log
@with a bunch of encapsulation layers, eg. (IPsec+IP+EtherIP+ether_header),
the arp data will not necessarily be in the first mbuf: add m_pullup()'s
to make it so.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.26 2001/01/19 06:37:37 itojun Exp $	*/
a89 1
extern	struct ifnet loif;
d230 1
a230 1
			 *	if (loif.if_flags & IFF_UP)
d244 1
a244 1
				rt->rt_ifp = &loif;
@


1.26
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.25 2000/12/28 23:56:47 mickey Exp $	*/
d406 1
a406 1
	int s;
d414 19
a432 12
		if (m->m_len >= sizeof(struct arphdr) &&
		    (ar = mtod(m, struct arphdr *)) &&
		    ntohs(ar->ar_hrd) == ARPHRD_ETHER &&
		    m->m_len >=
		      sizeof(struct arphdr) + 2 * (ar->ar_hln + ar->ar_pln))
			switch (ntohs(ar->ar_pro)) {

			case ETHERTYPE_IP:
			case ETHERTYPE_IPTRAILERS:
				in_arpinput(m);
				continue;
			}
@


1.25
log
@export arprequest() and make it use ifnet* as the 1st arg; tested; angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.24 2000/11/27 16:20:43 ho Exp $	*/
d141 1
a141 1
arp_rtrequest(req, rt, sa)
d144 1
a144 1
	struct sockaddr *sa;
@


1.24
log
@Style. Parts of xcast handling needs more thought. (provos@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.23 2000/11/27 14:57:52 ho Exp $	*/
a84 2
static	void arprequest
	    __P((struct arpcom *, u_int32_t *, u_int32_t *, u_int8_t *));
d197 1
a197 1
			arprequest((struct arpcom *)rt->rt_ifp,
d268 3
a270 3
static void
arprequest(ac, sip, tip, enaddr)
	register struct arpcom *ac;
d302 1
a302 1
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa, (struct rtentry *)0);
d383 1
a383 1
				arprequest(ac,
d664 1
a664 1
	arprequest(ac,
@


1.23
log
@Be more careful with ARP. Fix PR#1490. From gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.22 2000/06/22 19:05:51 art Exp $	*/
d465 1
d471 1
d489 1
a489 1
	if (ea->arp_sha[0] & 1) {
@


1.22
log
@Convert arptimer to new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.21 2000/06/20 17:56:10 art Exp $	*/
d463 7
d487 10
a496 5
	if (!bcmp((caddr_t)ea->arp_sha, (caddr_t)etherbroadcastaddr,
	    sizeof (ea->arp_sha))) {
		log(LOG_ERR,
		    "arp: ether address is broadcast for IP address %s!\n",
		    inet_ntoa(isaddr));
d508 2
a509 2
		if (sdl->sdl_alen &&
		    bcmp((caddr_t)ea->arp_sha, LLADDR(sdl), sdl->sdl_alen)) {
d534 9
@


1.21
log
@
Remove static from arptimer so that "show callout" in ddb shows the right
function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.20 2000/03/17 22:05:57 art Exp $	*/
d123 1
d125 1
a125 1
	register struct llinfo_arp *la, *nla;
d128 1
a128 1
	timeout(arptimer, NULL, arpt_prune * hz);
d153 2
d163 3
a165 1
		timeout(arptimer, (caddr_t)0, hz);
@


1.20
log
@remove multiple function declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.19 1999/11/10 18:48:47 chris Exp $	*/
d88 1
a88 1
static	void arptimer __P((void *));
d119 1
a119 1
static void
@


1.19
log
@Fix typo in printf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.18 1999/08/08 02:42:59 niklas Exp $	*/
a105 6
static void arptimer __P((void *));
static void arprequest __P((struct arpcom *, u_int32_t *, u_int32_t *,
			    u_int8_t *));
static void in_arpinput __P((struct mbuf *));
static void arptfree __P((struct llinfo_arp *));
static struct llinfo_arp *arplookup __P((u_int32_t, int, int ));
@


1.19.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 6
@


1.19.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.28 2001/02/06 00:22:24 mickey Exp $	*/
d85 2
d88 1
a88 1
void arptimer __P((void *));
d92 1
d119 1
a119 1
void
a122 1
	struct timeout *to = (struct timeout *)arg;
d124 1
a124 1
	struct llinfo_arp *la, *nla;
d127 1
a127 1
	timeout_add(to, arpt_prune * hz);
d142 1
a142 1
arp_rtrequest(req, rt, info)
d145 1
a145 1
	struct rt_addrinfo *info;
a151 2
		static struct timeout arptimer_to;

d160 1
a160 3

		timeout_set(&arptimer_to, arptimer, &arptimer_to);
		timeout_add(&arptimer_to, hz);
d194 1
a194 1
			arprequest(rt->rt_ifp,
d228 1
a228 1
			 *	if (lo0ifp->if_flags & IFF_UP)
d242 1
a242 1
				rt->rt_ifp = lo0ifp;
d265 3
a267 3
void
arprequest(ifp, sip, tip, enaddr)
	register struct ifnet *ifp;
d299 1
a299 1
	(*ifp->if_output)(ifp, m, &sa, (struct rtentry *)0);
d380 1
a380 1
				arprequest(&ac->ac_if,
d403 1
a403 1
	int s, len;
d411 12
a422 19

		len = sizeof(struct arphdr);
		if (m->m_len < len && (m = m_pullup(m, len)) == NULL)
			continue;

		ar = mtod(m, struct arphdr *);
		if (ntohs(ar->ar_hrd) != ARPHRD_ETHER)
			continue;

		len += 2 * (ar->ar_hln + ar->ar_pln);
		if (m->m_len < len && (m = m_pullup(m, len)) == NULL)
			continue;

		switch (ntohs(ar->ar_pro)) {
		case ETHERTYPE_IP:
		case ETHERTYPE_IPTRAILERS:
			in_arpinput(m);
			continue;
		}
a457 9
	if ((op != ARPOP_REQUEST) && (op != ARPOP_REPLY))
		goto out;
#if notyet
	if ((op == ARPOP_REPLY) && (m->m_flags & (M_BCAST|M_MCAST))) {
		log(LOG_ERR,
		    "arp: received reply to broadcast or multicast address\n");
		goto out;
	}
#endif
d475 5
a479 10
	if (ETHER_IS_MULTICAST (&ea->arp_sha[0])) {
		if (!bcmp((caddr_t)ea->arp_sha, (caddr_t)etherbroadcastaddr,
		    sizeof (ea->arp_sha)))
		    log(LOG_ERR,
			"arp: ether address is broadcast for IP address %s!\n",
			inet_ntoa(isaddr));
		else
		    log(LOG_ERR,
			"arp: ether address is multicast for IP address %s!\n",
			inet_ntoa(isaddr));
d491 2
a492 2
		if (sdl->sdl_alen) {
		    if (bcmp((caddr_t)ea->arp_sha, LLADDR(sdl), sdl->sdl_alen)) {
a516 9
		    }
		} else if (rt->rt_ifp != &ac->ac_if) {
		    log(LOG_WARNING,
			"arp: attempt to add entry for %s "
			"on %s by %s on %s\n",
			inet_ntoa(isaddr), rt->rt_ifp->if_xname,
			ether_sprintf(ea->arp_sha),
			(&ac->ac_if)->if_xname);
		    goto out;
d638 1
a638 1
	arprequest(&ac->ac_if,
@


1.19.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.19.2.2 2001/05/14 22:40:07 niklas Exp $	*/
d49 1
d52 1
d54 2
d64 1
d66 1
d541 1
a541 2
		} else if (rt->rt_ifp != &ac->ac_if && !(ac->ac_if.if_bridge &&
		    (rt->rt_ifp->if_bridge == ac->ac_if.if_bridge))) {
@


1.19.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.19.2.3 2001/07/04 10:54:28 niklas Exp $	*/
d79 1
a79 1
void arptfree __P((struct llinfo_arp *));
d81 2
a82 2
struct llinfo_arp *arplookup __P((u_int32_t, int, int));
void in_arpinput __P((struct mbuf *));
d100 4
a103 4
void	db_print_sa __P((struct sockaddr *));
void	db_print_ifa __P((struct ifaddr *));
void	db_print_llinfo __P((caddr_t));
int	db_show_radix_node __P((struct radix_node *, void *));
d444 1
a444 1
void
d599 1
a599 1
void
d622 1
a622 1
struct llinfo_arp *
d849 1
a849 1
void
d874 1
a874 1
void
d890 1
a890 1
void
d907 1
a907 1
int
@


1.19.2.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d98 1
a98 1
#include <uvm/uvm_extern.h>
@


1.19.2.6
log
@Merge in trunk
@
text
@a46 2
#include "bridge.h"

d453 1
a453 4
	struct in_ifaddr *ia;
#if NBRIDGE > 0
	struct in_ifaddr *bridge_ia = NULL;
#endif
d470 9
a478 36

	bcopy((caddr_t)ea->arp_tpa, (caddr_t)&itaddr, sizeof(itaddr));
	bcopy((caddr_t)ea->arp_spa, (caddr_t)&isaddr, sizeof(isaddr));

	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
		if (itaddr.s_addr != ia->ia_addr.sin_addr.s_addr)
			continue;

		if (ia->ia_ifp == m->m_pkthdr.rcvif)
			break;
#if NBRIDGE > 0
		/*
		 * If the interface we received the packet on
		 * is part of a bridge, check to see if we need
		 * to "bridge" the packet to ourselves at this
		 * layer.  Note we still prefer a perfect match,
		 * but allow this weaker match if necessary.
		 */
		if (m->m_pkthdr.rcvif->if_bridge != NULL &&
		    m->m_pkthdr.rcvif->if_bridge == ia->ia_ifp->if_bridge)
			bridge_ia = ia;
#endif
	}

#if NBRIDGE > 0
	if (ia == NULL && bridge_ia != NULL) {
		ia = bridge_ia;
		ac = (struct arpcom *)bridge_ia->ia_ifp;
	}
#endif

	if (ia == NULL) {
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (isaddr.s_addr != ia->ia_addr.sin_addr.s_addr)
				continue;
			if (ia->ia_ifp == m->m_pkthdr.rcvif)
d481 1
a481 3
	}

	if (ia == NULL)
d483 1
a483 3

	myaddr = ia->ia_addr.sin_addr;

d516 1
a516 1
				   ac->ac_if.if_xname);
d524 1
a524 1
				   ac->ac_if.if_xname);
d531 1
a531 1
				   ac->ac_if.if_xname);
d542 1
a542 1
			ac->ac_if.if_xname);
@


1.19.2.7
log
@Merge in -current from roughly a week ago
@
text
@d81 4
a84 4
void arptfree(struct llinfo_arp *);
void arptimer(void *);
struct llinfo_arp *arplookup(u_int32_t, int, int);
void in_arpinput(struct mbuf *);
d102 4
a105 4
void	db_print_sa(struct sockaddr *);
void	db_print_ifa(struct ifaddr *);
void	db_print_llinfo(caddr_t);
int	db_show_radix_node(struct radix_node *, void *);
d897 1
a897 1
	p = (u_char *)sa;
@


1.19.2.8
log
@Sync the SMP branch with 3.3
@
text
@a59 2
#include <net/if_fddi.h>
#include <net/if_types.h>
d122 1
a122 2
	for (la = LIST_FIRST(&llinfo_arp); la != LIST_END(&llinfo_arp);
	    la = nla) {
d125 1
a125 1
		nla = LIST_NEXT(la, la_list);
d160 1
a160 17

	if (rt->rt_flags & RTF_GATEWAY) {
		if (req != RTM_ADD)
			return;

		/*
		 * linklayers with particular link MTU limitation.  it is a bit
		 * awkward to have FDDI handling here, we should split ARP from
		 * netinet/if_ether.c like NetBSD does.
		 */
		switch (rt->rt_ifp->if_type) {
		case IFT_FDDI:
			if (rt->rt_ifp->if_mtu > FDDIIPMTU)
				rt->rt_rmx.rmx_mtu = FDDIIPMTU;
			break;
		}

a161 2
	}

a187 12
			/*
			 * linklayers with particular link MTU limitation.
			 */
			switch (rt->rt_ifp->if_type) {
			case IFT_FDDI:
				if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0 &&
				    (rt->rt_rmx.rmx_mtu > FDDIIPMTU ||
				     (rt->rt_rmx.rmx_mtu == 0 &&
				      rt->rt_ifp->if_mtu > FDDIIPMTU)))
					rt->rt_rmx.rmx_mtu = FDDIIPMTU;
				break;
			}
a514 11
	if (ia == NULL) {
		struct ifaddr *ifa;

		TAILQ_FOREACH(ifa, &m->m_pkthdr.rcvif->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family == AF_INET)
				break;
		}
		if (ifa)
			ia = (struct in_ifaddr *)ifa;
	}

d535 1
a535 1
	if (myaddr.s_addr && isaddr.s_addr == myaddr.s_addr) {
d549 1
a549 1
				   "entry for %s by %s on %s\n",
d565 1
a565 1
			    	   inet_ntoa(isaddr),
d847 2
a848 2

	if (myip_initialized)
d862 1
a862 1

@


1.19.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.19.2.8 2003/03/28 00:06:54 niklas Exp $	*/
d448 1
a448 2
		if (ntohs(ar->ar_hrd) != ARPHRD_ETHER) {
			m_freem(m);
a449 1
		}
@


1.19.2.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.19.2.9 2003/05/13 19:36:16 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
a146 2
	struct in_ifaddr *ia;
	struct ifaddr *ifa;
d255 2
a256 8

		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (ia->ia_ifp == rt->rt_ifp &&
			    SIN(rt_key(rt))->sin_addr.s_addr ==
			    (IA_SIN(ia))->sin_addr.s_addr)
				break;
		}
		if (ia) {
a266 6
			 *
			 * In 4.4BSD, the above "if" statement checked
			 * rt->rt_ifa against rt_key(rt).  It was changed
			 * to the current form so that we can provide a
			 * better support for multiple IPv4 addresses on a
			 * interface.
a273 11
			/*
			 * make sure to set rt->rt_ifa to the interface
			 * address we are using, otherwise we will have trouble
			 * with source address selection.
			 */
			ifa = &ia->ia_ifa;
			if (ifa != rt->rt_ifa) {
				IFAFREE(rt->rt_ifa);
				ifa->ifa_refcnt++;
				rt->rt_ifa = ifa;
			}
@


1.19.2.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a41 1
#include "carp.h"
a61 3
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif
d92 3
a94 3
struct in_addr myip, srv_ip;
int myip_initialized = 0;
int revarp_in_progress = 0;
d122 1
a122 1
		struct rtentry *rt = la->la_rt;
d137 1
a137 1
	struct rtentry *rt;
d140 2
a141 2
	struct sockaddr *gate = rt->rt_gateway;
	struct llinfo_arp *la = (struct llinfo_arp *)rt->rt_llinfo;
d319 3
a321 3
	struct ifnet *ifp;
	u_int32_t *sip, *tip;
	u_int8_t *enaddr;
d323 3
a325 3
	struct mbuf *m;
	struct ether_header *eh;
	struct ether_arp *ea;
d366 2
a367 2
	struct arpcom *ac;
	struct rtentry *rt;
d369 2
a370 2
	struct sockaddr *dst;
	u_char *desten;
d372 1
a372 1
	struct llinfo_arp *la;
d453 2
a454 2
	struct mbuf *m;
	struct arphdr *ar;
d506 2
a507 2
	struct ether_arp *ea;
	struct arpcom *ac = (struct arpcom *)m->m_pkthdr.rcvif;
d509 2
a510 2
	struct llinfo_arp *la = 0;
	struct rtentry *rt;
a517 1
	u_int8_t *enaddr = NULL;
a552 8

#if NCARP > 0
		if (ac->ac_if.if_carp) {
			if (carp_iamatch(ac->ac_if.if_carp, ia,
			    &isaddr, &enaddr)) 
				break;
		}
#endif
a584 2
	if (!enaddr)
		enaddr = ac->ac_enaddr;
d587 2
a588 1
	if (!bcmp((caddr_t)ea->arp_sha, enaddr, sizeof (ea->arp_sha)))
d590 1
a590 1
	if (ETHER_IS_MULTICAST (&ea->arp_sha[0]))
d592 10
a601 5
		    sizeof (ea->arp_sha))) {
			log(LOG_ERR, "arp: ether address is broadcast for "
			    "IP address %s!\n", inet_ntoa(isaddr));
			goto out;
		}
d612 1
a612 1
		    if (bcmp(ea->arp_sha, LLADDR(sdl), sdl->sdl_alen)) {
d648 1
a648 1
		bcopy(ea->arp_sha, LLADDR(sdl),
d668 4
a671 2
		bcopy(ea->arp_sha, ea->arp_tha, sizeof(ea->arp_sha));
		bcopy(enaddr, ea->arp_sha, sizeof(ea->arp_sha));
d677 2
a678 1
		bcopy(ea->arp_sha, ea->arp_tha, sizeof(ea->arp_sha));
d680 1
a680 1
		bcopy(LLADDR(sdl), ea->arp_sha, sizeof(ea->arp_sha));
d683 2
a684 2
	bcopy(ea->arp_spa, ea->arp_tpa, sizeof(ea->arp_spa));
	bcopy(&itaddr, ea->arp_spa, sizeof(ea->arp_spa));
d688 4
a691 2
	bcopy(ea->arp_tha, eh->ether_dhost, sizeof(eh->ether_dhost));
	bcopy(enaddr, eh->ether_shost, sizeof(eh->ether_shost));
d704 1
a704 1
	struct llinfo_arp *la;
d706 2
a707 2
	struct rtentry *rt = la->la_rt;
	struct sockaddr_dl *sdl;
d730 1
a730 1
	struct rtentry *rt;
d743 1
a743 1
		if (create) {
a746 8
			if (rt->rt_refcnt <= 0 &&
			    (rt->rt_flags & RTF_CLONED) != 0) {
				rtrequest(RTM_DELETE,
				    (struct sockaddr *)rt_key(rt),
				    rt->rt_gateway, rt_mask(rt), rt->rt_flags,
				    0);
			}
		}
@


1.18
log
@Fix cases when wanting to communicate with the bridge'
s remote interfaces, both ARP and local delivery had bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.17 1999/08/08 00:43:00 niklas Exp $	*/
d509 1
a509 1
				   "arp: attemt to overwrite entry for %s "
@


1.17
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.16 1999/08/02 22:51:15 deraadt Exp $	*/
d467 3
a469 1
		if (ia->ia_ifp == &ac->ac_if) {
@


1.16
log
@Ethernet, not 10 Mb/s Ethernet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.15 1999/07/18 21:36:40 ho Exp $	*/
d101 4
a104 4
static struct	in_addr myip, srv_ip;
static int	myip_initialized = 0;
static int	revarp_in_progress = 0;
static struct	ifnet *myip_ifp = NULL;
@


1.15
log
@Prevent host on one interface from overwriting ARP route entry for a
host on a different interface. Also add interface name to other overwrite
diagnostic messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.14 1999/05/16 00:34:40 ho Exp $	*/
d434 1
a434 1
 * ARP for Internet protocols on 10 Mb/s Ethernet.
d651 1
a651 1
 * Called from 10 Mb/s Ethernet interrupt handlers
d684 1
a684 1
 * RARP for Internet protocols on 10 Mb/s Ethernet.
@


1.14
log
@Add support for static ARP entries that cannot be overwritten.
Ordinary static ARPs that are overwritten will no longer still be static.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.13 1999/03/13 21:15:16 deraadt Exp $	*/
d500 12
a511 2
				   "entry for %s by %s\n", inet_ntoa(isaddr),
				   ether_sprintf(ea->arp_sha));
d515 1
a515 1
				   "arp info overwritten for %s by %s\n",
d517 2
a518 1
				   ether_sprintf(ea->arp_sha));
@


1.13
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.12 1997/09/28 23:09:56 deraadt Exp $	*/
d496 15
a510 3
		    bcmp((caddr_t)ea->arp_sha, LLADDR(sdl), sdl->sdl_alen))
			log(LOG_INFO, "arp info overwritten for %s by %s\n",
			    inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
@


1.12
log
@more \n in log()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.11 1997/08/01 03:53:01 flipk Exp $	*/
d802 1
d820 4
a823 2
		p++; len--;
		if (len) db_printf(",");
d827 1
d840 2
a841 4
	db_printf("  flags=0x%x,refcnt=%d,metric=%d\n",
			  ifa->ifa_flags,
			  ifa->ifa_refcnt,
			  ifa->ifa_metric);
d843 1
d854 1
a854 1
			  la->la_rt, la->la_hold, la->la_asked);
d856 1
d871 1
a871 2
			  rt->rt_flags, rt->rt_refcnt,
			  rt->rt_use, rt->rt_expire);
d888 1
a888 2
	db_printf(" gwroute=%p llinfo=%p\n",
			  rt->rt_gwroute, rt->rt_llinfo);
a889 1

d892 1
@


1.11
log
@when family is AF_UNSPEC,
ether_shost fields no longer get set for us.
initialize them ourselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.10 1997/07/24 22:59:35 deraadt Exp $	*/
d208 1
a208 1
			log(LOG_DEBUG, "arp_rtrequest: bad gateway value");
d345 1
a345 1
		log(LOG_DEBUG, "arpresolve: can't allocate llinfo");
@


1.10
log
@do not ignore IFF_NOARP
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.9 1997/07/21 07:52:05 deraadt Exp $	*/
d298 2
d541 2
d742 2
@


1.9
log
@make this compile until niklas fixes the boo-boo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.8 1997/02/11 22:23:14 kstailey Exp $	*/
d357 3
@


1.8
log
@IPF 1.3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.c,v 1.6 1996/05/10 12:31:19 deraadt Exp $	*/
d113 2
@


1.7
log
@When sending an ARP request, use the interface address for the route, rather
than the first address assigned.  This gives slightly different behaviour in
the presence of aliases.  From Bill Fenner, via Pete Bentley.
@
text
@@


1.6
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ether.c,v 1.4 1996/03/03 22:30:24 niklas Exp $	*/
/*	$NetBSD: if_ether.c,v 1.30 1996/05/07 02:40:46 thorpej Exp $	*/
a263 11
 * Broadcast an ARP packet, asking who has addr on interface ac.
 */
void
arpwhohas(ac, addr)
	register struct arpcom *ac;
	register struct in_addr *addr;
{
	arprequest(ac, &ac->ac_ipaddr.s_addr, &addr->s_addr, ac->ac_enaddr);
}

/*
d379 4
a382 1
				arpwhohas(ac, &(SIN(dst)->sin_addr));
a608 1
	ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;
d610 4
a613 1
	arpwhohas(ac, &ac->ac_ipaddr);
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: if_ether.c,v 1.29 1996/03/30 21:53:19 christos Exp $	*/
d871 1
a871 3
		db_printf("(%s%d)",
				  rt->rt_ifp->if_name,
				  rt->rt_ifp->if_unit);
@


1.4
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: if_ether.c,v 1.28 1996/02/13 23:40:59 christos Exp $	*/
d845 1
a845 1
	db_printf("  la_rt=0x%x la_hold=0x%x, la_asked=0x%x\n",
d859 1
a859 1
	db_printf("rtentry=0x%x", rt);
d861 1
a861 1
	db_printf(" flags=0x%x refcnt=%d use=%d expire=%d\n",
d869 1
a869 1
	db_printf(" ifp=0x%lx ", rt->rt_ifp);
d877 1
a877 1
	db_printf(" ifa=0x%lx\n", rt->rt_ifa);
d882 1
a882 1
	db_printf(" gwroute=0x%x llinfo=0x%x\n",
@


1.3
log
@one more inet_ntoa() improvement
@
text
@d1 2
a2 1
/*	$NetBSD: if_ether.c,v 1.27 1995/08/12 23:59:29 mycroft Exp $	*/
d57 1
d106 13
d348 1
a348 1
		if (la = arplookup(SIN(dst)->sin_addr.s_addr, 1, 0))
a634 1
	int op, s;
d668 1
d674 1
a674 1
	int op, s;
d793 4
d892 1
@


1.2
log
@add inet_ntoa() to the kernel. use it to log nicer messages. idea from freebsd
@
text
@d483 2
a484 2
			log(LOG_INFO, "arp info overwritten for %08x by %s\n",
			    ntohl(isaddr.s_addr), ether_sprintf(ea->arp_sha));
@


1.1
log
@Initial revision
@
text
@d468 2
a469 2
		    "arp: ether address is broadcast for IP address %x!\n",
		    ntohl(isaddr.s_addr));
d474 2
a475 2
		   "duplicate IP address %08x sent from ethernet address %s\n",
		   ntohl(isaddr.s_addr), ether_sprintf(ea->arp_sha));
d579 3
a581 1
			log(LOG_DEBUG, "arplookup: unable to enter address for %x\n", ntohl(addr));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
