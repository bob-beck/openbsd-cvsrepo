head	1.164;
access;
symbols
	OPENBSD_6_2:1.164.0.2
	OPENBSD_6_2_BASE:1.164
	OPENBSD_6_1:1.157.0.4
	OPENBSD_6_1_BASE:1.157
	OPENBSD_6_0:1.140.0.2
	OPENBSD_6_0_BASE:1.140
	OPENBSD_5_9:1.138.0.2
	OPENBSD_5_9_BASE:1.138
	OPENBSD_5_8:1.113.0.4
	OPENBSD_5_8_BASE:1.113
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.83.0.4
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.78.0.4
	OPENBSD_5_5_BASE:1.78
	OPENBSD_5_4:1.72.0.2
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.65.0.2
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.60.0.2
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.2
	OPENBSD_5_0:1.55.0.4
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.50.0.6
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.50.0.2
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.47.0.2
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.33.0.4
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.23
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.164
date	2017.08.09.06.21.04;	author florian;	state Exp;
branches;
next	1.163;
commitid	r2tXOFKckYdOQ2Mu;

1.163
date	2017.07.11.12.51.05;	author florian;	state Exp;
branches;
next	1.162;
commitid	iTlWhLM2orYZnz27;

1.162
date	2017.07.08.15.45.11;	author florian;	state Exp;
branches;
next	1.161;
commitid	RViknz9dev8KaVNJ;

1.161
date	2017.06.09.12.56.44;	author mpi;	state Exp;
branches;
next	1.160;
commitid	QXIy2rZA5FPYfFIG;

1.160
date	2017.06.07.13.28.02;	author mpi;	state Exp;
branches;
next	1.159;
commitid	c48G09HN6s8XE6t3;

1.159
date	2017.05.30.08.58.34;	author florian;	state Exp;
branches;
next	1.158;
commitid	VKcNXz6AIzf4YnHs;

1.158
date	2017.05.16.12.24.04;	author mpi;	state Exp;
branches;
next	1.157;
commitid	SAe3SQ48vKH6r5FL;

1.157
date	2017.03.06.08.56.39;	author mpi;	state Exp;
branches;
next	1.156;
commitid	aDXuIkVsOPuafbD0;

1.156
date	2017.03.03.08.01.41;	author mpi;	state Exp;
branches;
next	1.155;
commitid	zZ0XnqENwWjkpAg4;

1.155
date	2017.02.09.15.23.35;	author jca;	state Exp;
branches;
next	1.154;
commitid	1ap8YFU49Zg4mM41;

1.154
date	2016.12.22.13.39.32;	author mpi;	state Exp;
branches;
next	1.153;
commitid	nLPA84mESw8iBVkC;

1.153
date	2016.11.28.14.14.39;	author mpi;	state Exp;
branches;
next	1.152;
commitid	6k4TK07Jp4xe3PKg;

1.152
date	2016.11.28.13.59.51;	author mpi;	state Exp;
branches;
next	1.151;
commitid	gDeAqDskWelvIYpy;

1.151
date	2016.11.21.10.56.26;	author mpi;	state Exp;
branches;
next	1.150;
commitid	XfeOks8bJByON8ZI;

1.150
date	2016.11.21.10.52.08;	author mpi;	state Exp;
branches;
next	1.149;
commitid	KI2xKJXsc9yCGGDD;

1.149
date	2016.11.21.10.42.00;	author mpi;	state Exp;
branches;
next	1.148;
commitid	6iR8EjZ2NOBjuNvN;

1.148
date	2016.10.03.12.33.21;	author mpi;	state Exp;
branches;
next	1.147;
commitid	ymldqUr8o0SRU6R6;

1.147
date	2016.09.30.06.27.21;	author florian;	state Exp;
branches;
next	1.146;
commitid	9A1ettr7SvpaSMsM;

1.146
date	2016.09.26.19.39.24;	author sthen;	state Exp;
branches;
next	1.145;
commitid	UzcRvDWYif0xMSwq;

1.145
date	2016.09.08.09.02.42;	author mpi;	state Exp;
branches;
next	1.144;
commitid	tbomgjKFzM2WRdPj;

1.144
date	2016.09.02.11.51.07;	author florian;	state Exp;
branches;
next	1.143;
commitid	WFAlXusVqsoXg0f1;

1.143
date	2016.09.02.09.31.25;	author florian;	state Exp;
branches;
next	1.142;
commitid	MhBZWdq6rAZJjFcv;

1.142
date	2016.08.25.16.12.16;	author mpi;	state Exp;
branches;
next	1.141;
commitid	4P90WMY4Oz5hxikU;

1.141
date	2016.08.22.10.33.22;	author mpi;	state Exp;
branches;
next	1.140;
commitid	ZsKqEaqTKPu9hWk6;

1.140
date	2016.07.05.10.17.14;	author mpi;	state Exp;
branches;
next	1.139;
commitid	LxUFHuffW7GZZ01f;

1.139
date	2016.05.02.22.15.49;	author jmatthew;	state Exp;
branches;
next	1.138;
commitid	Qe5v796bHPmQNEGf;

1.138
date	2016.01.12.09.37.44;	author mpi;	state Exp;
branches;
next	1.137;
commitid	g2N11SxUeEM22PXv;

1.137
date	2015.12.18.10.55.51;	author tb;	state Exp;
branches;
next	1.136;
commitid	YD52P9wG7KPDwKDg;

1.136
date	2015.12.03.21.57.59;	author mpi;	state Exp;
branches;
next	1.135;
commitid	nmbu8xP0zmz2PPN0;

1.135
date	2015.12.01.21.29.10;	author mpi;	state Exp;
branches;
next	1.134;
commitid	LCAY2CIUVgl8cFm8;

1.134
date	2015.11.24.13.37.16;	author mpi;	state Exp;
branches;
next	1.133;
commitid	djjKhPvMtRdFfuFJ;

1.133
date	2015.11.02.13.54.46;	author sthen;	state Exp;
branches;
next	1.132;
commitid	D6yArAu1twZws4g1;

1.132
date	2015.11.02.07.24.08;	author mpi;	state Exp;
branches;
next	1.131;
commitid	j3heHwF6pc3KZsrO;

1.131
date	2015.10.30.09.39.42;	author bluhm;	state Exp;
branches;
next	1.130;
commitid	7wrRch1SS813fOcY;

1.130
date	2015.10.28.12.14.25;	author florian;	state Exp;
branches;
next	1.129;
commitid	Ajb0hNGeCqGFHjjg;

1.129
date	2015.10.25.21.32.16;	author florian;	state Exp;
branches;
next	1.128;
commitid	IZuAjGv8tKcObH1g;

1.128
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.127;
commitid	G2nTzngqgXpQqcJB;

1.127
date	2015.10.24.16.08.48;	author mpi;	state Exp;
branches;
next	1.126;
commitid	xFxvBxiFybIsZNMc;

1.126
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.125;
commitid	tp9bS9eCrwvRYjyO;

1.125
date	2015.09.18.14.26.22;	author mpi;	state Exp;
branches;
next	1.124;
commitid	hGprk1rxxzKhgpj5;

1.124
date	2015.09.12.20.50.17;	author mpi;	state Exp;
branches;
next	1.123;
commitid	L7FukNYlBzoQuXvw;

1.123
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.122;
commitid	Cr0DVA7exR1t2zXg;

1.122
date	2015.09.10.09.17.16;	author claudio;	state Exp;
branches;
next	1.121;
commitid	Vj0UdP5DLAPSJ0YI;

1.121
date	2015.09.09.15.51.40;	author mpi;	state Exp;
branches;
next	1.120;
commitid	MtXIH0WHmPXVgeDN;

1.120
date	2015.08.24.23.28.27;	author mpi;	state Exp;
branches;
next	1.119;
commitid	P83XIQmNiVyg0aoD;

1.119
date	2015.08.24.23.26.43;	author mpi;	state Exp;
branches;
next	1.118;
commitid	RvboqW7afhR7jBgv;

1.118
date	2015.08.24.22.11.34;	author mpi;	state Exp;
branches;
next	1.117;
commitid	QLnmQaxOCmSULhEv;

1.117
date	2015.08.24.15.58.35;	author mpi;	state Exp;
branches;
next	1.116;
commitid	hOA5qIh5CrYvhG4e;

1.116
date	2015.08.19.13.27.38;	author bluhm;	state Exp;
branches;
next	1.115;
commitid	t09qBDKQRv4jxgp3;

1.115
date	2015.08.18.08.52.25;	author mpi;	state Exp;
branches;
next	1.114;
commitid	uMSOhjeAvqfe36Ju;

1.114
date	2015.08.17.10.57.24;	author mpi;	state Exp;
branches;
next	1.113;
commitid	piv3mqqACFeWYcad;

1.113
date	2015.07.18.15.51.17;	author mpi;	state Exp;
branches;
next	1.112;
commitid	lwQKRpFyNEr7kjoF;

1.112
date	2015.07.18.15.05.32;	author mpi;	state Exp;
branches;
next	1.111;
commitid	8XKIMnE4aOLeVqIl;

1.111
date	2015.07.17.17.18.05;	author florian;	state Exp;
branches;
next	1.110;
commitid	2Bmxu3C7WMQ0wnXE;

1.110
date	2015.07.16.16.12.15;	author mpi;	state Exp;
branches;
next	1.109;
commitid	STtcOm1B3VSMXz2h;

1.109
date	2015.07.16.15.31.35;	author mpi;	state Exp;
branches;
next	1.108;
commitid	syrAtzfOhwI3Ygjb;

1.108
date	2015.07.08.07.56.51;	author mpi;	state Exp;
branches;
next	1.107;
commitid	2410UDx2ojGksNwU;

1.107
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.106;
commitid	h7z8lokZ0dFyuWpg;

1.106
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.105;
commitid	4Ro7ulidQXNcMvmM;

1.105
date	2015.06.04.09.51.15;	author mpi;	state Exp;
branches;
next	1.104;
commitid	70uJrIFCsGHS6OqZ;

1.104
date	2015.05.26.12.19.52;	author mpi;	state Exp;
branches;
next	1.103;
commitid	iiHJitHd0U6t7lGT;

1.103
date	2015.05.15.12.00.57;	author claudio;	state Exp;
branches;
next	1.102;
commitid	Gl6pqKOqk2n9Lwhq;

1.102
date	2015.04.27.14.51.44;	author mpi;	state Exp;
branches;
next	1.101;
commitid	h3YrO0fhNQbIyJUl;

1.101
date	2015.03.25.17.39.33;	author florian;	state Exp;
branches;
next	1.100;
commitid	pQamb99i6SEFuStR;

1.100
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.99;
commitid	p4LJxGKbi0BU2cG6;

1.99
date	2015.03.09.18.09.50;	author mikeb;	state Exp;
branches;
next	1.98;
commitid	u1TN9SiQsaiaOhK5;

1.98
date	2015.02.19.22.24.20;	author bluhm;	state Exp;
branches;
next	1.97;
commitid	RGP3DK5eaZTHUn8b;

1.97
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.96;
commitid	MyKPm9Q3dQu92BiX;

1.96
date	2014.12.22.11.17.20;	author mpi;	state Exp;
branches;
next	1.95;
commitid	oBZ47iouywWzWBZa;

1.95
date	2014.12.22.11.05.53;	author mpi;	state Exp;
branches;
next	1.94;
commitid	ZiNnf658AJiR4Tll;

1.94
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.93;
commitid	cYQY7jiay4SydLhD;

1.93
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.92;
commitid	Vq8oSnWLkf7dyy0N;

1.92
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.91;
commitid	t9FBKDfc4VDxpEy2;

1.91
date	2014.11.20.09.55.57;	author mpi;	state Exp;
branches;
next	1.90;
commitid	StxeqV93bwujMj7n;

1.90
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.89;
commitid	Z1vcFtHO8wRH0yRt;

1.89
date	2014.11.01.21.40.39;	author mpi;	state Exp;
branches;
next	1.88;
commitid	w0MRp28dmfD1ZzO8;

1.88
date	2014.10.07.08.47.28;	author mpi;	state Exp;
branches;
next	1.87;
commitid	YwQD6dPTFjvxMtlw;

1.87
date	2014.09.09.20.33.24;	author dlg;	state Exp;
branches;
next	1.86;
commitid	tQXZvE33slmbX8Sb;

1.86
date	2014.09.08.09.32.04;	author stsp;	state Exp;
branches;
next	1.85;
commitid	Mhy6wt0l9m2wF9uW;

1.85
date	2014.08.26.21.44.29;	author florian;	state Exp;
branches;
next	1.84;
commitid	yPNaXDJAsGXelPnV;

1.84
date	2014.08.25.14.00.34;	author florian;	state Exp;
branches;
next	1.83;
commitid	fUNtd3qRJAn6fam0;

1.83
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches
	1.83.4.1;
next	1.82;
commitid	B4dZSbxas1X1IpXI;

1.82
date	2014.07.11.16.39.06;	author henning;	state Exp;
branches;
next	1.81;
commitid	AGagL83SRBC6d7e7;

1.81
date	2014.07.11.15.03.17;	author blambert;	state Exp;
branches;
next	1.80;
commitid	HGjB9lpJfpqInwIy;

1.80
date	2014.03.27.10.39.23;	author mpi;	state Exp;
branches;
next	1.79;

1.79
date	2014.03.18.10.47.34;	author mpi;	state Exp;
branches;
next	1.78;

1.78
date	2014.01.23.10.16.30;	author mpi;	state Exp;
branches;
next	1.77;

1.77
date	2014.01.13.23.03.52;	author bluhm;	state Exp;
branches;
next	1.76;

1.76
date	2014.01.10.14.29.08;	author tedu;	state Exp;
branches;
next	1.75;

1.75
date	2014.01.07.17.07.46;	author mikeb;	state Exp;
branches;
next	1.74;

1.74
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.73;

1.73
date	2013.10.20.11.03.02;	author phessler;	state Exp;
branches;
next	1.72;

1.72
date	2013.07.01.14.22.20;	author bluhm;	state Exp;
branches;
next	1.71;

1.71
date	2013.07.01.13.06.24;	author bluhm;	state Exp;
branches;
next	1.70;

1.70
date	2013.05.31.15.04.25;	author bluhm;	state Exp;
branches;
next	1.69;

1.69
date	2013.03.25.14.40.57;	author mpi;	state Exp;
branches;
next	1.68;

1.68
date	2013.03.11.14.08.04;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2013.03.07.09.40.19;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.65;

1.65
date	2012.09.26.14.53.23;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2012.09.07.09.55.18;	author stsp;	state Exp;
branches;
next	1.63;

1.63
date	2012.09.04.10.03.16;	author stsp;	state Exp;
branches;
next	1.62;

1.62
date	2012.08.28.20.32.02;	author sperreault;	state Exp;
branches;
next	1.61;

1.61
date	2012.08.21.19.50.39;	author bluhm;	state Exp;
branches;
next	1.60;

1.60
date	2012.07.14.17.23.16;	author sperreault;	state Exp;
branches;
next	1.59;

1.59
date	2012.05.18.10.50.07;	author mikeb;	state Exp;
branches;
next	1.58;

1.58
date	2012.01.03.23.41.51;	author bluhm;	state Exp;
branches;
next	1.57;

1.57
date	2011.12.27.17.20.04;	author bluhm;	state Exp;
branches;
next	1.56;

1.56
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.55;

1.55
date	2011.02.24.01.25.17;	author stsp;	state Exp;
branches;
next	1.54;

1.54
date	2010.09.24.14.10.52;	author jsing;	state Exp;
branches;
next	1.53;

1.53
date	2010.06.28.18.50.37;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.06.14.12.10;	author stsp;	state Exp;
branches;
next	1.51;

1.51
date	2010.02.08.11.56.09;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2009.01.30.11.56.59;	author rainer;	state Exp;
branches;
next	1.49;

1.49
date	2009.01.30.10.47.46;	author mcbride;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.17.05.43.15;	author chl;	state Exp;
branches;
next	1.47;

1.47
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.11.06.30.36;	author mcbride;	state Exp;
branches;
next	1.45;

1.45
date	2008.05.11.08.13.02;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.01.16.39.30;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.28.23.07.13;	author pyr;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.28.22.17.21;	author pyr;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.15.03.07.44;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.16.15.41.19;	author pascoe;	state Exp;
branches;
next	1.38;

1.38
date	2006.04.22.19.43.07;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.22.14.37.45;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.29.02.59.42;	author jolan;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.27.16.22.45;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.11.17.03.22.31;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.28.08.43.03;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.10.03.30.21;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.26.21.43.32;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.24.07.55.12;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.24.07.47.54;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.15.15.00.43;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.14.14.24.44;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.13.02.25.08;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.30.23.30.08;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.09.14.38.39;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.09.00.59.29;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.08.21.51.08;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.08.21.22.41;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.08.21.22.03;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.08.00.06.58;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.07.03.06.15;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.06.09.06.43.38;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.04.06.22.57;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.16.16.19.56;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.07.11.43.55;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.13.04.12.40;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.02.09.44.28;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.28.11.55.23;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.01.08.05.49.41;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.23;	author itojun;	state Exp;
branches;
next	;

1.4.2.1
date	2000.03.02.07.04.46;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2000.03.24.09.09.40;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.05.14.22.40.20;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.07.04.10.55.27;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.4.2.9;

1.4.2.9
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;

1.83.4.1
date	2014.09.08.14.42.40;	author stsp;	state Exp;
branches;
next	;
commitid	t6ucjkx1gHuQkC9X;


desc
@@


1.164
log
@We are no longer processing router advertisements in the
kernel.
OK mpi
@
text
@/*	$OpenBSD: nd6_rtr.c,v 1.163 2017/07/11 12:51:05 florian Exp $	*/
/*	$KAME: nd6_rtr.c,v 1.97 2001/02/07 11:09:13 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_var.h>
#include <net/route.h>
#include <net/rtable.h>

#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/nd6.h>
#include <netinet/icmp6.h>

int rt6_deleteroute(struct rtentry *, void *, unsigned int);

/*
 * Receive Router Solicitation Message - just for routers.
 * Router solicitation/advertisement is mostly managed by userland program
 * (rtadvd) so here we have no function like nd6_ra_output().
 *
 * Based on RFC 2461
 */
void
nd6_rs_input(struct mbuf *m, int off, int icmp6len)
{
	struct ifnet *ifp;
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct nd_router_solicit *nd_rs;
	struct in6_addr saddr6 = ip6->ip6_src;
#if 0
	struct in6_addr daddr6 = ip6->ip6_dst;
#endif
	char *lladdr = NULL;
	int lladdrlen = 0;
#if 0
	struct sockaddr_dl *sdl = NULL;
	struct llinfo_nd6 *ln = NULL;
	struct rtentry *rt = NULL;
	int is_newentry;
#endif
	union nd_opts ndopts;
	char src[INET6_ADDRSTRLEN], dst[INET6_ADDRSTRLEN];

	/* If I'm not a router, ignore it. XXX - too restrictive? */
	if (!ip6_forwarding)
		goto freeit;

	/* Sanity checks */
	if (ip6->ip6_hlim != 255) {
		nd6log((LOG_ERR,
		    "nd6_rs_input: invalid hlim (%d) from %s to %s on %u\n",
		    ip6->ip6_hlim,
		    inet_ntop(AF_INET6, &ip6->ip6_src, src, sizeof(src)),
		    inet_ntop(AF_INET6, &ip6->ip6_dst, dst, sizeof(dst)),
		    m->m_pkthdr.ph_ifidx));
		goto bad;
	}

	/*
	 * Don't update the neighbor cache, if src = ::.
	 * This indicates that the src has no IP address assigned yet.
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&saddr6))
		goto freeit;

	IP6_EXTHDR_GET(nd_rs, struct nd_router_solicit *, m, off, icmp6len);
	if (nd_rs == NULL) {
		icmp6stat_inc(icp6s_tooshort);
		return;
	}

	icmp6len -= sizeof(*nd_rs);
	nd6_option_init(nd_rs + 1, icmp6len, &ndopts);
	if (nd6_options(&ndopts) < 0) {
		nd6log((LOG_INFO,
		    "nd6_rs_input: invalid ND option, ignored\n"));
		/* nd6_options have incremented stats */
		goto freeit;
	}

	if (ndopts.nd_opts_src_lladdr) {
		lladdr = (char *)(ndopts.nd_opts_src_lladdr + 1);
		lladdrlen = ndopts.nd_opts_src_lladdr->nd_opt_len << 3;
	}

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		goto freeit;

	if (lladdr && ((ifp->if_addrlen + 2 + 7) & ~7) != lladdrlen) {
		nd6log((LOG_INFO,
		    "nd6_rs_input: lladdrlen mismatch for %s "
		    "(if %d, RS packet %d)\n",
		    inet_ntop(AF_INET6, &saddr6, src, sizeof(src)),
		    ifp->if_addrlen, lladdrlen - 2));
		if_put(ifp);
		goto bad;
	}

	nd6_cache_lladdr(ifp, &saddr6, lladdr, lladdrlen, ND_ROUTER_SOLICIT, 0);
	if_put(ifp);

 freeit:
	m_freem(m);
	return;

 bad:
	icmp6stat_inc(icp6s_badrs);
	m_freem(m);
}

/*
 * Receive Router Advertisement Message.
 *
 * Based on RFC 2461
 */
void
nd6_ra_input(struct mbuf *m, int off, int icmp6len)
{
	struct ifnet *ifp;
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct nd_router_advert *nd_ra;
	struct in6_addr saddr6 = ip6->ip6_src;
	char *lladdr = NULL;
	int lladdrlen = 0;
	union nd_opts ndopts;
	char src[INET6_ADDRSTRLEN], dst[INET6_ADDRSTRLEN];

	/* Sanity checks */
	if (ip6->ip6_hlim != 255) {
		nd6log((LOG_ERR,
		    "nd6_ra_input: invalid hlim (%d) from %s to %s on %u\n",
		    ip6->ip6_hlim,
		    inet_ntop(AF_INET6, &ip6->ip6_src, src, sizeof(src)),
		    inet_ntop(AF_INET6, &ip6->ip6_dst, dst, sizeof(dst)),
		    m->m_pkthdr.ph_ifidx));
		goto bad;
	}

	if (!IN6_IS_ADDR_LINKLOCAL(&saddr6)) {
		nd6log((LOG_ERR,
		    "nd6_ra_input: src %s is not link-local\n",
		    inet_ntop(AF_INET6, &saddr6, src, sizeof(src))));
		goto bad;
	}

	IP6_EXTHDR_GET(nd_ra, struct nd_router_advert *, m, off, icmp6len);
	if (nd_ra == NULL) {
		icmp6stat_inc(icp6s_tooshort);
		return;
	}

	icmp6len -= sizeof(*nd_ra);
	nd6_option_init(nd_ra + 1, icmp6len, &ndopts);
	if (nd6_options(&ndopts) < 0) {
		nd6log((LOG_INFO,
		    "nd6_ra_input: invalid ND option, ignored\n"));
		/* nd6_options have incremented stats */
		goto freeit;
	}

	if (ndopts.nd_opts_src_lladdr) {
		lladdr = (char *)(ndopts.nd_opts_src_lladdr + 1);
		lladdrlen = ndopts.nd_opts_src_lladdr->nd_opt_len << 3;
	}

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		goto freeit;

	if (lladdr && ((ifp->if_addrlen + 2 + 7) & ~7) != lladdrlen) {
		nd6log((LOG_INFO,
		    "nd6_ra_input: lladdrlen mismatch for %s "
		    "(if %d, RA packet %d)\n",
		    inet_ntop(AF_INET6, &saddr6, src, sizeof(src)),
		    ifp->if_addrlen, lladdrlen - 2));
		if_put(ifp);
		goto bad;
	}

	nd6_cache_lladdr(ifp, &saddr6, lladdr, lladdrlen, ND_ROUTER_ADVERT, 0);
	if_put(ifp);

 freeit:
	m_freem(m);
	return;

 bad:
	icmp6stat_inc(icp6s_badra);
	m_freem(m);
}

/*
 * Delete all the routing table entries that use the specified gateway.
 * XXX: this function causes search through all entries of routing table, so
 * it shouldn't be called when acting as a router.
 */
void
rt6_flush(struct in6_addr *gateway, struct ifnet *ifp)
{
	NET_ASSERT_LOCKED();

	/* We'll care only link-local addresses */
	if (!IN6_IS_ADDR_LINKLOCAL(gateway))
		return;

	/* XXX: hack for KAME's link-local address kludge */
	gateway->s6_addr16[1] = htons(ifp->if_index);

	rtable_walk(ifp->if_rdomain, AF_INET6, rt6_deleteroute, gateway);
}

int
rt6_deleteroute(struct rtentry *rt, void *arg, unsigned int id)
{
	struct ifnet *ifp;
	struct rt_addrinfo info;
	struct in6_addr *gate = (struct in6_addr *)arg;
	struct sockaddr_in6 sa_mask;
	int error = 0;

	if (rt->rt_gateway == NULL || rt->rt_gateway->sa_family != AF_INET6)
		return (0);

	if (!IN6_ARE_ADDR_EQUAL(gate, &satosin6(rt->rt_gateway)->sin6_addr))
		return (0);

	/*
	 * Do not delete a static route.
	 * XXX: this seems to be a bit ad-hoc. Should we consider the
	 * 'cloned' bit instead?
	 */
	if ((rt->rt_flags & RTF_STATIC) != 0)
		return (0);

	/*
	 * We delete only host route. This means, in particular, we don't
	 * delete default route.
	 */
	if ((rt->rt_flags & RTF_HOST) == 0)
		return (0);

	ifp = if_get(rt->rt_ifidx);
	if (ifp != NULL) {
		bzero(&info, sizeof(info));
		info.rti_flags =  rt->rt_flags;
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] = rt_plen2mask(rt, &sa_mask);
		error = rtrequest_delete(&info, RTP_ANY, ifp, NULL, id);
	}
	if_put(ifp);

	return (error != 0 ? error : EAGAIN);
}
@


1.163
log
@Purging is at last at hand. Day of Doom is here. All that is evil
shall all be cleansed.

Remove sending of router solicitations and processing of router
advertisements from the kernel. It's handled by slaacd(8) these days.

Input & OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.162 2017/07/08 15:45:11 florian Exp $	*/
a60 2

extern int nd6_recalc_reachtm_interval;
@


1.162
log
@Enable slaacd on the installer and temporarily neuter router
advertisement processing and solicitation sending like we already did
for the non-install kernels.

Next step will be to tedu all that code from the kernel.

OK rpe@@ for the installer bits
move forward deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.161 2017/06/09 12:56:44 mpi Exp $	*/
a59 16
int rtpref(struct nd_defrouter *);
struct nd_defrouter *defrtrlist_update(struct nd_defrouter *);
struct in6_ifaddr *in6_ifadd(struct nd_prefix *, int);
struct nd_pfxrouter *pfxrtr_lookup(struct nd_prefix *, struct nd_defrouter *);
void pfxrtr_add(struct nd_prefix *, struct nd_defrouter *);
void pfxrtr_del(struct nd_pfxrouter *);
struct nd_pfxrouter *find_pfxlist_reachable_router(struct nd_prefix *);
void defrouter_delreq(struct nd_defrouter *);
void purge_detached(struct ifnet *);
int nd6_prefix_onlink(struct nd_prefix *);
int nd6_prefix_offlink(struct nd_prefix *);
void in6_init_address_ltimes(struct nd_prefix *, struct in6_addrlifetime *);
int prelist_update(struct nd_prefix *, struct nd_defrouter *, struct mbuf *);
int nd6_prelist_add(struct nd_prefix *, struct nd_defrouter *,
	struct nd_prefix **);
void defrouter_addreq(struct nd_defrouter *);
a61 7
void nd6_addr_add(void *);

void nd6_rs_output_timo(void *);
void nd6_rs_output_set_timo(int);
void nd6_rs_output(struct ifnet *, struct in6_ifaddr *);
void nd6_rs_dev_state(void *);

a63 14
#define ND6_RS_OUTPUT_INTERVAL		60
#define ND6_RS_OUTPUT_QUICK_INTERVAL	1

struct timeout	nd6_rs_output_timer;
int		nd6_rs_output_timeout = ND6_RS_OUTPUT_INTERVAL;
int		nd6_rs_timeout_count = 0;

void
nd6_rs_init(void)
{
	timeout_set_proc(&nd6_rs_output_timer, nd6_rs_output_timo, NULL);
}


a159 167
void
nd6_rs_output(struct ifnet* ifp, struct in6_ifaddr *ia6)
{
	struct mbuf *m;
	struct ip6_hdr *ip6;
	struct nd_router_solicit *rs;
	struct ip6_moptions im6o;
	caddr_t mac;
	int icmp6len, maxlen;

	NET_ASSERT_LOCKED();

	KASSERT(ia6 != NULL);
	KASSERT(ifp->if_flags & IFF_RUNNING);
	KASSERT(ifp->if_xflags & IFXF_AUTOCONF6);
	KASSERT(!(ia6->ia6_flags & IN6_IFF_TENTATIVE));

	maxlen = sizeof(*ip6) + sizeof(*rs);
	maxlen += (sizeof(struct nd_opt_hdr) + ifp->if_addrlen + 7) & ~7;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m && max_linkhdr + maxlen >= MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			m = NULL;
		}
	}
	if (m == NULL)
		return;

	m->m_pkthdr.ph_ifidx = 0;
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;
	m->m_flags |= M_MCAST;
	m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;

	im6o.im6o_ifidx = ifp->if_index;
	im6o.im6o_hlim = 255;
	im6o.im6o_loop = 0;

	icmp6len = sizeof(*rs);
	m->m_pkthdr.len = m->m_len = sizeof(*ip6) + icmp6len;
	m->m_data += max_linkhdr;	/* or MH_ALIGN() equivalent? */

	/* fill neighbor solicitation packet */
	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_flow = 0;
	ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc |= IPV6_VERSION;
	/* ip6->ip6_plen will be set later */
	ip6->ip6_nxt = IPPROTO_ICMPV6;
	ip6->ip6_hlim = 255;

	ip6->ip6_dst = in6addr_linklocal_allrouters;

	ip6->ip6_src = ia6->ia_addr.sin6_addr;

	rs = (struct nd_router_solicit *)(ip6 + 1);
	rs->nd_rs_type = ND_ROUTER_SOLICIT;
	rs->nd_rs_code = 0;
	rs->nd_rs_cksum = 0;
	rs->nd_rs_reserved = 0;

	if ((mac = nd6_ifptomac(ifp))) {
		int optlen = sizeof(struct nd_opt_hdr) + ifp->if_addrlen;
		struct nd_opt_hdr *nd_opt = (struct nd_opt_hdr *)(rs + 1);
		/* 8 byte alignments... */
		optlen = (optlen + 7) & ~7;

		m->m_pkthdr.len += optlen;
		m->m_len += optlen;
		icmp6len += optlen;
		bzero((caddr_t)nd_opt, optlen);
		nd_opt->nd_opt_type = ND_OPT_SOURCE_LINKADDR;
		nd_opt->nd_opt_len = optlen >> 3;
		bcopy(mac, (caddr_t)(nd_opt + 1), ifp->if_addrlen);
	}

	ip6->ip6_plen = htons((u_short)icmp6len);

	ip6_output(m, NULL, NULL, 0, &im6o, NULL);

	icmp6stat_inc(icp6s_outhist + ND_ROUTER_SOLICIT);
}

void
nd6_rs_output_set_timo(int timeout)
{
	return;
	nd6_rs_output_timeout = timeout;
	timeout_add_sec(&nd6_rs_output_timer, nd6_rs_output_timeout);
}

void
nd6_rs_output_timo(void *ignored_arg)
{
	struct ifnet *ifp;
	struct in6_ifaddr *ia6;
	int s;

	if (nd6_rs_timeout_count == 0)
		return;

	if (nd6_rs_output_timeout < ND6_RS_OUTPUT_INTERVAL)
		/* exponential backoff if running quick timeouts */
		nd6_rs_output_timeout *= 2;
	if (nd6_rs_output_timeout > ND6_RS_OUTPUT_INTERVAL)
		nd6_rs_output_timeout = ND6_RS_OUTPUT_INTERVAL;

	NET_LOCK(s);
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ISSET(ifp->if_flags, IFF_RUNNING) &&
		    ISSET(ifp->if_xflags, IFXF_AUTOCONF6)) {
			ia6 = in6ifa_ifpforlinklocal(ifp, IN6_IFF_TENTATIVE);
			if (ia6 != NULL)
				nd6_rs_output(ifp, ia6);
		}
	}
	NET_UNLOCK(s);
	nd6_rs_output_set_timo(nd6_rs_output_timeout);
}

void
nd6_rs_attach(struct ifnet *ifp)
{
	if (!ISSET(ifp->if_xflags, IFXF_AUTOCONF6)) {
		/*
		 * We are being called from net/if.c, autoconf is not yet
		 * enabled on the interface.
		 */
		nd6_rs_timeout_count++;
		RS_LHCOOKIE(ifp) = hook_establish(ifp->if_linkstatehooks, 1,
		    nd6_rs_dev_state, ifp);
	}

	/*
	 * (re)send solicitation regardless if we are enabling autoconf
	 * for the first time or if the link comes up
	 */
	nd6_rs_output_set_timo(ND6_RS_OUTPUT_QUICK_INTERVAL);
}

void
nd6_rs_detach(struct ifnet *ifp)
{
	if (ISSET(ifp->if_xflags, IFXF_AUTOCONF6)) {
		nd6_rs_timeout_count--;
		hook_disestablish(ifp->if_linkstatehooks, RS_LHCOOKIE(ifp));
	}

	if (nd6_rs_timeout_count == 0)
		timeout_del(&nd6_rs_output_timer);
}

void
nd6_rs_dev_state(void *arg)
{
	struct ifnet *ifp;

	ifp = (struct ifnet *) arg;

	if (LINK_STATE_IS_UP(ifp->if_link_state) &&
	    ifp->if_flags & IFF_RUNNING)
		/* start quick timer, will exponentially back off */
		nd6_rs_output_set_timo(ND6_RS_OUTPUT_QUICK_INTERVAL);
}

a168 1
	struct nd_ifinfo *ndi;
d172 2
a174 1
	struct nd_defrouter *dr;
d177 1
a177 18
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		goto freeit;

	goto freeit;

	/* We accept RAs only if inet6 autoconf is enabled  */
	if (!(ifp->if_xflags & IFXF_AUTOCONF6))
		goto freeit;

	ndi = ND_IFINFO(ifp);
	if (!(ndi->flags & ND6_IFF_ACCEPT_RTADV))
		goto freeit;

	if (nd6_rs_output_timeout != ND6_RS_OUTPUT_INTERVAL)
		/* we saw a RA, stop quick timer */
		nd6_rs_output_set_timo(ND6_RS_OUTPUT_INTERVAL);

d180 1
a180 1
		    "nd6_ra_input: invalid hlim (%d) from %s to %s on %s\n",
d184 1
a184 1
		    ifp->if_xname));
a197 1
		if_put(ifp);
a209 114
    {
	struct nd_defrouter dr0;
	u_int32_t advreachable = nd_ra->nd_ra_reachable;

	memset(&dr0, 0, sizeof(dr0));
	dr0.rtaddr = saddr6;
	dr0.flags  = nd_ra->nd_ra_flags_reserved;
	dr0.rtlifetime = ntohs(nd_ra->nd_ra_router_lifetime);
	dr0.expire = time_uptime + dr0.rtlifetime;
	dr0.ifp = ifp;
	/* unspecified or not? (RFC 2461 6.3.4) */
	if (advreachable) {
		advreachable = ntohl(advreachable);
		if (advreachable <= MAX_REACHABLE_TIME &&
		    ndi->basereachable != advreachable) {
			ndi->basereachable = advreachable;
			ndi->reachable = ND_COMPUTE_RTIME(ndi->basereachable);
			ndi->recalctm = nd6_recalc_reachtm_interval; /* reset */
		}
	}
	if (nd_ra->nd_ra_retransmit)
		ndi->retrans = ntohl(nd_ra->nd_ra_retransmit);
	if (nd_ra->nd_ra_curhoplimit) {
		/*
		 * Ignore it.  The router doesn't know the diameter of
		 * the Internet better than this source code.
		 */
	}
	dr = defrtrlist_update(&dr0);
    }

	/*
	 * prefix
	 */
	if (ndopts.nd_opts_pi) {
		struct nd_opt_hdr *pt;
		struct nd_opt_prefix_info *pi = NULL;
		struct nd_prefix pr;

		for (pt = (struct nd_opt_hdr *)ndopts.nd_opts_pi;
		     pt <= (struct nd_opt_hdr *)ndopts.nd_opts_pi_end;
		     pt = (struct nd_opt_hdr *)((caddr_t)pt +
						(pt->nd_opt_len << 3))) {
			if (pt->nd_opt_type != ND_OPT_PREFIX_INFORMATION)
				continue;
			pi = (struct nd_opt_prefix_info *)pt;

			if (pi->nd_opt_pi_len != 4) {
				nd6log((LOG_INFO,
				    "nd6_ra_input: invalid option "
				    "len %d for prefix information option, "
				    "ignored\n", pi->nd_opt_pi_len));
				continue;
			}

			if (128 < pi->nd_opt_pi_prefix_len) {
				nd6log((LOG_INFO,
				    "nd6_ra_input: invalid prefix "
				    "len %d for prefix information option, "
				    "ignored\n", pi->nd_opt_pi_prefix_len));
				continue;
			}

			if (IN6_IS_ADDR_MULTICAST(&pi->nd_opt_pi_prefix)
			 || IN6_IS_ADDR_LINKLOCAL(&pi->nd_opt_pi_prefix)) {
				nd6log((LOG_INFO,
				    "nd6_ra_input: invalid prefix "
				    "%s, ignored\n",
				    inet_ntop(AF_INET6, &pi->nd_opt_pi_prefix,
					src, sizeof(src))));
				continue;
			}

			/* aggregatable unicast address, rfc2374 */
			if ((pi->nd_opt_pi_prefix.s6_addr8[0] & 0xe0) == 0x20
			 && pi->nd_opt_pi_prefix_len != 64) {
				nd6log((LOG_INFO,
				    "nd6_ra_input: invalid prefixlen "
				    "%d for rfc2374 prefix %s, ignored\n",
				    pi->nd_opt_pi_prefix_len,
				    inet_ntop(AF_INET6, &pi->nd_opt_pi_prefix,
					src, sizeof(src))));
				continue;
			}

			bzero(&pr, sizeof(pr));
			pr.ndpr_prefix.sin6_family = AF_INET6;
			pr.ndpr_prefix.sin6_len = sizeof(pr.ndpr_prefix);
			pr.ndpr_prefix.sin6_addr = pi->nd_opt_pi_prefix;
			pr.ndpr_ifp = ifp;

			pr.ndpr_raf_onlink = (pi->nd_opt_pi_flags_reserved &
			     ND_OPT_PI_FLAG_ONLINK) ? 1 : 0;
			pr.ndpr_raf_auto = (pi->nd_opt_pi_flags_reserved &
			     ND_OPT_PI_FLAG_AUTO) ? 1 : 0;
			pr.ndpr_plen = pi->nd_opt_pi_prefix_len;
			pr.ndpr_vltime = ntohl(pi->nd_opt_pi_valid_time);
			pr.ndpr_pltime = ntohl(pi->nd_opt_pi_preferred_time);
			pr.ndpr_lastupdate = time_uptime;

			if (in6_init_prefix_ltimes(&pr))
				continue; /* prefix lifetime init failed */

			(void)prelist_update(&pr, dr, m);
		}
	}

	/*
	 * Source link layer address
	 */
    {
	char *lladdr = NULL;
	int lladdrlen = 0;

d215 4
d225 1
d230 1
a230 8

	/*
	 * Installing a link-layer address might change the state of the
	 * router's neighbor cache, which might also affect our on-link
	 * detection of advertised prefixes.
	 */
	pfxlist_onlink_check();
    }
a232 1
	if_put(ifp);
a237 1
	if_put(ifp);
a238 1435
}

/*
 * default router list processing sub routines
 */
void
defrouter_addreq(struct nd_defrouter *new)
{
	struct rt_addrinfo info;
	struct sockaddr_in6 def, mask, gate;
	struct rtentry *rt;
	int error;

	memset(&def, 0, sizeof(def));
	memset(&mask, 0, sizeof(mask));
	memset(&gate, 0, sizeof(gate)); /* for safety */
	memset(&info, 0, sizeof(info));

	def.sin6_len = mask.sin6_len = gate.sin6_len =
	    sizeof(struct sockaddr_in6);
	def.sin6_family = mask.sin6_family = gate.sin6_family = AF_INET6;
	gate.sin6_addr = new->rtaddr;
	gate.sin6_scope_id = 0;	/* XXX */

	info.rti_ifa = NULL;
	info.rti_flags = RTF_GATEWAY;
	info.rti_info[RTAX_DST] = sin6tosa(&def);
	info.rti_info[RTAX_GATEWAY] = sin6tosa(&gate);
	info.rti_info[RTAX_NETMASK] = sin6tosa(&mask);

	error = rtrequest(RTM_ADD, &info, RTP_DEFAULT, &rt,
	    new->ifp->if_rdomain);
	if (error == 0) {
		KERNEL_LOCK();
		rtm_send(rt, RTM_ADD, new->ifp->if_rdomain);
		KERNEL_UNLOCK();
		rtfree(rt);
		new->installed = 1;
	}
}

struct nd_defrouter *
defrouter_lookup(struct in6_addr *addr, unsigned int ifidx)
{
	struct nd_defrouter *dr;

	TAILQ_FOREACH(dr, &nd_defrouter, dr_entry)
		if (dr->ifp->if_index == ifidx &&
		    IN6_ARE_ADDR_EQUAL(addr, &dr->rtaddr))
			return (dr);

	return (NULL);		/* search failed */
}

void
defrtrlist_del(struct nd_defrouter *dr)
{
	struct nd_defrouter *deldr = NULL;
	struct in6_ifextra *ext = dr->ifp->if_afdata[AF_INET6];
	struct nd_prefix *pr;

	/*
	 * Flush all the routing table entries that use the router
	 * as a next hop.
	 */
	/* XXX: better condition? */
	if (!ip6_forwarding)
		rt6_flush(&dr->rtaddr, dr->ifp);

	if (dr->installed) {
		deldr = dr;
		defrouter_delreq(dr);
	}
	TAILQ_REMOVE(&nd_defrouter, dr, dr_entry);

	/*
	 * Also delete all the pointers to the router in each prefix lists.
	 */
	LIST_FOREACH(pr, &nd_prefix, ndpr_entry) {
		struct nd_pfxrouter *pfxrtr;
		if ((pfxrtr = pfxrtr_lookup(pr, dr)) != NULL)
			pfxrtr_del(pfxrtr);
	}
	pfxlist_onlink_check();

	/*
	 * If the router is the primary one, choose a new one.
	 * Note that defrouter_select() will remove the current gateway
	 * from the routing table.
	 */
	if (deldr)
		defrouter_select();

	ext->ndefrouters--;
	if (ext->ndefrouters < 0) {
		log(LOG_WARNING, "%s: negative count on %s\n", __func__,
		    dr->ifp->if_xname);
	}

	free(dr, M_IP6NDP, sizeof(*dr));
}

/*
 * Remove the default route for a given router.
 * This is just a subroutine function for defrouter_select(), and should
 * not be called from anywhere else.
 */
void
defrouter_delreq(struct nd_defrouter *dr)
{
	struct rt_addrinfo info;
	struct sockaddr_in6 def, mask, gw;
	struct rtentry *rt;
	int error;

#ifdef DIAGNOSTIC
	if (!dr)
		panic("dr == NULL in defrouter_delreq");
#endif

	memset(&info, 0, sizeof(info));
	memset(&def, 0, sizeof(def));
	memset(&mask, 0, sizeof(mask));
	memset(&gw, 0, sizeof(gw));	/* for safety */

	def.sin6_len = mask.sin6_len = gw.sin6_len =
	    sizeof(struct sockaddr_in6);
	def.sin6_family = mask.sin6_family = gw.sin6_family = AF_INET6;
	gw.sin6_addr = dr->rtaddr;
	gw.sin6_scope_id = 0;	/* XXX */

	info.rti_flags = RTF_GATEWAY;
	info.rti_info[RTAX_DST] = sin6tosa(&def);
	info.rti_info[RTAX_GATEWAY] = sin6tosa(&gw);
	info.rti_info[RTAX_NETMASK] = sin6tosa(&mask);

	error = rtrequest_delete(&info, RTP_DEFAULT, dr->ifp, &rt,
	    dr->ifp->if_rdomain);
	if (error == 0) {
		KERNEL_LOCK();
		rtm_send(rt, RTM_DELETE, dr->ifp->if_rdomain);
		KERNEL_UNLOCK();
		rtfree(rt);
	}

	dr->installed = 0;
}

/*
 * remove all default routes from default router list
 */
void
defrouter_reset(void)
{
	struct nd_defrouter *dr;

	TAILQ_FOREACH(dr, &nd_defrouter, dr_entry)
		defrouter_delreq(dr);

	/*
	 * XXX should we also nuke any default routers in the kernel, by
	 * going through them by rtalloc()?
	 */
}

/*
 * Default Router Selection according to Section 6.3.6 of RFC 2461 and
 * draft-ietf-ipngwg-router-selection:
 * 1) Routers that are reachable or probably reachable should be preferred.
 *    If we have more than one (probably) reachable router, prefer ones
 *    with the highest router preference.
 * 2) When no routers on the list are known to be reachable or
 *    probably reachable, routers SHOULD be selected in a round-robin
 *    fashion, regardless of router preference values.
 * 3) If the Default Router List is empty, assume that all
 *    destinations are on-link.
 *
 * We assume nd_defrouter is sorted by router preference value.
 * Since the code below covers both with and without router preference cases,
 * we do not need to classify the cases by ifdef.
 *
 * At this moment, we do not try to install more than one default router,
 * even when the multipath routing is available, because we're not sure about
 * the benefits for stub hosts comparing to the risk of making the code
 * complicated and the possibility of introducing bugs.
 */
void
defrouter_select(void)
{
	struct nd_defrouter *dr, *selected_dr = NULL, *installed_dr = NULL;
	struct rtentry *rt = NULL;
	struct llinfo_nd6 *ln = NULL;

	/*
	 * Let's handle easy case (3) first:
	 * If default router list is empty, there's nothing to be done.
	 */
	if (TAILQ_EMPTY(&nd_defrouter)) {
		return;
	}

	/*
	 * Search for a (probably) reachable router from the list.
	 * We just pick up the first reachable one (if any), assuming that
	 * the ordering rule of the list described in defrtrlist_update().
	 */
	TAILQ_FOREACH(dr, &nd_defrouter, dr_entry) {
		if (!(dr->ifp->if_xflags & IFXF_AUTOCONF6))
			continue;
		if (!selected_dr) {
			rt = nd6_lookup(&dr->rtaddr, 0, dr->ifp,
			    dr->ifp->if_rdomain);
			if ((rt != NULL) &&
			    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
			    ND6_IS_LLINFO_PROBREACH(ln)) {
				selected_dr = dr;
			}
			rtfree(rt);
		}

		if (dr->installed && !installed_dr)
			installed_dr = dr;
		else if (dr->installed && installed_dr) {
			/* this should not happen.  warn for diagnosis. */
			log(LOG_ERR, "defrouter_select: more than one router"
			    " is installed\n");
		}
	}
	/*
	 * If none of the default routers was found to be reachable,
	 * round-robin the list regardless of preference.
	 * Otherwise, if we have an installed router, check if the selected
	 * (reachable) router should really be preferred to the installed one.
	 * We only prefer the new router when the old one is not reachable
	 * or when the new one has a really higher preference value.
	 */
	if (!selected_dr) {
		if (!installed_dr || !TAILQ_NEXT(installed_dr, dr_entry))
			selected_dr = TAILQ_FIRST(&nd_defrouter);
		else
			selected_dr = TAILQ_NEXT(installed_dr, dr_entry);
	} else if (installed_dr) {
		rt = nd6_lookup(&installed_dr->rtaddr, 0, installed_dr->ifp,
		    installed_dr->ifp->if_rdomain);
		if ((rt != NULL) && (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
		    ND6_IS_LLINFO_PROBREACH(ln) &&
		    rtpref(selected_dr) <= rtpref(installed_dr)) {
			selected_dr = installed_dr;
		}
		rtfree(rt);
	}

	/*
	 * If the selected router is different than the installed one,
	 * remove the installed router and install the selected one.
	 * Note that the selected router is never NULL here.
	 */
	if (installed_dr != selected_dr) {
		if (installed_dr)
			defrouter_delreq(installed_dr);
		defrouter_addreq(selected_dr);
	}
}

/*
 * for default router selection
 * regards router-preference field as a 2-bit signed integer
 */
int
rtpref(struct nd_defrouter *dr)
{
#ifdef RTPREF
	switch (dr->flags & ND_RA_FLAG_RTPREF_MASK) {
	case ND_RA_FLAG_RTPREF_HIGH:
		return RTPREF_HIGH;
	case ND_RA_FLAG_RTPREF_MEDIUM:
	case ND_RA_FLAG_RTPREF_RSV:
		return RTPREF_MEDIUM;
	case ND_RA_FLAG_RTPREF_LOW:
		return RTPREF_LOW;
	default:
		/*
		 * This case should never happen.  If it did, it would mean a
		 * serious bug of kernel internal.  We thus always bark here.
		 * Or, can we even panic?
		 */
		log(LOG_ERR, "rtpref: impossible RA flag %x", dr->flags);
		return RTPREF_INVALID;
	}
	/* NOTREACHED */
#else
	return 0;
#endif
}

struct nd_defrouter *
defrtrlist_update(struct nd_defrouter *new)
{
	struct nd_defrouter *dr, *n;
	struct in6_ifextra *ext = new->ifp->if_afdata[AF_INET6];

	NET_ASSERT_LOCKED();

	if ((dr = defrouter_lookup(&new->rtaddr, new->ifp->if_index)) != NULL) {
		/* entry exists */
		if (new->rtlifetime == 0) {
			defrtrlist_del(dr);
			dr = NULL;
		} else {
			int oldpref = rtpref(dr);

			/* override */
			dr->flags = new->flags; /* xxx flag check */
			dr->rtlifetime = new->rtlifetime;
			dr->expire = new->expire;

			if (!dr->installed)
				defrouter_select();

			/*
			 * If the preference does not change, there's no need
			 * to sort the entries.
			 */
			if (rtpref(new) == oldpref) {
				return (dr);
			}

			/*
			 * preferred router may be changed, so relocate
			 * this router.
			 * XXX: calling TAILQ_REMOVE directly is a bad manner.
			 * However, since defrtrlist_del() has many side
			 * effects, we intentionally do so here.
			 * defrouter_select() below will handle routing
			 * changes later.
			 */
			TAILQ_REMOVE(&nd_defrouter, dr, dr_entry);
			n = dr;
			goto insert;
		}
		return (dr);
	}

	/* entry does not exist */
	if (new->rtlifetime == 0) {
		/* flush all possible redirects */
		if (new->ifp->if_xflags & IFXF_AUTOCONF6)
			rt6_flush(&new->rtaddr, new->ifp);
		return (NULL);
	}

	if (ip6_maxifdefrouters >= 0 &&
	    ext->ndefrouters >= ip6_maxifdefrouters) {
		return (NULL);
	}

	n = malloc(sizeof(*n), M_IP6NDP, M_NOWAIT | M_ZERO);
	if (n == NULL) {
		return (NULL);
	}
	*n = *new;

insert:
	/*
	 * Insert the new router in the Default Router List;
	 * The Default Router List should be in the descending order
	 * of router-preference.  Routers with the same preference are
	 * sorted in the arriving time order.
	 */

	/* insert at the end of the group */
	TAILQ_FOREACH(dr, &nd_defrouter, dr_entry)
		if (rtpref(n) > rtpref(dr))
			break;
	if (dr)
		TAILQ_INSERT_BEFORE(dr, n, dr_entry);
	else
		TAILQ_INSERT_TAIL(&nd_defrouter, n, dr_entry);

	defrouter_select();

	ext->ndefrouters++;

	return (n);
}

struct nd_pfxrouter *
pfxrtr_lookup(struct nd_prefix *pr, struct nd_defrouter *dr)
{
	struct nd_pfxrouter *search;

	LIST_FOREACH(search, &pr->ndpr_advrtrs, pfr_entry) {
		if (search->router == dr)
			break;
	}

	return (search);
}

void
pfxrtr_add(struct nd_prefix *pr, struct nd_defrouter *dr)
{
	struct nd_pfxrouter *new;

	new = malloc(sizeof(*new), M_IP6NDP, M_NOWAIT | M_ZERO);
	if (new == NULL)
		return;
	new->router = dr;

	LIST_INSERT_HEAD(&pr->ndpr_advrtrs, new, pfr_entry);

	pfxlist_onlink_check();
}

void
pfxrtr_del(struct nd_pfxrouter *pfr)
{
	LIST_REMOVE(pfr, pfr_entry);
	free(pfr, M_IP6NDP, sizeof(*pfr));
}

struct nd_prefix *
nd6_prefix_lookup(struct nd_prefix *pr)
{
	struct nd_prefix *search;

	LIST_FOREACH(search, &nd_prefix, ndpr_entry) {
		if (pr->ndpr_ifp == search->ndpr_ifp &&
		    pr->ndpr_plen == search->ndpr_plen &&
		    in6_are_prefix_equal(&pr->ndpr_prefix.sin6_addr,
		    &search->ndpr_prefix.sin6_addr, pr->ndpr_plen)) {
			break;
		}
	}

	return (search);
}

void
purge_detached(struct ifnet *ifp)
{
	struct nd_prefix *pr, *pr_next;
	struct in6_ifaddr *ia6;
	struct ifaddr *ifa, *ifa_next;

	NET_ASSERT_LOCKED();

	LIST_FOREACH_SAFE(pr, &nd_prefix, ndpr_entry, pr_next) {
		/*
		 * This function is called when we need to make more room for
		 * new prefixes rather than keeping old, possibly stale ones.
		 * Detached prefixes would be a good candidate; if all routers
		 * that advertised the prefix expired, the prefix is also
		 * probably stale.
		 */
		if (pr->ndpr_ifp != ifp ||
		    IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr) ||
		    ((pr->ndpr_stateflags & NDPRF_DETACHED) == 0 &&
		    !LIST_EMPTY(&pr->ndpr_advrtrs)))
			continue;

		TAILQ_FOREACH_SAFE(ifa, &ifp->if_addrlist, ifa_list, ifa_next) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;
			ia6 = ifatoia6(ifa);
			if ((ia6->ia6_flags & IN6_IFF_AUTOCONF) ==
			    IN6_IFF_AUTOCONF && ia6->ia6_ndpr == pr) {
				in6_purgeaddr(ifa);
			}
		}
	}
}

int
nd6_prelist_add(struct nd_prefix *pr, struct nd_defrouter *dr,
    struct nd_prefix **newp)
{
	struct nd_prefix *new = NULL;
	struct in6_ifextra *ext = pr->ndpr_ifp->if_afdata[AF_INET6];
	int i;

	NET_ASSERT_LOCKED();

	if (ip6_maxifprefixes >= 0) {
		if (ext->nprefixes >= ip6_maxifprefixes / 2) {
			purge_detached(pr->ndpr_ifp);
		}
		if (ext->nprefixes >= ip6_maxifprefixes)
			return(ENOMEM);
	}

	new = malloc(sizeof(*new), M_IP6NDP, M_NOWAIT | M_ZERO);
	if (new == NULL)
		return ENOMEM;
	*new = *pr;
	if (newp != NULL)
		*newp = new;

	/* initialization */
	LIST_INIT(&new->ndpr_advrtrs);
	in6_prefixlen2mask(&new->ndpr_mask, new->ndpr_plen);
	/* make prefix in the canonical form */
	for (i = 0; i < 4; i++)
		new->ndpr_prefix.sin6_addr.s6_addr32[i] &=
		    new->ndpr_mask.s6_addr32[i];

	task_set(&new->ndpr_task, nd6_addr_add, new);

	/* link ndpr_entry to nd_prefix list */
	LIST_INSERT_HEAD(&nd_prefix, new, ndpr_entry);

	/* ND_OPT_PI_FLAG_ONLINK processing */
	if (new->ndpr_raf_onlink) {
		char addr[INET6_ADDRSTRLEN];
		int e;

		if ((e = nd6_prefix_onlink(new)) != 0) {
			nd6log((LOG_ERR, "%s: failed to make the prefix %s/%d"
			    " on-link on %s (errno=%d)\n", __func__,
			    inet_ntop(AF_INET6, &pr->ndpr_prefix.sin6_addr,
				addr, sizeof(addr)),
			    pr->ndpr_plen, pr->ndpr_ifp->if_xname, e));
			/* proceed anyway. XXX: is it correct? */
		}
	}

	if (dr)
		pfxrtr_add(new, dr);

	ext->nprefixes++;

	return 0;
}

void
prelist_remove(struct nd_prefix *pr)
{
	struct nd_pfxrouter *pfr, *next;
	struct in6_ifextra *ext = pr->ndpr_ifp->if_afdata[AF_INET6];
	int e;

	NET_ASSERT_LOCKED();

	/* make sure to invalidate the prefix until it is really freed. */
	pr->ndpr_vltime = 0;
	pr->ndpr_pltime = 0;

	if ((pr->ndpr_stateflags & NDPRF_ONLINK) != 0 &&
	    (e = nd6_prefix_offlink(pr)) != 0) {
		char addr[INET6_ADDRSTRLEN];
		nd6log((LOG_ERR, "%s: failed to make %s/%d offlink "
		    "on %s, errno=%d\n", __func__,
		    inet_ntop(AF_INET6, &pr->ndpr_prefix.sin6_addr,
			addr, sizeof(addr)),
		    pr->ndpr_plen, pr->ndpr_ifp->if_xname, e));
		/* what should we do? */
	}

	if (pr->ndpr_refcnt > 0)
		return;		/* notice here? */

	/* unlink ndpr_entry from nd_prefix list */
	LIST_REMOVE(pr, ndpr_entry);

	/* free list of routers that adversed the prefix */
	LIST_FOREACH_SAFE(pfr, &pr->ndpr_advrtrs, pfr_entry, next)
		free(pfr, M_IP6NDP, sizeof(*pfr));

	ext->nprefixes--;
	if (ext->nprefixes < 0) {
		log(LOG_WARNING, "%s: negative count on %s\n", __func__,
		    pr->ndpr_ifp->if_xname);
	}

	free(pr, M_IP6NDP, sizeof(*pr));

	pfxlist_onlink_check();
}

/*
 * dr - may be NULL
 */

int
prelist_update(struct nd_prefix *new, struct nd_defrouter *dr, struct mbuf *m)
{
	struct in6_ifaddr *ia6_match = NULL;
	struct ifaddr *ifa;
	struct ifnet *ifp = new->ndpr_ifp;
	struct nd_prefix *pr;
	int error = 0;
	int tempaddr_preferred = 0, autoconf = 0, statique = 0;
	int auth;
	struct in6_addrlifetime lt6_tmp;
	char addr[INET6_ADDRSTRLEN];

	NET_ASSERT_LOCKED();

	auth = 0;
	if (m) {
		/*
		 * Authenticity for NA consists authentication for
		 * both IP header and IP datagrams, doesn't it ?
		 */
		auth = (m->m_flags & M_AUTH);
	}

	if ((pr = nd6_prefix_lookup(new)) != NULL) {
		/*
		 * nd6_prefix_lookup() ensures that pr and new have the same
		 * prefix on a same interface.
		 */

		/*
		 * Update prefix information.  Note that the on-link (L) bit
		 * and the autonomous (A) bit should NOT be changed from 1
		 * to 0.
		 */
		if (new->ndpr_raf_onlink == 1)
			pr->ndpr_raf_onlink = 1;
		if (new->ndpr_raf_auto == 1)
			pr->ndpr_raf_auto = 1;
		if (new->ndpr_raf_onlink) {
			pr->ndpr_vltime = new->ndpr_vltime;
			pr->ndpr_pltime = new->ndpr_pltime;
			pr->ndpr_preferred = new->ndpr_preferred;
			pr->ndpr_expire = new->ndpr_expire;
			pr->ndpr_lastupdate = new->ndpr_lastupdate;
		}

		if (new->ndpr_raf_onlink &&
		    (pr->ndpr_stateflags & NDPRF_ONLINK) == 0) {
			int e;

			if ((e = nd6_prefix_onlink(pr)) != 0) {
				nd6log((LOG_ERR, "%s: failed to make the prefix"
				    " %s/%d on-link on %s (errno=%d)\n",
				    __func__, inet_ntop(AF_INET6,
					&pr->ndpr_prefix.sin6_addr,
					addr, sizeof(addr)),
				    pr->ndpr_plen, pr->ndpr_ifp->if_xname, e));
				/* proceed anyway. XXX: is it correct? */
			}
		}

		if (dr && pfxrtr_lookup(pr, dr) == NULL)
			pfxrtr_add(pr, dr);
	} else {
		struct nd_prefix *newpr = NULL;

		if (new->ndpr_vltime == 0)
			goto end;
		if (new->ndpr_raf_onlink == 0 && new->ndpr_raf_auto == 0)
			goto end;

		error = nd6_prelist_add(new, dr, &newpr);
		if (error != 0 || newpr == NULL) {
			nd6log((LOG_NOTICE, "%s: nd6_prelist_add failed for"
			    " %s/%d on %s errno=%d, returnpr=%p\n", __func__,
			    inet_ntop(AF_INET6, &new->ndpr_prefix.sin6_addr,
				addr, sizeof(addr)),
			    new->ndpr_plen, new->ndpr_ifp->if_xname,
			    error, newpr));
			goto end; /* we should just give up in this case. */
		}

		pr = newpr;
	}

	/*
	 * Address autoconfiguration based on Section 5.5.3 of RFC 2462.
	 * Note that pr must be non NULL at this point.
	 */

	/* 5.5.3 (a). Ignore the prefix without the A bit set. */
	if (!new->ndpr_raf_auto)
		goto end;

	/*
	 * 5.5.3 (b). the link-local prefix should have been ignored in
	 * nd6_ra_input.
	 */

	/*
	 * 5.5.3 (c). Consistency check on lifetimes: pltime <= vltime.
	 * This should have been done in nd6_ra_input.
	 */

	/*
	 * 5.5.3 (d). If the prefix advertised does not match the prefix of an
	 * address already in the list, and the Valid Lifetime is not 0,
	 * form an address.  Note that even a manually configured address
	 * should reject autoconfiguration of a new address.
	 */
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		struct in6_ifaddr *ia6;
		int ifa_plen;
		u_int32_t storedlifetime;

		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;

		ia6 = ifatoia6(ifa);

		/*
		 * Spec is not clear here, but I believe we should concentrate
		 * on unicast (i.e. not anycast) addresses.
		 * XXX: other ia6_flags? detached or duplicated?
		 */
		if ((ia6->ia6_flags & IN6_IFF_ANYCAST) != 0)
			continue;

		ifa_plen = in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL);
		if (ifa_plen != new->ndpr_plen ||
		    !in6_are_prefix_equal(&ia6->ia_addr.sin6_addr,
		    &new->ndpr_prefix.sin6_addr, ifa_plen))
			continue;

		if (ia6_match == NULL) /* remember the first one */
			ia6_match = ia6;

		if ((ia6->ia6_flags & IN6_IFF_AUTOCONF) == 0) {
			statique = 1;
			continue;
		}

		/*
		 * An already autoconfigured address matched.  Now that we
		 * are sure there is at least one matched address, we can
		 * proceed to 5.5.3. (e): update the lifetimes according to the
		 * "two hours" rule and the privacy extension.
		 */
#define TWOHOUR		(120*60)
		/*
		 * RFC2462 introduces the notion of StoredLifetime to the
		 * "two hours" rule as follows:
		 *   the Lifetime associated with the previously autoconfigured
		 *   address.
		 * Our interpretation of this definition is "the remaining
		 * lifetime to expiration at the evaluation time".  One might
		 * be wondering if this interpretation is really conform to the
		 * RFC, because the text can read that "Lifetimes" are never
		 * decreased, and our definition of the "storedlifetime" below
		 * essentially reduces the "Valid Lifetime" advertised in the
		 * previous RA.  But, this is due to the wording of the text,
		 * and our interpretation is the same as an author's intention.
		 * See the discussion in the IETF ipngwg ML in August 2001,
		 * with the Subject "StoredLifetime in RFC 2462".
		 */
		lt6_tmp = ia6->ia6_lifetime;

		/* RFC 4941 temporary addresses (privacy extension). */
		if (ia6->ia6_flags & IN6_IFF_PRIVACY) {
			/* Do we still have a non-deprecated address? */
			if ((ia6->ia6_flags & IN6_IFF_DEPRECATED) == 0)
				tempaddr_preferred = 1;
			/* Don't extend lifetime for temporary addresses. */
			if (new->ndpr_vltime >= lt6_tmp.ia6t_vltime)
				continue;
			if (new->ndpr_pltime >= lt6_tmp.ia6t_pltime)
				continue;
		} else if ((ia6->ia6_flags & IN6_IFF_DEPRECATED) == 0)
			/* We have a regular SLAAC address. */
			autoconf = 1;

		if (lt6_tmp.ia6t_vltime == ND6_INFINITE_LIFETIME)
			storedlifetime = ND6_INFINITE_LIFETIME;
		else if (time_uptime - ia6->ia6_updatetime >
			 lt6_tmp.ia6t_vltime) {
			/*
			 * The case of "invalid" address.  We should usually
			 * not see this case.
			 */
			storedlifetime = 0;
		} else
			storedlifetime = lt6_tmp.ia6t_vltime -
				(time_uptime - ia6->ia6_updatetime);
		if (TWOHOUR < new->ndpr_vltime ||
		    storedlifetime < new->ndpr_vltime) {
			lt6_tmp.ia6t_vltime = new->ndpr_vltime;
		} else if (storedlifetime <= TWOHOUR
#if 0
			   /*
			    * This condition is logically redundant, so we just
			    * omit it.
			    * See IPng 6712, 6717, and 6721.
			    */
			   && new->ndpr_vltime <= storedlifetime
#endif
			) {
			if (auth) {
				lt6_tmp.ia6t_vltime = new->ndpr_vltime;
			}
		} else {
			/*
			 * new->ndpr_vltime <= TWOHOUR &&
			 * TWOHOUR < storedlifetime
			 */
			lt6_tmp.ia6t_vltime = TWOHOUR;
		}

		/* The 2 hour rule is not imposed for preferred lifetime. */
		lt6_tmp.ia6t_pltime = new->ndpr_pltime;

		in6_init_address_ltimes(pr, &lt6_tmp);

		ia6->ia6_lifetime = lt6_tmp;
		ia6->ia6_updatetime = time_uptime;
	}

	if ((!autoconf || ((ifp->if_xflags & IFXF_INET6_NOPRIVACY) == 0 &&
	     !tempaddr_preferred)) &&
	    new->ndpr_vltime != 0 && new->ndpr_pltime != 0 &&
	    !((ifp->if_xflags & IFXF_INET6_NOPRIVACY) && statique)) {
		/*
		 * There is no SLAAC address and/or there is no preferred RFC
		 * 4941 temporary address. And prefix lifetimes are non-zero.
		 * And there is no static address in the same prefix.
		 * Create new addresses in process context.
		 * Increment prefix refcount to ensure the prefix is not
		 * removed before the task is done.
		 */
		pr->ndpr_refcnt++;
		if (task_add(systq, &pr->ndpr_task) == 0)
			pr->ndpr_refcnt--;
	}

 end:
	return error;
}

void
nd6_addr_add(void *prptr)
{
	struct nd_prefix *pr = (struct nd_prefix *)prptr;
	struct in6_ifaddr *ia6;
	struct ifaddr *ifa;
	int ifa_plen, autoconf, privacy, s;

	NET_LOCK(s);

	autoconf = 1;
	privacy = (pr->ndpr_ifp->if_xflags & IFXF_INET6_NOPRIVACY) == 0;

	/*
	 * Check again if a non-deprecated address has already
	 * been autoconfigured for this prefix.
	 */
	TAILQ_FOREACH(ifa, &pr->ndpr_ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;

		ia6 = ifatoia6(ifa);

		/*
		 * Spec is not clear here, but I believe we should concentrate
		 * on unicast (i.e. not anycast) addresses.
		 * XXX: other ia6_flags? detached or duplicated?
		 */
		if ((ia6->ia6_flags & IN6_IFF_ANYCAST) != 0)
			continue;

		if ((ia6->ia6_flags & IN6_IFF_AUTOCONF) == 0)
			continue;

		if ((ia6->ia6_flags & IN6_IFF_DEPRECATED) != 0)
			continue;

		ifa_plen = in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL);
		if (ifa_plen == pr->ndpr_plen &&
		    in6_are_prefix_equal(&ia6->ia_addr.sin6_addr,
		    &pr->ndpr_prefix.sin6_addr, ifa_plen)) {
			if ((ia6->ia6_flags & IN6_IFF_PRIVACY) == 0)
				autoconf = 0;
			else
				privacy = 0;
			if (!autoconf && !privacy)
				break;
		}
	}

	if (autoconf && (ia6 = in6_ifadd(pr, 0)) != NULL) {
		ia6->ia6_ndpr = pr;
		pr->ndpr_refcnt++;
	} else
		autoconf = 0;

	if (privacy && (ia6 = in6_ifadd(pr, 1)) != NULL) {
		ia6->ia6_ndpr = pr;
		pr->ndpr_refcnt++;
	} else
		privacy = 0;

	/*
	 * A newly added address might affect the status
	 * of other addresses, so we check and update it.
	 * XXX: what if address duplication happens?
	 */
	if (autoconf || privacy)
		pfxlist_onlink_check();

	/* Decrement prefix refcount now that the task is done. */
	if (--pr->ndpr_refcnt == 0)
		prelist_remove(pr);

	NET_UNLOCK(s);
}

/*
 * A supplement function used in the on-link detection below;
 * detect if a given prefix has a (probably) reachable advertising router.
 * XXX: lengthy function name...
 */
struct nd_pfxrouter *
find_pfxlist_reachable_router(struct nd_prefix *pr)
{
	struct nd_pfxrouter *pfxrtr;
	struct rtentry *rt = NULL;
	struct llinfo_nd6 *ln;

	LIST_FOREACH(pfxrtr, &pr->ndpr_advrtrs, pfr_entry) {
		if ((rt = nd6_lookup(&pfxrtr->router->rtaddr, 0,
		    pfxrtr->router->ifp, pfxrtr->router->ifp->if_rdomain)) &&
		    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
		    ND6_IS_LLINFO_PROBREACH(ln)) {
			rtfree(rt);
			break;	/* found */
		}
		rtfree(rt);
	}

	return (pfxrtr);
}

/*
 * Check if each prefix in the prefix list has at least one available router
 * that advertised the prefix (a router is "available" if its neighbor cache
 * entry is reachable or probably reachable).
 * If the check fails, the prefix may be off-link, because, for example,
 * we have moved from the network but the lifetime of the prefix has not
 * expired yet.  So we should not use the prefix if there is another prefix
 * that has an available router.
 * But, if there is no prefix that has an available router, we still regards
 * all the prefixes as on-link.  This is because we can't tell if all the
 * routers are simply dead or if we really moved from the network and there
 * is no router around us.
 */
void
pfxlist_onlink_check(void)
{
	struct ifnet *ifp;
	struct ifaddr *ifa;
	struct nd_prefix *pr;
	struct in6_ifaddr *ia6, *pia6 = NULL;
	char addr[INET6_ADDRSTRLEN];

	/*
	 * Check if there is a prefix that has a reachable advertising
	 * router.
	 */
	LIST_FOREACH(pr, &nd_prefix, ndpr_entry) {
		if (pr->ndpr_raf_onlink && find_pfxlist_reachable_router(pr))
			break;
	}
	if (pr != NULL || !TAILQ_EMPTY(&nd_defrouter)) {
		/*
		 * There is at least one prefix that has a reachable router,
		 * or at least a router which probably does not advertise
		 * any prefixes.  The latter would be the case when we move
		 * to a new link where we have a router that does not provide
		 * prefixes and we configure an address by hand.
		 * Detach prefixes which have no reachable advertising
		 * router, and attach other prefixes.
		 */
		LIST_FOREACH(pr, &nd_prefix, ndpr_entry) {
			/* XXX: a link-local prefix should never be detached */
			if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
				continue;

			/*
			 * we aren't interested in prefixes without the L bit
			 * set.
			 */
			if (pr->ndpr_raf_onlink == 0)
				continue;

			if ((pr->ndpr_stateflags & NDPRF_DETACHED) == 0 &&
			    find_pfxlist_reachable_router(pr) == NULL)
				pr->ndpr_stateflags |= NDPRF_DETACHED;
			if ((pr->ndpr_stateflags & NDPRF_DETACHED) != 0 &&
			    find_pfxlist_reachable_router(pr) != 0)
				pr->ndpr_stateflags &= ~NDPRF_DETACHED;
		}
	} else {
		/* there is no prefix that has a reachable router */
		LIST_FOREACH(pr, &nd_prefix, ndpr_entry) {
			if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
				continue;

			if (pr->ndpr_raf_onlink == 0)
				continue;

			if ((pr->ndpr_stateflags & NDPRF_DETACHED) != 0)
				pr->ndpr_stateflags &= ~NDPRF_DETACHED;
		}
	}

	/*
	 * Remove each interface route associated with a (just) detached
	 * prefix, and reinstall the interface route for a (just) attached
	 * prefix.  Note that all attempt of reinstallation does not
	 * necessarily success, when a same prefix is shared among multiple
	 * interfaces.  Such cases will be handled in nd6_prefix_onlink,
	 * so we don't have to care about them.
	 */
	LIST_FOREACH(pr, &nd_prefix, ndpr_entry) {
		int e;

		if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
			continue;

		if (pr->ndpr_raf_onlink == 0)
			continue;

		if ((pr->ndpr_stateflags & NDPRF_DETACHED) != 0 &&
		    (pr->ndpr_stateflags & NDPRF_ONLINK) != 0) {
			if ((e = nd6_prefix_offlink(pr)) != 0) {
				nd6log((LOG_ERR, "%s: failed to make %s/%d "
				    "offlink, errno=%d\n", __func__,
				    inet_ntop(AF_INET6,
					&pr->ndpr_prefix.sin6_addr,
					addr, sizeof(addr)),
				    pr->ndpr_plen, e));
			}
		}
		if ((pr->ndpr_stateflags & NDPRF_DETACHED) == 0 &&
		    (pr->ndpr_stateflags & NDPRF_ONLINK) == 0 &&
		    pr->ndpr_raf_onlink) {
			if ((e = nd6_prefix_onlink(pr)) != 0) {
				nd6log((LOG_ERR, "%s: failed to make %s/%d "
				    "offlink, errno=%d\n", __func__,
				    inet_ntop(AF_INET6,
					&pr->ndpr_prefix.sin6_addr,
					addr, sizeof(addr)),
				    pr->ndpr_plen, e));
			}
		}
	}

	/*
	 * Changes on the prefix status might affect address status as well.
	 * Make sure that all addresses derived from an attached prefix are
	 * attached, and that all addresses derived from a detached prefix are
	 * detached.  Note, however, that a manually configured address should
	 * always be attached.
	 * The precise detection logic is same as the one for prefixes.
	 */
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;

			ia6 = ifatoia6(ifa);
			if ((ia6->ia6_flags & IN6_IFF_AUTOCONF) == 0)
				continue;

			/*
			 * This can happen when we first configure the address
			 * (i.e. the address exists, but the prefix does not).
			 * XXX: complicated relationships...
			 */
			if (ia6->ia6_ndpr == NULL)
				continue;

			if (find_pfxlist_reachable_router(ia6->ia6_ndpr)) {
				pia6 = ia6;
				break;
			}
		}

		if (pia6 != NULL)
			break;
	}

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;

			ia6 = ifatoia6(ifa);
			if ((ia6->ia6_flags & IN6_IFF_AUTOCONF) == 0)
				continue;

			if (pia6 != NULL) {
				/* XXX: see above. */
				if (ia6->ia6_ndpr == NULL)
					continue;

				if (find_pfxlist_reachable_router(ia6->ia6_ndpr))
					ia6->ia6_flags &= ~IN6_IFF_DETACHED;
				else
					ia6->ia6_flags |= IN6_IFF_DETACHED;
			} else {
				ia6->ia6_flags &= ~IN6_IFF_DETACHED;
			}
		}
	}
}

int
nd6_prefix_onlink(struct nd_prefix *pr)
{
	struct ifnet *ifp = pr->ndpr_ifp;
	struct ifaddr *ifa;
	struct nd_prefix *opr;
	char addr[INET6_ADDRSTRLEN];
	int error, rtflags = 0;

	/* sanity check */
	if ((pr->ndpr_stateflags & NDPRF_ONLINK) != 0)
		return (EEXIST);

	/*
	 * Add the interface route associated with the prefix.  Before
	 * installing the route, check if there's the same prefix on another
	 * interface, and the prefix has already installed the interface route.
	 * Although such a configuration is expected to be rare, we explicitly
	 * allow it.
	 */
	LIST_FOREACH(opr, &nd_prefix, ndpr_entry) {
		if (opr == pr)
			continue;

		if ((opr->ndpr_stateflags & NDPRF_ONLINK) == 0)
			continue;

		if (opr->ndpr_plen == pr->ndpr_plen &&
		    in6_are_prefix_equal(&pr->ndpr_prefix.sin6_addr,
		    &opr->ndpr_prefix.sin6_addr, pr->ndpr_plen))
			return (0);
	}

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (ifatoia6(ifa)->ia6_ndpr == pr)
			break;
	}
	if (ifa == NULL) {
		/*
		 * This can still happen, when, for example, we receive an RA
		 * containing a prefix with the L bit set and the A bit clear,
		 * after removing all IPv6 addresses on the receiving
		 * interface.  This should, of course, be rare though.
		 */
		nd6log((LOG_NOTICE,
		    "nd6_prefix_onlink: failed to find any ifaddr"
		    " to add route for a prefix(%s/%d) on %s\n",
		    inet_ntop(AF_INET6,	&pr->ndpr_prefix.sin6_addr,
			addr, sizeof(addr)),
		    pr->ndpr_plen, ifp->if_xname));
		return (0);
	}

	if (nd6_need_cache(ifp))
		rtflags = RTF_CLONING | RTF_CONNECTED;

	error = rt_ifa_add(ifa, rtflags, sin6tosa(&pr->ndpr_prefix));
	if (error == 0)
		pr->ndpr_stateflags |= NDPRF_ONLINK;

	return (error);
}

int
nd6_prefix_offlink(struct nd_prefix *pr)
{
	struct ifnet *ifp = pr->ndpr_ifp;
	struct ifaddr *ifa;
	struct nd_prefix *opr;
	char addr[INET6_ADDRSTRLEN];
	int error, rtflags = 0;

	/* sanity check */
	if ((pr->ndpr_stateflags & NDPRF_ONLINK) == 0) {
		nd6log((LOG_ERR,
		    "nd6_prefix_offlink: %s/%d is already off-link\n",
		    inet_ntop(AF_INET6, &pr->ndpr_prefix.sin6_addr,
			addr, sizeof(addr)),
		    pr->ndpr_plen));
		return (EEXIST);
	}

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (ifatoia6(ifa)->ia6_ndpr == pr)
			break;
	}
	if (ifa == NULL)
		return (EINVAL);

	if (nd6_need_cache(ifp))
		rtflags = RTF_CLONING | RTF_CONNECTED;

	error = rt_ifa_del(ifa, rtflags, sin6tosa(&pr->ndpr_prefix));
	if (error == 0) {
		pr->ndpr_stateflags &= ~NDPRF_ONLINK;

		/*
		 * There might be the same prefix on another interface,
		 * the prefix which could not be on-link just because we have
		 * the interface route (see comments in nd6_prefix_onlink).
		 * If there's one, try to make the prefix on-link on the
		 * interface.
		 */
		LIST_FOREACH(opr, &nd_prefix, ndpr_entry) {
			if (opr == pr)
				continue;

			if ((opr->ndpr_stateflags & NDPRF_ONLINK) != 0)
				continue;

			/*
			 * KAME specific: detached prefixes should not be
			 * on-link.
			 */
			if ((opr->ndpr_stateflags & NDPRF_DETACHED) != 0)
				continue;

			if (opr->ndpr_plen == pr->ndpr_plen &&
			    in6_are_prefix_equal(&pr->ndpr_prefix.sin6_addr,
			    &opr->ndpr_prefix.sin6_addr, pr->ndpr_plen)) {
				int e;

				if ((e = nd6_prefix_onlink(opr)) != 0) {
					nd6log((LOG_ERR,
					    "nd6_prefix_offlink: failed to "
					    "recover a prefix %s/%d from %s "
					    "to %s (errno = %d)\n",
					    inet_ntop(AF_INET6,
						&pr->ndpr_prefix.sin6_addr,
						addr, sizeof(addr)),
					    opr->ndpr_plen, ifp->if_xname,
					    opr->ndpr_ifp->if_xname, e));
				}
			}
		}
	}

	return (error);
}

struct in6_ifaddr *
in6_ifadd(struct nd_prefix *pr, int privacy)
{
	struct ifnet *ifp = pr->ndpr_ifp;
	struct ifaddr *ifa;
	struct in6_aliasreq ifra;
	struct in6_ifaddr *ia6;
	int error, plen0;
	struct in6_addr mask, rand_ifid;
	int prefixlen = pr->ndpr_plen;

	NET_ASSERT_LOCKED();

	in6_prefixlen2mask(&mask, prefixlen);

	/*
	 * find a link-local address (will be interface ID).
	 * Is it really mandatory? Theoretically, a global or a site-local
	 * address can be configured without a link-local address, if we
	 * have a unique interface identifier...
	 *
	 * it is not mandatory to have a link-local address, we can generate
	 * interface identifier on the fly.  we do this because:
	 * (1) it should be the easiest way to find interface identifier.
	 * (2) RFC2462 5.4 suggesting the use of the same interface identifier
	 * for multiple addresses on a single interface, and possible shortcut
	 * of DAD.  we omitted DAD for this reason in the past.
	 * (3) a user can prevent autoconfiguration of global address
	 * by removing link-local address by hand (this is partly because we
	 * don't have other way to control the use of IPv6 on a interface.
	 * this has been our design choice - cf. NRL's "ifconfig auto").
	 * (4) it is easier to manage when an interface has addresses
	 * with the same interface identifier, than to have multiple addresses
	 * with different interface identifiers.
	 */
	ifa = &in6ifa_ifpforlinklocal(ifp, 0)->ia_ifa; /* 0 is OK? */
	if (ifa)
		ia6 = ifatoia6(ifa);
	else
		return NULL;

	/* prefixlen + ifidlen must be equal to 128 */
	plen0 = in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL);
	if (prefixlen != plen0) {
		nd6log((LOG_INFO, "%s: wrong prefixlen for %s "
		    "(prefix=%d ifid=%d)\n", __func__,
		    ifp->if_xname, prefixlen, 128 - plen0));
		return NULL;
	}

	/* make ifaddr */
	bzero(&ifra, sizeof(ifra));
	strncpy(ifra.ifra_name, ifp->if_xname, sizeof(ifra.ifra_name));
	ifra.ifra_addr.sin6_family = AF_INET6;
	ifra.ifra_addr.sin6_len = sizeof(struct sockaddr_in6);
	/* prefix */
	bcopy(&pr->ndpr_prefix.sin6_addr, &ifra.ifra_addr.sin6_addr,
	    sizeof(ifra.ifra_addr.sin6_addr));
	ifra.ifra_addr.sin6_addr.s6_addr32[0] &= mask.s6_addr32[0];
	ifra.ifra_addr.sin6_addr.s6_addr32[1] &= mask.s6_addr32[1];
	ifra.ifra_addr.sin6_addr.s6_addr32[2] &= mask.s6_addr32[2];
	ifra.ifra_addr.sin6_addr.s6_addr32[3] &= mask.s6_addr32[3];

	/* interface ID */
	if (privacy) {
		ifra.ifra_flags |= IN6_IFF_PRIVACY;
		bcopy(&pr->ndpr_prefix.sin6_addr, &rand_ifid,
		    sizeof(rand_ifid));
		in6_get_rand_ifid(ifp, &rand_ifid);
		ifra.ifra_addr.sin6_addr.s6_addr32[0] |=
		    (rand_ifid.s6_addr32[0] & ~mask.s6_addr32[0]);
		ifra.ifra_addr.sin6_addr.s6_addr32[1] |=
		    (rand_ifid.s6_addr32[1] & ~mask.s6_addr32[1]);
		ifra.ifra_addr.sin6_addr.s6_addr32[2] |=
		    (rand_ifid.s6_addr32[2] & ~mask.s6_addr32[2]);
		ifra.ifra_addr.sin6_addr.s6_addr32[3] |=
		    (rand_ifid.s6_addr32[3] & ~mask.s6_addr32[3]);
	} else {
		ifra.ifra_addr.sin6_addr.s6_addr32[0] |=
		    (ia6->ia_addr.sin6_addr.s6_addr32[0] & ~mask.s6_addr32[0]);
		ifra.ifra_addr.sin6_addr.s6_addr32[1] |=
		    (ia6->ia_addr.sin6_addr.s6_addr32[1] & ~mask.s6_addr32[1]);
		ifra.ifra_addr.sin6_addr.s6_addr32[2] |=
		    (ia6->ia_addr.sin6_addr.s6_addr32[2] & ~mask.s6_addr32[2]);
		ifra.ifra_addr.sin6_addr.s6_addr32[3] |=
		    (ia6->ia_addr.sin6_addr.s6_addr32[3] & ~mask.s6_addr32[3]);
	}

	/* new prefix mask. */
	ifra.ifra_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_prefixmask.sin6_family = AF_INET6;
	bcopy(&mask, &ifra.ifra_prefixmask.sin6_addr,
	    sizeof(ifra.ifra_prefixmask.sin6_addr));

	/*
	 * lifetime.
	 * XXX: in6_init_address_ltimes would override these values later.
	 * We should reconsider this logic.
	 */
	ifra.ifra_lifetime.ia6t_vltime = pr->ndpr_vltime;
	ifra.ifra_lifetime.ia6t_pltime = pr->ndpr_pltime;

	if (privacy) {
	    if (ifra.ifra_lifetime.ia6t_vltime > ND6_PRIV_VALID_LIFETIME)
		ifra.ifra_lifetime.ia6t_vltime = ND6_PRIV_VALID_LIFETIME;
	    if (ifra.ifra_lifetime.ia6t_pltime > ND6_PRIV_PREFERRED_LIFETIME)
		ifra.ifra_lifetime.ia6t_pltime = ND6_PRIV_PREFERRED_LIFETIME
			- arc4random_uniform(ND6_PRIV_MAX_DESYNC_FACTOR);
	}

	/* XXX: scope zone ID? */

	ifra.ifra_flags |= IN6_IFF_AUTOCONF|IN6_IFF_TENTATIVE;

	/* If this address already exists, update it. */
	ia6 = in6ifa_ifpwithaddr(ifp, &ifra.ifra_addr.sin6_addr);

	error = in6_update_ifa(ifp, &ifra, ia6);

	if (error != 0) {
		char addr[INET6_ADDRSTRLEN];

		nd6log((LOG_ERR,
		    "%s: failed to make ifaddr %s on %s (errno=%d)\n", __func__,
		    inet_ntop(AF_INET6,	&ifra.ifra_addr.sin6_addr,
			addr, sizeof(addr)),
		    ifp->if_xname, error));
		return (NULL);	/* ifaddr must not have been allocated. */
	}

	ia6 = in6ifa_ifpwithaddr(ifp, &ifra.ifra_addr.sin6_addr);

	/* Perform DAD, if needed. */
	if (ia6 != NULL && ia6->ia6_flags & IN6_IFF_TENTATIVE)
		nd6_dad_start(&ia6->ia_ifa);

	return (ia6);
}

int
in6_init_prefix_ltimes(struct nd_prefix *ndpr)
{

	/* check if preferred lifetime > valid lifetime.  RFC2462 5.5.3 (c) */
	if (ndpr->ndpr_pltime > ndpr->ndpr_vltime) {
		nd6log((LOG_INFO, "in6_init_prefix_ltimes: preferred lifetime"
		    "(%d) is greater than valid lifetime(%d)\n",
		    (u_int)ndpr->ndpr_pltime, (u_int)ndpr->ndpr_vltime));
		return (EINVAL);
	}
	if (ndpr->ndpr_pltime == ND6_INFINITE_LIFETIME)
		ndpr->ndpr_preferred = 0;
	else
		ndpr->ndpr_preferred = time_uptime + ndpr->ndpr_pltime;
	if (ndpr->ndpr_vltime == ND6_INFINITE_LIFETIME)
		ndpr->ndpr_expire = 0;
	else
		ndpr->ndpr_expire = time_uptime + ndpr->ndpr_vltime;

	return 0;
}

void
in6_init_address_ltimes(struct nd_prefix *new, struct in6_addrlifetime *lt6)
{

	/* Valid lifetime must not be updated unless explicitly specified. */
	/* init ia6t_expire */
	if (lt6->ia6t_vltime == ND6_INFINITE_LIFETIME)
		lt6->ia6t_expire = 0;
	else {
		lt6->ia6t_expire = time_uptime;
		lt6->ia6t_expire += lt6->ia6t_vltime;
	}

	/* init ia6t_preferred */
	if (lt6->ia6t_pltime == ND6_INFINITE_LIFETIME)
		lt6->ia6t_preferred = 0;
	else {
		lt6->ia6t_preferred = time_uptime;
		lt6->ia6t_preferred += lt6->ia6t_pltime;
	}
@


1.161
log
@Replace rtrequest(RTM_DELETE...) rtrequest_delete() and do not even
try to remove a route from the table if it is and invalid cache.

This is a step towards decoupling code dealing with userland and kernel
inserted routes.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.160 2017/06/07 13:28:02 mpi Exp $	*/
a284 1
#ifndef	SMALL_KERNEL
a285 1
#endif	/* SMALL_KERNEL */
a384 1
#ifndef	SMALL_KERNEL
a385 1
#endif	/* SMALL_KERNEL */
@


1.160
log
@Grab the KERNEL_LOCK() around rtm*() functions.  Routing sockets globals
aren't protected by the NET_LOCK().

While here change lock assertions in rt_{set,put}gwroute(), the NET_LOCK()
is enough.

Tested by Hrvoje Popovski.

ok jmatthew@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.159 2017/05/30 08:58:34 florian Exp $	*/
d719 1
a719 1
	error = rtrequest(RTM_DELETE, &info, RTP_DEFAULT, &rt,
d2043 1
d2047 1
a2047 1
	int error;
d2070 10
a2079 8
	bzero(&info, sizeof(info));
	info.rti_flags =  rt->rt_flags;
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	info.rti_info[RTAX_NETMASK] = rt_plen2mask(rt, &sa_mask);
	error = rtrequest(RTM_DELETE, &info, RTP_ANY, NULL, id);
	if (error != 0)
		return (error);
d2081 1
a2081 1
	return (EAGAIN);
@


1.159
log
@Enable slaacd(8) by default and disable router solicitation and
advertisement processing in the kernel.
Go for it!!! deraadt@@
additional encouragement to push forward from at least mpi and henning
special thanks to naddy for being an early adopter and finding bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.158 2017/05/16 12:24:04 mpi Exp $	*/
d616 1
d618 1
d722 1
d724 1
@


1.158
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.157 2017/03/06 08:56:39 mpi Exp $	*/
d285 3
d386 4
@


1.157
log
@Prefix functions dealing with routing messages with 'rtm_' and keep
them all in net/rtsock.c.

This allows to easily spot which functions are doing a copyout(9)
when dealing with the routing midlayer.

ok phessler@@, bluhm@@, dhill@@, krw@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.156 2017/03/03 08:01:41 mpi Exp $	*/
d207 1
a207 1
	splsoftassert(IPL_SOFTNET);
d873 1
a873 1
	splsoftassert(IPL_SOFTNET);
d1017 1
a1017 1
	splsoftassert(IPL_SOFTNET);
d1053 1
a1053 1
	splsoftassert(IPL_SOFTNET);
d1113 1
a1113 1
	splsoftassert(IPL_SOFTNET);
d1168 1
a1168 1
	splsoftassert(IPL_SOFTNET);
d1836 1
a1836 1
	splsoftassert(IPL_SOFTNET);
d2017 1
a2017 1
	splsoftassert(IPL_SOFTNET);
@


1.156
log
@Iterate over the global list of interfaces instead of using the global
list of IPv6 addresses.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.155 2017/02/09 15:23:35 jca Exp $	*/
d609 1
a609 1
		rt_sendmsg(rt, RTM_ADD, new->ifp->if_rdomain);
d713 1
a713 1
		rt_sendmsg(rt, RTM_DELETE, dr->ifp->if_rdomain);
@


1.155
log
@percpu counters for raw ipv6 and icmp6 stats

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.154 2016/12/22 13:39:32 mpi Exp $	*/
d1522 2
d1525 1
a1525 1
	struct in6_ifaddr *ia6;
d1629 8
a1636 3
	TAILQ_FOREACH(ia6, &in6_ifaddr, ia_list) {
		if (!(ia6->ia6_flags & IN6_IFF_AUTOCONF))
			continue;
a1637 1
		if (ia6->ia6_ndpr == NULL) {
d1643 7
a1649 1
			continue;
d1652 1
a1652 1
		if (find_pfxlist_reachable_router(ia6->ia6_ndpr))
a1654 4
	if (ia6) {
		TAILQ_FOREACH(ia6, &in6_ifaddr, ia_list) {
			if ((ia6->ia6_flags & IN6_IFF_AUTOCONF) == 0)
				continue;
d1656 3
a1658 1
			if (ia6->ia6_ndpr == NULL) /* XXX: see above. */
d1661 1
a1661 8
			if (find_pfxlist_reachable_router(ia6->ia6_ndpr))
				ia6->ia6_flags &= ~IN6_IFF_DETACHED;
			else
				ia6->ia6_flags |= IN6_IFF_DETACHED;
		}
	}
	else {
		TAILQ_FOREACH(ia6, &in6_ifaddr, ia_list) {
d1665 12
a1676 1
			ia6->ia6_flags &= ~IN6_IFF_DETACHED;
@


1.154
log
@Remove all splsoftnet() from ND6 converting the non-recrusive ones to
NET_LOCK().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.153 2016/11/28 14:14:39 mpi Exp $	*/
d153 1
a153 1
		icmp6stat.icp6s_tooshort++;
d193 1
a193 1
	icmp6stat.icp6s_badrs++;
d279 1
a279 1
	icmp6stat.icp6s_outhist[ND_ROUTER_SOLICIT]++;
d415 1
a415 1
		icmp6stat.icp6s_tooshort++;
d573 1
a573 1
	icmp6stat.icp6s_badra++;
@


1.153
log
@Explicitly initialize rti_ifa when automagically adding a route.

This will allow to strengthen checks when userland adds a route.

ok phessler@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.152 2016/11/28 13:59:51 mpi Exp $	*/
d97 1
a97 1
	timeout_set(&nd6_rs_output_timer, nd6_rs_output_timo, NULL);
d205 3
a207 1
	int icmp6len, maxlen, s;
a276 1
	s = splsoftnet();
a277 1
	splx(s);
d294 1
d305 1
d314 1
a1109 1
	int e, s;
d1111 3
d1122 2
a1123 2
		nd6log((LOG_ERR, "prelist_remove: failed to make %s/%d offlink "
		    "on %s, errno=%d\n",
a1132 2
	s = splsoftnet();

d1142 1
a1142 1
		log(LOG_WARNING, "prelist_remove: negative count on %s\n",
a1148 1
	splx(s);
d1411 1
a1411 1
	s = splsoftnet();
d1477 1
a1477 1
	splx(s);
d1597 2
a1598 3
				nd6log((LOG_ERR,
				    "pfxlist_onlink_check: failed to "
				    "make %s/%d offlink, errno=%d\n",
d1609 2
a1610 3
				nd6log((LOG_ERR,
				    "pfxlist_onlink_check: failed to "
				    "make %s/%d offlink, errno=%d\n",
d2003 1
a2003 1
	int s;
a2011 1
	s = splsoftnet();
a2012 1
	splx(s);
@


1.152
log
@Remove multiple recursive splsoftnet().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.151 2016/11/21 10:56:26 mpi Exp $	*/
d597 1
@


1.151
log
@Assert that defrtrlist_update() is always called at IPL_SOFTNET.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.150 2016/11/21 10:52:08 mpi Exp $	*/
d73 3
a583 1
	int s;
a601 1
	s = splsoftnet();
a608 2
	splx(s);
	return;
d665 1
a665 1
		log(LOG_WARNING, "defrtrlist_del: negative count on %s\n",
a759 1
	int s = splsoftnet();
a765 1
		splx(s);
a829 3

	splx(s);
	return;
a1045 1
	int i, s;
d1047 3
a1052 1
			s = splsoftnet();
a1053 1
			splx(s);
a1075 1
	s = splsoftnet();
d1085 2
a1086 2
			nd6log((LOG_ERR, "nd6_prelist_add: failed to make "
			    "the prefix %s/%d on-link on %s (errno=%d)\n",
a1095 1
	splx(s);
@


1.150
log
@Assert that prelist_update() is always called at IPL_SOFTNET.

While here use __func__ in debug strings to reduce noise when grepping.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.149 2016/11/21 10:42:00 mpi Exp $	*/
d874 2
a875 1
	int s = splsoftnet();
a897 1
				splx(s);
a913 1
		splx(s);
a921 1
		splx(s);
a926 1
		splx(s);
a931 1
		splx(s);
a955 2

	splx(s);
@


1.149
log
@Assert that in6_ifadd() is always called at IPL_SOFTNET.

While here us __func__ in debug strings to reduce noise when grepping.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.148 2016/10/03 12:33:21 mpi Exp $	*/
d72 1
a72 1

d1173 1
a1173 1
	int s, error = 0;
d1179 1
a1179 1
	s = splsoftnet();
d1218 3
a1220 5
				nd6log((LOG_ERR,
				    "prelist_update: failed to make "
				    "the prefix %s/%d on-link on %s "
				    "(errno=%d)\n",
				    inet_ntop(AF_INET6,
d1240 2
a1241 3
			nd6log((LOG_NOTICE, "prelist_update: "
			    "nd6_prelist_add failed for %s/%d on %s "
			    "errno=%d, returnpr=%p\n",
a1410 1
	splx(s);
@


1.148
log
@Convert some of the remaining usages of time_second to time_uptime.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

Should fix mismatch between route timers that were already converted
and ND default routers that were still using time_second.

Tested by matthieu@@ and sthen@@

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.147 2016/09/30 06:27:21 florian Exp $	*/
d1835 1
a1835 1
	int error, s, plen0;
d1839 2
d1872 2
a1873 2
		nd6log((LOG_INFO, "in6_ifadd: wrong prefixlen for %s "
		    "(prefix=%d ifid=%d)\n",
a1944 1
	s = splsoftnet();
a1945 1
	splx(s);
d1951 1
a1951 1
		    "in6_ifadd: failed to make ifaddr %s on %s (errno=%d)\n",
@


1.147
log
@Revert sending router solicitations when a prefix expires and go back
to previous behaviour of starting quick, exponentially backing off and
settling on every 60 seconds.
sthen@@ noticed that this broke the backing off when we don't receive
an advertisment and so we would hammer the network every second which
is particularly bad on wifi networks.
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.146 2016/09/26 19:39:24 sthen Exp $	*/
d431 1
a431 1
	dr0.expire = time_second + dr0.rtlifetime;
d521 1
a521 1
			pr.ndpr_lastupdate = time_second;
d1353 1
a1353 1
		else if (time_second - ia6->ia6_updatetime >
d1362 1
a1362 1
				(time_second - ia6->ia6_updatetime);
d1393 1
a1393 1
		ia6->ia6_updatetime = time_second;
d1981 1
a1981 1
		ndpr->ndpr_preferred = time_second + ndpr->ndpr_pltime;
d1985 1
a1985 1
		ndpr->ndpr_expire = time_second + ndpr->ndpr_vltime;
d1999 1
a1999 1
		lt6->ia6t_expire = time_second;
d2007 1
a2007 1
		lt6->ia6t_preferred = time_second;
@


1.146
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.145 2016/09/08 09:02:42 mpi Exp $	*/
a77 1
u_int32_t nd6_rs_next_pltime_timo(struct ifnet *);
a285 23
u_int32_t
nd6_rs_next_pltime_timo(struct ifnet *ifp)
{
	struct ifaddr *ifa;
	struct in6_ifaddr *ia6;
	u_int32_t pltime_expires = ND6_INFINITE_LIFETIME;

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;

		ia6 = ifatoia6(ifa);
		if (ia6->ia6_lifetime.ia6t_pltime == ND6_INFINITE_LIFETIME ||
		    IFA6_IS_DEPRECATED(ia6) || IFA6_IS_INVALID(ia6))
			continue;

		pltime_expires = MIN(pltime_expires,
		    ia6->ia6_lifetime.ia6t_pltime);
	}

	return pltime_expires;
}

a290 2
	u_int32_t pltime_expire = ND6_INFINITE_LIFETIME, t;
	int timeout = ND6_RS_OUTPUT_INTERVAL;
d297 3
a299 1
		timeout = nd6_rs_output_timeout * 2;
d304 3
a306 11
			t = nd6_rs_next_pltime_timo(ifp);
			if (t == ND6_INFINITE_LIFETIME || t <
			    ND6_RS_OUTPUT_INTERVAL) {
				timeout = ND6_RS_OUTPUT_QUICK_INTERVAL;
				ia6 = in6ifa_ifpforlinklocal(ifp,
				    IN6_IFF_TENTATIVE);
				if (ia6 != NULL)
					nd6_rs_output(ifp, ia6);
			}

			pltime_expire = MIN(pltime_expire, t);
d309 1
a309 4
	if (pltime_expire != ND6_INFINITE_LIFETIME)
		timeout = MAX(timeout, pltime_expire / 2);

	nd6_rs_output_set_timo(timeout);
@


1.145
log
@If the same address is offered via NA, update the existing ``ifa''
instead of creating a new one.

Having two addresses mean that the old, deprecated one, would be
selected instead of the new one.  The issue could be triggered by
reducing the pltime/vltime values sent by a router advertisement
daemon.

Problem reported and fix tested by Jens Sauer on bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.144 2016/09/02 11:51:07 florian Exp $	*/
d361 1
a361 1
	 * (re)send solicitation regardless if we are enableing autoconf
@


1.144
log
@Consider when a prefix expires when sending solicitations instead of
blindly always sending one every 60 seconds.

repeated prodding & input naddy
input & OK vgross
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.143 2016/09/02 09:31:25 florian Exp $	*/
d1975 3
a1977 1
	/* allocate ifaddr structure, link into chain, etc. */
d1979 1
a1979 1
	error = in6_update_ifa(ifp, &ifra, NULL);
@


1.143
log
@Go through the set function like normal people; no functional change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.142 2016/08/25 16:12:16 mpi Exp $	*/
d78 1
d287 23
d315 2
d323 1
a323 3
		nd6_rs_output_timeout *= 2;
	if (nd6_rs_output_timeout > ND6_RS_OUTPUT_INTERVAL)
		nd6_rs_output_timeout = ND6_RS_OUTPUT_INTERVAL;
d328 11
a338 3
			ia6 = in6ifa_ifpforlinklocal(ifp, IN6_IFF_TENTATIVE);
			if (ia6 != NULL)
				nd6_rs_output(ifp, ia6);
d341 4
a344 1
	nd6_rs_output_set_timo(nd6_rs_output_timeout);
@


1.142
log
@Remove a check to expire received prefix.

This check does not make sense since November 2000 when IPv6 autoconf
address deletion has been made independent from prefix lifetimes.

Fix a case when a route was added to the table but the corresponding
address was not, leaving v6 unusable.

Found the hardway by and ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.141 2016/08/22 10:33:22 mpi Exp $	*/
d309 1
a309 1
	timeout_add_sec(&nd6_rs_output_timer, nd6_rs_output_timeout);
@


1.141
log
@Sizes for free(9) from David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.140 2016/07/05 10:17:14 mpi Exp $	*/
a1249 13
		}

		/*
		 * XXX: from the ND point of view, we can ignore a prefix
		 * with the on-link bit being zero.  However, we need a
		 * prefix structure for references from autoconfigured
		 * addresses.  Thus, we explicitly make sure that the prefix
		 * itself expires now.
		 */
		if (newpr->ndpr_raf_onlink == 0) {
			newpr->ndpr_vltime = 0;
			newpr->ndpr_pltime = 0;
			in6_init_prefix_ltimes(newpr);
@


1.140
log
@Expand IN6_IFF_NOTREADY, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.139 2016/05/02 22:15:49 jmatthew Exp $	*/
d670 1
a670 1
	free(dr, M_IP6NDP, 0);
d998 1
a998 1
	free(pfr, M_IP6NDP, 0);
d1148 1
a1148 1
		free(pfr, M_IP6NDP, 0);
d1156 1
a1156 1
	free(pr, M_IP6NDP, 0);
@


1.139
log
@Simplify life for routing table implementations by requiring that rtable_walk
callbacks return EAGAIN if they modify the routing table.  While we're here,
simplify life for rtable_walk callers by moving the loop that restarts the
walk on EAGAIN into rtable_walk itself.

Flushing cloned routes on interface state changes becomes a bit more
inefficient, but this can be improved later.

ok mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.138 2016/01/12 09:37:44 mpi Exp $	*/
a1878 8

#if 0 /* don't care link local addr state, and always do DAD */
	/* if link-local address is not eligible, do not autoconfigure. */
	if (ifatoia6(ifa)->ia6_flags & IN6_IFF_NOTREADY) {
		printf("in6_ifadd: link-local address not ready\n");
		return NULL;
	}
#endif
@


1.138
log
@Prevent a possible NULL-derefenced introduced by the move of RA sleeping
code in a task.

Such dereferenced can be triggered by receiving a RA with the 'on-link'
bit set to 0 apparently generated by dnsmasq and reported by matthieu@@.

ok matthieu@@, sthen@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.137 2015/12/18 10:55:51 tb Exp $	*/
d2059 1
d2087 5
a2091 1
	return (rtrequest(RTM_DELETE, &info, RTP_ANY, NULL, id));
@


1.137
log
@Convert arc4random() to arc4random_uniorm().  Diff by Matthew Martin.

Ensure that arc4random_uniform() doesn't loop by redefining
ND6_MAX_DESYNC_FACTOR to be 512, the largest power of two smaller
than the RFC-specified 600 seconds.  Suggested by florian@@ and deraadt@@

ok florian@@, sthen@@ in this form, arc4random change ok djm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.136 2015/12/03 21:57:59 mpi Exp $	*/
a1976 1
	/* this is always non-NULL */
d1980 1
a1980 1
	if (ia6->ia6_flags & IN6_IFF_TENTATIVE)
@


1.136
log
@Get rid of rt_mask() and stop allocating a "struct sockaddr" for every
route entry in ART.

rt_plen() now represents the prefix length of a route entry and should
be used instead.

For now use a "struct sockaddr_in6" to represent the mask when needed,
this should be then replaced by the prefix length and RTA_NETMASK only
used for compatibility with userland.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.135 2015/12/01 21:29:10 mpi Exp $	*/
d1954 1
a1954 1
			- (arc4random() % ND6_PRIV_MAX_DESYNC_FACTOR);
@


1.135
log
@Use rt_ifa_add(9) instead or rtrequest(9) when adding ND prefixes.

While here pick the corresponding ``ifa'' to attach the route instead
of the one corresponding to the link-local address on the same interface.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.134 2015/11/24 13:37:16 mpi Exp $	*/
d2059 1
d2086 1
a2086 1
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
@


1.134
log
@No need for <net/if_types.h>

As a bonus this removes a "#if NCARP > 0", say yeah!
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.133 2015/11/02 13:54:46 sthen Exp $	*/
d1700 1
a1700 1
	struct rt_addrinfo info;
a1701 2
	struct ifnet *ifp = pr->ndpr_ifp;
	struct sockaddr_in6 mask6;
a1702 1
	struct rtentry *rt;
d1704 1
a1704 2
	u_long rtflags = 0;
	int error;
d1730 5
a1734 12
	/*
	 * We prefer link-local addresses as the associated interface address.
	 */
	/* search for a link-local addr */
	ifa = &in6ifa_ifpforlinklocal(ifp,
	    IN6_IFF_NOTREADY | IN6_IFF_ANYCAST)->ia_ifa;
	if (ifa == NULL) {
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family == AF_INET6)
				break;
		}
		/* should we care about ia6_flags? */
a1751 4
	bzero(&mask6, sizeof(mask6));
	mask6.sin6_len = sizeof(mask6);
	mask6.sin6_addr = pr->ndpr_mask;

d1755 2
a1756 8
	bzero(&info, sizeof(info));
	info.rti_flags = rtflags;
	info.rti_info[RTAX_DST] = sin6tosa(&pr->ndpr_prefix);
	info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
	info.rti_info[RTAX_NETMASK] = sin6tosa(&mask6);

	error = rtrequest(RTM_ADD, &info, RTP_CONNECTED, &rt, ifp->if_rdomain);
	if (error == 0) {
a1757 3
		rt_sendmsg(rt, RTM_ADD, ifp->if_rdomain);
		rtfree(rt);
	}
a1764 1
	struct rt_addrinfo info;
d1766 1
a1767 2
	struct sockaddr_in6 sa6, mask6;
	struct rtentry *rt;
d1769 1
a1769 1
	int error;
d1781 11
a1791 12
	bzero(&sa6, sizeof(sa6));
	sa6.sin6_family = AF_INET6;
	sa6.sin6_len = sizeof(sa6);
	bcopy(&pr->ndpr_prefix.sin6_addr, &sa6.sin6_addr,
	    sizeof(struct in6_addr));
	bzero(&mask6, sizeof(mask6));
	mask6.sin6_family = AF_INET6;
	mask6.sin6_len = sizeof(sa6);
	bcopy(&pr->ndpr_mask, &mask6.sin6_addr, sizeof(struct in6_addr));
	bzero(&info, sizeof(info));
	info.rti_info[RTAX_DST] = sin6tosa(&sa6);
	info.rti_info[RTAX_NETMASK] = sin6tosa(&mask6);
d1793 1
a1793 2
	error = rtrequest(RTM_DELETE, &info, RTP_CONNECTED, &rt,
	    ifp->if_rdomain);
a1796 3
		rt_sendmsg(rt, RTM_DELETE, ifp->if_rdomain);
		rtfree(rt);

a1835 7
	} else {
		/* XXX: can we still set the NDPRF_ONLINK flag? */
		nd6log((LOG_ERR,
		    "nd6_prefix_offlink: failed to delete route: "
		    "%s/%d on %s (errno = %d)\n",
		    inet_ntop(AF_INET6,	&sa6.sin6_addr, addr, sizeof(addr)),
		    pr->ndpr_plen, ifp->if_xname, error));
@


1.133
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.132 2015/11/02 07:24:08 mpi Exp $	*/
a49 1
#include <net/if_types.h>
@


1.132
log
@Prefer an existing refcounted ``ifp'' to rt_ifp when possible or use the
interface index directly.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.131 2015/10/30 09:39:42 bluhm Exp $	*/
d557 1
a557 1
	 * detection of adveritsed prefixes.
@


1.131
log
@Rename rtrequest1() to rtrequest().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.130 2015/10/28 12:14:25 florian Exp $	*/
d614 1
a614 1
defrouter_lookup(struct in6_addr *addr, struct ifnet *ifp)
d619 2
a620 1
		if (dr->ifp == ifp && IN6_ARE_ADDR_EQUAL(addr, &dr->rtaddr))
d877 1
a877 1
	if ((dr = defrouter_lookup(&new->rtaddr, new->ifp)) != NULL) {
@


1.130
log
@Remove linkmtu and maxmtu from struct nd_ifinfo. IN6_LINKMTU can now
die and ifp->if_mtu is the one true mtu.
Suggested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.129 2015/10/25 21:32:16 florian Exp $	*/
d602 1
a602 1
	error = rtrequest1(RTM_ADD, &info, RTP_DEFAULT, &rt,
d707 1
a707 1
	error = rtrequest1(RTM_DELETE, &info, RTP_DEFAULT, &rt,
d1776 1
a1776 1
	error = rtrequest1(RTM_ADD, &info, RTP_CONNECTED, &rt, ifp->if_rdomain);
d1820 1
a1820 1
	error = rtrequest1(RTM_DELETE, &info, RTP_CONNECTED, &rt,
d2124 1
a2124 1
	return (rtrequest1(RTM_DELETE, &info, RTP_ANY, NULL, id));
@


1.129
log
@Put some comments in how nd6_rs_attach() works.
Requested by stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.128 2015/10/25 11:58:11 mpi Exp $	*/
a529 37

	/*
	 * MTU
	 */
	if (ndopts.nd_opts_mtu && ndopts.nd_opts_mtu->nd_opt_mtu_len == 1) {
		u_long mtu;
		u_long maxmtu;

		mtu = ntohl(ndopts.nd_opts_mtu->nd_opt_mtu_mtu);

		/* lower bound */
		if (mtu < IPV6_MMTU) {
			nd6log((LOG_INFO, "nd6_ra_input: bogus mtu option "
			    "mtu=%lu sent from %s, ignoring\n",
			    mtu,
			    inet_ntop(AF_INET6, &ip6->ip6_src,
				src, sizeof(src))));
			goto skip;
		}

		/* upper bound */
		maxmtu = (ndi->maxmtu && ndi->maxmtu < ifp->if_mtu)
		    ? ndi->maxmtu : ifp->if_mtu;
		if (mtu <= maxmtu) {
			ndi->linkmtu = mtu;
		} else {
			nd6log((LOG_INFO, "nd6_ra_input: bogus mtu "
			    "mtu=%lu sent from %s; "
			    "exceeds maxmtu %lu, ignoring\n",
			    mtu,
			    inet_ntop(AF_INET6, &ip6->ip6_src,
				src, sizeof(src)),
			    maxmtu));
		}
	}

 skip:
@


1.128
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.127 2015/10/24 16:08:48 mpi Exp $	*/
d317 4
d326 4
@


1.127
log
@Ignore Router Advertisment's current hop limit.

Appart from the usual inet6 axe murdering exercise to keep you fit, this
allows us to get rid of a lot of layer violation due to the use of per-
ifp variables to store the current hop limit.

Imputs from bluhm@@, ok phessler@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.126 2015/10/22 15:37:47 bluhm Exp $	*/
a1791 4
	/*
	 * in6_ifinit() sets nd6_rtrequest to ifa_rtrequest for all ifaddrs.
	 * ifa->ifa_rtrequest = nd6_rtrequest;
	 */
@


1.126
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.125 2015/09/18 14:26:22 mpi Exp $	*/
d438 6
a443 2
	if (nd_ra->nd_ra_curhoplimit)
		ndi->chlim = nd_ra->nd_ra_curhoplimit;
@


1.125
log
@Do not manually decrement rt's refcounter in nd6_lookup() and let the
callers rtfree(9) it.

Inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.124 2015/09/12 20:50:17 mpi Exp $	*/
a59 2

#define SDL(s)	((struct sockaddr_dl *)s)
@


1.124
log
@Now that rtrequest1(9) properly sets RTF_UP for newly added route,
stop passing it in every rt_ifa_add(9) calls.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.123 2015/09/11 08:17:06 claudio Exp $	*/
d807 9
a815 6
		if (!selected_dr &&
		    (rt = nd6_lookup(&dr->rtaddr, 0, dr->ifp,
		     dr->ifp->if_rdomain)) &&
		    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
		    ND6_IS_LLINFO_PROBREACH(ln)) {
			selected_dr = dr;
d839 9
a847 7
	} else if (installed_dr &&
	    (rt = nd6_lookup(&installed_dr->rtaddr, 0, installed_dr->ifp,
	     installed_dr->ifp->if_rdomain)) &&
	    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
	    ND6_IS_LLINFO_PROBREACH(ln) &&
	    rtpref(selected_dr) <= rtpref(installed_dr)) {
		selected_dr = installed_dr;
d1544 1
a1544 1
	struct rtentry *rt;
d1551 2
a1552 1
		    ND6_IS_LLINFO_PROBREACH(ln))
d1554 2
@


1.123
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.122 2015/09/10 09:17:16 claudio Exp $	*/
d1726 1
a1726 1
	u_long rtflags;
d1791 1
a1791 3
		rtflags = (RTF_UP | RTF_CLONING | RTF_CONNECTED);
	else
		rtflags = RTF_UP;
@


1.122
log
@if_put dance, shuffle some code and switch a printf to print the ifindex
instead of the name so we don't have to if_get/if_put it for just that.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.121 2015/09/09 15:51:40 mpi Exp $	*/
d276 1
a276 1
	ip6_output(m, NULL, NULL, 0, &im6o, NULL, NULL);
@


1.121
log
@Kill icmp6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_ICMP6 is no longer supported.

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.120 2015/08/24 23:28:27 mpi Exp $	*/
a128 4
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		goto freeit;

d136 1
a136 1
		    "nd6_rs_input: invalid hlim (%d) from %s to %s on %s\n",
d140 1
a140 1
		    ifp->if_xname));
d171 4
d181 1
d186 1
d405 1
d590 1
d596 1
@


1.120
log
@nd6_prefix_add() is no longer used and die.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.119 2015/08/24 23:26:43 mpi Exp $	*/
a276 2
	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	icmp6_ifstat_inc(ifp, ifs6_out_routersolicit);
@


1.119
log
@Start moving away from the global prefix list by limiting its usage to
AUTOCONF'd addresses.

This prevent the kernel from removing connected (/64) routes as soon as
it configures an AUTOCONF'd address based on a RA.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.118 2015/08/24 22:11:34 mpi Exp $	*/
a1069 46
}

struct nd_prefix *
nd6_prefix_add(struct ifnet *ifp, struct sockaddr_in6 *addr,
    struct sockaddr_in6 *mask, struct in6_addrlifetime *lt)
{
	struct nd_prefix pr0, *pr;
	int i;

	/*
	 * convert mask to prefix length (prefixmask has already
	 * been validated in in6_update_ifa().
	 */
	memset(&pr0, 0, sizeof(pr0));
	pr0.ndpr_ifp = ifp;
	pr0.ndpr_plen = in6_mask2len(&mask->sin6_addr, NULL);
	pr0.ndpr_prefix = *addr;
	pr0.ndpr_mask = mask->sin6_addr;
	/* apply the mask for safety. */
	for (i = 0; i < 4; i++) {
		pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &=
		    mask->sin6_addr.s6_addr32[i];
	}
	/*
	 * XXX: since we don't have an API to set prefix (not address)
	 * lifetimes, we just use the same lifetimes as addresses.
	 * The (temporarily) installed lifetimes can be overridden by
	 * later advertised RAs (when accept_rtadv is non 0), which is
	 * an intended behavior.
	 */
	pr0.ndpr_raf_onlink = 1; /* should be configurable? */
	pr0.ndpr_raf_auto = 1;
	pr0.ndpr_vltime = lt->ia6t_vltime;
	pr0.ndpr_pltime = lt->ia6t_pltime;

	/* add the prefix if not yet. */
	if ((pr = nd6_prefix_lookup(&pr0)) == NULL) {
		/*
		 * nd6_prelist_add will install the corresponding
		 * interface route.
		 */
		if (nd6_prelist_add(&pr0, NULL, &pr) != 0)
			return (NULL);
	}

	return (pr);
@


1.118
log
@Always increment the reference counter of the returned route entry in
rtrequest1(9).

This simplifies rtfree(9) dances and will prevent another CPU to free
the entry before we're done with it as soon as routing functions can
be executed in parallel.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.117 2015/08/24 15:58:35 mpi Exp $	*/
d1074 1
a1074 1
    struct sockaddr_in6 *mask, struct in6_addrlifetime *lt, int autoconf)
d1101 1
a1101 1
	pr0.ndpr_raf_auto = autoconf;
d1191 1
a1191 8
#if 0
	/*
	 * Though these flags are now meaningless, we'd rather keep the value
	 * not to confuse users when executing "ndp -p".
	 */
	pr->ndpr_raf_onlink = 0;
	pr->ndpr_raf_auto = 0;
#endif
@


1.117
log
@Rework the code to decide when to perform DAD to no longer rely on the
IN6_IFF_NODAD pseudo-flag not being set.

This was just a flag for spaghetti code that should not exist in the
first place.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.116 2015/08/19 13:27:38 bluhm Exp $	*/
d735 1
a735 8
		if (rt->rt_refcnt <= 0) {
			/*
			 * XXX: borrowed from the RTM_DELETE case of
			 * rtrequest1().
			 */
			rt->rt_refcnt++;
			rtfree(rt);
		}
a1899 1
		/* report the route deletion to the routing socket. */
d1901 1
a1940 6
		}

		if (rt->rt_refcnt <= 0) {
			/* XXX: we should free the entry ourselves. */
			rt->rt_refcnt++;
			rtfree(rt);
@


1.116
log
@Convert all calls to rtrequest1() and the following error check
into a common pattern.  In the man page clarify the usage of the
returned route.
OK mpi@@ mikeb@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.115 2015/08/18 08:52:25 mpi Exp $	*/
d2085 1
a2085 1
	ifra.ifra_flags |= IN6_IFF_AUTOCONF; /* obey autoconf */
d2104 7
a2110 1
	return (in6ifa_ifpwithaddr(ifp, &ifra.ifra_addr.sin6_addr));
@


1.115
log
@Call rtfree(9) when we no longer need the route entry rather than
decrementing rt_refcnt just after rtrequest1(9).

While here reduce the differences with rt_ifa_add(9).  There's still
an ambiguity about rtrequest1(9)'s return value, but bluhm@@ will
address that in a different diff.

Discussed with and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.114 2015/08/17 10:57:24 mpi Exp $	*/
d605 1
a605 1
	struct rtentry *rt = NULL;
d628 1
a628 1
	if (rt) {
d631 1
a632 2
	if (error == 0)
		new->installed = 1;
d707 2
a708 1
	struct rtentry *oldrt = NULL;
d731 1
a731 1
	rtrequest1(RTM_DELETE, &info, RTP_DEFAULT, &oldrt,
d733 3
a735 3
	if (oldrt) {
		rt_sendmsg(oldrt, RTM_DELETE, dr->ifp->if_rdomain);
		if (oldrt->rt_refcnt <= 0) {
d740 2
a741 2
			oldrt->rt_refcnt++;
			rtfree(oldrt);
d1781 2
d1784 1
a1784 3
	int error = 0;
	struct rtentry *rt = NULL;
	char addr[INET6_ADDRSTRLEN];
d1859 1
a1859 1
	if (error == 0 && rt != NULL) {
a1871 1
	int error = 0;
d1875 1
a1875 1
	struct rtentry *rt = NULL;
d1877 1
d1901 1
d1908 1
a1908 2
		if (rt != NULL)
			rt_sendmsg(rt, RTM_DELETE, ifp->if_rdomain);
d1949 6
a1961 8
	}

	if (rt != NULL) {
		if (rt->rt_refcnt <= 0) {
			/* XXX: we should free the entry ourselves. */
			rt->rt_refcnt++;
			rtfree(rt);
		}
@


1.114
log
@Remove anoying comment about in6_update_ifa().
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.113 2015/07/18 15:51:17 mpi Exp $	*/
d72 2
a73 1

d605 1
a605 1
	struct rtentry *newrt = NULL;
d626 1
a626 1
	error = rtrequest1(RTM_ADD, &info, RTP_DEFAULT, &newrt,
d628 3
a630 3
	if (newrt) {
		rt_sendmsg(newrt, RTM_ADD, new->ifp->if_rdomain);
		newrt->rt_refcnt--;
d1787 1
a1787 6
	if ((pr->ndpr_stateflags & NDPRF_ONLINK) != 0) {
		nd6log((LOG_ERR,
		    "nd6_prefix_onlink: %s/%d is already on-link\n",
		    inet_ntop(AF_INET6,	&pr->ndpr_prefix.sin6_addr,
			addr, sizeof(addr)),
		    pr->ndpr_plen));
a1788 1
	}
d1859 1
a1859 3
	if (error == 0) {
		if (rt != NULL) /* this should be non NULL, though */
			rt_sendmsg(rt, RTM_ADD, ifp->if_rdomain);
d1861 2
a1862 12
	} else {
		char gw[INET6_ADDRSTRLEN], mask[INET6_ADDRSTRLEN];
		nd6log((LOG_ERR, "nd6_prefix_onlink: failed to add route for a"
		    " prefix (%s/%d) on %s, gw=%s, mask=%s, flags=%lx "
		    "errno = %d\n",
		    inet_ntop(AF_INET6,	&pr->ndpr_prefix.sin6_addr,
			addr, sizeof(addr)),
		    pr->ndpr_plen, ifp->if_xname,
		    inet_ntop(AF_INET6, &satosin6(ifa->ifa_addr)->sin6_addr,
			gw, sizeof(gw)),
		    inet_ntop(AF_INET6, &mask6.sin6_addr, mask, sizeof(mask)),
		    rtflags, error));
a1863 3

	if (rt != NULL)
		rt->rt_refcnt--;
@


1.113
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.112 2015/07/18 15:05:32 mpi Exp $	*/
a2045 1

a2046 4
	/*
	 * in6_update_ifa() does not use ifra_name, but we accurately set it
	 * for safety.
	 */
@


1.112
log
@Merge two identical chunks to add new prefixes to the global data
structures into a function.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.111 2015/07/17 17:18:05 florian Exp $	*/
d52 1
a52 1
#include <net/radix.h>
d75 1
a75 1
int rt6_deleteroute(struct radix_node *, void *, u_int);
d2187 1
a2187 2
	struct radix_node_head *rnh = rtable_get(ifp->if_rdomain, AF_INET6);
	int s = splsoftnet();
d2190 1
a2190 2
	if (!IN6_IS_ADDR_LINKLOCAL(gateway)) {
		splx(s);
d2192 1
a2192 1
	}
d2196 2
a2197 1
	rnh->rnh_walktree(rnh, rt6_deleteroute, (void *)gateway);
d2202 1
a2202 1
rt6_deleteroute(struct radix_node *rn, void *arg, u_int id)
a2204 1
	struct rtentry *rt = (struct rtentry *)rn;
@


1.111
log
@Remove #if 0'ed code and update comment.
There is no need to handle managed/other flags for router
advertisments in the kernel according to the rfcs.
Remove stale todo comment; we do handle the on-link bit.
OK mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.110 2015/07/16 16:12:15 mpi Exp $	*/
d1076 46
@


1.110
log
@Expand ancient NTOHL/NTOHS/HTONS/HTONL macros.

ok guenther@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.109 2015/07/16 15:31:35 mpi Exp $	*/
a354 2
 * TODO: on-link bit on prefix information
 * TODO: ND_RA_FLAG_{OTHER,MANAGED} processing
a363 6
#if 0
	struct in6_addr daddr6 = ip6->ip6_dst;
	int flags; /* = nd_ra->nd_ra_flags_reserved; */
	int is_managed = ((flags & ND_RA_FLAG_MANAGED) != 0);
	int is_other = ((flags & ND_RA_FLAG_OTHER) != 0);
#endif
@


1.109
log
@Properly layer Router Solicitation code.

Tweak and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.108 2015/07/08 07:56:51 mpi Exp $	*/
d436 1
a436 1
		NTOHL(advreachable);
@


1.108
log
@Use a new RTF_CONNECTED flag for interface (connected) routes.

Recent changes to support multiple interface routes broke the
assumption made by all our userland routing daemons concerning
interface routes.  Historically such routes had a "gateway"
sockaddr of type AF_LINK.  But to be able to support multiple
interface routes as any other multipath routes, they now have
a unique "gateway" sockaddr containing their corresponding IP
address.

This self-describing flag should avoid ambiguity when dealing
with interface routes.

Issue reported by <mxb AT alumni DOT chalmers DOT se> and benno@@

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.107 2015/06/16 11:09:40 mpi Exp $	*/
d79 5
d86 14
d279 57
@


1.107
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.106 2015/06/08 22:19:28 krw Exp $	*/
a1737 2
	/* rtrequest1() will probably set RTF_UP, but we're not sure. */
	rtflags = RTF_UP;
d1739 1
a1739 1
		rtflags |= RTF_CLONING;
d1741 1
a1741 1
		rtflags &= ~RTF_CLONING;
@


1.106
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.105 2015/06/04 09:51:15 mpi Exp $	*/
d91 1
a91 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d109 4
d204 1
a204 1
	m->m_pkthdr.rcvif = NULL;
d285 2
a286 2
	struct ifnet *ifp = m->m_pkthdr.rcvif;
	struct nd_ifinfo *ndi = ND_IFINFO(ifp);
d300 4
d307 2
d433 1
a433 1
			pr.ndpr_ifp = (struct ifnet *)m->m_pkthdr.rcvif;
@


1.105
log
@Remove unused sa_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.104 2015/05/26 12:19:52 mpi Exp $	*/
d221 1
a221 1
	
d1001 1
a1001 1
nd6_prelist_add(struct nd_prefix *pr, struct nd_defrouter *dr, 
d1398 1
a1398 1
	/* 
d1564 1
a1564 1
	LIST_FOREACH(pr, &nd_prefix, ndpr_entry) {	
@


1.104
log
@Store the IP address of the corresponding ifa in the rt_gateway field
of RTF_CLONING and RTF_BROASCAST routes to not create MPATH conflicts
when IP address aliases are used.

This change makes it possible to have multiple RTF_CLONING routes with
the same priority.  Note that any of the existing RTF_CLONING route
might be used by the kernel to create a RTF_CLONED route which should
not be a problem with aliases since they are attached to the same ifp.

This unbreak address aliases since the kernel supports multiple connected
routes for a subnet.

Found the hardway by djm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.103 2015/05/15 12:00:57 claudio Exp $	*/
a1654 1
	struct sockaddr_dl sa_dl = { sizeof(sa_dl), AF_LINK };
a1726 3

	sa_dl.sdl_type = ifp->if_type;
	sa_dl.sdl_index = ifp->if_index;
@


1.103
log
@Allow multiple connected/interface routes to exist at the same time.
Use the existing multipath code. Switch away from using the ifa address
when making the cloning route and instead put a dummy sockaddr_dl route
in. With this it is possible to use the same network on multiple interfaces
at the same time. So if wireless and ethernet share the same network
the system will use the wired connection as long as there is link.
Still missing is builtin proxy-arp for the other interface IPs to allow
hitless failover.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.102 2015/04/27 14:51:44 mpi Exp $	*/
d1742 1
a1742 1
	info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)&sa_dl;
@


1.102
log
@Do not call nd6_purge() before purging the IPv6 addresses of a detached
interface.

Fix a use after free introduced in r1.98 of netinet6/in6.c and recently
exposed by a crazy pool/malloc damage finder being currently refined by
dlg@@ and deraadt@@.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.101 2015/03/25 17:39:33 florian Exp $	*/
d48 1
d1655 1
d1728 4
d1742 1
a1742 1
	info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
@


1.101
log
@With a per interface IPv6 stateless adress auto configuration flag it
is possible to allow IPv6 forwarding and SLAAC at the same time. This
is needed for RFC 7084.
Thanks to henning@@ for marking places that needed looking at in
Ljubljana.
OK phessler@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.100 2015/03/14 03:38:52 jsg Exp $	*/
d1455 2
a1456 1
	pr->ndpr_refcnt--;
@


1.100
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.99 2015/03/09 18:09:50 mikeb Exp $	*/
d109 1
a109 1
	if (!ip6_forwarding || (ifp->if_xflags & IFXF_AUTOCONF6))
d582 1
a582 1
	if (!ip6_forwarding && (dr->ifp->if_xflags & IFXF_AUTOCONF6))
a714 15
	 * This function should be called only when acting as an autoconfigured
	 * host.  Although the remaining part of this function is not effective
	 * if the node is not an autoconfigured host, we explicitly exclude
	 * such cases here for safety.
	 */
	/* XXX too strict? */
	if (ip6_forwarding) {
		nd6log((LOG_WARNING,
		    "defrouter_select: called unexpectedly (forwarding=%d)\n",
		    ip6_forwarding));
		splx(s);
		return;
	}

	/*
d867 1
a867 1
		if (!ip6_forwarding && (new->ifp->if_xflags & IFXF_AUTOCONF6))
@


1.99
log
@Avoid doing IPv6 SLAAC for prefixes with preferred lifetime of zero

RFC 4941 says in 3.3.5:

 "In particular, an implementation MUST NOT create a temporary address
  with a zero Preferred Lifetime."

OK sthen, henning, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.98 2015/02/19 22:24:20 bluhm Exp $	*/
a49 1
#include <net/if_dl.h>
@


1.98
log
@Move the splsoftnet() hiding in the declarations closer to the code.
No binary change;  OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.97 2015/01/27 03:17:36 dlg Exp $	*/
d1379 2
a1380 1
	    !tempaddr_preferred)) && new->ndpr_vltime != 0 &&
d1384 2
a1385 2
		 * 4941 temporary address. And the valid prefix lifetime is
		 * non-zero. And there is no static address in the same prefix.
@


1.97
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.96 2014/12/22 11:17:20 mpi Exp $	*/
a709 1
	int s = splsoftnet();
d713 1
d1142 1
a1142 2
	int s = splsoftnet();
	int error = 0;
d1147 2
@


1.96
log
@Operations on the global prefix or address lists should be done under
splsoftnet().
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.95 2014/12/22 11:05:53 mpi Exp $	*/
d77 1
a77 1
void nd6_addr_add(void *, void *);
d1048 1
a1048 1
	task_set(&new->ndpr_task, nd6_addr_add, new, NULL);
d1399 1
a1399 1
nd6_addr_add(void *prptr, void *arg2)
@


1.95
log
@Make sure rtrequest1(9) is called under splsoftnet().
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.94 2014/12/17 09:57:13 mpi Exp $	*/
a1052 1
	splx(s);
d1071 1
@


1.94
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.93 2014/12/17 09:45:59 mpi Exp $	*/
a1123 1
	splx(s);
d1128 1
@


1.93
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.92 2014/12/05 15:50:04 mpi Exp $	*/
d206 2
a207 2
	im6o.im6o_multicast_hlim = 255;
	im6o.im6o_multicast_loop = 0;
@


1.92
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.91 2014/11/20 09:55:57 mpi Exp $	*/
d205 1
a205 1
	im6o.im6o_multicast_ifp = ifp;
@


1.91
log
@What have no need for a variable that holds the maximum MTU size of
interfaces with an IPv6 address.

ok henning@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.90 2014/11/18 02:37:31 tedu Exp $	*/
d48 1
@


1.90
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.89 2014/11/01 21:40:39 mpi Exp $	*/
a462 2
			int change = (ndi->linkmtu != mtu);

a463 2
			if (change) /* in6_maxmtu may change */
				in6_setmaxmtu();
@


1.89
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.88 2014/10/07 08:47:28 mpi Exp $	*/
a45 1
#include <dev/rndvar.h>
a58 2

#include <dev/rndvar.h>
@


1.88
log
@Do not protect the SIOCSIFADDR call by splnet().  Drivers already
raise it inside their ioctl handler (except for carp(4), what else?).

In general, global structures manipulated in the softnet codepath only
require a splsoftnet() protection when they are modified in process
(ioctl) context.

Also put some IPL_SOFNET asserts in functions accessing global structures.

Previous version diff ok mikeb@@, with inputs from and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.87 2014/09/09 20:33:24 dlg Exp $	*/
d688 1
a688 1
	 * going through them by rtalloc1()?
@


1.87
log
@workqs were replaced with tasks in here, so dont need workq.h anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.86 2014/09/08 09:32:04 stsp Exp $	*/
d993 2
d1030 2
a1031 1
		if (ext->nprefixes >= ip6_maxifprefixes / 2)
d1033 2
@


1.86
log
@Prevent addition of redundant IPv6 autoconf addresses.
Regression from r1.81 which switched from workq to taskq and incorrectly
assumed duplicate addresses would be impossible with taskq. We ended
up re-adding the SLAAC address whenever a privacy address expired.
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.85 2014/08/26 21:44:29 florian Exp $	*/
a45 1
#include <sys/workq.h>
@


1.85
log
@Do not hand-roll all routers link local address.
pointed out & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.84 2014/08/25 14:00:34 florian Exp $	*/
d1404 3
a1406 2
	struct in6_ifaddr *ia6 = NULL;
	int autoconf, privacy, s;
d1412 37
@


1.84
log
@Move sending of router solicitations to the kernel; receiving and
processing of router advertisements was already in the kernel.
With this rtsol{,d}(8) is no longer necessary.

The kernel starts sending solicitations with
# ifconfig $IF inet6 autoconf
or
inet6 autoconf
in /etc/hostname.$IF.

input stsp@@
much help & OK mpi@@
tweaks & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.83 2014/07/12 18:44:23 tedu Exp $	*/
d224 2
a225 4
	bzero(&ip6->ip6_dst, sizeof(struct in6_addr));

	ip6->ip6_dst.s6_addr16[0] = htons(0xff02);
	ip6->ip6_dst.s6_addr8[15] = 0x02;
@


1.83
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.82 2014/07/11 16:39:06 henning Exp $	*/
d35 1
d174 102
d306 4
@


1.83.4.1
log
@Merge from -current:
Prevent addition of redundant IPv6 autoconf addresses.
Regression from r1.81 which switched from workq to taskq and incorrectly
assumed duplicate addresses would be impossible with taskq. We ended
up re-adding the SLAAC address whenever a privacy address expired.
ok bluhm@@, sthen@@ (for 5.6-stable)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.86 2014/09/08 09:32:04 stsp Exp $	*/
d1299 2
a1300 3
	struct in6_ifaddr *ia6;
	struct ifaddr *ifa;
	int ifa_plen, autoconf, privacy, s;
a1305 37

	/* 
	 * Check again if a non-deprecated address has already
	 * been autoconfigured for this prefix.
	 */
	TAILQ_FOREACH(ifa, &pr->ndpr_ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;

		ia6 = ifatoia6(ifa);

		/*
		 * Spec is not clear here, but I believe we should concentrate
		 * on unicast (i.e. not anycast) addresses.
		 * XXX: other ia6_flags? detached or duplicated?
		 */
		if ((ia6->ia6_flags & IN6_IFF_ANYCAST) != 0)
			continue;

		if ((ia6->ia6_flags & IN6_IFF_AUTOCONF) == 0)
			continue;

		if ((ia6->ia6_flags & IN6_IFF_DEPRECATED) != 0)
			continue;

		ifa_plen = in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL);
		if (ifa_plen == pr->ndpr_plen &&
		    in6_are_prefix_equal(&ia6->ia_addr.sin6_addr,
		    &pr->ndpr_prefix.sin6_addr, ifa_plen)) {
			if ((ia6->ia6_flags & IN6_IFF_PRIVACY) == 0)
				autoconf = 0;
			else
				privacy = 0;
			if (!autoconf && !privacy)
				break;
		}
	}
@


1.82
log
@introduce the IFXF_AUTOCONF6 interface flag which controls wether we
accept rtadvs on that interface. the global net.inet6.ip6.accept_rtadv
sysctl just doesn't cut it, even tho the spec wants that - but in their
little absurd world, a host just has one interface by definition anyway...
the sysctlgoes away.
lots of head scratching, brain cell elemination etc from bluhm benno stsp
florian, excitement from simon and todd, ok bluhm stsp benno florian
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.81 2014/07/11 15:03:17 blambert Exp $	*/
d518 1
a518 1
	free(dr, M_IP6NDP);
d862 1
a862 1
	free(pfr, M_IP6NDP);
d1014 1
a1014 1
		free(pfr, M_IP6NDP);
d1023 1
a1023 1
	free(pr, M_IP6NDP);
@


1.81
log
@move IPv6 prefix adding from workq to taskq; as a happy benefit, we
can delete 2 dozen or so lines that check to see if we've queued
up a prefix addition multiple times.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.80 2014/03/27 10:39:23 mpi Exp $	*/
d111 2
a112 2
	/* If I'm not a router, ignore it. */
	if (ip6_accept_rtadv != 0 || !ip6_forwarding)
d198 2
a199 6
	/*
	 * We only accept RAs only when
	 * the system-wide variable allows the acceptance, and
	 * per-interface variable allows RAs on the receiving interface.
	 */
	if (ip6_accept_rtadv == 0)
d484 2
a485 1
	if (!ip6_forwarding && ip6_accept_rtadv) /* XXX: better condition? */
d623 2
a624 1
	if (ip6_forwarding || !ip6_accept_rtadv) {
d626 2
a627 2
		    "defrouter_select: called unexpectedly (forwarding=%d, "
		    "accept_rtadv=%d)\n", ip6_forwarding, ip6_accept_rtadv));
d647 2
d785 1
a785 1
		if (!ip6_forwarding && ip6_accept_rtadv)
@


1.80
log
@Stop mixing interface address flags with routing entry ones.

Instead of always copying ifa_flags to the routing entry flags when
creating a route by calling rtinit(), explicitly pass the RTF_CLONING
flag when required.  This means ifa_flags are now *only* used to check
if an address has an associated route that was created by the kernel
auto-magically.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.79 2014/03/18 10:47:34 mpi Exp $	*/
d945 2
d1282 2
d1286 1
a1286 1
		if (workq_add_task(NULL, 0, nd6_addr_add, pr, NULL))
d1300 1
a1300 2
	struct ifaddr *ifa;
	int ifa_plen, autoconf, privacy, s;
a1306 38
	/* Because prelist_update() runs in interrupt context it may run
	 * again before this work queue task is run, causing multiple work
	 * queue tasks to be scheduled all of which add addresses for the
	 * same prefix. So check again if a non-deprecated address has already
	 * been autoconfigured for this prefix. */
	TAILQ_FOREACH(ifa, &pr->ndpr_ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;

		ia6 = ifatoia6(ifa);

		/*
		 * Spec is not clear here, but I believe we should concentrate
		 * on unicast (i.e. not anycast) addresses.
		 * XXX: other ia6_flags? detached or duplicated?
		 */
		if ((ia6->ia6_flags & IN6_IFF_ANYCAST) != 0)
			continue;

		if ((ia6->ia6_flags & IN6_IFF_AUTOCONF) == 0)
			continue;

		if ((ia6->ia6_flags & IN6_IFF_DEPRECATED) != 0)
			continue;

		ifa_plen = in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL);
		if (ifa_plen == pr->ndpr_plen &&
		    in6_are_prefix_equal(&ia6->ia_addr.sin6_addr,
		    &pr->ndpr_prefix.sin6_addr, ifa_plen)) {
			if ((ia6->ia6_flags & IN6_IFF_PRIVACY) == 0)
				autoconf = 0;
			else
				privacy = 0;
			if (!autoconf && !privacy)
				break;
		}
	}

d1327 1
@


1.79
log
@Rename rt_gettable() into rtable_get(), swap its arguments to be
coherent with the existing rtable_* functions and document it.

While here fix some other manpage glitches pointed out by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.78 2014/01/23 10:16:30 mpi Exp $	*/
d1633 2
a1634 3
	rtflags = ifa->ifa_flags | RTF_UP;
	if (nd6_need_cache(ifp)) {
		/* explicitly set in case ifa_flags does not set the flag. */
d1636 1
a1636 4
	} else {
		/*
		 * explicitly clear the cloning bit in case ifa_flags sets it.
		 */
a1637 1
	}
@


1.78
log
@Merge two chunks of code to inform listeners of a route change into a
new function, rt_sendmsg().  While here, in the v6 cases, pass the same
rtableid that was used for the request instead of dereferencing a pointer
after checking for it to be NULL.

ok krw@@ on a previous version, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.77 2014/01/13 23:03:52 bluhm Exp $	*/
d1974 1
a1974 1
	struct radix_node_head *rnh = rt_gettable(AF_INET6, ifp->if_rdomain);
@


1.77
log
@Call all local valiables of type struct in6_ifaddr "ia6".  This is
consistent with struct ifaddr "ifa" and struct in_ifaddr "ia".
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.76 2014/01/10 14:29:08 tedu Exp $	*/
a72 1
void nd6_rtmsg(int, struct rtentry *);
a426 21

/* tell the change to user processes watching the routing socket. */
void
nd6_rtmsg(int cmd, struct rtentry *rt)
{
	struct rt_addrinfo info;

	bzero((caddr_t)&info, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
	if (rt->rt_ifp) {
		info.rti_info[RTAX_IFP] =
		    TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
		info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
	}

	rt_missmsg(cmd, &info, rt->rt_flags, rt->rt_ifp, 0,
	    rt->rt_ifp->if_rdomain);
}

d456 1
a456 1
		nd6_rtmsg(RTM_ADD, newrt); /* tell user process */
d560 1
a560 1
		nd6_rtmsg(RTM_DELETE, oldrt);
d1653 1
a1653 1
			nd6_rtmsg(RTM_ADD, rt);
d1715 1
a1715 1
			nd6_rtmsg(RTM_DELETE, rt);
@


1.76
log
@replace the rest of the obsolete radix macros
sprinkle 0 -> NULL where obvious
ok millert mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.75 2014/01/07 17:07:46 mikeb Exp $	*/
d908 1
a908 1
	struct in6_ifaddr *ia;
d928 3
a930 3
			ia = ifatoia6(ifa);
			if ((ia->ia6_flags & IN6_IFF_AUTOCONF) ==
			    IN6_IFF_AUTOCONF && ia->ia6_ndpr == pr) {
d1179 1
a1179 1
		struct in6_ifaddr *ifa6;
d1186 1
a1186 1
		ifa6 = ifatoia6(ifa);
d1193 1
a1193 1
		if ((ifa6->ia6_flags & IN6_IFF_ANYCAST) != 0)
d1196 1
a1196 1
		ifa_plen = in6_mask2len(&ifa6->ia_prefixmask.sin6_addr, NULL);
d1198 1
a1198 1
		    !in6_are_prefix_equal(&ifa6->ia_addr.sin6_addr,
d1203 1
a1203 1
			ia6_match = ifa6;
d1205 1
a1205 1
		if ((ifa6->ia6_flags & IN6_IFF_AUTOCONF) == 0) {
d1233 1
a1233 1
		lt6_tmp = ifa6->ia6_lifetime;
d1236 1
a1236 1
		if (ifa6->ia6_flags & IN6_IFF_PRIVACY) {
d1238 1
a1238 1
			if ((ifa6->ia6_flags & IN6_IFF_DEPRECATED) == 0)
d1245 1
a1245 1
		} else if ((ifa6->ia6_flags & IN6_IFF_DEPRECATED) == 0)
d1251 1
a1251 1
		else if (time_second - ifa6->ia6_updatetime >
d1260 1
a1260 1
				(time_second - ifa6->ia6_updatetime);
d1290 2
a1291 2
		ifa6->ia6_lifetime = lt6_tmp;
		ifa6->ia6_updatetime = time_second;
d1429 1
a1429 1
	struct in6_ifaddr *ifa;
d1535 2
a1536 2
	TAILQ_FOREACH(ifa, &in6_ifaddr, ia_list) {
		if (!(ifa->ia6_flags & IN6_IFF_AUTOCONF))
d1539 1
a1539 1
		if (ifa->ia6_ndpr == NULL) {
d1548 1
a1548 1
		if (find_pfxlist_reachable_router(ifa->ia6_ndpr))
d1551 3
a1553 3
	if (ifa) {
		TAILQ_FOREACH(ifa, &in6_ifaddr, ia_list) {
			if ((ifa->ia6_flags & IN6_IFF_AUTOCONF) == 0)
d1556 1
a1556 1
			if (ifa->ia6_ndpr == NULL) /* XXX: see above. */
d1559 2
a1560 2
			if (find_pfxlist_reachable_router(ifa->ia6_ndpr))
				ifa->ia6_flags &= ~IN6_IFF_DETACHED;
d1562 1
a1562 1
				ifa->ia6_flags |= IN6_IFF_DETACHED;
d1566 2
a1567 2
		TAILQ_FOREACH(ifa, &in6_ifaddr, ia_list) {
			if ((ifa->ia6_flags & IN6_IFF_AUTOCONF) == 0)
d1570 1
a1570 1
			ifa->ia6_flags &= ~IN6_IFF_DETACHED;
d1804 1
a1804 1
	struct in6_ifaddr *ia, *ib;
d1833 1
a1833 1
		ib = ifatoia6(ifa);
d1846 1
a1846 1
	plen0 = in6_mask2len(&ib->ia_prefixmask.sin6_addr, NULL);
d1888 1
a1888 1
		    (ib->ia_addr.sin6_addr.s6_addr32[0] & ~mask.s6_addr32[0]);
d1890 1
a1890 1
		    (ib->ia_addr.sin6_addr.s6_addr32[1] & ~mask.s6_addr32[1]);
d1892 1
a1892 1
		    (ib->ia_addr.sin6_addr.s6_addr32[2] & ~mask.s6_addr32[2]);
d1894 1
a1894 1
		    (ib->ia_addr.sin6_addr.s6_addr32[3] & ~mask.s6_addr32[3]);
d1939 2
a1940 3
	ia = in6ifa_ifpwithaddr(ifp, &ifra.ifra_addr.sin6_addr);

	return (ia);		/* this is always non-NULL */
@


1.75
log
@Propagate an rdomain number to the nd6_lookup independently from
the ifp pointer which can be NULL.  This prevents a crash reported
by David Hill <dhill at mindcry ! org>.  OK bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.74 2013/11/11 09:15:35 mpi Exp $	*/
d245 1
a245 1
	Bzero(&dr0, sizeof(dr0));
d458 4
a461 4
	Bzero(&def, sizeof(def));
	Bzero(&mask, sizeof(mask));
	Bzero(&gate, sizeof(gate)); /* for safety */
	Bzero(&info, sizeof(info));
d563 4
a566 4
	Bzero(&info, sizeof(info));
	Bzero(&def, sizeof(def));
	Bzero(&mask, sizeof(mask));
	Bzero(&gw, sizeof(gw));	/* for safety */
@


1.74
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.73 2013/10/20 11:03:02 phessler Exp $	*/
d672 2
a673 1
		    (rt = nd6_lookup(&dr->rtaddr, 0, dr->ifp)) &&
d701 2
a702 1
	    (rt = nd6_lookup(&installed_dr->rtaddr, 0, installed_dr->ifp)) &&
d1403 1
a1403 1
		    pfxrtr->router->ifp)) &&
@


1.73
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.72 2013/07/01 14:22:20 bluhm Exp $	*/
d110 1
d120 4
a123 2
		    ip6->ip6_hlim, ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&ip6->ip6_dst), ifp->if_xname));
d158 2
a159 1
		    ip6_sprintf(&saddr6), ifp->if_addrlen, lladdrlen - 2));
d197 1
d212 4
a215 2
		    ip6->ip6_hlim, ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&ip6->ip6_dst), ifp->if_xname));
d222 1
a222 1
		    ip6_sprintf(&saddr6)));
d305 2
a306 1
				    ip6_sprintf(&pi->nd_opt_pi_prefix)));
d317 2
a318 1
				    ip6_sprintf(&pi->nd_opt_pi_prefix)));
d357 3
a359 1
			    mtu, ip6_sprintf(&ip6->ip6_src)));
d376 4
a379 1
			    mtu, ip6_sprintf(&ip6->ip6_src), maxmtu));
d400 2
a401 1
		    "(if %d, RA packet %d)\n", ip6_sprintf(&saddr6),
d972 1
d978 2
a979 1
			    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
d1013 1
d1016 2
a1017 1
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
d1062 1
d1105 3
a1107 1
				    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
d1128 2
a1129 1
			    ip6_sprintf(&new->ndpr_prefix.sin6_addr),
d1428 1
d1504 3
a1506 1
				    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
d1517 3
a1519 1
				    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
d1584 1
d1590 3
a1592 1
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr), pr->ndpr_plen));
d1639 2
a1640 1
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
d1676 1
d1680 2
a1681 1
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
d1683 4
a1686 2
		    ip6_sprintf(&satosin6(ifa->ifa_addr)->sin6_addr),
		    ip6_sprintf(&mask6.sin6_addr), rtflags, error));
d1704 1
d1710 3
a1712 1
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr), pr->ndpr_plen));
d1768 3
a1770 1
					    ip6_sprintf(&opr->ndpr_prefix.sin6_addr),
d1781 2
a1782 2
		    ip6_sprintf(&sa6.sin6_addr), pr->ndpr_plen, ifp->if_xname,
		    error));
d1927 2
d1931 3
a1933 2
		    ip6_sprintf(&ifra.ifra_addr.sin6_addr), ifp->if_xname,
		    error));
@


1.72
log
@Do not access queue fields directly, use FOREACH() macro instead.
No binary change.
OK mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.71 2013/07/01 13:06:24 bluhm Exp $	*/
d430 2
a431 1
	rt_missmsg(cmd, &info, rt->rt_flags, rt->rt_ifp, 0, 0);
d1951 1
a1951 1
	struct radix_node_head *rnh = rt_gettable(AF_INET6, 0);
@


1.71
log
@Use the LIST_FOREACH() macro when looping over advertising routers.
No binary change.
OK mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.70 2013/05/31 15:04:25 bluhm Exp $	*/
d893 1
a893 3
	for (pr = nd_prefix.lh_first; pr; pr = pr_next) {
		pr_next = pr->ndpr_next;

d907 1
a907 2
		for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa_next) {
			ifa_next = ifa->ifa_list.tqe_next;
@


1.70
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.69 2013/03/25 14:40:57 mpi Exp $	*/
d1014 1
a1014 3
	for (pfr = LIST_FIRST(&pr->ndpr_advrtrs); pfr != NULL; pfr = next) {
		next = LIST_NEXT(pfr, pfr_entry);

a1015 1
	}
d1378 1
a1378 2
	for (pfxrtr = LIST_FIRST(&pr->ndpr_advrtrs); pfxrtr;
	     pfxrtr = LIST_NEXT(pfxrtr, pfr_entry)) {
@


1.69
log
@Substitute the handcrafted list of IPv6 addresses by a proper TAILQ.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.68 2013/03/11 14:08:04 mpi Exp $	*/
d104 2
a105 2
	struct sockaddr_dl *sdl = (struct sockaddr_dl *)NULL;
	struct llinfo_nd6 *ln = (struct llinfo_nd6 *)NULL;
d454 3
a456 3
	info.rti_info[RTAX_DST] = (struct sockaddr *)&def;
	info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)&gate;
	info.rti_info[RTAX_NETMASK] = (struct sockaddr *)&mask;
d559 3
a561 3
	info.rti_info[RTAX_DST] = (struct sockaddr *)&def;
	info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)&gw;
	info.rti_info[RTAX_NETMASK] = (struct sockaddr *)&mask;
d1640 1
a1640 1
	info.rti_info[RTAX_DST] = (struct sockaddr *)&pr->ndpr_prefix;
d1642 1
a1642 1
	info.rti_info[RTAX_NETMASK] = (struct sockaddr *)&mask6;
d1655 1
a1655 1
		    ip6_sprintf(&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr),
d1693 2
a1694 2
	info.rti_info[RTAX_DST] = (struct sockaddr *)&sa6;
	info.rti_info[RTAX_NETMASK] = (struct sockaddr *)&mask6;
a1974 1
#define SIN6(s)	((struct sockaddr_in6 *)s)
d1982 1
a1982 1
	if (!IN6_ARE_ADDR_EQUAL(gate, &SIN6(rt->rt_gateway)->sin6_addr))
a2005 1
#undef SIN6
@


1.68
log
@Remove unused code manipulating a default interface and its index,
This is a leftover from the on-link assumption behavior removal,
which has been deprecated by RFC4861 anyway.

ok mikeb@@, bluhm@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.67 2013/03/07 09:40:19 mpi Exp $	*/
d1511 1
a1511 1
	for (ifa = in6_ifaddr; ifa; ifa = ifa->ia_next) {
d1528 1
a1528 1
		for (ifa = in6_ifaddr; ifa; ifa = ifa->ia_next) {
d1542 1
a1542 1
		for (ifa = in6_ifaddr; ifa; ifa = ifa->ia_next) {
@


1.67
log
@Remove unused ifa_ifwithaf() function.

ok mikeb@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.66 2013/03/04 14:42:25 bluhm Exp $	*/
a83 3
static struct ifnet *nd6_defifp;
int nd6_defifindex;

a2007 21
}

int
nd6_setdefaultiface(int ifindex)
{
	int error = 0;

	if (ifindex < 0 || if_indexlim <= ifindex)
		return (EINVAL);
	if (ifindex != 0 && !ifindex2ifnet[ifindex])
		return (EINVAL);

	if (nd6_defifindex != ifindex) {
		nd6_defifindex = ifindex;
		if (nd6_defifindex > 0) {
			nd6_defifp = ifindex2ifnet[nd6_defifindex];
		} else
			nd6_defifp = NULL;
	}

	return (error);
@


1.66
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.65 2012/09/26 14:53:23 markus Exp $	*/
a1600 1
		/* XXX: freebsd does not have ifa_ifwithaf */
@


1.65
log
@add M_ZEROIZE as an mbuf flag, so copied PFKEY messages (with embedded keys)
are cleared as well; from hshoexer@@, feedback and ok bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.64 2012/09/07 09:55:18 stsp Exp $	*/
d916 1
a916 1
			ia = (struct in6_ifaddr *)ifa;
d1169 1
a1169 1
		ifa6 = (struct in6_ifaddr *)ifa;
d1318 1
a1318 1
		ia6 = (struct in6_ifaddr *)ifa;
d1800 1
a1800 1
		ib = (struct in6_ifaddr *)ifa;
d1806 1
a1806 1
	if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_NOTREADY) {
@


1.64
log
@Create IPv6 privacy addresses even if static IPv6 addresses are present.
Restores the ability to use privacy addresses for outgoing connections and
static addresses for incoming connections, which was broken by r1.62.
ok sperreault@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.63 2012/09/04 10:03:16 stsp Exp $	*/
d1058 1
a1058 1
		auth = ((m->m_flags & M_AUTH_AH) && (m->m_flags & M_AUTH));
@


1.63
log
@Raise IPL to IPL_SOFTNET in nd6_addr_add(). This code originally ran at
IPL_SOFTNET before it was factored out into a work queue task.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.62 2012/08/28 20:32:02 sperreault Exp $	*/
d1278 2
a1279 1
	    !tempaddr_preferred)) && new->ndpr_vltime != 0 && !statique) {
@


1.62
log
@Do not add SLAAC or privacy addresses when a static address in the same prefix
already exists.

5.1 and older did the right thing.
5.2 did not (mea culpa).
Now we're back to doing the right thing.

spotted by naddy. ok stsp.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.61 2012/08/21 19:50:39 bluhm Exp $	*/
d1301 3
a1303 1
	int ifa_plen, autoconf, privacy;
d1367 2
@


1.61
log
@Reverse the name and meaning of the IFXF_INET6_PRIVACY interface
flag.  It is now called IFXF_INET6_NOPRIVACY.  So IPv6 privacy
addresses are on by default without resetting the flag during
ifconfig down/up.
OK stsp@@, sperreault@@ (who wrote the same diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.60 2012/07/14 17:23:16 sperreault Exp $	*/
d1048 1
a1048 1
	int tempaddr_preferred = 0, autoconf = 0;
d1188 2
a1189 1
		if ((ifa6->ia6_flags & IN6_IFF_AUTOCONF) == 0)
d1191 1
d1278 1
a1278 1
	    !tempaddr_preferred)) && new->ndpr_vltime != 0) {
d1282 2
a1283 1
		 * non-zero. Create new addresses in process context.
@


1.60
log
@Make IPv6 privacy addresses appear alongside regular SLAAC addresses.
Also fix a memory management problem that was made obvious by this diff.

ok bluhm@@, previous version ok @@stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.59 2012/05/18 10:50:07 mikeb Exp $	*/
d1275 1
a1275 1
	if ((!autoconf || ((ifp->if_xflags & IFXF_INET6_PRIVACY) &&
d1301 1
a1301 1
	privacy = (pr->ndpr_ifp->if_xflags & IFXF_INET6_PRIVACY) != 0;
@


1.59
log
@rt6_flush should remove all routes configured via a specified gw,
not only CONNECTED ones.  It should also be called when RA with
a RouterLifetime set to 0 is sent to clear a redirect.

While here make sure we use correct priorities when installing
routes acquired via redirects.

comments & ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.58 2012/01/03 23:41:51 bluhm Exp $	*/
d67 1
a67 1
struct in6_ifaddr *in6_ifadd(struct nd_prefix *);
a921 2
		if (pr->ndpr_refcnt == 0)
			prelist_remove(pr);
d1048 1
a1048 1
	int tempaddr_preferred = 0;
d1226 4
a1229 1
		}
d1275 2
a1276 4
	if ((ia6_match == NULL ||
	    (((ia6_match->ia6_flags & IN6_IFF_PRIVACY) ||
	    (ifp->if_xflags & IFXF_INET6_PRIVACY)) && !tempaddr_preferred)) &&
	    new->ndpr_vltime) {
d1278 3
a1280 3
		 * No address matched, or there is no preferred RFC 4941
		 * temporary address. And the valid prefix lifetime is non-zero.
		 * Create a new address in process context.
d1298 4
a1301 1
	int ifa_plen;
d1332 6
a1337 2
			pr->ndpr_refcnt--;
			return;
d1341 7
a1347 1
	if ((ia6 = in6_ifadd(pr)) != NULL) {
d1349 3
d1353 6
a1358 5
		/*
		 * A newly added address might affect the status
		 * of other addresses, so we check and update it.
		 * XXX: what if address duplication happens?
		 */
d1360 2
a1361 2
	} else
		pr->ndpr_refcnt--;
d1758 1
a1758 1
in6_ifadd(struct nd_prefix *pr)
d1832 1
a1832 1
	if (ifp->if_xflags & IFXF_INET6_PRIVACY) {
d1870 1
a1870 1
	if (ifp->if_xflags & IFXF_INET6_PRIVACY) {
@


1.58
log
@To access the ifaddr of an in_ifaddr or in6_ifaddr struct, it is
cleaner to access the first member via ia_ifa instead of casting.
No binary change.
ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.57 2011/12/27 17:20:04 bluhm Exp $	*/
d462 1
a462 1
	error = rtrequest1(RTM_ADD, &info, RTP_CONNECTED, &newrt,
d566 1
a566 1
	rtrequest1(RTM_DELETE, &info, RTP_CONNECTED, &oldrt,
d791 3
d1986 1
a1986 1
	return (rtrequest1(RTM_DELETE, &info, RTP_CONNECTED, NULL, id));
@


1.57
log
@Instead of hand crafted code, use the macros TAILQ_FOREACH(_SAFE)
and TAILQ_EMPTY for accessing the nd_defrouter list.  No funtional
change.
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.56 2011/11/24 17:39:55 sperreault Exp $	*/
d1571 2
a1572 2
	ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp,
	    IN6_IFF_NOTREADY | IN6_IFF_ANYCAST);
d1771 1
a1771 1
	ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp, 0); /* 0 is OK? */
@


1.56
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.55 2011/02/24 01:25:17 stsp Exp $	*/
d479 2
a480 3
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {
		if (dr->ifp == ifp && IN6_ARE_ADDR_EQUAL(addr, &dr->rtaddr)) {
a481 2
		}
	}
d591 1
a591 2
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry))
d647 1
a647 1
	if (!TAILQ_FIRST(&nd_defrouter)) {
d657 1
a657 2
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {
d817 1
a817 2
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {
a819 1
	}
d1396 1
a1396 1
	if (pr != NULL || TAILQ_FIRST(&nd_defrouter) != NULL) {
@


1.55
log
@Prevent the nd6_addr_add() work queue task from adding multiple addresses
for the same prefix. Tested by giovanni@@, steven@@, Dennis den Brok.
ok dlg miod claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.54 2010/09/24 14:10:52 jsing Exp $	*/
d462 2
a463 1
	error = rtrequest1(RTM_ADD, &info, RTP_CONNECTED, &newrt, 0);
d569 2
a570 1
	rtrequest1(RTM_DELETE, &info, RTP_CONNECTED, &oldrt, 0);
d1628 1
a1628 1
	error = rtrequest1(RTM_ADD, &info, RTP_CONNECTED, &rt, 0);
d1679 2
a1680 1
	error = rtrequest1(RTM_DELETE, &info, RTP_CONNECTED, &rt, 0);
@


1.54
log
@When processing IPv6 RA messages we may end up adding a new IPv6 address
from interrupt context. This results in problems if the process of adding
a new address makes use of pools that use PR_WAITOK (or anything else that
may sleep). To avoid this problem, create a workq task so that the new
IPv6 address is added from within process context.

ok dlg@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.52 2010/04/06 14:12:10 stsp Exp $	*/
d1300 36
@


1.53
log
@Add the rtable id as an argument to rn_walktree(). Functions like
rt_if_remove_rtdelete() need to know the table id to be able to correctly
remove nodes.
Problem found by Andrea Parazzini and analyzed by Martin Pelikn.
OK henning@@
@
text
@d45 1
d80 2
d1046 1
a1046 1
	struct in6_ifaddr *ia6 = NULL, *ia6_match = NULL;
d1283 1
a1283 1
		 * Create a new address.
d1285 3
a1287 17
		if ((ia6 = in6_ifadd(new)) != NULL) {
			/*
			 * note that we should use pr (not new) for reference.
			 */
			pr->ndpr_refcnt++;
			ia6->ia6_ndpr = pr;

			/*
			 * A newly added address might affect the status
			 * of other addresses, so we check and update it.
			 * XXX: what if address duplication happens?
			 */
			pfxlist_onlink_check();
		} else {
			/* just set an error. do not bark here. */
			error = EADDRNOTAVAIL; /* XXX: might be unused. */
		}
d1293 19
@


1.52
log
@Simple implementation of RFC4941, "Privacy Extensions for Stateless
Address Autoconfiguration in IPv6". For those among us who are paranoid
about broadcasting their MAC address to the IPv6 internet.

Man page help from jmc, testing by weerd, arc4random API hints from djm.

ok deraadt, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.51 2010/02/08 11:56:09 jsing Exp $	*/
d77 1
a77 1
int rt6_deleteroute(struct radix_node *, void *);
d1910 1
a1910 1
rt6_deleteroute(struct radix_node *rn, void *arg)
d1943 1
a1943 1
	return (rtrequest1(RTM_DELETE, &info, RTP_CONNECTED, NULL, 0));
@


1.51
log
@Destatic and ansify.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.49 2009/01/30 10:47:46 mcbride Exp $	*/
d60 2
d1049 1
d1216 12
d1272 5
a1276 1
	if (ia6_match == NULL && new->ndpr_vltime) {
d1278 2
a1279 1
		 * No address matched and the valid lifetime is non-zero.
d1706 1
a1706 1
	struct in6_addr mask;
d1773 23
a1795 8
	ifra.ifra_addr.sin6_addr.s6_addr32[0] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[0] & ~mask.s6_addr32[0]);
	ifra.ifra_addr.sin6_addr.s6_addr32[1] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[1] & ~mask.s6_addr32[1]);
	ifra.ifra_addr.sin6_addr.s6_addr32[2] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[2] & ~mask.s6_addr32[2]);
	ifra.ifra_addr.sin6_addr.s6_addr32[3] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[3] & ~mask.s6_addr32[3]);
d1810 8
@


1.50
log
@Mark routers internal as uninstalled after deleting the default route.
This makes it possible to get a new default route by router advertisement
after the old one got deleted (or timed out).

Ok henning@@, claudio@@, mcbride@@
@
text
@d62 10
a71 11
static int rtpref(struct nd_defrouter *);
static struct nd_defrouter *defrtrlist_update(struct nd_defrouter *);
static struct in6_ifaddr *in6_ifadd(struct nd_prefix *);
static struct nd_pfxrouter *pfxrtr_lookup(struct nd_prefix *,
	struct nd_defrouter *);
static void pfxrtr_add(struct nd_prefix *, struct nd_defrouter *);
static void pfxrtr_del(struct nd_pfxrouter *);
static struct nd_pfxrouter *find_pfxlist_reachable_router(struct nd_prefix *);
static void defrouter_delreq(struct nd_defrouter *);
static void nd6_rtmsg(int, struct rtentry *);
static void purge_detached(struct ifnet *);
d73 1
a73 2
static void in6_init_address_ltimes(struct nd_prefix *,
	struct in6_addrlifetime *);
d75 1
a75 1
static int rt6_deleteroute(struct radix_node *, void *);
d413 1
a413 1
static void
d484 1
a484 2
defrtrlist_del(dr)
	struct nd_defrouter *dr;
d535 1
a535 1
static void
d583 1
a583 1
defrouter_reset()
d711 1
a711 1
static int
d738 1
a738 1
static struct nd_defrouter *
d834 1
a834 1
static struct nd_pfxrouter *
d847 1
a847 1
static void
d862 1
a862 1
static void
d886 1
a886 1
static void
d926 1
a926 1
	struct nd_prefix **newp)
d1039 1
a1039 2
prelist_update(struct nd_prefix *new, struct nd_defrouter *dr, 
	struct mbuf *m)
d1291 1
a1291 1
static struct nd_pfxrouter *
d1678 1
a1678 1
static struct in6_ifaddr *
d1821 1
a1821 1
static void
d1866 1
a1866 1
static int
@


1.49
log
@"XXX: should this be performed under splnet()?"... Yes, yes it should.
Interface configuration causes neighbour discoverery, which runs packets
through parts of the stack that require at least splsoftnet(), like pf and
pfsync.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.48 2008/09/17 05:43:15 chl Exp $	*/
d760 3
@


1.48
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.47 2008/06/11 19:00:50 mcbride Exp $	*/
d1686 1
a1686 1
	int error, plen0;
d1782 5
a1786 1
	if ((error = in6_update_ifa(ifp, &ifra, NULL)) != 0) {
@


1.47
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.46 2008/06/11 06:30:36 mcbride Exp $	*/
a1047 1
	int newprefix = 0;
a1101 2

		newprefix = 1;
@


1.46
log
@From KAME, allow adjustable limits on NDP entries and discovered routes.

ok mpf naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.45 2008/05/11 08:13:02 claudio Exp $	*/
d92 1
a92 3
nd6_rs_input(m, off, icmp6len)
	struct	mbuf *m;
	int off, icmp6len;
d178 1
a178 3
nd6_ra_input(m, off, icmp6len)
	struct	mbuf *m;
	int off, icmp6len;
d416 1
a416 3
nd6_rtmsg(cmd, rt)
	int cmd;
	struct rtentry *rt;
d434 1
a434 2
defrouter_addreq(new)
	struct nd_defrouter *new;
d471 1
a471 3
defrouter_lookup(addr, ifp)
	struct in6_addr *addr;
	struct ifnet *ifp;
d539 1
a539 2
defrouter_delreq(dr)
	struct nd_defrouter *dr;
d622 1
a622 1
defrouter_select()
d742 1
a742 2
defrtrlist_update(new)
	struct nd_defrouter *new;
d835 1
a835 3
pfxrtr_lookup(pr, dr)
	struct nd_prefix *pr;
	struct nd_defrouter *dr;
d848 1
a848 3
pfxrtr_add(pr, dr)
	struct nd_prefix *pr;
	struct nd_defrouter *dr;
d863 1
a863 2
pfxrtr_del(pfr)
	struct nd_pfxrouter *pfr;
d870 1
a870 2
nd6_prefix_lookup(pr)
	struct nd_prefix *pr;
d887 1
a887 2
purge_detached(ifp)
	struct ifnet *ifp;
d925 2
a926 3
nd6_prelist_add(pr, dr, newp)
	struct nd_prefix *pr, **newp;
	struct nd_defrouter *dr;
d981 1
a981 2
prelist_remove(pr)
	struct nd_prefix *pr;
d1034 4
d1039 2
a1040 4
prelist_update(new, dr, m)
	struct nd_prefix *new;
	struct nd_defrouter *dr; /* may be NULL */
	struct mbuf *m;
d1296 1
a1296 2
find_pfxlist_reachable_router(pr)
	struct nd_prefix *pr;
d1328 1
a1328 1
pfxlist_onlink_check()
d1473 1
a1473 2
nd6_prefix_onlink(pr)
	struct nd_prefix *pr;
d1588 1
a1588 2
nd6_prefix_offlink(pr)
	struct nd_prefix *pr;
d1683 1
a1683 2
in6_ifadd(pr)
	struct nd_prefix *pr;
d1849 1
a1849 3
rt6_flush(gateway, ifp)
    struct in6_addr *gateway;
    struct ifnet *ifp;
d1867 1
a1867 3
rt6_deleteroute(rn, arg)
	struct radix_node *rn;
	void *arg;
d1905 1
a1905 2
nd6_setdefaultiface(ifindex)
	int ifindex;
@


1.45
log
@rtrequest to rtrequest1 conversion in inet6. With that no rtrequest should
be left over. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.44 2007/10/01 16:39:30 krw Exp $	*/
d72 1
d499 1
d533 6
d756 1
d804 6
d838 2
d903 39
d949 8
d994 2
d1005 1
d1040 6
@


1.44
log
@Last of the really easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'
where obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.43 2007/05/28 23:07:13 pyr Exp $	*/
d442 1
d451 1
d459 5
d465 1
a465 3
	error = rtrequest(RTM_ADD, (struct sockaddr *)&def,
	    (struct sockaddr *)&gate, (struct sockaddr *)&mask,
	    RTF_GATEWAY, &newrt, 0);
d543 1
d552 1
d563 6
a568 3
	rtrequest(RTM_DELETE, (struct sockaddr *)&def,
	    (struct sockaddr *)&gw,
	    (struct sockaddr *)&mask, RTF_GATEWAY, &oldrt, 0);
d574 1
a574 1
			 * rtrequest().
d1422 1
d1495 1
a1495 1
	/* rtrequest() will probably set RTF_UP, but we're not sure. */
d1506 8
a1513 2
	error = rtrequest(RTM_ADD, (struct sockaddr *)&pr->ndpr_prefix,
	    ifa->ifa_addr, (struct sockaddr *)&mask6, rtflags, &rt, 0);
d1538 1
d1562 4
a1565 2
	error = rtrequest(RTM_DELETE, (struct sockaddr *)&sa6, NULL,
	    (struct sockaddr *)&mask6, 0, &rt, 0);
d1823 1
d1848 6
a1853 2
	return (rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway,
	    rt_mask(rt), rt->rt_flags, 0, 0));
@


1.43
log
@typo slipped in, unbreak.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.42 2007/05/28 22:17:21 pyr Exp $	*/
d785 1
a785 1
	n = (struct nd_defrouter *)malloc(sizeof(*n), M_IP6NDP, M_NOWAIT);
a789 1
	bzero(n, sizeof(*n));
d840 1
a840 1
	new = (struct nd_pfxrouter *)malloc(sizeof(*new), M_IP6NDP, M_NOWAIT);
a842 1
	bzero(new, sizeof(*new));
d884 1
a884 1
	new = (struct nd_prefix *)malloc(sizeof(*new), M_IP6NDP, M_NOWAIT);
a886 1
	bzero(new, sizeof(*new));
@


1.42
log
@avoid bypassing sys/queue.h in many places in the kernel.
many assumptions were made about the way the various list types are
implemented.

lots of suggestions and help from otto and miod.
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.41 2006/11/15 03:07:44 itojun Exp $	*/
d962 1
a962 1
	for (pfr = LIST_FIRST(&p->ndpr_advrtrs); pfr != NULL; pfr = next) {
@


1.41
log
@unifdef -USCOPEDROUTING
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.40 2006/06/16 16:49:40 henning Exp $	*/
d44 1
d511 1
a511 1
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
d826 1
a826 1
	for (search = pr->ndpr_advrtrs.lh_first; search; search = search->pfr_next) {
d866 1
a866 1
	for (search = nd_prefix.lh_first; search; search = search->ndpr_next) {
d962 2
a963 2
	for (pfr = pr->ndpr_advrtrs.lh_first; pfr; pfr = next) {
		next = pfr->pfr_next;
d1276 1
a1276 1
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
d1290 1
a1290 1
		for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
d1311 1
a1311 1
		for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
d1331 1
a1331 1
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
d1438 1
a1438 1
	for (opr = nd_prefix.lh_first; opr; opr = opr->ndpr_next) {
d1563 1
a1563 1
		for (opr = nd_prefix.lh_first; opr; opr = opr->ndpr_next) {
@


1.40
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.39 2006/06/16 15:41:19 pascoe Exp $	*/
a453 1
#ifndef SCOPEDROUTING
a454 1
#endif
a552 1
#ifndef SCOPEDROUTING
a553 1
#endif
@


1.39
log
@Spelling.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.38 2006/04/22 19:43:07 claudio Exp $	*/
d434 1
a434 1
	rt_missmsg(cmd, &info, rt->rt_flags, rt->rt_ifp, 0);
d461 1
a461 1
	    RTF_GATEWAY, &newrt);
d561 1
a561 1
	    (struct sockaddr *)&mask, RTF_GATEWAY, &oldrt);
d1502 1
a1502 1
	    ifa->ifa_addr, (struct sockaddr *)&mask6, rtflags, &rt);
d1551 1
a1551 1
	    (struct sockaddr *)&mask6, 0, &rt);
d1834 1
a1834 1
	    rt_mask(rt), rt->rt_flags, 0));
@


1.38
log
@Routes announced via rt_missmsg() do not have rtm_index set. While in most
cases harmless it is used by the IPv6 code. The result is that bgpd is unable
to assigning link local addresses to the correct interface. OK henning@@
Fix for PR 5063.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.37 2006/03/22 14:37:45 henning Exp $	*/
d800 1
a800 1
	 * of router-preferece.  Routers with the same preference are
d897 1
a897 1
	/* initilization */
@


1.37
log
@prevent anything outside rote.c from accessing the routing table heads
directly. rather provide a rt_lookup function for regular lookups,
and a rt_gettable for those that need access to the head for some reason.
the latter cases should be revisted later probably so that nothing outside
the routing core code accesses the heads at all...
tested claudio jolan me, ok claudio markus
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.36 2006/03/05 21:48:57 miod Exp $	*/
d434 1
a434 1
	rt_missmsg(cmd, &info, rt->rt_flags, 0);
@


1.36
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.35 2005/11/29 02:59:42 jolan Exp $	*/
d1788 1
a1788 1
	struct radix_node_head *rnh = rt_tables[AF_INET6];
@


1.35
log
@something in the eurobsdcon route-a-thon broke my simple home network
router so back out the routing stuff to pre-eurobsdcon where my machine
doesn't crash immediately.

i am happy to test diffs and report success/failures but i am not happy
to have instantaneous crashes when i reboot with a new kernel that was
compiled from pristine sources.

if you are going to be an elitist asshole then you could at least make
sure your code works.

ok and "be crass towards them" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.33 2004/11/17 03:22:31 itojun Exp $	*/
d1104 1
a1104 2
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
	{
d1462 1
a1462 4
		for (ifa = ifp->if_addrlist.tqh_first;
		     ifa;
		     ifa = ifa->ifa_list.tqe_next)
		{
@


1.34
log
@don't let anything outside route.c access the routing table heads directly,
but go through a provided wrapper.
also provide rt_lookup() instead of doing the lookup manually in many places.
ryan ok
@
text
@d1792 1
a1792 1
	struct radix_node_head *rnh = rt_gettable(AF_INET6, 0);
@


1.33
log
@wrong paren.  Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.32 2004/10/28 08:43:03 itojun Exp $	*/
d1792 1
a1792 1
	struct radix_node_head *rnh = rt_tables[AF_INET6];
@


1.32
log
@remove onlink assumption behavior (consider destination on-link if default
router list is empty) based on recent IETF ipv6 discussion (RFC2461 5.2).

fix "ndp -I delete".

markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.31 2004/06/21 23:50:37 tholo Exp $	*/
d1431 2
a1432 2
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr), pr->ndpr_plen);
		return (EEXIST));
@


1.31
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.30 2003/12/10 03:30:21 itojun Exp $	*/
a69 2
static void defrouter_addifreq(struct ifnet *);
static void defrouter_delifreq(void);
a80 1
static struct ifaddr *nd6_defif_installed = NULL;
a471 96
/* Add a route to a given interface as default */
static void
defrouter_addifreq(ifp)
	struct ifnet *ifp;
{
	struct sockaddr_in6 def, mask;
	struct ifaddr *ifa;
	struct rtentry *newrt = NULL;
	int error, flags;
	struct rt_addrinfo info;

	/* remove one if we have already installed one */
	if (nd6_defif_installed)
		defrouter_delifreq();

	bzero(&def, sizeof(def));
	bzero(&mask, sizeof(mask));

	def.sin6_len = mask.sin6_len = sizeof(struct sockaddr_in6);
	def.sin6_family = mask.sin6_family = AF_INET6;

	/*
	 * Search for an ifaddr beloging to the specified interface.
	 * XXX: An IPv6 address are required to be assigned on the interface.
	 */
	if ((ifa = ifaof_ifpforaddr((struct sockaddr *)&def, ifp)) == NULL) {
		nd6log((LOG_ERR,	/* better error? */
		    "defrouter_addifreq: failed to find an ifaddr "
		    "to install a route to interface %s\n",
		    ifp->if_xname));
		return;
	}

	/* RTF_CLONING is necessary to make sure to perform ND */
	flags = ifa->ifa_flags | RTF_CLONING;
	bzero(&info, sizeof(info));
	info.rti_info[RTAX_DST] = (struct sockaddr *)&def;
	info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)ifa->ifa_addr;
	info.rti_info[RTAX_NETMASK] = (struct sockaddr *)&mask;
	info.rti_info[RTAX_IFA] = (struct sockaddr *)ifa->ifa_addr;
	info.rti_flags = flags;
	error = rtrequest1(RTM_ADD, &info, &newrt);
	if (error != 0) {
		nd6log((LOG_ERR,
		    "defrouter_addifreq: failed to install a route to "
		    "interface %s (errno = %d)\n",
		    ifp->if_xname, error));

		if (newrt)	/* maybe unnecessary, but do it for safety */
			newrt->rt_refcnt--;
	} else {
		if (newrt) {
			nd6_rtmsg(RTM_ADD, newrt);
			newrt->rt_refcnt--;
		}
	}

	nd6_defif_installed = ifa;
	ifa->ifa_refcnt++;
}

/* Remove a default route points to interface */
static void
defrouter_delifreq()
{
	struct sockaddr_in6 def, mask;
	struct rtentry *oldrt = NULL;

	if (!nd6_defif_installed)
		return;

	Bzero(&def, sizeof(def));
	Bzero(&mask, sizeof(mask));

	def.sin6_len = mask.sin6_len = sizeof(struct sockaddr_in6);
	def.sin6_family = mask.sin6_family = AF_INET6;

	rtrequest(RTM_DELETE, (struct sockaddr *)&def,
	    (struct sockaddr *)nd6_defif_installed->ifa_addr,
	    (struct sockaddr *)&mask, RTF_GATEWAY, &oldrt);
	if (oldrt) {
		nd6_rtmsg(RTM_DELETE, oldrt);
		if (oldrt->rt_refcnt <= 0) {
			/*
			 * XXX: borrowed from the RTM_DELETE case of
			 * rtrequest().
			 */
			oldrt->rt_refcnt++;
			rtfree(oldrt);
		}
	}

	IFAFREE(nd6_defif_installed);
	nd6_defif_installed = NULL;
}

a587 1
	defrouter_delifreq();
d640 1
a640 2
	 * If default router list is empty, we should probably install
	 * an interface route and assume that all destinations are on-link.
a642 26
		/*
		 * XXX: The specification does not say this mechanism should
		 * be restricted to hosts, but this would be not useful
		 * (even harmful) for routers.
		 * This test is meaningless due to a test at the beginning of
		 * the function, but we intentionally keep it to make the note
		 * clear.
		 */
		if (!ip6_forwarding) {
			if (nd6_defifp) {
				/*
				 * Install a route to the default interface
				 * as default route.
				 */
				defrouter_addifreq(nd6_defifp);
			} else {
				/*
				 * purge the existing route.
				 * XXX: is this really correct?
				 */
				defrouter_delifreq();
				nd6log((LOG_INFO, "defrouter_select: "
				    "there's no default router and no default"
				    " interface\n"));
			}
		}
a647 7
	 * If we have a default route for the default interface, delete it.
	 * Note that the existence of the route is checked in the delete
	 * function.
	 */
	defrouter_delifreq();

	/*
d1848 3
a1850 1
	if (ifindex < 0 || if_indexlim <= ifindex || !ifindex2ifnet[ifindex])
a1858 5

		/*
		 * Rescan default router list, refresh default route(s).
		 */
		defrouter_select();
@


1.30
log
@use if_indexlim (instead of if_index) and ifindex2ifnet[x] != NULL
to check if interface exists, as (1) if_index will have different meaning
(2) ifindex2ifnet could become NULL when interface gets destroyed,
when we introduce dynamically-created interfaces.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.29 2003/09/26 21:43:32 miod Exp $	*/
d247 1
a247 1
	dr0.expire = time.tv_sec + dr0.rtlifetime;
d331 1
a331 1
			pr.ndpr_lastupdate = time.tv_sec;
d1295 1
a1295 1
		else if (time.tv_sec - ifa6->ia6_updatetime >
d1304 1
a1304 1
				(time.tv_sec - ifa6->ia6_updatetime);
d1335 1
a1335 1
		ifa6->ia6_updatetime = time.tv_sec;
d1885 1
a1885 1
		ndpr->ndpr_preferred = time.tv_sec + ndpr->ndpr_pltime;
d1889 1
a1889 1
		ndpr->ndpr_expire = time.tv_sec + ndpr->ndpr_vltime;
d1903 1
a1903 1
		lt6->ia6t_expire = time.tv_sec;
d1911 1
a1911 1
		lt6->ia6t_preferred = time.tv_sec;
@


1.29
log
@Typos: defintion -> definition, proccess -> process

There are more occurences hiding in binutils, lynx and afs but I am too
lazy to report them upstream at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.28 2003/06/24 07:55:12 itojun Exp $	*/
d1982 1
a1982 1
	if (ifindex < 0 || if_index < ifindex)
@


1.28
log
@remove unneeded checks of accept_rtadv.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.27 2003/06/24 07:47:54 itojun Exp $	*/
d416 1
a416 1
 * default router list proccessing sub routines
@


1.27
log
@use time.tv_sec directly, rather than having time_second (freebsd NIH).
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.26 2003/05/15 15:00:43 itojun Exp $	*/
d115 1
a115 1
	if (ip6_accept_rtadv != 0 || ip6_forwarding != 1)
@


1.26
log
@rt->rt_ifp may not always be available.  masanori kanaoka via kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.25 2003/05/14 14:24:44 itojun Exp $	*/
a241 1
	long time_second = time.tv_sec;
d247 1
a247 1
	dr0.expire = time_second + dr0.rtlifetime;
a272 1
		long time_second = time.tv_sec;
d331 1
a331 1
			pr.ndpr_lastupdate = time_second;
a1242 1
		long time_second = time.tv_sec;
d1295 1
a1295 1
		else if (time_second - ifa6->ia6_updatetime >
d1304 1
a1304 1
				(time_second - ifa6->ia6_updatetime);
d1335 1
a1335 1
		ifa6->ia6_updatetime = time_second;
a1873 1
	long time_second = time.tv_sec;
d1885 1
a1885 1
		ndpr->ndpr_preferred = time_second + ndpr->ndpr_pltime;
d1889 1
a1889 1
		ndpr->ndpr_expire = time_second + ndpr->ndpr_vltime;
a1896 1
	long time_second = time.tv_sec;
d1903 1
a1903 1
		lt6->ia6t_expire = time_second;
d1911 1
a1911 1
		lt6->ia6t_preferred = time_second;
@


1.25
log
@make PULLDOWN_TEST codepath the default (has been default for a long time).
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.24 2003/05/13 02:25:08 itojun Exp $	*/
d433 5
a437 3
	info.rti_info[RTAX_IFP] =
	    TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
	info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
@


1.24
log
@corrected the pointer value for ifp nd6_rtmsg
(from KIU Shueng Chuan)
ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.23 2002/09/11 03:15:36 itojun Exp $	*/
a133 4
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_rs = (struct nd_router_solicit *)((caddr_t)ip6 + off);
#else
a138 1
#endif
a223 4
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_ra = (struct nd_router_advert *)((caddr_t)ip6 + off);
#else
a228 1
#endif
@


1.23
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.22 2002/07/30 23:30:08 itojun Exp $	*/
d444 1
a444 1
	    (struct sockaddr *)TAILQ_FIRST(&rt->rt_ifp->if_addrlist);
@


1.22
log
@remove unneeded NULL pointer checks.
From: tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.21 2002/06/09 14:38:39 itojun Exp $	*/
d591 1
a591 1
			return(dr);
d595 1
a595 1
	return(NULL);		/* search failed */
d906 1
a906 1
				return(dr);
d923 1
a923 1
		return(dr);
d929 1
a929 1
		return(NULL);
d935 1
a935 1
		return(NULL);
d963 1
a963 1
	return(n);
d978 1
a978 1
	return(search);
d1022 1
a1022 1
	return(search);
d1399 1
a1399 1
	return(pfxrtr);
d1577 1
a1577 1
		return(EEXIST));
d1597 1
a1597 1
			return(0);
d1629 1
a1629 1
		return(0);
d1669 1
a1669 1
	return(error);
d1687 1
a1687 1
		return(EEXIST);
d1762 1
a1762 1
	return(error);
d1874 1
a1874 1
		return(NULL);	/* ifaddr must not have been allocated. */
d1879 1
a1879 1
	return(ia);		/* this is always non-NULL */
d1964 1
a1964 1
		return(0);
d1967 1
a1967 1
		return(0);
d1975 1
a1975 1
		return(0);
d1982 1
a1982 1
		return(0);
d1984 1
a1984 1
	return(rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway,
d1996 1
a1996 1
		return(EINVAL);
d2011 1
a2011 1
	return(error);
@


1.21
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.20 2002/06/09 00:59:29 itojun Exp $	*/
d651 5
d669 1
a669 1
	    dr ? (struct sockaddr *)&gw : NULL,
d683 1
a683 2
	if (dr)
		dr->installed = 0;
@


1.20
log
@change M_AUTHxx to openbsd definition (M_AUTH_AH)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.19 2002/06/08 21:51:08 itojun Exp $	*/
d207 1
a207 1
	 * per-interface variable allows RAs on the receiving interface.  
d387 1
a387 1
	
d394 1
a394 1
	
d696 1
a696 1
	 * XXX should we also nuke any default routers in the kernel, by 
d821 1
a821 1
 			selected_dr = TAILQ_NEXT(installed_dr, dr_entry);
d845 1
a845 1
/* 
d847 1
a847 1
 * regards router-preference field as a 2-bit signed integer 
d896 1
a896 1
			/* 
d958 1
a958 1
		
d968 1
a968 1
	
d1238 1
a1238 1
 	/*
d1263 1
a1263 1
		
d1597 1
a1597 1
	 * We prefer link-local addresses as the associated interface address. 
d1787 1
a1787 1
	 * (3) a user can prevent autoconfiguration of global address 
d1845 1
a1845 1
	    
d1855 1
a1855 1
	 * We should reconsider this logic. 
@


1.19
log
@splnet -> splsoftnet where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.18 2002/06/08 21:22:41 itojun Exp $	*/
d1139 1
a1139 4
#if defined(M_AUTHIPHDR) && defined(M_AUTHIPDGM)
		auth = (m->m_flags & M_AUTHIPHDR
		     && m->m_flags & M_AUTHIPDGM) ? 1 : 0;
#endif
@


1.18
log
@remove #ifdef __NetBSD__
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.17 2002/06/08 21:22:03 itojun Exp $	*/
d471 1
a471 1
	s = splnet();
d725 1
a725 1
	int s = splnet();
d881 1
a881 1
	int s = splnet();
d1045 1
a1045 1
	s = splnet();
d1099 1
a1099 1
	s = splnet();
d1127 1
a1127 1
	int s = splnet();
d1939 1
a1939 1
	int s = splnet();
@


1.17
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.16 2002/06/08 00:06:58 itojun Exp $	*/
a1098 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
a1099 1
#endif
@


1.16
log
@in6_len2mask is a duplicate of in6_prefixlen2mask.  unify.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.15 2002/06/07 03:06:15 itojun Exp $	*/
d61 1
d63 1
a63 4
static int prelist_add(struct nd_prefix *, struct nd_defrouter *);
static struct nd_prefix *prefix_lookup(struct nd_prefix *);
static struct in6_ifaddr *in6_ifadd(struct ifnet *, struct in6_addr *,
			  struct in6_addr *, int);
d65 1
a65 1
					       struct nd_defrouter *);
d69 1
a69 2
static void nd6_detach_prefix(struct nd_prefix *);
static void nd6_attach_prefix(struct nd_prefix *);
d71 2
d74 2
a75 3
static void in6_init_address_ltimes(struct nd_prefix *ndpr,
					 struct in6_addrlifetime *lt6,
					 int update_vltime);
d81 1
a81 1
struct ifnet *nd6_defifp;
d83 1
d163 1
a163 1
			ip6_sprintf(&saddr6), ifp->if_addrlen, lladdrlen - 2));
d204 5
d211 2
d254 1
d282 1
a282 1
		struct nd_opt_prefix_info *pi;
d284 1
d337 1
a337 1
					      ND_OPT_PI_FLAG_ONLINK) ? 1 : 0;
d339 1
a339 1
					    ND_OPT_PI_FLAG_AUTO) ? 1 : 0;
d342 2
a343 2
			pr.ndpr_pltime =
				ntohl(pi->nd_opt_pi_preferred_time);
d356 1
a356 1
		u_int32_t mtu = ntohl(ndopts.nd_opts_mtu->nd_opt_mtu_mtu);
d359 2
d364 1
a364 1
			    "mtu=%d sent from %s, ignoring\n",
d380 1
a380 1
			    "mtu=%d sent from %s; "
d430 20
d455 1
d457 1
d461 1
a461 1
	Bzero(&gate, sizeof(gate));
d463 2
a464 2
	def.sin6_len = mask.sin6_len = gate.sin6_len
		= sizeof(struct sockaddr_in6);
d467 3
d472 9
a480 3
	(void)rtrequest(RTM_ADD, (struct sockaddr *)&def,
		(struct sockaddr *)&gate, (struct sockaddr *)&mask,
		RTF_GATEWAY, NULL);
d492 1
d494 5
d513 2
a514 1
		    "to install a route to interface %s\n", ifp->if_xname));
d518 10
a527 6
	flags = ifa->ifa_flags;
	if ((ifp->if_flags & IFF_POINTOPOINT) != 0)
		flags &= ~RTF_CLONING;
	if ((error = rtrequest(RTM_ADD, (struct sockaddr *)&def,
			       ifa->ifa_addr, (struct sockaddr *)&mask,
			       flags, NULL)) != 0) {
d532 8
d541 38
d590 1
a590 1
		if (dr->ifp == ifp && IN6_ARE_ADDR_EQUAL(addr, &dr->rtaddr))
d592 1
a598 25
defrouter_delreq(dr, dofree)
	struct nd_defrouter *dr;
	int dofree;
{
	struct sockaddr_in6 def, mask, gate;

	Bzero(&def, sizeof(def));
	Bzero(&mask, sizeof(mask));
	Bzero(&gate, sizeof(gate));

	def.sin6_len = mask.sin6_len = gate.sin6_len
		= sizeof(struct sockaddr_in6);
	def.sin6_family = mask.sin6_family = gate.sin6_family = AF_INET6;
	gate.sin6_addr = dr->rtaddr;

	rtrequest(RTM_DELETE, (struct sockaddr *)&def,
		  (struct sockaddr *)&gate,
		  (struct sockaddr *)&mask,
		  RTF_GATEWAY, (struct rtentry **)0);

	if (dofree)		/* XXX: necessary? */
		free(dr, M_IP6NDP);
}

void
d609 1
a609 2
	if (!ip6_forwarding && ip6_accept_rtadv) {
		/* above is a good condition? */
d611 4
a615 4

	if (dr == TAILQ_FIRST(&nd_defrouter))
		deldr = dr;	/* The router is primary. */

d640 67
a706 3
 * Default Router Selection according to Section 6.3.6 of RFC 2461:
 * 1) Routers that are reachable or probably reachable should be
 *    preferred.
d709 1
a709 1
 *    fashion.
d712 9
d726 1
a726 1
	struct nd_defrouter *dr, anydr;
d731 4
a734 1
	 * Search for a (probably) reachable router from the list.
d736 6
a741 10
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {
		if ((rt = nd6_lookup(&dr->rtaddr, 0, dr->ifp)) &&
		    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
		    ND6_IS_LLINFO_PROBREACH(ln)) {
			/* Got it, and move it to the head */
			TAILQ_REMOVE(&nd_defrouter, dr, dr_entry);
			TAILQ_INSERT_HEAD(&nd_defrouter, dr, dr_entry);
			break;
		}
d744 6
a749 13
	if ((dr = TAILQ_FIRST(&nd_defrouter))) {
		/*
		 * De-install the previous default gateway and install
		 * a new one.
		 * Note that if there is no reachable router in the list,
		 * the head entry will be used anyway.
		 * XXX: do we have to check the current routing table entry?
		 */
		bzero(&anydr, sizeof(anydr));
		defrouter_delreq(&anydr, 0);
		defrouter_addreq(dr);
	}
	else {
a750 2
		 * The Default Router List is empty, so install the default
		 * route to an inteface.
d754 3
a758 6
			/*
			 * De-install the current default route
			 * in advance.
			 */
			bzero(&anydr, sizeof(anydr));
			defrouter_delreq(&anydr, 0);
a762 4
				 * XXX: we enable this for host only, because
				 * this may override a default route installed
				 * a user process (e.g. routing daemon) in a
				 * router case.
d766 5
d776 63
d845 31
d889 2
d895 22
d936 1
d938 4
a941 3
	 * Insert the new router at the end of the Default Router List.
	 * If there is no other router, install it anyway. Otherwise,
	 * just continue to use the current default router.
d943 14
a956 3
	TAILQ_INSERT_TAIL(&nd_defrouter, n, dr_entry);
	if (TAILQ_FIRST(&nd_defrouter) == n)
		defrouter_select();
d1003 2
a1004 2
static struct nd_prefix *
prefix_lookup(pr)
d1013 1
a1013 3
					 &search->ndpr_prefix.sin6_addr,
					 pr->ndpr_plen)
		    ) {
d1021 3
a1023 3
static int
prelist_add(pr, dr)
	struct nd_prefix *pr;
d1026 1
a1026 1
	struct nd_prefix *new;
d1034 2
a1037 1
	new->ndpr_statef_onlink = pr->ndpr_statef_onlink;
d1043 1
a1043 3
			new->ndpr_mask.s6_addr32[i];

	/* xxx ND_OPT_PI_FLAG_ONLINK processing */
a1045 1

d1050 13
d1074 24
a1097 1
	int s;
d1099 3
d1103 1
a1120 6
/*
 * NOTE: We set address lifetime to keep
 *	address lifetime <= prefix lifetime
 * invariant.  This is to simplify on-link determination code.
 * If onlink determination is udated, this routine may have to be updated too.
 */
d1127 3
a1129 1
	struct in6_ifaddr *ia6 = NULL;
a1131 1

d1133 1
d1135 1
a1135 1
	struct in6_addrlifetime *lt6;
d1149 46
a1194 3
	if ((pr = prefix_lookup(new)) != NULL) {
		if (pr->ndpr_ifp != new->ndpr_ifp) {
			error = EADDRNOTAVAIL;
d1196 12
a1208 6
		/* update prefix information */
		pr->ndpr_flags = new->ndpr_flags;
		pr->ndpr_vltime = new->ndpr_vltime;
		pr->ndpr_pltime = new->ndpr_pltime;
		pr->ndpr_preferred = new->ndpr_preferred;
		pr->ndpr_expire = new->ndpr_expire;
d1211 5
a1215 2
		 * RFC 2462 5.5.3 (d) or (e)
		 * We got a prefix which we have seen in the past.
d1217 13
a1229 2
		if (!new->ndpr_raf_auto)
			goto noautoconf1;
d1231 3
a1233 4
		if (IN6_IS_ADDR_UNSPECIFIED(&pr->ndpr_addr))
			ia6 = NULL;
		else
			ia6 = in6ifa_ifpwithaddr(pr->ndpr_ifp, &pr->ndpr_addr);
d1235 4
a1238 27
		if (ia6 == NULL) {
			/*
			 * Special case:
			 * (1) We have seen the prefix advertised before, but
			 * we have never performed autoconfig for this prefix.
			 * This is because Autonomous bit was 0 previously, or
			 * autoconfig failed due to some other reasons.
			 * (2) We have seen the prefix advertised before and
			 * we have performed autoconfig in the past, but
			 * we seem to have no interface address right now.
			 * This is because the interface address have expired.
			 *
			 * This prefix is fresh, with respect to autoconfig
			 * process.
			 *
			 * Add an address based on RFC 2462 5.5.3 (d).
			 */
			ia6 = in6_ifadd(pr->ndpr_ifp,
				&pr->ndpr_prefix.sin6_addr, &pr->ndpr_addr,
				new->ndpr_plen);
			if (!ia6) {
				error = EADDRNOTAVAIL;
				nd6log((LOG_ERR,
				    "prelist_update: failed to add a "
				    "new address\n"));
				goto noautoconf1;
			}
d1240 4
a1243 1
			lt6 = &ia6->ia6_lifetime;
d1245 12
a1256 15
			/* address lifetime <= prefix lifetime */
			lt6->ia6t_vltime = new->ndpr_vltime;
			lt6->ia6t_pltime = new->ndpr_pltime;
			in6_init_address_ltimes(new, lt6, 1);
		} else {
#define TWOHOUR		(120*60)
			/*
			 * We have seen the prefix before, and we have added
			 * interface address in the past.  We still have
			 * the interface address assigned.
			 *
			 * update address lifetime based on RFC 2462
			 * 5.5.3 (e).
			 */
			int update = 0;
d1258 2
a1259 1
			lt6 = &ia6->ia6_lifetime;
d1261 1
a1261 15
#if 0	/* RFC 2462 5.5.3 (e) */
			lt6->ia6t_pltime = new->ndpr_pltime;
			if (TWOHOUR < new->ndpr_vltime
			 || lt6pr->nd < new->ndpr_vltime) {
				lt6->ia6t_vltime = new->ndpr_vltime;
				update++;
			} else if (auth
				&& lt6->ia6t_vltime <= TWOHOUR0
				&& new->ndpr_vltime <= lt6->ia6t_vltime) {
				lt6->ia6t_vltime = new->ndpr_vltime;
				update++;
			} else {
				lt6->ia6t_vltime = TWOHOUR;
				update++;
			}
d1263 13
a1275 12
			/* 2 hour rule is not imposed for pref lifetime */
			new->ndpr_apltime = new->ndpr_pltime;
			lt6->ia6t_pltime = new->ndpr_pltime;
#else	/* update from Jim Bound, (ipng 6712) */
			if (TWOHOUR < new->ndpr_vltime
			 || lt6->ia6t_vltime < new->ndpr_vltime) {
				lt6->ia6t_vltime = new->ndpr_vltime;
				update++;
			} else if (auth) {
				lt6->ia6t_vltime = new->ndpr_vltime;
				update++;
			}
d1277 2
a1278 5
			/* jim bound rule is not imposed for pref lifetime */
			lt6->ia6t_pltime = new->ndpr_pltime;
#endif
			in6_init_address_ltimes(new, lt6, update);
		}
d1280 2
a1281 1
 noautoconf1:
d1283 40
d1324 17
a1340 7
		/* address lifetime expire processing, RFC 2462 5.5.4. */
		if (pr->ndpr_preferred && pr->ndpr_preferred < time_second) {
			struct in6_ifaddr *ia6;

			ia6 = in6ifa_ifpwithaddr(pr->ndpr_ifp, &pr->ndpr_addr);
			if (ia6)
				ia6->ia6_flags &= ~IN6_IFF_DEPRECATED;
a1341 1
#endif
d1343 2
a1344 4
		if (dr && pfxrtr_lookup(pr, dr) == NULL)
			pfxrtr_add(pr, dr);
	} else {
		int error_tmp;
d1346 1
a1346 3
		if (new->ndpr_vltime == 0) goto end;

		bzero(&new->ndpr_addr, sizeof(struct in6_addr));
d1348 4
d1353 2
a1354 4
		 * RFC 2462 5.5.3 (d)
		 * We got a fresh prefix.  Perform some sanity checks
		 * and add an interface address by appending interface ID
		 * to the advertised prefix.
d1356 6
a1361 2
		if (!new->ndpr_raf_auto)
			goto noautoconf2;
d1363 10
a1372 21
		ia6 = in6_ifadd(new->ndpr_ifp, &new->ndpr_prefix.sin6_addr,
			  &new->ndpr_addr, new->ndpr_plen);
		if (!ia6) {
			error = EADDRNOTAVAIL;
			nd6log((LOG_ERR, "prelist_update: "
				"failed to add a new address\n"));
			goto noautoconf2;
		}
		/* set onlink bit if an interface route is configured */
		new->ndpr_statef_onlink = (ia6->ia_flags & IFA_ROUTE) ? 1 : 0;

		lt6 = &ia6->ia6_lifetime;

		/* address lifetime <= prefix lifetime */
		lt6->ia6t_vltime = new->ndpr_vltime;
		lt6->ia6t_pltime = new->ndpr_pltime;
		in6_init_address_ltimes(new, lt6, 1);

 noautoconf2:
		error_tmp = prelist_add(new, dr);
		error = error_tmp ? error_tmp : error;
d1396 1
a1396 1
				     pfxrtr->router->ifp)) &&
a1402 1

d1407 2
a1408 2
 * that advertised the prefix (A router is "available" if its neighbor cache
 * entry has reachable or probably reachable).
d1411 4
a1414 4
 * been expired yet. So we should not use the prefix if there is another
 * prefix that has an available router.
 * But if there is no prefix that has an available router, we still regards
 * all the prefixes as on-link. This is because we can't tell if all the
d1422 1
d1429 1
a1429 1
		if (find_pfxlist_reachable_router(pr))
d1432 1
a1432 2

	if (pr) {
d1434 7
a1440 5
		 * There is at least one prefix that has a reachable router.
		 * First, detach prefixes which has no reachable advertising
		 * router and then attach other prefixes.
		 * The order is important since an attached prefix and a
		 * detached prefix may have a same interface route.
d1443 57
a1499 4
			if (find_pfxlist_reachable_router(pr) == NULL &&
			    pr->ndpr_statef_onlink) {
				pr->ndpr_statef_onlink = 0;
				nd6_detach_prefix(pr);
d1502 49
a1550 4
		for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
			if (find_pfxlist_reachable_router(pr) &&
			    pr->ndpr_statef_onlink == 0)
				nd6_attach_prefix(pr);
d1554 6
a1559 4
		/* there is no prefix that has a reachable router */
		for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next)
			if (pr->ndpr_statef_onlink == 0)
				nd6_attach_prefix(pr);
d1563 2
a1564 2
static void
nd6_detach_prefix(pr)
d1567 67
a1633 2
	struct in6_ifaddr *ia6;
	struct sockaddr_in6 sa6, mask6;
d1636 2
a1637 1
	 * Delete the interface route associated with the prefix.
d1639 54
d1697 1
a1697 1
	      sizeof(struct in6_addr));
d1702 8
a1709 2
	{
		int e;
d1711 10
a1720 11
		e = rtrequest(RTM_DELETE, (struct sockaddr *)&sa6, NULL,
			      (struct sockaddr *)&mask6, 0, NULL);
		if (e) {
			nd6log((LOG_ERR,
			    "nd6_detach_prefix: failed to delete route: "
			    "%s/%d (errno = %d)\n",
			    ip6_sprintf(&sa6.sin6_addr),
			    pr->ndpr_plen,
			    e));
		}
	}
d1722 2
a1723 11
	/*
	 * Mark the address derived from the prefix detached so that
	 * it won't be used as a source address for a new connection.
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&pr->ndpr_addr))
		ia6 = NULL;
	else
		ia6 = in6ifa_ifpwithaddr(pr->ndpr_ifp, &pr->ndpr_addr);
	if (ia6)
		ia6->ia6_flags |= IN6_IFF_DETACHED;
}
d1725 6
a1730 6
static void
nd6_attach_prefix(pr)
	struct nd_prefix *pr;
{
	struct ifaddr *ifa;
	struct in6_ifaddr *ia6;
d1732 18
a1749 7
	/*
	 * Add the interface route associated with the prefix(if necessary)
	 * Should we consider if the L bit is set in pr->ndpr_flags?
	 */
	ifa = ifaof_ifpforaddr((struct sockaddr *)&pr->ndpr_prefix,
			       pr->ndpr_ifp);
	if (ifa == NULL) {
d1751 4
a1754 3
		    "nd6_attach_prefix: failed to find any ifaddr"
		    " to add route for a prefix(%s/%d)\n",
		    ip6_sprintf(&pr->ndpr_addr), pr->ndpr_plen));
a1755 3
	else {
		int e;
		struct sockaddr_in6 mask6;
d1757 5
a1761 14
		bzero(&mask6, sizeof(mask6));
		mask6.sin6_family = AF_INET6;
		mask6.sin6_len = sizeof(mask6);
		mask6.sin6_addr = pr->ndpr_mask;
		e = rtrequest(RTM_ADD, (struct sockaddr *)&pr->ndpr_prefix,
			      ifa->ifa_addr, (struct sockaddr *)&mask6,
			      ifa->ifa_flags, NULL);
		if (e == 0)
			pr->ndpr_statef_onlink = 1;
		else {
			nd6log((LOG_ERR,
			    "nd6_attach_prefix: failed to add route for"
			    " a prefix(%s/%d), errno = %d\n",
			    ip6_sprintf(&pr->ndpr_addr), pr->ndpr_plen, e));
d1765 1
a1765 13
	/*
	 * Now the address derived from the prefix can be used as a source
	 * for a new connection, so clear the detached flag.
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&pr->ndpr_addr))
		ia6 = NULL;
	else
		ia6 = in6ifa_ifpwithaddr(pr->ndpr_ifp, &pr->ndpr_addr);
	if (ia6) {
		ia6->ia6_flags &= ~IN6_IFF_DETACHED;
		if (pr->ndpr_statef_onlink)
			ia6->ia_flags |= IFA_ROUTE;
	}
d1769 2
a1770 5
in6_ifadd(ifp, in6, addr, prefixlen)
	struct ifnet *ifp;
	struct in6_addr *in6;
	struct in6_addr *addr;
	int prefixlen;	/* prefix len of the new prefix in "in6" */
d1772 1
d1774 3
a1776 2
	struct in6_ifaddr *ia, *ib, *oia;
	int s, error;
d1778 1
d1782 21
a1802 2
	/* find link-local address (will be interface ID) */
	ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp, 0);/* 0 is OK? */
d1817 5
a1821 5
	if (prefixlen != in6_mask2len(&ib->ia_prefixmask.sin6_addr)) {
		nd6log((LOG_ERR, "in6_ifadd: wrong prefixlen for %s"
			"(prefix=%d ifid=%d)\n", ifp->if_xname,
			prefixlen,
			128 - in6_mask2len(&ib->ia_prefixmask.sin6_addr)));
a1825 5
	ia = (struct in6_ifaddr *)malloc(sizeof(*ia), M_IFADDR, M_DONTWAIT);
	if (ia == NULL) {
		printf("ENOBUFS in in6_ifadd %d\n", __LINE__);
		return NULL;
	}
d1827 15
a1841 25
	bzero((caddr_t)ia, sizeof(*ia));
	ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
	if (ifp->if_flags & IFF_POINTOPOINT)
		ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ia->ia_dstaddr;
	else
		ia->ia_ifa.ifa_dstaddr = NULL;
	ia->ia_ifa.ifa_netmask = (struct sockaddr *)&ia->ia_prefixmask;
	ia->ia_ifp = ifp;

	/* link to in6_ifaddr */
	if ((oia = in6_ifaddr) != NULL) {
		for( ; oia->ia_next; oia = oia->ia_next)
			continue;
		oia->ia_next = ia;
	} else {
		/*
		 * This should be impossible, since we have at least one
		 * link-local address (see the beginning of this function).
		 * XXX: should we rather panic here?
		 */
		printf("in6_ifadd: in6_ifaddr is NULL (impossible!)\n");
		in6_ifaddr = ia;
	}
	/* gain a refcnt for the link from in6_ifaddr */
	ia->ia_ifa.ifa_refcnt++;
a1842 14
	/* link to if_addrlist */
	TAILQ_INSERT_TAIL(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
	/* gain another refcnt for the link from if_addrlist */
	ia->ia_ifa.ifa_refcnt++;

	/* new address */
	ia->ia_addr.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_addr.sin6_family = AF_INET6;
	/* prefix */
	bcopy(in6, &ia->ia_addr.sin6_addr, sizeof(ia->ia_addr.sin6_addr));
	ia->ia_addr.sin6_addr.s6_addr32[0] &= mask.s6_addr32[0];
	ia->ia_addr.sin6_addr.s6_addr32[1] &= mask.s6_addr32[1];
	ia->ia_addr.sin6_addr.s6_addr32[2] &= mask.s6_addr32[2];
	ia->ia_addr.sin6_addr.s6_addr32[3] &= mask.s6_addr32[3];
d1844 14
a1857 53
	ia->ia_addr.sin6_addr.s6_addr32[0]
		|= (ib->ia_addr.sin6_addr.s6_addr32[0] & ~mask.s6_addr32[0]);
	ia->ia_addr.sin6_addr.s6_addr32[1]
		|= (ib->ia_addr.sin6_addr.s6_addr32[1] & ~mask.s6_addr32[1]);
	ia->ia_addr.sin6_addr.s6_addr32[2]
		|= (ib->ia_addr.sin6_addr.s6_addr32[2] & ~mask.s6_addr32[2]);
	ia->ia_addr.sin6_addr.s6_addr32[3]
		|= (ib->ia_addr.sin6_addr.s6_addr32[3] & ~mask.s6_addr32[3]);

	/* new prefix */
	ia->ia_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_prefixmask.sin6_family = AF_INET6;
	bcopy(&mask, &ia->ia_prefixmask.sin6_addr,
		sizeof(ia->ia_prefixmask.sin6_addr));

	/* same routine */
	ia->ia_ifa.ifa_rtrequest =
		(ifp->if_type == IFT_PPP) ? nd6_p2p_rtrequest : nd6_rtrequest;
	ia->ia_ifa.ifa_flags |= RTF_CLONING;
	ia->ia_ifa.ifa_metric = ifp->if_metric;

	/* add interface route */
	if ((error = rtinit(&(ia->ia_ifa), (int)RTM_ADD, RTF_UP|RTF_CLONING))) {
		nd6log((LOG_NOTICE,
		    "in6_ifadd: failed to add an interface route "
		    "for %s/%d on %s, errno = %d\n",
		    ip6_sprintf(&ia->ia_addr.sin6_addr), prefixlen,
		    ifp->if_xname, error));
	}
	else
		ia->ia_flags |= IFA_ROUTE;

	*addr = ia->ia_addr.sin6_addr;

	if (ifp->if_flags & IFF_MULTICAST) {
		int error;	/* not used */
		struct in6_addr sol6;

		/* Restore saved multicast addresses(if any). */
		in6_restoremkludge(ia, ifp);

		/* join solicited node multicast address */
		bzero(&sol6, sizeof(sol6));
		sol6.s6_addr16[0] = htons(0xff02);
		sol6.s6_addr16[1] = htons(ifp->if_index);
		sol6.s6_addr32[1] = 0;
		sol6.s6_addr32[2] = htonl(1);
		sol6.s6_addr32[3] = ia->ia_addr.sin6_addr.s6_addr32[3];
		sol6.s6_addr8[12] = 0xff;
		(void)in6_addmulti(&sol6, ifp, &error);
	}

	ia->ia6_flags |= IN6_IFF_TENTATIVE;
d1860 3
a1862 1
	 * To make the interface up. Only AF_INET6 in ia is used...
d1864 2
a1865 6
	s = splimp();
	if (ifp->if_ioctl && (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia)) {
		splx(s);
		return NULL;
	}
	splx(s);
d1867 1
a1867 2
	/* Perform DAD, if needed. */
	nd6_dad_start((struct ifaddr *)ia, NULL);
d1869 1
a1869 2
	return ia;
}
d1871 8
a1878 10
int
in6_ifdel(ifp, in6)
	struct ifnet *ifp;
	struct in6_addr *in6;
{
	struct in6_ifaddr *ia = (struct in6_ifaddr *)NULL;
	struct in6_ifaddr *oia = (struct in6_ifaddr *)NULL;

	if (!ifp)
		return -1;
d1880 1
a1880 3
	ia = in6ifa_ifpwithaddr(ifp, in6);
	if (!ia)
		return -1;
d1882 1
a1882 52
	if (ifp->if_flags & IFF_MULTICAST) {
		/*
		 * delete solicited multicast addr for deleting host id
		 */
		struct in6_multi *in6m;
		struct in6_addr llsol;
		bzero(&llsol, sizeof(struct in6_addr));
		llsol.s6_addr16[0] = htons(0xff02);
		llsol.s6_addr16[1] = htons(ifp->if_index);
		llsol.s6_addr32[1] = 0;
		llsol.s6_addr32[2] = htonl(1);
		llsol.s6_addr32[3] =
				ia->ia_addr.sin6_addr.s6_addr32[3];
		llsol.s6_addr8[12] = 0xff;

		IN6_LOOKUP_MULTI(llsol, ifp, in6m);
		if (in6m)
			in6_delmulti(in6m);
	}

	if (ia->ia_flags & IFA_ROUTE) {
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, 0);
		ia->ia_flags &= ~IFA_ROUTE;
	}

	TAILQ_REMOVE(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
	IFAFREE(&ia->ia_ifa);

	/* lladdr is never deleted */
	oia = ia;
	if (oia == (ia = in6_ifaddr))
		in6_ifaddr = ia->ia_next;
	else {
		while (ia->ia_next && (ia->ia_next != oia))
			ia = ia->ia_next;
		if (ia->ia_next)
			ia->ia_next = oia->ia_next;
		else
			return -1;
	}

	in6_savemkludge(oia);
	IFAFREE((&oia->ia_ifa));
/* xxx
	rtrequest(RTM_DELETE,
		  (struct sockaddr *)&ia->ia_addr,
		  (struct sockaddr *)0
		  (struct sockaddr *)&ia->ia_prefixmask,
		  RTF_UP|RTF_CLONING,
		  (struct rtentry **)0);
*/
	return 0;
d1890 1
a1890 1
	/* check if preferred lifetime > valid lifetime */
d1910 1
a1910 3
in6_init_address_ltimes(struct nd_prefix *new,
			struct in6_addrlifetime *lt6,
			int update_vltime)
d1915 6
a1920 12
	if (update_vltime) {
		/* init ia6t_expire */
		if (lt6->ia6t_vltime == ND6_INFINITE_LIFETIME)
			lt6->ia6t_expire = 0;
		else {
			lt6->ia6t_expire = time_second;
			lt6->ia6t_expire += lt6->ia6t_vltime;
		}
		/* Ensure addr lifetime <= prefix lifetime. */
		if (new->ndpr_expire && lt6->ia6t_expire &&
		    new->ndpr_expire < lt6->ia6t_expire)
			lt6->ia6t_expire = new->ndpr_expire;
a1929 4
	 /* Ensure addr lifetime <= prefix lifetime. */
	if (new->ndpr_preferred && lt6->ia6t_preferred
	    && new->ndpr_preferred < lt6->ia6t_preferred)
		lt6->ia6t_preferred = new->ndpr_preferred;
d1973 8
d1987 2
a1988 2
	return(rtrequest(RTM_DELETE, rt_key(rt),
			 rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0));
d2003 1
a2003 1
		if (nd6_defifindex > 0)
d2005 1
a2005 1
		else
d2009 1
a2009 6
		 * If the Default Router List is empty, install a route
		 * to the specified interface as default or remove the default
		 * route when the default interface becomes canceled.
		 * The check for the queue is actually redundant, but
		 * we do this here to avoid re-install the default route
		 * if the list is NOT empty.
d2011 1
a2011 2
		if (TAILQ_FIRST(&nd_defrouter) == NULL)
			defrouter_select();
@


1.15
log
@cope with ndi->maxmtu == 0 case.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.14 2002/05/29 07:54:59 itojun Exp $	*/
d1213 1
a1213 1
	in6_len2mask(&mask, prefixlen);
@


1.14
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.13 2002/03/14 01:27:12 millert Exp $	*/
d349 1
d360 8
a367 14
		if (ndi->maxmtu) {
			if (mtu <= ndi->maxmtu) {
				int change = (ndi->linkmtu != mtu);

				ndi->linkmtu = mtu;
				if (change) /* in6_maxmtu may change */
					in6_setmaxmtu();
			} else {
				nd6log((LOG_INFO, "nd6_ra_input: bogus mtu "
				    "mtu=%d sent from %s; "
				    "exceeds maxmtu %d, ignoring\n",
				    mtu, ip6_sprintf(&ip6->ip6_src),
				    ndi->maxmtu));
			}
d369 4
a372 4
			nd6log((LOG_INFO, "nd6_ra_input: mtu option "
			    "mtu=%d sent from %s; maxmtu unknown, "
			    "ignoring\n",
			    mtu, ip6_sprintf(&ip6->ip6_src)));
d393 2
a394 2
		    "(if %d, RA packet %d)\n",
			ip6_sprintf(&saddr6), ifp->if_addrlen, lladdrlen - 2));
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.12 2001/12/07 09:16:07 itojun Exp $	*/
d192 1
a192 1
	struct nd_ifinfo *ndi = &nd_ifinfo[ifp->if_index];
@


1.12
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.11 2001/06/09 06:43:38 angelos Exp $	*/
d61 13
a73 13
static struct nd_defrouter *defrtrlist_update __P((struct nd_defrouter *));
static int prelist_add __P((struct nd_prefix *, struct nd_defrouter *));
static struct nd_prefix *prefix_lookup __P((struct nd_prefix *));
static struct in6_ifaddr *in6_ifadd __P((struct ifnet *, struct in6_addr *,
			  struct in6_addr *, int));
static struct nd_pfxrouter *pfxrtr_lookup __P((struct nd_prefix *,
					       struct nd_defrouter *));
static void pfxrtr_add __P((struct nd_prefix *, struct nd_defrouter *));
static void pfxrtr_del __P((struct nd_pfxrouter *));
static struct nd_pfxrouter *find_pfxlist_reachable_router __P((struct nd_prefix *));
static void nd6_detach_prefix __P((struct nd_prefix *));
static void nd6_attach_prefix __P((struct nd_prefix *));
static void defrouter_addifreq __P((struct ifnet *));
d75 1
a75 1
static void in6_init_address_ltimes __P((struct nd_prefix *ndpr,
d77 1
a77 1
					 int update_vltime));
d79 1
a79 1
static int rt6_deleteroute __P((struct radix_node *, void *));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.12 2001/12/07 09:16:07 itojun Exp $	*/
d61 17
a77 12
static int rtpref(struct nd_defrouter *);
static struct nd_defrouter *defrtrlist_update(struct nd_defrouter *);
static struct in6_ifaddr *in6_ifadd(struct nd_prefix *);
static struct nd_pfxrouter *pfxrtr_lookup(struct nd_prefix *,
	struct nd_defrouter *);
static void pfxrtr_add(struct nd_prefix *, struct nd_defrouter *);
static void pfxrtr_del(struct nd_pfxrouter *);
static struct nd_pfxrouter *find_pfxlist_reachable_router(struct nd_prefix *);
static void defrouter_delreq(struct nd_defrouter *);
static void defrouter_addifreq(struct ifnet *);
static void defrouter_delifreq(void);
static void nd6_rtmsg(int, struct rtentry *);
d79 1
a79 4
static void in6_init_address_ltimes(struct nd_prefix *,
	struct in6_addrlifetime *);

static int rt6_deleteroute(struct radix_node *, void *);
d83 1
a83 1
static struct ifnet *nd6_defifp;
a84 1
static struct ifaddr *nd6_defif_installed = NULL;
d164 1
a164 1
		    ip6_sprintf(&saddr6), ifp->if_addrlen, lladdrlen - 2));
d192 1
a192 1
	struct nd_ifinfo *ndi = ND_IFINFO(ifp);
a204 5
	/*
	 * We only accept RAs only when
	 * the system-wide variable allows the acceptance, and
	 * per-interface variable allows RAs on the receiving interface.  
	 */
a206 2
	if (!(ndi->flags & ND6_IFF_ACCEPT_RTADV))
		goto freeit;
a247 1
	Bzero(&dr0, sizeof(dr0));
d275 1
a275 1
		struct nd_opt_prefix_info *pi = NULL;
a276 1
		long time_second = time.tv_sec;
d329 1
a329 1
			     ND_OPT_PI_FLAG_ONLINK) ? 1 : 0;
d331 1
a331 1
			     ND_OPT_PI_FLAG_AUTO) ? 1 : 0;
d334 2
a335 2
			pr.ndpr_pltime = ntohl(pi->nd_opt_pi_preferred_time);
			pr.ndpr_lastupdate = time_second;
d348 1
a348 4
		u_long mtu;
		u_long maxmtu;

		mtu = ntohl(ndopts.nd_opts_mtu->nd_opt_mtu_mtu);
d353 1
a353 1
			    "mtu=%lu sent from %s, ignoring\n",
d359 14
a372 8
		maxmtu = (ndi->maxmtu && ndi->maxmtu < ifp->if_mtu)
		    ? ndi->maxmtu : ifp->if_mtu;
		if (mtu <= maxmtu) {
			int change = (ndi->linkmtu != mtu);

			ndi->linkmtu = mtu;
			if (change) /* in6_maxmtu may change */
				in6_setmaxmtu();
d374 4
a377 4
			nd6log((LOG_INFO, "nd6_ra_input: bogus mtu "
			    "mtu=%lu sent from %s; "
			    "exceeds maxmtu %lu, ignoring\n",
			    mtu, ip6_sprintf(&ip6->ip6_src), maxmtu));
d398 2
a399 2
		    "(if %d, RA packet %d)\n", ip6_sprintf(&saddr6),
		    ifp->if_addrlen, lladdrlen - 2));
a424 20

/* tell the change to user processes watching the routing socket. */
static void
nd6_rtmsg(cmd, rt)
	int cmd;
	struct rtentry *rt;
{
	struct rt_addrinfo info;

	bzero((caddr_t)&info, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
	info.rti_info[RTAX_IFP] =
	    (struct sockaddr *)TAILQ_FIRST(&rt->rt_ifp->if_addrlist);
	info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;

	rt_missmsg(cmd, &info, rt->rt_flags, 0);
}

a429 1
	struct rtentry *newrt = NULL;
a430 1
	int error;
d434 1
a434 1
	Bzero(&gate, sizeof(gate)); /* for safety */
d436 2
a437 2
	def.sin6_len = mask.sin6_len = gate.sin6_len =
	    sizeof(struct sockaddr_in6);
a439 3
#ifndef SCOPEDROUTING
	gate.sin6_scope_id = 0;	/* XXX */
#endif
d441 4
a444 10
	s = splsoftnet();
	error = rtrequest(RTM_ADD, (struct sockaddr *)&def,
	    (struct sockaddr *)&gate, (struct sockaddr *)&mask,
	    RTF_GATEWAY, &newrt);
	if (newrt) {
		nd6_rtmsg(RTM_ADD, newrt); /* tell user process */
		newrt->rt_refcnt--;
	}
	if (error == 0)
		new->installed = 1;
a455 1
	struct rtentry *newrt = NULL;
a456 5
	struct rt_addrinfo info;

	/* remove one if we have already installed one */
	if (nd6_defif_installed)
		defrouter_delifreq();
d471 1
a471 2
		    "to install a route to interface %s\n",
		    ifp->if_xname));
d475 6
a480 10
	/* RTF_CLONING is necessary to make sure to perform ND */
	flags = ifa->ifa_flags | RTF_CLONING;
	bzero(&info, sizeof(info));
	info.rti_info[RTAX_DST] = (struct sockaddr *)&def;
	info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)ifa->ifa_addr;
	info.rti_info[RTAX_NETMASK] = (struct sockaddr *)&mask;
	info.rti_info[RTAX_IFA] = (struct sockaddr *)ifa->ifa_addr;
	info.rti_flags = flags;
	error = rtrequest1(RTM_ADD, &info, &newrt);
	if (error != 0) {
a484 43

		if (newrt)	/* maybe unnecessary, but do it for safety */
			newrt->rt_refcnt--;
	} else {
		if (newrt) {
			nd6_rtmsg(RTM_ADD, newrt);
			newrt->rt_refcnt--;
		}
	}

	nd6_defif_installed = ifa;
	ifa->ifa_refcnt++;
}

/* Remove a default route points to interface */
static void
defrouter_delifreq()
{
	struct sockaddr_in6 def, mask;
	struct rtentry *oldrt = NULL;

	if (!nd6_defif_installed)
		return;

	Bzero(&def, sizeof(def));
	Bzero(&mask, sizeof(mask));

	def.sin6_len = mask.sin6_len = sizeof(struct sockaddr_in6);
	def.sin6_family = mask.sin6_family = AF_INET6;

	rtrequest(RTM_DELETE, (struct sockaddr *)&def,
	    (struct sockaddr *)nd6_defif_installed->ifa_addr,
	    (struct sockaddr *)&mask, RTF_GATEWAY, &oldrt);
	if (oldrt) {
		nd6_rtmsg(RTM_DELETE, oldrt);
		if (oldrt->rt_refcnt <= 0) {
			/*
			 * XXX: borrowed from the RTM_DELETE case of
			 * rtrequest().
			 */
			oldrt->rt_refcnt++;
			rtfree(oldrt);
		}
a485 3

	IFAFREE(nd6_defif_installed);
	nd6_defif_installed = NULL;
d497 1
a497 1
		if (dr->ifp == ifp && IN6_ARE_ADDR_EQUAL(addr, &dr->rtaddr)) {
a498 1
		}
d505 25
d540 2
a541 1
	if (!ip6_forwarding && ip6_accept_rtadv) /* XXX: better condition? */
d543 4
a547 4
	if (dr->installed) {
		deldr = dr;
		defrouter_delreq(dr);
	}
d572 3
a574 67
 * Remove the default route for a given router.
 * This is just a subroutine function for defrouter_select(), and should
 * not be called from anywhere else.
 */
static void
defrouter_delreq(dr)
	struct nd_defrouter *dr;
{
	struct sockaddr_in6 def, mask, gw;
	struct rtentry *oldrt = NULL;

	Bzero(&def, sizeof(def));
	Bzero(&mask, sizeof(mask));
	Bzero(&gw, sizeof(gw));	/* for safety */

	def.sin6_len = mask.sin6_len = gw.sin6_len =
	    sizeof(struct sockaddr_in6);
	def.sin6_family = mask.sin6_family = gw.sin6_family = AF_INET6;
	gw.sin6_addr = dr->rtaddr;
#ifndef SCOPEDROUTING
	gw.sin6_scope_id = 0;	/* XXX */
#endif

	rtrequest(RTM_DELETE, (struct sockaddr *)&def,
	    dr ? (struct sockaddr *)&gw : NULL,
	    (struct sockaddr *)&mask, RTF_GATEWAY, &oldrt);
	if (oldrt) {
		nd6_rtmsg(RTM_DELETE, oldrt);
		if (oldrt->rt_refcnt <= 0) {
			/*
			 * XXX: borrowed from the RTM_DELETE case of
			 * rtrequest().
			 */
			oldrt->rt_refcnt++;
			rtfree(oldrt);
		}
	}

	if (dr)
		dr->installed = 0;
}

/*
 * remove all default routes from default router list
 */
void
defrouter_reset()
{
	struct nd_defrouter *dr;

	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry))
		defrouter_delreq(dr);
	defrouter_delifreq();

	/*
	 * XXX should we also nuke any default routers in the kernel, by 
	 * going through them by rtalloc1()?
	 */
}

/*
 * Default Router Selection according to Section 6.3.6 of RFC 2461 and
 * draft-ietf-ipngwg-router-selection:
 * 1) Routers that are reachable or probably reachable should be preferred.
 *    If we have more than one (probably) reachable router, prefer ones
 *    with the highest router preference.
d577 1
a577 1
 *    fashion, regardless of router preference values.
a579 9
 *
 * We assume nd_defrouter is sorted by router preference value.
 * Since the code below covers both with and without router preference cases,
 * we do not need to classify the cases by ifdef.
 *
 * At this moment, we do not try to install more than one default router,
 * even when the multipath routing is available, because we're not sure about
 * the benefits for stub hosts comparing to the risk of making the code
 * complicated and the possibility of introducing bugs.
d584 2
a585 2
	int s = splsoftnet();
	struct nd_defrouter *dr, *selected_dr = NULL, *installed_dr = NULL;
d590 1
a590 4
	 * This function should be called only when acting as an autoconfigured
	 * host.  Although the remaining part of this function is not effective
	 * if the node is not an autoconfigured host, we explicitly exclude
	 * such cases here for safety.
d592 10
a601 6
	if (ip6_forwarding || !ip6_accept_rtadv) {
		nd6log((LOG_WARNING,
		    "defrouter_select: called unexpectedly (forwarding=%d, "
		    "accept_rtadv=%d)\n", ip6_forwarding, ip6_accept_rtadv));
		splx(s);
		return;
d604 13
a616 6
	/*
	 * Let's handle easy case (3) first:
	 * If default router list is empty, we should probably install
	 * an interface route and assume that all destinations are on-link.
	 */
	if (!TAILQ_FIRST(&nd_defrouter)) {
d618 2
a622 3
		 * This test is meaningless due to a test at the beginning of
		 * the function, but we intentionally keep it to make the note
		 * clear.
d625 6
d635 4
a641 5
				/*
				 * purge the existing route.
				 * XXX: is this really correct?
				 */
				defrouter_delifreq();
a646 63
		splx(s);
		return;
	}

	/*
	 * If we have a default route for the default interface, delete it.
	 * Note that the existence of the route is checked in the delete
	 * function.
	 */
	defrouter_delifreq();

	/*
	 * Search for a (probably) reachable router from the list.
	 * We just pick up the first reachable one (if any), assuming that
	 * the ordering rule of the list described in defrtrlist_update().
	 */
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {
		if (!selected_dr &&
		    (rt = nd6_lookup(&dr->rtaddr, 0, dr->ifp)) &&
		    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
		    ND6_IS_LLINFO_PROBREACH(ln)) {
			selected_dr = dr;
		}

		if (dr->installed && !installed_dr)
			installed_dr = dr;
		else if (dr->installed && installed_dr) {
			/* this should not happen.  warn for diagnosis. */
			log(LOG_ERR, "defrouter_select: more than one router"
			    " is installed\n");
		}
	}
	/*
	 * If none of the default routers was found to be reachable,
	 * round-robin the list regardless of preference.
	 * Otherwise, if we have an installed router, check if the selected
	 * (reachable) router should really be preferred to the installed one.
	 * We only prefer the new router when the old one is not reachable
	 * or when the new one has a really higher preference value.
	 */
	if (!selected_dr) {
		if (!installed_dr || !TAILQ_NEXT(installed_dr, dr_entry))
			selected_dr = TAILQ_FIRST(&nd_defrouter);
		else
 			selected_dr = TAILQ_NEXT(installed_dr, dr_entry);
	} else if (installed_dr &&
	    (rt = nd6_lookup(&installed_dr->rtaddr, 0, installed_dr->ifp)) &&
	    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
	    ND6_IS_LLINFO_PROBREACH(ln) &&
	    rtpref(selected_dr) <= rtpref(installed_dr)) {
		selected_dr = installed_dr;
	}

	/*
	 * If the selected router is different than the installed one,
	 * remove the installed router and install the selected one.
	 * Note that the selected router is never NULL here.
	 */
	if (installed_dr != selected_dr) {
		if (installed_dr)
			defrouter_delreq(installed_dr);
		defrouter_addreq(selected_dr);
a652 31
/* 
 * for default router selection
 * regards router-preference field as a 2-bit signed integer 
 */
static int
rtpref(struct nd_defrouter *dr)
{
#ifdef RTPREF
	switch (dr->flags & ND_RA_FLAG_RTPREF_MASK) {
	case ND_RA_FLAG_RTPREF_HIGH:
		return RTPREF_HIGH;
	case ND_RA_FLAG_RTPREF_MEDIUM:
	case ND_RA_FLAG_RTPREF_RSV:
		return RTPREF_MEDIUM;
	case ND_RA_FLAG_RTPREF_LOW:
		return RTPREF_LOW;
	default:
		/*
		 * This case should never happen.  If it did, it would mean a
		 * serious bug of kernel internal.  We thus always bark here.
		 * Or, can we even panic?
		 */
		log(LOG_ERR, "rtpref: impossible RA flag %x", dr->flags);
		return RTPREF_INVALID;
	}
	/* NOTREACHED */
#else
	return 0;
#endif
}

d658 1
a658 1
	int s = splsoftnet();
a665 2
			int oldpref = rtpref(dr);

a669 22

			/* 
			 * If the preference does not change, there's no need
			 * to sort the entries.
			 */
			if (rtpref(new) == oldpref) {
				splx(s);
				return(dr);
			}

			/*
			 * preferred router may be changed, so relocate
			 * this router.
			 * XXX: calling TAILQ_REMOVE directly is a bad manner.
			 * However, since defrtrlist_del() has many side
			 * effects, we intentionally do so here.
			 * defrouter_select() below will handle routing
			 * changes later.
			 */
			TAILQ_REMOVE(&nd_defrouter, dr, dr_entry);
			n = dr;
			goto insert;
a688 1
insert:
d690 3
a692 4
	 * Insert the new router in the Default Router List;
	 * The Default Router List should be in the descending order
	 * of router-preferece.  Routers with the same preference are
	 * sorted in the arriving time order.
d694 3
a696 14

	/* insert at the end of the group */
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {
		if (rtpref(n) > rtpref(dr))
			break;
	}
	if (dr)
		TAILQ_INSERT_BEFORE(dr, n, dr_entry);
	else
		TAILQ_INSERT_TAIL(&nd_defrouter, n, dr_entry);

	defrouter_select();

d743 2
a744 2
struct nd_prefix *
nd6_prefix_lookup(pr)
d753 3
a755 1
		    &search->ndpr_prefix.sin6_addr, pr->ndpr_plen)) {
d763 3
a765 3
int
nd6_prelist_add(pr, dr, newp)
	struct nd_prefix *pr, **newp;
d768 1
a768 1
	struct nd_prefix *new = NULL;
a775 2
	if (newp != NULL)
		*newp = new;
d778 1
d784 5
a788 1
		    new->ndpr_mask.s6_addr32[i];
a789 1
	s = splsoftnet();
a793 13
	/* ND_OPT_PI_FLAG_ONLINK processing */
	if (new->ndpr_raf_onlink) {
		int e;

		if ((e = nd6_prefix_onlink(new)) != 0) {
			nd6log((LOG_ERR, "nd6_prelist_add: failed to make "
			    "the prefix %s/%d on-link on %s (errno=%d)\n",
			    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
			    pr->ndpr_plen, pr->ndpr_ifp->if_xname, e));
			/* proceed anyway. XXX: is it correct? */
		}
	}

d805 1
a805 21
	int e, s;

	/* make sure to invalidate the prefix until it is really freed. */
	pr->ndpr_vltime = 0;
	pr->ndpr_pltime = 0;
#if 0
	/*
	 * Though these flags are now meaningless, we'd rather keep the value
	 * not to confuse users when executing "ndp -p".
	 */
	pr->ndpr_raf_onlink = 0;
	pr->ndpr_raf_auto = 0;
#endif
	if ((pr->ndpr_stateflags & NDPRF_ONLINK) != 0 &&
	    (e = nd6_prefix_offlink(pr)) != 0) {
		nd6log((LOG_ERR, "prelist_remove: failed to make %s/%d offlink "
		    "on %s, errno=%d\n",
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
		    pr->ndpr_plen, pr->ndpr_ifp->if_xname, e));
		/* what should we do? */
	}
d807 1
a807 4
	if (pr->ndpr_refcnt > 0)
		return;		/* notice here? */

	s = splsoftnet();
d825 6
d837 1
a837 3
	struct in6_ifaddr *ia6 = NULL, *ia6_match = NULL;
	struct ifaddr *ifa;
	struct ifnet *ifp = new->ndpr_ifp;
d839 2
a840 1
	int s = splsoftnet();
a841 1
	int newprefix = 0;
d843 1
a843 1
	struct in6_addrlifetime lt6_tmp;
d851 4
a854 1
		auth = ((m->m_flags & M_AUTH_AH) && (m->m_flags & M_AUTH));
d857 11
a867 5
	if ((pr = nd6_prefix_lookup(new)) != NULL) {
		/*
		 * nd6_prefix_lookup() ensures that pr and new have the same
		 * prefix on a same interface.
		 */
d870 2
a871 3
		 * Update prefix information.  Note that the on-link (L) bit
		 * and the autonomous (A) bit should NOT be changed from 1
		 * to 0.
d873 2
a874 11
		if (new->ndpr_raf_onlink == 1)
			pr->ndpr_raf_onlink = 1;
		if (new->ndpr_raf_auto == 1)
			pr->ndpr_raf_auto = 1;
		if (new->ndpr_raf_onlink) {
			pr->ndpr_vltime = new->ndpr_vltime;
			pr->ndpr_pltime = new->ndpr_pltime;
			pr->ndpr_preferred = new->ndpr_preferred;
			pr->ndpr_expire = new->ndpr_expire;
			pr->ndpr_lastupdate = new->ndpr_lastupdate;
		}
d876 4
a879 3
		if (new->ndpr_raf_onlink &&
		    (pr->ndpr_stateflags & NDPRF_ONLINK) == 0) {
			int e;
d881 22
a902 1
			if ((e = nd6_prefix_onlink(pr)) != 0) {
d904 3
a906 6
				    "prelist_update: failed to make "
				    "the prefix %s/%d on-link on %s "
				    "(errno=%d)\n",
				    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
				    pr->ndpr_plen, pr->ndpr_ifp->if_xname, e));
				/* proceed anyway. XXX: is it correct? */
a907 1
		}
d909 17
a925 4
		if (dr && pfxrtr_lookup(pr, dr) == NULL)
			pfxrtr_add(pr, dr);
	} else {
		struct nd_prefix *newpr = NULL;
d927 1
a927 1
		newprefix = 1;
d929 15
a943 4
		if (new->ndpr_vltime == 0)
			goto end;
		if (new->ndpr_raf_onlink == 0 && new->ndpr_raf_auto == 0)
			goto end;
d945 12
a956 10
		error = nd6_prelist_add(new, dr, &newpr);
		if (error != 0 || newpr == NULL) {
			nd6log((LOG_NOTICE, "prelist_update: "
			    "nd6_prelist_add failed for %s/%d on %s "
			    "errno=%d, returnpr=%p\n",
			    ip6_sprintf(&new->ndpr_prefix.sin6_addr),
			    new->ndpr_plen, new->ndpr_ifp->if_xname,
			    error, newpr));
			goto end; /* we should just give up in this case. */
		}
d958 4
a961 11
		/*
		 * XXX: from the ND point of view, we can ignore a prefix
		 * with the on-link bit being zero.  However, we need a
		 * prefix structure for references from autoconfigured
		 * addresses.  Thus, we explicitly make sure that the prefix
		 * itself expires now.
		 */
		if (newpr->ndpr_raf_onlink == 0) {
			newpr->ndpr_vltime = 0;
			newpr->ndpr_pltime = 0;
			in6_init_prefix_ltimes(newpr);
d964 1
a964 39
		pr = newpr;
	}

	/*
	 * Address autoconfiguration based on Section 5.5.3 of RFC 2462.
	 * Note that pr must be non NULL at this point.
	 */

	/* 5.5.3 (a). Ignore the prefix without the A bit set. */
	if (!new->ndpr_raf_auto)
		goto end;

	/*
	 * 5.5.3 (b). the link-local prefix should have been ignored in
	 * nd6_ra_input.
	 */

	/*
	 * 5.5.3 (c). Consistency check on lifetimes: pltime <= vltime.
	 * This should have been done in nd6_ra_input.
	 */

 	/*
	 * 5.5.3 (d). If the prefix advertised does not match the prefix of an
	 * address already in the list, and the Valid Lifetime is not 0,
	 * form an address.  Note that even a manually configured address
	 * should reject autoconfiguration of a new address.
	 */
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
	{
		struct in6_ifaddr *ifa6;
		int ifa_plen;
		u_int32_t storedlifetime;
		long time_second = time.tv_sec;

		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;

		ifa6 = (struct in6_ifaddr *)ifa;
a965 60
		/*
		 * Spec is not clear here, but I believe we should concentrate
		 * on unicast (i.e. not anycast) addresses.
		 * XXX: other ia6_flags? detached or duplicated?
		 */
		if ((ifa6->ia6_flags & IN6_IFF_ANYCAST) != 0)
			continue;
		
		ifa_plen = in6_mask2len(&ifa6->ia_prefixmask.sin6_addr, NULL);
		if (ifa_plen != new->ndpr_plen ||
		    !in6_are_prefix_equal(&ifa6->ia_addr.sin6_addr,
		    &new->ndpr_prefix.sin6_addr, ifa_plen))
			continue;

		if (ia6_match == NULL) /* remember the first one */
			ia6_match = ifa6;

		if ((ifa6->ia6_flags & IN6_IFF_AUTOCONF) == 0)
			continue;

		/*
		 * An already autoconfigured address matched.  Now that we
		 * are sure there is at least one matched address, we can
		 * proceed to 5.5.3. (e): update the lifetimes according to the
		 * "two hours" rule and the privacy extension.
		 */
#define TWOHOUR		(120*60)
		/*
		 * RFC2462 introduces the notion of StoredLifetime to the
		 * "two hours" rule as follows:
		 *   the Lifetime associated with the previously autoconfigured
		 *   address.
		 * Our interpretation of this definition is "the remaining
		 * lifetime to expiration at the evaluation time".  One might
		 * be wondering if this interpretation is really conform to the
		 * RFC, because the text can read that "Lifetimes" are never
		 * decreased, and our definition of the "storedlifetime" below
		 * essentially reduces the "Valid Lifetime" advertised in the
		 * previous RA.  But, this is due to the wording of the text,
		 * and our interpretation is the same as an author's intention.
		 * See the discussion in the IETF ipngwg ML in August 2001,
		 * with the Subject "StoredLifetime in RFC 2462".
		 */
		lt6_tmp = ifa6->ia6_lifetime;
		if (lt6_tmp.ia6t_vltime == ND6_INFINITE_LIFETIME)
			storedlifetime = ND6_INFINITE_LIFETIME;
		else if (time_second - ifa6->ia6_updatetime >
			 lt6_tmp.ia6t_vltime) {
			/*
			 * The case of "invalid" address.  We should usually
			 * not see this case.
			 */
			storedlifetime = 0;
		} else
			storedlifetime = lt6_tmp.ia6t_vltime -
				(time_second - ifa6->ia6_updatetime);
		if (TWOHOUR < new->ndpr_vltime ||
		    storedlifetime < new->ndpr_vltime) {
			lt6_tmp.ia6t_vltime = new->ndpr_vltime;
		} else if (storedlifetime <= TWOHOUR
d967 8
a974 6
			   /*
			    * This condition is logically redundant, so we just
			    * omit it.
			    * See IPng 6712, 6717, and 6721.
			    */
			   && new->ndpr_vltime <= storedlifetime
a975 11
			) {
			if (auth) {
				lt6_tmp.ia6t_vltime = new->ndpr_vltime;
			}
		} else {
			/*
			 * new->ndpr_vltime <= TWOHOUR &&
			 * TWOHOUR < storedlifetime
			 */
			lt6_tmp.ia6t_vltime = TWOHOUR;
		}
d977 6
a982 2
		/* The 2 hour rule is not imposed for preferred lifetime. */
		lt6_tmp.ia6t_pltime = new->ndpr_pltime;
d984 1
a984 1
		in6_init_address_ltimes(pr, &lt6_tmp);
a985 4
		ifa6->ia6_lifetime = lt6_tmp;
		ifa6->ia6_updatetime = time_second;
	}
	if (ia6_match == NULL && new->ndpr_vltime) {
d987 4
a990 2
		 * No address matched and the valid lifetime is non-zero.
		 * Create a new address.
d992 2
a993 6
		if ((ia6 = in6_ifadd(new)) != NULL) {
			/*
			 * note that we should use pr (not new) for reference.
			 */
			pr->ndpr_refcnt++;
			ia6->ia6_ndpr = pr;
d995 21
a1015 10
			/*
			 * A newly added address might affect the status
			 * of other addresses, so we check and update it.
			 * XXX: what if address duplication happens?
			 */
			pfxlist_onlink_check();
		} else {
			/* just set an error. do not bark here. */
			error = EADDRNOTAVAIL; /* XXX: might be unused. */
		}
d1039 1
a1039 1
		    pfxrtr->router->ifp)) &&
d1046 1
d1051 2
a1052 2
 * that advertised the prefix (a router is "available" if its neighbor cache
 * entry is reachable or probably reachable).
d1055 4
a1058 4
 * expired yet.  So we should not use the prefix if there is another prefix
 * that has an available router.
 * But, if there is no prefix that has an available router, we still regards
 * all the prefixes as on-link.  This is because we can't tell if all the
a1065 1
	struct in6_ifaddr *ifa;
d1072 1
a1072 1
		if (pr->ndpr_raf_onlink && find_pfxlist_reachable_router(pr))
d1075 2
a1076 1
	if (pr != NULL || TAILQ_FIRST(&nd_defrouter) != NULL) {
d1078 5
a1082 7
		 * There is at least one prefix that has a reachable router,
		 * or at least a router which probably does not advertise
		 * any prefixes.  The latter would be the case when we move
		 * to a new link where we have a router that does not provide
		 * prefixes and we configure an address by hand.
		 * Detach prefixes which have no reachable advertising
		 * router, and attach other prefixes.
d1085 5
a1089 17
			/* XXX: a link-local prefix should never be detached */
			if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
				continue;

			/*
			 * we aren't interested in prefixes without the L bit
			 * set.
			 */
			if (pr->ndpr_raf_onlink == 0)
				continue;

			if ((pr->ndpr_stateflags & NDPRF_DETACHED) == 0 &&
			    find_pfxlist_reachable_router(pr) == NULL)
				pr->ndpr_stateflags |= NDPRF_DETACHED;
			if ((pr->ndpr_stateflags & NDPRF_DETACHED) != 0 &&
			    find_pfxlist_reachable_router(pr) != 0)
				pr->ndpr_stateflags &= ~NDPRF_DETACHED;
a1090 2
	} else {
		/* there is no prefix that has a reachable router */
d1092 3
a1094 87
			if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
				continue;

			if (pr->ndpr_raf_onlink == 0)
				continue;

			if ((pr->ndpr_stateflags & NDPRF_DETACHED) != 0)
				pr->ndpr_stateflags &= ~NDPRF_DETACHED;
		}
	}

	/*
	 * Remove each interface route associated with a (just) detached
	 * prefix, and reinstall the interface route for a (just) attached
	 * prefix.  Note that all attempt of reinstallation does not
	 * necessarily success, when a same prefix is shared among multiple
	 * interfaces.  Such cases will be handled in nd6_prefix_onlink,
	 * so we don't have to care about them.
	 */
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
		int e;

		if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
			continue;

		if (pr->ndpr_raf_onlink == 0)
			continue;

		if ((pr->ndpr_stateflags & NDPRF_DETACHED) != 0 &&
		    (pr->ndpr_stateflags & NDPRF_ONLINK) != 0) {
			if ((e = nd6_prefix_offlink(pr)) != 0) {
				nd6log((LOG_ERR,
				    "pfxlist_onlink_check: failed to "
				    "make %s/%d offlink, errno=%d\n",
				    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
				    pr->ndpr_plen, e));
			}
		}
		if ((pr->ndpr_stateflags & NDPRF_DETACHED) == 0 &&
		    (pr->ndpr_stateflags & NDPRF_ONLINK) == 0 &&
		    pr->ndpr_raf_onlink) {
			if ((e = nd6_prefix_onlink(pr)) != 0) {
				nd6log((LOG_ERR,
				    "pfxlist_onlink_check: failed to "
				    "make %s/%d offlink, errno=%d\n",
				    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
				    pr->ndpr_plen, e));
			}
		}
	}

	/*
	 * Changes on the prefix status might affect address status as well.
	 * Make sure that all addresses derived from an attached prefix are
	 * attached, and that all addresses derived from a detached prefix are
	 * detached.  Note, however, that a manually configured address should
	 * always be attached.
	 * The precise detection logic is same as the one for prefixes.
	 */
	for (ifa = in6_ifaddr; ifa; ifa = ifa->ia_next) {
		if (!(ifa->ia6_flags & IN6_IFF_AUTOCONF))
			continue;

		if (ifa->ia6_ndpr == NULL) {
			/*
			 * This can happen when we first configure the address
			 * (i.e. the address exists, but the prefix does not).
			 * XXX: complicated relationships...
			 */
			continue;
		}

		if (find_pfxlist_reachable_router(ifa->ia6_ndpr))
			break;
	}
	if (ifa) {
		for (ifa = in6_ifaddr; ifa; ifa = ifa->ia_next) {
			if ((ifa->ia6_flags & IN6_IFF_AUTOCONF) == 0)
				continue;

			if (ifa->ia6_ndpr == NULL) /* XXX: see above. */
				continue;

			if (find_pfxlist_reachable_router(ifa->ia6_ndpr))
				ifa->ia6_flags &= ~IN6_IFF_DETACHED;
			else
				ifa->ia6_flags |= IN6_IFF_DETACHED;
d1098 4
a1101 6
		for (ifa = in6_ifaddr; ifa; ifa = ifa->ia_next) {
			if ((ifa->ia6_flags & IN6_IFF_AUTOCONF) == 0)
				continue;

			ifa->ia6_flags &= ~IN6_IFF_DETACHED;
		}
d1105 2
a1106 2
int
nd6_prefix_onlink(pr)
d1109 2
a1110 15
	struct ifaddr *ifa;
	struct ifnet *ifp = pr->ndpr_ifp;
	struct sockaddr_in6 mask6;
	struct nd_prefix *opr;
	u_long rtflags;
	int error = 0;
	struct rtentry *rt = NULL;

	/* sanity check */
	if ((pr->ndpr_stateflags & NDPRF_ONLINK) != 0) {
		nd6log((LOG_ERR,
		    "nd6_prefix_onlink: %s/%d is already on-link\n",
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr), pr->ndpr_plen);
		return(EEXIST));
	}
d1113 1
a1113 5
	 * Add the interface route associated with the prefix.  Before
	 * installing the route, check if there's the same prefix on another
	 * interface, and the prefix has already installed the interface route.
	 * Although such a configuration is expected to be rare, we explicitly
	 * allow it.
d1115 11
a1125 3
	for (opr = nd_prefix.lh_first; opr; opr = opr->ndpr_next) {
		if (opr == pr)
			continue;
d1127 9
a1135 23
		if ((opr->ndpr_stateflags & NDPRF_ONLINK) == 0)
			continue;

		if (opr->ndpr_plen == pr->ndpr_plen &&
		    in6_are_prefix_equal(&pr->ndpr_prefix.sin6_addr,
		    &opr->ndpr_prefix.sin6_addr, pr->ndpr_plen))
			return(0);
	}

	/*
	 * We prefer link-local addresses as the associated interface address. 
	 */
	/* search for a link-local addr */
	ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp,
	    IN6_IFF_NOTREADY | IN6_IFF_ANYCAST);
	if (ifa == NULL) {
		/* XXX: freebsd does not have ifa_ifwithaf */
		for (ifa = ifp->if_addrlist.tqh_first;
		     ifa;
		     ifa = ifa->ifa_list.tqe_next)
		{
			if (ifa->ifa_addr->sa_family == AF_INET6)
				break;
a1136 15
		/* should we care about ia6_flags? */
	}
	if (ifa == NULL) {
		/*
		 * This can still happen, when, for example, we receive an RA
		 * containing a prefix with the L bit set and the A bit clear,
		 * after removing all IPv6 addresses on the receiving
		 * interface.  This should, of course, be rare though.
		 */
		nd6log((LOG_NOTICE,
		    "nd6_prefix_onlink: failed to find any ifaddr"
		    " to add route for a prefix(%s/%d) on %s\n",
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
		    pr->ndpr_plen, ifp->if_xname));
		return(0);
d1140 2
a1141 2
	 * in6_ifinit() sets nd6_rtrequest to ifa_rtrequest for all ifaddrs.
	 * ifa->ifa_rtrequest = nd6_rtrequest;
d1143 6
a1148 34
	bzero(&mask6, sizeof(mask6));
	mask6.sin6_len = sizeof(mask6);
	mask6.sin6_addr = pr->ndpr_mask;
	/* rtrequest() will probably set RTF_UP, but we're not sure. */
	rtflags = ifa->ifa_flags | RTF_UP;
	if (nd6_need_cache(ifp)) {
		/* explicitly set in case ifa_flags does not set the flag. */
		rtflags |= RTF_CLONING;
	} else {
		/*
		 * explicitly clear the cloning bit in case ifa_flags sets it.
		 */
		rtflags &= ~RTF_CLONING;
	}
	error = rtrequest(RTM_ADD, (struct sockaddr *)&pr->ndpr_prefix,
	    ifa->ifa_addr, (struct sockaddr *)&mask6, rtflags, &rt);
	if (error == 0) {
		if (rt != NULL) /* this should be non NULL, though */
			nd6_rtmsg(RTM_ADD, rt);
		pr->ndpr_stateflags |= NDPRF_ONLINK;
	} else {
		nd6log((LOG_ERR, "nd6_prefix_onlink: failed to add route for a"
		    " prefix (%s/%d) on %s, gw=%s, mask=%s, flags=%lx "
		    "errno = %d\n",
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
		    pr->ndpr_plen, ifp->if_xname,
		    ip6_sprintf(&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr),
		    ip6_sprintf(&mask6.sin6_addr), rtflags, error));
	}

	if (rt != NULL)
		rt->rt_refcnt--;

	return(error);
d1151 2
a1152 2
int
nd6_prefix_offlink(pr)
d1155 2
a1156 5
	int error = 0;
	struct ifnet *ifp = pr->ndpr_ifp;
	struct nd_prefix *opr;
	struct sockaddr_in6 sa6, mask6;
	struct rtentry *rt = NULL;
d1158 7
a1164 2
	/* sanity check */
	if ((pr->ndpr_stateflags & NDPRF_ONLINK) == 0) {
d1166 3
a1168 3
		    "nd6_prefix_offlink: %s/%d is already off-link\n",
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr), pr->ndpr_plen));
		return(EEXIST);
d1170 3
d1174 14
a1187 54
	bzero(&sa6, sizeof(sa6));
	sa6.sin6_family = AF_INET6;
	sa6.sin6_len = sizeof(sa6);
	bcopy(&pr->ndpr_prefix.sin6_addr, &sa6.sin6_addr,
	    sizeof(struct in6_addr));
	bzero(&mask6, sizeof(mask6));
	mask6.sin6_family = AF_INET6;
	mask6.sin6_len = sizeof(sa6);
	bcopy(&pr->ndpr_mask, &mask6.sin6_addr, sizeof(struct in6_addr));
	error = rtrequest(RTM_DELETE, (struct sockaddr *)&sa6, NULL,
	    (struct sockaddr *)&mask6, 0, &rt);
	if (error == 0) {
		pr->ndpr_stateflags &= ~NDPRF_ONLINK;

		/* report the route deletion to the routing socket. */
		if (rt != NULL)
			nd6_rtmsg(RTM_DELETE, rt);

		/*
		 * There might be the same prefix on another interface,
		 * the prefix which could not be on-link just because we have
		 * the interface route (see comments in nd6_prefix_onlink).
		 * If there's one, try to make the prefix on-link on the
		 * interface.
		 */
		for (opr = nd_prefix.lh_first; opr; opr = opr->ndpr_next) {
			if (opr == pr)
				continue;

			if ((opr->ndpr_stateflags & NDPRF_ONLINK) != 0)
				continue;

			/*
			 * KAME specific: detached prefixes should not be
			 * on-link.
			 */
			if ((opr->ndpr_stateflags & NDPRF_DETACHED) != 0)
				continue;

			if (opr->ndpr_plen == pr->ndpr_plen &&
			    in6_are_prefix_equal(&pr->ndpr_prefix.sin6_addr,
			    &opr->ndpr_prefix.sin6_addr, pr->ndpr_plen)) {
				int e;

				if ((e = nd6_prefix_onlink(opr)) != 0) {
					nd6log((LOG_ERR,
					    "nd6_prefix_offlink: failed to "
					    "recover a prefix %s/%d from %s "
					    "to %s (errno = %d)\n",
					    ip6_sprintf(&opr->ndpr_prefix.sin6_addr),
					    opr->ndpr_plen, ifp->if_xname,
					    opr->ndpr_ifp->if_xname, e));
				}
			}
a1188 7
	} else {
		/* XXX: can we still set the NDPRF_ONLINK flag? */
		nd6log((LOG_ERR,
		    "nd6_prefix_offlink: failed to delete route: "
		    "%s/%d on %s (errno = %d)\n",
		    ip6_sprintf(&sa6.sin6_addr), pr->ndpr_plen, ifp->if_xname,
		    error));
d1191 12
a1202 6
	if (rt != NULL) {
		if (rt->rt_refcnt <= 0) {
			/* XXX: we should free the entry ourselves. */
			rt->rt_refcnt++;
			rtfree(rt);
		}
a1203 2

	return(error);
d1207 5
a1211 2
in6_ifadd(pr)
	struct nd_prefix *pr;
a1212 1
	struct ifnet *ifp = pr->ndpr_ifp;
d1214 2
a1215 3
	struct in6_aliasreq ifra;
	struct in6_ifaddr *ia, *ib;
	int error, plen0;
a1216 1
	int prefixlen = pr->ndpr_plen;
d1218 1
a1218 1
	in6_prefixlen2mask(&mask, prefixlen);
d1220 2
a1221 21
	/*
	 * find a link-local address (will be interface ID).
	 * Is it really mandatory? Theoretically, a global or a site-local
	 * address can be configured without a link-local address, if we
	 * have a unique interface identifier...
	 *
	 * it is not mandatory to have a link-local address, we can generate
	 * interface identifier on the fly.  we do this because:
	 * (1) it should be the easiest way to find interface identifier.
	 * (2) RFC2462 5.4 suggesting the use of the same interface identifier
	 * for multiple addresses on a single interface, and possible shortcut
	 * of DAD.  we omitted DAD for this reason in the past.
	 * (3) a user can prevent autoconfiguration of global address 
	 * by removing link-local address by hand (this is partly because we
	 * don't have other way to control the use of IPv6 on a interface.
	 * this has been our design choice - cf. NRL's "ifconfig auto").
	 * (4) it is easier to manage when an interface has addresses
	 * with the same interface identifier, than to have multiple addresses
	 * with different interface identifiers.
	 */
	ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp, 0); /* 0 is OK? */
d1236 5
a1240 5
	plen0 = in6_mask2len(&ib->ia_prefixmask.sin6_addr, NULL);
	if (prefixlen != plen0) {
		nd6log((LOG_INFO, "in6_ifadd: wrong prefixlen for %s "
		    "(prefix=%d ifid=%d)\n",
		    ifp->if_xname, prefixlen, 128 - plen0));
d1245 5
d1251 34
a1284 8
	bzero(&ifra, sizeof(ifra));
	/*
	 * in6_update_ifa() does not use ifra_name, but we accurately set it
	 * for safety.
	 */
	strncpy(ifra.ifra_name, ifp->if_xname, sizeof(ifra.ifra_name));
	ifra.ifra_addr.sin6_family = AF_INET6;
	ifra.ifra_addr.sin6_len = sizeof(struct sockaddr_in6);
d1286 46
a1331 6
	bcopy(&pr->ndpr_prefix.sin6_addr, &ifra.ifra_addr.sin6_addr,
	    sizeof(ifra.ifra_addr.sin6_addr));
	ifra.ifra_addr.sin6_addr.s6_addr32[0] &= mask.s6_addr32[0];
	ifra.ifra_addr.sin6_addr.s6_addr32[1] &= mask.s6_addr32[1];
	ifra.ifra_addr.sin6_addr.s6_addr32[2] &= mask.s6_addr32[2];
	ifra.ifra_addr.sin6_addr.s6_addr32[3] &= mask.s6_addr32[3];
d1333 12
a1344 15
	/* interface ID */
	ifra.ifra_addr.sin6_addr.s6_addr32[0] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[0] & ~mask.s6_addr32[0]);
	ifra.ifra_addr.sin6_addr.s6_addr32[1] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[1] & ~mask.s6_addr32[1]);
	ifra.ifra_addr.sin6_addr.s6_addr32[2] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[2] & ~mask.s6_addr32[2]);
	ifra.ifra_addr.sin6_addr.s6_addr32[3] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[3] & ~mask.s6_addr32[3]);
	    
	/* new prefix mask. */
	ifra.ifra_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_prefixmask.sin6_family = AF_INET6;
	bcopy(&mask, &ifra.ifra_prefixmask.sin6_addr,
	    sizeof(ifra.ifra_prefixmask.sin6_addr));
d1347 1
a1347 3
	 * lifetime.
	 * XXX: in6_init_address_ltimes would override these values later.
	 * We should reconsider this logic. 
d1349 20
a1368 2
	ifra.ifra_lifetime.ia6t_vltime = pr->ndpr_vltime;
	ifra.ifra_lifetime.ia6t_pltime = pr->ndpr_pltime;
d1370 2
a1371 1
	/* XXX: scope zone ID? */
d1373 3
a1375 1
	ifra.ifra_flags |= IN6_IFF_AUTOCONF; /* obey autoconf */
d1377 39
a1415 7
	/* allocate ifaddr structure, link into chain, etc. */
	if ((error = in6_update_ifa(ifp, &ifra, NULL)) != 0) {
		nd6log((LOG_ERR,
		    "in6_ifadd: failed to make ifaddr %s on %s (errno=%d)\n",
		    ip6_sprintf(&ifra.ifra_addr.sin6_addr), ifp->if_xname,
		    error));
		return(NULL);	/* ifaddr must not have been allocated. */
d1418 11
a1428 3
	ia = in6ifa_ifpwithaddr(ifp, &ifra.ifra_addr.sin6_addr);

	return(ia);		/* this is always non-NULL */
d1436 1
a1436 1
	/* check if preferred lifetime > valid lifetime.  RFC2462 5.5.3 (c) */
d1456 3
a1458 1
in6_init_address_ltimes(struct nd_prefix *new, struct in6_addrlifetime *lt6)
d1463 12
a1474 6
	/* init ia6t_expire */
	if (lt6->ia6t_vltime == ND6_INFINITE_LIFETIME)
		lt6->ia6t_expire = 0;
	else {
		lt6->ia6t_expire = time_second;
		lt6->ia6t_expire += lt6->ia6t_vltime;
d1484 4
d1501 1
a1501 1
	int s = splsoftnet();
a1530 8
	 * Do not delete a static route.
	 * XXX: this seems to be a bit ad-hoc. Should we consider the
	 * 'cloned' bit instead?
	 */
	if ((rt->rt_flags & RTF_STATIC) != 0)
		return(0);

	/*
d1537 2
a1538 2
	return(rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway,
	    rt_mask(rt), rt->rt_flags, 0));
d1553 1
a1553 1
		if (nd6_defifindex > 0) {
d1555 1
a1555 1
		} else
d1559 6
a1564 1
		 * Rescan default router list, refresh default route(s).
d1566 2
a1567 1
		defrouter_select();
@


1.12.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.12.2.1 2002/06/11 03:31:37 art Exp $	*/
d207 1
a207 1
	 * per-interface variable allows RAs on the receiving interface.
d387 1
a387 1

d394 1
a394 1

d591 1
a591 1
			return (dr);
d595 1
a595 1
	return (NULL);		/* search failed */
a650 5
#ifdef DIAGNOSTIC
	if (!dr)
		panic("dr == NULL in defrouter_delreq");
#endif

d664 1
a664 1
	    (struct sockaddr *)&gw,
d678 2
a679 1
	dr->installed = 0;
d696 1
a696 1
	 * XXX should we also nuke any default routers in the kernel, by
d821 1
a821 1
			selected_dr = TAILQ_NEXT(installed_dr, dr_entry);
d845 1
a845 1
/*
d847 1
a847 1
 * regards router-preference field as a 2-bit signed integer
d896 1
a896 1
			/*
d902 1
a902 1
				return (dr);
d919 1
a919 1
		return (dr);
d925 1
a925 1
		return (NULL);
d931 1
a931 1
		return (NULL);
d958 2
a959 2

	return (n);
d968 1
a968 1

d974 1
a974 1
	return (search);
d1018 1
a1018 1
	return (search);
d1238 1
a1238 1
	/*
d1263 1
a1263 1

d1395 1
a1395 1
	return (pfxrtr);
d1573 1
a1573 1
		return (EEXIST));
d1593 1
a1593 1
			return (0);
d1597 1
a1597 1
	 * We prefer link-local addresses as the associated interface address.
d1625 1
a1625 1
		return (0);
d1665 1
a1665 1
	return (error);
d1683 1
a1683 1
		return (EEXIST);
d1758 1
a1758 1
	return (error);
d1787 1
a1787 1
	 * (3) a user can prevent autoconfiguration of global address
d1845 1
a1845 1

d1855 1
a1855 1
	 * We should reconsider this logic.
d1870 1
a1870 1
		return (NULL);	/* ifaddr must not have been allocated. */
d1875 1
a1875 1
	return (ia);		/* this is always non-NULL */
d1960 1
a1960 1
		return (0);
d1963 1
a1963 1
		return (0);
d1971 1
a1971 1
		return (0);
d1978 1
a1978 1
		return (0);
d1980 1
a1980 1
	return (rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway,
d1992 1
a1992 1
		return (EINVAL);
d2007 1
a2007 1
	return (error);
@


1.12.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 4
d143 1
d229 4
d238 1
d443 3
a445 5
	if (rt->rt_ifp) {
		info.rti_info[RTAX_IFP] =
		    TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
		info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
	}
@


1.11
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.10 2001/04/04 06:22:57 itojun Exp $	*/
d384 1
a384 1
	 * Src linkaddress
@


1.10
log
@suppress RS/RA log messages (can be re-enabled by net.inet6.icmp6.nd6_debug),
as they may fill up /var.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.9 2001/02/16 16:19:56 itojun Exp $	*/
a58 2
#include <net/net_osdep.h>

d124 1
a124 1
		    ip6_sprintf(&ip6->ip6_dst), if_name(ifp)));
d212 1
a212 1
		    ip6_sprintf(&ip6->ip6_dst), if_name(ifp)));
d471 1
a471 2
		    "to install a route to interface %s\n",
		    if_name(ifp)));
d484 1
a484 1
		    if_name(ifp), error));
d1238 1
a1238 1
			"(prefix=%d ifid=%d)\n", if_name(ifp),
d1319 1
a1319 1
		    if_name(ifp), error));
@


1.9
log
@protect router list management by splsoftnet properly.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.8 2001/02/07 11:43:55 itojun Exp $	*/
d289 4
a292 3
				log(LOG_INFO, "nd6_ra_input: invalid option "
					"len %d for prefix information option, "
					"ignored\n", pi->nd_opt_pi_len);
d297 4
a300 3
				log(LOG_INFO, "nd6_ra_input: invalid prefix "
					"len %d for prefix information option, "
					"ignored\n", pi->nd_opt_pi_prefix_len);
d306 4
a309 3
				log(LOG_INFO, "nd6_ra_input: invalid prefix "
					"%s, ignored\n",
					ip6_sprintf(&pi->nd_opt_pi_prefix));
d316 5
a320 4
				log(LOG_INFO, "nd6_ra_input: invalid prefixlen "
					"%d for rfc2374 prefix %s, ignored\n",
					pi->nd_opt_pi_prefix_len,
					ip6_sprintf(&pi->nd_opt_pi_prefix));
d354 1
a354 1
			log(LOG_INFO, "nd6_ra_input: bogus mtu option "
d356 1
a356 1
			    mtu, ip6_sprintf(&ip6->ip6_src));
d369 1
a369 1
				log(LOG_INFO, "nd6_ra_input: bogus mtu "
d373 1
a373 1
				    ndi->maxmtu);
d376 1
a376 1
			log(LOG_INFO, "nd6_ra_input: mtu option "
d379 1
a379 1
			    mtu, ip6_sprintf(&ip6->ip6_src));
d471 1
a471 1
		log(LOG_ERR,	/* better error? */
d474 1
a474 1
		    if_name(ifp));
d484 1
a484 1
		log(LOG_ERR,
d487 1
a487 1
		    if_name(ifp), error);
d906 3
a908 2
				log(LOG_ERR, "prelist_update: failed to add a "
				    "new address\n");
d1002 2
a1003 2
			log(LOG_ERR, "prelist_update: "
				"failed to add a new address\n");
d1133 1
a1133 1
			log(LOG_ERR,
d1138 1
a1138 1
			    e);
d1168 1
a1168 1
		log(LOG_ERR,
d1171 1
a1171 1
		    ip6_sprintf(&pr->ndpr_addr), pr->ndpr_plen);
d1187 1
a1187 1
			log(LOG_ERR,
d1190 1
a1190 1
			    ip6_sprintf(&pr->ndpr_addr), pr->ndpr_plen, e);
d1240 1
a1240 1
		log(LOG_ERR, "in6_ifadd: wrong prefixlen for %s"
d1243 1
a1243 1
			128 - in6_mask2len(&ib->ia_prefixmask.sin6_addr));
d1318 2
a1319 1
		log(LOG_NOTICE, "in6_ifadd: failed to add an interface route "
d1322 1
a1322 1
		    if_name(ifp), error);
d1441 1
a1441 1
		log(LOG_INFO, "in6_init_prefix_ltimes: preferred lifetime"
d1443 1
a1443 1
		    (u_int)ndpr->ndpr_pltime, (u_int)ndpr->ndpr_vltime);
@


1.8
log
@by default, don't bark on inbound ND messages, as outsider may be able to
fill up /var with bogus packets.
setting net.inet6.icmp6.nd6_debug will re-enable kernel messages on invalid
ND packet and other occasions.

improve icmp6 stats.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.7 2000/06/13 04:12:40 itojun Exp $	*/
a809 1
	splx(s);
d817 2
@


1.7
log
@make sure to attach new in6_ifaddr into ifp->if_addrlist.
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6_rtr.c,v 1.6 2000/03/02 09:44:28 itojun Exp $	*/
/*	$KAME: nd6_rtr.c,v 1.40 2000/06/13 03:02:29 jinmei Exp $	*/
d123 5
a127 3
		log(LOG_ERR,
		    "nd6_rs_input: invalid hlim %d\n", ip6->ip6_hlim);
		goto freeit;
d151 3
a153 1
		log(LOG_INFO, "nd6_rs_input: invalid ND option, ignored\n");
d163 1
a163 1
		log(LOG_INFO,
d166 2
a167 1
			ip6_sprintf(&saddr6), ifp->if_addrlen, lladdrlen - 2);
d174 5
d211 5
a215 3
		log(LOG_ERR,
		    "nd6_ra_input: invalid hlim %d\n", ip6->ip6_hlim);
		goto freeit;
d219 1
a219 1
		log(LOG_ERR,
d221 2
a222 2
		    ip6_sprintf(&saddr6));
		goto freeit;
d239 3
a241 1
		log(LOG_INFO, "nd6_ra_input: invalid ND option, ignored\n");
d394 1
a394 1
		log(LOG_INFO,
d397 2
a398 1
			ip6_sprintf(&saddr6), ifp->if_addrlen, lladdrlen - 2);
d411 6
a416 1
freeit:
d634 4
d640 4
a644 4
			else	/* noisy log? */
				log(LOG_INFO, "defrouter_select: "
				    "there's no default router and no default"
				    " interface\n");
@


1.6
log
@do not add ifa_dstaddr for non-pointopoint interface.  IPv6 has no
concept for "broadcast".
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6_rtr.c,v 1.5 2000/02/28 11:55:23 itojun Exp $	*/
/*	$KAME: nd6_rtr.c,v 1.27 2000/02/26 06:53:11 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d667 1
a667 1
	 * just continue to use the current default router. 
d1238 7
a1244 1
	} else
d1246 2
d1251 3
a1253 14
	if (ifp->if_addrlist.tqh_first != NULL) {
		TAILQ_INSERT_TAIL(&ifp->if_addrlist, (struct ifaddr *)ia,
			ifa_list);
		ia->ia_ifa.ifa_refcnt++;
	}
#if 0
	else {
		/*
		 * this should not be the case because there is at least one
		 * link-local address(see the beginning of the function).
		 */
		TAILQ_INIT(&ifp->if_addrlist);
	}
#endif
d1465 1
a1465 1
 * it shouldn't be called when acting as a router. 
@


1.5
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.4 2000/02/07 06:09:10 itojun Exp $	*/
d1226 4
a1229 1
	ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ia->ia_dstaddr;
@


1.4
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/*	$OpenBSD: nd6_rtr.c,v 1.3 2000/01/08 05:49:41 angelos Exp $	*/
d72 1
a72 1
static void pfxlist_onlink_check __P((void));
d75 1
a82 3
#if 0
extern struct timeval time;
#endif
d85 2
a86 5
#if 0
static u_char bmask [] = {
	0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe,
};
#endif
d102 1
a102 2
	struct nd_router_solicit *nd_rs
		= (struct nd_router_solicit *)((caddr_t)ip6 + off);
d119 1
a119 1
		return;
d125 1
a125 1
		return;
d133 9
d143 2
d150 1
a150 1
		return;
d166 3
d186 1
a186 2
	struct nd_router_advert *nd_ra =
		(struct nd_router_advert *)((caddr_t)ip6 + off);
d190 1
a190 1
	int flags = nd_ra->nd_ra_flags_reserved;
d198 1
a198 1
		return;
d203 1
a203 1
		return;
d210 10
d222 1
d228 1
a228 1
		return;
d387 7
d395 3
a408 9
#if 0
	register struct radix_node *rn;
	register struct radix_node_head *rnh;
	struct sockaddr *ndst;
	struct ifnet *ifp = new->ifp;
	struct ifaddr *ifa;
	struct rtentry *rt;
	extern struct pool rtentry_pool;
#endif
a418 1
#if 1
a419 1

d425 26
a450 5
#else
	ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp);
	if (!ifa)
		return;
	if ((rnh = rt_tables[AF_INET6]) == 0)
d452 1
d454 11
a464 30
	s = splnet();
	R_Malloc(rt, struct rtentry *, sizeof(*rt));
	if (!rt)
		goto bad;
	Bzero(rt, sizeof(*rt));
	rt->rt_flags = RTF_UP | RTF_GATEWAY;
	if (rt_setgate(rt, (struct sockaddr *)&def, (struct sockaddr *)&gate)){
		Free(rt);
		goto bad;
	}
	ndst = rt_key(rt);
	Bcopy(&def, ndst, sizeof(def));
	rn = rnh->rnh_addaddr((caddr_t)ndst, (caddr_t)&mask,
			      rnh, rt->rt_nodes);
	if (rn == 0) {
		Free(rt_key(rt));
		Free(rt);
		goto bad;
	}
	ifa->ifa_refcnt++;
	rt->rt_ifa = ifa;
	rt->rt_ifp = ifp;
	rt->rt_rmx.rmx_mtu = ifa->ifa_ifp->if_mtu;
	/* xxx
	 * many codes should be stolen from route.c
	 */
bad:
	splx(s);
	return;
#endif
d474 2
a475 1
	for(dr = nd_defrouter.lh_first; dr; dr = dr->dr_next)
d478 1
d504 1
a504 1
	if (dofree)
a505 8

	if (nd_defrouter.lh_first)
		defrouter_addreq(nd_defrouter.lh_first);

	/*
	 * xxx update the Destination Cache entries for all
	 * destinations using that neighbor as a router (7.2.5)
	 */
d524 1
a524 1
	if (dr == nd_defrouter.lh_first)
d527 1
a527 1
	LIST_REMOVE(dr, dr_entry);
d540 3
a542 2
	 * If the router is the primary one, delete the default route
	 * entry in the routing table.
d545 2
a546 1
		defrouter_delreq(deldr, 0);
d550 78
d663 9
a671 7
	if (nd_defrouter.lh_first == NULL) {
		LIST_INSERT_HEAD(&nd_defrouter, n, dr_entry);
		defrouter_addreq(n);
	} else {
		LIST_INSERT_AFTER(nd_defrouter.lh_first, n, dr_entry);
		defrouter_addreq(n);
	}
d997 26
d1024 3
a1026 2
 * that advertised the prefix.
 * If the check fails, the prefix may be off-link because, for example,
d1030 1
a1030 1
 * But if there is no prefix that has an availble router, we still regards
d1035 1
a1035 1
static void
d1040 6
a1045 2
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next)
		if (pr->ndpr_advrtrs.lh_first) /* pr has an available router */
d1047 1
d1051 5
a1055 5
		 * There is at least one prefix that has a router. First,
		 * detach prefixes which has no advertising router and then
		 * attach other prefixes. The order is important since an
		 * attached prefix and a detached prefix may have a same
		 * interface route.
d1058 1
a1058 1
			if (pr->ndpr_advrtrs.lh_first == NULL &&
d1065 2
a1066 2
			if (pr->ndpr_advrtrs.lh_first &&
				 pr->ndpr_statef_onlink == 0)
d1071 1
a1071 1
		/* there is no prefix that has a router */
d1194 1
a1194 1
	ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp);
d1237 1
d1243 1
d1375 1
d1512 31
@


1.4.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: nd6_rtr.c,v 1.27 2000/02/26 06:53:11 itojun Exp $	*/
d71 1
a71 1
static struct nd_pfxrouter *find_pfxlist_reachable_router __P((struct nd_prefix *));
a73 1
static void defrouter_addifreq __P((struct ifnet *));
d81 3
d86 5
a90 2
struct ifnet *nd6_defifp;
int nd6_defifindex;
d106 2
a107 1
	struct nd_router_solicit *nd_rs;
d124 1
a124 1
		goto freeit;
d130 1
a130 1
		goto freeit;
a137 9
		goto freeit;

#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_rs = (struct nd_router_solicit *)((caddr_t)ip6 + off);
#else
	IP6_EXTHDR_GET(nd_rs, struct nd_router_solicit *, m, off, icmp6len);
	if (nd_rs == NULL) {
		icmp6stat.icp6s_tooshort++;
a138 2
	}
#endif
d144 1
a144 1
		goto freeit;
a159 3

 freeit:
	m_freem(m);
d177 2
a178 1
	struct nd_router_advert *nd_ra;
d182 1
a182 1
	int flags; /* = nd_ra->nd_ra_flags_reserved; */
d190 1
a190 1
		goto freeit;
d195 1
a195 1
		goto freeit;
a201 10
		goto freeit;
	}

#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_ra = (struct nd_router_advert *)((caddr_t)ip6 + off);
#else
	IP6_EXTHDR_GET(nd_ra, struct nd_router_advert *, m, off, icmp6len);
	if (nd_ra == NULL) {
		icmp6stat.icp6s_tooshort++;
a203 1
#endif
d209 1
a209 1
		goto freeit;
a367 7

	/*
	 * Installing a link-layer address might change the state of the
	 * router's neighbor cache, which might also affect our on-link
	 * detection of adveritsed prefixes.
	 */
	pfxlist_onlink_check();
a368 3

freeit:
	m_freem(m);
d380 9
d399 1
d401 1
d407 6
a412 1
}
d414 25
a438 18
/* Add a route to a given interface as default */
static void
defrouter_addifreq(ifp)
	struct ifnet *ifp;
{
	struct sockaddr_in6 def, mask;
	struct ifaddr *ifa;
	int error, flags;

	bzero(&def, sizeof(def));
	bzero(&mask, sizeof(mask));

	def.sin6_len = mask.sin6_len = sizeof(struct sockaddr_in6);
	def.sin6_family = mask.sin6_family = AF_INET6;

	/*
	 * Search for an ifaddr beloging to the specified interface.
	 * XXX: An IPv6 address are required to be assigned on the interface.
d440 4
a443 19
	if ((ifa = ifaof_ifpforaddr((struct sockaddr *)&def, ifp)) == NULL) {
		log(LOG_ERR,	/* better error? */
		    "defrouter_addifreq: failed to find an ifaddr "
		    "to install a route to interface %s\n",
		    if_name(ifp));
		return;
	}

	flags = ifa->ifa_flags;
	if ((ifp->if_flags & IFF_POINTOPOINT) != 0)
		flags &= ~RTF_CLONING;
	if ((error = rtrequest(RTM_ADD, (struct sockaddr *)&def,
			       ifa->ifa_addr, (struct sockaddr *)&mask,
			       flags, NULL)) != 0) {
		log(LOG_ERR,
		    "defrouter_addifreq: failed to install a route to "
		    "interface %s (errno = %d)\n",
		    if_name(ifp), error);
	}
d453 1
a453 2
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {
a455 1
	}
d481 1
a481 1
	if (dofree)		/* XXX: necessary? */
d483 8
d509 1
a509 1
	if (dr == TAILQ_FIRST(&nd_defrouter))
d512 1
a512 1
	TAILQ_REMOVE(&nd_defrouter, dr, dr_entry);
d525 2
a526 3
	 * If the router is the primary one, choose a new one.
	 * Note that defrouter_select() will remove the current gateway
	 * from the routing table.
d529 1
a529 2
		defrouter_select();

a532 78
/*
 * Default Router Selection according to Section 6.3.6 of RFC 2461:
 * 1) Routers that are reachable or probably reachable should be
 *    preferred.
 * 2) When no routers on the list are known to be reachable or
 *    probably reachable, routers SHOULD be selected in a round-robin
 *    fashion.
 * 3) If the Default Router List is empty, assume that all
 *    destinations are on-link.
 */
void
defrouter_select()
{
	int s = splnet();
	struct nd_defrouter *dr, anydr;
	struct rtentry *rt = NULL;
	struct llinfo_nd6 *ln = NULL;

	/*
	 * Search for a (probably) reachable router from the list.
	 */
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {
		if ((rt = nd6_lookup(&dr->rtaddr, 0, dr->ifp)) &&
		    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
		    ND6_IS_LLINFO_PROBREACH(ln)) {
			/* Got it, and move it to the head */
			TAILQ_REMOVE(&nd_defrouter, dr, dr_entry);
			TAILQ_INSERT_HEAD(&nd_defrouter, dr, dr_entry);
			break;
		}
	}

	if ((dr = TAILQ_FIRST(&nd_defrouter))) {
		/*
		 * De-install the previous default gateway and install
		 * a new one.
		 * Note that if there is no reachable router in the list,
		 * the head entry will be used anyway.
		 * XXX: do we have to check the current routing table entry?
		 */
		bzero(&anydr, sizeof(anydr));
		defrouter_delreq(&anydr, 0);
		defrouter_addreq(dr);
	}
	else {
		/*
		 * The Default Router List is empty, so install the default
		 * route to an inteface.
		 * XXX: The specification does not say this mechanism should
		 * be restricted to hosts, but this would be not useful
		 * (even harmful) for routers.
		 */
		if (!ip6_forwarding) {
			/*
			 * De-install the current default route
			 * in advance.
			 */
			bzero(&anydr, sizeof(anydr));
			defrouter_delreq(&anydr, 0);
			if (nd6_defifp) {
				/*
				 * Install a route to the default interface
				 * as default route.
				 */
				defrouter_addifreq(nd6_defifp);
			}
			else	/* noisy log? */
				log(LOG_INFO, "defrouter_select: "
				    "there's no default router and no default"
				    " interface\n");
		}
	}

	splx(s);
	return;
}

d568 7
a574 9

	/*
	 * Insert the new router at the end of the Default Router List.
	 * If there is no other router, install it anyway. Otherwise,
	 * just continue to use the current default router. 
	 */
	TAILQ_INSERT_TAIL(&nd_defrouter, n, dr_entry);
	if (TAILQ_FIRST(&nd_defrouter) == n)
		defrouter_select();
a899 26
 * A supplement function used in the on-link detection below;
 * detect if a given prefix has a (probably) reachable advertising router.
 * XXX: lengthy function name...
 */
static struct nd_pfxrouter *
find_pfxlist_reachable_router(pr)
	struct nd_prefix *pr;
{
	struct nd_pfxrouter *pfxrtr;
	struct rtentry *rt;
	struct llinfo_nd6 *ln;

	for (pfxrtr = LIST_FIRST(&pr->ndpr_advrtrs); pfxrtr;
	     pfxrtr = LIST_NEXT(pfxrtr, pfr_entry)) {
		if ((rt = nd6_lookup(&pfxrtr->router->rtaddr, 0,
				     pfxrtr->router->ifp)) &&
		    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
		    ND6_IS_LLINFO_PROBREACH(ln))
			break;	/* found */
	}

	return(pfxrtr);

}

/*
d901 2
a902 3
 * that advertised the prefix (A router is "available" if its neighbor cache
 * entry has reachable or probably reachable).
 * If the check fails, the prefix may be off-link, because, for example,
d906 1
a906 1
 * But if there is no prefix that has an available router, we still regards
d911 1
a911 1
void
d916 2
a917 6
	/*
	 * Check if there is a prefix that has a reachable advertising
	 * router.
	 */
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
		if (find_pfxlist_reachable_router(pr))
a918 1
	}
d922 5
a926 5
		 * There is at least one prefix that has a reachable router.
		 * First, detach prefixes which has no reachable advertising
		 * router and then attach other prefixes.
		 * The order is important since an attached prefix and a
		 * detached prefix may have a same interface route.
d929 1
a929 1
			if (find_pfxlist_reachable_router(pr) == NULL &&
d936 2
a937 2
			if (find_pfxlist_reachable_router(pr) &&
			    pr->ndpr_statef_onlink == 0)
d942 1
a942 1
		/* there is no prefix that has a reachable router */
d1065 1
a1065 1
	ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp, 0);/* 0 is OK? */
a1107 1
	ia->ia_ifa.ifa_refcnt++;
a1112 1
		ia->ia_ifa.ifa_refcnt++;
a1243 1
	IFAFREE(&ia->ia_ifa);
a1379 31
}

int
nd6_setdefaultiface(ifindex)
	int ifindex;
{
	int error = 0;

	if (ifindex < 0 || if_index < ifindex)
		return(EINVAL);

	if (nd6_defifindex != ifindex) {
		nd6_defifindex = ifindex;
		if (nd6_defifindex > 0)
			nd6_defifp = ifindex2ifnet[nd6_defifindex];
		else
			nd6_defifp = NULL;

		/*
		 * If the Default Router List is empty, install a route
		 * to the specified interface as default or remove the default
		 * route when the default interface becomes canceled.
		 * The check for the queue is actually redundant, but
		 * we do this here to avoid re-install the default route
		 * if the list is NOT empty.
		 */
		if (TAILQ_FIRST(&nd_defrouter) == NULL)
			defrouter_select();
	}

	return(error);
@


1.4.2.2
log
@Sync with -current
@
text
@d1226 1
a1226 4
	if (ifp->if_flags & IFF_POINTOPOINT)
		ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ia->ia_dstaddr;
	else
		ia->ia_ifa.ifa_dstaddr = NULL;
@


1.4.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6_rtr.c,v 1.10 2001/04/04 06:22:57 itojun Exp $	*/
/*	$KAME: nd6_rtr.c,v 1.97 2001/02/07 11:09:13 itojun Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
d123 3
a125 5
		nd6log((LOG_ERR,
		    "nd6_rs_input: invalid hlim (%d) from %s to %s on %s\n",
		    ip6->ip6_hlim, ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&ip6->ip6_dst), if_name(ifp)));
		goto bad;
d149 1
a149 3
		nd6log((LOG_INFO,
		    "nd6_rs_input: invalid ND option, ignored\n"));
		/* nd6_options have incremented stats */
d159 1
a159 1
		nd6log((LOG_INFO,
d162 1
a162 2
			ip6_sprintf(&saddr6), ifp->if_addrlen, lladdrlen - 2));
		goto bad;
a168 5
	return;

 bad:
	icmp6stat.icp6s_badrs++;
	m_freem(m);
d201 3
a203 5
		nd6log((LOG_ERR,
		    "nd6_ra_input: invalid hlim (%d) from %s to %s on %s\n",
		    ip6->ip6_hlim, ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&ip6->ip6_dst), if_name(ifp)));
		goto bad;
d207 1
a207 1
		nd6log((LOG_ERR,
d209 2
a210 2
		    ip6_sprintf(&saddr6)));
		goto bad;
d227 1
a227 3
		nd6log((LOG_INFO,
		    "nd6_ra_input: invalid ND option, ignored\n"));
		/* nd6_options have incremented stats */
d275 3
a277 4
				nd6log((LOG_INFO,
				    "nd6_ra_input: invalid option "
				    "len %d for prefix information option, "
				    "ignored\n", pi->nd_opt_pi_len));
d282 3
a284 4
				nd6log((LOG_INFO,
				    "nd6_ra_input: invalid prefix "
				    "len %d for prefix information option, "
				    "ignored\n", pi->nd_opt_pi_prefix_len));
d290 3
a292 4
				nd6log((LOG_INFO,
				    "nd6_ra_input: invalid prefix "
				    "%s, ignored\n",
				    ip6_sprintf(&pi->nd_opt_pi_prefix)));
d299 4
a302 5
				nd6log((LOG_INFO,
				    "nd6_ra_input: invalid prefixlen "
				    "%d for rfc2374 prefix %s, ignored\n",
				    pi->nd_opt_pi_prefix_len,
				    ip6_sprintf(&pi->nd_opt_pi_prefix)));
d336 1
a336 1
			nd6log((LOG_INFO, "nd6_ra_input: bogus mtu option "
d338 1
a338 1
			    mtu, ip6_sprintf(&ip6->ip6_src)));
d351 1
a351 1
				nd6log((LOG_INFO, "nd6_ra_input: bogus mtu "
d355 1
a355 1
				    ndi->maxmtu));
d358 1
a358 1
			nd6log((LOG_INFO, "nd6_ra_input: mtu option "
d361 1
a361 1
			    mtu, ip6_sprintf(&ip6->ip6_src)));
d380 1
a380 1
		nd6log((LOG_INFO,
d383 1
a383 2
			ip6_sprintf(&saddr6), ifp->if_addrlen, lladdrlen - 2));
		goto bad;
d396 1
a396 6
 freeit:
	m_freem(m);
	return;

 bad:
	icmp6stat.icp6s_badra++;
d447 1
a447 1
		nd6log((LOG_ERR,	/* better error? */
d450 1
a450 1
		    if_name(ifp)));
d460 1
a460 1
		nd6log((LOG_ERR,
d463 1
a463 1
		    if_name(ifp), error));
a613 4
				 * XXX: we enable this for host only, because
				 * this may override a default route installed
				 * a user process (e.g. routing daemon) in a
				 * router case.
d616 3
a618 2
			} else {
				nd6log((LOG_INFO, "defrouter_select: "
d620 1
a620 2
				    " interface\n"));
			}
d667 1
a667 1
	 * just continue to use the current default router.
d786 1
a793 2
	splx(s);

d877 2
a878 3
				nd6log((LOG_ERR,
				    "prelist_update: failed to add a "
				    "new address\n"));
d972 2
a973 2
			nd6log((LOG_ERR, "prelist_update: "
				"failed to add a new address\n"));
d1103 1
a1103 1
			nd6log((LOG_ERR,
d1108 1
a1108 1
			    e));
d1138 1
a1138 1
		nd6log((LOG_ERR,
d1141 1
a1141 1
		    ip6_sprintf(&pr->ndpr_addr), pr->ndpr_plen));
d1157 1
a1157 1
			nd6log((LOG_ERR,
d1160 1
a1160 1
			    ip6_sprintf(&pr->ndpr_addr), pr->ndpr_plen, e));
d1210 1
a1210 1
		nd6log((LOG_ERR, "in6_ifadd: wrong prefixlen for %s"
d1213 1
a1213 1
			128 - in6_mask2len(&ib->ia_prefixmask.sin6_addr)));
d1238 1
a1238 7
	} else {
		/*
		 * This should be impossible, since we have at least one
		 * link-local address (see the beginning of this function).
		 * XXX: should we rather panic here?
		 */
		printf("in6_ifadd: in6_ifaddr is NULL (impossible!)\n");
a1239 2
	}
	/* gain a refcnt for the link from in6_ifaddr */
d1243 14
a1256 3
	TAILQ_INSERT_TAIL(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
	/* gain another refcnt for the link from if_addrlist */
	ia->ia_ifa.ifa_refcnt++;
d1291 1
a1291 2
		nd6log((LOG_NOTICE,
		    "in6_ifadd: failed to add an interface route "
d1294 1
a1294 1
		    if_name(ifp), error));
d1413 1
a1413 1
		nd6log((LOG_INFO, "in6_init_prefix_ltimes: preferred lifetime"
d1415 1
a1415 1
		    (u_int)ndpr->ndpr_pltime, (u_int)ndpr->ndpr_vltime));
d1468 1
a1468 1
 * it shouldn't be called when acting as a router.
@


1.4.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.4.2.3 2001/05/14 22:40:20 niklas Exp $	*/
d59 2
d126 1
a126 1
		    ip6_sprintf(&ip6->ip6_dst), ifp->if_xname));
d214 1
a214 1
		    ip6_sprintf(&ip6->ip6_dst), ifp->if_xname));
d473 2
a474 1
		    "to install a route to interface %s\n", ifp->if_xname));
d487 1
a487 1
		    ifp->if_xname, error));
d1241 1
a1241 1
			"(prefix=%d ifid=%d)\n", ifp->if_xname,
d1322 1
a1322 1
		    ifp->if_xname, error));
@


1.4.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d384 1
a384 1
	 * Source link layer address
@


1.4.2.6
log
@Merge in -current from roughly a week ago
@
text
@d61 13
a73 13
static struct nd_defrouter *defrtrlist_update(struct nd_defrouter *);
static int prelist_add(struct nd_prefix *, struct nd_defrouter *);
static struct nd_prefix *prefix_lookup(struct nd_prefix *);
static struct in6_ifaddr *in6_ifadd(struct ifnet *, struct in6_addr *,
			  struct in6_addr *, int);
static struct nd_pfxrouter *pfxrtr_lookup(struct nd_prefix *,
					       struct nd_defrouter *);
static void pfxrtr_add(struct nd_prefix *, struct nd_defrouter *);
static void pfxrtr_del(struct nd_pfxrouter *);
static struct nd_pfxrouter *find_pfxlist_reachable_router(struct nd_prefix *);
static void nd6_detach_prefix(struct nd_prefix *);
static void nd6_attach_prefix(struct nd_prefix *);
static void defrouter_addifreq(struct ifnet *);
d75 1
a75 1
static void in6_init_address_ltimes(struct nd_prefix *ndpr,
d77 1
a77 1
					 int update_vltime);
d79 1
a79 1
static int rt6_deleteroute(struct radix_node *, void *);
@


1.4.2.7
log
@Sync the SMP branch with 3.3
@
text
@a60 1
static int rtpref(struct nd_defrouter *);
d62 4
a65 1
static struct in6_ifaddr *in6_ifadd(struct nd_prefix *);
d67 1
a67 1
	struct nd_defrouter *);
d71 2
a72 1
static void defrouter_delreq(struct nd_defrouter *);
a73 2
static void defrouter_delifreq(void);
static void nd6_rtmsg(int, struct rtentry *);
d75 3
a77 2
static void in6_init_address_ltimes(struct nd_prefix *,
	struct in6_addrlifetime *);
d83 1
a83 1
static struct ifnet *nd6_defifp;
a84 1
static struct ifaddr *nd6_defif_installed = NULL;
d164 1
a164 1
		    ip6_sprintf(&saddr6), ifp->if_addrlen, lladdrlen - 2));
d192 1
a192 1
	struct nd_ifinfo *ndi = ND_IFINFO(ifp);
a204 5
	/*
	 * We only accept RAs only when
	 * the system-wide variable allows the acceptance, and
	 * per-interface variable allows RAs on the receiving interface.
	 */
a206 2
	if (!(ndi->flags & ND6_IFF_ACCEPT_RTADV))
		goto freeit;
a247 1
	Bzero(&dr0, sizeof(dr0));
d275 1
a275 1
		struct nd_opt_prefix_info *pi = NULL;
a276 1
		long time_second = time.tv_sec;
d329 1
a329 1
			     ND_OPT_PI_FLAG_ONLINK) ? 1 : 0;
d331 1
a331 1
			     ND_OPT_PI_FLAG_AUTO) ? 1 : 0;
d334 2
a335 2
			pr.ndpr_pltime = ntohl(pi->nd_opt_pi_preferred_time);
			pr.ndpr_lastupdate = time_second;
d348 1
a348 4
		u_long mtu;
		u_long maxmtu;

		mtu = ntohl(ndopts.nd_opts_mtu->nd_opt_mtu_mtu);
d353 1
a353 1
			    "mtu=%lu sent from %s, ignoring\n",
d359 14
a372 8
		maxmtu = (ndi->maxmtu && ndi->maxmtu < ifp->if_mtu)
		    ? ndi->maxmtu : ifp->if_mtu;
		if (mtu <= maxmtu) {
			int change = (ndi->linkmtu != mtu);

			ndi->linkmtu = mtu;
			if (change) /* in6_maxmtu may change */
				in6_setmaxmtu();
d374 4
a377 4
			nd6log((LOG_INFO, "nd6_ra_input: bogus mtu "
			    "mtu=%lu sent from %s; "
			    "exceeds maxmtu %lu, ignoring\n",
			    mtu, ip6_sprintf(&ip6->ip6_src), maxmtu));
d382 1
a382 1

d389 1
a389 1

d398 2
a399 2
		    "(if %d, RA packet %d)\n", ip6_sprintf(&saddr6),
		    ifp->if_addrlen, lladdrlen - 2));
a424 20

/* tell the change to user processes watching the routing socket. */
static void
nd6_rtmsg(cmd, rt)
	int cmd;
	struct rtentry *rt;
{
	struct rt_addrinfo info;

	bzero((caddr_t)&info, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
	info.rti_info[RTAX_IFP] =
	    (struct sockaddr *)TAILQ_FIRST(&rt->rt_ifp->if_addrlist);
	info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;

	rt_missmsg(cmd, &info, rt->rt_flags, 0);
}

a429 1
	struct rtentry *newrt = NULL;
a430 1
	int error;
d434 1
a434 1
	Bzero(&gate, sizeof(gate)); /* for safety */
d436 2
a437 2
	def.sin6_len = mask.sin6_len = gate.sin6_len =
	    sizeof(struct sockaddr_in6);
a439 3
#ifndef SCOPEDROUTING
	gate.sin6_scope_id = 0;	/* XXX */
#endif
d441 4
a444 10
	s = splsoftnet();
	error = rtrequest(RTM_ADD, (struct sockaddr *)&def,
	    (struct sockaddr *)&gate, (struct sockaddr *)&mask,
	    RTF_GATEWAY, &newrt);
	if (newrt) {
		nd6_rtmsg(RTM_ADD, newrt); /* tell user process */
		newrt->rt_refcnt--;
	}
	if (error == 0)
		new->installed = 1;
a455 1
	struct rtentry *newrt = NULL;
a456 5
	struct rt_addrinfo info;

	/* remove one if we have already installed one */
	if (nd6_defif_installed)
		defrouter_delifreq();
d471 1
a471 2
		    "to install a route to interface %s\n",
		    ifp->if_xname));
d475 6
a480 10
	/* RTF_CLONING is necessary to make sure to perform ND */
	flags = ifa->ifa_flags | RTF_CLONING;
	bzero(&info, sizeof(info));
	info.rti_info[RTAX_DST] = (struct sockaddr *)&def;
	info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)ifa->ifa_addr;
	info.rti_info[RTAX_NETMASK] = (struct sockaddr *)&mask;
	info.rti_info[RTAX_IFA] = (struct sockaddr *)ifa->ifa_addr;
	info.rti_flags = flags;
	error = rtrequest1(RTM_ADD, &info, &newrt);
	if (error != 0) {
a484 43

		if (newrt)	/* maybe unnecessary, but do it for safety */
			newrt->rt_refcnt--;
	} else {
		if (newrt) {
			nd6_rtmsg(RTM_ADD, newrt);
			newrt->rt_refcnt--;
		}
	}

	nd6_defif_installed = ifa;
	ifa->ifa_refcnt++;
}

/* Remove a default route points to interface */
static void
defrouter_delifreq()
{
	struct sockaddr_in6 def, mask;
	struct rtentry *oldrt = NULL;

	if (!nd6_defif_installed)
		return;

	Bzero(&def, sizeof(def));
	Bzero(&mask, sizeof(mask));

	def.sin6_len = mask.sin6_len = sizeof(struct sockaddr_in6);
	def.sin6_family = mask.sin6_family = AF_INET6;

	rtrequest(RTM_DELETE, (struct sockaddr *)&def,
	    (struct sockaddr *)nd6_defif_installed->ifa_addr,
	    (struct sockaddr *)&mask, RTF_GATEWAY, &oldrt);
	if (oldrt) {
		nd6_rtmsg(RTM_DELETE, oldrt);
		if (oldrt->rt_refcnt <= 0) {
			/*
			 * XXX: borrowed from the RTM_DELETE case of
			 * rtrequest().
			 */
			oldrt->rt_refcnt++;
			rtfree(oldrt);
		}
a485 3

	IFAFREE(nd6_defif_installed);
	nd6_defif_installed = NULL;
d497 2
a498 3
		if (dr->ifp == ifp && IN6_ARE_ADDR_EQUAL(addr, &dr->rtaddr)) {
			return (dr);
		}
d501 26
a526 1
	return (NULL);		/* search failed */
d540 2
a541 1
	if (!ip6_forwarding && ip6_accept_rtadv) /* XXX: better condition? */
d543 4
a547 4
	if (dr->installed) {
		deldr = dr;
		defrouter_delreq(dr);
	}
d572 3
a574 71
 * Remove the default route for a given router.
 * This is just a subroutine function for defrouter_select(), and should
 * not be called from anywhere else.
 */
static void
defrouter_delreq(dr)
	struct nd_defrouter *dr;
{
	struct sockaddr_in6 def, mask, gw;
	struct rtentry *oldrt = NULL;

#ifdef DIAGNOSTIC
	if (!dr)
		panic("dr == NULL in defrouter_delreq");
#endif

	Bzero(&def, sizeof(def));
	Bzero(&mask, sizeof(mask));
	Bzero(&gw, sizeof(gw));	/* for safety */

	def.sin6_len = mask.sin6_len = gw.sin6_len =
	    sizeof(struct sockaddr_in6);
	def.sin6_family = mask.sin6_family = gw.sin6_family = AF_INET6;
	gw.sin6_addr = dr->rtaddr;
#ifndef SCOPEDROUTING
	gw.sin6_scope_id = 0;	/* XXX */
#endif

	rtrequest(RTM_DELETE, (struct sockaddr *)&def,
	    (struct sockaddr *)&gw,
	    (struct sockaddr *)&mask, RTF_GATEWAY, &oldrt);
	if (oldrt) {
		nd6_rtmsg(RTM_DELETE, oldrt);
		if (oldrt->rt_refcnt <= 0) {
			/*
			 * XXX: borrowed from the RTM_DELETE case of
			 * rtrequest().
			 */
			oldrt->rt_refcnt++;
			rtfree(oldrt);
		}
	}

	dr->installed = 0;
}

/*
 * remove all default routes from default router list
 */
void
defrouter_reset()
{
	struct nd_defrouter *dr;

	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry))
		defrouter_delreq(dr);
	defrouter_delifreq();

	/*
	 * XXX should we also nuke any default routers in the kernel, by
	 * going through them by rtalloc1()?
	 */
}

/*
 * Default Router Selection according to Section 6.3.6 of RFC 2461 and
 * draft-ietf-ipngwg-router-selection:
 * 1) Routers that are reachable or probably reachable should be preferred.
 *    If we have more than one (probably) reachable router, prefer ones
 *    with the highest router preference.
d577 1
a577 1
 *    fashion, regardless of router preference values.
a579 9
 *
 * We assume nd_defrouter is sorted by router preference value.
 * Since the code below covers both with and without router preference cases,
 * we do not need to classify the cases by ifdef.
 *
 * At this moment, we do not try to install more than one default router,
 * even when the multipath routing is available, because we're not sure about
 * the benefits for stub hosts comparing to the risk of making the code
 * complicated and the possibility of introducing bugs.
d584 2
a585 2
	int s = splsoftnet();
	struct nd_defrouter *dr, *selected_dr = NULL, *installed_dr = NULL;
d590 1
a590 4
	 * This function should be called only when acting as an autoconfigured
	 * host.  Although the remaining part of this function is not effective
	 * if the node is not an autoconfigured host, we explicitly exclude
	 * such cases here for safety.
d592 10
a601 6
	if (ip6_forwarding || !ip6_accept_rtadv) {
		nd6log((LOG_WARNING,
		    "defrouter_select: called unexpectedly (forwarding=%d, "
		    "accept_rtadv=%d)\n", ip6_forwarding, ip6_accept_rtadv));
		splx(s);
		return;
d604 13
a616 6
	/*
	 * Let's handle easy case (3) first:
	 * If default router list is empty, we should probably install
	 * an interface route and assume that all destinations are on-link.
	 */
	if (!TAILQ_FIRST(&nd_defrouter)) {
d618 2
a622 3
		 * This test is meaningless due to a test at the beginning of
		 * the function, but we intentionally keep it to make the note
		 * clear.
d625 6
d635 4
a641 5
				/*
				 * purge the existing route.
				 * XXX: is this really correct?
				 */
				defrouter_delifreq();
a646 63
		splx(s);
		return;
	}

	/*
	 * If we have a default route for the default interface, delete it.
	 * Note that the existence of the route is checked in the delete
	 * function.
	 */
	defrouter_delifreq();

	/*
	 * Search for a (probably) reachable router from the list.
	 * We just pick up the first reachable one (if any), assuming that
	 * the ordering rule of the list described in defrtrlist_update().
	 */
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {
		if (!selected_dr &&
		    (rt = nd6_lookup(&dr->rtaddr, 0, dr->ifp)) &&
		    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
		    ND6_IS_LLINFO_PROBREACH(ln)) {
			selected_dr = dr;
		}

		if (dr->installed && !installed_dr)
			installed_dr = dr;
		else if (dr->installed && installed_dr) {
			/* this should not happen.  warn for diagnosis. */
			log(LOG_ERR, "defrouter_select: more than one router"
			    " is installed\n");
		}
	}
	/*
	 * If none of the default routers was found to be reachable,
	 * round-robin the list regardless of preference.
	 * Otherwise, if we have an installed router, check if the selected
	 * (reachable) router should really be preferred to the installed one.
	 * We only prefer the new router when the old one is not reachable
	 * or when the new one has a really higher preference value.
	 */
	if (!selected_dr) {
		if (!installed_dr || !TAILQ_NEXT(installed_dr, dr_entry))
			selected_dr = TAILQ_FIRST(&nd_defrouter);
		else
			selected_dr = TAILQ_NEXT(installed_dr, dr_entry);
	} else if (installed_dr &&
	    (rt = nd6_lookup(&installed_dr->rtaddr, 0, installed_dr->ifp)) &&
	    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) &&
	    ND6_IS_LLINFO_PROBREACH(ln) &&
	    rtpref(selected_dr) <= rtpref(installed_dr)) {
		selected_dr = installed_dr;
	}

	/*
	 * If the selected router is different than the installed one,
	 * remove the installed router and install the selected one.
	 * Note that the selected router is never NULL here.
	 */
	if (installed_dr != selected_dr) {
		if (installed_dr)
			defrouter_delreq(installed_dr);
		defrouter_addreq(selected_dr);
a652 31
/*
 * for default router selection
 * regards router-preference field as a 2-bit signed integer
 */
static int
rtpref(struct nd_defrouter *dr)
{
#ifdef RTPREF
	switch (dr->flags & ND_RA_FLAG_RTPREF_MASK) {
	case ND_RA_FLAG_RTPREF_HIGH:
		return RTPREF_HIGH;
	case ND_RA_FLAG_RTPREF_MEDIUM:
	case ND_RA_FLAG_RTPREF_RSV:
		return RTPREF_MEDIUM;
	case ND_RA_FLAG_RTPREF_LOW:
		return RTPREF_LOW;
	default:
		/*
		 * This case should never happen.  If it did, it would mean a
		 * serious bug of kernel internal.  We thus always bark here.
		 * Or, can we even panic?
		 */
		log(LOG_ERR, "rtpref: impossible RA flag %x", dr->flags);
		return RTPREF_INVALID;
	}
	/* NOTREACHED */
#else
	return 0;
#endif
}

d658 1
a658 1
	int s = splsoftnet();
a665 2
			int oldpref = rtpref(dr);

a669 22

			/*
			 * If the preference does not change, there's no need
			 * to sort the entries.
			 */
			if (rtpref(new) == oldpref) {
				splx(s);
				return (dr);
			}

			/*
			 * preferred router may be changed, so relocate
			 * this router.
			 * XXX: calling TAILQ_REMOVE directly is a bad manner.
			 * However, since defrtrlist_del() has many side
			 * effects, we intentionally do so here.
			 * defrouter_select() below will handle routing
			 * changes later.
			 */
			TAILQ_REMOVE(&nd_defrouter, dr, dr_entry);
			n = dr;
			goto insert;
d672 1
a672 1
		return (dr);
d678 1
a678 1
		return (NULL);
d684 1
a684 1
		return (NULL);
a688 1
insert:
d690 3
a692 4
	 * Insert the new router in the Default Router List;
	 * The Default Router List should be in the descending order
	 * of router-preferece.  Routers with the same preference are
	 * sorted in the arriving time order.
d694 3
a696 14

	/* insert at the end of the group */
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {
		if (rtpref(n) > rtpref(dr))
			break;
	}
	if (dr)
		TAILQ_INSERT_BEFORE(dr, n, dr_entry);
	else
		TAILQ_INSERT_TAIL(&nd_defrouter, n, dr_entry);

	defrouter_select();

d698 2
a699 2

	return (n);
d708 1
a708 1

d714 1
a714 1
	return (search);
d743 2
a744 2
struct nd_prefix *
nd6_prefix_lookup(pr)
d753 3
a755 1
		    &search->ndpr_prefix.sin6_addr, pr->ndpr_plen)) {
d760 1
a760 1
	return (search);
d763 3
a765 3
int
nd6_prelist_add(pr, dr, newp)
	struct nd_prefix *pr, **newp;
d768 1
a768 1
	struct nd_prefix *new = NULL;
a775 2
	if (newp != NULL)
		*newp = new;
d778 1
d784 5
a788 1
		    new->ndpr_mask.s6_addr32[i];
a789 1
	s = splsoftnet();
a793 13
	/* ND_OPT_PI_FLAG_ONLINK processing */
	if (new->ndpr_raf_onlink) {
		int e;

		if ((e = nd6_prefix_onlink(new)) != 0) {
			nd6log((LOG_ERR, "nd6_prelist_add: failed to make "
			    "the prefix %s/%d on-link on %s (errno=%d)\n",
			    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
			    pr->ndpr_plen, pr->ndpr_ifp->if_xname, e));
			/* proceed anyway. XXX: is it correct? */
		}
	}

d805 1
a805 1
	int e, s;
d807 1
a807 24
	/* make sure to invalidate the prefix until it is really freed. */
	pr->ndpr_vltime = 0;
	pr->ndpr_pltime = 0;
#if 0
	/*
	 * Though these flags are now meaningless, we'd rather keep the value
	 * not to confuse users when executing "ndp -p".
	 */
	pr->ndpr_raf_onlink = 0;
	pr->ndpr_raf_auto = 0;
#endif
	if ((pr->ndpr_stateflags & NDPRF_ONLINK) != 0 &&
	    (e = nd6_prefix_offlink(pr)) != 0) {
		nd6log((LOG_ERR, "prelist_remove: failed to make %s/%d offlink "
		    "on %s, errno=%d\n",
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
		    pr->ndpr_plen, pr->ndpr_ifp->if_xname, e));
		/* what should we do? */
	}

	if (pr->ndpr_refcnt > 0)
		return;		/* notice here? */

	s = splsoftnet();
d825 6
d837 1
a837 3
	struct in6_ifaddr *ia6 = NULL, *ia6_match = NULL;
	struct ifaddr *ifa;
	struct ifnet *ifp = new->ndpr_ifp;
d839 2
a840 1
	int s = splsoftnet();
a841 1
	int newprefix = 0;
d843 1
a843 1
	struct in6_addrlifetime lt6_tmp;
d851 4
a854 1
		auth = ((m->m_flags & M_AUTH_AH) && (m->m_flags & M_AUTH));
d857 11
a867 5
	if ((pr = nd6_prefix_lookup(new)) != NULL) {
		/*
		 * nd6_prefix_lookup() ensures that pr and new have the same
		 * prefix on a same interface.
		 */
d870 2
a871 3
		 * Update prefix information.  Note that the on-link (L) bit
		 * and the autonomous (A) bit should NOT be changed from 1
		 * to 0.
d873 2
a874 11
		if (new->ndpr_raf_onlink == 1)
			pr->ndpr_raf_onlink = 1;
		if (new->ndpr_raf_auto == 1)
			pr->ndpr_raf_auto = 1;
		if (new->ndpr_raf_onlink) {
			pr->ndpr_vltime = new->ndpr_vltime;
			pr->ndpr_pltime = new->ndpr_pltime;
			pr->ndpr_preferred = new->ndpr_preferred;
			pr->ndpr_expire = new->ndpr_expire;
			pr->ndpr_lastupdate = new->ndpr_lastupdate;
		}
d876 4
a879 3
		if (new->ndpr_raf_onlink &&
		    (pr->ndpr_stateflags & NDPRF_ONLINK) == 0) {
			int e;
d881 22
a902 1
			if ((e = nd6_prefix_onlink(pr)) != 0) {
d904 3
a906 6
				    "prelist_update: failed to make "
				    "the prefix %s/%d on-link on %s "
				    "(errno=%d)\n",
				    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
				    pr->ndpr_plen, pr->ndpr_ifp->if_xname, e));
				/* proceed anyway. XXX: is it correct? */
a907 1
		}
d909 17
a925 4
		if (dr && pfxrtr_lookup(pr, dr) == NULL)
			pfxrtr_add(pr, dr);
	} else {
		struct nd_prefix *newpr = NULL;
d927 1
a927 1
		newprefix = 1;
d929 15
a943 4
		if (new->ndpr_vltime == 0)
			goto end;
		if (new->ndpr_raf_onlink == 0 && new->ndpr_raf_auto == 0)
			goto end;
d945 12
a956 10
		error = nd6_prelist_add(new, dr, &newpr);
		if (error != 0 || newpr == NULL) {
			nd6log((LOG_NOTICE, "prelist_update: "
			    "nd6_prelist_add failed for %s/%d on %s "
			    "errno=%d, returnpr=%p\n",
			    ip6_sprintf(&new->ndpr_prefix.sin6_addr),
			    new->ndpr_plen, new->ndpr_ifp->if_xname,
			    error, newpr));
			goto end; /* we should just give up in this case. */
		}
d958 4
a961 11
		/*
		 * XXX: from the ND point of view, we can ignore a prefix
		 * with the on-link bit being zero.  However, we need a
		 * prefix structure for references from autoconfigured
		 * addresses.  Thus, we explicitly make sure that the prefix
		 * itself expires now.
		 */
		if (newpr->ndpr_raf_onlink == 0) {
			newpr->ndpr_vltime = 0;
			newpr->ndpr_pltime = 0;
			in6_init_prefix_ltimes(newpr);
d964 1
a964 47
		pr = newpr;
	}

	/*
	 * Address autoconfiguration based on Section 5.5.3 of RFC 2462.
	 * Note that pr must be non NULL at this point.
	 */

	/* 5.5.3 (a). Ignore the prefix without the A bit set. */
	if (!new->ndpr_raf_auto)
		goto end;

	/*
	 * 5.5.3 (b). the link-local prefix should have been ignored in
	 * nd6_ra_input.
	 */

	/*
	 * 5.5.3 (c). Consistency check on lifetimes: pltime <= vltime.
	 * This should have been done in nd6_ra_input.
	 */

	/*
	 * 5.5.3 (d). If the prefix advertised does not match the prefix of an
	 * address already in the list, and the Valid Lifetime is not 0,
	 * form an address.  Note that even a manually configured address
	 * should reject autoconfiguration of a new address.
	 */
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
	{
		struct in6_ifaddr *ifa6;
		int ifa_plen;
		u_int32_t storedlifetime;
		long time_second = time.tv_sec;

		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;

		ifa6 = (struct in6_ifaddr *)ifa;

		/*
		 * Spec is not clear here, but I believe we should concentrate
		 * on unicast (i.e. not anycast) addresses.
		 * XXX: other ia6_flags? detached or duplicated?
		 */
		if ((ifa6->ia6_flags & IN6_IFF_ANYCAST) != 0)
			continue;
a965 52
		ifa_plen = in6_mask2len(&ifa6->ia_prefixmask.sin6_addr, NULL);
		if (ifa_plen != new->ndpr_plen ||
		    !in6_are_prefix_equal(&ifa6->ia_addr.sin6_addr,
		    &new->ndpr_prefix.sin6_addr, ifa_plen))
			continue;

		if (ia6_match == NULL) /* remember the first one */
			ia6_match = ifa6;

		if ((ifa6->ia6_flags & IN6_IFF_AUTOCONF) == 0)
			continue;

		/*
		 * An already autoconfigured address matched.  Now that we
		 * are sure there is at least one matched address, we can
		 * proceed to 5.5.3. (e): update the lifetimes according to the
		 * "two hours" rule and the privacy extension.
		 */
#define TWOHOUR		(120*60)
		/*
		 * RFC2462 introduces the notion of StoredLifetime to the
		 * "two hours" rule as follows:
		 *   the Lifetime associated with the previously autoconfigured
		 *   address.
		 * Our interpretation of this definition is "the remaining
		 * lifetime to expiration at the evaluation time".  One might
		 * be wondering if this interpretation is really conform to the
		 * RFC, because the text can read that "Lifetimes" are never
		 * decreased, and our definition of the "storedlifetime" below
		 * essentially reduces the "Valid Lifetime" advertised in the
		 * previous RA.  But, this is due to the wording of the text,
		 * and our interpretation is the same as an author's intention.
		 * See the discussion in the IETF ipngwg ML in August 2001,
		 * with the Subject "StoredLifetime in RFC 2462".
		 */
		lt6_tmp = ifa6->ia6_lifetime;
		if (lt6_tmp.ia6t_vltime == ND6_INFINITE_LIFETIME)
			storedlifetime = ND6_INFINITE_LIFETIME;
		else if (time_second - ifa6->ia6_updatetime >
			 lt6_tmp.ia6t_vltime) {
			/*
			 * The case of "invalid" address.  We should usually
			 * not see this case.
			 */
			storedlifetime = 0;
		} else
			storedlifetime = lt6_tmp.ia6t_vltime -
				(time_second - ifa6->ia6_updatetime);
		if (TWOHOUR < new->ndpr_vltime ||
		    storedlifetime < new->ndpr_vltime) {
			lt6_tmp.ia6t_vltime = new->ndpr_vltime;
		} else if (storedlifetime <= TWOHOUR
d967 8
a974 6
			   /*
			    * This condition is logically redundant, so we just
			    * omit it.
			    * See IPng 6712, 6717, and 6721.
			    */
			   && new->ndpr_vltime <= storedlifetime
a975 11
			) {
			if (auth) {
				lt6_tmp.ia6t_vltime = new->ndpr_vltime;
			}
		} else {
			/*
			 * new->ndpr_vltime <= TWOHOUR &&
			 * TWOHOUR < storedlifetime
			 */
			lt6_tmp.ia6t_vltime = TWOHOUR;
		}
d977 6
a982 2
		/* The 2 hour rule is not imposed for preferred lifetime. */
		lt6_tmp.ia6t_pltime = new->ndpr_pltime;
d984 1
a984 1
		in6_init_address_ltimes(pr, &lt6_tmp);
a985 4
		ifa6->ia6_lifetime = lt6_tmp;
		ifa6->ia6_updatetime = time_second;
	}
	if (ia6_match == NULL && new->ndpr_vltime) {
d987 4
a990 2
		 * No address matched and the valid lifetime is non-zero.
		 * Create a new address.
d992 2
a993 6
		if ((ia6 = in6_ifadd(new)) != NULL) {
			/*
			 * note that we should use pr (not new) for reference.
			 */
			pr->ndpr_refcnt++;
			ia6->ia6_ndpr = pr;
d995 21
a1015 10
			/*
			 * A newly added address might affect the status
			 * of other addresses, so we check and update it.
			 * XXX: what if address duplication happens?
			 */
			pfxlist_onlink_check();
		} else {
			/* just set an error. do not bark here. */
			error = EADDRNOTAVAIL; /* XXX: might be unused. */
		}
d1039 1
a1039 1
		    pfxrtr->router->ifp)) &&
d1045 2
a1046 1
	return (pfxrtr);
d1051 2
a1052 2
 * that advertised the prefix (a router is "available" if its neighbor cache
 * entry is reachable or probably reachable).
d1055 4
a1058 4
 * expired yet.  So we should not use the prefix if there is another prefix
 * that has an available router.
 * But, if there is no prefix that has an available router, we still regards
 * all the prefixes as on-link.  This is because we can't tell if all the
a1065 1
	struct in6_ifaddr *ifa;
d1072 1
a1072 1
		if (pr->ndpr_raf_onlink && find_pfxlist_reachable_router(pr))
d1075 2
a1076 1
	if (pr != NULL || TAILQ_FIRST(&nd_defrouter) != NULL) {
d1078 5
a1082 7
		 * There is at least one prefix that has a reachable router,
		 * or at least a router which probably does not advertise
		 * any prefixes.  The latter would be the case when we move
		 * to a new link where we have a router that does not provide
		 * prefixes and we configure an address by hand.
		 * Detach prefixes which have no reachable advertising
		 * router, and attach other prefixes.
d1085 5
a1089 17
			/* XXX: a link-local prefix should never be detached */
			if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
				continue;

			/*
			 * we aren't interested in prefixes without the L bit
			 * set.
			 */
			if (pr->ndpr_raf_onlink == 0)
				continue;

			if ((pr->ndpr_stateflags & NDPRF_DETACHED) == 0 &&
			    find_pfxlist_reachable_router(pr) == NULL)
				pr->ndpr_stateflags |= NDPRF_DETACHED;
			if ((pr->ndpr_stateflags & NDPRF_DETACHED) != 0 &&
			    find_pfxlist_reachable_router(pr) != 0)
				pr->ndpr_stateflags &= ~NDPRF_DETACHED;
a1090 2
	} else {
		/* there is no prefix that has a reachable router */
d1092 3
a1094 87
			if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
				continue;

			if (pr->ndpr_raf_onlink == 0)
				continue;

			if ((pr->ndpr_stateflags & NDPRF_DETACHED) != 0)
				pr->ndpr_stateflags &= ~NDPRF_DETACHED;
		}
	}

	/*
	 * Remove each interface route associated with a (just) detached
	 * prefix, and reinstall the interface route for a (just) attached
	 * prefix.  Note that all attempt of reinstallation does not
	 * necessarily success, when a same prefix is shared among multiple
	 * interfaces.  Such cases will be handled in nd6_prefix_onlink,
	 * so we don't have to care about them.
	 */
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
		int e;

		if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
			continue;

		if (pr->ndpr_raf_onlink == 0)
			continue;

		if ((pr->ndpr_stateflags & NDPRF_DETACHED) != 0 &&
		    (pr->ndpr_stateflags & NDPRF_ONLINK) != 0) {
			if ((e = nd6_prefix_offlink(pr)) != 0) {
				nd6log((LOG_ERR,
				    "pfxlist_onlink_check: failed to "
				    "make %s/%d offlink, errno=%d\n",
				    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
				    pr->ndpr_plen, e));
			}
		}
		if ((pr->ndpr_stateflags & NDPRF_DETACHED) == 0 &&
		    (pr->ndpr_stateflags & NDPRF_ONLINK) == 0 &&
		    pr->ndpr_raf_onlink) {
			if ((e = nd6_prefix_onlink(pr)) != 0) {
				nd6log((LOG_ERR,
				    "pfxlist_onlink_check: failed to "
				    "make %s/%d offlink, errno=%d\n",
				    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
				    pr->ndpr_plen, e));
			}
		}
	}

	/*
	 * Changes on the prefix status might affect address status as well.
	 * Make sure that all addresses derived from an attached prefix are
	 * attached, and that all addresses derived from a detached prefix are
	 * detached.  Note, however, that a manually configured address should
	 * always be attached.
	 * The precise detection logic is same as the one for prefixes.
	 */
	for (ifa = in6_ifaddr; ifa; ifa = ifa->ia_next) {
		if (!(ifa->ia6_flags & IN6_IFF_AUTOCONF))
			continue;

		if (ifa->ia6_ndpr == NULL) {
			/*
			 * This can happen when we first configure the address
			 * (i.e. the address exists, but the prefix does not).
			 * XXX: complicated relationships...
			 */
			continue;
		}

		if (find_pfxlist_reachable_router(ifa->ia6_ndpr))
			break;
	}
	if (ifa) {
		for (ifa = in6_ifaddr; ifa; ifa = ifa->ia_next) {
			if ((ifa->ia6_flags & IN6_IFF_AUTOCONF) == 0)
				continue;

			if (ifa->ia6_ndpr == NULL) /* XXX: see above. */
				continue;

			if (find_pfxlist_reachable_router(ifa->ia6_ndpr))
				ifa->ia6_flags &= ~IN6_IFF_DETACHED;
			else
				ifa->ia6_flags |= IN6_IFF_DETACHED;
d1098 4
a1101 6
		for (ifa = in6_ifaddr; ifa; ifa = ifa->ia_next) {
			if ((ifa->ia6_flags & IN6_IFF_AUTOCONF) == 0)
				continue;

			ifa->ia6_flags &= ~IN6_IFF_DETACHED;
		}
d1105 2
a1106 2
int
nd6_prefix_onlink(pr)
d1109 2
a1110 15
	struct ifaddr *ifa;
	struct ifnet *ifp = pr->ndpr_ifp;
	struct sockaddr_in6 mask6;
	struct nd_prefix *opr;
	u_long rtflags;
	int error = 0;
	struct rtentry *rt = NULL;

	/* sanity check */
	if ((pr->ndpr_stateflags & NDPRF_ONLINK) != 0) {
		nd6log((LOG_ERR,
		    "nd6_prefix_onlink: %s/%d is already on-link\n",
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr), pr->ndpr_plen);
		return (EEXIST));
	}
d1113 1
a1113 5
	 * Add the interface route associated with the prefix.  Before
	 * installing the route, check if there's the same prefix on another
	 * interface, and the prefix has already installed the interface route.
	 * Although such a configuration is expected to be rare, we explicitly
	 * allow it.
d1115 11
a1125 6
	for (opr = nd_prefix.lh_first; opr; opr = opr->ndpr_next) {
		if (opr == pr)
			continue;

		if ((opr->ndpr_stateflags & NDPRF_ONLINK) == 0)
			continue;
d1127 9
a1135 20
		if (opr->ndpr_plen == pr->ndpr_plen &&
		    in6_are_prefix_equal(&pr->ndpr_prefix.sin6_addr,
		    &opr->ndpr_prefix.sin6_addr, pr->ndpr_plen))
			return (0);
	}

	/*
	 * We prefer link-local addresses as the associated interface address.
	 */
	/* search for a link-local addr */
	ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp,
	    IN6_IFF_NOTREADY | IN6_IFF_ANYCAST);
	if (ifa == NULL) {
		/* XXX: freebsd does not have ifa_ifwithaf */
		for (ifa = ifp->if_addrlist.tqh_first;
		     ifa;
		     ifa = ifa->ifa_list.tqe_next)
		{
			if (ifa->ifa_addr->sa_family == AF_INET6)
				break;
a1136 15
		/* should we care about ia6_flags? */
	}
	if (ifa == NULL) {
		/*
		 * This can still happen, when, for example, we receive an RA
		 * containing a prefix with the L bit set and the A bit clear,
		 * after removing all IPv6 addresses on the receiving
		 * interface.  This should, of course, be rare though.
		 */
		nd6log((LOG_NOTICE,
		    "nd6_prefix_onlink: failed to find any ifaddr"
		    " to add route for a prefix(%s/%d) on %s\n",
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
		    pr->ndpr_plen, ifp->if_xname));
		return (0);
d1140 2
a1141 2
	 * in6_ifinit() sets nd6_rtrequest to ifa_rtrequest for all ifaddrs.
	 * ifa->ifa_rtrequest = nd6_rtrequest;
d1143 6
a1148 34
	bzero(&mask6, sizeof(mask6));
	mask6.sin6_len = sizeof(mask6);
	mask6.sin6_addr = pr->ndpr_mask;
	/* rtrequest() will probably set RTF_UP, but we're not sure. */
	rtflags = ifa->ifa_flags | RTF_UP;
	if (nd6_need_cache(ifp)) {
		/* explicitly set in case ifa_flags does not set the flag. */
		rtflags |= RTF_CLONING;
	} else {
		/*
		 * explicitly clear the cloning bit in case ifa_flags sets it.
		 */
		rtflags &= ~RTF_CLONING;
	}
	error = rtrequest(RTM_ADD, (struct sockaddr *)&pr->ndpr_prefix,
	    ifa->ifa_addr, (struct sockaddr *)&mask6, rtflags, &rt);
	if (error == 0) {
		if (rt != NULL) /* this should be non NULL, though */
			nd6_rtmsg(RTM_ADD, rt);
		pr->ndpr_stateflags |= NDPRF_ONLINK;
	} else {
		nd6log((LOG_ERR, "nd6_prefix_onlink: failed to add route for a"
		    " prefix (%s/%d) on %s, gw=%s, mask=%s, flags=%lx "
		    "errno = %d\n",
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr),
		    pr->ndpr_plen, ifp->if_xname,
		    ip6_sprintf(&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr),
		    ip6_sprintf(&mask6.sin6_addr), rtflags, error));
	}

	if (rt != NULL)
		rt->rt_refcnt--;

	return (error);
d1151 2
a1152 2
int
nd6_prefix_offlink(pr)
d1155 2
a1156 5
	int error = 0;
	struct ifnet *ifp = pr->ndpr_ifp;
	struct nd_prefix *opr;
	struct sockaddr_in6 sa6, mask6;
	struct rtentry *rt = NULL;
d1158 7
a1164 2
	/* sanity check */
	if ((pr->ndpr_stateflags & NDPRF_ONLINK) == 0) {
d1166 3
a1168 3
		    "nd6_prefix_offlink: %s/%d is already off-link\n",
		    ip6_sprintf(&pr->ndpr_prefix.sin6_addr), pr->ndpr_plen));
		return (EEXIST);
d1170 3
d1174 14
a1187 54
	bzero(&sa6, sizeof(sa6));
	sa6.sin6_family = AF_INET6;
	sa6.sin6_len = sizeof(sa6);
	bcopy(&pr->ndpr_prefix.sin6_addr, &sa6.sin6_addr,
	    sizeof(struct in6_addr));
	bzero(&mask6, sizeof(mask6));
	mask6.sin6_family = AF_INET6;
	mask6.sin6_len = sizeof(sa6);
	bcopy(&pr->ndpr_mask, &mask6.sin6_addr, sizeof(struct in6_addr));
	error = rtrequest(RTM_DELETE, (struct sockaddr *)&sa6, NULL,
	    (struct sockaddr *)&mask6, 0, &rt);
	if (error == 0) {
		pr->ndpr_stateflags &= ~NDPRF_ONLINK;

		/* report the route deletion to the routing socket. */
		if (rt != NULL)
			nd6_rtmsg(RTM_DELETE, rt);

		/*
		 * There might be the same prefix on another interface,
		 * the prefix which could not be on-link just because we have
		 * the interface route (see comments in nd6_prefix_onlink).
		 * If there's one, try to make the prefix on-link on the
		 * interface.
		 */
		for (opr = nd_prefix.lh_first; opr; opr = opr->ndpr_next) {
			if (opr == pr)
				continue;

			if ((opr->ndpr_stateflags & NDPRF_ONLINK) != 0)
				continue;

			/*
			 * KAME specific: detached prefixes should not be
			 * on-link.
			 */
			if ((opr->ndpr_stateflags & NDPRF_DETACHED) != 0)
				continue;

			if (opr->ndpr_plen == pr->ndpr_plen &&
			    in6_are_prefix_equal(&pr->ndpr_prefix.sin6_addr,
			    &opr->ndpr_prefix.sin6_addr, pr->ndpr_plen)) {
				int e;

				if ((e = nd6_prefix_onlink(opr)) != 0) {
					nd6log((LOG_ERR,
					    "nd6_prefix_offlink: failed to "
					    "recover a prefix %s/%d from %s "
					    "to %s (errno = %d)\n",
					    ip6_sprintf(&opr->ndpr_prefix.sin6_addr),
					    opr->ndpr_plen, ifp->if_xname,
					    opr->ndpr_ifp->if_xname, e));
				}
			}
a1188 7
	} else {
		/* XXX: can we still set the NDPRF_ONLINK flag? */
		nd6log((LOG_ERR,
		    "nd6_prefix_offlink: failed to delete route: "
		    "%s/%d on %s (errno = %d)\n",
		    ip6_sprintf(&sa6.sin6_addr), pr->ndpr_plen, ifp->if_xname,
		    error));
d1191 12
a1202 6
	if (rt != NULL) {
		if (rt->rt_refcnt <= 0) {
			/* XXX: we should free the entry ourselves. */
			rt->rt_refcnt++;
			rtfree(rt);
		}
a1203 2

	return (error);
d1207 5
a1211 2
in6_ifadd(pr)
	struct nd_prefix *pr;
a1212 1
	struct ifnet *ifp = pr->ndpr_ifp;
d1214 2
a1215 3
	struct in6_aliasreq ifra;
	struct in6_ifaddr *ia, *ib;
	int error, plen0;
a1216 1
	int prefixlen = pr->ndpr_plen;
d1218 1
a1218 1
	in6_prefixlen2mask(&mask, prefixlen);
d1220 2
a1221 21
	/*
	 * find a link-local address (will be interface ID).
	 * Is it really mandatory? Theoretically, a global or a site-local
	 * address can be configured without a link-local address, if we
	 * have a unique interface identifier...
	 *
	 * it is not mandatory to have a link-local address, we can generate
	 * interface identifier on the fly.  we do this because:
	 * (1) it should be the easiest way to find interface identifier.
	 * (2) RFC2462 5.4 suggesting the use of the same interface identifier
	 * for multiple addresses on a single interface, and possible shortcut
	 * of DAD.  we omitted DAD for this reason in the past.
	 * (3) a user can prevent autoconfiguration of global address
	 * by removing link-local address by hand (this is partly because we
	 * don't have other way to control the use of IPv6 on a interface.
	 * this has been our design choice - cf. NRL's "ifconfig auto").
	 * (4) it is easier to manage when an interface has addresses
	 * with the same interface identifier, than to have multiple addresses
	 * with different interface identifiers.
	 */
	ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp, 0); /* 0 is OK? */
d1236 5
a1240 5
	plen0 = in6_mask2len(&ib->ia_prefixmask.sin6_addr, NULL);
	if (prefixlen != plen0) {
		nd6log((LOG_INFO, "in6_ifadd: wrong prefixlen for %s "
		    "(prefix=%d ifid=%d)\n",
		    ifp->if_xname, prefixlen, 128 - plen0));
d1245 5
d1251 34
a1284 8
	bzero(&ifra, sizeof(ifra));
	/*
	 * in6_update_ifa() does not use ifra_name, but we accurately set it
	 * for safety.
	 */
	strncpy(ifra.ifra_name, ifp->if_xname, sizeof(ifra.ifra_name));
	ifra.ifra_addr.sin6_family = AF_INET6;
	ifra.ifra_addr.sin6_len = sizeof(struct sockaddr_in6);
d1286 43
a1328 6
	bcopy(&pr->ndpr_prefix.sin6_addr, &ifra.ifra_addr.sin6_addr,
	    sizeof(ifra.ifra_addr.sin6_addr));
	ifra.ifra_addr.sin6_addr.s6_addr32[0] &= mask.s6_addr32[0];
	ifra.ifra_addr.sin6_addr.s6_addr32[1] &= mask.s6_addr32[1];
	ifra.ifra_addr.sin6_addr.s6_addr32[2] &= mask.s6_addr32[2];
	ifra.ifra_addr.sin6_addr.s6_addr32[3] &= mask.s6_addr32[3];
d1330 15
a1344 15
	/* interface ID */
	ifra.ifra_addr.sin6_addr.s6_addr32[0] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[0] & ~mask.s6_addr32[0]);
	ifra.ifra_addr.sin6_addr.s6_addr32[1] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[1] & ~mask.s6_addr32[1]);
	ifra.ifra_addr.sin6_addr.s6_addr32[2] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[2] & ~mask.s6_addr32[2]);
	ifra.ifra_addr.sin6_addr.s6_addr32[3] |=
	    (ib->ia_addr.sin6_addr.s6_addr32[3] & ~mask.s6_addr32[3]);

	/* new prefix mask. */
	ifra.ifra_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_prefixmask.sin6_family = AF_INET6;
	bcopy(&mask, &ifra.ifra_prefixmask.sin6_addr,
	    sizeof(ifra.ifra_prefixmask.sin6_addr));
d1347 1
a1347 3
	 * lifetime.
	 * XXX: in6_init_address_ltimes would override these values later.
	 * We should reconsider this logic.
d1349 20
a1368 2
	ifra.ifra_lifetime.ia6t_vltime = pr->ndpr_vltime;
	ifra.ifra_lifetime.ia6t_pltime = pr->ndpr_pltime;
d1370 2
a1371 1
	/* XXX: scope zone ID? */
d1373 3
a1375 1
	ifra.ifra_flags |= IN6_IFF_AUTOCONF; /* obey autoconf */
d1377 39
a1415 7
	/* allocate ifaddr structure, link into chain, etc. */
	if ((error = in6_update_ifa(ifp, &ifra, NULL)) != 0) {
		nd6log((LOG_ERR,
		    "in6_ifadd: failed to make ifaddr %s on %s (errno=%d)\n",
		    ip6_sprintf(&ifra.ifra_addr.sin6_addr), ifp->if_xname,
		    error));
		return (NULL);	/* ifaddr must not have been allocated. */
d1418 11
a1428 3
	ia = in6ifa_ifpwithaddr(ifp, &ifra.ifra_addr.sin6_addr);

	return (ia);		/* this is always non-NULL */
d1436 1
a1436 1
	/* check if preferred lifetime > valid lifetime.  RFC2462 5.5.3 (c) */
d1456 3
a1458 1
in6_init_address_ltimes(struct nd_prefix *new, struct in6_addrlifetime *lt6)
d1463 12
a1474 6
	/* init ia6t_expire */
	if (lt6->ia6t_vltime == ND6_INFINITE_LIFETIME)
		lt6->ia6t_expire = 0;
	else {
		lt6->ia6t_expire = time_second;
		lt6->ia6t_expire += lt6->ia6t_vltime;
d1484 4
d1501 1
a1501 1
	int s = splsoftnet();
d1525 1
a1525 1
		return (0);
d1528 1
a1528 9
		return (0);

	/*
	 * Do not delete a static route.
	 * XXX: this seems to be a bit ad-hoc. Should we consider the
	 * 'cloned' bit instead?
	 */
	if ((rt->rt_flags & RTF_STATIC) != 0)
		return (0);
d1535 1
a1535 1
		return (0);
d1537 2
a1538 2
	return (rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway,
	    rt_mask(rt), rt->rt_flags, 0));
d1549 1
a1549 1
		return (EINVAL);
d1553 1
a1553 1
		if (nd6_defifindex > 0) {
d1555 1
a1555 1
		} else
d1559 6
a1564 1
		 * Rescan default router list, refresh default route(s).
d1566 2
a1567 1
		defrouter_select();
d1570 1
a1570 1
	return (error);
@


1.4.2.8
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d134 4
d143 1
d229 4
d238 1
d443 3
a445 5
	if (rt->rt_ifp) {
		info.rti_info[RTAX_IFP] =
		    TAILQ_FIRST(&rt->rt_ifp->if_addrlist)->ifa_addr;
		info.rti_info[RTAX_IFA] = rt->rt_ifa->ifa_addr;
	}
@


1.4.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d115 1
a115 1
	if (ip6_accept_rtadv != 0 || !ip6_forwarding)
d242 1
d248 1
a248 1
	dr0.expire = time.tv_sec + dr0.rtlifetime;
d274 1
d333 1
a333 1
			pr.ndpr_lastupdate = time.tv_sec;
d418 1
a418 1
 * default router list processing sub routines
d1245 1
d1298 1
a1298 1
		else if (time.tv_sec - ifa6->ia6_updatetime >
d1307 1
a1307 1
				(time.tv_sec - ifa6->ia6_updatetime);
d1338 1
a1338 1
		ifa6->ia6_updatetime = time.tv_sec;
d1877 1
d1889 1
a1889 1
		ndpr->ndpr_preferred = time.tv_sec + ndpr->ndpr_pltime;
d1893 1
a1893 1
		ndpr->ndpr_expire = time.tv_sec + ndpr->ndpr_vltime;
d1901 1
d1908 1
a1908 1
		lt6->ia6t_expire = time.tv_sec;
d1916 1
a1916 1
		lt6->ia6t_preferred = time.tv_sec;
d1987 1
a1987 1
	if (ifindex < 0 || if_indexlim <= ifindex || !ifindex2ifnet[ifindex])
@


1.3
log
@Missing rndvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.2 1999/12/10 10:04:28 angelos Exp $	*/
d53 1
a53 1
#include <netinet6/ip6.h>
d56 1
a56 1
#include <netinet6/icmp6.h>
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_rtr.c,v 1.1 1999/12/08 06:50:23 itojun Exp $	*/
d43 1
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a40 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a41 1
#endif
a213 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a214 1
#endif
a398 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
d400 1
a400 1
#endif
a412 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
a413 4
#endif
#ifdef __NetBSD__
	rt = pool_get(&rtentry_pool, PR_NOWAIT);
#else
a414 1
#endif
a536 3
#ifdef __NetBSD__
	int s = splsoftnet();
#else
a537 1
#endif
a664 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
d666 1
a666 1
#endif
a683 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
d685 1
a685 1
#endif
a714 3
#ifdef __NetBSD__
	int s = splsoftnet();
#else
d716 1
a716 1
#endif
a1108 7
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	if ((ifa = ifp->if_addrlist) != NULL) {
		for ( ; ifa->ifa_next; ifa = ifa->ifa_next)
			continue;
		ifa->ifa_next = (struct ifaddr *)ia;
	}
#else
a1112 1
#endif
a1169 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1171 1
#endif
a1206 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	struct ifaddr *ifa;
#endif
a1241 13
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	if ((ifa = ifp->if_addrlist) == (struct ifaddr *)ia) {
		ifp->if_addrlist = ifa->ifa_next;
	} else {
		while (ifa->ifa_next &&
		      (ifa->ifa_next != (struct ifaddr *)ia))
			ifa = ifa->ifa_next;
		if (ifa->ifa_next)
			ifa->ifa_next = ((struct ifaddr *)ia)->ifa_next;
		else
			return -1;
	}
#else
a1242 1
#endif
a1256 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1257 1
#endif
a1272 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1273 1
#endif
a1298 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1299 1
#endif
a1339 3
#ifdef __NetBSD__
	int s = splsoftnet();
#else
a1340 1
#endif
@

