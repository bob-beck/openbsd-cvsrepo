head	1.172;
access;
symbols
	OPENBSD_6_0:1.163.0.2
	OPENBSD_6_0_BASE:1.163
	OPENBSD_5_9:1.157.0.2
	OPENBSD_5_9_BASE:1.157
	OPENBSD_5_8:1.156.0.4
	OPENBSD_5_8_BASE:1.156
	OPENBSD_5_7:1.155.0.2
	OPENBSD_5_7_BASE:1.155
	OPENBSD_5_6:1.148.0.4
	OPENBSD_5_6_BASE:1.148
	OPENBSD_5_5:1.141.0.4
	OPENBSD_5_5_BASE:1.141
	OPENBSD_5_4:1.136.0.2
	OPENBSD_5_4_BASE:1.136
	OPENBSD_5_3:1.127.0.2
	OPENBSD_5_3_BASE:1.127
	OPENBSD_5_2:1.125.0.2
	OPENBSD_5_2_BASE:1.125
	OPENBSD_5_1_BASE:1.120
	OPENBSD_5_1:1.120.0.2
	OPENBSD_5_0:1.116.0.2
	OPENBSD_5_0_BASE:1.116
	OPENBSD_4_9:1.107.0.2
	OPENBSD_4_9_BASE:1.107
	OPENBSD_4_8:1.105.0.2
	OPENBSD_4_8_BASE:1.105
	OPENBSD_4_7:1.101.0.2
	OPENBSD_4_7_BASE:1.101
	OPENBSD_4_6:1.100.0.4
	OPENBSD_4_6_BASE:1.100
	OPENBSD_4_5:1.95.0.2
	OPENBSD_4_5_BASE:1.95
	OPENBSD_4_4:1.92.0.4
	OPENBSD_4_4_BASE:1.92
	OPENBSD_4_3:1.92.0.2
	OPENBSD_4_3_BASE:1.92
	OPENBSD_4_2:1.91.0.2
	OPENBSD_4_2_BASE:1.91
	OPENBSD_4_1:1.90.0.2
	OPENBSD_4_1_BASE:1.90
	OPENBSD_4_0:1.88.0.2
	OPENBSD_4_0_BASE:1.88
	OPENBSD_3_9:1.86.0.2
	OPENBSD_3_9_BASE:1.86
	OPENBSD_3_8:1.83.0.2
	OPENBSD_3_8_BASE:1.83
	OPENBSD_3_7:1.82.0.2
	OPENBSD_3_7_BASE:1.82
	OPENBSD_3_6:1.81.0.2
	OPENBSD_3_6_BASE:1.81
	SMP_SYNC_A:1.78
	SMP_SYNC_B:1.77
	OPENBSD_3_5:1.76.0.2
	OPENBSD_3_5_BASE:1.76
	OPENBSD_3_4:1.65.0.2
	OPENBSD_3_4_BASE:1.65
	UBC_SYNC_A:1.63
	OPENBSD_3_3:1.62.0.2
	OPENBSD_3_3_BASE:1.62
	OPENBSD_3_2:1.59.0.2
	OPENBSD_3_2_BASE:1.59
	OPENBSD_3_1:1.48.0.2
	OPENBSD_3_1_BASE:1.48
	UBC_SYNC_B:1.59
	UBC:1.44.0.2
	UBC_BASE:1.44
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_9:1.35.0.2
	OPENBSD_2_8:1.32.0.2
	OPENBSD_2_8_BASE:1.32
	OPENBSD_2_7:1.29.0.2
	OPENBSD_2_7_BASE:1.29
	SMP:1.28.0.4
	SMP_BASE:1.28
	kame_19991208:1.28
	OPENBSD_2_6:1.28.0.2
	OPENBSD_2_6_BASE:1.28
	OPENBSD_2_5:1.27.0.4
	OPENBSD_2_5_BASE:1.27
	OPENBSD_2_4:1.27.0.2
	OPENBSD_2_4_BASE:1.27
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.11.0.4
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.172
date	2017.02.27.19.16.56;	author claudio;	state Exp;
branches;
next	1.171;
commitid	Ukq2QkllmG8rHpFv;

1.171
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.170;
commitid	CHRb0fCqa8XxUAMH;

1.170
date	2016.11.07.00.26.32;	author guenther;	state Exp;
branches;
next	1.169;
commitid	W7ztnDZwvjCaeQTS;

1.169
date	2016.10.07.19.04.44;	author tedu;	state Exp;
branches;
next	1.168;
commitid	P3wH4sYsZgUq37HY;

1.168
date	2016.10.02.23.11.55;	author guenther;	state Exp;
branches;
next	1.167;
commitid	F8mRaOmEFbuy0fNX;

1.167
date	2016.09.25.15.23.37;	author deraadt;	state Exp;
branches;
next	1.166;
commitid	YxqfPf79WCjoxCH9;

1.166
date	2016.09.21.14.06.50;	author deraadt;	state Exp;
branches;
next	1.165;
commitid	i8Lki9zW9tZfkC2H;

1.165
date	2016.09.07.17.30.12;	author natano;	state Exp;
branches;
next	1.164;
commitid	D0avTYSlvEmEjLyB;

1.164
date	2016.09.04.09.22.29;	author mpi;	state Exp;
branches;
next	1.163;
commitid	jBolvsPoQ0BaYiLs;

1.163
date	2016.05.27.19.45.04;	author deraadt;	state Exp;
branches;
next	1.162;
commitid	nQEqvpt7rKDi6fz0;

1.162
date	2016.05.23.15.48.57;	author deraadt;	state Exp;
branches;
next	1.161;
commitid	u827DKK0c0dFAF72;

1.161
date	2016.05.10.01.33.03;	author deraadt;	state Exp;
branches;
next	1.160;
commitid	p0mYeAL9rzJlot3A;

1.160
date	2016.04.25.20.18.31;	author tedu;	state Exp;
branches;
next	1.159;
commitid	AL2KSeDZVXs2nAYI;

1.159
date	2016.03.17.12.30.04;	author mpi;	state Exp;
branches;
next	1.158;
commitid	1jDS3BRFhs3JT4HF;

1.158
date	2016.02.29.19.44.07;	author naddy;	state Exp;
branches;
next	1.157;
commitid	Tzte6JKABMyG38MY;

1.157
date	2015.10.23.10.22.30;	author claudio;	state Exp;
branches;
next	1.156;
commitid	T6PH2wUDdHyRNguI;

1.156
date	2015.07.18.15.51.17;	author mpi;	state Exp;
branches;
next	1.155;
commitid	lwQKRpFyNEr7kjoF;

1.155
date	2015.02.11.05.09.33;	author claudio;	state Exp;
branches;
next	1.154;
commitid	shw0pmjYusXvnxct;

1.154
date	2015.01.13.10.07.58;	author mpf;	state Exp;
branches;
next	1.153;
commitid	IZ2rtJyRuzWF0F1j;

1.153
date	2014.12.12.07.45.46;	author tedu;	state Exp;
branches;
next	1.152;
commitid	tOiu53jgNjU0V5Os;

1.152
date	2014.12.05.04.12.48;	author uebayasi;	state Exp;
branches;
next	1.151;
commitid	lSMz5LkZVlVJKmFM;

1.151
date	2014.11.19.18.04.54;	author tedu;	state Exp;
branches;
next	1.150;
commitid	DhpzIJGhCsFp0uYg;

1.150
date	2014.10.17.01.51.39;	author tedu;	state Exp;
branches;
next	1.149;
commitid	r6zxCLSQFWXeVG73;

1.149
date	2014.08.20.06.23.03;	author mikeb;	state Exp;
branches;
next	1.148;
commitid	3nalvU8sn6rZiZ1d;

1.148
date	2014.07.13.16.41.22;	author claudio;	state Exp;
branches;
next	1.147;
commitid	04aN4E0CXyBXMp3X;

1.147
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.146;
commitid	EF98ch02VpFassUi;

1.146
date	2014.07.04.05.58.30;	author guenther;	state Exp;
branches;
next	1.145;
commitid	vhXZZxMGVTWiFaF3;

1.145
date	2014.05.15.03.52.25;	author guenther;	state Exp;
branches;
next	1.144;

1.144
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.143;

1.143
date	2014.03.26.05.23.41;	author guenther;	state Exp;
branches;
next	1.142;

1.142
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.141;

1.141
date	2014.02.12.05.47.36;	author guenther;	state Exp;
branches;
next	1.140;

1.140
date	2014.02.08.00.51.13;	author tedu;	state Exp;
branches;
next	1.139;

1.139
date	2013.10.22.16.40.26;	author guenther;	state Exp;
branches;
next	1.138;

1.138
date	2013.09.22.17.28.33;	author guenther;	state Exp;
branches;
next	1.137;

1.137
date	2013.08.13.05.52.27;	author guenther;	state Exp;
branches;
next	1.136;

1.136
date	2013.06.09.13.10.19;	author miod;	state Exp;
branches;
next	1.135;

1.135
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.134;

1.134
date	2013.04.15.16.47.14;	author guenther;	state Exp;
branches;
next	1.133;

1.133
date	2013.04.11.04.30.59;	author tedu;	state Exp;
branches;
next	1.132;

1.132
date	2013.04.06.03.44.34;	author tedu;	state Exp;
branches;
next	1.131;

1.131
date	2013.03.24.00.09.31;	author tedu;	state Exp;
branches;
next	1.130;

1.130
date	2013.03.23.21.22.20;	author tedu;	state Exp;
branches;
next	1.129;

1.129
date	2013.03.20.04.26.11;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2013.03.20.03.43.07;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2012.12.18.21.28.45;	author millert;	state Exp;
branches;
next	1.126;

1.126
date	2012.12.05.23.20.24;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2012.04.17.23.17.53;	author pirofti;	state Exp;
branches;
next	1.124;

1.124
date	2012.04.12.14.59.18;	author pirofti;	state Exp;
branches;
next	1.123;

1.123
date	2012.04.12.10.11.41;	author mikeb;	state Exp;
branches;
next	1.122;

1.122
date	2012.04.10.15.50.52;	author guenther;	state Exp;
branches;
next	1.121;

1.121
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.120;

1.120
date	2012.01.07.05.38.12;	author guenther;	state Exp;
branches;
next	1.119;

1.119
date	2011.12.14.07.32.16;	author guenther;	state Exp;
branches;
next	1.118;

1.118
date	2011.12.09.16.14.54;	author nicm;	state Exp;
branches;
next	1.117;

1.117
date	2011.08.30.01.09.29;	author guenther;	state Exp;
branches;
next	1.116;

1.116
date	2011.07.08.18.38.55;	author yasuoka;	state Exp;
branches;
next	1.115;

1.115
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.114;

1.114
date	2011.06.24.19.47.49;	author naddy;	state Exp;
branches;
next	1.113;

1.113
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.112;

1.112
date	2011.04.15.17.58.25;	author guenther;	state Exp;
branches;
next	1.111;

1.111
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.110;

1.110
date	2011.04.04.11.13.53;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2011.03.12.04.54.28;	author guenther;	state Exp;
branches;
next	1.108;

1.108
date	2011.03.07.07.07.13;	author guenther;	state Exp;
branches;
next	1.107;

1.107
date	2010.11.02.09.36.09;	author dlg;	state Exp;
branches;
next	1.106;

1.106
date	2010.08.19.18.14.13;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.104;

1.104
date	2010.06.29.00.28.14;	author tedu;	state Exp;
branches;
next	1.103;

1.103
date	2010.06.28.18.50.37;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2010.05.02.00.51.10;	author tedu;	state Exp;
branches;
next	1.101;

1.101
date	2010.01.10.03.37.50;	author guenther;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.15.17.59.44;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.98;

1.98
date	2009.06.07.03.07.19;	author millert;	state Exp;
branches;
next	1.97;

1.97
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.96;

1.96
date	2009.04.19.17.53.39;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2009.01.21.21.02.41;	author miod;	state Exp;
branches;
next	1.94;

1.94
date	2008.10.07.02.20.11;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2008.09.16.15.48.12;	author gollo;	state Exp;
branches;
next	1.92;

1.92
date	2008.02.09.15.10.58;	author kettenis;	state Exp;
branches;
next	1.91;

1.91
date	2007.04.12.22.14.15;	author tedu;	state Exp;
branches;
next	1.90;

1.90
date	2007.01.12.07.41.31;	author art;	state Exp;
branches;
next	1.89;

1.89
date	2006.12.12.23.14.28;	author dim;	state Exp;
branches;
next	1.88;

1.88
date	2006.05.08.22.51.18;	author gwk;	state Exp;
branches;
next	1.87;

1.87
date	2006.03.15.21.02.04;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2006.02.06.17.37.28;	author jmc;	state Exp;
branches;
next	1.85;

1.85
date	2005.12.13.00.35.23;	author millert;	state Exp;
branches;
next	1.84;

1.84
date	2005.10.26.17.22.00;	author mickey;	state Exp;
branches;
next	1.83;

1.83
date	2005.06.08.22.33.27;	author millert;	state Exp;
branches;
next	1.82;

1.82
date	2005.03.10.17.26.10;	author tedu;	state Exp;
branches;
next	1.81;

1.81
date	2004.08.04.23.33.32;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2004.07.28.17.15.12;	author tholo;	state Exp;
branches;
next	1.79;

1.79
date	2004.06.28.01.34.46;	author aaron;	state Exp;
branches;
next	1.78;

1.78
date	2004.06.11.01.32.05;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2004.04.19.22.52.33;	author tedu;	state Exp;
branches;
next	1.76;

1.76
date	2004.02.27.21.46.44;	author grange;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.27.21.15.45;	author grange;	state Exp;
branches;
next	1.74;

1.74
date	2004.02.24.21.43.56;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2004.02.15.11.14.45;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2004.02.14.15.09.22;	author grange;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.07.21.51.30;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.07.04.13.02;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.07.03.37.57;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.07.02.13.51;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2003.12.23.20.02.27;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2003.12.18.23.46.20;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2003.08.21.18.56.07;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2003.04.25.20.06.41;	author grange;	state Exp;
branches;
next	1.62;

1.62
date	2003.01.21.16.59.23;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2003.01.13.06.04.16;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2002.12.17.23.11.31;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2002.07.07.22.06.33;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2002.07.07.18.20.02;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.56;

1.56
date	2002.06.11.11.14.29;	author beck;	state Exp;
branches;
next	1.55;

1.55
date	2002.06.09.09.51.31;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2002.06.09.05.46.15;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2002.06.09.04.26.40;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.08.23.32.14;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.08.23.16.03;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.08.22.24.47;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2002.05.15.23.17.53;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2002.03.14.19.42.54;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.03.01.02.52.51;	author provos;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.23.08.07.59;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2001.09.28.01.42.54;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.18.03.32.16;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.24.16.00.45;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.22.21.32.59;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.03.04.37.58;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.03.03.52.12;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.14.07.11.35;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.11.06.36.59;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2001.03.16.08.49.08;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.01.31.09.59.50;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.03.19.20.59;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.17.22.00.01;	author pjanzen;	state Exp;
branches;
next	1.31;

1.31
date	2000.07.01.02.55.57;	author pjanzen;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.18.17.59.55;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.22.19.28.05;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	99.06.29.23.52.00;	author provos;	state Exp;
branches
	1.28.4.1;
next	1.27;

1.27
date	98.08.16.03.22.55;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	98.07.07.07.12.51;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.06.02.06.10.30;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.03.15.17.20.34;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.12.08.21.25.34;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.11.06.15.59.52;	author kstailey;	state Exp;
branches;
next	1.21;

1.21
date	97.11.06.05.59.11;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	97.10.06.20.21.11;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.10.06.15.25.35;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	97.09.08.17.28.18;	author kstailey;	state Exp;
branches;
next	1.17;

1.17
date	97.09.05.19.23.25;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.09.05.18.46.29;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.09.03.13.51.09;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.06.22.04.58.04;	author flipk;	state Exp;
branches;
next	1.13;

1.13
date	97.06.21.04.59.47;	author flipk;	state Exp;
branches;
next	1.12;

1.12
date	97.06.14.21.37.10;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.10.04.01.26.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.09.20.22.53.05;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.08.11.20.35.12;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.08.08.06.36.48;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.06.29.21.06.43;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.06.29.21.02.52;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.31.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.21.41.13;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.30.04.51.33;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.12.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.29;	author deraadt;	state Exp;
branches;
next	;

1.28.4.1
date	2000.03.02.07.04.47;	author niklas;	state Exp;
branches;
next	1.28.4.2;

1.28.4.2
date	2001.05.14.22.45.04;	author niklas;	state Exp;
branches;
next	1.28.4.3;

1.28.4.3
date	2001.07.04.11.00.34;	author niklas;	state Exp;
branches;
next	1.28.4.4;

1.28.4.4
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.28.4.5;

1.28.4.5
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.28.4.6;

1.28.4.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.28.4.7;

1.28.4.7
date	2002.03.28.14.52.02;	author niklas;	state Exp;
branches;
next	1.28.4.8;

1.28.4.8
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.28.4.9;

1.28.4.9
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.28.4.10;

1.28.4.10
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.28.4.11;

1.28.4.11
date	2004.02.19.11.01.34;	author niklas;	state Exp;
branches;
next	1.28.4.12;

1.28.4.12
date	2004.03.14.22.08.21;	author niklas;	state Exp;
branches;
next	1.28.4.13;

1.28.4.13
date	2004.06.05.17.19.55;	author niklas;	state Exp;
branches;
next	1.28.4.14;

1.28.4.14
date	2004.06.05.23.13.10;	author niklas;	state Exp;
branches;
next	1.28.4.15;

1.28.4.15
date	2004.06.06.23.23.13;	author deraadt;	state Exp;
branches;
next	;

1.44.2.1
date	2002.06.11.03.32.34;	author art;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.44.2.3;

1.44.2.3
date	2003.05.19.22.32.36;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.172
log
@Retire the AF_MPLS protosw struct. Nothing is using it and the code was super
basic anyway. Simplifies the code a lot also by calling the mpls sysctl no
longer via the protosw but instead directly.
OK mpi@@ on a previous diff. Also tested by renato@@ who actually found a bug
which is now fixed.
@
text
@/*	$OpenBSD: sysctl.h,v 1.171 2017/01/21 05:42:03 guenther Exp $	*/
/*	$NetBSD: sysctl.h,v 1.16 1996/04/09 20:55:36 cgd Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Mike Karels at Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sysctl.h	8.2 (Berkeley) 3/30/95
 */

#ifndef _SYS_SYSCTL_H_
#define	_SYS_SYSCTL_H_

#include <uvm/uvmexp.h>

/*
 * Definitions for sysctl call.  The sysctl call uses a hierarchical name
 * for objects that can be examined or modified.  The name is expressed as
 * a sequence of integers.  Like a file path name, the meaning of each
 * component depends on its place in the hierarchy.  The top-level and kern
 * identifiers are defined here, and other identifiers are defined in the
 * respective subsystem header files.
 */

#define	CTL_MAXNAME	12	/* largest number of components supported */

/*
 * Each subsystem defined by sysctl defines a list of variables
 * for that subsystem. Each name is either a node with further
 * levels defined below it, or it is a leaf of some particular
 * type given below. Each sysctl level defines a set of name/type
 * pairs to be used by sysctl(1) in manipulating the subsystem.
 */
struct ctlname {
	char	*ctl_name;	/* subsystem name */
	int	ctl_type;	/* type of name */
};
#define	CTLTYPE_NODE	1	/* name is a node */
#define	CTLTYPE_INT	2	/* name describes an integer */
#define	CTLTYPE_STRING	3	/* name describes a string */
#define	CTLTYPE_QUAD	4	/* name describes a 64-bit number */
#define	CTLTYPE_STRUCT	5	/* name describes a structure */

/*
 * Top-level identifiers
 */
#define	CTL_UNSPEC	0		/* unused */
#define	CTL_KERN	1		/* "high kernel": proc, limits */
#define	CTL_VM		2		/* virtual memory */
#define	CTL_FS		3		/* file system, mount type is next */
#define	CTL_NET		4		/* network, see socket.h */
#define	CTL_DEBUG	5		/* debugging parameters */
#define	CTL_HW		6		/* generic cpu/io */
#define	CTL_MACHDEP	7		/* machine dependent */
/*define gap		8		   was CTL_USER: removed 2013-04 */
#define	CTL_DDB		9		/* DDB user interface, see db_var.h */
#define	CTL_VFS		10		/* VFS sysctl's */
#define	CTL_MAXID	11		/* number of valid top-level ids */

#define	CTL_NAMES { \
	{ 0, 0 }, \
	{ "kern", CTLTYPE_NODE }, \
	{ "vm", CTLTYPE_NODE }, \
	{ "fs", CTLTYPE_NODE }, \
	{ "net", CTLTYPE_NODE }, \
	{ "debug", CTLTYPE_NODE }, \
	{ "hw", CTLTYPE_NODE }, \
	{ "machdep", CTLTYPE_NODE }, \
	{ "gap", 0 }, \
	{ "ddb", CTLTYPE_NODE }, \
	{ "vfs", CTLTYPE_NODE }, \
}

/*
 * CTL_KERN identifiers
 */
#define	KERN_OSTYPE	 	 1	/* string: system version */
#define	KERN_OSRELEASE	 	 2	/* string: system release */
#define	KERN_OSREV	 	 3	/* int: system revision */
#define	KERN_VERSION	 	 4	/* string: compile time info */
#define	KERN_MAXVNODES	 	 5	/* int: max vnodes */
#define	KERN_MAXPROC	 	 6	/* int: max processes */
#define	KERN_MAXFILES	 	 7	/* int: max open files */
#define	KERN_ARGMAX	 	 8	/* int: max arguments to exec */
#define	KERN_SECURELVL	 	 9	/* int: system security level */
#define	KERN_HOSTNAME		10	/* string: hostname */
#define	KERN_HOSTID		11	/* int: host identifier */
#define	KERN_CLOCKRATE		12	/* struct: struct clockinfo */
#define	KERN_DNSJACKPORT	13	/* hijack dns sockets */
/* was KERN_PROC		14	*/
/* was KERN_FILE		15	*/
#define	KERN_PROF		16	/* node: kernel profiling info */
#define	KERN_POSIX1		17	/* int: POSIX.1 version */
#define	KERN_NGROUPS		18	/* int: # of supplemental group ids */
#define	KERN_JOB_CONTROL	19	/* int: is job control available */
#define	KERN_SAVED_IDS		20	/* int: saved set-user/group-ID */
#define	KERN_BOOTTIME		21	/* struct: time kernel was booted */
#define	KERN_DOMAINNAME		22	/* string: (YP) domainname */
#define	KERN_MAXPARTITIONS	23	/* int: number of partitions/disk */
#define	KERN_RAWPARTITION	24	/* int: raw partition number */
#define	KERN_MAXTHREAD	 	25	/* int: max threads */
#define	KERN_NTHREADS		26	/* int: number of threads */
#define	KERN_OSVERSION		27	/* string: kernel build version */
#define	KERN_SOMAXCONN		28	/* int: listen queue maximum */
#define	KERN_SOMINCONN		29	/* int: half-open controllable param */
/* was KERN_USERMOUNT		30	*/
/* was KERN_RND	31			*/
#define	KERN_NOSUIDCOREDUMP	32	/* int: no setuid coredumps ever */ 
#define	KERN_FSYNC		33	/* int: file synchronization support */
#define	KERN_SYSVMSG		34	/* int: SysV message queue suppoprt */
#define	KERN_SYSVSEM		35	/* int: SysV semaphore support */
#define	KERN_SYSVSHM		36	/* int: SysV shared memory support */
/* was KERN_ARND		37	*/
#define	KERN_MSGBUFSIZE		38	/* int: size of message buffer */
#define KERN_MALLOCSTATS	39	/* node: malloc statistics */
#define KERN_CPTIME		40	/* array: cp_time */
#define KERN_NCHSTATS		41	/* struct: vfs cache statistics */
#define KERN_FORKSTAT		42	/* struct: fork statistics */
#define KERN_NSELCOLL		43	/* int: select(2) collisions */
#define KERN_TTY		44	/* node: tty information */
#define	KERN_CCPU		45	/* int: ccpu */
#define	KERN_FSCALE		46	/* int: fscale */
#define	KERN_NPROCS		47	/* int: number of processes */
#define	KERN_MSGBUF		48	/* message buffer, KERN_MSGBUFSIZE */
#define	KERN_POOL		49	/* struct: pool information */
#define	KERN_STACKGAPRANDOM	50	/* int: stackgap_random */
#define	KERN_SYSVIPC_INFO	51	/* struct: SysV sem/shm/msg info */
#define KERN_ALLOWKMEM		52	/* int: allowkmem */
/* was KERN_CRYPTODEVALLOWSOFT	53	*/
#define KERN_SPLASSERT		54	/* int: splassert */
#define KERN_PROC_ARGS		55	/* node: proc args and env */
#define	KERN_NFILES		56	/* int: number of open files */
#define	KERN_TTYCOUNT		57	/* int: number of tty devices */
#define KERN_NUMVNODES		58	/* int: number of vnodes in use */
#define	KERN_MBSTAT		59	/* struct: mbuf statistics */
/* was KERN_USERASYMCRYPTO	60	*/
#define	KERN_SEMINFO		61	/* struct: SysV struct seminfo */
#define	KERN_SHMINFO		62	/* struct: SysV struct shminfo */
#define KERN_INTRCNT		63	/* node: interrupt counters */
#define	KERN_WATCHDOG		64	/* node: watchdog */
/* was KERN_EMUL		65	*/
#define	KERN_PROC		66	/* struct: process entries */
#define	KERN_MAXCLUSTERS	67	/* number of mclusters */
#define KERN_EVCOUNT		68	/* node: event counters */
#define	KERN_TIMECOUNTER	69	/* node: timecounter */
#define	KERN_MAXLOCKSPERUID	70	/* int: locks per uid */
#define	KERN_CPTIME2		71	/* array: cp_time2 */
#define	KERN_CACHEPCT		72	/* buffer cache % of physmem */
#define	KERN_FILE		73	/* struct: file entries */
#define	KERN_WXABORT		74	/* int: w^x sigabrt & core */
#define	KERN_CONSDEV		75	/* dev_t: console terminal device */
#define	KERN_NETLIVELOCKS	76	/* int: number of network livelocks */
#define	KERN_POOL_DEBUG		77	/* int: enable pool_debug */
#define	KERN_PROC_CWD		78      /* node: proc cwd */
#define	KERN_PROC_NOBROADCASTKILL 79	/* node: proc no broadcast kill */
#define	KERN_PROC_VMMAP		80      /* node: proc vmmap */
#define	KERN_GLOBAL_PTRACE	81	/* allow ptrace globally */
#define	KERN_CONSBUFSIZE	82	/* int: console message buffer size */
#define	KERN_CONSBUF		83	/* console message buffer */
#define	KERN_MAXID		84	/* number of valid kern ids */

#define	CTL_KERN_NAMES { \
	{ 0, 0 }, \
	{ "ostype", CTLTYPE_STRING }, \
	{ "osrelease", CTLTYPE_STRING }, \
	{ "osrevision", CTLTYPE_INT }, \
	{ "version", CTLTYPE_STRING }, \
	{ "maxvnodes", CTLTYPE_INT }, \
	{ "maxproc", CTLTYPE_INT }, \
	{ "maxfiles", CTLTYPE_INT }, \
	{ "argmax", CTLTYPE_INT }, \
	{ "securelevel", CTLTYPE_INT }, \
	{ "hostname", CTLTYPE_STRING }, \
	{ "hostid", CTLTYPE_INT }, \
	{ "clockrate", CTLTYPE_STRUCT }, \
	{ "dnsjackport", CTLTYPE_INT }, \
	{ "gap", 0 }, \
	{ "gap", 0 }, \
	{ "profiling", CTLTYPE_NODE }, \
	{ "posix1version", CTLTYPE_INT }, \
	{ "ngroups", CTLTYPE_INT }, \
	{ "job_control", CTLTYPE_INT }, \
	{ "saved_ids", CTLTYPE_INT }, \
	{ "boottime", CTLTYPE_STRUCT }, \
	{ "domainname", CTLTYPE_STRING }, \
	{ "maxpartitions", CTLTYPE_INT }, \
	{ "rawpartition", CTLTYPE_INT }, \
	{ "maxthread", CTLTYPE_INT }, \
	{ "nthreads", CTLTYPE_INT }, \
	{ "osversion", CTLTYPE_STRING }, \
	{ "somaxconn", CTLTYPE_INT }, \
	{ "sominconn", CTLTYPE_INT }, \
	{ "gap", 0 }, \
	{ "gap", 0 }, \
	{ "nosuidcoredump", CTLTYPE_INT }, \
	{ "fsync", CTLTYPE_INT }, \
	{ "sysvmsg", CTLTYPE_INT }, \
	{ "sysvsem", CTLTYPE_INT }, \
	{ "sysvshm", CTLTYPE_INT }, \
	{ "gap", 0 }, \
	{ "msgbufsize", CTLTYPE_INT }, \
	{ "malloc", CTLTYPE_NODE }, \
	{ "cp_time", CTLTYPE_STRUCT }, \
	{ "nchstats", CTLTYPE_STRUCT }, \
	{ "forkstat", CTLTYPE_STRUCT }, \
	{ "nselcoll", CTLTYPE_INT }, \
	{ "tty", CTLTYPE_NODE }, \
	{ "ccpu", CTLTYPE_INT }, \
	{ "fscale", CTLTYPE_INT }, \
	{ "nprocs", CTLTYPE_INT }, \
	{ "msgbuf", CTLTYPE_STRUCT }, \
	{ "pool", CTLTYPE_NODE }, \
	{ "stackgap_random", CTLTYPE_INT }, \
	{ "sysvipc_info", CTLTYPE_INT }, \
	{ "allowkmem", CTLTYPE_INT }, \
	{ "gap", 0 }, \
	{ "splassert", CTLTYPE_INT }, \
	{ "procargs", CTLTYPE_NODE }, \
	{ "nfiles", CTLTYPE_INT }, \
	{ "ttycount", CTLTYPE_INT }, \
	{ "numvnodes", CTLTYPE_INT }, \
	{ "mbstat", CTLTYPE_STRUCT }, \
	{ "gap", 0 }, \
	{ "seminfo", CTLTYPE_STRUCT }, \
	{ "shminfo", CTLTYPE_STRUCT }, \
	{ "intrcnt", CTLTYPE_NODE }, \
 	{ "watchdog", CTLTYPE_NODE }, \
 	{ "gap", 0 }, \
 	{ "proc", CTLTYPE_STRUCT }, \
 	{ "maxclusters", CTLTYPE_INT }, \
	{ "evcount", CTLTYPE_NODE }, \
 	{ "timecounter", CTLTYPE_NODE }, \
 	{ "maxlocksperuid", CTLTYPE_INT }, \
 	{ "cp_time2", CTLTYPE_STRUCT }, \
	{ "bufcachepercent", CTLTYPE_INT }, \
	{ "file", CTLTYPE_STRUCT }, \
	{ "wxabort", CTLTYPE_INT }, \
	{ "consdev", CTLTYPE_STRUCT }, \
	{ "netlivelocks", CTLTYPE_INT }, \
	{ "pool_debug", CTLTYPE_INT }, \
	{ "proc_cwd", CTLTYPE_NODE }, \
	{ "proc_nobroadcastkill", CTLTYPE_NODE }, \
	{ "proc_vmmap", CTLTYPE_NODE }, \
	{ "global_ptrace", CTLTYPE_INT }, \
}

/*
 * KERN_PROC subtypes
 */
#define	KERN_PROC_ALL		0	/* everything but kernel threads */
#define	KERN_PROC_PID		1	/* by process id */
#define	KERN_PROC_PGRP		2	/* by process group id */
#define	KERN_PROC_SESSION	3	/* by session of pid */
#define	KERN_PROC_TTY		4	/* by controlling tty */
#define	KERN_PROC_UID		5	/* by effective uid */
#define	KERN_PROC_RUID		6	/* by real uid */
#define	KERN_PROC_KTHREAD	7	/* also return kernel threads */
#define	KERN_PROC_SHOW_THREADS	0x40000000/* also return normal threads */

/*
 * KERN_SYSVIPC_INFO subtypes
 */
#define KERN_SYSVIPC_MSG_INFO	1	/* msginfo and msqid_ds */
#define KERN_SYSVIPC_SEM_INFO	2	/* seminfo and semid_ds */
#define KERN_SYSVIPC_SHM_INFO	3	/* shminfo and shmid_ds */

/*
 * KERN_PROC_ARGS subtypes
 */
#define KERN_PROC_ARGV		1
#define KERN_PROC_NARGV		2
#define KERN_PROC_ENV		3
#define KERN_PROC_NENV		4

/*
 * KERN_PROC subtype ops return arrays of relatively fixed size
 * structures of process info.   Use 8 byte alignment, and new
 * elements should only be added to the end of this structure so
 * binary compatibility can be preserved.
 */
#define	KI_NGROUPS	16
#define	KI_MAXCOMLEN	24	/* extra for 8 byte alignment */
#define	KI_WMESGLEN	8
#define	KI_MAXLOGNAME	32
#define	KI_EMULNAMELEN	8

#define KI_NOCPU	(~(u_int64_t)0)

struct kinfo_proc {
	u_int64_t p_forw;		/* PTR: linked run/sleep queue. */
	u_int64_t p_back;
	u_int64_t p_paddr;		/* PTR: address of proc */

	u_int64_t p_addr;		/* PTR: Kernel virtual addr of u-area */
	u_int64_t p_fd;			/* PTR: Ptr to open files structure. */
	u_int64_t p_stats;		/* unused, always zero. */
	u_int64_t p_limit;		/* PTR: Process limits. */
	u_int64_t p_vmspace;		/* PTR: Address space. */
	u_int64_t p_sigacts;		/* PTR: Signal actions, state */
	u_int64_t p_sess;		/* PTR: session pointer */
	u_int64_t p_tsess;		/* PTR: tty session pointer */
	u_int64_t p_ru;			/* PTR: Exit information. XXX */

	int32_t	p_eflag;		/* LONG: extra kinfo_proc flags */
#define	EPROC_CTTY	0x01	/* controlling tty vnode active */
#define	EPROC_SLEADER	0x02	/* session leader */
	int32_t	p_exitsig;		/* unused, always zero. */
	int32_t	p_flag;			/* INT: P_* flags. */

	int32_t	p_pid;			/* PID_T: Process identifier. */
	int32_t	p_ppid;			/* PID_T: Parent process id */
	int32_t	p_sid;			/* PID_T: session id */
	int32_t	p__pgid;		/* PID_T: process group id */
					/* XXX: <sys/proc.h> hijacks p_pgid */
	int32_t	p_tpgid;		/* PID_T: tty process group id */

	u_int32_t p_uid;		/* UID_T: effective user id */
	u_int32_t p_ruid;		/* UID_T: real user id */
	u_int32_t p_gid;		/* GID_T: effective group id */
	u_int32_t p_rgid;		/* GID_T: real group id */

	u_int32_t p_groups[KI_NGROUPS];	/* GID_T: groups */
	int16_t	p_ngroups;		/* SHORT: number of groups */

	int16_t	p_jobc;			/* SHORT: job control counter */
	u_int32_t p_tdev;		/* DEV_T: controlling tty dev */

	u_int32_t p_estcpu;		/* U_INT: Time averaged value of p_cpticks. */
	u_int32_t p_rtime_sec;		/* STRUCT TIMEVAL: Real time. */
	u_int32_t p_rtime_usec;		/* STRUCT TIMEVAL: Real time. */
	int32_t	p_cpticks;		/* INT: Ticks of cpu time. */
	u_int32_t p_pctcpu;		/* FIXPT_T: %cpu for this process */
	u_int32_t p_swtime;		/* unused, always zero */
	u_int32_t p_slptime;		/* U_INT: Time since last blocked. */
	int32_t	p_schedflags;		/* INT: PSCHED_* flags */

	u_int64_t p_uticks;		/* U_QUAD_T: Statclock hits in user mode. */
	u_int64_t p_sticks;		/* U_QUAD_T: Statclock hits in system mode. */
	u_int64_t p_iticks;		/* U_QUAD_T: Statclock hits processing intr. */

	u_int64_t p_tracep;		/* PTR: Trace to vnode or file */
	int32_t	p_traceflag;		/* INT: Kernel trace points. */

	int32_t p_holdcnt;		/* INT: If non-zero, don't swap. */

	int32_t p_siglist;		/* INT: Signals arrived but not delivered. */
	u_int32_t p_sigmask;		/* SIGSET_T: Current signal mask. */
	u_int32_t p_sigignore;		/* SIGSET_T: Signals being ignored. */
	u_int32_t p_sigcatch;		/* SIGSET_T: Signals being caught by user. */

	int8_t	p_stat;			/* CHAR: S* process status (from LWP). */
	u_int8_t p_priority;		/* U_CHAR: Process priority. */
	u_int8_t p_usrpri;		/* U_CHAR: User-priority based on p_estcpu and ps_nice. */
	u_int8_t p_nice;		/* U_CHAR: Process "nice" value. */

	u_int16_t p_xstat;		/* U_SHORT: Exit status for wait; also stop signal. */
	u_int16_t p_acflag;		/* U_SHORT: Accounting flags. */

	char	p_comm[KI_MAXCOMLEN];

	char	p_wmesg[KI_WMESGLEN];	/* wchan message */
	u_int64_t p_wchan;		/* PTR: sleep address. */

	char	p_login[KI_MAXLOGNAME];	/* setlogin() name */

	int32_t	p_vm_rssize;		/* SEGSZ_T: current resident set size in pages */
	int32_t	p_vm_tsize;		/* SEGSZ_T: text size (pages) */
	int32_t	p_vm_dsize;		/* SEGSZ_T: data size (pages) */
	int32_t	p_vm_ssize;		/* SEGSZ_T: stack size (pages) */

	int64_t	p_uvalid;		/* CHAR: following p_u* members from struct user are valid */
					/* XXX 64 bits for alignment */
	u_int64_t p_ustart_sec;		/* STRUCT TIMEVAL: starting time. */
	u_int32_t p_ustart_usec;	/* STRUCT TIMEVAL: starting time. */

	u_int32_t p_uutime_sec;		/* STRUCT TIMEVAL: user time. */
	u_int32_t p_uutime_usec;	/* STRUCT TIMEVAL: user time. */
	u_int32_t p_ustime_sec;		/* STRUCT TIMEVAL: system time. */
	u_int32_t p_ustime_usec;	/* STRUCT TIMEVAL: system time. */

	u_int64_t p_uru_maxrss;		/* LONG: max resident set size. */
	u_int64_t p_uru_ixrss;		/* LONG: integral shared memory size. */
	u_int64_t p_uru_idrss;		/* LONG: integral unshared data ". */
	u_int64_t p_uru_isrss;		/* LONG: integral unshared stack ". */
	u_int64_t p_uru_minflt;		/* LONG: page reclaims. */
	u_int64_t p_uru_majflt;		/* LONG: page faults. */
	u_int64_t p_uru_nswap;		/* LONG: swaps. */
	u_int64_t p_uru_inblock;	/* LONG: block input operations. */
	u_int64_t p_uru_oublock;	/* LONG: block output operations. */
	u_int64_t p_uru_msgsnd;		/* LONG: messages sent. */
	u_int64_t p_uru_msgrcv;		/* LONG: messages received. */
	u_int64_t p_uru_nsignals;	/* LONG: signals received. */
	u_int64_t p_uru_nvcsw;		/* LONG: voluntary context switches. */
	u_int64_t p_uru_nivcsw;		/* LONG: involuntary ". */

	u_int32_t p_uctime_sec;		/* STRUCT TIMEVAL: child u+s time. */
	u_int32_t p_uctime_usec;	/* STRUCT TIMEVAL: child u+s time. */
	int32_t p_psflags;		/* INT: PS_* flags on the process. */
	int32_t p_spare;		/* INT: unused. */
	u_int32_t p_svuid;		/* UID_T: saved user id */
	u_int32_t p_svgid;		/* GID_T: saved group id */
	char    p_emul[KI_EMULNAMELEN];	/* syscall emulation name */
	u_int64_t p_rlim_rss_cur;	/* RLIM_T: soft limit for rss */
	u_int64_t p_cpuid;		/* LONG: CPU id */
	u_int64_t p_vm_map_size;	/* VSIZE_T: virtual size */
	int32_t   p_tid;		/* PID_T: Thread identifier. */
	u_int32_t p_rtableid;		/* U_INT: Routing table identifier. */
};

/*
 * VM address range entry, matching struct vm_map_entry.  Useful for
 * debuggers to know process's addresses.
 *
 * To iterate entries, set the last kve_end as the base address into
 * kve_start.
 */
struct kinfo_vmentry {
	u_long kve_start;		/* vaddr_t */
	u_long kve_end;			/* vaddr_t */
	u_long kve_guard;		/* vsize_t */
	u_long kve_fspace;		/* vsize_t */
	u_long kve_fspace_augment;	/* vsize_t */
	u_int64_t kve_offset;		/* voff_t */
	int kve_wired_count;
	int kve_etype;
	int kve_protection;
	int kve_max_protection;
	int kve_advice;
	int kve_inheritance;
	u_int8_t kve_flags;		/* u_int8_t */
};

#define KVE_ET_OBJ		0x00000001
#define KVE_ET_SUBMAP		0x00000002
#define KVE_ET_COPYONWRITE 	0x00000004
#define KVE_ET_NEEDSCOPY	0x00000008
#define KVE_ET_HOLE		0x00000010
#define KVE_ET_NOFAULT		0x00000020
#define KVE_ET_FREEMAPPED	0x00000080
#define KVE_PROT_NONE		0x00000000
#define KVE_PROT_READ		0x00000001
#define KVE_PROT_WRITE		0x00000002
#define KVE_PROT_EXEC		0x00000004
#define KVE_ADV_NORMAL		0x00000000
#define KVE_ADV_RANDOM		0x00000001
#define KVE_ADV_SEQUENTIAL	0x00000002
#define KVE_INH_SHARE		0x00000000
#define KVE_INH_COPY		0x00000010
#define KVE_INH_NONE		0x00000020
#define KVE_INH_ZERO		0x00000030
#define KVE_F_STATIC		0x01
#define KVE_F_KMEM		0x02

#if defined(_KERNEL) || defined(_LIBKVM)

/*
 * Macros for filling in the bulk of a kinfo_proc structure, used
 * in the kernel to implement the KERN_PROC sysctl and in userland
 * in libkvm to implement reading from kernel crashes.  The macro
 * arguments are all pointers; by name they are:
 *	kp - target kinfo_proc structure
 *	copy_str - a function or macro invoked as copy_str(dst,src,maxlen)
 *	    that has strlcpy or memcpy semantics; the destination is
 *	    pre-filled with zeros; for libkvm, src is a kvm address
 *	p - source struct proc
 *	pr - source struct process
 *	uc - source struct ucreds
 *	pg - source struct pgrp
 *	paddr - kernel address of the source struct proc
 *	praddr - kernel address of the source struct process
 *	sess - source struct session
 *	vm - source struct vmspace
 *	lim - source struct plimits
 *	sa - source struct sigacts
 * There are some members that are not handled by these macros
 * because they're too painful to generalize: p_ppid, p_sid, p_tdev,
 * p_tpgid, p_tsess, p_vm_rssize, p_u[us]time_{sec,usec}, p_cpuid
 */

#define PTRTOINT64(_x)	((u_int64_t)(u_long)(_x))

#define FILL_KPROC(kp, copy_str, p, pr, uc, pg, paddr, \
    praddr, sess, vm, lim, sa, isthread, show_addresses) \
do {									\
	memset((kp), 0, sizeof(*(kp)));					\
									\
	if (show_addresses) {						\
		(kp)->p_paddr = PTRTOINT64(paddr);			\
		(kp)->p_fd = PTRTOINT64((pr)->ps_fd);			\
		(kp)->p_limit = PTRTOINT64((pr)->ps_limit);		\
		(kp)->p_vmspace = PTRTOINT64((pr)->ps_vmspace);		\
		(kp)->p_sigacts = PTRTOINT64((pr)->ps_sigacts);		\
		(kp)->p_sess = PTRTOINT64((pg)->pg_session);		\
		(kp)->p_ru = PTRTOINT64((pr)->ps_ru);			\
	}								\
	(kp)->p_stats = 0;						\
	(kp)->p_exitsig = 0;						\
	(kp)->p_flag = (p)->p_flag;					\
	(kp)->p_pid = (pr)->ps_pid;					\
	(kp)->p_psflags = (pr)->ps_flags;				\
									\
	(kp)->p__pgid = (pg)->pg_id;					\
									\
	(kp)->p_uid = (uc)->cr_uid;					\
	(kp)->p_ruid = (uc)->cr_ruid;					\
	(kp)->p_gid = (uc)->cr_gid;					\
	(kp)->p_rgid = (uc)->cr_rgid;					\
	(kp)->p_svuid = (uc)->cr_svuid;					\
	(kp)->p_svgid = (uc)->cr_svgid;					\
									\
	memcpy((kp)->p_groups, (uc)->cr_groups,				\
	    MIN(sizeof((kp)->p_groups), sizeof((uc)->cr_groups)));	\
	(kp)->p_ngroups = (uc)->cr_ngroups;				\
									\
	(kp)->p_jobc = (pg)->pg_jobc;					\
									\
	(kp)->p_estcpu = (p)->p_estcpu;					\
	if (isthread) {							\
		(kp)->p_rtime_sec = (p)->p_tu.tu_runtime.tv_sec;	\
		(kp)->p_rtime_usec = (p)->p_tu.tu_runtime.tv_nsec/1000;	\
		(kp)->p_tid = (p)->p_tid + THREAD_PID_OFFSET;		\
		(kp)->p_uticks = (p)->p_tu.tu_uticks;			\
		(kp)->p_sticks = (p)->p_tu.tu_sticks;			\
		(kp)->p_iticks = (p)->p_tu.tu_iticks;			\
	} else {							\
		(kp)->p_rtime_sec = (pr)->ps_tu.tu_runtime.tv_sec;	\
		(kp)->p_rtime_usec = (pr)->ps_tu.tu_runtime.tv_nsec/1000; \
		(kp)->p_tid = -1;					\
		(kp)->p_uticks = (pr)->ps_tu.tu_uticks;			\
		(kp)->p_sticks = (pr)->ps_tu.tu_sticks;			\
		(kp)->p_iticks = (pr)->ps_tu.tu_iticks;			\
	}								\
	(kp)->p_cpticks = (p)->p_cpticks;				\
									\
	if (show_addresses)						\
		(kp)->p_tracep = PTRTOINT64((pr)->ps_tracevp);		\
	(kp)->p_traceflag = (pr)->ps_traceflag;				\
									\
	(kp)->p_siglist = (p)->p_siglist;				\
	(kp)->p_sigmask = (p)->p_sigmask;				\
	(kp)->p_sigignore = (sa) ? (sa)->ps_sigignore : 0;		\
	(kp)->p_sigcatch = (sa) ? (sa)->ps_sigcatch : 0;		\
									\
	(kp)->p_stat = (p)->p_stat;					\
	(kp)->p_nice = (pr)->ps_nice;					\
									\
	(kp)->p_xstat = (p)->p_xstat;					\
	(kp)->p_acflag = (pr)->ps_acflag;				\
									\
	/* XXX depends on e_name being an array and not a pointer */	\
	copy_str((kp)->p_emul, (char *)(pr)->ps_emul +			\
	    offsetof(struct emul, e_name), sizeof((kp)->p_emul));	\
	strlcpy((kp)->p_comm, (pr)->ps_comm, sizeof((kp)->p_comm));	\
	strlcpy((kp)->p_login, (sess)->s_login,			\
	    MIN(sizeof((kp)->p_login), sizeof((sess)->s_login)));	\
									\
	if ((sess)->s_ttyvp)						\
		(kp)->p_eflag |= EPROC_CTTY;				\
	if ((sess)->s_leader == (praddr))				\
		(kp)->p_eflag |= EPROC_SLEADER;				\
									\
	if (((pr)->ps_flags & (PS_EMBRYO | PS_ZOMBIE)) == 0) {		\
		if ((vm) != NULL) {					\
			(kp)->p_vm_rssize = (vm)->vm_rssize;		\
			(kp)->p_vm_tsize = (vm)->vm_tsize;		\
			(kp)->p_vm_dsize = (vm)->vm_dused;		\
			(kp)->p_vm_ssize = (vm)->vm_ssize;		\
		}							\
		(kp)->p_addr = PTRTOINT64((p)->p_addr);			\
		(kp)->p_stat = (p)->p_stat;				\
		(kp)->p_slptime = (p)->p_slptime;			\
		(kp)->p_holdcnt = 1;					\
		(kp)->p_priority = (p)->p_priority;			\
		(kp)->p_usrpri = (p)->p_usrpri;				\
		if ((p)->p_wchan && (p)->p_wmesg)			\
			copy_str((kp)->p_wmesg, (p)->p_wmesg,		\
			    sizeof((kp)->p_wmesg));			\
		if (show_addresses)					\
			(kp)->p_wchan = PTRTOINT64((p)->p_wchan);	\
	}								\
									\
	if (lim)							\
		(kp)->p_rlim_rss_cur =					\
		    (lim)->pl_rlimit[RLIMIT_RSS].rlim_cur;		\
									\
	if (((pr)->ps_flags & PS_ZOMBIE) == 0) {			\
		struct timeval tv;					\
									\
		(kp)->p_uvalid = 1;					\
									\
		(kp)->p_ustart_sec = (pr)->ps_start.tv_sec;		\
		(kp)->p_ustart_usec = (pr)->ps_start.tv_nsec/1000;	\
									\
		(kp)->p_uru_maxrss = (p)->p_ru.ru_maxrss;		\
		(kp)->p_uru_ixrss = (p)->p_ru.ru_ixrss;			\
		(kp)->p_uru_idrss = (p)->p_ru.ru_idrss;			\
		(kp)->p_uru_isrss = (p)->p_ru.ru_isrss;			\
		(kp)->p_uru_minflt = (p)->p_ru.ru_minflt;		\
		(kp)->p_uru_majflt = (p)->p_ru.ru_majflt;		\
		(kp)->p_uru_nswap = (p)->p_ru.ru_nswap;			\
		(kp)->p_uru_inblock = (p)->p_ru.ru_inblock;		\
		(kp)->p_uru_oublock = (p)->p_ru.ru_oublock;		\
		(kp)->p_uru_msgsnd = (p)->p_ru.ru_msgsnd;		\
		(kp)->p_uru_msgrcv = (p)->p_ru.ru_msgrcv;		\
		(kp)->p_uru_nsignals = (p)->p_ru.ru_nsignals;		\
		(kp)->p_uru_nvcsw = (p)->p_ru.ru_nvcsw;			\
		(kp)->p_uru_nivcsw = (p)->p_ru.ru_nivcsw;		\
									\
		timeradd(&(pr)->ps_cru.ru_utime,			\
			 &(pr)->ps_cru.ru_stime, &tv);			\
		(kp)->p_uctime_sec = tv.tv_sec;				\
		(kp)->p_uctime_usec = tv.tv_usec;			\
	}								\
									\
	(kp)->p_cpuid = KI_NOCPU;					\
	(kp)->p_rtableid = (pr)->ps_rtableid;				\
} while (0)

#endif /* defined(_KERNEL) || defined(_LIBKVM) */


/*
 * kern.file returns an array of these structures, which are designed
 * both to be immune to 32/64 bit emulation issues and to
 * provide backwards compatibility.  The order differs slightly from
 * that of the real struct file, and some fields are taken from other
 * structures (struct vnode, struct proc) in order to make the file
 * information more useful.
 */
#define	KERN_FILE_BYFILE	1
#define	KERN_FILE_BYPID		2
#define	KERN_FILE_BYUID		3
#define	KERN_FILESLOP		10

#define KERN_FILE_TEXT		-1
#define KERN_FILE_CDIR		-2
#define KERN_FILE_RDIR		-3
#define KERN_FILE_TRACE		-4

#define KI_MNAMELEN		96	/* rounded up from 90 */
#define KI_UNPPATHLEN		104

struct kinfo_file {
	uint64_t	f_fileaddr;	/* PTR: address of struct file */
	uint32_t	f_flag;		/* SHORT: flags (see fcntl.h) */
	uint32_t	f_iflags;	/* INT: internal flags */
	uint32_t	f_type;		/* INT: descriptor type */
	uint32_t	f_count;	/* UINT: reference count */
	uint32_t	f_msgcount;	/* UINT: references from msg queue */
	uint32_t	f_usecount;	/* INT: number active users */
	uint64_t	f_ucred;	/* PTR: creds for descriptor */
	uint32_t	f_uid;		/* UID_T: descriptor credentials */
	uint32_t	f_gid;		/* GID_T: descriptor credentials */
	uint64_t	f_ops;		/* PTR: address of fileops */
	uint64_t	f_offset;	/* OFF_T: offset */
	uint64_t	f_data;		/* PTR: descriptor data */
	uint64_t	f_rxfer;	/* UINT64: number of read xfers */
	uint64_t	f_rwfer;	/* UINT64: number of write xfers */
	uint64_t	f_seek;		/* UINT64: number of seek operations */
	uint64_t	f_rbytes;	/* UINT64: total bytes read */
	uint64_t	f_wbytes;	/* UINT64: total bytes written */

	/* information about the vnode associated with this file */
	uint64_t	v_un;		/* PTR: socket, specinfo, etc */
	uint32_t	v_type;		/* ENUM: vnode type */
	uint32_t	v_tag;		/* ENUM: type of underlying data */
	uint32_t	v_flag;		/* UINT: vnode flags */
	uint32_t	va_rdev;	/* DEV_T: raw device */
	uint64_t	v_data;		/* PTR: private data for fs */
	uint64_t	v_mount;	/* PTR: mount info for fs */
	uint64_t	va_fileid;	/* LONG: file id */
	uint64_t	va_size;	/* UINT64_T: file size in bytes */
	uint32_t	va_mode;	/* MODE_T: file access mode and type */
	uint32_t	va_fsid;	/* DEV_T: filesystem device */
	char		f_mntonname[KI_MNAMELEN];

	/* socket information */
	uint32_t	so_type;	/* SHORT: socket type */
	uint32_t	so_state;	/* SHORT: socket state */
	uint64_t	so_pcb;		/* PTR: socket pcb */
					/* for non-root: -1 if not NULL */
	uint32_t	so_protocol;	/* SHORT: socket protocol type */
	uint32_t	so_family;	/* INT: socket domain family */
	uint64_t	inp_ppcb;	/* PTR: pointer to per-protocol pcb */
	uint32_t	inp_lport;	/* SHORT: local inet port */
	uint32_t	inp_laddru[4];	/* STRUCT: local inet addr */
	uint32_t	inp_fport;	/* SHORT: foreign inet port */
	uint32_t	inp_faddru[4];	/* STRUCT: foreign inet addr */
	uint64_t	unp_conn;	/* PTR: connected socket cntrl block */

	/* pipe information */
	uint64_t	pipe_peer;	/* PTR: link with other direction */
	uint32_t	pipe_state;	/* UINT: pipe status info */

	/* kqueue information */
	uint32_t	kq_count;	/* INT: number of pending events */
	uint32_t	kq_state;	/* INT: kqueue status information */

	uint32_t	__unused1;	/* INT: unused */

	/* process information when retrieved via KERN_FILE_BY[PU]ID */
	uint32_t	p_pid;		/* PID_T: process id */
	int32_t		fd_fd;		/* INT: descriptor number */
	uint32_t	fd_ofileflags;	/* CHAR: open file flags */
	uint32_t	p_uid;		/* UID_T: process credentials */
	uint32_t	p_gid;		/* GID_T: process credentials */
	uint32_t	p_tid;		/* PID_T: thread id */
	char		p_comm[KI_MAXCOMLEN];

	/* more socket information */
	uint32_t	inp_rtableid;	/* UINT: Routing table identifier. */
	uint64_t	so_splice;	/* PTR: f_data of spliced socket */
	int64_t		so_splicelen;	/* OFF_T: already spliced count or */
					/* -1 if this is target of splice */
	uint64_t	so_rcv_cc;	/* LONG: chars in receive buf */
	uint64_t	so_snd_cc;	/* LONG: chars in send buf */
	uint64_t	unp_refs;	/* PTR: connected sockets */
	uint64_t	unp_nextref;	/* PTR: link to next connected socket */
	uint64_t	unp_addr;	/* PTR: address of the socket address */
	char		unp_path[KI_UNPPATHLEN];
	uint32_t	inp_proto;	/* CHAR: raw protocol id */
	uint32_t	t_state;	/* SHORT: tcp state */
	uint64_t	t_rcv_wnd;	/* ULONG: tcp receive window */
	uint64_t	t_snd_wnd;	/* ULONG: tcp send window */
	uint64_t	t_snd_cwnd;	/* ULONG: congestion-controlled win */

	uint32_t	va_nlink;	/* NLINK_T: number of references to file */
};

/*
 * KERN_INTRCNT
 */
#define KERN_INTRCNT_NUM	1	/* int: # intrcnt */
#define KERN_INTRCNT_CNT	2	/* node: intrcnt */
#define KERN_INTRCNT_NAME	3	/* node: names */
#define KERN_INTRCNT_VECTOR	4	/* node: interrupt vector # */
#define KERN_INTRCNT_MAXID	5

#define CTL_KERN_INTRCNT_NAMES { \
	{ 0, 0 }, \
	{ "nintrcnt", CTLTYPE_INT }, \
	{ "intrcnt", CTLTYPE_NODE }, \
	{ "intrname", CTLTYPE_NODE }, \
}

/*
 * KERN_WATCHDOG
 */
#define KERN_WATCHDOG_PERIOD	1	/* int: watchdog period */
#define KERN_WATCHDOG_AUTO	2	/* int: automatic tickle */
#define KERN_WATCHDOG_MAXID	3

#define CTL_KERN_WATCHDOG_NAMES { \
	{ 0, 0 }, \
	{ "period", CTLTYPE_INT }, \
	{ "auto", CTLTYPE_INT }, \
}

/*
 * KERN_TIMECOUNTER
 */
#define KERN_TIMECOUNTER_TICK		1	/* int: number of revolutions */
#define KERN_TIMECOUNTER_TIMESTEPWARNINGS 2	/* int: log a warning when time changes */
#define KERN_TIMECOUNTER_HARDWARE	3	/* string: tick hardware used */
#define KERN_TIMECOUNTER_CHOICE		4	/* string: tick hardware used */
#define KERN_TIMECOUNTER_MAXID		5

#define CTL_KERN_TIMECOUNTER_NAMES { \
	{ 0, 0 }, \
	{ "tick", CTLTYPE_INT }, \
	{ "timestepwarnings", CTLTYPE_INT }, \
	{ "hardware", CTLTYPE_STRING }, \
	{ "choice", CTLTYPE_STRING }, \
}

/*
 * CTL_FS identifiers
 */
#define	FS_POSIX	1		/* POSIX flags */
#define	FS_MAXID	2

#define	CTL_FS_NAMES { \
	{ 0, 0 }, \
	{ "posix", CTLTYPE_NODE }, \
}

/*
 * CTL_FS identifiers
 */
#define	FS_POSIX_SETUID	1		/* int: always clear SGID/SUID bit when owner change */
#define	FS_POSIX_MAXID	2

#define	CTL_FS_POSIX_NAMES { \
	{ 0, 0 }, \
	{ "setuid", CTLTYPE_INT }, \
}

/*
 * CTL_HW identifiers
 */
#define	HW_MACHINE		 1	/* string: machine class */
#define	HW_MODEL		 2	/* string: specific machine model */
#define	HW_NCPU			 3	/* int: number of cpus being used */
#define	HW_BYTEORDER		 4	/* int: machine byte order */
#define	HW_PHYSMEM		 5	/* int: total memory */
#define	HW_USERMEM		 6	/* int: non-kernel memory */
#define	HW_PAGESIZE		 7	/* int: software page size */
#define	HW_DISKNAMES		 8	/* strings: disk drive names */
#define	HW_DISKSTATS		 9	/* struct: diskstats[] */
#define	HW_DISKCOUNT		10	/* int: number of disks */
#define	HW_SENSORS		11	/* node: hardware monitors */
#define	HW_CPUSPEED		12	/* get CPU frequency */
#define	HW_SETPERF		13	/* set CPU performance % */
#define	HW_VENDOR		14	/* string: vendor name */
#define	HW_PRODUCT		15	/* string: product name */
#define	HW_VERSION		16	/* string: hardware version */
#define	HW_SERIALNO		17	/* string: hardware serial number */
#define	HW_UUID			18	/* string: universal unique id */
#define	HW_PHYSMEM64		19	/* quad: total memory */
#define	HW_USERMEM64		20	/* quad: non-kernel memory */
#define	HW_NCPUFOUND		21	/* int: number of cpus found*/
#define	HW_ALLOWPOWERDOWN	22	/* allow power button shutdown */
#define	HW_PERFPOLICY		23	/* set performance policy */
#define	HW_MAXID		24	/* number of valid hw ids */

#define	CTL_HW_NAMES { \
	{ 0, 0 }, \
	{ "machine", CTLTYPE_STRING }, \
	{ "model", CTLTYPE_STRING }, \
	{ "ncpu", CTLTYPE_INT }, \
	{ "byteorder", CTLTYPE_INT }, \
	{ "gap", 0 }, \
	{ "gap", 0 }, \
	{ "pagesize", CTLTYPE_INT }, \
	{ "disknames", CTLTYPE_STRING }, \
	{ "diskstats", CTLTYPE_STRUCT }, \
	{ "diskcount", CTLTYPE_INT }, \
	{ "sensors", CTLTYPE_NODE}, \
	{ "cpuspeed", CTLTYPE_INT }, \
	{ "setperf", CTLTYPE_INT }, \
	{ "vendor", CTLTYPE_STRING }, \
	{ "product", CTLTYPE_STRING }, \
	{ "version", CTLTYPE_STRING }, \
	{ "serialno", CTLTYPE_STRING }, \
	{ "uuid", CTLTYPE_STRING }, \
	{ "physmem", CTLTYPE_QUAD }, \
	{ "usermem", CTLTYPE_QUAD }, \
	{ "ncpufound", CTLTYPE_INT }, \
	{ "allowpowerdown", CTLTYPE_INT }, \
	{ "perfpolicy", CTLTYPE_STRING }, \
}

/*
 * CTL_DEBUG definitions
 *
 * Second level identifier specifies which debug variable.
 * Third level identifier specifies which structure component.
 */
#define	CTL_DEBUG_NAME		0	/* string: variable name */
#define	CTL_DEBUG_VALUE		1	/* int: variable value */
#define	CTL_DEBUG_MAXID		20

#ifdef	_KERNEL
#ifdef	DEBUG
/*
 * CTL_DEBUG variables.
 *
 * These are declared as separate variables so that they can be
 * individually initialized at the location of their associated
 * variable. The loader prevents multiple use by issuing errors
 * if a variable is initialized in more than one place. They are
 * aggregated into an array in debug_sysctl(), so that it can
 * conveniently locate them when querried. If more debugging
 * variables are added, they must also be declared here and also
 * entered into the array.
 */
struct ctldebug {
	char	*debugname;	/* name of debugging variable */
	int	*debugvar;	/* pointer to debugging variable */
};
extern struct ctldebug debug0, debug1, debug2, debug3, debug4;
extern struct ctldebug debug5, debug6, debug7, debug8, debug9;
extern struct ctldebug debug10, debug11, debug12, debug13, debug14;
extern struct ctldebug debug15, debug16, debug17, debug18, debug19;
#endif	/* DEBUG */

/*
 * Internal sysctl function calling convention:
 *
 *	(*sysctlfn)(name, namelen, oldval, oldlenp, newval, newlen);
 *
 * The name parameter points at the next component of the name to be
 * interpreted.  The namelen parameter is the number of integers in
 * the name.
 */
typedef int (sysctlfn)(int *, u_int, void *, size_t *, void *, size_t, struct proc *);

int sysctl_int(void *, size_t *, void *, size_t, int *);
int sysctl_int_lower(void *, size_t *, void *, size_t, int *);
int sysctl_rdint(void *, size_t *, void *, int);
int sysctl_int_arr(int **, int *, u_int, void *, size_t *, void *, size_t);
int sysctl_quad(void *, size_t *, void *, size_t, int64_t *);
int sysctl_rdquad(void *, size_t *, void *, int64_t);
int sysctl_string(void *, size_t *, void *, size_t, char *, int);
int sysctl_tstring(void *, size_t *, void *, size_t, char *, int);
int sysctl__string(void *, size_t *, void *, size_t, char *, int, int);
int sysctl_rdstring(void *, size_t *, void *, const char *);
int sysctl_rdstruct(void *, size_t *, void *, const void *, int);
int sysctl_struct(void *, size_t *, void *, size_t, void *, int);
int sysctl_file(int *, u_int, char *, size_t *, struct proc *);
int sysctl_doproc(int *, u_int, char *, size_t *);
struct rtentry;
struct walkarg;
int sysctl_dumpentry(struct rtentry *, void *, unsigned int);
int sysctl_rtable(int *, u_int, void *, size_t *, void *, size_t);
int sysctl_clockrate(char *, size_t *, void *);
int sysctl_vnode(char *, size_t *, struct proc *);
#if defined(GPROF) || defined(DDBPROF)
int sysctl_doprof(int *, u_int, void *, size_t *, void *, size_t);
#endif
int sysctl_dopool(int *, u_int, char *, size_t *);

int kern_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		     struct proc *);
int hw_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *);
#ifdef DEBUG
int debug_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		      struct proc *);
#endif
int vm_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *);
int fs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *);
int fs_posix_sysctl(int *, u_int, void *, size_t *, void *, size_t,
			 struct proc *);
int net_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int cpu_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int vfs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int sysctl_sysvipc(int *, u_int, void *, size_t *);
int sysctl_wdog(int *, u_int, void *, size_t *, void *, size_t);

extern int (*cpu_cpuspeed)(int *);
extern void (*cpu_setperf)(int);

int bpf_sysctl(int *, u_int, void *, size_t *, void *, size_t);
int pflow_sysctl(int *, u_int, void *, size_t *, void *, size_t);
int pipex_sysctl(int *, u_int, void *, size_t *, void *, size_t);
int mpls_sysctl(int *, u_int, void *, size_t *, void *, size_t);

#else	/* !_KERNEL */

__BEGIN_DECLS
int	sysctl(const int *, u_int, void *, size_t *, void *, size_t);
__END_DECLS
#endif	/* _KERNEL */
#endif	/* !_SYS_SYSCTL_H_ */
@


1.171
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.170 2016/11/07 00:26:32 guenther Exp $	*/
d979 1
@


1.170
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.169 2016/10/07 19:04:44 tedu Exp $	*/
d580 1
a580 1
	strlcpy((kp)->p_comm, (p)->p_comm, sizeof((kp)->p_comm));	\
@


1.169
log
@introduce a sysctl to hijack dns sockets. when set to a port number,
all dns socket connections will be redirected to localhost:port.
this could be a sockopt on the listening socket, but sysctl is
an easier interface to work with right now.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.168 2016/10/02 23:11:55 guenther Exp $	*/
d497 1
d503 1
a503 1
 * because they're too painful to generalize: p_pid, p_ppid, p_sid, p_tdev,
d526 1
d548 1
a548 1
		(kp)->p_tid = (p)->p_pid + THREAD_PID_OFFSET;		\
@


1.168
log
@Add va_nlink information to struct kinfo_file (so bump the shlib minor)

from Sebastien Marie
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.167 2016/09/25 15:23:37 deraadt Exp $	*/
d116 1
a116 1
/* was KERN_VNODE		13	*/
d203 1
a203 1
	{ "gap", 0 }, \
@


1.167
log
@Make a move towards ending 4 decades of kernel snooping.

Add sysctl kern.allowkmem (default 0) which controls the ability to open
/dev/mem or /dev/kmem at securelevel > 0.  Over 15 years we converted 99%
of utilities in the tree to operate on sysctl-nodes (either by themselves
or via code hiding in the guts of -lkvm).

pstat -d and -v & procmap are affected and continued use of them will
require kern.allowkmem=1 in /etc/sysctl.conf.  acpidump (and it's
buddy sendbug) are affected, but we'll work out a solution soon.

There will be some impact in ports.

ok kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.166 2016/09/21 14:06:50 deraadt Exp $	*/
d751 2
@


1.166
log
@sysctl KERN_ARND is no longer used (in ports, it only occurs in fallback
paths of libevent).  This interface was the first generation of what
eventually became getentropy(2) and arc4random(3) -- june 1997!
Ports scan by sthen, general agreement guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.165 2016/09/07 17:30:12 natano Exp $	*/
d140 1
a140 1
/* was	KERN_ARND		37	*/
d155 1
a155 1
/* was KERN_USERCRYPTO		52	*/
d227 1
a227 1
	{ "arandom", CTLTYPE_INT }, \
d242 1
a242 1
	{ "gap", 0 }, \
@


1.165
log
@Remove usermount remnants. ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.164 2016/09/04 09:22:29 mpi Exp $	*/
d140 1
a140 1
#define	KERN_ARND		37	/* int: random integer from arc4rnd */
d221 1
a221 1
	{ "random", CTLTYPE_STRUCT }, \
@


1.164
log
@Introduce Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

Currently only available on amd64 and guarded under DDBPROF.  Support
for other archs will follow soon.

A new sysctl knob, ddb.console, need to be set to 1 in securelevel 0
to be able to use this feature.

Inputs and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.163 2016/05/27 19:45:04 deraadt Exp $	*/
d133 1
a133 1
#define	KERN_USERMOUNT		30	/* int: users may mount filesystems */
d220 1
a220 1
	{ "usermount", CTLTYPE_INT }, \
@


1.163
log
@W^X violations are no longer permitted by default.  A kernel log message
is generated, and mprotect/mmap return ENOTSUP.  If the sysctl(8) flag
kern.wxabort is set then a SIGABRT occurs instead, for gdb use or coredump
creation.

W^X violating programs can be permitted on a ffs/nfs filesystem-basis,
using the "wxallowed" mount option.  One day far in the future
upstream software developers will understand that W^X violations are a
tremendously risky practice and that style of programming will be
banished outright.  Until then, we recommend most users need to use the
wxallowed option on their /usr/local filesystem.  At least your other
filesystems don't permit such programs.

ok jca kettenis mlarkin natano
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.162 2016/05/23 15:48:57 deraadt Exp $	*/
d941 1
a941 1
#ifdef GPROF
@


1.162
log
@remove the sysctl kern.random counters, since none of the remaining
ones are capable of giving valuable works vs does-not-work evidence.
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.161 2016/05/10 01:33:03 deraadt Exp $	*/
d177 1
a177 1
/* was KERN_RTHREADS	74	*/
d264 1
a264 1
	{ "gap", 0 }, \
@


1.161
log
@rename an unused field in struct kinfo_file (it related to systrace..)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.160 2016/04/25 20:18:31 tedu Exp $	*/
d134 1
a134 1
#define	KERN_RND		31	/* struct: rnd(4) statistics */
d155 1
a155 1
/* was KERN_USERCRYPTO	52	*/
@


1.160
log
@remove systrace remnants
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.159 2016/03/17 12:30:04 mpi Exp $	*/
d724 1
a724 1
	uint32_t	str_npolicies;	/* INT: DEAD number systrace policies */
@


1.159
log
@Fix a comment about ``p_usrpri'', from Michal Mazurek.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.158 2016/02/29 19:44:07 naddy Exp $	*/
d724 1
a724 2
	/* systrace information */
	uint32_t	str_npolicies;	/* INT: number systrace policies */
@


1.158
log
@delete the kern.emul/KERN_EMUL sysctl bits since there are no
emulations left; ok millert@@ deraadt@@, jmc@@ (man pages)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.157 2015/10/23 10:22:30 claudio Exp $	*/
d380 1
a380 1
	u_int8_t p_usrpri;		/* U_CHAR: User-priority based on p_cpu and ps_nice. */
@


1.157
log
@Introduce a new sysctl NET_RT_IFNAMES that returns only ifnames to ifindex
mappings. This will be used by if_nameindex(3), if_nametoindex(3) and
if_indextoname(3) soon to fix the issues in pledge because of inet6 link
local addressing.
OK mpi@@ benno@@ deraadt@@
The libc version will follow soon so better start updating your kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.156 2015/07/18 15:51:17 mpi Exp $	*/
d168 1
a168 1
#define	KERN_EMUL		65	/* node: emuls */
d255 1
a255 1
 	{ "emul", CTLTYPE_NODE }, \
a272 9

/*
 * KERN_EMUL subtypes.
 */
#define	KERN_EMUL_NUM		0
/* Fourth level sysctl names */
#define KERN_EMUL_NAME		0
#define KERN_EMUL_ENABLED	1

@


1.156
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.155 2015/02/11 05:09:33 claudio Exp $	*/
a947 1
int sysctl_iflist(int, struct walkarg *);
@


1.155
log
@Extend struct kinfo_file a bit so that netstat has all the info it needs.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.154 2015/01/13 10:07:58 mpf Exp $	*/
d945 1
a945 1
struct radix_node;
d947 1
a947 1
int sysctl_dumpentry(struct radix_node *, void *, u_int);
@


1.154
log
@Add dmesg -s support, to view the output of rc(8) system startup messages.
Help and feedback by Theo and Miod.
OK deraadt@@, manpage-ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.153 2014/12/12 07:45:46 tedu Exp $	*/
d756 5
@


1.153
log
@sysctl kern.global_ptrace.
controls whether you can ptrace any process with appropriate privileges
or only one own's children.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.152 2014/12/05 04:12:48 uebayasi Exp $	*/
d185 3
a187 1
#define	KERN_MAXID		82	/* number of valid kern ids */
@


1.152
log
@Introduce a new sysctl to retrieve VM map entries

This adds a new sysctl KERN_PROC_VMMAP, which returns an array of VM map
entries of a specified process.  This prevents debuggers from iterating
vm_map_entry RB tree via kvm(3).

The name KERN_PROC_VMMAP and struct kinfo_vmentry are chosen from the same
function in FreeBSD.  struct kinfo_vmentry is revised to reduce size, because
OpenBSD does not keep track of filepaths.  The semantic is also changed to
return max buffer size as a hint, and start iteration at the specified base
address.

Much valuable input from deraadt@@, guenther@@, tedu@@

OK tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d184 2
a185 1
#define	KERN_MAXID		81	/* number of valid kern ids */
d269 1
@


1.151
log
@delete the KERN_VNODE sysctl. it fails to provide any isolation from the
kernel struct vnode defintion, and the only consumer (pstat) still needs
kvm to read much of the required information. no great loss to always use
kvm until there's a better replacement interface.
ok deraadt millert uebayasi
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.150 2014/10/17 01:51:39 tedu Exp $	*/
d183 2
a184 1
#define	KERN_MAXID		80	/* number of valid kern ids */
d267 1
d441 44
@


1.150
log
@redo the performance throttling in the kernel.
introduce a new sysctl, hw.perfpolicy, that governs the policy.
when set to anything other than manual, hw.setperf then becomes read only.
phessler was heading in this direction, but this is slightly different. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.149 2014/08/20 06:23:03 mikeb Exp $	*/
d116 3
a118 3
#define	KERN_VNODE		13	/* struct: vnode structures */
/*define gap: was KERN_PROC	14	*/
/*define gap: was KERN_FILE	15	*/
d155 2
a156 2
/* was define KERN_USERCRYPTO	52	*/
/* was define KERN_CRYPTODEVALLOWSOFT	53	*/
d163 1
a163 1
/* was define KERN_USERASYMCRYPTO	60	*/
d177 1
a177 1
/* was define KERN_RTHREADS	74	*/
d199 1
a199 1
	{ "vnode", CTLTYPE_STRUCT }, \
@


1.149
log
@Bye bye /dev/crypto

The interface has been disabled by default for about 4 years and
currently there's not much value in having it around at all.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.148 2014/07/13 16:41:22 claudio Exp $	*/
d801 2
a802 1
#define	HW_MAXID		23	/* number of valid hw ids */
d828 1
@


1.148
log
@Introduce PS_NOBROADCASTKILL a process flag that excludes processes from
receiving broadcast signals (kill -1). The flag can be set via a new
sysctl KERN_PROC_NOBROADCASTKILL. This will be used by iscsid to survive
the mass killing by init(8) when terminating multi-user operations.
With and OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.147 2014/07/08 17:19:26 deraadt Exp $	*/
d155 2
a156 2
#define KERN_USERCRYPTO		52	/* int: usercrypto */
#define KERN_CRYPTODEVALLOWSOFT	53	/* int: cryptodevallowsoft */
d163 1
a163 1
#define KERN_USERASYMCRYPTO	60	/* int: usercrypto */
d238 2
a239 2
	{ "usercrypto", CTLTYPE_INT }, \
	{ "cryptodevallowsoft", CTLTYPE_INT }, \
d246 1
a246 1
	{ "userasymcrypto", CTLTYPE_INT }, \
@


1.147
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.146 2014/07/04 05:58:30 guenther Exp $	*/
d182 2
a183 1
#define	KERN_MAXID		79	/* number of valid kern ids */
d265 1
@


1.146
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.145 2014/05/15 03:52:25 guenther Exp $	*/
d41 1
a41 1
#include <uvm/uvm_extern.h>
@


1.145
log
@Move from struct proc to process the reference-count-holding pointers
to the process's vmspace and filedescs.  struct proc continues to
keep copies of the pointers, copying them on fork, clearing them
on exit, and (for vmspace) refreshing on exec.
Also, make uvm_swapout_threads() thread aware, eliminating p_swtime
in kernel.

particular testing by ajacoutot@@ and sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.144 2014/03/30 21:54:48 guenther Exp $	*/
a515 1
	(kp)->p_pctcpu = (p)->p_pctcpu;					\
d544 1
a544 1
	if ((p)->p_stat != SIDL && !P_ZOMBIE(p)) {			\
d568 1
a568 1
	if (!P_ZOMBIE(p)) {						\
@


1.144
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.143 2014/03/26 05:23:41 guenther Exp $	*/
d360 2
a361 2
	u_int32_t p_pctcpu;		/* FIXPT_T: %cpu for this process during p_swtime */
	u_int32_t p_swtime;		/* U_INT: Time swapped in or out. */
d472 1
a472 1
		(kp)->p_fd = PTRTOINT64((p)->p_fd);			\
d474 1
a474 1
		(kp)->p_vmspace = PTRTOINT64((p)->p_vmspace);		\
a553 1
		(kp)->p_swtime = (p)->p_swtime;				\
@


1.143
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.142 2014/03/22 06:05:45 guenther Exp $	*/
a450 1
 *	pc - source struct pcreds
d465 1
a465 1
#define FILL_KPROC(kp, copy_str, p, pr, pc, uc, pg, paddr, \
d487 1
a487 1
	(kp)->p_ruid = (pc)->p_ruid;					\
d489 3
a491 3
	(kp)->p_rgid = (pc)->p_rgid;					\
	(kp)->p_svuid = (pc)->p_svuid;					\
	(kp)->p_svgid = (pc)->p_svgid;					\
@


1.142
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.141 2014/02/12 05:47:36 guenther Exp $	*/
d535 1
a535 1
	copy_str((kp)->p_emul, (char *)(p)->p_emul +			\
@


1.141
log
@Eliminate the exit sig handling, which was only invokable via the
Linux-compat clone() syscall when *not* using CLONE_THREAD.  pirofti@@
confirms Opera runs in compat without this, so out it goes; one less hair
to choke on in kern_exit.c

ok tedu@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.140 2014/02/08 00:51:13 tedu Exp $	*/
d476 1
a476 1
		(kp)->p_sigacts = PTRTOINT64((p)->p_sigacts);		\
@


1.140
log
@only copy wmesg if wchan, after chatting with guenther and millert.
(and no need to copy empty string, it's already been zero filled.)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.139 2013/10/22 16:40:26 guenther Exp $	*/
d335 1
a335 1
	int32_t	p_exitsig;		/* INT: signal to sent to parent on exit */
d481 1
a481 1
	(kp)->p_exitsig = (p)->p_exitsig;				\
@


1.139
log
@- add UNIX-domain socket info to struct kinfo_file2
- convert netstat from kvm_getfiles() to kvm_getfile2() using that
- delete kvm_getfiles() and KERN_FILE as no longer used (bump libkvm's major)
- rename kvm_getfile2() to kvm_getfiles(), kinfo_file2 to kinfo_file
  and KERN_FILE2 to KERN_FILE.

ok deraadt@@, millert@@
ports scan sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.138 2013/09/22 17:28:33 guenther Exp $	*/
d560 1
a560 1
		if ((p)->p_wmesg)					\
a561 3
			    sizeof((kp)->p_wmesg));			\
		else							\
			copy_str((kp)->p_wmesg, "",			\
@


1.138
log
@Stop merging the per-thread and per-process flags when reporting
them via sysctl(KERN_PROC).  In struct kinfo_proc the per-process
flags move to p_psflags, leaving the per-thread flags in p_flags.
Flag descriptions in ps(1) updated to be less obtuse.

discussed with matthew@@ some time ago; ok jca@@, manpage bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.137 2013/08/13 05:52:27 guenther Exp $	*/
d118 1
a118 1
#define	KERN_FILE		15	/* struct: file entries */
d176 1
a176 1
#define	KERN_FILE2		73	/* struct: file entries */
d200 1
a200 1
	{ "file", CTLTYPE_STRUCT }, \
d258 1
a258 1
	{ "file2", CTLTYPE_STRUCT }, \
d611 1
a611 1
 * kern.file2 returns an array of these structures, which are designed
d629 1
d631 1
a631 1
struct kinfo_file2 {
d669 1
d704 6
d890 1
a890 2
int sysctl_file(char *, size_t *, struct proc *);
int sysctl_file2(int *, u_int, char *, size_t *, struct proc *);
@


1.137
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.136 2013/06/09 13:10:19 miod Exp $	*/
d426 2
a427 1
	u_int64_t p_realflag;		/* INT: P_* flags (not including LWPs). */
d482 2
a483 1
	(kp)->p_flag = (p)->p_flag | (pr)->ps_flags | P_INMEM;		\
@


1.136
log
@Constify the mib argument of sysctl().
ok matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.135 2013/06/03 16:55:22 guenther Exp $	*/
d401 1
a401 1
	u_int32_t p_ustart_sec;		/* STRUCT TIMEVAL: starting time. */
@


1.135
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.134 2013/04/15 16:47:14 guenther Exp $	*/
d928 1
a928 1
int	sysctl(int *, u_int, void *, size_t *, void *, size_t);
@


1.134
log
@Remove CTL_USER hierarchy from sysctl()
(Use sysconf() or confstr() instead)

ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.133 2013/04/11 04:30:59 tedu Exp $	*/
d501 1
a501 1
		(kp)->p_rtime_usec = (p)->p_tu.tu_runtime.tv_usec;	\
d508 1
a508 1
		(kp)->p_rtime_usec = (pr)->ps_tu.tu_runtime.tv_usec;	\
d578 1
a578 1
		(kp)->p_ustart_usec = (pr)->ps_start.tv_usec;		\
@


1.133
log
@copy out a blank string if no wmesg, so userland can rely on reading
p_wmesg[0] and not find junk leftover from before
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.132 2013/04/06 03:44:34 tedu Exp $	*/
d82 1
a82 1
#define	CTL_USER	8		/* user-level */
d96 1
a96 1
	{ "user", CTLTYPE_NODE }, \
a820 49
}

/*
 * CTL_USER definitions
 */
#define	USER_CS_PATH		 1	/* string: _CS_PATH */
#define	USER_BC_BASE_MAX	 2	/* int: BC_BASE_MAX */
#define	USER_BC_DIM_MAX		 3	/* int: BC_DIM_MAX */
#define	USER_BC_SCALE_MAX	 4	/* int: BC_SCALE_MAX */
#define	USER_BC_STRING_MAX	 5	/* int: BC_STRING_MAX */
#define	USER_COLL_WEIGHTS_MAX	 6	/* int: COLL_WEIGHTS_MAX */
#define	USER_EXPR_NEST_MAX	 7	/* int: EXPR_NEST_MAX */
#define	USER_LINE_MAX		 8	/* int: LINE_MAX */
#define	USER_RE_DUP_MAX		 9	/* int: RE_DUP_MAX */
#define	USER_POSIX2_VERSION	10	/* int: POSIX2_VERSION */
#define	USER_POSIX2_C_BIND	11	/* int: POSIX2_C_BIND */
#define	USER_POSIX2_C_DEV	12	/* int: POSIX2_C_DEV */
#define	USER_POSIX2_CHAR_TERM	13	/* int: POSIX2_CHAR_TERM */
#define	USER_POSIX2_FORT_DEV	14	/* int: POSIX2_FORT_DEV */
#define	USER_POSIX2_FORT_RUN	15	/* int: POSIX2_FORT_RUN */
#define	USER_POSIX2_LOCALEDEF	16	/* int: POSIX2_LOCALEDEF */
#define	USER_POSIX2_SW_DEV	17	/* int: POSIX2_SW_DEV */
#define	USER_POSIX2_UPE		18	/* int: POSIX2_UPE */
#define	USER_STREAM_MAX		19	/* int: POSIX2_STREAM_MAX */
#define	USER_TZNAME_MAX		20	/* int: POSIX2_TZNAME_MAX */
#define	USER_MAXID		21	/* number of valid user ids */

#define	CTL_USER_NAMES { \
	{ 0, 0 }, \
	{ "cs_path", CTLTYPE_STRING }, \
	{ "bc_base_max", CTLTYPE_INT }, \
	{ "bc_dim_max", CTLTYPE_INT }, \
	{ "bc_scale_max", CTLTYPE_INT }, \
	{ "bc_string_max", CTLTYPE_INT }, \
	{ "coll_weights_max", CTLTYPE_INT }, \
	{ "expr_nest_max", CTLTYPE_INT }, \
	{ "line_max", CTLTYPE_INT }, \
	{ "re_dup_max", CTLTYPE_INT }, \
	{ "posix2_version", CTLTYPE_INT }, \
	{ "posix2_c_bind", CTLTYPE_INT }, \
	{ "posix2_c_dev", CTLTYPE_INT }, \
	{ "posix2_char_term", CTLTYPE_INT }, \
	{ "posix2_fort_dev", CTLTYPE_INT }, \
	{ "posix2_fort_run", CTLTYPE_INT }, \
	{ "posix2_localedef", CTLTYPE_INT }, \
	{ "posix2_sw_dev", CTLTYPE_INT }, \
	{ "posix2_upe", CTLTYPE_INT }, \
	{ "stream_max", CTLTYPE_INT }, \
	{ "tzname_max", CTLTYPE_INT }, \
@


1.132
log
@rthreads are always enabled. remove the sysctl.
ok deraadt guenther kettenis matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.131 2013/03/24 00:09:31 tedu Exp $	*/
d560 3
@


1.131
log
@pstats is already 0, but the bonus = 0 belongs outside the pointer section
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.130 2013/03/23 21:22:20 tedu Exp $	*/
d177 1
a177 1
#define	KERN_RTHREADS		74	/* kernel rthreads support enabled */
d259 1
a259 1
	{ "rthreads", CTLTYPE_INT }, \
@


1.130
log
@pull the suser check for sysctl pointers up higher, out of the loops.
hide a few more pointery things.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.129 2013/03/20 04:26:11 deraadt Exp $	*/
a472 1
		(kp)->p_stats = 0;					\
d479 1
@


1.129
log
@p_sigacts can also be zero'd; spotted by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.128 2013/03/20 03:43:07 deraadt Exp $	*/
d470 1
a470 1
	if (show_addresses)						\
d472 4
a475 5
	(kp)->p_fd = PTRTOINT64((p)->p_fd);				\
	(kp)->p_stats = 0;						\
	(kp)->p_limit = PTRTOINT64((pr)->ps_limit);			\
	(kp)->p_vmspace = PTRTOINT64((p)->p_vmspace);			\
	if (show_addresses)						\
a476 1
	if (show_addresses)						\
a477 1
	if (show_addresses)						\
d479 1
a479 1
									\
a939 5

void fill_file2(struct kinfo_file2 *, struct file *, struct filedesc *,
    int, struct vnode *, struct proc *, struct proc *);

void fill_kproc(struct proc *, struct kinfo_proc *, int);
@


1.128
log
@When non-root asks sysctl for kinfo proc or file requests, do not fill in
any kernel addresses information.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.127 2012/12/18 21:28:45 millert Exp $	*/
d470 1
a470 1
	if (show_addresses)							\
d476 3
a478 2
	(kp)->p_sigacts = PTRTOINT64((p)->p_sigacts);			\
	if (show_addresses)							\
d480 1
a480 1
	if (show_addresses)							\
d520 1
a520 1
	if (show_addresses)							\
d533 1
a533 1
	(kp)->p_acflag = (pr)->ps_acflag;					\
d564 1
a564 1
		if (show_addresses)						\
@


1.127
log
@We no longer use struct eproc for kinfo_proc in sysctl.h so there
is no direct need for sys/proc.h or sys/resource.h.  Some consumers
of kinfo_proc need these for the proc flags and rlimit defines like
RLIM_INF so add the appropriate includes to them.
OK deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.126 2012/12/05 23:20:24 deraadt Exp $	*/
d465 2
a466 1
#define FILL_KPROC(kp, copy_str, p, pr, pc, uc, pg, paddr, praddr, sess, vm, lim, sa, isthread) \
d470 2
a471 1
	(kp)->p_paddr = PTRTOINT64(paddr);				\
d477 4
a480 2
	(kp)->p_sess = PTRTOINT64((pg)->pg_session);			\
	(kp)->p_ru = PTRTOINT64((pr)->ps_ru);				\
d519 2
a520 1
	(kp)->p_tracep = PTRTOINT64((pr)->ps_tracevp);			\
d563 2
a564 1
		(kp)->p_wchan = PTRTOINT64((p)->p_wchan);		\
@


1.126
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.125 2012/04/17 23:17:53 pirofti Exp $	*/
a39 5

#ifndef _KERNEL
#include <sys/proc.h>		/* for SRUN, SIDL, etc */
#include <sys/resource.h>	/* for struct loadavg */
#endif
@


1.125
log
@Make it optional for kvm_getprocs() (and related sysctl) to return
thread information.

Add a KERN_PROC_SHOW_THREADS flag that has to be set in order to get the
thread info and make it off by default. This creates backwards compatibility
for applications that relied on a given size/number of items to be returned.

Modify ps(1) and top(1) accordingly.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.124 2012/04/12 14:59:18 pirofti Exp $	*/
a977 1
#include <sys/cdefs.h>
@


1.124
log
@Add per thread accounting, mainly for usage & friends.

This expands the already bloated FILL_KPROC macro to take an extra
parameter that indicates if the callee is a thread or a process.

The userland bits are adjusted accordingly and ps(1) and top(1) now
display per thread usage times when -H is used.

Also pkill(1) had to be adjusted so that duplicates don't pop up.

libkvm does basically the same thing as the kernel bits.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.123 2012/04/12 10:11:41 mikeb Exp $	*/
d291 1
@


1.123
log
@move accounting flags to struct process; idea and ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.122 2012/04/10 15:50:52 guenther Exp $	*/
d469 1
a469 1
#define FILL_KPROC(kp, copy_str, p, pr, pc, uc, pg, paddr, praddr, sess, vm, lim, sa) \
d501 15
a515 2
	(kp)->p_rtime_sec = (pr)->ps_tu.tu_runtime.tv_sec;		\
	(kp)->p_rtime_usec = (pr)->ps_tu.tu_runtime.tv_usec;		\
a518 4
	(kp)->p_uticks = (p)->p_uticks;					\
	(kp)->p_sticks = (p)->p_sticks;					\
	(kp)->p_iticks = (p)->p_iticks;					\
									\
a598 1
	(kp)->p_tid = (p)->p_pid + THREAD_PID_OFFSET;			\
d944 1
a944 1
void fill_kproc(struct proc *, struct kinfo_proc *);
@


1.122
log
@Make the KERN_NPROCS and KERN_MAXPROC sysctl()s and the RLIMIT_NPROC rlimit
count processes instead of threads.  New sysctl()s KERN_NTHREADS and
KERN_MAXTHREAD count and limit threads.  The nprocs and maxproc kernel
variables are replaced by nprocess, maxprocess, nthreads, and maxthread.

ok tedu@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.121 2012/03/23 15:51:26 guenther Exp $	*/
d522 1
a522 1
	(kp)->p_acflag = (p)->p_acflag;					\
@


1.121
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.120 2012/01/07 05:38:12 guenther Exp $	*/
d133 2
a134 2
/*define gap			25	*/
/*define gap			26	*/
d215 2
a216 2
	{ "gap", 0 }, \
	{ "gap", 0 }, \
@


1.120
log
@Add rtable id and thread id to struct kinfo_proc (and fix process id)
and add an 'rtableid' keyword to ps.

Add rtable id, thread id, and socket splice info to struct kinfo_file2
and make fstat display socket splice information.

Remove old KVM_PROC2 and kinfo_proc2 interfaces; bump libkvm major

Socket splice info and corrections from bluhm@@  "Lovely" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.119 2011/12/14 07:32:16 guenther Exp $	*/
d328 1
a328 1
	u_int64_t p_stats;		/* PTR: Accounting/statistics */
a460 1
 *	ps - source struct pstats
d469 1
a469 1
#define FILL_KPROC(kp, copy_str, p, pr, pc, uc, pg, paddr, praddr, sess, vm, lim, ps, sa) \
d475 1
a475 1
	(kp)->p_stats = PTRTOINT64((p)->p_stats);			\
d480 1
a480 1
	(kp)->p_ru = PTRTOINT64((p)->p_ru);				\
d501 2
a502 2
	(kp)->p_rtime_sec = (p)->p_rtime.tv_sec;			\
	(kp)->p_rtime_usec = (p)->p_rtime.tv_usec;			\
d560 1
a560 1
	if (!P_ZOMBIE(p) && (ps) != NULL) {				\
d565 2
a566 2
		(kp)->p_ustart_sec = (ps)->p_start.tv_sec;		\
		(kp)->p_ustart_usec = (ps)->p_start.tv_usec;		\
d568 14
a581 14
		(kp)->p_uru_maxrss = (ps)->p_ru.ru_maxrss;		\
		(kp)->p_uru_ixrss = (ps)->p_ru.ru_ixrss;		\
		(kp)->p_uru_idrss = (ps)->p_ru.ru_idrss;		\
		(kp)->p_uru_isrss = (ps)->p_ru.ru_isrss;		\
		(kp)->p_uru_minflt = (ps)->p_ru.ru_minflt;		\
		(kp)->p_uru_majflt = (ps)->p_ru.ru_majflt;		\
		(kp)->p_uru_nswap = (ps)->p_ru.ru_nswap;		\
		(kp)->p_uru_inblock = (ps)->p_ru.ru_inblock;		\
		(kp)->p_uru_oublock = (ps)->p_ru.ru_oublock;		\
		(kp)->p_uru_msgsnd = (ps)->p_ru.ru_msgsnd;		\
		(kp)->p_uru_msgrcv = (ps)->p_ru.ru_msgrcv;		\
		(kp)->p_uru_nsignals = (ps)->p_ru.ru_nsignals;		\
		(kp)->p_uru_nvcsw = (ps)->p_ru.ru_nvcsw;		\
		(kp)->p_uru_nivcsw = (ps)->p_ru.ru_nivcsw;		\
d583 2
a584 2
		timeradd(&(ps)->p_cru.ru_utime,				\
			 &(ps)->p_cru.ru_stime, &tv);			\
@


1.119
log
@Handle rthreads consistently in ktrace by moving the flags and vnode into
struct process; KTRFAC_ACTIVE becomes P_INKTR.  Also, save the credentials
used to open the file in sys_ktrace() and use them for all writes to the
vnode.

much feedback and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.118 2011/12/09 16:14:54 nicm Exp $	*/
a40 3
/*
 * These are for the eproc structure defined below.
 */
d43 1
a43 1
#include <sys/resource.h>
a45 2
#include <sys/resourcevar.h>	/* XXX */

a174 1
#define	KERN_PROC2		KERN_PROC	/* backwards compat name */
a321 3
#ifndef kinfo_proc2
#define kinfo_proc2	kinfo_proc
#endif
d437 2
d464 1
a464 1
 * because they're too painful to generalize: p_ppid, p_sid, p_tdev,
a485 1
	(kp)->p_pid = (p)->p_pid;					\
d591 2
d682 1
a682 1
	uint32_t	__spare;	/* padding */
d684 6
@


1.118
log
@Add new KERN_PROC_CWD sysctl to get the current working directory of a process.

ok guenther deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.117 2011/08/30 01:09:29 guenther Exp $	*/
d519 2
a520 2
	(kp)->p_tracep = PTRTOINT64((p)->p_tracep);			\
	(kp)->p_traceflag = (p)->p_traceflag;				\
@


1.117
log
@Make ps -N/-M work again by correcting kernel vs user address
handling in the FILL_KPROC() macro.

Problems pointed out by Martin Pelikan (martin.pelikan at gmail.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.116 2011/07/08 18:38:55 yasuoka Exp $	*/
d192 2
a193 1
#define	KERN_MAXID		78	/* number of valid kern ids */
d274 1
@


1.116
log
@this must be included my previous commit.

Include PIPEX in kernel by default.  And add new sysctl variable
`net.pipex.enable' to enable PIPEX.   By default, pipex is disabled
and it will not process packets from wire.  Update man pages and
update HOWTO_PIPEX_NPPPD.txt for testers.

discussed with dlg@@, ok deraadt@@ mcbride@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.115 2011/07/05 04:48:02 guenther Exp $	*/
d456 1
a456 1
 *	    pre-filled with zeros
d485 1
a485 1
	(kp)->p_sess = PTRTOINT64((pr)->ps_session);			\
d531 1
a531 1
	/* XXX depends on p_emul being an array and not a pointer */	\
d534 3
a536 3
	copy_str((kp)->p_comm, (p)->p_comm, sizeof((kp)->p_comm));	\
	copy_str((kp)->p_login, (sess)->s_login,			\
	    MIN(sizeof((kp)->p_login) - 1, sizeof((sess)->s_login)));	\
@


1.115
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.114 2011/06/24 19:47:49 naddy Exp $	*/
d965 1
@


1.114
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.113 2011/04/18 21:44:56 guenther Exp $	*/
d467 1
d475 1
a475 1
#define FILL_KPROC(kp, copy_str, p, pr, pc, uc, pg, paddr, praddr, sess, vm, lim, ps) \
d522 2
a523 2
	(kp)->p_sigignore = (p)->p_sigignore;				\
	(kp)->p_sigcatch = (p)->p_sigcatch;				\
@


1.113
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.110 2011/04/04 11:13:53 deraadt Exp $	*/
d760 23
a782 22
#define	HW_MACHINE	 1		/* string: machine class */
#define	HW_MODEL	 2		/* string: specific machine model */
#define	HW_NCPU		 3		/* int: number of cpus being used */
#define	HW_BYTEORDER	 4		/* int: machine byte order */
#define	HW_PHYSMEM	 5		/* int: total memory */
#define	HW_USERMEM	 6		/* int: non-kernel memory */
#define	HW_PAGESIZE	 7		/* int: software page size */
#define	HW_DISKNAMES	 8		/* strings: disk drive names */
#define	HW_DISKSTATS	 9		/* struct: diskstats[] */
#define	HW_DISKCOUNT	10		/* int: number of disks */
#define	HW_SENSORS	11		/* node: hardware monitors */
#define	HW_CPUSPEED	12		/* get CPU frequency */
#define	HW_SETPERF	13		/* set CPU performance % */
#define	HW_VENDOR	14		/* string: vendor name */
#define	HW_PRODUCT	15		/* string: product name */
#define	HW_VERSION	16		/* string: hardware version */
#define	HW_SERIALNO	17		/* string: hardware serial number */
#define	HW_UUID		18		/* string: universal unique id */
#define	HW_PHYSMEM64	19		/* quad: total memory */
#define	HW_USERMEM64	20		/* quad: non-kernel memory */
#define	HW_NCPUFOUND	21		/* int: number of cpus found*/
#define	HW_MAXID	22		/* number of valid hw ids */
d807 1
@


1.112
log
@p_sigacts is NULL for zombies, so FILL_KPROC() and  kvm_proclist() have
to handle that with the sigacts change.

problem observed and diagnosed by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.111 2011/04/15 04:52:40 guenther Exp $	*/
a466 1
 *	sa - source struct sigacts
d474 1
a474 1
#define FILL_KPROC(kp, copy_str, p, pr, pc, uc, pg, paddr, praddr, sess, vm, lim, ps, sa) \
d521 2
a522 2
	(kp)->p_sigignore = (sa) ? (sa)->ps_sigignore : 0;		\
	(kp)->p_sigcatch = (sa) ? (sa)->ps_sigcatch : 0;		\
@


1.111
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.110 2011/04/04 11:13:53 deraadt Exp $	*/
d522 2
a523 2
	(kp)->p_sigignore = (sa)->ps_sigignore;				\
	(kp)->p_sigcatch = (sa)->ps_sigcatch;				\
@


1.110
log
@sysctl kern.pool_debug=0 will disable POOL_DEBUG on the fly (still defaults
to on, if POOL_DEBUG is compiled in, so that boot-time pool corruption
can be found.  When the sysctl is turned off, performance is almost as
as good as compiling with POOL_DEBUG compiled out.  Not all pool page
headers can be purged of the magic checks.
performance tests by henning
ok ariane kettenis mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.109 2011/03/12 04:54:28 guenther Exp $	*/
d467 1
d475 1
a475 1
#define FILL_KPROC(kp, copy_str, p, pr, pc, uc, pg, paddr, praddr, sess, vm, lim, ps) \
d522 2
a523 2
	(kp)->p_sigignore = (p)->p_sigignore;				\
	(kp)->p_sigcatch = (p)->p_sigcatch;				\
@


1.109
log
@Replace the old, broken KERN_PROC ABI and its matching functions
in libkvm with the stable-ABI versions that are currently named
KERN_PROC2, kvm_get{proc,argv,envv}2().  The latter names and symbols
will continue to be supported for a few releases.

Committing now that they ports people have had a couple releases
to update pkgs that usd the old functions
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.108 2011/03/07 07:07:13 guenther Exp $	*/
d191 2
a192 1
#define	KERN_MAXID		77	/* number of valid kern ids */
d272 1
@


1.108
log
@The scheduling 'nice' value is per-process, not per-thread, so move it
into struct process.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.107 2010/11/02 09:36:09 dlg Exp $	*/
d45 1
a45 3
#include <sys/time.h>
#include <sys/ucred.h>
#include <sys/proc.h>
d127 1
a127 3
#if defined(_KERNEL) || defined(_LIBKVM)
#define	KERN_PROC		14	/* struct: process entries */
#endif
d179 2
a180 1
#define	KERN_PROC2		66	/* struct: process entries */
d208 1
a208 1
	{ "proc", CTLTYPE_STRUCT }, \
d260 1
a260 1
 	{ "proc2", CTLTYPE_STRUCT }, \
d310 1
a310 37
 * KERN_PROC subtype ops return arrays of augmented proc structures:
 */
struct kinfo_proc {
	struct	proc kp_proc;			/* proc structure */
	struct	eproc {
		struct	proc *e_paddr;		/* address of proc */
		struct	session *e_sess;	/* session pointer */
		struct	pcred e_pcred;		/* process credentials */
		struct	ucred e_ucred;		/* current credentials */
		struct	vmspace e_vm;		/* address space */
		struct  pstats e_pstats;	/* process stats */
		int	e_pstats_valid;		/* pstats valid? */
		pid_t	e_ppid;			/* parent process id */
		pid_t	e_pgid;			/* process group id */
		short	e_jobc;			/* job control counter */
		dev_t	e_tdev;			/* controlling tty dev */
		pid_t	e_tpgid;		/* tty process group id */
		struct	session *e_tsess;	/* tty session pointer */
#define	WMESGLEN	7
		char	e_wmesg[WMESGLEN+1];	/* wchan message */
		segsz_t e_xsize;		/* text size */
		short	e_xrssize;		/* text rss */
		short	e_xccount;		/* text references */
		short	e_xswrss;
		long	e_flag;
#define	EPROC_CTTY	0x01	/* controlling tty vnode active */
#define	EPROC_SLEADER	0x02	/* session leader */
		char	e_login[MAXLOGNAME];	/* setlogin() name */
#define	EMULNAMELEN	7
		char	e_emul[EMULNAMELEN+1];	/* syscall emulation name */
	        rlim_t	e_maxrss;
		struct plimit *e_limit;
	} kp_eproc;
};

/*
 * KERN_PROC2 subtype ops return arrays of relatively fixed size
d323 4
a326 1
struct kinfo_proc2 {
d341 3
a343 1
	int32_t	p_eflag;		/* LONG: extra kinfo_proc2 flags */
d447 2
a448 2
 * Macros for filling in the bulk of a kinfo_proc2 structure, used
 * in the kernel to implement the KERN_PROC2 sysctl and in userland
d451 1
a451 1
 *	kp - target kinfo_proc2 structure
d472 1
a472 1
#define FILL_KPROC2(kp, copy_str, p, pr, pc, uc, pg, paddr, praddr, sess, vm, lim, ps) \
a926 2
void fill_eproc(struct proc *, struct eproc *);

d930 1
a930 1
void fill_kproc2(struct proc *, struct kinfo_proc2 *);
@


1.107
log
@export the network livelock counter. part of a diff i committed the
userland side of.

pointed out by claudio@@ after i embarassed myself saying "yes, its there!"
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.106 2010/08/19 18:14:13 kettenis Exp $	*/
d424 1
a424 1
	u_int8_t p_usrpri;		/* U_CHAR: User-priority based on p_cpu and p_nice. */
d557 1
a557 1
	(kp)->p_nice = (p)->p_nice;					\
@


1.106
log
@Introduce an MI kern.consdev sysctl that will replace the MD
machdep.console_device that's only implemented on a few architectures.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.105 2010/07/26 01:56:27 guenther Exp $	*/
d193 2
a194 1
#define	KERN_MAXID		76	/* number of valid kern ids */
d273 1
@


1.105
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.104 2010/06/29 00:28:14 tedu Exp $	*/
d192 2
a193 1
#define	KERN_MAXID		75	/* number of valid kern ids */
d271 1
@


1.104
log
@Eliminate RTHREADS kernel option in favor of a sysctl.  The actual status
(not done) hasn't changed, but now it's less work to test things.
ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.103 2010/06/28 18:50:37 claudio Exp $	*/
d502 1
a502 1
#define FILL_KPROC2(kp, copy_str, p, pr, pc, uc, pg, paddr, sess, vm, lim, ps) \
d512 1
a512 1
	(kp)->p_sess = PTRTOINT64((p)->p_session);			\
d516 1
a516 1
	(kp)->p_flag = (p)->p_flag | P_INMEM;				\
d567 1
a567 1
	if ((sess)->s_leader == (paddr))				\
@


1.103
log
@Add the rtable id as an argument to rn_walktree(). Functions like
rt_if_remove_rtdelete() need to know the table id to be able to correctly
remove nodes.
Problem found by Andrea Parazzini and analyzed by Martin Pelikn.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.102 2010/05/02 00:51:10 tedu Exp $	*/
d191 2
a192 1
#define	KERN_MAXID		74	/* number of valid kern ids */
d269 1
@


1.102
log
@repeated text in a comment, spotted by adam dutko
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.101 2010/01/10 03:37:50 guenther Exp $	*/
d945 1
a945 1
int sysctl_dumpentry(struct radix_node *, void *);
@


1.101
log
@Reimplement kvm_getproc2()'s support for reading crash dumps and
/dev/mem to be direct instead of going through kvm_getprocs(), as
that function is going to get more an more broken as we move stuff
from struct proc to struct process for rthreads.  To minimize the
code copying, put the common logic of filling in a kinfo_proc2
structure into a macro FILL_KPROC2() in <sys/sysctl.h> for use from
both the kernel and user-space.  This also hides the KERN_PROC
#define behind "#if defined(_KERNEL)||defined(_LIBKVM)", as it's
deprecated.

Positive feedback from millert and blambert; so committing to unblock
further rthreads work.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.100 2009/06/15 17:59:44 deraadt Exp $	*/
d629 1
a629 1
 * both to be immune to be immune to 32/64 bit emulation issues and to
@


1.100
log
@No you cannot remove a sysctl mib once you add it.  It becomes ABI.  That
is how sysctl finds them, so it can *never* be renumbered again, and must
stay
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.99 2009/06/15 17:01:26 beck Exp $	*/
d129 1
d131 1
d471 155
@


1.99
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.98 2009/06/07 03:07:19 millert Exp $	*/
d187 3
a189 2
#define	KERN_FILE2		72	/* struct: file entries */
#define	KERN_MAXID		73	/* number of valid kern ids */
d264 1
@


1.98
log
@Add KERN_FILE2 sysctl analogous to KERN_PROC2 but for file structures,
along with vnode type-specific info to make it more useful for fstat(1).
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.97 2009/06/03 21:30:20 beck Exp $	*/
d187 2
a188 3
#define	KERN_CACHEPCT		72	/* buffer cache % of physmem */
#define	KERN_FILE2		73	/* struct: file entries */
#define	KERN_MAXID		74	/* number of valid kern ids */
a262 1
 	{ "bufcachepercent", CTLTYPE_INT }, \
@


1.97
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.96 2009/04/19 17:53:39 deraadt Exp $	*/
d188 2
a189 1
#define	KERN_MAXID		73	/* number of valid kern ids */
d265 1
d471 88
d784 1
d799 4
@


1.96
log
@Count number of cpus found (potentially not attached) and store that
in sysctl hw.ncpufound; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.95 2009/01/21 21:02:41 miod Exp $	*/
d187 2
a188 1
#define	KERN_MAXID		72	/* number of valid kern ids */
d263 1
@


1.95
log
@Pass the new pointer to sysctl_clockrate(), so that trying to change the
value of kern.clockrate with sysctl(3) correctly sets errno on failure.
PR #6040, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.94 2008/10/07 02:20:11 deraadt Exp $	*/
d539 1
a539 1
#define	HW_NCPU		 3		/* int: number of cpus */
d557 2
a558 1
#define	HW_MAXID	21		/* number of valid hw ids */
d582 1
@


1.94
log
@Do not display file offsets and a few other pieces of information, except
to the user or the superuser.  Display * for those fields instead.  From
PR 5113, but modified to use copyout correctly.
comments from tedu, ok from others
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.93 2008/09/16 15:48:12 gollo Exp $	*/
d696 1
a696 1
int sysctl_clockrate(char *, size_t *);
@


1.93
log
@netstat statistics for pflow(4) via pseudo family

ok cluadio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.92 2008/02/09 15:10:58 kettenis Exp $	*/
d689 1
a689 1
int sysctl_file(char *, size_t *);
@


1.92
log
@Introduce HW_PHYSMEM64 and HW_USERMEM64 sysctls, which don't overflow on
machines with more than 4GB of memory.  Make sysctl(8) print values obtained
using these sysctls for hw.physmem and hw.usermem.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.91 2007/04/12 22:14:15 tedu Exp $	*/
d733 1
@


1.91
log
@move p_limit and p_cred into struct process
leave macros behind for now to keep the commit small
ok art beck miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.90 2007/01/12 07:41:31 art Exp $	*/
d555 3
a557 1
#define	HW_MAXID	19		/* number of valid hw ids */
d565 2
a566 2
	{ "physmem", CTLTYPE_INT }, \
	{ "usermem", CTLTYPE_INT }, \
d579 2
@


1.90
log
@Switch some lockmgr locks to rwlocks.
In this commit:
 - gdt lock on amd64
 - sysctl lock
 - malloc sysctl lock
 - disk sysctl lock
 - swap syscall lock

miod@@, pedro@@ ok (and "looks good" others@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.89 2006/12/12 23:14:28 dim Exp $	*/
d332 1
@


1.89
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.88 2006/05/08 22:51:18 gwk Exp $	*/
a727 2

void sysctl_init(void);
@


1.88
log
@Add smbios support for i386 and amd64, fix ipmi to use this new functionallity,
hook up some sysctls to add system vendor/product/version and UUID reporting.

"get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.87 2006/03/15 21:02:04 deraadt Exp $	*/
d725 1
a725 1
extern int (*cpu_setperf)(int);
@


1.87
log
@add sysctl_int_lower().  This can read, but can only write to a kernel
variable if the result is a lowering of the value; tested matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.86 2006/02/06 17:37:28 jmc Exp $	*/
d549 6
a554 1
#define	HW_MAXID	14		/* number of valid hw ids */
d571 5
@


1.86
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.85 2005/12/13 00:35:23 millert Exp $	*/
d663 1
@


1.85
log
@First step in include files overhaul.  Use __FOO_VISIBLE (as defined
in sys/cdefs.h) instead of _FOO_SOURCE.  Also fix several namespace
pollution issues, including the byte order defines.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.84 2005/10/26 17:22:00 mickey Exp $	*/
d621 1
a621 1
 * Third level identifier specifies which stucture component.
@


1.84
log
@missing name for KERN_CPTIME2; from form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.83 2005/06/08 22:33:27 millert Exp $	*/
d462 1
@


1.83
log
@Add KERN_CPTIME2 on systems where __HAVE_CPUINFO is defined, exposes
spc_cp_time member of struct schedstate_percpu (per-cpu stats).
From art@@ during the hackathon.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.82 2005/03/10 17:26:10 tedu Exp $	*/
d261 1
@


1.82
log
@split out uidinfo from kern_proc.c private, use it to store lock count,
restrict lock count per uid to a global limit, add sysctl to adjust limit.
this prevents a user from creating too many locks.  problem noticed
by devon o'dell.  ok deraadt miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.81 2004/08/04 23:33:32 deraadt Exp $	*/
d186 2
a187 1
#define	KERN_MAXID		71	/* number of valid kern ids */
@


1.81
log
@tholo forgot to update KERN_MAXID; j@@pureftpd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.80 2004/07/28 17:15:12 tholo Exp $	*/
d185 2
a186 1
#define	KERN_MAXID		70	/* number of valid kern ids */
d259 1
@


1.80
log
@This touches only MI code, and adds new time keeping code.  The
code is all conditionalized on __HAVE_TIMECOUNTER, and not
enabled on any platforms.

adjtime(2) support exists, courtesy of nordin@@, sysctl(2) support
and a concept of quality for each time source attached exists.

High quality time sources exists for PIIX4 ACPI timer as well as
some AMD power management chips.  This will have to be redone
once we actually add ACPI support (at that time we need to use
the ACPI interfaces to get at these clocks).

ok art@@ ken@@ miod@@ jmc@@ and many more
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.79 2004/06/28 01:34:46 aaron Exp $	*/
d185 1
a185 1
#define	KERN_MAXID		69	/* number of valid kern ids */
@


1.79
log
@Add new, generic ``evcount'' event counter API to the kernel.  From art@@,
with modifications from me.  Includes code for generic interrupt counter
fetching via sysctl.  deraadt@@ tholo@@ drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.78 2004/06/11 01:32:05 deraadt Exp $	*/
d184 1
d257 1
d487 17
@


1.78
log
@export cpuid via kproc2, and make ps & top aware
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.28.4.15 2004/06/06 23:23:13 deraadt Exp $	*/
d183 2
a184 1
#define	KERN_MAXID		68	/* number of valid kern ids */
d255 1
d459 1
a459 1
 * KERN_INTR_CNT
d464 2
a465 1
#define KERN_INTRCNT_MAXID	4
@


1.77
log
@introduce a new km_page allocator that gets pages from kernel_map using
an interrupt safe thread.
use this as the new backend for mbpool and mclpool, eliminating the mb_map.
introduce a sysctl kern.maxclusters which controls the limit of clusters
allocated.
testing by many people, works everywhere but m68k.  ok deraadt@@

this essentially deprecates the NMBCLUSTERS option, don't use it.
this should reduce pressure on the kmem_map and the uvm reserve of static
map entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.76 2004/02/27 21:46:44 grange Exp $	*/
d339 2
d453 1
@


1.76
log
@Move setperf_prio to the machdep code, requested by deraadt@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.75 2004/02/27 21:15:45 grange Exp $	*/
d182 2
a183 1
#define	KERN_MAXID		67	/* number of valid kern ids */
d253 1
@


1.75
log
@Introduce simple priorities mechanism so that concurrent
hw.setperf handlers don't override each other.
Problem reported and tested by danh@@.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.74 2004/02/24 21:43:56 tedu Exp $	*/
a682 1
extern int setperf_prio;
@


1.74
log
@sysctl knob for bpf tunables.  some tips from canacar@@
ok canacar@@ deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.73 2004/02/15 11:14:45 markus Exp $	*/
d683 1
@


1.73
log
@add sysctl_int_arr() API similar to BSD/OS; ok itojun, deraadt, miod, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.72 2004/02/14 15:09:22 grange Exp $	*/
d683 2
@


1.72
log
@Simplify hw.{cpuspeed,setperf} api moving all the sysctl stuff
from the underlying callbacks.

Testing hppa mickey@@, ppc drahn@@
Ok markus@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.71 2004/01/07 21:51:30 millert Exp $	*/
d632 1
@


1.71
log
@Add p_rlim_rss_cur for ps "lim" field.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.70 2004/01/07 04:13:02 millert Exp $	*/
d680 2
a681 2
extern int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
extern int (*cpu_setperf)(void *, size_t *, void *, size_t);
@


1.70
log
@Variables in kinfo_proc2 that are actually sigset_t should be unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.69 2004/01/07 03:37:57 millert Exp $	*/
d448 1
@


1.69
log
@Add p_emul to kinfo_proc2 for ps
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.68 2004/01/07 02:13:51 millert Exp $	*/
d390 1
a390 1
	int32_t	p_holdcnt;              /* INT: If non-zero, don't swap. */
d393 3
a395 3
	int32_t p_sigmask;		/* INT: Current signal mask. */
	int32_t p_sigignore;		/* INT: Signals being ignored. */
	int32_t p_sigcatch;		/* INT: Signals being caught by user. */
d444 1
a444 1
	u_int64_t p_realflag;	       	/* INT: P_* flags (not including LWPs). */
@


1.68
log
@Implement KERN_PROC2 sysctl from NetBSD.  This will allow us to
have ps and friends be independent of changes in struct proc et al
in the kernel.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.67 2003/12/23 20:02:27 tedu Exp $	*/
d335 1
d447 1
@


1.67
log
@add cpu_setperf and cpu_cpuspeed externs to make life easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.66 2003/12/18 23:46:20 tedu Exp $	*/
d181 2
a182 1
#define	KERN_MAXID		66	/* number of valid kern ids */
d251 1
d326 123
d652 1
@


1.66
log
@add new hw sysctls, cpuspeed and setperf to control cpu frequency.
convert longrun support to use new sysctls.
add enhanced speedstep support, based on code by Michael Eriksson.
idea, help testing & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.65 2003/08/21 18:56:07 tedu Exp $	*/
d550 3
@


1.65
log
@emulation is now controlled by sysctl.  changes:
add e_flags to struct emul.  this stores on/off and native flags.
check for emul enabled in check_exec().  gather all the emuls into a
emulsw so a sysctl can find them.  create sysctl.  move maxhdrsiz calcualation
into init_main so it cleans up sys_execve codepath.  teach sysctl utility
to grok kern.emul hierarchy.
requested and ok deraadt@@  some comments from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.64 2003/06/02 23:28:22 millert Exp $	*/
d387 3
a389 1
#define	HW_MAXID	12		/* number of valid hw ids */
d404 2
@


1.64
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.63 2003/04/25 20:06:41 grange Exp $	*/
d180 2
a181 1
#define	KERN_MAXID		65	/* number of valid kern ids */
d249 1
d251 9
@


1.63
log
@sysctl front-end for the hardware monitoring sensors. This adds
new node hw.sensors; information from the sensors can be obtained
via hw.sensors.n, where n is a sensor number. All values are read only
for now. Documentation and back-end drivers are comming.
Tested by henning@@ and millert@@. Four oks from henning@@ and one
from millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.62 2003/01/21 16:59:23 markus Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.62
log
@add kern.watchdog sysctl and generic watchdog interface;
based on feedback and discussions with mickey, henric, fgsch and jakob.
ok art@@, mickey@@, jakob@@, henric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.61 2003/01/13 06:04:16 art Exp $	*/
d379 2
a380 1
#define	HW_MAXID	11		/* number of valid hw ids */
d394 1
@


1.61
log
@Sysctls for fetching intrcnt.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.60 2002/12/17 23:11:31 millert Exp $	*/
d183 2
a184 1
#define	KERN_MAXID		64	/* number of valid kern ids */
d251 1
d332 13
d536 1
@


1.60
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.59 2002/07/07 22:06:33 deraadt Exp $	*/
d182 2
a183 1
#define	KERN_MAXID		63	/* number of valid kern ids */
d249 1
d313 15
@


1.59
log
@document a bit better
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.58 2002/07/07 18:20:02 deraadt Exp $	*/
d180 3
a182 1
#define	KERN_MAXID		61	/* number of valid kern ids */
d246 2
@


1.58
log
@No, you do NOT go renumbering the sysctl table!
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.56 2002/06/11 11:14:29 beck Exp $	*/
d144 2
a145 2
#define	KERN_NTPTIME		25	/* struct: extended-precision time */
#define	KERN_TIMEX		26	/* struct: ntp timekeeping state */
@


1.57
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d144 37
a180 35
#define	KERN_OSVERSION		25	/* string: kernel build version */
#define	KERN_SOMAXCONN		26	/* int: listen queue maximum */
#define	KERN_SOMINCONN		27	/* int: half-open controllable param */
#define	KERN_USERMOUNT		28	/* int: users may mount filesystems */
#define	KERN_RND		29	/* struct: rnd(4) statistics */
#define	KERN_NOSUIDCOREDUMP	30	/* int: no setuid coredumps ever */ 
#define	KERN_FSYNC		31	/* int: file synchronization support */
#define	KERN_SYSVMSG		32	/* int: SysV message queue suppoprt */
#define	KERN_SYSVSEM		33	/* int: SysV semaphore support */
#define	KERN_SYSVSHM		34	/* int: SysV shared memory support */
#define	KERN_ARND		35	/* int: random integer from arc4rnd */
#define	KERN_MSGBUFSIZE		36	/* int: size of message buffer */
#define KERN_MALLOCSTATS	37	/* node: malloc statistics */
#define KERN_CPTIME		38	/* array: cp_time */
#define KERN_NCHSTATS		39	/* struct: vfs cache statistics */
#define KERN_FORKSTAT		40	/* struct: fork statistics */
#define KERN_NSELCOLL		41	/* int: select(2) collisions */
#define KERN_TTY		42	/* node: tty information */
#define	KERN_CCPU		43	/* int: ccpu */
#define	KERN_FSCALE		44	/* int: fscale */
#define	KERN_NPROCS		45	/* int: number of processes */
#define	KERN_MSGBUF		46	/* message buffer, KERN_MSGBUFSIZE */
#define	KERN_POOL		47	/* struct: pool information */
#define	KERN_STACKGAPRANDOM	48	/* int: stackgap_random */
#define	KERN_SYSVIPC_INFO	49	/* struct: SysV sem/shm/msg info */
#define KERN_USERCRYPTO		50	/* int: usercrypto */
#define KERN_CRYPTODEVALLOWSOFT	51	/* int: cryptodevallowsoft */
#define KERN_SPLASSERT		52	/* int: splassert */
#define KERN_PROC_ARGS		53	/* node: proc args and env */
#define	KERN_NFILES		54	/* int: number of open files */
#define	KERN_TTYCOUNT		55	/* int: number of tty devices */
#define KERN_NUMVNODES		56	/* int: number of vnodes in use */
#define	KERN_MBSTAT		57	/* struct: mbuf statistics */
#define KERN_USERASYMCRYPTO	58	/* int: usercrypto */
#define	KERN_MAXID		59	/* number of valid kern ids */
d208 2
@


1.56
log
@kernel changes to make asymmetric crypto work in userland
- modify getfeat to return something more useful to us on devices
  (like lofn and everything else until jason fixes it) that can't
  do rsa stuff, etc and can only do mod_exp..
- error handling fixes so we correctly fail to software when we can't
  deal with a particular key size
- add sysctl kern.userasymcrypto to turn on/off userland asymmetric crypto
  via /dev/crypto - 1 == on, 0 == off, default is off
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.55 2002/06/09 09:51:31 art Exp $	*/
d144 35
a178 37
#define	KERN_NTPTIME		25	/* struct: extended-precision time */
#define	KERN_TIMEX		26	/* struct: ntp timekeeping state */
#define	KERN_OSVERSION		27	/* string: kernel build version */
#define	KERN_SOMAXCONN		28	/* int: listen queue maximum */
#define	KERN_SOMINCONN		29	/* int: half-open controllable param */
#define	KERN_USERMOUNT		30	/* int: users may mount filesystems */
#define	KERN_RND		31	/* struct: rnd(4) statistics */
#define	KERN_NOSUIDCOREDUMP	32	/* int: no setuid coredumps ever */ 
#define	KERN_FSYNC		33	/* int: file synchronization support */
#define	KERN_SYSVMSG		34	/* int: SysV message queue suppoprt */
#define	KERN_SYSVSEM		35	/* int: SysV semaphore support */
#define	KERN_SYSVSHM		36	/* int: SysV shared memory support */
#define	KERN_ARND		37	/* int: random integer from arc4rnd */
#define	KERN_MSGBUFSIZE		38	/* int: size of message buffer */
#define KERN_MALLOCSTATS	39	/* node: malloc statistics */
#define KERN_CPTIME		40	/* array: cp_time */
#define KERN_NCHSTATS		41	/* struct: vfs cache statistics */
#define KERN_FORKSTAT		42	/* struct: fork statistics */
#define KERN_NSELCOLL		43	/* int: select(2) collisions */
#define KERN_TTY		44	/* node: tty information */
#define	KERN_CCPU		45	/* int: ccpu */
#define	KERN_FSCALE		46	/* int: fscale */
#define	KERN_NPROCS		47	/* int: number of processes */
#define	KERN_MSGBUF		48	/* message buffer, KERN_MSGBUFSIZE */
#define	KERN_POOL		49	/* struct: pool information */
#define	KERN_STACKGAPRANDOM	50	/* int: stackgap_random */
#define	KERN_SYSVIPC_INFO	51	/* struct: SysV sem/shm/msg info */
#define KERN_USERCRYPTO		52	/* int: usercrypto */
#define KERN_CRYPTODEVALLOWSOFT	53	/* int: cryptodevallowsoft */
#define KERN_SPLASSERT		54	/* int: splassert */
#define KERN_PROC_ARGS		55	/* node: proc args and env */
#define	KERN_NFILES		56	/* int: number of open files */
#define	KERN_TTYCOUNT		57	/* int: number of tty devices */
#define KERN_NUMVNODES		58	/* int: number of vnodes in use */
#define	KERN_MBSTAT		59	/* struct: mbuf statistics */
#define KERN_USERASYMCRYPTO	60	/* int: usercrypto */
#define	KERN_MAXID		61	/* number of valid kern ids */
a205 2
	{ "ntptime", CTLTYPE_STRUCT }, \
	{ "timex", CTLTYPE_STRUCT }, \
a467 1
int sysctl_ntptime(char *, size_t *);
@


1.55
log
@Userland might want resource.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.54 2002/06/09 05:46:15 art Exp $	*/
d179 2
a180 1
#define	KERN_MAXID		60	/* number of valid kern ids */
d243 1
@


1.54
log
@add struct pstats to struct eproc
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.53 2002/06/09 04:26:40 angelos Exp $	*/
d52 1
@


1.53
log
@Add KERN_MBSTAT
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.52 2002/06/08 23:32:14 angelos Exp $	*/
d54 2
d281 2
@


1.52
log
@TTYCOUNT and NUMVNODES
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.51 2002/06/08 23:16:03 angelos Exp $	*/
d175 2
a176 1
#define	KERN_MAXID		59	/* number of valid kern ids */
d238 1
@


1.51
log
@Add KERN_NFILES, and procargs entry.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.50 2002/06/08 22:24:47 art Exp $	*/
d173 3
a175 1
#define	KERN_MAXID		57	/* number of valid kern ids */
d235 2
@


1.50
log
@Sysctl for getting process arguments and environment.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.49 2002/05/15 23:17:53 art Exp $	*/
d172 2
a173 1
#define	KERN_MAXID		56	/* number of valid kern ids */
d231 2
@


1.49
log
@Implement splassert() for sparc - a tool for finding problems related to
spl handling (already found 3 problems).

Man page in a few seconds.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.48 2002/03/14 19:42:54 mickey Exp $	*/
d171 2
a172 1
#define	KERN_MAXID		55	/* number of valid kern ids */
d250 8
@


1.48
log
@version[] is externed in the systm.h and give it some const
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.47 2002/03/14 01:27:14 millert Exp $	*/
d170 2
a171 1
#define	KERN_MAXID		54	/* number of valid kern ids */
d228 1
@


1.47
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.46 2002/03/01 02:52:51 provos Exp $	*/
d433 2
a434 2
int sysctl_rdstring(void *, size_t *, void *, char *);
int sysctl_rdstruct(void *, size_t *, void *, void *, int);
a443 2
int sysctl_rdstring(void *, size_t *, void *, char *);
int sysctl_rdstruct(void *, size_t *, void *, void *, int);
@


1.46
log
@sysctl for cryptodevallowsoft - /dev/crypto will allow the software engine
to be used if there are no hardware cards.  mostly for debugging and
regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.45 2002/02/23 08:07:59 deraadt Exp $	*/
d424 1
a424 2
typedef int (sysctlfn)
    __P((int *, u_int, void *, size_t *, void *, size_t, struct proc *));
d426 12
a437 12
int sysctl_int __P((void *, size_t *, void *, size_t, int *));
int sysctl_rdint __P((void *, size_t *, void *, int));
int sysctl_quad __P((void *, size_t *, void *, size_t, int64_t *));
int sysctl_rdquad __P((void *, size_t *, void *, int64_t));
int sysctl_string __P((void *, size_t *, void *, size_t, char *, int));
int sysctl_tstring __P((void *, size_t *, void *, size_t, char *, int));
int sysctl__string __P((void *, size_t *, void *, size_t, char *, int, int));
int sysctl_rdstring __P((void *, size_t *, void *, char *));
int sysctl_rdstruct __P((void *, size_t *, void *, void *, int));
int sysctl_struct __P((void *, size_t *, void *, size_t, void *, int));
int sysctl_file __P((char *, size_t *));
int sysctl_doproc __P((int *, u_int, char *, size_t *));
d440 8
a447 8
int sysctl_dumpentry __P((struct radix_node *, void *));
int sysctl_iflist __P((int, struct walkarg *));
int sysctl_rtable __P((int *, u_int, void *, size_t *, void *, size_t));
int sysctl_clockrate __P((char *, size_t *));
int sysctl_rdstring __P((void *, size_t *, void *, char *));
int sysctl_rdstruct __P((void *, size_t *, void *, void *, int));
int sysctl_vnode __P((char *, size_t *, struct proc *));
int sysctl_ntptime __P((char *, size_t *));
d449 1
a449 1
int sysctl_doprof __P((int *, u_int, void *, size_t *, void *, size_t));
d451 1
a451 1
int sysctl_dopool __P((int *, u_int, char *, size_t *));
d453 1
a453 1
void fill_eproc __P((struct proc *, struct eproc *));
d455 4
a458 4
int kern_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
		     struct proc *));
int hw_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *));
d460 2
a461 2
int debug_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
		      struct proc *));
d463 13
a475 13
int vm_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *));
int fs_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *));
int fs_posix_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
			 struct proc *));
int net_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *));
int cpu_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *));
int vfs_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *));
int sysctl_sysvipc __P((int *, u_int, void *, size_t *));
d477 1
a477 1
void sysctl_init __P((void));
d483 1
a483 1
int	sysctl __P((int *, u_int, void *, size_t *, void *, size_t));
@


1.45
log
@sysctl kern.usercrypto
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.44 2001/11/06 19:53:21 miod Exp $	*/
d169 2
a170 1
#define	KERN_MAXID		53	/* number of valid kern ids */
d226 1
@


1.44
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.43 2001/09/28 01:42:54 millert Exp $	*/
d168 2
a169 1
#define	KERN_MAXID		52	/* number of valid kern ids */
d224 1
@


1.44.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.44 2001/11/06 19:53:21 miod Exp $	*/
a51 1
#include <sys/resource.h>
a53 2
#include <sys/resourcevar.h>	/* XXX */

d168 1
a168 9
#define KERN_USERCRYPTO		52	/* int: usercrypto */
#define KERN_CRYPTODEVALLOWSOFT	53	/* int: cryptodevallowsoft */
#define KERN_SPLASSERT		54	/* int: splassert */
#define KERN_PROC_ARGS		55	/* node: proc args and env */
#define	KERN_NFILES		56	/* int: number of open files */
#define	KERN_TTYCOUNT		57	/* int: number of tty devices */
#define KERN_NUMVNODES		58	/* int: number of vnodes in use */
#define	KERN_MBSTAT		59	/* struct: mbuf statistics */
#define	KERN_MAXID		60	/* number of valid kern ids */
a222 8
	{ "usercrypto", CTLTYPE_INT }, \
	{ "cryptodevallowsoft", CTLTYPE_INT }, \
	{ "splassert", CTLTYPE_INT }, \
	{ "procargs", CTLTYPE_NODE }, \
	{ "nfiles", CTLTYPE_INT }, \
	{ "ttycount", CTLTYPE_INT }, \
	{ "numvnodes", CTLTYPE_INT }, \
	{ "mbstat", CTLTYPE_STRUCT }, \
a244 8
 * KERN_PROC_ARGS subtypes
 */
#define KERN_PROC_ARGV		1
#define KERN_PROC_NARGV		2
#define KERN_PROC_ENV		3
#define KERN_PROC_NENV		4

/*
a254 2
		struct  pstats e_pstats;	/* process stats */
		int	e_pstats_valid;		/* pstats valid? */
d420 2
a421 1
typedef int (sysctlfn)(int *, u_int, void *, size_t *, void *, size_t, struct proc *);
d423 12
a434 12
int sysctl_int(void *, size_t *, void *, size_t, int *);
int sysctl_rdint(void *, size_t *, void *, int);
int sysctl_quad(void *, size_t *, void *, size_t, int64_t *);
int sysctl_rdquad(void *, size_t *, void *, int64_t);
int sysctl_string(void *, size_t *, void *, size_t, char *, int);
int sysctl_tstring(void *, size_t *, void *, size_t, char *, int);
int sysctl__string(void *, size_t *, void *, size_t, char *, int, int);
int sysctl_rdstring(void *, size_t *, void *, const char *);
int sysctl_rdstruct(void *, size_t *, void *, const void *, int);
int sysctl_struct(void *, size_t *, void *, size_t, void *, int);
int sysctl_file(char *, size_t *);
int sysctl_doproc(int *, u_int, char *, size_t *);
d437 8
a444 6
int sysctl_dumpentry(struct radix_node *, void *);
int sysctl_iflist(int, struct walkarg *);
int sysctl_rtable(int *, u_int, void *, size_t *, void *, size_t);
int sysctl_clockrate(char *, size_t *);
int sysctl_vnode(char *, size_t *, struct proc *);
int sysctl_ntptime(char *, size_t *);
d446 1
a446 1
int sysctl_doprof(int *, u_int, void *, size_t *, void *, size_t);
d448 1
a448 1
int sysctl_dopool(int *, u_int, char *, size_t *);
d450 1
a450 1
void fill_eproc(struct proc *, struct eproc *);
d452 4
a455 4
int kern_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		     struct proc *);
int hw_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *);
d457 2
a458 2
int debug_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		      struct proc *);
d460 13
a472 13
int vm_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *);
int fs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *);
int fs_posix_sysctl(int *, u_int, void *, size_t *, void *, size_t,
			 struct proc *);
int net_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int cpu_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int vfs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int sysctl_sysvipc(int *, u_int, void *, size_t *);
d474 1
a474 1
void sysctl_init(void);
d480 1
a480 1
int	sysctl(int *, u_int, void *, size_t *, void *, size_t);
@


1.44.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.44.2.1 2002/06/11 03:32:34 art Exp $	*/
d144 2
a145 2
/*define gap			25	*/
/*define gap			26	*/
d179 1
a179 2
#define KERN_USERASYMCRYPTO	60	/* int: usercrypto */
#define	KERN_MAXID		61	/* number of valid kern ids */
d207 2
a208 2
	{ "gap", 0 }, \
	{ "gap", 0 }, \
a241 1
	{ "userasymcrypto", CTLTYPE_INT }, \
d470 1
@


1.44.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d180 1
a180 5
#define	KERN_SEMINFO		61	/* struct: SysV struct seminfo */
#define	KERN_SHMINFO		62	/* struct: SysV struct shminfo */
#define KERN_INTRCNT		63	/* node: interrupt counters */
#define	KERN_WATCHDOG		64	/* node: watchdog */
#define	KERN_MAXID		65	/* number of valid kern ids */
a243 4
	{ "seminfo", CTLTYPE_STRUCT }, \
	{ "shminfo", CTLTYPE_STRUCT }, \
	{ "intrcnt", CTLTYPE_NODE }, \
 	{ "watchdog", CTLTYPE_NODE }, \
a308 28
 * KERN_INTR_CNT
 */
#define KERN_INTRCNT_NUM	1	/* int: # intrcnt */
#define KERN_INTRCNT_CNT	2	/* node: intrcnt */
#define KERN_INTRCNT_NAME	3	/* node: names */
#define KERN_INTRCNT_MAXID	4

#define CTL_KERN_INTRCNT_NAMES { \
	{ 0, 0 }, \
	{ "nintrcnt", CTLTYPE_INT }, \
	{ "intrcnt", CTLTYPE_NODE }, \
	{ "intrname", CTLTYPE_NODE }, \
}

/*
 * KERN_WATCHDOG
 */
#define KERN_WATCHDOG_PERIOD	1	/* int: watchdog period */
#define KERN_WATCHDOG_AUTO	2	/* int: automatic tickle */
#define KERN_WATCHDOG_MAXID	3

#define CTL_KERN_WATCHDOG_NAMES { \
	{ 0, 0 }, \
	{ "period", CTLTYPE_INT }, \
	{ "auto", CTLTYPE_INT }, \
}

/*
d343 1
a343 2
#define	HW_SENSORS	11		/* node: hardware monitors */
#define	HW_MAXID	12		/* number of valid hw ids */
a356 1
	{ "sensors", CTLTYPE_NODE}, \
a499 1
int sysctl_wdog(int *, u_int, void *, size_t *, void *, size_t);
@


1.43
log
@sysctl() support for getting the SYSV *info structs and the associated
SYSV structs.  To be used by ipcs(1).  Based on work by simonb@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.42 2001/08/18 03:32:16 art Exp $	*/
d54 1
a54 1
#include <vm/vm.h>
@


1.42
log
@Add a possibility to add a random offset to the stack on exec. This makes
it slightly harder to write generic buffer overflows. This doesn't really
give any real security, but it raises the bar for script-kiddies and it's
really cheap.

The range of the random offsets is controlled by the sysctl
kern.stackgap_random (must be a power of 2).

This is disabled by default right now, but we'll set it to a reasonable value
(1024?) soon, after some more testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.41 2001/06/24 16:00:45 art Exp $	*/
d166 3
a168 2
#define KERN_STACKGAPRANDOM	50	/* int: stackgap_random */
#define	KERN_MAXID		51	/* number of valid kern ids */
d222 1
d238 7
d472 1
@


1.41
log
@Add a sysctl for getting pool information out of the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.40 2001/06/22 21:32:59 mickey Exp $	*/
d166 2
a167 1
#define	KERN_MAXID		50	/* number of valid kern ids */
d220 1
@


1.40
log
@provide sysctl iface for msgbuf; raadtified
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.39 2001/06/03 04:37:58 angelos Exp $	*/
d165 2
a166 1
#define	KERN_MAXID		49	/* number of valid kern ids */
d218 1
d437 1
@


1.39
log
@KERN_NPROCS
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.38 2001/06/03 03:52:12 angelos Exp $	*/
d164 2
a165 1
#define	KERN_MAXID		48	/* number of valid kern ids */
d216 1
@


1.38
log
@Add KERN_FSCALE and KERN_CCPU.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.37 2001/05/14 07:11:35 angelos Exp $	*/
d163 2
a164 1
#define	KERN_MAXID		47	/* number of valid kern ids */
d214 1
@


1.37
log
@Disk statistics via sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.36 2001/05/11 06:36:59 angelos Exp $	*/
d161 3
a163 1
#define	KERN_MAXID		45	/* number of valid kern ids */
d211 2
@


1.36
log
@sysctl entries for kmemstats, nselcoll, nchstats, and forkstat.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.35 2001/03/16 08:49:08 art Exp $	*/
d160 2
a161 1
#define	KERN_MAXID		44	/* number of valid kern ids */
d208 1
d290 2
a291 1
#define	HW_MAXID	10		/* number of valid hw ids */
d302 1
a302 1
	{ "disknames", CTLTYPE_STRUCT }, \
d304 1
@


1.35
log
@Use a lockmgr lock for keeping down the vslocked memory in sysctl
instead of a home-brew equivalent.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.34 2001/01/31 09:59:50 deraadt Exp $	*/
d157 4
a160 1
#define	KERN_MAXID		41	/* number of valid kern ids */
d204 3
@


1.34
log
@add kern.cp_time sysctl, to be used by various things
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.33 2001/01/03 19:20:59 angelos Exp $	*/
d440 3
@


1.33
log
@Add sysctl_quad/sysctl_rdquad routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.32 2000/09/17 22:00:01 pjanzen Exp $	*/
d156 2
a157 1
#define	KERN_MAXID		40	/* number of valid kern ids */
d200 1
@


1.32
log
@Consistent tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.31 2000/07/01 02:55:57 pjanzen Exp $	*/
d155 2
a156 1
#define	KERN_MAXID		39	/* number of valid kern ids */
d198 1
d392 2
@


1.31
log
@correct struct name in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.30 2000/06/18 17:59:55 niklas Exp $	*/
d65 1
a65 1
#define CTL_MAXNAME	12	/* largest number of components supported */
d97 1
a97 1
#define CTL_VFS         10              /* VFS sysctl's */
d100 1
a100 1
#define CTL_NAMES { \
d140 1
a140 1
#define KERN_RAWPARTITION	24	/* int: raw partition number */
d147 6
a152 6
#define KERN_RND		31	/* struct: rnd(4) statistics */
#define KERN_NOSUIDCOREDUMP	32	/* int: no setuid coredumps ever */ 
#define	KERN_FSYNC		33      /* int: file synchronization support */
#define	KERN_SYSVMSG		34      /* int: SysV message queue suppoprt */
#define	KERN_SYSVSEM		35      /* int: SysV semaphore support */
#define	KERN_SYSVSHM		36      /* int: SysV shared memory support */
d157 1
a157 1
#define CTL_KERN_NAMES { \
d202 1
a202 1
#define KERN_PROC_ALL		0	/* everything but kernel threads */
d209 1
a209 1
#define KERN_PROC_KTHREAD	7	/* also return kernel threads */
d238 1
a238 1
#define EMULNAMELEN	7
d280 1
a280 1
#define CTL_HW_NAMES { \
@


1.30
log
@Mark kernel threads as system processes.  Make ps hide them by default,
show them with -k.  Do not try to show RSS based values for them as they
mess up column alignment.  vmstat -f now shows kernel threads separately
from rforks too.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.29 2000/02/22 19:28:05 deraadt Exp $	*/
d128 1
a128 1
#define	KERN_CLOCKRATE		12	/* struct: struct clockrate */
@


1.29
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.28 1999/06/29 23:52:00 provos Exp $	*/
d202 1
a202 1
#define KERN_PROC_ALL		0	/* everything */
d209 1
@


1.28
log
@add sysctl kern.arandom to get a random integer. useful when chrooted with
no /dev/arandom.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.27 1998/08/16 03:22:55 millert Exp $	*/
d154 2
a155 1
#define	KERN_MAXID		38	/* number of valid kern ids */
d196 1
@


1.28.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d154 1
a154 2
#define	KERN_MSGBUFSIZE		38	/* int: size of message buffer */
#define	KERN_MAXID		39	/* number of valid kern ids */
a194 1
	{ "msgbufsize", CTLTYPE_INT }, \
@


1.28.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.35 2001/03/16 08:49:08 art Exp $	*/
d65 1
a65 1
#define	CTL_MAXNAME	12	/* largest number of components supported */
d97 1
a97 1
#define	CTL_VFS		10		/* VFS sysctl's */
d100 1
a100 1
#define	CTL_NAMES { \
d128 1
a128 1
#define	KERN_CLOCKRATE		12	/* struct: struct clockinfo */
d140 1
a140 1
#define	KERN_RAWPARTITION	24	/* int: raw partition number */
d147 6
a152 6
#define	KERN_RND		31	/* struct: rnd(4) statistics */
#define	KERN_NOSUIDCOREDUMP	32	/* int: no setuid coredumps ever */ 
#define	KERN_FSYNC		33	/* int: file synchronization support */
#define	KERN_SYSVMSG		34	/* int: SysV message queue suppoprt */
#define	KERN_SYSVSEM		35	/* int: SysV semaphore support */
#define	KERN_SYSVSHM		36	/* int: SysV shared memory support */
d155 1
a155 3
#define KERN_MALLOCSTATS	39	/* node: malloc statistics */
#define KERN_CPTIME		40	/* array: cp_time */
#define	KERN_MAXID		41	/* number of valid kern ids */
d157 1
a157 1
#define	CTL_KERN_NAMES { \
a196 2
	{ "malloc", CTLTYPE_NODE }, \
	{ "cp_time", CTLTYPE_STRUCT }, \
d202 1
a202 1
#define	KERN_PROC_ALL		0	/* everything but kernel threads */
a208 1
#define	KERN_PROC_KTHREAD	7	/* also return kernel threads */
d237 1
a237 1
#define	EMULNAMELEN	7
d279 1
a279 1
#define	CTL_HW_NAMES { \
a388 2
int sysctl_quad __P((void *, size_t *, void *, size_t, int64_t *));
int sysctl_rdquad __P((void *, size_t *, void *, int64_t));
a432 3

void sysctl_init __P((void));

@


1.28.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.28.4.2 2001/05/14 22:45:04 niklas Exp $	*/
d157 1
a157 10
#define KERN_NCHSTATS		41	/* struct: vfs cache statistics */
#define KERN_FORKSTAT		42	/* struct: fork statistics */
#define KERN_NSELCOLL		43	/* int: select(2) collisions */
#define KERN_TTY		44	/* node: tty information */
#define	KERN_CCPU		45	/* int: ccpu */
#define	KERN_FSCALE		46	/* int: fscale */
#define	KERN_NPROCS		47	/* int: number of processes */
#define	KERN_MSGBUF		48	/* message buffer, KERN_MSGBUFSIZE */
#define	KERN_POOL		49	/* struct: pool information */
#define	KERN_MAXID		50	/* number of valid kern ids */
a200 9
	{ "nchstats", CTLTYPE_STRUCT }, \
	{ "forkstat", CTLTYPE_STRUCT }, \
	{ "nselcoll", CTLTYPE_INT }, \
	{ "tty", CTLTYPE_NODE }, \
	{ "ccpu", CTLTYPE_INT }, \
	{ "fscale", CTLTYPE_INT }, \
	{ "nprocs", CTLTYPE_INT }, \
	{ "msgbuf", CTLTYPE_STRUCT }, \
	{ "pool", CTLTYPE_NODE }, \
d282 1
a282 2
#define	HW_DISKCOUNT	10		/* int: number of disks */
#define	HW_MAXID	11		/* number of valid hw ids */
d293 1
a293 1
	{ "disknames", CTLTYPE_STRING }, \
a294 1
	{ "diskcount", CTLTYPE_INT }, \
a416 1
int sysctl_dopool __P((int *, u_int, char *, size_t *));
@


1.28.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.28.4.3 2001/07/04 11:00:34 niklas Exp $	*/
d166 1
a166 3
#define	KERN_STACKGAPRANDOM	50	/* int: stackgap_random */
#define	KERN_SYSVIPC_INFO	51	/* struct: SysV sem/shm/msg info */
#define	KERN_MAXID		52	/* number of valid kern ids */
a218 2
	{ "stackgap_random", CTLTYPE_INT }, \
	{ "sysvipc_info", CTLTYPE_INT }, \
a233 7
 * KERN_SYSVIPC_INFO subtypes
 */
#define KERN_SYSVIPC_MSG_INFO	1	/* msginfo and msqid_ds */
#define KERN_SYSVIPC_SEM_INFO	2	/* seminfo and semid_ds */
#define KERN_SYSVIPC_SHM_INFO	3	/* shminfo and shmid_ds */

/*
a460 1
int sysctl_sysvipc __P((int *, u_int, void *, size_t *));
@


1.28.4.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
#include <uvm/uvm_extern.h>
@


1.28.4.6
log
@Merge in trunk
@
text
@d168 1
a168 3
#define KERN_USERCRYPTO		52	/* int: usercrypto */
#define KERN_CRYPTODEVALLOWSOFT	53	/* int: cryptodevallowsoft */
#define	KERN_MAXID		54	/* number of valid kern ids */
a222 2
	{ "usercrypto", CTLTYPE_INT }, \
	{ "cryptodevallowsoft", CTLTYPE_INT }, \
@


1.28.4.7
log
@Merge in -current from roughly a week ago
@
text
@d424 2
a425 1
typedef int (sysctlfn)(int *, u_int, void *, size_t *, void *, size_t, struct proc *);
d427 12
a438 12
int sysctl_int(void *, size_t *, void *, size_t, int *);
int sysctl_rdint(void *, size_t *, void *, int);
int sysctl_quad(void *, size_t *, void *, size_t, int64_t *);
int sysctl_rdquad(void *, size_t *, void *, int64_t);
int sysctl_string(void *, size_t *, void *, size_t, char *, int);
int sysctl_tstring(void *, size_t *, void *, size_t, char *, int);
int sysctl__string(void *, size_t *, void *, size_t, char *, int, int);
int sysctl_rdstring(void *, size_t *, void *, const char *);
int sysctl_rdstruct(void *, size_t *, void *, const void *, int);
int sysctl_struct(void *, size_t *, void *, size_t, void *, int);
int sysctl_file(char *, size_t *);
int sysctl_doproc(int *, u_int, char *, size_t *);
d441 8
a448 6
int sysctl_dumpentry(struct radix_node *, void *);
int sysctl_iflist(int, struct walkarg *);
int sysctl_rtable(int *, u_int, void *, size_t *, void *, size_t);
int sysctl_clockrate(char *, size_t *);
int sysctl_vnode(char *, size_t *, struct proc *);
int sysctl_ntptime(char *, size_t *);
d450 1
a450 1
int sysctl_doprof(int *, u_int, void *, size_t *, void *, size_t);
d452 1
a452 1
int sysctl_dopool(int *, u_int, char *, size_t *);
d454 1
a454 1
void fill_eproc(struct proc *, struct eproc *);
d456 4
a459 4
int kern_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		     struct proc *);
int hw_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *);
d461 2
a462 2
int debug_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		      struct proc *);
d464 13
a476 13
int vm_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *);
int fs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		   struct proc *);
int fs_posix_sysctl(int *, u_int, void *, size_t *, void *, size_t,
			 struct proc *);
int net_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int cpu_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int vfs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int sysctl_sysvipc(int *, u_int, void *, size_t *);
d478 1
a478 1
void sysctl_init(void);
d484 1
a484 1
int	sysctl(int *, u_int, void *, size_t *, void *, size_t);
@


1.28.4.8
log
@Sync the SMP branch with 3.3
@
text
@a51 1
#include <sys/resource.h>
a53 2
#include <sys/resourcevar.h>	/* XXX */

d141 2
a142 2
/*define gap			25	*/
/*define gap			26	*/
d170 1
a170 12
#define KERN_SPLASSERT		54	/* int: splassert */
#define KERN_PROC_ARGS		55	/* node: proc args and env */
#define	KERN_NFILES		56	/* int: number of open files */
#define	KERN_TTYCOUNT		57	/* int: number of tty devices */
#define KERN_NUMVNODES		58	/* int: number of vnodes in use */
#define	KERN_MBSTAT		59	/* struct: mbuf statistics */
#define KERN_USERASYMCRYPTO	60	/* int: usercrypto */
#define	KERN_SEMINFO		61	/* struct: SysV struct seminfo */
#define	KERN_SHMINFO		62	/* struct: SysV struct shminfo */
#define KERN_INTRCNT		63	/* node: interrupt counters */
#define	KERN_WATCHDOG		64	/* node: watchdog */
#define	KERN_MAXID		65	/* number of valid kern ids */
d198 2
a199 2
	{ "gap", 0 }, \
	{ "gap", 0 }, \
a226 11
	{ "splassert", CTLTYPE_INT }, \
	{ "procargs", CTLTYPE_NODE }, \
	{ "nfiles", CTLTYPE_INT }, \
	{ "ttycount", CTLTYPE_INT }, \
	{ "numvnodes", CTLTYPE_INT }, \
	{ "mbstat", CTLTYPE_STRUCT }, \
	{ "userasymcrypto", CTLTYPE_INT }, \
	{ "seminfo", CTLTYPE_STRUCT }, \
	{ "shminfo", CTLTYPE_STRUCT }, \
	{ "intrcnt", CTLTYPE_NODE }, \
 	{ "watchdog", CTLTYPE_NODE }, \
a248 8
 * KERN_PROC_ARGS subtypes
 */
#define KERN_PROC_ARGV		1
#define KERN_PROC_NARGV		2
#define KERN_PROC_ENV		3
#define KERN_PROC_NENV		4

/*
a258 2
		struct  pstats e_pstats;	/* process stats */
		int	e_pstats_valid;		/* pstats valid? */
a281 28
 * KERN_INTR_CNT
 */
#define KERN_INTRCNT_NUM	1	/* int: # intrcnt */
#define KERN_INTRCNT_CNT	2	/* node: intrcnt */
#define KERN_INTRCNT_NAME	3	/* node: names */
#define KERN_INTRCNT_MAXID	4

#define CTL_KERN_INTRCNT_NAMES { \
	{ 0, 0 }, \
	{ "nintrcnt", CTLTYPE_INT }, \
	{ "intrcnt", CTLTYPE_NODE }, \
	{ "intrname", CTLTYPE_NODE }, \
}

/*
 * KERN_WATCHDOG
 */
#define KERN_WATCHDOG_PERIOD	1	/* int: watchdog period */
#define KERN_WATCHDOG_AUTO	2	/* int: automatic tickle */
#define KERN_WATCHDOG_MAXID	3

#define CTL_KERN_WATCHDOG_NAMES { \
	{ 0, 0 }, \
	{ "period", CTLTYPE_INT }, \
	{ "auto", CTLTYPE_INT }, \
}

/*
d445 1
a473 1
int sysctl_wdog(int *, u_int, void *, size_t *, void *, size_t);
@


1.28.4.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.28.4.8 2003/03/28 00:41:30 niklas Exp $	*/
d379 1
a379 2
#define	HW_SENSORS	11		/* node: hardware monitors */
#define	HW_MAXID	12		/* number of valid hw ids */
a392 1
	{ "sensors", CTLTYPE_NODE}, \
@


1.28.4.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.28.4.9 2003/05/13 19:36:57 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.28.4.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d180 1
a180 3
#define	KERN_EMUL		65	/* node: emuls */
#define	KERN_PROC2		66	/* struct: process entries */
#define	KERN_MAXID		67	/* number of valid kern ids */
a247 2
 	{ "emul", CTLTYPE_NODE }, \
 	{ "proc2", CTLTYPE_STRUCT }, \
a250 9
 * KERN_EMUL subtypes.
 */
#define	KERN_EMUL_NUM		0
/* Fourth level sysctl names */
#define KERN_EMUL_NAME		0
#define KERN_EMUL_ENABLED	1


/*
a312 126
 * KERN_PROC2 subtype ops return arrays of relatively fixed size
 * structures of process info.   Use 8 byte alignment, and new
 * elements should only be added to the end of this structure so
 * binary compatibility can be preserved.
 */
#define	KI_NGROUPS	16
#define	KI_MAXCOMLEN	24	/* extra for 8 byte alignment */
#define	KI_WMESGLEN	8
#define	KI_MAXLOGNAME	32
#define	KI_EMULNAMELEN	8

struct kinfo_proc2 {
	u_int64_t p_forw;		/* PTR: linked run/sleep queue. */
	u_int64_t p_back;
	u_int64_t p_paddr;		/* PTR: address of proc */

	u_int64_t p_addr;		/* PTR: Kernel virtual addr of u-area */
	u_int64_t p_fd;			/* PTR: Ptr to open files structure. */
	u_int64_t p_stats;		/* PTR: Accounting/statistics */
	u_int64_t p_limit;		/* PTR: Process limits. */
	u_int64_t p_vmspace;		/* PTR: Address space. */
	u_int64_t p_sigacts;		/* PTR: Signal actions, state */
	u_int64_t p_sess;		/* PTR: session pointer */
	u_int64_t p_tsess;		/* PTR: tty session pointer */
	u_int64_t p_ru;			/* PTR: Exit information. XXX */

	int32_t	p_eflag;		/* LONG: extra kinfo_proc2 flags */
	int32_t	p_exitsig;		/* INT: signal to sent to parent on exit */
	int32_t	p_flag;			/* INT: P_* flags. */

	int32_t	p_pid;			/* PID_T: Process identifier. */
	int32_t	p_ppid;			/* PID_T: Parent process id */
	int32_t	p_sid;			/* PID_T: session id */
	int32_t	p__pgid;		/* PID_T: process group id */
					/* XXX: <sys/proc.h> hijacks p_pgid */
	int32_t	p_tpgid;		/* PID_T: tty process group id */

	u_int32_t p_uid;		/* UID_T: effective user id */
	u_int32_t p_ruid;		/* UID_T: real user id */
	u_int32_t p_gid;		/* GID_T: effective group id */
	u_int32_t p_rgid;		/* GID_T: real group id */

	u_int32_t p_groups[KI_NGROUPS];	/* GID_T: groups */
	int16_t	p_ngroups;		/* SHORT: number of groups */

	int16_t	p_jobc;			/* SHORT: job control counter */
	u_int32_t p_tdev;		/* DEV_T: controlling tty dev */

	u_int32_t p_estcpu;		/* U_INT: Time averaged value of p_cpticks. */
	u_int32_t p_rtime_sec;		/* STRUCT TIMEVAL: Real time. */
	u_int32_t p_rtime_usec;		/* STRUCT TIMEVAL: Real time. */
	int32_t	p_cpticks;		/* INT: Ticks of cpu time. */
	u_int32_t p_pctcpu;		/* FIXPT_T: %cpu for this process during p_swtime */
	u_int32_t p_swtime;		/* U_INT: Time swapped in or out. */
	u_int32_t p_slptime;		/* U_INT: Time since last blocked. */
	int32_t	p_schedflags;		/* INT: PSCHED_* flags */

	u_int64_t p_uticks;		/* U_QUAD_T: Statclock hits in user mode. */
	u_int64_t p_sticks;		/* U_QUAD_T: Statclock hits in system mode. */
	u_int64_t p_iticks;		/* U_QUAD_T: Statclock hits processing intr. */

	u_int64_t p_tracep;		/* PTR: Trace to vnode or file */
	int32_t	p_traceflag;		/* INT: Kernel trace points. */

	int32_t p_holdcnt;		/* INT: If non-zero, don't swap. */

	int32_t p_siglist;		/* INT: Signals arrived but not delivered. */
	u_int32_t p_sigmask;		/* SIGSET_T: Current signal mask. */
	u_int32_t p_sigignore;		/* SIGSET_T: Signals being ignored. */
	u_int32_t p_sigcatch;		/* SIGSET_T: Signals being caught by user. */

	int8_t	p_stat;			/* CHAR: S* process status (from LWP). */
	u_int8_t p_priority;		/* U_CHAR: Process priority. */
	u_int8_t p_usrpri;		/* U_CHAR: User-priority based on p_cpu and p_nice. */
	u_int8_t p_nice;		/* U_CHAR: Process "nice" value. */

	u_int16_t p_xstat;		/* U_SHORT: Exit status for wait; also stop signal. */
	u_int16_t p_acflag;		/* U_SHORT: Accounting flags. */

	char	p_comm[KI_MAXCOMLEN];

	char	p_wmesg[KI_WMESGLEN];	/* wchan message */
	u_int64_t p_wchan;		/* PTR: sleep address. */

	char	p_login[KI_MAXLOGNAME];	/* setlogin() name */

	int32_t	p_vm_rssize;		/* SEGSZ_T: current resident set size in pages */
	int32_t	p_vm_tsize;		/* SEGSZ_T: text size (pages) */
	int32_t	p_vm_dsize;		/* SEGSZ_T: data size (pages) */
	int32_t	p_vm_ssize;		/* SEGSZ_T: stack size (pages) */

	int64_t	p_uvalid;		/* CHAR: following p_u* members from struct user are valid */
					/* XXX 64 bits for alignment */
	u_int32_t p_ustart_sec;		/* STRUCT TIMEVAL: starting time. */
	u_int32_t p_ustart_usec;	/* STRUCT TIMEVAL: starting time. */

	u_int32_t p_uutime_sec;		/* STRUCT TIMEVAL: user time. */
	u_int32_t p_uutime_usec;	/* STRUCT TIMEVAL: user time. */
	u_int32_t p_ustime_sec;		/* STRUCT TIMEVAL: system time. */
	u_int32_t p_ustime_usec;	/* STRUCT TIMEVAL: system time. */

	u_int64_t p_uru_maxrss;		/* LONG: max resident set size. */
	u_int64_t p_uru_ixrss;		/* LONG: integral shared memory size. */
	u_int64_t p_uru_idrss;		/* LONG: integral unshared data ". */
	u_int64_t p_uru_isrss;		/* LONG: integral unshared stack ". */
	u_int64_t p_uru_minflt;		/* LONG: page reclaims. */
	u_int64_t p_uru_majflt;		/* LONG: page faults. */
	u_int64_t p_uru_nswap;		/* LONG: swaps. */
	u_int64_t p_uru_inblock;	/* LONG: block input operations. */
	u_int64_t p_uru_oublock;	/* LONG: block output operations. */
	u_int64_t p_uru_msgsnd;		/* LONG: messages sent. */
	u_int64_t p_uru_msgrcv;		/* LONG: messages received. */
	u_int64_t p_uru_nsignals;	/* LONG: signals received. */
	u_int64_t p_uru_nvcsw;		/* LONG: voluntary context switches. */
	u_int64_t p_uru_nivcsw;		/* LONG: involuntary ". */

	u_int32_t p_uctime_sec;		/* STRUCT TIMEVAL: child u+s time. */
	u_int32_t p_uctime_usec;	/* STRUCT TIMEVAL: child u+s time. */
	u_int64_t p_realflag;		/* INT: P_* flags (not including LWPs). */
	u_int32_t p_svuid;		/* UID_T: saved user id */
	u_int32_t p_svgid;		/* GID_T: saved group id */
	char    p_emul[KI_EMULNAMELEN];	/* syscall emulation name */
	u_int64_t p_rlim_rss_cur;	/* RLIM_T: soft limit for rss */
};

/*
d376 1
a376 3
#define	HW_CPUSPEED	12		/* get CPU frequency */
#define	HW_SETPERF	13		/* set CPU performance % */
#define	HW_MAXID	14		/* number of valid hw ids */
a390 2
	{ "cpuspeed", CTLTYPE_INT }, \
	{ "setperf", CTLTYPE_INT }, \
a511 1
void fill_kproc2(struct proc *, struct kinfo_proc2 *);
a534 3

extern int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
extern int (*cpu_setperf)(void *, size_t *, void *, size_t);
@


1.28.4.12
log
@Some merged code from NetBSD, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.28.4.11 2004/02/19 11:01:34 niklas Exp $	*/
a336 2
#define KI_NOCPU	(~(u_int64_t)0)

a448 1
	u_int64_t p_cpuid;		/* LONG: CPU id */
@


1.28.4.13
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.28.4.12 2004/03/14 22:08:21 niklas Exp $	*/
a382 3
#ifdef MULTIPROCESSOR
	int32_t	__p_free1;		/* INT: Unused slot */
#else
a383 1
#endif
@


1.28.4.14
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d182 1
a182 2
#define	KERN_MAXCLUSTERS	67	/* number of mclusters */
#define	KERN_MAXID		68	/* number of valid kern ids */
a251 1
 	{ "maxclusters", CTLTYPE_INT }, \
a638 1
int sysctl_int_arr(int **, int *, u_int, void *, size_t *, void *, size_t);
d687 2
a688 4
extern int (*cpu_cpuspeed)(int *);
extern int (*cpu_setperf)(int);

int bpf_sysctl(int *, u_int, void *, size_t *, void *, size_t);
@


1.28.4.15
log
@do not put kernel-only #ifdefs in user-exposed structs!
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.28.4.14 2004/06/05 23:13:10 niklas Exp $	*/
d385 3
d389 1
@


1.27
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.26 1998/07/07 07:12:51 deraadt Exp $	*/
d153 2
a154 1
#define	KERN_MAXID		37	/* number of valid kern ids */
d194 1
@


1.26
log
@per XPG, gethostname() with a short buffer returns truncated data - not ENOMEM.
As permitted, make the truncated buffer be NUL terminated.
make getdomainname() match.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.25 1998/06/02 06:10:30 deraadt Exp $	*/
d96 1
a96 1
#define	CTL_DDB		9		/* DDB user interface, see ddb_var.h */
@


1.25
log
@add sysctl and sysconf support for sysvsem, sysvshm, sysvmsg, and fsync; mostly from kleink
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.24 1998/03/15 17:20:34 millert Exp $	*/
d386 2
@


1.24
log
@Update Berkeley sccsid since this includes the lite2 changes
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.23 1997/12/08 21:25:34 deraadt Exp $	*/
d149 5
a153 1
#define	KERN_MAXID		33	/* number of valid kern ids */
d189 4
@


1.23
log
@add kern.nosuidcoredump to lock things out even more
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.22 1997/11/06 15:59:52 kstailey Exp $	*/
d39 1
a39 1
 *	@@(#)sysctl.h	8.1 (Berkeley) 6/2/93
@


1.22
log
@fix ps(1) LIM column
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.21 1997/11/06 05:59:11 csapuntz Exp $	*/
d148 2
a149 1
#define	KERN_MAXID		32	/* number of valid kern ids */
d184 1
@


1.21
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.20 1997/10/06 20:21:11 deraadt Exp $	*/
d225 1
a225 1
		u_int32_t e_spare[2]; /* XXX remove prior to release */
@


1.20
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.18 1997/09/08 17:28:18 kstailey Exp $	*/
d52 2
a54 1
#endif
d97 2
a98 1
#define	CTL_MAXID	10		/* number of valid top-level ids */
d111 1
d389 1
a389 1
int sysctl_vnode __P((char *, size_t *));
d414 2
@


1.19
log
@VFS Lite2 Changes
@
text
@d52 1
a54 2
#include <vm/vm.h>

d96 1
a96 2
#define CTL_VFS         10              /* VFS sysctl's */
#define	CTL_MAXID	11		/* number of valid top-level ids */
a108 1
	{ "vfs", CTLTYPE_NODE }, \
d386 1
a386 1
int sysctl_vnode __P((char *, size_t *, struct proc *));
a410 2
		    struct proc *));
int vfs_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
@


1.18
log
@unbreak kvm for 32-bit machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.17 1997/09/05 19:23:25 kstailey Exp $	*/
d52 2
a54 1
#endif
d97 2
a98 1
#define	CTL_MAXID	10		/* number of valid top-level ids */
d111 1
d389 1
a389 1
int sysctl_vnode __P((char *, size_t *));
d414 2
@


1.17
log
@nuke e_spare.  It never bought us any usable compatibility and costs storage.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.16 1997/09/05 18:46:29 kstailey Exp $	*/
d222 1
@


1.16
log
@change e_spare back to a long.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.15 1997/09/03 13:51:09 kstailey Exp $	*/
a221 1
		long	e_spare[2];
@


1.15
log
@changes for ps "emul" option
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.14 1997/06/22 04:58:04 flipk Exp $	*/
d222 1
a222 1
		int32_t	e_spare[2];
@


1.14
log
@wasn't a race after all. properly initialize event_q pointers so the
last one doesn't point off the end.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.12 1997/06/14 21:37:10 mickey Exp $	*/
d220 3
a222 1
		long	e_spare[4];
@


1.13
log
@revert, there's a nasty race condition here.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.11 1996/10/04 01:26:45 deraadt Exp $	*/
d144 2
a145 1
#define	KERN_MAXID		31	/* number of valid kern ids */
d179 1
@


1.12
log
@split the treatment of the random events
event_q by flipk@@
spl fix by deraadt@@
gother statistics about whole processing
use 'sysctl kern.random' to view what had happened
also fix wrong vm.psstrings description
@
text
@d144 1
a144 2
#define KERN_RND		31	/* struct: rnd(4) statistics */
#define	KERN_MAXID		32	/* number of valid kern ids */
a177 1
	{ "random", CTLTYPE_STRUCT }, \
@


1.11
log
@usermount sysctl, default to prevent users from using mount syscall
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.10 1996/09/20 22:53:05 deraadt Exp $	*/
d144 2
a145 1
#define	KERN_MAXID		31	/* number of valid kern ids */
d179 1
@


1.10
log
@`solve' the syn bomb problem as well as currently known; add sysctl's for
SOMAXCONN (kern.somaxconn), SOMINCONN (kern.sominconn), and TCPTV_KEEP_INIT
(net.inet.tcp.keepinittime). when this is not enough (ie. overfull), start
doing tail drop, but slightly prefer the same port.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.9 1996/08/11 20:35:12 niklas Exp $	*/
d143 2
a144 1
#define	KERN_MAXID		30	/* number of valid kern ids */
d177 1
@


1.9
log
@Add fs_posix_sysctl prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.8 1996/08/08 06:36:48 tholo Exp $	*/
d141 3
a143 1
#define	KERN_MAXID		28	/* number of valid kern ids */
d174 2
@


1.8
log
@Make {,f}chown(2) behaviour POSIX.1 compliant with SUID / SGID files
Enable CTL_FS processing by sysctl(3)
Add CTL_FS request to disable clearing SUID / SGID bit when a files owner
or group is changed by root
Make sysctl(8) understand CTL_FS requests
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.7 1996/06/29 21:06:43 tholo Exp $	*/
d396 2
@


1.7
log
@Move new KERN_OSVERSION sysctl request so binary compatibility with NetBSD
is preserved
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.6 1996/06/29 21:02:52 tholo Exp $	*/
d215 22
@


1.6
log
@Make uname(1) and uname(3) do sane things for the version field; now will
show only "KERNEL#build".
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.h,v 1.4 1996/04/18 21:41:13 niklas Exp $	*/
d117 24
a140 24
#define	KERN_OSVERSION		 4	/* string: kernel build version */
#define	KERN_VERSION	 	 5	/* string: compile time info */
#define	KERN_MAXVNODES	 	 6	/* int: max vnodes */
#define	KERN_MAXPROC	 	 7	/* int: max processes */
#define	KERN_MAXFILES	 	 8	/* int: max open files */
#define	KERN_ARGMAX	 	 9	/* int: max arguments to exec */
#define	KERN_SECURELVL	 	10	/* int: system security level */
#define	KERN_HOSTNAME		11	/* string: hostname */
#define	KERN_HOSTID		12	/* int: host identifier */
#define	KERN_CLOCKRATE		13	/* struct: struct clockrate */
#define	KERN_VNODE		14	/* struct: vnode structures */
#define	KERN_PROC		15	/* struct: process entries */
#define	KERN_FILE		16	/* struct: file entries */
#define	KERN_PROF		17	/* node: kernel profiling info */
#define	KERN_POSIX1		18	/* int: POSIX.1 version */
#define	KERN_NGROUPS		19	/* int: # of supplemental group ids */
#define	KERN_JOB_CONTROL	20	/* int: is job control available */
#define	KERN_SAVED_IDS		21	/* int: saved set-user/group-ID */
#define	KERN_BOOTTIME		22	/* struct: time kernel was booted */
#define	KERN_DOMAINNAME		23	/* string: (YP) domainname */
#define	KERN_MAXPARTITIONS	24	/* int: number of partitions/disk */
#define KERN_RAWPARTITION	25	/* int: raw partition number */
#define	KERN_NTPTIME		26	/* struct: extended-precision time */
#define	KERN_TIMEX		27	/* struct: ntp timekeeping state */
a147 1
	{ "osversion", CTLTYPE_STRING }, \
d171 1
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d117 25
a141 24
#define	KERN_VERSION	 	 4	/* string: compile time info */
#define	KERN_MAXVNODES	 	 5	/* int: max vnodes */
#define	KERN_MAXPROC	 	 6	/* int: max processes */
#define	KERN_MAXFILES	 	 7	/* int: max open files */
#define	KERN_ARGMAX	 	 8	/* int: max arguments to exec */
#define	KERN_SECURELVL	 	 9	/* int: system security level */
#define	KERN_HOSTNAME		10	/* string: hostname */
#define	KERN_HOSTID		11	/* int: host identifier */
#define	KERN_CLOCKRATE		12	/* struct: struct clockrate */
#define	KERN_VNODE		13	/* struct: vnode structures */
#define	KERN_PROC		14	/* struct: process entries */
#define	KERN_FILE		15	/* struct: file entries */
#define	KERN_PROF		16	/* node: kernel profiling info */
#define	KERN_POSIX1		17	/* int: POSIX.1 version */
#define	KERN_NGROUPS		18	/* int: # of supplemental group ids */
#define	KERN_JOB_CONTROL	19	/* int: is job control available */
#define	KERN_SAVED_IDS		20	/* int: saved set-user/group-ID */
#define	KERN_BOOTTIME		21	/* struct: time kernel was booted */
#define	KERN_DOMAINNAME		22	/* string: (YP) domainname */
#define	KERN_MAXPARTITIONS	23	/* int: number of partitions/disk */
#define KERN_RAWPARTITION	24	/* int: raw partition number */
#define	KERN_NTPTIME		25	/* struct: extended-precision time */
#define	KERN_TIMEX		26	/* struct: ntp timekeeping state */
#define	KERN_MAXID		27	/* number of valid kern ids */
d148 1
@


1.4
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: sysctl.h,v 1.3 1996/03/30 04:51:33 mickey Exp $	*/
/*	$NetBSD: sysctl.h,v 1.14 1996/03/12 00:22:43 jonathan Exp $	*/
d68 1
a68 1
 * for that subsystem. Each name is either a node with further 
d172 1
a172 1
/* 
d183 1
a183 1
/* 
d354 3
a375 1

@


1.3
log
@Added: sysctl access to the ddb variables.
Fixed: "netbsd" strings in sym table handling routines.
now it is usefull to change max_{width,line} according
to your real console geometry, just w/ sysctl program.
@
text
@d1 2
a2 2
/*	$OpenBSD: sysctl.h,v 1.2 1996/03/03 12:12:22 niklas Exp $	*/
/*	$NetBSD: sysctl.h,v 1.11 1996/02/09 18:25:39 christos Exp $	*/
d138 3
a140 1
#define	KERN_MAXID		25	/* number of valid kern ids */
d168 2
d353 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 2
a96 1
#define	CTL_MAXID	9		/* number of valid top-level ids */
d108 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: sysctl.h,v 1.9 1995/08/04 18:36:08 thorpej Exp $	*/
d335 13
d349 17
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

