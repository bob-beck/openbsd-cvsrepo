head	1.34;
access;
symbols
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.6
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.23.0.12
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.10
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.8
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.6
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.6
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.34
date	2016.09.14.15.09.46;	author millert;	state Exp;
branches;
next	1.33;
commitid	N74U6xf3DWS7oXfc;

1.33
date	2016.07.13.21.32.01;	author millert;	state Exp;
branches;
next	1.32;
commitid	6hGDjK9d49iDQAD0;

1.32
date	2015.12.08.19.04.50;	author mmcc;	state Exp;
branches;
next	1.31;
commitid	ckwpUKLIIVPtpryy;

1.31
date	2015.12.07.18.46.35;	author espie;	state Exp;
branches;
next	1.30;
commitid	IuVQXdcoW2Zw8wMf;

1.30
date	2015.10.23.11.43.16;	author zhuk;	state Exp;
branches;
next	1.29;
commitid	8WPctGg8P39mEwQm;

1.29
date	2015.03.17.19.31.30;	author millert;	state Exp;
branches;
next	1.28;
commitid	0y5bUkEOUrNvvJEO;

1.28
date	2015.03.15.00.41.28;	author millert;	state Exp;
branches;
next	1.27;
commitid	IbVxlqGw2UipKdDr;

1.27
date	2013.11.26.13.18.53;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2013.11.12.19.35.47;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.16.18.28.24;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.02.04.40.21;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.28.18.20.15;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.16.16.45.11;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.09.12.32.58;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.10.20.47.30;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.10.15.31.01;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.10.15.00.27;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.02.56.06;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.27.18.19.20;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.26.20.38.55;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.05.21.27.16;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	99.11.25.03.46.46;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	99.04.25.01.16.04;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	99.03.04.03.34.35;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	98.12.13.07.31.07;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.11.08.04.31.13;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.11.04.11.32.02;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	98.03.30.06.59.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.02.23.05.48.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.08.26.23.37.21;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.12.05.06.04.39;	author millert;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Fix bug introduced in the fix for days outside the target month.
From Andy Bradford
@
text
@/*	$OpenBSD: day.c,v 1.33 2016/07/13 21:32:01 millert Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/uio.h>

#include <ctype.h>
#include <err.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "pathnames.h"
#include "calendar.h"

extern struct iovec header[];

#define WEEKLY 1
#define MONTHLY 2
#define YEARLY 3

struct tm *tp;
int *cumdays, offset;
char dayname[10];
enum calendars calendar;
u_long julian;


/* 1-based month, 0-based days, cumulative */
int daytab[][14] = {
	{ 0, -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364 },
	{ 0, -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
};

static char *days[] = {
	"sun", "mon", "tue", "wed", "thu", "fri", "sat", NULL,
};

static char *months[] = {
	"jan", "feb", "mar", "apr", "may", "jun",
	"jul", "aug", "sep", "oct", "nov", "dec", NULL,
};

static struct fixs fndays[8];         /* full national days names */
static struct fixs ndays[8];          /* short national days names */

static struct fixs fnmonths[13];      /* full national months names */
static struct fixs nmonths[13];       /* short national month names */

void
fill_print_date(struct match *m, struct tm *tm)
{
	if (strftime(m->print_date, sizeof(m->print_date),
	    daynames ? "%a %b %d" : "%b %d", tm) == 0)
		m->print_date[sizeof(m->print_date) - 1] = '\0';
}

void
setnnames(void)
{
	char buf[80];
	int i, l;
	struct tm tm;

	for (i = 0; i < 7; i++) {
		tm.tm_wday = i;
		l = strftime(buf, sizeof(buf), "%a", &tm);
		for (; l > 0 && isspace((unsigned char)buf[l - 1]); l--)
			;
		buf[l] = '\0';
		free(ndays[i].name);
		if ((ndays[i].name = strdup(buf)) == NULL)
			err(1, NULL);
		ndays[i].len = strlen(buf);

		l = strftime(buf, sizeof(buf), "%A", &tm);
		for (; l > 0 && isspace((unsigned char)buf[l - 1]); l--)
			;
		buf[l] = '\0';
		free(fndays[i].name);
		if ((fndays[i].name = strdup(buf)) == NULL)
			err(1, NULL);
		fndays[i].len = strlen(buf);
	}

	for (i = 0; i < 12; i++) {
		tm.tm_mon = i;
		l = strftime(buf, sizeof(buf), "%b", &tm);
		for (; l > 0 && isspace((unsigned char)buf[l - 1]); l--)
			;
		buf[l] = '\0';
		free(nmonths[i].name);
		if ((nmonths[i].name = strdup(buf)) == NULL)
			err(1, NULL);
		nmonths[i].len = strlen(buf);

		l = strftime(buf, sizeof(buf), "%B", &tm);
		for (; l > 0 && isspace((unsigned char)buf[l - 1]); l--)
			;
		buf[l] = '\0';
		free(fnmonths[i].name);
		if ((fnmonths[i].name = strdup(buf)) == NULL)
			err(1, NULL);
		fnmonths[i].len = strlen(buf);
	}
	/* Hardwired special events */
	spev[0].name = strdup(PESACH);
	spev[0].nlen = PESACHLEN;
	spev[0].getev = pesach;
	spev[1].name = strdup(EASTER);
	spev[1].nlen = EASTERNAMELEN;
	spev[1].getev = easter;
	spev[2].name = strdup(PASKHA);
	spev[2].nlen = PASKHALEN;
	spev[2].getev = paskha;
	for (i = 0; i < NUMEV; i++) {
		if (spev[i].name == NULL)
			err(1, NULL);
		spev[i].uname = NULL;
	}
}

void
settime(time_t *now)
{
	tp = localtime(now);
	tp->tm_sec = 0;
	tp->tm_min = 0;
	/* Avoid getting caught by a timezone shift; set time to noon */
	tp->tm_isdst = 0;
	tp->tm_hour = 12;
	*now = mktime(tp);
	if (isleap(tp->tm_year + 1900))
		cumdays = daytab[1];
	else
		cumdays = daytab[0];
	/* Friday displays Monday's events */
	offset = tp->tm_wday == 5 ? 3 : 1;
	if (f_SetdayAfter)
		offset = 0;	/* Except not when range is set explicitly */
	header[5].iov_base = dayname;

	(void) setlocale(LC_TIME, "C");
	header[5].iov_len = strftime(dayname, sizeof(dayname), "%A", tp);
	(void) setlocale(LC_TIME, "");

	setnnames();
}

/* convert [Year][Month]Day into unix time (since 1970)
 * Year: two or four digits, Month: two digits, Day: two digits
 */
time_t
Mktime(char *date)
{
	time_t t;
	int len;
	struct tm tm;

	(void)time(&t);
	tp = localtime(&t);

	len = strlen(date);
	if (len < 2)
		return((time_t)-1);
	bzero(&tm, sizeof tm);
	tm.tm_sec = 0;
	tm.tm_min = 0;
	/* Avoid getting caught by a timezone shift; set time to noon */
	tm.tm_isdst = 0;
	tm.tm_hour = 12;
	tm.tm_wday = 0;
	tm.tm_mday = tp->tm_mday;
	tm.tm_mon = tp->tm_mon;
	tm.tm_year = tp->tm_year;

	/* Day */
	tm.tm_mday = atoi(date + len - 2);

	/* Month */
	if (len >= 4) {
		*(date + len - 2) = '\0';
		tm.tm_mon = atoi(date + len - 4) - 1;
	}

	/* Year */
	if (len >= 6) {
		*(date + len - 4) = '\0';
		tm.tm_year = atoi(date);

		if (tm.tm_year < 69)		/* Y2K */
			tm.tm_year += 100;
		else if (tm.tm_year > 1900)
			tm.tm_year -= 1900;
	}

#if DEBUG
	printf("Mktime: %d %lld %d %s\n", (int)mktime(&tm), (long long)t, len,
	    asctime(&tm));
#endif
	return(mktime(&tm));
}

static void
adjust_calendar(int *day, int *month)
{
	switch (calendar) {
	case GREGORIAN:
		break;

	case JULIAN:
		*day += julian;
		if (*day > (cumdays[*month + 1] - cumdays[*month])) {
			*day -= (cumdays[*month + 1] - cumdays[*month]);
			if (++*month > 12)
				*month = 1;
		}
		break;
	case LUNAR:
		break;
	}
}

/*
 * Possible date formats include any combination of:
 *	3-charmonth			(January, Jan, Jan)
 *	3-charweekday			(Friday, Monday, mon.)
 *	numeric month or day		(1, 2, 04)
 *
 * Any character except \t or '*' may separate them, or they may not be
 * separated.  Any line following a line that is matched, that starts
 * with \t, is shown along with the matched line.
 */
struct match *
isnow(char *endp, int bodun)
{
	int day = 0, flags = 0, month = 0, v1, v2, i;
	int monthp, dayp, varp = 0;
	struct match *matches = NULL, *tmp, *tmp2;
	int interval = YEARLY;	/* how frequently the event repeats. */
	int vwd = 0;	/* Variable weekday */
	time_t tdiff, ttmp;
	struct tm tmtmp;

	/*
	 * CONVENTION
	 *
	 * Month:     1-12
	 * Monthname: Jan .. Dec
	 * Day:       1-31
	 * Weekday:   Mon-Sun
	 *
	 */

	/* read first field */
	/* didn't recognize anything, skip it */
	if (!(v1 = getfield(endp, &endp, &flags)))
		return (NULL);

	/* adjust bodun rate */
	if (bodun && !bodun_always)
		bodun = !arc4random_uniform(3);

	/* Easter or Easter depending days */
	if (flags & F_SPECIAL)
		vwd = v1;

	 /*
	  * 1. {Weekday,Day} XYZ ...
	  *
	  *    where Day is > 12
	  */
	else if (flags & F_ISDAY || v1 > 12) {

		/* found a day; day: 13-31 or weekday: 1-7 */
		day = v1;

		/* {Day,Weekday} {Month,Monthname} ... */
		/* if no recognizable month, assume just a day alone -- this is
		 * very unlikely and can only happen after the first 12 days.
		 * --find month or use current month */
		if (!(month = getfield(endp, &endp, &flags))) {
			month = tp->tm_mon + 1;
			/* F_ISDAY is set only if a weekday was spelled out */
			/* F_ISDAY must be set if 0 < day < 8 */
			if ((day <= 7) && (day >= 1))
				interval = WEEKLY;
			else
				interval = MONTHLY;
		} else if ((day <= 7) && (day >= 1))
			day += 10;
			/* it's a weekday; make it the first one of the month */
		if (month == -1) {
			month = tp->tm_mon + 1;
			interval = MONTHLY;
		} else if (calendar)
			adjust_calendar(&day, &month);
		if ((month > 12) || (month < 1))
			return (NULL);
	}

	/* 2. {Monthname} XYZ ... */
	else if (flags & F_ISMONTH) {
		month = v1;
		if (month == -1) {
			month = tp->tm_mon + 1;
			interval = MONTHLY;
		}
		/* Monthname {day,weekday} */
		/* if no recognizable day, assume the first day in month */
		if (!(day = getfield(endp, &endp, &flags)))
			day = 1;
		/* If a weekday was spelled out without an ordering,
		 * assume the first of that day in the month */
		if ((flags & F_ISDAY)) {
			if ((day >= 1) && (day <=7))
				day += 10;
		} else if (calendar)
			adjust_calendar(&day, &month);
	}

	/* Hm ... */
	else {
		v2 = getfield(endp, &endp, &flags);

		/*
		 * {Day} {Monthname} ...
		 * where Day <= 12
		 */
		if (flags & F_ISMONTH) {
			day = v1;
			month = v2;
			if (month == -1) {
				month = tp->tm_mon + 1;
				interval = MONTHLY;
			} else if (calendar)
				adjust_calendar(&day, &month);
		}

		/* {Month} {Weekday,Day} ...  */
		else {
			/* F_ISDAY set, v2 > 12, or no way to tell */
			month = v1;
			/* if no recognizable day, assume the first */
			day = v2 ? v2 : 1;
			if ((flags & F_ISDAY)) {
				if ((day >= 1) && (day <= 7))
					day += 10;
			} else
				adjust_calendar(&day, &month);
		}
	}

	/* convert Weekday into *next*  Day,
	 * e.g.: 'Sunday' -> 22
	 *       'SundayLast' -> ??
	 */
	if (flags & F_ISDAY) {
#if DEBUG
		fprintf(stderr, "\nday: %d %s month %d\n", day, endp, month);
#endif

		varp = 1;
		/* variable weekday, SundayLast, MondayFirst ... */
		if (day < 0 || day >= 10)
			vwd = day;
		else {
			day = tp->tm_mday + (((day - 1) - tp->tm_wday + 7) % 7);
			interval = WEEKLY;
		}
	} else
	/* Check for silliness.  Note we still catch Feb 29 */
		if (!(flags & F_SPECIAL) &&
		    (day > (cumdays[month + 1] - cumdays[month]) || day < 1)) {
			if (!((month == 2 && day == 29) ||
			    (interval == MONTHLY && day <= 31)))
				return (NULL);
		}

	if (!(flags & F_SPECIAL)) {
		monthp = month;
		dayp = day;
		day = cumdays[month] + day;
#if DEBUG
		fprintf(stderr, "day2: day %d(%d) yday %d\n", dayp, day, tp->tm_yday);
#endif
	/* Speed up processing for the most common situation:  yearly events
	 * when the interval being checked is less than a month or so (this
	 * could be less than a year, but then we have to start worrying about
	 * leap years).  Only one event can match, and it's easy to find.
	 * Note we can't check special events, because they can wander widely.
	 */
		if (((v1 = offset + f_dayAfter) < 50) && (interval == YEARLY)) {
			memcpy(&tmtmp, tp, sizeof(struct tm));
			tmtmp.tm_mday = dayp;
			tmtmp.tm_mon = monthp - 1;
			if (vwd) {
			/* We want the event next year if it's late now
			 * this year.  The 50-day limit means we don't have to
			 * worry if next year is or isn't a leap year.
			 */
				if (tp->tm_yday > 300 && tmtmp.tm_mon <= 1)
					variable_weekday(&vwd, tmtmp.tm_mon + 1,
					    tmtmp.tm_year + 1900 + 1);
				else
					variable_weekday(&vwd, tmtmp.tm_mon + 1,
					    tmtmp.tm_year + 1900);
				day = cumdays[tmtmp.tm_mon + 1] + vwd;
				tmtmp.tm_mday = vwd;
			}
			v2 = day - tp->tm_yday;
			if ((v2 > v1) || (v2 < 0)) {
				if ((v2 += isleap(tp->tm_year + 1900) ? 366 : 365)
				    <= v1)
					tmtmp.tm_year++;
				else if(!bodun || (day - tp->tm_yday) != -1)
					return(NULL);
			}
			if ((tmp = malloc(sizeof(struct match))) == NULL)
				err(1, NULL);

			if (bodun && (day - tp->tm_yday) == -1) {
				tmp->when = f_time - 1 * SECSPERDAY;
				tmtmp.tm_mday++;
				tmp->bodun = 1;
			} else {
				tmp->when = f_time + v2 * SECSPERDAY;
				tmp->bodun = 0;
			}

			(void)mktime(&tmtmp);
			fill_print_date(tmp, &tmtmp);
			tmp->var   = varp;
			tmp->next  = NULL;
			return(tmp);
		}
	} else {
		varp = 1;
		/* Set up v1 to the event number and ... */
		v1 = vwd % (NUMEV + 1) - 1;
		vwd /= (NUMEV + 1);
		if (v1 < 0) {
			v1 += NUMEV + 1;
			vwd--;
		}
		dayp = monthp = 1;	/* Why not */
	}

	/* Compare to past and coming instances of the event.  The i == 0 part
	 * of the loop corresponds to this specific instance.  Note that we
	 * can leave things sort of higgledy-piggledy since a mktime() happens
	 * on this before anything gets printed.  Also note that even though
	 * we've effectively gotten rid of f_dayBefore, we still have to check
	 * the one prior event for situations like "the 31st of every month"
	 * and "yearly" events which could happen twice in one year but not in
	 * the next */
	tmp2 = matches;
	for (i = -1; i < 2; i++) {
		memcpy(&tmtmp, tp, sizeof(struct tm));
		tmtmp.tm_mday = dayp;
		tmtmp.tm_mon = month = monthp - 1;
		do {
			v2 = 0;
			switch (interval) {
			case WEEKLY:
				tmtmp.tm_mday += 7 * i;
				break;
			case MONTHLY:
				month += i;
				tmtmp.tm_mon = month;
				switch(tmtmp.tm_mon) {
				case -1:
					tmtmp.tm_mon = month = 11;
					tmtmp.tm_year--;
					break;
				case 12:
					tmtmp.tm_mon = month = 0;
					tmtmp.tm_year++;
					break;
				}
				if (vwd) {
					v1 = vwd;
					variable_weekday(&v1, tmtmp.tm_mon + 1,
					    tmtmp.tm_year + 1900);
					tmtmp.tm_mday = v1;
				} else
					tmtmp.tm_mday = dayp;
				break;
			case YEARLY:
			default:
				tmtmp.tm_year += i;
				if (flags & F_SPECIAL) {
					tmtmp.tm_mon = 0;	/* Gee, mktime() is nice */
					tmtmp.tm_mday = spev[v1].getev(tmtmp.tm_year +
					    1900) + vwd;
				} else if (vwd) {
					v1 = vwd;
					variable_weekday(&v1, tmtmp.tm_mon + 1,
					    tmtmp.tm_year + 1900);
					tmtmp.tm_mday = v1;
				} else {
				/* Need the following to keep Feb 29 from
				 * becoming Mar 1 */
				tmtmp.tm_mday = dayp;
				tmtmp.tm_mon = monthp - 1;
				}
				break;
			}
			/* How many days apart are we */
			if ((ttmp = mktime(&tmtmp)) == -1)
				warnx("time out of range: %s", endp);
			else {
				tdiff = difftime(ttmp, f_time)/ SECSPERDAY;
				if (tdiff <= offset + f_dayAfter ||
				    (bodun && tdiff == -1)) {
					if (((tmtmp.tm_mon == month) ||
					     (flags & F_SPECIAL) ||
					     (interval == WEEKLY)) &&
					    (tdiff >=  0 ||
					    (bodun && tdiff == -1))) {
					if ((tmp = malloc(sizeof(struct match))) == NULL)
						err(1, NULL);
					tmp->when = ttmp;
					fill_print_date(tmp, &tmtmp);
					tmp->bodun = bodun && tdiff == -1;
					tmp->var   = varp;
					tmp->next  = NULL;
					if (tmp2)
						tmp2->next = tmp;
					else
						matches = tmp;
					tmp2 = tmp;
					v2 = (i == 1) ? 1 : 0;
					}
				} else
					i = 2; /* No point checking in the future */
			}
		} while (v2 != 0);
	}
	return (matches);
}


int
getmonth(char *s)
{
	char **p;
	struct fixs *n;

	for (n = fnmonths; n->name; ++n)
		if (!strncasecmp(s, n->name, n->len))
			return ((n - fnmonths) + 1);
	for (n = nmonths; n->name; ++n)
		if (!strncasecmp(s, n->name, n->len))
			return ((n - nmonths) + 1);
	for (p = months; *p; ++p)
		if (!strncasecmp(s, *p, 3))
			return ((p - months) + 1);
	return (0);
}


int
getday(char *s)
{
	char **p;
	struct fixs *n;

	for (n = fndays; n->name; ++n)
		if (!strncasecmp(s, n->name, n->len))
			return ((n - fndays) + 1);
	for (n = ndays; n->name; ++n)
		if (!strncasecmp(s, n->name, n->len))
			return ((n - ndays) + 1);
	for (p = days; *p; ++p)
		if (!strncasecmp(s, *p, 3))
			return ((p - days) + 1);
	return (0);
}

/* return offset for variable weekdays
 * -1 -> last weekday in month
 * +1 -> first weekday in month
 * ... etc ...
 */
int
getdayvar(char *s)
{
	int offset;


	offset = strlen(s);

	/* Sun+1 or Wednesday-2
	 *    ^              ^   */

	/* printf ("x: %s %s %d\n", s, s + offset - 2, offset); */
	switch(*(s + offset - 2)) {
	case '-':
	case '+':
	    return(atoi(s + offset - 2));
	    break;
	}

	/*
	 * some aliases: last, first, second, third, fourth
	 */

	/* last */
	if      (offset > 4 && !strcasecmp(s + offset - 4, "last"))
	    return(-1);
	else if (offset > 5 && !strcasecmp(s + offset - 5, "first"))
	    return(+1);
	else if (offset > 6 && !strcasecmp(s + offset - 6, "second"))
	    return(+2);
	else if (offset > 5 && !strcasecmp(s + offset - 5, "third"))
	    return(+3);
	else if (offset > 6 && !strcasecmp(s + offset - 6, "fourth"))
	    return(+4);

	/* no offset detected */
	return(0);
}


int
foy(int year)
{
	/* 0-6; what weekday Jan 1 is */
	year--;
	return ((1 - year/100 + year/400 + (int)(365.25 * year)) % 7);
}



void
variable_weekday(int *day, int month, int year)
{
	int v1, v2;
	int *cumdays;
	int day1;

	if (isleap(year))
		cumdays = daytab[1];
	else
		cumdays = daytab[0];
	day1 = foy(year);
	/* negative offset; last, -4 .. -1 */
	if (*day < 0) {
		v1 = *day/10 - 1;          /* offset -4 ... -1 */
		*day = 10 + (*day % 10);    /* day 1 ... 7 */

		/* which weekday the end of the month is (1-7) */
		v2 = (cumdays[month + 1] + day1) % 7 + 1;

		/* and subtract enough days */
		*day = cumdays[month + 1] - cumdays[month] +
		    (v1 + 1) * 7 - (v2 - *day + 7) % 7;
#if DEBUG
		fprintf(stderr, "\nMonth %d ends on weekday %d\n", month, v2);
#endif
	}

	/* first, second ... +1 ... +5 */
	else {
		v1 = *day/10;        /* offset */
		*day = *day % 10;

		/* which weekday the first of the month is (1-7) */
		v2 = (cumdays[month] + 1 + day1) % 7 + 1;

		/* and add enough days */
		*day = 1 + (v1 - 1) * 7 + (*day - v2 + 7) % 7;
#if DEBUG
		fprintf(stderr, "\nMonth %d starts on weekday %d\n", month, v2);
#endif
	}
}
@


1.33
log
@When matching a day in the month, make sure that the date is still
in the month we are interested in after calling mktime(3).  This
fixes things like Sunday+5 for months where there is not a 5th
Sunday and the 31st day in months with less than 31 days.
From Andy Bradford
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.32 2015/12/08 19:04:50 mmcc Exp $	*/
d546 3
a548 1
					if ((tmtmp.tm_mon == month) &&
@


1.32
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.31 2015/12/07 18:46:35 espie Exp $	*/
d546 3
a548 2
					if (tdiff >=  0 ||
					    (bodun && tdiff == -1)) {
@


1.31
log
@tweak the code a bit and add a -w option to display day of week.
okay jmc@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.30 2015/10/23 11:43:16 zhuk Exp $	*/
d101 1
a101 2
		if (ndays[i].name != NULL)
			free(ndays[i].name);
d110 1
a110 2
		if (fndays[i].name != NULL)
			free(fndays[i].name);
d122 1
a122 2
		if (nmonths[i].name != NULL)
			free(nmonths[i].name);
d131 1
a131 2
		if (fnmonths[i].name != NULL)
			free(fnmonths[i].name);
@


1.30
log
@A bit of whitespace cleanup, to make further diffs smaller.
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.29 2015/03/17 19:31:30 millert Exp $	*/
d81 8
d466 1
a466 6
			if (strftime(tmp->print_date,
			    sizeof(tmp->print_date),
			/*    "%a %b %d", &tm);  Skip weekdays */
			    "%b %d", &tmtmp) == 0)
				tmp->print_date[sizeof(tmp->print_date) - 1] = '\0';

d555 1
a555 5
					if (strftime(tmp->print_date,
					    sizeof(tmp->print_date),
					/*    "%a %b %d", &tm);  Skip weekdays */
					    "%b %d", &tmtmp) == 0)
						tmp->print_date[sizeof(tmp->print_date) - 1] = '\0';
@


1.29
log
@Eliminate use of TM_YEAR_BASE.  OK guenther@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.28 2015/03/15 00:41:28 millert Exp $	*/
d289 1
a289 1
		
@


1.28
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.27 2013/11/26 13:18:53 deraadt Exp $	*/
d159 1
a159 1
	if (isleap(tp->tm_year + TM_YEAR_BASE))
a216 1
		/* tm_year up TM_YEAR_BASE ... */
d218 3
a220 5
			tm.tm_year += 2000 - TM_YEAR_BASE;
		else if (tm.tm_year < 100)
			tm.tm_year += 1900 - TM_YEAR_BASE;
		else if (tm.tm_year > TM_YEAR_BASE)
			tm.tm_year -= TM_YEAR_BASE;
d430 1
a430 1
					    tmtmp.tm_year + TM_YEAR_BASE + 1);
d433 1
a433 1
					    tmtmp.tm_year + TM_YEAR_BASE);
d439 1
a439 1
				if ((v2 += isleap(tp->tm_year + TM_YEAR_BASE) ? 366 : 365)
d515 1
a515 1
					    tmtmp.tm_year + TM_YEAR_BASE);
d526 1
a526 1
					    TM_YEAR_BASE) + vwd;
d530 1
a530 1
					    tmtmp.tm_year + TM_YEAR_BASE);
@


1.27
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.26 2013/11/12 19:35:47 deraadt Exp $	*/
a41 1
#include <tzfile.h>
@


1.26
log
@deal with lack of prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.25 2013/04/16 18:28:24 deraadt Exp $	*/
d91 1
a91 1
		for (; l > 0 && isspace((int)buf[l - 1]); l--)
d101 1
a101 1
		for (; l > 0 && isspace((int)buf[l - 1]); l--)
d114 1
a114 1
		for (; l > 0 && isspace((int)buf[l - 1]); l--)
d124 1
a124 1
		for (; l > 0 && isspace((int)buf[l - 1]); l--)
@


1.25
log
@bzero struct tm before use; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.24 2013/04/02 04:40:21 deraadt Exp $	*/
a80 1

d234 1
a234 1
void
@


1.24
log
@handle large time_t in DEBUG code
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.23 2010/04/28 18:20:15 jsg Exp $	*/
d194 1
@


1.23
log
@shuffle extern decl of header[] so gcc4 doesn't complain about
incomplete types.

ok deraadt@@ 'Looks acceptable' miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.22 2009/10/27 23:59:36 deraadt Exp $	*/
d228 1
a228 1
	printf("Mktime: %d %d %d %s\n", (int)mktime(&tm), (int)t, len,
@


1.22
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.21 2008/04/13 00:22:17 djm Exp $	*/
d46 2
@


1.21
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.20 2005/11/16 16:45:11 deraadt Exp $	*/
a30 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)calendar.c  8.3 (Berkeley) 3/25/94";
#else
static const char rcsid[] = "$OpenBSD: day.c,v 1.20 2005/11/16 16:45:11 deraadt Exp $";
#endif
#endif /* not lint */
@


1.20
log
@knf & cleanup; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.19 2005/08/09 12:32:58 mickey Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: day.c,v 1.19 2005/08/09 12:32:58 mickey Exp $";
d304 1
a304 1
		bodun = !(arc4random() % 3);
@


1.19
log
@handle -A0 correctly; from koen@@egelink.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.18 2004/12/10 20:47:30 mickey Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: day.c,v 1.18 2004/12/10 20:47:30 mickey Exp $";
d94 2
a95 1
void setnnames(void)
d164 1
a164 2
settime(now)
	time_t *now;
d193 2
a194 2
time_t Mktime (date)
    char *date;
d196 3
a198 28
    time_t t;
    int len;
    struct tm tm;

    (void)time(&t);
    tp = localtime(&t);

    len = strlen(date);
    if (len < 2)
	return((time_t)-1);
    tm.tm_sec = 0;
    tm.tm_min = 0;
    /* Avoid getting caught by a timezone shift; set time to noon */
    tm.tm_isdst = 0;
    tm.tm_hour = 12;
    tm.tm_wday = 0;
    tm.tm_mday = tp->tm_mday;
    tm.tm_mon = tp->tm_mon;
    tm.tm_year = tp->tm_year;

    /* Day */
    tm.tm_mday = atoi(date + len - 2);

    /* Month */
    if (len >= 4) {
	*(date + len - 2) = '\0';
	tm.tm_mon = atoi(date + len - 4) - 1;
    }
d200 27
a226 2
    /* Year */
    if (len >= 6) {
d230 8
a237 8
	/* tm_year up TM_YEAR_BASE ... */
	if (tm.tm_year < 69)		/* Y2K */
		tm.tm_year += 2000 - TM_YEAR_BASE;
	else if (tm.tm_year < 100)
		tm.tm_year += 1900 - TM_YEAR_BASE;
	else if (tm.tm_year > TM_YEAR_BASE)
		tm.tm_year -= TM_YEAR_BASE;
    }
d240 2
a241 2
    printf("Mktime: %d %d %d %s\n", (int)mktime(&tm), (int)t, len,
	   asctime(&tm));
d243 1
a243 1
    return(mktime(&tm));
d277 1
a277 3
isnow(endp, bodun)
	char	*endp;
	int	bodun;
d593 1
a593 2
getmonth(s)
	char *s;
d612 1
a612 2
getday(s)
	char *s;
d635 1
a635 2
getdayvar(s)
	char *s;
d675 1
a675 2
foy(year)
	int year;
d685 1
a685 2
variable_weekday(day, month, year)
	int *day, month, year;
@


1.18
log
@define pesach (by gauss) and fix judaic calendar
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.17 2004/12/10 15:31:01 mickey Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: day.c,v 1.17 2004/12/10 15:31:01 mickey Exp $";
d179 1
a179 1
	if (f_dayAfter)
@


1.17
log
@cleanup extra includes and -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.16 2004/12/10 15:00:27 mickey Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: day.c,v 1.16 2004/12/10 15:00:27 mickey Exp $";
d146 9
a154 6
	spev[0].name = strdup(EASTER);
	spev[0].nlen = EASTERNAMELEN;
	spev[0].getev = easter;
	spev[1].name = strdup(PASKHA);
	spev[1].nlen = PASKHALEN;
	spev[1].getev = paskha;
@


1.16
log
@allow calendar files in julian
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.15 2003/06/03 02:56:06 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: day.c,v 1.15 2003/06/03 02:56:06 millert Exp $";
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.14 2001/11/19 19:02:13 mpech Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: day.c,v 1.14 2001/11/19 19:02:13 mpech Exp $";
d68 2
d243 20
d337 2
a338 1
		}
d356 5
a360 2
		if ((flags & F_ISDAY) && (day >= 1) && (day <=7))
			day += 10;
d377 2
a378 1
			}
d387 5
a391 2
			if ((flags & F_ISDAY) && (day >= 1) && (day <= 7))
				day += 10;
d483 1
a483 2
	}
	else {
@


1.14
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.13 2001/09/27 18:19:20 mickey Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: day.c,v 1.13 2001/09/27 18:19:20 mickey Exp $";
@


1.13
log
@some fixes and cleanups some from dfa@@solo.ee, some pointed
out by pjanzen@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.12 2001/09/26 20:38:55 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.12 2001/09/26 20:38:55 mickey Exp $";
d568 1
a568 1
	register char *s;
d570 1
a570 1
	register char **p;
d588 1
a588 1
	register char *s;
d590 1
a590 1
	register char **p;
d612 1
a612 1
	register char *s;
d614 1
a614 1
	register int offset;
@


1.12
log
@special procesing for cyrillic calendars (.ru, .ua, .by for now).
does not affect any existing behaviour for everything else.
old idea expressed by form@@; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.11 2001/06/05 21:27:16 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.11 2001/06/05 21:27:16 pjanzen Exp $";
d436 10
a445 1
			tmp->when = f_time + v2 * SECSPERDAY;
a451 4
			if (bodun && (day - tp->tm_yday) == -1)
				strcpy(tmp->prefix, "Бодун на утро от: ");
			else
				tmp->prefix[0] = '\0';
d547 1
a547 5
					if (bodun && tdiff == -1)
						strcpy(tmp->prefix,
						    "Bodun na ytpo ot: ");
					else
						tmp->prefix[0] = '\0';
@


1.11
log
@errx->err where errno is set
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.10 1999/11/25 03:46:46 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.10 1999/11/25 03:46:46 pjanzen Exp $";
d256 1
a256 1
isnow(endp)
d258 1
d283 4
d431 1
a431 1
				else
d443 5
d530 4
a533 2
				if (tdiff <= offset + f_dayAfter) {
					if (tdiff >=  0) {
d542 5
@


1.10
log
@Parse dates only before the first <tab> character; otherwise, weekly events
whose description starts with a valid month are misparsed.
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.9 1999/04/25 01:16:04 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.9 1999/04/25 01:16:04 pjanzen Exp $";
d111 1
a111 1
			errx(1, "cannot allocate memory");
d121 1
a121 1
			errx(1, "cannot allocate memory");
d134 1
a134 1
			errx(1, "cannot allocate memory");
d144 1
a144 1
			errx(1, "cannot allocate memory");
d156 1
a156 1
			errx(1, "cannot allocate memory");
d430 1
a430 1
				errx(1, "cannot allocate memory");
d523 1
a523 1
						errx(1, "cannot allocate memory");
@


1.9
log
@Fixed bug involving offsets from yearly "special events" (i.e Easter).
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.8 1999/03/04 03:34:35 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.8 1999/03/04 03:34:35 pjanzen Exp $";
d251 3
a253 3
 * Any character may separate them, or they may not be separated.  Any line,
 * following a line that is matched, that starts with "whitespace", is shown
 * along with the matched line.
@


1.8
log
@Correctly handle yearly events occurring on fixed weekdays in all cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.7 1998/12/13 07:31:07 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.7 1998/12/13 07:31:07 pjanzen Exp $";
d501 1
a501 1
					    vwd + TM_YEAR_BASE);
@


1.7
log
@Show periodic events the correct number of times.
Calculate special events (Easter) correctly regardless of which year
they occur in (thus fixing user/562).
Keep locales and special event names from propogating from one user
to the next during "calendar -a".
Set up a framework to handle special events other than Easter (for instance,
Jewish events, eventually).
Various other fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.6 1998/11/08 04:31:13 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.6 1998/11/08 04:31:13 pjanzen Exp $";
d407 14
@


1.6
log
@Sort output by date; include framework for showing periodic events more than
once
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.5 1998/11/04 11:32:02 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.5 1998/11/04 11:32:02 pjanzen Exp $";
d65 4
d70 1
a70 1
int *cumdays, offset, yrdays;
d147 12
d163 1
a163 1
    	time_t now;
d165 8
a172 3
	tp = localtime(&now);
	if (isleap(tp->tm_year + TM_YEAR_BASE)) {
		yrdays = DAYSPERLYEAR;
d174 1
a174 2
	} else {
		yrdays = DAYSPERNYEAR;
a175 1
	}
d178 2
d226 2
a227 2
	*(date + len - 4) = '\0';
	tm.tm_year = atoi(date);
d259 7
a265 3
	int day, flags = 0, month = 0, v1, v2;
	int monthp, dayp, varp;
	struct match *matches;
d283 2
a284 2
	if (flags & F_EASTER)
	    day = v1 - 1; /* days since January 1 [0-365] */
d293 1
a293 1
		/* found a day; day: 1-31 or weekday: 1-7 */
d297 4
a300 3
		/* if no recognizable month, assume just a day alone
		 * in other words, find month or use current month */
		if (!(month = getfield(endp, &endp, &flags)))
d302 15
d322 4
a325 1

d330 4
d347 4
a350 1
			varp = 0;
d359 2
a360 1
			varp = 0;
d370 1
a370 1
	    fprintf(stderr, "\nday: %d %s month %d\n", day, endp, month);
d373 15
a387 19
	    varp = 1;
	    /* variable weekday, SundayLast, MondayFirst ... */
	    if (day < 0 || day >= 10) {

		/* negative offset; last, -4 .. -1 */
		if (day < 0) {
		    v1 = day/10 - 1;          /* offset -4 ... -1 */
		    day = 10 + (day % 10);    /* day 1 ... 7 */

		    /* which weekday the end of the month is (1-7) */
		    v2 = (cumdays[month + 1] - tp->tm_yday +
		        tp->tm_wday + 371) % 7 + 1;

		    /* and subtract enough days */
		    day = cumdays[month + 1] - cumdays[month] +
		        (v1 + 1) * 7 - (v2 - day + 7) % 7;
#if DEBUG
		    fprintf(stderr, "\nMonth %d ends on weekday %d\n", month, v2);
#endif
d390 4
a393 11
		/* first, second ... +1 ... +5 */
		else {
		    v1 = day/10;        /* offset */
		    day = day % 10;

		    /* which weekday the first of the month is */
		    v2 = (cumdays[month] - tp->tm_yday +
		        tp->tm_wday + 372) % 7 + 1;
		    
		    /* and add enough days */
		    day = 1 + (v1 - 1) * 7 + (day - v2 + 7) % 7;
d395 1
a395 1
		    fprintf(stderr, "\nMonth %d starts on weekday %d\n", month, v2);
d397 31
a427 10
	    }
	    }
	    else
		    day = tp->tm_mday + (((day - 1) - tp->tm_wday + 7) % 7);
	}

	if (!(flags & F_EASTER)) {
	    monthp = month;
	    dayp = day;
	    day = cumdays[month] + day;
d430 9
a438 5
	    for (v1 = 0; day > cumdays[v1]; v1++)
		;
	    monthp = v1 - 1;
	    dayp = day - cumdays[v1 - 1];
	    varp = 1;
d441 88
a528 20
#if DEBUG
	fprintf(stderr, "day2: day %d(%d) yday %d\n", dayp, day, tp->tm_yday);
#endif
	/* if today or today + offset days */
	if ((day >= tp->tm_yday - f_dayBefore &&
	    day <= tp->tm_yday + offset + f_dayAfter) ||

	/* if number of days left in this year + days to event in next year */
	   (yrdays - tp->tm_yday + day <= offset + f_dayAfter ||
	    /* a year backward, eg. 6 Jan and 10 days before -> 27. Dec */
	    tp->tm_yday + day - f_dayBefore < 0
	    )) {
		if ((matches = malloc(sizeof(struct match))) == NULL)
			errx(1,"cannot allocate memory");
		matches->month = monthp;
		matches->day   = dayp;
		matches->var   = varp;
		matches->year  = tp->tm_year;	/* XXX */
		matches->next  = NULL;
		return (matches);
d530 1
a530 1
	return (NULL);
a586 1

a592 2
	    return(-(atoi(s + offset - 1)));
	    break;
d594 1
a594 1
	    return(atoi(s + offset - 1));
a597 1

a613 1

d616 57
@


1.5
log
@Various fixes, including closing user/630.
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.4 1998/03/30 06:59:26 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.4 1998/03/30 06:59:26 deraadt Exp $";
d234 2
a235 2
int
isnow(endp, monthp, dayp, varp)
a236 3
	int	*monthp;
	int	*dayp;
	int	*varp;
d239 2
d255 1
a255 1
		return (0);
d299 1
a299 1
			*varp = 0;
d308 1
a308 1
			*varp = 0;
d321 1
a321 1
	    *varp = 1;
d358 2
d363 2
a364 2
	    *monthp = month;
	    *dayp = day;
d370 3
a372 3
	    *monthp = v1 - 1;
	    *dayp = day - cumdays[v1 - 1];
	    *varp = 1;
d376 1
a376 1
	fprintf(stderr, "day2: day %d(%d) yday %d\n", *dayp, day, tp->tm_yday);
d379 2
a380 3
	if (day >= tp->tm_yday - f_dayBefore &&
	    day <= tp->tm_yday + offset + f_dayAfter)
		return (1);
d383 1
a383 1
	if (yrdays - tp->tm_yday + day <= offset + f_dayAfter ||
d386 11
a396 3
	    )
		return (1);
	return (0);
@


1.4
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.3 1998/02/23 05:48:42 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.3 1998/02/23 05:48:42 millert Exp $";
d186 3
a188 1
    tm.tm_hour = 0;
d204 1
a204 1
    if (len >= 7) {
d209 1
a209 1
	if (tm.tm_year < 70)
d315 1
a315 1
	 *       'SunayLast' -> ??
d329 1
a329 1
	            day = 10 + (day % 10);    /* day 1 ... 7 */
d331 10
a340 12
		    /* day, eg '22th' */
		    v2 = tp->tm_mday + (((day - 1) - tp->tm_wday + 7) % 7);

		    /* (month length - day) / 7 + 1 */
		    if (((int)((cumdays[month+1] -
		               cumdays[month] - v2) / 7) + 1) == -v1)
			/* bingo ! */
			day = v2;

		    /* set to yesterday */
		    else
			day = tp->tm_mday - 1;
d345 1
a345 1
		    v1 = day/10;        /* offset: +1 (first Sunday) ... */
d348 9
a356 11
		    /* day, eg '22th' */
		    v2 = tp->tm_mday + (((day - 1) - tp->tm_wday + 7) % 7);

		    /* Hurrah! matched */
		    if ( ((v2 - 1 + 7) / 7) == v1 )
			day = v2;

		    /* set to yesterday */
		    else
			day = tp->tm_mday - 1;
		}
a357 5

	    /* wired */
	    else {
		day = tp->tm_mday + (((day - 1) - tp->tm_wday + 7) % 7);
		*varp = 1;
@


1.3
log
@Avoid a few strlen's as strftime(3) returns the len.
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.2 1997/08/26 23:37:21 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.2 1997/08/26 23:37:21 millert Exp $";
d150 1
a150 1
	if (isleap(tp->tm_year + 1900)) {
a174 1
    char save;
d206 7
a212 3
	/* tm_year up 1900 ... */
	if (tm.tm_year > 1900)
	    tm.tm_year -= 1900;
@


1.2
log
@Make -t option use a date string like date(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: day.c,v 1.1 1996/12/05 06:04:39 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: day.c,v 1.1 1996/12/05 06:04:39 millert Exp $";
d100 2
a101 4
		strftime(buf, sizeof(buf), "%a", &tm);
		for (l = strlen(buf);
		     l > 0 && isspace((int)buf[l - 1]);
		     l--)
d110 2
a111 4
		strftime(buf, sizeof(buf), "%A", &tm);
		for (l = strlen(buf);
		     l > 0 && isspace((int)buf[l - 1]);
		     l--)
d123 2
a124 4
		strftime(buf, sizeof(buf), "%b", &tm);
		for (l = strlen(buf);
		     l > 0 && isspace((int)buf[l - 1]);
		     l--)
d133 2
a134 4
		strftime(buf, sizeof(buf), "%B", &tm);
		for (l = strlen(buf);
		     l > 0 && isspace((int)buf[l - 1]);
		     l--)
@


1.1
log
@FreeBSD calendar(1) + OpenBSD changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: $";
d176 2
a177 2
/* convert Day[/Month][/Year] into unix time (since 1970)
 * Day: two digits, Month: two digits, Year: digits
d183 1
d191 2
d201 2
d204 1
a204 5
    /* day */
    *(date+2) = NULL;
    tm.tm_mday = atoi(date);

    /* month */
d206 2
a207 2
	*(date+5) = NULL;
	tm.tm_mon = atoi(date+3) - 1;
d212 2
a213 1
	tm.tm_year = atoi(date+6);
@
