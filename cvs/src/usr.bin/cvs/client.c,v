head	1.125;
access;
symbols
	OPENBSD_6_1:1.125.0.6
	OPENBSD_6_1_BASE:1.125
	OPENBSD_6_0:1.125.0.4
	OPENBSD_6_0_BASE:1.125
	OPENBSD_5_9:1.125.0.2
	OPENBSD_5_9_BASE:1.125
	OPENBSD_5_8:1.124.0.6
	OPENBSD_5_8_BASE:1.124
	OPENBSD_5_7:1.124.0.2
	OPENBSD_5_7_BASE:1.124
	OPENBSD_5_6:1.123.0.18
	OPENBSD_5_6_BASE:1.123
	OPENBSD_5_5:1.123.0.16
	OPENBSD_5_5_BASE:1.123
	OPENBSD_5_4:1.123.0.12
	OPENBSD_5_4_BASE:1.123
	OPENBSD_5_3:1.123.0.10
	OPENBSD_5_3_BASE:1.123
	OPENBSD_5_2:1.123.0.8
	OPENBSD_5_2_BASE:1.123
	OPENBSD_5_1_BASE:1.123
	OPENBSD_5_1:1.123.0.6
	OPENBSD_5_0:1.123.0.4
	OPENBSD_5_0_BASE:1.123
	OPENBSD_4_9:1.123.0.2
	OPENBSD_4_9_BASE:1.123
	OPENBSD_4_8:1.122.0.2
	OPENBSD_4_8_BASE:1.122
	OPENBSD_4_7:1.121.0.2
	OPENBSD_4_7_BASE:1.121
	OPENBSD_4_6:1.121.0.4
	OPENBSD_4_6_BASE:1.121
	OPENBSD_4_5:1.119.0.2
	OPENBSD_4_5_BASE:1.119
	OPENBSD_4_4:1.116.0.2
	OPENBSD_4_4_BASE:1.116
	OPENBSD_4_3:1.108.0.2
	OPENBSD_4_3_BASE:1.108
	OPENBSD_4_2:1.71.0.2
	OPENBSD_4_2_BASE:1.71
	OPENBSD_4_1:1.59.0.2
	OPENBSD_4_1_BASE:1.59
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.0.1;
locks; strict;
comment	@ * @;


1.125
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.124;
commitid	O6jeJ0TRmiewrqMI;

1.124
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.123;
commitid	Uu5nFG3wCl0LACBb;

1.123
date	2010.09.29.18.14.52;	author nicm;	state Exp;
branches;
next	1.122;

1.122
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.121;

1.121
date	2009.04.04.11.29.57;	author joris;	state Exp;
branches;
next	1.120;

1.120
date	2009.04.01.06.41.58;	author joris;	state Exp;
branches;
next	1.119;

1.119
date	2009.02.23.21.28.57;	author tobias;	state Exp;
branches;
next	1.118;

1.118
date	2009.02.21.14.50.53;	author joris;	state Exp;
branches;
next	1.117;

1.117
date	2009.02.13.20.50.15;	author joris;	state Exp;
branches;
next	1.116;

1.116
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.115;

1.115
date	2008.06.11.02.19.13;	author tobias;	state Exp;
branches;
next	1.114;

1.114
date	2008.06.10.05.01.36;	author tobias;	state Exp;
branches;
next	1.113;

1.113
date	2008.04.24.19.13.56;	author tobias;	state Exp;
branches;
next	1.112;

1.112
date	2008.04.18.20.26.07;	author tobias;	state Exp;
branches;
next	1.111;

1.111
date	2008.03.09.03.32.01;	author joris;	state Exp;
branches;
next	1.110;

1.110
date	2008.03.09.00.36.30;	author tobias;	state Exp;
branches;
next	1.109;

1.109
date	2008.03.08.20.52.36;	author tobias;	state Exp;
branches;
next	1.108;

1.108
date	2008.02.29.21.43.57;	author joris;	state Exp;
branches;
next	1.107;

1.107
date	2008.02.28.20.00.56;	author joris;	state Exp;
branches;
next	1.106;

1.106
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.105;

1.105
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.104;

1.104
date	2008.02.10.14.08.52;	author xsa;	state Exp;
branches;
next	1.103;

1.103
date	2008.02.10.12.34.37;	author joris;	state Exp;
branches;
next	1.102;

1.102
date	2008.02.09.20.04.00;	author xsa;	state Exp;
branches;
next	1.101;

1.101
date	2008.02.09.12.48.23;	author joris;	state Exp;
branches;
next	1.100;

1.100
date	2008.02.05.21.49.29;	author tobias;	state Exp;
branches;
next	1.99;

1.99
date	2008.02.03.18.18.44;	author tobias;	state Exp;
branches;
next	1.98;

1.98
date	2008.02.03.17.20.14;	author joris;	state Exp;
branches;
next	1.97;

1.97
date	2008.02.03.15.57.25;	author tobias;	state Exp;
branches;
next	1.96;

1.96
date	2008.02.03.15.08.04;	author tobias;	state Exp;
branches;
next	1.95;

1.95
date	2008.02.01.21.09.59;	author xsa;	state Exp;
branches;
next	1.94;

1.94
date	2008.02.01.17.18.59;	author tobias;	state Exp;
branches;
next	1.93;

1.93
date	2008.01.31.22.09.05;	author xsa;	state Exp;
branches;
next	1.92;

1.92
date	2008.01.31.19.51.40;	author xsa;	state Exp;
branches;
next	1.91;

1.91
date	2008.01.29.11.55.30;	author tobias;	state Exp;
branches;
next	1.90;

1.90
date	2008.01.21.16.36.46;	author tobias;	state Exp;
branches;
next	1.89;

1.89
date	2008.01.10.11.20.29;	author tobias;	state Exp;
branches;
next	1.88;

1.88
date	2008.01.10.10.08.22;	author tobias;	state Exp;
branches;
next	1.87;

1.87
date	2008.01.10.10.05.40;	author tobias;	state Exp;
branches;
next	1.86;

1.86
date	2008.01.10.09.48.51;	author tobias;	state Exp;
branches;
next	1.85;

1.85
date	2008.01.10.09.47.05;	author tobias;	state Exp;
branches;
next	1.84;

1.84
date	2008.01.10.09.41.52;	author tobias;	state Exp;
branches;
next	1.83;

1.83
date	2007.11.11.09.51.49;	author tobias;	state Exp;
branches;
next	1.82;

1.82
date	2007.10.07.18.12.48;	author chl;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.22.15.30.29;	author tobias;	state Exp;
branches;
next	1.80;

1.80
date	2007.09.17.18.36.54;	author tobias;	state Exp;
branches;
next	1.79;

1.79
date	2007.09.10.19.11.08;	author joris;	state Exp;
branches;
next	1.78;

1.78
date	2007.09.10.14.06.14;	author joris;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.07.19.36.05;	author tobias;	state Exp;
branches;
next	1.76;

1.76
date	2007.09.07.19.18.41;	author tobias;	state Exp;
branches;
next	1.75;

1.75
date	2007.09.02.12.16.24;	author tobias;	state Exp;
branches;
next	1.74;

1.74
date	2007.09.02.11.11.12;	author tobias;	state Exp;
branches;
next	1.73;

1.73
date	2007.09.01.15.41.34;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2007.08.30.11.07.18;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2007.07.17.20.29.58;	author xsa;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.17.16.13.39;	author xsa;	state Exp;
branches;
next	1.69;

1.69
date	2007.07.03.13.22.42;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.29.12.42.05;	author xsa;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.27.20.42.19;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.27.03.58.16;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.26.02.24.10;	author niallo;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.26.02.50.46;	author ray;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.25.22.36.47;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.17.03.26.33;	author ray;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.16.09.52.47;	author xsa;	state Exp;
branches;
next	1.59;

1.59
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.57;

1.57
date	2007.01.31.21.07.35;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2007.01.28.02.04.45;	author joris;	state Exp;
branches;
next	1.55;

1.55
date	2007.01.27.19.38.19;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2007.01.26.21.59.11;	author otto;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.26.21.48.17;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2007.01.26.11.19.44;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.26.10.42.06;	author otto;	state Exp;
branches;
next	1.50;

1.50
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.18.16.45.52;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2007.01.17.17.54.50;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2007.01.16.09.14.19;	author xsa;	state Exp;
branches;
next	1.46;

1.46
date	2007.01.13.15.29.34;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2007.01.03.22.28.30;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2007.01.03.21.00.43;	author joris;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.03.19.27.28;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2007.01.02.23.55.15;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2006.12.21.22.32.30;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2006.12.20.16.25.27;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.19.16.04.40;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.19.15.12.59;	author joris;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.19.14.11.21;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.19.11.46.39;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.15.15.40.28;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.15.13.12.14;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.15.09.50.37;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.15.08.26.18;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2006.12.15.08.02.53;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2006.12.14.15.13.17;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.27.16.19.59;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.27.16.04.10;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.14.15.39.41;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.14.10.10.19;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.14.09.59.54;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.14.09.47.52;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.13.15.55.54;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.13.12.57.03;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.10.11.02.05;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.10.10.53.06;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.09.14.00.14;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.09.09.24.28;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.08.20.20.42;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.31.15.23.40;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.20.15.14.22;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.09.04.39.43;	author joris;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.09.01.47.20;	author joris;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.08.01.02.03;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.08.00.34.20;	author joris;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.31.01.15.26;	author jfb;	state dead;
branches;
next	1.7;

1.7
date	2004.07.30.01.49.22;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.29.18.32.03;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.28.11.18.01;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.28.01.53.28;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.27.13.08.23;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.26.16.01.22;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.125
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@/*	$OpenBSD: client.c,v 1.124 2015/01/16 06:40:06 deraadt Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/dirent.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

struct cvs_req cvs_requests[] = {
	/* this is what our client will use, the server should support it */
	{ "Root",		1,	cvs_server_root, REQ_NEEDED },
	{ "Valid-responses",	1,	cvs_server_validresp, REQ_NEEDED },
	{ "valid-requests",	1,	cvs_server_validreq, REQ_NEEDED },
	{ "Directory",		0,	cvs_server_directory, REQ_NEEDED },
	{ "Static-directory",	0,	cvs_server_static_directory,
	    REQ_NEEDED | REQ_NEEDDIR },
	{ "Sticky",		0,	cvs_server_sticky,
	    REQ_NEEDED | REQ_NEEDDIR },
	{ "Entry",		0,	cvs_server_entry,
	    REQ_NEEDED | REQ_NEEDDIR },
	{ "Modified",		0,	cvs_server_modified,
	    REQ_NEEDED | REQ_NEEDDIR },
	{ "UseUnchanged",	0,	cvs_server_useunchanged, REQ_NEEDED },
	{ "Unchanged",		0,	cvs_server_unchanged,
	    REQ_NEEDED | REQ_NEEDDIR },
	{ "Questionable",	0,	cvs_server_questionable, REQ_NEEDED },
	{ "Argument",		0,	cvs_server_argument, REQ_NEEDED },
	{ "Argumentx",		0,	cvs_server_argumentx, REQ_NEEDED },
	{ "Global_option",	0,	cvs_server_globalopt, REQ_NEEDED },
	{ "Set",		0,	cvs_server_set, REQ_NEEDED },
	{ "expand-modules",	0,	cvs_server_exp_modules, 0 },

	/*
	 * used to tell the server what is going on in our
	 * working copy, unsupported until we are told otherwise
	 */
	{ "Max-dotdot",			0,	NULL, 0 },
	{ "Checkin-prog",		0,	NULL, 0 },
	{ "Update-prog",		0,	NULL, 0 },
	{ "Kopt",			0,	NULL, 0 },
	{ "Checkin-time",		0,	NULL, 0 },
	{ "Is-modified",		0,	NULL, 0 },
	{ "Notify",			0,	NULL, 0 },
	{ "Case",			0,	NULL, 0 },
	{ "Gzip-stream",		0,	NULL, 0 },
	{ "wrapper-sendme-rcsOptions",	0,	NULL, 0 },
	{ "Kerberos-encrypt",		0,	NULL, 0 },
	{ "Gssapi-encrypt",		0,	NULL, 0 },
	{ "Gssapi-authenticate",	0,	NULL, 0 },

	/* commands that might be supported */
	{ "ci",			0,	cvs_server_commit,	REQ_NEEDDIR },
	{ "co",			0,	cvs_server_checkout,	REQ_NEEDDIR },
	{ "update",		0,	cvs_server_update,	REQ_NEEDDIR },
	{ "diff",		0,	cvs_server_diff,	REQ_NEEDDIR },
	{ "log",		0,	cvs_server_log,		REQ_NEEDDIR },
	{ "rlog",		0,	cvs_server_rlog, 0 },
	{ "add",		0,	cvs_server_add,		REQ_NEEDDIR },
	{ "remove",		0,	cvs_server_remove,	REQ_NEEDDIR },
	{ "update-patches",	0,	cvs_server_update_patches, 0 },
	{ "gzip-file-contents",	0,	NULL, 0 },
	{ "status",		0,	cvs_server_status,	REQ_NEEDDIR },
	{ "rdiff",		0,	cvs_server_rdiff, 0 },
	{ "tag",		0,	cvs_server_tag,		REQ_NEEDDIR },
	{ "rtag",		0,	cvs_server_rtag, 0 },
	{ "import",		0,	cvs_server_import,	REQ_NEEDDIR },
	{ "admin",		0,	cvs_server_admin,	REQ_NEEDDIR },
	{ "export",		0,	cvs_server_export,	REQ_NEEDDIR },
	{ "history",		0,	NULL, 0 },
	{ "release",		0,	cvs_server_release,	REQ_NEEDDIR },
	{ "watch-on",		0,	NULL, 0 },
	{ "watch-off",		0,	NULL, 0 },
	{ "watch-add",		0,	NULL, 0 },
	{ "watch-remove",	0,	NULL, 0 },
	{ "watchers",		0,	NULL, 0 },
	{ "editors",		0,	NULL, 0 },
	{ "init",		0,	cvs_server_init, 0 },
	{ "annotate",		0,	cvs_server_annotate,	REQ_NEEDDIR },
	{ "rannotate",		0,	cvs_server_rannotate, 0 },
	{ "noop",		0,	NULL, 0 },
	{ "version",		0,	cvs_server_version, 0 },
	{ "",			-1,	NULL, 0 }
};

static void	 client_check_directory(char *, char *);
static char	*client_get_supported_responses(void);
static char	*lastdir = NULL;
static int	 end_of_response = 0;

static void	cvs_client_initlog(void);

/*
 * File descriptors for protocol logging when the CVS_CLIENT_LOG environment
 * variable is set.
 */
static int	cvs_client_logon = 0;
int	cvs_client_inlog_fd = -1;
int	cvs_client_outlog_fd = -1;


int server_response = SERVER_OK;

static char *
client_get_supported_responses(void)
{
	BUF *bp;
	char *d;
	int i, first;

	first = 0;
	bp = buf_alloc(512);
	for (i = 0; cvs_responses[i].supported != -1; i++) {
		if (cvs_responses[i].hdlr == NULL)
			continue;

		if (first != 0)
			buf_putc(bp, ' ');
		else
			first++;
		buf_puts(bp, cvs_responses[i].name);
	}

	buf_putc(bp, '\0');
	d = buf_release(bp);
	return (d);
}

static void
client_check_directory(char *data, char *repository)
{
	CVSENTRIES *entlist;
	char *entry, *parent, *base, *p;

	STRIP_SLASH(data);

	/* first directory we get is our module root */
	if (module_repo_root == NULL && checkout_target_dir != NULL) {
		p = repository + strlen(current_cvsroot->cr_dir) + 1;
		module_repo_root = xstrdup(p);
		p = strrchr(module_repo_root, '/');
		if (p != NULL)
			*p = '\0';
	}

	cvs_mkpath(data, NULL);

	if (cvs_cmdop == CVS_OP_EXPORT)
		return;

	if ((base = basename(data)) == NULL)
		fatal("client_check_directory: overflow");

	if ((parent = dirname(data)) == NULL)
		fatal("client_check_directory: overflow");

	if (!strcmp(parent, "."))
		return;

	entry = xmalloc(CVS_ENT_MAXLINELEN);
	cvs_ent_line_str(base, NULL, NULL, NULL, NULL, 1, 0, entry,
	    CVS_ENT_MAXLINELEN);

	entlist = cvs_ent_open(parent);
	cvs_ent_add(entlist, entry);

	free(entry);
}

void
cvs_client_connect_to_server(void)
{
	struct cvs_var *vp;
	char *cmd, *argv[9], *resp;
	int ifd[2], ofd[2], argc;

	if (cvs_server_active == 1)
		fatal("cvs_client_connect: I was already connected to server");

	switch (current_cvsroot->cr_method) {
	case CVS_METHOD_PSERVER:
	case CVS_METHOD_KSERVER:
	case CVS_METHOD_GSERVER:
	case CVS_METHOD_FORK:
		fatal("the specified connection method is not supported");
	default:
		break;
	}

	if (pipe(ifd) == -1)
		fatal("cvs_client_connect: %s", strerror(errno));
	if (pipe(ofd) == -1)
		fatal("cvs_client_connect: %s", strerror(errno));

	switch (fork()) {
	case -1:
		fatal("cvs_client_connect: fork failed: %s", strerror(errno));
	case 0:
		if (dup2(ifd[0], STDIN_FILENO) == -1)
			fatal("cvs_client_connect: %s", strerror(errno));
		if (dup2(ofd[1], STDOUT_FILENO) == -1)
			fatal("cvs_client_connect: %s", strerror(errno));

		close(ifd[1]);
		close(ofd[0]);

		if ((cmd = getenv("CVS_SERVER")) == NULL)
			cmd = CVS_SERVER_DEFAULT;

		argc = 0;
		argv[argc++] = cvs_rsh;

		if (current_cvsroot->cr_user != NULL) {
			argv[argc++] = "-l";
			argv[argc++] = current_cvsroot->cr_user;
		}

		argv[argc++] = current_cvsroot->cr_host;
		argv[argc++] = cmd;
		argv[argc++] = "server";
		argv[argc] = NULL;

		cvs_log(LP_TRACE, "connecting to server %s",
		    current_cvsroot->cr_host);

		execvp(argv[0], argv);
		fatal("cvs_client_connect: failed to execute cvs server");
	default:
		break;
	}

	close(ifd[0]);
	close(ofd[1]);

	if ((current_cvsroot->cr_srvin = fdopen(ifd[1], "w")) == NULL)
		fatal("cvs_client_connect: %s", strerror(errno));
	if ((current_cvsroot->cr_srvout = fdopen(ofd[0], "r")) == NULL)
		fatal("cvs_client_connect: %s", strerror(errno));

	setvbuf(current_cvsroot->cr_srvin, NULL,_IOLBF, 0);
	setvbuf(current_cvsroot->cr_srvout, NULL, _IOLBF, 0);

	cvs_client_initlog();

	if (cvs_cmdop != CVS_OP_INIT)
		cvs_client_send_request("Root %s", current_cvsroot->cr_dir);

	resp = client_get_supported_responses();
	cvs_client_send_request("Valid-responses %s", resp);
	free(resp);

	cvs_client_send_request("valid-requests");
	cvs_client_get_responses();

	cvs_client_send_request("UseUnchanged");

	if (cvs_nolog == 1)
		cvs_client_send_request("Global_option -l");

	if (cvs_noexec == 1)
		cvs_client_send_request("Global_option -n");

	switch (verbosity) {
	case 0:
		cvs_client_send_request("Global_option -Q");
		break;
	case 1:
		/* Be quiet. This is the default in OpenCVS. */
		cvs_client_send_request("Global_option -q");
		break;
	default:
		break;
	}

	if (cvs_readonly == 1)
		cvs_client_send_request("Global_option -r");

	if (cvs_trace == 1)
		cvs_client_send_request("Global_option -t");

	/* XXX: If 'Set' is supported? */
	TAILQ_FOREACH(vp, &cvs_variables, cv_link)
		cvs_client_send_request("Set %s=%s", vp->cv_name, vp->cv_val);
}

void
cvs_client_send_request(char *fmt, ...)
{
	int i;
	va_list ap;
	char *data, *s;
	struct cvs_req *req;

	va_start(ap, fmt);
	i = vasprintf(&data, fmt, ap);
	va_end(ap);
	if (i == -1)
		fatal("cvs_client_send_request: could not allocate memory");

	if ((s = strchr(data, ' ')) != NULL)
		*s = '\0';

	req = cvs_remote_get_request_info(data);
	if (req == NULL)
		fatal("'%s' is an unknown request", data);

	if (req->supported != 1)
		fatal("remote cvs server does not support '%s'", data);

	if (s != NULL)
		*s = ' ';

	cvs_log(LP_TRACE, "%s", data);

	cvs_remote_output(data);
	free(data);
}

void
cvs_client_read_response(void)
{
	char *cmd, *data;
	struct cvs_resp *resp;

	cmd = cvs_remote_input();
	if ((data = strchr(cmd, ' ')) != NULL)
		(*data++) = '\0';

	resp = cvs_remote_get_response_info(cmd);
	if (resp == NULL)
		fatal("response '%s' is not supported by our client", cmd);

	if (resp->hdlr == NULL)
		fatal("opencvs client does not support '%s'", cmd);

	(*resp->hdlr)(data);

	free(cmd);
}

void
cvs_client_get_responses(void)
{
	while (end_of_response != 1)
		cvs_client_read_response();

	end_of_response = 0;
}

void
cvs_client_send_logmsg(char *msg)
{
	char *buf, *p, *q;

	(void)xasprintf(&buf, "%s\n", msg);

	cvs_client_send_request("Argument -m");
	if ((p = strchr(buf, '\n')) != NULL)
		*p++ = '\0';
	cvs_client_send_request("Argument %s", buf);
	for (q = p; p != NULL; q = p) {
		if ((p = strchr(q, '\n')) != NULL) {
			*p++ = '\0';
			cvs_client_send_request("Argumentx %s", q);
		}
	}

	free(buf);
}

void
cvs_client_senddir(const char *dir)
{
	struct stat st;
	int nb;
	char *d, *date, fpath[PATH_MAX], repo[PATH_MAX], *tag;

	d = NULL;

	if (lastdir != NULL && !strcmp(dir, lastdir))
		return;

	cvs_get_repository_path(dir, repo, PATH_MAX);

	if (cvs_cmdop != CVS_OP_RLOG)
		cvs_client_send_request("Directory %s\n%s", dir, repo);

	(void)xsnprintf(fpath, PATH_MAX, "%s/%s",
	    dir, CVS_PATH_STATICENTRIES);

	if (stat(fpath, &st) == 0 && (st.st_mode & (S_IRUSR|S_IRGRP|S_IROTH)))
		cvs_client_send_request("Static-directory");

	d = xstrdup(dir);
	cvs_parse_tagfile(d, &tag, &date, &nb);

	if (tag != NULL || date != NULL) {
		char buf[128];

		if (tag != NULL && nb != 0) {
			if (strlcpy(buf, "N", sizeof(buf)) >= sizeof(buf))
				fatal("cvs_client_senddir: truncation");
		} else if (tag != NULL) {
			if (strlcpy(buf, "T", sizeof(buf)) >= sizeof(buf))
				fatal("cvs_client_senddir: truncation");
		} else {
			if (strlcpy(buf, "D", sizeof(buf)) >= sizeof(buf))
				fatal("cvs_client_senddir: truncation");
		}

		if (strlcat(buf, tag ? tag : date, sizeof(buf)) >= sizeof(buf))
			fatal("cvs_client_senddir: truncation");

		cvs_client_send_request("Sticky %s", buf);

		free(tag);
		free(date);
	}
	free(d);
	free(lastdir);
	lastdir = xstrdup(dir);
}

void
cvs_client_sendfile(struct cvs_file *cf)
{
	size_t len;
	struct tm datetm;
	char rev[CVS_REV_BUFSZ], timebuf[CVS_TIME_BUFSZ], sticky[CVS_REV_BUFSZ];

	if (cf->file_type != CVS_FILE)
		return;

	cvs_client_senddir(cf->file_wd);
	cvs_remote_classify_file(cf);

	if (cf->file_type == CVS_DIR)
		return;

	if (cf->file_ent != NULL && cvs_cmdop != CVS_OP_IMPORT) {
		if (cf->file_status == FILE_ADDED) {
			len = strlcpy(rev, "0", sizeof(rev));
			if (len >= sizeof(rev))
				fatal("cvs_client_sendfile: truncation");

			len = strlcpy(timebuf, "Initial ", sizeof(timebuf));
			if (len >= sizeof(timebuf))
				fatal("cvs_client_sendfile: truncation");

			len = strlcat(timebuf, cf->file_name, sizeof(timebuf));
			if (len >= sizeof(timebuf))
				fatal("cvs_client_sendfile: truncation");
		} else {
			rcsnum_tostr(cf->file_ent->ce_rev, rev, sizeof(rev));
			ctime_r(&cf->file_ent->ce_mtime, timebuf);
		}

		if (cf->file_ent->ce_conflict == NULL) {
			timebuf[strcspn(timebuf, "\n")] = '\0';
		} else {
			len = strlcpy(timebuf, cf->file_ent->ce_conflict,
			    sizeof(timebuf));
			if (len >= sizeof(timebuf))
				fatal("cvs_client_sendfile: truncation");
			len = strlcat(timebuf, "+=", sizeof(timebuf));
			if (len >= sizeof(timebuf))
				fatal("cvs_client_sendfile: truncation");
		}

		sticky[0] = '\0';
		if (cf->file_ent->ce_tag != NULL) {
			(void)xsnprintf(sticky, sizeof(sticky), "T%s",
			    cf->file_ent->ce_tag);
		} else if (cf->file_ent->ce_date != -1) {
			gmtime_r(&(cf->file_ent->ce_date), &datetm);
			(void)strftime(sticky, sizeof(sticky),
			    "D"CVS_DATE_FMT, &datetm);
		}

		cvs_client_send_request("Entry /%s/%s%s/%s/%s/%s",
		    cf->file_name, (cf->file_status == FILE_REMOVED) ? "-" : "",
		    rev, timebuf, cf->file_ent->ce_opts ?
		    cf->file_ent->ce_opts : "", sticky);
	}

	if (cvs_cmdop == CVS_OP_ADD)
		cf->file_status = FILE_MODIFIED;

	switch (cf->file_status) {
	case FILE_UNKNOWN:
		if (cf->file_flags & FILE_ON_DISK)
			cvs_client_send_request("Questionable %s",
			    cf->file_name);
		break;
	case FILE_ADDED:
		if (backup_local_changes)	/* for update -C */
			cvs_backup_file(cf);

		cvs_client_send_request("Modified %s", cf->file_name);
		cvs_remote_send_file(cf->file_path, cf->fd);
		break;
	case FILE_MODIFIED:
		if (backup_local_changes) {	/* for update -C */
			cvs_backup_file(cf);
			cvs_client_send_request("Entry /%s/%s%s/%s/%s/%s",
			    cf->file_name, "", rev, timebuf,
			    cf->file_ent->ce_opts ? cf->file_ent->ce_opts : "",
			    sticky);
			break;
		}

		cvs_client_send_request("Modified %s", cf->file_name);
		cvs_remote_send_file(cf->file_path, cf->fd);
		break;
	case FILE_UPTODATE:
		cvs_client_send_request("Unchanged %s", cf->file_name);
		break;
	}
}

void
cvs_client_send_files(char **argv, int argc)
{
	int i;

	for (i = 0; i < argc; i++)
		cvs_client_send_request("Argument %s", argv[i]);
}

void
cvs_client_ok(char *data)
{
	end_of_response = 1;
	server_response = SERVER_OK;
}

void
cvs_client_error(char *data)
{
	end_of_response = 1;
	server_response = SERVER_ERROR;
}

void
cvs_client_validreq(char *data)
{
	int i;
	char *sp, *ep;
	struct cvs_req *req;

	if ((sp = data) == NULL)
		fatal("Missing argument for Valid-requests");

	do {
		if ((ep = strchr(sp, ' ')) != NULL)
			*ep = '\0';

		req = cvs_remote_get_request_info(sp);
		if (req != NULL)
			req->supported = 1;

		if (ep != NULL)
			sp = ep + 1;
	} while (ep != NULL);

	for (i = 0; cvs_requests[i].supported != -1; i++) {
		req = &cvs_requests[i];
		if ((req->flags & REQ_NEEDED) &&
		    req->supported != 1) {
			fatal("server does not support required '%s'",
			    req->name);
		}
	}
}

void
cvs_client_e(char *data)
{
	if (data == NULL)
		fatal("Missing argument for E");

	fprintf(stderr, "%s\n", data);
}

void
cvs_client_m(char *data)
{
	if (data == NULL)
		fatal("Missing argument for M");

	puts(data);
}

void
cvs_client_checkedin(char *data)
{
	CVSENTRIES *entlist;
	struct cvs_ent *ent, *newent;
	size_t len;
	struct tm datetm;
	char *dir, *e, *entry, rev[CVS_REV_BUFSZ];
	char sticky[CVS_ENT_MAXLINELEN], timebuf[CVS_TIME_BUFSZ];

	if (data == NULL)
		fatal("Missing argument for Checked-in");

	dir = cvs_remote_input();
	e = cvs_remote_input();
	free(dir);

	entlist = cvs_ent_open(data);
	newent = cvs_ent_parse(e);
	ent = cvs_ent_get(entlist, newent->ce_name);
	free(e);

	rcsnum_tostr(newent->ce_rev, rev, sizeof(rev));

	sticky[0] = '\0';
	if (ent == NULL) {
		len = strlcpy(rev, "0", sizeof(rev));
		if (len >= sizeof(rev))
			fatal("cvs_client_sendfile: truncation");

		len = strlcpy(timebuf, "Initial ", sizeof(timebuf));
		if (len >= sizeof(timebuf))
			fatal("cvs_client_sendfile: truncation");

		len = strlcat(timebuf, newent->ce_name, sizeof(timebuf));
		if (len >= sizeof(timebuf))
			fatal("cvs_client_sendfile: truncation");
	} else {
		gmtime_r(&ent->ce_mtime, &datetm);
		asctime_r(&datetm, timebuf);
		timebuf[strcspn(timebuf, "\n")] = '\0';

		if (newent->ce_tag != NULL) {
			(void)xsnprintf(sticky, sizeof(sticky), "T%s",
			    newent->ce_tag);
		} else if (newent->ce_date != -1) {
			gmtime_r(&(newent->ce_date), &datetm);
			(void)strftime(sticky, sizeof(sticky),
			    "D"CVS_DATE_FMT, &datetm);
		}

		cvs_ent_free(ent);
	}

	entry = xmalloc(CVS_ENT_MAXLINELEN);
	cvs_ent_line_str(newent->ce_name, rev, timebuf,
	    newent->ce_opts ? newent->ce_opts : "", sticky, 0,
	    newent->ce_status == CVS_ENT_REMOVED ? 1 : 0,
	    entry, CVS_ENT_MAXLINELEN);

	cvs_ent_free(newent);
	cvs_ent_add(entlist, entry);

	free(entry);
}

void
cvs_client_updated(char *data)
{
	int fd;
	time_t now;
	mode_t fmode;
	size_t flen;
	CVSENTRIES *ent;
	struct cvs_ent *e;
	const char *errstr;
	struct tm datetm;
	struct timeval tv[2];
	char repo[PATH_MAX], *entry;
	char timebuf[CVS_TIME_BUFSZ], revbuf[CVS_REV_BUFSZ];
	char *en, *mode, *len, *rpath, *p;
	char sticky[CVS_ENT_MAXLINELEN], fpath[PATH_MAX];

	if (data == NULL)
		fatal("Missing argument for Updated");

	rpath = cvs_remote_input();
	en = cvs_remote_input();
	mode = cvs_remote_input();
	len = cvs_remote_input();

	client_check_directory(data, rpath);
	cvs_get_repository_path(".", repo, PATH_MAX);

	STRIP_SLASH(repo);

	if (strlen(repo) + 1 > strlen(rpath))
		fatal("received a repository path that is too short");

	p = strrchr(rpath, '/');
	if (p == NULL)
		fatal("malicious repository path from server");

	(void)xsnprintf(fpath, sizeof(fpath), "%s/%s", data, p);

	flen = strtonum(len, 0, INT_MAX, &errstr);
	if (errstr != NULL)
		fatal("cvs_client_updated: %s: %s", len, errstr);
	free(len);

	cvs_strtomode(mode, &fmode);
	free(mode);
	fmode &= ~cvs_umask;

	time(&now);
	gmtime_r(&now, &datetm);
	asctime_r(&datetm, timebuf);
	timebuf[strcspn(timebuf, "\n")] = '\0';

	e = cvs_ent_parse(en);
	free(en);

	sticky[0] = '\0';
	if (e->ce_tag != NULL) {
		(void)xsnprintf(sticky, sizeof(sticky), "T%s", e->ce_tag);
	} else if (e->ce_date != -1) {
		gmtime_r(&(e->ce_date), &datetm);
		(void)strftime(sticky, sizeof(sticky),
		    "D"CVS_DATE_FMT, &datetm);
	}

	rcsnum_tostr(e->ce_rev, revbuf, sizeof(revbuf));

	entry = xmalloc(CVS_ENT_MAXLINELEN);
	cvs_ent_line_str(e->ce_name, revbuf, timebuf,
	    e->ce_opts ? e->ce_opts : "", sticky, 0, 0,
	    entry, CVS_ENT_MAXLINELEN);

	cvs_ent_free(e);

	if (cvs_cmdop != CVS_OP_EXPORT) {
		ent = cvs_ent_open(data);
		cvs_ent_add(ent, entry);
	}

	free(entry);

	(void)unlink(fpath);
	if ((fd = open(fpath, O_CREAT | O_WRONLY | O_TRUNC)) == -1)
		fatal("cvs_client_updated: open: %s: %s",
		    fpath, strerror(errno));

	cvs_remote_receive_file(fd, flen);

	tv[0].tv_sec = now;
	tv[0].tv_usec = 0;
	tv[1] = tv[0];

	if (futimes(fd, tv) == -1)
		fatal("cvs_client_updated: futimes: %s", strerror(errno));

	if (fchmod(fd, fmode) == -1)
		fatal("cvs_client_updated: fchmod: %s", strerror(errno));

	(void)close(fd);

	free(rpath);
}

void
cvs_client_merged(char *data)
{
	int fd;
	time_t now;
	mode_t fmode;
	size_t flen;
	CVSENTRIES *ent;
	const char *errstr;
	struct timeval tv[2];
	struct tm datetm;
	char timebuf[CVS_TIME_BUFSZ], *repo, *rpath, *entry, *mode;
	char *len, *fpath, *wdir;

	if (data == NULL)
		fatal("Missing argument for Merged");

	rpath = cvs_remote_input();
	entry = cvs_remote_input();
	mode = cvs_remote_input();
	len = cvs_remote_input();

	client_check_directory(data, rpath);

	repo = xmalloc(PATH_MAX);
	cvs_get_repository_path(".", repo, PATH_MAX);

	STRIP_SLASH(repo);

	if (strlen(repo) + 1 > strlen(rpath))
		fatal("received a repository path that is too short");

	fpath = rpath + strlen(repo) + 1;
	if ((wdir = dirname(fpath)) == NULL)
		fatal("cvs_client_merged: dirname: %s", strerror(errno));
	free(repo);

	flen = strtonum(len, 0, INT_MAX, &errstr);
	if (errstr != NULL)
		fatal("cvs_client_merged: %s: %s", len, errstr);
	free(len);

	cvs_strtomode(mode, &fmode);
	free(mode);
	fmode &= ~cvs_umask;

	time(&now);
	gmtime_r(&now, &datetm);
	asctime_r(&datetm, timebuf);
	timebuf[strcspn(timebuf, "\n")] = '\0';

	ent = cvs_ent_open(wdir);
	cvs_ent_add(ent, entry);
	free(entry);

	(void)unlink(fpath);
	if ((fd = open(fpath, O_CREAT | O_WRONLY | O_TRUNC)) == -1)
		fatal("cvs_client_merged: open: %s: %s",
		    fpath, strerror(errno));

	cvs_remote_receive_file(fd, flen);

	tv[0].tv_sec = now;
	tv[0].tv_usec = 0;
	tv[1] = tv[0];

	if (futimes(fd, tv) == -1)
		fatal("cvs_client_merged: futimes: %s", strerror(errno));

	if (fchmod(fd, fmode) == -1)
		fatal("cvs_client_merged: fchmod: %s", strerror(errno));

	(void)close(fd);

	free(rpath);
}

void
cvs_client_removed(char *data)
{
	CVSENTRIES *entlist;
	char *rpath, *filename, fpath[PATH_MAX];

	if (data == NULL)
		fatal("Missing argument for Removed");

	rpath = cvs_remote_input();
	if ((filename = strrchr(rpath, '/')) == NULL)
		fatal("bad rpath in cvs_client_removed: %s", rpath);
	filename++;

	entlist = cvs_ent_open(data);
	cvs_ent_remove(entlist, filename);

	(void)xsnprintf(fpath, PATH_MAX, "%s/%s", data, filename);
	(void)unlink(fpath);

	free(rpath);
}

void
cvs_client_remove_entry(char *data)
{
	CVSENTRIES *entlist;
	char *filename, *rpath;

	if (data == NULL)
		fatal("Missing argument for Remove-entry");

	rpath = cvs_remote_input();
	if ((filename = strrchr(rpath, '/')) == NULL)
		fatal("bad rpath in cvs_client_remove_entry: %s", rpath);
	filename++;

	entlist = cvs_ent_open(data);
	cvs_ent_remove(entlist, filename);

	free(rpath);
}

void
cvs_client_set_static_directory(char *data)
{
	FILE *fp;
	char *dir, fpath[PATH_MAX];

	if (data == NULL)
		fatal("Missing argument for Set-static-directory");

	STRIP_SLASH(data);

	dir = cvs_remote_input();
	free(dir);

	if (cvs_cmdop == CVS_OP_EXPORT)
		return;

	(void)xsnprintf(fpath, PATH_MAX, "%s/%s",
	    data, CVS_PATH_STATICENTRIES);

	if ((fp = fopen(fpath, "w+")) == NULL) {
		cvs_log(LP_ERRNO, "%s", fpath);
		return;
	}
	(void)fclose(fp);
}

void
cvs_client_clear_static_directory(char *data)
{
	char *dir, fpath[PATH_MAX];

	if (data == NULL)
		fatal("Missing argument for Clear-static-directory");

	STRIP_SLASH(data);

	dir = cvs_remote_input();
	free(dir);

	if (cvs_cmdop == CVS_OP_EXPORT)
		return;

	(void)xsnprintf(fpath, PATH_MAX, "%s/%s",
	    data, CVS_PATH_STATICENTRIES);

	(void)cvs_unlink(fpath);
}

void
cvs_client_set_sticky(char *data)
{
	FILE *fp;
	char *dir, *tag, tagpath[PATH_MAX];

	if (data == NULL)
		fatal("Missing argument for Set-sticky");

	STRIP_SLASH(data);

	dir = cvs_remote_input();
	tag = cvs_remote_input();

	if (cvs_cmdop == CVS_OP_EXPORT)
		goto out;

	client_check_directory(data, dir);

	(void)xsnprintf(tagpath, PATH_MAX, "%s/%s", data, CVS_PATH_TAG);

	if ((fp = fopen(tagpath, "w+")) == NULL) {
		cvs_log(LP_ERRNO, "%s", tagpath);
		goto out;
	}

	(void)fprintf(fp, "%s\n", tag);
	(void)fclose(fp);
out:
	free(tag);
	free(dir);
}

void
cvs_client_clear_sticky(char *data)
{
	char *dir, tagpath[PATH_MAX];

	if (data == NULL)
		fatal("Missing argument for Clear-sticky");

	STRIP_SLASH(data);

	dir = cvs_remote_input();

	if (cvs_cmdop == CVS_OP_EXPORT) {
		free(dir);
		return;
	}

	client_check_directory(data, dir);

	(void)xsnprintf(tagpath, PATH_MAX, "%s/%s", data, CVS_PATH_TAG);
	(void)unlink(tagpath);

	free(dir);
}


/*
 * cvs_client_initlog()
 *
 * Initialize protocol logging if the CVS_CLIENT_LOG environment variable is
 * set.  In this case, the variable's value is used as a path to which the
 * appropriate suffix is added (".in" for client input and ".out" for server
 * output).
 */
static void
cvs_client_initlog(void)
{
	u_int i;
	char *env, *envdup, buf[PATH_MAX], fpath[PATH_MAX];
	char rpath[PATH_MAX], timebuf[CVS_TIME_BUFSZ], *s;
	struct stat st;
	time_t now;
	struct passwd *pwd;

	/* avoid doing it more than once */
	if (cvs_client_logon)
		return;

	if ((env = getenv("CVS_CLIENT_LOG")) == NULL)
		return;

	envdup = xstrdup(env);
	if ((s = strchr(envdup, '%')) != NULL)
		*s = '\0';

	if (strlcpy(buf, env, sizeof(buf)) >= sizeof(buf))
		fatal("cvs_client_initlog: truncation");

	if (strlcpy(rpath, envdup, sizeof(rpath)) >= sizeof(rpath))
		fatal("cvs_client_initlog: truncation");

	free(envdup);

	s = buf;
	while ((s = strchr(s, '%')) != NULL) {
		s++;
		switch (*s) {
		case 'c':
			if (strlcpy(fpath, cmdp->cmd_name, sizeof(fpath)) >=
			    sizeof(fpath))
				fatal("cvs_client_initlog: truncation");
			break;
		case 'd':
			time(&now);
			ctime_r(&now, timebuf);
			timebuf[strcspn(timebuf, "\n")] = '\0';
			if (strlcpy(fpath, timebuf, sizeof(fpath)) >=
			    sizeof(fpath))
				fatal("cvs_client_initlog: truncation");
			break;
		case 'p':
			(void)xsnprintf(fpath, sizeof(fpath), "%d", getpid());
			break;
		case 'u':
			if ((pwd = getpwuid(getuid())) != NULL) {
				if (strlcpy(fpath, pwd->pw_name,
				    sizeof(fpath)) >= sizeof(fpath))
					fatal("cvs_client_initlog: truncation");
			} else {
				fpath[0] = '\0';
			}
			endpwent();
			break;
		default:
			fpath[0] = '\0';
			break;
		}

		if (fpath[0] != '\0') {
			if (strlcat(rpath, "-", sizeof(rpath)) >= sizeof(rpath))
				fatal("cvs_client_initlog: truncation");

			if (strlcat(rpath, fpath, sizeof(rpath))
			    >= sizeof(rpath))
				fatal("cvs_client_initlog: truncation");
		}
	}

	for (i = 0; i < UINT_MAX; i++) {
		(void)xsnprintf(fpath, sizeof(fpath), "%s-%d.in", rpath, i);

		if (stat(fpath, &st) != -1)
			continue;

		if (errno != ENOENT)
			fatal("cvs_client_initlog() stat failed '%s'",
			    strerror(errno));

		break;
	}

	if ((cvs_client_inlog_fd = open(fpath,
	    O_RDWR | O_CREAT | O_TRUNC, 0644)) == -1) {
		fatal("cvs_client_initlog: open `%s': %s",
		    fpath, strerror(errno));
	}

	for (i = 0; i < UINT_MAX; i++) {
		(void)xsnprintf(fpath, sizeof(fpath), "%s-%d.out", rpath, i);

		if (stat(fpath, &st) != -1)
			continue;

		if (errno != ENOENT)
			fatal("cvs_client_initlog() stat failed '%s'",
			    strerror(errno));

		break;
	}

	if ((cvs_client_outlog_fd = open(fpath,
	    O_RDWR | O_CREAT | O_TRUNC, 0644)) == -1) {
		fatal("cvs_client_initlog: open `%s': %s",
		    fpath, strerror(errno));
	}

	cvs_client_logon = 1;
}
@


1.124
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.123 2010/09/29 18:14:52 nicm Exp $	*/
d193 1
a193 1
	xfree(entry);
d276 1
a276 1
	xfree(resp);
d342 1
a342 1
	xfree(data);
d364 1
a364 1
	xfree(cmd);
d394 1
a394 1
	xfree(buf);
d442 2
a443 4
		if (tag != NULL)
			xfree(tag);
		if (date != NULL)
			xfree(date);
d445 2
a446 5
	if (d != NULL)
		xfree(d);

	if (lastdir != NULL)
		xfree(lastdir);
d635 1
a635 1
	xfree(dir);
d640 1
a640 1
	xfree(e);
d683 1
a683 1
	xfree(entry);
d728 1
a728 1
	xfree(len);
d731 1
a731 1
	xfree(mode);
d740 1
a740 1
	xfree(en);
d765 1
a765 1
	xfree(entry);
d786 1
a786 1
	xfree(rpath);
d824 1
a824 1
	xfree(repo);
d829 1
a829 1
	xfree(len);
d832 1
a832 1
	xfree(mode);
d842 1
a842 1
	xfree(entry);
d863 1
a863 1
	xfree(rpath);
d886 1
a886 1
	xfree(rpath);
d906 1
a906 1
	xfree(rpath);
d921 1
a921 1
	xfree(dir);
d947 1
a947 1
	xfree(dir);
d987 2
a988 2
	xfree(tag);
	xfree(dir);
d1004 1
a1004 1
		xfree(dir);
d1013 1
a1013 1
	xfree(dir);
d1052 1
a1052 1
	xfree(envdup);
@


1.123
log
@Support for update -C, from zinovik.

ok tobias xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.122 2010/07/23 21:46:05 ray Exp $	*/
d18 1
a18 1
#include <sys/param.h>
d402 1
a402 1
	char *d, *date, fpath[MAXPATHLEN], repo[MAXPATHLEN], *tag;
d409 1
a409 1
	cvs_get_repository_path(dir, repo, MAXPATHLEN);
d414 1
a414 1
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
d703 1
a703 1
	char repo[MAXPATHLEN], *entry;
d706 1
a706 1
	char sticky[CVS_ENT_MAXLINELEN], fpath[MAXPATHLEN];
d717 1
a717 1
	cvs_get_repository_path(".", repo, MAXPATHLEN);
d818 2
a819 2
	repo = xmalloc(MAXPATHLEN);
	cvs_get_repository_path(".", repo, MAXPATHLEN);
d875 1
a875 1
	char *rpath, *filename, fpath[MAXPATHLEN];
d888 1
a888 1
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s", data, filename);
d918 1
a918 1
	char *dir, fpath[MAXPATHLEN];
d931 1
a931 1
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
d944 1
a944 1
	char *dir, fpath[MAXPATHLEN];
d957 1
a957 1
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
d967 1
a967 1
	char *dir, *tag, tagpath[MAXPATHLEN];
d982 1
a982 1
	(void)xsnprintf(tagpath, MAXPATHLEN, "%s/%s", data, CVS_PATH_TAG);
d999 1
a999 1
	char *dir, tagpath[MAXPATHLEN];
d1015 1
a1015 1
	(void)xsnprintf(tagpath, MAXPATHLEN, "%s/%s", data, CVS_PATH_TAG);
d1034 2
a1035 2
	char *env, *envdup, buf[MAXPATHLEN], fpath[MAXPATHLEN];
	char rpath[MAXPATHLEN], timebuf[CVS_TIME_BUFSZ], *s;
@


1.122
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.121 2009/04/04 11:29:57 joris Exp $	*/
d527 6
d534 9
@


1.121
log
@properly expand modules if requested by the client,
this option is needed so gnu cvs clients can play along
properly when running checkout <module> in a remote setup.

if we do not support this, gnu cvs refuses to send us any
existing files already on disk and opencvs will consider everything
as NEEDS_CHECKOUT, instead of running an update on existing stuff.

problem noticed by fgsch@@
commited with opencvs, but please everybody else
do not use opencvs to commit yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.120 2009/04/01 06:41:58 joris Exp $	*/
d138 1
a138 1
	bp = cvs_buf_alloc(512);
d144 1
a144 1
			cvs_buf_putc(bp, ' ');
d147 1
a147 1
		cvs_buf_puts(bp, cvs_responses[i].name);
d150 2
a151 2
	cvs_buf_putc(bp, '\0');
	d = cvs_buf_release(bp);
@


1.120
log
@in client mode, be sure to consider the file modified if a conflict
exists in the CVS/Entries file, otherwise the server has no way
of determining if the user has resolved it or not.

also in client mode, send a conflict as Â"+=" not "+" alone, so other
cvs implementations get it.

commited entirely with opencvs,
with permission by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.119 2009/02/23 21:28:57 tobias Exp $	*/
d58 1
a76 1
	{ "expand-modules",		0,	NULL, 0 },
@


1.119
log
@Properly convert between gmt and localtime for unchanged files as client.
Problem reported by Jesus Sanchez (zexel08 at gmail dot com).

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.118 2009/02/21 14:50:53 joris Exp $	*/
d496 1
a496 1
			len = strlcat(timebuf, "+", sizeof(timebuf));
@


1.118
log
@use FILE_ON_DISK flags when we need to verify if a file
exists in the working copy or not instead of checking fd being -1
since this can differ in server or local mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.117 2009/02/13 20:50:15 joris Exp $	*/
d648 2
a649 1
		ctime_r(&ent->ce_mtime, timebuf);
@


1.117
log
@be more sane in handling the given repository path
in cvs_client_updated().
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.116 2008/06/14 03:19:15 joris Exp $	*/
d522 1
a522 1
		if (cf->fd != -1)
@


1.116
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.115 2008/06/11 02:19:13 tobias Exp $	*/
d689 1
a689 1
	char *en, *mode, *len, *rpath;
d708 5
a712 2
	(void)xsnprintf(fpath, sizeof(fpath), "%s/%s", data,
	    strrchr(rpath, '/'));
@


1.115
log
@Avoid possible NULL pointer dereferences by using reentrant versions
of time functions.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.114 2008/06/10 05:01:36 tobias Exp $	*/
a191 1
	cvs_ent_close(entlist, ENT_SYNC);
a670 1
	cvs_ent_close(entlist, ENT_SYNC);
a748 1
		cvs_ent_close(ent, ENT_SYNC);
a827 1
	cvs_ent_close(ent, ENT_SYNC);
a867 1
	cvs_ent_close(entlist, ENT_SYNC);
a890 1
	cvs_ent_close(entlist, ENT_SYNC);
@


1.114
log
@We have a cvs_buf_puts implementation now, also use cvs_buf_putc instead
of cvs_buf_append where appropiate.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.113 2008/04/24 19:13:56 tobias Exp $	*/
d30 1
d460 1
a460 1
	struct tm *datetm;
d507 1
a507 1
			datetm = gmtime(&(cf->file_ent->ce_date));
d509 1
a509 1
			    "D"CVS_DATE_FMT, datetm);
d617 1
a617 1
	struct tm *datetm;
d656 1
a656 1
			datetm = gmtime(&(newent->ce_date));
d658 1
a658 1
			    "D"CVS_DATE_FMT, datetm);
d687 1
a687 1
	struct tm *datetm;
d723 2
a724 1
	asctime_r(gmtime(&now), timebuf);
d734 1
a734 1
		datetm = gmtime(&(e->ce_date));
d736 1
a736 1
		    "D"CVS_DATE_FMT, datetm);
d788 1
d825 2
a826 1
	asctime_r(gmtime(&now), timebuf);
d1022 1
a1022 1
	char rpath[MAXPATHLEN], *s;
d1057 3
a1059 1
			if (strlcpy(fpath, ctime(&now), sizeof(fpath)) >=
@


1.113
log
@Use a fixed string in case of vasprintf() error instead of relying on
strerror().  Although our vasprintf() sets errno, we cannot rely on it on
other systems.

ok ray (who spotted this issue), xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.112 2008/04/18 20:26:07 tobias Exp $	*/
d143 1
a143 1
			cvs_buf_append(bp, " ", 1);
d146 1
a146 2
		cvs_buf_append(bp, cvs_responses[i].name,
		    strlen(cvs_responses[i].name));
@


1.112
log
@Properly check memory allocation in client code.  While at it, unified
vasprintf() check across OpenCVS code base.

Based on a diff by Jacek Masiulaniec.

ok (and unification requested by) xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.111 2008/03/09 03:32:01 joris Exp $	*/
d325 1
a325 1
		fatal("cvs_client_send_request: %s", strerror(errno));
@


1.111
log
@revert one of tobias his changes, it broke remote for several commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.110 2008/03/09 00:36:30 tobias Exp $	*/
d316 1
d322 1
a322 1
	vasprintf(&data, fmt, ap);
d324 2
@


1.110
log
@Prevent sending of "Directory" messages for arguments in remote setup if
the specified files (or directories) do not exist.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.109 2008/03/08 20:52:36 tobias Exp $	*/
d460 1
a460 1
	if (cf->file_type != CVS_FILE || (cf->fd == -1 && cf->file_ent == NULL))
@


1.109
log
@Set umask (and cvs_umask) to system's umask in local and client mode.
Also zap umask(0);umask(mask); calls, we have cvs_umask for this.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.108 2008/02/29 21:43:57 joris Exp $	*/
d460 1
a460 1
	if (cf->file_type != CVS_FILE)
@


1.108
log
@handle file permissions and owners properly.
matches what gnu cvs does.

fixes the fact that we couldnt update group writable files.

problem report & diff testing by David Crawshaw.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.107 2008/02/28 20:00:56 joris Exp $	*/
d679 1
a679 1
	mode_t fmode, mask;
d717 1
a717 3
	mask = umask(0);
	umask(mask);
	fmode &= ~mask;
d779 1
a779 1
	mode_t fmode, mask;
d817 1
a817 3
	mask = umask(0);
	umask(mask);
	fmode &= ~mask;
@


1.107
log
@do not fatal() on CVS_METHOD_EXT, since we actually support this.
reported & diff tested by Geerd-Dietger Hoffmann
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.106 2008/02/27 22:34:04 joris Exp $	*/
d754 1
d832 1
@


1.106
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.105 2008/02/11 20:33:11 tobias Exp $	*/
a211 1
	case CVS_METHOD_EXT:
@


1.105
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.104 2008/02/10 14:08:52 xsa Exp $	*/
d528 1
a528 1
		cvs_remote_send_file(cf->file_path);
@


1.104
log
@+ #define CVS_DATE_FMT   "%Y.%m.%d.%H.%M.%S"
...and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.103 2008/02/10 12:34:37 joris Exp $	*/
d137 1
a137 1
	bp = cvs_buf_alloc(512, BUF_AUTOEXT);
@


1.103
log
@handle date tags if we receive / send them
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.102 2008/02/09 20:04:00 xsa Exp $	*/
d506 2
a507 2
			strftime(sticky, sizeof(sticky),
			    "D%Y.%m.%d.%H.%M.%S", datetm);
d655 2
a656 2
			strftime(sticky, sizeof(sticky),
			    "D%Y.%m.%d.%H.%M.%S", datetm);
d734 2
a735 1
		strftime(sticky, sizeof(sticky), "D%Y.%m.%d.%H.%M.%S", datetm);
@


1.102
log
@Introduce cvs_ent_line_str() - formats CVS/Entries lines.
OK tobias@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.101 2008/02/09 12:48:23 joris Exp $	*/
d458 1
d504 4
d615 1
d650 1
a650 1
		if (newent->ce_tag != NULL)
d653 5
d685 1
d730 1
a730 1
	if (e->ce_tag != NULL)
d732 4
@


1.101
log
@remote improvements:

- make sure the client creates the correct CVS/Repository when running
  checkout if there was no -d targetdir specified.
- allow -D to work remotely for both checkout and update.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.100 2008/02/05 21:49:29 tobias Exp $	*/
d159 1
a159 1
	char entry[CVS_ENT_MAXLINELEN], *parent, *base, *p;
d186 3
a188 1
	(void)xsnprintf(entry, CVS_ENT_MAXLINELEN, "D/%s////", base);
d193 2
d610 1
a610 1
	char *dir, *e, entry[CVS_ENT_MAXLINELEN], rev[CVS_REV_BUFSZ];
d651 5
a655 3
	(void)xsnprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s%s/%s/%s/%s",
	    newent->ce_name, (newent->ce_status == CVS_ENT_REMOVED) ? "-" : "",
	    rev, timebuf, newent->ce_opts ? newent->ce_opts : "", sticky);
d660 2
d675 1
a675 1
	char repo[MAXPATHLEN], entry[CVS_ENT_MAXLINELEN];
d722 5
a726 3
	(void)xsnprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s/%s/%s",
	    e->ce_name, revbuf, timebuf,
	    e->ce_opts ? e->ce_opts : "", sticky);
d735 2
@


1.100
log
@When server sends CheckedIn use the supplied option and tag -- not the
one already in our CVS/Entries.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.99 2008/02/03 18:18:44 tobias Exp $	*/
d164 1
a164 1
	if (module_repo_root == NULL) {
@


1.99
log
@Added rdiff support.  In order to do this, some output and option fixes
had to be done for diff, too.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.98 2008/02/03 17:20:14 joris Exp $	*/
d642 1
a642 2
			    ent->ce_tag);
		newent->ce_opts = ent->ce_opts;
@


1.98
log
@better CVSROOT/module support, includes remote support and modules
that are not aliases (-a);

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.97 2008/02/03 15:57:25 tobias Exp $	*/
d89 1
a89 1
	{ "rdiff",		0,	NULL, 0 },
@


1.97
log
@Like i wrote in last commit, it's supposed to be sys/time.h, not sys/times.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.96 2008/02/03 15:08:04 tobias Exp $	*/
d111 1
a111 1
static void	 client_check_directory(char *);
d156 1
a156 1
client_check_directory(char *data)
d159 1
a159 1
	char entry[CVS_ENT_MAXLINELEN], *parent, *base;
d163 9
d670 2
a671 2
	char *en, *mode, *len, *fpath, *rpath, *wdir;
	char sticky[CVS_ENT_MAXLINELEN];
a675 2
	client_check_directory(data);

d681 1
d689 2
a690 3
	fpath = rpath + strlen(repo) + 1;
	if ((wdir = dirname(fpath)) == NULL)
		fatal("cvs_client_updated: dirname: %s", strerror(errno));
d722 1
a722 1
		ent = cvs_ent_open(wdir);
a763 2
	client_check_directory(data);

d769 2
a930 1
	xfree(dir);
d936 1
a936 1
	client_check_directory(data);
d949 1
a962 1
	xfree(dir);
d964 2
a965 1
	if (cvs_cmdop == CVS_OP_EXPORT)
d967 1
d969 1
a969 1
	client_check_directory(data);
d973 2
@


1.96
log
@(f)utimes takes sys/time.h
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.95 2008/02/01 21:09:59 xsa Exp $	*/
d21 1
a21 1
#include <sys/times.h>
@


1.95
log
@Make cvs_requests struct more readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.94 2008/02/01 17:18:59 tobias Exp $	*/
d21 1
@


1.94
log
@Added rannotate support

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.93 2008/01/31 22:09:05 xsa Exp $	*/
d77 31
a107 40
	{ "ci",				0,	cvs_server_commit,
	    REQ_NEEDDIR },
	{ "co",				0,	cvs_server_checkout,
	    REQ_NEEDDIR },
	{ "update",			0,	cvs_server_update,
	    REQ_NEEDDIR },
	{ "diff",			0,	cvs_server_diff, REQ_NEEDDIR },
	{ "log",			0,	cvs_server_log, REQ_NEEDDIR },
	{ "rlog",			0,	cvs_server_rlog, 0 },
	{ "add",			0,	cvs_server_add, REQ_NEEDDIR },
	{ "remove",			0,	cvs_server_remove,
	    REQ_NEEDDIR },
	{ "update-patches",		0,	cvs_server_update_patches, 0 },
	{ "gzip-file-contents",		0,	NULL, 0 },
	{ "status",			0,	cvs_server_status,
	    REQ_NEEDDIR },
	{ "rdiff",			0,	NULL, 0 },
	{ "tag",			0,	cvs_server_tag, REQ_NEEDDIR },
	{ "rtag",			0,	cvs_server_rtag, 0 },
	{ "import",			0,	cvs_server_import,
	    REQ_NEEDDIR },
	{ "admin",			0,	cvs_server_admin, REQ_NEEDDIR },
	{ "export",			0,	cvs_server_export,
	    REQ_NEEDDIR },
	{ "history",			0,	NULL, 0 },
	{ "release",			0,	cvs_server_release,
	    REQ_NEEDDIR },
	{ "watch-on",			0,	NULL, 0 },
	{ "watch-off",			0,	NULL, 0 },
	{ "watch-add",			0,	NULL, 0 },
	{ "watch-remove",		0,	NULL, 0 },
	{ "watchers",			0,	NULL, 0 },
	{ "editors",			0,	NULL, 0 },
	{ "init",			0,	cvs_server_init, 0 },
	{ "annotate",			0,	cvs_server_annotate,
	    REQ_NEEDDIR },
	{ "rannotate",			0,	cvs_server_rannotate, 0 },
	{ "noop",			0,	NULL, 0 },
	{ "version",			0,	cvs_server_version, 0 },
	{ "",				-1,	NULL, 0 }
@


1.93
log
@Zap trailing whitespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.92 2008/01/31 19:51:40 xsa Exp $	*/
d113 1
a113 1
	{ "rannotate",			0,	NULL, 0 },
@


1.92
log
@Make use of CVS_REV_BUFSZ everywhere for `sticky'.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.91 2008/01/29 11:55:30 tobias Exp $	*/
d1088 1
a1088 1
	if ((cvs_client_outlog_fd = open(fpath, 
@


1.91
log
@Properly check if an argument has been supplied for "Removed"

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.90 2008/01/21 16:36:46 tobias Exp $	*/
d453 1
a453 1
	char rev[CVS_REV_BUFSZ], timebuf[CVS_TIME_BUFSZ], sticky[32];
@


1.90
log
@Fixed export to be fully functional and compliant to GNU cvs in local and
remote setups.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.89 2008/01/10 11:20:29 tobias Exp $	*/
d831 3
@


1.89
log
@Added support for rtag in local and remote setups (with interoperability
with GNU cvs).  Basically we already had rtag in place as tag is supposed
to work with revisions in working directory, but our implementation was
wrong.  Fixed that on the fly as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.88 2008/01/10 10:08:22 tobias Exp $	*/
d99 2
a100 1
	{ "export",			0,	NULL, 0 },
d173 3
d721 6
a726 3
	ent = cvs_ent_open(wdir);
	cvs_ent_add(ent, entry);
	cvs_ent_close(ent, ENT_SYNC);
a873 3
	if (cvs_cmdop == CVS_OP_EXPORT)
		return;

d882 3
a899 3
	if (cvs_cmdop == CVS_OP_EXPORT)
		return;

d908 3
a922 3
	if (cvs_cmdop == CVS_OP_EXPORT)
		return;

d932 3
a954 3
	if (cvs_cmdop == CVS_OP_EXPORT)
		return;

d962 3
@


1.88
log
@another strcspn() round
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.87 2008/01/10 10:05:40 tobias Exp $	*/
d95 1
a95 1
	{ "rtag",			0,	NULL, 0 },
@


1.87
log
@Simply the use of cmdp and cvs_command by zapping cvs_command and working
solely with cmdp.  This remedies some reliability issues with invalid
commands supplied and also fixes a GNU cvs style incompatibility with
release command.

> Based on patch from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.86 2008/01/10 09:48:51 tobias Exp $	*/
d479 1
a479 2
			if (timebuf[strlen(timebuf) - 1] == '\n')
				timebuf[strlen(timebuf) - 1] = '\0';
d702 1
a702 2
	if (timebuf[strlen(timebuf) - 1] == '\n')
		timebuf[strlen(timebuf) - 1] = '\0';
d791 1
a791 2
	if (timebuf[strlen(timebuf) - 1] == '\n')
		timebuf[strlen(timebuf) - 1] = '\0';
@


1.86
log
@Properly free entry

> Patch from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.85 2008/01/10 09:47:05 tobias Exp $	*/
d1011 1
a1011 1
			if (strlcpy(fpath, cvs_command, sizeof(fpath)) >=
@


1.85
log
@Ignore CVS directories during import in remote setups. assert()ed GNU
cvs server and was unwanted behaviour anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.84 2008/01/10 09:41:52 tobias Exp $	*/
d799 1
@


1.84
log
@Properly handle "cvs add" on a client/server setup with GNU cvs as a client.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.83 2007/11/11 09:51:49 tobias Exp $	*/
d460 1
a460 1
	if (cf->file_ent != NULL) {
@


1.83
log
@If a file has modifications in it (i.e. cvs update on modified files),
reapply umask as done with unmodified files.  Sticks at GNU cvs behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.82 2007/10/07 18:12:48 chl Exp $	*/
d503 3
d601 1
a617 3
	ctime_r(&ent->ce_mtime, timebuf);
	if (timebuf[strlen(timebuf) - 1] == '\n')
		timebuf[strlen(timebuf) - 1] = '\0';
d620 23
a642 2
	if (ent->ce_tag != NULL)
		(void)xsnprintf(sticky, sizeof(sticky), "T%s", ent->ce_tag);
d646 1
a646 1
	    rev, timebuf, ent->ce_opts ? ent->ce_opts : "", sticky);
a647 1
	cvs_ent_free(ent);
@


1.82
log
@nb is an int, so it should be compared to an int.

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.81 2007/09/22 15:30:29 tobias Exp $	*/
d728 1
a728 1
	mode_t fmode;
d766 3
@


1.81
log
@Support for checkout with a local repository already in place.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.80 2007/09/17 18:36:54 tobias Exp $	*/
d416 1
a416 1
		if (tag != NULL && nb != NULL) {
@


1.80
log
@Print error messages sent by server on stderr. While at it, replaced
cvs_printf in cvs_client_m with puts (no need of cvs_printf's abilities
here).

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.79 2007/09/10 19:11:08 joris Exp $	*/
d401 1
a401 3
	if (cvs_cmdop == CVS_OP_CHECKOUT && strcmp(dir, "."))
		return;
	else if (cvs_cmdop != CVS_OP_RLOG)
@


1.79
log
@remove my addition of portnumber for rsh in CVSROOT.
while it sounds like a "good" idea some people convinced me otherwise.

mostly because this breaks compat with GNU cvs.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.78 2007/09/10 14:06:14 joris Exp $	*/
d583 1
a583 1
	cvs_printf("%s\n", data);
d592 1
a592 1
	cvs_printf("%s\n", data);
@


1.78
log
@Allow port specification in our CVSROOT which is used for our
ssh connection to our server.

Example: joris@@somehost.com:2222:/cvs

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.77 2007/09/07 19:36:05 tobias Exp $	*/
a234 5
		}

		if (current_cvsroot->cr_port != NULL) {
			argv[argc++] = "-p";
			argv[argc++] = current_cvsroot->cr_port;
@


1.77
log
@Added support for single file checkout.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.76 2007/09/07 19:18:41 tobias Exp $	*/
d235 5
@


1.76
log
@Do not use global option -V (GNU cvs doesn't understand it), be very
verbose per default on server-side instead.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.75 2007/09/02 12:16:24 tobias Exp $	*/
d401 3
a403 1
	if (cvs_cmdop != CVS_OP_RLOG)
@


1.75
log
@OpenCVS server init-support with OpenCVS and GNU cvs clients.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.74 2007/09/02 11:11:12 tobias Exp $	*/
d282 2
a283 1
	if (verbosity == 0)
d285 8
a292 3

	/* Be quiet. This is the default in OpenCVS. */
	cvs_client_send_request("Global_option -q");
a298 3

	if (verbosity == 2)
		cvs_client_send_request("Global_option -V");
@


1.74
log
@Log all commands sent with cvs_remote_output(), not just
cvs_client_send_request(). Simplified logging code while at it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.73 2007/09/01 15:41:34 joris Exp $	*/
d109 1
a109 1
	{ "init",			0,	cvs_server_init, REQ_NEEDDIR },
@


1.73
log
@s/free/xfree
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.72 2007/08/30 11:07:18 joris Exp $	*/
a326 16

	if (cvs_client_inlog_fd != -1) {
		BUF *bp;

		bp = cvs_buf_alloc(strlen(data), BUF_AUTOEXT);

		if (cvs_buf_append(bp, data, strlen(data)) < 0)
			fatal("cvs_client_send_request: cvs_buf_append");

		cvs_buf_putc(bp, '\n');

		if (cvs_buf_write_fd(bp, cvs_client_inlog_fd) < 0)
			fatal("cvs_client_send_request: cvs_buf_write_fd");

		cvs_buf_free(bp);
	}
@


1.72
log
@properly send our log message to the server using Argumentx, so we
no longer break when the log message has multiple lines.

from Tobias Stoeckmann, thanks for doing my work!
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.71 2007/07/17 20:29:58 xsa Exp $	*/
d397 1
a397 1
	free(buf);
@


1.71
log
@Forgot this part about rlog not needing the Directory request to be sent.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.70 2007/07/17 16:13:39 xsa Exp $	*/
d377 21
@


1.70
log
@Do not send the Directory request when using the rlog command.
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.69 2007/07/03 13:22:42 joris Exp $	*/
d85 1
a85 1
	{ "rlog",			0,	cvs_server_rlog, REQ_NEEDDIR },
@


1.69
log
@Rework the way opencvs works in relation to files in the Attic/:

Previously, files in the 'Attic/' were linked into our filelist as being
'Attic/filename,v' this caused unneeded stress on certain functions
like cvs_file_classify() who had to do pointer voodoo to split out
the 'Attic/' part and do other very weird stuff to normalize the pathname
of these files.

Instead, we handle these files early in the start when we
build the fileslist in cvs_repository_getdir(). When encountering
the 'Attic/' directory, we recurse in it if required but instead of
using the 'Attic/' directory component as our base directory we stick
with the directory name where 'Attic/' resides in, resulting in the
correct filename while maintaining the correct RCSpath for the file.

This made the following things a lot easier:
(and in most cases actually fixed the below points)

- status with files in Attic/.
- checking out HEAD repositories with files in Attic/.
- checking out repositories with -rTAG.
- updating with -rTAG.

and as an added bonus the following now also works:

- correctly creating CVS/Tag in both local and remote mode thus
  allowing update/status/and more to work correctly with the tagged tree.
  (thanks to the correct handling of -rTAG cases).
- resetting tags with opencvs -A properly works too now.

This is a major step forward into the usability
of OpenCVS when it comes to maintaining multiple tagged trees, the next
logical step would be to fix commiting to branches.

enjoy you -stable cowards.

tested by myself, xsa, niallo and ckuethe
thanks guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.68 2007/06/29 12:42:05 xsa Exp $	*/
d393 2
a394 1
	cvs_client_send_request("Directory %s\n%s", dir, repo);
@


1.68
log
@Server-side bits for release command.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.67 2007/06/28 21:38:09 xsa Exp $	*/
d170 1
a170 1
	cvs_mkpath(data);
d637 1
d678 5
d684 3
a686 2
	(void)xsnprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s/%s/", e->ce_name,
	    revbuf, timebuf, e->ce_opts ? e->ce_opts : "");
d897 2
d928 2
d931 1
a931 1
	(void)cvs_unlink(tagpath);
@


1.67
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.66 2007/06/27 20:42:19 joris Exp $	*/
d101 2
a102 1
	{ "release",			0,	NULL, 0 },
@


1.66
log
@have the server be more strict about the requests the client
sends that need a 'Directory' request first, so we do not
end up with very weird and possibly insecure behaviour.

more soon!

ok niallo@@ ray@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.65 2007/06/27 03:58:16 joris Exp $	*/
d439 1
a439 1
	char rev[16], timebuf[64], sticky[32];
d588 2
a589 2
	char *dir, *e, entry[CVS_ENT_MAXLINELEN], rev[16], timebuf[64];
	char sticky[CVS_ENT_MAXLINELEN];
d633 3
a635 2
	char timebuf[32], repo[MAXPATHLEN], *rpath, entry[CVS_ENT_MAXLINELEN];
	char *en, *mode, revbuf[32], *len, *fpath, *wdir;
d716 1
a716 1
	char timebuf[32], *repo, *rpath, *entry, *mode;
@


1.65
log
@We were missing the needed clue/magic to have our remote setup
handle files that have been removed from the repository
correctly, which resulted in them still being in the working copy
after doing an update.

noticed and diff tested by ckuethe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.64 2007/06/26 02:24:10 niallo Exp $	*/
d40 8
a47 4
	{ "Static-directory",	0,	cvs_server_static_directory, REQ_NEEDED },
	{ "Sticky",		0,	cvs_server_sticky, REQ_NEEDED },
	{ "Entry",		0,	cvs_server_entry, REQ_NEEDED },
	{ "Modified",		0,	cvs_server_modified, REQ_NEEDED },
d49 2
a50 1
	{ "Unchanged",		0,	cvs_server_unchanged, REQ_NEEDED },
d77 12
a88 8
	{ "ci",				0,	cvs_server_commit, 0 },
	{ "co",				0,	cvs_server_checkout, 0 },
	{ "update",			0,	cvs_server_update, 0 },
	{ "diff",			0,	cvs_server_diff, 0 },
	{ "log",			0,	cvs_server_log, 0 },
	{ "rlog",			0,	cvs_server_rlog, 0 },
	{ "add",			0,	cvs_server_add, 0 },
	{ "remove",			0,	cvs_server_remove, 0 },
d91 2
a92 1
	{ "status",			0,	cvs_server_status, 0 },
d94 1
a94 1
	{ "tag",			0,	cvs_server_tag, 0 },
d96 3
a98 2
	{ "import",			0,	cvs_server_import, 0 },
	{ "admin",			0,	cvs_server_admin, 0 },
d108 3
a110 2
	{ "init",			0,	cvs_server_init, 0 },
	{ "annotate",			0,	cvs_server_annotate, 0 },
@


1.64
log
@add support for cvs rlog.
from Mickey.

ok joris@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.63 2007/05/26 02:50:46 ray Exp $	*/
d770 14
a783 1
	char *dir;
d785 1
a785 2
	dir = cvs_remote_input();
	xfree(dir);
@


1.63
log
@Increase sticky tag buffer size.

Fix suggested by otto and xsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.62 2007/05/25 22:36:47 ray Exp $	*/
d77 1
a77 1
	{ "rlog",			0,	NULL, 0 },
@


1.62
log
@Call fatal() if we are missing an argument.  From Tobias Stoeckmann.

OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.61 2007/05/17 03:26:33 ray Exp $	*/
d577 1
a577 1
	char sticky[16];
@


1.61
log
@Remove nonsensical dereference.  From tbert.

OK niallo && xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.60 2007/05/16 09:52:47 xsa Exp $	*/
d528 3
a530 1
	sp = data;
d556 3
d565 3
d579 3
d624 3
d706 3
d782 3
d806 3
d832 3
d855 3
d884 3
@


1.60
log
@open() returns -1 on error, not NULL. From Tobias Stoeckmann.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.59 2007/02/22 06:42:09 otto Exp $	*/
d768 1
a768 1
	*filename++;
@


1.59
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.58 2007/02/17 18:23:43 xsa Exp $	*/
d960 1
a960 1
	    O_RDWR | O_CREAT | O_TRUNC, 0644)) == NULL) {
d979 1
a979 1
	    O_RDWR | O_CREAT | O_TRUNC, 0644)) == NULL) {
@


1.58
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.57 2007/01/31 21:07:35 xsa Exp $	*/
d18 12
a29 1
#include "includes.h"
a31 2
#include "log.h"
#include "diff.h"
@


1.57
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.56 2007/01/28 02:04:45 joris Exp $	*/
d373 2
a374 3
	if (cvs_path_cat(dir, CVS_PATH_STATICENTRIES, fpath, MAXPATHLEN) >=
	    MAXPATHLEN)
		fatal("cvs_client_senddir: truncation");
d782 2
a783 3
	if (cvs_path_cat(data, CVS_PATH_STATICENTRIES, fpath, MAXPATHLEN) >=
	    MAXPATHLEN)
		fatal("cvs_client_set_static_directory: truncation");
d805 2
a806 3
	if (cvs_path_cat(data, CVS_PATH_STATICENTRIES, fpath, MAXPATHLEN) >=
	    MAXPATHLEN)
		fatal("cvs_client_clear_static_directory: truncation");
d826 1
a826 2
	if (cvs_path_cat(data, CVS_PATH_TAG, tagpath, MAXPATHLEN) >= MAXPATHLEN)
		fatal("cvs_client_clear_sticky: truncation");
d852 1
a852 3
	if (cvs_path_cat(data, CVS_PATH_TAG, tagpath, MAXPATHLEN) >= MAXPATHLEN)
		fatal("cvs_client_clear_sticky: truncation");

@


1.56
log
@add merging support in both local and remote sides.
tested by many, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.55 2007/01/27 19:38:19 otto Exp $	*/
a142 1
	int l;
d159 1
a159 3
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "D/%s////", base);
	if (l == -1 || l >= CVS_ENT_MAXLINELEN)
		fatal("client_check_directory: overflow");
a417 1
	int l;
d463 1
a463 1
			l = snprintf(sticky, sizeof(sticky), "T%s",
a464 2
			if (l == -1 || l >= (int)sizeof(sticky))
				fatal("cvs_client_sendfile: overflow");
a557 1
	int l;
d578 2
a579 5
	if (ent->ce_tag != NULL) {
		l = snprintf(sticky, sizeof(sticky), "T%s", ent->ce_tag);
		if (l == -1 || l >= (int)sizeof(sticky))
			fatal("cvs_client_checkedin: overflow");
	}
d581 1
a581 1
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s%s/%s/%s/%s",
a583 2
	if (l == -1 || l >= CVS_ENT_MAXLINELEN)
		fatal("cvs_client_checkedin: overflow");
d594 1
a594 1
	int l, fd;
d642 1
a642 1
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s/%s/", e->ce_name,
a643 2
	if (l == -1 || l >= CVS_ENT_MAXLINELEN)
		fatal("cvs_client_updated: overflow");
a873 1
	int l;
d916 1
a916 1
			snprintf(fpath, sizeof(fpath), "%d", getpid());
d944 1
a944 3
		l = snprintf(fpath, sizeof(fpath), "%s-%d.in", rpath, i);
		if (l == -1 || l >= (int)sizeof(fpath))
			fatal("cvs_client_initlog: overflow");
d963 1
a963 3
		l = snprintf(fpath, sizeof(fpath), "%s-%d.out", rpath, i);
		if (l == -1 || l >= (int)sizeof(fpath))
			fatal("cvs_client_initlog: overflow");
@


1.55
log
@preserve flags in Entries in the remote case. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.54 2007/01/26 21:59:11 otto Exp $	*/
d460 3
d688 66
@


1.54
log
@more fixe size buffers on the stack. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.53 2007/01/26 21:48:17 xsa Exp $	*/
d470 1
a470 1
		cvs_client_send_request("Entry /%s/%s%s/%s//%s",
d651 2
a652 2
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s//", e->ce_name,
	    revbuf, timebuf);
@


1.53
log
@- support [-k mode] for the add command
- do not let the file keyword expension options (-k) disappear
from the Entries file when doing a commit/update/checkout
- be sure the expension mode gets written to the RCS file when a file
is added/committed in the first place
problems raised by otto@@; tests/ok otto@@ and joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.52 2007/01/26 11:19:44 joris Exp $	*/
d145 1
a145 1
	char *entry, *parent, *base;
a159 1
	entry = xmalloc(CVS_ENT_MAXLINELEN);
a166 2

	xfree(entry);
d564 2
a565 1
	char *dir, *entry, rev[16], timebuf[64], sticky[16];
d568 1
a568 1
	entry = cvs_remote_input();
d572 1
a572 1
	newent = cvs_ent_parse(entry);
d574 1
a574 3
	xfree(entry);

	entry = xmalloc(CVS_ENT_MAXLINELEN);
a597 2

	xfree(entry);
d611 2
a612 2
	char timebuf[32], repo[MAXPATHLEN], *rpath, *entry, *mode;
	char revbuf[32], *len, *fpath, *wdir;
d617 1
a617 1
	entry = cvs_remote_input();
d648 2
a649 2
	e = cvs_ent_parse(entry);
	xfree(entry);
a650 1
	entry = xmalloc(CVS_ENT_MAXLINELEN);
a659 1
	xfree(entry);
@


1.52
log
@Handle CVS/Entries and file timestamp correctly so we do
not mistakenly see a file as Modified while it is not.

As a result, we can remove the very hackish cvs_hack_time() and
GNU cvs and opencvs should almost get along now.

lotsa help and okay The otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.51 2007/01/26 10:42:06 otto Exp $	*/
d475 2
a476 1
		   rev, timebuf, sticky);
d592 1
a592 1
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s%s/%s//%s/",
d594 1
a594 1
	    rev, timebuf, sticky);
@


1.51
log
@respect umask; ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.50 2007/01/25 18:56:33 otto Exp $	*/
d649 1
a649 2
	now = cvs_hack_time(now, 0);
	ctime_r(&now, timebuf);
a673 1
	now = cvs_hack_time(now, 0);
@


1.50
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.49 2007/01/18 16:45:52 joris Exp $	*/
d610 1
a610 1
	mode_t fmode;
d644 3
@


1.49
log
@import improvements:
- add support for remote import in opencvs client and server.
- do not free already free'd buffers in import_update()
- do not append a '\0' to the loaded file buffer, this was bad behaviour

makes import work fine both locally and remotely.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.48 2007/01/17 17:54:50 joris Exp $	*/
d368 1
a368 1
	char *d, *date, *fpath, *repo, *tag;
a374 1
	repo = xmalloc(MAXPATHLEN);
a378 3
	xfree(repo);

	fpath = xmalloc(MAXPATHLEN);
a385 2
	xfree(fpath);

d616 1
a616 1
	char timebuf[32], *repo, *rpath, *entry, *mode;
a625 1
	repo = xmalloc(MAXPATHLEN);
a635 1
	xfree(repo);
d724 1
a724 1
	char *dir, *fpath;
a733 1
	fpath = xmalloc(MAXPATHLEN);
d740 1
a740 1
		goto out;
a742 2
out:
	xfree(fpath);
d748 1
a748 1
	char *dir, *fpath;
a757 1
	fpath = xmalloc(MAXPATHLEN);
a762 2

	xfree(fpath);
d769 1
a769 1
	char *dir, *tag, *tagpath;
a779 1
	tagpath = xmalloc(MAXPATHLEN);
a790 1
	xfree(tagpath);
d797 1
a797 1
	char *dir, *tagpath;
a806 1
	tagpath = xmalloc(MAXPATHLEN);
a810 2

	xfree(tagpath);
@


1.48
log
@add support for remote checkout in both our client and server,
with this the last real dependency to actually be able to use opencvs
in a remote setup has been added.

based upon an initial diff from xsa@@
'kay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.47 2007/01/16 09:14:19 xsa Exp $	*/
d77 1
a77 1
	{ "import",			0,	NULL, 0 },
@


1.47
log
@handle the export command in cvs_client_{set,clear}_sticky().
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.46 2007/01/13 15:29:34 joris Exp $	*/
d64 1
a64 1
	{ "co",				0,	NULL, 0 },
d634 2
@


1.46
log
@- remote update now works again, with new rcs api
- we no longer hold the entire file in memory when sending or receiving it
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.45 2007/01/11 02:35:55 joris Exp $	*/
d783 3
d812 3
@


1.45
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.44 2007/01/03 22:28:30 joris Exp $	*/
a613 1
	BUF *bp;
a671 1
	bp = cvs_remote_receive_file(flen);
d676 1
a676 5
	if (cvs_buf_write_fd(bp, fd) == -1)
		fatal("cvs_client_updated: cvs_buf_write_fd failed for %s",
		    fpath);

	cvs_buf_free(bp);
@


1.44
log
@add support for 'remove' in a remote setup.
testing appriciated, as always.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.43 2007/01/03 21:00:43 joris Exp $	*/
d178 3
@


1.43
log
@revert changes made in 1.40 - it breaks add in a remote setup
because opencvs server does not support 'wrapper-sendme-rcsOptions'
for the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.42 2007/01/03 19:27:28 joris Exp $	*/
d594 3
a596 2
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s//%s/",
	    newent->ce_name, rev, timebuf, sticky);
a713 1
	int l;
d715 1
a715 1
	char *filename, *rpath, *fpath;
a721 7
	fpath = xmalloc(MAXPATHLEN);
	l = snprintf(fpath, MAXPATHLEN, "%s%s", data, filename);
	if (l == -1 || l >= MAXPATHLEN)
		fatal("cvs_client_remove_entry: overflow");

	xfree(rpath);

d723 1
a723 1
	cvs_ent_remove(entlist, fpath);
d726 1
a726 1
	xfree(fpath);
@


1.42
log
@fix CVS_CLIENT_LOG logging, we were missing parts
which was making it very hard to correctly debug remote connections.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.41 2007/01/02 23:55:15 joris Exp $	*/
a276 3

	if (cvs_cmdop == CVS_OP_ADD || cvs_cmdop == CVS_OP_IMPORT)
		cvs_client_send_request("wrapper-sendme-rcsOptions");
@


1.41
log
@- fix cvs_client_remove_entry to correctly handle the passed data
- when commiting in a remote setup, allow the opencvs server to send
  the correct response to the client when a file has been removed
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.40 2006/12/21 22:32:30 xsa Exp $	*/
d108 2
a109 2
static int	cvs_client_inlog_fd = -1;
static int	cvs_client_outlog_fd = -1;
a347 28

	if (cvs_client_outlog_fd != -1) {
		BUF *bp;

		bp = cvs_buf_alloc(strlen(cmd), BUF_AUTOEXT);

		if (cvs_buf_append(bp, cmd, strlen(cmd)) < 0)
			fatal("cvs_client_read_response: cvs_buf_append");

		if (cvs_buf_append(bp,
		    (data == NULL) ? "" : " ",
		    (data == NULL) ? 0 : 1) < 0) {
			fatal("cvs_client_read_response: cvs_buf_append");
		}

		if (cvs_buf_append(bp,
		    (data == NULL) ? "" : data,
		    (data == NULL) ? 0 : strlen(data)) < 0) {
			fatal("cvs_client_read_response: cvs_buf_append");
		}

		cvs_buf_putc(bp, '\n');

		if (cvs_buf_write_fd(bp, cvs_client_outlog_fd) < 0)
			fatal("cvs_client_read_response: cvs_buf_write_fd");

		cvs_buf_free(bp);
	}
@


1.40
log
@if the add or import command is issued, send the wrapper-sendme-rcsOptions
request to the server.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.39 2006/12/20 16:25:27 xsa Exp $	*/
d744 1
d746 6
a751 2
	struct cvs_ent *ent;
	char *dir, *entry;
d753 4
a756 3
	dir = cvs_remote_input();
	entry = cvs_remote_input();
	xfree(dir);
d758 1
a758 2
	if ((ent = cvs_ent_parse(entry)) == NULL)
		fatal("cvs_client_remove_entry: cvs_ent_parse failed");
d761 1
a761 3

	cvs_ent_remove(entlist, ent->ce_name);
	cvs_ent_free(ent);
d764 1
a764 1
	xfree(entry);
@


1.39
log
@remove debug message left in previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.38 2006/12/19 16:04:40 xsa Exp $	*/
d277 3
@


1.38
log
@add some bits to handle Remove-entry.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.37 2006/12/19 15:12:59 joris Exp $	*/
a747 2

	cvs_log(LP_TRACE, "cvs_client_remove_entry(%s)", entry);
@


1.37
log
@- Introduce a way for the command code to recognize what the server replied.
- Modify the add command so it uses the above method to correctly enter
  added files in CVS/Entries if in a remote setup.

ok xsa@@

... And no a shark didnt eat me.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.36 2006/12/19 14:11:21 xsa Exp $	*/
d741 3
a743 1
	char *dir;
d746 1
d748 13
@


1.36
log
@add client-side support for Set-static-directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.35 2006/12/19 11:46:39 xsa Exp $	*/
d112 2
d539 1
d546 1
@


1.35
log
@add client-side support for Clear-static-directory, Clear-sticky and
Set-sticky requests. Set-sticky needs more work though.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.34 2006/12/15 15:40:28 xsa Exp $	*/
d741 28
@


1.34
log
@add support for "Static-directory" request.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.33 2006/12/15 13:12:14 xsa Exp $	*/
d742 72
@


1.33
log
@dummy support for update-patches request.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.32 2006/12/15 09:50:37 xsa Exp $	*/
d389 1
d391 1
a391 1
	char *d, *date, *repo, *tag;
d404 10
@


1.32
log
@server-side Static-directory bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.31 2006/12/15 08:26:18 xsa Exp $	*/
d71 1
a71 1
	{ "update-patches",		0,	NULL, 0 },
@


1.31
log
@adjust the Directory request by sending the repository on a new line too.
matches gnu cvs behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.30 2006/12/15 08:02:53 xsa Exp $	*/
d31 1
a47 1
	{ "Static-directory",		0,	NULL, 0 },
@


1.30
log
@server-side Sticky bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.29 2006/12/14 15:13:17 xsa Exp $	*/
a396 2
	cvs_client_send_request("Directory %s", dir);

d399 3
a401 1
	cvs_remote_output(repo);
@


1.29
log
@add support for the "Sticky" request; client-side only for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.28 2006/11/27 16:19:59 xsa Exp $	*/
d31 1
a47 1
	{ "Sticky",			0,	NULL, 0 },
@


1.28
log
@sort sent requests;
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.27 2006/11/27 16:04:10 xsa Exp $	*/
d389 4
a392 1
	char *repo;
d403 30
@


1.27
log
@hook up annotate server bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.26 2006/11/14 15:39:41 xsa Exp $	*/
d253 2
a274 2

	cvs_client_send_request("UseUnchanged");
@


1.26
log
@Add support for the "Set" request.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.25 2006/11/14 10:10:19 xsa Exp $	*/
d89 1
a89 1
	{ "annotate",			0,	NULL, 0 },
@


1.25
log
@add rlog and rannotate commands requests,
and sort them all while there so we get the same client/server output as
GNU CVS; easier to debug.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.24 2006/11/14 09:59:54 xsa Exp $	*/
d39 1
a59 1
	{ "Set",			0,	NULL, 0 },
d173 1
d275 4
@


1.24
log
@dummy support for Argumentx request.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.23 2006/11/14 09:47:52 xsa Exp $	*/
d55 1
d65 1
d67 6
a72 1
	{ "tag",			0,	cvs_server_tag, 0 },
a73 7
	{ "admin",			0,	cvs_server_admin, 0 },
	{ "history",			0,	NULL, 0 },
	{ "watchers",			0,	NULL, 0 },
	{ "editors",			0,	NULL, 0 },
	{ "annotate",			0,	NULL, 0 },
	{ "log",			0,	cvs_server_log, 0 },
	{ "export",			0,	NULL, 0 },
d75 1
a76 2
	{ "init",			0,	cvs_server_init, 0 },
	{ "update",			0,	cvs_server_update, 0 },
d78 4
a81 3
	{ "add",			0,	cvs_server_add, 0 },
	{ "remove",			0,	cvs_server_remove, 0 },
	{ "version",			0,	cvs_server_version, 0 },
d86 5
a90 1
	{ "release",			0,	NULL, 0 },
d92 1
a92 3
	{ "update-patches",		0,	NULL, 0 },
	{ "gzip-file-contents",		0,	NULL, 0 },
	{ "wrapper-sendme-rcsOptions",	0,	NULL, 0 },
@


1.23
log
@Bring back version command. Still needs tweaks to make the
gnu cvs client<->opencvs server setup work. Rest works fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.22 2006/11/13 15:55:54 xsa Exp $	*/
a29 1
	{ "Global_option",	0,	cvs_server_globalopt, REQ_NEEDED },
d37 2
a53 1
	{ "Argumentx",			0,	NULL, 0 },
@


1.22
log
@Add missing server-side bits for init...
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.21 2006/11/13 12:57:03 xsa Exp $	*/
d81 1
@


1.21
log
@Add server-side bits for admin command.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.20 2006/11/10 11:02:05 xsa Exp $	*/
d76 1
a76 1
	{ "init",			0,	NULL, 0 },
@


1.20
log
@do not forget to send -l and -q Global options too.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.19 2006/11/10 10:53:06 xsa Exp $	*/
d67 1
a67 1
	{ "admin",			0,	NULL, 0 },
@


1.19
log
@send Global options -n -Q -r to the server.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.18 2006/11/09 14:00:14 xsa Exp $	*/
d249 3
d257 3
@


1.18
log
@cvs init remote bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.17 2006/11/09 09:24:28 xsa Exp $	*/
d249 10
a258 1
	if (cvs_trace)
@


1.17
log
@remote tag command support joins the party!
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.16 2006/11/08 20:20:42 xsa Exp $	*/
d239 2
a240 1
	cvs_client_send_request("Root %s", current_cvsroot->cr_dir);
@


1.16
log
@bring back support for CVS_CLIENT_LOG that was removed with
the proto.c removal a while ago.... OK ray@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.15 2006/10/31 15:23:40 xsa Exp $	*/
d65 1
a65 1
	{ "tag",			0,	NULL, 0 },
@


1.15
log
@a step ahead in opencvs add|remove remote support.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.14 2006/07/20 15:14:22 joris Exp $	*/
d93 15
a107 4
static void client_check_directory(char *);
static char *client_get_supported_responses(void);
static char *lastdir = NULL;
static int end_of_response = 0;
d237 2
d282 17
d320 28
d349 1
d673 125
@


1.14
log
@Chad Dougherty <crd@@andrew.cmu.edu> teaches me how to spell 'supported' correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.13 2006/07/09 04:39:43 joris Exp $	*/
d79 2
a80 2
	{ "add",			0,	NULL, 0 },
	{ "remove",			0,	NULL, 0 },
@


1.13
log
@put the sticky tag if any in the correct place in the entries line when sending it to the server
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.12 2006/07/09 01:47:20 joris Exp $	*/
d168 1
a168 1
		fatal("the specified connection method is not support");
@


1.12
log
@more straightforward trace (-t) output, too much is just too noisy.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.11 2006/07/08 01:02:03 joris Exp $	*/
d375 1
a375 1
		cvs_client_send_request("Entry /%s/%s%s/%s/%s/",
d601 4
@


1.11
log
@handle "." special in client_check_directory();
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.10 2006/07/08 00:34:20 joris Exp $	*/
d268 1
a307 2
	cvs_log(LP_TRACE, "cvs_client_senddir(%s)", dir);

a333 2

	cvs_log(LP_TRACE, "cvs_client_sendfile(%s)", cf->file_path);
a408 1
	cvs_log(LP_TRACE, "cvs_client_ok()");
a414 1
	cvs_log(LP_TRACE, "cvs_client_error()");
a467 2
	cvs_log(LP_TRACE, "cvs_client_checkedin(%s)", data);

a518 2
	cvs_log(LP_TRACE, "cvs_client_updated(%s)", data);

a595 1
	cvs_log(LP_TRACE, "cvs_client_merged(%s)", data);
a600 1
	cvs_log(LP_TRACE, "cvs_client_removed(%s)", data);
a606 2

	cvs_log(LP_TRACE, "cvs_client_remove_entry(%s)", data);
@


1.10
log
@allow update in remote mode to work a bit better and
create any missing directories or new directories with -d
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.9 2006/07/07 17:37:17 joris Exp $	*/
d140 3
@


1.9
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 1
d124 29
d336 3
d524 2
@


1.8
log
@All the protocol code is in proto.c now
@
text
@d3 1
a3 2
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
d5 11
a15 19
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d18 1
a18 14
#include <sys/types.h>
#include <sys/stat.h>

#include <fcntl.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include <sysexits.h>
#ifdef CVS_ZLIB
#include <zlib.h>
#endif
d22 2
a23 1
#include "proto.h"
d25 13
d39 83
d123 5
a127 7
extern int   verbosity;
extern int   cvs_compress;
extern char *cvs_rsh;
extern int   cvs_trace;
extern int   cvs_nolog;
extern int   cvs_readonly;

d129 24
a152 2
static int  cvs_client_sendinfo (struct cvsroot *);
static int  cvs_client_initlog  (void);
d154 2
d157 2
a158 58

static int    cvs_server_infd = -1;
static int    cvs_server_outfd = -1;
static FILE  *cvs_server_in;
static FILE  *cvs_server_out;

/* protocol log files, if the CVS_CLIENT_LOG environment variable is used */
static FILE  *cvs_server_inlog;
static FILE  *cvs_server_outlog;

static char   cvs_client_buf[4096];



/*
 * cvs_client_connect()
 *
 * Open a client connection to the cvs server whose address is given in
 * the <root> variable.  The method used to connect depends on the
 * setting of the CVS_RSH variable.
 * Returns 0 on success, or -1 on failure.
 */

int
cvs_client_connect(struct cvsroot *root)
{
	int argc, infd[2], outfd[2];
	pid_t pid;
	char *argv[16], *cvs_server_cmd;

	if (pipe(infd) == -1) {
		cvs_log(LP_ERRNO,
		    "failed to create input pipe for client connection");
		return (-1);
	}

	if (pipe(outfd) == -1) {
		cvs_log(LP_ERRNO,
		    "failed to create output pipe for client connection");
		(void)close(infd[0]);
		(void)close(infd[1]);
		return (-1);
	}

	pid = fork();
	if (pid == -1) {
		cvs_log(LP_ERRNO, "failed to fork for cvs server connection");
		return (-1);
	}
	if (pid == 0) {
		if ((dup2(infd[0], STDIN_FILENO) == -1) ||
		    (dup2(outfd[1], STDOUT_FILENO) == -1)) {
			cvs_log(LP_ERRNO,
			    "failed to setup standard streams for cvs server");
			return (-1);
		}
		(void)close(infd[1]);
		(void)close(outfd[0]);
d163 1
a163 1
		if (root->cr_user != NULL) {
d165 1
a165 1
			argv[argc++] = root->cr_user;
d168 2
a169 7

		cvs_server_cmd = getenv("CVS_SERVER");
		if (cvs_server_cmd == NULL)
			cvs_server_cmd = "cvs";

		argv[argc++] = root->cr_host;
		argv[argc++] = cvs_server_cmd;
d173 3
d177 3
a179 2
		cvs_log(LP_ERRNO, "failed to exec");
		exit(EX_OSERR);
d182 7
a188 9
	/* we are the parent */
	cvs_server_infd = infd[1];
	cvs_server_outfd = outfd[0];

	cvs_server_in = fdopen(cvs_server_infd, "w");
	if (cvs_server_in == NULL) {
		cvs_log(LP_ERRNO, "failed to create pipe stream");
		return (-1);
	}
d190 2
a191 7
	cvs_server_out = fdopen(cvs_server_outfd, "r");
	if (cvs_server_out == NULL) {
		cvs_log(LP_ERRNO, "failed to create pipe stream");
		return (-1);
	}
	root->cr_srvin = cvs_server_in;
	root->cr_srvout = cvs_server_out;
d193 1
a193 3
	/* make the streams line-buffered */
	setvbuf(cvs_server_in, NULL, _IOLBF, 0);
	setvbuf(cvs_server_out, NULL, _IOLBF, 0);
d195 3
a197 2
	(void)close(infd[0]);
	(void)close(outfd[1]);
d199 2
a200 1
	cvs_client_initlog();
d202 2
a203 1
	cvs_client_sendinfo(root);
d205 2
a206 3
#ifdef CVS_ZLIB
	/* if compression was requested, initialize it */
#endif
d208 1
a208 1
	return (0);
d211 10
d222 2
a223 5
/*
 * cvs_client_disconnect()
 *
 * Disconnect from the cvs server.
 */
d225 3
a227 10
void
cvs_client_disconnect(struct cvsroot *root)
{
	cvs_log(LP_DEBUG, "closing client connection");
	(void)fclose(cvs_server_in);
	(void)fclose(cvs_server_out);
	cvs_server_in = NULL;
	cvs_server_out = NULL;
	cvs_server_infd = -1;
	cvs_server_outfd = -1;
d229 2
a230 5
	if (cvs_server_inlog != NULL)
		fclose(cvs_server_inlog);
	if (cvs_server_outlog != NULL)
		fclose(cvs_server_outlog);
}
d232 2
d235 3
a237 7
/*
 * cvs_client_sendln()
 *
 * Send a single line <line> string to the server.  The line is sent as is,
 * without any modifications.
 * Returns 0 on success, or -1 on failure.
 */
d239 2
a240 2
int
cvs_client_sendln(const char *line)
d242 2
a243 2
	int nl;
	size_t len;
d245 3
a247 2
	nl = 0;
	len = strlen(line);
d249 3
a251 2
	if ((len > 0) && (line[len - 1] != '\n'))
		nl = 1;
d253 2
a254 8
	if (cvs_server_inlog != NULL) {
		fputs(line, cvs_server_inlog);
		if (nl)
			fputc('\n', cvs_server_inlog);
	}
	fputs(line, cvs_server_in);
	if (nl)
		fputc('\n', cvs_server_in);
d256 2
a257 1
	return (0);
d260 5
d266 2
a267 5
/*
 * cvs_client_sendraw()
 *
 * Send the first <len> bytes from the buffer <src> to the server.
 */
d269 2
a270 2
int
cvs_client_sendraw(const void *src, size_t len)
d272 6
a277 5
	if (cvs_server_inlog != NULL)
		fwrite(src, sizeof(char), len, cvs_server_inlog);
	if (fwrite(src, sizeof(char), len, cvs_server_in) < len) {
		return (-1);
	}
d279 1
a279 2
	return (0);
}
d281 4
d286 4
a289 5
/*
 * cvs_client_recvraw()
 *
 * Receive the first <len> bytes from the buffer <src> to the server.
 */
d291 2
a292 2
ssize_t
cvs_client_recvraw(void *dst, size_t len)
d294 3
a296 1
	size_t ret;
d298 2
a299 7
	ret = fread(dst, sizeof(char), len, cvs_server_out);
	if (ret == 0)
		return (-1);
	if (cvs_server_outlog != NULL)
		fwrite(dst, sizeof(char), len, cvs_server_outlog);
	return (ssize_t)ret;
}
d301 1
d303 20
a322 6
/*
 * cvs_client_getln()
 *
 * Get a line from the server's output and store it in <lbuf>.  The terminating
 * newline character is stripped from the result.
 */
d324 9
a332 4
int
cvs_client_getln(char *lbuf, size_t len)
{
	size_t rlen;
d334 6
a339 4
	if (fgets(lbuf, len, cvs_server_out) == NULL) {
		if (ferror(cvs_server_out)) {
			cvs_log(LP_ERRNO, "failed to read line from server");
			return (-1);
d342 19
a360 2
		if (feof(cvs_server_out))
			*lbuf = '\0';
d362 1
d364 4
a367 2
	if (cvs_server_outlog != NULL)
		fputs(lbuf, cvs_server_outlog);
d369 3
a371 3
	rlen = strlen(lbuf);
	if ((rlen > 0) && (lbuf[rlen - 1] == '\n'))
		lbuf[--rlen] = '\0';
d373 5
a377 1
	return (0);
d380 6
d387 2
a388 11
/*
 * cvs_client_sendinfo()
 *
 * Initialize the connection status by first requesting the list of
 * supported requests from the server.  Then, we send the CVSROOT variable
 * with the `Root' request.
 * Returns 0 on success, or -1 on failure.
 */

static int
cvs_client_sendinfo(struct cvsroot *root)
d390 24
a413 10
	char *vresp;
	/*
	 * First, send the server the list of valid responses, then ask
	 * for valid requests
	 */

	vresp = cvs_resp_getvalid();
	if (vresp == NULL) {
		cvs_log(LP_ERR, "can't generate list of valid responses");
		return (-1);
d415 1
d417 5
a421 3
	if (cvs_client_sendreq(CVS_REQ_VALIDRESP, vresp, 0) < 0) {
	}
	free(vresp);
d423 5
a427 4
	if (cvs_client_sendreq(CVS_REQ_VALIDREQ, NULL, 1) < 0) {
		cvs_log(LP_ERR, "failed to get valid requests from server");
		return (-1);
	}
d429 7
a435 16
	/* not sure why, but we have to send this */
	if (cvs_client_sendreq(CVS_REQ_USEUNCHANGED, NULL, 0) < 0)
		return (-1);

	/* now share our global options with the server */
	if (verbosity == 1)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-q", 0);
	else if (verbosity == 0)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-Q", 0);

	if (cvs_nolog)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-l", 0);
	if (cvs_readonly)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-r", 0);
	if (cvs_trace)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-t", 0);
d437 1
a437 3
	/* now send the CVSROOT to the server */
	if (cvs_client_sendreq(CVS_REQ_ROOT, root->cr_dir, 0) < 0)
		return (-1);
d439 3
a441 2
	return (0);
}
d443 4
d448 1
a448 5
/*
 * cvs_client_senddir()
 *
 * Send a `Directory' request along with the 2 paths that follow it.
 */
d450 4
a453 4
int
cvs_client_senddir(const char *dir)
{
	char repo[MAXPATHLEN], buf[MAXPATHLEN];
d455 5
a459 6
	if (cvs_readrepo(dir, repo, sizeof(repo)) < 0) {
		repo[0] = '\0';
		strlcpy(buf, cvs_root->cr_dir, sizeof(buf));
	}
	else {
		snprintf(buf, sizeof(buf), "%s/%s", cvs_root->cr_dir, repo);
d462 9
a470 3
	if ((cvs_client_sendreq(CVS_REQ_DIRECTORY, dir, 0) < 0) ||
	    (cvs_client_sendln(buf) < 0))
		return (-1);
d472 1
a472 1
	return (0);
d475 66
d542 3
a544 7
/*
 * cvs_client_sendarg()
 *
 * Send the argument <arg> to the server.  The argument <append> is used to
 * determine if the argument should be simply appended to the last argument
 * sent or if it should be created as a new argument (0).
 */
d546 1
a546 6
int
cvs_client_sendarg(const char *arg, int append)
{
	return cvs_client_sendreq(((append == 0) ?
	    CVS_REQ_ARGUMENT : CVS_REQ_ARGUMENTX), arg, 0);
}
d548 4
d553 2
a554 6
/*
 * cvs_client_sendentry()
 *
 * Send an `Entry' request to the server along with the mandatory fields from
 * the CVS entry <ent> (which are the name and revision).
 */
d556 2
a557 4
int
cvs_client_sendentry(const struct cvs_ent *ent)
{
	char ebuf[128], numbuf[64];
d559 1
a559 2
	snprintf(ebuf, sizeof(ebuf), "/%s/%s///", ent->ce_name,
	    rcsnum_tostr(ent->ce_rev, numbuf, sizeof(numbuf)));
d561 1
a561 1
	return cvs_client_sendreq(CVS_REQ_ENTRY, ebuf, 0);
d564 5
d570 5
a574 9
/*
 * cvs_client_initlog()
 *
 * Initialize protocol logging if the CVS_CLIENT_LOG environment variable is
 * set.  In this case, the variable's value is used as a path to which the
 * appropriate suffix is added (".in" for server input and ".out" for server
 * output.
 * Returns 0 on success, or -1 on failure.
 */
d576 2
a577 2
static int
cvs_client_initlog(void)
d579 1
a579 23
	char *env, fpath[MAXPATHLEN];

	env = getenv("CVS_CLIENT_LOG");
	if (env == NULL)
		return (0);

	strlcpy(fpath, env, sizeof(fpath));
	strlcat(fpath, ".in", sizeof(fpath));
	cvs_server_inlog = fopen(fpath, "w");
	if (cvs_server_inlog == NULL) {
		cvs_log(LP_ERRNO, "failed to open server input log `%s'",
		    fpath);
		return (-1);
	}

	strlcpy(fpath, env, sizeof(fpath));
	strlcat(fpath, ".out", sizeof(fpath));
	cvs_server_outlog = fopen(fpath, "w");
	if (cvs_server_outlog == NULL) {
		cvs_log(LP_ERRNO, "failed to open server output log `%s'",
		    fpath);
		return (-1);
	}
d581 1
a581 3
	/* make the streams line-buffered */
	setvbuf(cvs_server_inlog, NULL, _IOLBF, 0);
	setvbuf(cvs_server_outlog, NULL, _IOLBF, 0);
d583 2
a584 1
	return (0);
@


1.7
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@@


1.6
log
@Make cvs_client_sendinfo() aware of its root context and remove the
exporting of cvs_root
@
text
@d44 1
a203 74
 * cvs_client_sendreq()
 *
 * Send a request to the server of type <rid>, with optional arguments
 * contained in <arg>, which should not be terminated by a newline.
 * The <resp> argument is 0 if no response is expected, or any other value if
 * a response is expected.
 * Returns 0 on success, or -1 on failure.
 */

int
cvs_client_sendreq(u_int rid, const char *arg, int resp)
{
	int ret;
	size_t len;
	char *rbp;
	const char *reqp;

	if (cvs_server_in == NULL) {
		cvs_log(LP_ERR, "cannot send request: Not connected");
		return (-1);
	}

	reqp = cvs_req_getbyid(rid);
	if (reqp == NULL) {
		cvs_log(LP_ERR, "unsupported request type %u", rid);
		return (-1);
	}

	snprintf(cvs_client_buf, sizeof(cvs_client_buf), "%s%s%s\n", reqp,
	    (arg == NULL) ? "" : " ", (arg == NULL) ? "" : arg);

	rbp = cvs_client_buf;

	if (cvs_server_inlog != NULL)
		fputs(cvs_client_buf, cvs_server_inlog);

	ret = fputs(cvs_client_buf, cvs_server_in);
	if (ret == EOF) {
		cvs_log(LP_ERRNO, "failed to send request to server");
		return (-1);
	}

	if (resp) {
		do {
			/* wait for incoming data */
			if (fgets(cvs_client_buf, sizeof(cvs_client_buf),
			    cvs_server_out) == NULL) {
				if (feof(cvs_server_out))
					return (0);
				cvs_log(LP_ERRNO,
				    "failed to read response from server");
				return (-1);
			}

			if (cvs_server_outlog != NULL)
				fputs(cvs_client_buf, cvs_server_outlog);

			if ((len = strlen(cvs_client_buf)) != 0) {
				if (cvs_client_buf[len - 1] != '\n') {
					/* truncated line */
				}
				else
					cvs_client_buf[--len] = '\0';
			}

			ret = cvs_resp_handle(cvs_client_buf);
		} while (ret == 0);
	}

	return (ret);
}


/*
a467 46

	return (0);
}


/*
 * cvs_client_sendfile()
 *
 */

int
cvs_client_sendfile(const char *path)
{
	int fd;
	ssize_t ret;
	char buf[4096];
	struct stat st;

	if (stat(path, &st) == -1) {
		cvs_log(LP_ERRNO, "failed to stat `%s'", path);
		return (-1);
	}

	fd = open(path, O_RDONLY, 0);
	if (fd == -1) {
		return (-1);
	}

	if (cvs_modetostr(st.st_mode, buf, sizeof(buf)) < 0)
		return (-1);

	cvs_client_sendln(buf);
	snprintf(buf, sizeof(buf), "%lld\n", st.st_size);
	cvs_client_sendln(buf);

	while ((ret = read(fd, buf, sizeof(buf))) != 0) {
		if (ret == -1) {
			cvs_log(LP_ERRNO, "failed to read file `%s'", path);
			return (-1);
		}

		cvs_client_sendraw(buf, (size_t)ret);

	}

	(void)close(fd);
@


1.5
log
@Only put a space in the client buffer if the request has a non-NULL
argument.  This is only for prettying and makes us closer to the
GNU behaviour
@
text
@a53 1
extern struct cvsroot *cvs_root;
d55 1
a55 4



static int  cvs_client_sendinfo (void);
d168 1
a168 1
	cvs_client_sendinfo();
d391 1
a391 1
cvs_client_sendinfo(void)
d414 4
d432 1
a432 5
	if (cvs_client_sendreq(CVS_REQ_ROOT, cvs_root->cr_dir, 0) < 0)
		return (-1);

	/* not sure why, but we have to send this */
	if (cvs_client_sendreq(CVS_REQ_USEUNCHANGED, NULL, 0) < 0)
@


1.4
log
@* prepare for an overhaul of the connection code by adding a cvsroot
  parameter to the cvs_client_connect() and cvs_client_disconnect()
  functions, so we rely less and less on a global variable
@
text
@d235 2
a236 2
	snprintf(cvs_client_buf, sizeof(cvs_client_buf), "%s %s\n", reqp,
	    (arg == NULL) ? "" : arg);
@


1.3
log
@* don't always return 0 in cvs_client_sendreq()
@
text
@d81 1
a81 1
 * the global <cvs_root> variable.  The method used to connect depends on the
d83 1
d87 1
a87 1
cvs_client_connect(void)
d125 1
a125 1
		if (cvs_root->cr_user != NULL) {
d127 1
a127 1
			argv[argc++] = cvs_root->cr_user;
d135 1
a135 1
		argv[argc++] = cvs_root->cr_host;
d160 2
d189 1
a189 1
cvs_client_disconnect(void)
@


1.2
log
@Remove the code that would avoid sending a `Directory' request if the
previous `Directory' request had sent the same dir, our code isn't as
stupid as it used to be
@
text
@d273 1
a273 1
	return (0);
@


1.1
log
@Initial revision
@
text
@a74 3
/* last directory sent with `Directory' */
static char   cvs_lastdir[MAXPATHLEN] = "";

d451 7
a457 8
	/* don't bother sending if it's the same as the last Directory sent */
	if (strcmp(dir, cvs_lastdir) == 0)
		return (0);

	if (cvs_readrepo(dir, repo, sizeof(repo)) < 0)
		return (-1);

	snprintf(buf, sizeof(buf), "%s/%s", cvs_root->cr_dir, repo);
a461 1
	strlcpy(cvs_lastdir, dir, sizeof(cvs_lastdir));
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
