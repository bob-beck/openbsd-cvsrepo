head	1.32;
access;
symbols
	OPENBSD_6_1:1.31.0.8
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.20
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.18
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.14
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.12
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.10
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.8
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.32
date	2017.08.28.19.33.20;	author otto;	state Exp;
branches;
next	1.31;
commitid	pt4iCZKa4LhAa1TL;

1.31
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.30;
commitid	O6jeJ0TRmiewrqMI;

1.30
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Uu5nFG3wCl0LACBb;

1.29
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2009.04.07.21.27.45;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2009.04.02.20.57.47;	author joris;	state Exp;
branches;
next	1.26;

1.26
date	2009.04.01.06.41.58;	author joris;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.21.14.50.53;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.12.07.16.14;	author joris;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.08.11.53.36;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2008.02.10.14.15.36;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.10.14.04.40;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.10.14.00.41;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.17.10.07.21;	author tobias;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.02.11.11.12;	author tobias;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.16.19.40.45;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.31.21.07.35;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.26.11.19.44;	author joris;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.26.08.35.23;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.25.06.44.11;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.24.21.24.48;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.18.16.45.52;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.13.15.29.34;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.03.19.27.28;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.10.01.32.32;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.09.01.47.20;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2006.07.08.00.34.20;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	;


desc
@@


1.32
log
@fix const related warnings; ok millert@@
@
text
@/*	$OpenBSD: remote.c,v 1.31 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* MAXBSIZE */
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "atomicio.h"
#include "cvs.h"
#include "remote.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

struct cvs_resp *
cvs_remote_get_response_info(const char *response)
{
	int i;

	for (i = 0; cvs_responses[i].supported != -1; i++) {
		if (!strcmp(cvs_responses[i].name, response))
			return (&(cvs_responses[i]));
	}

	return (NULL);
}

struct cvs_req *
cvs_remote_get_request_info(const char *request)
{
	int i;

	for (i = 0; cvs_requests[i].supported != -1; i++) {
		if (!strcmp(cvs_requests[i].name, request))
			return (&(cvs_requests[i]));
	}

	return (NULL);
}

void
cvs_remote_output(char *data)
{
	FILE *out;
	size_t len;
	char nl = '\n';

	if (cvs_server_active)
		out = stdout;
	else
		out = current_cvsroot->cr_srvin;

	fputs(data, out);
	fputs("\n", out);

	if (cvs_server_active == 0 && cvs_client_inlog_fd != -1) {
		len = strlen(data);
		if (atomicio(vwrite, cvs_client_inlog_fd, data, len) != len ||
		    atomicio(vwrite, cvs_client_inlog_fd, &nl, 1) != 1)
			fatal("failed to write to log file");
	}
}

char *
cvs_remote_input(void)
{
	FILE *in;
	size_t len;
	char nl = '\n';
	char *data, *ldata;

	if (cvs_server_active)
		in = stdin;
	else
		in = current_cvsroot->cr_srvout;

	data = fgetln(in, &len);
	if (data == NULL) {
		if (sig_received != 0)
			fatal("received signal %d", sig_received);

		if (cvs_server_active) {
			cvs_cleanup();
			exit(0);
		}

		fatal("the connection has been closed by the server");
	}

	if (data[len - 1] == '\n') {
		data[len - 1] = '\0';
		ldata = xstrdup(data);
	} else {
		ldata = xmalloc(len + 1);
		memcpy(ldata, data, len);
		ldata[len] = '\0';
	}

	if (cvs_server_active == 0 && cvs_client_outlog_fd != -1) {
		len = strlen(data);
		if (atomicio(vwrite, cvs_client_outlog_fd, data, len) != len ||
		    atomicio(vwrite, cvs_client_outlog_fd, &nl, 1) != 1)
			fatal("failed to write to log file");
	}

	return (ldata);
}

void
cvs_remote_receive_file(int fd, size_t len)
{
	FILE *in;
	char data[MAXBSIZE];
	size_t nread, nleft, toread;

	if (cvs_server_active)
		in = stdin;
	else
		in = current_cvsroot->cr_srvout;

	nleft = len;

	while (nleft > 0) {
		toread = MINIMUM(nleft, MAXBSIZE);

		nread = fread(data, sizeof(char), toread, in);
		if (nread == 0)
			fatal("error receiving file");

		if (atomicio(vwrite, fd, data, nread) != nread)
			fatal("failed to write %zu bytes", nread);

		if (cvs_server_active == 0 && cvs_client_outlog_fd != -1 &&
		    atomicio(vwrite, cvs_client_outlog_fd, data, nread)
		    != nread)
			fatal("failed to write to log file");

		nleft -= nread;
	}
}

void
cvs_remote_send_file(const char *path, int _fd)
{
	int fd;
	FILE *out, *in;
	size_t ret, rw;
	off_t total;
	struct stat st;
	char buf[18], data[MAXBSIZE];

	if (cvs_server_active)
		out = stdout;
	else
		out = current_cvsroot->cr_srvin;

	fd = dup(_fd);
	if (fd == -1)
		fatal("cvs_remote_send_file: dup: %s", strerror(errno));

	if (lseek(fd, 0, SEEK_SET) < 0)
		fatal("cvs_remote_send_file: %s: lseek: %s", path,
		    strerror(errno));

	if (fstat(fd, &st) == -1)
		fatal("cvs_remote_send_file: %s: fstat: %s", path,
		    strerror(errno));

	cvs_modetostr(st.st_mode, buf, sizeof(buf));
	cvs_remote_output(buf);

	(void)xsnprintf(buf, sizeof(buf), "%lld", st.st_size);
	cvs_remote_output(buf);

	if ((in = fdopen(fd, "r")) == NULL)
		fatal("cvs_remote_send_file: fdopen %s", strerror(errno));

	total = 0;
	while ((ret = fread(data, sizeof(char), MAXBSIZE, in)) != 0) {
		rw = fwrite(data, sizeof(char), ret, out);
		if (rw != ret)
			fatal("failed to write %zu bytes", ret);

		if (cvs_server_active == 0 && cvs_client_inlog_fd != -1 &&
		    atomicio(vwrite, cvs_client_inlog_fd, data, ret) != ret)
			fatal("failed to write to log file");

		total += ret;
	}

	if (total != st.st_size)
		fatal("length mismatch, %lld vs %lld", total, st.st_size);

	(void)fclose(in);
}

void
cvs_remote_send_file_buf(char *file, BUF *bp, mode_t mode)
{
	char buf[18];
	u_char *data;
	size_t len, ret;

	if (cvs_server_active != 1)
		fatal("cvs_remote_send_file_buf is server only");

	len = buf_len(bp);
	data = buf_release(bp);

	cvs_modetostr(mode, buf, sizeof(buf));
	cvs_remote_output(buf);

	(void)xsnprintf(buf, sizeof(buf), "%ld", len);
	cvs_remote_output(buf);

	ret = fwrite(data, sizeof(char), len, stdout);
	if (ret != len)
		cvs_log(LP_ERR, "warning: sent %s truncated", file);

	if (cvs_server_active == 0 && cvs_client_inlog_fd != -1 &&
	    atomicio(vwrite, cvs_client_inlog_fd, data, len) != len)
		fatal("failed to write to log file");

	free(data);
}

void
cvs_remote_classify_file(struct cvs_file *cf)
{
	struct stat st;
	CVSENTRIES *entlist;

	entlist = cvs_ent_open(cf->file_wd);
	cf->file_ent = cvs_ent_get(entlist, cf->file_name);

	if (cf->file_ent != NULL && cf->file_ent->ce_status != CVS_ENT_REG) {
		if (cf->file_ent->ce_status == CVS_ENT_ADDED) {
			if (cf->fd != -1)
				cf->file_status = FILE_ADDED;
			else
				cf->file_status = FILE_UNKNOWN;
		} else {
			cf->file_status = FILE_REMOVED;
		}

		return;
	}

	if (cf->file_ent != NULL) {
		if (cf->file_ent->ce_type == CVS_ENT_DIR)
			cf->file_type = CVS_DIR;
		else
			cf->file_type = CVS_FILE;
	}

	if (cf->fd != -1)
		cf->file_flags |= FILE_ON_DISK;

	if ((cf->file_flags & FILE_ON_DISK) && cf->file_ent != NULL) {
		if (fstat(cf->fd, &st) == -1)
			fatal("cvs_remote_classify_file(%s): %s", cf->file_path,
			    strerror(errno));

		if (st.st_mtime != cf->file_ent->ce_mtime ||
		    cf->file_ent->ce_conflict != NULL)
			cf->file_status = FILE_MODIFIED;
		else
			cf->file_status = FILE_UPTODATE;
	} else if (!(cf->file_flags & FILE_ON_DISK)) {
		cf->file_status = FILE_UNKNOWN;
	}

	if (cvs_cmdop == CVS_OP_IMPORT && cf->file_type == CVS_FILE)
		cf->file_status = FILE_MODIFIED;
}


void
cvs_validate_directory(const char *path)
{
	char *dir, *sp, *dp;

	dir = xstrdup(path);

	for (sp = dir; sp != NULL; sp = dp) {
		dp = strchr(sp, '/');
		if (dp != NULL)
			*(dp++) = '\0';

		if (!strcmp(sp, ".."))
			fatal("path validation failed!");
	}

	free(dir);
}
@


1.31
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.30 2015/01/16 06:40:07 deraadt Exp $	*/
d60 1
a60 1
cvs_remote_output(const char *data)
@


1.30
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.29 2010/07/23 21:46:05 ray Exp $	*/
d242 1
a242 1
	xfree(data);
d312 1
a312 1
	xfree(dir);
@


1.29
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.28 2009/04/07 21:27:45 joris Exp $	*/
d18 1
d31 2
d142 1
a142 1
		toread = MIN(nleft, MAXBSIZE);
@


1.28
log
@do not try to send a added file that is no longer on disk
towards the server.

problem spotted and diff tested by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.27 2009/04/02 20:57:47 joris Exp $	*/
d222 2
a223 2
	len = cvs_buf_len(bp);
	data = cvs_buf_release(bp);
@


1.27
log
@if ce_conflict != NULL, the file should be sent
to the server for verification.

commited with opencvs,
permission by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.26 2009/04/01 06:41:58 joris Exp $	*/
d252 6
a257 3
		if (cf->file_ent->ce_status == CVS_ENT_ADDED)
			cf->file_status = FILE_ADDED;
		else
d259 2
@


1.26
log
@in client mode, be sure to consider the file modified if a conflict
exists in the CVS/Entries file, otherwise the server has no way
of determining if the user has resolved it or not.

also in client mode, send a conflict as Â"+=" not "+" alone, so other
cvs implementations get it.

commited entirely with opencvs,
with permission by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.25 2009/02/21 14:50:53 joris Exp $	*/
d274 2
a275 1
		if (st.st_mtime != cf->file_ent->ce_mtime || cf->file_ent != NULL)
@


1.25
log
@use FILE_ON_DISK flags when we need to verify if a file
exists in the working copy or not instead of checking fd being -1
since this can differ in server or local mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.24 2008/06/14 03:19:15 joris Exp $	*/
d274 1
a274 1
		if (st.st_mtime != cf->file_ent->ce_mtime)
@


1.24
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.23 2008/06/12 07:16:14 joris Exp $	*/
d266 4
a269 1
	if (cf->fd != -1 && cf->file_ent != NULL) {
d278 1
a278 1
	} else if (cf->fd == -1) {
@


1.23
log
@completely kill the need for TMP_DIR when running checkout,
which gives us better performance among other things.

this is however disabled in a few cases:
1) whenever you run checkout over an existing tree (which acts as update)
2) whenever you specify -d or a module alias

we're planning on enabling this behaviour for case 2 in the future.

anoncvs sysadmins now love us even more.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.22 2008/03/08 11:53:36 joris Exp $	*/
a249 1
	cvs_ent_close(entlist, ENT_NOSYNC);
@


1.22
log
@correct usage of lseek(2);
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.21 2008/02/27 22:34:04 joris Exp $	*/
d210 30
@


1.21
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.20 2008/02/10 14:15:36 joris Exp $	*/
d176 1
a176 1
	if (lseek(fd, SEEK_SET, 0) < 0)
@


1.20
log
@cvs_validate_directory() was too paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.19 2008/02/10 14:04:40 joris Exp $	*/
d158 1
a158 1
cvs_remote_send_file(const char *path)
d172 7
a178 2
	if ((fd = open(path, O_RDONLY)) == -1)
		fatal("cvs_remote_send_file: %s: %s", path, strerror(errno));
d181 2
a182 1
		fatal("cvs_remote_send_file: %s: %s", path, strerror(errno));
@


1.19
log
@use cvs_validate_directory() in cvs_get_repository_path() as well,
since we want to make sure we have valid CVS/Repository content

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.18 2008/02/10 14:00:41 joris Exp $	*/
d254 1
a254 2
	if (cvs_server_active == 1 && path[0] == '/')
		fatal("No absolute directories allowed, go away.");
a255 1
	dir = xstrdup(path);
@


1.18
log
@introduce cvs_validate_directory(), which is used to check
directory path to make sure they do not fall outside the CVSROOT
or the working copy directory in a remote setup
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.17 2007/09/17 10:07:21 tobias Exp $	*/
d254 1
a254 1
	if (path[0] == '/')
@


1.17
log
@Imported atomicio interface.

Requested by ray@@, OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.16 2007/09/02 11:11:12 tobias Exp $	*/
d248 21
@


1.16
log
@Log all commands sent with cvs_remote_output(), not just
cvs_client_send_request(). Simplified logging code while at it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.15 2007/05/16 19:40:45 xsa Exp $	*/
d26 1
d60 1
d72 4
a75 2
		(void)write(cvs_client_inlog_fd, data, strlen(data));
		(void)write(cvs_client_inlog_fd, &nl, 1);
d115 4
a118 2
		(void)write(cvs_client_outlog_fd, data, strlen(data));
		(void)write(cvs_client_outlog_fd, &nl, 1);
d129 1
a129 1
	size_t nread, nwrite, nleft, toread;
d145 1
a145 2
		nwrite = write(fd, data, nread);
		if (nwrite != nread)
d148 4
a151 3
		if (cvs_server_active == 0 &&
		    cvs_client_outlog_fd != -1)
			(void)write(cvs_client_outlog_fd, data, nread);
d193 3
a195 2
		if (cvs_server_active == 0 && cvs_client_inlog_fd != -1)
			(void)write(cvs_client_inlog_fd, data, ret);
@


1.15
log
@In remote setup, write sent files to inlog (if specified) instead of outlog.
Matches GNU CVS' behaviour. From Tobias Stoeckmann.
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.14 2007/02/22 06:42:09 otto Exp $	*/
d59 1
d68 5
d80 1
d111 2
a112 13
		BUF *bp;

		bp = cvs_buf_alloc(strlen(ldata), BUF_AUTOEXT);

		if (cvs_buf_append(bp, ldata, strlen(ldata)) < 0)
			fatal("cvs_remote_input: cvs_buf_append");

		cvs_buf_putc(bp, '\n');

		if (cvs_buf_write_fd(bp, cvs_client_outlog_fd) < 0)
			fatal("cvs_remote_input: cvs_buf_write_fd");

		cvs_buf_free(bp);
@


1.14
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.13 2007/01/31 21:07:35 xsa Exp $	*/
d191 2
a192 3
		if (cvs_server_active == 0 &&
		    cvs_client_outlog_fd != -1)
			(void)write(cvs_client_outlog_fd, data, ret);
@


1.13
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.12 2007/01/26 11:19:44 joris Exp $	*/
d18 7
a24 1
#include "includes.h"
a26 2
#include "log.h"
#include "diff.h"
@


1.12
log
@Handle CVS/Entries and file timestamp correctly so we do
not mistakenly see a file as Modified while it is not.

As a result, we can remove the very hackish cvs_hack_time() and
GNU cvs and opencvs should almost get along now.

lotsa help and okay The otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.11 2007/01/26 08:35:23 otto Exp $	*/
d154 1
a154 1
	int l, fd;
d175 1
a175 3
	l = snprintf(buf, sizeof(buf), "%lld", st.st_size);
	if (l == -1 || l >= (int)sizeof(buf))
		fatal("cvs_remote_send_file: overflow");
@


1.11
log
@modestring can be 18 long
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.10 2007/01/25 18:56:33 otto Exp $	*/
a204 1
	time_t mtime;
d232 1
a232 2
		mtime = cvs_hack_time(st.st_mtime, 1);
		if (mtime != cf->file_ent->ce_mtime)
@


1.10
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.9 2007/01/25 06:44:11 otto Exp $	*/
d159 1
a159 1
	char buf[16], data[MAXBSIZE];
@


1.9
log
@plug a mem leak and wrong usage of strlcpy after fgetln. since fgetln
does not NUL-terminate, it is not ok to use strlcpy on the buffer.
ok opencvsgang@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.8 2007/01/24 21:24:48 otto Exp $	*/
d122 1
a122 1
	char *data;
a129 1
	data = xmalloc(MAXBSIZE);
a148 2

	xfree(data);
d159 1
a159 1
	char buf[16], *data;
a183 1
	data = xmalloc(MAXBSIZE);
a194 2

	xfree(data);
@


1.8
log
@user proper format string for size_t; file size is off_t; ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.7 2007/01/18 16:45:52 joris Exp $	*/
d92 1
d95 2
a96 3
		if (strlcpy(ldata, data, len) >= len)
			fatal("cvs_remote_input: truncation");
		data = ldata;
a97 2

	ldata = xstrdup(data);
@


1.7
log
@import improvements:
- add support for remote import in opencvs client and server.
- do not free already free'd buffers in import_update()
- do not append a '\0' to the loaded file buffer, this was bad behaviour

makes import work fine both locally and remotely.
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.6 2007/01/13 15:29:34 joris Exp $	*/
d144 1
a144 1
			fatal("failed to write %ld bytes", nread);
d161 2
a162 1
	size_t ret, rw, total;
d193 1
a193 1
			fatal("failed to write %ld bytes", ret);
d205 1
a205 1
		fatal("length mismatch, %ld vs %ld", total, st.st_size);
@


1.6
log
@- remote update now works again, with new rcs api
- we no longer hold the entire file in memory when sending or receiving it
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.5 2007/01/03 19:27:28 joris Exp $	*/
d248 3
@


1.5
log
@fix CVS_CLIENT_LOG logging, we were missing parts
which was making it very hard to correctly debug remote connections.
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.4 2006/07/10 01:32:32 joris Exp $	*/
d120 2
a121 2
BUF *
cvs_remote_receive_file(size_t len)
a122 1
	BUF *bp;
a123 1
	size_t ret;
d125 1
d132 9
a140 1
	bp = cvs_buf_alloc(len, BUF_AUTOEXT);
d142 7
a148 9
	if (len != 0) {
		data = xmalloc(len);
		ret = fread(data, sizeof(char), len, in);
		if (ret != len)
			fatal("length mismatch, expected %ld, got %ld",
			    len, ret);
		cvs_buf_set(bp, data, len, 0);
		xfree(data);
	}
d150 1
a150 3
	if (cvs_server_active == 0 && cvs_client_outlog_fd != -1) {
		if (cvs_buf_write_fd(bp, cvs_client_outlog_fd) < 0)
			fatal("cvs_remote_receive_file: cvs_buf_write_fd");
d153 1
a153 1
	return (bp);
a158 1
	BUF *bp;
d160 2
a161 2
	FILE *out;
	size_t ret;
d163 1
a163 1
	char buf[16], *fcont;
d184 9
a192 1
	bp = cvs_buf_load_fd(fd, BUF_AUTOEXT);
d194 5
a198 3
	if (cvs_server_active == 0 && cvs_client_inlog_fd != -1) {
		if (cvs_buf_write_fd(bp, cvs_client_inlog_fd) < 0)
			fatal("cvs_remote_send_file: cvs_buf_write");
d201 1
a201 1
	fcont = cvs_buf_release(bp);
d203 2
a204 7
	if (fcont != NULL) {
		ret = fwrite(fcont, sizeof(char), st.st_size, out);
		if (ret != st.st_size)
			fatal("tried to write %lld only wrote %ld",
			    st.st_size, ret);
		xfree(fcont);
	}
d206 1
a206 1
	(void)close(fd);
@


1.4
log
@handle 0 sized files correctly, tested by brad@@ thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.3 2006/07/09 01:47:20 joris Exp $	*/
d100 17
d145 5
d183 6
@


1.3
log
@more straightforward trace (-t) output, too much is just too noisy.
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.2 2006/07/08 00:34:20 joris Exp $	*/
d116 11
a126 4
	data = xmalloc(len);
	ret = fread(data, sizeof(char), len, in);
	if (ret != len)
		fatal("length mismatch, expected %ld, got %ld", len, ret);
a127 3
	bp = cvs_buf_alloc(len, BUF_AUTOEXT);
	cvs_buf_set(bp, data, len, 0);
	xfree(data);
a161 4
	ret = fwrite(fcont, sizeof(char), st.st_size, out);
	if (ret != st.st_size)
		fatal("length mismatch, tried to write %lld only wrote %ld",
		    st.st_size, ret);
d163 8
a170 1
	xfree(fcont);
@


1.2
log
@allow update in remote mode to work a bit better and
create any missing directories or new directories with -d
@
text
@d1 1
a1 1
/*	$OpenBSD: remote.c,v 1.1 2006/07/07 17:37:17 joris Exp $	*/
a60 3
	if (cvs_server_active == 0)
		cvs_log(LP_TRACE, "cvs_remote_output(%s)", data);

a115 2
	cvs_log(LP_TRACE, "cvs_remote_receive_file(%ld)", len);

a141 2
	cvs_log(LP_TRACE, "cvs_remote_send_file(%s)", path);

a172 2

	cvs_log(LP_TRACE, "cvs_remote_classify_file(%s)", cf->file_path);
@


1.1
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d193 7
@
