head	1.198;
access;
symbols
	OPENBSD_6_1:1.194.0.4
	OPENBSD_6_1_BASE:1.194
	OPENBSD_6_0:1.172.0.2
	OPENBSD_6_0_BASE:1.172
	OPENBSD_5_9:1.168.0.2
	OPENBSD_5_9_BASE:1.168
	OPENBSD_5_8:1.148.0.4
	OPENBSD_5_8_BASE:1.148
	OPENBSD_5_7:1.138.0.2
	OPENBSD_5_7_BASE:1.138
	OPENBSD_5_6:1.111.0.4
	OPENBSD_5_6_BASE:1.111
	OPENBSD_5_5:1.71.0.4
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.42.0.4
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.2
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.2
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.198
date	2017.05.05.15.16.25;	author schwarze;	state Exp;
branches;
next	1.197;
commitid	sNJdFUhzoVfGBx2p;

1.197
date	2017.05.05.13.17.04;	author schwarze;	state Exp;
branches;
next	1.196;
commitid	GvSRKa33jIoa4JAJ;

1.196
date	2017.05.04.17.48.24;	author schwarze;	state Exp;
branches;
next	1.195;
commitid	RHQLdCAdHKxKe8Eu;

1.195
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.194;
commitid	2CfzvK3gmiJH7vY0;

1.194
date	2017.03.03.13.41.28;	author schwarze;	state Exp;
branches;
next	1.193;
commitid	w4jK4ZS54l5ngp3Y;

1.193
date	2017.02.09.19.50.47;	author schwarze;	state Exp;
branches;
next	1.192;
commitid	htSnpNKUL8BDthH8;

1.192
date	2017.02.09.17.19.07;	author schwarze;	state Exp;
branches;
next	1.191;
commitid	M8rq0bbAM3ikHus0;

1.191
date	2017.01.27.11.33.08;	author schwarze;	state Exp;
branches;
next	1.190;
commitid	OcE6WyJfFFTmHJ1G;

1.190
date	2017.01.27.01.14.34;	author schwarze;	state Exp;
branches;
next	1.189;
commitid	8kHXk6qqyLzlI5Ov;

1.189
date	2017.01.27.01.09.02;	author schwarze;	state Exp;
branches;
next	1.188;
commitid	2FoTxyD9JI6zYLPZ;

1.188
date	2017.01.27.01.04.13;	author schwarze;	state Exp;
branches;
next	1.187;
commitid	A42uEuQToD0vHNR7;

1.187
date	2017.01.27.00.55.49;	author schwarze;	state Exp;
branches;
next	1.186;
commitid	w01f02dR8dJL04ML;

1.186
date	2017.01.11.17.39.45;	author schwarze;	state Exp;
branches;
next	1.185;
commitid	2X81lVBLl8eAHRVh;

1.185
date	2017.01.10.23.36.24;	author schwarze;	state Exp;
branches;
next	1.184;
commitid	1NsxjVXtIEKZm6T7;

1.184
date	2017.01.10.21.54.34;	author schwarze;	state Exp;
branches;
next	1.183;
commitid	iaEy6J4gJ8kh18cm;

1.183
date	2016.10.22.10.08.31;	author schwarze;	state Exp;
branches;
next	1.182;
commitid	tSkyY2W19oGXfIRu;

1.182
date	2016.10.20.16.29.13;	author schwarze;	state Exp;
branches;
next	1.181;
commitid	vW8kPtejUUJw2pHO;

1.181
date	2016.10.18.14.20.07;	author schwarze;	state Exp;
branches;
next	1.180;
commitid	4U0CRKGuZRyAjeH1;

1.180
date	2016.10.18.14.13.46;	author schwarze;	state Exp;
branches;
next	1.179;
commitid	5NmynQuI9eyuKvs4;

1.179
date	2016.09.02.14.03.24;	author schwarze;	state Exp;
branches;
next	1.178;
commitid	jUK7aUKdM9UfW4ME;

1.178
date	2016.09.01.15.07.46;	author schwarze;	state Exp;
branches;
next	1.177;
commitid	rsd62oEkXrnjIhV7;

1.177
date	2016.08.22.16.12.52;	author schwarze;	state Exp;
branches;
next	1.176;
commitid	fYNx8PKdgZDEATpW;

1.176
date	2016.08.17.20.46.06;	author schwarze;	state Exp;
branches;
next	1.175;
commitid	aP4FWZWOwFZQHMsk;

1.175
date	2016.08.05.17.20.30;	author schwarze;	state Exp;
branches;
next	1.174;
commitid	wd98WeCa9CvX02mP;

1.174
date	2016.08.01.20.46.33;	author schwarze;	state Exp;
branches;
next	1.173;
commitid	zNFGqhk7i7zUefqI;

1.173
date	2016.08.01.10.32.39;	author schwarze;	state Exp;
branches;
next	1.172;
commitid	UE9YpFybzQeyHuWW;

1.172
date	2016.07.19.13.30.16;	author schwarze;	state Exp;
branches;
next	1.171;
commitid	vM0BMAmv88IMfvC0;

1.171
date	2016.07.15.18.02.32;	author schwarze;	state Exp;
branches;
next	1.170;
commitid	NgDdzKtKRT5DJZ6U;

1.170
date	2016.07.09.15.23.36;	author schwarze;	state Exp;
branches;
next	1.169;
commitid	5FriDOsLWQ0ekSzQ;

1.169
date	2016.03.15.20.50.23;	author krw;	state Exp;
branches;
next	1.168;
commitid	JZR2bOwahEjnBJaG;

1.168
date	2016.01.08.17.48.04;	author schwarze;	state Exp;
branches;
next	1.167;
commitid	DoGoemryKYV644MI;

1.167
date	2016.01.08.15.01.58;	author schwarze;	state Exp;
branches;
next	1.166;
commitid	epbZyawFRPP0f3P8;

1.166
date	2016.01.08.02.53.09;	author schwarze;	state Exp;
branches;
next	1.165;
commitid	HwNcDew1e7MZc0JI;

1.165
date	2016.01.08.02.13.35;	author schwarze;	state Exp;
branches;
next	1.164;
commitid	DCHIkxiiKvXaJZJp;

1.164
date	2016.01.04.14.44.02;	author schwarze;	state Exp;
branches;
next	1.163;
commitid	xnTKQ0pWgSCCtCoR;

1.163
date	2015.12.15.17.36.19;	author schwarze;	state Exp;
branches;
next	1.162;
commitid	PXIma2wz20cyRFRu;

1.162
date	2015.11.07.17.58.52;	author schwarze;	state Exp;
branches;
next	1.161;
commitid	9ZfFG7Q71jrU5djH;

1.161
date	2015.11.06.16.27.13;	author schwarze;	state Exp;
branches;
next	1.160;
commitid	DFFVEgn8of3eIu5X;

1.160
date	2015.10.22.22.05.42;	author schwarze;	state Exp;
branches;
next	1.159;
commitid	h8gIY5ljbuMubFWJ;

1.159
date	2015.10.20.02.00.49;	author schwarze;	state Exp;
branches;
next	1.158;
commitid	v6RrmxwM663z4mTF;

1.158
date	2015.10.16.13.37.44;	author millert;	state Exp;
branches;
next	1.157;
commitid	H99PcNtHGZMrNl2r;

1.157
date	2015.10.13.22.57.49;	author schwarze;	state Exp;
branches;
next	1.156;
commitid	jXIG8UzKLXm2Z9i6;

1.156
date	2015.10.13.15.50.15;	author schwarze;	state Exp;
branches;
next	1.155;
commitid	ZofM5WCqJbf4KjAB;

1.155
date	2015.10.12.22.30.27;	author schwarze;	state Exp;
branches;
next	1.154;
commitid	upK4uPX8HT07fUgK;

1.154
date	2015.10.12.21.16.32;	author schwarze;	state Exp;
branches;
next	1.153;
commitid	9l84NMkZ4neXCcs8;

1.153
date	2015.10.12.00.32.37;	author schwarze;	state Exp;
branches;
next	1.152;
commitid	ujIM18H85xCltQLO;

1.152
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.151;
commitid	Ql2ha5NS80pwfGNT;

1.151
date	2015.10.11.21.06.59;	author schwarze;	state Exp;
branches;
next	1.150;
commitid	fBGuLyDivJdmK1wz;

1.150
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.149;
commitid	hxQV8O1pNUaef4ir;

1.149
date	2015.09.16.09.49.48;	author schwarze;	state Exp;
branches;
next	1.148;
commitid	hOAAIrPK39QeSrBu;

1.148
date	2015.07.19.05.59.07;	author schwarze;	state Exp;
branches;
next	1.147;
commitid	X9sGdJbndRzfjdoG;

1.147
date	2015.04.23.16.17.04;	author schwarze;	state Exp;
branches;
next	1.146;
commitid	DWHgiJTn6DvDpekX;

1.146
date	2015.04.18.17.50.02;	author schwarze;	state Exp;
branches;
next	1.145;
commitid	sjmmdLSx1e3Vat0h;

1.145
date	2015.04.18.16.34.03;	author schwarze;	state Exp;
branches;
next	1.144;
commitid	PxhkeHVIvdTMOTs6;

1.144
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.143;
commitid	6MYJ7cd8mhJ77AGH;

1.143
date	2015.04.02.23.47.43;	author schwarze;	state Exp;
branches;
next	1.142;
commitid	RJFkOLiS9gBqEEDl;

1.142
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.141;
commitid	Rfx1oTaH3hZ7Zcyf;

1.141
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.140;
commitid	lmErjWY2O9ooA6RY;

1.140
date	2015.03.27.17.36.56;	author schwarze;	state Exp;
branches;
next	1.139;
commitid	3WUgQM2C53CGXRkK;

1.139
date	2015.03.13.00.18.45;	author schwarze;	state Exp;
branches;
next	1.138;
commitid	LIjAJy6OOfqhiDux;

1.138
date	2015.02.27.16.21.42;	author schwarze;	state Exp;
branches;
next	1.137;
commitid	hpLjAGsLNVROm09C;

1.137
date	2015.01.15.04.26.06;	author schwarze;	state Exp;
branches;
next	1.136;
commitid	TgtfgXU8Rz8XgmeH;

1.136
date	2015.01.03.12.54.49;	author schwarze;	state Exp;
branches;
next	1.135;
commitid	CkO3k8n3JWc1xjoD;

1.135
date	2015.01.02.17.01.31;	author schwarze;	state Exp;
branches;
next	1.134;
commitid	i01ATpV8tbELCd7M;

1.134
date	2014.12.30.20.40.05;	author schwarze;	state Exp;
branches;
next	1.133;
commitid	tT7HlY3bV0JuQoMI;

1.133
date	2014.12.05.16.17.56;	author schwarze;	state Exp;
branches;
next	1.132;
commitid	nOAXPh9CELhWzhlA;

1.132
date	2014.12.05.15.16.25;	author schwarze;	state Exp;
branches;
next	1.131;
commitid	5p51Chn7HdcsOexL;

1.131
date	2014.12.05.14.26.23;	author schwarze;	state Exp;
branches;
next	1.130;
commitid	qZDxBnTGjf3MzvBU;

1.130
date	2014.12.04.21.48.26;	author schwarze;	state Exp;
branches;
next	1.129;
commitid	5iqNrdvpfJoDMXz1;

1.129
date	2014.12.04.20.13.13;	author schwarze;	state Exp;
branches;
next	1.128;
commitid	6Iglb9RcssBzENP7;

1.128
date	2014.12.04.18.31.04;	author schwarze;	state Exp;
branches;
next	1.127;
commitid	XRSeR62cGgKvk7Nz;

1.127
date	2014.12.04.17.35.42;	author schwarze;	state Exp;
branches;
next	1.126;
commitid	kShkDHqwvXo4xBiy;

1.126
date	2014.11.27.01.57.42;	author schwarze;	state Exp;
branches;
next	1.125;
commitid	wP9kqR5Ru9zWkEeC;

1.125
date	2014.11.26.21.40.11;	author schwarze;	state Exp;
branches;
next	1.124;
commitid	BFoJYar3mOvn9yB3;

1.124
date	2014.11.19.20.40.28;	author schwarze;	state Exp;
branches;
next	1.123;
commitid	cPqd2XujeGz1khgP;

1.123
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.122;
commitid	pNwmOla3ZQwLgu2f;

1.122
date	2014.10.27.13.29.30;	author schwarze;	state Exp;
branches;
next	1.121;
commitid	rqEyu52UjJCimBJX;

1.121
date	2014.10.12.20.32.16;	author schwarze;	state Exp;
branches;
next	1.120;
commitid	q8SsjSTF88esK95i;

1.120
date	2014.09.09.19.33.55;	author schwarze;	state Exp;
branches;
next	1.119;
commitid	x5ggJ04bYlL00y4H;

1.119
date	2014.09.07.03.08.42;	author schwarze;	state Exp;
branches;
next	1.118;
commitid	VhMYhjr8KTBySJ4o;

1.118
date	2014.09.07.03.00.03;	author schwarze;	state Exp;
branches;
next	1.117;
commitid	DavwCY6Bzvx1Yqwf;

1.117
date	2014.09.03.23.20.33;	author schwarze;	state Exp;
branches;
next	1.116;
commitid	nPk0DzpqFSEanZEV;

1.116
date	2014.09.03.18.08.26;	author schwarze;	state Exp;
branches;
next	1.115;
commitid	1DUpWacPgRNVWanP;

1.115
date	2014.09.01.23.47.56;	author schwarze;	state Exp;
branches;
next	1.114;
commitid	nSIQERUMXfYqnj4F;

1.114
date	2014.08.23.01.00.20;	author doug;	state Exp;
branches;
next	1.113;
commitid	FFa8yQFPywIcF5Xj;

1.113
date	2014.08.08.17.36.21;	author schwarze;	state Exp;
branches;
next	1.112;
commitid	yq0tYOJQc4lnOhVq;

1.112
date	2014.08.08.16.17.09;	author schwarze;	state Exp;
branches;
next	1.111;
commitid	TLMAnDXVMoqLltgG;

1.111
date	2014.06.21.16.17.56;	author schwarze;	state Exp;
branches;
next	1.110;
commitid	njZYmy3Y69FWaU2Z;

1.110
date	2014.06.20.01.20.55;	author schwarze;	state Exp;
branches;
next	1.109;
commitid	DlZxMatR8qoHEPiW;

1.109
date	2014.06.19.00.44.59;	author schwarze;	state Exp;
branches;
next	1.108;
commitid	yft3X7tl8EBoFQlM;

1.108
date	2014.06.18.19.17.37;	author sthen;	state Exp;
branches;
next	1.107;
commitid	dIgu8Geye7PQnhVQ;

1.107
date	2014.06.05.07.13.53;	author espie;	state Exp;
branches;
next	1.106;
commitid	r95Z6MPFZbR1wDB5;

1.106
date	2014.05.12.19.11.20;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2014.05.07.16.18.57;	author schwarze;	state Exp;
branches;
next	1.104;

1.104
date	2014.05.07.15.10.33;	author schwarze;	state Exp;
branches;
next	1.103;

1.103
date	2014.04.27.23.03.52;	author schwarze;	state Exp;
branches;
next	1.102;

1.102
date	2014.04.25.12.12.35;	author schwarze;	state Exp;
branches;
next	1.101;

1.101
date	2014.04.23.21.06.33;	author schwarze;	state Exp;
branches;
next	1.100;

1.100
date	2014.04.23.19.08.52;	author schwarze;	state Exp;
branches;
next	1.99;

1.99
date	2014.04.23.16.33.37;	author schwarze;	state Exp;
branches;
next	1.98;

1.98
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.97;

1.97
date	2014.04.19.02.55.44;	author schwarze;	state Exp;
branches;
next	1.96;

1.96
date	2014.04.19.02.29.12;	author schwarze;	state Exp;
branches;
next	1.95;

1.95
date	2014.04.18.21.54.48;	author schwarze;	state Exp;
branches;
next	1.94;

1.94
date	2014.04.16.21.35.48;	author schwarze;	state Exp;
branches;
next	1.93;

1.93
date	2014.04.16.18.59.38;	author schwarze;	state Exp;
branches;
next	1.92;

1.92
date	2014.04.13.22.02.54;	author schwarze;	state Exp;
branches;
next	1.91;

1.91
date	2014.04.13.21.21.27;	author schwarze;	state Exp;
branches;
next	1.90;

1.90
date	2014.04.10.02.45.03;	author schwarze;	state Exp;
branches;
next	1.89;

1.89
date	2014.04.09.21.49.31;	author schwarze;	state Exp;
branches;
next	1.88;

1.88
date	2014.04.04.18.23.07;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2014.04.04.16.43.08;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2014.04.04.15.55.17;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2014.04.04.02.31.01;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2014.04.03.21.45.27;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2014.04.03.16.26.53;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2014.04.03.15.37.14;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2014.03.26.21.39.33;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2014.03.26.20.53.31;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2014.03.23.12.44.18;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2014.03.22.00.56.07;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2014.03.21.22.52.21;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2014.03.19.22.33.04;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2014.03.19.22.20.36;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2014.03.19.21.50.59;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2014.03.18.16.56.06;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2014.01.22.20.58.35;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2014.01.19.22.48.00;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2014.01.19.22.40.42;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2014.01.19.00.09.33;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2014.01.18.08.54.20;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2014.01.17.19.16.42;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.17.19.07.12;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2014.01.06.20.53.36;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2014.01.06.15.32.44;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2014.01.06.13.54.11;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2014.01.06.03.52.05;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2014.01.06.03.02.40;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2014.01.05.20.26.27;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2014.01.05.04.48.35;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2014.01.05.04.13.46;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2014.01.05.03.25.51;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2014.01.05.03.06.36;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2014.01.05.00.29.49;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2014.01.02.22.44.07;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2014.01.02.22.19.38;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2014.01.02.20.24.35;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2014.01.02.18.51.51;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2013.12.31.19.39.09;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2013.12.31.18.07.06;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2013.12.31.00.40.19;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2013.11.21.01.47.10;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2013.10.05.21.17.29;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2013.06.05.02.02.53;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2013.05.29.23.15.11;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2012.05.24.23.33.23;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2012.04.18.01.41.41;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2012.04.15.13.26.14;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2012.04.15.11.14.38;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2012.01.15.16.31.05;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2012.01.09.23.21.47;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2012.01.09.01.59.08;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.07.15.32.24;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.05.22.48.52;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.28.01.17.01;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2011.12.26.11.44.31;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2011.12.25.19.57.20;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2011.12.25.16.52.55;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.25.14.51.33;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2011.12.25.13.05.29;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2011.12.20.00.41.24;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2011.12.19.02.26.33;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.12.01.59.13;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.10.22.01.03;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.10.16.53.38;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.09.01.47.11;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2011.12.09.00.53.10;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.08.02.14.00;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2011.12.07.01.57.18;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.04.14.11.55;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2011.12.03.14.53.12;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2011.12.01.23.22.09;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.29.22.30.56;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.28.00.57.28;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2011.11.27.23.27.16;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2011.11.27.23.11.32;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.27.22.57.28;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.26.16.41.35;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.17.15.38.27;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.17.15.02.29;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.17.14.52.32;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.14.18.52.05;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.13.10.40.52;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.13.00.53.07;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.06.23.04.16;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.09.17.13.45.28;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.14.15.10.54;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.198
log
@Move .sp to the roff modules.  Enough infrastructure is in place
now that this actually saves code: -70 LOC.
@
text
@/*	$OpenBSD: mandocdb.c,v 1.197 2017/05/05 13:17:04 schwarze Exp $ */
/*
 * Copyright (c) 2011, 2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011-2017 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2016 Ed Maste <emaste@@freebsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fts.h>
#include <limits.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mandoc_aux.h"
#include "mandoc_ohash.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "man.h"
#include "manconf.h"
#include "mansearch.h"
#include "dba_array.h"
#include "dba.h"

extern const char *const mansearch_keynames[];

enum	op {
	OP_DEFAULT = 0, /* new dbs from dir list or default config */
	OP_CONFFILE, /* new databases from custom config file */
	OP_UPDATE, /* delete/add entries in existing database */
	OP_DELETE, /* delete entries from existing database */
	OP_TEST /* change no databases, report potential problems */
};

struct	str {
	const struct mpage *mpage; /* if set, the owning parse */
	uint64_t	 mask; /* bitmask in sequence */
	char		 key[]; /* rendered text */
};

struct	inodev {
	ino_t		 st_ino;
	dev_t		 st_dev;
};

struct	mpage {
	struct inodev	 inodev;  /* used for hashing routine */
	struct dba_array *dba;
	char		*sec;     /* section from file content */
	char		*arch;    /* architecture from file content */
	char		*title;   /* title from file content */
	char		*desc;    /* description from file content */
	struct mpage	*next;    /* singly linked list */
	struct mlink	*mlinks;  /* singly linked list */
	int		 name_head_done;
	enum form	 form;    /* format from file content */
};

struct	mlink {
	char		 file[PATH_MAX]; /* filename rel. to manpath */
	char		*dsec;    /* section from directory */
	char		*arch;    /* architecture from directory */
	char		*name;    /* name from file name (not empty) */
	char		*fsec;    /* section from file name suffix */
	struct mlink	*next;    /* singly linked list */
	struct mpage	*mpage;   /* parent */
	int		 gzip;	  /* filename has a .gz suffix */
	enum form	 dform;   /* format from directory */
	enum form	 fform;   /* format from file name suffix */
};

typedef	int (*mdoc_fp)(struct mpage *, const struct roff_meta *,
			const struct roff_node *);

struct	mdoc_handler {
	mdoc_fp		 fp; /* optional handler */
	uint64_t	 mask;  /* set unless handler returns 0 */
	int		 taboo;  /* node flags that must not be set */
};


int		 mandocdb(int, char *[]);

static	void	 dbadd(struct dba *, struct mpage *);
static	void	 dbadd_mlink(const struct mlink *mlink);
static	void	 dbprune(struct dba *);
static	void	 dbwrite(struct dba *);
static	void	 filescan(const char *);
static	int	 fts_compare(const FTSENT **, const FTSENT **);
static	void	 mlink_add(struct mlink *, const struct stat *);
static	void	 mlink_check(struct mpage *, struct mlink *);
static	void	 mlink_free(struct mlink *);
static	void	 mlinks_undupe(struct mpage *);
static	void	 mpages_free(void);
static	void	 mpages_merge(struct dba *, struct mparse *);
static	void	 parse_cat(struct mpage *, int);
static	void	 parse_man(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	void	 parse_mdoc(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_head(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Fd(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	void	 parse_mdoc_fname(struct mpage *, const struct roff_node *);
static	int	 parse_mdoc_Fn(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Fo(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Nd(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Nm(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Sh(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Va(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Xr(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	void	 putkey(const struct mpage *, char *, uint64_t);
static	void	 putkeys(const struct mpage *, char *, size_t, uint64_t);
static	void	 putmdockey(const struct mpage *,
			const struct roff_node *, uint64_t, int);
static	int	 render_string(char **, size_t *);
static	void	 say(const char *, const char *, ...)
			__attribute__((__format__ (__printf__, 2, 3)));
static	int	 set_basedir(const char *, int);
static	int	 treescan(void);
static	size_t	 utf8(unsigned int, char [7]);

static	int		 nodb; /* no database changes */
static	int		 mparse_options; /* abort the parse early */
static	int		 use_all; /* use all found files */
static	int		 debug; /* print what we're doing */
static	int		 warnings; /* warn about crap */
static	int		 write_utf8; /* write UTF-8 output; else ASCII */
static	int		 exitcode; /* to be returned by main */
static	enum op		 op; /* operational mode */
static	char		 basedir[PATH_MAX]; /* current base directory */
static	struct mpage	*mpage_head; /* list of distinct manual pages */
static	struct ohash	 mpages; /* table of distinct manual pages */
static	struct ohash	 mlinks; /* table of directory entries */
static	struct ohash	 names; /* table of all names */
static	struct ohash	 strings; /* table of all strings */
static	uint64_t	 name_mask;

static	const struct mdoc_handler __mdocs[MDOC_MAX - MDOC_Dd] = {
	{ NULL, 0, NODE_NOPRT },  /* Dd */
	{ NULL, 0, NODE_NOPRT },  /* Dt */
	{ NULL, 0, NODE_NOPRT },  /* Os */
	{ parse_mdoc_Sh, TYPE_Sh, 0 }, /* Sh */
	{ parse_mdoc_head, TYPE_Ss, 0 }, /* Ss */
	{ NULL, 0, 0 },  /* Pp */
	{ NULL, 0, 0 },  /* D1 */
	{ NULL, 0, 0 },  /* Dl */
	{ NULL, 0, 0 },  /* Bd */
	{ NULL, 0, 0 },  /* Ed */
	{ NULL, 0, 0 },  /* Bl */
	{ NULL, 0, 0 },  /* El */
	{ NULL, 0, 0 },  /* It */
	{ NULL, 0, 0 },  /* Ad */
	{ NULL, TYPE_An, 0 },  /* An */
	{ NULL, 0, 0 },  /* Ap */
	{ NULL, TYPE_Ar, 0 },  /* Ar */
	{ NULL, TYPE_Cd, 0 },  /* Cd */
	{ NULL, TYPE_Cm, 0 },  /* Cm */
	{ NULL, TYPE_Dv, 0 },  /* Dv */
	{ NULL, TYPE_Er, 0 },  /* Er */
	{ NULL, TYPE_Ev, 0 },  /* Ev */
	{ NULL, 0, 0 },  /* Ex */
	{ NULL, TYPE_Fa, 0 },  /* Fa */
	{ parse_mdoc_Fd, 0, 0 },  /* Fd */
	{ NULL, TYPE_Fl, 0 },  /* Fl */
	{ parse_mdoc_Fn, 0, 0 },  /* Fn */
	{ NULL, TYPE_Ft, 0 },  /* Ft */
	{ NULL, TYPE_Ic, 0 },  /* Ic */
	{ NULL, TYPE_In, 0 },  /* In */
	{ NULL, TYPE_Li, 0 },  /* Li */
	{ parse_mdoc_Nd, 0, 0 },  /* Nd */
	{ parse_mdoc_Nm, 0, 0 },  /* Nm */
	{ NULL, 0, 0 },  /* Op */
	{ NULL, 0, 0 },  /* Ot */
	{ NULL, TYPE_Pa, NODE_NOSRC },  /* Pa */
	{ NULL, 0, 0 },  /* Rv */
	{ NULL, TYPE_St, 0 },  /* St */
	{ parse_mdoc_Va, TYPE_Va, 0 },  /* Va */
	{ parse_mdoc_Va, TYPE_Vt, 0 },  /* Vt */
	{ parse_mdoc_Xr, 0, 0 },  /* Xr */
	{ NULL, 0, 0 },  /* %A */
	{ NULL, 0, 0 },  /* %B */
	{ NULL, 0, 0 },  /* %D */
	{ NULL, 0, 0 },  /* %I */
	{ NULL, 0, 0 },  /* %J */
	{ NULL, 0, 0 },  /* %N */
	{ NULL, 0, 0 },  /* %O */
	{ NULL, 0, 0 },  /* %P */
	{ NULL, 0, 0 },  /* %R */
	{ NULL, 0, 0 },  /* %T */
	{ NULL, 0, 0 },  /* %V */
	{ NULL, 0, 0 },  /* Ac */
	{ NULL, 0, 0 },  /* Ao */
	{ NULL, 0, 0 },  /* Aq */
	{ NULL, TYPE_At, 0 },  /* At */
	{ NULL, 0, 0 },  /* Bc */
	{ NULL, 0, 0 },  /* Bf */
	{ NULL, 0, 0 },  /* Bo */
	{ NULL, 0, 0 },  /* Bq */
	{ NULL, TYPE_Bsx, NODE_NOSRC },  /* Bsx */
	{ NULL, TYPE_Bx, NODE_NOSRC },  /* Bx */
	{ NULL, 0, 0 },  /* Db */
	{ NULL, 0, 0 },  /* Dc */
	{ NULL, 0, 0 },  /* Do */
	{ NULL, 0, 0 },  /* Dq */
	{ NULL, 0, 0 },  /* Ec */
	{ NULL, 0, 0 },  /* Ef */
	{ NULL, TYPE_Em, 0 },  /* Em */
	{ NULL, 0, 0 },  /* Eo */
	{ NULL, TYPE_Fx, NODE_NOSRC },  /* Fx */
	{ NULL, TYPE_Ms, 0 },  /* Ms */
	{ NULL, 0, 0 },  /* No */
	{ NULL, 0, 0 },  /* Ns */
	{ NULL, TYPE_Nx, NODE_NOSRC },  /* Nx */
	{ NULL, TYPE_Ox, NODE_NOSRC },  /* Ox */
	{ NULL, 0, 0 },  /* Pc */
	{ NULL, 0, 0 },  /* Pf */
	{ NULL, 0, 0 },  /* Po */
	{ NULL, 0, 0 },  /* Pq */
	{ NULL, 0, 0 },  /* Qc */
	{ NULL, 0, 0 },  /* Ql */
	{ NULL, 0, 0 },  /* Qo */
	{ NULL, 0, 0 },  /* Qq */
	{ NULL, 0, 0 },  /* Re */
	{ NULL, 0, 0 },  /* Rs */
	{ NULL, 0, 0 },  /* Sc */
	{ NULL, 0, 0 },  /* So */
	{ NULL, 0, 0 },  /* Sq */
	{ NULL, 0, 0 },  /* Sm */
	{ NULL, 0, 0 },  /* Sx */
	{ NULL, TYPE_Sy, 0 },  /* Sy */
	{ NULL, TYPE_Tn, 0 },  /* Tn */
	{ NULL, 0, NODE_NOSRC },  /* Ux */
	{ NULL, 0, 0 },  /* Xc */
	{ NULL, 0, 0 },  /* Xo */
	{ parse_mdoc_Fo, 0, 0 },  /* Fo */
	{ NULL, 0, 0 },  /* Fc */
	{ NULL, 0, 0 },  /* Oo */
	{ NULL, 0, 0 },  /* Oc */
	{ NULL, 0, 0 },  /* Bk */
	{ NULL, 0, 0 },  /* Ek */
	{ NULL, 0, 0 },  /* Bt */
	{ NULL, 0, 0 },  /* Hf */
	{ NULL, 0, 0 },  /* Fr */
	{ NULL, 0, 0 },  /* Ud */
	{ NULL, TYPE_Lb, NODE_NOSRC },  /* Lb */
	{ NULL, 0, 0 },  /* Lp */
	{ NULL, TYPE_Lk, 0 },  /* Lk */
	{ NULL, TYPE_Mt, NODE_NOSRC },  /* Mt */
	{ NULL, 0, 0 },  /* Brq */
	{ NULL, 0, 0 },  /* Bro */
	{ NULL, 0, 0 },  /* Brc */
	{ NULL, 0, 0 },  /* %C */
	{ NULL, 0, 0 },  /* Es */
	{ NULL, 0, 0 },  /* En */
	{ NULL, TYPE_Dx, NODE_NOSRC },  /* Dx */
	{ NULL, 0, 0 },  /* %Q */
	{ NULL, 0, 0 },  /* %U */
	{ NULL, 0, 0 },  /* Ta */
};
static	const struct mdoc_handler *const mdocs = __mdocs - MDOC_Dd;


int
mandocdb(int argc, char *argv[])
{
	struct manconf	  conf;
	struct mparse	 *mp;
	struct dba	 *dba;
	const char	 *path_arg, *progname;
	size_t		  j, sz;
	int		  ch, i;

	if (pledge("stdio rpath wpath cpath fattr flock proc exec", NULL) == -1) {
		warn("pledge");
		return (int)MANDOCLEVEL_SYSERR;
	}

	memset(&conf, 0, sizeof(conf));

	/*
	 * We accept a few different invocations.
	 * The CHECKOP macro makes sure that invocation styles don't
	 * clobber each other.
	 */
#define	CHECKOP(_op, _ch) do \
	if (OP_DEFAULT != (_op)) { \
		warnx("-%c: Conflicting option", (_ch)); \
		goto usage; \
	} while (/*CONSTCOND*/0)

	path_arg = NULL;
	op = OP_DEFAULT;

	while (-1 != (ch = getopt(argc, argv, "aC:Dd:npQT:tu:v")))
		switch (ch) {
		case 'a':
			use_all = 1;
			break;
		case 'C':
			CHECKOP(op, ch);
			path_arg = optarg;
			op = OP_CONFFILE;
			break;
		case 'D':
			debug++;
			break;
		case 'd':
			CHECKOP(op, ch);
			path_arg = optarg;
			op = OP_UPDATE;
			break;
		case 'n':
			nodb = 1;
			break;
		case 'p':
			warnings = 1;
			break;
		case 'Q':
			mparse_options |= MPARSE_QUICK;
			break;
		case 'T':
			if (strcmp(optarg, "utf8")) {
				warnx("-T%s: Unsupported output format",
				    optarg);
				goto usage;
			}
			write_utf8 = 1;
			break;
		case 't':
			CHECKOP(op, ch);
			dup2(STDOUT_FILENO, STDERR_FILENO);
			op = OP_TEST;
			nodb = warnings = 1;
			break;
		case 'u':
			CHECKOP(op, ch);
			path_arg = optarg;
			op = OP_DELETE;
			break;
		case 'v':
			/* Compatibility with espie@@'s makewhatis. */
			break;
		default:
			goto usage;
		}

	argc -= optind;
	argv += optind;

	if (nodb) {
		if (pledge("stdio rpath", NULL) == -1) {
			warn("pledge");
			return (int)MANDOCLEVEL_SYSERR;
		}
	}

	if (OP_CONFFILE == op && argc > 0) {
		warnx("-C: Too many arguments");
		goto usage;
	}

	exitcode = (int)MANDOCLEVEL_OK;
	mchars_alloc();
	mp = mparse_alloc(mparse_options, MANDOCLEVEL_BADARG, NULL, NULL);
	mandoc_ohash_init(&mpages, 6, offsetof(struct mpage, inodev));
	mandoc_ohash_init(&mlinks, 6, offsetof(struct mlink, file));

	if (OP_UPDATE == op || OP_DELETE == op || OP_TEST == op) {

		/*
		 * Most of these deal with a specific directory.
		 * Jump into that directory first.
		 */
		if (OP_TEST != op && 0 == set_basedir(path_arg, 1))
			goto out;

		dba = nodb ? dba_new(128) : dba_read(MANDOC_DB);
		if (dba != NULL) {
			/*
			 * The existing database is usable.  Process
			 * all files specified on the command-line.
			 */
			if (!nodb) {
				if (pledge("stdio rpath wpath cpath fattr flock", NULL) == -1) {
					warn("pledge");
					exitcode = (int)MANDOCLEVEL_SYSERR;
					goto out;
				}
			}
			use_all = 1;
			for (i = 0; i < argc; i++)
				filescan(argv[i]);
			if (nodb == 0)
				dbprune(dba);
		} else {
			/* Database missing or corrupt. */
			if (op != OP_UPDATE || errno != ENOENT)
				say(MANDOC_DB, "%s: Automatically recreating"
				    " from scratch", strerror(errno));
			exitcode = (int)MANDOCLEVEL_OK;
			op = OP_DEFAULT;
			if (0 == treescan())
				goto out;
			dba = dba_new(128);
		}
		if (OP_DELETE != op)
			mpages_merge(dba, mp);
		if (nodb == 0)
			dbwrite(dba);
		dba_free(dba);
	} else {
		/*
		 * If we have arguments, use them as our manpaths.
		 * If we don't, use man.conf(5).
		 */
		if (argc > 0) {
			conf.manpath.paths = mandoc_reallocarray(NULL,
			    argc, sizeof(char *));
			conf.manpath.sz = (size_t)argc;
			for (i = 0; i < argc; i++)
				conf.manpath.paths[i] = mandoc_strdup(argv[i]);
		} else
			manconf_parse(&conf, path_arg, NULL, NULL);

		if (conf.manpath.sz == 0) {
			exitcode = (int)MANDOCLEVEL_BADARG;
			say("", "Empty manpath");
		}

		/*
		 * First scan the tree rooted at a base directory, then
		 * build a new database and finally move it into place.
		 * Ignore zero-length directories and strip trailing
		 * slashes.
		 */
		for (j = 0; j < conf.manpath.sz; j++) {
			sz = strlen(conf.manpath.paths[j]);
			if (sz && conf.manpath.paths[j][sz - 1] == '/')
				conf.manpath.paths[j][--sz] = '\0';
			if (0 == sz)
				continue;

			if (j) {
				mandoc_ohash_init(&mpages, 6,
				    offsetof(struct mpage, inodev));
				mandoc_ohash_init(&mlinks, 6,
				    offsetof(struct mlink, file));
			}

			if ( ! set_basedir(conf.manpath.paths[j], argc > 0))
				continue;
			if (0 == treescan())
				continue;
			dba = dba_new(128);
			mpages_merge(dba, mp);
			if (nodb == 0)
				dbwrite(dba);
			dba_free(dba);

			if (j + 1 < conf.manpath.sz) {
				mpages_free();
				ohash_delete(&mpages);
				ohash_delete(&mlinks);
			}
		}
	}
out:
	manconf_free(&conf);
	mparse_free(mp);
	mchars_free();
	mpages_free();
	ohash_delete(&mpages);
	ohash_delete(&mlinks);
	return exitcode;
usage:
	progname = getprogname();
	fprintf(stderr, "usage: %s [-aDnpQ] [-C file] [-Tutf8]\n"
			"       %s [-aDnpQ] [-Tutf8] dir ...\n"
			"       %s [-DnpQ] [-Tutf8] -d dir [file ...]\n"
			"       %s [-Dnp] -u dir [file ...]\n"
			"       %s [-Q] -t file ...\n",
		        progname, progname, progname, progname, progname);

	return (int)MANDOCLEVEL_BADARG;
}

/*
 * To get a singly linked list in alpha order while inserting entries
 * at the beginning, process directory entries in reverse alpha order.
 */
static int
fts_compare(const FTSENT **a, const FTSENT **b)
{
	return -strcmp((*a)->fts_name, (*b)->fts_name);
}

/*
 * Scan a directory tree rooted at "basedir" for manpages.
 * We use fts(), scanning directory parts along the way for clues to our
 * section and architecture.
 *
 * If use_all has been specified, grok all files.
 * If not, sanitise paths to the following:
 *
 *   [./]man*[/<arch>]/<name>.<section>
 *   or
 *   [./]cat<section>[/<arch>]/<name>.0
 *
 * TODO: accommodate for multi-language directories.
 */
static int
treescan(void)
{
	char		 buf[PATH_MAX];
	FTS		*f;
	FTSENT		*ff;
	struct mlink	*mlink;
	int		 gzip;
	enum form	 dform;
	char		*dsec, *arch, *fsec, *cp;
	const char	*path;
	const char	*argv[2];

	argv[0] = ".";
	argv[1] = NULL;

	f = fts_open((char * const *)argv, FTS_PHYSICAL | FTS_NOCHDIR,
	    fts_compare);
	if (f == NULL) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&fts_open");
		return 0;
	}

	dsec = arch = NULL;
	dform = FORM_NONE;

	while ((ff = fts_read(f)) != NULL) {
		path = ff->fts_path + 2;
		switch (ff->fts_info) {

		/*
		 * Symbolic links require various sanity checks,
		 * then get handled just like regular files.
		 */
		case FTS_SL:
			if (realpath(path, buf) == NULL) {
				if (warnings)
					say(path, "&realpath");
				continue;
			}
			if (strstr(buf, basedir) != buf) {
				if (warnings) say("",
				    "%s: outside base directory", buf);
				continue;
			}
			/* Use logical inode to avoid mpages dupe. */
			if (stat(path, ff->fts_statp) == -1) {
				if (warnings)
					say(path, "&stat");
				continue;
			}
			/* FALLTHROUGH */

		/*
		 * If we're a regular file, add an mlink by using the
		 * stored directory data and handling the filename.
		 */
		case FTS_F:
			if ( ! strcmp(path, MANDOC_DB))
				continue;
			if ( ! use_all && ff->fts_level < 2) {
				if (warnings)
					say(path, "Extraneous file");
				continue;
			}
			gzip = 0;
			fsec = NULL;
			while (fsec == NULL) {
				fsec = strrchr(ff->fts_name, '.');
				if (fsec == NULL || strcmp(fsec+1, "gz"))
					break;
				gzip = 1;
				*fsec = '\0';
				fsec = NULL;
			}
			if (fsec == NULL) {
				if ( ! use_all) {
					if (warnings)
						say(path,
						    "No filename suffix");
					continue;
				}
			} else if ( ! strcmp(++fsec, "html")) {
				if (warnings)
					say(path, "Skip html");
				continue;
			} else if ( ! strcmp(fsec, "ps")) {
				if (warnings)
					say(path, "Skip ps");
				continue;
			} else if ( ! strcmp(fsec, "pdf")) {
				if (warnings)
					say(path, "Skip pdf");
				continue;
			} else if ( ! use_all &&
			    ((dform == FORM_SRC &&
			      strncmp(fsec, dsec, strlen(dsec))) ||
			     (dform == FORM_CAT && strcmp(fsec, "0")))) {
				if (warnings)
					say(path, "Wrong filename suffix");
				continue;
			} else
				fsec[-1] = '\0';

			mlink = mandoc_calloc(1, sizeof(struct mlink));
			if (strlcpy(mlink->file, path,
			    sizeof(mlink->file)) >=
			    sizeof(mlink->file)) {
				say(path, "Filename too long");
				free(mlink);
				continue;
			}
			mlink->dform = dform;
			mlink->dsec = dsec;
			mlink->arch = arch;
			mlink->name = ff->fts_name;
			mlink->fsec = fsec;
			mlink->gzip = gzip;
			mlink_add(mlink, ff->fts_statp);
			continue;

		case FTS_D:
		case FTS_DP:
			break;

		default:
			if (warnings)
				say(path, "Not a regular file");
			continue;
		}

		switch (ff->fts_level) {
		case 0:
			/* Ignore the root directory. */
			break;
		case 1:
			/*
			 * This might contain manX/ or catX/.
			 * Try to infer this from the name.
			 * If we're not in use_all, enforce it.
			 */
			cp = ff->fts_name;
			if (ff->fts_info == FTS_DP) {
				dform = FORM_NONE;
				dsec = NULL;
				break;
			}

			if ( ! strncmp(cp, "man", 3)) {
				dform = FORM_SRC;
				dsec = cp + 3;
			} else if ( ! strncmp(cp, "cat", 3)) {
				dform = FORM_CAT;
				dsec = cp + 3;
			} else {
				dform = FORM_NONE;
				dsec = NULL;
			}

			if (dsec != NULL || use_all)
				break;

			if (warnings)
				say(path, "Unknown directory part");
			fts_set(f, ff, FTS_SKIP);
			break;
		case 2:
			/*
			 * Possibly our architecture.
			 * If we're descending, keep tabs on it.
			 */
			if (ff->fts_info != FTS_DP && dsec != NULL)
				arch = ff->fts_name;
			else
				arch = NULL;
			break;
		default:
			if (ff->fts_info == FTS_DP || use_all)
				break;
			if (warnings)
				say(path, "Extraneous directory part");
			fts_set(f, ff, FTS_SKIP);
			break;
		}
	}

	fts_close(f);
	return 1;
}

/*
 * Add a file to the mlinks table.
 * Do not verify that it's a "valid" looking manpage (we'll do that
 * later).
 *
 * Try to infer the manual section, architecture, and page name from the
 * path, assuming it looks like
 *
 *   [./]man*[/<arch>]/<name>.<section>
 *   or
 *   [./]cat<section>[/<arch>]/<name>.0
 *
 * See treescan() for the fts(3) version of this.
 */
static void
filescan(const char *file)
{
	char		 buf[PATH_MAX];
	struct stat	 st;
	struct mlink	*mlink;
	char		*p, *start;

	assert(use_all);

	if (0 == strncmp(file, "./", 2))
		file += 2;

	/*
	 * We have to do lstat(2) before realpath(3) loses
	 * the information whether this is a symbolic link.
	 * We need to know that because for symbolic links,
	 * we want to use the orginal file name, while for
	 * regular files, we want to use the real path.
	 */
	if (-1 == lstat(file, &st)) {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say(file, "&lstat");
		return;
	} else if (0 == ((S_IFREG | S_IFLNK) & st.st_mode)) {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say(file, "Not a regular file");
		return;
	}

	/*
	 * We have to resolve the file name to the real path
	 * in any case for the base directory check.
	 */
	if (NULL == realpath(file, buf)) {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say(file, "&realpath");
		return;
	}

	if (OP_TEST == op)
		start = buf;
	else if (strstr(buf, basedir) == buf)
		start = buf + strlen(basedir);
	else {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say("", "%s: outside base directory", buf);
		return;
	}

	/*
	 * Now we are sure the file is inside our tree.
	 * If it is a symbolic link, ignore the real path
	 * and use the original name.
	 * This implies passing stuff like "cat1/../man1/foo.1"
	 * on the command line won't work.  So don't do that.
	 * Note the stat(2) can still fail if the link target
	 * doesn't exist.
	 */
	if (S_IFLNK & st.st_mode) {
		if (-1 == stat(buf, &st)) {
			exitcode = (int)MANDOCLEVEL_BADARG;
			say(file, "&stat");
			return;
		}
		if (strlcpy(buf, file, sizeof(buf)) >= sizeof(buf)) {
			say(file, "Filename too long");
			return;
		}
		start = buf;
		if (OP_TEST != op && strstr(buf, basedir) == buf)
			start += strlen(basedir);
	}

	mlink = mandoc_calloc(1, sizeof(struct mlink));
	mlink->dform = FORM_NONE;
	if (strlcpy(mlink->file, start, sizeof(mlink->file)) >=
	    sizeof(mlink->file)) {
		say(start, "Filename too long");
		free(mlink);
		return;
	}

	/*
	 * In test mode or when the original name is absolute
	 * but outside our tree, guess the base directory.
	 */

	if (op == OP_TEST || (start == buf && *start == '/')) {
		if (strncmp(buf, "man/", 4) == 0)
			start = buf + 4;
		else if ((start = strstr(buf, "/man/")) != NULL)
			start += 5;
		else
			start = buf;
	}

	/*
	 * First try to guess our directory structure.
	 * If we find a separator, try to look for man* or cat*.
	 * If we find one of these and what's underneath is a directory,
	 * assume it's an architecture.
	 */
	if (NULL != (p = strchr(start, '/'))) {
		*p++ = '\0';
		if (0 == strncmp(start, "man", 3)) {
			mlink->dform = FORM_SRC;
			mlink->dsec = start + 3;
		} else if (0 == strncmp(start, "cat", 3)) {
			mlink->dform = FORM_CAT;
			mlink->dsec = start + 3;
		}

		start = p;
		if (NULL != mlink->dsec && NULL != (p = strchr(start, '/'))) {
			*p++ = '\0';
			mlink->arch = start;
			start = p;
		}
	}

	/*
	 * Now check the file suffix.
	 * Suffix of `.0' indicates a catpage, `.1-9' is a manpage.
	 */
	p = strrchr(start, '\0');
	while (p-- > start && '/' != *p && '.' != *p)
		/* Loop. */ ;

	if ('.' == *p) {
		*p++ = '\0';
		mlink->fsec = p;
	}

	/*
	 * Now try to parse the name.
	 * Use the filename portion of the path.
	 */
	mlink->name = start;
	if (NULL != (p = strrchr(start, '/'))) {
		mlink->name = p + 1;
		*p = '\0';
	}
	mlink_add(mlink, &st);
}

static void
mlink_add(struct mlink *mlink, const struct stat *st)
{
	struct inodev	 inodev;
	struct mpage	*mpage;
	unsigned int	 slot;

	assert(NULL != mlink->file);

	mlink->dsec = mandoc_strdup(mlink->dsec ? mlink->dsec : "");
	mlink->arch = mandoc_strdup(mlink->arch ? mlink->arch : "");
	mlink->name = mandoc_strdup(mlink->name ? mlink->name : "");
	mlink->fsec = mandoc_strdup(mlink->fsec ? mlink->fsec : "");

	if ('0' == *mlink->fsec) {
		free(mlink->fsec);
		mlink->fsec = mandoc_strdup(mlink->dsec);
		mlink->fform = FORM_CAT;
	} else if ('1' <= *mlink->fsec && '9' >= *mlink->fsec)
		mlink->fform = FORM_SRC;
	else
		mlink->fform = FORM_NONE;

	slot = ohash_qlookup(&mlinks, mlink->file);
	assert(NULL == ohash_find(&mlinks, slot));
	ohash_insert(&mlinks, slot, mlink);

	memset(&inodev, 0, sizeof(inodev));  /* Clear padding. */
	inodev.st_ino = st->st_ino;
	inodev.st_dev = st->st_dev;
	slot = ohash_lookup_memory(&mpages, (char *)&inodev,
	    sizeof(struct inodev), inodev.st_ino);
	mpage = ohash_find(&mpages, slot);
	if (NULL == mpage) {
		mpage = mandoc_calloc(1, sizeof(struct mpage));
		mpage->inodev.st_ino = inodev.st_ino;
		mpage->inodev.st_dev = inodev.st_dev;
		mpage->form = FORM_NONE;
		mpage->next = mpage_head;
		mpage_head = mpage;
		ohash_insert(&mpages, slot, mpage);
	} else
		mlink->next = mpage->mlinks;
	mpage->mlinks = mlink;
	mlink->mpage = mpage;
}

static void
mlink_free(struct mlink *mlink)
{

	free(mlink->dsec);
	free(mlink->arch);
	free(mlink->name);
	free(mlink->fsec);
	free(mlink);
}

static void
mpages_free(void)
{
	struct mpage	*mpage;
	struct mlink	*mlink;

	while ((mpage = mpage_head) != NULL) {
		while ((mlink = mpage->mlinks) != NULL) {
			mpage->mlinks = mlink->next;
			mlink_free(mlink);
		}
		mpage_head = mpage->next;
		free(mpage->sec);
		free(mpage->arch);
		free(mpage->title);
		free(mpage->desc);
		free(mpage);
	}
}

/*
 * For each mlink to the mpage, check whether the path looks like
 * it is formatted, and if it does, check whether a source manual
 * exists by the same name, ignoring the suffix.
 * If both conditions hold, drop the mlink.
 */
static void
mlinks_undupe(struct mpage *mpage)
{
	char		  buf[PATH_MAX];
	struct mlink	**prev;
	struct mlink	 *mlink;
	char		 *bufp;

	mpage->form = FORM_CAT;
	prev = &mpage->mlinks;
	while (NULL != (mlink = *prev)) {
		if (FORM_CAT != mlink->dform) {
			mpage->form = FORM_NONE;
			goto nextlink;
		}
		(void)strlcpy(buf, mlink->file, sizeof(buf));
		bufp = strstr(buf, "cat");
		assert(NULL != bufp);
		memcpy(bufp, "man", 3);
		if (NULL != (bufp = strrchr(buf, '.')))
			*++bufp = '\0';
		(void)strlcat(buf, mlink->dsec, sizeof(buf));
		if (NULL == ohash_find(&mlinks,
		    ohash_qlookup(&mlinks, buf)))
			goto nextlink;
		if (warnings)
			say(mlink->file, "Man source exists: %s", buf);
		if (use_all)
			goto nextlink;
		*prev = mlink->next;
		mlink_free(mlink);
		continue;
nextlink:
		prev = &(*prev)->next;
	}
}

static void
mlink_check(struct mpage *mpage, struct mlink *mlink)
{
	struct str	*str;
	unsigned int	 slot;

	/*
	 * Check whether the manual section given in a file
	 * agrees with the directory where the file is located.
	 * Some manuals have suffixes like (3p) on their
	 * section number either inside the file or in the
	 * directory name, some are linked into more than one
	 * section, like encrypt(1) = makekey(8).
	 */

	if (FORM_SRC == mpage->form &&
	    strcasecmp(mpage->sec, mlink->dsec))
		say(mlink->file, "Section \"%s\" manual in %s directory",
		    mpage->sec, mlink->dsec);

	/*
	 * Manual page directories exist for each kernel
	 * architecture as returned by machine(1).
	 * However, many manuals only depend on the
	 * application architecture as returned by arch(1).
	 * For example, some (2/ARM) manuals are shared
	 * across the "armish" and "zaurus" kernel
	 * architectures.
	 * A few manuals are even shared across completely
	 * different architectures, for example fdformat(1)
	 * on amd64, i386, and sparc64.
	 */

	if (strcasecmp(mpage->arch, mlink->arch))
		say(mlink->file, "Architecture \"%s\" manual in "
		    "\"%s\" directory", mpage->arch, mlink->arch);

	/*
	 * XXX
	 * parse_cat() doesn't set NAME_TITLE yet.
	 */

	if (FORM_CAT == mpage->form)
		return;

	/*
	 * Check whether this mlink
	 * appears as a name in the NAME section.
	 */

	slot = ohash_qlookup(&names, mlink->name);
	str = ohash_find(&names, slot);
	assert(NULL != str);
	if ( ! (NAME_TITLE & str->mask))
		say(mlink->file, "Name missing in NAME section");
}

/*
 * Run through the files in the global vector "mpages"
 * and add them to the database specified in "basedir".
 *
 * This handles the parsing scheme itself, using the cues of directory
 * and filename to determine whether the file is parsable or not.
 */
static void
mpages_merge(struct dba *dba, struct mparse *mp)
{
	struct mpage		*mpage, *mpage_dest;
	struct mlink		*mlink, *mlink_dest;
	struct roff_man		*man;
	char			*sodest;
	char			*cp;
	int			 fd;

	for (mpage = mpage_head; mpage != NULL; mpage = mpage->next) {
		mlinks_undupe(mpage);
		if ((mlink = mpage->mlinks) == NULL)
			continue;

		name_mask = NAME_MASK;
		mandoc_ohash_init(&names, 4, offsetof(struct str, key));
		mandoc_ohash_init(&strings, 6, offsetof(struct str, key));
		mparse_reset(mp);
		man = NULL;
		sodest = NULL;

		if ((fd = mparse_open(mp, mlink->file)) == -1) {
			say(mlink->file, "&open");
			goto nextpage;
		}

		/*
		 * Interpret the file as mdoc(7) or man(7) source
		 * code, unless it is known to be formatted.
		 */
		if (mlink->dform != FORM_CAT || mlink->fform != FORM_CAT) {
			mparse_readfd(mp, fd, mlink->file);
			close(fd);
			fd = -1;
			mparse_result(mp, &man, &sodest);
		}

		if (sodest != NULL) {
			mlink_dest = ohash_find(&mlinks,
			    ohash_qlookup(&mlinks, sodest));
			if (mlink_dest == NULL) {
				mandoc_asprintf(&cp, "%s.gz", sodest);
				mlink_dest = ohash_find(&mlinks,
				    ohash_qlookup(&mlinks, cp));
				free(cp);
			}
			if (mlink_dest != NULL) {

				/* The .so target exists. */

				mpage_dest = mlink_dest->mpage;
				while (1) {
					mlink->mpage = mpage_dest;

					/*
					 * If the target was already
					 * processed, add the links
					 * to the database now.
					 * Otherwise, this will
					 * happen when we come
					 * to the target.
					 */

					if (mpage_dest->dba != NULL)
						dbadd_mlink(mlink);

					if (mlink->next == NULL)
						break;
					mlink = mlink->next;
				}

				/* Move all links to the target. */

				mlink->next = mlink_dest->next;
				mlink_dest->next = mpage->mlinks;
				mpage->mlinks = NULL;
			}
			goto nextpage;
		} else if (man != NULL && man->macroset == MACROSET_MDOC) {
			mdoc_validate(man);
			mpage->form = FORM_SRC;
			mpage->sec = man->meta.msec;
			mpage->sec = mandoc_strdup(
			    mpage->sec == NULL ? "" : mpage->sec);
			mpage->arch = man->meta.arch;
			mpage->arch = mandoc_strdup(
			    mpage->arch == NULL ? "" : mpage->arch);
			mpage->title = mandoc_strdup(man->meta.title);
		} else if (man != NULL && man->macroset == MACROSET_MAN) {
			man_validate(man);
			if (*man->meta.msec != '\0' ||
			    *man->meta.title != '\0') {
				mpage->form = FORM_SRC;
				mpage->sec = mandoc_strdup(man->meta.msec);
				mpage->arch = mandoc_strdup(mlink->arch);
				mpage->title = mandoc_strdup(man->meta.title);
			} else
				man = NULL;
		}

		assert(mpage->desc == NULL);
		if (man == NULL) {
			mpage->form = FORM_CAT;
			mpage->sec = mandoc_strdup(mlink->dsec);
			mpage->arch = mandoc_strdup(mlink->arch);
			mpage->title = mandoc_strdup(mlink->name);
			parse_cat(mpage, fd);
		} else if (man->macroset == MACROSET_MDOC)
			parse_mdoc(mpage, &man->meta, man->first);
		else
			parse_man(mpage, &man->meta, man->first);
		if (mpage->desc == NULL) {
			mpage->desc = mandoc_strdup(mlink->name);
			if (warnings)
				say(mlink->file, "No one-line description, "
				    "using filename \"%s\"", mlink->name);
		}

		for (mlink = mpage->mlinks;
		     mlink != NULL;
		     mlink = mlink->next) {
			putkey(mpage, mlink->name, NAME_FILE);
			if (warnings && !use_all)
				mlink_check(mpage, mlink);
		}

		dbadd(dba, mpage);

nextpage:
		ohash_delete(&strings);
		ohash_delete(&names);
	}
}

static void
parse_cat(struct mpage *mpage, int fd)
{
	FILE		*stream;
	struct mlink	*mlink;
	char		*line, *p, *title, *sec;
	size_t		 linesz, plen, titlesz;
	ssize_t		 len;
	int		 offs;

	mlink = mpage->mlinks;
	stream = fd == -1 ? fopen(mlink->file, "r") : fdopen(fd, "r");
	if (stream == NULL) {
		if (fd != -1)
			close(fd);
		if (warnings)
			say(mlink->file, "&fopen");
		return;
	}

	line = NULL;
	linesz = 0;

	/* Parse the section number from the header line. */

	while (getline(&line, &linesz, stream) != -1) {
		if (*line == '\n')
			continue;
		if ((sec = strchr(line, '(')) == NULL)
			break;
		if ((p = strchr(++sec, ')')) == NULL)
			break;
		free(mpage->sec);
		mpage->sec = mandoc_strndup(sec, p - sec);
		if (warnings && *mlink->dsec != '\0' &&
		    strcasecmp(mpage->sec, mlink->dsec))
			say(mlink->file,
			    "Section \"%s\" manual in %s directory",
			    mpage->sec, mlink->dsec);
		break;
	}

	/* Skip to first blank line. */

	while (line == NULL || *line != '\n')
		if (getline(&line, &linesz, stream) == -1)
			break;

	/*
	 * Assume the first line that is not indented
	 * is the first section header.  Skip to it.
	 */

	while (getline(&line, &linesz, stream) != -1)
		if (*line != '\n' && *line != ' ')
			break;

	/*
	 * Read up until the next section into a buffer.
	 * Strip the leading and trailing newline from each read line,
	 * appending a trailing space.
	 * Ignore empty (whitespace-only) lines.
	 */

	titlesz = 0;
	title = NULL;

	while ((len = getline(&line, &linesz, stream)) != -1) {
		if (*line != ' ')
			break;
		offs = 0;
		while (isspace((unsigned char)line[offs]))
			offs++;
		if (line[offs] == '\0')
			continue;
		title = mandoc_realloc(title, titlesz + len - offs);
		memcpy(title + titlesz, line + offs, len - offs);
		titlesz += len - offs;
		title[titlesz - 1] = ' ';
	}
	free(line);

	/*
	 * If no page content can be found, or the input line
	 * is already the next section header, or there is no
	 * trailing newline, reuse the page title as the page
	 * description.
	 */

	if (NULL == title || '\0' == *title) {
		if (warnings)
			say(mlink->file, "Cannot find NAME section");
		fclose(stream);
		free(title);
		return;
	}

	title[titlesz - 1] = '\0';

	/*
	 * Skip to the first dash.
	 * Use the remaining line as the description (no more than 70
	 * bytes).
	 */

	if (NULL != (p = strstr(title, "- "))) {
		for (p += 2; ' ' == *p || '\b' == *p; p++)
			/* Skip to next word. */ ;
	} else {
		if (warnings)
			say(mlink->file, "No dash in title line, "
			    "reusing \"%s\" as one-line description", title);
		p = title;
	}

	plen = strlen(p);

	/* Strip backspace-encoding from line. */

	while (NULL != (line = memchr(p, '\b', plen))) {
		len = line - p;
		if (0 == len) {
			memmove(line, line + 1, plen--);
			continue;
		}
		memmove(line - 1, line + 1, plen - len);
		plen -= 2;
	}

	mpage->desc = mandoc_strdup(p);
	fclose(stream);
	free(title);
}

/*
 * Put a type/word pair into the word database for this particular file.
 */
static void
putkey(const struct mpage *mpage, char *value, uint64_t type)
{
	putkeys(mpage, value, strlen(value), type);
}

/*
 * Grok all nodes at or below a certain mdoc node into putkey().
 */
static void
putmdockey(const struct mpage *mpage,
	const struct roff_node *n, uint64_t m, int taboo)
{

	for ( ; NULL != n; n = n->next) {
		if (n->flags & taboo)
			continue;
		if (NULL != n->child)
			putmdockey(mpage, n->child, m, taboo);
		if (n->type == ROFFT_TEXT)
			putkey(mpage, n->string, m);
	}
}

static void
parse_man(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{
	const struct roff_node *head, *body;
	char		*start, *title;
	char		 byte;
	size_t		 sz;

	if (n == NULL)
		return;

	/*
	 * We're only searching for one thing: the first text child in
	 * the BODY of a NAME section.  Since we don't keep track of
	 * sections in -man, run some hoops to find out whether we're in
	 * the correct section or not.
	 */

	if (n->type == ROFFT_BODY && n->tok == MAN_SH) {
		body = n;
		if ((head = body->parent->head) != NULL &&
		    (head = head->child) != NULL &&
		    head->next == NULL &&
		    head->type == ROFFT_TEXT &&
		    strcmp(head->string, "NAME") == 0 &&
		    body->child != NULL) {

			/*
			 * Suck the entire NAME section into memory.
			 * Yes, we might run away.
			 * But too many manuals have big, spread-out
			 * NAME sections over many lines.
			 */

			title = NULL;
			deroff(&title, body);
			if (NULL == title)
				return;

			/*
			 * Go through a special heuristic dance here.
			 * Conventionally, one or more manual names are
			 * comma-specified prior to a whitespace, then a
			 * dash, then a description.  Try to puzzle out
			 * the name parts here.
			 */

			start = title;
			for ( ;; ) {
				sz = strcspn(start, " ,");
				if ('\0' == start[sz])
					break;

				byte = start[sz];
				start[sz] = '\0';

				/*
				 * Assume a stray trailing comma in the
				 * name list if a name begins with a dash.
				 */

				if ('-' == start[0] ||
				    ('\\' == start[0] && '-' == start[1]))
					break;

				putkey(mpage, start, NAME_TITLE);
				if ( ! (mpage->name_head_done ||
				    strcasecmp(start, meta->title))) {
					putkey(mpage, start, NAME_HEAD);
					mpage->name_head_done = 1;
				}

				if (' ' == byte) {
					start += sz + 1;
					break;
				}

				assert(',' == byte);
				start += sz + 1;
				while (' ' == *start)
					start++;
			}

			if (start == title) {
				putkey(mpage, start, NAME_TITLE);
				if ( ! (mpage->name_head_done ||
				    strcasecmp(start, meta->title))) {
					putkey(mpage, start, NAME_HEAD);
					mpage->name_head_done = 1;
				}
				free(title);
				return;
			}

			while (isspace((unsigned char)*start))
				start++;

			if (0 == strncmp(start, "-", 1))
				start += 1;
			else if (0 == strncmp(start, "\\-\\-", 4))
				start += 4;
			else if (0 == strncmp(start, "\\-", 2))
				start += 2;
			else if (0 == strncmp(start, "\\(en", 4))
				start += 4;
			else if (0 == strncmp(start, "\\(em", 4))
				start += 4;

			while (' ' == *start)
				start++;

			mpage->desc = mandoc_strdup(start);
			free(title);
			return;
		}
	}

	for (n = n->child; n; n = n->next) {
		if (NULL != mpage->desc)
			break;
		parse_man(mpage, meta, n);
	}
}

static void
parse_mdoc(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	for (n = n->child; n != NULL; n = n->next) {
		if (n->tok == TOKEN_NONE ||
		    n->tok < ROFF_MAX ||
		    n->flags & mdocs[n->tok].taboo)
			continue;
		assert(n->tok >= MDOC_Dd && n->tok < MDOC_MAX);
		switch (n->type) {
		case ROFFT_ELEM:
		case ROFFT_BLOCK:
		case ROFFT_HEAD:
		case ROFFT_BODY:
		case ROFFT_TAIL:
			if (mdocs[n->tok].fp != NULL &&
			    (*mdocs[n->tok].fp)(mpage, meta, n) == 0)
				break;
			if (mdocs[n->tok].mask)
				putmdockey(mpage, n->child,
				    mdocs[n->tok].mask, mdocs[n->tok].taboo);
			break;
		default:
			continue;
		}
		if (NULL != n->child)
			parse_mdoc(mpage, meta, n);
	}
}

static int
parse_mdoc_Fd(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{
	char		*start, *end;
	size_t		 sz;

	if (SEC_SYNOPSIS != n->sec ||
	    NULL == (n = n->child) ||
	    n->type != ROFFT_TEXT)
		return 0;

	/*
	 * Only consider those `Fd' macro fields that begin with an
	 * "inclusion" token (versus, e.g., #define).
	 */

	if (strcmp("#include", n->string))
		return 0;

	if ((n = n->next) == NULL || n->type != ROFFT_TEXT)
		return 0;

	/*
	 * Strip away the enclosing angle brackets and make sure we're
	 * not zero-length.
	 */

	start = n->string;
	if ('<' == *start || '"' == *start)
		start++;

	if (0 == (sz = strlen(start)))
		return 0;

	end = &start[(int)sz - 1];
	if ('>' == *end || '"' == *end)
		end--;

	if (end > start)
		putkeys(mpage, start, end - start + 1, TYPE_In);
	return 0;
}

static void
parse_mdoc_fname(struct mpage *mpage, const struct roff_node *n)
{
	char	*cp;
	size_t	 sz;

	if (n->type != ROFFT_TEXT)
		return;

	/* Skip function pointer punctuation. */

	cp = n->string;
	while (*cp == '(' || *cp == '*')
		cp++;
	sz = strcspn(cp, "()");

	putkeys(mpage, cp, sz, TYPE_Fn);
	if (n->sec == SEC_SYNOPSIS)
		putkeys(mpage, cp, sz, NAME_SYN);
}

static int
parse_mdoc_Fn(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	if (n->child == NULL)
		return 0;

	parse_mdoc_fname(mpage, n->child);

	for (n = n->child->next; n != NULL; n = n->next)
		if (n->type == ROFFT_TEXT)
			putkey(mpage, n->string, TYPE_Fa);

	return 0;
}

static int
parse_mdoc_Fo(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	if (n->type != ROFFT_HEAD)
		return 1;

	if (n->child != NULL)
		parse_mdoc_fname(mpage, n->child);

	return 0;
}

static int
parse_mdoc_Va(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{
	char *cp;

	if (n->type != ROFFT_ELEM && n->type != ROFFT_BODY)
		return 0;

	if (n->child != NULL &&
	    n->child->next == NULL &&
	    n->child->type == ROFFT_TEXT)
		return 1;

	cp = NULL;
	deroff(&cp, n);
	if (cp != NULL) {
		putkey(mpage, cp, TYPE_Vt | (n->tok == MDOC_Va ||
		    n->type == ROFFT_BODY ? TYPE_Va : 0));
		free(cp);
	}

	return 0;
}

static int
parse_mdoc_Xr(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{
	char	*cp;

	if (NULL == (n = n->child))
		return 0;

	if (NULL == n->next) {
		putkey(mpage, n->string, TYPE_Xr);
		return 0;
	}

	mandoc_asprintf(&cp, "%s(%s)", n->string, n->next->string);
	putkey(mpage, cp, TYPE_Xr);
	free(cp);
	return 0;
}

static int
parse_mdoc_Nd(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	if (n->type == ROFFT_BODY)
		deroff(&mpage->desc, n);
	return 0;
}

static int
parse_mdoc_Nm(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	if (SEC_NAME == n->sec)
		putmdockey(mpage, n->child, NAME_TITLE, 0);
	else if (n->sec == SEC_SYNOPSIS && n->type == ROFFT_HEAD) {
		if (n->child == NULL)
			putkey(mpage, meta->name, NAME_SYN);
		else
			putmdockey(mpage, n->child, NAME_SYN, 0);
	}
	if ( ! (mpage->name_head_done ||
	    n->child == NULL || n->child->string == NULL ||
	    strcasecmp(n->child->string, meta->title))) {
		putkey(mpage, n->child->string, NAME_HEAD);
		mpage->name_head_done = 1;
	}
	return 0;
}

static int
parse_mdoc_Sh(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	return n->sec == SEC_CUSTOM && n->type == ROFFT_HEAD;
}

static int
parse_mdoc_head(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	return n->type == ROFFT_HEAD;
}

/*
 * Add a string to the hash table for the current manual.
 * Each string has a bitmask telling which macros it belongs to.
 * When we finish the manual, we'll dump the table.
 */
static void
putkeys(const struct mpage *mpage, char *cp, size_t sz, uint64_t v)
{
	struct ohash	*htab;
	struct str	*s;
	const char	*end;
	unsigned int	 slot;
	int		 i, mustfree;

	if (0 == sz)
		return;

	mustfree = render_string(&cp, &sz);

	if (TYPE_Nm & v) {
		htab = &names;
		v &= name_mask;
		if (v & NAME_FIRST)
			name_mask &= ~NAME_FIRST;
		if (debug > 1)
			say(mpage->mlinks->file,
			    "Adding name %*s, bits=0x%llx", (int)sz, cp,
			    (unsigned long long)v);
	} else {
		htab = &strings;
		if (debug > 1)
		    for (i = 0; i < KEY_MAX; i++)
			if ((uint64_t)1 << i & v)
			    say(mpage->mlinks->file,
				"Adding key %s=%*s",
				mansearch_keynames[i], (int)sz, cp);
	}

	end = cp + sz;
	slot = ohash_qlookupi(htab, cp, &end);
	s = ohash_find(htab, slot);

	if (NULL != s && mpage == s->mpage) {
		s->mask |= v;
		return;
	} else if (NULL == s) {
		s = mandoc_calloc(1, sizeof(struct str) + sz + 1);
		memcpy(s->key, cp, sz);
		ohash_insert(htab, slot, s);
	}
	s->mpage = mpage;
	s->mask = v;

	if (mustfree)
		free(cp);
}

/*
 * Take a Unicode codepoint and produce its UTF-8 encoding.
 * This isn't the best way to do this, but it works.
 * The magic numbers are from the UTF-8 packaging.
 * They're not as scary as they seem: read the UTF-8 spec for details.
 */
static size_t
utf8(unsigned int cp, char out[7])
{
	size_t		 rc;

	rc = 0;
	if (cp <= 0x0000007F) {
		rc = 1;
		out[0] = (char)cp;
	} else if (cp <= 0x000007FF) {
		rc = 2;
		out[0] = (cp >> 6  & 31) | 192;
		out[1] = (cp       & 63) | 128;
	} else if (cp <= 0x0000FFFF) {
		rc = 3;
		out[0] = (cp >> 12 & 15) | 224;
		out[1] = (cp >> 6  & 63) | 128;
		out[2] = (cp       & 63) | 128;
	} else if (cp <= 0x001FFFFF) {
		rc = 4;
		out[0] = (cp >> 18 &  7) | 240;
		out[1] = (cp >> 12 & 63) | 128;
		out[2] = (cp >> 6  & 63) | 128;
		out[3] = (cp       & 63) | 128;
	} else if (cp <= 0x03FFFFFF) {
		rc = 5;
		out[0] = (cp >> 24 &  3) | 248;
		out[1] = (cp >> 18 & 63) | 128;
		out[2] = (cp >> 12 & 63) | 128;
		out[3] = (cp >> 6  & 63) | 128;
		out[4] = (cp       & 63) | 128;
	} else if (cp <= 0x7FFFFFFF) {
		rc = 6;
		out[0] = (cp >> 30 &  1) | 252;
		out[1] = (cp >> 24 & 63) | 128;
		out[2] = (cp >> 18 & 63) | 128;
		out[3] = (cp >> 12 & 63) | 128;
		out[4] = (cp >> 6  & 63) | 128;
		out[5] = (cp       & 63) | 128;
	} else
		return 0;

	out[rc] = '\0';
	return rc;
}

/*
 * If the string contains escape sequences,
 * replace it with an allocated rendering and return 1,
 * such that the caller can free it after use.
 * Otherwise, do nothing and return 0.
 */
static int
render_string(char **public, size_t *psz)
{
	const char	*src, *scp, *addcp, *seq;
	char		*dst;
	size_t		 ssz, dsz, addsz;
	char		 utfbuf[7], res[6];
	int		 seqlen, unicode;

	res[0] = '\\';
	res[1] = '\t';
	res[2] = ASCII_NBRSP;
	res[3] = ASCII_HYPH;
	res[4] = ASCII_BREAK;
	res[5] = '\0';

	src = scp = *public;
	ssz = *psz;
	dst = NULL;
	dsz = 0;

	while (scp < src + *psz) {

		/* Leave normal characters unchanged. */

		if (strchr(res, *scp) == NULL) {
			if (dst != NULL)
				dst[dsz++] = *scp;
			scp++;
			continue;
		}

		/*
		 * Found something that requires replacing,
		 * make sure we have a destination buffer.
		 */

		if (dst == NULL) {
			dst = mandoc_malloc(ssz + 1);
			dsz = scp - src;
			memcpy(dst, src, dsz);
		}

		/* Handle single-char special characters. */

		switch (*scp) {
		case '\\':
			break;
		case '\t':
		case ASCII_NBRSP:
			dst[dsz++] = ' ';
			scp++;
			continue;
		case ASCII_HYPH:
			dst[dsz++] = '-';
			/* FALLTHROUGH */
		case ASCII_BREAK:
			scp++;
			continue;
		default:
			abort();
		}

		/*
		 * Found an escape sequence.
		 * Read past the slash, then parse it.
		 * Ignore everything except characters.
		 */

		scp++;
		if (mandoc_escape(&scp, &seq, &seqlen) != ESCAPE_SPECIAL)
			continue;

		/*
		 * Render the special character
		 * as either UTF-8 or ASCII.
		 */

		if (write_utf8) {
			unicode = mchars_spec2cp(seq, seqlen);
			if (unicode <= 0)
				continue;
			addsz = utf8(unicode, utfbuf);
			if (addsz == 0)
				continue;
			addcp = utfbuf;
		} else {
			addcp = mchars_spec2str(seq, seqlen, &addsz);
			if (addcp == NULL)
				continue;
			if (*addcp == ASCII_NBRSP) {
				addcp = " ";
				addsz = 1;
			}
		}

		/* Copy the rendered glyph into the stream. */

		ssz += addsz;
		dst = mandoc_realloc(dst, ssz + 1);
		memcpy(dst + dsz, addcp, addsz);
		dsz += addsz;
	}
	if (dst != NULL) {
		*public = dst;
		*psz = dsz;
	}

	/* Trim trailing whitespace and NUL-terminate. */

	while (*psz > 0 && (*public)[*psz - 1] == ' ')
		--*psz;
	if (dst != NULL) {
		(*public)[*psz] = '\0';
		return 1;
	} else
		return 0;
}

static void
dbadd_mlink(const struct mlink *mlink)
{
	dba_page_alias(mlink->mpage->dba, mlink->name, NAME_FILE);
	dba_page_add(mlink->mpage->dba, DBP_SECT, mlink->dsec);
	dba_page_add(mlink->mpage->dba, DBP_SECT, mlink->fsec);
	dba_page_add(mlink->mpage->dba, DBP_ARCH, mlink->arch);
	dba_page_add(mlink->mpage->dba, DBP_FILE, mlink->file);
}

/*
 * Flush the current page's terms (and their bits) into the database.
 * Also, handle escape sequences at the last possible moment.
 */
static void
dbadd(struct dba *dba, struct mpage *mpage)
{
	struct mlink	*mlink;
	struct str	*key;
	char		*cp;
	uint64_t	 mask;
	size_t		 i;
	unsigned int	 slot;
	int		 mustfree;

	mlink = mpage->mlinks;

	if (nodb) {
		for (key = ohash_first(&names, &slot); NULL != key;
		     key = ohash_next(&names, &slot))
			free(key);
		for (key = ohash_first(&strings, &slot); NULL != key;
		     key = ohash_next(&strings, &slot))
			free(key);
		if (0 == debug)
			return;
		while (NULL != mlink) {
			fputs(mlink->name, stdout);
			if (NULL == mlink->next ||
			    strcmp(mlink->dsec, mlink->next->dsec) ||
			    strcmp(mlink->fsec, mlink->next->fsec) ||
			    strcmp(mlink->arch, mlink->next->arch)) {
				putchar('(');
				if ('\0' == *mlink->dsec)
					fputs(mlink->fsec, stdout);
				else
					fputs(mlink->dsec, stdout);
				if ('\0' != *mlink->arch)
					printf("/%s", mlink->arch);
				putchar(')');
			}
			mlink = mlink->next;
			if (NULL != mlink)
				fputs(", ", stdout);
		}
		printf(" - %s\n", mpage->desc);
		return;
	}

	if (debug)
		say(mlink->file, "Adding to database");

	cp = mpage->desc;
	i = strlen(cp);
	mustfree = render_string(&cp, &i);
	mpage->dba = dba_page_new(dba->pages,
	    *mpage->arch == '\0' ? mlink->arch : mpage->arch,
	    cp, mlink->file, mpage->form);
	if (mustfree)
		free(cp);
	dba_page_add(mpage->dba, DBP_SECT, mpage->sec);

	while (mlink != NULL) {
		dbadd_mlink(mlink);
		mlink = mlink->next;
	}

	for (key = ohash_first(&names, &slot); NULL != key;
	     key = ohash_next(&names, &slot)) {
		assert(key->mpage == mpage);
		dba_page_alias(mpage->dba, key->key, key->mask);
		free(key);
	}
	for (key = ohash_first(&strings, &slot); NULL != key;
	     key = ohash_next(&strings, &slot)) {
		assert(key->mpage == mpage);
		i = 0;
		for (mask = TYPE_Xr; mask <= TYPE_Lb; mask *= 2) {
			if (key->mask & mask)
				dba_macro_add(dba->macros, i,
				    key->key, mpage->dba);
			i++;
		}
		free(key);
	}
}

static void
dbprune(struct dba *dba)
{
	struct dba_array	*page, *files;
	char			*file;

	dba_array_FOREACH(dba->pages, page) {
		files = dba_array_get(page, DBP_FILE);
		dba_array_FOREACH(files, file) {
			if (*file < ' ')
				file++;
			if (ohash_find(&mlinks, ohash_qlookup(&mlinks,
			    file)) != NULL) {
				if (debug)
					say(file, "Deleting from database");
				dba_array_del(dba->pages);
				break;
			}
		}
	}
}

/*
 * Write the database from memory to disk.
 */
static void
dbwrite(struct dba *dba)
{
	char		 tfn[32];
	int		 status;
	pid_t		 child;

	if (dba_write(MANDOC_DB "~", dba) != -1) {
		if (rename(MANDOC_DB "~", MANDOC_DB) == -1) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say(MANDOC_DB, "&rename");
			unlink(MANDOC_DB "~");
		}
		return;
	}

	(void)strlcpy(tfn, "/tmp/mandocdb.XXXXXXXX", sizeof(tfn));
	if (mkdtemp(tfn) == NULL) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&%s", tfn);
		return;
	}

	(void)strlcat(tfn, "/" MANDOC_DB, sizeof(tfn));
	if (dba_write(tfn, dba) == -1) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(tfn, "&dba_write");
		goto out;
	}

	switch (child = fork()) {
	case -1:
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&fork cmp");
		return;
	case 0:
		execlp("cmp", "cmp", "-s", tfn, MANDOC_DB, (char *)NULL);
		say("", "&exec cmp");
		exit(0);
	default:
		break;
	}
	if (waitpid(child, &status, 0) == -1) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&wait cmp");
	} else if (WIFSIGNALED(status)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "cmp died from signal %d", WTERMSIG(status));
	} else if (WEXITSTATUS(status)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(MANDOC_DB,
		    "Data changed, but cannot replace database");
	}

out:
	*strrchr(tfn, '/') = '\0';
	switch (child = fork()) {
	case -1:
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&fork rm");
		return;
	case 0:
		execlp("rm", "rm", "-rf", tfn, (char *)NULL);
		say("", "&exec rm");
		exit((int)MANDOCLEVEL_SYSERR);
	default:
		break;
	}
	if (waitpid(child, &status, 0) == -1) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&wait rm");
	} else if (WIFSIGNALED(status) || WEXITSTATUS(status)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "%s: Cannot remove temporary directory", tfn);
	}
}

static int
set_basedir(const char *targetdir, int report_baddir)
{
	static char	 startdir[PATH_MAX];
	static int	 getcwd_status;  /* 1 = ok, 2 = failure */
	static int	 chdir_status;  /* 1 = changed directory */
	char		*cp;

	/*
	 * Remember the original working directory, if possible.
	 * This will be needed if the second or a later directory
	 * on the command line is given as a relative path.
	 * Do not error out if the current directory is not
	 * searchable: Maybe it won't be needed after all.
	 */
	if (0 == getcwd_status) {
		if (NULL == getcwd(startdir, sizeof(startdir))) {
			getcwd_status = 2;
			(void)strlcpy(startdir, strerror(errno),
			    sizeof(startdir));
		} else
			getcwd_status = 1;
	}

	/*
	 * We are leaving the old base directory.
	 * Do not use it any longer, not even for messages.
	 */
	*basedir = '\0';

	/*
	 * If and only if the directory was changed earlier and
	 * the next directory to process is given as a relative path,
	 * first go back, or bail out if that is impossible.
	 */
	if (chdir_status && '/' != *targetdir) {
		if (2 == getcwd_status) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say("", "getcwd: %s", startdir);
			return 0;
		}
		if (-1 == chdir(startdir)) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say("", "&chdir %s", startdir);
			return 0;
		}
	}

	/*
	 * Always resolve basedir to the canonicalized absolute
	 * pathname and append a trailing slash, such that
	 * we can reliably check whether files are inside.
	 */
	if (NULL == realpath(targetdir, basedir)) {
		if (report_baddir || errno != ENOENT) {
			exitcode = (int)MANDOCLEVEL_BADARG;
			say("", "&%s: realpath", targetdir);
		}
		return 0;
	} else if (-1 == chdir(basedir)) {
		if (report_baddir || errno != ENOENT) {
			exitcode = (int)MANDOCLEVEL_BADARG;
			say("", "&chdir");
		}
		return 0;
	}
	chdir_status = 1;
	cp = strchr(basedir, '\0');
	if ('/' != cp[-1]) {
		if (cp - basedir >= PATH_MAX - 1) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say("", "Filename too long");
			return 0;
		}
		*cp++ = '/';
		*cp = '\0';
	}
	return 1;
}

static void
say(const char *file, const char *format, ...)
{
	va_list		 ap;
	int		 use_errno;

	if ('\0' != *basedir)
		fprintf(stderr, "%s", basedir);
	if ('\0' != *basedir && '\0' != *file)
		fputc('/', stderr);
	if ('\0' != *file)
		fprintf(stderr, "%s", file);

	use_errno = 1;
	if (NULL != format) {
		switch (*format) {
		case '&':
			format++;
			break;
		case '\0':
			format = NULL;
			break;
		default:
			use_errno = 0;
			break;
		}
	}
	if (NULL != format) {
		if ('\0' != *basedir || '\0' != *file)
			fputs(": ", stderr);
		va_start(ap, format);
		vfprintf(stderr, format, ap);
		va_end(ap);
	}
	if (use_errno) {
		if ('\0' != *basedir || '\0' != *file || NULL != format)
			fputs(": ", stderr);
		perror(NULL);
	} else
		fputc('\n', stderr);
}
@


1.197
log
@move .ll to the roff modules
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.196 2017/05/04 17:48:24 schwarze Exp $ */
a289 1
	{ NULL, 0, 0 },  /* sp */
@


1.196
log
@Parser reorg:
Generate the first node on the roff level: .br
Fix some column numbers in diagnostic messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.195 2017/04/24 23:06:09 schwarze Exp $ */
a292 1
	{ NULL, 0, 0 },  /* ll */
@


1.195
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.194 2017/03/03 13:41:28 schwarze Exp $ */
a289 1
	{ NULL, 0, 0 },  /* br */
d1509 3
a1511 1
		if (n->tok == TOKEN_NONE || n->flags & mdocs[n->tok].taboo)
d1513 1
@


1.194
log
@Fix a copy-and-paste error that caused man(7) manuals without
a section number in .TH to be misinterpreted as preformatted.
Found by jsg@@ with cppcheck.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.193 2017/02/09 19:50:47 schwarze Exp $ */
d171 1
a171 2
static	const struct mdoc_handler mdocs[MDOC_MAX] = {
	{ NULL, 0, 0 },  /* Ap */
d187 1
d296 1
d1509 2
a1510 3
	assert(NULL != n);
	for (n = n->child; NULL != n; n = n->next) {
		if (n->flags & mdocs[n->tok].taboo)
d1518 3
a1520 3
			if (NULL != mdocs[n->tok].fp)
			       if (0 == (*mdocs[n->tok].fp)(mpage, meta, n))
				       break;
a1525 1
			assert(n->type != ROFFT_ROOT);
@


1.193
log
@No need to cast NULL when assigning it to a variable;
from Christos Zoulas <christos at NetBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.192 2017/02/09 17:19:07 schwarze Exp $ */
d1174 1
a1174 1
			    *man->meta.msec != '\0') {
@


1.192
log
@Be consistent in protecting __attribute__ attributes with __;
from Christos Zoulas <christos @@ NetBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.191 2017/01/27 11:33:08 schwarze Exp $ */
d560 1
a560 1
	argv[1] = (char *)NULL;
@


1.191
log
@warn about missing one-line description;
missing feature found in the TODO file
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.190 2017/01/27 01:14:34 schwarze Exp $ */
d150 1
a150 1
			__attribute__((__format__ (printf, 2, 3)));
@


1.190
log
@Parse the section number from the content of preformatted pages
and warn if it doesn't match the directory where the file was found.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.189 2017/01/27 01:09:02 schwarze Exp $ */
d1194 6
a1199 2
		if (mpage->desc == NULL)
			mpage->desc = mandoc_strdup(mpage->mlinks->name);
d1327 2
a1328 1
			say(mlink->file, "No dash in title line");
@


1.189
log
@If parsing a page reveals that it is neither mdoc(7) nor man(7),
fall back to treating it as preformatted rather than treating
it as man(7) anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.188 2017/01/27 01:04:13 schwarze Exp $ */
d1217 2
a1218 1
	char		*line, *p, *title;
d1223 4
a1226 5
	stream = (-1 == fd) ?
	    fopen(mpage->mlinks->file, "r") :
	    fdopen(fd, "r");
	if (NULL == stream) {
		if (-1 != fd)
d1229 1
a1229 1
			say(mpage->mlinks->file, "&fopen");
d1236 19
d1257 2
a1258 2
	while (getline(&line, &linesz, stream) != -1)
		if (*line == '\n')
d1304 1
a1304 2
			say(mpage->mlinks->file,
			    "Cannot find NAME section");
d1323 1
a1323 2
			say(mpage->mlinks->file,
			    "No dash in title line");
@


1.188
log
@fix base directory detection for makewhatis -t
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.187 2017/01/27 00:55:49 schwarze Exp $ */
d1116 1
d1173 12
a1184 5
			mpage->form = FORM_SRC;
			mpage->sec = mandoc_strdup(man->meta.msec);
			mpage->arch = mandoc_strdup(mlink->arch);
			mpage->title = mandoc_strdup(man->meta.title);
		} else {
d1189 2
a1190 4
		}

		assert(mpage->desc == NULL);
		if (man != NULL && man->macroset == MACROSET_MDOC)
d1192 1
a1192 1
		else if (man != NULL)
a1193 2
		else
			parse_cat(mpage, fd);
@


1.187
log
@Always register names taken from file names in the names ohash.
Bug found by makewhatis -p crashing in mlink_check().
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.186 2017/01/11 17:39:45 schwarze Exp $ */
d832 14
@


1.186
log
@Do text production for .Bt, .Ex, .Rv, .Ud at the validation stage
rather than in the formatters.  Use NODE_NOSRC flag for .Lb and
NODE_NOSRC and NODE_NOPRT for .St.  Results in a more rigorous
syntax tree and in 135 lines less code.

This work was triggered by a question from Abhinav Upadhyay <er dot
abhinav dot upadhyay at gmail dot com> (NetBSD) on discuss@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.185 2017/01/10 23:36:24 schwarze Exp $ */
d1179 5
a1183 3
		if (warnings && !use_all)
			for (mlink = mpage->mlinks; mlink;
			     mlink = mlink->next)
d1185 1
a1187 1
		mlink = mpage->mlinks;
@


1.185
log
@Use new NODE_NOSRC and NODE_NOPRT flags for .Bx and .At.
More rigorous AST and 40 lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.184 2017/01/10 21:54:34 schwarze Exp $ */
d227 1
a227 1
	{ NULL, TYPE_At, NODE_NOSRC },  /* At */
d278 1
a278 1
	{ NULL, TYPE_Lb, 0 },  /* Lb */
@


1.184
log
@For the .Ux/.Ox family of macros, do text production at the validation
stage rather than in each and every individual formatter, using the
new NODE_NOSRC flag.  More rigorous and also ten lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.183 2016/10/22 10:08:31 schwarze Exp $ */
d227 1
a227 1
	{ NULL, TYPE_At, 0 },  /* At */
d233 1
a233 1
	{ NULL, TYPE_Bx, 0 },  /* Bx */
@


1.183
log
@cast off_t and uint64_t for printf(3)
to make sure that widths match on all platforms;
from Ed Maste <emaste at freebsd dot org>;
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.182 2016/10/20 16:29:13 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011-2016 Ingo Schwarze <schwarze@@openbsd.org>
d102 1
d147 1
a147 1
			const struct roff_node *, uint64_t);
d172 123
a294 123
	{ NULL, 0 },  /* Ap */
	{ NULL, 0 },  /* Dd */
	{ NULL, 0 },  /* Dt */
	{ NULL, 0 },  /* Os */
	{ parse_mdoc_Sh, TYPE_Sh }, /* Sh */
	{ parse_mdoc_head, TYPE_Ss }, /* Ss */
	{ NULL, 0 },  /* Pp */
	{ NULL, 0 },  /* D1 */
	{ NULL, 0 },  /* Dl */
	{ NULL, 0 },  /* Bd */
	{ NULL, 0 },  /* Ed */
	{ NULL, 0 },  /* Bl */
	{ NULL, 0 },  /* El */
	{ NULL, 0 },  /* It */
	{ NULL, 0 },  /* Ad */
	{ NULL, TYPE_An },  /* An */
	{ NULL, TYPE_Ar },  /* Ar */
	{ NULL, TYPE_Cd },  /* Cd */
	{ NULL, TYPE_Cm },  /* Cm */
	{ NULL, TYPE_Dv },  /* Dv */
	{ NULL, TYPE_Er },  /* Er */
	{ NULL, TYPE_Ev },  /* Ev */
	{ NULL, 0 },  /* Ex */
	{ NULL, TYPE_Fa },  /* Fa */
	{ parse_mdoc_Fd, 0 },  /* Fd */
	{ NULL, TYPE_Fl },  /* Fl */
	{ parse_mdoc_Fn, 0 },  /* Fn */
	{ NULL, TYPE_Ft },  /* Ft */
	{ NULL, TYPE_Ic },  /* Ic */
	{ NULL, TYPE_In },  /* In */
	{ NULL, TYPE_Li },  /* Li */
	{ parse_mdoc_Nd, 0 },  /* Nd */
	{ parse_mdoc_Nm, 0 },  /* Nm */
	{ NULL, 0 },  /* Op */
	{ NULL, 0 },  /* Ot */
	{ NULL, TYPE_Pa },  /* Pa */
	{ NULL, 0 },  /* Rv */
	{ NULL, TYPE_St },  /* St */
	{ parse_mdoc_Va, TYPE_Va },  /* Va */
	{ parse_mdoc_Va, TYPE_Vt },  /* Vt */
	{ parse_mdoc_Xr, 0 },  /* Xr */
	{ NULL, 0 },  /* %A */
	{ NULL, 0 },  /* %B */
	{ NULL, 0 },  /* %D */
	{ NULL, 0 },  /* %I */
	{ NULL, 0 },  /* %J */
	{ NULL, 0 },  /* %N */
	{ NULL, 0 },  /* %O */
	{ NULL, 0 },  /* %P */
	{ NULL, 0 },  /* %R */
	{ NULL, 0 },  /* %T */
	{ NULL, 0 },  /* %V */
	{ NULL, 0 },  /* Ac */
	{ NULL, 0 },  /* Ao */
	{ NULL, 0 },  /* Aq */
	{ NULL, TYPE_At },  /* At */
	{ NULL, 0 },  /* Bc */
	{ NULL, 0 },  /* Bf */
	{ NULL, 0 },  /* Bo */
	{ NULL, 0 },  /* Bq */
	{ NULL, TYPE_Bsx },  /* Bsx */
	{ NULL, TYPE_Bx },  /* Bx */
	{ NULL, 0 },  /* Db */
	{ NULL, 0 },  /* Dc */
	{ NULL, 0 },  /* Do */
	{ NULL, 0 },  /* Dq */
	{ NULL, 0 },  /* Ec */
	{ NULL, 0 },  /* Ef */
	{ NULL, TYPE_Em },  /* Em */
	{ NULL, 0 },  /* Eo */
	{ NULL, TYPE_Fx },  /* Fx */
	{ NULL, TYPE_Ms },  /* Ms */
	{ NULL, 0 },  /* No */
	{ NULL, 0 },  /* Ns */
	{ NULL, TYPE_Nx },  /* Nx */
	{ NULL, TYPE_Ox },  /* Ox */
	{ NULL, 0 },  /* Pc */
	{ NULL, 0 },  /* Pf */
	{ NULL, 0 },  /* Po */
	{ NULL, 0 },  /* Pq */
	{ NULL, 0 },  /* Qc */
	{ NULL, 0 },  /* Ql */
	{ NULL, 0 },  /* Qo */
	{ NULL, 0 },  /* Qq */
	{ NULL, 0 },  /* Re */
	{ NULL, 0 },  /* Rs */
	{ NULL, 0 },  /* Sc */
	{ NULL, 0 },  /* So */
	{ NULL, 0 },  /* Sq */
	{ NULL, 0 },  /* Sm */
	{ NULL, 0 },  /* Sx */
	{ NULL, TYPE_Sy },  /* Sy */
	{ NULL, TYPE_Tn },  /* Tn */
	{ NULL, 0 },  /* Ux */
	{ NULL, 0 },  /* Xc */
	{ NULL, 0 },  /* Xo */
	{ parse_mdoc_Fo, 0 },  /* Fo */
	{ NULL, 0 },  /* Fc */
	{ NULL, 0 },  /* Oo */
	{ NULL, 0 },  /* Oc */
	{ NULL, 0 },  /* Bk */
	{ NULL, 0 },  /* Ek */
	{ NULL, 0 },  /* Bt */
	{ NULL, 0 },  /* Hf */
	{ NULL, 0 },  /* Fr */
	{ NULL, 0 },  /* Ud */
	{ NULL, TYPE_Lb },  /* Lb */
	{ NULL, 0 },  /* Lp */
	{ NULL, TYPE_Lk },  /* Lk */
	{ NULL, TYPE_Mt },  /* Mt */
	{ NULL, 0 },  /* Brq */
	{ NULL, 0 },  /* Bro */
	{ NULL, 0 },  /* Brc */
	{ NULL, 0 },  /* %C */
	{ NULL, 0 },  /* Es */
	{ NULL, 0 },  /* En */
	{ NULL, TYPE_Dx },  /* Dx */
	{ NULL, 0 },  /* %Q */
	{ NULL, 0 },  /* br */
	{ NULL, 0 },  /* sp */
	{ NULL, 0 },  /* %U */
	{ NULL, 0 },  /* Ta */
	{ NULL, 0 },  /* ll */
d1323 1
a1323 1
	const struct roff_node *n, uint64_t m)
d1327 2
d1330 1
a1330 1
			putmdockey(mpage, n->child, m);
d1468 2
d1481 1
a1481 1
				    mdocs[n->tok].mask);
d1649 1
a1649 1
		putmdockey(mpage, n->child, NAME_TITLE);
d1654 1
a1654 1
			putmdockey(mpage, n->child, NAME_SYN);
@


1.182
log
@0x%llu is a bad idea, make that 0x%llx;
noticed while investigating a report from Ed Maste
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.181 2016/10/18 14:20:07 schwarze Exp $ */
d1702 2
a1703 1
			    "Adding name %*s, bits=0x%llx", (int)sz, cp, v);
@


1.181
log
@Fix a comment: We don't have manpath(1).  No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.180 2016/10/18 14:13:46 schwarze Exp $ */
d1702 1
a1702 1
			    "Adding name %*s, bits=0x%llu", (int)sz, cp, v);
@


1.180
log
@Simplify and correct support for reproducible builds, such that database
entries come in a well-defined order even in the presence of MLINKS.
Do this by using the compar() argument of fts_open(3) rather than
trying to sort later, which missed some cases.
This also shortens the code by a few lines.

Diff from Ed Maste <emaste @@ FreeBSD>, adapted to our tree
and tweaked a bit by me, final version confirmed by Ed.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.179 2016/09/02 14:03:24 schwarze Exp $ */
d448 1
a448 2
		 * If we don't, grok from manpath(1) or however else
		 * manconf_parse() wants to do it.
@


1.179
log
@When "makewhatis -d" tries to add to a database that doesn't (yet) exist,
silently create it from scratch instead of printing a warning.
The annoying warning message was reported by ajacoutot@@, and espie@@
convincingly argues that a non-existing database can be considered
equivalent to an empty one.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.178 2016/09/01 15:07:46 schwarze Exp $ */
d5 1
d77 1
d112 1
a116 1
int		 mpages_compare(const void *, const void *);
d163 1
d523 10
d562 2
a563 2
	f = fts_open((char * const *)argv,
	    FTS_PHYSICAL | FTS_NOCHDIR, NULL);
d921 2
a945 1
	unsigned int	 slot;
d947 2
a948 3
	mpage = ohash_first(&mpages, &slot);
	while (NULL != mpage) {
		while (NULL != (mlink = mpage->mlinks)) {
d952 1
a957 1
		mpage = ohash_next(&mpages, &slot);
d1071 1
a1071 1
	struct mpage		**mplist, *mpage, *mpage_dest;
a1076 1
	unsigned int		 ip, npages, pslot;
d1078 1
a1078 5
	npages = ohash_entries(&mpages);
	mplist = mandoc_reallocarray(NULL, npages, sizeof(*mplist));
	ip = 0;
	mpage = ohash_first(&mpages, &pslot);
	while (mpage != NULL) {
d1080 2
a1081 6
		if (mpage->mlinks != NULL)
			mplist[ip++] = mpage;
		mpage = ohash_next(&mpages, &pslot);
	}
	npages = ip;
	qsort(mplist, npages, sizeof(*mplist), mpages_compare);
a1082 3
	for (ip = 0; ip < npages; ip++) {
		mpage = mplist[ip];
		mlink = mpage->mlinks;
a1190 11
	free(mplist);
}

int
mpages_compare(const void *vp1, const void *vp2)
{
	const struct mpage	*mp1, *mp2;

	mp1 = *(const struct mpage **)vp1;
	mp2 = *(const struct mpage **)vp2;
	return strcmp(mp1->mlinks->file, mp2->mlinks->file);
@


1.178
log
@remove "sparc" from a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.177 2016/08/22 16:12:52 schwarze Exp $ */
d428 3
a430 3
			say(MANDOC_DB,
			    "%s: Automatically recreating from scratch",
			    strerror(errno));
@


1.177
log
@When trying to edit an existing database with makewhatis(8) -d or -u
but reading the database fails, report the full path to the database
on standard error, and mention that the database is automatically
recreated from scratch.
Suggested by espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.176 2016/08/17 20:46:06 schwarze Exp $ */
d1021 1
a1021 1
	 * on amd64, i386, sparc, and sparc64.
@


1.176
log
@When the content of a manual page does not specify a section, the
empty string got added to the list of sections, breaking the database
format slightly and causing the page to not be considered part of
any section, not even if a section could be deduced from the directory
or from the file name.
Bug found due to the bogus pcredemo(3) "manual" in the pcre-8.38p0 package.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.175 2016/08/05 17:20:30 schwarze Exp $ */
d427 4
a430 4
			/*
			 * Database missing or corrupt.
			 * Recreate from scratch.
			 */
@


1.175
log
@fix a typo that prevented names from .Dt from getting priority over
names from .Sh NAME; no dire consequences on OpenBSD since we no
longer have MLINKS for mdoc(7) pages
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.174 2016/08/01 20:46:33 schwarze Exp $ */
d1985 1
a1985 1
	mpage->dba = dba_page_new(dba->pages, mlink->name, mpage->sec,
d1990 1
@


1.174
log
@Repair makewhatis -t, sorry for breaking it in the previous commit.
Committing this quickly because it hurts package builders.
Regression reported by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.173 2016/08/01 10:32:39 schwarze Exp $ */
d1665 1
a1665 1
		putkey(mpage, n->child->string, ROFFT_HEAD);
@


1.173
log
@Remove the dependency on SQLite without loss of functionality.
Drop the obsolete names_check() now that we deleted MLINKS.
Run "doas makewhatis" after compiling and installing this.

Earlier version tested by jmc@@ and jturner@@;
"commit it all" deraadt@@   "commit and dodge" krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.172 2016/07/19 13:30:16 schwarze Exp $ */
d408 2
a409 1
		if ((dba = dba_read(MANDOC_DB)) != NULL) {
d424 1
a424 1
			if (OP_TEST != op)
@


1.172
log
@Use __attribute__((__format__ throughout.
Triggered by a smaller patch from Christos Zoulas.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.171 2016/07/15 18:02:32 schwarze Exp $ */
d29 1
a36 2
#include <sqlite3.h>

d45 2
a47 1
extern int mansearch_keymax;
a49 19
#define	SQL_EXEC(_v) \
	if (SQLITE_OK != sqlite3_exec(db, (_v), NULL, NULL, NULL)) \
		say("", "%s: %s", (_v), sqlite3_errmsg(db))
#define	SQL_BIND_TEXT(_s, _i, _v) \
	if (SQLITE_OK != sqlite3_bind_text \
		((_s), (_i)++, (_v), -1, SQLITE_STATIC)) \
		say(mlink->file, "%s", sqlite3_errmsg(db))
#define	SQL_BIND_INT(_s, _i, _v) \
	if (SQLITE_OK != sqlite3_bind_int \
		((_s), (_i)++, (_v))) \
		say(mlink->file, "%s", sqlite3_errmsg(db))
#define	SQL_BIND_INT64(_s, _i, _v) \
	if (SQLITE_OK != sqlite3_bind_int64 \
		((_s), (_i)++, (_v))) \
		say(mlink->file, "%s", sqlite3_errmsg(db))
#define SQL_STEP(_s) \
	if (SQLITE_DONE != sqlite3_step((_s))) \
		say(mlink->file, "%s", sqlite3_errmsg(db))

d71 1
a71 1
	int64_t		 pageid;  /* pageid in mpages SQL table */
a76 1
	int		 form;    /* format from file content */
d78 1
a88 2
	int		 dform;   /* format from directory */
	int		 fform;   /* format from file name suffix */
d90 2
a91 10
};

enum	stmt {
	STMT_DELETE_PAGE = 0,	/* delete mpage */
	STMT_INSERT_PAGE,	/* insert mpage */
	STMT_INSERT_LINK,	/* insert mlink */
	STMT_INSERT_NAME,	/* insert name */
	STMT_SELECT_NAME,	/* retrieve existing name flags */
	STMT_INSERT_KEY,	/* insert parsed key */
	STMT__MAX
d105 1
a105 2
static	void	 dbclose(int);
static	void	 dbadd(struct mpage *);
d107 2
a108 3
static	void	 dbadd_mlink_name(const struct mlink *mlink);
static	int	 dbopen(int);
static	void	 dbprune(void);
d114 1
d116 1
a116 2
static	void	 mpages_merge(struct mparse *);
static	void	 names_check(void);
a151 1
static	char		 tempfilename[32];
a164 2
static	sqlite3		*db = NULL; /* current database */
static	sqlite3_stmt	*stmts[STMT__MAX]; /* current statements */
d299 1
a309 1
	memset(stmts, 0, STMT__MAX * sizeof(sqlite3_stmt *));
d408 1
a408 1
		if (dbopen(1)) {
d424 1
a424 1
				dbprune();
d434 1
a434 2
			if (0 == dbopen(0))
				goto out;
d437 4
a440 2
			mpages_merge(mp);
		dbclose(OP_DEFAULT == op ? 0 : 1);
d485 5
a489 8
			if (0 == dbopen(0))
				continue;

			mpages_merge(mp);
			if (warnings && !nodb &&
			    ! (MPARSE_QUICK & mparse_options))
				names_check();
			dbclose(0);
d539 2
a540 1
	int		 dform, gzip;
d906 1
d1055 1
a1055 1
mpages_merge(struct mparse *mp)
d1057 1
a1057 2
	char			 any[] = "any";
	struct mpage		*mpage, *mpage_dest;
d1063 1
a1063 4
	unsigned int		 pslot;

	if ( ! nodb)
		SQL_EXEC("BEGIN TRANSACTION");
d1065 3
d1071 6
a1076 4
		if ((mlink = mpage->mlinks) == NULL) {
			mpage = ohash_next(&mpages, &pslot);
			continue;
		}
d1078 3
d1129 2
a1130 2
					if (mpage_dest->pageid)
						dbadd_mlink_name(mlink);
a1165 13
		putkey(mpage, mpage->sec, TYPE_sec);
		if (*mpage->arch != '\0')
			putkey(mpage, mpage->arch, TYPE_arch);

		for ( ; mlink != NULL; mlink = mlink->next) {
			if ('\0' != *mlink->dsec)
				putkey(mpage, mlink->dsec, TYPE_sec);
			if ('\0' != *mlink->fsec)
				putkey(mpage, mlink->fsec, TYPE_sec);
			putkey(mpage, '\0' == *mlink->arch ?
			    any : mlink->arch, TYPE_arch);
			putkey(mpage, mlink->name, NAME_FILE);
		}
d1182 1
a1182 1
		dbadd(mpage);
a1187 1
		mpage = ohash_next(&mpages, &pslot);
d1189 1
a1189 3

	if (0 == nodb)
		SQL_EXEC("END TRANSACTION");
d1192 2
a1193 2
static void
names_check(void)
d1195 1
a1195 2
	sqlite3_stmt	*stmt;
	const char	*name, *sec, *arch, *key;
d1197 3
a1199 27
	sqlite3_prepare_v2(db,
	  "SELECT name, sec, arch, key FROM ("
	    "SELECT name AS key, pageid FROM names "
	    "WHERE bits & ? AND NOT EXISTS ("
	      "SELECT pageid FROM mlinks "
	      "WHERE mlinks.pageid == names.pageid "
	      "AND mlinks.name == names.name"
	    ")"
	  ") JOIN ("
	    "SELECT sec, arch, name, pageid FROM mlinks "
	    "GROUP BY pageid"
	  ") USING (pageid);",
	  -1, &stmt, NULL);

	if (sqlite3_bind_int64(stmt, 1, NAME_TITLE) != SQLITE_OK)
		say("", "%s", sqlite3_errmsg(db));

	while (sqlite3_step(stmt) == SQLITE_ROW) {
		name = (const char *)sqlite3_column_text(stmt, 0);
		sec  = (const char *)sqlite3_column_text(stmt, 1);
		arch = (const char *)sqlite3_column_text(stmt, 2);
		key  = (const char *)sqlite3_column_text(stmt, 3);
		say("", "%s(%s%s%s) lacks mlink \"%s\"", name, sec,
		    '\0' == *arch ? "" : "/",
		    '\0' == *arch ? "" : arch, key);
	}
	sqlite3_finalize(stmt);
a1323 7
	char	 *cp;

	assert(NULL != value);
	if (TYPE_arch == type)
		for (cp = value; *cp; cp++)
			if (isupper((unsigned char)*cp))
				*cp = _tolower((unsigned char)*cp);
d1716 1
a1716 1
		    for (i = 0; i < mansearch_keymax; i++)
d1922 5
a1926 33
	size_t		 i;

	i = 1;
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->dsec);
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->arch);
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->name);
	SQL_BIND_INT64(stmts[STMT_INSERT_LINK], i, mlink->mpage->pageid);
	SQL_STEP(stmts[STMT_INSERT_LINK]);
	sqlite3_reset(stmts[STMT_INSERT_LINK]);
}

static void
dbadd_mlink_name(const struct mlink *mlink)
{
	uint64_t	 bits;
	size_t		 i;

	dbadd_mlink(mlink);

	i = 1;
	SQL_BIND_INT64(stmts[STMT_SELECT_NAME], i, mlink->mpage->pageid);
	bits = NAME_FILE & NAME_MASK;
	if (sqlite3_step(stmts[STMT_SELECT_NAME]) == SQLITE_ROW) {
		bits |= sqlite3_column_int64(stmts[STMT_SELECT_NAME], 0);
		sqlite3_reset(stmts[STMT_SELECT_NAME]);
	}

	i = 1;
	SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, bits);
	SQL_BIND_TEXT(stmts[STMT_INSERT_NAME], i, mlink->name);
	SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, mlink->mpage->pageid);
	SQL_STEP(stmts[STMT_INSERT_NAME]);
	sqlite3_reset(stmts[STMT_INSERT_NAME]);
a1930 2
 * Wrap the entire set of additions in a transaction to make sqlite be a
 * little faster.
d1934 1
a1934 1
dbadd(struct mpage *mpage)
d1939 1
d1984 3
a1986 6
	i = 1;
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, cp);
	SQL_BIND_INT(stmts[STMT_INSERT_PAGE], i, mpage->form);
	SQL_STEP(stmts[STMT_INSERT_PAGE]);
	mpage->pageid = sqlite3_last_insert_rowid(db);
	sqlite3_reset(stmts[STMT_INSERT_PAGE]);
d1990 1
a1990 1
	while (NULL != mlink) {
a1993 1
	mlink = mpage->mlinks;
d1998 1
a1998 6
		i = 1;
		SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, key->mask);
		SQL_BIND_TEXT(stmts[STMT_INSERT_NAME], i, key->key);
		SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, mpage->pageid);
		SQL_STEP(stmts[STMT_INSERT_NAME]);
		sqlite3_reset(stmts[STMT_INSERT_NAME]);
d2004 7
a2010 6
		i = 1;
		SQL_BIND_INT64(stmts[STMT_INSERT_KEY], i, key->mask);
		SQL_BIND_TEXT(stmts[STMT_INSERT_KEY], i, key->key);
		SQL_BIND_INT64(stmts[STMT_INSERT_KEY], i, mpage->pageid);
		SQL_STEP(stmts[STMT_INSERT_KEY]);
		sqlite3_reset(stmts[STMT_INSERT_KEY]);
d2016 1
a2016 1
dbprune(void)
d2018 2
a2019 4
	struct mpage	*mpage;
	struct mlink	*mlink;
	size_t		 i;
	unsigned int	 slot;
d2021 12
a2032 20
	if (0 == nodb)
		SQL_EXEC("BEGIN TRANSACTION");

	for (mpage = ohash_first(&mpages, &slot); NULL != mpage;
	     mpage = ohash_next(&mpages, &slot)) {
		mlink = mpage->mlinks;
		if (debug)
			say(mlink->file, "Deleting from database");
		if (nodb)
			continue;
		for ( ; NULL != mlink; mlink = mlink->next) {
			i = 1;
			SQL_BIND_TEXT(stmts[STMT_DELETE_PAGE],
			    i, mlink->dsec);
			SQL_BIND_TEXT(stmts[STMT_DELETE_PAGE],
			    i, mlink->arch);
			SQL_BIND_TEXT(stmts[STMT_DELETE_PAGE],
			    i, mlink->name);
			SQL_STEP(stmts[STMT_DELETE_PAGE]);
			sqlite3_reset(stmts[STMT_DELETE_PAGE]);
a2034 3

	if (0 == nodb)
		SQL_EXEC("END TRANSACTION");
d2038 1
a2038 2
 * Close an existing database and its prepared statements.
 * If "real" is not set, rename the temporary file into the real one.
d2041 1
a2041 1
dbclose(int real)
d2043 1
a2043 1
	size_t		 i;
d2047 6
a2052 1
	if (nodb)
a2053 4

	for (i = 0; i < STMT__MAX; i++) {
		sqlite3_finalize(stmts[i]);
		stmts[i] = NULL;
d2056 4
a2059 4
	sqlite3_close(db);
	db = NULL;

	if (real)
d2061 1
d2063 5
a2067 6
	if ('\0' == *tempfilename) {
		if (-1 == rename(MANDOC_DB "~", MANDOC_DB)) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say(MANDOC_DB, "&rename");
		}
		return;
d2076 1
a2076 2
		execlp("cmp", "cmp", "-s",
		    tempfilename, MANDOC_DB, (char *)NULL);
d2082 1
a2082 1
	if (-1 == waitpid(child, &status, 0)) {
d2094 2
a2095 1
	*strrchr(tempfilename, '/') = '\0';
d2102 1
a2102 1
		execlp("rm", "rm", "-rf", tempfilename, (char *)NULL);
d2108 1
a2108 1
	if (-1 == waitpid(child, &status, 0)) {
d2113 1
a2113 2
		say("", "%s: Cannot remove temporary directory",
		    tempfilename);
a2114 144
}

/*
 * This is straightforward stuff.
 * Open a database connection to a "temporary" database, then open a set
 * of prepared statements we'll use over and over again.
 * If "real" is set, we use the existing database; if not, we truncate a
 * temporary one.
 * Must be matched by dbclose().
 */
static int
dbopen(int real)
{
	const char	*sql;
	int		 rc, ofl;

	if (nodb)
		return 1;

	*tempfilename = '\0';
	ofl = SQLITE_OPEN_READWRITE;

	if (real) {
		rc = sqlite3_open_v2(MANDOC_DB, &db, ofl, NULL);
		if (SQLITE_OK != rc) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			if (SQLITE_CANTOPEN != rc)
				say(MANDOC_DB, "%s", sqlite3_errstr(rc));
			return 0;
		}
		goto prepare_statements;
	}

	ofl |= SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE;

	remove(MANDOC_DB "~");
	rc = sqlite3_open_v2(MANDOC_DB "~", &db, ofl, NULL);
	if (SQLITE_OK == rc)
		goto create_tables;
	if (MPARSE_QUICK & mparse_options) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(MANDOC_DB "~", "%s", sqlite3_errstr(rc));
		return 0;
	}

	(void)strlcpy(tempfilename, "/tmp/mandocdb.XXXXXX",
	    sizeof(tempfilename));
	if (NULL == mkdtemp(tempfilename)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&%s", tempfilename);
		return 0;
	}
	(void)strlcat(tempfilename, "/" MANDOC_DB,
	    sizeof(tempfilename));
	rc = sqlite3_open_v2(tempfilename, &db, ofl, NULL);
	if (SQLITE_OK != rc) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "%s: %s", tempfilename, sqlite3_errstr(rc));
		return 0;
	}

create_tables:
	sql = "CREATE TABLE \"mpages\" (\n"
	      " \"desc\" TEXT NOT NULL,\n"
	      " \"form\" INTEGER NOT NULL,\n"
	      " \"pageid\" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\n"
	      ");\n"
	      "\n"
	      "CREATE TABLE \"mlinks\" (\n"
	      " \"sec\" TEXT NOT NULL,\n"
	      " \"arch\" TEXT NOT NULL,\n"
	      " \"name\" TEXT NOT NULL,\n"
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(pageid) "
		"ON DELETE CASCADE\n"
	      ");\n"
	      "CREATE INDEX mlinks_pageid_idx ON mlinks (pageid);\n"
	      "\n"
	      "CREATE TABLE \"names\" (\n"
	      " \"bits\" INTEGER NOT NULL,\n"
	      " \"name\" TEXT NOT NULL,\n"
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(pageid) "
		"ON DELETE CASCADE,\n"
	      " UNIQUE (\"name\", \"pageid\") ON CONFLICT REPLACE\n"
	      ");\n"
	      "\n"
	      "CREATE TABLE \"keys\" (\n"
	      " \"bits\" INTEGER NOT NULL,\n"
	      " \"key\" TEXT NOT NULL,\n"
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(pageid) "
		"ON DELETE CASCADE\n"
	      ");\n"
	      "CREATE INDEX keys_pageid_idx ON keys (pageid);\n";

	if (SQLITE_OK != sqlite3_exec(db, sql, NULL, NULL, NULL)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(MANDOC_DB, "%s", sqlite3_errmsg(db));
		sqlite3_close(db);
		return 0;
	}

prepare_statements:
	if (SQLITE_OK != sqlite3_exec(db,
	    "PRAGMA foreign_keys = ON", NULL, NULL, NULL)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(MANDOC_DB, "PRAGMA foreign_keys: %s",
		    sqlite3_errmsg(db));
		sqlite3_close(db);
		return 0;
	}

	sql = "DELETE FROM mpages WHERE pageid IN "
		"(SELECT pageid FROM mlinks WHERE "
		"sec=? AND arch=? AND name=?)";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_DELETE_PAGE], NULL);
	sql = "INSERT INTO mpages "
		"(desc,form) VALUES (?,?)";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_INSERT_PAGE], NULL);
	sql = "INSERT INTO mlinks "
		"(sec,arch,name,pageid) VALUES (?,?,?,?)";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_INSERT_LINK], NULL);
	sql = "SELECT bits FROM names where pageid = ?";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_SELECT_NAME], NULL);
	sql = "INSERT INTO names "
		"(bits,name,pageid) VALUES (?,?,?)";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_INSERT_NAME], NULL);
	sql = "INSERT INTO keys "
		"(bits,key,pageid) VALUES (?,?,?)";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_INSERT_KEY], NULL);

	/*
	 * When opening a new database, we can turn off
	 * synchronous mode for much better performance.
	 */

	if (real && SQLITE_OK != sqlite3_exec(db,
	    "PRAGMA synchronous = OFF", NULL, NULL, NULL)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(MANDOC_DB, "PRAGMA synchronous: %s",
		    sqlite3_errmsg(db));
		sqlite3_close(db);
		return 0;
	}

	return 1;
@


1.171
log
@add missing prototypes, no code change;
noticed by Christos Zoulas with -Wmissing-prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.170 2016/07/09 15:23:36 schwarze Exp $ */
d177 2
a178 1
static	void	 say(const char *, const char *, ...);
d1790 1
a1790 1
			    "Adding name %*s, bits=%d", sz, cp, v);
d1798 1
a1798 1
				mansearch_keynames[i], sz, cp);
@


1.170
log
@getopt(3) is declared in <unistd.h>, and <getopt.h> is not needed;
from Joerg Sonnenberger via Thomas Klausner, NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.169 2016/03/15 20:50:23 krw Exp $ */
d130 3
@


1.169
log
@'accomodate' -> 'accommodate' in comments.

Started by diff from Mical Mazurek.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.168 2016/01/08 17:48:04 schwarze Exp $ */
a27 1
#include <getopt.h>
@


1.168
log
@Delete the redundant "nchild" member of struct roff_node, replacing
most uses by one, a few by two pointer checks, and only one by a
tiny loop - not only making data smaller, but code shorter as well.

This gets rid of an implicit invariant that confused both static
analysis tools and human auditors.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.167 2016/01/08 15:01:58 schwarze Exp $ */
d563 1
a563 1
 * TODO: accomodate for multi-language directories.
@


1.167
log
@Prefer warn(3) over perror(3) at the few places where it was used.
It is useful to see the program name.
Suggested by Christos Zoulas (NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.166 2016/01/08 02:53:09 schwarze Exp $ */
d1427 1
a1427 1
	if (NULL == n)
d1439 3
a1441 4
		assert(body->parent);
		if (NULL != (head = body->parent->head) &&
		    1 == head->nchild &&
		    NULL != (head = (head->child)) &&
d1443 2
a1444 2
		    0 == strcmp(head->string, "NAME") &&
		    NULL != body->child) {
d1677 3
a1679 1
	if (n->nchild == 1 && n->child->type == ROFFT_TEXT)
@


1.166
log
@Simplify the mparse_open() interface.
Just return the file descriptor or -1 on error;
there is just one kind of error anyway.
Suggested by Christos Zoulas (NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.165 2016/01/08 02:13:35 schwarze Exp $ */
d335 1
a335 1
		perror("pledge");
d414 1
a414 1
			perror("pledge");
d446 1
a446 1
					perror("pledge");
@


1.165
log
@It was very surprising that a function called mparse_readfd()
closed the file descriptor passed to it after completing its work,
in particular considering the fact that it required its callers
to call open(2) or mparse_open() beforehand.

Change mparse_readfd() to not call close(2) and change the callers
to call close(2) afterwards, more or less bringing open and close
to the same level of the code and making review easier.  Note that
man.cgi(8) already did that, even though it was wrong in the past.

Small restructuring suggested by Christos Zoulas (NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.164 2016/01/04 14:44:02 schwarze Exp $ */
d1115 1
a1115 2
		mparse_open(mp, &fd, mlink->file);
		if (fd == -1) {
@


1.164
log
@Improve handling of .Va and .Vt macros.
tedu@@ noticed that no Vt= database entries were generated.
Serguey Parkhomovsky suggested the deletion of parse_mdoc_body().
tb@@ noticed that the fix requires more than just adding TYPE_Vt
to the MDOC_Vt mask in the mdoc_handler array.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.163 2015/12/15 17:36:19 schwarze Exp $ */
d1127 1
@


1.163
log
@pledge(2) style:
Make sure to always use the idiom 'if (pledge("'
such that it can easily be searched for.
No functional change.
Requested by deraadt@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.162 2015/11/07 17:58:52 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011-2015 Ingo Schwarze <schwarze@@openbsd.org>
a150 2
static	int	 parse_mdoc_body(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
d166 2
d237 2
a238 2
	{ NULL, TYPE_Va },  /* Va */
	{ parse_mdoc_body, TYPE_Va },  /* Vt */
d1670 23
a1757 8
}

static int
parse_mdoc_body(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	return n->type == ROFFT_BODY;
@


1.162
log
@Modernization, no functional change intended:
Use the POSIX function getline(3) rather than the slightly
dangerous BSD function fgetln(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.161 2015/11/06 16:27:13 schwarze Exp $ */
d412 5
a416 3
	if (nodb && pledge("stdio rpath", NULL) == -1) {
		perror("pledge");
		return (int)MANDOCLEVEL_SYSERR;
d444 6
a449 5
			if (!nodb && pledge("stdio rpath wpath cpath fattr flock",
			    NULL) == -1) {
				perror("pledge");
				exitcode = (int)MANDOCLEVEL_SYSERR;
				goto out;
@


1.161
log
@Use getprogname(3) rather than __progname.
Suggested by Joerg@@ Sonnenberger (NetBSD).
Last year, deraadt@@ confirmed on tech@@ that this "has the potential
to be more portable", and micro-optimizing for speed is not relevant
here.  Also gets rid of one global variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.160 2015/10/22 22:05:42 schwarze Exp $ */
d1272 3
a1274 1
	size_t		 len, plen, titlesz;
d1287 3
d1292 2
a1293 2
	while (NULL != (line = fgetln(stream, &len)))
		if ('\n' == *line)
d1301 2
a1302 2
	while (NULL != (line = fgetln(stream, &len)))
		if ('\n' != *line && ' ' != *line)
d1315 2
a1316 2
	while (NULL != (line = fgetln(stream, &len))) {
		if (' ' != *line || '\n' != line[len - 1])
d1318 4
a1321 5
		while (len > 0 && isspace((unsigned char)*line)) {
			line++;
			len--;
		}
		if (1 == len)
d1323 3
a1325 3
		title = mandoc_realloc(title, titlesz + len);
		memcpy(title + titlesz, line, len);
		titlesz += len;
d1328 1
d1346 1
a1346 2
	title = mandoc_realloc(title, titlesz + 1);
	title[titlesz] = '\0';
@


1.160
log
@use the new function man_validate() here, too
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.159 2015/10/20 02:00:49 schwarze Exp $ */
a179 2
extern	char		*__progname;

d330 1
a330 1
	const char	 *path_arg;
d537 1
d543 1
a543 2
		       __progname, __progname, __progname,
		       __progname, __progname);
@


1.159
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.158 2015/10/16 13:37:44 millert Exp $ */
d1181 1
@


1.158
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.157 2015/10/13 22:57:49 schwarze Exp $ */
d1171 1
@


1.157
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.156 2015/10/13 15:50:15 schwarze Exp $ */
d336 1
a336 1
	if (pledge("stdio rpath wpath cpath fattr proc exec", NULL) == -1) {
d444 1
a444 1
			if (!nodb && pledge("stdio rpath wpath cpath fattr",
@


1.156
log
@Reduce the amount of code by moving the three copies of the ohash
callback functions into one common place, preparing for the use of
ohash for some additional purposes.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.154 2015/10/12 21:16:32 schwarze Exp $ */
a191 1
static	struct mchars	*mchars; /* table of named characters */
d425 2
a426 3
	mchars = mchars_alloc();
	mp = mparse_alloc(mparse_options, MANDOCLEVEL_BADARG, NULL,
	    mchars, NULL);
d533 1
a533 1
	mchars_free(mchars);
d1931 1
a1931 1
			unicode = mchars_spec2cp(mchars, seq, seqlen);
d1939 1
a1939 1
			addcp = mchars_spec2str(mchars, seq, seqlen, &addsz);
@


1.155
log
@pledge(2) for makewhatis(8):
Always needed: stdio rpath.
In addition when writing to an existing db: wpath cpath fattr.
In addition when creating a new db: proc exec.
Based on work by and OK bentley@@, "get moving" deraadt@@.
@
text
@a36 1
#include <ohash.h>
d40 1
a138 3
static	void	*hash_alloc(size_t, void *);
static	void	 hash_free(void *, void *);
static	void	*hash_calloc(size_t, size_t, void *);
a331 1
	struct ohash_info mpages_info, mlinks_info;
a344 8
	mpages_info.alloc  = mlinks_info.alloc  = hash_alloc;
	mpages_info.calloc = mlinks_info.calloc = hash_calloc;
	mpages_info.free   = mlinks_info.free   = hash_free;
	mpages_info.data   = mlinks_info.data   = NULL;

	mpages_info.key_offset = offsetof(struct mpage, inodev);
	mlinks_info.key_offset = offsetof(struct mlink, file);

d429 2
a430 2
	ohash_init(&mpages, 6, &mpages_info);
	ohash_init(&mlinks, 6, &mlinks_info);
d506 4
a509 2
				ohash_init(&mpages, 6, &mpages_info);
				ohash_init(&mlinks, 6, &mlinks_info);
a1089 1
	struct ohash_info	 str_info;
a1097 6
	str_info.alloc = hash_alloc;
	str_info.calloc = hash_calloc;
	str_info.free = hash_free;
	str_info.data = NULL;
	str_info.key_offset = offsetof(struct str, key);

d1110 2
a1111 2
		ohash_init(&names, 4, &str_info);
		ohash_init(&strings, 6, &str_info);
a2363 21
}

static void *
hash_calloc(size_t n, size_t sz, void *arg)
{

	return mandoc_calloc(n, sz);
}

static void *
hash_alloc(size_t sz, void *arg)
{

	return mandoc_malloc(sz);
}

static void
hash_free(void *p, void *arg)
{

	free(p);
@


1.154
log
@Garbage collect an unused variable, no functional change;
found by Svyatoslav Mishyn <juef at openmailbox dot org> with cppcheck.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.153 2015/10/12 00:32:37 schwarze Exp $ */
d341 5
d427 5
d458 6
@


1.153
log
@Clear dform and dsec when exiting a first-level directory in treescan().
Fixes a segfault reported by bentley@@.
While here, do some style cleanup in the same function.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.152 2015/10/12 00:07:27 schwarze Exp $ */
a1239 1
	int		 irc;
d1255 1
a1255 1
	if (SQLITE_OK != sqlite3_bind_int64(stmt, 1, NAME_TITLE))
d1258 1
a1258 1
	while (SQLITE_ROW == (irc = sqlite3_step(stmt))) {
@


1.152
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.151 2015/10/11 21:06:59 schwarze Exp $ */
d577 1
a577 1
	if (NULL == f) {
d586 1
a586 1
	while (NULL != (ff = fts_read(f))) {
d595 1
a595 1
			if (NULL == realpath(path, buf)) {
d606 1
a606 1
			if (-1 == stat(path, ff->fts_statp)) {
d618 1
a618 1
			if (0 == strcmp(path, MANDOC_DB))
d627 1
a627 1
			while (NULL == fsec) {
d629 1
a629 1
				if (NULL == fsec || strcmp(fsec+1, "gz"))
d635 1
a635 1
			if (NULL == fsec) {
d642 1
a642 1
			} else if (0 == strcmp(++fsec, "html")) {
d646 1
a646 1
			} else if (0 == strcmp(fsec, "ps")) {
d650 1
a650 1
			} else if (0 == strcmp(fsec, "pdf")) {
d655 1
a655 1
			    ((FORM_SRC == dform &&
d657 1
a657 1
			     (FORM_CAT == dform && strcmp(fsec, "0")))) {
d702 3
a704 1
			if (FTS_DP == ff->fts_info)
d706 1
d708 1
a708 1
			if (0 == strncmp(cp, "man", 3)) {
d711 1
a711 1
			} else if (0 == strncmp(cp, "cat", 3)) {
d719 1
a719 1
			if (NULL != dsec || use_all)
d731 1
a731 1
			if (FTS_DP != ff->fts_info && NULL != dsec)
d737 1
a737 1
			if (FTS_DP == ff->fts_info || use_all)
@


1.151
log
@Finally use __progname, err(3) and warn(3).
That's more readable and less error-prone than fumbling around
with argv[0], fprintf(3), strerror(3), perror(3), and exit(3).
It also shortens the code by 50 lines.

It's a bad idea to boycott good interfaces merely because standards
committees ignore them.  Instead, it's the job of the portable
distribution to provide compatibility modules for archaic systems
(like commercial Solaris) that still don't have them.  Actually,
the compat code for the portable distribution already exists and
will be committed right after this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.150 2015/10/06 18:30:43 schwarze Exp $ */
a681 1
			/* FALLTHROUGH */
a1546 1
			/* FALLTHROUGH */
a1547 1
			/* FALLTHROUGH */
a1548 1
			/* FALLTHROUGH */
a1549 1
			/* FALLTHROUGH */
a1901 1
			/* FALLTHROUGH */
@


1.150
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.149 2015/09/16 09:49:48 schwarze Exp $ */
d24 1
d183 2
a185 1
static	char		*progname;
a351 6
	progname = strrchr(argv[0], '/');
	if (progname == NULL)
		progname = argv[0];
	else
		++progname;

d359 1
a359 2
		fprintf(stderr, "%s: -%c: Conflicting option\n", \
		    progname, (_ch)); \
d395 2
a396 3
				fprintf(stderr, "%s: -T%s: "
				    "Unsupported output format\n",
				    progname, optarg);
d423 1
a423 2
		fprintf(stderr, "%s: -C: Too many arguments\n",
		    progname);
d540 2
a541 2
		       progname, progname, progname,
		       progname, progname);
@


1.149
log
@for portability, use (char *)NULL in execlp(3) as discussed on tech@@
(didn't blow up anywhere yet, but better safe than sorry)
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.148 2015/07/19 05:59:07 schwarze Exp $ */
d540 1
a540 1
	return(exitcode);
d550 1
a550 1
	return((int)MANDOCLEVEL_BADARG);
d587 1
a587 1
		return(0);
d752 1
a752 1
	return(1);
d1589 1
a1589 1
		return(0);
d1597 1
a1597 1
		return(0);
d1600 1
a1600 1
		return(0);
d1612 1
a1612 1
		return(0);
d1620 1
a1620 1
	return(0);
d1650 1
a1650 1
		return(0);
d1658 1
a1658 1
	return(0);
d1667 1
a1667 1
		return(1);
d1672 1
a1672 1
	return(0);
d1682 1
a1682 1
		return(0);
d1686 1
a1686 1
		return(0);
d1692 1
a1692 1
	return(0);
d1702 1
a1702 1
	return(0);
d1724 1
a1724 1
	return(0);
d1732 1
a1732 1
	return(n->sec == SEC_CUSTOM && n->type == ROFFT_HEAD);
d1740 1
a1740 1
	return(n->type == ROFFT_HEAD);
d1748 1
a1748 1
	return(n->type == ROFFT_BODY);
d1853 1
a1853 1
		return(0);
d1856 1
a1856 1
	return(rc);
d1980 1
a1980 1
		return(1);
d1982 1
a1982 1
		return(0);
d2249 1
a2249 1
		return(1);
d2260 1
a2260 1
			return(0);
d2274 1
a2274 1
		return(0);
d2282 1
a2282 1
		return(0);
d2290 1
a2290 1
		return(0);
d2329 1
a2329 1
		return(0);
d2339 1
a2339 1
		return(0);
d2372 1
a2372 1
		return(0);
d2375 1
a2375 1
	return(1);
d2382 1
a2382 1
	return(mandoc_calloc(n, sz));
d2389 1
a2389 1
	return(mandoc_malloc(sz));
d2438 1
a2438 1
			return(0);
d2443 1
a2443 1
			return(0);
d2457 1
a2457 1
		return(0);
d2463 1
a2463 1
		return(0);
d2471 1
a2471 1
			return(0);
d2476 1
a2476 1
	return(1);
@


1.148
log
@Do not fork and exec gunzip(1), just link with libz instead.
As discussed with deraadt@@, that's cleaner and will help tame(2).
Something like this was also suggested earlier by bapt at FreeBSD.
Minus 50 lines of code, deleting one interface function (mparse_wait),
no functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.147 2015/04/23 16:17:04 schwarze Exp $ */
d2193 1
a2193 1
		    tempfilename, MANDOC_DB, NULL);
d2218 1
a2218 1
		execlp("rm", "rm", "-rf", tempfilename, NULL);
@


1.147
log
@Unify mdoc_deroff() and man_deroff() into a common function deroff().
No functional change except that for mdoc(7), it now skips leading
escape sequences just like it already did for man(7).
Escape sequences rarely occur in mdoc(7) code and if they do,
skipping them is an improvement in this context.
Minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.146 2015/04/18 17:50:02 schwarze Exp $ */
a1230 4
		if (mparse_wait(mp) != MANDOCLEVEL_OK) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say(mlink->file, "&wait gunzip");
		}
@


1.146
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.145 2015/04/18 16:34:03 schwarze Exp $ */
d1461 1
a1461 1
			man_deroff(&title, body);
d1705 1
a1705 1
		mdoc_deroff(&mpage->desc, n);
@


1.145
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.144 2015/04/18 16:04:40 schwarze Exp $ */
d1180 1
a1180 1
			mpage->sec = mdoc_meta(man)->msec;
d1183 1
a1183 1
			mpage->arch = mdoc_meta(man)->arch;
d1186 1
a1186 2
			mpage->title =
			    mandoc_strdup(mdoc_meta(man)->title);
d1189 1
a1189 1
			mpage->sec = mandoc_strdup(man_meta(man)->msec);
d1191 1
a1191 1
			mpage->title = mandoc_strdup(man_meta(man)->title);
d1214 1
a1214 1
			parse_mdoc(mpage, mdoc_meta(man), mdoc_node(man));
d1216 1
a1216 1
			parse_man(mpage, man_meta(man), man_node(man));
@


1.144
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.143 2015/04/02 23:47:43 schwarze Exp $ */
a1091 1
	struct roff_man		*mdoc;
a1118 1
		mdoc = NULL;
d1134 1
a1134 1
			mparse_result(mp, &mdoc, &man, &sodest);
d1178 1
a1178 1
		} else if (mdoc != NULL) {
d1180 1
a1180 1
			mpage->sec = mdoc_meta(mdoc)->msec;
d1183 1
a1183 1
			mpage->arch = mdoc_meta(mdoc)->arch;
d1187 2
a1188 2
			    mandoc_strdup(mdoc_meta(mdoc)->title);
		} else if (man != NULL) {
d1214 2
a1215 2
		if (mdoc != NULL)
			parse_mdoc(mpage, mdoc_meta(mdoc), mdoc_node(mdoc));
@


1.143
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.142 2015/04/02 22:06:17 schwarze Exp $ */
d1092 2
a1093 2
	struct mdoc		*mdoc;
	struct man		*man;
@


1.142
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.141 2015/04/02 21:03:18 schwarze Exp $ */
d123 1
a123 1
typedef	int (*mdoc_fp)(struct mpage *, const struct mdoc_meta *,
d149 1
a149 1
static	void	 parse_man(struct mpage *, const struct man_meta *,
d151 1
a151 1
static	void	 parse_mdoc(struct mpage *, const struct mdoc_meta *,
d153 1
a153 1
static	int	 parse_mdoc_body(struct mpage *, const struct mdoc_meta *,
d155 1
a155 1
static	int	 parse_mdoc_head(struct mpage *, const struct mdoc_meta *,
d157 1
a157 1
static	int	 parse_mdoc_Fd(struct mpage *, const struct mdoc_meta *,
d160 1
a160 1
static	int	 parse_mdoc_Fn(struct mpage *, const struct mdoc_meta *,
d162 1
a162 1
static	int	 parse_mdoc_Fo(struct mpage *, const struct mdoc_meta *,
d164 1
a164 1
static	int	 parse_mdoc_Nd(struct mpage *, const struct mdoc_meta *,
d166 1
a166 1
static	int	 parse_mdoc_Nm(struct mpage *, const struct mdoc_meta *,
d168 1
a168 1
static	int	 parse_mdoc_Sh(struct mpage *, const struct mdoc_meta *,
d170 1
a170 1
static	int	 parse_mdoc_Xr(struct mpage *, const struct mdoc_meta *,
d1428 1
a1428 1
parse_man(struct mpage *mpage, const struct man_meta *meta,
d1554 1
a1554 1
parse_mdoc(struct mpage *mpage, const struct mdoc_meta *meta,
d1587 1
a1587 1
parse_mdoc_Fd(struct mpage *mpage, const struct mdoc_meta *meta,
d1652 1
a1652 1
parse_mdoc_Fn(struct mpage *mpage, const struct mdoc_meta *meta,
d1669 1
a1669 1
parse_mdoc_Fo(struct mpage *mpage, const struct mdoc_meta *meta,
d1683 1
a1683 1
parse_mdoc_Xr(struct mpage *mpage, const struct mdoc_meta *meta,
d1703 1
a1703 1
parse_mdoc_Nd(struct mpage *mpage, const struct mdoc_meta *meta,
d1713 1
a1713 1
parse_mdoc_Nm(struct mpage *mpage, const struct mdoc_meta *meta,
d1735 1
a1735 1
parse_mdoc_Sh(struct mpage *mpage, const struct mdoc_meta *meta,
d1743 1
a1743 1
parse_mdoc_head(struct mpage *mpage, const struct mdoc_meta *meta,
d1751 1
a1751 1
parse_mdoc_body(struct mpage *mpage, const struct mdoc_meta *meta,
@


1.141
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.140 2015/03/27 17:36:56 schwarze Exp $ */
d124 1
a124 1
			const struct mdoc_node *);
d150 1
a150 1
			const struct man_node *);
d152 1
a152 1
			const struct mdoc_node *);
d154 1
a154 1
			const struct mdoc_node *);
d156 1
a156 1
			const struct mdoc_node *);
d158 2
a159 2
			const struct mdoc_node *);
static	void	 parse_mdoc_fname(struct mpage *, const struct mdoc_node *);
d161 1
a161 1
			const struct mdoc_node *);
d163 1
a163 1
			const struct mdoc_node *);
d165 1
a165 1
			const struct mdoc_node *);
d167 1
a167 1
			const struct mdoc_node *);
d169 1
a169 1
			const struct mdoc_node *);
d171 1
a171 1
			const struct mdoc_node *);
d175 1
a175 1
			const struct mdoc_node *, uint64_t);
d1416 1
a1416 1
	const struct mdoc_node *n, uint64_t m)
d1429 1
a1429 1
	const struct man_node *n)
d1431 1
a1431 1
	const struct man_node *head, *body;
d1555 1
a1555 1
	const struct mdoc_node *n)
d1588 1
a1588 1
	const struct mdoc_node *n)
d1631 1
a1631 1
parse_mdoc_fname(struct mpage *mpage, const struct mdoc_node *n)
d1653 1
a1653 1
	const struct mdoc_node *n)
d1670 1
a1670 1
	const struct mdoc_node *n)
d1684 1
a1684 1
	const struct mdoc_node *n)
d1704 1
a1704 1
	const struct mdoc_node *n)
d1714 1
a1714 1
	const struct mdoc_node *n)
d1736 1
a1736 1
	const struct mdoc_node *n)
d1744 1
a1744 1
	const struct mdoc_node *n)
d1752 1
a1752 1
	const struct mdoc_node *n)
@


1.140
log
@Parse the new man.conf(5) "output" directive.
The next step will be to actually use the parsed data.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.139 2015/03/13 00:18:45 schwarze Exp $ */
d39 3
a43 2
#include "mandoc.h"
#include "mandoc_aux.h"
d1422 1
a1422 1
		if (MDOC_TEXT == n->type)
d1446 1
a1446 1
	if (MAN_BODY == n->type && MAN_SH == n->tok) {
d1452 1
a1452 1
		    MAN_TEXT == head->type &&
d1561 1
a1561 1
		case MDOC_ELEM:
d1563 1
a1563 1
		case MDOC_BLOCK:
d1565 1
a1565 1
		case MDOC_HEAD:
d1567 1
a1567 1
		case MDOC_BODY:
d1569 1
a1569 1
		case MDOC_TAIL:
d1578 1
a1578 1
			assert(MDOC_ROOT != n->type);
d1595 1
a1595 1
	    MDOC_TEXT != n->type)
d1606 1
a1606 1
	if (NULL == (n = n->next) || MDOC_TEXT != n->type)
d1636 1
a1636 1
	if (n->type != MDOC_TEXT)
d1662 1
a1662 1
		if (n->type == MDOC_TEXT)
d1673 1
a1673 1
	if (n->type != MDOC_HEAD)
d1707 1
a1707 1
	if (MDOC_BODY == n->type)
d1719 1
a1719 1
	else if (SEC_SYNOPSIS == n->sec && MDOC_HEAD == n->type) {
d1728 1
a1728 1
		putkey(mpage, n->child->string, NAME_HEAD);
d1739 1
a1739 1
	return(SEC_CUSTOM == n->sec && MDOC_HEAD == n->type);
d1747 1
a1747 1
	return(MDOC_HEAD == n->type);
d1755 1
a1755 1
	return(MDOC_BODY == n->type);
@


1.139
log
@Fix hardlink detection on platforms having padding in struct inodev,
typically 64bit platforms.  This was basically broken since forever.
Not only is the padding used, but it was used uninitialized.
Problem reported by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.138 2015/02/27 16:21:42 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d43 1
a43 1
#include "manpath.h"
d331 5
a336 5
	size_t		  j, sz;
	const char	 *path_arg;
	struct manpaths	  dirs;
	struct mparse	 *mp;
	struct ohash_info mpages_info, mlinks_info;
d338 1
a339 1
	memset(&dirs, 0, sizeof(struct manpaths));
d478 1
a478 1
		 * manpath_parse() wants to do it.
d481 1
a481 1
			dirs.paths = mandoc_reallocarray(NULL,
d483 1
a483 1
			dirs.sz = (size_t)argc;
d485 1
a485 1
				dirs.paths[i] = mandoc_strdup(argv[i]);
d487 1
a487 1
			manpath_parse(&dirs, path_arg, NULL, NULL);
d489 1
a489 1
		if (0 == dirs.sz) {
d500 4
a503 4
		for (j = 0; j < dirs.sz; j++) {
			sz = strlen(dirs.paths[j]);
			if (sz && '/' == dirs.paths[j][sz - 1])
				dirs.paths[j][--sz] = '\0';
d512 1
a512 1
			if (0 == set_basedir(dirs.paths[j], argc > 0))
d525 1
a525 1
			if (j + 1 < dirs.sz) {
d533 1
a533 1
	manpath_free(&dirs);
@


1.138
log
@When makewhatis(8) scans a tree, ignore trailing garbage on filenames.
This is relevant because some ports install files like man1/xsel.1x,
as reported by patrick keshishian <pkeshish at gmail dot com> on misc@@.

We can probably improve functionality and simplify the code by ignoring
file name extensions altogether; we already know the section number from
the name of the directory.  But so close to lock, i'm keeping the fix
minimal.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.137 2015/01/15 04:26:06 schwarze Exp $ */
d927 1
@


1.137
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.136 2015/01/03 12:54:49 schwarze Exp $ */
d661 2
a662 1
			    ((FORM_SRC == dform && strcmp(fsec, dsec)) ||
@


1.136
log
@Fix a potential NULL pointer access in an error message after waitpid()
failure; found using detailed information provided by Ulrich Spoerlein
<uqs at FreeBSD> about FreeBSD Coverity CID 1261304.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.135 2015/01/02 17:01:31 schwarze Exp $ */
d435 1
a435 1
	mp = mparse_alloc(mparse_options, MANDOCLEVEL_FATAL, NULL,
a1094 1
	enum mandoclevel	 lvl;
d1128 2
a1129 3
		 * Try interpreting the file as mdoc(7) or man(7)
		 * source code, unless it is already known to be
		 * formatted.  Fall back to formatted mode.
d1132 2
a1133 3
			lvl = mparse_readfd(mp, fd, mlink->file);
			if (lvl < MANDOCLEVEL_FATAL)
				mparse_result(mp, &mdoc, &man, &sodest);
@


1.135
log
@Explicitly set the *data member of struct ohash_info to NULL.
It is never dereferenced, but it gets copied around, which worries
static analysis tools and might also confuse human auditors.
FreeBSD Coverity CID 1261298, 1261299, 1261300, reported by
Pedro Giffuni and Ulrich Sprlein <pfg@@ and uqs@@ at FreeBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.134 2014/12/30 20:40:05 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d1109 1
a1109 1
		if (mpage->mlinks == NULL) {
d1122 1
a1122 1
		mparse_open(mp, &fd, mpage->mlinks->file);
d1124 1
a1124 1
			say(mpage->mlinks->file, "&open");
d1133 2
a1134 3
		if (mpage->mlinks->dform != FORM_CAT ||
		    mpage->mlinks->fform != FORM_CAT) {
			lvl = mparse_readfd(mp, fd, mpage->mlinks->file);
a1152 1
				mlink = mpage->mlinks;
d1192 3
a1194 6
			mpage->sec =
			    mandoc_strdup(man_meta(man)->msec);
			mpage->arch =
			    mandoc_strdup(mpage->mlinks->arch);
			mpage->title =
			    mandoc_strdup(man_meta(man)->title);
d1197 3
a1199 6
			mpage->sec =
			    mandoc_strdup(mpage->mlinks->dsec);
			mpage->arch =
			    mandoc_strdup(mpage->mlinks->arch);
			mpage->title =
			    mandoc_strdup(mpage->mlinks->name);
d1205 1
a1205 1
		for (mlink = mpage->mlinks; mlink; mlink = mlink->next) {
d1231 1
d1236 1
a1236 1
			say(mpage->mlinks->file, "&wait gunzip");
@


1.134
log
@When a file is given on the command line, actually exists, and its name
relative to the respective manual tree is longer than PATH_MAX, do not
leak the memory allocated to hold the name.  Not sure that can actually
happen, but better safe than sorry.
FreeBSD Coverity Scan CID 1261303, reported by Pedro Giffuni <pfg@@>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.133 2014/12/05 16:17:56 schwarze Exp $ */
d343 2
a344 1
	mpages_info.free  = mlinks_info.free  = hash_free;
d1100 1
@


1.133
log
@Improve parsing of function names.
This gets rid of the last bogus entries in base and Xenocara.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.132 2014/12/05 15:16:25 schwarze Exp $ */
d845 1
@


1.132
log
@Do not misinterpret function arguments as function names;
improves semantic analysis of more than 300 manuals.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.131 2014/12/05 14:26:23 schwarze Exp $ */
d158 1
d1634 2
a1635 3
static int
parse_mdoc_Fn(struct mpage *mpage, const struct mdoc_meta *meta,
	const struct mdoc_node *n)
d1638 1
d1640 2
a1641 2
	if (NULL == (n = n->child) || MDOC_TEXT != n->type)
		return(0);
d1643 1
a1643 6
	/*
	 * Parse: .Fn "struct type *name" "char *arg".
	 * First strip away pointer symbol.
	 * Then store the function name, then type.
	 * Finally, store the arguments.
	 */
d1645 2
a1646 4
	if (NULL == (cp = strrchr(n->string, ' ')))
		cp = n->string;

	while ('*' == *cp)
d1648 1
d1650 1
a1650 1
	putkey(mpage, cp, TYPE_Fn);
d1652 2
a1653 1
		putkey(mpage, cp, NAME_SYN);
d1655 9
a1663 2
	if (n->string < cp)
		putkeys(mpage, n->string, cp - n->string, TYPE_Ft);
d1665 2
a1666 2
	for (n = n->next; NULL != n; n = n->next)
		if (MDOC_TEXT == n->type)
d1680 3
a1682 3
	putmdockey(mpage, n->child, TYPE_Fn);
	if (n->sec == SEC_SYNOPSIS)
		putmdockey(mpage, n->child, NAME_SYN);
@


1.131
log
@Render text before, not after accumulating flag bits, such that flags
for different representations of the same string end up in the same
database entry.  Improves name classification for 500 manuals.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.130 2014/12/04 21:48:26 schwarze Exp $ */
d1673 3
@


1.130
log
@When finding a .so link after the page was already processed,
do not clobber the existing names flags;
instead, OR the additional flags into them.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.129 2014/12/04 20:13:13 schwarze Exp $ */
a76 1
	char		*rendered; /* key in UTF-8 or ASCII form */
d79 1
a79 1
	char		 key[]; /* may contain escape sequences */
d131 1
a131 1
static	void	 dbadd(struct mpage *, struct mchars *);
d145 1
a145 1
static	void	 mpages_merge(struct mchars *, struct mparse *);
d171 1
a171 2
static	void	 putkeys(const struct mpage *,
			const char *, size_t, uint64_t);
d174 1
a174 1
static	void	 render_key(struct mchars *, struct str *);
d191 1
a332 1
	struct mchars	 *mc;
d432 1
a432 1
	mc = mchars_alloc();
d434 1
a434 1
	    mc, NULL);
d470 1
a470 1
			mpages_merge(mc, mp);
d517 1
a517 1
			mpages_merge(mc, mp);
d533 1
a533 1
	mchars_free(mc);
d1080 1
a1080 1
mpages_merge(struct mchars *mc, struct mparse *mp)
d1234 1
a1234 1
		dbadd(mpage, mc);
d1593 1
a1593 1
	const char	*start, *end;
d1762 1
a1762 2
putkeys(const struct mpage *mpage,
	const char *cp, size_t sz, uint64_t v)
d1768 1
a1768 1
	int		 i;
d1773 2
d1807 3
d1865 4
a1868 2
 * Store the rendered version of a key, or alias the pointer
 * if the key contains no escape sequences.
d1870 2
a1871 2
static void
render_key(struct mchars *mc, struct str *key)
d1873 3
a1875 1
	size_t		 sz, bsz, pos;
d1877 1
a1877 6
	char		*buf;
	const char	*seq, *cpp, *val;
	int		 len, u;
	enum mandoc_esc	 esc;

	assert(NULL == key->rendered);
d1886 15
a1900 2
	val = key->key;
	bsz = strlen(val);
a1901 15
	/*
	 * Pre-check: if we have no stop-characters, then set the
	 * pointer as ourselvse and get out of here.
	 */
	if (strcspn(val, res) == bsz) {
		key->rendered = key->key;
		return;
	}

	/* Pre-allocate by the length of the input */

	buf = mandoc_malloc(++bsz);
	pos = 0;

	while ('\0' != *val) {
d1903 2
a1904 3
		 * Halt on the first escape sequence.
		 * This also halts on the end of string, in which case
		 * we just copy, fallthrough, and exit the loop.
d1906 5
a1910 4
		if ((sz = strcspn(val, res)) > 0) {
			memcpy(&buf[pos], val, sz);
			pos += sz;
			val += sz;
d1913 5
a1917 5
		switch (*val) {
		case ASCII_HYPH:
			buf[pos++] = '-';
			val++;
			continue;
d1921 5
a1925 2
			buf[pos++] = ' ';
			val++;
d1928 1
d1931 1
a1931 1
			break;
a1932 6
		if ('\\' != *val)
			break;

		/* Read past the slash. */

		val++;
d1935 3
a1937 2
		 * Parse the escape sequence and see if it's a
		 * predefined character or special character.
d1940 2
a1941 5
		esc = mandoc_escape((const char **)&val,
		    &seq, &len);
		if (ESCAPE_ERROR == esc)
			break;
		if (ESCAPE_SPECIAL != esc)
d1950 2
a1951 1
			if ((u = mchars_spec2cp(mc, seq, len)) <= 0)
d1953 2
a1954 2
			cpp = utfbuf;
			if (0 == (sz = utf8(u, utfbuf)))
d1956 1
a1956 1
			sz = strlen(cpp);
d1958 2
a1959 2
			cpp = mchars_spec2str(mc, seq, len, &sz);
			if (NULL == cpp)
d1961 3
a1963 3
			if (ASCII_NBRSP == *cpp) {
				cpp = " ";
				sz = 1;
d1969 19
a1987 8
		bsz += sz;
		buf = mandoc_realloc(buf, bsz);
		memcpy(&buf[pos], cpp, sz);
		pos += sz;
	}

	buf[pos] = '\0';
	key->rendered = buf;
d2035 1
a2035 1
dbadd(struct mpage *mpage, struct mchars *mc)
d2039 1
d2042 1
d2048 1
a2048 3
		     key = ohash_next(&names, &slot)) {
			if (key->rendered != key->key)
				free(key->rendered);
a2049 1
		}
d2051 1
a2051 3
		     key = ohash_next(&strings, &slot)) {
			if (key->rendered != key->key)
				free(key->rendered);
a2052 1
		}
d2081 3
a2083 5
	i = strlen(mpage->desc) + 1;
	key = mandoc_calloc(1, sizeof(struct str) + i);
	memcpy(key->key, mpage->desc, i);
	render_key(mc, key);

d2085 1
a2085 1
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, key->rendered);
d2090 2
a2091 4

	if (key->rendered != key->key)
		free(key->rendered);
	free(key);
a2101 2
		if (NULL == key->rendered)
			render_key(mc, key);
d2104 1
a2104 1
		SQL_BIND_TEXT(stmts[STMT_INSERT_NAME], i, key->rendered);
a2107 2
		if (key->rendered != key->key)
			free(key->rendered);
a2112 2
		if (NULL == key->rendered)
			render_key(mc, key);
d2115 1
a2115 1
		SQL_BIND_TEXT(stmts[STMT_INSERT_KEY], i, key->rendered);
a2118 2
		if (key->rendered != key->key)
			free(key->rendered);
@


1.129
log
@correctly store .Dt and .TH information in the names table
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.128 2014/12/04 18:31:04 schwarze Exp $ */
d118 1
d1783 1
a1783 1
			    "Adding name %*s", sz, cp);
d2000 1
d2006 9
a2014 1
	SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, NAME_FILE & NAME_MASK);
d2327 2
a2328 1
		"ON DELETE CASCADE\n"
d2366 2
@


1.128
log
@in the SYNOPSIS, add .Fo and first .Fn arguments to the names table
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.127 2014/12/04 17:35:42 schwarze Exp $ */
d97 1
d148 2
a149 1
static	void	 parse_man(struct mpage *, const struct man_node *);
d1220 2
a1221 4
		assert(NULL == mpage->desc);
		if (NULL != mdoc) {
			if (NULL != (cp = mdoc_meta(mdoc)->name))
				putkey(mpage, cp, NAME_HEAD);
d1223 2
a1224 2
		} else if (NULL != man)
			parse_man(mpage, man_node(man));
d1227 1
a1227 1
		if (NULL == mpage->desc)
d1432 2
a1433 1
parse_man(struct mpage *mpage, const struct man_node *n)
d1499 5
d1518 5
d1553 1
a1553 1
		parse_man(mpage, n);
d1723 6
@


1.127
log
@In the SYNOPSIS, if .Nm occurs without argument, give the first .Nm
that occurred in the document a NAME_SYN entry in the names table.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.126 2014/11/27 01:57:42 schwarze Exp $ */
d158 2
d295 1
a295 1
	{ parse_mdoc_head, 0 },  /* Fo */
d1646 2
d1656 11
@


1.126
log
@Make makewhatis(8) understand .so links to .gz pages.
Drop the FORM_GZ annotation in the mpages table; it is conceptually wrong
because it ought to be in the mlinks table: An uncompressed .so link file
can point to a compressed manual page file and vice versa.
Besides, it is no longer needed because mparse_open() handles it all.
Sprinkle some KNF while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.125 2014/11/26 21:40:11 schwarze Exp $ */
d121 2
a122 1
typedef	int (*mdoc_fp)(struct mpage *, const struct mdoc_node *);
d148 18
a165 9
static	void	 parse_mdoc(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_body(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_head(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Fd(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Fn(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Nd(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Nm(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Sh(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Xr(struct mpage *, const struct mdoc_node *);
d1220 1
a1220 1
			parse_mdoc(mpage, mdoc_node(mdoc));
d1545 2
a1546 1
parse_mdoc(struct mpage *mpage, const struct mdoc_node *n)
d1562 1
a1562 1
			       if (0 == (*mdocs[n->tok].fp)(mpage, n))
d1573 1
a1573 1
			parse_mdoc(mpage, n);
d1578 2
a1579 1
parse_mdoc_Fd(struct mpage *mpage, const struct mdoc_node *n)
d1622 2
a1623 1
parse_mdoc_Fn(struct mpage *mpage, const struct mdoc_node *n)
d1656 2
a1657 1
parse_mdoc_Xr(struct mpage *mpage, const struct mdoc_node *n)
d1676 2
a1677 1
parse_mdoc_Nd(struct mpage *mpage, const struct mdoc_node *n)
d1686 2
a1687 1
parse_mdoc_Nm(struct mpage *mpage, const struct mdoc_node *n)
d1692 6
a1697 2
	else if (SEC_SYNOPSIS == n->sec && MDOC_HEAD == n->type)
		putmdockey(mpage, n->child, NAME_SYN);
d1702 2
a1703 1
parse_mdoc_Sh(struct mpage *mpage, const struct mdoc_node *n)
d1710 2
a1711 1
parse_mdoc_head(struct mpage *mpage, const struct mdoc_node *n)
d1718 2
a1719 1
parse_mdoc_body(struct mpage *mpage, const struct mdoc_node *n)
@


1.125
log
@Simplify the mparse_open()/mparse_wait() interface.
Don't bother the user with the PID of the child process,
store it inside the opaque mparse handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.124 2014/11/19 20:40:28 schwarze Exp $ */
d1086 1
a1086 1
	if (0 == nodb)
d1090 1
a1090 1
	while (NULL != mpage) {
d1092 1
a1092 1
		if (NULL == mpage->mlinks) {
d1116 2
a1117 2
		if (FORM_CAT != mpage->mlinks->dform ||
		    FORM_CAT != mpage->mlinks->fform) {
d1123 1
a1123 1
		if (NULL != sodest) {
d1126 7
a1132 1
			if (NULL != mlink_dest) {
d1153 1
a1153 1
					if (NULL == mlink->next)
d1165 1
a1165 1
		} else if (NULL != mdoc) {
d1169 1
a1169 1
			    NULL == mpage->sec ? "" : mpage->sec);
d1172 1
a1172 1
			    NULL == mpage->arch ? "" : mpage->arch);
d1175 1
a1175 1
		} else if (NULL != man) {
a1191 2
		if (mpage->mlinks->gzip)
			mpage->form |= FORM_GZ;
@


1.124
log
@Three fixes with respect to the names table:
1. Do not mask out NAME_FIRST before its first use.
2. Avoid duplicate NAME_FILE entries.
3. Correctly mask NAME_FILE for .so links.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.123 2014/10/28 17:35:42 schwarze Exp $ */
a1076 1
	pid_t			 child_pid;
a1103 1
		child_pid = 0;
d1105 1
a1105 1
		mparse_open(mp, &fd, mpage->mlinks->file, &child_pid);
d1222 1
a1222 2
		if (child_pid &&
		    mparse_wait(mp, child_pid) != MANDOCLEVEL_OK) {
@


1.123
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.122 2014/10/27 13:29:30 schwarze Exp $ */
d131 1
d1147 1
a1147 1
						dbadd_mlink(mlink);
d1722 2
a1723 1
		name_mask &= ~NAME_FIRST;
d1938 8
d1948 1
a1948 1
	SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, NAME_FILE);
@


1.122
log
@Fix a regression in term.c rev. 1.89 reported by bentley@@:
In UTF-8 output, do not print anything if mchars_spec2cp() returns 0.
In particular, this repairs handling of zero-width spaces (\&).

While here, let mchars_spec2cp() return 0xFFFD instead of -1
if the character is not found, simplifying the using code.
In HTML output, do not print obfuscated ASCII characters and
do not test for one-char escapes, mchars_spec2cp() already does that.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.121 2014/10/12 20:32:16 schwarze Exp $ */
a417 1
	mp = mparse_alloc(mparse_options, MANDOCLEVEL_FATAL, NULL, NULL);
d419 2
a420 1

d518 1
a519 1
	mparse_free(mp);
@


1.121
log
@add missing entry for .ll to the dispatch table;
patch from Martin <Natano at natano dot net>, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.120 2014/09/09 19:33:55 schwarze Exp $ */
d1896 1
a1896 1
			if (0 == (u = mchars_spec2cp(mc, seq, len)))
@


1.120
log
@If a manpath directory (for example, a _whatdb entry from man.conf(5)
or an entry in the MANPATH environment variable) does not exist,
silently skip it.  This brings makewhatis(8) back closer to the
behaviour of espie@@'s version and ought to shut up the weekly(8)
whining observed by henning@@ on machines not having xbase installed.
Also, don't error out after the first unusable manpath entry, still
try the others.

Of course, still complain about non-existent directories specified
on the command line and about any directories failing for other
reasons than ENOENT.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.119 2014/09/07 03:08:42 schwarze Exp $ */
d308 1
@


1.119
log
@Do not report a page as arch=any merely because .Dt lacks the third argument.
Pages found outside arch-specific dirs still get arch=any, of course.
Issue reported by justinhenryhaynes at gmail dot com on misc@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.118 2014/09/07 03:00:03 schwarze Exp $ */
d162 1
a162 1
static	int	 set_basedir(const char *);
d429 1
a429 1
		if (OP_TEST != op && 0 == set_basedir(path_arg))
d495 2
a496 2
			if (0 == set_basedir(dirs.paths[j]))
				goto out;
d498 1
a498 1
				goto out;
d500 1
a500 1
				goto out;
d2334 1
a2334 1
set_basedir(const char *targetdir)
d2387 4
a2390 2
		exitcode = (int)MANDOCLEVEL_BADARG;
		say("", "&%s: realpath", targetdir);
d2393 4
a2396 2
		exitcode = (int)MANDOCLEVEL_BADARG;
		say("", "&chdir");
@


1.118
log
@fix debugging output
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.117 2014/09/03 23:20:33 schwarze Exp $ */
d1189 2
a1190 2
		putkey(mpage, '\0' == *mpage->arch ?
		    any : mpage->arch, TYPE_arch);
@


1.117
log
@Add *.gz support to apropos(1) -a, manm(1), and even mandoc(1).
Implemented by moving the zip code from makewhatis(8) to the parser lib.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandocdb.c,v 1.116 2014/09/03 18:08:26 schwarze Exp $ */
d1728 1
a1728 1
			if (1 << i & v)
@


1.116
log
@If a manual page is installed gzip(1)ed, let makewhatis(8) take
note in mandoc.db(5), such that man(1) -w and apropos(1) -w can
report the correct filename.
This is a prerequisite for letting apropos -a and man support
gzip'ed manuals in the future, which doesn't work yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d18 1
a1068 1
	int			 fd[2];
d1076 1
a1076 1
	int			 status;
a1103 2
		fd[0] = -1;
		fd[1] = -1;
d1105 4
a1108 29
		if (mpage->mlinks->gzip) {
			if (-1 == pipe(fd)) {
				exitcode = (int)MANDOCLEVEL_SYSERR;
				say(mpage->mlinks->file, "&pipe gunzip");
				goto nextpage;
			}
			switch (child_pid = fork()) {
			case -1:
				exitcode = (int)MANDOCLEVEL_SYSERR;
				say(mpage->mlinks->file, "&fork gunzip");
				child_pid = 0;
				close(fd[1]);
				close(fd[0]);
				goto nextpage;
			case 0:
				close(fd[0]);
				if (-1 == dup2(fd[1], STDOUT_FILENO)) {
					say(mpage->mlinks->file,
					    "&dup gunzip");
					exit(1);
				}
				execlp("gunzip", "gunzip", "-c",
				    mpage->mlinks->file, NULL);
				say(mpage->mlinks->file, "&exec gunzip");
				exit(1);
			default:
				close(fd[1]);
				break;
			}
d1118 1
a1118 1
			lvl = mparse_readfd(mp, fd[0], mpage->mlinks->file);
d1210 1
a1210 1
			parse_cat(mpage, fd[0]);
d1222 4
a1225 15
		if (child_pid) {
			if (-1 == waitpid(child_pid, &status, 0)) {
				exitcode = (int)MANDOCLEVEL_SYSERR;
				say(mpage->mlinks->file, "&wait gunzip");
			} else if (WIFSIGNALED(status)) {
				exitcode = (int)MANDOCLEVEL_SYSERR;
				say(mpage->mlinks->file,
				    "gunzip died from signal %d",
				    WTERMSIG(status));
			} else if (WEXITSTATUS(status)) {
				exitcode = (int)MANDOCLEVEL_SYSERR;
				say(mpage->mlinks->file,
				    "gunzip failed with code %d",
				    WEXITSTATUS(status));
			}
@


1.115
log
@When makewhatis(8) finds an .so link after the manual being pointed to
has already been processed, add the file names to the names table, too,
not just to the mlinks table.
This fixes a bug where apropos(1) and the new man(1) wouldn't find some
of the Xenocara manuals via some of their .so links.  After rebuilding,
run "makewhatis /usr/X11R6/man" or just wait for weekly(8).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.114 2014/08/23 01:00:20 doug Exp $ */
a74 6
enum	form {
	FORM_NONE,  /* format is unknown */
	FORM_SRC,   /* format is -man or -mdoc */
	FORM_CAT    /* format is cat */
};

a89 1
	enum form	 form;    /* format from file content */
d95 1
a99 2
	enum form	 dform;   /* format from directory */
	enum form	 fform;   /* format from file name suffix */
d106 2
d824 1
d1213 2
d2046 1
a2046 1
	SQL_BIND_INT(stmts[STMT_INSERT_PAGE], i, FORM_SRC == mpage->form);
@


1.114
log
@Fix fd leak when fdopen fails.

ok schwarze@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.113 2014/08/08 17:36:21 schwarze Exp $ */
d1976 7
@


1.113
log
@Absurdly, the return value of sqlite3_column_text()
is "const unsigned char *", which causes warnings with GCC on Linux.
Explicitly cast to "const char *" to avoid this.
Issue noticed by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.112 2014/08/08 16:17:09 schwarze Exp $ */
d1324 2
@


1.112
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.111 2014/06/21 16:17:56 schwarze Exp $ */
d1302 4
a1305 4
		name = sqlite3_column_text(stmt, 0);
		sec  = sqlite3_column_text(stmt, 1);
		arch = sqlite3_column_text(stmt, 2);
		key  = sqlite3_column_text(stmt, 3);
@


1.111
log
@Prefix messages about bad command line options and arguments
with "mandoc: " or "makewhatis: ", respectively,
similar to what we already do for other messages.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.110 2014/06/20 01:20:55 schwarze Exp $ */
d1193 3
a1195 2
			mpage->sec =
			    mandoc_strdup(mdoc_meta(mdoc)->msec);
@


1.110
log
@More tweaking of set_basedir().

1) Do not error out when getcwd(3) fails, only fail when inaccessibility
of the cwd prevents processing of relative paths given on the command line.

2) Do not uselessly call set_basedir() twice in a row.
While fts_read(3) in treescan() does cause the cwd to jump around,
fts_close(3) is always called at the end, putting us back
where we came from.  The -d/-u fallback code already relied on this.

3) Fix the man-root-dir indicator in say().
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.109 2014/06/19 00:44:59 schwarze Exp $ */
d350 2
a351 1
		fprintf(stderr, "-%c: Conflicting option\n", (_ch)); \
d387 3
a389 2
				fprintf(stderr, "-T%s: Unsupported "
				    "output format\n", optarg);
d416 2
a417 1
		fprintf(stderr, "-C: Too many arguments\n");
@


1.109
log
@Some simple set_basedir() cleanup; more to come.

1) Refrain from calling set_basedir() in the -t case,
and do not attempt to strip anything from the file names in that case.
Testing individual files cannot reasonably have any notion of a base dir.

2) Remove the possibility of passing NULL to set_basedir().
It was dangerous because it was not idempotent, and it served no purpose
except closing a file descriptor right before exit(), which is pointless.
Besides, the file descriptor is likely to be removed completely, soon.

3) Make sure that /foobar isn't treated as a subdirectory of /foo;
this fixes a bug reported by espie@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.108 2014/06/18 19:17:37 sthen Exp $ */
a500 2
			if (0 == set_basedir(dirs.paths[j]))
				goto out;
d2365 2
a2366 1
	static int	 fd;
d2370 25
a2394 4
	 * Remember where we started by keeping a fd open to the origin
	 * path component: throughout this utility, we chdir() a lot to
	 * handle relative paths, and by doing this, we can return to
	 * the starting point.
d2396 2
a2397 2
	if ('\0' == *startdir) {
		if (NULL == getcwd(startdir, PATH_MAX)) {
d2399 1
a2399 1
			say("", "&getcwd");
d2402 1
a2402 11
		if (-1 == (fd = open(startdir, O_RDONLY, 0))) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say("", "&open %s", startdir);
			return(0);
		}
	} else {
		if (-1 == fd)
			return(0);
		if (-1 == fchdir(fd)) {
			close(fd);
			basedir[0] = '\0';
d2408 6
a2414 1
		basedir[0] = '\0';
d2423 1
d2446 1
a2446 1
		fputs("//", stderr);
@


1.108
log
@Don't display "unable to open mandoc.db" error messages (SQLITE_CANTOPEN)
in the code which opens mandocdb's sqlite database when updating/deleting
individual files (as used and only really useful for pkg_add/pkg_delete).
ok schwarze@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.107 2014/06/05 07:13:53 espie Exp $ */
d428 1
a428 1
		 * All of these deal with a specific directory.
d431 1
a431 1
		if (0 == set_basedir(path_arg))
a519 1
	set_basedir(NULL);
d794 1
a794 3
	if (strstr(buf, basedir) == buf && strcmp(basedir, "/") != 0)
		start = buf + strlen(basedir) + 1;
	else if (OP_TEST == op)
d796 2
d823 3
a825 3
		start = strstr(buf, basedir) == buf && 
		    strcmp(basedir, "/") != 0 ?
		    buf + strlen(basedir) + 1 : buf;
d2368 1
d2379 1
a2379 2
			if (NULL != targetdir)
				say("", "&getcwd");
a2386 2
		if (NULL == targetdir)
			targetdir = startdir;
a2396 4
		if (NULL == targetdir) {
			close(fd);
			return(1);
		}
d2407 10
@


1.107
log
@work-around issue in makewhatis, that expects its current dir to NOT be /.
okay aja@@, miod@@ until Ingo figures things out.

(This fixes the
///sr/ports/pobj/p5-YAML-0.84/fake-amd64/usr/local/man/man3p/YAML::Loader::Base.3p: fopen: No such file or directory
style errors)
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.106 2014/05/12 19:11:20 espie Exp $ */
d2226 2
a2227 1
			say(MANDOC_DB, "%s", sqlite3_errstr(rc));
@


1.106
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.105 2014/05/07 16:18:57 schwarze Exp $ */
d795 1
a795 1
	if (strstr(buf, basedir) == buf)
d824 2
a825 1
		start = strstr(buf, basedir) == buf ?
@


1.105
log
@Render roff escape sequences contained in manual page descriptions
before putting them into the mpages table.
Issue found by bentley@@ in OpenBSD::Getopt(3p).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.104 2014/05/07 15:10:33 schwarze Exp $ */
d140 2
a141 2
static	void	 hash_free(void *, size_t, void *);
static	void	*hash_halloc(size_t, void *);
d331 2
a332 2
	mpages_info.halloc = mlinks_info.halloc = hash_halloc;
	mpages_info.hfree  = mlinks_info.hfree  = hash_free;
d1085 2
a1086 2
	str_info.halloc = hash_halloc;
	str_info.hfree = hash_free;
d2342 1
a2342 1
hash_halloc(size_t sz, void *arg)
d2345 1
a2345 1
	return(mandoc_calloc(1, sz));
d2356 1
a2356 1
hash_free(void *p, size_t sz, void *arg)
@


1.104
log
@Fix two memory leaks in makewhatis -n:
1. As found by nigel@@, names_check() requires database access.
2. Do not leak names and strings in -n mode.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.103 2014/04/27 23:03:52 schwarze Exp $ */
d2031 5
d2037 1
a2037 1
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->desc);
d2042 4
@


1.103
log
@Improve error handling in dbopen().  If PRAGMA SQL statements fail,
report the error, close the database, and return failure from dbopen(),
such that the main program can recover and rebuild the database.

As noticed by stsp@@, this can happen when database files are
accessible, but corrupt or in the wrong format, which will now
automatically be repaired.

Besides, use a safer idiom after sqlite3_open*() failure that also
handles out-of-memory situations correctly, and do not forget to
close the database after CREATE TABLE failure.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.102 2014/04/25 12:12:35 schwarze Exp $ */
d507 1
a507 1
			if (warnings &&
d1991 12
@


1.102
log
@Reduce the verbosity of makewhatis -t:
In the past, it always showed the title lines of the files processed.
Now, it only shows them when called with -D.
That is better because pkg_create calls makewhatis -t.
It is also more consistent with -D behaviour in non- -t modes.
Issue reported by ajacoutot@@; ok espie@@ ajacoutot@@ jasper@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.101 2014/04/23 21:06:33 schwarze Exp $ */
d2204 1
a2204 1
			say(MANDOC_DB, "%s", sqlite3_errmsg(db));
d2218 1
a2218 1
		say(MANDOC_DB "~", "%s", sqlite3_errmsg(db));
d2234 1
a2234 1
		say("", "%s: %s", tempfilename, sqlite3_errmsg(db));
d2272 1
d2277 9
a2285 1
	SQL_EXEC("PRAGMA foreign_keys = ON");
d2308 8
a2315 2
	if (real)
		SQL_EXEC("PRAGMA synchronous = OFF");
@


1.101
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.100 2014/04/23 19:08:52 schwarze Exp $ */
d1991 2
@


1.100
log
@Audit strlcpy(3)/strlcat(3) usage:
* Add missing truncation checks to three calls.
* In four cases where we know that the distination buffer is large enough,
cast the return vailue to (void).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.99 2014/04/23 16:33:37 schwarze Exp $ */
d466 2
a467 2
			dirs.paths = mandoc_calloc(argc,
			    sizeof(char *));
d1779 1
a1779 1
		s = mandoc_calloc(sizeof(struct str) + sz + 1, 1);
d2307 1
a2307 1
	return(mandoc_calloc(sz, 1));
@


1.99
log
@improve SQL style: avoid "SELECT *", be explicit in what columns we want;
suggested by espie@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.98 2014/04/20 16:44:44 schwarze Exp $ */
d658 7
a664 1
			strlcpy(mlink->file, path, sizeof(mlink->file));
d820 4
a823 1
		strlcpy(buf, file, sizeof(buf));
d829 5
a833 1
	strlcpy(mlink->file, start, sizeof(mlink->file));
d981 1
a981 5
		if (strlcpy(buf, mlink->file, PATH_MAX) >= PATH_MAX) {
			if (warnings)
				say(mlink->file, "Filename too long");
			goto nextlink;
		}
d987 1
a987 1
		strlcat(buf, mlink->dsec, PATH_MAX);
d2220 2
a2221 6
	if (strlcpy(tempfilename, "/tmp/mandocdb.XXXXXX",
	    sizeof(tempfilename)) >= sizeof(tempfilename)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "/tmp/mandocdb.XXXXXX: Filename too long");
		return(0);
	}
d2227 2
a2228 7
	if (strlcat(tempfilename, "/" MANDOC_DB,
	    sizeof(tempfilename)) >= sizeof(tempfilename)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "%s/" MANDOC_DB ": Filename too long",
		    tempfilename);
		return(0);
	}
@


1.98
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.97 2014/04/19 02:55:44 schwarze Exp $ */
d1282 2
a1283 1
	    "SELECT * FROM mlinks GROUP BY pageid"
@


1.97
log
@Two minor tweaks regarding the fallback from -u/-d to default mode:
(1) Use all files found on the command line, but do *not* use all stray
files found during fallback tree recursion.
(2) If the fallback works, call that success, i.e. exit(0).
As pointed out by naddy@@, the latter is required for ports' happiness.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.96 2014/04/19 02:29:12 schwarze Exp $ */
d175 3
a177 3
static	int	 	 use_all; /* use all found files */
static	int	  	 debug; /* print what we're doing */
static	int	  	 warnings; /* warn about crap */
d180 1
a180 1
static	enum op	  	 op; /* operational mode */
d315 1
d344 1
a344 1
	 * We accept a few different invocations.  
d359 1
a359 1
		case ('a'):
d362 1
a362 1
		case ('C'):
d367 1
a367 1
		case ('D'):
d370 1
a370 1
		case ('d'):
d375 1
a375 1
		case ('n'):
d378 1
a378 1
		case ('p'):
d381 1
a381 1
		case ('Q'):
d384 1
a384 1
		case ('T'):
d392 1
a392 1
		case ('t'):
d398 1
a398 1
		case ('u'):
d403 1
a403 1
		case ('v'):
d466 2
a467 2
			dirs.paths = mandoc_calloc
				(argc, sizeof(char *));
d534 1
a534 1
		       progname, progname, progname, 
d548 1
a548 1
 *   [./]man*[/<arch>]/<name>.<section> 
d588 1
a588 1
		case (FTS_SL):
d611 1
a611 1
		case (FTS_F):
d668 1
a668 1
		case (FTS_D):
d670 1
a670 1
		case (FTS_DP):
d680 1
a680 1
		case (0):
d683 1
a683 1
		case (1):
d704 1
a704 1
			if (NULL != dsec || use_all) 
d711 1
a711 1
		case (2):
d743 1
a743 1
 *   [./]man*[/<arch>]/<name>.<section> 
d980 1
a980 1
				ohash_qlookup(&mlinks, buf)))
d1109 1
a1109 1
			case (-1):
d1116 1
a1116 1
			case (0):
d1331 1
a1331 1
	
d1401 1
a1401 1
		} 
d1465 5
a1469 5
				1 == head->nchild &&
				NULL != (head = (head->child)) &&
				MAN_TEXT == head->type &&
				0 == strcmp(head->string, "NAME") &&
				NULL != body->child) {
d1483 1
a1483 1
			/* 
d1565 1
a1565 1
		case (MDOC_ELEM):
d1567 1
a1567 1
		case (MDOC_BLOCK):
d1569 1
a1569 1
		case (MDOC_HEAD):
d1571 1
a1571 1
		case (MDOC_BODY):
d1573 1
a1573 1
		case (MDOC_TAIL):
d1597 2
a1598 2
			NULL == (n = n->child) || 
			MDOC_TEXT != n->type)
d1641 1
a1641 1
	/* 
d1643 1
a1643 1
	 * First strip away pointer symbol. 
d1645 1
a1645 1
	 * Finally, store the arguments. 
d1862 1
a1862 1
	} 
d1882 1
a1882 1
		case (ASCII_HYPH):
d1886 1
a1886 1
		case ('\t'):
d1888 1
a1888 1
		case (ASCII_NBRSP):
d1892 1
a1892 1
		case (ASCII_BREAK):
d1909 2
a1910 2
		esc = mandoc_escape
			((const char **)&val, &seq, &len);
d2121 1
a2121 1
	case (-1):
d2125 1
a2125 1
	case (0):
d2147 1
a2147 1
	case (-1):
d2151 1
a2151 1
	case (0):
d2182 1
a2182 1
	if (nodb) 
d2202 1
a2202 1
	if (SQLITE_OK == rc) 
d2393 1
a2393 1
		case ('&'):
d2396 1
a2396 1
		case ('\0'):
@


1.96
log
@Properly handle symlinks (hardlinks and .so only files were already ok):
Use the file name of the symlink but the inode number of the file pointed to,
such that we get multiple mlinks records but not multiple mpages records.
Also make sure they do not point outside the tree we are processing.

Issue found by kili@@ in desktop-file-edit(1), thanks!
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.95 2014/04/18 21:54:48 schwarze Exp $ */
a424 4
		/* 
		 * Force processing all files.
		 */
		use_all = 1;
d428 1
a428 2
		 * Jump into that directory then collect files specified
		 * on the command-line.
d432 1
d434 5
d448 1
@


1.95
log
@In update mode, when opening the database fails, probably because it is
missing or corrupt, just rebuild it from scratch.  This also helps when
installing the very first port on a freshly installed machine
and is similar to what espie@@'s classical makewhatis(8) did.

Issue reported by naddy@@ via kili@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.94 2014/04/16 21:35:48 schwarze Exp $ */
d554 1
d566 2
a567 5
	/*
	 * Walk through all components under the directory, using the
	 * logical descent of files.
	 */
	f = fts_open((char * const *)argv, FTS_LOGICAL, NULL);
d579 25
d608 1
a608 1
		if (FTS_F == ff->fts_info) {
d664 7
a670 2
		} else if (FTS_D != ff->fts_info &&
				FTS_DP != ff->fts_info) {
d759 21
d796 18
a813 8
	if (-1 == stat(buf, &st)) {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say(file, "&stat");
		return;
	} else if ( ! (S_IFREG & st.st_mode)) {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say(file, "Not a regular file");
		return;
@


1.94
log
@Rename the mpages.id column to mpages.pageid.  There is no good reason
to call this kid by a different name here than in all other tables.
Easier to polish this now than after enabling.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.93 2014/04/16 18:59:38 schwarze Exp $ */
d437 16
a452 6
		for (i = 0; i < argc; i++)
			filescan(argv[i]);
		if (0 == dbopen(1))
			goto out;
		if (OP_TEST != op)
			dbprune();
d455 1
a455 1
		dbclose(1);
@


1.93
log
@Give the mlinks and keys tables a pageid index,
as suggested by jeremy@@ and espie@@.

The mlinks index speeds up basic apropos(1) searches by around 30%
because it speeds up the final SELECT FROM mlinks query by about 95%.
For large result sets, the overall speedup gets even larger, in the
extreme case of "apropos Nd~." by more than 90%.
The keys index finally makes the apropos(1) -O option usable: It no longer
incurs relevant extra cost, while in the past it was embarrassingly slow.

This comes at a cost:  Total database build times grow by about 5%,
and each index adds about 10% database size with -Q.  I consider that
acceptable in view of the huge apropos(1) performance gains.
The -Q database for /usr/share/man still remains below 1 MB.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.92 2014/04/13 22:02:54 schwarze Exp $ */
d95 1
a95 1
	int64_t		 recno;   /* id in mpages SQL table */
d1094 1
a1094 1
					if (mpage_dest->recno)
d1887 1
a1887 1
	SQL_BIND_INT64(stmts[STMT_INSERT_LINK], i, mlink->mpage->recno);
d1939 1
a1939 1
	mpage->recno = sqlite3_last_insert_rowid(db);
d1956 1
a1956 1
		SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, mpage->recno);
d1971 1
a1971 1
		SQL_BIND_INT64(stmts[STMT_INSERT_KEY], i, mpage->recno);
d2167 1
a2167 1
	      " \"id\" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\n"
d2174 1
a2174 1
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(id) "
d2182 1
a2182 1
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(id) "
d2189 1
a2189 1
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(id) "
d2202 1
a2202 1
	sql = "DELETE FROM mpages WHERE id IN "
@


1.92
log
@Unify description handling across all document types (mdoc, man, cat).
Assert that the description is unset right before calling the parse_*
handler, and assign a default if it's still unset right afterwards.
Remove all stray asserts and default assignments found elsewhere.

This fixes SQL_STEP failures for man(7) pages lacking descriptions.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.91 2014/04/13 21:21:27 schwarze Exp $ */
d2177 1
d2191 2
a2192 1
	      ");\n";
@


1.91
log
@better error reporting in case of SQL errors: mention dir and file
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.90 2014/04/10 02:45:03 schwarze Exp $ */
d1149 1
a1152 1
			assert(NULL == mpage->desc);
a1153 3
			if (NULL == mpage->desc)
				mpage->desc = mandoc_strdup(
				    mpage->mlinks->name);
d1158 2
a1295 2
		assert(NULL == mpage->desc);
		mpage->desc = mandoc_strdup(mpage->mlinks->name);
a1333 1
	assert(NULL == mpage->desc);
a1472 1
			assert(NULL == mpage->desc);
@


1.90
log
@Next speed optimization step for the new apropos(1).
Split manual names out of the common "keys" table into their
own "names" table.  This reduces standard apropos(1) search
times (i.e. searching for names and descriptions only) by
typically about 70% for the full /usr/share/man database.
(Yes, that multiplies with the previous optimization step,
so both together have reduced search times by a factor of
more than six.  I'm not done yet, expect more to come.)

Even with the minimal databases built with makewhatis(8) -Q,
this step still reduces search times by 15-20%.  For both cases,
database sizes and build times hardly change (+/-2%).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.89 2014/04/09 21:49:31 schwarze Exp $ */
d50 1
a50 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db))
d54 1
a54 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db))
d58 1
a58 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db))
d62 1
a62 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db))
d65 1
a65 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db))
a1199 1
	size_t		 i;
d1215 2
a1216 2
	i = 1;
	SQL_BIND_INT64(stmt, i, NAME_TITLE);
d1951 1
@


1.89
log
@After careful gprof(1)ing of the new apropos(1), move the descriptions
back from the keys table to the mpages table:  I found a good way
to still use them in searches, without complication of the code.

On my notebook, this reduces typical apropos(1) search times by about 40%,
it reduces /usr/share/man database size by 6% in makewhatis(8) -Q mode
and by 2% in standard mode (less overhead storing pointers to mpages),
and it doesn't measurably change database build times (may even be
going down by a percent or so because less data is being copied
around in ohashes).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.88 2014/04/04 18:23:07 schwarze Exp $ */
d121 1
d184 1
d188 1
d961 1
a961 1
	 * parse_cat() doesn't set TYPE_Nm and TYPE_NAME yet.
d972 2
a973 2
	slot = ohash_qlookup(&strings, mlink->name);
	str = ohash_find(&strings, slot);
d975 1
a975 1
	if ( ! (TYPE_NAME & str->mask))
d1019 2
d1146 1
a1146 1
			putkey(mpage, mlink->name, TYPE_Nm);
d1151 1
a1151 1
				putkey(mpage, cp, TYPE_Nm);
d1187 1
d1205 1
a1205 1
	    "SELECT key, pageid FROM keys "
d1208 2
a1209 2
	      "WHERE mlinks.pageid == keys.pageid "
	      "AND mlinks.name == keys.key"
d1217 1
a1217 1
	SQL_BIND_INT64(stmt, i, TYPE_NAME);
d1442 1
a1442 1
				putkey(mpage, start, TYPE_NAME | TYPE_Nm);
d1456 1
a1456 1
				putkey(mpage, start, TYPE_NAME | TYPE_Nm);
d1633 1
a1633 1
		putmdockey(mpage, n->child, TYPE_NAME | TYPE_Nm);
d1635 1
a1635 1
		putmdockey(mpage, n->child, TYPE_Nm);
d1669 1
a1671 1
	uint64_t	 mask;
d1678 15
a1692 8
	if (debug > 1) {
		for (i = 0, mask = 1;
		     i < mansearch_keymax;
		     i++, mask <<= 1)
			if (mask & v)
				break;
		say(mpage->mlinks->file, "Adding key %s=%*s",
		    mansearch_keynames[i], sz, cp);
d1696 2
a1697 2
	slot = ohash_qlookupi(&strings, cp, &end);
	s = ohash_find(&strings, slot);
d1705 1
a1705 1
		ohash_insert(&strings, slot, s);
d1953 15
d2183 7
d2215 3
@


1.88
log
@In -p (picky) mode, warn unless each filename (aka mlink)
appears as a name in the NAME section.
While here, garbage collect two unused variables, both called "match".
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.87 2014/04/04 16:43:08 schwarze Exp $ */
d219 1
a219 1
	{ parse_mdoc_Nd, TYPE_Nd },  /* Nd */
d1149 3
a1151 2
			putkey(mpage, NULL != mpage->desc ?
			    mpage->desc : mpage->mlinks->name, TYPE_Nd);
a1293 1
		putkey(mpage, mpage->mlinks->name, TYPE_Nd);
a1333 1
	putkey(mpage, mpage->desc, TYPE_Nd);
a1473 1
			putkey(mpage, mpage->desc, TYPE_Nd);
d1921 1
a1921 10
		for (key = ohash_first(&strings, &slot); NULL != key;
		     key = ohash_next(&strings, &slot)) {
			if (TYPE_Nd & key->mask) {
				if (NULL == key->rendered)
					render_key(mc, key);
				printf(" - %s", key->rendered);
				break;
			}
		}
		putchar('\n');
d1929 1
d2142 1
d2175 1
a2175 1
		"(form) VALUES (?)";
@


1.87
log
@Warn about missing mlinks.
This is really expensive, more than tripling database build times,
so only do it when the -p (picky) option was given, but none of the
following options were given: -Q (quick), -d, -u, or -t.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.86 2014/04/04 15:55:17 schwarze Exp $ */
d142 1
a142 1
static	int	 mlink_check(struct mpage *, struct mlink *);
d919 1
a919 1
static int
d922 2
a923 3
	int	 match;

	match = 1;
d935 1
a935 2
	    strcasecmp(mpage->sec, mlink->dsec)) {
		match = 0;
a937 1
	}
d952 1
a952 2
	if (strcasecmp(mpage->arch, mlink->arch)) {
		match = 0;
a954 1
	}
d956 12
a967 2
	if (strcasecmp(mpage->title, mlink->name))
		match = 0;
d969 5
a973 1
	return(match);
d996 1
a996 1
	int			 match, status;
a1143 9
		if (warnings && !use_all) {
			match = 0;
			for (mlink = mpage->mlinks; mlink;
			     mlink = mlink->next)
				if (mlink_check(mpage, mlink))
					match = 1;
		} else
			match = 1;

d1155 5
@


1.86
log
@Remember which names are in the NAME section.
This helps to find missing MLINKS.
Database build times do not change and database growth is minimal
(1.2% with -Q, 0.7% without -Q in /usr/share/man),
so making this optional would be pointless.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.85 2014/04/04 02:31:01 schwarze Exp $ */
d147 1
d491 3
d1181 36
@


1.85
log
@When the -n or -t flag is given to makewhatis(8),
write names and decriptions to stdout,
in a format similar to apropos(1) output.
Inspired by espie@@'s makewhatis.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.84 2014/04/03 21:45:27 schwarze Exp $ */
d219 1
a219 1
	{ parse_mdoc_Nm, TYPE_Nm },  /* Nm */
d1392 1
a1392 1
				putkey(mpage, start, TYPE_Nm);
d1406 1
a1406 1
				putkey(mpage, start, TYPE_Nm);
d1583 5
a1587 2
	return(SEC_NAME == n->sec ||
	    (SEC_SYNOPSIS == n->sec && MDOC_HEAD == n->type));
@


1.84
log
@Instead of silently doing nothing at all,
warn and return non-zero when the manpath is empty, that is,
when /etc/man.conf is non-existent or unreadable
AND the environment variable MANPATH is unset or empty
AND no directories were given on the command line.

Inspired by the error handling in espie@@'s makewhatis(8),
except that one doesn't know about MANPATH.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.83 2014/04/03 16:26:53 schwarze Exp $ */
d1853 1
a1853 2
	if (debug)
		say(mpage->mlinks->file, "Adding to database");
d1855 30
a1884 1
	if (nodb)
d1886 4
d1897 1
a1897 1
	for (mlink = mpage->mlinks; mlink; mlink = mlink->next)
d1899 2
@


1.83
log
@Rename the -W option to -p (mnemonics: picky, print to stderr):
That letter was already chosen by espie@@ for OpenBSD 2.7,
so avoid being gratuitiously different more than a decade later.
Accept -v for backward compatibility with espie@@'s makewhatis,
even though it does nothing right now.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.82 2014/04/03 15:37:14 schwarze Exp $ */
d456 5
@


1.82
log
@The -v option of mandocdb(8) clashes with the -v option of espie@@'s
makewhatis(8), which traditionally does something different,
so rename it to -D (mnemonics: Debug, Dump, Display).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.81 2014/03/26 21:39:33 schwarze Exp $ */
d352 1
a352 1
	while (-1 != (ch = getopt(argc, argv, "aC:Dd:nQT:tu:W")))
d373 3
d398 2
a399 2
		case ('W'):
			warnings = 1;
d504 4
a507 4
	fprintf(stderr, "usage: %s [-aDnQW] [-C file] [-Tutf8]\n"
			"       %s [-aDnQW] [-Tutf8] dir ...\n"
			"       %s [-DnQW] [-Tutf8] -d dir [file ...]\n"
			"       %s [-DnW] -u dir [file ...]\n"
@


1.81
log
@Without bloating mandoc(1) itself, let mandocdb(8) support files
called manN/X.N.gz and catN/X.0.gz, reading them through a pipe(2)
from gunzip(1) -c.  Asked for by various people in the past.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.80 2014/03/26 20:53:31 schwarze Exp $ */
d174 1
a174 1
static	int	  	 verb; /* print what we're doing */
d352 1
a352 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:nQT:tu:vW")))
d362 3
a394 3
		case ('v'):
			verb++;
			break;
d501 4
a504 4
	fprintf(stderr, "usage: %s [-anQvW] [-C file] [-Tutf8]\n"
			"       %s [-anQvW] [-Tutf8] dir ...\n"
			"       %s [-nQvW] [-Tutf8] -d dir [file ...]\n"
			"       %s [-nvW] -u dir [file ...]\n"
d1618 1
a1618 1
	if (verb > 1) {
d1845 1
a1845 1
	if (verb)
d1891 1
a1891 1
		if (verb)
@


1.80
log
@Improve error reporting.
Simplify combining a custom format string with perror(),
avoiding many manual calls to strerror(errno).
For low-level failures, report attempted function calls.
Do not abuse the say() filename argument for files outside the basedir,
and even less for other text.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.79 2014/03/23 12:44:18 schwarze Exp $ */
d114 1
d147 1
a147 1
static	void	 parse_cat(struct mpage *);
d532 1
a532 1
	int		 dform;
d567 12
a578 2
			} else if (NULL == (fsec =
					strrchr(ff->fts_name, '.'))) {
a588 4
			} else if (0 == strcmp(fsec, "gz")) {
				if (warnings)
					say(path, "Skip gz");
				continue;
d613 1
d967 1
d974 2
a975 1
	int			 match;
d999 35
d1042 1
a1042 1
			lvl = mparse_readfd(mp, -1, mpage->mlinks->file);
d1082 1
a1082 3
			ohash_delete(&strings);
			mpage = ohash_next(&mpages, &pslot);
			continue;
d1142 1
a1142 1
			parse_cat(mpage);
d1145 18
d1172 1
a1172 1
parse_cat(struct mpage *mpage)
d1178 4
a1181 1
	if (NULL == (stream = fopen(mpage->mlinks->file, "r"))) {
@


1.79
log
@If an .Nd block contains macros, avoid fragmented entries in mandocdb(8),
instead use the .Nd content recursively.
Improves a couple of index entries in base.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.78 2014/03/22 00:56:07 schwarze Exp $ */
d546 1
a546 1
		say("", NULL);
d700 1
a700 1
		say(file, NULL);
d716 1
a716 1
		say(file, NULL);
d1119 1
a1119 1
			say(mpage->mlinks->file, NULL);
d1876 1
a1876 1
			say(MANDOC_DB, "%s", strerror(errno));
d1884 1
a1884 1
		say("fork cmp", "%s", strerror(errno));
d1889 1
a1889 1
		say("exec cmp", "%s", strerror(errno));
d1896 1
a1896 1
		say("wait cmp", "%s", strerror(errno));
d1899 1
a1899 1
		say("cmp", "Died from a signal");
d1910 1
a1910 1
		say("fork rm", "%s", strerror(errno));
d1914 1
a1914 1
		say("exec rm", "%s", strerror(errno));
d1921 1
a1921 1
		say("wait rm", "%s", strerror(errno));
d1924 2
a1925 2
		say(tempfilename,
		    "Cannot remove temporary directory");
d1974 1
a1974 1
		say("/tmp/mandocdb.XXXXXX", "Filename too long");
d1979 1
a1979 1
		say(tempfilename, "%s", strerror(errno));
d1985 2
a1986 1
		say(tempfilename, "Filename too long");
d1992 1
a1992 1
		say(tempfilename, "%s", sqlite3_errmsg(db));
d2087 1
a2087 1
				say(".", NULL);
d2092 1
a2092 1
			say(startdir, NULL);
d2104 1
a2104 1
			say(startdir, NULL);
d2115 1
a2115 1
		say(targetdir, NULL);
d2119 1
a2119 1
		say("", NULL);
d2129 1
a2136 1
	fputs(": ", stderr);
d2138 24
a2161 1
	if (NULL == format) {
d2163 2
a2164 8
		return;
	}

	va_start(ap, format);
	vfprintf(stderr, format, ap);
	va_end(ap);

	fputc('\n', stderr);
@


1.78
log
@If a man(7) NAME section contains macros, avoid truncated or empty
entries for .Nd in mandocdb(8), instead use the macro content
recursively.  This improves indexing of more than 200 manuals
in Xenocara, i.e. more than 15%, in particular GL and some Xkb.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.77 2014/03/21 22:52:21 schwarze Exp $ */
a1500 1
	size_t		 sz;
d1502 3
a1504 24
	if (MDOC_BODY != n->type)
		return(0);

	/*
	 * Special-case the `Nd' because we need to put the description
	 * into the document table.
	 */

	for (n = n->child; NULL != n; n = n->next) {
		if (MDOC_TEXT == n->type) {
			if (NULL != mpage->desc) {
				sz = strlen(mpage->desc) +
				     strlen(n->string) + 2;
				mpage->desc = mandoc_realloc(
				    mpage->desc, sz);
				strlcat(mpage->desc, " ", sz);
				strlcat(mpage->desc, n->string, sz);
			} else
				mpage->desc = mandoc_strdup(n->string);
		}
		if (NULL != n->child)
			parse_mdoc_Nd(mpage, n);
	}
	return(1);
@


1.77
log
@avoid repetitive code for asprintf error handling
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.76 2014/03/21 22:17:01 schwarze Exp $ */
d1258 1
a1258 1
	char		*start, *sv, *title;
d1260 1
a1260 1
	size_t		 sz, titlesz;
d1280 1
a1280 5
				NULL != (body = body->child) &&
				MAN_TEXT == body->type) {

			title = NULL;
			titlesz = 0;
d1289 2
a1290 11
			for ( ; NULL != body; body = body->next) {
				if (MAN_TEXT != body->type)
					break;
				if (0 == (sz = strlen(body->string)))
					continue;
				title = mandoc_realloc
					(title, titlesz + sz + 1);
				memcpy(title + titlesz, body->string, sz);
				titlesz += sz + 1;
				title[titlesz - 1] = ' ';
			}
a1293 27
			title = mandoc_realloc(title, titlesz + 1);
			title[titlesz] = '\0';

			/* Skip leading space.  */

			sv = title;
			while (isspace((unsigned char)*sv))
				sv++;

			if (0 == (sz = strlen(sv))) {
				free(title);
				return;
			}

			/* Erase trailing space. */

			start = &sv[sz - 1];
			while (start > sv && isspace((unsigned char)*start))
				*start-- = '\0';

			if (start == sv) {
				free(title);
				return;
			}

			start = sv;

d1302 1
d1333 1
a1333 1
			if (sv == start) {
@


1.76
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.75 2014/03/19 22:33:04 schwarze Exp $ */
d1531 1
a1531 4
	if (-1 == asprintf(&cp, "%s(%s)", n->string, n->next->string)) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.75
log
@Register pure .so pages as mlinks, not as mpages.
This doesn't affect /usr/share/man, but improves /usr/X11R6/man:
* Eliminates multiple apropos(1) output for such pages.
* Reduces X11R6 database size from 450 kB to 240 kB (-47%).
* Reduces X11R6 database build time from 1.68s to 1.00s (-40%).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.74 2014/03/19 22:20:36 schwarze Exp $ */
d41 1
@


1.74
log
@Without the MPARSE_SO option, if the file contains nothing but a
single .so request, do not read the file pointed to, but instead
let mparse_result() provide the file name pointed to as a return
value.  To be used by makewhatis(8) in the future.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.73 2014/03/19 21:50:59 schwarze Exp $ */
d94 1
d112 1
d131 2
a132 1
static	void	 dbadd(const struct mpage *, struct mchars *);
a348 1
	mparse_options = MPARSE_SO;
d815 1
d958 2
a959 2
	struct mpage		*mpage;
	struct mlink		*mlink;
d962 1
d998 1
a998 1
				mparse_result(mp, &mdoc, &man, NULL);
d1001 39
a1039 1
		if (NULL != mdoc) {
d1816 14
d1837 1
a1837 1
dbadd(const struct mpage *mpage, struct mchars *mc)
a1840 1
	int64_t		 recno;
d1853 1
a1853 1
	recno = sqlite3_last_insert_rowid(db);
d1856 2
a1857 9
	for (mlink = mpage->mlinks; mlink; mlink = mlink->next) {
		i = 1;
		SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->dsec);
		SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->arch);
		SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->name);
		SQL_BIND_INT64(stmts[STMT_INSERT_LINK], i, recno);
		SQL_STEP(stmts[STMT_INSERT_LINK]);
		sqlite3_reset(stmts[STMT_INSERT_LINK]);
	}
d1867 1
a1867 1
		SQL_BIND_INT64(stmts[STMT_INSERT_KEY], i, recno);
@


1.73
log
@Generalize the mparse_alloc() and roff_alloc() functions by giving
them an "options" argument, replacing the existing "inttype" and
"quick" arguments, preparing for a future MPARSE_SO option.
Store this argument in struct mparse and struct roff, replacing the
existing "inttype", "parsetype", and "quick" members.
No functional change except one tiny cosmetic fix in roff_TH().
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.72 2014/03/18 16:56:06 schwarze Exp $ */
d994 1
a994 1
				mparse_result(mp, &mdoc, &man);
@


1.72
log
@Allow checking that databases are up to date even when you have no write
permission on the databases, as requested by espie@@ quite some time ago.
But make sure to not slow database generation down when you do have write
permission, and to not delay error reporting in -Q mode.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.71 2014/01/22 20:58:35 schwarze Exp $ */
d167 1
a167 1
static	int		 quick; /* abort the parse early */
d346 1
d367 1
a367 1
			quick = 1;
d407 1
a407 2
	mp = mparse_alloc(MPARSE_AUTO, 
		MANDOCLEVEL_FATAL, NULL, NULL, quick);
d1980 1
a1980 1
	if (quick) {
@


1.71
log
@Implement the \: (optional line break) escape sequence,
documented in the Ossanna-Kernighan-Ritter troff manual
and also supported by groff.

Missing feature reported by Steffen Nurpmeso <sdaoden at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.70 2014/01/19 22:48:00 schwarze Exp $ */
d19 1
d164 1
d1871 2
d1888 28
a1915 1
	if (-1 == rename(MANDOC_DB "~", MANDOC_DB)) {
d1917 24
a1940 1
		say(MANDOC_DB, NULL);
d1955 1
a1955 1
	const char	*file, *sql;
d1961 1
d1963 4
a1966 3
	if (0 == real) {
		file = MANDOC_DB "~";
		if (-1 == remove(file) && ENOENT != errno) {
d1968 1
a1968 1
			say(file, NULL);
d1971 4
a1974 3
		ofl |= SQLITE_OPEN_EXCLUSIVE;
	} else
		file = MANDOC_DB;
d1976 2
a1977 1
	rc = sqlite3_open_v2(file, &db, ofl, NULL);
d1979 2
a1980 2
		goto prepare_statements;
	if (SQLITE_CANTOPEN != rc) {
d1982 1
a1982 1
		say(file, NULL);
d1986 19
a2004 4
	sqlite3_close(db);
	db = NULL;

	if (SQLITE_OK != (rc = sqlite3_open(file, &db))) {
d2006 1
a2006 1
		say(file, NULL);
d2010 1
d2033 1
a2033 1
		say(file, "%s", sqlite3_errmsg(db));
@


1.70
log
@Avoid the risk of trying to modify a literal string.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.69 2014/01/19 22:40:42 schwarze Exp $ */
d1659 1
a1659 1
	char		 utfbuf[7], res[5];
d1671 2
a1672 1
	res[4] = '\0';
d1703 2
a1704 1
		if (ASCII_HYPH == *val) {
d1708 3
a1710 1
		} else if ('\t' == *val || ASCII_NBRSP == *val) {
d1713 2
d1716 4
a1719 1
		} else if ('\\' != *val)
@


1.69
log
@Always store the arch in lower-case only.
Reduces database size by ~0.5%, and by ~1.5% with -Q.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.68 2014/01/19 00:09:33 schwarze Exp $ */
d951 1
d1023 1
a1023 1
		    "any" : mpage->arch, TYPE_arch);
d1031 1
a1031 1
			    "any" : mlink->arch, TYPE_arch);
@


1.68
log
@Support a second -v on mandocdb(8) to show keys while they are being added;
i need that for debugging, in particular to be used with -t.
To be able to do so, provide a global table of key names, for reuse.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.67 2014/01/18 08:54:20 schwarze Exp $ */
d152 1
a152 2
static	void	 putkey(const struct mpage *,
			const char *, uint64_t);
d956 1
a956 1
	const char		*cp;
d1180 1
a1180 1
putkey(const struct mpage *mpage, const char *value, uint64_t type)
d1182 1
d1185 4
d1442 1
a1442 1
	const char	*cp;
@


1.67
log
@Cope with slightly broken NAME sections in man(7) pages
having a trailing comma after the last name, like this:

ASN1_OBJECT_new, ASN1_OBJECT_free, - object allocation functions

Nit found somewhere above the Tasman Sea,
committing from Dunedin, Otago.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.66 2014/01/17 19:16:42 schwarze Exp $ */
d43 3
d1560 2
d1563 1
a1563 1
	const char	*end;
d1567 10
@


1.66
log
@Drop the AUTOINCREMENT PRIMARY KEYs from the mlinks and keys tables.
They are completely unused, and i cannot imagine what they *could*
ever be used for; but apparently, they are expensive to generate.

Standard DB build time goes down by 10%, now at 1.9x of makewhatis.
Standard DB size goes down by 4%, now at 11x of makewhatis.
DB build time with -Q goes down by 15%, now at 0.28x of makewhatis.
DB size with -Q goes down by 3%, now at 3.35x of makewhatis.

Optimization found somewhere above the Southern Balochistan desert,
near the Iran-Pakistan border.  Committing from Melbourne, Victoria.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.64 2014/01/06 20:53:36 schwarze Exp $ */
d1296 9
@


1.65
log
@Despite some experimenting, i'm unable to find any relevant effect of
creating an index for the keys table on apropos(1) search times;
apparently, adding that index was premature optimization in the first
place; so, stop adding that index.

Its root gone, the following evil is reduced (/usr/share/man on my notebook)
 - DB build time with -Q goes down by 15%, now at 1/3 of makewhatis
 - DB size with -Q goes down by 35%, now at 3.5x of makewhatis
 - full DB build time goes down by 12%, now at 2.1x of makewhatis
 - full DB size goes down by 42%, now at 11.5x of makewhatis

Optimization found somewhere above the Dasht-e Kavir, the Great Salt
Desert, between Tehran (Iran) and Herat (Afghanistan).  Committing
from Melbourne, Australia.
@
text
@d1909 1
a1909 2
		"ON DELETE CASCADE,\n"
	      " \"id\" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\n"
d1916 1
a1916 2
		"ON DELETE CASCADE,\n"
	      " \"id\" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\n"
@


1.64
log
@Do not sync to disk after each individual manual page (duh!),
only sync to disk one single time when all data is ready.

Rebuild times for /usr/share/man/mandoc.db shrink on my notebook:
In standard mode from 45 seconds to 11 seconds   (75% reduction)
In -Q mode       from 25 seconds to 3.1 seconds  (87% reduction)
For comparison: makewhatis(8):      4.2 seconds

That is, in -Q mode, we are now *faster* than the existing makewhatis(8),
and careful profiling shows there is still a lot of room for improval.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.63 2014/01/06 15:32:44 schwarze Exp $ */
d1919 1
a1919 3
	      ");\n"
	      "\n"
	      "CREATE INDEX \"key_index\" ON keys (key);\n";
@


1.63
log
@Fix mandocdb(8) -d and -u.
It was broken by recent optimizations.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.62 2014/01/06 13:54:11 schwarze Exp $ */
d964 3
d1057 3
a1754 2
	SQL_EXEC("BEGIN TRANSACTION");

a1785 2

	SQL_EXEC("END TRANSACTION");
@


1.62
log
@Rename dbindex() to dbadd() to be less confusing.
The concept of an index file is gone since the switch to SQLite.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.61 2014/01/06 03:52:05 schwarze Exp $ */
d695 7
a701 1
	} else if (OP_TEST != op && strstr(buf, basedir) != buf) {
d705 3
a707 1
	} else if (-1 == stat(buf, &st)) {
d716 1
a716 1
	start = buf + strlen(basedir);
d1794 2
a1795 2
	if (nodb)
		return;
d1797 2
a1798 2
	mpage = ohash_first(&mpages, &slot);
	while (NULL != mpage) {
a1799 4
		i = 1;
		SQL_BIND_TEXT(stmts[STMT_DELETE_PAGE], i, mlink->file);
		SQL_STEP(stmts[STMT_DELETE_PAGE]);
		sqlite3_reset(stmts[STMT_DELETE_PAGE]);
d1801 14
a1814 2
			say(mlink->file, "Deleted from database");
		mpage = ohash_next(&mpages, &slot);
d1816 3
d1929 3
a1931 1
	sql = "DELETE FROM mpages where file=?";
@


1.61
log
@Remove the redundant "file" column from the "mlinks" table.
The contents can easily be reconstructed from sec, arch, name, form.
Shrinks the database by another 3% in standard mode and 9% in -Q mode.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.60 2014/01/06 03:02:40 schwarze Exp $ */
d125 1
a125 1
static	void	 dbindex(const struct mpage *, struct mchars *);
d1042 1
a1042 1
		dbindex(mpage, mc);
d1727 1
a1727 1
dbindex(const struct mpage *mpage, struct mchars *mc)
d1736 1
a1736 1
		say(mpage->mlinks->file, "Adding to index");
d1797 1
a1797 1
			say(mlink->file, "Deleted from index");
@


1.60
log
@Drop Nd from the mpages table, it is still in the keys table.
This shrinks the database in standard mode by 3%, in -Q mode by 9%,
without loss of functionality.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.59 2014/01/05 20:26:27 schwarze Exp $ */
a1750 1
		SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->file);
a1883 1
	      " \"file\" TEXT NOT NULL,\n"
d1916 1
a1916 1
		"(file,sec,arch,name,pageid) VALUES (?,?,?,?,?)";
@


1.59
log
@Add an option -Q (quick) to mandocdb(8)
for accelerated generation of reduced-size databases.

Implement this by allowing the parsers to optionally
abort the parse sequence after the NAME section.

While here, garbage collect the unused void *arg attribute
of struct mparse and mparse_alloc().

This reduces the processing time of mandocdb(8) on /usr/share/man
by a factor of 2 and the database size by a factor of 4.
However, it still takes 5 times the time and 6 times the space
of makewhatis(8), so more work is clearly needed.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.58 2014/01/05 04:48:35 schwarze Exp $ */
a1730 1
	const char	*desc;
a1740 10
	desc = "";
	if (NULL != mpage->desc && '\0' != *mpage->desc) {
		key = ohash_find(&strings,
			ohash_qlookup(&strings, mpage->desc));
		assert(NULL != key);
		if (NULL == key->rendered)
			render_key(mc, key);
		desc = key->rendered;
	}

a1743 1
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, desc);
a1879 1
	      " \"desc\" TEXT NOT NULL,\n"
d1915 1
a1915 1
		"(desc,form) VALUES (?,?)";
@


1.58
log
@Rip out the complete "reachable" checks, without replacement.
It's a pity i spent time during t2k13 writing this; however,
when an entire concept is busted, let us not look back.

There is no such thing as an unreachable page.  Even if you are crazy
enough to put a page starting with ".Dt NAMEI 9" into a file man1/cat.1,
we now make sure that it can be found by all of the following:
Nm=namei Nm=cat sec=1 sec=9
It will always be displayed as:
cat(1) - pathname lookup
So you know that you have to type `man cat` to get at it.
That obsoletes the concept of "unreachable manuals" for good.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.57 2014/01/05 04:13:46 schwarze Exp $ */
d162 2
a164 1
static	int		 nodb; /* no database changes */
d343 1
a343 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:nT:tu:vW")))
d361 3
d403 1
a403 1
		MANDOCLEVEL_FATAL, NULL, NULL, NULL);
d493 3
a495 3
	fprintf(stderr, "usage: %s [-anvW] [-C file] [-Tutf8]\n"
			"       %s [-anvW] [-Tutf8] dir ...\n"
			"       %s [-nvW] [-Tutf8] -d dir [file ...]\n"
d497 1
a497 1
			"       %s -t file ...\n",
@


1.57
log
@Remove the obsolete file name column from the mpages table.
This column wasn't helpful because one manpage can have multiple MLINKS.
Use the file name column in the mlinks table, instead.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.56 2014/01/05 03:25:51 schwarze Exp $ */
a108 5
struct	title {
	char		*title; /* name(sec/arch) given inside the file */
	char		*file; /* file name in case of mismatch */
};

d137 1
a137 1
static	void	 mpages_merge(struct mchars *, struct mparse *, int);
d425 1
a425 1
			mpages_merge(mc, mp, 0);
d469 1
a469 1
			mpages_merge(mc, mp, warnings && !use_all);
d935 1
a935 1
mpages_merge(struct mchars *mc, struct mparse *mp, int check_reachable)
d937 1
a937 2
	struct ohash		 title_table;
	struct ohash_info	 title_info, str_info;
a941 2
	struct title		*title_entry;
	char			*title_str;
d944 1
a944 1
	unsigned int		 pslot, tslot;
a951 8
	if (check_reachable) {
		title_info.alloc = hash_alloc;
		title_info.halloc = hash_halloc;
		title_info.hfree = hash_free;
		title_info.key_offset = offsetof(struct title, title);
		ohash_init(&title_table, 6, &title_info);
	}

a1037 31
		/*
		 * Build a title string for the file.  If it matches
		 * the location of the file, remember the title as
		 * found; else, remember it as missing.
		 */

		if (check_reachable) {
			if (-1 == asprintf(&title_str, "%s(%s%s%s)",
			    mpage->title, mpage->sec,
			    '\0' == *mpage->arch ? "" : "/",
			    mpage->arch)) {
				perror(NULL);
				exit((int)MANDOCLEVEL_SYSERR);
			}
			tslot = ohash_qlookup(&title_table, title_str);
			title_entry = ohash_find(&title_table, tslot);
			if (NULL == title_entry) {
				title_entry = mandoc_malloc(
						sizeof(struct title));
				title_entry->title = title_str;
				title_entry->file = mandoc_strdup(
				    match ? "" : mpage->mlinks->file);
				ohash_insert(&title_table, tslot,
						title_entry);
			} else {
				if (match)
					*title_entry->file = '\0';
				free(title_str);
			}
		}

a1040 15
	}

	if (check_reachable) {
		title_entry = ohash_first(&title_table, &tslot);
		while (NULL != title_entry) {
			if ('\0' != *title_entry->file)
				say(title_entry->file,
			    	    "Probably unreachable, title is %s",
				    title_entry->title);
			free(title_entry->title);
			free(title_entry->file);
			free(title_entry);
			title_entry = ohash_next(&title_table, &tslot);
		}
		ohash_delete(&title_table);
@


1.56
log
@Remove the obsolete sec and arch columns from the mpages table.
They were confusing because a manpage can have MLINKS in different
sections and architectures.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.55 2014/01/05 03:06:36 schwarze Exp $ */
a1812 6
	/*
	 * XXX The following line is obsolete
	 * and only kept for backward compatibility
	 * until apropos(1) and friends have caught up.
	 */
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->mlinks->file);
a1948 5
	/*
	 * XXX The first column in table mpages is obsolete
	 * and only kept for backward compatibility
	 * until apropos(1) and friends have caught up.
	 */
a1949 1
	      " \"file\" TEXT NOT NULL,\n"
d1986 1
a1986 1
		"(file,desc,form) VALUES (?,?,?)";
@


1.55
log
@Reimplement apropos -s NUM -S ARCH EXPR by internally converting it to
apropos \( EXPR \) -a 'sec~^NUM$' -a 'arch~^(ARCH|any)$'
in preparation for removal of sec and arch from the mpage table.

Almost no functional change except for the following bonus:
This also makes sure that for cross-section and cross-arch MLINKs,
all of the following work:
apropos -s 1 encrypt
apropos -s 8 encrypt
apropos -s 1 makekey
apropos -s 8 makekey
Before this commit, they don't, neither for the
old makewhatis(8)/apropos(1) combo nor for the new one.

While here, print error messages about invalid regexps to stderr.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.54 2014/01/05 00:29:49 schwarze Exp $ */
d1814 1
a1814 1
	 * XXX The following three lines are obsolete
a1818 2
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->mlinks->dsec);
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->mlinks->arch);
d1956 1
a1956 1
	 * XXX The first three columns in table mpages are obsolete
a1961 2
	      " \"sec\" TEXT NOT NULL,\n"
	      " \"arch\" TEXT NOT NULL,\n"
d1998 1
a1998 1
		"(file,sec,arch,desc,form) VALUES (?,?,?,?,?)";
@


1.54
log
@Put section and architecture info into the keys table,
in preparation for removing them from the mpages table,
aiming for cleaner and more uniform interfaces.
Database growth is below 4%, part of which will be reclaimed.

As a bonus, this allows searches like:
./obj/apropos An=kettenis -a arch=ppc
./obj/apropos An=kettenis -a sec~[^4]
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.53 2014/01/02 22:44:07 schwarze Exp $ */
d1020 2
a1021 1
		putkey(mpage, mpage->arch, TYPE_arch);
d1028 2
a1029 1
			putkey(mpage, mlink->arch, TYPE_arch);
@


1.53
log
@Avoid "utf8" in the names of a function and a struct member
that don't necessarily have anything to do with UTF-8.
Just renaming, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.52 2014/01/02 22:19:38 schwarze Exp $ */
d1019 2
d1022 6
a1027 1
		for (mlink = mpage->mlinks; mlink; mlink = mlink->next)
d1029 1
@


1.52
log
@Do not put UTF-8-encoded strings into the database by default, use ASCII.
Just like for mandoc(1), provide a -Tutf8 option for people who want that.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.51 2014/01/02 20:24:35 schwarze Exp $ */
d77 1
a77 1
	char		*utf8; /* key in UTF-8 form */
d80 1
a80 1
	char		 key[]; /* the string itself */
d160 1
a164 1
static	void	 utf8key(struct mchars *, struct str *);
d1657 2
a1658 2
 * Store the UTF-8 version of a key, or alias the pointer if the key has
 * no UTF-8 transcription marks in it.
d1661 1
a1661 1
utf8key(struct mchars *mc, struct str *key)
d1670 1
a1670 1
	assert(NULL == key->utf8);
d1686 1
a1686 1
		key->utf8 = key->key;
d1765 1
a1765 1
	key->utf8 = buf;
d1772 1
a1772 1
 * Also, UTF-8-encode the description at the last possible moment.
d1795 3
a1797 3
		if (NULL == key->utf8)
			utf8key(mc, key);
		desc = key->utf8;
d1831 2
a1832 2
		if (NULL == key->utf8)
			utf8key(mc, key);
d1835 1
a1835 1
		SQL_BIND_TEXT(stmts[STMT_INSERT_KEY], i, key->utf8);
d1839 2
a1840 2
		if (key->utf8 != key->key)
			free(key->utf8);
@


1.51
log
@Polish the mlink_add() interface:
Allocate memory inside, not in the callers.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.50 2014/01/02 18:51:51 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d171 1
d347 1
a347 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:ntu:vW")))
d365 8
d494 3
a496 3
	fprintf(stderr, "usage: %s [-anvW] [-C file]\n"
			"       %s [-anvW] dir ...\n"
			"       %s [-nvW] -d dir [file ...]\n"
d1726 1
a1730 1

a1732 2
		if (0 == (u = mchars_spec2cp(mc, seq, len)))
			continue;
d1735 2
a1736 2
		 * If we have a Unicode codepoint, try to convert that
		 * to a UTF-8 byte string.
d1738 17
a1754 3
		cpp = utfbuf;
		if (0 == (sz = utf8(u, utfbuf)))
			continue;
a1757 1
		sz = strlen(cpp);
a1758 1

a1759 1

@


1.50
log
@Check all MLINKS for consistency with the content of the manual page,
not just the first one.  This doesn't change how the check is done,
but just which MLINKS are checked.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49 2013/12/31 19:39:09 schwarze Exp $ */
d517 2
a518 2
	char		*fsec;
	const char	*dsec, *arch, *cp, *path;
d583 1
d587 4
a590 7
			if (NULL != dsec)
				mlink->dsec = mandoc_strdup(dsec);
			if (NULL != arch)
				mlink->arch = mandoc_strdup(arch);
			mlink->name = mandoc_strdup(ff->fts_name);
			if (NULL != fsec)
				mlink->fsec = mandoc_strdup(fsec);
a609 2
			dsec = NULL;
			dform = FORM_NONE;
d620 3
a636 1
			arch = NULL;
d639 2
d714 1
a714 1
			mlink->dsec = mandoc_strdup(start + 3);
d717 1
a717 1
			mlink->dsec = mandoc_strdup(start + 3);
d723 1
a723 1
			mlink->arch = mandoc_strdup(start);
d738 1
a738 1
		mlink->fsec = mandoc_strdup(p);
a749 2
	mlink->name = mandoc_strdup(mlink->name);

d762 4
a765 8
	if (NULL == mlink->dsec)
		mlink->dsec = mandoc_strdup("");
	if (NULL == mlink->arch)
		mlink->arch = mandoc_strdup("");
	if (NULL == mlink->name)
		mlink->name = mandoc_strdup("");
	if (NULL == mlink->fsec)
		mlink->fsec = mandoc_strdup("");
@


1.49
log
@Yet another regression introduced by Kristaps when he switched from
Berkeley DB to SQLite3: In the .In parser, the logic got inverted.
The resulting NULL pointer access was found by clang;
scan log provided by Ulrich Spoerlein <uqs at FreeBSD>.

The best fix is to simply remove the whole, pointless custom
handler function for .In and let the framework do its work.
Now searching for included header files actually works.

While here, remove the similarly pointless custom .St handler,
fix the return value of the .Fd handler and disentangle the
spaghetti in the .Nm handler.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.48 2013/12/31 18:07:06 schwarze Exp $ */
d138 1
d881 48
d942 1
a976 1
		match = 1;
d1017 2
a1018 16
		/*
		 * Check whether the manual section given in a file
		 * agrees with the directory where the file is located.
		 * Some manuals have suffixes like (3p) on their
		 * section number either inside the file or in the
		 * directory name, some are linked into more than one
		 * section, like encrypt(1) = makekey(8).  Do not skip
		 * manuals for such reasons.
		 */
		if (warnings && !use_all && FORM_SRC == mpage->form &&
		    strcasecmp(mpage->sec, mpage->mlinks->dsec)) {
			match = 0;
			say(mpage->mlinks->file, "Section \"%s\" "
				"manual in %s directory",
				mpage->sec, mpage->mlinks->dsec);
		}
d1020 1
a1020 16
		/*
		 * Manual page directories exist for each kernel
		 * architecture as returned by machine(1).
		 * However, many manuals only depend on the
		 * application architecture as returned by arch(1).
		 * For example, some (2/ARM) manuals are shared
		 * across the "armish" and "zaurus" kernel
		 * architectures.
		 * A few manuals are even shared across completely
		 * different architectures, for example fdformat(1)
		 * on amd64, i386, sparc, and sparc64.
		 * Thus, warn about architecture mismatches,
		 * but don't skip manuals for this reason.
		 */
		if (warnings && !use_all &&
		    strcasecmp(mpage->arch, mpage->mlinks->arch)) {
d1022 6
a1027 9
			say(mpage->mlinks->file, "Architecture \"%s\" "
				"manual in \"%s\" directory",
				mpage->arch, mpage->mlinks->arch);
		}
		if (warnings && !use_all &&
		    strcasecmp(mpage->title, mpage->mlinks->name))
			match = 0;

		putkey(mpage, mpage->mlinks->name, TYPE_Nm);
@


1.48
log
@remove assignments that will be overwritten right afterwards,
and remove pointless local variables;
found in a clang output from Ulrich Spoerlein <uqs at FreeBSD>
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.47 2013/12/31 00:40:19 schwarze Exp $ */
a148 1
static	int	 parse_mdoc_In(struct mpage *, const struct mdoc_node *);
a151 1
static	int	 parse_mdoc_St(struct mpage *, const struct mdoc_node *);
d209 1
a209 1
	{ parse_mdoc_In, TYPE_In },  /* In */
d217 1
a217 1
	{ parse_mdoc_St, 0 },  /* St */
d1434 1
a1434 12
	return(1);
}

static int
parse_mdoc_In(struct mpage *mpage, const struct mdoc_node *n)
{

	if (NULL != n->child && MDOC_TEXT == n->child->type)
		return(0);

	putkey(mpage, n->child->string, TYPE_In);
	return(1);
a1470 11
parse_mdoc_St(struct mpage *mpage, const struct mdoc_node *n)
{

	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return(0);

	putkey(mpage, n->child->string, TYPE_St);
	return(1);
}

static int
d1527 2
a1528 6
	if (SEC_NAME == n->sec)
		return(1);
	else if (SEC_SYNOPSIS != n->sec || MDOC_HEAD != n->type)
		return(0);

	return(1);
@


1.47
log
@Replace the Berkeley-DB based mandocdb(8) by an SQLite3-based version,
aiming for more flexible development and optimization options.
Kristaps started this during the summer 2012, i did some very heavy
bugfixing during t2k13 and finally, during the last few days,
got it to a state where it is ripe for in-tree development.
Beware, neither the user interfaces nor the database formats
are expected to be stable just yet.

Will not be installed or activated until further discussion.
No functional change to mandoc(1).

"As long as it remains off until we decide the cost, fine." deraadt@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.46 2013/11/21 01:47:10 schwarze Exp $ */
a1728 1
		u = 0;
@


1.46
log
@My audit of mandoc revealed two missing (unsigned char) casts
in isspace() and tolower() arguments containing arbitrary char data.
Thanks to deraadt@@ for triggering the audit.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.45 2013/10/05 21:17:29 schwarze Exp $ */
d3 2
a4 2
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d18 1
a18 1
#include <sys/types.h>
a21 1
#include <dirent.h>
d24 1
d27 1
a32 1
#include <db.h>
d34 4
a38 1
#include "mdoc.h"
a39 1
#include "mandocdb.h"
d41 1
d43 18
a60 2
#define	MANDOC_BUFSZ	  BUFSIZ
#define	MANDOC_SLOP	  1024
d62 7
a68 2
#define	MANDOC_SRC	  0x1
#define	MANDOC_FORM	  0x2
d70 5
a74 1
/* Access to the mandoc database on disk. */
d76 5
a80 5
struct	mdb {
	char		  idxn[PATH_MAX]; /* index db filename */
	char		  dbn[PATH_MAX]; /* keyword db filename */
	DB		 *idx; /* index recno database */
	DB		 *db; /* keyword btree database */
d83 4
a86 1
/* Stack of temporarily unused index records. */
d88 8
a95 5
struct	recs {
	recno_t		 *stack; /* pointer to a malloc'ed array */
	size_t		  size; /* number of allocated slots */
	size_t		  cur; /* current number of empty records */
	recno_t		  last; /* last record number in the index */
d98 9
a106 10
/* Tiny list for files.  No need to bring in QUEUE. */

struct	of {
	char		 *fname; /* heap-allocated */
	char		 *sec;
	char		 *arch;
	char		 *title;
	int		  src_form;
	struct of	 *next; /* NULL for last one */
	struct of	 *first; /* first in list */
d109 3
a111 6
/* Buffer for storing growable data. */

struct	buf {
	char		 *cp;
	size_t		  len; /* current length */
	size_t		  size; /* total buffer size */
d114 6
a119 8
/* Operation we're going to perform. */

enum	op {
	OP_DEFAULT = 0, /* new dbs from dir list or default config */
	OP_CONFFILE, /* new databases from custom config file */
	OP_UPDATE, /* delete/add entries in existing database */
	OP_DELETE, /* delete entries from existing database */
	OP_TEST /* change no databases, report potential problems */
d122 1
a122 44
#define	MAN_ARGS	  DB *hash, \
			  struct buf *buf, \
			  struct buf *dbuf, \
			  const struct man_node *n
#define	MDOC_ARGS	  DB *hash, \
			  struct buf *buf, \
			  struct buf *dbuf, \
			  const struct mdoc_node *n, \
			  const struct mdoc_meta *m

static	void		  buf_appendmdoc(struct buf *, 
				const struct mdoc_node *, int);
static	void		  buf_append(struct buf *, const char *);
static	void		  buf_appendb(struct buf *, 
				const void *, size_t);
static	void		  dbt_put(DB *, const char *, DBT *, DBT *);
static	void		  hash_put(DB *, const struct buf *, uint64_t);
static	void		  hash_reset(DB **);
static	void		  index_merge(const struct of *, struct mparse *,
				struct buf *, struct buf *, DB *,
				struct mdb *, struct recs *);
static	void		  index_prune(const struct of *, struct mdb *,
				struct recs *);
static	void		  ofile_argbuild(int, char *[], struct of **,
				const char *);
static	void		  ofile_dirbuild(const char *, const char *,
				const char *, int, struct of **);
static	void		  ofile_free(struct of *);
static	void		  pformatted(DB *, struct buf *, 
				struct buf *, const struct of *);
static	int		  pman_node(MAN_ARGS);
static	void		  pmdoc_node(MDOC_ARGS);
static	int		  pmdoc_head(MDOC_ARGS);
static	int		  pmdoc_body(MDOC_ARGS);
static	int		  pmdoc_Fd(MDOC_ARGS);
static	int		  pmdoc_In(MDOC_ARGS);
static	int		  pmdoc_Fn(MDOC_ARGS);
static	int		  pmdoc_Nd(MDOC_ARGS);
static	int		  pmdoc_Nm(MDOC_ARGS);
static	int		  pmdoc_Sh(MDOC_ARGS);
static	int		  pmdoc_St(MDOC_ARGS);
static	int		  pmdoc_Xr(MDOC_ARGS);

#define	MDOCF_CHILD	  0x01  /* Automatically index child nodes. */
d125 2
a126 3
	int		(*fp)(MDOC_ARGS);  /* Optional handler. */
	uint64_t	  mask;  /* Set unless handler returns 0. */
	int		  flags;  /* For use by pmdoc_node. */
d129 52
d182 122
a303 122
	{ NULL, 0, 0 },  /* Ap */
	{ NULL, 0, 0 },  /* Dd */
	{ NULL, 0, 0 },  /* Dt */
	{ NULL, 0, 0 },  /* Os */
	{ pmdoc_Sh, TYPE_Sh, MDOCF_CHILD }, /* Sh */
	{ pmdoc_head, TYPE_Ss, MDOCF_CHILD }, /* Ss */
	{ NULL, 0, 0 },  /* Pp */
	{ NULL, 0, 0 },  /* D1 */
	{ NULL, 0, 0 },  /* Dl */
	{ NULL, 0, 0 },  /* Bd */
	{ NULL, 0, 0 },  /* Ed */
	{ NULL, 0, 0 },  /* Bl */
	{ NULL, 0, 0 },  /* El */
	{ NULL, 0, 0 },  /* It */
	{ NULL, 0, 0 },  /* Ad */
	{ NULL, TYPE_An, MDOCF_CHILD },  /* An */
	{ NULL, TYPE_Ar, MDOCF_CHILD },  /* Ar */
	{ NULL, TYPE_Cd, MDOCF_CHILD },  /* Cd */
	{ NULL, TYPE_Cm, MDOCF_CHILD },  /* Cm */
	{ NULL, TYPE_Dv, MDOCF_CHILD },  /* Dv */
	{ NULL, TYPE_Er, MDOCF_CHILD },  /* Er */
	{ NULL, TYPE_Ev, MDOCF_CHILD },  /* Ev */
	{ NULL, 0, 0 },  /* Ex */
	{ NULL, TYPE_Fa, MDOCF_CHILD },  /* Fa */
	{ pmdoc_Fd, TYPE_In, 0 },  /* Fd */
	{ NULL, TYPE_Fl, MDOCF_CHILD },  /* Fl */
	{ pmdoc_Fn, 0, 0 },  /* Fn */
	{ NULL, TYPE_Ft, MDOCF_CHILD },  /* Ft */
	{ NULL, TYPE_Ic, MDOCF_CHILD },  /* Ic */
	{ pmdoc_In, TYPE_In, 0 },  /* In */
	{ NULL, TYPE_Li, MDOCF_CHILD },  /* Li */
	{ pmdoc_Nd, TYPE_Nd, MDOCF_CHILD },  /* Nd */
	{ pmdoc_Nm, TYPE_Nm, MDOCF_CHILD },  /* Nm */
	{ NULL, 0, 0 },  /* Op */
	{ NULL, 0, 0 },  /* Ot */
	{ NULL, TYPE_Pa, MDOCF_CHILD },  /* Pa */
	{ NULL, 0, 0 },  /* Rv */
	{ pmdoc_St, TYPE_St, 0 },  /* St */
	{ NULL, TYPE_Va, MDOCF_CHILD },  /* Va */
	{ pmdoc_body, TYPE_Va, MDOCF_CHILD },  /* Vt */
	{ pmdoc_Xr, TYPE_Xr, 0 },  /* Xr */
	{ NULL, 0, 0 },  /* %A */
	{ NULL, 0, 0 },  /* %B */
	{ NULL, 0, 0 },  /* %D */
	{ NULL, 0, 0 },  /* %I */
	{ NULL, 0, 0 },  /* %J */
	{ NULL, 0, 0 },  /* %N */
	{ NULL, 0, 0 },  /* %O */
	{ NULL, 0, 0 },  /* %P */
	{ NULL, 0, 0 },  /* %R */
	{ NULL, 0, 0 },  /* %T */
	{ NULL, 0, 0 },  /* %V */
	{ NULL, 0, 0 },  /* Ac */
	{ NULL, 0, 0 },  /* Ao */
	{ NULL, 0, 0 },  /* Aq */
	{ NULL, TYPE_At, MDOCF_CHILD },  /* At */
	{ NULL, 0, 0 },  /* Bc */
	{ NULL, 0, 0 },  /* Bf */
	{ NULL, 0, 0 },  /* Bo */
	{ NULL, 0, 0 },  /* Bq */
	{ NULL, TYPE_Bsx, MDOCF_CHILD },  /* Bsx */
	{ NULL, TYPE_Bx, MDOCF_CHILD },  /* Bx */
	{ NULL, 0, 0 },  /* Db */
	{ NULL, 0, 0 },  /* Dc */
	{ NULL, 0, 0 },  /* Do */
	{ NULL, 0, 0 },  /* Dq */
	{ NULL, 0, 0 },  /* Ec */
	{ NULL, 0, 0 },  /* Ef */
	{ NULL, TYPE_Em, MDOCF_CHILD },  /* Em */
	{ NULL, 0, 0 },  /* Eo */
	{ NULL, TYPE_Fx, MDOCF_CHILD },  /* Fx */
	{ NULL, TYPE_Ms, MDOCF_CHILD },  /* Ms */
	{ NULL, 0, 0 },  /* No */
	{ NULL, 0, 0 },  /* Ns */
	{ NULL, TYPE_Nx, MDOCF_CHILD },  /* Nx */
	{ NULL, TYPE_Ox, MDOCF_CHILD },  /* Ox */
	{ NULL, 0, 0 },  /* Pc */
	{ NULL, 0, 0 },  /* Pf */
	{ NULL, 0, 0 },  /* Po */
	{ NULL, 0, 0 },  /* Pq */
	{ NULL, 0, 0 },  /* Qc */
	{ NULL, 0, 0 },  /* Ql */
	{ NULL, 0, 0 },  /* Qo */
	{ NULL, 0, 0 },  /* Qq */
	{ NULL, 0, 0 },  /* Re */
	{ NULL, 0, 0 },  /* Rs */
	{ NULL, 0, 0 },  /* Sc */
	{ NULL, 0, 0 },  /* So */
	{ NULL, 0, 0 },  /* Sq */
	{ NULL, 0, 0 },  /* Sm */
	{ NULL, 0, 0 },  /* Sx */
	{ NULL, TYPE_Sy, MDOCF_CHILD },  /* Sy */
	{ NULL, TYPE_Tn, MDOCF_CHILD },  /* Tn */
	{ NULL, 0, 0 },  /* Ux */
	{ NULL, 0, 0 },  /* Xc */
	{ NULL, 0, 0 },  /* Xo */
	{ pmdoc_head, TYPE_Fn, 0 },  /* Fo */
	{ NULL, 0, 0 },  /* Fc */
	{ NULL, 0, 0 },  /* Oo */
	{ NULL, 0, 0 },  /* Oc */
	{ NULL, 0, 0 },  /* Bk */
	{ NULL, 0, 0 },  /* Ek */
	{ NULL, 0, 0 },  /* Bt */
	{ NULL, 0, 0 },  /* Hf */
	{ NULL, 0, 0 },  /* Fr */
	{ NULL, 0, 0 },  /* Ud */
	{ NULL, TYPE_Lb, MDOCF_CHILD },  /* Lb */
	{ NULL, 0, 0 },  /* Lp */
	{ NULL, TYPE_Lk, MDOCF_CHILD },  /* Lk */
	{ NULL, TYPE_Mt, MDOCF_CHILD },  /* Mt */
	{ NULL, 0, 0 },  /* Brq */
	{ NULL, 0, 0 },  /* Bro */
	{ NULL, 0, 0 },  /* Brc */
	{ NULL, 0, 0 },  /* %C */
	{ NULL, 0, 0 },  /* Es */
	{ NULL, 0, 0 },  /* En */
	{ NULL, TYPE_Dx, MDOCF_CHILD },  /* Dx */
	{ NULL, 0, 0 },  /* %Q */
	{ NULL, 0, 0 },  /* br */
	{ NULL, 0, 0 },  /* sp */
	{ NULL, 0, 0 },  /* %U */
	{ NULL, 0, 0 },  /* Ta */
a305 5
static	const char	 *progname;
static	int		  use_all;  /* Use all directories and files. */
static	int		  verb;  /* Output verbosity level. */
static	int		  warnings;  /* Potential problems in manuals. */

d309 17
a325 17
	struct mparse	*mp; /* parse sequence */
	struct manpaths	 dirs;
	struct mdb	 mdb;
	struct recs	 recs;
	enum op		 op; /* current operation */
	const char	*dir;
	char		*cp;
	char		 pbuf[PATH_MAX];
	int		 ch, i, flags;
	DB		*hash; /* temporary keyword hashtable */
	BTREEINFO	 info; /* btree configuration */
	size_t		 sz1, sz2, ipath;
	struct buf	 buf, /* keyword buffer */
			 dbuf; /* description buffer */
	struct of	*of; /* list of files for processing */
	extern int	 optind;
	extern char	*optarg;
d333 10
a342 3
	memset(&dirs, 0, sizeof(struct manpaths));
	memset(&mdb, 0, sizeof(struct mdb));
	memset(&recs, 0, sizeof(struct recs));
d344 1
a344 3
	of = NULL;
	mp = NULL;
	hash = NULL;
a345 1
	dir = NULL;
d347 1
a347 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:tu:vW")))
d353 2
a354 6
			if (op) {
				fprintf(stderr,
				    "-C: conflicting options\n");
				goto usage;
			}
			dir = optarg;
d358 2
a359 6
			if (op) {
				fprintf(stderr,
				    "-d: conflicting options\n");
				goto usage;
			}
			dir = optarg;
d362 3
d366 1
a367 5
			if (op) {
				fprintf(stderr,
				    "-t: conflicting options\n");
				goto usage;
			}
d369 1
a369 2
			use_all = 1;
			warnings = 1;
d372 2
a373 6
			if (op) {
				fprintf(stderr,
				    "-u: conflicting options\n");
				goto usage;
			}
			dir = optarg;
d390 1
a390 1
		fprintf(stderr, "-C: too many arguments\n");
d394 4
a397 3
	memset(&info, 0, sizeof(BTREEINFO));
	info.lorder = 4321;
	info.flags = R_DUP;
d399 2
a400 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL, NULL);
d402 5
a406 2
	memset(&buf, 0, sizeof(struct buf));
	memset(&dbuf, 0, sizeof(struct buf));
d408 30
a437 1
	buf.size = dbuf.size = MANDOC_BUFSZ;
d439 12
a450 2
	buf.cp = mandoc_malloc(buf.size);
	dbuf.cp = mandoc_malloc(dbuf.size);
d452 4
a455 7
	if (OP_TEST == op) {
		ofile_argbuild(argc, argv, &of, NULL);
		if (NULL == of)
			goto out;
		index_merge(of, mp, &dbuf, &buf, hash, &mdb, &recs);
		goto out;
	}
d457 8
a464 9
	if (OP_UPDATE == op || OP_DELETE == op) {
		if (NULL == realpath(dir, pbuf)) {
			perror(dir);
			exit((int)MANDOCLEVEL_BADARG);
		}
		if (strlcat(pbuf, "/", PATH_MAX) >= PATH_MAX) {
			fprintf(stderr, "%s: path too long\n", pbuf);
			exit((int)MANDOCLEVEL_BADARG);
		}
d466 2
a467 2
		strlcat(mdb.dbn, pbuf, PATH_MAX);
		sz1 = strlcat(mdb.dbn, MANDOC_DB, PATH_MAX);
d469 5
a473 6
		strlcat(mdb.idxn, pbuf, PATH_MAX);
		sz2 = strlcat(mdb.idxn, MANDOC_IDX, PATH_MAX);

		if (sz1 >= PATH_MAX || sz2 >= PATH_MAX) {
			fprintf(stderr, "%s: path too long\n", mdb.idxn);
			exit((int)MANDOCLEVEL_BADARG);
d475 18
d494 2
a495 3
		flags = O_CREAT | O_RDWR;
		mdb.db = dbopen(mdb.dbn, flags, 0644, DB_BTREE, &info);
		mdb.idx = dbopen(mdb.idxn, flags, 0644, DB_RECNO, NULL);
d497 24
a520 7
		if (NULL == mdb.db) {
			perror(mdb.dbn);
			exit((int)MANDOCLEVEL_SYSERR);
		} else if (NULL == mdb.idx) {
			perror(mdb.idxn);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d522 2
a523 1
		ofile_argbuild(argc, argv, &of, pbuf);
d525 10
a534 2
		if (NULL == of)
			goto out;
d536 2
a537 1
		index_prune(of, &mdb, &recs);
d539 2
d542 2
a543 3
		 * Go to the root of the respective manual tree.
		 * This must work or no manuals may be found (they're
		 * indexed relative to the root).
d545 73
d619 6
a624 4
		if (OP_UPDATE == op) {
			if (-1 == chdir(dir)) {
				perror(dir);
				exit((int)MANDOCLEVEL_SYSERR);
d626 24
a649 2
			index_merge(of, mp, &dbuf, &buf, hash,
					&mdb, &recs);
d651 5
d657 43
a699 1
		goto out;
d701 3
d706 4
a709 3
	 * Configure the directories we're going to scan.
	 * If we have command-line arguments, use them.
	 * If not, we use man(1)'s method (see mandocdb.8).
d711 9
d721 5
a725 9
	if (argc > 0) {
		dirs.paths = mandoc_calloc(argc, sizeof(char *));
		dirs.sz = argc;
		for (i = 0; i < argc; i++) {
			if (NULL == (cp = realpath(argv[i], pbuf))) {
				perror(argv[i]);
				goto out;
			}
			dirs.paths[i] = mandoc_strdup(cp);
d727 1
a727 2
	} else
		manpath_parse(&dirs, dir, NULL, NULL);
d729 12
a740 1
	for (ipath = 0; ipath < dirs.sz; ipath++) {
d742 10
a751 5
		/*
		 * Go to the root of the respective manual tree.
		 * This must work or no manuals may be found:
		 * They are indexed relative to the root.
		 */
d753 2
a754 4
		if (-1 == chdir(dirs.paths[ipath])) {
			perror(dirs.paths[ipath]);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d756 26
a781 33
		/* Create a new database in two temporary files. */

		flags = O_CREAT | O_EXCL | O_RDWR;
		while (NULL == mdb.db) {
			strlcpy(mdb.dbn, MANDOC_DB, PATH_MAX);
			strlcat(mdb.dbn, ".XXXXXXXXXX", PATH_MAX);
			if (NULL == mktemp(mdb.dbn)) {
				perror(mdb.dbn);
				exit((int)MANDOCLEVEL_SYSERR);
			}
			mdb.db = dbopen(mdb.dbn, flags, 0644,
					DB_BTREE, &info);
			if (NULL == mdb.db && EEXIST != errno) {
				perror(mdb.dbn);
				exit((int)MANDOCLEVEL_SYSERR);
			}
		}
		while (NULL == mdb.idx) {
			strlcpy(mdb.idxn, MANDOC_IDX, PATH_MAX);
			strlcat(mdb.idxn, ".XXXXXXXXXX", PATH_MAX);
			if (NULL == mktemp(mdb.idxn)) {
				perror(mdb.idxn);
				unlink(mdb.dbn);
				exit((int)MANDOCLEVEL_SYSERR);
			}
			mdb.idx = dbopen(mdb.idxn, flags, 0644,
					DB_RECNO, NULL);
			if (NULL == mdb.idx && EEXIST != errno) {
				perror(mdb.idxn);
				unlink(mdb.dbn);
				exit((int)MANDOCLEVEL_SYSERR);
			}
		}
d783 18
a800 3
		/*
		 * Search for manuals and fill the new database.
		 */
d802 3
a804 1
	       	ofile_dirbuild(".", "", "", 0, &of);
d806 6
a811 6
		if (NULL != of) {
			index_merge(of, mp, &dbuf, &buf, hash,
			     &mdb, &recs);
			ofile_free(of);
			of = NULL;
		}
d813 21
a833 4
		(*mdb.db->close)(mdb.db);
		(*mdb.idx->close)(mdb.idx);
		mdb.db = NULL;
		mdb.idx = NULL;
d835 25
a859 18
		/*
		 * Replace the old database with the new one.
		 * This is not perfectly atomic,
		 * but i cannot think of a better way.
		 */

		if (-1 == rename(mdb.dbn, MANDOC_DB)) {
			perror(MANDOC_DB);
			unlink(mdb.dbn);
			unlink(mdb.idxn);
			exit((int)MANDOCLEVEL_SYSERR);
		}
		if (-1 == rename(mdb.idxn, MANDOC_IDX)) {
			perror(MANDOC_IDX);
			unlink(MANDOC_DB);
			unlink(MANDOC_IDX);
			unlink(mdb.idxn);
			exit((int)MANDOCLEVEL_SYSERR);
d861 18
d880 1
d882 42
a923 9
out:
	if (mdb.db)
		(*mdb.db->close)(mdb.db);
	if (mdb.idx)
		(*mdb.idx->close)(mdb.idx);
	if (hash)
		(*hash->close)(hash);
	if (mp)
		mparse_free(mp);
d925 5
a929 47
	manpath_free(&dirs);
	ofile_free(of);
	free(buf.cp);
	free(dbuf.cp);
	free(recs.stack);

	return(MANDOCLEVEL_OK);

usage:
	fprintf(stderr,
		"usage: %s [-avvv] [-C file] | dir ... | -t file ...\n"
		"                        -d dir [file ...] | "
		"-u dir [file ...]\n",
		progname);

	return((int)MANDOCLEVEL_BADARG);
}

void
index_merge(const struct of *of, struct mparse *mp,
		struct buf *dbuf, struct buf *buf, DB *hash,
		struct mdb *mdb, struct recs *recs)
{
	recno_t		 rec;
	int		 ch, skip;
	DBT		 key, val;
	DB		*files;  /* temporary file name table */
	struct mdoc	*mdoc;
	struct man	*man;
	const char	*fn, *msec, *march, *mtitle;
	char		*p;
	uint64_t	 mask;
	size_t		 sv;
	unsigned	 seq;
	uint64_t	 vbuf[2];
	char		 type;

	static char	 emptystring[] = "";

	if (warnings) {
		files = NULL;
		hash_reset(&files);
	}

	rec = 0;
	for (of = of->first; of; of = of->next) {
		fn = of->fname;
d936 6
a941 9

		mparse_reset(mp);
		mdoc = NULL;
		man = NULL;

		if ((MANDOC_SRC & of->src_form ||
		    ! (MANDOC_FORM & of->src_form)) &&
		    MANDOCLEVEL_FATAL > mparse_readfd(mp, -1, fn))
			mparse_result(mp, &mdoc, &man);
d944 8
a951 5
			msec = mdoc_meta(mdoc)->msec;
			march = mdoc_meta(mdoc)->arch;
			if (NULL == march)
				march = "";
			mtitle = mdoc_meta(mdoc)->title;
d953 7
a959 3
			msec = man_meta(man)->msec;
			march = "";
			mtitle = man_meta(man)->title;
d961 7
a967 3
			msec = of->sec;
			march = of->arch;
			mtitle = of->title;
d979 7
a985 10

		skip = 0;
		assert(of->sec);
		assert(msec);
		if (warnings)
			if (strcasecmp(msec, of->sec))
				fprintf(stderr, "%s: "
					"section \"%s\" manual "
					"in \"%s\" directory\n",
					fn, msec, of->sec);
d1001 10
d1012 1
a1012 8
		assert(of->arch);
		assert(march);
		if (warnings)
			if (strcasecmp(march, of->arch))
				fprintf(stderr, "%s: "
					"architecture \"%s\" manual "
					"in \"%s\" directory\n",
					fn, march, of->arch);
d1014 11
a1024 10
		/*
		 * By default, skip a file if the title given
		 * in the file disagrees with the file name.
		 * Do not warn, this happens for all MLINKs.
		 */

		assert(of->title);
		assert(mtitle);
		if (strcasecmp(mtitle, of->title))
			skip = 1;
d1032 7
a1038 8
		if (warnings) {
			buf->len = 0;
			buf_appendb(buf, mtitle, strlen(mtitle));
			buf_appendb(buf, "(", 1);
			buf_appendb(buf, msec, strlen(msec));
			if ('\0' != *march) {
				buf_appendb(buf, "/", 1);
				buf_appendb(buf, march, strlen(march));
d1040 14
a1053 24
			buf_appendb(buf, ")", 2);
			for (p = buf->cp; '\0' != *p; p++)
				*p = tolower((unsigned char)*p);
			key.data = buf->cp;
			key.size = buf->len;
			val.data = NULL;
			val.size = 0;
			if (0 == skip)
				val.data = emptystring;
			else {
				ch = (*files->get)(files, &key, &val, 0);
				if (ch < 0) {
					perror("hash");
					exit((int)MANDOCLEVEL_SYSERR);
				} else if (ch > 0) {
					val.data = (void *)fn;
					val.size = strlen(fn) + 1;
				} else
					val.data = NULL;
			}
			if (NULL != val.data &&
			    (*files->put)(files, &key, &val, 0) < 0) {
				perror("hash");
				exit((int)MANDOCLEVEL_SYSERR);
d1057 20
a1076 2
		if (skip && !use_all)
			continue;
d1078 6
a1083 9
		/*
		 * The index record value consists of a nil-terminated
		 * filename, a nil-terminated manual section, and a
		 * nil-terminated description.  Use the actual
		 * location of the file, such that the user can find
		 * it with man(1).  Since the description may not be
		 * set, we set a sentinel to see if we're going to
		 * write a nil byte in its place.
		 */
d1085 5
a1089 7
		dbuf->len = 0;
		type = mdoc ? 'd' : (man ? 'a' : 'c');
		buf_appendb(dbuf, &type, 1);
		buf_appendb(dbuf, fn, strlen(fn) + 1);
		buf_appendb(dbuf, of->sec, strlen(of->sec) + 1);
		buf_appendb(dbuf, of->title, strlen(of->title) + 1);
		buf_appendb(dbuf, of->arch, strlen(of->arch) + 1);
d1091 1
a1091 1
		sv = dbuf->len;
d1093 3
a1095 4
		/*
		 * Collect keyword/mask pairs.
		 * Each pair will become a new btree node.
		 */
d1097 4
a1100 8
		hash_reset(&hash);
		if (mdoc)
			pmdoc_node(hash, buf, dbuf,
				mdoc_node(mdoc), mdoc_meta(mdoc));
		else if (man)
			pman_node(hash, buf, dbuf, man_node(man));
		else
			pformatted(hash, buf, dbuf, of);
d1102 10
a1111 1
		/* Test mode, do not access any database. */
d1113 2
a1114 2
		if (NULL == mdb->db || NULL == mdb->idx)
			continue;
d1116 14
a1129 7
		/*
		 * Make sure the file name is always registered
		 * as an .Nm search key.
		 */
		buf->len = 0;
		buf_append(buf, of->title);
		hash_put(hash, buf, TYPE_Nm);
d1131 6
a1136 4
		/*
		 * Reclaim an empty index record, if available.
		 * Use its record number for all new btree nodes.
		 */
d1138 11
a1148 9
		if (recs->cur > 0) {
			recs->cur--;
			rec = recs->stack[(int)recs->cur];
		} else if (recs->last > 0) {
			rec = recs->last;
			recs->last = 0;
		} else
			rec++;
		vbuf[1] = htobe64(rec);
d1150 2
a1151 4
		/*
		 * Copy from the in-memory hashtable of pending
		 * keyword/mask pairs into the database.
		 */
d1153 5
a1157 16
		seq = R_FIRST;
		while (0 == (ch = (*hash->seq)(hash, &key, &val, seq))) {
			seq = R_NEXT;
			assert(sizeof(uint64_t) == val.size);
			memcpy(&mask, val.data, val.size);
			vbuf[0] = htobe64(mask);
			val.size = sizeof(vbuf);
			val.data = &vbuf;
			dbt_put(mdb->db, mdb->dbn, &key, &val);
		}
		if (ch < 0) {
			perror("hash");
			unlink(mdb->dbn);
			unlink(mdb->idxn);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d1159 9
a1167 4
		/*
		 * Apply to the index.  If we haven't had a description
		 * set, put an empty one in now.
		 */
d1169 1
a1169 2
		if (dbuf->len == sv)
			buf_appendb(dbuf, "", 1);
d1171 1
a1171 2
		key.data = &rec;
		key.size = sizeof(recno_t);
d1173 9
a1181 2
		val.data = dbuf->cp;
		val.size = dbuf->len;
d1183 6
a1188 2
		if (verb)
			printf("%s: adding to index\n", fn);
d1190 6
a1195 7
		dbt_put(mdb->idx, mdb->idxn, &key, &val);
	}

	/*
	 * Iterate the remembered file titles and check that
	 * all files can be found by their main title.
	 */
d1197 2
a1198 11
	if (warnings) {
		seq = R_FIRST;
		while (0 == (*files->seq)(files, &key, &val, seq)) {
			seq = R_NEXT;
			if (val.size)
				fprintf(stderr, "%s: probably "
				    "unreachable, title is %s\n",
				    (char *)val.data, (char *)key.data);
		}
		(*files->close)(files);
	}
d1202 1
a1202 4
 * Scan through all entries in the index file `idx' and prune those
 * entries in `ofile'.
 * Pruning consists of removing from `db', then invalidating the entry
 * in `idx' (zeroing its value size).
d1205 2
a1206 1
index_prune(const struct of *ofile, struct mdb *mdb, struct recs *recs)
a1207 13
	const struct of	*of;
	const char	*fn;
	uint64_t	 vbuf[2];
	unsigned	 seq, sseq;
	DBT		 key, val;
	int		 ch;

	recs->cur = 0;
	seq = R_FIRST;
	while (0 == (ch = (*mdb->idx->seq)(mdb->idx, &key, &val, seq))) {
		seq = R_NEXT;
		assert(sizeof(recno_t) == key.size);
		memcpy(&recs->last, key.data, key.size);
d1209 7
a1215 1
		/* Deleted records are zero-sized.  Skip them. */
d1217 7
a1223 2
		if (0 == val.size)
			goto cont;
d1225 2
a1226 6
		/*
		 * Make sure we're sane.
		 * Read past our mdoc/man/cat type to the next string,
		 * then make sure it's bounded by a NUL.
		 * Failing any of these, we go into our error handler.
		 */
d1228 6
a1233 3
		fn = (char *)val.data + 1;
		if (NULL == memchr(fn, '\0', val.size - 1))
			break;
d1235 10
a1244 4
		/*
		 * Search for the file in those we care about.
		 * XXX: build this into a tree.  Too slow.
		 */
d1246 2
a1247 3
		for (of = ofile->first; of; of = of->next)
			if (0 == strcmp(fn, of->fname))
				break;
d1249 6
a1254 2
		if (NULL == of)
			continue;
d1256 13
a1268 4
		/*
		 * Search through the keyword database, throwing out all
		 * references to our file.
		 */
d1270 2
a1271 6
		sseq = R_FIRST;
		while (0 == (ch = (*mdb->db->seq)(mdb->db,
					&key, &val, sseq))) {
			sseq = R_NEXT;
			if (sizeof(vbuf) != val.size)
				break;
d1273 1
a1273 3
			memcpy(vbuf, val.data, val.size);
			if (recs->last != betoh64(vbuf[1]))
				continue;
d1275 3
a1277 4
			if ((ch = (*mdb->db->del)(mdb->db,
					&key, R_CURSOR)) < 0)
				break;
		}
d1279 4
a1282 8
		if (ch < 0) {
			perror(mdb->dbn);
			exit((int)MANDOCLEVEL_SYSERR);
		} else if (1 != ch) {
			fprintf(stderr, "%s: corrupt database\n",
					mdb->dbn);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d1284 1
a1284 2
		if (verb)
			printf("%s: deleting from index\n", fn);
d1286 3
a1288 2
		val.size = 0;
		ch = (*mdb->idx->put)(mdb->idx, &key, &val, R_CURSOR);
d1290 4
a1293 8
		if (ch < 0)
			break;
cont:
		if (recs->cur >= recs->size) {
			recs->size += MANDOC_SLOP;
			recs->stack = mandoc_realloc(recs->stack,
					recs->size * sizeof(recno_t));
		}
d1295 1
a1295 3
		recs->stack[(int)recs->cur] = recs->last;
		recs->cur++;
	}
d1297 7
a1303 7
	if (ch < 0) {
		perror(mdb->idxn);
		exit((int)MANDOCLEVEL_SYSERR);
	} else if (1 != ch) {
		fprintf(stderr, "%s: corrupt index\n", mdb->idxn);
		exit((int)MANDOCLEVEL_SYSERR);
	}
d1305 4
a1308 2
	recs->last++;
}
d1310 2
a1311 6
/*
 * Grow the buffer (if necessary) and copy in a binary string.
 */
static void
buf_appendb(struct buf *buf, const void *cp, size_t sz)
{
d1313 1
a1313 1
	/* Overshoot by MANDOC_BUFSZ. */
d1315 4
a1318 4
	while (buf->len + sz >= buf->size) {
		buf->size = buf->len + sz + MANDOC_BUFSZ;
		buf->cp = mandoc_realloc(buf->cp, buf->size);
	}
d1320 5
a1324 3
	memcpy(buf->cp + (int)buf->len, cp, sz);
	buf->len += sz;
}
d1326 5
a1330 10
/*
 * Append a nil-terminated string to the buffer.  
 * This can be invoked multiple times.  
 * The buffer string will be nil-terminated.
 * If invoked multiple times, a space is put between strings.
 */
static void
buf_append(struct buf *buf, const char *cp)
{
	size_t		 sz;
d1332 2
a1333 2
	if (0 == (sz = strlen(cp)))
		return;
d1335 10
a1344 2
	if (buf->len)
		buf->cp[(int)buf->len - 1] = ' ';
d1346 2
a1347 2
	buf_appendb(buf, cp, sz + 1);
}
d1349 7
a1355 23
/*
 * Recursively add all text from a given node.  
 * This is optimised for general mdoc nodes in this context, which do
 * not consist of subexpressions and having a recursive call for n->next
 * would be wasteful.
 * The "f" variable should be 0 unless called from pmdoc_Nd for the
 * description buffer, which does not start at the beginning of the
 * buffer.
 */
static void
buf_appendmdoc(struct buf *buf, const struct mdoc_node *n, int f)
{

	for ( ; n; n = n->next) {
		if (n->child)
			buf_appendmdoc(buf, n->child, f);

		if (MDOC_TEXT == n->type && f) {
			f = 0;
			buf_appendb(buf, n->string, 
					strlen(n->string) + 1);
		} else if (MDOC_TEXT == n->type)
			buf_append(buf, n->string);
d1357 4
d1365 1
a1365 1
hash_reset(DB **db)
a1366 1
	DB		*hash;
d1368 25
a1392 7
	if (NULL != (hash = *db))
		(*hash->close)(hash);

	*db = dbopen(NULL, O_CREAT|O_RDWR, 0644, DB_HASH, NULL);
	if (NULL == *db) {
		perror("hash");
		exit((int)MANDOCLEVEL_SYSERR);
a1395 9
/* ARGSUSED */
static int
pmdoc_head(MDOC_ARGS)
{

	return(MDOC_HEAD == n->type);
}

/* ARGSUSED */
d1397 1
a1397 9
pmdoc_body(MDOC_ARGS)
{

	return(MDOC_BODY == n->type);
}

/* ARGSUSED */
static int
pmdoc_Fd(MDOC_ARGS)
d1402 3
a1404 3
	if (SEC_SYNOPSIS != n->sec)
		return(0);
	if (NULL == (n = n->child) || MDOC_TEXT != n->type)
d1411 1
d1434 2
a1435 4
	assert(end >= start);

	buf_appendb(buf, start, (size_t)(end - start + 1));
	buf_appendb(buf, "", 1);
a1438 1
/* ARGSUSED */
d1440 1
a1440 1
pmdoc_In(MDOC_ARGS)
d1443 1
a1443 1
	if (NULL == n->child || MDOC_TEXT != n->child->type)
d1446 1
a1446 1
	buf_append(buf, n->child->string);
a1449 1
/* ARGSUSED */
d1451 1
a1451 1
pmdoc_Fn(MDOC_ARGS)
a1452 1
	struct mdoc_node *nn;
d1455 1
a1455 3
	nn = n->child;

	if (NULL == nn || MDOC_TEXT != nn->type)
d1458 6
a1463 1
	/* .Fn "struct type *name" "char *arg" */
d1465 2
a1466 5
	cp = strrchr(nn->string, ' ');
	if (NULL == cp)
		cp = nn->string;

	/* Strip away pointer symbol. */
d1471 1
a1471 4
	/* Store the function name. */

	buf_append(buf, cp);
	hash_put(hash, buf, TYPE_Fn);
d1473 2
a1474 1
	/* Store the function type. */
d1476 3
a1478 16
	if (nn->string < cp) {
		buf->len = 0;
		buf_appendb(buf, nn->string, cp - nn->string);
		buf_appendb(buf, "", 1);
		hash_put(hash, buf, TYPE_Ft);
	}

	/* Store the arguments. */

	for (nn = nn->next; nn; nn = nn->next) {
		if (MDOC_TEXT != nn->type)
			continue;
		buf->len = 0;
		buf_append(buf, nn->string);
		hash_put(hash, buf, TYPE_Fa);
	}
a1482 1
/* ARGSUSED */
d1484 1
a1484 1
pmdoc_St(MDOC_ARGS)
d1490 1
a1490 1
	buf_append(buf, n->child->string);
a1493 1
/* ARGSUSED */
d1495 1
a1495 1
pmdoc_Xr(MDOC_ARGS)
d1497 1
d1502 4
a1505 1
	buf_appendb(buf, n->string, strlen(n->string));
d1507 7
a1513 7
	if (NULL != (n = n->next)) {
		buf_appendb(buf, ".", 1);
		buf_appendb(buf, n->string, strlen(n->string) + 1);
	} else
		buf_appendb(buf, ".", 2);

	return(1);
a1515 1
/* ARGSUSED */
d1517 1
a1517 1
pmdoc_Nd(MDOC_ARGS)
d1519 1
d1524 20
a1543 1
	buf_appendmdoc(dbuf, n->child, 1);
a1546 1
/* ARGSUSED */
d1548 1
a1548 1
pmdoc_Nm(MDOC_ARGS)
a1555 3
	if (NULL == n->child)
		buf_append(buf, m->name);

a1558 1
/* ARGSUSED */
d1560 1
a1560 1
pmdoc_Sh(MDOC_ARGS)
d1566 2
a1567 2
static void
hash_put(DB *db, const struct buf *buf, uint64_t mask)
a1568 3
	uint64_t	 oldmask;
	DBT		 key, val;
	int		 rc;
d1570 2
a1571 2
	if (buf->len < 2)
		return;
d1573 3
a1575 2
	key.data = buf->cp;
	key.size = buf->len;
d1577 1
a1577 16
	if ((rc = (*db->get)(db, &key, &val, 0)) < 0) {
		perror("hash");
		exit((int)MANDOCLEVEL_SYSERR);
	} else if (0 == rc) {
		assert(sizeof(uint64_t) == val.size);
		memcpy(&oldmask, val.data, val.size);
		mask |= oldmask;
	}

	val.data = &mask;
	val.size = sizeof(uint64_t); 

	if ((rc = (*db->put)(db, &key, &val, 0)) < 0) {
		perror("hash");
		exit((int)MANDOCLEVEL_SYSERR);
	} 
d1580 5
d1586 2
a1587 1
dbt_put(DB *db, const char *dbn, DBT *key, DBT *val)
d1589 3
d1593 6
a1598 2
	assert(key->size);
	assert(val->size);
d1600 2
a1601 1
	if (0 == (*db->put)(db, key, val, 0))
d1603 7
a1609 4
	
	perror(dbn);
	exit((int)MANDOCLEVEL_SYSERR);
	/* NOTREACHED */
d1613 4
a1616 2
 * Call out to per-macro handlers after clearing the persistent database
 * key.  If the macro sets the database key, flush it to the database.
d1618 2
a1619 2
static void
pmdoc_node(MDOC_ARGS)
d1621 1
d1623 36
a1658 40
	if (NULL == n)
		return;

	switch (n->type) {
	case (MDOC_HEAD):
		/* FALLTHROUGH */
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_TAIL):
		/* FALLTHROUGH */
	case (MDOC_BLOCK):
		/* FALLTHROUGH */
	case (MDOC_ELEM):
		buf->len = 0;

		/*
		 * Both NULL handlers and handlers returning true
		 * request using the data.  Only skip the element
		 * when the handler returns false.
		 */

		if (NULL != mdocs[n->tok].fp &&
		    0 == (*mdocs[n->tok].fp)(hash, buf, dbuf, n, m))
			break;

		/*
		 * For many macros, use the text from all children.
		 * Set zero flags for macros not needing this.
		 * In that case, the handler must fill the buffer.
		 */

		if (MDOCF_CHILD & mdocs[n->tok].flags)
			buf_appendmdoc(buf, n->child, 0);

		/*
		 * Cover the most common case:
		 * Automatically stage one string per element.
		 * Set a zero mask for macros not needing this.
		 * Additional staging can be done in the handler.
		 */
d1660 2
a1661 9
		if (mdocs[n->tok].mask)
			hash_put(hash, buf, mdocs[n->tok].mask);
		break;
	default:
		break;
	}

	pmdoc_node(hash, buf, dbuf, n->child, m);
	pmdoc_node(hash, buf, dbuf, n->next, m);
d1664 6
a1669 2
static int
pman_node(MAN_ARGS)
d1671 14
a1684 3
	const struct man_node *head, *body;
	char		*start, *sv, *title;
	size_t		 sz, titlesz;
d1686 2
a1687 2
	if (NULL == n)
		return(0);
d1690 2
a1691 4
	 * We're only searching for one thing: the first text child in
	 * the BODY of a NAME section.  Since we don't keep track of
	 * sections in -man, run some hoops to find out whether we're in
	 * the correct section or not.
d1693 4
d1698 1
a1698 32
	if (MAN_BODY == n->type && MAN_SH == n->tok) {
		body = n;
		assert(body->parent);
		if (NULL != (head = body->parent->head) &&
				1 == head->nchild &&
				NULL != (head = (head->child)) &&
				MAN_TEXT == head->type &&
				0 == strcmp(head->string, "NAME") &&
				NULL != (body = body->child) &&
				MAN_TEXT == body->type) {

			title = NULL;
			titlesz = 0;
			/*
			 * Suck the entire NAME section into memory.
			 * Yes, we might run away.
			 * But too many manuals have big, spread-out
			 * NAME sections over many lines.
			 */
			for ( ; NULL != body; body = body->next) {
				if (MAN_TEXT != body->type)
					break;
				if (0 == (sz = strlen(body->string)))
					continue;
				title = mandoc_realloc
					(title, titlesz + sz + 1);
				memcpy(title + titlesz, body->string, sz);
				titlesz += sz + 1;
				title[(int)titlesz - 1] = ' ';
			}
			if (NULL == title)
				return(0);
d1700 2
a1701 2
			title = mandoc_realloc(title, titlesz + 1);
			title[(int)titlesz] = '\0';
d1703 11
a1713 1
			/* Skip leading space.  */
d1715 10
a1724 3
			sv = title;
			while (isspace((unsigned char)*sv))
				sv++;
d1726 1
a1726 4
			if (0 == (sz = strlen(sv))) {
				free(title);
				return(0);
			}
d1728 2
a1729 1
			/* Erase trailing space. */
d1731 8
a1738 3
			start = &sv[sz - 1];
			while (start > sv && isspace((unsigned char)*start))
				*start-- = '\0';
d1740 4
a1743 4
			if (start == sv) {
				free(title);
				return(0);
			}
d1745 7
a1751 44
			start = sv;

			/* 
			 * Go through a special heuristic dance here.
			 * This is why -man manuals are great!
			 * (I'm being sarcastic: my eyes are bleeding.)
			 * Conventionally, one or more manual names are
			 * comma-specified prior to a whitespace, then a
			 * dash, then a description.  Try to puzzle out
			 * the name parts here.
			 */

			for ( ;; ) {
				sz = strcspn(start, " ,");
				if ('\0' == start[(int)sz])
					break;

				buf->len = 0;
				buf_appendb(buf, start, sz);
				buf_appendb(buf, "", 1);

				hash_put(hash, buf, TYPE_Nm);

				if (' ' == start[(int)sz]) {
					start += (int)sz + 1;
					break;
				}

				assert(',' == start[(int)sz]);
				start += (int)sz + 1;
				while (' ' == *start)
					start++;
			}

			buf->len = 0;

			if (sv == start) {
				buf_append(buf, start);
				free(title);
				return(1);
			}

			while (isspace((unsigned char)*start))
				start++;
d1753 1
a1753 10
			if (0 == strncmp(start, "-", 1))
				start += 1;
			else if (0 == strncmp(start, "\\-\\-", 4))
				start += 4;
			else if (0 == strncmp(start, "\\-", 2))
				start += 2;
			else if (0 == strncmp(start, "\\(en", 4))
				start += 4;
			else if (0 == strncmp(start, "\\(em", 4))
				start += 4;
d1755 2
a1756 2
			while (' ' == *start)
				start++;
d1758 1
a1758 3
			sz = strlen(start) + 1;
			buf_appendb(dbuf, start, sz);
			buf_appendb(buf, start, sz);
d1760 2
a1761 3
			hash_put(hash, buf, TYPE_Nd);
			free(title);
		}
d1764 2
a1765 5
	for (n = n->child; n; n = n->next)
		if (pman_node(hash, buf, dbuf, n))
			return(1);

	return(0);
d1769 4
a1772 2
 * Parse a formatted manual page.
 * By necessity, this involves rather crude guesswork.
d1775 1
a1775 2
pformatted(DB *hash, struct buf *buf, 
		struct buf *dbuf, const struct of *of)
d1777 9
a1785 3
	FILE		*stream;
	char		*line, *p, *title;
	size_t		 len, plen, titlesz;
d1787 1
a1787 3
	if (NULL == (stream = fopen(of->fname, "r"))) {
		if (warnings)
			perror(of->fname);
d1789 9
d1800 1
a1800 16
	/*
	 * Always use the title derived from the filename up front,
	 * do not even try to find it in the file.  This also makes
	 * sure we don't end up with an orphan index record, even if
	 * the file content turns out to be completely unintelligible.
	 */

	buf->len = 0;
	buf_append(buf, of->title);
	hash_put(hash, buf, TYPE_Nm);

	/* Skip to first blank line. */

	while (NULL != (line = fgetln(stream, &len)))
		if ('\n' == *line)
			break;
d1802 1
d1804 3
a1806 2
	 * Assume the first line that is not indented
	 * is the first section header.  Skip to it.
d1808 34
a1841 28

	while (NULL != (line = fgetln(stream, &len)))
		if ('\n' != *line && ' ' != *line)
			break;
	
	/*
	 * Read up until the next section into a buffer.
	 * Strip the leading and trailing newline from each read line,
	 * appending a trailing space.
	 * Ignore empty (whitespace-only) lines.
	 */

	titlesz = 0;
	title = NULL;

	while (NULL != (line = fgetln(stream, &len))) {
		if (' ' != *line || '\n' != line[(int)len - 1])
			break;
		while (len > 0 && isspace((unsigned char)*line)) {
			line++;
			len--;
		}
		if (1 == len)
			continue;
		title = mandoc_realloc(title, titlesz + len);
		memcpy(title + titlesz, line, len);
		titlesz += len;
		title[(int)titlesz - 1] = ' ';
d1844 2
d1847 7
a1853 6
	/*
	 * If no page content can be found, or the input line
	 * is already the next section header, or there is no
	 * trailing newline, reuse the page title as the page
	 * description.
	 */
d1855 1
a1855 8
	if (NULL == title || '\0' == *title) {
		if (warnings)
			fprintf(stderr, "%s: cannot find NAME section\n",
					of->fname);
		buf_appendb(dbuf, buf->cp, buf->size);
		hash_put(hash, buf, TYPE_Nd);
		fclose(stream);
		free(title);
d1857 11
d1869 1
d1871 8
a1878 2
	title = mandoc_realloc(title, titlesz + 1);
	title[(int)titlesz] = '\0';
d1880 2
a1881 5
	/*
	 * Skip to the first dash.
	 * Use the remaining line as the description (no more than 70
	 * bytes).
	 */
d1883 3
a1885 8
	if (NULL != (p = strstr(title, "- "))) {
		for (p += 2; ' ' == *p || '\b' == *p; p++)
			/* Skip to next word. */ ;
	} else {
		if (warnings)
			fprintf(stderr, "%s: no dash in title line\n",
					of->fname);
		p = title;
d1888 2
a1889 1
	plen = strlen(p);
d1891 2
a1892 1
	/* Strip backspace-encoding from line. */
d1894 3
a1896 8
	while (NULL != (line = memchr(p, '\b', plen))) {
		len = line - p;
		if (0 == len) {
			memmove(line, line + 1, plen--);
			continue;
		} 
		memmove(line - 1, line + 1, plen - len);
		plen -= 2;
a1897 7

	buf_appendb(dbuf, p, plen + 1);
	buf->len = 0;
	buf_appendb(buf, p, plen + 1);
	hash_put(hash, buf, TYPE_Nd);
	fclose(stream);
	free(title);
d1900 10
a1909 3
static void
ofile_argbuild(int argc, char *argv[], struct of **of,
		const char *basedir)
d1911 2
a1912 21
	char		 buf[PATH_MAX];
	char		 pbuf[PATH_MAX];
	const char	*sec, *arch, *title;
	char		*relpath, *p;
	int		 i, src_form;
	struct of	*nof;

	for (i = 0; i < argc; i++) {
		if (NULL == (relpath = realpath(argv[i], pbuf))) {
			perror(argv[i]);
			continue;
		}
		if (NULL != basedir) {
			if (strstr(pbuf, basedir) != pbuf) {
				fprintf(stderr, "%s: file outside "
				    "base directory %s\n",
				    pbuf, basedir);
				continue;
			}
			relpath = pbuf + strlen(basedir);
		}
d1914 2
a1915 6
		/*
		 * Try to infer the manual section, architecture and
		 * page title from the path, assuming it looks like
		 *   man*[/<arch>]/<title>.<section>   or
		 *   cat<section>[/<arch>]/<title>.0
		 */
d1917 7
a1923 39
		if (strlcpy(buf, relpath, sizeof(buf)) >= sizeof(buf)) {
			fprintf(stderr, "%s: path too long\n", relpath);
			continue;
		}
		sec = arch = title = "";
		src_form = 0;
		p = strrchr(buf, '\0');
		while (p-- > buf) {
			if ('\0' == *sec && '.' == *p) {
				sec = p + 1;
				*p = '\0';
				if ('0' == *sec)
					src_form |= MANDOC_FORM;
				else if ('1' <= *sec && '9' >= *sec)
					src_form |= MANDOC_SRC;
				continue;
			}
			if ('/' != *p)
				continue;
			if ('\0' == *title) {
				title = p + 1;
				*p = '\0';
				continue;
			}
			if (0 == strncmp("man", p + 1, 3))
				src_form |= MANDOC_SRC;
			else if (0 == strncmp("cat", p + 1, 3))
				src_form |= MANDOC_FORM;
			else
				arch = p + 1;
			break;
		}
		if ('\0' == *title) {
			if (warnings)
				fprintf(stderr,
				    "%s: cannot deduce title "
				    "from filename\n",
				    relpath);
			title = buf;
d1925 3
d1929 8
a1936 3
		/*
		 * Build the file structure.
		 */
d1938 2
a1939 6
		nof = mandoc_calloc(1, sizeof(struct of));
		nof->fname = mandoc_strdup(relpath);
		nof->sec = mandoc_strdup(sec);
		nof->arch = mandoc_strdup(arch);
		nof->title = mandoc_strdup(title);
		nof->src_form = src_form;
d1941 4
a1944 14
		/*
		 * Add the structure to the list.
		 */

		if (verb > 1)
			printf("%s: scheduling\n", relpath);
		if (NULL == *of) {
			*of = nof;
			(*of)->first = nof;
		} else {
			nof->first = (*of)->first;
			(*of)->next = nof;
			*of = nof;
		}
a1945 1
}
d1947 38
a1984 25
/*
 * Recursively build up a list of files to parse.
 * We use this instead of ftw() and so on because I don't want global
 * variables hanging around.
 * This ignores the mandoc.db and mandoc.index files, but assumes that
 * everything else is a manual.
 * Pass in a pointer to a NULL structure for the first invocation.
 */
static void
ofile_dirbuild(const char *dir, const char* psec, const char *parch,
		int p_src_form, struct of **of)
{
	char		 buf[PATH_MAX];
	size_t		 sz;
	DIR		*d;
	const char	*fn, *sec, *arch;
	char		*p, *q, *suffix;
	struct of	*nof;
	struct dirent	*dp;
	int		 src_form;

	if (NULL == (d = opendir(dir))) {
		if (warnings)
			perror(dir);
		return;
d1987 13
a1999 2
	while (NULL != (dp = readdir(d))) {
		fn = dp->d_name;
d2001 4
a2004 2
		if ('.' == *fn)
			continue;
d2006 2
a2007 1
		src_form = p_src_form;
d2009 2
a2010 3
		if (DT_DIR == dp->d_type) {
			sec = psec;
			arch = parch;
d2012 3
a2014 5
			/*
			 * By default, only use directories called:
			 *   man<section>/[<arch>/]   or
			 *   cat<section>/[<arch>/]
			 */
d2016 2
a2017 31
			if ('\0' == *sec) {
				if(0 == strncmp("man", fn, 3)) {
					src_form |= MANDOC_SRC;
					sec = fn + 3;
				} else if (0 == strncmp("cat", fn, 3)) {
					src_form |= MANDOC_FORM;
					sec = fn + 3;
				} else {
					if (warnings) fprintf(stderr,
					    "%s/%s: bad section\n",
					    dir, fn);
					if (use_all)
						sec = fn;
					else
						continue;
				}
			} else if ('\0' == *arch) {
				if (NULL != strchr(fn, '.')) {
					if (warnings) fprintf(stderr,
					    "%s/%s: bad architecture\n",
					    dir, fn);
					if (0 == use_all)
						continue;
				}
				arch = fn;
			} else {
				if (warnings) fprintf(stderr, "%s/%s: "
				    "excessive subdirectory\n", dir, fn);
				if (0 == use_all)
					continue;
			}
d2019 3
a2021 10
			buf[0] = '\0';
			strlcat(buf, dir, PATH_MAX);
			strlcat(buf, "/", PATH_MAX);
			sz = strlcat(buf, fn, PATH_MAX);

			if (PATH_MAX <= sz) {
				if (warnings) fprintf(stderr, "%s/%s: "
				    "path too long\n", dir, fn);
				continue;
			}
d2023 2
a2024 2
			if (verb > 1)
				printf("%s: scanning\n", buf);
d2026 3
a2028 3
			ofile_dirbuild(buf, sec, arch, src_form, of);
			continue;
		}
d2030 2
a2031 17
		if (DT_REG != dp->d_type) {
			if (warnings)
				fprintf(stderr,
				    "%s/%s: not a regular file\n",
				    dir, fn);
			continue;
		}
		if (!strcmp(MANDOC_DB, fn) || !strcmp(MANDOC_IDX, fn))
			continue;
		if ('\0' == *psec) {
			if (warnings)
				fprintf(stderr,
				    "%s/%s: file outside section\n",
				    dir, fn);
			if (0 == use_all)
				continue;
		}
d2033 5
a2037 5
		/*
		 * By default, skip files where the file name suffix
		 * does not agree with the section directory
		 * they are located in.
		 */
d2039 17
a2055 22
		suffix = strrchr(fn, '.');
		if (NULL == suffix) {
			if (warnings)
				fprintf(stderr,
				    "%s/%s: no filename suffix\n",
				    dir, fn);
			if (0 == use_all)
				continue;
		} else if ((MANDOC_SRC & src_form &&
				strcmp(suffix + 1, psec)) ||
			    (MANDOC_FORM & src_form &&
				strcmp(suffix + 1, "0"))) {
			if (warnings)
				fprintf(stderr,
				    "%s/%s: wrong filename suffix\n",
				    dir, fn);
			if (0 == use_all)
				continue;
			if ('0' == suffix[1])
				src_form |= MANDOC_FORM;
			else if ('1' <= suffix[1] && '9' >= suffix[1])
				src_form |= MANDOC_SRC;
d2057 11
a2067 44

		/*
		 * Skip formatted manuals if a source version is
		 * available.  Ignore the age: it is very unlikely
		 * that people install newer formatted base manuals
		 * when they used to have source manuals before,
		 * and in ports, old manuals get removed on update.
		 */
		if (0 == use_all && MANDOC_FORM & src_form &&
				'\0' != *psec) {
			buf[0] = '\0';
			strlcat(buf, dir, PATH_MAX);
			p = strrchr(buf, '/');
			if ('\0' != *parch && NULL != p)
				for (p--; p > buf; p--)
					if ('/' == *p)
						break;
			if (NULL == p)
				p = buf;
			else
				p++;
			if (0 == strncmp("cat", p, 3))
				memcpy(p, "man", 3);
			strlcat(buf, "/", PATH_MAX);
			sz = strlcat(buf, fn, PATH_MAX);
			if (sz >= PATH_MAX) {
				if (warnings) fprintf(stderr,
				    "%s/%s: path too long\n",
				    dir, fn);
				continue;
			}
			q = strrchr(buf, '.');
			if (NULL != q && p < q++) {
				*q = '\0';
				sz = strlcat(buf, psec, PATH_MAX);
				if (sz >= PATH_MAX) {
					if (warnings) fprintf(stderr,
					    "%s/%s: path too long\n",
					    dir, fn);
					continue;
				}
				if (0 == access(buf, R_OK))
					continue;
			}
d2069 3
a2071 43

		buf[0] = '\0';
		assert('.' == dir[0]);
		if ('/' == dir[1]) {
			strlcat(buf, dir + 2, PATH_MAX);
			strlcat(buf, "/", PATH_MAX);
		}
		sz = strlcat(buf, fn, PATH_MAX);
		if (sz >= PATH_MAX) {
			if (warnings) fprintf(stderr,
			    "%s/%s: path too long\n", dir, fn);
			continue;
		}

		nof = mandoc_calloc(1, sizeof(struct of));
		nof->fname = mandoc_strdup(buf);
		nof->sec = mandoc_strdup(psec);
		nof->arch = mandoc_strdup(parch);
		nof->src_form = src_form;

		/*
		 * Remember the file name without the extension,
		 * to be used as the page title in the database.
		 */

		if (NULL != suffix)
			*suffix = '\0';
		nof->title = mandoc_strdup(fn);

		/*
		 * Add the structure to the list.
		 */

		if (verb > 1)
			printf("%s: scheduling\n", buf);

		if (NULL == *of) {
			*of = nof;
			(*of)->first = nof;
		} else {
			nof->first = (*of)->first;
			(*of)->next = nof;
			*of = nof;
d2074 11
a2084 2

	closedir(d);
d2088 1
a2088 1
ofile_free(struct of *of)
d2090 1
a2090 1
	struct of	*nof;
d2092 7
a2098 2
	if (NULL != of)
		of = of->first;
d2100 3
a2102 8
	while (NULL != of) {
		nof = of->next;
		free(of->fname);
		free(of->sec);
		free(of->arch);
		free(of->title);
		free(of);
		of = nof;
d2104 6
@


1.45
log
@Cleanup suggested by gcc-4.8.1, following hints by Christos Zoulas:
- avoid bad qualifier casting in roff.c, roff_parsetext()
  by changing the mandoc_escape arguments to "const char const **"
- avoid bad qualifier casting in mandocdb.c, index_merge()
- garbage collect a few unused variables elsewhere
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.44 2013/06/05 02:02:53 schwarze Exp $ */
d719 1
a719 1
				*p = tolower(*p);
@


1.44
log
@Some places used PATH_MAX from <limits.h>, some MAXPATHLEN from <sys/param.h>.
Consistently use the PATH_MAX since it is specified by POSIX,
while MAXPATHLEN is not.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.43 2013/05/29 23:15:11 schwarze Exp $ */
d605 2
d725 1
a725 1
				val.data = "";
@


1.43
log
@Trivial sync to bsd.lv:
Kristaps changed the size member of struct manpaths from int to size_t.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.42 2012/05/24 23:33:23 schwarze Exp $ */
a17 1
#include <sys/param.h>
d26 1
d49 2
a50 2
	char		  idxn[MAXPATHLEN]; /* index db filename */
	char		  dbn[MAXPATHLEN]; /* keyword db filename */
d405 2
a406 2
		strlcat(mdb.dbn, pbuf, MAXPATHLEN);
		sz1 = strlcat(mdb.dbn, MANDOC_DB, MAXPATHLEN);
d408 2
a409 2
		strlcat(mdb.idxn, pbuf, MAXPATHLEN);
		sz2 = strlcat(mdb.idxn, MANDOC_IDX, MAXPATHLEN);
d411 1
a411 1
		if (sz1 >= MAXPATHLEN || sz2 >= MAXPATHLEN) {
d489 2
a490 2
			strlcpy(mdb.dbn, MANDOC_DB, MAXPATHLEN);
			strlcat(mdb.dbn, ".XXXXXXXXXX", MAXPATHLEN);
d503 2
a504 2
			strlcpy(mdb.idxn, MANDOC_IDX, MAXPATHLEN);
			strlcat(mdb.idxn, ".XXXXXXXXXX", MAXPATHLEN);
d1637 1
a1637 1
	char		 buf[MAXPATHLEN];
d1747 1
a1747 1
	char		 buf[MAXPATHLEN];
d1813 3
a1815 3
			strlcat(buf, dir, MAXPATHLEN);
			strlcat(buf, "/", MAXPATHLEN);
			sz = strlcat(buf, fn, MAXPATHLEN);
d1817 1
a1817 1
			if (MAXPATHLEN <= sz) {
d1888 1
a1888 1
			strlcat(buf, dir, MAXPATHLEN);
d1900 3
a1902 3
			strlcat(buf, "/", MAXPATHLEN);
			sz = strlcat(buf, fn, MAXPATHLEN);
			if (sz >= MAXPATHLEN) {
d1911 2
a1912 2
				sz = strlcat(buf, psec, MAXPATHLEN);
				if (sz >= MAXPATHLEN) {
d1926 2
a1927 2
			strlcat(buf, dir + 2, MAXPATHLEN);
			strlcat(buf, "/", MAXPATHLEN);
d1929 2
a1930 2
		sz = strlcat(buf, fn, MAXPATHLEN);
		if (sz >= MAXPATHLEN) {
@


1.42
log
@Support -Ios='OpenBSD 5.1' to override uname(3) as the source of the
default value for the mdoc(7) .Os macro.
Needed for man.cgi on the OpenBSD website.

Problem with man.cgi first noticed by deraadt@@;
beck@@ and deraadt@@ agree with the way to solve the issue.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.41 2012/04/18 01:41:41 deraadt Exp $ */
d289 1
a289 1
	size_t		 sz1, sz2;
d472 1
a472 1
	for (i = 0; i < dirs.sz; i++) {
d480 2
a481 2
		if (-1 == chdir(dirs.paths[i])) {
			perror(dirs.paths[i]);
@


1.41
log
@backout non-portable code
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.39 2012/04/15 11:14:38 schwarze Exp $ */
d377 1
a377 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL);
@


1.40
log
@Clean up code a bit by pushing warnings into a WARNING macro; from kristaps@@.

This also backs out the realpath(3) changes for now; according to
Kristaps, they caused regressions.
@
text
@a45 9
#define WARNING(_f, _b, _fmt, _args...) \
	do if (warnings) { \
		fprintf(stderr, "%s: ", (_b)); \
		fprintf(stderr, (_fmt), ##_args); \
		if ('\0' != *(_f)) \
			fprintf(stderr, ": %s", (_f)); \
		fprintf(stderr, "\n"); \
	} while (/* CONSTCOND */ 0)
		
d114 4
a117 1
				struct mdb *, struct recs *,
a118 4
static	void		  index_prune(const struct of *, struct mdb *,
				struct recs *, const char *);
static	void		  ofile_argbuild(int, char *[],
				struct of **, const char *);
d120 1
a120 1
				const char *, int, struct of **, char *);
d122 2
a123 2
static	void		  pformatted(DB *, struct buf *, struct buf *,
				const struct of *, const char *);
d284 2
a286 1
	char		 dirbuf[MAXPATHLEN];
d388 1
a388 1
		ofile_argbuild(argc, argv, &of, ".");
d391 1
a391 2
		index_merge(of, mp, &dbuf, &buf,
				hash, &mdb, &recs, ".");
d396 10
a405 2
		strlcat(mdb.dbn, dir, MAXPATHLEN);
		strlcat(mdb.dbn, "/", MAXPATHLEN);
d408 1
a408 2
		strlcat(mdb.idxn, dir, MAXPATHLEN);
		strlcat(mdb.idxn, "/", MAXPATHLEN);
d412 1
a412 1
			fprintf(stderr, "%s: path too long\n", dir);
d428 1
a428 1
		ofile_argbuild(argc, argv, &of, dir);
d433 1
a433 1
		index_prune(of, &mdb, &recs, dir);
d447 1
a447 1
					&mdb, &recs, dir);
d462 7
a468 2
		for (i = 0; i < argc; i++) 
			dirs.paths[i] = mandoc_strdup(argv[i]);
d473 1
d523 1
a523 2
		strlcpy(dirbuf, dirs.paths[i], MAXPATHLEN);
	       	ofile_dirbuild(".", "", "", 0, &of, dirbuf);
d527 1
a527 1
			     &mdb, &recs, dirs.paths[i]);
d578 1
a578 1
		"usage: %s [-av] [-C file] | dir ... | -t file ...\n"
d589 1
a589 2
		struct mdb *mdb, struct recs *recs,
		const char *basedir)
a594 1
	char	 	 emptystring[1] = {'\0'};
d597 1
a598 1
	const char	*fn, *msec, *march, *mtitle;
d658 7
a664 3
		if (strcasecmp(msec, of->sec))
			WARNING(fn, basedir, "Section \"%s\" manual "
				"in \"%s\" directory", msec, of->sec);
d682 6
a687 4
		if (strcasecmp(march, of->arch))
			WARNING(fn, basedir, "Architecture \"%s\" "
				"manual in \"%s\" directory",
				march, of->arch);
d723 1
a723 1
				val.data = emptystring;
d777 1
a777 1
			pformatted(hash, buf, dbuf, of, basedir);
d824 2
d844 1
a844 1
			printf("%s: Adding to index: %s\n", basedir, fn);
d859 3
a861 3
				WARNING((char *)val.data, basedir,
					"Probably unreachable, title "
					"is %s", (char *)key.data);
d874 1
a874 2
index_prune(const struct of *ofile, struct mdb *mdb,
		struct recs *recs, const char *basedir)
d949 1
a949 2
			printf("%s: Deleting from index: %s\n",
					basedir, fn);
d1509 2
a1510 2
pformatted(DB *hash, struct buf *buf, struct buf *dbuf, 
		const struct of *of, const char *basedir)
d1517 2
a1518 1
		WARNING(of->fname, basedir, "%s", strerror(errno));
d1573 1
d1582 3
a1584 2
		WARNING(of->fname, basedir, 
			"Cannot find NAME section");
d1605 3
a1607 2
		WARNING(of->fname, basedir, 
			"No dash in title line");
d1634 2
a1635 2
ofile_argbuild(int argc, char *argv[], 
		struct of **of, const char *basedir)
d1638 1
d1640 1
a1640 1
	char		*p;
d1645 13
d1666 2
a1667 2
		if (strlcpy(buf, argv[i], sizeof(buf)) >= sizeof(buf)) {
			fprintf(stderr, "%s: Path too long\n", argv[i]);
d1699 5
a1703 2
			WARNING(argv[i], basedir, 
				"Cannot deduce title from filename");
d1712 1
a1712 1
		nof->fname = mandoc_strdup(argv[i]);
d1723 1
a1723 2
			printf("%s: scheduling\n", argv[i]);

d1745 1
a1745 1
		int p_src_form, struct of **of, char *basedir)
d1757 2
a1758 1
		WARNING("", dir, "%s", strerror(errno));
d1788 3
a1790 1
					WARNING(fn, basedir, "Bad section");
d1798 3
a1800 1
					WARNING(fn, basedir, "Bad architecture");
d1806 2
a1807 1
				WARNING(fn, basedir, "Excessive subdirectory");
a1814 2
			strlcat(basedir, "/", MAXPATHLEN);
			strlcat(basedir, fn, MAXPATHLEN);
d1818 2
a1819 1
				WARNING(fn, basedir, "Path too long");
d1826 1
a1826 5
			ofile_dirbuild(buf, sec, arch,
					src_form, of, basedir);

			p = strrchr(basedir, '/');
			*p = '\0';
d1831 4
a1834 1
			WARNING(fn, basedir, "Not a regular file");
d1840 4
a1843 1
			WARNING(fn, basedir, "File outside section");
d1856 4
a1859 1
			WARNING(fn, basedir, "No filename suffix");
d1866 4
a1869 1
			WARNING(fn, basedir, "Wrong filename suffix");
d1903 3
a1905 1
				WARNING(fn, basedir, "Path too long");
d1913 3
a1915 1
					WARNING(fn, basedir, "Path too long");
d1931 2
a1932 1
			WARNING(fn, basedir, "Path too long");
@


1.39
log
@Handle multi-line NAME sections in man(7); from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.38 2012/01/15 16:31:05 schwarze Exp $ */
d46 9
d123 2
a124 1
				struct mdb *, struct recs *);
d126 3
a128 3
				struct recs *);
static	void		  ofile_argbuild(int, char *[], struct of **,
				const char *);
d130 1
a130 1
				const char *, int, struct of **);
d132 2
a133 2
static	void		  pformatted(DB *, struct buf *, 
				struct buf *, const struct of *);
a293 2
	char		*cp;
	char		 pbuf[PATH_MAX];
d295 1
d397 1
a397 1
		ofile_argbuild(argc, argv, &of, NULL);
d400 2
a401 1
		index_merge(of, mp, &dbuf, &buf, hash, &mdb, &recs);
d406 2
a407 10
		if (NULL == realpath(dir, pbuf)) {
			perror(dir);
			exit((int)MANDOCLEVEL_BADARG);
		}
		if (strlcat(pbuf, "/", PATH_MAX) >= PATH_MAX) {
			fprintf(stderr, "%s: path too long\n", pbuf);
			exit((int)MANDOCLEVEL_BADARG);
		}

		strlcat(mdb.dbn, pbuf, MAXPATHLEN);
d410 2
a411 1
		strlcat(mdb.idxn, pbuf, MAXPATHLEN);
d415 1
a415 1
			fprintf(stderr, "%s: path too long\n", mdb.idxn);
d431 1
a431 1
		ofile_argbuild(argc, argv, &of, pbuf);
d436 1
a436 1
		index_prune(of, &mdb, &recs);
d450 1
a450 1
					&mdb, &recs);
d465 2
a466 7
		for (i = 0; i < argc; i++) {
			if (NULL == (cp = realpath(argv[i], pbuf))) {
				perror(argv[i]);
				goto out;
			}
			dirs.paths[i] = mandoc_strdup(cp);
		}
a470 1

d520 2
a521 1
	       	ofile_dirbuild(".", "", "", 0, &of);
d525 1
a525 1
			     &mdb, &recs);
d576 1
a576 1
		"usage: %s [-avvv] [-C file] | dir ... | -t file ...\n"
d587 2
a588 1
		struct mdb *mdb, struct recs *recs)
d594 1
d597 1
a598 1
	char		*p;
d658 3
a660 7
		if (warnings)
			if (strcasecmp(msec, of->sec))
				fprintf(stderr, "%s: "
					"section \"%s\" manual "
					"in \"%s\" directory\n",
					fn, msec, of->sec);

d678 4
a681 6
		if (warnings)
			if (strcasecmp(march, of->arch))
				fprintf(stderr, "%s: "
					"architecture \"%s\" manual "
					"in \"%s\" directory\n",
					fn, march, of->arch);
d717 1
a717 1
				val.data = "";
d771 1
a771 1
			pformatted(hash, buf, dbuf, of);
a817 2
			unlink(mdb->dbn);
			unlink(mdb->idxn);
d836 1
a836 1
			printf("%s: adding to index\n", fn);
d851 3
a853 3
				fprintf(stderr, "%s: probably "
				    "unreachable, title is %s\n",
				    (char *)val.data, (char *)key.data);
d866 2
a867 1
index_prune(const struct of *ofile, struct mdb *mdb, struct recs *recs)
d942 2
a943 1
			printf("%s: deleting from index\n", fn);
d1503 2
a1504 2
pformatted(DB *hash, struct buf *buf, 
		struct buf *dbuf, const struct of *of)
d1511 1
a1511 2
		if (warnings)
			perror(of->fname);
a1565 1

d1574 2
a1575 3
		if (warnings)
			fprintf(stderr, "%s: cannot find NAME section\n",
					of->fname);
d1596 2
a1597 3
		if (warnings)
			fprintf(stderr, "%s: no dash in title line\n",
					of->fname);
d1624 2
a1625 2
ofile_argbuild(int argc, char *argv[], struct of **of,
		const char *basedir)
a1627 1
	char		 pbuf[PATH_MAX];
d1629 1
a1629 1
	char		*relpath, *p;
a1633 13
		if (NULL == (relpath = realpath(argv[i], pbuf))) {
			perror(argv[i]);
			continue;
		}
		if (NULL != basedir) {
			if (strstr(pbuf, basedir) != pbuf) {
				fprintf(stderr, "%s: file outside "
				    "base directory %s\n",
				    pbuf, basedir);
				continue;
			}
			relpath = pbuf + strlen(basedir);
		}
d1642 2
a1643 2
		if (strlcpy(buf, relpath, sizeof(buf)) >= sizeof(buf)) {
			fprintf(stderr, "%s: path too long\n", relpath);
d1675 2
a1676 5
			if (warnings)
				fprintf(stderr,
				    "%s: cannot deduce title "
				    "from filename\n",
				    relpath);
d1685 1
a1685 1
		nof->fname = mandoc_strdup(relpath);
d1696 2
a1697 1
			printf("%s: scheduling\n", relpath);
d1719 1
a1719 1
		int p_src_form, struct of **of)
d1731 1
a1731 2
		if (warnings)
			perror(dir);
d1761 1
a1761 3
					if (warnings) fprintf(stderr,
					    "%s/%s: bad section\n",
					    dir, fn);
d1769 1
a1769 3
					if (warnings) fprintf(stderr,
					    "%s/%s: bad architecture\n",
					    dir, fn);
d1775 1
a1775 2
				if (warnings) fprintf(stderr, "%s/%s: "
				    "excessive subdirectory\n", dir, fn);
d1783 2
d1788 1
a1788 2
				if (warnings) fprintf(stderr, "%s/%s: "
				    "path too long\n", dir, fn);
d1795 5
a1799 1
			ofile_dirbuild(buf, sec, arch, src_form, of);
d1804 1
a1804 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: not a regular file\n",
				    dir, fn);
d1810 1
a1810 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: file outside section\n",
				    dir, fn);
d1823 1
a1823 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: no filename suffix\n",
				    dir, fn);
d1830 1
a1830 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: wrong filename suffix\n",
				    dir, fn);
d1864 1
a1864 3
				if (warnings) fprintf(stderr,
				    "%s/%s: path too long\n",
				    dir, fn);
d1872 1
a1872 3
					if (warnings) fprintf(stderr,
					    "%s/%s: path too long\n",
					    dir, fn);
d1888 1
a1888 2
			if (warnings) fprintf(stderr,
			    "%s/%s: path too long\n", dir, fn);
@


1.38
log
@Two details improving the quality of the Xenocara mandoc database,
also helping a bit in ports land:
1) Do not skip manuals for section mismatches;
use the section where the file is actually located.
2) Always use the file name as an .Nm search key.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.37 2012/01/09 23:21:47 schwarze Exp $ */
d1358 2
a1359 2
	const char	*start, *sv;
	size_t		 sz;
d1382 48
a1429 2
			assert(body->string);
			start = sv = body->string;
d1467 1
d1471 1
a1471 1
			while (' ' == *start)
d1493 1
@


1.37
log
@Stop -W from complaining about MLINKs; only warn when a file
seems inaccessible by its main title.

This reduces the number of warnings in base to about 140,
which is already low enough to find a couple of actual problems
among the noise.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.36 2012/01/09 01:59:08 schwarze Exp $ */
d646 7
a652 3
		 * By default, skip a file if the manual section
		 * given in the file disagrees with the directory
		 * where the file is located.
d658 2
a659 2
		if (strcasecmp(msec, of->sec)) {
			if (warnings)
a663 2
			skip = 1;
		}
d682 2
a683 2
		if (strcasecmp(march, of->arch)) {
			if (warnings)
a687 2
			march = of->arch;
		}
a692 2
		 * If both agree, use the file name as the title,
		 * because the one in the file usually is all caps.
a698 2
		else
			mtitle = of->title;
d748 5
a752 3
		 * nil-terminated description.  Since the description
		 * may not be set, we set a sentinel to see if we're
		 * going to write a nil byte in its place.
d759 3
a761 3
		buf_appendb(dbuf, msec, strlen(msec) + 1);
		buf_appendb(dbuf, mtitle, strlen(mtitle) + 1);
		buf_appendb(dbuf, march, strlen(march) + 1);
d783 8
@


1.36
log
@Rename whatis.{db,index} back to mandoc.{db,index}
such that makewhatis(8) called from pkg_delete(1)
does not fail trying to open old-style whatis.db files as btree(3).
Suggested by espie@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.35 2012/01/07 15:32:24 schwarze Exp $ */
d594 1
d598 1
d605 5
d692 1
d699 1
a699 6
		if (strcasecmp(mtitle, of->title)) {
			if (warnings)
				fprintf(stderr, "%s: "
					"title \"%s\" in file "
					"but \"%s\" in filename\n",
					fn, mtitle, of->title);
d701 1
a701 1
		} else
d704 42
d841 17
@


1.35
log
@Improve handling of relative paths, letting invocations like the
following one reindex certain files in a local tree:
makewhatis -d mytree mytree/*/foo*.*
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.34 2012/01/05 22:48:52 schwarze Exp $ */
d1623 1
a1623 1
 * This ignores the whatis.db and whatis.index files, but assumes that
@


1.34
log
@Do not truncate the production database when starting to build a new one,
because that would break apropos(1) during the build, and if the build
fails, you would be left without any database at all.
Instead, build the database in temporary files in the same directory
and rename(2) them into place when they are ready.
Suggested by deraadt@@.

There is still a tiny race between the two rename(2)s;
if that's a problem, we can solve it later using locking.
Put this in now such that we can move on.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.33 2011/12/28 01:17:01 schwarze Exp $ */
d117 2
a118 1
static	void		  ofile_argbuild(int, char *[], struct of **);
d388 1
a388 1
		ofile_argbuild(argc, argv, &of);
d396 10
a405 2
		strlcat(mdb.dbn, dir, MAXPATHLEN);
		strlcat(mdb.dbn, "/", MAXPATHLEN);
d408 1
a408 2
		strlcat(mdb.idxn, dir, MAXPATHLEN);
		strlcat(mdb.idxn, "/", MAXPATHLEN);
d412 1
a412 1
			fprintf(stderr, "%s: path too long\n", dir);
d428 1
a428 1
		ofile_argbuild(argc, argv, &of);
d1518 2
a1519 1
ofile_argbuild(int argc, char *argv[], struct of **of)
d1522 1
d1524 1
a1524 1
	char		*p;
d1529 13
d1550 2
a1551 2
		if (strlcpy(buf, argv[i], sizeof(buf)) >= sizeof(buf)) {
			fprintf(stderr, "%s: path too long\n", argv[i]);
d1587 1
a1587 1
				    argv[i]);
d1596 1
a1596 1
		nof->fname = mandoc_strdup(argv[i]);
d1607 1
a1607 1
			printf("%s: scheduling\n", argv[i]);
@


1.33
log
@Some parsing improvements from kristaps@@:
* Accept multiple lines in cat page NAME parsing.
* Do not trim the description to 70 characters in the database.
* Instead, limit the length of the description during output.
* In man(7), accept \-\- as a Nm-Nd separator; occurs in 3p.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.32 2011/12/26 11:44:31 schwarze Exp $ */
d24 1
a385 4
	flags = O_CREAT | O_RDWR;
	if (OP_DEFAULT == op || OP_CONFFILE == op)
		flags |= O_TRUNC;

d408 1
a464 1
		mdb.idxn[0] = mdb.dbn[0] = '\0';
d466 5
a470 3
		strlcat(mdb.dbn, dirs.paths[i], MAXPATHLEN);
		strlcat(mdb.dbn, "/", MAXPATHLEN);
		sz1 = strlcat(mdb.dbn, MANDOC_DB, MAXPATHLEN);
d472 3
a474 8
		strlcat(mdb.idxn, dirs.paths[i], MAXPATHLEN);
		strlcat(mdb.idxn, "/", MAXPATHLEN);
		sz2 = strlcat(mdb.idxn, MANDOC_IDX, MAXPATHLEN);

		if (sz1 >= MAXPATHLEN || sz2 >= MAXPATHLEN) {
			fprintf(stderr, "%s: path too long\n",
					dirs.paths[i]);
			exit((int)MANDOCLEVEL_BADARG);
d477 1
a477 4
		if (mdb.db)
			(*mdb.db->close)(mdb.db);
		if (mdb.idx)
			(*mdb.idx->close)(mdb.idx);
d479 31
a509 2
		mdb.db = dbopen(mdb.dbn, flags, 0644, DB_BTREE, &info);
		mdb.idx = dbopen(mdb.idxn, flags, 0644, DB_RECNO, NULL);
d511 3
a513 7
		if (NULL == mdb.db) {
			perror(mdb.dbn);
			exit((int)MANDOCLEVEL_SYSERR);
		} else if (NULL == mdb.idx) {
			perror(mdb.idxn);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d515 1
a515 2
		ofile_free(of);
		of = NULL;
d517 5
a521 3
		if (-1 == chdir(dirs.paths[i])) {
			perror(dirs.paths[i]);
			exit((int)MANDOCLEVEL_SYSERR);
d524 4
a527 3
	       	ofile_dirbuild(".", "", "", 0, &of);
		if (NULL == of)
			continue;
d530 3
a532 3
		 * Go to the root of the respective manual tree.
		 * This must work or no manuals may be found (they're
		 * indexed relative to the root).
d535 11
a545 2
		if (-1 == chdir(dirs.paths[i])) {
			perror(dirs.paths[i]);
a547 2

		index_merge(of, mp, &dbuf, &buf, hash, &mdb, &recs);
d765 2
@


1.32
log
@Do not skip manuals shared across architectures when building databases.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.31 2011/12/25 19:57:20 schwarze Exp $ */
d22 1
d120 2
a121 2
static	void		  pformatted(DB *, struct buf *, struct buf *,
				const struct of *);
d1326 2
d1358 2
a1359 2
pformatted(DB *hash, struct buf *buf, struct buf *dbuf,
		 const struct of *of)
d1362 2
a1363 2
	char		*line, *p;
	size_t		 len, plen;
d1396 26
d1430 1
a1430 2
	line = fgetln(stream, &len);
	if (NULL == line || ' ' != *line || '\n' != line[(int)len - 1]) {
d1437 1
d1441 2
a1442 1
	line[(int)--len] = '\0';
d1450 1
a1450 1
	if (NULL != (p = strstr(line, "- "))) {
d1457 1
a1457 1
		p = line;
d1460 1
a1460 4
	if ((plen = strlen(p)) > 70) {
		plen = 70;
		p[plen] = '\0';
	}
d1479 1
@


1.31
log
@Plug a memleak and constify some strings; from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.30 2011/12/25 16:52:55 schwarze Exp $ */
d606 2
a607 2
		 * and architecture given in the file disagree
		 * with the directory where the file is located.
d622 15
d645 1
a645 1
			skip = 1;
@


1.30
log
@Use the traditional name "whatis.db" for the mandocdb(8) databases.
Requested by deraadt@@, ok kristaps@@.

CAUTION:
If you run "sudo mandocdb" after this, the old apropos(1) and whatis(1)
will not work any longer.  To get temporary copies of the new ones, run:
cd /usr/bin; rm -f apropos whatis; ln -s mandoc apropos; ln -s mandoc whatis
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.29 2011/12/25 14:51:33 schwarze Exp $ */
d1443 2
a1444 1
	char		*sec, *arch, *title, *p;
d1748 1
d1767 4
a1770 1
	while (of) {
@


1.29
log
@For binary compatability of the databases across architectures,
use pointers to arrays, not pointers to structs.  It is now possible
to create databases on sparc64 and use them on i386 and vice versa.
Kristaps@@ can't think of anything else that might be required, either.
Put this in now such that we can move on.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.28 2011/12/25 13:05:29 schwarze Exp $ */
d1529 1
a1529 1
 * This ignores the mandoc.db and mandoc.index files, but assumes that
@


1.28
log
@Implement test mode (makewhatis -t), required for pkg_create(8).
Always do all consistency checks; when any one fails, decide whether
to print a message, or skip the file, or both, or none.

While here, do some cleanup as well:
* Bail out on conflicting options.
* Do not crash with -a if there are plain files in the root dir.
* Collect some related variables into structs.

Feedback and OK kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.27 2011/12/20 00:41:24 schwarze Exp $ */
d566 1
a566 1
	struct db_val	 vbuf;
d705 1
a705 1
		vbuf.rec = htobe32(rec);
d717 2
a718 2
			vbuf.mask = htobe64(mask);
			val.size = sizeof(struct db_val);
d759 1
a759 1
	struct db_val	*vbuf;
d808 1
a808 1
			if (sizeof(struct db_val) != val.size)
d811 2
a812 2
			vbuf = val.data;
			if (recs->last != betoh32(vbuf->rec))
@


1.27
log
@Do not cast void pointers to pointers requiring alignment.
This makes mandocdb(8)/apropos(1) work on strict alignment architectures.
Basic way to fix this confirmed by deraadt@@ and kettenis@@, thanks.

This now works on both sparc64 and i386, but note that the binary
database format is still machine-dependent.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.26 2011/12/19 02:26:33 schwarze Exp $ */
d44 18
d85 2
a86 1
	OP_NEW = 0, /* new database */
d88 2
a89 1
	OP_DELETE /* delete entries from existing database */
d112 3
a114 6
				DB *, const char *, DB *, const char *,
				recno_t, const recno_t *, size_t);
static	void		  index_prune(const struct of *, DB *, 
				const char *, DB *, const char *, 
				recno_t *, recno_t **, size_t *,
				size_t *);
a132 1
static	void		  usage(void);
d270 1
d277 2
a280 1
	char		*conf_file;
d282 1
a282 3
	char		 pbuf[PATH_MAX],
			 ibuf[MAXPATHLEN], /* index fname */
			 fbuf[MAXPATHLEN];  /* btree fname */
d284 1
a284 3
	DB		*idx, /* index database */
			*db, /* keyword database */
			*hash; /* temporary keyword hashtable */
d286 1
a286 5
	recno_t		 maxrec; /* last record number in the index */
	recno_t		*recs; /* the numbers of all empty records */
	size_t		 sz1, sz2,
			 recsz, /* number of allocated slots in recs */
			 reccur; /* current number of empty records */
d300 2
a302 2
	verb = 0;
	use_all = 0;
a303 1
	db = idx = NULL;
d306 1
a306 4
	recs = NULL;
	recsz = reccur = 0;
	maxrec = 0;
	op = OP_NEW;
a307 1
	conf_file = NULL;
d309 1
a309 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:u:v")))
d315 7
a321 1
			conf_file = optarg;
d324 5
d332 11
d344 5
d355 3
d359 1
a359 2
			usage();
			return((int)MANDOCLEVEL_BADARG);
d365 5
d384 11
a394 1
	flags = OP_NEW == op ? O_CREAT|O_TRUNC|O_RDWR : O_CREAT|O_RDWR;
d397 7
a403 9
		ibuf[0] = fbuf[0] = '\0';

		strlcat(fbuf, dir, MAXPATHLEN);
		strlcat(fbuf, "/", MAXPATHLEN);
		sz1 = strlcat(fbuf, MANDOC_DB, MAXPATHLEN);

		strlcat(ibuf, dir, MAXPATHLEN);
		strlcat(ibuf, "/", MAXPATHLEN);
		sz2 = strlcat(ibuf, MANDOC_IDX, MAXPATHLEN);
d406 1
a406 1
			fprintf(stderr, "%s: Path too long\n", dir);
d410 2
a411 2
		db = dbopen(fbuf, flags, 0644, DB_BTREE, &info);
		idx = dbopen(ibuf, flags, 0644, DB_RECNO, NULL);
d413 2
a414 2
		if (NULL == db) {
			perror(fbuf);
d416 2
a417 2
		} else if (NULL == idx) {
			perror(ibuf);
d426 1
a426 4
		of = of->first;

		index_prune(of, db, fbuf, idx, ibuf,
				&maxrec, &recs, &recsz, &reccur);
d440 1
a440 2
					db, fbuf, idx, ibuf,
					maxrec, recs, reccur);
d463 1
a463 1
		manpath_parse(&dirs, conf_file, NULL, NULL);
d466 1
a466 1
		ibuf[0] = fbuf[0] = '\0';
d468 7
a474 7
		strlcat(fbuf, dirs.paths[i], MAXPATHLEN);
		strlcat(fbuf, "/", MAXPATHLEN);
		sz1 = strlcat(fbuf, MANDOC_DB, MAXPATHLEN);

		strlcat(ibuf, dirs.paths[i], MAXPATHLEN);
		strlcat(ibuf, "/", MAXPATHLEN);
		sz2 = strlcat(ibuf, MANDOC_IDX, MAXPATHLEN);
d477 1
a477 1
			fprintf(stderr, "%s: Path too long\n",
d482 4
a485 4
		if (db)
			(*db->close)(db);
		if (idx)
			(*idx->close)(idx);
d487 2
a488 2
		db = dbopen(fbuf, flags, 0644, DB_BTREE, &info);
		idx = dbopen(ibuf, flags, 0644, DB_RECNO, NULL);
d490 2
a491 2
		if (NULL == db) {
			perror(fbuf);
d493 2
a494 2
		} else if (NULL == idx) {
			perror(ibuf);
a497 5
		if (verb > 2) {
			printf("%s: Truncated\n", fbuf);
			printf("%s: Truncated\n", ibuf);
		}

d504 1
a504 3
		} 

	       	ofile_dirbuild(".", NULL, NULL, 0, &of);
d506 1
a509 2
		of = of->first;

d511 1
a511 1
		 * Go to the root of the respective manual tree.  
d521 1
a521 2
		index_merge(of, mp, &dbuf, &buf, hash, db, fbuf,
				idx, ibuf, maxrec, recs, reccur);
d525 4
a528 4
	if (db)
		(*db->close)(db);
	if (idx)
		(*idx->close)(idx);
d538 1
a538 1
	free(recs);
d541 9
d555 1
a555 2
		DB *db, const char *dbf, DB *idx, const char *idxf,
		recno_t maxrec, const recno_t *recs, size_t reccur)
d558 1
a558 1
	int		 ch;
d562 1
a562 1
	const char	*fn, *msec, *mtitle, *arch;
d569 2
a570 1
	for (rec = 0; of; of = of->next) {
d590 3
a592 1
			arch = mdoc_meta(mdoc)->arch;
d596 1
a596 1
			arch = NULL;
d600 1
a600 1
			arch = of->arch;
d610 21
a630 12
		if (0 == use_all) {
			assert(of->sec);
			assert(msec);
			if (strcasecmp(msec, of->sec))
				continue;

			if (NULL == arch) {
				if (NULL != of->arch)
					continue;
			} else if (NULL == of->arch ||
					strcasecmp(arch, of->arch))
				continue;
d633 1
a633 4
		if (NULL == arch)
			arch = "";

		/* 
d642 9
d652 1
a652 3
		if (0 == strcasecmp(mtitle, of->title))
			mtitle = of->title;
		else if (0 == use_all)
d655 1
a655 1
		/* 
d669 1
a669 1
		buf_appendb(dbuf, arch, strlen(arch) + 1);
d687 5
d697 6
a702 6
		if (reccur > 0) {
			--reccur;
			rec = recs[(int)reccur];
		} else if (maxrec > 0) {
			rec = maxrec;
			maxrec = 0;
d720 1
a720 1
			dbt_put(db, dbf, &key, &val);
d726 1
a726 1
		
d742 1
a742 1
			printf("%s: Added index\n", fn);
d744 1
a744 1
		dbt_put(idx, idxf, &key, &val);
d755 1
a755 3
index_prune(const struct of *ofile, DB *db, const char *dbf, 
		DB *idx, const char *idxf, recno_t *maxrec,
		recno_t **recs, size_t *recsz, size_t *reccur)
d764 1
a764 1
	*reccur = 0;
d766 1
a766 1
	while (0 == (ch = (*idx->seq)(idx, &key, &val, seq))) {
d769 1
a769 1
		memcpy(maxrec, key.data, key.size);
d787 1
a787 1
		/* 
d792 1
a792 1
		for (of = ofile; of; of = of->next)
d805 2
a806 1
		while (0 == (ch = (*db->seq)(db, &key, &val, sseq))) {
d812 1
a812 1
			if (*maxrec != betoh32(vbuf->rec))
d815 2
a816 1
			if ((ch = (*db->del)(db, &key, R_CURSOR)) < 0)
d821 1
a821 1
			perror(dbf);
d824 2
a825 1
			fprintf(stderr, "%s: Corrupt database\n", dbf);
d830 1
a830 1
			printf("%s: Deleted index\n", fn);
d833 1
a833 1
		ch = (*idx->put)(idx, &key, &val, R_CURSOR);
d838 4
a841 4
		if (*reccur >= *recsz) {
			*recsz += MANDOC_SLOP;
			*recs = mandoc_realloc
				(*recs, *recsz * sizeof(recno_t));
d844 2
a845 2
		(*recs)[(int)*reccur] = *maxrec;
		(*reccur)++;
d849 1
a849 1
		perror(idxf);
d852 1
a852 1
		fprintf(stderr, "%s: Corrupt index\n", idxf);
d856 1
a856 1
	(*maxrec)++;
d1348 2
a1349 1
		perror(of->fname);
d1388 3
d1408 4
a1411 1
	} else
d1413 1
d1457 1
a1457 1
			fprintf(stderr, "%s: Path too long\n", argv[i]);
d1460 1
a1460 1
		sec = arch = title = NULL;
d1464 1
a1464 1
			if (NULL == sec && '.' == *p) {
d1475 1
a1475 1
			if (NULL == title) {
d1488 6
a1493 1
		if (NULL == title)
d1495 1
d1503 2
a1504 4
		if (NULL != sec)
			nof->sec = mandoc_strdup(sec);
		if (NULL != arch)
			nof->arch = mandoc_strdup(arch);
d1512 2
a1513 2
		if (verb > 2) 
			printf("%s: Scheduling\n", argv[i]);
d1547 3
a1549 2
		perror(dir);
		return(0);
d1570 1
a1570 1
			if (NULL == sec) {
d1577 22
a1598 3
				} else if (use_all)
					sec = fn;
				else
d1600 1
a1600 5
			} else if (NULL == arch && (use_all ||
					NULL == strchr(fn, '.')))
				arch = fn;
			else if (0 == use_all)
				continue;
d1608 3
a1610 2
				fprintf(stderr, "%s: Path too long\n", dir);
				return(0);
d1612 3
a1614 3
 
			if (verb > 2)
				printf("%s: Scanning\n", buf);
d1617 1
d1620 8
a1627 4
		if (DT_REG != dp->d_type ||
				(NULL == psec && !use_all) ||
				! strcmp(MANDOC_DB, fn) ||
				! strcmp(MANDOC_IDX, fn))
d1629 8
d1645 6
a1650 2
		if (0 == use_all) {
			if (NULL == suffix)
d1652 2
a1653 2
			if ((MANDOC_SRC & src_form &&
					 strcmp(suffix + 1, psec)) ||
d1655 7
a1661 4
					 strcmp(suffix + 1, "0")))
					continue;
		}
		if (NULL != suffix) {
a1667 1

d1676 1
a1676 1
				NULL != psec) {
d1680 1
a1680 1
			if (NULL != parch && NULL != p)
d1693 3
a1695 1
				fprintf(stderr, "%s: Path too long\n", buf);
d1703 3
a1705 2
					fprintf(stderr,
					    "%s: Path too long\n", buf);
d1713 1
d1715 4
a1718 4
		assert('/' == dir[1]);
		buf[0] = '\0';
		strlcat(buf, dir + 2, MAXPATHLEN);
		strlcat(buf, "/", MAXPATHLEN);
d1721 2
a1722 1
			fprintf(stderr, "%s: Path too long\n", dir);
d1728 2
a1729 4
		if (NULL != psec)
			nof->sec = mandoc_strdup(psec);
		if (NULL != parch)
			nof->arch = mandoc_strdup(parch);
d1745 2
a1746 2
		if (verb > 2)
			printf("%s: Scheduling\n", buf);
a1773 11
}

static void
usage(void)
{

	fprintf(stderr, "usage: %s [-v] "
			"[-C file] |"
			" dir ... |"
			" -d dir [file ...] |"
			" -u dir [file ...]\n", progname);
@


1.26
log
@Improvements from kristaps@@:
(1) Make the database format simpler and smaller by
- storing the file type as a single character and
- storing paths relative to the dir containing the database.
The latter allows to move trees around.
Both together typically save 15-25% of the index size.
(2) Make sure apropos(1) "any" really covers all search keys.
(3) Make manpath_parseline() static, drop manpath_parseconf() completely.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.25 2011/12/12 01:59:13 schwarze Exp $ */
d521 1
d652 3
a654 1
			vbuf.mask = htobe64(*(uint64_t *)val.data);
d707 2
a708 1
		*maxrec = *(recno_t *)key.data;
d1068 1
d1081 5
a1085 2
	} else if (0 == rc)
		mask |= *(uint64_t *)val.data;
@


1.25
log
@implement -C (alternative config file) for apropos(1) and mandocdb(8);
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.24 2011/12/10 22:01:03 schwarze Exp $ */
a19 1
#include <sys/stat.h>
d99 1
a99 1
static	int		  ofile_dirbuild(const char *, const char *,
d374 1
a374 4
		if (verb > 2) {
			printf("%s: Opened\n", fbuf);
			printf("%s: Opened\n", ibuf);
		}
a375 1
		ofile_argbuild(argc, argv, &of);
d385 3
a387 3
		 * Go to the root of the respective manual tree
		 * such that .so links work.  In case of failure,
		 * just prod on, even though .so links won't work.
d391 4
a394 1
			chdir(dir);
d463 2
a464 2
		if ( ! ofile_dirbuild(dirs.paths[i], NULL, NULL,
					0, &of)) 
d466 3
d476 3
a478 3
		 * Go to the root of the respective manual tree
		 * such that .so links work.  In case of failure,
		 * just prod on, even though .so links won't work.
d481 5
a485 1
		chdir(dirs.paths[i]);
d524 1
d605 2
a606 1
		buf_append(dbuf, mdoc ? "mdoc" : (man ? "man" : "cat"));
d694 1
a694 1
	const char	*fn, *cp;
a704 1
		cp = val.data;
d718 2
a719 5
		if (NULL == (fn = memchr(cp, '\0', val.size)))
			break;
		if (++fn - cp >= (int)val.size)
			break;
		if (NULL == memchr(fn, '\0', val.size - (fn - cp)))
d1449 1
a1449 1
static int
a1453 1
	struct stat	 sb;
d1515 1
a1515 3
			if ( ! ofile_dirbuild(buf, sec, arch,
					src_form, of))
				return(0);
d1517 1
d1519 3
a1521 3
		    (NULL == psec && !use_all) ||
		    !strcmp(MANDOC_DB, fn) ||
		    !strcmp(MANDOC_IDX, fn))
d1585 1
a1585 1
				if (0 == stat(buf, &sb))
d1590 2
d1593 1
a1593 1
		strlcat(buf, dir, MAXPATHLEN);
a1634 1
	return(1);
@


1.24
log
@Avoid leaking index records:
Before allocating a record for a file,
first make sure we actually want to use the file.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.23 2011/12/10 16:53:38 schwarze Exp $ */
d263 1
d303 1
d305 1
a305 1
	while (-1 != (ch = getopt(argc, argv, "ad:u:v")))
d310 3
d422 1
a422 1
		manpath_parse(&dirs, NULL, NULL);
d1656 4
a1659 3
			"[-d dir [files...] |"
			" -u dir [files...] |"
			" dir...]\n", progname);
@


1.23
log
@Fix selection of arch-specific manuals:
(1) Correctly compare cat vs. man paths.
(2) Compare arch (and section) names case-insensitively.
Problem noticed by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.22 2011/12/09 01:47:11 schwarze Exp $ */
d519 3
a521 1
		 * Reclaim an empty index record, if available.
a523 9
		if (reccur > 0) {
			--reccur;
			rec = recs[(int)reccur];
		} else if (maxrec > 0) {
			rec = maxrec;
			maxrec = 0;
		} else
			rec++;

a524 1
		hash_reset(&hash);
a527 6
		/*
		 * Try interpreting the file as mdoc(7) or man(7)
		 * source code, unless it is already known to be
		 * formatted.  Fall back to formatted mode.
		 */

d602 4
a605 1
		/* Fix the record number in the btree value. */
d607 1
d617 2
a618 2
		 * Copy from the in-memory hashtable of pending keywords
		 * into the database.
d621 8
d630 6
@


1.22
log
@Improve parsing of preformatted manuals:
* If the first section is empty, reuse the file name as the description.
* Strip backspace encoding from the description.
* Make the loops more readable using string(3) functions.
* Put fclose() at the end, as line isn't valid afterwards.
From kristaps@@, tweaked a bit by me.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.21 2011/12/09 00:53:10 schwarze Exp $ */
d570 1
a570 1
			if (strcmp(msec, of->sec))
d577 1
a577 1
					strcmp(arch, of->arch))
d1550 4
@


1.21
log
@In default mode, use realpath(3) on the "dir" arguments
and put canonicalized absolute pathnames into the database;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.20 2011/12/08 02:14:00 schwarze Exp $ */
d1279 1
a1279 2
	while (NULL != (line = fgetln(stream, &len)) && '\n' != *line)
		/* Skip to first blank line. */ ;
d1281 12
a1292 3
	while (NULL != (line = fgetln(stream, &len)) &&
			('\n' == *line || ' ' == *line))
		/* Skip to first section header. */ ;
d1295 4
a1298 2
	 * If no page content can be found,
	 * reuse the page title as the page description.
d1301 2
a1302 1
	if (NULL == (line = fgetln(stream, &len))) {
d1308 2
a1309 1
	fclose(stream);
d1312 3
a1314 1
	 * If there is a dash, skip to the text following it.
d1317 4
a1320 7
	for (p = line, plen = len; plen; p++, plen--)
		if ('-' == *p)
			break;
	for ( ; plen; p++, plen--)
		if ('-' != *p && ' ' != *p && 8 != *p)
			break;
	if (0 == plen) {
d1322 4
a1325 1
		plen = len;
d1328 11
a1338 3
	/*
	 * Copy the rest of the line, but no more than 70 bytes.
	 */
d1340 1
a1340 4
	if (70 < plen)
		plen = 70;
	p[plen-1] = '\0';
	buf_appendb(dbuf, p, plen);
d1342 1
a1342 1
	buf_appendb(buf, p, plen);
d1344 1
@


1.20
log
@bugfix: make reclaiming of index slots actually work;
index_prune always counted the free slots,
but didn't tell anybody about them, so they weren't reused
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.19 2011/12/07 01:57:18 schwarze Exp $ */
d263 3
a265 1
	char		 ibuf[MAXPATHLEN], /* index fname */
d407 1
a407 1
		dirs.paths = mandoc_malloc(argc * sizeof(char *));
d409 7
a415 2
		for (i = 0; i < argc; i++)
			dirs.paths[i] = mandoc_strdup(argv[i]);
@


1.19
log
@Implement search support for 24 additional macros, extract more information
from Fn, and lift section restrictions from An Cd Er Ev Fn Fo In Pa St Va Vt
by removing 4 handler functions and 50 lines of code.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.18 2011/12/04 14:11:55 schwarze Exp $ */
d97 2
a98 1
				recno_t *, recno_t **, size_t *);
d380 1
a380 1
				&maxrec, &recs, &recsz);
d667 2
a668 2
		DB *idx, const char *idxf,
		recno_t *maxrec, recno_t **recs, size_t *recsz)
a674 1
	size_t		 reccur;
d677 1
a677 1
	reccur = 0;
d751 1
a751 1
		if (reccur >= *recsz) {
d757 2
a758 2
		(*recs)[(int)reccur] = *maxrec;
		reccur++;
@


1.18
log
@Fix parsing of file names given on the command line; i broke it
when adding support for formatted manual pages.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.17 2011/12/03 14:53:12 schwarze Exp $ */
d106 10
a115 14
static	void		  pmdoc_An(MDOC_ARGS);
static	void		  pmdoc_Cd(MDOC_ARGS);
static	void		  pmdoc_Er(MDOC_ARGS);
static	void		  pmdoc_Ev(MDOC_ARGS);
static	void		  pmdoc_Fd(MDOC_ARGS);
static	void		  pmdoc_In(MDOC_ARGS);
static	void		  pmdoc_Fn(MDOC_ARGS);
static	void		  pmdoc_Fo(MDOC_ARGS);
static	void		  pmdoc_Nd(MDOC_ARGS);
static	void		  pmdoc_Nm(MDOC_ARGS);
static	void		  pmdoc_Pa(MDOC_ARGS);
static	void		  pmdoc_St(MDOC_ARGS);
static	void		  pmdoc_Vt(MDOC_ARGS);
static	void		  pmdoc_Xr(MDOC_ARGS);
d118 1
a118 1
typedef	void		(*pmdoc_nf)(MDOC_ARGS);
d120 129
a248 123
static	const pmdoc_nf	  mdocs[MDOC_MAX] = {
	NULL, /* Ap */
	NULL, /* Dd */
	NULL, /* Dt */
	NULL, /* Os */
	NULL, /* Sh */ 
	NULL, /* Ss */ 
	NULL, /* Pp */ 
	NULL, /* D1 */
	NULL, /* Dl */
	NULL, /* Bd */
	NULL, /* Ed */
	NULL, /* Bl */ 
	NULL, /* El */
	NULL, /* It */
	NULL, /* Ad */ 
	pmdoc_An, /* An */ 
	NULL, /* Ar */
	pmdoc_Cd, /* Cd */ 
	NULL, /* Cm */
	NULL, /* Dv */ 
	pmdoc_Er, /* Er */ 
	pmdoc_Ev, /* Ev */ 
	NULL, /* Ex */ 
	NULL, /* Fa */ 
	pmdoc_Fd, /* Fd */
	NULL, /* Fl */
	pmdoc_Fn, /* Fn */ 
	NULL, /* Ft */ 
	NULL, /* Ic */ 
	pmdoc_In, /* In */ 
	NULL, /* Li */
	pmdoc_Nd, /* Nd */
	pmdoc_Nm, /* Nm */
	NULL, /* Op */
	NULL, /* Ot */
	pmdoc_Pa, /* Pa */
	NULL, /* Rv */
	pmdoc_St, /* St */ 
	pmdoc_Vt, /* Va */
	pmdoc_Vt, /* Vt */ 
	pmdoc_Xr, /* Xr */ 
	NULL, /* %A */
	NULL, /* %B */
	NULL, /* %D */
	NULL, /* %I */
	NULL, /* %J */
	NULL, /* %N */
	NULL, /* %O */
	NULL, /* %P */
	NULL, /* %R */
	NULL, /* %T */
	NULL, /* %V */
	NULL, /* Ac */
	NULL, /* Ao */
	NULL, /* Aq */
	NULL, /* At */ 
	NULL, /* Bc */
	NULL, /* Bf */
	NULL, /* Bo */
	NULL, /* Bq */
	NULL, /* Bsx */
	NULL, /* Bx */
	NULL, /* Db */
	NULL, /* Dc */
	NULL, /* Do */
	NULL, /* Dq */
	NULL, /* Ec */
	NULL, /* Ef */ 
	NULL, /* Em */ 
	NULL, /* Eo */
	NULL, /* Fx */
	NULL, /* Ms */ 
	NULL, /* No */
	NULL, /* Ns */
	NULL, /* Nx */
	NULL, /* Ox */
	NULL, /* Pc */
	NULL, /* Pf */
	NULL, /* Po */
	NULL, /* Pq */
	NULL, /* Qc */
	NULL, /* Ql */
	NULL, /* Qo */
	NULL, /* Qq */
	NULL, /* Re */
	NULL, /* Rs */
	NULL, /* Sc */
	NULL, /* So */
	NULL, /* Sq */
	NULL, /* Sm */ 
	NULL, /* Sx */
	NULL, /* Sy */
	NULL, /* Tn */
	NULL, /* Ux */
	NULL, /* Xc */
	NULL, /* Xo */
	pmdoc_Fo, /* Fo */ 
	NULL, /* Fc */ 
	NULL, /* Oo */
	NULL, /* Oc */
	NULL, /* Bk */
	NULL, /* Ek */
	NULL, /* Bt */
	NULL, /* Hf */
	NULL, /* Fr */
	NULL, /* Ud */
	NULL, /* Lb */
	NULL, /* Lp */ 
	NULL, /* Lk */ 
	NULL, /* Mt */ 
	NULL, /* Brq */ 
	NULL, /* Bro */ 
	NULL, /* Brc */ 
	NULL, /* %C */
	NULL, /* Es */
	NULL, /* En */
	NULL, /* Dx */
	NULL, /* %Q */
	NULL, /* br */
	NULL, /* sp */
	NULL, /* %U */
	NULL, /* Ta */
a836 12
/* ARGSUSED */
static void
pmdoc_An(MDOC_ARGS)
{
	
	if (SEC_AUTHORS != n->sec)
		return;

	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_An);
}

d853 17
a869 1
static void
d874 1
a874 1
	
d876 1
a876 1
		return;
d878 1
a878 1
		return;
d885 1
a885 1
		return;
d888 1
a888 1
		return;
d900 1
a900 1
		return;
d910 1
a910 2

	hash_put(hash, buf, TYPE_In);
d914 2
a915 2
static void
pmdoc_Cd(MDOC_ARGS)
a916 3
	
	if (SEC_SYNOPSIS != n->sec)
		return;
a917 11
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_Cd);
}

/* ARGSUSED */
static void
pmdoc_In(MDOC_ARGS)
{
	
	if (SEC_SYNOPSIS != n->sec)
		return;
d919 1
a919 1
		return;
d922 1
a922 1
	hash_put(hash, buf, TYPE_In);
d926 1
a926 1
static void
d929 1
a930 5
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;
d932 6
a937 1
	/* .Fn "struct type *arg" "foo" */
d939 1
a939 1
	cp = strrchr(n->child->string, ' ');
d941 1
a941 1
		cp = n->child->string;
d948 2
d952 21
d976 1
a976 1
static void
d979 1
a979 3
	
	if (SEC_STANDARDS != n->sec)
		return;
d981 1
a981 1
		return;
d984 1
a984 1
	hash_put(hash, buf, TYPE_St);
d988 1
a988 1
static void
d993 1
a993 1
		return;
d1003 1
a1003 52
	hash_put(hash, buf, TYPE_Xr);
}

/* ARGSUSED */
static void
pmdoc_Vt(MDOC_ARGS)
{
	const char	*start;
	size_t		 sz;
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (MDOC_Vt == n->tok && MDOC_BODY != n->type)
		return;
	if (NULL == n->last || MDOC_TEXT != n->last->type)
		return;

	/*
	 * Strip away leading pointer symbol '*' and trailing ';'.
	 */

	start = n->last->string;

	while ('*' == *start)
		start++;

	if (0 == (sz = strlen(start)))
		return;

	if (';' == start[(int)sz - 1])
		sz--;

	if (0 == sz)
		return;

	buf_appendb(buf, start, sz);
	buf_appendb(buf, "", 1);
	hash_put(hash, buf, TYPE_Va);
}

/* ARGSUSED */
static void
pmdoc_Fo(MDOC_ARGS)
{
	
	if (SEC_SYNOPSIS != n->sec || MDOC_HEAD != n->type)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;

	buf_append(buf, n->child->string);
	hash_put(hash, buf, TYPE_Fn);
a1005 1

d1007 1
a1007 1
static void
d1012 1
a1012 1
		return;
d1015 1
a1015 3
	buf_appendmdoc(buf, n->child, 0);

	hash_put(hash, buf, TYPE_Nd);
d1019 2
a1020 14
static void
pmdoc_Er(MDOC_ARGS)
{

	if (SEC_ERRORS != n->sec)
		return;
	
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_Er);
}

/* ARGSUSED */
static void
pmdoc_Ev(MDOC_ARGS)
d1023 4
a1026 6
	if (SEC_ENVIRONMENT != n->sec)
		return;
	
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_Ev);
}
d1028 2
a1029 4
/* ARGSUSED */
static void
pmdoc_Pa(MDOC_ARGS)
{
d1031 1
a1031 5
	if (SEC_FILES != n->sec)
		return;
	
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_Pa);
d1035 2
a1036 2
static void
pmdoc_Nm(MDOC_ARGS)
a1037 10
	
	if (SEC_NAME == n->sec) {
		buf_appendmdoc(buf, n->child, 0);
		hash_put(hash, buf, TYPE_Nm);
		return;
	} else if (SEC_SYNOPSIS != n->sec || MDOC_HEAD != n->type)
		return;

	if (NULL == n->child)
		buf_append(buf, m->name);
d1039 1
a1039 2
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_Nm);
d1105 10
a1114 1
		if (NULL == mdocs[n->tok])
d1117 18
a1134 2
		buf->len = 0;
		(*mdocs[n->tok])(hash, buf, dbuf, n, m);
@


1.17
log
@Make the mandocdb(8) format endian-neutral by storing integer data
in network byte order; from kristaps@@.

Hopefully, this finishes the database format.
This commit requires another rebuild of your mandoc databases
by running "sudo mandocdb".
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.16 2011/12/01 23:22:09 schwarze Exp $ */
d1408 1
a1408 1
			if (strncmp("man", p + 1, 3)) {
d1410 1
a1410 2
				arch = p + 1;
			} else if (strncmp("cat", p + 1, 3)) {
d1412 1
a1413 1
			}
@


1.16
log
@Fix mandocdb(8) to pass over the type when pruning the database.
This fixed `-d' perpetually adding the same files.
While here, remove -vv, clean up the code and document it.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.15 2011/11/29 22:30:56 schwarze Exp $ */
d323 1
d621 1
a621 1
		vbuf.rec = rec;
d625 1
a625 2

			vbuf.mask = *(uint64_t *)val.data;
a627 1

d725 1
a725 1
			if (*maxrec != vbuf->rec)
@


1.15
log
@Sync to bsd.lv, mostly from kristaps@@.
Make `-i' only apply to regular expressions.
For substring matches, always use strcasestr().
Also, improve some manuals and comments.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.14 2011/11/28 00:57:28 schwarze Exp $ */
a628 3
			if (verb > 1)
				printf("%s: Added keyword: %s\n", 
						fn, (char *)key.data);
d652 1
d669 1
a669 1
	const char	*fn;
d681 25
a705 10
		if (0 == val.size) {
			if (reccur >= *recsz) {
				*recsz += MANDOC_SLOP;
				*recs = mandoc_realloc(*recs, 
					*recsz * sizeof(recno_t));
			}
			(*recs)[(int)reccur] = *maxrec;
			reccur++;
			continue;
		}
a706 1
		fn = (char *)val.data;
d714 5
d722 3
a724 1
			assert(sizeof(struct db_val) == val.size);
d728 2
a729 5
			if (verb)
				printf("%s: Deleted keyword: %s\n", 
						fn, (char *)key.data);
			ch = (*db->del)(db, &key, R_CURSOR);
			if (ch < 0)
d732 1
d736 3
a745 4
		if (ch < 0) {
			perror(idxf);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d747 3
d759 9
@


1.14
log
@Put back the chdir(2) to the right man page tree before parsing manuals;
this got lost during the bsd.lv sync in rev. 1.10; oops.
This is required for processing .so links: otherwise, several files
in Xenocara fail to parse and cause ugly complaints instead.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.13 2011/11/27 23:27:16 schwarze Exp $ */
d378 6
d457 6
@


1.13
log
@Reimplement the global command line options -a and -v
as static global variables, reducing the maze of arguments
passed around among various static functions.
Suggested by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.12 2011/11/27 23:11:32 schwarze Exp $ */
d30 1
d378 2
a379 1
		if (OP_UPDATE == op)
d383 1
d452 1
@


1.12
log
@Save the manual type (mdoc, man, or cat) in the index file
of the mandoc databases, as suggested by kristaps@@.
Given the well-structured code, this is surprisingly simple.

This changes the mandoc.index database format.
Run "sudo mandocdb" to regenerate your databases.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.11 2011/11/27 22:57:28 schwarze Exp $ */
d91 2
a92 3
				struct buf *, struct buf *,
				DB *, DB *, const char *, 
				DB *, const char *, int, int,
d96 2
a97 3
				int, recno_t *, recno_t **, size_t *);
static	void		  ofile_argbuild(char *[], int, int, int,
				struct of **);
d99 1
a99 2
				const char *, int, int, int,
				struct of **);
d249 2
d261 1
a261 3
	int		 verb, /* output verbosity */
			 use_all, /* use all directories and files */
			 ch, i, flags;
d368 1
a368 1
		ofile_argbuild(argv, argc, use_all, verb, &of);
d374 1
a374 1
		index_prune(of, db, fbuf, idx, ibuf, verb,
d379 2
a380 2
					db, fbuf, idx, ibuf, use_all,
					verb, maxrec, recs, reccur);
d441 1
a441 1
				0, use_all, verb, &of)) 
d450 1
a450 2
				idx, ibuf, use_all, verb,
				maxrec, recs, reccur);
d474 2
a475 3
		struct buf *dbuf, struct buf *buf,
		DB *hash, DB *db, const char *dbf,
		DB *idx, const char *idxf, int use_all, int verb,
d651 1
a651 1
		DB *idx, const char *idxf, int verb,
d1325 1
a1325 2
ofile_argbuild(char *argv[], int argc, int use_all, int verb,
		struct of **of)
d1417 1
a1417 1
		int p_src_form, int use_all, int verb, struct of **of)
d1483 1
a1483 1
					src_form, use_all, verb, of))
@


1.11
log
@Rudimentary handling of formatted manuals ("cat pages").
Coded on the train back from p2k11 in Budapest.
Kristaps has seen the patch and agreed with the direction.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.10 2011/11/26 16:41:35 schwarze Exp $ */
d586 1
@


1.10
log
@Resync to bsd.lv, most code from kristaps@@.
In particular, support the MANPATH environment variable
and don't confuse index record numbers when working with
multiple mandoc databases at once.
Besides, remove lots of gratuitious code and whitespace differences.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.9 2011/11/17 15:38:27 schwarze Exp $ */
d19 2
d41 3
d51 1
d101 2
a102 1
				const char *, int, int, struct of **);
d104 2
d444 1
a444 1
				use_all, verb, &of))
d495 5
d511 2
d514 23
a536 3
		if (mparse_readfd(mp, -1, fn) >= MANDOCLEVEL_FATAL) {
			fprintf(stderr, "%s: Parse failure\n", fn);
			continue;
a538 4
		mparse_result(mp, &mdoc, &man);
		if (NULL == mdoc && NULL == man)
			continue;

a544 5
		msec = NULL != mdoc ? 
			mdoc_meta(mdoc)->msec : man_meta(man)->msec;
		arch = NULL != mdoc ? 
			mdoc_meta(mdoc)->arch : NULL;

a568 3
		mtitle = NULL != mdoc ? 
			mdoc_meta(mdoc)->title : man_meta(man)->title;

d598 1
a598 1
		else 
d600 2
d1252 76
d1334 1
a1334 1
	int		 i;
d1342 2
a1343 1
		 *   man*[/<arch>]/<title>.<section>
d1351 1
d1357 4
d1370 5
a1374 1
			if (strncmp("man", p + 1, 3))
d1376 1
d1393 1
d1422 1
a1422 1
		int use_all, int verb, struct of **of)
d1425 1
d1429 1
a1429 1
	char		*suffix;
d1432 1
d1445 2
d1453 2
a1454 1
			 *   man<section>/[<arch>/]
d1458 2
a1459 1
				if(0 == strncmp("man", fn, 3))
d1461 4
a1464 1
				else if (use_all)
d1488 1
a1488 1
					use_all, verb, of))
d1507 36
a1542 1
			if (strcmp(suffix + 1, psec))
d1544 13
d1565 1
a1565 1
			return(0);
d1574 1
d1585 4
a1590 1

@


1.9
log
@Change the search type mask from 32 to 64 bit such that a full set
of search types can be supported in the future.  While here, replace
a couple of memcpy(3)s by proper, statically type-checked assignments,
and de-obfuscate some magical numbers using sizeof().
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.8 2011/11/17 15:02:29 schwarze Exp $ */
d4 1
a27 1
#include <unistd.h>
d34 1
a34 1
#include "man_conf.h"
a246 1
	struct man_conf	 dirs;
d248 1
d277 2
a314 1
	memset(&dirs, 0, sizeof(struct man_conf));
d371 2
a372 3
		if (OP_UPDATE == op) {
			chdir(dir);
			index_merge(of, mp, &dbuf, &buf, hash, 
a374 1
		}
d379 13
a391 5
	if (0 == argc) {
		man_conf_parse(&dirs);
		argc = dirs.argc;
		argv = dirs.argv;
	}
d393 1
a393 1
	for (i = 0; i < argc; i++) {
d396 1
a396 1
		strlcat(fbuf, argv[i], MAXPATHLEN);
d400 1
a400 1
		strlcat(ibuf, argv[i], MAXPATHLEN);
d405 2
a406 1
			fprintf(stderr, "%s: Path too long\n", argv[i]);
d434 2
a435 2
		if ( ! ofile_dirbuild(argv[i], NULL, NULL,
				use_all, verb, &of)) 
d443 1
a443 2
		chdir(argv[i]);
		index_merge(of, mp, &dbuf, &buf, hash, db, fbuf, 
a456 2
	if (dirs.argc)
		man_conf_free(&dirs);
d458 1
d470 1
a470 1
		DB *hash, DB *db, const char *dbf, 
@


1.8
log
@Fix a pasto that prevented detection of mandoc.index dbopen(3) failure.
And as suggested by kristaps@@, improve a lot of comments.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.7 2011/11/17 14:52:32 schwarze Exp $ */
d82 1
a82 1
static	void		  hash_put(DB *, const struct buf *, int);
d476 1
a476 1
	char		 vbuf[8];
a574 3
		
		memset(vbuf, 0, sizeof(uint32_t));
		memcpy(vbuf + 4, &rec, sizeof(uint32_t));
d576 1
d581 3
a583 3
			memcpy(vbuf, val.data, sizeof(uint32_t));
			val.size = sizeof(vbuf);
			val.data = vbuf;
d628 1
d661 3
a663 2
			assert(8 == val.size);
			if (*maxrec != *(recno_t *)(val.data + 4))
d1044 1
a1044 1
hash_put(DB *db, const struct buf *buf, int mask)
d1059 1
a1059 1
		mask |= *(int *)val.data;
d1062 1
a1062 1
	val.size = sizeof(int); 
@


1.7
log
@Minimal man.conf(5) _whatdb support for mandocdb(8) and apropos(1),
and add the standard options -M and -m to apropos(1).
Including a bugfix to prevent mandocdb(8) from leaking
database file descriptors.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.6 2011/11/14 18:52:05 schwarze Exp $ */
d260 2
a261 2
	recno_t		 maxrec; /* supremum of all records */
	recno_t		*recs; /* buffer of empty records */
d263 2
a264 2
			 recsz, /* buffer size of recs */
			 reccur; /* valid number of recs */
d351 1
a351 1
		} else if (NULL == db) {
d413 1
a413 1
		} else if (NULL == db) {
d502 3
a504 3
		 * Make sure the manual section and architecture
		 * agree with the directory where the file is located
		 * or man(1) will not be able to find it.
d530 4
a533 3
		 * Case is relevant for man(1), so use the file name
		 * instead of the (usually) all caps page title,
		 * if the two agree.
d1232 3
a1234 1
		 * Analyze the path.
d1328 2
a1329 2
	 		 * Don't bother parsing directories
			 * that man(1) won't find.
d1369 3
a1371 1
		 * Don't bother parsing files that man(1) won't find.
d1397 6
@


1.6
log
@Store page titles in the correct case, and by default, only
put stuff into the database that man(1) will be able to retrieve.
However, support an option to use all directories and files.

Kristaps@@ agreed with the general direction and provided some feedback.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.5 2011/11/13 10:40:52 schwarze Exp $ */
d27 1
d34 1
d247 1
d313 1
d370 2
a371 1
		if (OP_UPDATE == op)
d375 1
d380 6
d402 5
d435 1
d450 2
@


1.5
log
@Inventing new keywords for mostly the same thing when a well-established
set of keywords already exists is a bad idea, so reuse the mdoc(7)
macro names as apropos(1) search types.  This is a gain in brevity
as well.  Some time ago, kristaps@@ agreed in principle.

The search type bit field constants are used by both mandocdb(8) and
apropos(1) and should better stay in sync, so give them their own
header file.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.4 2011/11/13 00:53:07 schwarze Exp $ */
d41 3
d85 1
a85 1
				DB *, const char *, int,
d90 4
a93 2
static	void		  ofile_argbuild(char *[], int, int, struct of **);
static	int		  ofile_dirbuild(const char *, int, struct of **);
d251 1
d275 1
d286 1
a286 1
	while (-1 != (ch = getopt(argc, argv, "d:u:v")))
d288 3
d357 1
a357 1
		ofile_argbuild(argv, argc, verb, &of);
d368 2
a369 2
					db, fbuf, idx, ibuf, verb,
					maxrec, recs, reccur);
d409 2
a410 1
		if ( ! ofile_dirbuild(argv[i], verb, &of)) 
d419 2
a420 1
				idx, ibuf, verb, maxrec, recs, reccur);
d445 1
a445 1
		DB *idx, const char *idxf, int verb,
d481 6
a488 2
		mtitle = NULL != mdoc ? 
			mdoc_meta(mdoc)->title : man_meta(man)->title;
d492 14
d510 17
d1200 2
a1201 1
ofile_argbuild(char *argv[], int argc, int verb, struct of **of)
d1203 2
d1209 35
d1245 11
a1255 1
		nof->fname = strdup(argv[i]);
d1278 2
a1279 1
ofile_dirbuild(const char *dir, int verb, struct of **of)
d1284 2
a1285 1
	const char	*fn;
d1296 4
d1301 19
a1319 3
			if (0 == strcmp(".", fn))
				continue;
			if (0 == strcmp("..", fn))
d1327 25
a1351 3
			if (sz < MAXPATHLEN) {
				if ( ! ofile_dirbuild(buf, verb, of))
					return(0);
d1353 1
a1353 1
			} else if (sz < MAXPATHLEN)
a1354 3

			fprintf(stderr, "%s: Path too long\n", dir);
			return(0);
a1355 6
		if (DT_REG != dp->d_type)
			continue;

		if (0 == strcmp(MANDOC_DB, fn) ||
				0 == strcmp(MANDOC_IDX, fn))
			continue;
d1368 7
d1401 3
@


1.4
log
@Fix two crashes that occur when walking very large (i.e. real-world) trees:
1) Avoid excessive, needless recursion lest you overflow the stack;
2) Close dir file descriptors, lest you run out of descriptors.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.3 2011/10/06 23:04:16 schwarze Exp $ */
d32 1
a33 2
#define	MANDOC_DB	 "mandoc.db"
#define	MANDOC_IDX	 "mandoc.index"
a36 16
/* Bit-fields.  See mandocdb.8. */

#define TYPE_NAME	  0x01
#define TYPE_FUNCTION	  0x02
#define TYPE_UTILITY	  0x04
#define TYPE_INCLUDES	  0x08
#define TYPE_VARIABLE	  0x10
#define TYPE_STANDARD	  0x20
#define TYPE_AUTHOR	  0x40
#define TYPE_CONFIG	  0x80
#define TYPE_DESC	  0x100
#define TYPE_XREF	  0x200
#define TYPE_PATH	  0x400
#define TYPE_ENV	  0x800
#define TYPE_ERR	  0x1000

d705 1
a705 1
	hash_put(hash, buf, TYPE_AUTHOR);
d766 1
a766 1
	hash_put(hash, buf, TYPE_INCLUDES);
d778 1
a778 1
	hash_put(hash, buf, TYPE_CONFIG);
d792 1
a792 1
	hash_put(hash, buf, TYPE_INCLUDES);
d818 1
a818 1
	hash_put(hash, buf, TYPE_FUNCTION);
d832 1
a832 1
	hash_put(hash, buf, TYPE_STANDARD);
d851 1
a851 1
	hash_put(hash, buf, TYPE_XREF);
d888 1
a888 1
	hash_put(hash, buf, TYPE_VARIABLE);
d902 1
a902 1
	hash_put(hash, buf, TYPE_FUNCTION);
d917 1
a917 1
	hash_put(hash, buf, TYPE_DESC);
d929 1
a929 1
	hash_put(hash, buf, TYPE_ERR);
d941 1
a941 1
	hash_put(hash, buf, TYPE_ENV);
d953 1
a953 1
	hash_put(hash, buf, TYPE_PATH);
d963 1
a963 1
		hash_put(hash, buf, TYPE_NAME);
d972 1
a972 1
	hash_put(hash, buf, TYPE_UTILITY);
d1102 1
a1102 1
				hash_put(hash, buf, TYPE_NAME);
d1141 1
a1141 1
			hash_put(hash, buf, TYPE_DESC);
@


1.3
log
@1) Import the future apropos(1) replacement written by kristaps@@.
2) Link both that one and mandocdb(8) into the mandoc(1) binary.
3) Install a /usr/bin/mandocdb hardlink and the mandocdb(8) manual.

Do not replace /usr/bin/apropos by a hardlink yet because it is
not ready for production, and ports integration is still missing.
Development will be done in the tree, even the user interfaces
are still subject to change at this point.

Both jmc@@ and deraadt@@ agree with getting this in.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.2 2011/09/17 13:45:28 schwarze Exp $ */
d1162 3
a1164 4
	if (pman_node(hash, buf, dbuf, n->child))
		return(1);
	if (pman_node(hash, buf, dbuf, n->next))
		return(1);
d1269 1
@


1.2
log
@Change the mandocdb(8) interface to better agree with makewhatis(8);
in particular, allow recursing multiple directories and create
multiple databases in one call.
This commit includes some reorganization, and exposing mandoc_strdup
as a utility function in mandoc.h.
written by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.1 2011/07/14 15:10:54 schwarze Exp $ */
d255 1
a255 1
main(int argc, char *argv[])
@


1.1
log
@Import mandocdb(8) from bsd.lv, coded by kristaps@@, for in-tree development.
Will need adjustments to user interface and functionality, and will be
linked into the mandoc(1) binary and hardlinked from /usr/libexec/mandocdb
to /usr/bin/mandoc when ready for general consumption.
The ultimate goal is to call it from OpenBSD::Makewhatis to replace
OpenBSD::Makewhatis::Unformated with enhanced functionality.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.1 2011/07/14 10:57:02 kristaps Exp $ */
d20 1
a35 1
#define	MANDOC_FLAGS	  O_CREAT|O_TRUNC|O_RDWR
d54 8
d66 2
a67 2
	size_t		  len;
	size_t		  size;
d74 1
a74 1
	OP_UPDATE, /* update entries in existing database */
d96 11
a257 2
	struct mdoc	*mdoc; /* resulting mdoc */
	struct man	*man; /* resulting man */
d259 1
a259 5
	char		*fn; /* current file being parsed */
	const char	*msec, /* manual section */
	      	 	*mtitle, /* manual title */
			*arch, /* manual architecture */
	      		*dir; /* result dir (default: cwd) */
d261 3
a263 3
			 fbuf[MAXPATHLEN],  /* btree fname */
			 vbuf[8]; /* stringified record number */
	int		 ch, seq, sseq, verb, i;
a266 3
	DBT		 key, val;
	enum mandoclevel ec; /* exit status */
	size_t		 sv;
d268 1
a268 2
	recno_t		 rec,
			 maxrec; /* supremum of all records */
d270 2
a271 1
	size_t		 recsz, /* buffer size of recs */
d275 1
a284 1
	dir = "";
d286 1
d294 1
a294 1
	ec = MANDOCLEVEL_SYSERR;
d296 1
a296 4
	memset(&buf, 0, sizeof(struct buf));
	memset(&dbuf, 0, sizeof(struct buf));

	while (-1 != (ch = getopt(argc, argv, "d:ruv")))
d300 1
d302 2
a303 1
		case ('r'):
a305 3
		case ('u'):
			op = OP_UPDATE;
			break;
d317 14
a330 2
	ibuf[0] = ibuf[MAXPATHLEN - 2] =
		fbuf[0] = fbuf[MAXPATHLEN - 2] = '\0';
d332 2
a333 2
	strlcat(fbuf, dir, MAXPATHLEN);
	strlcat(fbuf, MANDOC_DB, MAXPATHLEN);
d335 12
a346 2
	strlcat(ibuf, dir, MAXPATHLEN);
	strlcat(ibuf, MANDOC_IDX, MAXPATHLEN);
d348 2
a349 5
	if ('\0' != fbuf[MAXPATHLEN - 2] ||
			'\0' != ibuf[MAXPATHLEN - 2]) {
		fprintf(stderr, "%s: Path too long\n", dir);
		goto out;
	}
d351 7
a357 6
	/*
	 * For the keyword database, open a BTREE database that allows
	 * duplicates.  
	 * For the index database, use a standard RECNO database type.
	 * Truncate the database if we're creating a new one.
	 */
d359 4
a362 2
	memset(&info, 0, sizeof(BTREEINFO));
	info.flags = R_DUP;
d364 13
a376 7
	if (OP_NEW == op) {
		db = dbopen(fbuf, MANDOC_FLAGS, 0644, DB_BTREE, &info);
		idx = dbopen(ibuf, MANDOC_FLAGS, 0644, DB_RECNO, NULL);
	} else {
		db = dbopen(fbuf, O_CREAT|O_RDWR, 0644, DB_BTREE, &info);
		idx = dbopen(ibuf, O_CREAT|O_RDWR, 0644, DB_RECNO, NULL);
	}
a377 5
	if (NULL == db) {
		perror(fbuf);
		goto out;
	} else if (NULL == db) {
		perror(ibuf);
d381 18
a398 8
	/*
	 * If we're going to delete or update a database, remove the
	 * entries now (both the index and all keywords pointing to it).
	 * This doesn't actually remove them: it only sets their record
	 * value lengths to zero.
	 * While doing so, add the empty records to a list we'll access
	 * later in re-adding entries to the database.
	 */
d400 7
a406 15
	if (OP_DELETE == op || OP_UPDATE == op) {
		seq = R_FIRST;
		while (0 == (ch = (*idx->seq)(idx, &key, &val, seq))) {
			seq = R_NEXT;
			maxrec = *(recno_t *)key.data;
			if (0 == val.size && OP_UPDATE == op) {
				if (reccur >= recsz) {
					recsz += MANDOC_SLOP;
					recs = mandoc_realloc
						(recs, recsz * sizeof(recno_t));
				}
				recs[(int)reccur] = maxrec;
				reccur++;
				continue;
			}
d408 4
a411 4
			fn = (char *)val.data;
			for (i = 0; i < argc; i++)
				if (0 == strcmp(fn, argv[i]))
					break;
d413 2
a414 2
			if (i == argc)
				continue;
d416 2
a417 17
			sseq = R_FIRST;
			while (0 == (ch = (*db->seq)(db, &key, &val, sseq))) {
				sseq = R_NEXT;
				assert(8 == val.size);
				if (maxrec != *(recno_t *)(val.data + 4))
					continue;
				if (verb > 1)
					printf("%s: Deleted keyword: %s\n", 
						fn, (char *)key.data);
				ch = (*db->del)(db, &key, R_CURSOR);
				if (ch < 0)
					break;
			}
			if (ch < 0) {
				perror(fbuf);
				exit((int)MANDOCLEVEL_SYSERR);
			}
d419 2
a420 2
			if (verb)
				printf("%s: Deleted index\n", fn);
d422 1
a422 6
			val.size = 0;
			ch = (*idx->put)(idx, &key, &val, R_CURSOR);
			if (ch < 0) {
				perror(ibuf);
				exit((int)MANDOCLEVEL_SYSERR);
			}
d424 2
a425 11
			if (OP_UPDATE == op) {
				if (reccur >= recsz) {
					recsz += MANDOC_SLOP;
					recs = mandoc_realloc
						(recs, recsz * sizeof(recno_t));
				}
				recs[(int)reccur] = maxrec;
				reccur++;
			}
		}
		maxrec++;
d428 9
a436 4
	if (OP_DELETE == op) {
		ec = MANDOCLEVEL_OK;
		goto out;
	}
d438 4
a441 7
	/*
	 * Add records to the database.
	 * Try parsing each manual given on the command line.  
	 * If we fail, then emit an error and keep on going.  
	 * Take resulting trees and push them down into the database code.
	 * Use the auto-parser and don't report any errors.
	 */
d443 2
a444 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL);
d446 16
a461 3
	buf.size = dbuf.size = MANDOC_BUFSZ;
	buf.cp = mandoc_malloc(buf.size);
	dbuf.cp = mandoc_malloc(dbuf.size);
d463 8
a470 11
	for (rec = 0, i = 0; i < argc; i++) {
		fn = argv[i];
		if (OP_UPDATE == op) {
			if (reccur > 0) {
				--reccur;
				rec = recs[(int)reccur];
			} else if (maxrec > 0) {
				rec = maxrec;
				maxrec = 0;
			} else
				rec++;
d490 2
a491 1
		arch = NULL != mdoc ? mdoc_meta(mdoc)->arch : NULL;
d504 5
a508 5
		dbuf.len = 0;
		buf_appendb(&dbuf, fn, strlen(fn) + 1);
		buf_appendb(&dbuf, msec, strlen(msec) + 1);
		buf_appendb(&dbuf, mtitle, strlen(mtitle) + 1);
		buf_appendb(&dbuf, arch, strlen(arch) + 1);
d510 1
a510 1
		sv = dbuf.len;
d515 1
a515 1
			pmdoc_node(hash, &buf, &dbuf,
d518 1
a518 1
			pman_node(hash, &buf, &dbuf, man_node(man));
d537 3
a539 4
				printf("%s: Added keyword: %s, 0x%x\n", 
					fn, (char *)key.data, 
					*(int *)val.data);
			dbt_put(db, fbuf, &key, &val);
d551 2
a552 2
		if (dbuf.len == sv)
			buf_appendb(&dbuf, "", 1);
d557 2
a558 2
		val.data = dbuf.cp;
		val.size = dbuf.len;
d560 1
a560 1
		if (verb > 0)
d562 63
d626 2
a627 2
		dbt_put(idx, ibuf, &key, &val);
	}
d629 6
a634 10
	ec = MANDOCLEVEL_OK;
out:
	if (db)
		(*db->close)(db);
	if (idx)
		(*idx->close)(idx);
	if (hash)
		(*hash->close)(hash);
	if (mp)
		mparse_free(mp);
d636 5
a640 3
	free(buf.cp);
	free(dbuf.cp);
	free(recs);
d642 4
a645 1
	return((int)ec);
d733 1
a733 1
	*db = dbopen(NULL, MANDOC_FLAGS, 0644, DB_HASH, NULL);
d1171 116
d1290 4
a1293 2
	fprintf(stderr, "usage: %s [-ruv] [-d path] [file...]\n", 
			progname);
@

