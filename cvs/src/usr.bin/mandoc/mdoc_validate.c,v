head	1.262;
access;
symbols
	OPENBSD_6_1:1.235.0.4
	OPENBSD_6_1_BASE:1.235
	OPENBSD_6_0:1.217.0.4
	OPENBSD_6_0_BASE:1.217
	OPENBSD_5_9:1.217.0.2
	OPENBSD_5_9_BASE:1.217
	OPENBSD_5_8:1.207.0.4
	OPENBSD_5_8_BASE:1.207
	OPENBSD_5_7:1.199.0.2
	OPENBSD_5_7_BASE:1.199
	OPENBSD_5_6:1.148.0.4
	OPENBSD_5_6_BASE:1.148
	OPENBSD_5_5:1.121.0.4
	OPENBSD_5_5_BASE:1.121
	OPENBSD_5_4:1.109.0.4
	OPENBSD_5_4_BASE:1.109
	OPENBSD_5_3:1.109.0.2
	OPENBSD_5_3_BASE:1.109
	OPENBSD_5_2:1.107.0.2
	OPENBSD_5_2_BASE:1.107
	OPENBSD_5_1_BASE:1.100
	OPENBSD_5_1:1.100.0.2
	OPENBSD_5_0:1.93.0.2
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.88.0.2
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.67.0.2
	OPENBSD_4_8_BASE:1.67
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13;
locks; strict;
comment	@ * @;


1.262
date	2017.07.02.15.31.48;	author schwarze;	state Exp;
branches;
next	1.261;
commitid	AHLDG8sc9gJmviax;

1.261
date	2017.07.01.09.47.23;	author schwarze;	state Exp;
branches;
next	1.260;
commitid	bUWzoq61QcedQFz7;

1.260
date	2017.06.29.15.21.46;	author schwarze;	state Exp;
branches;
next	1.259;
commitid	GIZSbEspTHFlNqWu;

1.259
date	2017.06.27.12.17.35;	author schwarze;	state Exp;
branches;
next	1.258;
commitid	mxC186QEP83HxZ4x;

1.258
date	2017.06.25.17.42.37;	author schwarze;	state Exp;
branches;
next	1.257;
commitid	lU4NKBZiOj5pFGLJ;

1.257
date	2017.06.24.18.58.09;	author schwarze;	state Exp;
branches;
next	1.256;
commitid	Ml3HiKmSwGhhly92;

1.256
date	2017.06.24.15.59.28;	author schwarze;	state Exp;
branches;
next	1.255;
commitid	k99BPjhy9T1oDPrY;

1.255
date	2017.06.24.14.38.27;	author schwarze;	state Exp;
branches;
next	1.254;
commitid	ebFpCjoYaInwxToS;

1.254
date	2017.06.17.22.40.27;	author schwarze;	state Exp;
branches;
next	1.253;
commitid	eh9zSUWrW3gWUWkZ;

1.253
date	2017.06.11.20.02.48;	author schwarze;	state Exp;
branches;
next	1.252;
commitid	Srp1n0Vh67VPDfxe;

1.252
date	2017.06.11.19.36.31;	author schwarze;	state Exp;
branches;
next	1.251;
commitid	XRYVv5vPYVYMmfcL;

1.251
date	2017.06.11.17.16.36;	author schwarze;	state Exp;
branches;
next	1.250;
commitid	dPcvyya15rxVpblT;

1.250
date	2017.06.11.14.10.24;	author schwarze;	state Exp;
branches;
next	1.249;
commitid	n2shy00rWZc4bHGY;

1.249
date	2017.06.10.16.53.58;	author schwarze;	state Exp;
branches;
next	1.248;
commitid	8S95QVK2XRrKghjb;

1.248
date	2017.06.10.01.48.31;	author schwarze;	state Exp;
branches;
next	1.247;
commitid	GnqehULkzSOZe9a6;

1.247
date	2017.06.07.23.29.31;	author schwarze;	state Exp;
branches;
next	1.246;
commitid	ZGR4ldkhpkbOKKrj;

1.246
date	2017.06.01.15.24.41;	author schwarze;	state Exp;
branches;
next	1.245;
commitid	HpKDtV1c60HwJeIE;

1.245
date	2017.05.31.15.30.12;	author schwarze;	state Exp;
branches;
next	1.244;
commitid	JVG7q5p4I1jfXSdC;

1.244
date	2017.05.30.19.29.31;	author schwarze;	state Exp;
branches;
next	1.243;
commitid	aKw7GZmlWwBhe2SM;

1.243
date	2017.05.14.13.59.53;	author schwarze;	state Exp;
branches;
next	1.242;
commitid	6Z3UXBiVei0kgzkX;

1.242
date	2017.05.05.15.16.25;	author schwarze;	state Exp;
branches;
next	1.241;
commitid	sNJdFUhzoVfGBx2p;

1.241
date	2017.05.05.13.17.04;	author schwarze;	state Exp;
branches;
next	1.240;
commitid	GvSRKa33jIoa4JAJ;

1.240
date	2017.05.05.02.06.17;	author schwarze;	state Exp;
branches;
next	1.239;
commitid	JMX1RJlA2uFuu13l;

1.239
date	2017.05.04.17.48.24;	author schwarze;	state Exp;
branches;
next	1.238;
commitid	RHQLdCAdHKxKe8Eu;

1.238
date	2017.04.29.12.43.55;	author schwarze;	state Exp;
branches;
next	1.237;
commitid	7BLUwozNEzUO8xfK;

1.237
date	2017.04.28.16.23.30;	author schwarze;	state Exp;
branches;
next	1.236;
commitid	nV5MVbtsUqRIHwiv;

1.236
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.235;
commitid	2CfzvK3gmiJH7vY0;

1.235
date	2017.03.06.17.25.24;	author schwarze;	state Exp;
branches;
next	1.234;
commitid	T3Lyz7zZ1p6Y3Qbz;

1.234
date	2017.02.06.03.41.44;	author schwarze;	state Exp;
branches;
next	1.233;
commitid	FiEZU00RcX3pLlUS;

1.233
date	2017.01.11.17.39.45;	author schwarze;	state Exp;
branches;
next	1.232;
commitid	2X81lVBLl8eAHRVh;

1.232
date	2017.01.10.23.36.24;	author schwarze;	state Exp;
branches;
next	1.231;
commitid	1NsxjVXtIEKZm6T7;

1.231
date	2017.01.10.21.54.34;	author schwarze;	state Exp;
branches;
next	1.230;
commitid	iaEy6J4gJ8kh18cm;

1.230
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.229;
commitid	aFt8sLe7F06PjFYh;

1.229
date	2017.01.10.12.54.28;	author schwarze;	state Exp;
branches;
next	1.228;
commitid	vzXxeQWxUqXTMW9w;

1.228
date	2017.01.08.02.01.14;	author schwarze;	state Exp;
branches;
next	1.227;
commitid	qyybVQWQaMjZPO4r;

1.227
date	2017.01.08.00.10.22;	author schwarze;	state Exp;
branches;
next	1.226;
commitid	W4clzDItIfTolc66;

1.226
date	2016.12.28.17.21.17;	author schwarze;	state Exp;
branches;
next	1.225;
commitid	KjwyCoopqjkm90wM;

1.225
date	2016.10.09.18.16.46;	author schwarze;	state Exp;
branches;
next	1.224;
commitid	naY2DgYOKonEJYdH;

1.224
date	2016.08.20.14.43.39;	author schwarze;	state Exp;
branches;
next	1.223;
commitid	epkxu6NfanH6WQ2U;

1.223
date	2016.08.11.11.39.19;	author schwarze;	state Exp;
branches;
next	1.222;
commitid	s86Y12Z16pLJ0Zj7;

1.222
date	2016.08.11.10.46.27;	author schwarze;	state Exp;
branches;
next	1.221;
commitid	r67IJG8PHX3p1ma5;

1.221
date	2016.08.10.20.16.43;	author schwarze;	state Exp;
branches;
next	1.220;
commitid	jhFGW3zYObiKPB3w;

1.220
date	2016.08.10.12.29.02;	author schwarze;	state Exp;
branches;
next	1.219;
commitid	2v55nAn2mqzJQDGN;

1.219
date	2016.08.10.12.04.57;	author schwarze;	state Exp;
branches;
next	1.218;
commitid	0qnMgDuKR4zvxdnc;

1.218
date	2016.08.09.15.08.15;	author schwarze;	state Exp;
branches;
next	1.217;
commitid	0tR13xy4fWg1d9V8;

1.217
date	2016.01.08.17.48.04;	author schwarze;	state Exp;
branches;
next	1.216;
commitid	DoGoemryKYV644MI;

1.216
date	2015.10.30.19.03.36;	author schwarze;	state Exp;
branches;
next	1.215;
commitid	B2ZxW3H5UgZIgEOi;

1.215
date	2015.10.21.23.49.05;	author schwarze;	state Exp;
branches;
next	1.214;
commitid	shiLX2ph584rkqmV;

1.214
date	2015.10.20.02.00.49;	author schwarze;	state Exp;
branches;
next	1.213;
commitid	v6RrmxwM663z4mTF;

1.213
date	2015.10.19.20.03.57;	author schwarze;	state Exp;
branches;
next	1.212;
commitid	w1A4QkRoLR0q64Vt;

1.212
date	2015.10.12.21.25.36;	author schwarze;	state Exp;
branches;
next	1.211;
commitid	F85vaZTeTOSQeMvp;

1.211
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.210;
commitid	Ql2ha5NS80pwfGNT;

1.210
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.209;
commitid	hxQV8O1pNUaef4ir;

1.209
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.208;
commitid	191tWtskbsgcpQqV;

1.208
date	2015.09.14.15.35.47;	author schwarze;	state Exp;
branches;
next	1.207;
commitid	rmmzXNvCXUtwzubE;

1.207
date	2015.04.23.16.17.04;	author schwarze;	state Exp;
branches;
next	1.206;
commitid	DWHgiJTn6DvDpekX;

1.206
date	2015.04.20.09.48.19;	author schwarze;	state Exp;
branches;
next	1.205;
commitid	eBdWhIyrSEWQBsKg;

1.205
date	2015.04.19.14.25.05;	author schwarze;	state Exp;
branches;
next	1.204;
commitid	E1gJfKuheBoo64Vb;

1.204
date	2015.04.19.13.59.37;	author schwarze;	state Exp;
branches;
next	1.203;
commitid	aS3h5dIgZk0f7675;

1.203
date	2015.04.19.13.50.10;	author schwarze;	state Exp;
branches;
next	1.202;
commitid	QSaLMe5iBgPB4hUe;

1.202
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.201;
commitid	6MYJ7cd8mhJ77AGH;

1.201
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.200;
commitid	Rfx1oTaH3hZ7Zcyf;

1.200
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.199;
commitid	lmErjWY2O9ooA6RY;

1.199
date	2015.02.23.13.54.39;	author schwarze;	state Exp;
branches;
next	1.198;
commitid	UVaQMhGn2wsN4JNR;

1.198
date	2015.02.23.13.30.02;	author schwarze;	state Exp;
branches;
next	1.197;
commitid	0JG7TLVmNW4cori6;

1.197
date	2015.02.17.20.33.44;	author schwarze;	state Exp;
branches;
next	1.196;
commitid	bzSwTm9b9VF7LbRZ;

1.196
date	2015.02.16.19.02.32;	author schwarze;	state Exp;
branches;
next	1.195;
commitid	FIU2ZPmmtKgDK48N;

1.195
date	2015.02.14.13.22.12;	author schwarze;	state Exp;
branches;
next	1.194;
commitid	x3Yh4z9vciKKhq8k;

1.194
date	2015.02.12.12.20.47;	author schwarze;	state Exp;
branches;
next	1.193;
commitid	SViaEKzwzmf0o0kW;

1.193
date	2015.02.10.08.05.07;	author schwarze;	state Exp;
branches;
next	1.192;
commitid	udnlyXKeRKvRFGfq;

1.192
date	2015.02.06.16.05.51;	author schwarze;	state Exp;
branches;
next	1.191;
commitid	Bj9alpGWXCQILmH9;

1.191
date	2015.02.06.07.12.34;	author schwarze;	state Exp;
branches;
next	1.190;
commitid	QDbepmLqTNee3zgJ;

1.190
date	2015.02.06.03.31.11;	author schwarze;	state Exp;
branches;
next	1.189;
commitid	EGoCKP2gntS3HBlE;

1.189
date	2015.02.06.02.04.35;	author schwarze;	state Exp;
branches;
next	1.188;
commitid	ZI6u3EG8xLvfZl5l;

1.188
date	2015.02.06.01.07.07;	author schwarze;	state Exp;
branches;
next	1.187;
commitid	oDIjvdp0jkTBklvD;

1.187
date	2015.02.05.01.46.38;	author schwarze;	state Exp;
branches;
next	1.186;
commitid	Whyrd7T544leDR65;

1.186
date	2015.02.04.22.29.28;	author schwarze;	state Exp;
branches;
next	1.185;
commitid	IbbLBZeVYih9Ehjm;

1.185
date	2015.02.04.19.11.17;	author schwarze;	state Exp;
branches;
next	1.184;
commitid	PZMqCEcndQc8WcAL;

1.184
date	2015.02.04.18.03.28;	author schwarze;	state Exp;
branches;
next	1.183;
commitid	voy6CFtu7t43ZgbA;

1.183
date	2015.02.04.16.38.31;	author schwarze;	state Exp;
branches;
next	1.182;
commitid	MoF7T4hAk1bvNz7U;

1.182
date	2015.02.03.00.48.27;	author schwarze;	state Exp;
branches;
next	1.181;
commitid	YfyANUxCvB10IMDY;

1.181
date	2014.12.18.20.15.31;	author schwarze;	state Exp;
branches;
next	1.180;
commitid	CkFt17nQTCc3kns5;

1.180
date	2014.12.18.19.22.47;	author schwarze;	state Exp;
branches;
next	1.179;
commitid	gEOgPFvFGEiQs5LO;

1.179
date	2014.11.30.05.28.00;	author schwarze;	state Exp;
branches;
next	1.178;
commitid	4gOj8tbqcpkeLVbt;

1.178
date	2014.11.28.18.35.37;	author schwarze;	state Exp;
branches;
next	1.177;
commitid	C7yrJvu6v6cTTSgM;

1.177
date	2014.11.28.18.07.38;	author schwarze;	state Exp;
branches;
next	1.176;
commitid	FLjJT6vAqGK0xVjM;

1.176
date	2014.11.28.17.23.34;	author schwarze;	state Exp;
branches;
next	1.175;
commitid	KPB6oZLXpckMtSIh;

1.175
date	2014.11.28.01.05.40;	author schwarze;	state Exp;
branches;
next	1.174;
commitid	AyxWGi7Dr0LL0dRV;

1.174
date	2014.11.27.23.35.03;	author schwarze;	state Exp;
branches;
next	1.173;
commitid	h4lbTux1L5FzGMXy;

1.173
date	2014.11.27.16.20.27;	author schwarze;	state Exp;
branches;
next	1.172;
commitid	snF2JxsotuPud6ts;

1.172
date	2014.11.26.19.23.47;	author schwarze;	state Exp;
branches;
next	1.171;
commitid	N3DK42cTzpgDhcMl;

1.171
date	2014.11.17.06.44.35;	author schwarze;	state Exp;
branches;
next	1.170;
commitid	eO1CUhWjZNit4m47;

1.170
date	2014.10.30.20.05.33;	author schwarze;	state Exp;
branches;
next	1.169;
commitid	0MyCvIn2JIoyqJkI;

1.169
date	2014.10.13.14.01.03;	author schwarze;	state Exp;
branches;
next	1.168;
commitid	hBDxRc5sN1rjj2Lh;

1.168
date	2014.10.11.21.33.58;	author schwarze;	state Exp;
branches;
next	1.167;
commitid	gbaRSVU8ZtzeIUFY;

1.167
date	2014.10.11.21.14.11;	author schwarze;	state Exp;
branches;
next	1.166;
commitid	ArFLy7r4v7g9NTzH;

1.166
date	2014.09.12.00.53.21;	author schwarze;	state Exp;
branches;
next	1.165;
commitid	nVgiAqRo1hF16aAQ;

1.165
date	2014.09.11.23.52.47;	author schwarze;	state Exp;
branches;
next	1.164;
commitid	OL6L1tS4sl1FuVNA;

1.164
date	2014.09.07.23.24.33;	author schwarze;	state Exp;
branches;
next	1.163;
commitid	fhtI2THcHW6rewCo;

1.163
date	2014.09.07.00.04.47;	author schwarze;	state Exp;
branches;
next	1.162;
commitid	JW3D5jXuOqHC1Ka6;

1.162
date	2014.08.19.17.28.57;	author schwarze;	state Exp;
branches;
next	1.161;
commitid	H23kXubonCa9li7K;

1.161
date	2014.08.08.16.17.09;	author schwarze;	state Exp;
branches;
next	1.160;
commitid	TLMAnDXVMoqLltgG;

1.160
date	2014.08.08.16.11.10;	author schwarze;	state Exp;
branches;
next	1.159;
commitid	DQH8Q7VreNINE0C7;

1.159
date	2014.08.08.16.08.19;	author schwarze;	state Exp;
branches;
next	1.158;
commitid	g0HpAl6Jim48a9q4;

1.158
date	2014.08.08.15.57.05;	author schwarze;	state Exp;
branches;
next	1.157;
commitid	kusPy8TfXLTHQJo8;

1.157
date	2014.08.08.15.54.10;	author schwarze;	state Exp;
branches;
next	1.156;
commitid	yBKHNskikm52fHMo;

1.156
date	2014.08.08.15.45.58;	author schwarze;	state Exp;
branches;
next	1.155;
commitid	HtYC13kYxIr23M9f;

1.155
date	2014.08.08.15.42.39;	author schwarze;	state Exp;
branches;
next	1.154;
commitid	dIfosrluXZ6tTQFU;

1.154
date	2014.08.08.15.38.46;	author schwarze;	state Exp;
branches;
next	1.153;
commitid	0s9bQuCDRMV0Ke9L;

1.153
date	2014.08.08.15.26.28;	author schwarze;	state Exp;
branches;
next	1.152;
commitid	p7GwHxeS0xJRdvMp;

1.152
date	2014.08.08.15.21.17;	author schwarze;	state Exp;
branches;
next	1.151;
commitid	6Tv1eQzz4fj9QlUj;

1.151
date	2014.08.08.15.15.27;	author schwarze;	state Exp;
branches;
next	1.150;
commitid	fgZ1S3QYW6RU4QWI;

1.150
date	2014.08.08.15.10.15;	author schwarze;	state Exp;
branches;
next	1.149;
commitid	V6V8vpTM0RQ4gS7I;

1.149
date	2014.08.08.15.03.25;	author schwarze;	state Exp;
branches;
next	1.148;
commitid	IC4m7PBMv8EruQl8;

1.148
date	2014.07.07.16.12.06;	author schwarze;	state Exp;
branches;
next	1.147;
commitid	JkcWLt8pXBmAkPFj;

1.147
date	2014.07.06.19.08.56;	author schwarze;	state Exp;
branches;
next	1.146;
commitid	rolX8OitNNoUBJoD;

1.146
date	2014.07.05.12.33.54;	author schwarze;	state Exp;
branches;
next	1.145;
commitid	IbTbYyU1XoSImvHA;

1.145
date	2014.07.05.01.11.33;	author schwarze;	state Exp;
branches;
next	1.144;
commitid	xwzAVywNWdayFtqP;

1.144
date	2014.07.04.16.11.41;	author schwarze;	state Exp;
branches;
next	1.143;
commitid	sgqZ9hnRM3L6yvgn;

1.143
date	2014.07.04.01.50.03;	author schwarze;	state Exp;
branches;
next	1.142;
commitid	Y8kkUfI8kBY4R2Vw;

1.142
date	2014.07.03.23.23.45;	author schwarze;	state Exp;
branches;
next	1.141;
commitid	r0fsz0DrjbQnVa67;

1.141
date	2014.07.02.20.18.42;	author schwarze;	state Exp;
branches;
next	1.140;
commitid	9LBCQenwbyZCIKCe;

1.140
date	2014.07.02.19.54.39;	author schwarze;	state Exp;
branches;
next	1.139;
commitid	Yt0K01y5ZeXGGSxs;

1.139
date	2014.07.02.13.10.15;	author schwarze;	state Exp;
branches;
next	1.138;
commitid	Ao0fphsjJ98jbj9D;

1.138
date	2014.07.02.11.42.56;	author schwarze;	state Exp;
branches;
next	1.137;
commitid	aUdrdtDM8sKwymS7;

1.137
date	2014.07.02.05.51.49;	author schwarze;	state Exp;
branches;
next	1.136;
commitid	fKiFNFn6PyMDO56P;

1.136
date	2014.07.02.03.47.07;	author schwarze;	state Exp;
branches;
next	1.135;
commitid	p4pNII1v0bYCswy0;

1.135
date	2014.07.01.22.36.35;	author schwarze;	state Exp;
branches;
next	1.134;
commitid	6SNWblzmBTWk9YRA;

1.134
date	2014.06.20.22.58.41;	author schwarze;	state Exp;
branches;
next	1.133;
commitid	ktgkM223FL3EC6E8;

1.133
date	2014.06.20.17.23.09;	author schwarze;	state Exp;
branches;
next	1.132;
commitid	gTaF7NL9JpgvI2ni;

1.132
date	2014.04.23.21.06.33;	author schwarze;	state Exp;
branches;
next	1.131;

1.131
date	2014.04.23.16.07.06;	author schwarze;	state Exp;
branches;
next	1.130;

1.130
date	2014.04.20.20.48.34;	author schwarze;	state Exp;
branches;
next	1.129;

1.129
date	2014.04.20.19.39.35;	author schwarze;	state Exp;
branches;
next	1.128;

1.128
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.127;

1.127
date	2014.04.15.00.41.02;	author schwarze;	state Exp;
branches;
next	1.126;

1.126
date	2014.03.31.00.02.45;	author dlg;	state Exp;
branches;
next	1.125;

1.125
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.124;

1.124
date	2014.03.23.15.14.29;	author schwarze;	state Exp;
branches;
next	1.123;

1.123
date	2014.03.21.22.52.21;	author schwarze;	state Exp;
branches;
next	1.122;

1.122
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.121;

1.121
date	2014.02.16.14.26.51;	author schwarze;	state Exp;
branches;
next	1.120;

1.120
date	2014.01.11.22.16.03;	author schwarze;	state Exp;
branches;
next	1.119;

1.119
date	2014.01.07.09.10.58;	author schwarze;	state Exp;
branches;
next	1.118;

1.118
date	2014.01.06.22.39.19;	author schwarze;	state Exp;
branches;
next	1.117;

1.117
date	2014.01.06.00.53.14;	author schwarze;	state Exp;
branches;
next	1.116;

1.116
date	2013.12.15.21.18.00;	author schwarze;	state Exp;
branches;
next	1.115;

1.115
date	2013.10.21.23.32.33;	author schwarze;	state Exp;
branches;
next	1.114;

1.114
date	2013.10.06.22.45.13;	author schwarze;	state Exp;
branches;
next	1.113;

1.113
date	2013.10.06.13.27.47;	author schwarze;	state Exp;
branches;
next	1.112;

1.112
date	2013.10.03.19.32.25;	author schwarze;	state Exp;
branches;
next	1.111;

1.111
date	2013.09.16.00.25.06;	author schwarze;	state Exp;
branches;
next	1.110;

1.110
date	2013.08.05.14.32.56;	author schwarze;	state Exp;
branches;
next	1.109;

1.109
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.108;

1.108
date	2012.11.16.22.20.40;	author schwarze;	state Exp;
branches;
next	1.107;

1.107
date	2012.07.18.11.09.30;	author schwarze;	state Exp;
branches;
next	1.106;

1.106
date	2012.07.16.09.51.03;	author schwarze;	state Exp;
branches;
next	1.105;

1.105
date	2012.07.12.15.09.50;	author schwarze;	state Exp;
branches;
next	1.104;

1.104
date	2012.07.11.16.55.29;	author schwarze;	state Exp;
branches;
next	1.103;

1.103
date	2012.07.10.14.35.57;	author schwarze;	state Exp;
branches;
next	1.102;

1.102
date	2012.05.24.23.33.23;	author schwarze;	state Exp;
branches;
next	1.101;

1.101
date	2012.04.15.10.31.00;	author schwarze;	state Exp;
branches;
next	1.100;

1.100
date	2011.12.03.22.47.27;	author schwarze;	state Exp;
branches;
next	1.99;

1.99
date	2011.12.02.01.45.43;	author schwarze;	state Exp;
branches;
next	1.98;

1.98
date	2011.11.19.13.17.44;	author schwarze;	state Exp;
branches;
next	1.97;

1.97
date	2011.11.16.19.47.58;	author schwarze;	state Exp;
branches;
next	1.96;

1.96
date	2011.10.16.12.18.32;	author schwarze;	state Exp;
branches;
next	1.95;

1.95
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.94;

1.94
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.93;

1.93
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.92;

1.92
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.91;

1.91
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.90;

1.90
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.89;

1.89
date	2011.03.07.01.35.33;	author schwarze;	state Exp;
branches;
next	1.88;

1.88
date	2011.02.06.17.33.21;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2011.01.30.18.28.01;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2011.01.30.17.41.59;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2011.01.22.13.55.50;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2011.01.03.23.39.27;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2010.12.29.00.47.31;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2010.12.26.21.04.19;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2010.12.21.23.57.31;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2010.12.21.23.46.18;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2010.12.09.21.29.17;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2010.12.07.00.08.52;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2010.12.01.22.02.29;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2010.10.26.22.48.07;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2010.10.24.18.15.43;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2010.10.23.17.04.51;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2010.10.23.16.40.15;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2010.10.16.13.38.29;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2010.09.27.21.25.28;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2010.09.20.19.48.21;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2010.07.31.21.43.07;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2010.07.02.17.41.05;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2010.06.27.21.54.42;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2010.06.27.17.49.58;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.06.18.08.41;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2010.05.26.02.39.58;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.24.12.48.11;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.24.00.00.10;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2010.05.23.22.45.01;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2010.05.15.18.25.51;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2010.05.15.16.48.12;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2010.05.14.14.47.44;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2010.05.14.01.54.37;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2010.05.13.20.34.29;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.03.17.06.19;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2010.04.03.16.30.42;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.03.16.24.17;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.02.12.39.47;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.02.00.38.59;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2010.02.18.02.11.26;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.01.22.20.24;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2009.12.23.22.30.17;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.21.19.13.51;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.19.16.27.52;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2009.08.22.22.50.17;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.09.21.49.45;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.09.20.11.30;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.09.17.38.24;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.26.01.59.46;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.19.12.26.57;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.18.20.19.50;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.18.20.15.07;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.18.19.44.38;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.18.16.21.52;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.18.15.34.27;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.13.01.00.50;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.13.00.33.40;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.12.23.19.48;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.12.22.35.08;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.12.21.45.44;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.12.21.08.29;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.12.20.30.27;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.12.19.05.52;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.12.18.35.57;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.08.00.04.10;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.06.22.33.58;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.26.22.43.40;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.23.23.02.54;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.21.19.09.58;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.21.18.15.03;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.19.07.20.19;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.19.00.07.06;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.18.21.08.29;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.18.20.59.49;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.18.01.19.02;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.17.23.18.06;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.262
log
@add warning "cross reference to self"; inspired by mdoclint
@
text
@/*	$OpenBSD: mdoc_validate.c,v 1.261 2017/07/01 09:47:23 schwarze Exp $ */
/*
 * Copyright (c) 2008-2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2017 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2010 Joerg Sonnenberger <joerg@@netbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#ifndef OSNAME
#include <sys/utsname.h>
#endif

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "mandoc_xr.h"
#include "roff.h"
#include "mdoc.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libmdoc.h"

/* FIXME: .Bl -diag can't have non-text children in HEAD. */

#define	POST_ARGS struct roff_man *mdoc

enum	check_ineq {
	CHECK_LT,
	CHECK_GT,
	CHECK_EQ
};

typedef	void	(*v_post)(POST_ARGS);

static	int	 build_list(struct roff_man *, int);
static	void	 check_text(struct roff_man *, int, int, char *);
static	void	 check_argv(struct roff_man *,
			struct roff_node *, struct mdoc_argv *);
static	void	 check_args(struct roff_man *, struct roff_node *);
static	void	 check_toptext(struct roff_man *, int, int, const char *);
static	int	 child_an(const struct roff_node *);
static	size_t		macro2len(enum roff_tok);
static	void	 rewrite_macro2len(struct roff_man *, char **);
static	int	 similar(const char *, const char *);

static	void	 post_an(POST_ARGS);
static	void	 post_an_norm(POST_ARGS);
static	void	 post_at(POST_ARGS);
static	void	 post_bd(POST_ARGS);
static	void	 post_bf(POST_ARGS);
static	void	 post_bk(POST_ARGS);
static	void	 post_bl(POST_ARGS);
static	void	 post_bl_block(POST_ARGS);
static	void	 post_bl_head(POST_ARGS);
static	void	 post_bl_norm(POST_ARGS);
static	void	 post_bx(POST_ARGS);
static	void	 post_defaults(POST_ARGS);
static	void	 post_display(POST_ARGS);
static	void	 post_dd(POST_ARGS);
static	void	 post_delim(POST_ARGS);
static	void	 post_dt(POST_ARGS);
static	void	 post_en(POST_ARGS);
static	void	 post_es(POST_ARGS);
static	void	 post_eoln(POST_ARGS);
static	void	 post_ex(POST_ARGS);
static	void	 post_fa(POST_ARGS);
static	void	 post_fn(POST_ARGS);
static	void	 post_fname(POST_ARGS);
static	void	 post_fo(POST_ARGS);
static	void	 post_hyph(POST_ARGS);
static	void	 post_ignpar(POST_ARGS);
static	void	 post_it(POST_ARGS);
static	void	 post_lb(POST_ARGS);
static	void	 post_nd(POST_ARGS);
static	void	 post_nm(POST_ARGS);
static	void	 post_ns(POST_ARGS);
static	void	 post_obsolete(POST_ARGS);
static	void	 post_os(POST_ARGS);
static	void	 post_par(POST_ARGS);
static	void	 post_prevpar(POST_ARGS);
static	void	 post_root(POST_ARGS);
static	void	 post_rs(POST_ARGS);
static	void	 post_rv(POST_ARGS);
static	void	 post_sh(POST_ARGS);
static	void	 post_sh_head(POST_ARGS);
static	void	 post_sh_name(POST_ARGS);
static	void	 post_sh_see_also(POST_ARGS);
static	void	 post_sh_authors(POST_ARGS);
static	void	 post_sm(POST_ARGS);
static	void	 post_st(POST_ARGS);
static	void	 post_std(POST_ARGS);
static	void	 post_useless(POST_ARGS);
static	void	 post_xr(POST_ARGS);
static	void	 post_xx(POST_ARGS);

static	const v_post __mdoc_valids[MDOC_MAX - MDOC_Dd] = {
	post_dd,	/* Dd */
	post_dt,	/* Dt */
	post_os,	/* Os */
	post_sh,	/* Sh */
	post_ignpar,	/* Ss */
	post_par,	/* Pp */
	post_display,	/* D1 */
	post_display,	/* Dl */
	post_display,	/* Bd */
	NULL,		/* Ed */
	post_bl,	/* Bl */
	NULL,		/* El */
	post_it,	/* It */
	post_delim,	/* Ad */
	post_an,	/* An */
	NULL,		/* Ap */
	post_defaults,	/* Ar */
	NULL,		/* Cd */
	post_delim,	/* Cm */
	post_delim,	/* Dv */
	post_delim,	/* Er */
	post_delim,	/* Ev */
	post_ex,	/* Ex */
	post_fa,	/* Fa */
	NULL,		/* Fd */
	post_delim,	/* Fl */
	post_fn,	/* Fn */
	post_delim,	/* Ft */
	post_delim,	/* Ic */
	post_delim,	/* In */
	post_defaults,	/* Li */
	post_nd,	/* Nd */
	post_nm,	/* Nm */
	post_delim,	/* Op */
	post_obsolete,	/* Ot */
	post_defaults,	/* Pa */
	post_rv,	/* Rv */
	post_st,	/* St */
	post_delim,	/* Va */
	post_delim,	/* Vt */
	post_xr,	/* Xr */
	NULL,		/* %A */
	post_hyph,	/* %B */ /* FIXME: can be used outside Rs/Re. */
	NULL,		/* %D */
	NULL,		/* %I */
	NULL,		/* %J */
	post_hyph,	/* %N */
	post_hyph,	/* %O */
	NULL,		/* %P */
	post_hyph,	/* %R */
	post_hyph,	/* %T */ /* FIXME: can be used outside Rs/Re. */
	NULL,		/* %V */
	NULL,		/* Ac */
	post_delim,	/* Ao */
	post_delim,	/* Aq */
	post_at,	/* At */
	NULL,		/* Bc */
	post_bf,	/* Bf */
	post_delim,	/* Bo */
	NULL,		/* Bq */
	post_xx,	/* Bsx */
	post_bx,	/* Bx */
	post_obsolete,	/* Db */
	NULL,		/* Dc */
	NULL,		/* Do */
	NULL,		/* Dq */
	NULL,		/* Ec */
	NULL,		/* Ef */
	post_delim,	/* Em */
	NULL,		/* Eo */
	post_xx,	/* Fx */
	post_delim,	/* Ms */
	NULL,		/* No */
	post_ns,	/* Ns */
	post_xx,	/* Nx */
	post_xx,	/* Ox */
	NULL,		/* Pc */
	NULL,		/* Pf */
	post_delim,	/* Po */
	post_delim,	/* Pq */
	NULL,		/* Qc */
	post_delim,	/* Ql */
	post_delim,	/* Qo */
	post_delim,	/* Qq */
	NULL,		/* Re */
	post_rs,	/* Rs */
	NULL,		/* Sc */
	post_delim,	/* So */
	post_delim,	/* Sq */
	post_sm,	/* Sm */
	post_hyph,	/* Sx */
	post_delim,	/* Sy */
	post_useless,	/* Tn */
	post_xx,	/* Ux */
	NULL,		/* Xc */
	NULL,		/* Xo */
	post_fo,	/* Fo */
	NULL,		/* Fc */
	post_delim,	/* Oo */
	NULL,		/* Oc */
	post_bk,	/* Bk */
	NULL,		/* Ek */
	post_eoln,	/* Bt */
	post_obsolete,	/* Hf */
	post_obsolete,	/* Fr */
	post_eoln,	/* Ud */
	post_lb,	/* Lb */
	post_par,	/* Lp */
	post_delim,	/* Lk */
	post_defaults,	/* Mt */
	post_delim,	/* Brq */
	post_delim,	/* Bro */
	NULL,		/* Brc */
	NULL,		/* %C */
	post_es,	/* Es */
	post_en,	/* En */
	post_xx,	/* Dx */
	NULL,		/* %Q */
	NULL,		/* %U */
	NULL,		/* Ta */
};
static	const v_post *const mdoc_valids = __mdoc_valids - MDOC_Dd;

#define	RSORD_MAX 14 /* Number of `Rs' blocks. */

static	const enum roff_tok rsord[RSORD_MAX] = {
	MDOC__A,
	MDOC__T,
	MDOC__B,
	MDOC__I,
	MDOC__J,
	MDOC__R,
	MDOC__N,
	MDOC__V,
	MDOC__U,
	MDOC__P,
	MDOC__Q,
	MDOC__C,
	MDOC__D,
	MDOC__O
};

static	const char * const secnames[SEC__MAX] = {
	NULL,
	"NAME",
	"LIBRARY",
	"SYNOPSIS",
	"DESCRIPTION",
	"CONTEXT",
	"IMPLEMENTATION NOTES",
	"RETURN VALUES",
	"ENVIRONMENT",
	"FILES",
	"EXIT STATUS",
	"EXAMPLES",
	"DIAGNOSTICS",
	"COMPATIBILITY",
	"ERRORS",
	"SEE ALSO",
	"STANDARDS",
	"HISTORY",
	"AUTHORS",
	"CAVEATS",
	"BUGS",
	"SECURITY CONSIDERATIONS",
	NULL
};


void
mdoc_node_validate(struct roff_man *mdoc)
{
	struct roff_node *n;
	const v_post *p;

	n = mdoc->last;
	mdoc->last = mdoc->last->child;
	while (mdoc->last != NULL) {
		mdoc_node_validate(mdoc);
		if (mdoc->last == n)
			mdoc->last = mdoc->last->child;
		else
			mdoc->last = mdoc->last->next;
	}

	mdoc->last = n;
	mdoc->next = ROFF_NEXT_SIBLING;
	switch (n->type) {
	case ROFFT_TEXT:
		if (n->sec != SEC_SYNOPSIS ||
		    (n->parent->tok != MDOC_Cd && n->parent->tok != MDOC_Fd))
			check_text(mdoc, n->line, n->pos, n->string);
		if (n->parent->tok == MDOC_It ||
		    (n->parent->type == ROFFT_BODY &&
		     (n->parent->tok == MDOC_Sh ||
		      n->parent->tok == MDOC_Ss)))
			check_toptext(mdoc, n->line, n->pos, n->string);
		break;
	case ROFFT_EQN:
	case ROFFT_TBL:
		break;
	case ROFFT_ROOT:
		post_root(mdoc);
		break;
	default:
		check_args(mdoc, mdoc->last);

		/*
		 * Closing delimiters are not special at the
		 * beginning of a block, opening delimiters
		 * are not special at the end.
		 */

		if (n->child != NULL)
			n->child->flags &= ~NODE_DELIMC;
		if (n->last != NULL)
			n->last->flags &= ~NODE_DELIMO;

		/* Call the macro's postprocessor. */

		if (n->tok < ROFF_MAX) {
			switch(n->tok) {
			case ROFF_br:
			case ROFF_sp:
				post_par(mdoc);
				break;
			default:
				roff_validate(mdoc);
				break;
			}
			break;
		}

		assert(n->tok >= MDOC_Dd && n->tok < MDOC_MAX);
		p = mdoc_valids + n->tok;
		if (*p)
			(*p)(mdoc);
		if (mdoc->last == n)
			mdoc_state(mdoc, n);
		break;
	}
}

static void
check_args(struct roff_man *mdoc, struct roff_node *n)
{
	int		 i;

	if (NULL == n->args)
		return;

	assert(n->args->argc);
	for (i = 0; i < (int)n->args->argc; i++)
		check_argv(mdoc, n, &n->args->argv[i]);
}

static void
check_argv(struct roff_man *mdoc, struct roff_node *n, struct mdoc_argv *v)
{
	int		 i;

	for (i = 0; i < (int)v->sz; i++)
		check_text(mdoc, v->line, v->pos, v->value[i]);
}

static void
check_text(struct roff_man *mdoc, int ln, int pos, char *p)
{
	char		*cp;

	if (MDOC_LITERAL & mdoc->flags)
		return;

	for (cp = p; NULL != (p = strchr(p, '\t')); p++)
		mandoc_msg(MANDOCERR_FI_TAB, mdoc->parse,
		    ln, pos + (int)(p - cp), NULL);
}

static void
check_toptext(struct roff_man *mdoc, int ln, int pos, const char *p)
{
	const char	*cp, *cpr;

	if (*p == '\0')
		return;

	if ((cp = strstr(p, "OpenBSD")) != NULL)
		mandoc_msg(MANDOCERR_BX, mdoc->parse,
		    ln, pos + (cp - p), "Ox");
	if ((cp = strstr(p, "NetBSD")) != NULL)
		mandoc_msg(MANDOCERR_BX, mdoc->parse,
		    ln, pos + (cp - p), "Nx");
	if ((cp = strstr(p, "FreeBSD")) != NULL)
		mandoc_msg(MANDOCERR_BX, mdoc->parse,
		    ln, pos + (cp - p), "Fx");
	if ((cp = strstr(p, "DragonFly")) != NULL)
		mandoc_msg(MANDOCERR_BX, mdoc->parse,
		    ln, pos + (cp - p), "Dx");

	cp = p;
	while ((cp = strstr(cp + 1, "()")) != NULL) {
		for (cpr = cp - 1; cpr >= p; cpr--)
			if (*cpr != '_' && !isalnum((unsigned char)*cpr))
				break;
		if ((cpr < p || *cpr == ' ') && cpr + 1 < cp) {
			cpr++;
			mandoc_vmsg(MANDOCERR_FUNC, mdoc->parse,
			    ln, pos + (cpr - p),
			    "%.*s()", (int)(cp - cpr), cpr);
		}
	}
}

static void
post_delim(POST_ARGS)
{
	const struct roff_node	*nch;
	const char		*lc, *cp;
	int			 nw;
	enum mdelim		 delim;
	enum roff_tok		 tok;

	/*
	 * Find candidates: at least two bytes,
	 * the last one a closing or middle delimiter.
	 */

	tok = mdoc->last->tok;
	nch = mdoc->last->last;
	if (nch == NULL || nch->type != ROFFT_TEXT)
		return;
	lc = strchr(nch->string, '\0') - 1;
	if (lc <= nch->string)
		return;
	delim = mdoc_isdelim(lc);
	if (delim == DELIM_NONE || delim == DELIM_OPEN)
		return;

	/*
	 * Reduce false positives by allowing various cases.
	 */

	/* Escaped delimiters. */
	if (lc > nch->string + 1 && lc[-2] == '\\' &&
	    (lc[-1] == '&' || lc[-1] == 'e'))
		return;

	/* Specific byte sequences. */
	switch (*lc) {
	case ')':
		for (cp = lc; cp >= nch->string; cp--)
			if (*cp == '(')
				return;
		break;
	case '.':
		if (lc > nch->string + 1 && lc[-2] == '.' && lc[-1] == '.')
			return;
		if (lc[-1] == '.')
			return;
		break;
	case ';':
		if (tok == MDOC_Vt)
			return;
		break;
	case '?':
		if (lc[-1] == '?')
			return;
		break;
	case ']':
		for (cp = lc; cp >= nch->string; cp--)
			if (*cp == '[')
				return;
		break;
	case '|':
		if (lc == nch->string + 1 && lc[-1] == '|')
			return;
	default:
		break;
	}

	/* Exactly two non-alphanumeric bytes. */
	if (lc == nch->string + 1 && !isalnum((unsigned char)lc[-1]))
		return;

	/* At least three alphabetic words with a sentence ending. */
	if (strchr("!.:?", *lc) != NULL && (tok == MDOC_Em ||
	    tok == MDOC_Li || tok == MDOC_Po || tok == MDOC_Pq ||
	    tok == MDOC_Sy)) {
		nw = 0;
		for (cp = lc - 1; cp >= nch->string; cp--) {
			if (*cp == ' ') {
				nw++;
				if (cp > nch->string && cp[-1] == ',')
					cp--;
			} else if (isalpha((unsigned int)*cp)) {
				if (nw > 1)
					return;
			} else
				break;
		}
	}

	mandoc_vmsg(MANDOCERR_DELIM, mdoc->parse,
	    nch->line, nch->pos + (lc - nch->string),
	    "%s%s %s", roff_name[tok],
	    nch == mdoc->last->child ? "" : " ...", nch->string);
}

static void
post_bl_norm(POST_ARGS)
{
	struct roff_node *n;
	struct mdoc_argv *argv, *wa;
	int		  i;
	enum mdocargt	  mdoclt;
	enum mdoc_list	  lt;

	n = mdoc->last->parent;
	n->norm->Bl.type = LIST__NONE;

	/*
	 * First figure out which kind of list to use: bind ourselves to
	 * the first mentioned list type and warn about any remaining
	 * ones.  If we find no list type, we default to LIST_item.
	 */

	wa = (n->args == NULL) ? NULL : n->args->argv;
	mdoclt = MDOC_ARG_MAX;
	for (i = 0; n->args && i < (int)n->args->argc; i++) {
		argv = n->args->argv + i;
		lt = LIST__NONE;
		switch (argv->arg) {
		/* Set list types. */
		case MDOC_Bullet:
			lt = LIST_bullet;
			break;
		case MDOC_Dash:
			lt = LIST_dash;
			break;
		case MDOC_Enum:
			lt = LIST_enum;
			break;
		case MDOC_Hyphen:
			lt = LIST_hyphen;
			break;
		case MDOC_Item:
			lt = LIST_item;
			break;
		case MDOC_Tag:
			lt = LIST_tag;
			break;
		case MDOC_Diag:
			lt = LIST_diag;
			break;
		case MDOC_Hang:
			lt = LIST_hang;
			break;
		case MDOC_Ohang:
			lt = LIST_ohang;
			break;
		case MDOC_Inset:
			lt = LIST_inset;
			break;
		case MDOC_Column:
			lt = LIST_column;
			break;
		/* Set list arguments. */
		case MDOC_Compact:
			if (n->norm->Bl.comp)
				mandoc_msg(MANDOCERR_ARG_REP,
				    mdoc->parse, argv->line,
				    argv->pos, "Bl -compact");
			n->norm->Bl.comp = 1;
			break;
		case MDOC_Width:
			wa = argv;
			if (0 == argv->sz) {
				mandoc_msg(MANDOCERR_ARG_EMPTY,
				    mdoc->parse, argv->line,
				    argv->pos, "Bl -width");
				n->norm->Bl.width = "0n";
				break;
			}
			if (NULL != n->norm->Bl.width)
				mandoc_vmsg(MANDOCERR_ARG_REP,
				    mdoc->parse, argv->line,
				    argv->pos, "Bl -width %s",
				    argv->value[0]);
			rewrite_macro2len(mdoc, argv->value);
			n->norm->Bl.width = argv->value[0];
			break;
		case MDOC_Offset:
			if (0 == argv->sz) {
				mandoc_msg(MANDOCERR_ARG_EMPTY,
				    mdoc->parse, argv->line,
				    argv->pos, "Bl -offset");
				break;
			}
			if (NULL != n->norm->Bl.offs)
				mandoc_vmsg(MANDOCERR_ARG_REP,
				    mdoc->parse, argv->line,
				    argv->pos, "Bl -offset %s",
				    argv->value[0]);
			rewrite_macro2len(mdoc, argv->value);
			n->norm->Bl.offs = argv->value[0];
			break;
		default:
			continue;
		}
		if (LIST__NONE == lt)
			continue;
		mdoclt = argv->arg;

		/* Check: multiple list types. */

		if (LIST__NONE != n->norm->Bl.type) {
			mandoc_vmsg(MANDOCERR_BL_REP,
			    mdoc->parse, n->line, n->pos,
			    "Bl -%s", mdoc_argnames[argv->arg]);
			continue;
		}

		/* The list type should come first. */

		if (n->norm->Bl.width ||
		    n->norm->Bl.offs ||
		    n->norm->Bl.comp)
			mandoc_vmsg(MANDOCERR_BL_LATETYPE,
			    mdoc->parse, n->line, n->pos, "Bl -%s",
			    mdoc_argnames[n->args->argv[0].arg]);

		n->norm->Bl.type = lt;
		if (LIST_column == lt) {
			n->norm->Bl.ncols = argv->sz;
			n->norm->Bl.cols = (void *)argv->value;
		}
	}

	/* Allow lists to default to LIST_item. */

	if (LIST__NONE == n->norm->Bl.type) {
		mandoc_msg(MANDOCERR_BL_NOTYPE, mdoc->parse,
		    n->line, n->pos, "Bl");
		n->norm->Bl.type = LIST_item;
		mdoclt = MDOC_Item;
	}

	/*
	 * Validate the width field.  Some list types don't need width
	 * types and should be warned about them.  Others should have it
	 * and must also be warned.  Yet others have a default and need
	 * no warning.
	 */

	switch (n->norm->Bl.type) {
	case LIST_tag:
		if (NULL == n->norm->Bl.width)
			mandoc_msg(MANDOCERR_BL_NOWIDTH, mdoc->parse,
			    n->line, n->pos, "Bl -tag");
		break;
	case LIST_column:
	case LIST_diag:
	case LIST_ohang:
	case LIST_inset:
	case LIST_item:
		if (n->norm->Bl.width)
			mandoc_vmsg(MANDOCERR_BL_SKIPW, mdoc->parse,
			    wa->line, wa->pos, "Bl -%s",
			    mdoc_argnames[mdoclt]);
		break;
	case LIST_bullet:
	case LIST_dash:
	case LIST_hyphen:
		if (NULL == n->norm->Bl.width)
			n->norm->Bl.width = "2n";
		break;
	case LIST_enum:
		if (NULL == n->norm->Bl.width)
			n->norm->Bl.width = "3n";
		break;
	default:
		break;
	}
}

static void
post_bd(POST_ARGS)
{
	struct roff_node *n;
	struct mdoc_argv *argv;
	int		  i;
	enum mdoc_disp	  dt;

	n = mdoc->last;
	for (i = 0; n->args && i < (int)n->args->argc; i++) {
		argv = n->args->argv + i;
		dt = DISP__NONE;

		switch (argv->arg) {
		case MDOC_Centred:
			dt = DISP_centered;
			break;
		case MDOC_Ragged:
			dt = DISP_ragged;
			break;
		case MDOC_Unfilled:
			dt = DISP_unfilled;
			break;
		case MDOC_Filled:
			dt = DISP_filled;
			break;
		case MDOC_Literal:
			dt = DISP_literal;
			break;
		case MDOC_File:
			mandoc_msg(MANDOCERR_BD_FILE, mdoc->parse,
			    n->line, n->pos, NULL);
			break;
		case MDOC_Offset:
			if (0 == argv->sz) {
				mandoc_msg(MANDOCERR_ARG_EMPTY,
				    mdoc->parse, argv->line,
				    argv->pos, "Bd -offset");
				break;
			}
			if (NULL != n->norm->Bd.offs)
				mandoc_vmsg(MANDOCERR_ARG_REP,
				    mdoc->parse, argv->line,
				    argv->pos, "Bd -offset %s",
				    argv->value[0]);
			rewrite_macro2len(mdoc, argv->value);
			n->norm->Bd.offs = argv->value[0];
			break;
		case MDOC_Compact:
			if (n->norm->Bd.comp)
				mandoc_msg(MANDOCERR_ARG_REP,
				    mdoc->parse, argv->line,
				    argv->pos, "Bd -compact");
			n->norm->Bd.comp = 1;
			break;
		default:
			abort();
		}
		if (DISP__NONE == dt)
			continue;

		if (DISP__NONE == n->norm->Bd.type)
			n->norm->Bd.type = dt;
		else
			mandoc_vmsg(MANDOCERR_BD_REP,
			    mdoc->parse, n->line, n->pos,
			    "Bd -%s", mdoc_argnames[argv->arg]);
	}

	if (DISP__NONE == n->norm->Bd.type) {
		mandoc_msg(MANDOCERR_BD_NOTYPE, mdoc->parse,
		    n->line, n->pos, "Bd");
		n->norm->Bd.type = DISP_ragged;
	}
}

/*
 * Stand-alone line macros.
 */

static void
post_an_norm(POST_ARGS)
{
	struct roff_node *n;
	struct mdoc_argv *argv;
	size_t	 i;

	n = mdoc->last;
	if (n->args == NULL)
		return;

	for (i = 1; i < n->args->argc; i++) {
		argv = n->args->argv + i;
		mandoc_vmsg(MANDOCERR_AN_REP,
		    mdoc->parse, argv->line, argv->pos,
		    "An -%s", mdoc_argnames[argv->arg]);
	}

	argv = n->args->argv;
	if (argv->arg == MDOC_Split)
		n->norm->An.auth = AUTH_split;
	else if (argv->arg == MDOC_Nosplit)
		n->norm->An.auth = AUTH_nosplit;
	else
		abort();
}

static void
post_eoln(POST_ARGS)
{
	struct roff_node	*n;

	post_useless(mdoc);
	n = mdoc->last;
	if (n->child != NULL)
		mandoc_vmsg(MANDOCERR_ARG_SKIP, mdoc->parse, n->line,
		    n->pos, "%s %s", roff_name[n->tok], n->child->string);

	while (n->child != NULL)
		roff_node_delete(mdoc, n->child);

	roff_word_alloc(mdoc, n->line, n->pos, n->tok == MDOC_Bt ?
	    "is currently in beta test." : "currently under development.");
	mdoc->last->flags |= NODE_EOS | NODE_NOSRC;
	mdoc->last = n;
}

static int
build_list(struct roff_man *mdoc, int tok)
{
	struct roff_node	*n;
	int			 ic;

	n = mdoc->last->next;
	for (ic = 1;; ic++) {
		roff_elem_alloc(mdoc, n->line, n->pos, tok);
		mdoc->last->flags |= NODE_NOSRC;
		mdoc_node_relink(mdoc, n);
		n = mdoc->last = mdoc->last->parent;
		mdoc->next = ROFF_NEXT_SIBLING;
		if (n->next == NULL)
			return ic;
		if (ic > 1 || n->next->next != NULL) {
			roff_word_alloc(mdoc, n->line, n->pos, ",");
			mdoc->last->flags |= NODE_DELIMC | NODE_NOSRC;
		}
		n = mdoc->last->next;
		if (n->next == NULL) {
			roff_word_alloc(mdoc, n->line, n->pos, "and");
			mdoc->last->flags |= NODE_NOSRC;
		}
	}
}

static void
post_ex(POST_ARGS)
{
	struct roff_node	*n;
	int			 ic;

	post_std(mdoc);

	n = mdoc->last;
	mdoc->next = ROFF_NEXT_CHILD;
	roff_word_alloc(mdoc, n->line, n->pos, "The");
	mdoc->last->flags |= NODE_NOSRC;

	if (mdoc->last->next != NULL)
		ic = build_list(mdoc, MDOC_Nm);
	else if (mdoc->meta.name != NULL) {
		roff_elem_alloc(mdoc, n->line, n->pos, MDOC_Nm);
		mdoc->last->flags |= NODE_NOSRC;
		roff_word_alloc(mdoc, n->line, n->pos, mdoc->meta.name);
		mdoc->last->flags |= NODE_NOSRC;
		mdoc->last = mdoc->last->parent;
		mdoc->next = ROFF_NEXT_SIBLING;
		ic = 1;
	} else {
		mandoc_msg(MANDOCERR_EX_NONAME, mdoc->parse,
		    n->line, n->pos, "Ex");
		ic = 0;
	}

	roff_word_alloc(mdoc, n->line, n->pos,
	    ic > 1 ? "utilities exit\\~0" : "utility exits\\~0");
	mdoc->last->flags |= NODE_NOSRC;
	roff_word_alloc(mdoc, n->line, n->pos,
	    "on success, and\\~>0 if an error occurs.");
	mdoc->last->flags |= NODE_EOS | NODE_NOSRC;
	mdoc->last = n;
}

static void
post_lb(POST_ARGS)
{
	struct roff_node	*n;

	post_delim(mdoc);

	n = mdoc->last;
	assert(n->child->type == ROFFT_TEXT);
	mdoc->next = ROFF_NEXT_CHILD;
	roff_word_alloc(mdoc, n->line, n->pos, "library");
	mdoc->last->flags = NODE_NOSRC;
	roff_word_alloc(mdoc, n->line, n->pos, "\\(Lq");
	mdoc->last->flags = NODE_DELIMO | NODE_NOSRC;
	mdoc->last = mdoc->last->next;
	roff_word_alloc(mdoc, n->line, n->pos, "\\(Rq");
	mdoc->last->flags = NODE_DELIMC | NODE_NOSRC;
	mdoc->last = n;
}

static void
post_rv(POST_ARGS)
{
	struct roff_node	*n;
	int			 ic;

	post_std(mdoc);

	n = mdoc->last;
	mdoc->next = ROFF_NEXT_CHILD;
	if (n->child != NULL) {
		roff_word_alloc(mdoc, n->line, n->pos, "The");
		mdoc->last->flags |= NODE_NOSRC;
		ic = build_list(mdoc, MDOC_Fn);
		roff_word_alloc(mdoc, n->line, n->pos,
		    ic > 1 ? "functions return" : "function returns");
		mdoc->last->flags |= NODE_NOSRC;
		roff_word_alloc(mdoc, n->line, n->pos,
		    "the value\\~0 if successful;");
	} else
		roff_word_alloc(mdoc, n->line, n->pos, "Upon successful "
		    "completion, the value\\~0 is returned;");
	mdoc->last->flags |= NODE_NOSRC;

	roff_word_alloc(mdoc, n->line, n->pos, "otherwise "
	    "the value\\~\\-1 is returned and the global variable");
	mdoc->last->flags |= NODE_NOSRC;
	roff_elem_alloc(mdoc, n->line, n->pos, MDOC_Va);
	mdoc->last->flags |= NODE_NOSRC;
	roff_word_alloc(mdoc, n->line, n->pos, "errno");
	mdoc->last->flags |= NODE_NOSRC;
	mdoc->last = mdoc->last->parent;
	mdoc->next = ROFF_NEXT_SIBLING;
	roff_word_alloc(mdoc, n->line, n->pos,
	    "is set to indicate the error.");
	mdoc->last->flags |= NODE_EOS | NODE_NOSRC;
	mdoc->last = n;
}

static void
post_std(POST_ARGS)
{
	struct roff_node *n;

	n = mdoc->last;
	if (n->args && n->args->argc == 1)
		if (n->args->argv[0].arg == MDOC_Std)
			return;

	mandoc_msg(MANDOCERR_ARG_STD, mdoc->parse,
	    n->line, n->pos, roff_name[n->tok]);
}

static void
post_st(POST_ARGS)
{
	struct roff_node	 *n, *nch;
	const char		 *p;

	n = mdoc->last;
	nch = n->child;
	assert(nch->type == ROFFT_TEXT);

	if ((p = mdoc_a2st(nch->string)) == NULL) {
		mandoc_vmsg(MANDOCERR_ST_BAD, mdoc->parse,
		    nch->line, nch->pos, "St %s", nch->string);
		roff_node_delete(mdoc, n);
		return;
	}

	nch->flags |= NODE_NOPRT;
	mdoc->next = ROFF_NEXT_CHILD;
	roff_word_alloc(mdoc, nch->line, nch->pos, p);
	mdoc->last->flags |= NODE_NOSRC;
	mdoc->last= n;
}

static void
post_obsolete(POST_ARGS)
{
	struct roff_node *n;

	n = mdoc->last;
	if (n->type == ROFFT_ELEM || n->type == ROFFT_BLOCK)
		mandoc_msg(MANDOCERR_MACRO_OBS, mdoc->parse,
		    n->line, n->pos, roff_name[n->tok]);
}

static void
post_useless(POST_ARGS)
{
	struct roff_node *n;

	n = mdoc->last;
	mandoc_msg(MANDOCERR_MACRO_USELESS, mdoc->parse,
	    n->line, n->pos, roff_name[n->tok]);
}

/*
 * Block macros.
 */

static void
post_bf(POST_ARGS)
{
	struct roff_node *np, *nch;

	/*
	 * Unlike other data pointers, these are "housed" by the HEAD
	 * element, which contains the goods.
	 */

	np = mdoc->last;
	if (np->type != ROFFT_HEAD)
		return;

	assert(np->parent->type == ROFFT_BLOCK);
	assert(np->parent->tok == MDOC_Bf);

	/* Check the number of arguments. */

	nch = np->child;
	if (np->parent->args == NULL) {
		if (nch == NULL) {
			mandoc_msg(MANDOCERR_BF_NOFONT, mdoc->parse,
			    np->line, np->pos, "Bf");
			return;
		}
		nch = nch->next;
	}
	if (nch != NULL)
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
		    nch->line, nch->pos, "Bf ... %s", nch->string);

	/* Extract argument into data. */

	if (np->parent->args != NULL) {
		switch (np->parent->args->argv[0].arg) {
		case MDOC_Emphasis:
			np->norm->Bf.font = FONT_Em;
			break;
		case MDOC_Literal:
			np->norm->Bf.font = FONT_Li;
			break;
		case MDOC_Symbolic:
			np->norm->Bf.font = FONT_Sy;
			break;
		default:
			abort();
		}
		return;
	}

	/* Extract parameter into data. */

	if ( ! strcmp(np->child->string, "Em"))
		np->norm->Bf.font = FONT_Em;
	else if ( ! strcmp(np->child->string, "Li"))
		np->norm->Bf.font = FONT_Li;
	else if ( ! strcmp(np->child->string, "Sy"))
		np->norm->Bf.font = FONT_Sy;
	else
		mandoc_vmsg(MANDOCERR_BF_BADFONT, mdoc->parse,
		    np->child->line, np->child->pos,
		    "Bf %s", np->child->string);
}

static void
post_fname(POST_ARGS)
{
	const struct roff_node	*n;
	const char		*cp;
	size_t			 pos;

	n = mdoc->last->child;
	pos = strcspn(n->string, "()");
	cp = n->string + pos;
	if ( ! (cp[0] == '\0' || (cp[0] == '(' && cp[1] == '*')))
		mandoc_msg(MANDOCERR_FN_PAREN, mdoc->parse,
		    n->line, n->pos + pos, n->string);
	if (n->sec == SEC_SYNOPSIS && mdoc->meta.msec != NULL)
		mandoc_xr_add(mdoc->meta.msec, n->string, -1, -1);
}

static void
post_fn(POST_ARGS)
{

	post_fname(mdoc);
	post_fa(mdoc);
}

static void
post_fo(POST_ARGS)
{
	const struct roff_node	*n;

	n = mdoc->last;

	if (n->type != ROFFT_HEAD)
		return;

	if (n->child == NULL) {
		mandoc_msg(MANDOCERR_FO_NOHEAD, mdoc->parse,
		    n->line, n->pos, "Fo");
		return;
	}
	if (n->child != n->last) {
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
		    n->child->next->line, n->child->next->pos,
		    "Fo ... %s", n->child->next->string);
		while (n->child != n->last)
			roff_node_delete(mdoc, n->last);
	}

	post_fname(mdoc);
}

static void
post_fa(POST_ARGS)
{
	const struct roff_node *n;
	const char *cp;

	for (n = mdoc->last->child; n != NULL; n = n->next) {
		for (cp = n->string; *cp != '\0'; cp++) {
			/* Ignore callbacks and alterations. */
			if (*cp == '(' || *cp == '{')
				break;
			if (*cp != ',')
				continue;
			mandoc_msg(MANDOCERR_FA_COMMA, mdoc->parse,
			    n->line, n->pos + (cp - n->string),
			    n->string);
			break;
		}
	}
	post_delim(mdoc);
}

static void
post_nm(POST_ARGS)
{
	struct roff_node	*n;

	n = mdoc->last;

	if ((n->sec == SEC_NAME || n->sec == SEC_SYNOPSIS) &&
	    n->child != NULL && n->child->type == ROFFT_TEXT &&
	    mdoc->meta.msec != NULL)
		mandoc_xr_add(mdoc->meta.msec, n->child->string, -1, -1);

	if (n->last != NULL &&
	    (n->last->tok == MDOC_Pp ||
	     n->last->tok == MDOC_Lp))
		mdoc_node_relink(mdoc, n->last);

	if (mdoc->meta.name == NULL)
		deroff(&mdoc->meta.name, n);

	if (mdoc->meta.name == NULL ||
	    (mdoc->lastsec == SEC_NAME && n->child == NULL))
		mandoc_msg(MANDOCERR_NM_NONAME, mdoc->parse,
		    n->line, n->pos, "Nm");

	if (n->type == ROFFT_ELEM)
		post_delim(mdoc);

	if ((n->type != ROFFT_ELEM && n->type != ROFFT_HEAD) ||
	    (n->child != NULL && n->child->type == ROFFT_TEXT) ||
	    mdoc->meta.name == NULL)
		return;

	mdoc->next = ROFF_NEXT_CHILD;
	roff_word_alloc(mdoc, n->line, n->pos, mdoc->meta.name);
	mdoc->last->flags |= NODE_NOSRC;
	mdoc->last = n;
}

static void
post_nd(POST_ARGS)
{
	struct roff_node	*n;
	size_t			 sz;

	n = mdoc->last;

	if (n->type != ROFFT_BODY)
		return;

	if (n->sec != SEC_NAME)
		mandoc_msg(MANDOCERR_ND_LATE, mdoc->parse,
		    n->line, n->pos, "Nd");

	if (n->child == NULL)
		mandoc_msg(MANDOCERR_ND_EMPTY, mdoc->parse,
		    n->line, n->pos, "Nd");
	else if (n->last->type == ROFFT_TEXT &&
	    (sz = strlen(n->last->string)) != 0 &&
	    n->last->string[sz - 1] == '.')
		mandoc_msg(MANDOCERR_ND_DOT, mdoc->parse,
		    n->last->line, n->last->pos + sz - 1, NULL);

	post_hyph(mdoc);
}

static void
post_display(POST_ARGS)
{
	struct roff_node *n, *np;

	n = mdoc->last;
	switch (n->type) {
	case ROFFT_BODY:
		if (n->end != ENDBODY_NOT) {
			if (n->tok == MDOC_Bd &&
			    n->body->parent->args == NULL)
				roff_node_delete(mdoc, n);
		} else if (n->child == NULL)
			mandoc_msg(MANDOCERR_BLK_EMPTY, mdoc->parse,
			    n->line, n->pos, roff_name[n->tok]);
		else if (n->tok == MDOC_D1)
			post_hyph(mdoc);
		break;
	case ROFFT_BLOCK:
		if (n->tok == MDOC_Bd) {
			if (n->args == NULL) {
				mandoc_msg(MANDOCERR_BD_NOARG,
				    mdoc->parse, n->line, n->pos, "Bd");
				mdoc->next = ROFF_NEXT_SIBLING;
				while (n->body->child != NULL)
					mdoc_node_relink(mdoc,
					    n->body->child);
				roff_node_delete(mdoc, n);
				break;
			}
			post_bd(mdoc);
			post_prevpar(mdoc);
		}
		for (np = n->parent; np != NULL; np = np->parent) {
			if (np->type == ROFFT_BLOCK && np->tok == MDOC_Bd) {
				mandoc_vmsg(MANDOCERR_BD_NEST,
				    mdoc->parse, n->line, n->pos,
				    "%s in Bd", roff_name[n->tok]);
				break;
			}
		}
		break;
	default:
		break;
	}
}

static void
post_defaults(POST_ARGS)
{
	struct roff_node *nn;

	if (mdoc->last->child != NULL) {
		post_delim(mdoc);
		return;
	}

	/*
	 * The `Ar' defaults to "file ..." if no value is provided as an
	 * argument; the `Mt' and `Pa' macros use "~"; the `Li' just
	 * gets an empty string.
	 */

	nn = mdoc->last;
	switch (nn->tok) {
	case MDOC_Ar:
		mdoc->next = ROFF_NEXT_CHILD;
		roff_word_alloc(mdoc, nn->line, nn->pos, "file");
		mdoc->last->flags |= NODE_NOSRC;
		roff_word_alloc(mdoc, nn->line, nn->pos, "...");
		mdoc->last->flags |= NODE_NOSRC;
		break;
	case MDOC_Pa:
	case MDOC_Mt:
		mdoc->next = ROFF_NEXT_CHILD;
		roff_word_alloc(mdoc, nn->line, nn->pos, "~");
		mdoc->last->flags |= NODE_NOSRC;
		break;
	default:
		abort();
	}
	mdoc->last = nn;
}

static void
post_at(POST_ARGS)
{
	struct roff_node	*n, *nch;
	const char		*att;

	n = mdoc->last;
	nch = n->child;

	/*
	 * If we have a child, look it up in the standard keys.  If a
	 * key exist, use that instead of the child; if it doesn't,
	 * prefix "AT&T UNIX " to the existing data.
	 */

	att = NULL;
	if (nch != NULL && ((att = mdoc_a2att(nch->string)) == NULL))
		mandoc_vmsg(MANDOCERR_AT_BAD, mdoc->parse,
		    nch->line, nch->pos, "At %s", nch->string);

	mdoc->next = ROFF_NEXT_CHILD;
	if (att != NULL) {
		roff_word_alloc(mdoc, nch->line, nch->pos, att);
		nch->flags |= NODE_NOPRT;
	} else
		roff_word_alloc(mdoc, n->line, n->pos, "AT&T UNIX");
	mdoc->last->flags |= NODE_NOSRC;
	mdoc->last = n;
}

static void
post_an(POST_ARGS)
{
	struct roff_node *np, *nch;

	post_an_norm(mdoc);

	np = mdoc->last;
	nch = np->child;
	if (np->norm->An.auth == AUTH__NONE) {
		if (nch == NULL)
			mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
			    np->line, np->pos, "An");
		else
			post_delim(mdoc);
	} else if (nch != NULL)
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
		    nch->line, nch->pos, "An ... %s", nch->string);
}

static void
post_en(POST_ARGS)
{

	post_obsolete(mdoc);
	if (mdoc->last->type == ROFFT_BLOCK)
		mdoc->last->norm->Es = mdoc->last_es;
}

static void
post_es(POST_ARGS)
{

	post_obsolete(mdoc);
	mdoc->last_es = mdoc->last;
}

static void
post_xx(POST_ARGS)
{
	struct roff_node	*n;
	const char		*os;

	post_delim(mdoc);

	n = mdoc->last;
	switch (n->tok) {
	case MDOC_Bsx:
		os = "BSD/OS";
		break;
	case MDOC_Dx:
		os = "DragonFly";
		break;
	case MDOC_Fx:
		os = "FreeBSD";
		break;
	case MDOC_Nx:
		os = "NetBSD";
		break;
	case MDOC_Ox:
		os = "OpenBSD";
		break;
	case MDOC_Ux:
		os = "UNIX";
		break;
	default:
		abort();
	}
	mdoc->next = ROFF_NEXT_CHILD;
	roff_word_alloc(mdoc, n->line, n->pos, os);
	mdoc->last->flags |= NODE_NOSRC;
	mdoc->last = n;
}

static void
post_it(POST_ARGS)
{
	struct roff_node *nbl, *nit, *nch;
	int		  i, cols;
	enum mdoc_list	  lt;

	post_prevpar(mdoc);

	nit = mdoc->last;
	if (nit->type != ROFFT_BLOCK)
		return;

	nbl = nit->parent->parent;
	lt = nbl->norm->Bl.type;

	switch (lt) {
	case LIST_tag:
	case LIST_hang:
	case LIST_ohang:
	case LIST_inset:
	case LIST_diag:
		if (nit->head->child == NULL)
			mandoc_vmsg(MANDOCERR_IT_NOHEAD,
			    mdoc->parse, nit->line, nit->pos,
			    "Bl -%s It",
			    mdoc_argnames[nbl->args->argv[0].arg]);
		break;
	case LIST_bullet:
	case LIST_dash:
	case LIST_enum:
	case LIST_hyphen:
		if (nit->body == NULL || nit->body->child == NULL)
			mandoc_vmsg(MANDOCERR_IT_NOBODY,
			    mdoc->parse, nit->line, nit->pos,
			    "Bl -%s It",
			    mdoc_argnames[nbl->args->argv[0].arg]);
		/* FALLTHROUGH */
	case LIST_item:
		if ((nch = nit->head->child) != NULL)
			mandoc_vmsg(MANDOCERR_ARG_SKIP, mdoc->parse,
			    nit->line, nit->pos, "It %s",
			    nch->string == NULL ? roff_name[nch->tok] :
			    nch->string);
		break;
	case LIST_column:
		cols = (int)nbl->norm->Bl.ncols;

		assert(nit->head->child == NULL);

		if (nit->head->next->child == NULL &&
		    nit->head->next->next == NULL) {
			mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
			    nit->line, nit->pos, "It");
			roff_node_delete(mdoc, nit);
			break;
		}

		i = 0;
		for (nch = nit->child; nch != NULL; nch = nch->next) {
			if (nch->type != ROFFT_BODY)
				continue;
			if (i++ && nch->flags & NODE_LINE)
				mandoc_msg(MANDOCERR_TA_LINE, mdoc->parse,
				    nch->line, nch->pos, "Ta");
		}
		if (i < cols || i > cols + 1)
			mandoc_vmsg(MANDOCERR_BL_COL,
			    mdoc->parse, nit->line, nit->pos,
			    "%d columns, %d cells", cols, i);
		else if (nit->head->next->child != NULL &&
		    nit->head->next->child->line > nit->line)
			mandoc_msg(MANDOCERR_IT_NOARG, mdoc->parse,
			    nit->line, nit->pos, "Bl -column It");
		break;
	default:
		abort();
	}
}

static void
post_bl_block(POST_ARGS)
{
	struct roff_node *n, *ni, *nc;

	post_prevpar(mdoc);

	n = mdoc->last;
	for (ni = n->body->child; ni != NULL; ni = ni->next) {
		if (ni->body == NULL)
			continue;
		nc = ni->body->last;
		while (nc != NULL) {
			switch (nc->tok) {
			case MDOC_Pp:
			case MDOC_Lp:
			case ROFF_br:
				break;
			default:
				nc = NULL;
				continue;
			}
			if (ni->next == NULL) {
				mandoc_msg(MANDOCERR_PAR_MOVE,
				    mdoc->parse, nc->line, nc->pos,
				    roff_name[nc->tok]);
				mdoc_node_relink(mdoc, nc);
			} else if (n->norm->Bl.comp == 0 &&
			    n->norm->Bl.type != LIST_column) {
				mandoc_vmsg(MANDOCERR_PAR_SKIP,
				    mdoc->parse, nc->line, nc->pos,
				    "%s before It", roff_name[nc->tok]);
				roff_node_delete(mdoc, nc);
			} else
				break;
			nc = ni->body->last;
		}
	}
}

/*
 * If the argument of -offset or -width is a macro,
 * replace it with the associated default width.
 */
static void
rewrite_macro2len(struct roff_man *mdoc, char **arg)
{
	size_t		  width;
	enum roff_tok	  tok;

	if (*arg == NULL)
		return;
	else if ( ! strcmp(*arg, "Ds"))
		width = 6;
	else if ((tok = roffhash_find(mdoc->mdocmac, *arg, 0)) == TOKEN_NONE)
		return;
	else
		width = macro2len(tok);

	free(*arg);
	mandoc_asprintf(arg, "%zun", width);
}

static void
post_bl_head(POST_ARGS)
{
	struct roff_node *nbl, *nh, *nch, *nnext;
	struct mdoc_argv *argv;
	int		  i, j;

	post_bl_norm(mdoc);

	nh = mdoc->last;
	if (nh->norm->Bl.type != LIST_column) {
		if ((nch = nh->child) == NULL)
			return;
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
		    nch->line, nch->pos, "Bl ... %s", nch->string);
		while (nch != NULL) {
			roff_node_delete(mdoc, nch);
			nch = nh->child;
		}
		return;
	}

	/*
	 * Append old-style lists, where the column width specifiers
	 * trail as macro parameters, to the new-style ("normal-form")
	 * lists where they're argument values following -column.
	 */

	if (nh->child == NULL)
		return;

	nbl = nh->parent;
	for (j = 0; j < (int)nbl->args->argc; j++)
		if (nbl->args->argv[j].arg == MDOC_Column)
			break;

	assert(j < (int)nbl->args->argc);

	/*
	 * Accommodate for new-style groff column syntax.  Shuffle the
	 * child nodes, all of which must be TEXT, as arguments for the
	 * column field.  Then, delete the head children.
	 */

	argv = nbl->args->argv + j;
	i = argv->sz;
	for (nch = nh->child; nch != NULL; nch = nch->next)
		argv->sz++;
	argv->value = mandoc_reallocarray(argv->value,
	    argv->sz, sizeof(char *));

	nh->norm->Bl.ncols = argv->sz;
	nh->norm->Bl.cols = (void *)argv->value;

	for (nch = nh->child; nch != NULL; nch = nnext) {
		argv->value[i++] = nch->string;
		nch->string = NULL;
		nnext = nch->next;
		roff_node_delete(NULL, nch);
	}
	nh->child = NULL;
}

static void
post_bl(POST_ARGS)
{
	struct roff_node	*nparent, *nprev; /* of the Bl block */
	struct roff_node	*nblock, *nbody;  /* of the Bl */
	struct roff_node	*nchild, *nnext;  /* of the Bl body */
	const char		*prev_Er;
	int			 order;

	nbody = mdoc->last;
	switch (nbody->type) {
	case ROFFT_BLOCK:
		post_bl_block(mdoc);
		return;
	case ROFFT_HEAD:
		post_bl_head(mdoc);
		return;
	case ROFFT_BODY:
		break;
	default:
		return;
	}
	if (nbody->end != ENDBODY_NOT)
		return;

	nchild = nbody->child;
	if (nchild == NULL) {
		mandoc_msg(MANDOCERR_BLK_EMPTY, mdoc->parse,
		    nbody->line, nbody->pos, "Bl");
		return;
	}
	while (nchild != NULL) {
		nnext = nchild->next;
		if (nchild->tok == MDOC_It ||
		    (nchild->tok == MDOC_Sm &&
		     nnext != NULL && nnext->tok == MDOC_It)) {
			nchild = nnext;
			continue;
		}

		/*
		 * In .Bl -column, the first rows may be implicit,
		 * that is, they may not start with .It macros.
		 * Such rows may be followed by nodes generated on the
		 * roff level, for example .TS, which cannot be moved
		 * out of the list.  In that case, wrap such roff nodes
		 * into an implicit row.
		 */

		if (nchild->prev != NULL) {
			mdoc->last = nchild;
			mdoc->next = ROFF_NEXT_SIBLING;
			roff_block_alloc(mdoc, nchild->line,
			    nchild->pos, MDOC_It);
			roff_head_alloc(mdoc, nchild->line,
			    nchild->pos, MDOC_It);
			mdoc->next = ROFF_NEXT_SIBLING;
			roff_body_alloc(mdoc, nchild->line,
			    nchild->pos, MDOC_It);
			while (nchild->tok != MDOC_It) {
				mdoc_node_relink(mdoc, nchild);
				if ((nchild = nnext) == NULL)
					break;
				nnext = nchild->next;
				mdoc->next = ROFF_NEXT_SIBLING;
			}
			mdoc->last = nbody;
			continue;
		}

		mandoc_msg(MANDOCERR_BL_MOVE, mdoc->parse,
		    nchild->line, nchild->pos, roff_name[nchild->tok]);

		/*
		 * Move the node out of the Bl block.
		 * First, collect all required node pointers.
		 */

		nblock  = nbody->parent;
		nprev   = nblock->prev;
		nparent = nblock->parent;

		/*
		 * Unlink this child.
		 */

		nbody->child = nnext;
		if (nnext == NULL)
			nbody->last  = NULL;
		else
			nnext->prev = NULL;

		/*
		 * Relink this child.
		 */

		nchild->parent = nparent;
		nchild->prev   = nprev;
		nchild->next   = nblock;

		nblock->prev = nchild;
		if (nprev == NULL)
			nparent->child = nchild;
		else
			nprev->next = nchild;

		nchild = nnext;
	}

	if (mdoc->meta.os_e != MANDOC_OS_NETBSD)
		return;

	prev_Er = NULL;
	for (nchild = nbody->child; nchild != NULL; nchild = nchild->next) {
		if (nchild->tok != MDOC_It)
			continue;
		if ((nnext = nchild->head->child) == NULL)
			continue;
		if (nnext->type == ROFFT_BLOCK)
			nnext = nnext->body->child;
		if (nnext == NULL || nnext->tok != MDOC_Er)
			continue;
		nnext = nnext->child;
		if (prev_Er != NULL) {
			order = strcmp(prev_Er, nnext->string);
			if (order > 0)
				mandoc_vmsg(MANDOCERR_ER_ORDER,
				    mdoc->parse, nnext->line, nnext->pos,
				    "Er %s %s (NetBSD)",
				    prev_Er, nnext->string);
			else if (order == 0)
				mandoc_vmsg(MANDOCERR_ER_REP,
				    mdoc->parse, nnext->line, nnext->pos,
				    "Er %s (NetBSD)", prev_Er);
		}
		prev_Er = nnext->string;
	}
}

static void
post_bk(POST_ARGS)
{
	struct roff_node	*n;

	n = mdoc->last;

	if (n->type == ROFFT_BLOCK && n->body->child == NULL) {
		mandoc_msg(MANDOCERR_BLK_EMPTY,
		    mdoc->parse, n->line, n->pos, "Bk");
		roff_node_delete(mdoc, n);
	}
}

static void
post_sm(POST_ARGS)
{
	struct roff_node	*nch;

	nch = mdoc->last->child;

	if (nch == NULL) {
		mdoc->flags ^= MDOC_SMOFF;
		return;
	}

	assert(nch->type == ROFFT_TEXT);

	if ( ! strcmp(nch->string, "on")) {
		mdoc->flags &= ~MDOC_SMOFF;
		return;
	}
	if ( ! strcmp(nch->string, "off")) {
		mdoc->flags |= MDOC_SMOFF;
		return;
	}

	mandoc_vmsg(MANDOCERR_SM_BAD,
	    mdoc->parse, nch->line, nch->pos,
	    "%s %s", roff_name[mdoc->last->tok], nch->string);
	mdoc_node_relink(mdoc, nch);
	return;
}

static void
post_root(POST_ARGS)
{
	const char *openbsd_arch[] = {
		"alpha", "amd64", "arm64", "armv7", "hppa", "i386",
		"landisk", "loongson", "luna88k", "macppc", "mips64",
		"octeon", "sgi", "socppc", "sparc64", NULL
	};
	const char *netbsd_arch[] = {
		"acorn26", "acorn32", "algor", "alpha", "amiga",
		"arc", "atari",
		"bebox", "cats", "cesfic", "cobalt", "dreamcast",
		"emips", "evbarm", "evbmips", "evbppc", "evbsh3", "evbsh5",
		"hp300", "hpcarm", "hpcmips", "hpcsh", "hppa",
		"i386", "ibmnws", "luna68k",
		"mac68k", "macppc", "mipsco", "mmeye", "mvme68k", "mvmeppc",
		"netwinder", "news68k", "newsmips", "next68k",
		"pc532", "playstation2", "pmax", "pmppc", "prep",
		"sandpoint", "sbmips", "sgimips", "shark",
		"sparc", "sparc64", "sun2", "sun3",
		"vax", "walnut", "x68k", "x86", "x86_64", "xen", NULL
        };
	const char **arches[] = { NULL, netbsd_arch, openbsd_arch };

	struct roff_node *n;
	const char **arch;

	/* Add missing prologue data. */

	if (mdoc->meta.date == NULL)
		mdoc->meta.date = mdoc->quick ? mandoc_strdup("") :
		    mandoc_normdate(mdoc, NULL, 0, 0);

	if (mdoc->meta.title == NULL) {
		mandoc_msg(MANDOCERR_DT_NOTITLE,
		    mdoc->parse, 0, 0, "EOF");
		mdoc->meta.title = mandoc_strdup("UNTITLED");
	}

	if (mdoc->meta.vol == NULL)
		mdoc->meta.vol = mandoc_strdup("LOCAL");

	if (mdoc->meta.os == NULL) {
		mandoc_msg(MANDOCERR_OS_MISSING,
		    mdoc->parse, 0, 0, NULL);
		mdoc->meta.os = mandoc_strdup("");
	} else if (mdoc->meta.os_e &&
	    (mdoc->meta.rcsids & (1 << mdoc->meta.os_e)) == 0)
		mandoc_msg(MANDOCERR_RCS_MISSING, mdoc->parse, 0, 0,
		    mdoc->meta.os_e == MANDOC_OS_OPENBSD ?
		    "(OpenBSD)" : "(NetBSD)");

	if (mdoc->meta.arch != NULL &&
	    (arch = arches[mdoc->meta.os_e]) != NULL) {
		while (*arch != NULL && strcmp(*arch, mdoc->meta.arch))
			arch++;
		if (*arch == NULL) {
			n = mdoc->first->child;
			while (n->tok != MDOC_Dt)
				n = n->next;
			n = n->child->next->next;
			mandoc_vmsg(MANDOCERR_ARCH_BAD,
			    mdoc->parse, n->line, n->pos,
			    "Dt ... %s %s", mdoc->meta.arch,
			    mdoc->meta.os_e == MANDOC_OS_OPENBSD ?
			    "(OpenBSD)" : "(NetBSD)");
		}
	}

	/* Check that we begin with a proper `Sh'. */

	n = mdoc->first->child;
	while (n != NULL && n->tok != TOKEN_NONE &&
	    mdoc_macros[n->tok].flags & MDOC_PROLOGUE)
		n = n->next;

	if (n == NULL)
		mandoc_msg(MANDOCERR_DOC_EMPTY, mdoc->parse, 0, 0, NULL);
	else if (n->tok != MDOC_Sh)
		mandoc_msg(MANDOCERR_SEC_BEFORE, mdoc->parse,
		    n->line, n->pos, roff_name[n->tok]);
}

static void
post_rs(POST_ARGS)
{
	struct roff_node *np, *nch, *next, *prev;
	int		  i, j;

	np = mdoc->last;

	if (np->type != ROFFT_BODY)
		return;

	if (np->child == NULL) {
		mandoc_msg(MANDOCERR_RS_EMPTY, mdoc->parse,
		    np->line, np->pos, "Rs");
		return;
	}

	/*
	 * The full `Rs' block needs special handling to order the
	 * sub-elements according to `rsord'.  Pick through each element
	 * and correctly order it.  This is an insertion sort.
	 */

	next = NULL;
	for (nch = np->child->next; nch != NULL; nch = next) {
		/* Determine order number of this child. */
		for (i = 0; i < RSORD_MAX; i++)
			if (rsord[i] == nch->tok)
				break;

		if (i == RSORD_MAX) {
			mandoc_msg(MANDOCERR_RS_BAD, mdoc->parse,
			    nch->line, nch->pos, roff_name[nch->tok]);
			i = -1;
		} else if (nch->tok == MDOC__J || nch->tok == MDOC__B)
			np->norm->Rs.quote_T++;

		/*
		 * Remove this child from the chain.  This somewhat
		 * repeats roff_node_unlink(), but since we're
		 * just re-ordering, there's no need for the
		 * full unlink process.
		 */

		if ((next = nch->next) != NULL)
			next->prev = nch->prev;

		if ((prev = nch->prev) != NULL)
			prev->next = nch->next;

		nch->prev = nch->next = NULL;

		/*
		 * Scan back until we reach a node that's
		 * to be ordered before this child.
		 */

		for ( ; prev ; prev = prev->prev) {
			/* Determine order of `prev'. */
			for (j = 0; j < RSORD_MAX; j++)
				if (rsord[j] == prev->tok)
					break;
			if (j == RSORD_MAX)
				j = -1;

			if (j <= i)
				break;
		}

		/*
		 * Set this child back into its correct place
		 * in front of the `prev' node.
		 */

		nch->prev = prev;

		if (prev == NULL) {
			np->child->prev = nch;
			nch->next = np->child;
			np->child = nch;
		} else {
			if (prev->next)
				prev->next->prev = nch;
			nch->next = prev->next;
			prev->next = nch;
		}
	}
}

/*
 * For some arguments of some macros,
 * convert all breakable hyphens into ASCII_HYPH.
 */
static void
post_hyph(POST_ARGS)
{
	struct roff_node	*nch;
	char			*cp;

	for (nch = mdoc->last->child; nch != NULL; nch = nch->next) {
		if (nch->type != ROFFT_TEXT)
			continue;
		cp = nch->string;
		if (*cp == '\0')
			continue;
		while (*(++cp) != '\0')
			if (*cp == '-' &&
			    isalpha((unsigned char)cp[-1]) &&
			    isalpha((unsigned char)cp[1]))
				*cp = ASCII_HYPH;
	}
}

static void
post_ns(POST_ARGS)
{
	struct roff_node	*n;

	n = mdoc->last;
	if (n->flags & NODE_LINE ||
	    (n->next != NULL && n->next->flags & NODE_DELIMC))
		mandoc_msg(MANDOCERR_NS_SKIP, mdoc->parse,
		    n->line, n->pos, NULL);
}

static void
post_sh(POST_ARGS)
{

	post_ignpar(mdoc);

	switch (mdoc->last->type) {
	case ROFFT_HEAD:
		post_sh_head(mdoc);
		break;
	case ROFFT_BODY:
		switch (mdoc->lastsec)  {
		case SEC_NAME:
			post_sh_name(mdoc);
			break;
		case SEC_SEE_ALSO:
			post_sh_see_also(mdoc);
			break;
		case SEC_AUTHORS:
			post_sh_authors(mdoc);
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
}

static void
post_sh_name(POST_ARGS)
{
	struct roff_node *n;
	int hasnm, hasnd;

	hasnm = hasnd = 0;

	for (n = mdoc->last->child; n != NULL; n = n->next) {
		switch (n->tok) {
		case MDOC_Nm:
			if (hasnm && n->child != NULL)
				mandoc_vmsg(MANDOCERR_NAMESEC_PUNCT,
				    mdoc->parse, n->line, n->pos,
				    "Nm %s", n->child->string);
			hasnm = 1;
			continue;
		case MDOC_Nd:
			hasnd = 1;
			if (n->next != NULL)
				mandoc_msg(MANDOCERR_NAMESEC_ND,
				    mdoc->parse, n->line, n->pos, NULL);
			break;
		case TOKEN_NONE:
			if (n->type == ROFFT_TEXT &&
			    n->string[0] == ',' && n->string[1] == '\0' &&
			    n->next != NULL && n->next->tok == MDOC_Nm) {
				n = n->next;
				continue;
			}
			/* FALLTHROUGH */
		default:
			mandoc_msg(MANDOCERR_NAMESEC_BAD, mdoc->parse,
			    n->line, n->pos, roff_name[n->tok]);
			continue;
		}
		break;
	}

	if ( ! hasnm)
		mandoc_msg(MANDOCERR_NAMESEC_NONM, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, NULL);
	if ( ! hasnd)
		mandoc_msg(MANDOCERR_NAMESEC_NOND, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, NULL);
}

static void
post_sh_see_also(POST_ARGS)
{
	const struct roff_node	*n;
	const char		*name, *sec;
	const char		*lastname, *lastsec, *lastpunct;
	int			 cmp;

	n = mdoc->last->child;
	lastname = lastsec = lastpunct = NULL;
	while (n != NULL) {
		if (n->tok != MDOC_Xr ||
		    n->child == NULL ||
		    n->child->next == NULL)
			break;

		/* Process one .Xr node. */

		name = n->child->string;
		sec = n->child->next->string;
		if (lastsec != NULL) {
			if (lastpunct[0] != ',' || lastpunct[1] != '\0')
				mandoc_vmsg(MANDOCERR_XR_PUNCT,
				    mdoc->parse, n->line, n->pos,
				    "%s before %s(%s)", lastpunct,
				    name, sec);
			cmp = strcmp(lastsec, sec);
			if (cmp > 0)
				mandoc_vmsg(MANDOCERR_XR_ORDER,
				    mdoc->parse, n->line, n->pos,
				    "%s(%s) after %s(%s)", name,
				    sec, lastname, lastsec);
			else if (cmp == 0 &&
			    strcasecmp(lastname, name) > 0)
				mandoc_vmsg(MANDOCERR_XR_ORDER,
				    mdoc->parse, n->line, n->pos,
				    "%s after %s", name, lastname);
		}
		lastname = name;
		lastsec = sec;

		/* Process the following node. */

		n = n->next;
		if (n == NULL)
			break;
		if (n->tok == MDOC_Xr) {
			lastpunct = "none";
			continue;
		}
		if (n->type != ROFFT_TEXT)
			break;
		for (name = n->string; *name != '\0'; name++)
			if (isalpha((const unsigned char)*name))
				return;
		lastpunct = n->string;
		if (n->next == NULL || n->next->tok == MDOC_Rs)
			mandoc_vmsg(MANDOCERR_XR_PUNCT, mdoc->parse,
			    n->line, n->pos, "%s after %s(%s)",
			    lastpunct, lastname, lastsec);
		n = n->next;
	}
}

static int
child_an(const struct roff_node *n)
{

	for (n = n->child; n != NULL; n = n->next)
		if ((n->tok == MDOC_An && n->child != NULL) || child_an(n))
			return 1;
	return 0;
}

static void
post_sh_authors(POST_ARGS)
{

	if ( ! child_an(mdoc->last))
		mandoc_msg(MANDOCERR_AN_MISSING, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, NULL);
}

/*
 * Return an upper bound for the string distance (allowing
 * transpositions).  Not a full Levenshtein implementation
 * because Levenshtein is quadratic in the string length
 * and this function is called for every standard name,
 * so the check for each custom name would be cubic.
 * The following crude heuristics is linear, resulting
 * in quadratic behaviour for checking one custom name,
 * which does not cause measurable slowdown.
 */
static int
similar(const char *s1, const char *s2)
{
	const int	maxdist = 3;
	int		dist = 0;

	while (s1[0] != '\0' && s2[0] != '\0') {
		if (s1[0] == s2[0]) {
			s1++;
			s2++;
			continue;
		}
		if (++dist > maxdist)
			return INT_MAX;
		if (s1[1] == s2[1]) {  /* replacement */
			s1++;
			s2++;
		} else if (s1[0] == s2[1] && s1[1] == s2[0]) {
			s1 += 2;	/* transposition */
			s2 += 2;
		} else if (s1[0] == s2[1])  /* insertion */
			s2++;
		else if (s1[1] == s2[0])  /* deletion */
			s1++;
		else
			return INT_MAX;
	}
	dist += strlen(s1) + strlen(s2);
	return dist > maxdist ? INT_MAX : dist;
}

static void
post_sh_head(POST_ARGS)
{
	struct roff_node	*nch;
	const char		*goodsec;
	const char *const	*testsec;
	int			 dist, mindist;
	enum roff_sec		 sec;

	/*
	 * Process a new section.  Sections are either "named" or
	 * "custom".  Custom sections are user-defined, while named ones
	 * follow a conventional order and may only appear in certain
	 * manual sections.
	 */

	sec = mdoc->last->sec;

	/* The NAME should be first. */

	if (sec != SEC_NAME && mdoc->lastnamed == SEC_NONE)
		mandoc_vmsg(MANDOCERR_NAMESEC_FIRST, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, "Sh %s",
		    sec != SEC_CUSTOM ? secnames[sec] :
		    (nch = mdoc->last->child) == NULL ? "" :
		    nch->type == ROFFT_TEXT ? nch->string :
		    roff_name[nch->tok]);

	/* The SYNOPSIS gets special attention in other areas. */

	if (sec == SEC_SYNOPSIS) {
		roff_setreg(mdoc->roff, "nS", 1, '=');
		mdoc->flags |= MDOC_SYNOPSIS;
	} else {
		roff_setreg(mdoc->roff, "nS", 0, '=');
		mdoc->flags &= ~MDOC_SYNOPSIS;
	}

	/* Mark our last section. */

	mdoc->lastsec = sec;

	/* We don't care about custom sections after this. */

	if (sec == SEC_CUSTOM) {
		if ((nch = mdoc->last->child) == NULL ||
		    nch->type != ROFFT_TEXT || nch->next != NULL)
			return;
		goodsec = NULL;
		mindist = INT_MAX;
		for (testsec = secnames + 1; *testsec != NULL; testsec++) {
			dist = similar(nch->string, *testsec);
			if (dist < mindist) {
				goodsec = *testsec;
				mindist = dist;
			}
		}
		if (goodsec != NULL)
			mandoc_vmsg(MANDOCERR_SEC_TYPO, mdoc->parse,
			    nch->line, nch->pos, "Sh %s instead of %s",
			    nch->string, goodsec);
		return;
	}

	/*
	 * Check whether our non-custom section is being repeated or is
	 * out of order.
	 */

	if (sec == mdoc->lastnamed)
		mandoc_vmsg(MANDOCERR_SEC_REP, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos,
		    "Sh %s", secnames[sec]);

	if (sec < mdoc->lastnamed)
		mandoc_vmsg(MANDOCERR_SEC_ORDER, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos,
		    "Sh %s", secnames[sec]);

	/* Mark the last named section. */

	mdoc->lastnamed = sec;

	/* Check particular section/manual conventions. */

	if (mdoc->meta.msec == NULL)
		return;

	goodsec = NULL;
	switch (sec) {
	case SEC_ERRORS:
		if (*mdoc->meta.msec == '4')
			break;
		goodsec = "2, 3, 4, 9";
		/* FALLTHROUGH */
	case SEC_RETURN_VALUES:
	case SEC_LIBRARY:
		if (*mdoc->meta.msec == '2')
			break;
		if (*mdoc->meta.msec == '3')
			break;
		if (NULL == goodsec)
			goodsec = "2, 3, 9";
		/* FALLTHROUGH */
	case SEC_CONTEXT:
		if (*mdoc->meta.msec == '9')
			break;
		if (NULL == goodsec)
			goodsec = "9";
		mandoc_vmsg(MANDOCERR_SEC_MSEC, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos,
		    "Sh %s for %s only", secnames[sec], goodsec);
		break;
	default:
		break;
	}
}

static void
post_xr(POST_ARGS)
{
	struct roff_node *n, *nch;

	n = mdoc->last;
	nch = n->child;
	if (nch->next == NULL) {
		mandoc_vmsg(MANDOCERR_XR_NOSEC, mdoc->parse,
		    n->line, n->pos, "Xr %s", nch->string);
	} else {
		assert(nch->next == n->last);
		if(mandoc_xr_add(nch->next->string, nch->string,
		    nch->line, nch->pos))
			mandoc_vmsg(MANDOCERR_XR_SELF, mdoc->parse,
			    nch->line, nch->pos, "Xr %s %s",
			    nch->string, nch->next->string);
	}
	post_delim(mdoc);
}

static void
post_ignpar(POST_ARGS)
{
	struct roff_node *np;

	switch (mdoc->last->type) {
	case ROFFT_BLOCK:
		post_prevpar(mdoc);
		return;
	case ROFFT_HEAD:
		post_hyph(mdoc);
		return;
	case ROFFT_BODY:
		break;
	default:
		return;
	}

	if ((np = mdoc->last->child) != NULL)
		if (np->tok == MDOC_Pp || np->tok == MDOC_Lp) {
			mandoc_vmsg(MANDOCERR_PAR_SKIP,
			    mdoc->parse, np->line, np->pos,
			    "%s after %s", roff_name[np->tok],
			    roff_name[mdoc->last->tok]);
			roff_node_delete(mdoc, np);
		}

	if ((np = mdoc->last->last) != NULL)
		if (np->tok == MDOC_Pp || np->tok == MDOC_Lp) {
			mandoc_vmsg(MANDOCERR_PAR_SKIP, mdoc->parse,
			    np->line, np->pos, "%s at the end of %s",
			    roff_name[np->tok],
			    roff_name[mdoc->last->tok]);
			roff_node_delete(mdoc, np);
		}
}

static void
post_prevpar(POST_ARGS)
{
	struct roff_node *n;

	n = mdoc->last;
	if (NULL == n->prev)
		return;
	if (n->type != ROFFT_ELEM && n->type != ROFFT_BLOCK)
		return;

	/*
	 * Don't allow prior `Lp' or `Pp' prior to a paragraph-type
	 * block:  `Lp', `Pp', or non-compact `Bd' or `Bl'.
	 */

	if (n->prev->tok != MDOC_Pp &&
	    n->prev->tok != MDOC_Lp &&
	    n->prev->tok != ROFF_br)
		return;
	if (n->tok == MDOC_Bl && n->norm->Bl.comp)
		return;
	if (n->tok == MDOC_Bd && n->norm->Bd.comp)
		return;
	if (n->tok == MDOC_It && n->parent->norm->Bl.comp)
		return;

	mandoc_vmsg(MANDOCERR_PAR_SKIP, mdoc->parse,
	    n->prev->line, n->prev->pos, "%s before %s",
	    roff_name[n->prev->tok], roff_name[n->tok]);
	roff_node_delete(mdoc, n->prev);
}

static void
post_par(POST_ARGS)
{
	struct roff_node *np;

	np = mdoc->last;
	if (np->tok != ROFF_br && np->tok != ROFF_sp)
		post_prevpar(mdoc);

	if (np->tok == ROFF_sp) {
		if (np->child != NULL && np->child->next != NULL)
			mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
			    np->child->next->line, np->child->next->pos,
			    "sp ... %s", np->child->next->string);
	} else if (np->child != NULL)
		mandoc_vmsg(MANDOCERR_ARG_SKIP,
		    mdoc->parse, np->line, np->pos, "%s %s",
		    roff_name[np->tok], np->child->string);

	if ((np = mdoc->last->prev) == NULL) {
		np = mdoc->last->parent;
		if (np->tok != MDOC_Sh && np->tok != MDOC_Ss)
			return;
	} else if (np->tok != MDOC_Pp && np->tok != MDOC_Lp &&
	    (mdoc->last->tok != ROFF_br ||
	     (np->tok != ROFF_sp && np->tok != ROFF_br)))
		return;

	mandoc_vmsg(MANDOCERR_PAR_SKIP, mdoc->parse,
	    mdoc->last->line, mdoc->last->pos, "%s after %s",
	    roff_name[mdoc->last->tok], roff_name[np->tok]);
	roff_node_delete(mdoc, mdoc->last);
}

static void
post_dd(POST_ARGS)
{
	struct roff_node *n;
	char		 *datestr;

	n = mdoc->last;
	n->flags |= NODE_NOPRT;

	if (mdoc->meta.date != NULL) {
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Dd");
		free(mdoc->meta.date);
	} else if (mdoc->flags & MDOC_PBODY)
		mandoc_msg(MANDOCERR_PROLOG_LATE, mdoc->parse,
		    n->line, n->pos, "Dd");
	else if (mdoc->meta.title != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dd after Dt");
	else if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dd after Os");

	if (n->child == NULL || n->child->string[0] == '\0') {
		mdoc->meta.date = mdoc->quick ? mandoc_strdup("") :
		    mandoc_normdate(mdoc, NULL, n->line, n->pos);
		return;
	}

	datestr = NULL;
	deroff(&datestr, n);
	if (mdoc->quick)
		mdoc->meta.date = datestr;
	else {
		mdoc->meta.date = mandoc_normdate(mdoc,
		    datestr, n->line, n->pos);
		free(datestr);
	}
}

static void
post_dt(POST_ARGS)
{
	struct roff_node *nn, *n;
	const char	 *cp;
	char		 *p;

	n = mdoc->last;
	n->flags |= NODE_NOPRT;

	if (mdoc->flags & MDOC_PBODY) {
		mandoc_msg(MANDOCERR_DT_LATE, mdoc->parse,
		    n->line, n->pos, "Dt");
		return;
	}

	if (mdoc->meta.title != NULL)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Dt");
	else if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dt after Os");

	free(mdoc->meta.title);
	free(mdoc->meta.msec);
	free(mdoc->meta.vol);
	free(mdoc->meta.arch);

	mdoc->meta.title = NULL;
	mdoc->meta.msec = NULL;
	mdoc->meta.vol = NULL;
	mdoc->meta.arch = NULL;

	/* Mandatory first argument: title. */

	nn = n->child;
	if (nn == NULL || *nn->string == '\0') {
		mandoc_msg(MANDOCERR_DT_NOTITLE,
		    mdoc->parse, n->line, n->pos, "Dt");
		mdoc->meta.title = mandoc_strdup("UNTITLED");
	} else {
		mdoc->meta.title = mandoc_strdup(nn->string);

		/* Check that all characters are uppercase. */

		for (p = nn->string; *p != '\0'; p++)
			if (islower((unsigned char)*p)) {
				mandoc_vmsg(MANDOCERR_TITLE_CASE,
				    mdoc->parse, nn->line,
				    nn->pos + (p - nn->string),
				    "Dt %s", nn->string);
				break;
			}
	}

	/* Mandatory second argument: section. */

	if (nn != NULL)
		nn = nn->next;

	if (nn == NULL) {
		mandoc_vmsg(MANDOCERR_MSEC_MISSING,
		    mdoc->parse, n->line, n->pos,
		    "Dt %s", mdoc->meta.title);
		mdoc->meta.vol = mandoc_strdup("LOCAL");
		return;  /* msec and arch remain NULL. */
	}

	mdoc->meta.msec = mandoc_strdup(nn->string);

	/* Infer volume title from section number. */

	cp = mandoc_a2msec(nn->string);
	if (cp == NULL) {
		mandoc_vmsg(MANDOCERR_MSEC_BAD, mdoc->parse,
		    nn->line, nn->pos, "Dt ... %s", nn->string);
		mdoc->meta.vol = mandoc_strdup(nn->string);
	} else
		mdoc->meta.vol = mandoc_strdup(cp);

	/* Optional third argument: architecture. */

	if ((nn = nn->next) == NULL)
		return;

	for (p = nn->string; *p != '\0'; p++)
		*p = tolower((unsigned char)*p);
	mdoc->meta.arch = mandoc_strdup(nn->string);

	/* Ignore fourth and later arguments. */

	if ((nn = nn->next) != NULL)
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
		    nn->line, nn->pos, "Dt ... %s", nn->string);
}

static void
post_bx(POST_ARGS)
{
	struct roff_node	*n, *nch;
	const char		*macro;

	post_delim(mdoc);

	n = mdoc->last;
	nch = n->child;

	if (nch != NULL) {
		macro = !strcmp(nch->string, "Open") ? "Ox" :
		    !strcmp(nch->string, "Net") ? "Nx" :
		    !strcmp(nch->string, "Free") ? "Fx" :
		    !strcmp(nch->string, "DragonFly") ? "Dx" : NULL;
		if (macro != NULL)
			mandoc_msg(MANDOCERR_BX, mdoc->parse,
			    n->line, n->pos, macro);
		mdoc->last = nch;
		nch = nch->next;
		mdoc->next = ROFF_NEXT_SIBLING;
		roff_elem_alloc(mdoc, n->line, n->pos, MDOC_Ns);
		mdoc->last->flags |= NODE_NOSRC;
		mdoc->next = ROFF_NEXT_SIBLING;
	} else
		mdoc->next = ROFF_NEXT_CHILD;
	roff_word_alloc(mdoc, n->line, n->pos, "BSD");
	mdoc->last->flags |= NODE_NOSRC;

	if (nch == NULL) {
		mdoc->last = n;
		return;
	}

	roff_elem_alloc(mdoc, n->line, n->pos, MDOC_Ns);
	mdoc->last->flags |= NODE_NOSRC;
	mdoc->next = ROFF_NEXT_SIBLING;
	roff_word_alloc(mdoc, n->line, n->pos, "-");
	mdoc->last->flags |= NODE_NOSRC;
	roff_elem_alloc(mdoc, n->line, n->pos, MDOC_Ns);
	mdoc->last->flags |= NODE_NOSRC;
	mdoc->last = n;

	/*
	 * Make `Bx's second argument always start with an uppercase
	 * letter.  Groff checks if it's an "accepted" term, but we just
	 * uppercase blindly.
	 */

	*nch->string = (char)toupper((unsigned char)*nch->string);
}

static void
post_os(POST_ARGS)
{
#ifndef OSNAME
	struct utsname	  utsname;
	static char	 *defbuf;
#endif
	struct roff_node *n;

	n = mdoc->last;
	n->flags |= NODE_NOPRT;

	if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Os");
	else if (mdoc->flags & MDOC_PBODY)
		mandoc_msg(MANDOCERR_PROLOG_LATE, mdoc->parse,
		    n->line, n->pos, "Os");

	/*
	 * Set the operating system by way of the `Os' macro.
	 * The order of precedence is:
	 * 1. the argument of the `Os' macro, unless empty
	 * 2. the -Ios=foo command line argument, if provided
	 * 3. -DOSNAME="\"foo\"", if provided during compilation
	 * 4. "sysname release" from uname(3)
	 */

	free(mdoc->meta.os);
	mdoc->meta.os = NULL;
	deroff(&mdoc->meta.os, n);
	if (mdoc->meta.os)
		goto out;

	if (mdoc->os_s != NULL) {
		mdoc->meta.os = mandoc_strdup(mdoc->os_s);
		goto out;
	}

#ifdef OSNAME
	mdoc->meta.os = mandoc_strdup(OSNAME);
#else /*!OSNAME */
	if (defbuf == NULL) {
		if (uname(&utsname) == -1) {
			mandoc_msg(MANDOCERR_OS_UNAME, mdoc->parse,
			    n->line, n->pos, "Os");
			defbuf = mandoc_strdup("UNKNOWN");
		} else
			mandoc_asprintf(&defbuf, "%s %s",
			    utsname.sysname, utsname.release);
	}
	mdoc->meta.os = mandoc_strdup(defbuf);
#endif /*!OSNAME*/

out:
	if (mdoc->meta.os_e == MANDOC_OS_OTHER) {
		if (strstr(mdoc->meta.os, "OpenBSD") != NULL)
			mdoc->meta.os_e = MANDOC_OS_OPENBSD;
		else if (strstr(mdoc->meta.os, "NetBSD") != NULL)
			mdoc->meta.os_e = MANDOC_OS_NETBSD;
	}

	/*
	 * This is the earliest point where we can check
	 * Mdocdate conventions because we don't know
	 * the operating system earlier.
	 */

	if (n->child != NULL)
		mandoc_vmsg(MANDOCERR_OS_ARG, mdoc->parse,
		    n->child->line, n->child->pos,
		    "Os %s (%s)", n->child->string,
		    mdoc->meta.os_e == MANDOC_OS_OPENBSD ?
		    "OpenBSD" : "NetBSD");

	while (n->tok != MDOC_Dd)
		if ((n = n->prev) == NULL)
			return;
	if ((n = n->child) == NULL)
		return;
	if (strncmp(n->string, "$" "Mdocdate", 9)) {
		if (mdoc->meta.os_e == MANDOC_OS_OPENBSD)
			mandoc_vmsg(MANDOCERR_MDOCDATE_MISSING,
			    mdoc->parse, n->line, n->pos,
			    "Dd %s (OpenBSD)", n->string);
	} else {
		if (mdoc->meta.os_e == MANDOC_OS_NETBSD)
			mandoc_vmsg(MANDOCERR_MDOCDATE,
			    mdoc->parse, n->line, n->pos,
			    "Dd %s (NetBSD)", n->string);
	}
}

enum roff_sec
mdoc_a2sec(const char *p)
{
	int		 i;

	for (i = 0; i < (int)SEC__MAX; i++)
		if (secnames[i] && 0 == strcmp(p, secnames[i]))
			return (enum roff_sec)i;

	return SEC_CUSTOM;
}

static size_t
macro2len(enum roff_tok macro)
{

	switch (macro) {
	case MDOC_Ad:
		return 12;
	case MDOC_Ao:
		return 12;
	case MDOC_An:
		return 12;
	case MDOC_Aq:
		return 12;
	case MDOC_Ar:
		return 12;
	case MDOC_Bo:
		return 12;
	case MDOC_Bq:
		return 12;
	case MDOC_Cd:
		return 12;
	case MDOC_Cm:
		return 10;
	case MDOC_Do:
		return 10;
	case MDOC_Dq:
		return 12;
	case MDOC_Dv:
		return 12;
	case MDOC_Eo:
		return 12;
	case MDOC_Em:
		return 10;
	case MDOC_Er:
		return 17;
	case MDOC_Ev:
		return 15;
	case MDOC_Fa:
		return 12;
	case MDOC_Fl:
		return 10;
	case MDOC_Fo:
		return 16;
	case MDOC_Fn:
		return 16;
	case MDOC_Ic:
		return 10;
	case MDOC_Li:
		return 16;
	case MDOC_Ms:
		return 6;
	case MDOC_Nm:
		return 10;
	case MDOC_No:
		return 12;
	case MDOC_Oo:
		return 10;
	case MDOC_Op:
		return 14;
	case MDOC_Pa:
		return 32;
	case MDOC_Pf:
		return 12;
	case MDOC_Po:
		return 12;
	case MDOC_Pq:
		return 12;
	case MDOC_Ql:
		return 16;
	case MDOC_Qo:
		return 12;
	case MDOC_So:
		return 12;
	case MDOC_Sq:
		return 12;
	case MDOC_Sy:
		return 6;
	case MDOC_Sx:
		return 16;
	case MDOC_Tn:
		return 10;
	case MDOC_Va:
		return 12;
	case MDOC_Vt:
		return 12;
	case MDOC_Xr:
		return 10;
	default:
		break;
	};
	return 0;
}
@


1.261
log
@Basic reporting of .Xrs to manual pages that don't exist
in the base system, inspired by mdoclint(1).

We are able to do this because (1) the -mdoc parser, the -Tlint validator,
and the man(1) manual page lookup code are all in the same program
and (2) the mandoc.db(5) database format allows fast lookup.

Feedback from, previous versions tested by, and OK jmc@@.

A few features will be added to this in the tree, step by step.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.260 2017/06/29 15:21:46 schwarze Exp $ */
d1092 2
d1159 5
d2334 5
a2338 2
		mandoc_xr_add(nch->next->string, nch->string,
		    nch->line, nch->pos);
@


1.260
log
@warn about some non-portable idioms in .Bl -column;
triggered by a question from Yuri Pankov (illumos)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.259 2017/06/27 12:17:35 schwarze Exp $ */
d34 1
d2325 1
a2325 1
	} else
d2327 3
@


1.259
log
@warn about .Ns macros that have no effect because they are followed
by an isolated closing delimiter; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.258 2017/06/25 17:42:37 schwarze Exp $ */
d1448 8
d1457 7
a1463 4
		for (nch = nit->child; nch != NULL; nch = nch->next)
			if (nch->type == ROFFT_BODY)
				i++;

d1468 4
@


1.258
log
@Catch typos in .Sh names; suggested by jmc@@.

I'm using a very simple, linear time / zero space fuzzy string
matching heuristic rather than a full Levenshtein metric, to keep
the code both simple and fast.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.257 2017/06/24 18:58:09 schwarze Exp $ */
d1971 1
d1973 3
a1975 1
	if (mdoc->last->flags & NODE_LINE)
d1977 1
a1977 1
		    mdoc->last->line, mdoc->last->pos, NULL);
@


1.257
log
@operating system dependent message about unknown architecture;
inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.256 2017/06/24 15:59:28 schwarze Exp $ */
d61 1
d2137 41
d2183 2
d2222 17
a2238 1
	if (sec == SEC_CUSTOM)
d2240 1
@


1.256
log
@in the base system, suggest leaving .Os blank; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.255 2017/06/24 14:38:27 schwarze Exp $ */
d1774 21
d1796 1
d1822 17
@


1.255
log
@Split -Wstyle into -Wstyle and the even lower -Wbase, and add
-Wopenbsd and -Wnetbsd to check conventions for the base system of
a specific operating system.  Mark operating system specific messages
with "(OpenBSD)" at the end.

Please use just "-Tlint" to check base system manuals (defaulting
to -Wall, which is now -Wbase), but prefer "-Tlint -Wstyle" for the
manuals of portable software projects you maintain that are not
part of OpenBSD base, to avoid bogus recommendations about base
system conventions that do not apply.

Issue originally reported by semarie@@, solution using
an idea from tedu@@, discussed with jmc@@ and jca@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.254 2017/06/17 22:40:27 schwarze Exp $ */
d2571 7
@


1.254
log
@style message about missing RCS ids; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.253 2017/06/11 20:02:48 schwarze Exp $ */
d1697 1
a1697 1
	if (mdoc->meta.os_e != MDOC_OS_NETBSD)
d1716 2
a1717 1
				    "Er %s %s", prev_Er, nnext->string);
d1721 1
a1721 1
				    "Er %s", prev_Er);
d1797 3
a1799 2
		mandoc_msg(MANDOCERR_RCS_MISSING,
		    mdoc->parse, 0, 0, NULL);
d2538 2
a2539 2
	if (mdoc->defos) {
		mdoc->meta.os = mandoc_strdup(mdoc->defos);
d2558 7
a2564 3
out:	mdoc->meta.os_e = strstr(mdoc->meta.os, "OpenBSD") != NULL ?
	    MDOC_OS_OPENBSD : strstr(mdoc->meta.os, "NetBSD") != NULL ?
	    MDOC_OS_NETBSD : MDOC_OS_OTHER;
d2578 1
a2578 1
		if (mdoc->meta.os_e == MDOC_OS_OPENBSD)
d2581 1
a2581 1
			    "Dd %s", n->string);
d2583 1
a2583 1
		if (mdoc->meta.os_e == MDOC_OS_NETBSD)
d2586 1
a2586 1
			    "Dd %s", n->string);
@


1.253
log
@ooops, fix a glitch in the previous commit...
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.252 2017/06/11 19:36:31 schwarze Exp $ */
d1794 4
a1797 1
	}
@


1.252
log
@Style message about legacy man(7) date format in mdoc(7) documents
and operating system dependent messages about missing or unexpected
Mdocdate; inspired by mdoclint(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.251 2017/06/11 17:16:36 schwarze Exp $ */
d2568 1
a2568 1
	if (strcmp(n->string, "$" "Mdocdate")) {
@


1.251
log
@style message about missing .Fn markup; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.250 2017/06/11 14:10:24 schwarze Exp $ */
d1778 2
a1779 3
		mdoc->meta.date = mdoc->quick ?
		    mandoc_strdup("") :
		    mandoc_normdate(mdoc->parse, NULL, 0, 0);
d2335 1
a2335 1
		    mandoc_normdate(mdoc->parse, NULL, n->line, n->pos);
d2344 1
a2344 1
		mdoc->meta.date = mandoc_normdate(mdoc->parse,
d2556 23
@


1.250
log
@Do not issue the message "no blank before trailing delimiter" for .No.
In practice, that message only matters inside .Bf, and even there, it
can occasionally be a false positive.  In all other cases, it usually
is a false positive, so it is better to drop it outright.
Suggested by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.249 2017/06/10 16:53:58 schwarze Exp $ */
a53 1
static	void	 check_bsd(struct roff_man *, int, int, char *);
d57 1
d305 5
a309 4
		if (n->parent->tok == MDOC_Sh ||
		    n->parent->tok == MDOC_Ss ||
		    n->parent->tok == MDOC_It)
			check_bsd(mdoc, n->line, n->pos, n->string);
d392 1
a392 1
check_bsd(struct roff_man *mdoc, int ln, int pos, char *p)
d394 4
a397 1
	const char	*cp;
d411 13
@


1.249
log
@Reduce false positives for the "no blank before trailing delimiter" message.
This brings us down to one false positive for about every 18 pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.248 2017/06/10 01:48:31 schwarze Exp $ */
d185 1
a185 1
	post_delim,	/* No */
d482 2
a483 2
	    tok == MDOC_Li || tok == MDOC_No || tok == MDOC_Po ||
	    tok == MDOC_Pq || tok == MDOC_Sy)) {
@


1.248
log
@style message about missing blank before trailing delimiter;
inspired by mdoclint(1), and jmc@@ considers it useful
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.247 2017/06/07 23:29:31 schwarze Exp $ */
d413 2
a414 1
	const char		*lc;
d416 1
d418 6
d433 65
d500 1
a500 1
	    "%s%s %s", roff_name[mdoc->last->tok],
@


1.247
log
@style checks related to .Er; inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.246 2017/06/01 15:24:41 schwarze Exp $ */
d76 1
d126 1
a126 1
	NULL,		/* Ad */
d131 4
a134 4
	NULL,		/* Cm */
	NULL,		/* Dv */
	NULL,		/* Er */
	NULL,		/* Ev */
d138 1
a138 1
	NULL,		/* Fl */
d140 3
a142 3
	NULL,		/* Ft */
	NULL,		/* Ic */
	NULL,		/* In */
d146 1
a146 1
	NULL,		/* Op */
d151 2
a152 2
	NULL,		/* Va */
	NULL,		/* Vt */
d166 2
a167 2
	NULL,		/* Ao */
	NULL,		/* Aq */
d171 1
a171 1
	NULL,		/* Bo */
d181 1
a181 1
	NULL,		/* Em */
d184 2
a185 2
	NULL,		/* Ms */
	NULL,		/* No */
d191 2
a192 2
	NULL,		/* Po */
	NULL,		/* Pq */
d194 3
a196 3
	NULL,		/* Ql */
	NULL,		/* Qo */
	NULL,		/* Qq */
d200 2
a201 2
	NULL,		/* So */
	NULL,		/* Sq */
d204 1
a204 1
	NULL,		/* Sy */
d211 1
a211 1
	NULL,		/* Oo */
d216 1
a216 1
	NULL,		/* Hf */
d221 1
a221 1
	NULL,		/* Lk */
d223 2
a224 2
	NULL,		/* Brq */
	NULL,		/* Bro */
d410 22
d805 2
d1055 1
d1078 3
d1171 5
a1181 3
	if (mdoc->last->child != NULL)
		return;

a1182 1

d1246 2
d1276 2
d2112 3
a2114 3
		return;
	}
	assert(nch->next == n->last);
d2362 2
@


1.246
log
@STYLE message about full stop at the end of .Nd; inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.245 2017/05/31 15:30:12 schwarze Exp $ */
d1470 2
d1572 28
d2406 1
a2406 1
		return;
d2410 1
a2410 1
		return;
d2427 4
@


1.245
log
@STYLE message about missing use of Ox/Nx/Fx/Dx; OK jmc@@ wiz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.244 2017/05/30 19:29:31 schwarze Exp $ */
d1067 1
d1081 5
@


1.244
log
@STYLE message about useless macros we don't want (Bt Tn Ud);
not a WARNING because they don't endanger portability
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.243 2017/05/14 13:59:53 schwarze Exp $ */
d54 1
d304 4
d390 19
d2291 1
d2297 7
@


1.243
log
@warn about punctuation between .Xr and .Rs in SEE ALSO;
inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.242 2017/05/05 15:16:25 schwarze Exp $ */
d106 1
d203 1
a203 1
	NULL,		/* Tn */
d673 1
d857 10
@


1.242
log
@Move .sp to the roff modules.  Enough infrastructure is in place
now that this actually saves code: -70 LOC.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.241 2017/05/05 13:17:04 schwarze Exp $ */
d1870 1
a1870 1
		if (n->next == NULL)
@


1.241
log
@move .ll to the roff modules
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.240 2017/05/05 02:06:17 schwarze Exp $ */
a227 1
	post_par,	/* sp */
d328 1
d2087 1
a2087 1
	if (np->tok != ROFF_br && np->tok != MDOC_sp)
d2090 1
a2090 1
	if (np->tok == MDOC_sp) {
d2106 1
a2106 1
	     (np->tok != MDOC_sp && np->tok != ROFF_br)))
@


1.240
log
@Move handling of the roff(7) .ft request from the man(7)
modules to the new roff(7) modules.  As a side effect,
mdoc(7) now handles .ft, too.  Of course, do not use that.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.239 2017/05/04 17:48:24 schwarze Exp $ */
a230 1
	NULL,		/* ll */
@


1.239
log
@Parser reorg:
Generate the first node on the roff level: .br
Fix some column numbers in diagnostic messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.238 2017/04/29 12:43:55 schwarze Exp $ */
d333 2
a334 1
				abort();
@


1.238
log
@Parser unification: use nice ohashes for all three request and macro tables;
no functional change, minus two source files, minus 200 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.237 2017/04/28 16:23:30 schwarze Exp $ */
a227 1
	post_par,	/* br */
d327 12
d1312 1
a1312 1
			case MDOC_br:
d2066 1
a2066 1
	    n->prev->tok != MDOC_br)
d2087 1
a2087 1
	if (np->tok != MDOC_br && np->tok != MDOC_sp)
d2105 2
a2106 2
	    (mdoc->last->tok != MDOC_br ||
	     (np->tok != MDOC_sp && np->tok != MDOC_br)))
@


1.237
log
@Delete .Pp right before the first .Sh and right before any .Ss,
and warn about it; mdoclint(1) does so, and it makes sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.236 2017/04/24 23:06:09 schwarze Exp $ */
d59 1
a59 1
static	void	 rewrite_macro2len(char **);
d452 1
a452 1
			rewrite_macro2len(argv->value);
d467 1
a467 1
			rewrite_macro2len(argv->value);
d594 1
a594 1
			rewrite_macro2len(argv->value);
d1329 2
a1330 2
void
rewrite_macro2len(char **arg)
d1339 1
a1339 1
	else if ((tok = mdoc_hash_find(*arg)) == TOKEN_NONE)
@


1.236
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.235 2017/03/06 17:25:24 schwarze Exp $ */
d2006 3
@


1.235
log
@Using .Nd only makes sense in the NAME section.
Warn if that macro occurs elsewhere.
Triggered by a question from Dag-Erling Smoergrav <des @@ FreeBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.234 2017/02/06 03:41:44 schwarze Exp $ */
d58 1
a58 1
static	size_t		macro2len(int);
d109 1
a109 2
static	v_post mdoc_valids[MDOC_MAX] = {
	NULL,		/* Ap */
d125 1
d234 1
d238 1
a238 1
static	const int rsord[RSORD_MAX] = {
d286 1
a286 1
	v_post *p;
d663 2
a664 3
		mandoc_vmsg(MANDOCERR_ARG_SKIP, mdoc->parse,
		    n->line, n->pos, "%s %s",
		    mdoc_macronames[n->tok], n->child->string);
d808 1
a808 1
	    n->line, n->pos, mdoc_macronames[n->tok]);
d843 1
a843 1
		    n->line, n->pos, mdoc_macronames[n->tok]);
d1051 1
a1051 1
			    n->line, n->pos, mdoc_macronames[n->tok]);
d1074 1
a1074 1
				    "%s in Bd", mdoc_macronames[n->tok]);
d1260 4
a1263 4
			mandoc_vmsg(MANDOCERR_ARG_SKIP,
			    mdoc->parse, nit->line, nit->pos,
			    "It %s", nch->string == NULL ?
			    mdoc_macronames[nch->tok] : nch->string);
d1310 1
a1310 1
				    mdoc_macronames[nc->tok]);
d1316 1
a1316 2
				    "%s before It",
				    mdoc_macronames[nc->tok]);
d1333 1
a1333 1
	int		  tok;
d1480 1
a1480 2
		    nchild->line, nchild->pos,
		    mdoc_macronames[nchild->tok]);
d1558 1
a1558 1
	    "%s %s", mdoc_macronames[mdoc->last->tok], nch->string);
d1601 1
a1601 1
		    n->line, n->pos, mdoc_macronames[n->tok]);
d1635 2
a1636 3
			mandoc_msg(MANDOCERR_RS_BAD,
			    mdoc->parse, nch->line, nch->pos,
			    mdoc_macronames[nch->tok]);
d1789 1
a1789 1
			    n->line, n->pos, mdoc_macronames[n->tok]);
d1910 1
a1910 1
		    mdoc_macronames[nch->tok]);
d2019 2
a2020 2
			    "%s after %s", mdoc_macronames[np->tok],
			    mdoc_macronames[mdoc->last->tok]);
d2028 2
a2029 2
			    mdoc_macronames[np->tok],
			    mdoc_macronames[mdoc->last->tok]);
d2062 2
a2063 3
	    n->prev->line, n->prev->pos,
	    "%s before %s", mdoc_macronames[n->prev->tok],
	    mdoc_macronames[n->tok]);
d2084 1
a2084 1
		    mdoc_macronames[np->tok], np->child->string);
d2096 2
a2097 3
	    mdoc->last->line, mdoc->last->pos,
	    "%s after %s", mdoc_macronames[mdoc->last->tok],
	    mdoc_macronames[np->tok]);
d2348 1
a2348 1
macro2len(int macro)
@


1.234
log
@The .Nm macro does not only use the default name when it has no
argument, but also when the first argument is a child macro.
Arcane issue found in the FreeBSD cxgbetool(8) manual that Baptiste
Daroussin <bapt at FreeBSD> sent me long ago for a different reason.

While solving this, switch to the new technique of doing text
production in the validator, reducing code duplication in the
formatters, which also makes -Ttree output clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.233 2017/01/11 17:39:45 schwarze Exp $ */
d1025 4
@


1.233
log
@Do text production for .Bt, .Ex, .Rv, .Ud at the validation stage
rather than in the formatters.  Use NODE_NOSRC flag for .Lb and
NODE_NOSRC and NODE_NOPRT for .St.  Results in a more rigorous
syntax tree and in 135 lines less code.

This work was triggered by a question from Abhinav Upadhyay <er dot
abhinav dot upadhyay at gmail dot com> (NetBSD) on discuss@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.232 2017/01/10 23:36:24 schwarze Exp $ */
d1004 10
@


1.232
log
@Use new NODE_NOSRC and NODE_NOPRT flags for .Bx and .At.
More rigorous AST and 40 lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.231 2017/01/10 21:54:34 schwarze Exp $ */
d52 1
d97 1
d146 1
a146 1
	post_std,	/* Rv */
d624 4
d656 142
d812 24
d846 4
a915 26
post_lb(POST_ARGS)
{
	struct roff_node	*n;
	char			*libname;

	n = mdoc->last->child;
	assert(n->type == ROFFT_TEXT);
	mandoc_asprintf(&libname, "library \\(Lq%s\\(Rq", n->string);
	free(n->string);
	n->string = libname;
}

static void
post_eoln(POST_ARGS)
{
	const struct roff_node *n;

	n = mdoc->last;
	if (n->child != NULL)
		mandoc_vmsg(MANDOCERR_ARG_SKIP,
		    mdoc->parse, n->line, n->pos,
		    "%s %s", mdoc_macronames[n->tok],
		    n->child->string);
}

static void
a1592 21
post_st(POST_ARGS)
{
	struct roff_node	 *n, *nch;
	const char		 *p;

	n = mdoc->last;
	nch = n->child;

	assert(nch->type == ROFFT_TEXT);

	if ((p = mdoc_a2st(nch->string)) == NULL) {
		mandoc_vmsg(MANDOCERR_ST_BAD, mdoc->parse,
		    nch->line, nch->pos, "St %s", nch->string);
		roff_node_delete(mdoc, n);
	} else {
		free(nch->string);
		nch->string = mandoc_strdup(p);
	}
}

static void
a2323 26
}

/*
 * If no argument is provided,
 * fill in the name of the current manual page.
 */
static void
post_ex(POST_ARGS)
{
	struct roff_node *n;

	post_std(mdoc);

	n = mdoc->last;
	if (n->child != NULL)
		return;

	if (mdoc->meta.name == NULL) {
		mandoc_msg(MANDOCERR_EX_NONAME, mdoc->parse,
		    n->line, n->pos, "Ex");
		return;
	}

	mdoc->next = ROFF_NEXT_CHILD;
	roff_word_alloc(mdoc, n->line, n->pos, mdoc->meta.name);
	mdoc->last = n;
@


1.231
log
@For the .Ux/.Ox family of macros, do text production at the validation
stage rather than in each and every individual formatter, using the
new NODE_NOSRC flag.  More rigorous and also ten lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.230 2017/01/10 13:46:53 schwarze Exp $ */
d959 2
a960 3
	struct roff_node	*n;
	const char		*std_att;
	char			*att;
d963 1
a963 6
	if (n->child == NULL) {
		mdoc->next = ROFF_NEXT_CHILD;
		roff_word_alloc(mdoc, n->line, n->pos, "AT&T UNIX");
		mdoc->last = n;
		return;
	}
d971 2
a972 3
	n = n->child;
	assert(n->type == ROFFT_TEXT);
	if ((std_att = mdoc_a2att(n->string)) == NULL) {
d974 6
a979 2
		    n->line, n->pos, "At %s", n->string);
		mandoc_asprintf(&att, "AT&T UNIX %s", n->string);
d981 3
a983 4
		att = mandoc_strdup(std_att);

	free(n->string);
	n->string = att;
d2102 30
a2131 1
	struct roff_node	*n;
d2139 1
a2139 2
	if ((n = mdoc->last->child) != NULL && (n = n->next) != NULL)
		*n->string = (char)toupper((unsigned char)*n->string);
@


1.230
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.229 2017/01/10 12:54:28 schwarze Exp $ */
d105 1
d168 1
a168 1
	NULL,		/* Bsx */
d178 1
a178 1
	NULL,		/* Fx */
d182 2
a183 2
	NULL,		/* Nx */
	NULL,		/* Ox */
d201 1
a201 1
	NULL,		/* Ux */
d224 1
a224 1
	NULL,		/* Dx */
d1023 35
@


1.229
log
@Introduce flags NODE_NOSRC and NODE_NOPRT for AST nodes.
Use them to mark generated nodes and nodes that shall not produce output.
Let -Ttree output mode display these new flags.
Use NODE_NOSRC for .Ar, .Mt, and .Pa default arguments.
Use NODE_NOPRT for .Dd, .Dt, and .Os.

These will help to make handling of text production macros more rigorous.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.228 2017/01/08 02:01:14 schwarze Exp $ */
d318 1
a318 1
			n->child->flags &= ~MDOC_DELIMC;
d320 1
a320 1
			n->last->flags &= ~MDOC_DELIMO;
d1549 1
a1549 1
	if (mdoc->last->flags & MDOC_LINE)
@


1.228
log
@Tolerate bare tabs in SYNOPSIS .Cd for now.
It's used in half a dozen pages.
Even though i have been thinking about it for years,
i still can't suggest anything better.
The false positives are annoying.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.227 2017/01/08 00:10:22 schwarze Exp $ */
d939 1
d941 1
d947 1
d1938 2
d1957 1
a1957 1
		goto out;
a1968 2
out:
	roff_node_delete(mdoc, n);
d1979 2
d1984 1
a1984 1
		goto out;
d2036 1
a2036 1
		goto out;  /* msec and arch remain NULL. */
d2054 1
a2054 1
		goto out;
a2064 3

out:
	roff_node_delete(mdoc, n);
d2092 2
d2114 1
a2114 1
		goto out;
d2118 1
a2118 1
		goto out;
a2134 3

out:
	roff_node_delete(mdoc, n);
@


1.227
log
@Stricter validation of the NAME section, in particular:
- require a comma between names
- reject all other text nodes
- reject all empty Nm below NAME, not only in the leading position
- reject Nm after Nd
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.226 2016/12/28 17:21:17 schwarze Exp $ */
d298 2
a299 1
		if (n->sec != SEC_SYNOPSIS || n->parent->tok != MDOC_Fd)
@


1.226
log
@Make the second, section number argument of .Xr mandatory.
In fact, we have been requiring it for many years.
The only reason to not warn when it was missing
was excessive traditionalism - it was optional in 4.4BSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.225 2016/10/09 18:16:46 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2016 Ingo Schwarze <schwarze@@openbsd.org>
d845 2
a846 2
	if (mdoc->meta.name != NULL)
		return;
d848 2
a849 3
	deroff(&mdoc->meta.name, n);

	if (mdoc->meta.name == NULL)
d1591 4
d1596 1
a1596 1
			break;
d1604 6
a1609 2
			if (hasnm)
				break;
d1614 1
a1614 1
			break;
d1616 1
@


1.225
log
@Delete complicated code dealing with .Bl -tag without -width,
and just let it default to -width 6n, which agrees with the
traditional -width Ds that is still in widespread use.

I just pushed a patch upstream to GNU roff that does the same for
groff_mdoc(7).  Before, groff contained code that was even more
complicated than mandoc, but both resulted in quite different
user-visible output.  Now, both agree, and output is nicer for both.

Useless complication noticed by Carsten Kunze (Heirloom roff).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.224 2016/08/20 14:43:39 schwarze Exp $ */
d104 1
d147 1
a147 1
	NULL,		/* Xr */
d1802 15
d2012 1
a2012 1
	/* Mandatory second argument: section.*/
@


1.224
log
@If a column list starts with implicit rows (that is, rows without .It)
and roff-level nodes (e.g. tbl or eqn) follow, don't run into an
assertion.  Instead, wrap the roff-level nodes in their own row.
Issue found by tb@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.223 2016/08/11 11:39:19 schwarze Exp $ */
a67 1
static	void	 post_bl_block_tag(POST_ARGS);
a1091 8
	/*
	 * These are fairly complicated, so we've broken them into two
	 * functions.  post_bl_block_tag() is called when a -tag is
	 * specified, but no -width (it must be guessed).  The second
	 * when a -width is specified (macro indicators must be
	 * rewritten into real lengths).
	 */

a1092 7

	if (n->norm->Bl.type == LIST_tag &&
	    n->norm->Bl.width == NULL) {
		post_bl_block_tag(mdoc);
		assert(n->norm->Bl.width != NULL);
	}

a1146 65
}

static void
post_bl_block_tag(POST_ARGS)
{
	struct roff_node *n, *nn;
	size_t		  sz, ssz;
	int		  i;
	char		  buf[24];

	/*
	 * Calculate the -width for a `Bl -tag' list if it hasn't been
	 * provided.  Uses the first head macro.  NOTE AGAIN: this is
	 * ONLY if the -width argument has NOT been provided.  See
	 * rewrite_macro2len() for converting the -width string.
	 */

	sz = 10;
	n = mdoc->last;

	for (nn = n->body->child; nn != NULL; nn = nn->next) {
		if (nn->tok != MDOC_It)
			continue;

		assert(nn->type == ROFFT_BLOCK);
		nn = nn->head->child;

		if (nn == NULL)
			break;

		if (nn->type == ROFFT_TEXT) {
			sz = strlen(nn->string) + 1;
			break;
		}

		if (0 != (ssz = macro2len(nn->tok)))
			sz = ssz;

		break;
	}

	/* Defaults to ten ens. */

	(void)snprintf(buf, sizeof(buf), "%un", (unsigned int)sz);

	/*
	 * We have to dynamically add this to the macro's argument list.
	 * We're guaranteed that a MDOC_Width doesn't already exist.
	 */

	assert(n->args != NULL);
	i = (int)(n->args->argc)++;

	n->args->argv = mandoc_reallocarray(n->args->argv,
	    n->args->argc, sizeof(struct mdoc_argv));

	n->args->argv[i].arg = MDOC_Width;
	n->args->argv[i].line = n->line;
	n->args->argv[i].pos = n->pos;
	n->args->argv[i].sz = 1;
	n->args->argv[i].value = mandoc_malloc(sizeof(char *));
	n->args->argv[i].value[0] = mandoc_strdup(buf);

	/* Set our width! */
	n->norm->Bl.width = n->args->argv[i].value[0];
@


1.223
log
@oops, fix stupid typo in previous
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.222 2016/08/11 10:46:27 schwarze Exp $ */
d1323 1
d1326 32
a1357 3
		     nchild->next != NULL &&
		     nchild->next->tok == MDOC_It)) {
			nchild = nchild->next;
a1372 1
		nnext   = nchild->next;
a1377 1
		assert(nchild->prev == NULL);
@


1.222
log
@If a .Bd display is on the one hand doomed to be deleted because
it has no type, but is on the other hand breaking another block,
delete its end marker as well, or the end marker may remain behind
as an orphan, triggering an assertion in the terminal formatter.
Problem found by tb@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.221 2016/08/10 20:16:43 schwarze Exp $ */
d881 2
a882 1
			if (n->tok == MDOC_Bd && n->parent->args == NULL)
@


1.221
log
@Don't deref NULL if the only child of the first .Sh is an empty
in-line macro, and don't printf("%s", NULL) if the first child
of the first .Sh is a macro; again found by tb@@ with afl(1).
(No, you should never use macros in any .Sh at all, please.)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.220 2016/08/10 12:29:02 schwarze Exp $ */
d880 4
a883 3
		if (n->end != ENDBODY_NOT)
			break;
		if (n->child == NULL)
@


1.220
log
@Don't printf("%s", NULL) if .It has a macro as an argument
in a list of a type where items don't takes arguments.
Issue found by tb@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.219 2016/08/10 12:04:57 schwarze Exp $ */
d1755 3
a1757 2
	const char	*goodsec;
	enum roff_sec	 sec;
d1773 4
a1776 2
		    sec == SEC_CUSTOM ? mdoc->last->child->string :
		    secnames[sec]);
@


1.219
log
@When validating a .Bl list that defaults to -item for want of a type,
don't let a subsequent -width access mdoc_argnames[] out of bounds.
Found by tb@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.218 2016/08/09 15:08:15 schwarze Exp $ */
d1058 1
a1058 1
		if (nit->head->child != NULL)
d1061 2
a1062 1
			    "It %s", nit->head->child->string);
@


1.218
log
@fix printf("%s", NULL);
found while investigating an unrelated bug report from jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.217 2016/01/08 17:48:04 schwarze Exp $ */
d503 1
@


1.217
log
@Delete the redundant "nchild" member of struct roff_node, replacing
most uses by one, a few by two pointer checks, and only one by a
tiny loop - not only making data smaller, but code shorter as well.

This gets rid of an implicit invariant that confused both static
analysis tools and human auditors.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.216 2015/10/30 19:03:36 schwarze Exp $ */
d1767 1
a1767 1
	if (SEC_NAME != sec && SEC_NONE == mdoc->lastnamed)
d1769 3
a1771 2
		    mdoc->last->line, mdoc->last->pos,
		    "Sh %s", secnames[sec]);
@


1.216
log
@If a .Bd block has no arguments at all, drop the block and only keep
its contents.  Removing a gratuitious difference to groff output
found after a related bug report from krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.215 2015/10/21 23:49:05 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2015 Ingo Schwarze <schwarze@@openbsd.org>
d1272 2
a1273 1
	argv->sz += nh->nchild;
a1285 1
	nh->nchild = 0;
d1346 2
a1347 2
		if (--nbody->nchild == 0) {
			nbody->child = NULL;
d1349 1
a1349 3
			assert(nnext == NULL);
		} else {
			nbody->child = nnext;
a1350 1
		}
a1360 1
		nparent->nchild++;
d1678 3
a1680 1
		if (n->tok != MDOC_Xr || n->nchild < 2)
d1736 1
a1736 1
		if ((n->tok == MDOC_An && n->nchild) || child_an(n))
d1923 1
a1923 1
		if (np->nchild > 1)
@


1.215
log
@Move all mdoc(7) node validation done before child parsing
to the new separate validation pass, except for a tiny bit
needed by the parser which goes to the new mdoc_state() module;
cleaner, simpler, and surprisingly also shorter by 15 lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.214 2015/10/20 02:00:49 schwarze Exp $ */
d889 10
@


1.214
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.213 2015/10/19 20:03:57 schwarze Exp $ */
a41 1
#define	PRE_ARGS  struct roff_man *mdoc, struct roff_node *n
a49 1
typedef	void	(*v_pre)(PRE_ARGS);
a51 5
struct	valids {
	v_pre	 pre;
	v_post	 post;
};

d61 1
d63 1
d70 1
a71 1
static	void	 post_d1(POST_ARGS);
d73 1
a87 1
static	void	 post_literal(POST_ARGS);
d91 1
d94 1
d104 1
d106 124
a229 132
static	void	 pre_an(PRE_ARGS);
static	void	 pre_bd(PRE_ARGS);
static	void	 pre_bl(PRE_ARGS);
static	void	 pre_display(PRE_ARGS);
static	void	 pre_obsolete(PRE_ARGS);
static	void	 pre_par(PRE_ARGS);
static	void	 pre_std(PRE_ARGS);

static	const struct valids mdoc_valids[MDOC_MAX] = {
	{ NULL, NULL },				/* Ap */
	{ NULL, post_dd },			/* Dd */
	{ NULL, post_dt },			/* Dt */
	{ NULL, post_os },			/* Os */
	{ NULL, post_sh },			/* Sh */
	{ NULL, post_ignpar },			/* Ss */
	{ pre_par, post_par },			/* Pp */
	{ pre_display, post_d1 },		/* D1 */
	{ pre_display, post_literal },		/* Dl */
	{ pre_bd, post_literal },		/* Bd */
	{ NULL, NULL },				/* Ed */
	{ pre_bl, post_bl },			/* Bl */
	{ NULL, NULL },				/* El */
	{ pre_par, post_it },			/* It */
	{ NULL, NULL },				/* Ad */
	{ pre_an, post_an },			/* An */
	{ NULL, post_defaults },		/* Ar */
	{ NULL, NULL },				/* Cd */
	{ NULL, NULL },				/* Cm */
	{ NULL, NULL },				/* Dv */
	{ NULL, NULL },				/* Er */
	{ NULL, NULL },				/* Ev */
	{ pre_std, post_ex },			/* Ex */
	{ NULL, post_fa },			/* Fa */
	{ NULL, NULL },				/* Fd */
	{ NULL, NULL },				/* Fl */
	{ NULL, post_fn },			/* Fn */
	{ NULL, NULL },				/* Ft */
	{ NULL, NULL },				/* Ic */
	{ NULL, NULL },				/* In */
	{ NULL, post_defaults },		/* Li */
	{ NULL, post_nd },			/* Nd */
	{ NULL, post_nm },			/* Nm */
	{ NULL, NULL },				/* Op */
	{ pre_obsolete, NULL },			/* Ot */
	{ NULL, post_defaults },		/* Pa */
	{ pre_std, NULL },			/* Rv */
	{ NULL, post_st },			/* St */
	{ NULL, NULL },				/* Va */
	{ NULL, NULL },				/* Vt */
	{ NULL, NULL },				/* Xr */
	{ NULL, NULL },				/* %A */
	{ NULL, post_hyph },			/* %B */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, NULL },				/* %D */
	{ NULL, NULL },				/* %I */
	{ NULL, NULL },				/* %J */
	{ NULL, post_hyph },			/* %N */
	{ NULL, post_hyph },			/* %O */
	{ NULL, NULL },				/* %P */
	{ NULL, post_hyph },			/* %R */
	{ NULL, post_hyph },			/* %T */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, NULL },				/* %V */
	{ NULL, NULL },				/* Ac */
	{ NULL, NULL },				/* Ao */
	{ NULL, NULL },				/* Aq */
	{ NULL, post_at },			/* At */
	{ NULL, NULL },				/* Bc */
	{ NULL, post_bf },			/* Bf */
	{ NULL, NULL },				/* Bo */
	{ NULL, NULL },				/* Bq */
	{ NULL, NULL },				/* Bsx */
	{ NULL, post_bx },			/* Bx */
	{ pre_obsolete, NULL },			/* Db */
	{ NULL, NULL },				/* Dc */
	{ NULL, NULL },				/* Do */
	{ NULL, NULL },				/* Dq */
	{ NULL, NULL },				/* Ec */
	{ NULL, NULL },				/* Ef */
	{ NULL, NULL },				/* Em */
	{ NULL, NULL },				/* Eo */
	{ NULL, NULL },				/* Fx */
	{ NULL, NULL },				/* Ms */
	{ NULL, NULL },				/* No */
	{ NULL, post_ns },			/* Ns */
	{ NULL, NULL },				/* Nx */
	{ NULL, NULL },				/* Ox */
	{ NULL, NULL },				/* Pc */
	{ NULL, NULL },				/* Pf */
	{ NULL, NULL },				/* Po */
	{ NULL, NULL },				/* Pq */
	{ NULL, NULL },				/* Qc */
	{ NULL, NULL },				/* Ql */
	{ NULL, NULL },				/* Qo */
	{ NULL, NULL },				/* Qq */
	{ NULL, NULL },				/* Re */
	{ NULL, post_rs },			/* Rs */
	{ NULL, NULL },				/* Sc */
	{ NULL, NULL },				/* So */
	{ NULL, NULL },				/* Sq */
	{ NULL, post_sm },			/* Sm */
	{ NULL, post_hyph },			/* Sx */
	{ NULL, NULL },				/* Sy */
	{ NULL, NULL },				/* Tn */
	{ NULL, NULL },				/* Ux */
	{ NULL, NULL },				/* Xc */
	{ NULL, NULL },				/* Xo */
	{ NULL, post_fo },			/* Fo */
	{ NULL, NULL },				/* Fc */
	{ NULL, NULL },				/* Oo */
	{ NULL, NULL },				/* Oc */
	{ NULL, post_bk },			/* Bk */
	{ NULL, NULL },				/* Ek */
	{ NULL, post_eoln },			/* Bt */
	{ NULL, NULL },				/* Hf */
	{ pre_obsolete, NULL },			/* Fr */
	{ NULL, post_eoln },			/* Ud */
	{ NULL, post_lb },			/* Lb */
	{ pre_par, post_par },			/* Lp */
	{ NULL, NULL },				/* Lk */
	{ NULL, post_defaults },		/* Mt */
	{ NULL, NULL },				/* Brq */
	{ NULL, NULL },				/* Bro */
	{ NULL, NULL },				/* Brc */
	{ NULL, NULL },				/* %C */
	{ pre_obsolete, post_es },		/* Es */
	{ pre_obsolete, post_en },		/* En */
	{ NULL, NULL },				/* Dx */
	{ NULL, NULL },				/* %Q */
	{ NULL, post_par },			/* br */
	{ NULL, post_par },			/* sp */
	{ NULL, NULL },				/* %U */
	{ NULL, NULL },				/* Ta */
	{ NULL, NULL },				/* ll */
a278 24
mdoc_valid_pre(struct roff_man *mdoc, struct roff_node *n)
{
	v_pre	 p;

	switch (n->type) {
	case ROFFT_TEXT:
		if (n->sec != SEC_SYNOPSIS || n->parent->tok != MDOC_Fd)
			check_text(mdoc, n->line, n->pos, n->string);
		return;
	case ROFFT_TBL:
	case ROFFT_EQN:
	case ROFFT_ROOT:
		return;
	default:
		break;
	}

	check_args(mdoc, n);
	p = mdoc_valids[n->tok].pre;
	if (*p)
		(*p)(mdoc, n);
}

void
d282 1
a282 1
	v_post p;
d298 3
d308 1
d323 1
a323 1
		p = mdoc_valids[n->tok].post;
d368 1
a368 20
pre_display(PRE_ARGS)
{
	struct roff_node *node;

	if (n->type != ROFFT_BLOCK)
		return;

	for (node = mdoc->last->parent; node; node = node->parent)
		if (node->type == ROFFT_BLOCK)
			if (MDOC_Bd == node->tok)
				break;

	if (node)
		mandoc_vmsg(MANDOCERR_BD_NEST,
		    mdoc->parse, n->line, n->pos,
		    "%s in Bd", mdoc_macronames[n->tok]);
}

static void
pre_bl(PRE_ARGS)
d370 1
d376 2
a377 2
	if (n->type != ROFFT_BLOCK)
		return;
a540 1
	pre_par(mdoc, n);
d544 1
a544 1
pre_bd(PRE_ARGS)
d546 1
d551 1
a551 5
	pre_display(mdoc, n);

	if (n->type != ROFFT_BLOCK)
		return;

a616 1
	pre_par(mdoc, n);
d620 1
a620 1
pre_an(PRE_ARGS)
d622 1
d626 1
d647 1
a647 1
pre_std(PRE_ARGS)
d649 1
d651 3
a653 2
	if (n->args && 1 == n->args->argc)
		if (MDOC_Std == n->args->argv[0].arg)
d661 1
a661 1
pre_obsolete(PRE_ARGS)
d663 1
d665 1
d872 1
a872 18
post_d1(POST_ARGS)
{
	struct roff_node	*n;

	n = mdoc->last;

	if (n->type != ROFFT_BODY)
		return;

	if (n->child == NULL)
		mandoc_msg(MANDOCERR_BLK_EMPTY, mdoc->parse,
		    n->line, n->pos, "D1");

	post_hyph(mdoc);
}

static void
post_literal(POST_ARGS)
d874 1
a874 1
	struct roff_node	*n;
d877 27
a903 7

	if (n->type != ROFFT_BODY || n->end != ENDBODY_NOT)
		return;

	if (n->child == NULL)
		mandoc_msg(MANDOCERR_BLK_EMPTY, mdoc->parse,
		    n->line, n->pos, mdoc_macronames[n->tok]);
d978 2
d995 1
d1004 1
d1015 2
d1077 2
d1223 2
a1225 1

d1872 1
a1872 1
pre_par(PRE_ARGS)
d1874 1
d1876 2
a1877 1
	if (NULL == mdoc->last)
d1887 3
a1889 3
	if (MDOC_Pp != mdoc->last->tok &&
	    MDOC_Lp != mdoc->last->tok &&
	    MDOC_br != mdoc->last->tok)
d1891 1
a1891 1
	if (MDOC_Bl == n->tok && n->norm->Bl.comp)
d1893 1
a1893 1
	if (MDOC_Bd == n->tok && n->norm->Bd.comp)
d1895 1
a1895 1
	if (MDOC_It == n->tok && n->parent->norm->Bl.comp)
d1899 2
a1900 2
	    mdoc->last->line, mdoc->last->pos,
	    "%s before %s", mdoc_macronames[mdoc->last->tok],
d1902 1
a1902 1
	roff_node_delete(mdoc, mdoc->last);
d1911 2
d2157 2
a2159 1

@


1.213
log
@style cleanup, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.212 2015/10/12 21:25:36 schwarze Exp $ */
a63 1
static	enum roff_sec	a2sec(const char *);
a110 1
static	void	 pre_dd(PRE_ARGS);
a111 2
static	void	 pre_dt(PRE_ARGS);
static	void	 pre_literal(PRE_ARGS);
a112 1
static	void	 pre_os(PRE_ARGS);
d118 3
a120 3
	{ pre_dd, post_dd },			/* Dd */
	{ pre_dt, post_dt },			/* Dt */
	{ pre_os, post_os },			/* Os */
d125 1
a125 1
	{ pre_literal, post_literal },		/* Dl */
d313 1
a313 1
mdoc_valid_post(struct roff_man *mdoc)
d319 8
a326 3
	if (n->flags & MDOC_VALID)
		return;
	n->flags |= MDOC_VALID | MDOC_ENDED;
d328 2
d356 2
d599 1
a599 1
	pre_literal(mdoc, n);
a718 42
pre_dt(PRE_ARGS)
{

	if (mdoc->meta.title != NULL)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Dt");
	else if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dt after Os");
}

static void
pre_os(PRE_ARGS)
{

	if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Os");
	else if (mdoc->flags & MDOC_PBODY)
		mandoc_msg(MANDOCERR_PROLOG_LATE, mdoc->parse,
		    n->line, n->pos, "Os");
}

static void
pre_dd(PRE_ARGS)
{

	if (mdoc->meta.date != NULL)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Dd");
	else if (mdoc->flags & MDOC_PBODY)
		mandoc_msg(MANDOCERR_PROLOG_LATE, mdoc->parse,
		    n->line, n->pos, "Dd");
	else if (mdoc->meta.title != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dd after Dt");
	else if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dd after Os");
}

static void
d942 1
a942 1
	if (n->type != ROFFT_BODY)
a947 7

	if (n->tok == MDOC_Bd &&
	    n->norm->Bd.type != DISP_literal &&
	    n->norm->Bd.type != DISP_unfilled)
		return;

	mdoc->flags &= ~MDOC_LITERAL;
a964 1
	mdoc->next = ROFF_NEXT_CHILD;
d968 1
d974 1
d1334 2
a1779 1
	struct roff_node *n;
a1780 1
	char		*secname;
d1790 1
a1790 3
	secname = NULL;
	deroff(&secname, mdoc->last);
	sec = NULL == secname ? SEC_CUSTOM : a2sec(secname);
d1797 1
a1797 1
		    "Sh %s", secname);
d1801 1
a1801 1
	if (SEC_SYNOPSIS == sec) {
a1812 14
	/*
	 * Set the section attribute for the current HEAD, for its
	 * parent BLOCK, and for the HEAD children; the latter can
	 * only be TEXT nodes, so no recursion is needed.
	 * For other blocks and elements, including .Sh BODY, this is
	 * done when allocating the node data structures, but for .Sh
	 * BLOCK and HEAD, the section is still unknown at that time.
	 */

	mdoc->last->parent->sec = sec;
	mdoc->last->sec = sec;
	for (n = mdoc->last->child; n != NULL; n = n->next)
		n->sec = sec;

d1815 1
a1815 2
	if (SEC_CUSTOM == sec) {
		free(secname);
a1816 1
	}
d1826 1
a1826 1
		    "Sh %s", secname);
d1831 1
a1831 1
		    "Sh %s", secname);
d1839 1
a1839 2
	if (mdoc->meta.msec == NULL) {
		free(secname);
a1840 1
	}
d1865 1
a1865 1
		    "Sh %s for %s only", secname, goodsec);
a1869 1
	free(secname);
a1971 29
pre_literal(PRE_ARGS)
{

	pre_display(mdoc, n);

	if (n->type != ROFFT_BODY)
		return;

	/*
	 * The `Dl' (note "el" not "one") and `Bd -literal' and `Bd
	 * -unfilled' macros set MDOC_LITERAL on entrance to the body.
	 */

	switch (n->tok) {
	case MDOC_Dl:
		mdoc->flags |= MDOC_LITERAL;
		break;
	case MDOC_Bd:
		if (DISP_literal == n->norm->Bd.type)
			mdoc->flags |= MDOC_LITERAL;
		if (DISP_unfilled == n->norm->Bd.type)
			mdoc->flags |= MDOC_LITERAL;
		break;
	default:
		abort();
	}
}

static void
d1977 4
a1980 1
	if (mdoc->meta.date)
d1982 9
a1991 1
	n = mdoc->last;
d2019 12
d2133 6
d2204 2
a2205 2
static enum roff_sec
a2sec(const char *p)
@


1.212
log
@Delete an assignment that is unconditionally overwritten two lines later;
found by Svyatoslav Mishyn <juef at openmailbox dot org>
with the clang static analyzer.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.211 2015/10/12 00:07:27 schwarze Exp $ */
a759 1
	enum mdocargt	  arg;
d771 1
a771 1
	assert(MDOC_Bf == np->parent->tok);
d776 2
a777 2
	if (NULL == np->parent->args) {
		if (NULL == nch) {
d784 1
a784 1
	if (NULL != nch)
d790 3
a792 3
	if (np->parent->args) {
		arg = np->parent->args->argv[0].arg;
		if (MDOC_Emphasis == arg)
d794 2
a795 1
		else if (MDOC_Literal == arg)
d797 2
a798 1
		else if (MDOC_Symbolic == arg)
d800 2
a801 1
		else
d803 1
d809 1
a809 1
	if (0 == strcmp(np->child->string, "Em"))
d811 1
a811 1
	else if (0 == strcmp(np->child->string, "Li"))
d813 1
a813 1
	else if (0 == strcmp(np->child->string, "Sy"))
d840 1
a840 1
	if (n->child)
d929 1
a929 1
	if (NULL != mdoc->meta.name)
d934 1
a934 1
	if (NULL == mdoc->meta.name)
d1006 1
a1006 1
	if (mdoc->last->child)
d1050 1
a1050 1
	if (NULL == (std_att = mdoc_a2att(n->string))) {
d1139 2
a1140 1
		for (i = 0, nch = nit->child; nch; nch = nch->next)
d1169 2
a1170 2
	if (LIST_tag == n->norm->Bl.type &&
	    NULL == n->norm->Bl.width) {
d1172 1
a1172 1
		assert(n->norm->Bl.width);
d1175 2
a1176 2
	for (ni = n->body->child; ni; ni = ni->next) {
		if (NULL == ni->body)
d1179 1
a1179 1
		while (NULL != nc) {
d1189 1
a1189 1
			if (NULL == ni->next) {
d1194 2
a1195 2
			} else if (0 == n->norm->Bl.comp &&
			    LIST_column != n->norm->Bl.type) {
d1249 2
a1250 2
	for (nn = n->body->child; nn; nn = nn->next) {
		if (MDOC_It != nn->tok)
d1279 1
a1279 1
	assert(n->args);
d1412 2
a1413 2
		assert(NULL == nchild->prev);
		if (0 == --nbody->nchild) {
d1416 1
a1416 1
			assert(NULL == nnext);
d1432 1
a1432 1
		if (NULL == nprev)
d1456 1
a1456 1
post_sm(struct roff_man *mdoc)
d1537 1
a1537 1
	if (NULL == (p = mdoc_a2st(nch->string))) {
d1665 1
a1665 1
	if (MDOC_LINE & mdoc->last->flags)
d1870 1
a1870 1
	for (n = mdoc->last->child; n; n = n->next)
d1952 2
a1953 2
	if (NULL != (np = mdoc->last->child))
		if (MDOC_Pp == np->tok || MDOC_Lp == np->tok) {
d1961 2
a1962 2
	if (NULL != (np = mdoc->last->last))
		if (MDOC_Pp == np->tok || MDOC_Lp == np->tok) {
d2020 1
a2020 1
	if (NULL == (np = mdoc->last->prev)) {
d2022 1
a2022 1
		if (MDOC_Sh != np->tok && MDOC_Ss != np->tok)
d2024 3
a2026 3
	} else if (MDOC_Pp != np->tok && MDOC_Lp != np->tok &&
	    (MDOC_br != mdoc->last->tok ||
	     (MDOC_sp != np->tok && MDOC_br != np->tok)))
d2075 1
a2075 1
	if (NULL == n->child || '\0' == n->child->string[0]) {
d2190 1
a2190 2
	n = mdoc->last->child;
	if (n && NULL != (n = n->next))
d2228 2
a2229 2
	if (NULL == defbuf) {
		if (-1 == uname(&utsname)) {
d2255 1
a2255 1
	if (n->child)
@


1.211
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.210 2015/10/06 18:30:44 schwarze Exp $ */
a1830 1
	sec = SEC_CUSTOM;
@


1.210
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.209 2015/09/26 00:53:15 schwarze Exp $ */
d302 1
a302 1
		/* FALLTHROUGH */
a303 1
		/* FALLTHROUGH */
a304 1
		/* FALLTHROUGH */
a329 1
		/* FALLTHROUGH */
a330 1
		/* FALLTHROUGH */
a562 1
		/* FALLTHROUGH */
a563 1
		/* FALLTHROUGH */
a564 1
		/* FALLTHROUGH */
a565 1
		/* FALLTHROUGH */
a572 1
		/* FALLTHROUGH */
a573 1
		/* FALLTHROUGH */
a1014 1
		/* FALLTHROUGH */
a1104 1
		/* FALLTHROUGH */
a1105 1
		/* FALLTHROUGH */
a1106 1
		/* FALLTHROUGH */
a1107 1
		/* FALLTHROUGH */
a1115 1
		/* FALLTHROUGH */
a1116 1
		/* FALLTHROUGH */
a1117 1
		/* FALLTHROUGH */
a1177 1
				/* FALLTHROUGH */
a1178 1
				/* FALLTHROUGH */
a1910 1
		/* FALLTHROUGH */
@


1.209
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.208 2015/09/14 15:35:47 schwarze Exp $ */
d1822 2
a1823 2
			return(1);
	return(0);
d2295 1
a2295 1
			return((enum roff_sec)i);
d2297 1
a2297 1
	return(SEC_CUSTOM);
d2306 1
a2306 1
		return(12);
d2308 1
a2308 1
		return(12);
d2310 1
a2310 1
		return(12);
d2312 1
a2312 1
		return(12);
d2314 1
a2314 1
		return(12);
d2316 1
a2316 1
		return(12);
d2318 1
a2318 1
		return(12);
d2320 1
a2320 1
		return(12);
d2322 1
a2322 1
		return(10);
d2324 1
a2324 1
		return(10);
d2326 1
a2326 1
		return(12);
d2328 1
a2328 1
		return(12);
d2330 1
a2330 1
		return(12);
d2332 1
a2332 1
		return(10);
d2334 1
a2334 1
		return(17);
d2336 1
a2336 1
		return(15);
d2338 1
a2338 1
		return(12);
d2340 1
a2340 1
		return(10);
d2342 1
a2342 1
		return(16);
d2344 1
a2344 1
		return(16);
d2346 1
a2346 1
		return(10);
d2348 1
a2348 1
		return(16);
d2350 1
a2350 1
		return(6);
d2352 1
a2352 1
		return(10);
d2354 1
a2354 1
		return(12);
d2356 1
a2356 1
		return(10);
d2358 1
a2358 1
		return(14);
d2360 1
a2360 1
		return(32);
d2362 1
a2362 1
		return(12);
d2364 1
a2364 1
		return(12);
d2366 1
a2366 1
		return(12);
d2368 1
a2368 1
		return(16);
d2370 1
a2370 1
		return(12);
d2372 1
a2372 1
		return(12);
d2374 1
a2374 1
		return(12);
d2376 1
a2376 1
		return(6);
d2378 1
a2378 1
		return(16);
d2380 1
a2380 1
		return(10);
d2382 1
a2382 1
		return(12);
d2384 1
a2384 1
		return(12);
d2386 1
a2386 1
		return(10);
d2390 1
a2390 1
	return(0);
@


1.208
log
@Remove the warning about children of .Vt blocks because actually,
.Vt type global_variable No = Dv defined_constant ;
is the best way to specify in the SYNOPSIS how a global variable
is initialized in the rare case where that matters.
Issue noticed by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.207 2015/04/23 16:17:04 schwarze Exp $ */
a657 1
			/* NOTREACHED */
a1030 1
		/* NOTREACHED */
a2079 1
		/* NOTREACHED */
@


1.207
log
@Unify mdoc_deroff() and man_deroff() into a common function deroff().
No functional change except that for mdoc(7), it now skips leading
escape sequences just like it already did for man(7).
Escape sequences rarely occur in mdoc(7) code and if they do,
skipping them is an improvement in this context.
Minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.206 2015/04/20 09:48:19 schwarze Exp $ */
a107 1
static	void	 post_vt(POST_ARGS);
d161 1
a161 1
	{ NULL, post_vt },			/* Vt */
a922 22
}

static void
post_vt(POST_ARGS)
{
	const struct roff_node *n;

	/*
	 * The Vt macro comes in both ELEM and BLOCK form, both of which
	 * have different syntaxes (yet more context-sensitive
	 * behaviour).  ELEM types must have a child, which is already
	 * guaranteed by the in_line parsing routine; BLOCK types,
	 * specifically the BODY, should only have TEXT children.
	 */

	if (mdoc->last->type != ROFFT_BODY)
		return;

	for (n = mdoc->last->child; n; n = n->next)
		if (n->type != ROFFT_TEXT)
			mandoc_msg(MANDOCERR_VT_CHILD, mdoc->parse,
			    n->line, n->pos, mdoc_macronames[n->tok]);
@


1.206
log
@Avoid out-of-bounds read access before the beginning of the
mdoc_macros[] array.  This sometimes prevented proper warnings
about text nodes preceding the first section header.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.205 2015/04/19 14:25:05 schwarze Exp $ */
d963 1
a963 1
	mdoc_deroff(&mdoc->meta.name, n);
d1877 1
a1877 1
	mdoc_deroff(&secname, mdoc->last);
d2126 1
a2126 1
	mdoc_deroff(&datestr, n);
d2261 1
a2261 1
	mdoc_deroff(&mdoc->meta.os, n);
@


1.205
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.204 2015/04/19 13:59:37 schwarze Exp $ */
d1556 2
a1557 1
	while (n != NULL && mdoc_macros[n->tok].flags & MDOC_PROLOGUE)
@


1.204
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.203 2015/04/19 13:50:10 schwarze Exp $ */
d1045 2
a1046 2
		mdoc_word_alloc(mdoc, nn->line, nn->pos, "file");
		mdoc_word_alloc(mdoc, nn->line, nn->pos, "...");
d1051 1
a1051 1
		mdoc_word_alloc(mdoc, nn->line, nn->pos, "~");
d1070 1
a1070 1
		mdoc_word_alloc(mdoc, n->line, n->pos, "AT&T UNIX");
d2309 1
a2309 1
	mdoc_word_alloc(mdoc, n->line, n->pos, mdoc->meta.name);
@


1.203
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.202 2015/04/18 16:04:40 schwarze Exp $ */
d1263 1
a1263 1
	else if ((tok = mdoc_hash_find(*arg)) == MDOC_MAX)
d1759 1
a1759 1
		case MDOC_MAX:
@


1.202
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.201 2015/04/02 22:06:17 schwarze Exp $ */
d37 1
d899 1
a899 1
			mdoc_node_delete(mdoc, n->last);
d1241 1
a1241 1
				mdoc_node_delete(mdoc, nc);
d1352 1
a1352 1
			mdoc_node_delete(mdoc, nch);
d1393 1
a1393 1
		mdoc_node_delete(NULL, nch);
d1492 1
a1492 1
		mdoc_node_delete(mdoc, n);
d1580 1
a1580 1
		mdoc_node_delete(mdoc, n);
d1627 1
a1627 1
		 * repeats mdoc_node_unlink(), but since we're
d2000 1
a2000 1
			mdoc_node_delete(mdoc, np);
d2009 1
a2009 1
			mdoc_node_delete(mdoc, np);
d2042 1
a2042 1
	mdoc_node_delete(mdoc, mdoc->last);
d2075 1
a2075 1
	mdoc_node_delete(mdoc, mdoc->last);
d2134 1
a2134 1
	mdoc_node_delete(mdoc, n);
d2219 1
a2219 1
	mdoc_node_delete(mdoc, n);
d2285 1
a2285 1
	mdoc_node_delete(mdoc, n);
@


1.201
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.200 2015/04/02 21:03:18 schwarze Exp $ */
d41 2
a42 2
#define	PRE_ARGS  struct mdoc *mdoc, struct roff_node *n
#define	POST_ARGS struct mdoc *mdoc
d58 2
a59 2
static	void	 check_text(struct mdoc *, int, int, char *);
static	void	 check_argv(struct mdoc *,
d61 1
a61 1
static	void	 check_args(struct mdoc *, struct roff_node *);
d294 1
a294 1
mdoc_valid_pre(struct mdoc *mdoc, struct roff_node *n)
d320 1
a320 1
mdoc_valid_post(struct mdoc *mdoc)
d363 1
a363 1
check_args(struct mdoc *mdoc, struct roff_node *n)
d376 1
a376 1
check_argv(struct mdoc *mdoc, struct roff_node *n, struct mdoc_argv *v)
d385 1
a385 1
check_text(struct mdoc *mdoc, int ln, int pos, char *p)
d1040 1
a1040 1
	mdoc->next = MDOC_NEXT_CHILD;
d1068 1
a1068 1
		mdoc->next = MDOC_NEXT_CHILD;
d1496 1
a1496 1
post_sm(struct mdoc *mdoc)
d2307 1
a2307 1
	mdoc->next = MDOC_NEXT_CHILD;
@


1.200
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.199 2015/02/23 13:54:39 schwarze Exp $ */
d41 1
a41 1
#define	PRE_ARGS  struct mdoc *mdoc, struct mdoc_node *n
d60 5
a64 5
			struct mdoc_node *, struct mdoc_argv *);
static	void	 check_args(struct mdoc *, struct mdoc_node *);
static	int	 child_an(const struct mdoc_node *);
static	enum mdoc_sec	a2sec(const char *);
static	size_t		macro2len(enum mdoct);
d249 1
a249 1
static	const enum mdoct rsord[RSORD_MAX] = {
d294 1
a294 1
mdoc_valid_pre(struct mdoc *mdoc, struct mdoc_node *n)
d322 1
a322 1
	struct mdoc_node *n;
d363 1
a363 1
check_args(struct mdoc *mdoc, struct mdoc_node *n)
d376 1
a376 1
check_argv(struct mdoc *mdoc, struct mdoc_node *n, struct mdoc_argv *v)
d400 1
a400 1
	struct mdoc_node *node;
d770 1
a770 1
	struct mdoc_node *np, *nch;
d832 1
a832 1
	struct mdoc_node	*n;
d845 1
a845 1
	const struct mdoc_node *n;
d858 1
a858 1
	const struct mdoc_node	*n;
d881 1
a881 1
	const struct mdoc_node	*n;
d907 1
a907 1
	const struct mdoc_node *n;
d928 1
a928 1
	const struct mdoc_node *n;
d950 1
a950 1
	struct mdoc_node	*n;
d972 1
a972 1
	struct mdoc_node	*n;
d989 1
a989 1
	struct mdoc_node	*n;
d1006 1
a1006 1
	struct mdoc_node	*n;
d1028 1
a1028 1
	struct mdoc_node *nn;
d1062 1
a1062 1
	struct mdoc_node	*n;
d1096 1
a1096 1
	struct mdoc_node *np, *nch;
d1127 1
a1129 1
	struct mdoc_node *nbl, *nit, *nch;
d1195 1
a1195 1
	struct mdoc_node *n, *ni, *nc;
d1256 1
a1256 1
	enum mdoct	  tok;
d1274 1
a1274 1
	struct mdoc_node *n, *nn;
d1339 1
a1339 1
	struct mdoc_node *nbl, *nh, *nch, *nnext;
d1401 3
a1403 3
	struct mdoc_node	*nparent, *nprev; /* of the Bl block */
	struct mdoc_node	*nblock, *nbody;  /* of the Bl */
	struct mdoc_node	*nchild, *nnext;  /* of the Bl body */
d1484 1
a1484 1
	struct mdoc_node	*n;
d1498 1
a1498 1
	struct mdoc_node	*nch;
d1528 1
a1528 1
	struct mdoc_node *n;
d1568 1
a1568 1
	struct mdoc_node	 *n, *nch;
d1589 1
a1589 1
	struct mdoc_node *np, *nch, *next, *prev;
d1683 1
a1683 1
	struct mdoc_node	*nch;
d1742 1
a1742 1
	struct mdoc_node *n;
d1780 1
a1780 1
	const struct mdoc_node	*n;
d1840 1
a1840 1
child_an(const struct mdoc_node *n)
d1861 1
a1861 1
	struct mdoc_node *n;
d1864 1
a1864 1
	enum mdoc_sec	 sec;
d1981 1
a1981 1
	struct mdoc_node *np;
d2047 1
a2047 1
	struct mdoc_node *np;
d2110 1
a2110 1
	struct mdoc_node *n;
d2139 1
a2139 1
	struct mdoc_node *nn, *n;
d2224 1
a2224 1
	struct mdoc_node	*n;
d2244 1
a2244 1
	struct mdoc_node *n;
d2294 1
a2294 1
	struct mdoc_node *n;
d2312 1
a2312 1
static enum mdoc_sec
d2319 1
a2319 1
			return((enum mdoc_sec)i);
d2325 1
a2325 1
macro2len(enum mdoct macro)
@


1.199
log
@oops, in NAME, don't nag about the comma after .Nm
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.198 2015/02/23 13:30:02 schwarze Exp $ */
d11 1
a11 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d13 1
a13 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d32 3
d36 1
a36 2
#include "mandoc.h"
#include "mandoc_aux.h"
a37 1
#include "libmandoc.h"
d299 1
a299 1
	case MDOC_TEXT:
d303 1
a303 1
	case MDOC_TBL:
d305 1
a305 1
	case MDOC_EQN:
d307 1
a307 1
	case MDOC_ROOT:
d331 1
a331 1
	case MDOC_TEXT:
d333 1
a333 1
	case MDOC_EQN:
d335 1
a335 1
	case MDOC_TBL:
d337 1
a337 1
	case MDOC_ROOT:
d402 1
a402 1
	if (MDOC_BLOCK != n->type)
d406 1
a406 1
		if (MDOC_BLOCK == node->type)
d424 1
a424 1
	if (n->type != MDOC_BLOCK)
d607 1
a607 1
	if (n->type != MDOC_BLOCK)
d720 1
a720 1
	if (MDOC_ELEM == n->type || MDOC_BLOCK == n->type)
d779 1
a779 1
	if (MDOC_HEAD != np->type)
d782 1
a782 1
	assert(MDOC_BLOCK == np->parent->type);
d836 1
a836 1
	assert(MDOC_TEXT == n->type);
d885 1
a885 1
	if (n->type != MDOC_HEAD)
d938 1
a938 1
	if (MDOC_BODY != mdoc->last->type)
d942 1
a942 1
		if (MDOC_TEXT != n->type)
d976 1
a976 1
	if (n->type != MDOC_BODY)
d993 1
a993 1
	if (n->type != MDOC_BODY)
d1010 1
a1010 1
	if (n->type != MDOC_BODY)
d1081 1
a1081 1
	assert(MDOC_TEXT == n->type);
d1113 1
a1113 1
	if (MDOC_BLOCK == mdoc->last->type)
d1132 1
a1132 1
	if (nit->type != MDOC_BLOCK)
d1179 1
a1179 1
			if (nch->type == MDOC_BODY)
d1293 1
a1293 1
		assert(MDOC_BLOCK == nn->type);
d1299 1
a1299 1
		if (MDOC_TEXT == nn->type) {
d1407 1
a1407 1
	case MDOC_BLOCK:
d1410 1
a1410 1
	case MDOC_HEAD:
d1413 1
a1413 1
	case MDOC_BODY:
d1488 1
a1488 1
	if (n->type == MDOC_BLOCK && n->body->child == NULL) {
d1507 1
a1507 1
	assert(nch->type == MDOC_TEXT);
d1574 1
a1574 1
	assert(MDOC_TEXT == nch->type);
d1594 1
a1594 1
	if (np->type != MDOC_BODY)
d1687 1
a1687 1
		if (nch->type != MDOC_TEXT)
d1716 1
a1716 1
	case MDOC_HEAD:
d1719 1
a1719 1
	case MDOC_BODY:
d1825 1
a1825 1
		if (n->type != MDOC_TEXT)
d1984 1
a1984 1
	case MDOC_HEAD:
d1987 1
a1987 1
	case MDOC_BODY:
d2018 1
a2018 1
	if (MDOC_ELEM != n->type && MDOC_BLOCK != n->type)
d2083 1
a2083 1
	if (MDOC_BODY != n->type)
@


1.198
log
@improve NAME section diagnostics;
confusing messages reported by Jan Stary <hans at stare dot cz>
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.197 2015/02/17 20:33:44 schwarze Exp $ */
d1757 4
@


1.197
log
@Render \(lq and \(rq as '"' in -Tascii mode but leave the rendering
of .Do/.Dc, .Dq, .Lb, and .St untouched.
Reduces groff-mandoc differences in base by about 7%.
Reminded of the issue by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.196 2015/02/16 19:02:32 schwarze Exp $ */
d1742 1
d1744 1
a1744 5
	/*
	 * Warn if the NAME section doesn't contain the `Nm' and `Nd'
	 * macros (can have multiple `Nm' and one `Nd').  Note that the
	 * children of the BODY declaration can also be "text".
	 */
d1746 16
a1761 4
	if (NULL == (n = mdoc->last->child)) {
		mandoc_msg(MANDOCERR_NAMESEC_BAD, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, "empty");
		return;
d1764 6
a1769 15
	for ( ; n && n->next; n = n->next) {
		if (MDOC_ELEM == n->type && MDOC_Nm == n->tok)
			continue;
		if (MDOC_TEXT == n->type)
			continue;
		mandoc_msg(MANDOCERR_NAMESEC_BAD, mdoc->parse,
		    n->line, n->pos, mdoc_macronames[n->tok]);
	}

	assert(n);
	if (MDOC_BLOCK == n->type && MDOC_Nd == n->tok)
		return;

	mandoc_msg(MANDOCERR_NAMESEC_BAD, mdoc->parse,
	    n->line, n->pos, mdoc_macronames[n->tok]);
@


1.196
log
@clean up post_dt() validation function;
improved diagnostics, minus six lines of code
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.195 2015/02/14 13:22:12 schwarze Exp $ */
d836 1
a836 1
	mandoc_asprintf(&libname, "library \\(lq%s\\(rq", n->string);
@


1.195
log
@shut up about tabs in SYNOPSIS .Fd lines, there is no good way to avoid them
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.194 2015/02/12 12:20:47 schwarze Exp $ */
d2150 1
a2150 1
	/* First check that all characters are uppercase. */
d2152 2
a2153 14
	if (NULL != (nn = n->child))
		for (p = nn->string; *p; p++) {
			if (toupper((unsigned char)*p) == *p)
				continue;
			mandoc_vmsg(MANDOCERR_TITLE_CASE,
			    mdoc->parse, nn->line,
			    nn->pos + (p - nn->string),
			    "Dt %s", nn->string);
			break;
		}

	/* No argument: msec and arch remain NULL. */

	if (NULL == (nn = n->child)) {
d2157 13
a2169 2
		mdoc->meta.vol = mandoc_strdup("LOCAL");
		goto out;
d2172 1
a2172 1
	/* One argument: msec and arch remain NULL. */
d2174 2
a2175 2
	mdoc->meta.title = mandoc_strdup(
	    '\0' == nn->string[0] ? "UNTITLED" : nn->string);
d2177 1
a2177 1
	if (NULL == (nn = nn->next)) {
d2182 1
a2182 1
		goto out;
d2185 3
a2187 6
	/* Handles: `.Dt TITLE SEC'
	 * title = TITLE,
	 * volume = SEC is msec ? format(msec) : SEC,
	 * msec = SEC is msec ? atoi(msec) : 0,
	 * arch = NULL
	 */
d2190 1
a2190 4
	if (cp) {
		mdoc->meta.vol = mandoc_strdup(cp);
		mdoc->meta.msec = mandoc_strdup(nn->string);
	} else {
d2194 11
a2204 2
		mdoc->meta.msec = mandoc_strdup(nn->string);
	}
d2206 1
a2206 1
	/* Handle an optional architecture */
d2208 3
a2210 5
	if ((nn = nn->next) != NULL) {
		for (p = nn->string; *p; p++)
			*p = tolower((unsigned char)*p);
		mdoc->meta.arch = mandoc_strdup(nn->string);
	}
a2211 2
	/* Ignore any subsequent parameters... */
	/* FIXME: warn about subsequent parameters. */
@


1.194
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.193 2015/02/10 08:05:07 schwarze Exp $ */
d299 2
a300 1
		check_text(mdoc, n->line, n->pos, n->string);
@


1.193
log
@trim trailing white space, no code change;
from Svyatoslav Mishyn <juef at openmailboxd dot org>, Crux Linux
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.192 2015/02/06 16:05:51 schwarze Exp $ */
d326 1
a326 1
	n->flags |= MDOC_VALID;
a416 1
	struct mdoc_node *np;
d422 1
a422 10
	if (MDOC_BLOCK != n->type) {
		if (ENDBODY_NOT != n->end) {
			assert(n->pending);
			np = n->pending->parent;
		} else
			np = n->parent;

		assert(np);
		assert(MDOC_BLOCK == np->type);
		assert(MDOC_Bl == np->tok);
a423 1
	}
a598 1
	struct mdoc_node *np;
d605 1
a605 10
	if (MDOC_BLOCK != n->type) {
		if (ENDBODY_NOT != n->end) {
			assert(n->pending);
			np = n->pending->parent;
		} else
			np = n->parent;

		assert(np);
		assert(MDOC_BLOCK == np->type);
		assert(MDOC_Bd == np->tok);
a606 1
	}
d776 2
a777 12
	if (MDOC_HEAD != mdoc->last->type) {
		if (ENDBODY_NOT != mdoc->last->end) {
			assert(mdoc->last->pending);
			np = mdoc->last->pending->parent->head;
		} else if (MDOC_BLOCK != mdoc->last->type) {
			np = mdoc->last->parent->head;
		} else
			np = mdoc->last->head;

		assert(np);
		assert(MDOC_HEAD == np->type);
		assert(MDOC_Bf == np->tok);
a778 1
	}
a779 1
	np = mdoc->last;
@


1.192
log
@replace the last legacy generic message type, "argument count wrong",
by more specific messages, improving diagnostics for .cc .tr .Bl -column
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.191 2015/02/06 07:12:34 schwarze Exp $ */
d1809 1
a1809 1
	const char 		*name, *sec;
@


1.191
log
@Delete the legacy generic warning type MANDOCERR_ARGCWARN,
replacing the last instances by more specific warnings.
Improved functionality, minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.190 2015/02/06 03:31:11 schwarze Exp $ */
d1215 1
a1215 1
			mandoc_vmsg(MANDOCERR_ARGCOUNT,
d1217 1
a1217 1
			    "columns == %d (have %d)", cols, i);
@


1.190
log
@better handle .Fo and .Fd without argument
better handle .Fo with more than one argument
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.189 2015/02/06 02:04:35 schwarze Exp $ */
a56 2
static	void	 check_count(struct mdoc *, enum mdoc_type,
			enum check_ineq, int);
a65 3
static	void	 ewarn_eq1(POST_ARGS);
static	void	 ewarn_ge1(POST_ARGS);

a87 1
static	void	 post_hyphtext(POST_ARGS);
d162 11
a172 11
	{ NULL, ewarn_ge1 },			/* %A */
	{ NULL, post_hyphtext },		/* %B */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, ewarn_ge1 },			/* %D */
	{ NULL, ewarn_ge1 },			/* %I */
	{ NULL, ewarn_ge1 },			/* %J */
	{ NULL, post_hyphtext },		/* %N */
	{ NULL, post_hyphtext },		/* %O */
	{ NULL, ewarn_ge1 },			/* %P */
	{ NULL, post_hyphtext },		/* %R */
	{ NULL, post_hyphtext },		/* %T */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, ewarn_ge1 },			/* %V */
d234 1
a234 1
	{ NULL, ewarn_ge1 },			/* %C */
d238 1
a238 1
	{ NULL, ewarn_ge1 },			/* %Q */
d241 1
a241 1
	{ NULL, ewarn_eq1 },			/* %U */
a360 47
check_count(struct mdoc *mdoc, enum mdoc_type type,
	enum check_ineq ineq, int val)
{
	const char	*p;

	if (mdoc->last->type != type)
		return;

	switch (ineq) {
	case CHECK_LT:
		p = "less than ";
		if (mdoc->last->nchild < val)
			return;
		break;
	case CHECK_GT:
		p = "more than ";
		if (mdoc->last->nchild > val)
			return;
		break;
	case CHECK_EQ:
		p = "";
		if (val == mdoc->last->nchild)
			return;
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	mandoc_vmsg(MANDOCERR_ARGCWARN, mdoc->parse, mdoc->last->line,
	    mdoc->last->pos, "want %s%d children (have %d)",
	    p, val, mdoc->last->nchild);
}

static void
ewarn_eq1(POST_ARGS)
{
	check_count(mdoc, MDOC_ELEM, CHECK_EQ, 1);
}

static void
ewarn_ge1(POST_ARGS)
{
	check_count(mdoc, MDOC_ELEM, CHECK_GT, 0);
}

static void
a866 1
	check_count(mdoc, MDOC_ELEM, CHECK_EQ, 1);
d1029 1
a1029 1
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
d1046 1
a1046 1
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
d1453 1
a1453 1
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
d1521 1
a1521 1
		mandoc_msg(MANDOCERR_MACRO_EMPTY,
a1729 8
}

static void
post_hyphtext(POST_ARGS)
{

	ewarn_ge1(mdoc);
	post_hyph(mdoc);
@


1.189
log
@better handle empty .Bd .Bl .D1 .Dl blocks
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.188 2015/02/06 01:07:07 schwarze Exp $ */
a67 1
static	void	 bwarn_ge1(POST_ARGS);
d151 1
a151 1
	{ NULL, ewarn_ge1 },			/* Fd */
a401 6
bwarn_ge1(POST_ARGS)
{
	check_count(mdoc, MDOC_BODY, CHECK_GT, 0);
}

static void
d967 3
d971 17
a987 4
	check_count(mdoc, MDOC_HEAD, CHECK_EQ, 1);
	bwarn_ge1(mdoc);
	if (mdoc->last->type == MDOC_HEAD && mdoc->last->nchild)
		post_fname(mdoc);
@


1.188
log
@better handle .In .Sh .Ss .St .Xr without arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.187 2015/02/05 01:46:38 schwarze Exp $ */
d1066 10
a1076 1
	bwarn_ge1(mdoc);
d1083 1
d1085 8
a1092 1
	bwarn_ge1(mdoc);
d1094 4
a1097 6
	/*
	 * The `Dl' (note "el" not "one") and `Bd' macros unset the
	 * MDOC_LITERAL flag as they leave.  Note that `Bd' only sets
	 * this in literal mode, but it doesn't hurt to just switch it
	 * off in general since displays can't be nested.
	 */
d1099 1
a1099 2
	if (MDOC_BODY == mdoc->last->type)
		mdoc->flags &= ~MDOC_LITERAL;
a1495 2
	bwarn_ge1(mdoc);

d1497 6
a1502 1
	while (NULL != nchild) {
d1760 1
a1760 1
	struct mdoc_node	*n, *nch;
d1763 2
a1764 18
	n = mdoc->last;
	switch (n->type) {
	case MDOC_HEAD:
		if (MDOC_Sh == n->tok || MDOC_Ss == n->tok)
			break;
		return;
	case MDOC_BODY:
		if (MDOC_D1 == n->tok || MDOC_Nd == n->tok)
			break;
		return;
	case MDOC_ELEM:
		break;
	default:
		return;
	}

	for (nch = n->child; nch; nch = nch->next) {
		if (MDOC_TEXT != nch->type)
d1767 1
a1767 1
		if ('\0' == *cp)
d1769 2
a1770 2
		while ('\0' != *(++cp))
			if ('-' == *cp &&
d2064 7
a2070 3
	post_hyph(mdoc);

	if (MDOC_BODY != mdoc->last->type)
d2072 1
@


1.187
log
@fix handling of empty .An macros
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.186 2015/02/04 22:29:28 schwarze Exp $ */
d157 1
a157 1
	{ NULL, ewarn_eq1 },			/* In */
d168 1
a168 1
	{ NULL, ewarn_ge1 },			/* Xr */
a1633 7
	if (NULL == nch) {
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
		    n->line, n->pos, mdoc_macronames[n->tok]);
		mdoc_node_delete(mdoc, n);
		return;
	}

a2062 1
	check_count(mdoc, MDOC_HEAD, CHECK_GT, 0);
@


1.186
log
@Discard excess head arguments for .Bd .Bl .Bk and delete hwarn_eq0().
Discard empty .Bk blocks.
Improve related diagnostics.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.185 2015/02/04 19:11:17 schwarze Exp $ */
d1162 6
a1167 4
	if (AUTH__NONE == np->norm->An.auth) {
		if (0 == np->child)
			check_count(mdoc, MDOC_ELEM, CHECK_GT, 0);
	} else if ((nch = np->child) != NULL)
@


1.185
log
@improve diagnostics regarding arguments of .An .Pp .Lp .br .sp
in particular, get rid of check_count(..., CHECK_EQ, 0)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.184 2015/02/04 18:03:28 schwarze Exp $ */
a70 1
static	void	 hwarn_eq0(POST_ARGS);
a420 6
hwarn_eq0(POST_ARGS)
{
	check_count(mdoc, MDOC_HEAD, CHECK_EQ, 0);
}

static void
a1074 2
	if (mdoc->last->tok == MDOC_Bd)
		hwarn_eq0(mdoc);
d1400 1
a1400 1
	struct mdoc_node *np, *nn, *nnp;
d1404 11
a1414 3
	if (LIST_column != mdoc->last->norm->Bl.type) {
		/* FIXME: this should be ERROR class... */
		hwarn_eq0(mdoc);
d1424 1
a1424 1
	if (mdoc->last->child == NULL)
d1427 3
a1429 5
	np = mdoc->last->parent;
	assert(np->args);

	for (j = 0; j < (int)np->args->argc; j++)
		if (MDOC_Column == np->args->argv[j].arg)
d1432 1
a1432 1
	assert(j < (int)np->args->argc);
d1440 1
a1440 1
	argv = np->args->argv + j;
d1442 1
a1442 1
	argv->sz += mdoc->last->nchild;
d1446 2
a1447 2
	mdoc->last->norm->Bl.ncols = argv->sz;
	mdoc->last->norm->Bl.cols = (void *)argv->value;
d1449 5
a1453 6
	for (nn = mdoc->last->child; nn; i++) {
		argv->value[i] = nn->string;
		nn->string = NULL;
		nnp = nn;
		nn = nn->next;
		mdoc_node_delete(NULL, nnp);
d1455 2
a1456 3

	mdoc->last->nchild = 0;
	mdoc->last->child = NULL;
d1542 1
d1544 7
a1550 2
	hwarn_eq0(mdoc);
	bwarn_ge1(mdoc);
@


1.184
log
@discard .Rs head arguments and improve .Rs diagnostics
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.183 2015/02/04 16:38:31 schwarze Exp $ */
d1168 1
a1168 1
	struct mdoc_node *np;
d1174 3
a1176 2
	} else if (np->child)
		check_count(mdoc, MDOC_ELEM, CHECK_EQ, 0);
d2129 1
a2129 4
	if (mdoc->last->tok == MDOC_sp)
		check_count(mdoc, MDOC_ELEM, CHECK_LT, 2);
	else
		check_count(mdoc, MDOC_ELEM, CHECK_EQ, 0);
d2131 9
a2139 3
	if (MDOC_ELEM != mdoc->last->type &&
	    MDOC_BLOCK != mdoc->last->type)
		return;
@


1.183
log
@more specific .Nd diagnostics, allowing to get rid of enum check_lvl
and the respective argument of check_count()
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.182 2015/02/03 00:48:27 schwarze Exp $ */
d1652 1
a1652 1
	struct mdoc_node *nn, *next, *prev;
d1655 3
a1657 3
	switch (mdoc->last->type) {
	case MDOC_HEAD:
		check_count(mdoc, MDOC_HEAD, CHECK_EQ, 0);
d1659 4
a1662 6
	case MDOC_BODY:
		if (mdoc->last->child)
			break;
		check_count(mdoc, MDOC_BODY, CHECK_GT, 0);
		return;
	default:
d1673 2
a1674 2
	for (nn = mdoc->last->child->next; nn; nn = next) {
		/* Determine order of `nn'. */
d1676 1
a1676 1
			if (rsord[i] == nn->tok)
d1681 2
a1682 2
			    mdoc->parse, nn->line, nn->pos,
			    mdoc_macronames[nn->tok]);
d1684 2
a1685 2
		} else if (MDOC__J == nn->tok || MDOC__B == nn->tok)
			mdoc->last->norm->Rs.quote_T++;
d1688 1
a1688 1
		 * Remove `nn' from the chain.  This somewhat
d1694 2
a1695 2
		if (NULL != (next = nn->next))
			next->prev = nn->prev;
d1697 2
a1698 2
		if (NULL != (prev = nn->prev))
			prev->next = nn->next;
d1700 1
a1700 1
		nn->prev = nn->next = NULL;
d1704 1
a1704 1
		 * ordered before `nn'.
d1720 2
a1721 2
		 * Set `nn' back into its correct place in front
		 * of the `prev' node.
d1724 1
a1724 1
		nn->prev = prev;
d1726 5
a1730 1
		if (prev) {
d1732 3
a1734 7
				prev->next->prev = nn;
			nn->next = prev->next;
			prev->next = nn;
		} else {
			mdoc->last->child->prev = nn;
			nn->next = mdoc->last->child;
			mdoc->last->child = nn;
@


1.182
log
@Bring .Pp/.Lp handling inside .Nm blocks closer to groff;
as a bonus, get rid of another call to rew_sub().
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.181 2014/12/18 20:15:31 schwarze Exp $ */
a48 5
enum	check_lvl {
	CHECK_WARN,
	CHECK_ERROR,
};

d58 1
a58 1
			enum check_lvl, enum check_ineq, int);
d370 1
a370 1
		enum check_lvl lvl, enum check_ineq ineq, int val)
a372 1
	enum mandocerr	 t;
d398 1
a398 2
	t = lvl == CHECK_WARN ? MANDOCERR_ARGCWARN : MANDOCERR_ARGCOUNT;
	mandoc_vmsg(t, mdoc->parse, mdoc->last->line,
d406 1
a406 1
	check_count(mdoc, MDOC_BODY, CHECK_WARN, CHECK_GT, 0);
d412 1
a412 1
	check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 1);
d418 1
a418 1
	check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_GT, 0);
d424 1
a424 1
	check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 0);
d934 1
a934 1
	check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 1);
d982 1
a982 1
	check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 1);
d1056 10
a1066 1
	check_count(mdoc, MDOC_BODY, CHECK_ERROR, CHECK_GT, 0);
d1173 1
a1173 1
			check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_GT, 0);
d1175 1
a1175 1
		check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 0);
d1657 1
a1657 1
		check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 0);
d1662 1
a1662 1
		check_count(mdoc, MDOC_BODY, CHECK_WARN, CHECK_GT, 0);
d2068 1
a2068 1
	check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_GT, 0);
d2131 1
a2131 1
		check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_LT, 2);
d2133 1
a2133 1
		check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 0);
@


1.181
log
@Only keep leading .Sm inside a list when it immediately precedes
the first .It.  Otherwise, move it out together with whatever
follows.  Fixing an assertion failure found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.180 2014/12/18 19:22:47 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2014 Ingo Schwarze <schwarze@@openbsd.org>
d1041 8
d1053 1
a1053 1
	mdoc_deroff(&mdoc->meta.name, mdoc->last);
d1057 1
a1057 1
		    mdoc->last->line, mdoc->last->pos, "Nm");
@


1.180
log
@When the head of a list item is extended with a partial explicit
macro (for example .Xo) and never closed again, the item ends up
without a body block.  This can even happen for list types that
usually don't have heads in the first place.  So even in this
case, check for the existence of the body before accessing it.
NULL pointer access found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.179 2014/11/30 05:28:00 schwarze Exp $ */
d1478 4
a1481 1
		if (MDOC_It == nchild->tok || MDOC_Sm == nchild->tok) {
@


1.179
log
@Multiple fixes with respect to .Pf:
* The first argument of .Pf is not parsed.
* Normal delimiter handling does not apply to the first argument of .Pf.
* Warn if nothing follows a prefix (inspired by groff_mdoc(7)).
* In that case, do not suppress spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.178 2014/11/28 18:35:37 schwarze Exp $ */
d1191 1
a1191 1
	if (MDOC_BLOCK != nit->type)
d1207 1
a1207 1
		if (NULL == nit->head->child)
d1220 1
a1220 1
		if (NULL == nit->body->child)
d1227 1
a1227 1
		if (NULL != nit->head->child)
d1235 1
a1235 1
		assert(NULL == nit->head->child);
d1238 1
a1238 1
			if (MDOC_BODY == nch->type)
@


1.178
log
@Retire support for CSRG supplementary document titles.  These are
long obsolete and were never written in mdoc(7) in the first place.
Removes 100 lines from source files.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.177 2014/11/28 18:07:38 schwarze Exp $ */
d211 1
a211 1
	{ NULL, ewarn_eq1 },			/* Pf */
@


1.177
log
@Drop useless architecture table.  Validating architecture names
is a job for makewhatis(8)/mandoc.db(5), not for the parser.
Removes 150 lines from source files and 4k (1%) from the binary.
Bloat found by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.176 2014/11/28 17:23:34 schwarze Exp $ */
d2274 1
a2274 7
	if (NULL == (nn = nn->next))
		goto out;

	/*
	 * If the third argument is a volume name, format is,
	 * otherwise assume it's an architecture.
	 */
d2276 1
a2276 5
	cp = mdoc_a2vol(nn->string);
	if (cp) {
		free(mdoc->meta.vol);
		mdoc->meta.vol = mandoc_strdup(cp);
	} else {
@


1.176
log
@Remove bulky, irrelevant library description string tables
not used by a single manual in OpenBSD and just print library names;
will remain in the portable version for use by FreeBSD and NetBSD.
Removes 150 lines from source tree and 16 Kilobytes (4%) from binary.
Bloat found by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.175 2014/11/28 01:05:40 schwarze Exp $ */
d2277 3
a2279 5
	/* Handles: `.Dt TITLE SEC VOL'
	 * title = TITLE,
	 * volume = VOL is vol ? format(VOL) :
	 *	    VOL is arch ? format(arch) :
	 *	    VOL
d2287 3
a2289 8
		cp = mdoc_a2arch(nn->string);
		if (NULL == cp) {
			mandoc_vmsg(MANDOCERR_ARCH_BAD, mdoc->parse,
			    nn->line, nn->pos, "Dt ... %s", nn->string);
			free(mdoc->meta.vol);
			mdoc->meta.vol = mandoc_strdup(nn->string);
		} else
			mdoc->meta.arch = mandoc_strdup(cp);
@


1.175
log
@Simplify code by making mdoc validation handlers void.
No functional change, minus 90 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.174 2014/11/27 23:35:03 schwarze Exp $ */
a938 1
	const char		*stdlibname;
a941 1

a942 2

	assert(n);
d944 1
a944 7

	if (NULL == (stdlibname = mdoc_a2lib(n->string)))
		mandoc_asprintf(&libname,
		    "library \\(lq%s\\(rq", n->string);
	else
		libname = mandoc_strdup(stdlibname);

@


1.174
log
@Downgrade .Bd -file from FATAL to ERROR.
Since this was the last remaining FATAL error in this area,
this change will allow major simplifications in the mdoc(7) parser.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.173 2014/11/27 16:20:27 schwarze Exp $ */
d54 2
a55 2
typedef	int	(*v_pre)(PRE_ARGS);
typedef	int	(*v_post)(POST_ARGS);
d62 1
a62 1
static	int	 check_count(struct mdoc *, enum mdoc_type,
d73 59
a131 63
static	int	 berr_ge1(POST_ARGS);
static	int	 bwarn_ge1(POST_ARGS);
static	int	 ewarn_eq0(POST_ARGS);
static	int	 ewarn_eq1(POST_ARGS);
static	int	 ewarn_ge1(POST_ARGS);
static	int	 ewarn_le1(POST_ARGS);
static	int	 hwarn_eq0(POST_ARGS);
static	int	 hwarn_eq1(POST_ARGS);
static	int	 hwarn_ge1(POST_ARGS);

static	int	 post_an(POST_ARGS);
static	int	 post_at(POST_ARGS);
static	int	 post_bf(POST_ARGS);
static	int	 post_bk(POST_ARGS);
static	int	 post_bl(POST_ARGS);
static	int	 post_bl_block(POST_ARGS);
static	int	 post_bl_block_tag(POST_ARGS);
static	int	 post_bl_head(POST_ARGS);
static	int	 post_bx(POST_ARGS);
static	int	 post_d1(POST_ARGS);
static	int	 post_defaults(POST_ARGS);
static	int	 post_dd(POST_ARGS);
static	int	 post_dt(POST_ARGS);
static	int	 post_en(POST_ARGS);
static	int	 post_es(POST_ARGS);
static	int	 post_eoln(POST_ARGS);
static	int	 post_ex(POST_ARGS);
static	int	 post_fa(POST_ARGS);
static	int	 post_fn(POST_ARGS);
static	int	 post_fname(POST_ARGS);
static	int	 post_fo(POST_ARGS);
static	int	 post_hyph(POST_ARGS);
static	int	 post_hyphtext(POST_ARGS);
static	int	 post_ignpar(POST_ARGS);
static	int	 post_it(POST_ARGS);
static	int	 post_lb(POST_ARGS);
static	int	 post_literal(POST_ARGS);
static	int	 post_nd(POST_ARGS);
static	int	 post_nm(POST_ARGS);
static	int	 post_ns(POST_ARGS);
static	int	 post_os(POST_ARGS);
static	int	 post_par(POST_ARGS);
static	int	 post_root(POST_ARGS);
static	int	 post_rs(POST_ARGS);
static	int	 post_sh(POST_ARGS);
static	int	 post_sh_head(POST_ARGS);
static	int	 post_sh_name(POST_ARGS);
static	int	 post_sh_see_also(POST_ARGS);
static	int	 post_sh_authors(POST_ARGS);
static	int	 post_sm(POST_ARGS);
static	int	 post_st(POST_ARGS);
static	int	 post_vt(POST_ARGS);
static	int	 pre_an(PRE_ARGS);
static	int	 pre_bd(PRE_ARGS);
static	int	 pre_bl(PRE_ARGS);
static	int	 pre_dd(PRE_ARGS);
static	int	 pre_display(PRE_ARGS);
static	int	 pre_dt(PRE_ARGS);
static	int	 pre_literal(PRE_ARGS);
static	int	 pre_obsolete(PRE_ARGS);
static	int	 pre_os(PRE_ARGS);
static	int	 pre_par(PRE_ARGS);
static	int	 pre_std(PRE_ARGS);
d305 1
a305 1
int
d319 1
a319 1
		return(1);
d326 2
a327 1
	return(*p ? (*p)(mdoc, n) : 1);
d330 1
a330 1
int
d338 1
a338 1
		return(1);
d347 1
a347 1
		return(1);
d349 2
a350 1
		return(post_root(mdoc));
d367 3
a369 1
		return(*p ? (*p)(mdoc) : 1);
d373 1
a373 1
static int
d381 1
a381 1
		return(1);
d387 1
a387 1
			return(1);
d392 1
a392 1
			return(1);
d397 1
a397 1
			return(1);
a407 1
	return(1);
d410 1
a410 8
static int
berr_ge1(POST_ARGS)
{

	return(check_count(mdoc, MDOC_BODY, CHECK_ERROR, CHECK_GT, 0));
}

static int
d413 1
a413 1
	return(check_count(mdoc, MDOC_BODY, CHECK_WARN, CHECK_GT, 0));
d416 1
a416 7
static int
ewarn_eq0(POST_ARGS)
{
	return(check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 0));
}

static int
d419 1
a419 1
	return(check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 1));
d422 1
a422 1
static int
d425 1
a425 1
	return(check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_GT, 0));
d428 1
a428 7
static int
ewarn_le1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_LT, 2));
}

static int
d431 1
a431 13
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 0));
}

static int
hwarn_eq1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 1));
}

static int
hwarn_ge1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_GT, 0));
d469 1
a469 1
static int
d475 1
a475 1
		return(1);
a485 2

	return(1);
d488 1
a488 1
static int
d507 1
a507 1
		return(1);
d678 1
a678 2

	return(pre_par(mdoc, n));
d681 1
a681 1
static int
d701 1
a701 1
		return(1);
d770 1
a770 2

	return(pre_par(mdoc, n));
d773 1
a773 1
static int
d780 1
a780 1
		return(1);
a795 2

	return(1);
d798 1
a798 1
static int
d804 1
a804 1
			return(1);
a807 1
	return(1);
d810 1
a810 1
static int
a816 1
	return(1);
d819 1
a819 1
static int
a828 1
	return(1);
d831 1
a831 1
static int
a840 1
	return(1);
d843 1
a843 1
static int
a858 1
	return(1);
d861 1
a861 1
static int
d884 1
a884 1
		return(1);
d898 1
a898 1
			return(1);
d918 1
a918 1
		return(1);
a932 2

	return(1);
d935 1
a935 1
static int
a956 1
	return(1);
d959 1
a959 1
static int
a969 1
	return(1);
d972 1
a972 1
static int
a984 1
	return(1);
d987 1
a987 1
static int
a992 1
	return(1);
d995 1
a995 1
static int
d999 1
a999 1
	hwarn_eq1(mdoc);
a1002 1
	return(1);
d1005 1
a1005 1
static int
a1023 1
	return(1);
d1026 1
a1026 1
static int
d1040 1
a1040 1
		return(1);
a1045 2

	return(1);
d1048 1
a1048 1
static int
d1053 1
a1053 1
		return(1);
a1059 1
	return(1);
d1062 1
a1062 1
static int
d1066 2
a1067 2
	berr_ge1(mdoc);
	return(post_hyph(mdoc));
d1070 1
a1070 1
static int
d1075 1
a1075 1
	return(post_hyph(mdoc));
d1078 1
a1078 1
static int
a1094 2

	return(1);
d1097 1
a1097 1
static int
d1109 1
a1109 1
		return(1);
d1116 2
a1117 4
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, "file"))
			return(0);
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, "..."))
			return(0);
d1122 1
a1122 2
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, "~"))
			return(0);
a1127 1

a1128 1
	return(1);
d1131 1
a1131 1
static int
d1141 1
a1141 2
		if ( ! mdoc_word_alloc(mdoc, n->line, n->pos, "AT&T UNIX"))
			return(0);
d1143 1
a1143 1
		return(1);
a1162 1
	return(1);
d1165 1
a1165 1
static int
a1175 2

	return(1);
d1178 1
a1178 1
static int
a1183 1
	return(1);
d1186 1
a1186 1
static int
a1190 1
	return(1);
d1193 1
a1193 1
static int
d1202 1
a1202 1
		return(1);
a1258 2

	return(1);
d1261 1
a1261 1
static int
d1278 1
a1278 2
		if ( ! post_bl_block_tag(mdoc))
			return(0);
d1302 1
a1302 2
				if ( ! mdoc_node_relink(mdoc, nc))
					return(0);
a1314 1
	return(1);
d1340 1
a1340 1
static int
a1402 1
	return(1);
d1405 1
a1405 1
static int
d1412 1
a1412 1
	if (LIST_column != mdoc->last->norm->Bl.type)
d1414 3
a1416 1
		return(hwarn_eq0(mdoc));
d1425 1
a1425 1
		return(1);
a1460 2

	return(1);
d1463 1
a1463 1
static int
d1473 2
a1474 1
		return(post_bl_block(mdoc));
d1476 2
a1477 1
		return(post_bl_head(mdoc));
d1481 1
a1481 1
		return(1);
a1537 2

	return(1);
d1540 1
a1540 1
static int
a1545 1
	return(1);
d1548 1
a1548 1
static int
d1557 1
a1557 1
		return(1);
d1564 1
a1564 1
		return(1);
d1568 1
a1568 1
		return(1);
d1574 2
a1575 1
	return(mdoc_node_relink(mdoc, nch));
d1578 1
a1578 1
static int
a1615 2

	return(1);
d1618 1
a1618 1
static int
d1631 1
a1631 1
		return(1);
a1643 2

	return(1);
d1646 1
a1646 1
static int
d1655 1
a1655 1
		return(1);
d1660 1
a1660 1
		return(1);
d1662 1
a1662 1
		return(1);
a1735 2

	return(1);
d1742 1
a1742 1
static int
d1753 1
a1753 1
		return(1);
d1757 1
a1757 1
		return(1);
d1761 1
a1761 1
		return(1);
a1775 1
	return(1);
d1778 1
a1778 1
static int
d1783 1
a1783 1
	return(post_hyph(mdoc));
d1786 1
a1786 1
static int
a1792 1
	return(1);
d1795 1
a1795 1
static int
d1803 2
a1804 1
		return(post_sh_head(mdoc));
d1808 2
a1809 1
			return(post_sh_name(mdoc));
d1811 2
a1812 1
			return(post_sh_see_also(mdoc));
d1814 2
a1815 1
			return(post_sh_authors(mdoc));
a1822 2

	return(1);
d1825 1
a1825 1
static int
d1839 1
a1839 1
		return(1);
d1853 1
a1853 1
		return(1);
a1856 1
	return(1);
d1859 1
a1859 1
static int
d1911 1
a1911 1
				return(1);
a1918 1
	return(1);
d1931 1
a1931 1
static int
a1937 1
	return(1);
d1940 1
a1940 1
static int
d1999 1
a1999 1
		return(1);
d2025 1
a2025 1
		return(1);
a2056 1

a2057 1
	return(1);
d2060 1
a2060 1
static int
d2065 1
a2065 1
	hwarn_ge1(mdoc);
d2069 1
a2069 1
		return(1);
a2087 2

	return(1);
d2090 1
a2090 1
static int
d2095 1
a2095 1
		return(1);
d2097 1
a2097 1
		return(1);
d2107 1
a2107 1
		return(1);
d2109 1
a2109 1
		return(1);
d2111 1
a2111 1
		return(1);
d2113 1
a2113 1
		return(1);
a2119 1
	return(1);
d2122 1
a2122 1
static int
d2128 1
a2128 1
		ewarn_le1(mdoc);
d2130 1
a2130 1
		ewarn_eq0(mdoc);
d2134 1
a2134 1
		return(1);
d2139 5
a2143 7
			return(1);
	} else {
		if (MDOC_Pp != np->tok && MDOC_Lp != np->tok &&
		    (MDOC_br != mdoc->last->tok ||
		     (MDOC_sp != np->tok && MDOC_br != np->tok)))
			return(1);
	}
a2149 1
	return(1);
d2152 1
a2152 1
static int
d2159 1
a2159 1
		return(1);
a2179 2

	return(1);
d2182 1
a2182 1
static int
a2208 1
	return(1);
d2211 1
a2211 1
static int
a2312 1
	return(1);
d2315 1
a2315 1
static int
a2328 2

	return(1);
d2331 1
a2331 1
static int
a2378 1
	return(1);
d2385 1
a2385 1
static int
d2393 1
a2393 1
		return(1);
d2398 1
a2398 1
		return(1);
d2402 1
a2402 4

	if ( ! mdoc_word_alloc(mdoc, n->line, n->pos, mdoc->meta.name))
		return(0);

a2403 1
	return(1);
@


1.173
log
@Fix the obsolete .Db (toggle debug mode) macro to ignore its arguments
and not trigger an assertion when there is more than one argument;
the latter found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.172 2014/11/26 19:23:47 schwarze Exp $ */
d762 1
a762 1
			return(0);
@


1.172
log
@remove an unreachable warning about .Sm arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.171 2014/11/17 06:44:35 schwarze Exp $ */
a18 1

a72 1
static	int	 ebool(POST_ARGS);
d122 1
d200 1
a200 1
	{ NULL, ebool },			/* Db */
d227 1
a227 1
	{ NULL, ebool },			/* Sm */
d1623 1
a1623 1
ebool(struct mdoc *mdoc)
a1625 1
	enum mdoct		 tok;
a1626 1
	tok = mdoc->last->tok;
d1629 2
a1630 3
	if (NULL == nch) {
		if (MDOC_Sm == tok)
			mdoc->flags ^= MDOC_SMOFF;
d1634 1
a1634 1
	assert(MDOC_TEXT == nch->type);
d1636 2
a1637 3
	if (0 == strcmp(nch->string, "on")) {
		if (MDOC_Sm == tok)
			mdoc->flags &= ~MDOC_SMOFF;
d1640 2
a1641 3
	if (0 == strcmp(nch->string, "off")) {
		if (MDOC_Sm == tok)
			mdoc->flags |= MDOC_SMOFF;
d1647 1
a1647 1
	    "%s %s", mdoc_macronames[tok], nch->string);
@


1.171
log
@Multiple fixes with respect to in-line macros:
* .No selects the default font; relevant e.g. in .Bf blocks
* no need to force empty .Li elements
* closing delimiters as leading macro arguments do not suppress space
* opening delimiters at the end of a macro line do not suppress space
* correctly handle delimiter spacing in -Tman
As a side effect, these fixes let mandoc warn about empty .No macros
as requested by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.170 2014/10/30 20:05:33 schwarze Exp $ */
a1636 2

	check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_LT, 2);
@


1.170
log
@Major bugsquashing with respect to -offset and -width:
1. Support specifying the .Bd and .Bl -offset as a macro default width;
while here, simplify the code handling the same for .Bl -width.
2. Correct handling of .Bl -offset arguments:  unlike .Bd -offset, the
arguments "left", "indent", and "indent-two" have no special meaning.
3. Fix the scaling of string length -offset and -width arguments in -Thtml.
Triggered by an incomplete documentation patch from bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.169 2014/10/13 14:01:03 schwarze Exp $ */
d211 1
a211 1
	{ NULL, ewarn_eq0 },			/* No */
d355 14
a1175 4
			return(0);
		break;
	case MDOC_Li:
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, ""))
@


1.169
log
@Do not warn about declarations of functions returning function pointers,
getting rid of a false positive noticed by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.168 2014/10/11 21:33:58 schwarze Exp $ */
d72 1
a90 1
static	int	 post_bl_block_width(POST_ARGS);
d599 1
d614 1
d762 1
a1340 4
	} else if (NULL != n->norm->Bl.width) {
		if ( ! post_bl_block_width(mdoc))
			return(0);
		assert(n->norm->Bl.width);
d1380 6
a1385 2
static int
post_bl_block_width(POST_ARGS)
a1387 1
	int		  i;
a1388 2
	struct mdoc_node *n;
	char		  buf[24];
d1390 3
a1392 12
	n = mdoc->last;

	/*
	 * Calculate the real width of a list from the -width string,
	 * which may contain a macro (with a known default width), a
	 * literal string, or a scaling width.
	 *
	 * If the value to -width is a macro, then we re-write it to be
	 * the macro's width as set in share/tmac/mdoc/doc-common.
	 */

	if (0 == strcmp(n->norm->Bl.width, "Ds"))
d1394 2
a1395 2
	else if (MDOC_MAX == (tok = mdoc_hash_find(n->norm->Bl.width)))
		return(1);
d1399 2
a1400 17
	/* The value already exists: free and reallocate it. */

	assert(n->args);

	for (i = 0; i < (int)n->args->argc; i++)
		if (MDOC_Width == n->args->argv[i].arg)
			break;

	assert(i < (int)n->args->argc);

	(void)snprintf(buf, sizeof(buf), "%un", (unsigned int)width);
	free(n->args->argv[i].value[0]);
	n->args->argv[i].value[0] = mandoc_strdup(buf);

	/* Set our width! */
	n->norm->Bl.width = n->args->argv[i].value[0];
	return(1);
d1415 1
a1415 1
	 * post_bl_block_width() for converting the -width string.
@


1.168
log
@oops, don't crash when .Fo has no argument
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.167 2014/10/11 21:14:11 schwarze Exp $ */
d1006 3
a1008 2
	const struct mdoc_node *n;
	size_t pos;
d1012 2
a1013 1
	if (n->string[pos] != '\0')
@


1.167
log
@warn about parentheses in function names after .Fn and .Fo;
particularly useful when converting from other languages to mdoc(7);
feature suggested by bentley@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.166 2014/09/12 00:53:21 schwarze Exp $ */
d1032 1
a1032 1
	if (mdoc->last->type == MDOC_HEAD)
@


1.166
log
@warn about commas in function arguments; inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.165 2014/09/11 23:52:47 schwarze Exp $ */
d103 2
d165 1
a165 1
	{ NULL, post_fa },			/* Fn */
d1004 23
d1032 2
@


1.165
log
@warn about botched .Xr ordering and punctuation below SEE ALSO;
inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.164 2014/09/07 23:24:33 schwarze Exp $ */
d102 1
d160 1
a160 1
	{ NULL, NULL },				/* Fa */
d163 1
a163 1
	{ NULL, NULL },				/* Fn */
d1007 22
@


1.164
log
@warn about AUTHORS sections without .An macros, inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_validate.c,v 1.163 2014/09/07 00:04:47 schwarze Exp $ */
d119 1
d1859 2
d1906 63
@


1.163
log
@Allow .ll in the prologue; Daniel Levai reports Slackware Linux uses this.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d69 1
a116 1
static	int	 post_sh_body(POST_ARGS);
d118 2
d1851 2
a1852 1
	if (MDOC_HEAD == mdoc->last->type)
d1854 13
a1866 2
	if (MDOC_BODY == mdoc->last->type)
		return(post_sh_body(mdoc));
d1872 1
a1872 1
post_sh_body(POST_ARGS)
a1875 3
	if (SEC_NAME != mdoc->lastsec)
		return(1);

d1903 20
@


1.162
log
@Do not dereference a NULL pointer if a .Bl macro has
no -type, -width, -offset or -compact arguments whatsoever;
this got broken in mdoc_validate.c rev. 1.156.
While here, sort headers.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.161 2014/08/08 16:17:09 schwarze Exp $ */
a1644 3
	n = mdoc->first;
	assert(n);

d1647 7
a1653 4
	if (NULL == n->child)
		mandoc_msg(MANDOCERR_DOC_EMPTY, mdoc->parse,
		    n->line, n->pos, NULL);
	else if (MDOC_Sh != n->child->tok)
d1655 1
a1655 2
		    n->child->line, n->child->pos,
		    mdoc_macronames[n->child->tok]);
@


1.161
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.160 2014/08/08 16:11:10 schwarze Exp $ */
d19 2
a24 2
#include <sys/types.h>

d531 1
a531 1
	wa = n->args->argv;
@


1.160
log
@Simplify by allowing only one post-handler.
Saves 36 static arrays and 10 lines of code
at the expense of only five new trivial static functions.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.159 2014/08/08 16:08:19 schwarze Exp $ */
a112 1
static	int	 post_prol(POST_ARGS);
d841 1
a841 5
	if (NULL == mdoc->meta.date || mdoc->meta.os)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dt");

	if (mdoc->meta.title)
d844 3
a846 1

d854 2
a855 2
	if (NULL == mdoc->meta.title || NULL == mdoc->meta.date)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
d857 2
a858 3

	if (mdoc->meta.os)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
a859 1

d867 2
a868 2
	if (mdoc->meta.title || mdoc->meta.os)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
d870 2
a871 3

	if (mdoc->meta.date)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
d873 6
a878 1

d1625 18
a1642 14
	if ( ! (MDOC_PBODY & mdoc->flags)) {
		mandoc_msg(MANDOCERR_PROLOG_BAD, mdoc->parse, 0, 0, "EOF");
		if (mdoc->meta.date == NULL)
			mdoc->meta.date = mdoc->quick ?
			    mandoc_strdup("") :
			    mandoc_normdate(mdoc->parse, NULL, 0, 0);
		if (mdoc->meta.title == NULL)
			mdoc->meta.title = mandoc_strdup("UNKNOWN");
		if (mdoc->meta.vol == NULL)
			mdoc->meta.vol = mandoc_strdup("LOCAL");
		if (mdoc->meta.arch == NULL)
			mdoc->meta.msec = mandoc_strdup("1");
		if (mdoc->meta.os == NULL)
			mdoc->meta.os = mandoc_strdup("UNKNOWN");
d1979 4
a1982 1
	assert(mdoc->meta.msec);
d2161 1
a2161 1
		return(post_prol(mdoc));
d2173 3
a2175 1
	return(post_prol(mdoc));
d2187 9
a2195 8
	if (mdoc->meta.title)
		free(mdoc->meta.title);
	if (mdoc->meta.vol)
		free(mdoc->meta.vol);
	if (mdoc->meta.arch)
		free(mdoc->meta.arch);

	mdoc->meta.title = mdoc->meta.vol = mdoc->meta.arch = NULL;
d2210 1
a2210 3
	/* Handles: `.Dt'
	 * title = unknown, volume = local, msec = 0, arch = NULL
	 */
d2213 3
a2215 3
		/* XXX: make these macro values. */
		/* FIXME: warn about missing values. */
		mdoc->meta.title = mandoc_strdup("UNKNOWN");
d2217 1
a2217 2
		mdoc->meta.msec = mandoc_strdup("1");
		return(post_prol(mdoc));
d2220 1
a2220 3
	/* Handles: `.Dt TITLE'
	 * title = TITLE, volume = local, msec = 0, arch = NULL
	 */
d2223 1
a2223 1
	    '\0' == nn->string[0] ? "UNKNOWN" : nn->string);
d2226 3
a2228 2
		/* FIXME: warn about missing msec. */
		/* XXX: make this a macro value. */
d2230 1
a2230 2
		mdoc->meta.msec = mandoc_strdup("1");
		return(post_prol(mdoc));
d2252 1
a2252 1
		return(post_prol(mdoc));
d2278 2
a2279 17

	return(post_prol(mdoc));
}

static int
post_prol(POST_ARGS)
{
	/*
	 * Remove prologue macros from the document after they're
	 * processed.  The final document uses mdoc_meta for these
	 * values and discards the originals.
	 */

	mdoc_node_delete(mdoc, mdoc->last);
	if (mdoc->meta.title && mdoc->meta.date && mdoc->meta.os)
		mdoc->flags |= MDOC_PBODY;

d2325 1
a2325 1
		return(post_prol(mdoc));
d2329 1
a2329 1
		return(post_prol(mdoc));
d2346 4
a2349 1
	return(post_prol(mdoc));
@


1.159
log
@Simplify by allowing only one pre-handler.
Saves 12 static arrays and 19 lines of code.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.158 2014/08/08 15:57:05 schwarze Exp $ */
d60 1
a60 1
	v_post	*post;
d86 1
d93 1
d101 1
d103 1
d108 1
a132 37
static	v_post	 posts_an[] = { post_an, NULL };
static	v_post	 posts_at[] = { post_at, post_defaults, NULL };
static	v_post	 posts_bd[] = { post_literal, hwarn_eq0, bwarn_ge1, NULL };
static	v_post	 posts_bf[] = { post_bf, NULL };
static	v_post	 posts_bk[] = { hwarn_eq0, bwarn_ge1, NULL };
static	v_post	 posts_bl[] = { bwarn_ge1, post_bl, NULL };
static	v_post	 posts_bx[] = { post_bx, NULL };
static	v_post	 posts_bool[] = { ebool, NULL };
static	v_post	 posts_eoln[] = { post_eoln, NULL };
static	v_post	 posts_defaults[] = { post_defaults, NULL };
static	v_post	 posts_d1[] = { bwarn_ge1, post_hyph, NULL };
static	v_post	 posts_dd[] = { post_dd, post_prol, NULL };
static	v_post	 posts_dl[] = { post_literal, bwarn_ge1, NULL };
static	v_post	 posts_dt[] = { post_dt, post_prol, NULL };
static	v_post	 posts_en[] = { post_en, NULL };
static	v_post	 posts_es[] = { post_es, NULL };
static	v_post	 posts_ex[] = { post_ex, NULL };
static	v_post	 posts_fo[] = { hwarn_eq1, bwarn_ge1, NULL };
static	v_post	 posts_hyph[] = { post_hyph, NULL };
static	v_post	 posts_hyphtext[] = { ewarn_ge1, post_hyph, NULL };
static	v_post	 posts_it[] = { post_it, NULL };
static	v_post	 posts_lb[] = { post_lb, NULL };
static	v_post	 posts_nd[] = { berr_ge1, post_hyph, NULL };
static	v_post	 posts_nm[] = { post_nm, NULL };
static	v_post	 posts_notext[] = { ewarn_eq0, NULL };
static	v_post	 posts_ns[] = { post_ns, NULL };
static	v_post	 posts_os[] = { post_os, post_prol, NULL };
static	v_post	 posts_pp[] = { post_par, ewarn_eq0, NULL };
static	v_post	 posts_rs[] = { post_rs, NULL };
static	v_post	 posts_sh[] = { post_ignpar,hwarn_ge1,post_sh,post_hyph,NULL };
static	v_post	 posts_sp[] = { post_par, ewarn_le1, NULL };
static	v_post	 posts_ss[] = { post_ignpar, hwarn_ge1, post_hyph, NULL };
static	v_post	 posts_st[] = { post_st, NULL };
static	v_post	 posts_text[] = { ewarn_ge1, NULL };
static	v_post	 posts_text1[] = { ewarn_eq1, NULL };
static	v_post	 posts_vt[] = { post_vt, NULL };

d135 9
a143 9
	{ pre_dd, posts_dd },			/* Dd */
	{ pre_dt, posts_dt },			/* Dt */
	{ pre_os, posts_os },			/* Os */
	{ NULL, posts_sh },			/* Sh */
	{ NULL, posts_ss },			/* Ss */
	{ pre_par, posts_pp },			/* Pp */
	{ pre_display, posts_d1 },		/* D1 */
	{ pre_literal, posts_dl },		/* Dl */
	{ pre_bd, posts_bd },			/* Bd */
d145 1
a145 1
	{ pre_bl, posts_bl },			/* Bl */
d147 1
a147 1
	{ pre_par, posts_it },			/* It */
d149 2
a150 2
	{ pre_an, posts_an },			/* An */
	{ NULL, posts_defaults },		/* Ar */
d156 1
a156 1
	{ pre_std, posts_ex },			/* Ex */
d158 1
a158 1
	{ NULL, posts_text },			/* Fd */
d163 4
a166 4
	{ NULL, posts_text1 },			/* In */
	{ NULL, posts_defaults },		/* Li */
	{ NULL, posts_nd },			/* Nd */
	{ NULL, posts_nm },			/* Nm */
d169 1
a169 1
	{ NULL, posts_defaults },		/* Pa */
d171 1
a171 1
	{ NULL, posts_st },			/* St */
d173 13
a185 13
	{ NULL, posts_vt },			/* Vt */
	{ NULL, posts_text },			/* Xr */
	{ NULL, posts_text },			/* %A */
	{ NULL, posts_hyphtext },		/* %B */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, posts_text },			/* %D */
	{ NULL, posts_text },			/* %I */
	{ NULL, posts_text },			/* %J */
	{ NULL, posts_hyphtext },		/* %N */
	{ NULL, posts_hyphtext },		/* %O */
	{ NULL, posts_text },			/* %P */
	{ NULL, posts_hyphtext },		/* %R */
	{ NULL, posts_hyphtext },		/* %T */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, posts_text },			/* %V */
d189 1
a189 1
	{ NULL, posts_at },			/* At */
d191 1
a191 1
	{ NULL, posts_bf },			/* Bf */
d195 2
a196 2
	{ NULL, posts_bx },			/* Bx */
	{ NULL, posts_bool },			/* Db */
d206 2
a207 2
	{ NULL, posts_notext },			/* No */
	{ NULL, posts_ns },			/* Ns */
d211 1
a211 1
	{ NULL, posts_text1 },			/* Pf */
d219 1
a219 1
	{ NULL, posts_rs },			/* Rs */
d223 2
a224 2
	{ NULL, posts_bool },			/* Sm */
	{ NULL, posts_hyph },			/* Sx */
d230 1
a230 1
	{ NULL, posts_fo },			/* Fo */
d234 1
a234 1
	{ NULL, posts_bk },			/* Bk */
d236 1
a236 1
	{ NULL, posts_eoln },			/* Bt */
d239 3
a241 3
	{ NULL, posts_eoln },			/* Ud */
	{ NULL, posts_lb },			/* Lb */
	{ pre_par, posts_pp },			/* Lp */
d243 1
a243 1
	{ NULL, posts_defaults },		/* Mt */
d247 3
a249 3
	{ NULL, posts_text },			/* %C */
	{ pre_obsolete, posts_es },		/* Es */
	{ pre_obsolete, posts_en },		/* En */
d251 4
a254 4
	{ NULL, posts_text },			/* %Q */
	{ NULL, posts_pp },			/* br */
	{ NULL, posts_sp },			/* sp */
	{ NULL, posts_text1 },			/* %U */
d332 2
a333 1
	v_post		*p;
d335 2
a336 1
	if (MDOC_VALID & mdoc->last->flags)
d338 1
a338 1
	mdoc->last->flags |= MDOC_VALID;
d340 1
a340 1
	switch (mdoc->last->type) {
d350 2
a351 1
		break;
a352 8

	if (NULL == mdoc_valids[mdoc->last->tok].post)
		return(1);
	for (p = mdoc_valids[mdoc->last->tok].post; *p; p++)
		if ( ! (*p)(mdoc))
			return(0);

	return(1);
d999 9
d1047 16
d1066 4
a1106 6
	case MDOC_At:
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, "AT&T"))
			return(0);
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, "UNIX"))
			return(0);
		break;
d1133 9
d1148 1
a1148 3
	if (NULL == (n = mdoc->last->child))
		return(1);

d1516 2
d1575 9
d1824 8
d1845 2
d2017 3
d2082 5
d2155 1
a2155 1
		return(1);
d2167 1
a2167 1
	return(1);
d2211 1
a2211 1
		return(1);
d2226 1
a2226 1
		return(1);
d2248 1
a2248 1
		return(1);
d2275 1
a2275 1
	return(1);
d2336 1
a2336 1
		return(1);
d2340 1
a2340 1
		return(1);
d2357 1
a2357 1
	return(1);
@


1.158
log
@demacrify: get rid of man_nmsg(), man_pmsg(), mdoc_nmsg(), mdoc_pmsg()
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.157 2014/08/08 15:54:10 schwarze Exp $ */
d59 1
a59 1
	v_pre	*pre;
a163 12
static	v_pre	 pres_an[] = { pre_an, NULL };
static	v_pre	 pres_bd[] = { pre_display, pre_bd, pre_literal, pre_par, NULL };
static	v_pre	 pres_bl[] = { pre_bl, pre_par, NULL };
static	v_pre	 pres_d1[] = { pre_display, NULL };
static	v_pre	 pres_dl[] = { pre_literal, pre_display, NULL };
static	v_pre	 pres_dd[] = { pre_dd, NULL };
static	v_pre	 pres_dt[] = { pre_dt, NULL };
static	v_pre	 pres_it[] = { pre_par, NULL };
static	v_pre	 pres_obsolete[] = { pre_obsolete, NULL };
static	v_pre	 pres_os[] = { pre_os, NULL };
static	v_pre	 pres_pp[] = { pre_par, NULL };
static	v_pre	 pres_std[] = { pre_std, NULL };
d167 3
a169 3
	{ pres_dd, posts_dd },			/* Dd */
	{ pres_dt, posts_dt },			/* Dt */
	{ pres_os, posts_os },			/* Os */
d172 4
a175 4
	{ pres_pp, posts_pp },			/* Pp */
	{ pres_d1, posts_d1 },			/* D1 */
	{ pres_dl, posts_dl },			/* Dl */
	{ pres_bd, posts_bd },			/* Bd */
d177 1
a177 1
	{ pres_bl, posts_bl },			/* Bl */
d179 1
a179 1
	{ pres_it, posts_it },			/* It */
d181 1
a181 1
	{ pres_an, posts_an },			/* An */
d188 1
a188 1
	{ pres_std, posts_ex },			/* Ex */
d200 1
a200 1
	{ pres_obsolete, NULL },		/* Ot */
d202 1
a202 1
	{ pres_std, NULL },			/* Rv */
d270 1
a270 1
	{ pres_obsolete, NULL },		/* Fr */
d273 1
a273 1
	{ pres_pp, posts_pp },			/* Lp */
d280 2
a281 2
	{ pres_obsolete, posts_es },		/* Es */
	{ pres_obsolete, posts_en },		/* En */
d340 1
a340 3
	v_pre		*p;
	int		 line, pos;
	char		*tp;
d344 1
a344 4
		tp = n->string;
		line = n->line;
		pos = n->pos;
		check_text(mdoc, line, pos, tp);
d357 2
a358 7

	if (NULL == mdoc_valids[n->tok].pre)
		return(1);
	for (p = mdoc_valids[n->tok].pre; *p; p++)
		if ( ! (*p)(mdoc, n))
			return(0);
	return(1);
d730 1
a730 1
	return(1);
d741 2
d822 1
a822 1
	return(1);
d2091 2
@


1.157
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.156 2014/08/08 15:45:58 schwarze Exp $ */
d1664 2
a1665 1
		mdoc_nmsg(mdoc, n, MANDOCERR_DOC_EMPTY);
d1844 2
a1845 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NS_SKIP);
@


1.156
log
@Split MANDOCERR_IGNARGV into one message for .An and one for .Bl
and report the macro name and argument.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.155 2014/08/08 15:42:39 schwarze Exp $ */
d679 1
a679 1
			mandoc_msg(MANDOCERR_BL_REP,
d681 1
a681 1
			    mdoc_argnames[argv->arg]);
d690 2
a691 2
			mandoc_msg(MANDOCERR_BL_LATETYPE,
			    mdoc->parse, n->line, n->pos,
d704 2
a705 1
		mdoc_nmsg(mdoc, n, MANDOCERR_BL_NOTYPE);
d719 2
a720 1
			mdoc_nmsg(mdoc, n, MANDOCERR_BL_NOWIDTH);
d797 2
a798 1
			mdoc_nmsg(mdoc, n, MANDOCERR_BADDISP);
d831 1
a831 1
			mandoc_msg(MANDOCERR_BD_REP,
d833 1
a833 1
			    mdoc_argnames[argv->arg]);
d837 2
a838 1
		mdoc_nmsg(mdoc, n, MANDOCERR_BD_NOTYPE);
d975 2
a976 1
			mdoc_nmsg(mdoc, np, MANDOCERR_BF_NOFONT);
d1089 2
a1090 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NM_NONAME);
d1178 2
a1179 2
		mandoc_msg(MANDOCERR_AT_BAD, mdoc->parse,
		    n->line, n->pos, n->string);
d1246 1
a1246 1
			mandoc_msg(MANDOCERR_IT_NOHEAD,
d1248 1
d1259 1
a1259 1
			mandoc_msg(MANDOCERR_IT_NOBODY,
d1261 1
d1692 2
a1693 2
		mandoc_msg(MANDOCERR_ST_BAD, mdoc->parse,
		    nch->line, nch->pos, nch->string);
d1920 3
a1922 2
		mandoc_msg(MANDOCERR_NAMESEC_FIRST, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, secname);
d1965 3
a1967 2
		mandoc_msg(MANDOCERR_SEC_REP, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, secname);
d1970 3
a1972 2
		mandoc_msg(MANDOCERR_SEC_ORDER, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, secname);
d2006 1
a2006 1
		    "%s for %s only", secname, goodsec);
d2188 1
a2188 1
			mandoc_msg(MANDOCERR_TITLE_CASE,
d2191 1
a2191 1
			    nn->string);
d2235 2
a2236 2
		mandoc_msg(MANDOCERR_MSEC_BAD, mdoc->parse,
		    nn->line, nn->pos, nn->string);
d2258 2
a2259 2
			mandoc_msg(MANDOCERR_ARCH_BAD, mdoc->parse,
			    nn->line, nn->pos, nn->string);
d2369 2
a2370 1
		mdoc_nmsg(mdoc, n, MANDOCERR_EX_NONAME);
@


1.155
log
@In .Bl -column, if some of the column width declarations are given
right after the -column argument and some at the very end of the
argument list, after some other arguments like -compact, concatenate
the column lists.
This gets rid of one of the last useless FATAL errors
and actually shortens the code by a few lines.

This fixes an issue introduced more than five years ago, at first
causing an assert() since bsd.lv mdoc_action.c rev. 1.14 (June 17, 2009),
then later a FATAL error since mdoc_validate rev. 1.130 (Nov. 30, 2010),
and marked as "TODO" ever since.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.154 2014/08/08 15:38:46 schwarze Exp $ */
d567 1
a567 1
	struct mdoc_argv *argv;
d569 1
d591 2
d640 1
d674 1
d730 3
a732 1
			mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV);
d844 2
a845 1
	int		 i;
d847 1
a847 1
	if (NULL == n->args)
d850 6
a855 3
	for (i = 1; i < (int)n->args->argc; i++)
		mdoc_pmsg(mdoc, n->args->argv[i].line,
		    n->args->argv[i].pos, MANDOCERR_IGNARGV);
d857 2
a858 1
	if (MDOC_Split == n->args->argv[0].arg)
d860 1
a860 1
	else if (MDOC_Nosplit == n->args->argv[0].arg)
@


1.154
log
@Remove the useless FATAL error "argument count wrong, violates syntax".
The last remaining instance was .It in .Bl -column with more than one
excessive .Ta.  However, simply downgrading from FATAL to ERROR, it just
works fine, almost the same way as in groff, without any other changes.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.153 2014/08/08 15:26:28 schwarze Exp $ */
d1450 1
d1458 1
a1458 1
	 * Convert old-style lists, where the column width specifiers
d1463 1
a1463 11
	/* First, disallow both types and allow normal-form. */

	/*
	 * TODO: technically, we can accept both and just merge the two
	 * lists, but I'll leave that for another day.
	 */

	if (mdoc->last->norm->Bl.ncols && mdoc->last->nchild) {
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_COLUMNS);
		return(0);
	} else if (NULL == mdoc->last->child)
a1473 1
	assert(0 == np->args->argv[j].sz);
d1481 5
a1485 3
	np->args->argv[j].sz = (size_t)mdoc->last->nchild;
	np->args->argv[j].value = mandoc_reallocarray(NULL,
	    (size_t)mdoc->last->nchild, sizeof(char *));
d1487 2
a1488 2
	mdoc->last->norm->Bl.ncols = np->args->argv[j].sz;
	mdoc->last->norm->Bl.cols = (void *)np->args->argv[j].value;
d1490 2
a1491 2
	for (i = 0, nn = mdoc->last->child; nn; i++) {
		np->args->argv[j].value[i] = nn->string;
@


1.153
log
@Get rid of the useless FATAL error "child violates parent syntax".
When finding items outside lists, simply skip them and throw an ERROR.
Handle subsections before the first section instead of bailing out.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.152 2014/08/08 15:21:17 schwarze Exp $ */
a1208 1
	enum mandocerr	  er;
d1259 5
a1263 10
		if (i < cols)
			er = MANDOCERR_ARGCOUNT;
		else if (i == cols || i == cols + 1)
			break;
		else
			er = MANDOCERR_SYNTARGCOUNT;

		mandoc_vmsg(er, mdoc->parse, nit->line, nit->pos,
		    "columns == %d (have %d)", cols, i);
		return(MANDOCERR_ARGCOUNT == er);
@


1.152
log
@Remove two useless FATAL errors.
When a file contains neither text nor macros, treat it as an empty document.
When the mdoc(7) document prologue is incomplete, use some default values.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.151 2014/08/08 15:15:27 schwarze Exp $ */
a64 1
static	int	 check_parent(PRE_ARGS, enum mdoct, enum mdoc_type);
a121 1
static	int	 pre_it(PRE_ARGS);
a125 2
static	int	 pre_sh(PRE_ARGS);
static	int	 pre_ss(PRE_ARGS);
d171 1
a171 1
static	v_pre	 pres_it[] = { pre_it, pre_par, NULL };
a174 2
static	v_pre	 pres_sh[] = { pre_sh, NULL };
static	v_pre	 pres_ss[] = { pre_ss, NULL };
d182 2
a183 2
	{ pres_sh, posts_sh },			/* Sh */
	{ pres_ss, posts_ss },			/* Ss */
a542 16
check_parent(PRE_ARGS, enum mdoct tok, enum mdoc_type t)
{

	assert(n->parent);
	if ((MDOC_ROOT == t || tok == n->parent->tok) &&
			(t == n->parent->type))
		return(1);

	mandoc_vmsg(MANDOCERR_SYNTCHILD, mdoc->parse,
	    n->line, n->pos, "want parent %s",
	    MDOC_ROOT == t ? "<root>" : mdoc_macronames[tok]);
	return(0);
}


static int
a831 28
}

static int
pre_ss(PRE_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(1);
	return(check_parent(mdoc, n, MDOC_Sh, MDOC_BODY));
}

static int
pre_sh(PRE_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(1);
	return(check_parent(mdoc, n, MDOC_MAX, MDOC_ROOT));
}

static int
pre_it(PRE_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(1);

	return(check_parent(mdoc, n, MDOC_Bl, MDOC_BODY));
@


1.151
log
@better name and wording for the last two non-generic errors
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.150 2014/08/08 15:10:15 schwarze Exp $ */
a1681 1
	int		  ret;
d1684 1
a1684 3
	ret = 1;

	/* Check that we have a finished prologue. */
d1687 13
a1699 2
		ret = 0;
		mdoc_nmsg(mdoc, mdoc->first, MANDOCERR_NODOCPROLOG);
d1714 1
a1714 1
	return(ret);
@


1.150
log
@Various improvements related to .Ex and .Rv:
* let .Nm fall back to the empty string, not to UNKNOWN
* never let .Rv copy an argument from .Nm
* avoid spurious \fR after empty .Nm in -Tman
* correct handling of .Ex and .Rv in -Tman
* correct the wording of the output for .Rv without arguments
* use non-breaking spaces in .Ex and .Rv output where required
* split MANDOCERR_NONAME into a warning for .Ex and an error for .Nm
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.149 2014/08/08 15:03:25 schwarze Exp $ */
d2375 2
a2376 1
			mdoc_nmsg(mdoc, n, MANDOCERR_UNAME);
@


1.149
log
@Partial implementation of .Bd -centered.

In groff, .Bd -centered operates in fill mode, which is relatively
hard to implement, while this implementation operates in non-fill
mode so far.  As long as you pay attention that your lines do not
overflow, it works.  To make sure that rendering is the same for
mandoc and groff, it is recommended to insert .br between lines
for now.  This implementation will need improvement later.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.148 2014/07/07 16:12:06 schwarze Exp $ */
d99 1
a115 1
static	int	 post_std(POST_ARGS);
d148 1
a164 1
static	v_post	 posts_std[] = { post_std, NULL };
d206 1
a206 1
	{ pres_std, posts_std },		/* Ex */
d220 1
a220 1
	{ pres_std, posts_std },		/* Rv */
a532 6

	/* FIXME: move to post_std(). */

	if (MDOC_Std == v->arg)
		if ( ! (v->sz || mdoc->meta.name))
			mdoc_nmsg(mdoc, n, MANDOCERR_NONAME);
d1121 2
a1122 4
	if (NULL == mdoc->meta.name) {
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NONAME);
		mdoc->meta.name = mandoc_strdup("UNKNOWN");
	}
d2386 4
d2391 1
a2391 1
post_std(POST_ARGS)
d2393 1
a2393 1
	struct mdoc_node *nn, *n;
a2396 6
	/*
	 * Macros accepting `-std' as an argument have the name of the
	 * current document (`Nm') filled in as the argument if it's not
	 * provided.
	 */

d2400 2
a2401 1
	if (NULL == mdoc->meta.name)
d2403 1
a2404 1
	nn = n;
d2410 1
a2410 1
	mdoc->last = nn;
@


1.148
log
@no need to delete any content from .Rs blocks,
and downgrade the related message from ERROR to WARNING
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.147 2014/07/06 19:08:56 schwarze Exp $ */
d801 1
a801 1
			dt = DISP_centred;
@


1.147
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.146 2014/07/05 12:33:54 schwarze Exp $ */
a1766 33
	 * Make sure only certain types of nodes are allowed within the
	 * the `Rs' body.  Delete offending nodes and raise a warning.
	 * Do this before re-ordering for the sake of clarity.
	 */

	next = NULL;
	for (nn = mdoc->last->child; nn; nn = next) {
		for (i = 0; i < RSORD_MAX; i++)
			if (nn->tok == rsord[i])
				break;

		if (i < RSORD_MAX) {
			if (MDOC__J == rsord[i] || MDOC__B == rsord[i])
				mdoc->last->norm->Rs.quote_T++;
			next = nn->next;
			continue;
		}

		next = nn->next;
		mandoc_msg(MANDOCERR_RS_SKIP, mdoc->parse,
		    nn->line, nn->pos, mdoc_macronames[nn->tok]);
		mdoc_node_delete(mdoc, nn);
	}

	/*
	 * Nothing to sort if only invalid nodes were found
	 * inside the `Rs' body.
	 */

	if (NULL == mdoc->last->child)
		return(1);

	/*
d1769 1
a1769 1
	 * and correctly order it.  This is a insertion sort.
d1779 8
d1812 2
@


1.146
log
@Cleanup with respect to bad macro arguments.
* Fix .Sm with invalid arg: move arg out and toggle mode.
* Promote "unknown standard" from WARNING to ERROR, it loses information.
* Delete MANDOCERR_BADWIDTH, it would only indicate a mandoc(1) bug.
* Do not report MANDOCERR_BL_LATETYPE when there is no type at all.
* Mention macro names, arguments and fallbacks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.145 2014/07/05 01:11:33 schwarze Exp $ */
d550 2
a551 1
		mdoc_pmsg(mdoc, ln, pos + (int)(p - cp), MANDOCERR_BADTAB);
@


1.145
log
@Cleanup regarding -offset and -width:
* Bugfix: Last one wins, not first one.
* Fix .Bl -width without argument: it means 0n, so do not ignore it.
* Report macro names, argument names and fallbacks in related messages.
* Simplify: Garbage collect auxiliary variables in pre_bd() and pre_bl().
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.144 2014/07/04 16:11:41 schwarze Exp $ */
d695 2
d700 5
a704 14
		if (LIST__NONE != lt && n->norm->Bl.type != LIST__NONE)
			mdoc_nmsg(mdoc, n, MANDOCERR_LISTREP);

		/* Assign list type. */

		if (LIST__NONE != lt && n->norm->Bl.type == LIST__NONE) {
			n->norm->Bl.type = lt;
			/* Set column information, too. */
			if (LIST_column == lt) {
				n->norm->Bl.ncols =
				    n->args->argv[i].sz;
				n->norm->Bl.cols = (void *)
				    n->args->argv[i].value;
			}
d709 12
a720 8
		if (n->norm->Bl.type == LIST__NONE)
			if (n->norm->Bl.width ||
			    n->norm->Bl.offs ||
			    n->norm->Bl.comp)
				mandoc_msg(MANDOCERR_BL_LATETYPE,
				    mdoc->parse, n->line, n->pos,
				    mdoc_argnames[n->args->argv[0].arg]);
		continue;
d740 1
a740 1
			mdoc_nmsg(mdoc, n, MANDOCERR_BL_WIDTH);
d842 2
d845 1
a845 8
		/* Check whether a type has already been assigned. */

		if (DISP__NONE != dt && n->norm->Bd.type != DISP__NONE)
			mdoc_nmsg(mdoc, n, MANDOCERR_DISPREP);

		/* Make our type assignment. */

		if (DISP__NONE != dt && n->norm->Bd.type == DISP__NONE)
d847 4
d1217 2
a1218 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADATT);
d1421 2
a1422 4
	else if (0 == (width = macro2len(tok)))  {
		mdoc_nmsg(mdoc, n, MANDOCERR_BADWIDTH);
		return(1);
	}
d1653 5
d1659 2
a1660 2
	if (NULL == mdoc->last->child) {
		if (MDOC_Sm == mdoc->last->tok)
d1667 1
a1667 1
	assert(MDOC_TEXT == mdoc->last->child->type);
d1669 2
a1670 2
	if (0 == strcmp(mdoc->last->child->string, "on")) {
		if (MDOC_Sm == mdoc->last->tok)
d1674 2
a1675 2
	if (0 == strcmp(mdoc->last->child->string, "off")) {
		if (MDOC_Sm == mdoc->last->tok)
d1680 4
a1683 2
	mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADBOOL);
	return(1);
d1719 1
a1719 1
	struct mdoc_node	 *ch;
d1722 4
a1725 1
	if (NULL == (ch = mdoc->last->child)) {
d1727 2
a1728 3
		    mdoc->last->line, mdoc->last->pos,
		    mdoc_macronames[mdoc->last->tok]);
		mdoc_node_delete(mdoc, mdoc->last);
d1732 1
a1732 1
	assert(MDOC_TEXT == ch->type);
d1734 4
a1737 3
	if (NULL == (p = mdoc_a2st(ch->string))) {
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADSTANDARD);
		mdoc_node_delete(mdoc, mdoc->last);
d1739 2
a1740 2
		free(ch->string);
		ch->string = mandoc_strdup(p);
@


1.144
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
Also fix the handling of excess .It head arguments in -Tman.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.143 2014/07/04 01:50:03 schwarze Exp $ */
d593 3
a595 2
	int		  i, comp, dup;
	const char	 *offs, *width;
a596 1
	struct mdoc_node *np;
d618 1
d620 1
a620 3
		dup = comp = 0;
		width = offs = NULL;
		switch (n->args->argv[i].arg) {
d657 5
a661 2
			dup = n->norm->Bl.comp;
			comp = 1;
d664 5
a668 4
			/* NB: this can be empty! */
			if (n->args->argv[i].sz) {
				width = n->args->argv[i].value[0];
				dup = (NULL != n->norm->Bl.width);
d671 6
a676 1
			mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV);
d679 4
a682 4
			/* NB: this can be empty! */
			if (n->args->argv[i].sz) {
				offs = n->args->argv[i].value[0];
				dup = (NULL != n->norm->Bl.offs);
d685 6
a690 1
			mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV);
a695 12
		/* Check: duplicate auxiliary arguments. */

		if (dup)
			mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP);

		if (comp && ! dup)
			n->norm->Bl.comp = comp;
		if (offs && ! dup)
			n->norm->Bl.offs = offs;
		if (width && ! dup)
			n->norm->Bl.width = width;

d779 3
a781 1
	int		  i, dup, comp;
a782 2
	const char	 *offs;
	struct mdoc_node *np;
d798 1
a799 2
		dup = comp = 0;
		offs = NULL;
d801 1
a801 1
		switch (n->args->argv[i].arg) {
d821 4
a824 4
			/* NB: this can be empty! */
			if (n->args->argv[i].sz) {
				offs = n->args->argv[i].value[0];
				dup = (NULL != n->norm->Bd.offs);
d827 6
a832 1
			mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV);
d835 5
a839 2
			comp = 1;
			dup = n->norm->Bd.comp;
a844 12

		/* Check whether we have duplicates. */

		if (dup)
			mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP);

		/* Make our auxiliary assignments. */

		if (offs && ! dup)
			n->norm->Bd.offs = offs;
		if (comp && ! dup)
			n->norm->Bd.comp = comp;
@


1.143
log
@Clean up messages related to missing arguments.
* Do not warn about empty -column cells, they seem valid to me.
* Downgrade empty item and missing -std from ERROR to WARNING.
* Hierarchical naming.
* Descriptive, not imperative style.
* Mention macro names, argument names, and fallbacks.
* Garbage collect some unreachable code in post_it().
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.142 2014/07/03 23:23:45 schwarze Exp $ */
a82 1
static	int	 hwarn_le1(POST_ARGS);
d135 1
a135 1
static	v_post	 posts_bf[] = { hwarn_le1, post_bf, NULL };
a512 6
static int
hwarn_le1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_LT, 2));
}

d990 1
a990 1
	struct mdoc_node *np;
d1017 1
a1017 4
	/*
	 * Cannot have both argument and parameter.
	 * If neither is specified, let it through with a warning.
	 */
d1019 7
a1025 6
	if (np->parent->args && np->child) {
		mdoc_nmsg(mdoc, np, MANDOCERR_SYNTARGVCOUNT);
		return(0);
	} else if (NULL == np->parent->args && NULL == np->child) {
		mdoc_nmsg(mdoc, np, MANDOCERR_FONTTYPE);
		return(1);
d1027 3
d1055 3
a1057 1
		mdoc_nmsg(mdoc, np, MANDOCERR_FONTTYPE);
d1090 1
d1092 6
a1097 2
	if (mdoc->last->child)
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_ARGSLOST);
d1311 3
a1313 1
			mdoc_nmsg(mdoc, nit, MANDOCERR_ARGSLOST);
@


1.142
log
@Fix formatting of empty .Bl -inset item heads.
Downgrade empty item heads from ERROR to WARNING.
Show the list type in the error message.
Choose better variable names for nodes in post_it().
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.141 2014/07/02 20:18:42 schwarze Exp $ */
d726 3
a728 2
				mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST);

d735 1
a735 1
		mdoc_nmsg(mdoc, n, MANDOCERR_LISTTYPE);
d749 1
a749 1
			mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG);
d869 1
a869 1
		mdoc_nmsg(mdoc, n, MANDOCERR_DISPTYPE);
d934 2
a935 1
	mdoc_nmsg(mdoc, n, MANDOCERR_NOARGV);
a1280 5
	if (LIST__NONE == lt) {
		mdoc_nmsg(mdoc, nit, MANDOCERR_LISTTYPE);
		return(1);
	}

d1304 3
a1306 1
			mdoc_nmsg(mdoc, nit, MANDOCERR_NOBODY);
a1316 3
		if (NULL == nit->body->child)
			mdoc_nmsg(mdoc, nit, MANDOCERR_NOBODY);

d1332 1
a1332 1
		break;
@


1.141
log
@Improve and test the messages about empty macros,
in particular reporting the macro names involved.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.140 2014/07/02 19:54:39 schwarze Exp $ */
d1269 1
a1269 1
	struct mdoc_node *n, *c;
d1272 2
a1273 1
	if (MDOC_BLOCK != mdoc->last->type)
d1276 2
a1277 2
	n = mdoc->last->parent->parent;
	lt = n->norm->Bl.type;
d1280 1
a1280 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_LISTTYPE);
d1286 1
a1286 5
		if (mdoc->last->head->child)
			break;
		/* FIXME: give this a dummy value. */
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS);
		break;
d1294 4
a1297 2
		if (NULL == mdoc->last->head->child)
			mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS);
d1306 2
a1307 2
		if (NULL == mdoc->last->body->child)
			mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY);
d1310 2
a1311 2
		if (mdoc->last->head->child)
			mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_ARGSLOST);
d1314 1
a1314 1
		cols = (int)n->norm->Bl.ncols;
d1316 1
a1316 1
		assert(NULL == mdoc->last->head->child);
d1318 2
a1319 2
		if (NULL == mdoc->last->body->child)
			mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY);
d1321 2
a1322 2
		for (i = 0, c = mdoc->last->child; c; c = c->next)
			if (MDOC_BODY == c->type)
d1332 1
a1332 2
		mandoc_vmsg(er, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos,
@


1.140
log
@When .Sm is called without an argument, groff toggles the spacing mode,
so let us do the same for compatibility.  Using this feature is of
course not recommended except in manual page obfuscation contests.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.139 2014/07/02 13:10:15 schwarze Exp $ */
d1728 3
a1730 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_MACROEMPTY);
@


1.139
log
@Disentangle the MANDOCERR_CHILD message, which reported three
completely different things, into three distinct messages.
Also mention the macro names we are talking about.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.138 2014/07/02 11:42:56 schwarze Exp $ */
d1667 2
a1668 2
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_MACROEMPTY);
		mdoc_node_delete(mdoc, mdoc->last);
d1671 2
a1672 1
	check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 1);
@


1.138
log
@Clean up warnings related to macros and nesting.
* Hierarchical naming of enum mandocerr items.
* Improve the wording to make it comprehensible.
* Mention the offending macro.
* Garbage collect one chunk of ancient, long unreachable code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.137 2014/07/02 05:51:49 schwarze Exp $ */
d1116 2
a1117 1
			mdoc_nmsg(mdoc, n, MANDOCERR_CHILD);
d1613 3
a1615 1
		mdoc_nmsg(mdoc, nchild, MANDOCERR_CHILD);
d1784 2
a1785 1
		mdoc_nmsg(mdoc, nn, MANDOCERR_CHILD);
@


1.137
log
@Improve "skipping paragraph macro" messages,
showing which macro was skipped and before or after what.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.136 2014/07/02 03:47:07 schwarze Exp $ */
d590 3
a592 1
		mdoc_nmsg(mdoc, n, MANDOCERR_NESTEDDISP);
d1904 1
a1904 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_IGNNS);
@


1.136
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.135 2014/07/01 22:36:35 schwarze Exp $ */
d1384 3
a1386 1
				mdoc_nmsg(mdoc, nc, MANDOCERR_MOVEPAR);
d1391 4
a1394 1
				mdoc_nmsg(mdoc, nc, MANDOCERR_IGNPAR);
d2082 4
a2085 1
			mdoc_nmsg(mdoc, np, MANDOCERR_IGNPAR);
d2091 4
a2094 1
			mdoc_nmsg(mdoc, np, MANDOCERR_IGNPAR);
d2126 4
a2129 1
	mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_IGNPAR);
d2137 1
d2143 3
a2145 3
	if (NULL == mdoc->last->prev) {
		if (MDOC_Sh != mdoc->last->parent->tok &&
		    MDOC_Ss != mdoc->last->parent->tok)
d2148 1
a2148 2
		if (MDOC_Pp != mdoc->last->prev->tok &&
		    MDOC_Lp != mdoc->last->prev->tok &&
d2150 1
a2150 2
		     (MDOC_sp != mdoc->last->prev->tok &&
		      MDOC_br != mdoc->last->prev->tok)))
d2154 4
a2157 1
	mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_IGNPAR);
@


1.135
log
@Clean up the warnings related to document structure.
* Hierarchical naming of the related enum mandocerr items.
* Mention the offending macro, section title, or string.
While here, improve some wordings:
* Descriptive instead of imperative style.
* Uniform style for "missing" and "skipping".
* Where applicable, mention the fallback used.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.134 2014/06/20 22:58:41 schwarze Exp $ */
d97 2
d126 1
d147 2
d177 1
d219 1
a219 1
	{ NULL, NULL },				/* Ot */
d289 1
a289 1
	{ NULL, NULL },				/* Fr */
d299 2
a300 2
	{ NULL, NULL },				/* Es */
	{ NULL, NULL },				/* En */
d936 10
d1241 17
@


1.134
log
@As suggested by jmc@@, only include line and column numbers into messages
when they are meaningful, to avoid confusing stuff like this:
$ mandoc /dev/null
mandoc: /dev/null:0:1: FATAL: not a manual
Instead, just say:
mandoc: /dev/null: FATAL: not a manual

Another example this applies to is documents having a prologue,
but lacking a body.  Do not throw a FATAL error for these; instead,
issue a warning and show the empty document, in the man(7) case with
the same amount of blank lines as groff does.  Also downgrade mdoc(7)
documents having content before the first .Sh from FATAL to WARNING.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.133 2014/06/20 17:23:09 schwarze Exp $ */
d934 2
a935 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_ORDER);
d938 2
a939 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_REP);
d949 2
a950 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_ORDER);
d953 2
a954 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_REP);
d964 2
a965 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_ORDER);
d968 2
a969 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_REP);
d1669 4
a1672 3
	else if (MDOC_BLOCK != n->child->type ||
	    MDOC_Sh != n->child->tok)
		mdoc_nmsg(mdoc, n->child, MANDOCERR_SEC_BEFORE);
d1895 2
a1896 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC);
d1905 2
a1906 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC);
d1913 2
a1914 1
	mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC);
d1922 1
d1941 2
a1942 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NAMESECFIRST);
d1985 2
a1986 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECREP);
d1989 2
a1990 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECOOO);
d2000 1
d2005 1
d2014 2
d2020 5
a2024 2
		mandoc_msg(MANDOCERR_SECMSEC, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, secname);
d2189 1
a2189 1
	/* First make all characters uppercase. */
d2195 4
a2198 6

			/*
			 * FIXME: don't be lazy: have this make all
			 * characters be uppercase and just warn once.
			 */
			mdoc_nmsg(mdoc, nn, MANDOCERR_TITLE_CASE);
d2242 2
a2243 1
		mdoc_nmsg(mdoc, n, MANDOCERR_MSEC_BAD);
d2265 2
a2266 1
			mdoc_nmsg(mdoc, nn, MANDOCERR_ARCH_BAD);
@


1.133
log
@Start systematic improvements of error reporting.
So far, this covers all WARNINGs related to the prologue.

1) hierarchical naming of MANDOCERR_* constants
2) mention the macro name in messages where that adds clarity
3) add one missing MANDOCERR_DATE_MISSING msg
4) fix the wording of one message related to the man(7) prologue

Started on the plane back from Ottawa.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.132 2014/04/23 21:06:33 schwarze Exp $ */
d1644 1
a1644 1
	int		  erc;
d1647 1
a1647 1
	erc = 0;
d1652 1
a1652 1
		erc++;
d1661 5
a1665 9
	if (NULL == n->child) {
		erc++;
		mdoc_nmsg(mdoc, n, MANDOCERR_NODOCBODY);
	} else if (MDOC_BLOCK != n->child->type ||
	    MDOC_Sh != n->child->tok) {
		erc++;
		/* Can this be lifted?  See rxdebug.1 for example. */
		mdoc_nmsg(mdoc, n, MANDOCERR_NODOCBODY);
	}
d1667 1
a1667 1
	return(erc ? 0 : 1);
@


1.132
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.131 2014/04/23 16:07:06 schwarze Exp $ */
d934 1
a934 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO);
d937 1
a937 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP);
d947 1
a947 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO);
d950 1
a950 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP);
d960 1
a960 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO);
d963 1
a963 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP);
d2183 1
a2183 1
			mdoc_nmsg(mdoc, nn, MANDOCERR_UPPERCASE);
d2227 1
a2227 1
		mdoc_nmsg(mdoc, n, MANDOCERR_BADMSEC);
d2249 1
a2249 1
			mdoc_nmsg(mdoc, nn, MANDOCERR_BADVOLARCH);
@


1.131
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.130 2014/04/20 20:48:34 schwarze Exp $ */
d1459 2
a1460 2
	n->args->argv = mandoc_realloc(n->args->argv,
	    n->args->argc * sizeof(struct mdoc_argv));
d1520 2
a1521 2
	np->args->argv[j].value = mandoc_malloc(
	    (size_t)mdoc->last->nchild * sizeof(char *));
@


1.130
log
@strlen+malloc+snprintf is error prone;
rewrite post_lb() to use asprintf(3) instead
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.129 2014/04/20 19:39:35 schwarze Exp $ */
d1182 3
a1184 3
	const char	 *p, *q;
	char		 *buf;
	size_t		  sz;
d1192 1
a1192 1
	if (NULL == mdoc->last->child)
d1195 2
a1196 7
	assert(MDOC_TEXT == mdoc->last->child->type);
	p = mdoc_a2att(mdoc->last->child->string);

	if (p) {
		free(mdoc->last->child->string);
		mdoc->last->child->string = mandoc_strdup(p);
	} else {
d1198 3
a1200 9
		p = "AT&T UNIX ";
		q = mdoc->last->child->string;
		sz = strlen(p) + strlen(q) + 1;
		buf = mandoc_malloc(sz);
		strlcpy(buf, p, sz);
		strlcat(buf, q, sz);
		free(mdoc->last->child->string);
		mdoc->last->child->string = buf;
	}
d1202 2
@


1.129
log
@make sure static buffers for snprintf(3) are large enough
and cast snprintf return value to (void) where they are
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.128 2014/04/20 16:44:44 schwarze Exp $ */
d1043 3
a1045 3
	const char	*p;
	char		*buf;
	size_t		 sz;
d1049 1
a1049 2
	assert(mdoc->last->child);
	assert(MDOC_TEXT == mdoc->last->child->type);
d1051 2
a1052 1
	p = mdoc_a2lib(mdoc->last->child->string);
d1054 5
a1058 9
	/* If lookup ok, replace with table value. */

	if (p) {
		free(mdoc->last->child->string);
		mdoc->last->child->string = mandoc_strdup(p);
		return(1);
	}

	/* If not, use "library ``xxxx''. */
d1060 2
a1061 7
	sz = strlen(mdoc->last->child->string) + 2 +
	     strlen("\\(lqlibrary\\(rq");
	buf = mandoc_malloc(sz);
	snprintf(buf, sz, "library \\(lq%s\\(rq",
	    mdoc->last->child->string);
	free(mdoc->last->child->string);
	mdoc->last->child->string = buf;
@


1.128
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.127 2014/04/15 00:41:02 schwarze Exp $ */
a43 2
#define	NUMSIZ	  32

d1385 1
a1385 1
	char		  buf[NUMSIZ];
d1417 1
a1417 1
	snprintf(buf, NUMSIZ, "%un", (unsigned int)width);
d1432 1
a1432 1
	char		  buf[NUMSIZ];
d1467 1
a1467 1
	snprintf(buf, NUMSIZ, "%un", (unsigned int)sz);
@


1.127
log
@Using macros in .Sh header lines, or having .Sm off or .Bk -words open
while processing .Sh, is not at all recommended, but it's not strictly
a syntax violation either, and in any case, mandoc must not die in an
assertion.  I broke this in rev. 1.124.

Crash found while trying to read the (rather broken) original 4.3BSD-Reno
od(1) manual page.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.126 2014/03/31 00:02:45 dlg Exp $ */
d65 1
a65 1
static	int	 check_count(struct mdoc *, enum mdoc_type, 
d69 1
a69 1
static	void	 check_argv(struct mdoc *, 
d185 3
a187 3
	{ pres_sh, posts_sh },			/* Sh */ 
	{ pres_ss, posts_ss },			/* Ss */ 
	{ pres_pp, posts_pp },			/* Pp */ 
d192 1
a192 1
	{ pres_bl, posts_bl },			/* Bl */ 
d195 2
a196 2
	{ NULL, NULL },				/* Ad */ 
	{ pres_an, posts_an },			/* An */ 
d198 1
a198 1
	{ NULL, NULL },				/* Cd */ 
d200 5
a204 5
	{ NULL, NULL },				/* Dv */ 
	{ NULL, NULL },				/* Er */ 
	{ NULL, NULL },				/* Ev */ 
	{ pres_std, posts_std },		/* Ex */ 
	{ NULL, NULL },				/* Fa */ 
d207 4
a210 4
	{ NULL, NULL },				/* Fn */ 
	{ NULL, NULL },				/* Ft */ 
	{ NULL, NULL },				/* Ic */ 
	{ NULL, posts_text1 },			/* In */ 
d218 1
a218 1
	{ NULL, posts_st },			/* St */ 
d220 2
a221 2
	{ NULL, posts_vt },			/* Vt */ 
	{ NULL, posts_text },			/* Xr */ 
d236 1
a236 1
	{ NULL, posts_at },			/* At */ 
d248 2
a249 2
	{ NULL, NULL },				/* Ef */ 
	{ NULL, NULL },				/* Em */ 
d252 1
a252 1
	{ NULL, NULL },				/* Ms */ 
d270 1
a270 1
	{ NULL, posts_bool },			/* Sm */ 
d277 2
a278 2
	{ NULL, posts_fo },			/* Fo */ 
	{ NULL, NULL },				/* Fc */ 
d288 6
a293 6
	{ pres_pp, posts_pp },			/* Lp */ 
	{ NULL, NULL },				/* Lk */ 
	{ NULL, posts_defaults },		/* Mt */ 
	{ NULL, NULL },				/* Brq */ 
	{ NULL, NULL },				/* Bro */ 
	{ NULL, NULL },				/* Brc */ 
d351 1
d360 1
a360 1
	case (MDOC_TEXT):
d366 1
a366 1
	case (MDOC_TBL):
d368 1
a368 1
	case (MDOC_EQN):
d370 1
a370 1
	case (MDOC_ROOT):
d381 1
a381 1
		if ( ! (*p)(mdoc, n)) 
a385 1

d396 1
a396 1
	case (MDOC_TEXT):
d398 1
a398 1
	case (MDOC_EQN):
d400 1
a400 1
	case (MDOC_TBL):
d402 1
a402 1
	case (MDOC_ROOT):
d411 1
a411 1
		if ( ! (*p)(mdoc)) 
d418 1
a418 1
check_count(struct mdoc *mdoc, enum mdoc_type type, 
d426 1
a426 1
	
d428 1
a428 1
	case (CHECK_LT):
d433 1
a433 1
	case (CHECK_GT):
d438 1
a438 1
	case (CHECK_EQ):
d449 3
a451 3
	mandoc_vmsg(t, mdoc->parse, mdoc->last->line, mdoc->last->pos,
			"want %s%d children (have %d)",
			p, val, mdoc->last->nchild);
d565 3
a567 3
	mandoc_vmsg(MANDOCERR_SYNTCHILD, mdoc->parse, n->line, 
			n->pos, "want parent %s", MDOC_ROOT == t ? 
			"<root>" : mdoc_macronames[tok]);
d580 1
a580 1
	for (node = mdoc->last->parent; node; node = node->parent) 
a590 1

d612 1
a612 1
	/* 
a617 1
	/* LINTED */
d624 1
a624 1
		case (MDOC_Bullet):
d627 1
a627 1
		case (MDOC_Dash):
d630 1
a630 1
		case (MDOC_Enum):
d633 1
a633 1
		case (MDOC_Hyphen):
d636 1
a636 1
		case (MDOC_Item):
d639 1
a639 1
		case (MDOC_Tag):
d642 1
a642 1
		case (MDOC_Diag):
d645 1
a645 1
		case (MDOC_Hang):
d648 1
a648 1
		case (MDOC_Ohang):
d651 1
a651 1
		case (MDOC_Inset):
d654 1
a654 1
		case (MDOC_Column):
d658 1
a658 1
		case (MDOC_Compact):
d662 1
a662 1
		case (MDOC_Width):
d671 1
a671 1
		case (MDOC_Offset):
d707 2
a708 2
				n->norm->Bl.ncols = 
					n->args->argv[i].sz;
d710 1
a710 1
					n->args->argv[i].value;
d717 3
a719 3
			if (n->norm->Bl.width || 
					n->norm->Bl.offs || 
					n->norm->Bl.comp)
d732 1
a732 1
	/* 
d740 1
a740 1
	case (LIST_tag):
d744 1
a744 1
	case (LIST_column):
d746 1
a746 1
	case (LIST_diag):
d748 1
a748 1
	case (LIST_ohang):
d750 1
a750 1
	case (LIST_inset):
d752 1
a752 1
	case (LIST_item):
d756 1
a756 1
	case (LIST_bullet):
d758 1
a758 1
	case (LIST_dash):
d760 1
a760 1
	case (LIST_hyphen):
d764 1
a764 1
	case (LIST_enum):
a774 1

d779 1
a779 1
	enum mdoc_disp 	  dt;
a795 1
	/* LINTED */
d802 1
a802 1
		case (MDOC_Centred):
d805 1
a805 1
		case (MDOC_Ragged):
d808 1
a808 1
		case (MDOC_Unfilled):
d811 1
a811 1
		case (MDOC_Filled):
d814 1
a814 1
		case (MDOC_Literal):
d817 1
a817 1
		case (MDOC_File):
d820 1
a820 1
		case (MDOC_Offset):
d829 1
a829 1
		case (MDOC_Compact):
a868 1

a877 1

a886 1

a896 1

d904 1
a904 1
	
d906 2
a907 2
		mdoc_pmsg(mdoc, n->args->argv[i].line, 
			n->args->argv[i].pos, MANDOCERR_IGNARGV);
a969 1

d987 1
a987 1
		} else 
d1000 1
a1000 1
	/* 
d1002 1
a1002 1
	 * If neither is specified, let it through with a warning. 
d1014 1
a1014 1
	
d1036 1
a1036 1
	else 
d1066 2
a1067 2
	sz = strlen(mdoc->last->child->string) +
		2 + strlen("\\(lqlibrary\\(rq");
d1069 2
a1070 2
	snprintf(buf, sz, "library \\(lq%s\\(rq", 
			mdoc->last->child->string);
a1084 1

d1100 1
a1100 1
	
d1102 1
a1102 1
		if (MDOC_TEXT != n->type) 
a1107 1

d1127 1
a1127 1
	
d1154 1
a1154 1
	
d1159 1
a1159 1
	case (MDOC_Ar):
d1165 1
a1165 1
	case (MDOC_At):
d1171 1
a1171 1
	case (MDOC_Li):
d1175 1
a1175 1
	case (MDOC_Pa):
d1177 1
a1177 1
	case (MDOC_Mt):
d1184 1
a1184 1
	} 
d1202 1
a1202 1
	
a1241 1

d1262 1
a1262 1
	case (LIST_tag):
d1268 1
a1268 1
	case (LIST_hang):
d1270 1
a1270 1
	case (LIST_ohang):
d1272 1
a1272 1
	case (LIST_inset):
d1274 1
a1274 1
	case (LIST_diag):
d1278 1
a1278 1
	case (LIST_bullet):
d1280 1
a1280 1
	case (LIST_dash):
d1282 1
a1282 1
	case (LIST_enum):
d1284 1
a1284 1
	case (LIST_hyphen):
d1288 1
a1288 1
	case (LIST_item):
d1292 1
a1292 1
	case (LIST_column):
d1311 3
a1313 3
		mandoc_vmsg(er, mdoc->parse, mdoc->last->line, 
				mdoc->last->pos, 
				"columns == %d (have %d)", cols, i);
d1323 1
a1323 1
post_bl_block(POST_ARGS) 
d1337 2
a1338 2
	if (LIST_tag == n->norm->Bl.type && 
			NULL == n->norm->Bl.width) {
d1354 1
a1354 1
			case (MDOC_Pp):
d1356 1
a1356 1
			case (MDOC_Lp):
d1358 1
a1358 1
			case (MDOC_br):
d1413 1
a1413 1
	for (i = 0; i < (int)n->args->argc; i++) 
d1465 1
a1465 1
	} 
d1479 2
a1480 2
	n->args->argv = mandoc_realloc(n->args->argv, 
			n->args->argc * sizeof(struct mdoc_argv));
a1493 1

d1495 1
a1495 1
post_bl_head(POST_ARGS) 
d1512 1
a1512 1
	/* 
d1526 1
a1526 1
	for (j = 0; j < (int)np->args->argc; j++) 
d1540 2
a1541 2
	np->args->argv[j].value = mandoc_malloc
		((size_t)mdoc->last->nchild * sizeof(char *));
d1569 1
a1569 1
	case (MDOC_BLOCK):
d1571 1
a1571 1
	case (MDOC_HEAD):
d1573 1
a1573 1
	case (MDOC_BODY):
d1678 1
a1678 1
	
d1684 2
a1685 2
	} else if (MDOC_BLOCK != n->child->type || 
			MDOC_Sh != n->child->tok) {
d1726 1
a1726 1
	case (MDOC_HEAD):
d1729 1
a1729 1
	case (MDOC_BODY):
d1783 1
a1783 1
		/* 
d1789 1
a1789 1
		
d1798 1
a1798 1
		/* 
d1847 1
a1847 1
	case (MDOC_HEAD):
d1851 1
a1851 1
	case (MDOC_BODY):
d1855 1
a1855 1
	case (MDOC_ELEM):
d2011 1
a2011 1
	case (SEC_ERRORS):
d2015 1
a2015 1
	case (SEC_RETURN_VALUES):
d2017 1
a2017 1
	case (SEC_LIBRARY):
d2023 1
a2023 1
	case (SEC_CONTEXT):
d2069 1
a2069 1
	/* 
d2129 1
a2129 1
	case (MDOC_Dl):
d2132 1
a2132 1
	case (MDOC_Bd):
d2142 1
a2142 1
	
d2199 1
a2199 1
			/* 
d2207 2
a2208 2
	/* Handles: `.Dt' 
	 *   --> title = unknown, volume = local, msec = 0, arch = NULL
d2220 2
a2221 2
	/* Handles: `.Dt TITLE' 
	 *   --> title = TITLE, volume = local, msec = 0, arch = NULL
d2224 2
a2225 2
	mdoc->meta.title = mandoc_strdup
		('\0' == nn->string[0] ? "UNKNOWN" : nn->string);
d2236 4
a2239 4
	 *   --> title = TITLE, volume = SEC is msec ? 
	 *           format(msec) : SEC,
	 *       msec = SEC is msec ? atoi(msec) : 0,
	 *       arch = NULL
d2250 1
a2250 1
	} 
d2256 4
a2259 4
	 *   --> title = TITLE, volume = VOL is vol ?
	 *       format(VOL) : 
	 *           VOL is arch ? format(arch) : 
	 *               VOL
d2272 1
a2272 1
		} else 
d2274 1
a2274 1
	}	
d2303 1
a2303 1
	/* 
d2311 1
a2311 2
		*n->string = (char)toupper
			((unsigned char)*n->string);
d2334 1
a2334 1
 	 */
d2353 2
a2354 2
                        defbuf = mandoc_strdup("UNKNOWN");
                } else
d2381 1
a2381 1
	
d2392 1
a2392 1
static enum mdoc_sec 
d2397 1
a2397 1
	for (i = 0; i < (int)SEC__MAX; i++) 
d2409 1
a2409 1
	case(MDOC_Ad):
d2411 1
a2411 1
	case(MDOC_Ao):
d2413 1
a2413 1
	case(MDOC_An):
d2415 1
a2415 1
	case(MDOC_Aq):
d2417 1
a2417 1
	case(MDOC_Ar):
d2419 1
a2419 1
	case(MDOC_Bo):
d2421 1
a2421 1
	case(MDOC_Bq):
d2423 1
a2423 1
	case(MDOC_Cd):
d2425 1
a2425 1
	case(MDOC_Cm):
d2427 1
a2427 1
	case(MDOC_Do):
d2429 1
a2429 1
	case(MDOC_Dq):
d2431 1
a2431 1
	case(MDOC_Dv):
d2433 1
a2433 1
	case(MDOC_Eo):
d2435 1
a2435 1
	case(MDOC_Em):
d2437 1
a2437 1
	case(MDOC_Er):
d2439 1
a2439 1
	case(MDOC_Ev):
d2441 1
a2441 1
	case(MDOC_Fa):
d2443 1
a2443 1
	case(MDOC_Fl):
d2445 1
a2445 1
	case(MDOC_Fo):
d2447 1
a2447 1
	case(MDOC_Fn):
d2449 1
a2449 1
	case(MDOC_Ic):
d2451 1
a2451 1
	case(MDOC_Li):
d2453 1
a2453 1
	case(MDOC_Ms):
d2455 1
a2455 1
	case(MDOC_Nm):
d2457 1
a2457 1
	case(MDOC_No):
d2459 1
a2459 1
	case(MDOC_Oo):
d2461 1
a2461 1
	case(MDOC_Op):
d2463 1
a2463 1
	case(MDOC_Pa):
d2465 1
a2465 1
	case(MDOC_Pf):
d2467 1
a2467 1
	case(MDOC_Po):
d2469 1
a2469 1
	case(MDOC_Pq):
d2471 1
a2471 1
	case(MDOC_Ql):
d2473 1
a2473 1
	case(MDOC_Qo):
d2475 1
a2475 1
	case(MDOC_So):
d2477 1
a2477 1
	case(MDOC_Sq):
d2479 1
a2479 1
	case(MDOC_Sy):
d2481 1
a2481 1
	case(MDOC_Sx):
d2483 1
a2483 1
	case(MDOC_Tn):
d2485 1
a2485 1
	case(MDOC_Va):
d2487 1
a2487 1
	case(MDOC_Vt):
d2489 1
a2489 1
	case(MDOC_Xr):
@


1.126
log
@recognise the CONTEXT section. we consider it only applicable to
section 9 manpages for now.

requested by schwartz@@ pre 5.5
tweaks by jmc@@ schwartz@@
ok schwartz@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.125 2014/03/30 19:47:32 schwarze Exp $ */
d1949 1
a1949 1
	const char	*secname;
d1961 2
a1962 9
	n = mdoc->last;
	if (n->child) {
		assert(1 == n->nchild);
		n = n->child;
		assert(NULL != n);
		assert(MDOC_TEXT == n->type);
		secname = n->string;
		sec = a2sec(secname);
	}
d1999 2
a2000 1
	if (SEC_CUSTOM == sec)
d2002 1
d2046 1
@


1.125
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.124 2014/03/23 15:14:29 schwarze Exp $ */
d331 1
d2040 2
@


1.124
log
@Retire the old concat() function.
For .Sh, i wasn't even needed at all.
For .Dd, .Nm, and .Os, use the new mdoc_deroff() instead.
This gets rid of the last limited-size static buffers in this file,
hence eliminates the last explicit MANDOCERR_MEM throwers here,
and it shortens the code by 50 lines.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.123 2014/03/21 22:52:21 schwarze Exp $ */
d303 1
@


1.123
log
@avoid repetitive code for asprintf error handling
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.122 2014/03/21 22:17:01 schwarze Exp $ */
a44 1
#define	DATESIZE  32
a71 1
static	int	 concat(char *, const struct mdoc_node *, size_t);
a1119 2
	char		 buf[BUFSIZ];
	int		 c;
d1124 1
a1124 1
	/* Try to use our children for setting the meta name. */
d1126 1
a1126 11
	if (NULL != mdoc->last->child) {
		buf[0] = '\0';
		c = concat(buf, mdoc->last->child, BUFSIZ);
	} else
		c = 0;

	switch (c) {
	case (-1):
		mdoc_nmsg(mdoc, mdoc->last->child, MANDOCERR_MEM);
		return(0);
	case (0):
a1128 4
		break;
	default:
		mdoc->meta.name = mandoc_strdup(buf);
		break;
a1945 1
	char		 buf[BUFSIZ];
d1947 1
a1948 1
	int		 c;
d1957 1
d1959 9
a1967 6
	buf[0] = '\0';
	if (-1 == (c = concat(buf, mdoc->last->child, BUFSIZ))) {
		mdoc_nmsg(mdoc, mdoc->last->child, MANDOCERR_MEM);
		return(0);
	} else if (1 == c)
		sec = a2sec(buf);
d2041 1
a2041 1
				mdoc->last->line, mdoc->last->pos, buf);
a2161 1
	char		  buf[DATESIZE];
d2163 1
a2163 1
	int		  c;
d2175 8
a2182 4
	buf[0] = '\0';
	if (-1 == (c = concat(buf, n->child, DATESIZE))) {
		mdoc_nmsg(mdoc, n->child, MANDOCERR_MEM);
		return(0);
a2183 5

	assert(c);
	mdoc->meta.date = mdoc->quick ? mandoc_strdup(buf) :
	    mandoc_normdate(mdoc->parse, buf, n->line, n->pos);

a2332 1
	char		  buf[BUFSIZ];
a2337 1
	int		  c;
d2351 3
a2353 11

	buf[0] = '\0';
	if (-1 == (c = concat(buf, n->child, BUFSIZ))) {
		mdoc_nmsg(mdoc, n->child, MANDOCERR_MEM);
		return(0);
	}

	assert(c);

	if ('\0' != *buf) {
		mdoc->meta.os = mandoc_strdup(buf);
a2354 1
	}
a2402 23
	return(1);
}

/*
 * Concatenate a node, stopping at the first non-text.
 * Concatenation is separated by a single whitespace.  
 * Returns -1 on fatal (string overrun) error, 0 if child nodes were
 * encountered, 1 otherwise.
 */
static int
concat(char *p, const struct mdoc_node *n, size_t sz)
{

	for ( ; NULL != n; n = n->next) {
		if (MDOC_TEXT != n->type) 
			return(0);
		if ('\0' != p[0] && strlcat(p, " ", sz) >= sz)
			return(-1);
		if (strlcat(p, n->string, sz) >= sz)
			return(-1);
		concat(p, n->child, sz);
	}

@


1.122
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.121 2014/02/16 14:26:51 schwarze Exp $ */
d2396 3
a2398 5
                } else if (-1 == asprintf(&defbuf, "%s %s",
		    utsname.sysname, utsname.release)) {
			perror(NULL);
			exit((int)MANDOCLEVEL_SYSERR);
		}
@


1.121
log
@After Werner Lemberg accepted and committed some updates to the manual
page template contained in groff_mdoc(7), catch up with our own stuff.
In particular, allow ERRORS in section 4 and DIAGNOSTICS in section 9.
ok jmc@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.120 2014/01/11 22:16:03 schwarze Exp $ */
d35 1
@


1.120
log
@Remove useless use of strnlen(3).
Yuckiness pointed out by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.119 2014/01/07 09:10:58 schwarze Exp $ */
d2041 4
a2045 2
		/* FALLTHROUGH */
	case (SEC_ERRORS):
@


1.119
log
@Cache the result of uname(3) such that we don't need to call it
over and over again for each manual; found with gprof(1).
Speeds up mandocdb(8) -Q by 3%, now at 39.5% of makewhatis(8).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.118 2014/01/06 22:39:19 schwarze Exp $ */
d1893 1
a1893 1
		if (3 > strnlen(cp, 3))
@


1.118
log
@Another 18% speedup for mandocdb(8) -Q, found by gprof(1).
In -Q mode, refrain form validating and normalizing the format
of the date given in .Dd or .TH, as it won't be used anyway.

For /usr/share/man, mandocdb -Q now takes 45% of the time of makewhatis(8).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.117 2014/01/06 00:53:14 schwarze Exp $ */
a2346 1
	struct mdoc_node *n;
a2347 1
	int		  c;
d2350 1
d2352 2
d2376 10
a2385 5
	if ('\0' == buf[0]) {
		if (mdoc->defos) {
			mdoc->meta.os = mandoc_strdup(mdoc->defos);
			return(1);
		}
d2387 1
a2387 4
		if (strlcat(buf, OSNAME, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
		}
d2389 1
d2392 5
a2396 15
                        mdoc->meta.os = mandoc_strdup("UNKNOWN");
                        return(post_prol(mdoc));
                }

		if (strlcat(buf, utsname.sysname, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
		}
		if (strlcat(buf, " ", BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
		}
		if (strlcat(buf, utsname.release, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
d2398 2
a2400 3
	}

	mdoc->meta.os = mandoc_strdup(buf);
@


1.117
log
@Joerg Sonnenberger contributed copyrightable amounts of text to
some files.  To make it clear that he also put his contributions
under the ISC license, with his explicit permission, add his
Copyright notice to the relevant files.  No code change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.116 2013/12/15 21:18:00 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d2183 2
a2184 2
		mdoc->meta.date = mandoc_normdate
			(mdoc->parse, NULL, n->line, n->pos);
d2195 2
a2196 2
	mdoc->meta.date = mandoc_normdate
		(mdoc->parse, buf, n->line, n->pos);
@


1.116
log
@The "value" argument to the roff(7) .nr requests ends right before
the first non-digit character.  While here, implement and document
an optional sign, requesting increment or decrement, as documented
in the Ossanna/Kernighan/Ritter troff manual and supported by groff.

Reported by bentley@@ on discuss at mdocml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.115 2013/10/21 23:32:33 schwarze Exp $ */
d5 1
@


1.115
log
@There are three kinds of input lines: text lines, macros taking
positional arguments (like Dt Fn Xr) and macros taking text as
arguments (like Nd Sh Em %T An).  In the past, even the latter put
each word of their arguments into its own MDOC_TEXT node; instead,
concatenate arguments unless delimiters, keeps or spacing mode
prevent that.  Regarding mandoc(1), this is internal refactoring,
no output change intended.

Once we will switch mandocdb(8) from DB to SQLite in the future,
this is going to be required to support search expressions crossing
word boundaries, and it will reduce both database sizes and build
times by a bit more than 5% each.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.114 2013/10/06 22:45:13 schwarze Exp $ */
d1990 1
a1990 1
		roff_setreg(mdoc->roff, "nS", 1);
d1993 1
a1993 1
		roff_setreg(mdoc->roff, "nS", 0);
@


1.114
log
@We don't do hyphenation, but we allow breaking the line at hyphens that are
already there in the middle of words.  So far, we only allowed this on text
lines.  Now it turns out some macros allow this for their arguments, too,
in particular .Nd and most of the .%? citation macros.

Issue found by Franco Fichtner <franco at lastsummer dot de> while doing
systematic groff-mandoc comparisons in the DragonFly base system, THANKS!

While here, garbage collect two empty prevalidator function pointer lists
and sort a couple of function declarations.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.113 2013/10/06 13:27:47 schwarze Exp $ */
d1673 3
a1675 1
	if (0 == strcmp(mdoc->last->child->string, "on"))
d1677 4
a1680 1
	if (0 == strcmp(mdoc->last->child->string, "off"))
d1682 1
@


1.113
log
@If there is random stuff inside a .Bl block body before the first .It,
do not throw a FATAL error and do not die, but just throw a WARNING
and move the stuff out of the .Bl block.

This bug felt completely 2008-ish; meanwhile, such bugs from the
Kristaps-doesnt-like-syntax-errors-so-lets-just-give-up--Era
are becoming rare, but this was one of the last survivors.

Thanks to bentley@@ for reminding me to finally fix this.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.112 2013/10/03 19:32:25 schwarze Exp $ */
d18 1
a18 1
#ifndef        OSNAME
d96 1
a98 2
static	int	 post_defaults(POST_ARGS);
static	int	 post_literal(POST_ARGS);
d100 2
d104 1
a108 1
static	int	 post_ignpar(POST_ARGS);
d142 1
d147 2
d151 1
a151 1
static	v_post	 posts_nd[] = { berr_ge1, NULL };
d158 1
a158 1
static	v_post	 posts_sh[] = { post_ignpar, hwarn_ge1, post_sh, NULL };
d160 1
a160 1
static	v_post	 posts_ss[] = { post_ignpar, hwarn_ge1, NULL };
a165 1
static	v_post	 posts_wline[] = { bwarn_ge1, NULL };
a172 2
static	v_pre	 pres_er[] = { NULL, NULL };
static	v_pre	 pres_fd[] = { NULL, NULL };
d188 1
a188 1
	{ pres_d1, posts_wline },		/* D1 */
d201 1
a201 1
	{ pres_er, NULL },			/* Er */ 
d205 1
a205 1
	{ pres_fd, posts_text },		/* Fd */
d223 1
a223 1
	{ NULL, posts_text },			/* %B */ /* FIXME: can be used outside Rs/Re. */
d227 2
a228 2
	{ NULL, posts_text },			/* %N */
	{ NULL, posts_text },			/* %O */
d230 2
a231 2
	{ NULL, posts_text },			/* %R */
	{ NULL, posts_text },			/* %T */ /* FIXME: can be used outside Rs/Re. */
d271 1
a271 1
	{ NULL, NULL },				/* Sx */
d1853 41
@


1.112
log
@Support setting arbitrary roff(7) number registers,
preserving read support for the ".nr nS" SYNOPSIS state register;
read support for arbitrary registers is still not available.

Inspired by NetBSD roff.c rev. 1.18 (Christos Zoulas, March 21, 2013),
but implemented differently.  I don't want to have yet another different
implementation of a hash table in mandoc - it would be the second one
in roff.c alone and the fifth one in mandoc grand total.
Instead, i designed and implemented roff_setreg() and roff_getreg()
to be similar to roff_setstrn() and roff_getstrn().

Once we feel the need to optimize, we can introduce one common
hash table implementation for everything in mandoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.111 2013/09/16 00:25:06 schwarze Exp $ */
d1589 9
a1597 3
	struct mdoc_node	*n;

	if (MDOC_HEAD == mdoc->last->type) 
d1599 3
a1601 3
	if (MDOC_BLOCK == mdoc->last->type)
		return(post_bl_block(mdoc));
	if (MDOC_BODY != mdoc->last->type)
d1603 1
d1605 4
a1608 10
	for (n = mdoc->last->child; n; n = n->next) {
		switch (n->tok) {
		case (MDOC_Lp):
			/* FALLTHROUGH */
		case (MDOC_Pp):
			mdoc_nmsg(mdoc, n, MANDOCERR_CHILD);
			/* FALLTHROUGH */
		case (MDOC_It):
			/* FALLTHROUGH */
		case (MDOC_Sm):
a1609 2
		default:
			break;
d1612 42
a1653 2
		mdoc_nmsg(mdoc, n, MANDOCERR_SYNTCHILD);
		return(0);
@


1.111
log
@One of the WARNING messages has to use the word "section" twice in two
different meanings, that cannot be helped.  But we can make this less
confusing by stating that the second instance refers to stuff like (2),
(3), and (9), and by adding the sections header the first instance
refers to, for example ERRORS or RETURN VALUES.

Source for confusion noticed by Jan Stary <hans at stare dot cz>,
better wording suggested by jmc@@, tweaked by me.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.110 2013/08/05 14:32:56 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
a886 2

	roff_regunset(mdoc->roff, REG_nS);
d1902 2
a1903 1
	if (SEC_SYNOPSIS == sec)
d1905 2
a1906 1
	else
d1908 1
@


1.110
log
@Put .%C before .%D in .Rs output
because that's the usual order in formal citations.

My patch that was accepted into groff by Werner Lemberg
uses the same order, so keep groff and mandoc consistent.

Committing now because jmc@@ already starts to rely on the .%C macro,
see for example /usr/src/usr.bin/bdes/bdes.1 rev. 1.11.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.109 2012/11/17 00:25:20 schwarze Exp $ */
d1963 2
a1964 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECMSEC);
@


1.109
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.108 2012/11/16 22:20:40 schwarze Exp $ */
d318 1
d320 1
a320 2
	MDOC__O,
	MDOC__C
@


1.108
log
@Warn about unknown volume or arch in Dt macro arguments;
patch written by Nicolas Joly <njoly at pasteur dot fr>.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.107 2012/07/18 11:09:30 schwarze Exp $ */
d415 1
a415 1
check_count(struct mdoc *m, enum mdoc_type type, 
d421 1
a421 1
	if (m->last->type != type)
d427 1
a427 1
		if (m->last->nchild < val)
d432 1
a432 1
		if (m->last->nchild > val)
d437 1
a437 1
		if (val == m->last->nchild)
d446 1
a446 1
	mandoc_vmsg(t, m->parse, m->last->line, m->last->pos,
d448 1
a448 1
			p, val, m->last->nchild);
d514 1
a514 1
check_args(struct mdoc *m, struct mdoc_node *n)
d523 1
a523 1
		check_argv(m, n, &n->args->argv[i]);
d527 1
a527 1
check_argv(struct mdoc *m, struct mdoc_node *n, struct mdoc_argv *v)
d532 1
a532 1
		check_text(m, v->line, v->pos, v->value[i]);
d537 2
a538 2
		if ( ! (v->sz || m->meta.name))
			mdoc_nmsg(m, n, MANDOCERR_NONAME);
d542 1
a542 1
check_text(struct mdoc *m, int ln, int pos, char *p)
d546 1
a546 1
	if (MDOC_LITERAL & m->flags)
d550 1
a550 1
		mdoc_pmsg(m, ln, pos + (int)(p - cp), MANDOCERR_BADTAB);
@


1.107
log
@Fix handling of paragraph macros inside lists:
* When they are trailing the last item, move them outside the list.
* When they are trailing any other none-compact item, drop them.

Improves formatting of 40 pages, e.g. grep(1), ksh(1), netstat(1),
ath(4), bsd.port.mk(5), pf.conf(5), mount(8), crypto(9).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.106 2012/07/16 09:51:03 schwarze Exp $ */
a2203 1
		/* FIXME: warn about bad arch. */
d2206 1
@


1.106
log
@Several -mdoc parser improvements related to vertical spacing:
* So far, .Pp and .Lp were removed before paragraph type blocks.
* Now also remove .br before paragraph type blocks.
* Treat .Lp as a paragraph like .Pp, so remove .Pp, .Lp, .br before it.
* Do not treat .sp as a paragraph, don't remove anything before it.
* After .Sh, .Ss, .Pp, and .Lp, remove .Pp, .Lp, .sp, .br, and blank lines.
* After .sp and .br, remove .br.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.105 2012/07/12 15:09:50 schwarze Exp $ */
d1352 1
a1352 1
	struct mdoc_node *n;
d1368 1
d1372 2
a1373 2
	} else 
		return(1);
d1375 29
a1403 1
	assert(n->norm->Bl.width);
@


1.105
log
@The post_nm() validation function crashed when the first .Nm child node
was a non-text node.  Fix this by rewriting post_nm() to always set
the meta name to UNKNOWN when the name is missing or unusable.
While here, make MANDOCERR_NONAME an ERROR, as it usually renders
the page content unintelligible.

Bug reported by Maxim <Belooussov at gmail dot com>, thanks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.104 2012/07/11 16:55:29 schwarze Exp $ */
d106 1
d152 1
d155 1
a155 1
static	v_post	 posts_sp[] = { ewarn_le1, NULL };
d186 1
a186 1
	{ pres_pp, posts_notext },		/* Pp */ 
d287 1
a287 1
	{ NULL, posts_notext },			/* Lp */ 
d298 2
a299 2
	{ NULL, posts_notext },			/* br */
	{ pres_pp, posts_sp },			/* sp */
d1980 3
a1982 1
	if (MDOC_Pp != mdoc->last->tok && MDOC_Lp != mdoc->last->tok)
d1990 26
@


1.104
log
@fix position and formatting of %U
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.103 2012/07/10 14:35:57 schwarze Exp $ */
d1122 2
a1123 1
	/* If no child specified, make sure we have the meta name. */
d1125 1
a1125 5
	if (NULL == mdoc->last->child && NULL == mdoc->meta.name) {
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NONAME);
		return(1);
	} else if (mdoc->meta.name)
		return(1);
d1127 5
a1131 1
	/* If no meta name, set it from the child. */
d1133 2
a1134 2
	buf[0] = '\0';
	if (-1 == (c = concat(buf, mdoc->last->child, BUFSIZ))) {
d1137 7
a1144 3

	assert(c);
	mdoc->meta.name = mandoc_strdup(buf);
@


1.103
log
@* implement -Tman .Bl -item -inset -diag -ohang -dash -hyphen -enum .It
* fix -Tman .Bl -bullet .It
* adjust the -Tascii .Bl -bullet -dash -hyphen .It
default and minimum width to new groff standards,
it changed from 4n (in groff 1.15) to 2n (in groff 1.21)
* same for -Tascii -enum, it changed from 5n to 2n
* use -hang formatting for -Tascii -enum -width 2n
* for -Tascii -enum, the default is -width 3n
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.102 2012/05/24 23:33:23 schwarze Exp $ */
d313 1
d318 1
a318 2
	MDOC__C,
	MDOC__U
@


1.102
log
@Support -Ios='OpenBSD 5.1' to override uname(3) as the source of the
default value for the mdoc(7) .Os macro.
Needed for man.cgi on the OpenBSD website.

Problem with man.cgi first noticed by deraadt@@;
beck@@ and deraadt@@ agree with the way to solve the issue.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.101 2012/04/15 10:31:00 schwarze Exp $ */
d732 2
a733 1
	 * and must also be warned.
d738 2
a739 3
		if (n->norm->Bl.width)
			break;
		mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG);
d752 12
@


1.101
log
@Two bugfixes regarding the -width and -offset macro arguments:
1) They consume the next argument even if it starts with a dash.
2) When -width is the last argument on the line such that the
actual width argument is missing, downgrade from a fatal to a
non-fatal error, just like for -offset.  The formatting still
doesn't agree with groff, but at least we don't die any longer.

Item 2 was observed and that part of the patch coded by kristaps@@,
who found lots of instances of this particular formatting error
in Mac OSX manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.100 2011/12/03 22:47:27 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
d2191 6
a2196 4
	 * Set the operating system by way of the `Os' macro.  Note that
	 * if an argument isn't provided and -DOSNAME="\"foo\"" is
	 * provided during compilation, this value will be used instead
	 * of filling in "sysname release" from uname().
d2199 1
a2199 2
	if (mdoc->meta.os)
		free(mdoc->meta.os);
a2208 4
	/* XXX: yes, these can all be dynamically-adjusted buffers, but
	 * it's really not worth the extra hackery.
	 */

d2210 4
@


1.100
log
@remove useless "#ifdef __linux__" that crept in,
and trivial sync to bsd.lv (two new comments)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.99 2011/12/02 01:45:43 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d660 7
a666 2
			dup = (NULL != n->norm->Bl.width);
			width = n->args->argv[i].value[0];
@


1.99
log
@In man(7), when no explicit volume name is given, use the default
volume name for the respective manual section, just like in mdoc(7).
This gives us nicer page headers for cvs(1), lynx(1), tic(1),
mkhybrid(8), and many curses(3) manuals.

ok kristaps@@

To not break compatibility, i wrote a corresponding patch for GNU troff
which Werner Lemberg accepted upstream at rev. 1.65 of:
http://cvs.savannah.gnu.org/viewvc/groff/tmac/an-old.tmac?root=groff
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.98 2011/11/19 13:17:44 schwarze Exp $ */
d1859 10
@


1.98
log
@Avoid a NULL pointer access if an .Rs block body contains nothing
but invalid nodes.  Output still differs a lot from groff, but at
least let's not crash.
Problem found and patch provided by joerg@@, thanks!
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.97 2011/11/16 19:47:58 schwarze Exp $ */
d2088 1
a2088 1
	cp = mdoc_a2msec(nn->string);
@


1.97
log
@When processing .Sh HEAD, as soon as we know which section this is,
fix up the section attributes of the HEAD, it's parent BLOCK, and
all its (text) children.  This is required because the section
attributes get set when each node is allocated, i.e. before processing
the content of the node itself.  Thus, the listed nodes got the section
attribute of the preceding section.  No need to fix up the BODY, all
is fine there already.
Found while implementing TYPE_Sh for mandocdb(8).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.96 2011/10/16 12:18:32 schwarze Exp $ */
d1691 8
@


1.96
log
@Remove a bunch of useless assignments,
and assert that print_bvspace cannot be called on NULL pointers.
No change in behaviour, none of these were bugs,
but the code becomes easier to understand.
Based on a clang report posted by joerg@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.95 2011/09/18 15:54:48 schwarze Exp $ */
d1817 1
d1851 4
@


1.95
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.94 2011/09/18 10:25:28 schwarze Exp $ */
d544 4
a547 4
	cp = p;
	for (cp = p; NULL != (p = strchr(p, '\t')); p++) {
		if (MDOC_LITERAL & m->flags)
			continue;
a548 1
	}
@


1.94
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.93 2011/05/29 21:22:18 schwarze Exp $ */
d71 1
a71 3

static	int	 concat(struct mdoc *, char *, 
			const struct mdoc_node *, size_t);
d542 1
a542 8
	char		*cpp, *pp;
	size_t		 sz;

	while ('\0' != *p) {
		sz = strcspn(p, "\t\\");

		p += (int)sz;
		pos += (int)sz;
d544 3
a546 5
		if ('\t' == *p) {
			if ( ! (MDOC_LITERAL & m->flags))
				mdoc_pmsg(m, ln, pos, MANDOCERR_BADTAB);
			p++;
			pos++;
d548 1
a548 18
		} else if ('\0' == *p)
			break;

		pos++;
		pp = ++p;

		if (ESCAPE_ERROR == mandoc_escape
				((const char **)&pp, NULL, NULL)) {
			mdoc_pmsg(m, ln, pos, MANDOCERR_BADESCAPE);
			break;
		}

		cpp = p;
		while (NULL != (cpp = memchr(cpp, ASCII_HYPH, pp - cpp)))
			*cpp = '-';

		pos += pp - p;
		p = pp;
d702 1
a702 1
				n->norm->Bl.cols = (const char **)
d1104 1
d1116 3
a1118 1
	if ( ! concat(mdoc, buf, mdoc->last->child, BUFSIZ))
d1120 1
d1122 1
a1123 1

d1394 1
a1394 1
	snprintf(buf, NUMSIZ, "%zun", width);
d1444 1
a1444 1
	snprintf(buf, NUMSIZ, "%zun", sz);
d1520 1
a1520 1
	mdoc->last->norm->Bl.cols = (const char **)np->args->argv[j].value;
d1819 1
d1828 4
a1831 1
	if ( ! concat(mdoc, buf, mdoc->last->child, BUFSIZ))
d1833 2
a1834 2

	sec = a2sec(buf);
d1983 1
d1995 3
a1997 1
	if ( ! concat(mdoc, buf, n->child, DATESIZE))
d1999 1
d2001 1
d2030 1
a2030 1
			if (toupper((u_char)*p) == *p)
d2156 1
d2173 3
a2175 1
	if ( ! concat(mdoc, buf, n->child, BUFSIZ))
d2177 3
d2246 6
d2253 1
a2253 1
concat(struct mdoc *m, char *p, const struct mdoc_node *n, size_t sz)
d2256 2
a2257 14
	p[0] = '\0';

	/*
	 * Concatenate sibling nodes together.  All siblings must be of
	 * type MDOC_TEXT or an assertion is raised.  Concatenation is
	 * separated by a single whitespace.  Returns 0 on fatal (string
	 * overrun) error.
	 */

	for ( ; n; n = n->next) {
		assert(MDOC_TEXT == n->type);

		if (strlcat(p, n->string, sz) >= sz) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
d2259 5
a2263 9
		}

		if (NULL == n->next)
			continue;

		if (strlcat(p, " ", sz) >= sz) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
@


1.93
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.92 2011/04/24 16:22:02 schwarze Exp $ */
d898 1
a898 1
	mdoc->regs->regs[(int)REG_nS].set = 0;
@


1.92
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.91 2011/04/21 22:59:54 schwarze Exp $ */
d179 1
a179 1
static const struct valids mdoc_valids[MDOC_MAX] = {
d544 1
a544 1
	int		 c;
d547 1
a547 1
	for ( ; *p; p++, pos++) {
d549 1
a550 4

		if ('\0' == *p)
			break;

d556 2
d559 5
a563 1
		}
d565 2
a566 1
		if (0 == (c = mandoc_special(p))) {
d568 1
a568 1
			continue;
d571 6
a576 2
		p += c - 1;
		pos += c - 1;
d1534 1
a1534 1
	 * Accomodate for new-style groff column syntax.  Shuffle the
@


1.91
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.90 2011/03/20 23:36:42 schwarze Exp $ */
d32 1
d154 1
a154 1
static	v_post	 posts_sh[] = { post_ignpar, hwarn_ge1, bwarn_ge1, post_sh, NULL };
d156 1
a156 1
static	v_post	 posts_ss[] = { post_ignpar, hwarn_ge1, bwarn_ge1, NULL };
d446 1
a446 1
	mdoc_vmsg(m, t, m->last->line, m->last->pos,
d581 3
a583 4
	mdoc_vmsg(mdoc, MANDOCERR_SYNTCHILD,
				n->line, n->pos, "want parent %s",
				MDOC_ROOT == t ? "<root>" : 
					mdoc_macronames[tok]);
d1331 2
a1332 1
		mdoc_vmsg(mdoc, er, mdoc->last->line, mdoc->last->pos, 
d2001 2
a2002 2
		mdoc->meta.date = mandoc_normdate(NULL,
		    mdoc->msg, mdoc->data, n->line, n->pos);
d2009 2
a2010 2
	mdoc->meta.date = mandoc_normdate(buf,
	    mdoc->msg, mdoc->data, n->line, n->pos);
d2193 1
a2193 1
		if (uname(&utsname)) {
@


1.90
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.89 2011/03/07 01:35:33 schwarze Exp $ */
d73 2
d178 1
a178 1
const	struct valids mdoc_valids[MDOC_MAX] = {
d322 24
d445 1
a445 2

	return(mdoc_vmsg(m, t, m->last->line, m->last->pos,
d447 2
a448 1
			p, val, m->last->nchild));
d1265 1
a1265 1
	int		  i, cols, rc;
d1331 1
a1331 2
		rc = mdoc_vmsg(mdoc, er, 
				mdoc->last->line, mdoc->last->pos, 
d1333 1
a1333 1
		return(rc);
d1394 1
a1394 1
	else if (0 == (width = mdoc_macro2len(tok)))  {
d1451 1
a1451 1
		if (0 != (ssz = mdoc_macro2len(nn->tok)))
d1845 1
a1845 1
	sec = mdoc_str2sec(buf);
d2151 2
a2152 1
		*n->string = toupper((unsigned char)*n->string);
d2279 104
@


1.89
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.88 2011/02/06 17:33:21 schwarze Exp $ */
d337 2
d367 2
@


1.88
log
@If .Ns is specified on its own line, ignore it, like groff does;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.87 2011/01/30 18:28:01 schwarze Exp $ */
d4 1
d139 1
a139 1
static	v_post	 posts_dd[] = { ewarn_ge1, post_dd, post_prol, NULL };
d220 1
a220 1
	{ NULL, posts_text },			/* %D */ /* FIXME: check date with mandoc_a2time(). */
d914 1
a914 1
	if (0 == mdoc->meta.date || mdoc->meta.os)
d927 1
a927 1
	if (NULL == mdoc->meta.title || 0 == mdoc->meta.date)
d1966 3
d1970 3
a1972 3

	if (NULL == n->child) {
		mdoc->meta.date = time(NULL);
d1979 2
a1980 7
	mdoc->meta.date = mandoc_a2time
		(MTIME_MDOCDATE | MTIME_CANONICAL, buf);

	if (0 == mdoc->meta.date) {
		mdoc_nmsg(mdoc, n, MANDOCERR_BADDATE);
		mdoc->meta.date = time(NULL);
	}
@


1.87
log
@Make .Bx accept not more than two arguments.
Convert the first character of the second argument to uppercase.
Append the second argument with a hyphen.
Improves chpass(1), column(1), fstat(1), ...
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.86 2011/01/30 17:41:59 schwarze Exp $ */
d102 1
d147 1
d249 1
a249 1
	{ NULL, posts_notext },			/* Ns */
d1740 9
@


1.86
log
@Like in groff, if .%B is specified, quote .%T; from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.85 2011/01/22 13:55:50 schwarze Exp $ */
d93 1
d133 1
d235 1
a235 1
	{ NULL, NULL },				/* Bx */
d2095 18
@


1.85
log
@Check argument count validation for all in_line() macros.
Most empty in_line() macros are already removed by the parser,
so there is no need to check again in mdoc_validate.c.
This also downgrades almost all remaining argument count issues
from ERROR to WARNING.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.84 2011/01/04 22:28:17 schwarze Exp $ */
d1663 2
a1664 2
			if (MDOC__J == rsord[i])
				mdoc->last->norm->Rs.child_J = nn;
@


1.84
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.83 2011/01/03 23:39:27 schwarze Exp $ */
a75 1
static	int	 eerr_ge1(POST_ARGS);
d151 1
a151 1
static	v_post	 posts_text[] = { eerr_ge1, NULL };
a154 1
static	v_post	 posts_wtext[] = { ewarn_ge1, NULL };
d186 1
a186 1
	{ NULL, posts_text },			/* Ad */ 
d189 1
a189 1
	{ NULL, posts_text },			/* Cd */ 
d192 1
a192 1
	{ pres_er, posts_text },		/* Er */ 
d196 1
a196 1
	{ pres_fd, posts_wtext },		/* Fd */
d198 3
a200 3
	{ NULL, posts_text },			/* Fn */ 
	{ NULL, posts_wtext },			/* Ft */ 
	{ NULL, posts_text },			/* Ic */ 
d212 1
a212 1
	{ NULL, posts_wtext },			/* Xr */ 
d243 1
a243 1
	{ NULL, posts_text },			/* Ms */ 
d262 3
a264 3
	{ NULL, posts_text },			/* Sx */
	{ NULL, posts_text },			/* Sy */
	{ NULL, posts_text },			/* Tn */
d280 1
a280 1
	{ NULL, posts_text },			/* Lk */ 
a429 6
eerr_ge1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_ELEM, CHECK_ERROR, CHECK_GT, 0));
}

static int
d1069 2
a1070 1
	 * behaviour).  ELEM types must have a child; BLOCK types,
a1073 2
	if (MDOC_ELEM == mdoc->last->type)
		return(eerr_ge1(mdoc));
d1217 4
a1220 1
	if (AUTH__NONE != np->norm->An.auth && np->child) {
a1221 9
		return(1);
	}

	/* 
	 * FIXME: make this ewarn and make sure that the front-ends
	 * don't print the arguments.
	 */
	if (AUTH__NONE != np->norm->An.auth || np->child)
		return(1);
a1222 1
	mdoc_nmsg(mdoc, np, MANDOCERR_NOARGS);
@


1.83
log
@Partial cleanup of argument count validation in mdoc(7):

* Do not segfault on empty .Db, .Rs, .Sm, and .St.
* Let check_count() really throw the requested level, not always ERROR.
* Downgrade most bad argument counts from ERROR to WARNING.
* And some related internal cleanup.

Looks fine to kristaps@@.

Note that the macros using eerr_ge1() still need to be checked at a later
time; but as all the others are done, let's use what we already have.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.82 2010/12/29 00:47:31 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
a34 4
#include "out.h"
#include "term.h"
#include "tbl.h"

a125 1
static	int	 pre_ts(PRE_ARGS);
a171 1
static	v_pre	 pres_ts[] = { pre_ts, NULL };
a295 2
	{ pres_ts, NULL },			/* TS */
	{ NULL, NULL },				/* TE */
d325 2
a326 1
	if (MDOC_TEXT == n->type) {
d331 4
d336 2
d360 4
a363 1
	if (MDOC_TEXT == mdoc->last->type)
d365 1
a365 1
	if (MDOC_ROOT == mdoc->last->type)
d367 3
a1899 10

	return(1);
}

static int
pre_ts(PRE_ARGS)
{

	if (MDOC_BLOCK == mdoc->last->type)
		mdoc->last->norm->TS = tbl_alloc();
@


1.82
log
@Reorg by Kristaps:  In libmdoc, replace the union of pointers to structs
of macro-specific data by a pointer to a union of structs, which makes the
code simpler and more robust at the expense of a small memory overhead.
Merging was somewhat difficult because we mustn't break tbl(1) support
which the bsd.lv version does not yet have.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.81 2010/12/26 21:04:19 schwarze Exp $ */
a55 1
	CHECK_FATAL
a79 2
static	int	 eerr_eq0(POST_ARGS);
static	int	 eerr_eq1(POST_ARGS);
a80 1
static	int	 eerr_le1(POST_ARGS);
d82 1
d84 1
a84 2
static	int	 herr_eq0(POST_ARGS);
static	int	 herr_ge1(POST_ARGS);
d87 1
d138 1
a138 1
static	v_post	 posts_bool[] = { eerr_eq1, ebool, NULL };
d142 1
a142 1
static	v_post	 posts_dl[] = { post_literal, bwarn_ge1, herr_eq0, NULL };
d146 1
a146 1
static	v_post	 posts_lb[] = { eerr_eq1, post_lb, NULL };
d151 5
a155 5
static	v_post	 posts_rs[] = { berr_ge1, herr_eq0, post_rs, NULL };
static	v_post	 posts_sh[] = { post_ignpar, herr_ge1, bwarn_ge1, post_sh, NULL };
static	v_post	 posts_sp[] = { eerr_le1, NULL };
static	v_post	 posts_ss[] = { post_ignpar, herr_ge1, bwarn_ge1, NULL };
static	v_post	 posts_st[] = { eerr_eq1, post_st, NULL };
d158 1
a158 1
static	v_post	 posts_text1[] = { eerr_eq1, NULL };
d160 1
a160 1
static	v_post	 posts_wline[] = { bwarn_ge1, herr_eq0, NULL };
d380 1
d392 1
a392 1
		p = "greater than ";
d406 1
a406 6
	if (CHECK_WARN == lvl) {
		return(mdoc_vmsg(m, MANDOCERR_ARGCOUNT,
				m->last->line, m->last->pos,
				"want %s%d children (have %d)",
				p, val, m->last->nchild));
	}
d408 2
a409 5
	/* FIXME: THIS IS THE SAME AS THE ABOVE. */

	return(mdoc_vmsg(m, MANDOCERR_ARGCOUNT,
			m->last->line, m->last->pos,
			"require %s%d children (have %d)",
d417 1
a417 1
	return(check_count(mdoc, MDOC_BODY, CHECK_FATAL, CHECK_GT, 0));
a426 12
eerr_eq0(POST_ARGS)
{
	return(check_count(mdoc, MDOC_ELEM, CHECK_FATAL, CHECK_EQ, 0));
}

static int
eerr_eq1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_ELEM, CHECK_FATAL, CHECK_EQ, 1));
}

static int
d429 1
a429 1
	return(check_count(mdoc, MDOC_ELEM, CHECK_FATAL, CHECK_GT, 0));
d433 1
a433 1
eerr_le1(POST_ARGS)
d435 1
a435 1
	return(check_count(mdoc, MDOC_ELEM, CHECK_FATAL, CHECK_LT, 2));
d439 1
a439 1
ewarn_eq0(POST_ARGS)
d441 1
a441 1
	return(check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 0));
d451 1
a451 1
herr_eq0(POST_ARGS)
d453 1
a453 1
	return(check_count(mdoc, MDOC_HEAD, CHECK_FATAL, CHECK_EQ, 0));
d457 1
a457 1
herr_ge1(POST_ARGS)
d459 1
a459 1
	return(check_count(mdoc, MDOC_HEAD, CHECK_FATAL, CHECK_GT, 0));
d463 1
a463 1
hwarn_eq0(POST_ARGS)
d465 1
a465 1
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 0));
d469 1
a469 1
hwarn_eq1(POST_ARGS)
d471 1
a471 1
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 1));
d1027 2
d1221 4
a1224 2
	if (AUTH__NONE != np->norm->An.auth && np->child)
		return(eerr_eq0(mdoc));
d1566 3
a1568 1
	if (NULL == mdoc->last->child)
d1570 2
d1620 2
a1621 1
	const char	*p;
d1623 5
a1627 1
	assert(MDOC_TEXT == mdoc->last->child->type);
d1629 1
a1629 1
	p = mdoc_a2st(mdoc->last->child->string);
d1631 1
a1631 1
	if (p == NULL) {
d1635 2
a1636 2
		free(mdoc->last->child->string);
		mdoc->last->child->string = mandoc_strdup(p);
d1648 10
a1657 1
	if (MDOC_BODY != mdoc->last->type)
d1659 1
@


1.81
log
@Behave more like groff (both old and new): Specifying both .%T and .%J in
an .Rs block causes the title to be quoted instead of underlined, such
that journal title and article title appear visually different.
Original diff from kristaps@@, simplified by me, tweaked again by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.80 2010/12/21 23:57:31 schwarze Exp $ */
a129 1
static	int	 pre_rs(PRE_ARGS);
a176 1
static	v_pre	 pres_rs[] = { pre_rs, NULL };
d268 1
a268 1
	{ pres_rs, posts_rs },			/* Rs */
a615 2
		assert(np->data.Bl);
		n->data.Bl = np->data.Bl;
a624 3
	assert(NULL == n->data.Bl);
	n->data.Bl = mandoc_calloc(1, sizeof(struct mdoc_bl));

d667 1
a667 1
			dup = n->data.Bl->comp;
d671 1
a671 1
			dup = (NULL != n->data.Bl->width);
d678 1
a678 1
				dup = (NULL != n->data.Bl->offs);
d693 1
a693 1
			n->data.Bl->comp = comp;
d695 1
a695 1
			n->data.Bl->offs = offs;
d697 1
a697 1
			n->data.Bl->width = width;
d701 1
a701 1
		if (LIST__NONE != lt && n->data.Bl->type != LIST__NONE)
d706 2
a707 2
		if (LIST__NONE != lt && n->data.Bl->type == LIST__NONE) {
			n->data.Bl->type = lt;
d710 1
a710 1
				n->data.Bl->ncols = 
d712 1
a712 1
				n->data.Bl->cols = (const char **)
d719 4
a722 4
		if (n->data.Bl->type == LIST__NONE)
			if (n->data.Bl->width || 
					n->data.Bl->offs || 
					n->data.Bl->comp)
d730 1
a730 1
	if (LIST__NONE == n->data.Bl->type) {
d732 1
a732 1
		n->data.Bl->type = LIST_item;
d741 1
a741 1
	switch (n->data.Bl->type) {
d743 1
a743 1
		if (n->data.Bl->width)
d756 1
a756 1
		if (n->data.Bl->width)
a784 2
		assert(np->data.Bd);
		n->data.Bd = np->data.Bd;
a787 3
	assert(NULL == n->data.Bd);
	n->data.Bd = mandoc_calloc(1, sizeof(struct mdoc_bd));

d817 1
a817 1
				dup = (NULL != n->data.Bd->offs);
d824 1
a824 1
			dup = n->data.Bd->comp;
d839 1
a839 1
			n->data.Bd->offs = offs;
d841 1
a841 1
			n->data.Bd->comp = comp;
d845 1
a845 1
		if (DISP__NONE != dt && n->data.Bd->type != DISP__NONE)
d850 2
a851 2
		if (DISP__NONE != dt && n->data.Bd->type == DISP__NONE)
			n->data.Bd->type = dt;
d854 1
a854 1
	if (DISP__NONE == n->data.Bd->type) {
d856 1
a856 1
		n->data.Bd->type = DISP_ragged;
a900 3
	assert(NULL == n->data.An);
	n->data.An = mandoc_calloc(1, sizeof(struct mdoc_an));

d909 1
a909 1
		n->data.An->auth = AUTH_split;
d911 1
a911 1
		n->data.An->auth = AUTH_nosplit;
a968 10
static int
pre_rs(PRE_ARGS)
{

	assert(NULL == n->data.Rs);
	n->data.Rs = mandoc_calloc(1, sizeof(struct mdoc_rs));

	return(1);
}

a992 2
		assert(np->data.Bf);
		mdoc->last->data.Bf = np->data.Bf;
a998 1
	np->data.Bf = mandoc_calloc(1, sizeof(struct mdoc_bf));
d1018 1
a1018 1
			np->data.Bf->font = FONT_Em;
d1020 1
a1020 1
			np->data.Bf->font = FONT_Li;
d1022 1
a1022 1
			np->data.Bf->font = FONT_Sy;
d1031 1
a1031 1
		np->data.Bf->font = FONT_Em;
d1033 1
a1033 1
		np->data.Bf->font = FONT_Li;
d1035 1
a1035 1
		np->data.Bf->font = FONT_Sy;
d1241 1
a1241 1
	if (AUTH__NONE != np->data.An->auth && np->child)
d1248 1
a1248 1
	if (AUTH__NONE != np->data.An->auth || np->child)
d1268 1
a1268 2
	assert(n->data.Bl);
	lt = n->data.Bl->type;
d1307 1
a1307 1
		cols = (int)n->data.Bl->ncols;
d1351 2
a1352 2
	if (LIST_tag == n->data.Bl->type && 
			NULL == n->data.Bl->width) {
d1355 1
a1355 1
	} else if (NULL != n->data.Bl->width) {
d1361 1
a1361 1
	assert(n->data.Bl->width);
d1385 1
a1385 1
	if (0 == strcmp(n->data.Bl->width, "Ds"))
d1387 1
a1387 1
	else if (MDOC_MAX == (tok = mdoc_hash_find(n->data.Bl->width)))
d1409 1
a1409 1
	n->data.Bl->width = n->args->argv[i].value[0];
d1475 1
a1475 1
	n->data.Bl->width = n->args->argv[i].value[0];
d1486 1
a1486 1
	if (LIST_column != mdoc->last->data.Bl->type)
d1503 1
a1503 1
	if (mdoc->last->data.Bl->ncols && mdoc->last->nchild) {
d1529 2
a1530 2
	mdoc->last->data.Bl->ncols = np->args->argv[j].sz;
	mdoc->last->data.Bl->cols = (const char **)np->args->argv[j].value;
d1674 1
a1674 1
				mdoc->last->parent->data.Rs->child_J = nn;
a1691 1

d1903 1
a1903 1
		mdoc->last->data.TS = tbl_alloc();
d1924 1
a1924 1
	if (MDOC_Bl == n->tok && n->data.Bl->comp)
d1926 1
a1926 1
	if (MDOC_Bd == n->tok && n->data.Bd->comp)
d1928 1
a1928 1
	if (MDOC_It == n->tok && n->parent->data.Bl->comp)
d1953 1
a1953 2
		assert(n->data.Bd);
		if (DISP_literal == n->data.Bd->type)
d1955 1
a1955 1
		if (DISP_unfilled == n->data.Bd->type)
@


1.80
log
@Migrate .An to use a pointer to its data, like everybody else.
In preparation for a simpler ref-counted system for node data.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.79 2010/12/21 23:46:18 schwarze Exp $ */
d130 1
d178 1
d270 1
a270 1
	{ NULL, posts_rs },			/* Rs */
d984 10
d1702 2
d1721 1
@


1.79
log
@Vertical spacing improvements from kristaps@@, small tweaks by me:
Add a "last child" member to struct mdoc_node.
Remove .Pp or .Lp if it is the first or last child of an .Sh or .Ss body.
Thus, no need to do the same in the front-ends any longer.
Tolerate some cases of .Pp inside .Bl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.78 2010/12/09 21:29:17 schwarze Exp $ */
d911 3
d922 1
a922 1
		n->data.An.auth = AUTH_split;
d924 1
a924 1
		n->data.An.auth = AUTH_nosplit;
d1257 1
a1257 1
	if (AUTH__NONE != np->data.An.auth && np->child)
d1264 1
a1264 1
	if (AUTH__NONE != np->data.An.auth || np->child)
@


1.78
log
@Allow quote macros (`Op', `Aq', `Bq', `Dq', `Pq', `Ql', `Qq', `Sq', and
`Brq') to have zero arguments without warning.  This makes sense because
the multi-line quote macros (`Oo/Oc' etc.) allow zero children anyway.
Furthermore, the documentation doesn't state that they're required to
have children.

Reported by Alex Kozlov, patch from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.77 2010/12/07 00:08:52 schwarze Exp $ */
d110 1
d155 1
a155 1
static	v_post	 posts_sh[] = { herr_ge1, bwarn_ge1, post_sh, NULL };
d157 1
a157 1
static	v_post	 posts_ss[] = { herr_ge1, NULL };
d174 1
a174 1
static	v_pre	 pres_it[] = { pre_it, NULL };
a901 4
	/* 
	 * FIXME: this can probably be lifted if we make the It into
	 * something else on-the-fly?
	 */
a1570 2
	if (NULL == mdoc->last->child)
		return(1);
a1571 7
	/*
	 * We only allow certain children of `Bl'.  This is usually on
	 * `It', but apparently `Sm' occurs here and there, so we let
	 * that one through, too.
	 */

	/* LINTED */
d1573 9
a1581 3
		if (MDOC_BLOCK == n->type && MDOC_It == n->tok)
			continue;
		if (MDOC_Sm == n->tok)
d1583 4
d1888 23
d1926 2
a1935 1

d1939 2
@


1.77
log
@Complete the merge of bsd.lv version 1.10.7:
No more functional changes, just sync ordering, comments and white space.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.76 2010/12/01 22:02:29 schwarze Exp $ */
d215 1
a215 1
	{ NULL, posts_wline },			/* Op */
d236 1
a236 1
	{ NULL, posts_wline },			/* Aq */
d241 1
a241 1
	{ NULL, posts_wline },			/* Bq */
d247 1
a247 1
	{ NULL, posts_wline },			/* Dq */
d261 1
a261 1
	{ NULL, posts_wline },			/* Pq */
d263 1
a263 1
	{ NULL, posts_wline },			/* Ql */
d265 1
a265 1
	{ NULL, posts_wline },			/* Qq */
d270 1
a270 1
	{ NULL, posts_wline },			/* Sq */
d292 1
a292 1
	{ NULL, posts_wline },			/* Brq */ 
@


1.76
log
@Merge mdoc_action.c into mdoc_validate.c, because having two places to do
basically the same things just causes code duplication and confusion.
Work by kristaps@@, including a few bugfixes he found during the merge,
and reapplying OpenBSD changes on top.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.75 2010/10/26 22:48:07 schwarze Exp $ */
d2124 2
a2125 1
	free(mdoc->meta.os);
a2193 1

@


1.75
log
@Downgrade nearly 20 ERRORS to WARNINGS.
All these indicate problems in the mdoc(7) or man(7) source code,
but they can't cause relevant information loss or clobbered formatting.
While here, error message improve wording and make it more uniform,
don't throw MANDOCERR_NOWIDTHARG twice when there is one single issue,
and consolidate MANDOCERR_WIDTHARG into MANDOCERR_IGNARGV.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.74 2010/10/24 18:15:43 schwarze Exp $ */
d17 4
d29 1
d35 4
d44 3
d70 2
a71 3
static	int	 check_stdarg(PRE_ARGS);
static	int	 check_text(struct mdoc *, int, int, char *);
static	int	 check_argv(struct mdoc *, 
d73 4
a76 1
static	int	 check_args(struct mdoc *, struct mdoc_node *);
d97 3
d101 1
d103 3
d109 2
d117 1
a117 1
static	int	 post_eoln(POST_ARGS);
d126 1
d128 1
a128 2
static	int	 pre_pp(PRE_ARGS);
static	int	 pre_rv(PRE_ARGS);
d131 2
d135 2
a136 2
static	v_post	 posts_at[] = { post_at, NULL };
static	v_post	 posts_bd_bk[] = { hwarn_eq0, bwarn_ge1, NULL };
d138 1
d142 4
a145 1
static	v_post	 posts_dt[] = { post_dt, NULL };
d152 1
d158 1
d165 2
a166 2
static	v_pre	 pres_bd[] = { pre_display, pre_bd, pre_pp, NULL };
static	v_pre	 pres_bl[] = { pre_bl, pre_pp, NULL };
d168 1
a171 1
static	v_pre	 pres_ex[] = { NULL, NULL };
d175 1
a175 2
static	v_pre	 pres_pp[] = { pre_pp, NULL };
static	v_pre	 pres_rv[] = { pre_rv, NULL };
d178 2
d183 1
a183 1
	{ pres_dd, posts_wtext },		/* Dd */
d185 1
a185 1
	{ pres_os, NULL },			/* Os */
d190 2
a191 2
	{ pres_d1, posts_wline },		/* Dl */
	{ pres_bd, posts_bd_bk },		/* Bd */
d198 1
a198 1
	{ NULL, NULL },				/* Ar */
d204 1
a204 1
	{ pres_ex, NULL },			/* Ex */ 
d212 1
a212 1
	{ NULL, NULL },				/* Li */
d217 2
a218 2
	{ NULL, NULL },				/* Pa */
	{ pres_rv, NULL },			/* Rv */
d282 1
a282 1
	{ NULL, posts_bd_bk },			/* Bk */
d291 1
a291 1
	{ NULL, posts_text },			/* Mt */ 
d304 1
a304 1
	{ NULL, NULL },				/* TS */
d308 19
d339 2
a340 1
		return(check_text(mdoc, line, pos, tp));
d343 2
a344 2
	if ( ! check_args(mdoc, n))
		return(0);
d402 3
d414 2
d501 1
a501 13

static int
check_stdarg(PRE_ARGS)
{

	if (n->args && 1 == n->args->argc)
		if (MDOC_Std == n->args->argv[0].arg)
			return(1);
	return(mdoc_nmsg(mdoc, n, MANDOCERR_NOARGV));
}


static int
d507 1
a507 1
		return(1);
d511 1
a511 4
		if ( ! check_argv(m, n, &n->args->argv[i]))
			return(0);

	return(1);
d514 1
a514 2

static int
d520 1
a520 2
		if ( ! check_text(m, v->line, v->pos, v->value[i]))
			return(0);
d522 1
a522 6
	if (MDOC_Std == v->arg) {
		if (v->sz || m->meta.name)
			return(1);
		if ( ! mdoc_nmsg(m, n, MANDOCERR_NONAME))
			return(0);
	}
d524 3
a526 1
	return(1);
d529 1
a529 2

static int
d545 3
a547 5
			if (MDOC_LITERAL & m->flags)
				continue;
			if (mdoc_pmsg(m, ln, pos, MANDOCERR_BADTAB))
				continue;
			return(0);
d550 4
a553 1
		/* Check the special character. */
d555 2
a556 6
		c = mandoc_special(p);
		if (c) {
			p += c - 1;
			pos += c - 1;
		} else
			mdoc_pmsg(m, ln, pos, MANDOCERR_BADESCAPE);
a557 2

	return(1);
a559 1

d589 1
d685 1
a685 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV))
				return(0);
d693 2
a694 2
		if (dup && ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP))
			return(0);
d706 1
a706 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTREP))
				return(0);
d727 1
a727 2
				if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST))
					return(0);
d735 1
a735 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTTYPE))
			return(0);
d749 2
a750 3
		if (mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG))
			break;
		return(0);
d829 1
a829 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV))
				return(0);
d842 2
a843 2
		if (dup && ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP))
			return(0);
d855 1
a855 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_DISPREP))
				return(0);
d864 1
a864 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_DISPTYPE))
			return(0);
d900 1
d918 2
a919 3
		if ( ! mdoc_pmsg(mdoc, n->args->argv[i].line,
			n->args->argv[i].pos, MANDOCERR_IGNARGV))
			return(0);
a930 9

static int
pre_rv(PRE_ARGS)
{

	return(check_stdarg(mdoc, n));
}


d932 1
a932 1
post_dt(POST_ARGS)
a933 2
	const struct mdoc_node *nn;
	const char	*p;
d935 3
a937 8
	if (NULL != (nn = mdoc->last->child))
		for (p = nn->string; *p; p++) {
			if (toupper((u_char)*p) == *p)
				continue;
			if ( ! mdoc_nmsg(mdoc, nn, MANDOCERR_UPPERCASE))
				return(0);
			break;
		}
d939 1
a942 1

d948 2
a949 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO))
			return(0);
d951 2
a952 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP))
			return(0);
a955 1

d961 2
a962 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO))
			return(0);
d964 2
a965 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP))
			return(0);
a968 1

d974 2
a975 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO))
			return(0);
d977 2
a978 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP))
			return(0);
d1024 4
a1027 2
	} else if (NULL == np->parent->args && NULL == np->child)
		return(mdoc_nmsg(mdoc, np, MANDOCERR_FONTTYPE));
d1052 2
a1053 2
	else if ( ! mdoc_nmsg(mdoc, np, MANDOCERR_FONTTYPE))
		return(0);
a1057 1

d1061 8
d1070 5
a1074 1
	if (mdoc_a2lib(mdoc->last->child->string))
d1076 12
a1087 1
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADLIB));
a1089 1

d1094 3
a1096 3
	if (NULL == mdoc->last->child)
		return(1);
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_ARGSLOST));
d1119 1
a1119 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_CHILD))
				return(0);
d1128 1
d1130 4
a1133 1
	if (mdoc->last->child)
d1135 1
a1135 1
	if (mdoc->meta.name)
d1137 26
a1162 1
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NONAME));
d1165 48
d1217 3
d1221 6
d1229 1
d1231 18
a1248 3
	if (mdoc_a2att(mdoc->last->child->string))
		return(1);
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADATT));
a1250 1

d1259 1
d1266 3
a1268 1
	return(mdoc_nmsg(mdoc, np, MANDOCERR_NOARGS));
d1289 1
a1289 1
		return(0);
d1297 1
a1297 2
		if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS))
			return(0);
d1307 1
a1307 2
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS))
				return(0);
d1317 1
a1317 2
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY))
				return(0);
d1321 1
a1321 2
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_ARGSLOST))
				return(0);
d1329 1
a1329 2
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY))
				return(0);
a1352 1

d1354 1
a1354 1
post_bl_head(POST_ARGS) 
d1358 9
a1366 2
	assert(mdoc->last->parent);
	n = mdoc->last->parent;
d1368 3
a1370 3
	if (LIST_column == n->data.Bl->type) {
		if (n->data.Bl->ncols && mdoc->last->nchild) {
			mdoc_nmsg(mdoc, n, MANDOCERR_COLUMNS);
d1372 4
a1375 1
		}
a1376 1
	}
d1378 2
a1379 2
	/* FIXME: should be ERROR class. */
	return(hwarn_eq0(mdoc));
a1381 1

d1383 1
a1383 1
post_bl(POST_ARGS)
d1385 5
a1389 1
	struct mdoc_node	*n;
d1391 1
a1391 6
	if (MDOC_HEAD == mdoc->last->type) 
		return(post_bl_head(mdoc));
	if (MDOC_BODY != mdoc->last->type)
		return(1);
	if (NULL == mdoc->last->child)
		return(1);
d1394 6
a1399 3
	 * We only allow certain children of `Bl'.  This is usually on
	 * `It', but apparently `Sm' occurs here and there, so we let
	 * that one through, too.
d1402 7
a1408 8
	/* LINTED */
	for (n = mdoc->last->child; n; n = n->next) {
		if (MDOC_BLOCK == n->type && MDOC_It == n->tok)
			continue;
		if (MDOC_Sm == n->tok)
			continue;
		mdoc_nmsg(mdoc, n, MANDOCERR_SYNTCHILD);
		return(0);
d1411 16
a1429 1

d1431 1
a1431 1
ebool(struct mdoc *mdoc)
d1433 24
a1456 1
	struct mdoc_node *n;
d1458 2
a1459 3
	/* LINTED */
	for (n = mdoc->last->child; n; n = n->next) {
		if (MDOC_TEXT != n->type)
d1461 5
a1465 4
		if (0 == strcmp(n->string, "on"))
			continue;
		if (0 == strcmp(n->string, "off"))
			continue;
d1467 5
a1471 1
	}
d1473 4
a1476 4
	if (NULL == n)
		return(1);
	return(mdoc_nmsg(mdoc, n, MANDOCERR_BADBOOL));
}
d1478 2
d1481 2
a1482 3
static int
post_root(POST_ARGS)
{
d1484 6
a1489 10
	if (NULL == mdoc->first->child)
		mdoc_nmsg(mdoc, mdoc->first, MANDOCERR_NODOCBODY);
	else if ( ! (MDOC_PBODY & mdoc->flags))
		mdoc_nmsg(mdoc, mdoc->first, MANDOCERR_NODOCPROLOG);
	else if (MDOC_BLOCK != mdoc->first->child->type)
		mdoc_nmsg(mdoc, mdoc->first, MANDOCERR_NODOCBODY);
	else if (MDOC_Sh != mdoc->first->child->tok)
		mdoc_nmsg(mdoc, mdoc->first, MANDOCERR_NODOCBODY);
	else
		return(1);
d1491 3
a1493 1
	return(0);
d1498 1
a1498 1
post_st(POST_ARGS)
d1500 2
d1503 3
a1505 4
	if (mdoc_a2st(mdoc->last->child->string))
		return(1);
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADSTANDARD));
}
d1507 5
d1513 1
a1513 4
static int
post_rs(POST_ARGS)
{
	struct mdoc_node	*nn;
d1515 57
d1574 2
d1577 180
a1756 33
	for (nn = mdoc->last->child; nn; nn = nn->next)
		switch (nn->tok) {
		case(MDOC__U):
			/* FALLTHROUGH */
		case(MDOC__Q):
			/* FALLTHROUGH */
		case(MDOC__C):
			/* FALLTHROUGH */
		case(MDOC__A):
			/* FALLTHROUGH */
		case(MDOC__B):
			/* FALLTHROUGH */
		case(MDOC__D):
			/* FALLTHROUGH */
		case(MDOC__I):
			/* FALLTHROUGH */
		case(MDOC__J):
			/* FALLTHROUGH */
		case(MDOC__N):
			/* FALLTHROUGH */
		case(MDOC__O):
			/* FALLTHROUGH */
		case(MDOC__P):
			/* FALLTHROUGH */
		case(MDOC__R):
			/* FALLTHROUGH */
		case(MDOC__T):
			/* FALLTHROUGH */
		case(MDOC__V):
			break;
		default:
			mdoc_nmsg(mdoc, nn, MANDOCERR_SYNTCHILD);
			return(0);
d1758 1
a1762 1

a1774 1

d1789 4
a1792 2
	if (NULL == (n = mdoc->last->child))
		return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC));
d1799 1
a1799 2
		if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC))
			return(0);
d1805 3
a1807 1
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC));
a1809 1

d1813 2
a1814 3
	char		        buf[BUFSIZ];
	enum mdoc_sec	        sec;
	const struct mdoc_node *n;
d1818 3
a1820 3
	 * "custom"; custom sections are user-defined, while named ones
	 * usually follow a conventional order and may only appear in
	 * certain manual sections.
d1823 6
a1828 1
	buf[0] = '\0';
d1830 2
a1831 4
	/*
	 * FIXME: yes, these can use a dynamic buffer, but I don't do so
	 * in the interests of simplicity.
	 */
d1833 1
a1833 3
	for (n = mdoc->last->child; n; n = n->next) {
		/* XXX - copied from compact(). */
		assert(MDOC_TEXT == n->type);
d1835 4
a1838 11
		if (strlcat(buf, n->string, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
		}
		if (NULL == n->next)
			continue;
		if (strlcat(buf, " ", BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
		}
	}
d1840 1
a1840 1
	sec = mdoc_str2sec(buf);
d1842 1
a1842 4
	/* 
	 * Check: NAME should always be first, CUSTOM has no roles,
	 * non-CUSTOM has a conventional order to be followed.
	 */
d1844 1
a1844 3
	if (SEC_NAME != sec && SEC_NONE == mdoc->lastnamed)
		if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NAMESECFIRST))
			return(0);
d1849 5
d1855 1
a1855 2
		if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECREP))
			return(0);
d1858 7
a1864 2
		if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECOOO))
			return(0);
d1866 1
a1866 4
	/* 
	 * Check particular section/manual conventions.  LIBRARY can
	 * only occur in manual section 2, 3, and 9.
	 */
d1869 4
a1873 1
		assert(mdoc->meta.msec);
d1880 2
a1881 1
		return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECMSEC));
d1889 9
d1900 1
a1900 1
pre_pp(PRE_ARGS)
d1906 4
a1909 1
	/* Don't allow prior `Lp' or `Pp'. */
d1923 305
@


1.74
log
@Do not throw FATAL errors when there is no need to:
 - when encountering nested displays (.Bd containing .Bd, .D1, .D1)
 - when a block end macro was forgotten
 - when ending a block that was never started
 - when the uname(3) system call failed
along with a little related cleanup
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.73 2010/10/23 17:04:51 schwarze Exp $ */
d734 3
a736 5
		if (NULL == n->data.Bl->width)
			break;
		if (mdoc_nmsg(mdoc, n, MANDOCERR_WIDTHARG))
			break;
		return(0);
@


1.73
log
@use proper message in case of multiple arguments to .An
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.72 2010/10/23 16:40:15 schwarze Exp $ */
a551 2
	/* Display elements (`Bd', `D1'...) cannot be nested. */

a554 1
	/* LINTED */
d559 2
a560 2
	if (NULL == node)
		return(1);
d562 1
a562 2
	mdoc_nmsg(mdoc, n, MANDOCERR_NESTEDDISP);
	return(0);
@


1.72
log
@cleanup mdoc(7) validation code: use real functions, not macros
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.71 2010/10/16 13:38:29 schwarze Exp $ */
d894 1
d898 4
a901 2
	if (n->args->argc > 1)
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGCOUNT))
a902 2

	/* FIXME: this should use a different error message. */
@


1.71
log
@Support tbl(1) code embedded into mdoc(7) input files.
Very similar to what i have done in man(7) yesterday.
Allows to build cpu(4) on HPPA, wi(4), and phantasia(6).
Now we are able to build all tbl code in base.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.70 2010/09/27 21:25:28 schwarze Exp $ */
d35 12
d55 2
a62 10
static	int	 err_child_lt(struct mdoc *, const char *, int);
static	int	 warn_child_lt(struct mdoc *, const char *, int);
static	int	 err_child_gt(struct mdoc *, const char *, int);
static	int	 warn_child_gt(struct mdoc *, const char *, int);
static	int	 err_child_eq(struct mdoc *, const char *, int);
static	int	 warn_child_eq(struct mdoc *, const char *, int);
static	int	 warn_count(struct mdoc *, const char *, 
			int, const char *, int);
static	int	 err_count(struct mdoc *, const char *, 
			int, const char *, int);
d64 1
d67 1
a67 1
static	int	 ebool(POST_ARGS);
d75 1
a76 1
static	int	 hwarn_eq0(POST_ARGS);
d325 58
d384 2
a385 3
static inline int
warn_count(struct mdoc *m, const char *k, 
		int want, const char *v, int has)
d387 2
d390 4
a393 3
	return(mdoc_vmsg(m, MANDOCERR_ARGCOUNT, 
				m->last->line, m->last->pos, 
				"%s %s %d (have %d)", v, k, want, has));
d396 5
d402 2
a403 3
static inline int
err_count(struct mdoc *m, const char *k,
		int want, const char *v, int has)
d405 2
d408 4
a411 5
	mdoc_vmsg(m, MANDOCERR_SYNTARGCOUNT, 
			m->last->line, m->last->pos, 
			"%s %s %d (have %d)", 
			v, k, want, has);
	return(0);
d414 5
d420 5
a424 5
/*
 * Build these up with macros because they're basically the same check
 * for different inequalities.  Yes, this could be done with functions,
 * but this is reasonable for now.
 */
d426 4
a429 33
#define CHECK_CHILD_DEFN(lvl, name, ineq) 			\
static int 							\
lvl##_child_##name(struct mdoc *mdoc, const char *p, int sz) 	\
{ 								\
	if (mdoc->last->nchild ineq sz)				\
		return(1); 					\
	return(lvl##_count(mdoc, #ineq, sz, p, mdoc->last->nchild)); \
}

#define CHECK_BODY_DEFN(name, lvl, func, num) 			\
static int 							\
b##lvl##_##name(POST_ARGS) 					\
{ 								\
	if (MDOC_BODY != mdoc->last->type) 			\
		return(1); 					\
	return(func(mdoc, "multi-line arguments", (num))); 	\
}

#define CHECK_ELEM_DEFN(name, lvl, func, num) 			\
static int							\
e##lvl##_##name(POST_ARGS) 					\
{ 								\
	assert(MDOC_ELEM == mdoc->last->type); 			\
	return(func(mdoc, "line arguments", (num))); 		\
}

#define CHECK_HEAD_DEFN(name, lvl, func, num)			\
static int 							\
h##lvl##_##name(POST_ARGS) 					\
{ 								\
	if (MDOC_HEAD != mdoc->last->type) 			\
		return(1); 					\
	return(func(mdoc, "line arguments", (num)));	 	\
d432 5
d438 5
a442 18
CHECK_CHILD_DEFN(warn, gt, >)			/* warn_child_gt() */
CHECK_CHILD_DEFN(err, gt, >)			/* err_child_gt() */
CHECK_CHILD_DEFN(warn, eq, ==)			/* warn_child_eq() */
CHECK_CHILD_DEFN(err, eq, ==)			/* err_child_eq() */
CHECK_CHILD_DEFN(err, lt, <)			/* err_child_lt() */
CHECK_CHILD_DEFN(warn, lt, <)			/* warn_child_lt() */
CHECK_BODY_DEFN(ge1, warn, warn_child_gt, 0)	/* bwarn_ge1() */
CHECK_BODY_DEFN(ge1, err, err_child_gt, 0)	/* berr_ge1() */
CHECK_ELEM_DEFN(eq0, warn, warn_child_eq, 0)	/* ewarn_eq0() */
CHECK_ELEM_DEFN(ge1, warn, warn_child_gt, 0)	/* ewarn_ge1() */
CHECK_ELEM_DEFN(eq1, err, err_child_eq, 1)	/* eerr_eq1() */
CHECK_ELEM_DEFN(le1, err, err_child_lt, 2)	/* eerr_le1() */
CHECK_ELEM_DEFN(ge1, err, err_child_gt, 0)	/* eerr_ge1() */
CHECK_HEAD_DEFN(eq0, err, err_child_eq, 0)	/* herr_eq0() */
CHECK_HEAD_DEFN(le1, warn, warn_child_lt, 2)	/* hwarn_le1() */
CHECK_HEAD_DEFN(ge1, err, err_child_gt, 0)	/* herr_ge1() */
CHECK_HEAD_DEFN(eq1, warn, warn_child_eq, 1)	/* hwarn_eq1() */
CHECK_HEAD_DEFN(eq0, warn, warn_child_eq, 0)	/* hwarn_eq0() */
d901 2
d1135 5
a1139 1
		return(mdoc_nmsg(mdoc, np, MANDOCERR_ARGCOUNT));
a1235 1
	int		  i;
d1249 2
a1250 3
	if (0 == (i = mdoc->last->nchild))
		return(1);
	return(warn_count(mdoc, "==", 0, "line arguments", i));
@


1.70
log
@Merge the last bits of 1.10.6 (released today), most were already in:
* ignore double-.Pp
* ignore .Pp before .Bd and .Bl (unless -compact in specified)
* avoid double blank line upon .Pp, .br and friends in literal context
* cast enums to int when passing them to exit(3) to please lint(1)
While merging, fix a regression introduced by kristaps@@:
Outside literal mode, double blank lines must both be printed.
To achieve this again after kristaps@@ improvements in 1.10.6,
treat such blank lines as .sp (instead of .Pp as in 1.10.5)
and drop .Pp before .sp just like dropping .Pp before .Pp.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.69 2010/09/20 19:48:21 schwarze Exp $ */
d267 2
@


1.69
log
@Make .Pp .Lp .br not FATAL when having arguments;
From kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.68 2010/08/20 00:53:35 schwarze Exp $ */
d99 1
d129 2
a130 2
static	v_pre	 pres_bd[] = { pre_display, pre_bd, NULL };
static	v_pre	 pres_bl[] = { pre_bl, NULL };
d139 1
d151 1
a151 1
	{ NULL, posts_notext },			/* Pp */ 
d264 1
a264 1
	{ NULL, posts_sp },			/* sp */
d1464 23
@


1.68
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.67 2010/07/31 21:43:07 schwarze Exp $ */
a62 1
static	int	 eerr_eq0(POST_ARGS);
d66 1
d116 1
a116 1
static	v_post	 posts_notext[] = { eerr_eq0, NULL };
d391 1
a394 1
CHECK_ELEM_DEFN(eq0, err, err_child_eq, 0)	/* eerr_eq0() */
@


1.67
log
@Merge bsd.lv version 1.10.5: last larger batch of bug fixes before release.
NOT including Kristaps' .Bd -literal changes which cause regressions.
Features:
* -Tpdf now fully working
Bugfixes:
* proper handling of quoted strings by .ds in roff(7)
* allow empty .Dd
* make .Sm start no-spacing after the first output word
* underline .Ad
* minor fixes in -Thtml
and some optimisations in terminal output.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.66 2010/07/25 18:05:54 schwarze Exp $ */
d480 2
a481 6
			continue;
		}

		c = mdoc_pmsg(m, ln, pos, MANDOCERR_BADESCAPE);
		if ( ! (MDOC_IGN_ESCAPE & m->pflags) && ! c)
			return(c);
@


1.66
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.65 2010/07/13 01:09:13 schwarze Exp $ */
d144 1
a144 1
	{ pres_dd, posts_text },		/* Dd */
@


1.65
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.64 2010/07/02 17:41:05 schwarze Exp $ */
a30 1
/* TODO: ignoring Pp (it's superfluous in some invocations). */
d452 1
a452 1
check_text(struct mdoc *mdoc, int line, int pos, char *p)
d455 1
d457 8
a464 4
	/* 
	 * FIXME: we absolutely cannot let \b get through or it will
	 * destroy some assumptions in terms of format.
	 */
a465 1
	for ( ; *p; p++, pos++) {
d467 6
a472 6
			if ( ! (MDOC_LITERAL & mdoc->flags))
				if ( ! mdoc_pmsg(mdoc, line, pos, MANDOCERR_BADCHAR))
					return(0);
		} else if ( ! isprint((u_char)*p) && ASCII_HYPH != *p)
			if ( ! mdoc_pmsg(mdoc, line, pos, MANDOCERR_BADCHAR))
				return(0);
d474 1
a474 2
		if ('\\' != *p)
			continue;
d483 2
a484 2
		c = mdoc_pmsg(mdoc, line, pos, MANDOCERR_BADESCAPE);
		if ( ! (MDOC_IGN_ESCAPE & mdoc->pflags) && ! c)
a491 2


a508 1

d623 2
d947 1
a947 1
	int		  arg;
@


1.64
log
@Not only for -tag lists, but for -hang, -ohang, -inset, -diag,
and -item list as well, empty bodies are OK, they do not even
warrant a warning, much less the error they were throwing.
According to kristaps, joerg@@ also brought this up some time ago.
ok kristaps@@ jmc@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.63 2010/06/27 21:54:42 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
d153 1
a153 1
	{ pres_bd, posts_bd_bk },			/* Bd */
d457 5
d536 4
a539 3
	int		 i, comp, dup;
	const char	*offs, *width;
	enum mdoc_list	 lt;
d542 11
a552 6
		assert(n->parent);
		assert(MDOC_BLOCK == n->parent->type);
		assert(MDOC_Bl == n->parent->tok);
		assert(LIST__NONE != n->parent->data.Bl.type);
		memcpy(&n->data.Bl, &n->parent->data.Bl,
				sizeof(struct mdoc_bl));
d562 2
a563 1
	assert(LIST__NONE == n->data.Bl.type);
d607 1
a607 1
			dup = n->data.Bl.comp;
d611 1
a611 1
			dup = (NULL != n->data.Bl.width);
d618 1
a618 1
				dup = (NULL != n->data.Bl.offs);
d632 1
a632 1
			n->data.Bl.comp = comp;
d634 1
a634 1
			n->data.Bl.offs = offs;
d636 1
a636 1
			n->data.Bl.width = width;
d640 1
a640 1
		if (LIST__NONE != lt && n->data.Bl.type != LIST__NONE)
d646 10
a655 2
		if (LIST__NONE != lt && n->data.Bl.type == LIST__NONE)
			n->data.Bl.type = lt;
d659 4
a662 4
		if (n->data.Bl.type == LIST__NONE)
			if (n->data.Bl.width || 
					n->data.Bl.offs || 
					n->data.Bl.comp)
d671 1
a671 1
	if (LIST__NONE == n->data.Bl.type) {
d674 1
a674 1
		n->data.Bl.type = LIST_item;
d683 1
a683 1
	switch (n->data.Bl.type) {
d685 1
a685 1
		if (n->data.Bl.width)
d699 1
a699 1
		if (NULL == n->data.Bl.width)
d715 4
a718 3
	int		 i, dup, comp;
	enum mdoc_disp 	 dt;
	const char	*offs;
d721 11
a731 6
		assert(n->parent);
		assert(MDOC_BLOCK == n->parent->type);
		assert(MDOC_Bd == n->parent->tok);
		assert(DISP__NONE != n->parent->data.Bd.type);
		memcpy(&n->data.Bd, &n->parent->data.Bd, 
				sizeof(struct mdoc_bd));
d735 2
a736 1
	assert(DISP__NONE == n->data.Bd.type);
d767 1
a767 1
				dup = (NULL != n->data.Bd.offs);
d775 1
a775 1
			dup = n->data.Bd.comp;
d790 1
a790 1
			n->data.Bd.offs = offs;
d792 1
a792 1
			n->data.Bd.comp = comp;
d796 1
a796 1
		if (DISP__NONE != dt && n->data.Bd.type != DISP__NONE)
d802 2
a803 2
		if (DISP__NONE != dt && n->data.Bd.type == DISP__NONE)
			n->data.Bd.type = dt;
d806 1
a806 1
	if (DISP__NONE == n->data.Bd.type) {
d809 1
a809 1
		n->data.Bd.type = DISP_ragged;
d856 1
a856 1
	if (NULL == n->args || 1 == n->args->argc)
d858 12
a869 5
	mdoc_vmsg(mdoc, MANDOCERR_SYNTARGCOUNT, 
				n->line, n->pos,
				"line arguments == 1 (have %d)",
				n->args->argc);
	return(0);
d945 7
a951 2
	char		 *p;
	struct mdoc_node *head;
d953 14
a966 1
	if (MDOC_BLOCK != mdoc->last->type)
d968 6
d975 4
a978 1
	head = mdoc->last->head;
d980 2
a981 3
	if (mdoc->last->args && head->child) {
		/* FIXME: this should provide a default. */
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SYNTARGVCOUNT);
d983 15
a997 1
	} else if (mdoc->last->args)
a998 5

	if (NULL == head->child || MDOC_TEXT != head->child->type) {
		/* FIXME: this should provide a default. */
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SYNTARGVCOUNT);
		return(0);
d1001 1
a1001 1
	p = head->child->string;
d1003 8
a1010 6
	if (0 == strcmp(p, "Em"))
		return(1);
	else if (0 == strcmp(p, "Li"))
		return(1);
	else if (0 == strcmp(p, "Sy"))
		return(1);
d1012 1
a1012 2
	mdoc_nmsg(mdoc, head, MANDOCERR_FONTTYPE);
	return(0);
d1090 1
d1092 4
a1095 7
	if (mdoc->last->args) {
		if (NULL == mdoc->last->child)
			return(1);
		return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_ARGCOUNT));
	}

	if (mdoc->last->child)
d1097 1
a1097 1
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS));
d1113 2
a1114 1
	lt = n->data.Bl.type;
d1157 1
a1157 6
		cols = -1;
		for (i = 0; i < (int)n->args->argc; i++)
			if (MDOC_Column == n->args->argv[i].arg) {
				cols = (int)n->args->argv[i].sz;
				break;
			}
a1158 1
		assert(-1 != cols);
d1197 2
a1198 7
	if (LIST_column == n->data.Bl.type) {
		for (i = 0; i < (int)n->args->argc; i++)
			if (MDOC_Column == n->args->argv[i].arg)
				break;
		assert(i < (int)n->args->argc);

		if (n->args->argv[i].sz && mdoc->last->nchild) {
@


1.63
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.62 2010/06/27 17:49:58 schwarze Exp $ */
a1069 3
		if (NULL == mdoc->last->body->child)
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY))
				return(0);
d1078 3
a1084 3
				return(0);
		if (NULL == mdoc->last->body->child)
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY))
@


1.62
log
@minor .Bk fixes:
* do not print invalid arguments verbatim (no groffs prints them, either)
* do not trigger TERMP_PREKEEP twice
* do not die from invlid arguments (groff won't die, either)
* continue to ignore even valid arguments (just like groff)
ok kristaps@@ on the previous version, before removing my last bug ;)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.61 2010/06/26 17:56:43 schwarze Exp $ */
d805 2
@


1.61
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.60 2010/06/06 20:30:08 schwarze Exp $ */
d106 1
a106 1
static	v_post	 posts_bd[] = { hwarn_eq0, bwarn_ge1, NULL };
d153 1
a153 1
	{ pres_bd, posts_bd },			/* Bd */
d244 1
a244 1
	{ NULL, posts_wline },			/* Bk */
@


1.60
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.59 2010/06/06 18:08:41 schwarze Exp $ */
d46 1
a46 1
static	int	 check_text(struct mdoc *, int, int, const char *);
d48 2
a49 4
			const struct mdoc_node *,
			const struct mdoc_argv *);
static	int	 check_args(struct mdoc *, 
			const struct mdoc_node *);
d274 1
a274 1
	const char	*tp;
d416 1
a416 1
check_args(struct mdoc *m, const struct mdoc_node *n)
d433 1
a433 2
check_argv(struct mdoc *m, const struct mdoc_node *n, 
		const struct mdoc_argv *v)
d453 1
a453 1
check_text(struct mdoc *mdoc, int line, int pos, const char *p)
d531 2
a532 1
	int		 i, width, offs, cmpt, dupl;
d539 3
a541 2
		assert(LIST__NONE != n->parent->data.list);
		n->data.list = n->parent->data.list;
d551 1
a551 2
	assert(LIST__NONE == n->data.list);
	offs = width = cmpt = -1;
d556 2
a557 1
		dupl = 0;
d595 2
a596 3
			if (cmpt >= 0) 
				dupl++;
			cmpt = i;
d599 2
a600 3
			if (width >= 0)
				dupl++;
			width = i;
d603 8
a610 3
			if (offs >= 0)
				dupl++;
			offs = i;
d616 9
a624 3
		if (dupl)
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP))
				return(0);
d628 1
a628 1
		if (LIST__NONE != lt && n->data.list != LIST__NONE)
d634 2
a635 2
		if (LIST__NONE != lt && n->data.list == LIST__NONE)
			n->data.list = lt;
d639 4
a642 2
		if (n->data.list == LIST__NONE)
			if (width >= 0 || offs >= 0 || cmpt >= 0)
d651 1
a651 1
	if (LIST__NONE == n->data.list) {
d654 1
a654 1
		n->data.list = LIST_item;
d663 1
a663 1
	switch (n->data.list) {
d665 1
a665 1
		if (width >= 0)
d679 1
a679 1
		if (width < 0)
d695 3
a697 1
	int		 i, type, err;
d699 7
a705 1
	if (MDOC_BLOCK != n->type)
a706 3
	if (NULL == n->args) {
		mdoc_nmsg(mdoc, n, MANDOCERR_DISPTYPE);
		return(0);
d709 1
a709 1
	/* Make sure that only one type of display is specified.  */
d712 5
a716 2
	for (i = 0, err = type = 0; ! err && 
			i < (int)n->args->argc; i++)
d719 2
a720 1
			/* FALLTHROUGH */
d722 2
a723 1
			/* FALLTHROUGH */
d725 2
a726 1
			/* FALLTHROUGH */
d728 2
a729 1
			/* FALLTHROUGH */
d731 10
a740 1
			if (0 == type++) 
d742 2
a743 1
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_DISPREP))
d746 4
d751 2
a752 1
			break;
d755 31
a785 4
	if (type)
		return(1);
	mdoc_nmsg(mdoc, n, MANDOCERR_DISPTYPE);
	return(0);
d1043 1
a1043 1
	lt = n->data.list;
d1135 1
a1135 1
	if (LIST_column == n->data.list) {
@


1.59
log
@Merge bsd.lv release 1.10.0,
which is mostly the post-hackathon release,
bringing in the OpenBSD changes to bsd.lv,
but which also has a few additional minor fixes:

* .Lb is an in-line macro, not in_line_eoln
* .Bt, .Ud now warn when discarding arguments
* allow bad -man dates to flow verbatim into the front-ends
- so far all reported by Ulrich Spoerlein
* .Ar, .Fl and .Li starting with closing punctuation emit an empty element
* empty .Li macros print nothing, but may cause spacing
* proper EOS handling for .Bt, .Ex, .Rv, and .Ud.
* cleanup: collapse posts_xr into posts_wtext (which is the same)
* efficiency: very simple table lookup for roff.c
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.58 2010/05/26 02:39:58 schwarze Exp $ */
d33 1
a33 1
#define	PRE_ARGS  struct mdoc *mdoc, const struct mdoc_node *n
d82 1
d113 1
d148 1
a148 1
	{ pres_dt, NULL },			/* Dt */
d267 1
d272 1
a272 1
mdoc_valid_pre(struct mdoc *mdoc, const struct mdoc_node *n)
d534 2
a535 1
	int		 pos, type, width, offset;
d537 6
a542 1
	if (MDOC_BLOCK != n->type)
a543 3
	if (NULL == n->args) {
		mdoc_nmsg(mdoc, n, MANDOCERR_LISTTYPE);
		return(0);
d546 5
a550 1
	/* Make sure that only one type of list is specified.  */
d552 2
a553 1
	type = offset = width = -1;
d556 5
a560 2
	for (pos = 0; pos < (int)n->args->argc; pos++)
		switch (n->args->argv[pos].arg) {
d562 2
a563 1
			/* FALLTHROUGH */
d565 2
a566 1
			/* FALLTHROUGH */
d568 2
a569 1
			/* FALLTHROUGH */
d571 2
a572 1
			/* FALLTHROUGH */
d574 2
a575 1
			/* FALLTHROUGH */
d577 2
a578 1
			/* FALLTHROUGH */
d580 2
a581 1
			/* FALLTHROUGH */
d583 2
a584 1
			/* FALLTHROUGH */
d586 2
a587 1
			/* FALLTHROUGH */
d589 2
a590 1
			/* FALLTHROUGH */
d592 3
a594 7
			if (type < 0) {
				type = n->args->argv[pos].arg;
				break;
			}
			if (mdoc_nmsg(mdoc, n, MANDOCERR_LISTREP))
				break;
			return(0);
d596 4
a599 5
			if (type >= 0)
				break;
			if (mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST))
				break;
			return(0);
d602 2
a603 5
				if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP))
					return(0);
			if (type < 0 && ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST))
				return(0);
			width = n->args->argv[pos].arg;
d606 3
a608 8
			if (offset >= 0)
				if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP))
					return(0);
			if (type < 0 && ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST))
				return(0);
			offset = n->args->argv[pos].arg;
			break;
		default:
d612 33
a644 3
	if (type < 0) {
		mdoc_nmsg(mdoc, n, MANDOCERR_LISTTYPE);
		return(0);
d653 8
a660 6
	switch (type) {
	case (MDOC_Tag):
		if (width < 0 && ! mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG))
			return(0);
		break;
	case (MDOC_Column):
d662 1
a662 1
	case (MDOC_Diag):
d664 1
a664 1
	case (MDOC_Ohang):
d666 1
a666 1
	case (MDOC_Inset):
d668 6
a673 4
	case (MDOC_Item):
		if (width >= 0 && ! mdoc_nmsg(mdoc, n, MANDOCERR_WIDTHARG))
			return(0);
		break;
d782 19
a803 2
	/* FIXME: make sure is capitalised. */

d970 2
a971 1
	int		  type, i, cols;
d973 1
d979 3
a981 1
	if (NULL == n->args) {
d986 3
a988 26
	/* Some types require block-head, some not. */

	/* LINTED */
	for (cols = type = -1, i = 0; -1 == type && 
			i < (int)n->args->argc; i++)
		switch (n->args->argv[i].arg) {
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Item):
			type = n->args->argv[i].arg;
d990 3
a992 18
		case (MDOC_Column):
			type = n->args->argv[i].arg;
			cols = (int)n->args->argv[i].sz;
			break;
		default:
			break;
		}

	if (-1 == type) {
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_LISTTYPE);
		return(0);
	}

	switch (type) {
	case (MDOC_Tag):
		if (NULL == mdoc->last->head->child)
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS))
				return(0);
d994 1
a994 1
	case (MDOC_Hang):
d996 1
a996 1
	case (MDOC_Ohang):
d998 1
a998 1
	case (MDOC_Inset):
d1000 1
a1000 1
	case (MDOC_Diag):
d1008 1
a1008 1
	case (MDOC_Bullet):
d1010 1
a1010 1
	case (MDOC_Dash):
d1012 1
a1012 1
	case (MDOC_Enum):
d1014 1
a1014 1
	case (MDOC_Hyphen):
d1016 1
a1016 1
	case (MDOC_Item):
d1024 13
a1036 17
	case (MDOC_Column):
		if (NULL == mdoc->last->head->child)
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS))
				return(0);
		if (mdoc->last->body->child)
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BODYLOST))
				return(0);
		c = mdoc->last->child;
		for (i = 0; c && MDOC_HEAD == c->type; c = c->next)
			i++;

		if (i < cols) {
			if ( ! mdoc_vmsg(mdoc, MANDOCERR_ARGCOUNT,
					mdoc->last->line, 
					mdoc->last->pos, 
					"columns == %d (have %d)",
					cols, i))
d1038 8
d1047 2
a1048 2
		} else if (i == cols || i == cols + 1)
			break;
d1050 1
a1050 1
		mdoc_vmsg(mdoc, MANDOCERR_SYNTARGCOUNT,
d1053 1
a1053 1
		return(0);
d1065 2
a1066 3
	int			i;
	const struct mdoc_node *n;
	const struct mdoc_argv *a;
d1068 1
a1069 1
	assert(n->args);
d1071 9
a1079 6
	for (i = 0; i < (int)n->args->argc; i++) {
		a = &n->args->argv[i];
		if (a->arg == MDOC_Column) {
			if (a->sz && mdoc->last->nchild)
				return(mdoc_nmsg(mdoc, n, MANDOCERR_COLUMNS));
			return(1);
d1081 1
@


1.58
log
@When a word does not fully fit onto the output line, but it contains
at least one hyphen, we already had support for breaking the line a the
last fitting hyphen.  This patch improves this functionality by only
breaking at hyphens in free-form text, and by not breaking at hyphens
* at the beginning or end of a word   or
* immediately preceded or followed by another hyphen   or
* escaped by a preceding backslash.

Before this patch, differences in break-at-hyphen support were one
of the major sources of noise in automatic comparisons to mdoc(7)
groff output.  Now, the remaining differences are hard to find among
the noise coming from other sources.

Where there are still differences, what we do seems to be better than
what groff does, see e.g. the chio(1) exchange and position commands
for one of the now rare examples.

idea and coding by kristaps@@

Besides, this was the last substantial code difference left
between bsd.lv and openbsd.org.  We are now in full sync.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.57 2010/05/24 12:48:11 schwarze Exp $ */
d91 1
d111 1
a127 1
static	v_post	 posts_xr[] = { ewarn_ge1, NULL };
a137 1
static	v_pre	 pres_lb[] = { NULL, NULL };
d184 1
a184 1
	{ NULL, posts_xr },			/* Xr */ 
d246 1
a246 1
	{ NULL, posts_notext },			/* Bt */
d249 2
a250 2
	{ NULL, posts_notext },			/* Ud */
	{ pres_lb, posts_lb },			/* Lb */
d391 1
a391 1
CHECK_ELEM_DEFN(ge1, warn, warn_child_gt, 0)	/* ewarn_gt1() */
d825 10
@


1.57
log
@lift 64-byte max width for Sh (now BUFSIZ); from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.56 2010/05/24 00:00:10 schwarze Exp $ */
d462 1
a462 1
		} else if ( ! isprint((u_char)*p))
@


1.56
log
@Increase performance by saving the list type in struct mdoc_node.
This will eventually be used so that mdoc_macro can know whether to
dump list line arguments into the body (`Bl -column' overflowing).
Remove a2list() and arg_listtype() because of this.

From kristaps@@.

While merging, fix a regression in mdoc_term.c, print_bvspace():
The bsd.lv version of this broke vertical spacing in .Bl -column.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.55 2010/05/23 22:45:01 schwarze Exp $ */
d22 1
d1224 1
a1224 1
	char		        buf[64];
d1246 1
a1246 1
		if (strlcat(buf, n->string, 64) >= 64) {
d1252 1
a1252 1
		if (strlcat(buf, " ", 64) >= 64) {
@


1.55
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.54 2010/05/15 18:25:51 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d567 2
a568 13
			/*
			 * Note that if a duplicate is detected, we
			 * remove the duplicate instead of passing it
			 * over.  If we don't do this, mdoc_action will
			 * become confused when it scans over multiple
			 * types whilst setting its bitmasks.
			 *
			 * FIXME: this should occur in mdoc_action.c.
			 */
			if (type >= 0) {
				if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTREP))
					return(0);
				mdoc_argn_free(n->args, pos);
d571 3
a573 2
			type = n->args->argv[pos].arg;
			break;
d575 5
a579 3
			if (type < 0 && ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST))
				return(0);
			break;
@


1.54
log
@allow non-numeric manual sections in -mdoc;
while here, allow LIBRARY in section 9;
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.53 2010/05/15 16:48:12 schwarze Exp $ */
d25 1
d321 3
a323 2
	return(mdoc_vwarn(m, m->last->line, m->last->pos, 
		"suggests %s %s %d (has %d)", v, k, want, has));
d332 5
a336 2
	return(mdoc_verr(m, m->last->line, m->last->pos,
		"requires %s %s %d (has %d)", v, k, want, has));
d409 1
a409 1
	return(mdoc_nwarn(mdoc, n, EARGVAL));
a440 1
		/* `Nm' name must be set. */
d443 2
a444 1
		return(mdoc_nerr(m, n, ENAME));
d459 1
a459 1
				if ( ! mdoc_pwarn(mdoc, line, pos, EPRINT))
d462 1
a462 1
			if ( ! mdoc_pwarn(mdoc, line, pos, EPRINT))
d474 4
a477 4
		if ( ! (MDOC_IGN_ESCAPE & mdoc->pflags))
			return(mdoc_perr(mdoc, line, pos, EESCAPE));
		if ( ! mdoc_pwarn(mdoc, line, pos, EESCAPE))
			return(0);
d495 5
a499 2
	return(mdoc_verr(mdoc, n->line, n->pos, "require parent %s",
		MDOC_ROOT == t ? "<root>" : mdoc_macronames[tok]));
d522 2
a523 1
	return(mdoc_nerr(mdoc, n, ENESTDISP));
d534 4
a537 2
	if (NULL == n->args)
		return(mdoc_nerr(mdoc, n, ELISTTYPE));
d577 1
a577 1
				if ( ! mdoc_nwarn(mdoc, n, EMULTILIST))
d585 1
a585 1
			if (type < 0 && ! mdoc_nwarn(mdoc, n, ENOTYPE))
d590 3
a592 2
				return(mdoc_nerr(mdoc, n, EARGREP));
			if (type < 0 && ! mdoc_nwarn(mdoc, n, ENOTYPE))
d598 3
a600 2
				return(mdoc_nerr(mdoc, n, EARGREP));
			if (type < 0 && ! mdoc_nwarn(mdoc, n, ENOTYPE))
d608 4
a611 2
	if (type < 0)
		return(mdoc_nerr(mdoc, n, ELISTTYPE));
d621 1
a621 1
		if (width < 0 && ! mdoc_nwarn(mdoc, n, EMISSWIDTH))
d633 1
a633 1
		if (width >= 0 && ! mdoc_nwarn(mdoc, n, ENOWIDTH))
d651 4
a654 2
	if (NULL == n->args) 
		return(mdoc_nerr(mdoc, n, EDISPTYPE));
d673 3
a675 1
			return(mdoc_nerr(mdoc, n, EMULTIDISP));
d682 2
a683 1
	return(mdoc_nerr(mdoc, n, EDISPTYPE));
d713 4
d727 5
a731 2
	return(mdoc_verr(mdoc, n->line, n->pos, 
				"only one argument allowed"));
d750 1
a750 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLOOO))
d753 1
a753 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLREP))
d764 1
a764 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLOOO))
d767 1
a767 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLREP))
d778 1
a778 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLOOO))
d781 1
a781 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLREP))
d798 5
a802 3
	if (mdoc->last->args && head->child)
		return(mdoc_nerr(mdoc, mdoc->last, ELINE));
	else if (mdoc->last->args)
d805 5
a809 2
	if (NULL == head->child || MDOC_TEXT != head->child->type)
		return(mdoc_nerr(mdoc, mdoc->last, ELINE));
d820 2
a821 1
	return(mdoc_nerr(mdoc, head, EFONT));
d831 1
a831 1
	return(mdoc_nwarn(mdoc, mdoc->last, ELIB));
d854 1
a854 1
			if ( ! mdoc_nwarn(mdoc, n, EBADCHILD))
d869 1
a869 1
	return(mdoc_nerr(mdoc, mdoc->last, ENAME));
d879 1
a879 2
	if (MDOC_TEXT != mdoc->last->child->type)
		return(mdoc_nerr(mdoc, mdoc->last, EATT));
d882 1
a882 1
	return(mdoc_nwarn(mdoc, mdoc->last, EATT));
d893 1
a893 1
		return(mdoc_nerr(mdoc, mdoc->last, ENOLINE));
d898 1
a898 1
	return(mdoc_nerr(mdoc, mdoc->last, ELINE));
d912 4
a915 2
	if (NULL == n->args)
		return(mdoc_nerr(mdoc, mdoc->last, ELISTTYPE));
d952 4
a955 2
	if (-1 == type)
		return(mdoc_nerr(mdoc, mdoc->last, ELISTTYPE));
d960 1
a960 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, ELINE))
d971 1
a971 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, ELINE))
d974 1
a974 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, EMULTILINE))
d987 1
a987 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, ENOLINE))
d990 1
a990 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, EMULTILINE))
d995 1
a995 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, ELINE))
d998 1
a998 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, ENOMULTILINE))
d1005 5
a1009 4
			if ( ! mdoc_vwarn(mdoc, mdoc->last->line, 
					mdoc->last->pos, "column "
					"mismatch: have %d, want %d", 
					i, cols))
d1015 4
a1018 3
		return(mdoc_verr(mdoc, mdoc->last->line, 
				mdoc->last->pos, "column mismatch: "
				"have %d, want %d", i, cols));
d1041 1
a1041 1
				return(mdoc_nerr(mdoc, n, ECOLMIS));
d1076 2
a1077 1
		return(mdoc_nerr(mdoc, n, EBADCHILD));
d1102 1
a1102 1
	return(mdoc_nerr(mdoc, n, EBOOL));
d1111 9
a1119 8
		return(mdoc_nerr(mdoc, mdoc->first, ENODAT));
	if ( ! (MDOC_PBODY & mdoc->flags))
		return(mdoc_nerr(mdoc, mdoc->first, ENOPROLOGUE));

	if (MDOC_BLOCK != mdoc->first->child->type)
		return(mdoc_nerr(mdoc, mdoc->first, ENODAT));
	if (MDOC_Sh != mdoc->first->child->tok)
		return(mdoc_nerr(mdoc, mdoc->first, ENODAT));
d1121 1
a1121 1
	return(1);
d1131 1
a1131 1
	return(mdoc_nwarn(mdoc, mdoc->last, EBADSTAND));
d1174 2
a1175 1
			return(mdoc_nerr(mdoc, nn, EBADCHILD));
d1210 1
a1210 1
		return(mdoc_nwarn(mdoc, mdoc->last, ENAMESECINC));
d1217 1
a1217 1
		if ( ! mdoc_nwarn(mdoc, mdoc->last, ENAMESECINC))
d1224 1
a1224 1
	return(mdoc_nwarn(mdoc, mdoc->last, ENAMESECINC));
d1242 6
a1247 1
	buf[0] = 0;
d1253 4
a1256 2
		if (strlcat(buf, n->string, 64) >= 64)
			return(mdoc_nerr(mdoc, n, ETOOLONG));
d1259 4
a1262 2
		if (strlcat(buf, " ", 64) >= 64)
			return(mdoc_nerr(mdoc, n, ETOOLONG));
d1273 1
a1273 1
		if ( ! mdoc_nwarn(mdoc, mdoc->last, ESECNAME))
d1280 1
a1280 1
		if ( ! mdoc_nwarn(mdoc, mdoc->last, ESECREP))
d1284 1
a1284 1
		if ( ! mdoc_nwarn(mdoc, mdoc->last, ESECOOO))
d1301 1
a1301 1
		return(mdoc_nwarn(mdoc, mdoc->last, EWRONGMSEC));
@


1.53
log
@various improvements regarding errors and warnings Joerg Sonnenberger:
* If the last -column .Bl isn't specified, it is auto-sized.
* An invalid .St argument should be a warning, not an error.
  Just put the argument into the output.
* An invalid .At argument should be a warning, not an error.
  Just print the argument, like new groff does.
* Remove warnings concerning manual section (like 1, 6, 8).
  It was only used for .Ex and not really useful.
* Remove warnings concerning page section (like SYNOPSIS).
  These were only used for .Fd and .Lb and not really useful.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.52 2010/05/14 19:52:43 schwarze Exp $ */
d1239 1
a1239 1
	 * only occur in msec 2, 3 (TODO: are there more of these?).
d1244 6
a1249 4
		switch (mdoc->meta.msec) {
		case (2):
			/* FALLTHROUGH */
		case (3):
d1251 1
a1251 4
		default:
			return(mdoc_nwarn(mdoc, mdoc->last, EWRONGMSEC));
		}
		break;
@


1.52
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.51 2010/05/14 14:47:44 schwarze Exp $ */
a21 1
#include <stdarg.h>
a42 2
static	int	 check_msec(PRE_ARGS, ...);
static	int	 check_sec(PRE_ARGS, ...);
a95 2
static	int	 pre_ex(PRE_ARGS);
static	int	 pre_fd(PRE_ARGS);
a96 1
static	int	 pre_lb(PRE_ARGS);
d132 2
a133 2
static	v_pre	 pres_ex[] = { pre_ex, NULL };
static	v_pre	 pres_fd[] = { pre_fd, NULL };
d135 1
a135 1
static	v_pre	 pres_lb[] = { pre_lb, NULL };
a408 46
check_sec(PRE_ARGS, ...)
{
	enum mdoc_sec	 sec;
	va_list		 ap;

	va_start(ap, n);

	for (;;) {
		/* LINTED */
		sec = (enum mdoc_sec)va_arg(ap, int);
		if (SEC_CUSTOM == sec)
			break;
		if (sec != mdoc->lastsec)
			continue;
		va_end(ap);
		return(1);
	}

	va_end(ap);
	return(mdoc_nwarn(mdoc, n, EBADSEC));
}


static int
check_msec(PRE_ARGS, ...)
{
	va_list		 ap;
	int		 msec;

	va_start(ap, n);
	for (;;) {
		/* LINTED */
		if (0 == (msec = va_arg(ap, int)))
			break;
		if (msec != mdoc->meta.msec)
			continue;
		va_end(ap);
		return(1);
	}

	va_end(ap);
	return(mdoc_nwarn(mdoc, n, EBADMSEC));
}


static int
a708 8
pre_lb(PRE_ARGS)
{

	return(check_sec(mdoc, n, SEC_LIBRARY, SEC_CUSTOM));
}


static int
a716 10
pre_ex(PRE_ARGS)
{

	if ( ! check_msec(mdoc, n, 1, 6, 8, 0))
		return(0);
	return(check_stdarg(mdoc, n));
}


static int
d850 1
a850 1
	return(mdoc_nerr(mdoc, mdoc->last, EATT));
d968 1
a968 1
		if (i < cols || i == (cols + 1)) {
d975 1
a975 1
		} else if (i == cols)
d1091 1
a1091 1
	return(mdoc_nerr(mdoc, mdoc->last, EBADSTAND));
a1257 8
}


static int
pre_fd(PRE_ARGS)
{

	return(check_sec(mdoc, n, SEC_SYNOPSIS, SEC_CUSTOM));
@


1.51
log
@Merge 1.9.25, keeping local patches;
this does not merge kristaps' end-of-sentences handling yet,
i will check that separately.  This one includes:
* handle \*(Ba as a delimiter
* introduce ARGS_PEND for .Bl -column .It end-of-line special casing
* section ordering: expect EXIT STATUS at the right place
* line break fixes in SYNOPSIS
* allow literal contexts to have arbitrary line lengths
* the input file column number can not be used to identify the beginning
  of a line because white space is allowed after the initial '.'
* proper leading spaces in -man -Tascii mode
* do not let Lb break lines in -mdoc -Thtml LIBRARY
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.50 2010/05/14 01:54:37 schwarze Exp $ */
a268 1
	{ NULL, NULL },				/* eos */
d890 1
a890 2
		if (MDOC_TEXT != n->type &&
		    (MDOC_ELEM != n->type || MDOC_eos != n->tok)) 
@


1.50
log
@merge 1.9.24, keeping local patches; some changes:
* preserve multiple consecutive space characters in input
* do not restrict .Cd and .Rv to certain sections (requested by Joerg)
* do not run lookup() on quoted words
* enum return types for mdoc_args and mdoc_argv
* fix auto-closing of LINK tag in -Txhtml (from Daniel Friesel)
* various lint and manual fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.49 2010/05/13 20:34:29 schwarze Exp $ */
d1287 1
a1287 1
	sec = mdoc_atosec(buf);
d1294 4
a1297 3
	if (SEC_NAME != sec && SEC_NONE == mdoc->lastnamed && 
			! mdoc_nwarn(mdoc, mdoc->last, ESECNAME))
		return(0);
d1300 1
d1304 1
@


1.49
log
@Remove the command line option -fno-ign-chars.
This option was not useful, you never want mandoc to die
just because there is an invalid character in the input file,
neither in production nor when linting: a warning is sufficient.
This was particularly annoying because it was part of -fstrict
and could not be switched off.
"less is more" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.48 2010/04/07 23:15:05 schwarze Exp $ */
a95 1
static	int	 pre_cd(PRE_ARGS);
a133 1
static	v_pre	 pres_cd[] = { pre_cd, NULL };
d165 1
a165 1
	{ pres_cd, posts_text },		/* Cd */ 
d736 1
a736 1
	return(check_parent(mdoc, n, -1, MDOC_ROOT));
a772 2
	if ( ! check_msec(mdoc, n, 2, 3, 0))
		return(0);
a783 8
}


static int
pre_cd(PRE_ARGS)
{

	return(check_msec(mdoc, n, 4, 0));
@


1.48
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.47 2010/04/03 17:06:19 schwarze Exp $ */
a58 1
static	int	 warn_print(struct mdoc *, int, int);
a323 10
static int
warn_print(struct mdoc *m, int ln, int pos)
{

	if (MDOC_IGN_CHARS & m->pflags)
		return(mdoc_pwarn(m, ln, pos, EPRINT));
	return(mdoc_perr(m, ln, pos, EPRINT));
}


d509 1
a509 1
				if ( ! warn_print(mdoc, line, pos))
d512 1
a512 1
			if ( ! warn_print(mdoc, line, pos))
@


1.47
log
@no need to die from .Xr without arguments, we can just ignore it

ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.46 2010/04/03 16:30:42 schwarze Exp $ */
d76 1
a100 1
static	int	 pre_er(PRE_ARGS);
d112 1
a112 1
static	v_post	 posts_bd[] = { herr_eq0, bwarn_ge1, NULL };
d140 1
a140 1
static	v_pre	 pres_er[] = { pre_er, NULL };
d414 1
d622 9
a802 8
pre_er(PRE_ARGS)
{

	return(check_msec(mdoc, n, 2, 3, 9, 0));
}


static int
d1089 1
d1094 8
a1101 3
	for (i = 0; i < (int)n->args->argc; i++)
		if (n->args->argv[i].arg == MDOC_Column)
			break;
d1103 1
a1103 1
	if (i == (int)n->args->argc)
d1105 1
a1105 5

	if (n->args->argv[i].sz && mdoc->last->child)
		return(mdoc_nerr(mdoc, n, ECOLMIS));

	return(1);
d1317 2
a1318 2
	if (SEC_NAME != sec && SEC_NONE == mdoc->lastnamed &&
	    ! mdoc_nwarn(mdoc, mdoc->last, ESECNAME))
@


1.46
log
@When two conflicting list types are specified for the same list,
use the first, discard the second, and warn.  No need to bail out.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.44 2010/04/02 12:39:47 schwarze Exp $ */
d132 1
a132 1
static	v_post	 posts_xr[] = { eerr_ge1, NULL };
@


1.45
log
@* outside literal context in mdoc(7), handle blank lines like .Pp
* a missing NAME section in mdoc(7) need not be fatal

ok deraadt@@
@
text
@d621 6
a626 2
			if (type >= 0) 
				return(mdoc_nerr(mdoc, n, EMULTILIST));
@


1.44
log
@merge 1.9.22, keeping local patches
* convert mdoc tokens from #define to enum
* fix a segfault with .Xo/.Xc in explicit blocks
* Thorn is \*(Th, not \*(TH; noticed by Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.43 2010/03/02 00:38:59 schwarze Exp $ */
d1309 3
a1311 2
	if (SEC_NAME != sec && SEC_NONE == mdoc->lastnamed)
		return(mdoc_nerr(mdoc, mdoc->last, ESECNAME));
@


1.43
log
@Proper inter-sentence spacing for mdoc(7).
When a text line or a non-block macro line in the source code ends
in any of ".!?", consider that an end of sentence (EOS).
This makes Jason's rule "new sentence, new line" even more important.
Let the parser detect the EOS and insert a token into the AST.
Let the -Tascii frontend render the EOS token as a double space before
the next word.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.42 2010/02/18 02:11:26 schwarze Exp $ */
d43 1
a43 1
static	int	 check_parent(PRE_ARGS, int, enum mdoc_type);
d547 1
a547 1
check_parent(PRE_ARGS, int tok, enum mdoc_type t)
@


1.42
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.41 2010/01/01 22:20:24 schwarze Exp $ */
d272 1
d908 2
a909 1
		if (MDOC_TEXT != n->type) 
@


1.41
log
@.Bl may have .Sm as a child.
The comment in the source code and OK by kristaps@@;
merged upstream in rev. 1.55.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.55 2010/01/01 15:14:03 kristaps Exp $ */
a70 1
static	int	 eerr_le2(POST_ARGS);
d92 1
d129 1
d132 1
a132 1
static	v_post	 posts_xr[] = { eerr_ge1, eerr_le2, NULL };
d190 1
a190 1
	{ NULL, posts_text },			/* Vt */ 
a405 1
CHECK_ELEM_DEFN(le2, err, err_child_lt, 3)	/* eerr_le2() */
d886 26
@


1.40
log
@sync to 1.9.13: minor fixes:

correctness/functionality:
 - bugfix: properly ignore lines with only a dot in -man
 - bugfix: .Bl -ohang doesn't allow -width, warn about this
 - improve date string handling by new function mandoc_a2time
 - some HTML improvements
 - significant documentation additions in man.7 and mdoc.7

portability:
 - replace __dead by __attribute__((noreturn))
 - bugfix: correct .Dx rendering
 - some more library names for NetBSD

simplicity:
 - replace hand-rolled putchar(3)-loops by fwrite(3)
 - replace single-character printf(3) by putchar(3)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.39 2009/12/22 23:58:00 schwarze Exp $ */
d1085 6
d1093 4
a1096 3
		if (MDOC_BLOCK == n->type) 
			if (MDOC_It == n->tok)
				continue;
@


1.39
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.38 2009/10/27 21:40:07 schwarze Exp $ */
d193 1
a193 1
	{ NULL, posts_text },			/* %D */
d664 2
d806 2
@


1.38
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.37 2009/10/21 19:13:51 schwarze Exp $ */
a20 1
#include <errno.h>
@


1.37
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.36 2009/10/19 16:27:52 schwarze Exp $ */
a117 1
static	v_post	 posts_in[] = { eerr_eq1, NULL };
a122 1
static	v_post	 posts_pf[] = { eerr_eq1, NULL };
d129 1
d180 1
a180 1
	{ NULL, posts_in },			/* In */ 
d228 1
a228 1
	{ NULL, posts_pf },			/* Pf */
d259 1
a259 1
	{ NULL, NULL },				/* Lk */ 
d271 1
d695 2
d1154 2
@


1.36
log
@sync to 1.9.6: multiple improvements to references (.Rs)
 * validate and order .Rs child nodes
 * underline book title (.%B) and issuer (.%I)
 * enclose title of article (.%T) in quotes
 * avoid calling mdoc_verr directly, use a proper error code instead
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.35 2009/08/22 22:50:17 schwarze Exp $ */
d73 1
a92 1
static	int	 post_sp(POST_ARGS);
d127 1
a127 1
static	v_post	 posts_sp[] = { post_sp, NULL };
d194 1
a194 1
	{ NULL, posts_text },			/* %B */
d202 1
a202 1
	{ NULL, posts_text },			/* %T */
d407 1
d621 1
a621 1
			if (-1 != type) 
d625 4
d630 1
a630 1
			if (-1 != width)
d632 2
d637 1
a637 1
			if (-1 != offset)
d639 2
d647 1
a647 1
	if (-1 == type)
d658 1
a658 1
		if (-1 == width && ! mdoc_nwarn(mdoc, n, EMISSWIDTH))
d668 1
a668 1
		if (-1 != width && ! mdoc_nwarn(mdoc, n, ENOWIDTH))
a701 2
			/* FALLTHROUGH */
		case (MDOC_File):
a1129 31


static int
post_sp(POST_ARGS)
{
	long		 lval;
	char		*ep, *buf;

	if (NULL == mdoc->last->child)
		return(1);
	else if ( ! eerr_eq1(mdoc))
		return(0);

	assert(MDOC_TEXT == mdoc->last->child->type);
	buf = mdoc->last->child->string;
	assert(buf);
	
	/* From OpenBSD's strtol(3). */
	errno = 0;
	lval = strtol(buf, &ep, 10);
	if (buf[0] == '\0' || *ep != '\0')
		return(mdoc_nerr(mdoc, mdoc->last->child, ENUMFMT));

	if ((errno == ERANGE && (lval == LONG_MAX || lval == LONG_MIN)) ||
			(lval > INT_MAX || lval < 0))
		return(mdoc_nerr(mdoc, mdoc->last->child, ENUMFMT));

	return(1);
}


@


1.35
log
@sync to 1.9.1: .Rv and .Ex accept multiple arguments
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.34 2009/08/09 21:49:45 schwarze Exp $ */
d88 1
d125 1
d237 1
a237 1
	{ NULL, posts_wline },			/* Rs */
d1078 1
a1078 3
		return(mdoc_verr(mdoc, n->line, n->pos, 
				"bad child of parent %s",
				mdoc_macronames[mdoc->last->tok]));
d1163 44
@


1.34
log
@sync to 1.8.4: correct error message to complain about .An line arguments
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.33 2009/08/09 20:11:30 schwarze Exp $ */
a79 1
static	int	 post_args(POST_ARGS);
a115 1
static	v_post	 posts_ex[] = { eerr_eq0, post_args, NULL };
a123 1
static	v_post	 posts_rv[] = { eerr_eq0, post_args, NULL };
d172 1
a172 1
	{ pres_ex, posts_ex },			/* Ex */ 
d186 1
a186 1
	{ pres_rv, posts_rv },			/* Rv */
a911 10
		return(1);
	return(mdoc_nerr(mdoc, mdoc->last, ELINE));
}


static int
post_args(POST_ARGS)
{

	if (mdoc->last->args)
@


1.33
log
@sync to 1.8.3: In .Bl -column, handle one column in excess,
but still issue a warning
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.32 2009/08/09 17:38:24 schwarze Exp $ */
d911 1
a911 1
		return(mdoc_nerr(mdoc, mdoc->last, ELINE));
d1218 1
@


1.32
log
@sync to 1.8.2: more .Bl -column fixes, in particular:
1) -column implies -compact
2) do not die from fewer columns than specified (more are still fatal)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.31 2009/07/26 01:59:46 schwarze Exp $ */
d1028 1
a1028 1
		if (i < cols) {
@


1.31
log
@sync to 1.8.1: support .br and .sp
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.30 2009/07/19 12:26:57 schwarze Exp $ */
d1027 7
a1033 1
		if (i == cols)
d1035 6
a1040 3
		return(mdoc_verr(mdoc, mdoc->last->line, mdoc->last->pos,
				"column mismatch (have %d, want %d)", 
				i, cols));
@


1.30
log
@The abbreviation for .Bf -symbolic is .Bf Sy, not .Bf Sm;
"Gah! Fixed." kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.29 2009/07/18 20:19:50 schwarze Exp $ */
d21 2
a72 1
static	int	 ewarn_eq0(POST_ARGS);
d92 1
a125 1
static	v_post	 posts_pp[] = { ewarn_eq0, NULL };
d128 1
d159 1
a159 1
	{ NULL, posts_pp },			/* Pp */ 
d260 1
a260 1
	{ NULL, posts_pp },			/* Lp */ 
d271 2
a404 1
CHECK_ELEM_DEFN(eq0, warn, warn_child_eq, 0)	/* ewarn_eq0() */
d1127 31
@


1.29
log
@sync to 1.8.0: a bad .St argument causes an error, not a warning
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.28 2009/07/18 20:15:07 schwarze Exp $ */
d858 1
a858 1
	else if (0 == strcmp(p, "Sm"))
@


1.28
log
@sync to 1.8.0: white space fixes, no code change
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.27 2009/07/18 19:44:38 schwarze Exp $ */
d1132 1
a1132 1
	return(mdoc_nwarn(mdoc, mdoc->last, EBADSTAND));
@


1.27
log
@sync to 1.8.0: move mdoc_a2att, mdoc_a2st, and mdoc_a2lib to libmdoc
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.26 2009/07/18 16:21:52 schwarze Exp $ */
d31 2
a32 3
#define	PRE_ARGS	struct mdoc *mdoc, const struct mdoc_node *n
#define	POST_ARGS	struct mdoc *mdoc

d42 6
a47 6
static	int	check_parent(PRE_ARGS, int, enum mdoc_type);
static	int	check_msec(PRE_ARGS, ...);
static	int	check_sec(PRE_ARGS, ...);
static	int	check_stdarg(PRE_ARGS);
static	int	check_text(struct mdoc *, int, int, const char *);
static	int	check_argv(struct mdoc *, 
d50 1
a50 1
static	int	check_args(struct mdoc *, 
d52 8
a59 8
static	int	err_child_lt(struct mdoc *, const char *, int);
static	int	warn_child_lt(struct mdoc *, const char *, int);
static	int	err_child_gt(struct mdoc *, const char *, int);
static	int	warn_child_gt(struct mdoc *, const char *, int);
static	int	err_child_eq(struct mdoc *, const char *, int);
static	int	warn_child_eq(struct mdoc *, const char *, int);
static	int	warn_print(struct mdoc *, int, int);
static	int	warn_count(struct mdoc *, const char *, 
d61 1
a61 1
static	int	err_count(struct mdoc *, const char *, 
d63 86
a148 83
static	int	pre_an(PRE_ARGS);
static	int	pre_bd(PRE_ARGS);
static	int	pre_bl(PRE_ARGS);
static	int	pre_cd(PRE_ARGS);
static	int	pre_dd(PRE_ARGS);
static	int	pre_display(PRE_ARGS);
static	int	pre_dt(PRE_ARGS);
static	int	pre_er(PRE_ARGS);
static	int	pre_ex(PRE_ARGS);
static	int	pre_fd(PRE_ARGS);
static	int	pre_it(PRE_ARGS);
static	int	pre_lb(PRE_ARGS);
static	int	pre_os(PRE_ARGS);
static	int	pre_rv(PRE_ARGS);
static	int	pre_sh(PRE_ARGS);
static	int	pre_ss(PRE_ARGS);
static	int	herr_ge1(POST_ARGS);
static	int	hwarn_le1(POST_ARGS);
static	int	herr_eq0(POST_ARGS);
static	int	eerr_eq0(POST_ARGS);
static	int	eerr_le2(POST_ARGS);
static	int	eerr_eq1(POST_ARGS);
static	int	eerr_ge1(POST_ARGS);
static	int	ewarn_eq0(POST_ARGS);
static	int	berr_ge1(POST_ARGS);
static	int	bwarn_ge1(POST_ARGS);
static	int	hwarn_eq1(POST_ARGS);
static	int	ewarn_ge1(POST_ARGS);
static	int	ebool(POST_ARGS);
static	int	post_an(POST_ARGS);
static	int	post_args(POST_ARGS);
static	int	post_at(POST_ARGS);
static	int	post_bf(POST_ARGS);
static	int	post_bl(POST_ARGS);
static	int	post_bl_head(POST_ARGS);
static	int	post_it(POST_ARGS);
static	int	post_nm(POST_ARGS);
static	int	post_root(POST_ARGS);
static	int	post_sh(POST_ARGS);
static	int	post_sh_body(POST_ARGS);
static	int	post_sh_head(POST_ARGS);
static	int	post_st(POST_ARGS);

static	v_pre	pres_an[] = { pre_an, NULL };
static	v_pre	pres_bd[] = { pre_display, pre_bd, NULL };
static	v_pre	pres_bl[] = { pre_bl, NULL };
static	v_pre	pres_cd[] = { pre_cd, NULL };
static	v_pre	pres_dd[] = { pre_dd, NULL };
static	v_pre	pres_d1[] = { pre_display, NULL };
static	v_pre	pres_dt[] = { pre_dt, NULL };
static	v_pre	pres_er[] = { pre_er, NULL };
static	v_pre	pres_ex[] = { pre_ex, NULL };
static	v_pre	pres_fd[] = { pre_fd, NULL };
static	v_pre	pres_it[] = { pre_it, NULL };
static	v_pre	pres_lb[] = { pre_lb, NULL };
static	v_pre	pres_os[] = { pre_os, NULL };
static	v_pre	pres_rv[] = { pre_rv, NULL };
static	v_pre	pres_sh[] = { pre_sh, NULL };
static	v_pre	pres_ss[] = { pre_ss, NULL };
static	v_post	posts_bool[] = { eerr_eq1, ebool, NULL };
static	v_post	posts_bd[] = { herr_eq0, bwarn_ge1, NULL };
static	v_post	posts_text[] = { eerr_ge1, NULL };
static	v_post	posts_wtext[] = { ewarn_ge1, NULL };
static	v_post	posts_notext[] = { eerr_eq0, NULL };
static	v_post	posts_wline[] = { bwarn_ge1, herr_eq0, NULL };
static	v_post	posts_sh[] = { herr_ge1, bwarn_ge1, post_sh, NULL };
static	v_post	posts_bl[] = { bwarn_ge1, post_bl, NULL };
static	v_post	posts_it[] = { post_it, NULL };
static	v_post	posts_in[] = { eerr_eq1, NULL };
static	v_post	posts_ss[] = { herr_ge1, NULL };
static	v_post	posts_pf[] = { eerr_eq1, NULL };
static	v_post	posts_lb[] = { eerr_eq1, NULL };
static	v_post	posts_st[] = { eerr_eq1, post_st, NULL };
static	v_post	posts_pp[] = { ewarn_eq0, NULL };
static	v_post	posts_ex[] = { eerr_eq0, post_args, NULL };
static	v_post	posts_rv[] = { eerr_eq0, post_args, NULL };
static	v_post	posts_an[] = { post_an, NULL };
static	v_post	posts_at[] = { post_at, NULL };
static	v_post	posts_xr[] = { eerr_ge1, eerr_le2, NULL };
static	v_post	posts_nd[] = { berr_ge1, NULL };
static	v_post	posts_nm[] = { post_nm, NULL };
static	v_post	posts_bf[] = { hwarn_le1, post_bf, NULL };
static	v_post	posts_fo[] = { hwarn_eq1, bwarn_ge1, NULL };
d273 1
a273 2
mdoc_valid_pre(struct mdoc *mdoc, 
		const struct mdoc_node *n)
a300 8

	/*
	 * This check occurs after the macro's children have been filled
	 * in: postfix validation.  Since this happens when we're
	 * rewinding the scope tree, it's possible to have multiple
	 * invocations (as by design, for now), we set bit MDOC_VALID to
	 * indicate that we've validated.
	 */
@


1.26
log
@sync to 1.8.0: avoid duplicate warning about a malformed NAME section
when the next section following NAME is a custom section
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.25 2009/07/18 15:34:27 schwarze Exp $ */
d869 10
@


1.25
log
@sync to 1.8.0: .Nd is now a BFI, was an ELEM,
and use \(en instead of \- for .Nd
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.24 2009/07/13 01:00:50 schwarze Exp $ */
d1151 1
a1151 1
	if (SEC_NAME != mdoc->lastnamed)
@


1.24
log
@fix a trivial pasto that crept into 1.7.23; also submitted upstream
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.23 2009/07/13 00:33:40 schwarze Exp $ */
d88 1
d143 1
d180 1
a180 1
	{ NULL, posts_wtext },			/* Nd */
d407 1
d1172 1
a1172 1
	if (MDOC_ELEM == n->type && MDOC_Nd == n->tok)
@


1.23
log
@sync to 1.7.24: mdoc_nwarn/mdoc_nerr got mixed up;
fix from joerg at netbsd via kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.22 2009/07/12 23:19:48 schwarze Exp $ */
d537 1
a537 1
		if ( ! mdoc_perr(mdoc, line, pos, EESCAPE))
@


1.22
log
@sync to 1.7.24: make .In handling more similar to new groff
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.21 2009/07/12 22:35:08 schwarze Exp $ */
d1215 2
a1216 1
		return(mdoc_nwarn(mdoc, mdoc->last, ESECREP));
d1218 2
a1219 1
		return(mdoc_nwarn(mdoc, mdoc->last, ESECOOO));
@


1.21
log
@sync to 1.7.23: pass warning code to mdoc_pwarn() instead of warning message
define additional warning macro mdoc_nwarn()
remove obsolete warning functions mdoc_warn(), pwarn(), vwarn(), nwarn()
remove various now unused "enum mdoc_warn" and "enum mwarn"
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.20 2009/07/12 21:45:44 schwarze Exp $ */
a87 1
static	int	ewarn_eq1(POST_ARGS);
d131 1
a131 1
static	v_post	posts_in[] = { ewarn_eq1, NULL };
a404 1
CHECK_ELEM_DEFN(eq1, warn, warn_child_eq, 1)	/* ewarn_eq1() */
@


1.20
log
@sync to 1.7.23: pass error code to mdoc_perr() instead of error string
and use the so improved mdoc_nerr() at many places;
get rid of now unused static functions perr()
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.19 2009/07/12 21:08:29 schwarze Exp $ */
a33 20
enum	mwarn {
	WPRINT,
	WNOWIDTH,
	WMISSWIDTH,
	WESCAPE,
	WWRONGMSEC,
	WSECOOO,
	WSECREP,
	WBADSTAND,
	WNAMESECINC,
	WNOMULTILINE,
	WMULTILINE,
	WLINE,
	WNOLINE,
	WPROLOOO,
	WPROLREP,
	WARGVAL,
	WBADSEC,
	WBADMSEC
};
a42 1
static	int	pwarn(struct mdoc *, int, int, enum mwarn);
a106 3
#define	vwarn(m, t) nwarn((m), (m)->last, (t))
#define	nwarn(m, n, t) pwarn((m), (n)->line, (n)->pos, (t))

a327 75
pwarn(struct mdoc *m, int line, int pos, enum mwarn type)
{
	char		 *p;
	enum mdoc_warn	  c;

	c = WARN_SYNTAX;
	p = NULL;
	switch (type) {
	case (WBADMSEC):
		p = "inappropriate manual section";
		c = WARN_COMPAT;
		break;
	case (WBADSEC):
		p = "inappropriate document section";
		c = WARN_COMPAT;
		break;
	case (WARGVAL):
		p = "argument value suggested";
		c = WARN_COMPAT;
		break;
	case (WPROLREP):
		p = "prologue macros repeated";
		c = WARN_COMPAT;
		break;
	case (WPROLOOO):
		p = "prologue macros out-of-order";
		c = WARN_COMPAT;
		break;
	case (WNOWIDTH):
		p = "superfluous width argument";
		break;
	case (WMISSWIDTH):
		p = "missing width argument";
		break;
	case (WPRINT):
		p = "invalid character";
		break;
	case (WESCAPE):
		p = "invalid escape sequence";
		break;
	case (WNOLINE):
		p = "suggested no line arguments";
		break;
	case (WLINE):
		p = "suggested line arguments";
		break;
	case (WMULTILINE):
		p = "suggested multi-line arguments";
		break;
	case (WNOMULTILINE):
		p = "suggested no multi-line arguments";
		break;
	case (WWRONGMSEC):
		p = "document section in wrong manual section";
		c = WARN_COMPAT;
		break;
	case (WSECOOO):
		p = "document section out of conventional order";
		break;
	case (WSECREP):
		p = "document section repeated";
		break;
	case (WBADSTAND):
		p = "unknown standard";
		break;
	case (WNAMESECINC):
		p = "NAME section contents incomplete/badly-ordered";
		break;
	}
	assert(p);
	return(mdoc_pwarn(m, line, pos, c, p));
}


static int
d332 1
a332 1
		return(pwarn(m, ln, pos, WPRINT));
d426 1
a426 1
	return(nwarn(mdoc, n, WARGVAL));
d450 1
a450 1
	return(nwarn(mdoc, n, WBADSEC));
d472 1
a472 1
	return(nwarn(mdoc, n, WBADMSEC));
d653 1
a653 1
		if (-1 == width && ! nwarn(mdoc, n, WMISSWIDTH))
d663 1
a663 1
		if (-1 != width && ! nwarn(mdoc, n, WNOWIDTH))
d802 1
a802 1
		if ( ! nwarn(mdoc, n, WPROLOOO))
d805 1
a805 1
		if ( ! nwarn(mdoc, n, WPROLREP))
d816 1
a816 1
		if ( ! nwarn(mdoc, n, WPROLOOO))
d819 1
a819 1
		if ( ! nwarn(mdoc, n, WPROLREP))
d830 1
a830 1
		if ( ! nwarn(mdoc, n, WPROLOOO))
d833 1
a833 1
		if ( ! nwarn(mdoc, n, WPROLREP))
d977 1
a977 1
			if ( ! vwarn(mdoc, WLINE))
d988 1
a988 1
			if ( ! vwarn(mdoc, WLINE))
d991 1
a991 1
			if ( ! vwarn(mdoc, WMULTILINE))
d1004 1
a1004 1
			if ( ! vwarn(mdoc, WNOLINE))
d1007 1
a1007 1
			if ( ! vwarn(mdoc, WMULTILINE))
d1012 1
a1012 1
			if ( ! vwarn(mdoc, WLINE))
d1015 1
a1015 1
			if ( ! vwarn(mdoc, WNOMULTILINE))
d1128 1
a1128 1
	return(vwarn(mdoc, WBADSTAND));
d1160 1
a1160 1
		return(vwarn(mdoc, WNAMESECINC));
d1167 1
a1167 1
		if ( ! vwarn(mdoc, WNAMESECINC))
d1173 1
a1173 1
	return(vwarn(mdoc, WNAMESECINC));
d1217 1
a1217 1
		return(vwarn(mdoc, WSECREP));
d1219 1
a1219 1
		return(vwarn(mdoc, WSECOOO));
d1234 1
a1234 1
			return(vwarn(mdoc, WWRONGMSEC));
@


1.19
log
@sync to 1.7.23: pass error code to mdoc_nerr() instead of error string
and use the so improved mdoc_nerr() at many places
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.18 2009/07/12 20:30:27 schwarze Exp $ */
a63 1
static	int	perr(struct mdoc *, int, int, enum merr);
a128 1
#define	verr(m, t) nerr((m), (m)->last, (t))
a129 1
#define	nerr(m, n, t) perr((m), (n)->line, (n)->pos, (t))
a351 64
perr(struct mdoc *m, int line, int pos, enum merr type)
{
	char		 *p;
	
	p = NULL;
	switch (type) {
	case (ETOOLONG):
		p = "text argument too long";
		break;
	case (EESCAPE):
		p = "invalid escape sequence";
		break;
	case (EPRINT):
		p = "invalid character";
		break;
	case (ENESTDISP):
		p = "displays may not be nested";
		break;
	case (EBOOL):
		p = "expected boolean value";
		break;
	case (EARGREP):
		p = "argument repeated";
		break;
	case (EMULTIDISP):
		p = "multiple display types specified";
		break;
	case (EMULTILIST):
		p = "multiple list types specified";
		break;
	case (ELISTTYPE):
		p = "missing list type";
		break;
	case (EDISPTYPE):
		p = "missing display type";
		break;
	case (ESECNAME):
		p = "the NAME section must come first";
		break;
	case (ELINE):
		p = "expected line arguments";
		break;
	case (ENOPROLOGUE):
		p = "document has no prologue";
		break;
	case (ENODAT):
		p = "document has no data";
		break;
	case (ECOLMIS):
		p = "column syntax style mismatch";
		break;
	case (EATT):
		p = "expected valid AT&T symbol";
		break;
	case (ENAME):
		p = "default name not yet set";
		break;
	}
	assert(p);
	return(mdoc_perr(m, line, pos, p));
}


static int
d429 1
d432 1
a432 1
	return(perr(m, ln, pos, EPRINT));
d637 2
a638 2
			return(perr(mdoc, line, pos, EESCAPE));
		if ( ! pwarn(mdoc, line, pos, WESCAPE))
@


1.18
log
@sync to 1.7.23: unify the various "enum merr" into libman.h and libmdoc.h,
use it as a new argument to mdoc_err(), the same way as for for man_err(),
and use string tables instead of switch statements to select error messages
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.17 2009/07/12 19:05:52 schwarze Exp $ */
d672 1
a672 1
		return(nerr(m, n, ENAME));
d747 1
a747 1
	return(nerr(mdoc, n, ENESTDISP));
d759 1
a759 1
		return(nerr(mdoc, n, ELISTTYPE));
d790 1
a790 1
				return(nerr(mdoc, n, EMULTILIST));
d795 1
a795 1
				return(nerr(mdoc, n, EARGREP));
d800 1
a800 1
				return(nerr(mdoc, n, EARGREP));
d808 1
a808 1
		return(nerr(mdoc, n, ELISTTYPE));
d847 1
a847 1
		return(nerr(mdoc, n, EDISPTYPE));
d866 1
a866 1
			return(nerr(mdoc, n, EMULTIDISP));
d873 1
a873 1
	return(nerr(mdoc, n, EDISPTYPE));
d1016 1
a1016 1
		return(mdoc_nerr(mdoc, mdoc->last, "one argument expected"));
d1021 1
a1021 1
		return(mdoc_nerr(mdoc, mdoc->last, "text argument expected"));
d1032 1
a1032 1
	return(mdoc_nerr(mdoc, head->child, "invalid font mode"));
d1044 1
a1044 1
	return(verr(mdoc, ENAME));
d1055 1
a1055 1
		return(verr(mdoc, EATT));
d1058 1
a1058 1
	return(verr(mdoc, EATT));
d1069 1
a1069 1
		return(verr(mdoc, ELINE));
d1074 1
a1074 1
	return(verr(mdoc, ELINE));
d1084 1
a1084 1
	return(verr(mdoc, ELINE));
d1099 1
a1099 1
		return(verr(mdoc, ELISTTYPE));
d1137 1
a1137 1
		return(verr(mdoc, ELISTTYPE));
d1215 1
a1215 1
		return(nerr(mdoc, n, ECOLMIS));
d1265 1
a1265 1
	return(nerr(mdoc, n, EBOOL));
d1274 1
a1274 1
		return(verr(mdoc, ENODAT));
d1276 1
a1276 1
		return(verr(mdoc, ENOPROLOGUE));
d1279 1
a1279 1
		return(verr(mdoc, ENODAT));
d1281 1
a1281 1
		return(verr(mdoc, ENODAT));
d1363 1
a1363 1
			return(nerr(mdoc, n, ETOOLONG));
d1367 1
a1367 1
			return(nerr(mdoc, n, ETOOLONG));
d1378 1
a1378 1
		return(verr(mdoc, ESECNAME));
@


1.17
log
@sync to 1.7.23: third step to get rid of enum mdoc_warn:
mdoc_verr is not using enum mdoc_warn, so use it at a few more places
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.16 2009/07/12 18:35:57 schwarze Exp $ */
a33 20
enum	merr {
	ETOOLONG,
	EESCAPE,
	EPRINT,
	ENODATA,
	ENOPROLOGUE,
	ELINE,
	EATT,
	ENAME,
	ELISTTYPE,
	EDISPTYPE,
	EMULTIDISP,
	ESECNAME,
	EMULTILIST,
	EARGREP,
	EBOOL,
	ECOLMIS,
	ENESTDISP
};

d400 1
a400 1
	case (ENODATA):
d1016 1
a1016 1
		return(mdoc_err(mdoc, "one argument expected"));
d1021 1
a1021 1
		return(mdoc_err(mdoc, "text argument expected"));
d1274 1
a1274 1
		return(verr(mdoc, ENODATA));
d1279 1
a1279 1
		return(verr(mdoc, ENODATA));
d1281 1
a1281 1
		return(verr(mdoc, ENODATA));
@


1.16
log
@sync to 1.7.23: second step to get rid of enum mdoc_warn:
remove type from mdoc_vwarn arguments, and use this function where apropriate
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.15 2009/07/08 00:04:10 schwarze Exp $ */
d537 1
a537 1
	return(mdoc_err(m, 
d743 1
a743 1
	return(mdoc_nerr(mdoc, n, "require parent %s",
d933 2
a934 1
	return(mdoc_nerr(mdoc, n, "only one argument allowed"));
d1207 3
a1209 2
		return(mdoc_err(mdoc, "column mismatch (have "
					"%d, want %d)", i, cols));
d1258 2
a1259 1
		return(mdoc_nerr(mdoc, n, "bad child of parent %s",
@


1.15
log
@sync to 1.7.21: unified escape sequence validation for mdoc and man
checking is still incomplete, but a bit better, in particular for man
now in sync with 1.7.22: the only 1.7.22 diff was already in
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.14 2009/07/06 22:33:58 schwarze Exp $ */
d527 1
a527 1
	return(mdoc_warn(m, WARN_SYNTAX, 
@


1.14
log
@remove unused WDEPCOL warning that became unused in 1.7.19
ok kristaps@@  and contained in 1.7.21
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.13 2009/06/26 22:43:40 schwarze Exp $ */
d26 1
d702 1
a702 1
	size_t		 c;
d704 1
a704 1
	for ( ; *p; p++) {
d716 1
a716 1
		c = mdoc_isescape(p);
d718 2
a719 1
			p += (int)c - 1;
@


1.13
log
@the forms \*x, \*(xx and \*[xxx] are not deprecated, so revert most of 1.8;
noticed by jmc@@;  ok kristaps@@;  to be included in 1.7.21
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.12 2009/06/23 23:02:54 schwarze Exp $ */
a57 1
	WDEPCOL,
a463 4
		c = WARN_COMPAT;
		break;
	case (WDEPCOL):
		p = "deprecated column argument syntax";
@


1.12
log
@sync to 1.7.20: like for the -man case, add an nchild counter to the -mdoc
nodes, simplifying the validation code; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.11 2009/06/21 19:09:58 schwarze Exp $ */
a57 1
	WDEPESC,
a482 3
	case (WDEPESC):
		p = "deprecated special-character escape";
		break;
a721 4
			/* See if form is deprecated. */
			if ('*' == p[1]) 
				if ( ! pwarn(mdoc, line, pos, WDEPESC))
					return(0);
@


1.11
log
@sync to 1.7.19: .Bl -column  now correctly handles tail entries,
for example:  .Bl -column -compact -offset ... args ...
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.10 2009/06/21 18:15:03 schwarze Exp $ */
a101 1
static	int	count_child(struct mdoc *);
a549 13
static inline int
count_child(struct mdoc *mdoc)
{
	int		  i;
	struct mdoc_node *n;

	for (i = 0, n = mdoc->last->child; n; n = n->next, i++)
		/* Do nothing */ ;

	return(i);
}


d560 1
a560 2
	int i; 							\
	if ((i = count_child(mdoc)) ineq sz) 			\
d562 1
a562 1
	return(lvl##_count(mdoc, #ineq, sz, p, i)); 		\
@


1.10
log
@sync to 1.7.19: kristaps@@ rewrote post_bf to reduce nesting
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.9 2009/06/19 07:20:19 schwarze Exp $ */
d49 1
d142 1
d179 1
a179 1
static	v_post	posts_bl[] = { herr_eq0, bwarn_ge1, post_bl, NULL };
d425 3
d800 1
a800 1
	int		 pos, col, type, width, offset;
d809 1
a809 1
	type = offset = width = col = -1;
a837 1
			col = pos;
a880 16
	/*
	 * General validation of fields.
	 */

	switch (type) {
	case (MDOC_Column):
		assert(col >= 0);
		if (0 == n->args->argv[col].sz)
			break;
		if ( ! nwarn(mdoc, n, WDEPCOL))
			return(0);
		break;
	default:
		break;
	}

d1243 23
d1270 2
@


1.9
log
@sync to 1.7.19: more elegant section handling
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.8 2009/06/19 00:07:06 schwarze Exp $ */
d1072 7
a1078 4
	if (NULL == mdoc->last->args) {
		if (NULL == head->child || 
				MDOC_TEXT != head->child->type)
			return(mdoc_err(mdoc, "text argument expected"));
d1080 1
a1080 9
		p = head->child->string;
		if (0 == strcmp(p, "Em"))
			return(1);
		else if (0 == strcmp(p, "Li"))
			return(1);
		else if (0 == strcmp(p, "Sm"))
			return(1);
		return(mdoc_nerr(mdoc, head->child, "invalid font"));
	}
d1082 6
a1087 2
	if (head->child)
		return(mdoc_err(mdoc, "one argument expected"));
d1089 1
a1089 1
	return(1);
@


1.8
log
@sync to 1.7.19: escape sequences of the forms \*x and \*(xx are deprecated
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.7 2009/06/18 23:34:53 schwarze Exp $ */
d45 1
a119 1
static	int	pre_prologue(PRE_ARGS);
d158 1
a158 1
static	v_pre	pres_dd[] = { pre_prologue, pre_dd, NULL };
d160 1
a160 1
static	v_pre	pres_dt[] = { pre_prologue, pre_dt, NULL };
d166 1
a166 1
static	v_pre	pres_os[] = { pre_prologue, pre_os, NULL };
d411 3
a1019 8
pre_prologue(PRE_ARGS)
{

	return(check_sec(mdoc, n, SEC_PROLOGUE, SEC_CUSTOM));
}


static int
d1306 1
a1306 1
	if (SEC_PROLOGUE == mdoc->lastnamed)
d1387 1
a1387 3
	assert(MDOC_Sh == mdoc->last->tok);

	/* This is just concat() inlined, which is irritating. */
a1388 1
	buf[0] = 0;
d1390 1
d1392 1
d1403 4
a1406 1
	/* The NAME section should always be first. */
d1408 2
a1409 2
	if (SEC_BODY == mdoc->lastnamed && SEC_NAME != sec)
		return(vwarn(mdoc, WSECOOO));
a1411 3

	/* Check for repeated or out-of-order sections. */

d1417 4
a1420 1
	/* Check particular section/manual section conventions. */
@


1.7
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.6 2009/06/18 21:08:29 schwarze Exp $ */
d56 1
d477 3
a718 2
	/* FIXME: indicate deprecated escapes \*(xx and \*x. */

d733 4
@


1.6
log
@sync to 1.7.16: The .Er macro may also be used in sections (3) and (9).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.5 2009/06/18 20:59:49 schwarze Exp $ */
d194 1
a194 1
	{ NULL, NULL }, 			/* \" */
a300 1
	{ NULL, NULL },				/* Ap */
@


1.5
log
@sync to 1.7.16: use dedicated warning types for list validation
instead of hand-rolled warnings
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.4 2009/06/18 01:19:02 schwarze Exp $ */
d999 1
a999 1
	return(check_msec(mdoc, n, 2, 0));
@


1.4
log
@sync to 1.7.16: make a couple of macros callable, reserve "|",
and some tweaks to .Lk
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.3 2009/06/17 23:18:06 schwarze Exp $ */
d53 2
d56 1
a440 3
	case (WPRINT):
		p = "invalid character";
		break;
d461 13
d787 1
a787 1
	int		 i, type, width, offset;
d796 1
a796 1
	type = offset = width = -1;
d799 2
a800 2
	for (i = 0; i < (int)n->args->argc; i++)
		switch (n->args->argv[i].arg) {
d822 5
a826 5
			if (-1 == type) {
				type = n->args->argv[i].arg;
				break;
			}
			return(nerr(mdoc, n, EMULTILIST));
d828 4
a831 5
			if (-1 == width) {
				width = n->args->argv[i].arg;
				break;
			}
			return(nerr(mdoc, n, EARGREP));
d833 4
a836 5
			if (-1 == offset) {
				offset = n->args->argv[i].arg;
				break;
			}
			return(nerr(mdoc, n, EARGREP));
d844 6
d851 4
d862 15
a876 1
		if (-1 == width)
d878 3
a880 9
		return(mdoc_nwarn(mdoc, n, WARN_SYNTAX,
				"superfluous %s argument",
				mdoc_argnames[MDOC_Width]));
	case (MDOC_Tag):
		if (-1 != width)
			break;
		return(mdoc_nwarn(mdoc, n, WARN_SYNTAX, 
				"suggest %s argument", 
				mdoc_argnames[MDOC_Width]));
@


1.3
log
@sync to 1.7.16: rename static function printwarn to warn_print
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
d300 1
a300 1
	{ NULL, posts_text },			/* Lk */ 
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.9 2009/06/12 09:18:00 kristaps Exp $ */
a79 1
static	int	printwarn(struct mdoc *, int, int);
d97 1
d498 8
a698 9
printwarn(struct mdoc *m, int ln, int pos)
{
	if (MDOC_IGN_CHARS & m->pflags)
		return(pwarn(m, ln, pos, WPRINT));
	return(perr(m, ln, pos, EPRINT));
}


static int
d708 1
a708 1
				if ( ! printwarn(mdoc, line, pos))
d711 1
a711 1
			if ( ! printwarn(mdoc, line, pos))
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: mdoc_validate.c,v 1.3 2009/04/02 16:37:40 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@

