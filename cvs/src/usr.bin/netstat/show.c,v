head	1.53;
access;
symbols
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.50.0.2
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.53
date	2017.01.21.11.32.04;	author guenther;	state Exp;
branches;
next	1.52;
commitid	DpBZlpar7mq0CJFq;

1.52
date	2016.09.03.14.23.14;	author phessler;	state Exp;
branches;
next	1.51;
commitid	rJW7JJ1v8NrTSfc8;

1.51
date	2016.09.01.09.41.34;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	wRPxUwlIhFV2EtnL;

1.50
date	2016.07.13.08.40.46;	author mpi;	state Exp;
branches;
next	1.49;
commitid	VkTTZG0LgjCK3eLa;

1.49
date	2015.09.11.20.10.26;	author mpi;	state Exp;
branches;
next	1.48;
commitid	Grl16jFIcIlVkkgd;

1.48
date	2015.04.27.09.54.04;	author benno;	state Exp;
branches;
next	1.47;
commitid	XPj13hNRfwBUDzu8;

1.47
date	2015.02.12.23.31.12;	author claudio;	state Exp;
branches;
next	1.46;
commitid	subnpd857rOYrBI2;

1.46
date	2015.02.09.12.25.03;	author claudio;	state Exp;
branches;
next	1.45;
commitid	83gy3puTH63xWYWh;

1.45
date	2015.02.06.03.22.00;	author reyk;	state Exp;
branches;
next	1.44;
commitid	2ShTul7wSa8iiu5L;

1.44
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	Uu5nFG3wCl0LACBb;

1.43
date	2014.10.23.16.45.57;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	IvHOKuDOlqzgwkmv;

1.42
date	2014.05.08.09.28.08;	author mpi;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.17.15.36.53;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2013.11.21.17.32.13;	author mikeb;	state Exp;
branches;
next	1.39;

1.39
date	2013.11.13.21.19.30;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.20.15.23.37;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.16.10.53.14;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2012.03.17.10.16.41;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2011.11.01.17.30.04;	author mikeb;	state Exp;
branches;
next	1.34;

1.34
date	2010.10.11.12.33.36;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.30.12.55.12;	author bluhm;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.29.16.35.40;	author bluhm;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.19.13.07.15;	author chl;	state Exp;
branches;
next	1.30;

1.30
date	2010.03.23.16.26.01;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.14.00.02.08;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.11.08.28.44;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.07.09.09.31;	author martynas;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.05.03.26.59;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.27.11.35.57;	author michele;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.31.18.03.42;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.23.18.28.45;	author chris;	state Exp;
branches;
next	1.22;

1.22
date	2009.05.23.17.03.06;	author chris;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.28.12.09.36;	author michele;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.06.19.58.31;	author chl;	state Exp;
branches;
next	1.19;

1.19
date	2009.02.03.16.44.15;	author michele;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.26.17.28.09;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.08.12.52.36;	author michele;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.15.21.18.37;	author michele;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.15.20.16.20;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.15.20.13.10;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.08.07.19.42;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.14.18.35.46;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.05.20.29.05;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.25.11.50.47;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.24.20.36.34;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.07.21.15.43.42;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.19.05.37.10;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.04.12.20.24;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.23.10.59.38;	author pyr;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.29.10.09.09;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.30.19.42.58;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.27.19.16.37;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.53
log
@The POSIX APIs that that sockaddrs all ignore the s*_len field in the
incoming socket, so userspace doesn't need to set it unless it has its
own reasons for tracking the size along with the sockaddr.

ok phessler@@ deraadt@@ florian@@
@
text
@/*	$OpenBSD: show.c,v 1.52 2016/09/03 14:23:14 phessler Exp $	*/
/*	$NetBSD: show.c,v 1.1 1996/11/15 18:01:41 gwr Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/socket.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netmpls/mpls.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "netstat.h"

char	*any_ntoa(const struct sockaddr *);
char	*link_print(struct sockaddr *);
char	*label_print(struct sockaddr *);

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))

/*
 * Definitions for showing gateway flags.
 */
struct bits {
	int	b_mask;
	char	b_val;
};
static const struct bits bits[] = {
	{ RTF_UP,	'U' },
	{ RTF_GATEWAY,	'G' },
	{ RTF_HOST,	'H' },
	{ RTF_REJECT,	'R' },
	{ RTF_DYNAMIC,	'D' },
	{ RTF_MODIFIED,	'M' },
	{ RTF_DONE,	'd' }, /* Completed -- for routing messages only */
	{ RTF_CLONING,	'C' },
	{ RTF_MULTICAST,'m' },
	{ RTF_LLINFO,	'L' },
	{ RTF_STATIC,	'S' },
	{ RTF_BLACKHOLE,'B' },
	{ RTF_PROTO3,	'3' },
	{ RTF_PROTO2,	'2' },
	{ RTF_PROTO1,	'1' },
	{ RTF_CLONED,	'c' },
	{ RTF_CACHED,	'h' },
	{ RTF_MPATH,	'P' },
	{ RTF_MPLS,	'T' },
	{ RTF_LOCAL,	'l' },
	{ RTF_BFD,	'F' },
	{ RTF_BROADCAST,'b' },
	{ RTF_CONNECTED,'n' },
	{ 0 }
};

int	 WID_DST(int);
void	 p_rtentry(struct rt_msghdr *);
void	 pr_family(int);
void	 p_sockaddr(struct sockaddr *, struct sockaddr *, int, int);
void	 p_sockaddr_mpls(struct sockaddr *, struct sockaddr *, int, int);
void	 p_flags(int, char *);
char	*routename4(in_addr_t);
char	*routename6(struct sockaddr_in6 *);

size_t
get_sysctl(const int *mib, u_int mcnt, char **buf)
{
	size_t needed;

	while (1) {
		if (sysctl(mib, mcnt, NULL, &needed, NULL, 0) == -1)
			err(1, "sysctl-estimate");
		if (needed == 0)
			break;
		if ((*buf = realloc(*buf, needed)) == NULL)
			err(1, NULL);
		if (sysctl(mib, mcnt, *buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			err(1, "sysctl");
		}
		break;
	}

	return needed;
}

/*
 * Print routing tables.
 */
void
p_rttables(int af, u_int tableid)
{
	struct rt_msghdr *rtm;
	char *buf = NULL, *next, *lim = NULL;
	size_t needed;
	int mib[7], mcnt;
	struct sockaddr *sa;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = af;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
	mib[6] = tableid;
	mcnt = 7;

	needed = get_sysctl(mib, mcnt, &buf);
	lim = buf + needed;

	printf("Routing tables\n");

	if (buf) {
		for (next = buf; next < lim; next += rtm->rtm_msglen) {
			rtm = (struct rt_msghdr *)next;
			if (rtm->rtm_version != RTM_VERSION)
				continue;
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			p_rtentry(rtm);
		}
	}
	free(buf);
}

/*
 * column widths; each followed by one space
 * width of destination/gateway column
 * strlen("fe80::aaaa:bbbb:cccc:dddd@@gif0") == 30, strlen("/128") == 4
 */
#define	WID_GW(af)	((af) == AF_INET6 ? (nflag ? 30 : 18) : 18)

int
WID_DST(int af)
{

	if (nflag)
		switch (af) {
		case AF_MPLS:
			return 9;
		case AF_INET6:
			return 34;
		default:
			return 18;
		}
	else
		switch (af) {
		case AF_MPLS:
			return 9;
 		default:
			return 18;
		}
}

/*
 * Print header for routing table columns.
 */
void
pr_rthdr(int af, int Aflag)
{
	if (Aflag)
		printf("%-*.*s ", PLEN, PLEN, "Address");
	switch (af) {
	case PF_KEY:
		printf("%-18s %-5s %-18s %-5s %-5s %-22s\n",
		    "Source", "Port", "Destination",
		    "Port", "Proto", "SA(Address/Proto/Type/Direction)");
		break;
	case PF_MPLS:
		printf("%-9s %-9s %-6s %-18s %-6.6s %5.5s %8.8s %5.5s  %4.4s %s\n",
		    "In label", "Out label", "Op", "Gateway",
		    "Flags", "Refs", "Use", "Mtu", "Prio", "Interface");
		break;
	default:
		printf("%-*.*s %-*.*s %-6.6s %5.5s %8.8s %5.5s  %4.4s %s",
		    WID_DST(af), WID_DST(af), "Destination",
		    WID_GW(af), WID_GW(af), "Gateway",
		    "Flags", "Refs", "Use", "Mtu", "Prio", "Iface");
		if (vflag && !Aflag)
			printf(" %s", "Label");
		putchar('\n');
		break;
	}
}

static void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		} else
			rti_info[i] = NULL;
	}
}

/*
 * Print a routing table entry.
 */
void
p_rtentry(struct rt_msghdr *rtm)
{
	static int	 old_af = -1;
	struct sockaddr	*sa = (struct sockaddr *)((char *)rtm + rtm->rtm_hdrlen);
	struct sockaddr	*mask, *rti_info[RTAX_MAX];
	char		 ifbuf[IF_NAMESIZE];

	if (sa->sa_family == AF_KEY)
		return;

	get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

	if (Fflag && rti_info[RTAX_GATEWAY]->sa_family != sa->sa_family) {
		return;
	}
	if (old_af != sa->sa_family) {
		old_af = sa->sa_family;
		pr_family(sa->sa_family);
		pr_rthdr(sa->sa_family, 0);
	}

	mask = rti_info[RTAX_NETMASK];
	if ((sa = rti_info[RTAX_DST]) == NULL)
		return;

	p_sockaddr(sa, mask, rtm->rtm_flags, WID_DST(sa->sa_family));
	p_sockaddr_mpls(sa, rti_info[RTAX_SRC], rtm->rtm_mpls,
	    WID_DST(sa->sa_family));

	p_sockaddr(rti_info[RTAX_GATEWAY], NULL, RTF_HOST,
	    WID_GW(sa->sa_family));

	p_flags(rtm->rtm_flags, "%-6.6s ");
	printf("%5u %8llu ", rtm->rtm_rmx.rmx_refcnt,
	    rtm->rtm_rmx.rmx_pksent);
	if (rtm->rtm_rmx.rmx_mtu)
		printf("%5u ", rtm->rtm_rmx.rmx_mtu);
	else
		printf("%5s ", "-");
	putchar((rtm->rtm_rmx.rmx_locks & RTV_MTU) ? 'L' : ' ');
	printf("  %2d %-5.16s", rtm->rtm_priority,
	    if_indextoname(rtm->rtm_index, ifbuf));
	if (vflag && rti_info[RTAX_LABEL])
		printf(" %s", ((struct sockaddr_rtlabel *)
		    rti_info[RTAX_LABEL])->sr_label);
	putchar('\n');
}

/*
 * Print address family header before a section of the routing table.
 */
void
pr_family(int af)
{
	char *afname;

	switch (af) {
	case AF_INET:
		afname = "Internet";
		break;
	case AF_INET6:
		afname = "Internet6";
		break;
	case PF_KEY:
		afname = "Encap";
		break;
	case AF_MPLS:
		afname = "MPLS";
		break;
	default:
		afname = NULL;
		break;
	}
	if (afname)
		printf("\n%s:\n", afname);
	else
		printf("\nProtocol Family %d:\n", af);
}

void
p_addr(struct sockaddr *sa, struct sockaddr *mask, int flags)
{
	p_sockaddr(sa, mask, flags, WID_DST(sa->sa_family));
}

void
p_gwaddr(struct sockaddr *sa, int af)
{
	p_sockaddr(sa, 0, RTF_HOST, WID_GW(af));
}

void
p_sockaddr(struct sockaddr *sa, struct sockaddr *mask, int flags, int width)
{
	char *cp;

	switch (sa->sa_family) {
	case AF_INET6:
	    {
		struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)sa;
		struct in6_addr *in6 = &sa6->sin6_addr;

		/*
		 * XXX: This is a special workaround for KAME kernels.
		 * sin6_scope_id field of SA should be set in the future.
		 */
		if (IN6_IS_ADDR_LINKLOCAL(in6) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(in6) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(in6)) {
			/* XXX: override is ok? */
			sa6->sin6_scope_id = (u_int32_t)ntohs(*(u_short *)
			    &in6->s6_addr[2]);
			*(u_short *)&in6->s6_addr[2] = 0;
		}
		if (flags & RTF_HOST)
			cp = routename((struct sockaddr *)sa6);
		else
			cp = netname((struct sockaddr *)sa6, mask);
		break;
	    }
	case AF_MPLS:
		return;
	default:
		if ((flags & RTF_HOST) || mask == NULL)
			cp = routename(sa);
		else
			cp = netname(sa, mask);
		break;
	}
	if (width < 0)
		printf("%s", cp);
	else {
		if (nflag)
			printf("%-*s ", width, cp);
		else
			printf("%-*.*s ", width, width, cp);
	}
}

static char line[HOST_NAME_MAX+1];
static char domain[HOST_NAME_MAX+1];

void
p_sockaddr_mpls(struct sockaddr *in, struct sockaddr *out, int flags, int width)
{
	if (in->sa_family != AF_MPLS)
		return;

	if (flags & MPLS_OP_POP || flags == MPLS_OP_LOCAL) {
		printf("%-*s ", width, label_print(in));
		printf("%-*s ", width, label_print(NULL));
	} else {
		printf("%-*s ", width, label_print(in));
		printf("%-*s ", width, label_print(out));
	}

	printf("%-6s ", mpls_op(flags));
}

void
p_flags(int f, char *format)
{
	char name[33], *flags;
	const struct bits *p = bits;

	for (flags = name; p->b_mask && flags < &name[sizeof(name) - 2]; p++)
		if (p->b_mask & f)
			*flags++ = p->b_val;
	*flags = '\0';
	printf(format, name);
}

char *
routename(struct sockaddr *sa)
{
	char *cp = NULL;
	static int first = 1;

	if (first) {
		first = 0;
		if (gethostname(domain, sizeof(domain)) == 0 &&
		    (cp = strchr(domain, '.')))
			(void)strlcpy(domain, cp + 1, sizeof(domain));
		else
			domain[0] = '\0';
		cp = NULL;
	}

	if (sa->sa_len == 0) {
		(void)strlcpy(line, "default", sizeof(line));
		return (line);
	}

	switch (sa->sa_family) {
	case AF_INET:
		return
		    (routename4(((struct sockaddr_in *)sa)->sin_addr.s_addr));

	case AF_INET6:
	    {
		struct sockaddr_in6 sin6;

		memset(&sin6, 0, sizeof(sin6));
		memcpy(&sin6, sa, sa->sa_len);
		sin6.sin6_family = AF_INET6;
		if (sa->sa_len == sizeof(struct sockaddr_in6) &&
		    (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_LINKLOCAL(&sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_INTFACELOCAL(&sin6.sin6_addr)) &&
		    sin6.sin6_scope_id == 0) {
			sin6.sin6_scope_id =
			    ntohs(*(u_int16_t *)&sin6.sin6_addr.s6_addr[2]);
			sin6.sin6_addr.s6_addr[2] = 0;
			sin6.sin6_addr.s6_addr[3] = 0;
		}
		return (routename6(&sin6));
	    }

	case AF_LINK:
		return (link_print(sa));
	case AF_MPLS:
		return (label_print(sa));
	case AF_UNSPEC:
		if (sa->sa_len == sizeof(struct sockaddr_rtlabel)) {
			static char name[RTLABEL_LEN];
			struct sockaddr_rtlabel *sr;

			sr = (struct sockaddr_rtlabel *)sa;
			(void)strlcpy(name, sr->sr_label, sizeof(name));
			return (name);
		}
		/* FALLTHROUGH */
	default:
		(void)snprintf(line, sizeof(line), "(%d) %s",
		    sa->sa_family, any_ntoa(sa));
		break;
	}
	return (line);
}

char *
routename4(in_addr_t in)
{
	char		*cp = NULL;
	struct in_addr	 ina;
	struct hostent	*hp;

	if (in == INADDR_ANY)
		cp = "default";
	if (!cp && !nflag) {
		if ((hp = gethostbyaddr((char *)&in,
		    sizeof(in), AF_INET)) != NULL) {
			if ((cp = strchr(hp->h_name, '.')) &&
			    !strcmp(cp + 1, domain))
				*cp = '\0';
			cp = hp->h_name;
		}
	}
	ina.s_addr = in;
	strlcpy(line, cp ? cp : inet_ntoa(ina), sizeof(line));

	return (line);
}

char *
routename6(struct sockaddr_in6 *sin6)
{
	int	 niflags = 0;

	if (nflag)
		niflags |= NI_NUMERICHOST;
	else
		niflags |= NI_NOFQDN;

	if (getnameinfo((struct sockaddr *)sin6, sizeof(*sin6),
	    line, sizeof(line), NULL, 0, niflags) != 0)
		strncpy(line, "invalid", sizeof(line));

	return (line);
}

/*
 * Return the name of the network whose address is given.
 * The address is assumed to be that of a net or subnet, not a host.
 */
char *
netname4(in_addr_t in, in_addr_t mask)
{
	int mbits;

	in = ntohl(in);
	mask = ntohl(mask);
	mbits = mask ? 33 - ffs(mask) : 0;
	if (in == INADDR_ANY && mask == INADDR_ANY)
		strlcpy(line, "default", sizeof(line));
#define C(x)	((x) & 0xff)
	else if (mbits < 9)
		snprintf(line, sizeof(line), "%u/%d", C(in >> 24), mbits);
	else if (mbits < 17)
		snprintf(line, sizeof(line), "%u.%u/%d",
		    C(in >> 24) , C(in >> 16), mbits);
	else if (mbits < 25)
		snprintf(line, sizeof(line), "%u.%u.%u/%d",
		    C(in >> 24), C(in >> 16), C(in >> 8), mbits);
	else
		snprintf(line, sizeof(line), "%u.%u.%u.%u/%d", C(in >> 24),
		    C(in >> 16), C(in >> 8), C(in), mbits);
#undef C
	return (line);
}

char *
netname6(struct sockaddr_in6 *sa6, struct sockaddr_in6 *mask)
{
	struct sockaddr_in6 sin6;
	u_char *p;
	int masklen, final = 0, illegal = 0;
	int i, lim, flag, error;
	char hbuf[NI_MAXHOST];

	sin6 = *sa6;

	flag = 0;
	masklen = 0;
	if (mask) {
		lim = mask->sin6_len - offsetof(struct sockaddr_in6, sin6_addr);
		lim = lim < (int)sizeof(struct in6_addr) ?
		    lim : (int)sizeof(struct in6_addr);
		for (p = (u_char *)&mask->sin6_addr, i = 0; i < lim; p++) {
			if (final && *p) {
				illegal++;
				sin6.sin6_addr.s6_addr[i++] = 0x00;
				continue;
			}

			switch (*p & 0xff) {
			case 0xff:
				masklen += 8;
				break;
			case 0xfe:
				masklen += 7;
				final++;
				break;
			case 0xfc:
				masklen += 6;
				final++;
				break;
			case 0xf8:
				masklen += 5;
				final++;
				break;
			case 0xf0:
				masklen += 4;
				final++;
				break;
			case 0xe0:
				masklen += 3;
				final++;
				break;
			case 0xc0:
				masklen += 2;
				final++;
				break;
			case 0x80:
				masklen += 1;
				final++;
				break;
			case 0x00:
				final++;
				break;
			default:
				final++;
				illegal++;
				break;
			}

			if (!illegal)
				sin6.sin6_addr.s6_addr[i++] &= *p;
			else
				sin6.sin6_addr.s6_addr[i++] = 0x00;
		}
		while (i < (int)sizeof(struct in6_addr))
			sin6.sin6_addr.s6_addr[i++] = 0x00;
	} else
		masklen = 128;

	if (masklen == 0 && IN6_IS_ADDR_UNSPECIFIED(&sin6.sin6_addr))
		return ("default");

	if (illegal)
		warnx("illegal prefixlen");

	if (nflag)
		flag |= NI_NUMERICHOST;
	error = getnameinfo((struct sockaddr *)&sin6, sizeof(sin6),
	    hbuf, sizeof(hbuf), NULL, 0, flag);
	if (error)
		snprintf(hbuf, sizeof(hbuf), "invalid");

	snprintf(line, sizeof(line), "%s/%d", hbuf, masklen);
	return (line);
}

/*
 * Return the name of the network whose address is given.
 * The address is assumed to be that of a net or subnet, not a host.
 */
char *
netname(struct sockaddr *sa, struct sockaddr *mask)
{
	switch (sa->sa_family) {
	case AF_INET:
		return netname4(((struct sockaddr_in *)sa)->sin_addr.s_addr,
		    mask->sa_len == 0 ? 0 :
		    ((struct sockaddr_in *)mask)->sin_addr.s_addr);
	case AF_INET6:
		return netname6((struct sockaddr_in6 *)sa,
		    (struct sockaddr_in6 *)mask);
	case AF_LINK:
		return (link_print(sa));
	case AF_MPLS:
		return (label_print(sa));
	default:
		snprintf(line, sizeof(line), "af %d: %s",
		    sa->sa_family, any_ntoa(sa));
		break;
	}
	return (line);
}

static const char hexlist[] = "0123456789abcdef";

char *
any_ntoa(const struct sockaddr *sa)
{
	static char obuf[240];
	const char *in = sa->sa_data;
	char *out = obuf;
	int len = sa->sa_len - offsetof(struct sockaddr, sa_data);

	*out++ = 'Q';
	do {
		*out++ = hexlist[(*in >> 4) & 15];
		*out++ = hexlist[(*in++)    & 15];
		*out++ = '.';
	} while (--len > 0 && (out + 3) < &obuf[sizeof(obuf) - 1]);
	out[-1] = '\0';
	return (obuf);
}

char *
link_print(struct sockaddr *sa)
{
	struct sockaddr_dl	*sdl = (struct sockaddr_dl *)sa;
	u_char			*lla = (u_char *)sdl->sdl_data + sdl->sdl_nlen;

	if (sdl->sdl_nlen == 0 && sdl->sdl_alen == 0 &&
	    sdl->sdl_slen == 0) {
		(void)snprintf(line, sizeof(line), "link#%d", sdl->sdl_index);
		return (line);
	}
	switch (sdl->sdl_type) {
	case IFT_ETHER:
	case IFT_CARP:
		return (ether_ntoa((struct ether_addr *)lla));
	default:
		return (link_ntoa(sdl));
	}
}

char *
mpls_op(u_int32_t type)
{
	switch (type & (MPLS_OP_PUSH | MPLS_OP_POP | MPLS_OP_SWAP)) {
	case MPLS_OP_LOCAL:
		return ("LOCAL");
	case MPLS_OP_POP:
		return ("POP");
	case MPLS_OP_SWAP:
		return ("SWAP");
	case MPLS_OP_PUSH:
		return ("PUSH");
	default:
		return ("?");
	}
}

char *
label_print(struct sockaddr *sa)
{
	struct sockaddr_mpls	*smpls = (struct sockaddr_mpls *)sa;

	if (smpls)
		(void)snprintf(line, sizeof(line), "%u",
		    ntohl(smpls->smpls_label) >> MPLS_LABEL_OFFSET);
	else
		(void)snprintf(line, sizeof(line), "-");

	return (line);
}
@


1.52
log
@Add userland parts for BFD.  Can't work if you don't have it enabled in
the kernel.

OK claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.51 2016/09/01 09:41:34 bluhm Exp $	*/
a451 1
		sin6.sin6_len = sizeof(struct sockaddr_in6);
d522 1
a522 1
	if (getnameinfo((struct sockaddr *)sin6, sin6->sin6_len,
d642 1
a642 1
	error = getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
@


1.51
log
@Display all route flags in "route get", "route show" and "netstat -r"
output.  Sort them according to the RTF_... defines in route.h.
OK claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.50 2016/07/13 08:40:46 mpi Exp $	*/
d93 1
@


1.50
log
@Introduce RTF_MULTICAST and flag corresponding IPv6 routes as such
instead of abusing RTF_CLONING.

Fix a leak reporeted by Aaron Riekenberg on misc@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.49 2015/09/11 20:10:26 mpi Exp $	*/
a76 1
	{ RTF_BLACKHOLE, 'B' },
d84 3
a87 2
	{ RTF_PROTO2,	'2' },
	{ RTF_PROTO3,	'3' },
d89 1
d93 2
a94 1
	{ RTF_BROADCAST, 'b' },
@


1.49
log
@Remove XRESOLVE support.

dlg@@ is sad because we won't be able to implement arpd(8) the way
people intended it in the 80s.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.48 2015/04/27 09:54:04 benno Exp $	*/
a80 1
	{ RTF_MASK,	'm' }, /* Mask Present -- for routing messages only */
d82 1
@


1.48
log
@sync with rev 1.99 of sbin/route/show.c
requested by claudio@@ and mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.47 2015/02/12 23:31:12 claudio Exp $	*/
a82 1
	{ RTF_XRESOLVE,	'X' },
@


1.47
log
@Free the buffers used for the sysctl. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.46 2015/02/09 12:25:03 claudio Exp $	*/
a160 2
			if (af != AF_UNSPEC && sa->sa_family != af)
				continue;
@


1.46
log
@Get rid of another KVM reader and convert the multicast output to use
the new sysctls. Looks good deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.45 2015/02/06 03:22:00 reyk Exp $	*/
a164 2
		free(buf);
		buf = NULL;
d166 1
@


1.45
log
@Remove route/netstat -f encap in favor of ipsecctl -s flow.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.44 2015/01/16 06:40:10 deraadt Exp $	*/
d106 23
d149 3
a151 15
	while (1) {
		if (sysctl(mib, mcnt, NULL, &needed, NULL, 0) == -1)
			err(1, "route-sysctl-estimate");
		if (needed == 0)
			break;
		if ((buf = realloc(buf, needed)) == NULL)
			err(1, NULL);
		if (sysctl(mib, mcnt, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			err(1, "sysctl of routing table");
		}
		lim = buf + needed;
		break;
	}
@


1.44
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.43 2014/10/23 16:45:57 schwarze Exp $	*/
a38 1
#include <net/pfkeyv2.h>
a41 1
#include <netinet/ip_ipsp.h>
a64 2
#define PFKEYV2_CHUNK sizeof(u_int64_t)

a98 1
void	 p_pfkentry(struct sadb_msg *);
a99 3
void	 p_encap(struct sockaddr *, struct sockaddr *, int);
void	 p_protocol(struct sadb_protocol *, struct sockaddr *, struct
	     sadb_protocol *, int);
a104 1
void	 index_pfk(struct sadb_msg *, void **);
a112 1
	struct sadb_msg *msg;
a156 41

	if (af != 0 && af != PF_KEY)
		return;

	mib[0] = CTL_NET;
	mib[1] = PF_KEY;
	mib[2] = PF_KEY_V2;
	mib[3] = NET_KEY_SPD_DUMP;
	mib[4] = mib[5] = 0;
	while (1) {
		if (sysctl(mib, 4, NULL, &needed, NULL, 0) == -1) {
			if (errno == ENOPROTOOPT)
				return;
			err(1, "spd-sysctl-estimate");
		}
		if (needed == 0)
			break;
		if ((buf = realloc(buf, needed)) == NULL)
			err(1, NULL);
		if (sysctl(mib, 4, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			err(1,"sysctl of spd");
		}
		lim = buf + needed;
		break;
	}

	if (buf) {
		printf("\nEncap:\n");

		for (next = buf; next < lim; next += msg->sadb_msg_len *
		    PFKEYV2_CHUNK) {
			msg = (struct sadb_msg *)next;
			if (msg->sadb_msg_len == 0)
				break;
			p_pfkentry(msg);
		}
		free(buf);
		buf = NULL;
	}
a286 47
 * Print a pfkey/encap entry.
 */
void
p_pfkentry(struct sadb_msg *msg)
{
	static int		 old = 0;
	struct sadb_address	*saddr;
	struct sadb_protocol	*sap, *saft;
	struct sockaddr		*sa, *mask;
	void			*headers[SADB_EXT_MAX + 1];

	if (!old) {
		pr_rthdr(PF_KEY, 0);
		old++;
	}

	bzero(headers, sizeof(headers));
	index_pfk(msg, headers);

	/* These are always set */
	saddr = headers[SADB_X_EXT_SRC_FLOW];
	sa = (struct sockaddr *)(saddr + 1);
	saddr = headers[SADB_X_EXT_SRC_MASK];
	mask = (struct sockaddr *)(saddr + 1);
	p_encap(sa, mask, WID_DST(sa->sa_family));

	/* These are always set, too. */
	saddr = headers[SADB_X_EXT_DST_FLOW];
	sa = (struct sockaddr *)(saddr + 1);
	saddr = headers[SADB_X_EXT_DST_MASK];
	mask = (struct sockaddr *)(saddr + 1);
	p_encap(sa, mask, WID_DST(sa->sa_family));

	/* Bypass and deny flows do not set SADB_EXT_ADDRESS_DST! */
	sap = headers[SADB_X_EXT_PROTOCOL];
	saft = headers[SADB_X_EXT_FLOW_TYPE];
	saddr = headers[SADB_EXT_ADDRESS_DST];
	if (saddr)
		sa = (struct sockaddr *)(saddr + 1);
	else
		sa = NULL;
	p_protocol(sap, sa, saft, msg->sadb_msg_satype);

	printf("\n");
}

/*
a329 91
p_encap(struct sockaddr *sa, struct sockaddr *mask, int width)
{
	char		*cp;
	unsigned short	 port = 0;

	if (mask)
		cp = netname(sa, mask);
	else
		cp = routename(sa);
	switch (sa->sa_family) {
	case AF_INET:
		port = ntohs(((struct sockaddr_in *)sa)->sin_port);
		break;
	case AF_INET6:
		port = ntohs(((struct sockaddr_in6 *)sa)->sin6_port);
		break;
	}
	if (width < 0)
		printf("%s", cp);
	else {
		if (nflag)
			printf("%-*s %-5u ", width, cp, port);
		else
			printf("%-*.*s %-5u ", width, width, cp, port);
	}
}

void
p_protocol(struct sadb_protocol *sap, struct sockaddr *sa, struct sadb_protocol
    *saft, int proto)
{
	printf("%-6u", sap->sadb_protocol_proto);

	if (sa)
		p_sockaddr(sa, NULL, 0, -1);
	else
		printf("none");

	switch (proto) {
	case SADB_SATYPE_ESP:
		printf("/esp");
		break;
	case SADB_SATYPE_AH:
		printf("/ah");
		break;
	case SADB_X_SATYPE_IPCOMP:
		printf("/ipcomp");
		break;
	case SADB_X_SATYPE_IPIP:
		printf("/ipip");
		break;
	default:
		printf("/<unknown>");
	}

	switch(saft->sadb_protocol_proto) {
	case SADB_X_FLOW_TYPE_USE:
		printf("/use");
		break;
	case SADB_X_FLOW_TYPE_REQUIRE:
		printf("/require");
		break;
	case SADB_X_FLOW_TYPE_ACQUIRE:
		printf("/acquire");
		break;
	case SADB_X_FLOW_TYPE_DENY:
		printf("/deny");
		break;
	case SADB_X_FLOW_TYPE_BYPASS:
		printf("/bypass");
		break;
	case SADB_X_FLOW_TYPE_DONTACQ:
		printf("/dontacq");
		break;
	default:
		printf("/<unknown type>");
	}

	switch(saft->sadb_protocol_direction) {
	case IPSP_DIRECTION_IN:
		printf("/in");
		break;
	case IPSP_DIRECTION_OUT:
		printf("/out");
		break;
	default:
		printf("/<unknown>");
	}
}

void
a737 42
}

void
index_pfk(struct sadb_msg *msg, void **headers)
{
	struct sadb_ext	*ext;

	for (ext = (struct sadb_ext *)(msg + 1);
	    (size_t)((u_int8_t *)ext - (u_int8_t *)msg) <
	    msg->sadb_msg_len * PFKEYV2_CHUNK && ext->sadb_ext_len > 0;
	    ext = (struct sadb_ext *)((u_int8_t *)ext +
	    ext->sadb_ext_len * PFKEYV2_CHUNK)) {
		switch (ext->sadb_ext_type) {
		case SADB_EXT_ADDRESS_SRC:
			headers[SADB_EXT_ADDRESS_SRC] = (void *)ext;
			break;
		case SADB_EXT_ADDRESS_DST:
			headers[SADB_EXT_ADDRESS_DST] = (void *)ext;
			break;
		case SADB_X_EXT_PROTOCOL:
			headers[SADB_X_EXT_PROTOCOL] = (void *)ext;
			break;
		case SADB_X_EXT_SRC_FLOW:
			headers[SADB_X_EXT_SRC_FLOW] = (void *)ext;
			break;
		case SADB_X_EXT_DST_FLOW:
			headers[SADB_X_EXT_DST_FLOW] = (void *)ext;
			break;
		case SADB_X_EXT_SRC_MASK:
			headers[SADB_X_EXT_SRC_MASK] = (void *)ext;
			break;
		case SADB_X_EXT_DST_MASK:
			headers[SADB_X_EXT_DST_MASK] = (void *)ext;
			break;
		case SADB_X_EXT_FLOW_TYPE:
			headers[SADB_X_EXT_FLOW_TYPE] = (void *)ext;
			break;
		default:
			/* Ignore. */
			break;
		}
	}
@


1.43
log
@Remove networks(5) support.
In particular, do not call getnetbyaddr(3), use gethostbyaddr(3) only.
Do not call setnetent(3) and the dummy sethostent(3).
OK henning@@; and deraadt@@ agrees with the general direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.42 2014/05/08 09:28:08 mpi Exp $	*/
a32 1
#include <sys/param.h>
d55 1
d566 2
a567 2
static char line[MAXHOSTNAMELEN];
static char domain[MAXHOSTNAMELEN];
@


1.42
log
@Introduce two new route flags: RTF_LOCAL and RTF_BROADCAST.

Nothing use them for the moment, but here is the plan:

Since a route lookup is always necessary to output a packet it makes
sense to store all the information regarding how the packet should be
sent in the routing entry.  This will save us some expensive lookups
on address lists.

But once we have all the information about our addresses in the routing
table, we can even use it in the input path with the hope that the number
of lookups in the forwarding case can be reduce to one.

ok henning@@, chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.41 2014/04/17 15:36:53 claudio Exp $	*/
a715 2
	char *cp = NULL;
	struct netent *np = NULL;
d720 1
a720 4
	if (!nflag && in != INADDR_ANY) {
		if ((np = getnetbyaddr(in, AF_INET)) != NULL)
			cp = np->n_name;
	}
d722 1
a722 4
		cp = "default";
	mbits = mask ? 33 - ffs(mask) : 0;
	if (cp)
		strlcpy(line, cp, sizeof(line));
@


1.41
log
@Sync show.c with the route version. Make the two files more similar but
still not identical. OK sthen@@ mpi@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.40 2013/11/21 17:32:13 mikeb Exp $	*/
d96 2
@


1.40
log
@split kernel parts of the if.h into a separate header file if_var.h
which allows us to modify ifnet structure in a relatively safe way;
discussed with deraadt, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.39 2013/11/13 21:19:30 deraadt Exp $	*/
a33 1
#include <sys/protosw.h>
a37 1
#include <net/if_var.h>
d99 1
d215 1
a215 1
static int
d298 1
a402 3
	case AF_APPLETALK:
		afname = "AppleTalk";
		break;
d761 1
a761 1
		    lim : sizeof(struct in6_addr);
d815 1
a815 1
		while (i < sizeof(struct in6_addr))
@


1.39
log
@handle lack of proto
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.38 2013/03/20 15:23:37 deraadt Exp $	*/
d39 1
@


1.38
log
@As non-root, whenever netstat is about to print out a kernel pointer...
print 0x0 instead.  Hides a lot stuff people don't need to see.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.37 2013/01/16 10:53:14 deraadt Exp $	*/
d215 1
a215 1
int
@


1.37
log
@sys/mbuf.h not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.36 2012/03/17 10:16:41 dlg Exp $	*/
d134 6
a139 5

	if (sysctl(mib, mcnt, NULL, &needed, NULL, 0) < 0)
		err(1, "route-sysctl-estimate");
	if (needed > 0) {
		if ((buf = malloc(needed)) == 0)
d141 3
a143 1
		if (sysctl(mib, mcnt, buf, &needed, NULL, 0) < 0)
d145 1
d147 1
d174 9
a182 8

	if (sysctl(mib, 4, NULL, &needed, NULL, 0) == -1) {
		if (errno == ENOPROTOOPT)
			return;
		err(1, "spd-sysctl-estimate");
	}
	if (needed > 0) {
		if ((buf = malloc(needed)) == 0)
d184 3
a186 1
		if (sysctl(mib, 4, buf, &needed, NULL, 0) == -1)
d188 1
d190 1
@


1.36
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.35 2011/11/01 17:30:04 mikeb Exp $	*/
a35 1
#include <sys/mbuf.h>
@


1.35
log
@Do some cleanup and improve the manpage. From Andreas Bartelt; ok henning, jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.34 2010/10/11 12:33:36 claudio Exp $	*/
a95 1
	{ RTF_JUMBO,	'J' },
@


1.34
log
@Do similar changes to netstat as done to route(8). Try to show the
most expected rtable when doing a netstat -rn.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.33 2010/07/30 12:55:12 bluhm Exp $	*/
d119 1
a119 1
p_rttables(int af, u_int tableid, int hastable)
d134 2
a135 5
	if (hastable) {
		mib[6] = tableid;
		mcnt = 7;
	} else
		mcnt = 6;
@


1.33
log
@Do not print "Label" caption for "netstat -rvA".
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.32 2010/07/29 16:35:40 bluhm Exp $	*/
d119 1
a119 1
p_rttables(int af, u_int tableid)
d125 1
a125 1
	int mib[7];
d134 5
a138 1
	mib[6] = tableid;
d140 1
a140 1
	if (sysctl(mib, 7, NULL, &needed, NULL, 0) < 0)
d145 1
a145 1
		if (sysctl(mib, 7, buf, &needed, NULL, 0) < 0)
a841 1

@


1.32
log
@Print a column with the routing label if "netstat -vr" or "route
-v show" are called with the -v switch.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.31 2010/05/19 13:07:15 chl Exp $	*/
d252 1
a252 1
		if (vflag)
@


1.31
log
@remove unused variables

ok claudio@@ michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.30 2010/03/23 16:26:01 claudio Exp $	*/
d248 1
a248 1
		printf("%-*.*s %-*.*s %-6.6s %5.5s %8.8s %5.5s  %4.4s %s\n",
d252 3
d317 1
a317 1
	printf("  %2d %.16s", rtm->rtm_priority,
d319 3
@


1.30
log
@Sync with show.c of route(8). OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.29 2010/01/14 00:02:08 claudio Exp $	*/
a556 2
	char buf[MAXHOSTNAMELEN], *cp;

@


1.29
log
@Similar fix for default route printing as done in netstat. Make sure mask
is 0 when sa_len is 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.28 2010/01/11 08:28:44 dlg Exp $	*/
d63 1
a63 2
char	*label_print_op(u_int32_t);
char	*label_print(struct sockaddr *, struct sockaddr *);
d213 1
a213 1
			return 34;
d222 1
a222 1
			return 34;
d243 1
a243 1
		printf("%-16s %-10s %-6s %-18s %-6.6s %5.5s %8.8s %5.5s  %4.4s %s\n",
d305 1
d562 7
a568 7
	if (flags & MPLS_OP_POP || flags == MPLS_OP_LOCAL)
		cp = label_print(in, NULL);
	else
		cp = label_print(in, out);

	snprintf(buf, MAXHOSTNAMELEN, "%s %s", cp,
	    label_print_op(flags));
d570 1
a570 1
	printf("%-*s ", width, buf);
d636 1
a636 1
		return (label_print(sa, NULL));
d845 1
a845 1
		return (label_print(sa, NULL));
d895 1
a895 1
label_print_op(u_int32_t type)
d912 1
a912 1
label_print(struct sockaddr *in, struct sockaddr *out)
d914 1
a914 17
	struct sockaddr_mpls	*insmpls = (struct sockaddr_mpls *)in;
	struct sockaddr_mpls	*outsmpls = (struct sockaddr_mpls *)out;
	char			*in_label;
	char			*out_label;

	if (asprintf(&in_label, "%u",
	    ntohl(insmpls->smpls_label) >> MPLS_LABEL_OFFSET) == -1)
		err(1, NULL);

	if (outsmpls) {
		if (asprintf(&out_label, "%u",
		    ntohl(outsmpls->smpls_label) >> MPLS_LABEL_OFFSET) == -1)
			err(1, NULL);
	} else {
		if (asprintf(&out_label, "-") == -1)
			err(1, NULL);
	}
d916 5
a920 5
	(void)snprintf(line, sizeof(line), "%-16s %-10s", in_label,
	    out_label);

	free(in_label);
	free(out_label);
@


1.28
log
@"default" routes need a mask of 0 too.

from and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.26 2009/08/05 03:26:59 deraadt Exp $	*/
d837 1
@


1.27
log
@if buffers overlap;  result will be undefined.  ok claudio@@, michele@@
@
text
@d713 1
a713 1
	if (in == INADDR_ANY)
@


1.26
log
@missing break
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.25 2009/06/27 11:35:57 michele Exp $	*/
d557 1
a557 1
	char *cp;
d567 1
a567 1
	snprintf(cp, MAXHOSTNAMELEN, "%s %s", cp,
d570 1
a570 1
	printf("%-*s ", width, cp);
@


1.25
log
@Mark MPLS routes with T (tagged) in route output.

suggested by dlg@@, ok claudio@@, laurent@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.24 2009/05/31 18:03:42 claudio Exp $	*/
d974 1
@


1.24
log
@There is no need to mask priority with RTP_MASK because it is already done
by the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.23 2009/05/23 18:28:45 chris Exp $	*/
d99 1
@


1.23
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.22 2009/05/23 17:03:06 chris Exp $	*/
d313 1
a313 1
	printf("  %2d %.16s", rtm->rtm_priority & RTP_MASK,
@


1.22
log
@missed rtm_hdrlen conversion in two places

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.21 2009/04/28 12:09:36 michele Exp $	*/
d153 1
a153 1
			sa = (struct sockaddr *)(next + rtm->hdrlen);
@


1.21
log
@Sync with kernel changes.
Add support to route(8) for a new dummy operation to allow packets coming in
with a particular label to leave the MPLS cloud and join ipv4/ipv6 stack.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.20 2009/02/06 19:58:31 chl Exp $	*/
d153 1
a153 1
			sa = (struct sockaddr *)(rtm + 1);
d278 1
a278 1
	struct sockaddr	*sa = (struct sockaddr *)(rtm + 1);
@


1.20
log
@remove unused variables.

ok henning@@ michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.19 2009/02/03 16:44:15 michele Exp $	*/
d561 1
a561 1
	if (flags & MPLS_OP_POP)
d896 2
@


1.19
log
@Reflect MPLS kernel changes. Operations are stored now in rt_mpls field.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.18 2009/01/26 17:28:09 claudio Exp $	*/
a911 2
	char			 ifname_in[IF_NAMESIZE];
	char			 ifname_out[IF_NAMESIZE];
@


1.18
log
@Again use P to mark multipath routes in route output. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.17 2009/01/08 12:52:36 michele Exp $	*/
d300 1
a300 1
	p_sockaddr_mpls(sa, rti_info[RTAX_SRC], rtm->rtm_flags,
@


1.17
log
@Reflect MPLS kernel changes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.16 2008/12/15 21:18:37 michele Exp $	*/
d98 1
@


1.16
log
@Unbreak netstat, reflecting kernel changes.
Now it shows MPLS informations correctly.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.15 2008/12/15 20:16:20 deraadt Exp $	*/
d64 1
a64 1
char	*label_print(struct sockaddr *);
d108 1
d299 3
d531 1
a531 9
		if (flags & RTF_HOST || mask == NULL)
			cp = routename(sa);
		else
			cp = netname(sa, mask);

		snprintf(cp, MAXHOSTNAMELEN, "%s %s", cp,
		    label_print_op(flags));

		break;
d549 22
a583 3
static char line[MAXHOSTNAMELEN];
static char domain[MAXHOSTNAMELEN];

d634 1
a634 1
		return (label_print(sa));
d842 1
a842 1
		return (label_print(sa));
d907 1
a907 1
label_print(struct sockaddr *sa)
d909 2
a910 1
	struct sockaddr_mpls	*smpls = (struct sockaddr_mpls *)sa;
d917 1
a917 1
	    ntohl(smpls->smpls_in_label) >> MPLS_LABEL_OFFSET) == -1)
d920 8
a927 3
	if (asprintf(&out_label, "%u",
	    ntohl(smpls->smpls_out_label) >> MPLS_LABEL_OFFSET) == -1)
		err(1, NULL);
@


1.15
log
@work around tree breakage by mpls people
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.14 2008/09/15 20:13:10 claudio Exp $	*/
d63 1
a63 1
char	*label_print_op(u_int8_t);
d526 10
a617 1
#if 0
a619 1
#endif
a825 1
#if 0
a827 1
#endif
a875 1
#if 0
d877 1
a877 1
label_print_op(u_int8_t type)
d879 1
a879 1
	switch (type) {
d900 2
a901 3
	if (asprintf(&in_label, "%u%%%s",
	    ntohl(smpls->smpls_in_label) >> MPLS_LABEL_OFFSET,
	    if_indextoname(smpls->smpls_in_ifindex, ifname_in)) == -1)
d908 2
a909 3
	(void)snprintf(line, sizeof(line), "%-16s %-10s %-6s", in_label,
	    smpls->smpls_operation == MPLS_OP_POP ? "-" : out_label,
	    label_print_op(smpls->smpls_operation));
a915 1
#endif
@


1.14
log
@Similar to route(8) change mask rtm->rtm_priority with RTP_MASK to show
correct values. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.13 2008/05/08 07:19:42 claudio Exp $	*/
d608 1
d611 1
d818 1
d821 1
d870 1
d913 1
@


1.13
log
@Sync netstat show.c with route show.c to gain mpls support and to show the
routing priority. hai norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.12 2007/12/14 18:35:46 deraadt Exp $	*/
d308 1
a308 1
	printf("  %2d %.16s", rtm->rtm_priority,
@


1.12
log
@remove 21 nlist variables, and instead use sysctl to query the kernel
turn on INET6 the default (remove the #ifdef's)
ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.11 2007/09/05 20:29:05 claudio Exp $	*/
d47 1
d63 2
d106 1
a106 1
	    sadb_protocol *, int);
a201 1
#define	WID_DST(af)	((af) == AF_INET6 ? (nflag ? 34 : 18) : 18)
d204 22
d234 2
a235 6
	if (af != PF_KEY)
		printf("%-*.*s %-*.*s %-6.6s %6.6s %8.8s %6.6s  %s\n",
		    WID_DST(af), WID_DST(af), "Destination",
		    WID_GW(af), WID_GW(af), "Gateway",
		    "Flags", "Refs", "Use", "Mtu", "Interface");
	else
d239 13
d301 1
a301 1
	printf("%6u %8llu ", rtm->rtm_rmx.rmx_refcnt,
d304 1
a304 1
		printf("%6u ", rtm->rtm_rmx.rmx_mtu);
d306 1
a306 1
		printf("%6s ", "-");
d308 2
a309 1
	printf(" %.16s", if_indextoname(rtm->rtm_index, ifbuf));
d319 1
a319 1
	static int	 	 old = 0;
d378 3
d409 2
a410 2
	char 		*cp;
	unsigned short	 port;
d608 2
a609 1

d816 2
d864 43
@


1.11
log
@Correct the format strings after the recent rt_metrics changes.
rmx_pksent is not u_int64_t all others are just u_int.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.10 2007/07/25 11:50:47 claudio Exp $	*/
d194 1
a194 1
/* 
@


1.10
log
@Make it possible to show alternate routing tables in netstat. This mostly
comes from route(8) which already had the -T option.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.9 2007/07/24 20:36:34 claudio Exp $	*/
d268 1
a268 1
	printf("%6d %8ld ", (int)rtm->rtm_rmx.rmx_refcnt,
d271 1
a271 1
		printf("%6ld ", rtm->rtm_rmx.rmx_mtu);
@


1.9
log
@Bring back a few things from route/show.c which I like better.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.8 2007/07/21 15:43:42 claudio Exp $	*/
a97 1
void	 pr_rthdr(int, int);
d114 1
a114 1
p_rttables(int af)
d120 1
a120 1
	int mib[6];
d129 3
a131 1
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
d136 1
a136 1
		if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
@


1.8
log
@Similar to sbin/route/show.c:
Check the rtm_version before trying to print an entry. If the rtmsg has a
different version skip it and don't try to print it. Solves a SIGSEGV I have
triggered with one of my scarier diffs.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.7 2007/06/19 05:37:10 ray Exp $	*/
a245 1

d379 3
a384 3
	default:
		port = ntohs(((struct sockaddr_in *)sa)->sin_port);
		break;
d401 1
d577 1
a577 1
			strlcpy(name, sr->sr_label, sizeof(name));
@


1.7
log
@Remove unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.6 2007/06/04 12:20:24 henning Exp $	*/
d145 2
@


1.6
log
@remove IPX support, agreed by many
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.5 2007/03/23 10:59:38 pyr Exp $	*/
a283 1
	struct sadb_ext		*ext;
@


1.5
log
@Add a new flag -F to netstat restricting route display in conjuction
with -r to routes in the same address family as the destination.
ok henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.4 2006/12/29 10:09:09 claudio Exp $	*/
a44 1
#include <netipx/ipx.h>
a339 3
	case AF_IPX:
		afname = "IPX";
		break;
a566 3
	case AF_IPX:
		return (ipx_print(sa));

a773 2
	case AF_IPX:
		return (ipx_print(sa));
a801 51
}

short ipx_nullh[] = {0,0,0};
short ipx_bh[] = {-1,-1,-1};

char *
ipx_print(struct sockaddr *sa)
{
	struct sockaddr_ipx *sipx = (struct sockaddr_ipx *)sa;
	struct ipx_addr work;
	union {
		union ipx_net	net_e;
		u_int32_t	long_e;
	} net;
	u_short port;
	static char mybuf[50+MAXHOSTNAMELEN], cport[10], chost[25];
	char *host = "";
	char *p;
	u_char *q;

	work = sipx->sipx_addr;
	port = ntohs(work.ipx_port);
	work.ipx_port = 0;
	net.net_e = work.ipx_net;
	if (ipx_nullhost(work) && net.long_e == 0) {
		if (!port)
			return ("*.*");
		(void)snprintf(mybuf, sizeof(mybuf), "*.0x%XH", port);
		return (mybuf);
	}

	if (memcmp(ipx_bh, work.ipx_host.c_host, 6) == 0)
		host = "any";
	else if (memcmp(ipx_nullh, work.ipx_host.c_host, 6) == 0)
		host = "*";
	else {
		q = work.ipx_host.c_host;
		(void)snprintf(chost, sizeof(chost), "%02X%02X%02X%02X%02X%02XH",
			q[0], q[1], q[2], q[3], q[4], q[5]);
		for (p = chost; *p == '0' && p < chost + 12; p++)
			/* void */;
		host = p;
	}
	if (port)
		(void)snprintf(cport, sizeof(cport), ".%XH", htons(port));
	else
		*cport = '\0';

	(void)snprintf(mybuf, sizeof(mybuf), "%XH.%s%s",
	    ntohl(net.long_e), host, cport);
	return (mybuf);
@


1.4
log
@Netstat has the same issue problem as route when printing a default inet6
route.  Need to typecast the sizeof() to int so that the compare works.
Having a negativ lim is OK.  Reported by Björn Ketelaars. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.3 2006/11/17 01:11:23 itojun Exp $	*/
d249 4
a257 1
	get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
@


1.3
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.2 2006/05/30 19:42:58 todd Exp $	*/
d686 1
a686 1
		lim = lim < sizeof(struct in6_addr) ?
@


1.2
log
@this fixes a crash observed by Naddy on amd64, and permits the src/dst ip's to
be visible .. when IPv6 sa flows are present
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.1 2006/05/27 19:16:37 claudio Exp $	*/
d475 2
a476 1
		    IN6_IS_ADDR_MC_LINKLOCAL(in6)) {
d557 2
a558 1
		     IN6_IS_ADDR_MC_LINKLOCAL(&sin6.sin6_addr)) &&
@


1.1
log
@Moving netstat from kvm snooping to retrieving the routing tables via
sysctl. Most code is stolen from route -- which was stolen from netstat.
kvm snooping code is still in and useable. Put it in deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.26 2003/08/26 08:33:12 itojun Exp $	*/
d375 4
d380 2
a381 1
	case AF_INET6: {
a382 1
	}
a383 4
		if (mask)
			cp = netname(sa, mask);
		else
			cp = routename(sa);
@

