head	1.110;
access;
symbols
	OPENBSD_6_1:1.109.0.4
	OPENBSD_6_1_BASE:1.109
	OPENBSD_6_0:1.105.0.4
	OPENBSD_6_0_BASE:1.105
	OPENBSD_5_9:1.101.0.2
	OPENBSD_5_9_BASE:1.101
	OPENBSD_5_8:1.97.0.2
	OPENBSD_5_8_BASE:1.97
	OPENBSD_5_7:1.96.0.2
	OPENBSD_5_7_BASE:1.96
	OPENBSD_5_6:1.94.0.4
	OPENBSD_5_6_BASE:1.94
	OPENBSD_5_5:1.92.0.4
	OPENBSD_5_5_BASE:1.92
	OPENBSD_5_4:1.91.0.2
	OPENBSD_5_4_BASE:1.91
	OPENBSD_5_3:1.86.0.6
	OPENBSD_5_3_BASE:1.86
	OPENBSD_5_2:1.86.0.4
	OPENBSD_5_2_BASE:1.86
	OPENBSD_5_1_BASE:1.86
	OPENBSD_5_1:1.86.0.2
	OPENBSD_5_0:1.85.0.2
	OPENBSD_5_0_BASE:1.85
	OPENBSD_4_9:1.84.0.2
	OPENBSD_4_9_BASE:1.84
	OPENBSD_4_8:1.80.0.2
	OPENBSD_4_8_BASE:1.80
	OPENBSD_4_7:1.75.0.2
	OPENBSD_4_7_BASE:1.75
	OPENBSD_4_6:1.71.0.6
	OPENBSD_4_6_BASE:1.71
	OPENBSD_4_5:1.71.0.2
	OPENBSD_4_5_BASE:1.71
	OPENBSD_4_4:1.69.0.2
	OPENBSD_4_4_BASE:1.69
	OPENBSD_4_3:1.67.0.2
	OPENBSD_4_3_BASE:1.67
	OPENBSD_4_2:1.65.0.4
	OPENBSD_4_2_BASE:1.65
	OPENBSD_4_1:1.65.0.2
	OPENBSD_4_1_BASE:1.65
	OPENBSD_4_0:1.64.0.4
	OPENBSD_4_0_BASE:1.64
	OPENBSD_3_9:1.45.0.2
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_8:1.1.0.2;
locks; strict;
comment	@ * @;


1.110
date	2017.05.31.09.15.42;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	zCd5GrUCVAe14Y6J;

1.109
date	2017.03.14.00.55.37;	author dtucker;	state Exp;
branches;
next	1.108;
commitid	q0lxFQ4z8N7tZLsW;

1.108
date	2017.03.14.00.25.03;	author dtucker;	state Exp;
branches;
next	1.107;
commitid	KBVISE8YrZj1TraB;

1.107
date	2016.11.30.00.28.31;	author dtucker;	state Exp;
branches;
next	1.106;
commitid	cItLYZCoclAybZAb;

1.106
date	2016.10.23.22.04.05;	author dtucker;	state Exp;
branches;
next	1.105;
commitid	v1YsIAvaioz9gRAs;

1.105
date	2016.07.15.00.24.30;	author djm;	state Exp;
branches;
next	1.104;
commitid	PAQPO8bvkonq4i81;

1.104
date	2016.04.06.06.42.17;	author djm;	state Exp;
branches;
next	1.103;
commitid	His5Dv7TLGORp9Rs;

1.103
date	2016.04.02.14.37.42;	author krw;	state Exp;
branches;
next	1.102;
commitid	rfpOX4oSITckBvQ2;

1.102
date	2016.03.02.22.42.40;	author dtucker;	state Exp;
branches;
next	1.101;
commitid	kyzoHwOzjFTjav9W;

1.101
date	2016.01.20.09.22.39;	author dtucker;	state Exp;
branches;
next	1.100;
commitid	vKMuM4wTsH5ozJxD;

1.100
date	2015.12.04.21.51.06;	author tobias;	state Exp;
branches;
next	1.99;
commitid	PLgwAteYeZszrvxN;

1.99
date	2015.10.24.08.34.09;	author sthen;	state Exp;
branches;
next	1.98;
commitid	oX5ScjyW28uV5o3Q;

1.98
date	2015.10.07.00.54.06;	author djm;	state Exp;
branches;
next	1.97;
commitid	LpOdh7ua59BYlVcY;

1.97
date	2015.04.24.01.36.00;	author deraadt;	state Exp;
branches;
next	1.96;
commitid	LHkUmZjv49ojnnuH;

1.96
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	Uu5nFG3wCl0LACBb;

1.95
date	2014.10.24.02.01.20;	author lteo;	state Exp;
branches;
next	1.94;
commitid	K0sGF4uE2LYJ8DMA;

1.94
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.93;
commitid	z7plx8Gkj6l2sxem;

1.93
date	2014.04.20.02.30.25;	author djm;	state Exp;
branches;
next	1.92;

1.92
date	2013.10.14.23.28.23;	author djm;	state Exp;
branches;
next	1.91;

1.91
date	2013.07.12.00.43.50;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2013.06.01.13.15.52;	author dtucker;	state Exp;
branches;
next	1.89;

1.89
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.88;

1.88
date	2013.04.24.16.01.46;	author tedu;	state Exp;
branches;
next	1.87;

1.87
date	2013.04.23.17.49.45;	author tedu;	state Exp;
branches;
next	1.86;

1.86
date	2011.09.05.05.59.08;	author djm;	state Exp;
branches;
next	1.85;

1.85
date	2011.03.29.18.54.17;	author stevesk;	state Exp;
branches;
next	1.84;

1.84
date	2010.11.21.01.01.13;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2010.11.13.23.27.50;	author djm;	state Exp;
branches;
next	1.82;

1.82
date	2010.09.24.13.33.00;	author matthew;	state Exp;
branches;
next	1.81;

1.81
date	2010.09.22.22.58.51;	author djm;	state Exp;
branches;
next	1.80;

1.80
date	2010.07.21.02.10.58;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2010.07.13.23.13.16;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2010.07.13.11.52.06;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2010.07.02.04.32.44;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.21.05.00.36;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2010.01.09.23.04.13;	author dtucker;	state Exp;
branches;
next	1.74;

1.74
date	2009.12.25.19.40.21;	author stevesk;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.20.03.24.07;	author djm;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.28.16.38.18;	author reyk;	state Exp;
branches;
next	1.71;

1.71
date	2009.02.21.19.32.04;	author tobias;	state Exp;
branches;
next	1.70;

1.70
date	2009.01.22.10.02.34;	author djm;	state Exp;
branches;
next	1.69;

1.69
date	2008.06.13.01.38.23;	author dtucker;	state Exp;
branches;
next	1.68;

1.68
date	2008.06.12.20.38.28;	author dtucker;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.01.08.47.04;	author dtucker;	state Exp;
branches;
next	1.66;

1.66
date	2007.12.27.14.22.08;	author dtucker;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.23.01.35.11;	author ray;	state Exp;
branches;
next	1.64;

1.64
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.62;

1.62
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.60;

1.60
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.59;

1.59
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.58;

1.58
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.57;

1.57
date	2006.07.10.16.37.36;	author stevesk;	state Exp;
branches;
next	1.56;

1.56
date	2006.07.10.12.46.51;	author dtucker;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.09.15.15.10;	author stevesk;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.53;

1.53
date	2006.07.05.02.42.09;	author stevesk;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.30.09.58.15;	author djm;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.25.01.13.23;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.20.17.10.19;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.13.10.14.29;	author dtucker;	state Exp;
branches;
next	1.45;

1.45
date	2006.02.10.00.27.13;	author stevesk;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2006.02.08.12.32.49;	author stevesk;	state Exp;
branches;
next	1.43;

1.43
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.31.10.19.02;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.05.23.43.53;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.02.07.53.44;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2006.01.01.10.08.48;	author stevesk;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.01.08.59.27;	author stevesk;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.08.18.34.11;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.08.09.26.18;	author dtucker;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2005.07.04.00.58.43;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.06.11.20.36;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.09.04.32.54;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2005.03.01.10.09.52;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.11.01.48.56;	author dtucker;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.06.11.41.03;	author dtucker;	state Exp;
branches;
next	1.25;

1.25
date	2004.08.11.21.43.05;	author avsm;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2004.06.14.01.44.39;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.28.09.08.06;	author markus;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2003.09.18.08.49.45;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.12.10.15.36;	author markus;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2002.12.13.10.03.15;	author markus;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2002.03.04.17.27.39;	author stevesk;	state Exp;
branches
	1.19.2.1
	1.19.4.1;
next	1.18;

1.18
date	2002.03.04.13.10.46;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.26.20.03.51;	author stevesk;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.24.19.59.42;	author stevesk;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.24.21.09.25;	author stevesk;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.26.17.27.24;	author markus;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.06.16.08.58.34;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.16.08.49.38;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.19.19.43.57;	author stevesk;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.11.14.59.56;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.08.19.45.24;	author mouring;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.03.23.09.52;	author mouring;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.12.20.09.37;	author stevesk;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.02.28.17.52.54;	author deraadt;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.02.28.05.34.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.22.21.59.44;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.21.19.05.52;	author markus;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.02.16.20.13.07;	author jason;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.02.19.17.19.06;	author jason;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.03.21.19.46.26;	author jason;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.05.07.21.09.31;	author jason;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.4.2.1
date	2001.03.12.15.44.12;	author jason;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.03.21.18.52.52;	author jason;	state Exp;
branches;
next	;

1.5.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.12.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	;

1.19.2.1
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.19.4.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.19.4.2;

1.19.4.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.20.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.21.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.23.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.25.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.29.2.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.34.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.45.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.110
log
@Switch to recallocarray() for a few operations.  Both growth and shrinkage
are handled safely, and there also is no need for preallocation dances.
Future changes in this area will be less error prone.
Review and one bug found by markus
@
text
@/* $OpenBSD: misc.c,v 1.109 2017/03/14 00:55:37 dtucker Exp $ */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 * Copyright (c) 2005,2006 Damien Miller.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/un.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
#include "misc.h"
#include "log.h"
#include "ssh.h"

/* remove newline at end of string */
char *
chop(char *s)
{
	char *t = s;
	while (*t) {
		if (*t == '\n' || *t == '\r') {
			*t = '\0';
			return s;
		}
		t++;
	}
	return s;

}

/* set/unset filedescriptor to non-blocking */
int
set_nonblock(int fd)
{
	int val;

	val = fcntl(fd, F_GETFL);
	if (val < 0) {
		error("fcntl(%d, F_GETFL): %s", fd, strerror(errno));
		return (-1);
	}
	if (val & O_NONBLOCK) {
		debug3("fd %d is O_NONBLOCK", fd);
		return (0);
	}
	debug2("fd %d setting O_NONBLOCK", fd);
	val |= O_NONBLOCK;
	if (fcntl(fd, F_SETFL, val) == -1) {
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd,
		    strerror(errno));
		return (-1);
	}
	return (0);
}

int
unset_nonblock(int fd)
{
	int val;

	val = fcntl(fd, F_GETFL);
	if (val < 0) {
		error("fcntl(%d, F_GETFL): %s", fd, strerror(errno));
		return (-1);
	}
	if (!(val & O_NONBLOCK)) {
		debug3("fd %d is not O_NONBLOCK", fd);
		return (0);
	}
	debug("fd %d clearing O_NONBLOCK", fd);
	val &= ~O_NONBLOCK;
	if (fcntl(fd, F_SETFL, val) == -1) {
		debug("fcntl(%d, F_SETFL, ~O_NONBLOCK): %s",
		    fd, strerror(errno));
		return (-1);
	}
	return (0);
}

const char *
ssh_gai_strerror(int gaierr)
{
	if (gaierr == EAI_SYSTEM && errno != 0)
		return strerror(errno);
	return gai_strerror(gaierr);
}

/* disable nagle on socket */
void
set_nodelay(int fd)
{
	int opt;
	socklen_t optlen;

	optlen = sizeof opt;
	if (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {
		debug("getsockopt TCP_NODELAY: %.100s", strerror(errno));
		return;
	}
	if (opt == 1) {
		debug2("fd %d is TCP_NODELAY", fd);
		return;
	}
	opt = 1;
	debug2("fd %d setting TCP_NODELAY", fd);
	if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)
		error("setsockopt TCP_NODELAY: %.100s", strerror(errno));
}

/* Characters considered whitespace in strsep calls. */
#define WHITESPACE " \t\r\n"
#define QUOTE	"\""

/* return next token in configuration line */
char *
strdelim(char **s)
{
	char *old;
	int wspace = 0;

	if (*s == NULL)
		return NULL;

	old = *s;

	*s = strpbrk(*s, WHITESPACE QUOTE "=");
	if (*s == NULL)
		return (old);

	if (*s[0] == '\"') {
		memmove(*s, *s + 1, strlen(*s)); /* move nul too */
		/* Find matching quote */
		if ((*s = strpbrk(*s, QUOTE)) == NULL) {
			return (NULL);		/* no matching quote */
		} else {
			*s[0] = '\0';
			*s += strspn(*s + 1, WHITESPACE) + 1;
			return (old);
		}
	}

	/* Allow only one '=' to be skipped */
	if (*s[0] == '=')
		wspace = 1;
	*s[0] = '\0';

	/* Skip any extra whitespace after first token */
	*s += strspn(*s + 1, WHITESPACE) + 1;
	if (*s[0] == '=' && !wspace)
		*s += strspn(*s + 1, WHITESPACE) + 1;

	return (old);
}

struct passwd *
pwcopy(struct passwd *pw)
{
	struct passwd *copy = xcalloc(1, sizeof(*copy));

	copy->pw_name = xstrdup(pw->pw_name);
	copy->pw_passwd = xstrdup(pw->pw_passwd);
	copy->pw_gecos = xstrdup(pw->pw_gecos);
	copy->pw_uid = pw->pw_uid;
	copy->pw_gid = pw->pw_gid;
	copy->pw_expire = pw->pw_expire;
	copy->pw_change = pw->pw_change;
	copy->pw_class = xstrdup(pw->pw_class);
	copy->pw_dir = xstrdup(pw->pw_dir);
	copy->pw_shell = xstrdup(pw->pw_shell);
	return copy;
}

/*
 * Convert ASCII string to TCP/IP port number.
 * Port must be >=0 and <=65535.
 * Return -1 if invalid.
 */
int
a2port(const char *s)
{
	long long port;
	const char *errstr;

	port = strtonum(s, 0, 65535, &errstr);
	if (errstr != NULL)
		return -1;
	return (int)port;
}

int
a2tun(const char *s, int *remote)
{
	const char *errstr = NULL;
	char *sp, *ep;
	int tun;

	if (remote != NULL) {
		*remote = SSH_TUNID_ANY;
		sp = xstrdup(s);
		if ((ep = strchr(sp, ':')) == NULL) {
			free(sp);
			return (a2tun(s, NULL));
		}
		ep[0] = '\0'; ep++;
		*remote = a2tun(ep, NULL);
		tun = a2tun(sp, NULL);
		free(sp);
		return (*remote == SSH_TUNID_ERR ? *remote : tun);
	}

	if (strcasecmp(s, "any") == 0)
		return (SSH_TUNID_ANY);

	tun = strtonum(s, 0, SSH_TUNID_MAX, &errstr);
	if (errstr != NULL)
		return (SSH_TUNID_ERR);

	return (tun);
}

#define SECONDS		1
#define MINUTES		(SECONDS * 60)
#define HOURS		(MINUTES * 60)
#define DAYS		(HOURS * 24)
#define WEEKS		(DAYS * 7)

/*
 * Convert a time string into seconds; format is
 * a sequence of:
 *      time[qualifier]
 *
 * Valid time qualifiers are:
 *      <none>  seconds
 *      s|S     seconds
 *      m|M     minutes
 *      h|H     hours
 *      d|D     days
 *      w|W     weeks
 *
 * Examples:
 *      90m     90 minutes
 *      1h30m   90 minutes
 *      2d      2 days
 *      1w      1 week
 *
 * Return -1 if time string is invalid.
 */
long
convtime(const char *s)
{
	long total, secs, multiplier = 1;
	const char *p;
	char *endp;

	errno = 0;
	total = 0;
	p = s;

	if (p == NULL || *p == '\0')
		return -1;

	while (*p) {
		secs = strtol(p, &endp, 10);
		if (p == endp ||
		    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||
		    secs < 0)
			return -1;

		switch (*endp++) {
		case '\0':
			endp--;
			break;
		case 's':
		case 'S':
			break;
		case 'm':
		case 'M':
			multiplier = MINUTES;
			break;
		case 'h':
		case 'H':
			multiplier = HOURS;
			break;
		case 'd':
		case 'D':
			multiplier = DAYS;
			break;
		case 'w':
		case 'W':
			multiplier = WEEKS;
			break;
		default:
			return -1;
		}
		if (secs >= LONG_MAX / multiplier)
			return -1;
		secs *= multiplier;
		if  (total >= LONG_MAX - secs)
			return -1;
		total += secs;
		if (total < 0)
			return -1;
		p = endp;
	}

	return total;
}

/*
 * Returns a standardized host+port identifier string.
 * Caller must free returned string.
 */
char *
put_host_port(const char *host, u_short port)
{
	char *hoststr;

	if (port == 0 || port == SSH_DEFAULT_PORT)
		return(xstrdup(host));
	if (asprintf(&hoststr, "[%s]:%d", host, (int)port) < 0)
		fatal("put_host_port: asprintf: %s", strerror(errno));
	debug3("put_host_port: %s", hoststr);
	return hoststr;
}

/*
 * Search for next delimiter between hostnames/addresses and ports.
 * Argument may be modified (for termination).
 * Returns *cp if parsing succeeds.
 * *cp is set to the start of the next delimiter, if one was found.
 * If this is the last field, *cp is set to NULL.
 */
char *
hpdelim(char **cp)
{
	char *s, *old;

	if (cp == NULL || *cp == NULL)
		return NULL;

	old = s = *cp;
	if (*s == '[') {
		if ((s = strchr(s, ']')) == NULL)
			return NULL;
		else
			s++;
	} else if ((s = strpbrk(s, ":/")) == NULL)
		s = *cp + strlen(*cp); /* skip to end (see first case below) */

	switch (*s) {
	case '\0':
		*cp = NULL;	/* no more fields*/
		break;

	case ':':
	case '/':
		*s = '\0';	/* terminate */
		*cp = s + 1;
		break;

	default:
		return NULL;
	}

	return old;
}

char *
cleanhostname(char *host)
{
	if (*host == '[' && host[strlen(host) - 1] == ']') {
		host[strlen(host) - 1] = '\0';
		return (host + 1);
	} else
		return host;
}

char *
colon(char *cp)
{
	int flag = 0;

	if (*cp == ':')		/* Leading colon is part of file name. */
		return NULL;
	if (*cp == '[')
		flag = 1;

	for (; *cp; ++cp) {
		if (*cp == '@@' && *(cp+1) == '[')
			flag = 1;
		if (*cp == ']' && *(cp+1) == ':' && flag)
			return (cp+1);
		if (*cp == ':' && !flag)
			return (cp);
		if (*cp == '/')
			return NULL;
	}
	return NULL;
}

/*
 * Parse a [user@@]host[:port] string.
 * Caller must free returned user and host.
 * Any of the pointer return arguments may be NULL (useful for syntax checking).
 * If user was not specified then *userp will be set to NULL.
 * If port was not specified then *portp will be -1.
 * Returns 0 on success, -1 on failure.
 */
int
parse_user_host_port(const char *s, char **userp, char **hostp, int *portp)
{
	char *sdup, *cp, *tmp;
	char *user = NULL, *host = NULL;
	int port = -1, ret = -1;

	if (userp != NULL)
		*userp = NULL;
	if (hostp != NULL)
		*hostp = NULL;
	if (portp != NULL)
		*portp = -1;

	if ((sdup = tmp = strdup(s)) == NULL)
		return -1;
	/* Extract optional username */
	if ((cp = strchr(tmp, '@@')) != NULL) {
		*cp = '\0';
		if (*tmp == '\0')
			goto out;
		if ((user = strdup(tmp)) == NULL)
			goto out;
		tmp = cp + 1;
	}
	/* Extract mandatory hostname */
	if ((cp = hpdelim(&tmp)) == NULL || *cp == '\0')
		goto out;
	host = xstrdup(cleanhostname(cp));
	/* Convert and verify optional port */
	if (tmp != NULL && *tmp != '\0') {
		if ((port = a2port(tmp)) <= 0)
			goto out;
	}
	/* Success */
	if (userp != NULL) {
		*userp = user;
		user = NULL;
	}
	if (hostp != NULL) {
		*hostp = host;
		host = NULL;
	}
	if (portp != NULL)
		*portp = port;
	ret = 0;
 out:
	free(sdup);
	free(user);
	free(host);
	return ret;
}

/* function to assist building execv() arguments */
void
addargs(arglist *args, char *fmt, ...)
{
	va_list ap;
	char *cp;
	u_int nalloc;
	int r;

	va_start(ap, fmt);
	r = vasprintf(&cp, fmt, ap);
	va_end(ap);
	if (r == -1)
		fatal("addargs: argument too long");

	nalloc = args->nalloc;
	if (args->list == NULL) {
		nalloc = 32;
		args->num = 0;
	} else if (args->num+2 >= nalloc)
		nalloc *= 2;

	args->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));
	args->nalloc = nalloc;
	args->list[args->num++] = cp;
	args->list[args->num] = NULL;
}

void
replacearg(arglist *args, u_int which, char *fmt, ...)
{
	va_list ap;
	char *cp;
	int r;

	va_start(ap, fmt);
	r = vasprintf(&cp, fmt, ap);
	va_end(ap);
	if (r == -1)
		fatal("replacearg: argument too long");

	if (which >= args->num)
		fatal("replacearg: tried to replace invalid arg %d >= %d",
		    which, args->num);
	free(args->list[which]);
	args->list[which] = cp;
}

void
freeargs(arglist *args)
{
	u_int i;

	if (args->list != NULL) {
		for (i = 0; i < args->num; i++)
			free(args->list[i]);
		free(args->list);
		args->nalloc = args->num = 0;
		args->list = NULL;
	}
}

/*
 * Expands tildes in the file name.  Returns data allocated by xmalloc.
 * Warning: this calls getpw*.
 */
char *
tilde_expand_filename(const char *filename, uid_t uid)
{
	const char *path, *sep;
	char user[128], *ret;
	struct passwd *pw;
	u_int len, slash;

	if (*filename != '~')
		return (xstrdup(filename));
	filename++;

	path = strchr(filename, '/');
	if (path != NULL && path > filename) {		/* ~user/path */
		slash = path - filename;
		if (slash > sizeof(user) - 1)
			fatal("tilde_expand_filename: ~username too long");
		memcpy(user, filename, slash);
		user[slash] = '\0';
		if ((pw = getpwnam(user)) == NULL)
			fatal("tilde_expand_filename: No such user %s", user);
	} else if ((pw = getpwuid(uid)) == NULL)	/* ~/path */
		fatal("tilde_expand_filename: No such uid %ld", (long)uid);

	/* Make sure directory has a trailing '/' */
	len = strlen(pw->pw_dir);
	if (len == 0 || pw->pw_dir[len - 1] != '/')
		sep = "/";
	else
		sep = "";

	/* Skip leading '/' from specified path */
	if (path != NULL)
		filename = path + 1;

	if (xasprintf(&ret, "%s%s%s", pw->pw_dir, sep, filename) >= PATH_MAX)
		fatal("tilde_expand_filename: Path too long");

	return (ret);
}

/*
 * Expand a string with a set of %[char] escapes. A number of escapes may be
 * specified as (char *escape_chars, char *replacement) pairs. The list must
 * be terminated by a NULL escape_char. Returns replaced string in memory
 * allocated by xmalloc.
 */
char *
percent_expand(const char *string, ...)
{
#define EXPAND_MAX_KEYS	16
	u_int num_keys, i, j;
	struct {
		const char *key;
		const char *repl;
	} keys[EXPAND_MAX_KEYS];
	char buf[4096];
	va_list ap;

	/* Gather keys */
	va_start(ap, string);
	for (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {
		keys[num_keys].key = va_arg(ap, char *);
		if (keys[num_keys].key == NULL)
			break;
		keys[num_keys].repl = va_arg(ap, char *);
		if (keys[num_keys].repl == NULL)
			fatal("%s: NULL replacement", __func__);
	}
	if (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)
		fatal("%s: too many keys", __func__);
	va_end(ap);

	/* Expand string */
	*buf = '\0';
	for (i = 0; *string != '\0'; string++) {
		if (*string != '%') {
 append:
			buf[i++] = *string;
			if (i >= sizeof(buf))
				fatal("%s: string too long", __func__);
			buf[i] = '\0';
			continue;
		}
		string++;
		/* %% case */
		if (*string == '%')
			goto append;
		if (*string == '\0')
			fatal("%s: invalid format", __func__);
		for (j = 0; j < num_keys; j++) {
			if (strchr(keys[j].key, *string) != NULL) {
				i = strlcat(buf, keys[j].repl, sizeof(buf));
				if (i >= sizeof(buf))
					fatal("%s: string too long", __func__);
				break;
			}
		}
		if (j >= num_keys)
			fatal("%s: unknown key %%%c", __func__, *string);
	}
	return (xstrdup(buf));
#undef EXPAND_MAX_KEYS
}

/*
 * Read an entire line from a public key file into a static buffer, discarding
 * lines that exceed the buffer size.  Returns 0 on success, -1 on failure.
 */
int
read_keyfile_line(FILE *f, const char *filename, char *buf, size_t bufsz,
   u_long *lineno)
{
	while (fgets(buf, bufsz, f) != NULL) {
		if (buf[0] == '\0')
			continue;
		(*lineno)++;
		if (buf[strlen(buf) - 1] == '\n' || feof(f)) {
			return 0;
		} else {
			debug("%s: %s line %lu exceeds size limit", __func__,
			    filename, *lineno);
			/* discard remainder of line */
			while (fgetc(f) != '\n' && !feof(f))
				;	/* nothing */
		}
	}
	return -1;
}

int
tun_open(int tun, int mode)
{
	struct ifreq ifr;
	char name[100];
	int fd = -1, sock;
	const char *tunbase = "tun";

	if (mode == SSH_TUNMODE_ETHERNET)
		tunbase = "tap";

	/* Open the tunnel device */
	if (tun <= SSH_TUNID_MAX) {
		snprintf(name, sizeof(name), "/dev/%s%d", tunbase, tun);
		fd = open(name, O_RDWR);
	} else if (tun == SSH_TUNID_ANY) {
		for (tun = 100; tun >= 0; tun--) {
			snprintf(name, sizeof(name), "/dev/%s%d",
			    tunbase, tun);
			if ((fd = open(name, O_RDWR)) >= 0)
				break;
		}
	} else {
		debug("%s: invalid tunnel %u", __func__, tun);
		return -1;
	}

	if (fd < 0) {
		debug("%s: %s open: %s", __func__, name, strerror(errno));
		return -1;
	}

	debug("%s: %s mode %d fd %d", __func__, name, mode, fd);

	/* Bring interface up if it is not already */
	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s%d", tunbase, tun);
	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)
		goto failed;

	if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {
		debug("%s: get interface %s flags: %s", __func__,
		    ifr.ifr_name, strerror(errno));
		goto failed;
	}

	if (!(ifr.ifr_flags & IFF_UP)) {
		ifr.ifr_flags |= IFF_UP;
		if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {
			debug("%s: activate interface %s: %s", __func__,
			    ifr.ifr_name, strerror(errno));
			goto failed;
		}
	}

	close(sock);
	return fd;

 failed:
	if (fd >= 0)
		close(fd);
	if (sock >= 0)
		close(sock);
	return -1;
}

void
sanitise_stdfd(void)
{
	int nullfd, dupfd;

	if ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
		fprintf(stderr, "Couldn't open /dev/null: %s\n",
		    strerror(errno));
		exit(1);
	}
	while (++dupfd <= STDERR_FILENO) {
		/* Only populate closed fds. */
		if (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {
			if (dup2(nullfd, dupfd) == -1) {
				fprintf(stderr, "dup2: %s\n", strerror(errno));
				exit(1);
			}
		}
	}
	if (nullfd > STDERR_FILENO)
		close(nullfd);
}

char *
tohex(const void *vp, size_t l)
{
	const u_char *p = (const u_char *)vp;
	char b[3], *r;
	size_t i, hl;

	if (l > 65536)
		return xstrdup("tohex: length > 65536");

	hl = l * 2 + 1;
	r = xcalloc(1, hl);
	for (i = 0; i < l; i++) {
		snprintf(b, sizeof(b), "%02x", p[i]);
		strlcat(r, b, hl);
	}
	return (r);
}

u_int64_t
get_u64(const void *vp)
{
	const u_char *p = (const u_char *)vp;
	u_int64_t v;

	v  = (u_int64_t)p[0] << 56;
	v |= (u_int64_t)p[1] << 48;
	v |= (u_int64_t)p[2] << 40;
	v |= (u_int64_t)p[3] << 32;
	v |= (u_int64_t)p[4] << 24;
	v |= (u_int64_t)p[5] << 16;
	v |= (u_int64_t)p[6] << 8;
	v |= (u_int64_t)p[7];

	return (v);
}

u_int32_t
get_u32(const void *vp)
{
	const u_char *p = (const u_char *)vp;
	u_int32_t v;

	v  = (u_int32_t)p[0] << 24;
	v |= (u_int32_t)p[1] << 16;
	v |= (u_int32_t)p[2] << 8;
	v |= (u_int32_t)p[3];

	return (v);
}

u_int32_t
get_u32_le(const void *vp)
{
	const u_char *p = (const u_char *)vp;
	u_int32_t v;

	v  = (u_int32_t)p[0];
	v |= (u_int32_t)p[1] << 8;
	v |= (u_int32_t)p[2] << 16;
	v |= (u_int32_t)p[3] << 24;

	return (v);
}

u_int16_t
get_u16(const void *vp)
{
	const u_char *p = (const u_char *)vp;
	u_int16_t v;

	v  = (u_int16_t)p[0] << 8;
	v |= (u_int16_t)p[1];

	return (v);
}

void
put_u64(void *vp, u_int64_t v)
{
	u_char *p = (u_char *)vp;

	p[0] = (u_char)(v >> 56) & 0xff;
	p[1] = (u_char)(v >> 48) & 0xff;
	p[2] = (u_char)(v >> 40) & 0xff;
	p[3] = (u_char)(v >> 32) & 0xff;
	p[4] = (u_char)(v >> 24) & 0xff;
	p[5] = (u_char)(v >> 16) & 0xff;
	p[6] = (u_char)(v >> 8) & 0xff;
	p[7] = (u_char)v & 0xff;
}

void
put_u32(void *vp, u_int32_t v)
{
	u_char *p = (u_char *)vp;

	p[0] = (u_char)(v >> 24) & 0xff;
	p[1] = (u_char)(v >> 16) & 0xff;
	p[2] = (u_char)(v >> 8) & 0xff;
	p[3] = (u_char)v & 0xff;
}

void
put_u32_le(void *vp, u_int32_t v)
{
	u_char *p = (u_char *)vp;

	p[0] = (u_char)v & 0xff;
	p[1] = (u_char)(v >> 8) & 0xff;
	p[2] = (u_char)(v >> 16) & 0xff;
	p[3] = (u_char)(v >> 24) & 0xff;
}

void
put_u16(void *vp, u_int16_t v)
{
	u_char *p = (u_char *)vp;

	p[0] = (u_char)(v >> 8) & 0xff;
	p[1] = (u_char)v & 0xff;
}

void
ms_subtract_diff(struct timeval *start, int *ms)
{
	struct timeval diff, finish;

	gettimeofday(&finish, NULL);
	timersub(&finish, start, &diff);	
	*ms -= (diff.tv_sec * 1000) + (diff.tv_usec / 1000);
}

void
ms_to_timeval(struct timeval *tv, int ms)
{
	if (ms < 0)
		ms = 0;
	tv->tv_sec = ms / 1000;
	tv->tv_usec = (ms % 1000) * 1000;
}

time_t
monotime(void)
{
	struct timespec ts;

	if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0)
		fatal("clock_gettime: %s", strerror(errno));

	return (ts.tv_sec);
}

double
monotime_double(void)
{
	struct timespec ts;

	if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0)
		fatal("clock_gettime: %s", strerror(errno));

	return (ts.tv_sec + (double)ts.tv_nsec / 1000000000);
}

void
bandwidth_limit_init(struct bwlimit *bw, u_int64_t kbps, size_t buflen)
{
	bw->buflen = buflen;
	bw->rate = kbps;
	bw->thresh = bw->rate;
	bw->lamt = 0;
	timerclear(&bw->bwstart);
	timerclear(&bw->bwend);
}	

/* Callback from read/write loop to insert bandwidth-limiting delays */
void
bandwidth_limit(struct bwlimit *bw, size_t read_len)
{
	u_int64_t waitlen;
	struct timespec ts, rm;

	if (!timerisset(&bw->bwstart)) {
		gettimeofday(&bw->bwstart, NULL);
		return;
	}

	bw->lamt += read_len;
	if (bw->lamt < bw->thresh)
		return;

	gettimeofday(&bw->bwend, NULL);
	timersub(&bw->bwend, &bw->bwstart, &bw->bwend);
	if (!timerisset(&bw->bwend))
		return;

	bw->lamt *= 8;
	waitlen = (double)1000000L * bw->lamt / bw->rate;

	bw->bwstart.tv_sec = waitlen / 1000000L;
	bw->bwstart.tv_usec = waitlen % 1000000L;

	if (timercmp(&bw->bwstart, &bw->bwend, >)) {
		timersub(&bw->bwstart, &bw->bwend, &bw->bwend);

		/* Adjust the wait time */
		if (bw->bwend.tv_sec) {
			bw->thresh /= 2;
			if (bw->thresh < bw->buflen / 4)
				bw->thresh = bw->buflen / 4;
		} else if (bw->bwend.tv_usec < 10000) {
			bw->thresh *= 2;
			if (bw->thresh > bw->buflen * 8)
				bw->thresh = bw->buflen * 8;
		}

		TIMEVAL_TO_TIMESPEC(&bw->bwend, &ts);
		while (nanosleep(&ts, &rm) == -1) {
			if (errno != EINTR)
				break;
			ts = rm;
		}
	}

	bw->lamt = 0;
	gettimeofday(&bw->bwstart, NULL);
}

/* Make a template filename for mk[sd]temp() */
void
mktemp_proto(char *s, size_t len)
{
	const char *tmpdir;
	int r;

	if ((tmpdir = getenv("TMPDIR")) != NULL) {
		r = snprintf(s, len, "%s/ssh-XXXXXXXXXXXX", tmpdir);
		if (r > 0 && (size_t)r < len)
			return;
	}
	r = snprintf(s, len, "/tmp/ssh-XXXXXXXXXXXX");
	if (r < 0 || (size_t)r >= len)
		fatal("%s: template string too short", __func__);
}

static const struct {
	const char *name;
	int value;
} ipqos[] = {
	{ "af11", IPTOS_DSCP_AF11 },
	{ "af12", IPTOS_DSCP_AF12 },
	{ "af13", IPTOS_DSCP_AF13 },
	{ "af21", IPTOS_DSCP_AF21 },
	{ "af22", IPTOS_DSCP_AF22 },
	{ "af23", IPTOS_DSCP_AF23 },
	{ "af31", IPTOS_DSCP_AF31 },
	{ "af32", IPTOS_DSCP_AF32 },
	{ "af33", IPTOS_DSCP_AF33 },
	{ "af41", IPTOS_DSCP_AF41 },
	{ "af42", IPTOS_DSCP_AF42 },
	{ "af43", IPTOS_DSCP_AF43 },
	{ "cs0", IPTOS_DSCP_CS0 },
	{ "cs1", IPTOS_DSCP_CS1 },
	{ "cs2", IPTOS_DSCP_CS2 },
	{ "cs3", IPTOS_DSCP_CS3 },
	{ "cs4", IPTOS_DSCP_CS4 },
	{ "cs5", IPTOS_DSCP_CS5 },
	{ "cs6", IPTOS_DSCP_CS6 },
	{ "cs7", IPTOS_DSCP_CS7 },
	{ "ef", IPTOS_DSCP_EF },
	{ "lowdelay", IPTOS_LOWDELAY },
	{ "throughput", IPTOS_THROUGHPUT },
	{ "reliability", IPTOS_RELIABILITY },
	{ NULL, -1 }
};

int
parse_ipqos(const char *cp)
{
	u_int i;
	char *ep;
	long val;

	if (cp == NULL)
		return -1;
	for (i = 0; ipqos[i].name != NULL; i++) {
		if (strcasecmp(cp, ipqos[i].name) == 0)
			return ipqos[i].value;
	}
	/* Try parsing as an integer */
	val = strtol(cp, &ep, 0);
	if (*cp == '\0' || *ep != '\0' || val < 0 || val > 255)
		return -1;
	return val;
}

const char *
iptos2str(int iptos)
{
	int i;
	static char iptos_str[sizeof "0xff"];

	for (i = 0; ipqos[i].name != NULL; i++) {
		if (ipqos[i].value == iptos)
			return ipqos[i].name;
	}
	snprintf(iptos_str, sizeof iptos_str, "0x%02x", iptos);
	return iptos_str;
}

void
lowercase(char *s)
{
	for (; *s; s++)
		*s = tolower((u_char)*s);
}

int
unix_listener(const char *path, int backlog, int unlink_first)
{
	struct sockaddr_un sunaddr;
	int saved_errno, sock;

	memset(&sunaddr, 0, sizeof(sunaddr));
	sunaddr.sun_family = AF_UNIX;
	if (strlcpy(sunaddr.sun_path, path, sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {
		error("%s: \"%s\" too long for Unix domain socket", __func__,
		    path);
		errno = ENAMETOOLONG;
		return -1;
	}

	sock = socket(PF_UNIX, SOCK_STREAM, 0);
	if (sock < 0) {
		saved_errno = errno;
		error("socket: %.100s", strerror(errno));
		errno = saved_errno;
		return -1;
	}
	if (unlink_first == 1) {
		if (unlink(path) != 0 && errno != ENOENT)
			error("unlink(%s): %.100s", path, strerror(errno));
	}
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {
		saved_errno = errno;
		error("bind: %.100s", strerror(errno));
		close(sock);
		error("%s: cannot bind to path: %s", __func__, path);
		errno = saved_errno;
		return -1;
	}
	if (listen(sock, backlog) < 0) {
		saved_errno = errno;
		error("listen: %.100s", strerror(errno));
		close(sock);
		unlink(path);
		error("%s: cannot listen on path: %s", __func__, path);
		errno = saved_errno;
		return -1;
	}
	return sock;
}

/*
 * Compares two strings that maybe be NULL. Returns non-zero if strings
 * are both NULL or are identical, returns zero otherwise.
 */
static int
strcmp_maybe_null(const char *a, const char *b)
{
	if ((a == NULL && b != NULL) || (a != NULL && b == NULL))
		return 0;
	if (a != NULL && strcmp(a, b) != 0)
		return 0;
	return 1;
}

/*
 * Compare two forwards, returning non-zero if they are identical or
 * zero otherwise.
 */
int
forward_equals(const struct Forward *a, const struct Forward *b)
{
	if (strcmp_maybe_null(a->listen_host, b->listen_host) == 0)
		return 0;
	if (a->listen_port != b->listen_port)
		return 0;
	if (strcmp_maybe_null(a->listen_path, b->listen_path) == 0)
		return 0;
	if (strcmp_maybe_null(a->connect_host, b->connect_host) == 0)
		return 0;
	if (a->connect_port != b->connect_port)
		return 0;
	if (strcmp_maybe_null(a->connect_path, b->connect_path) == 0)
		return 0;
	/* allocated_port and handle are not checked */
	return 1;
}

/* returns 1 if bind to specified port by specified user is permitted */
int
bind_permitted(int port, uid_t uid)
{
	if (port < IPPORT_RESERVED && uid != 0)
		return 0;
	return 1;
}

/* returns 1 if process is already daemonized, 0 otherwise */
int
daemonized(void)
{
	int fd;

	if ((fd = open(_PATH_TTY, O_RDONLY | O_NOCTTY)) >= 0) {
		close(fd);
		return 0;	/* have controlling terminal */
	}
	if (getppid() != 1)
		return 0;	/* parent is not init */
	if (getsid(0) != getpid())
		return 0;	/* not session leader */
	debug3("already daemonized");
	return 1;
}
@


1.109
log
@Fix convtime() overflow test on boundary condition, spotted by & ok djm.
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.108 2017/03/14 00:25:03 dtucker Exp $ */
d525 1
a525 1
	args->list = xreallocarray(args->list, nalloc, sizeof(char *));
@


1.108
log
@Check for integer overflow when parsing times in convtime().  Reported by
nicolas.iooss at m4x.org, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.107 2016/11/30 00:28:31 dtucker Exp $ */
d336 1
a336 1
		if (secs > LONG_MAX / multiplier)
d339 1
a339 1
		if  (total > LONG_MAX - secs)
@


1.107
log
@On startup, check to see if sshd is already daemonized and if so,
skip the call to daemon() and do not rewrite the PidFile.  This
means that when sshd re-execs itself on SIGHUP the process ID will
no longer change.  Should address bz#2641.  ok djm@@ markus@@.
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.106 2016/10/23 22:04:05 dtucker Exp $ */
d292 1
a292 1
	long total, secs;
d319 1
a319 1
			secs *= MINUTES;
d323 1
a323 1
			secs *= HOURS;
d327 1
a327 1
			secs *= DAYS;
d331 1
a331 1
			secs *= WEEKS;
d336 5
@


1.106
log
@Factor out "can bind to low ports" check into its own function.  This will make
it easier for Portable to support platforms with permissions models other than
uid==0 (eg bz#2625).  ok djm@@, "doesn't offend me too much" deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.105 2016/07/15 00:24:30 djm Exp $ */
d1188 18
@


1.105
log
@Add a ProxyJump ssh_config(5) option and corresponding -J ssh(1)
command-line flag to allow simplified indirection through a
SSH bastion or "jump host".

These options construct a proxy command that connects to the
specified jump host(s) (more than one may be specified) and uses
port-forwarding to establish a connection to the next destination.

This codifies the safest way of indirecting connections through SSH
servers and makes it easy to use.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.104 2016/04/06 06:42:17 djm Exp $ */
d1182 8
@


1.104
log
@don't record duplicate LocalForward and RemoteForward entries;
fixes failure with ExitOnForwardFailure+hostname canonicalisation
where the same forwards are added on the second pass through
the configuration file. bz#2562; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.103 2016/04/02 14:37:42 krw Exp $ */
d435 61
@


1.103
log
@Another use for fcntl() and thus of the superfluous 3rd parameter
is when sanitising standard fd's before calling daemon().

Use a tweaked version of the ssh(1) function in all three places
found using fcntl() this way.

ok jca@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.102 2016/03/02 22:42:40 dtucker Exp $ */
d1083 38
@


1.102
log
@Improve precision of progressmeter for sftp and scp by storing sub-second
timestamps.  Pointed out by mmcc@@, ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.101 2016/01/20 09:22:39 dtucker Exp $ */
d78 1
a78 1
	val = fcntl(fd, F_GETFL, 0);
d80 1
a80 1
		error("fcntl(%d, F_GETFL, 0): %s", fd, strerror(errno));
d102 1
a102 1
	val = fcntl(fd, F_GETFL, 0);
d104 1
a104 1
		error("fcntl(%d, F_GETFL, 0): %s", fd, strerror(errno));
d708 7
a714 7
	while (++dupfd <= 2) {
		/* Only clobber closed fds */
		if (fcntl(dupfd, F_GETFL, 0) >= 0)
			continue;
		if (dup2(nullfd, dupfd) == -1) {
			fprintf(stderr, "dup2: %s\n", strerror(errno));
			exit(1);
d717 1
a717 1
	if (nullfd > 2)
@


1.101
log
@Include sys/time.h for gettimeofday.  From sortie at maxsi.org.
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.100 2015/12/04 21:51:06 tobias Exp $ */
d872 11
@


1.100
log
@Properly handle invalid %-format by calling fatal.

ok deraadt, djm
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.99 2015/10/24 08:34:09 sthen Exp $ */
d30 1
@


1.99
log
@Handle the split of tun(4) "link0" into tap(4) in ssh tun-forwarding.
Adapted from portable (using separate devices for this is the normal case
in most OS). ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.98 2015/10/07 00:54:06 djm Exp $ */
d590 2
@


1.98
log
@don't try to change tun device flags if they are already what
we need; makes it possible to use tun/tap networking as non-
root user if device permissions and interface flags are
pre-established; based on patch by Ossi Herrala
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.97 2015/04/24 01:36:00 deraadt Exp $ */
d636 4
d643 1
a643 1
		snprintf(name, sizeof(name), "/dev/tun%d", tun);
d647 2
a648 1
			snprintf(name, sizeof(name), "/dev/tun%d", tun);
d664 3
a666 4
	/* Set the tunnel device operation mode */
	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "tun%d", tun);
	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1) {
		error("%s: socket: %s", __func__, strerror(errno));
a667 1
	}
a674 13
	/* Set interface mode if not already in correct mode */
	if ((mode == SSH_TUNMODE_ETHERNET && !(ifr.ifr_flags & IFF_LINK0)) ||
	    (mode != SSH_TUNMODE_ETHERNET && (ifr.ifr_flags & IFF_LINK0))) {
		ifr.ifr_flags &= ~IFF_UP;
		ifr.ifr_flags ^= IFF_LINK0;
		if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {
			debug("%s: reset interface %s flags: %s", __func__,
			    ifr.ifr_name, strerror(errno));
			goto failed;
		}
	}

	/* Bring interface up if it is not already */
@


1.97
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.96 2015/01/16 06:40:12 deraadt Exp $ */
d649 1
a649 1
		return (-1);
d653 2
a654 2
		debug("%s: %s open failed: %s", __func__, name, strerror(errno));
		return (-1);
d661 2
a662 1
	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)
d664 1
d666 3
a668 1
	if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1)
d670 1
d672 11
a682 8
	/* Set interface mode */
	ifr.ifr_flags &= ~IFF_UP;
	if (mode == SSH_TUNMODE_ETHERNET)
		ifr.ifr_flags |= IFF_LINK0;
	else
		ifr.ifr_flags &= ~IFF_LINK0;
	if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)
		goto failed;
d684 9
a692 4
	/* Bring interface up */
	ifr.ifr_flags |= IFF_UP;
	if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)
		goto failed;
d695 1
a695 1
	return (fd);
d702 1
a702 3
	debug("%s: failed to set %s mode %d: %s", __func__, name,
	    mode, strerror(errno));
	return (-1);
@


1.96
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.95 2014/10/24 02:01:20 lteo Exp $ */
d458 1
a458 1
	args->list = xrealloc(args->list, nalloc, sizeof(char *));
@


1.95
log
@Remove unnecessary include: netinet/in_systm.h is not needed by these
programs.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.94 2014/07/15 15:54:14 millert Exp $ */
a30 1
#include <sys/param.h>
d43 1
d537 1
a537 1
	if (xasprintf(&ret, "%s%s%s", pw->pw_dir, sep, filename) >= MAXPATHLEN)
@


1.94
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.93 2014/04/20 02:30:25 djm Exp $ */
a34 1
#include <netinet/in_systm.h>
@


1.93
log
@use get/put_u32 to load values rather than *((UINT32 *)p) that breaks on
strict-alignment architectures; reported by and ok stsp@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.92 2013/10/14 23:28:23 djm Exp $ */
d30 1
d1022 46
@


1.92
log
@refactor client config code a little:

add multistate option partsing to readconf.c, similar to servconf.c's
existing code.

move checking of options that accept "none" as an argument to readconf.c

add a lowercase() function and use it instead of explicit tolower() in
loops

part of a larger diff that was ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.91 2013/07/12 00:43:50 djm Exp $ */
d768 14
d820 10
@


1.91
log
@in ssh_gai_strerror() don't fallback to strerror for EAI_SYSTEM when
errno == 0. Avoids confusing error message in some broken resolver
cases. bz#2122 patch from plautrba AT redhat.com; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.90 2013/06/01 13:15:52 dtucker Exp $ */
d38 1
d990 7
@


1.90
log
@Use clock_gettime(CLOCK_MONOTONIC ...) for ssh timers so that things like
keepalives and rekeying will work properly over clock steps.  Suggested by
markus@@, "looks good" djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.89 2013/05/17 00:13:13 djm Exp $ */
d122 1
a122 1
	if (gaierr == EAI_SYSTEM)
@


1.89
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.88 2013/04/24 16:01:46 tedu Exp $ */
d832 11
@


1.88
log
@remove extra parens noticed by nicm
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.87 2013/04/23 17:49:45 tedu Exp $ */
d240 1
a240 1
			xfree(sp);
d246 1
a246 1
		xfree(sp);
d479 1
a479 1
	xfree(args->list[which]);
d490 2
a491 2
			xfree(args->list[i]);
		xfree(args->list);
@


1.87
log
@use xasprintf instead of a series of strlcats and strdup. ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.86 2011/09/05 05:59:08 djm Exp $ */
d527 1
a527 1
	if ((len == 0 || pw->pw_dir[len - 1] != '/'))
@


1.86
log
@fix typo in IPQoS parsing: there is no "AF14" class, but there is
an "AF21" class. Spotted by giesen AT snickers.org; ok markus stevesk
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.85 2011/03/29 18:54:17 stevesk Exp $ */
d504 2
a505 2
	const char *path;
	char user[128], ret[MAXPATHLEN];
a524 3
	if (strlcpy(ret, pw->pw_dir, sizeof(ret)) >= sizeof(ret))
		fatal("tilde_expand_filename: Path too long");

d527 4
a530 3
	if ((len == 0 || pw->pw_dir[len - 1] != '/') &&
	    strlcat(ret, "/", sizeof(ret)) >= sizeof(ret))
		fatal("tilde_expand_filename: Path too long");
d535 2
a536 1
	if (strlcat(ret, filename, sizeof(ret)) >= sizeof(ret))
d539 1
a539 1
	return (xstrdup(ret));
@


1.85
log
@print ipqos friendly string for sshd -T; ok markus

# sshd -Tf sshd_config|grep ipqos
ipqos lowdelay throughput
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.84 2010/11/21 01:01:13 djm Exp $ */
d923 1
a923 1
	{ "af14", IPTOS_DSCP_AF21 },
@


1.84
log
@honour $TMPDIR for client xauth and ssh-agent temporary directories;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.83 2010/11/13 23:27:50 djm Exp $ */
d967 13
@


1.83
log
@allow ssh and sshd to set arbitrary TOS/DSCP/QoS values instead of
hardcoding lowdelay/throughput.

bz#1733 patch from philipp AT redfish-solutions.com; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.82 2010/09/24 13:33:00 matthew Exp $ */
d897 17
@


1.82
log
@Add timingsafe_bcmp(3) to libc, mention that it's already in the
kernel in kern(9), and remove it from OpenSSH.

ok deraadt@@, djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.81 2010/09/22 22:58:51 djm Exp $ */
d34 2
d898 52
@


1.81
log
@add an option per-read/write callback to atomicio

factor out bandwidth limiting code from scp(1) into a generic bandwidth
limiter that can be attached using the atomicio callback mechanism

add a bandwidth limit option to sftp(1) using the above

"very nice" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.80 2010/07/21 02:10:58 djm Exp $ */
a830 11
}

int
timingsafe_bcmp(const void *b1, const void *b2, size_t n)
{
	const unsigned char *p1 = b1, *p2 = b2;
	int ret = 0;

	for (; n > 0; n--)
		ret |= *p1++ ^ *p2++;
	return (ret != 0);
@


1.80
log
@sync timingsafe_bcmp() with the one dempsky@@ committed to sys/lib/libkern
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.79 2010/07/13 23:13:16 djm Exp $ */
d842 64
@


1.79
log
@s/timing_safe_cmp/timingsafe_bcmp/g
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.78 2010/07/13 11:52:06 djm Exp $ */
d834 1
a834 1
timingsafe_bcmp(const void *_s1, const void *_s2, size_t n)
d836 1
a836 2
	u_char *s1 = (u_char *)_s1;
	u_char *s2 = (u_char *)_s2;
d839 3
a841 3
	for (; n > 0; n--, s1++, s2++)
		ret |= *s1 ^ *s2;
	return ret;
a842 1

@


1.78
log
@implement a timing_safe_cmp() function to compare memory without leaking
timing information by short-circuiting like memcmp() and use it for
some of the more sensitive comparisons (though nothing high-value was
readily attackable anyway); "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.77 2010/07/02 04:32:44 djm Exp $ */
d834 1
a834 1
timing_safe_cmp(const void *_s1, const void *_s2, size_t n)
@


1.77
log
@unbreak strdelim() skipping past quoted strings, e.g.

AllowUsers "blah blah" blah

was broken; report and fix in bz#1757 from bitman.zhou AT centrify.com
ok dtucker;
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.76 2010/05/21 05:00:36 djm Exp $ */
d831 12
@


1.76
log
@colon() returns char*, so s/return (0)/return NULL/
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.75 2010/01/09 23:04:13 dtucker Exp $ */
d174 1
@


1.75
log
@Remove RoutingDomain from ssh since it's now not needed.  It can be replaced
with "route exec" or "nc -V" as a proxycommand.  "route exec" also ensures
that trafic such as DNS lookups stays withing the specified routingdomain.

For example (from reyk):
# route -T 2 exec /usr/sbin/sshd
or inherited from the parent process
$ route -T 2 exec sh
$ ssh 10.1.2.3

ok deraadt@@ markus@@ stevesk@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.71 2009/02/21 19:32:04 tobias Exp $ */
d415 1
a415 1
		return (0);
d427 1
a427 1
			return (0);
d429 1
a429 1
	return (0);
@


1.74
log
@validate routing domain is in range 0-RT_TABLEID_MAX.
'Looks right' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.73 2009/11/20 03:24:07 djm Exp $ */
a146 37
/* open a socket in the specified routing domain */
int
socket_rdomain(int domain, int type, int protocol, int rdomain)
{
	int sock, ipproto = IPPROTO_IP;

	if ((sock = socket(domain, type, protocol)) == -1)
		return (-1);

	if (rdomain == -1)
		return (sock);
	
	switch (domain) {
	case AF_INET6:
		ipproto = IPPROTO_IPV6;
		/* FALLTHROUGH */
	case AF_INET:
		debug2("socket %d af %d setting rdomain %d",
		    sock, domain, rdomain);
		if (setsockopt(sock, ipproto, SO_RDOMAIN, &rdomain,
		    sizeof(rdomain)) == -1) {
			debug("setsockopt SO_RDOMAIN: %.100s",
			    strerror(errno));
			close(sock);
			return (-1);
		}
		break;
	default:
		debug("socket %d af %d does not support rdomain %d",
		    sock, domain, rdomain);
		close(sock);
		return (-1);
	}

	return (sock);
}

a223 12
}

int
a2rdomain(const char *s)
{
	long long rdomain;
	const char *errstr;

	rdomain = strtonum(s, 0, RT_TABLEID_MAX, &errstr);
	if (errstr != NULL)
		return -1;
	return (int)rdomain;
@


1.73
log
@correct off-by-one in percent_expand(): we would fatal() when trying
to expand EXPAND_MAX_KEYS, allowing only EXPAND_MAX_KEYS-1 to actually work.
Note that nothing in OpenSSH actually uses close to this limit at present.
bz#1607 from Jan.Pechanec AT Sun.COM
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.72 2009/10/28 16:38:18 reyk Exp $ */
d261 12
@


1.72
log
@Allow to set the rdomain in ssh/sftp/scp/sshd and ssh-keyscan.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.71 2009/02/21 19:32:04 tobias Exp $ */
d587 1
a591 1
	u_int num_keys, i, j;
d603 1
a603 1
			fatal("percent_expand: NULL replacement");
d605 2
a608 3
	if (num_keys >= EXPAND_MAX_KEYS)
		fatal("percent_expand: too many keys");

d616 1
a616 1
				fatal("percent_expand: string too long");
d621 1
d628 1
a628 1
					fatal("percent_expand: string too long");
d633 1
a633 1
			fatal("percent_expand: unknown key %%%c", *string);
@


1.71
log
@Added missing newlines in error messages.

ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.70 2009/01/22 10:02:34 djm Exp $ */
d145 37
@


1.70
log
@make a2port() return -1 when it encounters an invalid port number
rather than 0, which it will now treat as valid (needed for future work)

adjust current consumers of a2port() to check its return value is <= 0,
which in turn required some things to be converted from u_short => int

make use of int vs. u_short consistent in some other places too

feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.69 2008/06/13 01:38:23 dtucker Exp $ */
d697 2
a698 1
		fprintf(stderr, "Couldn't open /dev/null: %s", strerror(errno));
d706 1
a706 1
			fprintf(stderr, "dup2: %s", strerror(errno));
@


1.69
log
@upcast uid to long with matching %ld, prevents warnings in portable
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.68 2008/06/12 20:38:28 dtucker Exp $ */
d211 2
a212 2
 * Port must be >0 and <=65535.
 * Return 0 if invalid.
d217 2
a218 2
	long port;
	char *endp;
d220 4
a223 8
	errno = 0;
	port = strtol(s, &endp, 0);
	if (s == endp || *endp != '\0' ||
	    (errno == ERANGE && (port == LONG_MIN || port == LONG_MAX)) ||
	    port <= 0 || port > 65535)
		return 0;

	return port;
@


1.68
log
@Make keepalive timeouts apply while waiting for a packet, particularly during
key renegotiation (bz #1363).  With djm and Matt Day, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.67 2008/01/01 08:47:04 dtucker Exp $ */
d524 1
a524 1
		fatal("tilde_expand_filename: No such uid %d", uid);
@


1.67
log
@spaces -> tabs from my previous commit
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.66 2007/12/27 14:22:08 dtucker Exp $ */
d815 20
@


1.66
log
@Add a small helper function to consistently handle the EAI_SYSTEM error
code of getaddrinfo.  Prompted by vgiffin at apple com via bz #1417.
ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.65 2006/11/23 01:35:11 ray Exp $ */
d120 3
a122 3
        if (gaierr == EAI_SYSTEM)
                return strerror(errno);
        return gai_strerror(gaierr);
@


1.65
log
@Don't access buf[strlen(buf) - 1] for zero-length strings.

``ok by me'' djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.64 2006/08/03 03:34:42 deraadt Exp $ */
d38 1
d115 8
@


1.64
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.63 2006/08/01 23:22:47 stevesk Exp $ */
d606 2
@


1.63
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.62 2006/07/26 13:57:17 stevesk Exp $ */
d27 1
a27 2
#include "includes.h"

a28 1
#include <sys/types.h>
d46 1
a48 1
#include "xmalloc.h"
@


1.62
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.61 2006/07/26 02:35:17 stevesk Exp $ */
d43 1
@


1.61
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.60 2006/07/22 20:48:23 stevesk Exp $ */
d43 1
@


1.60
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.59 2006/07/17 01:31:09 stevesk Exp $ */
d32 1
@


1.59
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.58 2006/07/11 20:07:25 stevesk Exp $ */
d42 1
@


1.58
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.57 2006/07/10 16:37:36 stevesk Exp $ */
d42 1
@


1.57
log
@move #include <stdarg.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.56 2006/07/10 12:46:51 dtucker Exp $ */
d37 1
@


1.56
log
@Add port identifier to known_hosts for non-default ports, based originally
on a patch from Devin Nate in bz#910.

For any connection using the default port or using a HostKeyAlias the
format is unchanged, otherwise the host name or address is enclosed
within square brackets in the same format as sshd's ListenAddress.

Tested by many, ok markus@@.
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.55 2006/07/09 15:15:10 stevesk Exp $ */
d40 1
@


1.55
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.54 2006/07/06 16:03:53 stevesk Exp $ */
d44 1
d328 17
@


1.54
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.53 2006/07/05 02:42:09 stevesk Exp $ */
d37 1
@


1.53
log
@move #include <netinet/in.h> out of includes.h; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.52 2006/03/30 09:58:15 djm Exp $ */
d30 1
d38 1
@


1.52
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.51 2006/03/25 13:17:02 djm Exp $ */
d30 1
d33 1
@


1.51
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2005 Damien Miller.  All rights reserved.
d679 1
a679 1
tohex(const u_char *d, u_int l)
d681 1
d683 4
a686 1
	u_int i, hl;
d691 1
a691 1
		snprintf(b, sizeof(b), "%02x", d[i]);
d697 79
@


1.50
log
@change OpenSSH's xrealloc() function from being xrealloc(p, new_size) to
xrealloc(p, new_nmemb, new_itemsize).

realloc is particularly prone to integer overflows because it is almost
always allocating "n * size" bytes, so this is a far safer API;
ok deraadt@@
@
text
@d1 1
@


1.49
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d420 1
a420 1
	args->list = xrealloc(args->list, nalloc * sizeof(char *));
@


1.48
log
@in a switch (), break after return or goto is stupid
@
text
@d173 1
a173 1
	struct passwd *copy = xmalloc(sizeof(*copy));
a174 1
	memset(copy, 0, sizeof(*copy));
d684 1
a684 2
	r = xmalloc(hl);
	*r = '\0';
@


1.47
log
@RCSID() can die
@
text
@d292 1
@


1.46
log
@Allow config directives to contain whitespace by surrounding them by double
quotes.  mindrot #482, man page help from jmc@@, ok djm@@
@
text
@a26 1
RCSID("$OpenBSD: misc.c,v 1.45 2006/02/10 00:27:13 stevesk Exp $");
@


1.45
log
@move #include <sys/ioctl.h> out of includes.h; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.44 2006/02/08 12:32:49 stevesk Exp $");
d129 1
d143 1
a143 1
	*s = strpbrk(*s, WHITESPACE "=");
d147 11
d163 1
@


1.45.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: misc.c,v 1.64 2006/08/03 03:34:42 deraadt Exp $ */
d3 1
a3 1
 * Copyright (c) 2005,2006 Damien Miller.  All rights reserved.
d26 3
a28 1
#include <sys/types.h>
a29 2
#include <sys/socket.h>
#include <sys/param.h>
a31 1
#include <netinet/in.h>
a33 2
#include <errno.h>
#include <fcntl.h>
a34 6
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a35 1
#include "xmalloc.h"
d38 1
a38 1
#include "ssh.h"
a128 1
#define QUOTE	"\""
d142 1
a142 1
	*s = strpbrk(*s, WHITESPACE QUOTE "=");
a145 11
	if (*s[0] == '\"') {
		memmove(*s, *s + 1, strlen(*s)); /* move nul too */
		/* Find matching quote */
		if ((*s = strpbrk(*s, QUOTE)) == NULL) {
			return (NULL);		/* no matching quote */
		} else {
			*s[0] = '\0';
			return (old);
		}
	}

a150 1
	/* Skip any extra whitespace after first token */
d161 1
a161 1
	struct passwd *copy = xcalloc(1, sizeof(*copy));
d163 1
a279 1
			break;
a311 17
 * Returns a standardized host+port identifier string.
 * Caller must free returned string.
 */
char *
put_host_port(const char *host, u_short port)
{
	char *hoststr;

	if (port == 0 || port == SSH_DEFAULT_PORT)
		return(xstrdup(host));
	if (asprintf(&hoststr, "[%s]:%d", host, (int)port) < 0)
		fatal("put_host_port: asprintf: %s", strerror(errno));
	debug3("put_host_port: %s", hoststr);
	return hoststr;
}

/*
d408 1
a408 1
	args->list = xrealloc(args->list, nalloc, sizeof(char *));
d666 1
a666 1
tohex(const void *vp, size_t l)
a667 1
	const u_char *p = (const u_char *)vp;
d669 1
a669 4
	size_t i, hl;

	if (l > 65536)
		return xstrdup("tohex: length > 65536");
d672 2
a673 1
	r = xcalloc(1, hl);
d675 1
a675 1
		snprintf(b, sizeof(b), "%02x", p[i]);
a680 79
u_int64_t
get_u64(const void *vp)
{
	const u_char *p = (const u_char *)vp;
	u_int64_t v;

	v  = (u_int64_t)p[0] << 56;
	v |= (u_int64_t)p[1] << 48;
	v |= (u_int64_t)p[2] << 40;
	v |= (u_int64_t)p[3] << 32;
	v |= (u_int64_t)p[4] << 24;
	v |= (u_int64_t)p[5] << 16;
	v |= (u_int64_t)p[6] << 8;
	v |= (u_int64_t)p[7];

	return (v);
}

u_int32_t
get_u32(const void *vp)
{
	const u_char *p = (const u_char *)vp;
	u_int32_t v;

	v  = (u_int32_t)p[0] << 24;
	v |= (u_int32_t)p[1] << 16;
	v |= (u_int32_t)p[2] << 8;
	v |= (u_int32_t)p[3];

	return (v);
}

u_int16_t
get_u16(const void *vp)
{
	const u_char *p = (const u_char *)vp;
	u_int16_t v;

	v  = (u_int16_t)p[0] << 8;
	v |= (u_int16_t)p[1];

	return (v);
}

void
put_u64(void *vp, u_int64_t v)
{
	u_char *p = (u_char *)vp;

	p[0] = (u_char)(v >> 56) & 0xff;
	p[1] = (u_char)(v >> 48) & 0xff;
	p[2] = (u_char)(v >> 40) & 0xff;
	p[3] = (u_char)(v >> 32) & 0xff;
	p[4] = (u_char)(v >> 24) & 0xff;
	p[5] = (u_char)(v >> 16) & 0xff;
	p[6] = (u_char)(v >> 8) & 0xff;
	p[7] = (u_char)v & 0xff;
}

void
put_u32(void *vp, u_int32_t v)
{
	u_char *p = (u_char *)vp;

	p[0] = (u_char)(v >> 24) & 0xff;
	p[1] = (u_char)(v >> 16) & 0xff;
	p[2] = (u_char)(v >> 8) & 0xff;
	p[3] = (u_char)v & 0xff;
}


void
put_u16(void *vp, u_int16_t v)
{
	u_char *p = (u_char *)vp;

	p[0] = (u_char)(v >> 8) & 0xff;
	p[1] = (u_char)v & 0xff;
}
@


1.44
log
@move #include <netinet/tcp.h> out of includes.h; ok markus@@
@
text
@d27 3
a29 1
RCSID("$OpenBSD: misc.c,v 1.43 2006/02/08 12:15:27 stevesk Exp $");
@


1.43
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.42 2006/01/31 10:19:02 djm Exp $");
d30 1
@


1.42
log
@fix local arbitrary command execution vulnerability on local/local and
remote/remote copies (CVE-2006-0225, bz #1094), patch by
t8m AT centrum.cz, polished by dtucker@@ and myself; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.41 2006/01/05 23:43:53 djm Exp $");
d30 2
@


1.41
log
@check that stdio file descriptors are actually closed before clobbering
them in sanitise_stdfd(). problems occurred when a lower numbered fd was
closed, but higher ones weren't. spotted by, and patch tested by
Frdric Olivi
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.40 2006/01/02 07:53:44 reyk Exp $");
d386 1
a386 1
	char buf[1024];
d388 1
d391 1
a391 1
	vsnprintf(buf, sizeof(buf), fmt, ap);
d393 2
d405 1
a405 1
	args->list[args->num++] = xstrdup(buf);
d407 34
@


1.40
log
@clarify tun(4) opening - set the mode and bring the interface up. also
(re)sets the tun(4) layer 2 LINK0 flag for existing tunnel interfaces.

suggested and ok by djm@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.39 2006/01/01 10:08:48 stevesk Exp $");
d604 1
a604 1
	int nullfd;
d606 1
a606 1
	if ((nullfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
d610 5
a614 2
	while (nullfd < 2) {
		if (dup2(nullfd, nullfd + 1) == -1) {
a617 1
		nullfd++;
@


1.39
log
@no trailing "\n" for debug()
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.38 2006/01/01 08:59:27 stevesk Exp $");
d573 4
a576 1
	if (mode == SSH_TUNMODE_ETHERNET) {
d578 6
a583 3
		if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)
			goto failed;
	}
@


1.38
log
@move <net/if.h>; ok djm@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.37 2005/12/08 18:34:11 reyk Exp $");
d555 1
a555 1
		debug("%s: invalid tunnel %u\n", __func__, tun);
@


1.37
log
@two changes to the new ssh tunnel support. this breaks compatibility
with the initial commit but is required for a portable approach.
- make the tunnel id u_int and platform friendly, use predefined types.
- support configuration of layer 2 (ethernet) or layer 3
(point-to-point, default) modes. configuration is done using the
Tunnel (yes|point-to-point|ethernet|no) option is ssh_config(5) and
restricted by the PermitTunnel (yes|point-to-point|ethernet|no) option
in sshd_config(5).

ok djm@@, man page bits by jmc@@
@
text
@d27 3
a29 1
RCSID("$OpenBSD: misc.c,v 1.36 2005/12/06 22:38:27 reyk Exp $");
@


1.36
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.35 2005/09/13 23:40:07 djm Exp $");
d199 1
a199 1
		*remote = -1;
d209 1
a209 1
		return (tun);
d213 1
a213 1
		return (-1);
d215 3
a217 3
	tun = strtonum(s, 0, INT_MAX, &errstr);
	if (errstr != NULL || tun < -1)
		return (-2);
d536 1
a536 1
tun_open(int tun)
d538 1
d540 1
a540 1
	int i, fd;
d542 2
a543 1
	if (tun > -1) {
d545 6
a550 3
		if ((fd = open(name, O_RDWR)) >= 0)  {
			debug("%s: %s: %d", __func__, name, fd);
			return (fd);
d553 7
a559 7
		for (i = 100; i >= 0; i--) {
			snprintf(name, sizeof(name), "/dev/tun%d", i);
			if ((fd = open(name, O_RDWR)) >= 0)  {
				debug("%s: %s: %d", __func__, name, fd);
				return (fd);
			}
		}
d561 29
a589 1
	debug("%s: %s failed: %s", __func__, name, strerror(errno));
@


1.35
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.34 2005/07/08 09:26:18 dtucker Exp $");
d191 31
d533 25
@


1.34
log
@Make comment match code; ok djm@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.33 2005/07/04 00:58:43 djm Exp $");
d502 20
@


1.34.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d27 1
a27 3
RCSID("$OpenBSD: misc.c,v 1.42 2006/01/31 10:19:02 djm Exp $");

#include <net/if.h>
a190 31
int
a2tun(const char *s, int *remote)
{
	const char *errstr = NULL;
	char *sp, *ep;
	int tun;

	if (remote != NULL) {
		*remote = SSH_TUNID_ANY;
		sp = xstrdup(s);
		if ((ep = strchr(sp, ':')) == NULL) {
			xfree(sp);
			return (a2tun(s, NULL));
		}
		ep[0] = '\0'; ep++;
		*remote = a2tun(ep, NULL);
		tun = a2tun(sp, NULL);
		xfree(sp);
		return (*remote == SSH_TUNID_ERR ? *remote : tun);
	}

	if (strcasecmp(s, "any") == 0)
		return (SSH_TUNID_ANY);

	tun = strtonum(s, 0, SSH_TUNID_MAX, &errstr);
	if (errstr != NULL)
		return (SSH_TUNID_ERR);

	return (tun);
}

d353 1
a353 1
	char *cp;
a354 1
	int r;
d357 1
a357 1
	r = vasprintf(&cp, fmt, ap);
a358 2
	if (r == -1)
		fatal("addargs: argument too long");
d369 1
a369 1
	args->list[args->num++] = cp;
a372 34
void
replacearg(arglist *args, u_int which, char *fmt, ...)
{
	va_list ap;
	char *cp;
	int r;

	va_start(ap, fmt);
	r = vasprintf(&cp, fmt, ap);
	va_end(ap);
	if (r == -1)
		fatal("replacearg: argument too long");

	if (which >= args->num)
		fatal("replacearg: tried to replace invalid arg %d >= %d",
		    which, args->num);
	xfree(args->list[which]);
	args->list[which] = cp;
}

void
freeargs(arglist *args)
{
	u_int i;

	if (args->list != NULL) {
		for (i = 0; i < args->num; i++)
			xfree(args->list[i]);
		xfree(args->list);
		args->nalloc = args->num = 0;
		args->list = NULL;
	}
}

a501 86
}

int
tun_open(int tun, int mode)
{
	struct ifreq ifr;
	char name[100];
	int fd = -1, sock;

	/* Open the tunnel device */
	if (tun <= SSH_TUNID_MAX) {
		snprintf(name, sizeof(name), "/dev/tun%d", tun);
		fd = open(name, O_RDWR);
	} else if (tun == SSH_TUNID_ANY) {
		for (tun = 100; tun >= 0; tun--) {
			snprintf(name, sizeof(name), "/dev/tun%d", tun);
			if ((fd = open(name, O_RDWR)) >= 0)
				break;
		}
	} else {
		debug("%s: invalid tunnel %u", __func__, tun);
		return (-1);
	}

	if (fd < 0) {
		debug("%s: %s open failed: %s", __func__, name, strerror(errno));
		return (-1);
	}

	debug("%s: %s mode %d fd %d", __func__, name, mode, fd);

	/* Set the tunnel device operation mode */
	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "tun%d", tun);
	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)
		goto failed;

	if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1)
		goto failed;

	/* Set interface mode */
	ifr.ifr_flags &= ~IFF_UP;
	if (mode == SSH_TUNMODE_ETHERNET)
		ifr.ifr_flags |= IFF_LINK0;
	else
		ifr.ifr_flags &= ~IFF_LINK0;
	if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)
		goto failed;

	/* Bring interface up */
	ifr.ifr_flags |= IFF_UP;
	if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)
		goto failed;

	close(sock);
	return (fd);

 failed:
	if (fd >= 0)
		close(fd);
	if (sock >= 0)
		close(sock);
	debug("%s: failed to set %s mode %d: %s", __func__, name,
	    mode, strerror(errno));
	return (-1);
}

void
sanitise_stdfd(void)
{
	int nullfd, dupfd;

	if ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
		fprintf(stderr, "Couldn't open /dev/null: %s", strerror(errno));
		exit(1);
	}
	while (++dupfd <= 2) {
		/* Only clobber closed fds */
		if (fcntl(dupfd, F_GETFL, 0) >= 0)
			continue;
		if (dup2(nullfd, dupfd) == -1) {
			fprintf(stderr, "dup2: %s", strerror(errno));
			exit(1);
		}
	}
	if (nullfd > 2)
		close(nullfd);
@


1.34.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: misc.c,v 1.64 2006/08/03 03:34:42 deraadt Exp $ */
d3 1
a3 1
 * Copyright (c) 2005,2006 Damien Miller.  All rights reserved.
d26 2
a27 4
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/param.h>
a29 2
#include <netinet/in.h>
#include <netinet/tcp.h>
a30 11
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
d33 1
a33 1
#include "ssh.h"
a123 1
#define QUOTE	"\""
d137 1
a137 1
	*s = strpbrk(*s, WHITESPACE QUOTE "=");
a140 11
	if (*s[0] == '\"') {
		memmove(*s, *s + 1, strlen(*s)); /* move nul too */
		/* Find matching quote */
		if ((*s = strpbrk(*s, QUOTE)) == NULL) {
			return (NULL);		/* no matching quote */
		} else {
			*s[0] = '\0';
			return (old);
		}
	}

a145 1
	/* Skip any extra whitespace after first token */
d156 1
a156 1
	struct passwd *copy = xcalloc(1, sizeof(*copy));
d158 1
a274 1
			break;
a306 17
 * Returns a standardized host+port identifier string.
 * Caller must free returned string.
 */
char *
put_host_port(const char *host, u_short port)
{
	char *hoststr;

	if (port == 0 || port == SSH_DEFAULT_PORT)
		return(xstrdup(host));
	if (asprintf(&hoststr, "[%s]:%d", host, (int)port) < 0)
		fatal("put_host_port: asprintf: %s", strerror(errno));
	debug3("put_host_port: %s", hoststr);
	return hoststr;
}

/*
d403 1
a403 1
	args->list = xrealloc(args->list, nalloc, sizeof(char *));
d661 1
a661 1
tohex(const void *vp, size_t l)
a662 1
	const u_char *p = (const u_char *)vp;
d664 1
a664 4
	size_t i, hl;

	if (l > 65536)
		return xstrdup("tohex: length > 65536");
d667 2
a668 1
	r = xcalloc(1, hl);
d670 1
a670 1
		snprintf(b, sizeof(b), "%02x", p[i]);
a675 79
u_int64_t
get_u64(const void *vp)
{
	const u_char *p = (const u_char *)vp;
	u_int64_t v;

	v  = (u_int64_t)p[0] << 56;
	v |= (u_int64_t)p[1] << 48;
	v |= (u_int64_t)p[2] << 40;
	v |= (u_int64_t)p[3] << 32;
	v |= (u_int64_t)p[4] << 24;
	v |= (u_int64_t)p[5] << 16;
	v |= (u_int64_t)p[6] << 8;
	v |= (u_int64_t)p[7];

	return (v);
}

u_int32_t
get_u32(const void *vp)
{
	const u_char *p = (const u_char *)vp;
	u_int32_t v;

	v  = (u_int32_t)p[0] << 24;
	v |= (u_int32_t)p[1] << 16;
	v |= (u_int32_t)p[2] << 8;
	v |= (u_int32_t)p[3];

	return (v);
}

u_int16_t
get_u16(const void *vp)
{
	const u_char *p = (const u_char *)vp;
	u_int16_t v;

	v  = (u_int16_t)p[0] << 8;
	v |= (u_int16_t)p[1];

	return (v);
}

void
put_u64(void *vp, u_int64_t v)
{
	u_char *p = (u_char *)vp;

	p[0] = (u_char)(v >> 56) & 0xff;
	p[1] = (u_char)(v >> 48) & 0xff;
	p[2] = (u_char)(v >> 40) & 0xff;
	p[3] = (u_char)(v >> 32) & 0xff;
	p[4] = (u_char)(v >> 24) & 0xff;
	p[5] = (u_char)(v >> 16) & 0xff;
	p[6] = (u_char)(v >> 8) & 0xff;
	p[7] = (u_char)v & 0xff;
}

void
put_u32(void *vp, u_int32_t v)
{
	u_char *p = (u_char *)vp;

	p[0] = (u_char)(v >> 24) & 0xff;
	p[1] = (u_char)(v >> 16) & 0xff;
	p[2] = (u_char)(v >> 8) & 0xff;
	p[3] = (u_char)v & 0xff;
}


void
put_u16(void *vp, u_int16_t v)
{
	u_char *p = (u_char *)vp;

	p[0] = (u_char)(v >> 8) & 0xff;
	p[1] = (u_char)v & 0xff;
}
@


1.33
log
@implement support for X11 and agent forwarding over multiplex slave
connections. Because of protocol limitations, the slave connections inherit
the master's DISPLAY and SSH_AUTH_SOCK rather than distinctly forwarding
their own.

ok dtucker@@ "put it in" deraadt@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.32 2005/06/17 02:44:32 djm Exp $");
d422 1
a422 1
 * be terminated by an escape_char of -1. Returns replaced string in memory
@


1.32
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.31 2005/06/06 11:20:36 djm Exp $");
d503 17
@


1.31
log
@introduce a generic %foo expansion function. replace existing % expansion and
add expansion to ControlPath; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.30 2005/04/09 04:32:54 djm Exp $");
d383 1
a383 1
	int len;
d391 2
a392 1
		if (path - filename > sizeof(user) - 1)
d394 2
a395 2
		memcpy(user, filename, path - filename);
		user[path - filename] = '\0';
d433 1
a433 1
	int num_keys, i, j;
@


1.30
log
@replace tilde_expand_filename with a simpler implementation, ahead of more
whacking; ok deraadt@@
@
text
@d3 1
d27 1
a27 1
RCSID("$OpenBSD: misc.c,v 1.29 2005/03/10 22:01:05 deraadt Exp $");
d416 62
@


1.29
log
@spacing
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.28 2005/03/01 10:09:52 djm Exp $");
d370 45
@


1.29.2.1
log
@upgrade to OpenSSH 4.2
@
text
@a2 1
 * Copyright (c) 2005 Damien Miller.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.34 2005/07/08 09:26:18 dtucker Exp $");
a372 108
 * Expands tildes in the file name.  Returns data allocated by xmalloc.
 * Warning: this calls getpw*.
 */
char *
tilde_expand_filename(const char *filename, uid_t uid)
{
	const char *path;
	char user[128], ret[MAXPATHLEN];
	struct passwd *pw;
	u_int len, slash;

	if (*filename != '~')
		return (xstrdup(filename));
	filename++;

	path = strchr(filename, '/');
	if (path != NULL && path > filename) {		/* ~user/path */
		slash = path - filename;
		if (slash > sizeof(user) - 1)
			fatal("tilde_expand_filename: ~username too long");
		memcpy(user, filename, slash);
		user[slash] = '\0';
		if ((pw = getpwnam(user)) == NULL)
			fatal("tilde_expand_filename: No such user %s", user);
	} else if ((pw = getpwuid(uid)) == NULL)	/* ~/path */
		fatal("tilde_expand_filename: No such uid %d", uid);

	if (strlcpy(ret, pw->pw_dir, sizeof(ret)) >= sizeof(ret))
		fatal("tilde_expand_filename: Path too long");

	/* Make sure directory has a trailing '/' */
	len = strlen(pw->pw_dir);
	if ((len == 0 || pw->pw_dir[len - 1] != '/') &&
	    strlcat(ret, "/", sizeof(ret)) >= sizeof(ret))
		fatal("tilde_expand_filename: Path too long");

	/* Skip leading '/' from specified path */
	if (path != NULL)
		filename = path + 1;
	if (strlcat(ret, filename, sizeof(ret)) >= sizeof(ret))
		fatal("tilde_expand_filename: Path too long");

	return (xstrdup(ret));
}

/*
 * Expand a string with a set of %[char] escapes. A number of escapes may be
 * specified as (char *escape_chars, char *replacement) pairs. The list must
 * be terminated by a NULL escape_char. Returns replaced string in memory
 * allocated by xmalloc.
 */
char *
percent_expand(const char *string, ...)
{
#define EXPAND_MAX_KEYS	16
	struct {
		const char *key;
		const char *repl;
	} keys[EXPAND_MAX_KEYS];
	u_int num_keys, i, j;
	char buf[4096];
	va_list ap;

	/* Gather keys */
	va_start(ap, string);
	for (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {
		keys[num_keys].key = va_arg(ap, char *);
		if (keys[num_keys].key == NULL)
			break;
		keys[num_keys].repl = va_arg(ap, char *);
		if (keys[num_keys].repl == NULL)
			fatal("percent_expand: NULL replacement");
	}
	va_end(ap);

	if (num_keys >= EXPAND_MAX_KEYS)
		fatal("percent_expand: too many keys");

	/* Expand string */
	*buf = '\0';
	for (i = 0; *string != '\0'; string++) {
		if (*string != '%') {
 append:
			buf[i++] = *string;
			if (i >= sizeof(buf))
				fatal("percent_expand: string too long");
			buf[i] = '\0';
			continue;
		}
		string++;
		if (*string == '%')
			goto append;
		for (j = 0; j < num_keys; j++) {
			if (strchr(keys[j].key, *string) != NULL) {
				i = strlcat(buf, keys[j].repl, sizeof(buf));
				if (i >= sizeof(buf))
					fatal("percent_expand: string too long");
				break;
			}
		}
		if (j >= num_keys)
			fatal("percent_expand: unknown key %%%c", *string);
	}
	return (xstrdup(buf));
#undef EXPAND_MAX_KEYS
}

/*
a393 17

char *
tohex(const u_char *d, u_int l)
{
	char b[3], *r;
	u_int i, hl;

	hl = l * 2 + 1;
	r = xmalloc(hl);
	*r = '\0';
	for (i = 0; i < l; i++) {
		snprintf(b, sizeof(b), "%02x", d[i]);
		strlcat(r, b, hl);
	}
	return (r);
}

@


1.29.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d27 1
a27 3
RCSID("$OpenBSD: misc.c,v 1.42 2006/01/31 10:19:02 djm Exp $");

#include <net/if.h>
a190 31
int
a2tun(const char *s, int *remote)
{
	const char *errstr = NULL;
	char *sp, *ep;
	int tun;

	if (remote != NULL) {
		*remote = SSH_TUNID_ANY;
		sp = xstrdup(s);
		if ((ep = strchr(sp, ':')) == NULL) {
			xfree(sp);
			return (a2tun(s, NULL));
		}
		ep[0] = '\0'; ep++;
		*remote = a2tun(ep, NULL);
		tun = a2tun(sp, NULL);
		xfree(sp);
		return (*remote == SSH_TUNID_ERR ? *remote : tun);
	}

	if (strcasecmp(s, "any") == 0)
		return (SSH_TUNID_ANY);

	tun = strtonum(s, 0, SSH_TUNID_MAX, &errstr);
	if (errstr != NULL)
		return (SSH_TUNID_ERR);

	return (tun);
}

d353 1
a353 1
	char *cp;
a354 1
	int r;
d357 1
a357 1
	r = vasprintf(&cp, fmt, ap);
a358 2
	if (r == -1)
		fatal("addargs: argument too long");
d369 1
a369 1
	args->list[args->num++] = cp;
a372 34
void
replacearg(arglist *args, u_int which, char *fmt, ...)
{
	va_list ap;
	char *cp;
	int r;

	va_start(ap, fmt);
	r = vasprintf(&cp, fmt, ap);
	va_end(ap);
	if (r == -1)
		fatal("replacearg: argument too long");

	if (which >= args->num)
		fatal("replacearg: tried to replace invalid arg %d >= %d",
		    which, args->num);
	xfree(args->list[which]);
	args->list[which] = cp;
}

void
freeargs(arglist *args)
{
	u_int i;

	if (args->list != NULL) {
		for (i = 0; i < args->num; i++)
			xfree(args->list[i]);
		xfree(args->list);
		args->nalloc = args->num = 0;
		args->list = NULL;
	}
}

a501 86
}

int
tun_open(int tun, int mode)
{
	struct ifreq ifr;
	char name[100];
	int fd = -1, sock;

	/* Open the tunnel device */
	if (tun <= SSH_TUNID_MAX) {
		snprintf(name, sizeof(name), "/dev/tun%d", tun);
		fd = open(name, O_RDWR);
	} else if (tun == SSH_TUNID_ANY) {
		for (tun = 100; tun >= 0; tun--) {
			snprintf(name, sizeof(name), "/dev/tun%d", tun);
			if ((fd = open(name, O_RDWR)) >= 0)
				break;
		}
	} else {
		debug("%s: invalid tunnel %u", __func__, tun);
		return (-1);
	}

	if (fd < 0) {
		debug("%s: %s open failed: %s", __func__, name, strerror(errno));
		return (-1);
	}

	debug("%s: %s mode %d fd %d", __func__, name, mode, fd);

	/* Set the tunnel device operation mode */
	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "tun%d", tun);
	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)
		goto failed;

	if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1)
		goto failed;

	/* Set interface mode */
	ifr.ifr_flags &= ~IFF_UP;
	if (mode == SSH_TUNMODE_ETHERNET)
		ifr.ifr_flags |= IFF_LINK0;
	else
		ifr.ifr_flags &= ~IFF_LINK0;
	if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)
		goto failed;

	/* Bring interface up */
	ifr.ifr_flags |= IFF_UP;
	if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)
		goto failed;

	close(sock);
	return (fd);

 failed:
	if (fd >= 0)
		close(fd);
	if (sock >= 0)
		close(sock);
	debug("%s: failed to set %s mode %d: %s", __func__, name,
	    mode, strerror(errno));
	return (-1);
}

void
sanitise_stdfd(void)
{
	int nullfd, dupfd;

	if ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
		fprintf(stderr, "Couldn't open /dev/null: %s", strerror(errno));
		exit(1);
	}
	while (++dupfd <= 2) {
		/* Only clobber closed fds */
		if (fcntl(dupfd, F_GETFL, 0) >= 0)
			continue;
		if (dup2(nullfd, dupfd) == -1) {
			fprintf(stderr, "dup2: %s", strerror(errno));
			exit(1);
		}
	}
	if (nullfd > 2)
		close(nullfd);
@


1.28
log
@bz#413: allow optional specification of bind address for port forwardings.
Patch originally by Dan Astorian, but worked on by several people
Adds GatewayPorts=clientspecified option on server to allow remote forwards
to bind to client-specified ports.

ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.27 2004/12/11 01:48:56 dtucker Exp $");
d300 1
a300 1
	
d306 1
a306 1
	
d388 1
a388 1
			while(fgetc(f) != '\n' && !feof(f))
@


1.27
log
@Fix debug call in error path of authorized_keys processing and fix related
warnings; ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.26 2004/12/06 11:41:03 dtucker Exp $");
d270 42
@


1.26
log
@Discard over-length authorized_keys entries rather than complaining when
they don't decode.  bz #884, with & ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.25 2004/08/11 21:43:05 avsm Exp $");
d336 1
a336 1
   int *lineno)
d343 2
a344 2
			debug("%s: %s line %d exceeds size limit", __func__,
			    filename, lineno);
@


1.25
log
@some signed/unsigned int comparison cleanups; markus@@ ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.24 2004/06/14 01:44:39 djm Exp $");
d328 23
@


1.25.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.28 2005/03/01 10:09:52 djm Exp $");
a271 42
/*
 * Search for next delimiter between hostnames/addresses and ports.
 * Argument may be modified (for termination).
 * Returns *cp if parsing succeeds.
 * *cp is set to the start of the next delimiter, if one was found.
 * If this is the last field, *cp is set to NULL.
 */
char *
hpdelim(char **cp)
{
	char *s, *old;

	if (cp == NULL || *cp == NULL)
		return NULL;

	old = s = *cp;
	if (*s == '[') {
		if ((s = strchr(s, ']')) == NULL)
			return NULL;
		else
			s++;
	} else if ((s = strpbrk(s, ":/")) == NULL)
		s = *cp + strlen(*cp); /* skip to end (see first case below) */

	switch (*s) {
	case '\0':
		*cp = NULL;	/* no more fields*/
		break;
	
	case ':':
	case '/':
		*s = '\0';	/* terminate */
		*cp = s + 1;
		break;
	
	default:
		return NULL;
	}

	return old;
}

a327 23
}

/*
 * Read an entire line from a public key file into a static buffer, discarding
 * lines that exceed the buffer size.  Returns 0 on success, -1 on failure.
 */
int
read_keyfile_line(FILE *f, const char *filename, char *buf, size_t bufsz,
   u_long *lineno)
{
	while (fgets(buf, bufsz, f) != NULL) {
		(*lineno)++;
		if (buf[strlen(buf) - 1] == '\n' || feof(f)) {
			return 0;
		} else {
			debug("%s: %s line %lu exceeds size limit", __func__,
			    filename, *lineno);
			/* discard remainder of line */
			while(fgetc(f) != '\n' && !feof(f))
				;	/* nothing */
		}
	}
	return -1;
@


1.25.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.29 2005/03/10 22:01:05 deraadt Exp $");
d300 1
a300 1

d306 1
a306 1

d388 1
a388 1
			while (fgetc(f) != '\n' && !feof(f))
@


1.25.2.3
log
@upgrade to OpenSSH 4.2
@
text
@a2 1
 * Copyright (c) 2005 Damien Miller.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.34 2005/07/08 09:26:18 dtucker Exp $");
a372 108
 * Expands tildes in the file name.  Returns data allocated by xmalloc.
 * Warning: this calls getpw*.
 */
char *
tilde_expand_filename(const char *filename, uid_t uid)
{
	const char *path;
	char user[128], ret[MAXPATHLEN];
	struct passwd *pw;
	u_int len, slash;

	if (*filename != '~')
		return (xstrdup(filename));
	filename++;

	path = strchr(filename, '/');
	if (path != NULL && path > filename) {		/* ~user/path */
		slash = path - filename;
		if (slash > sizeof(user) - 1)
			fatal("tilde_expand_filename: ~username too long");
		memcpy(user, filename, slash);
		user[slash] = '\0';
		if ((pw = getpwnam(user)) == NULL)
			fatal("tilde_expand_filename: No such user %s", user);
	} else if ((pw = getpwuid(uid)) == NULL)	/* ~/path */
		fatal("tilde_expand_filename: No such uid %d", uid);

	if (strlcpy(ret, pw->pw_dir, sizeof(ret)) >= sizeof(ret))
		fatal("tilde_expand_filename: Path too long");

	/* Make sure directory has a trailing '/' */
	len = strlen(pw->pw_dir);
	if ((len == 0 || pw->pw_dir[len - 1] != '/') &&
	    strlcat(ret, "/", sizeof(ret)) >= sizeof(ret))
		fatal("tilde_expand_filename: Path too long");

	/* Skip leading '/' from specified path */
	if (path != NULL)
		filename = path + 1;
	if (strlcat(ret, filename, sizeof(ret)) >= sizeof(ret))
		fatal("tilde_expand_filename: Path too long");

	return (xstrdup(ret));
}

/*
 * Expand a string with a set of %[char] escapes. A number of escapes may be
 * specified as (char *escape_chars, char *replacement) pairs. The list must
 * be terminated by a NULL escape_char. Returns replaced string in memory
 * allocated by xmalloc.
 */
char *
percent_expand(const char *string, ...)
{
#define EXPAND_MAX_KEYS	16
	struct {
		const char *key;
		const char *repl;
	} keys[EXPAND_MAX_KEYS];
	u_int num_keys, i, j;
	char buf[4096];
	va_list ap;

	/* Gather keys */
	va_start(ap, string);
	for (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {
		keys[num_keys].key = va_arg(ap, char *);
		if (keys[num_keys].key == NULL)
			break;
		keys[num_keys].repl = va_arg(ap, char *);
		if (keys[num_keys].repl == NULL)
			fatal("percent_expand: NULL replacement");
	}
	va_end(ap);

	if (num_keys >= EXPAND_MAX_KEYS)
		fatal("percent_expand: too many keys");

	/* Expand string */
	*buf = '\0';
	for (i = 0; *string != '\0'; string++) {
		if (*string != '%') {
 append:
			buf[i++] = *string;
			if (i >= sizeof(buf))
				fatal("percent_expand: string too long");
			buf[i] = '\0';
			continue;
		}
		string++;
		if (*string == '%')
			goto append;
		for (j = 0; j < num_keys; j++) {
			if (strchr(keys[j].key, *string) != NULL) {
				i = strlcat(buf, keys[j].repl, sizeof(buf));
				if (i >= sizeof(buf))
					fatal("percent_expand: string too long");
				break;
			}
		}
		if (j >= num_keys)
			fatal("percent_expand: unknown key %%%c", *string);
	}
	return (xstrdup(buf));
#undef EXPAND_MAX_KEYS
}

/*
a393 17

char *
tohex(const u_char *d, u_int l)
{
	char b[3], *r;
	u_int i, hl;

	hl = l * 2 + 1;
	r = xmalloc(hl);
	*r = '\0';
	for (i = 0; i < l; i++) {
		snprintf(b, sizeof(b), "%02x", d[i]);
		strlcat(r, b, hl);
	}
	return (r);
}

@


1.24
log
@set_nonblock() instead of fnctl(...,O_NONBLOCK); "looks sane" deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.23 2003/10/28 09:08:06 markus Exp $");
d311 1
a311 1
	int nalloc;
@


1.23
log
@error->debug for getsockopt+TCP_NODELAY; several requests
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.22 2003/09/18 08:49:45 markus Exp $");
d49 1
a49 1
void
d57 1
a57 1
		return;
d60 2
a61 2
		debug2("fd %d is O_NONBLOCK", fd);
		return;
d65 6
a70 3
	if (fcntl(fd, F_SETFL, val) == -1)
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
		    fd, strerror(errno));
d73 1
a73 1
void
d81 1
a81 1
		return;
d84 2
a85 2
		debug2("fd %d is not O_NONBLOCK", fd);
		return;
d89 2
a90 2
	if (fcntl(fd, F_SETFL, val) == -1)
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
d92 3
@


1.23.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.25 2004/08/11 21:43:05 avsm Exp $");
d49 1
a49 1
int
d57 1
a57 1
		return (-1);
d60 2
a61 2
		debug3("fd %d is O_NONBLOCK", fd);
		return (0);
d65 3
a67 6
	if (fcntl(fd, F_SETFL, val) == -1) {
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd,
		    strerror(errno));
		return (-1);
	}
	return (0);
d70 1
a70 1
int
d78 1
a78 1
		return (-1);
d81 2
a82 2
		debug3("fd %d is not O_NONBLOCK", fd);
		return (0);
d86 2
a87 2
	if (fcntl(fd, F_SETFL, val) == -1) {
		debug("fcntl(%d, F_SETFL, ~O_NONBLOCK): %s",
a88 3
		return (-1);
	}
	return (0);
d305 1
a305 1
	u_int nalloc;
@


1.23.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.28 2005/03/01 10:09:52 djm Exp $");
a271 42
/*
 * Search for next delimiter between hostnames/addresses and ports.
 * Argument may be modified (for termination).
 * Returns *cp if parsing succeeds.
 * *cp is set to the start of the next delimiter, if one was found.
 * If this is the last field, *cp is set to NULL.
 */
char *
hpdelim(char **cp)
{
	char *s, *old;

	if (cp == NULL || *cp == NULL)
		return NULL;

	old = s = *cp;
	if (*s == '[') {
		if ((s = strchr(s, ']')) == NULL)
			return NULL;
		else
			s++;
	} else if ((s = strpbrk(s, ":/")) == NULL)
		s = *cp + strlen(*cp); /* skip to end (see first case below) */

	switch (*s) {
	case '\0':
		*cp = NULL;	/* no more fields*/
		break;
	
	case ':':
	case '/':
		*s = '\0';	/* terminate */
		*cp = s + 1;
		break;
	
	default:
		return NULL;
	}

	return old;
}

a327 23
}

/*
 * Read an entire line from a public key file into a static buffer, discarding
 * lines that exceed the buffer size.  Returns 0 on success, -1 on failure.
 */
int
read_keyfile_line(FILE *f, const char *filename, char *buf, size_t bufsz,
   u_long *lineno)
{
	while (fgets(buf, bufsz, f) != NULL) {
		(*lineno)++;
		if (buf[strlen(buf) - 1] == '\n' || feof(f)) {
			return 0;
		} else {
			debug("%s: %s line %lu exceeds size limit", __func__,
			    filename, *lineno);
			/* discard remainder of line */
			while(fgetc(f) != '\n' && !feof(f))
				;	/* nothing */
		}
	}
	return -1;
@


1.22
log
@more buffer allocation fixes; from Solar Designer; CAN-2003-0682; ok millert@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.21 2003/04/12 10:15:36 markus Exp $");
d100 1
a100 1
		error("getsockopt TCP_NODELAY: %.100s", strerror(errno));
@


1.21
log
@debug->debug2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.20 2002/12/13 10:03:15 markus Exp $");
d305 1
d311 1
d313 1
a313 1
		args->nalloc = 32;
d315 2
a316 2
	} else if (args->num+2 >= args->nalloc)
		args->nalloc *= 2;
d318 2
a319 1
	args->list = xrealloc(args->list, args->nalloc * sizeof(char *));
@


1.21.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.23 2003/10/28 09:08:06 markus Exp $");
d100 1
a100 1
		debug("getsockopt TCP_NODELAY: %.100s", strerror(errno));
a304 1
	int nalloc;
a309 1
	nalloc = args->nalloc;
d311 1
a311 1
		nalloc = 32;
d313 2
a314 2
	} else if (args->num+2 >= nalloc)
		nalloc *= 2;
d316 1
a316 2
	args->list = xrealloc(args->list, nalloc * sizeof(char *));
	args->nalloc = nalloc;
@


1.21.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.25 2004/08/11 21:43:05 avsm Exp $");
d49 1
a49 1
int
d57 1
a57 1
		return (-1);
d60 2
a61 2
		debug3("fd %d is O_NONBLOCK", fd);
		return (0);
d65 3
a67 6
	if (fcntl(fd, F_SETFL, val) == -1) {
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd,
		    strerror(errno));
		return (-1);
	}
	return (0);
d70 1
a70 1
int
d78 1
a78 1
		return (-1);
d81 2
a82 2
		debug3("fd %d is not O_NONBLOCK", fd);
		return (0);
d86 2
a87 2
	if (fcntl(fd, F_SETFL, val) == -1) {
		debug("fcntl(%d, F_SETFL, ~O_NONBLOCK): %s",
a88 3
		return (-1);
	}
	return (0);
d305 1
a305 1
	u_int nalloc;
@


1.20
log
@cleanup debug messages, more useful information for the client user.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.19 2002/03/04 17:27:39 stevesk Exp $");
d63 1
a63 1
	debug("fd %d setting O_NONBLOCK", fd);
@


1.20.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.21 2003/04/12 10:15:36 markus Exp $");
d63 1
a63 1
	debug2("fd %d setting O_NONBLOCK", fd);
@


1.20.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.23 2003/10/28 09:08:06 markus Exp $");
d100 1
a100 1
		debug("getsockopt TCP_NODELAY: %.100s", strerror(errno));
a304 1
	int nalloc;
a309 1
	nalloc = args->nalloc;
d311 1
a311 1
		nalloc = 32;
d313 2
a314 2
	} else if (args->num+2 >= nalloc)
		nalloc *= 2;
d316 1
a316 2
	args->list = xrealloc(args->list, nalloc * sizeof(char *));
	args->nalloc = nalloc;
@


1.19
log
@$OpenBSD$ and RCSID() cleanup: don't use RCSID() in .h files; add
missing RCSID() to .c files and remove dup /*$OpenBSD$*/ from .c
files.  ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.18 2002/03/04 13:10:46 markus Exp $");
d108 1
a108 1
	debug("fd %d setting TCP_NODELAY", fd);
@


1.19.2.1
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.20 2002/12/13 10:03:15 markus Exp $");
d108 1
a108 1
	debug2("fd %d setting TCP_NODELAY", fd);
@


1.19.4.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.20 2002/12/13 10:03:15 markus Exp $");
d108 1
a108 1
	debug2("fd %d setting TCP_NODELAY", fd);
@


1.19.4.2
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.21 2003/04/12 10:15:36 markus Exp $");
d63 1
a63 1
	debug2("fd %d setting O_NONBLOCK", fd);
@


1.18
log
@error-> debug, because O_NONBLOCK for /dev/null causes too many different errnos; ok stevesk@@, deraadt@@
@
text
@a0 2
/*	$OpenBSD: misc.c,v 1.17 2002/02/26 20:03:51 stevesk Exp $	*/

d26 1
a26 1
RCSID("$OpenBSD: misc.c,v 1.17 2002/02/26 20:03:51 stevesk Exp $");
@


1.17
log
@use socklen_t
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.16 2002/02/24 19:59:42 stevesk Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.16 2002/02/24 19:59:42 stevesk Exp $");
d68 2
a69 3
		if (errno != ENODEV)
			error("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
			    fd, strerror(errno));
d89 2
a90 3
		if (errno != ENODEV)
			error("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
			    fd, strerror(errno));
@


1.16
log
@disable Nagle in connect_to() and channel_post_port_listener() (port
forwarding endpoints).  the intention is to preserve the on-the-wire
appearance to applications at either end; the applications can then
enable TCP_NODELAY according to their requirements. ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.15 2002/01/24 21:09:25 stevesk Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.15 2002/01/24 21:09:25 stevesk Exp $");
d99 2
a100 1
	int opt, optlen;
@


1.15
log
@add set_nodelay() to set TCP_NODELAY on a socket (prep for nagle tuning).
no nagle changes just yet; ok djm@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.14 2001/12/19 07:18:56 deraadt Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.14 2001/12/19 07:18:56 deraadt Exp $");
d99 1
a99 1
	int on = 1;
d101 10
d112 1
a112 1
	if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof on) == -1)
@


1.14
log
@basic KNF done while i was looking for something else
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.13 2001/12/05 10:06:12 deraadt Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.13 2001/12/05 10:06:12 deraadt Exp $");
d93 11
@


1.13
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.12 2001/06/26 17:27:24 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.12 2001/06/26 17:27:24 markus Exp $");
d295 1
a295 1
	} else if (args->num+2 >= args->nalloc) 
@


1.12
log
@remove comments from .h, since they are cut&paste from the .c files
and out of sync
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.11 2001/06/16 08:58:34 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.11 2001/06/16 08:58:34 markus Exp $");
d40 1
a40 1
		if(*t == '\n' || *t == '\r') {
@


1.12.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d1 2
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.19 2002/03/04 17:27:39 stevesk Exp $");
d40 1
a40 1
		if (*t == '\n' || *t == '\r') {
d68 3
a70 2
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
		    fd, strerror(errno));
d90 3
a92 24
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
		    fd, strerror(errno));
}

/* disable nagle on socket */
void
set_nodelay(int fd)
{
	int opt;
	socklen_t optlen;

	optlen = sizeof opt;
	if (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {
		error("getsockopt TCP_NODELAY: %.100s", strerror(errno));
		return;
	}
	if (opt == 1) {
		debug2("fd %d is TCP_NODELAY", fd);
		return;
	}
	opt = 1;
	debug("fd %d setting TCP_NODELAY", fd);
	if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)
		error("setsockopt TCP_NODELAY: %.100s", strerror(errno));
d295 1
a295 1
	} else if (args->num+2 >= args->nalloc)
@


1.11
log
@copy pw_expire and pw_change, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.10 2001/06/16 08:49:38 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.10 2001/06/16 08:49:38 markus Exp $");
d34 1
d50 1
d98 1
d145 7
a151 1
int a2port(const char *s)
d172 23
a194 1
long convtime(const char *s)
d281 1
@


1.10
log
@typo; dunlap@@apl.washington.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.9 2001/05/19 19:43:57 stevesk Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.9 2001/05/19 19:43:57 stevesk Exp $");
d134 2
@


1.9
log
@sshd command-line arguments and configuration file options that
specify time may be expressed using a sequence of the form:
time[qualifier], where time is a positive integer value and qualifier
is one of the following:
    <none>,s,m,h,d,w
Examples:
    600     600 seconds (10 minutes)
    10m     10 minutes
    1h30m   1 hour 30 minutes (90 minutes)
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.8 2001/05/11 14:59:56 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.8 2001/05/11 14:59:56 markus Exp $");
d85 1
a85 1
	debug("fd %d setting O_NONBLOCK", fd);
@


1.8
log
@add unset_nonblock for stdout/err flushing in client_loop().
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.7 2001/05/08 19:45:24 mouring Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.7 2001/05/08 19:45:24 mouring Exp $");
d153 60
@


1.7
log
@Use addargs() in sftp plus some clean up of addargs().  OK Markus
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.6 2001/05/03 23:09:52 mouring Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.6 2001/05/03 23:09:52 mouring Exp $");
d53 1
d60 1
a60 1
		debug("fd %d IS O_NONBLOCK", fd);
d65 22
@


1.6
log
@Move colon() and cleanhost() to misc.c where I should I have put it in
the first place
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.5 2001/04/12 20:09:37 stevesk Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.5 2001/04/12 20:09:37 stevesk Exp $");
d163 21
@


1.5
log
@robust port validation; ok markus@@ jakob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.4 2001/02/28 17:52:54 deraadt Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.4 2001/02/28 17:52:54 deraadt Exp $");
d130 33
@


1.5.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.12 2001/06/26 17:27:24 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.12 2001/06/26 17:27:24 markus Exp $");
a33 1
/* remove newline at end of string */
a48 1
/* set/unset filedescriptor to non-blocking */
a52 1

d59 1
a59 1
		debug2("fd %d is O_NONBLOCK", fd);
a69 22
void
unset_nonblock(int fd)
{
	int val;

	val = fcntl(fd, F_GETFL, 0);
	if (val < 0) {
		error("fcntl(%d, F_GETFL, 0): %s", fd, strerror(errno));
		return;
	}
	if (!(val & O_NONBLOCK)) {
		debug2("fd %d is not O_NONBLOCK", fd);
		return;
	}
	debug("fd %d clearing O_NONBLOCK", fd);
	val &= ~O_NONBLOCK;
	if (fcntl(fd, F_SETFL, val) == -1)
		if (errno != ENODEV)
			error("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
			    fd, strerror(errno));
}

a72 1
/* return next token in configuration line */
a110 2
	copy->pw_expire = pw->pw_expire;
	copy->pw_change = pw->pw_change;
d117 1
a117 7
/*
 * Convert ASCII string to TCP/IP port number.
 * Port must be >0 and <=65535.
 * Return 0 if invalid.
 */
int
a2port(const char *s)
a129 137
}

#define SECONDS		1
#define MINUTES		(SECONDS * 60)
#define HOURS		(MINUTES * 60)
#define DAYS		(HOURS * 24)
#define WEEKS		(DAYS * 7)

/*
 * Convert a time string into seconds; format is
 * a sequence of:
 *      time[qualifier]
 *
 * Valid time qualifiers are:
 *      <none>  seconds
 *      s|S     seconds
 *      m|M     minutes
 *      h|H     hours
 *      d|D     days
 *      w|W     weeks
 *
 * Examples:
 *      90m     90 minutes
 *      1h30m   90 minutes
 *      2d      2 days
 *      1w      1 week
 *
 * Return -1 if time string is invalid.
 */
long
convtime(const char *s)
{
	long total, secs;
	const char *p;
	char *endp;

	errno = 0;
	total = 0;
	p = s;

	if (p == NULL || *p == '\0')
		return -1;

	while (*p) {
		secs = strtol(p, &endp, 10);
		if (p == endp ||
		    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||
		    secs < 0)
			return -1;

		switch (*endp++) {
		case '\0':
			endp--;
		case 's':
		case 'S':
			break;
		case 'm':
		case 'M':
			secs *= MINUTES;
			break;
		case 'h':
		case 'H':
			secs *= HOURS;
			break;
		case 'd':
		case 'D':
			secs *= DAYS;
			break;
		case 'w':
		case 'W':
			secs *= WEEKS;
			break;
		default:
			return -1;
		}
		total += secs;
		if (total < 0)
			return -1;
		p = endp;
	}

	return total;
}

char *
cleanhostname(char *host)
{
	if (*host == '[' && host[strlen(host) - 1] == ']') {
		host[strlen(host) - 1] = '\0';
		return (host + 1);
	} else
		return host;
}

char *
colon(char *cp)
{
	int flag = 0;

	if (*cp == ':')		/* Leading colon is part of file name. */
		return (0);
	if (*cp == '[')
		flag = 1;

	for (; *cp; ++cp) {
		if (*cp == '@@' && *(cp+1) == '[')
			flag = 1;
		if (*cp == ']' && *(cp+1) == ':' && flag)
			return (cp+1);
		if (*cp == ':' && !flag)
			return (cp);
		if (*cp == '/')
			return (0);
	}
	return (0);
}

/* function to assist building execv() arguments */
void
addargs(arglist *args, char *fmt, ...)
{
	va_list ap;
	char buf[1024];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);

	if (args->list == NULL) {
		args->nalloc = 32;
		args->num = 0;
	} else if (args->num+2 >= args->nalloc) 
		args->nalloc *= 2;

	args->list = xrealloc(args->list, args->nalloc * sizeof(char *));
	args->list[args->num++] = xstrdup(buf);
	args->list[args->num] = NULL;
@


1.5.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d1 2
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.19 2002/03/04 17:27:39 stevesk Exp $");
d40 1
a40 1
		if (*t == '\n' || *t == '\r') {
d68 3
a70 2
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
		    fd, strerror(errno));
d90 3
a92 24
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
		    fd, strerror(errno));
}

/* disable nagle on socket */
void
set_nodelay(int fd)
{
	int opt;
	socklen_t optlen;

	optlen = sizeof opt;
	if (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {
		error("getsockopt TCP_NODELAY: %.100s", strerror(errno));
		return;
	}
	if (opt == 1) {
		debug2("fd %d is TCP_NODELAY", fd);
		return;
	}
	opt = 1;
	debug("fd %d setting TCP_NODELAY", fd);
	if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)
		error("setsockopt TCP_NODELAY: %.100s", strerror(errno));
d295 1
a295 1
	} else if (args->num+2 >= args->nalloc)
@


1.4
log
@for completeness, copy pw_gecos too
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.3 2001/02/28 05:34:28 deraadt Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.3 2001/02/28 05:34:28 deraadt Exp $");
d115 15
@


1.4.2.1
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.1 2001/01/21 19:05:52 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.1 2001/01/21 19:05:52 markus Exp $");
d32 1
d98 17
@


1.4.2.2
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.4 2001/02/28 17:52:54 deraadt Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.4 2001/02/28 17:52:54 deraadt Exp $");
a31 1
#include "xmalloc.h"
a96 17
}

struct passwd *
pwcopy(struct passwd *pw)
{
	struct passwd *copy = xmalloc(sizeof(*copy));

	memset(copy, 0, sizeof(*copy));
	copy->pw_name = xstrdup(pw->pw_name);
	copy->pw_passwd = xstrdup(pw->pw_passwd);
	copy->pw_gecos = xstrdup(pw->pw_gecos);
	copy->pw_uid = pw->pw_uid;
	copy->pw_gid = pw->pw_gid;
	copy->pw_class = xstrdup(pw->pw_class);
	copy->pw_dir = xstrdup(pw->pw_dir);
	copy->pw_shell = xstrdup(pw->pw_shell);
	return copy;
@


1.3
log
@pull in protos
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.2 2001/02/22 21:59:44 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.2 2001/02/22 21:59:44 markus Exp $");
d104 1
d108 1
@


1.2
log
@use pwcopy in ssh.c, too
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.1 2001/01/21 19:05:52 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.1 2001/01/21 19:05:52 markus Exp $");
d32 1
@


1.1
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 2000/10/27 07:32:19 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: util.c,v 1.6 2000/10/27 07:32:19 markus Exp $");
d97 15
@


1.1.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.1 2001/01/21 19:05:52 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.1 2001/01/21 19:05:52 markus Exp $");
@


1.1.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.1.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.4 2001/02/28 17:52:54 deraadt Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.4 2001/02/28 17:52:54 deraadt Exp $");
a31 1
#include "xmalloc.h"
a96 17
}

struct passwd *
pwcopy(struct passwd *pw)
{
	struct passwd *copy = xmalloc(sizeof(*copy));

	memset(copy, 0, sizeof(*copy));
	copy->pw_name = xstrdup(pw->pw_name);
	copy->pw_passwd = xstrdup(pw->pw_passwd);
	copy->pw_gecos = xstrdup(pw->pw_gecos);
	copy->pw_uid = pw->pw_uid;
	copy->pw_gid = pw->pw_gid;
	copy->pw_class = xstrdup(pw->pw_class);
	copy->pw_dir = xstrdup(pw->pw_dir);
	copy->pw_shell = xstrdup(pw->pw_shell);
	return copy;
@


1.1.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.5 2001/04/12 20:09:37 stevesk Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.5 2001/04/12 20:09:37 stevesk Exp $");
a114 15
}

int a2port(const char *s)
{
	long port;
	char *endp;

	errno = 0;
	port = strtol(s, &endp, 0);
	if (s == endp || *endp != '\0' ||
	    (errno == ERANGE && (port == LONG_MIN || port == LONG_MAX)) ||
	    port <= 0 || port > 65535)
		return 0;

	return port;
@


1.1.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.12 2001/06/26 17:27:24 markus Exp $	*/
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.12 2001/06/26 17:27:24 markus Exp $");
a33 1
/* remove newline at end of string */
a48 1
/* set/unset filedescriptor to non-blocking */
a52 1

d59 1
a59 1
		debug2("fd %d is O_NONBLOCK", fd);
a69 22
void
unset_nonblock(int fd)
{
	int val;

	val = fcntl(fd, F_GETFL, 0);
	if (val < 0) {
		error("fcntl(%d, F_GETFL, 0): %s", fd, strerror(errno));
		return;
	}
	if (!(val & O_NONBLOCK)) {
		debug2("fd %d is not O_NONBLOCK", fd);
		return;
	}
	debug("fd %d clearing O_NONBLOCK", fd);
	val &= ~O_NONBLOCK;
	if (fcntl(fd, F_SETFL, val) == -1)
		if (errno != ENODEV)
			error("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
			    fd, strerror(errno));
}

a72 1
/* return next token in configuration line */
a110 2
	copy->pw_expire = pw->pw_expire;
	copy->pw_change = pw->pw_change;
d117 1
a117 7
/*
 * Convert ASCII string to TCP/IP port number.
 * Port must be >0 and <=65535.
 * Return 0 if invalid.
 */
int
a2port(const char *s)
a129 137
}

#define SECONDS		1
#define MINUTES		(SECONDS * 60)
#define HOURS		(MINUTES * 60)
#define DAYS		(HOURS * 24)
#define WEEKS		(DAYS * 7)

/*
 * Convert a time string into seconds; format is
 * a sequence of:
 *      time[qualifier]
 *
 * Valid time qualifiers are:
 *      <none>  seconds
 *      s|S     seconds
 *      m|M     minutes
 *      h|H     hours
 *      d|D     days
 *      w|W     weeks
 *
 * Examples:
 *      90m     90 minutes
 *      1h30m   90 minutes
 *      2d      2 days
 *      1w      1 week
 *
 * Return -1 if time string is invalid.
 */
long
convtime(const char *s)
{
	long total, secs;
	const char *p;
	char *endp;

	errno = 0;
	total = 0;
	p = s;

	if (p == NULL || *p == '\0')
		return -1;

	while (*p) {
		secs = strtol(p, &endp, 10);
		if (p == endp ||
		    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||
		    secs < 0)
			return -1;

		switch (*endp++) {
		case '\0':
			endp--;
		case 's':
		case 'S':
			break;
		case 'm':
		case 'M':
			secs *= MINUTES;
			break;
		case 'h':
		case 'H':
			secs *= HOURS;
			break;
		case 'd':
		case 'D':
			secs *= DAYS;
			break;
		case 'w':
		case 'W':
			secs *= WEEKS;
			break;
		default:
			return -1;
		}
		total += secs;
		if (total < 0)
			return -1;
		p = endp;
	}

	return total;
}

char *
cleanhostname(char *host)
{
	if (*host == '[' && host[strlen(host) - 1] == ']') {
		host[strlen(host) - 1] = '\0';
		return (host + 1);
	} else
		return host;
}

char *
colon(char *cp)
{
	int flag = 0;

	if (*cp == ':')		/* Leading colon is part of file name. */
		return (0);
	if (*cp == '[')
		flag = 1;

	for (; *cp; ++cp) {
		if (*cp == '@@' && *(cp+1) == '[')
			flag = 1;
		if (*cp == ']' && *(cp+1) == ':' && flag)
			return (cp+1);
		if (*cp == ':' && !flag)
			return (cp);
		if (*cp == '/')
			return (0);
	}
	return (0);
}

/* function to assist building execv() arguments */
void
addargs(arglist *args, char *fmt, ...)
{
	va_list ap;
	char buf[1024];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);

	if (args->list == NULL) {
		args->nalloc = 32;
		args->num = 0;
	} else if (args->num+2 >= args->nalloc) 
		args->nalloc *= 2;

	args->list = xrealloc(args->list, args->nalloc * sizeof(char *));
	args->list[args->num++] = xstrdup(buf);
	args->list[args->num] = NULL;
@


1.1.2.6
log
@Merge OpenSSH 3.1.
@
text
@d1 2
d28 1
a28 1
RCSID("$OpenBSD: misc.c,v 1.19 2002/03/04 17:27:39 stevesk Exp $");
d40 1
a40 1
		if (*t == '\n' || *t == '\r') {
d68 3
a70 2
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
		    fd, strerror(errno));
d90 3
a92 24
		debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s",
		    fd, strerror(errno));
}

/* disable nagle on socket */
void
set_nodelay(int fd)
{
	int opt;
	socklen_t optlen;

	optlen = sizeof opt;
	if (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {
		error("getsockopt TCP_NODELAY: %.100s", strerror(errno));
		return;
	}
	if (opt == 1) {
		debug2("fd %d is TCP_NODELAY", fd);
		return;
	}
	opt = 1;
	debug("fd %d setting TCP_NODELAY", fd);
	if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)
		error("setsockopt TCP_NODELAY: %.100s", strerror(errno));
d295 1
a295 1
	} else if (args->num+2 >= args->nalloc)
@


