head	1.372;
access;
symbols
	OPENBSD_6_2:1.372.0.2
	OPENBSD_6_2_BASE:1.372
	OPENBSD_6_1:1.361.0.4
	OPENBSD_6_1_BASE:1.361
	OPENBSD_6_0:1.347.0.4
	OPENBSD_6_0_BASE:1.347
	OPENBSD_5_9:1.345.0.2
	OPENBSD_5_9_BASE:1.345
	OPENBSD_5_8:1.336.0.4
	OPENBSD_5_8_BASE:1.336
	OPENBSD_5_7:1.329.0.2
	OPENBSD_5_7_BASE:1.329
	OPENBSD_5_6:1.328.0.4
	OPENBSD_5_6_BASE:1.328
	OPENBSD_5_5:1.327.0.4
	OPENBSD_5_5_BASE:1.327
	OPENBSD_5_4:1.324.0.2
	OPENBSD_5_4_BASE:1.324
	OPENBSD_5_3:1.321.0.2
	OPENBSD_5_3_BASE:1.321
	OPENBSD_5_2:1.316.0.2
	OPENBSD_5_2_BASE:1.316
	OPENBSD_5_1_BASE:1.311
	OPENBSD_5_1:1.311.0.2
	OPENBSD_5_0:1.308.0.2
	OPENBSD_5_0_BASE:1.308
	OPENBSD_4_9:1.307.0.2
	OPENBSD_4_9_BASE:1.307
	OPENBSD_4_8:1.297.0.2
	OPENBSD_4_8_BASE:1.297
	OPENBSD_4_7:1.288.0.2
	OPENBSD_4_7_BASE:1.288
	OPENBSD_4_6:1.264.0.4
	OPENBSD_4_6_BASE:1.264
	OPENBSD_4_5:1.235.0.2
	OPENBSD_4_5_BASE:1.235
	OPENBSD_4_4:1.232.0.2
	OPENBSD_4_4_BASE:1.232
	OPENBSD_4_3:1.230.0.2
	OPENBSD_4_3_BASE:1.230
	OPENBSD_4_2:1.227.0.2
	OPENBSD_4_2_BASE:1.227
	OPENBSD_4_1:1.219.0.2
	OPENBSD_4_1_BASE:1.219
	OPENBSD_4_0:1.211.0.2
	OPENBSD_4_0_BASE:1.211
	OPENBSD_3_9:1.200.0.2
	OPENBSD_3_9_BASE:1.200
	OPENBSD_3_8:1.169.0.2
	OPENBSD_3_8_BASE:1.169
	OPENBSD_3_7:1.153.0.2
	OPENBSD_3_7_BASE:1.153
	OPENBSD_3_6:1.142.0.2
	OPENBSD_3_6_BASE:1.142
	OPENBSD_3_5:1.101.0.2
	OPENBSD_3_5_BASE:1.101;
locks; strict;
comment	@ * @;


1.372
date	2017.09.14.18.16.28;	author phessler;	state Exp;
branches;
next	1.371;
commitid	eT5xILPiqvXeVHTq;

1.371
date	2017.08.11.16.02.53;	author claudio;	state Exp;
branches;
next	1.370;
commitid	TArqhzl9aciTsGlE;

1.370
date	2017.08.10.15.44.09;	author benno;	state Exp;
branches;
next	1.369;
commitid	JYXIsqWBdEQE1SxM;

1.369
date	2017.08.10.14.12.34;	author benno;	state Exp;
branches;
next	1.368;
commitid	c9UchCvA6vxTNTQ8;

1.368
date	2017.05.29.13.10.40;	author claudio;	state Exp;
branches;
next	1.367;
commitid	ebCUWhuoADz6XXzw;

1.367
date	2017.05.29.12.48.11;	author claudio;	state Exp;
branches;
next	1.366;
commitid	jakzq3MU7PX0O6kF;

1.366
date	2017.05.28.20.15.02;	author claudio;	state Exp;
branches;
next	1.365;
commitid	i32mFInjiFuyFeWM;

1.365
date	2017.05.28.20.10.59;	author claudio;	state Exp;
branches;
next	1.364;
commitid	dYFaZPECpMm7qqN4;

1.364
date	2017.05.28.12.21.36;	author claudio;	state Exp;
branches;
next	1.363;
commitid	FWHn2FssuHSixuVj;

1.363
date	2017.05.27.18.12.23;	author phessler;	state Exp;
branches;
next	1.362;
commitid	DuFAjaquQFZWoSIc;

1.362
date	2017.05.27.10.33.15;	author phessler;	state Exp;
branches;
next	1.361;
commitid	SM4OMu9209fRs2iQ;

1.361
date	2017.01.25.03.21.55;	author claudio;	state Exp;
branches;
next	1.360;
commitid	cao2hEetneZRFuIU;

1.360
date	2017.01.25.00.15.38;	author claudio;	state Exp;
branches;
next	1.359;
commitid	njwYsyFBZe4riTmC;

1.359
date	2017.01.24.23.38.12;	author claudio;	state Exp;
branches;
next	1.358;
commitid	o0u4P0zRnQoELo6o;

1.358
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.357;
commitid	airB1W2Kb948lFil;

1.357
date	2017.01.23.22.53.52;	author claudio;	state Exp;
branches;
next	1.356;
commitid	GENNLgd0FzEuXHQN;

1.356
date	2017.01.23.22.47.59;	author claudio;	state Exp;
branches;
next	1.355;
commitid	pnGdVXq8GJLI0bC2;

1.355
date	2017.01.23.12.25.19;	author claudio;	state Exp;
branches;
next	1.354;
commitid	v3CPPZ2rgYxYsA45;

1.354
date	2017.01.23.11.43.40;	author claudio;	state Exp;
branches;
next	1.353;
commitid	zHIgxV97QgdmH5L2;

1.353
date	2016.11.10.09.18.33;	author phessler;	state Exp;
branches;
next	1.352;
commitid	E1P0R5QtujrHNt7s;

1.352
date	2016.10.18.19.47.52;	author benno;	state Exp;
branches;
next	1.351;
commitid	5x9UhbnnXpAv8nhe;

1.351
date	2016.10.14.16.05.36;	author phessler;	state Exp;
branches;
next	1.350;
commitid	Ai7XVOgXw9ZLovz1;

1.350
date	2016.09.03.16.22.17;	author renato;	state Exp;
branches;
next	1.349;
commitid	FeUy6OVH7V8nX42o;

1.349
date	2016.09.02.14.00.29;	author benno;	state Exp;
branches;
next	1.348;
commitid	cUiKeXOsNjNjPeSK;

1.348
date	2016.08.08.21.44.00;	author renato;	state Exp;
branches;
next	1.347;
commitid	Nu19hjaf9yj2aAQY;

1.347
date	2016.07.21.10.13.58;	author claudio;	state Exp;
branches;
next	1.346;
commitid	JBhXdMVuhYdAttq1;

1.346
date	2016.06.03.17.36.37;	author benno;	state Exp;
branches;
next	1.345;
commitid	utIafqBHH3dRVCSC;

1.345
date	2015.12.22.21.36.57;	author mmcc;	state Exp;
branches;
next	1.344;
commitid	ea5GZDc4EQ86MZA8;

1.344
date	2015.12.03.09.26.59;	author benno;	state Exp;
branches;
next	1.343;
commitid	69xlHNTJQiFVCH5T;

1.343
date	2015.11.06.16.23.26;	author phessler;	state Exp;
branches;
next	1.342;
commitid	gwEx9C0BtWsMUbsG;

1.342
date	2015.10.25.18.45.04;	author claudio;	state Exp;
branches;
next	1.341;
commitid	EHIvURCGYDeOHHUc;

1.341
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.340;
commitid	sbrB3Q5CNxcwZpfU;

1.340
date	2015.10.07.20.26.16;	author deraadt;	state Exp;
branches;
next	1.339;
commitid	zoCFTdwZRvyOP9pY;

1.339
date	2015.09.21.09.47.15;	author phessler;	state Exp;
branches;
next	1.338;
commitid	0iY3tr4GQ1eTlhDV;

1.338
date	2015.09.19.16.24.08;	author claudio;	state Exp;
branches;
next	1.337;
commitid	sEc1y6lthMj4p1tq;

1.337
date	2015.08.30.23.20.43;	author deraadt;	state Exp;
branches;
next	1.336;
commitid	I8OZ98xpe7zz0YGw;

1.336
date	2015.08.04.14.46.38;	author phessler;	state Exp;
branches;
next	1.335;
commitid	wJyyJZr2xy2xDvm7;

1.335
date	2015.07.20.16.10.38;	author claudio;	state Exp;
branches;
next	1.334;
commitid	JXdI3dG8XAYCUdaO;

1.334
date	2015.07.18.22.52.39;	author benno;	state Exp;
branches;
next	1.333;
commitid	nZLC4rTYzidfI7tQ;

1.333
date	2015.07.16.17.26.57;	author blambert;	state Exp;
branches;
next	1.332;
commitid	Jzg6Nk7vlsZsRUYp;

1.332
date	2015.06.21.12.16.29;	author claudio;	state Exp;
branches;
next	1.331;
commitid	aM7whefEVTxWj9sv;

1.331
date	2015.06.19.14.54.12;	author phessler;	state Exp;
branches;
next	1.330;
commitid	KfEXxzS3c4m01GKl;

1.330
date	2015.03.14.03.52.42;	author claudio;	state Exp;
branches;
next	1.329;
commitid	1OLz8RQEaC2xclFf;

1.329
date	2014.10.08.16.15.37;	author deraadt;	state Exp;
branches;
next	1.328;
commitid	8hXaK4f2GeAALziF;

1.328
date	2014.04.13.10.36.41;	author blambert;	state Exp;
branches;
next	1.327;

1.327
date	2014.01.22.04.08.08;	author claudio;	state Exp;
branches;
next	1.326;

1.326
date	2013.11.13.20.41.01;	author benno;	state Exp;
branches;
next	1.325;

1.325
date	2013.08.14.20.34.26;	author claudio;	state Exp;
branches;
next	1.324;

1.324
date	2013.07.17.14.09.13;	author benno;	state Exp;
branches;
next	1.323;

1.323
date	2013.07.10.15.56.06;	author claudio;	state Exp;
branches;
next	1.322;

1.322
date	2013.05.31.23.10.12;	author claudio;	state Exp;
branches;
next	1.321;

1.321
date	2012.09.18.10.10.00;	author claudio;	state Exp;
branches;
next	1.320;

1.320
date	2012.09.18.09.45.51;	author claudio;	state Exp;
branches;
next	1.319;

1.319
date	2012.09.17.18.03.28;	author miod;	state Exp;
branches;
next	1.318;

1.318
date	2012.09.12.05.56.22;	author claudio;	state Exp;
branches;
next	1.317;

1.317
date	2012.08.12.14.24.56;	author claudio;	state Exp;
branches;
next	1.316;

1.316
date	2012.05.27.18.52.07;	author claudio;	state Exp;
branches
	1.316.2.1;
next	1.315;

1.315
date	2012.05.22.20.38.17;	author claudio;	state Exp;
branches;
next	1.314;

1.314
date	2012.04.12.17.31.05;	author claudio;	state Exp;
branches;
next	1.313;

1.313
date	2012.04.07.17.25.51;	author claudio;	state Exp;
branches;
next	1.312;

1.312
date	2012.03.27.18.22.07;	author claudio;	state Exp;
branches;
next	1.311;

1.311
date	2011.09.20.21.19.06;	author claudio;	state Exp;
branches;
next	1.310;

1.310
date	2011.09.19.11.18.11;	author claudio;	state Exp;
branches;
next	1.309;

1.309
date	2011.09.17.16.29.44;	author claudio;	state Exp;
branches;
next	1.308;

1.308
date	2011.07.09.02.51.18;	author henning;	state Exp;
branches;
next	1.307;

1.307
date	2011.02.15.12.26.37;	author claudio;	state Exp;
branches;
next	1.306;

1.306
date	2011.01.29.17.10.45;	author henning;	state Exp;
branches;
next	1.305;

1.305
date	2011.01.27.17.19.09;	author sthen;	state Exp;
branches;
next	1.304;

1.304
date	2010.12.23.17.41.40;	author claudio;	state Exp;
branches;
next	1.303;

1.303
date	2010.11.30.15.33.06;	author claudio;	state Exp;
branches;
next	1.302;

1.302
date	2010.11.24.00.58.10;	author sthen;	state Exp;
branches;
next	1.301;

1.301
date	2010.11.18.12.18.31;	author claudio;	state Exp;
branches;
next	1.300;

1.300
date	2010.11.10.15.14.36;	author claudio;	state Exp;
branches;
next	1.299;

1.299
date	2010.10.15.07.43.02;	author claudio;	state Exp;
branches;
next	1.298;

1.298
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.297;

1.297
date	2010.07.14.09.00.08;	author claudio;	state Exp;
branches
	1.297.2.1;
next	1.296;

1.296
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.295;

1.295
date	2010.05.19.12.44.14;	author claudio;	state Exp;
branches;
next	1.294;

1.294
date	2010.05.17.15.49.29;	author claudio;	state Exp;
branches;
next	1.293;

1.293
date	2010.05.04.10.25.31;	author claudio;	state Exp;
branches;
next	1.292;

1.292
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.291;

1.291
date	2010.04.13.09.09.48;	author claudio;	state Exp;
branches;
next	1.290;

1.290
date	2010.03.30.15.43.30;	author claudio;	state Exp;
branches;
next	1.289;

1.289
date	2010.03.29.09.06.56;	author claudio;	state Exp;
branches;
next	1.288;

1.288
date	2010.03.03.13.52.39;	author claudio;	state Exp;
branches;
next	1.287;

1.287
date	2010.02.09.13.29.15;	author claudio;	state Exp;
branches;
next	1.286;

1.286
date	2010.02.08.17.21.37;	author claudio;	state Exp;
branches;
next	1.285;

1.285
date	2010.02.08.17.16.36;	author claudio;	state Exp;
branches;
next	1.284;

1.284
date	2010.01.13.06.02.37;	author claudio;	state Exp;
branches;
next	1.283;

1.283
date	2010.01.11.01.34.35;	author claudio;	state Exp;
branches;
next	1.282;

1.282
date	2010.01.10.08.32.08;	author claudio;	state Exp;
branches;
next	1.281;

1.281
date	2010.01.10.00.15.09;	author claudio;	state Exp;
branches;
next	1.280;

1.280
date	2010.01.05.08.49.57;	author claudio;	state Exp;
branches;
next	1.279;

1.279
date	2009.12.31.15.34.02;	author claudio;	state Exp;
branches;
next	1.278;

1.278
date	2009.12.18.15.51.37;	author claudio;	state Exp;
branches;
next	1.277;

1.277
date	2009.12.16.15.40.55;	author claudio;	state Exp;
branches;
next	1.276;

1.276
date	2009.12.08.14.03.40;	author claudio;	state Exp;
branches;
next	1.275;

1.275
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.274;

1.274
date	2009.11.11.13.48.34;	author claudio;	state Exp;
branches;
next	1.273;

1.273
date	2009.11.02.20.38.15;	author claudio;	state Exp;
branches;
next	1.272;

1.272
date	2009.10.28.15.54.13;	author claudio;	state Exp;
branches;
next	1.271;

1.271
date	2009.10.26.09.27.58;	author claudio;	state Exp;
branches;
next	1.270;

1.270
date	2009.10.12.15.19.30;	author claudio;	state Exp;
branches;
next	1.269;

1.269
date	2009.10.12.13.14.47;	author claudio;	state Exp;
branches;
next	1.268;

1.268
date	2009.10.08.09.27.56;	author sthen;	state Exp;
branches;
next	1.267;

1.267
date	2009.10.05.12.03.45;	author claudio;	state Exp;
branches;
next	1.266;

1.266
date	2009.10.05.11.35.48;	author claudio;	state Exp;
branches;
next	1.265;

1.265
date	2009.08.06.08.53.11;	author claudio;	state Exp;
branches;
next	1.264;

1.264
date	2009.06.29.12.22.16;	author claudio;	state Exp;
branches;
next	1.263;

1.263
date	2009.06.22.11.14.14;	author sthen;	state Exp;
branches;
next	1.262;

1.262
date	2009.06.07.05.56.24;	author eric;	state Exp;
branches;
next	1.261;

1.261
date	2009.06.07.00.30.23;	author claudio;	state Exp;
branches;
next	1.260;

1.260
date	2009.06.06.21.21.37;	author claudio;	state Exp;
branches;
next	1.259;

1.259
date	2009.06.06.06.33.15;	author eric;	state Exp;
branches;
next	1.258;

1.258
date	2009.06.06.06.04.10;	author claudio;	state Exp;
branches;
next	1.257;

1.257
date	2009.06.06.01.10.29;	author claudio;	state Exp;
branches;
next	1.256;

1.256
date	2009.06.06.01.02.51;	author claudio;	state Exp;
branches;
next	1.255;

1.255
date	2009.06.06.01.00.56;	author claudio;	state Exp;
branches;
next	1.254;

1.254
date	2009.06.05.19.52.32;	author claudio;	state Exp;
branches;
next	1.253;

1.253
date	2009.06.05.17.36.49;	author claudio;	state Exp;
branches;
next	1.252;

1.252
date	2009.06.04.22.08.19;	author claudio;	state Exp;
branches;
next	1.251;

1.251
date	2009.06.04.05.29.06;	author claudio;	state Exp;
branches;
next	1.250;

1.250
date	2009.06.04.04.46.42;	author claudio;	state Exp;
branches;
next	1.249;

1.249
date	2009.06.02.01.02.28;	author claudio;	state Exp;
branches;
next	1.248;

1.248
date	2009.06.02.00.09.02;	author claudio;	state Exp;
branches;
next	1.247;

1.247
date	2009.06.01.23.54.49;	author claudio;	state Exp;
branches;
next	1.246;

1.246
date	2009.05.27.06.58.15;	author claudio;	state Exp;
branches;
next	1.245;

1.245
date	2009.05.17.14.45.25;	author claudio;	state Exp;
branches;
next	1.244;

1.244
date	2009.05.17.13.22.10;	author claudio;	state Exp;
branches;
next	1.243;

1.243
date	2009.05.17.12.25.15;	author claudio;	state Exp;
branches;
next	1.242;

1.242
date	2009.05.11.19.16.21;	author claudio;	state Exp;
branches;
next	1.241;

1.241
date	2009.04.23.19.23.27;	author claudio;	state Exp;
branches;
next	1.240;

1.240
date	2009.03.18.19.45.09;	author claudio;	state Exp;
branches;
next	1.239;

1.239
date	2009.03.13.16.05.40;	author claudio;	state Exp;
branches;
next	1.238;

1.238
date	2009.03.13.06.25.04;	author claudio;	state Exp;
branches;
next	1.237;

1.237
date	2009.03.13.05.43.51;	author claudio;	state Exp;
branches;
next	1.236;

1.236
date	2009.03.13.04.19.43;	author claudio;	state Exp;
branches;
next	1.235;

1.235
date	2009.01.13.21.35.16;	author sthen;	state Exp;
branches;
next	1.234;

1.234
date	2008.12.28.15.19.21;	author claudio;	state Exp;
branches;
next	1.233;

1.233
date	2008.12.12.16.02.49;	author claudio;	state Exp;
branches;
next	1.232;

1.232
date	2008.06.15.10.03.46;	author claudio;	state Exp;
branches
	1.232.2.1;
next	1.231;

1.231
date	2008.05.02.13.49.34;	author claudio;	state Exp;
branches;
next	1.230;

1.230
date	2008.02.26.19.58.51;	author claudio;	state Exp;
branches
	1.230.2.1;
next	1.229;

1.229
date	2007.11.27.01.13.54;	author claudio;	state Exp;
branches;
next	1.228;

1.228
date	2007.09.16.15.20.50;	author claudio;	state Exp;
branches;
next	1.227;

1.227
date	2007.06.19.09.44.55;	author pyr;	state Exp;
branches;
next	1.226;

1.226
date	2007.05.11.11.27.59;	author claudio;	state Exp;
branches;
next	1.225;

1.225
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.224;

1.224
date	2007.04.06.18.03.50;	author claudio;	state Exp;
branches;
next	1.223;

1.223
date	2007.03.28.12.33.32;	author henning;	state Exp;
branches;
next	1.222;

1.222
date	2007.03.16.14.06.57;	author claudio;	state Exp;
branches;
next	1.221;

1.221
date	2007.03.16.13.52.30;	author claudio;	state Exp;
branches;
next	1.220;

1.220
date	2007.03.12.15.49.54;	author claudio;	state Exp;
branches;
next	1.219;

1.219
date	2007.02.22.08.34.18;	author henning;	state Exp;
branches
	1.219.2.1;
next	1.218;

1.218
date	2007.01.26.17.40.49;	author claudio;	state Exp;
branches;
next	1.217;

1.217
date	2007.01.24.13.24.51;	author claudio;	state Exp;
branches;
next	1.216;

1.216
date	2007.01.04.12.43.36;	author claudio;	state Exp;
branches;
next	1.215;

1.215
date	2006.12.12.10.19.44;	author claudio;	state Exp;
branches;
next	1.214;

1.214
date	2006.12.08.22.31.16;	author itojun;	state Exp;
branches;
next	1.213;

1.213
date	2006.11.10.14.47.32;	author henning;	state Exp;
branches;
next	1.212;

1.212
date	2006.09.19.13.02.24;	author henning;	state Exp;
branches;
next	1.211;

1.211
date	2006.08.23.08.13.04;	author claudio;	state Exp;
branches;
next	1.210;

1.210
date	2006.08.22.15.02.07;	author henning;	state Exp;
branches;
next	1.209;

1.209
date	2006.08.14.17.11.18;	author henning;	state Exp;
branches;
next	1.208;

1.208
date	2006.06.15.10.04.40;	author claudio;	state Exp;
branches;
next	1.207;

1.207
date	2006.06.14.17.08.56;	author claudio;	state Exp;
branches;
next	1.206;

1.206
date	2006.05.28.22.07.54;	author claudio;	state Exp;
branches;
next	1.205;

1.205
date	2006.04.21.08.55.21;	author claudio;	state Exp;
branches;
next	1.204;

1.204
date	2006.04.12.14.05.46;	author claudio;	state Exp;
branches;
next	1.203;

1.203
date	2006.04.05.13.24.28;	author claudio;	state Exp;
branches;
next	1.202;

1.202
date	2006.03.22.10.18.49;	author claudio;	state Exp;
branches;
next	1.201;

1.201
date	2006.03.13.16.49.35;	author claudio;	state Exp;
branches;
next	1.200;

1.200
date	2006.02.10.14.34.40;	author claudio;	state Exp;
branches;
next	1.199;

1.199
date	2006.02.02.14.06.05;	author claudio;	state Exp;
branches;
next	1.198;

1.198
date	2006.01.24.14.48.47;	author claudio;	state Exp;
branches;
next	1.197;

1.197
date	2006.01.24.14.14.04;	author claudio;	state Exp;
branches;
next	1.196;

1.196
date	2006.01.24.13.34.33;	author claudio;	state Exp;
branches;
next	1.195;

1.195
date	2006.01.20.16.40.17;	author claudio;	state Exp;
branches;
next	1.194;

1.194
date	2006.01.20.14.56.12;	author claudio;	state Exp;
branches;
next	1.193;

1.193
date	2006.01.14.22.39.49;	author claudio;	state Exp;
branches;
next	1.192;

1.192
date	2006.01.13.13.04.33;	author claudio;	state Exp;
branches;
next	1.191;

1.191
date	2006.01.12.14.05.13;	author claudio;	state Exp;
branches;
next	1.190;

1.190
date	2006.01.05.16.00.07;	author claudio;	state Exp;
branches;
next	1.189;

1.189
date	2006.01.04.12.53.31;	author claudio;	state Exp;
branches;
next	1.188;

1.188
date	2006.01.03.22.49.17;	author claudio;	state Exp;
branches;
next	1.187;

1.187
date	2006.01.03.15.48.39;	author claudio;	state Exp;
branches;
next	1.186;

1.186
date	2006.01.03.13.09.18;	author claudio;	state Exp;
branches;
next	1.185;

1.185
date	2005.12.30.11.22.23;	author claudio;	state Exp;
branches;
next	1.184;

1.184
date	2005.12.24.13.52.56;	author claudio;	state Exp;
branches;
next	1.183;

1.183
date	2005.12.09.16.17.28;	author claudio;	state Exp;
branches;
next	1.182;

1.182
date	2005.12.08.16.02.56;	author claudio;	state Exp;
branches;
next	1.181;

1.181
date	2005.11.30.13.45.19;	author claudio;	state Exp;
branches;
next	1.180;

1.180
date	2005.11.29.21.11.07;	author claudio;	state Exp;
branches;
next	1.179;

1.179
date	2005.11.29.20.45.21;	author claudio;	state Exp;
branches;
next	1.178;

1.178
date	2005.11.02.13.21.06;	author claudio;	state Exp;
branches;
next	1.177;

1.177
date	2005.11.01.15.21.54;	author claudio;	state Exp;
branches;
next	1.176;

1.176
date	2005.11.01.14.37.16;	author claudio;	state Exp;
branches;
next	1.175;

1.175
date	2005.11.01.10.58.29;	author claudio;	state Exp;
branches;
next	1.174;

1.174
date	2005.10.13.09.08.21;	author claudio;	state Exp;
branches;
next	1.173;

1.173
date	2005.09.21.13.35.03;	author claudio;	state Exp;
branches;
next	1.172;

1.172
date	2005.09.20.14.40.32;	author henning;	state Exp;
branches;
next	1.171;

1.171
date	2005.09.20.13.31.53;	author henning;	state Exp;
branches;
next	1.170;

1.170
date	2005.09.19.15.58.43;	author henning;	state Exp;
branches;
next	1.169;

1.169
date	2005.08.10.08.34.06;	author claudio;	state Exp;
branches;
next	1.168;

1.168
date	2005.07.29.22.26.30;	author claudio;	state Exp;
branches;
next	1.167;

1.167
date	2005.07.29.12.38.40;	author claudio;	state Exp;
branches;
next	1.166;

1.166
date	2005.07.01.13.38.14;	author claudio;	state Exp;
branches;
next	1.165;

1.165
date	2005.07.01.12.10.20;	author claudio;	state Exp;
branches;
next	1.164;

1.164
date	2005.07.01.09.19.24;	author claudio;	state Exp;
branches;
next	1.163;

1.163
date	2005.06.29.09.43.25;	author claudio;	state Exp;
branches;
next	1.162;

1.162
date	2005.06.13.21.16.18;	author henning;	state Exp;
branches;
next	1.161;

1.161
date	2005.06.10.08.28.50;	author claudio;	state Exp;
branches;
next	1.160;

1.160
date	2005.05.23.22.45.02;	author henning;	state Exp;
branches;
next	1.159;

1.159
date	2005.05.03.07.01.23;	author djm;	state Exp;
branches;
next	1.158;

1.158
date	2005.04.28.13.54.45;	author claudio;	state Exp;
branches;
next	1.157;

1.157
date	2005.04.16.19.10.59;	author cloder;	state Exp;
branches;
next	1.156;

1.156
date	2005.03.28.15.16.46;	author henning;	state Exp;
branches;
next	1.155;

1.155
date	2005.03.28.15.03.33;	author henning;	state Exp;
branches;
next	1.154;

1.154
date	2005.03.24.10.28.39;	author henning;	state Exp;
branches;
next	1.153;

1.153
date	2004.11.23.13.07.01;	author claudio;	state Exp;
branches;
next	1.152;

1.152
date	2004.11.19.14.43.57;	author claudio;	state Exp;
branches;
next	1.151;

1.151
date	2004.11.11.16.59.47;	author claudio;	state Exp;
branches;
next	1.150;

1.150
date	2004.11.11.16.50.33;	author claudio;	state Exp;
branches;
next	1.149;

1.149
date	2004.11.11.13.29.37;	author henning;	state Exp;
branches;
next	1.148;

1.148
date	2004.11.11.13.14.45;	author claudio;	state Exp;
branches;
next	1.147;

1.147
date	2004.11.11.13.06.45;	author claudio;	state Exp;
branches;
next	1.146;

1.146
date	2004.11.11.10.35.15;	author claudio;	state Exp;
branches;
next	1.145;

1.145
date	2004.09.28.12.09.31;	author claudio;	state Exp;
branches;
next	1.144;

1.144
date	2004.09.16.17.36.29;	author henning;	state Exp;
branches;
next	1.143;

1.143
date	2004.09.16.00.25.12;	author henning;	state Exp;
branches;
next	1.142;

1.142
date	2004.08.12.10.24.16;	author claudio;	state Exp;
branches;
next	1.141;

1.141
date	2004.08.10.14.06.53;	author claudio;	state Exp;
branches;
next	1.140;

1.140
date	2004.08.10.13.02.08;	author claudio;	state Exp;
branches;
next	1.139;

1.139
date	2004.08.06.12.04.08;	author claudio;	state Exp;
branches;
next	1.138;

1.138
date	2004.08.06.11.51.19;	author claudio;	state Exp;
branches;
next	1.137;

1.137
date	2004.08.05.21.01.38;	author claudio;	state Exp;
branches;
next	1.136;

1.136
date	2004.08.05.20.56.11;	author claudio;	state Exp;
branches;
next	1.135;

1.135
date	2004.08.05.18.44.19;	author claudio;	state Exp;
branches;
next	1.134;

1.134
date	2004.08.05.16.26.56;	author claudio;	state Exp;
branches;
next	1.133;

1.133
date	2004.08.05.15.58.21;	author claudio;	state Exp;
branches;
next	1.132;

1.132
date	2004.08.05.15.19.50;	author henning;	state Exp;
branches;
next	1.131;

1.131
date	2004.08.04.12.41.48;	author henning;	state Exp;
branches;
next	1.130;

1.130
date	2004.07.30.14.44.30;	author claudio;	state Exp;
branches;
next	1.129;

1.129
date	2004.07.29.17.05.13;	author claudio;	state Exp;
branches;
next	1.128;

1.128
date	2004.07.28.16.02.14;	author claudio;	state Exp;
branches;
next	1.127;

1.127
date	2004.07.13.17.57.20;	author jaredy;	state Exp;
branches;
next	1.126;

1.126
date	2004.07.05.16.54.53;	author henning;	state Exp;
branches;
next	1.125;

1.125
date	2004.07.05.02.13.44;	author henning;	state Exp;
branches;
next	1.124;

1.124
date	2004.07.04.03.51.31;	author henning;	state Exp;
branches;
next	1.123;

1.123
date	2004.07.04.03.37.03;	author henning;	state Exp;
branches;
next	1.122;

1.122
date	2004.07.03.17.19.59;	author claudio;	state Exp;
branches;
next	1.121;

1.121
date	2004.06.24.23.15.58;	author claudio;	state Exp;
branches;
next	1.120;

1.120
date	2004.06.23.07.10.05;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2004.06.22.23.17.01;	author claudio;	state Exp;
branches;
next	1.118;

1.118
date	2004.06.22.20.28.58;	author claudio;	state Exp;
branches;
next	1.117;

1.117
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.116;

1.116
date	2004.06.06.17.38.10;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2004.05.21.15.36.40;	author claudio;	state Exp;
branches;
next	1.114;

1.114
date	2004.05.21.12.10.22;	author claudio;	state Exp;
branches;
next	1.113;

1.113
date	2004.05.21.11.48.56;	author claudio;	state Exp;
branches;
next	1.112;

1.112
date	2004.05.08.19.17.20;	author henning;	state Exp;
branches;
next	1.111;

1.111
date	2004.05.07.10.06.15;	author djm;	state Exp;
branches;
next	1.110;

1.110
date	2004.04.30.05.47.50;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2004.04.29.19.56.04;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2004.04.28.04.36.16;	author claudio;	state Exp;
branches;
next	1.107;

1.107
date	2004.04.28.03.34.38;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2004.04.28.02.57.27;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2004.04.27.04.38.12;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2004.04.25.17.34.39;	author claudio;	state Exp;
branches;
next	1.103;

1.103
date	2004.04.25.07.16.24;	author henning;	state Exp;
branches;
next	1.102;

1.102
date	2004.04.25.02.57.55;	author henning;	state Exp;
branches;
next	1.101;

1.101
date	2004.03.20.23.17.35;	author david;	state Exp;
branches;
next	1.100;

1.100
date	2004.03.15.11.48.04;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2004.03.12.20.48.09;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2004.03.12.19.33.30;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2004.03.11.17.34.01;	author henning;	state Exp;
branches;
next	1.96;

1.96
date	2004.03.11.14.22.23;	author claudio;	state Exp;
branches;
next	1.95;

1.95
date	2004.03.10.14.29.37;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2004.03.05.22.21.32;	author claudio;	state Exp;
branches;
next	1.93;

1.93
date	2004.03.02.19.29.01;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2004.03.01.16.02.01;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2004.02.27.20.53.56;	author claudio;	state Exp;
branches;
next	1.90;

1.90
date	2004.02.27.14.46.09;	author claudio;	state Exp;
branches;
next	1.89;

1.89
date	2004.02.26.16.16.41;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2004.02.26.14.00.33;	author claudio;	state Exp;
branches;
next	1.87;

1.87
date	2004.02.26.09.53.58;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2004.02.25.19.48.18;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2004.02.24.15.43.03;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2004.02.23.17.19.26;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2004.02.19.23.07.00;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2004.02.19.13.54.58;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2004.02.18.23.18.16;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2004.02.18.16.36.09;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2004.02.17.19.12.58;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2004.02.16.14.26.29;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2004.02.16.12.53.15;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2004.02.09.01.56.18;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.09.01.46.34;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2004.02.07.11.42.30;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2004.02.02.19.14.11;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2004.02.02.18.56.25;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2004.02.02.16.44.05;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.28.19.24.06;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.27.21.56.21;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.27.16.49.53;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.22.21.09.00;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.22.21.01.26;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.22.20.34.56;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.17.19.35.36;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.13.13.45.49;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.13.13.34.56;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.13.13.18.03;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.11.22.08.04;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.11.22.06.57;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.11.21.57.58;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.11.21.56.07;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.11.21.47.20;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.11.21.32.56;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.11.20.13.00;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.11.02.39.05;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.10.22.25.42;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2004.01.10.16.20.29;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.07.12.38.36;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.07.01.58.56;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.07.00.01.16;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2004.01.05.22.57.58;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.04.20.47.34;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.04.17.19.41;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.03.20.37.34;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.03.20.22.07;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.03.14.06.35;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.01.23.09.09;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.27.00.53.51;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.27.00.18.11;	author jakob;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.26.23.50.35;	author jakob;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.26.22.41.01;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.26.21.33.14;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.26.20.52.14;	author jakob;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.26.18.33.11;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.26.18.07.33;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.25.23.41.23;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.25.23.22.13;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.25.02.24.26;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.24.23.48.06;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.24.20.09.57;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.24.19.59.24;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.24.13.49.21;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.24.13.28.02;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.23.19.14.49;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.23.19.13.27;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.23.18.52.46;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.23.18.28.05;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.23.15.59.02;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.21.23.28.39;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.21.23.26.38;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.20.21.43.45;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.20.21.19.40;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.20.20.53.30;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.20.18.32.22;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.20.15.09.07;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.20.14.36.46;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.19.19.24.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.19.16.46.46;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.19.11.19.02;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.19.01.15.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.19.01.13.34;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.18.22.22.22;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.17.19.26.26;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.17.18.11.31;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;

1.219.2.1
date	2007.04.30.20.43.07;	author ckuethe;	state Exp;
branches;
next	;

1.230.2.1
date	2009.01.30.22.39.47;	author claudio;	state Exp;
branches;
next	;

1.232.2.1
date	2009.01.30.22.37.34;	author claudio;	state Exp;
branches;
next	;

1.297.2.1
date	2010.11.15.14.15.47;	author stephan;	state Exp;
branches;
next	;

1.316.2.1
date	2012.11.29.20.06.16;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.372
log
@fix accounting for received prefixes per neighbor

noticed by deraadt@@ and job@@

OK benno@@ deraadt@@ job@@
@
text
@/*	$OpenBSD: rde.c,v 1.371 2017/08/11 16:02:53 claudio Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2016 Job Snijders <job@@instituut.net>
 * Copyright (c) 2016 Peter Hessler <phessler@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <errno.h>
#include <ifaddrs.h>
#include <pwd.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <err.h>

#include "bgpd.h"
#include "mrt.h"
#include "rde.h"
#include "session.h"
#include "log.h"

#define PFD_PIPE_MAIN		0
#define PFD_PIPE_SESSION	1
#define PFD_PIPE_SESSION_CTL	2
#define PFD_PIPE_COUNT		3

void		 rde_sighdlr(int);
void		 rde_dispatch_imsg_session(struct imsgbuf *);
void		 rde_dispatch_imsg_parent(struct imsgbuf *);
int		 rde_update_dispatch(struct imsg *);
void		 rde_update_update(struct rde_peer *, struct rde_aspath *,
		     struct bgpd_addr *, u_int8_t);
void		 rde_update_withdraw(struct rde_peer *, struct bgpd_addr *,
		     u_int8_t);
int		 rde_attr_parse(u_char *, u_int16_t, struct rde_peer *,
		     struct rde_aspath *, struct mpattr *);
int		 rde_attr_add(struct rde_aspath *, u_char *, u_int16_t);
u_int8_t	 rde_attr_missing(struct rde_aspath *, int, u_int16_t);
int		 rde_get_mp_nexthop(u_char *, u_int16_t, u_int8_t,
		     struct rde_aspath *);
int		 rde_update_extract_prefix(u_char *, u_int16_t, void *,
		     u_int8_t, u_int8_t);
int		 rde_update_get_prefix(u_char *, u_int16_t, struct bgpd_addr *,
		     u_int8_t *);
int		 rde_update_get_prefix6(u_char *, u_int16_t, struct bgpd_addr *,
		     u_int8_t *);
int		 rde_update_get_vpn4(u_char *, u_int16_t, struct bgpd_addr *,
		     u_int8_t *);
void		 rde_update_err(struct rde_peer *, u_int8_t , u_int8_t,
		     void *, u_int16_t);
void		 rde_update_log(const char *, u_int16_t,
		     const struct rde_peer *, const struct bgpd_addr *,
		     const struct bgpd_addr *, u_int8_t);
void		 rde_as4byte_fixup(struct rde_peer *, struct rde_aspath *);
void		 rde_reflector(struct rde_peer *, struct rde_aspath *);

void		 rde_dump_rib_as(struct prefix *, struct rde_aspath *, pid_t,
		     int);
void		 rde_dump_filter(struct prefix *,
		     struct ctl_show_rib_request *);
void		 rde_dump_filterout(struct rde_peer *, struct prefix *,
		     struct ctl_show_rib_request *);
void		 rde_dump_upcall(struct rib_entry *, void *);
void		 rde_dump_prefix_upcall(struct rib_entry *, void *);
void		 rde_dump_ctx_new(struct ctl_show_rib_request *, pid_t,
		     enum imsg_type);
void		 rde_dump_ctx_throttle(pid_t pid, int throttle);
void		 rde_dump_runner(void);
int		 rde_dump_pending(void);
void		 rde_dump_done(void *);
void		 rde_dump_mrt_new(struct mrt *, pid_t, int);
void		 rde_dump_rib_free(struct rib *);
void		 rde_dump_mrt_free(struct rib *);
void		 rde_rib_free(struct rib_desc *);

int		 rde_rdomain_import(struct rde_aspath *, struct rdomain *);
void		 rde_reload_done(void);
void		 rde_softreconfig_out(struct rib_entry *, void *);
void		 rde_softreconfig_in(struct rib_entry *, void *);
void		 rde_softreconfig_unload_peer(struct rib_entry *, void *);
void		 rde_up_dump_upcall(struct rib_entry *, void *);
void		 rde_update_queue_runner(void);
void		 rde_update6_queue_runner(u_int8_t);

void		 peer_init(u_int32_t);
void		 peer_shutdown(void);
int		 peer_localaddrs(struct rde_peer *, struct bgpd_addr *);
struct rde_peer	*peer_add(u_int32_t, struct peer_config *);
struct rde_peer	*peer_get(u_int32_t);
void		 peer_up(u_int32_t, struct session_up *);
void		 peer_down(u_int32_t);
void		 peer_flush(struct rde_peer *, u_int8_t);
void		 peer_stale(u_int32_t, u_int8_t);
void		 peer_recv_eor(struct rde_peer *, u_int8_t);
void		 peer_dump(u_int32_t, u_int8_t);
void		 peer_send_eor(struct rde_peer *, u_int8_t);

void		 network_add(struct network_config *, int);
void		 network_delete(struct network_config *, int);
void		 network_dump_upcall(struct rib_entry *, void *);

void		 rde_shutdown(void);
int		 sa_cmp(struct bgpd_addr *, struct sockaddr *);

volatile sig_atomic_t	 rde_quit = 0;
struct bgpd_config	*conf, *nconf;
time_t			 reloadtime;
struct rde_peer_head	 peerlist;
struct rde_peer		*peerself;
struct filter_head	*out_rules, *out_rules_tmp;
struct rdomain_head	*rdomains_l, *newdomains;
struct imsgbuf		*ibuf_se;
struct imsgbuf		*ibuf_se_ctl;
struct imsgbuf		*ibuf_main;
struct rde_memstats	 rdemem;

struct rde_dump_ctx {
	LIST_ENTRY(rde_dump_ctx)	entry;
	struct rib_context		ribctx;
	struct ctl_show_rib_request	req;
	sa_family_t			af;
	u_int8_t			throttled;
};

LIST_HEAD(, rde_dump_ctx) rde_dump_h = LIST_HEAD_INITIALIZER(rde_dump_h);

struct rde_mrt_ctx {
	LIST_ENTRY(rde_mrt_ctx)	entry;
	struct rib_context	ribctx;
	struct mrt		mrt;
};

LIST_HEAD(, rde_mrt_ctx) rde_mrts = LIST_HEAD_INITIALIZER(rde_mrts);
u_int rde_mrt_cnt;

void
rde_sighdlr(int sig)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		rde_quit = 1;
		break;
	}
}

u_int32_t	peerhashsize = 64;
u_int32_t	pathhashsize = 1024;
u_int32_t	attrhashsize = 512;
u_int32_t	nexthophashsize = 64;

void
rde_main(int debug, int verbose)
{
	struct passwd		*pw;
	struct pollfd		*pfd = NULL;
	struct rde_mrt_ctx	*mctx, *xmctx;
	void			*newp;
	u_int			 pfd_elms = 0, i, j;
	int			 timeout;
	u_int8_t		 aid;

	log_init(debug, LOG_DAEMON);
	log_setverbose(verbose);

	bgpd_process = PROC_RDE;
	log_procinit(log_procnames[bgpd_process]);

	if ((pw = getpwnam(BGPD_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("route decision engine");

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	if (pledge("stdio route recvfd", NULL) == -1)
		fatal("pledge");

	signal(SIGTERM, rde_sighdlr);
	signal(SIGINT, rde_sighdlr);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
	signal(SIGALRM, SIG_IGN);
	signal(SIGUSR1, SIG_IGN);

	if ((ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
		fatal(NULL);
	imsg_init(ibuf_main, 3);

	/* initialize the RIB structures */
	pt_init();
	path_init(pathhashsize);
	aspath_init(pathhashsize);
	attr_init(attrhashsize);
	nexthop_init(nexthophashsize);
	peer_init(peerhashsize);

	out_rules = calloc(1, sizeof(struct filter_head));
	if (out_rules == NULL)
		fatal(NULL);
	TAILQ_INIT(out_rules);
	rdomains_l = calloc(1, sizeof(struct rdomain_head));
	if (rdomains_l == NULL)
		fatal(NULL);
	SIMPLEQ_INIT(rdomains_l);
	if ((conf = calloc(1, sizeof(struct bgpd_config))) == NULL)
		fatal(NULL);
	log_info("route decision engine ready");

	while (rde_quit == 0) {
		if (pfd_elms < PFD_PIPE_COUNT + rde_mrt_cnt) {
			if ((newp = reallocarray(pfd,
			    PFD_PIPE_COUNT + rde_mrt_cnt,
			    sizeof(struct pollfd))) == NULL) {
				/* panic for now  */
				log_warn("could not resize pfd from %u -> %u"
				    " entries", pfd_elms, PFD_PIPE_COUNT +
				    rde_mrt_cnt);
				fatalx("exiting");
			}
			pfd = newp;
			pfd_elms = PFD_PIPE_COUNT + rde_mrt_cnt;
		}
		timeout = INFTIM;
		bzero(pfd, sizeof(struct pollfd) * pfd_elms);

		set_pollfd(&pfd[PFD_PIPE_MAIN], ibuf_main);
		set_pollfd(&pfd[PFD_PIPE_SESSION], ibuf_se);
		set_pollfd(&pfd[PFD_PIPE_SESSION_CTL], ibuf_se_ctl);

		if (rde_dump_pending() &&
		    ibuf_se_ctl && ibuf_se_ctl->w.queued == 0)
			timeout = 0;

		i = PFD_PIPE_COUNT;
		for (mctx = LIST_FIRST(&rde_mrts); mctx != 0; mctx = xmctx) {
			xmctx = LIST_NEXT(mctx, entry);
			if (mctx->mrt.wbuf.queued) {
				pfd[i].fd = mctx->mrt.wbuf.fd;
				pfd[i].events = POLLOUT;
				i++;
			} else if (mctx->mrt.state == MRT_STATE_REMOVE) {
				close(mctx->mrt.wbuf.fd);
				LIST_REMOVE(mctx, entry);
				free(mctx);
				rde_mrt_cnt--;
			}
		}

		if (poll(pfd, i, timeout) == -1) {
			if (errno != EINTR)
				fatal("poll error");
			continue;
		}

		if (handle_pollfd(&pfd[PFD_PIPE_MAIN], ibuf_main) == -1)
			fatalx("Lost connection to parent");
		else
			rde_dispatch_imsg_parent(ibuf_main);

		if (handle_pollfd(&pfd[PFD_PIPE_SESSION], ibuf_se) == -1) {
			log_warnx("RDE: Lost connection to SE");
			msgbuf_clear(&ibuf_se->w);
			free(ibuf_se);
			ibuf_se = NULL;
		} else
			rde_dispatch_imsg_session(ibuf_se);

		if (handle_pollfd(&pfd[PFD_PIPE_SESSION_CTL], ibuf_se_ctl) ==
		    -1) {
			log_warnx("RDE: Lost connection to SE control");
			msgbuf_clear(&ibuf_se_ctl->w);
			free(ibuf_se_ctl);
			ibuf_se_ctl = NULL;
		} else
			rde_dispatch_imsg_session(ibuf_se_ctl);

		for (j = PFD_PIPE_COUNT, mctx = LIST_FIRST(&rde_mrts);
		    j < i && mctx != 0; j++) {
			if (pfd[j].fd == mctx->mrt.wbuf.fd &&
			    pfd[j].revents & POLLOUT)
				mrt_write(&mctx->mrt);
			mctx = LIST_NEXT(mctx, entry);
		}

		rde_update_queue_runner();
		for (aid = AID_INET6; aid < AID_MAX; aid++)
			rde_update6_queue_runner(aid);
		if (rde_dump_pending() &&
		    ibuf_se_ctl && ibuf_se_ctl->w.queued <= 10)
			rde_dump_runner();
	}

	/* do not clean up on shutdown on production, it takes ages. */
	if (debug)
		rde_shutdown();

	/* close pipes */
	if (ibuf_se) {
		msgbuf_clear(&ibuf_se->w);
		close(ibuf_se->fd);
		free(ibuf_se);
	}
	if (ibuf_se_ctl) {
		msgbuf_clear(&ibuf_se_ctl->w);
		close(ibuf_se_ctl->fd);
		free(ibuf_se_ctl);
	}
	msgbuf_clear(&ibuf_main->w);
	close(ibuf_main->fd);
	free(ibuf_main);

	while ((mctx = LIST_FIRST(&rde_mrts)) != NULL) {
		msgbuf_clear(&mctx->mrt.wbuf);
		close(mctx->mrt.wbuf.fd);
		LIST_REMOVE(mctx, entry);
		free(mctx);
	}


	log_info("route decision engine exiting");
	exit(0);
}

struct network_config	 netconf_s, netconf_p;
struct filter_set_head	*session_set, *parent_set;

void
rde_dispatch_imsg_session(struct imsgbuf *ibuf)
{
	struct imsg		 imsg;
	struct peer		 p;
	struct peer_config	 pconf;
	struct session_up	 sup;
	struct ctl_show_rib	 csr;
	struct ctl_show_rib_request	req;
	struct rde_peer		*peer;
	struct rde_aspath	*asp;
	struct filter_set	*s;
	struct nexthop		*nh;
	u_int8_t		*asdata;
	ssize_t			 n;
	int			 verbose;
	u_int16_t		 len;
	u_int8_t		 aid;

	while (ibuf) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("rde_dispatch_imsg_session: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_UPDATE:
			rde_update_dispatch(&imsg);
			break;
		case IMSG_SESSION_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(pconf))
				fatalx("incorrect size of session request");
			memcpy(&pconf, imsg.data, sizeof(pconf));
			peer_add(imsg.hdr.peerid, &pconf);
			break;
		case IMSG_SESSION_UP:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(sup))
				fatalx("incorrect size of session request");
			memcpy(&sup, imsg.data, sizeof(sup));
			peer_up(imsg.hdr.peerid, &sup);
			break;
		case IMSG_SESSION_DOWN:
			peer_down(imsg.hdr.peerid);
			break;
		case IMSG_SESSION_STALE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(aid)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&aid, imsg.data, sizeof(aid));
			if (aid >= AID_MAX)
				fatalx("IMSG_SESSION_STALE: bad AID");
			peer_stale(imsg.hdr.peerid, aid);
			break;
		case IMSG_SESSION_FLUSH:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(aid)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&aid, imsg.data, sizeof(aid));
			if (aid >= AID_MAX)
				fatalx("IMSG_SESSION_FLUSH: bad AID");
			if ((peer = peer_get(imsg.hdr.peerid)) == NULL) {
				log_warnx("rde_dispatch: unknown peer id %d",
				    imsg.hdr.peerid);
				break;
			}
			peer_flush(peer, aid);
			break;
		case IMSG_SESSION_RESTARTED:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(aid)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&aid, imsg.data, sizeof(aid));
			if (aid >= AID_MAX)
				fatalx("IMSG_SESSION_RESTARTED: bad AID");
			if ((peer = peer_get(imsg.hdr.peerid)) == NULL) {
				log_warnx("rde_dispatch: unknown peer id %d",
				    imsg.hdr.peerid);
				break;
			}
			if (peer->staletime[aid])
				peer_flush(peer, aid);
			break;
		case IMSG_REFRESH:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(aid)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&aid, imsg.data, sizeof(aid));
			if (aid >= AID_MAX)
				fatalx("IMSG_REFRESH: bad AID");
			peer_dump(imsg.hdr.peerid, aid);
			break;
		case IMSG_NETWORK_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct network_config)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&netconf_s, imsg.data, sizeof(netconf_s));
			TAILQ_INIT(&netconf_s.attrset);
			session_set = &netconf_s.attrset;
			break;
		case IMSG_NETWORK_ASPATH:
			if (imsg.hdr.len - IMSG_HEADER_SIZE <
			    sizeof(struct ctl_show_rib)) {
				log_warnx("rde_dispatch: wrong imsg len");
				bzero(&netconf_s, sizeof(netconf_s));
				break;
			}
			asdata = imsg.data;
			asdata += sizeof(struct ctl_show_rib);
			memcpy(&csr, imsg.data, sizeof(csr));
			if (csr.aspath_len + sizeof(csr) > imsg.hdr.len -
			    IMSG_HEADER_SIZE) {
				log_warnx("rde_dispatch: wrong aspath len");
				bzero(&netconf_s, sizeof(netconf_s));
				break;
			}
			asp = path_get();
			asp->lpref = csr.local_pref;
			asp->med = csr.med;
			asp->weight = csr.weight;
			asp->flags = csr.flags;
			asp->origin = csr.origin;
			asp->flags |= F_PREFIX_ANNOUNCED | F_ANN_DYNAMIC;
			asp->aspath = aspath_get(asdata, csr.aspath_len);
			netconf_s.asp = asp;
			break;
		case IMSG_NETWORK_ATTR:
			if (imsg.hdr.len <= IMSG_HEADER_SIZE) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			/* parse path attributes */
			len = imsg.hdr.len - IMSG_HEADER_SIZE;
			asp = netconf_s.asp;
			if (rde_attr_add(asp, imsg.data, len) == -1) {
				log_warnx("rde_dispatch: bad network "
				    "attribute");
				path_put(asp);
				bzero(&netconf_s, sizeof(netconf_s));
				break;
			}
			break;
		case IMSG_NETWORK_DONE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			session_set = NULL;
			switch (netconf_s.prefix.aid) {
			case AID_INET:
				if (netconf_s.prefixlen > 32)
					goto badnet;
				network_add(&netconf_s, 0);
				break;
			case AID_INET6:
				if (netconf_s.prefixlen > 128)
					goto badnet;
				network_add(&netconf_s, 0);
				break;
			case 0:
				/* something failed beforehands */
				break;
			default:
badnet:
				log_warnx("rde_dispatch: bad network");
				break;
			}
			break;
		case IMSG_NETWORK_REMOVE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct network_config)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&netconf_s, imsg.data, sizeof(netconf_s));
			TAILQ_INIT(&netconf_s.attrset);
			network_delete(&netconf_s, 0);
			break;
		case IMSG_NETWORK_FLUSH:
			if (imsg.hdr.len != IMSG_HEADER_SIZE) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			prefix_network_clean(peerself, time(NULL),
			    F_ANN_DYNAMIC);
			break;
		case IMSG_FILTER_SET:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct filter_set)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			if (session_set == NULL) {
				log_warnx("rde_dispatch: "
				    "IMSG_FILTER_SET unexpected");
				break;
			}
			if ((s = malloc(sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			memcpy(s, imsg.data, sizeof(struct filter_set));
			TAILQ_INSERT_TAIL(session_set, s, entry);

			if (s->type == ACTION_SET_NEXTHOP) {
				nh = nexthop_get(&s->action.nexthop);
				nh->refcnt++;
			}
			break;
		case IMSG_CTL_SHOW_NETWORK:
		case IMSG_CTL_SHOW_RIB:
		case IMSG_CTL_SHOW_RIB_AS:
		case IMSG_CTL_SHOW_RIB_COMMUNITY:
		case IMSG_CTL_SHOW_RIB_EXTCOMMUNITY:
		case IMSG_CTL_SHOW_RIB_LARGECOMMUNITY:
		case IMSG_CTL_SHOW_RIB_PREFIX:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(req)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&req, imsg.data, sizeof(req));
			rde_dump_ctx_new(&req, imsg.hdr.pid, imsg.hdr.type);
			break;
		case IMSG_CTL_SHOW_NEIGHBOR:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct peer)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&p, imsg.data, sizeof(struct peer));
			peer = peer_get(p.conf.id);
			if (peer != NULL) {
				p.stats.prefix_cnt = peer->prefix_cnt;
				p.stats.prefix_rcvd_update =
				    peer->prefix_rcvd_update;
				p.stats.prefix_rcvd_withdraw =
				    peer->prefix_rcvd_withdraw;
				p.stats.prefix_rcvd_eor =
				    peer->prefix_rcvd_eor;
				p.stats.prefix_sent_update =
				    peer->prefix_sent_update;
				p.stats.prefix_sent_withdraw =
				    peer->prefix_sent_withdraw;
				p.stats.prefix_sent_eor =
				    peer->prefix_sent_eor;
			}
			imsg_compose(ibuf_se_ctl, IMSG_CTL_SHOW_NEIGHBOR, 0,
			    imsg.hdr.pid, -1, &p, sizeof(struct peer));
			break;
		case IMSG_CTL_END:
			imsg_compose(ibuf_se_ctl, IMSG_CTL_END, 0, imsg.hdr.pid,
			    -1, NULL, 0);
			break;
		case IMSG_CTL_SHOW_RIB_MEM:
			imsg_compose(ibuf_se_ctl, IMSG_CTL_SHOW_RIB_MEM, 0,
			    imsg.hdr.pid, -1, &rdemem, sizeof(rdemem));
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by SE */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		case IMSG_XON:
			if (imsg.hdr.peerid) {
				peer = peer_get(imsg.hdr.peerid);
				if (peer)
					peer->throttled = 0;
				break;
			} else {
				rde_dump_ctx_throttle(imsg.hdr.pid, 0);
			}
			break;
		case IMSG_XOFF:
			if (imsg.hdr.peerid) {
				peer = peer_get(imsg.hdr.peerid);
				if (peer)
					peer->throttled = 1;
			} else {
				rde_dump_ctx_throttle(imsg.hdr.pid, 1);
			}
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}
}

void
rde_dispatch_imsg_parent(struct imsgbuf *ibuf)
{
	static struct rdomain	*rd;
	struct imsg		 imsg;
	struct mrt		 xmrt;
	struct rde_rib		 rn;
	struct imsgbuf		*i;
	struct filter_head	*nr;
	struct filter_rule	*r;
	struct filter_set	*s;
	struct nexthop		*nh;
	struct rib		*rib;
	int			 n, fd;
	u_int16_t		 rid;

	while (ibuf) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("rde_dispatch_imsg_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_SOCKET_CONN:
		case IMSG_SOCKET_CONN_CTL:
			if ((fd = imsg.fd) == -1) {
				log_warnx("expected to receive imsg fd to "
				    "SE but didn't receive any");
				break;
			}
			if ((i = malloc(sizeof(struct imsgbuf))) == NULL)
				fatal(NULL);
			imsg_init(i, fd);
			if (imsg.hdr.type == IMSG_SOCKET_CONN) {
				if (ibuf_se) {
					log_warnx("Unexpected imsg connection "
					    "to SE received");
					msgbuf_clear(&ibuf_se->w);
					free(ibuf_se);
				}
				ibuf_se = i;
			} else {
				if (ibuf_se_ctl) {
					log_warnx("Unexpected imsg ctl "
					    "connection to SE received");
					msgbuf_clear(&ibuf_se_ctl->w);
					free(ibuf_se_ctl);
				}
				ibuf_se_ctl = i;
			}
			break;
		case IMSG_NETWORK_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct network_config)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&netconf_p, imsg.data, sizeof(netconf_p));
			TAILQ_INIT(&netconf_p.attrset);
			parent_set = &netconf_p.attrset;
			break;
		case IMSG_NETWORK_DONE:
			parent_set = NULL;
			network_add(&netconf_p, 1);
			break;
		case IMSG_NETWORK_REMOVE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct network_config)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&netconf_p, imsg.data, sizeof(netconf_p));
			TAILQ_INIT(&netconf_p.attrset);
			network_delete(&netconf_p, 1);
			break;
		case IMSG_RECONF_CONF:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct bgpd_config))
				fatalx("IMSG_RECONF_CONF bad len");
			reloadtime = time(NULL);
			out_rules_tmp = calloc(1, sizeof(struct filter_head));
			if (out_rules_tmp == NULL)
				fatal(NULL);
			TAILQ_INIT(out_rules_tmp);
			newdomains = calloc(1, sizeof(struct rdomain_head));
			if (newdomains == NULL)
				fatal(NULL);
			SIMPLEQ_INIT(newdomains);
			if ((nconf = malloc(sizeof(struct bgpd_config))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct bgpd_config));
			for (rid = 0; rid < rib_size; rid++) {
				if (*ribs[rid].name == '\0')
					break;
				ribs[rid].state = RECONF_DELETE;
			}
			break;
		case IMSG_RECONF_RIB:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct rde_rib))
				fatalx("IMSG_RECONF_RIB bad len");
			memcpy(&rn, imsg.data, sizeof(rn));
			rib = rib_find(rn.name);
			if (rib == NULL)
				rib = rib_new(rn.name, rn.rtableid, rn.flags);
			else if (rib->rtableid != rn.rtableid ||
			    (rib->flags & F_RIB_HASNOFIB) !=
			    (rib->flags & F_RIB_HASNOFIB)) {
				struct filter_head	*in_rules;
				struct rib_desc		*ribd = rib_desc(rib);
				/*
				 * Big hammer in the F_RIB_HASNOFIB case but
				 * not often enough used to optimise it more.
				 * Need to save the filters so that they're not
				 * lost.
				 */
				in_rules = ribd->in_rules;
				ribd->in_rules = NULL;
				rde_rib_free(ribd);
				rib = rib_new(rn.name, rn.rtableid, rn.flags);
				ribd->in_rules = in_rules;
			} else
				rib_desc(rib)->state = RECONF_KEEP;
			break;
		case IMSG_RECONF_FILTER:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct filter_rule))
				fatalx("IMSG_RECONF_FILTER bad len");
			if ((r = malloc(sizeof(struct filter_rule))) == NULL)
				fatal(NULL);
			memcpy(r, imsg.data, sizeof(struct filter_rule));
			TAILQ_INIT(&r->set);
			if ((rib = rib_find(r->rib)) == NULL) {
				log_warnx("IMSG_RECONF_FILTER: filter rule "
				    "for nonexistent rib %s", r->rib);
				parent_set = NULL;
				free(r);
				break;
			}
			r->peer.ribid = rib->id;
			parent_set = &r->set;
			if (r->dir == DIR_IN) {
				nr = rib_desc(rib)->in_rules_tmp;
				if (nr == NULL) {
					nr = calloc(1,
					    sizeof(struct filter_head));
					if (nr == NULL)
						fatal(NULL);
					TAILQ_INIT(nr);
					rib_desc(rib)->in_rules_tmp = nr;
				}
				TAILQ_INSERT_TAIL(nr, r, entry);
			} else
				TAILQ_INSERT_TAIL(out_rules_tmp, r, entry);
			break;
		case IMSG_RECONF_RDOMAIN:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct rdomain))
				fatalx("IMSG_RECONF_RDOMAIN bad len");
			if ((rd = malloc(sizeof(struct rdomain))) == NULL)
				fatal(NULL);
			memcpy(rd, imsg.data, sizeof(struct rdomain));
			TAILQ_INIT(&rd->import);
			TAILQ_INIT(&rd->export);
			SIMPLEQ_INSERT_TAIL(newdomains, rd, entry);
			break;
		case IMSG_RECONF_RDOMAIN_EXPORT:
			if (rd == NULL) {
				log_warnx("rde_dispatch_imsg_parent: "
				    "IMSG_RECONF_RDOMAIN_EXPORT unexpected");
				break;
			}
			parent_set = &rd->export;
			break;
		case IMSG_RECONF_RDOMAIN_IMPORT:
			if (rd == NULL) {
				log_warnx("rde_dispatch_imsg_parent: "
				    "IMSG_RECONF_RDOMAIN_IMPORT unexpected");
				break;
			}
			parent_set = &rd->import;
			break;
		case IMSG_RECONF_RDOMAIN_DONE:
			parent_set = NULL;
			break;
		case IMSG_RECONF_DONE:
			if (nconf == NULL)
				fatalx("got IMSG_RECONF_DONE but no config");
			parent_set = NULL;

			rde_reload_done();
			break;
		case IMSG_NEXTHOP_UPDATE:
			nexthop_update(imsg.data);
			break;
		case IMSG_FILTER_SET:
			if (imsg.hdr.len > IMSG_HEADER_SIZE +
			    sizeof(struct filter_set))
				fatalx("IMSG_FILTER_SET bad len");
			if (parent_set == NULL) {
				log_warnx("rde_dispatch_imsg_parent: "
				    "IMSG_FILTER_SET unexpected");
				break;
			}
			if ((s = malloc(sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			memcpy(s, imsg.data, sizeof(struct filter_set));
			TAILQ_INSERT_TAIL(parent_set, s, entry);

			if (s->type == ACTION_SET_NEXTHOP) {
				nh = nexthop_get(&s->action.nexthop);
				nh->refcnt++;
			}
			break;
		case IMSG_MRT_OPEN:
		case IMSG_MRT_REOPEN:
			if (imsg.hdr.len > IMSG_HEADER_SIZE +
			    sizeof(struct mrt)) {
				log_warnx("wrong imsg len");
				break;
			}
			memcpy(&xmrt, imsg.data, sizeof(xmrt));
			if ((fd = imsg.fd) == -1)
				log_warnx("expected to receive fd for mrt dump "
				    "but didn't receive any");
			else if (xmrt.type == MRT_TABLE_DUMP ||
			    xmrt.type == MRT_TABLE_DUMP_MP ||
			    xmrt.type == MRT_TABLE_DUMP_V2) {
				rde_dump_mrt_new(&xmrt, imsg.hdr.pid, fd);
			} else
				close(fd);
			break;
		case IMSG_MRT_CLOSE:
			/* ignore end message because a dump is atomic */
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}
}

/* handle routing updates from the session engine. */
int
rde_update_dispatch(struct imsg *imsg)
{
	struct bgpd_addr	 prefix;
	struct mpattr		 mpa;
	struct rde_peer		*peer;
	struct rde_aspath	*asp = NULL;
	u_char			*p, *mpp = NULL;
	int			 error = -1, pos = 0;
	u_int16_t		 afi, len, mplen;
	u_int16_t		 withdrawn_len;
	u_int16_t		 attrpath_len;
	u_int16_t		 nlri_len;
	u_int8_t		 aid, prefixlen, safi, subtype;
	u_int32_t		 fas;

	peer = peer_get(imsg->hdr.peerid);
	if (peer == NULL)	/* unknown peer, cannot happen */
		return (-1);
	if (peer->state != PEER_UP)
		return (-1);	/* peer is not yet up, cannot happen */

	p = imsg->data;

	if (imsg->hdr.len < IMSG_HEADER_SIZE + 2) {
		rde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLIST, NULL, 0);
		return (-1);
	}

	memcpy(&len, p, 2);
	withdrawn_len = ntohs(len);
	p += 2;
	if (imsg->hdr.len < IMSG_HEADER_SIZE + 2 + withdrawn_len + 2) {
		rde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLIST, NULL, 0);
		return (-1);
	}

	p += withdrawn_len;
	memcpy(&len, p, 2);
	attrpath_len = len = ntohs(len);
	p += 2;
	if (imsg->hdr.len <
	    IMSG_HEADER_SIZE + 2 + withdrawn_len + 2 + attrpath_len) {
		rde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLIST, NULL, 0);
		return (-1);
	}

	nlri_len =
	    imsg->hdr.len - IMSG_HEADER_SIZE - 4 - withdrawn_len - attrpath_len;
	bzero(&mpa, sizeof(mpa));

	if (attrpath_len != 0) { /* 0 = no NLRI information in this message */
		/* parse path attributes */
		asp = path_get();
		while (len > 0) {
			if ((pos = rde_attr_parse(p, len, peer, asp,
			    &mpa)) < 0)
				goto done;
			p += pos;
			len -= pos;
		}

		/* check for missing but necessary attributes */
		if ((subtype = rde_attr_missing(asp, peer->conf.ebgp,
		    nlri_len))) {
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_MISSNG_WK_ATTR,
			    &subtype, sizeof(u_int8_t));
			goto done;
		}

		rde_as4byte_fixup(peer, asp);

		/* enforce remote AS if requested */
		if (asp->flags & F_ATTR_ASPATH &&
		    peer->conf.enforce_as == ENFORCE_AS_ON) {
			fas = aspath_neighbor(asp->aspath);
			if (peer->conf.remote_as != fas) {
			    log_peer_warnx(&peer->conf, "bad path, "
				"starting with %s, "
				"enforce neighbor-as enabled", log_as(fas));
			    rde_update_err(peer, ERR_UPDATE, ERR_UPD_ASPATH,
				    NULL, 0);
			    goto done;
			}
		}

		rde_reflector(peer, asp);
	}

	p = imsg->data;
	len = withdrawn_len;
	p += 2;
	/* withdraw prefix */
	while (len > 0) {
		if ((pos = rde_update_get_prefix(p, len, &prefix,
		    &prefixlen)) == -1) {
			/*
			 * the RFC does not mention what we should do in
			 * this case. Let's do the same as in the NLRI case.
			 */
			log_peer_warnx(&peer->conf, "bad withdraw prefix");
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,
			    NULL, 0);
			goto done;
		}
		if (prefixlen > 32) {
			log_peer_warnx(&peer->conf, "bad withdraw prefix");
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,
			    NULL, 0);
			goto done;
		}

		p += pos;
		len -= pos;

		if (peer->capa.mp[AID_INET] == 0) {
			log_peer_warnx(&peer->conf,
			    "bad withdraw, %s disabled", aid2str(AID_INET));
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,
			    NULL, 0);
			goto done;
		}

		rde_update_withdraw(peer, &prefix, prefixlen);
	}

	if (attrpath_len == 0) {
		/* 0 = no NLRI information in this message */
		if (nlri_len != 0) {
			/* crap at end of update which should not be there */
			rde_update_err(peer, ERR_UPDATE,
			    ERR_UPD_ATTRLIST, NULL, 0);
			return (-1);
		}
		if (withdrawn_len == 0) {
			/* EoR marker */
			peer_recv_eor(peer, AID_INET);
		}
		return (0);
	}

	/* withdraw MP_UNREACH_NLRI if available */
	if (mpa.unreach_len != 0) {
		mpp = mpa.unreach;
		mplen = mpa.unreach_len;
		memcpy(&afi, mpp, 2);
		mpp += 2;
		mplen -= 2;
		afi = ntohs(afi);
		safi = *mpp++;
		mplen--;

		if (afi2aid(afi, safi, &aid) == -1) {
			log_peer_warnx(&peer->conf,
			    "bad AFI/SAFI pair in withdraw");
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,
			    NULL, 0);
			goto done;
		}

		if (peer->capa.mp[aid] == 0) {
			log_peer_warnx(&peer->conf,
			    "bad withdraw, %s disabled", aid2str(aid));
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,
			    NULL, 0);
			goto done;
		}

		if ((asp->flags & ~F_ATTR_MP_UNREACH) == 0 && mplen == 0) {
			/* EoR marker */
			peer_recv_eor(peer, aid);
		}

		switch (aid) {
		case AID_INET6:
			while (mplen > 0) {
				if ((pos = rde_update_get_prefix6(mpp, mplen,
				    &prefix, &prefixlen)) == -1) {
					log_peer_warnx(&peer->conf,
					    "bad IPv6 withdraw prefix");
					rde_update_err(peer, ERR_UPDATE,
					    ERR_UPD_OPTATTR,
					    mpa.unreach, mpa.unreach_len);
					goto done;
				}
				if (prefixlen > 128) {
					log_peer_warnx(&peer->conf,
					    "bad IPv6 withdraw prefix");
					rde_update_err(peer, ERR_UPDATE,
					    ERR_UPD_OPTATTR,
					    mpa.unreach, mpa.unreach_len);
					goto done;
				}

				mpp += pos;
				mplen -= pos;

				rde_update_withdraw(peer, &prefix, prefixlen);
			}
			break;
		case AID_VPN_IPv4:
			while (mplen > 0) {
				if ((pos = rde_update_get_vpn4(mpp, mplen,
				    &prefix, &prefixlen)) == -1) {
					log_peer_warnx(&peer->conf,
					    "bad VPNv4 withdraw prefix");
					rde_update_err(peer, ERR_UPDATE,
					    ERR_UPD_OPTATTR,
					    mpa.unreach, mpa.unreach_len);
					goto done;
				}
				if (prefixlen > 32) {
					log_peer_warnx(&peer->conf,
					    "bad VPNv4 withdraw prefix");
					rde_update_err(peer, ERR_UPDATE,
					    ERR_UPD_OPTATTR,
					    mpa.unreach, mpa.unreach_len);
					goto done;
				}

				mpp += pos;
				mplen -= pos;

				rde_update_withdraw(peer, &prefix, prefixlen);
			}
			break;
		default:
			/* silently ignore unsupported multiprotocol AF */
			break;
		}

		if ((asp->flags & ~F_ATTR_MP_UNREACH) == 0) {
			error = 0;
			goto done;
		}
	}

	/* shift to NLRI information */
	p += 2 + attrpath_len;

	/* aspath needs to be loop free nota bene this is not a hard error */
	if (peer->conf.ebgp &&
	    peer->conf.enforce_local_as == ENFORCE_AS_ON &&
	    !aspath_loopfree(asp->aspath, peer->conf.local_as))
		asp->flags |= F_ATTR_LOOP;

	/* parse nlri prefix */
	while (nlri_len > 0) {
		if ((pos = rde_update_get_prefix(p, nlri_len, &prefix,
		    &prefixlen)) == -1) {
			log_peer_warnx(&peer->conf, "bad nlri prefix");
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,
			    NULL, 0);
			goto done;
		}
		if (prefixlen > 32) {
			log_peer_warnx(&peer->conf, "bad nlri prefix");
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,
			    NULL, 0);
			goto done;
		}

		p += pos;
		nlri_len -= pos;

		if (peer->capa.mp[AID_INET] == 0) {
			log_peer_warnx(&peer->conf,
			    "bad update, %s disabled", aid2str(AID_INET));
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,
			    NULL, 0);
			goto done;
		}

		rde_update_update(peer, asp, &prefix, prefixlen);

		/* max prefix checker */
		if (peer->conf.max_prefix &&
		    peer->prefix_cnt > peer->conf.max_prefix) {
			log_peer_warnx(&peer->conf, "prefix limit reached"
			    " (>%u/%u)", peer->prefix_cnt,
			    peer->conf.max_prefix);
			rde_update_err(peer, ERR_CEASE, ERR_CEASE_MAX_PREFIX,
			    NULL, 0);
			goto done;
		}

	}

	/* add MP_REACH_NLRI if available */
	if (mpa.reach_len != 0) {
		mpp = mpa.reach;
		mplen = mpa.reach_len;
		memcpy(&afi, mpp, 2);
		mpp += 2;
		mplen -= 2;
		afi = ntohs(afi);
		safi = *mpp++;
		mplen--;

		if (afi2aid(afi, safi, &aid) == -1) {
			log_peer_warnx(&peer->conf,
			    "bad AFI/SAFI pair in update");
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,
			    NULL, 0);
			goto done;
		}

		if (peer->capa.mp[aid] == 0) {
			log_peer_warnx(&peer->conf,
			    "bad update, %s disabled", aid2str(aid));
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,
			    NULL, 0);
			goto done;
		}

		/*
		 * this works because asp is not linked.
		 * But first unlock the previously locked nexthop.
		 */
		if (asp->nexthop) {
			asp->nexthop->refcnt--;
			(void)nexthop_delete(asp->nexthop);
			asp->nexthop = NULL;
		}
		if ((pos = rde_get_mp_nexthop(mpp, mplen, aid, asp)) == -1) {
			log_peer_warnx(&peer->conf, "bad nlri prefix");
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,
			    mpa.reach, mpa.reach_len);
			goto done;
		}
		mpp += pos;
		mplen -= pos;

		switch (aid) {
		case AID_INET6:
			while (mplen > 0) {
				if ((pos = rde_update_get_prefix6(mpp, mplen,
				    &prefix, &prefixlen)) == -1) {
					log_peer_warnx(&peer->conf,
					    "bad IPv6 nlri prefix");
					rde_update_err(peer, ERR_UPDATE,
					    ERR_UPD_OPTATTR,
					    mpa.reach, mpa.reach_len);
					goto done;
				}
				if (prefixlen > 128) {
					rde_update_err(peer, ERR_UPDATE,
					    ERR_UPD_OPTATTR,
					    mpa.reach, mpa.reach_len);
					goto done;
				}

				mpp += pos;
				mplen -= pos;

				rde_update_update(peer, asp, &prefix,
				    prefixlen);

				/* max prefix checker */
				if (peer->conf.max_prefix &&
				    peer->prefix_cnt > peer->conf.max_prefix) {
					log_peer_warnx(&peer->conf,
					    "prefix limit reached"
					    " (>%u/%u)", peer->prefix_cnt,
					    peer->conf.max_prefix);
					rde_update_err(peer, ERR_CEASE,
					    ERR_CEASE_MAX_PREFIX, NULL, 0);
					goto done;
				}

			}
			break;
		case AID_VPN_IPv4:
			while (mplen > 0) {
				if ((pos = rde_update_get_vpn4(mpp, mplen,
				    &prefix, &prefixlen)) == -1) {
					log_peer_warnx(&peer->conf,
					    "bad VPNv4 nlri prefix");
					rde_update_err(peer, ERR_UPDATE,
					    ERR_UPD_OPTATTR,
					    mpa.reach, mpa.reach_len);
					goto done;
				}
				if (prefixlen > 32) {
					rde_update_err(peer, ERR_UPDATE,
					    ERR_UPD_OPTATTR,
					    mpa.reach, mpa.reach_len);
					goto done;
				}

				mpp += pos;
				mplen -= pos;

				rde_update_update(peer, asp, &prefix,
				    prefixlen);

				/* max prefix checker */
				if (peer->conf.max_prefix &&
				    peer->prefix_cnt > peer->conf.max_prefix) {
					log_peer_warnx(&peer->conf,
					    "prefix limit reached"
					    " (>%u/%u)", peer->prefix_cnt,
					    peer->conf.max_prefix);
					rde_update_err(peer, ERR_CEASE,
					    ERR_CEASE_MAX_PREFIX, NULL, 0);
					goto done;
				}

			}
			break;
		default:
			/* silently ignore unsupported multiprotocol AF */
			break;
		}
	}

done:
	if (attrpath_len != 0) {
		/* unlock the previously locked entry */
		if (asp->nexthop) {
			asp->nexthop->refcnt--;
			(void)nexthop_delete(asp->nexthop);
		}
		/* free allocated attribute memory that is no longer used */
		path_put(asp);
	}

	return (error);
}

void
rde_update_update(struct rde_peer *peer, struct rde_aspath *asp,
    struct bgpd_addr *prefix, u_int8_t prefixlen)
{
	struct rde_aspath	*fasp;
	enum filter_actions	 action;
	u_int16_t		 i;

	peer->prefix_rcvd_update++;
	/* add original path to the Adj-RIB-In */
	if (path_update(&ribs[0].rib, peer, asp, prefix, prefixlen))
		peer->prefix_cnt++;

	for (i = 1; i < rib_size; i++) {
		if (*ribs[i].name == '\0')
			break;
		/* input filter */
		action = rde_filter(ribs[i].in_rules, &fasp, peer, asp, prefix,
		    prefixlen, peer);

		if (fasp == NULL)
			fasp = asp;

		if (action == ACTION_ALLOW) {
			rde_update_log("update", i, peer,
			    &fasp->nexthop->exit_nexthop, prefix, prefixlen);
			path_update(&ribs[i].rib, peer, fasp, prefix,
			    prefixlen);
		} else if (prefix_remove(&ribs[i].rib, peer, prefix, prefixlen,
		    0)) {
			rde_update_log("filtered withdraw", i, peer,
			    NULL, prefix, prefixlen);
		}

		/* free modified aspath */
		if (fasp != asp)
			path_put(fasp);
	}
}

void
rde_update_withdraw(struct rde_peer *peer, struct bgpd_addr *prefix,
    u_int8_t prefixlen)
{
	u_int16_t i;

	for (i = 1; i < rib_size; i++) {
		if (*ribs[i].name == '\0')
			break;
		if (prefix_remove(&ribs[i].rib, peer, prefix, prefixlen, 0)) {
			rde_update_log("withdraw", i, peer, NULL, prefix,
			    prefixlen);
		}
	}

	/* remove original path form the Adj-RIB-In */
	if (prefix_remove(&ribs[0].rib, peer, prefix, prefixlen, 0))
		peer->prefix_cnt--;

	peer->prefix_rcvd_withdraw++;
}

/*
 * BGP UPDATE parser functions
 */

/* attribute parser specific makros */
#define UPD_READ(t, p, plen, n) \
	do { \
		memcpy(t, p, n); \
		p += n; \
		plen += n; \
	} while (0)

#define CHECK_FLAGS(s, t, m)	\
	(((s) & ~(ATTR_DEFMASK | (m))) == (t))

int
rde_attr_parse(u_char *p, u_int16_t len, struct rde_peer *peer,
    struct rde_aspath *a, struct mpattr *mpa)
{
	struct bgpd_addr nexthop;
	u_char		*op = p, *npath;
	u_int32_t	 tmp32;
	int		 error;
	u_int16_t	 attr_len, nlen;
	u_int16_t	 plen = 0;
	u_int8_t	 flags;
	u_int8_t	 type;
	u_int8_t	 tmp8;

	if (len < 3) {
bad_len:
		rde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLEN, op, len);
		return (-1);
	}

	UPD_READ(&flags, p, plen, 1);
	UPD_READ(&type, p, plen, 1);

	if (flags & ATTR_EXTLEN) {
		if (len - plen < 2)
			goto bad_len;
		UPD_READ(&attr_len, p, plen, 2);
		attr_len = ntohs(attr_len);
	} else {
		UPD_READ(&tmp8, p, plen, 1);
		attr_len = tmp8;
	}

	if (len - plen < attr_len)
		goto bad_len;

	/* adjust len to the actual attribute size including header */
	len = plen + attr_len;

	switch (type) {
	case ATTR_UNDEF:
		/* ignore and drop path attributes with a type code of 0 */
		plen += attr_len;
		break;
	case ATTR_ORIGIN:
		if (attr_len != 1)
			goto bad_len;

		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0)) {
bad_flags:
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRFLAGS,
			    op, len);
			return (-1);
		}

		UPD_READ(&a->origin, p, plen, 1);
		if (a->origin > ORIGIN_INCOMPLETE) {
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_ORIGIN,
			    op, len);
			return (-1);
		}
		if (a->flags & F_ATTR_ORIGIN)
			goto bad_list;
		a->flags |= F_ATTR_ORIGIN;
		break;
	case ATTR_ASPATH:
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0))
			goto bad_flags;
		error = aspath_verify(p, attr_len, rde_as4byte(peer));
		if (error == AS_ERR_SOFT) {
			/*
			 * soft errors like unexpected segment types are
			 * not considered fatal and the path is just
			 * marked invalid.
			 */
			a->flags |= F_ATTR_PARSE_ERR;
			log_peer_warnx(&peer->conf, "bad ASPATH, "
			    "path invalidated and prefix withdrawn");
		} else if (error != 0) {
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_ASPATH,
			    NULL, 0);
			return (-1);
		}
		if (a->flags & F_ATTR_ASPATH)
			goto bad_list;
		if (rde_as4byte(peer)) {
			npath = p;
			nlen = attr_len;
		} else
			npath = aspath_inflate(p, attr_len, &nlen);
		a->flags |= F_ATTR_ASPATH;
		a->aspath = aspath_get(npath, nlen);
		if (npath != p)
			free(npath);
		plen += attr_len;
		break;
	case ATTR_NEXTHOP:
		if (attr_len != 4)
			goto bad_len;
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0))
			goto bad_flags;
		if (a->flags & F_ATTR_NEXTHOP)
			goto bad_list;
		a->flags |= F_ATTR_NEXTHOP;

		bzero(&nexthop, sizeof(nexthop));
		nexthop.aid = AID_INET;
		UPD_READ(&nexthop.v4.s_addr, p, plen, 4);
		/*
		 * Check if the nexthop is a valid IP address. We consider
		 * multicast and experimental addresses as invalid.
		 */
		tmp32 = ntohl(nexthop.v4.s_addr);
		if (IN_MULTICAST(tmp32) || IN_BADCLASS(tmp32)) {
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,
			    op, len);
			return (-1);
		}
		a->nexthop = nexthop_get(&nexthop);
		/*
		 * lock the nexthop because it is not yet linked else
		 * withdraws may remove this nexthop which in turn would
		 * cause a use after free error.
		 */
		a->nexthop->refcnt++;
		break;
	case ATTR_MED:
		if (attr_len != 4)
			goto bad_len;
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, 0))
			goto bad_flags;
		if (a->flags & F_ATTR_MED)
			goto bad_list;
		a->flags |= F_ATTR_MED;

		UPD_READ(&tmp32, p, plen, 4);
		a->med = ntohl(tmp32);
		break;
	case ATTR_LOCALPREF:
		if (attr_len != 4)
			goto bad_len;
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0))
			goto bad_flags;
		if (peer->conf.ebgp) {
			/* ignore local-pref attr on non ibgp peers */
			plen += 4;
			break;
		}
		if (a->flags & F_ATTR_LOCALPREF)
			goto bad_list;
		a->flags |= F_ATTR_LOCALPREF;

		UPD_READ(&tmp32, p, plen, 4);
		a->lpref = ntohl(tmp32);
		break;
	case ATTR_ATOMIC_AGGREGATE:
		if (attr_len != 0)
			goto bad_len;
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0))
			goto bad_flags;
		goto optattr;
	case ATTR_AGGREGATOR:
		if ((!rde_as4byte(peer) && attr_len != 6) ||
		    (rde_as4byte(peer) && attr_len != 8)) {
			/*
			 * ignore attribute in case of error as per
			 * RFC 7606
			 */
			log_peer_warnx(&peer->conf, "bad AGGREGATOR, "
			    "partial attribute ignored");
			plen += attr_len;
			break;
		}
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE,
		    ATTR_PARTIAL))
			goto bad_flags;
		if (!rde_as4byte(peer)) {
			/* need to inflate aggregator AS to 4-byte */
			u_char	t[8];
			t[0] = t[1] = 0;
			UPD_READ(&t[2], p, plen, 2);
			UPD_READ(&t[4], p, plen, 4);
			if (attr_optadd(a, flags, type, t,
			    sizeof(t)) == -1)
				goto bad_list;
			break;
		}
		/* 4-byte ready server take the default route */
		goto optattr;
	case ATTR_COMMUNITIES:
		if (attr_len == 0 || attr_len % 4 != 0) {
			/*
			 * mark update as bad and withdraw all routes as per
			 * RFC 7606
			 */
			a->flags |= F_ATTR_PARSE_ERR;
			log_peer_warnx(&peer->conf, "bad COMMUNITIES, "
			    "path invalidated and prefix withdrawn");
		}
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE,
		    ATTR_PARTIAL))
			goto bad_flags;
		goto optattr;
	case ATTR_LARGE_COMMUNITIES:
		if (attr_len == 0 || attr_len % 12 != 0) {
			/*
			 * mark update as bad and withdraw all routes as per
			 * RFC 7606
			 */
			a->flags |= F_ATTR_PARSE_ERR;
			log_peer_warnx(&peer->conf, "bad LARGE COMMUNITIES, "
			    "path invalidated and prefix withdrawn");
		}
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE,
		    ATTR_PARTIAL))
			goto bad_flags;
		goto optattr;
	case ATTR_EXT_COMMUNITIES:
		if (attr_len == 0 || attr_len % 8 != 0) {
			/*
			 * mark update as bad and withdraw all routes as per
			 * RFC 7606
			 */
			a->flags |= F_ATTR_PARSE_ERR;
			log_peer_warnx(&peer->conf, "bad EXT_COMMUNITIES, "
			    "path invalidated and prefix withdrawn");
		}
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE,
		    ATTR_PARTIAL))
			goto bad_flags;
		goto optattr;
	case ATTR_ORIGINATOR_ID:
		if (attr_len != 4)
			goto bad_len;
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, 0))
			goto bad_flags;
		goto optattr;
	case ATTR_CLUSTER_LIST:
		if (attr_len % 4 != 0)
			goto bad_len;
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, 0))
			goto bad_flags;
		goto optattr;
	case ATTR_MP_REACH_NLRI:
		if (attr_len < 4)
			goto bad_len;
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, 0))
			goto bad_flags;
		/* the validity is checked in rde_update_dispatch() */
		if (a->flags & F_ATTR_MP_REACH)
			goto bad_list;
		a->flags |= F_ATTR_MP_REACH;

		mpa->reach = p;
		mpa->reach_len = attr_len;
		plen += attr_len;
		break;
	case ATTR_MP_UNREACH_NLRI:
		if (attr_len < 3)
			goto bad_len;
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, 0))
			goto bad_flags;
		/* the validity is checked in rde_update_dispatch() */
		if (a->flags & F_ATTR_MP_UNREACH)
			goto bad_list;
		a->flags |= F_ATTR_MP_UNREACH;

		mpa->unreach = p;
		mpa->unreach_len = attr_len;
		plen += attr_len;
		break;
	case ATTR_AS4_AGGREGATOR:
		if (attr_len != 8) {
			/* see ATTR_AGGREGATOR ... */
			if ((flags & ATTR_PARTIAL) == 0)
				goto bad_len;
			log_peer_warnx(&peer->conf, "bad AS4_AGGREGATOR, "
			    "partial attribute ignored");
			plen += attr_len;
			break;
		}
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE,
		    ATTR_PARTIAL))
			goto bad_flags;
		a->flags |= F_ATTR_AS4BYTE_NEW;
		goto optattr;
	case ATTR_AS4_PATH:
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE,
		    ATTR_PARTIAL))
			goto bad_flags;
		if ((error = aspath_verify(p, attr_len, 1)) != 0) {
			/*
			 * XXX RFC does not specify how to handle errors.
			 * XXX Instead of dropping the session because of a
			 * XXX bad path just mark the full update as having
			 * XXX a parse error which makes the update no longer
			 * XXX eligible and will not be considered for routing
			 * XXX or redistribution.
			 * XXX We follow draft-ietf-idr-optional-transitive
			 * XXX by looking at the partial bit.
			 * XXX Consider soft errors similar to a partial attr.
			 */
			if (flags & ATTR_PARTIAL || error == AS_ERR_SOFT) {
				a->flags |= F_ATTR_PARSE_ERR;
				log_peer_warnx(&peer->conf, "bad AS4_PATH, "
				    "path invalidated and prefix withdrawn");
				goto optattr;
			} else {
				rde_update_err(peer, ERR_UPDATE, ERR_UPD_ASPATH,
				    NULL, 0);
				return (-1);
			}
		}
		a->flags |= F_ATTR_AS4BYTE_NEW;
		goto optattr;
	default:
		if ((flags & ATTR_OPTIONAL) == 0) {
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_UNKNWN_WK_ATTR,
			    op, len);
			return (-1);
		}
optattr:
		if (attr_optadd(a, flags, type, p, attr_len) == -1) {
bad_list:
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLIST,
			    NULL, 0);
			return (-1);
		}

		plen += attr_len;
		break;
	}

	return (plen);
}

int
rde_attr_add(struct rde_aspath *a, u_char *p, u_int16_t len)
{
	u_int16_t	 attr_len;
	u_int16_t	 plen = 0;
	u_int8_t	 flags;
	u_int8_t	 type;
	u_int8_t	 tmp8;

	if (a == NULL)		/* no aspath, nothing to do */
		return (0);
	if (len < 3)
		return (-1);

	UPD_READ(&flags, p, plen, 1);
	UPD_READ(&type, p, plen, 1);

	if (flags & ATTR_EXTLEN) {
		if (len - plen < 2)
			return (-1);
		UPD_READ(&attr_len, p, plen, 2);
		attr_len = ntohs(attr_len);
	} else {
		UPD_READ(&tmp8, p, plen, 1);
		attr_len = tmp8;
	}

	if (len - plen < attr_len)
		return (-1);

	if (attr_optadd(a, flags, type, p, attr_len) == -1)
		return (-1);
	return (0);
}

#undef UPD_READ
#undef CHECK_FLAGS

u_int8_t
rde_attr_missing(struct rde_aspath *a, int ebgp, u_int16_t nlrilen)
{
	/* ATTR_MP_UNREACH_NLRI may be sent alone */
	if (nlrilen == 0 && a->flags & F_ATTR_MP_UNREACH &&
	    (a->flags & F_ATTR_MP_REACH) == 0)
		return (0);

	if ((a->flags & F_ATTR_ORIGIN) == 0)
		return (ATTR_ORIGIN);
	if ((a->flags & F_ATTR_ASPATH) == 0)
		return (ATTR_ASPATH);
	if ((a->flags & F_ATTR_MP_REACH) == 0 &&
	    (a->flags & F_ATTR_NEXTHOP) == 0)
		return (ATTR_NEXTHOP);
	if (!ebgp)
		if ((a->flags & F_ATTR_LOCALPREF) == 0)
			return (ATTR_LOCALPREF);
	return (0);
}

int
rde_get_mp_nexthop(u_char *data, u_int16_t len, u_int8_t aid,
    struct rde_aspath *asp)
{
	struct bgpd_addr	nexthop;
	u_int8_t		totlen, nhlen;

	if (len == 0)
		return (-1);

	nhlen = *data++;
	totlen = 1;
	len--;

	if (nhlen > len)
		return (-1);

	bzero(&nexthop, sizeof(nexthop));
	nexthop.aid = aid;
	switch (aid) {
	case AID_INET6:
		/*
		 * RFC2545 describes that there may be a link-local
		 * address carried in nexthop. Yikes!
		 * This is not only silly, it is wrong and we just ignore
		 * this link-local nexthop. The bgpd session doesn't run
		 * over the link-local address so why should all other
		 * traffic.
		 */
		if (nhlen != 16 && nhlen != 32) {
			log_warnx("bad multiprotocol nexthop, bad size");
			return (-1);
		}
		memcpy(&nexthop.v6.s6_addr, data, 16);
		break;
	case AID_VPN_IPv4:
		/*
		 * Neither RFC4364 nor RFC3107 specify the format of the
		 * nexthop in an explicit way. The quality of RFC went down
		 * the toilet the larger the number got.
		 * RFC4364 is very confusing about VPN-IPv4 address and the
		 * VPN-IPv4 prefix that carries also a MPLS label.
		 * So the nexthop is a 12-byte address with a 64bit RD and
		 * an IPv4 address following. In the nexthop case the RD can
		 * be ignored.
		 * Since the nexthop has to be in the main IPv4 table just
		 * create an AID_INET nexthop. So we don't need to handle
		 * AID_VPN_IPv4 in nexthop and kroute.
		 */
		if (nhlen != 12) {
			log_warnx("bad multiprotocol nexthop, bad size");
			return (-1);
		}
		data += sizeof(u_int64_t);
		nexthop.aid = AID_INET;
		memcpy(&nexthop.v4, data, sizeof(nexthop.v4));
		break;
	default:
		log_warnx("bad multiprotocol nexthop, bad AID");
		return (-1);
	}

	asp->nexthop = nexthop_get(&nexthop);
	/*
	 * lock the nexthop because it is not yet linked else
	 * withdraws may remove this nexthop which in turn would
	 * cause a use after free error.
	 */
	asp->nexthop->refcnt++;

	/* ignore reserved (old SNPA) field as per RFC4760 */
	totlen += nhlen + 1;
	data += nhlen + 1;

	return (totlen);
}

int
rde_update_extract_prefix(u_char *p, u_int16_t len, void *va,
    u_int8_t pfxlen, u_int8_t max)
{
	static u_char addrmask[] = {
	    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };
	u_char		*a = va;
	int		 i;
	u_int16_t	 plen = 0;

	for (i = 0; pfxlen && i < max; i++) {
		if (len <= plen)
			return (-1);
		if (pfxlen < 8) {
			a[i] = *p++ & addrmask[pfxlen];
			plen++;
			break;
		} else {
			a[i] = *p++;
			plen++;
			pfxlen -= 8;
		}
	}
	return (plen);
}

int
rde_update_get_prefix(u_char *p, u_int16_t len, struct bgpd_addr *prefix,
    u_int8_t *prefixlen)
{
	u_int8_t	 pfxlen;
	int		 plen;

	if (len < 1)
		return (-1);

	pfxlen = *p++;
	len--;

	bzero(prefix, sizeof(struct bgpd_addr));
	prefix->aid = AID_INET;
	*prefixlen = pfxlen;

	if ((plen = rde_update_extract_prefix(p, len, &prefix->v4, pfxlen,
	    sizeof(prefix->v4))) == -1)
		return (-1);

	return (plen + 1);	/* pfxlen needs to be added */
}

int
rde_update_get_prefix6(u_char *p, u_int16_t len, struct bgpd_addr *prefix,
    u_int8_t *prefixlen)
{
	int		plen;
	u_int8_t	pfxlen;

	if (len < 1)
		return (-1);

	pfxlen = *p++;
	len--;

	bzero(prefix, sizeof(struct bgpd_addr));
	prefix->aid = AID_INET6;
	*prefixlen = pfxlen;

	if ((plen = rde_update_extract_prefix(p, len, &prefix->v6, pfxlen,
	    sizeof(prefix->v6))) == -1)
		return (-1);

	return (plen + 1);	/* pfxlen needs to be added */
}

int
rde_update_get_vpn4(u_char *p, u_int16_t len, struct bgpd_addr *prefix,
    u_int8_t *prefixlen)
{
	int		 rv, done = 0;
	u_int8_t	 pfxlen;
	u_int16_t	 plen;

	if (len < 1)
		return (-1);

	memcpy(&pfxlen, p, 1);
	p += 1;
	plen = 1;

	bzero(prefix, sizeof(struct bgpd_addr));

	/* label stack */
	do {
		if (len - plen < 3 || pfxlen < 3 * 8)
			return (-1);
		if (prefix->vpn4.labellen + 3U >
		    sizeof(prefix->vpn4.labelstack))
			return (-1);
		prefix->vpn4.labelstack[prefix->vpn4.labellen++] = *p++;
		prefix->vpn4.labelstack[prefix->vpn4.labellen++] = *p++;
		prefix->vpn4.labelstack[prefix->vpn4.labellen] = *p++;
		if (prefix->vpn4.labelstack[prefix->vpn4.labellen] &
		    BGP_MPLS_BOS)
			done = 1;
		prefix->vpn4.labellen++;
		plen += 3;
		pfxlen -= 3 * 8;
	} while (!done);

	/* RD */
	if (len - plen < (int)sizeof(u_int64_t) ||
	    pfxlen < sizeof(u_int64_t) * 8)
		return (-1);
	memcpy(&prefix->vpn4.rd, p, sizeof(u_int64_t));
	pfxlen -= sizeof(u_int64_t) * 8;
	p += sizeof(u_int64_t);
	plen += sizeof(u_int64_t);

	/* prefix */
	prefix->aid = AID_VPN_IPv4;
	*prefixlen = pfxlen;

	if ((rv = rde_update_extract_prefix(p, len, &prefix->vpn4.addr,
	    pfxlen, sizeof(prefix->vpn4.addr))) == -1)
		return (-1);

	return (plen + rv);
}

void
rde_update_err(struct rde_peer *peer, u_int8_t error, u_int8_t suberr,
    void *data, u_int16_t size)
{
	struct ibuf	*wbuf;

	if ((wbuf = imsg_create(ibuf_se, IMSG_UPDATE_ERR, peer->conf.id, 0,
	    size + sizeof(error) + sizeof(suberr))) == NULL)
		fatal("%s %d imsg_create error", __func__, __LINE__);
	if (imsg_add(wbuf, &error, sizeof(error)) == -1 ||
	    imsg_add(wbuf, &suberr, sizeof(suberr)) == -1 ||
	    imsg_add(wbuf, data, size) == -1)
		fatal("%s %d imsg_add error", __func__, __LINE__);
	imsg_close(ibuf_se, wbuf);
	peer->state = PEER_ERR;
}

void
rde_update_log(const char *message, u_int16_t rid,
    const struct rde_peer *peer, const struct bgpd_addr *next,
    const struct bgpd_addr *prefix, u_int8_t prefixlen)
{
	char		*l = NULL;
	char		*n = NULL;
	char		*p = NULL;

	if ( !((conf->log & BGPD_LOG_UPDATES) ||
	       (peer->conf.flags & PEERFLAG_LOG_UPDATES)) )
		return;

	if (next != NULL)
		if (asprintf(&n, " via %s", log_addr(next)) == -1)
			n = NULL;
	if (asprintf(&p, "%s/%u", log_addr(prefix), prefixlen) == -1)
		p = NULL;
	l = log_fmt_peer(&peer->conf);
	log_info("Rib %s: %s AS%s: %s %s%s", ribs[rid].name,
	    l, log_as(peer->conf.remote_as), message,
	    p ? p : "out of memory", n ? n : "");

	free(l);
	free(n);
	free(p);
}

/*
 * 4-Byte ASN helper function.
 * Two scenarios need to be considered:
 * - NEW session with NEW attributes present -> just remove the attributes
 * - OLD session with NEW attributes present -> try to merge them
 */
void
rde_as4byte_fixup(struct rde_peer *peer, struct rde_aspath *a)
{
	struct attr	*nasp, *naggr, *oaggr;
	u_int32_t	 as;

	/*
	 * if either ATTR_AS4_AGGREGATOR or ATTR_AS4_PATH is present
	 * try to fixup the attributes.
	 * Do not fixup if F_ATTR_PARSE_ERR is set.
	 */
	if (!(a->flags & F_ATTR_AS4BYTE_NEW) || a->flags & F_ATTR_PARSE_ERR)
		return;

	/* first get the attributes */
	nasp = attr_optget(a, ATTR_AS4_PATH);
	naggr = attr_optget(a, ATTR_AS4_AGGREGATOR);

	if (rde_as4byte(peer)) {
		/* NEW session using 4-byte ASNs */
		if (nasp) {
			log_peer_warnx(&peer->conf, "uses 4-byte ASN "
			    "but sent AS4_PATH attribute.");
			attr_free(a, nasp);
		}
		if (naggr) {
			log_peer_warnx(&peer->conf, "uses 4-byte ASN "
			    "but sent AS4_AGGREGATOR attribute.");
			attr_free(a, naggr);
		}
		return;
	}
	/* OLD session using 2-byte ASNs */
	/* try to merge the new attributes into the old ones */
	if ((oaggr = attr_optget(a, ATTR_AGGREGATOR))) {
		memcpy(&as, oaggr->data, sizeof(as));
		if (ntohl(as) != AS_TRANS) {
			/* per RFC ignore AS4_PATH and AS4_AGGREGATOR */
			if (nasp)
				attr_free(a, nasp);
			if (naggr)
				attr_free(a, naggr);
			return;
		}
		if (naggr) {
			/* switch over to new AGGREGATOR */
			attr_free(a, oaggr);
			if (attr_optadd(a, ATTR_OPTIONAL | ATTR_TRANSITIVE,
			    ATTR_AGGREGATOR, naggr->data, naggr->len))
				fatalx("attr_optadd failed but impossible");
		}
	}
	/* there is no need for AS4_AGGREGATOR any more */
	if (naggr)
		attr_free(a, naggr);

	/* merge AS4_PATH with ASPATH */
	if (nasp)
		aspath_merge(a, nasp);
}


/*
 * route reflector helper function
 */
void
rde_reflector(struct rde_peer *peer, struct rde_aspath *asp)
{
	struct attr	*a;
	u_int8_t	*p;
	u_int16_t	 len;
	u_int32_t	 id;

	/* do not consider updates with parse errors */
	if (asp->flags & F_ATTR_PARSE_ERR)
		return;

	/* check for originator id if eq router_id drop */
	if ((a = attr_optget(asp, ATTR_ORIGINATOR_ID)) != NULL) {
		if (memcmp(&conf->bgpid, a->data, sizeof(conf->bgpid)) == 0) {
			/* this is coming from myself */
			asp->flags |= F_ATTR_LOOP;
			return;
		}
	} else if (conf->flags & BGPD_FLAG_REFLECTOR) {
		if (peer->conf.ebgp)
			id = conf->bgpid;
		else
			id = htonl(peer->remote_bgpid);
		if (attr_optadd(asp, ATTR_OPTIONAL, ATTR_ORIGINATOR_ID,
		    &id, sizeof(u_int32_t)) == -1)
			fatalx("attr_optadd failed but impossible");
	}

	/* check for own id in the cluster list */
	if (conf->flags & BGPD_FLAG_REFLECTOR) {
		if ((a = attr_optget(asp, ATTR_CLUSTER_LIST)) != NULL) {
			for (len = 0; len < a->len;
			    len += sizeof(conf->clusterid))
				/* check if coming from my cluster */
				if (memcmp(&conf->clusterid, a->data + len,
				    sizeof(conf->clusterid)) == 0) {
					asp->flags |= F_ATTR_LOOP;
					return;
				}

			/* prepend own clusterid by replacing attribute */
			len = a->len + sizeof(conf->clusterid);
			if (len < a->len)
				fatalx("rde_reflector: cluster-list overflow");
			if ((p = malloc(len)) == NULL)
				fatal("rde_reflector");
			memcpy(p, &conf->clusterid, sizeof(conf->clusterid));
			memcpy(p + sizeof(conf->clusterid), a->data, a->len);
			attr_free(asp, a);
			if (attr_optadd(asp, ATTR_OPTIONAL, ATTR_CLUSTER_LIST,
			    p, len) == -1)
				fatalx("attr_optadd failed but impossible");
			free(p);
		} else if (attr_optadd(asp, ATTR_OPTIONAL, ATTR_CLUSTER_LIST,
		    &conf->clusterid, sizeof(conf->clusterid)) == -1)
			fatalx("attr_optadd failed but impossible");
	}
}

/*
 * control specific functions
 */
void
rde_dump_rib_as(struct prefix *p, struct rde_aspath *asp, pid_t pid, int flags)
{
	struct ctl_show_rib	 rib;
	struct ibuf		*wbuf;
	struct attr		*a;
	void			*bp;
	time_t			 staletime;
	u_int8_t		 l;

	bzero(&rib, sizeof(rib));
	rib.lastchange = p->lastchange;
	rib.local_pref = asp->lpref;
	rib.med = asp->med;
	rib.weight = asp->weight;
	strlcpy(rib.descr, asp->peer->conf.descr, sizeof(rib.descr));
	memcpy(&rib.remote_addr, &asp->peer->remote_addr,
	    sizeof(rib.remote_addr));
	rib.remote_id = asp->peer->remote_bgpid;
	if (asp->nexthop != NULL) {
		memcpy(&rib.true_nexthop, &asp->nexthop->true_nexthop,
		    sizeof(rib.true_nexthop));
		memcpy(&rib.exit_nexthop, &asp->nexthop->exit_nexthop,
		    sizeof(rib.exit_nexthop));
	} else {
		/* announced network may have a NULL nexthop */
		bzero(&rib.true_nexthop, sizeof(rib.true_nexthop));
		bzero(&rib.exit_nexthop, sizeof(rib.exit_nexthop));
		rib.true_nexthop.aid = p->prefix->aid;
		rib.exit_nexthop.aid = p->prefix->aid;
	}
	pt_getaddr(p->prefix, &rib.prefix);
	rib.prefixlen = p->prefix->prefixlen;
	rib.origin = asp->origin;
	rib.flags = 0;
	if (p->re->active == p)
		rib.flags |= F_PREF_ACTIVE;
	if (!asp->peer->conf.ebgp)
		rib.flags |= F_PREF_INTERNAL;
	if (asp->flags & F_PREFIX_ANNOUNCED)
		rib.flags |= F_PREF_ANNOUNCE;
	if (asp->nexthop == NULL || asp->nexthop->state == NEXTHOP_REACH)
		rib.flags |= F_PREF_ELIGIBLE;
	if (asp->flags & F_ATTR_LOOP)
		rib.flags &= ~F_PREF_ELIGIBLE;
	staletime = asp->peer->staletime[p->prefix->aid];
	if (staletime && p->lastchange <= staletime)
		rib.flags |= F_PREF_STALE;
	rib.aspath_len = aspath_length(asp->aspath);

	if ((wbuf = imsg_create(ibuf_se_ctl, IMSG_CTL_SHOW_RIB, 0, pid,
	    sizeof(rib) + rib.aspath_len)) == NULL)
		return;
	if (imsg_add(wbuf, &rib, sizeof(rib)) == -1 ||
	    imsg_add(wbuf, aspath_dump(asp->aspath),
	    rib.aspath_len) == -1)
		return;
	imsg_close(ibuf_se_ctl, wbuf);

	if (flags & F_CTL_DETAIL)
		for (l = 0; l < asp->others_len; l++) {
			if ((a = asp->others[l]) == NULL)
				break;
			if ((wbuf = imsg_create(ibuf_se_ctl,
			    IMSG_CTL_SHOW_RIB_ATTR, 0, pid,
			    attr_optlen(a))) == NULL)
				return;
			if ((bp = ibuf_reserve(wbuf, attr_optlen(a))) == NULL) {
				ibuf_free(wbuf);
				return;
			}
			if (attr_write(bp, attr_optlen(a), a->flags,
			    a->type, a->data, a->len) == -1) {
				ibuf_free(wbuf);
				return;
			}
			imsg_close(ibuf_se_ctl, wbuf);
		}
}

void
rde_dump_filterout(struct rde_peer *peer, struct prefix *p,
    struct ctl_show_rib_request *req)
{
	struct bgpd_addr	 addr;
	struct rde_aspath	*asp;
	enum filter_actions	 a;

	if (up_test_update(peer, p) != 1)
		return;

	pt_getaddr(p->prefix, &addr);
	a = rde_filter(out_rules, &asp, peer, p->aspath, &addr,
	    p->prefix->prefixlen, p->aspath->peer);
	if (asp)
		asp->peer = p->aspath->peer;
	else
		asp = p->aspath;

	if (a == ACTION_ALLOW)
		rde_dump_rib_as(p, asp, req->pid, req->flags);

	if (asp != p->aspath)
		path_put(asp);
}

void
rde_dump_filter(struct prefix *p, struct ctl_show_rib_request *req)
{
	struct rde_peer		*peer;

	if (req->flags & F_CTL_ADJ_IN ||
	    !(req->flags & (F_CTL_ADJ_IN|F_CTL_ADJ_OUT))) {
		if (req->peerid && req->peerid != p->aspath->peer->conf.id)
			return;
		if (req->type == IMSG_CTL_SHOW_RIB_AS &&
		    !aspath_match(p->aspath->aspath->data,
		    p->aspath->aspath->len, &req->as, req->as.as))
			return;
		if (req->type == IMSG_CTL_SHOW_RIB_COMMUNITY &&
		    !community_match(p->aspath, req->community.as,
		    req->community.type))
			return;
		if (req->type == IMSG_CTL_SHOW_RIB_EXTCOMMUNITY &&
		    !community_ext_match(p->aspath, &req->extcommunity, 0))
			return;
		if (req->type == IMSG_CTL_SHOW_RIB_LARGECOMMUNITY &&
		    !community_large_match(p->aspath, req->large_community.as,
		    req->large_community.ld1, req->large_community.ld2))
			return;
		if ((req->flags & F_CTL_ACTIVE) && p->re->active != p)
			return;
		rde_dump_rib_as(p, p->aspath, req->pid, req->flags);
	} else if (req->flags & F_CTL_ADJ_OUT) {
		if (p->re->active != p)
			/* only consider active prefix */
			return;
		if (req->peerid) {
			if ((peer = peer_get(req->peerid)) != NULL)
				rde_dump_filterout(peer, p, req);
			return;
		}
	}
}

void
rde_dump_upcall(struct rib_entry *re, void *ptr)
{
	struct prefix		*p;
	struct rde_dump_ctx	*ctx = ptr;

	LIST_FOREACH(p, &re->prefix_h, rib_l)
		rde_dump_filter(p, &ctx->req);
}

void
rde_dump_prefix_upcall(struct rib_entry *re, void *ptr)
{
	struct rde_dump_ctx	*ctx = ptr;
	struct prefix		*p;
	struct pt_entry		*pt;
	struct bgpd_addr	 addr;

	pt = re->prefix;
	pt_getaddr(pt, &addr);
	if (addr.aid != ctx->req.prefix.aid)
		return;
	if (ctx->req.prefixlen > pt->prefixlen)
		return;
	if (!prefix_compare(&ctx->req.prefix, &addr, ctx->req.prefixlen))
		LIST_FOREACH(p, &re->prefix_h, rib_l)
			rde_dump_filter(p, &ctx->req);
}

void
rde_dump_ctx_new(struct ctl_show_rib_request *req, pid_t pid,
    enum imsg_type type)
{
	struct rde_dump_ctx	*ctx;
	struct rib		*rib;
	struct rib_entry	*re;
	u_int			 error;
	u_int8_t		 hostplen;

	if ((ctx = calloc(1, sizeof(*ctx))) == NULL) {
		log_warn("rde_dump_ctx_new");
		error = CTL_RES_NOMEM;
		imsg_compose(ibuf_se_ctl, IMSG_CTL_RESULT, 0, pid, -1, &error,
		    sizeof(error));
		return;
	}
	if ((rib = rib_find(req->rib)) == NULL) {
		log_warnx("rde_dump_ctx_new: no such rib %s", req->rib);
		error = CTL_RES_NOSUCHPEER;
		imsg_compose(ibuf_se_ctl, IMSG_CTL_RESULT, 0, pid, -1, &error,
		    sizeof(error));
		free(ctx);
		return;
	}

	memcpy(&ctx->req, req, sizeof(struct ctl_show_rib_request));
	ctx->req.pid = pid;
	ctx->req.type = type;
	ctx->ribctx.ctx_count = CTL_MSG_HIGH_MARK;
	ctx->ribctx.ctx_rib = rib;
	switch (ctx->req.type) {
	case IMSG_CTL_SHOW_NETWORK:
		ctx->ribctx.ctx_upcall = network_dump_upcall;
		break;
	case IMSG_CTL_SHOW_RIB:
	case IMSG_CTL_SHOW_RIB_AS:
	case IMSG_CTL_SHOW_RIB_COMMUNITY:
	case IMSG_CTL_SHOW_RIB_EXTCOMMUNITY:
	case IMSG_CTL_SHOW_RIB_LARGECOMMUNITY:
		ctx->ribctx.ctx_upcall = rde_dump_upcall;
		break;
	case IMSG_CTL_SHOW_RIB_PREFIX:
		if (req->flags & F_LONGER) {
			ctx->ribctx.ctx_upcall = rde_dump_prefix_upcall;
			break;
		}
		switch (req->prefix.aid) {
		case AID_INET:
		case AID_VPN_IPv4:
			hostplen = 32;
			break;
		case AID_INET6:
			hostplen = 128;
			break;
		default:
			fatalx("rde_dump_ctx_new: unknown af");
		}
		if (req->prefixlen == hostplen)
			re = rib_lookup(rib, &req->prefix);
		else
			re = rib_get(rib, &req->prefix, req->prefixlen);
		if (re)
			rde_dump_upcall(re, ctx);
		imsg_compose(ibuf_se_ctl, IMSG_CTL_END, 0, ctx->req.pid,
		    -1, NULL, 0);
		free(ctx);
		return;
	default:
		fatalx("rde_dump_ctx_new: unsupported imsg type");
	}
	ctx->ribctx.ctx_done = rde_dump_done;
	ctx->ribctx.ctx_arg = ctx;
	ctx->ribctx.ctx_aid = ctx->req.aid;
	LIST_INSERT_HEAD(&rde_dump_h, ctx, entry);
	rib_dump_r(&ctx->ribctx);
}

void
rde_dump_ctx_throttle(pid_t pid, int throttle)
{
	struct rde_dump_ctx	*ctx;

	LIST_FOREACH(ctx, &rde_dump_h, entry) {
		if (ctx->req.pid == pid) {
			ctx->throttled = throttle;
			return;
		}
	}
}

void
rde_dump_runner(void)
{
	struct rde_dump_ctx	*ctx, *next;

	for (ctx = LIST_FIRST(&rde_dump_h); ctx != NULL; ctx = next) {
		next = LIST_NEXT(ctx, entry);
		if (!ctx->throttled)
			rib_dump_r(&ctx->ribctx);
	}
}

int
rde_dump_pending(void)
{
	struct rde_dump_ctx	*ctx;

	/* return true if there is at least one unthrottled context */
	LIST_FOREACH(ctx, &rde_dump_h, entry)
		if (!ctx->throttled)
			return (1);

	return (0);
}

void
rde_dump_done(void *arg)
{
	struct rde_dump_ctx	*ctx = arg;

	imsg_compose(ibuf_se_ctl, IMSG_CTL_END, 0, ctx->req.pid,
	    -1, NULL, 0);
	LIST_REMOVE(ctx, entry);
	free(ctx);
}

void
rde_dump_rib_free(struct rib *rib)
{
	struct rde_dump_ctx	*ctx, *next;

	for (ctx = LIST_FIRST(&rde_dump_h); ctx != NULL; ctx = next) {
		next = LIST_NEXT(ctx, entry);
		if (ctx->ribctx.ctx_rib == rib)
			rde_dump_done(ctx);
	}
}

void
rde_dump_mrt_new(struct mrt *mrt, pid_t pid, int fd)
{
	struct rde_mrt_ctx	*ctx;
	struct rib		*rib;

	if ((ctx = calloc(1, sizeof(*ctx))) == NULL) {
		log_warn("rde_dump_mrt_new");
		return;
	}
	memcpy(&ctx->mrt, mrt, sizeof(struct mrt));
	TAILQ_INIT(&ctx->mrt.wbuf.bufs);
	ctx->mrt.wbuf.fd = fd;
	ctx->mrt.state = MRT_STATE_RUNNING;
	rib = rib_find(ctx->mrt.rib);
	if (rib == NULL) {
		log_warnx("non existing RIB %s for mrt dump", ctx->mrt.rib);
		free(ctx);
		return;
	}

	if (ctx->mrt.type == MRT_TABLE_DUMP_V2)
		mrt_dump_v2_hdr(&ctx->mrt, conf, &peerlist);

	ctx->ribctx.ctx_count = CTL_MSG_HIGH_MARK;
	ctx->ribctx.ctx_rib = rib;
	ctx->ribctx.ctx_upcall = mrt_dump_upcall;
	ctx->ribctx.ctx_done = mrt_done;
	ctx->ribctx.ctx_arg = &ctx->mrt;
	ctx->ribctx.ctx_aid = AID_UNSPEC;
	LIST_INSERT_HEAD(&rde_mrts, ctx, entry);
	rde_mrt_cnt++;
	rib_dump_r(&ctx->ribctx);
}

void
rde_dump_mrt_free(struct rib *rib)
{
	struct rde_mrt_ctx	*ctx, *next;

	for (ctx = LIST_FIRST(&rde_mrts); ctx != NULL; ctx = next) {
		next = LIST_NEXT(ctx, entry);
		if (ctx->ribctx.ctx_rib == rib)
			mrt_done(&ctx->mrt);
	}
}

void
rde_rib_free(struct rib_desc *rd)
{
	/* abort pending rib_dumps */
	rde_dump_rib_free(&rd->rib);
	rde_dump_mrt_free(&rd->rib);

	rib_free(&rd->rib);
}

/*
 * kroute specific functions
 */
int
rde_rdomain_import(struct rde_aspath *asp, struct rdomain *rd)
{
	struct filter_set	*s;

	TAILQ_FOREACH(s, &rd->import, entry) {
		if (community_ext_match(asp, &s->action.ext_community, 0))
			return (1);
	}
	return (0);
}

void
rde_send_kroute(struct rib *rib, struct prefix *new, struct prefix *old)
{
	struct kroute_full	 kr;
	struct bgpd_addr	 addr;
	struct prefix		*p;
	struct rdomain		*rd;
	enum imsg_type		 type;

	/*
	 * Make sure that self announce prefixes are not committed to the
	 * FIB. If both prefixes are unreachable no update is needed.
	 */
	if ((old == NULL || old->aspath->flags & F_PREFIX_ANNOUNCED) &&
	    (new == NULL || new->aspath->flags & F_PREFIX_ANNOUNCED))
		return;

	if (new == NULL || new->aspath->flags & F_PREFIX_ANNOUNCED) {
		type = IMSG_KROUTE_DELETE;
		p = old;
	} else {
		type = IMSG_KROUTE_CHANGE;
		p = new;
	}

	pt_getaddr(p->prefix, &addr);
	bzero(&kr, sizeof(kr));
	memcpy(&kr.prefix, &addr, sizeof(kr.prefix));
	kr.prefixlen = p->prefix->prefixlen;
	if (p->aspath->flags & F_NEXTHOP_REJECT)
		kr.flags |= F_REJECT;
	if (p->aspath->flags & F_NEXTHOP_BLACKHOLE)
		kr.flags |= F_BLACKHOLE;
	if (type == IMSG_KROUTE_CHANGE)
		memcpy(&kr.nexthop, &p->aspath->nexthop->true_nexthop,
		    sizeof(kr.nexthop));
	strlcpy(kr.label, rtlabel_id2name(p->aspath->rtlabelid),
	    sizeof(kr.label));

	switch (addr.aid) {
	case AID_VPN_IPv4:
		if (rib->flags & F_RIB_LOCAL)
			/* not Loc-RIB, no update for VPNs */
			break;

		SIMPLEQ_FOREACH(rd, rdomains_l, entry) {
			if (!rde_rdomain_import(p->aspath, rd))
				continue;
			/* must send exit_nexthop so that correct MPLS tunnel
			 * is chosen
			 */
			if (type == IMSG_KROUTE_CHANGE)
				memcpy(&kr.nexthop,
				    &p->aspath->nexthop->exit_nexthop,
				    sizeof(kr.nexthop));
			if (imsg_compose(ibuf_main, type, rd->rtableid, 0, -1,
			    &kr, sizeof(kr)) == -1)
				fatal("%s %d imsg_compose error", __func__,
				    __LINE__);
		}
		break;
	default:
		if (imsg_compose(ibuf_main, type, rib->rtableid, 0, -1,
		    &kr, sizeof(kr)) == -1)
			fatal("%s %d imsg_compose error", __func__, __LINE__);
		break;
	}
}

/*
 * update specific functions
 */
void
rde_generate_updates(struct rib *rib, struct prefix *new, struct prefix *old)
{
	struct rde_peer			*peer;

	/*
	 * If old is != NULL we know it was active and should be removed.
	 * If new is != NULL we know it is reachable and then we should
	 * generate an update.
	 */
	if (old == NULL && new == NULL)
		return;

	LIST_FOREACH(peer, &peerlist, peer_l) {
		if (peer->conf.id == 0)
			continue;
		if (peer->rib != rib)
			continue;
		if (peer->state != PEER_UP)
			continue;
		up_generate_updates(out_rules, peer, new, old);
	}
}

u_char	queue_buf[4096];

void
rde_up_dump_upcall(struct rib_entry *re, void *ptr)
{
	struct rde_peer		*peer = ptr;

	if (re_rib(re) != peer->rib)
		fatalx("King Bula: monstrous evil horror.");
	if (re->active == NULL)
		return;
	up_generate_updates(out_rules, peer, re->active, NULL);
}

void
rde_update_queue_runner(void)
{
	struct rde_peer		*peer;
	int			 r, sent, max = RDE_RUNNER_ROUNDS, eor = 0;
	u_int16_t		 len, wd_len, wpos;

	len = sizeof(queue_buf) - MSGSIZE_HEADER;
	do {
		sent = 0;
		LIST_FOREACH(peer, &peerlist, peer_l) {
			if (peer->conf.id == 0)
				continue;
			if (peer->state != PEER_UP)
				continue;
			/* first withdraws */
			wpos = 2; /* reserve space for the length field */
			r = up_dump_prefix(queue_buf + wpos, len - wpos - 2,
			    &peer->withdraws[AID_INET], peer);
			wd_len = r;
			/* write withdraws length filed */
			wd_len = htons(wd_len);
			memcpy(queue_buf, &wd_len, 2);
			wpos += r;

			/* now bgp path attributes */
			r = up_dump_attrnlri(queue_buf + wpos, len - wpos,
			    peer);
			switch (r) {
			case -1:
				eor = 1;
				if (wd_len == 0) {
					/* no withdraws queued just send EoR */
					peer_send_eor(peer, AID_INET);
					continue;
				}
				break;
			case 2:
				if (wd_len == 0) {
					/*
					 * No packet to send. No withdraws and
					 * no path attributes. Skip.
					 */
					continue;
				}
				/* FALLTHROUGH */
			default:
				wpos += r;
				break;
			}

			/* finally send message to SE */
			if (imsg_compose(ibuf_se, IMSG_UPDATE, peer->conf.id,
			    0, -1, queue_buf, wpos) == -1)
				fatal("%s %d imsg_compose error", __func__,
				    __LINE__);
			sent++;
			if (eor) {
				eor = 0;
				peer_send_eor(peer, AID_INET);
			}
		}
		max -= sent;
	} while (sent != 0 && max > 0);
}

void
rde_update6_queue_runner(u_int8_t aid)
{
	struct rde_peer		*peer;
	u_char			*b;
	int			 r, sent, max = RDE_RUNNER_ROUNDS / 2;
	u_int16_t		 len;

	/* first withdraws ... */
	do {
		sent = 0;
		LIST_FOREACH(peer, &peerlist, peer_l) {
			if (peer->conf.id == 0)
				continue;
			if (peer->state != PEER_UP)
				continue;
			len = sizeof(queue_buf) - MSGSIZE_HEADER;
			b = up_dump_mp_unreach(queue_buf, &len, peer, aid);

			if (b == NULL)
				continue;
			/* finally send message to SE */
			if (imsg_compose(ibuf_se, IMSG_UPDATE, peer->conf.id,
			    0, -1, b, len) == -1)
				fatal("%s %d imsg_compose error", __func__,
				    __LINE__);
			sent++;
		}
		max -= sent;
	} while (sent != 0 && max > 0);

	/* ... then updates */
	max = RDE_RUNNER_ROUNDS / 2;
	do {
		sent = 0;
		LIST_FOREACH(peer, &peerlist, peer_l) {
			if (peer->conf.id == 0)
				continue;
			if (peer->state != PEER_UP)
				continue;
			len = sizeof(queue_buf) - MSGSIZE_HEADER;
			r = up_dump_mp_reach(queue_buf, &len, peer, aid);
			switch (r) {
			case -2:
				continue;
			case -1:
				peer_send_eor(peer, aid);
				continue;
			default:
				b = queue_buf + r;
				break;
			}

			/* finally send message to SE */
			if (imsg_compose(ibuf_se, IMSG_UPDATE, peer->conf.id,
			    0, -1, b, len) == -1)
				fatal("%s %d imsg_compose error", __func__,
				    __LINE__);
			sent++;
		}
		max -= sent;
	} while (sent != 0 && max > 0);
}

/*
 * pf table specific functions
 */
void
rde_send_pftable(u_int16_t id, struct bgpd_addr *addr,
    u_int8_t len, int del)
{
	struct pftable_msg pfm;

	if (id == 0)
		return;

	/* do not run while cleaning up */
	if (rde_quit)
		return;

	bzero(&pfm, sizeof(pfm));
	strlcpy(pfm.pftable, pftable_id2name(id), sizeof(pfm.pftable));
	memcpy(&pfm.addr, addr, sizeof(pfm.addr));
	pfm.len = len;

	if (imsg_compose(ibuf_main,
	    del ? IMSG_PFTABLE_REMOVE : IMSG_PFTABLE_ADD,
	    0, 0, -1, &pfm, sizeof(pfm)) == -1)
		fatal("%s %d imsg_compose error", __func__, __LINE__);
}

void
rde_send_pftable_commit(void)
{
	/* do not run while cleaning up */
	if (rde_quit)
		return;

	if (imsg_compose(ibuf_main, IMSG_PFTABLE_COMMIT, 0, 0, -1, NULL, 0) ==
	    -1)
		fatal("%s %d imsg_compose error", __func__, __LINE__);
}

/*
 * nexthop specific functions
 */
void
rde_send_nexthop(struct bgpd_addr *next, int valid)
{
	int			 type;

	if (valid)
		type = IMSG_NEXTHOP_ADD;
	else
		type = IMSG_NEXTHOP_REMOVE;

	if (imsg_compose(ibuf_main, type, 0, 0, -1, next,
	    sizeof(struct bgpd_addr)) == -1)
		fatal("%s %d imsg_compose error", __func__, __LINE__);
}

/*
 * soft reconfig specific functions
 */
void
rde_reload_done(void)
{
	struct rdomain		*rd;
	struct rde_peer		*peer;
	struct filter_head	*fh;
	u_int16_t		 rid;

	/* first merge the main config */
	if ((nconf->flags & BGPD_FLAG_NO_EVALUATE)
	    != (conf->flags & BGPD_FLAG_NO_EVALUATE)) {
		log_warnx("change to/from route-collector "
		    "mode ignored");
		if (conf->flags & BGPD_FLAG_NO_EVALUATE)
			nconf->flags |= BGPD_FLAG_NO_EVALUATE;
		else
			nconf->flags &= ~BGPD_FLAG_NO_EVALUATE;
	}
	memcpy(conf, nconf, sizeof(struct bgpd_config));
	conf->listen_addrs = NULL;
	conf->csock = NULL;
	conf->rcsock = NULL;
	free(nconf);
	nconf = NULL;

	/* sync peerself with conf */
	peerself->remote_bgpid = ntohl(conf->bgpid);
	peerself->conf.local_as = conf->as;
	peerself->conf.remote_as = conf->as;
	peerself->short_as = conf->short_as;

	/* apply new set of rdomain, sync will be done later */
	while ((rd = SIMPLEQ_FIRST(rdomains_l)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(rdomains_l, entry);
		filterset_free(&rd->import);
		filterset_free(&rd->export);
		free(rd);
	}
	free(rdomains_l);
	rdomains_l = newdomains;
	/* XXX WHERE IS THE SYNC ??? */

	rde_filter_calc_skip_steps(out_rules_tmp);

	/*
	 * make the new filter rules the active one but keep the old for
	 * softrconfig. This is needed so that changes happening are using
	 * the right filters.
	 */
	fh = out_rules;
	out_rules = out_rules_tmp;
	out_rules_tmp = fh;

	/* check if filter changed */
	LIST_FOREACH(peer, &peerlist, peer_l) {
		if (peer->conf.id == 0)
			continue;
		peer->reconf_out = 0;
		peer->reconf_rib = 0;
		if (peer->rib != rib_find(peer->conf.rib)) {
			rib_dump(peer->rib, rde_softreconfig_unload_peer, peer,
			    AID_UNSPEC);
			peer->rib = rib_find(peer->conf.rib);
			if (peer->rib == NULL)
				fatalx("King Bula's peer met an unknown RIB");
			peer->reconf_rib = 1;
			continue;
		}
		if (!rde_filter_equal(out_rules, out_rules_tmp, peer)) {
			peer->reconf_out = 1;
		}
	}
	/* bring ribs in sync */
	for (rid = 0; rid < rib_size; rid++) {
		if (*ribs[rid].name == '\0')
			continue;
		rde_filter_calc_skip_steps(ribs[rid].in_rules_tmp);

		/* flip rules, make new active */
		fh = ribs[rid].in_rules;
		ribs[rid].in_rules = ribs[rid].in_rules_tmp;
		ribs[rid].in_rules_tmp = fh;

		switch (ribs[rid].state) {
		case RECONF_DELETE:
			rde_rib_free(&ribs[rid]);
			break;
		case RECONF_KEEP:
			if (rde_filter_equal(ribs[rid].in_rules,
			    ribs[rid].in_rules_tmp, NULL))
				/* rib is in sync */
				break;
			ribs[rid].state = RECONF_RELOAD;
			/* FALLTHROUGH */
		case RECONF_REINIT:
			rib_dump(&ribs[0].rib, rde_softreconfig_in, &ribs[rid],
			    AID_UNSPEC);
			break;
		case RECONF_RELOAD:
			log_warnx("Bad rib reload state");
			/* FALLTHROUGH */
		case RECONF_NONE:
			break;
		}
	}
	LIST_FOREACH(peer, &peerlist, peer_l) {
		if (peer->reconf_out)
			rib_dump(peer->rib, rde_softreconfig_out,
			    peer, AID_UNSPEC);
		else if (peer->reconf_rib)
			/* dump the full table to neighbors that changed rib */
			peer_dump(peer->conf.id, AID_UNSPEC);
	}
	filterlist_free(out_rules_tmp);
	out_rules_tmp = NULL;
	for (rid = 0; rid < rib_size; rid++) {
		if (*ribs[rid].name == '\0')
			continue;
		filterlist_free(ribs[rid].in_rules_tmp);
		ribs[rid].in_rules_tmp = NULL;
		ribs[rid].state = RECONF_NONE;
	}

	log_info("RDE reconfigured");
	imsg_compose(ibuf_main, IMSG_RECONF_DONE, 0, 0,
	    -1, NULL, 0);
}

void
rde_softreconfig_in(struct rib_entry *re, void *ptr)
{
	struct rib_desc		*rib = ptr;
	struct prefix		*p, *np;
	struct pt_entry		*pt;
	struct rde_peer		*peer;
	struct rde_aspath	*asp, *oasp, *nasp;
	enum filter_actions	 oa, na;
	struct bgpd_addr	 addr;

	pt = re->prefix;
	pt_getaddr(pt, &addr);
	for (p = LIST_FIRST(&re->prefix_h); p != NULL; p = np) {
		/*
		 * prefix_remove() and path_update() may change the object
		 * so cache the values.
		 */
		np = LIST_NEXT(p, rib_l);
		asp = p->aspath;
		peer = asp->peer;

		/* check if prefix changed */
		if (rib->state == RECONF_RELOAD) {
			oa = rde_filter(rib->in_rules_tmp, &oasp, peer,
			    asp, &addr, pt->prefixlen, peer);
			oasp = oasp != NULL ? oasp : asp;
		} else {
			/* make sure we update everything for RECONF_REINIT */
			oa = ACTION_DENY;
			oasp = asp;
		}
		na = rde_filter(rib->in_rules, &nasp, peer, asp,
		    &addr, pt->prefixlen, peer);
		nasp = nasp != NULL ? nasp : asp;

		/* go through all 4 possible combinations */
		/* if (oa == ACTION_DENY && na == ACTION_DENY) */
			/* nothing todo */
		if (oa == ACTION_DENY && na == ACTION_ALLOW) {
			/* update Local-RIB */
			path_update(&rib->rib, peer, nasp, &addr,
			    pt->prefixlen);
		} else if (oa == ACTION_ALLOW && na == ACTION_DENY) {
			/* remove from Local-RIB */
			prefix_remove(&rib->rib, peer, &addr, pt->prefixlen, 0);
		} else if (oa == ACTION_ALLOW && na == ACTION_ALLOW) {
			if (path_compare(nasp, oasp) != 0)
				/* send update */
				path_update(&rib->rib, peer, nasp, &addr,
				    pt->prefixlen);
		}

		if (oasp != asp)
			path_put(oasp);
		if (nasp != asp)
			path_put(nasp);
	}
}

void
rde_softreconfig_out(struct rib_entry *re, void *ptr)
{
	struct prefix		*p = re->active;
	struct pt_entry		*pt;
	struct rde_peer		*peer = ptr;
	struct rde_aspath	*oasp, *nasp;
	enum filter_actions	 oa, na;
	struct bgpd_addr	 addr;

	if (peer->conf.id == 0)
		fatalx("King Bula troubled by bad peer");

	if (p == NULL)
		return;

	pt = re->prefix;
	pt_getaddr(pt, &addr);

	if (up_test_update(peer, p) != 1)
		return;

	oa = rde_filter(out_rules_tmp, &oasp, peer, p->aspath,
	    &addr, pt->prefixlen, p->aspath->peer);
	na = rde_filter(out_rules, &nasp, peer, p->aspath,
	    &addr, pt->prefixlen, p->aspath->peer);
	oasp = oasp != NULL ? oasp : p->aspath;
	nasp = nasp != NULL ? nasp : p->aspath;

	/* go through all 4 possible combinations */
	/* if (oa == ACTION_DENY && na == ACTION_DENY) */
		/* nothing todo */
	if (oa == ACTION_DENY && na == ACTION_ALLOW) {
		/* send update */
		up_generate(peer, nasp, &addr, pt->prefixlen);
	} else if (oa == ACTION_ALLOW && na == ACTION_DENY) {
		/* send withdraw */
		up_generate(peer, NULL, &addr, pt->prefixlen);
	} else if (oa == ACTION_ALLOW && na == ACTION_ALLOW) {
		/* send update if path attributes changed */
		if (path_compare(nasp, oasp) != 0)
			up_generate(peer, nasp, &addr, pt->prefixlen);
	}

	if (oasp != p->aspath)
		path_put(oasp);
	if (nasp != p->aspath)
		path_put(nasp);
}

void
rde_softreconfig_unload_peer(struct rib_entry *re, void *ptr)
{
	struct rde_peer		*peer = ptr;
	struct prefix		*p = re->active;
	struct pt_entry		*pt;
	struct rde_aspath	*oasp;
	enum filter_actions	 oa;
	struct bgpd_addr	 addr;

	pt = re->prefix;
	pt_getaddr(pt, &addr);

	/* check if prefix was announced */
	if (up_test_update(peer, p) != 1)
		return;

	oa = rde_filter(out_rules_tmp, &oasp, peer, p->aspath,
	    &addr, pt->prefixlen, p->aspath->peer);
	oasp = oasp != NULL ? oasp : p->aspath;

	if (oa == ACTION_DENY)
		/* nothing todo */
		goto done;

	/* send withdraw */
	up_generate(peer, NULL, &addr, pt->prefixlen);
done:
	if (oasp != p->aspath)
		path_put(oasp);
}

/*
 * generic helper function
 */
u_int32_t
rde_local_as(void)
{
	return (conf->as);
}

int
rde_noevaluate(void)
{
	/* do not run while cleaning up */
	if (rde_quit)
		return (1);

	return (conf->flags & BGPD_FLAG_NO_EVALUATE);
}

int
rde_decisionflags(void)
{
	return (conf->flags & BGPD_FLAG_DECISION_MASK);
}

int
rde_as4byte(struct rde_peer *peer)
{
	return (peer->capa.as4byte);
}

/*
 * peer functions
 */
struct peer_table {
	struct rde_peer_head	*peer_hashtbl;
	u_int32_t		 peer_hashmask;
} peertable;

#define PEER_HASH(x)		\
	&peertable.peer_hashtbl[(x) & peertable.peer_hashmask]

void
peer_init(u_int32_t hashsize)
{
	struct peer_config pc;
	u_int32_t	 hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	peertable.peer_hashtbl = calloc(hs, sizeof(struct rde_peer_head));
	if (peertable.peer_hashtbl == NULL)
		fatal("peer_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&peertable.peer_hashtbl[i]);
	LIST_INIT(&peerlist);

	peertable.peer_hashmask = hs - 1;

	bzero(&pc, sizeof(pc));
	snprintf(pc.descr, sizeof(pc.descr), "LOCAL");

	peerself = peer_add(0, &pc);
	if (peerself == NULL)
		fatalx("peer_init add self");

	peerself->state = PEER_UP;
}

void
peer_shutdown(void)
{
	u_int32_t	i;

	for (i = 0; i <= peertable.peer_hashmask; i++)
		if (!LIST_EMPTY(&peertable.peer_hashtbl[i]))
			log_warnx("peer_free: free non-free table");

	free(peertable.peer_hashtbl);
}

struct rde_peer *
peer_get(u_int32_t id)
{
	struct rde_peer_head	*head;
	struct rde_peer		*peer;

	head = PEER_HASH(id);

	LIST_FOREACH(peer, head, hash_l) {
		if (peer->conf.id == id)
			return (peer);
	}
	return (NULL);
}

struct rde_peer *
peer_add(u_int32_t id, struct peer_config *p_conf)
{
	struct rde_peer_head	*head;
	struct rde_peer		*peer;

	if ((peer = peer_get(id))) {
		memcpy(&peer->conf, p_conf, sizeof(struct peer_config));
		return (NULL);
	}

	peer = calloc(1, sizeof(struct rde_peer));
	if (peer == NULL)
		fatal("peer_add");

	LIST_INIT(&peer->path_h);
	memcpy(&peer->conf, p_conf, sizeof(struct peer_config));
	peer->remote_bgpid = 0;
	peer->rib = rib_find(peer->conf.rib);
	if (peer->rib == NULL)
		fatalx("King Bula's new peer met an unknown RIB");
	peer->state = PEER_NONE;
	up_init(peer);

	head = PEER_HASH(id);

	LIST_INSERT_HEAD(head, peer, hash_l);
	LIST_INSERT_HEAD(&peerlist, peer, peer_l);

	return (peer);
}

int
peer_localaddrs(struct rde_peer *peer, struct bgpd_addr *laddr)
{
	struct ifaddrs	*ifap, *ifa, *match;

	if (getifaddrs(&ifap) == -1)
		fatal("getifaddrs");

	for (match = ifap; match != NULL; match = match->ifa_next)
		if (sa_cmp(laddr, match->ifa_addr) == 0)
			break;

	if (match == NULL) {
		log_warnx("peer_localaddrs: local address not found");
		return (-1);
	}

	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family == AF_INET &&
		    strcmp(ifa->ifa_name, match->ifa_name) == 0) {
			if (ifa->ifa_addr->sa_family ==
			    match->ifa_addr->sa_family)
				ifa = match;
			sa2addr(ifa->ifa_addr, &peer->local_v4_addr);
			break;
		}
	}
	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family == AF_INET6 &&
		    strcmp(ifa->ifa_name, match->ifa_name) == 0) {
			/*
			 * only accept global scope addresses except explicitly
			 * specified.
			 */
			if (ifa->ifa_addr->sa_family ==
			    match->ifa_addr->sa_family)
				ifa = match;
			else if (IN6_IS_ADDR_LINKLOCAL(
			    &((struct sockaddr_in6 *)ifa->
			    ifa_addr)->sin6_addr) ||
			    IN6_IS_ADDR_SITELOCAL(
			    &((struct sockaddr_in6 *)ifa->
			    ifa_addr)->sin6_addr))
				continue;
			sa2addr(ifa->ifa_addr, &peer->local_v6_addr);
			break;
		}
	}

	freeifaddrs(ifap);
	return (0);
}

void
peer_up(u_int32_t id, struct session_up *sup)
{
	struct rde_peer	*peer;
	u_int8_t	 i;

	peer = peer_get(id);
	if (peer == NULL) {
		log_warnx("peer_up: unknown peer id %d", id);
		return;
	}

	if (peer->state != PEER_DOWN && peer->state != PEER_NONE &&
	    peer->state != PEER_UP) {
		/*
		 * There is a race condition when doing PEER_ERR -> PEER_DOWN.
		 * So just do a full reset of the peer here.
		 */
		for (i = 0; i < AID_MAX; i++) {
			peer->staletime[i] = 0;
			peer_flush(peer, i);
		}
		up_down(peer);
		peer->prefix_cnt = 0;
		peer->state = PEER_DOWN;
	}
	peer->remote_bgpid = ntohl(sup->remote_bgpid);
	peer->short_as = sup->short_as;
	memcpy(&peer->remote_addr, &sup->remote_addr,
	    sizeof(peer->remote_addr));
	memcpy(&peer->capa, &sup->capa, sizeof(peer->capa));

	if (peer_localaddrs(peer, &sup->local_addr)) {
		peer->state = PEER_DOWN;
		imsg_compose(ibuf_se, IMSG_SESSION_DOWN, id, 0, -1, NULL, 0);
		return;
	}

	peer->state = PEER_UP;
	up_init(peer);

	if (rde_noevaluate())
		/*
		 * no need to dump the table to the peer, there are no active
		 * prefixes anyway. This is a speed up hack.
		 */
		return;

	for (i = 0; i < AID_MAX; i++) {
		if (peer->capa.mp[i])
			peer_dump(id, i);
	}
}

void
peer_down(u_int32_t id)
{
	struct rde_peer		*peer;
	struct rde_aspath	*asp, *nasp;

	peer = peer_get(id);
	if (peer == NULL) {
		log_warnx("peer_down: unknown peer id %d", id);
		return;
	}
	peer->remote_bgpid = 0;
	peer->state = PEER_DOWN;
	up_down(peer);

	/* walk through per peer RIB list and remove all prefixes. */
	for (asp = LIST_FIRST(&peer->path_h); asp != NULL; asp = nasp) {
		nasp = LIST_NEXT(asp, peer_l);
		path_remove(asp);
	}
	LIST_INIT(&peer->path_h);
	peer->prefix_cnt = 0;

	/* Deletions are performed in path_remove() */
	rde_send_pftable_commit();

	LIST_REMOVE(peer, hash_l);
	LIST_REMOVE(peer, peer_l);
	free(peer);
}

/*
 * Flush all routes older then staletime. If staletime is 0 all routes will
 * be flushed.
 */
void
peer_flush(struct rde_peer *peer, u_int8_t aid)
{
	struct rde_aspath	*asp, *nasp;
	u_int32_t		 rprefixes;

	rprefixes = 0;
	/* walk through per peer RIB list and remove all stale prefixes. */
	for (asp = LIST_FIRST(&peer->path_h); asp != NULL; asp = nasp) {
		nasp = LIST_NEXT(asp, peer_l);
		rprefixes += path_remove_stale(asp, aid);
	}

	/* Deletions are performed in path_remove() */
	rde_send_pftable_commit();

	/* flushed no need to keep staletime */
	peer->staletime[aid] = 0;

	if (peer->prefix_cnt > rprefixes)
		peer->prefix_cnt -= rprefixes;
	else
		peer->prefix_cnt = 0;
}

void
peer_stale(u_int32_t id, u_int8_t aid)
{
	struct rde_peer		*peer;
	time_t			 now;

	peer = peer_get(id);
	if (peer == NULL) {
		log_warnx("peer_stale: unknown peer id %d", id);
		return;
	}

	/* flush the now even staler routes out */
	if (peer->staletime[aid])
		peer_flush(peer, aid);
	peer->staletime[aid] = now = time(NULL);

	/* make sure new prefixes start on a higher timestamp */
	do {
		sleep(1);
	} while (now >= time(NULL));
}

void
peer_dump(u_int32_t id, u_int8_t aid)
{
	struct rde_peer		*peer;

	peer = peer_get(id);
	if (peer == NULL) {
		log_warnx("peer_dump: unknown peer id %d", id);
		return;
	}

	if (peer->conf.announce_type == ANNOUNCE_DEFAULT_ROUTE)
		up_generate_default(out_rules, peer, aid);
	else
		rib_dump(peer->rib, rde_up_dump_upcall, peer, aid);
	if (peer->capa.grestart.restart)
		up_generate_marker(peer, aid);
}

/* End-of-RIB marker, RFC 4724 */
void
peer_recv_eor(struct rde_peer *peer, u_int8_t aid)
{
	peer->prefix_rcvd_eor++;

	/*
	 * First notify SE to avert a possible race with the restart timeout.
	 * If the timeout fires before this imsg is processed by the SE it will
	 * result in the same operation since the timeout issues a FLUSH which
	 * does the same as the RESTARTED action (flushing stale routes).
	 * The logic in the SE is so that only one of FLUSH or RESTARTED will
	 * be sent back to the RDE and so peer_flush is only called once.
	 */
	if (imsg_compose(ibuf_se, IMSG_SESSION_RESTARTED, peer->conf.id,
	    0, -1, &aid, sizeof(aid)) == -1)
		fatal("%s %d imsg_compose error", __func__, __LINE__);

	log_peer_info(&peer->conf, "received %s EOR marker",
	    aid2str(aid));
}

void
peer_send_eor(struct rde_peer *peer, u_int8_t aid)
{
	u_int16_t	afi;
	u_int8_t	safi;

	peer->prefix_sent_eor++;

	if (aid == AID_INET) {
		u_char null[4];

		bzero(&null, 4);
		if (imsg_compose(ibuf_se, IMSG_UPDATE, peer->conf.id,
		    0, -1, &null, 4) == -1)
			fatal("%s %d imsg_compose error in peer_send_eor",
			    __func__, __LINE__);
	} else {
		u_int16_t	i;
		u_char		buf[10];

		if (aid2afi(aid, &afi, &safi) == -1)
			fatalx("peer_send_eor: bad AID");

		i = 0;	/* v4 withdrawn len */
		bcopy(&i, &buf[0], sizeof(i));
		i = htons(6);	/* path attr len */
		bcopy(&i, &buf[2], sizeof(i));
		buf[4] = ATTR_OPTIONAL;
		buf[5] = ATTR_MP_UNREACH_NLRI;
		buf[6] = 3;	/* withdrawn len */
		i = htons(afi);
		bcopy(&i, &buf[7], sizeof(i));
		buf[9] = safi;

		if (imsg_compose(ibuf_se, IMSG_UPDATE, peer->conf.id,
		    0, -1, &buf, 10) == -1)
			fatal("%s %d imsg_compose error in peer_send_eor",
			    __func__, __LINE__);
	}

	log_peer_info(&peer->conf, "sending %s EOR marker",
	    aid2str(aid));
}

/*
 * network announcement stuff
 */
void
network_add(struct network_config *nc, int flagstatic)
{
	struct rdomain		*rd;
	struct rde_aspath	*asp;
	struct filter_set_head	*vpnset = NULL;
	in_addr_t		 prefix4;
	u_int16_t		 i;

	if (nc->rtableid) {
		SIMPLEQ_FOREACH(rd, rdomains_l, entry) {
			if (rd->rtableid != nc->rtableid)
				continue;
			switch (nc->prefix.aid) {
			case AID_INET:
				prefix4 = nc->prefix.v4.s_addr;
				bzero(&nc->prefix, sizeof(nc->prefix));
				nc->prefix.aid = AID_VPN_IPv4;
				nc->prefix.vpn4.rd = rd->rd;
				nc->prefix.vpn4.addr.s_addr = prefix4;
				nc->prefix.vpn4.labellen = 3;
				nc->prefix.vpn4.labelstack[0] =
				    (rd->label >> 12) & 0xff;
				nc->prefix.vpn4.labelstack[1] =
				    (rd->label >> 4) & 0xff;
				nc->prefix.vpn4.labelstack[2] =
				    (rd->label << 4) & 0xf0;
				nc->prefix.vpn4.labelstack[2] |= BGP_MPLS_BOS;
				vpnset = &rd->export;
				break;
			default:
				log_warnx("unable to VPNize prefix");
				filterset_free(&nc->attrset);
				return;
			}
			break;
		}
		if (rd == NULL) {
			log_warnx("network_add: "
			    "prefix %s/%u in non-existing rdomain %u",
			    log_addr(&nc->prefix), nc->prefixlen, nc->rtableid);
			return;
		}
	}

	if (nc->type == NETWORK_MRTCLONE) {
		asp = nc->asp;
	} else {
		asp = path_get();
		asp->aspath = aspath_get(NULL, 0);
		asp->origin = ORIGIN_IGP;
		asp->flags = F_ATTR_ORIGIN | F_ATTR_ASPATH |
		    F_ATTR_LOCALPREF | F_PREFIX_ANNOUNCED;
		/* the nexthop is unset unless a default set overrides it */
	}
	if (!flagstatic)
		asp->flags |= F_ANN_DYNAMIC;
	rde_apply_set(asp, &nc->attrset, nc->prefix.aid, peerself, peerself);
	if (vpnset)
		rde_apply_set(asp, vpnset, nc->prefix.aid, peerself, peerself);
	for (i = 1; i < rib_size; i++) {
		if (*ribs[i].name == '\0')
			break;
		path_update(&ribs[i].rib, peerself, asp, &nc->prefix,
		    nc->prefixlen);
	}
	path_put(asp);
	filterset_free(&nc->attrset);
}

void
network_delete(struct network_config *nc, int flagstatic)
{
	struct rdomain	*rd;
	in_addr_t	 prefix4;
	u_int32_t	 flags = F_PREFIX_ANNOUNCED;
	u_int32_t	 i;

	if (!flagstatic)
		flags |= F_ANN_DYNAMIC;

	if (nc->rtableid) {
		SIMPLEQ_FOREACH(rd, rdomains_l, entry) {
			if (rd->rtableid != nc->rtableid)
				continue;
			switch (nc->prefix.aid) {
			case AID_INET:
				prefix4 = nc->prefix.v4.s_addr;
				bzero(&nc->prefix, sizeof(nc->prefix));
				nc->prefix.aid = AID_VPN_IPv4;
				nc->prefix.vpn4.rd = rd->rd;
				nc->prefix.vpn4.addr.s_addr = prefix4;
				nc->prefix.vpn4.labellen = 3;
				nc->prefix.vpn4.labelstack[0] =
				    (rd->label >> 12) & 0xff;
				nc->prefix.vpn4.labelstack[1] =
				    (rd->label >> 4) & 0xff;
				nc->prefix.vpn4.labelstack[2] =
				    (rd->label << 4) & 0xf0;
				nc->prefix.vpn4.labelstack[2] |= BGP_MPLS_BOS;
				break;
			default:
				log_warnx("unable to VPNize prefix");
				return;
			}
		}
	}

	for (i = 1; i < rib_size; i++) {
		if (*ribs[i].name == '\0')
			break;
		prefix_remove(&ribs[i].rib, peerself, &nc->prefix,
		    nc->prefixlen, flags);
	}
}

void
network_dump_upcall(struct rib_entry *re, void *ptr)
{
	struct prefix		*p;
	struct kroute_full	 k;
	struct bgpd_addr	 addr;
	struct rde_dump_ctx	*ctx = ptr;

	LIST_FOREACH(p, &re->prefix_h, rib_l) {
		if (!(p->aspath->flags & F_PREFIX_ANNOUNCED))
			continue;
		pt_getaddr(p->prefix, &addr);

		bzero(&k, sizeof(k));
		memcpy(&k.prefix, &addr, sizeof(k.prefix));
		if (p->aspath->nexthop == NULL ||
		    p->aspath->nexthop->state != NEXTHOP_REACH)
			k.nexthop.aid = k.prefix.aid;
		else
			memcpy(&k.nexthop, &p->aspath->nexthop->true_nexthop,
			    sizeof(k.nexthop));
		k.prefixlen = p->prefix->prefixlen;
		k.flags = F_KERNEL;
		if ((p->aspath->flags & F_ANN_DYNAMIC) == 0)
			k.flags = F_STATIC;
		if (imsg_compose(ibuf_se_ctl, IMSG_CTL_SHOW_NETWORK, 0,
		    ctx->req.pid, -1, &k, sizeof(k)) == -1)
			log_warnx("network_dump_upcall: "
			    "imsg_compose error");
	}
}

/* clean up */
void
rde_shutdown(void)
{
	struct rde_peer		*p;
	u_int32_t		 i;

	/*
	 * the decision process is turned off if rde_quit = 1 and
	 * rde_shutdown depends on this.
	 */

	/*
	 * All peers go down
	 */
	for (i = 0; i <= peertable.peer_hashmask; i++)
		while ((p = LIST_FIRST(&peertable.peer_hashtbl[i])) != NULL)
			peer_down(p->conf.id);

	/* free filters */
	filterlist_free(out_rules);
	for (i = 0; i < rib_size; i++) {
		if (*ribs[i].name == '\0')
			break;
		filterlist_free(ribs[i].in_rules);
	}

	nexthop_shutdown();
	path_shutdown();
	aspath_shutdown();
	attr_shutdown();
	pt_shutdown();
	peer_shutdown();
}

int
sa_cmp(struct bgpd_addr *a, struct sockaddr *b)
{
	struct sockaddr_in	*in_b;
	struct sockaddr_in6	*in6_b;

	if (aid2af(a->aid) != b->sa_family)
		return (1);

	switch (b->sa_family) {
	case AF_INET:
		in_b = (struct sockaddr_in *)b;
		if (a->v4.s_addr != in_b->sin_addr.s_addr)
			return (1);
		break;
	case AF_INET6:
		in6_b = (struct sockaddr_in6 *)b;
#ifdef __KAME__
		/* directly stolen from sbin/ifconfig/ifconfig.c */
		if (IN6_IS_ADDR_LINKLOCAL(&in6_b->sin6_addr)) {
			in6_b->sin6_scope_id =
			    ntohs(*(u_int16_t *)&in6_b->sin6_addr.s6_addr[2]);
			in6_b->sin6_addr.s6_addr[2] =
			    in6_b->sin6_addr.s6_addr[3] = 0;
		}
#endif
		if (bcmp(&a->v6, &in6_b->sin6_addr,
		    sizeof(struct in6_addr)))
			return (1);
		break;
	default:
		fatal("king bula sez: unknown address family");
		/* NOTREACHED */
	}

	return (0);
}
@


1.371
log
@softreconfig in and out are on by default for ever and machines now have
enough memory that it does not make sense to provide these knobs anymore.
They just make the code more complex for no much gain.
OK phessler@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.370 2017/08/10 15:44:09 benno Exp $ */
d1333 2
a1334 2
	path_update(&ribs[0].rib, peer, asp, prefix, prefixlen);
	peer->prefix_cnt++;
@


1.370
log
@Fix a comment and line length. Noted by Dennis fondras.
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.369 2017/08/10 14:12:34 benno Exp $ */
a1328 1
	int			 r = 0, f = 0;
d1333 2
a1334 2
	if (peer->conf.softreconfig_in)
		r += path_update(&ribs[0].rib, peer, asp, prefix, prefixlen);
d1349 1
a1349 1
			r += path_update(&ribs[i].rib, peer, fasp, prefix,
a1354 1
			f++;
a1360 5

	if (r)
		peer->prefix_cnt++;
	else if (f)
		peer->prefix_cnt--;
a1366 1
	int r = 0;
d1369 1
a1369 3
	peer->prefix_rcvd_withdraw++;

	for (i = rib_size - 1; ; i--) {
a1374 1
			r++;
a1375 2
		if (i == 0)
			break;
d1378 2
a1379 1
	if (r)
d1381 2
d2933 1
a2933 2
		if (peer->conf.softreconfig_out &&
		    !rde_filter_equal(out_rules, out_rules_tmp, peer)) {
d3650 1
a3650 1
	for (i = rib_size - 1; i > 0; i--) {
@


1.369
log
@handle extended communities in bgpctl.
From Dennis Fondras, thanks!
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.368 2017/05/29 13:10:40 claudio Exp $ */
a215 1
	/* initialize the RIB structures */
d220 1
d1172 2
a1173 1
			    " (>%u/%u)", peer->prefix_cnt, peer->conf.max_prefix);
@


1.368
log
@After some consideration, revert last commit and don't abuse rde_dump_done.
IMSG_CTL_SHOW_RIB_PREFIX case is not using rib_dump_r and so should not use
rde_dump_done, instead send the IMSG_CTL_END msg and free the ctx directly.
This is easier to understand.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.367 2017/05/29 12:48:11 claudio Exp $ */
d574 1
d2312 3
d2401 1
@


1.367
log
@Fix crash in IMSG_CTL_SHOW_RIB_PREFIX handling. The ctx is not added to
the list in that case so don't try to LIST_REMOVE it.
Problem found by benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.366 2017/05/28 20:15:02 claudio Exp $ */
d2422 3
a2424 1
		rde_dump_done(ctx);
d2481 1
a2481 6
	/*
	 * ctx is not linked for IMSG_CTL_SHOW_RIB_PREFIX because it
	 * does not need to use rib_dump_r
	 */
	if (ctx->req.type != IMSG_CTL_SHOW_RIB_PREFIX)
		LIST_REMOVE(ctx, entry);
@


1.366
log
@Print when we send or recv an EOR marker.
Req by and OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.365 2017/05/28 20:10:59 claudio Exp $ */
d2479 6
a2484 1
	LIST_REMOVE(ctx, entry);
@


1.365
log
@Close imsg pipes later in the process. The shutdown code still tires to
send imsgs and so the SE and RDE crashed because of this late in shutdown.
OK benno@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.364 2017/05/28 12:21:36 claudio Exp $ */
d3493 3
d3537 3
@


1.364
log
@Implement an XON/XOFF protocol between the RDE and the SE to throttle
per control session and peer the generation of imsg in the RDE. This
reduces the memory pressure in the SE substantially and also a bit in
the RDE. Makes the RDE more responsive for bgpctl commands.
Tested by me with 100 peers * 2000 prefixes and by phessler@@ on an AMS-IX
border router with 200+ session. Convergance time got quite a bit better.
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.363 2017/05/27 18:12:23 phessler Exp $ */
d324 4
a341 4

	/* do not clean up on shutdown on production, it takes ages. */
	if (debug)
		rde_shutdown();
@


1.363
log
@Allow an administrator to disable the bgp loop detection algorithm,
which is useful in very limited situations.

Angry dragons and grues will hunt for you, if you use it.

OK claudio@@ sthen@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.362 2017/05/27 10:33:15 phessler Exp $ */
d79 1
a79 1
void		 rde_dump_rib_as(struct prefix *, struct rde_aspath *,pid_t,
d89 4
d94 3
a96 1
void		 rde_dump_done(void *);
d140 1
d144 1
d147 2
d150 2
a152 2
	struct rib_context	ribctx;
	LIST_ENTRY(rde_mrt_ctx)	entry;
d261 1
a261 1
		if (rib_dump_pending() &&
a273 1
				LIST_REMOVE(&mctx->ribctx, entry);
d319 1
a319 1
		if (rib_dump_pending() &&
d321 1
a321 1
			rib_dump_runner();
a345 1
		LIST_REMOVE(&mctx->ribctx, entry);
d622 19
d767 1
a767 1
				rib_free(rib);
d2388 1
a2388 1
	ctx->ribctx.ctx_count = RDE_RUNNER_ROUNDS;
d2430 1
d2435 38
d2479 1
d2484 12
d2519 1
a2519 1
	ctx->ribctx.ctx_count = RDE_RUNNER_ROUNDS;
d2530 22
d2953 1
a2953 1
			rib_free(&ribs[rid].rib);
@


1.362
log
@Allow OpenBGPD to selectively choose which local ASN to use per-peer.
This is intended to be used for ASN migrations, not for permanent use.

You MUST use filters to protect yourself from receiving your own routes.
There be dragons and grues.

OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.361 2017/01/25 03:21:55 claudio Exp $ */
d1107 1
@


1.361
log
@Hopefully the last of the struct rib rototilling. Peer just points to a
struct rib and not rib_desc since the full descriptor is almost never needed.
This should now allow the update code to be changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.360 2017/01/25 00:15:38 claudio Exp $ */
d1106 2
a1107 1
	if (peer->conf.ebgp && !aspath_loopfree(asp->aspath, conf->as))
@


1.360
log
@Switch rde_generate_update and rde_send_kroute to accept a struct rib instead
of the id. For this we move the rtableid into struct rib. Also move the update
code in rib.c up to where the kroute code is. Makes more senses like that.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.359 2017/01/24 23:38:12 claudio Exp $ */
d633 1
a633 1
	struct rib_desc		*rib;
d727 3
a729 3
			else if (rib->rib.rtableid != rn.rtableid ||
			    (rib->rib.flags & F_RIB_HASNOFIB) !=
			    (rib->rib.flags & F_RIB_HASNOFIB)) {
d731 1
d738 2
a739 2
				in_rules = rib->in_rules;
				rib->in_rules = NULL;
d742 1
a742 1
				rib->in_rules = in_rules;
d744 1
a744 1
				rib->state = RECONF_KEEP;
d761 1
a761 1
			r->peer.ribid = rib->rib.id;
d764 1
a764 1
				nr = rib->in_rules_tmp;
d771 1
a771 1
					rib->in_rules_tmp = nr;
d2335 1
a2335 1
	struct rib_desc		*rib;
d2360 1
a2360 1
	ctx->ribctx.ctx_rib = &rib->rib;
d2388 1
a2388 1
			re = rib_lookup(&rib->rib, &req->prefix);
d2390 1
a2390 1
			re = rib_get(&rib->rib, &req->prefix, req->prefixlen);
d2418 1
a2418 1
	struct rib_desc		*rib;
d2439 1
a2439 1
	ctx->ribctx.ctx_rib = &rib->rib;
d2552 1
a2552 1
		if (&peer->rib->rib != rib)
d2567 1
a2567 1
	if (re_rib(re) != &peer->rib->rib)
d2824 2
a2825 2
			rib_dump(&peer->rib->rib,
			    rde_softreconfig_unload_peer, peer, AID_UNSPEC);
d2850 1
a2850 1
			rib_free(&ribs[rid]);
d2872 1
a2872 1
			rib_dump(&peer->rib->rib, rde_softreconfig_out,
d3368 1
a3368 1
		rib_dump(&peer->rib->rib, rde_up_dump_upcall, peer, aid);
@


1.359
log
@Save some space in struct rib_entry so it is back to 64bytes (on 64bit archs).
Doing this by folding the lock flag into a pointer and providing an accessor
function for the rib pointer. This is an acceptable middle path for this
important structure.
OK benno@@ on an earlier version
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.358 2017/01/24 04:22:42 benno Exp $ */
d727 1
a727 1
			else if (rib->rtableid != rn.rtableid ||
d2464 1
a2464 1
rde_send_kroute(struct prefix *new, struct prefix *old, u_int16_t ribid)
d2504 1
a2504 1
		if (ribid != 1)
d2525 1
a2525 1
		if (imsg_compose(ibuf_main, type, ribs[ribid].rtableid, 0, -1,
d2533 171
a3031 171
}

/*
 * update specific functions
 */
u_char	queue_buf[4096];

void
rde_up_dump_upcall(struct rib_entry *re, void *ptr)
{
	struct rde_peer		*peer = ptr;

	if (re_rib(re) != &peer->rib->rib)
		fatalx("King Bula: monstrous evil horror.");
	if (re->active == NULL)
		return;
	up_generate_updates(out_rules, peer, re->active, NULL);
}

void
rde_generate_updates(u_int16_t ribid, struct prefix *new, struct prefix *old)
{
	struct rde_peer			*peer;

	/*
	 * If old is != NULL we know it was active and should be removed.
	 * If new is != NULL we know it is reachable and then we should
	 * generate an update.
	 */
	if (old == NULL && new == NULL)
		return;

	LIST_FOREACH(peer, &peerlist, peer_l) {
		if (peer->conf.id == 0)
			continue;
		if (peer->rib->rib.id != ribid)
			continue;
		if (peer->state != PEER_UP)
			continue;
		up_generate_updates(out_rules, peer, new, old);
	}
}

void
rde_update_queue_runner(void)
{
	struct rde_peer		*peer;
	int			 r, sent, max = RDE_RUNNER_ROUNDS, eor = 0;
	u_int16_t		 len, wd_len, wpos;

	len = sizeof(queue_buf) - MSGSIZE_HEADER;
	do {
		sent = 0;
		LIST_FOREACH(peer, &peerlist, peer_l) {
			if (peer->conf.id == 0)
				continue;
			if (peer->state != PEER_UP)
				continue;
			/* first withdraws */
			wpos = 2; /* reserve space for the length field */
			r = up_dump_prefix(queue_buf + wpos, len - wpos - 2,
			    &peer->withdraws[AID_INET], peer);
			wd_len = r;
			/* write withdraws length filed */
			wd_len = htons(wd_len);
			memcpy(queue_buf, &wd_len, 2);
			wpos += r;

			/* now bgp path attributes */
			r = up_dump_attrnlri(queue_buf + wpos, len - wpos,
			    peer);
			switch (r) {
			case -1:
				eor = 1;
				if (wd_len == 0) {
					/* no withdraws queued just send EoR */
					peer_send_eor(peer, AID_INET);
					continue;
				}
				break;
			case 2:
				if (wd_len == 0) {
					/*
					 * No packet to send. No withdraws and
					 * no path attributes. Skip.
					 */
					continue;
				}
				/* FALLTHROUGH */
			default:
				wpos += r;
				break;
			}

			/* finally send message to SE */
			if (imsg_compose(ibuf_se, IMSG_UPDATE, peer->conf.id,
			    0, -1, queue_buf, wpos) == -1)
				fatal("%s %d imsg_compose error", __func__,
				    __LINE__);
			sent++;
			if (eor) {
				eor = 0;
				peer_send_eor(peer, AID_INET);
			}
		}
		max -= sent;
	} while (sent != 0 && max > 0);
}

void
rde_update6_queue_runner(u_int8_t aid)
{
	struct rde_peer		*peer;
	u_char			*b;
	int			 r, sent, max = RDE_RUNNER_ROUNDS / 2;
	u_int16_t		 len;

	/* first withdraws ... */
	do {
		sent = 0;
		LIST_FOREACH(peer, &peerlist, peer_l) {
			if (peer->conf.id == 0)
				continue;
			if (peer->state != PEER_UP)
				continue;
			len = sizeof(queue_buf) - MSGSIZE_HEADER;
			b = up_dump_mp_unreach(queue_buf, &len, peer, aid);

			if (b == NULL)
				continue;
			/* finally send message to SE */
			if (imsg_compose(ibuf_se, IMSG_UPDATE, peer->conf.id,
			    0, -1, b, len) == -1)
				fatal("%s %d imsg_compose error", __func__,
				    __LINE__);
			sent++;
		}
		max -= sent;
	} while (sent != 0 && max > 0);

	/* ... then updates */
	max = RDE_RUNNER_ROUNDS / 2;
	do {
		sent = 0;
		LIST_FOREACH(peer, &peerlist, peer_l) {
			if (peer->conf.id == 0)
				continue;
			if (peer->state != PEER_UP)
				continue;
			len = sizeof(queue_buf) - MSGSIZE_HEADER;
			r = up_dump_mp_reach(queue_buf, &len, peer, aid);
			switch (r) {
			case -2:
				continue;
			case -1:
				peer_send_eor(peer, aid);
				continue;
			default:
				b = queue_buf + r;
				break;
			}

			/* finally send message to SE */
			if (imsg_compose(ibuf_se, IMSG_UPDATE, peer->conf.id,
			    0, -1, b, len) == -1)
				fatal("%s %d imsg_compose error", __func__,
				    __LINE__);
			sent++;
		}
		max -= sent;
	} while (sent != 0 && max > 0);
@


1.358
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.357 2017/01/23 22:53:52 claudio Exp $ */
d2873 1
a2873 1
	if (re->rib != &peer->rib->rib)
@


1.357
log
@Rename rib pointer in struct prefix to re since it points to a rib_entry.
While there also remove a comment that is since a few years at least.
OK gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.356 2017/01/23 22:47:59 claudio Exp $ */
d34 1
d42 1
d175 3
d179 1
a179 4
	log_procname = log_procnames[bgpd_process];

	log_init(debug);
	log_verbose(verbose);
d612 1
a612 1
			log_verbose(verbose);
@


1.356
log
@Introduce a struct rib sitting between struct rib_desc and struct rib_tree.
This way the tree becomes a bit better decoupled.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.355 2017/01/23 12:25:19 claudio Exp $ */
d2191 1
a2191 1
	if (p->rib->active == p)
d2283 1
a2283 1
		if ((req->flags & F_CTL_ACTIVE) && p->rib->active != p)
d2287 1
a2287 1
		if (p->rib->active != p)
@


1.355
log
@More rototilling, make rib_new and rib_find return a point to struct rib_desc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.354 2017/01/23 11:43:40 claudio Exp $ */
d726 2
a727 2
			    (rib->flags & F_RIB_HASNOFIB) !=
			    (rib->flags & F_RIB_HASNOFIB)) {
d758 1
a758 1
			r->peer.ribid = rib->id;
d1301 1
a1301 1
		r += path_update(&ribs[0], peer, asp, prefix, prefixlen);
d1316 1
a1316 1
			r += path_update(&ribs[i], peer, fasp, prefix,
d1318 1
a1318 1
		} else if (prefix_remove(&ribs[i], peer, prefix, prefixlen,
d1348 1
a1348 1
		if (prefix_remove(&ribs[i], peer, prefix, prefixlen, 0)) {
d2357 1
a2357 1
	ctx->ribctx.ctx_rib = rib;
d2385 1
a2385 1
			re = rib_lookup(rib, &req->prefix);
d2387 1
a2387 1
			re = rib_get(rib, &req->prefix, req->prefixlen);
d2436 1
a2436 1
	ctx->ribctx.ctx_rib = rib;
d2650 1
a2650 1
			rib_dump(peer->rib,
d2686 1
a2686 1
			rib_dump(&ribs[0], rde_softreconfig_in, &ribs[rid],
d2698 1
a2698 1
			rib_dump(peer->rib, rde_softreconfig_out,
d2760 2
a2761 1
			path_update(rib, peer, nasp, &addr, pt->prefixlen);
d2764 1
a2764 1
			prefix_remove(rib, peer, &addr, pt->prefixlen, 0);
d2768 1
a2768 1
				path_update(rib, peer, nasp, &addr,
d2871 1
a2871 1
	if (re->ribid != peer->rib->id)
d2894 1
a2894 1
		if (peer->rib->id != ribid)
d3365 1
a3365 1
		rib_dump(peer->rib, rde_up_dump_upcall, peer, aid);
d3496 1
a3496 1
		path_update(&ribs[i], peerself, asp, &nc->prefix,
d3544 2
a3545 2
		prefix_remove(&ribs[i], peerself, &nc->prefix, nc->prefixlen,
		    flags);
@


1.354
log
@Rename struct rib to struct rib_desc. Mechanical change, OK gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.353 2016/11/10 09:18:33 phessler Exp $ */
d631 1
d722 6
a727 6
			rid = rib_find(rn.name);
			if (rid == RIB_FAILED)
				rib_new(rn.name, rn.rtableid, rn.flags);
			else if (ribs[rid].rtableid != rn.rtableid ||
			    (ribs[rid].flags & F_RIB_HASNOFIB) !=
			    (rn.flags & F_RIB_HASNOFIB)) {
d735 5
a739 5
				in_rules = ribs[rid].in_rules;
				ribs[rid].in_rules = NULL;
				rib_free(&ribs[rid]);
				rib_new(rn.name, rn.rtableid, rn.flags);
				ribs[rid].in_rules = in_rules;
d741 1
a741 1
				ribs[rid].state = RECONF_KEEP;
d751 1
a751 1
			if ((r->peer.ribid = rib_find(r->rib)) == RIB_FAILED) {
d758 1
d761 1
a761 1
				nr = ribs[r->peer.ribid].in_rules_tmp;
d768 1
a768 1
					ribs[r->peer.ribid].in_rules_tmp = nr;
d2332 1
a2334 1
	u_int16_t		 id;
d2344 1
a2344 1
	if ((id = rib_find(req->rib)) == RIB_FAILED) {
d2357 1
a2357 1
	ctx->ribctx.ctx_rib = &ribs[id];
d2385 1
a2385 1
			re = rib_lookup(&ribs[id], &req->prefix);
d2387 1
a2387 1
			re = rib_get(&ribs[id], &req->prefix, req->prefixlen);
d2415 1
a2415 1
	u_int16_t		 id;
d2425 2
a2426 2
	id = rib_find(ctx->mrt.rib);
	if (id == RIB_FAILED) {
d2436 1
a2436 1
	ctx->ribctx.ctx_rib = &ribs[id];
d2649 2
a2650 2
		if (peer->ribid != rib_find(peer->conf.rib)) {
			rib_dump(&ribs[peer->ribid],
d2652 2
a2653 2
			peer->ribid = rib_find(peer->conf.rib);
			if (peer->ribid == RIB_FAILED)
d2698 1
a2698 1
			rib_dump(&ribs[peer->ribid], rde_softreconfig_out,
d2870 1
a2870 1
	if (re->ribid != peer->ribid)
d2893 1
a2893 1
		if (peer->ribid != ribid)
d3146 2
a3147 2
	peer->ribid = rib_find(peer->conf.rib);
	if (peer->ribid == RIB_FAILED)
d3364 1
a3364 1
		rib_dump(&ribs[peer->ribid], rde_up_dump_upcall, peer, aid);
@


1.353
log
@draft-ietf-idr-optional-transitive-00 became RFC 7606

changes from the draft to the RFC:
 - PARTIAL flag is no longer considered protection
 - for some attrs, a length of 0 is invalid

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.352 2016/10/18 19:47:52 benno Exp $ */
d2720 1
a2720 1
	struct rib		*rib = ptr;
@


1.352
log
@"Terminate the session after number prefixes have been received" means
that max-prefix 1 will close the session on the first prefix which is
off by one to what one would expect. Change it to No. received >
max-prefix, which is also in line with other implementations.
Found by jbg@@ and deraadt@@.
ok phessler@@ deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.351 2016/10/14 16:05:36 phessler Exp $ */
d1540 1
a1540 2
			 * draft-ietf-idr-optional-transitive-00.txt
			 * but only if partial bit is set
a1541 2
			if ((flags & ATTR_PARTIAL) == 0)
				goto bad_len;
d1564 1
a1564 1
		if (attr_len % 4 != 0) {
d1567 1
a1567 2
			 * draft-ietf-idr-optional-transitive-00.txt
			 * but only if partial bit is set
a1568 2
			if ((flags & ATTR_PARTIAL) == 0)
				goto bad_len;
d1578 1
a1578 1
		if (attr_len % 12 != 0) {
d1581 1
a1581 2
			 * draft-ietf-idr-optional-transitive-00.txt
			 * but only if partial bit is set
a1582 2
			if ((flags & ATTR_PARTIAL) == 0)
				goto bad_len;
d1592 1
a1592 1
		if (attr_len % 8 != 0) {
d1595 1
a1595 2
			 * draft-ietf-idr-optional-transitive-00.txt
			 * but only if partial bit is set
a1596 2
			if ((flags & ATTR_PARTIAL) == 0)
				goto bad_len;
@


1.351
log
@Add support for draft-ietf-idr-large-community

Joint work with Job Snijders, many thanks!
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.350 2016/09/03 16:22:17 renato Exp $ */
d1135 1
a1135 1
		    peer->prefix_cnt >= peer->conf.max_prefix) {
d1217 1
a1217 1
				    peer->prefix_cnt >= peer->conf.max_prefix) {
d1255 1
a1255 1
				    peer->prefix_cnt >= peer->conf.max_prefix) {
@


1.350
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.349 2016/09/02 14:00:29 benno Exp $ */
d5 2
d564 1
d1583 17
d2289 4
d2375 1
@


1.349
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.348 2016/08/08 21:44:00 renato Exp $ */
d311 15
a337 9
	if (ibuf_se)
		msgbuf_clear(&ibuf_se->w);
	free(ibuf_se);
	if (ibuf_se_ctl)
		msgbuf_clear(&ibuf_se_ctl->w);
	free(ibuf_se_ctl);

	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
@


1.348
log
@Use exit(3) instead of _exit(2) in the child processes.

Since recently the child processes call exec() after fork(), so they
should stop using _exit(2) and use exit(3) instead when shutting down.

Ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.347 2016/07/21 10:13:58 claudio Exp $ */
d171 3
a185 1
	bgpd_process = PROC_RDE;
@


1.347
log
@Remove a fatal() in peer_up when the local addrs of a peer can't be figured out.
Instead bring the session down and wait for admin help.
OK henning@@, benno@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.346 2016/06/03 17:36:37 benno Exp $ */
d332 1
a332 1
	_exit(0);
@


1.346
log
@Add operators =, !=, - (range), >< (exclsive range) to the as-path
filters (AS, peer-as, source-as, transit-as).

Add a use case (block illegal AS numbers) to the bgpd.conf example.

feedback from claudio, sthen, florian,
ok florian@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.345 2015/12/22 21:36:57 mmcc Exp $ */
d99 1
a99 1
void		 peer_localaddrs(struct rde_peer *, struct bgpd_addr *);
d3137 1
a3137 1
void
d3149 4
a3152 2
	if (match == NULL)
		fatalx("peer_localaddrs: local address not found");
d3187 1
d3222 5
a3226 1
	peer_localaddrs(peer, &sup->local_addr);
@


1.345
log
@commited -> committed
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.344 2015/12/03 09:26:59 benno Exp $ */
d2255 1
a2255 1
		    p->aspath->aspath->len, req->as.type, req->as.as))
@


1.344
log
@claudio questioned the need for pledge(unix) in the rde, and i think
he is right.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.343 2015/11/06 16:23:26 phessler Exp $ */
d2448 1
a2448 1
	 * Make sure that self announce prefixes are not commited to the
@


1.343
log
@Radically improve the performance of bgpd filters.  Based on PF's skip
steps (and uses much of the same code).

In a torture test of ~600k prefix filters and 65k prefixes, convergance
time goes from 35 minutes to 30 seconds.

Many thanks to LONAP for providing a base configuration for torture
testing.

many discussions with claudio@@, benno@@, sthen@@ and the rest of the bgpd crowd

OK sthen@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.342 2015/10/25 18:45:04 claudio Exp $ */
d190 1
a190 1
	if (pledge("stdio unix route recvfd", NULL) == -1)
@


1.342
log
@Only run the rib_dump_runner() if there is something pending and the
control socket has not many messages queued.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.341 2015/10/09 01:37:09 deraadt Exp $ */
d2609 2
d2644 2
@


1.341
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.340 2015/10/07 20:26:16 deraadt Exp $ */
d304 2
a305 1
		if (ibuf_se_ctl && ibuf_se_ctl->w.queued <= 0)
@


1.340
log
@In theory, bgpd should be happy with tame "stdio unix route recvfd".
Let's hear from people's experiences by commiting it.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.339 2015/09/21 09:47:15 phessler Exp $ */
d190 2
a191 2
	if (tame("stdio unix route recvfd", NULL) == -1)
		fatal("tame");
@


1.339
log
@Let us log all updates sent from an individual peer.  Since this can be
applied to a group, also let us disable logging on a sub-member of the
group.  Very handy for debugging naughty peers on a router with multiple
peers.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.338 2015/09/19 16:24:08 claudio Exp $ */
d33 1
d189 3
@


1.338
log
@Use correct function name in error message
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.337 2015/08/30 23:20:43 deraadt Exp $ */
d1980 2
a1981 1
	if (!(conf->log & BGPD_LOG_UPDATES))
@


1.337
log
@rename a variable "err" to "error"
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.336 2015/08/04 14:46:38 phessler Exp $ */
d354 1
a354 1
			fatal("rde_dispatch_imsg_session: imsg_read error");
d620 1
a620 1
			fatal("rde_dispatch_imsg_parent: imsg_read error");
@


1.336
log
@Give more precise errors, to help track when bgpd quits

OK florian@@ benno@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.335 2015/07/20 16:10:38 claudio Exp $ */
d1365 1
a1365 1
	int		 err;
d1426 2
a1427 2
		err = aspath_verify(p, attr_len, rde_as4byte(peer));
		if (err == AS_ERR_SOFT) {
d1436 1
a1436 1
		} else if (err != 0) {
d1643 1
a1643 1
		if ((err = aspath_verify(p, attr_len, 1)) != 0) {
d1655 1
a1655 1
			if (flags & ATTR_PARTIAL || err == AS_ERR_SOFT) {
@


1.335
log
@Make bgpd execute the RDE and session engine process instead of just forking.
This way ASLR and stack cookies are per process.
With input from benno@@ and deraadt@@
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.334 2015/07/18 22:52:39 benno Exp $ */
d273 1
a273 1
			log_warnx("Lost connection to SE");
d282 1
a282 1
			log_warnx("Lost connection to SE");
@


1.334
log
@give bgpd's fatal() varargs and use it to instrument bgpd fatal()
calls to aid in debugging
henning@@ "makes sense to me", sthen@@ "yes please", ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.333 2015/07/16 17:26:57 blambert Exp $ */
d159 2
a160 3
pid_t
rde_main(int pipe_m2r[2], int pipe_s2r[2], int pipe_m2s[2], int pipe_s2rctl[2],
    int debug)
a161 1
	pid_t			 pid;
d170 2
a171 8
	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}
a195 6
	close(pipe_s2r[0]);
	close(pipe_s2rctl[0]);
	close(pipe_m2r[0]);
	close(pipe_m2s[0]);
	close(pipe_m2s[1]);

d197 1
a197 3
	if ((ibuf_se = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_se_ctl = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d199 1
a199 3
	imsg_init(ibuf_se, pipe_s2r[1]);
	imsg_init(ibuf_se_ctl, pipe_s2rctl[1]);
	imsg_init(ibuf_main, pipe_m2r[1]);
d236 7
a242 15
		pfd[PFD_PIPE_MAIN].fd = ibuf_main->fd;
		pfd[PFD_PIPE_MAIN].events = POLLIN;
		if (ibuf_main->w.queued > 0)
			pfd[PFD_PIPE_MAIN].events |= POLLOUT;

		pfd[PFD_PIPE_SESSION].fd = ibuf_se->fd;
		pfd[PFD_PIPE_SESSION].events = POLLIN;
		if (ibuf_se->w.queued > 0)
			pfd[PFD_PIPE_SESSION].events |= POLLOUT;

		pfd[PFD_PIPE_SESSION_CTL].fd = ibuf_se_ctl->fd;
		pfd[PFD_PIPE_SESSION_CTL].events = POLLIN;
		if (ibuf_se_ctl->w.queued > 0)
			pfd[PFD_PIPE_SESSION_CTL].events |= POLLOUT;
		else if (rib_dump_pending())
d267 3
a269 6
		if ((pfd[PFD_PIPE_MAIN].revents & POLLOUT) &&
		    ibuf_main->w.queued)
			if (msgbuf_write(&ibuf_main->w) <= 0 && errno != EAGAIN)
				fatal("pipe write error");

		if (pfd[PFD_PIPE_MAIN].revents & POLLIN)
d272 6
a277 6
		if ((pfd[PFD_PIPE_SESSION].revents & POLLOUT) &&
		    ibuf_se->w.queued)
			if (msgbuf_write(&ibuf_se->w) <= 0 && errno != EAGAIN)
				fatal("pipe write error");

		if (pfd[PFD_PIPE_SESSION].revents & POLLIN)
d280 7
a286 7
		if ((pfd[PFD_PIPE_SESSION_CTL].revents & POLLOUT) &&
		    ibuf_se_ctl->w.queued)
			if (msgbuf_write(&ibuf_se_ctl->w) <= 0 &&
			    errno != EAGAIN)
				fatal("pipe write error");

		if (pfd[PFD_PIPE_SESSION_CTL].revents & POLLIN)
d300 1
a300 1
		if (ibuf_se_ctl->w.queued <= 0)
d316 2
a317 1
	msgbuf_clear(&ibuf_se->w);
d319 2
a320 1
	msgbuf_clear(&ibuf_se_ctl->w);
d322 1
d352 1
a352 6
	if ((n = imsg_read(ibuf)) == -1)
		fatal("rde_dispatch_imsg_session: imsg_read error");
	if (n == 0)	/* connection closed */
		fatalx("rde_dispatch_imsg_session: pipe closed");

	for (;;) {
d610 1
d618 1
a618 6
	if ((n = imsg_read(ibuf)) == -1)
		fatal("rde_dispatch_imsg_parent: imsg_read error");
	if (n == 0)	/* connection closed */
		fatalx("rde_dispatch_imsg_parent: pipe closed");

	for (;;) {
d625 28
@


1.333
log
@fix pasto in error string

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.332 2015/06/21 12:16:29 claudio Exp $ */
d1969 1
a1969 1
		fatal("imsg_create error");
d1973 1
a1973 1
		fatal("imsg_add error");
d2496 2
a2497 1
				fatal("imsg_compose error");
d2503 1
a2503 1
			fatal("imsg_compose error");
d2532 1
a2532 1
		fatal("imsg_compose error");
d2544 1
a2544 1
		fatal("imsg_compose error");
d2562 1
a2562 1
		fatal("imsg_compose error");
d2929 2
a2930 1
				fatal("imsg_compose error");
d2965 2
a2966 1
				fatal("imsg_compose error");
d2997 2
a2998 1
				fatal("imsg_compose error");
d3352 1
a3352 1
		fatal("imsg_compose error");
d3369 2
a3370 1
			fatal("imsg_compose error in peer_send_eor");
d3391 2
a3392 1
			fatal("imsg_compose error in peer_send_eor");
@


1.332
log
@There is a race between sending notifications to the SE and getting a new
peer_up event in the RDE. This can be triggered by graceful restart. So
remove the panic and replace it with roughly what peer_down does.
OK phessler and henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.331 2015/06/19 14:54:12 phessler Exp $ */
d806 1
a806 1
				fatalx("IMSG_RECONF_CONF bad len");
@


1.331
log
@show the number of (currently) known prefixes and the max-prefix limit,
when we terminate the session.

since we terminate the session as soon as we go above the limit, show
'>' since there may be more that we haven't/won't process.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.330 2015/03/14 03:52:42 claudio Exp $ */
d3193 13
a3205 2
	    peer->state != PEER_UP)
		fatalx("peer_up: bad state");
@


1.330
log
@rename rde_free_filter() to filterlist_free() and start using it outside
of the RDE to free the filterlists. Also refactor common code to merge
filterlists into its own function. Makes the code look nicer.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.329 2014/10/08 16:15:37 deraadt Exp $ */
d1127 2
a1128 1
			log_peer_warnx(&peer->conf, "prefix limit reached");
d1210 3
a1212 1
					    "prefix limit reached");
d1248 3
a1250 1
					    "prefix limit reached");
@


1.329
log
@Use reallocarray() throughout to spot multiplicative int overflow.
ok henning benno
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.328 2014/04/13 10:36:41 blambert Exp $ */
d2672 1
a2672 1
	rde_free_filter(out_rules_tmp);
d2677 1
a2677 1
		rde_free_filter(ribs[rid].in_rules_tmp);
d3545 1
a3545 1
	rde_free_filter(out_rules);
d3549 1
a3549 1
		rde_free_filter(ribs[i].in_rules);
@


1.328
log
@fix language/spelling in error string

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.327 2014/01/22 04:08:08 claudio Exp $ */
d240 3
a242 2
			if ((newp = realloc(pfd, sizeof(struct pollfd) *
			    (PFD_PIPE_COUNT + rde_mrt_cnt))) == NULL) {
@


1.327
log
@Fix a bug where stale routes were not properly flushed on sessions announcing
the graceful restart capability.  The bug is triggered when a router does not
reconnect before the graceful restart timeout fires.
This removes the checks for the CAPA_GR_FORWARD flag in the timeout and
IMSG_SESSION_RESTARTED handler.
CAPA_GR_RESTARTING is indicating that bgpd is currently doing a graceful
restart for this neighbor and therefore the SE must issue a flush of stale
routes in some way.
CAPA_GR_FORWARD on the other hand is only indicating that the neighbor
actually preserved the forwarding state which is too strict for the timeout
handler.
Tested by sthen@@, florian@@ and benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.326 2013/11/13 20:41:01 benno Exp $ */
d742 1
a742 1
				    "for not existsing rib %s", r->rib);
@


1.326
log
@from claudio
"Let msgbuf_write return -1 with errno EAGAIN. The users then must
check if this was the case and readd the event or poll again.  The
current handling in the imsg code is wrong for sure."

ok gilles, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.325 2013/08/14 20:34:26 claudio Exp $ */
d3285 1
d3321 8
a3328 1
	/* First notify SE to remove possible race with the timeout. */
@


1.325
log
@Rewrite the internals of the RDE reload logic.
This is the first step to make bgpd reload non blocking in the RDE.
It also speeds up the reload time a fair bit in some cases (mainly if
you run with multiple RIBs and have larger filtersets) and it should also
fix a few edge cases on reloads.
Testing done by benno@@, florian@@ and sthen@@ OK henning@@ and benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.324 2013/07/17 14:09:13 benno Exp $ */
d294 1
a294 1
			if (msgbuf_write(&ibuf_main->w) < 0)
d302 1
a302 1
			if (msgbuf_write(&ibuf_se->w) < 0)
d310 2
a311 1
			if (msgbuf_write(&ibuf_se_ctl->w) < 0)
@


1.324
log
@on graceful restart, the number of prefixes could be counted wrong,
triping max-prefix.  fix it this way, at least until prefix accounting
is done better.
diff from florian@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.323 2013/07/10 15:56:06 claudio Exp $ */
d88 1
a88 1
void		 rde_up_dump_upcall(struct rib_entry *, void *);
a90 2
void		 rde_softreconfig_load(struct rib_entry *, void *);
void		 rde_softreconfig_load_peer(struct rib_entry *, void *);
d92 1
d121 1
a121 1
struct filter_head	*rules_l, *newrules;
d226 2
a227 2
	rules_l = calloc(1, sizeof(struct filter_head));
	if (rules_l == NULL)
d229 1
a229 1
	TAILQ_INIT(rules_l);
d639 1
a639 1
	struct rde_peer		*peer;
d643 1
a643 2
	int			 n, fd, reconf_in = 0, reconf_out = 0,
				 reconf_rib = 0;
d687 2
a688 2
			newrules = calloc(1, sizeof(struct filter_head));
			if (newrules == NULL)
d690 1
a690 1
			TAILQ_INIT(newrules);
d699 3
a701 1
			for (rid = 0; rid < rib_size; rid++)
d703 1
d716 9
a724 2
				/* Big hammer in the F_RIB_NOFIB case but
				 * not often enough used to optimise it more. */
d727 1
d739 7
a745 1
			r->peer.ribid = rib_find(r->rib);
d747 13
a759 1
			TAILQ_INSERT_TAIL(newrules, r, entry);
a793 15
			if ((nconf->flags & BGPD_FLAG_NO_EVALUATE)
			    != (conf->flags & BGPD_FLAG_NO_EVALUATE)) {
				log_warnx("change to/from route-collector "
				    "mode ignored");
				if (conf->flags & BGPD_FLAG_NO_EVALUATE)
					nconf->flags |= BGPD_FLAG_NO_EVALUATE;
				else
					nconf->flags &= ~BGPD_FLAG_NO_EVALUATE;
			}
			memcpy(conf, nconf, sizeof(struct bgpd_config));
			conf->listen_addrs = NULL;
			conf->csock = NULL;
			conf->rcsock = NULL;
			free(nconf);
			nconf = NULL;
a794 76
			/* sync peerself with conf */
			peerself->remote_bgpid = ntohl(conf->bgpid);
			peerself->conf.local_as = conf->as;
			peerself->conf.remote_as = conf->as;
			peerself->short_as = conf->short_as;

			/* apply new set of rdomain, sync will be done later */
			while ((rd = SIMPLEQ_FIRST(rdomains_l)) != NULL) {
				SIMPLEQ_REMOVE_HEAD(rdomains_l, entry);
				filterset_free(&rd->import);
				filterset_free(&rd->export);
				free(rd);
			}
			free(rdomains_l);
			rdomains_l = newdomains;

			/* check if filter changed */
			LIST_FOREACH(peer, &peerlist, peer_l) {
				if (peer->conf.id == 0)
					continue;
				peer->reconf_out = 0;
				peer->reconf_in = 0;
				peer->reconf_rib = 0;
				if (peer->conf.softreconfig_in &&
				    !rde_filter_equal(rules_l, newrules, peer,
				    DIR_IN)) {
					peer->reconf_in = 1;
					reconf_in = 1;
				}
				if (peer->ribid != rib_find(peer->conf.rib)) {
					rib_dump(&ribs[peer->ribid],
					    rde_softreconfig_unload_peer, peer,
					    AID_UNSPEC);
					peer->ribid = rib_find(peer->conf.rib);
					peer->reconf_rib = 1;
					reconf_rib = 1;
					continue;
				}
				if (peer->conf.softreconfig_out &&
				    !rde_filter_equal(rules_l, newrules, peer,
				    DIR_OUT)) {
					peer->reconf_out = 1;
					reconf_out = 1;
				}
			}
			/* bring ribs in sync before softreconfig dance */
			for (rid = 0; rid < rib_size; rid++) {
				if (ribs[rid].state == RECONF_DELETE)
					rib_free(&ribs[rid]);
				else if (ribs[rid].state == RECONF_REINIT)
					rib_dump(&ribs[0],
					    rde_softreconfig_load, &ribs[rid],
					    AID_UNSPEC);
			}
			/* sync local-RIBs first */
			if (reconf_in)
				rib_dump(&ribs[0], rde_softreconfig_in, NULL,
				    AID_UNSPEC);
			/* then sync peers */
			if (reconf_out) {
				int i;
				for (i = 1; i < rib_size; i++) {
					if (ribs[i].state == RECONF_REINIT)
						/* already synced by _load */
						continue;
					rib_dump(&ribs[i], rde_softreconfig_out,
					    NULL, AID_UNSPEC);
				}
			}
			if (reconf_rib) {
				LIST_FOREACH(peer, &peerlist, peer_l) {
					rib_dump(&ribs[peer->ribid],
						rde_softreconfig_load_peer,
						peer, AID_UNSPEC);
				}
			}
d796 1
a796 11
			while ((r = TAILQ_FIRST(rules_l)) != NULL) {
				TAILQ_REMOVE(rules_l, r, entry);
				filterset_free(&r->set);
				free(r);
			}
			free(rules_l);
			rules_l = newrules;

			log_info("RDE reconfigured");
			imsg_compose(ibuf_main, IMSG_RECONF_DONE, 0, 0,
			    -1, NULL, 0);
a1270 2
extern u_int16_t rib_size;

d1286 2
d1289 2
a1290 2
		action = rde_filter(i, &fasp, rules_l, peer, asp, prefix,
		    prefixlen, peer, DIR_IN);
d1328 2
d2224 2
a2225 2
	a = rde_filter(1 /* XXX */, &asp, rules_l, peer, p->aspath, &addr,
	    p->prefix->prefixlen, p->aspath->peer, DIR_OUT);
d2561 1
a2561 1
rde_softreconfig_out(struct rib_entry *re, void *ptr)
d2563 1
a2563 2
	struct prefix		*p = re->active;
	struct pt_entry		*pt;
d2565 36
a2600 3
	struct rde_aspath	*oasp, *nasp;
	enum filter_actions	 oa, na;
	struct bgpd_addr	 addr;
d2602 8
a2609 2
	if (p == NULL)
		return;
d2611 1
a2611 2
	pt = re->prefix;
	pt_getaddr(pt, &addr);
d2615 9
a2623 1
		if (peer->ribid != re->ribid)
a2624 19
		if (peer->reconf_out == 0)
			continue;
		if (up_test_update(peer, p) != 1)
			continue;

		oa = rde_filter(re->ribid, &oasp, rules_l, peer, p->aspath,
		    &addr, pt->prefixlen, p->aspath->peer, DIR_OUT);
		na = rde_filter(re->ribid, &nasp, newrules, peer, p->aspath,
		    &addr, pt->prefixlen, p->aspath->peer, DIR_OUT);
		oasp = oasp != NULL ? oasp : p->aspath;
		nasp = nasp != NULL ? nasp : p->aspath;

		if (oa == ACTION_DENY && na == ACTION_DENY)
			/* nothing todo */
			goto done;
		if (oa == ACTION_DENY && na == ACTION_ALLOW) {
			/* send update */
			up_generate(peer, nasp, &addr, pt->prefixlen);
			goto done;
d2626 3
a2628 4
		if (oa == ACTION_ALLOW && na == ACTION_DENY) {
			/* send withdraw */
			up_generate(peer, NULL, &addr, pt->prefixlen);
			goto done;
d2630 30
a2659 5
		if (oa == ACTION_ALLOW && na == ACTION_ALLOW) {
			if (path_compare(nasp, oasp) == 0)
				goto done;
			/* send update */
			up_generate(peer, nasp, &addr, pt->prefixlen);
d2661 18
d2680 3
a2682 6
done:
		if (oasp != p->aspath)
			path_put(oasp);
		if (nasp != p->aspath)
			path_put(nasp);
	}
d2688 1
a2694 1
	u_int16_t		 i;
d2699 4
a2703 2

		/* store aspath as prefix may change till we're done */
d2707 4
a2710 14
		/* XXX how can this happen ??? */
		if (peer->reconf_in == 0)
			continue;

		for (i = 1; i < rib_size; i++) {
			/* only active ribs need a softreconfig rerun */
			if (ribs[i].state != RECONF_KEEP)
				continue;

			/* check if prefix changed */
			oa = rde_filter(i, &oasp, rules_l, peer, asp, &addr,
			    pt->prefixlen, peer, DIR_IN);
			na = rde_filter(i, &nasp, newrules, peer, asp, &addr,
			    pt->prefixlen, peer, DIR_IN);
d2712 4
a2715 30
			nasp = nasp != NULL ? nasp : asp;

			if (oa == ACTION_DENY && na == ACTION_DENY)
				/* nothing todo */
				goto done;
			if (oa == ACTION_DENY && na == ACTION_ALLOW) {
				/* update Local-RIB */
				path_update(&ribs[i], peer, nasp, &addr,
				    pt->prefixlen);
				goto done;
			}
			if (oa == ACTION_ALLOW && na == ACTION_DENY) {
				/* remove from Local-RIB */
				prefix_remove(&ribs[i], peer, &addr,
				    pt->prefixlen, 0);
				goto done;
			}
			if (oa == ACTION_ALLOW && na == ACTION_ALLOW) {
				if (path_compare(nasp, oasp) == 0)
					goto done;
				/* send update */
				path_update(&ribs[i], peer, nasp, &addr,
				    pt->prefixlen);
			}

done:
			if (oasp != asp)
				path_put(oasp);
			if (nasp != asp)
				path_put(nasp);
d2717 2
a2718 25
	}
}

void
rde_softreconfig_load(struct rib_entry *re, void *ptr)
{
	struct rib		*rib = ptr;
	struct prefix		*p, *np;
	struct pt_entry		*pt;
	struct rde_peer		*peer;
	struct rde_aspath	*asp, *nasp;
	enum filter_actions	 action;
	struct bgpd_addr	 addr;

	pt = re->prefix;
	pt_getaddr(pt, &addr);
	for (p = LIST_FIRST(&re->prefix_h); p != NULL; p = np) {
		np = LIST_NEXT(p, rib_l);

		/* store aspath as prefix may change till we're done */
		asp = p->aspath;
		peer = asp->peer;

		action = rde_filter(rib->id, &nasp, newrules, peer, asp, &addr,
		    pt->prefixlen, peer, DIR_IN);
d2721 4
a2724 1
		if (action == ACTION_ALLOW) {
d2727 8
d2737 2
d2745 1
a2745 1
rde_softreconfig_load_peer(struct rib_entry *re, void *ptr)
a2746 1
	struct rde_peer		*peer = ptr;
d2749 3
a2751 2
	struct rde_aspath	*nasp;
	enum filter_actions	 na;
d2754 6
a2762 1
	/* check if prefix was announced */
d2766 5
a2770 2
	na = rde_filter(re->ribid, &nasp, newrules, peer, p->aspath,
	    &addr, pt->prefixlen, p->aspath->peer, DIR_OUT);
d2773 2
a2774 1
	if (na == ACTION_DENY)
d2776 11
a2786 1
		goto done;
d2788 2
a2789 3
	/* send update */
	up_generate(peer, nasp, &addr, pt->prefixlen);
done:
d2811 2
a2812 2
	oa = rde_filter(re->ribid, &oasp, rules_l, peer, p->aspath,
	    &addr, pt->prefixlen, p->aspath->peer, DIR_OUT);
d2840 1
a2840 1
	up_generate_updates(rules_l, peer, re->active, NULL);
d2863 1
a2863 1
		up_generate_updates(rules_l, peer, new, old);
d3110 2
d3306 1
a3306 1
		up_generate_default(rules_l, peer, aid);
d3427 3
a3429 1
	for (i = 1; i < rib_size; i++)
d3432 1
d3475 3
a3477 1
	for (i = rib_size - 1; i > 0; i--)
d3480 1
a3519 1
	struct filter_rule	*r;
d3535 5
a3539 4
	while ((r = TAILQ_FIRST(rules_l)) != NULL) {
		TAILQ_REMOVE(rules_l, r, entry);
		filterset_free(&r->set);
		free(r);
a3540 1
	free(rules_l);
@


1.323
log
@Change the way the RDE updates its peer list. The SE is now always sending
a IMSG_SESSION_ADD message to the RDE when a peer comes up or when a reload
happens. The IMSG_SESSION_ADD has the full current config of the peer and
so the RDE should end up with correct values. This affects mostly maxprefix
and the RIB settings. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.322 2013/05/31 23:10:12 claudio Exp $ */
d3282 1
d3284 1
d3288 1
a3288 1
		path_remove_stale(asp, aid);
d3296 5
@


1.322
log
@Unfuck BGP MPLS VPNs that got broken by the last few reload related commits.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.321 2012/09/18 10:10:00 claudio Exp $ */
d396 1
a396 7
			peer = peer_add(imsg.hdr.peerid, &pconf);
			if (peer == NULL) {
				log_warnx("session add: "
				    "peer id %d already exists",
				    imsg.hdr.peerid);
				break;
			}
a640 1
	struct peer_config	*pconf;
a721 10
		case IMSG_RECONF_PEER:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct peer_config))
				fatalx("IMSG_RECONF_PEER bad len");
			if ((peer = peer_get(imsg.hdr.peerid)) == NULL)
				break;
			pconf = imsg.data;
			strlcpy(peer->conf.rib, pconf->rib,
			    sizeof(peer->conf.rib));
			break;
d3130 2
a3131 1
	if (peer_get(id))
d3133 1
@


1.321
log
@Expose the local weight in the ctl_show_rib struct so bgpctl can print it.
OK sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.320 2012/09/18 09:45:51 claudio Exp $ */
d3441 7
@


1.320
log
@Only allow one reload request at a time in bgpd. Needed for further work.
OK sthen@@, benno@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.319 2012/09/17 18:03:28 miod Exp $ */
d493 1
d2235 1
@


1.319
log
@Unbreak. gcc 2 at least complains if a declaration is ended by two semicolons.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.318 2012/09/12 05:56:22 claudio Exp $ */
d885 2
@


1.318
log
@Better graceful restart support (implementing more then just the EoR record).
This implements only the "Restarting Client" bits of the RFC -- in other
words bgpd will keep the FIB when the client restarts but it will not do GR
when restarting itself. The capability is still off by default (you need
"announce restart yes" to enable it).
Tested by Anders Berggren. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.317 2012/08/12 14:24:56 claudio Exp $ */
d2225 1
a2225 1
	time_t			 staletime;;
@


1.317
log
@By default mask the reserved bits and the ext len bit in the attribute
flags field. Some systems seem to start sending bad flags around which
cause session failures in bgpd. Make sure that bgpd ignores the must be
zero flags correctly and ensure that they are always reset to zero when
sending updates out.
Reported and patch tested by Laurent CARON, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.316 2012/05/27 18:52:07 claudio Exp $ */
d104 3
d413 41
d606 2
d612 2
d1071 4
d1105 5
d2225 1
d2262 3
d3227 2
a3228 1
	if (peer->state != PEER_DOWN && peer->state != PEER_NONE)
d3285 44
d3344 1
a3344 1
	if (peer->capa.restart)
d3350 11
d3365 2
@


1.316
log
@Extend the network code to allow attributes to be passed in with prefixes.
In the end this will allow anyone to use MRT table dumps to load prefixes
into a bgpd instance. For example you can download the RIPE dumps and load
full-feeds onto your laptop until the poor thing dies.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.315 2012/05/22 20:38:17 claudio Exp $ */
d1385 1
a1385 1
	(((s) & ~(ATTR_EXTLEN | (m))) == (t))
@


1.316.2.1
log
@MFC fix for interoperability problem with some newer Junipers which don't
clear reserved bits:

-- -- --
By default mask the reserved bits and the ext len bit in the attribute
flags field. Some systems seem to start sending bad flags around which
cause session failures in bgpd. Make sure that bgpd ignores the must be
zero flags correctly and ensure that they are always reset to zero when
sending updates out.
Reported and patch tested by Laurent CARON, OK henning@@

Members:
        rde.c:1.316->1.317
        rde.h:1.142->1.143
        rde_attr.c:1.90->1.91
-- -- --
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.317 2012/08/12 14:24:56 claudio Exp $ */
d1385 1
a1385 1
	(((s) & ~(ATTR_DEFMASK | (m))) == (t))
@


1.315
log
@Fix a warning message to print the correct information. OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.314 2012/04/12 17:31:05 claudio Exp $ */
d54 1
a360 1
	struct rde_peer		*peer;
d362 1
d364 2
d368 1
d371 1
d430 41
d488 3
d1717 36
d1816 1
a1816 1
		 * the toilet the larger the the number got.
d3321 10
a3330 6
	asp = path_get();
	asp->aspath = aspath_get(NULL, 0);
	asp->origin = ORIGIN_IGP;
	asp->flags = F_ATTR_ORIGIN | F_ATTR_ASPATH |
	    F_ATTR_LOCALPREF | F_PREFIX_ANNOUNCED;
	/* the nexthop is unset unless a default set overrides it */
a3332 1

@


1.314
log
@The ebgp flags is just a truth value and it is better to not == 1 compares.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.313 2012/04/07 17:25:51 claudio Exp $ */
d3077 1
a3077 1
		log_warnx("peer_up: peer id %d already exists", id);
@


1.313
log
@The Route Distinguishers should not be used to control distribution.
Found by and fix tested by Rimi Philippe
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.312 2012/03/27 18:22:07 claudio Exp $ */
d2033 3
a2035 1
		if (peer->conf.ebgp == 0)
a2036 2
		else
			id = conf->bgpid;
d2111 1
a2111 1
	if (asp->peer->conf.ebgp == 0)
@


1.312
log
@Introduce F_CTL_ACTIVE a flag to only show selected pathes.
Requested and OK deraadt@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.311 2011/09/20 21:19:06 claudio Exp $ */
a2416 2
			if (addr.vpn4.rd != rd->rd)
				continue;
a3250 1

@


1.311
log
@Move a few functions into util.c because bgpctl will need them soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.310 2011/09/19 11:18:11 claudio Exp $ */
d2193 2
@


1.310
log
@remove an unused ctl struct and remove some unneeded values from
struct ctl_show_rib since bgpctl does not look at them at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.309 2011/09/17 16:29:44 claudio Exp $ */
d2187 2
a2188 1
		    !aspath_match(p->aspath->aspath, req->as.type, req->as.as))
@


1.309
log
@Implement new mrt table dump format as specified in draft-ietf-grow-mrt.
Tested with IP and IPv6 sessions and against the libbgpdump parser.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.308 2011/07/09 02:51:18 henning Exp $ */
a2088 2
	rib.prefix_cnt = asp->prefix_cnt;
	rib.active_cnt = asp->active_cnt;
@


1.308
log
@remove that rlimit code, rc.d and login classes do it much betterer these
days. screaming bob ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.307 2011/02/15 12:26:37 claudio Exp $ */
d823 2
a824 1
			    xmrt.type == MRT_TABLE_DUMP_MP) {
d2340 4
@


1.307
log
@Use log_as() to print the offending neighbor-as instead of printing it
as an int. This way 4-byte ASes should be printed nicely.
OK deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.306 2011/01/29 17:10:45 henning Exp $ */
a25 1
#include <limits.h>
a159 1
	struct rlimit		 rl;
a187 6

	if (getrlimit(RLIMIT_DATA, &rl) == -1)
		fatal("getrlimit");
	rl.rlim_cur = rl.rlim_max;
	if (setrlimit(RLIMIT_DATA, &rl) == -1)
		fatal("setrlimit");
@


1.306
log
@improve error msg when enforce-neighbor-as is on and the path doesn't
start with the neighbor-as. makes finding the offender easier.
from Sebastian Benoit <benoit-lists at fb12.de>, claudio agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.305 2011/01/27 17:19:09 sthen Exp $ */
d925 2
a926 2
				"starting with %i, "
				"enforce neighbor-as enabled", fas);
@


1.305
log
@change a logged error from 'enforce remote-as' to the correct
'enforce neighbor-as'; from Sebastian Benoit on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.304 2010/12/23 17:41:40 claudio Exp $ */
d861 1
d921 7
a927 6
		    peer->conf.enforce_as == ENFORCE_AS_ON)
			if (peer->conf.remote_as !=
			    aspath_neighbor(asp->aspath)) {
				log_peer_warnx(&peer->conf, "bad path, "
				    "enforce neighbor-as enabled");
				rde_update_err(peer, ERR_UPDATE, ERR_UPD_ASPATH,
d929 1
a929 1
				goto done;
d931 1
@


1.304
log
@Increase the DATA limit in the RDE to the max value and do the same
for NOFILE in the session engine.
OK henning, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.303 2010/11/30 15:33:06 claudio Exp $ */
d924 1
a924 1
				    "enforce remote-as enabled");
@


1.303
log
@Do what the comment actually says. Ignore the full attribute not only the
header. ATTR_UNDEF is still a bit strange though but at least it will now
parse and ignore such a freak attribute correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.302 2010/11/24 00:58:10 sthen Exp $ */
d21 2
d161 1
d190 6
@


1.302
log
@fix spelling in an error message
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.301 2010/11/18 12:18:31 claudio Exp $ */
d1375 1
@


1.301
log
@Accept but ignore (treat as withdraw) updates with AS_CONFED_* path
segments. Bgpd does not support confederations but it is too extreme
to close a session because a path contained such elements.
OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.300 2010/11/10 15:14:36 claudio Exp $ */
d2728 1
a2728 1
		fatalx("King Bula: monsterous evil horror.");
@


1.300
log
@Make sure that the initial configuration of the child is zeroed out
by using calloc(). This fixes an issue where the RDE would start up
as route-collector because uninitialized memory made the RDE switch
to that mode.
OK henning@@, sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.299 2010/10/15 07:43:02 claudio Exp $ */
d1340 1
d1400 11
a1410 1
		if (aspath_verify(p, attr_len, rde_as4byte(peer)) != 0) {
d1617 1
a1617 1
		if (aspath_verify(p, attr_len, 1) != 0) {
d1627 1
d1629 1
a1629 1
			if (flags & ATTR_PARTIAL) {
@


1.299
log
@Add a few more wanrings to the UPDATE parser. Mainly to warn when
attributes are ignored or UPDATEs are invalidated and withdrawn.
While there use % to check if a attribute is a multiple of X.
OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.298 2010/09/02 14:03:21 sobrado Exp $ */
d230 1
a230 1
	if ((conf = malloc(sizeof(struct bgpd_config))) == NULL)
@


1.298
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.297 2010/07/14 09:00:08 claudio Exp $ */
d1492 2
d1514 1
a1514 1
		if ((attr_len & 0x3) != 0) {
d1522 3
a1524 2
			else
				a->flags |= F_ATTR_PARSE_ERR;
d1531 1
a1531 1
		if ((attr_len & 0x7) != 0) {
d1539 3
a1541 2
			else
				a->flags |= F_ATTR_PARSE_ERR;
d1554 1
a1554 1
		if ((attr_len & 0x3) != 0)
d1592 2
a1593 1
			/* we should add a warning here */
d1619 2
d1950 3
a1952 1
		if (nasp)
d1954 4
a1957 1
		if (naggr)
d1959 1
@


1.297
log
@Fix a mrt fd leak by moving the block which closes finished dumps.
The previous location also depended on poll results and in most cases was
therefor not entered because finished dumps are not added to the poll array.
Problem reported by Peter Haag, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.296 2010/05/26 13:56:07 nicm Exp $ */
d1706 1
a1706 1
		 * the toilet the larger the the number got. 
d2153 1
a2153 1
	if (req->flags & F_CTL_ADJ_IN || 
d2157 1
a2157 1
		if (req->type == IMSG_CTL_SHOW_RIB_AS && 
d2716 1
a2716 1
	 * If new is != NULL we know it is reachable and then we should 
d2849 1
a2849 1
				
@


1.297.2.1
log
@MFC, original commit from claudio@@
(r1.300 of rde.c and r1.313 of session.c):
- - - - - - - - - - - - - -
Make sure that the initial configuration of the child is zeroed out
by using calloc(). This fixes an issue where the RDE would start up
as route-collector because uninitialized memory made the RDE switch
to that mode.
OK henning@@, sthen@@, phessler@@
- - - - - - - - - - - - - -

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.297 2010/07/14 09:00:08 claudio Exp $ */
d230 1
a230 1
	if ((conf = calloc(1, sizeof(struct bgpd_config))) == NULL)
@


1.296
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.295 2010/05/19 12:44:14 claudio Exp $ */
d267 2
a268 1
		LIST_FOREACH(mctx, &rde_mrts, entry) {
d273 6
a313 1
			xmctx = LIST_NEXT(mctx, entry);
d317 1
a317 9
			if (mctx->mrt.wbuf.queued == 0 && 
			    mctx->mrt.state == MRT_STATE_REMOVE) {
				close(mctx->mrt.wbuf.fd);
				LIST_REMOVE(&mctx->ribctx, entry);
				LIST_REMOVE(mctx, entry);
				free(mctx);
				rde_mrt_cnt--;
			}
			mctx = xmctx;
@


1.295
log
@Add softreconfig support for peers changing the RIB. Done by first unloading
the old RIB and then via softreconfig in and a special softreconfig out loading
the new RIB.
Feature requested and testeded by Elisa Jasinska.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.294 2010/05/17 15:49:29 claudio Exp $ */
d1879 1
a1879 1
	struct buf	*wbuf;
d2051 1
a2051 1
	struct buf		*wbuf;
d2111 2
a2112 2
			if ((bp = buf_reserve(wbuf, attr_optlen(a))) == NULL) {
				buf_free(wbuf);
d2117 1
a2117 1
				buf_free(wbuf);
@


1.294
log
@Last bits of MPLS VPN support. Hook kernel routing tables and RIB together.
This adds a bit of new config to specify the mapping between an rdomain and
the BGP MPLS VPN instance, example:
rdomain 1 {
        descr "CUSTOMER1"
	rd 65003:1
	import-target rt 65003:3
	export-target rt 65003:1
	depend on mpe0
	network 192.168.224/24
}
The "depend on mpe0" is a but ugly but for now this is the quickest way to
figure out which interface bgp should use to insert the MPLS routes.

A big side-effect of this diff is that networks are now internally
distributed through kroute.c.
This needs some kernel changes that will follow hopefully soon.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.293 2010/05/04 10:25:31 claudio Exp $ */
d90 2
d550 1
d554 2
a555 1
	int			 n, fd, reconf_in = 0, reconf_out = 0;
d632 10
d725 16
a746 6
				if (peer->conf.softreconfig_in &&
				    !rde_filter_equal(rules_l, newrules, peer,
				    DIR_IN)) {
					peer->reconf_in = 1;
					reconf_in = 1;
				}
d772 7
d2628 64
@


1.293
log
@Assuming that a prefixlen 32 is a host route is not clever when IPv6 comes
into play. Check the AID and use 32 or 128 based on the address family.
Now bgpctl show rib <IPv6 addr> works like in the IPv4 case.
Bug reported and fix made during yesterday's Swinog BE#85
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.292 2010/05/03 13:09:38 claudio Exp $ */
d85 1
a102 1
void		 network_init(struct network_head *);
d116 1
d224 4
d543 1
a565 13
		case IMSG_RECONF_CONF:
			reloadtime = time(NULL);
			newrules = calloc(1, sizeof(struct filter_head));
			if (newrules == NULL)
				fatal(NULL);
			TAILQ_INIT(newrules);
			if ((nconf = malloc(sizeof(struct bgpd_config))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct bgpd_config));
			for (rid = 0; rid < rib_size; rid++)
				ribs[rid].state = RECONF_DELETE;
			break;
d567 5
d590 20
d640 30
d675 1
a675 1
				log_warnx( "change to/from route-collector "
d694 10
a703 1
			prefix_network_clean(peerself, reloadtime, 0);
d756 1
d763 3
d2294 12
d2312 1
d2345 29
a2373 3
	if (imsg_compose(ibuf_main, type, ribs[ribid].rtableid, 0, -1, &kr,
	    sizeof(kr)) == -1)
		fatal("imsg_compose error");
a3071 14
network_init(struct network_head *net_l)
{
	struct network	*n;

	reloadtime = time(NULL);

	while ((n = TAILQ_FIRST(net_l)) != NULL) {
		TAILQ_REMOVE(net_l, n, entry);
		network_add(&n->net, 1);
		free(n);
	}
}

void
d3074 1
d3076 2
d3080 29
d3119 2
d3132 4
a3135 2
	u_int32_t	flags = F_PREFIX_ANNOUNCED;
	u_int32_t	i;
d3139 27
@


1.292
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.291 2010/04/13 09:09:48 claudio Exp $ */
d2124 1
d2161 12
a2172 1
		if (req->prefixlen == 32)
@


1.291
log
@Instead of passing AF specific struct kroutes over imsgs use a struct
kroute_full structure that is AF independent and has all information in
it. Simplifies the communication between processes and reduces the number
of imsg types. This is another step to add FIB support to BGP MPLS VPNs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.290 2010/03/30 15:43:30 claudio Exp $ */
d599 9
a607 2
				rib_new(rn.name, rn.flags);
			else
d676 1
a676 1
			/* sync local-RIB first */
d1991 1
a1991 1
		rib.flags |= F_RIB_ACTIVE;
d1993 1
a1993 1
		rib.flags |= F_RIB_INTERNAL;
d1995 1
a1995 1
		rib.flags |= F_RIB_ANNOUNCE;
d1997 1
a1997 1
		rib.flags |= F_RIB_ELIGIBLE;
d1999 1
a1999 1
		rib.flags &= ~F_RIB_ELIGIBLE;
d2222 1
a2222 1
rde_send_kroute(struct prefix *new, struct prefix *old)
d2259 1
a2259 1
	if (imsg_compose(ibuf_main, type, 0, 0, -1, &kr,
@


1.290
log
@Hmpf, aid2af() leftover from the time I did the transition that should not
be there. network X set nexthop Y failed because of this.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.289 2010/03/29 09:06:56 claudio Exp $ */
d2217 1
a2217 2
	struct kroute_label	 kl;
	struct kroute6_label	 kl6;
d2239 16
a2254 44
	switch (addr.aid) {
	case AID_INET:
		bzero(&kl, sizeof(kl));
		kl.kr.prefix.s_addr = addr.v4.s_addr;
		kl.kr.prefixlen = p->prefix->prefixlen;
		if (p->aspath->flags & F_NEXTHOP_REJECT)
			kl.kr.flags |= F_REJECT;
		if (p->aspath->flags & F_NEXTHOP_BLACKHOLE)
			kl.kr.flags |= F_BLACKHOLE;
		if (type == IMSG_KROUTE_CHANGE)
			kl.kr.nexthop.s_addr =
			    p->aspath->nexthop->true_nexthop.v4.s_addr;
		strlcpy(kl.label, rtlabel_id2name(p->aspath->rtlabelid),
		    sizeof(kl.label));
		if (imsg_compose(ibuf_main, type, 0, 0, -1, &kl,
		    sizeof(kl)) == -1)
			fatal("imsg_compose error");
		break;
	case AID_INET6:
		bzero(&kl6, sizeof(kl6));
		memcpy(&kl6.kr.prefix, &addr.v6, sizeof(struct in6_addr));
		kl6.kr.prefixlen = p->prefix->prefixlen;
		if (p->aspath->flags & F_NEXTHOP_REJECT)
			kl6.kr.flags |= F_REJECT;
		if (p->aspath->flags & F_NEXTHOP_BLACKHOLE)
			kl6.kr.flags |= F_BLACKHOLE;
		if (type == IMSG_KROUTE_CHANGE) {
			type = IMSG_KROUTE6_CHANGE;
			memcpy(&kl6.kr.nexthop,
			    &p->aspath->nexthop->true_nexthop.v6,
			    sizeof(struct in6_addr));
		} else
			type = IMSG_KROUTE6_DELETE;
		strlcpy(kl6.label, rtlabel_id2name(p->aspath->rtlabelid),
		    sizeof(kl6.label));
		if (imsg_compose(ibuf_main, type, 0, 0, -1, &kl6,
		    sizeof(kl6)) == -1)
			fatal("imsg_compose error");
		break;
	case AID_VPN_IPv4:
		break;
	default:
		fatal("rde_send_kroute: unhandled AID");
	}
d3008 1
a3008 2
	struct kroute		 k;
	struct kroute6		 k6;
d3016 17
a3032 24
		switch (addr.aid) {
		case AID_INET:
			bzero(&k, sizeof(k));
			k.prefix.s_addr = addr.v4.s_addr;
			k.prefixlen = p->prefix->prefixlen;
			if (p->aspath->peer == peerself)
				k.flags = F_KERNEL;
			if (imsg_compose(ibuf_se_ctl, IMSG_CTL_SHOW_NETWORK, 0,
			    ctx->req.pid, -1, &k, sizeof(k)) == -1)
				log_warnx("network_dump_upcall: "
				    "imsg_compose error");
			break;
		case AID_INET6:
			bzero(&k6, sizeof(k6));
			memcpy(&k6.prefix, &addr.v6, sizeof(k6.prefix));
			k6.prefixlen = p->prefix->prefixlen;
			if (p->aspath->peer == peerself)
				k6.flags = F_KERNEL;
			if (imsg_compose(ibuf_se_ctl, IMSG_CTL_SHOW_NETWORK6, 0,
			    ctx->req.pid, -1, &k6, sizeof(k6)) == -1)
				log_warnx("network_dump_upcall: "
				    "imsg_compose error");
			break;
		}
@


1.289
log
@We always allocate rib ids dynamicaly so there is no need for allowing
fixed id allocation. Makes code simpler.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.288 2010/03/03 13:52:39 claudio Exp $ */
d3010 1
a3010 1
	rde_apply_set(asp, &nc->attrset, aid2af(nc->prefix.aid), peerself, peerself);
@


1.288
log
@Replace enum rib_state with enum reconf_action since their doing the same.
NEW is now REINIT, ACTIVE is KEEP and DELETE and NONE stay the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.287 2010/02/09 13:29:15 claudio Exp $ */
d599 1
a599 1
				rib_new(-1, rn.name, rn.flags);
@


1.287
log
@Don't hardcode the AID to AID_INET6 when sending MP EoR updates.
This will allow AID_VPN_IPv4 to do EoRs as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.286 2010/02/08 17:21:37 claudio Exp $ */
d571 1
a571 1
				ribs[rid].state = RIB_DELETE;
d601 1
a601 1
				ribs[rid].state = RIB_ACTIVE;
d662 1
a662 1
				if (ribs[rid].state == RIB_DELETE)
d664 1
a664 1
				else if (ribs[rid].state == RIB_NEW)
d677 1
a677 1
					if (ribs[i].state == RIB_NEW)
d2432 1
a2432 1
			if (ribs[i].state != RIB_ACTIVE)
@


1.286
log
@Unbreak IPv6 local address lookups. Some idiot aka me optimised a loop and
because of that either the IPv4 or IPv6 local address was not set. Because
of this prefixes were sent out with all zero nexthops.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.285 2010/02/08 17:16:36 claudio Exp $ */
d2660 1
a2660 1
				peer_send_eor(peer, AID_INET6);
@


1.285
log
@It is enough that peer->capa.mp[i] is non zero. It does not need to be 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.284 2010/01/13 06:02:37 claudio Exp $ */
d2825 4
a2828 1
		} else if (ifa->ifa_addr->sa_family == AF_INET6 &&
@


1.284
log
@Add support for BGP MPLS VPN aka RFC 4364. This is only the RDE part so
that it is possible to use OpenBGPD as a route-reflector for VPNv4.
Some clean up of the BGP MP code so that multiple protocols are easier
supported. kroute/kernel support not yet done but comming.
OK henning@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.283 2010/01/11 01:34:35 claudio Exp $ */
d2882 1
a2882 1
		if (peer->capa.mp[i] == 1)
@


1.283
log
@Make sure we do not add trailing garbage while parsing a prefix that has a
prefixlen that is not a multiple of 8. Found while reading the RFC.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.282 2010/01/10 08:32:08 claudio Exp $ */
d54 1
a54 1
int		 rde_get_mp_nexthop(u_char *, u_int16_t, u_int16_t,
d62 2
d90 1
a90 1
void		 rde_update6_queue_runner(void);
d163 1
d316 2
a317 1
		rde_update6_queue_runner();
d431 1
a431 1
				case AID_INET6:
d929 26
d1049 2
a1050 2
		if ((pos = rde_get_mp_nexthop(mpp, mplen, afi, asp)) == -1) {
			log_peer_warnx(&peer->conf, "bad IPv6 nlri prefix");
d1095 36
d1571 1
a1571 1
rde_get_mp_nexthop(u_char *data, u_int16_t len, u_int16_t afi,
d1588 3
a1590 2
	switch (afi) {
	case AFI_IPv6:
a1602 1
		nexthop.aid = AID_INET6;
d1604 2
a1605 1
		asp->nexthop = nexthop_get(&nexthop);
d1607 11
a1617 3
		 * lock the nexthop because it is not yet linked else
		 * withdraws may remove this nexthop which in turn would
		 * cause a use after free error.
d1619 12
a1630 1
		asp->nexthop->refcnt++;
d1632 7
a1638 3
		/* ignore reserved (old SNPA) field as per RFC 4760 */
		totlen += nhlen + 1;
		data += nhlen + 1;
d1640 3
a1642 5
		return (totlen);
	default:
		log_warnx("bad multiprotocol nexthop, bad AF");
		break;
	}
d1644 1
a1644 1
	return (-1);
d1721 55
d2279 4
d2568 1
a2568 1
			    &peer->withdraws, peer);
d2616 1
a2616 1
rde_update6_queue_runner(void)
d2632 1
a2632 1
			b = up_dump_mp_unreach(queue_buf, &len, peer);
d2655 1
a2655 1
			r = up_dump_mp_reach(queue_buf, &len, peer);
@


1.282
log
@Generate a EoR marker in the update list instead of sending it independent
of the actual update dump. This will get us the right barrier and the EoR
is no longer sent way before the actual dump. Currently a nop since graceful
restart is turned off (unless you have announce restart yes in the config).
put it in henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.281 2010/01/10 00:15:09 claudio Exp $ */
d56 2
d1560 26
d1589 2
a1590 7
	int		i;
	u_int8_t	pfxlen;
	u_int16_t	plen;
	union {
		struct in_addr	a32;
		u_int8_t	a8[4];
	}		addr;
d1595 2
a1596 3
	memcpy(&pfxlen, p, 1);
	p += 1;
	plen = 1;
a1598 9
	addr.a32.s_addr = 0;
	for (i = 0; i <= 3; i++) {
		if (pfxlen > i * 8) {
			if (len - plen < 1)
				return (-1);
			memcpy(&addr.a8[i], p++, 1);
			plen++;
		}
	}
a1599 1
	prefix->v4.s_addr = addr.a32.s_addr;
d1602 5
a1606 1
	return (plen);
d1613 1
a1613 1
	int		i;
a1614 1
	u_int16_t	plen;
d1619 2
a1620 3
	memcpy(&pfxlen, p, 1);
	p += 1;
	plen = 1;
a1622 8
	for (i = 0; i <= 15; i++) {
		if (pfxlen > i * 8) {
			if (len - plen < 1)
				return (-1);
			memcpy(&prefix->v6.s6_addr[i], p++, 1);
			plen++;
		}
	}
d1626 5
a1630 1
	return (plen);
@


1.281
log
@Switch rib_dump() to use AID instead of AFs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.280 2010/01/05 08:49:57 claudio Exp $ */
d2397 1
a2397 1
	int			 r, sent, max = RDE_RUNNER_ROUNDS;
d2421 22
a2442 8
			wpos += r;

			if (wpos == 4)
				/*
				 * No packet to send. The 4 bytes are the
				 * needed withdraw and path attribute length.
				 */
				continue;
d2449 4
d2463 1
a2463 1
	int			 sent, max = RDE_RUNNER_ROUNDS / 2;
d2498 6
a2503 3
			b = up_dump_mp_reach(queue_buf, &len, peer);

			if (b == NULL)
d2505 5
d2777 1
a2777 1
		peer_send_eor(peer, aid);
@


1.280
log
@Make sure that all important config variables are synced on a reload in
the SE. This got more important since we use the reload all the time now.
Found out the hard way and fix tested by Laurent CARON
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.279 2009/12/31 15:34:02 claudio Exp $ */
d661 1
a661 1
					    AF_UNSPEC);
d666 1
a666 1
				    AF_UNSPEC);
d675 1
a675 1
					    NULL, AF_UNSPEC);
d2013 1
a2013 1
	ctx->ribctx.ctx_af = ctx->req.af;
d2052 1
a2052 1
	ctx->ribctx.ctx_af = AF_UNSPEC;
a2738 1
	sa_family_t		 af;	/* XXX needs to be replaced with aid */
a2745 2
	af = aid2af(aid);

d2749 1
a2749 1
		rib_dump(&ribs[peer->ribid], rde_up_dump_upcall, peer, af);
@


1.279
log
@Instead of passing the config via arguments to the childs on bootup issue
a config reload as first step in bootup. This allows childs to start with
an empty config and a lot of special cleanup code can bite the dust.
Testing by myself and sthen@@ with a few configs (more testing welcome).
Seems like a good idea henning@@ & sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.278 2009/12/18 15:51:37 claudio Exp $ */
d622 3
@


1.278
log
@Merge rde_filter_community() with community_match() and kill a useless
indirection.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.277 2009/12/16 15:40:55 claudio Exp $ */
d149 2
a150 4
rde_main(struct bgpd_config *config, struct peer *peer_l,
    struct network_head *net_l, struct filter_head *rules,
    struct mrt_head *mrt_l, struct rib_names *rib_n, int pipe_m2r[2],
    int pipe_s2r[2], int pipe_m2s[2], int pipe_s2rctl[2], int debug)
a153 2
	struct peer		*p;
	struct listen_addr	*la;
a154 4
	struct filter_rule	*f;
	struct filter_set	*set;
	struct nexthop		*nh;
	struct rde_rib		*rr;
a155 1
	struct mrt		*mrt;
a168 2
	conf = config;

d189 2
a206 18
	/* peer list, mrt list and listener list are not used in the RDE */
	while ((p = peer_l) != NULL) {
		peer_l = p->next;
		free(p);
	}

	while ((mrt = LIST_FIRST(mrt_l)) != NULL) {
		LIST_REMOVE(mrt, entry);
		free(mrt);
	}

	while ((la = TAILQ_FIRST(config->listen_addrs)) != NULL) {
		TAILQ_REMOVE(config->listen_addrs, la, entry);
		close(la->fd);
		free(la);
	}
	free(config->listen_addrs);

a207 5
	while ((rr = SIMPLEQ_FIRST(&ribnames))) {
		SIMPLEQ_REMOVE_HEAD(&ribnames, entry);
		rib_new(-1, rr->name, rr->flags);
		free(rr);
	}
a212 2
	rules_l = rules;
	network_init(net_l);
d214 6
a221 10
	TAILQ_FOREACH(f, rules, entry) {
		f->peer.ribid = rib_find(f->rib);
		TAILQ_FOREACH(set, &f->set, entry) {
			if (set->type == ACTION_SET_NEXTHOP) {
				nh = nexthop_get(&set->action.nexthop);
				nh->refcnt++;
			}
		}
	}

d625 5
a2536 1
	struct in_addr   id;
d2552 1
a2552 3
	pc.remote_as = conf->as;
	id.s_addr = conf->bgpid;
	snprintf(pc.descr, sizeof(pc.descr), "LOCAL: ID %s", inet_ntoa(id));
a2558 2
	peerself->remote_bgpid = ntohl(conf->bgpid);
	peerself->short_as = conf->short_as;
@


1.277
log
@Implement "set ext-community [delete] subtype key:value" to set and delete
extended communities as specified in RFC 4360. No matching implemented yet
and stuff like * and neighbor-as are neither supported but will be soon.
Looks good henning & sthen, manpage fixed by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.276 2009/12/08 14:03:40 claudio Exp $ */
d1941 1
a1941 1
		    !rde_filter_community(p->aspath, req->community.as,
@


1.276
log
@Big AID change part two. This changes the mp capability into an array of
flags. This makes a lot of code much easier since the comparison is now
trivial. Additionally calculate the negotiated capabilities for a session
in the SE and pass that and only that to the RDE. This makes the decisions
in the RDE a lot easier.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.275 2009/12/01 14:28:05 claudio Exp $ */
d1378 16
@


1.275
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.274 2009/11/11 13:48:34 claudio Exp $ */
d95 2
a96 2
void		 peer_dump(u_int32_t, u_int16_t, u_int8_t);
void		 peer_send_eor(struct rde_peer *, u_int16_t, u_int16_t);
a385 1
	struct rrefresh		 r;
d393 1
d432 1
a432 1
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(r)) {
d436 4
a439 2
			memcpy(&r, imsg.data, sizeof(r));
			peer_dump(imsg.hdr.peerid, r.afi, r.safi);
d768 2
d778 1
a778 3
	u_int8_t		 prefixlen, safi, subtype;
	struct bgpd_addr	 prefix;
	struct mpattr		 mpa;
d877 3
a879 3
		if (peer->capa_received.mp_v4 == SAFI_NONE &&
		    peer->capa_received.mp_v6 != SAFI_NONE) {
			log_peer_warnx(&peer->conf, "bad AFI, IPv4 disabled");
d909 19
a927 9
		switch (afi) {
		case AFI_IPv6:
			if (peer->capa_received.mp_v6 == SAFI_NONE) {
				log_peer_warnx(&peer->conf, "bad AFI, "
				    "IPv6 disabled");
				rde_update_err(peer, ERR_UPDATE,
				    ERR_UPD_OPTATTR, NULL, 0);
				goto done;
			}
d990 3
a992 3
		if (peer->capa_received.mp_v4 == SAFI_NONE &&
		    peer->capa_received.mp_v6 != SAFI_NONE) {
			log_peer_warnx(&peer->conf, "bad AFI, IPv4 disabled");
d1022 16
d1056 2
a1057 10
		switch (afi) {
		case AFI_IPv6:
			if (peer->capa_received.mp_v6 == SAFI_NONE) {
				log_peer_warnx(&peer->conf, "bad AFI, "
				    "IPv6 disabled");
				rde_update_err(peer, ERR_UPDATE,
				    ERR_UPD_OPTATTR, NULL, 0);
				goto done;
			}

d2536 1
a2536 1
	return (peer->capa_announced.as4byte && peer->capa_received.as4byte);
d2689 1
d2703 1
a2703 4
	memcpy(&peer->capa_announced, &sup->capa_announced,
	    sizeof(peer->capa_announced));
	memcpy(&peer->capa_received, &sup->capa_received,
	    sizeof(peer->capa_received));
d2717 4
a2720 1
	peer_dump(id, AFI_ALL, SAFI_ALL);
d2755 1
a2755 1
peer_dump(u_int32_t id, u_int16_t afi, u_int8_t safi)
d2758 1
d2766 8
a2773 23
	if (afi == AFI_ALL || afi == AFI_IPv4)
		if ((safi == SAFI_ALL || safi == SAFI_UNICAST) &&
		    peer->conf.capabilities.mp_v4 != SAFI_NONE) {
			if (peer->conf.announce_type == ANNOUNCE_DEFAULT_ROUTE)
				up_generate_default(rules_l, peer, AF_INET);
			else
				rib_dump(&ribs[peer->ribid], rde_up_dump_upcall,
				    peer, AF_INET);
			if (peer->capa_received.restart &&
			    peer->capa_announced.restart)
				peer_send_eor(peer, AFI_IPv4, SAFI_UNICAST);
		}
	if (afi == AFI_ALL || afi == AFI_IPv6)
		if ((safi == SAFI_ALL || safi == SAFI_UNICAST)) {
			if (peer->conf.announce_type == ANNOUNCE_DEFAULT_ROUTE)
				up_generate_default(rules_l, peer, AF_INET6);
			else
				rib_dump(&ribs[peer->ribid], rde_up_dump_upcall,
				    peer, AF_INET6);
			if (peer->capa_received.restart &&
			    peer->capa_announced.restart)
				peer_send_eor(peer, AFI_IPv6, SAFI_UNICAST);
		}
d2778 1
a2778 1
peer_send_eor(struct rde_peer *peer, u_int16_t afi, u_int16_t safi)
d2780 4
a2783 1
	if (afi == AFI_IPv4 && safi == SAFI_UNICAST) {
d2793 3
@


1.274
log
@Plug two memory leaks in error pathes. Found by parfait. OK henning, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.273 2009/11/02 20:38:15 claudio Exp $ */
d455 2
a456 2
			switch (netconf_s.prefix.af) {
			case AF_INET:
d461 1
a461 1
			case AF_INET6:
d1272 1
a1272 1
		nexthop.af = AF_INET;
d1528 1
a1528 1
		nexthop.af = AF_INET6;
d1580 1
a1580 1
	prefix->af = AF_INET;
d1611 1
a1611 1
	prefix->af = AF_INET6;
d1817 2
a1818 2
		rib.true_nexthop.af = p->prefix->af;
		rib.exit_nexthop.af = p->prefix->af;
d1941 1
a1941 1
	if (addr.af != ctx->req.prefix.af)
d2081 2
a2082 2
	switch (addr.af) {
	case AF_INET:
d2099 1
a2099 1
	case AF_INET6:
d2639 1
a2639 4
			peer->local_v4_addr.af = AF_INET;
			peer->local_v4_addr.v4.s_addr =
			    ((struct sockaddr_in *)ifa->ifa_addr)->
			    sin_addr.s_addr;
d2641 1
a2641 5
		}
	}

	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family == AF_INET6 &&
d2657 1
a2657 7
			peer->local_v6_addr.af = AF_INET6;
			memcpy(&peer->local_v6_addr.v6,
			    &((struct sockaddr_in6 *)ifa->ifa_addr)->
			    sin6_addr, sizeof(struct in6_addr));
			peer->local_v6_addr.scope_id =
			    ((struct sockaddr_in6 *)ifa->ifa_addr)->
			    sin6_scope_id;
d2757 1
a2757 3
		if ((safi == SAFI_ALL || safi == SAFI_UNICAST) &&
		    peer->capa_announced.mp_v6 != SAFI_NONE &&
		    peer->capa_received.mp_v6 != SAFI_NONE) {
d2833 1
a2833 1
	rde_apply_set(asp, &nc->attrset, nc->prefix.af, peerself, peerself);
d2868 3
a2870 1
		if (p->prefix->af == AF_INET) {
a2871 1
			pt_getaddr(p->prefix, &addr);
d2880 2
a2881 2
		}
		if (p->prefix->af == AF_INET6) {
a2882 1
			pt_getaddr(p->prefix, &addr);
d2891 1
d2938 1
a2938 1
	if (a->af != b->sa_family)
d2941 1
a2941 1
	switch (a->af) {
@


1.273
log
@Implement IMSG_CTL_LOG_VERBOSE similar to ospfd. Even though bgpd has almost
no log_debug() it makes more sense to make all routing daemons behave the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.272 2009/10/28 15:54:13 claudio Exp $ */
d1971 1
@


1.272
log
@Free correct buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.271 2009/10/26 09:27:58 claudio Exp $ */
d392 2
a393 1
	int			 n;
d552 5
@


1.271
log
@Better error handling when doing mrt dumps (e.g. when there is no more space
on the disk). Before the SE spinned and the RDE may even crash in these events.
Found by Elisa Jasinska. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.270 2009/10/12 15:19:30 claudio Exp $ */
d363 1
a363 1
		free(mrt);
@


1.270
log
@Only dump AFI/SAFI pairs that are active. For IPv6 check the announced and
received MP capability for IPv4 this does not work when announce capabilities
no is set so check if announce IPv4 none was set in the config.
The capabilities code needs rework since those checks are very error prone.
With this we don't leak unneeded EOR markers for other AFI/SAFI pairs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.269 2009/10/12 13:14:47 claudio Exp $ */
d124 3
a126 2
	struct mrt		 mrt;
	struct rib_context	 ribctx;
d129 1
a129 1
struct mrt_head rde_mrts = LIST_HEAD_INITIALIZER(rde_mrts);
d163 2
a164 1
	struct mrt		*mrt, *xmrt;
d293 3
a295 3
		LIST_FOREACH(mrt, &rde_mrts, entry) {
			if (mrt->wbuf.queued) {
				pfd[i].fd = mrt->wbuf.fd;
d331 4
a334 4
		for (j = PFD_PIPE_COUNT, mrt = LIST_FIRST(&rde_mrts);
		    j < i && mrt != 0; j++) {
			xmrt = LIST_NEXT(mrt, entry);
			if (pfd[j].fd == mrt->wbuf.fd &&
d336 7
a342 6
				mrt_write(mrt);
			if (mrt->wbuf.queued == 0 && 
			    mrt->state == MRT_STATE_REMOVE) {
				close(mrt->wbuf.fd);
				LIST_REMOVE(mrt, entry);
				free(mrt);
d345 1
a345 1
			mrt = xmrt;
d358 5
a362 4
	while ((mrt = LIST_FIRST(&rde_mrts)) != NULL) {
		msgbuf_clear(&mrt->wbuf);
		close(mrt->wbuf.fd);
		LIST_REMOVE(mrt, entry);
d2037 1
a2037 1
	ctx->ribctx.ctx_done = mrt_dump_done;
d2040 1
a2040 1
	LIST_INSERT_HEAD(&rde_mrts, &ctx->mrt, entry);
@


1.269
log
@Send correct EOR updates. peer_send_eor() does not accept the AFI_ALL and
SAFI_ALL shortcuts. This should fix issues with Juniper boxes that started
when I enabled more capabilities by default.
Fix and report by rivo nurges (rix at estpak dot ee) Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.268 2009/10/08 09:27:56 sthen Exp $ */
d2747 2
a2748 1
		if (safi == SAFI_ALL || safi == SAFI_UNICAST) {
d2759 3
a2761 1
		if (safi == SAFI_ALL || safi == SAFI_UNICAST) {
@


1.268
log
@remove an unused variable, ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.267 2009/10/05 12:03:45 claudio Exp $ */
d2753 3
d2764 3
a2767 3

	if (peer->capa_received.restart && peer->capa_announced.restart)
		peer_send_eor(peer, afi, safi);
@


1.267
log
@Load prefixes into new created RIBs at reload time by walking over the
Adj-RIB-In. This only works correctly when softreconfig in is enabled
(which is the default). This is needed to allow dynamic creation of
additional RIBs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.266 2009/10/05 11:35:48 claudio Exp $ */
a2156 1
	size_t			 size;
a2162 2

	size = sizeof(struct bgpd_addr);
@


1.266
log
@draft-ietf-idr-restart is RFC 4724 since quite some time.
Fix function name in a warning message.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.265 2009/08/06 08:53:11 claudio Exp $ */
d84 1
d672 9
a680 1
			/* XXX this needs rework anyway */
d688 4
a691 1
				for (i = 1; i < rib_size; i++)
d694 1
a703 4
			for (rid = 0; rid < rib_size; rid++) {
				if (ribs[rid].state == RIB_DELETE)
					rib_free(&ribs[rid]);
			}
d2260 4
d2291 1
a2291 1
				path_update(&ribs[1], peer, nasp, &addr,
d2301 34
@


1.265
log
@Implement the error handling as proposed in draft-ietf-idr-optional-transitive
for optional transitive attributes. In short if the partial bit is set on
an optional transitive attribute but the attribute fails validation ignore
the attribute or mark the path as ineligible instead of killing the session
with a NOTIFICATION. Tested, input and OK sthen, OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.264 2009/06/29 12:22:16 claudio Exp $ */
d2698 1
a2698 1
		log_warnx("peer_down: unknown peer id %d", id);
d2723 1
a2723 1
/* End-of-RIB marker, draft-ietf-idr-restart-13.txt */
@


1.264
log
@Unfuck mrt table dumps and plug a memory leak while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.263 2009/06/22 11:14:14 sthen Exp $ */
d813 1
a813 8
		/*
		 * if either ATTR_AS4_AGGREGATOR or ATTR_AS4_PATH is present
		 * try to fixup the attributes.
		 * XXX do not fixup if F_ATTR_LOOP is set.
		 */
		if (asp->flags & F_ATTR_AS4BYTE_NEW &&
		    !(asp->flags & F_ATTR_LOOP))
			rde_as4byte_fixup(peer, asp);
d1081 2
a1082 1
	int			 r = 0;
d1092 2
a1093 3
		if (rde_filter(i, &fasp, rules_l, peer, asp, prefix, prefixlen,
		    peer, DIR_IN) == ACTION_DENY)
			goto done;
d1098 11
a1108 3
		rde_update_log("update", i, peer, &fasp->nexthop->exit_nexthop,
		    prefix, prefixlen);
		r += path_update(&ribs[i], peer, fasp, prefix, prefixlen);
a1109 1
done:
d1117 2
d1310 13
a1322 3
		    (rde_as4byte(peer) && attr_len != 8))
			goto bad_len;
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE, 0))
d1338 11
a1348 2
		if ((attr_len & 0x3) != 0)
			goto bad_len;
d1394 8
a1401 2
		if (attr_len != 8)
			goto bad_len;
d1415 6
a1420 4
			 * XXX bad path just mark the full update as not
			 * XXX loop-free the update is no longer eligible and
			 * XXX will not be considered for routing or
			 * XXX redistribution. Something better is needed.
d1422 8
a1429 2
			a->flags |= F_ATTR_LOOP;
			goto optattr;
d1654 8
d1714 4
@


1.263
log
@Log a warning when "enforce remote-as" is triggered. ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.262 2009/06/07 05:56:24 eric Exp $ */
d123 1
a124 1
	struct mrt		*mrt;
d335 1
a335 1
			    mrt->type == MRT_STATE_REMOVE) {
d1960 1
a1960 2
	if ((ctx = calloc(1, sizeof(*ctx))) == NULL ||
	    (ctx->mrt = calloc(1, sizeof(struct mrt))) == NULL) {
d1964 5
a1968 5
	memcpy(ctx->mrt, mrt, sizeof(struct mrt));
	TAILQ_INIT(&ctx->mrt->wbuf.bufs);
	ctx->mrt->wbuf.fd = fd;
	ctx->mrt->type = MRT_STATE_RUNNING;
	id = rib_find(ctx->mrt->rib);
d1970 1
a1970 2
		log_warnx("non existing RIB %s for mrt dump", ctx->mrt->rib);
		free(ctx->mrt);
d1978 1
a1978 1
	ctx->ribctx.ctx_arg = ctx->mrt;
d1980 1
a1980 1
	LIST_INSERT_HEAD(&rde_mrts, ctx->mrt, entry);
@


1.262
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.261 2009/06/07 00:30:23 claudio Exp $ */
d827 2
@


1.261
log
@First attempt at reload support for RIBs. There is some magic that I do
not fully understand but at least no flames are comming out of my test
box anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.260 2009/06/06 21:21:37 claudio Exp $ */
d724 1
a724 1
			if ((fd = imsg_get_fd(ibuf)) == -1)
@


1.260
log
@Fix bgpctl show rib prefix/len command. Problem reported by Insan Praja.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.259 2009/06/06 06:33:15 eric Exp $ */
d558 2
a562 1
	struct mrt		 xmrt;
d565 1
d589 2
d611 11
d691 4
@


1.259
log
@sync bgpd/bgpctl with the common imsg code, making it lib ready as well.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.258 2009/06/06 06:04:10 claudio Exp $ */
a75 1
void		 rde_dump_prefix(struct ctl_show_rib_request *);
d509 1
a516 11
		case IMSG_CTL_SHOW_RIB_PREFIX:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(req)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&req, imsg.data, sizeof(req));
			req.pid = imsg.hdr.pid;
			rde_dump_prefix(&req);
			imsg_compose(ibuf_se_ctl, IMSG_CTL_END, 0, req.pid, -1,
			    NULL, 0);
			break;
a1863 27
rde_dump_prefix(struct ctl_show_rib_request *req)
{
	struct rib_entry	*re;
	u_int			 error;
	u_int16_t		 id;

	if ((id = rib_find(req->rib)) == RIB_FAILED) {
		log_warnx("rde_dump_ctx_new: no such rib %s", req->rib);
		error = CTL_RES_NOSUCHPEER;
		imsg_compose(ibuf_se_ctl, IMSG_CTL_RESULT, 0, req->pid, -1,
		    &error, sizeof(error));
		return;
	}
	if (req->prefixlen == 32) {
		if ((re = rib_lookup(&ribs[id], &req->prefix)) != NULL)
			rde_dump_upcall(re, req);
	} else if (req->flags & F_LONGER) {
		rib_dump(&ribs[id], rde_dump_prefix_upcall, req,
		    req->prefix.af);
	} else {
		if ((re = rib_get(&ribs[id], &req->prefix, req->prefixlen)) !=
		    NULL)
			rde_dump_upcall(re, req);
	}
}

void
d1868 1
d1901 13
@


1.258
log
@Make it possible to select the RIB that a show command should show.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.257 2009/06/06 01:10:29 claudio Exp $ */
d1566 1
a1566 2
	if (imsg_close(ibuf_se, wbuf) == -1)
		fatal("imsg_close error");
d1767 1
a1767 2
	if (imsg_close(ibuf_se_ctl, wbuf) == -1)
		return;
d1786 1
a1786 2
			if (imsg_close(ibuf_se_ctl, wbuf) == -1)
				return;
@


1.257
log
@Some preliminary filter magic to support multiple RIBs on the filters.
It is ugly but does the trick for now. Filters will be rewritten anyway.
The rib specifier only makes sense on from rules. e.g. deny rib OMG from any
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.256 2009/06/06 01:02:51 claudio Exp $ */
d1881 2
d1884 7
a1890 1
	/* XXX other ribs ... */
d1892 1
a1892 1
		if ((re = rib_lookup(&ribs[1], &req->prefix)) != NULL)
d1895 2
a1896 1
		rib_dump(&ribs[1], rde_dump_prefix_upcall, req, req->prefix.af);
d1898 1
a1898 1
		if ((re = rib_get(&ribs[1], &req->prefix, req->prefixlen)) !=
d1910 1
d1919 8
d1931 1
a1931 1
	ctx->ribctx.ctx_rib = &ribs[1]; /* XXX other ribs */
@


1.256
log
@Only generate updates for peers that are member of the RIB that update is
comming from.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.255 2009/06/06 01:00:56 claudio Exp $ */
d62 1
a62 1
void		 rde_update_log(const char *,
d249 1
d626 1
d1086 11
a1096 11
	/* input filter */
	if (rde_filter(&fasp, rules_l, peer, asp, prefix, prefixlen,
	    peer, DIR_IN) == ACTION_DENY)
		goto done;

	if (fasp == NULL)
		fasp = asp;

	rde_update_log("update", peer, &fasp->nexthop->exit_nexthop,
	    prefix, prefixlen);
	for (i = 1; i < rib_size; i++)
d1100 4
a1103 3
	/* free modified aspath */
	if (fasp != asp)
		path_put(fasp);
a1116 1
	rde_update_log("withdraw", peer, NULL, prefix, prefixlen);
d1119 5
a1123 1
		r += prefix_remove(&ribs[i], peer, prefix, prefixlen, 0);
d1572 1
a1572 1
rde_update_log(const char *message,
d1589 1
a1589 1
	log_info("%s AS%s: %s %s%s",
d1805 1
a1805 1
	a = rde_filter(&asp, rules_l, peer, p->aspath, &addr,
d2134 4
a2137 4
		oa = rde_filter(&oasp, rules_l, peer, p->aspath, &addr,
		    pt->prefixlen, p->aspath->peer, DIR_OUT);
		na = rde_filter(&nasp, newrules, peer, p->aspath, &addr,
		    pt->prefixlen, p->aspath->peer, DIR_OUT);
d2178 1
d2193 8
a2200 7
		/* check if prefix changed */
		oa = rde_filter(&oasp, rules_l, peer, asp, &addr,
		    pt->prefixlen, peer, DIR_IN);
		na = rde_filter(&nasp, newrules, peer, asp, &addr,
		    pt->prefixlen, peer, DIR_IN);
		oasp = oasp != NULL ? oasp : asp;
		nasp = nasp != NULL ? nasp : asp;
d2202 13
a2214 15
		if (oa == ACTION_DENY && na == ACTION_DENY)
			/* nothing todo */
			goto done;
		if (oa == ACTION_DENY && na == ACTION_ALLOW) {
			/* update Local-RIB */
			path_update(&ribs[1], peer, nasp, &addr, pt->prefixlen);
			goto done;
		}
		if (oa == ACTION_ALLOW && na == ACTION_DENY) {
			/* remove from Local-RIB */
			prefix_remove(&ribs[1], peer, &addr, pt->prefixlen, 0);
			goto done;
		}
		if (oa == ACTION_ALLOW && na == ACTION_ALLOW) {
			if (path_compare(nasp, oasp) == 0)
d2216 8
a2223 3
			/* send update */
			path_update(&ribs[1], peer, nasp, &addr, pt->prefixlen);
		}
d2226 5
a2230 4
		if (oasp != asp)
			path_put(oasp);
		if (nasp != asp)
			path_put(nasp);
@


1.255
log
@Minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.254 2009/06/05 19:52:32 claudio Exp $ */
d2232 2
d2240 1
a2240 1
rde_generate_updates(struct prefix *new, struct prefix *old)
d2254 2
@


1.254
log
@Make it possible to bind peers to a specified RIB. Now only filters and
bgpctl are missing to have full support of multiple RIBs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.253 2009/06/05 17:36:49 claudio Exp $ */
d665 1
a666 1
			/* XXX this needs rework anyway */
d669 1
a669 1
				AF_UNSPEC);
@


1.253
log
@Change the way we do mrt dumps in the rde (from the retarded only one dump
possible to as many as you like). The mrt dumps are now done with the same
tree walking code as the control messages. Makes the RDE respond a bit faster
and use less memory while dumping.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.252 2009/06/04 22:08:19 claudio Exp $ */
d2478 1
d2634 2
a2635 3
				/* XXX totaly wrong ... */
				rib_dump(&ribs[1], rde_up_dump_upcall, peer,
				    AF_INET);
d2642 2
a2643 2
				/* XXX again wrong rib */
				rib_dump(&ribs[1], rde_up_dump_upcall, peer, AF_INET6);
@


1.252
log
@Make mrt understand alternate RIB plus remove some other static rib references.
There is still a problem with the mrt dumps because we only allow one in the
RDE. This needs some additional work.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.251 2009/06/04 05:29:06 claudio Exp $ */
d41 1
a41 1
#define PFD_MRT_FILE		3
d79 1
a114 1
struct mrt		*mrt;
d123 8
d157 1
a157 1
	struct pollfd		 pfd[4];
d162 4
a165 1
	int			 i, timeout;
a223 1
	mrt = NULL;
d258 12
d271 1
a271 1
		bzero(pfd, sizeof(pfd));
d289 7
a295 5
		i = 3;
		if (mrt && mrt->wbuf.queued) {
			pfd[PFD_MRT_FILE].fd = mrt->wbuf.fd;
			pfd[PFD_MRT_FILE].events = POLLOUT;
			i++;
d328 8
a335 3
		if (pfd[PFD_MRT_FILE].revents & POLLOUT) {
			mrt_write(mrt);
			if (mrt->wbuf.queued == 0) {
d337 1
d339 1
a339 1
				mrt = NULL;
d341 1
d354 7
d571 1
a571 1
	struct mrt		*xmrt;
d573 1
a573 1
	int			 n, reconf_in = 0, reconf_out = 0;
d713 2
a714 8

			xmrt = calloc(1, sizeof(struct mrt));
			if (xmrt == NULL)
				fatal("rde_dispatch_imsg_parent");
			memcpy(xmrt, imsg.data, sizeof(struct mrt));
			TAILQ_INIT(&xmrt->wbuf.bufs);

			if ((xmrt->wbuf.fd = imsg_get_fd(ibuf)) == -1)
d717 5
a721 21
			else if (xmrt->type == MRT_TABLE_DUMP ||
			    xmrt->type == MRT_TABLE_DUMP_MP) {
				u_int16_t id;

				/* do not dump if another is still running */
				id = rib_find(mrt->rib);
				if (id == RIB_FAILED)
					log_warnx("non existing RIB %s for mrt "
					    "dump", mrt->rib);
				else if (mrt == NULL || mrt->wbuf.queued == 0) {
					free(mrt);
					mrt = xmrt;
					mrt_clear_seq();
					rib_dump(&ribs[id], mrt_dump_upcall,
					    mrt, AF_UNSPEC);
					break;
				} else
					log_warnx("dump failed: already in progress");
			}
			close(xmrt->wbuf.fd);
			free(xmrt);
d1936 33
a2809 1
	free(mrt);
@


1.251
log
@Export networks to be redistributed into all ribs for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.250 2009/06/04 04:46:42 claudio Exp $ */
d633 6
a638 3
			if (reconf_out)
				rib_dump(&ribs[1], rde_softreconfig_out, NULL,
				AF_UNSPEC);
d687 2
d690 5
a694 1
				if (mrt == NULL || mrt->wbuf.queued == 0) {
d698 2
a699 2
					rib_dump(&ribs[1], mrt_dump_upcall, mrt,
					    AF_UNSPEC);
d701 2
a702 1
				}
d2071 2
@


1.250
log
@Add "rde rib <name>" to the config and allow the rde to use these other RIBs.
Still a bit hackish, reload is missing and printconf as well. Looks good h@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.249 2009/06/02 01:02:28 claudio Exp $ */
a227 1

d2642 1
d2654 3
a2656 2
	path_update(&ribs[0], peerself, asp, &nc->prefix, nc->prefixlen);
	path_update(&ribs[1], peerself, asp, &nc->prefix, nc->prefixlen);
d2665 2
a2666 1
	u_int32_t	 flags = F_PREFIX_ANNOUNCED;
d2671 3
a2673 4
	prefix_remove(&ribs[0], peerself, &nc->prefix, nc->prefixlen,
	    flags);
	prefix_remove(&ribs[1], peerself, &nc->prefix, nc->prefixlen,
	    flags);
@


1.249
log
@Make show rib as and show rib community use the same dump code as the other
show rib commands. This makes the output sorted by prefix and not some rather
randomly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.248 2009/06/02 00:09:02 claudio Exp $ */
d142 2
a143 2
    struct mrt_head *mrt_l, int pipe_m2r[2], int pipe_s2r[2], int pipe_m2s[2],
    int pipe_s2rctl[2], int debug)
d153 1
d223 6
a228 1
	rib_init();
d1044 2
d1052 1
d1069 2
a1070 1
	r += path_update(&ribs[1], peer, fasp, prefix, prefixlen);
d1086 1
d1091 5
a1095 2
	r += prefix_remove(&ribs[1], peer, prefix, prefixlen, 0);
	r += prefix_remove(&ribs[0], peer, prefix, prefixlen, 0);
@


1.248
log
@Move the rest of the rib dump functions into rde_rib.c where it belongs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.247 2009/06/01 23:54:49 claudio Exp $ */
a74 1
void		 rde_dump_as(struct ctl_show_rib_request *);
a76 1
void		 rde_dump_community(struct ctl_show_rib_request *);
d464 2
a472 11
		case IMSG_CTL_SHOW_RIB_AS:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(req)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&req, imsg.data, sizeof(req));
			req.pid = imsg.hdr.pid;
			rde_dump_as(&req);
			imsg_compose(ibuf_se_ctl, IMSG_CTL_END, 0, req.pid, -1,
			    NULL, 0);
			break;
a483 11
		case IMSG_CTL_SHOW_RIB_COMMUNITY:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(req)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&req, imsg.data, sizeof(req));
			req.pid = imsg.hdr.pid;
			rde_dump_community(&req);
			imsg_compose(ibuf_se_ctl, IMSG_CTL_END, 0, req.pid, -1,
			    NULL, 0);
			break;
d1783 7
a1813 20
rde_dump_as(struct ctl_show_rib_request *req)
{
	extern struct path_table	 pathtable;
	struct rde_aspath		*asp;
	struct prefix			*p;
	u_int32_t			 i;

	for (i = 0; i <= pathtable.path_hashmask; i++) {
		LIST_FOREACH(asp, &pathtable.path_hashtbl[i], path_l) {
			if (!aspath_match(asp->aspath, req->as.type,
			    req->as.as))
				continue;
			/* match found */
			LIST_FOREACH(p, &asp->prefix_h, path_l)
				rde_dump_filter(p, req);
		}
	}
}

void
a1850 20
rde_dump_community(struct ctl_show_rib_request *req)
{
	extern struct path_table	 pathtable;
	struct rde_aspath		*asp;
	struct prefix			*p;
	u_int32_t			 i;

	for (i = 0; i <= pathtable.path_hashmask; i++) {
		LIST_FOREACH(asp, &pathtable.path_hashtbl[i], path_l) {
			if (!rde_filter_community(asp, req->community.as,
			    req->community.type))
				continue;
			/* match found */
			LIST_FOREACH(p, &asp->prefix_h, path_l)
				rde_dump_filter(p, req);
		}
	}
}

void
d1874 2
@


1.247
log
@Use only one list to queue the dump contextes on. Use the list in struct
rib_context instead of the ctl specific rde_dump_ctx to make it more general.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.246 2009/05/27 06:58:15 claudio Exp $ */
a81 2
void		 rde_dump_runner(void);
int		 rde_dump_pending(void);
a124 2
LIST_HEAD(, rib_context) rde_dump_h = LIST_HEAD_INITIALIZER(rde_dump_h);

d261 1
a261 1
		else if (rde_dump_pending())
d313 1
a313 1
			rde_dump_runner();
d1937 1
a1937 2

	LIST_INSERT_HEAD(&rde_dump_h, &ctx->ribctx, entry);
a1946 1
	LIST_REMOVE(&ctx->ribctx, entry);
a1947 17
}

void
rde_dump_runner(void)
{
	struct rib_context	*ctx, *next;

	for (ctx = LIST_FIRST(&rde_dump_h); ctx != NULL; ctx = next) {
		next = LIST_NEXT(ctx, entry);
		rib_dump_r(ctx);
	}
}

int
rde_dump_pending(void)
{
	return (!LIST_EMPTY(&rde_dump_h));
@


1.246
log
@Move update and withdraw code into own functions to simplify the necessary
changes to make multiple RIB functional. Also change the way we account the
prefixes per peer (for maxprefix check). Every prefix that was added to any
RIB is counted. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.245 2009/05/17 14:45:25 claudio Exp $ */
a121 1
	TAILQ_ENTRY(rde_dump_ctx)	entry;
d127 1
a127 1
TAILQ_HEAD(, rde_dump_ctx) rde_dump_h = TAILQ_HEAD_INITIALIZER(rde_dump_h);
d1942 1
a1942 1
	TAILQ_INSERT_TAIL(&rde_dump_h, ctx, entry);
d1952 1
a1952 1
	TAILQ_REMOVE(&rde_dump_h, ctx, entry);
d1959 1
a1959 1
	struct rde_dump_ctx	*ctx, *next;
d1961 3
a1963 3
	for (ctx = TAILQ_FIRST(&rde_dump_h); ctx != NULL; ctx = next) {
		next = TAILQ_NEXT(ctx, entry);
		rib_dump_r(&ctx->ribctx);
d1970 1
a1970 1
	return (!TAILQ_EMPTY(&rde_dump_h));
@


1.245
log
@F_LOCAL and F_ORIGINAL are gone. The Adj-Rib-In is now a distinct tree.
Fix pf table code by checking if the aspath has a pftableid set or not
instead of doing the F_LOCAL dance. This works because the in the
Adj-Rib-In it is impossible to set pftableid.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.244 2009/05/17 13:22:10 claudio Exp $ */
d47 4
d734 1
a734 1
	struct rde_aspath	*asp = NULL, *fasp;
d855 1
a855 4
		peer->prefix_rcvd_withdraw++;
		rde_update_log("withdraw", peer, NULL, &prefix, prefixlen);
		prefix_remove(&ribs[1], peer, &prefix, prefixlen, 0);
		prefix_remove(&ribs[0], peer, &prefix, prefixlen, 0);
d910 1
a910 7
				peer->prefix_rcvd_withdraw++;
				rde_update_log("withdraw", peer, NULL,
				    &prefix, prefixlen);
				prefix_remove(&ribs[1], peer, &prefix,
				    prefixlen, 0);
				prefix_remove(&ribs[0], peer, &prefix,
				    prefixlen, 0);
d958 1
a958 11
		peer->prefix_rcvd_update++;
		/* add original path to the Adj-RIB-In */
		if (peer->conf.softreconfig_in)
			path_update(&ribs[0], peer, asp, &prefix, prefixlen);

		/* input filter */
		if (rde_filter(&fasp, rules_l, peer, asp, &prefix, prefixlen,
		    peer, DIR_IN) == ACTION_DENY) {
			path_put(fasp);
			continue;
		}
a965 1
			path_put(fasp);
a968 10
		if (fasp == NULL)
			fasp = asp;

		rde_update_log("update", peer, &fasp->nexthop->exit_nexthop,
		    &prefix, prefixlen);
		path_update(&ribs[1], peer, fasp, &prefix, prefixlen);

		/* free modified aspath */
		if (fasp != asp)
			path_put(fasp);
d1030 2
a1031 13
				peer->prefix_rcvd_update++;
				/* add original path to the Adj-RIB-In */
				if (peer->conf.softreconfig_in)
					path_update(&ribs[0], peer, asp,
					    &prefix, prefixlen);

				/* input filter */
				if (rde_filter(&fasp, rules_l, peer, asp,
				    &prefix, prefixlen, peer, DIR_IN) ==
				    ACTION_DENY) {
					path_put(fasp);
					continue;
				}
a1039 1
					path_put(fasp);
a1042 12
				if (fasp == NULL)
					fasp = asp;

				rde_update_log("update", peer,
				    &asp->nexthop->exit_nexthop,
				    &prefix, prefixlen);
				path_update(&ribs[1], peer, fasp, &prefix,
				    prefixlen);

				/* free modified aspath */
				if (fasp != asp)
					path_put(fasp);
d1065 49
a1710 1
	rib.rib_cnt = asp->rib_cnt;
d2610 1
@


1.244
log
@Simplify the IMSG_CTL_SHOW_NETWORK case and make it actually work by sending
the imsgs back to the right pid and not some more or less random address.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.243 2009/05/17 12:25:15 claudio Exp $ */
d853 2
a854 2
		prefix_remove(&ribs[1], peer, &prefix, prefixlen, F_LOCAL);
		prefix_remove(&ribs[0], peer, &prefix, prefixlen, F_ORIGINAL);
d913 1
a913 1
				    prefixlen, F_LOCAL);
d915 1
a915 1
				    prefixlen, F_ORIGINAL);
d2209 1
a2209 1
			prefix_remove(&ribs[1], peer, &addr, pt->prefixlen, F_LOCAL);
d2734 1
a2734 1
	    flags | F_LOCAL);
d2736 1
a2736 1
	    flags | F_ORIGINAL);
@


1.243
log
@Rework most of the RDE to allow multiple RIBs. This is mostly preparation
work by changing the way the RDE DB is built. struct prefix and struct
pt_entry are simplified and extended with a rib_entry where the decision
tree is run on. From now on a prefix can only reside on one particular RIB
which simplifies the code a bit. Currently there are two fixed ribs
(adj-rib-in and the local-rib) which needs to be made more dynamic in
upcomming commits.
This is work in progress, the RDE seems to work for me and sthen@@ (no flames
comming out of our testrouters but there is still a lot missing)
Move into the tree to simplify developement -- henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.242 2009/05/11 19:16:21 claudio Exp $ */
a347 1
	sa_family_t		 af = AF_UNSPEC;
a465 8
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(af)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			bzero(&req, sizeof(req));
			memcpy(&req.af, imsg.data, sizeof(af));
			rde_dump_ctx_new(&req, imsg.hdr.pid, imsg.hdr.type);
			break;
d2746 1
a2746 3
	pid_t			 pid;

	memcpy(&pid, ptr, sizeof(pid));
d2759 1
a2759 1
			    pid, -1, &k, sizeof(k)) == -1)
d2771 1
a2771 1
			    pid, -1, &k6, sizeof(k6)) == -1)
@


1.242
log
@Make bgpctl show network print both AF_INET and AF_INET6 as mentioned in the
man page. Problem found by Rod Whitworth. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.241 2009/04/23 19:23:27 claudio Exp $ */
d70 1
a70 1
void		 rde_dump_upcall(struct pt_entry *, void *);
d72 1
a72 1
void		 rde_dump_prefix_upcall(struct pt_entry *, void *);
d77 1
d81 3
a83 3
void		 rde_up_dump_upcall(struct pt_entry *, void *);
void		 rde_softreconfig_out(struct pt_entry *, void *);
void		 rde_softreconfig_in(struct pt_entry *, void *);
d100 1
a100 1
void		 network_dump_upcall(struct pt_entry *, void *);
d119 1
a119 1
	struct pt_context		ptc;
d225 1
d655 1
d657 2
a658 1
				pt_dump(rde_softreconfig_in, NULL, AF_UNSPEC);
d661 2
a662 1
				pt_dump(rde_softreconfig_out, NULL, AF_UNSPEC);
d716 1
a716 1
					pt_dump(mrt_dump_upcall, mrt,
d862 2
a863 2
		prefix_remove(peer, &prefix, prefixlen, F_LOCAL);
		prefix_remove(peer, &prefix, prefixlen, F_ORIGINAL);
d921 4
a924 4
				prefix_remove(peer, &prefix, prefixlen,
				    F_LOCAL);
				prefix_remove(peer, &prefix, prefixlen,
				    F_ORIGINAL);
d975 1
a975 1
			path_update(peer, asp, &prefix, prefixlen, F_ORIGINAL);
d999 1
a999 1
		path_update(peer, fasp, &prefix, prefixlen, F_LOCAL);
d1068 2
a1069 2
					path_update(peer, asp, &prefix,
					    prefixlen, F_ORIGINAL);
d1096 2
a1097 2
				path_update(peer, fasp, &prefix, prefixlen,
				    F_LOCAL);
d1721 1
a1721 1
	rib.adjrib_cnt = asp->adjrib_cnt;
d1742 1
a1742 1
	if (p->prefix->active == p)
d1817 2
a1818 3
	if ((req->flags & F_CTL_ADJ_IN && p->flags & F_ORIGINAL) ||
	    (!(req->flags & (F_CTL_ADJ_IN|F_CTL_ADJ_OUT)) &&
	    p->flags & F_LOCAL)) {
d1822 2
a1823 2
	} else if (req->flags & F_CTL_ADJ_OUT && p->flags & F_LOCAL) {
		if (p->prefix->active != p)
a1825 1

d1835 1
a1835 1
rde_dump_upcall(struct pt_entry *pt, void *ptr)
d1838 1
a1838 1
	struct ctl_show_rib_request	*req = ptr;
d1840 2
a1841 2
	LIST_FOREACH(p, &pt->prefix_h, prefix_l)
		rde_dump_filter(p, req);
d1865 1
a1865 1
rde_dump_prefix_upcall(struct pt_entry *pt, void *ptr)
d1867 4
a1870 3
	struct ctl_show_rib_request	*req = ptr;
	struct prefix			*p;
	struct bgpd_addr		 addr;
d1872 1
d1874 1
a1874 1
	if (addr.af != req->prefix.af)
d1876 1
a1876 1
	if (req->prefixlen > pt->prefixlen)
d1878 3
a1880 3
	if (!prefix_compare(&req->prefix, &addr, req->prefixlen))
		LIST_FOREACH(p, &pt->prefix_h, prefix_l)
			rde_dump_filter(p, req);
d1886 1
a1886 1
	struct pt_entry	*pt;
d1888 1
d1890 2
a1891 2
		if ((pt = pt_lookup(&req->prefix)) != NULL)
			rde_dump_upcall(pt, req);
d1893 1
a1893 1
		pt_dump(rde_dump_prefix_upcall, req, req->prefix.af);
d1895 3
a1897 2
		if ((pt = pt_get(&req->prefix, req->prefixlen)) != NULL)
			rde_dump_upcall(pt, req);
d1938 15
a1952 4
	ctx->ptc.count = RDE_RUNNER_ROUNDS;
	ctx->af = ctx->req.af;
	if (ctx->af == AF_UNSPEC)
		ctx->af = AF_INET;
d1958 11
d1975 1
a1975 24
		if (ctx->ptc.done) {
			imsg_compose(ibuf_se_ctl, IMSG_CTL_END, 0, ctx->req.pid,
			    -1, NULL, 0);
			TAILQ_REMOVE(&rde_dump_h, ctx, entry);
			free(ctx);
			continue;
		}
		switch (ctx->req.type) {
		case IMSG_CTL_SHOW_NETWORK:
			pt_dump_r(network_dump_upcall, &ctx->req.pid,
			    ctx->af, &ctx->ptc);
			break;
		case IMSG_CTL_SHOW_RIB:
			pt_dump_r(rde_dump_upcall, &ctx->req, ctx->af,
			    &ctx->ptc);
			break;
		default:
			fatalx("rde_dump_runner: unsupported imsg type");
		}
		if (ctx->ptc.done && ctx->req.af == AF_UNSPEC &&
		    ctx->af == AF_INET) {
			ctx->ptc.done = 0;
			ctx->af = AF_INET6;
		}
d2120 1
a2120 1
rde_softreconfig_out(struct pt_entry *pt, void *ptr)
d2122 2
a2123 1
	struct prefix		*p = pt->active;
d2132 1
d2178 1
a2178 1
rde_softreconfig_in(struct pt_entry *pt, void *ptr)
d2181 1
d2187 1
d2189 2
a2190 4
	for (p = LIST_FIRST(&pt->prefix_h); p != NULL; p = np) {
		np = LIST_NEXT(p, prefix_l);
		if (!(p->flags & F_ORIGINAL))
			continue;
d2196 1
d2213 1
a2213 1
			path_update(peer, nasp, &addr, pt->prefixlen, F_LOCAL);
d2218 1
a2218 1
			prefix_remove(peer, &addr, pt->prefixlen, F_LOCAL);
d2225 1
a2225 1
			path_update(peer, nasp, &addr, pt->prefixlen, F_LOCAL);
d2242 1
a2242 1
rde_up_dump_upcall(struct pt_entry *pt, void *ptr)
d2246 1
a2246 1
	if (pt->active == NULL)
d2248 1
a2248 1
	up_generate_updates(rules_l, peer, pt->active, NULL);
d2646 3
a2648 1
				pt_dump(rde_up_dump_upcall, peer, AF_INET);
d2655 2
a2656 1
				pt_dump(rde_up_dump_upcall, peer, AF_INET6);
a2715 1
	u_int32_t		 flags = F_PREFIX_ANNOUNCED;
d2724 1
a2724 1
		flags |= F_ANN_DYNAMIC;
d2727 2
a2728 2
	path_update(peerself, asp, &nc->prefix, nc->prefixlen, flags | F_ORIGINAL);
	path_update(peerself, asp, &nc->prefix, nc->prefixlen, flags | F_LOCAL);
d2742 4
a2745 2
	prefix_remove(peerself, &nc->prefix, nc->prefixlen, flags | F_LOCAL);
	prefix_remove(peerself, &nc->prefix, nc->prefixlen, flags | F_ORIGINAL);
d2749 1
a2749 1
network_dump_upcall(struct pt_entry *pt, void *ptr)
d2759 1
a2759 1
	LIST_FOREACH(p, &pt->prefix_h, prefix_l) {
@


1.241
log
@Rework the way we handle announced networks. Instead of two freak rde_peers
use one that is less freaky. Merge bgpctl and config networks into one tree.
First step of a larger change in the RDE and this goes now in to allow to
move forward.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.240 2009/03/18 19:45:09 claudio Exp $ */
d1965 3
a1967 1
		if (ctx->ptc.done && ctx->req.af == AF_UNSPEC)
d1969 1
@


1.240
log
@Correctly check for MRT_TABLE_DUMP_MP and don't send the config to the SE.
Make mrt table-mp dumps actually work. Found on the plane from NRT to ZRH.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.239 2009/03/13 16:05:40 claudio Exp $ */
a99 1
void		 network_flush(int);
d108 1
a108 2
struct rde_peer		 peerself;
struct rde_peer		 peerdynamic;
d440 2
a441 1
			network_flush(0);
d631 1
a631 1
			prefix_network_clean(&peerself, reloadtime);
d635 2
a1827 2
		LIST_FOREACH(peer, &peerlist, peer_l)
			rde_dump_filterout(peer, p, req);
d2124 2
d2253 2
d2272 2
d2320 2
d2343 2
d2407 2
d2422 13
a2686 1
	struct in_addr   id;
a2688 15
	bzero(&peerself, sizeof(peerself));
	peerself.state = PEER_UP;
	peerself.remote_bgpid = ntohl(conf->bgpid);
	id.s_addr = conf->bgpid;
	peerself.conf.remote_as = conf->as;
	peerself.short_as = conf->short_as;
	snprintf(peerself.conf.descr, sizeof(peerself.conf.descr),
	    "LOCAL: ID %s", inet_ntoa(id));
	bzero(&peerdynamic, sizeof(peerdynamic));
	peerdynamic.state = PEER_UP;
	peerdynamic.remote_bgpid = ntohl(conf->bgpid);
	peerdynamic.conf.remote_as = conf->as;
	peerdynamic.short_as = conf->short_as;
	snprintf(peerdynamic.conf.descr, sizeof(peerdynamic.conf.descr),
	    "LOCAL: ID %s", inet_ntoa(id));
d2701 1
a2701 1
	struct rde_peer		*p;
d2709 2
d2712 3
a2714 8
	if (flagstatic)
		p = &peerself;
	else
		p = &peerdynamic;

	rde_apply_set(asp, &nc->attrset, nc->prefix.af, p, p);
	path_update(p, asp, &nc->prefix, nc->prefixlen, F_ORIGINAL);
	path_update(p, asp, &nc->prefix, nc->prefixlen, F_LOCAL);
d2723 1
a2723 1
	struct rde_peer	*p;
d2725 2
a2726 4
	if (flagstatic)
		p = &peerself;
	else
		p = &peerdynamic;
d2728 2
a2729 2
	prefix_remove(p, &nc->prefix, nc->prefixlen, F_LOCAL);
	prefix_remove(p, &nc->prefix, nc->prefixlen, F_ORIGINAL);
d2751 1
a2751 1
			if (p->aspath->peer == &peerself)
d2763 1
a2763 1
			if (p->aspath->peer == &peerself)
a2772 9
void
network_flush(int flagstatic)
{
	if (flagstatic)
		prefix_network_clean(&peerself, time(NULL));
	else
		prefix_network_clean(&peerdynamic, time(NULL));
}

a2777 1
	struct rde_aspath	*asp, *nasp;
a2791 15

	/* free announced network prefixes */
	peerself.remote_bgpid = 0;
	peerself.state = PEER_DOWN;
	for (asp = LIST_FIRST(&peerself.path_h); asp != NULL; asp = nasp) {
		nasp = LIST_NEXT(asp, peer_l);
		path_remove(asp);
	}

	peerdynamic.remote_bgpid = 0;
	peerdynamic.state = PEER_DOWN;
	for (asp = LIST_FIRST(&peerdynamic.path_h); asp != NULL; asp = nasp) {
		nasp = LIST_NEXT(asp, peer_l);
		path_remove(asp);
	}
@


1.239
log
@No need for a line break, makes code a bit more compact.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.238 2009/03/13 06:25:04 claudio Exp $ */
d703 2
a704 1
			else if (xmrt->type == MRT_TABLE_DUMP) {
@


1.238
log
@Next step in mrt cleanup. Switch buf_write to a smarter version of itself.
Doing more the stuff msgbuf_write does and switch the only user -- mrt --
over to use this simpler way of writing out stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.237 2009/03/13 05:43:51 claudio Exp $ */
d2606 1
a2606 2
			if (peer->conf.announce_type ==
			    ANNOUNCE_DEFAULT_ROUTE)
d2613 1
a2613 2
			if (peer->conf.announce_type ==
			    ANNOUNCE_DEFAULT_ROUTE)
@


1.237
log
@Move mrt code over to use the msgbuf way of queuing buffers instead of rolling
an own version. More cleanup to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.236 2009/03/13 04:19:43 claudio Exp $ */
d303 3
a305 1
			if (mrt_write(mrt) == -1) {
d308 1
a308 2
			} else if (mrt->wbuf.queued == 0)
				close(mrt->wbuf.fd);
@


1.236
log
@More paranoia when parsing empty updates. Make sure they are really empty and
don't come with some additional stuff attached to them.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.235 2009/01/13 21:35:16 sthen Exp $ */
d266 2
a267 2
		if (mrt && mrt->queued) {
			pfd[PFD_MRT_FILE].fd = mrt->fd;
d306 2
a307 2
			} else if (mrt->queued == 0)
				close(mrt->fd);
d697 1
a697 1
			TAILQ_INIT(&xmrt->bufs);
d699 1
a699 1
			if ((xmrt->fd = imsg_get_fd(ibuf)) == -1)
d702 1
a702 2

			if (xmrt->type == MRT_TABLE_DUMP) {
d704 1
a704 1
				if (mrt == NULL || mrt->queued == 0) {
d713 1
a713 1
			close(xmrt->fd);
@


1.235
log
@Replace NEW_ASPATH/NEW_AGGREGATOR with the naming from RFC4893,
AS4_PATH/AS4_AGGREGATOR. No binary change.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.234 2008/12/28 15:19:21 claudio Exp $ */
d859 8
a866 1
	if (attrpath_len == 0) /* 0 = no NLRI information in this message */
d868 1
@


1.234
log
@Add a ugly workaround for the problem where an invalid AS4_PATH is passed
over mulitple hops and causes bgpd to close the connection. This is what
the RFC requires us to do but the result is a DoS against all OpenBGPD
routers when somebody injects such a bad optional transitive attribute
because the intermediate routers don't give a damn about it.
As a result we now ignore such bad prefixes and don't allow them in the
decision process. The handling of optional transitive attributes needs to
be rethinked because all of them can be abused in such a way.
Idea OK by a few + henning@@, tested myself against my crappy regress test
suite that needs way more work.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.233 2008/12/12 16:02:49 claudio Exp $ */
d798 1
a798 1
		 * if either ATTR_NEW_AGGREGATOR or ATTR_NEW_ASPATH is present
d1339 1
a1339 1
	case ATTR_NEW_AGGREGATOR:
d1347 1
a1347 1
	case ATTR_NEW_ASPATH:
d1588 2
a1589 2
	nasp = attr_optget(a, ATTR_NEW_ASPATH);
	naggr = attr_optget(a, ATTR_NEW_AGGREGATOR);
d1604 1
a1604 1
			/* per RFC draft ignore NEW_ASPATH and NEW_AGGREGATOR */
d1619 1
a1619 1
	/* there is no need for NEW_AGGREGATOR any more */
d1623 1
a1623 1
	/* merge NEW_ASPATH with ASPATH */
@


1.233
log
@Follow RFC 4271 more closely by sending the correct error back for optional
attributes and use the correct lenght in some other error cases.
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.232 2008/06/15 10:03:46 claudio Exp $ */
d800 1
d802 2
a803 1
		if (asp->flags & F_ATTR_AS4BYTE_NEW)
d1352 10
a1361 4
			/* XXX draft does not specify how to handle errors */
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,
			    op, len);
			return (-1);
@


1.232
log
@Paranoia check. Make sure that the 2 len bytes are actually available.
Another easy M hiding in my bgp source forest.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.231 2008/05/02 13:49:34 claudio Exp $ */
d1171 1
a1171 1
			    op, attr_len);
d1178 1
a1178 1
			    op, attr_len);
d1225 1
a1225 1
			    op, attr_len);
d1351 2
a1352 2
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_ASPATH,
			    NULL, 0);
@


1.232.2.1
log
@Bring in from reliability fix from -current rev. 1.234
OK henning@@ sthen@@

Add a ugly workaround for the problem where an invalid AS4_PATH is passed
over mulitple hops and causes bgpd to close the connection. This is what
the RFC requires us to do but the result is a DoS against all OpenBGPD
routers when somebody injects such a bad optional transitive attribute
because the intermediate routers don't give a damn about it.
As a result we now ignore such bad prefixes and don't allow them in the
decision process. The handling of optional transitive attributes needs to
be rethinked because all of them can be abused in such a way.
Idea OK by a few + henning@@, tested myself against my crappy regress test
suite that needs way more work.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.234 2008/12/28 15:19:21 claudio Exp $ */
a799 1
		 * XXX do not fixup if F_ATTR_LOOP is set.
d801 1
a801 2
		if (asp->flags & F_ATTR_AS4BYTE_NEW &&
		    !(asp->flags & F_ATTR_LOOP))
d1171 1
a1171 1
			    op, len);
d1178 1
a1178 1
			    op, len);
d1225 1
a1225 1
			    op, len);
d1350 4
a1353 10
			/*
			 * XXX RFC does not specify how to handle errors.
			 * XXX Instead of dropping the session because of a
			 * XXX bad path just mark the full update as not
			 * XXX loop-free the update is no longer eligible and
			 * XXX will not be considered for routing or
			 * XXX redistribution. Something better is needed.
			 */
			a->flags |= F_ATTR_LOOP;
			goto optattr;
@


1.231
log
@Fix logic when setting the F_RIB_ELIGIBLE flag. A path with a NULL nexthop
is localy originated and so is eligible by definition.
Noticed and fix tested by Christian, bsd (at) cleondra (dot) ch
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.230 2008/02/26 19:58:51 claudio Exp $ */
d750 5
@


1.230
log
@Ignore and drop path attributes with a type code of 0 instead of sending an
error back. This increases robustness without causing any issues. The RFC
does not forbid the use of 0 in the type code but it is not explicitly
allowed and the type code list at IANA does not mention 0 at all.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.229 2007/11/27 01:13:54 claudio Exp $ */
d1720 1
a1720 1
	if (asp->nexthop != NULL && asp->nexthop->state == NEXTHOP_REACH)
a2848 1

@


1.230.2.1
log
@Bring in from reliability fix from -current rev. 1.234
OK henning@@ sthen@@

Add a ugly workaround for the problem where an invalid AS4_PATH is passed
over mulitple hops and causes bgpd to close the connection. This is what
the RFC requires us to do but the result is a DoS against all OpenBGPD
routers when somebody injects such a bad optional transitive attribute
because the intermediate routers don't give a damn about it.
As a result we now ignore such bad prefixes and don't allow them in the
decision process. The handling of optional transitive attributes needs to
be rethinked because all of them can be abused in such a way.
Idea OK by a few + henning@@, tested myself against my crappy regress test
suite that needs way more work.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.230 2008/02/26 19:58:51 claudio Exp $ */
a794 1
		 * XXX do not fixup if F_ATTR_LOOP is set.
d796 1
a796 2
		if (asp->flags & F_ATTR_AS4BYTE_NEW &&
		    !(asp->flags & F_ATTR_LOOP))
d1166 1
a1166 1
			    op, len);
d1173 1
a1173 1
			    op, len);
d1220 1
a1220 1
			    op, len);
d1345 4
a1348 10
			/*
			 * XXX RFC does not specify how to handle errors.
			 * XXX Instead of dropping the session because of a
			 * XXX bad path just mark the full update as not
			 * XXX loop-free the update is no longer eligible and
			 * XXX will not be considered for routing or
			 * XXX redistribution. Something better is needed.
			 */
			a->flags |= F_ATTR_LOOP;
			goto optattr;
@


1.229
log
@Prefixes or actually pathes that would cause a rooting loops should not be
dropped when parsed but instead be added to the RIB marked as not eligible.
So the decision process does not pick them up as a valid route.
Tested and some ideas by Tony Sarendal (tony (at) polarcap (dot) org)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.228 2007/09/16 15:20:50 claudio Exp $ */
d1157 2
a1158 2
		rde_update_err(peer, ERR_UPDATE, ERR_UPD_UNSPECIFIC, NULL, 0);
		return (-1);
@


1.228
log
@log_fmt_peer() does not use a static buffer so it is necessary to free the
string that it returned later. rde_update_log() did not do that.
Memory leak found and diff provided by Mike Belopuhov.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.227 2007/06/19 09:44:55 pyr Exp $ */
d62 1
a62 1
int		 rde_reflector(struct rde_peer *, struct rde_aspath *);
d809 1
a809 4
		if (rde_reflector(peer, asp) != 1) {
			error = 0;
			goto done;
		}
d920 2
a921 4
	if (peer->conf.ebgp && !aspath_loopfree(asp->aspath, conf->as)) {
		error = 0;
		goto done;
	}
d1619 1
a1619 1
int
d1629 1
a1629 1
		if (memcmp(&conf->bgpid, a->data, sizeof(conf->bgpid)) == 0)
d1631 3
a1633 1
			return (0);
d1651 4
a1654 2
				    sizeof(conf->clusterid)) == 0)
					return (0);
a1672 1
	return (1);
d1720 1
a1720 1
	if (asp->nexthop == NULL || asp->nexthop->state == NEXTHOP_REACH)
d1722 2
@


1.227
log
@Ignore SIGHUP in bgpd's children to allow the use of pkill -1 bgpd for
reloading.

``yeah that is good'' henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.226 2007/05/11 11:27:59 claudio Exp $ */
d1545 1
d1557 1
d1559 1
a1559 1
	    log_fmt_peer(&peer->conf), log_as(peer->conf.remote_as), message,
d1562 1
@


1.226
log
@Various spelling fixes from Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.225 2007/04/23 13:04:24 claudio Exp $ */
d189 1
@


1.225
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.224 2007/04/06 18:03:50 claudio Exp $ */
d703 1
a703 1
				/* do not dump if a other is still running */
d857 1
a857 1
	/* withdraw MP_UNREACH_NRLI if available */
@


1.224
log
@Count the updates and withdraws for additional statisic gathering.
Discussed with henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.223 2007/03/28 12:33:32 henning Exp $ */
d61 1
d791 7
d1126 1
a1126 1
	u_char		*op = p;
d1128 1
a1128 1
	u_int16_t	 attr_len;
d1187 1
a1187 1
		if (aspath_verify(p, attr_len) != 0) {
d1194 5
d1200 3
a1202 1
		a->aspath = aspath_get(p, attr_len);
d1271 2
a1272 1
		if (attr_len != 6)
d1276 12
d1336 20
d1544 1
a1544 1
	char		*nexthop = NULL;
d1551 2
a1552 4
		if (asprintf(&nexthop, " via %s",
		    log_addr(next)) == -1)
			nexthop = NULL;

d1555 3
a1557 3
	log_info("neighbor %s (AS%u) %s %s %s",
	    log_addr(&peer->conf.remote_addr), peer->conf.remote_as, message,
	    p ? p : "out of memory", nexthop ? nexthop : "");
d1559 1
a1559 1
	free(nexthop);
d1564 54
a1619 1

d2330 1
a2330 1
u_int16_t
d2352 6
d2515 1
d2647 1
d2654 1
@


1.223
log
@add IMSG_CTL_SHOW_RIB_COMMUNITY, rib by given community
mostly from rivo nurges <rix@@estpak.ee>, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.222 2007/03/16 14:06:57 claudio Exp $ */
d520 1
a520 1
			if (peer != NULL)
d522 9
d840 1
d890 1
d946 1
d1039 1
@


1.222
log
@A few more s/2858/4760/ and use RFC <number> everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.221 2007/03/16 13:52:30 claudio Exp $ */
d73 1
d501 11
d1754 20
@


1.221
log
@Update multiprotocol extension code to RFC 4760. This actually removes
a few things we actually never realy cared about.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.220 2007/03/12 15:49:54 claudio Exp $ */
d793 1
a793 1
			 * the rfc does not mention what we should do in
@


1.220
log
@When running show commands that are restarted make sure that we either
have pending imsgs to send or that we reduce the poll timout to 0. This
fixes hanging and extrem slow performing bgpctl show rib commands.
Found by Jon Morby additional testing by Stuart Henderson. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.219 2007/02/22 08:34:18 henning Exp $ */
d1369 3
a1371 2
		totlen += nhlen;
		data += nhlen;
d1373 1
a1373 5
		if (*data != 0) {
			log_warnx("SNPA are not supported for IPv6");
			return (-1);
		}
		return (++totlen);
d2429 1
a2429 2
		if (safi == SAFI_ALL || safi == SAFI_UNICAST ||
		    safi == SAFI_BOTH) {
d2437 1
a2437 2
		if (safi == SAFI_ALL || safi == SAFI_UNICAST ||
		    safi == SAFI_BOTH) {
@


1.219
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.218 2007/01/26 17:40:49 claudio Exp $ */
d76 1
d155 1
a155 1
	int			 i;
d243 1
d259 2
d269 1
a269 1
		if (poll(pfd, i, INFTIM) == -1) {
d1802 6
@


1.219.2.1
log
@From claudio@@
> When running show commands that are restarted make sure that we either
> have pending imsgs to send or that we reduce the poll timout to 0. This
> fixes hanging and extrem slow performing bgpctl show rib commands.
> Found by Jon Morby additional testing by Stuart Henderson. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.219 2007/02/22 08:34:18 henning Exp $ */
a75 1
int		 rde_dump_pending(void);
d154 1
a154 1
	int			 i, timeout;
a241 1
		timeout = INFTIM;
a256 2
		else if (rde_dump_pending())
			timeout = 0;
d265 1
a265 1
		if (poll(pfd, i, timeout) == -1) {
a1797 6
}

int
rde_dump_pending(void)
{
	return (!TAILQ_EMPTY(&rde_dump_h));
@


1.218
log
@Massiv rework of the control imsg flow. Main changes:
- dedicated pipe between the SE and the RDE for control messages
- restartable RB tree dumps in the RDE
- queuing limits both in the SE and RDE
The result is a dramatic decrease of memory consumption on operations like
bgpctl show rib. Previously all messages where first stored in the RDE
then passed to the SE where they got queued in case bgpctl was not fast enough.
Now only a small number of messages is generated and passed to the SE and
the SE has an additional limit instead of acting like an infinite buffer.
Without this the bgpd on bgpd.networx.ch would not survive a single minute.
looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.217 2007/01/24 13:24:51 claudio Exp $ */
d1672 1
a1672 1
		       	if ((peer = peer_get(req->peerid)) != NULL)
d1774 1
a1774 1
	for(ctx = TAILQ_FIRST(&rde_dump_h); ctx != NULL; ctx = next) {
d1998 1
a1998 1
	for(p = LIST_FIRST(&pt->prefix_h); p != NULL; p = np) {
@


1.217
log
@Lock the nexthop while parsing an update by increasing the reference count.
This is needed because the nexthop is not yet linked to the aspath attributes
and so a withdraw in the same update imsg could remove this nexthop which in
turn causes a use after free error when the prefix is added later on.
The order of parsing (attributes, withdraws, prefixes instead of withdraws,
attributes, prefixes) was reversed for multiprotocol support.
This should fix all strange nexthop crashes seen by various people.
Tested and OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.216 2007/01/04 12:43:36 claudio Exp $ */
d38 1
a38 1
#define	PFD_PIPE_MAIN		0
d40 2
a41 1
#define PFD_MRT_FILE		2
d62 1
d73 4
d110 1
d115 9
d144 1
a144 1
    int debug)
d150 1
a150 1
	struct pollfd		 pfd[3];
d188 1
d195 1
d199 1
d253 6
a258 1
		i = 2;
d287 8
d305 2
a312 1
	msgbuf_write(&ibuf_se->w);
d315 2
a316 1
	msgbuf_write(&ibuf_main->w);
a338 1
	pid_t			 pid;
d462 3
a464 5
			pid = imsg.hdr.pid;
			memcpy(&af, imsg.data, sizeof(af));
			pt_dump(network_dump_upcall, &pid, af);
			imsg_compose(ibuf_se, IMSG_CTL_END, 0, pid, -1,
			    NULL, 0);
d472 1
a472 4
			req.pid = imsg.hdr.pid;
			pt_dump(rde_dump_upcall, &req, req.af);
			imsg_compose(ibuf_se, IMSG_CTL_END, 0, req.pid, -1,
			    NULL, 0);
d482 1
a482 1
			imsg_compose(ibuf_se, IMSG_CTL_END, 0, req.pid, -1,
d493 1
a493 1
			imsg_compose(ibuf_se, IMSG_CTL_END, 0, req.pid, -1,
d506 1
a506 1
			imsg_compose(ibuf_se, IMSG_CTL_SHOW_NEIGHBOR, 0,
d510 1
a510 1
			imsg_compose(ibuf_se, IMSG_CTL_END, 0, imsg.hdr.pid,
d514 1
a514 1
			imsg_compose(ibuf_se, IMSG_CTL_SHOW_RIB_MEM, 0,
d1597 1
a1597 1
	if ((wbuf = imsg_create(ibuf_se, IMSG_CTL_SHOW_RIB, 0, pid,
d1604 1
a1604 1
	if (imsg_close(ibuf_se, wbuf) == -1)
d1611 3
a1613 2
			if ((wbuf = imsg_create(ibuf_se, IMSG_CTL_SHOW_RIB_ATTR,
			    0, pid, attr_optlen(a))) == NULL)
d1624 1
a1624 1
			if (imsg_close(ibuf_se, wbuf) == -1)
d1744 56
d2085 1
a2085 1
	int			 r, sent;
d2122 2
a2123 1
	} while (sent != 0);
d2131 1
a2131 1
	int			 sent;
d2151 2
a2152 1
	} while (sent != 0);
d2155 1
d2172 2
a2173 1
	} while (sent != 0);
d2568 2
a2569 2
			if (imsg_compose(ibuf_se, IMSG_CTL_SHOW_NETWORK, 0, pid,
			    -1, &k, sizeof(k)) == -1)
d2580 1
a2580 1
			if (imsg_compose(ibuf_se, IMSG_CTL_SHOW_NETWORK6, 0,
@


1.216
log
@Do not run rde_shutdown() unless bgpd is started with -d.
On some of my systems rde_shutdown() takes more than 3min doing nothing more
than calling free(3) over and over again.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.215 2006/12/12 10:19:44 claudio Exp $ */
d679 1
a679 1
	int			 pos = 0;
d723 2
a724 4
			    &mpa)) < 0) {
				path_put(asp);
				return (-1);
			}
d734 1
a734 2
			path_put(asp);
			return (-1);
d744 1
a744 2
				path_put(asp);
				return (-1);
d748 2
a749 2
			path_put(asp);
			return (0);
d767 1
a767 3
			if (attrpath_len != 0)
				path_put(asp);
			return (-1);
d773 1
a773 3
			if (attrpath_len != 0)
				path_put(asp);
			return (-1);
d784 1
a784 3
			if (attrpath_len != 0)
				path_put(asp);
			return (-1);
d812 1
a812 2
				path_put(asp);
				return (-1);
d822 1
a822 2
					path_put(asp);
					return (-1);
d830 1
a830 2
					path_put(asp);
					return (-1);
d850 2
a851 2
			path_put(asp);
			return (0);
d860 2
a861 2
		path_put(asp);
		return (0);
d871 1
a871 2
			path_put(asp);
			return (-1);
d877 1
a877 2
			path_put(asp);
			return (-1);
d888 1
a888 2
			path_put(asp);
			return (-1);
a907 1
			path_put(asp);
d909 1
a909 1
			return (-1);
d937 1
d939 5
d948 1
a948 2
			path_put(asp);
			return (-1);
d960 1
a960 2
				path_put(asp);
				return (-1);
d971 1
a971 2
					path_put(asp);
					return (-1);
d977 1
a977 2
					path_put(asp);
					return (-1);
a1002 1
					path_put(asp);
d1004 1
a1004 1
					return (-1);
d1027 10
a1036 2
	/* need to free allocated attribute memory that is no longer used */
	path_put(asp);
d1038 1
a1038 1
	return (0);
d1156 6
d1330 6
@


1.215
log
@Kill peer_remove(). This function is only used once so inline it there.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.214 2006/12/08 22:31:16 itojun Exp $ */
d127 2
a128 1
    struct mrt_head *mrt_l, int pipe_m2r[2], int pipe_s2r[2], int pipe_m2s[2])
d275 3
a277 1
	rde_shutdown();
@


1.214
log
@no need for KAME_SCOPEID; just check __KAME__.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.213 2006/11/10 14:47:32 henning Exp $ */
a80 1
void		 peer_remove(struct rde_peer *);
a2188 8
peer_remove(struct rde_peer *peer)
{
	LIST_REMOVE(peer, hash_l);
	LIST_REMOVE(peer, peer_l);
	free(peer);
}

void
d2309 3
a2311 1
	peer_remove(peer);
@


1.213
log
@char -> u_char in a few places
apparently from Jeff Rizzo <riz@@NetBSD.org> via "Thomas E. Spanjaard"
<tgen@@netphreax.net>, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.212 2006/09/19 13:02:24 henning Exp $ */
d2578 1
a2578 1
#if defined(__KAME__) && defined(KAME_SCOPEID)
@


1.212
log
@when the neighbor announced the restart capability, send the end-of-rib
marker after a bulk transfer, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.211 2006/08/23 08:13:04 claudio Exp $ */
d2038 1
a2038 1
	char			*b;
@


1.211
log
@Extend show rib interface code so that it is possible to show the adj-rib-in
and adj-rib-out. Additionally it is now possible to limit the output to a
specified peer. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.210 2006/08/22 15:02:07 henning Exp $ */
d2351 2
a2352 4
#if 0
	/* do not send EOR for now, juniper apparently has a problem with it */
	peer_send_eor(peer, afi, safi);
#endif
@


1.210
log
@do not send the empty UPDATE message as End-of-RIB marker yet, Juniper
doesn't handle it correctly. found out the hard way by me :(
Note: This is a clear protocol violation by juniper. Nontheless we need
to be interoperate correctly...
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.209 2006/08/14 17:11:18 henning Exp $ */
d61 6
a66 1
void		 rde_dump_rib_as(struct prefix *, pid_t, int);
d1518 1
a1518 1
rde_dump_rib_as(struct prefix *p, pid_t pid, int flags)
d1528 7
a1534 7
	rib.local_pref = p->aspath->lpref;
	rib.med = p->aspath->med;
	rib.prefix_cnt = p->aspath->prefix_cnt;
	rib.active_cnt = p->aspath->active_cnt;
	rib.adjrib_cnt = p->aspath->adjrib_cnt;
	strlcpy(rib.descr, p->aspath->peer->conf.descr, sizeof(rib.descr));
	memcpy(&rib.remote_addr, &p->aspath->peer->remote_addr,
d1536 3
a1538 3
	rib.remote_id = p->aspath->peer->remote_bgpid;
	if (p->aspath->nexthop != NULL) {
		memcpy(&rib.true_nexthop, &p->aspath->nexthop->true_nexthop,
d1540 1
a1540 1
		memcpy(&rib.exit_nexthop, &p->aspath->nexthop->exit_nexthop,
d1551 1
a1551 1
	rib.origin = p->aspath->origin;
d1555 1
a1555 1
	if (p->aspath->peer->conf.ebgp == 0)
d1557 1
a1557 1
	if (p->aspath->flags & F_PREFIX_ANNOUNCED)
d1559 1
a1559 2
	if (p->aspath->nexthop == NULL ||
	    p->aspath->nexthop->state == NEXTHOP_REACH)
d1561 1
a1561 1
	rib.aspath_len = aspath_length(p->aspath->aspath);
d1567 1
a1567 1
	    imsg_add(wbuf, aspath_dump(p->aspath->aspath),
d1574 2
a1575 2
		for (l = 0; l < p->aspath->others_len; l++) {
			if ((a = p->aspath->others[l]) == NULL)
d1595 52
d1653 1
a1653 3
		/* for now dump only stuff from the local-RIB */
		if (p->flags & F_LOCAL)
			rde_dump_rib_as(p, req->pid, req->flags);
d1671 1
a1671 4
				/* for now dump only stuff from the local-RIB */
				if (p->flags & F_LOCAL)
					rde_dump_rib_as(p, req->pid,
					    req->flags);
d1690 1
a1690 3
			/* for now dump only stuff from the local-RIB */
			if (p->flags & F_LOCAL)
				rde_dump_rib_as(p, req->pid, req->flags);
@


1.209
log
@after a bulk transfer (initial or caused by route refresh request),
send an "empty" UPDATE message, used as End-of-RIB marker for implementions
understanding this, ignored by anything else.
see draft-ietf-idr-restart-13.txt, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.208 2006/06/15 10:04:40 claudio Exp $ */
d2302 2
d2305 1
@


1.208
log
@Instead of passing three different kinds of arguments in show rib control
request use one struct ctl_show_rib_request where all the info is encoded.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.207 2006/06/14 17:08:56 claudio Exp $ */
d81 1
d2301 34
@


1.207
log
@Send bot nexthops (exit and true) in the bgpctl show rib cases. bgpctl
can than select which nexthop should be printed. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.206 2006/05/28 22:07:54 claudio Exp $ */
d63 1
a63 1
void		 rde_dump_as(struct filter_as *, pid_t, int);
d65 2
a66 1
void		 rde_dump_prefix(struct ctl_show_rib_prefix *, pid_t);
a68 1
void		 rde_up_dump_upcall(struct pt_entry *, void *);
d294 1
d428 1
a428 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(af)) {
d432 4
a435 4
			pid = imsg.hdr.pid;
			memcpy(&af, imsg.data, sizeof(af));
			pt_dump(rde_dump_upcall, &pid, af);
			imsg_compose(ibuf_se, IMSG_CTL_END, 0, pid, -1,
d439 1
a439 2
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct filter_as)) {
d443 4
a446 3
			pid = imsg.hdr.pid;
			rde_dump_as(imsg.data, pid, 1);
			imsg_compose(ibuf_se, IMSG_CTL_END, 0, pid, -1,
d450 1
a450 2
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct ctl_show_rib_prefix)) {
d454 4
a457 3
			pid = imsg.hdr.pid;
			rde_dump_prefix(imsg.data, pid);
			imsg_compose(ibuf_se, IMSG_CTL_END, 0, pid, -1,
d1512 1
a1512 1
rde_dump_rib_as(struct prefix *p, pid_t pid, int all)
d1568 1
a1568 1
	if (all)
d1593 1
a1593 3
	pid_t			 pid;

	memcpy(&pid, ptr, sizeof(pid));
d1598 1
a1598 1
			rde_dump_rib_as(p, pid, 0);
d1602 1
a1602 1
rde_dump_as(struct filter_as *a, pid_t pid, int flags)
d1611 2
a1612 1
			if (!aspath_match(asp->aspath, a->type, a->as))
d1618 2
a1619 1
					rde_dump_rib_as(p, pid, flags);
d1627 3
a1629 6
	struct {
		pid_t				 pid;
		struct ctl_show_rib_prefix	*pref;
	}			*ctl = ptr;
	struct prefix		*p;
	struct bgpd_addr	 addr;
d1632 1
a1632 1
	if (addr.af != ctl->pref->prefix.af)
d1634 1
a1634 1
	if (ctl->pref->prefixlen > pt->prefixlen)
d1636 1
a1636 1
	if (!prefix_compare(&ctl->pref->prefix, &addr, ctl->pref->prefixlen))
d1640 1
a1640 1
				rde_dump_rib_as(p, ctl->pid, 0);
d1644 1
a1644 1
rde_dump_prefix(struct ctl_show_rib_prefix *pref, pid_t pid)
d1647 6
a1652 12
	struct {
		pid_t				 pid;
		struct ctl_show_rib_prefix	*pref;
	} ctl;

	if (pref->prefixlen == 32) {
		if ((pt = pt_lookup(&pref->prefix)) != NULL)
			rde_dump_upcall(pt, &pid);
	} else if (pref->flags & F_LONGER) {
		ctl.pid = pid;
		ctl.pref = pref;
		pt_dump(rde_dump_prefix_upcall, &ctl, AF_UNSPEC);
d1654 2
a1655 2
		if ((pt = pt_get(&pref->prefix, pref->prefixlen)) != NULL)
			rde_dump_upcall(pt, &pid);
@


1.206
log
@Preload and pin nexthop used in filtersets so the are validiated when used.
This will fix problems with set nexthop on outgoing filters. Found by
gluk@@ OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.205 2006/04/21 08:55:21 claudio Exp $ */
d1530 6
a1535 4
	if (p->aspath->nexthop != NULL)
		memcpy(&rib.nexthop, &p->aspath->nexthop->true_nexthop,
		    sizeof(rib.nexthop));
	else {
d1537 4
a1540 2
		bzero(&rib.nexthop, sizeof(rib.nexthop));
		rib.nexthop.af = p->prefix->af;
@


1.205
log
@attr_init() should use attrhashsize and not pathhashsize. Found via a lint
cleanup diff from deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.204 2006/04/12 14:05:46 claudio Exp $ */
d129 3
d207 9
d295 1
d409 5
d495 1
d615 5
d2466 1
@


1.204
log
@It is no longer allowed to change attributes in place. This corrupts the
attribute cache. Instead remove attribute and readd it after beeing changed.
This should fix the "att_diff: equal attributes encountered" error seen by
Tony Sarendal. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.203 2006/04/05 13:24:28 claudio Exp $ */
d196 1
a196 1
	attr_init(pathhashsize);
@


1.203
log
@remote_bgpid is stored in host byte order so a htonl() is needed when putting
the value on the wire. This solves the backward originator-ids seend by
Tony Sarendal. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.202 2006/03/22 10:18:49 claudio Exp $ */
d1434 1
d1463 5
a1467 3
			/* prepend own clusterid */
			if ((a->data = realloc(a->data, a->len +
			    sizeof(conf->clusterid))) == NULL)
d1469 7
a1475 5
			memmove(a->data + sizeof(conf->clusterid),
			    a->data, a->len);
			a->len += sizeof(conf->clusterid);
			memcpy(a->data, &conf->clusterid,
			    sizeof(conf->clusterid));
@


1.202
log
@Add a new SHOW imsg to send optional attributes to bgpctl. This can be used
to show communites in bgpctl output. Only send these messages if it they are
requested to reduce the overhead for simple listings. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.201 2006/03/13 16:49:35 claudio Exp $ */
d1435 1
d1442 9
a1450 5
	} else if ((conf->flags & BGPD_FLAG_REFLECTOR) &&
	    attr_optadd(asp, ATTR_OPTIONAL, ATTR_ORIGINATOR_ID,
	    peer->conf.ebgp == 0 ? &peer->remote_bgpid : &conf->bgpid,
	    sizeof(u_int32_t)) == -1)
		fatalx("attr_optadd failed but impossible");
d2289 1
a2289 1
	peerself.remote_bgpid = conf->bgpid;
d2296 1
a2296 1
	peerdynamic.remote_bgpid = conf->bgpid;
@


1.201
log
@Fix for PR 5052. Be more careful about the announced networks we accept.
Make sure that at least the address family and the prefix length are sane.
Reported and fix tested by Pete Vickers.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.200 2006/02/10 14:34:40 claudio Exp $ */
d61 1
a61 1
void		 rde_dump_rib_as(struct prefix *, pid_t);
d63 1
a63 1
void		 rde_dump_as(struct filter_as *, pid_t);
d308 2
a309 1
				log_warnx("peer_up: peer id %d already exists",
d426 1
a426 1
			rde_dump_as(imsg.data, pid);
d1477 1
a1477 1
rde_dump_rib_as(struct prefix *p, pid_t pid)
d1481 3
d1485 1
d1492 4
d1528 20
d1561 1
a1561 1
			rde_dump_rib_as(p, pid);
d1565 1
a1565 1
rde_dump_as(struct filter_as *a, pid_t pid)
d1580 1
a1580 1
					rde_dump_rib_as(p, pid);
d1604 1
a1604 1
				rde_dump_rib_as(p, ctl->pid);
d2279 1
d2285 1
d2288 1
a2288 1
	    "LOCAL AS %hu", conf->as);
d2294 1
a2294 1
	    "LOCAL AS %hu", conf->as);
@


1.200
log
@Make it possible to turn suftreconfig in/out on or off. Default is on for
both directions. Manpage update follows. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.199 2006/02/02 14:06:05 claudio Exp $ */
d346 16
a361 1
			network_add(&netconf_s, 0);
@


1.199
log
@Implement new special community "neighbor-as". neighbor-as is expanded on
the fly to the remote AS of the current neighbor. This can be used to
simplify rulesets in a dramatic way -- going from a script based nightmare
down to a handfull rules. jajajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.198 2006/01/24 14:48:47 claudio Exp $ */
d538 2
a539 1
				if (!rde_filter_equal(rules_l, newrules, peer,
d544 2
a545 1
				if (!rde_filter_equal(rules_l, newrules, peer,
d859 2
a860 1
		path_update(peer, asp, &prefix, prefixlen, F_ORIGINAL);
d950 3
a952 2
				path_update(peer, asp, &prefix, prefixlen,
				    F_ORIGINAL);
@


1.198
log
@Last bits for softreconfig in support. Now bgpd will automaticaly rei-filter
the RIB after a reload so you no longer need to clear sessions because you
modified filters. Looks good henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.197 2006/01/24 14:14:04 claudio Exp $ */
d2271 1
a2271 1
	rde_apply_set(asp, &nc->attrset, nc->prefix.af, p, DIR_IN);
@


1.197
log
@Check if filter changed on a per peer basis. This should speed up the
table run done later as many filter evaluations can be skipped.
From the softreconfig in tree. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.196 2006/01/24 13:34:33 claudio Exp $ */
d67 1
d549 3
d1713 1
a1713 1
 * update specific functions
a1714 2
u_char	queue_buf[4096];

d1768 63
@


1.196
log
@Finally start using the Adj-RIB-In. The most complex part is the modification
of path_update(). There are about 10 different ways how to update a path and
some of them are tricky. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.195 2006/01/20 16:40:17 claudio Exp $ */
d456 1
d460 1
a460 1
	int			 n;
d533 17
a549 1
			if (!rde_filter_equal(rules_l, newrules, DIR_OUT))
d551 1
d1727 2
@


1.195
log
@Proactively fix prefix counters. Currently only F_LOCAL prefixes exist but
as soon as F_ORIGINAL come the counters would no longer be correct and in the
end max-prefix would no longer work. Add additinal counters for F_ORIGINAL
prefixes and bump the correct conter depending on the prefix flags.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.194 2006/01/20 14:56:12 claudio Exp $ */
d834 3
d860 1
a860 1
		path_update(peer, fasp, &prefix, prefixlen);
d924 4
d954 2
a955 1
				path_update(peer, fasp, &prefix, prefixlen);
d2171 2
a2172 1
	struct rde_aspath	 *asp;
d2181 8
a2188 9
	if (flagstatic) {
		rde_apply_set(asp, &nc->attrset, nc->prefix.af, &peerself,
		    DIR_IN);
		path_update(&peerself, asp, &nc->prefix, nc->prefixlen);
	} else {
		rde_apply_set(asp, &nc->attrset, nc->prefix.af, &peerdynamic,
		    DIR_IN);
		path_update(&peerdynamic, asp, &nc->prefix, nc->prefixlen);
	}
@


1.194
log
@Don't leak a aspath in network_add(). path_update() copies the aspath so
the passed aspath needs to be freed in network_add(). OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.193 2006/01/14 22:39:49 claudio Exp $ */
d1437 1
@


1.193
log
@Small step in supporting the Adj-RIB-In additionaly to the Local-RIB.
First step is to define two flags F_LOCAL and F_ORIGINAL. These flags
are used to distinguish prefix in the Local-RIB and those in the Adj-
RIB-In. Adapt prefix API and add additional checks so that no Adj-RIB-
In prefixes get mistakenly selected. Currently no F_ORIGINAL prefixes
are created but this may change soon. Looks good Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.192 2006/01/13 13:04:33 claudio Exp $ */
d2180 2
@


1.192
log
@Simplify evaluation process. Instead of checking the reachability of a prefix
at many different places do it once. This simplifies the logic and makes it
easier to extend it for upcomming Adj-RIB-In addition. OK Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.191 2006/01/12 14:05:13 claudio Exp $ */
d725 2
a726 1
		prefix_remove(peer, &prefix, prefixlen);
d778 4
a781 1
				prefix_remove(peer, &prefix, prefixlen);
d1480 3
a1482 1
	    rde_dump_rib_as(p, pid);
d1499 3
a1501 1
				rde_dump_rib_as(p, pid);
d1523 3
a1525 1
			rde_dump_rib_as(p, ctl->pid);
d2186 2
d2189 1
a2189 1
		prefix_remove(&peerself, &nc->prefix, nc->prefixlen);
d2191 4
a2194 1
		prefix_remove(&peerdynamic, &nc->prefix, nc->prefixlen);
@


1.191
log
@Copy AS path in rde_filter() on demand instead of doing it before calling
rde_filter(). Adapt path_update() to this change too. path_update() does
a path_copy before linking the rde_aspath into the RIB. Looks good Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.190 2006/01/05 16:00:07 claudio Exp $ */
d1553 2
a1554 3
	 * If old is != NULL we know it was active and should be removed.
	 * On the other hand new may be UNREACH and then we should not
	 * generate an update.
d1557 1
a1557 3
	    (new == NULL || new->aspath->nexthop == NULL ||
	    new->aspath->nexthop->state != NEXTHOP_REACH ||
	    new->aspath->flags & F_PREFIX_ANNOUNCED))
d1560 1
a1560 3
	if (new == NULL || new->aspath->nexthop == NULL ||
	    new->aspath->nexthop->state != NEXTHOP_REACH ||
	    new->aspath->flags & F_PREFIX_ANNOUNCED) {
d1745 1
a1745 1
	 * On the other hand new may be UNREACH and then we should not
d1748 1
a1748 2
	if (old == NULL && (new == NULL || (new->aspath->nexthop != NULL &&
	    new->aspath->nexthop->state != NEXTHOP_REACH)))
@


1.190
log
@Cache optional BGP attributes (mostly communities) and use a simple
pointer plus a ref counter to link the attributes to the path object.
Saves +/- 10M on 11 full feeds. Looks good Henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.189 2006/01/04 12:53:31 claudio Exp $ */
a829 5
		/*
		 * We need to copy attrs before calling the filter because
		 * the filter may change the attributes.
		 */
		fasp = path_copy(asp);
d831 2
a832 2
		if (rde_filter(rules_l, peer, fasp, &prefix, prefixlen, peer,
		    DIR_IN) == ACTION_DENY) {
d848 4
a851 1
		rde_update_log("update", peer, &asp->nexthop->exit_nexthop,
d854 4
a916 1
				fasp = path_copy(asp);
d918 3
a920 2
				if (rde_filter(rules_l, peer, fasp, &prefix,
				    prefixlen, peer, DIR_IN) == ACTION_DENY) {
d937 3
d944 4
d1698 6
a1703 8
		/* copy attributes for output filter */
		oasp = path_copy(p->aspath);
		nasp = path_copy(p->aspath);

		oa = rde_filter(rules_l, peer, oasp, &addr, pt->prefixlen,
		    p->aspath->peer, DIR_OUT);
		na = rde_filter(newrules, peer, nasp, &addr, pt->prefixlen,
		    p->aspath->peer, DIR_OUT);
d1726 4
a1729 2
		path_put(oasp);
		path_put(nasp);
@


1.189
log
@Simplify shutdown function and sprinkle some rde_quit checks into functions
that don't need to run if the RDE is quitting e.g. the decision process.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.188 2006/01/03 22:49:17 claudio Exp $ */
d115 1
d195 1
d2275 1
@


1.188
log
@Track some (memory) statistics in the RDE. Accessible via bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.187 2006/01/03 15:48:39 claudio Exp $ */
d1617 4
d1635 4
d1856 4
a2240 7
	/* First mark all peer as down */
	for (i = 0; i <= peertable.peer_hashmask; i++)
		LIST_FOREACH(p, &peertable.peer_hashtbl[i], peer_l) {
			p->remote_bgpid = 0;
			p->state = PEER_DOWN;
			up_down(p);
		}
d2242 1
a2242 2
	 * Now walk through the aspath list and remove everything.
	 * path_remove will also remove the prefixes and the pt_entries.
d2245 2
a2246 10
		while ((p = LIST_FIRST(&peertable.peer_hashtbl[i])) != NULL) {
			for (asp = LIST_FIRST(&p->path_h);
			    asp != NULL; asp = nasp) {
				nasp = LIST_NEXT(asp, peer_l);
				path_remove(asp);
			}
			LIST_INIT(&p->path_h);
			/* finally remove peer */
			peer_remove(p);
		}
@


1.187
log
@Kill WFLAG macro. Should have been included in the rde_attr_parse() merge.
Makes the code more obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.186 2006/01/03 13:09:18 claudio Exp $ */
d100 1
d438 4
@


1.186
log
@No need to check the poll fds in case of EINTR. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.185 2005/12/30 11:22:23 claudio Exp $ */
a960 7
#define WFLAG(s, t)			\
	do {				\
		if ((s) & (t))		\
			goto bad_list;	\
		(s) |= (t);		\
	} while (0)

d1020 3
a1022 1
		WFLAG(a->flags, F_ATTR_ORIGIN);
d1032 3
a1034 1
		WFLAG(a->flags, F_ATTR_ASPATH);
d1043 3
a1045 1
		WFLAG(a->flags, F_ATTR_NEXTHOP);
d1067 4
a1070 1
		WFLAG(a->flags, F_ATTR_MED);
d1084 4
a1087 1
		WFLAG(a->flags, F_ATTR_LOCALPREF);
d1127 4
a1130 2
		/* the actually validity is checked in rde_update_dispatch() */
		WFLAG(a->flags, F_ATTR_MP_REACH);
d1141 4
a1144 2
		/* the actually validity is checked in rde_update_dispatch() */
		WFLAG(a->flags, F_ATTR_MP_UNREACH);
d1171 1
a1171 1
#undef WFLAG
@


1.185
log
@Merge rde_attr_error() into rde_attr_parse() it is no longer necessary to
have a separate error function. It is no porblem to call rde_update_err()
directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.184 2005/12/24 13:52:56 claudio Exp $ */
d219 1
a219 1
		if (poll(pfd, i, INFTIM) == -1)
d222 2
@


1.184
log
@Don't use bzero(&pfd, sizeof(pfd)); pfd is an array so bzero(pfd, sizeof(pfd));
is better. Discussed on icb.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.183 2005/12/09 16:17:28 claudio Exp $ */
d46 2
a47 4
int		 rde_attr_parse(u_char *, u_int16_t, struct rde_aspath *, int,
		     enum enforce_as, u_int16_t, struct mpattr *);
u_char		*rde_attr_error(u_char *, u_int16_t, struct rde_aspath *,
		     u_int8_t *, u_int16_t *);
d596 1
a596 1
	u_char			*p, *emsg, *mpp = NULL;
d601 1
a601 1
	u_int16_t		 nlri_len, size;
d640 2
a641 7
			if ((pos = rde_attr_parse(p, len, asp,
			    peer->conf.ebgp, peer->conf.enforce_as,
			    peer->conf.remote_as, &mpa)) < 0) {
				emsg = rde_attr_error(p, len, asp,
				    &subtype, &size);
				rde_update_err(peer, ERR_UPDATE, subtype,
				    emsg, size);
d658 11
d962 1
a962 1
			return (-1);	\
d967 2
a968 2
rde_attr_parse(u_char *p, u_int16_t len, struct rde_aspath *a, int ebgp,
    enum enforce_as enforce_as, u_int16_t remote_as, struct mpattr *mpa)
d971 1
d979 3
a981 1
	if (len < 3)
d983 1
d990 1
a990 1
			return (-1);
d999 4
a1002 1
		return (-1);
d1006 1
a1006 1
		/* error! */
d1010 6
d1017 2
a1018 2
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0))
			return (-1);
d1020 3
a1022 1
		if (a->origin > ORIGIN_INCOMPLETE)
d1024 1
d1029 4
d1034 1
a1034 2
		if (aspath_verify(p, attr_len) != 0)
			return (-1);
a1036 4
		if (enforce_as == ENFORCE_AS_ON &&
		    remote_as != aspath_neighbor(a->aspath))
			return (-1);

d1041 1
a1041 1
			return (-1);
d1043 1
a1043 1
			return (-1);
d1045 1
d1054 3
a1056 1
		if (IN_MULTICAST(tmp32) || IN_BADCLASS(tmp32))
d1058 1
a1058 1

d1063 1
a1063 1
			return (-1);
d1065 1
a1065 1
			return (-1);
d1072 1
a1072 1
			return (-1);
d1074 4
a1077 5
			return (-1);
		if (ebgp) {
			/* ignore local-pref attr for non ibgp peers */
			a->lpref = 0;	/* set a default value ... */
			plen += 4;	/* and ignore the real value */
d1086 1
a1086 1
			return (-1);
d1088 1
a1088 1
			return (-1);
d1092 1
a1092 1
			return (-1);
d1094 1
a1094 1
			return (-1);
d1098 1
a1098 1
			return (-1);
d1101 1
a1101 1
			return (-1);
d1105 1
a1105 1
			return (-1);
d1107 1
a1107 1
			return (-1);
d1111 1
a1111 1
			return (-1);
d1113 1
a1113 1
			return (-1);
d1117 1
a1117 1
			return (-1);
d1119 1
a1119 1
			return (-1);
d1129 1
a1129 1
			return (-1);
d1131 1
a1131 1
			return (-1);
d1140 3
a1142 1
		if ((flags & ATTR_OPTIONAL) == 0)
d1144 1
d1146 4
a1149 1
		if (attr_optadd(a, flags, type, p, attr_len) == -1)
d1151 2
a1157 158
}

u_char *
rde_attr_error(u_char *p, u_int16_t len, struct rde_aspath *attr,
    u_int8_t *suberr, u_int16_t *size)
{
	struct attr	*a;
	u_char		*op;
	u_int16_t	 attr_len;
	u_int16_t	 plen = 0;
	u_int8_t	 flags;
	u_int8_t	 type;
	u_int8_t	 tmp8;

	*suberr = ERR_UPD_ATTRLEN;
	*size = len;
	op = p;
	if (len < 3)
		return (op);

	UPD_READ(&flags, p, plen, 1);
	UPD_READ(&type, p, plen, 1);

	if (flags & ATTR_EXTLEN) {
		if (len - plen < 2)
			return (op);
		UPD_READ(&attr_len, p, plen, 2);
		attr_len = ntohs(attr_len);
	} else {
		UPD_READ(&tmp8, p, plen, 1);
		attr_len = tmp8;
	}

	if (len - plen < attr_len)
		return (op);
	*size = attr_len;

	switch (type) {
	case ATTR_UNDEF:
		/* error! */
		*suberr = ERR_UPD_UNSPECIFIC;
		*size = 0;
		return (NULL);
	case ATTR_ORIGIN:
		if (attr_len != 1)
			return (op);
		if (attr->flags & F_ATTR_ORIGIN) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		UPD_READ(&tmp8, p, plen, 1);
		if (tmp8 > ORIGIN_INCOMPLETE) {
			*suberr = ERR_UPD_ORIGIN;
			return (op);
		}
		break;
	case ATTR_ASPATH:
		if (attr->flags & F_ATTR_ASPATH) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		if (CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0)) {
			/* malformed aspath detected by exclusion method */
			*size = 0;
			*suberr = ERR_UPD_ASPATH;
			return (NULL);
		}
		break;
	case ATTR_NEXTHOP:
		if (attr_len != 4)
			return (op);
		if (attr->flags & F_ATTR_NEXTHOP) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		if (CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0)) {
			/* malformed nexthop detected by exclusion method */
			*suberr = ERR_UPD_NETWORK;
			return (op);
		}
		break;
	case ATTR_MED:
		if (attr_len != 4)
			return (op);
		if (attr->flags & F_ATTR_MED) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		break;
	case ATTR_LOCALPREF:
		if (attr_len != 4)
			return (op);
		if (attr->flags & F_ATTR_LOCALPREF) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		break;
	case ATTR_ATOMIC_AGGREGATE:
		if (attr_len != 0)
			return (op);
		break;
	case ATTR_AGGREGATOR:
		if (attr_len != 6)
			return (op);
		break;
	case ATTR_COMMUNITIES:
		if ((attr_len & 0x3) != 0)
			return (op);
		goto optattr;
	case ATTR_ORIGINATOR_ID:
		if (attr_len != 4)
			return (op);
		goto optattr;
	case ATTR_CLUSTER_LIST:
		if ((attr_len & 0x3) != 0)
			return (op);
		goto optattr;
	case ATTR_MP_REACH_NLRI:
		if (attr_len < 4)
			return (op);
		if (attr->flags & F_ATTR_MP_REACH) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		break;
	case ATTR_MP_UNREACH_NLRI:
		if (attr_len < 3)
			return (op);
		if (attr->flags & F_ATTR_MP_UNREACH) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		break;
	default:
optattr:
		if ((flags & ATTR_OPTIONAL) == 0) {
			*suberr = ERR_UPD_UNKNWN_WK_ATTR;
			return (op);
		}
		TAILQ_FOREACH(a, &attr->others, entry)
			if (type == a->type) {
				*size = 0;
				*suberr = ERR_UPD_ATTRLIST;
				return (NULL);
			}
		*suberr = ERR_UPD_OPTATTR;
		return (op);
	}
	/* can only be a attribute flag error */
	*suberr = ERR_UPD_ATTRFLAGS;
	return (op);
@


1.183
log
@Unkown attributes need to be optional, if not issue a "unknown wellknown
attribute" error. While this check is already present in the error handling
function it is not done while parsing. Found via regress, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.182 2005/12/08 16:02:56 claudio Exp $ */
d203 1
a203 1
		bzero(&pfd, sizeof(pfd));
@


1.182
log
@Missing ntohs() in error path. Found via regress test.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.181 2005/11/30 13:45:19 claudio Exp $ */
d1119 2
@


1.181
log
@No need to filter incoming withdraws just try to remove everything form the
RIB -- if it got filtered before so be it.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.180 2005/11/29 21:11:07 claudio Exp $ */
d1154 1
@


1.180
log
@Add a flags field to struct prefix which will be used shortly. Remove the peer
pointer so that the size does not grow. Adding 4 bytes to struct prefix would
result in 64MB more memory usage on one of my systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.179 2005/11/29 20:45:21 claudio Exp $ */
a710 5
		/* input filter */
		if (rde_filter(rules_l, peer, NULL, &prefix, prefixlen, peer,
		    DIR_IN) == ACTION_DENY)
			continue;

a760 5

				/* input filter */
				if (rde_filter(rules_l, peer, NULL, &prefix,
				    prefixlen, peer, DIR_IN) == ACTION_DENY)
					continue;
@


1.179
log
@even more spaces and tabs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.178 2005/11/02 13:21:06 claudio Exp $ */
d1556 1
a1556 1
	if (p->peer->conf.ebgp == 0)
d1804 1
a1804 1
		    p->peer, DIR_OUT);
d1806 1
a1806 1
		    p->peer, DIR_OUT);
d2304 1
a2304 1
			if (p->peer == &peerself)
d2316 1
a2316 1
			if (p->peer == &peerself)
@


1.178
log
@Use the new rde_filter_equal() with dir = DIR_OUT to check if a soft-
reconfigure out run is needed or not. If the output filters did not change
no table walk is needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.177 2005/11/01 15:21:54 claudio Exp $ */
d524 1
a524 1
			
d1790 1
a1790 1
	
d1822 1
a1822 1
			if (path_compare(nasp, oasp) == 0) 
@


1.177
log
@Softreconfig out support. On config reload filter changes of outgoing rules
will propagte directly to the neighbors. There is no need to restart bgpd
in that case. Currently not optimal but a good start. "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.176 2005/11/01 14:37:16 claudio Exp $ */
d525 2
a526 1
			pt_dump(rde_softreconfig_out, NULL, AF_UNSPEC);
@


1.176
log
@Major cleanup in rde_update.c. Merge equal code used in different places
into own functions. Move up_dump_upcall() into rde.c and rename it
rde_up_dump_upcall(). This is needed for the next step.
up_test_update() tests if an update or withdraw is needed and up_generate()
creates the updates.  "get it in" henning@@ (he is eager on softreconfig out)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.175 2005/11/01 10:58:29 claudio Exp $ */
d68 1
d524 2
a525 1
			/* soft reconfig out */
d711 1
a711 1
		if (rde_filter(peer, NULL, &prefix, prefixlen, peer,
d767 2
a768 2
				if (rde_filter(peer, NULL, &prefix, prefixlen,
				    peer, DIR_IN) == ACTION_DENY)
d832 1
a832 1
		if (rde_filter(peer, fasp, &prefix, prefixlen, peer,
d913 2
a914 2
				if (rde_filter(peer, fasp, &prefix, prefixlen,
				    peer, DIR_IN) == ACTION_DENY) {
d1782 52
d1840 1
a1840 1
	up_generate_updates(peer, pt->active, NULL);
d1860 1
a1860 1
		up_generate_updates(peer, new, old);
d2207 1
a2207 1
				up_generate_default(peer, AF_INET);
d2216 1
a2216 1
				up_generate_default(peer, AF_INET6);
@


1.175
log
@Switch from the per peer filter set list to a filter-only solution.
The default filter_sets are converted into match filter rules that get
evaluated first. Simplifies code massively -- mainly the config reload
part -- and makes softreconfig out a piece of cake.  "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.174 2005/10/13 09:08:21 claudio Exp $ */
d68 1
d1780 10
d2155 1
a2155 1
				pt_dump(up_dump_upcall, peer, AF_INET);
d2164 1
a2164 1
				pt_dump(up_dump_upcall, peer, AF_INET6);
@


1.174
log
@Simplify poll loop, there is no need for nfds tracking. While there kill
some comments that are totaly wrong. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.173 2005/09/21 13:35:03 claudio Exp $ */
a305 1
			session_set = &peer->conf.attrset;
a311 1
			session_set = NULL;
d522 1
a792 3
	/* apply default overrides */
	rde_apply_set(asp, &peer->conf.attrset, AF_INET, peer, DIR_DEFAULT_IN);

a884 3
			/* apply default overrides */
			rde_apply_set(asp, &peer->conf.attrset, AF_INET6, peer,
			    DIR_DEFAULT_IN);
a1981 1
	TAILQ_INIT(&peer->conf.attrset);
a1998 2

	filterset_free(&peer->conf.attrset);
d2200 1
a2200 1
		    DIR_DEFAULT_IN);
d2204 1
a2204 1
		    DIR_DEFAULT_IN);
@


1.173
log
@Make sure that "updates" with only MP withdraws (MP_UNREACH_NRLI) stop
processing after the MP withdraw block. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.172 2005/09/20 14:40:32 henning Exp $ */
d126 1
a126 1
	int			 nfds, i;
d219 1
a219 1
		if ((nfds = poll(pfd, i, INFTIM)) == -1)
d223 1
a223 1
		if (nfds > 0 && (pfd[PFD_PIPE_MAIN].revents & POLLOUT) &&
d228 1
a228 2
		if (nfds > 0 && pfd[PFD_PIPE_MAIN].revents & POLLIN) {
			nfds--;
a229 1
		}
d231 1
a231 1
		if (nfds > 0 && (pfd[PFD_PIPE_SESSION].revents & POLLOUT) &&
d236 1
a236 2
		if (nfds > 0 && pfd[PFD_PIPE_SESSION].revents & POLLIN) {
			nfds--;
a237 1
		}
d239 1
a239 1
		if (nfds > 0 && pfd[PFD_MRT_FILE].revents & POLLOUT) {
a1867 4
				/*
				 * No packet to send. The 4 bytes are the
				 * needed withdraw and path attribute length.
				 */
a1886 4
				/*
				 * No packet to send. The 4 bytes are the
				 * needed withdraw and path attribute length.
				 */
@


1.172
log
@allow "show rib" to be limited to an address family too
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.171 2005/09/20 13:31:53 henning Exp $ */
d707 2
a708 1
			path_put(asp);
d781 5
@


1.171
log
@let "bgpctl network show" print v6 addresses correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.169 2005/08/10 08:34:06 claudio Exp $ */
d393 1
a393 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE) {
d398 2
a399 1
			pt_dump(rde_dump_upcall, &pid, AF_UNSPEC);
@


1.170
log
@KNF
@
text
@d283 1
d382 1
a382 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE) {
d387 2
a388 1
			pt_dump(network_dump_upcall, &pid, AF_UNSPEC);
d2239 1
d2245 4
a2248 2
	LIST_FOREACH(p, &pt->prefix_h, prefix_l)
		if (p->aspath->flags & F_PREFIX_ANNOUNCED) {
d2260 13
@


1.169
log
@Pass the correct peer to rde_apply_set(). rde_apply_set() needs to know
the peer where the prefix came from so that prepend-neighbor works.
Extend rde_filter() and make sure that the correct peer is passed.
Until now most cases resulted in a NULL peer causing a nasty crash that
was found by David Ulevitch. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.168 2005/07/29 22:26:30 claudio Exp $ */
d2243 12
a2254 12
	    if (p->aspath->flags & F_PREFIX_ANNOUNCED) {
		    bzero(&k, sizeof(k));
		    pt_getaddr(p->prefix, &addr);
		    k.prefix.s_addr = addr.v4.s_addr;
		    k.prefixlen = p->prefix->prefixlen;
		    if (p->peer == &peerself)
			    k.flags = F_KERNEL;
		    if (imsg_compose(ibuf_se, IMSG_CTL_SHOW_NETWORK, 0, pid,
			-1, &k, sizeof(k)) == -1)
			    log_warnx("network_dump_upcall: "
				"imsg_compose error");
	    }
@


1.168
log
@Debugging session at WTH. Fix many bugs in the IPv6 support -- some copy paste
and some more obscure ones. With this is it possible to run IPv6 sessions
between two bgpd.
OK if it does not break IPv4 hummpa barman Henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.167 2005/07/29 12:38:40 claudio Exp $ */
d709 1
a709 1
		if (rde_filter(peer, NULL, &prefix, prefixlen,
d766 1
a766 1
				    DIR_IN) == ACTION_DENY)
d828 1
a828 1
		if (rde_filter(peer, fasp, &prefix, prefixlen,
d912 2
a913 2
				if (rde_filter(peer, fasp, &prefix,
				    prefixlen, DIR_IN) == ACTION_DENY) {
@


1.167
log
@Add another piece to the IPv6 puzzle. This time code to generate MP updates.
Does not affect IPv4 minimaly tested for IPv6 because we still don't have an
IPv6 capable neighbor. henning@@ ya
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.166 2005/07/01 13:38:14 claudio Exp $ */
d252 1
d1862 1
a1862 1
			if (b == NULL || len <= 4)
d1885 1
a1885 1
			if (b == NULL || len <= 4)
d2054 7
a2060 9
			else {
				if (IN6_IS_ADDR_LINKLOCAL(
				    &((struct sockaddr_in6 *)ifa->
				    ifa_addr)->sin6_addr) ||
				    IN6_IS_ADDR_SITELOCAL(
				    &((struct sockaddr_in6 *)ifa->
				    ifa_addr)->sin6_addr))
					continue;
			}
d2154 1
a2154 1
			    ANNOUNCE_DEFAULT_ROUTE) {
d2156 2
a2157 4
				return;
			}
			pt_dump(up_dump_upcall, peer, AF_INET);
			return;
d2163 1
a2163 1
			    ANNOUNCE_DEFAULT_ROUTE) {
d2165 2
a2166 4
				return;
			}
			pt_dump(up_dump_upcall, peer, AF_INET6);
			return;
a2167 2

	log_peer_warnx(&peer->conf, "unsupported AFI, SAFI combination");
@


1.166
log
@Switch filter_sets form SIMPLEQ to TAILQ, needed for upcomming stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.165 2005/07/01 12:10:20 claudio Exp $ */
d69 1
d698 9
d731 8
d774 2
a775 1
			fatalx("unsupported multipath AF");
d812 9
a872 4
		/* apply default overrides */
		rde_apply_set(asp, &peer->conf.attrset, AF_INET6, peer,
		    DIR_DEFAULT_IN);

d875 12
d934 1
d936 2
a937 1
			fatalx("unsupported AF");
a1647 1
 * XXX notyet IPv6 ready
d1653 1
a1668 2
	bzero(&kl, sizeof(kl));

a1676 2
		kl.kr.nexthop.s_addr =
		    p->aspath->nexthop->true_nexthop.v4.s_addr;
d1680 40
a1719 11
	kl.kr.prefix.s_addr = addr.v4.s_addr;
	kl.kr.prefixlen = p->prefix->prefixlen;
	if (p->aspath->flags & F_NEXTHOP_REJECT)
		kl.kr.flags |= F_REJECT;
	if (p->aspath->flags & F_NEXTHOP_BLACKHOLE)
		kl.kr.flags |= F_BLACKHOLE;
	strlcpy(kl.label, rtlabel_id2name(p->aspath->rtlabelid),
	    sizeof(kl.label));

	if (imsg_compose(ibuf_main, type, 0, 0, -1, &kl, sizeof(kl)) == -1)
		fatal("imsg_compose error");
d1844 55
d2092 4
d2160 11
@


1.165
log
@The newly introduced function filterset_free() existed already as
rde_free_set(), I just missed it when I was looking for it.
Kill rde_free_set() and use the more correct filterset_free() from now on.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.164 2005/07/01 09:19:24 claudio Exp $ */
d334 1
a334 1
			SIMPLEQ_INIT(&netconf_s.attrset);
d352 1
a352 1
			SIMPLEQ_INIT(&netconf_s.attrset);
d376 1
a376 1
			SIMPLEQ_INSERT_TAIL(session_set, s, entry);
d478 1
a478 1
			SIMPLEQ_INIT(&netconf_p.attrset);
d492 1
a492 1
			SIMPLEQ_INIT(&netconf_p.attrset);
d502 1
a502 1
			SIMPLEQ_INIT(&r->set);
d544 1
a544 1
			SIMPLEQ_INSERT_TAIL(parent_set, s, entry);
d1873 1
a1873 1
	SIMPLEQ_INIT(&peer->conf.attrset);
@


1.164
log
@Make the pftable filter set use the name2id "cache" like the route labels.
This saves 14 bytes per aspath. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.163 2005/06/29 09:43:25 claudio Exp $ */
d1892 1
a1892 1
	rde_free_set(&peer->conf.attrset);
d2094 1
a2094 1
	rde_free_set(&nc->attrset);
@


1.163
log
@rtlabel support via filter sets. Just use "set rtlabel foobar" in filters
network and neighbor statements and the routes are labeled accordingly.
While doing that fix some mem-leaks by introducing filterset_free() and
remove the free on send option of send_filterset().
This took a bit longer because we need to carefully track the rtlabel id
refcnts or bad things may happen on reloads.
henning@@ looks fine
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.162 2005/06/13 21:16:18 henning Exp $ */
d1663 1
a1663 1
rde_send_pftable(const char *table, struct bgpd_addr *addr,
d1668 1
a1668 1
	if (*table == '\0')
d1672 1
a1672 1
	strlcpy(pfm.pftable, table, sizeof(pfm.pftable));
@


1.162
log
@route label support, kroute part and ID allocator as well as the internal
interface changes. support in the filter language and rde to come. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.161 2005/06/10 08:28:50 claudio Exp $ */
d525 1
d1652 2
a1653 2
	/* XXX */
	strlcpy(kl.label, rtlabel_id2name(0), sizeof(kl.label));
@


1.161
log
@Simplify show rib upcalls. Kill one mostly unused function.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.160 2005/05/23 22:45:02 henning Exp $ */
d1614 4
a1617 4
	struct kroute		kr;
	struct bgpd_addr	addr;
	struct prefix	*p;
	enum imsg_type	 type;
d1630 1
a1630 1
	bzero(&kr, sizeof(kr));
d1640 2
a1641 1
		kr.nexthop.s_addr = p->aspath->nexthop->true_nexthop.v4.s_addr;
d1645 2
a1646 2
	kr.prefix.s_addr = addr.v4.s_addr;
	kr.prefixlen = p->prefix->prefixlen;
d1648 1
a1648 1
		kr.flags |= F_REJECT;
d1650 3
a1652 1
		kr.flags |= F_BLACKHOLE;
d1654 1
a1654 1
	if (imsg_compose(ibuf_main, type, 0, 0, -1, &kr, sizeof(kr)) == -1)
@


1.160
log
@no need for endpwent()
(you lost, theo)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.159 2005/05/03 07:01:23 djm Exp $ */
a63 1
void		 rde_dump_rib_prefix(struct prefix *, pid_t);
a1534 23
rde_dump_rib_prefix(struct prefix *p, pid_t pid)
{
	struct ctl_show_rib_prefix	 prefix;

	prefix.lastchange = p->lastchange;
	pt_getaddr(p->prefix, &prefix.prefix);
	prefix.prefixlen = p->prefix->prefixlen;
	prefix.flags = 0;
	if (p->prefix->active == p)
		prefix.flags |= F_RIB_ACTIVE;
	if (p->peer->conf.ebgp == 0)
		prefix.flags |= F_RIB_INTERNAL;
	if (p->aspath->flags & F_PREFIX_ANNOUNCED)
		prefix.flags |= F_RIB_ANNOUNCE;
	if (p->aspath->nexthop == NULL ||
	    p->aspath->nexthop->state == NEXTHOP_REACH)
		prefix.flags |= F_RIB_ELIGIBLE;
	if (imsg_compose(ibuf_se, IMSG_CTL_SHOW_RIB_PREFIX, 0, pid, -1,
	    &prefix, sizeof(prefix)) == -1)
		log_warnx("rde_dump_as: imsg_compose error");
}

void
d1554 1
a1554 2
	i = pathtable.path_hashmask;
	do {
d1559 2
a1560 4
			rde_dump_rib_as(LIST_FIRST(&asp->prefix_h), pid);
			for (p = LIST_NEXT(LIST_FIRST(&asp->prefix_h), path_l);
			    p != NULL; p = LIST_NEXT(p, path_l))
				rde_dump_rib_prefix(p, pid);
d1562 1
a1562 1
	} while (i-- != 0);
@


1.159
log
@setres[ug]id; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.158 2005/04/28 13:54:45 claudio Exp $ */
a153 2

	endpwent();
@


1.158
log
@Support for "network connected" and "network static" -- announce all
directly connected respectively all static routes. The list is auto-
matically adjusted as soon as a route changes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.157 2005/04/16 19:10:59 cloder Exp $ */
d151 2
a152 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid)) {
a153 1
	}
@


1.157
log
@Format string cleanup. OK millert, henning, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.156 2005/03/28 15:16:46 henning Exp $ */
d488 10
@


1.156
log
@ewps, this was not supposed to creep in
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.155 2005/03/28 15:03:33 henning Exp $ */
d1425 1
a1425 1
	log_info("neighbor %s (AS%u) %s %s/%u %s",
@


1.155
log
@free rules_l if the initial config file parse fails
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.154 2005/03/24 10:28:39 henning Exp $ */
d267 1
a267 1
	exit(0);
@


1.154
log
@soem fatal()s that should be fatalx()s, Alexander von Gernler
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.153 2004/11/23 13:07:01 claudio Exp $ */
d267 1
a267 1
	_exit(0);
@


1.153
log
@Switch from a single filter_set to a linked list of sets. With this change
it is possible to specify multiple communities. This is also the first step
to better bgpd filters. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.152 2004/11/19 14:43:57 claudio Exp $ */
d289 1
a289 1
		fatal("rde_dispatch_imsg_session: pipe closed");
d460 1
a460 1
		fatal("rde_dispatch_imsg_parent: pipe closed");
d530 1
a530 1
				log_warnx("rde_dispatch: "
@


1.152
log
@For consistency reasons rename struct as_filter to struct filter_as.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.151 2004/11/11 16:59:47 claudio Exp $ */
d270 3
a276 1
	struct session_up	 sup;
d278 1
d281 2
d301 12
d318 1
d337 11
a347 1
			network_add(imsg.data, 0);
d355 3
a357 1
			network_delete(imsg.data, 0);
d366 16
d453 1
d481 7
a487 1
			network_add(imsg.data, 1);
d496 2
d515 1
d528 11
d1889 1
d1908 1
d1979 1
a1979 1
	peer = peer_add(id, &sup->conf);
d2110 1
@


1.151
log
@Unbreak peer_localaddr() because Link Local Addresses reported by
getifaddrs() have the scope id added to the address and so fuck up in the
compare later. This part has bin stolen from ifconfig/ifconfig.c and shows
the beauty of IPv6. Thank you KAME.
disgusting but OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.150 2004/11/11 16:50:33 claudio Exp $ */
d66 1
a66 1
void		 rde_dump_as(struct as_filter *, pid_t);
d358 1
a358 1
			    sizeof(struct as_filter)) {
d1497 1
a1497 1
rde_dump_as(struct as_filter *a, pid_t pid)
@


1.150
log
@Pass the copied as-path attributes to the filter function and not the
original. Affected code is currently still unreachable.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.149 2004/11/11 13:29:37 henning Exp $ */
d2170 9
@


1.149
log
@spaces at EOL in comments, spotted by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.148 2004/11/11 13:14:45 claudio Exp $ */
d801 1
a801 1
				if (rde_filter(peer, asp, &prefix,
@


1.148
log
@NOTREACHED not not reached! Stupid me.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.147 2004/11/11 13:06:45 claudio Exp $ */
d1224 1
a1224 1
		/* 
@


1.147
log
@Store the local v4 and v6 address of a session. For IPv4 sessions the first
IPv6 address with global scope of the interface used by the session is used.
In any case the local endpoint of the session is used for one of the two no
matter what scope.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.146 2004/11/11 10:35:15 claudio Exp $ */
d2176 1
a2176 1
		/* not reached */
@


1.146
log
@New config statement "rde route-age [evaluate|ignore]". If set to evaluate
the best path selection will not only be based on the path attributes but
also on the age of the prefix. This is an extension to the RFC. The default
is ignore but previously it was implicitly set to evaluate.
OK henning@@ man page OK jaredy@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.145 2004/09/28 12:09:31 claudio Exp $ */
d20 1
d23 1
d73 1
d88 1
d1844 62
a1918 1
	memcpy(&peer->local_addr, &sup->local_addr, sizeof(peer->local_addr));
d1921 3
d2151 29
@


1.145
log
@Add prepend-neighbor feature. Prepend the remote-as n times similar to
prepend-self. Only for incomming UPDATEs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.144 2004/09/16 17:36:29 henning Exp $ */
d1739 6
@


1.144
log
@imsg API cleanup:
-kill imsg_compose_pid, imsg_compose_fdpass and imsg_create_pid
-extend the original imsg_compose/_create API to take pid & fd too
-make imsg_compose do imsg_create + imsg_add + imsg_close instead of
 duplicating the code
-adjust all callers to the new API
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.143 2004/09/16 00:25:12 henning Exp $ */
d692 1
a692 1
	rde_apply_set(asp, &peer->conf.attrset, AF_INET);
d768 2
a769 1
		rde_apply_set(asp, &peer->conf.attrset, AF_INET6);
d1958 3
a1960 4
	/* apply default overrides */
	rde_apply_set(asp, &nc->attrset, nc->prefix.af);

	if (flagstatic)
d1962 3
a1964 1
	else
d1966 1
@


1.143
log
@malloc the imsg buffers instead of having them staticly, suggested by
micskye some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.142 2004/08/12 10:24:16 claudio Exp $ */
d339 2
a340 1
			imsg_compose_pid(ibuf_se, IMSG_CTL_END, pid, NULL, 0);
d349 2
a350 1
			imsg_compose_pid(ibuf_se, IMSG_CTL_END, pid, NULL, 0);
d360 2
a361 1
			imsg_compose_pid(ibuf_se, IMSG_CTL_END, pid, NULL, 0);
d371 2
a372 1
			imsg_compose_pid(ibuf_se, IMSG_CTL_END, pid, NULL, 0);
d384 2
a385 2
			imsg_compose_pid(ibuf_se, IMSG_CTL_SHOW_NEIGHBOR,
			    imsg.hdr.pid, &p, sizeof(struct peer));
d388 2
a389 2
			imsg_compose_pid(ibuf_se, IMSG_CTL_END, imsg.hdr.pid,
			    NULL, 0);
d1323 1
a1323 1
	if ((wbuf = imsg_create(ibuf_se, IMSG_UPDATE_ERR, peer->conf.id,
d1445 1
a1445 1
	if ((wbuf = imsg_create_pid(ibuf_se, IMSG_CTL_SHOW_RIB, pid,
d1474 1
a1474 1
	if (imsg_compose_pid(ibuf_se, IMSG_CTL_SHOW_RIB_PREFIX, pid,
d1599 1
a1599 1
	if (imsg_compose(ibuf_main, type, 0, &kr, sizeof(kr)) == -1)
d1622 1
a1622 1
	    0, &pfm, sizeof(pfm)) == -1)
d1629 2
a1630 1
	if (imsg_compose(ibuf_main, IMSG_PFTABLE_COMMIT, 0, NULL, 0) == -1)
d1650 1
a1650 1
	if (imsg_compose(ibuf_main, type, 0, next,
d1718 1
a1718 1
			    queue_buf, wpos) == -1)
d1993 2
a1994 2
		    if (imsg_compose_pid(ibuf_se, IMSG_CTL_SHOW_NETWORK, pid,
			&k, sizeof(k)) == -1)
@


1.142
log
@Just ignore RFC2545 and the silly idea of using link local addresses as
nexthop. This makes the code a lot simpler. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.141 2004/08/10 14:06:53 claudio Exp $ */
d93 2
a94 2
struct imsgbuf		 ibuf_se;
struct imsgbuf		 ibuf_main;
d164 5
a168 2
	imsg_init(&ibuf_se, pipe_s2r[1]);
	imsg_init(&ibuf_main, pipe_m2r[1]);
d201 1
a201 1
		pfd[PFD_PIPE_MAIN].fd = ibuf_main.fd;
d203 1
a203 1
		if (ibuf_main.w.queued > 0)
d206 1
a206 1
		pfd[PFD_PIPE_SESSION].fd = ibuf_se.fd;
d208 1
a208 1
		if (ibuf_se.w.queued > 0)
d223 2
a224 2
		    ibuf_main.w.queued)
			if (msgbuf_write(&ibuf_main.w) < 0)
d229 1
a229 1
			rde_dispatch_imsg_parent(&ibuf_main);
d233 2
a234 2
		    ibuf_se.w.queued)
			if (msgbuf_write(&ibuf_se.w) < 0)
d239 1
a239 1
			rde_dispatch_imsg_session(&ibuf_se);
d255 6
a260 4
	msgbuf_write(&ibuf_se.w);
	msgbuf_clear(&ibuf_se.w);
	msgbuf_write(&ibuf_main.w);
	msgbuf_clear(&ibuf_main.w);
d339 1
a339 1
			imsg_compose_pid(&ibuf_se, IMSG_CTL_END, pid, NULL, 0);
d348 1
a348 1
			imsg_compose_pid(&ibuf_se, IMSG_CTL_END, pid, NULL, 0);
d358 1
a358 1
			imsg_compose_pid(&ibuf_se, IMSG_CTL_END, pid, NULL, 0);
d368 1
a368 1
			imsg_compose_pid(&ibuf_se, IMSG_CTL_END, pid, NULL, 0);
d380 1
a380 1
			imsg_compose_pid(&ibuf_se, IMSG_CTL_SHOW_NEIGHBOR,
d384 1
a384 1
			imsg_compose_pid(&ibuf_se, IMSG_CTL_END, imsg.hdr.pid,
d1319 1
a1319 1
	if ((wbuf = imsg_create(&ibuf_se, IMSG_UPDATE_ERR, peer->conf.id,
d1326 1
a1326 1
	if (imsg_close(&ibuf_se, wbuf) == -1)
d1441 1
a1441 1
	if ((wbuf = imsg_create_pid(&ibuf_se, IMSG_CTL_SHOW_RIB, pid,
d1448 1
a1448 1
	if (imsg_close(&ibuf_se, wbuf) == -1)
d1470 1
a1470 1
	if (imsg_compose_pid(&ibuf_se, IMSG_CTL_SHOW_RIB_PREFIX, pid,
d1595 1
a1595 1
	if (imsg_compose(&ibuf_main, type, 0, &kr, sizeof(kr)) == -1)
d1616 1
a1616 1
	if (imsg_compose(&ibuf_main,
d1625 1
a1625 1
	if (imsg_compose(&ibuf_main, IMSG_PFTABLE_COMMIT, 0, NULL, 0) == -1)
d1645 1
a1645 1
	if (imsg_compose(&ibuf_main, type, 0, next,
d1712 1
a1712 1
			if (imsg_compose(&ibuf_se, IMSG_UPDATE, peer->conf.id,
d1988 1
a1988 1
		    if (imsg_compose_pid(&ibuf_se, IMSG_CTL_SHOW_NETWORK, pid,
@


1.141
log
@Gahhh, why is this still around? It was never necessary to inform the parent
after fd passing. I thought I removed that some time ago... anyway now it
is gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.140 2004/08/10 13:02:08 claudio Exp $ */
d918 1
a918 1
		a->nexthop = nexthop_get(&nexthop, NULL);
d1194 1
a1194 1
	struct bgpd_addr	nexthop, llnh, *lp;
a1207 1
	bzero(&llnh, sizeof(llnh));
d1210 8
d1224 1
a1224 12
		lp = NULL;
		if (nhlen == 32) {
			/* 
			 * rfc 2545 describes that there may be a link local
			 * address carried in nexthop. Yikes.
			 */
			llnh.af = AF_INET6;
			memcpy(&llnh.v6.s6_addr, data, 16);
			/* XXX we need to set the scope_id */
			lp = &llnh;
		}
		asp->nexthop = nexthop_get(&nexthop, lp);
d1628 1
a1628 1
rde_send_nexthop(struct bgpd_addr *next, struct bgpd_addr *ll, int valid)
a1629 1
	struct buf		*wbuf;
d1638 1
a1638 4
	if (ll == NULL)
		size = sizeof(struct bgpd_addr);
	else
		size = 2 * sizeof(struct bgpd_addr);
d1640 3
a1642 9
	if ((wbuf = imsg_create(&ibuf_main, type, 0, size)) == NULL)
		fatal("imsg_create error");
	if (imsg_add(wbuf, next, sizeof(struct bgpd_addr)) == -1)
		fatal("imsg_add error");
	if (ll != NULL)
		if (imsg_add(wbuf, ll, sizeof(struct bgpd_addr)) == -1)
			fatal("imsg_add error");
	if (imsg_close(&ibuf_main, wbuf) == -1)
		fatal("imsg_close error");
@


1.140
log
@switch nexthop in struct filter_set form struct in_addr to struct bgpd_addr
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.139 2004/08/06 12:04:08 claudio Exp $ */
a475 5

			/* tell parent to close fd */
			if (imsg_compose(&ibuf_main, IMSG_MRT_CLOSE, 0,
			    xmrt, sizeof(struct mrt)) == -1)
				log_warn("rde_dispatch_imsg_parent: mrt close");
@


1.139
log
@Monster diff to get one step closer to IPv6 support.
Cleanup path attribute handling. First of all kill struct attr_flags, all
those infos are now in struct rde_aspath. Second move attribute parser
functions into rde.c, rde_attr.c is shared between bgpd and bgpctl.
Third reimplementation of the nexthop handling. Make it IPv6 ready and
fix some major bug relating to "set nexthop".
henning@@ OK if it breaks nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.138 2004/08/06 11:51:19 claudio Exp $ */
d688 1
a688 1
	rde_apply_set(asp, &peer->conf.attrset);
d763 3
d1967 1
a1967 1
	rde_apply_set(asp, &nc->attrset);
@


1.138
log
@Forward IMSG_CTL_SHOW_NEIGHBOR messages to the rde so that we can report
the current and max prefix count back to bgpctl. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.137 2004/08/05 21:01:38 claudio Exp $ */
d44 7
d58 1
a58 1
		     const struct rde_peer *, const struct attr_flags *,
d60 1
a60 1
int		 rde_reflector(struct rde_peer *, struct attr_flags *);
d511 3
a513 2
	u_char			*p, *emsg, *mpp;
	int			 pos;
d520 1
a520 2
	struct attr_flags	 attrs, fattrs;
	struct attr		*mpattr;
d547 5
d554 1
a554 1
		attr_init(&attrs);
d556 1
a556 1
			if ((pos = attr_parse(p, len, &attrs,
d558 2
a559 2
			    peer->conf.remote_as)) < 0) {
				emsg = attr_error(p, len, &attrs,
d563 1
a563 1
				attr_free(&attrs);
d571 2
a572 1
		if ((subtype = attr_missing(&attrs, peer->conf.ebgp)) != 0) {
d575 1
a575 1
			attr_free(&attrs);
d579 2
a580 2
		if (rde_reflector(peer, &attrs) != 1) {
			attr_free(&attrs);
d600 1
a600 1
				attr_free(&attrs);
d608 1
a608 1
				attr_free(&attrs);
d624 3
d628 3
a630 4
	if (attrpath_len != 0 &&
	    (mpattr = attr_optget(&attrs, ATTR_MP_UNREACH_NLRI)) != NULL) {
		mpp = mpattr->data;
		mplen = mpattr->len;
d646 2
a647 2
					    mpattr->data, mpattr->len);
					attr_free(&attrs);
d655 2
a656 2
					    mpattr->data, mpattr->len);
					attr_free(&attrs);
d672 1
a677 3
	if (attrpath_len == 0) /* 0 = no NLRI information in this message */
		return (0);

a679 3
	nlri_len =
	    imsg->hdr.len - IMSG_HEADER_SIZE - 4 - withdrawn_len - attrpath_len;

d682 2
a683 2
	if (peer->conf.ebgp && !aspath_loopfree(attrs.aspath, conf->as)) {
		attr_free(&attrs);
d688 1
a688 1
	rde_apply_set(&attrs, &peer->conf.attrset);
d697 1
a697 1
			attr_free(&attrs);
d704 1
a704 1
			attr_free(&attrs);
d715 1
a715 1
		attr_copy(&fattrs, &attrs);
d717 1
a717 1
		if (rde_filter(peer, &fattrs, &prefix, prefixlen,
d719 1
a719 1
			attr_free(&fattrs);
d729 2
a730 2
			attr_free(&attrs);
			attr_free(&fattrs);
d734 3
a736 2
		rde_update_log("update", peer, &fattrs, &prefix, prefixlen);
		path_update(peer, &fattrs, &prefix, prefixlen);
d740 3
a742 3
	if ((mpattr = attr_optget(&attrs, ATTR_MP_REACH_NLRI)) != NULL) {
		mpp = mpattr->data;
		mplen = mpattr->len;
d750 4
a753 1
		if ((pos = attr_mp_nexthop_check(mpp, mplen, afi)) == -1) {
d756 2
a757 2
			    mpattr->data, mpattr->len);
			attr_free(&attrs);
a759 1

a762 8
		if (*p++ != NULL) {
			/* XXX this is ugly */
			log_peer_warnx(&peer->conf, "SNPA are not supported");
			rde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,
			    mpattr->data, mpattr->len);
			attr_free(&attrs);
			return (-1);
		}
d772 2
a773 2
					    mpattr->data, mpattr->len);
					attr_free(&attrs);
d779 2
a780 2
					    mpattr->data, mpattr->len);
					attr_free(&attrs);
d787 1
a787 1
				attr_copy(&fattrs, &attrs);
d789 1
a789 1
				if (rde_filter(peer, &fattrs, &prefix,
d791 1
a791 1
					attr_free(&fattrs);
a794 1
				/* XXX IPv4 and IPv6 together */
d802 2
a803 2
					attr_free(&attrs);
					attr_free(&fattrs);
d807 2
a808 1
				rde_update_log("update", peer, &fattrs,
d810 1
a810 1
				path_update(peer, &fattrs, &prefix, prefixlen);
d818 1
a818 1
	attr_free(&attrs);
d823 425
d1334 1
a1334 1
    const struct rde_peer *peer, const struct attr_flags *attr,
d1343 4
a1346 10
	if (attr != NULL)
		if (attr_ismp(attr)) {
			if (asprintf(&nexthop, " via %s",
			    log_addr(attr_mp_nexthop(attr))) == -1)
				nexthop = NULL;
		else
			if (asprintf(&nexthop, " via %s",
			    inet_ntoa(attr->nexthop)) == -1)
				nexthop = NULL;
		}
d1358 4
d1363 1
a1363 1
rde_reflector(struct rde_peer *peer, struct attr_flags *attrs)
d1369 1
a1369 1
	if ((a = attr_optget(attrs, ATTR_ORIGINATOR_ID)) != NULL) {
d1374 1
a1374 1
	    attr_optadd(attrs, ATTR_OPTIONAL, ATTR_ORIGINATOR_ID,
d1381 1
a1381 1
		if ((a = attr_optget(attrs, ATTR_CLUSTER_LIST)) != NULL) {
d1398 1
a1398 1
		} else if (attr_optadd(attrs, ATTR_OPTIONAL, ATTR_CLUSTER_LIST,
d1415 2
a1416 2
	rib.local_pref = p->aspath->flags.lpref;
	rib.med = p->aspath->flags.med;
d1419 8
a1426 2
	memcpy(&rib.nexthop, &p->aspath->nexthop->true_nexthop,
	    sizeof(rib.nexthop));
d1429 1
a1429 1
	rib.origin = p->aspath->flags.origin;
d1435 4
a1438 1
	if (p->aspath->nexthop->state == NEXTHOP_REACH)
d1440 1
a1440 3
	if (p->aspath->nexthop->flags & NEXTHOP_ANNOUNCE)
		rib.flags |= F_RIB_ANNOUNCE;
	rib.aspath_len = aspath_length(p->aspath->flags.aspath);
d1446 1
a1446 1
	    imsg_add(wbuf, aspath_dump(p->aspath->flags.aspath),
d1466 4
a1469 1
	if (p->aspath->nexthop->state == NEXTHOP_REACH)
a1470 2
	if (p->aspath->nexthop->flags & NEXTHOP_ANNOUNCE)
		prefix.flags |= F_RIB_ANNOUNCE;
d1499 1
a1499 1
			if (!aspath_match(asp->flags.aspath, a->type, a->as))
d1554 1
d1569 4
a1572 3
	if ((old == NULL || old->aspath->nexthop->flags & NEXTHOP_ANNOUNCE) &&
	    (new == NULL || new->aspath->nexthop->state != NEXTHOP_REACH ||
	    new->aspath->nexthop->flags & NEXTHOP_ANNOUNCE))
d1579 1
a1579 1
	    new->aspath->nexthop->flags & NEXTHOP_ANNOUNCE) {
d1591 1
a1591 1
	if (p->aspath->flags.nexthop_reject)
d1593 1
a1593 1
	if (p->aspath->flags.nexthop_blackhole)
d1634 1
a1634 1
rde_send_nexthop(struct bgpd_addr *next, int valid)
d1636 3
a1638 1
	int			type;
d1645 14
a1658 3
	if (imsg_compose(&ibuf_main, type, 0, next,
	    sizeof(struct bgpd_addr)) == -1)
		fatal("imsg_compose error");
d1676 2
a1677 2
	if (old == NULL && (new == NULL ||
	    new->aspath->nexthop->state != NEXTHOP_REACH))
d1954 1
a1954 3
	struct attr_flags	 attrs;

	bzero(&attrs, sizeof(attrs));
d1956 6
a1961 6
	attrs.aspath = aspath_get(NULL, 0);
	attrs.nexthop.s_addr = INADDR_ANY;
	/* med = 0 */
	attrs.lpref = DEFAULT_LPREF;
	attrs.origin = ORIGIN_IGP;
	TAILQ_INIT(&attrs.others);
d1964 1
a1964 1
	rde_apply_set(&attrs, &nc->attrset);
d1967 1
a1967 1
		path_update(&peerself, &attrs, &nc->prefix, nc->prefixlen);
d1969 1
a1969 1
		path_update(&peerdynamic, &attrs, &nc->prefix, nc->prefixlen);
d1992 1
a1992 1
	    if (p->aspath->nexthop->flags & NEXTHOP_ANNOUNCE) {
d1995 1
a1995 1
		    k.prefix = addr.v4;
@


1.137
log
@The peer_l is not needed in the rde but still allocated, free them and
save 1k per peer. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.136 2004/08/05 20:56:11 claudio Exp $ */
d259 1
d261 1
d357 17
@


1.136
log
@As usual cleanup on exit. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.135 2004/08/05 18:44:19 claudio Exp $ */
d106 3
a108 3
rde_main(struct bgpd_config *config, struct network_head *net_l,
    struct filter_head *rules, struct mrt_head *mrt_l,
    int pipe_m2r[2], int pipe_s2r[2], int pipe_m2s[2])
d112 1
d160 6
a165 1
	/* main mrt list and listener list are not used in the SE */
@


1.135
log
@Cleanup aspath specific functions and api. Mainly switch to a refcnt based
allocation. This helps to save a bit of RAM. looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.134 2004/08/05 16:26:56 claudio Exp $ */
d1602 1
d1605 1
@


1.134
log
@struct prefix has a pointer to the peer so use it everywhere directly instead
of the detour via aspath.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.133 2004/08/05 15:58:21 claudio Exp $ */
d175 1
a647 3
		char *s;
		aspath_asprint(&s, attrs.aspath->data, attrs.aspath->hdr.len);
		free(s);
d1482 1
a1482 1
	attrs.aspath = aspath_create(NULL, 0);
@


1.133
log
@rename and move prefix_equal() to prefix_compare() which returns -1, 0, 1
similar to memcmp() and all other compare functions in bgpd. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.132 2004/08/05 15:19:50 henning Exp $ */
a973 2
	if (p->aspath->nexthop->state == NEXTHOP_REACH)
		rib.flags |= F_RIB_ELIGIBLE;
d976 1
a976 1
	if (p->aspath->peer->conf.ebgp == 0)
d978 2
a1003 2
	if (p->aspath->nexthop->state == NEXTHOP_REACH)
		prefix.flags |= F_RIB_ELIGIBLE;
d1006 1
a1006 1
	if (p->aspath->peer->conf.ebgp == 0)
d1008 2
@


1.132
log
@we wanna ignore SIGPIPE here just like in the session engine, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.131 2004/08/04 12:41:48 henning Exp $ */
d1066 1
a1066 1
	if (prefix_equal(&ctl->pref->prefix, &addr, ctl->pref->prefixlen))
@


1.131
log
@session_main() and rde_main() return... right, a pid. and a pid is a pid_t
and not an int.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.130 2004/07/30 14:44:30 claudio Exp $ */
d148 1
@


1.130
log
@Add new announce type "default-route" which will only announce the default
route to the specified neighbor. Idea and OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.129 2004/07/29 17:05:13 claudio Exp $ */
d105 1
a105 1
int
@


1.129
log
@Initalize local varible in rde_update_get_prefix or we may end up with funny
prefixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.128 2004/07/28 16:02:14 claudio Exp $ */
d1435 5
@


1.128
log
@The default localpreference is 100 and not 0. Found and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.127 2004/07/13 17:57:20 jaredy Exp $ */
d814 1
@


1.127
log
@fix some typos

ok henning otto
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.126 2004/07/05 16:54:53 henning Exp $ */
d1480 1
a1480 1
	/* lpref = 0 */
@


1.126
log
@implement "set nexthop blackhole" and "set nexthop reject"
blackhole/reject routes will be entered to the kernel for matching ones.
this is intended to be used with the Cymru Bogon Route Server Project
(http://www.cymru.com/BGP/bogon-rs.html) and similar services, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.125 2004/07/05 02:13:44 henning Exp $ */
d678 1
a678 1
		 * We need to copy attrs befor calling the filter because
d918 1
a918 1
			/* this is comming from myself */
d931 1
a931 1
				/* check if comming from my cluster */
d1546 1
a1546 1
	 * the decision process is turend of if rde_quit = 1 and
@


1.125
log
@fix a few KNF fallouts
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.124 2004/07/04 03:51:31 henning Exp $ */
d1112 2
a1118 1
		kr.nexthop.s_addr = 0;
d1128 4
@


1.124
log
@2 more file descriptors for each RDE and SE inherited from the parent
we should close
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.123 2004/07/04 03:37:03 henning Exp $ */
d199 1
a199 1
				
@


1.123
log
@when getting rid of the listen_addr TAILQ after forking actually close
the file descriptors in RDE and parent process, not needed or used there
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.122 2004/07/03 17:19:59 claudio Exp $ */
d108 1
a108 1
    int pipe_m2r[2], int pipe_s2r[2])
d151 2
@


1.122
log
@Switch mrt dumping to fd passing. This gives some speed up when extensive
dumping is done. Acctually mrt dumps were broken because of the fd passing.
The nice side effect is a much cleaner code, especially in the parent process.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.121 2004/06/24 23:15:58 claudio Exp $ */
d165 1
@


1.121
log
@First step at multiprotocol support, only partially done.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.120 2004/06/23 07:10:05 henning Exp $ */
d38 1
d88 1
a111 1
	struct mrt		*m;
d113 2
a114 2
	struct pollfd		 pfd[2];
	int			 nfds;
d157 3
a159 3
	while ((m = LIST_FIRST(mrt_l)) != NULL) {
		LIST_REMOVE(m, list);
		free(m);
d161 2
d190 8
a197 1
		if ((nfds = poll(pfd, 2, INFTIM)) == -1)
d220 9
a355 1
	struct mrt_config	 mrt;
d357 1
d422 33
a454 9
		case IMSG_MRT_REQ:
			memcpy(&mrt, imsg.data, sizeof(mrt));
			mrt.ibuf = &ibuf_main;
			if (mrt.type == MRT_TABLE_DUMP) {
				mrt_clear_seq();
				pt_dump(mrt_dump_upcall, &mrt, AF_UNSPEC);
				if (imsg_compose(&ibuf_main, IMSG_MRT_END,
				    mrt.id, NULL, 0) == -1)
					fatalx("imsg_compose error");
d456 2
d459 1
a459 1
		case IMSG_MRT_END:
d898 1
a898 1
	log_debug("neighbor %s (AS%u) %s %s/%u %s",
@


1.120
log
@kill that stupid AS path loop whining, that is normal
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.119 2004/06/22 23:17:01 claudio Exp $ */
d45 2
d429 1
a429 1
	u_char			*p, *emsg;
d431 1
a431 1
	u_int16_t		 len;
d435 1
a435 1
	u_int8_t		 prefixlen, subtype;
d438 1
d536 51
d656 84
d765 1
a765 1
	addr.a32.s_addr = 0;
d781 30
d835 1
d837 1
a837 1
	if (! (conf->log & BGPD_LOG_UPDATES))
d841 9
a849 1
		asprintf(&nexthop, " via %s", inet_ntoa(attr->nexthop));
d851 2
d855 1
a855 2
	    inet_ntoa(prefix->v4), prefixlen,
	    nexthop ? nexthop : "");
d858 1
@


1.119
log
@Cleanup. jajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.118 2004/06/22 20:28:58 claudio Exp $ */
a545 1
		log_peer_warnx(&peer->conf, "AS path loop: %s", s);
@


1.118
log
@Make the RDE IPv6 ready missing is the message handling. The internal
prefix tree changed form a hash table to a per AF RB tree.
OK henning@@ some ideas are from Brent Graveland.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.117 2004/06/20 18:35:12 henning Exp $ */
a31 1
#include "ensure.h"
a690 1
		ENSURE(a->len == 4);
a814 1
			ENSURE(!path_empty(asp));
a875 2
	ENSURE(old == NULL || old->aspath->nexthop != NULL);
	ENSURE(new == NULL || new->aspath->nexthop != NULL);
a963 2
	ENSURE(old == NULL || old->aspath->nexthop != NULL);
	ENSURE(new == NULL || new->aspath->nexthop != NULL);
a1086 1
	ENSURE(head != NULL);
d1090 1
a1090 1
			return peer;
d1092 1
a1092 1
	return NULL;
d1101 2
a1102 1
	ENSURE(peer_get(id) == NULL);
a1114 1
	ENSURE(head != NULL);
a1124 4
	ENSURE(peer->state == PEER_DOWN);
	ENSURE(peer_get(peer->conf.id) != NULL);
	ENSURE(LIST_EMPTY(&peer->path_h));

d1138 1
a1138 1
		log_warnx("peer_up: unknown peer id %d", id);
d1142 2
a1143 1
	ENSURE(peer->state == PEER_DOWN || peer->state == PEER_NONE);
a1317 1
	ENSURE(rde_quit != 0);
d1337 1
@


1.117
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.116 2004/06/06 17:38:10 henning Exp $ */
d293 1
a293 1
			pt_dump(network_dump_upcall, &pid);
d302 1
a302 1
			pt_dump(rde_dump_upcall, &pid);
d407 1
a407 1
				pt_dump(mrt_dump_upcall, &mrt);
d744 1
a744 1
	memcpy(&rib.prefix, &p->prefix->prefix, sizeof(rib.prefix));
d775 1
a775 1
	memcpy(&prefix.prefix, &p->prefix->prefix, sizeof(prefix.prefix));
d832 3
a834 3
	}		*ctl = ptr;
	struct prefix	*p;
	in_addr_t	 mask;
d836 6
a841 4
	mask = htonl(0xffffffff << (32 - ctl->pref->prefixlen));
	if (ctl->pref->prefixlen <= pt->prefixlen &&
	    (ctl->pref->prefix.v4.s_addr & mask) ==
	    (pt->prefix.v4.s_addr & mask))
d861 1
a861 1
		pt_dump(rde_dump_prefix_upcall, &ctl);
d874 2
a875 1
	struct kroute	 kr;
d903 2
a904 1
	kr.prefix.s_addr = p->prefix->prefix.v4.s_addr;
d1214 1
a1214 1
			pt_dump(up_dump_upcall, peer);
d1287 1
d1295 2
a1296 2
		    memcpy(&k.prefix, &p->prefix->prefix.v4.s_addr,
			sizeof(k.prefix));
@


1.116
log
@rework bgpd's handling of listening sockets. instead of one for each
supported address familiy, keep a tailq of an arbitary number of them.
the new struct listen_addr contains the sockaddr and the fd.
this fixes quite some nasty behaviour which was a consequence of the previous
model.
looks right deraadt@@, and discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.115 2004/05/21 15:36:40 claudio Exp $ */
d373 1
a373 1
			TAILQ_INSERT_TAIL(newrules, r, entries);
d392 1
a392 1
				TAILQ_REMOVE(rules_l, r, entries);
d1240 1
a1240 1
		TAILQ_REMOVE(net_l, n, network_l);
d1365 1
a1365 1
		TAILQ_REMOVE(rules_l, r, entries);
@


1.115
log
@RFC 2796 bgp route reflector support. This is very useful in conjunction
with templates. looks good, go for it henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.114 2004/05/21 12:10:22 claudio Exp $ */
d107 6
a112 5
	pid_t		 pid;
	struct passwd	*pw;
	struct mrt	*m;
	struct pollfd	 pfd[2];
	int		 nfds;
d154 1
a154 1
	/* main mrt list is not used in the SE */
d159 5
@


1.114
log
@Grrr. Forgot to cleanup dynamic announcements on shutdown.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.113 2004/05/21 11:48:56 claudio Exp $ */
d48 4
a57 3
void		 rde_update_log(const char *,
		     const struct rde_peer *, const struct attr_flags *,
		     const struct bgpd_addr *, u_int8_t);
d441 1
a441 1
	withdrawn_len = len = ntohs(len);
d448 44
d503 2
d511 2
a527 10
	memcpy(&len, p, 2);
	attrpath_len = ntohs(len);
	p += 2;
	if (imsg->hdr.len <
	    IMSG_HEADER_SIZE + 2 + withdrawn_len + 2 + attrpath_len) {
		rde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLIST, NULL, 0);
		return (-1);
	}
	nlri_len =
	    imsg->hdr.len - IMSG_HEADER_SIZE - 4 - withdrawn_len - attrpath_len;
d531 4
a534 14
	/* parse path attributes */
	attr_init(&attrs);
	while (attrpath_len > 0) {
		if ((pos = attr_parse(p, attrpath_len, &attrs, peer->conf.ebgp,
		    peer->conf.enforce_as, peer->conf.remote_as)) < 0) {
			emsg = attr_error(p, attrpath_len, &attrs,
			    &subtype, &size);
			rde_update_err(peer, ERR_UPDATE, subtype, emsg, size);
			attr_free(&attrs);
			return (-1);
		}
		p += pos;
		attrpath_len -= pos;
	}
a535 7
	/* check for missing but necessary attributes */
	if ((subtype = attr_missing(&attrs, peer->conf.ebgp)) != 0) {
		rde_update_err(peer, ERR_UPDATE, ERR_UPD_MISSNG_WK_ATTR,
		    &subtype, sizeof(u_int8_t));
		attr_free(&attrs);
		return (-1);
	}
d543 1
a543 2
		aspath_destroy(attrs.aspath);
		attr_optfree(&attrs);
d676 44
@


1.113
log
@Add support for dynamic announcements. Usefule to annouce temporary
blackhole routes or to make network announcements dependent on a external
state (e.g. for carp setups) OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.112 2004/05/08 19:17:20 henning Exp $ */
d1281 7
@


1.112
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.111 2004/05/07 10:06:15 djm Exp $ */
d69 4
a72 1
void		 network_add(struct network_config *);
d81 1
d257 32
d356 2
a357 2
		case IMSG_RECONF_NETWORK:
			network_add(imsg.data);
d1161 6
d1170 1
a1170 1
		network_add(&n->net);
d1176 1
a1176 1
network_add(struct network_config *nc)
d1192 46
a1237 1
	path_update(&peerself, &attrs, &nc->prefix, nc->prefixlen);
@


1.111
log
@add a filter option to dump prefixes learned in UPDATEs into a PF table,
intended for building realtime BGP blacklists (e.g. with spamd);
ok claudio & henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.110 2004/04/30 05:47:50 deraadt Exp $ */
d804 1
a804 1
rde_send_pftable(const char *table, struct bgpd_addr *addr, 
d818 1
a818 1
	    del ? IMSG_PFTABLE_REMOVE : IMSG_PFTABLE_ADD, 
@


1.110
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.109 2004/04/29 19:56:04 deraadt Exp $ */
d801 30
d1082 3
@


1.109
log
@sock -> fd; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.108 2004/04/28 04:36:16 claudio Exp $ */
d860 1
a860 1
			wpos = 2; /* reserve space for the lenght field */
d864 1
a864 1
			/* write withdraws lenght filed */
d877 1
a877 1
				 * needed withdraw and path attribute lenght.
@


1.108
log
@Unbreak the stuff that I commited first that was totaly broken. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.107 2004/04/28 03:34:38 henning Exp $ */
d165 1
a165 1
		pfd[PFD_PIPE_MAIN].fd = ibuf_main.sock;
d170 1
a170 1
		pfd[PFD_PIPE_SESSION].fd = ibuf_se.sock;
@


1.107
log
@make this at least compile
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.106 2004/04/28 02:57:27 claudio Exp $ */
d1059 8
a1069 1
#if 0
a1070 1
#endif
a1073 1
#if 0
a1074 1
#endif
@


1.106
log
@Enable route refresh in the RDE. Now peer can request route refreshes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.105 2004/04/27 04:38:12 deraadt Exp $ */
d1059 1
a1059 1
	if (afi == AFI_ALL |afi == AFI_IPv4)
d1062 1
d1064 1
d1068 1
d1070 1
@


1.105
log
@crud stripping; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.104 2004/04/25 17:34:39 claudio Exp $ */
d66 1
d217 1
d245 8
d1028 1
a1028 1
	pt_dump(up_dump_upcall, peer);
d1054 13
@


1.104
log
@Remove the no longer needed configure stuff in RDE. The peer list needs no
longer to be synced between parent, SE and RDE. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.103 2004/04/25 07:16:24 henning Exp $ */
d105 1
a105 1
	int		 n, nfds;
d180 1
a180 1
			if ((n = msgbuf_write(&ibuf_main.w)) < 0)
d190 1
a190 1
			if ((n = msgbuf_write(&ibuf_se.w)) < 0)
@


1.103
log
@add "neighbor cloning", allowing you to specify a prefix and prefixlength
instead of the neighbor's IP address. WHen a connection comes in matching
that mask we clone the neighbor spec.
IPv6 match code by itojun, rde feeding by claudio, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.102 2004/04/25 02:57:55 henning Exp $ */
d59 1
a59 1
void		 peer_init(struct peer *, u_int32_t);
d97 3
a99 3
rde_main(struct bgpd_config *config, struct peer *peer_l,
    struct network_head *net_l, struct filter_head *rules,
    struct mrt_head *mrt_l, int pipe_m2r[2], int pipe_s2r[2])
d156 1
a156 1
	peer_init(peer_l, peerhashsize);
a283 2
	struct peer_config	*pconf;
	struct rde_peer		*p, *np;
a309 9
		case IMSG_RECONF_PEER:
			pconf = imsg.data;
			if ((p = peer_get(pconf->id)) == NULL)
				p = peer_add(pconf->id, pconf);
			else
				memcpy(&p->conf, pconf,
				    sizeof(struct peer_config));
			p->conf.reconf_action = RECONF_KEEP;
			break;
a324 15
			for (p = LIST_FIRST(&peerlist);
			    p != NULL; p = np) {
				np = LIST_NEXT(p, peer_l);
				switch (p->conf.reconf_action) {
				case RECONF_NONE:
					peer_remove(p);
					break;
				case RECONF_KEEP:
					/* reset state */
					p->conf.reconf_action = RECONF_NONE;
					break;
				default:
					break;
				}
			}
d907 1
a907 1
peer_init(struct peer *peer_l, u_int32_t hashsize)
@


1.102
log
@&d and %d have different meanings in format strings, yeah
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.101 2004/03/20 23:17:35 david Exp $ */
a934 1
	struct peer	*p, *next;
a947 8

	for (p = peer_l; p != NULL; p = next) {
		next = p->next;
		p->conf.reconf_action = RECONF_NONE;
		peer_add(p->conf.id, &p->conf);
		free(p);
	}
	peer_l = NULL;
d982 1
a982 1
	struct rde_peer	*peer;
d1008 3
a1010 10
	/*
	 * If the session is up we wait until we get the IMSG_SESSION_DOWN
	 * message. If the session is down or was never up we delete the
	 * peer.
	 */
	if (peer->state == PEER_UP) {
		peer->conf.reconf_action = RECONF_DELETE;
	} else {
		ENSURE(peer_get(peer->conf.id) != NULL);
		ENSURE(LIST_EMPTY(&peer->path_h));
d1012 2
a1013 2
		LIST_REMOVE(peer, hash_l);
		LIST_REMOVE(peer, peer_l);
d1015 1
a1015 2
		free(peer);
	}
d1023 1
a1023 1
	peer = peer_get(id);
d1069 1
a1069 2
	if (peer->conf.reconf_action == RECONF_DELETE)
		peer_remove(peer);
@


1.101
log
@comment spelling fixes; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.100 2004/03/15 11:48:04 henning Exp $ */
d1072 1
a1072 1
		log_warnx("peer_down: unknown peer id &d", id);
@


1.100
log
@properly check chdir success after chroot() and tweak err msgs a little,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.99 2004/03/12 20:48:09 henning Exp $ */
d1166 1
a1166 1
			/* finaly remove peer */
d1170 1
a1170 1
	/* free annoced network prefixes */
@


1.99
log
@tweak err reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.98 2004/03/12 19:33:30 henning Exp $ */
d122 3
a124 2
		fatal("chroot failed");
	chdir("/");
@


1.98
log
@not debugging any more
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.97 2004/03/11 17:34:01 henning Exp $ */
d667 1
a667 2
	    sizeof(rib) + rib.aspath_len)) == NULL) {
		log_warnx("rde_dump_upcall: imsg_create error");
a668 1
	}
d671 1
a671 2
	    rib.aspath_len) == -1) {
		log_warnx("rde_dump_upcall: imsg_add error");
d673 1
a673 3
	}
	if (imsg_close(&ibuf_se, wbuf) == -1) {
		log_warnx("rde_dump_upcall: imsg_close error");
a674 1
	}
@


1.97
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.96 2004/03/11 14:22:23 claudio Exp $ */
d207 1
a207 1
	exit(0);
@


1.96
log
@Shutdown the RDE cleanly on exit. Plug some memleaks. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.95 2004/03/10 14:29:37 henning Exp $ */
d200 1
a200 1
	
@


1.95
log
@when we exit try to write out what is left in the msg buffers for the imsg
pipes and clear buffers afterwards
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.94 2004/03/05 22:21:32 claudio Exp $ */
d60 1
d70 2
d99 1
a99 1
    int pipe_m2r[2], int pipe_s2r[2])
d103 1
d146 6
d199 2
d207 1
a207 1
	_exit(0);
d964 12
d1136 58
@


1.94
log
@Plug some memory leaks in rde. Based on a patch by Patrick Latifi.
Added attr_move() so that we can copy the attribute before calling the filter.
path_update() will now use the passed attribute so it can't be simply reused.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.93 2004/03/02 19:29:01 claudio Exp $ */
d188 5
@


1.93
log
@Framework for rib lookups by prefix. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.92 2004/03/01 16:02:01 claudio Exp $ */
d391 1
a391 1
	struct attr_flags	 attrs;
a511 1
		/* input filter */
d513 2
a514 2
		 * XXX we need to copy attrs befor calling the filter
		 * but that stinks, because we copy it again in path_update.
d516 5
a520 2
		if (rde_filter(peer, &attrs, &prefix, prefixlen,
		    DIR_IN) == ACTION_DENY)
d522 1
d531 1
d535 2
a536 2
		rde_update_log("update", peer, &attrs, &prefix, prefixlen);
		path_update(peer, &attrs, &prefix, prefixlen);
@


1.92
log
@Make it possible to diable the decision process. This is a feature only useful
for route-collectors. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.91 2004/02/27 20:53:56 claudio Exp $ */
d48 2
a49 2
void		 rde_dump_rib(struct prefix *, pid_t);
void		 rde_dump_prefix(struct prefix *, pid_t);
d52 2
d244 10
d619 1
a619 1
rde_dump_rib(struct prefix *p, pid_t pid)
d663 1
a663 1
rde_dump_prefix(struct prefix *p, pid_t pid)
d693 1
a693 1
	    rde_dump_rib(p, pid);
d702 1
a702 1
	u_long				 i;
d711 1
a711 1
			rde_dump_rib(LIST_FIRST(&asp->prefix_h), pid);
d714 1
a714 1
				rde_dump_prefix(p, pid);
d717 40
@


1.91
log
@remove unneded peer pointer in struct prefix and change a in_addr_t to
struct in_addr. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.90 2004/02/27 14:46:09 claudio Exp $ */
d321 9
a793 6
u_int16_t
rde_local_as(void)
{
	return conf->as;
}

d838 14
d973 8
@


1.90
log
@Cleanup no functional changes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.89 2004/02/26 16:16:41 claudio Exp $ */
a578 1
	struct in_addr	 nh;
d583 2
a584 4
	if (attr != NULL) {
		nh.s_addr = attr->nexthop;
		asprintf(&nexthop, " via %s", inet_ntoa(nh));
	}
d618 1
a618 1
	if (p->peer->conf.ebgp == 0)
d654 1
a654 1
	if (p->peer->conf.ebgp == 0)
d1016 1
a1016 1
	attrs.nexthop = INADDR_ANY;
@


1.89
log
@show rib infrastructure. At least full dumps and per as dumps. Per prefix
dump need some more work. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.88 2004/02/26 14:00:33 claudio Exp $ */
d692 1
a692 1
			ENSURE(!LIST_EMPTY(&asp->prefix_h));
@


1.88
log
@Implement "enforce neighbor-as yes|no" which is by default on for ebgp
neighbors. While doing that check also that the nexthop is valid (not class D
or E and not in 127/8 range). Kill some TODO and XXX and rename the british
neighbour to neighbor as used everywhere else. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.87 2004/02/26 09:53:58 claudio Exp $ */
d48 4
d196 1
d223 19
d595 104
@


1.87
log
@Add per netwok definition filter sets. So you can now use
network 10.0.0.0/8 set localpref 100
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.86 2004/02/25 19:48:18 claudio Exp $ */
d412 2
a413 2
		if ((pos = attr_parse(p, attrpath_len, &attrs,
		    peer->conf.ebgp)) < 0) {
@


1.86
log
@Rewrite some parts of the mrt dump handling. It is no longer possible to
dump the filtered updates but therefore it is now possible to dump per
neighbor and also to dump the outgoing messages. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.85 2004/02/24 15:43:03 claudio Exp $ */
d896 3
@


1.85
log
@Enhance filters. prefixlen knows now 8-24 and 8><24. It is possible to use
prefix 10.0.0.0/8 prefixlen >= 8 and set localpref 100 can be set on a per
neighbor basis. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.84 2004/02/23 17:19:26 claudio Exp $ */
a71 3
int			 mrt_flagfilter = 0;
struct mrt_config	 mrt_filter;

d314 1
a314 1
			mrt.msgbuf = &ibuf_main.w;
a320 3
			} else if (mrt.type == MRT_FILTERED_IN) {
				mrt_flagfilter = 1;
				memcpy(&mrt_filter, &mrt, sizeof(mrt_filter));
a323 1
			memcpy(&mrt, imsg.data, sizeof(mrt));
a324 4
			if (mrt.type == MRT_FILTERED_IN) {
				mrt_flagfilter = 0;
				bzero(&mrt_filter, sizeof(mrt_filter));
			}
a352 5

	if (mrt_flagfilter == 1)
		mrt_dump_bgp_msg(&mrt_filter, imsg->data,
		    imsg->hdr.len - IMSG_HEADER_SIZE, UPDATE,
		    &peer->conf, conf);
@


1.84
log
@I was hunting this bug for quite some time. Don't use a value you need later
as counter. This fixes the bad nlri prefix errors I got. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.83 2004/02/19 23:07:00 claudio Exp $ */
d458 4
a461 1
	
d482 1
a482 1
		
@


1.83
log
@Add support for basic filters. Nothing optimized and it has some issues but
this is a huge step forward. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.82 2004/02/19 13:54:58 claudio Exp $ */
d373 1
a373 1
	withdrawn_len = ntohs(len);
d381 2
a382 2
	while (withdrawn_len > 0) {
		if ((pos = rde_update_get_prefix(p, withdrawn_len, &prefix,
d388 1
d394 1
a394 2
			log_peer_warnx(&peer->conf, "bad prefix %s/%u",
			    inet_ntoa(prefix.v4), prefixlen);
d401 1
a401 1
		withdrawn_len -= pos;
d463 1
d470 1
a470 2
			log_peer_warnx(&peer->conf, "bad prefix %s/%u",
			    inet_ntoa(prefix.v4), prefixlen);
d473 1
@


1.82
log
@Make the code more portable. Add some missing header files and make the use
of the queue(3) makros more portable. OK henning@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.81 2004/02/18 23:18:16 claudio Exp $ */
d380 1
d402 6
d425 1
d433 1
a433 2
			aspath_destroy(attrs.aspath);
			attr_optfree(&attrs);
d440 1
d444 1
a444 2
		aspath_destroy(attrs.aspath);
		attr_optfree(&attrs);
d459 1
d465 1
a465 2
			aspath_destroy(attrs.aspath);
			attr_optfree(&attrs);
d478 11
a488 1
		rde_update_log("update", peer, &attrs, &prefix, prefixlen);
d494 1
a494 2
			aspath_destroy(attrs.aspath);
			attr_optfree(&attrs);
d497 2
d503 1
a503 2
	aspath_destroy(attrs.aspath);
	attr_optfree(&attrs);
@


1.81
log
@Correctly handle parse errors in aspath and prefixes. Also do input aspath
loop detection. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.80 2004/02/18 16:36:09 claudio Exp $ */
d22 1
d25 1
d286 1
a286 1
			    p != LIST_END(&peerlist); p = np) {
d845 1
a845 3
	for (asp = LIST_FIRST(&peer->path_h);
	    asp != LIST_END(&peer->path_h);
	    asp = nasp) {
d871 1
a871 2
	for (n = TAILQ_FIRST(net_l); n != TAILQ_END(net_l);
	    n = TAILQ_FIRST(net_l)) {
@


1.80
log
@Bring the path attribute parsing on big step closer to the RFC.
Check that evry attribut is only allowed once and ensure that the
mandatory attributes are present.
no objections henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.79 2004/02/17 19:12:58 claudio Exp $ */
d389 8
d419 1
a419 1
		    peer->conf.ebgp, conf->as)) < 0) {
d439 11
d459 8
@


1.79
log
@Somehow size needs some time to settle. The direct inline call of attr_error
caused troubles on my test machines which manifested in garbage size values.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.78 2004/02/16 14:26:29 claudio Exp $ */
d412 2
a413 1
			emsg = attr_error(p, attrpath_len, &subtype, &size);
d421 8
@


1.78
log
@Extend imsg API so that messages can be composed on the fly. In the RDE it
happens often, that imsg consists of multiple objects. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.77 2004/02/16 12:53:15 claudio Exp $ */
d347 1
a347 1
	u_char			*p;
d412 2
a413 2
			rde_update_err(peer, ERR_UPDATE, subtype,
			    attr_error(p, attrpath_len, &subtype, &size), size);
@


1.77
log
@Make the path attribute handling more RFC conformant. Also move the
parser to rde_attr.c where it belongs. Still missing: better aspath loop
detection (should be done afterwards) and some basic error checking for
optional attributes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.76 2004/02/09 01:56:18 henning Exp $ */
d492 1
a492 1
	u_char	buf[1024];
d494 9
a502 8
	buf[0] = error;
	buf[1] = suberr;
	if (size > sizeof(buf) - 2)
		size = sizeof(buf) - 2;
	memcpy(buf + 2, data, size);
	if (imsg_compose(&ibuf_se, IMSG_UPDATE_ERR, peer->conf.id,
	    buf, size + 2) == -1)
		fatal("imsg_compose error");
@


1.76
log
@replace a bunch of u_long by u_int32_t
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.75 2004/02/09 01:46:34 henning Exp $ */
d44 2
a45 4
void		 init_attr_flags(struct attr_flags *);
int		 rde_update_get_attr(struct rde_peer *, u_char *, u_int16_t,
		     struct attr_flags *);
void		 rde_update_err(struct rde_peer *, enum suberr_update);
d352 2
a353 2
	u_int16_t		 nlri_len;
	u_int8_t		 prefixlen;
d374 1
a374 1
		rde_update_err(peer, ERR_UPD_ATTRLIST);
d381 6
a386 1
			rde_update_err(peer, ERR_UPD_ATTRLIST);
d400 1
a400 1
		rde_update_err(peer, ERR_UPD_ATTRLIST);
d408 1
a408 1
	init_attr_flags(&attrs);
d410 6
a415 3
		if ((pos = rde_update_get_attr(peer, p, attrpath_len,
		    &attrs)) < 0) {
			rde_update_err(peer, ERR_UPD_ATTRLIST);
d425 4
a428 1
			rde_update_err(peer, ERR_UPD_ATTRLIST);
d437 5
a441 2
			rde_update_err(peer, ERR_UPD_UNSPECIFIC);
			break;
a487 98
#define UPD_READ(t, p, plen, n) \
	do { \
		memcpy(t, p, n); \
		p += n; \
		plen += n; \
	} while (0)

void
init_attr_flags(struct attr_flags *a)
{
	bzero(a, sizeof(struct attr_flags));
	a->origin = ORIGIN_INCOMPLETE;
	TAILQ_INIT(&a->others);
}

int
rde_update_get_attr(struct rde_peer *peer, u_char *p, u_int16_t len,
    struct attr_flags *a)
{
	u_int32_t	 tmp32;
	u_int16_t	 attr_len;
	u_int16_t	 plen = 0;
	u_int8_t	 flags;
	u_int8_t	 type;
	u_int8_t	 tmp8;
	int		 r; /* XXX */

	if (len < 3)
		return (-1);

	UPD_READ(&flags, p, plen, 1);
	UPD_READ(&type, p, plen, 1);

	if (flags & ATTR_EXTLEN) {
		if (len - plen < 2)
			return (-1);
		UPD_READ(&attr_len, p, plen, 2);
	} else {
		UPD_READ(&tmp8, p, plen, 1);
		attr_len = tmp8;
	}

	if (len - plen < attr_len)
		return (-1);

	switch (type) {
	case ATTR_UNDEF:
		/* error! */
		return (-1);
	case ATTR_ORIGIN:
		if (attr_len != 1)
			return (-1);
		UPD_READ(&a->origin, p, plen, 1);
		break;
	case ATTR_ASPATH:
		if ((r = aspath_verify(p, attr_len, conf->as)) != 0) {
			/* XXX could also be a aspath loop but this
			 * check should be moved to the filtering. */
			log_warnx("XXX aspath_verify failed: error %i", r);
			return (-1);
		}
		a->aspath = aspath_create(p, attr_len);
		plen += attr_len;
		break;
	case ATTR_NEXTHOP:
		if (attr_len != 4)
			return (-1);
		UPD_READ(&a->nexthop, p, plen, 4);	/* network byte order */
		break;
	case ATTR_MED:
		if (attr_len != 4)
			return (-1);
		UPD_READ(&tmp32, p, plen, 4);
		a->med = ntohl(tmp32);
		break;
	case ATTR_LOCALPREF:
		if (attr_len != 4)
			return (-1);
		if (peer->conf.ebgp) {
			/* ignore local-pref attr for non ibgp peers */
			a->lpref = 0;	/* set a default value */
			break;
		}
		UPD_READ(&tmp32, p, plen, 4);
		a->lpref = ntohl(tmp32);
		break;
	case ATTR_ATOMIC_AGGREGATE:
	case ATTR_AGGREGATOR:
	default:
		attr_optadd(a, flags, type, p, attr_len);
		plen += attr_len;
		break;
	}

	return (plen);

}

d489 2
a490 1
rde_update_err(struct rde_peer *peer, enum suberr_update errorcode)
d492 1
a492 1
	u_int8_t	errcode;
d494 5
a498 1
	errcode = errorcode;
d500 1
a500 1
	    &errcode, sizeof(errcode)) == -1)
@


1.75
log
@make max_prefix an u_int32_t instead of an u_long and change its
meaning as in 0 means no limit insytead of setting it to ULONG_MAX for
no limit
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.74 2004/02/07 11:42:30 henning Exp $ */
d53 1
a53 1
void		 peer_init(struct peer *, u_long);
d86 3
a88 3
u_long	peerhashsize = 64;
u_long	pathhashsize = 1024;
u_long	nexthophashsize = 64;
d753 1
a753 1
	u_long			 peer_hashmask;
d760 1
a760 1
peer_init(struct peer *peer_l, u_long hashsize)
d763 1
a763 1
	u_long		 hs, i;
@


1.74
log
@send filter rules to the RDE on reloads, help & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.73 2004/02/02 19:14:11 deraadt Exp $ */
d425 2
a426 1
		if (peer->prefix_cnt >= peer->conf.max_prefix) {
a910 1
	peerself.conf.max_prefix = ULONG_MAX;
@


1.73
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.72 2004/02/02 18:56:25 claudio Exp $ */
d68 1
d92 2
a93 1
    struct network_head *net_l, int pipe_m2r[2], int pipe_s2r[2])
d143 1
a143 1

d235 1
d252 4
d273 9
d304 6
@


1.72
log
@Fix bug in the decision process. The decision process is unable to directly
detect changes of the active prefix. This bug is only triggered when a
nexthop changes state. While doing that clarify prefix_move a bit.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.71 2004/02/02 16:44:05 claudio Exp $ */
d663 1
a663 1
	if (old == NULL && (new == NULL || 
@


1.71
log
@Seal a memory leak and fix a format string, conf->as is unsigned.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.70 2004/01/28 19:24:06 henning Exp $ */
d597 9
a605 5
	if ((old == NULL || old->aspath->nexthop == NULL ||
	    old->aspath->nexthop->state != NEXTHOP_REACH ||
	    old->aspath->nexthop->flags & NEXTHOP_ANNOUNCE) &&
	    (new == NULL || new->aspath->nexthop == NULL ||
	    new->aspath->nexthop->state != NEXTHOP_REACH ||
d656 8
a663 3
	if ((old == NULL || old->aspath->nexthop == NULL ||
	    old->aspath->nexthop->state != NEXTHOP_REACH) &&
	    (new == NULL || new->aspath->nexthop == NULL ||
@


1.70
log
@catch SIGINT here as well so we can properly shut down if ^C'ed in debug mode
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.69 2004/01/27 21:56:21 henning Exp $ */
d413 1
d882 1
a882 1
	    "LOCAL AS %hd", conf->as);
@


1.69
log
@move strict kroute from in_addr_t for nexthop and prefix to struct in_addr
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.68 2004/01/27 16:49:53 henning Exp $ */
d78 1
d128 1
@


1.68
log
@use a struct bgpd_addr instead of sockaddr_in for peer_config->local_addr and
->remote_addr for easier multiprotocol support

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.67 2004/01/22 21:09:00 henning Exp $ */
d607 1
a607 1
		kr.nexthop = 0;
d611 1
a611 1
		kr.nexthop = p->aspath->nexthop->true_nexthop.v4.s_addr;
d614 1
a614 1
	kr.prefix = p->prefix->prefix.v4.s_addr;
@


1.67
log
@provide a log_debug and use it in rde.c.
with this, logit() can be a private function.
we don't need to include syslog.h in bgpd.h any more; log.c and parse.y
who need it include it directly now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.66 2004/01/22 21:01:26 henning Exp $ */
a564 1
	char		*neighbor;
a570 4
	neighbor = strdup(inet_ntoa(peer->conf.remote_addr.sin_addr));
	if (neighbor == NULL)
		return;

d577 1
a577 1
	    neighbor, peer->conf.remote_as, message,
a580 1
	free(neighbor);
@


1.66
log
@use log_peer_warnx() now that we can, claudio agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.65 2004/01/22 20:34:56 henning Exp $ */
d581 1
a581 2
	logit(LOG_DEBUG, "neighbor %s (AS%u) %s %s/%u"
	    "%s",
@


1.65
log
@use log_warnx and log_info. reclassify a few messages in the process and fix
a few messages.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.64 2004/01/17 19:35:36 claudio Exp $ */
d402 1
a402 2
			log_warnx("peer %s: prefix limit reached",
			    peer->conf.descr);			/* LXXX */
@


1.64
log
@Make it possible to announce own networks. In the RDE these prefixes are
attached to a pseudo peer and inserted like all other prefixes into the RIB.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.63 2004/01/13 13:45:49 claudio Exp $ */
d142 1
a142 1
	logit(LOG_INFO, "route decision engine ready");
d182 1
a182 1
	logit(LOG_INFO, "route decision engine exiting");
d286 1
a286 1
			logit(LOG_INFO, "RDE reconfigured");
d402 2
a403 2
			logit(LOG_CRIT, "peer %s max prefix limit reached",
			    peer->conf.descr);
d509 1
a509 2
			logit(LOG_INFO,
			    "XXX aspath_verify failed: error %i\n", r);
d830 1
a830 1
		logit(LOG_CRIT, "peer_up: unknown peer id %d", id);
d852 1
a852 1
		logit(LOG_CRIT, "peer_down: unknown peer id &d", id);
a910 2
	logit(LOG_DEBUG, "adding network %s/%d",
	    inet_ntoa(nc->prefix.v4), nc->prefixlen);
@


1.63
log
@Implement a max-prefix and a announce none | self | all neighbor statement.
The first limits the number of sent prefixes per peer the latter controls
which prefix we do annouce to the neighbor.
Another looks good from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.62 2004/01/13 13:34:56 claudio Exp $ */
d60 3
d65 1
d67 1
d89 2
a90 2
rde_main(struct bgpd_config *config, struct peer *peer_l, int pipe_m2r[2],
    int pipe_s2r[2])
d132 4
a135 1
	peer_init(peer_l, peerhashsize);
d138 3
a140 3
	pt_init();
	imsg_init(&ibuf_se, pipe_s2r[1]);
	imsg_init(&ibuf_main, pipe_m2r[1]);
d246 1
d261 3
d285 1
d604 2
a605 1
	    old->aspath->nexthop->state != NEXTHOP_REACH) &&
d607 2
a608 1
	    new->aspath->nexthop->state != NEXTHOP_REACH))
d612 2
a613 1
	    new->aspath->nexthop->state != NEXTHOP_REACH) {
d872 45
@


1.62
log
@Better update error handling. Ensure that the session goes down and
ignore all queued updates after an error. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.61 2004/01/13 13:18:03 claudio Exp $ */
d388 6
@


1.61
log
@Dump and send RIB to the neighbor if his session is comming up.
Now bgpctl neighbor <IP> up does work as expected.
Looks good from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.60 2004/01/11 22:08:04 henning Exp $ */
d47 1
a47 1
void		 rde_update_err(u_int32_t, enum suberr_update);
d339 1
a339 1
		rde_update_err(peer->conf.id, ERR_UPD_ATTRLIST);
d346 1
a346 1
			rde_update_err(peer->conf.id, ERR_UPD_ATTRLIST);
d360 1
a360 1
		rde_update_err(peer->conf.id, ERR_UPD_ATTRLIST);
d372 1
a372 1
			rde_update_err(peer->conf.id, ERR_UPD_ATTRLIST);
d382 1
a382 1
			rde_update_err(peer->conf.id, ERR_UPD_ATTRLIST);
d532 1
a532 1
rde_update_err(u_int32_t peerid, enum suberr_update errorcode)
d537 1
a537 1
	if (imsg_compose(&ibuf_se, IMSG_UPDATE_ERR, peerid,
d540 1
d812 2
@


1.60
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.59 2004/01/11 22:06:57 claudio Exp $ */
d630 18
d817 1
@


1.59
log
@This comment is not true. We decided to use a separate struct kroute6
for IPv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.58 2004/01/11 21:57:58 henning Exp $ */
d548 1
a548 1
	char	 	*nexthop = NULL;
@


1.58
log
@remove obsolete comment
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.57 2004/01/11 21:56:07 claudio Exp $ */
a599 1
	/* XXX switch struct kroute to bgpd_addr too */
@


1.57
log
@Bad sizeof slipped in while resolving a conflict. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.56 2004/01/11 21:47:20 claudio Exp $ */
a620 1
	/* XXX change to bgpd_addr */
@


1.56
log
@Move all struct in_addr to either struct bgpd_addr or in_addr_t whichever
is more appropriate. The rde uses now in most cases struct bgpd_addr.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.55 2004/01/11 21:32:56 henning Exp $ */
d622 2
a623 1
	if (imsg_compose(&ibuf_main, type, 0, next, sizeof(in_addr_t)) == -1)
@


1.55
log
@in the nexthop imsgs use struct bgpd_addr for the data part instead of
in_addr_t

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.54 2004/01/11 20:13:00 claudio Exp $ */
d42 1
a42 1
int		 rde_update_get_prefix(u_char *, u_int16_t, struct in_addr *,
d50 1
a50 1
		     const struct in_addr *, u_int8_t);
d319 1
a319 1
	struct in_addr		 prefix;
d352 1
a352 1
		prefix_remove(peer, prefix, prefixlen);
d388 1
a388 1
		path_update(peer, &attrs, prefix, prefixlen);
d398 1
a398 1
rde_update_get_prefix(u_char *p, u_int16_t len, struct in_addr *prefix,
d425 2
a426 1
	prefix->s_addr = addr.a32.s_addr;
d545 1
a545 1
    const struct in_addr *prefix, u_int8_t prefixlen)
d547 3
a549 2
	char *neighbor;
	char *nexthop = NULL;
d559 2
a560 1
		asprintf(&nexthop, " via %s", inet_ntoa(attr->nexthop));
d566 1
a566 1
	    inet_ntoa(*prefix), prefixlen,
d597 1
a597 1
		kr.nexthop = p->aspath->nexthop->true_nexthop.s_addr;
d600 2
a601 1
	kr.prefix = p->prefix->prefix.s_addr;
d612 1
a612 1
rde_send_nexthop(in_addr_t next, int valid)
a614 1
	struct bgpd_addr	addr;
d621 2
a622 4
	addr.af = AF_INET;
	addr.v4.s_addr = next;

	if (imsg_compose(&ibuf_main, type, 0, &addr, sizeof(addr)) == -1)
@


1.54
log
@Add to the IMSG_SESSION_UP message the local and remote address of the
peer session. This is needed to set the correct nexthop address in outgoing
bgp UPDATES. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.53 2004/01/11 02:39:05 henning Exp $ */
d405 2
a406 2
		struct in_addr	addr32;
		u_int8_t	addr8[4];
d416 1
a416 1
	addr.addr32.s_addr = 0;
d421 1
a421 1
			memcpy(&addr.addr8[i], p++, 1);
d425 1
a425 1
	prefix->s_addr = addr.addr32.s_addr;
d610 2
a611 1
	int	type;
d618 4
a621 1
	if (imsg_compose(&ibuf_main, type, 0, &next, sizeof(next)) == -1)
@


1.53
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.52 2004/01/10 22:25:42 claudio Exp $ */
d57 1
a57 1
void		 peer_up(u_int32_t, u_int32_t);
d182 1
a182 1
	u_int32_t		 rid;
d201 1
a201 1
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(rid))
d203 2
a204 2
			memcpy(&rid, imsg.data, sizeof(rid));
			peer_up(imsg.hdr.peerid, rid);
d780 1
a780 1
peer_up(u_int32_t id, u_int32_t rid)
d789 4
a792 1
	peer->remote_bgpid = ntohl(rid);
@


1.52
log
@Implement as path prepends. At least one prepend is needed for ebgp
neighbors. Fix a bug in the update generation. If no path attributes are
available e.g. a packet with only withdraws we need to set (and write) the
bgp path attribute field to zero. With this change we are able to send
valid updates to our neighbors with one exception: the nexthop field which
needs to be changed for ebgp neighbors.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.51 2004/01/10 16:20:29 claudio Exp $ */
d637 1
a637 1
	u_int16_t	 	 len, wd_len, wpos;
@


1.51
log
@RDE update generation. First we queue all updates and withdraws on a per
peer basis. A queue runner will dequeue and package those messages to valid
bgp UPDATE messages and send them to the SE.
Not yet done is per peer type attribute handling (like aspath prepends and
nexthop modifications) and the queue runner could be a tad smarter. All in
all this gives us a good starting point for the missing parts.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.50 2004/01/07 12:38:36 claudio Exp $ */
d621 3
d626 6
d646 2
a647 2
			wpos = 2;
			r = up_dump_prefix(queue_buf + wpos, len - wpos,
d650 1
d660 5
a664 2
			if (wpos == 2)
				/* no packet to send */
@


1.50
log
@Modified version of hennings last patch. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.49 2004/01/07 01:58:56 henning Exp $ */
d45 2
a46 1
int		 rde_update_get_attr(u_char *, u_int16_t, struct attr_flags *);
d51 1
d171 1
d370 2
a371 1
		if ((pos = rde_update_get_attr(p, attrpath_len, &attrs)) < 0) {
d443 1
d447 2
a448 1
rde_update_get_attr(u_char *p, u_int16_t len, struct attr_flags *a)
a452 1
	u_int16_t	 tmp16;
d510 5
a518 4
		if (attr_len > 0)
			return (-1);
		a->aggr_atm = 1;
		break;
a519 6
		if (attr_len != 6)
			return (-1);
		UPD_READ(&tmp16, p, plen, 2);
		a->aggr_as = ntohs(tmp16);
		UPD_READ(&a->aggr_ip, p, plen, 4);	/*network byte order */
		break;
d521 1
a521 1
		/* ignore for now */
d621 43
d734 1
d778 1
d794 1
@


1.49
log
@don't ever send kroute change (that includes add) requests to the parent
where the nexthop is not in state NEXTHOP_REACH.
previously routes in state NEXTHOP_LOOKUP, i. e. not yet verified, were
send to the parent process causing unnecessary and of course failing route
add attempts, cluttering logs, etc. nexthops in state NEXTHOP_UNREACH were
handled correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.48 2004/01/07 00:01:16 claudio Exp $ */
d581 1
a581 1
	    old->aspath->nexthop->state == NEXTHOP_UNREACH) &&
d583 1
a583 1
	    new->aspath->nexthop->state == NEXTHOP_UNREACH))
d587 1
a587 1
	    new->aspath->nexthop->state == NEXTHOP_UNREACH) {
a593 2
		if (new->aspath->nexthop->state != NEXTHOP_REACH)
			return;
@


1.48
log
@Make sure that kroute updates for the FIB are only sent if there is a
change. Until now rde_send_kroute tried to send a IMSG_KROUTE_DELETE if old
and new prefix where ineligible. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.47 2004/01/06 03:43:50 henning Exp $ */
d594 2
@


1.47
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.46 2004/01/05 22:57:58 claudio Exp $ */
d580 4
a583 1
	if (old == NULL && new == NULL)
@


1.46
log
@Big overhaul of the mrt code.
Dumping of incomming bgp messages is now possible and dumping the (not yet)
filtered updates works too. Per neighbor dumps are still missing.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.45 2004/01/04 20:47:34 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.45
log
@split the dispatch_imsg function into twom one per pipe.
with the amount of different msgs the RDE is handling the checks wether
a msg was received on the "wrong" pipe make things less clear.
also remove some outdated comments
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.44 2004/01/04 17:19:41 henning Exp $ */
d64 3
d217 1
a217 1
	struct mrt		 mrtdump;
d276 13
a288 4
			mrtdump.id = imsg.hdr.peerid;
			mrtdump.msgbuf = &ibuf_main.w;
			pt_dump(mrt_dump_upcall, &mrtdump);
			/* FALLTHROUGH */
d290 1
d292 4
a295 3
			if (imsg_compose(&ibuf_main, IMSG_MRT_END,
			    imsg.hdr.peerid, NULL, 0) == -1)
				fatalx("imsg_compose error");
d324 5
@


1.44
log
@in the SE, keep the remote router-id in network byte order, just like
every other IP address
in the RDE, transform in into host byte order upon receival
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.43 2004/01/03 20:37:34 henning Exp $ */
d39 2
a40 1
void		 rde_dispatch_imsg(struct imsgbuf *, int);
a146 6
		if (nfds > 0 && pfd[PFD_PIPE_MAIN].revents & POLLIN)
			rde_dispatch_imsg(&ibuf_main, PFD_PIPE_MAIN);

		if (nfds > 0 && pfd[PFD_PIPE_SESSION].revents & POLLIN)
			rde_dispatch_imsg(&ibuf_se, PFD_PIPE_SESSION);

d148 1
a148 2
		    ibuf_main.w.queued) {
			nfds--;
d151 4
d158 1
a158 2
		    ibuf_se.w.queued) {
			nfds--;
d161 4
d173 39
a211 1
rde_dispatch_imsg(struct imsgbuf *ibuf, int idx)
a216 1
	u_int32_t		 rid;
d220 1
a220 2
		fatal("rde_dispatch_imsg: imsg_read error");

d222 1
a222 1
		fatal("rde_dispatch_imsg: pipe closed");
d226 1
a226 2
			fatal("rde_dispatch_imsg: imsg_read error");

a231 2
			if (idx != PFD_PIPE_MAIN)
				fatalx("reconf request not from parent");
a237 2
			if (idx != PFD_PIPE_MAIN)
				fatalx("reconf request not from parent");
d239 1
a239 2
			p = peer_get(pconf->id); /* will always fail atm */
			if (p == NULL)
a246 2
			if (idx != PFD_PIPE_MAIN)
				fatalx("reconf request not from parent");
d250 1
a250 2
			    p != LIST_END(&peerlist);
			    p = np) {
a268 18
		case IMSG_UPDATE:
			if (idx != PFD_PIPE_SESSION)
				fatalx("update msg not from session engine");
			rde_update_dispatch(&imsg);
			break;
		case IMSG_SESSION_UP:
			if (idx != PFD_PIPE_SESSION)
				fatalx("session msg not from session engine");
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(rid))
				fatalx("incorrect size of session request");
			memcpy(&rid, imsg.data, sizeof(rid));
			peer_up(imsg.hdr.peerid, rid);
			break;
		case IMSG_SESSION_DOWN:
			if (idx != PFD_PIPE_SESSION)
				fatalx("session msg not from session engine");
			peer_down(imsg.hdr.peerid);
			break;
a269 2
			if (idx != PFD_PIPE_MAIN)
				fatalx("nexthop response not from parent");
a272 2
			if (idx != PFD_PIPE_MAIN)
				fatalx("mrt request not from parent");
a277 2
			if (idx != PFD_PIPE_MAIN)
				fatalx("mrt request not from parent");
d290 1
a290 5
/*
 * rde_update_dispatch() -- handle routing updates comming from the session
 * engine.
 */

@


1.43
log
@move some session specific stuff to session.h and make the few files
that need it include that
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.42 2004/01/03 20:22:07 henning Exp $ */
d710 1
a710 1
	peer->remote_bgpid = rid;
@


1.42
log
@decouple the peer list from bgpd_config.
so many parts of bgpd are not at all interested in the session specific peer
structs... allows for some further cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.41 2004/01/03 14:06:35 henning Exp $ */
d33 1
d78 1
a78 1
rde_main(struct bgpd_config *config, struct peer *peers, int pipe_m2r[2],
d121 1
a121 1
	peer_init(peers, peerhashsize);
d611 1
a611 1
peer_init(struct peer *peers, u_long hashsize)
d628 1
a628 1
	for (p = peers; p != NULL; p = next) {
d634 1
a634 1
	peers = NULL;
@


1.41
log
@change imsg_read semantics so that the number of bytes read is returned.
that means that the callers can (and must) coope with closed connections
themselves, what is exactly the desired behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.40 2004/01/01 23:09:09 henning Exp $ */
d49 1
a49 1
void		 peer_init(struct bgpd_config *, u_long);
d77 2
a78 1
rde_main(struct bgpd_config *config, int pipe_m2r[2], int pipe_s2r[2])
d120 1
a120 1
	peer_init(config, peerhashsize);
a200 1
			nconf->peers = NULL;
d610 1
a610 1
peer_init(struct bgpd_config *bgpconf, u_long hashsize)
d627 1
a627 1
	for (p = bgpconf->peers; p != NULL; p = next) {
d633 1
a633 1
	bgpconf->peers = NULL;
@


1.40
log
@now that imsg_get uses bigger buffers, one read call can put more than one
imsg into the buffer. since imsg_get by definition only returns one imsg we
missed the next imsg(s) until the next poll event on the socket in question,
building up a queue on that socket. didn't show up as a problem yet...
factor out imsg_read, which reads into the buffer. imsg_get now entirely
operates on the buffers and does not read(2) itself.
make all callers cope by calling imsg_read on poll events and calling
imsg_get in a loop until all imsgs are processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.39 2003/12/27 00:53:51 henning Exp $ */
d179 1
a179 1
	if (imsg_read(ibuf) == -1)
d181 3
@


1.39
log
@implement "no fib-update" much cooler
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.38 2003/12/27 00:18:11 jakob Exp $ */
d179 9
a187 2
	if ((n = imsg_get(ibuf, &imsg)) == -1)
		fatal("imsg_get error");
a188 1
	if (n > 0) {
@


1.38
log
@do not print NULL nexthop (e.g. from a withdrawn route)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.37 2003/12/26 23:50:35 jakob Exp $ */
a549 3

	if (conf->flags & BGPD_FLAG_NO_FIB_UPDATE)
		return;
@


1.37
log
@print nexthop when logging. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.36 2003/12/26 22:41:01 henning Exp $ */
d535 1
a535 1
	    nexthop);
@


1.36
log
@"when you try to be very smart, something breaks horribly"
zap aspath->state, which was a copy of aspath->nexthop->state, for a tiny
little bit faster access. tho, it happened what had to happen, they ran
out of sync.
it's just not worth it.

also add a missinf LIST_INIT.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.35 2003/12/26 21:33:14 henning Exp $ */
d24 1
d518 1
d527 6
a532 1
	logit(LOG_DEBUG, "neighbor %s (AS%u) %s %s/%u",
d534 2
a535 1
	    inet_ntoa(*prefix), prefixlen);
d538 1
@


1.35
log
@when asking the kernel to add a route, send him the true nexthop and not
the exit nexthop as the latter will only work if the two happen to be equal
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.34 2003/12/26 20:52:14 jakob Exp $ */
d548 2
a549 1
	if (new == NULL || new->aspath->state == NEXTHOP_UNREACH) {
d552 1
d556 1
a560 1
	kr.nexthop = p->aspath->nexthop->true_nexthop.s_addr;
@


1.34
log
@add option 'log updates' to log updates. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.33 2003/12/26 18:33:11 henning Exp $ */
d558 1
a558 1
	kr.nexthop = p->aspath->flags.nexthop.s_addr;
@


1.33
log
@let imsg_get and imsg_compose not fatal() but return errors upstream.
make the callers cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.32 2003/12/26 18:07:33 henning Exp $ */
d44 3
d318 1
d353 1
d509 21
@


1.32
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.31 2003/12/25 23:41:23 claudio Exp $ */
d173 1
d175 4
a178 1
	if (imsg_get(ibuf, &imsg) > 0) {
d261 3
a263 2
			imsg_compose(&ibuf_main, IMSG_MRT_END,
			    imsg.hdr.peerid, NULL, 0);
d501 3
a503 2
	imsg_compose(&ibuf_se, IMSG_UPDATE_ERR, peerid,
	    &errcode, sizeof(errcode));
d534 2
a535 1
	imsg_compose(&ibuf_main, type, 0, &kr, sizeof(kr));
d544 2
d547 1
a547 2
		imsg_compose(&ibuf_main, IMSG_NEXTHOP_ADD, 0,
		    &next, sizeof(next));
d549 4
a552 2
		imsg_compose(&ibuf_main, IMSG_NEXTHOP_REMOVE, 0,
		    &next, sizeof(next));
@


1.31
log
@Turn the nexthop verification on. At least in the RDE.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.30 2003/12/25 23:22:13 claudio Exp $ */
d82 1
a82 1
		fatal("cannot fork", errno);
d92 1
a92 1
		fatal("getpwnam", errno);
d95 1
a95 1
		fatal("chroot failed", errno);
d104 1
a104 1
		fatal("can't drop privileges", errno);
d138 1
a138 1
				fatal("poll error", errno);
d150 1
a150 1
				fatal("pipe write error", errno);
d157 1
a157 1
				fatal("pipe write error", errno);
d178 1
a178 1
				fatal("reconf request not from parent", 0);
d181 1
a181 1
				fatal(NULL, errno);
d187 1
a187 1
				fatal("reconf request not from parent", 0);
d199 1
a199 1
				fatal("reconf request not from parent", 0);
d201 1
a201 1
				fatal("got IMSG_RECONF_DONE but no config", 0);
d225 1
a225 1
				fatal("update msg not from session engine", 0);
d230 1
a230 1
				fatal("session msg not from session engine", 0);
d232 1
a232 1
				fatal("incorrect size of session request", 0);
d238 1
a238 1
				fatal("session msg not from session engine", 0);
d243 1
a243 1
				fatal("nexthop response not from parent", 0);
d248 1
a248 1
				fatal("mrt request not from parent", 0);
d255 1
a255 1
				fatal("mrt request not from parent", 0);
d566 1
a566 1
		fatal("peer_init", errno);
d609 1
a609 1
		fatal("peer_add", errno);
@


1.30
log
@RDE part of the nexthop verification puzzle.
The RDE just tracks the nexthop IPs and reacts on nexthop messages
from the parent.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.29 2003/12/25 02:24:26 henning Exp $ */
d244 1
a265 7

/*
 * rde_request_dispatch() -- handle all messages comming form the parent.
 * This are reconfiguration request and inquiries.
 * XXX most is done in rde_dispatch_imsg so probably drop this function.
 */

@


1.29
log
@kill IMSG_KROUTE_ADD as well. just send KROUTE_CHANGE requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.28 2003/12/24 23:48:06 henning Exp $ */
d241 4
d535 14
@


1.28
log
@syscalls return -1 on err so test for == -1 instead of the < 0 found in very
few places, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.27 2003/12/24 20:09:57 henning Exp $ */
d518 1
a518 4
	if (old == NULL) {
		type = IMSG_KROUTE_ADD;
		p = new;
	} else if (new == NULL || new->aspath->state == NEXTHOP_UNREACH) {
@


1.27
log
@now that the main process can cleanup without RDE's help, we do not need the
somewhat fragile IMSG_SHUTDOWN_* stuff any more. speeds shutdown up
enourmously.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.26 2003/12/24 19:59:24 henning Exp $ */
d94 1
a94 1
	if (chroot(pw->pw_dir) < 0)
@


1.26
log
@now that we keep track of the routes we added to the kernel we can remove
them easily on shutdown without the RDE's help
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.20 2003/12/23 18:28:05 henning Exp $ */
a253 4
			break;
		case IMSG_SHUTDOWN_REQUEST:
			imsg_compose(&ibuf_main, IMSG_SHUTDOWN_DONE, 0,
			    NULL, 0);
@


1.25
log
@add option to not touch the kernel routing table
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.24 2003/12/24 13:28:02 henning Exp $ */
a44 2
void		 rde_dump_kroute(struct pt_entry *pt, void *ptr);

a255 1
			pt_dump(rde_dump_kroute, NULL);
a537 8
}

void
rde_dump_kroute(struct pt_entry *pt, void *ptr)
{
	if (pt->active == NULL)
		return;
	rde_send_kroute(NULL, pt->active);
@


1.24
log
@handle write() returning 0 correctly, adjust the msgbuf API appropriately,
and make all callers cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.23 2003/12/23 19:14:49 deraadt Exp $ */
d518 3
@


1.23
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.22 2003/12/23 19:13:27 henning Exp $ */
d151 1
a151 1
			if ((n = msgbuf_write(&ibuf_main.w)) == -1)
d158 1
a158 2
			if ((n = msgbuf_write(&ibuf_se.w)) ==
			    -1)
@


1.22
log
@kill a chunk of debug code that is not usefull any more

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.21 2003/12/23 18:52:46 claudio Exp $ */
d135 1
a135 1
		if (ibuf_se.w.queued  > 0)
d533 1
a533 1
	
@


1.21
log
@In case of exit the RDE need to tell the parent to remove all still active
prefixes from the kernel routing table. This is done with a simple table
walk. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.20 2003/12/23 18:28:05 henning Exp $ */
a350 6
		}
		/* XXX only for debugging. Used as debugger hook. */
		if (prefixlen < 8 || prefixlen > 24) {
			logit(LOG_DEBUG, "XXX XXX %s/%d\t[%d] {%d}\n",
			    inet_ntoa(prefix), prefixlen, nlri_len,
			    imsg->hdr.len - IMSG_HEADER_SIZE);
@


1.20
log
@send shutdown requests to the child processes and wait for a ackmessage from
them when shutting down.
the rde needs the main process to clean up the routing table on exit so the
parent process needs to be in service until the RDE is done.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.19 2003/12/23 15:59:02 claudio Exp $ */
d45 2
d259 1
d545 8
@


1.19
log
@Send updates to the main process so they can be added to the kernel
routing table. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.18 2003/12/21 23:28:39 henning Exp $ */
d255 4
@


1.18
log
@rename get_imsg() to imsg_get(); that's more consistent
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.17 2003/12/21 23:26:38 henning Exp $ */
d509 30
@


1.17
log
@wrap read & write buffers for imsgs into a struct.
finally gives us read buffers per pipe instead of per process, eleminating
a possible race.
also gets us a real imsg_init() that does all the boring init work
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.16 2003/12/21 22:16:53 henning Exp $ */
d175 1
a175 1
	if (get_imsg(ibuf, &imsg) > 0) {
@


1.16
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.15 2003/12/20 21:43:45 claudio Exp $ */
d37 1
a37 1
void		 rde_dispatch_imsg(int, int);
d55 2
a56 2
struct msgbuf		 msgbuf_se;
struct msgbuf		 msgbuf_main;
d119 2
a120 5
	msgbuf_init(&msgbuf_se);
	msgbuf_se.sock = pipe_s2r[1];
	msgbuf_init(&msgbuf_main);
	msgbuf_main.sock = pipe_m2r[1];
	init_imsg_buf();
d126 1
a126 1
		pfd[PFD_PIPE_MAIN].fd = msgbuf_main.sock;
d128 1
a128 1
		if (msgbuf_main.queued > 0)
d131 1
a131 1
		pfd[PFD_PIPE_SESSION].fd = msgbuf_se.sock;
d133 1
a133 1
		if (msgbuf_se.queued  > 0)
d141 1
a141 1
			rde_dispatch_imsg(pfd[PFD_PIPE_MAIN].fd, PFD_PIPE_MAIN);
d144 1
a144 2
			rde_dispatch_imsg(pfd[PFD_PIPE_SESSION].fd,
			    PFD_PIPE_SESSION);
d147 1
a147 1
		    msgbuf_main.queued) {
d149 1
a149 1
			if ((n = msgbuf_write(&msgbuf_main)) == -1)
d154 1
a154 1
		    msgbuf_se.queued) {
d156 1
a156 1
			if ((n = msgbuf_write(&msgbuf_se)) ==
d167 1
a167 1
rde_dispatch_imsg(int fd, int idx)
d175 1
a175 1
	if (get_imsg(fd, &imsg) > 0) {
d246 1
a246 1
			mrtdump.msgbuf = &msgbuf_main;
d253 1
a253 1
			imsg_compose(&msgbuf_main, IMSG_MRT_END,
d505 1
a505 1
	imsg_compose(&msgbuf_se, IMSG_UPDATE_ERR, peerid,
@


1.15
log
@knf. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.14 2003/12/20 21:19:40 claudio Exp $ */
a53 3
int			 se_queued_writes = 0;
int			 se_sock;
int			 main_queued_writes = 0;
d55 2
d119 4
a123 1
	se_sock = pipe_s2r[1];
d129 1
a129 1
		pfd[PFD_PIPE_MAIN].fd = pipe_m2r[1];
d131 1
a131 1
		if (main_queued_writes > 0)
d134 1
a134 1
		pfd[PFD_PIPE_SESSION].fd = pipe_s2r[1];
d136 1
a136 1
		if (se_queued_writes > 0)
d143 4
a146 5
		if (nfds > 0 && pfd[PFD_PIPE_MAIN].revents & POLLIN) {
			rde_dispatch_imsg(pfd[PFD_PIPE_MAIN].fd,
			    PFD_PIPE_MAIN);
		}
		if (nfds > 0 && pfd[PFD_PIPE_SESSION].revents & POLLIN) {
d149 1
a149 1
		}
d151 1
a151 1
		    main_queued_writes) {
d153 1
a153 1
			if ((n = buf_sock_write(pfd[PFD_PIPE_MAIN].fd)) == -1)
a154 1
			main_queued_writes -= n;
d156 1
d158 1
a158 1
		    se_queued_writes) {
d160 1
a160 1
			if ((n = buf_sock_write(pfd[PFD_PIPE_SESSION].fd)) ==
a162 1
			se_queued_writes -= n;
d174 1
d238 1
a238 1
			rid = *(u_int32_t *)imsg.data;
d249 3
a251 2
			pt_dump(mrt_dump_upcall, fd, &main_queued_writes,
			    &imsg.hdr.peerid);
d257 1
a257 1
			main_queued_writes += imsg_compose(fd, IMSG_MRT_END,
d509 1
a509 1
	se_queued_writes += imsg_compose(se_sock, IMSG_UPDATE_ERR, peerid,
@


1.14
log
@more cast cleanup imsg_compose takes now a void * argument. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.13 2003/12/20 20:53:30 henning Exp $ */
d255 2
a256 2
			main_queued_writes += imsg_compose(fd,
			    IMSG_MRT_END, imsg.hdr.peerid, NULL, 0);
d507 2
a508 2
	se_queued_writes += imsg_compose(se_sock, IMSG_UPDATE_ERR,
	    peerid, &errcode, sizeof(errcode));
@


1.13
log
@few missing break; in default: cases in switch; one noticed by tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.12 2003/12/20 18:32:22 henning Exp $ */
d192 1
a192 1
			pconf = (struct peer_config *)imsg.data;
d508 1
a508 1
	    peerid, (u_char *)&errcode, sizeof(errcode));
@


1.12
log
@keep track which process we are so fatal() can log in which proc the
condition happened. fatal()s from subsystems used by all 3 processes like
the imsg subsystem were hard to track down without knowing in which process
the condition happened.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.11 2003/12/20 15:09:07 henning Exp $ */
d259 1
d494 1
@


1.11
log
@formulate two comparisons sligthly different to prevent the left side from
becoming negative. this was logically impossible already but this way gcc
has the chance to notice that as well.
together with the last commit this makes bgod -Wsign-compare clean
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.10 2003/12/20 14:36:46 henning Exp $ */
d98 1
d100 1
@


1.10
log
@poll returns plain int...
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.9 2003/12/19 19:24:08 deraadt Exp $ */
d299 1
a299 1
	if (imsg->hdr.len - IMSG_HEADER_SIZE < 2 + withdrawn_len + 2) {
d318 2
a319 2
	if (imsg->hdr.len - IMSG_HEADER_SIZE <
	    2 + withdrawn_len + 2 + attrpath_len) {
@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.8 2003/12/19 16:46:46 claudio Exp $ */
d79 1
a79 2
	size_t		 nfds;
	int		 n;
@


1.8
log
@Rework of the RDE config merge. This fixes problems with peers that
where newer up. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.7 2003/12/19 11:19:02 henning Exp $ */
d526 2
a527 1
	for (hs = 1; hs < hashsize; hs <<= 1) ;
@


1.7
log
@fix getpwnam use; noticed by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.6 2003/12/19 01:15:47 deraadt Exp $ */
d174 1
a174 1
	struct rde_peer	*p;
a175 1
	int			 reconf;
d193 1
a193 1
			if (p == NULL) {
d195 1
a195 2
				reconf = RECONF_REINIT;
			} else {
d197 2
a198 6
				sizeof(struct peer_config));
				reconf = RECONF_KEEP;
			}
			p->conf.reconf_action = reconf;
			if (pconf->reconf_action > reconf)
				p->conf.reconf_action = pconf->reconf_action;
d205 10
a214 11
			/* Just remove deleted peers, new peers need no action
			 * and merged peers neither. If the SE needs to drop
			 * the current session and reopen a new one we get a
			 * DOWN/UP request.  We tag the deleted peers and
			 * remove them in peer_down.
			 */
			LIST_FOREACH(p, &peerlist, peer_l)
				if (p->conf.reconf_action == RECONF_NONE ||
				    p->conf.reconf_action == RECONF_DELETE)
					p->conf.reconf_action = RECONF_DELETE;
				else
d216 5
d591 10
a600 2
	ENSURE(peer_get(peer->conf.id) != NULL);
	ENSURE(LIST_EMPTY(&peer->path_h));
d602 2
a603 2
	LIST_REMOVE(peer, hash_l);
	LIST_REMOVE(peer, peer_l);
d605 2
a606 1
	free(peer);
@


1.6
log
@knf & 64-bit cleanup; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.5 2003/12/19 01:13:34 henning Exp $ */
a81 8
	conf = config;

	if ((pw = calloc(1, sizeof(struct passwd))) == NULL)
		fatal(NULL, errno);

	if ((pw = getpwnam(BGPD_USER)) == NULL)
		fatal("getpwnam", errno);

d91 5
d106 2
@


1.5
log
@for(p = something; p != NULL; p = p->next) is not going to fly if there is
a free(p) inside that for loop...
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.4 2003/12/18 22:22:22 claudio Exp $ */
d175 1
a175 1
	struct rde_peer 	*p;
d213 1
a213 1
 			 * and merged peers neither. If the SE needs to drop
d251 1
a251 1
			    (void *)imsg.hdr.peerid);
d587 1
a587 1
	
d596 1
a596 1
	
d599 1
a599 1
	
@


1.4
log
@First step for configuration merges in the RDE. Currently this will not
work correctly because the peer id changes on config reload. The code in
the RDE per se should be OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.3 2003/12/17 19:26:26 henning Exp $ */
d526 1
a526 1
	struct peer	*p;
d540 2
a541 1
	for (p = bgpconf->peers; p != NULL; p = p->next) {
@


1.3
log
@send reconf requests to the RDE as well and handle them there; syncing peer
data with RIB missing
use same message in RDE and SE for consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.2 2003/12/17 18:11:31 henning Exp $ */
d46 2
a47 1
void		 peer_add(u_int32_t, struct peer_config *);
d57 1
d175 1
a175 1
	struct rde_peer		*p;
d196 1
a196 4
				if ((p = calloc(1, sizeof(struct rde_peer))) ==
				    NULL)
					fatal("new peer", errno);
				p->state = PEER_NONE;
d198 3
a200 2
				/* XXXC peer_add */
			} else
d202 1
a202 2

			memcpy(&p->conf, pconf, sizeof(struct peer_config));
d212 13
a224 1
			/* XXXC merge in as needed */
d226 1
a514 2
LIST_HEAD(rde_peer_head, rde_peer);

d536 1
d541 1
d543 1
d545 1
d557 1
a557 1
	LIST_FOREACH(peer, head, peer_l) {
d564 1
a564 1
void
d572 1
a572 1
	peer = calloc(1, sizeof(peer));
d577 3
a579 1
	memcpy(&peer->conf, p_conf, sizeof(*p_conf));
d584 16
a599 1
	LIST_INSERT_HEAD(head, peer, peer_l);
d609 1
a609 1
		logit(LOG_CRIT, "peer_up: AYII, unknown peer!");
d624 1
a624 1
		logit(LOG_CRIT, "peer_down: AYII, unknown peer!");
d638 3
@


1.2
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d52 1
a52 1
struct bgpd_config	*conf;
d171 5
a175 2
	struct imsg	imsg;
	u_int32_t	rid;
d180 8
d189 19
d211 5
a215 2
			logit(LOG_DEBUG, "RDE: got reconf request");
			/* rde_request_dispatch() */
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d91 5
a95 7

        case 0:
                break;

        default:
                return (pid);
        }
d99 1
a99 1
	chdir ("/");
d165 1
a165 1
	_exit (0);
@

