head	1.5;
access;
symbols
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.09.19.08.58.57;	author yasuoka;	state dead;
branches;
next	1.4;

1.4
date	2012.05.08.13.15.11;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove files that became unused by new configuration syntax.
@
text
@/*	$OpenBSD: config_helper.c,v 1.4 2012/05/08 13:15:11 yasuoka Exp $ */
/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/* $Id: config_helper.c,v 1.4 2012/05/08 13:15:11 yasuoka Exp $ */
#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "properties.h"
#include "config_helper.h"
#include "debugmacro.h"

#define	KEYBUFSZ	512

/**
 * This function concatenates given prefix and the give suffix for making
 * configuration key (("prefix", "suffix") => "prefix.suffix").  The string
 * returned by this function resides in a static memory area.
 */
const char *
config_key_prefix(const char *prefix, const char *suffix)
{
	static char keybuf[KEYBUFSZ];

	strlcpy(keybuf, prefix, sizeof(keybuf));
	strlcat(keybuf, ".", sizeof(keybuf));
	strlcat(keybuf, suffix, sizeof(keybuf));

	return keybuf;
}

/**
 * Retrieve the configuration value as a 'string' that is specified by
 * given configuration key.
 * @@param   _this   The pointer to {@@link ::properties}
 * @@param   confKey configuration key name.
 * @@return pointer to the configuration value.  If no configuration value
 * exists then it returns NULL.
 */
const char *
config_str(struct properties *_this, const char *confKey)
{
	ASSERT(_this != NULL)

	return properties_get(_this, confKey);
}

/**
 * Retrieve the configuration value as a 'int' that is specified by
 * given configuration key.
 * @@param   _this   The pointer to {@@link ::properties}
 * @@param   confKey configuration key name.
 * @@param   defValue	The default value.  This function will return this
 * value in case no configuration exists
 */
int
config_int(struct properties *_this, const char *confKey, int defValue)
{
	int rval, x;
	const char *val;

	val = config_str(_this, confKey);

	if (val == NULL)
		return defValue;

	x = sscanf(val, "%d", &rval);

	if (x != 1)
		return defValue;

	return rval;
}

/**
 * Checks whether the configuration value equals given string.
 * @@param   _this   The pointer to {@@link ::properties}
 * @@param   confKey configuration key name.
 * @@param   defValue	The default value.  This function will return this
 * value in case no configuration exists
 * @@return  return 1 if given string matches the configuration value,
 * otherwise return 0.
 */
int
config_str_equal(struct properties *_this, const char *confKey,
    const char *str, int defValue)
{
	const char *val;

	val = config_str(_this, confKey);

	if (val == NULL)
		return defValue;

	return (strcmp(val, str) == 0)? 1 : 0;
}

/**
 * Checks whether the configuration value equals given string ignoring
 * case.
 * @@param   _this   The pointer to {@@link ::properties}
 * @@param   confKey configuration key name.
 * @@param   defValue	The default value.  This function will return this
 * value in case no configuration exists
 * @@return  return 1 if given string equals the configuration value,
 * otherwise return 0.
 */
int
config_str_equali(struct properties *_this, const char *confKey,
    const char *str, int defValue)
{
	const char *val;

	val = config_str(_this, confKey);

	if (val == NULL)
		return defValue;

	return (strcasecmp(val, str) == 0)? 1 : 0;
}

/***********************************************************************
 * Following functions are to get configuration value by given
 * configuration key.  At first the function will try to get the value
 * by the key with the prefix, if it fails, then it will try to get the
 * value by the key without the prefix.
 *
 * For example, we have following configuration
 *
 *	pppoe.service_name: default_service
 *	PPPoE0.pppoe.service_name: my_service
 *
 * calling
 *
 *	config_prefixed_str(prop, "PPPoE0", "service_name")
 *
 * returns "my_service".  If
 *
 *	PPPoE0.pppoe.service_name: my_service
 *
 * does not exist, then it returns "default_service".
 *
 * Functions that have fixed prefix can be generated by
 * PREFIXED_CONFIG_FUNCTIONS macro that is defined in config_helper.h.
 */
const char  *
config_prefixed_str(struct properties *_this, const char *prefix, const char *confKey)
{
	char keybuf[KEYBUFSZ];
	const char *val;

	if (prefix != NULL) {
		snprintf(keybuf, sizeof(keybuf), "%s.%s", prefix, confKey);
		val = config_str(_this, keybuf);
		if (val != NULL)
			return val;
	}

	return config_str(_this, confKey);
}

int
config_prefixed_int(struct properties *_this, const char *prefix, const char *confKey, int defValue)
{
	char keybuf[KEYBUFSZ];
	const char *val;

	if (prefix != NULL) {
		snprintf(keybuf, sizeof(keybuf), "%s.%s", prefix, confKey);
		val = config_str(_this, keybuf);
		if (val != NULL)
			return config_int(_this, keybuf, defValue);
	}

	return config_int(_this, confKey, defValue);
}

int
config_prefixed_str_equal(struct properties *_this, const char *prefix, const char *confKey, const char *str,
    int defValue)
{
	char keybuf[KEYBUFSZ];
	const char *val;

	if (prefix != NULL) {
		snprintf(keybuf, sizeof(keybuf), "%s.%s", prefix, confKey);
		val = config_str(_this, keybuf);
		if (val != NULL)
			return config_str_equal(_this, keybuf, str,
			    defValue);
	}

	return config_str_equal(_this, confKey, str, defValue);
}

int
config_prefixed_str_equali(struct properties *_this, const char *prefix,
    const char *confKey, const char *str, int defValue)
{
	char keybuf[KEYBUFSZ];
	const char *val;

	ASSERT(_this != NULL);

	if (prefix != NULL) {
		snprintf(keybuf, sizeof(keybuf), "%s.%s", prefix, confKey);
		val = config_str(_this, keybuf);
		if (val != NULL)
			return config_str_equali(_this, keybuf, str,
			    defValue);
	}

	return config_str_equali(_this, confKey, str, defValue);
}

/***********************************************************************
 * Following functions are to get configuration value by given
 * configuration key.  At first the function will try to get the value
 * by the key with the prefix and given label, if it fail, then it will
 * try to get the value by the key without the label.
 *
 * For example, we have following configuration
 *
 *	ipcp.dns_primary: 192.168.0.1
 *	ipcp.ipcp0.dns_primary: 192.168.0.2
 *
 * calling
 *
 *  config_named_prefix_str(prop, "ipcp", "ipcp0", "dns_primary");
 *
 * will returns "192.168.0.2".  If
 *
 *	ipcp.ipcp0.dns_primary: 192.168.0.2
 *
 * was not exists, then it returns "default_service".
 *
 * Functions that has fixed prefix can be generated by
 * NAMED_PREFIXED_CONFIG_FUNCTIONS macro that is defined in
 * config_helper.h.
 ***********************************************************************/
const char  *
config_named_prefix_str(struct properties *_this, const char *prefix,
    const char *name, const char *confKey)
{
	char keybuf[KEYBUFSZ];
	const char *val;

	if (name != NULL && name[0] != '\0') {
		snprintf(keybuf, sizeof(keybuf), "%s.%s.%s", prefix, name,
		    confKey);
		val = config_str(_this, keybuf);
		if (val != NULL)
			return val;
	}

	snprintf(keybuf, sizeof(keybuf), "%s.%s", prefix, confKey);
	return config_str(_this, keybuf);
}

int
config_named_prefix_int(struct properties *_this, const char *prefix,
    const char *name, const char *confKey, int defValue)
{
	char keybuf[KEYBUFSZ];
	const char *val;

	if (name != NULL && name[0] != '\0') {
		snprintf(keybuf, sizeof(keybuf), "%s.%s.%s", prefix, name,
		    confKey);
		val = config_str(_this, keybuf);
		if (val != NULL)
			return config_int(_this, keybuf, defValue);
	}

	snprintf(keybuf, sizeof(keybuf), "%s.%s", prefix, confKey);
	return config_int(_this, keybuf, defValue);
}

int
config_named_prefix_str_equal(struct properties *_this, const char *prefix,
    const char *name, const char *confKey, const char *str, int defValue)
{
	const char *val;

	val = config_named_prefix_str(_this, prefix, name, confKey);
	if (val == NULL)
		return defValue;

	return (strcmp(val, str) == 0)? 1 : 0;
}

int
config_named_prefix_str_equali(struct properties *_this, const char *prefix,
    const char *name, const char *confKey, const char *str, int defValue)
{
	const char *val;

	val = config_named_prefix_str(_this, prefix, name, confKey);
	if (val == NULL)
		return defValue;

	return (strcasecmp(val, str) == 0)? 1 : 0;
}
@


1.4
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: config_helper.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $ */
d27 1
a27 1
/* $Id: config_helper.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $ */
@


1.3
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: config_helper.c,v 1.2 2010/07/01 03:38:17 yasuoka Exp $ */
d27 1
a27 1
/* $Id: config_helper.c,v 1.2 2010/07/01 03:38:17 yasuoka Exp $ */
@


1.2
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d27 1
a27 1
/* $Id: config_helper.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $ */
d166 1
a166 1
 * 
d186 1
a186 1
int         
d202 1
a202 1
int         
d220 1
a220 1
int         
d247 1
a247 1
 * 
d284 1
a284 1
int         
d303 1
a303 1
int         
d316 1
a316 1
int         
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d1 1
d27 1
a27 5
/* $Id: config_helper.c,v 1.2 2009/03/25 12:10:39 yasuoka Exp $ */
/**@@file コンフィグヘルパ。
 * <p>
 * しています。</p>
 */
d40 3
a42 3
 * コンフィグキーを作成するための文字列連結
 * (("prefix", "suffix") => "prefix.suffix") を、行います。内部で固定のバッファ
 * 領域を返します。
d57 6
a62 5
 * 設定を文字列で返します。
 *
 * @@param   _this   {@@link ::properties}へのポインタ。
 * @@param   confKey 設定ファイルの設定項目名
 * @@return  設定値。設定が存在しない場合には NULL が返ります。
d73 6
a78 5
 * 設定を int で返します。
 *
 * @@param   _this   	{@@link ::properties}へのポインタ。
 * @@param   confKey 	設定ファイルの設定項目名
 * @@param   defValue	設定が省略されている場合のデフォルトの値
a93 1
		/* 関数のインタフェースを変更して、エラーは区別すべきかも */
d100 7
a106 6
 * 設定があたえられた文字列と一致するかどうかを返します。
 *
 * @@param   _this   	{@@link ::properties}へのポインタ。
 * @@param   confKey 	設定ファイルの設定項目名
 * @@param   defValue	設定が省略されている場合のデフォルトの値
 * @@return  一致する場合には 1、一致しない場合には 0 が返ります。
d123 8
a130 7
 * 設定があたえられた文字列と一致するかどうかを返します。ASCII 文字の
 * 大文字小文字は無視します。
 *
 * @@param   _this   	{@@link ::properties}へのポインタ。
 * @@param   confKey 	設定ファイルの設定項目名
 * @@param   defValue	設定が省略されている場合のデフォルトの値
 * @@return  一致する場合には 1、一致しない場合には 0 が返ります。
d147 6
a152 2
 * 設定項目名に指定したプレフィックスをつけて設定を取得し、設定がなければ
 * プレフィックスなしの設定項目で設定を取得するための関数です。
d154 4
a157 4
 * たとえば
 * 
 * pppoe.service_name: default_service
 * PPPoE0.pppoe.service_name: my_service
d159 1
a159 3
 * という設定があった場合、
 *  config_prefixed_str(prop, "PPPoE0", "service_name")
 * を呼び出すと "my_service" が取得できます。設定に、
d161 1
a161 1
 * PPPoE0.pppoe.service_name: my_service
d163 1
a163 1
 * がない場合には、"default_service" が取得できます。
d165 5
a169 3
 * config_helper.h に定義されている PREFIXED_CONFIG_FUNCTIONS マクロを
 * 使って、プレフィックス部分の指定方法を固定して使うこともできます。
 ***********************************************************************/
d241 4
a244 2
 * 設定項目名に指定したプレフィックスと指定した名前をつけて設定を取得し、
 * 設定がなければプレフィックスに設定項目で設定を取得するための関数です。
d246 1
a246 1
 * たとえば
d248 4
a251 2
 * ipcp.dns_primary: 192.168.0.1
 * ipcp.ipcp0.dns_primary: 192.168.0.2
a252 1
 * という設定があった場合、
a253 1
 * を呼び出すと "192.168.0.2" が取得できます。設定に、
d255 3
a257 1
 * ipcp.ipcp0.dns_primary: 192.168.0.2
d259 1
a259 1
 * がない場合には、"192.168.0.1" が取得できます。
d261 3
a263 2
 * config_helper.h に定義されている NAMED_PREFIX_CONFIG_FUNCTIONS マクロ
 * を使って、プレフィックス部分の指定方法を固定して使うこともできます。
@

