head	1.5;
access;
symbols
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.09.19.08.58.57;	author yasuoka;	state dead;
branches;
next	1.4;

1.4
date	2012.05.08.13.15.11;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove files that became unused by new configuration syntax.
@
text
@/*	$OpenBSD: csvreader.c,v 1.4 2012/05/08 13:15:11 yasuoka Exp $ */
/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/* The original version is CSVReader.java */
/* @@file
 * Subroutines to read CSV(RFC4180)
 * <pre>
 *  csvreader *csv;
 *  const char **cols;
 *  char buf[1024];
 *
 *  csv = csvreader_create();
 *  while (fgets(buf, sizeof(buf), stdin) != NULL) {
 *	if (csvreader_parse(csv, buf) != CSVREADER_NO_ERROR) {
 *	    // error handling
 *	    break;
 *	}
 *	cols = csv_reader_get_column(csv)
 *	if (cols == NULL)
 *	    continue;
 *	// your code here.  col[0] is the first column.
 *   }
 *   if (csvreader_parse(csv, buf) == CSVREADER_NO_ERROR) {
 *	cols = csv_reader_get_column(csv)
 *	if (cols != NULL) {
 *	    // your code here.  col[0] is the first column.
 *	}
 *   } else {
 *	    // error handling
 *   }
 *   csvreader_destroy(csv);
 *</pre>
 */
/* $Id: csvreader.c,v 1.4 2012/05/08 13:15:11 yasuoka Exp $ */
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include "csvreader.h"

struct _csvreader {
	char 	*buffer;
	const char **cols;
	int	cap;
	int	pos;
	int	start_pos;
	int	col_cap;
	int	col_pos;
	int	state;
	int	column_start_with_quote:1;
};

#define CSV_BUFSIZ		256
#define CSV_COLSIZ		32

#define CSV_INIT		0
#define CSV_IN_DATA		1
#define CSV_WAIT_DELIM		2
#define CSV_HAS_DQUOTE		3
#define CSV_FLUSH_WAIT		4

#define DQUOTE		'"'
#define COMMA		','
#define	CR		'\r'
#define	LF		'\n'

static int   csvreader_buffer_append (csvreader *, const char *, int);
static int   csvreader_flush_column (csvreader *);
static CSVREADER_STATUS  csvreader_parse_flush0 (csvreader *, int);

/**
 * Make a cvsreader context and returns it. Return null if malloc() failed.
 */
csvreader *
csvreader_create(void)
{
	csvreader *_this;

	if ((_this = malloc(sizeof(csvreader))) == NULL)
		return NULL;
	memset(_this, 0, sizeof(*_this));
	_this->state = CSV_INIT;

	return _this;
}


/**
 * Free a cvsreader context.
 */
void
csvreader_destroy(csvreader *_this)
{
	if (_this->buffer != NULL)
		free(_this->buffer);
	if (_this->cols != NULL)
		free(_this->cols);
	free(_this);
}

/**
 * get the number of parsed columns.
 */
int
csvreader_get_number_of_column(csvreader *_this)
{
	if (_this->state != CSV_FLUSH_WAIT)
		return 0;
	return _this->col_pos;
}

/**
 * get a parsed column.
 */
const char **
csvreader_get_column(csvreader *_this)
{
	if (_this->state != CSV_FLUSH_WAIT)
		return NULL;

	_this->col_pos = 0;
	_this->pos = 0;
	_this->start_pos = 0;
	_this->state = CSV_INIT;

	return _this->cols;
}

/**
 * Reset a cvsreader context.
 */
void
csvreader_reset(csvreader *_this)
{
	_this->cap = 0;
	_this->pos = 0;
	_this->start_pos = 0;
	_this->col_cap = 0;
	_this->col_pos = 0;
	_this->state = 0;
	_this->column_start_with_quote = 0;
}

/**
 * Finish parsing of a column on the way.
 * <p>
 * Call this function when it's sure that there is no next line or the end
 * of the CSV.
 * It will return error when the parsing of the field isn't finished. </p>
 */
CSVREADER_STATUS
csvreader_parse_flush(csvreader *_this)
{
	return csvreader_parse_flush0(_this, 1);
}

/**
 * parse a line.
 *
 * @@param	a csvreader context
 * @@param	a line to parse
 */
CSVREADER_STATUS
csvreader_parse(csvreader *_this, const char *line)
{
	int off, lline, append;

	lline = strlen(line);

	if (_this->state == CSV_FLUSH_WAIT)
		return CSVREADER_HAS_PENDING_COLUMN;

	if (csvreader_buffer_append(_this, line, lline) != 0)
		return CSVREADER_OUT_OF_MEMORY;

	for (off = 0; off < lline; off++) {
		append = 1;
		switch (_this->state) {
		case CSV_INIT:
			_this->state = CSV_IN_DATA;
			if (line[off] == DQUOTE) {
				_this->column_start_with_quote = 1;
				break;
			}
			/* FALLTHROUGH */
		case CSV_IN_DATA:
			if (_this->column_start_with_quote != 0) {
				if (line[off] == DQUOTE)
					_this->state = CSV_HAS_DQUOTE;
				break;
			}
			if (line[off] == COMMA) {
				append = 0;
				csvreader_flush_column(_this);
			}
			if (_this->column_start_with_quote == 0 &&
			    (line[off] == CR || line[off] == LF))
				goto eol;
			break;
		case CSV_HAS_DQUOTE:
			if (line[off] == DQUOTE) {
				_this->state = CSV_IN_DATA;
				append = 0;
				break;
			}
                	_this->state = CSV_WAIT_DELIM;
			/* FALLTHROUGH */
		case CSV_WAIT_DELIM:
			if (line[off] == CR || line[off] == LF)
				goto eol;
			append = 0;
			if (line[off] != COMMA)
				return CSVREADER_PARSE_ERROR;
			csvreader_flush_column(_this);
			break;
		}
		if (append)
			_this->buffer[_this->pos++] = line[off];
	}
eol:

	return csvreader_parse_flush0(_this, 0);
}

static CSVREADER_STATUS
csvreader_parse_flush0(csvreader *_this, int is_final)
{
	if (_this->state == CSV_FLUSH_WAIT)
		return CSVREADER_NO_ERROR;
	switch (_this->state) {
	case CSV_IN_DATA:
		if (_this->column_start_with_quote != 0) {
			if (is_final)
				return CSVREADER_PARSE_ERROR;
			/* wait next line */
			return CSVREADER_NO_ERROR;
		}
		/* FALLTHROUGH */
	case CSV_INIT:
		if (is_final && _this->col_pos == 0)
			return CSVREADER_NO_ERROR;
		/* FALLTHROUGH */
        case CSV_HAS_DQUOTE:
        case CSV_WAIT_DELIM:
		csvreader_flush_column(_this);
		_this->state = CSV_FLUSH_WAIT;
		return CSVREADER_NO_ERROR;
	}
	return CSVREADER_PARSE_ERROR;
}

/**
 * Convert columns stored in char *[] to a CVS line string.
 *
 * @@param	cols	columns to be converted. NULL means the end of the
 * 			column.
 * @@param	ncols	number of columns
 * @@param	buffer	the output buffer to write a converted line.
 * @@param	lbuffer	the size of the output buffer.
 */
int
csvreader_toline(const char **cols, int ncols, char *buffer, int lbuffer)
{
	int i, j, off;

	off = 0;
#define	checksize()	if (off + 1 > lbuffer) { goto enobufs; }
	for (i = 0; i < ncols && cols[i] != NULL; i++) {
		if (i != 0) {
			checksize();
			buffer[off++] = ',';
		}
		for (j = 0; cols[i][j] != '\0'; j++) {
			if (j == 0) {
				checksize();
				buffer[off++] = '"';
			}
			if (cols[i][j] == '"') {
				checksize();
				buffer[off++] = '"';
			}
			checksize();
			buffer[off++] = cols[i][j];
		}
		checksize();
		buffer[off++] = '"';
	}
	checksize();
	buffer[off++] = '\0';

	return 0;
enobufs:
	return 1;
}

static int
csvreader_buffer_append(csvreader *_this, const char *buf, int lbuf)
{
	int ncap;
	char *nbuffer;

	if (_this->pos + lbuf > _this->cap) {
		ncap = _this->cap + lbuf;
		if ((ncap % CSV_BUFSIZ) != 0)
			ncap += CSV_BUFSIZ - (ncap % CSV_BUFSIZ);
		if ((nbuffer = realloc(_this->buffer, ncap)) == NULL)
			return 1;
		_this->cap = ncap;
		_this->buffer = nbuffer;
	}

	return 0;
}

static int
csvreader_flush_column(csvreader *_this)
{
	int ncap;
	const char **ncols;

	if (_this->col_pos + 1 >= _this->col_cap) {
		ncap = _this->col_cap + CSV_COLSIZ;
		if ((ncols = realloc(_this->cols, ncap * sizeof(char *)))
		    == NULL)
			return CSVREADER_OUT_OF_MEMORY;
		_this->col_cap = ncap;
		_this->cols = ncols;
	}

	if (_this->column_start_with_quote != 0) {
		 _this->start_pos++;
		_this->buffer[_this->pos - 1] = '\0';
	} else {
		_this->buffer[_this->pos++] = '\0';
	}

	_this->cols[_this->col_pos++] = _this->buffer + _this->start_pos;
	_this->cols[_this->col_pos] = NULL;
	_this->start_pos = _this->pos;
	_this->column_start_with_quote = 0;
	_this->state = CSV_INIT;

	return CSVREADER_NO_ERROR;
}
@


1.4
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: csvreader.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $ */
d57 1
a57 1
/* $Id: csvreader.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $ */
@


1.3
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: csvreader.c,v 1.2 2010/07/01 03:38:17 yasuoka Exp $ */
d57 1
a57 1
/* $Id: csvreader.c,v 1.2 2010/07/01 03:38:17 yasuoka Exp $ */
@


1.2
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d57 1
a57 1
/* $Id: csvreader.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $ */
d174 1
a174 1
CSVREADER_STATUS 
d205 1
a205 1
				_this->column_start_with_quote = 1; 
d248 1
a248 1
static CSVREADER_STATUS 
d363 1
a363 1
	_this->column_start_with_quote = 0; 
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d1 1
d27 1
a27 1
/* original version は CSVReader.java */
d29 1
a29 1
 * CSV(RFC4180) を読み込むための補助的な関数
d57 1
a57 1
/* $Id: csvreader.c 34825 2008-02-03 11:47:53Z yasuoka $ */
d86 1
a86 1
#define COLON		','
d95 1
a95 2
 * cvsreader コンテキストを作成して返却します。メモリ割り当てに失敗すると、
 * NULL が返ります。
d112 1
a112 1
 * cvsreader コンテキストを解放します。
d125 1
a125 1
 * パース済みのカラム配列の数を取得します。
d136 1
a136 1
 * パース済みのカラム配列(=行) を取得します。
d153 1
a153 1
 * cvsreader コンテキストをリセットします。
d168 1
a168 1
 * パース途中のカラムのパースを完了します。
d170 3
a172 3
 * CSVファイルの末尾など、続く行
 * が存在しない場合や、CSV としての行の区切りであることが確実な場合に呼び
 * だします。フィールドが終了していない場合などにはエラーが返ります。</p>
d181 1
a181 1
 * 行をパースします。
d183 2
a184 2
 * @@param	csvreader コンテキスト
 * @@param	パースする行。
d208 1
a208 1
			/* FALL THROUGH */
d215 1
a215 1
			if (line[off] == COLON) {
d230 1
a230 1
			/* FALL THROUGH */
d235 1
a235 1
			if (line[off] != COLON)
d261 1
a261 1
		/* FALL THROUGH */
d265 1
a265 1
		/* FALL THROUGH */
d276 7
a282 6
 * char ポインタの配列に格納された列を CSV の表現の行文字列に変換します。

 * @@param	cols	変換する列。NULL 要素は、列の終わりとみなします。
 * @@param	ncols	列の数。
 * @@param	buffer	変換後の行文字列を書き込むスペース
 * @@param	lbuffer	変換後の行文字列を書き込むスペースの大きさ。
@

