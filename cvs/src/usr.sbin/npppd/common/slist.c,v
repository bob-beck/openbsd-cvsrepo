head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.10
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.8
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.5.0.12
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.8
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.17.07.56.01;	author tb;	state Exp;
branches;
next	1.6;
commitid	DvSNtn3J92N3xjX7;

1.6
date	2015.12.05.18.43.36;	author mmcc;	state Exp;
branches;
next	1.5;
commitid	z4uV9iYMuGOvIKaj;

1.5
date	2013.04.20.23.32.32;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.18.03.13.04;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Replace arc4random() % i by arc4random_uniform(i) to avoid modulo bias.
Part of a diff by Matthew Martin, reviewed by deraadt@@ and me.

ok deraadt@@
@
text
@/*	$OpenBSD$ */
/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/**@@file
 * provide list accesses against any pointer
 */
/*
 *	void **list;
 *	list_size;	// allocated size for the list
 *	last_idx;	// The last index
 *	first_idx;	// The first index
 *
 * - first_idx == last_idx means empty.
 * - 0 <= (fist_idx and last_idx) <= (list_size - 1)
 * - Allocated size is (last_idx - first_idx) % list_size.
 *   To make the code for checking empty and full simple, we use only
 *   list_size-1 items instead of using the full size.
 * - XXX Wnen itr_curr is removed...
 */
#include <sys/types.h>

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "slist.h"

#define	GROW_SIZE	256
#define	PTR_SIZE	(sizeof(intptr_t))

#ifdef	SLIST_DEBUG
#include <stdio.h>
#define	SLIST_ASSERT(cond)			\
	if (!(cond)) {							\
		fprintf(stderr,						\
		    "\nAssertion failure("#cond") at (%s):%s:%d\n",	\
		    __func__, __FILE__, __LINE__);			\
	}
#else
#define	SLIST_ASSERT(cond)
#endif

/**
 * Returns 1 if a index is in the valid range, otherwise returns 0.
 */
#define	VALID_IDX(_list, _idx)					\
	  (((_list)->first_idx <= (_list)->last_idx)			\
	? (((_list)->first_idx <= (_idx) && (_idx) < (_list)->last_idx)? 1 : 0)\
	: (((_list)->first_idx <= (_idx) || (_idx) < (_list)->last_idx)? 1 : 0))

/** Convert an index into the internal index */
#define	REAL_IDX(_list, _idx)						\
	(((_list)->first_idx + (_idx)) % (_list)->list_size)

/** Convert a virtual index into the index */
#define	VIRT_IDX(_list, _idx)	(((_list)->first_idx <= (_idx))	\
	? (_idx) - (_list)->first_idx				\
	: (_list)->list_size - (_list)->first_idx + (_idx))

/** Decrement an index */
#define	DECR_IDX(_list, _memb)						\
	(_list)->_memb = ((_list)->list_size + --((_list)->_memb))	\
	    % (_list)->list_size
/** Increment an index */
#define	INCR_IDX(_list, _memb)						\
	(_list)->_memb = (++((_list)->_memb)) % (_list)->list_size

static int          slist_grow (slist *);
static int          slist_grow0 (slist *, int);
static __inline void  slist_swap0 (slist *, int, int);
static __inline void  slist_qsort0(slist *, int (*)(const void *, const void *), int, int);

#define	itr_is_valid(list)	((list)->itr_next >= 0)
#define	itr_invalidate(list)	((list)->itr_next = -1)

/** Initialize a slist */
void
slist_init(slist *list)
{
	memset(list, 0, sizeof(slist));
	itr_invalidate(list);
}

/**
 * Specify the size of a list. The size must be specified with the size you
 * want to use +1. Extra 1 entry is for internal use. The size doesn't shrink.
 */
int
slist_set_size(slist *list, int size)
{
	if (size > list->list_size)
		return slist_grow0(list, size - list->list_size);

	return 0;
}

/** Finish using. Free the buffers and reinit. */
void
slist_fini(slist *list)
{
	free(list->list);
	slist_init(list);
}

/** The length of the list */
int
slist_length(slist *list)
{
	return
	      (list->first_idx <= list->last_idx)
	    ? (list->last_idx - list->first_idx)
	    : (list->list_size - list->first_idx + list->last_idx);
}

/** Extend the size. Used if the list is full. */
static int
slist_grow0(slist *list, int grow_sz)
{
	int size_new;
	void **list_new = NULL;

 	/* just return if it is possible to add one item */
	if (slist_length(list) + 1 < list->list_size)
		/* "+ 1" to avoid the situation list_size == slist_length() */
		return 0;

	size_new = list->list_size + grow_sz;
	if ((list_new = realloc(list->list, PTR_SIZE * size_new))
	    == NULL)
		return -1;

	memset(&list_new[list->list_size], 0,
	    PTR_SIZE * (size_new - list->list_size));

	list->list = list_new;
	if (list->last_idx < list->first_idx && list->last_idx >= 0) {

		/*
		 * space is created at the right side when center has space,
		 * so move left side to right side
		 */
		if (list->last_idx <= grow_sz) {
			/*
			 * The right side has enough space, so move the left
			 * side to right side.
			 */
			memmove(&list->list[list->list_size],
			    &list->list[0], PTR_SIZE * list->last_idx);
			list->last_idx = list->list_size + list->last_idx;
		} else {
			/*
			 * Copy the left side to right side as long as we
			 * can
			 */
			memmove(&list->list[list->list_size],
			    &list->list[0], PTR_SIZE * grow_sz);
			/* Shift the remain to left */
			memmove(&list->list[0], &list->list[grow_sz],
			    PTR_SIZE *(list->last_idx - grow_sz));

			list->last_idx -= grow_sz;
		}
	}
	list->list_size = size_new;

	return 0;
}

static int
slist_grow(slist *list)
{
	return slist_grow0(list, GROW_SIZE);
}

/** Add an item to a list */
void *
slist_add(slist *list, void *item)
{
	if (slist_grow(list) != 0)
		return NULL;

	list->list[list->last_idx] = item;

	if (list->itr_next == -2) {
		/* the iterator points the last, update it. */
		list->itr_next = list->last_idx;
	}

	INCR_IDX(list, last_idx);

	return item;
}

#define slist_get0(list_, idx)	((list_)->list[REAL_IDX((list_), (idx))])

/** Add all items in add_items to a list. */
int
slist_add_all(slist *list, slist *add_items)
{
	int i, n;

	n = slist_length(add_items);
	for (i = 0; i < n; i++) {
		if (slist_add(list, slist_get0(add_items, i)) ==  NULL)
			return 1;
	}

	return 0;
}

/** Return "idx"th item. */
void *
slist_get(slist *list, int idx)
{
	SLIST_ASSERT(idx >= 0);
	SLIST_ASSERT(slist_length(list) > idx);

	if (idx < 0 || slist_length(list) <= idx)
		return NULL;

	return slist_get0(list, idx);
}

/** Store a value in "idx"th item */
int
slist_set(slist *list, int idx, void *item)
{
	SLIST_ASSERT(idx >= 0);
	SLIST_ASSERT(slist_length(list) > idx);

	if (idx < 0 || slist_length(list) <= idx)
		return -1;

	list->list[REAL_IDX(list, idx)] = item;

	return 0;
}

/** Remove the 1st entry and return it. */
void *
slist_remove_first(slist *list)
{
	void *oldVal;

	if (slist_length(list) <= 0)
		return NULL;

	oldVal = list->list[list->first_idx];

	if (itr_is_valid(list) && list->itr_next == list->first_idx)
		INCR_IDX(list, itr_next);

	if (!VALID_IDX(list, list->itr_next))
		itr_invalidate(list);

	INCR_IDX(list, first_idx);

	return oldVal;
}

/** Remove the last entry and return it */
void *
slist_remove_last(slist *list)
{
	if (slist_length(list) <= 0)
		return NULL;

	DECR_IDX(list, last_idx);
	if (!VALID_IDX(list, list->itr_next))
		itr_invalidate(list);

	return list->list[list->last_idx];
}

/** Remove all entries */
void
slist_remove_all(slist *list)
{
	void **list0 = list->list;

	slist_init(list);

	list->list = list0;
}

/* Swap items. This doesn't check boudary. */
static __inline void
slist_swap0(slist *list, int m, int n)
{
	void *m0;

	itr_invalidate(list);	/* Invalidate iterator */

	m0 = list->list[REAL_IDX(list, m)];
	list->list[REAL_IDX(list, m)] = list->list[REAL_IDX(list, n)];
	list->list[REAL_IDX(list, n)] = m0;
}

/** Swap between mth and nth */
void
slist_swap(slist *list, int m, int n)
{
	int len;

	len = slist_length(list);
	SLIST_ASSERT(m >= 0);
	SLIST_ASSERT(n >= 0);
	SLIST_ASSERT(len > m);
	SLIST_ASSERT(len > n);

	if (m < 0 || n < 0)
		return;
	if (m >= len || n >= len)
		return;

	slist_swap0(list, m, n);
}

/** Remove "idx"th item */
void *
slist_remove(slist *list, int idx)
{
	int first, last, idx0, reset_itr;
	void *oldVal;

	SLIST_ASSERT(idx >= 0);
	SLIST_ASSERT(slist_length(list) > idx);

	if (idx < 0 || slist_length(list) <= idx)
		return NULL;

	idx0 = REAL_IDX(list, idx);
	oldVal = list->list[idx0];
	reset_itr = 0;

	first = -1;
	last = -1;

	if (list->itr_next == idx0) {
		INCR_IDX(list, itr_next);
		if (!VALID_IDX(list, list->itr_next))
			list->itr_next = -2;	/* on the last item */
	}

	/* should we reduce the last side or the first side? */
	if (list->first_idx < list->last_idx) {
		/* take the smaller side */
		if (idx0 - list->first_idx < list->last_idx - idx0) {
			first = list->first_idx;
			INCR_IDX(list, first_idx);
		} else {
			last = list->last_idx;
			DECR_IDX(list, last_idx);
		}
	} else {
		/*
		 * 0 < last (unused) first < idx < size, so let's reduce the
		 * first.
		 */
		if (list->first_idx <= idx0) {
			first = list->first_idx;
			INCR_IDX(list, first_idx);
		} else {
			last = list->last_idx;
			DECR_IDX(list, last_idx);
		}
	}

	/* the last side */
	if (last != -1 && last != 0 && last != idx0) {

		/* move left the items that is from idx0 to the last */
		if (itr_is_valid(list) &&
		    idx0 <= list->itr_next && list->itr_next <= last) {
			DECR_IDX(list, itr_next);
			if (!VALID_IDX(list, list->itr_next))
				itr_invalidate(list);
		}

		memmove(&list->list[idx0], &list->list[idx0 + 1],
		    (PTR_SIZE) * (last - idx0));
	}
	/* the first side */
	if (first != -1 && first != idx0) {

		/* move right the items that is from first to the idx0 */
		if (itr_is_valid(list) &&
		    first <= list->itr_next && list->itr_next <= idx0) {
			INCR_IDX(list, itr_next);
			if (!VALID_IDX(list, list->itr_next))
				itr_invalidate(list);
		}

		memmove(&list->list[first + 1], &list->list[first],
		    (PTR_SIZE) * (idx0 - first));
	}
	if (list->first_idx == list->last_idx) {
		list->first_idx = 0;
		list->last_idx = 0;
	}

	return oldVal;
}

/**
 * Shuffle items.
 */
void
slist_shuffle(slist *list)
{
	int i, len;

	len = slist_length(list);
	for (i = len; i > 1; i--)
		slist_swap0(list, i - 1, (int)arc4random_uniform(i));
}

/** Init an iterator. Only one iterator exists.  */
void
slist_itr_first(slist *list)
{
	list->itr_next = list->first_idx;
	if (!VALID_IDX(list, list->itr_next))
		itr_invalidate(list);
}

/**
 * Return whether a iterator can go to the next item.
 * @@return Return 1 if the iterator can return the next item.
 *	Return 0 it reaches the end of the list or the list is modified
 *	destructively.
 */
int
slist_itr_has_next(slist *list)
{
	if (list->itr_next < 0)
		return 0;
	return VALID_IDX(list, list->itr_next);
}

/** Return the next item and iterate to the next */
void *
slist_itr_next(slist *list)
{
	void *rval;

	if (!itr_is_valid(list))
		return NULL;
	SLIST_ASSERT(VALID_IDX(list, list->itr_next));

	if (list->list == NULL)
		return NULL;

	rval = list->list[list->itr_next];
	list->itr_curr = list->itr_next;
	INCR_IDX(list, itr_next);

	if (!VALID_IDX(list, list->itr_next))
		list->itr_next = -2;	/* on the last item */

	return rval;
}

/** Delete the current iterated item  */
void *
slist_itr_remove(slist *list)
{
	SLIST_ASSERT(list != NULL);

	return slist_remove(list, VIRT_IDX(list, list->itr_curr));
}

/** Sort the list items by quick sort algorithm using given compar */
void
slist_qsort(slist *list, int (*compar)(const void *, const void *))
{
	if (list->first_idx != list->last_idx)	/* is not empty */
		slist_qsort0(list, compar, 0, slist_length(list) - 1);
}

static __inline void
slist_qsort0(slist *list, int (*compar)(const void *, const void *), int l,
    int r)
{
	int i, j;
	void *p;

	i = l;
	j = r;
	p = slist_get0(list, (j + i) / 2);
	while (i <= j) {
		while (compar(slist_get0(list, i), p) < 0)
			i++;
		while (compar(slist_get0(list, j), p) > 0)
			j--;
		if (i <= j)
			slist_swap0(list, i++, j--);
	}
	if (l < j)
		slist_qsort0(list, compar, l, j);
	if (i < r)
		slist_qsort0(list, compar, i, r);
}
@


1.6
log
@strings.h -> string.h to prevent an implicit declaration. Also remove a
bunch of NULL-checks before free().
@
text
@d1 1
d438 1
a438 1
		slist_swap0(list, i - 1, (int)(arc4random() % i));
@


1.5
log
@Don't use random() because it's not safe.  Use arc4random() instead of
it.  Suggested by deraadt.
@
text
@d123 1
a123 2
	if (list->list != NULL)
		free(list->list);
@


1.4
log
@Replace npppdctl(8) by new npppctl(8).  npppctl was written from
scratch, it uses parser.c derived from ikectl(8) to have OpenBSD's
fashion.  This includes related changes listed below:
- changed npppd control IPC heavyly.
- support IPv6 as tunnel source address.
- deleted support changing the configuration of npppd_ctl on running.
  Because it is not so needed but it requires privilege operations.
- refactors.

man page helps from jmc.  tested by sebastia.
ok deraadt sebastia sthen
@
text
@a429 1
 * slist_shuffle() uses random(3). Call srandom(3) before use it.
d438 1
a438 1
		slist_swap0(list, i - 1, (int)(random() % i));
@


1.3
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d93 1
d495 32
@


1.2
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d154 1
a154 1
	memset(&list_new[list->list_size], 0, 
d183 1
a183 1
			list->last_idx -= grow_sz; 
d247 1
a247 1
int 
d269 1
a269 1
	
d302 1
a302 1
	
d334 1
a334 1
		return;	
d336 1
a336 1
		return;	
d371 1
a371 1
			first = list->first_idx;	
d383 1
a383 1
			first = list->first_idx;	
d402 1
a402 1
		memmove(&list->list[idx0], &list->list[idx0 + 1], 
d416 1
a416 1
		memmove(&list->list[first + 1], &list->list[first], 
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d27 1
a27 1
 * 任意のポインタに関するリスト操作を提供します。
d31 3
a33 3
 *	list_size;	// list に割り当てたサイズ。
 *	last_idx;	// 最初のインデックス
 *	first_idx;	// 最後のインデックス
d35 6
a40 7
 * ・first_idx == last_idx は空を示します。
 * ・fist_idx と last_idx は 0 以上 list_size - 1 以下です。
 * ・使っているサイズは、(last_idx - first_idx) % list_size です。
 *   list_size まで使ってしまうと、空と区別ができず区別しようとすると複雑
 *   になるので、そういう状況を作りません。このため、list に割り当てたサイズ
 *   のうち 1個分は使いません。
 * ・XXX itr_curr が削除されると、
d66 1
a66 2
 * 内部のインデックスが範囲内ならば、1 を範囲を越えている場合には 0 を
 * を返すマクロです。
d73 1
a73 1
/** インデックスを内部のインデックスに変換します。 */
d77 1
a77 1
/** 内部のインデックスをインデックスに変換します。 */
d82 1
a82 1
/** インデックスを示すメンバー変数を decrement します */
d86 1
a86 1
/** インデックスを示すメンバー変数を increment します */
d97 1
a97 1
/** 初期化処理を行います */
d106 2
a107 2
 * リストのサイズを指定します。1つの要素は内部で利用されるので、必要なサイズ
 * + 1 を指定します。サイズは小さくなりません。
d118 1
a118 1
/** 終了化処理を行います */
d127 1
a127 1
/** このリストの長さ */
d137 1
a137 1
/** リストがいっぱいの場合に割り当てサイズを成長させます。 */
d144 1
a144 1
	/* ひとつ追加できるか。できるならそのまま抜ける。*/
d146 1
a146 1
		/* list_size == slist_length() という状況は作らない */
d159 1
d161 2
a162 2
		 * 空きが真ん中にある状況で右側に空きを作ったので、左側
		 * を右にもっていく。
d166 2
a167 2
			 * 左側を右側にもっていく場合に十分なスペースがある
			 * のですべて移動
d173 4
a176 1
			/* 左側をできるかぎり右端に copy */
d179 1
a179 1
			/* 左側、copy した分を左にずらす */
d197 1
a197 1
/** リストの末尾に要素を追加します。*/
d218 1
a218 1
/** リストの末尾に指定したリストの要素全てを追加します */
d233 1
a233 1
/** idx番目の要素を返します。*/
d246 1
a246 1
/** idx番目の要素をセットします。*/
d261 1
a261 1
/** 1番目の要素を削除して取り出します。*/
d283 1
a283 4



/** 最後の要素を削除して取り出します。*/
d297 1
a297 1
/** 全て要素を削除します */
d308 1
a308 1
/* this doesn't check boudary. */
d314 1
a314 1
	itr_invalidate(list);	/* イテレータ無効 */
d321 1
a321 1
/** リストの m 番目の要素と n 番目の要素を入れ換えます。 */
d341 1
a341 1
/** idx 番目の要素を削除します */
d367 1
a367 1
	/* last 側を縮めるか、first 側を縮めるか。*/
d369 1
a369 1
		/* いちおう短い方を選択 */
d379 2
a380 1
		 * 0 < last (未使用) first < idx < size なので first 側を縮める
d391 1
a391 1
	/* last側 */
d394 1
a394 1
		/* idx0 〜 last を左にひとつずらす */
d405 1
a405 1
	/* first側 */
d408 1
a408 1
		/* first 〜 idx0 を右にひとつずらす */
d428 2
a429 4
 * シャッフルします。
 * <p>
 * <b>slist_shuffle は random(3) を使ってます。使用前に srandom(3) してく
 * ださい。</b></p>
d441 1
a441 3
/**
 * イテレータを初期化します。ひとつの slist インスタンスでひとつしか使えません。
 */
d451 4
a454 4
 * イテレータが次の要素に進めるかどうかを返します。
 * @@return イテレータが次の要素を返すことができる場合に 1 を返します。
 *	終端に達したか、イテレータが最後まで達したか、リスト構造の変更があって、
 *	続行不能な場合には 0 が返ります。
d464 1
a464 1
/** イテレータの次の要素を取り出しつつ、次の要素に進めます。 */
d487 1
a487 1
/** イテレータの現在の要素を削除します */
@

