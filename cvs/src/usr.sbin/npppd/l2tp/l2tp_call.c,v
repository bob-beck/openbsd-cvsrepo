head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.10
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.19
date	2015.12.05.16.10.31;	author yasuoka;	state Exp;
branches;
next	1.18;
commitid	CAVUqjHZb5KSEF4I;

1.18
date	2015.07.20.19.03.54;	author yasuoka;	state Exp;
branches;
next	1.17;
commitid	uMtYKtqdxBlRLy7t;

1.17
date	2015.06.24.05.20.16;	author yasuoka;	state Exp;
branches;
next	1.16;
commitid	YDRNbrCPmk1DFZbt;

1.16
date	2015.01.19.01.48.59;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	a1BWBASyBgKKetQd;

1.15
date	2013.09.20.07.26.23;	author yasuoka;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches
	1.14.2.1
	1.14.4.1;
next	1.13;

1.13
date	2012.07.13.15.11.14;	author yasuoka;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2012.05.08.13.18.37;	author yasuoka;	state Exp;
branches;
next	1.11;

1.11
date	2012.05.08.13.15.11;	author yasuoka;	state Exp;
branches;
next	1.10;

1.10
date	2012.01.23.03.41.21;	author yasuoka;	state Exp;
branches;
next	1.9;

1.9
date	2012.01.18.03.13.04;	author yasuoka;	state Exp;
branches;
next	1.8;

1.8
date	2011.10.15.03.24.11;	author yasuoka;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.20.23.12.33;	author jasper;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.24.14.50.30;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.27.07.27.02;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.07.49.44;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;

1.13.2.1
date	2013.09.20.14.05.09;	author yasuoka;	state Exp;
branches;
next	;

1.14.2.1
date	2013.09.20.14.04.36;	author yasuoka;	state Exp;
branches;
next	;

1.14.4.1
date	2013.09.20.14.03.18;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Pass the pppx_hdr when sending packets through the pppx device and use the
ppp_id in the pppx_hdr to find the associated ppp when receiving the packets
from the device.
@
text
@/*	$OpenBSD: l2tp_call.c,v 1.18 2015/07/20 19:03:54 yasuoka Exp $	*/

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/* $Id: l2tp_call.c,v 1.18 2015/07/20 19:03:54 yasuoka Exp $ */
/**@@file L2TP LNS call */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <stdlib.h>
#include <stddef.h>
#include <netinet/in.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <stdarg.h>
#include <unistd.h>
#include <event.h>
#include <net/if_dl.h>

#include "debugutil.h"
#include "bytebuf.h"
#include "hash.h"
#include "slist.h"
#include "l2tp.h"
#include "l2tp_subr.h"

#include "npppd.h"
#include "l2tp_local.h"

#ifdef	L2TP_CALL_DEBUG
#define	L2TP_CALL_DBG(m)	l2tp_call_log m
#define	L2TP_CALL_ASSERT(x)	ASSERT(x)
#else
#define	L2TP_CALL_DBG(m)
#define	L2TP_CALL_ASSERT(x)
#endif

static void  l2tp_call_log (l2tp_call *, int, const char *, ...) __printflike(3,4);
static void               l2tp_call_disconnect (l2tp_call *, int, int, const char *, struct l2tp_avp *[], int);
static int                l2tp_call_recv_ICRQ (l2tp_call *, u_char *, int);
static int                l2tp_call_send_ICRP (l2tp_call *);
static int                l2tp_call_recv_ICCN (l2tp_call *, u_char *, int, dialin_proxy_info *);
static int                l2tp_recv_CDN (l2tp_call *, u_char *, int);
static int                l2tp_call_send_CDN (l2tp_call *, int, int, const char *, struct l2tp_avp *[], int);
static int                l2tp_call_send_ZLB (l2tp_call *);
static inline const char  *l2tp_call_state_string (l2tp_call *);
static int                l2tp_call_bind_ppp (l2tp_call *, dialin_proxy_info *);
static void               l2tp_call_notify_down (l2tp_call *);
static int                l2tp_call_send_data_packet (l2tp_call *, bytebuffer *);

static int   l2tp_call_ppp_output (npppd_ppp *, unsigned char *, int, int);
static void  l2tp_call_closed_by_ppp (npppd_ppp *);

/* create {@@link ::_l2tp_call L2TP call} instance */
l2tp_call *
l2tp_call_create(void)
{
	l2tp_call *_this;

	if ((_this = malloc(sizeof(l2tp_call))) == NULL)
		return NULL;

	return _this;
}

/* initialize {@@link ::_l2tp_call L2TP call} instance */
int
l2tp_call_init(l2tp_call *_this, l2tp_ctrl *ctrl)
{
	memset(_this, 0, sizeof(l2tp_call));

	_this->ctrl = ctrl;
	if (l2tpd_assign_call(ctrl->l2tpd, _this) != 0)
		return -1;

	_this->use_seq = ctrl->data_use_seq;

	return 0;
}

/* free {@@link ::_l2tp_call L2TP call} instance */
void
l2tp_call_destroy(l2tp_call *_this, int from_l2tp_ctrl)
{
	l2tpd_release_call(_this->ctrl->l2tpd, _this);
	free(_this);
}

/*
 * l2tp disconnect will occur when
 *      1) disconnect request issued from nppdctl command
 *      2) npppd is terminated
 * in case 1) ppp_stop() is used to terminal. (PPP LCP TermReq)
 * and in case 2) l2tp_call_disconnect() is used (L2TP CDN)
 */
/* administrative reason disconnection */
void
l2tp_call_admin_disconnect(l2tp_call *_this)
{
	l2tp_call_disconnect(_this, L2TP_CDN_RCODE_ADMINISTRATIVE_REASON, 0,
	    NULL, NULL, 0);
}

void
l2tp_call_drop(l2tp_call *_this)
{
	l2tp_call_disconnect(_this, 0, 0, NULL, NULL, 0);
}

/*
 * disconnect l2tp connection
 * @@param result_code	disconect without CDN, specify zero
 */
static void
l2tp_call_disconnect(l2tp_call *_this, int result_code, int error_code,
    const char *errmes, struct l2tp_avp *addavp[], int naddavp)
{
	L2TP_CALL_ASSERT(_this != NULL);

	if (_this->state == L2TP_CALL_STATE_CLEANUP_WAIT) {
		/* CDN received, or have been sent */
		l2tp_call_notify_down(_this);	/* just in case */
		return;
	}
	if (result_code > 0) {
		if (l2tp_call_send_CDN(_this, result_code, error_code, errmes,
		    addavp, naddavp)
		    != 0)
			l2tp_call_log(_this, LOG_ERR, "Error sending CDN: %m");
	}
	_this->state = L2TP_CALL_STATE_CLEANUP_WAIT;
	l2tp_call_notify_down(_this);
}

/*
 * control packet
 */

/* call it when control packet is received */
int
l2tp_call_recv_packet(l2tp_ctrl *ctrl, l2tp_call *_this, int mestype,
    u_char *pkt, int pktlen)
{
	int i, len, session_id, send_cdn;
	l2tp_call *call;
	dialin_proxy_info dpi;

	/* when ICRQ, this will be NULL */
	L2TP_CALL_ASSERT(_this != NULL ||
	    mestype == L2TP_AVP_MESSAGE_TYPE_ICRQ);

	if (_this == NULL) {
		if (mestype != L2TP_AVP_MESSAGE_TYPE_ICRQ)
			return 1;
		if ((_this = l2tp_call_create()) == NULL) {
			l2tp_ctrl_log(ctrl, LOG_ERR,
			    "l2tp_call_create failed in %s(): %m", __func__);
			return 1;
		}
		l2tp_call_init(_this, ctrl);

		if (l2tp_call_recv_ICRQ(_this, pkt, pktlen) != 0)
			return 1;

		len = slist_length(&ctrl->call_list);
		session_id = _this->id;
	    again:
		/* assign a session ID */
		session_id &= 0xffff;
		if (session_id == 0)
			session_id = 1;
		for (i = 0; i < len; i++) {
			call = slist_get(&ctrl->call_list, i);
			if (call->session_id == session_id) {
				session_id++;
				goto again;
			}
		}
		_this->session_id = session_id;

		/* add the l2tp_call to call list */
		slist_add(&_this->ctrl->call_list, _this);

		if (l2tp_call_send_ICRP(_this) != 0)
			return 1;
		_this->state = L2TP_CALL_STATE_WAIT_CONN;
		return 0;
	}

	/* state machine */
	send_cdn = 0;
	switch (_this->state) {
	default:
		break;
	case L2TP_CALL_STATE_WAIT_CONN:
		switch (mestype) {
		case L2TP_AVP_MESSAGE_TYPE_ICCN:
			memset(&dpi, 0, sizeof(dpi));
			if (l2tp_call_recv_ICCN(_this, pkt, pktlen, &dpi) != 0)
				return 1;
			l2tp_call_bind_ppp(_this, &dpi);
			l2tp_call_send_ZLB(_this);
			_this->state = L2TP_CALL_STATE_ESTABLISHED;
			_this->ctrl->ncalls++;
			return 0;
		case L2TP_AVP_MESSAGE_TYPE_ICRQ:
		case L2TP_AVP_MESSAGE_TYPE_ICRP:
			send_cdn = 1;
			/* FALLTHROUGH */
		default:
			l2tp_call_log(_this, LOG_ERR,
			    "Waiting ICCN.  But received %s",
			    avp_mes_type_string(mestype));
			if (send_cdn) {
				l2tp_call_disconnect(_this,
				    L2TP_CDN_RCODE_ERROR_CODE,
				    L2TP_ECODE_GENERIC_ERROR, "Illegal state.",
				    NULL, 0);
				return 0;
			}
		}
		break;
	case L2TP_CALL_STATE_ESTABLISHED:
		switch (mestype) {
		case L2TP_AVP_MESSAGE_TYPE_CDN:
			/* disconnect from peer. log it */
			l2tp_recv_CDN(_this, pkt, pktlen);
			_this->state = L2TP_CALL_STATE_CLEANUP_WAIT;
			l2tp_call_notify_down(_this);
			l2tp_call_send_ZLB(_this);
			return 0;
		case L2TP_AVP_MESSAGE_TYPE_ICRQ:
		case L2TP_AVP_MESSAGE_TYPE_ICRP:
		case L2TP_AVP_MESSAGE_TYPE_ICCN:
			send_cdn = 1;
			break;
		default:
			break;
		}
		l2tp_call_log(_this, LOG_ERR,
		    "Call established.  But received %s",
		    avp_mes_type_string(mestype));
		if (send_cdn) {
			l2tp_call_disconnect(_this,
			    L2TP_CDN_RCODE_ERROR_CODE,
			    L2TP_ECODE_GENERIC_ERROR, "Illegal state.",
			    NULL, 0);
			return 0;
		}
		l2tp_call_disconnect(_this, 0, 0, NULL, NULL, 0);
		return 1;
	}
	l2tp_call_log(_this, LOG_INFO, "Received %s in unexpected state=%s",
	    avp_mes_type_string(mestype), l2tp_call_state_string(_this));
	l2tp_call_disconnect(_this, 0, 0, NULL, NULL, 0);
	return 1;
}
/*
 * receieve ICRQ
 * @@return	return 0 if the ICRQ is acceptable.
 *		other values means fail to receive, and
 *		CDN was sent and status was updated.
 */
static int
l2tp_call_recv_ICRQ(l2tp_call *_this, u_char *pkt, int pktlen)
{
	int avpsz, slen;
	struct l2tp_avp *avp;
	char buf[L2TP_AVP_MAXSIZ], emes[256];

	avp = (struct l2tp_avp *)buf;
	while (pktlen >= 6 && (avpsz = avp_enum(avp, pkt, pktlen, 1)) > 0) {
		pkt += avpsz;
		pktlen -= avpsz;
		if (avp->vendor_id != 0) {
			L2TP_CALL_DBG((_this, LOG_DEBUG,
			    "Received a Vendor-specific AVP vendor-id=%d "
			    "type=%d", avp->vendor_id, avp->attr_type));
			continue;
		}
		if (avp->is_hidden != 0) {
			l2tp_call_log(_this, LOG_WARNING,
			    "Received AVP (%s/%d) is hidden.  But we don't "
			    "share secret.",
			    avp_attr_type_string(avp->attr_type),
			    avp->attr_type);
			if (avp->is_mandatory != 0) {
				l2tp_call_disconnect(_this,
				    L2TP_CDN_RCODE_ERROR_CODE,
				    L2TP_ECODE_UNKNOWN_MANDATORY_AVP, NULL,
				    NULL, 0);
				return 1;
			}
			continue;
		}
		switch (avp->attr_type) {
		case L2TP_AVP_TYPE_MESSAGE_TYPE:
			AVP_SIZE_CHECK(avp, ==, 8);
			continue;
		case L2TP_AVP_TYPE_ASSIGNED_SESSION_ID:
			AVP_SIZE_CHECK(avp, ==, 8);
			_this->peer_session_id = avp_get_val16(avp);
			continue;
		case L2TP_AVP_TYPE_CALL_SERIAL_NUMBER:
		case L2TP_AVP_TYPE_BEARER_TYPE:
		case L2TP_AVP_TYPE_PHYSICAL_CHANNEL_ID:
			/*
			 * Memo:
			 * Microsoft "L2TP/IPsec VPN Client" for
			 * Windows 98/Me/NT asserts mandatory bit in
			 * Physical Channel Id
			 */
			break;
		case L2TP_AVP_TYPE_CALLING_NUMBER:
			slen = MINIMUM(sizeof(_this->calling_number) - 1,
			    avp_attr_length(avp));
			memcpy(_this->calling_number, avp->attr_value, slen);
			_this->calling_number[slen] = '\0';
			break;
		case L2TP_AVP_TYPE_CALLED_NUMBER:
		case L2TP_AVP_TYPE_SUB_ADDRESS:
			continue;
		default:
			if (avp->is_mandatory) {
				l2tp_call_log(_this, LOG_WARNING,
				    "AVP (%s/%d) is not supported, but it's "
				    "mandatory",
				    avp_attr_type_string(avp->attr_type),
				    avp->attr_type);
				if (avp->is_mandatory != 0) {
					l2tp_call_disconnect(_this,
					    L2TP_CDN_RCODE_ERROR_CODE,
					    L2TP_ECODE_UNKNOWN_MANDATORY_AVP,
					    NULL, NULL, 0);
					return 1;
				}
#ifdef L2TP_CALL_DEBUG
			} else {
				L2TP_CALL_DBG((_this, LOG_DEBUG,
				    "AVP (%s/%d) is not handled",
				    avp_attr_type_string(avp->attr_type),
				    avp->attr_type));
#endif
			}
		}
	}
	if (_this->peer_session_id == 0) {
		l2tp_call_log(_this, LOG_ERR,
		    "Received a bad ICRP: SessionId = 0");
		l2tp_call_disconnect(_this, L2TP_CDN_RCODE_ERROR_CODE,
		    L2TP_ECODE_INVALID_MESSAGE, "Session Id must not be 0",
		    NULL, 0);
		return 1;
	}
	l2tp_call_log(_this, LOG_INFO, "RecvICRQ session_id=%u",
	    _this->peer_session_id);

	return 0;
size_check_failed:
	l2tp_call_log(_this, LOG_ERR, "Received bad ICRQ: %s", emes);
	l2tp_call_disconnect(_this, L2TP_CDN_RCODE_ERROR_CODE,
	    L2TP_ECODE_WRONG_LENGTH, NULL, NULL, 0);

	return 1;
}

/* send ICRP */
static int
l2tp_call_send_ICRP(l2tp_call *_this)
{
	int rval;
	struct l2tp_avp *avp;
	char buf[L2TP_AVP_MAXSIZ];
	bytebuffer *bytebuf;

	bytebuf = l2tp_ctrl_prepare_snd_buffer(_this->ctrl, 1);
	if (bytebuf == NULL) {
		l2tp_call_log(_this, LOG_ERR, "sending ICRP failed: no buffer");
		return 1;
	}
	avp = (struct l2tp_avp *)buf;

	/* Message Type = ICRP */
	memset(avp, 0, sizeof(*avp));
	avp->is_mandatory = 1;
	avp->attr_type = L2TP_AVP_TYPE_MESSAGE_TYPE;
	avp_set_val16(avp, L2TP_AVP_MESSAGE_TYPE_ICRP);
	bytebuf_add_avp(bytebuf, avp, 2);

	memset(avp, 0, sizeof(*avp));
	avp->is_mandatory = 1;
	avp->attr_type = L2TP_AVP_TYPE_ASSIGNED_SESSION_ID;
	avp_set_val16(avp, _this->session_id);
	bytebuf_add_avp(bytebuf, avp, 2);

	if ((rval = l2tp_ctrl_send_packet(_this->ctrl, _this->peer_session_id,
	    bytebuf)) != 0) {
		l2tp_call_log(_this, LOG_ERR, "failed to SendICRP: %m");
		return 1;
	}
	l2tp_call_log(_this, LOG_INFO, "SendICRP session_id=%u",
	    _this->session_id);
	return 0;
}

/* send L2TP data message */
static int
l2tp_call_send_data_packet(l2tp_call *_this, bytebuffer *buffer)
{
	int rval;
	struct l2tp_header *hdr;

	bytebuffer_flip(buffer);
	hdr = (struct l2tp_header *)bytebuffer_pointer(buffer);
	memset(hdr, 0, sizeof(*hdr) - 4);	/* Nr, NS are option */

	hdr->t = 0;
	hdr->ver = L2TP_HEADER_VERSION_RFC2661;
	hdr->l = 1;
	hdr->length = htons(bytebuffer_remaining(buffer));
	hdr->tunnel_id = htons(_this->ctrl->peer_tunnel_id);
	hdr->session_id = htons(_this->peer_session_id);
	if (_this->use_seq) {
		hdr->s = 1;
		hdr->ns = htons(_this->snd_nxt++);
		hdr->nr = htons(_this->rcv_nxt);
	}

	if (L2TP_CTRL_CONF(_this->ctrl)->data_out_pktdump != 0) {
		l2tpd_log(_this->ctrl->l2tpd, LOG_DEBUG,
		    "ctrl=%u call=%u L2TP Data output packet dump",
		    _this->ctrl->id, _this->id);
		show_hd(debug_get_debugfp(), bytebuffer_pointer(buffer),
		    bytebuffer_remaining(buffer));
	}
	if ((rval = l2tp_ctrl_send(_this->ctrl, bytebuffer_pointer(buffer),
	    bytebuffer_remaining(buffer))) < 0) {
		L2TP_CALL_DBG((_this, LOG_DEBUG, "sendto() failed: %m"));
	}

	return (rval == bytebuffer_remaining(buffer))? 0 : 1;
}

/*
 * receive ICCN
 * @@return	return 0 if the ICCN is acceptable.
 *		other value means fail to receive, and
 *		CDN was sent and status was updated.
 */
static int
l2tp_call_recv_ICCN(l2tp_call *_this, u_char *pkt, int pktlen,
    dialin_proxy_info *dpi)
{
	int avpsz, tx_conn_speed;
	uint32_t framing_type = 0;
	struct l2tp_avp *avp;
	char buf[L2TP_AVP_MAXSIZ], emes[256];

	tx_conn_speed = 0;
	avp = (struct l2tp_avp *)buf;
	while (pktlen >= 6 && (avpsz = avp_enum(avp, pkt, pktlen, 1)) > 0) {
		pkt += avpsz;
		pktlen -= avpsz;
		if (avp->vendor_id != 0) {
			L2TP_CALL_DBG((_this, LOG_DEBUG,
			    "Received a Vendor-specific AVP vendor-id=%d "
			    "type=%d", avp->vendor_id, avp->attr_type));
			continue;
		}
		if (avp->is_hidden != 0) {
			l2tp_call_log(_this, LOG_WARNING,
			    "Received AVP (%s/%d) is hidden.  But we don't "
			    "share secret.",
			    avp_attr_type_string(avp->attr_type),
			    avp->attr_type);
			if (avp->is_mandatory != 0) {
				l2tp_call_disconnect(_this,
				    L2TP_CDN_RCODE_ERROR_CODE,
				    L2TP_ECODE_UNKNOWN_MANDATORY_AVP, NULL,
				    NULL, 0);
				return 1;
			}
			continue;
		}
		switch (avp->attr_type) {
		case L2TP_AVP_TYPE_MESSAGE_TYPE:
			AVP_SIZE_CHECK(avp, ==, 8);
			continue;
		case L2TP_AVP_TYPE_RX_CONNECT_SPEED:
			/*
			 * As RFC 2661 this AVP is not mandatory.  But `xl2tpd'
			 * sends this as a mandatory AVP.  Handle this to
			 * ignore the xl2tpd' bug.
			 */
			AVP_SIZE_CHECK(avp, ==, 10);
			continue;
		case L2TP_AVP_TYPE_TX_CONNECT_SPEED:
			AVP_SIZE_CHECK(avp, ==, 10);
			tx_conn_speed = avp_get_val32(avp);
			continue;
		case L2TP_AVP_TYPE_FRAMING_TYPE:
			AVP_SIZE_CHECK(avp, ==, 10);
			framing_type = avp_get_val32(avp);
			continue;
		case L2TP_AVP_TYPE_SEQUENCING_REQUIRED:
			_this->seq_required = 1;
			_this->use_seq = 1;
			continue;
	    /*
	     * AVP's for Proxy-LCP and Proxy-Authen
	     */
		case L2TP_AVP_TYPE_LAST_SENT_LCP_CONFREQ:
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->last_sent_lcp.data));
			memcpy(dpi->last_sent_lcp.data, avp->attr_value,
			    avp_attr_length(avp));
			dpi->last_sent_lcp.ldata = avp_attr_length(avp);
			break;
		case L2TP_AVP_TYPE_LAST_RECV_LCP_CONFREQ:
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->last_recv_lcp.data));
			memcpy(dpi->last_recv_lcp.data, avp->attr_value,
			    avp_attr_length(avp));
			dpi->last_recv_lcp.ldata = avp_attr_length(avp);
			break;
		case L2TP_AVP_TYPE_PROXY_AUTHEN_CHALLENGE:
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->auth_chall));
			memcpy(dpi->auth_chall, avp->attr_value,
			    avp_attr_length(avp));
			dpi->lauth_chall = avp_attr_length(avp);
			break;
		case L2TP_AVP_TYPE_PROXY_AUTHEN_ID:
			AVP_SIZE_CHECK(avp, ==, 8);
			dpi->auth_id = avp_get_val16(avp);
			break;
		case L2TP_AVP_TYPE_PROXY_AUTHEN_NAME:
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->username) - 1);
			memcpy(dpi->username, avp->attr_value,
			    avp_attr_length(avp));
			break;
		case L2TP_AVP_TYPE_PROXY_AUTHEN_RESPONSE:
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->auth_resp));
			memcpy(dpi->auth_resp, avp->attr_value,
			    avp_attr_length(avp));
			dpi->lauth_resp = avp_attr_length(avp);
			break;
		case L2TP_AVP_TYPE_PROXY_AUTHEN_TYPE:
			AVP_SIZE_CHECK(avp, ==, 8);
			switch (avp_get_val16(avp)) {
			default:
				l2tp_call_log(_this, LOG_WARNING,
				    "RecvICCN Unknown proxy-authen-type=%d",
				    avp_get_val16(avp));
				/* FALLTHROUGH */
			case L2TP_AUTH_TYPE_NO_AUTH:
				dpi->auth_type = 0;
				break;
			case L2TP_AUTH_TYPE_PPP_CHAP:
				dpi->auth_type = PPP_AUTH_CHAP_MD5;
				break;
			case L2TP_AUTH_TYPE_PPP_PAP:
				dpi->auth_type = PPP_AUTH_PAP;
				break;
			case L2TP_AUTH_TYPE_MS_CHAP_V1:
				dpi->auth_type = PPP_AUTH_CHAP_MS;
				break;
			}
			break;
		default:
			if (avp->is_mandatory != 0) {
				l2tp_call_log(_this, LOG_WARNING,
				    "AVP (%s/%d) is not supported, but it's "
				    "mandatory",
				    avp_attr_type_string(avp->attr_type),
				    avp->attr_type);
				l2tp_call_disconnect(_this,
				    L2TP_CDN_RCODE_ERROR_CODE,
				    L2TP_ECODE_UNKNOWN_MANDATORY_AVP, NULL,
				    NULL, 0);
				return 1;
#ifdef L2TP_CALL_DEBUG
			} else {
				L2TP_CALL_DBG((_this, LOG_DEBUG,
				    "AVP (%s/%d) is not handled",
				    avp_attr_type_string(avp->attr_type),
				    avp->attr_type));
#endif
			}
		}
	}
	l2tp_call_log(_this, LOG_INFO, "RecvICCN "
	    "session_id=%u calling_number=%s tx_conn_speed=%u framing=%s",
	    _this->peer_session_id, _this->calling_number, tx_conn_speed,
	    ((framing_type & L2TP_FRAMING_CAP_FLAGS_ASYNC) != 0)? "async" :
	    ((framing_type & L2TP_FRAMING_CAP_FLAGS_SYNC) != 0)? "sync" :
	    "unknown");

	return 0;
size_check_failed:
	l2tp_call_log(_this, LOG_ERR, "Received bad ICCN: %s", emes);
	l2tp_call_disconnect(_this, L2TP_CDN_RCODE_ERROR_CODE,
	    L2TP_ECODE_WRONG_LENGTH, NULL, NULL, 0);
	return 1;
}

/* receive CDN */
static int
l2tp_recv_CDN(l2tp_call *_this, u_char *pkt, int pktlen)
{
	int result, error, avpsz, len, sessid;
	struct l2tp_avp *avp;
	char buf[L2TP_AVP_MAXSIZ], emes[256], pmes[256];

	/* initialize */
	result = 0;
	error = 0;
	sessid = 0;
	strlcpy(pmes, "(none)", sizeof(pmes));

	avp = (struct l2tp_avp *)buf;
	while (pktlen >= 6 && (avpsz = avp_enum(avp, pkt, pktlen, 1)) > 0) {
		pkt += avpsz;
		pktlen -= avpsz;
		if (avp->vendor_id != 0) {
			L2TP_CALL_DBG((_this, LOG_DEBUG,
			    "Received a Vendor-specific AVP vendor-id=%d "
			    "type=%d", avp->vendor_id, avp->attr_type));
			continue;
		}
		if (avp->is_hidden != 0) {
			l2tp_call_log(_this, LOG_WARNING,
			    "Received AVP (%s/%d) is hidden.  But we don't "
			    "share secret.",
			    avp_attr_type_string(avp->attr_type),
			    avp->attr_type);
			if (avp->is_mandatory != 0) {
				l2tp_call_disconnect(_this,
				    L2TP_CDN_RCODE_ERROR_CODE,
				    L2TP_ECODE_UNKNOWN_MANDATORY_AVP, NULL,
				    NULL, 0);
				return 1;
			}
			continue;
		}
		switch (avp->attr_type) {
		case L2TP_AVP_TYPE_MESSAGE_TYPE:
			AVP_SIZE_CHECK(avp, ==, 8);
			continue;
		case L2TP_AVP_TYPE_RESULT_CODE:
			AVP_SIZE_CHECK(avp, >=, 8);
			result = avp->attr_value[0] << 8 | avp->attr_value[1];
			if (avp->length >= 10) {
				error = avp->attr_value[2] << 8 |
				    avp->attr_value[3];
				len = avp->length - 12;
				if (len > 0) {
					len = MINIMUM(len, sizeof(pmes) - 1);
					memcpy(pmes, &avp->attr_value[4], len);
					pmes[len] = '\0';
				}
			}
			continue;
		case L2TP_AVP_TYPE_ASSIGNED_SESSION_ID:
			AVP_SIZE_CHECK(avp, >=, 8);
			sessid = avp_get_val16(avp);
			continue;
		default:
			if (avp->is_mandatory) {
				l2tp_call_log(_this, LOG_WARNING,
				    "AVP (%s/%d) is not supported, but it's "
				    "mandatory",
				    avp_attr_type_string(avp->attr_type),
				    avp->attr_type);
				if (avp->is_mandatory != 0) {
					l2tp_call_disconnect(_this,
					    L2TP_CDN_RCODE_ERROR_CODE,
					    L2TP_ECODE_UNKNOWN_MANDATORY_AVP,
					    NULL, NULL, 0);
					return 1;
				}
#ifdef L2TP_CALL_DEBUG
			} else {
				L2TP_CALL_DBG((_this, LOG_DEBUG,
				    "AVP (%s/%d) is not handled",
				    avp_attr_type_string(avp->attr_type),
				    avp->attr_type));
#endif
			}
		}
	}
	if (error == 0) {
		l2tp_call_log(_this, LOG_INFO,
		    "RecvCDN result=%s/%d", l2tp_cdn_rcode_string(result),
		    result);
	} else {
		l2tp_call_log(_this, LOG_INFO,
		    "RecvCDN result=%s/%d error=%s/%d message=%s",
		    l2tp_cdn_rcode_string(result), result,
		    l2tp_ecode_string(error), error, pmes);
	}

	return 0;

size_check_failed:
	/* continue to process even if the CDN message was broken */
	l2tp_call_log(_this, LOG_ERR, "Received bad CDN: %s", emes);

	return 0;
}

/* send CDN */
static int
l2tp_call_send_CDN(l2tp_call *_this, int result_code, int error_code, const
    char *errmes, struct l2tp_avp *addavp[], int naddavp)
{
	uint32_t val32;
	int i, avplen, len;
	struct l2tp_avp *avp;
	char buf[L2TP_AVP_MAXSIZ];
	bytebuffer *bytebuf;

	L2TP_CALL_ASSERT(_this != NULL);
	bytebuf = l2tp_ctrl_prepare_snd_buffer(_this->ctrl, 1);
	if (bytebuf == NULL) {
		l2tp_call_log(_this, LOG_ERR, "sending CDN failed: no buffer");
		return 1;
	}
	avp = (struct l2tp_avp *)buf;

	/* Message Type = CDN */
	memset(avp, 0, sizeof(*avp));
	avp->is_mandatory = 1;
	avp->attr_type = L2TP_AVP_TYPE_MESSAGE_TYPE;
	avp_set_val16(avp, L2TP_AVP_MESSAGE_TYPE_CDN);
	bytebuf_add_avp(bytebuf, avp, 2);

	/* Result Code */
	memset(avp, 0, sizeof(*avp));
	avp->is_mandatory = 1;
	avp->attr_type = L2TP_AVP_TYPE_RESULT_CODE;
#if 0
/*
 * Windows 2000 work around:
 * Windows 2000 will return "2 - Length is wrong" in StopCCN,
 * when it received "length = 8 and no error code AVP".
 * Avoid the error, use AVP length = 10.
 */
	if (error_code > 0) {
		val32 = (result_code << 16) | (error_code & 0xffff);
		avplen = 4;
		avp_set_val32(avp, val32);
	} else {
		avplen = 2;
		avp_set_val16(avp, result_code);
	}
#else
	val32 = (result_code << 16) | (error_code & 0xffff);
	avplen = 4;
	avp_set_val32(avp, val32);
#endif

	if (errmes != NULL) {
		len = MINIMUM(strlen(errmes), L2TP_AVP_MAXSIZ - 128);
		memcpy(&avp->attr_value[avplen], errmes, len);
		avplen += len;
	}
	bytebuf_add_avp(bytebuf, avp, avplen);

	/* Assigned Session Id */
	memset(avp, 0, sizeof(*avp));
	avp->is_mandatory = 1;
	avp->attr_type = L2TP_AVP_TYPE_ASSIGNED_SESSION_ID;
	if (_this != NULL && _this->session_id != 0)
		avp_set_val16(avp, _this->session_id);
	else
		avp_set_val16(avp, 0);
	bytebuf_add_avp(bytebuf, avp, 2);

	for (i = 0; i < naddavp; i++)
		bytebuf_add_avp(bytebuf, addavp[i], addavp[i]->length - 6);

	if (l2tp_ctrl_send_packet(_this->ctrl, _this->peer_session_id,
	    bytebuf) != 0) {
		l2tp_call_log(_this, LOG_ERR, "Error sending CDN: %m");
		return 1;
	}

	if (error_code > 0) {
		l2tp_call_log(_this, LOG_INFO,
		    "SendCDN result=%s/%d error=%s/%d messsage=%s",
		    l2tp_cdn_rcode_string(result_code), result_code,
		    l2tp_ecode_string(error_code), error_code,
		    (errmes == NULL)? "none" : errmes);
	} else {
		l2tp_call_log(_this, LOG_INFO, "SendCDN result=%s/%d",
		    l2tp_cdn_rcode_string(result_code), result_code);
	}

	return 0;
}

/* send ZLB */
static int
l2tp_call_send_ZLB(l2tp_call *_this)
{
	bytebuffer *bytebuf;

	l2tp_call_log(_this, LOG_INFO, "SendZLB");
	bytebuf = l2tp_ctrl_prepare_snd_buffer(_this->ctrl, 1);
	if (bytebuf == NULL) {
		l2tp_call_log(_this, LOG_ERR, "sending ZLB failed: no buffer");
		return 1;
	}
	return l2tp_ctrl_send_packet(_this->ctrl, _this->peer_session_id,
	    bytebuf);
}

/*
 * misc
 */
/* logging with the label of the instance */
static void
l2tp_call_log(l2tp_call *_this, int prio, const char *fmt, ...)
{
	char logbuf[BUFSIZ];
	va_list ap;

	va_start(ap, fmt);
#ifdef	L2TPD_MULTIPLE
	snprintf(logbuf, sizeof(logbuf), "l2tpd id=%u ctrl=%u call=%u %s",
	    _this->ctrl->l2tpd->id, _this->ctrl->id, _this->id, fmt);
#else
	snprintf(logbuf, sizeof(logbuf), "l2tpd ctrl=%u call=%u %s",
	    _this->ctrl->id, _this->id, fmt);
#endif
	vlog_printf(prio, logbuf, ap);
	va_end(ap);
}

/* convert current status to strings */
static inline const char *
l2tp_call_state_string(l2tp_call *_this)
{
	switch (_this->state) {
	case L2TP_CALL_STATE_IDLE:		return "idle";
	case L2TP_CALL_STATE_WAIT_CONN:		return "wait-conn";
	case L2TP_CALL_STATE_ESTABLISHED:	return "established";
	case L2TP_CALL_STATE_CLEANUP_WAIT:	return "cleanup-wait";
	}
	return "unknown";
}

/*
 * npppd physical layer
 */

/* input packet to ppp */
void
l2tp_call_ppp_input(l2tp_call *_this, u_char *pkt, int pktlen, int delayed)
{
	int rval;
	npppd_ppp *ppp;

	ppp = _this->ppp;
	rval = ppp->recv_packet(ppp, pkt, pktlen,
	    delayed ? PPP_IO_FLAGS_DELAYED : 0);

	if (_this->ppp == NULL)		/* ppp is freed */
		return;

	if (rval != 0)
		ppp->ierrors++;
	else {
		ppp->ipackets++;
		ppp->ibytes += pktlen;
	}
}

/* called ppp output a packet */
static int
l2tp_call_ppp_output(npppd_ppp *ppp, unsigned char *bytes, int nbytes,
    int flags)
{
	l2tp_call *_this;
	bytebuffer *bytebuf;

	_this = ppp->phy_context;

	bytebuf = l2tp_ctrl_prepare_snd_buffer(_this->ctrl, _this->use_seq);

	if (bytebuf != NULL) {
		bytebuffer_put(bytebuf, bytes, nbytes);
		if (l2tp_call_send_data_packet(_this, bytebuf) != 0)
			ppp->oerrors++;
		else {
			ppp->opackets++;
			ppp->obytes += nbytes;
		}
	} else
		ppp->oerrors++;

	return 0;
}

/* it will be called when the connection was closed at ppp */
static void
l2tp_call_closed_by_ppp(npppd_ppp *ppp)
{
	l2tp_call *_this;

	L2TP_CALL_ASSERT(ppp != NULL);
	L2TP_CALL_ASSERT(ppp->phy_context != NULL);

	_this = ppp->phy_context;

	/* do before l2tp_call_disconnect() */
	_this->ppp = NULL;

	if (_this->state == L2TP_CALL_STATE_CLEANUP_WAIT) {
		/*  no need to call l2tp_call_disconnect */
	} else if (ppp->disconnect_code == PPP_DISCON_NO_INFORMATION) {
		l2tp_call_disconnect(_this,
		    L2TP_CDN_RCODE_ADMINISTRATIVE_REASON, 0, NULL, NULL, 0);
	} else {
		/*
		 * RFC3145 L2TP Disconnect Cause Information
		 */
		struct l2tp_avp *avp[1];
		struct _ppp_cause {
			struct l2tp_avp avp;
			uint16_t	code;
			uint16_t	proto;
			uint8_t		direction;
			char		message[128];
		} __attribute__((__packed__)) ppp_cause;

		ppp_cause.avp.is_mandatory = 0;
		ppp_cause.avp.is_hidden = 0;
		ppp_cause.avp.vendor_id = 0;	/* ietf */
		ppp_cause.avp.attr_type =
		    L2TP_AVP_TYPE_PPP_DISCONNECT_CAUSE_CODE;
		ppp_cause.code = htons(ppp->disconnect_code);
		ppp_cause.proto = htons(ppp->disconnect_proto);
		ppp_cause.direction = ppp->disconnect_direction;
		ppp_cause.avp.length = offsetof(struct _ppp_cause, message[0]);

		if (ppp->disconnect_message != NULL) {
			strlcpy(ppp_cause.message, ppp->disconnect_message,
			    sizeof(ppp_cause.message));
			ppp_cause.avp.length += strlen(ppp_cause.message);
		}
		avp[0] = &ppp_cause.avp;
		l2tp_call_disconnect(_this,
		    L2TP_CDN_RCODE_ERROR_CODE, L2TP_ECODE_GENERIC_ERROR,
		    "Disconnected by local PPP", avp, 1);
	}
	l2tp_call_log(_this, LOG_NOTICE, "logtype=PPPUnbind");
}

/* notify disconnection to ppp to terminate or free of ppp */
static void
l2tp_call_notify_down(l2tp_call *_this)
{
	if (_this->ppp != NULL)
		ppp_phy_downed(_this->ppp);
}

/* bind ppp */
static int
l2tp_call_bind_ppp(l2tp_call *_this, dialin_proxy_info *dpi)
{
	int code, errcode;
	npppd_ppp *ppp;

	code = L2TP_CDN_RCODE_BUSY;
	errcode = 0;
	ppp = NULL;
	if ((ppp = ppp_create()) == NULL)
		goto fail;

	ASSERT(_this->ppp == NULL);

	if (_this->ppp != NULL)
		return -1;

	_this->ppp = ppp;

	ppp->tunnel_type = NPPPD_TUNNEL_L2TP;
	ppp->tunnel_session_id = _this->session_id;
	ppp->phy_context = _this;
	ppp->send_packet = l2tp_call_ppp_output;
	ppp->phy_close = l2tp_call_closed_by_ppp;

	strlcpy(ppp->phy_label, L2TP_CTRL_LISTENER_TUN_NAME(_this->ctrl),
	    sizeof(ppp->phy_label));
	L2TP_CALL_ASSERT(sizeof(ppp->phy_info) >= _this->ctrl->peer.ss_len);
	memcpy(&ppp->phy_info, &_this->ctrl->peer,
	    MINIMUM(sizeof(ppp->phy_info), _this->ctrl->peer.ss_len));
	strlcpy(ppp->calling_number, _this->calling_number,
	    sizeof(ppp->calling_number));
	if (ppp_init(npppd_get_npppd(), ppp) != 0) {
		l2tp_call_log(_this, LOG_ERR, "failed binding ppp");
		goto fail;
	}

	l2tp_call_log(_this, LOG_NOTICE, "logtype=PPPBind ppp=%d", ppp->id);
	if (DIALIN_PROXY_IS_REQUESTED(dpi)) {
		if (!L2TP_CTRL_CONF(_this->ctrl)->accept_dialin) {
			l2tp_call_log(_this, LOG_ERR,
			    "'accept_dialin' is 'false' in the setting.");
			code = L2TP_CDN_RCODE_ERROR_CODE;
			errcode = L2TP_ECODE_INVALID_MESSAGE;
			goto fail;
		}

		if (ppp_dialin_proxy_prepare(ppp, dpi) != 0) {
			code = L2TP_CDN_RCODE_TEMP_NOT_AVALIABLE;
			goto fail;
		}
	}
	ppp_start(ppp);

	return 0;
fail:
	if (ppp != NULL)
		ppp_destroy(ppp);
	_this->ppp = NULL;

	l2tp_call_disconnect(_this, code, errcode, NULL, NULL, 0);
	return 1;
}
@


1.18
log
@Pass the errcode when disconnecting L2TP call.

From Yuuichi Someya at IIJ.
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.17 2015/06/24 05:20:16 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.17 2015/06/24 05:20:16 yasuoka Exp $ */
d1011 1
@


1.17
log
@Fix npppd to terminate all PPP sessions properly even in case the
sending window for L2TP control is full when the control is terminating
(by a L2TP keepalive failure or other reasons).  In that case, if the
L2TP peer didn't respond at all, npppd had kept some PPP sessions
forever.
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.16 2015/01/19 01:48:59 deraadt Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.16 2015/01/19 01:48:59 deraadt Exp $ */
d1050 1
a1050 1
	l2tp_call_disconnect(_this, code, 0, NULL, NULL, 0);
@


1.16
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.15 2013/09/20 07:26:23 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.15 2013/09/20 07:26:23 yasuoka Exp $ */
d126 6
@


1.15
log
@Add length check for Proxy LCP and Authentication AVPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.14 2012/09/18 13:14:08 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.14 2012/09/18 13:14:08 yasuoka Exp $ */
a30 1
#include <sys/param.h>
d333 1
a333 1
			slen = MIN(sizeof(_this->calling_number) - 1,
d673 1
a673 1
					len = MIN(len, sizeof(pmes) - 1);
d779 1
a779 1
		len = MIN(strlen(errmes), L2TP_AVP_MAXSIZ - 128);
d1013 1
a1013 1
	    MIN(sizeof(ppp->phy_info), _this->ctrl->peer.ss_len));
@


1.14
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.13 2012/07/13 15:11:14 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.13 2012/07/13 15:11:14 yasuoka Exp $ */
a527 1
#ifndef	L2TPD_TEST
d532 1
d538 1
d544 1
d546 1
a546 1
			    MIN(avp_attr_length(avp), sizeof(dpi->auth_chall)));
d550 1
d554 1
d556 1
a556 2
			    MIN(sizeof(dpi->username) - 1,
			    avp_attr_length(avp)));
d559 1
d561 1
a561 1
			    MIN(avp_attr_length(avp), sizeof(dpi->auth_resp)));
d565 1
a585 1
#endif
@


1.14.2.1
log
@MFC

date: 2013/09/20 07:26:23;  author: yasuoka;  state: Exp;  lines: +12 -8;
Add length check for Proxy LCP and Authentication AVPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.14 2012/09/18 13:14:08 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.14 2012/09/18 13:14:08 yasuoka Exp $ */
d528 1
a532 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->last_sent_lcp.data));
a537 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->last_recv_lcp.data));
a542 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->auth_chall));
d544 1
a544 1
			    avp_attr_length(avp));
a547 1
			AVP_SIZE_CHECK(avp, ==, 8);
a550 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->username) - 1);
d552 2
a553 1
			    avp_attr_length(avp));
a555 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->auth_resp));
d557 1
a557 1
			    avp_attr_length(avp));
a560 1
			AVP_SIZE_CHECK(avp, ==, 8);
d581 1
@


1.14.4.1
log
@MFC

date: 2013/09/20 07:26:23;  author: yasuoka;  state: Exp;  lines: +12 -8;
Add length check for Proxy LCP and Authentication AVPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.14 2012/09/18 13:14:08 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.14 2012/09/18 13:14:08 yasuoka Exp $ */
d528 1
a532 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->last_sent_lcp.data));
a537 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->last_recv_lcp.data));
a542 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->auth_chall));
d544 1
a544 1
			    avp_attr_length(avp));
a547 1
			AVP_SIZE_CHECK(avp, ==, 8);
a550 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->username) - 1);
d552 2
a553 1
			    avp_attr_length(avp));
a555 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->auth_resp));
d557 1
a557 1
			    avp_attr_length(avp));
a560 1
			AVP_SIZE_CHECK(avp, ==, 8);
d581 1
@


1.13
log
@npppd used wrong AVPs as a `calling number' because `break' in switch
case was missing.

ok claudio henning
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.12 2012/05/08 13:18:37 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.12 2012/05/08 13:18:37 yasuoka Exp $ */
d448 1
a448 1
	if (_this->ctrl->l2tpd->data_out_pktdump != 0) {
d1001 1
a1001 1
	ppp->tunnel_type = PPP_TUNNEL_L2TP;
d1006 1
a1006 1
	strlcpy(ppp->phy_label, _this->ctrl->phy_label,
d1020 1
a1020 2
		if (!l2tp_ctrl_config_str_equal(_this->ctrl,
		    "l2tp.accept_dialin", "true", 0)) {
@


1.13.2.1
log
@MFC

date: 2013/09/20 07:26:23;  author: yasuoka;  state: Exp;  lines: +12 -8;
Add length check for Proxy LCP and Authentication AVPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.13 2012/07/13 15:11:14 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.13 2012/07/13 15:11:14 yasuoka Exp $ */
d528 1
a532 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->last_sent_lcp.data));
a537 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->last_recv_lcp.data));
a542 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->auth_chall));
d544 1
a544 1
			    avp_attr_length(avp));
a547 1
			AVP_SIZE_CHECK(avp, ==, 8);
a550 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->username) - 1);
d552 2
a553 1
			    avp_attr_length(avp));
a555 1
			AVP_MAXLEN_CHECK(avp, sizeof(dpi->auth_resp));
d557 1
a557 1
			    avp_attr_length(avp));
a560 1
			AVP_SIZE_CHECK(avp, ==, 8);
d581 1
@


1.12
log
@Trivial changes from the upstream(IIJ).
 - fix styles, compile errors in some ifdef condition and compiler warnings.
 - delete rtev* that was to work around routing socket overflows.
 - delete is_ctrl argument from l2tp_ctrl_send_packet().  It's not used.
 - tweak returning the exit status.
 - use IPV6_IPSEC_POLICY for IPv6 socket.
   (though npppd cannot set up a ipsec policy to the socket yet.)

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.11 2012/05/08 13:15:11 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.11 2012/05/08 13:15:11 yasuoka Exp $ */
d332 1
@


1.11
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tp_call.c,v 1.10 2012/01/23 03:41:21 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.10 2012/01/23 03:41:21 yasuoka Exp $ */
d415 1
a415 1
	    bytebuf, 1)) != 0) {
d795 1
a795 1
	    bytebuf, 1) != 0) {
d827 1
a827 1
	    bytebuf, 1);
@


1.10
log
@Add handling of `rx connect speed' avp to avoid the bug of xl2tpd.

Reported and tested by sebastia@@
ok sthen sebastia giovanni
@
text
@d1 1
a1 1
/* $OpenBSD: l2tp_call.c,v 1.9 2012/01/18 03:13:04 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.9 2012/01/18 03:13:04 yasuoka Exp $ */
d841 1
a841 1
#ifdef	L2TPD_MULITPLE
@


1.9
log
@Replace npppdctl(8) by new npppctl(8).  npppctl was written from
scratch, it uses parser.c derived from ikectl(8) to have OpenBSD's
fashion.  This includes related changes listed below:
- changed npppd control IPC heavyly.
- support IPv6 as tunnel source address.
- deleted support changing the configuration of npppd_ctl on running.
  Because it is not so needed but it requires privilege operations.
- refactors.

man page helps from jmc.  tested by sebastia.
ok deraadt sebastia sthen
@
text
@d1 1
a1 1
/* $OpenBSD: l2tp_call.c,v 1.8 2011/10/15 03:24:11 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.8 2011/10/15 03:24:11 yasuoka Exp $ */
d506 8
@


1.8
log
@Added "provision for rewound PPP frames" that allows receiving
reorder packets to pass to the upper layer without reorder.  It
will improve performance (throughput or loss rate) for PPTP or
L2TP(/IPesc) on networks that latency is unstable such as mobile
network.

As our test environment (bandwidth: 6Mbps, latency: 50ms for 97% of
traffic and 52ms for rest of traffic), throughput has changed from
0.76MB to 2.17MB on file upload by PPTP connected Windows Vista
ftp.exe.

Developed by UMEZAWA Takeshi at IIJ.

ok jmatthew@@
tested jmatthew@@ and myself.
@
text
@d1 1
a1 1
/* $OpenBSD: l2tp_call.c,v 1.7 2011/01/20 23:12:33 jasper Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.7 2011/01/20 23:12:33 jasper Exp $ */
d999 3
a1001 2
	memcpy(&ppp->phy_info.peer_in, &_this->ctrl->peer,
	    _this->ctrl->peer.ss_len);
@


1.7
log
@- tyop, recieve -> receive

ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: l2tp_call.c,v 1.6 2010/09/24 14:50:30 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.6 2010/09/24 14:50:30 yasuoka Exp $ */
d863 1
a863 1
l2tp_call_ppp_input(l2tp_call *_this, u_char *pkt, int pktlen)
d869 2
a870 1
	rval = ppp->recv_packet(ppp, pkt, pktlen, 0);
@


1.6
log
@Add support pipex for L2TP call and L2TP on IPv6.
- pipex requires unique session-id in protocol, so session-id
  generation algorithm has been changed.
- change to fit the new PIPEX ioctl.
ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: l2tp_call.c,v 1.5 2010/07/02 21:20:57 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.5 2010/07/02 21:20:57 yasuoka Exp $ */
d158 1
a158 1
/* call it when control packet is recieved */
@


1.5
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: l2tp_call.c,v 1.4 2010/07/01 03:38:17 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.4 2010/07/01 03:38:17 yasuoka Exp $ */
a78 3
/* l2tp_call ID sequence #  */
static unsigned l2tp_call_id_seq = 0;

d92 1
a92 1
void
d98 3
a100 1
	_this->id = l2tp_call_id_seq++;
d102 2
d110 1
@


1.4
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
a2 1
/*	$OpenBSD:$	*/
d28 1
a28 1
/* $Id: l2tp_call.c,v 1.3 2010/01/27 07:27:02 yasuoka Exp $ */
d115 1
a115 1
 *      2) npppd is terminated 
d280 1
a280 1
 */		
d355 1
a355 1
				L2TP_CALL_DBG((_this, LOG_DEBUG, 
d417 1
a417 1
	l2tp_call_log(_this, LOG_INFO, "SendICRP session_id=%u", 
d532 1
a532 1
			memcpy(dpi->auth_chall, avp->attr_value, 
d545 1
a545 1
			memcpy(dpi->auth_resp, avp->attr_value, 
d585 1
a585 1
				L2TP_CALL_DBG((_this, LOG_DEBUG, 
d685 1
a685 1
				L2TP_CALL_DBG((_this, LOG_DEBUG, 
d715 1
a715 1
l2tp_call_send_CDN(l2tp_call *_this, int result_code, int error_code, const 
d746 1
a746 1
 * Windows 2000 will return "2 - Length is wrong" in StopCCN, 
@


1.3
log
@Fixed 2 off-by-one problems.
(found by parfait, reported by jsg@@)
@
text
@d1 1
d27 2
a28 4
/* $Id: l2tp_call.c,v 1.2 2010/01/13 07:49:44 yasuoka Exp $ */
/**@@file
 * L2TP LNS のコールの実装。
 */
d42 1
a50 2
#ifndef	L2TPD_TEST
#include <net/if_dl.h>
a51 3
#else
typedef struct _dialin_proxy_info { } dialin_proxy_info;
#endif
d75 2
d78 1
a78 1
/** l2tp_call の ID番号のシーケンス番号 */
d81 1
a81 1
/** {@@link ::_l2tp_call L2TP コール} インスタンスを生成します。*/
d93 1
a93 1
/** {@@link ::_l2tp_call L2TP コール} インスタンスを初期化します。 */
d104 1
a104 1
/** このインスタンスを解放します。 */
d112 5
a116 5
 *  切断について
 *	a) npppdctl (vdipwho) から切断要求があった。
 *	   ppp_stop() で切断します。→ PPP LCP TermReq
 *	b) npppd が終了する、あるいは設定変更により l2tp.enabled = false
 *	   l2tp_call_disconnect() で切断します。→ L2TP CDN
d118 1
a118 1
/** 管理上の理由から切断します。 */
d126 3
a128 4
/**
 * 切断します。
 * @@param result_code	CDN を送信せずに切断(解放)する場合には、0 を指定
 * します。
d137 2
a138 2
		// 既に CDN を受信、または送信済み
		l2tp_call_notify_down(_this);	// ねんのため
d151 5
a155 4
/************************************************************************
 * 制御パケットの送受信
 ************************************************************************/
/** 制御パケットが入力された時に呼び出します。 */
d164 1
a164 1
	// ICRQ の時だけ、_this == NULL
d184 1
a184 1
		/* セッションIDの割り当て */
d197 1
a197 1
		/* この l2tp_call をリストに追加。 */
d206 1
a206 1
	/* ステートマシン */
d225 1
a225 1
			// FALL THROUGH
d242 1
a242 3
			/*
			 * peer からの切断。ログに残す
			 */
d274 6
a279 6
/**
 * ICRQ受信
 * @@return	acceptable な ICRQ の場合には、0 を返します。
 *		失敗した場合には、0 以外を返し、CDN は送信済みで、ステータス
 *		も変更済みです。
 */
d324 4
a327 3
			 * Windows 98/Me/NT の MS "L2TP/IPsec VPN Client"
			 * では Physical Channel Id は mandatory ビットがたって
			 * いる。
a336 1
			// 使い途あれば。
d382 1
a382 1
/** ICRP 送信 */
d421 1
a421 1
/** L2TP data messageを送信します。*/
d430 1
a430 1
	memset(hdr, 0, sizeof(*hdr) - 4);	/* Nr, Ns はオプション */
d459 5
a463 4
/**
 * ICCN 受信
 * @@return acceptable な ICCN の場合には、0 を返します。失敗した場合には、0
 *	以外を返し、CDN は送信済みで、ステータスも変更済みです。
d607 1
a607 1
/** CDN 受信 */
d615 1
a615 1
	/* 初期化 */
d706 1
a706 1
	// CDN のメッセージがおかしくても、続行
d712 1
a712 1
/** CDN 送信 */
d744 4
a747 2
 * エラーコード無しの長さ 8 の AVP を送信すると、Windows 2000 側が StopCCN で
 * "2 - Length is wrong" を返してくる。長さ10にして回避。
d803 1
a803 1
/** ZLB の送信 */
d819 4
a822 4
/************************************************************************
 * その他
 ************************************************************************/
/** このインスタンスに基づいたラベルから始まるログを記録します。 */
d841 1
a841 1
/** 現在のステータスの文字列表現を返します。 */
d854 3
d858 1
a858 26
#ifdef	L2TPD_TEST

void
l2tp_call_ppp_input(l2tp_call *_this, u_char *pkt, int pktlen)
{
}
static int
l2tp_call_bind_ppp(l2tp_call *_this, dialin_proxy_info *dpi)
{
	return 0;
}
static void
l2tp_call_notify_down(l2tp_call *_this)
{
}

#else
/************************************************************************
 * npppd の物理層として
 ************************************************************************/
#include "npppd.h"

static int   l2tp_call_ppp_output (npppd_ppp *, unsigned char *, int, int);
static void  l2tp_call_closed_by_ppp (npppd_ppp *);

/** ppp にパケットを入力します。 */
d879 1
a879 1
/** ppp からパケットが出力される時に呼び出されます。 */
d905 1
a905 1
/** ppp で切断された場合に呼び出されます。 */
d916 2
a917 1
	_this->ppp = NULL;	// l2tp_call_disconnect より先に。
d960 1
a960 1
/** ppp に切断した旨を通知し ppp の終了/解放を行います。 */
d968 1
a968 1
/** ppp の bind。 */
d979 1
a979 1
		goto reigai;
d1001 1
a1001 1
		goto reigai;
d1012 1
a1012 1
			goto reigai;
d1017 1
a1017 1
			goto reigai;
d1023 1
a1023 1
reigai:
a1030 1
#endif
@


1.2
log
@cleanup npppd code.  delete IIJ local ifdef switches and fix warnings.
ok @@dlg
@
text
@d26 1
a26 1
/* $Id: l2tp_call.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $ */
d662 1
a662 1
					len = MIN(len, sizeof(pmes));
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d26 1
a26 1
/* $Id: l2tp_call.c 37877 2009-11-09 05:01:11Z yasuoka $ */
a1015 10
#ifdef IDGW_DIALIN
	if (DIALIN_PROXY_IS_REQUESTED(dpi)) {
		strlcpy(ppp->phy_label, L2TPD_DIALIN_LAYER2_LABEL,
		    sizeof(ppp->phy_label));
		ppp->phy_info.peer_pn.pn_len =  sizeof(npppd_phone_number);
		ppp->phy_info.peer_pn.pn_family = NPPPD_AF_PHONE_NUMBER;
		strlcpy(ppp->phy_info.peer_pn.pn_number, _this->calling_number,
		    sizeof(ppp->phy_info.peer_pn.pn_number));
	} else {
#endif
a1019 3
#ifdef IDGW_DIALIN
	}
#endif
@

