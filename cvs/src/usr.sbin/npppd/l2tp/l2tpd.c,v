head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.8
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.6
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2016.03.21.00.49.36;	author guenther;	state Exp;
branches;
next	1.18;
commitid	MSxcUg12B9iLaLLL;

1.18
date	2015.12.17.08.09.20;	author tb;	state Exp;
branches;
next	1.17;
commitid	MrOakYvPdtmxCs1T;

1.17
date	2015.12.05.18.43.36;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	z4uV9iYMuGOvIKaj;

1.16
date	2015.06.23.06.59.54;	author yasuoka;	state Exp;
branches;
next	1.15;
commitid	KW9hHW3D8d8LyHVv;

1.15
date	2014.05.07.01.16.15;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2014.03.22.04.32.39;	author yasuoka;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.20.23.32.32;	author yasuoka;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.20.07.00.19;	author yasuoka;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches;
next	1.10;

1.10
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2012.05.08.13.18.37;	author yasuoka;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.08.13.15.11;	author yasuoka;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.18.02.53.56;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2011.03.16.09.49.11;	author okan;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.24.14.50.30;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.07.49.44;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Instead of creating a socket with socket() or accept() and then
setting the O_NONBLOCK flag on it with fcntl(F_SETFL) afterwards,
just pass SOCK_NONBLOCK to socket() or accept4() and get it right
to begin with.

ok millert@@ krw@@ beck@@ deraadt@@ jca@@
@
text
@/*	$OpenBSD: l2tpd.c,v 1.18 2015/12/17 08:09:20 tb Exp $ */

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/**@@file L2TP(Layer Two Tunneling Protocol "L2TP") / RFC2661 */
/* $Id: l2tpd.c,v 1.18 2015/12/17 08:09:20 tb Exp $ */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <unistd.h>
#include <netdb.h>
#include <syslog.h>
#include <signal.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <stdarg.h>
#include <event.h>

#ifdef USE_LIBSOCKUTIL
#include <seil/sockfromto.h>
#else
#include "recvfromto.h"
#endif

#include "bytebuf.h"
#include "hash.h"
#include "slist.h"
#include "debugutil.h"
#include "l2tp.h"
#include "l2tp_subr.h"
#include "l2tp_local.h"
#include "addr_range.h"
#include "net_utils.h"

#ifdef	L2TPD_DEBUG
#define	L2TPD_ASSERT(x)	ASSERT(x)
#define	L2TPD_DBG(x)	l2tpd_log x
#else
#define	L2TPD_ASSERT(x)
#endif
#define L2TPD_IPSEC_POLICY_IN	"in ipsec esp/transport//require"
#define L2TPD_IPSEC_POLICY_OUT	"out ipsec esp/transport//require"

static void             l2tpd_io_event (int, short, void *);
static inline int       short_cmp (const void *, const void *);
static inline uint32_t  short_hash (const void *, int);

/* sequence # of l2tpd ID */
static u_int l2tpd_id_seq = 0;

/* L2TP daemon instance */

/**
 * initialize L2TP daemon instance
 * <p>
 * {@@link _l2tpd#bind_sin} will return with .sin_family = AF_INET,
 * .sin_port = 1701 and .sin_len = "appropriate value"
 * </p>
 */
int
l2tpd_init(l2tpd *_this)
{
	int i, off;
	u_int id;

	L2TPD_ASSERT(_this != NULL);
	memset(_this, 0, sizeof(l2tpd));

	slist_init(&_this->listener);
	slist_init(&_this->free_session_id_list);

	_this->id = l2tpd_id_seq++;

	if ((_this->ctrl_map = hash_create(short_cmp, short_hash,
	    L2TPD_TUNNEL_HASH_SIZ)) == NULL) {
		log_printf(LOG_ERR, "hash_create() failed in %s(): %m",
		    __func__);
		return 1;
	}

	if (slist_add(&_this->free_session_id_list,
	    (void *)L2TP_SESSION_ID_SHUFFLE_MARK) == NULL) {
		l2tpd_log(_this, LOG_ERR, "slist_add() failed on %s(): %m",
		    __func__);
		return 1;
	}
	off = arc4random() & L2TP_SESSION_ID_MASK;
	for (i = 0; i < L2TP_NCALL; i++) {
		id = (i + off) & L2TP_SESSION_ID_MASK;
		if (id == 0)
			id = (off - 1) & L2TP_SESSION_ID_MASK;
		if (slist_add(&_this->free_session_id_list,
		    (void *)(uintptr_t)id) == NULL) {
			l2tpd_log(_this, LOG_ERR,
			    "slist_add() failed on %s(): %m", __func__);
			return 1;
		}
	}
	_this->purge_ipsec_sa = 1;
	_this->state = L2TPD_STATE_INIT;

	return 0;
}

/*
 * Add a {@@link :l2tpd_listener} to the {@@link ::l2tpd L2TP daemon}
 * @@param	_this	{@@link ::l2tpd L2TP daemon}
 * @@param	idx	index of the lisnter
 * @@param	tun_name	tunnel name (ex. "L2TP")
 * @@param	bindaddr	bind address
 */
int
l2tpd_add_listener(l2tpd *_this, int idx, struct l2tp_conf *conf,
    struct sockaddr *addr)
{
	l2tpd_listener *plistener, *plsnr;

	plistener = NULL;
	if (idx == 0 && slist_length(&_this->listener) > 0) {
		slist_itr_first(&_this->listener);
		while (slist_itr_has_next(&_this->listener)) {
			slist_itr_next(&_this->listener);
			plsnr = slist_itr_remove(&_this->listener);
			L2TPD_ASSERT(plsnr != NULL);
			L2TPD_ASSERT(plsnr->sock == -1);
			free(plsnr);
		}
	}
	L2TPD_ASSERT(slist_length(&_this->listener) == idx);
	if (slist_length(&_this->listener) != idx) {
		l2tpd_log(_this, LOG_ERR,
		    "Invalid argument error on %s(): idx must be %d but %d",
		    __func__, slist_length(&_this->listener), idx);
		goto fail;
	}
	if ((plistener = calloc(1, sizeof(l2tpd_listener))) == NULL) {
		l2tpd_log(_this, LOG_ERR, "calloc() failed in %s: %m",
		    __func__);
		goto fail;
	}
	L2TPD_ASSERT(sizeof(plistener->bind) >= addr->sa_len);
	memcpy(&plistener->bind, addr, addr->sa_len);

	if (plistener->bind.sin6.sin6_port == 0)
		plistener->bind.sin6.sin6_port = htons(L2TPD_DEFAULT_UDP_PORT);

	plistener->sock = -1;
	plistener->self = _this;
	plistener->index = idx;
	plistener->conf = conf;
	strlcpy(plistener->tun_name, conf->name, sizeof(plistener->tun_name));

	if (slist_add(&_this->listener, plistener) == NULL) {
		l2tpd_log(_this, LOG_ERR, "slist_add() failed in %s: %m",
		    __func__);
		goto fail;
	}
	return 0;
fail:
	free(plistener);
	return 1;
}

/* finalize L2TP daemon instance */
void
l2tpd_uninit(l2tpd *_this)
{
	l2tpd_listener *plsnr;

	L2TPD_ASSERT(_this != NULL);

	slist_fini(&_this->free_session_id_list);
	if (_this->ctrl_map != NULL) {
		hash_free(_this->ctrl_map);
		_this->ctrl_map = NULL;
	}

	slist_itr_first(&_this->listener);
	while (slist_itr_has_next(&_this->listener)) {
		plsnr = slist_itr_next(&_this->listener);
		L2TPD_ASSERT(plsnr != NULL);
		L2TPD_ASSERT(plsnr->sock == -1);
		free(plsnr);
	}
	slist_fini(&_this->listener);

	event_del(&_this->ev_timeout);	/* just in case */
	_this->state = L2TPD_STATE_STOPPED;
}

/** assign the call to the l2tpd */
int
l2tpd_assign_call(l2tpd *_this, l2tp_call *call)
{
	int    shuffle_cnt;
	u_int  session_id;

	shuffle_cnt = 0;
	do {
		session_id = (uintptr_t)slist_remove_first(
		    &_this->free_session_id_list);
		if (session_id != L2TP_SESSION_ID_SHUFFLE_MARK)
			break;
		L2TPD_ASSERT(shuffle_cnt == 0);
		if (shuffle_cnt++ > 0) {
			l2tpd_log(_this, LOG_ERR,
			    "unexpected errror in %s(): free_session_id_list "
			    "full", __func__);
			slist_add(&_this->free_session_id_list,
			    (void *)L2TP_SESSION_ID_SHUFFLE_MARK);
			return 1;
		}
		slist_shuffle(&_this->free_session_id_list);
		slist_add(&_this->free_session_id_list,
		    (void *)L2TP_SESSION_ID_SHUFFLE_MARK);
	} while (1);
	call->id = session_id;

	return 0;
}

/* this function will be called when the call is released */
void
l2tpd_release_call(l2tpd *_this, l2tp_call *call)
{
	slist_add(&_this->free_session_id_list, (void *)(uintptr_t)call->id);
}

/* start l2tpd listner */
static int
l2tpd_listener_start(l2tpd_listener *_this)
{
	l2tpd *_l2tpd;
	int    af, lvl, opt, sock, ival;
	char   hbuf[NI_MAXHOST + NI_MAXSERV + 16];

	_l2tpd = _this->self;
	sock = -1;
	af = _this->bind.sin6.sin6_family;
	lvl = (af == AF_INET)? IPPROTO_IP : IPPROTO_IPV6;

	if (_this->tun_name[0] == '\0')
		strlcpy(_this->tun_name, L2TPD_DEFAULT_LAYER2_LABEL,
		    sizeof(_this->tun_name));
	if ((sock = socket(_this->bind.sin6.sin6_family,
	    SOCK_DGRAM | SOCK_NONBLOCK, IPPROTO_UDP)) < 0) {
		l2tpd_log(_l2tpd, LOG_ERR,
		    "socket() failed in %s(): %m", __func__);
		goto fail;
	}
#if defined(IP_STRICT_RCVIF) && defined(USE_STRICT_RCVIF)
	ival = 1;
	if (setsockopt(sock, IPPROTO_IP, IP_STRICT_RCVIF, &ival, sizeof(ival))
	    != 0)
		l2tpd_log(_l2tpd, LOG_WARNING,
		    "%s(): setsockopt(IP_STRICT_RCVIF) failed: %m", __func__);
#endif
	ival = 1;
	if (setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &ival, sizeof(ival))
	    != 0) {
		l2tpd_log(_l2tpd, LOG_ERR,
		    "setsockopt(,,SO_REUSEPORT) failed in %s(): %m", __func__);
		goto fail;
	}
	if (bind(sock, (struct sockaddr *)&_this->bind,
	    _this->bind.sin6.sin6_len) != 0) {
		l2tpd_log(_l2tpd, LOG_ERR, "Binding %s/udp: %m",
		    addrport_tostring((struct sockaddr *)&_this->bind,
		    _this->bind.sin6.sin6_len, hbuf, sizeof(hbuf)));
		goto fail;
	}
#ifdef USE_LIBSOCKUTIL
	if (setsockoptfromto(sock) != 0) {
		l2tpd_log(_l2tpd, LOG_ERR,
		    "setsockoptfromto() failed in %s(): %m", __func__);
		goto fail;
	}
#else
	opt = (af == AF_INET)? IP_RECVDSTADDR : IPV6_RECVPKTINFO;
	ival = 1;
	if (setsockopt(sock, lvl, opt, &ival, sizeof(ival)) != 0) {
		l2tpd_log(_l2tpd, LOG_ERR,
		    "setsockopt(,,IP{,V6}_RECVDSTADDR) failed in %s(): %m",
		    __func__);
		goto fail;
	}
#endif
#ifdef USE_SA_COOKIE
	if (af == AF_INET) {
		ival = 1;
		if (setsockopt(sock, IPPROTO_IP, IP_IPSECFLOWINFO, &ival,
		    sizeof(ival)) != 0) {
			l2tpd_log(_l2tpd, LOG_ERR,
			    "setsockopt(,,IP_IPSECFLOWINFO) failed in %s(): %m",
			    __func__);
			goto fail;
		}
	}
#endif
#ifdef IP_PIPEX
	opt = (af == AF_INET)? IP_PIPEX : IPV6_PIPEX;
	ival = 1;
	if (setsockopt(sock, lvl, opt, &ival, sizeof(ival)) != 0)
		l2tpd_log(_l2tpd, LOG_WARNING,
		    "%s(): setsockopt(IP{,V6}_PIPEX) failed: %m", __func__);
#endif
	if (_this->conf->require_ipsec) {
#ifdef IP_IPSEC_POLICY
		caddr_t  ipsec_policy_in, ipsec_policy_out;

		opt = (af == AF_INET)? IP_IPSEC_POLICY : IPV6_IPSEC_POLICY;
		/*
		 * Note: ipsec_set_policy() will assign the buffer for
		 * yacc parser stack, however it never free.
		 * it cause memory leak (-2000byte).
		 */
		if ((ipsec_policy_in = ipsec_set_policy(L2TPD_IPSEC_POLICY_IN,
		    strlen(L2TPD_IPSEC_POLICY_IN))) == NULL) {
			l2tpd_log(_l2tpd, LOG_ERR,
			    "ipsec_set_policy(L2TPD_IPSEC_POLICY_IN) failed "
			    "at %s(): %s: %m", __func__, ipsec_strerror());
		} else if (setsockopt(sock, lvl, opt, ipsec_policy_in,
		    ipsec_get_policylen(ipsec_policy_in)) < 0) {
			l2tpd_log(_l2tpd, LOG_WARNING,
			    "setsockopt(,,IP_IPSEC_POLICY(in)) failed "
			    "in %s(): %m", __func__);
		}
		if ((ipsec_policy_out = ipsec_set_policy(L2TPD_IPSEC_POLICY_OUT,
		    strlen(L2TPD_IPSEC_POLICY_OUT))) == NULL) {
			l2tpd_log(_l2tpd, LOG_ERR,
			    "ipsec_set_policy(L2TPD_IPSEC_POLICY_OUT) failed "
			    "at %s(): %s: %m", __func__, ipsec_strerror());
		}
		if (ipsec_policy_out != NULL &&
		    setsockopt(sock, lvl, opt, ipsec_policy_out,
		    ipsec_get_policylen(ipsec_policy_out)) < 0) {
			l2tpd_log(_l2tpd, LOG_WARNING,
			    "setsockopt(,,IP_IPSEC_POLICY(out)) failed "
			    "in %s(): %m", __func__);
		}
		free(ipsec_policy_in);
		free(ipsec_policy_out);
#elif defined(IP_ESP_TRANS_LEVEL)
		opt = (af == AF_INET)
		    ? IP_ESP_TRANS_LEVEL : IPV6_ESP_TRANS_LEVEL;
		ival = IPSEC_LEVEL_REQUIRE;
		if (setsockopt(sock, lvl, opt, &ival, sizeof(ival)) != 0) {
			l2tpd_log(_l2tpd, LOG_WARNING,
			    "setsockopt(,,IP{,V6}_ESP_TRANS_LEVEL(out)) failed "
			    "in %s(): %m", __func__);
		}
#else
#error IP_IPSEC_POLICY or IP_ESP_TRANS_LEVEL must be usable.
#endif
	}

	_this->sock = sock;

	event_set(&_this->ev_sock, _this->sock, EV_READ | EV_PERSIST,
	    l2tpd_io_event, _this);
	event_add(&_this->ev_sock, NULL);

	l2tpd_log(_l2tpd, LOG_INFO, "Listening %s/udp (L2TP LNS) [%s]",
	    addrport_tostring((struct sockaddr *)&_this->bind,
	    _this->bind.sin6.sin6_len, hbuf, sizeof(hbuf)), _this->tun_name);

	return 0;
fail:
	if (sock >= 0)
		close(sock);

	return 1;
}

/* start L2TP daemon */
int
l2tpd_start(l2tpd *_this)
{
	int rval;
	l2tpd_listener *plsnr;

	rval = 0;

	L2TPD_ASSERT(_this->state == L2TPD_STATE_INIT);
	if (_this->state != L2TPD_STATE_INIT) {
		l2tpd_log(_this, LOG_ERR, "Failed to start l2tpd: illegal "
		    "state.");
		return -1;
	}

	slist_itr_first(&_this->listener);
	while (slist_itr_has_next(&_this->listener)) {
		plsnr = slist_itr_next(&_this->listener);
		rval |= l2tpd_listener_start(plsnr);
	}

	if (rval == 0)
		_this->state = L2TPD_STATE_RUNNING;

	return rval;
}

/* stop l2tp lisnter */
static void
l2tpd_listener_stop(l2tpd_listener *_this)
{
	char hbuf[NI_MAXHOST + NI_MAXSERV + 16];

	if (_this->sock >= 0) {
		event_del(&_this->ev_sock);
		close(_this->sock);
		l2tpd_log(_this->self, LOG_INFO,
		    "Shutdown %s/udp (L2TP LNS)",
		    addrport_tostring((struct sockaddr *)&_this->bind,
		    _this->bind.sin6.sin6_len, hbuf, sizeof(hbuf)));
		_this->sock = -1;
	}
}

/* stop immediattly without disconnect operation */
void
l2tpd_stop_immediatly(l2tpd *_this)
{
	l2tpd_listener *plsnr;

	slist_itr_first(&_this->listener);
	while (slist_itr_has_next(&_this->listener)) {
		plsnr = slist_itr_next(&_this->listener);
		l2tpd_listener_stop(plsnr);
	}
	event_del(&_this->ev_timeout);	/* XXX */
	_this->state = L2TPD_STATE_STOPPED;
}

/*
 * this function will be called when {@@link ::_l2tp_ctrl control}
 * is terminated.
 */
void
l2tpd_ctrl_finished_notify(l2tpd *_this)
{
	if (_this->state != L2TPD_STATE_SHUTTING_DOWN)
		return;

	if (hash_first(_this->ctrl_map) != NULL)
		return;

	l2tpd_stop_immediatly(_this);
}

static void
l2tpd_stop_timeout(int fd, short evtype, void *ctx)
{
	hash_link *hl;
	l2tp_ctrl *ctrl;
	l2tpd *_this;

	_this = ctx;
	l2tpd_log(_this, LOG_INFO, "Shutdown timeout");
	for (hl = hash_first(_this->ctrl_map); hl != NULL;
	    hl = hash_next(_this->ctrl_map)) {
		ctrl = hl->item;
		l2tp_ctrl_stop(ctrl, 0);
	}
	l2tpd_stop_immediatly(_this);
}

/* stop L2TP daemon */
void
l2tpd_stop(l2tpd *_this)
{
	int nctrls = 0;
	hash_link *hl;
	l2tp_ctrl *ctrl;

	nctrls = 0;
	event_del(&_this->ev_timeout);
	if (l2tpd_is_stopped(_this))
		return;
	if (l2tpd_is_shutting_down(_this)) {
		/* terminate immediately, when 2nd call */
		l2tpd_stop_immediatly(_this);
		return;
	}
	for (hl = hash_first(_this->ctrl_map); hl != NULL;
	    hl = hash_next(_this->ctrl_map)) {
		ctrl = hl->item;
		l2tp_ctrl_stop(ctrl, L2TP_STOP_CCN_RCODE_SHUTTING_DOWN);
		nctrls++;
	}
	_this->state = L2TPD_STATE_SHUTTING_DOWN;
	if (nctrls > 0) {
		struct timeval tv0;

		tv0.tv_usec = 0;
		tv0.tv_sec = L2TPD_SHUTDOWN_TIMEOUT;

		evtimer_set(&_this->ev_timeout, l2tpd_stop_timeout, _this);
		evtimer_add(&_this->ev_timeout, &tv0);

		return;
	}
	l2tpd_stop_immediatly(_this);
}

/*
 * Configuration
 */
int
l2tpd_reload(l2tpd *_this, struct l2tp_confs *l2tp_conf)
{
	int			 i;
	struct l2tp_conf	*conf;
	l2tpd_listener		*listener;
	struct l2tp_listen_addr	*addr;

	if (slist_length(&_this->listener) > 0) {
		/*
		 * TODO: add / remove / restart listener.
		 */
		slist_itr_first(&_this->listener);
		while (slist_itr_has_next(&_this->listener)) {
			listener = slist_itr_next(&_this->listener);
			TAILQ_FOREACH(conf, l2tp_conf, entry) {
				if (strcmp(listener->tun_name,
				    conf->name) == 0) {
					listener->conf = conf;
					break;
				}
			}
		}

		return 0;
	}

	i = 0;
	TAILQ_FOREACH(conf, l2tp_conf, entry) {
		TAILQ_FOREACH(addr, &conf->listen, entry)
			l2tpd_add_listener(_this, i++, conf, 
			    (struct sockaddr *)&addr->addr);
	}
	if (l2tpd_start(_this) != 0)
		return -1;

	return 0;
}

/*
 * I/O functions
 */
/* logging when deny an access */
void
l2tpd_log_access_deny(l2tpd *_this, const char *reason, struct sockaddr *peer)
{
	char buf[BUFSIZ];

	l2tpd_log(_this, LOG_ALERT, "Received packet from %s/udp: "
	    "%s", addrport_tostring(peer, peer->sa_len, buf, sizeof(buf)),
	    reason);
}

/* I/O event handler */
static void
l2tpd_io_event(int fd, short evtype, void *ctx)
{
	int sz;
	l2tpd *_l2tpd;
	l2tpd_listener *_this;
	socklen_t peerlen, socklen;
	struct sockaddr_storage peer, sock;
	u_char buf[8192];
	void *nat_t;

	_this = ctx;
	_l2tpd = _this->self;
	if ((evtype & EV_READ) != 0) {
		peerlen = sizeof(peer);
		socklen = sizeof(sock);
		while (!l2tpd_is_stopped(_l2tpd)) {
#if defined(USE_LIBSOCKUTIL) || defined(USE_SA_COOKIE)
			int sa_cookie_len;
			struct in_ipsec_sa_cookie sa_cookie;

			sa_cookie_len = sizeof(sa_cookie);
			if ((sz = recvfromto_nat_t(_this->sock, buf,
			    sizeof(buf), 0,
			    (struct sockaddr *)&peer, &peerlen,
			    (struct sockaddr *)&sock, &socklen,
			    &sa_cookie, &sa_cookie_len)) <= 0) {
#else
			if ((sz = recvfromto(_this->sock, buf,
			    sizeof(buf), 0,
			    (struct sockaddr *)&peer, &peerlen,
			    (struct sockaddr *)&sock, &socklen)) == -1) {
#endif
				if (errno == EAGAIN || errno == EINTR)
					break;
				l2tpd_log(_l2tpd, LOG_ERR,
				    "recvfrom() failed in %s(): %m",
				    __func__);
				l2tpd_stop(_l2tpd);
				return;
			}
			/* source address check (allows.in) */
			switch (peer.ss_family) {
			case AF_INET:
#if defined(USE_LIBSOCKUTIL) || defined(USE_SA_COOKIE)
				if (sa_cookie_len > 0)
					nat_t = &sa_cookie;
				else
					nat_t = NULL;
#else
				nat_t = NULL;
#endif
				l2tp_ctrl_input(_l2tpd, _this->index,
				    (struct sockaddr *)&peer,
				    (struct sockaddr *)&sock, nat_t,
				    buf, sz);
				break;
			case AF_INET6:
				l2tp_ctrl_input(_l2tpd, _this->index,
				    (struct sockaddr *)&peer,
				    (struct sockaddr *)&sock, NULL,
				    buf, sz);
				break;
			default:
				l2tpd_log(_l2tpd, LOG_ERR,
				    "received from unknown address family = %d",
				    peer.ss_family);
				break;
			}
		}
	}
}

/*
 * L2TP control
 */
l2tp_ctrl *
l2tpd_get_ctrl(l2tpd *_this, unsigned tunid)
{
	hash_link *hl;

	hl = hash_lookup(_this->ctrl_map, (void *)(uintptr_t)tunid);
	if (hl == NULL)
		return NULL;

	return hl->item;
}

void
l2tpd_add_ctrl(l2tpd *_this, l2tp_ctrl *ctrl)
{
	hash_insert(_this->ctrl_map, (void *)(uintptr_t)ctrl->tunnel_id, ctrl);
}

void
l2tpd_remove_ctrl(l2tpd *_this, unsigned tunid)
{
	hash_delete(_this->ctrl_map, (void *)(uintptr_t)tunid, 0);
}


/*
 * misc
 */

void
l2tpd_log(l2tpd *_this, int prio, const char *fmt, ...)
{
	char logbuf[BUFSIZ];
	va_list ap;

	va_start(ap, fmt);
#ifdef	L2TPD_MULTIPLE
	snprintf(logbuf, sizeof(logbuf), "l2tpd id=%u %s", _this->id, fmt);
#else
	snprintf(logbuf, sizeof(logbuf), "l2tpd %s", fmt);
#endif
	vlog_printf(prio, logbuf, ap);
	va_end(ap);
}
@


1.18
log
@Replace 'arc4random() % (2^k - 1)' by 'arc4random() & (2^k - 1)' to
avoid modulo bias.  Part of a diff by Matthew Martin, reviewed by
deraadt@@ and me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.17 2015/12/05 18:43:36 mmcc Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.17 2015/12/05 18:43:36 mmcc Exp $ */
d275 1
a275 1
	    SOCK_DGRAM, IPPROTO_UDP)) < 0) {
a286 9
	if ((ival = fcntl(sock, F_GETFL, 0)) < 0) {
		l2tpd_log(_l2tpd, LOG_ERR,
		    "fcntl(,F_GETFL) failed in %s(): %m", __func__);
		goto fail;
	} else if (fcntl(sock, F_SETFL, ival | O_NONBLOCK) < 0) {
		l2tpd_log(_l2tpd, LOG_ERR, "fcntl(,F_SETFL,O_NONBLOCK) failed "
		    "in %s(): %m", __func__);
		goto fail;
	}
@


1.17
log
@strings.h -> string.h to prevent an implicit declaration. Also remove a
bunch of NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.16 2015/06/23 06:59:54 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.16 2015/06/23 06:59:54 yasuoka Exp $ */
d116 1
a116 1
	off = arc4random() % L2TP_SESSION_ID_MASK;
d118 1
a118 1
		id = (i + off) % L2TP_SESSION_ID_MASK;
d120 1
a120 1
			id = (off - 1) % L2TP_SESSION_ID_MASK;
@


1.16
log
@Fix the problem when npppd receives a zero length 1701/udp packet.  If
it receives such packets when the errno is not EAGAIN or EINTR, it had
closed all L2TP sessions and stoppped the L2TP server.  Also fix the
receiving GRE packet since it potentially has the same problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.15 2014/05/07 01:16:15 tedu Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.15 2014/05/07 01:16:15 tedu Exp $ */
d189 1
a189 2
	if (plistener != NULL)
		free(plistener);
d379 2
a380 4
		if (ipsec_policy_in != NULL)
			free(ipsec_policy_in);
		if (ipsec_policy_out != NULL)
			free(ipsec_policy_out);
@


1.15
log
@use calloc. from Peter Malone
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.14 2014/03/22 04:32:39 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.14 2014/03/22 04:32:39 yasuoka Exp $ */
d635 1
a635 1
			    (struct sockaddr *)&sock, &socklen)) <= 0) {
@


1.14
log
@Now tunnel can have multiple listen addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.13 2013/04/20 23:32:32 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.13 2013/04/20 23:32:32 yasuoka Exp $ */
d165 2
a166 2
	if ((plistener = malloc(sizeof(l2tpd_listener))) == NULL) {
		l2tpd_log(_this, LOG_ERR, "malloc() failed in %s: %m",
a169 1
	memset(plistener, 0, sizeof(l2tpd_listener));
@


1.13
log
@Don't use random() because it's not safe.  Use arc4random() instead of
it.  Suggested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.12 2013/04/20 07:00:19 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.12 2013/04/20 07:00:19 yasuoka Exp $ */
d142 2
a143 1
l2tpd_add_listener(l2tpd *_this, int idx, struct l2tp_conf *conf)
d171 2
a172 2
	L2TPD_ASSERT(sizeof(plistener->bind) >= conf->address.ss_len);
	memcpy(&plistener->bind, &conf->address, conf->address.ss_len);
d554 4
a557 3
	int               i;
	struct l2tp_conf *conf;
	l2tpd_listener   *listener;
d579 5
a583 2
	TAILQ_FOREACH(conf, l2tp_conf, entry)
		l2tpd_add_listener(_this, i++, conf);
@


1.12
log
@PPPoE server was broken since last configuration rework.  Calling
pppoed_init() was accidentally deleted. Revert it in npppd_init() and
rearrange l2tpd_init() and pptpd_init() to the same place.

ok todd
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.11 2012/09/18 13:14:08 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.11 2012/09/18 13:14:08 yasuoka Exp $ */
d116 1
a116 1
	off = random() % L2TP_SESSION_ID_MASK;
@


1.11
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.10 2012/07/16 18:05:36 markus Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.10 2012/07/16 18:05:36 markus Exp $ */
a575 2
	if (l2tpd_init(_this) != 0)
		return -1;
@


1.10
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.9 2012/05/08 13:18:37 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.9 2012/05/08 13:18:37 yasuoka Exp $ */
a34 3
#if 0
#include <netinet6/ipsec.h>
#endif
a61 2
#include "properties.h"
#include "config_helper.h"
a93 2
	struct sockaddr_in sin4;
	struct sockaddr_in6 sin6;
a100 14
	memset(&sin4, 0, sizeof(sin4));
	sin4.sin_len = sizeof(sin4);
	sin4.sin_family = AF_INET;
	if (l2tpd_add_listener(_this, 0, L2TPD_DEFAULT_LAYER2_LABEL,
	    (struct sockaddr *)&sin4) != 0) {
		return 1;
	}
	memset(&sin6, 0, sizeof(sin6));
	sin6.sin6_len = sizeof(sin6);
	sin6.sin6_family = AF_INET6;
	if (l2tpd_add_listener(_this, 1, L2TPD_DEFAULT_LAYER2_LABEL,
	    (struct sockaddr *)&sin6) != 0) {
		return 1;
	}
a127 3
	_this->ip4_allow = NULL;

	_this->require_ipsec = 1;
d138 1
a138 1
 * @@param	label	physical layer label (ex. "L2TP")
d142 1
a142 2
l2tpd_add_listener(l2tpd *_this, int idx, const char *label,
    struct sockaddr *bindaddr)
d170 2
a171 2
	L2TPD_ASSERT(sizeof(plistener->bind) >= bindaddr->sa_len);
	memcpy(&plistener->bind, bindaddr, bindaddr->sa_len);
d179 2
a180 1
	strlcpy(plistener->phy_label, label, sizeof(plistener->phy_label));
a207 3
	if (_this->ip4_allow != NULL)
		in_addr_range_list_remove_all(&_this->ip4_allow);

a218 1
	_this->config = NULL;
a258 1

d261 1
a261 2
l2tpd_listener_start(l2tpd_listener *_this, char *ipsec_policy_in,
    char *ipsec_policy_out)
a262 1
	int sock, ival;
d264 4
a267 1
	char hbuf[NI_MAXHOST + NI_MAXSERV + 16];
d269 2
a270 1
	_l2tpd = _this->self;
d272 3
a274 3
	if (_this->phy_label[0] == '\0')
		strlcpy(_this->phy_label, L2TPD_DEFAULT_LAYER2_LABEL,
		    sizeof(_this->phy_label));
d318 9
a326 9
	if (_this->bind.sin6.sin6_family == AF_INET) {
		ival = 1;
		if (setsockopt(sock, IPPROTO_IP, IP_RECVDSTADDR, &ival,
		    sizeof(ival)) != 0) {
			l2tpd_log(_l2tpd, LOG_ERR,
			    "setsockopt(,,IP_RECVDSTADDR) failed in %s(): %m",
			    __func__);
			goto fail;
		}
d328 1
a336 10
#endif
	} else {
		ival = 1;
                if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &ival,
		    sizeof(ival)) != 0) {
			l2tpd_log(_l2tpd, LOG_ERR,
			    "setsockopt(,,IPV6_PKTINFO) failed in %s(): %m",
			    __func__);
			goto fail;
		}
a338 1
	if (_this->bind.sin6.sin6_family == AF_INET) {
d340 5
a344 5
		ival = 1;
		if (setsockopt(sock, IPPROTO_IP, IP_PIPEX, &ival,
		    sizeof(ival)) != 0)
			l2tpd_log(_l2tpd, LOG_WARNING,
			    "%s(): setsockopt(IP_PIPEX) failed: %m", __func__);
d346 1
d348 15
a362 4
		if (ipsec_policy_in != NULL &&
		    setsockopt(sock, IPPROTO_IP, IP_IPSEC_POLICY,
		    ipsec_policy_in, ipsec_get_policylen(ipsec_policy_in))
		    < 0) {
d367 6
d374 2
a375 3
		    setsockopt(sock, IPPROTO_IP, IP_IPSEC_POLICY,
		    ipsec_policy_out, ipsec_get_policylen(ipsec_policy_out))
		    < 0) {
d380 9
a388 6
#endif
	} else {
#ifdef IPV6_PIPEX
		ival = 1;
		if (setsockopt(sock, IPPROTO_IPV6, IPV6_PIPEX, &ival,
		    sizeof(ival)) != 0)
d390 1
a390 18
			    "%s(): setsockopt(IPV6_PIPEX) failed: %m",
			    __func__);
#endif
#ifdef IPV6_IPSEC_POLICY
		if (ipsec_policy_in != NULL &&
		    setsockopt(sock, IPPROTO_IPV6, IPV6_IPSEC_POLICY,
		    ipsec_policy_in, ipsec_get_policylen(ipsec_policy_in))
		    < 0) {
			l2tpd_log(_l2tpd, LOG_WARNING,
			    "setsockopt(,,IPV6_IPSEC_POLICY(in)) failed "
			    "in %s(): %m", __func__);
		}
		if (ipsec_policy_out != NULL &&
		    setsockopt(sock, IPPROTO_IPV6, IPV6_IPSEC_POLICY,
		    ipsec_policy_out, ipsec_get_policylen(ipsec_policy_out))
		    < 0) {
			l2tpd_log(_l2tpd, LOG_WARNING,
			    "setsockopt(,,IPV6_IPSEC_POLICY(out)) failed "
d393 2
d397 1
d406 1
a406 1
	    _this->bind.sin6.sin6_len, hbuf, sizeof(hbuf)), _this->phy_label);
a420 1
	caddr_t ipsec_policy_in, ipsec_policy_out;
a423 2
	ipsec_policy_in = NULL;
	ipsec_policy_out = NULL;
a430 23
	if (_this->require_ipsec != 0) {
#if 0
		/*
		 * Note: ipsec_set_policy() will assign the buffer for
		 * yacc parser stack, however it never free.
		 * it cause memory leak (-2000byte).
		 */
		if ((ipsec_policy_in = ipsec_set_policy(L2TPD_IPSEC_POLICY_IN,
		    strlen(L2TPD_IPSEC_POLICY_IN))) == NULL) {
			l2tpd_log(_this, LOG_ERR,
			    "ipsec_set_policy(L2TPD_IPSEC_POLICY_IN) failed "
			    "at %s(): %s: %m", __func__, ipsec_strerror());
				goto fail;
		}
		if ((ipsec_policy_out = ipsec_set_policy(L2TPD_IPSEC_POLICY_OUT,
		    strlen(L2TPD_IPSEC_POLICY_OUT))) == NULL) {
			l2tpd_log(_this, LOG_ERR,
			    "ipsec_set_policy(L2TPD_IPSEC_POLICY_OUT) failed "
			    "at %s(): %s: %m", __func__, ipsec_strerror());
			goto fail;
		}
#endif
	}
d435 1
a435 2
		rval |= l2tpd_listener_start(plsnr, ipsec_policy_in,
		    ipsec_policy_out);
a437 5
	if (ipsec_policy_in != NULL)
		free(ipsec_policy_in);
	if (ipsec_policy_out != NULL)
		free(ipsec_policy_out);

a441 9
#if 0
fail:
#endif
	if (ipsec_policy_in != NULL)
		free(ipsec_policy_in);
	if (ipsec_policy_out != NULL)
		free(ipsec_policy_out);

	return 1;
a549 7
#define	CFG_KEY(p, s)	config_key_prefix((p), (s))
#define	VAL_SEP		" \t\r\n"

CONFIG_FUNCTIONS(l2tpd_config, l2tpd, config);
PREFIXED_CONFIG_FUNCTIONS(l2tp_ctrl_config, l2tp_ctrl, l2tpd->config,
    phy_label);

d551 1
a551 2
l2tpd_reload(l2tpd *_this, struct properties *config, const char *name,
    int default_enabled)
d553 3
a555 22
	int i, do_start, aierr;
	const char *val;
	char *tok, *cp, buf[L2TPD_CONFIG_BUFSIZ], *label;
	struct addrinfo *ai;

	_this->config = config;
	do_start = 0;
	if (l2tpd_config_str_equal(_this, CFG_KEY(name, "enabled"), "true",
	    default_enabled)) {
		/* care the case false-true flapping */
		if (l2tpd_is_shutting_down(_this))
			l2tpd_stop_immediatly(_this);
		if (l2tpd_is_stopped(_this))
			do_start = 1;
	} else {
		if (!l2tpd_is_stopped(_this))
			l2tpd_stop(_this);
		return 0;
	}
	if (do_start && l2tpd_init(_this) != 0)
		return 1;
	_this->config = config;
d557 11
a567 77
	/* default value */
	 gethostname(_this->default_hostname, sizeof(_this->default_hostname));

	_this->ctrl_in_pktdump = l2tpd_config_str_equal(_this,
	    "log.l2tp.ctrl.in.pktdump", "true", 0);
	_this->data_in_pktdump = l2tpd_config_str_equal(_this,
	    "log.l2tp.data.in.pktdump", "true", 0);
	_this->ctrl_out_pktdump = l2tpd_config_str_equal(_this,
	    "log.l2tp.ctrl.out.pktdump", "true", 0);
	_this->data_out_pktdump = l2tpd_config_str_equal(_this,
	    "log.l2tp.data.out.pktdump", "true", 0);
	_this->phy_label_with_ifname = l2tpd_config_str_equal(_this,
	    CFG_KEY(name, "label_with_ifname"), "true", 0);

	/* parse ip4_allow */
	in_addr_range_list_remove_all(&_this->ip4_allow);
	val = l2tpd_config_str(_this, CFG_KEY(name, "ip4_allow"));
	if (val != NULL) {
		if (strlen(val) >= sizeof(buf)) {
			l2tpd_log(_this, LOG_ERR, "configuration error at "
			    "l2tpd.ip4_allow: too long");
			return 1;
		}
		strlcpy(buf, val, sizeof(buf));
		for (cp = buf; (tok = strsep(&cp, VAL_SEP)) != NULL;) {
			if (*tok == '\0')
				continue;
			if (in_addr_range_list_add(&_this->ip4_allow, tok)
			    != 0) {
				l2tpd_log(_this, LOG_ERR,
				    "configuration error at "
				    "l2tpd.ip4_allow: %s", tok);
				return 1;
			}
		}
	}

	if (do_start) {
		 /*
		  * in the case of 1) cold-booted and 2) pptpd.enable
		  * toggled "false" to "true" do this, because we can
		  * assume that all pptpd listner are initialized.
		  */
		val = l2tpd_config_str(_this, CFG_KEY(name, "listener"));
		if (val != NULL) {
			if (strlen(val) >= sizeof(buf)) {
				l2tpd_log(_this, LOG_ERR,
				    "configuration error at %s: too long",
				    CFG_KEY(name, "listener"));
				return 1;
			}
			strlcpy(buf, val, sizeof(buf));

			label = NULL;
			/* it can accept multiple values with tab/space
			 * separation */
			for (i = 0, cp = buf;
			    (tok = strsep(&cp, VAL_SEP)) != NULL;) {
				if (*tok == '\0')
					continue;
				if (label == NULL) {
					label = tok;
					continue;
				}
				if ((aierr = addrport_parse(tok, IPPROTO_UDP,
				    &ai)) != 0) {
					l2tpd_log(_this, LOG_ERR,
					    "configuration error at "
					    "l2tpd.listener: %s: %s", label,
					    gai_strerror(aierr));
					label = NULL;
					return 1;
				}
				if (l2tpd_add_listener(_this, i, label,
				    ai->ai_addr) != 0) {
					freeaddrinfo(ai);
					label = NULL;
a569 8
				freeaddrinfo(ai);
				label = NULL;
				i++;
			}
			if (label != NULL) {
				l2tpd_log(_this, LOG_ERR, "configuration "
				    "error at l2tpd.listener: %s", label);
				return 1;
a571 4
		_this->purge_ipsec_sa = l2tpd_config_str_equal(_this,
		    CFG_KEY(name, "purge_ipsec_sa"), "true", 1);
		_this->require_ipsec = l2tpd_config_str_equal(_this,
		    CFG_KEY(name, "require_ipsec"), "true", 1);
d573 1
a573 2
		if (l2tpd_start(_this) != 0)
			return 1;
d576 8
d654 4
a657 14
				/*
				 * XXX check source address when NAT-T
				 */
				if (in_addr_range_list_includes(
				    &_l2tpd->ip4_allow,
				    &((struct sockaddr_in *)&peer)->sin_addr))
					l2tp_ctrl_input(_l2tpd, _this->index,
					    (struct sockaddr *)&peer,
					    (struct sockaddr *)&sock, nat_t,
					    buf, sz);
				else
					l2tpd_log_access_deny(_l2tpd,
					    "not allowed by acl.",
					    (struct sockaddr *)&peer);
a659 1
				/* XXX source address restriction in IPv6? */
@


1.9
log
@Trivial changes from the upstream(IIJ).
 - fix styles, compile errors in some ifdef condition and compiler warnings.
 - delete rtev* that was to work around routing socket overflows.
 - delete is_ctrl argument from l2tp_ctrl_send_packet().  It's not used.
 - tweak returning the exit status.
 - use IPV6_IPSEC_POLICY for IPv6 socket.
   (though npppd cannot set up a ipsec policy to the socket yet.)

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.8 2012/05/08 13:15:11 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.8 2012/05/08 13:15:11 yasuoka Exp $ */
a84 5
#ifndef USE_LIBSOCKUTIL
struct in_ipsec_sa_cookie	{	};
#endif


d354 10
d789 1
a789 1
#ifdef USE_LIBSOCKUTIL
d816 1
a816 1
#ifdef USE_LIBSOCKUTIL
@


1.8
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: l2tpd.c,v 1.7 2012/01/18 02:53:56 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.7 2012/01/18 02:53:56 yasuoka Exp $ */
d370 1
a371 1
	if (_this->bind.sin6.sin6_family == AF_INET) {
d377 19
d397 1
a403 1
	}
d405 18
a422 15
#ifdef IP_IPSEC_POLICY
/*XXX */
	if (ipsec_policy_in != NULL &&
	    setsockopt(sock, IPPROTO_IP, IP_IPSEC_POLICY,
	    ipsec_policy_in, ipsec_get_policylen(ipsec_policy_in)) < 0) {
		l2tpd_log(_l2tpd, LOG_WARNING,
		    "setsockopt(,,IP_IPSEC_POLICY(in)) failed in %s(): %m",
		    __func__);
	}
	if (ipsec_policy_out != NULL &&
	    setsockopt(sock, IPPROTO_IP, IP_IPSEC_POLICY,
	    ipsec_policy_out, ipsec_get_policylen(ipsec_policy_out)) < 0) {
		l2tpd_log(_l2tpd, LOG_WARNING,
		    "setsockopt(,,IP_IPSEC_POLICY(out)) failed in %s(): %m",
		    __func__);
a423 1
#endif
d759 1
a759 1
	char hostbuf[NI_MAXHOST], servbuf[NI_MAXSERV];
d761 3
a763 8
	if (getnameinfo(peer, peer->sa_len, hostbuf, sizeof(hostbuf),
	    servbuf, sizeof(servbuf), NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
		l2tpd_log(_this, LOG_ERR, "getnameinfo() failed at %s(): %m",
		    __func__);
		return;
	}
	l2tpd_log(_this, LOG_ALERT, "Received packet from %s:%s/udp: "
	    "%s", hostbuf, servbuf, reason);
@


1.7
log
@Fix compiler warnings and some styles.

ok sebastia sthen
@
text
@d1 1
a1 1
/* $OpenBSD: l2tpd.c,v 1.6 2011/03/16 09:49:11 okan Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.6 2011/03/16 09:49:11 okan Exp $ */
a300 9
#ifdef NPPPD_FAKEBIND
	int wildcardbinding = 0;
	extern void set_faith(int, int);

	/* XXX IPv6? */
	wildcardbinding =
	    (_this->bind.sin4.sin_family == AF_INET4 && 
		    _this->bind.sin4.sin_addr.s_addr == INADDR_ANY)? 1 : 0;
#endif
a312 4
#ifdef NPPPD_FAKEBIND
	if (!wildcardbinding)
		set_faith(sock, 1);
#endif
a342 14
#ifdef NPPPD_FAKEBIND
	if (!wildcardbinding)
		set_faith(sock, 0);
#endif
#ifdef UDP_NO_CKSUM
	ival = 1;
	if (setsockopt(sock, IPPROTO_UDP, UDP_NO_CKSUM, &ival, sizeof(ival))
	    != 0) {
		l2tpd_log(_l2tpd, LOG_ERR,
		    "setsockopt(,,UDP_NO_CKSUM) failed in %s(): %m",
		    __func__);
		goto fail;
	}
#endif
d874 1
a874 1
#ifdef	L2TPD_MULITPLE
@


1.6
log
@spelling.

ok yasuoka@@
@
text
@d1 1
a1 1
/* $OpenBSD: l2tpd.c,v 1.5 2010/09/24 14:50:30 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.5 2010/09/24 14:50:30 yasuoka Exp $ */
d83 1
a83 1
static unsigned l2tpd_id_seq = 0;
d102 2
a103 1
	int i, id, off;
d147 2
a148 2
		if (slist_add(&_this->free_session_id_list, (void *)id)
		    == NULL) {
d258 2
a259 1
	int shuffle_cnt, session_id;
d263 1
a263 1
		session_id = (int)slist_remove_first(
d289 1
a289 1
	slist_add(&_this->free_session_id_list, (void *)call->id);
d866 1
a866 1
l2tpd_get_ctrl(l2tpd *_this, int tunid)
d870 1
a870 1
	hl = hash_lookup(_this->ctrl_map, (void *)tunid);
d880 1
a880 1
	hash_insert(_this->ctrl_map, (void *)ctrl->tunnel_id, ctrl);
d884 1
a884 1
l2tpd_remove_ctrl(l2tpd *_this, int tunid)
d886 1
a886 1
	hash_delete(_this->ctrl_map, (void *)tunid, 0);
@


1.5
log
@Add support pipex for L2TP call and L2TP on IPv6.
- pipex requires unique session-id in protocol, so session-id
  generation algorithm has been changed.
- change to fit the new PIPEX ioctl.
ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: l2tpd.c,v 1.4 2010/07/02 21:20:57 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.4 2010/07/02 21:20:57 yasuoka Exp $ */
d593 1
a593 1
		/* terminate immidiatly, when 2nd call */
@


1.4
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: l2tpd.c,v 1.3 2010/07/01 03:38:17 yasuoka Exp $ */
d29 1
a29 1
/* $Id: l2tpd.c,v 1.3 2010/07/01 03:38:17 yasuoka Exp $ */
d102 3
a104 1
	struct sockaddr_in sin0;
d110 5
a114 3
	memset(&sin0, 0, sizeof(sin0));
	sin0.sin_len = sizeof(sin0);
	sin0.sin_family = AF_INET;
d116 8
a123 1
	    (struct sockaddr *)&sin0) != 0) {
a125 1

d134 19
d199 2
a200 2
	L2TPD_ASSERT(sizeof(plistener->bind_sin) >= bindaddr->sa_len);
	memcpy(&plistener->bind_sin, bindaddr, bindaddr->sa_len);
d202 2
a203 2
	if (plistener->bind_sin.sin_port == 0)
		plistener->bind_sin.sin_port = htons(L2TPD_DEFAULT_UDP_PORT);
d230 1
d253 38
d298 1
d303 1
d305 2
a306 1
	    (_this->bind_sin.sin_addr.s_addr == INADDR_ANY)?  1 : 0;
d314 2
a315 1
	if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
d347 5
a351 5
	if (bind(sock, (struct sockaddr *)&_this->bind_sin,
	    _this->bind_sin.sin_len) != 0) {
		l2tpd_log(_l2tpd, LOG_ERR, "Binding %s:%u/udp: %m",
		    inet_ntoa(_this->bind_sin.sin_addr),
		    ntohs(_this->bind_sin.sin_port));
d375 34
a408 7
	ival = 1;	/* for recvfromto */
	if (setsockopt(sock, IPPROTO_IP, IP_RECVDSTADDR, &ival, sizeof(ival))
	    != 0) {
		l2tpd_log(_l2tpd, LOG_ERR,
		    "setsockopt(,,IP_RECVDSTADDR) failed in %s(): %m",
		    __func__);
		goto fail;
d434 3
a436 3
	l2tpd_log(_l2tpd, LOG_INFO, "Listening %s:%u/udp (L2TP LNS) [%s]",
	    inet_ntoa(_this->bind_sin.sin_addr),
	    ntohs(_this->bind_sin.sin_port), _this->phy_label);
d519 2
d525 3
a527 3
		    "Shutdown %s:%u/udp (L2TP LNS)",
		    inet_ntoa(_this->bind_sin.sin_addr),
		    ntohs(_this->bind_sin.sin_port));
d698 1
a698 2
		/* read l2tpd.lisnter_in */
		val = l2tpd_config_str(_this, CFG_KEY(name, "listener_in"));
d723 1
a723 1
					    "l2tpd.listener_in: %s: %s", label,
a727 2
				L2TPD_ASSERT(ai != NULL &&
				    ai->ai_family == AF_INET);
d740 1
a740 1
				    "error at l2tpd.listener_in: %s", label);
d842 7
@


1.3
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
a2 1
/*	$OpenBSD:$	*/
d29 1
a29 1
/* $Id: l2tpd.c,v 1.2 2010/01/13 07:49:44 yasuoka Exp $ */
d111 1
a111 1
	if (l2tpd_add_listener(_this, 0, L2TPD_DEFAULT_LAYER2_LABEL, 
d343 1
a343 1
		
d538 1
a538 1
	if (l2tpd_config_str_equal(_this, CFG_KEY(name, "enabled"), "true", 
d541 1
a541 1
		if (l2tpd_is_shutting_down(_this)) 
d741 1
a741 1
					l2tpd_log_access_deny(_l2tpd, 
@


1.2
log
@cleanup npppd code.  delete IIJ local ifdef switches and fix warnings.
ok @@dlg
@
text
@d1 1
d27 2
a28 7
/**@@file
 * L2TP(Layer Two Tunneling Protocol "L2TP") の実装
 */
/*
 * RFC 2661
 */
// $Id: l2tpd.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $
a79 3
/*
 * static 変数
 */
d81 1
a81 1
/** l2tpd の ID番号のシーケンス番号 */
d89 1
a89 3
/***********************************************************************
 * L2TP デーモンインスタンス操作
 ***********************************************************************/
d92 1
a92 1
 * L2TPデーモンインスタンスを初期化します。
d94 3
a96 2
 * {@@link _l2tpd#bind_sin} は、.sin_family = AF_INET、.sin_port = 1701、
 * .sin_len が設定された状態で返ります。 </p>
d132 6
a137 6
/**
 * {@@link ::l2tpd L2TPデーモン}に{@@link ::l2tpd_listener リスナ}を追加します。
 * @@param	_this	{@@link ::l2tpd L2TPデーモン}
 * @@param	idx	リスナのインデックス
 * @@param	label	物理層としてのラベル。"L2TP" など
 * @@param	bindaddr	待ち受けるアドレス
d161 1
a161 1
		goto reigai;
d166 1
a166 1
		goto reigai;
a171 1
	/* ポート番号が省略された場合は、デフォルト (1701/udp)を使う */
d183 1
a183 1
		goto reigai;
d186 1
a186 1
reigai:
d192 1
a192 1
/** L2TPデーモンインスタンスの終了処理を行います。*/
d217 1
a217 1
	event_del(&_this->ev_timeout);	// ねんのため
d222 1
a222 1
/** 待ち受けを開始します。*/
d245 1
a245 1
		goto reigai;
d261 1
a261 1
		goto reigai;
d265 1
a265 1
		goto reigai;
d272 1
a272 1
		goto reigai;
d279 1
a279 1
		goto reigai;
d292 1
a292 1
		goto reigai;
d299 1
a299 1
		goto reigai;
d302 1
a302 2
	// recvfromto のために
	ival = 1;
d308 1
a308 1
		goto reigai;
d339 1
a339 1
reigai:
d346 1
a346 1
/** L2TPデーモンを開始します。*/
d367 3
a369 3
		 * NOTE ipsec_set_policy() 内で利用する yacc のスタック用の
		 * バッファは動的に割り当てられますが、解放されません。
		 * yasuoka の調査時は 2000 バイトリークします。
d376 1
a376 1
				goto reigai;
d383 1
a383 1
			goto reigai;
d405 1
a405 1
reigai:
d415 1
a415 1
/** 待ち受けを終了します */
d429 2
a430 3
/**
 * 切断を猶予せずにすぐに停止します。
 */
d441 1
a441 1
	event_del(&_this->ev_timeout);	// ねんのため
d445 3
a447 2
/**
 * {@@link ::_l2tp_ctrl コントロール} が終了した際にコールされます。
d478 1
a478 3
/**
 * L2TPデーモンを停止します。
 */
d491 1
a491 3
		/*
		 * 2度目はすぐに終了
		 */
d516 3
a518 3
/***********************************************************************
 * 設定関連
 ***********************************************************************/
d539 1
a539 1
		// false にした直後に true にされるかもしれない。
d553 1
a553 1
	/* 設定がなかったら使われる */
d567 1
a567 1
	// ip4_allow をパース
d591 6
a596 6
		/*
		 * 起動直後と、l2tpd.enable が false -> true に変更された
		 * 場合に、do_start。すべてのリスナーが、初期化された状態を
		 * 仮定できる
		 */
		// l2tpd.listener_in の読み込む
d608 2
a609 1
			// タブ、スペース区切りで、複数指定可能
d657 4
a660 4
/***********************************************************************
 * I/O 関連
 ***********************************************************************/
/** アクセスを拒否したことをログに残す */
d676 1
a676 1
/** I/Oイベントハンドラ */
d718 1
a718 1
			//送信元チェック(allows.in)
d730 1
a730 1
				 * XXX NAT-T の場合の送信元チェック
d754 3
a756 3
/***********************************************************************
 * L2TPコントロール関連
 ***********************************************************************/
d782 3
a784 3
/***********************************************************************
 * 雑多
 ***********************************************************************/
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d32 1
a32 1
// $Id: l2tpd.c 39106 2010-01-10 21:01:39Z yasuoka $
d414 1
d416 1
@

