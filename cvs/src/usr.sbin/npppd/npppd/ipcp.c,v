head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.16
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.12
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.14
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2012.05.08.13.15.11;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.5
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@/*	$OpenBSD: ipcp.c,v 1.4 2012/05/08 13:15:11 yasuoka Exp $ */

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/**@@file
 * This is an implementation of IPCP. This code is currently implemented
 * as network service provider, and the peer is forced to obey our proposal.
 */
/*
 * RFC 1332, 1877
 */
/* $Id: ipcp.c,v 1.4 2012/05/08 13:15:11 yasuoka Exp $ */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <net/if_dl.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <stdio.h>
#include <syslog.h>
#include <string.h>
#include <event.h>

#include "debugutil.h"
#include "slist.h"
#include "npppd.h"

#ifdef	IPCP_DEBUG
#define	IPCP_DBG(x)	fsm_log x
#define	IPCP_ASSERT(x)	ASSERT(x)
#else
#define	IPCP_DBG(x)
#define	IPCP_ASSERT(x)
#endif


#define	IPCP_IP_ADDRESSES	1
#define	IPCP_IP_COMP		2
#define	IPCP_IP_ADDRESS		3
#define	IPCP_PRI_DNS		129	/* 0x81 */
#define	IPCP_PRI_NBNS		130	/* 0x82 */
#define	IPCP_SEC_DNS		131	/* 0x83 */
#define	IPCP_SEC_NBNS		132	/* 0x84 */

#define u32maskcmp(mask, a, b) (((a) & (mask)) == ((b) & (mask)))

static void  ipcp_resetci (fsm *);
static int   ipcp_cilen (fsm *);
static void  ipcp_addci (fsm *, u_char *, int *);
static int   ipcp_ackci (fsm *, u_char *, int);
static int   ipcp_nakci (fsm *, u_char *, int);
static int   ipcp_rejci (fsm *, u_char *, int);
static int   ipcp_reqci (fsm *, u_char *, int *, int);
static void  ipcp_open (fsm *);
static void  ipcp_close (fsm *);
static void  ipcp_start (fsm *);
static void  ipcp_stop (fsm *);

static struct fsm_callbacks ipcp_callbacks = {
	ipcp_resetci,	/* Reset our Configuration Information */
	ipcp_cilen,	/* Length of our Configuration Information */
	ipcp_addci,	/* Add our Configuration Information */
	ipcp_ackci,	/* ACK our Configuration Information */
	ipcp_nakci,	/* NAK our Configuration Information */
	ipcp_rejci,	/* Reject our Configuration Information */
	ipcp_reqci,	/* Request peer's Configuration Information */

	ipcp_open,	/* Called when fsm reaches OPENED state */
	ipcp_close,	/* Called when fsm leaves OPENED state */
	ipcp_start,	/* Called when we want the lower layer up */
	ipcp_stop,	/* Called when we want the lower layer down */
	NULL,		/* Called when Protocol-Reject received */
	NULL,		/* Retransmission is necessary */
	NULL,		/* Called to handle LCP-specific codes */
	"ipcp"		/* String name of protocol */
};

/**
 * Initialize {@@link ::_ipcp IPCP instance }.
 */
void
ipcp_init(ipcp *_this, npppd_ppp *ppp)
{
	struct tunnconf *conf;

	memset(_this, 0, sizeof(ipcp));

	_this->ppp = ppp;
	_this->fsm.ppp = ppp;

	fsm_init(&_this->fsm);

	_this->fsm.callbacks = &ipcp_callbacks;
	_this->fsm.protocol = PPP_PROTO_NCP | NCP_IPCP;

	conf = ppp_get_tunnconf(ppp);
	PPP_FSM_CONFIG(&_this->fsm, timeouttime, conf->ipcp_timeout);
	PPP_FSM_CONFIG(&_this->fsm, maxconfreqtransmits,
	    conf->ipcp_max_configure);
	PPP_FSM_CONFIG(&_this->fsm, maxtermtransmits,
	    conf->ipcp_max_terminate);
	PPP_FSM_CONFIG(&_this->fsm, maxnakloops,
	    conf->ipcp_max_nak_loop);
}

static void
ipcp_resetci(fsm *f)
{
	IPCP_DBG((f, LOG_DEBUG, "%s", __func__));
	if (npppd_prepare_ip(f->ppp->pppd, f->ppp) != 0) {
		fsm_log(f, LOG_ERR, "failed to assign ip address.");
		ppp_stop(f->ppp, NULL);
	}
}

static int
ipcp_cilen(fsm *f)
{
	IPCP_DBG((f, LOG_DEBUG, "%s", __func__));
	return f->ppp->mru;
}

static void
ipcp_addci(fsm *f, u_char *pktp, int *lpktp)
{
	u_char *pktp0;

	IPCP_DBG((f, LOG_DEBUG, "%s", __func__));
	pktp0 = pktp;

	PUTCHAR(IPCP_IP_ADDRESS, pktp);
	PUTCHAR(6, pktp);
	memcpy(pktp, &f->ppp->ipcp.ip4_our.s_addr, 4);
	pktp += 4;
	*lpktp = pktp - pktp0;
}


static int
ipcp_ackci(fsm *f, u_char *pktp, int lpkt)
{
	IPCP_DBG((f, LOG_DEBUG, "%s", __func__));
	/* TODO */
	return -1;
}

static int
ipcp_nakci(fsm *f, u_char *pktp, int lpkt)
{
	IPCP_DBG((f, LOG_DEBUG, "%s", __func__));

	fsm_log(f, LOG_INFO, "Peer refused(ConfNak) our ip=%s.",
	    inet_ntoa(f->ppp->ipcp.ip4_our));
	fsm_close(f, NULL);
	return -1;
}

static int
ipcp_rejci(fsm *f, u_char *pktp, int lpkt)
{
	IPCP_DBG((f, LOG_DEBUG, "%s", __func__));

	fsm_log(f, LOG_INFO, "Peer refused(ConfRej) our ip=%s.",
	    inet_ntoa(f->ppp->ipcp.ip4_our));
	fsm_close(f, NULL);

	return 0;
}

static int
ipcp_reqci(fsm *f, u_char *pktp, int *lpktp, int reject_if_disagree)
{
	int type, len, rcode, lrej, lnak;
	u_char rejbuf0[256], nakbuf0[256], *nakbuf, *rejbuf, *pktp0;
	char buf0[256];
	struct in_addr ip_addr, *ip_addrp;
	npppd_ppp *ppp;
	npppd *_npppd;
	int ip_address_acked = 0;

	IPCP_DBG((f, LOG_DEBUG, "%s(reject_if_disagree=%d, nakloops=%d)",
	    __func__, reject_if_disagree, f->nakloops));
	ppp = f->ppp;
	_npppd = ppp->pppd;

	nakbuf = nakbuf0;
	rejbuf = rejbuf0;
	lrej = 0;
	lnak = 0;
	pktp0 = pktp;
	rcode = -1;

	if (*lpktp > 128) {
		rcode = CONFREJ;
		rejbuf = pktp;
		lrej = *lpktp;
		goto fail;
	}

#define	remlen()	(*lpktp - (pktp - pktp0))

	ip_address_acked = 0;
	while (remlen() >= 2) {
		GETCHAR(type, pktp);
		GETCHAR(len, pktp);
		if (len <= 0 || remlen() + 2 < len)
			goto fail;

		switch (type) {
		case IPCP_IP_ADDRESS:
		case IPCP_PRI_DNS:
		case IPCP_PRI_NBNS:
		case IPCP_SEC_DNS:
		case IPCP_SEC_NBNS:
			if (remlen() < 4)
				goto fail;
			GETLONG(ip_addr.s_addr, pktp);
			ip_addr.s_addr = htonl(ip_addr.s_addr);

			switch (type) {
			case IPCP_IP_ADDRESS:
				if (!ppp_ip_assigned(ppp)) {
					if (npppd_assign_ip_addr(ppp->pppd, ppp,
					    htonl(ip_addr.s_addr)) != 0 &&
					    npppd_assign_ip_addr(ppp->pppd, ppp,
					    INADDR_ANY) != 0) {
						/*
						 * The reason why it call with INADDR_ANY again here
						 * is to adapt the client expecting to fall back into
						 * dynamic allocation when user-select is allowed.
						 */
						pktp -= 4;
						goto do_reject;
					}
					strlcpy(buf0, inet_ntoa(ip_addr),
					    sizeof(buf0));
					fsm_log(f, LOG_INFO,
					    "IP Address peer=%s our=%s.", buf0,
					    inet_ntoa(
						ppp->ppp_framed_ip_address));
				}

				if (u32maskcmp(ppp->ppp_framed_ip_netmask
				    .s_addr, ip_addr.s_addr,
				    ppp->ppp_framed_ip_address.s_addr)) {
					/*
					 * In case of assigning network address, it obey
					 * peer's proposal if peer's IP-Address Option is
					 * included in network address to assign.
					 */
					ip_addrp = &ip_addr;
				} else {
					ip_addrp = &ppp->
					    ppp_framed_ip_address;
				}
				ip_address_acked = 1;
				break;
			case IPCP_PRI_DNS:
				ip_addrp = &ppp->ipcp.dns_pri;	break;
			case IPCP_SEC_DNS:
				ip_addrp = &ppp->ipcp.dns_sec;	break;
			case IPCP_PRI_NBNS:
				ip_addrp = &ppp->ipcp.nbns_pri;	break;
			case IPCP_SEC_NBNS:
				ip_addrp = &ppp->ipcp.nbns_sec;	break;
			default:
				ip_addrp = NULL;
			}

			if (ip_addrp == NULL ||
			    ip_addrp->s_addr == INADDR_NONE) {
				pktp -= 4;
				goto do_reject;
			}
			if (ip_addrp->s_addr != ip_addr.s_addr) {
				if (reject_if_disagree) {
					pktp -= 4;
					goto do_reject;
				}
				if (lrej > 0) {
				/* if there is a reject, will send Rej, not send Nak. */
				} else {
					PUTCHAR(type, nakbuf);
					PUTCHAR(6, nakbuf);
					PUTLONG(ntohl(ip_addrp->s_addr),
					    nakbuf);
					lnak += 6;
					rcode = CONFNAK;
				}
			}
			break;
		case IPCP_IP_COMP:
		case IPCP_IP_ADDRESSES:
		default:
			fsm_log(f, LOG_DEBUG, "Unhandled Option %02x %d", type,
			    len);
do_reject:
			pktp -= 2;
			memmove(rejbuf + lrej, pktp, len);
			lrej += len;
			pktp += len;
			rcode = CONFREJ;
		}
		continue;
	}
	if (rcode == -1)
		rcode = CONFACK;

fail:
	switch (rcode) {
	case CONFREJ:
		IPCP_DBG((f, LOG_DEBUG, "SendConfRej"));
		memmove(pktp0, rejbuf0, lrej);
		*lpktp = lrej;
		break;
	case CONFNAK:
		/*
		 * In case of Yamaha router is set "pp ppp ipcp ip-address off",
		 * it sends ConfReq without IP-Address Option.
		 * To quote RFC 1332:
		 * If negotiation about the remote IP-address is required, and
		 * the peer did not provide the option in its Configure-Request,
		 * the option SHOULD be appended to a Configure-Nak.
		 *
		 * Is any problem of overrunning 6 bytes of lpkt?
		 *  - In ppp.c, lpkt is allocated mru + 64 bytes. lpkt is less
		 *    than mru, so +6 is enough.
		 */
		if (!ip_address_acked) {
			/* It is mandatory to assign IP address. */
			if (!ppp_ip_assigned(ppp)) {
				if (npppd_assign_ip_addr(ppp->pppd, ppp,
				    INADDR_ANY) != 0) {
				    /* The log already put in npppd_assign_ip_addr(). */
				}
			}
			PUTCHAR(IPCP_IP_ADDRESS, nakbuf);
			PUTCHAR(6, nakbuf);
			PUTLONG(ntohl(ppp->ppp_framed_ip_address.s_addr),
			    nakbuf);
			lnak += 6;
		}
		IPCP_DBG((f, LOG_DEBUG, "SendConfNak"));
		memmove(pktp0, nakbuf0, lnak);
		*lpktp = lnak;
		break;
	case CONFACK:
		IPCP_DBG((f, LOG_DEBUG, "SendConfAck"));
		break;
	}

	return rcode;
#undef	remlen
}

static void
ipcp_open(fsm *f)
{
	if (!ppp_ip_assigned(f->ppp)) {
		fsm_log(f, LOG_INFO, "the ip-address option from the peer was "
		    "not agreed.");
		/*
		 * agreed without IP-Address Option.  try to assign static address.
		 */
		if (f->ppp->realm_framed_ip_address.s_addr
			    != INADDR_USER_SELECT &&
		    f->ppp->realm_framed_ip_address.s_addr
			    != INADDR_NAS_SELECT &&
		    f->ppp->realm_framed_ip_address.s_addr != 0) {
			npppd_assign_ip_addr(f->ppp->pppd, f->ppp, INADDR_ANY);
		}
	}
	if (!ppp_ip_assigned(f->ppp)) {
		fsm_log(f, LOG_NOTICE,
		    "IPCP opened but no IP address for the peer.");
		ppp_stop(f->ppp, NULL);
		return;
	}

	fsm_log(f, LOG_INFO, "logtype=Opened ip=%s assignType=%s",
	    inet_ntoa(f->ppp->ppp_framed_ip_address),
	    (f->ppp->assign_dynapool)? "dynamic" : "static");

	ppp_ipcp_opened(f->ppp);
}

static void
ipcp_close(fsm *f)
{
	IPCP_DBG((f, LOG_DEBUG, "%s", __func__));
}

static void
ipcp_start(fsm *f)
{
}

static void
ipcp_stop(fsm *f)
{
	fsm_log(f, LOG_INFO, "IPCP is stopped");
	ppp_stop(f->ppp, NULL);
}
@


1.4
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcp.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $ */
d35 1
a35 1
/* $Id: ipcp.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $ */
d108 2
d119 9
a127 4
	PPP_FSM_CONFIG(&_this->fsm, timeouttime,	"ipcp.timeout");
	PPP_FSM_CONFIG(&_this->fsm, maxconfreqtransmits,"ipcp.max_configure");
	PPP_FSM_CONFIG(&_this->fsm, maxtermtransmits,	"ipcp.max_terminate");
	PPP_FSM_CONFIG(&_this->fsm, maxnakloops,	"ipcp.max_nak_loop");
@


1.3
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d35 1
a35 1
/* $Id: ipcp.c,v 1.2 2010/07/01 03:38:17 yasuoka Exp $ */
@


1.2
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
d35 1
a35 1
/* $Id: ipcp.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $ */
d56 1
a56 1
#define	IPCP_DBG(x)	
d325 1
a325 1
	
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d27 2
a28 2
 * IPCP の実装です。現在ネットワーク提供者としての実装で、こちらの提案を
 * 押しつけます。
d33 1
a33 1
/* $Id: ipcp.c 35138 2008-05-19 14:12:31Z yasuoka $ */
d101 1
a101 1
 * {@@link ::_ipcp IPCP インスタンス} を初期化します。
d212 1
a212 1
		goto reigai;
d222 1
a222 1
			goto reigai;
d231 1
a231 1
				goto reigai;
d243 3
a245 6
						 * INADDR_ANY で call しなおす
						 * のは、user-select が許可さ
						 * れている場合に動的割り当て
						 * へのフォールバックを期待す
						 * るクライアントへの対応のた
						 * め。[IDGW-DEV 6847]
d262 3
a264 4
					 * ネットワーク型払出し時は、対抗の
					 * IP-Address Option が、払い出すネッ
					 * トワークに含まれる場合には、対抗
					 * の提案に従う。
d296 1
a296 1
				/* reject があれば、Rej するので Nak しない */
d324 1
a324 1
reigai:
d333 4
a336 4
		 * Yamaha で、"pp ppp ipcp ip-address off" すると、IP-Adddress
		 * Option なしで ConfReq が届く。RFC 1332 より
		 * 
	      	 * If negotiation about the remote IP-address is required, and
d340 3
a342 3
		 * 6バイト lpkt をはみだしても大丈夫か?
		 *	- ppp.c では mru + 64 分確保している。lpkt は mru 以下
		 *	  なので、+6 は大丈夫。
d345 1
a345 1
			/* IPアドレスの割り当ては必須。*/
d349 1
a349 1
				    /* ログは npppd_assign_ip_addr で出力済み */
d378 1
a378 2
		 * IP-Address Option 無しで合意。固定IPアドレス割当てを
		 * 試みる
@

