head	1.47;
access;
symbols
	OPENBSD_6_1:1.43.0.8
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.47
date	2017.08.12.11.20.34;	author goda;	state Exp;
branches;
next	1.46;
commitid	ccl4VRXLf9CVdvt9;

1.46
date	2017.08.11.16.41.47;	author goda;	state Exp;
branches;
next	1.45;
commitid	lPXceYnVd6sYbkcz;

1.45
date	2017.04.18.03.28.04;	author yasuoka;	state Exp;
branches;
next	1.44;
commitid	jZL0tRGvswpHkARR;

1.44
date	2017.04.18.03.25.22;	author yasuoka;	state Exp;
branches;
next	1.43;
commitid	Nhz30Sxxw8cC7tQJ;

1.43
date	2015.12.05.16.10.31;	author yasuoka;	state Exp;
branches;
next	1.42;
commitid	CAVUqjHZb5KSEF4I;

1.42
date	2015.11.09.01.14.22;	author yasuoka;	state Exp;
branches;
next	1.41;
commitid	IfiP91PwAFaBuyw6;

1.41
date	2015.06.24.04.57.55;	author yasuoka;	state Exp;
branches;
next	1.40;
commitid	QZXetMSFXN0i2dnV;

1.40
date	2015.01.19.01.48.59;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	a1BWBASyBgKKetQd;

1.39
date	2015.01.08.07.34.05;	author yasuoka;	state Exp;
branches;
next	1.38;
commitid	XZWXDDgTC0gslzFn;

1.38
date	2014.11.13.04.03.53;	author yasuoka;	state Exp;
branches;
next	1.37;
commitid	QXooH58ehI6kvg3C;

1.37
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.36;
commitid	2uw1UTO4k6erpWzK;

1.36
date	2014.07.08.18.49.27;	author yasuoka;	state Exp;
branches;
next	1.35;
commitid	sYV73duWmOcVSm0H;

1.35
date	2014.03.22.04.30.31;	author yasuoka;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.22.04.23.17;	author yasuoka;	state Exp;
branches;
next	1.33;

1.33
date	2014.03.22.04.21.04;	author yasuoka;	state Exp;
branches;
next	1.32;

1.32
date	2013.09.13.03.25.28;	author yasuoka;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.03.23.26.57;	author yasuoka;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.20.23.32.32;	author yasuoka;	state Exp;
branches;
next	1.29;

1.29
date	2013.04.20.07.00.19;	author yasuoka;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.16.07.42.27;	author yasuoka;	state Exp;
branches;
next	1.27;

1.27
date	2013.02.13.22.10.38;	author yasuoka;	state Exp;
branches;
next	1.26;

1.26
date	2012.12.05.23.20.26;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2012.11.13.17.10.40;	author yasuoka;	state Exp;
branches;
next	1.24;

1.24
date	2012.09.28.23.46.00;	author yasuoka;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.20.20.28.09;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2012.09.19.17.50.17;	author yasuoka;	state Exp;
branches;
next	1.21;

1.21
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches;
next	1.20;

1.20
date	2012.07.17.03.18.57;	author yasuoka;	state Exp;
branches;
next	1.19;

1.19
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2012.05.08.13.30.16;	author yasuoka;	state Exp;
branches;
next	1.17;

1.17
date	2012.05.08.13.18.37;	author yasuoka;	state Exp;
branches;
next	1.16;

1.16
date	2012.05.08.13.15.11;	author yasuoka;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.23.03.36.22;	author yasuoka;	state Exp;
branches;
next	1.14;

1.14
date	2012.01.18.03.13.04;	author yasuoka;	state Exp;
branches;
next	1.13;

1.13
date	2012.01.18.02.53.56;	author yasuoka;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.08.06.14.54;	author yasuoka;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.06.20.52.28;	author yasuoka;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.15.15.47.52;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.02.12.04.44;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.14.50.30;	author yasuoka;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.23.01.45.10;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.31.09.33.09;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.31.05.49.51;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.07.49.44;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.47
log
@add a new option to set limits on max-sessions each IPCP.

It can set limits on different max-sessions if there're using several protocols
such as PPPoE and L2TP/IPsec.

ok yasuoka@@
@
text
@/*	$OpenBSD: npppd.c,v 1.46 2017/08/11 16:41:47 goda Exp $ */

/*-
 * Copyright (c) 2005-2008,2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/**@@file
 * Next pppd(nppd). This file provides a npppd daemon process and operations
 * for npppd instance.
 * @@author	Yasuoka Masahiko
 * $Id: npppd.c,v 1.46 2017/08/11 16:41:47 goda Exp $
 */
#include "version.h"
#include <sys/param.h>	/* ALIGNED_POINTER */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <net/route.h>
#include <arpa/inet.h>
#include <net/if_dl.h>
#include <unistd.h>
#include <time.h>
#include <syslog.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <netdb.h>
#include <libgen.h>
#include <fcntl.h>
#include <event.h>
#include <errno.h>
#include <ifaddrs.h>
#include <err.h>
#include <pwd.h>

#include "pathnames.h"
#include "debugutil.h"
#include "addr_range.h"
#include "npppd_subr.h"
#include "npppd_local.h"
#include "npppd_auth.h"
#include "radish.h"
#include "net_utils.h"
#include "time_utils.h"

#include "l2tp_local.h"	/* XXX sa_cookie */

#ifdef USE_NPPPD_ARP
#include "npppd_arp.h"
#endif

#ifdef USE_NPPPD_PIPEX
#ifdef USE_NPPPD_PPPOE
#include "pppoe_local.h"
#endif /* USE_NPPPD_PPPOE */
#include "psm-opt.h"
#include <sys/ioctl.h>
#include <net/pipex.h>
#endif /* USE_NPPPD_PIPEX */

#include "accept.h"
#include "log.h"

static npppd s_npppd;	/* singleton */

static void         npppd_reload0 (npppd *);
static void         npppd_update_pool_reference (npppd *);
static int          npppd_rd_walktree_delete(struct radish_head *);
static __dead void  usage (void);
static void         npppd_stop_really (npppd *);
static uint32_t     str_hash(const void *, int);
static void         npppd_on_sighup (int, short, void *);
static void         npppd_on_sigterm (int, short, void *);
static void         npppd_on_sigint (int, short, void *);
static void         npppd_on_sigchld (int, short, void *);
static void         npppd_reset_timer(npppd *);
static void         npppd_timer(int, short, void *);
static void         npppd_auth_finalizer_periodic(npppd *);
static int          rd2slist_walk (struct radish *, void *);
static int          rd2slist (struct radish_head *, slist *);
static slist       *npppd_get_ppp_by_user (npppd *, const char *);
static int          npppd_get_all_users (npppd *, slist *);
static struct ipcpstat
                   *npppd_get_ipcp_stat(struct ipcpstat_head *, const char *);
static void         npppd_destroy_ipcp_stats(struct ipcpstat_head *);
static void         npppd_ipcp_stats_reload(npppd *);

#ifndef	NO_ROUTE_FOR_POOLED_ADDRESS
static struct in_addr loop;	/* initialize at npppd_init() */
#endif
static uint32_t        str_hash(const void *, int);

#ifdef USE_NPPPD_PIPEX
static int npppd_ppp_pipex_ip_disable(npppd *, npppd_ppp *);
static void pipex_periodic(npppd *);
#endif /* USE_NPPPD_PIPEX */

#ifdef NPPPD_DEBUG
#define NPPPD_DBG(x) 	log_printf x
#define NPPPD_ASSERT(x) ASSERT(x)
#else
#define NPPPD_DBG(x)
#define NPPPD_ASSERT(x)
#endif

/***********************************************************************
 * Daemon process
 ***********************************************************************/
int        main (int, char *[]);
int        debugsyslog = 0;	/* used by log.c */

int
main(int argc, char *argv[])
{
	int            ch, stop_by_error, runasdaemon = 1, nflag = 0;
	extern char   *optarg;
	const char    *npppd_conf0 = DEFAULT_NPPPD_CONF;
	struct passwd *pw;

	while ((ch = getopt(argc, argv, "nf:d")) != -1) {
		switch (ch) {
		case 'n':
			nflag = 1;
			break;
		case 'f':
			npppd_conf0 = optarg;
			break;
		case 'd':
			debuglevel++;
			runasdaemon = 0;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 0)
		usage();
	if (nflag) {
		debuglevel++;
		runasdaemon = 0;
	}

	/* for log.c */
	log_init(debuglevel);
	if (debuglevel > 0) {
		/* for ../common/debugutil.c */
		debug_set_debugfp(stderr);
		debug_use_syslog(0);
	}
	if (runasdaemon)
		daemon(0, 0);

	/* check for root privileges */
	if (geteuid())
		errx(1, "need root privileges");
	/* check for npppd user */
	if (getpwnam(NPPPD_USER) == NULL)
		errx(1, "unknown user %s", NPPPD_USER);

	if (privsep_init() != 0)
		err(1, "cannot drop privileges");

	if (nflag) {
		if (npppd_config_check(npppd_conf0) == 0) {
			fprintf(stderr, "configuration OK\n");
			exit(EXIT_SUCCESS);
		}
		exit(EXIT_FAILURE);
	}
	if (npppd_init(&s_npppd, npppd_conf0) != 0)
		exit(EXIT_FAILURE);

	if ((pw = getpwnam(NPPPD_USER)) == NULL)
		err(EXIT_FAILURE, "gwpwnam");
	if (chroot(pw->pw_dir) == -1)
		err(EXIT_FAILURE, "chroot");
	if (chdir("/") == -1)
		err(EXIT_FAILURE, "chdir(\"/\")");
        if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		err(EXIT_FAILURE, "cannot drop privileges");
	/* privileges is dropped */

	npppd_start(&s_npppd);
	stop_by_error = s_npppd.stop_by_error;
	npppd_fini(&s_npppd);
	privsep_fini();
	log_printf(LOG_NOTICE, "Terminate npppd.");

	exit((!stop_by_error)? EXIT_SUCCESS : EXIT_FAILURE);
}

static __dead void
usage(void)
{
	fprintf(stderr, "usage: npppd [-dn] [-f config_file]\n");
	exit(1);
}

/** Returns the singleton npppd instance */
npppd *
npppd_get_npppd()
{
	return &s_npppd;
}

/***********************************************************************
 * Operations to npppd itself (initialize/finalize/start/stop)
 ***********************************************************************/
 /** Initialize the npppd */
int
npppd_init(npppd *_this, const char *config_file)
{
	int		 i, status = -1, value;
	const char	*pidpath0;
	FILE		*pidfp = NULL;
	struct tunnconf	*tunn;
	struct ipcpconf *ipcpconf;
	struct ipcpstat *ipcpstat;
	int		 mib[] = { CTL_NET, PF_PIPEX, PIPEXCTL_ENABLE };
	size_t		 size;

	memset(_this, 0, sizeof(npppd));
#ifndef	NO_ROUTE_FOR_POOLED_ADDRESS
	loop.s_addr = htonl(INADDR_LOOPBACK);
#endif

	NPPPD_ASSERT(config_file != NULL);

	pidpath0 = NULL;
	_this->pid = getpid();
	slist_init(&_this->realms);
	npppd_conf_init(&_this->conf);

	log_printf(LOG_NOTICE, "Starting npppd pid=%u version=%s",
	    _this->pid, VERSION);
#if defined(BUILD_DATE) && defined(BUILD_TIME)
	log_printf(LOG_INFO, "Build %s %s ", BUILD_DATE, BUILD_TIME);
#endif
	if (get_nanotime() == INT64_MIN) {
		log_printf(LOG_ERR, "get_nanotime() failed: %m");
		return 1;
	}

	if (realpath(config_file, _this->config_file) == NULL) {
		log_printf(LOG_ERR, "realpath(%s,) failed in %s(): %m",
		    config_file, __func__);
		return 1;
	}
	/* we assume 4.4 compatible realpath().  See realpath(3) on BSD. */
	NPPPD_ASSERT(_this->config_file[0] == '/');

	_this->boot_id = arc4random();

#ifdef	USE_NPPPD_L2TP
	if (l2tpd_init(&_this->l2tpd) != 0)
		return (-1);
#endif
#ifdef	USE_NPPPD_PPTP
	if (pptpd_init(&_this->pptpd) != 0)
		return (-1);
#endif
#ifdef	USE_NPPPD_PPPOE
	if (pppoed_init(&_this->pppoed) != 0)
		return (-1);
#endif
	LIST_INIT(&_this->ipcpstats);

	/* load configuration */
	if ((status = npppd_reload_config(_this)) != 0)
		return status;

	TAILQ_FOREACH(tunn, &_this->conf.tunnconfs, entry) {
		if (tunn->pipex) {
			size = sizeof(value);
			if (!sysctl(mib, nitems(mib), &value, &size, NULL, 0)
			    && value == 0)
				log_printf(LOG_WARNING,
					"pipex(4) is disabled by sysctl");
			break;
		}
	}

	if ((_this->map_user_ppp = hash_create(
	    (int (*) (const void *, const void *))strcmp, str_hash,
	    NPPPD_USER_HASH_SIZ)) == NULL) {
		log_printf(LOG_ERR, "hash_create() failed in %s(): %m",
		    __func__);
		return -1;
	}

	if (npppd_ifaces_load_config(_this) != 0) {
		return -1;
	}

	TAILQ_FOREACH(ipcpconf, &_this->conf.ipcpconfs, entry) {
		ipcpstat = malloc(sizeof(*ipcpstat));
		if (ipcpstat == NULL) {
			log_printf(LOG_ERR, "initializing ipcp_stats failed : %m");
			npppd_destroy_ipcp_stats(&_this->ipcpstats);
			return -1;
		}
		memset(ipcpstat, 0, sizeof(*ipcpstat));
		strlcpy(ipcpstat->name, ipcpconf->name, sizeof(ipcpstat->name));
		LIST_INSERT_HEAD(&_this->ipcpstats, ipcpstat, entry);
	}

	pidpath0 = DEFAULT_NPPPD_PIDFILE;

	/* initialize event(3) */
	event_init();
	_this->ctl_sock.cs_name = NPPPD_SOCKET;
	_this->ctl_sock.cs_ctx = _this;
	if (control_init(&_this->ctl_sock) == -1) {
		log_printf(LOG_ERR, "control_init() failed %s(): %m",
		    __func__);
		return (-1);
	}
	if (control_listen(&_this->ctl_sock) == -1) {
		log_printf(LOG_ERR, "control_listen() failed %s(): %m",
		    __func__);
		return (-1);
	}
	accept_init();

	/* ignore signals */
	signal(SIGPIPE, SIG_IGN);
	signal(SIGURG, SIG_IGN);

	/* set signal handlers */
	signal_set(&_this->ev_sigterm, SIGTERM, npppd_on_sigterm, _this);
	signal_set(&_this->ev_sigint, SIGINT, npppd_on_sigint, _this);
	signal_set(&_this->ev_sighup, SIGHUP, npppd_on_sighup, _this);
	signal_set(&_this->ev_sigchld, SIGCHLD, npppd_on_sigchld, _this);
	signal_add(&_this->ev_sigterm, NULL);
	signal_add(&_this->ev_sigint, NULL);
	signal_add(&_this->ev_sighup, NULL);
	signal_add(&_this->ev_sigchld, NULL);

	evtimer_set(&_this->ev_timer, npppd_timer, _this);

	/* start tun(4) or pppac(4) */
	status = 0;
	for (i = 0; i < countof(_this->iface); i++) {
		if (_this->iface[i].initialized != 0)
			status |= npppd_iface_start(&_this->iface[i]);
	}
	if (status != 0)
		return -1;

	/*
	 * If the npppd can start(open) interfaces successfully, it can
	 * act as only one npppd process on the system and overwrite the pid
	 * file.
	 */
	if ((pidfp = fopen(pidpath0, "w+")) == NULL) {
		log_printf(LOG_ERR, "fopen(%s,w+) failed in %s(): %m",
		    pidpath0, __func__);
		return -1;
	}
	strlcpy(_this->pidpath, pidpath0, sizeof(_this->pidpath));
	fprintf(pidfp, "%u\n", _this->pid);
	fclose(pidfp);
	pidfp = NULL;
#ifdef USE_NPPPD_ARP
	arp_set_strictintfnetwork(npppd_config_str_equali(_this, "arpd.strictintfnetwork", "true", ARPD_STRICTINTFNETWORK_DEFAULT));
	if (npppd_config_str_equali(_this, "arpd.enabled", "true", ARPD_DEFAULT) == 1)
        	arp_sock_init();
#endif
	if ((status = npppd_modules_reload(_this)) != 0)
		return status;

	npppd_update_pool_reference(_this);

	return 0;
}

/** start the npppd */
void
npppd_start(npppd *_this)
{
	int rval = 0;

	npppd_reset_timer(_this);
	while ((rval = event_loop(EVLOOP_ONCE)) == 0) {
		if (_this->finalized != 0)
			break;
	}
	if (rval != 0) {
		log_printf(LOG_CRIT, "event_loop() failed: %m");
		abort();
	}
}

/** stop the npppd */
void
npppd_stop(npppd *_this)
{
	int i;
#ifdef	USE_NPPPD_L2TP
	l2tpd_stop(&_this->l2tpd);
#endif
#ifdef	USE_NPPPD_PPTP
	pptpd_stop(&_this->pptpd);
#endif
#ifdef	USE_NPPPD_PPPOE
	pppoed_stop(&_this->pppoed);
#endif
#ifdef USE_NPPPD_ARP
        arp_sock_fini();
#endif
	close(_this->ctl_sock.cs_fd);
	control_cleanup(&_this->ctl_sock);

	for (i = countof(_this->iface) - 1; i >= 0; i--) {
		if (_this->iface[i].initialized != 0)
			npppd_iface_stop(&_this->iface[i]);
	}
	npppd_set_radish(_this, NULL);

	_this->finalizing = 1;
	npppd_reset_timer(_this);
}

static void
npppd_stop_really(npppd *_this)
{
	int i;
#if defined(USE_NPPPD_L2TP) || defined(USE_NPPPD_PPTP)
	int wait_again;

	wait_again = 0;

#ifdef	USE_NPPPD_L2TP
	if (!l2tpd_is_stopped(&_this->l2tpd))
		wait_again |= 1;
#endif
#ifdef	USE_NPPPD_PPTP
	if (!pptpd_is_stopped(&_this->pptpd))
		wait_again |= 1;
#endif
	if (wait_again != 0) {
		npppd_reset_timer(_this);
		return;
	}
#endif
	for (i = countof(_this->iface) - 1; i >= 0; i--) {
		npppd_iface_fini(&_this->iface[i]);
	}
	_this->finalized = 1;
}

/** finalize the npppd */
void
npppd_fini(npppd *_this)
{
	int i;
	npppd_auth_base *auth_base;

#ifdef USE_NPPPD_L2TP
	l2tpd_uninit(&_this->l2tpd);
#endif
#ifdef USE_NPPPD_PPTP
	pptpd_uninit(&_this->pptpd);
#endif
#ifdef USE_NPPPD_PPPOE
	pppoed_uninit(&_this->pppoed);
#endif
	for (slist_itr_first(&_this->realms);
	    slist_itr_has_next(&_this->realms);) {
		auth_base = slist_itr_next(&_this->realms);
		npppd_auth_destroy(auth_base);
	}
	for (i = countof(_this->iface) - 1; i >= 0; i--) {
		if (_this->iface[i].initialized != 0)
			npppd_iface_fini(&_this->iface[i]);
	}

	for (i = countof(_this->pool) - 1; i >= 0; i--) {
		if (_this->pool[i].initialized != 0)
			npppd_pool_uninit(&_this->pool[i]);
	}

	npppd_destroy_ipcp_stats(&_this->ipcpstats);

	signal_del(&_this->ev_sigterm);
	signal_del(&_this->ev_sigint);
	signal_del(&_this->ev_sighup);
	signal_del(&_this->ev_sigchld);

	npppd_conf_fini(&_this->conf);

	slist_fini(&_this->realms);

	if (_this->map_user_ppp != NULL)
		hash_free(_this->map_user_ppp);
}

/***********************************************************************
 * Timer related functions
 ***********************************************************************/
static void
npppd_reset_timer(npppd *_this)
{
	struct timeval tv;

	if (_this->finalizing != 0) {
		/* we can use the timer exclusively on finalizing */
		tv.tv_usec = 500000;
		tv.tv_sec = 0;
		evtimer_add(&_this->ev_timer, &tv);
	} else {
		tv.tv_usec = 0;
		tv.tv_sec = NPPPD_TIMER_TICK_IVAL;
		evtimer_add(&_this->ev_timer, &tv);
	}
}

static void
npppd_timer(int fd, short evtype, void *ctx)
{
	npppd *_this;

	_this = ctx;
	if (_this->finalizing != 0) {
		npppd_stop_really(_this); /* The timer has been reset */
		return;	/* we can use the timer exclusively on finalizing */
	}
	_this->secs += NPPPD_TIMER_TICK_IVAL;
	if (_this->reloading_count > 0) {
		_this->reloading_count -= NPPPD_TIMER_TICK_IVAL;
		if (_this->reloading_count <= 0) {
			npppd_reload0(_this);
			_this->reloading_count = 0;
		}
	} else {
		if ((_this->secs % TIMER_TICK_RUP(
			    NPPPD_AUTH_REALM_FINALIZER_INTERVAL)) == 0)
			npppd_auth_finalizer_periodic(_this);
	}

#ifdef USE_NPPPD_PPPOE
	if (pppoed_need_polling(&_this->pppoed))
		pppoed_reload_listeners(&_this->pppoed);
#endif
#ifdef USE_NPPPD_PIPEX
	pipex_periodic(_this);
#endif

	npppd_reset_timer(_this);
}

int
npppd_reset_routing_table(npppd *_this, int pool_only)
{
#ifndef	NO_ROUTE_FOR_POOLED_ADDRESS
	slist rtlist0;

	if (_this->iface[0].using_pppx) 
		return 0;

	slist_init(&rtlist0);
	if (rd2slist(_this->rd, &rtlist0) != 0)
		return 1;

	for (slist_itr_first(&rtlist0); slist_itr_has_next(&rtlist0); ) {
		struct radish *rd;
		struct sockaddr_npppd *snp;
		npppd_ppp *ppp;
		int is_first;

		rd = slist_itr_next(&rtlist0);
		snp = rd->rd_rtent;

		is_first = 1;
		for (snp = rd->rd_rtent; snp != NULL; snp = snp->snp_next) {
			switch (snp->snp_type) {
			case SNP_POOL:
			case SNP_DYN_POOL:
				if (is_first)
					in_route_add(&snp->snp_addr,
					    &snp->snp_mask, &loop,
					    LOOPBACK_IFNAME, RTF_BLACKHOLE, 0);
				break;

			case SNP_PPP:
				if (pool_only)
					break;
				ppp = snp->snp_data_ptr;
				if (ppp->ppp_framed_ip_netmask.s_addr
				    == 0xffffffffL) {
					in_host_route_add(&ppp->
					    ppp_framed_ip_address,
					    &ppp_iface(ppp)->ip4addr,
					    ppp_iface(ppp)->ifname,
					    MRU_IPMTU(ppp->peer_mru));
				} else {
					in_route_add(&ppp->
					    ppp_framed_ip_address,
					    &ppp->ppp_framed_ip_netmask,
					    &ppp_iface(ppp)->ip4addr,
					    ppp_iface(ppp)->ifname, 0,
					    MRU_IPMTU(ppp->peer_mru));
				}
				break;
			}
			is_first = 0;
		}

	}

	slist_fini(&rtlist0);
#endif
	return 0;
}

/***********************************************************************
 * Other npppd related functions.
 ***********************************************************************/
/**
 * Get the user's password.  Return 0 on success.
 *
 * @@param	username    Username who acquires password
 * @@param	password    A pointer to a buffer space to store the password.
 *			    Use NULL when you need to know only the length of
 *			    the password.
 * @@param	plpassword  A pointer to the length of the password parameter.
 *			    This function uses this parameter value and stores
 *			    the required length value pointed to by this
 *			    parameter.  Use NULL when use don't need to know
 *			    the password and its length.
 * @@return	If the function succeeds, 0 is returned.  The function returns
 *		1 if the username is unknown, returns 2 if the password buffer
 *		length is not enough.  It returns negative value for other
 *		errors.
 */
int
npppd_get_user_password(npppd *_this, npppd_ppp *ppp,
    const char *username, char *password, int *plpassword)
{
	char buf0[MAX_USERNAME_LENGTH];

	NPPPD_ASSERT(ppp->realm != NULL);
	return npppd_auth_get_user_password(ppp->realm,
	    npppd_auth_username_for_auth(ppp->realm, username, buf0), password,
	    plpassword);
}

/** Get the Framed-IP-Address attribute of the user */
struct in_addr *
npppd_get_user_framed_ip_address(npppd *_this, npppd_ppp *ppp,
    const char *username)
{

	if (ppp->peer_auth == 0) {
		ppp->realm_framed_ip_address.s_addr = 0;
		goto do_default;
	}
	NPPPD_ASSERT(ppp->realm != NULL);

	if (ppp->realm_framed_ip_address.s_addr != 0)
		return &ppp->realm_framed_ip_address;

	/* assign by the authentication realm */
	if (npppd_auth_get_framed_ip(ppp->realm, username,
	    &ppp->realm_framed_ip_address,
		    &ppp->realm_framed_ip_netmask) != 0)
		ppp->realm_framed_ip_address.s_addr = 0;

do_default:
	/* Use USER_SELECT if the realm doesn't specify the ip address */
	if (ppp->realm_framed_ip_address.s_addr == 0)
		ppp->realm_framed_ip_address.s_addr = INADDR_USER_SELECT;


	if (ppp->realm_framed_ip_address.s_addr == INADDR_USER_SELECT) {
		/* Use NAS_SELECT if USER_SELECT is not allowed by the config */
		if (!ppp_ipcp(ppp)->allow_user_select)
			ppp->realm_framed_ip_address.s_addr = INADDR_NAS_SELECT;
	}
	NPPPD_DBG((LOG_DEBUG, "%s() = %s", __func__,
	    inet_ntoa(ppp->realm_framed_ip_address)));

	return &ppp->realm_framed_ip_address;
}

/** XXX */
int
npppd_check_calling_number(npppd *_this, npppd_ppp *ppp)
{
	struct tunnconf *conf;
	int              lnumber, rval;
	char             number[NPPPD_PHONE_NUMBER_LEN + 1];

	conf = ppp_get_tunnconf(ppp);
	if (conf->callnum_check != 0) {
		lnumber = sizeof(number);
		if ((rval = npppd_auth_get_calling_number(ppp->realm,
		    ppp->username, number, &lnumber)) == 0)
			return
			    (strcmp(number, ppp->calling_number) == 0)? 1 : 0;
		if ((conf->callnum_check & NPPPD_CALLNUM_CHECK_STRICT) != 0)
			return 0;
	}

	return 1;
}

/**
 * This function finds a {@@link npppd_ppp} instance that is assigned the
 * specified ip address and returns it
 * @@param ipaddr	IP Address(Specify in network byte order)
 */
npppd_ppp *
npppd_get_ppp_by_ip(npppd *_this, struct in_addr ipaddr)
{
	struct sockaddr_npppd *snp;
	struct radish *rdp;
	struct sockaddr_in npppd_get_ppp_by_ip_sin4;

	npppd_get_ppp_by_ip_sin4.sin_family = AF_INET;
	npppd_get_ppp_by_ip_sin4.sin_len = sizeof(struct sockaddr_in);
	npppd_get_ppp_by_ip_sin4.sin_addr = ipaddr;
	if (_this->rd == NULL)
		return NULL;	/* no radix tree on startup */
	if (rd_match((struct sockaddr *)&npppd_get_ppp_by_ip_sin4, _this->rd,
	    &rdp)) {
		snp = rdp->rd_rtent;
		if (snp->snp_type == SNP_PPP)
			return snp->snp_data_ptr;
	}
	return NULL;
}

/**
 * This function finds {@@link npppd_ppp} instances that are authenticated
 * as the specified username and returns them as a {@@link slist} list.
 * @@param username	PPP Username.
 * @@return	{@@link slist} that contans the {@@link npppd_ppp} instances.
 * NULL may be returned if no instance has been found.
 */
static slist *
npppd_get_ppp_by_user(npppd *_this, const char *username)
{
	hash_link *hl;

	if ((hl = hash_lookup(_this->map_user_ppp, username)) != NULL)
		return hl->item;

	return NULL;
}

/**
 * This function finds a {@@link npppd_ppp} instance that matches the specified
 * ppp id and returns it.
 * @@param	id	{@@link npppd_ppp#id ppp's id}
 * @@return	This function returns the pointer if the instance which has
 *		specified ID is found, otherwise it returns NULL.
 */
npppd_ppp *
npppd_get_ppp_by_id(npppd *_this, u_int ppp_id)
{
	slist users;
	npppd_ppp *ppp0, *ppp;

	NPPPD_ASSERT(_this != NULL);

	ppp = NULL;
	slist_init(&users);
	if (npppd_get_all_users(_this, &users) != 0) {
		log_printf(LOG_WARNING,
		    "npppd_get_all_users() failed in %s()", __func__);
	} else {
		/* FIXME: This linear search eats CPU. */
		for (slist_itr_first(&users); slist_itr_has_next(&users); ) {
			ppp0 = slist_itr_next(&users);
			if (ppp0->id == ppp_id) {
				ppp = ppp0;
				break;
			}
		}
	}
	slist_fini(&users);

	return ppp;
}

static struct ipcpstat *
npppd_get_ipcp_stat(struct ipcpstat_head *head , const char *ipcp_name)
{
	struct ipcpstat *ipcpstat = NULL;

	LIST_FOREACH(ipcpstat, head, entry) {
		if (strncmp(ipcpstat->name, ipcp_name,
		    sizeof(ipcpstat->name)) == 0)
			return ipcpstat;
	}

	return NULL;
}

static void
npppd_destroy_ipcp_stats(struct ipcpstat_head *head)
{
	struct ipcpstat	*ipcpstat, *tipcpstat;
	npppd_ppp	*ppp, *tppp;

	LIST_FOREACH_SAFE(ipcpstat, head, entry, tipcpstat) {
		LIST_FOREACH_SAFE(ppp, &ipcpstat->ppp, ipcpstat_entry, tppp) {
			ppp->ipcpstat = NULL;
			LIST_REMOVE(ppp, ipcpstat_entry);
		}
		free(ipcpstat);
	}
}

static void
npppd_ipcp_stats_reload(npppd *_this)
{
	struct ipcpstat		*ipcpstat, *tipcpstat;
	struct ipcpconf		*ipcpconf;
	struct ipcpstat_head	 destroy_list;

	LIST_INIT(&destroy_list);
	LIST_FOREACH_SAFE(ipcpstat, &_this->ipcpstats, entry, tipcpstat) {
		LIST_REMOVE(ipcpstat, entry);
		LIST_INSERT_HEAD(&destroy_list, ipcpstat, entry);
	}

	TAILQ_FOREACH(ipcpconf, &_this->conf.ipcpconfs, entry) {
		ipcpstat = npppd_get_ipcp_stat(&destroy_list, ipcpconf->name);
		if (ipcpstat != NULL) {
			LIST_REMOVE(ipcpstat, entry);
			LIST_INSERT_HEAD(&_this->ipcpstats, ipcpstat, entry);
			continue;
		}

		ipcpstat = malloc(sizeof(*ipcpstat));
		if (ipcpstat == NULL) {
			log_printf(LOG_ERR, "initializing ipcp_stats failed : %m");
			continue;
		}
		memset(ipcpstat, 0, sizeof(*ipcpstat));
		strlcpy(ipcpstat->name, ipcpconf->name, sizeof(ipcpconf->name));
		LIST_INSERT_HEAD(&_this->ipcpstats, ipcpstat, entry);
	}
	npppd_destroy_ipcp_stats(&destroy_list);
}

/**
 * Checks whether the user reaches the maximum session limit
 * (user_max_serssion).
 * @@return	This function returns 1(true) if the user does not reach the
 *		limit, otherwise it returns 0(false).
 */
int
npppd_check_user_max_session(npppd *_this, npppd_ppp *ppp)
{
	int global_count, realm_count;
	npppd_ppp *ppp1;
	slist *uppp;

	/* user_max_session == 0 means unlimit */
	if (_this->conf.user_max_session == 0 &&
	    npppd_auth_user_session_unlimited(ppp->realm))
		return 1;

	global_count = realm_count = 0;
	if ((uppp = npppd_get_ppp_by_user(_this, ppp->username)) != NULL) {
		for (slist_itr_first(uppp); slist_itr_has_next(uppp); ) {
			ppp1 = slist_itr_next(uppp);
			if (ppp->realm == ppp1->realm)
				realm_count++;
			global_count++;
		}
	}

	if (npppd_check_auth_user_max_session(ppp->realm, realm_count)) {
		ppp_log(ppp, LOG_WARNING,
		    "user %s exceeds user-max-session limit per auth",
		    ppp->username);
		return 0;
	} else if (_this->conf.user_max_session != 0 &&
	    _this->conf.user_max_session <= global_count) {
		ppp_log(ppp, LOG_WARNING,
		    "user %s exceeds user-max-session limit", ppp->username);
		return 0;
	} else
		return 1;
}

/***********************************************************************
 * Network I/O ralated functions.
 ***********************************************************************/
/**
 * Call this function to output packets to the network(tun).  This function
 * currently assumes the packet is a IPv4 datagram.
 */
void
npppd_network_output(npppd *_this, npppd_ppp *ppp, int proto, u_char *pktp,
    int lpktp)
{
	struct ip *pip;
	int lbuf;
	u_char buf[256];	/* enough size for TCP/IP header */

	NPPPD_ASSERT(ppp != NULL);

	if (!ppp_ip_assigned(ppp))
		return;

	if (lpktp < sizeof(struct ip)) {
		ppp_log(ppp, LOG_DEBUG, "Received IP packet is too small");
		return;
	}
	lbuf = MINIMUM(lpktp, sizeof(buf));
	if (!ALIGNED_POINTER(pktp, struct ip)) {
		memcpy(buf, pktp, lbuf);
		pip = (struct ip *)buf;
	} else {
		pip = (struct ip *)pktp;
	}

	if (ppp->ingress_filter != 0 &&
	    (pip->ip_src.s_addr & ppp->ppp_framed_ip_netmask.s_addr)
		    != (ppp->ppp_framed_ip_address.s_addr &
			ppp->ppp_framed_ip_netmask.s_addr)) {
		char logbuf[80];
		strlcpy(logbuf, inet_ntoa(pip->ip_dst), sizeof(logbuf));
		ppp_log(ppp, LOG_INFO,
		    "Drop packet by ingress filter.  %s => %s",
		    inet_ntoa(pip->ip_src), logbuf);

		return;
	}
	if (ppp->timeout_sec > 0 && !ip_is_idle_packet(pip, lbuf))
		ppp_reset_idle_timeout(ppp);

#ifndef NO_ADJUST_MSS
	if (ppp->adjust_mss) {
		if (lpktp == lbuf) {
			/*
			 * We can assume the packet length is less than
			 * sizeof(buf).
			 */
			if (!ALIGNED_POINTER(pktp, struct ip))
				pktp = buf;
			adjust_tcp_mss(pktp, lpktp, MRU_IPMTU(ppp->peer_mru));
		}
	}
#endif
	npppd_iface_write(ppp_iface(ppp), ppp, proto, pktp, lpktp);
}

#ifdef USE_NPPPD_PIPEX
/***********************************************************************
 * PIPEX related functions
 ***********************************************************************/
static void
pipex_setup_common(npppd_ppp *ppp, struct pipex_session_req *req)
{
	memset(req, 0, sizeof(*req));
	if (psm_opt_is_accepted(&ppp->lcp, acfc))
		req->pr_ppp_flags |= PIPEX_PPP_ACFC_ENABLED;
	if (psm_peer_opt_is_accepted(&ppp->lcp, acfc))
		req->pr_ppp_flags |= PIPEX_PPP_ACFC_ACCEPTED;

	if (psm_peer_opt_is_accepted(&ppp->lcp, pfc))
		req->pr_ppp_flags |= PIPEX_PPP_PFC_ACCEPTED;
	if (psm_opt_is_accepted(&ppp->lcp, pfc))
		req->pr_ppp_flags |= PIPEX_PPP_PFC_ENABLED;

	if (ppp->has_acf != 0)
		req->pr_ppp_flags |= PIPEX_PPP_HAS_ACF;

	if (ppp->adjust_mss != 0)
		req->pr_ppp_flags |= PIPEX_PPP_ADJUST_TCPMSS;
	if (ppp->ingress_filter != 0)
		req->pr_ppp_flags |= PIPEX_PPP_INGRESS_FILTER;

	req->pr_ip_srcaddr = ppp->pppd->iface[0].ip4addr;
	req->pr_ip_address = ppp->ppp_framed_ip_address;
	req->pr_ip_netmask = ppp->ppp_framed_ip_netmask;
	req->pr_peer_mru = ppp->peer_mru;
	req->pr_ppp_id = ppp->id;

	req->pr_timeout_sec = ppp->timeout_sec;

#ifdef USE_NPPPD_MPPE
	req->pr_ccp_id = ppp->ccp.fsm.id;
	if (ppp->mppe.send.keybits > 0) {
		memcpy(req->pr_mppe_send.master_key,
		    ppp->mppe.send.master_key,
		    sizeof(req->pr_mppe_send.master_key));
		req->pr_mppe_send.stateless = ppp->mppe.send.stateless;
		req->pr_mppe_send.keylenbits = ppp->mppe.send.keybits;
		req->pr_ppp_flags |= PIPEX_PPP_MPPE_ENABLED;
	}
	if (ppp->mppe.recv.keybits > 0) {
		memcpy(req->pr_mppe_recv.master_key,
		    ppp->mppe.recv.master_key,
		    sizeof(req->pr_mppe_recv.master_key));
		req->pr_mppe_recv.stateless = ppp->mppe.recv.stateless;
		req->pr_mppe_recv.keylenbits = ppp->mppe.recv.keybits;
		req->pr_ppp_flags |= PIPEX_PPP_MPPE_ACCEPTED;
	}
	if (ppp->mppe.required)
		req->pr_ppp_flags |= PIPEX_PPP_MPPE_REQUIRED;
#endif /* USE_NPPPD_MPPE */
}

/** Enable PIPEX of the {@@link npppd_ppp ppp} */
int
npppd_ppp_pipex_enable(npppd *_this, npppd_ppp *ppp)
{
	struct pipex_session_req req;
#ifdef	USE_NPPPD_PPPOE
	pppoe_session *pppoe;
#endif
#ifdef	USE_NPPPD_PPTP
	pptp_call *call;
#endif
#ifdef	USE_NPPPD_L2TP
	l2tp_call *l2tp;
	l2tp_ctrl *l2tpctrl;
#endif
	int error;

	NPPPD_ASSERT(ppp != NULL);
	NPPPD_ASSERT(ppp->phy_context != NULL);
	NPPPD_ASSERT(ppp->use_pipex != 0);

	pipex_setup_common(ppp, &req);

	switch (ppp->tunnel_type) {
#ifdef USE_NPPPD_PPPOE
	case NPPPD_TUNNEL_PPPOE:
	    {
		struct sockaddr *sa;
		struct ether_header *eh;
		pppoe = (pppoe_session *)ppp->phy_context;

		/* PPPoE specific informations */
		req.pr_protocol = PIPEX_PROTO_PPPOE;
		req.pr_session_id = pppoe->session_id;
		req.pr_peer_session_id = 0;
		strlcpy(req.pr_proto.pppoe.over_ifname,
		    pppoe_session_listen_ifname(pppoe),
		    sizeof(req.pr_proto.pppoe.over_ifname));

		sa = (struct sockaddr *)&req.pr_peer_address;
		sa->sa_family = AF_UNSPEC;
		sa->sa_len = sizeof(struct sockaddr);

		eh = (struct ether_header *)sa->sa_data;
		eh->ether_type = htons(ETHERTYPE_PPPOE);
		memcpy(eh->ether_dhost, pppoe->ether_addr, ETHER_ADDR_LEN);
		memset(eh->ether_shost, 0, ETHER_ADDR_LEN);

		break;
	    }
#endif
#ifdef USE_NPPPD_PPTP
	case NPPPD_TUNNEL_PPTP:
		call = (pptp_call *)ppp->phy_context;

		/* PPTP specific informations */
		req.pr_session_id = call->id;
		req.pr_protocol = PIPEX_PROTO_PPTP;

		req.pr_peer_session_id = call->peers_call_id;
		req.pr_proto.pptp.snd_nxt = call->snd_nxt;
		req.pr_proto.pptp.snd_una = call->snd_una;
		req.pr_proto.pptp.rcv_nxt = call->rcv_nxt;
		req.pr_proto.pptp.rcv_acked = call->rcv_acked;
		req.pr_proto.pptp.winsz = call->winsz;
		req.pr_proto.pptp.maxwinsz = call->maxwinsz;
		req.pr_proto.pptp.peer_maxwinsz = call->peers_maxwinsz;

		NPPPD_ASSERT(call->ctrl->peer.ss_family == AF_INET);
		NPPPD_ASSERT(call->ctrl->our.ss_family == AF_INET);

		memcpy(&req.pr_peer_address, &call->ctrl->peer,
		    call->ctrl->peer.ss_len);
		memcpy(&req.pr_local_address, &call->ctrl->our,
		    call->ctrl->our.ss_len);
		break;
#endif
#ifdef USE_NPPPD_L2TP
	case NPPPD_TUNNEL_L2TP:
		l2tp = (l2tp_call *)ppp->phy_context;
		l2tpctrl = l2tp->ctrl;

		/* L2TPv2 specific context */
		/* Session KEYS */
		req.pr_protocol = PIPEX_PROTO_L2TP;
		req.pr_proto.l2tp.tunnel_id = l2tpctrl->tunnel_id;
		req.pr_proto.l2tp.peer_tunnel_id = l2tpctrl->peer_tunnel_id;
		req.pr_session_id = l2tp->session_id;
		req.pr_peer_session_id = l2tp->peer_session_id;

		if (l2tpctrl->data_use_seq)
			req.pr_proto.l2tp.option_flags |=
			    PIPEX_L2TP_USE_SEQUENCING;

		/* transmission control contexts */
		req.pr_proto.l2tp.ns_nxt = l2tp->snd_nxt;
		req.pr_proto.l2tp.nr_nxt = l2tp->rcv_nxt;

		memcpy(&req.pr_peer_address, &l2tpctrl->peer,
		    l2tpctrl->peer.ss_len);
		memcpy(&req.pr_local_address, &l2tpctrl->sock,
		    l2tpctrl->sock.ss_len);
#ifdef USE_SA_COOKIE
		if (l2tpctrl->sa_cookie != NULL) {
			req.pr_proto.l2tp.ipsecflowinfo =
			    ((struct in_ipsec_sa_cookie *)l2tpctrl->sa_cookie)
				    ->ipsecflow;
		}
#endif
		break;
#endif
	default:
		return 1;
	}

	if ((error = ioctl(_this->iface[ppp->ifidx].devf, PIPEXASESSION, &req))
	    != 0) {
		if (errno == ENXIO)	/* pipex is disabled on runtime */
			error = 0;
		ppp->pipex_enabled = 0;
		return error;
	}

	if (_this->iface[ppp->ifidx].using_pppx) {
		struct pipex_session_descr_req descr_req;

		descr_req.pdr_protocol = req.pr_protocol;
		descr_req.pdr_session_id = req.pr_session_id;
		memset(descr_req.pdr_descr, 0, sizeof(descr_req.pdr_descr));
		strlcpy(descr_req.pdr_descr, ppp->username, sizeof(descr_req.pdr_descr));
		error = ioctl(_this->iface[ppp->ifidx].devf, PIPEXSIFDESCR, &descr_req);
		if (error != 0) {
			log_printf(LOG_WARNING, "PIPEXSIFDESCR(%s) failed: %d\n", ppp->username, error);
		}
	}

	ppp->pipex_enabled = 1;
	if (ppp->timeout_sec > 0) {
		/* Stop the npppd's idle-timer.  We use pipex's idle-timer */
		ppp->timeout_sec = 0;
		ppp_reset_idle_timeout(ppp);
	}

	return error;
}

/** Disable PIPEX of the {@@link npppd_ppp ppp} */
int
npppd_ppp_pipex_disable(npppd *_this, npppd_ppp *ppp)
{
	struct pipex_session_close_req req;
#ifdef USE_NPPPD_PPPOE
	pppoe_session *pppoe;
#endif
#ifdef USE_NPPPD_PPTP
	pptp_call *call;
#endif
#ifdef USE_NPPPD_L2TP
	l2tp_call *l2tp;
#endif
	int error;

	if (ppp->pipex_started == 0)
		return 0;	/* not started */

	bzero(&req, sizeof(req));
	switch(ppp->tunnel_type) {
#ifdef USE_NPPPD_PPPOE
	case NPPPD_TUNNEL_PPPOE:
		pppoe = (pppoe_session *)ppp->phy_context;

		/* PPPoE specific informations */
		req.pcr_protocol = PIPEX_PROTO_PPPOE;
		req.pcr_session_id = pppoe->session_id;
		break;
#endif
#ifdef USE_NPPPD_PPTP
	case NPPPD_TUNNEL_PPTP:
		call = (pptp_call *)ppp->phy_context;

		/* PPTP specific informations */
		req.pcr_session_id = call->id;
		req.pcr_protocol = PIPEX_PROTO_PPTP;
		break;
#endif
#ifdef USE_NPPPD_L2TP
	case NPPPD_TUNNEL_L2TP:
		l2tp = (l2tp_call *)ppp->phy_context;

		/* L2TP specific context */
		req.pcr_session_id = l2tp->session_id;
		req.pcr_protocol = PIPEX_PROTO_L2TP;
		break;
#endif
	default:
		return 1;
	}

	error = ioctl(_this->iface[ppp->ifidx].devf, PIPEXDSESSION, &req);
	if (error == 0) {
		ppp->ipackets += req.pcr_stat.ipackets;
		ppp->opackets += req.pcr_stat.opackets;
		ppp->ierrors += req.pcr_stat.ierrors;
		ppp->oerrors += req.pcr_stat.oerrors;
		ppp->ibytes += req.pcr_stat.ibytes;
		ppp->obytes += req.pcr_stat.obytes;
		ppp->pipex_enabled = 0;
	}

	return error;
}

/* XXX: s/npppd_ppp_pipex_ip_disable/npppd_ppp_pipex_stop/ ?? */

/** Stop PIPEX of the {@@link npppd_ppp ppp} */
static int
npppd_ppp_pipex_ip_disable(npppd *_this, npppd_ppp *ppp)
{
	struct pipex_session_config_req req;
#ifdef USE_NPPPD_PPPOE
	pppoe_session *pppoe;
#endif
#ifdef USE_NPPPD_PPTP
	pptp_call *call;
#endif
#ifdef USE_NPPPD_L2TP
	l2tp_call *l2tp;
#endif
	if (ppp->pipex_started == 0)
		return 0;	/* not started */

	bzero(&req, sizeof(req));
	switch(ppp->tunnel_type) {
#ifdef USE_NPPPD_PPPOE
	case NPPPD_TUNNEL_PPPOE:
		pppoe = (pppoe_session *)ppp->phy_context;

		/* PPPoE specific informations */
		req.pcr_protocol = PIPEX_PROTO_PPPOE;
		req.pcr_session_id = pppoe->session_id;
		break;
#endif
#ifdef USE_NPPPD_PPTP
	case NPPPD_TUNNEL_PPTP:
		call = (pptp_call *)ppp->phy_context;

		/* PPTP specific informations */
		req.pcr_session_id = call->id;
		req.pcr_protocol = PIPEX_PROTO_PPTP;
		break;
#endif
#ifdef USE_NPPPD_L2TP
	case NPPPD_TUNNEL_L2TP:
		l2tp = (l2tp_call *)ppp->phy_context;

		/* L2TP specific context */
		req.pcr_session_id = l2tp->session_id;
		req.pcr_protocol = PIPEX_PROTO_L2TP;
		break;
#endif
	default:
		return 1;
	}
	req.pcr_ip_forward = 0;

	return ioctl(_this->iface[ppp->ifidx].devf, PIPEXCSESSION, &req);
}

static void
pipex_periodic(npppd *_this)
{
	struct pipex_session_list_req  req;
	npppd_ppp                     *ppp;
	int                            i, devf, error;
	u_int                          ppp_id;
	slist                          dlist, users;

	slist_init(&dlist);
	slist_init(&users);

	devf = -1;
	for (i = 0; i < nitems(_this->iface); i++) {
		if (_this->iface[i].initialized != 0) {
			devf = _this->iface[i].devf;
			break;
		}
	}
	if (devf >= 0) {
		do {
			error = ioctl(devf, PIPEXGCLOSED, &req);
			if (error) {
				if (errno != ENXIO)
					log_printf(LOG_WARNING,
					    "PIPEXGCLOSED failed: %m");
				break;
			}
			for (i = 0; i < req.plr_ppp_id_count; i++) {
				ppp_id = req.plr_ppp_id[i];
				slist_add(&dlist, (void *)(uintptr_t)ppp_id);
			}
		} while (req.plr_flags & PIPEX_LISTREQ_MORE);
	}

	if (slist_length(&dlist) <= 0)
		goto pipex_done;
	if (npppd_get_all_users(_this, &users) != 0) {
		log_printf(LOG_WARNING,
		    "npppd_get_all_users() failed in %s()", __func__);
		slist_fini(&users);
		goto pipex_done;
	}

	/* Disconnect request */
	slist_itr_first(&dlist);
	while (slist_itr_has_next(&dlist)) {
		/* FIXME: Linear search by PPP Id eats CPU */
		ppp_id = (uintptr_t)slist_itr_next(&dlist);
		slist_itr_first(&users);
		ppp = NULL;
		while (slist_itr_has_next(&users)) {
			ppp =  slist_itr_next(&users);
			if (ppp_id == ppp->id) {
				/* found */
				slist_itr_remove(&users);
				break;
			}
			ppp = NULL;
		}
		if (ppp == NULL) {
			log_printf(LOG_WARNING,
			    "kernel requested a ppp down, but it's not found.  "
			    "ppp=%d", ppp_id);
			continue;
		}
		ppp_log(ppp, LOG_INFO, "Stop requested by the kernel");
		/* TODO: PIPEX doesn't return the disconect reason */
#ifdef USE_NPPPD_RADIUS
		ppp_set_radius_terminate_cause(ppp,
		    RADIUS_TERMNATE_CAUSE_IDLE_TIMEOUT);
#endif
		ppp_stop(ppp, NULL);
	}
pipex_done:
	slist_fini(&users);
	slist_fini(&dlist);
}
#endif /* USE_NPPPD_PIPEX */

/***********************************************************************
 * IP address assignment related functions
 ***********************************************************************/
/** Prepare to use IP */
int
npppd_prepare_ip(npppd *_this, npppd_ppp *ppp)
{

	if (ppp_ipcp(ppp) == NULL)
		return 1;

	npppd_get_user_framed_ip_address(_this, ppp, ppp->username);

	if (npppd_iface_ip_is_ready(ppp_iface(ppp)))
		ppp->ipcp.ip4_our = ppp_iface(ppp)->ip4addr;
	else if (npppd_iface_ip_is_ready(&_this->iface[0]))
		ppp->ipcp.ip4_our = _this->iface[0].ip4addr;
	else
		return -1;
	ppp->ipcp.dns_pri = ppp_ipcp(ppp)->dns_servers[0];
	ppp->ipcp.dns_sec = ppp_ipcp(ppp)->dns_servers[1];
	ppp->ipcp.nbns_pri = ppp_ipcp(ppp)->nbns_servers[0];
	ppp->ipcp.nbns_sec = ppp_ipcp(ppp)->nbns_servers[1];

	return 0;
}

/** Notify stop using IP to npppd and release the resources. */
void
npppd_release_ip(npppd *_this, npppd_ppp *ppp)
{

	if (!ppp_ip_assigned(ppp))
		return;

	npppd_set_ip_enabled(_this, ppp, 0);
	npppd_pool_release_ip(ppp->assigned_pool, ppp);
	ppp->assigned_pool = NULL;
	ppp->ppp_framed_ip_address.s_addr = 0;
}

/**
 * Change IP enableness.  When the enableness is change, npppd will operate
 * the route entry.
 */
void
npppd_set_ip_enabled(npppd *_this, npppd_ppp *ppp, int enabled)
{
	int was_enabled, found;
	slist *u;
	hash_link *hl;
	npppd_ppp *ppp1;

	NPPPD_ASSERT(ppp_ip_assigned(ppp));
	NPPPD_DBG((LOG_DEBUG,
	    "npppd_set_ip_enabled(%s/%s, %s)", ppp->username,
		inet_ntoa(ppp->ppp_framed_ip_address),
		(enabled)?"true" : "false"));

	/*
	 * Don't do anything if the enableness is not change.  Changing route
	 * makes many programs will wake up and do heavy operations, it causes
	 * system overload, so we refrain useless changing route.
	 */
	enabled = (enabled)? 1 : 0;
	was_enabled = (ppp->assigned_ip4_enabled != 0)? 1 : 0;
	if (enabled == was_enabled)
		return;

	ppp->assigned_ip4_enabled = enabled;
	if (enabled) {
		if (ppp->username[0] != '\0') {
			if ((u = npppd_get_ppp_by_user(_this, ppp->username))
			    == NULL) {
				if ((u = malloc(sizeof(slist))) == NULL) {
					ppp_log(ppp, LOG_ERR,
					    "Out of memory on %s: %m",
					    __func__);
				} else {
					slist_init(u);
					slist_set_size(u, 4);
					hash_insert(_this->map_user_ppp,
					    ppp->username, u);
					NPPPD_DBG((LOG_DEBUG,
					    "hash_insert(user->ppp, %s)",
					    ppp->username));
				}
			}
			if (u != NULL)	/* above malloc() may failed */
				slist_add(u, ppp);
		}

#ifndef	NO_ROUTE_FOR_POOLED_ADDRESS
		if (_this->iface[ppp->ifidx].using_pppx == 0) {
			if (ppp->snp.snp_next != NULL)
				/*
				 * There is a blackhole route that has same
				 * address/mask.
				 */
				in_route_delete(&ppp->ppp_framed_ip_address,
				    &ppp->ppp_framed_ip_netmask, &loop,
				    RTF_BLACKHOLE);
			/* See the comment for MRU_IPMTU() on ppp.h */
			if (ppp->ppp_framed_ip_netmask.s_addr == 0xffffffffL) {
				in_host_route_add(&ppp->ppp_framed_ip_address,
				    &ppp_iface(ppp)->ip4addr,
				    ppp_iface(ppp)->ifname,
				    MRU_IPMTU(ppp->peer_mru));
			} else {
				in_route_add(&ppp->ppp_framed_ip_address,
				    &ppp->ppp_framed_ip_netmask,
				    &ppp_iface(ppp)->ip4addr,
				    ppp_iface(ppp)->ifname, 0,
				    MRU_IPMTU(ppp->peer_mru));
			}
		}
#endif
	} else {
#ifndef	NO_ROUTE_FOR_POOLED_ADDRESS
		if (_this->iface[ppp->ifidx].using_pppx == 0) {
			if (ppp->ppp_framed_ip_netmask.s_addr == 0xffffffffL) {
				in_host_route_delete(&ppp->ppp_framed_ip_address,
				    &ppp_iface(ppp)->ip4addr);
			} else {
				in_route_delete(&ppp->ppp_framed_ip_address,
				    &ppp->ppp_framed_ip_netmask,
				    &ppp_iface(ppp)->ip4addr, 0);
			}
			if (ppp->snp.snp_next != NULL)
				/*
				 * There is a blackhole route that has same
				 * address/mask.
				 */
				in_route_add(&ppp->snp.snp_addr,
				    &ppp->snp.snp_mask, &loop, LOOPBACK_IFNAME,
				    RTF_BLACKHOLE, 0);
		}
#endif
		if (ppp->username[0] != '\0') {
			hl = hash_lookup(_this->map_user_ppp, ppp->username);
			NPPPD_ASSERT(hl != NULL);
			if (hl == NULL) {
				ppp_log(ppp, LOG_ERR,
				    "Unexpected error: cannot find user(%s) "
				    "from user database", ppp->username);
				return;
			}
			found = 0;
			u = hl->item;
			for (slist_itr_first(u); slist_itr_has_next(u);) {
				ppp1 = slist_itr_next(u);
				if (ppp1 == ppp) {
					slist_itr_remove(u);
					found++;
					break;
				}
			}
			if (found == 0) {
				ppp_log(ppp, LOG_ERR,
				    "Unexpected error: PPP instance is "
				    "not found in the user's list.");
			}
			NPPPD_ASSERT(found != 0);
			if (slist_length(u) <= 0) {
				/* The last PPP */
				NPPPD_DBG((LOG_DEBUG,
				    "hash_delete(user->ppp, %s)",
				    ppp->username));
				if (hash_delete(_this->map_user_ppp,
				    ppp->username, 0) != 0) {
					ppp_log(ppp, LOG_ERR,
					    "Unexpected error: cannot delete "
					    "user(%s) from user database",
					    ppp->username);
				}
				slist_fini(u);
				free(u);
			} else {
				/* Replace the reference. */
				ppp1 = slist_get(u, 0);
				hl->key = ppp1->username;
			}
		}
#ifdef USE_NPPPD_PIPEX
		if (npppd_ppp_pipex_ip_disable(_this, ppp) != 0)
			ppp_log(ppp, LOG_ERR,
			    "npppd_ppp_pipex_ip_disable() failed: %m");
#endif /* USE_NPPPD_PIPEX */
	}
}

/**
 * Assign the IP address.  Returning "struct in_addr" is stored IP address
 * in network byte order.
 * @@param req_ip4	IP address request to assign.  If the address is used
 * already, this function will return fail.
 */
int
npppd_assign_ip_addr(npppd *_this, npppd_ppp *ppp, uint32_t req_ip4)
{
	uint32_t ip4, ip4mask;
	int dyna, rval, fallback_dyna;
	const char *reason = "out of the pool";
	struct sockaddr_npppd *snp;
	npppd_pool *pool;
	npppd_auth_base *realm;

	NPPPD_DBG((LOG_DEBUG, "%s() assigned=%s", __func__,
	    (ppp_ip_assigned(ppp))? "true" : "false"));
	if (ppp_ip_assigned(ppp))
		return 0;

	ip4 = INADDR_ANY;
	ip4mask = 0xffffffffL;
	realm = ppp->realm;
	dyna = 0;
	fallback_dyna = 0;
	pool = NULL;

	if (ppp->realm_framed_ip_address.s_addr == INADDR_USER_SELECT) {
		if (req_ip4 == INADDR_ANY)
			dyna = 1;
	} else if (ppp->realm_framed_ip_address.s_addr == INADDR_NAS_SELECT) {
		dyna = 1;
	} else {
		NPPPD_ASSERT(realm != NULL);
		fallback_dyna = 1;
		req_ip4 = ntohl(ppp->realm_framed_ip_address.s_addr);
		ip4mask = ntohl(ppp->realm_framed_ip_netmask.s_addr);
	}
	if (!dyna) {
		/*
		 * Realm requires the fixed IP address, but the address
		 * doesn't belong any address pool.  Fallback to dynamic
		 * assignment.
		 */
		pool = ppp_pool(ppp);
		rval = npppd_pool_get_assignability(pool, req_ip4, ip4mask,
		    &snp);
		switch (rval) {
		case ADDRESS_OK:
			if (snp->snp_type == SNP_POOL) {
				/*
				 * Fixed address pool can be used only if the
				 * realm specified to use it.
				 */
				if (ppp->realm_framed_ip_address
				    .s_addr != INADDR_USER_SELECT)
					ip4 = req_ip4;
				break;
			}
			ppp->assign_dynapool = 1;
			ip4 = req_ip4;
			break;
		case ADDRESS_RESERVED:
			reason = "reserved";
			break;
		case ADDRESS_OUT_OF_POOL:
			reason = "out of the pool";
			break;
		case ADDRESS_BUSY:
			fallback_dyna = 0;
			reason = "busy";
			break;
		default:
		case ADDRESS_INVALID:
			fallback_dyna = 0;
			reason = "invalid";
			break;
		}
#define	IP_4OCT(v) ((0xff000000 & (v)) >> 24), ((0x00ff0000 & (v)) >> 16),\
	    ((0x0000ff00 & (v)) >> 8), (0x000000ff & (v))
		if (ip4 == 0) {
			ppp_log(ppp, LOG_NOTICE,
			    "Requested IP address (%d.%d.%d.%d)/%d "
			    "is %s", IP_4OCT(req_ip4),
			    netmask2prefixlen(htonl(ip4mask)), reason);
			if (fallback_dyna)
				goto dyna_assign;
			return 1;
		}
		ppp->assigned_pool = pool;

		ppp->ppp_framed_ip_address.s_addr = htonl(ip4);
		ppp->ppp_framed_ip_netmask.s_addr = htonl(ip4mask);
		ppp->acct_framed_ip_address = ppp->ppp_framed_ip_address;
	} else {
dyna_assign:
		pool = ppp_pool(ppp);
		ip4 = npppd_pool_get_dynamic(pool, ppp);
		if (ip4 == 0) {
			ppp_log(ppp, LOG_NOTICE,
			    "No free address in the pool.");
			return 1;
		}
		ppp->assigned_pool = pool;
		ppp->assign_dynapool = 1;
		ppp->ppp_framed_ip_address.s_addr = htonl(ip4);
		ppp->ppp_framed_ip_netmask.s_addr = htonl(0xffffffffL);
		ppp->acct_framed_ip_address = ppp->ppp_framed_ip_address;
	}

	return npppd_pool_assign_ip(ppp->assigned_pool, ppp);
}

static void *
rtlist_remove(slist *prtlist, struct radish *radish)
{
	struct radish *r;

	slist_itr_first(prtlist);
	while (slist_itr_has_next(prtlist)) {
		r = slist_itr_next(prtlist);
		if (!sockaddr_npppd_match(radish->rd_route, r->rd_route) ||
		    !sockaddr_npppd_match(radish->rd_mask, r->rd_mask))
			continue;

		return slist_itr_remove(prtlist);
	}

	return NULL;
}

/** Set {@@link ::npppd#rd the only radish of npppd} */
int
npppd_set_radish(npppd *_this, void *radish_head)
{
	int rval, delppp0, count;
	struct sockaddr_npppd *snp;
	struct radish *radish, *r;
	slist rtlist0, rtlist1, delppp;
	npppd_ppp *ppp;
	void *dummy;

	slist_init(&rtlist0);
	slist_init(&rtlist1);
	slist_init(&delppp);

	if (radish_head != NULL) {
		if (rd2slist(radish_head, &rtlist1) != 0) {
			log_printf(LOG_WARNING, "rd2slist failed: %m");
			goto fail;
		}
	}
	if (_this->rd != NULL) {
		if (rd2slist(_this->rd, &rtlist0) != 0) {
			log_printf(LOG_WARNING, "rd2slist failed: %m");
			goto fail;
		}
	}
	if (_this->rd != NULL && radish_head != NULL) {
		for (slist_itr_first(&rtlist0); slist_itr_has_next(&rtlist0);) {
			radish = slist_itr_next(&rtlist0);
			snp = radish->rd_rtent;
		    /*
		     * replace the pool address
		     */
			if (snp->snp_type == SNP_POOL ||
			    snp->snp_type == SNP_DYN_POOL) {
				if (rd_lookup(radish->rd_route, radish->rd_mask,
					    radish_head) == NULL)
					continue;
				/* don't add */
				rtlist_remove(&rtlist1, radish);
				/* don't delete */
				slist_itr_remove(&rtlist0);
				continue;
			}
		    /*
		     * handle the active PPP sessions.
		     */
			NPPPD_ASSERT(snp->snp_type == SNP_PPP);
			ppp =  snp->snp_data_ptr;

			/* Don't delete the route of active PPP session */
			slist_itr_remove(&rtlist0);

			/* clear informations about old pool configuration */
			snp->snp_next = NULL;

			delppp0 = 0;
			if (!rd_match((struct sockaddr *)snp, radish_head, &r)){
				/*
				 * If the address doesn't belong the new pools,
				 * add the PPP session to the deletion list.
				 */
				slist_add(&delppp, snp->snp_data_ptr);
				delppp0 = 1;
			} else {
				NPPPD_ASSERT(
				    ((struct sockaddr_npppd *)r->rd_rtent)
					->snp_type == SNP_POOL ||
				    ((struct sockaddr_npppd *)r->rd_rtent)
					->snp_type == SNP_DYN_POOL);
				/*
				 * If there is a pool entry that has same
				 * address/mask, then make the RADISH entry a
				 * list.  Set SNP_PPP as the first in the list,
				 * set current entry in snp->snp_next and
				 * delete it.
				 */
				if (sockaddr_npppd_match(
					    radish->rd_route, r->rd_route) &&
				    sockaddr_npppd_match(
					    radish->rd_mask, r->rd_mask)) {
					/*
					 * Releasing it, so remove it from the
					 * new routing list.
					 */
					rtlist_remove(&rtlist1, radish);
					/* set as snp_snp_next */
					snp->snp_next = r->rd_rtent;
					rval = rd_delete(r->rd_route,
					    r->rd_mask, radish_head, &dummy);
					NPPPD_ASSERT(rval == 0);
				}
			}
			/* Register to the new radish */
			rval = rd_insert(radish->rd_route, radish->rd_mask,
			    radish_head, snp);
			if (rval != 0) {
				errno = rval;
				ppp_log(((npppd_ppp *)snp->snp_data_ptr),
				    LOG_ERR,
				    "Fatal error on %s, cannot continue "
				    "this ppp session: %m", __func__);
				if (!delppp0)
					slist_add(&delppp, snp->snp_data_ptr);
			}
		}
	}
	count = 0;
#ifndef	NO_ROUTE_FOR_POOLED_ADDRESS
	if (_this->iface[0].using_pppx == 0) {
		for (slist_itr_first(&rtlist0); slist_itr_has_next(&rtlist0);) {
			radish = slist_itr_next(&rtlist0);
			in_route_delete(&SIN(radish->rd_route)->sin_addr,
			    &SIN(radish->rd_mask)->sin_addr, &loop,
			    RTF_BLACKHOLE);
			count++;
		}
		if (count > 0)
			log_printf(LOG_INFO,
			    "Deleted %d routes for old pool addresses", count);

		count = 0;
		for (slist_itr_first(&rtlist1); slist_itr_has_next(&rtlist1);) {
			radish = slist_itr_next(&rtlist1);
			in_route_add(&(SIN(radish->rd_route)->sin_addr),
			    &SIN(radish->rd_mask)->sin_addr, &loop,
			    LOOPBACK_IFNAME, RTF_BLACKHOLE, 0);
			count++;
		}
		if (count > 0)
			log_printf(LOG_INFO,
				    "Added %d routes for new pool addresses",
				    count);
	}
#endif
	slist_fini(&rtlist0);
	slist_fini(&rtlist1);

	if (_this->rd != NULL) {
		npppd_rd_walktree_delete(_this->rd);
		_this->rd = NULL;
	}
	if (radish_head == NULL)
		npppd_get_all_users(_this, &delppp);
	_this->rd = radish_head;

	for (slist_itr_first(&delppp); slist_itr_has_next(&delppp);) {
		ppp = slist_itr_next(&delppp);
                ppp_log(ppp, LOG_NOTICE,
                    "stop.  IP address of this ppp is out of the pool.: %s",
                    inet_ntoa(ppp->ppp_framed_ip_address));
		ppp_stop(ppp, NULL);
	}
	slist_fini(&delppp);

	return 0;
fail:
	slist_fini(&rtlist0);
	slist_fini(&rtlist1);
	slist_fini(&delppp);

	return 1;
}

/**
 * This function stores all users to {@@link slist} and returns them.
 * References to {@@link ::npppd_ppp} will be stored in users.
 */
static int
npppd_get_all_users(npppd *_this, slist *users)
{
	int rval;
	struct radish *rd;
	struct sockaddr_npppd *snp;
	slist list;

	NPPPD_ASSERT(_this != NULL);

	slist_init(&list);
	if (_this->rd == NULL)
		return 0;
	rval = rd2slist(_this->rd, &list);
	if (rval != 0)
		return rval;

	for (slist_itr_first(&list); slist_itr_has_next(&list);) {
		rd = slist_itr_next(&list);
		snp = rd->rd_rtent;
		if (snp->snp_type == SNP_PPP) {
			if (slist_add(users, snp->snp_data_ptr) == NULL) {
				log_printf(LOG_ERR,
				    "slist_add() failed in %s: %m", __func__);
				goto fail;
			}
		}
	}
	slist_fini(&list);

	return 0;
fail:
	slist_fini(&list);

	return 1;
}

static int
rd2slist_walk(struct radish *rd, void *list0)
{
	slist *list = list0;
	void *r;

	r = slist_add(list, rd);
	if (r == NULL)
		return -1;
	return 0;
}
static int
rd2slist(struct radish_head *h, slist *list)
{
	return rd_walktree(h, rd2slist_walk, list);
}

static void
npppd_reload0(npppd *_this)
{
	int  i;

	npppd_reload_config(_this);
#ifdef USE_NPPPD_ARP
	arp_set_strictintfnetwork(npppd_config_str_equali(_this, "arpd.strictintfnetwork", "true", ARPD_STRICTINTFNETWORK_DEFAULT));
	if (npppd_config_str_equali(_this, "arpd.enabled", "true", ARPD_DEFAULT) == 1)
        	arp_sock_init();
	else
		arp_sock_fini();
#endif
	npppd_modules_reload(_this);
	npppd_ifaces_load_config(_this);
	npppd_update_pool_reference(_this);
	npppd_auth_finalizer_periodic(_this);
	npppd_ipcp_stats_reload(_this);

	for (i = 0; i < countof(_this->iface); i++) {
		if (_this->iface[i].initialized != 0 &&
		    _this->iface[i].started == 0)
			npppd_iface_start(&_this->iface[i]);
	}
}

static void
npppd_update_pool_reference(npppd *_this)
{
	int  i, j;
	/* update iface to pool reference */
	for (i = 0; i < countof(_this->iface_pool); i++) {
		_this->iface_pool[i] = NULL;
		if (_this->iface[i].initialized == 0)
			continue;
		if (_this->iface[i].ipcpconf == NULL)
			continue;	/* no IPCP for this interface */

		for (j = 0; j < countof(_this->pool); j++) {
			if (_this->pool[j].initialized == 0)
				continue;
			if (strcmp(_this->iface[i].ipcpconf->name,
			    _this->pool[j].ipcp_name) == 0) {
				/* found the ipcp that has the pool */
				_this->iface_pool[i] = &_this->pool[j];
				break;
			}
		}
	}
}

/***********************************************************************
 * Signal handlers
 ***********************************************************************/
static void
npppd_on_sighup(int fd, short ev_type, void *ctx)
{
	npppd *_this;

	_this = ctx;
#ifndef	NO_DELAYED_RELOAD
	if (_this->delayed_reload > 0)
		_this->reloading_count = _this->delayed_reload;
	else
#endif
		npppd_reload0(_this);
}

static void
npppd_on_sigterm(int fd, short ev_type, void *ctx)
{
	npppd *_this;

	_this = ctx;
	npppd_stop(_this);
}

static void
npppd_on_sigint(int fd, short ev_type, void *ctx)
{
	npppd *_this;

	_this = ctx;
	npppd_stop(_this);
}

static void
npppd_on_sigchld(int fd, short ev_type, void *ctx)
{
	int status;
	pid_t wpid;
	npppd *_this;

	_this = ctx;
	wpid = privsep_priv_pid();
	if (wait4(wpid, &status, WNOHANG, NULL) == wpid) {
		if (WIFSIGNALED(status))
			log_printf(LOG_WARNING,
			    "privileged process exits abnormaly.  signal=%d",
			    WTERMSIG(status));
		else
			log_printf(LOG_WARNING,
			    "privileged process exits abnormaly.  status=%d",
			    WEXITSTATUS(status));
		_this->stop_by_error = 1;
		npppd_stop(_this);
	}
}
/***********************************************************************
 * Miscellaneous functions
 ***********************************************************************/
static uint32_t
str_hash(const void *ptr, int sz)
{
	uint32_t hash = 0;
	int i, len;
	const char *str;

	str = ptr;
	len = strlen(str);
	for (i = 0; i < len; i++)
		hash = hash*0x1F + str[i];
	hash = (hash << 16) ^ (hash & 0xffff);

	return hash % sz;
}

/**
 * Select a authentication realm that is for given {@@link ::npppd_ppp PPP}.
 * Return 0 on success.
 */
int
npppd_ppp_bind_realm(npppd *_this, npppd_ppp *ppp, const char *username, int
    eap_required)
{
	struct confbind *bind;
	npppd_auth_base *realm = NULL, *realm0 = NULL, *realm1 = NULL;
	char             buf1[MAX_USERNAME_LENGTH];
	int              lsuffix, lusername, lmax;

	NPPPD_ASSERT(_this != NULL);
	NPPPD_ASSERT(ppp != NULL);
	NPPPD_ASSERT(username != NULL);

	/*
	 * If the PPP suffix is the longest, and the length of the suffix is
	 * same, select the first one.
	 */
	lusername = strlen(username);
	lmax = -1;
	realm = NULL;

	TAILQ_FOREACH(bind, &_this->conf.confbinds, entry) {
		if (strcmp(bind->tunnconf->name, ppp->phy_label) != 0)
			continue;

		realm0 = NULL;
		slist_itr_first(&_this->realms);
		while (slist_itr_has_next(&_this->realms)) {
			realm1 = slist_itr_next(&_this->realms);
			if (!npppd_auth_is_usable(realm1))
				continue;
			if (eap_required && !npppd_auth_is_eap_capable(realm1))
				continue;
			if (strcmp(npppd_auth_get_name(realm1),
			    bind->authconf->name) == 0) {
				realm0 = realm1;
				break;
			}
		}
		if (realm0 == NULL)
			continue;

		lsuffix = strlen(npppd_auth_get_suffix(realm0));
		if (lsuffix > lmax &&
		    (lsuffix == 0 ||
			(lsuffix < lusername && strcmp(username + lusername
				- lsuffix, npppd_auth_get_suffix(realm0))
				== 0))) {
			lmax = lsuffix;
			realm = realm0;
		}
	}

	if (realm == NULL) {
		log_printf(LOG_INFO, "user='%s' could not bind any realms",
		    username);
		return 1;
	}
	NPPPD_DBG((LOG_DEBUG, "bind realm %s", npppd_auth_get_name(realm)));

	if (npppd_auth_get_type(realm) == NPPPD_AUTH_TYPE_LOCAL)
		/* hook the auto reload */
		npppd_auth_get_user_password(realm,
		    npppd_auth_username_for_auth(realm1, username, buf1), NULL,
			NULL);
	ppp->realm = realm;

	return 0;
}

/** Is assigned realm a LOCAL authentication? */
int
npppd_ppp_is_realm_local(npppd *_this, npppd_ppp *ppp)
{
	NPPPD_ASSERT(_this != NULL);
	NPPPD_ASSERT(ppp != NULL);

	if (ppp->realm == NULL)
		return 0;

	return (npppd_auth_get_type(ppp->realm) == NPPPD_AUTH_TYPE_LOCAL)
	    ? 1 : 0;
}

/** Is assigned realm a RADIUS authentication? */
int
npppd_ppp_is_realm_radius(npppd *_this, npppd_ppp *ppp)
{
	NPPPD_ASSERT(_this != NULL);
	NPPPD_ASSERT(ppp != NULL);

	if (ppp->realm == NULL)
		return 0;

	return (npppd_auth_get_type(ppp->realm) == NPPPD_AUTH_TYPE_RADIUS)
	    ? 1 : 0;
}

/** Is assigned realm usable? */
int
npppd_ppp_is_realm_ready(npppd *_this, npppd_ppp *ppp)
{
	if (ppp->realm == NULL)
		return 0;

	return npppd_auth_is_ready(ppp->realm);
}

/** Return the name of assigned realm */
const char *
npppd_ppp_get_realm_name(npppd *_this, npppd_ppp *ppp)
{
	if (ppp->realm == NULL)
		return "(none)";
	return npppd_auth_get_name(ppp->realm);
}

/** Return the interface name that bound given {@@link ::npppd_ppp PPP} */
const char *
npppd_ppp_get_iface_name(npppd *_this, npppd_ppp *ppp)
{
	if (ppp == NULL || ppp->ifidx < 0)
		return "(not binding)";
	return ppp_iface(ppp)->ifname;
}

/** Is the interface usable? */
int
npppd_ppp_iface_is_ready(npppd *_this, npppd_ppp *ppp)
{
	return (npppd_iface_ip_is_ready(ppp_iface(ppp)) &&
	    ppp_ipcp(ppp) != NULL)? 1 : 0;
}

/** Select a suitable interface for {@@link :npppd_ppp PPP} and bind them  */
int
npppd_ppp_bind_iface(npppd *_this, npppd_ppp *ppp)
{
	int              i, ifidx;
	struct confbind *bind;
	struct ipcpstat *ipcpstat;

	NPPPD_ASSERT(_this != NULL);
	NPPPD_ASSERT(ppp != NULL);

	if (ppp->ifidx >= 0)
		return 0;

	TAILQ_FOREACH(bind, &_this->conf.confbinds, entry) {
		if (strcmp(bind->tunnconf->name, ppp->phy_label) != 0)
			continue;
		if (ppp->realm == NULL) {
			if (bind->authconf == NULL)
				break;
		} else if (strcmp(bind->authconf->name,
		    npppd_auth_get_name(ppp->realm)) == 0)
			break;
	}
	if (bind == NULL)
		return 1;

	/* Search a interface */
	ifidx = -1;
	for (i = 0; i < countof(_this->iface); i++) {
		if (_this->iface[i].initialized == 0)
			continue;
		if (strcmp(_this->iface[i].ifname, bind->iface->name) == 0)
			ifidx = i;
	}
	if (ifidx < 0)
		return 1;

	ppp->ifidx = ifidx;
	NPPPD_ASSERT(ppp_ipcp(ppp) != NULL);
	ipcpstat = npppd_get_ipcp_stat(&_this->ipcpstats, ppp_ipcp(ppp)->name);
	if (ipcpstat == NULL) {
		ppp_log(ppp, LOG_WARNING, "Unknown IPCP %s",
		    ppp_ipcp(ppp)->name);
		ppp->ifidx = -1; /* unbind inteface */
		return 1;
	}
	if (ppp_ipcp(ppp)->max_session > 0 &&
	    ipcpstat->nsession >= ppp_ipcp(ppp)->max_session) {
		ppp_log(ppp, LOG_WARNING,
		    "Number of sessions per IPCP reaches out of the limit=%d",
		    ppp_ipcp(ppp)->max_session);
		ppp->ifidx = -1; /* unbind inteface */
		return 1;
	}

	if (_this->conf.max_session > 0 &&
	    _this->nsession >= _this->conf.max_session) {
		ppp_log(ppp, LOG_WARNING,
		    "Number of sessions reaches out of the limit=%d",
		    _this->conf.max_session);
		ppp->ifidx = -1; /* unbind inteface */
		return 1;
	}
	_this->nsession++;

	LIST_INSERT_HEAD(&ipcpstat->ppp, ppp, ipcpstat_entry);
	ppp->ipcpstat = ipcpstat;
	ipcpstat->nsession++;

	return 0;
}

/** Unbind the interface from the {@@link ::npppd_ppp PPP} */
void
npppd_ppp_unbind_iface(npppd *_this, npppd_ppp *ppp)
{
	if (ppp->ifidx >= 0) {
		_this->nsession--;
		if (ppp->ipcpstat!= NULL) {
			ppp->ipcpstat->nsession--;
			LIST_REMOVE(ppp, ipcpstat_entry);
		}
	}
	ppp->ifidx = -1;
}

static int
npppd_rd_walktree_delete(struct radish_head *rh)
{
	void *dummy;
	struct radish *rd;
	slist list;

	slist_init(&list);
	if (rd2slist(rh, &list) != 0)
		return 1;
	for (slist_itr_first(&list); slist_itr_has_next(&list);) {
		rd = slist_itr_next(&list);
		rd_delete(rd->rd_route, rd->rd_mask, rh, &dummy);
	}
	slist_fini(&list);

	free(rh);

	return 0;
}

#ifdef USE_NPPPD_RADIUS
/**
 * Return radius_req_setting for the given {@@link ::npppd_ppp PPP}.
 * @@return return NULL if no usable RADIUS setting.
 */
void *
npppd_get_radius_auth_setting(npppd *_this, npppd_ppp *ppp)
{
	NPPPD_ASSERT(_this != NULL);
	NPPPD_ASSERT(ppp != NULL);

	if (ppp->realm == NULL)
		return NULL;
	if (!npppd_ppp_is_realm_radius(_this, ppp))
		return NULL;

	return npppd_auth_radius_get_radius_auth_setting(ppp->realm);
}
#endif

/** Finalize authentication realm */
static void
npppd_auth_finalizer_periodic(npppd *_this)
{
	int ndisposing = 0, refcnt;
	slist users;
	npppd_auth_base *auth_base;
	npppd_ppp *ppp;

	/*
	 * For the realms with disposing flag, if the realm has assigned PPPs,
	 * disconnect them.  If all PPPs are disconnected then free the realm.
	 */
	NPPPD_DBG((DEBUG_LEVEL_2, "%s() called", __func__));
	slist_itr_first(&_this->realms);
	while (slist_itr_has_next(&_this->realms)) {
		auth_base = slist_itr_next(&_this->realms);
		if (!npppd_auth_is_disposing(auth_base))
			continue;
		refcnt = 0;
		if (ndisposing++ == 0) {
			slist_init(&users);
			if (npppd_get_all_users(_this, &users) != 0) {
				log_printf(LOG_WARNING,
				    "npppd_get_all_users() failed in %s(): %m",
				    __func__);
				break;
			}
		}
		slist_itr_first(&users);
		while (slist_itr_has_next(&users)) {
			ppp = slist_itr_next(&users);
			if (ppp->realm == auth_base) {
				refcnt++;
				ppp_stop(ppp, NULL);
				ppp_log(ppp, LOG_INFO,
				    "Stop request by npppd.  Binding "
				    "authentication realm is disposing.  "
				    "realm=%s", npppd_auth_get_name(auth_base));
				slist_itr_remove(&users);
			}
		}
		if (refcnt == 0) {
			npppd_auth_destroy(auth_base);
			slist_itr_remove(&_this->realms);
		}
	}
	if (ndisposing > 0)
		slist_fini(&users);
}

/** compare sockaddr_npppd.  return 0 if matches */
int
sockaddr_npppd_match(void *a0, void *b0)
{
	struct sockaddr_npppd *a, *b;

	a = a0;
	b = b0;

	return (a->snp_addr.s_addr == b->snp_addr.s_addr)? 1 : 0;
}

/**
 * This function stores the username for authentication to the space specified
 * by username_buffer and returns it.  username_buffer must have space more
 * than MAX_USERNAME_LENGTH.
 */
const char *
npppd_ppp_get_username_for_auth(npppd *_this, npppd_ppp *ppp,
    const char *username, char *username_buffer)
{
	NPPPD_ASSERT(_this != NULL);
	NPPPD_ASSERT(ppp != NULL);
	NPPPD_ASSERT(ppp->realm != NULL);

	return npppd_auth_username_for_auth(ppp->realm, username,
	    username_buffer);
}

const char *
npppd_tunnel_protocol_name(int tunn_protocol)
{
	switch (tunn_protocol) {
	case NPPPD_TUNNEL_NONE:
		return "None";
	case NPPPD_TUNNEL_L2TP:
		return "L2TP";
	case NPPPD_TUNNEL_PPTP:
		return "PPTP";
	case NPPPD_TUNNEL_PPPOE:
		return "PPPoE";
	case NPPPD_TUNNEL_SSTP:
		return "SSTP";
	}

	return "Error";
}

const char *
npppd_ppp_tunnel_protocol_name(npppd *_this, npppd_ppp *ppp)
{
	return npppd_tunnel_protocol_name(ppp->tunnel_type);
}

struct tunnconf *
npppd_get_tunnconf(npppd *_this, const char *name)
{
	struct tunnconf *conf;

	TAILQ_FOREACH(conf, &_this->conf.tunnconfs, entry) {
		if (strcmp(conf->name, name) == 0)
			return conf;
	}

	return NULL;
}

void
npppd_on_ppp_start(npppd *_this, npppd_ppp *ppp)
{
	struct ctl_conn  *c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (npppd_ctl_add_started_ppp_id(c->ctx, ppp->id) == 0) {
			npppd_ctl_imsg_compose(c->ctx, &c->iev.ibuf);
			imsg_event_add(&c->iev);
		}
	}
}

void
npppd_on_ppp_stop(npppd *_this, npppd_ppp *ppp)
{
	struct ctl_conn  *c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (npppd_ctl_add_stopped_ppp(c->ctx, ppp) == 0) {
			npppd_ctl_imsg_compose(c->ctx, &c->iev.ibuf);
			imsg_event_add(&c->iev);
		}
	}
}

void
imsg_event_add(struct imsgev *iev)
{
	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev->data);
	event_add(&iev->ev, NULL);
}
@


1.46
log
@add a new option to set limits on user-max-sessions each AUTHENTICATION.

It can set limits on different user-max-sessions if there're using several
protocols such as PPPoE and L2TP/IPsec.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.45 2017/04/18 03:28:04 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.45 2017/04/18 03:28:04 yasuoka Exp $
d108 4
d246 2
d295 2
d324 12
d512 2
d816 62
d1951 1
d2205 1
d2237 18
d2260 1
a2262 1
	ppp->ifidx = ifidx;
d2265 4
d2276 1
a2276 1
	if (ppp->ifidx >= 0)
d2278 5
@


1.45
log
@Warn if pipex(4) is disabled but the configuration uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.44 2017/04/18 03:25:22 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.44 2017/04/18 03:25:22 yasuoka Exp $
d803 1
a803 1
	int count;
d808 2
a809 1
	if (_this->conf.user_max_session == 0)
d812 1
a812 1
	count = 0;
d816 3
a818 3
			if (strcmp(ppp_iface(ppp)->ifname,
			    ppp_iface(ppp1)->ifname) == 0)
				count++;
d822 12
a833 1
	return (count < _this->conf.user_max_session)? 1 : 0;
@


1.44
log
@Delete #include lines which are unnecessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.43 2015/12/05 16:10:31 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.43 2015/12/05 16:10:31 yasuoka Exp $
d238 6
a243 3
	int i, status = -1;
	const char *pidpath0;
	FILE *pidfp = NULL;
d292 11
@


1.43
log
@Pass the pppx_hdr when sending packets through the pppx device and use the
ppp_id in the pppx_hdr to find the associated ppp when receiving the packets
from the device.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.42 2015/11/09 01:14:22 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.42 2015/11/09 01:14:22 yasuoka Exp $
a82 7
#if defined(__NetBSD__)
#include <net/if_ether.h>
#else
#include <netinet/if_ether.h>
#endif
#include <netinet/ip_var.h>
#include <net/if_types.h>
@


1.42
log
@Remove -h from the command line options.

diff from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.41 2015/06/24 04:57:55 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.41 2015/06/24 04:57:55 yasuoka Exp $
d877 1
a877 1
	npppd_iface_write(ppp_iface(ppp), proto, pktp, lpktp);
@


1.41
log
@Use the return value of event_loop() properly.  Also abort(3) if
event_loop() returns abnormally which is unexpected.

diff from Yuuichi Someya
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.40 2015/01/19 01:48:59 deraadt Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.40 2015/01/19 01:48:59 deraadt Exp $
d101 1
a101 1
static void         usage (void);
d148 1
a148 1
	while ((ch = getopt(argc, argv, "nf:dh")) != -1) {
d160 1
a160 2
		case '?':
		case 'h':
a161 1
			exit(1);
d166 1
a166 1
	if (argc != 0) {
a167 2
		exit(1);
	}
d224 2
a225 2
static void
usage()
d227 2
a228 1
	fprintf(stderr, "usage: npppd [-dhn] [-f config_file]\n");
@


1.40
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.39 2015/01/08 07:34:05 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.39 2015/01/08 07:34:05 yasuoka Exp $
d389 1
a389 1
	while ((event_loop(EVLOOP_ONCE)) == 0) {
d393 1
a393 1
	if (rval != 0)
d395 2
@


1.39
log
@Count number of sessions correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.38 2014/11/13 04:03:53 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.38 2014/11/13 04:03:53 yasuoka Exp $
d35 1
a37 1
#include <sys/param.h>
d842 1
a842 1
	lbuf = MIN(lpktp, sizeof(buf));
@


1.38
log
@When the pool address is changed and there is a PPP session which uses
the pool to be deleted, then the PPP session is to be deleted. But the
internal radish tree had kept the deleted session.  This causes
"use-after-free", and it had made npppd crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.37 2014/10/25 03:23:49 lteo Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.37 2014/10/25 03:23:49 lteo Exp $
d2134 1
a2134 1
	    _this->nsession++ >= _this->conf.max_session) {
d2141 1
d2150 2
a2151 1
	_this->nsession--;
@


1.37
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.36 2014/07/08 18:49:27 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.36 2014/07/08 18:49:27 yasuoka Exp $
d1754 1
a1763 1
	_this->rd = radish_head;
@


1.36
log
@Fix npppd not to access freed memory when it is exiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.35 2014/03/22 04:30:31 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.35 2014/03/22 04:30:31 yasuoka Exp $
a40 1
#include <netinet/in_systm.h>
@


1.35
log
@Reimplement control part of npppd(8) with imsg.  Also add "monitor"
command for npppctl(8) to monitor PPP session start/stop events.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.34 2014/03/22 04:23:17 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.34 2014/03/22 04:23:17 yasuoka Exp $
d1749 1
a1749 1
	if (_this->rd != NULL)
d1751 2
@


1.34
log
@Fixed a bug in npppd_auth_get_user() which caused segmentation faults after
a user authentication is succeeded in case the authentication config option
has `username-suffix' and 'strip-atmark-realm' is yes. Delete
`username-prefix' from authentication setting.  This config option was
mis-leading and useless.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.33 2014/03/22 04:21:04 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.33 2014/03/22 04:21:04 yasuoka Exp $
d99 17
a115 15
static void            npppd_reload0 (npppd *);
static void            npppd_update_pool_reference (npppd *);
static int             npppd_rd_walktree_delete(struct radish_head *);
static void            usage (void);
static void            npppd_stop_really (npppd *);
static uint32_t        str_hash(const void *, int);
static void            npppd_on_sighup (int, short, void *);
static void            npppd_on_sigterm (int, short, void *);
static void            npppd_on_sigint (int, short, void *);
static void            npppd_on_sigchld (int, short, void *);
static void            npppd_reset_timer(npppd *);
static void            npppd_timer(int, short, void *);
static void            npppd_auth_finalizer_periodic(npppd *);
static int  rd2slist_walk (struct radish *, void *);
static int  rd2slist (struct radish_head *, slist *);
d317 12
a328 1

a374 3
	npppd_ctl_init(&_this->ctl, _this, NPPPD_CTL_SOCK_PATH);
	if ((status = npppd_ctl_start(&_this->ctl)) != 0)
		return status;
a411 3
#ifdef	USE_NPPPD_NPPPD_CTL
	npppd_ctl_stop(&_this->ctl);
#endif
d415 3
d743 1
a743 1
slist *
d1777 1
a1777 1
int
d2311 37
@


1.33
log
@In RADIUS accounting, realm_framed_ip_address was mistakenly used for
Framed-IP-Address.  acct_framed_ip_address should be used for that purpose.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.32 2013/09/13 03:25:28 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.32 2013/09/13 03:25:28 yasuoka Exp $
d1958 1
a1958 1
	int              lsuffix, lprefix, lusername, lmax;
a1998 7
			/* check prefix */
			lprefix = strlen(npppd_auth_get_prefix(realm0));
			if (lprefix > 0 &&
			    strncmp(username, npppd_auth_get_prefix(realm0),
				    lprefix) != 0)
				continue;

@


1.32
log
@fix some gcc warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.31 2013/06/03 23:26:57 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.31 2013/06/03 23:26:57 yasuoka Exp $
d1562 1
d1576 1
@


1.31
log
@Stop doing pipex ioctl if no tunnel interface is configured.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.30 2013/04/20 23:32:32 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.30 2013/04/20 23:32:32 yasuoka Exp $
a249 1
	long seed;
@


1.30
log
@Don't use random() because it's not safe.  Use arc4random() instead of
it.  Suggested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.29 2013/04/20 07:00:19 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.29 2013/04/20 07:00:19 yasuoka Exp $
d1203 1
a1203 1
	int                            i, error;
d1209 5
a1213 6
	do {
		error = ioctl(_this->iface[0].devf, PIPEXGCLOSED, &req);
		if (error) {
			if (errno != ENXIO)
				log_printf(LOG_WARNING,
				    "PIPEXGCLOSED failed: %m");
d1216 16
a1231 5
		for (i = 0; i < req.plr_ppp_id_count; i++) {
			ppp_id = req.plr_ppp_id[i];
			slist_add(&dlist, (void *)(uintptr_t)ppp_id);
		}
	} while (req.plr_flags & PIPEX_LISTREQ_MORE);
@


1.29
log
@PPPoE server was broken since last configuration rework.  Calling
pppoed_init() was accidentally deleted. Revert it in npppd_init() and
rearrange l2tpd_init() and pptpd_init() to the same place.

ok todd
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.28 2013/04/16 07:42:27 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.28 2013/04/16 07:42:27 yasuoka Exp $
a113 1
static inline void     seed_random(long *);
d282 1
a282 5
	/* initialize random seeds */
	seed_random(&seed);
	srandom(seed);

	_this->boot_id = (uint32_t)random();
a2256 19
}

static inline void
seed_random(long *seed)
{
	struct timeval t;
#ifdef KERN_URND
	size_t seedsiz;
	int mib[] = { CTL_KERN, KERN_URND };

	seedsiz = sizeof(*seed);
	if (sysctl(mib, countof(mib), seed, &seedsiz, NULL, 0) == 0) {
		NPPPD_ASSERT(seedsiz == sizeof(long));
		return;
	}
	log_printf(LOG_WARNING, "Could not set random seed from the system: %m");
#endif
	gettimeofday(&t, NULL);
	*seed = gethostid() ^ t.tv_sec ^ t.tv_usec ^ getpid();
@


1.28
log
@Fixed `max-session' and `user-max-session'.  They has been broken by the
configuration reworking.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.27 2013/02/13 22:10:38 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.27 2013/02/13 22:10:38 yasuoka Exp $
d289 12
@


1.27
log
@Pipex did panic when the 0 length mppe is given by ioctl.  Return
EINVAL instead of panic.  Also npppd called ioctl with the invalid
argument because of the bugs introduced by the config parser change
commit.  Fixed those bugs and make sure not to use 0 length keys for
MPPE.

reported by csszep at gmail and giovanni
ok giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.26 2012/12/05 23:20:26 deraadt Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.26 2012/12/05 23:20:26 deraadt Exp $
d787 1
a787 1
	if (_this->user_max_session == 0)
d800 1
a800 1
	return (count < _this->user_max_session)? 1 : 0;
d2111 2
a2112 1
	if (_this->max_session > 0 && _this->nsession++ >= _this->max_session) {
d2115 1
a2115 1
		    _this->max_session);
@


1.26
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.25 2012/11/13 17:10:40 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.25 2012/11/13 17:10:40 yasuoka Exp $
d902 14
a915 11
	memcpy(req->pr_mppe_send.master_key,
	    ppp->mppe.send.master_key, sizeof(req->pr_mppe_send.master_key));
	req->pr_mppe_send.stateless = ppp->mppe.send.stateless;
	req->pr_mppe_send.keylenbits = ppp->mppe.send.keybits;

	memcpy(req->pr_mppe_recv.master_key,
	    ppp->mppe.recv.master_key, sizeof(req->pr_mppe_recv.master_key));
	req->pr_mppe_recv.stateless = ppp->mppe.recv.stateless;
	req->pr_mppe_recv.keylenbits = ppp->mppe.recv.keybits;

	if (ppp->mppe_started != 0) {
a916 1
		req->pr_ppp_flags |= PIPEX_PPP_MPPE_ENABLED;
@


1.25
log
@Add accept.c from ldpd and use it to handle file descriptor exhaustion
in accept() case.

"go for it" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.24 2012/09/28 23:46:00 yasuoka Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Internet Initiative Japan Inc.
d32 1
a32 1
 * $Id: npppd.c,v 1.24 2012/09/28 23:46:00 yasuoka Exp $
a33 1
#include <sys/cdefs.h>
a34 12
#ifndef LINT
__COPYRIGHT(
"@@(#) npppd - PPP daemon for PPP Access Concentrators\n"
"@@(#) Version " VERSION "\n"
"@@(#) \n"
"@@(#) Copyright 2005-2008\n"
"@@(#) 	Internet Initiative Japan Inc.  All rights reserved.\n"
"@@(#) \n"
"@@(#) \n"
"@@(#) \n"
);
#endif
@


1.24
log
@framed-ip-address and framed-ip-netmask were not working.

pointed out by Andrew Ngo.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.23 2012/09/20 20:28:09 jmc Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.23 2012/09/20 20:28:09 jmc Exp $
d107 3
d322 2
@


1.23
log
@various fixes; ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.22 2012/09/19 17:50:17 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.22 2012/09/19 17:50:17 yasuoka Exp $
d1548 1
@


1.22
log
@cleanup around the pipex.  naming style, delete or update comments.
no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.21 2012/09/18 13:14:08 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.21 2012/09/18 13:14:08 yasuoka Exp $
d241 1
a241 1
	fprintf(stderr, "usage: npppd [-hdn] [-f config_file]\n");
@


1.21
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.20 2012/07/17 03:18:57 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.20 2012/07/17 03:18:57 yasuoka Exp $
d968 1
a968 1
		sa = (struct sockaddr *)&req.peer_address;
d1000 1
a1000 1
		memcpy(&req.peer_address, &call->ctrl->peer,
d1002 1
a1002 1
		memcpy(&req.local_address, &call->ctrl->our,
d1027 1
a1027 1
		memcpy(&req.peer_address, &l2tpctrl->peer,
d1029 1
a1029 1
		memcpy(&req.local_address, &l2tpctrl->sock,
@


1.20
log
@use IPsec flowinfo on pipex(4) to select the IPsec tunnel for sending
L2TP packets.

ok markus henning
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.19 2012/07/16 18:05:36 markus Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.19 2012/07/16 18:05:36 markus Exp $
d109 2
a110 1
static void            npppd_reload0(npppd *);
a112 1
static void            npppd_start (npppd *);
d148 1
d153 3
a155 3
	int ch, stop_by_error, ll_adjust = 0, runasdaemon = 0;
	extern char *optarg;
	const char *npppd_conf0 = DEFAULT_NPPPD_CONF;
d158 1
a158 1
	while ((ch = getopt(argc, argv, "Dc:dhs")) != -1) {
d160 2
a161 2
		case 's':
			ll_adjust++;
d163 1
a163 1
		case 'c':
a165 3
		case 'D':
			runasdaemon = 1;
			break;
d168 1
d176 13
d190 1
a192 5
	} else {
		debug_set_syslog_level_adjust(ll_adjust);
		openlog(NULL, LOG_PID, LOG_NPPPD);
		if (runasdaemon)
			daemon(0, 0);
d194 2
d207 7
d241 1
a241 9
	fprintf(stderr,
	    "usage: npppd [-sDdh] [-c config_file]\n"
	    "\t-d: increase debuglevel.  Output log to standard error.\n"
	    "\t-c: specify configuration file.  default=\"%s\".\n"
	    "\t-s: adjust syslog level to be silent.\n"
	    "\t-D: run as a daemon.\n"
	    "\t-h: show usage.\n"
	    , DEFAULT_NPPPD_CONF
	);
a258 1
	char pidpath[MAXPATHLEN];
a259 1
	const char *coredir;
a260 1
	char	cwd[MAXPATHLEN];
d273 1
d315 1
a315 18
	if ((pidpath0 = npppd_config_str(_this, "pidfile")) == NULL)
		pidpath0 = DEFAULT_NPPPD_PIDFILE;

	/* Runtime directory */
	if ((coredir = npppd_config_str(_this, "coredir")) == NULL) {
		/* diretory for pid file */
		strlcpy(pidpath, pidpath0, sizeof(pidpath));
		strlcpy(cwd, dirname(pidpath), sizeof(cwd));
	}
	else {
		/* directory for dumping core */
		strlcpy(cwd, coredir, sizeof(cwd));
	}
	if (chdir(cwd) != 0) {
		log_printf(LOG_ERR, "chdir(%s,) failed in %s(): %m", __func__,
		    cwd);
		return -1;
	}
d367 6
a372 1
	return npppd_modules_reload(_this);
d443 1
a443 2
		if (_this->iface[i].initialized != 0)
			npppd_iface_fini(&_this->iface[i]);
a472 2
	for (i = 0; i < countof(_this->iface_bind); i++)
		slist_fini(&_this->iface_bind[i].pools);
d484 1
a484 2
	if (_this->properties != NULL)
		properties_destroy(_this->properties);
d654 1
a654 12
	if (ppp->realm_framed_ip_address.s_addr != 0) {
#if 1
/*
 * FIXME: This fix is ad hok, it overwrites the ip address here if assigning
 * FIXME: IP address by RADIUS is prohibited.  This will make a bug when a
 * FIXME: new authentication type is add.  Fix this until then.
 */
		if ((ppp_ipcp(ppp)->ip_assign_flags & NPPPD_IP_ASSIGN_RADIUS)
		    == 0) {
			ppp->realm_framed_ip_netmask.s_addr = 0;
		} else
#endif
a655 1
	}
d657 5
a661 8
	ppp->realm_framed_ip_netmask.s_addr = 0xffffffffL;
	if ((ppp_ipcp(ppp)->ip_assign_flags & NPPPD_IP_ASSIGN_FIXED) != 0) {
		/* assign by the authentication realm */
		if (npppd_auth_get_framed_ip(ppp->realm, username,
		    &ppp->realm_framed_ip_address,
			    &ppp->realm_framed_ip_netmask) != 0)
			ppp->realm_framed_ip_address.s_addr = 0;
	}
d667 2
d671 1
a671 2
		if ((ppp_ipcp(ppp)->ip_assign_flags &
		    NPPPD_IP_ASSIGN_USER_SELECT) == 0)
d684 3
a686 2
	int lnumber, rval, strict, loose;
	char number[NPPPD_PHONE_NUMBER_LEN + 1];
d688 2
a689 4
	strict = ppp_config_str_equal(ppp, "check_callnum", "strict", 0);
	loose  = ppp_config_str_equal(ppp, "check_callnum", "loose", 0);

	if (strict || loose) {
d692 1
a692 2
		    ppp->username,
		    number, &lnumber)) == 0)
d695 1
a695 1
		if (strict)
d795 1
a795 1
	if (ppp_iface(ppp)->user_max_session == 0)
d808 1
a808 1
	return (count < ppp_iface(ppp)->user_max_session)? 1 : 0;
d954 1
a954 1
	case PPP_TUNNEL_PPPOE:
d981 1
a981 1
	case PPP_TUNNEL_PPTP:
d1007 1
a1007 1
	case PPP_TUNNEL_L2TP:
d1097 1
a1097 1
	case PPP_TUNNEL_PPPOE:
d1106 1
a1106 1
	case PPP_TUNNEL_PPTP:
d1115 1
a1115 1
	case PPP_TUNNEL_L2TP:
d1163 1
a1163 1
	case PPP_TUNNEL_PPPOE:
d1172 1
a1172 1
	case PPP_TUNNEL_PPTP:
d1181 1
a1181 1
	case PPP_TUNNEL_L2TP:
d1200 5
a1204 5
	struct pipex_session_list_req req;
	npppd_ppp *ppp;
	int i, error;
	u_int ppp_id;
	slist dlist, users;
d1274 1
d1286 4
a1289 9
	if (ppp_ipcp(ppp)->dns_use_tunnel_end != 0) {
		ppp->ipcp.dns_pri = ppp->ipcp.ip4_our;
		ppp->ipcp.dns_sec.s_addr = INADDR_NONE;
	} else {
		ppp->ipcp.dns_pri = ppp_ipcp(ppp)->dns_pri;
		ppp->ipcp.dns_sec = ppp_ipcp(ppp)->dns_sec;
	}
	ppp->ipcp.nbns_pri = ppp_ipcp(ppp)->nbns_pri;
	ppp->ipcp.nbns_sec = ppp_ipcp(ppp)->nbns_sec;
d1468 1
a1468 1
	int flag, dyna, rval, fallback_dyna;
a1480 1
	flag = ppp_ipcp(ppp)->ip_assign_flags;
d1493 3
a1495 13
		/* We cannot assign a fixed ip address without realm */

		if ((npppd_auth_get_type(realm) == NPPPD_AUTH_TYPE_RADIUS &&
		    (flag & NPPPD_IP_ASSIGN_RADIUS) == 0 &&
			    (flag & NPPPD_IP_ASSIGN_FIXED) == 0) ||
		    (npppd_auth_get_type(realm) == NPPPD_AUTH_TYPE_LOCAL &&
		    (flag & NPPPD_IP_ASSIGN_FIXED) == 0))
			dyna = 1;
		else {
			fallback_dyna = 1;
			req_ip4 = ntohl(ppp->realm_framed_ip_address.s_addr);
			ip4mask = ntohl(ppp->realm_framed_ip_netmask.s_addr);
		}
d1503 13
a1515 35
		for (slist_itr_first(ppp_pools(ppp));
		    slist_itr_has_next(ppp_pools(ppp));){
			pool = slist_itr_next(ppp_pools(ppp));
			rval = npppd_pool_get_assignability(pool, req_ip4,
			    ip4mask, &snp);
			switch (rval) {
			case ADDRESS_OK:
				if (snp->snp_type == SNP_POOL) {
					/*
					 * Fixed address pool can be used
					 * only if the realm specified to use
					 * it.
					 */
					if (ppp->realm_framed_ip_address
					    .s_addr != INADDR_USER_SELECT)
						ip4 = req_ip4;
					break;
				}
				ppp->assign_dynapool = 1;
				ip4 = req_ip4;
				break;
			case ADDRESS_RESERVED:
				reason = "reserved";
				continue;
			case ADDRESS_OUT_OF_POOL:
				reason = "out of the pool";
				continue;	/* try next */
			case ADDRESS_BUSY:
				fallback_dyna = 0;
				reason = "busy";
				break;
			default:
			case ADDRESS_INVALID:
				fallback_dyna = 0;
				reason = "invalid";
d1518 17
a1547 1
		ppp->assigned_pool = pool;
d1553 2
a1554 7
		for (slist_itr_first(ppp_pools(ppp));
		    slist_itr_has_next(ppp_pools(ppp));){
			pool = slist_itr_next(ppp_pools(ppp));
			ip4 = npppd_pool_get_dynamic(pool, ppp);
			if (ip4 != 0)
				break;
		}
a1641 1
			ppp->assigned_pool = NULL;
d1811 2
d1823 32
a1854 7
#ifdef NPPPD_RESET_IP_ADDRESS
	{
	    int i;
	    for (i = 0; i < countof(_this->iface); i++) {
		    if (_this->iface[i].initialized != 0)
			    npppd_iface_reinit(&_this->iface[i]);
	    }
a1855 2
#endif
	npppd_auth_finalizer_periodic(_this);
d1942 1
a1942 3
	int lsuffix, lprefix, lusername, lmax;
	const char *val;
	char *tok, *buf0, buf[NPPPD_CONFIG_BUFSIZ], buf1[MAX_USERNAME_LENGTH];
d1944 2
d1959 4
a1962 6
	if ((val = ppp_config_str(ppp, "realm_list")) == NULL) {
#ifndef	NO_DEFAULT_REALM
		/*
		 * If the realm is not a list, because of compatibility for
		 * past versions, we try fallback from LOCAL to RADIUS.
		 */
d1969 5
a1973 9
			switch (npppd_auth_get_type(realm1)) {
			case NPPPD_AUTH_TYPE_LOCAL:
				if (npppd_auth_get_user_password(
				    realm1, npppd_auth_username_for_auth(
					    realm1, username, buf1),
				    NULL, NULL) == 0) {
					realm = realm1;
					goto found;
				}
a1974 4

			case NPPPD_AUTH_TYPE_RADIUS:
				realm = realm1;
				goto found;
d1977 14
a1990 25
#else
		/* Nothing to do */
#endif
	} else {
		strlcpy(buf, val, sizeof(buf));
		buf0 = buf;
		while ((tok = strsep(&buf0, " ,\t\r\n")) != NULL) {
			if (tok[0] == '\0')
				continue;
			realm0 = NULL;
			slist_itr_first(&_this->realms);
			while (slist_itr_has_next(&_this->realms)) {
				realm1 = slist_itr_next(&_this->realms);
				if (!npppd_auth_is_usable(realm1))
					continue;
				if (eap_required &&
				    !npppd_auth_is_eap_capable(realm1))
					continue;
				if (strcmp(npppd_auth_get_label(realm1), tok)
				    == 0) {
					realm0 = realm1;
					break;
				}
			}
			if (realm0 == NULL)
a1991 12
			lsuffix = strlen(npppd_auth_get_suffix(realm0));
			if (lsuffix > lmax &&
			    (lsuffix == 0 || (lsuffix < lusername &&
			    strcmp(username + lusername - lsuffix,
				npppd_auth_get_suffix(realm0)) == 0))) {
				/* check prefix */
				lprefix = strlen(npppd_auth_get_prefix(realm0));
				if (lprefix > 0 &&
				    strncmp(username,
					    npppd_auth_get_prefix(realm0),
					    lprefix) != 0)
					continue;
d1993 2
a1994 3
				lmax = lsuffix;
				realm = realm0;
			}
d1997 1
d2003 1
a2003 5
#ifndef	NO_DEFAULT_REALM
found:
#endif
	NPPPD_DBG((LOG_DEBUG, "%s bind realm %s(%s)",
	    username, npppd_auth_get_label(realm), npppd_auth_get_name(realm)));
d2083 2
a2084 4
	int i, ifidx, ntotal_session;
	const char *ifname, *label;
	char buf[BUFSIZ];
	npppd_auth_base *realm;
d2091 10
a2100 12
	if (ppp->peer_auth == 0) {
		strlcpy(buf, "no_auth.concentrate", sizeof(buf));
	} else {
		realm = (npppd_auth_base *)ppp->realm;
		strlcpy(buf, "realm.", sizeof(buf));
		NPPPD_ASSERT(ppp->realm != NULL);
		label = npppd_auth_get_label(realm);
		if (label[0] != '\0') {
			strlcat(buf, label, sizeof(buf));
			strlcat(buf, ".concentrate", sizeof(buf));
		} else
			strlcat(buf, "concentrate", sizeof(buf));
d2102 1
a2102 3

	ifname = ppp_config_str(ppp, buf);
	if (ifname == NULL)
a2106 1
	ntotal_session = 0;
d2110 1
a2110 2
		ntotal_session += _this->iface[i].nsession;
		if (strcmp(_this->iface[i].ifname, ifname) == 0)
d2116 1
a2116 1
	if (ntotal_session >= _this->max_session) {
a2121 7
	if (_this->iface[ifidx].nsession >= _this->iface[ifidx].max_session) {
		ppp_log(ppp, LOG_WARNING,
		    "Number of sessions reaches out of the interface limit=%d",
		    _this->iface[ifidx].max_session);
		return 1;
	}

a2122 1
	ppp_iface(ppp)->nsession++;
d2131 1
a2131 3
	if (ppp->ifidx >= 0)
		ppp_iface(ppp)->nsession--;

d2276 1
a2276 1
npppd_ppp_tunnel_protocol_name(npppd *_this, npppd_ppp *ppp)
d2278 2
a2279 2
	switch (ppp->tunnel_type) {
	case PPP_TUNNEL_NONE:
d2281 1
a2281 1
	case PPP_TUNNEL_L2TP:
d2283 1
a2283 1
	case PPP_TUNNEL_PPTP:
d2285 1
a2285 1
	case PPP_TUNNEL_PPPOE:
d2287 1
a2287 1
	case PPP_TUNNEL_SSTP:
a2290 1
	NPPPD_ASSERT(0);
d2293 20
@


1.19
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.18 2012/05/08 13:30:16 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.18 2012/05/08 13:30:16 yasuoka Exp $
a1043 1
		/* options: XXX: needs other? */
d1056 6
a1061 4
#ifdef	IP_IPSEC_SA_COOKIE
		if (l2tpctrl->sa_cookie != NULL)
			req.pr_proto.l2tp.ipsec_sa_cookie =
			    *(struct in_ipsec_sa_cookie *)l2tpctrl->sa_cookie;
@


1.18
log
@Fix a null reference bug on terminating the process.

seems ok henning, ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.17 2012/05/08 13:18:37 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.17 2012/05/08 13:18:37 yasuoka Exp $
d84 2
@


1.17
log
@Trivial changes from the upstream(IIJ).
 - fix styles, compile errors in some ifdef condition and compiler warnings.
 - delete rtev* that was to work around routing socket overflows.
 - delete is_ctrl argument from l2tp_ctrl_send_packet().  It's not used.
 - tweak returning the exit status.
 - use IPV6_IPSEC_POLICY for IPv6 socket.
   (though npppd cannot set up a ipsec policy to the socket yet.)

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.16 2012/05/08 13:15:11 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.16 2012/05/08 13:15:11 yasuoka Exp $
d1777 2
a1778 1
	_this->rd = radish_head;
d1788 1
d1814 2
@


1.16
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd.c,v 1.15 2012/01/23 03:36:22 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.15 2012/01/23 03:36:22 yasuoka Exp $
a81 1
#include "rtev.h"
d150 1
a150 1
	int ch, retstatus, ll_adjust = 0, runasdaemon = 0;
a154 1
	retstatus = EXIT_SUCCESS;
d195 2
a196 4
	if (npppd_init(&s_npppd, npppd_conf0) != 0) {
		retstatus = EXIT_FAILURE;
		goto fail;
	}
d199 1
a199 1
		err(1, "gwpwnam");
d201 1
a201 1
		err(1, "chroot");
d203 1
a203 1
		err(1, "chdir(\"/\")");
d207 1
a207 1
		err(1, "cannot drop privileges");
d211 1
a211 2
	if (s_npppd.stop_by_error != 0)
		retstatus = EXIT_FAILURE;
a212 2
	/* FALLTHROUGH */
fail:
d216 1
a216 1
	exit(retstatus);
a327 11
	/* initialize rtev */
	rtev_libevent_init(
	    npppd_config_int(_this, "rtsock.event_delay",
		DEFAULT_RTSOCK_EVENT_DELAY),
	    npppd_config_int(_this, "rtsock.send_wait_millisec",
		DEFAULT_RTSOCK_SEND_WAIT_MILLISEC),
	    npppd_config_int(_this, "rtsock.send_npkts",
		DEFAULT_RTSOCK_SEND_NPKTS), 0);

	_this->rtev_event_serial = -1;

a496 2

	rtev_fini();
a541 1
	if (_this->rtev_event_serial != rtev_get_event_serial()) {
d543 2
a544 2
		if (pppoed_need_polling(&_this->pppoed))
			pppoed_reload_listeners(&_this->pppoed);
a545 3
	}
	_this->rtev_event_serial = rtev_get_event_serial();

a1050 2
		NPPPD_ASSERT(l2tpctrl->peer.ss_family == AF_INET);

d1925 1
a1925 1
			    "priviledged process exits abnormaly.  signal=%d",
d1929 1
a1929 1
			    "priviledged process exits abnormaly.  status=%d",
@


1.15
log
@The ingress filter of pipex and npppd become configurable and disabled
by default.  After this change we need to add

  ppp.ingress_filter: true

to npppd.conf if it is needed.

ok sthen
@
text
@d1 1
a1 1
/* $OpenBSD: npppd.c,v 1.14 2012/01/18 03:13:04 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.14 2012/01/18 03:13:04 yasuoka Exp $
@


1.14
log
@Replace npppdctl(8) by new npppctl(8).  npppctl was written from
scratch, it uses parser.c derived from ikectl(8) to have OpenBSD's
fashion.  This includes related changes listed below:
- changed npppd control IPC heavyly.
- support IPv6 as tunnel source address.
- deleted support changing the configuration of npppd_ctl on running.
  Because it is not so needed but it requires privilege operations.
- refactors.

man page helps from jmc.  tested by sebastia.
ok deraadt sebastia sthen
@
text
@d1 1
a1 1
/* $OpenBSD: npppd.c,v 1.13 2012/01/18 02:53:56 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.13 2012/01/18 02:53:56 yasuoka Exp $
d890 4
a893 4
#ifndef	NO_INGRES_FILTER
	if ((pip->ip_src.s_addr & ppp->ppp_framed_ip_netmask.s_addr) !=
	    (ppp->ppp_framed_ip_address.s_addr &
		    ppp->ppp_framed_ip_netmask.s_addr)) {
a901 1
#endif
d944 2
@


1.13
log
@Fix compiler warnings and some styles.

ok sebastia sthen
@
text
@d1 1
a1 1
/* $OpenBSD: npppd.c,v 1.12 2011/07/08 06:14:54 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.12 2011/07/08 06:14:54 yasuoka Exp $
d390 3
d801 1
a801 1
npppd_get_ppp_by_id(npppd *_this, int ppp_id)
d1249 2
a1250 1
	int i, error, ppp_id;
d2373 20
@


1.12
log
@Improved npppd privileged separations:
- Changed finalizing way to the privileged process.  In old way, the
  privileged process could not aware abnormal exit of the process in
  jail.  Then the processes in jail remained as zombies.  Created a
  pipe to monitor the privileged process, the privileged process can
  exit in peace by using the pipe.
- npppd will exit abnormally when the privileged process exits
  abnormally.
- PF_KEY socket requires privileges.
- Return correct "errno" to the jail in priv_open().
- Cleanup.

ok hsuenaga@@
@
text
@d1 1
a1 1
/* $OpenBSD: npppd.c,v 1.11 2011/07/06 20:52:28 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.11 2011/07/06 20:52:28 yasuoka Exp $
d1261 1
a1261 1
			slist_add(&dlist, (void *)ppp_id);
d1278 1
a1278 1
		ppp_id = (int)slist_itr_next(&dlist);
@


1.11
log
@Add RADIUS accounting support and some authentication related changes:

- Add functions to radius+.c that are required to implement RADIUS
  accounting.
- Send RADIUS Account-Start and Account-Stop messages with attributes that
  are defined by RFC 2866, 2868, 2869.
- If any authentication realm is deleted from the configuration, npppd may
  exit by segmentation fault.
- Delete radius_common.c, radius_common.h and eap.c because they are not
  used.
- Retransmission and failover are reimplemented.
- Cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: npppd.c,v 1.10 2011/05/15 15:47:52 markus Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.10 2011/05/15 15:47:52 markus Exp $
d52 1
d117 1
d120 1
a120 1
static void	       npppd_auth_finalizer_periodic(npppd *);
d151 1
a151 1
	int ch, retval = 0, ll_adjust = 0, runasdaemon = 0;
d156 1
d198 1
a198 1
		retval = 1;
d215 2
d223 1
a223 1
	return retval;
d354 1
d358 1
d503 1
d1934 22
@


1.10
log
@disable pipex for L2TP on disconnect, too; yasuoka@@ agrees.
@
text
@d1 1
a1 1
/* $OpenBSD: npppd.c,v 1.9 2011/04/02 12:04:44 dlg Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.9 2011/04/02 12:04:44 dlg Exp $
d290 2
d1289 5
d2030 1
a2030 1
				lprefix = strlen(npppd_auth_get_suffix(realm0));
d2033 1
a2033 1
					    npppd_auth_get_suffix(realm0),
d2228 1
a2228 1
npppd_get_radius_req_setting(npppd *_this, npppd_ppp *ppp)
d2238 1
a2238 15
	return npppd_auth_radius_get_radius_req_setting(
	    (npppd_auth_radius *)ppp->realm);
}

/** Notice a failure on RAIDUS request/response */
void
npppd_radius_server_failure_notify(npppd *_this, npppd_ppp *ppp, void *rad_ctx,
    const char *reason)
{
	NPPPD_ASSERT(rad_ctx != NULL);
	NPPPD_ASSERT(ppp != NULL);

	npppd_auth_radius_server_failure_notify(
	    (npppd_auth_radius *)ppp->realm, radius_get_server_address(rad_ctx),
	    reason);
d2284 1
a2284 1
		if (refcnt == 0)
d2286 2
@


1.9
log
@add support for pppx interfaces instead of tun interfaces.

pppx mode will create a pppx interface for each ppp session in the kernel,
and will rely on the kernel to handle the routing rather than doing it
itself. as a bonus it will configure the interfaces description with the
username of the person connecting (which makes systat if pretty).

ok claudio@@ yasuoka@@ as part of a larger diff
from jonathan matthew
weve been running all this in production for a month now..
@
text
@d1 1
a1 1
/* $OpenBSD: npppd.c,v 1.8 2010/09/24 14:50:30 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.8 2010/09/24 14:50:30 yasuoka Exp $
d1146 9
@


1.8
log
@Add support pipex for L2TP call and L2TP on IPv6.
- pipex requires unique session-id in protocol, so session-id
  generation algorithm has been changed.
- change to fit the new PIPEX ioctl.
ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: npppd.c,v 1.7 2010/09/23 01:45:10 jsg Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.7 2010/09/23 01:45:10 jsg Exp $
d258 1
d260 1
d570 3
d933 1
d1086 13
d1383 22
a1404 17
		if (ppp->snp.snp_next != NULL)
			/*
			 * There is a blackhole route that has same
			 * address/mask.
			 */
			in_route_delete(&ppp->ppp_framed_ip_address,
			    &ppp->ppp_framed_ip_netmask, &loop, RTF_BLACKHOLE);
		/* See the comment for MRU_IPMTU() on ppp.h */
		if (ppp->ppp_framed_ip_netmask.s_addr == 0xffffffffL) {
			in_host_route_add(&ppp->ppp_framed_ip_address,
			    &ppp_iface(ppp)->ip4addr, ppp_iface(ppp)->ifname,
			    MRU_IPMTU(ppp->peer_mru));
		} else {
			in_route_add(&ppp->ppp_framed_ip_address,
			    &ppp->ppp_framed_ip_netmask,
			    &ppp_iface(ppp)->ip4addr, ppp_iface(ppp)->ifname, 0,
			    MRU_IPMTU(ppp->peer_mru));
d1409 17
a1425 7
		if (ppp->ppp_framed_ip_netmask.s_addr == 0xffffffffL) {
			in_host_route_delete(&ppp->ppp_framed_ip_address,
			    &ppp_iface(ppp)->ip4addr);
		} else {
			in_route_delete(&ppp->ppp_framed_ip_address,
			    &ppp->ppp_framed_ip_netmask,
			    &ppp_iface(ppp)->ip4addr, 0);
a1426 7
		if (ppp->snp.snp_next != NULL)
			/*
			 * There is a blackhole route that has same
			 * address/mask.
			 */
			in_route_add(&ppp->snp.snp_addr, &ppp->snp.snp_mask,
			    &loop, LOOPBACK_IFNAME, RTF_BLACKHOLE, 0);
d1743 25
a1767 21
	for (slist_itr_first(&rtlist0); slist_itr_has_next(&rtlist0);) {
		radish = slist_itr_next(&rtlist0);
		in_route_delete(&SIN(radish->rd_route)->sin_addr,
		    &SIN(radish->rd_mask)->sin_addr, &loop, RTF_BLACKHOLE);
		count++;
	}
	if (count > 0)
		log_printf(LOG_INFO,
		    "Deleted %d routes for old pool addresses", count);

	count = 0;
	for (slist_itr_first(&rtlist1); slist_itr_has_next(&rtlist1);) {
		radish = slist_itr_next(&rtlist1);
		in_route_add(&(SIN(radish->rd_route)->sin_addr),
		    &SIN(radish->rd_mask)->sin_addr, &loop, LOOPBACK_IFNAME,
		    RTF_BLACKHOLE, 0);
		count++;
	}
	if (count > 0)
		log_printf(LOG_INFO,
		    "Added %d routes for new pool addresses", count);
@


1.7
log
@remove support for talking to the zebra routing socket which
was not enabled, we use a kernel routing socket for such things.

ok yasuoka@@ claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: npppd.c,v 1.6 2010/07/31 09:33:09 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.6 2010/07/31 09:33:09 yasuoka Exp $
d100 2
d967 4
d982 3
d994 9
a1002 2
		memcpy(&req.pr_proto.pppoe.peer_address, &pppoe->ether_addr,
		    ETHER_ADDR_LEN);
d1005 1
a1024 2
		req.pr_proto.pptp.peer_address =
		    ((struct sockaddr_in *)&call->ctrl->peer)->sin_addr;
d1026 40
a1065 2
		req.pr_proto.pptp.our_address =
		    ((struct sockaddr_in *)&call->ctrl->our)->sin_addr;
d1101 3
d1160 3
d1184 9
@


1.6
log
@delete IIJ local functionalities.
@
text
@d1 1
a1 1
/* $OpenBSD: npppd.c,v 1.5 2010/07/02 21:20:57 yasuoka Exp $ */
d32 1
a32 1
 * $Id: npppd.c,v 1.5 2010/07/02 21:20:57 yasuoka Exp $
a81 3
#ifdef NPPPD_USE_RT_ZEBRA
#include "rt_zebra.h"
#endif
a332 6
#ifdef NPPPD_USE_RT_ZEBRA
	if (rt_zebra_get_instance() == NULL)
		return -1;
	rt_zebra_init(rt_zebra_get_instance());
	rt_zebra_start(rt_zebra_get_instance());
#endif
a446 3
#ifdef NPPPD_USE_RT_ZEBRA
	rt_zebra_stop(rt_zebra_get_instance());
#endif
a498 3
#ifdef NPPPD_USE_RT_ZEBRA
	rt_zebra_fini(rt_zebra_get_instance());
#endif
a554 5
#endif
#ifdef NPPPD_USE_RT_ZEBRA
	if (!rt_zebra_is_running(rt_zebra_get_instance())) {
		rt_zebra_start(rt_zebra_get_instance());
	}
@


1.5
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d32 1
a32 1
 * $Id: npppd.c,v 1.4 2010/07/01 03:38:17 yasuoka Exp $
a87 4
#ifdef USE_NPPPD_LINKID
#include "linkid.h"
#endif

a380 3
#ifdef USE_NPPPD_LINKID
	linkid_sock_init();
#endif
a420 3
#ifdef USE_NPPPD_LINKID
	linkid_sock_fini();
#endif
a1256 4

#ifdef USE_NPPPD_LINKID
	linkid_purge(ppp->ppp_framed_ip_address);
#endif
@


1.4
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
d32 1
a32 1
 * $Id: npppd.c,v 1.3 2010/01/31 05:49:51 yasuoka Exp $
d39 1
a39 1
"@@(#) Version " VERSION "\n" 
d142 1
a142 1
#define NPPPD_DBG(x) 
d372 1
a372 1
	 * If the npppd can start(open) interfaces successfully, it can 
d580 1
a580 1
#endif	
d636 1
a636 1
					    ppp_iface(ppp)->ifname, 0, 
d761 1
a761 1
 * specified ip address and returns it 
d901 1
a901 1
	if ((pip->ip_src.s_addr & ppp->ppp_framed_ip_netmask.s_addr) != 
d1038 1
a1038 1
		req.pr_proto.pptp.peer_address = 
d1041 1
a1041 1
		req.pr_proto.pptp.our_address = 
d1301 1
a1301 1
	enabled = (enabled)? 1 : 0;	
d1335 1
a1335 1
			in_route_delete(&ppp->ppp_framed_ip_address, 
d1436 1
a1436 1
	NPPPD_DBG((LOG_DEBUG, "%s() assigned=%s", __func__, 
d1554 1
a1554 1
rtlist_remove(slist *prtlist, struct radish *radish) 
d1672 1
a1672 1
				    LOG_ERR, 
d1753 1
a1753 1
				log_printf(LOG_ERR, 
d1768 1
a1768 1
static int 
d1865 1
a1865 1
 * Select a authentication realm that is for given {@@link ::npppd_ppp PPP}.  
d1933 1
a1933 1
				    !npppd_auth_is_eap_capable(realm1)) 
d2186 1
a2186 1
	 * disconnect them.  If all PPPs are disconnected then free the realm. 
@


1.3
log
@privilege separation of npppd.

- Drop privilege after daemon initializing.
- Some system calls that requires root privileges were replaced to
  wrapper functions that communicate with a separated privileged
  process via IPC.  And the privileged process checks whether the
  operations are acceptable.
@
text
@d27 2
a28 2
 * Next pppdnpppd  npppd
 *
d30 1
a30 1
 * $Id: npppd.c,v 1.2 2010/01/13 07:49:44 yasuoka Exp $
a107 1
/* static */
d145 1
a145 1
 * 
d199 1
a199 1
		goto reigai;
d217 1
a217 1
reigai:
d238 1
a238 1
/**  npppd  */
d246 1
a246 1
 * npppd  (init/fini/stop/start)
d248 1
a248 1
/**  */
d284 1
a284 11
	/*
	 * NetBSD 2.0  realpath(3) 
	 *
	 * This implementation of realpath() differs slightly from the Solaris
	 * implementation.  The 4.4BSD version always returns absolute
	 * pathnames, whereas the Solaris implementation will, under certain
	 * circumstances, return a relative resolvedname when given a relative
	 * pathname.
	 *
	 * FIXME: 4.4BSD
	 */
d291 1
a291 1
	/*  */
a306 1
	/* PID */
d310 1
a310 1
	/*  */
d312 1
a312 1
		/* PID */
d317 1
a317 1
		/* core  */
d326 1
a326 1
	/*  */
d329 1
a329 1
	/* Routing */
d337 1
d346 1
a346 1
	/*  */
d349 2
a350 4
	/*
	 * 
	 * EV_PERSIST (event(3))1
	 */
a356 2
	//_npppd
	signal_add(&_this->ev_sighup, NULL);
d360 1
a360 3
	/*
	 * 
	 */
d370 3
a372 2
	 *  start (open)  nppp 
	 * PID
a373 1
	/* pid  */
d394 1
a394 1
/** npppd  */
a401 1
		// 
d409 1
a409 1
/** npppd  */
a441 1

d474 1
a474 1
/** npppd  */
d526 1
a526 1
 * 
d534 1
a534 1
		/*  */
d552 2
a553 3
		npppd_stop_really(_this);
		/* */
		return; /*  */
d650 1
a650 1
 * npppd  API (export)
d653 1
a653 1
 *  0 
d655 13
a667 7
 * @@param	username	
 * @@param	password	
 *				 NULL
 *				
 * @@param	lppassword	
 * @@return User unknown  1
 *  2
d681 1
a681 1
/**  Framed-IP-Address */
d696 3
a698 3
 * FIXME: radius  IP
 * FIXME: radius  acctlist 
 * FIXME: 
d710 1
a710 1
		/*  */
d718 1
a718 1
	/*  USER_SELECT */
d722 1
a722 1
		/* USER_SELECT  NAS_SELECT  */
a756 6
/*  */
static struct sockaddr_in npppd_get_ppp_by_ip_sin4 = {
	.sin_family = AF_INET,
	.sin_len = sizeof(struct sockaddr_in)
};

d758 3
a760 3
 *  IP {@@link npppd_ppp} 
 * 
 * @@param ipaddr	IP
d767 1
d769 2
d773 1
a773 1
		return NULL;	/*  */
d784 5
a788 5
 *  PPP {@@link npppd_ppp} 
 * @@param username	PPP
 * @@param rlist		 {@@link slist}
 * @@retnr	 0 -1rlist
 *	
d802 5
a806 4
 *  PPP  ID  {@@link npppd_ppp} 
 * @@param	id	 {@@link npppd_ppp#id ppp  id}
 * @@return	id  {@@link npppd_ppp} 
 *  NULL 
d822 1
a822 1
		/* FIXME: Id  */
d837 4
a840 3
 *  (user_max_session) 
 * 
 * @@return	 1  0 
d849 2
a850 2
	/* user_max_session0 */
	if (ppp_iface(ppp)->user_max_session == 0) {
a851 1
	}
d867 1
a867 1
 *  I/O 
d870 2
a871 2
 * (tun)
 *  IPv4 
d879 1
a879 1
	u_char buf[256];	/* TCP/IP  */
d918 2
a919 2
			 * TCP  sizeof(buf) 
			 * 
d930 1
d932 1
a932 1
 * IPv4 
a933 2
#ifdef USE_NPPPD_PIPEX

d982 1
a982 1
/** PPPAC  IPv4 */
d1006 1
a1006 1
		/* PPPOE  */
d1022 1
a1022 1
		/* PPTP  */
d1057 1
a1057 1
		/* NPPPD  idle timer  */
d1065 1
a1065 1
/** PPPAC  IPv4 */
d1087 1
a1087 1
		/* PPPOE  */
d1096 1
a1096 1
		/* PPTP  */
d1119 3
a1121 1
/** PPPAC  IPv4 */
d1141 1
a1141 1
		/* PPPOE  */
d1150 1
a1150 1
		/* PPTP  */
d1196 1
a1196 1
	/*  */
d1199 1
a1199 1
		/* FIXME: PPP id  */
d1228 1
a1228 1
 * IP
d1230 1
a1230 1
/** npppd  IP */
d1258 1
a1258 1
/** npppd  IP */
d1276 4
a1279 1
/** IPenabled */
d1293 1
d1295 3
a1297 2
	 * enabled 
	 *  wakeup 
d1303 1
d1323 1
a1323 1
			if (u != NULL)	/* malloc  */
d1329 4
a1332 1
			/* / */
d1358 4
a1361 1
			/* / */
d1391 1
a1391 1
				/*  PPP */
d1405 1
a1405 1
				/*  */
d1419 4
a1422 4
 * IP struct in_addr 
 * 
 * @@param req_ip4	 IP
 * 
d1454 1
a1454 1
		/*  IP */
d1470 3
a1472 3
		 * fallback_dyna ...
		 *	Realm 
		 *	 fallback 
d1483 3
a1485 2
					 * 
					 * Realm 
d1500 1
a1500 1
				continue;	/*  */
d1569 1
a1569 1
/** {@@link ::npppd#rd npppd  radish} */
d1587 1
a1587 1
			goto reigai;
d1593 1
a1593 1
			goto reigai;
d1601 1
a1601 1
		     * 
d1608 1
a1608 1
				/*  */
d1610 1
a1610 1
				/*  */
d1615 1
a1615 1
		     *  PPP 
d1620 1
a1620 1
			/*  PPP */
d1623 1
a1623 1
			/*  */
d1630 2
a1631 2
				 * PPP
				 * 
d1642 5
a1646 5
				 * /
				 * RADISH 
				 * SNP_PPP 
				 * snp->snp_next 
				 * 
d1652 4
a1655 1
					/*  */
d1657 1
a1657 1
					/* snp_next  */
d1664 1
a1664 1
			/*  Radish */
d1719 1
a1719 1
reigai:
d1728 2
a1729 2
 *  {@@link slist} users 
 * {@@link ::npppd_ppp} 
d1753 1
a1753 1
				goto reigai;
d1760 1
a1760 1
reigai:
d1809 1
a1809 1
 * 
d1844 1
a1844 1
 * 
d1863 2
a1864 2
 *  {@@link ::npppd_ppp PPP} 
 * 0 
d1880 2
a1881 2
	 * PPP
	 * 
d1890 2
a1891 2
		 * 
		 * =>RADIUS 
d1980 1
a1980 1
/** */
d1994 1
a1994 1
/** RADIUS*/
d2008 1
a2008 1
/** */
d2018 1
a2018 1
/** */
d2027 1
a2027 1
/** ppp */
d2036 1
a2036 1
/** */
d2044 1
a2044 1
/** ppp */
d2076 1
a2076 1
	/*  */
d2108 1
a2108 1
/** ppp  */
d2140 4
a2143 1
/** @@return  radius  NULL  */
d2159 1
a2159 1
/** Radius */
d2173 1
a2173 1
/**  */
d2183 2
a2184 2
	 * disposing  realm  PPP 
	 *  realm 
d2222 1
a2222 1
/** sockaddr_npppd  0  */
d2235 3
a2237 4
 *  username_buffer 
 * 
 * @@param username_buffer 
 * MAX_USERNAME_LENGTH 
@


1.2
log
@cleanup npppd code.  delete IIJ local ifdef switches and fix warnings.
ok @@dlg
@
text
@d30 1
a30 1
 * $Id: npppd.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $
d69 2
d156 1
d188 10
d202 13
d217 1
a217 1
	// FALL THROUGH
d219 1
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d30 1
a30 1
 * $Id: npppd.c 39106 2010-01-10 21:01:39Z yasuoka $
a174 9
#if defined(__NetBSD__) && (__NetBSD_Version__ < 300000000) && \
    defined(USE_NPPPD_PPPOE) 
	/*
	 * FIXME: BPF + kqueue on NetBSD 2.0.2 
	 *  event 
	 */
	setenv("EVENT_NOKQUEUE", "nokqueue", 0);
#endif

a179 3
#ifdef _SEIL_EXT_
		openlog(NULL, 0, LOG_NPPPD);
#else
a180 1
#endif
a410 3
#ifdef	IDGW_SSLDIP
	pptpd_stop(&_this->ssldipd);
#endif
a449 4
#ifdef	IDGW_SSLDIP
	if (!pptpd_is_stopped(&_this->ssldipd))
		wait_again |= 1;
#endif
a458 3
#ifdef	_SEIL_EXT_
	unlink(_this->pidpath);
#endif
a477 3
#ifdef	IDGW_SSLDIP
	pptpd_uninit(&_this->ssldipd);
#endif
a574 4
#ifdef _SEIL_EXT_
		/* zebra@@seil  */
		npppd_reset_routing_table(_this, 1);
#endif	
d576 1
a576 1
#endif	
a1917 17
#ifdef IDGW
				/* 
				 * 
				 * 
				 */
				if (npppd_auth_get_type(realm0)
				    == NPPPD_AUTH_TYPE_LOCAL) {
					if (!npppd_auth_is_ready(realm0))
						continue;
					if (npppd_auth_get_user_password(realm0,
					    npppd_auth_username_for_auth(
						realm0, username, buf1),
						NULL, NULL) == 1) {
						continue;
					}
				}
#endif
@

