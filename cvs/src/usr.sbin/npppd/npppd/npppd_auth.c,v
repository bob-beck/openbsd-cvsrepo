head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.12.0.8
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.19
date	2017.02.22.07.48.26;	author yasuoka;	state Exp;
branches;
next	1.18;
commitid	SwiZo2uIquE3VzDK;

1.18
date	2016.03.08.02.05.00;	author yasuoka;	state Exp;
branches;
next	1.17;
commitid	pbvpyOLtd7KuOHEc;

1.17
date	2015.12.05.18.43.36;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	z4uV9iYMuGOvIKaj;

1.16
date	2015.01.19.01.48.59;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	a1BWBASyBgKKetQd;

1.15
date	2014.08.22.04.36.16;	author jsg;	state Exp;
branches;
next	1.14;
commitid	tGhNqxfuY2HdoYgb;

1.14
date	2014.05.30.05.06.00;	author yasuoka;	state Exp;
branches;
next	1.13;

1.13
date	2014.03.22.04.23.17;	author yasuoka;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.31.09.44.21;	author yasuoka;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.22.20.22.48;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.05.06.31.27;	author yasuoka;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.08.13.15.11;	author yasuoka;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.06.20.52.28;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.31.05.49.51;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.14.23.35.39;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.07.49.44;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Delete lines which are misleading and unneeded.
spotted patrick
@
text
@/*	$OpenBSD: npppd_auth.c,v 1.18 2016/03/08 02:05:00 yasuoka Exp $ */

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/**@@file authentication realm */
/* $Id: npppd_auth.c,v 1.18 2016/03/08 02:05:00 yasuoka Exp $ */
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if_dl.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <syslog.h>
#include <string.h>
#include <time.h>
#include <event.h>
#include <stdarg.h>
#include <stdlib.h>
#include <netdb.h>
#include <errno.h>

#include "debugutil.h"
#include "slist.h"
#include "npppd_local.h"
#include "npppd_auth.h"
#include "net_utils.h"

#include "npppd_auth_local.h"

/**
 * Create a npppd_auth_base object.
 * @@param auth_type	the authentication type.
 *	specify {@@link ::NPPPD_AUTH_TYPE_LOCAL} to authenticate by the local
 *	file, or specify {@@link ::NPPPD_AUTH_TYPE_RADIUS} for RADIUS
 *	authentication.
 * @@param name		the configuration name
 * @@param _npppd	the parent {@@link ::npppd} object
 * @@see	::NPPPD_AUTH_TYPE_LOCAL
 * @@see	::NPPPD_AUTH_TYPE_RADIUS
 * @@return The pointer to the {@@link ::npppd_auth_base} object will be returned
 * in case success otherwise NULL will be returned.
 */
npppd_auth_base *
npppd_auth_create(int auth_type, const char *name, void *_npppd)
{
	npppd_auth_base *base;

	NPPPD_AUTH_ASSERT(name != NULL);

	switch (auth_type) {
	case NPPPD_AUTH_TYPE_LOCAL:
		if ((base = calloc(1, sizeof(npppd_auth_local))) != NULL) {
			base->type = NPPPD_AUTH_TYPE_LOCAL;
			strlcpy(base->name, name, sizeof(base->name));
			base->npppd = _npppd;

			return base;
		}
		break;

#ifdef USE_NPPPD_RADIUS
	case NPPPD_AUTH_TYPE_RADIUS:
		if ((base = calloc(1, sizeof(npppd_auth_radius))) != NULL) {
			npppd_auth_radius *_this = (npppd_auth_radius *)base;
			base->type = NPPPD_AUTH_TYPE_RADIUS;
			strlcpy(base->name, name, sizeof(base->name));
			base->npppd = _npppd;
			if ((_this->rad_auth_setting =
			    radius_req_setting_create()) == NULL)
				goto radius_fail;
			if ((_this->rad_acct_setting =
			    radius_req_setting_create()) == NULL)
				goto radius_fail;

			return base;
radius_fail:
			if (_this->rad_auth_setting != NULL)
				radius_req_setting_destroy(
				    _this->rad_auth_setting);
			if (_this->rad_acct_setting != NULL)
				radius_req_setting_destroy(
				    _this->rad_acct_setting);
			free(base);
			return NULL;
		}

		break;
#endif

	default:
		NPPPD_AUTH_ASSERT(0);
		break;
	}

	return NULL;
}

/**
 * Call this function to make the object unusable.
 * <p>
 * {@@link ::npppd_auth_base} objects is refered by the {@@link ::npppd_ppp}
 * object.   After this funcation is called, npppd will disconnect the PPP
 * links that refers the object, it will call {@@link ::npppd_auth_destroy()}
 * when all the references to the object are released.</p>
 */
void
npppd_auth_dispose(npppd_auth_base *base)
{

	base->disposing = 1;

	return;
}

/** Destroy the {@@link ::npppd_auth_base} object.  */
void
npppd_auth_destroy(npppd_auth_base *base)
{

	if (base->disposing == 0)
		npppd_auth_dispose(base);

	npppd_auth_base_log(base, LOG_INFO, "Finalized");

	switch(base->type) {
	case NPPPD_AUTH_TYPE_LOCAL:
		memset(base, 0, sizeof(npppd_auth_local));
		break;

#ifdef USE_NPPPD_RADIUS
	case NPPPD_AUTH_TYPE_RADIUS:
	    {
		npppd_auth_radius *_this = (npppd_auth_radius *)base;
		if (_this->rad_auth_setting != NULL)
			radius_req_setting_destroy(_this->rad_auth_setting);
		_this->rad_auth_setting = NULL;
		if (_this->rad_acct_setting != NULL)
			radius_req_setting_destroy(_this->rad_acct_setting);
		_this->rad_acct_setting = NULL;
		memset(base, 0, sizeof(npppd_auth_local));
		break;
	    }
#endif
	}
	free(base);

	return;
}

/** Reload the configuration */
int
npppd_auth_reload(npppd_auth_base *base)
{
	struct authconf *auth;

	TAILQ_FOREACH(auth, &base->npppd->conf.authconfs, entry) {
		if (strcmp(auth->name, base->name) == 0)
			break;
	}
	if (auth == NULL)
		return 1;

	base->pppsuffix[0] = '\0';
	if (auth->username_suffix != NULL)
		strlcpy(base->pppsuffix, auth->username_suffix,
		    sizeof(base->pppsuffix));
	base->eap_capable = auth->eap_capable;
	base->strip_nt_domain = auth->strip_nt_domain;
	base->strip_atmark_realm = auth->strip_atmark_realm;
	base->has_users_file = 0;
	base->radius_ready = 0;

	if (strlen(auth->users_file_path) > 0) {
		strlcpy(base->users_file_path, auth->users_file_path,
		    sizeof(base->users_file_path));
		base->has_users_file = 1;
	} else {
		if (base->type == NPPPD_AUTH_TYPE_LOCAL) {
			npppd_auth_base_log(base,
			    LOG_WARNING, "missing users_file property.");
			goto fail;
		}
	}

	switch (base->type) {
#ifdef USE_NPPPD_RADIUS
	case NPPPD_AUTH_TYPE_RADIUS:
		if (npppd_auth_radius_reload(base, auth) != 0)
			goto fail;
		break;
#endif
	}
	base->initialized = 1;

	return 0;

fail:
	base->initialized = 0;
	base->has_users_file = 0;
	base->radius_ready = 0;

	return 1;
}

/**
 * This function gets specified user's password. The value 0 is returned
 * if the call succeeds.
 *
 * @@param	username	username which gets the password
 * @@param	password	buffers which stores the password
 *				Specify NULL if you want to known the length of
 *				the password only.
 * @@param	lppassword	pointer which indicates the length of
 *				the buffer which stores the password.
 * @@return A value 1 is returned if user is unknown. A value 2 is returned
 *				if password buffer is sufficient. A negative value is
 *				returned if other error occurred.
 */
int
npppd_auth_get_user_password(npppd_auth_base *base,
    const char *username, char *password, int *plpassword)
{
	int              retval, sz, lpassword;
	npppd_auth_user *user;

	NPPPD_AUTH_ASSERT(base != NULL);
	NPPPD_AUTH_DBG((base, LOG_DEBUG, "%s(%s)", __func__, username));

	user = NULL;
	retval = 0;
	if (base->has_users_file == 0) {
		retval = -1;
		goto out;
	}
	if ((user = npppd_auth_get_user(base, username)) == NULL) {
		retval = 1;
		goto out;
	}
	if (password == NULL && plpassword == NULL) {
		retval = 0;
		goto out;
	}
	if (plpassword == NULL) {
		retval = -1;
		goto out;
	}
	lpassword = strlen(user->password) + 1;
	sz = *plpassword;
	*plpassword = lpassword;
	if (password == NULL) {
		retval = 0;
		goto out;
	}
	if (sz < lpassword) {
		retval = 2;
		goto out;
	}
	strlcpy(password, user->password, sz);
out:
	free(user);

	return retval;
}

/**
 * This function gets specified users' Framed-IP-{Address,Netmask}.
 * The value 0 is returned if the call succeeds.
 * <p>
 * Because authentication database is updated at any time, the password is
 * possible to be inconsistent if this function is not called immediately
 * after authentication. So this function is called immediately after
 * authentication. </p>
 * @@param	username	username which gets the password
 * @@param	ip4address	pointer which indicates struct in_addr which
 *						stores the Framed-IP-Address
 * @@param	ip4netmask	pointer which indicates struct in_addr which
 *						stores Framed-IP-Netmask
 */
int
npppd_auth_get_framed_ip(npppd_auth_base *base, const char *username,
    struct in_addr *ip4address, struct in_addr *ip4netmask)
{
	npppd_auth_user *user;

	NPPPD_AUTH_ASSERT(base != NULL);
	NPPPD_AUTH_DBG((base, LOG_DEBUG, "%s(%s)", __func__, username));
	if (base->has_users_file == 0)
		return -1;

	if ((user = npppd_auth_get_user(base, username)) == NULL)
		return 1;

	if (user->framed_ip_address.s_addr != 0) {
		*ip4address = user->framed_ip_address;
		if (ip4netmask != NULL)
			*ip4netmask = user->framed_ip_netmask;

		free(user);
		return 0;
	}
	free(user);

	return 1;
}

/**
 * Retribute "Calling-Number" attribute of the user from the realm.
 *
 * @@param username	Username.
 * @@param number	Pointer to the space for the Calling-Number.  This
 *	can be NULL in case retributing the Calling-Number only.
 * @@param plnumber	Pointer to the length of the space for the
 *	Calling-Number.
 * @@return 0 if the Calling-Number attribute is successfully retributed.
 *	1 if the user has no Calling-Number attribute.  return -1 if the realm
 *	doesn't have user attributes or other errors.   return 2 if the space
 *	is not enough.
 */
int
npppd_auth_get_calling_number(npppd_auth_base *base, const char *username,
    char *number, int *plnumber)
{
	int              retval, lcallnum, sz;
	npppd_auth_user *user;

	user = NULL;
	retval = 0;
	if (base->has_users_file == 0)
		return -1;

	if ((user = npppd_auth_get_user(base, username)) == NULL)
		return 1;

	if (number == NULL && plnumber == NULL) {
		retval = 0;
		goto out;
	}
	if (plnumber == NULL) {
		retval = -1;
		goto out;
	}
	lcallnum = strlen(user->calling_number) + 1;
	sz = *plnumber;
	*plnumber = lcallnum;
	if (sz < lcallnum) {
		retval = 2;
		goto out;
	}
	strlcpy(number, user->calling_number, sz);

out:
	free(user);

	return retval;
}

int
npppd_auth_get_type(npppd_auth_base *base)
{
	return base->type;
}

int
npppd_auth_is_usable(npppd_auth_base *base)
{
    	return (base->initialized != 0 && base->disposing == 0)? 1 : 0;
}

int
npppd_auth_is_ready(npppd_auth_base *base)
{
	if (!npppd_auth_is_usable(base))
		return 0;

	switch(base->type) {
	case NPPPD_AUTH_TYPE_LOCAL:
		return (base->has_users_file)? 1 : 0;
		/* NOTREACHED */

	case NPPPD_AUTH_TYPE_RADIUS:
		return (base->has_users_file != 0 ||
		    base->radius_ready != 0)? 1 : 0;
		/* NOTREACHED */
	}
	NPPPD_AUTH_ASSERT(0);

    	return 0;
}

int
npppd_auth_is_disposing(npppd_auth_base *base)
{
	return (base->disposing != 0)? 1 : 0;
}

int
npppd_auth_is_eap_capable(npppd_auth_base *base)
{
	return (base->eap_capable != 0)? 1 : 0;
}

const char *
npppd_auth_get_name(npppd_auth_base *base)
{
	return base->name;
}

const char *
npppd_auth_get_suffix(npppd_auth_base *base)
{
	return base->pppsuffix;
}

const char *
npppd_auth_username_for_auth(npppd_auth_base *base, const char *username,
    char *username_buffer)
{
	const char *u0;
	char *atmark, *u1;

	u0 = NULL;
	if (base->strip_nt_domain != 0) {
		if ((u0 = strchr(username, '\\')) != NULL)
			u0++;
	}
	if (u0 == NULL)
		u0 = username;
	u1 = username_buffer;
	if (username_buffer != u0)
		memmove(username_buffer, u0, MINIMUM(strlen(u0) + 1,
		    MAX_USERNAME_LENGTH));
	if (base->strip_atmark_realm != 0) {
		if ((atmark = strrchr(u1, '@@')) != NULL)
			*atmark = '\0';
	}

	return username_buffer;
}

/***********************************************************************
 * Account list related functions
 ***********************************************************************/
static npppd_auth_user *
npppd_auth_get_user(npppd_auth_base *base, const char *username)
{
	int              lsuffix, lusername;
	const char      *un;
	char             buf[MAX_USERNAME_LENGTH];
	npppd_auth_user *u;

	un = username;
	lsuffix = strlen(base->pppsuffix);
	lusername = strlen(username);
	if (lsuffix > 0 && lusername > lsuffix &&
	    strcmp(username + lusername - lsuffix, base->pppsuffix) == 0 &&
	    lusername - lsuffix < sizeof(buf)) {
		memcpy(buf, username, lusername - lsuffix);
		buf[lusername - lsuffix] = '\0';
		un = buf;
	}
	
	if (priv_get_user_info(base->users_file_path, un, &u) == 0)
		return u;

	return NULL;
}

#ifdef USE_NPPPD_RADIUS
/***********************************************************************
 * RADIUS
 ***********************************************************************/
/** reload the configuration of RADIUS authentication realm */
static int
npppd_auth_radius_reload(npppd_auth_base *base, struct authconf *auth)
{
	npppd_auth_radius  *_this = (npppd_auth_radius *)base;
	radius_req_setting *rad;
	struct radserver   *server;
	int                 i, nauth, nacct;

	_this->rad_auth_setting->timeout =
	    (auth->data.radius.auth.timeout == 0)
		    ? DEFAULT_RADIUS_TIMEOUT : auth->data.radius.auth.timeout;
	_this->rad_acct_setting->timeout =
	    (auth->data.radius.acct.timeout == 0)
		    ? DEFAULT_RADIUS_TIMEOUT : auth->data.radius.acct.timeout;


	_this->rad_auth_setting->max_tries =
	    (auth->data.radius.auth.max_tries == 0)
		    ? DEFAULT_RADIUS_MAX_TRIES : auth->data.radius.auth.max_tries;
	_this->rad_acct_setting->max_tries =
	    (auth->data.radius.acct.max_tries == 0)
		    ? DEFAULT_RADIUS_MAX_TRIES : auth->data.radius.acct.max_tries;

	_this->rad_auth_setting->max_failovers =
	    (auth->data.radius.auth.max_failovers == 0)
		    ? DEFAULT_RADIUS_MAX_FAILOVERS
		    : auth->data.radius.auth.max_failovers;
	_this->rad_acct_setting->max_failovers =
	    (auth->data.radius.acct.max_failovers == 0)
		    ? DEFAULT_RADIUS_MAX_FAILOVERS
		    : auth->data.radius.acct.max_failovers;

	_this->rad_acct_setting->curr_server = 
	_this->rad_auth_setting->curr_server = 0;

	/* load configs for authentication server */
	rad = _this->rad_auth_setting;
	for (i = 0; i < countof(rad->server); i++)
		memset(&rad->server[i], 0, sizeof(rad->server[0]));
	i = 0;
	TAILQ_FOREACH(server, &auth->data.radius.auth.servers, entry) {
		if (i >= countof(rad->server))
			break;
		memcpy(&rad->server[i].peer, &server->address,
		    server->address.ss_len);
		if (((struct sockaddr_in *)&rad->server[i].peer)->sin_port
		    == 0)
			((struct sockaddr_in *)&rad->server[i].peer)->sin_port
			    = htons(DEFAULT_RADIUS_AUTH_PORT);
		strlcpy(rad->server[i].secret, server->secret,
		    sizeof(rad->server[i].secret));
		rad->server[i].enabled = 1;
		i++;
	}
	nauth = i;

	/* load configs for accounting server */
	rad = _this->rad_acct_setting;
	for (i = 0; i < countof(rad->server); i++)
		memset(&rad->server[i], 0, sizeof(rad->server[0]));
	i = 0;
	TAILQ_FOREACH(server, &auth->data.radius.acct.servers, entry) {
		if (i >= countof(rad->server))
			break;
		memcpy(&rad->server[i].peer, &server->address,
		    server->address.ss_len);
		if (((struct sockaddr_in *)&rad->server[i].peer)->sin_port
		    == 0)
			((struct sockaddr_in *)&rad->server[i].peer)->sin_port
			    = htons(DEFAULT_RADIUS_ACCT_PORT);
		strlcpy(rad->server[i].secret, server->secret,
		    sizeof(rad->server[i].secret));
		rad->server[i].enabled = 1;
		i++;
	}
	nacct = i;

	for (i = 0; i < countof(_this->rad_auth_setting->server); i++) {
		if (_this->rad_auth_setting->server[i].enabled)
			base->radius_ready = 1;
	}

	npppd_auth_base_log(&_this->nar_base, LOG_INFO,
	    "Loaded configuration.  %d authentication server%s, %d accounting "
	    "server%s.",
	    nauth, (nauth > 1)? "s" : "", nacct, (nacct > 1)? "s" : "");

	return 0;
}

/**
 * Get {@@link ::radius_req_setting} for RADIUS authentication of specified
 * {@@link ::npppd_auth_base} object.
 */
void *
npppd_auth_radius_get_radius_auth_setting(npppd_auth_radius *_this)
{
	return _this->rad_auth_setting;
}

/**
 * Get {@@link ::radius_req_setting} for RADIUS accounting of specified
 * {@@link ::npppd_auth_base} object.
 */
void *
npppd_auth_radius_get_radius_acct_setting(npppd_auth_radius *_this)
{
	return _this->rad_acct_setting;
}

#endif

/***********************************************************************
 * Helper functions
 ***********************************************************************/
/** Log it which starts the label based on this instance. */
static int
npppd_auth_base_log(npppd_auth_base *_this, int prio, const char *fmt, ...)
{
	int status;
	char logbuf[BUFSIZ];
	va_list ap;

	NPPPD_AUTH_ASSERT(_this != NULL);
	va_start(ap, fmt);
	snprintf(logbuf, sizeof(logbuf), "realm name=%s %s",
	    _this->name, fmt);
	status = vlog_printf(prio, logbuf, ap);
	va_end(ap);

	return status;
}
@


1.18
log
@Fix: "authconf.users_file_path" is a char[] but is checked as a char*.

Diff from Mathieu Papineau (via Claer)
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.17 2015/12/05 18:43:36 mmcc Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.17 2015/12/05 18:43:36 mmcc Exp $ */
a77 2
			base->strip_nt_domain = 1;
			base->strip_atmark_realm = 0;
a89 1
			base->strip_nt_domain = 0;
@


1.17
log
@strings.h -> string.h to prevent an implicit declaration. Also remove a
bunch of NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.16 2015/01/19 01:48:59 deraadt Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.16 2015/01/19 01:48:59 deraadt Exp $ */
d200 1
a200 1
	if (auth->users_file_path != NULL) {
@


1.16
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.15 2014/08/22 04:36:16 jsg Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.15 2014/08/22 04:36:16 jsg Exp $ */
d287 1
a287 2
	if (user != NULL)
		free(user);
d379 1
a379 2
	if (user != NULL)
		free(user);
@


1.15
log
@remove an uneeded test
ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.14 2014/05/30 05:06:00 yasuoka Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.14 2014/05/30 05:06:00 yasuoka Exp $ */
d459 1
a459 1
		memmove(username_buffer, u0, MIN(strlen(u0) + 1,
@


1.14
log
@Use calloc instead of malloc and memset.

from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.13 2014/03/22 04:23:17 yasuoka Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.13 2014/03/22 04:23:17 yasuoka Exp $ */
d191 6
a196 9
	if (auth != NULL) {
		if (auth->username_suffix != NULL)
			strlcpy(base->pppsuffix, auth->username_suffix,
			    sizeof(base->pppsuffix));
		base->eap_capable = auth->eap_capable;
		base->strip_nt_domain = auth->strip_nt_domain;
		base->strip_atmark_realm = auth->strip_atmark_realm;
	}

@


1.13
log
@Fixed a bug in npppd_auth_get_user() which caused segmentation faults after
a user authentication is succeeded in case the authentication config option
has `username-suffix' and 'strip-atmark-realm' is yes. Delete
`username-prefix' from authentication setting.  This config option was
mis-leading and useless.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.12 2013/01/31 09:44:21 yasuoka Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.12 2013/01/31 09:44:21 yasuoka Exp $ */
d76 1
a76 2
		if ((base = malloc(sizeof(npppd_auth_local))) != NULL) {
			memset(base, 0, sizeof(npppd_auth_local));
d89 1
a89 1
		if ((base = malloc(sizeof(npppd_auth_radius))) != NULL) {
a90 1
			memset(base, 0, sizeof(npppd_auth_radius));
@


1.12
log
@port numbers for radius servers were not configured correctly.

pointed out by mxb and Robert Blacquiere
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.11 2012/09/22 20:22:48 espie Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.11 2012/09/22 20:22:48 espie Exp $ */
a191 1
	base->pppprefix[0] = '\0';
a196 3
		if (auth->username_prefix != NULL)
			strlcpy(base->pppprefix, auth->username_prefix,
			    sizeof(base->pppprefix));
a448 6
npppd_auth_get_prefix(npppd_auth_base *base)
{
	return base->pppprefix;
}

const char *
d487 4
a490 6
	if (lsuffix > 0) {
		/* Strip the suffix */
		lusername = strlen(username);
		NPPPD_AUTH_ASSERT(lusername + 1 < sizeof(buf));
		if (lusername + 1 >= sizeof(buf))
			return NULL;
@


1.11
log
@gcc2 doesn't like unnamed fields. make this compile on vax again.
"looks right" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.10 2012/09/18 13:14:08 yasuoka Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.10 2012/09/18 13:14:08 yasuoka Exp $ */
d564 4
d585 4
@


1.10
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.9 2012/06/05 06:31:27 yasuoka Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.9 2012/06/05 06:31:27 yasuoka Exp $ */
d528 2
a529 2
	    (auth->radius.auth.timeout == 0)
		    ? DEFAULT_RADIUS_TIMEOUT : auth->radius.auth.timeout;
d531 2
a532 2
	    (auth->radius.acct.timeout == 0)
		    ? DEFAULT_RADIUS_TIMEOUT : auth->radius.acct.timeout;
d536 2
a537 2
	    (auth->radius.auth.max_tries == 0)
		    ? DEFAULT_RADIUS_MAX_TRIES : auth->radius.auth.max_tries;
d539 2
a540 2
	    (auth->radius.acct.max_tries == 0)
		    ? DEFAULT_RADIUS_MAX_TRIES : auth->radius.acct.max_tries;
d543 1
a543 1
	    (auth->radius.auth.max_failovers == 0)
d545 1
a545 1
		    : auth->radius.auth.max_failovers;
d547 1
a547 1
	    (auth->radius.acct.max_failovers == 0)
d549 1
a549 1
		    : auth->radius.acct.max_failovers;
d559 1
a559 1
	TAILQ_FOREACH(server, &auth->radius.auth.servers, entry) {
d576 1
a576 1
	TAILQ_FOREACH(server, &auth->radius.acct.servers, entry) {
@


1.9
log
@don't use `reigai' that means `exception' in Japanese as labels.
no binary change.

from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.8 2012/05/08 13:15:11 yasuoka Exp $ */
d29 1
a29 2
/* $Id: npppd_auth.c,v 1.8 2012/05/08 13:15:11 yasuoka Exp $ */
/* I hope to write the source code in npppd-independent as possible. */
a46 1
#include "hash.h"
a49 1
#include "config_helper.h"
a50 1
#include "csvreader.h"
a53 1
static const char *npppd_auth_default_label(npppd_auth_base *);
d60 1
a60 1
 * @@param label		the configuration label
d68 1
a68 1
npppd_auth_create(int auth_type, const char *label, void *_npppd)
d72 1
a72 1
	NPPPD_AUTH_ASSERT(label != NULL);
a78 1
			base->users_hash = NULL;
d81 1
a81 1
			strlcpy(base->label, label, sizeof(base->label));
d95 1
a95 1
			strlcpy(base->label, label, sizeof(base->label));
a140 3
	if (base->users_hash != NULL)
		hash_delete_all(base->users_hash, 1);

a151 5
	if (base->users_hash != NULL) {
		hash_free(base->users_hash);
		base->users_hash = NULL;
	}

d183 8
a190 1
	const char *val;
d192 13
a204 24
	val = npppd_auth_config_str(base, "name");
	if (val == NULL)
		/* use the label if .name is not defined. */
		strlcpy(base->name, npppd_auth_default_label(base),
		    sizeof(base->name));
	else
		strlcpy(base->name, val, sizeof(base->name));

	if ((val = npppd_auth_config_str(base, "pppsuffix")) != NULL)
		strlcpy(base->pppsuffix, val, sizeof(base->pppsuffix));
	else
		base->pppsuffix[0] = '\0';

	if ((val = npppd_auth_config_str(base, "pppprefix")) != NULL)
		strlcpy(base->pppprefix, val, sizeof(base->pppprefix));
	else
		base->pppprefix[0] = '\0';

	base->eap_capable =
	    npppd_auth_config_str_equal(base, "eap_capable", "true", 1);
	base->strip_nt_domain =
	    npppd_auth_config_str_equal(base, "strip_nt_domain", "true", 1);
	base->strip_atmark_realm =
	    npppd_auth_config_str_equal(base, "strip_atmark_realm", "true", 0);
d206 1
a206 2
	base->has_acctlist = 0;
	base->acctlist_ready = 0;
a207 15
	if ((val = npppd_auth_config_str(base, "acctlist")) != NULL) {
		strlcpy(base->acctlist_path, val, sizeof(base->acctlist_path));
		if (base->users_hash == NULL) {
			if ((base->users_hash = hash_create(
			    (int (*)(const void *, const void *))strcmp,
				str_hash, 1021)) == NULL) {
				npppd_auth_base_log(base,
				    LOG_WARNING, "hash_create() failed: %m.");
				goto fail;
			}
		}
		base->reloadable = NPPPD_DEFAULT_AUTH_LOCAL_RELOADABLE;
		base->has_acctlist = 1;
		if (npppd_auth_reload_acctlist(base) != 0)
			goto fail;
d209 4
d216 1
a216 1
			    LOG_WARNING, "missing acctlist property.");
d224 1
a224 1
		if (npppd_auth_radius_reload(base) != 0)
d235 1
a235 2
	base->has_acctlist = 0;
	base->acctlist_ready = 0;
d259 1
a259 1
	int sz, lpassword;
d265 18
a282 13
	if (base->has_acctlist == 0 || base->acctlist_ready == 0)
		return -1;

	if (base->reloadable != 0)
		npppd_auth_reload_acctlist(base);

	if ((user = npppd_auth_find_user(base, username)) == NULL)
		return 1;

	if (password == NULL && plpassword == NULL)
		return 0;
	if (plpassword == NULL)
		return -1;
d286 12
a297 4
	if (password == NULL)
		return 0;
	if (sz < lpassword)
		return 2;
d299 1
a299 2
	strlcpy(password, user->password, sz);
	return 0;
d324 1
a324 1
	if (base->has_acctlist == 0 || base->acctlist_ready == 0)
d327 1
a327 1
	if ((user = npppd_auth_find_user(base, username)) == NULL)
d335 1
d338 1
d360 1
a360 1
	int lcallnum, sz;
d363 3
a365 1
	if (base->has_acctlist == 0 || base->acctlist_ready == 0)
d368 1
a368 1
	if ((user = npppd_auth_find_user(base, username)) == NULL)
d371 8
a378 4
	if (number == NULL && plnumber == NULL)
		return 0;
	if (plnumber == NULL)
		return -1;
d382 4
a385 2
	if (sz < lcallnum)
		return 2;
d388 5
a392 1
	return 0;
d415 1
a415 1
		return (base->acctlist_ready != 0)? 1 : 0;
d419 1
a419 1
		return (base->acctlist_ready != 0 ||
a440 6
npppd_auth_get_label(npppd_auth_base *base)
{
	return base->label;
}

const char *
a486 196
/** Reload the account list */
static int
npppd_auth_reload_acctlist(npppd_auth_base *base)
{
	CSVREADER_STATUS status;
	int linno, ncols, usersz, nuser, eof, off;
	const char **cols, *passwd, *callnum;
	char line[8192];
	csvreader *csv;
	npppd_auth_user *user;
	struct in_addr ip4, ip4mask;
	slist users;
	FILE *file;
	struct stat st;

	if (base->acctlist_ready != 0 && lstat(base->acctlist_path, &st) == 0) {
		if (st.st_mtime == base->last_load)
			return 0;
		base->last_load = st.st_mtime;
	}

	slist_init(&users);
	csv = NULL;
	if ((file = priv_fopen(base->acctlist_path)) == NULL) {
		/* hash is empty if file is not found. */
		if (errno == ENOENT)
			hash_delete_all(base->users_hash, 1);
		npppd_auth_base_log(base,
		    (errno == ENOENT)? LOG_DEBUG : LOG_ERR,
		    "Open %s failed: %m", base->acctlist_path);
		return 0;
	}
	if ((csv = csvreader_create()) == NULL) {
		npppd_auth_base_log(base, LOG_ERR,
		    "Loading a account list failed: csvreader_create(): %m");
		goto fail;
	}

	for (linno = 0, eof = 0; !eof;) {
		ip4.s_addr = 0;
		ip4mask.s_addr = 0xffffffffL;
		if (fgets(line, sizeof(line), file) != NULL) {
			int linelen;

			linelen = strlen(line);
			if (linelen <= 0) {
				npppd_auth_base_log(base, LOG_ERR,
				    "Loading a account list failed: lineno=%d "
				    "line too short", linno + 1);
				goto fail;
			}
			if (line[linelen - 1] != '\n' && !feof(file)) {
				npppd_auth_base_log(base, LOG_ERR,
				    "Loading a account list failed: lineno=%d "
				    "line too long", linno + 1);
				goto fail;
			}

			status = csvreader_parse(csv, line);
		} else {
			if (!feof(file)) {
				npppd_auth_base_log(base, LOG_ERR,
				    "Loading a account list failed: %m");
				goto fail;
			}
			status = csvreader_parse_flush(csv);
			eof = 1;
		}
		if (status != CSVREADER_NO_ERROR) {
			if (status == CSVREADER_OUT_OF_MEMORY)
				npppd_auth_base_log(base, LOG_ERR,
				    "Loading a account list failed: %m");
			else
				npppd_auth_base_log(base, LOG_ERR,
				    "Loading a account list "
				    "failed: lineno=%d parse error", linno);
			goto fail;
		}
		ncols = csvreader_get_number_of_column(csv);
		if ((cols = csvreader_get_column(csv)) == NULL)
			continue;
		linno++; /* count up here because line number is treated as CSV. */
		if (linno == 1) {
			/* skip a title line */
			continue;
		}
		if (ncols < 1) {
			npppd_auth_base_log(base, LOG_ERR,
			    "account list lineno=%d has only %d fields.",
			    linno, ncols);
			continue;
		}
		if (strlen(cols[0]) <= 0)
			continue;	/* skip if the user-name is empty */
		if (ncols >= 3) {
			if (*cols[2] != '\0' && inet_aton(cols[2], &ip4) != 1) {
				npppd_auth_base_log(base, LOG_ERR,
				    "account list lineno=%d parse error: "
				    "invalid 'Framed-IP-Address' field: %s",
				    linno, cols[2]);
				continue;
			}
		}
		if (ncols >= 4) {
			if ((*cols[3] != '\0' &&
			    inet_aton(cols[3], &ip4mask) != 1) ||
			    netmask2prefixlen(htonl(ip4mask.s_addr)) < 0) {
				npppd_auth_base_log(base, LOG_ERR,
				    "account list lineno=%d parse error: "
				    "invalid 'Framed-IP-Netmask' field: %s",
				    linno, cols[3]);
				continue;
			}
		}

		passwd = "";
		if (cols[1] != NULL)
			passwd = cols[1];
		callnum = "";
		if (ncols >= 6 && cols[5] != NULL)
			callnum = cols[5];

		usersz = sizeof(npppd_auth_user);
		usersz += strlen(cols[0]) + 1;
		usersz += strlen(passwd) + 1;
		usersz += strlen(callnum) + 1;
		if ((user = malloc(usersz)) == NULL) {
			npppd_auth_base_log(base, LOG_ERR,
			    "Loading a account list failed: %m");
			goto fail;
		}
		memset(user, 0, usersz);

		off = 0;

		user->username = user->space + off;
		off += strlcpy(user->username, cols[0], usersz - off);
		++off;

		user->password = user->space + off;
		off += strlcpy(user->password, passwd, usersz - off);
		++off;

		user->calling_number = user->space + off;
		strlcpy(user->calling_number, callnum, usersz - off);

		user->framed_ip_address = ip4;
		user->framed_ip_netmask = ip4mask;

		slist_add(&users, user);
	}
	hash_delete_all(base->users_hash, 1);

	nuser = 0;
	for (slist_itr_first(&users); slist_itr_has_next(&users);) {
		user = slist_itr_next(&users);
		if (hash_lookup(base->users_hash, user->username) != NULL) {
			npppd_auth_base_log(base, LOG_WARNING,
			    "Record for user='%s' is redefined, the first "
			    "record will be used.",  user->username);
			free(user);
			goto next_user;
		}
		if (hash_insert(base->users_hash, user->username, user) != 0) {
			npppd_auth_base_log(base, LOG_ERR,
			    "Loading a account list failed: hash_insert(): %m");
			goto fail;
		}
		nuser++;
next_user:
		slist_itr_remove(&users);
	}
	slist_fini(&users);
	csvreader_destroy(csv);

	fclose(file);
	npppd_auth_base_log(base, LOG_INFO,
	    "Loaded users from='%s' successfully.  %d users",
	    base->acctlist_path, nuser);
	base->acctlist_ready = 1;

	return 0;
fail:
	fclose(file);
	if (csv != NULL)
		csvreader_destroy(csv);
	hash_delete_all(base->users_hash, 1);
	for (slist_itr_first(&users); slist_itr_has_next(&users);) {
		user = slist_itr_next(&users);
		free(user);
	}
	slist_fini(&users);

	return 1;
}

d488 1
a488 1
npppd_auth_find_user(npppd_auth_base *base, const char *username)
d490 4
a493 4
	int lsuffix, lusername;
	const char *un;
	char buf[MAX_USERNAME_LENGTH];
	hash_link *hl;
d507 3
d511 1
a511 4
	if ((hl = hash_lookup(base->users_hash, un)) == NULL)
		return NULL;

	return hl->item;
a517 37

static int
radius_server_address_load(radius_req_setting *radius, int idx,
    const char *address, enum RADIUS_SERVER_TYPE type)
{
	struct addrinfo *ai;
	struct sockaddr_in *sin4;

	memset(&radius->server[idx], 0, sizeof(radius->server[0]));

	if (addrport_parse(address, IPPROTO_TCP, &ai) !=0)
		return 1;

	switch (ai->ai_family) {
	default:
		freeaddrinfo(ai);
		return 1;
	case AF_INET:
	case AF_INET6:
		break;
	}

	sin4 = (struct sockaddr_in *)(ai->ai_addr);
	if (sin4->sin_port == 0)
		sin4->sin_port = htons((type == RADIUS_SERVER_TYPE_AUTH)
		    ? DEFAULT_RADIUS_AUTH_PORT : DEFAULT_RADIUS_ACCT_PORT);

	memcpy(&radius->server[idx].peer, ai->ai_addr,
	    MIN(sizeof(radius->server[idx].peer), ai->ai_addrlen));

	freeaddrinfo(ai);
	radius->server[idx].enabled = 1;

	return 0;
}

#define	VAL_SEP		" \t\r\n"
d520 1
a520 1
npppd_auth_radius_reload(npppd_auth_base *base)
d522 16
a537 6
	npppd_auth_radius *_this = (npppd_auth_radius *)base;
	int i, nauth, nacct;

	_this->rad_acct_setting->timeout = _this->rad_auth_setting->timeout =
	    npppd_auth_config_int(base, "timeout", DEFAULT_RADIUS_TIMEOUT);

d539 2
a540 3
	_this->rad_auth_setting->max_tries = 
		npppd_auth_config_int(base, "max_tries",
		    DEFAULT_RADIUS_MAX_TRIES);
d542 4
d547 3
a549 3
	_this->rad_auth_setting->max_failovers = 
		npppd_auth_config_int(base, "max_failovers",
		    DEFAULT_RADIUS_MAX_FAILOVERS);
d553 34
a586 6
	if ((nauth = radius_loadconfig(base, _this->rad_auth_setting,
	    RADIUS_SERVER_TYPE_AUTH)) < 0)
		goto fail;
	if ((nacct = radius_loadconfig(base, _this->rad_acct_setting,
	    RADIUS_SERVER_TYPE_ACCT)) < 0)
		goto fail;
d595 2
a596 3
	    "server%s.  timeout=%dsec",
	    nauth, (nauth > 1)? "s" : "", nacct, (nacct > 1)? "s" : "",
	    _this->rad_auth_setting->timeout);
a598 91
fail:
	npppd_auth_destroy(base);

	return 1;
}

static int
radius_loadconfig(npppd_auth_base *base, radius_req_setting *radius,
    enum RADIUS_SERVER_TYPE srvtype)
{
	npppd_auth_radius *_this = (npppd_auth_radius *)base;
	int i, n;
	const char *val;
	char *tok, *buf0, buf[NPPPD_CONFIG_BUFSIZ];
	char label[256];
	struct rad_cfglabel  {
		const char *list;
		const char *address;
		const char *secret;
		const char *addressL;
		const char *secretL;
	} const rad_auth_cfglabel = {
		.list = "server_list",
		.address = "server.address",
		.secret = "server.secret",
		.addressL = "server.%s.address",
		.secretL = "server.%s.secret"
	}, rad_acct_cfglabel = {
		.list = "acct_server_list",
		.address = "acct_server.address",
		.secret = "acct_server.secret",
		.addressL = "acct_server.%s.address",
		.secretL = "acct_server.%s.secret"
	}, *cfglabel;

	if (srvtype == RADIUS_SERVER_TYPE_AUTH)
		cfglabel = &rad_auth_cfglabel;
	else
		cfglabel = &rad_acct_cfglabel;

	for (i = 0; i < countof(radius->server); i++)
	radius->server[i].enabled = 0;

	n = 0;
	if ((val = npppd_auth_config_str(base, cfglabel->list)) != NULL) {
		strlcpy(buf, val, sizeof(buf));
		buf0 = buf;
		while ((tok = strsep(&buf0, VAL_SEP)) != NULL) {
			if (tok[0] == '\0')
				continue;
			snprintf(label, sizeof(label), cfglabel->addressL,tok);
			if ((val = npppd_auth_config_str(base, label)) == NULL){
				npppd_auth_base_log(&_this->nar_base, LOG_INFO,
				    "property %s is not found", label);
				goto fail;
			}
			if (radius_server_address_load(radius, n, val, srvtype)
			    != 0) {
				npppd_auth_base_log(base, LOG_INFO,
				    "parse error at %s", label);
				goto fail;
			}
			snprintf(label, sizeof(label), cfglabel->secretL, tok);
			if ((val = npppd_auth_config_str(base, label)) != NULL)
				strlcpy(radius->server[n].secret, val,
				    sizeof(radius->server[n].secret));
			else
				radius->server[n].secret[0] = '\0';
			n++;
		}
	} else if ((val = npppd_auth_config_str(base, cfglabel->address))
	    != NULL) {
		if (radius_server_address_load(radius, n, val, srvtype) != 0) {
			npppd_auth_base_log(base, LOG_INFO,
			    "parse error at %s", label);
			goto fail;
		}
		if ((val = npppd_auth_config_str(base, cfglabel->secret))
		    != NULL) 
			strlcpy(radius->server[n].secret, val,
			    sizeof(radius->server[n].secret));
		else
			radius->server[n].secret[0] = '\0';
		n++;
	}
	for (i = n; i < countof(radius->server); i++)
		memset(&radius->server[i], 0, sizeof(radius->server[0]));

	return n;
fail:
	return -1;
d636 2
a637 3
	snprintf(logbuf, sizeof(logbuf), "realm name=%s(%s) %s",
	    _this->name, (_this->label[0] == '\0')? "default" : _this->label,
	    fmt);
a641 69
}

static uint32_t
str_hash(const void *ptr, int sz)
{
	u_int32_t hash = 0;
	int i, len;
	const char *str;

	str = ptr;
	len = strlen(str);
	for (i = 0; i < len; i++)
		hash = hash*0x1F + str[i];
	hash = (hash << 16) ^ (hash & 0xffff);

	return hash % sz;
}

static const char *
npppd_auth_default_label(npppd_auth_base *base)
{
	switch(base->type) {
	case NPPPD_AUTH_TYPE_LOCAL:
		return "local";
	case NPPPD_AUTH_TYPE_RADIUS:
		return "radius";
	}
	NPPPD_AUTH_ASSERT(0);

	return NULL;
}

static inline const char *
npppd_auth_config_prefix(npppd_auth_base *base)
{
	switch(base->type) {
	case NPPPD_AUTH_TYPE_LOCAL:
		return "auth.local.realm";

	case NPPPD_AUTH_TYPE_RADIUS:
		return "auth.radius.realm";

	}
	NPPPD_AUTH_ASSERT(0);

	return NULL;
}

static const char  *
npppd_auth_config_str(npppd_auth_base *base, const char *confKey)
{
	return config_named_prefix_str(((npppd *)base->npppd)->properties,
	    npppd_auth_config_prefix(base), base->label, confKey);
}

static int
npppd_auth_config_int(npppd_auth_base *base, const char *confKey, int defVal)
{
	return config_named_prefix_int(((npppd *)base->npppd)->properties,
	    npppd_auth_config_prefix(base), base->label, confKey, defVal);
}

static int
npppd_auth_config_str_equal(npppd_auth_base *base, const char *confKey,
    const char *confVal, int defVal)
{
	return config_named_prefix_str_equal(((npppd *)base->npppd)->properties,
	    npppd_auth_config_prefix(base), base->label, confKey, confVal,
	    defVal);
@


1.8
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_auth.c,v 1.7 2011/07/06 20:52:28 yasuoka Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.7 2011/07/06 20:52:28 yasuoka Exp $ */
d105 1
a105 1
				goto radius_reigai;
d108 1
a108 1
				goto radius_reigai;
d111 1
a111 1
radius_reigai:
d786 1
a786 1
		goto reigai;
d789 1
a789 1
		goto reigai;
d803 1
a803 1
reigai:
@


1.7
log
@Add RADIUS accounting support and some authentication related changes:

- Add functions to radius+.c that are required to implement RADIUS
  accounting.
- Send RADIUS Account-Start and Account-Stop messages with attributes that
  are defined by RFC 2866, 2868, 2869.
- If any authentication realm is deleted from the configuration, npppd may
  exit by segmentation fault.
- Delete radius_common.c, radius_common.h and eap.c because they are not
  used.
- Retransmission and failover are reimplemented.
- Cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: npppd_auth.c,v 1.6 2010/07/02 21:20:57 yasuoka Exp $ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.6 2010/07/02 21:20:57 yasuoka Exp $ */
d58 1
d173 1
d186 1
@


1.6
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.5 2010/07/01 03:38:17 yasuoka Exp $ */
d96 1
d102 6
d110 9
d120 1
d173 8
d183 1
d461 6
d725 1
a725 1
    const char *address)
d728 1
a728 1
	struct sockaddr_in *sin;
d744 5
a748 3
	sin = (struct sockaddr_in *)(ai->ai_addr);
	if (sin->sin_port == 0)
		sin->sin_port = htons(DEFAULT_RADIUS_AUTH_PORT);
d758 1
d764 47
d813 1
a813 1
	char *tok, *buf0, buf[NPPPD_CONFIG_BUFSIZ], logbuf[BUFSIZ];
d815 27
a842 1
#define	VAL_SEP		" \t\r\n"
d844 1
a844 5
	_this->rad_setting.timeout =
	    npppd_auth_config_int(base, "timeout", DEFAULT_RADIUS_AUTH_TIMEOUT);
	_this->rad_setting.curr_server = 0;

	if ((val = npppd_auth_config_str(base, "server_list")) != NULL) {
d850 4
a853 2
			snprintf(label, sizeof(label), "server.%s.address",tok);
			if ((val = npppd_auth_config_str(base, label)) == NULL)
d855 3
a857 2
			if (radius_server_address_load(&_this->rad_setting, n,
			    val) != 0) {
d862 1
a862 2
			snprintf(label, sizeof(label), "server.%s.secret",
			    tok);
d864 2
a865 3
				strlcpy(_this->rad_setting.server[n].secret,
				    val, sizeof(_this->rad_setting
					.server[n].secret));
d867 1
a867 3
				_this->rad_setting.server[n].secret[0] = '\0';
			if (n != 0)
				strlcat(logbuf, " ", sizeof(logbuf));
d870 1
a870 1
	} else if ((val = npppd_auth_config_str(base, "server.address"))
d872 1
a872 2
		if (radius_server_address_load(&_this->rad_setting, n, val)
		    != 0) {
d877 4
a880 3
		if ((val = npppd_auth_config_str(base, "server.secret"))!= NULL)
			strlcpy(_this->rad_setting.server[n].secret, val,
			    sizeof(_this->rad_setting.server[n].secret));
d882 1
a882 1
			_this->rad_setting.server[n].secret[0] = '\0';
d885 2
a886 8
	for (i = n; i < countof(_this->rad_setting.server); i++) {
		memset(&_this->rad_setting.server[i], 0,
		    sizeof(_this->rad_setting.server[0]));
	}
	for (i = 0; i < countof(_this->rad_setting.server); i++) {
		if (_this->rad_setting.server[i].enabled)
			base->radius_ready = 1;
	}
d888 1
a888 5
	npppd_auth_base_log(base, LOG_INFO,
	    "Loaded configuration timeout=%d nserver=%d",
	    _this->rad_setting.timeout, n);

	return 0;
d890 1
a890 3
	npppd_auth_destroy(base);

	return 1;
d894 2
a895 2
 * Get {@@link ::radius_req_setting} of specified {@@link ::npppd_auth_base}
 * object.
d898 1
a898 1
npppd_auth_radius_get_radius_req_setting(npppd_auth_radius *_this)
d900 1
a900 1
	return &_this->rad_setting;
d903 6
a908 4
/** This function notifies that RADIUS server failed the request. */
void
npppd_auth_radius_server_failure_notify(npppd_auth_radius *_this,
    struct sockaddr *server, const char *reason)
d910 2
a911 6
	int i, n;
	radius_req_setting *rad_setting;
	char buf0[BUFSIZ];

	NPPPD_AUTH_ASSERT(_this != NULL);
	NPPPD_AUTH_ASSERT(server != NULL);
a912 25
	if (reason == NULL)
		reason = "failure";

	rad_setting = &_this->rad_setting;
	if (memcmp(&rad_setting->server[rad_setting->curr_server].peer,
	    server, server->sa_len) == 0) {
		/*
		 * The RADIUS server which request was failed is currently selected,
		 * so next RADIUS server will be selected.
		 */
		for (i = 1; i < countof(rad_setting->server); i++) {
			n = (rad_setting->curr_server + i) %
			    countof(rad_setting->server);
			if (rad_setting->server[n].enabled == 0)
				continue;
			rad_setting->curr_server = n;
			break;
		}
	}

	npppd_auth_base_log(&_this->nar_base, LOG_NOTICE,
	    "server=%s request failure: %s",
		addrport_tostring(server, server->sa_len, buf0, sizeof(buf0)),
		reason);
}
@


1.5
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
d29 1
a29 1
/* $Id: npppd_auth.c,v 1.4 2010/01/31 05:49:51 yasuoka Exp $ */
d106 1
a106 1
	
d116 1
a116 1
 * Call this function to make the object unusable. 
d190 1
a190 1
	base->strip_nt_domain = 
d192 1
a192 1
	base->strip_atmark_realm = 
d244 1
a244 1
 * This function gets specified user's password. The value 0 is returned 
d254 1
a254 1
 *				if password buffer is sufficient. A negative value is 
d393 1
a393 1
		
d395 1
a395 1
		return (base->acctlist_ready != 0 || 
d520 1
a520 1
			
d701 1
a701 1
		return 1; 
d909 1
a909 1
	
@


1.4
log
@privilege separation of npppd.

- Drop privilege after daemon initializing.
- Some system calls that requires root privileges were replaced to
  wrapper functions that communicate with a separated privileged
  process via IPC.  And the privileged process checks whether the
  operations are acceptable.
@
text
@d26 3
a28 3
/**@@file 認証レルム */
/* $Id: npppd_auth.c,v 1.3 2010/01/14 23:35:39 yasuoka Exp $ */
/* なるべく npppd に非依存で書いていきたいところ。*/
d67 1
a67 1
 * in case success otherwise NULL wiil be returned.
d170 1
a170 1
		/* .name の定義がなければ、ラベルを使う */
d204 1
a204 1
				goto reigai;
d210 1
a210 1
			goto reigai;
d216 1
a216 1
			goto reigai;
d224 1
a224 1
			goto reigai;
d232 1
a232 1
reigai:
d242 2
a243 1
 * ユーザのパスワードを取得します。成功すると 0 が返ります。
d245 9
a253 7
 * @@param	username	パスワードを取得するユーザの名前
 * @@param	password	パスワードを格納する領域。
 *				パスワードの長さだけを知りたい場合には NULL
 *				を指定します。
 * @@param	lppassword	パスワードを格納する領域の長さのポインタ
 * @@return User unknown の場合は 1、パスワードバッファの長さが足りない場合
 * は 2、その他のエラーは負の数が返ります。
d291 2
a292 1
 * ユーザの Framed-IP-{Address,Netmask} を取得します。成功すると 0 が返ります。
d294 9
a302 7
 * 認証データベースは随時更新されるため、認証直後にこの関数を呼び出さないと、
 * パスワードと世代がズレる可能性があります。したがって認証直後にこの関数
 * を呼び出します。</p>
 * @@param	username	パスワードを取得するユーザの名前
 * @@param	ip4address	Framed-IP-Address を格納する struct in_addr 
 * @@param	ip4netmask	Framed-IP-Netmask を格納する struct in_addr 
 *	のポインタ
d485 1
a485 1
		/* ファイルが存在しない場合は、空とする */
d496 1
a496 1
		goto reigai;
d510 1
a510 1
				goto reigai;
d516 1
a516 1
				goto reigai;
d524 1
a524 1
				goto reigai;
d537 1
a537 1
			goto reigai;
d542 1
a542 1
		linno++; /* CSV としての行番号としたいのでココでカウント */
d590 1
a590 1
			goto reigai;
d627 1
a627 1
			goto reigai;
d643 1
a643 1
reigai:
d722 1
a722 1
/** RADIUS認証レルムの設定を読み込みます */
d746 1
a746 1
				goto reigai;
d751 1
a751 1
				goto reigai;
d771 1
a771 1
			goto reigai;
d794 1
a794 1
reigai:
d810 1
a810 1
/** RADIUS サーバが問い合わせに失敗したことを通知します。*/
d829 2
a830 2
		 * 失敗した Radius は現在カレントなので、次の Radius
		 * に切替える。
d852 1
a852 1
/** このインスタンスに基づいたラベルから始まるログを記録します。 */
@


1.3
log
@fix to compile with gcc4.  (from jsg@@)
@
text
@d27 1
a27 1
/* $Id: npppd_auth.c,v 1.2 2010/01/13 07:49:44 yasuoka Exp $ */
d478 1
a478 1
	if ((file = fopen(base->acctlist_path, "r")) == NULL) {
@


1.2
log
@cleanup npppd code.  delete IIJ local ifdef switches and fix warnings.
ok @@dlg
@
text
@d27 1
a27 1
/* $Id: npppd_auth.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $ */
d688 1
d703 4
a706 2
	if (sin46_port(ai->ai_addr) == 0)
		sin46_port(ai->ai_addr) = htons(DEFAULT_RADIUS_AUTH_PORT);
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d27 1
a27 1
/* $Id: npppd_auth.c 39106 2010-01-10 21:01:39Z yasuoka $ */
a269 5
#ifdef IDGW
	/* パスワードを * で潰してあるユーザは、パスワードは使わない */
	if (strcmp(user->password, "*") == 0) 
		return 1;
#endif
a481 10
#ifdef _SEIL_EXT_
		if (errno == ENOENT)
			npppd_auth_base_log(base, LOG_NOTICE,
			    "Realm is not ready");
		else
			npppd_auth_base_log(base, LOG_ERR,
			    "Open %s failed: %m", base->acctlist_path);
		base->acctlist_ready = 0;
		return 0;
#else
a485 1
#endif
@

