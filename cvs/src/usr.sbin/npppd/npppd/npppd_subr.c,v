head	1.18;
access;
symbols
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.18
date	2016.04.05.21.24.02;	author krw;	state Exp;
branches;
next	1.17;
commitid	3qdWFFf70QZsgEH7;

1.17
date	2015.09.13.08.22.10;	author mpi;	state Exp;
branches;
next	1.16;
commitid	bCMzmZ7dn8Rha8rl;

1.16
date	2015.01.19.01.48.59;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	a1BWBASyBgKKetQd;

1.15
date	2014.11.13.04.18.27;	author yasuoka;	state Exp;
branches;
next	1.14;
commitid	aNmYbtcRa1hFSyYK;

1.14
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.13;
commitid	2uw1UTO4k6erpWzK;

1.13
date	2014.08.14.08.08.00;	author mpi;	state Exp;
branches;
next	1.12;
commitid	ndedgDOHTJQiAjS1;

1.12
date	2014.06.13.06.35.58;	author yasuoka;	state Exp;
branches;
next	1.11;
commitid	QfBvDfn4t6LI6h2v;

1.11
date	2014.04.18.10.05.22;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.14.10.21.07;	author mpi;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.05.23.20.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.08.13.18.37;	author yasuoka;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.08.13.15.12;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.23.01.45.10;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.31.05.49.51;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.07.49.44;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Move more fcntl(,F_GETFL,0) -> fcntl(,F_GETFL).

No functional change.

ok guenther@@
@
text
@/*	$OpenBSD: npppd_subr.c,v 1.17 2015/09/13 08:22:10 mpi Exp $ */

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/**@@file
 * This file provides helper functions for npppd.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <net/route.h>
#include <net/if_dl.h>
#include <net/if.h>
#include <ifaddrs.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <fcntl.h>
#include <stdio.h>
#include <syslog.h>
#include <stddef.h>
#include <unistd.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <resolv.h>

#include "debugutil.h"
#include "addr_range.h"

#include "npppd_defs.h"
#include "npppd_subr.h"
#include "privsep.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

static u_int16_t route_seq = 0;
static int  in_route0(int, struct in_addr *, struct in_addr *, struct in_addr *, int, const char *, uint32_t);
#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

static const char *
skip_space(const char *s)
{
	const char *r;
	for (r = s; *r != '\0' && isspace((unsigned char)*r); r++)
		;; /* skip */

	return r;
}

/**
 * Read and store IPv4 address of name server from resolv.conf.
 * The path of resolv.conf is taken from _PATH_RESCONF in resolv.h.
 */
int
load_resolv_conf(struct in_addr *pri, struct in_addr *sec)
{
	FILE *filep;
	int i;
	struct in_addr *addr;
	char *ap, *line, buf[BUFSIZ];

	pri->s_addr = INADDR_NONE;
	sec->s_addr = INADDR_NONE;

	filep = NULL;
	if ((filep = priv_fopen(_PATH_RESCONF)) == NULL)
		return 1;

	i = 0;
	while (fgets(buf, sizeof(buf), filep) != NULL) {
		line = (char *)skip_space(buf);
		if (strncmp(line, "nameserver", 10) != 0)
			continue;
		line += 10;
		if (!isspace((unsigned char)*line))
			continue;
		while ((ap = strsep(&line, " \t\r\n")) != NULL) {
			if (*ap == '\0')
				continue;
			if (i == 0)
				addr = pri;
			else
				addr = sec;
			if (inet_aton(ap, addr) != 1) {
				/*
				 * FIXME: If configured IPv6, it may have IPv6
				 * FIXME: address.  For the present, continue.
				 */
				continue;
			}
			addr->s_addr = addr->s_addr;
			if (++i >= 2)
				goto end_loop;
		}
	}
end_loop:
	if (filep != NULL)
		fclose(filep);

	return 0;
}

/* Add and delete routing entry. */
static int
in_route0(int type, struct in_addr *dest, struct in_addr *mask,
    struct in_addr *gate, int mtu, const char *ifname, uint32_t rtm_flags)
{
	struct rt_msghdr *rtm;
	struct sockaddr_in sdest, smask, sgate;
	struct sockaddr_dl *sdl;
	char dl_buf[512];	/* enough size */
	char *cp, buf[sizeof(*rtm) + sizeof(struct sockaddr_in) * 3 +
	    sizeof(dl_buf) + 128];
	const char *strtype;
	int rval, flags, sock;

	sock = -1;

	ASSERT(type == RTM_ADD || type == RTM_DELETE);
	if(type == RTM_ADD)
		strtype = "RTM_ADD";
	else
		strtype = "RTM_DELETE";

	memset(buf, 0, sizeof(buf));
	memset(&sdest, 0, sizeof(sdest));
	memset(&smask, 0, sizeof(smask));
	memset(&sgate, 0, sizeof(sgate));
	memset(&dl_buf, 0, sizeof(dl_buf));

	sdl = (struct sockaddr_dl *)dl_buf;

	sdest.sin_addr = *dest;
	if (mask != NULL)
		smask.sin_addr = *mask;
	if (gate != NULL)
		sgate.sin_addr = *gate;

	sdest.sin_family = smask.sin_family = sgate.sin_family = AF_INET;
	sdest.sin_len = smask.sin_len = sgate.sin_len = sizeof(sgate);

	rtm = (struct rt_msghdr *)buf;

	rtm->rtm_version = RTM_VERSION;
	rtm->rtm_type = type;
	rtm->rtm_flags = rtm_flags;
	if (gate != NULL)
		rtm->rtm_flags |= RTF_GATEWAY;
	if (mask == NULL)
		rtm->rtm_flags |= RTF_HOST;

	if (type == RTM_ADD && mtu > 0) {
		rtm->rtm_inits = RTV_MTU;
		rtm->rtm_rmx.rmx_mtu = mtu;
	}

	if (type == RTM_ADD)
		rtm->rtm_flags |= RTF_UP;

	rtm->rtm_addrs = RTA_DST;
	if (gate != NULL)
		rtm->rtm_addrs |= RTA_GATEWAY;
	if (mask != NULL)
		rtm->rtm_addrs |= RTA_NETMASK;
#ifdef RTA_IFP
	if (ifname != NULL)
		rtm->rtm_addrs |= RTA_IFP;
#endif

	rtm->rtm_pid = getpid();
	route_seq = ((route_seq + 1)&0x0000ffff);
	rtm->rtm_seq = route_seq;

	cp = (char *)rtm;
	cp += ROUNDUP(sizeof(*rtm));

	memcpy(cp, &sdest, sdest.sin_len);
	cp += ROUNDUP(sdest.sin_len);
	if (gate != NULL) {
		memcpy(cp, &sgate, sgate.sin_len);
		cp += ROUNDUP(sgate.sin_len);
	}
	if (mask != NULL) {
		memcpy(cp, &smask, smask.sin_len);
		cp += ROUNDUP(smask.sin_len);
	}
#ifdef RTA_IFP
	if (ifname != NULL) {
		strlcpy(sdl->sdl_data, ifname, IFNAMSIZ);
		sdl->sdl_family = AF_LINK;
		sdl->sdl_len = offsetof(struct sockaddr_dl, sdl_data) +IFNAMSIZ;
		sdl->sdl_index = if_nametoindex(ifname);
		memcpy(cp, sdl, sdl->sdl_len);
		cp += ROUNDUP(sdl->sdl_len);
	}
#endif

	rtm->rtm_msglen = cp - buf;

	if ((sock = priv_socket(PF_ROUTE, SOCK_RAW, AF_UNSPEC)) < 0) {
		log_printf(LOG_ERR, "socket() failed in %s() on %s : %m",
		    __func__, strtype);
		goto fail;
	}

	if ((flags = fcntl(sock, F_GETFL)) < 0) {
		log_printf(LOG_ERR, "fcntl(,F_GETFL) failed on %s : %m",
		    __func__);
		goto fail;
	}

	if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
		log_printf(LOG_ERR, "fcntl(,F_SETFL) failed on %s : %m",
		    __func__);
		goto fail;
	}

	if ((rval = priv_send(sock, buf, rtm->rtm_msglen, 0)) <= 0) {
		if ((type == RTM_DELETE && errno == ESRCH) ||
		    (type == RTM_ADD    && errno == EEXIST)) {
			log_printf(LOG_DEBUG,
			    "write() failed in %s on %s : %m", __func__,
			    strtype);
		} else {
			log_printf(LOG_WARNING,
			    "write() failed in %s on %s : %m", __func__,
			    strtype);
		}
		goto fail;
	}

	close(sock);

	return 0;

fail:
	if (sock >= 0)
		close(sock);

	return 1;
}

/** Add host routing entry. */
int
in_host_route_add(struct in_addr *dest, struct in_addr *gate,
    const char *ifname, int mtu)
{
	return in_route0(RTM_ADD, dest, NULL, gate, mtu, ifname, 0);
}

/** Delete host routing entry. */
int
in_host_route_delete(struct in_addr *dest, struct in_addr *gate)
{
	return in_route0(RTM_DELETE, dest, NULL, gate, 0, NULL, 0);
}

/** Add network routing entry. */
int
in_route_add(struct in_addr *dest, struct in_addr *mask, struct in_addr *gate,
    const char *ifname, uint32_t rtm_flags, int mtu)
{
	return in_route0(RTM_ADD, dest, mask, gate, mtu, ifname, rtm_flags);
}

/** Delete network routing entry. */
int
in_route_delete(struct in_addr *dest, struct in_addr *mask,
    struct in_addr *gate, uint32_t rtm_flags)
{
	return in_route0(RTM_DELETE, dest, mask, gate, 0, NULL, rtm_flags);
}

/**
 *  Check whether a packet should reset idle timer
 *  Returns 1 to don't reset timer (i.e. the packet is "idle" packet)
 */
int
ip_is_idle_packet(const struct ip * pip, int len)
{
	u_int16_t ip_off;
	const struct udphdr *uh;

	/*
         * Fragmented packet is not idle packet.
         * (Long packet which needs to fragment is not idle packet.)
         */
	ip_off = ntohs(pip->ip_off);
	if ((ip_off & IP_MF) || ((ip_off & IP_OFFMASK) != 0))
		return 0;

	switch (pip->ip_p) {
	case IPPROTO_IGMP:
		return 1;
	case IPPROTO_ICMP:
		/* Is length enough? */
		if (pip->ip_hl * 4 + 8 > len)
			return 1;

		switch (((unsigned char *) pip)[pip->ip_hl * 4]) {
		case 0:	/* Echo Reply */
		case 8:	/* Echo Request */
			return 0;
		default:
			return 1;
		}
	case IPPROTO_UDP:
	case IPPROTO_TCP:
		/*
		 * The place of port number of UDP and TCP is the same,
		 * so can be shared.
		 */
		uh = (const struct udphdr *) (((const char *) pip) +
		    (pip->ip_hl * 4));

		/* Is length enough? */
		if (pip->ip_hl * 4 + sizeof(struct udphdr) > len)
			return 1;

		switch (ntohs(uh->uh_sport)) {
		case 53:	/* DOMAIN */
		case 67:	/* BOOTPS */
		case 68:	/* BOOTPC */
		case 123:	/* NTP */
		case 137:	/* NETBIOS-NS */
		case 520:	/* RIP */
			return 1;
		}
		switch (ntohs(uh->uh_dport)) {
		case 53:	/* DOMAIN */
		case 67:	/* BOOTPS */
		case 68:	/* BOOTPC */
		case 123:	/* NTP */
		case 137:	/* NETBIOS-NS */
		case 520:	/* RIP */
			return 1;
		}
		return 0;
	default:
		return 0;
	}
}

/***********************************************************************
 * Add and delete routing entry for the pool address.
 ***********************************************************************/
void
in_addr_range_add_route(struct in_addr_range *range)
{
	struct in_addr_range *range0;
	struct in_addr dest, mask, loop;

	for (range0 = range; range0 != NULL; range0 = range0->next){
		dest.s_addr = htonl(range0->addr);
		mask.s_addr = htonl(range0->mask);
		loop.s_addr = htonl(INADDR_LOOPBACK);
		in_route_add(&dest, &mask, &loop, LOOPBACK_IFNAME,
		    RTF_BLACKHOLE, 0);
	}
	log_printf(LOG_INFO, "Added routes for pooled addresses");
}

void
in_addr_range_delete_route(struct in_addr_range *range)
{
	struct in_addr_range *range0;
	struct in_addr dest, mask, loop;

	for (range0 = range; range0 != NULL; range0 = range0->next){
		dest.s_addr = htonl(range0->addr);
		mask.s_addr = htonl(range0->mask);
		loop.s_addr = htonl(INADDR_LOOPBACK);

		in_route_delete(&dest, &mask, &loop, RTF_BLACKHOLE);
	}
	log_printf(LOG_NOTICE, "Deleted routes for pooled addresses");
}


/* GETSHORT is also defined in #inlude <arpa/nameser_compat.h>. */
#undef	GETCHAR
#undef	GETSHORT
#undef	PUTSHORT

#define GETCHAR(c, cp) { (c) = *(cp)++; }
#define GETSHORT(s, cp) { \
	(s) = *(cp)++ << 8; \
	(s) |= *(cp)++; \
}
#define PUTSHORT(s, cp) { \
	*(cp)++ = (u_char) ((s) >> 8); \
	*(cp)++ = (u_char) (s); \
}
#define TCP_OPTLEN_IN_SEGMENT	12	/* timestamp option and padding */
#define MAXMSS(mtu) (mtu - sizeof(struct ip) - sizeof(struct tcphdr) - \
    TCP_OPTLEN_IN_SEGMENT)

/* adapted from FreeBSD:src/usr.sbin/ppp/tcpmss.c */
/*
 * Copyright (c) 2000 Ruslan Ermilov and Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/usr.sbin/ppp/tcpmss.c,v 1.1.4.3 2001/07/19 11:39:54 brian Exp $
 */

/*
 * The following macro is used to update an internet checksum.  "acc" is a
 * 32-bit accumulation of all the changes to the checksum (adding in old
 * 16-bit words and subtracting out new words), and "cksum" is the checksum
 * value to be updated.
 */
#define ADJUST_CHECKSUM(acc, cksum) {			\
	acc += cksum;					\
	if (acc < 0) {					\
		acc = -acc;				\
		acc = (acc >> 16) + (acc & 0xffff);	\
		acc += acc >> 16;			\
		cksum = (u_short) ~acc;			\
	} else {					\
		acc = (acc >> 16) + (acc & 0xffff);	\
		acc += acc >> 16;			\
		cksum = (u_short) acc;			\
	}						\
}

/**
 * Adjust mss to make IP packet be shorter than or equal MTU.
 *
 * @@param	pktp	pointer that indicates IP packet
 * @@param	lpktp	length
 * @@param	mtu	MTU
 */
int
adjust_tcp_mss(u_char *pktp, int lpktp, int mtu)
{
	int opt, optlen, acc, ip_off, mss, maxmss;
	struct ip *pip;
	struct tcphdr *th;

	if (lpktp < sizeof(struct ip) + sizeof(struct tcphdr))
		return 1;

	pip = (struct ip *)pktp;
	ip_off = ntohs(pip->ip_off);

	/* exclude non-TCP packet or fragmented packet. */
	if (pip->ip_p != IPPROTO_TCP || (ip_off & IP_MF) != 0 ||
	    (ip_off & IP_OFFMASK) != 0)
		return 0;

	pktp += pip->ip_hl << 2;
	lpktp -= pip->ip_hl << 2;

	/* broken packet */
	if (sizeof(struct tcphdr) > lpktp)
		return 1;

	th = (struct tcphdr *)pktp;
	/* MSS is selected only from SYN segment. (See RFC 793) */
	if ((th->th_flags & TH_SYN) == 0)
		return 0;

	lpktp = MINIMUM(th->th_off << 4, lpktp);

	pktp += sizeof(struct tcphdr);
	lpktp -= sizeof(struct tcphdr);

	while (lpktp >= TCPOLEN_MAXSEG) {
		GETCHAR(opt, pktp);
		switch (opt) {
		case TCPOPT_MAXSEG:
			GETCHAR(optlen, pktp);
			GETSHORT(mss, pktp);
			maxmss = MAXMSS(mtu);
			if (mss > maxmss) {
				pktp-=2;
				PUTSHORT(maxmss, pktp);
				acc = htons(mss);
				acc -= htons(maxmss);
				ADJUST_CHECKSUM(acc, th->th_sum);
			}
			return 0;
			/* NOTREACHED */
			break;
		case TCPOPT_EOL:
			return 0;
			/* NOTREACHED */
			break;
		case TCPOPT_NOP:
			lpktp--;
			break;
		default:
			GETCHAR(optlen, pktp);
			if (optlen < 2)	/* packet is broken */
				return 1;
			pktp += optlen - 2;
			lpktp -= optlen;
			break;
		}
	}
	return 0;
}
@


1.17
log
@Set the index of the interface in handroller link_addr(3) like code.

This is now necessary on OpenBSD because our routing interface no longer
use ifunit() to find the corresponding interface.

ok yasuoka@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.16 2015/01/19 01:48:59 deraadt Exp $ */
d143 1
a143 1
	int rval, dummy, flags, sock;
d234 1
a234 2
	dummy = 0;
	if ((flags = fcntl(sock, F_GETFL, dummy)) < 0) {
@


1.16
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.15 2014/11/13 04:18:27 yasuoka Exp $ */
d32 1
d220 1
@


1.15
log
@Fix a condition which selects log level for errors on routing socket,
since it was logically reverse.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.14 2014/10/25 03:23:49 lteo Exp $ */
a30 1
#include <sys/param.h>
d60 2
d511 1
a511 1
	lpktp = MIN(th->th_off << 4, lpktp);
@


1.14
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.13 2014/08/14 08:08:00 mpi Exp $ */
d245 2
a246 2
		if (!(type == RTM_DELETE && errno == ESRCH) &&
		    !(type == RTM_ADD    && errno == EEXIST)) {
@


1.13
log
@Do not set RTF_MASK, it is not used anymore.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.12 2014/06/13 06:35:58 yasuoka Exp $ */
a34 1
#include <netinet/in_systm.h>
@


1.12
log
@Fix tcp-mss-adjust of pipex and npppd to update the pointer of
tcp option and check the boundary correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.11 2014/04/18 10:05:22 claudio Exp $ */
a177 2
	else
		rtm->rtm_flags |= RTF_MASK;
@


1.11
log
@Do not set RTF_DONE flag on route message, only the kernel is allowed to
set that to indicate that it processed the message. Also de-#ifdef the
RTF_MASK part, OpenBSD is not that archaic.
OK yasuoka@@ long time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.10 2013/03/14 10:21:07 mpi Exp $ */
d31 2
a32 1
#include <sys/types.h>
d513 2
d544 3
a546 1
			pktp += 2 - optlen;
@


1.10
log
@Remove some faith-related #ifdef'd code that was only used for old IIJ
products and never enabled in our tree.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.9 2012/12/05 23:20:26 deraadt Exp $ */
d172 1
a172 1
	rtm->rtm_flags = RTF_DONE | rtm_flags;
a176 1
#ifdef	RTF_MASK
a178 1
#endif
@


1.9
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.8 2012/05/08 13:18:37 yasuoka Exp $ */
a548 15
}

void
set_faith(int sock, int onoff)
{
#ifdef IP_FAITH
	int ival;

	ival = onoff;
	if(setsockopt(sock, IPPROTO_IP, IP_FAITH, &ival, sizeof(ival))
	    < 0) {
		log_printf(LOG_DEBUG,
		"setsockopt(IP_FAITH) failed at %s(): %m", __func__);
	}
#endif
@


1.8
log
@Trivial changes from the upstream(IIJ).
 - fix styles, compile errors in some ifdef condition and compiler warnings.
 - delete rtev* that was to work around routing socket overflows.
 - delete is_ctrl argument from l2tp_ctrl_send_packet().  It's not used.
 - tweak returning the exit status.
 - use IPV6_IPSEC_POLICY for IPv6 socket.
   (though npppd cannot set up a ipsec policy to the socket yet.)

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.7 2012/05/08 13:15:12 yasuoka Exp $ */
a30 8
/* $Id: npppd_subr.c,v 1.7 2012/05/08 13:15:12 yasuoka Exp $ */
#include <sys/cdefs.h>
#ifndef LINT
__COPYRIGHT(
"@@(#) Copyright (c) 2000 Ruslan Ermilov and Brian Somers <brian@@Awfulhak.org>\n"
"@@(#) All rights reserved.\n"
);
#endif
@


1.7
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: npppd_subr.c,v 1.6 2010/09/23 01:45:10 jsg Exp $ */
d31 1
a31 1
/* $Id: npppd_subr.c,v 1.6 2010/09/23 01:45:10 jsg Exp $ */
a66 1
#include "rtev.h"
a148 1
#ifndef NPPPD_USE_RTEV_WRITE
a151 1
#endif
a236 5
#ifdef NPPPD_USE_RTEV_WRITE
	if (rtev_write(rtm) < 0)
		log_printf(LOG_ERR, "rtev_write failed in %s: %m", __func__);
#else

a270 1
#endif
a273 1
#ifndef NPPPD_USE_RTEV_WRITE
a276 1
#endif
@


1.6
log
@remove support for talking to the zebra routing socket which
was not enabled, we use a kernel routing socket for such things.

ok yasuoka@@ claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: npppd_subr.c,v 1.5 2010/07/02 21:20:57 yasuoka Exp $ */
d31 1
a31 1
/* $Id: npppd_subr.c,v 1.5 2010/07/02 21:20:57 yasuoka Exp $ */
@


1.5
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d31 1
a31 1
/* $Id: npppd_subr.c,v 1.4 2010/07/01 03:38:17 yasuoka Exp $ */
a67 5
#ifdef NPPPD_USE_RT_ZEBRA
#include "bytebuf.h"
#include <event.h>
#include "rt_zebra.h"
#endif
a156 13
#ifdef NPPPD_USE_RT_ZEBRA
	if ((rtm_flags & RTF_BLACKHOLE) != 0) {
		if (type == RTM_ADD)
			return rt_zebra_add_ipv4_blackhole_rt(
			    rt_zebra_get_instance(), dest->s_addr,
			    (mask == NULL)? 0xffffffffL : mask->s_addr);
		else
			return rt_zebra_delete_ipv4_blackhole_rt(
			    rt_zebra_get_instance(), dest->s_addr,
			    (mask == NULL)? 0xffffffffL : mask->s_addr);
		return -1;
	}
#endif
@


1.4
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
d31 1
a31 1
/* $Id: npppd_subr.c,v 1.3 2010/01/31 05:49:51 yasuoka Exp $ */
d306 1
a306 1
	
d516 1
a516 1
 * 
@


1.3
log
@privilege separation of npppd.

- Drop privilege after daemon initializing.
- Some system calls that requires root privileges were replaced to
  wrapper functions that communicate with a separated privileged
  process via IPC.  And the privileged process checks whether the
  operations are acceptable.
@
text
@d27 1
a27 1
 * npppd の補助的な関数を提供します。
d29 1
a29 1
/* $Id: npppd_subr.c,v 1.2 2010/01/13 07:49:44 yasuoka Exp $ */
d89 2
a90 2
 * resolv.conf からネームサーバの IPv4 のエントリを読み出します。
 * resolv.conf のパスは、resolv.h の _PATH_RESCONF を使います。
d124 2
a125 2
				 * FIXME IPv6 使ってるの場合 IPv6 アドレスが入
				 * っているかもしれない。とりあえず、continue。
a127 1
				//goto reigai;
d141 1
a141 1
// 経路追加削除
d149 1
a149 1
	char dl_buf[512];	// enough size
d264 1
a264 1
		goto reigai;
d271 1
a271 1
		goto reigai;
d277 1
a277 1
		goto reigai;
d291 1
a291 1
		goto reigai;
d300 1
a300 1
reigai:
d308 1
a308 1
/** ホスト経路を追加 */
d316 1
a316 1
/** ホスト経路を削除 */
d323 1
a323 1
/** ネット経路を追加 */
d331 1
a331 1
/** ネット経路を削除 */
a338 1
// 従来 ppp の ip.c より流用
d350 2
a351 2
         * フラグメントされたパケットはアイドルパケットではない
         * （フラグメントするほど長いパケットはアイドルパケットではない）
d361 1
a361 1
		/* 長さは足りている？ */
d375 2
a376 2
		 * UDP も TCP も、ポートの部分は同じなので、そこだけは共用で
		 * きる。
d381 1
a381 1
		/* 長さは足りている？ */
d410 1
a410 1
 * プールしているアドレスへの経路追加/削除
d445 1
a445 1
/* #inlude <arpa/nameser_compat.h>	も GETSHORT を定義している */
d513 4
a516 3
 * IPパケットが MTU 以下となるように mss を調整します。
 * @@param	pktp	IPパケットのポインタ
 * @@param	lpktp	長さ
d532 1
a532 1
	/* TCP じゃないパケットやフラグメントされたパケットは対象外 */
d540 1
a540 1
	/* 壊れてる */
d545 1
a545 1
	/* MSS は SYN がセットされたセグメントに限る。(See RFC 793) */
@


1.2
log
@cleanup npppd code.  delete IIJ local ifdef switches and fix warnings.
ok @@dlg
@
text
@d29 1
a29 1
/* $Id: npppd_subr.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $ */
d71 1
d104 1
a104 1
	if ((filep = fopen(_PATH_RESCONF, "r")) == NULL)
d262 1
a262 1
	if ((sock = socket(PF_ROUTE, SOCK_RAW, AF_UNSPEC)) < 0) {
d281 1
a281 1
	if ((rval = write(sock, buf, rtm->rtm_msglen)) <= 0) {
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d29 1
a29 1
/* $Id: npppd_subr.c 38793 2009-12-17 06:10:08Z yasuoka $ */
a207 14
#ifdef	_SEIL_EXT_
	/*
	 * phash で interface のアドレスを変更されると、route flush される。
	 * route flush コマンドに -xpppac (Except pppac) オプションを追加
	 * して、RTF_PROTO2 ならば flush しないような修正を行い、phash で
	 * 使用される の flush_route() では -xpppac 付きで route コマンド
	 * を実行する。
	 */
	rtm->rtm_flags |= RTF_PROTO2;
	/* 
	 * RTF_STATIC が立っていないと Zebra が消す場合がある。
	 */
	rtm->rtm_flags |= RTF_STATIC;
#endif	/* _SEIL_EXT_ */
@

