head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.8
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.10
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.03.22.04.11.27;	author yasuoka;	state Exp;
branches;
next	1.9;
commitid	E0uBzN9HedaLPg1K;

1.9
date	2015.07.23.09.04.06;	author yasuoka;	state Exp;
branches;
next	1.8;
commitid	UzaYgcNQWA1XOOah;

1.8
date	2015.01.19.01.48.59;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	a1BWBASyBgKKetQd;

1.7
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2012.05.08.13.23.53;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2012.05.08.13.15.12;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.06.20.52.28;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Log the reply message from RADIUS server when the authenticaion fails.
Diff from Yuuichi Someya
@
text
@/*	$OpenBSD: pap.c,v 1.9 2015/07/23 09:04:06 yasuoka Exp $ */

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/* $Id: pap.c,v 1.9 2015/07/23 09:04:06 yasuoka Exp $ */
/**@@file
 * This file provides Password Authentication Protocol (PAP) handlers.
 * @@author Yasuoka Masahiko
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <net/if_dl.h>
#include <netinet/in.h>

#include <event.h>
#include <md5.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <errno.h>
#include <vis.h>

#include "slist.h"
#include "npppd.h"
#include "ppp.h"

#ifdef USE_NPPPD_RADIUS
#include <radius.h>
#include "radius_chap_const.h"
#include "npppd_radius.h"
#endif

#include "debugutil.h"

#define	AUTHREQ				0x01
#define	AUTHACK				0x02
#define	AUTHNAK				0x03

#define	PAP_STATE_INITIAL		0
#define	PAP_STATE_STARTING		1
#define	PAP_STATE_AUTHENTICATING	2
#define	PAP_STATE_SENT_RESPONSE		3
#define	PAP_STATE_STOPPED		4
#define	PAP_STATE_PROXY_AUTHENTICATION	5

#define	DEFAULT_SUCCESS_MESSAGE		"OK"
#define	DEFAULT_FAILURE_MESSAGE		"Unknown username or password"
#define	DEFAULT_ERROR_MESSAGE		"Unknown failure"

#ifdef	PAP_DEBUG
#define	PAP_DBG(x)	pap_log x
#define	PAP_ASSERT(cond)					\
	if (!(cond)) {						\
	    fprintf(stderr,					\
		"\nASSERT(" #cond ") failed on %s() at %s:%d.\n"\
		, __func__, __FILE__, __LINE__);		\
	    abort(); 						\
	}
#else
#define	PAP_ASSERT(cond)
#define	PAP_DBG(x)
#endif

static void  pap_log (pap *, uint32_t, const char *, ...) __printflike(3,4);
static void  pap_response (pap *, int, const char *);
static void  pap_authenticate(pap *, const char *);
static void  pap_local_authenticate (pap *, const char *, const char *);
#ifdef USE_NPPPD_RADIUS
static void  pap_radius_authenticate (pap *, const char *, const char *);
static void  pap_radius_response (void *, RADIUS_PACKET *, int, RADIUS_REQUEST_CTX);
#endif

#ifdef __cplusplus
extern "C" {
#endif

void  pap_init (pap *, npppd_ppp *);
int   pap_start (pap *);
int   pap_stop (pap *);
int   pap_input (pap *, u_char *, int);

#ifdef __cplusplus
}
#endif

void
pap_init(pap *_this, npppd_ppp *ppp)
{
	_this->ppp = ppp;
	_this->state = PAP_STATE_INITIAL;
	_this->auth_id = -1;
}

int
pap_start(pap *_this)
{
	pap_log(_this, LOG_DEBUG, "%s", __func__);

	if (_this->state == PAP_STATE_PROXY_AUTHENTICATION) {
		_this->state = PAP_STATE_AUTHENTICATING;
		pap_authenticate(_this, _this->ppp->proxy_authen_resp);
		return 0;
	}

	_this->state = PAP_STATE_STARTING;
	return 0;
}

int
pap_stop(pap *_this)
{
	_this->state = PAP_STATE_STOPPED;
	_this->auth_id = -1;

#ifdef USE_NPPPD_RADIUS
	if (_this->radctx != NULL) {
		radius_cancel_request(_this->radctx);
		_this->radctx = NULL;
	}
#endif
	return 0;
}

/** Receiving PAP packet */
int
pap_input(pap *_this, u_char *pktp, int lpktp)
{
	int code, id, length, len;
	u_char *pktp1;
	char name[MAX_USERNAME_LENGTH], password[MAX_PASSWORD_LENGTH];

	if (_this->state == PAP_STATE_STOPPED ||
	    _this->state == PAP_STATE_INITIAL) {
		pap_log(_this, LOG_ERR, "Received pap packet.  But pap is "
		    "not started.");
		return -1;
	}
	pktp1 = pktp;

	GETCHAR(code, pktp1);
	GETCHAR(id, pktp1);
	GETSHORT(length, pktp1);

	if (code != AUTHREQ) {
		pap_log(_this, LOG_ERR, "%s: Received unknown code=%d",
		    __func__, code);
		return -1;
	}
	if (lpktp < length) {
		pap_log(_this, LOG_ERR, "%s: Received broken packet.",
		    __func__);
		return -1;
	}

	/* retribute the username */
#define	remlen		(lpktp - (pktp1 - pktp))
	if (remlen < 1)
		goto fail;
	GETCHAR(len, pktp1);
	if (len <= 0)
		goto fail;
	if (remlen < len)
		goto fail;
	if (len > 0)
		memcpy(name, pktp1, len);
	name[len] = '\0';
	pktp1 += len;

	if (_this->state != PAP_STATE_STARTING) {
		/*
		 * Receiving identical message again, it must be the message
		 * retransmit by the peer.  Continue if the username is same.
		 */
		if ((_this->state == PAP_STATE_AUTHENTICATING ||
		    _this->state == PAP_STATE_SENT_RESPONSE) &&
		    strcmp(_this->name, name) == 0) {
			/* continue */
		} else {
			pap_log(_this, LOG_ERR,
			    "Received AuthReq is not same as before.  "
			    "(%d,%s) != (%d,%s)", id, name, _this->auth_id,
			    _this->name);
			_this->auth_id = id;
			goto fail;
		}
	}
	if (_this->state == PAP_STATE_AUTHENTICATING)
		return 0;
	_this->auth_id = id;
	strlcpy(_this->name, name, sizeof(_this->name));

	_this->state = PAP_STATE_AUTHENTICATING;

	/* retribute the password */
	if (remlen < 1)
		goto fail;
	GETCHAR(len, pktp1);
	if (remlen < len)
		goto fail;
	if (len > 0)
		memcpy(password, pktp1, len);

	password[len] = '\0';
	pap_authenticate(_this, password);

	return 0;
fail:
	pap_response(_this, 0, DEFAULT_FAILURE_MESSAGE);
	return -1;
}

static void
pap_authenticate(pap *_this, const char *password)
{
	if (npppd_ppp_bind_realm(_this->ppp->pppd, _this->ppp, _this->name, 0)
	    == 0) {
		if (!npppd_ppp_is_realm_ready(_this->ppp->pppd, _this->ppp)) {
			pap_log(_this, LOG_INFO,
			    "username=\"%s\" realm is not ready.", _this->name);
			goto fail;
			/* NOTREACHED */
		}
#if USE_NPPPD_RADIUS
		if (npppd_ppp_is_realm_radius(_this->ppp->pppd, _this->ppp)) {
			pap_radius_authenticate(_this, _this->name, password);
			return;
			/* NOTREACHED */
		} else
#endif
		if (npppd_ppp_is_realm_local(_this->ppp->pppd, _this->ppp)) {
			pap_local_authenticate(_this, _this->name, password);
			return;
			/* NOTREACHED */
		}
	}
fail:
	pap_response(_this, 0, DEFAULT_FAILURE_MESSAGE);
}

static void
pap_log(pap *_this, uint32_t prio, const char *fmt, ...)
{
	char logbuf[BUFSIZ];
	va_list ap;

	va_start(ap, fmt);
	snprintf(logbuf, sizeof(logbuf), "ppp id=%u layer=pap %s",
	    _this->ppp->id, fmt);
	vlog_printf(prio, logbuf, ap);
	va_end(ap);
}

static void
pap_response(pap *_this, int authok, const char *mes)
{
	int lpktp, lmes;
	u_char *pktp, *pktp1;
	const char *realm;

	pktp = ppp_packetbuf(_this->ppp, PPP_PROTO_PAP) + HEADERLEN;
	lpktp = _this->ppp->mru - HEADERLEN;
	realm = npppd_ppp_get_realm_name(_this->ppp->pppd, _this->ppp);

	pktp1 = pktp;
	if (mes == NULL)
		lmes = 0;
	else
		lmes = strlen(mes);
	lmes = MINIMUM(lmes, lpktp - 1);

	PUTCHAR(lmes, pktp1);
	if (lmes > 0)
		memcpy(pktp1, mes, lmes);
	lpktp = lmes + 1;

	if (authok)
		ppp_output(_this->ppp, PPP_PROTO_PAP, AUTHACK, _this->auth_id,
		    pktp, lpktp);
	else
		ppp_output(_this->ppp, PPP_PROTO_PAP, AUTHNAK, _this->auth_id,
		    pktp, lpktp);

	if (!authok) {
		pap_log(_this, LOG_ALERT,
		    "logtype=Failure username=\"%s\" realm=%s", _this->name,
		    realm);
		pap_stop(_this);
		ppp_set_disconnect_cause(_this->ppp, 
		    PPP_DISCON_AUTH_FAILED, PPP_PROTO_PAP, 1 /* peer */, NULL);
		ppp_stop(_this->ppp, "Authentication Required");
	} else {
		strlcpy(_this->ppp->username, _this->name,
		    sizeof(_this->ppp->username));
		pap_log(_this, LOG_INFO,
		    "logtype=Success username=\"%s\" realm=%s", _this->name,
		    realm);
		pap_stop(_this);
		ppp_auth_ok(_this->ppp);
		/* reset the state to response request of retransmision. */
		_this->state = PAP_STATE_SENT_RESPONSE;
	}
}

static void
pap_local_authenticate(pap *_this, const char *username, const char *password)
{
	int lpassword0;
	char password0[MAX_PASSWORD_LENGTH];

	lpassword0 = sizeof(password0);

	if (npppd_get_user_password(_this->ppp->pppd, _this->ppp, username,
	    password0, &lpassword0) == 0) {
		if (!strcmp(password0, password)) {
			pap_response(_this, 1, DEFAULT_SUCCESS_MESSAGE);
			return;
		}
	}
	pap_response(_this, 0, DEFAULT_FAILURE_MESSAGE);
}

/***********************************************************************
 * Proxy Authentication
 ***********************************************************************/
int
pap_proxy_authen_prepare(pap *_this, dialin_proxy_info *dpi)
{

	PAP_ASSERT(dpi->auth_type == PPP_AUTH_PAP);
	PAP_ASSERT(_this->state == PAP_STATE_INITIAL);

	_this->auth_id = dpi->auth_id;
	if (strlen(dpi->username) >= sizeof(_this->name)) {
		pap_log(_this, LOG_NOTICE,
		    "\"Proxy Authen Name\" is too long.");
		return -1;
	}

	/* copy the authenticaiton properties */
	PAP_ASSERT(_this->ppp->proxy_authen_resp == NULL);
	if ((_this->ppp->proxy_authen_resp = malloc(dpi->lauth_resp + 1)) ==
	    NULL) {
		pap_log(_this, LOG_ERR, "malloc() failed in %s(): %m",
		    __func__);
		return -1;
	}
	memcpy(_this->ppp->proxy_authen_resp, dpi->auth_resp,
	    dpi->lauth_resp);
	_this->ppp->proxy_authen_resp[dpi->lauth_resp] = '\0';
	strlcpy(_this->name, dpi->username, sizeof(_this->name));

	_this->state = PAP_STATE_PROXY_AUTHENTICATION;

	return 0;
}

#ifdef USE_NPPPD_RADIUS
static void
pap_radius_authenticate(pap *_this, const char *username, const char *password)
{
	void *radctx;
	RADIUS_PACKET *radpkt;
	MD5_CTX md5ctx;
	int i, j, s_len, passlen;
	u_char ra[16], digest[16], pass[128];
	const char *s;
	radius_req_setting *rad_setting = NULL;
	char buf0[MAX_USERNAME_LENGTH];

	if ((rad_setting = npppd_get_radius_auth_setting(_this->ppp->pppd,
	    _this->ppp)) == NULL)
		goto fail;

	if ((radpkt = radius_new_request_packet(RADIUS_CODE_ACCESS_REQUEST))
	    == NULL)
		goto fail;

	if (radius_prepare(rad_setting, _this, &radctx, pap_radius_response)
	    != 0) {
		radius_delete_packet(radpkt);
		goto fail;
	}

	if (ppp_set_radius_attrs_for_authreq(_this->ppp, rad_setting, radpkt)
	    != 0)
		goto fail;

	if (radius_put_string_attr(radpkt, RADIUS_TYPE_USER_NAME,
	    npppd_ppp_get_username_for_auth(_this->ppp->pppd, _this->ppp,
	    username, buf0)) != 0)
		goto fail;

	if (_this->radctx != NULL)
		radius_cancel_request(_this->radctx);

	_this->radctx = radctx;

	/* Create RADIUS User-Password Attribute (RFC 2865, 5.2.) */
	s = radius_get_server_secret(_this->radctx);
	s_len = strlen(s);

	memset(pass, 0, sizeof(pass)); /* null padding */
	passlen = MINIMUM(strlen(password), sizeof(pass));
	memcpy(pass, password, passlen);
	if ((passlen % 16) != 0)
		passlen += 16 - (passlen % 16);

	radius_get_authenticator(radpkt, ra);

	MD5Init(&md5ctx);
	MD5Update(&md5ctx, s, s_len);
	MD5Update(&md5ctx, ra, 16);
	MD5Final(digest, &md5ctx);

	for (i = 0; i < 16; i++)
		pass[i] ^= digest[i];

	while (i < passlen) {
		MD5Init(&md5ctx);
		MD5Update(&md5ctx, s, s_len);
		MD5Update(&md5ctx, &pass[i - 16], 16);
		MD5Final(digest, &md5ctx);

		for (j = 0; j < 16; j++, i++)
			pass[i] ^= digest[j];
	}

	if (radius_put_raw_attr(radpkt, RADIUS_TYPE_USER_PASSWORD, pass,
	    passlen) != 0)
		goto fail;

	radius_request(_this->radctx, radpkt);

	return;
fail:
	if (_this->radctx != NULL)
		radius_cancel_request(_this->radctx);
	pap_log(_this, LOG_ERR, "%s() failed: %m", __func__);
	pap_response(_this, 0, DEFAULT_ERROR_MESSAGE);

	return;
}

static void
pap_radius_response(void *context, RADIUS_PACKET *pkt, int flags,
    RADIUS_REQUEST_CTX reqctx)
{
	int code = -1;
	const char *reason = NULL;
	RADIUS_REQUEST_CTX radctx;
	pap *_this;

	_this = context;
	radctx = _this->radctx;
	_this->radctx = NULL;	/* important */

	if (pkt == NULL) {
		if (flags & RADIUS_REQUEST_TIMEOUT)
			reason = "timeout";
		else if (flags & RADIUS_REQUEST_ERROR)
			reason = strerror(errno);
		else
			reason = "error";
		goto auth_failed;
	}
	code = radius_get_code(pkt);
	if (code == RADIUS_CODE_ACCESS_REJECT) {
		reason="reject";
		goto auth_failed;
	} else if (code != RADIUS_CODE_ACCESS_ACCEPT) {
		reason="error";
		goto auth_failed;
	}
	if ((flags & RADIUS_REQUEST_CHECK_AUTHENTICATOR_OK) == 0 &&
	    (flags & RADIUS_REQUEST_CHECK_AUTHENTICATOR_NO_CHECK) == 0) {
		reason="bad_authenticator";
		goto auth_failed;
	}
	/* Autentication succeeded */
	pap_response(_this, 1, DEFAULT_SUCCESS_MESSAGE);
	ppp_process_radius_framed_ip(_this->ppp, pkt);

	return;
auth_failed:
	/* Autentication failure */
	pap_log(_this, LOG_WARNING, "Radius authentication request failed: %s",
	    reason);
	/* log reply messages from radius server */
	if (pkt != NULL) {
		char radmsg[255], vissed[1024];
		size_t rmlen = 0;
		if ((radius_get_raw_attr(pkt, RADIUS_TYPE_REPLY_MESSAGE,
		    radmsg, &rmlen)) == 0) {
			if (rmlen != 0) {
				strvisx(vissed, radmsg, rmlen, VIS_WHITE);
				pap_log(_this, LOG_WARNING,
				    "Radius reply message: %s", vissed);
			}
		}
	}

	pap_response(_this, 0, DEFAULT_FAILURE_MESSAGE);
}
#endif
@


1.9
log
@Make npppd use libradius(3).  Remove radius+ files.
@
text
@d1 1
a1 1
/*	$OpenBSD: pap.c,v 1.8 2015/01/19 01:48:59 deraadt Exp $ */
d28 1
a28 1
/* $Id: pap.c,v 1.8 2015/01/19 01:48:59 deraadt Exp $ */
d47 1
d514 14
@


1.8
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: pap.c,v 1.7 2012/09/18 13:14:08 yasuoka Exp $ */
d28 1
a28 1
/* $Id: pap.c,v 1.7 2012/09/18 13:14:08 yasuoka Exp $ */
d53 1
a53 1
#include <radius+.h>
@


1.7
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: pap.c,v 1.6 2012/05/08 13:23:53 yasuoka Exp $ */
d28 1
a28 1
/* $Id: pap.c,v 1.6 2012/05/08 13:23:53 yasuoka Exp $ */
a33 1
#include <sys/param.h>
d294 1
a294 1
	lmes = MIN(lmes, lpktp - 1);
d428 1
a428 1
	passlen = MIN(strlen(password), sizeof(pass));
@


1.6
log
@Fix double free bug in PAP with radius authentication.
(found by yus at iij)

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pap.c,v 1.5 2012/05/08 13:15:12 yasuoka Exp $ */
d28 1
a28 1
/* $Id: pap.c,v 1.5 2012/05/08 13:15:12 yasuoka Exp $ */
d404 2
a405 2
	if (radius_prepare(rad_setting, _this, &radctx,
	    pap_radius_response, _this->ppp->auth_timeout) != 0) {
@


1.5
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pap.c,v 1.4 2011/07/06 20:52:28 yasuoka Exp $ */
d28 1
a28 1
/* $Id: pap.c,v 1.4 2011/07/06 20:52:28 yasuoka Exp $ */
a507 1
	radius_delete_packet(pkt);
a513 3
	if (pkt != NULL)
		radius_delete_packet(pkt);

@


1.4
log
@Add RADIUS accounting support and some authentication related changes:

- Add functions to radius+.c that are required to implement RADIUS
  accounting.
- Send RADIUS Account-Start and Account-Stop messages with attributes that
  are defined by RFC 2866, 2868, 2869.
- If any authentication realm is deleted from the configuration, npppd may
  exit by segmentation fault.
- Delete radius_common.c, radius_common.h and eap.c because they are not
  used.
- Retransmission and failover are reimplemented.
- Cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: pap.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $ */
d28 1
a28 1
/* $Id: pap.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $ */
@


1.3
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d28 1
a28 1
/* $Id: pap.c,v 1.2 2010/07/01 03:38:17 yasuoka Exp $ */
d47 1
d54 1
d56 1
d58 1
d96 1
a96 1
static void  pap_radius_response (void *, RADIUS_PACKET *, int);
d314 1
a314 1
		ppp_stop_ex(_this->ppp, "Authentication Required",
d316 1
d396 1
a396 1
	if ((rad_setting = npppd_get_radius_req_setting(_this->ppp->pppd,
d471 2
a472 1
pap_radius_response(void *context, RADIUS_PACKET *pkt, int flags)
d484 1
a484 1
		if (flags & RADIUS_REQUST_TIMEOUT) {
d486 3
a488 3
			npppd_radius_server_failure_notify(_this->ppp->pppd,
			    _this->ppp, radctx, "request timeout");
		} else {
a489 3
			npppd_radius_server_failure_notify(_this->ppp->pppd,
			    _this->ppp, radctx, "unknown error");
		}
d500 2
a501 2
	if ((flags & RADIUS_REQUST_CHECK_AUTHENTICTOR_OK) == 0 &&
	    (flags & RADIUS_REQUST_CHECK_AUTHENTICTOR_NO_CHECK) == 0) {
a502 2
		npppd_radius_server_failure_notify(_this->ppp->pppd, _this->ppp,
		    radctx, "bad authenticator");
@


1.2
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
d28 1
a28 1
/* $Id: pap.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $ */
d82 2
a83 2
#define	PAP_ASSERT(cond)			
#define	PAP_DBG(x)	
d399 1
a399 1
	if (radius_prepare(rad_setting, _this, &radctx, 
d410 1
a410 1
	    npppd_ppp_get_username_for_auth(_this->ppp->pppd, _this->ppp, 
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d26 1
a26 1
/* $Id: pap.c 35695 2009-04-13 14:52:44Z yasuoka $ */
d28 1
a28 1
 * Password Authentication Protocol (PAP) の実装
a30 5
/*
 *   Windows 2000 で PAP を行うと、8秒間に10個の AuthReq が届きタイムアウト
 *   この値は CHAP の場合の半分以下なので、Radius 要求のタイムアウトの値は、
 *   CHAP と PAP で別々に設定できたほうが良いかもしれない。
 */
d144 1
a144 1
/** PAP のパケット受信 */
d175 1
a175 1
	/* ユーザ名を取り出し */
d178 1
a178 1
		goto reigai;
d181 1
a181 1
		goto reigai;
d183 1
a183 1
		goto reigai;
d191 2
a192 2
		 * まったく同じ要求を２度受け取った場合は、先方の再送による
		 * もの。UserName が同じならば続行する。
d197 1
a197 1
			/* 続行 */
d204 1
a204 1
			goto reigai;
d214 1
a214 1
	/* パスワードを取り出し */
d216 1
a216 1
		goto reigai;
d219 1
a219 1
		goto reigai;
d227 1
a227 1
reigai:
d240 1
a240 1
			goto reigai;
d256 1
a256 1
reigai:
a307 1
		/* 失敗したら ppp 終了 */
d318 1
a318 1
		// 再送要求に答えるために pap_stop でのセットを上書きします。
a322 1
/** PAP認証 */
d391 1
a391 1
		goto reigai;
d395 1
a395 1
		goto reigai;
d400 1
a400 1
		goto reigai;
d405 1
a405 1
		goto reigai;
d410 1
a410 1
		goto reigai;
d417 1
a417 4
	/*
	 * RADIUS User-Password アートリビュートの作成
	 * (RFC 2865, "5.2.  User-Password")
	 */
d421 1
a421 1
	memset(pass, 0, sizeof(pass));			// null-padding
d449 1
a449 1
		goto reigai;
d454 1
a454 1
reigai:
d473 1
a473 1
	_this->radctx = NULL;	/* 大事 */
d502 1
a502 1
	// 認証 OK
d504 1
a504 1
	ppp_proccess_radius_framed_ip(_this->ppp, pkt);
d509 1
a509 1
	// 認証 NG
@

