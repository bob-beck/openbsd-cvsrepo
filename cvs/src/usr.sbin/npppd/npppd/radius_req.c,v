head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.10
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.8
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.05.18.43.36;	author mmcc;	state Exp;
branches;
next	1.10;
commitid	z4uV9iYMuGOvIKaj;

1.10
date	2015.07.23.09.04.06;	author yasuoka;	state Exp;
branches;
next	1.9;
commitid	UzaYgcNQWA1XOOah;

1.9
date	2015.01.19.01.48.59;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	a1BWBASyBgKKetQd;

1.8
date	2014.05.30.05.06.00;	author yasuoka;	state Exp;
branches;
next	1.7;

1.7
date	2014.03.22.04.25.00;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2012.05.08.13.15.12;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.06.20.52.28;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.11
log
@strings.h -> string.h to prevent an implicit declaration. Also remove a
bunch of NULL-checks before free().
@
text
@/*	$OpenBSD: radius_req.c,v 1.10 2015/07/23 09:04:06 yasuoka Exp $ */

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/**@@file
 * This file provides functions for RADIUS request using radius(3) and event(3).
 * @@author	Yasuoka Masahiko
 * $Id: radius_req.c,v 1.10 2015/07/23 09:04:06 yasuoka Exp $
 */
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <stdio.h>
#include <syslog.h>
#include <stdlib.h>
#include <debugutil.h>
#include <time.h>
#include <event.h>
#include <string.h>
#include <errno.h>

#include "radius_req.h"
#include <radius.h>

#ifndef nitems
#define	nitems(_a)	(sizeof((_a)) / sizeof((_a)[0]))
#endif

struct overlapped {
	struct event		 ev_sock;
	int			 socket;
	int			 ntry;
	int			 max_tries;
	int			 failovers;
	int			 acct_delay_time;
	int			 response_fn_calling;
	struct sockaddr_storage	 ss;
	struct timespec		 req_time;
	void			*context;
	radius_response		*response_fn;
	char			 secret[MAX_RADIUS_SECRET];
	RADIUS_PACKET		*pkt;
	radius_req_setting	*setting;
};

static int   radius_request0 (struct overlapped *, int);
static int   radius_prepare_socket(struct overlapped *);
static void  radius_request_io_event (int, short, void *);
static void  radius_on_response(RADIUS_REQUEST_CTX, RADIUS_PACKET *, int, int);
static int   select_srcaddr(struct sockaddr const *, struct sockaddr *, socklen_t *);
static void  radius_req_setting_ref(radius_req_setting *);
static void  radius_req_setting_unref(radius_req_setting *);

#ifdef	RADIUS_REQ_DEBUG
#define RADIUS_REQ_DBG(x)	log_printf x
#define	RADIUS_REQ_ASSERT(cond)					\
	if (!(cond)) {						\
	    fprintf(stderr,					\
		"\nASSERT(" #cond ") failed on %s() at %s:%d.\n"\
		, __func__, __FILE__, __LINE__);		\
	    abort(); 						\
	}
#else
#define	RADIUS_REQ_ASSERT(cond)
#define RADIUS_REQ_DBG(x)
#endif

/**
 * Send RADIUS request message.  The pkt(RADIUS packet) will be released
 * by this implementation.
 */
void
radius_request(RADIUS_REQUEST_CTX ctx, RADIUS_PACKET *pkt)
{
	uint32_t ival;
	struct overlapped *lap;

	RADIUS_REQ_ASSERT(pkt != NULL);
	RADIUS_REQ_ASSERT(ctx != NULL);
	lap = ctx;
	lap->pkt = pkt;
	if (radius_get_uint32_attr(pkt, RADIUS_TYPE_ACCT_DELAY_TIME, &ival)
	    == 0)
		lap->acct_delay_time = 1;
	radius_request0(lap, 0);
}

/**
 * Prepare NAS-IP-Address or NAS-IPv6-Address.  If
 * setting->server[setting->curr_server].sock is not initialized, address
 * will be selected automatically.
 */
int
radius_prepare_nas_address(radius_req_setting *setting,
    RADIUS_PACKET *pkt)
{
	int af;
	struct sockaddr_in *sin4;
	struct sockaddr_in6 *sin6;
	socklen_t socklen;

	/* See RFC 2765, 3162 */
	RADIUS_REQ_ASSERT(setting != NULL);

	af = setting->server[setting->curr_server].peer.sin6.sin6_family;
	RADIUS_REQ_ASSERT(af == AF_INET6 || af == AF_INET);

	sin4 = &setting->server[setting->curr_server].sock.sin4;
	sin6 = &setting->server[setting->curr_server].sock.sin6;

	switch (af) {
	case AF_INET:
		socklen = sizeof(*sin4);
		if (sin4->sin_addr.s_addr == INADDR_ANY) {
			if (select_srcaddr((struct sockaddr const *)
			    &setting->server[setting->curr_server].peer,
			    (struct sockaddr *)sin4, &socklen) != 0) {
				RADIUS_REQ_ASSERT("NOTREACHED" == NULL);
				goto fail;
			}
		}
		if (radius_put_ipv4_attr(pkt, RADIUS_TYPE_NAS_IP_ADDRESS,
		    sin4->sin_addr) != 0)
			goto fail;
		break;
	case AF_INET6:
		socklen = sizeof(*sin6);
		if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
			if (select_srcaddr((struct sockaddr const *)
			    &setting->server[setting->curr_server].peer,
			    (struct sockaddr *)sin4, &socklen) != 0) {
				RADIUS_REQ_ASSERT("NOTREACHED" == NULL);
				goto fail;
			}
		}
		if (radius_put_raw_attr(pkt, RADIUS_TYPE_NAS_IPV6_ADDRESS,
		    sin6->sin6_addr.s6_addr, sizeof(sin6->sin6_addr.s6_addr))
		    != 0)
			goto fail;
		break;
	}

	return 0;
fail:
	return 1;
}


/** Checks whether the request can fail over to another server */
int
radius_request_can_failover(RADIUS_REQUEST_CTX ctx)
{
	struct overlapped *lap;
	radius_req_setting *setting;

	lap = ctx;
	setting = lap->setting;

	if (lap->failovers >= setting->max_failovers)
		return 0;
	if (memcmp(&lap->ss, &setting->server[setting->curr_server].peer,
	    setting->server[setting->curr_server].peer.sin6.sin6_len) == 0)
		/* flagged server doesn't differ from the last server. */
		return 0;

	return 1;
}

/** Send RADIUS request failing over to another server. */
int
radius_request_failover(RADIUS_REQUEST_CTX ctx)
{
	struct overlapped *lap;

	lap = ctx;
	RADIUS_REQ_ASSERT(lap != NULL);
	RADIUS_REQ_ASSERT(lap->socket >= 0)

	if (!radius_request_can_failover(lap))
		return -1;

	if (radius_prepare_socket(lap) != 0)
		return -1;

	if (radius_request0(lap, 1) != 0)
		return -1;

	lap->failovers++;

	return 0;
}

static int
radius_prepare_socket(struct overlapped *lap)
{
	int sock;
	radius_req_setting *setting;
	struct sockaddr *sa;

	setting = lap->setting;
	if (lap->socket >= 0)
		close(lap->socket);
	lap->socket = -1;

	sa = (struct sockaddr *)&setting->server[setting->curr_server].peer;

	if ((sock = socket(sa->sa_family, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
		log_printf(LOG_ERR, "socket() failed in %s: %m", __func__);
		return -1;
	}
	if (connect(sock, sa, sa->sa_len) != 0) {
		log_printf(LOG_ERR, "connect() failed in %s: %m", __func__);
		close(sock);
		return -1;
	}
	memcpy(&lap->ss, sa, sa->sa_len);
	lap->socket = sock;
	memcpy(lap->secret, setting->server[setting->curr_server].secret,
	    sizeof(lap->secret));
	lap->ntry = lap->max_tries;

	return 0;
}

/**
 * Prepare sending RADIUS request.  This implementation will call back to
 * notice that it receives the response or it fails for timeouts to the
 * The context that is set as 'pctx' and response packet that is given
 * by the callback function will be released by this implementation internally.
 * @@param setting	Setting for RADIUS server or request.
 * @@param context	Context for the caller.
 * @@param pctx		Pointer to the space for context of RADIUS request
 *			(RADIUS_REQUEST_CTX).  This will be used for canceling.
 *			NULL can be specified when you don't need.
 * @@param response_fn	Specify callback function as a pointer. The function
 *			will be called when it receives a response or when
 *			request fails for timeouts.
 * @@param timeout	response timeout in second.
 */
int
radius_prepare(radius_req_setting *setting, void *context,
    RADIUS_REQUEST_CTX *pctx, radius_response response_fn)
{
	struct overlapped *lap;

	RADIUS_REQ_ASSERT(setting != NULL);
	lap = NULL;

	if (setting->server[setting->curr_server].enabled == 0)
		return 1;
	if ((lap = calloc(1, sizeof(struct overlapped))) == NULL) {
		log_printf(LOG_ERR, "calloc() failed in %s: %m", __func__);
		goto fail;
	}
	lap->context = context;
	lap->response_fn = response_fn;
	lap->socket = -1;
	lap->setting = setting;

	lap->max_tries = setting->max_tries;
	if (lap->max_tries <= 0)
		lap->max_tries = 3;	/* default max tries */

	if (radius_prepare_socket(lap) != 0)
		goto fail;

	if (pctx != NULL)
		*pctx = lap;

	radius_req_setting_ref(setting);	

	return 0;
fail:
	free(lap);

	return 1;
}

/**
 * Cancel the RADIUS request.
 * @@param	The context received by {@@link radius_request()}
 */
void
radius_cancel_request(RADIUS_REQUEST_CTX ctx)
{
	struct overlapped	*lap = ctx;

	/*
	 * Don't call this function from the callback function.
	 * The context will be freed after the callback function is called.
	 */
	RADIUS_REQ_ASSERT(lap->response_fn_calling == 0);
	if (lap->response_fn_calling != 0)
		return;

	if (lap->socket >= 0) {
		event_del(&lap->ev_sock);
		close(lap->socket);
		lap->socket = -1;
	}
	if (lap->pkt != NULL) {
		radius_delete_packet(lap->pkt);
		lap->pkt = NULL;
	}
	radius_req_setting_unref(lap->setting);

	memset(lap->secret, 0x41, sizeof(lap->secret));

	free(lap);
}

/** Return the shared secret for RADIUS server that is used by this context.  */
const char *
radius_get_server_secret(RADIUS_REQUEST_CTX ctx)
{
	struct overlapped *lap;

	lap = ctx;
	RADIUS_REQ_ASSERT(lap != NULL);

	return lap->secret;
}

/** Return the address of RADIUS server that is used by this context.  */
struct sockaddr *
radius_get_server_address(RADIUS_REQUEST_CTX ctx)
{
	struct overlapped *lap;

	lap = ctx;
	RADIUS_REQ_ASSERT(lap != NULL);

	return (struct sockaddr *)&lap->ss;
}

static int
radius_request0(struct overlapped *lap, int new_message)
{
	struct timeval tv0;

	RADIUS_REQ_ASSERT(lap->ntry > 0);

	if (lap->acct_delay_time != 0) {
		struct timespec curr, delta;

		if (clock_gettime(CLOCK_MONOTONIC, &curr) != 0) {
			log_printf(LOG_CRIT,
			    "clock_gettime(CLOCK_MONOTONIC,) failed: %m");
			RADIUS_REQ_ASSERT(0);
		}
		if (!timespecisset(&lap->req_time))
			lap->req_time = curr;
		else {
			timespecsub(&curr, &lap->req_time, &delta);
			if (radius_set_uint32_attr(lap->pkt,
			    RADIUS_TYPE_ACCT_DELAY_TIME, delta.tv_sec) == 0) {
				radius_update_id(lap->pkt);
				new_message = 1;
			}
		}
	}
	if (new_message) {
		radius_set_accounting_request_authenticator(lap->pkt,
		    radius_get_server_secret(lap));
	}

	lap->ntry--;
	if (radius_send(lap->socket, lap->pkt, 0) != 0) {
		log_printf(LOG_ERR, "sendto() failed in %s: %m",
		    __func__);
		radius_on_response(lap, NULL, RADIUS_REQUEST_ERROR, 1);
		return 1;
	}
	tv0.tv_usec = 0;
	tv0.tv_sec = lap->setting->timeout;

	event_set(&lap->ev_sock, lap->socket, EV_READ | EV_PERSIST,
	    radius_request_io_event, lap);
	event_add(&lap->ev_sock, &tv0);

	return 0;
}

static void
radius_request_io_event(int fd, short evmask, void *context)
{
	struct overlapped *lap;
	struct sockaddr_storage ss;
	int flags;
	socklen_t len;
	RADIUS_PACKET *respkt;

	RADIUS_REQ_ASSERT(context != NULL);

	lap = context;
	respkt = NULL;
	flags = 0;
	if ((evmask & EV_READ) != 0) {
		RADIUS_REQ_ASSERT(lap->socket >= 0);
		if (lap->socket < 0)
			return;
		RADIUS_REQ_ASSERT(lap->pkt != NULL);
		memset(&ss, 0, sizeof(ss));
		len = sizeof(ss);
		if ((respkt = radius_recv(lap->socket, 0)) == NULL) {
			RADIUS_REQ_DBG((LOG_DEBUG,
			    "radius_recv() on %s(): %m", __func__));
			/*
			 * Ignore error by icmp.  Wait a response from the
			 * server anyway, it may eventually become ready.
			 */
			switch (errno) {
			case EHOSTDOWN: case EHOSTUNREACH: case ECONNREFUSED:
				return;	/* sleep the rest of timeout time */
			}
			flags |= RADIUS_REQUEST_ERROR;
		} else if (lap->secret[0] == '\0') {
			flags |= RADIUS_REQUEST_CHECK_AUTHENTICATOR_NO_CHECK;
		} else {
			radius_set_request_packet(respkt, lap->pkt);
			if (!radius_check_response_authenticator(respkt,
			    lap->secret))
				flags |= RADIUS_REQUEST_CHECK_AUTHENTICATOR_OK;
		}
		radius_on_response(lap, respkt, flags, 0);
		radius_delete_packet(respkt);
	} else if ((evmask & EV_TIMEOUT) != 0) {
		if (lap->ntry > 0) {
			RADIUS_REQ_DBG((LOG_DEBUG,
			    "%s() timed out retry", __func__));
			radius_request0(lap, 0);
			return;
		}
		RADIUS_REQ_DBG((LOG_DEBUG, "%s() timed out", __func__));
		flags |= RADIUS_REQUEST_TIMEOUT;
		radius_on_response(lap, NULL, flags, 1);
	}
}

static void
radius_on_response(RADIUS_REQUEST_CTX ctx, RADIUS_PACKET *pkt, int flags,
    int server_failure)
{
	struct overlapped *lap;
	int failovers;

	lap = ctx;
	if (server_failure) {
		int i, n;
		struct sockaddr *sa_curr;

		sa_curr = (struct sockaddr *)&lap->setting->server[
		    lap->setting->curr_server].peer;
		if (sa_curr->sa_len == lap->ss.ss_len &&
		    memcmp(sa_curr, &lap->ss, sa_curr->sa_len) == 0) {
			/*
			 * The server on failure is flagged as the current.
			 * change the current
			 */
			for (i = 1; i < nitems(lap->setting->server); i++) {
				n = (lap->setting->curr_server + i) %
				    nitems(lap->setting->server);
				if (lap->setting->server[n].enabled) {
					lap->setting->curr_server = n;
					break;
				}
			}
		}
	}

	failovers = lap->failovers;
	if (lap->response_fn != NULL) {
		lap->response_fn_calling++;
		lap->response_fn(lap->context, pkt, flags, ctx);
		lap->response_fn_calling--;
	}
	if (failovers == lap->failovers)
		radius_cancel_request(lap);
}

static int
select_srcaddr(struct sockaddr const *dst, struct sockaddr *src,
    socklen_t *srclen)
{
	int sock;

	sock = -1;
	if ((sock = socket(dst->sa_family, SOCK_DGRAM, IPPROTO_UDP)) < 0)
		goto fail;
	if (connect(sock, dst, dst->sa_len) != 0)
		goto fail;
	if (getsockname(sock, src, srclen) != 0)
		goto fail;

	close(sock);

	return 0;
fail:
	if (sock >= 0)
		close(sock);

	return 1;
}

radius_req_setting *
radius_req_setting_create(void)
{
	return calloc(1, sizeof(radius_req_setting));
}

int
radius_req_setting_has_server(radius_req_setting *setting)
{
	return setting->server[setting->curr_server].enabled;
}

void
radius_req_setting_destroy(radius_req_setting *setting)
{
	setting->destroyed = 1;

	if (setting->refcnt == 0)
		free(setting);
}

static void
radius_req_setting_ref(radius_req_setting *setting)
{
	setting->refcnt++;
}

static void
radius_req_setting_unref(radius_req_setting *setting)
{
	setting->refcnt--;
	if (setting->destroyed)
		radius_req_setting_destroy(setting);
}
@


1.10
log
@Make npppd use libradius(3).  Remove radius+ files.
@
text
@d1 1
a1 1
/*	$OpenBSD: radius_req.c,v 1.9 2015/01/19 01:48:59 deraadt Exp $ */
d31 1
a31 1
 * $Id: radius_req.c,v 1.9 2015/01/19 01:48:59 deraadt Exp $
d299 1
a299 2
	if (lap != NULL)
		free(lap);
@


1.9
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: radius_req.c,v 1.8 2014/05/30 05:06:00 yasuoka Exp $ */
d29 1
a29 1
 * This file provides functions for RADIUS request using radius+.c and event(3).
d31 1
a31 1
 * $Id: radius_req.c,v 1.8 2014/05/30 05:06:00 yasuoka Exp $
a40 2
#include <radius+.h>
#include <radiusconst.h>
d48 1
d389 1
a389 1
		radius_set_request_authenticator(lap->pkt,
@


1.8
log
@Use calloc instead of malloc and memset.

from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: radius_req.c,v 1.7 2014/03/22 04:25:00 yasuoka Exp $ */
d31 1
a31 1
 * $Id: radius_req.c,v 1.7 2014/03/22 04:25:00 yasuoka Exp $
a33 1
#include <sys/param.h>
@


1.7
log
@Add an assert not to call radius_cancel_request() on callback. If the
assert is disabled by compile time, the function returns immediatly on that
condition.
@
text
@d1 1
a1 1
/*	$OpenBSD: radius_req.c,v 1.6 2012/09/18 13:14:08 yasuoka Exp $ */
d31 1
a31 1
 * $Id: radius_req.c,v 1.6 2012/09/18 13:14:08 yasuoka Exp $
d278 2
a279 2
	if ((lap = malloc(sizeof(struct overlapped))) == NULL) {
		log_printf(LOG_ERR, "malloc() failed in %s: %m", __func__);
a281 1
	memset(lap, 0, sizeof(struct overlapped));
d536 1
a536 7
	radius_req_setting *setting;

	if ((setting = malloc(sizeof(radius_req_setting))) == NULL)
		return NULL;
	memset(setting, 0, sizeof(radius_req_setting));

	return setting;
@


1.6
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: radius_req.c,v 1.5 2012/05/08 13:15:12 yasuoka Exp $ */
d31 1
a31 1
 * $Id: radius_req.c,v 1.5 2012/05/08 13:15:12 yasuoka Exp $
d57 14
a70 13
	struct event ev_sock;
	int socket;
	int ntry;
	int max_tries;
	int failovers;
	struct sockaddr_storage ss;
	struct timespec req_time;
	void *context;
	radius_response *response_fn;
	char secret[MAX_RADIUS_SECRET];
	RADIUS_PACKET *pkt;
	radius_req_setting *setting;
	int acct_delay_time;
d315 9
a323 1
	struct overlapped *lap;
a324 1
	lap = ctx;
d501 2
a502 1
	if (lap->response_fn != NULL)
d504 2
@


1.5
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: radius_req.c,v 1.4 2011/07/06 20:52:28 yasuoka Exp $ */
d31 1
a31 1
 * $Id: radius_req.c,v 1.4 2011/07/06 20:52:28 yasuoka Exp $
d268 1
a268 1
    RADIUS_REQUEST_CTX *pctx, radius_response response_fn, int timeout)
d287 1
a287 7
	if (timeout != 0 &&
	    (setting->max_tries == 0 ||
		    timeout < setting->max_tries * setting->timeout))
		lap->max_tries = timeout / setting->timeout;
	else
		lap->max_tries = setting->max_tries;

@


1.4
log
@Add RADIUS accounting support and some authentication related changes:

- Add functions to radius+.c that are required to implement RADIUS
  accounting.
- Send RADIUS Account-Start and Account-Stop messages with attributes that
  are defined by RFC 2866, 2868, 2869.
- If any authentication realm is deleted from the configuration, npppd may
  exit by segmentation fault.
- Delete radius_common.c, radius_common.h and eap.c because they are not
  used.
- Retransmission and failover are reimplemented.
- Cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: radius_req.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $ */
d31 1
a31 1
 * $Id: radius_req.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $
@


1.3
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d31 1
a31 1
 * $Id: radius_req.c,v 1.2 2010/07/01 03:38:17 yasuoka Exp $
d48 1
d52 4
d60 2
a61 1
	int timeout;
d63 1
d68 2
d72 2
a73 1
static int   radius_request0 (struct overlapped *);
d75 4
a78 1
static int select_srcaddr(struct sockaddr const *, struct sockaddr *, socklen_t *);
d81 1
d91 1
d101 1
d108 4
a111 5
	if (radius_request0(lap) != 0) {
		if (lap->response_fn != NULL)
			lap->response_fn(lap->context, NULL,
			    RADIUS_REQUST_ERROR);
	}
d174 77
a269 1
	int sock;
a270 1
	struct sockaddr_in6 *sin6;
a280 5
	sin6 = &setting->server[setting->curr_server].peer.sin6;
	if ((sock = socket(sin6->sin6_family, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
		log_printf(LOG_ERR, "socket() failed in %s: %m", __func__);
		goto fail;
	}
a281 6
	memcpy(&lap->ss, &setting->server[setting->curr_server].peer,
	    setting->server[setting->curr_server].peer.sin6.sin6_len);

	lap->socket = sock;
	lap->timeout = MIN(setting->timeout, timeout);
	lap->ntry = timeout / lap->timeout;
d284 16
a299 2
	memcpy(lap->secret, setting->server[setting->curr_server].secret,
	    sizeof(lap->secret));
d303 2
d332 2
d364 1
a364 1
radius_request0(struct overlapped *lap)
d370 24
d395 4
a398 2
	if (radius_sendto(lap->socket, lap->pkt, 0, (struct sockaddr *)
	    &lap->ss, lap->ss.ss_len) != 0)
d400 1
d402 1
a402 1
	tv0.tv_sec = lap->timeout;
d404 1
a404 1
	event_set(&lap->ev_sock, lap->socket, EV_READ,
d422 3
a425 3
		lap = context;
		flags = 0;

a429 1

d432 12
a443 5
		if ((respkt = radius_recvfrom(lap->socket, 0,
		    (struct sockaddr *)&ss, &len)) == NULL) {
			log_printf(LOG_ERR, "recvfrom() failed in %s: %m",
			    __func__);
			flags |= RADIUS_REQUST_ERROR;
d445 1
a445 1
			flags |= RADIUS_REQUST_CHECK_AUTHENTICTOR_NO_CHECK;
d450 10
a459 1
				flags |= RADIUS_REQUST_CHECK_AUTHENTICTOR_OK;
d461 5
d467 6
a472 2
		if (lap->response_fn != NULL)
			lap->response_fn(lap->context, respkt, flags);
d474 20
a493 11
		if (respkt != NULL)
			radius_delete_packet(respkt);
		radius_cancel_request(lap);
	} else if ((evmask & EV_TIMEOUT) != 0) {
		lap = context;
		if (lap->ntry > 0) {
			if (radius_request0(lap) != 0) {
				if (lap->response_fn != NULL)
					lap->response_fn(lap->context, NULL,
					    RADIUS_REQUST_ERROR);
				radius_cancel_request(lap);
a494 1
			return;
d496 6
a501 3
		if (lap->response_fn != NULL)
			lap->response_fn(lap->context, NULL,
			    RADIUS_REQUST_TIMEOUT);
a502 1
	}
d527 41
@


1.2
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
d31 1
a31 1
 * $Id: radius_req.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $ 
d76 1
a76 1
#define	RADIUS_REQ_ASSERT(cond)			
d163 1
a163 1
 * by the callback function will be released by this implementation internally. 
d169 1
a169 1
 * @@param response_fn	Specify callback function as a pointer. The function 
d332 2
a333 2
			if (radius_request0(lap) != 0) { 
				if (lap->response_fn != NULL) 
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@a25 1
/* $Id: radius_req.c 36323 2009-09-24 13:38:13Z ymatsui $ */
d27 1
a27 2
 * radius+ ライブラリと event(3) を組み合わせた、RADIUS 要求のためのユーティ
 * リティ。
d29 1
d78 2
a79 3
 * RADIUS リクエストを送信します。指定した pkt(RADIUS パケット) は、この実装
 * 内部で解放されます。
 * @@param pkt		要求する RADIUS パケット。
d98 3
a100 4
 * NAS-IP-Address または NAS-IPv6-Address を準備します。
 * setting->server[setting->curr_server].sock にローカルアドレスがセッ
 * トされていない場合には、サーバのアドレスから自動でローカルアドレスを
 * セットします。
d128 1
a128 1
				goto reigai;
d133 1
a133 1
			goto reigai;
d142 1
a142 1
				goto reigai;
d148 1
a148 1
			goto reigai;
d153 1
a153 1
reigai:
d158 13
a170 15
 * RADIUS リクエストを送信する準備を行います。
 * <p>
 * 応答があった場合やタイムアウトなどのエラーは、指定した関数を呼び出(コール
 * バック)して通知します。</p>
 * <p>
 * pctx に書き出されるコンテキストと応答コールバック関数で指定される
 * 応答パケットは、この実装内部で解放されます。</p>
 * @@param setting	RADIUS サーバや問い合わせの設定
 * @@param context	呼び出し側コンテキスト
 * @@param pctx		RADIUS リクエストコンテキスト(RADIUS_REQUEST_CTX)
 *			を書き出す領域を指定します。キャンセルする場合などに、
 *			使用します。NULL を指定しても構いません。
 * @@param response_fn	応答を受信あるいはタイムアウトした時に呼び出す関数を
 *			関数ポインタで指定します。
 * @@param timeout	応答タイムアウトまでの秒数
d187 1
a187 1
		goto reigai;
d192 1
a192 1
		goto reigai;
d209 1
a209 1
reigai:
d217 2
a218 2
 * RADIUS 要求をキャンセルします。
 * @@param	{@@link radius_request()} で受け取ったコンテキスト
a234 1
	/* あえて no comment。*/
d240 1
a240 1
/** このコンテキストで利用している RADIUS サーバの共有秘密鍵を返します。*/
d252 1
a252 1
/** このコンテキストで利用している RADIUS サーバのアドレスを返します。*/
d353 1
a353 1
		goto reigai;
d355 1
a355 1
		goto reigai;
d357 1
a357 1
		goto reigai;
d362 1
a362 1
reigai:
@

