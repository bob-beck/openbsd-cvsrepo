head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.20
date	2016.05.28.07.00.18;	author natano;	state Exp;
branches;
next	1.19;
commitid	V3qpA476A18HvhDy;

1.19
date	2015.12.17.08.09.20;	author tb;	state Exp;
branches;
next	1.18;
commitid	MrOakYvPdtmxCs1T;

1.18
date	2015.10.11.07.32.06;	author guenther;	state Exp;
branches;
next	1.17;
commitid	l7h58s8VRh2mApBT;

1.17
date	2015.01.19.01.48.59;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	a1BWBASyBgKKetQd;

1.16
date	2014.11.27.10.22.38;	author tobias;	state Exp;
branches;
next	1.15;
commitid	NsUDdo6dm1jQhtMA;

1.15
date	2014.07.21.01.51.11;	author guenther;	state Exp;
branches;
next	1.14;
commitid	ro8JUTvBpvQMiFY9;

1.14
date	2014.03.22.04.18.18;	author yasuoka;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.20.23.32.32;	author yasuoka;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.16.07.27.36;	author yasuoka;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches;
next	1.10;

1.10
date	2012.05.08.13.18.37;	author yasuoka;	state Exp;
branches;
next	1.9;

1.9
date	2012.05.08.13.15.12;	author yasuoka;	state Exp;
branches;
next	1.8;

1.8
date	2012.01.18.02.53.56;	author yasuoka;	state Exp;
branches;
next	1.7;

1.7
date	2011.02.28.02.31.55;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.31.05.49.51;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.27.07.27.02;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.07.49.44;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Replace the /dev/bpf* open loop with a plain open("/dev/bpf0", ...).
ok deraadt jca
@
text
@/*	$OpenBSD: pppoed.c,v 1.19 2015/12/17 08:09:20 tb Exp $	*/

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/**@@file
 * This file provides the PPPoE(RFC2516) server(access concentrator)
 * implementaion.
 * $Id: pppoed.c,v 1.19 2015/12/17 08:09:20 tb Exp $
 */
#include <sys/param.h>	/* ALIGN */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <net/if.h>
#include <net/if_types.h>
#if defined(__NetBSD__)
#include <net/if_ether.h>
#else
#include <netinet/if_ether.h>
#endif
#include <net/if_dl.h>
#include <net/ethertypes.h>
#include <net/bpf.h>
#include <endian.h>
#include <string.h>
#include <syslog.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>
#include <event.h>
#include <signal.h>
#include <stdlib.h>
#include <ifaddrs.h>
#include <stdarg.h>
#include <errno.h>

#include "debugutil.h"
#include "slist.h"
#include "bytebuf.h"
#include "hash.h"
#include "privsep.h"

#include "pppoe.h"
#include "pppoe_local.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

static int pppoed_seqno = 0;

#ifdef	PPPOED_DEBUG
#define	PPPOED_ASSERT(x)	ASSERT(x)
#define	PPPOED_DBG(x)	pppoed_log x
#else
#define	PPPOED_ASSERT(x)
#define	PPPOED_DBG(x)
#endif

static void      pppoed_log (pppoed *, int, const char *, ...) __printflike(3,4);
static void      pppoed_listener_init(pppoed *, pppoed_listener *);
static int       pppoed_output (pppoed_listener *, u_char *, u_char *, int);
static int       pppoed_listener_start (pppoed_listener *, int);
static void      pppoed_io_event (int, short, void *);
static void      pppoed_input (pppoed_listener *, uint8_t [ETHER_ADDR_LEN], int, u_char *, int);
static void      pppoed_recv_PADR (pppoed_listener *, uint8_t [ETHER_ADDR_LEN], slist *);
static void      pppoed_recv_PADI (pppoed_listener *, uint8_t [ETHER_ADDR_LEN], slist *);
static int       session_id_cmp (void *, void *);
static uint32_t  session_id_hash (void *, size_t);

#ifdef PPPOE_TEST
static void      pppoed_on_sigterm (int, short, void *);
static void      usage (void);
#endif
static const char *pppoe_code_string(int);
#ifdef	PPPOED_DEBUG
static const char *pppoe_tag_string(int);
#endif

/*
 * daemon
 */

/* initialize PPPoE daemon */
int
pppoed_init(pppoed *_this)
{
	int i, off, id;

	memset(_this, 0, sizeof(pppoed));
	_this->id = pppoed_seqno++;

	if ((_this->session_hash = hash_create(
	    (int (*) (const void *, const void *))session_id_cmp,
	    (uint32_t (*) (const void *, int))session_id_hash,
	    PPPOE_SESSION_HASH_SIZ)) == NULL) {
		pppoed_log(_this, LOG_ERR, "hash_create() failed on %s(): %m",
		    __func__);
		goto fail;
	}

	slist_init(&_this->session_free_list);
	if (slist_add(&_this->session_free_list,
	    (void *)PPPOED_SESSION_SHUFFLE_MARK) == NULL) {
		pppoed_log(_this, LOG_ERR, "slist_add() failed on %s(): %m",
		    __func__);
		goto fail;
	}

	/* XXX initialize hash of cookies */
	if ((_this->acookie_hash = hash_create(
	    (int (*) (const void *, const void *))session_id_cmp,
	    (uint32_t (*) (const void *, int))session_id_hash,
	    PPPOE_SESSION_HASH_SIZ)) == NULL) {
		pppoed_log(_this, LOG_WARNING,
		    "hash_create() failed on %s(): %m", __func__);
		pppoed_log(_this, LOG_WARNING, "hash_create() failed on %s(): "
		    "ac-cookie hash create failed.", __func__);
		_this->acookie_hash = NULL;
	}
	_this->acookie_next = arc4random();

#if PPPOE_NSESSION > 0xffff
#error PPPOE_NSESSION must be less than 65536
#endif
	off = arc4random() & 0xffff;
	for (i = 0; i < PPPOE_NSESSION; i++) {
		id = (i + off) & 0xffff;
		if (id == 0)
			id = (off - 1) & 0xffff;
		if (slist_add(&_this->session_free_list, (void *)(intptr_t)id)
		    == NULL) {
			pppoed_log(_this, LOG_ERR,
			    "slist_add() failed on %s(): %m", __func__);
			goto fail;
		}
	}

	_this->state = PPPOED_STATE_INIT;

	return 0;
fail:
	pppoed_uninit(_this);
	return 1;
}

static void
pppoed_listener_init(pppoed *_this, pppoed_listener *listener)
{
	memset(listener, 0, sizeof(pppoed_listener));
	listener->bpf = -1;
	listener->self = _this;
	listener->index = PPPOED_LISTENER_INVALID_INDEX;
}

/* reload listner */
int
pppoed_reload_listeners(pppoed *_this)
{
	int rval = 0;

	if (_this->state == PPPOED_STATE_RUNNING &&
	    _this->listen_incomplete != 0)
		rval = pppoed_start(_this);

	return rval;
}

/*
 * Reject any packet except the packet to self and broadcasts,
 * as bpf(4) potentially receive packets for others.
 */
#define	REJECT_FOREIGN_ADDRESS 1

#define ETHER_FIRST_INT(e)	((e)[0]<<24|(e)[1]<<16|(e)[2]<<8|(e)[3])
#define ETHER_LAST_SHORT(e)	((e)[4]<<8|(e)[5])

static int
pppoed_listener_start(pppoed_listener *_this, int restart)
{
	int log_level;
	struct ifreq ifreq;
	int ival;
	int found;
	struct ifaddrs *ifa0, *ifa;
	struct sockaddr_dl *sdl;
	struct bpf_insn insns[] = {
	    /* check etyer type = PPPOEDESC or PPPOE */
		BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_PPPOEDISC, 2, 0),
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_PPPOE, 1, 0),
		BPF_STMT(BPF_RET+BPF_K, (u_int)0),
#ifndef	REJECT_FOREIGN_ADDRESS
		BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
#else
	/* to ff:ff:ff:ff:ff:ff */
		BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 0),
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0xffffffff, 0, 3),
		BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 4),
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0xffff, 0, 1),
		BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
	/* to self */
		BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 0),
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K,
		    ETHER_FIRST_INT(_this->ether_addr), 0, 3),
		BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 4),
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K,
		    ETHER_LAST_SHORT(_this->ether_addr), 0, 1),
		BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
		BPF_STMT(BPF_RET+BPF_K, (u_int)0),
#endif
	};
	struct bpf_program bf_filter = {
		.bf_len = countof(insns),
		.bf_insns = insns
	};
	pppoed *_pppoed;

	if (restart == 0)
		log_level = LOG_ERR;
	else
		log_level = LOG_INFO;

	_pppoed = _this->self;

	ifa0 = NULL;
	if (getifaddrs(&ifa0) != 0) {
		pppoed_log(_pppoed, log_level,
		    "getifaddrs() failed on %s(): %m", __func__);
		return -1;
	}
	found = 0;
	for (ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next) {
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		if (sdl->sdl_family != AF_LINK || sdl->sdl_type != IFT_ETHER ||
		    sdl->sdl_alen != ETHER_ADDR_LEN)
			continue;
		if (strcmp(ifa->ifa_name, _this->listen_ifname) == 0) {
			memcpy(_this->ether_addr,
			    (caddr_t)LLADDR(sdl), ETHER_ADDR_LEN);
			found = 1;
			break;
		}
	}
	freeifaddrs(ifa0);
	if (!found) {
		pppoed_log(_pppoed, log_level, "%s is not available.",
		    _this->listen_ifname);
		goto fail;
	}

	if ((_this->bpf = priv_open("/dev/bpf0", O_RDWR)) == -1) {
		pppoed_log(_pppoed, log_level, "Cannot open bpf: %m");
		goto fail;
	}

	ival = BPF_CAPTURE_SIZ;
	if (ioctl(_this->bpf, BIOCSBLEN, &ival) != 0) {
		pppoed_log(_pppoed, log_level, "ioctl(bpf, BIOCSBLEN(%d)): %m",
		    ival);
		goto fail;
	}
	ival = 1;
	if (ioctl(_this->bpf, BIOCIMMEDIATE, &ival) != 0) {
		pppoed_log(_pppoed, log_level, "Cannot start bpf on %s: %m",
		    _this->listen_ifname);
		goto fail;
	}

	/* bind interface */
	memset(&ifreq, 0, sizeof(ifreq));
	strlcpy(ifreq.ifr_name, _this->listen_ifname, sizeof(ifreq.ifr_name));
	if (ioctl(_this->bpf, BIOCSETIF, &ifreq) != 0) {
		pppoed_log(_pppoed, log_level, "Cannot start bpf on %s: %m",
		    _this->listen_ifname);
		goto fail;
	}

	/* set linklocal address */
#ifdef	REJECT_FOREIGN_ADDRESS
	insns[10].k = ETHER_FIRST_INT(_this->ether_addr);
	insns[12].k = ETHER_LAST_SHORT(_this->ether_addr);
#endif

	/* set filter */
	if (ioctl(_this->bpf, BIOCSETF, &bf_filter) != 0) {
		pppoed_log(_pppoed, log_level, "ioctl(bpf, BIOCSETF()): %m");
		goto fail;
	}

	event_set(&_this->ev_bpf, _this->bpf, EV_READ | EV_PERSIST,
	    pppoed_io_event, _this);
	event_add(&_this->ev_bpf, NULL);

	pppoed_log(_pppoed, LOG_INFO, "Listening on %s (PPPoE) [%s] "
	    "address=%02x:%02x:%02x:%02x:%02x:%02x", _this->listen_ifname,
	    _this->tun_name, _this->ether_addr[0], _this->ether_addr[1],
	    _this->ether_addr[2], _this->ether_addr[3], _this->ether_addr[4],
	    _this->ether_addr[5]);

	return 0;
fail:
	if (_this->bpf >= 0) {
		close(_this->bpf);
		_this->bpf = -1;
	}

	return 1;
}

/* start PPPoE daemon */
int
pppoed_start(pppoed *_this)
{
	int rval = 0;
	int nlistener_fail = 0;
	pppoed_listener *plistener;

	slist_itr_first(&_this->listener);
	while (slist_itr_has_next(&_this->listener)) {
		plistener = slist_itr_next(&_this->listener);
		PPPOED_ASSERT(plistener != NULL);
		if (plistener->bpf < 0) {
			if (pppoed_listener_start(plistener,
			    _this->listen_incomplete) != 0)
				nlistener_fail++;
		}
	}
	if (nlistener_fail > 0)
		_this->listen_incomplete = 1;
	else
		_this->listen_incomplete = 0;

	_this->state = PPPOED_STATE_RUNNING;

	return rval;
}

/* stop listener */
static void
pppoed_listener_stop(pppoed_listener *_this)
{
	pppoed *_pppoed;

	PPPOED_ASSERT(_this != NULL);
	_pppoed = _this->self;
	PPPOED_ASSERT(_pppoed != NULL);

	if (_this->bpf >= 0) {
		event_del(&_this->ev_bpf);
		close(_this->bpf);
		pppoed_log(_pppoed, LOG_INFO, "Shutdown %s (PPPoE) [%s] "
		    "address=%02x:%02x:%02x:%02x:%02x:%02x",
		    _this->listen_ifname, _this->tun_name,
		    _this->ether_addr[0], _this->ether_addr[1],
		    _this->ether_addr[2], _this->ether_addr[3],
		    _this->ether_addr[4], _this->ether_addr[5]);
		_this->bpf = -1;
	}
}

/* stop PPPoE daemon */
void
pppoed_stop(pppoed *_this)
{
	pppoed_listener *plistener;
	hash_link *hl;
	pppoe_session *session;

	if (!pppoed_is_running(_this))
		return;

	_this->state = PPPOED_STATE_STOPPED;
	if (_this->session_hash != NULL) {
		for (hl = hash_first(_this->session_hash);
		    hl != NULL;
		    hl = hash_next(_this->session_hash)) {
			session = (pppoe_session *)hl->item;
			pppoe_session_disconnect(session);
			pppoe_session_stop(session);
		}
	}
	for (slist_itr_first(&_this->listener);
	    slist_itr_has_next(&_this->listener);) {
		plistener = slist_itr_next(&_this->listener);
		pppoed_listener_stop(plistener);
		free(plistener);
		slist_itr_remove(&_this->listener);
	}
	PPPOED_DBG((_this, LOG_DEBUG, "Stopped"));
}

/* uninitialize (free) PPPoE daemon */
void
pppoed_uninit(pppoed *_this)
{
	if (_this->session_hash != NULL) {
		hash_free(_this->session_hash);
		_this->session_hash = NULL;
	}
	if (_this->acookie_hash != NULL) {
		hash_free(_this->acookie_hash);
		_this->acookie_hash = NULL;
	}
	slist_fini(&_this->session_free_list);
	/* listener themself has been released already */
	slist_fini(&_this->listener);
}

/* it is called when the PPPoE session was closed */
void
pppoed_pppoe_session_close_notify(pppoed *_this, pppoe_session *session)
{
	slist_add(&_this->session_free_list,
	    (void *)(intptr_t)session->session_id);

	if (_this->acookie_hash != NULL)
		hash_delete(_this->acookie_hash,
		    (void *)(intptr_t)session->acookie, 0);
	if (_this->session_hash != NULL)
		hash_delete(_this->session_hash,
		    (void *)(intptr_t)session->session_id, 0);

	pppoe_session_fini(session);
	free(session);
}

/*
 * PPPoE Configuration
 */
/* reload configurations for the PPPoE daemon */
int
pppoed_reload(pppoed *_this, struct pppoe_confs *pppoe_conf)
{
	int                i, count, do_start, found;
	struct pppoe_conf *conf;
	struct ifaddrs    *ifa0;
	slist              rmlist, newlist;
	struct {
		char			 ifname[IF_NAMESIZE];
		char			 name[PPPOED_PHY_LABEL_SIZE];
		struct pppoe_conf	*conf;
	} listeners[PPPOE_NLISTENER];
	pppoed_listener   *l;
	pppoe_session     *session;
	hash_link         *hl;

	do_start = 0;
	ifa0 = NULL;
	slist_init(&rmlist);
	slist_init(&newlist);

	if (getifaddrs(&ifa0) != 0) {
		pppoed_log(_this, LOG_ERR,
		    "getifaddrs() failed on %s(): %m", __func__);
		goto fail;
	}
	count = 0;
	TAILQ_FOREACH(conf, pppoe_conf, entry) {
		strlcpy(listeners[count].ifname, conf->if_name,
		    sizeof(listeners[count].ifname));
		strlcpy(listeners[count].name, conf->name,
		    sizeof(listeners[count].name));
		listeners[count].conf = conf;
		count++;
	}

	if (slist_add_all(&rmlist, &_this->listener) != 0)
		goto fail;

	for (i = 0; i < count; i++) {
		found = 0;
		l = NULL;
		slist_itr_first(&rmlist);
		while (slist_itr_has_next(&rmlist)) {
			l = slist_itr_next(&rmlist);
			if (strcmp(l->listen_ifname, listeners[i].ifname) == 0){
				slist_itr_remove(&rmlist);
				found = 1;
				break;
			}
		}
		if (!found) {
			if ((l = malloc(sizeof(pppoed_listener))) == NULL)
				goto fail;
			pppoed_listener_init(_this, l);
		}
		l->self = _this;
		strlcpy(l->tun_name, listeners[i].name, sizeof(l->tun_name));
		strlcpy(l->listen_ifname, listeners[i].ifname,
		    sizeof(l->listen_ifname));
		l->conf = listeners[i].conf;
		if (slist_add(&newlist, l) == NULL) {
			pppoed_log(_this, LOG_ERR,
			    "slist_add() failed in %s(): %m", __func__);
			goto fail;
		}
	}

	if (slist_set_size(&_this->listener, count) != 0)
		goto fail;

	/* garbage collection of listener context */
	slist_itr_first(&rmlist);
	while (slist_itr_has_next(&rmlist)) {
		l = slist_itr_next(&rmlist);
		/* handle child PPPoE session */
		if (_this->session_hash != NULL) {
			for (hl = hash_first(_this->session_hash); hl != NULL;
			    hl = hash_next(_this->session_hash)) {
				session = (pppoe_session *)hl->item;
				if (session->listener_index == l->index)
					pppoe_session_stop(session);
			}
		}
		pppoed_listener_stop(l);
		free(l);
	}
	slist_remove_all(&_this->listener);
	/* as slist_set_size-ed, it must not fail */
	(void)slist_add_all(&_this->listener, &newlist);

	/* reset indexes */
	slist_itr_first(&newlist);
	for (i = 0; slist_itr_has_next(&newlist); i++) {
		l = slist_itr_next(&newlist);
		if (l->index != i && l->index != PPPOED_LISTENER_INVALID_INDEX){
			PPPOED_DBG((_this, LOG_DEBUG, "listener %d => %d",
			    l->index, i));
			for (hl = hash_first(_this->session_hash); hl != NULL;
			    hl = hash_next(_this->session_hash)) {
				session = (pppoe_session *)hl->item;
				if (session->listener_index == l->index)
					session->listener_index = i;
			}
		}
		l->index = i;
	}

	slist_fini(&rmlist);
	slist_fini(&newlist);
	if (ifa0 != NULL)
		freeifaddrs(ifa0);

	if (pppoed_start(_this) != 0)
		return 1;

	return 0;
fail:
	slist_fini(&rmlist);
	slist_fini(&newlist);
	if (ifa0 != NULL)
		freeifaddrs(ifa0);

	return 1;
}

/*
 * I/O
 */

static void
pppoed_io_event(int fd, short evmask, void *ctx)
{
	u_char buf[BPF_CAPTURE_SIZ], *pkt;
	int lpkt, off;
	pppoed_listener *_this;
	struct ether_header *ether;
	struct bpf_hdr *bpf;

	_this = ctx;

	PPPOED_ASSERT(_this != NULL);

	lpkt = read(_this->bpf, buf, sizeof(buf));
	pkt = buf;
	while (lpkt > 0) {
		if (lpkt < sizeof(struct bpf_hdr)) {
			pppoed_log(_this->self, LOG_WARNING,
			    "Received bad PPPoE packet: packet too short(%d)",
			    lpkt);
			break;
		}
		bpf = (struct bpf_hdr *)pkt;
		ether = (struct ether_header *)(pkt + bpf->bh_hdrlen);
		ether->ether_type = ntohs(ether->ether_type);
		if (memcmp(ether->ether_shost, _this->ether_addr,
		    ETHER_ADDR_LEN) == 0)
			/* the packet is from myself */
			goto next_pkt;
		off = bpf->bh_hdrlen + sizeof(struct ether_header);
		if (lpkt < off + sizeof(struct pppoe_header)) {
			pppoed_log(_this->self, LOG_WARNING,
			    "Received bad PPPoE packet: packet too short(%d)",
			    lpkt);
			break;
		}
		pppoed_input(_this, ether->ether_shost,
		    (ether->ether_type == ETHERTYPE_PPPOEDISC)? 1 : 0,
		    pkt + off, lpkt - off);
next_pkt:
		pkt = pkt + BPF_WORDALIGN(bpf->bh_hdrlen +
		    bpf->bh_caplen);
		lpkt -= BPF_WORDALIGN(bpf->bh_hdrlen + bpf->bh_caplen);
	}
	return;
}

static void
pppoed_input(pppoed_listener *_this, uint8_t shost[ETHER_ADDR_LEN], int is_disc,
    u_char *pkt, int lpkt)
{
	hash_link *hl;
	pppoe_session *session;
	struct pppoe_header *pppoe;
	struct pppoe_tlv *tlv;
	u_char tlvspace[2048], *p_tlvspace;
	int session_id;
	slist tag_list;
	const char *reason;
#define tlvspace_remaining() (sizeof(tlvspace) - (p_tlvspace - tlvspace))

	reason = "";
	p_tlvspace = tlvspace;
	session = NULL;

	pppoe = (struct pppoe_header *)pkt;
	session_id = pppoe->session_id = ntohs(pppoe->session_id);
	pppoe->length = ntohs(pppoe->length);

#ifdef PPPOED_DEBUG
	if (is_disc) {
		PPPOED_DBG((_this->self, DEBUG_LEVEL_1,
		    "Recv%s(%02x) ver=%d type=%d session-id=%d if=%s",
		    pppoe_code_string(pppoe->code), pppoe->code,
		    pppoe->ver, pppoe->type, pppoe->session_id,
		    _this->listen_ifname));
	}
#endif
	pkt += sizeof(struct pppoe_header);
	lpkt -= sizeof(struct pppoe_header);

	if (lpkt < pppoe->length) {
		reason = "received packet is shorter than "
		    "pppoe length field.";
		goto bad_packet;
	}
	/* use PPPoE header value as lpkt */
	lpkt = pppoe->length;

	if (pppoe->type != PPPOE_RFC2516_TYPE ||
	    pppoe->ver != PPPOE_RFC2516_VER) {
		reason = "received packet has wrong version or type.";
		goto bad_packet;
	}

	if (session_id != 0) {
		hl = hash_lookup(_this->self->session_hash,
		    (void *)(intptr_t)session_id);
		if (hl != NULL)
			session = (pppoe_session *)hl->item;
	}
	if (!is_disc) {
		if (session != NULL)
			pppoe_session_input(session, pkt, pppoe->length);
		return;
	}

	/*
	 * PPPoE-Discovery Packet processing.
	 */
	slist_init(&tag_list);
	while (lpkt > 0) {
		if (lpkt < 4) {
			reason = "tlv list is broken.  "
			    "Remaining octet is too short.";
			goto fail;
		}
		if (tlvspace_remaining() < 4) {
			reason = "parsing TAGs reached the buffer size limit.";
			goto fail;
		}
		tlv = (struct pppoe_tlv *)p_tlvspace;
		GETSHORT(tlv->type, pkt);
		GETSHORT(tlv->length, pkt);
		p_tlvspace += 4;
		lpkt -= 4;
		if (tlv->length > lpkt) {
			reason = "tlv list is broken.  length is wrong.";
			goto fail;
		}
		if (tlvspace_remaining() < tlv->length) {
			reason = "parsing TAGs reached the buffer size limit.";
			goto fail;
		}
		if (tlv->length > 0) {
			memcpy(tlv->value, pkt, tlv->length);
			pkt += tlv->length;
			lpkt -= tlv->length;
			p_tlvspace += tlv->length;
			p_tlvspace = (u_char *)ALIGN(p_tlvspace);
		}
#ifdef	PPPOED_DEBUG
		if (debuglevel >= 2)
			pppoed_log(_this->self, DEBUG_LEVEL_2,
			    "Recv%s tag %s(%04x)=%s",
			    pppoe_code_string(pppoe->code),
			    pppoe_tag_string(tlv->type), tlv->type,
			    pppoed_tlv_value_string(tlv));
#endif
		if (tlv->type == PPPOE_TAG_END_OF_LIST)
			break;
		if (slist_add(&tag_list, tlv) == NULL) {
			goto fail;
		}
	}
	switch (pppoe->code) {
	case PPPOE_CODE_PADI:
		if (_this->self->state != PPPOED_STATE_RUNNING)
			break;
		pppoed_recv_PADI(_this, shost, &tag_list);
		break;
	case PPPOE_CODE_PADR:
		if (_this->self->state != PPPOED_STATE_RUNNING)
			break;
		pppoed_recv_PADR(_this, shost, &tag_list);
		break;
	case PPPOE_CODE_PADT:
		PPPOED_DBG((_this->self, LOG_DEBUG, "RecvPADT"));
		if (session != NULL)
			pppoe_session_recv_PADT(session, &tag_list);
		break;
	}
	slist_fini(&tag_list);

	return;
fail:
	slist_fini(&tag_list);
bad_packet:
	pppoed_log(_this->self, LOG_INFO,
	    "Received a bad packet: code=%s(%02x) ver=%d type=%d session-id=%d"
	    " if=%s: %s", pppoe_code_string(pppoe->code), pppoe->code,
	    pppoe->ver, pppoe->type, pppoe->session_id, _this->listen_ifname,
	    reason);
}

static int
pppoed_output(pppoed_listener *_this, u_char *dhost, u_char *pkt, int lpkt)
{
	int sz, iovc;
	struct iovec iov[3];
	struct ether_header ether;
	struct pppoe_header *pppoe;
	u_char pad[ETHERMIN];

	memcpy(ether.ether_dhost, dhost, ETHER_ADDR_LEN);
	memcpy(ether.ether_shost, _this->ether_addr, ETHER_ADDR_LEN);

	iov[0].iov_base = &ether;
	iov[0].iov_len = sizeof(struct ether_header);
	ether.ether_type = htons(ETHERTYPE_PPPOEDISC);
	iov[1].iov_base = pkt;
	iov[1].iov_len = lpkt;
	pppoe = (struct pppoe_header *)pkt;
	pppoe->length = htons(lpkt - sizeof(struct pppoe_header));

	iovc = 2;

	if (lpkt < ETHERMIN) {
		memset(pad, 0, ETHERMIN - lpkt);
		iov[2].iov_base = pad;
		iov[2].iov_len = ETHERMIN - lpkt;
		iovc++;
	}

	sz = writev(_this->bpf, iov, iovc);

	return (sz > 0)? 0 : -1;
}

static void
pppoed_recv_PADR(pppoed_listener *_this, uint8_t shost[ETHER_ADDR_LEN],
    slist *tag_list)
{
	int session_id, shuffle_cnt;
	pppoe_session *session;
	pppoed *_pppoed;

	_pppoed = _this->self;
	if ((session = malloc(sizeof(pppoe_session))) == NULL) {
		pppoed_log(_pppoed, LOG_ERR, "malloc() failed on %s(): %m",
		    __func__);
		goto fail;
	}

	/* create session_id */
	shuffle_cnt = 0;
	do {
		session_id = (intptr_t)slist_remove_first(
		    &_pppoed->session_free_list);
		if (session_id != PPPOED_SESSION_SHUFFLE_MARK)
			break;
		PPPOED_ASSERT(shuffle_cnt == 0);
		if (shuffle_cnt++ > 0) {
			pppoed_log(_pppoed, LOG_ERR,
			    "unexpected errror in %s(): session_free_list full",
			    __func__);
			slist_add(&_pppoed->session_free_list,
			    (void *)PPPOED_SESSION_SHUFFLE_MARK);
			goto fail;
		}
		slist_shuffle(&_pppoed->session_free_list);
		slist_add(&_pppoed->session_free_list,
		    (void *)PPPOED_SESSION_SHUFFLE_MARK);
	} while (1);

	if (pppoe_session_init(session, _pppoed, _this->index, session_id,
	    shost) != 0)
		goto fail;

	hash_insert(_pppoed->session_hash, (void *)(intptr_t)session_id,
	    session);

	if (pppoe_session_recv_PADR(session, tag_list) != 0)
		goto fail;

	session = NULL;	/* don't free */
	/* FALLTHROUGH */
fail:
	if (session != NULL)
		pppoe_session_fini(session);
	return;
}

static void
pppoed_recv_PADI(pppoed_listener *_this, uint8_t shost[ETHER_ADDR_LEN],
    slist *tag_list)
{
	int len;
	const char *service_name, *ac_name;
	u_char bufspace[2048];
	u_char sn[2048], ac_name0[40];
	struct pppoe_header pppoe;
	struct pppoe_tlv tlv, *tlv_hostuniq, *tlv0, *tlv_service_name;
	bytebuffer *buf;

	if ((buf = bytebuffer_wrap(bufspace, sizeof(bufspace))) == NULL) {
		pppoed_log(_this->self, LOG_ERR,
		"bytebuffer_wrap() failed on %s(): %m", __func__);
		return;
	}
	bytebuffer_clear(buf);

	tlv_hostuniq = NULL;
	tlv_service_name = NULL;

	service_name = "";
	if (_this->conf->service_name != NULL)
		service_name = _this->conf->service_name;

	for (slist_itr_first(tag_list); slist_itr_has_next(tag_list);) {
		tlv0 = slist_itr_next(tag_list);
		if (tlv0->type == PPPOE_TAG_HOST_UNIQ)
			tlv_hostuniq = tlv0;
		if (tlv0->type == PPPOE_TAG_SERVICE_NAME) {

			len = tlv0->length;
			if (len >= sizeof(sn))
				goto fail;

			memcpy(sn, tlv0->value, len);
			sn[len] = '\0';

			if (strcmp(service_name, sn) == 0 ||
			    (sn[0] == '\0' && _this->conf->accept_any_service))
				tlv_service_name = tlv0;
		}
	}
	if (tlv_service_name == NULL) {
		pppoed_log(_this->self, LOG_INFO,
		    "Deny PADI from=%02x:%02x:%02x:%02x:%02x:%02x "
		    "service-name=%s host-uniq=%s if=%s: serviceName is "
		    "not allowed.", shost[0], shost[1],
		    shost[2], shost[3], shost[4], shost[5], sn, tlv_hostuniq?
		    pppoed_tlv_value_string(tlv_hostuniq) : "none",
		    _this->listen_ifname);
		goto fail;
	}

	pppoed_log(_this->self, LOG_INFO,
	    "RecvPADI from=%02x:%02x:%02x:%02x:%02x:%02x service-name=%s "
	    "host-uniq=%s if=%s", shost[0], shost[1], shost[2], shost[3],
	    shost[4], shost[5], sn, tlv_hostuniq?
	    pppoed_tlv_value_string(tlv_hostuniq) : "none",
	    _this->listen_ifname);

	/*
	 * PPPoE Header
	 */
	memset(&pppoe, 0, sizeof(pppoe));
	pppoe.ver = PPPOE_RFC2516_VER;
	pppoe.type = PPPOE_RFC2516_TYPE;
	pppoe.code = PPPOE_CODE_PADO;
	bytebuffer_put(buf, &pppoe, sizeof(pppoe));

	/*
	 * Tag - Service-Name
	 */
	tlv.type = htons(PPPOE_TAG_SERVICE_NAME);
	len = strlen(service_name);
	tlv.length = htons(len);
	bytebuffer_put(buf, &tlv, sizeof(tlv));
	if (len > 0)
		bytebuffer_put(buf, service_name, len);

	/*
	 * Tag - Access Concentrator Name
	 */
	ac_name = _this->conf->ac_name;
	if (ac_name == NULL) {
		/*
		 * use the ethernet address as default AC-Name.
		 * suggested by RFC 2516.
		 */
		snprintf(ac_name0, sizeof(ac_name0),
		    "%02x:%02x:%02x:%02x:%02x:%02x", _this->ether_addr[0],
		    _this->ether_addr[1], _this->ether_addr[2],
		    _this->ether_addr[3], _this->ether_addr[4],
		    _this->ether_addr[5]);
		ac_name = ac_name0;
	}

	tlv.type = htons(PPPOE_TAG_AC_NAME);
	len = strlen(ac_name);
	tlv.length = htons(len);
	bytebuffer_put(buf, &tlv, sizeof(tlv));
	bytebuffer_put(buf, ac_name, len);

	/*
	 * Tag - ac-cookie
	 */
	if (_this->self->acookie_hash != NULL) {
		/*
		 * search next ac-cookie.
		 * (XXX it will loop in uint32_t boundaly)
		 */
		do {
			_this->self->acookie_next += 1;
		}
		while(hash_lookup(_this->self->acookie_hash,
		    (void *)(intptr_t)_this->self->acookie_next) != NULL);

		tlv.type = htons(PPPOE_TAG_AC_COOKIE);
		tlv.length = ntohs(sizeof(uint32_t));
		bytebuffer_put(buf, &tlv, sizeof(tlv));
		bytebuffer_put(buf, &_this->self->acookie_next,
		    sizeof(uint32_t));
	}

	/*
	 * Tag - Host-Uniq
	 */
	if (tlv_hostuniq != NULL) {
		tlv.type = htons(PPPOE_TAG_HOST_UNIQ);
		tlv.length = ntohs(tlv_hostuniq->length);
		bytebuffer_put(buf, &tlv, sizeof(tlv));
		bytebuffer_put(buf, tlv_hostuniq->value,
		    tlv_hostuniq->length);
	}

	/*
	 * Tag - End-Of-List
	 */
	tlv.type = htons(PPPOE_TAG_END_OF_LIST);
	tlv.length = ntohs(0);
	bytebuffer_put(buf, &tlv, sizeof(tlv));

	bytebuffer_flip(buf);

	if (pppoed_output(_this, shost, bytebuffer_pointer(buf),
	    bytebuffer_remaining(buf)) != 0) {
		pppoed_log(_this->self, LOG_ERR, "pppoed_output() failed:%m");
	}
	pppoed_log(_this->self, LOG_INFO,
	    "SendPADO to=%02x:%02x:%02x:%02x:%02x:%02x serviceName=%s "
	    "acName=%s hostUniq=%s eol if=%s", shost[0], shost[1], shost[2],
	    shost[3], shost[4], shost[5], service_name, ac_name,
	    tlv_hostuniq? pppoed_tlv_value_string(tlv_hostuniq) : "none",
		_this->listen_ifname);
	/* FALLTHROUGH */
fail:
	bytebuffer_unwrap(buf);
	bytebuffer_destroy(buf);
}

/*
 * log
 */
static void
pppoed_log(pppoed *_this, int prio, const char *fmt, ...)
{
	char logbuf[BUFSIZ];
	va_list ap;

	PPPOED_ASSERT(_this != NULL);
	va_start(ap, fmt);
#ifdef	PPPOED_MULTIPLE
	snprintf(logbuf, sizeof(logbuf), "pppoed id=%u %s", _this->id, fmt);
#else
	snprintf(logbuf, sizeof(logbuf), "pppoed %s", fmt);
#endif
	vlog_printf(prio, logbuf, ap);
	va_end(ap);
}

#define	NAME_VAL(x)	{ x, #x }
static struct _label_name {
	int		label;
	const char	*name;
} pppoe_code_labels[] = {
	NAME_VAL(PPPOE_CODE_PADI),
	NAME_VAL(PPPOE_CODE_PADO),
	NAME_VAL(PPPOE_CODE_PADR),
	NAME_VAL(PPPOE_CODE_PADS),
	NAME_VAL(PPPOE_CODE_PADT),
#ifdef PPPOED_DEBUG
}, pppoe_tlv_labels[] = {
	NAME_VAL(PPPOE_TAG_END_OF_LIST),
	NAME_VAL(PPPOE_TAG_SERVICE_NAME),
	NAME_VAL(PPPOE_TAG_AC_NAME),
	NAME_VAL(PPPOE_TAG_HOST_UNIQ),
	NAME_VAL(PPPOE_TAG_AC_COOKIE),
	NAME_VAL(PPPOE_TAG_VENDOR_SPECIFIC),
	NAME_VAL(PPPOE_TAG_RELAY_SESSION_ID),
	NAME_VAL(PPPOE_TAG_SERVICE_NAME_ERROR),
	NAME_VAL(PPPOE_TAG_AC_SYSTEM_ERROR),
	NAME_VAL(PPPOE_TAG_GENERIC_ERROR)
#endif
};
#define LABEL_TO_STRING(func_name, label_names, prefix_len)		\
	static const char *						\
	func_name(int code)						\
	{								\
		int i;							\
									\
		for (i = 0; i < countof(label_names); i++) {		\
			if (label_names[i].label == code)		\
				return label_names[i].name + prefix_len;\
		}							\
									\
		return "UNKNOWN";					\
	}
LABEL_TO_STRING(pppoe_code_string, pppoe_code_labels, 11)
#ifdef PPPOED_DEBUG
LABEL_TO_STRING(pppoe_tag_string, pppoe_tlv_labels, 10)
#endif

const char *
pppoed_tlv_value_string(struct pppoe_tlv *tlv)
{
	int i;
	char buf[3];
	static char _tlv_string_value[8192];

	_tlv_string_value[0] = '\0';
	for (i = 0; i < tlv->length; i++) {
		snprintf(buf, sizeof(buf), "%02x", tlv->value[i]);
		strlcat(_tlv_string_value, buf,
		    sizeof(_tlv_string_value));
	}
	return _tlv_string_value;
}

/*
 * misc
 */
static int
session_id_cmp(void *a, void *b)
{
	int ia, ib;

	ia = (intptr_t)a;
	ib = (intptr_t)b;

	return ib - ia;
}

static uint32_t
session_id_hash(void *a, size_t siz)
{
	int ia;

	ia = (intptr_t)a;

	return ia % siz;
}
@


1.19
log
@Replace 'arc4random() % (2^k - 1)' by 'arc4random() & (2^k - 1)' to
avoid modulo bias.  Part of a diff by Matthew Martin, reviewed by
deraadt@@ and me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.18 2015/10/11 07:32:06 guenther Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.18 2015/10/11 07:32:06 guenther Exp $
a204 1
	int i;
a205 1
	char buf[BUFSIZ];
d276 2
a277 11
	/* Open /dev/bpfXX */
	/* FIXME: /dev/bpf of NetBSD3.0 can simultaneity open */
	for (i = 0; i < 256; i++) {
		snprintf(buf, sizeof(buf), "/dev/bpf%d", i);
		if ((_this->bpf = priv_open(buf, O_RDWR)) >= 0) {
			break;
		} else if (errno == ENXIO || errno == ENOENT)
			break;	/* no more entries */
	}
	if (_this->bpf < 0) {
		pppoed_log(_pppoed, log_level, "Cannot open bpf");
d319 1
a319 1
	pppoed_log(_pppoed, LOG_INFO, "Listening on %s (PPPoE) [%s] using=%s "
d321 1
a321 1
	    _this->tun_name, buf, _this->ether_addr[0], _this->ether_addr[1],
@


1.18
log
@Simplify and lock down priv_open():
 * kill the 'mode' argument
 * fail if passed any flags other than O_ACCMODE OR O_NONBLOCK
 * paranoia: mask O_CREAT when calling open() with only two arguments
 * instead of using ioctl(FIONBIO) after the fact, pass O_NONBLOCK to
   priv_open()

"good start" deraadt@@
ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.17 2015/01/19 01:48:59 deraadt Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.17 2015/01/19 01:48:59 deraadt Exp $
d150 1
a150 1
	off = arc4random() % 0xffff;
d152 1
a152 1
		id = (i + off) % 0xffff;
d154 1
a154 1
			id = (off - 1) % 0xffff;
@


1.17
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.16 2014/11/27 10:22:38 tobias Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.16 2014/11/27 10:22:38 tobias Exp $
d282 1
a282 1
		if ((_this->bpf = priv_open(buf, O_RDWR, 0600)) >= 0) {
@


1.16
log
@Fix typos in comments.

ok jmc, yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.15 2014/07/21 01:51:11 guenther Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.15 2014/07/21 01:51:11 guenther Exp $
d33 1
a34 1
#include <sys/param.h>
d71 2
@


1.15
log
@Switch from <sys/endian.h> or <machine/endian.h> to the new,
being-standardized <endian.h>

ok deraadt@@ millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.14 2014/03/22 04:18:18 yasuoka Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.14 2014/03/22 04:18:18 yasuoka Exp $
d443 1
a443 1
/* it called when the PPPoE session was closed */
d536 1
a536 1
	/* garbage collection of listner context */
d681 1
a681 1
	/* use PPPoE heade value as lpkt */
d703 1
a703 1
	 * PPPoE-Discovery Packet proccessing.
@


1.14
log
@Stop output "Stopped" log message of the tunnel protocols.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.13 2013/04/20 23:32:32 yasuoka Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.13 2013/04/20 23:32:32 yasuoka Exp $
a34 1
#include <sys/endian.h>
d49 1
@


1.13
log
@Don't use random() because it's not safe.  Use arc4random() instead of
it.  Suggested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.12 2013/04/16 07:27:36 yasuoka Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.12 2013/04/16 07:27:36 yasuoka Exp $
d423 1
a423 1
	pppoed_log(_this, LOG_NOTICE, "Stopped");
@


1.12
log
@pppoed didn't work since it has been broken after the last
configuration parser change.

pointed out by todd.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.11 2012/09/18 13:14:08 yasuoka Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.11 2012/09/18 13:14:08 yasuoka Exp $
d143 1
a143 1
	_this->acookie_next = random();
d148 1
a148 1
	off = random() % 0xffff;
@


1.11
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.10 2012/05/08 13:18:37 yasuoka Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.10 2012/05/08 13:18:37 yasuoka Exp $
d473 3
a475 2
		char       ifname[IF_NAMESIZE];
		char       name[PPPOED_PHY_LABEL_SIZE];
d497 1
d525 1
@


1.10
log
@Trivial changes from the upstream(IIJ).
 - fix styles, compile errors in some ifdef condition and compiler warnings.
 - delete rtev* that was to work around routing socket overflows.
 - delete is_ctrl argument from l2tp_ctrl_send_packet().  It's not used.
 - tweak returning the exit status.
 - use IPV6_IPSEC_POLICY for IPv6 socket.
   (though npppd cannot set up a ipsec policy to the socket yet.)

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.9 2012/05/08 13:15:12 yasuoka Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.9 2012/05/08 13:15:12 yasuoka Exp $
a66 2
#include "properties.h"
#include "config_helper.h"
d330 1
a330 1
	    _this->phy_label, buf, _this->ether_addr[0], _this->ether_addr[1],
d387 1
a387 1
		    _this->listen_ifname, _this->phy_label,
a440 2

	_this->config = NULL;
a463 7
#define	CFG_KEY(p, s)	config_key_prefix((p), (s))
#define	VAL_SEP		" \t\r\n"

CONFIG_FUNCTIONS(pppoed_config, pppoed, config);
PREFIXED_CONFIG_FUNCTIONS(pppoed_listener_config, pppoed_listener, self->config,
    phy_label);

d466 1
a466 2
pppoed_reload(pppoed *_this, struct properties *config, const char *name,
    int default_enabled)
d468 4
a471 7
	struct sockaddr_dl *sdl;
	int i, count, found;
	hash_link *hl;
	const char *val;
	char *tok, *cp, buf[PPPOED_CONFIG_BUFSIZ], *label;
	pppoed_listener *l;
	int do_start;
d473 2
a474 2
		char ifname[IF_NAMESIZE];
		char label[PPPOED_PHY_LABEL_SIZE];
d476 3
a478 3
	struct ifaddrs *ifa0, *ifa;
	slist rmlist, newlist;
	pppoe_session *session;
a480 19

	_this->config = config;
	if (pppoed_config_str_equal(_this, CFG_KEY(name, "enabled"), "true",
	    default_enabled)) {
		/* avoid false->true flapping */
		if (pppoed_is_stopped(_this) || !pppoed_is_running(_this))
			do_start = 1;
	} else {
		if (!pppoed_is_stopped(_this))
			pppoed_stop(_this);
		return 0;
	}

	if (do_start) {
		if (pppoed_init(_this) != 0)
			return 1;
		_this->config = config;
	}

a484 10
	_this->desc_in_pktdump = pppoed_config_str_equal(_this,
	    "log.pppoe.desc.in.pktdump", "true", 0);
	_this->desc_out_pktdump = pppoed_config_str_equal(_this,
	    "log.pppoe.desc.out.pktdump", "true", 0);

	_this->session_in_pktdump = pppoed_config_str_equal(_this,
	    "log.pppoe.session.in.pktdump", "true", 0);
	_this->session_out_pktdump = pppoed_config_str_equal(_this,
	    "log.pppoe.session.out.pktdump", "true", 0);

d491 6
a496 54
	val = pppoed_config_str(_this, CFG_KEY(name, "interface"));
	if (val != NULL) {
		if (strlen(val) >= sizeof(buf)) {
			log_printf(LOG_ERR, "configuration error at "
			    "%s: too long", CFG_KEY(name, "interface"));
			return 1;
		}
		strlcpy(buf, val, sizeof(buf));

		label = NULL;
		/* it accepts multiple entries with tab/space separation */
		for (i = 0, cp = buf;
		    (tok = strsep(&cp, VAL_SEP)) != NULL;) {
			if (*tok == '\0')
				continue;
			if (label == NULL) {
				label = tok;
				continue;
			}
			PPPOED_ASSERT(count < countof(listeners));
			if (count >= countof(listeners)) {
				pppoed_log(_this, LOG_ERR,
				    "Too many listeners");
				goto fail;
			}
			/* check the interface exist or not */
			found = 0;
			for (ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next) {
				sdl = (struct sockaddr_dl *)ifa->ifa_addr;
				if (sdl->sdl_family == AF_LINK &&
				    IFTYPE_IS_LAN(sdl->sdl_type) &&
				    strcmp(ifa->ifa_name, tok) == 0) {
					found = 1;
					break;
				}
			}
			if (!found) {
				pppoed_log(_this, LOG_ERR,
				    "interface %s is not found", tok);
				goto fail;
			}
			strlcpy(listeners[count].ifname, tok,
			    sizeof(listeners[count].ifname));
			strlcpy(listeners[count].label, label,
			    sizeof(listeners[count].label));

			label = NULL;
			count++;
		}
		if (label != NULL) {
			log_printf(LOG_ERR, "configuration error at %s: %s",
			    CFG_KEY(name, "interface"), label);
			return 1;
		}
d520 1
a520 2
		strlcpy(l->phy_label, listeners[i].label,
		    sizeof(l->phy_label));
d869 2
a870 2
	int len, accept_any_service_req;
	const char *val, *service_name, *ac_name;
d888 2
a889 5
	if ((val = pppoed_listener_config_str(_this, "pppoe.service_name"))
	    != NULL)
		service_name = val;
	accept_any_service_req = pppoed_listener_config_str_equal(_this,
		"pppoe.accept_any_service_request", "true", 1);
d905 1
a905 1
			    (sn[0] == '\0' && accept_any_service_req))
d949 1
a949 1
	ac_name = pppoed_listener_config_str(_this, "pppoe.ac_name");
@


1.9
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoed.c,v 1.8 2012/01/18 02:53:56 yasuoka Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.8 2012/01/18 02:53:56 yasuoka Exp $
a68 1
#include "rtev.h"
@


1.8
log
@Fix compiler warnings and some styles.

ok sebastia sthen
@
text
@d1 1
a1 1
/* $OpenBSD: pppoed.c,v 1.7 2011/02/28 02:31:55 dlg Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.7 2011/02/28 02:31:55 dlg Exp $
d1134 1
a1134 1
#ifdef	PPPOED_MULITPLE
@


1.7
log
@fix a buffer overflow in the pppoe receive packet handling.

diff from yasuoka@@
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pppoed.c,v 1.6 2010/07/02 21:20:57 yasuoka Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.6 2010/07/02 21:20:57 yasuoka Exp $
d156 2
a157 1
		if (slist_add(&_this->session_free_list, (void *)id) == NULL) {
d452 2
a453 1
	slist_add(&_this->session_free_list, (void *)session->session_id);
d456 2
a457 1
		hash_delete(_this->acookie_hash, (void *)session->acookie, 0);
d459 2
a460 2
		hash_delete(_this->session_hash, (void *)session->session_id,
		    0);
d782 2
a783 1
		hl = hash_lookup(_this->self->session_hash, (void *)session_id);
d923 1
a923 1
		session_id = (int)slist_remove_first(
d945 2
a946 1
	hash_insert(_pppoed->session_hash, (void *)session_id, session);
d1078 1
a1078 1
		    (void *)_this->self->acookie_next) != NULL);
d1209 2
a1210 2
	ia = (int)a;
	ib = (int)b;
d1220 1
a1220 1
	ia = (int)a;
@


1.6
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: pppoed.c,v 1.5 2010/07/01 03:38:17 yasuoka Exp $	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.5 2010/07/01 03:38:17 yasuoka Exp $
d742 1
d799 4
d812 4
d817 1
a817 1
			memcpy(&tlv->value, pkt, tlv->length);
@


1.5
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
a2 1
/*	$OpenBSD:$	*/
d31 1
a31 1
 * $Id: pppoed.c,v 1.4 2010/01/31 05:49:51 yasuoka Exp $
d172 1
a172 1
pppoed_listener_init(pppoed *_this, pppoed_listener *listener) 
d237 1
a237 1
#endif 
d403 1
a403 1
	pppoe_session *session; 
d496 1
a496 1
	if (pppoed_config_str_equal(_this, CFG_KEY(name, "enabled"), "true", 
d755 1
a755 1
		    pppoe_code_string(pppoe->code), pppoe->code, 
d894 1
a894 1
    slist *tag_list) 
d947 1
a947 1
    slist *tag_list) 
d1205 1
a1205 1
	
@


1.4
log
@privilege separation of npppd.

- Drop privilege after daemon initializing.
- Some system calls that requires root privileges were replaced to
  wrapper functions that communicate with a separated privileged
  process via IPC.  And the privileged process checks whether the
  operations are acceptable.
@
text
@d1 1
d28 3
a30 6
 * PPPoEサーバの実装。
 * <dl>
 *  <dt>RFC 2516</dt>
 *  <dd>A Method for Transmitting PPP Over Ethernet (PPPoE)</dd>
 * </dl>
 * $Id: pppoed.c,v 1.3 2010/01/27 07:27:02 yasuoka Exp $
d104 5
a108 4
/***********************************************************************
 * デーモン関連
 ***********************************************************************/
/** PPPoE デーモンを初期化します */
d123 1
a123 1
		goto reigai;
d131 1
a131 1
		goto reigai;
d134 1
a134 1
	/* XXX クッキーハッシュの初期化 */
d158 1
a158 1
			goto reigai;
d165 1
a165 1
reigai:
d179 1
a179 1
/** リスナをリロードします */
d192 3
a194 3
/**
 * 他人宛のパケットを受信するかも(see bpf(4))。自分宛とブロードキャスト宛
 * は弾く。
d221 1
a221 1
	/* ff:ff:ff:ff:ff:ff 宛 */
d227 1
a227 1
	/* 自分の Mac 宛 */
d274 1
a274 1
		goto reigai;
d278 1
a278 1
	/* FIXME: NetBSD 3.0 では、/dev/bpf 一つで何度も開けるらしい */
d284 1
a284 1
			break;	/* これ以上探してもみつからないはず */
d288 1
a288 1
		goto reigai;
d295 1
a295 1
		goto reigai;
d301 1
a301 1
		goto reigai;
d310 1
a310 1
		goto reigai;
d322 1
a322 1
		goto reigai;
d336 1
a336 1
reigai:
d345 1
a345 1
/** PPPoE デーモンを開始します */
d373 1
d396 1
a396 1
/** PPPoE デーモンを停止します */
d427 1
a427 1
/** PPPoE デーモンを解放します */
d440 3
a442 1
	slist_fini(&_this->listener); // stop メンバは解放済。
d446 1
a446 1
/** PPPoE セッションが close された時に呼び出されます。*/
d462 3
a464 3
/***********************************************************************
 * 設定関連
 ***********************************************************************/
d472 1
a472 1
/** PPPoE デーモンの設定を再読み込みします */
d497 1
a497 1
		// false にした直後に true にされるかもしれない。
d529 1
a529 1
		goto reigai;
d542 1
a542 1
		// タブ、スペース区切りで、複数指定可能
d555 1
a555 1
				goto reigai;
d557 1
a557 1
			/* インタフェースの実在確認 */
d571 1
a571 1
				goto reigai;
d589 1
a589 1
		goto reigai;
d605 1
a605 1
				goto reigai;
d616 1
a616 1
			goto reigai;
d621 1
a621 1
		goto reigai;
d623 1
a623 1
	/* 使わなくなったリスナの停止 */
d627 1
a627 1
		/* 派生した PPPoEセッションの考慮 */
d640 1
a640 1
	/* slist_set_size しているので、失敗しないはず */
d643 1
a643 1
	/* インデックスのリセット */
d669 1
a669 1
reigai:
d677 5
a681 3
/***********************************************************************
 * I/O 関連
 ***********************************************************************/
d709 2
a710 1
			goto next_pkt;	// 自分パケット
d767 2
a768 1
	lpkt = pppoe->length;	/* PPPoEヘッダの値を使う */
d795 1
a795 1
			goto reigai;
d804 1
a804 1
			goto reigai;
d824 1
a824 1
			goto reigai;
d847 1
a847 1
reigai:
d903 1
a903 1
		goto reigai;
d906 1
a906 1
	/* セッション Id の作成 */
d920 1
a920 1
			goto reigai;
d929 1
a929 1
		goto reigai;
d934 1
a934 1
		goto reigai;
d937 2
a938 2
	/* FALL THROUGH */
reigai:
d981 1
a981 1
				goto reigai;
d999 1
a999 1
		goto reigai;
d1056 2
a1057 2
		 * ac-cookie の次の値を探す。
		 * (uint32_t の空間で値がループします)
d1102 2
a1103 2
	// FALL THROUGH
reigai:
d1108 3
a1110 3
/***********************************************************************
 * ログ関連
 ***********************************************************************/
d1186 3
a1188 3
/***********************************************************************
 * 雑多な関数
 ***********************************************************************/
@


1.3
log
@Fixed 2 off-by-one problems.
(found by parfait, reported by jsg@@)
@
text
@d32 1
a32 1
 * $Id: pppoed.c,v 1.2 2010/01/13 07:49:44 yasuoka Exp $
d71 1
d282 1
a282 1
		if ((_this->bpf = open(buf, O_RDWR, 0600)) >= 0) {
@


1.2
log
@cleanup npppd code.  delete IIJ local ifdef switches and fix warnings.
ok @@dlg
@
text
@d32 1
a32 1
 * $Id: pppoed.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $
d973 1
a973 1
			if (len > sizeof(sn))
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d32 1
a32 1
 * $Id: pppoed.c 39106 2010-01-10 21:01:39Z yasuoka $
a33 3
#ifdef	_SEIL_EXT_
#include <seil/features.h>
#endif
@

