head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.16
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.14
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.10
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.8
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2014.03.22.04.32.39;	author yasuoka;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.13.17.10.40;	author yasuoka;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.08.13.15.12;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.15.03.24.11;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.20.23.12.33;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.07.49.44;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Now tunnel can have multiple listen addresses.
@
text
@/*	$OpenBSD: pptp.h,v 1.9 2012/11/13 17:10:40 yasuoka Exp $	*/

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#ifndef PPTP_H
#define PPTP_H	1

/*
 * PPTP protocol constants
 */
#define	PPTP_MES_TYPE_CTRL			1
#define	PPTP_MAGIC_COOKIE			0x1a2b3c4d
#define	PPTP_RFC_2637_VERSION			0x0100

#ifndef	PPTP_MAX_CALL
#define	PPTP_MAX_CALL				8192
#endif

/* Start-Control-Connection-Request */
#define	PPTP_CTRL_MES_CODE_SCCRQ	1

/* Start-Control-Connection-Reply */
#define	PPTP_CTRL_MES_CODE_SCCRP	2

/* Stop-Control-Connection-Request */
#define	PPTP_CTRL_MES_CODE_StopCCRQ	3

/* Stop-Control-Connection-Reply */
#define	PPTP_CTRL_MES_CODE_StopCCRP	4

/* Echo-Request */
#define	PPTP_CTRL_MES_CODE_ECHO_RQ	5

/* Echo-Reply */
#define	PPTP_CTRL_MES_CODE_ECHO_RP	6

/* Outgoing-Call-Request */
#define	PPTP_CTRL_MES_CODE_OCRQ		7

/* Outgoing-Call-Reply */
#define	PPTP_CTRL_MES_CODE_OCRP		8

/* Incoming-Call-Request */
#define	PPTP_CTRL_MES_CODE_ICRQ		9

/* Incoming-Call-Reply */
#define	PPTP_CTRL_MES_CODE_ICRP		10

/* Incoming-Call-Connected */
#define	PPTP_CTRL_MES_CODE_ICCN		11

/* Call-Clear-Request */
#define	PPTP_CTRL_MES_CODE_CCR		12

/* Call-Disconnect-Notify */
#define	PPTP_CTRL_MES_CODE_CDN		13

/* Set-Link-Info */
#define	PPTP_CTRL_MES_CODE_SLI		15


#define	PPTP_CTRL_FRAMING_ASYNC		1
#define	PPTP_CTRL_FRAMING_SYNC		2

#define	PPTP_CTRL_BEARER_ANALOG		1
#define	PPTP_CTRL_BEARER_DIGITAL	2


/* Result Code: Start-Control-Connection-Reply */
#define PPTP_SCCRP_RESULT_SUCCESS		1
#define PPTP_SCCRP_RESULT_GENERIC_ERROR		2
#define PPTP_SCCRP_RESULT_CHANNEL_EXISTS	3
#define PPTP_SCCRP_RESULT_NOT_AUTHORIZIZED	4
#define PPTP_SCCRP_RESULT_BAD_PROTOCOL_VERSION	5

/* General Error Code (RFC 2637 2.16 pp.36) */
#define PPTP_ERROR_NONE				0
#define PPTP_ERROR_NOT_CONNECTED		1
#define PPTP_ERROR_BAD_FORMAT			2
#define PPTP_ERROR_NO_RESOURCE			3
#define PPTP_ERROR_BAD_CALL			4
#define PPTP_ERROR_PAC_ERROR			5

/* Result Code: Outgoing-Call-Reply */
#define PPTP_OCRP_RESULT_CONNECTED		1
#define PPTP_OCRP_RESULT_GENERIC_ERROR		2
#define PPTP_OCRP_RESULT_NO_CARRIER		3
#define PPTP_OCRP_RESULT_BUSY			4
#define PPTP_OCRP_RESULT_NO_DIALTONE		5
#define PPTP_OCRP_RESULT_TIMEOUT		6
#define PPTP_OCRP_RESULT_DO_NOT_ACCEPT		7

/* Result Code: Echo-Reply */
#define PPTP_ECHO_RP_RESULT_OK			1
#define PPTP_ECHO_RP_RESULT_GENERIC_ERROR	2

/* Reason code of the Stop-Control-Connection-Request */
#define	PPTP_StopCCRQ_REASON_NONE			1
#define	PPTP_StopCCRQ_REASON_STOP_PROTOCOL		2
#define	PPTP_StopCCRQ_REASON_STOP_LOCAL_SHUTDOWN	3

/* Result code of the Stop-Control-Connection-Response */
#define	PPTP_StopCCRP_RESULT_OK			1
#define	PPTP_StopCCRP_RESULT_GENERIC_ERROR	2

#define	PPTP_CDN_RESULT_LOST_CARRIER		1
#define	PPTP_CDN_RESULT_GENRIC_ERROR		2
#define	PPTP_CDN_RESULT_ADMIN_SHUTDOWN		3
#define	PPTP_CDN_RESULT_REQUEST			4

/* Default TCP port number */
#define	PPTPD_DEFAULT_TCP_PORT			1723


#define	PPTP_GRE_PROTOCOL_TYPE			0x880b
#define	PPTP_GRE_VERSION			1

/*
 * Constants of the NPPPD implementation
 */
#include "pptp_conf.h"

/* pptpd status */
#define	PPTPD_STATE_INIT 		0
#define	PPTPD_STATE_RUNNING 		1
#define	PPTPD_STATE_SHUTTING_DOWN 	2
#define	PPTPD_STATE_STOPPED 		3

#define	PPTPD_CONFIG_BUFSIZ		65535

#define	PPTP_BACKLOG	32
#define PPTP_BUFSIZ	1024

#define PPTPD_DEFAULT_LAYER2_LABEL		"PPTP"

/* pptp control state code */
#define PPTP_CTRL_STATE_IDLE			0
#define PPTP_CTRL_STATE_WAIT_CTRL_REPLY		1
#define PPTP_CTRL_STATE_ESTABLISHED		2
#define PPTP_CTRL_STATE_WAIT_STOP_REPLY		3
#define PPTP_CTRL_STATE_DISPOSING		4

#ifndef	PPTPD_DEFAULT_VENDOR_NAME
#define	PPTPD_DEFAULT_VENDOR_NAME		""
#endif

#ifndef	PPTP_CALL_DEFAULT_MAXWINSZ
#define	PPTP_CALL_DEFAULT_MAXWINSZ		64
#endif

/* Connection speed that nofified by OCRP */
/* XXX: currently we use fixed value */
#ifndef	PPTP_CALL_CONNECT_SPEED
#define	PPTP_CALL_CONNECT_SPEED			10000000
#endif

/* Initial packet processing delay that nofified by OCRP */
#ifndef	PPTP_CALL_INITIAL_PPD
#define PPTP_CALL_INITIAL_PPD			0
#endif

/**
 * PPTP_CALL_DELAY_LIMIT indicates how many sequence number can be rewinded
 * by reordering.
 */
#define	PPTP_CALL_DELAY_LIMIT			64

/* pptp call state machine */
#define	PPTP_CALL_STATE_IDLE			0
#define	PPTP_CALL_STATE_WAIT_CONN		1
#define	PPTP_CALL_STATE_ESTABLISHED		2
#define	PPTP_CALL_STATE_CLEANUP_WAIT		3

/* Timeout */
#define PPTPD_SHUTDOWN_TIMEOUT			5

#define	PPTPD_IDLE_TIMEOUT			60

#define	PPTP_CALL_CLEANUP_WAIT_TIME		3

#define PPTP_CTRL_DEFAULT_ECHO_INTERVAL		60
#define PPTP_CTRL_DEFAULT_ECHO_TIMEOUT		60
#define	PPTP_CTRL_StopCCRP_WAIT_TIME		3

/* MAXIMUM bindable IP addresses */
#ifndef	PPTP_NLISTENER
#define	PPTP_NLISTENER				6
#endif

/* Utility macro */
#define	pptpd_is_stopped(pptpd)					\
	(((pptpd)->state != PPTPD_STATE_SHUTTING_DOWN &&	\
	    (pptpd)->state != PPTPD_STATE_RUNNING)? 1 : 0)

#define	pptpd_is_shutting_down(pptpd)				\
	(((pptpd)->state == PPTPD_STATE_SHUTTING_DOWN)? 1 : 0)

/*
 * types
 */
struct _pptpd;

typedef struct _pptpd_listener {
	struct event ev_sock_gre; /* GRE event context */
	struct _pptpd	*self;
	uint16_t	index;
	int		sock; /* listing socket */
	int		sock_gre; /* GRE socket */
	struct sockaddr_in bind_sin;	/* listing TCP address */
	struct sockaddr_in bind_sin_gre; /* listing GRE address */
	char	tun_name[PPTP_NAME_LEN];
	struct pptp_conf *conf;
} pptpd_listener;

typedef struct _pptpd {
	unsigned	id;
	slist listener;		/* list of listeners */
	int state;
	struct event ev_timer; /* timer event context */
	slist  ctrl_list;	/* list of PPTP controls */

	slist call_free_list;	/* Free call lists */
	hash_table *call_id_map; /* table to map between callid and call */
	/* ipv4 networks that is permitted to connect */

	uint32_t		/* flags */
	    initialized:1;
} pptpd;

#define pptp_ctrl_sock_gre(ctrl)	\
	((pptpd_listener *)slist_get(&(ctrl)->pptpd->listener,\
	    (ctrl)->listener_index))->sock_gre

/* get listner's physical layer label from pptp_ctrl */
#define	PPTP_CTRL_LISTENER_TUN_NAME(ctrl)	\
	((pptpd_listener *)slist_get(&(ctrl)->pptpd->listener,\
	    (ctrl)->listener_index))->tun_name

#define	PPTP_CTRL_CONF(ctrl)					\
	((pptpd_listener *)slist_get(&(ctrl)->pptpd->listener,	\
	    (ctrl)->listener_index))->conf

typedef struct _pptp_ctrl {
	pptpd		*pptpd;	/* parents */
	uint16_t	listener_index;
	unsigned 	id;
	int		state;

	int		sock;
	struct sockaddr_storage peer;
	struct sockaddr_storage our;
	struct event	ev_sock;
	struct event	ev_timer;

	int echo_interval; /* periods between idle state to ECHO transmit */
	int echo_timeout;

	int		send_ready; /* ready to send */
	bytebuffer	*recv_buf;
	bytebuffer	*send_buf;

	slist		call_list;

	time_t	last_snd_ctrl;	/* timestamp of latest ctrl message sent */
	time_t	last_rcv_ctrl;	/* timestamp of latest ctrl message receieved */
	uint32_t	echo_seq; /* identifier of Echo Request */

	int16_t		/* flags : processing I/O events */
			on_io_event:1,
			reserved:15;
} pptp_ctrl;

typedef struct _pptp_call {
	pptp_ctrl	*ctrl; /* parent */
	unsigned	id;

	int		ifidx; /* receive interface index */

	int		state;

	unsigned	peers_call_id;
	void		*ppp;

	uint32_t	snd_una;	/* next ack notification */
	uint32_t	snd_nxt;	/* next transmit sequence # */

	uint32_t	rcv_nxt;	/* received sequence # */
	uint32_t	rcv_acked;	/* latest acked received sequence # */

	int		winsz;		/* current window size */
	int		maxwinsz;	/* maximum window size */
	int		peers_maxwinsz;

	time_t		last_io;
} pptp_call;


/*
 * function prototypes
 */
#ifdef __cplusplus
extern "C" {
#endif

int   pptpd_init (pptpd *);
void  pptpd_uninit (pptpd *);
int   pptpd_assign_call (pptpd *, pptp_call *);
void  pptpd_release_call (pptpd *, pptp_call *);
int   pptpd_start (pptpd *);
void  pptpd_stop (pptpd *);
void pptpd_stop_immediatly (pptpd *);
void  pptpd_ctrl_finished_notify(pptpd *, pptp_ctrl *);
int  pptpd_add_listener(pptpd *, int, struct pptp_conf *, struct sockaddr *);

pptp_ctrl  *pptp_ctrl_create (void);
int        pptp_ctrl_init (pptp_ctrl *);
int        pptp_ctrl_start (pptp_ctrl *);
void       pptp_ctrl_stop (pptp_ctrl *, int);
void       pptp_ctrl_destroy (pptp_ctrl *);
void       pptp_ctrl_output (pptp_ctrl *, u_char *, int);

pptp_call  *pptp_call_create (void);
int        pptp_call_init (pptp_call *, pptp_ctrl *);
int        pptp_call_start (pptp_call *);
int        pptp_call_stop (pptp_call *);
void       pptp_call_destroy (pptp_call *);
void       pptp_call_input (pptp_call *, int, u_char *, int);
void       pptp_call_gre_input (pptp_call *, uint32_t, uint32_t, int, u_char *, int);
void       pptp_call_disconnect(pptp_call *, int, int, const char *);
int        pptpd_reload(pptpd *, struct pptp_confs *);

#ifdef __cplusplus
}
#endif
#endif
@


1.9
log
@Add accept.c from ldpd and use it to handle file descriptor exhaustion
in accept() case.

"go for it" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pptp.h,v 1.8 2012/09/18 13:14:08 yasuoka Exp $	*/
d336 1
a336 1
int  pptpd_add_listener(pptpd *, int, struct pptp_conf *);
@


1.8
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: pptp.h,v 1.7 2012/05/08 13:15:12 yasuoka Exp $	*/
a226 1
	struct event ev_sock;	/* event context */
@


1.7
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pptp.h,v 1.6 2011/10/15 03:24:11 yasuoka Exp $	*/
d144 2
d235 2
a236 1
	char	phy_label[16];
a245 2
	struct properties *config;

a248 1
	struct in_addr_range *ip4_allow;
d251 1
a251 6
	    initialized:1,
	    ctrl_in_pktdump:1,
	    ctrl_out_pktdump:1,
	    data_in_pktdump:1,
	    data_out_pktdump:1,
	    phy_label_with_ifname:1;
d259 1
a259 1
#define	PPTP_CTRL_LISTENER_LABEL(ctrl)	\
d261 5
a265 1
	    (ctrl)->listener_index))->phy_label
a271 1
	char		phy_label[16];
d337 1
a337 1
int  pptpd_add_listener(pptpd *, int, const char *, struct sockaddr *);
d354 1
a354 11
int        pptpd_reload(pptpd *, struct properties *, const char *, int);

/* config_helper  */
const char   *pptpd_config_str (pptpd *, const char *);
int          pptpd_config_int (pptpd *, const char *, int);
int          pptpd_config_str_equal (pptpd *, const char *, const char *, int);
int          pptpd_config_str_equali (pptpd *, const char *, const char *, int);
const char   *pptp_ctrl_config_str (pptp_ctrl *, const char *);
int          pptp_ctrl_config_int (pptp_ctrl *, const char *, int);
int          pptp_ctrl_config_str_equal (pptp_ctrl *, const char *, const char *, int);
int          pptp_ctrl_config_str_equali (pptp_ctrl *, const char *, const char *, int);
@


1.6
log
@Added "provision for rewound PPP frames" that allows receiving
reorder packets to pass to the upper layer without reorder.  It
will improve performance (throughput or loss rate) for PPTP or
L2TP(/IPesc) on networks that latency is unstable such as mobile
network.

As our test environment (bandwidth: 6Mbps, latency: 50ms for 97% of
traffic and 52ms for rest of traffic), throughput has changed from
0.76MB to 2.17MB on file upload by PPTP connected Windows Vista
ftp.exe.

Developed by UMEZAWA Takeshi at IIJ.

ok jmatthew@@
tested jmatthew@@ and myself.
@
text
@d1 1
a1 1
/* $OpenBSD: pptp.h,v 1.5 2011/01/20 23:12:33 jasper Exp $	*/
@


1.5
log
@- tyop, recieve -> receive

ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: pptp.h,v 1.4 2010/07/02 21:20:57 yasuoka Exp $	*/
d183 5
a187 5
/* PPTP_CALL_NMAX_INSEQ specifies N packets was backwarded,
 * when sequence# backwarded */
#ifndef	PPTP_CALL_NMAX_INSEQ
#define	PPTP_CALL_NMAX_INSEQ	64
#endif
@


1.4
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: pptp.h,v 1.3 2010/07/01 03:38:17 yasuoka Exp $	*/
d303 1
a303 1
	int		ifidx; /* recieve interface index */
d313 2
a314 2
	uint32_t	rcv_nxt;	/* recieved sequence # */
	uint32_t	rcv_acked;	/* latest acked recieved sequence # */
@


1.3
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
a2 1
/*	$OpenBSD:$	*/
@


1.2
log
@cleanup npppd code.  delete IIJ local ifdef switches and fix warnings.
ok @@dlg
@
text
@d1 1
d30 3
a32 3
/************************************************************************
 * プロトコル上の定数
 ************************************************************************/
d41 2
d44 2
a45 2
/** Start-Control-Connection-Request */
#define	PPTP_CTRL_MES_CODE_SCCRQ		1
d47 2
a48 2
/** Start-Control-Connection-Reply */
#define	PPTP_CTRL_MES_CODE_SCCRP		2
d50 2
a51 2
/** Stop-Control-Connection-Request */
#define	PPTP_CTRL_MES_CODE_StopCCRQ		3
d53 2
a54 2
/** Stop-Control-Connection-Reply */
#define	PPTP_CTRL_MES_CODE_StopCCRP		4
d56 2
a57 2
/** Echo-Request */
#define	PPTP_CTRL_MES_CODE_ECHO_RQ		5
d59 2
a60 2
/** Echo-Reply */
#define	PPTP_CTRL_MES_CODE_ECHO_RP		6
d62 2
a63 2
/** Outgoing-Call-Request */
#define	PPTP_CTRL_MES_CODE_OCRQ			7
d65 2
a66 2
/** Outgoing-Call-Reply */
#define	PPTP_CTRL_MES_CODE_OCRP			8
d68 2
a69 2
/** Incoming-Call-Request */
#define	PPTP_CTRL_MES_CODE_ICRQ			9
d71 2
a72 2
/** Incoming-Call-Reply */
#define	PPTP_CTRL_MES_CODE_ICRP			10
d74 2
a75 2
/** Incoming-Call-Connected */
#define	PPTP_CTRL_MES_CODE_ICCN			11
d77 2
a78 2
/** Call-Clear-Request */
#define	PPTP_CTRL_MES_CODE_CCR			12
d80 2
a81 2
/** Call-Disconnect-Notify */
#define	PPTP_CTRL_MES_CODE_CDN			13
a82 2
/** Set-Link-Info */
#define	PPTP_CTRL_MES_CODE_SLI			15
d84 2
d87 2
a88 2
#define	PPTP_CTRL_FRAMING_ASYNC			1
#define	PPTP_CTRL_FRAMING_SYNC			2
a89 2
#define	PPTP_CTRL_BEARER_ANALOG			1
#define	PPTP_CTRL_BEARER_DIGITAL		2
d91 1
a91 1
/* Start-Control-Connection-Reply の Result Code */
d106 1
a106 1
/* Outgoing-Call-Reply の Result Code */
d115 1
a115 1
/* Echo-Reply の Result Code */
d119 1
a119 1
/* Stop-Control-Connection-Request の Reason */
d124 1
a124 1
/* Stop-Control-Connection-Response の Result */
d133 1
a133 1
/** デフォルトの待ち受け TCP ポート番号 */
d140 4
a143 4
/************************************************************************
 * この実装の定数
 ************************************************************************/
/* pptpd ステータス */
d156 1
a156 1
/** ステートマシン */
d171 2
a173 1
/** 接続スピード。OCRP で通知する値で、現在は 10Mbps で固定 */
d177 1
a178 1
/** OCRP で通知する。初期 Packet Processing Dealy */
d182 2
a184 1
/** シーケンスが戻った場合に何パケットまでを戻ったとみなすか。*/
d188 1
a188 1
/** call のステートマシン */
d194 1
a194 1
/* タイムアウト関連 */
d205 1
a205 1
/** アドレスは最大何個 bind 可能か。*/
d210 1
a210 1
/** PPTPデーモンが停止したかどうかを返します。 */
a214 1
/** PPTPデーモンが停止処理中かどうかを返します。 */
d218 3
a220 4
/************************************************************************
 * 型
 ************************************************************************/
/** PPTP デーモンの型*/
d222 1
a222 1
/** PPTP デーモン待ち受け型 */
d224 2
a225 5
	/** イベントコンテキスト */
	struct event ev_sock;
	/** GREイベントコンテキスト */
	struct event ev_sock_gre;
	/** PPTPD 自身 */
a226 1
	/** インデックス番号 */
d228 4
a231 9
	/** 待ち受けソケット */
	int		sock;
	/** GREソケット */
	int		sock_gre;
	/** 待ち受けアドレス TCP */
	struct sockaddr_in bind_sin;
	/** 待ち受けアドレス GRE */
	struct sockaddr_in bind_sin_gre;
	/** 物理層のラベル */
a234 1
/** PPTP デーモンの型*/
a235 1
	/** インスタンスの Id */
d237 1
a237 3
	/** 待ち受けリスト */
	slist listener;
	/** ステート */
d239 2
a240 4
	/** タイマーイベントコンテキスト */
	struct event ev_timer;
	/** PPTP コントロールのリスト */
	slist  ctrl_list;
a241 1
	/** 設定 */
d244 3
a246 5
	/** 空きコールリスト */
	slist call_free_list;
	/** コールId => Call マップ */
	hash_table *call_id_map;
	/** 接続を許可するIPv4ネットワーク */
d249 1
a249 2
	/** フラグ */
	uint32_t
d262 1
a262 1
/** pptp_ctrl から、リスナーの物理層のラベルを取り出すマクロ */
a266 1
/** PPTP コントロールの型*/
d268 1
a268 3
	/** 親 pptpd */
	pptpd		*pptpd;
	/** リスナー インデックス番号*/
a269 1
	/** インスタンスの Id */
a270 1
	/** ステート */
a271 1
	/** 物理層のラベル */
a273 1
	/** ソケット */
a274 1
	/** 先方のアドレス */
a275 1
	/** 当方のアドレス */
a276 1
	/** イベントコンテキスト */
a277 1
	/** タイマーイベントコンテキスト */
d280 1
a280 3
	/** アイドル状態から ECHO 送信までの秒数。0以下は無効。*/
	int echo_interval;
	/** ECHO のタイムアウト */
d283 1
a283 3
	/** 送信可能かどうか。送信バッファが埋まっていないか */
	int		send_ready;
	/** 受信バッファ */
a284 1
	/** 送信バッファ */
a286 1
	/** コールのリスト */
d289 3
a291 6
	/** 最後にコントロールメッセージを送信した時間 */
	time_t	last_snd_ctrl;	
	/** 最後にコントロールメッセージを受信を送信した時間 */
	time_t	last_rcv_ctrl;	
	/** Echo Request の identifier */
	uint32_t	echo_seq;
d293 1
a293 1
	int16_t		/** I/O イベント処理中。*/
a295 1

a297 1
/** PPTP コールの型 */
d299 1
a299 3
	/** 親コントロール */
	pptp_ctrl	*ctrl;
	/** コールID*/
d302 1
a302 2
	/** 受信インタフェース番号 */
	int		ifidx;
a303 1
	/** ステート */
a305 1
	/** 先方のコールID*/
d309 8
a316 15
	/** 次の確認応答 */
	uint32_t	snd_una;
	/** 次の送信シーケンス番号 */
	uint32_t	snd_nxt;

	/** 受信シーケンス番号 */
	uint32_t	rcv_nxt;
	/** 応答確認した受信シーケンス番号 */
	uint32_t	rcv_acked;

	/** カレントウィンドウサイズ */
	int		winsz;
	/** 最大ウィンドウサイズ */
	int		maxwinsz;
	/** 先方の最大ウィンドウサイズ*/
a319 1

d323 3
a325 3
/************************************************************************
 * 関数プロトタイプ
 ************************************************************************/
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d163 1
a163 1
#define	PPTPD_DEFAULT_VENDOR_NAME		"IIJ"
@

