head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.8
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.6
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.18.0.6
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.31
date	2016.04.16.18.32.29;	author krw;	state Exp;
branches;
next	1.30;
commitid	T9FcpyqLCeKWwhkO;

1.30
date	2016.03.21.00.49.36;	author guenther;	state Exp;
branches;
next	1.29;
commitid	MSxcUg12B9iLaLLL;

1.29
date	2015.12.17.07.56.01;	author tb;	state Exp;
branches;
next	1.28;
commitid	DvSNtn3J92N3xjX7;

1.28
date	2015.12.05.18.43.36;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	z4uV9iYMuGOvIKaj;

1.27
date	2015.06.23.07.07.33;	author yasuoka;	state Exp;
branches;
next	1.26;
commitid	45mIWVXP4uWQjnAD;

1.26
date	2015.06.23.06.59.54;	author yasuoka;	state Exp;
branches;
next	1.25;
commitid	KW9hHW3D8d8LyHVv;

1.25
date	2015.01.19.01.48.59;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	a1BWBASyBgKKetQd;

1.24
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.23;
commitid	2uw1UTO4k6erpWzK;

1.23
date	2014.07.10.13.48.03;	author yasuoka;	state Exp;
branches;
next	1.22;
commitid	yGmGKhUMR3FbcG5k;

1.22
date	2014.05.30.05.06.00;	author yasuoka;	state Exp;
branches;
next	1.21;

1.21
date	2014.03.22.04.32.39;	author yasuoka;	state Exp;
branches;
next	1.20;

1.20
date	2014.03.22.04.19.54;	author yasuoka;	state Exp;
branches;
next	1.19;

1.19
date	2014.03.22.04.18.18;	author yasuoka;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.20.23.32.32;	author yasuoka;	state Exp;
branches;
next	1.17;

1.17
date	2013.04.20.07.00.19;	author yasuoka;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.06.17.03.51;	author giovanni;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.14.10.21.07;	author mpi;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.11.09.28.02;	author giovanni;	state Exp;
branches;
next	1.12;

1.12
date	2012.11.13.17.10.40;	author yasuoka;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches;
next	1.10;

1.10
date	2012.05.08.13.15.12;	author yasuoka;	state Exp;
branches;
next	1.9;

1.9
date	2012.01.18.02.53.56;	author yasuoka;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.20.23.12.33;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.27.00.12.16;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.24.14.50.30;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.31.05.49.51;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.07.49.44;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Change last non-/gnu/ fcntl(x, F_GETFL, 0) strays to fcntl(x, F_GETFL).

No functional change.

ok millert@@
@
text
@/*	$OpenBSD: pptpd.c,v 1.30 2016/03/21 00:49:36 guenther Exp $	*/

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/* $Id: pptpd.c,v 1.30 2016/03/21 00:49:36 guenther Exp $ */

/**@@file
 * This file provides a implementation of PPTP daemon.  Currently it
 * provides functions for PAC (PPTP Access Concentrator) only.
 * $Id: pptpd.c,v 1.30 2016/03/21 00:49:36 guenther Exp $
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_gre.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <stdarg.h>
#include <signal.h>
#include <syslog.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <event.h>
#include <ifaddrs.h>

#ifdef USE_LIBSOCKUTIL
#include <seil/sockfromto.h>
#endif

#include "net_utils.h"
#include "bytebuf.h"
#include "debugutil.h"
#include "hash.h"
#include "slist.h"
#include "addr_range.h"

#include "pptp.h"
#include "pptp_local.h"
#include "privsep.h"
#include "accept.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

static int pptpd_seqno = 0;

#ifdef	PPTPD_DEBUG
#define	PPTPD_ASSERT(x)	ASSERT(x)
#define	PPTPD_DBG(x)	pptpd_log x
#else
#define	PPTPD_ASSERT(x)
#define	PPTPD_DBG(x)
#endif

static void      pptpd_log (pptpd *, int, const char *, ...) __printflike(3,4);
static void      pptpd_close_gre (pptpd *);
static void      pptpd_close_1723 (pptpd *);
static void      pptpd_io_event (int, short, void *);
static void      pptpd_gre_io_event (int, short, void *);
static void      pptpd_gre_input (pptpd_listener *, struct sockaddr *, u_char *, int);
static void      pptp_ctrl_start_by_pptpd (pptpd *, int, int, struct sockaddr *);
static int       pptp_call_cmp (const void *, const void *);
static uint32_t  pptp_call_hash (const void *, int);
static void      pptp_gre_header_string (struct pptp_gre_header *, char *, int);

#define	PPTPD_SHUFFLE_MARK	-1

/* initialize pptp daemon */
int
pptpd_init(pptpd *_this)
{
	int i, m;
	uint16_t call0, call[UINT16_MAX - 1];

	int mib[] = { CTL_NET, PF_INET, IPPROTO_GRE, GRECTL_ALLOW };
	int value;
	size_t size;
	size = sizeof(value);

	if (sysctl(mib, sizeof(mib)/sizeof(mib[0]), &value, &size, NULL, 0) == 0) {
		if(value == 0) {
			pptpd_log(_this, LOG_WARNING, "GRE protocol not allowed");
		}
	}

	memset(_this, 0, sizeof(pptpd));
	_this->id = pptpd_seqno++;

	slist_init(&_this->ctrl_list);
	slist_init(&_this->call_free_list);

	/* randomize call id */
	for (i = 0; i < countof(call) ; i++)
		call[i] = i + 1;
	for (i = countof(call); i > 1; i--) {
		m = arc4random_uniform(i);
		call0 = call[m];
		call[m] = call[i - 1];
		call[i - 1] = call0;
	}

	for (i = 0; i < MINIMUM(PPTP_MAX_CALL, countof(call)); i++)
		slist_add(&_this->call_free_list, (void *)(uintptr_t)call[i]);
	slist_add(&_this->call_free_list, (void *)PPTPD_SHUFFLE_MARK);

	if (_this->call_id_map == NULL)
		_this->call_id_map = hash_create(pptp_call_cmp, pptp_call_hash,
		    0);

	return 0;
}

/* add a listner to pptpd daemon context */
int
pptpd_add_listener(pptpd *_this, int idx, struct pptp_conf *conf,
    struct sockaddr *addr)
{
	int inaddr_any;
	pptpd_listener *plistener, *plstn;

	plistener = NULL;
	if (idx == 0 && slist_length(&_this->listener) > 0) {
		slist_itr_first(&_this->listener);
		while (slist_itr_has_next(&_this->listener)) {
			slist_itr_next(&_this->listener);
			plstn = slist_itr_remove(&_this->listener);
			PPTPD_ASSERT(plstn != NULL);
			PPTPD_ASSERT(plstn->sock == -1);
			PPTPD_ASSERT(plstn->sock_gre == -1);
			free(plstn);
		}
	}
	PPTPD_ASSERT(slist_length(&_this->listener) == idx);
	if (slist_length(&_this->listener) != idx) {
		pptpd_log(_this, LOG_ERR,
		    "Invalid argument error on %s(): idx must be %d but %d",
		    __func__, slist_length(&_this->listener), idx);
		goto fail;
	}
	if ((plistener = calloc(1, sizeof(pptpd_listener))) == NULL) {
		pptpd_log(_this, LOG_ERR, "calloc() failed in %s: %m",
		    __func__);
		goto fail;
	}

	PPTPD_ASSERT(sizeof(plistener->bind_sin) >= addr->sa_len);
	memcpy(&plistener->bind_sin, addr, addr->sa_len);
	memcpy(&plistener->bind_sin_gre, addr, addr->sa_len);

	if (plistener->bind_sin.sin_port == 0)
		plistener->bind_sin.sin_port = htons(PPTPD_DEFAULT_TCP_PORT);

	/* When a raw socket binds both of an INADDR_ANY and specific IP
	 * address sockets, packets will be received by those sockets
	 * simultaneously. To avoid this duplicate receives, not
	 * permit such kind of configuration */
	inaddr_any = 0;
	slist_itr_first(&_this->listener);
	while (slist_itr_has_next(&_this->listener)) {
		plstn = slist_itr_next(&_this->listener);
		if (plstn->bind_sin_gre.sin_addr.s_addr == INADDR_ANY)
			inaddr_any++;
	}
	if (plistener->bind_sin_gre.sin_addr.s_addr == INADDR_ANY)
		inaddr_any++;
	if (inaddr_any > 0 && idx > 0) {
		log_printf(LOG_ERR, "configuration error at pptpd.listener_in: "
		    "combination 0.0.0.0 and other address is not allowed.");
		goto fail;
	}

	plistener->bind_sin_gre.sin_port = 0;
	plistener->sock = -1;
	plistener->sock_gre = -1;
	plistener->self = _this;
	plistener->index = idx;
	plistener->conf = conf;
	strlcpy(plistener->tun_name, conf->name, sizeof(plistener->tun_name));

	if (slist_add(&_this->listener, plistener) == NULL) {
		pptpd_log(_this, LOG_ERR, "slist_add() failed in %s: %m",
		    __func__);
		goto fail;
	}
	return 0;
fail:
	free(plistener);
	return 1;
}

void
pptpd_uninit(pptpd *_this)
{
	pptpd_listener *plstn;

	slist_fini(&_this->ctrl_list);
	slist_fini(&_this->call_free_list);

	slist_itr_first(&_this->listener);
	while (slist_itr_has_next(&_this->listener)) {
		plstn = slist_itr_next(&_this->listener);
		PPTPD_ASSERT(plstn != NULL);
		PPTPD_ASSERT(plstn->sock == -1);
		PPTPD_ASSERT(plstn->sock_gre == -1);
		free(plstn);
	}
	slist_fini(&_this->listener);
	if (_this->call_id_map != NULL)
		hash_free(_this->call_id_map);
	_this->call_id_map = NULL;
}

#define	CALL_ID_KEY(call_id, listener_idx)	\
	((void *)((uintptr_t)(call_id) | (listener_idx) << 16))
#define	CALL_KEY(call)				\
	CALL_ID_KEY((call)->id, (call)->ctrl->listener_index)
int
pptpd_assign_call(pptpd *_this, pptp_call *call)
{
	int shuffle_cnt = 0;
	u_int call_id;

	shuffle_cnt = 0;
	slist_itr_first(&_this->call_free_list);
	while (slist_length(&_this->call_free_list) > 1 &&
	    slist_itr_has_next(&_this->call_free_list)) {
		call_id = (uintptr_t)slist_itr_next(&_this->call_free_list);
		if (call_id == 0)
			break;
		slist_itr_remove(&_this->call_free_list);
		if (call_id == PPTPD_SHUFFLE_MARK) {
			if (shuffle_cnt++ > 0)
				break;
			slist_shuffle(&_this->call_free_list);
			slist_add(&_this->call_free_list,
			    (void *)PPTPD_SHUFFLE_MARK);
			slist_itr_first(&_this->call_free_list);
			continue;
		}
		call->id = call_id;
		hash_insert(_this->call_id_map, CALL_KEY(call), call);

		return 0;
	}
	errno = EBUSY;
	pptpd_log(_this, LOG_ERR, "call request reached limit=%d",
	    PPTP_MAX_CALL);
	return -1;
}

void
pptpd_release_call(pptpd *_this, pptp_call *call)
{
	if (call->id != 0)
		slist_add(&_this->call_free_list, (void *)(uintptr_t)call->id);
	hash_delete(_this->call_id_map, CALL_KEY(call), 0);
	call->id = 0;
}

static int
pptpd_listener_start(pptpd_listener *_this)
{
	int sock, ival, sock_gre;
	struct sockaddr_in bind_sin, bind_sin_gre;
	int wildcardbinding;

	wildcardbinding =
	    (_this->bind_sin.sin_addr.s_addr == INADDR_ANY)?  1 : 0;
	sock = -1;
	sock_gre = -1;
	memcpy(&bind_sin, &_this->bind_sin, sizeof(bind_sin));
	memcpy(&bind_sin_gre, &_this->bind_sin_gre, sizeof(bind_sin_gre));

	if ((sock = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP))
	    < 0) {
		pptpd_log(_this->self, LOG_ERR, "socket() failed at %s(): %m",
		    __func__);
		goto fail;
	}
	ival = 1;
	if(setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &ival, sizeof(ival)) < 0){
		pptpd_log(_this->self, LOG_WARNING,
		    "setsockopt(SO_REUSEPORT) failed at %s(): %m", __func__);
	}
#if defined(IP_STRICT_RCVIF) && defined(USE_STRICT_RCVIF)
	ival = 1;
	if (setsockopt(sock, IPPROTO_IP, IP_STRICT_RCVIF, &ival, sizeof(ival))
	    != 0)
		pptpd_log(_this->self, LOG_WARNING,
		    "%s(): setsockopt(IP_STRICT_RCVIF) failed: %m", __func__);
#endif
	if (bind(sock, (struct sockaddr *)&_this->bind_sin,
	    _this->bind_sin.sin_len) != 0) {
		pptpd_log(_this->self, LOG_ERR,
		    "bind(%s:%u) failed at %s(): %m",
		    inet_ntoa(_this->bind_sin.sin_addr),
		    ntohs(_this->bind_sin.sin_port), __func__);
		goto fail;
	}
	if (listen(sock, PPTP_BACKLOG) != 0) {
		pptpd_log(_this->self, LOG_ERR,
		    "listen(%s:%u) failed at %s(): %m",
		    inet_ntoa(_this->bind_sin.sin_addr),
		    ntohs(_this->bind_sin.sin_port), __func__);
		goto fail;
	}
	pptpd_log(_this->self, LOG_INFO, "Listening %s:%u/tcp (PPTP PAC) [%s]",
	    inet_ntoa(_this->bind_sin.sin_addr),
	    ntohs(_this->bind_sin.sin_port), _this->tun_name);

	/* GRE */
	bind_sin_gre.sin_port = 0;
	if ((sock_gre = priv_socket(AF_INET, SOCK_RAW, IPPROTO_GRE)) < 0) {
		pptpd_log(_this->self, LOG_ERR, "socket() failed at %s(): %m",
		    __func__);
		goto fail;
	}
#if defined(IP_STRICT_RCVIF) && defined(USE_STRICT_RCVIF)
	ival = 1;
	if (setsockopt(sock_gre, IPPROTO_IP, IP_STRICT_RCVIF, &ival,
	    sizeof(ival)) != 0)
		pptpd_log(_this->self, LOG_WARNING,
		    "%s(): setsockopt(IP_STRICT_RCVIF) failed: %m", __func__);
#endif
#ifdef IP_PIPEX
	ival = 1;
	if (setsockopt(sock_gre, IPPROTO_IP, IP_PIPEX, &ival, sizeof(ival))
	    != 0)
		pptpd_log(_this->self, LOG_WARNING,
		    "%s(): setsockopt(IP_PIPEX) failed: %m", __func__);
#endif
	if ((ival = fcntl(sock_gre, F_GETFL)) < 0) {
		pptpd_log(_this->self, LOG_ERR,
		    "fcntl(F_GET_FL) failed at %s(): %m", __func__);
		goto fail;
	} else if (fcntl(sock_gre, F_SETFL, ival | O_NONBLOCK) < 0) {
		pptpd_log(_this->self, LOG_ERR,
		    "fcntl(F_SET_FL) failed at %s(): %m", __func__);
		goto fail;
	}
	if (bind(sock_gre, (struct sockaddr *)&bind_sin_gre,
	    bind_sin_gre.sin_len) != 0) {
		pptpd_log(_this->self, LOG_ERR,
		    "bind(%s:%u) failed at %s(): %m",
		    inet_ntoa(bind_sin_gre.sin_addr),
		    ntohs(bind_sin_gre.sin_port), __func__);
		goto fail;
	}
	if (wildcardbinding) {
#ifdef USE_LIBSOCKUTIL
		if (setsockoptfromto(sock) != 0) {
			pptpd_log(_this->self, LOG_ERR,
			    "setsockoptfromto() failed in %s(): %m", __func__);
			goto fail;
		}
#else
		/* nothing to do */
#endif
	}
	pptpd_log(_this->self, LOG_INFO, "Listening %s:gre (PPTP PAC)",
	    inet_ntoa(bind_sin_gre.sin_addr));

	_this->sock = sock;
	_this->sock_gre = sock_gre;

	if (accept_add(_this->sock, pptpd_io_event, _this) != 0) {
		pptpd_log(_this->self, LOG_ERR,
		    "accept_add() failed in %s(): %m", __func__);
		goto fail;
	}

	event_set(&_this->ev_sock_gre, _this->sock_gre, EV_READ | EV_PERSIST,
	    pptpd_gre_io_event, _this);
	event_add(&_this->ev_sock_gre, NULL);

	return 0;
fail:
	if (sock >= 0)
		close(sock);
	if (sock_gre >= 0)
		close(sock_gre);

	_this->sock = -1;
	_this->sock_gre = -1;

	return 1;
}

int
pptpd_start(pptpd *_this)
{
	int rval = 0;
	pptpd_listener *plistener;

	slist_itr_first(&_this->listener);
	while (slist_itr_has_next(&_this->listener)) {
		plistener = slist_itr_next(&_this->listener);
		PPTPD_ASSERT(plistener != NULL);
		rval |= pptpd_listener_start(plistener);
	}
	if (rval == 0)
		_this->state = PPTPD_STATE_RUNNING;

	return rval;
}

static void
pptpd_listener_close_gre(pptpd_listener *_this)
{
	if (_this->sock_gre >= 0) {
		event_del(&_this->ev_sock_gre);
		close(_this->sock_gre);
		pptpd_log(_this->self, LOG_INFO, "Shutdown %s/gre",
		    inet_ntoa(_this->bind_sin_gre.sin_addr));
	}
	_this->sock_gre = -1;
}

static void
pptpd_close_gre(pptpd *_this)
{
	pptpd_listener *plistener;

	slist_itr_first(&_this->listener);
	while (slist_itr_has_next(&_this->listener)) {
		plistener = slist_itr_next(&_this->listener);
		pptpd_listener_close_gre(plistener);
	}
}

static void
pptpd_listener_close_1723(pptpd_listener *_this)
{
	if (_this->sock >= 0) {
		accept_del(_this->sock);
		close(_this->sock);
		pptpd_log(_this->self, LOG_INFO, "Shutdown %s:%u/tcp",
		    inet_ntoa(_this->bind_sin.sin_addr),
		    ntohs(_this->bind_sin.sin_port));
	}
	_this->sock = -1;
}

static void
pptpd_close_1723(pptpd *_this)
{
	pptpd_listener *plistener;

	slist_itr_first(&_this->listener);
	while (slist_itr_has_next(&_this->listener)) {
		plistener = slist_itr_next(&_this->listener);
		pptpd_listener_close_1723(plistener);
	}
}

void
pptpd_stop_immediatly(pptpd *_this)
{
	pptp_ctrl *ctrl;

	if (event_initialized(&_this->ev_timer))
		evtimer_del(&_this->ev_timer);
	if (_this->state != PPTPD_STATE_STOPPED) {
		/* lock, to avoid multiple call from pptp_ctrl_stop() */
		_this->state = PPTPD_STATE_STOPPED;

		pptpd_close_1723(_this);
		for (slist_itr_first(&_this->ctrl_list);
		    (ctrl = slist_itr_next(&_this->ctrl_list)) != NULL;) {
			pptp_ctrl_stop(ctrl, 0);
		}
		pptpd_close_gre(_this);
		slist_fini(&_this->ctrl_list);
		slist_fini(&_this->call_free_list);
		PPTPD_DBG((_this, LOG_DEBUG, "Stopped"));
	} else {
		PPTPD_DBG((_this, LOG_DEBUG, "(Already) Stopped"));
	}
}

static void
pptpd_stop_timeout(int fd, short event, void *ctx)
{
	pptpd *_this;

	_this = ctx;
	pptpd_stop_immediatly(_this);
}

void
pptpd_stop(pptpd *_this)
{
	int nctrl;
	pptp_ctrl *ctrl;
	struct timeval tv;

	if (event_initialized(&_this->ev_timer))
		evtimer_del(&_this->ev_timer);
	pptpd_close_1723(_this);

	/* XXX: use common procedure with l2tpd_stop */

	if (pptpd_is_stopped(_this))
		return;
	if (pptpd_is_shutting_down(_this)) {
		pptpd_stop_immediatly(_this);
		return;
	}
	_this->state = PPTPD_STATE_SHUTTING_DOWN;
	nctrl = 0;
	for (slist_itr_first(&_this->ctrl_list);
	    (ctrl = slist_itr_next(&_this->ctrl_list)) != NULL;) {
		pptp_ctrl_stop(ctrl, PPTP_CDN_RESULT_ADMIN_SHUTDOWN);
		nctrl++;
	}
	if (nctrl > 0) {
		tv.tv_sec = PPTPD_SHUTDOWN_TIMEOUT;
		tv.tv_usec = 0;

		evtimer_set(&_this->ev_timer, pptpd_stop_timeout, _this);
		evtimer_add(&_this->ev_timer, &tv);

		return;
	}
	pptpd_stop_immediatly(_this);
}

/*
 * PPTP Configuration
 */
int
pptpd_reload(pptpd *_this, struct pptp_confs *pptp_conf)
{
	int			 i;
	struct pptp_conf	*conf;
	pptpd_listener 		*listener;
	struct pptp_listen_addr	*addr;

	if (slist_length(&_this->listener) > 0) {
		/*
		 * TODO: add / remove / restart listener.
		 */
		slist_itr_first(&_this->listener);
		while (slist_itr_has_next(&_this->listener)) {
			listener = slist_itr_next(&_this->listener);
			TAILQ_FOREACH(conf, pptp_conf, entry) {
				if (strcmp(listener->tun_name,
				    conf->name) == 0) {
					listener->conf = conf;
					break;
				}
			}
		}

		return 0;
	}

	i = 0;
	TAILQ_FOREACH(conf, pptp_conf, entry) {
		TAILQ_FOREACH(addr, &conf->listen, entry)
			pptpd_add_listener(_this, i++, conf,
			    (struct sockaddr *)&addr->addr);
	}
	if (pptpd_start(_this) != 0)
		return -1;

	return 0;
}

/*
 * I/O functions
 */
/* I/O event handler of 1723/tcp */
static void
pptpd_io_event(int fd, short evmask, void *ctx)
{
	int newsock;
	const char *reason;
	socklen_t peerlen;
	struct sockaddr_storage peer;
	pptpd *_this;
	pptpd_listener *listener;

	listener = ctx;
	PPTPD_ASSERT(listener != NULL);
	_this = listener->self;
	PPTPD_ASSERT(_this != NULL);

	if ((evmask & EV_READ) != 0) {
		for (;;) { /* accept till EAGAIN occured */
			peerlen = sizeof(peer);
			if ((newsock = accept(listener->sock,
			    (struct sockaddr *)&peer, &peerlen)) < 0) {
				if (errno != EAGAIN && errno == EINTR &&
				    errno != ECONNABORTED) {
					if (errno == EMFILE || errno == ENFILE)
						accept_pause();
					pptpd_log(_this, LOG_ERR,
					    "accept() failed at %s(): %m",
						__func__);
				}
				break;
			}
		/* check peer */
			switch (peer.ss_family) {
			case AF_INET:
				pptp_ctrl_start_by_pptpd(_this, newsock,
				    listener->index, (struct sockaddr *)&peer);
				break;
			default:
				reason = "address family is not supported.";
				break;
			}
		}
	}
}

/* I/O event handeler of GRE */
static void
pptpd_gre_io_event(int fd, short evmask, void *ctx)
{
	int sz;
	u_char pkt[65535];
	socklen_t peerlen;
	struct sockaddr_storage peer;
	pptpd *_this;
	pptpd_listener *listener;

	listener = ctx;
	PPTPD_ASSERT(listener != NULL);
	_this = listener->self;
	PPTPD_ASSERT(_this != NULL);

	if (evmask & EV_READ) {
		for (;;) {
			/* read till bloked */
			peerlen = sizeof(peer);
			if ((sz = recvfrom(listener->sock_gre, pkt, sizeof(pkt),
			    0, (struct sockaddr *)&peer, &peerlen)) == -1) {
				if (errno == EAGAIN || errno == EINTR)
					break;
				pptpd_log(_this, LOG_INFO,
				    "read(GRE) failed: %m");
				pptpd_stop(_this);
				return;
			}
			pptpd_gre_input(listener, (struct sockaddr *)&peer, pkt,
			    sz);
		}
	}
}

/* receive GRE then route to pptp_call */
static void
pptpd_gre_input(pptpd_listener *listener, struct sockaddr *peer, u_char *pkt,
    int lpkt)
{
	int hlen, input_flags;
	uint32_t seq, ack, call_id;
	struct ip *iphdr;
	struct pptp_gre_header *grehdr;
	char hbuf0[NI_MAXHOST], logbuf[512];
	const char *reason;
	pptp_call *call;
	hash_link *hl;
	pptpd *_this;

	seq = 0;
	ack = 0;
	input_flags = 0;
	reason = "No error";
	_this = listener->self;

	PPTPD_ASSERT(peer->sa_family == AF_INET);

	strlcpy(hbuf0, "<unknown>", sizeof(hbuf0));
	if (getnameinfo(peer, peer->sa_len, hbuf0, sizeof(hbuf0), NULL, 0,
	    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
		pptpd_log(_this, LOG_ERR,
		    "getnameinfo() failed at %s(): %m", __func__);
		goto fail;
	}
	if (listener->conf->data_in_pktdump != 0) {
		pptpd_log(_this, LOG_DEBUG, "PPTP Data input packet dump");
		show_hd(debug_get_debugfp(), pkt, lpkt);
	}
	if (peer->sa_family != AF_INET) {
		pptpd_log(_this, LOG_ERR,
		    "Received malformed GRE packet: address family is not "
		    "supported: peer=%s af=%d", hbuf0, peer->sa_family);
		goto fail;
	}

	if (lpkt < sizeof(struct ip)) {
		pptpd_log(_this, LOG_ERR,
		    "Received a short length packet length=%d, from %s", lpkt,
			hbuf0);
		goto fail;
	}
	iphdr = (struct ip *)pkt;

	iphdr->ip_len = ntohs(iphdr->ip_len);
	hlen = iphdr->ip_hl * 4;

	if (iphdr->ip_len > lpkt ||
	    iphdr->ip_len < hlen + sizeof(struct pptp_gre_header)) {
		pptpd_log(_this, LOG_ERR,
		    "Received a broken packet: ip_hl=%d iplen=%d lpkt=%d", hlen,
			iphdr->ip_len, lpkt);
		show_hd(debug_get_debugfp(), pkt, lpkt);
		goto fail;
	}
	pkt += hlen;
	lpkt -= hlen;
	grehdr = (struct pptp_gre_header *)pkt;
	pkt += sizeof(struct pptp_gre_header);
	lpkt -= sizeof(struct pptp_gre_header);

	grehdr->protocol_type = htons(grehdr->protocol_type);
	grehdr->payload_length = htons(grehdr->payload_length);
	grehdr->call_id = htons(grehdr->call_id);

	if (!(grehdr->protocol_type == PPTP_GRE_PROTOCOL_TYPE &&
	    grehdr->C == 0 && grehdr->R == 0 && grehdr->K != 0 &&
	    grehdr->recur == 0 && grehdr->s == 0 && grehdr->flags == 0 &&
	    grehdr->ver == PPTP_GRE_VERSION)) {
		reason = "GRE header is broken";
		goto bad_gre;
	}
	if (grehdr->S != 0) {
		if (lpkt < 2) {
			reason = "No enough space for seq number";
			goto bad_gre;
		}
		input_flags |= PPTP_GRE_PKT_SEQ_PRESENT;
		seq = ntohl(*(uint32_t *)pkt);
		pkt += 4;
		lpkt -= 4;
	}

	if (grehdr->A != 0) {
		if (lpkt < 2) {
			reason = "No enough space for ack number";
			goto bad_gre;
		}
		input_flags |= PPTP_GRE_PKT_ACK_PRESENT;
		ack = ntohl(*(uint32_t *)pkt);
		pkt += 4;
		lpkt -= 4;
	}

	if (grehdr->payload_length > lpkt) {
		reason = "'Payload Length' is mismatch from actual length";
		goto bad_gre;
	}


	/* route to pptp_call */
	call_id = grehdr->call_id;

	hl = hash_lookup(_this->call_id_map, CALL_ID_KEY(call_id, listener->index));
	if (hl == NULL) {
		reason = "Received GRE packet has unknown call_id";
		goto bad_gre;
	}
	call = hl->item;
	pptp_call_gre_input(call, seq, ack, input_flags, pkt, lpkt);

	return;
bad_gre:
	pptp_gre_header_string(grehdr, logbuf, sizeof(logbuf));
	pptpd_log(_this, LOG_INFO,
	    "Received malformed GRE packet: %s: peer=%s sock=%s %s seq=%u: "
	    "ack=%u ifidx=%d", reason, hbuf0, inet_ntoa(iphdr->ip_dst), logbuf,
	    seq, ack, listener->index);
fail:
	return;
}

/* start PPTP control, when new connection is established */
static void
pptp_ctrl_start_by_pptpd(pptpd *_this, int sock, int listener_index,
    struct sockaddr *peer)
{
	pptp_ctrl *ctrl;
	socklen_t  sslen;

	ctrl = NULL;
	if ((ctrl = pptp_ctrl_create()) == NULL)
		goto fail;
	if (pptp_ctrl_init(ctrl) != 0)
		goto fail;

	memset(&ctrl->peer, 0, sizeof(ctrl->peer));
	memcpy(&ctrl->peer, peer, peer->sa_len);
	ctrl->pptpd = _this;
	ctrl->sock = sock;
	ctrl->listener_index = listener_index;

	sslen = sizeof(ctrl->our);
	if (getsockname(ctrl->sock, (struct sockaddr *)&ctrl->our,
	    &sslen) != 0) {
		pptpd_log(_this, LOG_WARNING,
		    "getsockname() failed at %s(): %m", __func__);
		goto fail;
	}

	if (PPTP_CTRL_CONF(ctrl)->echo_interval != 0)
		ctrl->echo_interval = PPTP_CTRL_CONF(ctrl)->echo_interval;
	if (PPTP_CTRL_CONF(ctrl)->echo_timeout != 0)
		ctrl->echo_timeout = PPTP_CTRL_CONF(ctrl)->echo_timeout;

	if (pptp_ctrl_start(ctrl) != 0)
		goto fail;

	slist_add(&_this->ctrl_list, ctrl);

	return;
fail:
	close(sock);
	pptp_ctrl_destroy(ctrl);
	return;
}

void
pptpd_ctrl_finished_notify(pptpd *_this, pptp_ctrl *ctrl)
{
	pptp_ctrl *ctrl1;
	int i, nctrl;

	PPTPD_ASSERT(_this != NULL);
	PPTPD_ASSERT(ctrl != NULL);

	accept_unpause();

	nctrl = 0;
	for (i = 0; i < slist_length(&_this->ctrl_list); i++) {
		ctrl1 = slist_get(&_this->ctrl_list, i);
		if (ctrl1 == ctrl) {
			slist_remove(&_this->ctrl_list, i);
			break;
		}
	}
	pptp_ctrl_destroy(ctrl);

	PPTPD_DBG((_this, LOG_DEBUG, "Remains %d ctrls", nctrl));
	if (pptpd_is_shutting_down(_this) && nctrl == 0)
		pptpd_stop_immediatly(_this);
}

/*
 * utility functions
 */

/* logging with the this PPTP instance */
static void
pptpd_log(pptpd *_this, int prio, const char *fmt, ...)
{
	char logbuf[BUFSIZ];
	va_list ap;

	PPTPD_ASSERT(_this != NULL);
	va_start(ap, fmt);
#ifdef	PPTPD_MULTIPLE
	snprintf(logbuf, sizeof(logbuf), "pptpd id=%u %s", _this->id, fmt);
#else
	snprintf(logbuf, sizeof(logbuf), "pptpd %s", fmt);
#endif
	vlog_printf(prio, logbuf, ap);
	va_end(ap);
}

static int
pptp_call_cmp(const void *a0, const void *b0)
{
	return ((intptr_t)a0 - (intptr_t)b0);
}

static uint32_t
pptp_call_hash(const void *ctx, int size)
{
	return (uintptr_t)ctx % size;
}

/* convert GRE packet header to strings */
static void
pptp_gre_header_string(struct pptp_gre_header *grehdr, char *buf, int lbuf)
{
	snprintf(buf, lbuf,
	    "[%s%s%s%s%s%s] ver=%d "
	    "protocol_type=%04x payload_length=%d call_id=%d",
	    (grehdr->C != 0)? "C" : "", (grehdr->R != 0)? "R" : "",
	    (grehdr->K != 0)? "K" : "", (grehdr->S != 0)? "S" : "",
	    (grehdr->s != 0)? "s" : "", (grehdr->A != 0)? "A" : "", grehdr->ver,
	    grehdr->protocol_type, grehdr->payload_length, grehdr->call_id);
}
@


1.30
log
@Instead of creating a socket with socket() or accept() and then
setting the O_NONBLOCK flag on it with fcntl(F_SETFL) afterwards,
just pass SOCK_NONBLOCK to socket() or accept4() and get it right
to begin with.

ok millert@@ krw@@ beck@@ deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.29 2015/12/17 07:56:01 tb Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.29 2015/12/17 07:56:01 tb Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.29 2015/12/17 07:56:01 tb Exp $
d361 1
a361 1
	if ((ival = fcntl(sock_gre, F_GETFL, 0)) < 0) {
@


1.29
log
@Replace arc4random() % i by arc4random_uniform(i) to avoid modulo bias.
Part of a diff by Matthew Martin, reviewed by deraadt@@ and me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.28 2015/12/05 18:43:36 mmcc Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.28 2015/12/05 18:43:36 mmcc Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.28 2015/12/05 18:43:36 mmcc Exp $
d303 2
a304 1
	if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
a320 9
	if ((ival = fcntl(sock, F_GETFL, 0)) < 0) {
		pptpd_log(_this->self, LOG_ERR,
		    "fcntl(F_GET_FL) failed at %s(): %m", __func__);
		goto fail;
	} else if (fcntl(sock, F_SETFL, ival | O_NONBLOCK) < 0) {
		pptpd_log(_this->self, LOG_ERR,
		    "fcntl(F_SET_FL) failed at %s(): %m", __func__);
		goto fail;
	}
@


1.28
log
@strings.h -> string.h to prevent an implicit declaration. Also remove a
bunch of NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.27 2015/06/23 07:07:33 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.27 2015/06/23 07:07:33 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.27 2015/06/23 07:07:33 yasuoka Exp $
d125 1
a125 1
		m = arc4random() % i;
@


1.27
log
@Fix npppd to check the size of received GRE packets properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.26 2015/06/23 06:59:54 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.26 2015/06/23 06:59:54 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.26 2015/06/23 06:59:54 yasuoka Exp $
d216 1
a216 2
	if (plistener != NULL)
		free(plistener);
@


1.26
log
@Fix the problem when npppd receives a zero length 1701/udp packet.  If
it receives such packets when the errno is not EAGAIN or EINTR, it had
closed all L2TP sessions and stoppped the L2TP server.  Also fix the
receiving GRE packet since it potentially has the same problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.25 2015/01/19 01:48:59 deraadt Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.25 2015/01/19 01:48:59 deraadt Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.25 2015/01/19 01:48:59 deraadt Exp $
d744 1
a744 1
	    iphdr->ip_len < sizeof(struct pptp_gre_header)) {
@


1.25
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.24 2014/10/25 03:23:49 lteo Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.24 2014/10/25 03:23:49 lteo Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.24 2014/10/25 03:23:49 lteo Exp $
d677 2
a678 3
			    0, (struct sockaddr *)&peer, &peerlen)) <= 0) {
				if (sz < 0 &&
				    (errno == EAGAIN || errno == EINTR))
@


1.24
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.23 2014/07/10 13:48:03 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.23 2014/07/10 13:48:03 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.23 2014/07/10 13:48:03 yasuoka Exp $
a35 1
#include <sys/param.h>
d72 2
d131 1
a131 1
	for (i = 0; i < MIN(PPTP_MAX_CALL, countof(call)); i++)
@


1.23
log
@Tweak accept pacing in pptp.  Add handling when accept_add() fails and
add logging when accept() fails in EMFILE or ENFILE.
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.22 2014/05/30 05:06:00 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.22 2014/05/30 05:06:00 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.22 2014/05/30 05:06:00 yasuoka Exp $
a40 1
#include <netinet/in_systm.h>
@


1.22
log
@Use calloc instead of malloc and memset.

from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.21 2014/03/22 04:32:39 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.21 2014/03/22 04:32:39 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.21 2014/03/22 04:32:39 yasuoka Exp $
d404 5
a408 1
	accept_add(_this->sock, pptpd_io_event, _this);
d632 1
a632 3
				if (errno == EMFILE || errno == ENFILE)
					accept_pause();
				else if (errno != EAGAIN && errno != EINTR &&
d634 2
@


1.21
log
@Now tunnel can have multiple listen addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.20 2014/03/22 04:19:54 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.20 2014/03/22 04:19:54 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.20 2014/03/22 04:19:54 yasuoka Exp $
d169 2
a170 2
	if ((plistener = malloc(sizeof(pptpd_listener))) == NULL) {
		pptpd_log(_this, LOG_ERR, "malloc() failed in %s: %m",
a173 1
	memset(plistener, 0, sizeof(pptpd_listener));
@


1.20
log
@Don't stop listening 1723/tcp when accept() is failed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.19 2014/03/22 04:18:18 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.19 2014/03/22 04:18:18 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.19 2014/03/22 04:18:18 yasuoka Exp $
d144 2
a145 1
pptpd_add_listener(pptpd *_this, int idx, struct pptp_conf *conf)
d176 3
a178 4
	PPTPD_ASSERT(sizeof(plistener->bind_sin) >= conf->address.ss_len);
	memcpy(&plistener->bind_sin, &conf->address, conf->address.ss_len);
	memcpy(&plistener->bind_sin_gre, &conf->address,
	    conf->address.ss_len);
d569 4
a572 3
	int              i;
	struct pptp_conf *conf;
	pptpd_listener  *listener;
d594 5
a598 2
	TAILQ_FOREACH(conf, pptp_conf, entry)
		pptpd_add_listener(_this, i++, conf);
@


1.19
log
@Stop output "Stopped" log message of the tunnel protocols.
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.18 2013/04/20 23:32:32 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.18 2013/04/20 23:32:32 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.18 2013/04/20 23:32:32 yasuoka Exp $
a631 2
					pptpd_listener_close_1723(listener);
					pptpd_stop(_this);
@


1.18
log
@Don't use random() because it's not safe.  Use arc4random() instead of
it.  Suggested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.17 2013/04/20 07:00:19 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.17 2013/04/20 07:00:19 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.17 2013/04/20 07:00:19 yasuoka Exp $
d510 1
a510 1
		pptpd_log(_this, LOG_NOTICE, "Stopped");
@


1.17
log
@PPPoE server was broken since last configuration rework.  Calling
pppoed_init() was accidentally deleted. Revert it in npppd_init() and
rearrange l2tpd_init() and pptpd_init() to the same place.

ok todd
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.16 2013/04/06 17:03:51 giovanni Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.16 2013/04/06 17:03:51 giovanni Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.16 2013/04/06 17:03:51 giovanni Exp $
d125 1
a125 1
		m = random() % i;
@


1.16
log
@
Turn an error into a warning to be able to start l2tp tunnels even if
gre is not allowed.
ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.15 2013/03/14 10:21:07 mpi Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.15 2013/03/14 10:21:07 mpi Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.15 2013/03/14 10:21:07 mpi Exp $
a591 2
	if (pptpd_init(_this) != 0)
		return -1;
@


1.15
log
@Remove some faith-related #ifdef'd code that was only used for old IIJ
products and never enabled in our tree.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.14 2013/03/11 17:40:11 deraadt Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.14 2013/03/11 17:40:11 deraadt Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.14 2013/03/11 17:40:11 deraadt Exp $
d111 1
a111 2
			pptpd_log(_this, LOG_ERR, "GRE protocol not allowed");
			return 1;
@


1.14
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.13 2013/03/11 09:28:02 giovanni Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.13 2013/03/11 09:28:02 giovanni Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.13 2013/03/11 09:28:02 giovanni Exp $
a297 3
#ifdef NPPPD_FAKEBIND
	extern void set_faith(int, int);
#endif
a315 4
#ifdef NPPPD_FAKEBIND
	if (!wildcardbinding)
		set_faith(sock, 1);
#endif
a346 4
#ifdef NPPPD_FAKEBIND
	if (!wildcardbinding)
		set_faith(sock, 0);
#endif
a357 4
#ifdef NPPPD_FAKEBIND
	if (!wildcardbinding)
		set_faith(sock_gre, 1);
#endif
a388 4
#ifdef NPPPD_FAKEBIND
	if (!wildcardbinding)
		set_faith(sock_gre, 0);
#endif
@


1.13
log
@
do not start npppd if a pptp tunnel is configured but the gre protocol is not
enabled.
ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.12 2012/11/13 17:10:40 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.12 2012/11/13 17:10:40 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.12 2012/11/13 17:10:40 yasuoka Exp $
d649 2
a650 1
				else if (errno != EAGAIN && errno != EINTR) {
@


1.12
log
@Add accept.c from ldpd and use it to handle file descriptor exhaustion
in accept() case.

"go for it" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.11 2012/09/18 13:14:08 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.11 2012/09/18 13:14:08 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.11 2012/09/18 13:14:08 yasuoka Exp $
d38 1
d43 1
a54 1
#include <string.h>
d103 12
@


1.11
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.10 2012/05/08 13:15:12 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.10 2012/05/08 13:15:12 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.10 2012/05/08 13:15:12 yasuoka Exp $
d71 1
d412 1
a412 3
	event_set(&_this->ev_sock, _this->sock, EV_READ | EV_PERSIST,
	    pptpd_io_event, _this);
	event_add(&_this->ev_sock, NULL);
d477 1
a477 1
		event_del(&_this->ev_sock);
d634 3
a636 10
				switch (errno) {
				case EAGAIN:
				case EINTR:
					break;
				case ECONNABORTED:
					pptpd_log(_this, LOG_WARNING,
					    "accept() failed at %s(): %m",
					    __func__);
					break;
				default:
d875 2
@


1.10
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pptpd.c,v 1.9 2012/01/18 02:53:56 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.9 2012/01/18 02:53:56 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.9 2012/01/18 02:53:56 yasuoka Exp $
a66 2
#include "properties.h"
#include "config_helper.h"
a99 1
	struct sockaddr_in sin0;
a104 11
	slist_init(&_this->listener);
	memset(&sin0, 0, sizeof(sin0));
	sin0.sin_len = sizeof(sin0);
	sin0.sin_family = AF_INET;
	if (pptpd_add_listener(_this, 0, PPTPD_DEFAULT_LAYER2_LABEL,
	    (struct sockaddr *)&sin0) != 0) {
		return 1;
	}

	_this->ip4_allow = NULL;

d131 1
a131 2
pptpd_add_listener(pptpd *_this, int idx, const char *label,
    struct sockaddr *bindaddr)
d162 4
a165 3
	PPTPD_ASSERT(sizeof(plistener->bind_sin) >= bindaddr->sa_len);
	memcpy(&plistener->bind_sin, bindaddr, bindaddr->sa_len);
	memcpy(&plistener->bind_sin_gre, bindaddr, bindaddr->sa_len);
d194 2
a195 1
	strlcpy(plistener->phy_label, label, sizeof(plistener->phy_label));
d226 1
a226 1
	if (_this->call_id_map != NULL) {
a227 3
	}
	if (_this->ip4_allow != NULL)
		in_addr_range_list_remove_all(&_this->ip4_allow);
a228 1
	_this->config = NULL;
a294 3
	if (_this->phy_label[0] == '\0')
		strlcpy(_this->phy_label, PPTPD_DEFAULT_LAYER2_LABEL,
		    sizeof(_this->phy_label));
d346 1
a346 1
	    ntohs(_this->bind_sin.sin_port), _this->phy_label);
a573 6
#define	CFG_KEY(p, s)	config_key_prefix((p), (s))
#define	VAL_SEP		" \t\r\n"

CONFIG_FUNCTIONS(pptpd_config, pptpd, config);
PREFIXED_CONFIG_FUNCTIONS(pptp_ctrl_config, pptp_ctrl, pptpd->config,
    phy_label);
d575 1
a575 2
pptpd_reload(pptpd *_this, struct properties *config, const char *name,
    int default_enabled)
d577 15
a591 102
	int i, do_start, aierr;
	const char *val;
	char *tok, *cp, buf[PPTPD_CONFIG_BUFSIZ], *label;
	struct addrinfo *ai;

	ASSERT(_this != NULL);
	ASSERT(config != NULL);

	_this->config = config;
	do_start = 0;
	if (pptpd_config_str_equal(_this, CFG_KEY(name, "enabled"), "true",
	    default_enabled)) {
		/* avoid false-true flap */
		if (pptpd_is_shutting_down(_this))
			pptpd_stop_immediatly(_this);
		if (pptpd_is_stopped(_this))
			do_start = 1;
	} else {
		if (!pptpd_is_stopped(_this))
			pptpd_stop(_this);
		return 0;
	}
	if (do_start && pptpd_init(_this) != 0)
		return 1;
	/* set again as pptpd_init will reset it */
	_this->config = config;

	_this->ctrl_in_pktdump = pptpd_config_str_equal(_this,
	    "log.pptp.ctrl.in.pktdump", "true", 0);
	_this->data_in_pktdump = pptpd_config_str_equal(_this,
	    "log.pptp.data.in.pktdump", "true", 0);
	_this->ctrl_out_pktdump = pptpd_config_str_equal(_this,
	    "log.pptp.ctrl.out.pktdump", "true", 0);
	_this->data_out_pktdump = pptpd_config_str_equal(_this,
	    "log.pptp.data.out.pktdump", "true", 0);
	_this->phy_label_with_ifname = pptpd_config_str_equal(_this,
	    CFG_KEY(name, "label_with_ifname"), "true", 0);

	/* parse ip4_allow */
	in_addr_range_list_remove_all(&_this->ip4_allow);
	val = pptpd_config_str(_this, CFG_KEY(name, "ip4_allow"));
	if (val != NULL) {
		if (strlen(val) >= sizeof(buf)) {
			log_printf(LOG_ERR, "configuration error at "
			    "%s: too long", CFG_KEY(name, "ip4_allow"));
			return 1;
		}
		strlcpy(buf, val, sizeof(buf));
		for (cp = buf; (tok = strsep(&cp, VAL_SEP)) != NULL;) {
			if (*tok == '\0')
				continue;
			if (in_addr_range_list_add(&_this->ip4_allow, tok)
			    != 0) {
				pptpd_log(_this, LOG_ERR,
				    "configuration error at %s: %s",
				    CFG_KEY(name, "ip4_allow"), tok);
				return 1;
			}
		}
	}

	if (do_start) {
		/* in the case of 1) cold-booted and 2) pptpd.enable
		 * toggled "false" to "true" do this, because we can
		 * assume that all pptpd listner are initialized. */

		val = pptpd_config_str(_this, CFG_KEY(name, "listener_in"));
		if (val != NULL) {
			if (strlen(val) >= sizeof(buf)) {
				pptpd_log(_this, LOG_ERR,
				    "configuration error at "
				    "%s: too long", CFG_KEY(name, "listener"));
				return 1;
			}
			strlcpy(buf, val, sizeof(buf));

			label = NULL;
			/* it can accept multple velues with tab/space
			 * separation */
			for (i = 0, cp = buf;
			    (tok = strsep(&cp, VAL_SEP)) != NULL;) {
				if (*tok == '\0')
					continue;
				if (label == NULL) {
					label = tok;
					continue;
				}
				if ((aierr = addrport_parse(tok, IPPROTO_TCP,
				    &ai)) != 0) {
					pptpd_log(_this, LOG_ERR,
					    "configuration error at "
					    "%s: %s: %s",
					    CFG_KEY(name, "listener_in"), tok,
					    gai_strerror(aierr));
					return 1;
				}
				PPTPD_ASSERT(ai != NULL &&
				    ai->ai_family == AF_INET);
				if (pptpd_add_listener(_this, i, label,
				    ai->ai_addr) != 0) {
					freeaddrinfo(ai);
					label = NULL;
a593 9
				freeaddrinfo(ai);
				label = NULL;
				i++;
			}
			if (label != NULL) {
				pptpd_log(_this, LOG_ERR,
				    "configuration error at %s: %s",
				    CFG_KEY(name, "listner_in"), label);
				return 1;
d596 2
a597 2
		if (pptpd_start(_this) != 0)
			return 1;
d600 8
a613 15
static void
pptpd_log_access_deny(pptpd *_this, const char *reason, struct sockaddr *peer)
{
	char hostbuf[NI_MAXHOST], servbuf[NI_MAXSERV];

	if (getnameinfo(peer, peer->sa_len, hostbuf, sizeof(hostbuf),
	    servbuf, sizeof(servbuf), NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
		pptpd_log(_this, LOG_ERR, "getnameinfo() failed at %s(): %m",
		    __func__);
		return;
	}
	pptpd_log(_this, LOG_ALERT, "denied a connection from %s:%s/tcp: %s",
	    hostbuf, servbuf, reason);
}

d656 3
a658 7
				if (!in_addr_range_list_includes(
				    &_this->ip4_allow,
				    &((struct sockaddr_in *)&peer)->sin_addr)) {
					reason = "not allowed by acl.";
					break;
				}
				goto accept;
a662 10
		/* not permitted */
			pptpd_log_access_deny(_this, reason,
			    (struct sockaddr *)&peer);
			close(newsock);
			continue;
			/* NOTREACHED */
accept:
		/* permitted, can accepted */
			pptp_ctrl_start_by_pptpd(_this, newsock,
			    listener->index, (struct sockaddr *)&peer);
d733 1
a733 1
	if (_this->data_in_pktdump != 0) {
a834 1
	int ival;
d836 1
a836 2
	socklen_t sslen;
	char ifname[IF_NAMESIZE], msgbuf[128];
d858 4
a861 32
	/* change with interface name, ex) "L2TP%em0.mru" */
	if (_this->phy_label_with_ifname != 0) {
		if (get_ifname_by_sockaddr((struct sockaddr *)&ctrl->our,
		    ifname) == NULL) {
			pptpd_log_access_deny(_this,
			    "could not get interface informations", peer);
			goto fail;
		}
		if (pptpd_config_str_equal(_this,
		    config_key_prefix("pptpd.interface", ifname), "accept", 0)){
			snprintf(ctrl->phy_label, sizeof(ctrl->phy_label),
			    "%s%%%s", PPTP_CTRL_LISTENER_LABEL(ctrl), ifname);
		} else if (pptpd_config_str_equal(_this,
		    config_key_prefix("pptpd.interface", "any"), "accept", 0)){
			snprintf(ctrl->phy_label, sizeof(ctrl->phy_label),
			    "%s", PPTP_CTRL_LISTENER_LABEL(ctrl));
		} else {
			/* the interface is not permitted */
			snprintf(msgbuf, sizeof(msgbuf),
			    "'%s' is not allowed by config.", ifname);
			pptpd_log_access_deny(_this, msgbuf, peer);
			goto fail;
		}
	} else
		strlcpy(ctrl->phy_label, PPTP_CTRL_LISTENER_LABEL(ctrl),
		    sizeof(ctrl->phy_label));

	if ((ival = pptp_ctrl_config_int(ctrl, "pptp.echo_interval", 0)) != 0)
		ctrl->echo_interval = ival;

	if ((ival = pptp_ctrl_config_int(ctrl, "pptp.echo_timeout", 0)) != 0)
		ctrl->echo_timeout = ival;
@


1.9
log
@Fix compiler warnings and some styles.

ok sebastia sthen
@
text
@d1 1
a1 1
/* $OpenBSD: pptpd.c,v 1.8 2011/01/20 23:12:33 jasper Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.8 2011/01/20 23:12:33 jasper Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.8 2011/01/20 23:12:33 jasper Exp $
d1086 1
a1086 1
#ifdef	PPTPD_MULITPLE
@


1.8
log
@- tyop, recieve -> receive

ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: pptpd.c,v 1.7 2010/09/27 00:12:16 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.7 2010/09/27 00:12:16 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.7 2010/09/27 00:12:16 yasuoka Exp $
d248 4
a251 4
#define	CALL_MAP_KEY(call)	\
	(void *)(call->id | (call->ctrl->listener_index << 16))
#define	CALL_ID(item)	((uint32_t)item & 0xffff)

d255 2
a256 1
	int shuffle_cnt = 0, call_id;
d262 1
a262 1
		call_id = (int)slist_itr_next(&_this->call_free_list);
d276 1
a276 1
		hash_insert(_this->call_id_map, CALL_MAP_KEY(call), call);
d290 2
a291 2
		slist_add(&_this->call_free_list, (void *)call->id);
	hash_delete(_this->call_id_map, CALL_MAP_KEY(call), 0);
d955 1
a955 2
	hl = hash_lookup(_this->call_id_map,
	    (void *)(call_id | (listener->index << 16)));
d1098 1
a1098 1
	return ((uint32_t)a0 - (uint32_t)b0);
d1104 1
a1104 1
	return (uint32_t)ctx % size;
@


1.7
log
@IP_PIPEX mistakenly was applied to the 1723/tcp socket.  Apply the option
to the gre socket.
@
text
@d1 1
a1 1
/* $OpenBSD: pptpd.c,v 1.6 2010/09/24 14:50:30 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.6 2010/09/24 14:50:30 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.6 2010/09/24 14:50:30 yasuoka Exp $
d185 1
a185 1
	 * address sockets, packets will be recieved by those sockets
d846 1
a846 1
/* recieve GRE then route to pptp_call */
@


1.6
log
@Add support pipex for L2TP call and L2TP on IPv6.
- pipex requires unique session-id in protocol, so session-id
  generation algorithm has been changed.
- change to fit the new PIPEX ioctl.
ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: pptpd.c,v 1.5 2010/07/02 21:20:57 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.5 2010/07/02 21:20:57 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.5 2010/07/02 21:20:57 yasuoka Exp $
a334 6
#ifdef IP_PIPEX
	ival = 1;
	if (setsockopt(sock, IPPROTO_IP, IP_PIPEX, &ival, sizeof(ival)) != 0)
		pptpd_log(_this->self, LOG_WARNING,
		    "%s(): setsockopt(IP_PIPEX) failed: %m", __func__);
#endif
d384 7
@


1.5
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: pptpd.c,v 1.4 2010/07/01 03:38:17 yasuoka Exp $	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.4 2010/07/01 03:38:17 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.4 2010/07/01 03:38:17 yasuoka Exp $
d334 6
@


1.4
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 2
a2 1
/*	$OpenBSD:$	*/
d28 1
a28 1
/* $Id: pptpd.c,v 1.3 2010/01/31 05:49:51 yasuoka Exp $ */
d33 1
a33 1
 * $Id: pptpd.c,v 1.2 2010-01-13 07:49:44 yasuoka Exp $
d112 1
a112 1
	if (pptpd_add_listener(_this, 0, PPTPD_DEFAULT_LAYER2_LABEL, 
d184 2
a185 2
	/* When a raw socket binds both of an INADDR_ANY and specific IP 
	 * address sockets, packets will be recieved by those sockets 
d606 1
a606 1
	if (pptpd_config_str_equal(_this, CFG_KEY(name, "enabled"), "true", 
d609 1
a609 1
		if (pptpd_is_shutting_down(_this)) 
d673 2
a674 2
			/* it can accept multple velues with tab/space 
			 * separation */ 
d688 1
a688 1
					    CFG_KEY(name, "listener_in"), tok, 
d1005 1
a1005 1
		if (pptpd_config_str_equal(_this, 
d1009 1
a1009 1
		} else if (pptpd_config_str_equal(_this, 
d1020 1
a1020 1
	} else 
@


1.3
log
@privilege separation of npppd.

- Drop privilege after daemon initializing.
- Some system calls that requires root privileges were replaced to
  wrapper functions that communicate with a separated privileged
  process via IPC.  And the privileged process checks whether the
  operations are acceptable.
@
text
@d1 1
d27 2
a28 1
/* $Id: pptpd.c,v 1.2 2010/01/13 07:49:44 yasuoka Exp $ */
d30 3
a32 2
 * PPTPデーモンの実装。現在は PAC(PPTP Access Concentrator) としての実装
 * のみです。
d96 1
a96 1
/** PPTPデーモンを初期化します */
d121 1
a121 1
	/* Call-ID シャッフル */
d130 1
a130 1
	/* 必要個だけを slist に */
a132 1
	/* 末尾に SHUFFLE_MARK。次回は slist_shuffle で shuflle される */
d142 1
a142 7
/**
 * {@@link ::pptpd PPTPデーモン}に{@@link ::pptpd_listener リスナ}を追加します。
 * @@param	_this	{@@link ::pptpd PPTPデーモン}
 * @@param	idx	リスナのインデックス
 * @@param	label	物理層としてのラベル。"PPTP" など
 * @@param	bindaddr	待ち受けるアドレス
 */
d167 1
a167 1
		goto reigai;
d172 1
a172 1
		goto reigai;
a179 1
	/* ポート番号が省略された場合は、デフォルト (1723/tcp)を使う */
d183 4
a186 6
	/*
	 * raw ソケットで、INADDR_ANY と明示的な IP アドレス指定したソケット両
	 * 方を bind した場合、パケットは両方のソケットで受信される。この状態が
	 * 発生すると、パケットが重複して受信したように見えてしまうため、このよ
	 * うな設定は許さないこととした。
	 */
d199 1
a199 1
		goto reigai;
d212 1
a212 1
		goto reigai;
d215 1
a215 1
reigai:
a238 1
		// アイテムの削除?
a250 1
/** PPTPを割り当てます */
a283 1
/** PPTPを解放します。*/
a312 1
	// 1723/tcp
d316 1
a316 1
		goto reigai;
d337 1
a337 1
		goto reigai;
d341 1
a341 1
		goto reigai;
d349 1
a349 1
		goto reigai;
d356 1
a356 1
		goto reigai;
d371 1
a371 1
		goto reigai;
d387 1
a387 1
		goto reigai;
d391 1
a391 1
		goto reigai;
d399 1
a399 1
		goto reigai;
d410 1
a410 1
			goto reigai;
d431 1
a431 1
reigai:
d442 1
a442 1
/** PPTPデーモンを開始します */
a472 1
/** GREの待ち受けソケットを close します */
a484 1
/** 1723/tcp の待ち受けソケットを close します */
d497 1
a497 1
/** 1723/tcp の待ち受けソケットを close します */
a509 1
/** PPTPデーモンを本当に終了します。**/
d518 1
a518 4
		/*
		 * pptp_ctrl_stop を呼び出すと、この関数が再度呼ばれる可能
		 * 性がある。このため、このstate 変更は重要。
		 */
a543 1
/** PPTPデーモンを終了します */
d554 2
a555 1
	/* このあたりの動作は l2tpd_stop とあわせるべき */
a570 1
		// タイマーセット
d582 3
a584 3
/***********************************************************************
 * 設定関連
 ***********************************************************************/
d603 1
a603 1
	_this->config = config;	/* 現在は copy しなくて大丈夫 */
d607 1
a607 1
		// false にした直後に true にされるかもしれない。
d619 1
a619 1
	// pptpd_init でリセットされてしまうので。
d633 1
a633 1
	// ip4_allow をパース
d657 4
a660 6
		/*
		 * 起動直後と、pptpd.enable が false -> true に変更された
		 * 場合に、do_start。すべてのリスナーが、初期化された状態を
		 * 仮定できる
		 */
		// pptpd.listener_in の読み込む
d672 2
a673 1
			// タブ、スペース区切りで、複数指定可能
d717 3
a719 3
/***********************************************************************
 * I/O関連
 ***********************************************************************/
d735 1
a735 1
/** 1723/tcp の IOイベントハンドラ */
d752 1
a752 1
		for (;;) {	// EAGAIN まで 連続して accept
d774 1
a774 1
		// 送信元チェック
d788 1
a788 1
		// 許可されていない
d793 1
a793 1
			// NOTREACHED 
d795 1
a795 1
		// 許可
d802 1
a802 1
/** GRE の IOイベントハンドラー */
d820 1
a820 1
			// Block するまで読む
d838 1
a838 1
/** GREの受信 → pptp_call に配送 */
d866 1
a866 1
		goto reigai;
d876 1
a876 1
		goto reigai;
d883 1
a883 1
		goto reigai;
a886 2
	// IPヘッダは ntohs 済み NetBSD の場合
#if !defined(__NetBSD__)
a887 1
#endif
d896 1
a896 1
		goto reigai;
d943 1
a943 1
	// pptp_call に配送 
d962 1
a962 1
reigai:
d966 1
a966 1
/** PPTPコントロールを開始します。(新しい接続があれば呼び出される。) */
d978 1
a978 1
		goto reigai;
d980 1
a980 1
		goto reigai;
d993 1
a993 1
		goto reigai;
d995 2
a996 1
	/* "L2TP%em0.mru" などと、インタフェースで設定を変更する場合 */
d1002 1
a1002 1
			goto reigai;
d1013 1
a1013 1
			/* このインタフェースは許可されていない。*/
d1017 1
a1017 1
			goto reigai;
d1030 1
a1030 1
		goto reigai;
d1035 1
a1035 1
reigai:
a1040 1
/** PPTPコントロールが終了後に通知してきます。*/
a1061 1
	// シャットダウン中最後の一人
d1065 5
a1069 4
/***********************************************************************
 * その他、ユーティリティ関数
 ***********************************************************************/
/** このインスタンスに基づいたラベルから始まるログを記録します。 */
d1099 1
a1099 1
/** GREパケットヘッダを文字列として */
@


1.2
log
@cleanup npppd code.  delete IIJ local ifdef switches and fix warnings.
ok @@dlg
@
text
@d26 1
a26 1
/* $Id: pptpd.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $ */
d68 1
d379 1
a379 1
	if ((sock_gre = socket(AF_INET, SOCK_RAW, IPPROTO_GRE)) < 0) {
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d26 1
a26 1
/* $Id: pptpd.c 39106 2010-01-10 21:01:39Z yasuoka $ */
a64 3
#ifdef _SEIL_EXT_
#include "rtev.h"
#endif
a1038 17
#if defined(_SEIL_EXT_) && !defined(USE_LIBSOCKUTIL)
		if (!rtev_ifa_is_primary(ifname,
		    (struct sockaddr *)&ctrl->our)) {
			char hostbuf[NI_MAXHOST];

			getnameinfo((struct sockaddr *)&ctrl->our,
			    ctrl->our.ss_len, hostbuf,
			    sizeof(hostbuf), NULL, 0, NI_NUMERICHOST);
			snprintf(msgbuf, sizeof(msgbuf),
			    "connecting to %s (an alias address of %s)"
			    " is not allowed by this version.",
			    hostbuf, ifname);
			pptpd_log_access_deny(_this, msgbuf, peer);

			goto reigai;
		}
#endif
@

