head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.4
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	NSD_4_1_6:1.1.1.11
	OPENBSD_5_8:1.1.1.10.0.6
	OPENBSD_5_8_BASE:1.1.1.10
	NSD_4_1_3:1.1.1.10
	OPENBSD_5_7:1.1.1.10.0.2
	OPENBSD_5_7_BASE:1.1.1.10
	NSD_4_1_1:1.1.1.10
	NSD_4_1_0:1.1.1.9
	OPENBSD_5_6:1.1.1.8.0.6
	OPENBSD_5_6_BASE:1.1.1.8
	NSD_4_0_3:1.1.1.8
	NSD_4_0_2:1.1.1.8
	OPENBSD_5_5:1.1.1.8.0.4
	OPENBSD_5_5_BASE:1.1.1.8
	NSD_4_0_1:1.1.1.8
	NSD_4_0_0:1.1.1.7
	NSD_3_2_16:1.1.1.6
	OPENBSD_5_4:1.1.1.5.0.4
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.2
	OPENBSD_5_3_BASE:1.1.1.5
	NSD_3_2_15:1.1.1.5
	NSD_3_2_14:1.1.1.4
	NSD_3_2_13:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.2
	OPENBSD_5_2_BASE:1.1.1.4
	NSD_3_2_11:1.1.1.4
	NSD_3_2_10:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.4
	NSD_3_2_9:1.1.1.3
	OPENBSD_5_0:1.1.1.3.0.2
	OPENBSD_5_0_BASE:1.1.1.3
	NSD_3_2_8:1.1.1.3
	OPENBSD_4_9:1.1.1.2.0.4
	OPENBSD_4_9_BASE:1.1.1.2
	NSD_3_2_6:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.2
	OPENBSD_4_8_BASE:1.1.1.2
	NSD_3_2_5:1.1.1.2
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2017.04.15.09.15.45;	author florian;	state Exp;
branches;
next	1.7;
commitid	fXBqT4bSlfjTKAVE;

1.7
date	2017.01.17.06.21.41;	author florian;	state Exp;
branches;
next	1.6;
commitid	6d948iJ1oT7IPB23;

1.6
date	2016.10.24.09.45.45;	author florian;	state Exp;
branches;
next	1.5;
commitid	nkv8hwhJfsWbeUmW;

1.5
date	2016.10.24.09.44.43;	author florian;	state Exp;
branches;
next	1.4;
commitid	g3wASIhTcujU0LFi;

1.4
date	2016.08.31.07.31.20;	author florian;	state Exp;
branches;
next	1.3;
commitid	1gMwFuybgH2l617m;

1.3
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.2;
commitid	Z9jVKJJMPmC3zw2t;

1.2
date	2015.12.11.12.28.49;	author sthen;	state Exp;
branches;
next	1.1;
commitid	e67Hx722TeF4XpDl;

1.1
date	2010.01.15.19.25.01;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.25.01;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.04.15.20.56.59;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.05.21.18.17.19;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.02.18.10.17.43;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.09.03.09.21.36;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.11.26.12.50.29;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.02.04.01.54.09;	author brad;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.09.16.16.54.05;	author brad;	state Exp;
branches;
next	1.1.1.10;
commitid	BWSdZeElrpYSRdME;

1.1.1.10
date	2015.02.03.10.24.34;	author brad;	state Exp;
branches;
next	1.1.1.11;
commitid	yn8l9RVkmdMVYIfl;

1.1.1.11
date	2015.11.05.21.21.05;	author sthen;	state Exp;
branches;
next	;
commitid	RXfGmPAh2IZTjnIf;


desc
@@


1.8
log
@update to 4.1.16rc1
tests & OK sthen

(if there are more changes coming for 4.1.16 release we will just
commit them on top)
@
text
@%{
/*
 * configlexer.lex - lexical analyzer for NSD config file
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved
 *
 * See LICENSE for the license.
 *
 */

#include "config.h"

#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <strings.h>
#ifdef HAVE_GLOB_H
# include <glob.h>
#endif

#include "options.h"
#include "configyyrename.h"
#include "configparser.h"
void c_error(const char *message);

#if 0
#define LEXOUT(s)  printf s /* used ONLY when debugging */
#else
#define LEXOUT(s)
#endif

struct inc_state {
	char* filename;
	int line;
	YY_BUFFER_STATE buffer;
	struct inc_state* next;
};
static struct inc_state* config_include_stack = NULL;
static int inc_depth = 0;
static int inc_prev = 0;
static int num_args = 0;

void init_cfg_parse(void)
{
	config_include_stack = NULL;
	inc_depth = 0;
	inc_prev = 0;
	num_args = 0;
}

static void config_start_include(const char* filename)
{
	FILE *input;
	struct inc_state* s;
	char* nm;
	if(inc_depth++ > 10000000) {
		c_error_msg("too many include files");
		return;
	}
	if(strlen(filename) == 0) {
		c_error_msg("empty include file name");
		return;
	}
	s = (struct inc_state*)malloc(sizeof(*s));
	if(!s) {
		c_error_msg("include %s: malloc failure", filename);
		return;
	}
	nm = strdup(filename);
	if(!nm) {
		c_error_msg("include %s: strdup failure", filename);
		free(s);
		return;
	}
	input = fopen(filename, "r");
	if(!input) {
		c_error_msg("cannot open include file '%s': %s",
			filename, strerror(errno));
		free(s);
		free(nm);
		return;
	}
	LEXOUT(("switch_to_include_file(%s) ", filename));
	s->filename = cfg_parser->filename;
	s->line = cfg_parser->line;
	s->buffer = YY_CURRENT_BUFFER;
	s->next = config_include_stack;
	config_include_stack = s;

	cfg_parser->filename = nm;
	cfg_parser->line = 1;
	yy_switch_to_buffer(yy_create_buffer(input, YY_BUF_SIZE));
}

static void config_start_include_glob(const char* filename)
{
	/* check for wildcards */
#ifdef HAVE_GLOB
	glob_t g;
	size_t i;
	int r, flags;
#endif /* HAVE_GLOB */
	if (cfg_parser->chroot) {
		int l = strlen(cfg_parser->chroot); /* chroot has trailing slash */
		if (strncmp(cfg_parser->chroot, filename, l) != 0) {
			c_error_msg("include file '%s' is not relative to chroot '%s'",
				filename, cfg_parser->chroot);
			return;
		}
		filename += l - 1; /* strip chroot without trailing slash */
	}
#ifdef HAVE_GLOB
	if(!(!strchr(filename, '*') && !strchr(filename, '?') &&
		 !strchr(filename, '[') && !strchr(filename, '{') &&
		 !strchr(filename, '~'))) {
		 flags = 0
#ifdef GLOB_ERR
		 	 | GLOB_ERR
#endif
#ifdef GLOB_NOSORT
			 | GLOB_NOSORT
#endif
#ifdef GLOB_BRACE
			 | GLOB_BRACE
#endif
#ifdef GLOB_TILDE
			 | GLOB_TILDE
#endif
		;
		memset(&g, 0, sizeof(g));
		r = glob(filename, flags, NULL, &g);
		if(r) {
			/* some error */
			globfree(&g);
			if(r == GLOB_NOMATCH)
				return; /* no matches for pattern */
			config_start_include(filename); /* let original deal with it */
			return;
		}
		/* process files found, if any */
		for(i=0; i<(size_t)g.gl_pathc; i++) {
			config_start_include(g.gl_pathv[i]);
		}
		globfree(&g);
		return;
	}
#endif /* HAVE_GLOB */
	config_start_include(filename);
}

static void config_end_include(void)
{
	struct inc_state* s = config_include_stack;
	--inc_depth;
	if(!s) return;
	free(cfg_parser->filename);
	cfg_parser->filename = s->filename;
	cfg_parser->line = s->line;
	yy_delete_buffer(YY_CURRENT_BUFFER);
	yy_switch_to_buffer(s->buffer);
	config_include_stack = s->next;
	free(s);
}

#ifndef yy_set_bol /* compat definition, for flex 2.4.6 */
#define yy_set_bol(at_bol) \
        { \
	        if ( ! yy_current_buffer ) \
	                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	        yy_current_buffer->yy_ch_buf[0] = ((at_bol)?'\n':' '); \
        }
#endif

%}
%option noinput
%option nounput
%{
#ifndef YY_NO_UNPUT
#define YY_NO_UNPUT 1
#endif
#ifndef YY_NO_INPUT
#define YY_NO_INPUT 1
#endif
%}

SPACE   [ \t]
LETTER  [a-zA-Z]
UNQUOTEDLETTER [^\"\n\r \t\\]|\\.
NEWLINE [\r\n]
COMMENT \#
COLON 	\:
ANY     [^\"\n\r\\]|\\.

%x	quotedstring include include_quoted

%%
{SPACE}* 		{ LEXOUT(("SP ")); /* ignore */ }
{SPACE}*{COMMENT}.* 	{ LEXOUT(("comment(%s) ", yytext)); /* ignore */ }
server{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_SERVER;}
name{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_NAME;}
ip-address{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_IP_ADDRESS;}
interface{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_IP_ADDRESS;}
ip-transparent{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_IP_TRANSPARENT;}
ip-freebind{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_IP_FREEBIND;}
debug-mode{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_DEBUG_MODE;}
hide-version{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_HIDE_VERSION;}
ip4-only{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_IP4_ONLY;}
ip6-only{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_IP6_ONLY;}
do-ip4{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_DO_IP4;}
do-ip6{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_DO_IP6;}
database{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_DATABASE;}
identity{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_IDENTITY;}
version{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_VERSION;}
nsid{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_NSID;}
logfile{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_LOGFILE;}
server-count{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_SERVER_COUNT;}
tcp-count{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_TCP_COUNT;}
tcp-query-count{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_TCP_QUERY_COUNT;}
tcp-timeout{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_TCP_TIMEOUT;}
tcp-mss{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_TCP_MSS;}
outgoing-tcp-mss{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_OUTGOING_TCP_MSS;}
ipv4-edns-size{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_IPV4_EDNS_SIZE;}
ipv6-edns-size{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_IPV6_EDNS_SIZE;}
pidfile{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_PIDFILE;}
port{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_PORT;}
reuseport{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_REUSEPORT;}
statistics{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_STATISTICS;}
chroot{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_CHROOT;}
username{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_USERNAME;}
zonesdir{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONESDIR;}
zonelistfile{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONELISTFILE;}
difffile{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_DIFFFILE;}
xfrdfile{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_XFRDFILE;}
xfrdir{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_XFRDIR;}
xfrd-reload-timeout{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_XFRD_RELOAD_TIMEOUT;}
verbosity{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_VERBOSITY;}
zone{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONE;}
zonefile{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONEFILE;}
zonestats{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONESTATS;}
allow-notify{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ALLOW_NOTIFY;}
size-limit-xfr{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_SIZE_LIMIT_XFR;}
request-xfr{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_REQUEST_XFR;}
notify{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_NOTIFY;}
notify-retry{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_NOTIFY_RETRY;}
provide-xfr{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_PROVIDE_XFR;}
outgoing-interface{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_OUTGOING_INTERFACE;}
allow-axfr-fallback{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ALLOW_AXFR_FALLBACK;}
key{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_KEY;}
algorithm{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ALGORITHM;}
secret{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_SECRET;}
pattern{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_PATTERN;}
include-pattern{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_INCLUDEPATTERN;}
remote-control{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_REMOTE_CONTROL;}
control-enable{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_CONTROL_ENABLE;}
control-interface{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_CONTROL_INTERFACE;}
control-port{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_CONTROL_PORT;}
server-key-file{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_SERVER_KEY_FILE;}
server-cert-file{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_SERVER_CERT_FILE;}
control-key-file{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_CONTROL_KEY_FILE;}
control-cert-file{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_CONTROL_CERT_FILE;}
AXFR			{ LEXOUT(("v(%s) ", yytext)); return VAR_AXFR;}
UDP			{ LEXOUT(("v(%s) ", yytext)); return VAR_UDP;}
rrl-size{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_SIZE;}
rrl-ratelimit{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_RATELIMIT;}
rrl-slip{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_SLIP;}
rrl-ipv4-prefix-length{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_IPV4_PREFIX_LENGTH;}
rrl-ipv6-prefix-length{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_IPV6_PREFIX_LENGTH;}
rrl-whitelist-ratelimit{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_WHITELIST_RATELIMIT;}
rrl-whitelist{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_WHITELIST;}
zonefiles-check{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONEFILES_CHECK;}
zonefiles-write{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONEFILES_WRITE;}
log-time-ascii{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_LOG_TIME_ASCII;}
round-robin{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ROUND_ROBIN;}
minimal-responses{COLON} { LEXOUT(("v(%s) ", yytext)); return VAR_MINIMAL_RESPONSES;}
max-refresh-time{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_MAX_REFRESH_TIME;}
min-refresh-time{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_MIN_REFRESH_TIME;}
max-retry-time{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_MAX_RETRY_TIME;}
min-retry-time{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_MIN_RETRY_TIME;}
multi-master-check{COLON}      { LEXOUT(("v(%s) ", yytext)); return VAR_MULTI_MASTER_CHECK;}
{NEWLINE}		{ LEXOUT(("NL\n")); cfg_parser->line++;}

	/* Quoted strings. Strip leading and ending quotes */
\"			{ BEGIN(quotedstring); LEXOUT(("QS ")); }
<quotedstring><<EOF>>   {
        yyerror("EOF inside quoted string");
        BEGIN(INITIAL);
}
<quotedstring>{ANY}*    { LEXOUT(("STR(%s) ", yytext)); yymore(); }
<quotedstring>\n        { cfg_parser->line++; yymore(); }
<quotedstring>\" {
        LEXOUT(("QE "));
        BEGIN(INITIAL);
        yytext[yyleng - 1] = '\0';
	yylval.str = region_strdup(cfg_parser->opt->region, yytext);
        return STRING;
}

	/* include: directive */
include{COLON}		{ LEXOUT(("v(%s) ", yytext)); BEGIN(include); }
<include><<EOF>>	{
        yyerror("EOF inside include directive");
        BEGIN(INITIAL);
}
<include>{SPACE}*	{ LEXOUT(("ISP ")); /* ignore */ }
<include>{NEWLINE}	{ LEXOUT(("NL\n")); cfg_parser->line++;}
<include>\"		{ LEXOUT(("IQS ")); BEGIN(include_quoted); }
<include>{UNQUOTEDLETTER}*	{
	LEXOUT(("Iunquotedstr(%s) ", yytext));
	config_start_include_glob(yytext);
	BEGIN(INITIAL);
}
<include_quoted><<EOF>>	{
        yyerror("EOF inside quoted string");
        BEGIN(INITIAL);
}
<include_quoted>{ANY}*	{ LEXOUT(("ISTR(%s) ", yytext)); yymore(); }
<include_quoted>{NEWLINE}	{ cfg_parser->line++; yymore(); }
<include_quoted>\"	{
	LEXOUT(("IQE "));
	yytext[yyleng - 1] = '\0';
	config_start_include_glob(yytext);
	BEGIN(INITIAL);
}
<INITIAL><<EOF>>	{
	yy_set_bol(1); /* Set beginning of line, so "^" rules match.  */
	if (!config_include_stack) {
		yyterminate();
	} else {
		fclose(yyin);
		config_end_include();
	}
}

{UNQUOTEDLETTER}*	{ LEXOUT(("unquotedstr(%s) ", yytext)); 
			yylval.str = region_strdup(cfg_parser->opt->region, yytext); return STRING; }

%%
@


1.7
log
@Update to nsd 4.1.14
OK sthen@@
@
text
@d274 1
@


1.6
log
@do not ignore -Wsign-compare; requested by deraadt@@
@
text
@a68 9
	if (cfg_parser->chroot) {
		int l = strlen(cfg_parser->chroot); /* chroot has trailing slash */
		if (strncmp(cfg_parser->chroot, filename, l) != 0) {
			c_error_msg("include file '%s' is not relative to chroot '%s'",
				filename, cfg_parser->chroot);
			return;
		}
		filename += l - 1; /* strip chroot without trailing slash */
	}
d97 1
a97 1
	 /* check for wildcards */
d99 15
a113 4
	 glob_t g;
	 size_t i;
	 int r, flags;
	 if(!(!strchr(filename, '*') && !strchr(filename, '?') &&
d146 1
a146 1
	 }
d148 1
a148 1
	 config_start_include(filename);
@


1.5
log
@Update to 4.1.13
Testing millert, brad and myself.
OK millert@@
@
text
@a9 2
/* because flex keeps having sign-unsigned compare problems that are unfixed*/
#pragma GCC diagnostic ignored "-Wsign-compare"
@


1.4
log
@update to 4.1.11
"Working fine here." millert@@
OK dlg, sthen
@
text
@d10 2
d278 1
@


1.3
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@d239 1
d272 4
@


1.2
log
@update to NSD 4.1.7, ok florian@@
@
text
@d202 1
d218 2
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
#include <config.h>
d17 3
a25 2
#define YY_NO_UNPUT

d33 1
a33 1
	const char* filename;
d35 2
d38 12
a49 3
static struct inc_state parse_stack[MAXINCLUDES];
static YY_BUFFER_STATE include_stack[MAXINCLUDES];
static int config_include_stack_ptr = 0;
d54 6
d64 18
a81 2
	if(config_include_stack_ptr >= MAXINCLUDES) {
		c_error_msg("includes nested too deeply, skipped (>%d)", MAXINCLUDES);
d88 2
d93 7
a99 4
	parse_stack[config_include_stack_ptr].filename = cfg_parser->filename;
	parse_stack[config_include_stack_ptr].line = cfg_parser->line;
	include_stack[config_include_stack_ptr] = YY_CURRENT_BUFFER;
	cfg_parser->filename = region_strdup(cfg_parser->opt->region, filename);
d102 45
a146 1
	++config_include_stack_ptr;
d151 6
a156 3
	--config_include_stack_ptr;
	cfg_parser->filename = parse_stack[config_include_stack_ptr].filename;
	cfg_parser->line = parse_stack[config_include_stack_ptr].line;
d158 3
a160 1
	yy_switch_to_buffer(include_stack[config_include_stack_ptr]);
d173 10
d200 2
d206 2
d210 2
d221 1
d226 1
d229 1
d234 1
d245 10
d257 11
d297 1
a297 1
	config_start_include(yytext);
d309 1
a309 1
	config_start_include(yytext);
d314 1
a314 1
	if (config_include_stack_ptr == 0) {
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.5
@
text
@a107 1
nsid{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_NSID;}
@


1.1.1.3
log
@NSD v3.2.8
@
text
@d5 1
a5 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved
@


1.1.1.4
log
@NSD v3.2.11, ok phessler@@
@
text
@d11 1
a11 1
#include "config.h"
a118 1
zone-stats-file{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONESTATSFILE;}
@


1.1.1.5
log
@Update to NSD 3.2.15, ok brad@@ phessler@@ deraadt@@ also tested by okan@@
@
text
@a140 4
rrl-size{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_SIZE;}
rrl-ratelimit{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_RATELIMIT;}
rrl-whitelist-ratelimit{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_WHITELIST_RATELIMIT;}
rrl-whitelist{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_WHITELIST;}
@


1.1.1.6
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@a101 1
ip-transparent{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_IP_TRANSPARENT;}
a142 3
rrl-slip{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_SLIP;}
rrl-ipv4-prefix-length{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_IPV4_PREFIX_LENGTH;}
rrl-ipv6-prefix-length{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_RRL_IPV6_PREFIX_LENGTH;}
@


1.1.1.7
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d5 1
a5 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved
d23 2
a49 9
	if (cfg_parser->chroot) {
		int l = strlen(cfg_parser->chroot); /* chroot has trailing slash */
		if (strncmp(cfg_parser->chroot, filename, l) != 0) {
			c_error_msg("include file '%s' is not relative to chroot '%s'",
				filename, cfg_parser->chroot);
			return;
		}
		filename += l - 1; /* strip chroot without trailing slash */
	}
a84 10
%option noinput
%option nounput
%{
#ifndef YY_NO_UNPUT
#define YY_NO_UNPUT 1
#endif
#ifndef YY_NO_INPUT
#define YY_NO_INPUT 1
#endif
%}
a106 2
do-ip4{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_DO_IP4;}
do-ip6{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_DO_IP6;}
d120 1
a123 1
zonelistfile{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONELISTFILE;}
a125 1
xfrdir{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_XFRDIR;}
a139 10
pattern{COLON}		{ LEXOUT(("v(%s) ", yytext)); return VAR_PATTERN;}
include-pattern{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_INCLUDEPATTERN;}
remote-control{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_REMOTE_CONTROL;}
control-enable{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_CONTROL_ENABLE;}
control-interface{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_CONTROL_INTERFACE;}
control-port{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_CONTROL_PORT;}
server-key-file{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_SERVER_KEY_FILE;}
server-cert-file{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_SERVER_CERT_FILE;}
control-key-file{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_CONTROL_KEY_FILE;}
control-cert-file{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_CONTROL_CERT_FILE;}
a148 1
zonefiles-check{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONEFILES_CHECK;}
@


1.1.1.8
log
@update to NSD 4.0.1, ok sthen@@
@
text
@a118 1
interface{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_IP_ADDRESS;}
@


1.1.1.9
log
@update to NSD 4.1.0, ok sthen@@
@
text
@a16 3
#ifdef HAVE_GLOB_H
# include <glob.h>
#endif
d30 1
a30 1
	char* filename;
a31 2
	YY_BUFFER_STATE buffer;
	struct inc_state* next;
d33 3
a35 12
static struct inc_state* config_include_stack = NULL;
static int inc_depth = 0;
static int inc_prev = 0;
static int num_args = 0;

void init_cfg_parse(void)
{
	config_include_stack = NULL;
	inc_depth = 0;
	inc_prev = 0;
	num_args = 0;
}
a39 6
	struct inc_state* s;
	char* nm;
	if(inc_depth++ > 10000000) {
		c_error_msg("too many include files");
		return;
	}
d44 2
a45 3
	s = (struct inc_state*)malloc(sizeof(*s));
	if(!s) {
		c_error_msg("include %s: malloc failure", filename);
a56 6
	nm = strdup(filename);
	if(!nm) {
		c_error_msg("include %s: strdup failure", filename);
		free(s);
		return;
	}
a60 2
		free(s);
		free(nm);
d64 4
a67 7
	s->filename = cfg_parser->filename;
	s->line = cfg_parser->line;
	s->buffer = YY_CURRENT_BUFFER;
	s->next = config_include_stack;
	config_include_stack = s;

	cfg_parser->filename = nm;
d70 1
a70 45
}

static void config_start_include_glob(const char* filename)
{
	 /* check for wildcards */
#ifdef HAVE_GLOB
	 glob_t g;
	 size_t i;
	 int r, flags;
	 if(!(!strchr(filename, '*') && !strchr(filename, '?') &&
		 !strchr(filename, '[') && !strchr(filename, '{') &&
		 !strchr(filename, '~'))) {
		 flags = 0
#ifdef GLOB_ERR
		 	 | GLOB_ERR
#endif
#ifdef GLOB_NOSORT
			 | GLOB_NOSORT
#endif
#ifdef GLOB_BRACE
			 | GLOB_BRACE
#endif
#ifdef GLOB_TILDE
			 | GLOB_TILDE
#endif
		;
		memset(&g, 0, sizeof(g));
		r = glob(filename, flags, NULL, &g);
		if(r) {
			/* some error */
			globfree(&g);
			if(r == GLOB_NOMATCH)
				return; /* no matches for pattern */
			config_start_include(filename); /* let original deal with it */
			return;
		}
		/* process files found, if any */
		for(i=0; i<(size_t)g.gl_pathc; i++) {
			config_start_include(g.gl_pathv[i]);
		}
		globfree(&g);
		return;
	 }
#endif /* HAVE_GLOB */
	 config_start_include(filename);
d75 3
a77 6
	struct inc_state* s = config_include_stack;
	--inc_depth;
	if(!s) return;
	free(cfg_parser->filename);
	cfg_parser->filename = s->filename;
	cfg_parser->line = s->line;
d79 1
a79 3
	yy_switch_to_buffer(s->buffer);
	config_include_stack = s->next;
	free(s);
a180 3
zonefiles-write{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONEFILES_WRITE;}
log-time-ascii{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_LOG_TIME_ASCII;}
round-robin{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ROUND_ROBIN;}
d210 1
a210 1
	config_start_include_glob(yytext);
d222 1
a222 1
	config_start_include_glob(yytext);
d227 1
a227 1
	if (!config_include_stack) {
@


1.1.1.10
log
@update to NSD 4.1.1, ok sthen@@
@
text
@a231 1
zonestats{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_ZONESTATS;}
@


1.1.1.11
log
@update to NSD 4.1.6, ok millert@@ florian@@
@
text
@a219 1
reuseport{COLON}	{ LEXOUT(("v(%s) ", yytext)); return VAR_REUSEPORT;}
@


