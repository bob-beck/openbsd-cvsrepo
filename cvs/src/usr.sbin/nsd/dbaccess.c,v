head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	NSD_4_1_6:1.1.1.13
	OPENBSD_5_8:1.1.1.13.0.4
	OPENBSD_5_8_BASE:1.1.1.13
	NSD_4_1_3:1.1.1.13
	OPENBSD_5_7:1.1.1.12.0.2
	OPENBSD_5_7_BASE:1.1.1.12
	NSD_4_1_1:1.1.1.12
	NSD_4_1_0:1.1.1.11
	OPENBSD_5_6:1.1.1.10.0.4
	OPENBSD_5_6_BASE:1.1.1.10
	NSD_4_0_3:1.1.1.10
	NSD_4_0_2:1.1.1.9
	OPENBSD_5_5:1.1.1.8.0.4
	OPENBSD_5_5_BASE:1.1.1.8
	NSD_4_0_1:1.1.1.8
	NSD_4_0_0:1.1.1.7
	NSD_3_2_16:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.6
	OPENBSD_5_4_BASE:1.1.1.6
	OPENBSD_5_3:1.1.1.6.0.4
	OPENBSD_5_3_BASE:1.1.1.6
	NSD_3_2_15:1.1.1.6
	NSD_3_2_14:1.1.1.6
	NSD_3_2_13:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.2
	OPENBSD_5_2_BASE:1.1.1.6
	NSD_3_2_11:1.1.1.6
	NSD_3_2_10:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.2
	NSD_3_2_9:1.1.1.5
	OPENBSD_5_0:1.1.1.4.0.2
	OPENBSD_5_0_BASE:1.1.1.4
	NSD_3_2_8:1.1.1.4
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	NSD_3_2_6:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.2
	OPENBSD_4_8_BASE:1.1.1.2
	NSD_3_2_5:1.1.1.2
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.3;
commitid	WmSuN5M3Jbe54113;

1.3
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.2;
commitid	Z9jVKJJMPmC3zw2t;

1.2
date	2015.12.09.00.36.26;	author sthen;	state Exp;
branches;
next	1.1;
commitid	oFaRJS86oPhcC6P7;

1.1
date	2010.01.15.19.25.00;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.25.00;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.04.15.20.56.57;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.08.22.09.21.46;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.05.21.18.17.17;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.01.29.11.15.36;	author jakob;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.11.26.12.50.21;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.02.04.01.54.07;	author brad;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.13.02.00.28;	author brad;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.14.16.01.51;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.09.16.16.54.04;	author brad;	state Exp;
branches;
next	1.1.1.12;
commitid	BWSdZeElrpYSRdME;

1.1.1.12
date	2015.02.03.10.24.32;	author brad;	state Exp;
branches;
next	1.1.1.13;
commitid	yn8l9RVkmdMVYIfl;

1.1.1.13
date	2015.07.17.17.36.01;	author sthen;	state Exp;
branches;
next	;
commitid	Jeq5uGP63ff7nS9K;


desc
@@


1.4
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * dbaccess.c -- access methods for nsd(8) database
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include "config.h"

#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

#include "dns.h"
#include "namedb.h"
#include "util.h"
#include "options.h"
#include "rdata.h"
#include "udb.h"
#include "udbradtree.h"
#include "udbzone.h"
#include "zonec.h"
#include "nsec3.h"
#include "difffile.h"
#include "nsd.h"

static time_t udb_time = 0;
static unsigned long udb_rrsets = 0;
static unsigned long udb_rrset_count = 0;

void
namedb_close(struct namedb* db)
{
	if(db) {
		if(db->udb) {
			udb_base_close(db->udb);
			udb_base_free(db->udb);
			db->udb = NULL;
		}
		zonec_desetup_parser();
		region_destroy(db->region);
	}
}

void
namedb_close_udb(struct namedb* db)
{
	if(db) {
		/* we cannot actually munmap the data, because other
		 * processes still need to access the udb, so cleanup the
		 * udb */
		udb_base_free_keep_mmap(db->udb);
		db->udb = NULL;
	}
}

void
apex_rrset_checks(namedb_type* db, rrset_type* rrset, domain_type* domain)
{
	uint32_t soa_minimum;
	unsigned i;
	zone_type* zone = rrset->zone;
	assert(domain == zone->apex);
	(void)domain;
	if (rrset_rrtype(rrset) == TYPE_SOA) {
		zone->soa_rrset = rrset;

		/* BUG #103 add another soa with a tweaked ttl */
		if(zone->soa_nx_rrset == 0) {
			zone->soa_nx_rrset = region_alloc(db->region,
				sizeof(rrset_type));
			zone->soa_nx_rrset->rr_count = 1;
			zone->soa_nx_rrset->next = 0;
			zone->soa_nx_rrset->zone = zone;
			zone->soa_nx_rrset->rrs = region_alloc(db->region,
				sizeof(rr_type));
		}
		memcpy(zone->soa_nx_rrset->rrs, rrset->rrs, sizeof(rr_type));

		/* check the ttl and MINIMUM value and set accordingly */
		memcpy(&soa_minimum, rdata_atom_data(rrset->rrs->rdatas[6]),
				rdata_atom_size(rrset->rrs->rdatas[6]));
		if (rrset->rrs->ttl > ntohl(soa_minimum)) {
			zone->soa_nx_rrset->rrs[0].ttl = ntohl(soa_minimum);
		}
	} else if (rrset_rrtype(rrset) == TYPE_NS) {
		zone->ns_rrset = rrset;
	} else if (rrset_rrtype(rrset) == TYPE_RRSIG) {
		for (i = 0; i < rrset->rr_count; ++i) {
			if(rr_rrsig_type_covered(&rrset->rrs[i])==TYPE_DNSKEY){
				zone->is_secure = 1;
				break;
			}
		}
	}
}

/** read rr */
static void
read_rr(namedb_type* db, rr_type* rr, udb_ptr* urr, domain_type* domain)
{
	buffer_type buffer;
	ssize_t c;
	assert(udb_ptr_get_type(urr) == udb_chunk_type_rr);
	rr->owner = domain;
	rr->type = RR(urr)->type;
	rr->klass = RR(urr)->klass;
	rr->ttl = RR(urr)->ttl;

	buffer_create_from(&buffer, RR(urr)->wire, RR(urr)->len);
	c = rdata_wireformat_to_rdata_atoms(db->region, db->domains,
		rr->type, RR(urr)->len, &buffer, &rr->rdatas);
	if(c == -1) {
		/* safe on error */
		rr->rdata_count = 0;
		rr->rdatas = NULL;
		return;
	}
	rr->rdata_count = c;
}

/** calculate rr count */
static uint16_t
calculate_rr_count(udb_base* udb, udb_ptr* rrset)
{
	udb_ptr rr;
	uint16_t num = 0;
	udb_ptr_new(&rr, udb, &RRSET(rrset)->rrs);
	while(rr.data) {
		num++;
		udb_ptr_set_rptr(&rr, udb, &RR(&rr)->next);
	}
	udb_ptr_unlink(&rr, udb);
	return num;
}

/** read rrset */
static void
read_rrset(udb_base* udb, namedb_type* db, zone_type* zone,
	domain_type* domain, udb_ptr* urrset)
{
	rrset_type* rrset;
	udb_ptr urr;
	unsigned i;
	assert(udb_ptr_get_type(urrset) == udb_chunk_type_rrset);
	/* if no RRs, do not create anything (robust) */
	if(RRSET(urrset)->rrs.data == 0)
		return;
	rrset = (rrset_type *) region_alloc(db->region, sizeof(rrset_type));
	rrset->zone = zone;
	rrset->rr_count = calculate_rr_count(udb, urrset);
	rrset->rrs = (rr_type *) region_alloc_array(
		db->region, rrset->rr_count, sizeof(rr_type));
	/* add the RRs */
	udb_ptr_new(&urr, udb, &RRSET(urrset)->rrs);
	for(i=0; i<rrset->rr_count; i++) {
		read_rr(db, &rrset->rrs[i], &urr, domain);
		udb_ptr_set_rptr(&urr, udb, &RR(&urr)->next);
	}
	udb_ptr_unlink(&urr, udb);
	domain_add_rrset(domain, rrset);
	if(domain == zone->apex)
		apex_rrset_checks(db, rrset, domain);
}

/** read one elem from db, of type domain_d */
static void read_node_elem(udb_base* udb, namedb_type* db, 
	region_type* dname_region, zone_type* zone, struct domain_d* d)
{
	const dname_type* dname;
	domain_type* domain;
	udb_ptr urrset;

	dname = dname_make(dname_region, d->name, 0);
	if(!dname) return;
	domain = domain_table_insert(db->domains, dname);
	assert(domain); /* domain_table_insert should always return non-NULL */

	/* add rrsets */
	udb_ptr_init(&urrset, udb);
	udb_ptr_set_rptr(&urrset, udb, &d->rrsets);
	while(urrset.data) {
		read_rrset(udb, db, zone, domain, &urrset);
		udb_ptr_set_rptr(&urrset, udb, &RRSET(&urrset)->next);

		if(++udb_rrsets % ZONEC_PCT_COUNT == 0 && time(NULL) > udb_time + ZONEC_PCT_TIME) {
			udb_time = time(NULL);
			VERBOSITY(1, (LOG_INFO, "read %s %d %%",
				zone->opts->name,
				(int)(udb_rrsets*((unsigned long)100)/udb_rrset_count)));
		}
	}
	region_free_all(dname_region);
	udb_ptr_unlink(&urrset, udb);
}

/** recurse read radix from disk. This radix tree is by domain name, so max of
 * 256 depth, and thus the stack usage is small. */
static void read_zone_recurse(udb_base* udb, namedb_type* db,
	region_type* dname_region, zone_type* zone, struct udb_radnode_d* node)
{
	if(node->elem.data) {
		/* pre-order process of node->elem, for radix tree this is
		 * also in-order processing (identical to order tree_next()) */
		read_node_elem(udb, db, dname_region, zone, (struct domain_d*)
			(udb->base + node->elem.data));
	}
	if(node->lookup.data) {
		uint16_t i;
		struct udb_radarray_d* a = (struct udb_radarray_d*)
			(udb->base + node->lookup.data);
		/* we do not care for what the exact radix key is, we want
		 * to add all of them and the read routine does not need
		 * the radix-key, it has it stored */
		for(i=0; i<a->len; i++) {
			if(a->array[i].node.data) {
				read_zone_recurse(udb, db, dname_region, zone,
					(struct udb_radnode_d*)(udb->base +
						a->array[i].node.data));
			}
		}
	}
}

/** read zone data */
static void
read_zone_data(udb_base* udb, namedb_type* db, region_type* dname_region,
	udb_ptr* z, zone_type* zone)
{
	udb_ptr dtree;
	/* recursively read domains, we only read so ptrs stay valid */
	udb_ptr_new(&dtree, udb, &ZONE(z)->domains);
	if(RADTREE(&dtree)->root.data)
		read_zone_recurse(udb, db, dname_region, zone,
			(struct udb_radnode_d*)
			(udb->base + RADTREE(&dtree)->root.data));
	udb_ptr_unlink(&dtree, udb);
}

/** create a zone */
zone_type*
namedb_zone_create(namedb_type* db, const dname_type* dname,
	struct zone_options* zo)
{
	zone_type* zone = (zone_type *) region_alloc(db->region,
		sizeof(zone_type));
	zone->node = radname_insert(db->zonetree, dname_name(dname),
		dname->name_size, zone);
	assert(zone->node);
	zone->apex = domain_table_insert(db->domains, dname);
	zone->apex->usage++; /* the zone.apex reference */
	zone->apex->is_apex = 1;
	zone->soa_rrset = NULL;
	zone->soa_nx_rrset = NULL;
	zone->ns_rrset = NULL;
#ifdef NSEC3
	zone->nsec3_param = NULL;
	zone->nsec3_last = NULL;
	zone->nsec3tree = NULL;
	zone->hashtree = NULL;
	zone->wchashtree = NULL;
	zone->dshashtree = NULL;
#endif
	zone->opts = zo;
	zone->filename = NULL;
	zone->logstr = NULL;
	zone->mtime.tv_sec = 0;
	zone->mtime.tv_nsec = 0;
	zone->zonestatid = 0;
	zone->is_secure = 0;
	zone->is_changed = 0;
	zone->is_ok = 1;
	return zone;
}

void
namedb_zone_delete(namedb_type* db, zone_type* zone)
{
	/* RRs and UDB and NSEC3 and so on must be already deleted */
	radix_delete(db->zonetree, zone->node);

	/* see if apex can be deleted */
	if(zone->apex) {
		zone->apex->usage --;
		zone->apex->is_apex = 0;
		if(zone->apex->usage == 0) {
			/* delete the apex, possibly */
			domain_table_deldomain(db, zone->apex);
		}
	}

	/* soa_rrset is freed when the SOA was deleted */
	if(zone->soa_nx_rrset) {
		region_recycle(db->region, zone->soa_nx_rrset->rrs,
			sizeof(rr_type));
		region_recycle(db->region, zone->soa_nx_rrset,
			sizeof(rrset_type));
	}
#ifdef NSEC3
	hash_tree_delete(db->region, zone->nsec3tree);
	hash_tree_delete(db->region, zone->hashtree);
	hash_tree_delete(db->region, zone->wchashtree);
	hash_tree_delete(db->region, zone->dshashtree);
#endif
	if(zone->filename)
		region_recycle(db->region, zone->filename,
			strlen(zone->filename)+1);
	if(zone->logstr)
		region_recycle(db->region, zone->logstr,
			strlen(zone->logstr)+1);
	region_recycle(db->region, zone, sizeof(zone_type));
}

#ifdef HAVE_MMAP
/** read a zone */
static void
read_zone(udb_base* udb, namedb_type* db, struct nsd_options* opt,
	region_type* dname_region, udb_ptr* z)
{
	/* construct dname */
	const dname_type* dname = dname_make(dname_region, ZONE(z)->name, 0);
	struct zone_options* zo = dname?zone_options_find(opt, dname):NULL;
	zone_type* zone;
	if(!dname) return;
	if(!zo) {
		/* deleted from the options, remove it from the nsd.db too */
		VERBOSITY(2, (LOG_WARNING, "zone %s is deleted",
			dname_to_string(dname, NULL)));
		udb_zone_delete(udb, z);
		region_free_all(dname_region);
		return;
	}
	assert(udb_ptr_get_type(z) == udb_chunk_type_zone);
	udb_rrsets = 0;
	udb_rrset_count = ZONE(z)->rrset_count;
	zone = namedb_zone_create(db, dname, zo);
	region_free_all(dname_region);
	read_zone_data(udb, db, dname_region, z, zone);
	zone->is_changed = (ZONE(z)->is_changed != 0);
#ifdef NSEC3
	prehash_zone_complete(db, zone);
#endif
}
#endif /* HAVE_MMAP */

#ifdef HAVE_MMAP
/** read zones from nsd.db */
static void
read_zones(udb_base* udb, namedb_type* db, struct nsd_options* opt,
	region_type* dname_region)
{
	udb_ptr ztree, n, z;
	udb_ptr_init(&z, udb);
	udb_ptr_new(&ztree, udb, udb_base_get_userdata(udb));
	udb_radix_first(udb,&ztree,&n);
	udb_time = time(NULL);
	while(n.data) {
		udb_ptr_set_rptr(&z, udb, &RADNODE(&n)->elem);
		udb_radix_next(udb, &n); /* store in case n is deleted */
		read_zone(udb, db, opt, dname_region, &z);
		udb_ptr_zero(&z, udb);
		if(nsd.signal_hint_shutdown) break;
	}
	udb_ptr_unlink(&ztree, udb);
	udb_ptr_unlink(&n, udb);
	udb_ptr_unlink(&z, udb);
}
#endif /* HAVE_MMAP */

#ifdef HAVE_MMAP
/** try to read the udb file or fail */
static int
try_read_udb(namedb_type* db, int fd, const char* filename,
	struct nsd_options* opt)
{
	/*
	 * Temporary region used while loading domain names from the
	 * database.  The region is freed after each time a dname is
	 * read from the database.
	 */
	region_type* dname_region;

	assert(fd != -1);
	if(!(db->udb=udb_base_create_fd(filename, fd, &namedb_walkfunc,
		NULL))) {
		/* fd is closed by failed udb create call */
		VERBOSITY(1, (LOG_WARNING, "can not use %s, "
			"will create anew", filename));
		return 0;
	}
	/* sanity check if can be opened */
	if(udb_base_get_userflags(db->udb) != 0) {
		log_msg(LOG_WARNING, "%s was not closed properly, it might "
			"be corrupted, will create anew", filename);
		udb_base_free(db->udb);
		db->udb = NULL;
		return 0;
	}
	/* read if it can be opened */
	dname_region = region_create(xalloc, free);
	/* this operation does not fail, we end up with
	 * something, even if that is an empty namedb */
	read_zones(db->udb, db, opt, dname_region);
	region_destroy(dname_region);
	return 1;
}
#endif /* HAVE_MMAP */

struct namedb *
namedb_open (const char* filename, struct nsd_options* opt)
{
	namedb_type* db;

	/*
	 * Region used to store the loaded database.  The region is
	 * freed in namedb_close.
	 */
	region_type* db_region;
	int fd;

#ifdef USE_MMAP_ALLOC
	db_region = region_create_custom(mmap_alloc, mmap_free, MMAP_ALLOC_CHUNK_SIZE,
		MMAP_ALLOC_LARGE_OBJECT_SIZE, MMAP_ALLOC_INITIAL_CLEANUP_SIZE, 1);
#else /* !USE_MMAP_ALLOC */
	db_region = region_create_custom(xalloc, free, DEFAULT_CHUNK_SIZE,
		DEFAULT_LARGE_OBJECT_SIZE, DEFAULT_INITIAL_CLEANUP_SIZE, 1);
#endif /* !USE_MMAP_ALLOC */
	db = (namedb_type *) region_alloc(db_region, sizeof(struct namedb));
	db->region = db_region;
	db->domains = domain_table_create(db->region);
	db->zonetree = radix_tree_create(db->region);
	db->diff_skip = 0;
	db->diff_pos = 0;
	zonec_setup_parser(db);

	if (gettimeofday(&(db->diff_timestamp), NULL) != 0) {
		log_msg(LOG_ERR, "unable to load %s: cannot initialize"
				 "timestamp", filename);
		region_destroy(db_region);
		return NULL;
        }

	/* in dbless mode there is no file to read or mmap */
	if(filename == NULL || filename[0] == 0) {
		db->udb = NULL;
		return db;
	}

#ifndef HAVE_MMAP
	/* no mmap() system call, use dbless mode */
	VERBOSITY(1, (LOG_INFO, "no mmap(), ignoring database %s", filename));
	db->udb = NULL;
	(void)fd; (void)opt;
	return db;
#else /* HAVE_MMAP */

	/* attempt to open, if does not exist, create a new one */
	fd = open(filename, O_RDWR);
	if(fd == -1) {
		if(errno != ENOENT) {
			log_msg(LOG_ERR, "%s: %s", filename, strerror(errno));
			region_destroy(db_region);
			return NULL;
		}
	}
	/* attempt to read the file (if it exists) */
	if(fd != -1) {
		if(!try_read_udb(db, fd, filename, opt))
			fd = -1;
	}
	/* attempt to create the file (if necessary or failed read) */
	if(fd == -1) {
		if(!(db->udb=udb_base_create_new(filename, &namedb_walkfunc,
			NULL))) {
			region_destroy(db_region);
			return NULL;
		}
		if(!udb_dns_init_file(db->udb)) {
			region_destroy(db->region);
			return NULL;
		}
	}
	return db;
#endif /* HAVE_MMAP */
}

/** the the file mtime stat (or nonexist or error) */
int
file_get_mtime(const char* file, struct timespec* mtime, int* nonexist)
{
	struct stat s;
	if(stat(file, &s) != 0) {
		mtime->tv_sec = 0;
		mtime->tv_nsec = 0;
		*nonexist = (errno == ENOENT);
		return 0;
	}
	*nonexist = 0;
	mtime->tv_sec = s.st_mtime;
#ifdef HAVE_STRUCT_STAT_ST_MTIMENSEC
	mtime->tv_nsec = s.st_mtimensec;
#elif defined(HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC)
	mtime->tv_nsec = s.st_mtim.tv_nsec;
#else
	mtime->tv_nsec = 0;
#endif
	return 1;
}

void
namedb_read_zonefile(struct nsd* nsd, struct zone* zone, udb_base* taskudb,
	udb_ptr* last_task)
{
	struct timespec mtime;
	int nonexist = 0;
	unsigned int errors;
	const char* fname;
	if(!nsd->db || !zone || !zone->opts || !zone->opts->pattern->zonefile)
		return;
	mtime.tv_sec = 0;
	mtime.tv_nsec = 0;
	fname = config_make_zonefile(zone->opts, nsd);
	if(!file_get_mtime(fname, &mtime, &nonexist)) {
		if(nonexist) {
			VERBOSITY(2, (LOG_INFO, "zonefile %s does not exist",
				fname));
		} else
			log_msg(LOG_ERR, "zonefile %s: %s",
				fname, strerror(errno));
		if(taskudb) task_new_soainfo(taskudb, last_task, zone, 0);
		return;
	} else {
		const char* zone_fname = zone->filename;
		struct timespec zone_mtime = zone->mtime;
		if(nsd->db->udb) {
			zone_fname = udb_zone_get_file_str(nsd->db->udb,
				dname_name(domain_dname(zone->apex)),
				domain_dname(zone->apex)->name_size);
			udb_zone_get_mtime(nsd->db->udb,
				dname_name(domain_dname(zone->apex)),
				domain_dname(zone->apex)->name_size,
				&zone_mtime);
		}
		/* if no zone_fname, then it was acquired in zone transfer,
		 * see if the file is newer than the zone transfer
		 * (regardless if this is a different file), because the
		 * zone transfer is a different content source too */
		if(!zone_fname && timespec_compare(&zone_mtime, &mtime) >= 0) {
			VERBOSITY(3, (LOG_INFO, "zonefile %s is older than "
				"zone transfer in memory", fname));
			return;

		/* if zone_fname, then the file was acquired from reading it,
		 * and see if filename changed or mtime newer to read it */
		} else if(zone_fname && fname &&
		   strcmp(zone_fname, fname) == 0 &&
		   timespec_compare(&zone_mtime, &mtime) == 0) {
			VERBOSITY(3, (LOG_INFO, "zonefile %s is not modified",
				fname));
			return;
		}
	}

	assert(parser);
	/* wipe zone from memory */
#ifdef NSEC3
	nsec3_hash_tree_clear(zone);
#endif
	delete_zone_rrs(nsd->db, zone);
#ifdef NSEC3
	nsec3_clear_precompile(nsd->db, zone);
	zone->nsec3_param = NULL;
#endif /* NSEC3 */
	errors = zonec_read(zone->opts->name, fname, zone);
	if(errors > 0) {
		log_msg(LOG_ERR, "zone %s file %s read with %u errors",
			zone->opts->name, fname, errors);
		/* wipe (partial) zone from memory */
		zone->is_ok = 1;
#ifdef NSEC3
		nsec3_hash_tree_clear(zone);
#endif
		delete_zone_rrs(nsd->db, zone);
#ifdef NSEC3
		nsec3_clear_precompile(nsd->db, zone);
		zone->nsec3_param = NULL;
#endif /* NSEC3 */
		if(nsd->db->udb) {
			region_type* dname_region;
			udb_ptr z;
			/* see if we can revert to the udb stored version */
			if(!udb_zone_search(nsd->db->udb, &z, dname_name(domain_dname(
				zone->apex)), domain_dname(zone->apex)->name_size)) {
				/* tell that zone contents has been lost */
				if(taskudb) task_new_soainfo(taskudb, last_task, zone, 0);
				return;
			}
			/* read from udb */
			dname_region = region_create(xalloc, free);
			udb_rrsets = 0;
			udb_rrset_count = ZONE(&z)->rrset_count;
			udb_time = time(NULL);
			read_zone_data(nsd->db->udb, nsd->db, dname_region, &z, zone);
			region_destroy(dname_region);
			udb_ptr_unlink(&z, nsd->db->udb);
		} else {
			if(zone->filename)
				region_recycle(nsd->db->region, zone->filename,
					strlen(zone->filename)+1);
			zone->filename = NULL;
			if(zone->logstr)
				region_recycle(nsd->db->region, zone->logstr,
					strlen(zone->logstr)+1);
			zone->logstr = NULL;
		}
	} else {
		VERBOSITY(1, (LOG_INFO, "zone %s read with success",
			zone->opts->name));
		zone->is_ok = 1;
		zone->is_changed = 0;
		/* store zone into udb */
		if(nsd->db->udb) {
			if(!write_zone_to_udb(nsd->db->udb, zone, &mtime,
				fname)) {
				log_msg(LOG_ERR, "failed to store zone in db");
			} else {
				VERBOSITY(2, (LOG_INFO, "zone %s written to db",
					zone->opts->name));
			}
		} else {
			zone->mtime = mtime;
			if(zone->filename)
				region_recycle(nsd->db->region, zone->filename,
					strlen(zone->filename)+1);
			zone->filename = region_strdup(nsd->db->region, fname);
			if(zone->logstr)
				region_recycle(nsd->db->region, zone->logstr,
					strlen(zone->logstr)+1);
			zone->logstr = NULL;
		}
	}
	if(taskudb) task_new_soainfo(taskudb, last_task, zone, 0);
#ifdef NSEC3
	prehash_zone_complete(nsd->db, zone);
#endif
}

void namedb_check_zonefile(struct nsd* nsd, udb_base* taskudb,
	udb_ptr* last_task, struct zone_options* zopt)
{
	zone_type* zone;
	const dname_type* dname = (const dname_type*)zopt->node.key;
	/* find zone to go with it, or create it */
	zone = namedb_find_zone(nsd->db, dname);
	if(!zone) {
		zone = namedb_zone_create(nsd->db, dname, zopt);
	}
	namedb_read_zonefile(nsd, zone, taskudb, last_task);
}

void namedb_check_zonefiles(struct nsd* nsd, struct nsd_options* opt,
	udb_base* taskudb, udb_ptr* last_task)
{
	struct zone_options* zo;
	/* check all zones in opt, create if not exist in main db */
	RBTREE_FOR(zo, struct zone_options*, opt->zone_options) {
		namedb_check_zonefile(nsd, taskudb, last_task, zo);
		if(nsd->signal_hint_shutdown) break;
	}
}
@


1.3
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@d250 1
a250 1
	zone_options_t* zo)
d324 1
a324 1
read_zone(udb_base* udb, namedb_type* db, nsd_options_t* opt,
d329 1
a329 1
	zone_options_t* zo = dname?zone_options_find(opt, dname):NULL;
d356 1
a356 1
read_zones(udb_base* udb, namedb_type* db, nsd_options_t* opt,
d381 1
a381 1
	nsd_options_t* opt)
d417 1
a417 1
namedb_open (const char* filename, nsd_options_t* opt)
d656 1
a656 1
	udb_ptr* last_task, zone_options_t* zopt)
d668 1
a668 1
void namedb_check_zonefiles(struct nsd* nsd, nsd_options_t* opt,
d671 1
a671 1
	zone_options_t* zo;
d673 1
a673 1
	RBTREE_FOR(zo, zone_options_t*, opt->zone_options) {
@


1.2
log
@comment typo fixes, from nsd 4.1.7rc1
@
text
@d274 2
a275 1
	zone->mtime = 0;
d495 2
a496 2
static int
file_get_mtime(const char* file, time_t* mtime, int* nonexist)
d500 2
a501 1
		*mtime = 0;
d506 8
a513 1
	*mtime = s.st_mtime;
d521 1
a521 1
	time_t mtime = 0;
d527 2
d541 1
a541 1
		time_t zone_mtime = zone->mtime;
d546 1
a546 1
			zone_mtime = (time_t)udb_zone_get_mtime(nsd->db->udb,
d548 2
a549 1
				domain_dname(zone->apex)->name_size);
d555 1
a555 1
		if(!zone_fname && zone_mtime >= mtime) {
d563 2
a564 1
		   strcmp(zone_fname, fname) == 0 && zone_mtime >= mtime) {
d630 2
a631 1
			if(!write_zone_to_udb(nsd->db->udb, zone, mtime, fname)) {
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
#include <config.h>
a19 1
#include <stdio.h>		/* DEBUG */
d25 12
d38 2
a39 5
int
namedb_lookup(struct namedb    *db,
	      const dname_type *dname,
	      domain_type     **closest_match,
	      domain_type     **closest_encloser)
d41 9
a49 2
	return domain_table_search(
		db->domains, dname, closest_match, closest_encloser);
d52 2
a53 2
static int
read_magic(namedb_type *db)
d55 7
a61 6
	char buf[NAMEDB_MAGIC_SIZE];

	if (fread(buf, sizeof(char), sizeof(buf), db->fd) != sizeof(buf))
		return 0;

	return memcmp(buf, NAMEDB_MAGIC, NAMEDB_MAGIC_SIZE) == 0;
d64 2
a65 2
static const dname_type *
read_dname(FILE *fd, region_type *region)
d67 7
a73 2
	uint8_t size;
	uint8_t temp[MAXDOMAINLEN];
d75 11
a85 4
	if (fread(&size, sizeof(uint8_t), 1, fd) != 1)
		return NULL;
	if (fread(temp, sizeof(uint8_t), size, fd) != size)
		return NULL;
d87 16
a102 1
	return dname_make(region, temp, 1);
d105 3
a107 2
static int
read_size(namedb_type *db, uint32_t *result)
d109 16
a124 5
	if (fread(result, sizeof(*result), 1, db->fd) == 1) {
		*result = ntohl(*result);
		return 1;
	} else {
		return 0;
d126 1
d129 3
a131 2
static domain_type *
read_domain(namedb_type *db, uint32_t domain_count, domain_type **domains)
d133 9
a141 9
	uint32_t domain_number;

	if (!read_size(db, &domain_number))
		return NULL;

	if (domain_number == 0 || domain_number > domain_count)
		return NULL;

	return domains[domain_number - 1];
d144 4
a147 2
static zone_type *
read_zone(namedb_type *db, uint32_t zone_count, zone_type **zones)
d149 22
a170 9
	uint32_t zone_number;

	if (!read_size(db, &zone_number))
		return NULL;

	if (zone_number == 0 || zone_number > zone_count)
		return NULL;

	return zones[zone_number - 1];
d173 3
a175 2
static int
read_rdata_atom(namedb_type *db, uint16_t type, int index, uint32_t domain_count, domain_type **domains, rdata_atom_type *result)
d177 22
a198 19
	uint8_t data[65536];

	if (rdata_atom_is_domain(type, index)) {
		result->domain = read_domain(db, domain_count, domains);
		if (!result->domain)
			return 0;
	} else {
		uint16_t size;

		if (fread(&size, sizeof(size), 1, db->fd) != 1)
			return 0;
		size = ntohs(size);
		if (fread(data, sizeof(uint8_t), size, db->fd) != size)
			return 0;

		result->data = (uint16_t *) region_alloc(
			db->region, sizeof(uint16_t) + size);
		memcpy(result->data, &size, sizeof(uint16_t));
		memcpy((uint8_t *) result->data + sizeof(uint16_t), data, size);
d200 2
a201 2

	return 1;
d204 24
a227 58
static rrset_type *
read_rrset(namedb_type *db,
	   uint32_t domain_count, domain_type **domains,
	   uint32_t zone_count, zone_type **zones)
{
	rrset_type *rrset;
	int i, j;
	domain_type *owner;
	uint16_t type;
	uint16_t klass;
	uint32_t soa_minimum;

	owner = read_domain(db, domain_count, domains);
	if (!owner)
		return NULL;

	rrset = (rrset_type *) region_alloc(db->region, sizeof(rrset_type));

	rrset->zone = read_zone(db, zone_count, zones);
	if (!rrset->zone)
		return NULL;

	if (fread(&type, sizeof(type), 1, db->fd) != 1)
		return NULL;
	type = ntohs(type);

	if (fread(&klass, sizeof(klass), 1, db->fd) != 1)
		return NULL;
	klass = ntohs(klass);

	if (fread(&rrset->rr_count, sizeof(rrset->rr_count), 1, db->fd) != 1)
		return NULL;
	rrset->rr_count = ntohs(rrset->rr_count);
	rrset->rrs = (rr_type *) region_alloc(
		db->region, rrset->rr_count * sizeof(rr_type));

	assert(rrset->rr_count > 0);

	for (i = 0; i < rrset->rr_count; ++i) {
		rr_type *rr = &rrset->rrs[i];

		rr->owner = owner;
		rr->type = type;
		rr->klass = klass;

		if (fread(&rr->rdata_count, sizeof(rr->rdata_count), 1, db->fd) != 1)
			return NULL;
		rr->rdata_count = ntohs(rr->rdata_count);
		rr->rdatas = (rdata_atom_type *) region_alloc(
			db->region, rr->rdata_count * sizeof(rdata_atom_type));

		if (fread(&rr->ttl, sizeof(rr->ttl), 1, db->fd) != 1)
			return NULL;
		rr->ttl = ntohl(rr->ttl);

		for (j = 0; j < rr->rdata_count; ++j) {
			if (!read_rdata_atom(db, rr->type, j, domain_count, domains, &rr->rdatas[j]))
				return NULL;
d230 1
d232 14
a245 1
	domain_add_rrset(owner, rrset);
d247 34
a280 3
	if (rrset_rrtype(rrset) == TYPE_SOA) {
		assert(owner == rrset->zone->apex);
		rrset->zone->soa_rrset = rrset;
d282 5
a286 11
		/* BUG #103 add another soa with a tweaked ttl */
		rrset->zone->soa_nx_rrset = region_alloc(db->region, sizeof(rrset_type));
		rrset->zone->soa_nx_rrset->rrs =
			region_alloc(db->region, rrset->rr_count * sizeof(rr_type));

		memcpy(rrset->zone->soa_nx_rrset->rrs, rrset->rrs, sizeof(rr_type));
		rrset->zone->soa_nx_rrset->rr_count = 1;
		rrset->zone->soa_nx_rrset->next = 0;

		/* also add a link to the zone */
		rrset->zone->soa_nx_rrset->zone = rrset->zone;
d288 7
a294 5
		/* check the ttl and MINIMUM value and set accordinly */
		memcpy(&soa_minimum, rdata_atom_data(rrset->rrs->rdatas[6]),
				rdata_atom_size(rrset->rrs->rdatas[6]));
		if (rrset->rrs->ttl > ntohl(soa_minimum)) {
			rrset->zone->soa_nx_rrset->rrs[0].ttl = ntohl(soa_minimum);
d296 1
d298 6
a303 4
	} else if (owner == rrset->zone->apex
		   && rrset_rrtype(rrset) == TYPE_NS)
	{
		rrset->zone->ns_rrset = rrset;
d305 14
d320 18
a337 8
#ifdef DNSSEC
	if (rrset_rrtype(rrset) == TYPE_RRSIG && owner == rrset->zone->apex) {
		for (i = 0; i < rrset->rr_count; ++i) {
			if (rr_rrsig_type_covered(&rrset->rrs[i]) == TYPE_SOA) {
				rrset->zone->is_secure = 1;
				break;
			}
		}
d339 9
a348 1
	return rrset;
d350 1
d352 5
a356 2
struct namedb *
namedb_open (const char *filename, nsd_options_t* opt, size_t num_children)
d358 17
a374 7
	namedb_type *db;

	/*
	 * Region used to store the loaded database.  The region is
	 * freed in namedb_close.
	 */
	region_type *db_region;
d376 6
d387 32
a418 1
	region_type *dname_region;
d421 2
a422 3
	 * Temporary region used to store array of domains and zones
	 * while loading the database.  The region is freed before
	 * returning.
d424 2
a425 28
	region_type *temp_region;

	uint32_t dname_count;
	domain_type **domains;	/* Indexed by domain number.  */

	uint32_t zone_count;
	zone_type **zones;	/* Indexed by zone number.  */

	uint32_t i;
	uint32_t rrset_count = 0;
	uint32_t rr_count = 0;

	rrset_type *rrset;

	DEBUG(DEBUG_DBACCESS, 2,
	      (LOG_INFO, "sizeof(namedb_type) = %lu\n", (unsigned long) sizeof(namedb_type)));
	DEBUG(DEBUG_DBACCESS, 2,
	      (LOG_INFO, "sizeof(zone_type) = %lu\n", (unsigned long) sizeof(zone_type)));
	DEBUG(DEBUG_DBACCESS, 2,
	      (LOG_INFO, "sizeof(domain_type) = %lu\n", (unsigned long) sizeof(domain_type)));
	DEBUG(DEBUG_DBACCESS, 2,
	      (LOG_INFO, "sizeof(rrset_type) = %lu\n", (unsigned long) sizeof(rrset_type)));
	DEBUG(DEBUG_DBACCESS, 2,
	      (LOG_INFO, "sizeof(rr_type) = %lu\n", (unsigned long) sizeof(rr_type)));
	DEBUG(DEBUG_DBACCESS, 2,
	      (LOG_INFO, "sizeof(rdata_atom_type) = %lu\n", (unsigned long) sizeof(rdata_atom_type)));
	DEBUG(DEBUG_DBACCESS, 2,
	      (LOG_INFO, "sizeof(rbnode_t) = %lu\n", (unsigned long) sizeof(rbnode_t)));
d427 4
d433 1
d437 1
a437 4
	db->zones = NULL;
	db->zone_count = 0;
	db->filename = region_strdup(db->region, filename);
	db->crc = 0xffffffff;
d439 2
d444 1
a444 1
				 "timestamp", db->filename);
d446 1
a446 1
                return NULL;
d449 4
a452 7
	/* Open it... */
	db->fd = fopen(db->filename, "r");
	if (db->fd == NULL) {
		log_msg(LOG_ERR, "unable to load %s: %s",
			db->filename, strerror(errno));
		region_destroy(db_region);
		return NULL;
d455 7
a461 5
	if (!read_magic(db)) {
		log_msg(LOG_ERR, "corrupted database (read magic): %s", db->filename);
		namedb_close(db);
		return NULL;
	}
d463 8
a470 4
	if (!read_size(db, &zone_count)) {
		log_msg(LOG_ERR, "corrupted database (read size): %s", db->filename);
		namedb_close(db);
		return NULL;
d472 10
a481 17

	DEBUG(DEBUG_DBACCESS, 1,
	      (LOG_INFO, "Retrieving %lu zones\n", (unsigned long) zone_count));

	temp_region = region_create(xalloc, free);
	dname_region = region_create(xalloc, free);

	db->zone_count = zone_count;
	zones = (zone_type **) region_alloc(temp_region,
					    zone_count * sizeof(zone_type *));
	for (i = 0; i < zone_count; ++i) {
		const dname_type *dname = read_dname(db->fd, dname_region);
		if (!dname) {
			log_msg(LOG_ERR, "corrupted database (read dname): %s", db->filename);
			region_destroy(dname_region);
			region_destroy(temp_region);
			namedb_close(db);
d484 2
a485 29
		zones[i] = (zone_type *) region_alloc(db->region,
						      sizeof(zone_type));
		zones[i]->next = db->zones;
		db->zones = zones[i];
		zones[i]->apex = domain_table_insert(db->domains, dname);
		zones[i]->soa_rrset = NULL;
		zones[i]->soa_nx_rrset = NULL;
		zones[i]->ns_rrset = NULL;
#ifdef NSEC3
		zones[i]->nsec3_soa_rr = NULL;
		zones[i]->nsec3_last = NULL;
#endif
		zones[i]->opts = zone_options_find(opt, domain_dname(zones[i]->apex));
		zones[i]->number = i + 1;
		zones[i]->is_secure = 0;
		zones[i]->updated = 1;
		zones[i]->is_ok = 0;
		zones[i]->dirty = region_alloc(db->region, sizeof(uint8_t)*num_children);
		memset(zones[i]->dirty, 0, sizeof(uint8_t)*num_children);
		if(!zones[i]->opts) {
			log_msg(LOG_ERR, "cannot load database. Zone %s in db "
					 "%s, but not in config file (might "
					 "happen if you edited the config "
					 "file). Please rebuild database and "
					 "start again.",
				dname_to_string(dname, NULL), db->filename);
			region_destroy(dname_region);
			region_destroy(temp_region);
			namedb_close(db);
d488 4
d493 9
a501 1
		region_free_all(dname_region);
d503 4
d508 48
a555 6
	if (!read_size(db, &dname_count)) {
		log_msg(LOG_ERR, "corrupted database (read size): %s", db->filename);
		region_destroy(dname_region);
		region_destroy(temp_region);
		namedb_close(db);
		return NULL;
d558 40
a597 9
	DEBUG(DEBUG_DBACCESS, 1,
	      (LOG_INFO, "Retrieving %lu domain names\n", (unsigned long) dname_count));

	domains = (domain_type **) region_alloc(
		temp_region, dname_count * sizeof(domain_type *));
	for (i = 0; i < dname_count; ++i) {
		const dname_type *dname = read_dname(db->fd, dname_region);
		if (!dname) {
			log_msg(LOG_ERR, "corrupted database (read dname): %s", db->filename);
d599 34
a632 3
			region_destroy(temp_region);
			namedb_close(db);
			return NULL;
a633 2
		domains[i] = domain_table_insert(db->domains, dname);
		region_free_all(dname_region);
d635 3
a637 7

	region_destroy(dname_region);

#ifndef NDEBUG
	fprintf(stderr, "database region after loading domain names: ");
	region_dump_stats(db->region, stderr);
	fprintf(stderr, "\n");
d639 1
d641 9
a649 3
	while ((rrset = read_rrset(db, dname_count, domains, zone_count, zones))) {
		++rrset_count;
		rr_count += rrset->rr_count;
d651 1
a651 34

	DEBUG(DEBUG_DBACCESS, 1,
	      (LOG_INFO, "Retrieved %lu RRs in %lu RRsets\n",
	       (unsigned long) rr_count, (unsigned long) rrset_count));

	region_destroy(temp_region);

	if ((db->crc_pos = ftello(db->fd)) == -1) {
		log_msg(LOG_ERR, "ftello %s failed: %s",
			db->filename, strerror(errno));
		namedb_close(db);
		return NULL;
	}
	if (!read_size(db, &db->crc)) {
		log_msg(LOG_ERR, "corrupted database (read size): %s", db->filename);
		namedb_close(db);
		return NULL;
	}
	if (!read_magic(db)) {
		log_msg(LOG_ERR, "corrupted database (read magic): %s", db->filename);
		namedb_close(db);
		return NULL;
	}

	fclose(db->fd);
	db->fd = NULL;

#ifndef NDEBUG
	fprintf(stderr, "database region after loading database: ");
	region_dump_stats(db->region, stderr);
	fprintf(stderr, "\n");
#endif

	return db;
d654 2
a655 2
void
namedb_close (struct namedb *db)
d657 5
a661 5
	if (db) {
		if (db->fd) {
			fclose(db->fd);
		}
		region_destroy(db->region);
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.5
@
text
@a284 4
#ifdef USE_MMAP_ALLOC
	db_region = region_create_custom(mmap_alloc, mmap_free, MMAP_ALLOC_CHUNK_SIZE,
		MMAP_ALLOC_LARGE_OBJECT_SIZE, MMAP_ALLOC_INITIAL_CLEANUP_SIZE, 1);
#else /* !USE_MMAP_ALLOC */
a286 1
#endif /* !USE_MMAP_ALLOC */
a453 1
	namedb_fd_close(db);
d455 3
a460 9

void
namedb_fd_close (struct namedb *db)
{
	if (db && db->fd) {
		fclose(db->fd);
	}
}

@


1.1.1.3
log
@NSD v3.2.6
@
text
@d220 1
d229 1
@


1.1.1.4
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.5
log
@NSD v3.2.9
@
text
@a212 1
		owner->has_SOA = 1;
d219 1
a219 9
#ifdef NSEC3
#ifndef FULL_PREHASH
	else if (type == TYPE_NSEC3) {
		if (0 != namedb_add_nsec3_domain(db, owner, rrset->zone)) {
			return NULL;
		}
	}
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */
d222 1
a222 1
			if (rr_rrsig_type_covered(&rrset->rrs[i]) == TYPE_DNSKEY) {
d237 6
d283 15
a297 6
	if ((db = namedb_create()) == NULL) {
		log_msg(LOG_ERR,
			"insufficient memory to create database");
		return NULL;
	}
 	db->filename = region_strdup(db->region, filename);
d302 3
a304 3
		namedb_destroy(db);
		return NULL;
	}
d311 1
a311 1
		namedb_destroy(db);
a316 3
		log_msg(LOG_ERR, "cannot load database, incompatible version "
					"number. Please rebuild database and "
                                        "start again.");
d376 1
a376 14
#ifdef NSEC3
#ifndef FULL_PREHASH
		zones[i]->nsec3_domains = NULL;
		if (0 != zone_nsec3_domains_create(db, zones[i])) {
			log_msg(LOG_ERR,
				"insufficient memory for NSEC3 tree, "
				"unable to read database");
			region_destroy(dname_region);
			region_destroy(temp_region);
			namedb_close(db);
			return NULL;
		}
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */
a437 3
		log_msg(LOG_ERR, "cannot load database, incompatible version "
					"number. Please rebuild database and "
                                        "start again.");
d459 1
a459 1
		namedb_destroy(db);
@


1.1.1.6
log
@NSD v3.2.11, ok phessler@@
@
text
@d10 1
a10 1
#include "config.h"
@


1.1.1.7
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d20 1
a25 11
#include "rdata.h"
#include "udb.h"
#include "udbradtree.h"
#include "udbzone.h"
#include "zonec.h"
#include "nsec3.h"
#include "difffile.h"

static time_t udb_time = 0;
static unsigned udb_rrsets = 0;
static unsigned udb_rrset_count = 0;
d27 37
a63 2
void
namedb_close(struct namedb* db)
d65 5
a69 7
	if(db) {
		if(db->udb) {
			udb_base_close(db->udb);
			udb_base_free(db->udb);
		}
		zonec_desetup_parser();
		region_destroy(db->region);
d73 16
a88 2
void
namedb_close_udb(struct namedb* db)
d90 9
a98 7
	if(db) {
		/* we cannot actually munmap the data, because other
		 * processes still need to access the udb, so cleanup the
		 * udb */
		udb_base_free_keep_mmap(db->udb);
		db->udb = NULL;
	}
d101 2
a102 2
void
apex_rrset_checks(namedb_type* db, rrset_type* rrset, domain_type* domain)
d104 1
a104 7
	uint32_t soa_minimum;
	unsigned i;
	zone_type* zone = rrset->zone;
	assert(domain == zone->apex);
	(void)domain;
	if (rrset_rrtype(rrset) == TYPE_SOA) {
		zone->soa_rrset = rrset;
d106 6
a111 11
		/* BUG #103 add another soa with a tweaked ttl */
		if(zone->soa_nx_rrset == 0) {
			zone->soa_nx_rrset = region_alloc(db->region,
				sizeof(rrset_type));
			zone->soa_nx_rrset->rr_count = 1;
			zone->soa_nx_rrset->next = 0;
			zone->soa_nx_rrset->zone = zone;
			zone->soa_nx_rrset->rrs = region_alloc(db->region,
				sizeof(rr_type));
		}
		memcpy(zone->soa_nx_rrset->rrs, rrset->rrs, sizeof(rr_type));
d113 10
a122 15
		/* check the ttl and MINIMUM value and set accordinly */
		memcpy(&soa_minimum, rdata_atom_data(rrset->rrs->rdatas[6]),
				rdata_atom_size(rrset->rrs->rdatas[6]));
		if (rrset->rrs->ttl > ntohl(soa_minimum)) {
			zone->soa_nx_rrset->rrs[0].ttl = ntohl(soa_minimum);
		}
	} else if (rrset_rrtype(rrset) == TYPE_NS) {
		zone->ns_rrset = rrset;
	} else if (rrset_rrtype(rrset) == TYPE_RRSIG) {
		for (i = 0; i < rrset->rr_count; ++i) {
			if(rr_rrsig_type_covered(&rrset->rrs[i])==TYPE_DNSKEY){
				zone->is_secure = 1;
				break;
			}
		}
d124 2
d128 16
a143 51
/** read rr */
static void
read_rr(namedb_type* db, rr_type* rr, udb_ptr* urr, domain_type* domain)
{
	buffer_type buffer;
	ssize_t c;
	assert(udb_ptr_get_type(urr) == udb_chunk_type_rr);
	rr->owner = domain;
	rr->type = RR(urr)->type;
	rr->klass = RR(urr)->klass;
	rr->ttl = RR(urr)->ttl;

	buffer_create_from(&buffer, RR(urr)->wire, RR(urr)->len);
	c = rdata_wireformat_to_rdata_atoms(db->region, db->domains,
		rr->type, RR(urr)->len, &buffer, &rr->rdatas);
	if(c == -1) {
		/* safe on error */
		rr->rdata_count = 0;
		rr->rdatas = NULL;
		return;
	}
	rr->rdata_count = c;
}

/** calculate rr count */
static uint16_t
calculate_rr_count(udb_base* udb, udb_ptr* rrset)
{
	udb_ptr rr;
	uint16_t num = 0;
	udb_ptr_new(&rr, udb, &RRSET(rrset)->rrs);
	while(rr.data) {
		num++;
		udb_ptr_set_rptr(&rr, udb, &RR(&rr)->next);
	}
	udb_ptr_unlink(&rr, udb);
	return num;
}

/** read rrset */
static void
read_rrset(udb_base* udb, namedb_type* db, zone_type* zone,
	domain_type* domain, udb_ptr* urrset)
{
	rrset_type* rrset;
	udb_ptr urr;
	unsigned i;
	assert(udb_ptr_get_type(urrset) == udb_chunk_type_rrset);
	/* if no RRs, do not create anything (robust) */
	if(RRSET(urrset)->rrs.data == 0)
		return;
d145 16
a160 2
	rrset->zone = zone;
	rrset->rr_count = calculate_rr_count(udb, urrset);
d163 23
a185 36
	/* add the RRs */
	udb_ptr_new(&urr, udb, &RRSET(urrset)->rrs);
	for(i=0; i<rrset->rr_count; i++) {
		read_rr(db, &rrset->rrs[i], &urr, domain);
		udb_ptr_set_rptr(&urr, udb, &RR(&urr)->next);
	}
	udb_ptr_unlink(&urr, udb);
	domain_add_rrset(domain, rrset);
	if(domain == zone->apex)
		apex_rrset_checks(db, rrset, domain);
}

/** read one elem from db, of type domain_d */
static void read_node_elem(udb_base* udb, namedb_type* db, 
	region_type* dname_region, zone_type* zone, struct domain_d* d)
{
	const dname_type* dname;
	domain_type* domain;
	udb_ptr urrset;

	dname = dname_make(dname_region, d->name, 0);
	if(!dname) return;
	domain = domain_table_insert(db->domains, dname);
	assert(domain); /* domain_table_insert should always return non-NULL */

	/* add rrsets */
	udb_ptr_init(&urrset, udb);
	udb_ptr_set_rptr(&urrset, udb, &d->rrsets);
	while(urrset.data) {
		read_rrset(udb, db, zone, domain, &urrset);
		udb_ptr_set_rptr(&urrset, udb, &RRSET(&urrset)->next);

		if(++udb_rrsets % ZONEC_PCT_COUNT == 0 && time(NULL) > udb_time + ZONEC_PCT_TIME) {
			udb_time = time(NULL);
			VERBOSITY(1, (LOG_INFO, "read %s %d %%",
				zone->opts->name, udb_rrsets*100/udb_rrset_count));
a187 3
	region_free_all(dname_region);
	udb_ptr_unlink(&urrset, udb);
}
d189 5
a193 27
/** recurse read radix from disk. This radix tree is by domain name, so max of
 * 256 depth, and thus the stack usage is small. */
static void read_zone_recurse(udb_base* udb, namedb_type* db,
	region_type* dname_region, zone_type* zone, struct udb_radnode_d* node)
{
	if(node->elem.data) {
		/* pre-order process of node->elem, for radix tree this is
		 * also in-order processing (identical to order tree_next()) */
		read_node_elem(udb, db, dname_region, zone, (struct domain_d*)
			(udb->base + node->elem.data));
	}
	if(node->lookup.data) {
		uint16_t i;
		struct udb_radarray_d* a = (struct udb_radarray_d*)
			(udb->base + node->lookup.data);
		/* we do not care for what the exact radix key is, we want
		 * to add all of them and the read routine does not need
		 * the radix-key, it has it stored */
		for(i=0; i<a->len; i++) {
			if(a->array[i].node.data) {
				read_zone_recurse(udb, db, dname_region, zone,
					(struct udb_radnode_d*)(udb->base +
						a->array[i].node.data));
			}
		}
	}
}
d195 8
a202 45
/** read zone data */
static void
read_zone_data(udb_base* udb, namedb_type* db, region_type* dname_region,
	udb_ptr* z, zone_type* zone)
{
	udb_ptr dtree;
	/* recursively read domains, we only read so ptrs stay valid */
	udb_ptr_new(&dtree, udb, &ZONE(z)->domains);
	if(RADTREE(&dtree)->root.data)
		read_zone_recurse(udb, db, dname_region, zone,
			(struct udb_radnode_d*)
			(udb->base + RADTREE(&dtree)->root.data));
	udb_ptr_unlink(&dtree, udb);
}

/** create a zone */
zone_type*
namedb_zone_create(namedb_type* db, const dname_type* dname,
	zone_options_t* zo)
{
	zone_type* zone = (zone_type *) region_alloc(db->region,
		sizeof(zone_type));
	zone->node = radname_insert(db->zonetree, dname_name(dname),
		dname->name_size, zone);
	assert(zone->node);
	zone->apex = domain_table_insert(db->domains, dname);
	zone->apex->usage++; /* the zone.apex reference */
	zone->apex->is_apex = 1;
	zone->soa_rrset = NULL;
	zone->soa_nx_rrset = NULL;
	zone->ns_rrset = NULL;
#ifdef NSEC3
	zone->nsec3_param = NULL;
	zone->nsec3_last = NULL;
	zone->nsec3tree = NULL;
	zone->hashtree = NULL;
	zone->wchashtree = NULL;
	zone->dshashtree = NULL;
#endif
	zone->opts = zo;
	zone->is_secure = 0;
	zone->is_changed = 0;
	zone->is_ok = 1;
	return zone;
}
d204 2
a205 5
void
namedb_zone_delete(namedb_type* db, zone_type* zone)
{
	/* RRs and UDB and NSEC3 and so on must be already deleted */
	radix_delete(db->zonetree, zone->node);
d207 5
a211 6
	/* see if apex can be deleted */
	if(zone->apex) {
		zone->apex->usage --;
		if(zone->apex->usage == 0) {
			/* delete the apex, possibly */
			domain_table_deldomain(db, zone->apex);
d213 1
a213 1
	}
d215 4
a218 6
	/* soa_rrset is freed when the SOA was deleted */
	if(zone->soa_nx_rrset) {
		region_recycle(db->region, zone->soa_nx_rrset->rrs,
			sizeof(rr_type));
		region_recycle(db->region, zone->soa_nx_rrset,
			sizeof(rrset_type));
d221 15
a235 25
	hash_tree_delete(db->region, zone->nsec3tree);
	hash_tree_delete(db->region, zone->hashtree);
	hash_tree_delete(db->region, zone->wchashtree);
	hash_tree_delete(db->region, zone->dshashtree);
#endif
	region_recycle(db->region, zone, sizeof(zone_type));
}

/** read a zone */
static void
read_zone(udb_base* udb, namedb_type* db, nsd_options_t* opt,
	region_type* dname_region, udb_ptr* z)
{
	/* construct dname */
	const dname_type* dname = dname_make(dname_region, ZONE(z)->name, 0);
	zone_options_t* zo = dname?zone_options_find(opt, dname):NULL;
	zone_type* zone;
	if(!dname) return;
	if(!zo) {
		/* deleted from the options, remove it from the nsd.db too */
		VERBOSITY(2, (LOG_WARNING, "zone %s is deleted",
			dname_to_string(dname, NULL)));
		udb_zone_delete(udb, z);
		region_free_all(dname_region);
		return;
d237 1
a237 10
	assert(udb_ptr_get_type(z) == udb_chunk_type_zone);
	udb_rrsets = 0;
	udb_rrset_count = ZONE(z)->rrset_count;
	zone = namedb_zone_create(db, dname, zo);
	region_free_all(dname_region);
	read_zone_data(udb, db, dname_region, z, zone);
	zone->is_changed = (ZONE(z)->is_changed != 0);
#ifdef NSEC3
	prehash_zone_complete(db, zone);
#endif
d240 4
a243 20
/** read zones from nsd.db */
static void
read_zones(udb_base* udb, namedb_type* db, nsd_options_t* opt,
	region_type* dname_region)
{
	udb_ptr ztree, n, z;
	udb_ptr_init(&z, udb);
	udb_ptr_new(&ztree, udb, udb_base_get_userdata(udb));
	udb_radix_first(udb,&ztree,&n);
	udb_time = time(NULL);
	while(n.data) {
		udb_ptr_set_rptr(&z, udb, &RADNODE(&n)->elem);
		udb_radix_next(udb, &n); /* store in case n is deleted */
		read_zone(udb, db, opt, dname_region, &z);
		udb_ptr_zero(&z, udb);
	}
	udb_ptr_unlink(&ztree, udb);
	udb_ptr_unlink(&n, udb);
	udb_ptr_unlink(&z, udb);
}
a244 5
/** try to read the udb file or fail */
static int
try_read_udb(namedb_type* db, int fd, const char* filename,
	nsd_options_t* opt)
{
d250 1
a250 1
	region_type* dname_region;
d252 38
a289 7
	assert(fd != -1);
	if(!(db->udb=udb_base_create_fd(filename, fd, &namedb_walkfunc,
		NULL))) {
		/* fd is closed by failed udb create call */
		VERBOSITY(1, (LOG_WARNING, "can not use %s, "
			"will create anew", filename));
		return 0;
d291 7
a297 7
	/* sanity check if can be opened */
	if(udb_base_get_userflags(db->udb) != 0) {
		log_msg(LOG_WARNING, "%s was not closed properly, it might "
			"be corrupted, will create anew", filename);
		udb_base_free(db->udb);
		db->udb = NULL;
		return 0;
a298 8
	/* read if it can be opened */
	dname_region = region_create(xalloc, free);
	/* this operation does not fail, we end up with
	 * something, even if that is an empty namedb */
	read_zones(db->udb, db, opt, dname_region);
	region_destroy(dname_region);
	return 1;
}
d300 8
a307 4
struct namedb *
namedb_open (const char* filename, nsd_options_t* opt)
{
	namedb_type* db;
d309 8
a316 6
	/*
	 * Region used to store the loaded database.  The region is
	 * freed in namedb_close.
	 */
	region_type* db_region;
	int fd;
d318 4
a321 7
	/* attempt to open, if does not exist, create a new one */
	fd = open(filename, O_RDWR);
	if(fd == -1) {
		if(errno != ENOENT) {
			log_msg(LOG_ERR, "%s: %s", filename, strerror(errno));
			return NULL;
		}
d324 5
a328 13
#ifdef USE_MMAP_ALLOC
	db_region = region_create_custom(mmap_alloc, mmap_free, MMAP_ALLOC_CHUNK_SIZE,
		MMAP_ALLOC_LARGE_OBJECT_SIZE, MMAP_ALLOC_INITIAL_CLEANUP_SIZE, 1);
#else /* !USE_MMAP_ALLOC */
	db_region = region_create_custom(xalloc, free, DEFAULT_CHUNK_SIZE,
		DEFAULT_LARGE_OBJECT_SIZE, DEFAULT_INITIAL_CLEANUP_SIZE, 1);
#endif /* !USE_MMAP_ALLOC */
	db = (namedb_type *) region_alloc(db_region, sizeof(struct namedb));
	db->region = db_region;
	db->domains = domain_table_create(db->region);
	db->zonetree = radix_tree_create(db->region);
	db->diff_skip = 0;
	db->diff_pos = 0;
d330 41
a370 18
	if (gettimeofday(&(db->diff_timestamp), NULL) != 0) {
		log_msg(LOG_ERR, "unable to load %s: cannot initialize"
				 "timestamp", filename);
		region_destroy(db_region);
		close(fd);
		return NULL;
        }

	/* attempt to read the file (if it exists) */
	if(fd != -1) {
		if(!try_read_udb(db, fd, filename, opt))
			fd = -1;
	}
	/* attempt to create the file (if necessary or failed read) */
	if(fd == -1) {
		if(!(db->udb=udb_base_create_new(filename, &namedb_walkfunc,
			NULL))) {
			region_destroy(db_region);
d373 10
a382 2
		if(!udb_dns_init_file(db->udb)) {
			region_destroy(db->region);
d385 3
a388 3
	zonec_setup_parser(db);
	return db;
}
d390 6
a395 9
/** the the file mtime stat (or nonexist or error) */
static int
file_get_mtime(const char* file, time_t* mtime, int* nonexist)
{
	struct stat s;
	if(stat(file, &s) != 0) {
		*mtime = 0;
		*nonexist = (errno == ENOENT);
		return 0;
a396 4
	*nonexist = 0;
	*mtime = s.st_mtime;
	return 1;
}
d398 13
a410 28
void
namedb_read_zonefile(struct namedb* db, struct zone* zone, udb_base* taskudb,
	udb_ptr* last_task)
{
	time_t mtime = 0;
	int nonexist = 0;
	unsigned int errors;
	const char* fname;
	if(!db || !db->udb || !zone || !zone->opts || !zone->opts->pattern->zonefile)
		return;
	fname = config_make_zonefile(zone->opts);
	if(!file_get_mtime(fname, &mtime, &nonexist)) {
		if(nonexist) {
			VERBOSITY(2, (LOG_INFO, "zonefile %s does not exist",
				fname));
		} else
			log_msg(LOG_ERR, "zonefile %s: %s",
				fname, strerror(errno));
		if(taskudb) task_new_soainfo(taskudb, last_task, zone);
		return;
	} else {
		/* check the mtime */
		if(udb_zone_get_mtime(db->udb, dname_name(domain_dname(
			zone->apex)), domain_dname(zone->apex)->name_size)
			>= (uint64_t)mtime) {
			VERBOSITY(3, (LOG_INFO, "zonefile %s is not modified",
				fname));
			return;
d412 2
d416 6
a421 4
	assert(parser);
	/* wipe zone from memory */
#ifdef NSEC3
	nsec3_hash_tree_clear(zone);
d423 39
a461 15
	delete_zone_rrs(db, zone);
#ifdef NSEC3
	nsec3_clear_precompile(db, zone);
	zone->nsec3_param = NULL;
#endif /* NSEC3 */
	errors = zonec_read(zone->opts->name, fname, zone);
	if(errors > 0) {
		region_type* dname_region;
		udb_ptr z;
		log_msg(LOG_ERR, "zone %s file %s read with %u errors",
			zone->opts->name, fname, errors);
		/* wipe (partial) zone from memory */
		zone->is_ok = 1;
#ifdef NSEC3
		nsec3_hash_tree_clear(zone);
d463 10
a472 32
		delete_zone_rrs(db, zone);
#ifdef NSEC3
		nsec3_clear_precompile(db, zone);
		zone->nsec3_param = NULL;
#endif /* NSEC3 */
		/* see if we can revert to the udb stored version */
		if(!udb_zone_search(db->udb, &z, dname_name(domain_dname(
			zone->apex)), domain_dname(zone->apex)->name_size)) {
			/* tell that zone contents has been lost */
			if(taskudb) task_new_soainfo(taskudb, last_task, zone);
			return;
		}
		/* read from udb */
		dname_region = region_create(xalloc, free);
		udb_rrsets = 0;
		udb_rrset_count = ZONE(&z)->rrset_count;
		udb_time = time(NULL);
		read_zone_data(db->udb, db, dname_region, &z, zone);
		region_destroy(dname_region);
		udb_ptr_unlink(&z, db->udb);
	} else {
		VERBOSITY(1, (LOG_INFO, "zone %s read with no errors",
			zone->opts->name));
		zone->is_ok = 1;
		zone->is_changed = 0;
		/* store zone into udb */
		if(!write_zone_to_udb(db->udb, zone, mtime)) {
			log_msg(LOG_ERR, "failed to store zone in db");
		} else {
			VERBOSITY(2, (LOG_INFO, "zone %s written to db",
				zone->opts->name));
		}
a473 4
	if(taskudb) task_new_soainfo(taskudb, last_task, zone);
#ifdef NSEC3
	prehash_zone_complete(db, zone);
#endif
d476 2
a477 2
void namedb_check_zonefile(struct namedb* db, udb_base* taskudb,
	udb_ptr* last_task, zone_options_t* zopt)
d479 2
a480 17
	zone_type* zone;
	const dname_type* dname = (const dname_type*)zopt->node.key;
	/* find zone to go with it, or create it */
	zone = namedb_find_zone(db, dname);
	if(!zone) {
		zone = namedb_zone_create(db, dname, zopt);
	}
	namedb_read_zonefile(db, zone, taskudb, last_task);
}

void namedb_check_zonefiles(struct namedb* db, nsd_options_t* opt,
	udb_base* taskudb, udb_ptr* last_task)
{
	zone_options_t* zo;
	/* check all zones in opt, create if not exist in main db */
	RBTREE_FOR(zo, zone_options_t*, opt->zone_options) {
		namedb_check_zonefile(db, taskudb, last_task, zo);
d483 1
@


1.1.1.8
log
@update to NSD 4.0.1, ok sthen@@
@
text
@a31 1
#include "nsd.h"
d474 1
a474 1
namedb_read_zonefile(struct nsd* nsd, struct zone* zone, udb_base* taskudb,
d481 1
a481 1
	if(!nsd->db || !nsd->db->udb || !zone || !zone->opts || !zone->opts->pattern->zonefile)
d483 1
a483 1
	fname = config_make_zonefile(zone->opts, nsd);
d491 1
a491 1
		if(taskudb) task_new_soainfo(taskudb, last_task, zone, 0);
d495 1
a495 1
		if(udb_zone_get_mtime(nsd->db->udb, dname_name(domain_dname(
d509 1
a509 1
	delete_zone_rrs(nsd->db, zone);
d511 1
a511 1
	nsec3_clear_precompile(nsd->db, zone);
d525 1
a525 1
		delete_zone_rrs(nsd->db, zone);
d527 1
a527 1
		nsec3_clear_precompile(nsd->db, zone);
d531 1
a531 1
		if(!udb_zone_search(nsd->db->udb, &z, dname_name(domain_dname(
d534 1
a534 1
			if(taskudb) task_new_soainfo(taskudb, last_task, zone, 0);
d542 1
a542 1
		read_zone_data(nsd->db->udb, nsd->db, dname_region, &z, zone);
d544 1
a544 1
		udb_ptr_unlink(&z, nsd->db->udb);
d551 1
a551 1
		if(!write_zone_to_udb(nsd->db->udb, zone, mtime)) {
d558 1
a558 1
	if(taskudb) task_new_soainfo(taskudb, last_task, zone, 0);
d560 1
a560 1
	prehash_zone_complete(nsd->db, zone);
d564 1
a564 1
void namedb_check_zonefile(struct nsd* nsd, udb_base* taskudb,
d570 1
a570 1
	zone = namedb_find_zone(nsd->db, dname);
d572 1
a572 1
		zone = namedb_zone_create(nsd->db, dname, zopt);
d574 1
a574 1
	namedb_read_zonefile(nsd, zone, taskudb, last_task);
d577 1
a577 1
void namedb_check_zonefiles(struct nsd* nsd, nsd_options_t* opt,
d583 1
a583 1
		namedb_check_zonefile(nsd, taskudb, last_task, zo);
@


1.1.1.9
log
@update to NSD 4.0.2, ok sthen@@
@
text
@d495 2
a496 19
		const char* zone_fname = udb_zone_get_file_str(nsd->db->udb,
			dname_name(domain_dname(zone->apex)), domain_dname(
			zone->apex)->name_size);
		/* if no zone_fname, then it was acquired in zone transfer,
		 * see if the file is newer than the zone transfer
		 * (regardless if this is a different file), because the
		 * zone transfer is a different content source too */
		if(!zone_fname && udb_zone_get_mtime(nsd->db->udb,
			dname_name(domain_dname(zone->apex)), domain_dname(
			zone->apex)->name_size) >= (uint64_t)mtime) {
			VERBOSITY(3, (LOG_INFO, "zonefile %s is older than "
				"zone transfer in memory", fname));
			return;

		/* if zone_fname, then the file was acquired from reading it,
		 * and see if filename changed or mtime newer to read it */
		} else if(zone_fname && fname &&
		   strcmp(zone_fname, fname) == 0 &&
		   udb_zone_get_mtime(nsd->db->udb, dname_name(domain_dname(
d552 1
a552 1
		if(!write_zone_to_udb(nsd->db->udb, zone, mtime, fname)) {
@


1.1.1.10
log
@Update to NSD 4.0.3, main change is to improve/fix nsd.db database
corruption checks and avoid some causes of corruption. More details at
http://article.gmane.org/gmane.network.dns.nsd.general/1687
@
text
@a44 1
			db->udb = NULL;
@


1.1.1.11
log
@update to NSD 4.1.0, ok sthen@@
@
text
@d35 2
a36 2
static unsigned long udb_rrsets = 0;
static unsigned long udb_rrset_count = 0;
d196 1
a196 2
				zone->opts->name,
				(int)(udb_rrsets*((unsigned long)100)/udb_rrset_count)));
a270 3
	zone->filename = NULL;
	zone->logstr = NULL;
	zone->mtime = 0;
a304 6
	if(zone->filename)
		region_recycle(db->region, zone->filename,
			strlen(zone->filename)+1);
	if(zone->logstr)
		region_recycle(db->region, zone->logstr,
			strlen(zone->logstr)+1);
a307 1
#ifdef HAVE_MMAP
a336 1
#endif /* HAVE_MMAP */
a337 1
#ifdef HAVE_MMAP
a352 1
		if(nsd.signal_hint_shutdown) break;
a357 1
#endif /* HAVE_MMAP */
a358 1
#ifdef HAVE_MMAP
a394 1
#endif /* HAVE_MMAP */
d408 9
a429 1
	zonec_setup_parser(db);
d435 1
a438 23
	/* in dbless mode there is no file to read or mmap */
	if(filename == NULL || filename[0] == 0) {
		db->udb = NULL;
		return db;
	}

#ifndef HAVE_MMAP
	/* no mmap() system call, use dbless mode */
	VERBOSITY(1, (LOG_INFO, "no mmap(), ignoring database %s", filename));
	db->udb = NULL;
	(void)fd; (void)opt;
	return db;
#else /* HAVE_MMAP */

	/* attempt to open, if does not exist, create a new one */
	fd = open(filename, O_RDWR);
	if(fd == -1) {
		if(errno != ENOENT) {
			log_msg(LOG_ERR, "%s: %s", filename, strerror(errno));
			region_destroy(db_region);
			return NULL;
		}
	}
d456 1
a457 1
#endif /* HAVE_MMAP */
d483 1
a483 1
	if(!nsd->db || !zone || !zone->opts || !zone->opts->pattern->zonefile)
d496 3
a498 10
		const char* zone_fname = zone->filename;
		time_t zone_mtime = zone->mtime;
		if(nsd->db->udb) {
			zone_fname = udb_zone_get_file_str(nsd->db->udb,
				dname_name(domain_dname(zone->apex)),
				domain_dname(zone->apex)->name_size);
			zone_mtime = (time_t)udb_zone_get_mtime(nsd->db->udb,
				dname_name(domain_dname(zone->apex)),
				domain_dname(zone->apex)->name_size);
		}
d503 3
a505 1
		if(!zone_fname && zone_mtime >= mtime) {
d513 4
a516 1
		   strcmp(zone_fname, fname) == 0 && zone_mtime >= mtime) {
d535 2
d549 6
a554 27
		if(nsd->db->udb) {
			region_type* dname_region;
			udb_ptr z;
			/* see if we can revert to the udb stored version */
			if(!udb_zone_search(nsd->db->udb, &z, dname_name(domain_dname(
				zone->apex)), domain_dname(zone->apex)->name_size)) {
				/* tell that zone contents has been lost */
				if(taskudb) task_new_soainfo(taskudb, last_task, zone, 0);
				return;
			}
			/* read from udb */
			dname_region = region_create(xalloc, free);
			udb_rrsets = 0;
			udb_rrset_count = ZONE(&z)->rrset_count;
			udb_time = time(NULL);
			read_zone_data(nsd->db->udb, nsd->db, dname_region, &z, zone);
			region_destroy(dname_region);
			udb_ptr_unlink(&z, nsd->db->udb);
		} else {
			if(zone->filename)
				region_recycle(nsd->db->region, zone->filename,
					strlen(zone->filename)+1);
			zone->filename = NULL;
			if(zone->logstr)
				region_recycle(nsd->db->region, zone->logstr,
					strlen(zone->logstr)+1);
			zone->logstr = NULL;
d556 8
d570 2
a571 7
		if(nsd->db->udb) {
			if(!write_zone_to_udb(nsd->db->udb, zone, mtime, fname)) {
				log_msg(LOG_ERR, "failed to store zone in db");
			} else {
				VERBOSITY(2, (LOG_INFO, "zone %s written to db",
					zone->opts->name));
			}
d573 2
a574 9
			zone->mtime = mtime;
			if(zone->filename)
				region_recycle(nsd->db->region, zone->filename,
					strlen(zone->filename)+1);
			zone->filename = region_strdup(nsd->db->region, fname);
			if(zone->logstr)
				region_recycle(nsd->db->region, zone->logstr,
					strlen(zone->logstr)+1);
			zone->logstr = NULL;
a602 1
		if(nsd->signal_hint_shutdown) break;
@


1.1.1.12
log
@update to NSD 4.1.1, ok sthen@@
@
text
@a274 1
	zone->zonestatid = 0;
@


1.1.1.13
log
@update to NSD 4.1.3, ok florian@@, also tested by brad
@
text
@d159 2
a160 2
	rrset->rrs = (rr_type *) region_alloc_array(
		db->region, rrset->rr_count, sizeof(rr_type));
a290 1
		zone->apex->is_apex = 0;
d610 1
a610 1
		VERBOSITY(1, (LOG_INFO, "zone %s read with success",
@


