head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.2
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	NSD_4_1_6:1.1.1.17
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	NSD_4_1_3:1.1.1.17
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	NSD_4_1_1:1.1.1.16
	NSD_4_1_0:1.1.1.15
	OPENBSD_5_6:1.1.1.14.0.4
	OPENBSD_5_6_BASE:1.1.1.14
	NSD_4_0_3:1.1.1.14
	NSD_4_0_2:1.1.1.14
	OPENBSD_5_5:1.1.1.13.0.4
	OPENBSD_5_5_BASE:1.1.1.13
	NSD_4_0_1:1.1.1.13
	NSD_4_0_0:1.1.1.12
	NSD_3_2_16:1.1.1.11
	OPENBSD_5_4:1.1.1.10.0.4
	OPENBSD_5_4_BASE:1.1.1.10
	OPENBSD_5_3:1.1.1.10.0.2
	OPENBSD_5_3_BASE:1.1.1.10
	NSD_3_2_15:1.1.1.10
	NSD_3_2_14:1.1.1.9
	NSD_3_2_13:1.1.1.8
	OPENBSD_5_2:1.1.1.7.0.2
	OPENBSD_5_2_BASE:1.1.1.7
	NSD_3_2_11:1.1.1.7
	NSD_3_2_10:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.2
	NSD_3_2_9:1.1.1.5
	OPENBSD_5_0:1.1.1.4.0.2
	OPENBSD_5_0_BASE:1.1.1.4
	NSD_3_2_8:1.1.1.4
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	NSD_3_2_6:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.2
	OPENBSD_4_8_BASE:1.1.1.2
	NSD_3_2_5:1.1.1.2
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2017.04.15.09.15.45;	author florian;	state Exp;
branches;
next	1.7;
commitid	fXBqT4bSlfjTKAVE;

1.7
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.6;
commitid	WmSuN5M3Jbe54113;

1.6
date	2016.10.24.09.44.43;	author florian;	state Exp;
branches;
next	1.5;
commitid	g3wASIhTcujU0LFi;

1.5
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.4;
commitid	Z9jVKJJMPmC3zw2t;

1.4
date	2015.07.17.17.36.33;	author sthen;	state Exp;
branches;
next	1.3;
commitid	2WtkENMkCz3GhSbE;

1.3
date	2015.02.03.10.40.02;	author brad;	state Exp;
branches;
next	1.2;
commitid	MI9j0d0LR8Dk9lnd;

1.2
date	2014.12.18.23.26.12;	author brad;	state Exp;
branches;
next	1.1;
commitid	rBaz3dZHAQwIDT3j;

1.1
date	2010.01.15.19.25.02;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.25.02;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.04.15.20.56.50;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.08.22.09.21.44;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.05.21.18.17.10;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.01.29.11.15.31;	author jakob;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.03.02.08.38.49;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2012.07.09.21.55.06;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2012.08.28.15.11.39;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.11.23.20.29.15;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.02.18.10.17.43;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.09.03.09.21.36;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.11.26.12.50.19;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.02.04.01.54.06;	author brad;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.13.02.00.27;	author brad;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.09.16.16.54.03;	author brad;	state Exp;
branches;
next	1.1.1.16;
commitid	BWSdZeElrpYSRdME;

1.1.1.16
date	2015.02.03.10.24.32;	author brad;	state Exp;
branches;
next	1.1.1.17;
commitid	yn8l9RVkmdMVYIfl;

1.1.1.17
date	2015.07.17.17.36.01;	author sthen;	state Exp;
branches;
next	;
commitid	Jeq5uGP63ff7nS9K;


desc
@@


1.8
log
@update to 4.1.16rc1
tests & OK sthen

(if there are more changes coming for 4.1.16 release we will just
commit them on top)
@
text
@/*
 * difffile.c - DIFF file handling source code. Read and write diff files.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include "config.h"
#include <assert.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include "difffile.h"
#include "xfrd-disk.h"
#include "util.h"
#include "packet.h"
#include "rdata.h"
#include "udb.h"
#include "udbzone.h"
#include "nsec3.h"
#include "nsd.h"
#include "rrl.h"

static int
write_64(FILE *out, uint64_t val)
{
	return write_data(out, &val, sizeof(val));
}

static int
write_32(FILE *out, uint32_t val)
{
	val = htonl(val);
	return write_data(out, &val, sizeof(val));
}

static int
write_8(FILE *out, uint8_t val)
{
	return write_data(out, &val, sizeof(val));
}

static int
write_str(FILE *out, const char* str)
{
	uint32_t len = strlen(str);
	if(!write_32(out, len))
		return 0;
	return write_data(out, str, len);
}

void
diff_write_packet(const char* zone, const char* pat, uint32_t old_serial,
	uint32_t new_serial, uint32_t seq_nr, uint8_t* data, size_t len,
	struct nsd* nsd, uint64_t filenumber)
{
	FILE* df = xfrd_open_xfrfile(nsd, filenumber, seq_nr?"a":"w");
	if(!df) {
		log_msg(LOG_ERR, "could not open transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
		return;
	}

	/* if first part, first write the header */
	if(seq_nr == 0) {
		struct timeval tv;
		if (gettimeofday(&tv, NULL) != 0) {
			log_msg(LOG_ERR, "could not get timestamp for %s: %s",
				zone, strerror(errno));
		}
		if(!write_32(df, DIFF_PART_XFRF) ||
			!write_8(df, 0) /* notcommitted(yet) */ ||
			!write_32(df, 0) /* numberofparts when done */ ||
			!write_64(df, (uint64_t) tv.tv_sec) ||
			!write_32(df, (uint32_t) tv.tv_usec) ||
			!write_32(df, old_serial) ||
			!write_32(df, new_serial) ||
			!write_64(df, (uint64_t) tv.tv_sec) ||
			!write_32(df, (uint32_t) tv.tv_usec) ||
			!write_str(df, zone) ||
			!write_str(df, pat)) {
			log_msg(LOG_ERR, "could not write transfer %s file %lld: %s",
				zone, (long long)filenumber, strerror(errno));
			fclose(df);
			return;
		}
	}

	if(!write_32(df, DIFF_PART_XXFR) ||
		!write_32(df, len) ||
		!write_data(df, data, len) ||
		!write_32(df, len))
	{
		log_msg(LOG_ERR, "could not write transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
	}
	fclose(df);
}

void
diff_write_commit(const char* zone, uint32_t old_serial, uint32_t new_serial,
	uint32_t num_parts, uint8_t commit, const char* log_str,
	struct nsd* nsd, uint64_t filenumber)
{
	struct timeval tv;
	FILE* df;

	if (gettimeofday(&tv, NULL) != 0) {
		log_msg(LOG_ERR, "could not set timestamp for %s: %s",
			zone, strerror(errno));
	}

	/* overwrite the first part of the file with 'committed = 1', 
	 * as well as the end_time and number of parts.
	 * also write old_serial and new_serial, so that a bad file mixup
	 * will result in unusable serial numbers. */

	df = xfrd_open_xfrfile(nsd, filenumber, "r+");
	if(!df) {
		log_msg(LOG_ERR, "could not open transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
		return;
	}
	if(!write_32(df, DIFF_PART_XFRF) ||
		!write_8(df, commit) /* committed */ ||
		!write_32(df, num_parts) ||
		!write_64(df, (uint64_t) tv.tv_sec) ||
		!write_32(df, (uint32_t) tv.tv_usec) ||
		!write_32(df, old_serial) ||
		!write_32(df, new_serial))
	{
		log_msg(LOG_ERR, "could not write transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
		fclose(df);
		return;
	}

	/* append the log_str to the end of the file */
	if(fseek(df, 0, SEEK_END) == -1) {
		log_msg(LOG_ERR, "could not fseek transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
		fclose(df);
		return;
	}
	if(!write_str(df, log_str)) {
		log_msg(LOG_ERR, "could not write transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
		fclose(df);
		return;

	}
	fflush(df);
	fclose(df);
}

int
diff_read_64(FILE *in, uint64_t* result)
{
	if (fread(result, sizeof(*result), 1, in) == 1) {
		return 1;
	} else {
		return 0;
	}
}

int
diff_read_32(FILE *in, uint32_t* result)
{
	if (fread(result, sizeof(*result), 1, in) == 1) {
		*result = ntohl(*result);
		return 1;
	} else {
		return 0;
	}
}

int
diff_read_8(FILE *in, uint8_t* result)
{
        if (fread(result, sizeof(*result), 1, in) == 1) {
                return 1;
        } else {
                return 0;
        }
}

int
diff_read_str(FILE* in, char* buf, size_t len)
{
	uint32_t disklen;
	if(!diff_read_32(in, &disklen))
		return 0;
	if(disklen >= len)
		return 0;
	if(fread(buf, disklen, 1, in) != 1)
		return 0;
	buf[disklen] = 0;
	return 1;
}

static void
add_rdata_to_recyclebin(namedb_type* db, rr_type* rr)
{
	/* add rdatas to recycle bin. */
	size_t i;
	for(i=0; i<rr->rdata_count; i++)
	{
		if(!rdata_atom_is_domain(rr->type, i))
			region_recycle(db->region, rr->rdatas[i].data,
				rdata_atom_size(rr->rdatas[i])
				+ sizeof(uint16_t));
	}
	region_recycle(db->region, rr->rdatas,
		sizeof(rdata_atom_type)*rr->rdata_count);
}

/* this routine determines if below a domain there exist names with
 * data (is_existing) or no names below the domain have data.
 */
static int
has_data_below(domain_type* top)
{
	domain_type* d = top;
	assert(d != NULL);
	/* in the canonical ordering subdomains are after this name */
	d = domain_next(d);
	while(d != NULL && domain_is_subdomain(d, top)) {
		if(d->is_existing)
			return 1;
		d = domain_next(d);
	}
	return 0;
}

/** check if domain with 0 rrsets has become empty (nonexist) */
static domain_type*
rrset_zero_nonexist_check(domain_type* domain, domain_type* ce)
{
	/* is the node now an empty node (completely deleted) */
	if(domain->rrsets == 0) {
		/* if there is no data below it, it becomes non existing.
		   also empty nonterminals above it become nonexisting */
		/* check for data below this node. */
		if(!has_data_below(domain)) {
			/* nonexist this domain and all parent empty nonterminals */
			domain_type* p = domain;
			while(p != NULL && p->rrsets == 0) {
				if(p == ce || has_data_below(p))
					return p;
				p->is_existing = 0;
				/* fixup wildcard child of parent */
				if(p->parent &&
					p->parent->wildcard_child_closest_match == p)
					p->parent->wildcard_child_closest_match = domain_previous_existing_child(p);
				p = p->parent;
			}
		}
	}
	return NULL;
}

/** remove rrset.  Adjusts zone params.  Does not remove domain */
static void
rrset_delete(namedb_type* db, domain_type* domain, rrset_type* rrset)
{
	int i;
	/* find previous */
	rrset_type** pp = &domain->rrsets;
	while(*pp && *pp != rrset) {
		pp = &( (*pp)->next );
	}
	if(!*pp) {
		/* rrset does not exist for domain */
		return;
	}
	*pp = rrset->next;

	DEBUG(DEBUG_XFRD,2, (LOG_INFO, "delete rrset of %s type %s",
		domain_to_string(domain),
		rrtype_to_string(rrset_rrtype(rrset))));

	/* is this a SOA rrset ? */
	if(rrset->zone->soa_rrset == rrset) {
		rrset->zone->soa_rrset = 0;
	}
	if(rrset->zone->ns_rrset == rrset) {
		rrset->zone->ns_rrset = 0;
	}
	if(domain == rrset->zone->apex && rrset_rrtype(rrset) == TYPE_RRSIG) {
		for (i = 0; i < rrset->rr_count; ++i) {
			if(rr_rrsig_type_covered(&rrset->rrs[i])==TYPE_DNSKEY) {
				rrset->zone->is_secure = 0;
				break;
			}
		}
	}
	/* recycle the memory space of the rrset */
	for (i = 0; i < rrset->rr_count; ++i)
		add_rdata_to_recyclebin(db, &rrset->rrs[i]);
	region_recycle(db->region, rrset->rrs,
		sizeof(rr_type) * rrset->rr_count);
	rrset->rr_count = 0;
	region_recycle(db->region, rrset, sizeof(rrset_type));
}

static int
rdatas_equal(rdata_atom_type *a, rdata_atom_type *b, int num, uint16_t type,
	int* rdnum, char** reason)
{
	int k, start, end;
	start = 0;
	end = num;
	/**
	 * SOA RDATA comparisons in XFR are more lenient,
	 * only serial rdata is checked.
	 **/
	if (type == TYPE_SOA) {
		start = 2;
		end = 3;
	}
	for(k = start; k < end; k++)
	{
		if(rdata_atom_is_domain(type, k)) {
			if(dname_compare(domain_dname(a[k].domain),
				domain_dname(b[k].domain))!=0) {
				*rdnum = k;
				*reason = "dname data";
				return 0;
			}
		} else if(rdata_atom_is_literal_domain(type, k)) {
			/* literal dname, but compare case insensitive */
			if(a[k].data[0] != b[k].data[0]) {
				*rdnum = k;
				*reason = "literal dname len";
				return 0; /* uncompressed len must be equal*/
			}
			if(!dname_equal_nocase((uint8_t*)(a[k].data+1),
				(uint8_t*)(b[k].data+1), a[k].data[0])) {
				*rdnum = k;
				*reason = "literal dname data";
				return 0;
			}
		} else {
			/* check length */
			if(a[k].data[0] != b[k].data[0]) {
				*rdnum = k;
				*reason = "rdata len";
				return 0;
			}
			/* check data */
			if(memcmp(a[k].data+1, b[k].data+1, a[k].data[0])!=0) {
				*rdnum = k;
				*reason = "rdata data";
				return 0;
			}
		}
	}
	return 1;
}

static void
debug_find_rr_num(rrset_type* rrset, uint16_t type, uint16_t klass,
	rdata_atom_type *rdatas, ssize_t rdata_num)
{
	int i, rd;
	char* reason = "";

	for(i=0; i < rrset->rr_count; ++i) {
		if (rrset->rrs[i].type != type) {
			log_msg(LOG_WARNING, "diff: RR <%s, %s> does not match "
				"RR num %d type %s",
				dname_to_string(domain_dname(rrset->rrs[i].owner),0),
				rrtype_to_string(type),	i,
				rrtype_to_string(rrset->rrs[i].type));
		}
		if (rrset->rrs[i].klass != klass) {
			log_msg(LOG_WARNING, "diff: RR <%s, %s> class %d "
				"does not match RR num %d class %d",
				dname_to_string(domain_dname(rrset->rrs[i].owner),0),
				rrtype_to_string(type),
				klass, i,
				rrset->rrs[i].klass);
		}
		if (rrset->rrs[i].rdata_count != rdata_num) {
			log_msg(LOG_WARNING, "diff: RR <%s, %s> rdlen %u "
				"does not match RR num %d rdlen %d",
				dname_to_string(domain_dname(rrset->rrs[i].owner),0),
				rrtype_to_string(type),
				(unsigned) rdata_num, i,
				(unsigned) rrset->rrs[i].rdata_count);
		}
		if (!rdatas_equal(rdatas, rrset->rrs[i].rdatas, rdata_num, type,
			&rd, &reason)) {
			log_msg(LOG_WARNING, "diff: RR <%s, %s> rdata element "
				"%d differs from RR num %d rdata (%s)",
				dname_to_string(domain_dname(rrset->rrs[i].owner),0),
				rrtype_to_string(type),
				rd, i, reason);
		}
	}
}

static int
find_rr_num(rrset_type* rrset, uint16_t type, uint16_t klass,
	rdata_atom_type *rdatas, ssize_t rdata_num, int add)
{
	int i, rd;
	char* reason;

	for(i=0; i < rrset->rr_count; ++i) {
		if(rrset->rrs[i].type == type &&
		   rrset->rrs[i].klass == klass &&
		   rrset->rrs[i].rdata_count == rdata_num &&
		   rdatas_equal(rdatas, rrset->rrs[i].rdatas, rdata_num, type,
			&rd, &reason))
		{
			return i;
		}
	}
        /* this is odd. Log why rr cannot be found. */
	if (!add) {
		debug_find_rr_num(rrset, type, klass, rdatas, rdata_num);
	}
	return -1;
}

#ifdef NSEC3
/* see if nsec3 deletion triggers need action */
static void
nsec3_delete_rr_trigger(namedb_type* db, rr_type* rr, zone_type* zone,
	udb_ptr* udbz)
{
	/* the RR has not actually been deleted yet, so we can inspect it */
	if(!zone->nsec3_param)
		return;
	/* see if the domain was an NSEC3-domain in the chain, but no longer */
	if(rr->type == TYPE_NSEC3 && rr->owner->nsec3 &&
		rr->owner->nsec3->nsec3_node.key &&
		nsec3_rr_uses_params(rr, zone) &&
		nsec3_in_chain_count(rr->owner, zone) <= 1) {
		domain_type* prev = nsec3_chain_find_prev(zone, rr->owner);
		/* remove from prehash because no longer an NSEC3 domain */
		if(domain_is_prehash(db->domains, rr->owner))
			prehash_del(db->domains, rr->owner);
		/* fixup the last in the zone */
		if(rr->owner == zone->nsec3_last)
			zone->nsec3_last = prev;
		/* unlink from the nsec3tree */
		zone_del_domain_in_hash_tree(zone->nsec3tree,
			&rr->owner->nsec3->nsec3_node);
		/* add previous NSEC3 to the prehash list */
		if(prev && prev != rr->owner)
			prehash_add(db->domains, prev);
		else	nsec3_clear_precompile(db, zone);
		/* this domain becomes ordinary data domain: done later */
	}
	/* see if the rr was NSEC3PARAM that we were using */
	else if(rr->type == TYPE_NSEC3PARAM && rr == zone->nsec3_param) {
		/* clear trees, wipe hashes, wipe precompile */
		nsec3_clear_precompile(db, zone);
		/* pick up new nsec3param (from udb, or avoid deleted rr) */
		nsec3_find_zone_param(db, zone, udbz, rr);
		/* if no more NSEC3, done */
		if(!zone->nsec3_param)
			return;
		nsec3_precompile_newparam(db, zone);
	}
}

/* see if nsec3 prehash can be removed with new rrset content */
static void
nsec3_rrsets_changed_remove_prehash(domain_type* domain, zone_type* zone)
{
	/* deletion of rrset already done, we can check if conditions apply */
	/* see if the domain is no longer precompiled */
	/* it has a hash_node, but no longer fulfills conditions */
	if(nsec3_domain_part_of_zone(domain, zone) && domain->nsec3 &&
		domain->nsec3->hash_node.key &&
		!nsec3_condition_hash(domain, zone)) {
		/* remove precompile */
		domain->nsec3->nsec3_cover = NULL;
		domain->nsec3->nsec3_wcard_child_cover = NULL;
		domain->nsec3->nsec3_is_exact = 0;
		/* remove it from the hash tree */
		zone_del_domain_in_hash_tree(zone->hashtree,
			&domain->nsec3->hash_node);
		zone_del_domain_in_hash_tree(zone->wchashtree,
			&domain->nsec3->wchash_node);
	}
	if(domain != zone->apex && domain->nsec3 &&
		domain->nsec3->dshash_node.key &&
		(!domain->parent || nsec3_domain_part_of_zone(domain->parent, zone)) &&
		!nsec3_condition_dshash(domain, zone)) {
		/* remove precompile */
		domain->nsec3->nsec3_ds_parent_cover = NULL;
		domain->nsec3->nsec3_ds_parent_is_exact = 0;
		/* remove it from the hash tree */
		zone_del_domain_in_hash_tree(zone->dshashtree,
			&domain->nsec3->dshash_node);
	}
}

/* see if domain needs to get precompiled info */
static void
nsec3_rrsets_changed_add_prehash(namedb_type* db, domain_type* domain,
	zone_type* zone)
{
	if(!zone->nsec3_param)
		return;
	if((!domain->nsec3 || !domain->nsec3->hash_node.key)
		&& nsec3_condition_hash(domain, zone)) {
		region_type* tmpregion = region_create(xalloc, free);
		nsec3_precompile_domain(db, domain, zone, tmpregion);
		region_destroy(tmpregion);
	}
	if((!domain->nsec3 || !domain->nsec3->dshash_node.key)
		&& nsec3_condition_dshash(domain, zone)) {
		nsec3_precompile_domain_ds(db, domain, zone);
	}
}

/* see if nsec3 rrset-deletion triggers need action */
static void
nsec3_delete_rrset_trigger(namedb_type* db, domain_type* domain,
	zone_type* zone, uint16_t type)
{
	if(!zone->nsec3_param)
		return;
	nsec3_rrsets_changed_remove_prehash(domain, zone);
	/* for type nsec3, or a delegation, the domain may have become a
	 * 'normal' domain with its remaining data now */
	if(type == TYPE_NSEC3 || type == TYPE_NS || type == TYPE_DS)
		nsec3_rrsets_changed_add_prehash(db, domain, zone);
	/* for type DNAME or a delegation, obscured data may be revealed */
	if(type == TYPE_NS || type == TYPE_DS || type == TYPE_DNAME) {
		/* walk over subdomains and check them each */
		domain_type *d;
		for(d=domain_next(domain); d && domain_is_subdomain(d, domain);
			d=domain_next(d)) {
			nsec3_rrsets_changed_add_prehash(db, d, zone);
		}
	}
}

/* see if nsec3 addition triggers need action */
static void
nsec3_add_rr_trigger(namedb_type* db, rr_type* rr, zone_type* zone,
	udb_ptr* udbz)
{
	/* the RR has been added in full, also to UDB (and thus NSEC3PARAM 
	 * in the udb has been adjusted) */
	if(zone->nsec3_param && rr->type == TYPE_NSEC3 &&
		(!rr->owner->nsec3 || !rr->owner->nsec3->nsec3_node.key)
		&& nsec3_rr_uses_params(rr, zone)) {
		/* added NSEC3 into the chain */
		nsec3_precompile_nsec3rr(db, rr->owner, zone);
		/* the domain has become an NSEC3-domain, if it was precompiled
		 * previously, remove that, neatly done in routine above */
		nsec3_rrsets_changed_remove_prehash(rr->owner, zone);
		/* set this NSEC3 to prehash */
		prehash_add(db->domains, rr->owner);
	} else if(!zone->nsec3_param && rr->type == TYPE_NSEC3PARAM) {
		/* see if this means NSEC3 chain can be used */
		nsec3_find_zone_param(db, zone, udbz, NULL);
		if(!zone->nsec3_param)
			return;
		nsec3_zone_trees_create(db->region, zone);
		nsec3_precompile_newparam(db, zone);
	}
}

/* see if nsec3 rrset-addition triggers need action */
static void
nsec3_add_rrset_trigger(namedb_type* db, domain_type* domain, zone_type* zone,
	uint16_t type)
{
	/* the rrset has been added so we can inspect it */
	if(!zone->nsec3_param)
		return;
	/* because the rrset is added we can check conditions easily.
	 * check if domain needs to become precompiled now */
	nsec3_rrsets_changed_add_prehash(db, domain, zone);
	/* if a delegation, it changes from normal name to unhashed referral */
	if(type == TYPE_NS || type == TYPE_DS) {
		nsec3_rrsets_changed_remove_prehash(domain, zone);
	}
	/* if delegation or DNAME added, then some RRs may get obscured */
	if(type == TYPE_NS || type == TYPE_DS || type == TYPE_DNAME) {
		/* walk over subdomains and check them each */
		domain_type *d;
		for(d=domain_next(domain); d && domain_is_subdomain(d, domain);
			d=domain_next(d)) {
			nsec3_rrsets_changed_remove_prehash(d, zone);
		}
	}
}
#endif /* NSEC3 */

/* fixup usage lower for domain names in the rdata */
static void
rr_lower_usage(namedb_type* db, rr_type* rr)
{
	unsigned i;
	for(i=0; i<rr->rdata_count; i++) {
		if(rdata_atom_is_domain(rr->type, i)) {
			assert(rdata_atom_domain(rr->rdatas[i])->usage > 0);
			rdata_atom_domain(rr->rdatas[i])->usage --;
			if(rdata_atom_domain(rr->rdatas[i])->usage == 0)
				domain_table_deldomain(db,
					rdata_atom_domain(rr->rdatas[i]));
		}
	}
}

static void
rrset_lower_usage(namedb_type* db, rrset_type* rrset)
{
	unsigned i;
	for(i=0; i<rrset->rr_count; i++)
		rr_lower_usage(db, &rrset->rrs[i]);
}

int
delete_RR(namedb_type* db, const dname_type* dname,
	uint16_t type, uint16_t klass,
	buffer_type* packet, size_t rdatalen, zone_type *zone,
	region_type* temp_region, udb_ptr* udbz, int* softfail)
{
	domain_type *domain;
	rrset_type *rrset;
	domain = domain_table_find(db->domains, dname);
	if(!domain) {
		log_msg(LOG_WARNING, "diff: domain %s does not exist",
			dname_to_string(dname,0));
		buffer_skip(packet, rdatalen);
		*softfail = 1;
		return 1; /* not fatal error */
	}
	rrset = domain_find_rrset(domain, zone, type);
	if(!rrset) {
		log_msg(LOG_WARNING, "diff: rrset %s does not exist",
			dname_to_string(dname,0));
		buffer_skip(packet, rdatalen);
		*softfail = 1;
		return 1; /* not fatal error */
	} else {
		/* find the RR in the rrset */
		domain_table_type *temptable;
		rdata_atom_type *rdatas;
		ssize_t rdata_num;
		int rrnum;
		temptable = domain_table_create(temp_region);
		/* This will ensure that the dnames in rdata are
		 * normalized, conform RFC 4035, section 6.2
		 */
		rdata_num = rdata_wireformat_to_rdata_atoms(
			temp_region, temptable, type, rdatalen, packet, &rdatas);
		if(rdata_num == -1) {
			log_msg(LOG_ERR, "diff: bad rdata for %s",
				dname_to_string(dname,0));
			return 0;
		}
		rrnum = find_rr_num(rrset, type, klass, rdatas, rdata_num, 0);
		if(rrnum == -1 && type == TYPE_SOA && domain == zone->apex
			&& rrset->rr_count != 0)
			rrnum = 0; /* replace existing SOA if no match */
		if(rrnum == -1) {
			log_msg(LOG_WARNING, "diff: RR <%s, %s> does not exist",
				dname_to_string(dname,0), rrtype_to_string(type));
			*softfail = 1;
			return 1; /* not fatal error */
		}
		/* delete the normalized RR from the udb */
		if(db->udb)
			udb_del_rr(db->udb, udbz, &rrset->rrs[rrnum]);
#ifdef NSEC3
		/* process triggers for RR deletions */
		nsec3_delete_rr_trigger(db, &rrset->rrs[rrnum], zone, udbz);
#endif
		/* lower usage (possibly deleting other domains, and thus
		 * invalidating the current RR's domain pointers) */
		rr_lower_usage(db, &rrset->rrs[rrnum]);
		if(rrset->rr_count == 1) {
			/* delete entire rrset */
			rrset_delete(db, domain, rrset);
			/* check if domain is now nonexisting (or parents) */
			rrset_zero_nonexist_check(domain, NULL);
#ifdef NSEC3
			/* cleanup nsec3 */
			nsec3_delete_rrset_trigger(db, domain, zone, type);
#endif
			/* see if the domain can be deleted (and inspect parents) */
			domain_table_deldomain(db, domain);
		} else {
			/* swap out the bad RR and decrease the count */
			rr_type* rrs_orig = rrset->rrs;
			add_rdata_to_recyclebin(db, &rrset->rrs[rrnum]);
			if(rrnum < rrset->rr_count-1)
				rrset->rrs[rrnum] = rrset->rrs[rrset->rr_count-1];
			memset(&rrset->rrs[rrset->rr_count-1], 0, sizeof(rr_type));
			/* realloc the rrs array one smaller */
			rrset->rrs = region_alloc_array_init(db->region, rrs_orig,
				(rrset->rr_count-1), sizeof(rr_type));
			if(!rrset->rrs) {
				log_msg(LOG_ERR, "out of memory, %s:%d", __FILE__, __LINE__);
				exit(1);
			}
			region_recycle(db->region, rrs_orig,
				sizeof(rr_type) * rrset->rr_count);
#ifdef NSEC3
			if(type == TYPE_NSEC3PARAM && zone->nsec3_param) {
				/* fixup nsec3_param pointer to same RR */
				assert(zone->nsec3_param >= rrs_orig &&
					zone->nsec3_param <=
					rrs_orig+rrset->rr_count);
				/* last moved to rrnum, others at same index*/
				if(zone->nsec3_param == &rrs_orig[
					rrset->rr_count-1])
					zone->nsec3_param = &rrset->rrs[rrnum];
				else
					zone->nsec3_param =
						(void*)zone->nsec3_param
						-(void*)rrs_orig +
						(void*)rrset->rrs;
			}
#endif /* NSEC3 */
			rrset->rr_count --;
#ifdef NSEC3
			/* for type nsec3, the domain may have become a
			 * 'normal' domain with its remaining data now */
			if(type == TYPE_NSEC3)
				nsec3_rrsets_changed_add_prehash(db, domain,
					zone);
#endif /* NSEC3 */
		}
	}
	return 1;
}

int
add_RR(namedb_type* db, const dname_type* dname,
	uint16_t type, uint16_t klass, uint32_t ttl,
	buffer_type* packet, size_t rdatalen, zone_type *zone, udb_ptr* udbz,
	int* softfail)
{
	domain_type* domain;
	rrset_type* rrset;
	rdata_atom_type *rdatas;
	rr_type *rrs_old;
	ssize_t rdata_num;
	int rrnum;
#ifdef NSEC3
	int rrset_added = 0;
#endif
	domain = domain_table_find(db->domains, dname);
	if(!domain) {
		/* create the domain */
		domain = domain_table_insert(db->domains, dname);
	}
	rrset = domain_find_rrset(domain, zone, type);
	if(!rrset) {
		/* create the rrset */
		rrset = region_alloc(db->region, sizeof(rrset_type));
		if(!rrset) {
			log_msg(LOG_ERR, "out of memory, %s:%d", __FILE__, __LINE__);
			exit(1);
		}
		rrset->zone = zone;
		rrset->rrs = 0;
		rrset->rr_count = 0;
		domain_add_rrset(domain, rrset);
#ifdef NSEC3
		rrset_added = 1;
#endif
	}

	/* dnames in rdata are normalized, conform RFC 4035,
	 * Section 6.2
	 */
	rdata_num = rdata_wireformat_to_rdata_atoms(
		db->region, db->domains, type, rdatalen, packet, &rdatas);
	if(rdata_num == -1) {
		log_msg(LOG_ERR, "diff: bad rdata for %s",
			dname_to_string(dname,0));
		return 0;
	}
	rrnum = find_rr_num(rrset, type, klass, rdatas, rdata_num, 1);
	if(rrnum != -1) {
		DEBUG(DEBUG_XFRD, 2, (LOG_ERR, "diff: RR <%s, %s> already exists",
			dname_to_string(dname,0), rrtype_to_string(type)));
		/* ignore already existing RR: lenient accepting of messages */
		*softfail = 1;
		return 1;
	}
	if(rrset->rr_count == 65535) {
		log_msg(LOG_ERR, "diff: too many RRs at %s",
			dname_to_string(dname,0));
		return 0;
	}

	/* re-alloc the rrs and add the new */
	rrs_old = rrset->rrs;
	rrset->rrs = region_alloc_array(db->region,
		(rrset->rr_count+1), sizeof(rr_type));
	if(!rrset->rrs) {
		log_msg(LOG_ERR, "out of memory, %s:%d", __FILE__, __LINE__);
		exit(1);
	}
	if(rrs_old)
		memcpy(rrset->rrs, rrs_old, rrset->rr_count * sizeof(rr_type));
	region_recycle(db->region, rrs_old, sizeof(rr_type) * rrset->rr_count);
	rrset->rr_count ++;

	rrset->rrs[rrset->rr_count - 1].owner = domain;
	rrset->rrs[rrset->rr_count - 1].rdatas = rdatas;
	rrset->rrs[rrset->rr_count - 1].ttl = ttl;
	rrset->rrs[rrset->rr_count - 1].type = type;
	rrset->rrs[rrset->rr_count - 1].klass = klass;
	rrset->rrs[rrset->rr_count - 1].rdata_count = rdata_num;

	/* see if it is a SOA */
	if(domain == zone->apex) {
		apex_rrset_checks(db, rrset, domain);
#ifdef NSEC3
		if(type == TYPE_NSEC3PARAM && zone->nsec3_param) {
			/* the pointer just changed, fix it up to point
			 * to the same record */
			assert(zone->nsec3_param >= rrs_old &&
				zone->nsec3_param < rrs_old+rrset->rr_count);
			/* in this order to make sure no overflow/underflow*/
			zone->nsec3_param = (void*)zone->nsec3_param - 
				(void*)rrs_old + (void*)rrset->rrs;
		}
#endif /* NSEC3 */
	}

	/* write the just-normalized RR to the udb */
	if(db->udb) {
		if(!udb_write_rr(db->udb, udbz, &rrset->rrs[rrset->rr_count - 1])) {
			log_msg(LOG_ERR, "could not add RR to nsd.db, disk-space?");
			return 0;
		}
	}
#ifdef NSEC3
	if(rrset_added) {
		domain_type* p = domain->parent;
		nsec3_add_rrset_trigger(db, domain, zone, type);
		/* go up and process (possibly created) empty nonterminals, 
		 * until we hit the apex or root */
		while(p && p->rrsets == NULL && !p->is_apex) {
			nsec3_rrsets_changed_add_prehash(db, p, zone);
			p = p->parent;
		}
	}
	nsec3_add_rr_trigger(db, &rrset->rrs[rrset->rr_count - 1], zone, udbz);
#endif /* NSEC3 */
	return 1;
}

static zone_type*
find_or_create_zone(namedb_type* db, const dname_type* zone_name,
	struct nsd_options* opt, const char* zstr, const char* patname)
{
	zone_type* zone;
	struct zone_options* zopt;
	zone = namedb_find_zone(db, zone_name);
	if(zone) {
		return zone;
	}
	zopt = zone_options_find(opt, zone_name);
	if(!zopt) {
		/* if _implicit_ then insert as _part_of_config */
		if(strncmp(patname, PATTERN_IMPLICIT_MARKER,
			strlen(PATTERN_IMPLICIT_MARKER)) == 0) {
			zopt = zone_options_create(opt->region);
			if(!zopt) return 0;
			zopt->part_of_config = 1;
			zopt->name = region_strdup(opt->region, zstr);
			zopt->pattern = pattern_options_find(opt, patname);
			if(!zopt->name || !zopt->pattern) return 0;
			if(!nsd_options_insert_zone(opt, zopt)) {
				log_msg(LOG_ERR, "bad domain name or duplicate zone '%s' "
					"pattern %s", zstr, patname);
			}
		} else {
			/* create zone : presumably already added to zonelist
			 * by xfrd, who wrote the AXFR or IXFR to disk, so we only
			 * need to add it to our config.
			 * This process does not need linesize and offset zonelist */
			zopt = zone_list_zone_insert(opt, zstr, patname, 0, 0);
			if(!zopt)
				return 0;
		}
	}
	zone = namedb_zone_create(db, zone_name, zopt);
	return zone;
}

void
delete_zone_rrs(namedb_type* db, zone_type* zone)
{
	rrset_type *rrset;
	domain_type *domain = zone->apex, *next;
	int nonexist_check = 0;
	/* go through entire tree below the zone apex (incl subzones) */
	while(domain && domain_is_subdomain(domain, zone->apex))
	{
		DEBUG(DEBUG_XFRD,2, (LOG_INFO, "delete zone visit %s",
			domain_to_string(domain)));
		/* delete all rrsets of the zone */
		while((rrset = domain_find_any_rrset(domain, zone))) {
			/* lower usage can delete other domains */
			rrset_lower_usage(db, rrset);
			/* rrset del does not delete our domain(yet) */
			rrset_delete(db, domain, rrset);
			/* no rrset_zero_nonexist_check, do that later */
			if(domain->rrsets == 0)
				nonexist_check = 1;
		}
		/* the delete upcoming could delete parents, but nothing next
		 * or after the domain so store next ptr */
		next = domain_next(domain);
		/* see if the domain can be deleted (and inspect parents) */
		domain_table_deldomain(db, domain);
		domain = next;
	}

	/* check if data deletions have created nonexisting domain entries,
	 * but after deleting domains so the checks are faster */
	if(nonexist_check) {
		domain_type* ce = NULL; /* for speeding up has_data_below */
		DEBUG(DEBUG_XFRD, 1, (LOG_INFO, "axfrdel: zero rrset check"));
		domain = zone->apex;
		while(domain && domain_is_subdomain(domain, zone->apex))
		{
			/* the interesting domains should be existing==1
			 * and rrsets==0, speeding up out processing of
			 * sub-zones, since we only spuriously check empty
			 * nonterminals */
			if(domain->is_existing)
				ce = rrset_zero_nonexist_check(domain, ce);
			domain = domain_next(domain);
		}
	}

	DEBUG(DEBUG_XFRD, 1, (LOG_INFO, "axfrdel: recyclebin holds %lu bytes",
		(unsigned long) region_get_recycle_size(db->region)));
#ifndef NDEBUG
	if(nsd_debug_level >= 2)
		region_log_stats(db->region);
#endif

	assert(zone->soa_rrset == 0);
	/* keep zone->soa_nx_rrset alloced: it is reused */
	assert(zone->ns_rrset == 0);
	assert(zone->is_secure == 0);
}

/* return value 0: syntaxerror,badIXFR, 1:OK, 2:done_and_skip_it */
static int
apply_ixfr(namedb_type* db, FILE *in, const char* zone, uint32_t serialno,
	struct nsd_options* opt, uint32_t seq_nr, uint32_t seq_total,
	int* is_axfr, int* delete_mode, int* rr_count,
	udb_ptr* udbz, struct zone** zone_res, const char* patname, int* bytes,
	int* softfail)
{
	uint32_t msglen, checklen, pkttype;
	int qcount, ancount, counter;
	buffer_type* packet;
	region_type* region;
	int i;
	uint16_t rrlen;
	const dname_type *dname_zone, *dname;
	zone_type* zone_db;

	/* note that errors could not really happen due to format of the
	 * packet since xfrd has checked all dnames and RRs before commit,
	 * this is why the errors are fatal (exit process), it must be
	 * something internal or a bad disk or something. */

	/* read ixfr packet RRs and apply to in memory db */
	if(!diff_read_32(in, &pkttype) || pkttype != DIFF_PART_XXFR) {
		log_msg(LOG_ERR, "could not read type or wrong type");
		return 0;
	}

	if(!diff_read_32(in, &msglen)) {
		log_msg(LOG_ERR, "could not read len");
		return 0;
	}

	if(msglen < QHEADERSZ) {
		log_msg(LOG_ERR, "msg too short");
		return 0;
	}

	region = region_create(xalloc, free);
	if(!region) {
		log_msg(LOG_ERR, "out of memory");
		return 0;
	}
	packet = buffer_create(region, QIOBUFSZ);
	if(msglen > QIOBUFSZ) {
		log_msg(LOG_ERR, "msg too long");
		region_destroy(region);
		return 0;
	}
	buffer_clear(packet);
	if(fread(buffer_begin(packet), msglen, 1, in) != 1) {
		log_msg(LOG_ERR, "short fread: %s", strerror(errno));
		region_destroy(region);
		return 0;
	}
	buffer_set_limit(packet, msglen);

	/* see if check on data fails: checks that we are not reading
	 * random garbage */
	if(!diff_read_32(in, &checklen) || checklen != msglen) {
		log_msg(LOG_ERR, "transfer part has incorrect checkvalue");
		return 0;
	}
	*bytes += msglen;

	dname_zone = dname_parse(region, zone);
	zone_db = find_or_create_zone(db, dname_zone, opt, zone, patname);
	if(!zone_db) {
		log_msg(LOG_ERR, "could not create zone %s %s", zone, patname);
		region_destroy(region);
		return 0;
	}
	*zone_res = zone_db;

	/* only answer section is really used, question, additional and
	   authority section RRs are skipped */
	qcount = QDCOUNT(packet);
	ancount = ANCOUNT(packet);
	buffer_skip(packet, QHEADERSZ);

	/* skip queries */
	for(i=0; i<qcount; ++i)
		if(!packet_skip_rr(packet, 1)) {
			log_msg(LOG_ERR, "bad RR in question section");
			region_destroy(region);
			return 0;
		}

	DEBUG(DEBUG_XFRD,2, (LOG_INFO, "diff: started packet for zone %s",
			dname_to_string(dname_zone, 0)));
	/* first RR: check if SOA and correct zone & serialno */
	if(*rr_count == 0) {
		DEBUG(DEBUG_XFRD,2, (LOG_INFO, "diff: %s parse first RR",
			dname_to_string(dname_zone, 0)));
		dname = dname_make_from_packet(region, packet, 1, 1);
		if(!dname) {
			log_msg(LOG_ERR, "could not parse dname");
			region_destroy(region);
			return 0;
		}
		if(dname_compare(dname_zone, dname) != 0) {
			log_msg(LOG_ERR, "SOA dname %s not equal to zone",
				dname_to_string(dname,0));
			log_msg(LOG_ERR, "zone dname is %s",
				dname_to_string(dname_zone,0));
			region_destroy(region);
			return 0;
		}
		if(!buffer_available(packet, 10)) {
			log_msg(LOG_ERR, "bad SOA RR");
			region_destroy(region);
			return 0;
		}
		if(buffer_read_u16(packet) != TYPE_SOA ||
			buffer_read_u16(packet) != CLASS_IN) {
			log_msg(LOG_ERR, "first RR not SOA IN");
			region_destroy(region);
			return 0;
		}
		buffer_skip(packet, sizeof(uint32_t)); /* ttl */
		if(!buffer_available(packet, buffer_read_u16(packet)) ||
			!packet_skip_dname(packet) /* skip prim_ns */ ||
			!packet_skip_dname(packet) /* skip email */) {
			log_msg(LOG_ERR, "bad SOA RR");
			region_destroy(region);
			return 0;
		}
		if(buffer_read_u32(packet) != serialno) {
			buffer_skip(packet, -4);
			log_msg(LOG_ERR, "SOA serial %u different from commit %u",
				(unsigned)buffer_read_u32(packet), (unsigned)serialno);
			region_destroy(region);
			return 0;
		}
		buffer_skip(packet, sizeof(uint32_t)*4);
		counter = 1;
		*rr_count = 1;
		*is_axfr = 0;
		*delete_mode = 0;
		DEBUG(DEBUG_XFRD,2, (LOG_INFO, "diff: %s start count %d, ax %d, delmode %d",
			dname_to_string(dname_zone, 0), *rr_count, *is_axfr, *delete_mode));
	}
	else  counter = 0;

	for(; counter < ancount; ++counter,++(*rr_count))
	{
		uint16_t type, klass;
		uint32_t ttl;

		if(!(dname=dname_make_from_packet(region, packet, 1,1))) {
			log_msg(LOG_ERR, "bad xfr RR dname %d", *rr_count);
			region_destroy(region);
			return 0;
		}
		if(!buffer_available(packet, 10)) {
			log_msg(LOG_ERR, "bad xfr RR format %d", *rr_count);
			region_destroy(region);
			return 0;
		}
		type = buffer_read_u16(packet);
		klass = buffer_read_u16(packet);
		ttl = buffer_read_u32(packet);
		rrlen = buffer_read_u16(packet);
		if(!buffer_available(packet, rrlen)) {
			log_msg(LOG_ERR, "bad xfr RR rdata %d, len %d have %d",
				*rr_count, rrlen, (int)buffer_remaining(packet));
			region_destroy(region);
			return 0;
		}
		DEBUG(DEBUG_XFRD,2, (LOG_INFO, "diff: %s parsed count %d, ax %d, delmode %d",
			dname_to_string(dname_zone, 0), *rr_count, *is_axfr, *delete_mode));

		if(*rr_count == 1 && type != TYPE_SOA) {
			/* second RR: if not SOA: this is an AXFR; delete all zone contents */
#ifdef NSEC3
			nsec3_hash_tree_clear(zone_db);
#endif
			delete_zone_rrs(db, zone_db);
			if(db->udb)
				udb_zone_clear(db->udb, udbz);
#ifdef NSEC3
			nsec3_clear_precompile(db, zone_db);
			zone_db->nsec3_param = NULL;
#endif /* NSEC3 */
			/* add everything else (incl end SOA) */
			*delete_mode = 0;
			*is_axfr = 1;
			DEBUG(DEBUG_XFRD,2, (LOG_INFO, "diff: %s sawAXFR count %d, ax %d, delmode %d",
				dname_to_string(dname_zone, 0), *rr_count, *is_axfr, *delete_mode));
		}
		if(*rr_count == 1 && type == TYPE_SOA) {
			/* if the serial no of the SOA equals the serialno, then AXFR */
			size_t bufpos = buffer_position(packet);
			uint32_t thisserial;
			if(!packet_skip_dname(packet) ||
				!packet_skip_dname(packet) ||
				buffer_remaining(packet) < sizeof(uint32_t)*5)
			{
				log_msg(LOG_ERR, "bad xfr SOA RR formerr.");
				region_destroy(region);
				return 0;
			}
			thisserial = buffer_read_u32(packet);
			if(thisserial == serialno) {
				/* AXFR */
#ifdef NSEC3
				nsec3_hash_tree_clear(zone_db);
#endif
				delete_zone_rrs(db, zone_db);
				if(db->udb)
					udb_zone_clear(db->udb, udbz);
#ifdef NSEC3
				nsec3_clear_precompile(db, zone_db);
				zone_db->nsec3_param = NULL;
#endif /* NSEC3 */
				*delete_mode = 0;
				*is_axfr = 1;
			}
			/* must have stuff in memory for a successful IXFR,
			 * the serial number of the SOA has been checked
			 * previously (by check_for_bad_serial) if it exists */
			if(!*is_axfr && !domain_find_rrset(zone_db->apex,
				zone_db, TYPE_SOA)) {
				log_msg(LOG_ERR, "%s SOA serial %u is not "
					"in memory, skip IXFR", zone, serialno);
				region_destroy(region);
				/* break out and stop the IXFR, ignore it */
				return 2;
			}
			buffer_set_position(packet, bufpos);
		}
		if(type == TYPE_SOA && !*is_axfr) {
			/* switch from delete-part to add-part and back again,
			   just before soa - so it gets deleted and added too */
			/* this means we switch to delete mode for the final SOA */
			*delete_mode = !*delete_mode;
			DEBUG(DEBUG_XFRD,2, (LOG_INFO, "diff: %s IXFRswapdel count %d, ax %d, delmode %d",
				dname_to_string(dname_zone, 0), *rr_count, *is_axfr, *delete_mode));
		}
		if(type == TYPE_TSIG || type == TYPE_OPT) {
			/* ignore pseudo RRs */
			buffer_skip(packet, rrlen);
			continue;
		}

		DEBUG(DEBUG_XFRD,2, (LOG_INFO, "xfr %s RR dname is %s type %s",
			*delete_mode?"del":"add",
			dname_to_string(dname,0), rrtype_to_string(type)));
		if(*delete_mode) {
			/* delete this rr */
			if(!*is_axfr && type == TYPE_SOA && counter==ancount-1
				&& seq_nr == seq_total-1) {
				continue; /* do not delete final SOA RR for IXFR */
			}
			if(!delete_RR(db, dname, type, klass, packet,
				rrlen, zone_db, region, udbz, softfail)) {
				region_destroy(region);
				return 0;
			}
		}
		else
		{
			/* add this rr */
			if(!add_RR(db, dname, type, klass, ttl, packet,
				rrlen, zone_db, udbz, softfail)) {
				region_destroy(region);
				return 0;
			}
		}
	}
	region_destroy(region);
	return 1;
}

static int
check_for_bad_serial(namedb_type* db, const char* zone_str, uint32_t old_serial)
{
	/* see if serial OK with in-memory serial */
	domain_type* domain;
	region_type* region = region_create(xalloc, free);
	const dname_type* zone_name = dname_parse(region, zone_str);
	zone_type* zone = 0;
	domain = domain_table_find(db->domains, zone_name);
	if(domain)
		zone = domain_find_zone(db, domain);
	if(zone && zone->apex == domain && zone->soa_rrset && old_serial)
	{
		uint32_t memserial;
		memcpy(&memserial, rdata_atom_data(zone->soa_rrset->rrs[0].rdatas[2]),
			sizeof(uint32_t));
		if(old_serial != ntohl(memserial)) {
			region_destroy(region);
			return 1;
		}
	}
	region_destroy(region);
	return 0;
}

static int
apply_ixfr_for_zone(nsd_type* nsd, zone_type* zonedb, FILE* in,
	struct nsd_options* opt, udb_base* taskudb, udb_ptr* last_task,
	uint32_t xfrfilenr)
{
	char zone_buf[3072];
	char log_buf[5120];
	char patname_buf[2048];

	uint32_t old_serial, new_serial, num_parts, type;
	uint64_t time_end_0, time_start_0;
	uint32_t time_end_1, time_start_1;
	uint8_t committed;
	uint32_t i;
	int num_bytes = 0;

	/* read zone name and serial */
	if(!diff_read_32(in, &type)) {
		log_msg(LOG_ERR, "diff file too short");
		return 0;
	}
	if(type != DIFF_PART_XFRF) {
		log_msg(LOG_ERR, "xfr file has wrong format");
		return 0;

	}
	/* committed and num_parts are first because they need to be
	 * updated once the rest is written.  The log buf is not certain
	 * until its done, so at end of file.  The patname is in case a
	 * new zone is created, we know what the options-pattern is */
	if(!diff_read_8(in, &committed) ||
		!diff_read_32(in, &num_parts) ||
		!diff_read_64(in, &time_end_0) ||
		!diff_read_32(in, &time_end_1) ||
		!diff_read_32(in, &old_serial) ||
		!diff_read_32(in, &new_serial) ||
		!diff_read_64(in, &time_start_0) ||
		!diff_read_32(in, &time_start_1) ||
		!diff_read_str(in, zone_buf, sizeof(zone_buf)) ||
		!diff_read_str(in, patname_buf, sizeof(patname_buf))) {
		log_msg(LOG_ERR, "diff file bad commit part");
		return 0;
	}

	/* has been read in completely */
	if(strcmp(zone_buf, domain_to_string(zonedb->apex)) != 0) {
		log_msg(LOG_ERR, "file %s does not match task %s",
			zone_buf, domain_to_string(zonedb->apex));
		return 0;
	}
	if(!committed) {
		log_msg(LOG_ERR, "diff file %s was not committed", zone_buf);
		return 0;
	}
	if(num_parts == 0) {
		log_msg(LOG_ERR, "diff file %s was not completed", zone_buf);
		return 0;
	}
	if(check_for_bad_serial(nsd->db, zone_buf, old_serial)) {
		DEBUG(DEBUG_XFRD,1, (LOG_ERR,
			"skipping diff file commit with bad serial"));
		return 1;
	}

	if(committed)
	{
		int is_axfr=0, delete_mode=0, rr_count=0, softfail=0;
		const dname_type* apex = domain_dname_const(zonedb->apex);
		udb_ptr z;

		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "processing xfr: %s", zone_buf));
		if(nsd->db->udb) {
			if(udb_base_get_userflags(nsd->db->udb) != 0) {
				log_msg(LOG_ERR, "database corrupted, cannot update");
				xfrd_unlink_xfrfile(nsd, xfrfilenr);
				exit(1);
			}
			/* all parts were checked by xfrd before commit */
			if(!udb_zone_search(nsd->db->udb, &z, dname_name(apex),
				apex->name_size)) {
				/* create it */
				if(!udb_zone_create(nsd->db->udb, &z, dname_name(apex),
					apex->name_size)) {
					/* out of disk space perhaps */
					log_msg(LOG_ERR, "could not udb_create_zone "
						"%s, disk space full?", log_buf);
					return 0;
				}
			}
			/* set the udb dirty until we are finished applying changes */
			udb_base_set_userflags(nsd->db->udb, 1);
		}
		/* read and apply all of the parts */
		for(i=0; i<num_parts; i++) {
			int ret;
			DEBUG(DEBUG_XFRD,2, (LOG_INFO, "processing xfr: apply part %d", (int)i));
			ret = apply_ixfr(nsd->db, in, zone_buf, new_serial, opt,
				i, num_parts, &is_axfr, &delete_mode,
				&rr_count, (nsd->db->udb?&z:NULL), &zonedb,
				patname_buf, &num_bytes, &softfail);
			if(ret == 0) {
				log_msg(LOG_ERR, "bad ixfr packet part %d in diff file for %s", (int)i, zone_buf);
				xfrd_unlink_xfrfile(nsd, xfrfilenr);
				/* the udb is still dirty, it is bad */
				exit(1);
			} else if(ret == 2) {
				break;
			}
		}
		if(nsd->db->udb)
			udb_base_set_userflags(nsd->db->udb, 0);
		/* read the final log_str: but do not fail on it */
		if(!diff_read_str(in, log_buf, sizeof(log_buf))) {
			log_msg(LOG_ERR, "could not read log for transfer %s",
				zone_buf);
			snprintf(log_buf, sizeof(log_buf), "error reading log");
		}
#ifdef NSEC3
		if(zonedb) prehash_zone(nsd->db, zonedb);
#endif /* NSEC3 */
		zonedb->is_changed = 1;
		if(nsd->db->udb) {
			ZONE(&z)->is_changed = 1;
			ZONE(&z)->mtime = time_end_0;
			ZONE(&z)->mtime_nsec = time_end_1*1000;
			udb_zone_set_log_str(nsd->db->udb, &z, log_buf);
			udb_zone_set_file_str(nsd->db->udb, &z, NULL);
			udb_ptr_unlink(&z, nsd->db->udb);
		} else {
			zonedb->mtime.tv_sec = time_end_0;
			zonedb->mtime.tv_nsec = time_end_1*1000;
			if(zonedb->logstr)
				region_recycle(nsd->db->region, zonedb->logstr,
					strlen(zonedb->logstr)+1);
			zonedb->logstr = region_strdup(nsd->db->region, log_buf);
			if(zonedb->filename)
				region_recycle(nsd->db->region, zonedb->filename,
					strlen(zonedb->filename)+1);
			zonedb->filename = NULL;
		}
		if(softfail && taskudb && !is_axfr) {
			log_msg(LOG_ERR, "Failed to apply IXFR cleanly "
				"(deletes nonexistent RRs, adds existing RRs). "
				"Zone %s contents is different from master, "
				"starting AXFR. Transfer %s", zone_buf, log_buf);
			/* add/del failures in IXFR, get an AXFR */
			task_new_soainfo(taskudb, last_task, zonedb, 1);
		} else {
			if(taskudb)
				task_new_soainfo(taskudb, last_task, zonedb, 0);
		}

		if(1 <= verbosity) {
			double elapsed = (double)(time_end_0 - time_start_0)+
				(double)((double)time_end_1
				-(double)time_start_1) / 1000000.0;
			VERBOSITY(1, (LOG_INFO, "zone %s %s of %d bytes in %g seconds",
				zone_buf, log_buf, num_bytes, elapsed));
		}
	}
	else {
	 	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "skipping xfr: %s", log_buf));
	}
	return 1;
}

struct udb_base* task_file_create(const char* file)
{
        return udb_base_create_new(file, &namedb_walkfunc, NULL);
}

static int
task_create_new_elem(struct udb_base* udb, udb_ptr* last, udb_ptr* e,
	size_t sz, const dname_type* zname)
{
	if(!udb_ptr_alloc_space(e, udb, udb_chunk_type_task, sz)) {
		return 0;
	}
	if(udb_ptr_is_null(last)) {
		udb_base_set_userdata(udb, e->data);
	} else {
		udb_rptr_set_ptr(&TASKLIST(last)->next, udb, e);
	}
	udb_ptr_set_ptr(last, udb, e);

	/* fill in tasklist item */
	udb_rel_ptr_init(&TASKLIST(e)->next);
	TASKLIST(e)->size = sz;
	TASKLIST(e)->oldserial = 0;
	TASKLIST(e)->newserial = 0;
	TASKLIST(e)->yesno = 0;

	if(zname) {
		memmove(TASKLIST(e)->zname, zname, dname_total_size(zname));
	}
	return 1;
}

void task_new_soainfo(struct udb_base* udb, udb_ptr* last, struct zone* z,
	int gone)
{
	/* calculate size */
	udb_ptr e;
	size_t sz;
	const dname_type* apex, *ns, *em;
	if(!z || !z->apex || !domain_dname(z->apex))
		return; /* safety check */

	DEBUG(DEBUG_IPC,1, (LOG_INFO, "nsd: add soa info for zone %s",
		domain_to_string(z->apex)));
	apex = domain_dname(z->apex);
	sz = sizeof(struct task_list_d) + dname_total_size(apex);
	if(z->soa_rrset && !gone) {
		ns = domain_dname(rdata_atom_domain(
			z->soa_rrset->rrs[0].rdatas[0]));
		em = domain_dname(rdata_atom_domain(
			z->soa_rrset->rrs[0].rdatas[1]));
		sz += sizeof(uint32_t)*6 + sizeof(uint8_t)*2
			+ ns->name_size + em->name_size;
	} else {
		ns = 0;
		em = 0;
	}

	/* create new task_list item */
	if(!task_create_new_elem(udb, last, &e, sz, apex)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add SOAINFO");
		return;
	}
	TASKLIST(&e)->task_type = task_soa_info;

	if(z->soa_rrset && !gone) {
		uint32_t ttl = htonl(z->soa_rrset->rrs[0].ttl);
		uint8_t* p = (uint8_t*)TASKLIST(&e)->zname;
		p += dname_total_size(apex);
		memmove(p, &ttl, sizeof(uint32_t));
		p += sizeof(uint32_t);
		memmove(p, &ns->name_size, sizeof(uint8_t));
		p += sizeof(uint8_t);
		memmove(p, dname_name(ns), ns->name_size);
		p += ns->name_size;
		memmove(p, &em->name_size, sizeof(uint8_t));
		p += sizeof(uint8_t);
		memmove(p, dname_name(em), em->name_size);
		p += em->name_size;
		memmove(p, rdata_atom_data(z->soa_rrset->rrs[0].rdatas[2]),
			sizeof(uint32_t));
		p += sizeof(uint32_t);
		memmove(p, rdata_atom_data(z->soa_rrset->rrs[0].rdatas[3]),
			sizeof(uint32_t));
		p += sizeof(uint32_t);
		memmove(p, rdata_atom_data(z->soa_rrset->rrs[0].rdatas[4]),
			sizeof(uint32_t));
		p += sizeof(uint32_t);
		memmove(p, rdata_atom_data(z->soa_rrset->rrs[0].rdatas[5]),
			sizeof(uint32_t));
		p += sizeof(uint32_t);
		memmove(p, rdata_atom_data(z->soa_rrset->rrs[0].rdatas[6]),
			sizeof(uint32_t));
	}
	udb_ptr_unlink(&e, udb);
}

void task_process_sync(struct udb_base* taskudb)
{
	/* need to sync before other process uses the mmap? */
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "task procsync %s size %d",
		taskudb->fname, (int)taskudb->base_size));
	(void)taskudb;
}

void task_remap(struct udb_base* taskudb)
{
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "task remap %s size %d",
		taskudb->fname, (int)taskudb->glob_data->fsize));
	udb_base_remap_process(taskudb);
}

void task_clear(struct udb_base* taskudb)
{
	udb_ptr t, n;
	udb_ptr_new(&t, taskudb, udb_base_get_userdata(taskudb));
	udb_base_set_userdata(taskudb, 0);
	udb_ptr_init(&n, taskudb);
	while(!udb_ptr_is_null(&t)) {
		udb_ptr_set_rptr(&n, taskudb, &TASKLIST(&t)->next);
		udb_rptr_zero(&TASKLIST(&t)->next, taskudb);
		udb_ptr_free_space(&t, taskudb, TASKLIST(&t)->size);
		udb_ptr_set_ptr(&t, taskudb, &n);
	}
	udb_ptr_unlink(&t, taskudb);
	udb_ptr_unlink(&n, taskudb);
}

void task_new_expire(struct udb_base* udb, udb_ptr* last,
	const struct dname* z, int expired)
{
	udb_ptr e;
	if(!z) return;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add expire info for zone %s",
		dname_to_string(z,NULL)));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)+
		dname_total_size(z), z)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add expire");
		return;
	}
	TASKLIST(&e)->task_type = task_expire;
	TASKLIST(&e)->yesno = expired;
	udb_ptr_unlink(&e, udb);
}

void task_new_check_zonefiles(udb_base* udb, udb_ptr* last,
	const dname_type* zone)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task checkzonefiles"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d) +
		(zone?dname_total_size(zone):0), zone)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add check_zones");
		return;
	}
	TASKLIST(&e)->task_type = task_check_zonefiles;
	TASKLIST(&e)->yesno = (zone!=NULL);
	udb_ptr_unlink(&e, udb);
}

void task_new_write_zonefiles(udb_base* udb, udb_ptr* last,
	const dname_type* zone)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task writezonefiles"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d) +
		(zone?dname_total_size(zone):0), zone)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add writezones");
		return;
	}
	TASKLIST(&e)->task_type = task_write_zonefiles;
	TASKLIST(&e)->yesno = (zone!=NULL);
	udb_ptr_unlink(&e, udb);
}

void task_new_set_verbosity(udb_base* udb, udb_ptr* last, int v)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task set_verbosity"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d),
		NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add set_v");
		return;
	}
	TASKLIST(&e)->task_type = task_set_verbosity;
	TASKLIST(&e)->yesno = v;
	udb_ptr_unlink(&e, udb);
}

#ifdef BIND8_STATS
void* task_new_stat_info(udb_base* udb, udb_ptr* last, struct nsdst* stat,
	size_t child_count)
{
	void* p;
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task stat_info"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)+
		sizeof(*stat) + sizeof(stc_type)*child_count, NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add stati");
		return NULL;
	}
	TASKLIST(&e)->task_type = task_stat_info;
	p = TASKLIST(&e)->zname;
	memcpy(p, stat, sizeof(*stat));
	udb_ptr_unlink(&e, udb);
	return p + sizeof(*stat);
}
#endif /* BIND8_STATS */

void
task_new_add_zone(udb_base* udb, udb_ptr* last, const char* zone,
	const char* pattern, unsigned zonestatid)
{
	size_t zlen = strlen(zone);
	size_t plen = strlen(pattern);
	void *p;
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task addzone %s %s", zone, pattern));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)+
		zlen + 1 + plen + 1, NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add addz");
		return;
	}
	TASKLIST(&e)->task_type = task_add_zone;
	TASKLIST(&e)->yesno = zonestatid;
	p = TASKLIST(&e)->zname;
	memcpy(p, zone, zlen+1);
	memmove(p+zlen+1, pattern, plen+1);
	udb_ptr_unlink(&e, udb);
}

void
task_new_del_zone(udb_base* udb, udb_ptr* last, const dname_type* dname)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task delzone %s", dname_to_string(dname, 0)));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+dname_total_size(dname), dname)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add delz");
		return;
	}
	TASKLIST(&e)->task_type = task_del_zone;
	udb_ptr_unlink(&e, udb);
}

void task_new_add_key(udb_base* udb, udb_ptr* last, struct key_options* key)
{
	char* p;
	udb_ptr e;
	assert(key->name && key->algorithm && key->secret);
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task addkey"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+strlen(key->name)+1+strlen(key->algorithm)+1+
		strlen(key->secret)+1, NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add addk");
		return;
	}
	TASKLIST(&e)->task_type = task_add_key;
	p = (char*)TASKLIST(&e)->zname;
	memmove(p, key->name, strlen(key->name)+1);
	p+=strlen(key->name)+1;
	memmove(p, key->algorithm, strlen(key->algorithm)+1);
	p+=strlen(key->algorithm)+1;
	memmove(p, key->secret, strlen(key->secret)+1);
	udb_ptr_unlink(&e, udb);
}

void task_new_del_key(udb_base* udb, udb_ptr* last, const char* name)
{
	char* p;
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task delkey"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+strlen(name)+1, NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add delk");
		return;
	}
	TASKLIST(&e)->task_type = task_del_key;
	p = (char*)TASKLIST(&e)->zname;
	memmove(p, name, strlen(name)+1);
	udb_ptr_unlink(&e, udb);
}

void task_new_add_pattern(udb_base* udb, udb_ptr* last,
	struct pattern_options* p)
{
	region_type* temp;
	buffer_type* buffer;
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task addpattern %s", p->pname));
	temp = region_create(xalloc, free);
	buffer = buffer_create(temp, 4096);
	pattern_options_marshal(buffer, p);
	buffer_flip(buffer);
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+ buffer_limit(buffer), NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add addp");
		region_destroy(temp);
		return;
	}
	TASKLIST(&e)->task_type = task_add_pattern;
	TASKLIST(&e)->yesno = buffer_limit(buffer);
	memmove(TASKLIST(&e)->zname, buffer_begin(buffer),
		buffer_limit(buffer));
	udb_ptr_unlink(&e, udb);
	region_destroy(temp);
}

void task_new_del_pattern(udb_base* udb, udb_ptr* last, const char* name)
{
	char* p;
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task delpattern %s", name));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+strlen(name)+1, NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add delp");
		return;
	}
	TASKLIST(&e)->task_type = task_del_pattern;
	p = (char*)TASKLIST(&e)->zname;
	memmove(p, name, strlen(name)+1);
	udb_ptr_unlink(&e, udb);
}

void task_new_opt_change(udb_base* udb, udb_ptr* last, struct nsd_options* opt)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task opt_change"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d),
		NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add o_c");
		return;
	}
	TASKLIST(&e)->task_type = task_opt_change;
#ifdef RATELIMIT
	TASKLIST(&e)->oldserial = opt->rrl_ratelimit;
	TASKLIST(&e)->newserial = opt->rrl_whitelist_ratelimit;
	TASKLIST(&e)->yesno = (uint64_t) opt->rrl_slip;
#else
	(void)opt;
#endif
	udb_ptr_unlink(&e, udb);
}

void task_new_zonestat_inc(udb_base* udb, udb_ptr* last, unsigned sz)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task zonestat_inc"));
	if(sz == 0)
		return; /* no need to decrease to 0 */
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d),
		NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add z_i");
		return;
	}
	TASKLIST(&e)->task_type = task_zonestat_inc;
	TASKLIST(&e)->oldserial = (uint32_t)sz;
	udb_ptr_unlink(&e, udb);
}

int
task_new_apply_xfr(udb_base* udb, udb_ptr* last, const dname_type* dname,
	uint32_t old_serial, uint32_t new_serial, uint64_t filenumber)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task apply_xfr"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+dname_total_size(dname), dname)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add applyxfr");
		return 0;
	}
	TASKLIST(&e)->oldserial = old_serial;
	TASKLIST(&e)->newserial = new_serial;
	TASKLIST(&e)->yesno = filenumber;
	TASKLIST(&e)->task_type = task_apply_xfr;
	udb_ptr_unlink(&e, udb);
	return 1;
}

void
task_process_expire(namedb_type* db, struct task_list_d* task)
{
	uint8_t ok;
	zone_type* z = namedb_find_zone(db, task->zname);
	assert(task->task_type == task_expire);
	if(!z) {
		DEBUG(DEBUG_IPC, 1, (LOG_WARNING, "zone %s %s but not in zonetree",
			dname_to_string(task->zname, NULL),
			task->yesno?"expired":"unexpired"));
		return;
	}
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: expire task zone %s %s",
		dname_to_string(task->zname,0),
		task->yesno?"expired":"unexpired"));
	/* find zone, set expire flag */
	ok = !task->yesno;
	/* only update zone->is_ok if needed to minimize copy-on-write
	 * of memory pages shared after fork() */
	if(ok && !z->is_ok)
		z->is_ok = 1;
	else if(!ok && z->is_ok)
		z->is_ok = 0;
}

static void
task_process_set_verbosity(struct task_list_d* task)
{
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "verbosity task %d", (int)task->yesno));
	verbosity = task->yesno;
}

static void
task_process_checkzones(struct nsd* nsd, udb_base* udb, udb_ptr* last_task,
	struct task_list_d* task)
{
	/* on SIGHUP check if zone-text-files changed and if so,
	 * reread.  When from xfrd-reload, no need to fstat the files */
	if(task->yesno) {
		struct zone_options* zo = zone_options_find(nsd->options,
			task->zname);
		if(zo)
			namedb_check_zonefile(nsd, udb, last_task, zo);
	} else {
		/* check all zones */
		namedb_check_zonefiles(nsd, nsd->options, udb, last_task);
	}
}

static void
task_process_writezones(struct nsd* nsd, struct task_list_d* task)
{
	if(task->yesno) {
		struct zone_options* zo = zone_options_find(nsd->options,
			task->zname);
		if(zo)
			namedb_write_zonefile(nsd, zo);
	} else {
		namedb_write_zonefiles(nsd, nsd->options);
	}
}

static void
task_process_add_zone(struct nsd* nsd, udb_base* udb, udb_ptr* last_task,
	struct task_list_d* task)
{
	zone_type* z;
	const dname_type* zdname;
	const char* zname = (const char*)task->zname;
	const char* pname = zname + strlen(zname)+1;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "addzone task %s %s", zname, pname));
	zdname = dname_parse(nsd->db->region, zname);
	if(!zdname) {
		log_msg(LOG_ERR, "can not parse zone name %s", zname);
		return;
	}
	/* create zone */
	z = find_or_create_zone(nsd->db, zdname, nsd->options, zname, pname);
	if(!z) {
		region_recycle(nsd->db->region, (void*)zdname,
			dname_total_size(zdname));
		log_msg(LOG_ERR, "can not add zone %s %s", zname, pname);
		return;
	}
	z->zonestatid = (unsigned)task->yesno;
	/* if zone is empty, attempt to read the zonefile from disk (if any) */
	if(!z->soa_rrset && z->opts->pattern->zonefile) {
		namedb_read_zonefile(nsd, z, udb, last_task);
	}
}

static void
task_process_del_zone(struct nsd* nsd, struct task_list_d* task)
{
	zone_type* zone;
	struct zone_options* zopt;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "delzone task %s", dname_to_string(
		task->zname, NULL)));
	zone = namedb_find_zone(nsd->db, task->zname);
	if(!zone)
		return;

#ifdef NSEC3
	nsec3_hash_tree_clear(zone);
#endif
	delete_zone_rrs(nsd->db, zone);
	if(nsd->db->udb) {
		udb_ptr udbz;
		if(udb_zone_search(nsd->db->udb, &udbz, dname_name(task->zname),
			task->zname->name_size)) {
			udb_zone_delete(nsd->db->udb, &udbz);
			udb_ptr_unlink(&udbz, nsd->db->udb);
		}
	}
#ifdef NSEC3
	nsec3_clear_precompile(nsd->db, zone);
	zone->nsec3_param = NULL;
#endif /* NSEC3 */

	/* remove from zonetree, apex, soa */
	zopt = zone->opts;
	namedb_zone_delete(nsd->db, zone);
	/* remove from options (zone_list already edited by xfrd) */
	zone_options_delete(nsd->options, zopt);
}

static void
task_process_add_key(struct nsd* nsd, struct task_list_d* task)
{
	struct key_options key;
	key.name = (char*)task->zname;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "addkey task %s", key.name));
	key.algorithm = key.name + strlen(key.name)+1;
	key.secret = key.algorithm + strlen(key.algorithm)+1;
	key_options_add_modify(nsd->options, &key);
	memset(key.secret, 0xdd, strlen(key.secret)); /* wipe secret */
}

static void
task_process_del_key(struct nsd* nsd, struct task_list_d* task)
{
	char* name = (char*)task->zname;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "delkey task %s", name));
	/* this is reload and nothing is using the TSIG key right now */
	key_options_remove(nsd->options, name);
}

static void
task_process_add_pattern(struct nsd* nsd, struct task_list_d* task)
{
	region_type* temp = region_create(xalloc, free);
	buffer_type buffer;
	struct pattern_options *pat;
	buffer_create_from(&buffer, task->zname, task->yesno);
	pat = pattern_options_unmarshal(temp, &buffer);
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "addpattern task %s", pat->pname));
	pattern_options_add_modify(nsd->options, pat);
	region_destroy(temp);
}

static void
task_process_del_pattern(struct nsd* nsd, struct task_list_d* task)
{
	char* name = (char*)task->zname;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "delpattern task %s", name));
	pattern_options_remove(nsd->options, name);
}

static void
task_process_opt_change(struct nsd* nsd, struct task_list_d* task)
{
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "optchange task"));
#ifdef RATELIMIT
	nsd->options->rrl_ratelimit = task->oldserial;
	nsd->options->rrl_whitelist_ratelimit = task->newserial;
	nsd->options->rrl_slip = task->yesno;
	rrl_set_limit(nsd->options->rrl_ratelimit, nsd->options->rrl_whitelist_ratelimit,
		nsd->options->rrl_slip);
#else
	(void)nsd; (void)task;
#endif
}

#ifdef USE_ZONE_STATS
static void
task_process_zonestat_inc(struct nsd* nsd, udb_base* udb, udb_ptr *last_task,
	struct task_list_d* task)
{
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "zonestat_inc task %u", (unsigned)task->oldserial));
	nsd->zonestatdesired = (unsigned)task->oldserial;
	/* send echo to xfrd to increment on its end */
	task_new_zonestat_inc(udb, last_task, nsd->zonestatdesired);
}
#endif

static void
task_process_apply_xfr(struct nsd* nsd, udb_base* udb, udb_ptr *last_task,
	udb_ptr* task)
{
	/* we have to use an udb_ptr task here, because the apply_xfr procedure
	 * appends soa_info which may remap and change the pointer. */
	zone_type* zone;
	FILE* df;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "applyxfr task %s", dname_to_string(
		TASKLIST(task)->zname, NULL)));
	zone = namedb_find_zone(nsd->db, TASKLIST(task)->zname);
	if(!zone) {
		/* assume the zone has been deleted and a zone transfer was
		 * still waiting to be processed */
		xfrd_unlink_xfrfile(nsd, TASKLIST(task)->yesno);
		return;
	}
	/* apply the XFR */
	/* oldserial, newserial, yesno is filenumber */
	df = xfrd_open_xfrfile(nsd, TASKLIST(task)->yesno, "r");
	if(!df) {
		/* could not open file to update */
		/* there is no reply to xfrd failed-update,
		 * because xfrd has a scan for apply-failures. */
		xfrd_unlink_xfrfile(nsd, TASKLIST(task)->yesno);
		return;
	}
	/* read and apply zone transfer */
	if(!apply_ixfr_for_zone(nsd, zone, df, nsd->options, udb,
		last_task, TASKLIST(task)->yesno)) {
		/* there is no reply to xfrd failed-update,
		 * because xfrd has a scan for apply-failures. */
	}

	fclose(df);
	xfrd_unlink_xfrfile(nsd, TASKLIST(task)->yesno);
}


void task_process_in_reload(struct nsd* nsd, udb_base* udb, udb_ptr *last_task,
        udb_ptr* task)
{
	switch(TASKLIST(task)->task_type) {
	case task_expire:
		task_process_expire(nsd->db, TASKLIST(task));
		break;
	case task_check_zonefiles:
		task_process_checkzones(nsd, udb, last_task, TASKLIST(task));
		break;
	case task_write_zonefiles:
		task_process_writezones(nsd, TASKLIST(task));
		break;
	case task_set_verbosity:
		task_process_set_verbosity(TASKLIST(task));
		break;
	case task_add_zone:
		task_process_add_zone(nsd, udb, last_task, TASKLIST(task));
		break;
	case task_del_zone:
		task_process_del_zone(nsd, TASKLIST(task));
		break;
	case task_add_key:
		task_process_add_key(nsd, TASKLIST(task));
		break;
	case task_del_key:
		task_process_del_key(nsd, TASKLIST(task));
		break;
	case task_add_pattern:
		task_process_add_pattern(nsd, TASKLIST(task));
		break;
	case task_del_pattern:
		task_process_del_pattern(nsd, TASKLIST(task));
		break;
	case task_opt_change:
		task_process_opt_change(nsd, TASKLIST(task));
		break;
#ifdef USE_ZONE_STATS
	case task_zonestat_inc:
		task_process_zonestat_inc(nsd, udb, last_task, TASKLIST(task));
		break;
#endif
	case task_apply_xfr:
		task_process_apply_xfr(nsd, udb, last_task, task);
		break;
	default:
		log_msg(LOG_WARNING, "unhandled task in reload type %d",
			(int)TASKLIST(task)->task_type);
		break;
	}
	udb_ptr_free_space(task, udb, TASKLIST(task)->size);
}
@


1.7
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@d755 1
d757 1
d775 1
d777 1
@


1.6
log
@Update to 4.1.13
Testing millert, brad and myself.
OK millert@@
@
text
@d861 1
a861 1
	nsd_options_t* opt, const char* zstr, const char* patname)
d864 1
a864 1
	zone_options_t* zopt;
d961 1
a961 1
	nsd_options_t* opt, uint32_t seq_nr, uint32_t seq_total,
d1259 1
a1259 1
	nsd_options_t* opt, udb_base* taskudb, udb_ptr* last_task,
d1620 1
a1620 1
		sizeof(*stat) + sizeof(stc_t)*child_count, NULL)) {
d1668 1
a1668 1
void task_new_add_key(udb_base* udb, udb_ptr* last, key_options_t* key)
d1706 2
a1707 1
void task_new_add_pattern(udb_base* udb, udb_ptr* last, pattern_options_t* p)
d1747 1
a1747 1
void task_new_opt_change(udb_base* udb, udb_ptr* last, nsd_options_t* opt)
d1841 1
a1841 1
		zone_options_t* zo = zone_options_find(nsd->options,
d1855 1
a1855 1
		zone_options_t* zo = zone_options_find(nsd->options,
d1897 1
a1897 1
	zone_options_t* zopt;
d1931 1
a1931 1
	key_options_t key;
d1954 1
a1954 1
	pattern_options_t *pat;
@


1.5
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@d375 1
a375 1
				dname_to_string(rrset->rrs[i].owner->dname,0),
d382 1
a382 1
				dname_to_string(rrset->rrs[i].owner->dname,0),
d390 1
a390 1
				dname_to_string(rrset->rrs[i].owner->dname,0),
d399 1
a399 1
				dname_to_string(rrset->rrs[i].owner->dname,0),
d1302 1
a1302 1
	if(strcmp(zone_buf, dname_to_string(zonedb->apex->dname,0)) != 0) {
d1304 1
a1304 1
			zone_buf, dname_to_string(zonedb->apex->dname,0));
d1324 1
a1324 1
		const dname_type* apex = zonedb->apex->dname;
@


1.4
log
@merge conflicts
@
text
@d1381 1
d1386 2
a1387 1
			zonedb->mtime = time_end_0;
@


1.3
log
@merge conflicts
@
text
@d705 2
a706 2
			rrset->rrs = region_alloc_init(db->region, rrs_orig,
				sizeof(rr_type) * (rrset->rr_count-1));
d794 5
d802 2
a803 2
	rrset->rrs = region_alloc(db->region,
		(rrset->rr_count+1) * sizeof(rr_type));
d1411 1
a1411 1
			VERBOSITY(2, (LOG_INFO, "zone %s %s of %d bytes in %g seconds",
@


1.2
log
@Merge in some commits from upstream..

- Fix that failure to add tcp to tcp base does not leak the socket.
- Fixes for wildcard addition and deletion, speedup for some cases.
- Fix that queries for noname CH TXT are REFUSED instead of nodata.
- Fix #616: retry xfer for zones with no content after command.
- Fix that expired zones stay expired after a server restart.
- RFC 7344: CDS and CDNSKEY (read in).

ok sthen@@
@
text
@d1627 1
a1627 1
	const char* pattern)
d1640 1
d1759 16
d1878 1
d1977 12
d2065 5
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
#include <config.h>
d17 1
d21 5
d28 1
a28 1
write_32(FILE *out, uint32_t val)
a29 1
	val = htonl(val);
d34 1
a34 1
write_16(FILE *out, uint16_t val)
d36 1
a36 1
	val = htons(val);
d56 3
a58 2
diff_write_packet(const char* zone, uint32_t new_serial, uint16_t id,
	uint32_t seq_nr, uint8_t* data, size_t len, nsd_options_t* opt)
d60 4
a63 9
	const char* filename = opt->difffile;
	struct timeval tv;
	FILE *df;
	uint32_t file_len = sizeof(uint32_t) + strlen(zone) +
		sizeof(new_serial) + sizeof(id) + sizeof(seq_nr) + len;

	if (gettimeofday(&tv, NULL) != 0) {
		log_msg(LOG_ERR, "could not set timestamp for %s: %s",
			filename, strerror(errno));
d67 23
a89 5
	df = fopen(filename, "a");
	if(!df) {
		log_msg(LOG_ERR, "could not open file %s for append: %s",
			filename, strerror(errno));
		return;
d92 2
a93 8
	if(!write_32(df, DIFF_PART_IXFR) ||
		!write_32(df, (uint32_t) tv.tv_sec) ||
		!write_32(df, (uint32_t) tv.tv_usec) ||
		!write_32(df, file_len) ||
		!write_str(df, zone) ||
		!write_32(df, new_serial) ||
		!write_16(df, id) ||
		!write_32(df, seq_nr) ||
d95 1
a95 1
		!write_32(df, file_len))
d97 2
a98 2
		log_msg(LOG_ERR, "could not write to file %s: %s",
			filename, strerror(errno));
a99 1
	fflush(df);
d104 3
a106 3
diff_write_commit(const char* zone, uint32_t old_serial,
	uint32_t new_serial, uint16_t id, uint32_t num_parts,
	uint8_t commit, const char* log_str, nsd_options_t* opt)
a107 1
	const char* filename = opt->difffile;
d109 1
a109 2
	FILE *df;
	uint32_t len;
d113 1
a113 2
			filename, strerror(errno));
		return;
d116 6
a121 1
	df = fopen(filename, "a");
d123 2
a124 2
		log_msg(LOG_ERR, "could not open file %s for append: %s",
			filename, strerror(errno));
d127 4
a130 7

	len = strlen(zone) + sizeof(len) + sizeof(old_serial) +
		sizeof(new_serial) + sizeof(id) + sizeof(num_parts) +
		sizeof(commit) + strlen(log_str) + sizeof(len);

	if(!write_32(df, DIFF_PART_SURE) ||
		!write_32(df, (uint32_t) tv.tv_sec) ||
a131 2
		!write_32(df, len) ||
		!write_str(df, zone) ||
d133 1
a133 6
		!write_32(df, new_serial) ||
		!write_16(df, id) ||
		!write_32(df, num_parts) ||
		!write_8(df, commit) ||
		!write_str(df, log_str) ||
		!write_32(df, len))
d135 19
a153 2
		log_msg(LOG_ERR, "could not write to file %s: %s",
			filename, strerror(errno));
a158 4
/*
 * Checksum to signal no data change occured (for example, by a
 * zonec run.
 */
d160 1
a160 1
db_crc_different(namedb_type* db)
d162 4
a165 36
	FILE *fd = fopen(db->filename, "r");
	uint32_t crc_file;
	char buf[NAMEDB_MAGIC_SIZE];
	if(fd == NULL) {
		log_msg(LOG_ERR, "unable to load %s: %s",
			db->filename, strerror(errno));
		return -1;
	}

	/* seek to position of CRC, check it and magic no */
	if(fseeko(fd, db->crc_pos, SEEK_SET)==-1) {
		log_msg(LOG_ERR, "unable to fseeko %s: %s. db changed?",
			db->filename, strerror(errno));
		fclose(fd);
		return -1;
	}

	if(fread(&crc_file, sizeof(crc_file), 1, fd) != 1) {
		if(!feof(fd))
			log_msg(LOG_ERR, "could not read %s CRC: %s. "
				"db changed?", db->filename, strerror(errno));
		fclose(fd);
		return -1;
	}
	crc_file = ntohl(crc_file);

	if(fread(buf, sizeof(char), sizeof(buf), fd) != sizeof(buf)) {
		if(!feof(fd))
			log_msg(LOG_ERR, "could not read %s magic: %s. "
				"db changed?", db->filename, strerror(errno));
		fclose(fd);
		return -1;
	}
	if(memcmp(buf, NAMEDB_MAGIC, NAMEDB_MAGIC_SIZE) != 0) {
		fclose(fd);
		return -1;
a166 6

	fclose(fd);

	if(db->crc == crc_file)
		return 0;
	return 1;
a180 11
diff_read_16(FILE *in, uint16_t* result)
{
        if (fread(result, sizeof(*result), 1, in) == 1) {
                *result = ntohs(*result);
                return 1;
        } else {
                return 0;
        }
}

int
d230 1
a230 1
	while(d != NULL && dname_is_subdomain(domain_dname(d), domain_dname(top))) {
d238 28
d282 1
a282 1
		dname_to_string(domain_dname(domain),0),
a287 1
		rrset->zone->updated = 1;
a291 1
#ifdef DNSSEC
d294 1
a294 1
			if (rr_rrsig_type_covered(&rrset->rrs[i]) == TYPE_SOA) {
a299 1
#endif
d305 1
a306 16

	/* is the node now an empty node (completely deleted) */
	if(domain->rrsets == 0) {
		/* if there is no data below it, it becomes non existing.
		   also empty nonterminals above it become nonexisting */
		/* check for data below this node. */
		if(!has_data_below(domain)) {
			/* nonexist this domain and all parent empty nonterminals */
			domain_type* p = domain;
			while(p != NULL && p->rrsets == 0) {
				p->is_existing = 0;
				p = p->parent;
			}
		}
	}
	rrset->rr_count = 0;
d310 2
a311 1
rdatas_equal(rdata_atom_type *a, rdata_atom_type *b, int num, uint16_t type)
d313 12
a324 2
	int k;
	for(k = 0; k < num; k++)
d328 16
a343 1
				domain_dname(b[k].domain))!=0)
d345 1
d348 3
a350 1
			if(a[k].data[0] != b[k].data[0])
d352 1
d354 3
a356 1
			if(memcmp(a[k].data+1, b[k].data+1, a[k].data[0])!=0)
d358 1
d364 42
d407 2
a408 3
find_rr_num(rrset_type* rrset,
	uint16_t type, uint16_t klass,
	rdata_atom_type *rdatas, ssize_t rdata_num)
d410 2
a411 1
	int i;
d417 2
a418 1
		   rdatas_equal(rdatas, rrset->rrs[i].rdatas, rdata_num, type))
d423 6
d430 194
a623 1
	return -1;
d626 1
a626 1
static int
d630 1
a630 1
	region_type* temp_region)
d639 1
d647 1
d666 4
a669 1
		rrnum = find_rr_num(rrset, type, klass, rdatas, rdata_num);
d671 3
a673 2
			log_msg(LOG_WARNING, "diff: RR %s does not exist",
				dname_to_string(dname,0));
d676 10
d689 8
d713 17
d731 7
d743 1
a743 1
static int
d746 2
a747 1
	buffer_type* packet, size_t rdatalen, zone_type *zone)
d755 1
d773 1
d786 1
a786 1
	rrnum = find_rr_num(rrset, type, klass, rdatas, rdata_num);
d788 2
a789 2
		DEBUG(DEBUG_XFRD, 2, (LOG_ERR, "diff: RR %s already exists",
			dname_to_string(dname,0)));
d791 1
d817 19
a835 30
		if(type == TYPE_SOA) {
			uint32_t soa_minimum;
			zone->soa_rrset = rrset;
			zone->updated = 1;
			/* BUG #103 tweaked SOA ttl value */
			if(zone->soa_nx_rrset == 0) {
				zone->soa_nx_rrset = region_alloc(db->region,
					sizeof(rrset_type));
				if(!zone->soa_nx_rrset) {
					log_msg(LOG_ERR, "out of memory, %s:%d",
						__FILE__, __LINE__);
					exit(1);
				}
				zone->soa_nx_rrset->rr_count = 1;
				zone->soa_nx_rrset->next = 0;
				zone->soa_nx_rrset->zone = zone;
				zone->soa_nx_rrset->rrs = region_alloc(db->region,
					sizeof(rr_type));
				if(!zone->soa_nx_rrset->rrs) {
					log_msg(LOG_ERR, "out of memory, %s:%d",
						__FILE__, __LINE__);
					exit(1);
				}
			}
			memcpy(zone->soa_nx_rrset->rrs, rrset->rrs, sizeof(rr_type));
			memcpy(&soa_minimum, rdata_atom_data(rrset->rrs->rdatas[6]),
				rdata_atom_size(rrset->rrs->rdatas[6]));
			if (rrset->rrs->ttl > ntohl(soa_minimum)) {
				rrset->zone->soa_nx_rrset->rrs[0].ttl = ntohl(soa_minimum);
			}
d837 10
a846 2
		if(type == TYPE_NS) {
			zone->ns_rrset = rrset;
a847 11
#ifdef DNSSEC
		if(type == TYPE_RRSIG) {
			int i;
			for (i = 0; i < rrset->rr_count; ++i) {
				if (rr_rrsig_type_covered(&rrset->rrs[i]) == TYPE_SOA) {
					zone->is_secure = 1;
					break;
				}
			}
		}
#endif
d849 2
d855 2
a856 2
find_zone(namedb_type* db, const dname_type* zone_name, nsd_options_t* opt,
	size_t child_count)
a857 1
	domain_type *domain;
d859 28
a886 16
	domain = domain_table_find(db->domains, zone_name);
	if(!domain) {
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfr: creating domain %s",
			dname_to_string(zone_name,0)));
		/* create the zone and domain of apex (zone has config options) */
		domain = domain_table_insert(db->domains, zone_name);
	} else {
		/* O(1) if SOA exists */
		zone = domain_find_zone(domain);
		/* if domain was empty (no rrsets, empty zone) search in zonelist */
		/* check apex to make sure we don't find a parent zone */
		if(!zone || zone->apex != domain)
			zone = namedb_find_zone(db, domain);
		if(zone) {
			assert(zone->apex == domain);
			return zone;
d889 1
a889 35
	/* create the zone */
	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfr: creating zone_type %s",
		dname_to_string(zone_name,0)));
	zone = (zone_type *) region_alloc(db->region, sizeof(zone_type));
	if(!zone) {
		log_msg(LOG_ERR, "out of memory, %s:%d", __FILE__, __LINE__);
		exit(1);
	}
	zone->next = db->zones;
	db->zones = zone;
	db->zone_count++;
	zone->apex = domain;
	zone->soa_rrset = 0;
	zone->soa_nx_rrset = 0;
	zone->ns_rrset = 0;
#ifdef NSEC3
	zone->nsec3_soa_rr = NULL;
	zone->nsec3_last = NULL;
#endif
	zone->dirty = region_alloc(db->region, sizeof(uint8_t)*child_count);
	if(!zone->dirty) {
		log_msg(LOG_ERR, "out of memory, %s:%d", __FILE__, __LINE__);
		exit(1);
	}
	memset(zone->dirty, 0, sizeof(uint8_t)*child_count);
	zone->opts = zone_options_find(opt, domain_dname(zone->apex));
	if(!zone->opts) {
		log_msg(LOG_ERR, "xfr: zone %s not in config.",
			dname_to_string(zone_name,0));
		return 0;
	}
	zone->number = db->zone_count;
	zone->is_secure = 0;
	zone->updated = 1;
	zone->is_ok = 0;
d893 1
a893 1
static void
d897 2
a898 1
	domain_type *domain = zone->apex;
d900 1
a900 2
	while(domain && dname_is_subdomain(
		domain_dname(domain), domain_dname(zone->apex)))
d903 1
a903 1
			dname_to_string(domain_dname(domain),0)));
d906 3
d910 27
a937 1
		domain = domain_next(domain);
d943 1
a943 1
	if(nsd_debug_level >= 1)
d948 1
a948 1
	/* keep zone->soa_nx_rrset alloced */
a950 1
	assert(zone->updated == 1);
d953 1
d955 2
a956 3
apply_ixfr(namedb_type* db, FILE *in, const off_t* startpos,
	const char* zone, uint32_t serialno, nsd_options_t* opt,
	uint16_t id, uint32_t seq_nr, uint32_t seq_total,
d958 2
a959 1
	size_t child_count)
d961 1
a961 1
	uint32_t filelen, msglen, pkttype, timestamp[2];
d969 6
a974 10
	char file_zone_name[3072];
	uint32_t file_serial, file_seq_nr;
	uint16_t file_id;
	off_t mempos;

	memmove(&mempos, startpos, sizeof(off_t));
	if(fseeko(in, mempos, SEEK_SET) == -1) {
		log_msg(LOG_INFO, "could not fseeko: %s.", strerror(errno));
		return 0;
	}
d976 1
a976 2

	if(!diff_read_32(in, &pkttype) || pkttype != DIFF_PART_IXFR) {
a979 5
	if(!diff_read_32(in, &timestamp[0]) ||
	   !diff_read_32(in, &timestamp[1])) {
		log_msg(LOG_ERR, "could not read timestamp");
		return 0;
	}
d981 1
a981 1
	if(!diff_read_32(in, &filelen)) {
d986 1
a986 2
	/* read header */
	if(filelen < QHEADERSZ + sizeof(uint32_t)*3 + sizeof(uint16_t)) {
a995 19

	if(!diff_read_str(in, file_zone_name, sizeof(file_zone_name)) ||
		!diff_read_32(in, &file_serial) ||
		!diff_read_16(in, &file_id) ||
		!diff_read_32(in, &file_seq_nr))
	{
		log_msg(LOG_ERR, "could not part data");
		region_destroy(region);
		return 0;
	}

	if(strcmp(file_zone_name, zone) != 0 || serialno != file_serial ||
		id != file_id || seq_nr != file_seq_nr) {
		log_msg(LOG_ERR, "internal error: reading part with changed id");
		region_destroy(region);
		return 0;
	}
	msglen = filelen - sizeof(uint32_t)*3 - sizeof(uint16_t)
		- strlen(file_zone_name);
a996 8
	dname_zone = dname_parse(region, zone);
	zone_db = find_zone(db, dname_zone, opt, child_count);
	if(!zone_db) {
		log_msg(LOG_ERR, "no zone exists");
		region_destroy(region);
		return 0;
	}

d1010 17
d1082 2
a1083 2
			log_msg(LOG_ERR, "SOA serial %d different from commit %d",
				buffer_read_u32(packet), serialno);
a1091 1

d1127 3
d1131 6
d1158 3
d1162 6
d1171 11
d1208 1
a1208 1
				rrlen, zone_db, region)) {
d1217 1
a1217 1
				rrlen, zone_db)) {
d1237 1
a1237 1
		zone = domain_find_zone(domain);
a1251 127
/* for multiple tcp packets use a data structure that has
 * a rbtree (zone_names) with for each zone:
 * 	has a rbtree by sequence number
 *		with inside a serial_number and ID (for checking only)
 *		and contains a off_t to the IXFR packet in the file.
 * so when you get a commit for a zone, get zone obj, find sequence,
 * then check if you have all sequence numbers available. Apply all packets.
 */
struct diff_read_data {
	/* rbtree of struct diff_zone*/
	rbtree_t* zones;
	/* region for allocation */
	region_type* region;
};
struct diff_zone {
	/* key is dname of zone */
	rbnode_t node;
	/* rbtree of struct diff_xfrpart */
	rbtree_t* parts;
};
struct diff_xfrpart {
	/* key is sequence number */
	rbnode_t node;
	uint32_t seq_nr;
	uint32_t new_serial;
	uint16_t id;
	off_t file_pos;
};

static struct diff_read_data*
diff_read_data_create()
{
	region_type* region = region_create(xalloc, free);
	struct diff_read_data* data = (struct diff_read_data*)
		region_alloc(region, sizeof(struct diff_read_data));
	if(!data) {
		log_msg(LOG_ERR, "out of memory, %s:%d", __FILE__, __LINE__);
		exit(1);
	}
	data->region = region;
	data->zones = rbtree_create(region,
		(int (*)(const void *, const void *)) dname_compare);
	return data;
}

static struct diff_zone*
diff_read_find_zone(struct diff_read_data* data, const char* name)
{
	const dname_type* dname = dname_parse(data->region, name);
	struct diff_zone* zp = (struct diff_zone*)
		rbtree_search(data->zones, dname);
	return zp;
}

static int intcompf(const void* a, const void* b)
{
	if(*(uint32_t*)a < *(uint32_t*)b)
		return -1;
	if(*(uint32_t*)a > *(uint32_t*)b)
		return +1;
	return 0;
}

static struct diff_zone*
diff_read_insert_zone(struct diff_read_data* data, const char* name)
{
	const dname_type* dname = dname_parse(data->region, name);
	struct diff_zone* zp = region_alloc(data->region,
		sizeof(struct diff_zone));
	if(!zp) {
		log_msg(LOG_ERR, "out of memory, %s:%d", __FILE__, __LINE__);
		exit(1);
	}
	zp->node = *RBTREE_NULL;
	zp->node.key = dname;
	zp->parts = rbtree_create(data->region, intcompf);
	rbtree_insert(data->zones, (rbnode_t*)zp);
	return zp;
}

static struct diff_xfrpart*
diff_read_find_part(struct diff_zone* zp, uint32_t seq_nr)
{
	struct diff_xfrpart* xp = (struct diff_xfrpart*)
		rbtree_search(zp->parts, &seq_nr);
	return xp;
}

static struct diff_xfrpart*
diff_read_insert_part(struct diff_read_data* data,
	struct diff_zone* zp, uint32_t seq_nr)
{
	struct diff_xfrpart* xp = region_alloc(data->region,
		sizeof(struct diff_xfrpart));
	if(!xp) {
		log_msg(LOG_ERR, "out of memory, %s:%d", __FILE__, __LINE__);
		exit(1);
	}
	xp->node = *RBTREE_NULL;
	xp->node.key = &xp->seq_nr;
	xp->seq_nr = seq_nr;
	rbtree_insert(zp->parts, (rbnode_t*)xp);
	return xp;
}

/* mark commit as rollback and close inputfile, fatal exits */
static void
mark_and_exit(nsd_options_t* opt, FILE* f, off_t commitpos, const char* desc)
{
	const char* filename = opt->difffile;
	fclose(f);
	if(!(f = fopen(filename, "r+"))) {
		log_msg(LOG_ERR, "mark xfr, failed to re-open difffile %s: %s",
			filename, strerror(errno));
	} else if(fseeko(f, commitpos, SEEK_SET) == -1) {
		log_msg(LOG_INFO, "could not fseeko: %s.", strerror(errno));
		fclose(f);
	} else {
		uint8_t c = 0;
		fwrite(&c, sizeof(c), 1, f);
		fclose(f);
		log_msg(LOG_ERR, "marked xfr as failed: %s", desc);
		log_msg(LOG_ERR, "marked xfr so that next reload can succeed");
	}
	exit(1);
}

d1253 3
a1255 3
read_sure_part(namedb_type* db, FILE *in, nsd_options_t* opt,
	struct diff_read_data* data, struct diff_log** log,
	size_t child_count)
d1259 5
a1263 2
	uint32_t old_serial, new_serial, num_parts;
	uint16_t id;
a1264 1
	struct diff_zone *zp;
d1266 1
a1266 3
	int have_all_parts = 1;
	struct diff_log* thislog = 0;
	off_t commitpos;
d1269 2
a1270 6
	if(!diff_read_str(in, zone_buf, sizeof(zone_buf)) ||
		!diff_read_32(in, &old_serial) ||
		!diff_read_32(in, &new_serial) ||
		!diff_read_16(in, &id) ||
		!diff_read_32(in, &num_parts)) {
		log_msg(LOG_ERR, "diff file bad commit part");
d1273 2
a1274 3
	commitpos = ftello(in); /* position of commit byte */
	if(commitpos == -1) {
		log_msg(LOG_INFO, "could not ftello: %s.", strerror(errno));
d1276 1
d1278 4
d1283 9
a1291 2
		!diff_read_str(in, log_buf, sizeof(log_buf)) )
	{
d1296 9
a1304 11
	if(log) {
		thislog = (struct diff_log*)region_alloc(db->region, sizeof(struct diff_log));
		if(!thislog) {
			log_msg(LOG_ERR, "out of memory, %s:%d", __FILE__, __LINE__);
			exit(1);
		}
		thislog->zone_name = region_strdup(db->region, zone_buf);
		thislog->comment = region_strdup(db->region, log_buf);
		thislog->error = 0;
		thislog->next = *log;
		*log = thislog;
d1306 3
a1308 8

	/* has been read in completely */
	zp = diff_read_find_zone(data, zone_buf);
	if(!zp) {
		log_msg(LOG_ERR, "diff file commit without IXFR");
		if(thislog)
			thislog->error = "error no IXFR parts";
		return 1;
d1310 1
a1310 1
	if(committed && check_for_bad_serial(db, zone_buf, old_serial)) {
a1312 4
		zp->parts->root = RBTREE_NULL;
		zp->parts->count = 0;
		if(thislog)
			thislog->error = "error bad serial";
a1314 12
	for(i=0; i<num_parts; i++) {
		struct diff_xfrpart *xp = diff_read_find_part(zp, i);
		if(!xp || xp->id != id || xp->new_serial != new_serial) {
			have_all_parts = 0;
		}
	}
	if(!have_all_parts) {
		DEBUG(DEBUG_XFRD,1, (LOG_ERR,
			"skipping diff file commit without all parts"));
		if(thislog)
			thislog->error = "error missing parts";
	}
d1316 1
a1316 1
	if(committed && have_all_parts)
d1318 25
a1342 8
		int is_axfr=0, delete_mode=0, rr_count=0;
		off_t resume_pos;

		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "processing xfr: %s", log_buf));
		resume_pos = ftello(in);
		if(resume_pos == -1) {
			log_msg(LOG_INFO, "could not ftello: %s.", strerror(errno));
			return 0;
d1344 1
d1346 1
a1346 1
			struct diff_xfrpart *xp = diff_read_find_part(zp, i);
d1348 11
a1358 6
			if(!apply_ixfr(db, in, &xp->file_pos, zone_buf, new_serial, opt,
				id, xp->seq_nr, num_parts, &is_axfr, &delete_mode,
				&rr_count, child_count)) {
				log_msg(LOG_ERR, "bad ixfr packet part %d in %s", (int)i,
					opt->difffile);
				mark_and_exit(opt, in, commitpos, log_buf);
d1361 47
a1407 3
		if(fseeko(in, resume_pos, SEEK_SET) == -1) {
			log_msg(LOG_INFO, "could not fseeko: %s.", strerror(errno));
			return 0;
d1413 2
d1416 3
a1418 4
	/* clean out the parts for the zone after the commit/rollback */
	zp->parts->root = RBTREE_NULL;
	zp->parts->count = 0;
	return 1;
d1422 2
a1423 1
store_ixfr_data(FILE *in, uint32_t len, struct diff_read_data* data, off_t* startpos)
d1425 7
a1431 23
	char zone_name[3072];
	struct diff_zone* zp;
	struct diff_xfrpart* xp;
	uint32_t new_serial, seq;
	uint16_t id;
	if(!diff_read_str(in, zone_name, sizeof(zone_name)) ||
		!diff_read_32(in, &new_serial) ||
		!diff_read_16(in, &id) ||
		!diff_read_32(in, &seq)) {
		log_msg(LOG_INFO, "could not read ixfr store info: file format error");
		return 0;
	}
	len -= sizeof(uint32_t)*3 + sizeof(uint16_t) + strlen(zone_name);
	if(fseeko(in, len, SEEK_CUR) == -1)
		log_msg(LOG_INFO, "fseek failed: %s", strerror(errno));
	/* store the info */
	zp = diff_read_find_zone(data, zone_name);
	if(!zp)
		zp = diff_read_insert_zone(data, zone_name);
	xp = diff_read_find_part(zp, seq);
	if(xp) {
		log_msg(LOG_INFO, "discarding partial xfr part: %s %d", zone_name, seq);
		/* overwrite with newer value (which probably relates to next commit) */
d1433 11
a1443 2
	else {
		xp = diff_read_insert_part(data, zp, seq);
a1444 3
	xp->new_serial = new_serial;
	xp->id = id;
	memmove(&xp->file_pos, startpos, sizeof(off_t));
d1448 2
a1449 4
static int
read_process_part(namedb_type* db, FILE *in, uint32_t type,
	nsd_options_t* opt, struct diff_read_data* data,
	struct diff_log** log, size_t child_count, off_t* startpos)
d1451 22
a1472 1
	uint32_t len, len2;
d1474 4
a1477 8
	/* read length */
	if(!diff_read_32(in, &len))
		return 1;
	/* read content */
	if(type == DIFF_PART_IXFR) {
		DEBUG(DEBUG_XFRD,2, (LOG_INFO, "part IXFR len %d", len));
		if(!store_ixfr_data(in, len, data, startpos))
			return 0;
d1479 30
a1508 7
	else if(type == DIFF_PART_SURE) {
		DEBUG(DEBUG_XFRD,2, (LOG_INFO, "part SURE len %d", len));
		if(!read_sure_part(db, in, opt, data, log, child_count))
			return 0;
	} else {
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "unknown part %x len %d", type, len));
		return 0;
d1510 16
a1525 7
	/* read length */
	if(!diff_read_32(in, &len2))
		return 1; /* short read is OK */
	/* verify length */
	if(len != len2)
		return 0; /* bad data is wrong */
	return 1;
d1528 1
a1528 6
/*
 * Finds smallest offset in data structs
 * returns 0 if no offsets in the data structs.
 */
static int
find_smallest_offset(struct diff_read_data* data, off_t* offset)
d1530 13
a1542 4
	int found_any = 0;
	struct diff_zone* dz;
	struct diff_xfrpart* dx;
	off_t mem_offset, mem_fpos;
d1544 16
a1559 9
	if(!data || !data->zones)
		return 0;
	RBTREE_FOR(dz, struct diff_zone*, data->zones)
	{
		if(!dz->parts)
			continue;
		RBTREE_FOR(dx, struct diff_xfrpart*, dz->parts)
		{
			memmove(&mem_fpos, &dx->file_pos, sizeof(off_t));
d1561 14
a1574 2
			if(found_any) {
				memmove(&mem_offset, offset, sizeof(off_t));
d1576 9
a1584 7
				if(mem_fpos < mem_offset)
					memmove(offset, &mem_fpos, sizeof(off_t));
			} else {
				found_any = 1;
				memmove(offset, &mem_fpos, sizeof(off_t));
			}
		}
d1586 4
d1591 12
a1602 1
	return found_any;
d1605 2
a1606 2
int
diff_read_file(namedb_type* db, nsd_options_t* opt, struct diff_log** log,
d1609 15
a1623 5
	const char* filename = opt->difffile;
	FILE *df;
	uint32_t type, timestamp[2], curr_timestamp[2];
	struct diff_read_data* data = diff_read_data_create();
	off_t startpos;
d1625 13
a1637 6
	df = fopen(filename, "r");
	if(!df) {
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "could not open file %s for reading: %s",
			filename, strerror(errno)));
		region_destroy(data->region);
		return 1;
d1639 6
d1646 13
a1658 3
	/* check timestamp */
	curr_timestamp[0] = (uint32_t) db->diff_timestamp.tv_sec;
	curr_timestamp[1] = (uint32_t) db->diff_timestamp.tv_usec;
d1660 11
a1670 5
	if(!diff_read_32(df, &type)) {
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "difffile %s is empty",
			filename));
		db->diff_skip = 0;
		db->diff_pos = 0;
d1672 59
a1730 6
	else if (!diff_read_32(df, &timestamp[0]) ||
		 !diff_read_32(df, &timestamp[1])) {
		log_msg(LOG_ERR, "difffile %s bad first part: no timestamp",
			filename);
		region_destroy(data->region);
		return 0;
d1732 5
a1736 5
	else if (curr_timestamp[0] != timestamp[0] ||
		 curr_timestamp[1] != timestamp[1]) {
		/* new timestamp, no skipping */
		db->diff_timestamp.tv_sec = (time_t) timestamp[0];
		db->diff_timestamp.tv_usec = (suseconds_t) timestamp[1];
d1738 8
a1745 9
		if (db->diff_skip) {
			DEBUG(DEBUG_XFRD,1, (LOG_INFO, "new timestamp on "
				"difffile %s, restoring diff_skip and diff_pos "
				"[old timestamp: %u.%u; new timestamp: %u.%u]",
				filename, curr_timestamp[0], curr_timestamp[1],
				timestamp[0], timestamp[1]));
			db->diff_skip = 0;
			db->diff_pos = 0;
		}
d1747 10
d1758 9
a1766 5
	/* Always seek, to diff_pos or to beginning of the file. */
	if (fseeko(df, 0, SEEK_SET)==-1) {
		log_msg(LOG_INFO, "could not fseeko file %s: %s.", filename,
				strerror(errno));
		region_destroy(data->region);
d1769 7
a1775 8
	if(db->diff_skip) {
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "skip diff file"));
		if(fseeko(df, db->diff_pos, SEEK_SET)==-1) {
			log_msg(LOG_INFO, "could not fseeko file %s: %s. "
					  "Reread from start.", filename,
				strerror(errno));
		}
	}
d1777 11
a1787 5
	startpos = ftello(df);
	if(startpos == -1) {
		log_msg(LOG_INFO, "could not ftello: %s.", strerror(errno));
		region_destroy(data->region);
		return 0;
d1789 12
d1802 6
a1807 5
	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "start of diff file read at pos %u",
		(uint32_t) db->diff_pos));
	while(diff_read_32(df, &type))
	{
		DEBUG(DEBUG_XFRD,2, (LOG_INFO, "iter loop"));
d1809 14
a1822 22
		/* read timestamp */
		if(!diff_read_32(df, &timestamp[0]) ||
			!diff_read_32(df, &timestamp[1])) {
			log_msg(LOG_INFO, "could not read timestamp: %s.",
				strerror(errno));
			region_destroy(data->region);
			return 0;
		}

		if(!read_process_part(db, df, type, opt, data, log,
			child_count, &startpos))
		{
			log_msg(LOG_INFO, "error processing diff file");
			region_destroy(data->region);
			return 0;
		}
		startpos = ftello(df);
		if(startpos == -1) {
			log_msg(LOG_INFO, "could not ftello: %s.", strerror(errno));
			region_destroy(data->region);
			return 0;
		}
d1824 1
a1824 1
	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "end of diff file read"));
d1826 8
a1833 4
	if(find_smallest_offset(data, &db->diff_pos)) {
		/* can skip to the first unused element */
		DEBUG(DEBUG_XFRD,2, (LOG_INFO, "next time skip diff file"));
		db->diff_skip = 1;
d1835 1
a1835 9
		/* all processed, can skip to here next time */
		DEBUG(DEBUG_XFRD,2, (LOG_INFO, "next time skip diff file"));
		db->diff_skip = 1;
		db->diff_pos = ftello(df);
		if(db->diff_pos == -1) {
			log_msg(LOG_INFO, "could not ftello: %s.",
				strerror(errno));
			db->diff_skip = 0;
		}
d1837 1
d1839 26
a1864 3
	region_destroy(data->region);
	fclose(df);
	return 1;
d1867 2
a1868 1
static int diff_broken(FILE *df, off_t* break_pos)
d1870 7
a1876 2
	uint32_t type, len, len2;
	*break_pos = ftello(df);
d1878 10
a1887 13
	/* try to read and validate parts of the file */
	while(diff_read_32(df, &type)) /* cannot read type is no error, normal EOF */
	{
		/* check type */
		if(type != DIFF_PART_IXFR && type != DIFF_PART_SURE)
			return 1;
		/* check length */
		if(!diff_read_32(df, &len))
			return 1; /* EOF inside the part is error */
		if(fseeko(df, len, SEEK_CUR) == -1)
		{
			log_msg(LOG_INFO, "fseeko failed: %s", strerror(errno));
			return 1;
a1888 8
		/* fseek clears EOF flag, but try reading length value,
		   if EOF, the part is truncated */
		if(!diff_read_32(df, &len2))
			return 1;
		if(len != len2)
			return 1; /* bad part, lengths must agree */
		/* this part is ok */
		*break_pos = ftello(df);
d1890 52
a1941 1
	return 0;
d1944 2
a1945 1
void diff_snip_garbage(namedb_type* db, nsd_options_t* opt)
d1947 11
a1957 3
	off_t break_pos;
	const char* filename = opt->difffile;
	FILE *df;
d1959 20
a1978 2
	/* open file here and keep open, so it cannot change under our nose */
	df = fopen(filename, "r+");
d1980 4
a1983 2
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "could not open file %s for garbage collecting: %s",
			filename, strerror(errno)));
d1986 5
a1990 9
	/* and skip into file, since nsd does not read anything before the pos */
	if(db->diff_skip) {
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "garbage collect skip diff file"));
		if(fseeko(df, db->diff_pos, SEEK_SET)==-1) {
			log_msg(LOG_INFO, "could not fseeko file %s: %s.",
				filename, strerror(errno));
			fclose(df);
			return;
		}
d1993 49
a2041 9
	/* detect break point */
	if(diff_broken(df, &break_pos))
	{
		/* snip off at break_pos */
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "snipping off trailing partial part of %s",
			filename));
		if(ftruncate(fileno(df), break_pos) == -1)
			log_msg(LOG_ERR, "ftruncate %s failed: %s",
				filename, strerror(errno));
d2043 1
a2043 2

	fclose(df);
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.5
@
text
@d1065 1
a1065 1
		(void)write_data(f, &c, sizeof(c));
@


1.1.1.3
log
@NSD v3.2.6
@
text
@d297 1
d306 1
d546 1
d556 1
@


1.1.1.4
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.5
log
@NSD v3.2.9
@
text
@a19 1
#include "nsec3.h"
a292 1
		domain->has_SOA = 0;
d299 1
a299 1
			if (rr_rrsig_type_covered(&rrset->rrs[i]) == TYPE_DNSKEY) {
a304 9

#ifdef NSEC3
#ifndef FULL_PREHASH
	if (rrset->rrs[0].type == TYPE_NSEC3) {
		namedb_del_nsec3_domain(db, domain, rrset->zone);
	}
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */

a320 2
				if(has_data_below(p))
					break;
d375 1
a375 1
	region_type* temp_region, int is_axfr)
a414 15
#ifdef NSEC3
#ifndef FULL_PREHASH
		if (is_axfr == 0) {
			struct domain *parent = domain;
			do {
				if (0 != namedb_add_nsec3_mod_domain(db,
								    parent)) {
					return 0;
				}
				parent = parent->parent;
			} while (parent != zone->apex->parent);
		}
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */

d443 1
a443 2
	buffer_type* packet, size_t rdatalen, zone_type *zone,
	int is_axfr)
a539 1
			domain->has_SOA = 1;
d547 1
a547 1
				if (rr_rrsig_type_covered(&rrset->rrs[i]) == TYPE_DNSKEY) {
a553 20

#ifdef NSEC3
#ifndef FULL_PREHASH
	if ((type == TYPE_NSEC3) &&
	    (rrset->rr_count == 1)) {
		/* NSEC3 RRset just added */
		if (0 != namedb_add_nsec3_domain(db, domain, zone))
			return 0;
	}
	if (is_axfr == 0) {
		struct domain *parent = domain;
		do {
			if (0 != namedb_add_nsec3_mod_domain(db, parent))
				return 0;
			parent = parent->parent;
		} while (parent != zone->apex->parent);
	}
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */

a611 12
#ifdef NSEC3
#ifndef FULL_PREHASH
	zone->nsec3_domains = NULL;

	if (0 != zone_nsec3_domains_create(db, zone)) {
		log_msg(LOG_ERR,
			"xfr: zone NSEC3 domains "
			"memory allocation failure");
		return 0;
	}
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */
a623 7
	zone->updated = 1;
#ifdef NSEC3
#ifndef FULL_PREHASH
	zone_nsec3_domains_destroy(db, zone);
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */

a635 10
#ifdef NSEC3
#ifndef FULL_PREHASH
	if (0 != zone_nsec3_domains_create(db, zone)) {
		log_msg(LOG_ERR,
			"Zone %s: unable to create zone NSEC3 prehash table",
			dname_to_string(domain_dname(zone->apex),
			NULL));
	}
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */
a650 1
/* return value 0: syntaxerror,badIXFR, 1:OK, 2:done_and_skip_it */
a871 11
			/* must have stuff in memory for a successful IXFR,
			 * the serial number of the SOA has been checked
			 * previously (by check_for_bad_serial) if it exists */
			if(!*is_axfr && !domain_find_rrset(zone_db->apex,
				zone_db, TYPE_SOA)) {
				log_msg(LOG_ERR, "%s SOA serial %d is not "
					"in memory, skip IXFR", zone, serialno);
				region_destroy(region);
				/* break out and stop the IXFR, ignore it */
				return 2;
			}
d898 1
a898 1
				rrlen, zone_db, region, *is_axfr)) {
d907 1
a907 1
				rrlen, zone_db, *is_axfr)) {
a1154 33

#ifdef NSEC3
#ifndef FULL_PREHASH
		struct region *region;
		dname_type const *zone_dname;
		struct zone *zone;

		region = region_create(xalloc, free);
		if (region == NULL) {
			log_msg(LOG_ERR, "out of memory");
			return 0;
		}
		zone_dname = dname_parse(region, zone_buf);
		if (zone_dname == NULL) {
			log_msg(LOG_ERR, "out of memory");
		        region_destroy(region);
			return 0;
		}
		zone = find_zone(db, zone_dname, opt, child_count);
		region_destroy(region);
		if (zone == NULL) {
			log_msg(LOG_ERR, "no zone exists");
			return 0;
		}
		if (0 != namedb_nsec3_mod_domains_create(db)) {
			log_msg(LOG_ERR,
				"unable to allocate space "
				"for modified NSEC3 domains");
			return 0;
		}
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */

a1161 1
			int ret;
d1163 1
a1163 1
			ret = apply_ixfr(db, in, &xp->file_pos, zone_buf, new_serial, opt,
d1165 1
a1165 2
				&rr_count, child_count);
			if(ret == 0) {
a1168 2
			} else if(ret == 2) {
				break;
a1170 9
#ifdef NSEC3
#ifndef FULL_PREHASH
		if (is_axfr != 0)
			prehash_zone(db, zone);
		else
			prehash_zone_incremental(db, zone);
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */

@


1.1.1.6
log
@import nsd 3.2.10, "cool" jakob@@, also looked over by Brad
@
text
@d271 1
a271 29

/* this routine makes empty terminals non-existent.
 * @@domain the lowest empty terminal
 * @@ce the closest encloser
 */
static domain_type*
rrset_delete_empty_terminals(domain_type* domain, domain_type* ce)
{
	assert(domain);
	if (domain->rrsets == 0) {
		/* if there is no data below it, it becomes non existing.
		   also empty nonterminals above it become nonexisting */
		/* check for data below this node. */
		if(!has_data_below(domain)) {
			/* nonexist this domain and all parent empty nonterminals */
			domain_type* p = domain;
			while(p != NULL && p->rrsets == 0) {
				if(p == ce || has_data_below(p))
					return p;
				p->is_existing = 0;
				p = p->parent;
			}
		}
	}
	return NULL;
}


static domain_type*
d282 1
a282 1
		return NULL;
a320 1
	rrset->rr_count = 0;
d324 14
a337 2
	if (domain->rrsets == 0) {
		return domain;
d339 1
a339 1
	return NULL;
a386 1
	domain_type* prevdomain,
a439 2
#else
		(void)is_axfr;
d445 1
a445 5
			domain = rrset_delete(db, domain, rrset);
			if (domain && domain != prevdomain && !domain->nextdiff) {
				/* this domain is not yet in the diff chain */
				prevdomain->nextdiff = domain;
			}
a600 2
#else
	(void)is_axfr;
a685 1
	domain_type *next = NULL;
d701 1
a701 1
			(void)rrset_delete(db, domain, rrset);
d703 1
a703 3
		next = domain_next(domain);
		domain->nextdiff = next;
		domain = next;
a729 13
/* fix empty terminals */
static void
fix_empty_terminals(zone_type* zone_db)
{
	domain_type* domain = zone_db->apex, *ce = NULL, *next = NULL;
	while (domain) {
		ce = rrset_delete_empty_terminals(domain, ce);
		next = domain->nextdiff;
		domain->nextdiff = NULL;
		domain = next;
	}
}

a745 1
	domain_type* last_in_list;
a895 1
	last_in_list = zone_db->apex;
d988 1
a988 1
			if(!delete_RR(db, dname, type, klass, last_in_list, packet,
a992 3
			if (!*is_axfr && last_in_list->nextdiff) {
				last_in_list = last_in_list->nextdiff;
			}
a1003 1
        fix_empty_terminals(zone_db);
@


1.1.1.7
log
@NSD v3.2.11, ok phessler@@
@
text
@d852 1
a852 2
		/* break out and stop the IXFR, ignore it */
		return 2;
d1051 1
a1051 1
	fix_empty_terminals(zone_db);
d1316 1
a1316 2
			/* just stop trying applying ixfr */
			return 1;
@


1.1.1.8
log
@update to NSD 3.2.13

- fix crash in nsd-patch if a zone has been removed from nsd.conf. (difffile.c)

- CVE-2012-2979 DOS fix, this is in optional code which is *not* used with
a standard OpenBSD build. (query.c, server.c)
@
text
@a638 1
	zone_options_t* opts;
a656 7
	/* lookup in config */
	opts = zone_options_find(opt, domain_dname(domain));
	if(!opts) {
		log_msg(LOG_ERR, "xfr: zone %s not in config.",
			dname_to_string(zone_name,0));
		return 0;
	}
a665 1
	zone->opts = opts;
d682 6
@


1.1.1.9
log
@update to NSD 3.2.14, requested by/ok brad@@
@
text
@a1514 1
		fclose(df);
a1538 1
		fclose(df);
a1553 1
		fclose(df);
a1568 1
			fclose(df);
a1576 1
			fclose(df);
a1582 1
			fclose(df);
@


1.1.1.10
log
@Update to NSD 3.2.15, ok brad@@ phessler@@ deraadt@@ also tested by okan@@
@
text
@d10 1
a10 1
#include "config.h"
d88 1
d442 2
a443 2
			log_msg(LOG_WARNING, "diff: RR <%s, %s> does not exist",
				dname_to_string(dname,0), rrtype_to_string(type));
d535 2
a536 2
		DEBUG(DEBUG_XFRD, 2, (LOG_ERR, "diff: RR <%s, %s> already exists",
			dname_to_string(dname,0), rrtype_to_string(type)));
d1297 2
a1330 2

		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "processing xfr: %s", log_buf));
@


1.1.1.11
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@a538 8
	if(domain == zone->apex) {
		/* make sure we don't get multiple soa rrs  */
		if (type == TYPE_SOA && rrset->rr_count > 0) {
			log_msg(LOG_ERR, "diff: multiple soa records for %s",
				dname_to_string(dname,0));
			return 0;
		}
	}
@


1.1.1.12
log
@import NSD 4.0.0, tests from Dorian Bttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
a16 1
#include "xfrd-disk.h"
a19 2
#include "udb.h"
#include "udbzone.h"
a20 2
#include "nsd.h"
#include "rrl.h"
d23 1
a23 1
write_64(FILE *out, uint64_t val)
d25 1
d30 1
a30 1
write_32(FILE *out, uint32_t val)
d32 1
a32 1
	val = htonl(val);
d52 2
a53 3
diff_write_packet(const char* zone, const char* pat, uint32_t old_serial,
	uint32_t new_serial, uint32_t seq_nr, uint8_t* data, size_t len,
	struct nsd* nsd, uint64_t filenumber)
d55 9
a63 4
	FILE* df = xfrd_open_xfrfile(nsd, filenumber, seq_nr?"a":"w");
	if(!df) {
		log_msg(LOG_ERR, "could not open transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
d67 5
a71 23
	/* if first part, first write the header */
	if(seq_nr == 0) {
		struct timeval tv;
		if (gettimeofday(&tv, NULL) != 0) {
			log_msg(LOG_ERR, "could not get timestamp for %s: %s",
				zone, strerror(errno));
		}
		if(!write_32(df, DIFF_PART_XFRF) ||
			!write_8(df, 0) /* notcommitted(yet) */ ||
			!write_32(df, 0) /* numberofparts when done */ ||
			!write_64(df, (uint64_t) tv.tv_sec) ||
			!write_32(df, (uint32_t) tv.tv_usec) ||
			!write_32(df, old_serial) ||
			!write_32(df, new_serial) ||
			!write_64(df, (uint64_t) tv.tv_sec) ||
			!write_32(df, (uint32_t) tv.tv_usec) ||
			!write_str(df, zone) ||
			!write_str(df, pat)) {
			log_msg(LOG_ERR, "could not write transfer %s file %lld: %s",
				zone, (long long)filenumber, strerror(errno));
			fclose(df);
			return;
		}
d74 8
a81 2
	if(!write_32(df, DIFF_PART_XXFR) ||
		!write_32(df, len) ||
d83 1
a83 1
		!write_32(df, len))
d85 2
a86 2
		log_msg(LOG_ERR, "could not write transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
d92 3
a94 3
diff_write_commit(const char* zone, uint32_t old_serial, uint32_t new_serial,
	uint32_t num_parts, uint8_t commit, const char* log_str,
	struct nsd* nsd, uint64_t filenumber)
d96 1
d98 2
a99 1
	FILE* df;
d103 2
a104 1
			zone, strerror(errno));
d107 1
a107 6
	/* overwrite the first part of the file with 'committed = 1', 
	 * as well as the end_time and number of parts.
	 * also write old_serial and new_serial, so that a bad file mixup
	 * will result in unusable serial numbers. */

	df = xfrd_open_xfrfile(nsd, filenumber, "r+");
d109 2
a110 2
		log_msg(LOG_ERR, "could not open transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
d113 7
a119 4
	if(!write_32(df, DIFF_PART_XFRF) ||
		!write_8(df, commit) /* committed */ ||
		!write_32(df, num_parts) ||
		!write_64(df, (uint64_t) tv.tv_sec) ||
d121 2
d124 6
a129 1
		!write_32(df, new_serial))
d131 2
a132 19
		log_msg(LOG_ERR, "could not write transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
		fclose(df);
		return;
	}

	/* append the log_str to the end of the file */
	if(fseek(df, 0, SEEK_END) == -1) {
		log_msg(LOG_ERR, "could not fseek transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
		fclose(df);
		return;
	}
	if(!write_str(df, log_str)) {
		log_msg(LOG_ERR, "could not write transfer %s file %lld: %s",
			zone, (long long)filenumber, strerror(errno));
		fclose(df);
		return;

d138 4
d143 1
a143 1
diff_read_64(FILE *in, uint64_t* result)
d145 41
a185 3
	if (fread(result, sizeof(*result), 1, in) == 1) {
		return 1;
	} else {
d187 1
a187 1
	}
d202 11
d262 1
a262 1
	while(d != NULL && domain_is_subdomain(d, top)) {
d270 29
a298 2
/** remove rrset.  Adjusts zone params.  Does not remove domain */
static void
d309 1
a309 1
		return;
d314 1
a314 1
		domain_to_string(domain),
d320 2
d328 1
a328 1
			if(rr_rrsig_type_covered(&rrset->rrs[i])==TYPE_DNSKEY) {
d334 9
d352 2
a353 14
	if(domain->rrsets == 0) {
		/* if there is no data below it, it becomes non existing.
		   also empty nonterminals above it become nonexisting */
		/* check for data below this node. */
		if(!has_data_below(domain)) {
			/* nonexist this domain and all parent empty nonterminals */
			domain_type* p = domain;
			while(p != NULL && p->rrsets == 0) {
				if(has_data_below(p))
					break;
				p->is_existing = 0;
				p = p->parent;
			}
		}
d355 1
d359 1
a359 2
rdatas_equal(rdata_atom_type *a, rdata_atom_type *b, int num, uint16_t type,
	int* rdnum, char** reason)
d366 1
a366 16
				domain_dname(b[k].domain))!=0) {
				*rdnum = k;
				*reason = "dname data";
				return 0;
			}
		} else if(rdata_atom_is_literal_domain(type, k)) {
			/* literal dname, but compare case insensitive */
			if(a[k].data[0] != b[k].data[0]) {
				*rdnum = k;
				*reason = "literal dname len";
				return 0; /* uncompressed len must be equal*/
			}
			if(!dname_equal_nocase((uint8_t*)(a[k].data+1),
				(uint8_t*)(b[k].data+1), a[k].data[0])) {
				*rdnum = k;
				*reason = "literal dname data";
a367 1
			}
d370 1
a370 3
			if(a[k].data[0] != b[k].data[0]) {
				*rdnum = k;
				*reason = "rdata len";
a371 1
			}
d373 1
a373 3
			if(memcmp(a[k].data+1, b[k].data+1, a[k].data[0])!=0) {
				*rdnum = k;
				*reason = "rdata data";
a374 1
			}
d380 3
a382 2
static void
debug_find_rr_num(rrset_type* rrset, uint16_t type, uint16_t klass,
d385 1
a385 44
	int i, rd;
	char* reason = "";

	for(i=0; i < rrset->rr_count; ++i) {
		if (rrset->rrs[i].type != type) {
			log_msg(LOG_WARNING, "diff: RR <%s, %s> does not match "
				"RR num %d type %s",
				dname_to_string(rrset->rrs[i].owner->dname,0),
				rrtype_to_string(type),	i,
				rrtype_to_string(rrset->rrs[i].type));
		}
		if (rrset->rrs[i].klass != klass) {
			log_msg(LOG_WARNING, "diff: RR <%s, %s> class %d "
				"does not match RR num %d class %d",
				dname_to_string(rrset->rrs[i].owner->dname,0),
				rrtype_to_string(type),
				klass, i,
				rrset->rrs[i].klass);
		}
		if (rrset->rrs[i].rdata_count != rdata_num) {
			log_msg(LOG_WARNING, "diff: RR <%s, %s> rdlen %u "
				"does not match RR num %d rdlen %d",
				dname_to_string(rrset->rrs[i].owner->dname,0),
				rrtype_to_string(type),
				(unsigned) rdata_num, i,
				(unsigned) rrset->rrs[i].rdata_count);
		}
		if (!rdatas_equal(rdatas, rrset->rrs[i].rdatas, rdata_num, type,
			&rd, &reason)) {
			log_msg(LOG_WARNING, "diff: RR <%s, %s> rdata element "
				"%d differs from RR num %d rdata (%s)",
				dname_to_string(rrset->rrs[i].owner->dname,0),
				rrtype_to_string(type),
				rd, i, reason);
		}
	}
}

static int
find_rr_num(rrset_type* rrset, uint16_t type, uint16_t klass,
	rdata_atom_type *rdatas, ssize_t rdata_num, int add)
{
	int i, rd;
	char* reason;
d391 1
a391 2
		   rdatas_equal(rdatas, rrset->rrs[i].rdatas, rdata_num, type,
			&rd, &reason))
d396 1
a396 4
        /* this is odd. Log why rr cannot be found. */
	if (!add) {
		debug_find_rr_num(rrset, type, klass, rdatas, rdata_num);
	}
d400 1
a400 196
#ifdef NSEC3
/* see if nsec3 deletion triggers need action */
static void
nsec3_delete_rr_trigger(namedb_type* db, rr_type* rr, zone_type* zone,
	udb_ptr* udbz)
{
	/* the RR has not actually been deleted yet, so we can inspect it */
	if(!zone->nsec3_param)
		return;
	/* see if the domain was an NSEC3-domain in the chain, but no longer */
	if(rr->type == TYPE_NSEC3 && rr->owner->nsec3 &&
		rr->owner->nsec3->nsec3_node.key &&
		nsec3_rr_uses_params(rr, zone) &&
		nsec3_in_chain_count(rr->owner, zone) <= 1) {
		domain_type* prev = nsec3_chain_find_prev(zone, rr->owner);
		/* remove from prehash because no longer an NSEC3 domain */
		if(domain_is_prehash(db->domains, rr->owner))
			prehash_del(db->domains, rr->owner);
		/* fixup the last in the zone */
		if(rr->owner == zone->nsec3_last)
			zone->nsec3_last = prev;
		/* unlink from the nsec3tree */
		zone_del_domain_in_hash_tree(zone->nsec3tree,
			&rr->owner->nsec3->nsec3_node);
		/* add previous NSEC3 to the prehash list */
		if(prev && prev != rr->owner)
			prehash_add(db->domains, prev);
		else	nsec3_clear_precompile(db, zone);
		/* this domain becomes ordinary data domain: done later */
	}
	/* see if the rr was NSEC3PARAM that we were using */
	else if(rr->type == TYPE_NSEC3PARAM && rr == zone->nsec3_param) {
		/* clear trees, wipe hashes, wipe precompile */
		nsec3_clear_precompile(db, zone);
		/* pick up new nsec3param from udb */
		nsec3_find_zone_param(db, zone, udbz);
		/* if no more NSEC3, done */
		if(!zone->nsec3_param)
			return;
		nsec3_precompile_newparam(db, zone);
	}
}

/* see if nsec3 prehash can be removed with new rrset content */
static void
nsec3_rrsets_changed_remove_prehash(domain_type* domain, zone_type* zone)
{
	/* deletion of rrset already done, we can check if conditions apply */
	/* see if the domain is no longer precompiled */
	/* it has a hash_node, but no longer fulfills conditions */
	if(nsec3_domain_part_of_zone(domain, zone) && domain->nsec3 &&
		domain->nsec3->hash_node.key &&
		!nsec3_condition_hash(domain, zone)) {
		/* remove precompile */
		domain->nsec3->nsec3_cover = NULL;
		domain->nsec3->nsec3_wcard_child_cover = NULL;
		domain->nsec3->nsec3_is_exact = 0;
		/* remove it from the hash tree */
		zone_del_domain_in_hash_tree(zone->hashtree,
			&domain->nsec3->hash_node);
		zone_del_domain_in_hash_tree(zone->wchashtree,
			&domain->nsec3->wchash_node);
	}
	if(domain != zone->apex && domain->nsec3 &&
		domain->nsec3->dshash_node.key &&
		!nsec3_condition_dshash(domain, zone)) {
		/* remove precompile */
		domain->nsec3->nsec3_ds_parent_cover = NULL;
		domain->nsec3->nsec3_ds_parent_is_exact = 0;
		/* remove it from the hash tree */
		zone_del_domain_in_hash_tree(zone->dshashtree,
			&domain->nsec3->dshash_node);
	}
}

/* see if domain needs to get precompiled info */
static void
nsec3_rrsets_changed_add_prehash(namedb_type* db, domain_type* domain,
	zone_type* zone)
{
	if(!zone->nsec3_param)
		return;
	if((!domain->nsec3 || !domain->nsec3->hash_node.key)
		&& nsec3_condition_hash(domain, zone)) {
		region_type* tmpregion = region_create(xalloc, free);
		nsec3_precompile_domain(db, domain, zone, tmpregion);
		region_destroy(tmpregion);
	}
	if((!domain->nsec3 || !domain->nsec3->dshash_node.key)
		&& nsec3_condition_dshash(domain, zone)) {
		nsec3_precompile_domain_ds(db, domain, zone);
	}
}

/* see if nsec3 rrset-deletion triggers need action */
static void
nsec3_delete_rrset_trigger(namedb_type* db, domain_type* domain,
	zone_type* zone, uint16_t type)
{
	if(!zone->nsec3_param)
		return;
	nsec3_rrsets_changed_remove_prehash(domain, zone);
	/* for type nsec3, or a delegation, the domain may have become a
	 * 'normal' domain with its remaining data now */
	if(type == TYPE_NSEC3 || type == TYPE_NS || type == TYPE_DS)
		nsec3_rrsets_changed_add_prehash(db, domain, zone);
	/* for type DNAME or a delegation, obscured data may be revealed */
	if(type == TYPE_NS || type == TYPE_DS || type == TYPE_DNAME) {
		/* walk over subdomains and check them each */
		domain_type *d;
		for(d=domain_next(domain); d && domain_is_subdomain(d, domain);
			d=domain_next(d)) {
			nsec3_rrsets_changed_add_prehash(db, d, zone);
		}
	}
}

/* see if nsec3 addition triggers need action */
static void
nsec3_add_rr_trigger(namedb_type* db, rr_type* rr, zone_type* zone,
	udb_ptr* udbz)
{
	/* the RR has been added in full, also to UDB (and thus NSEC3PARAM 
	 * in the udb has been adjusted) */
	if(zone->nsec3_param && rr->type == TYPE_NSEC3 &&
		(!rr->owner->nsec3 || !rr->owner->nsec3->nsec3_node.key)
		&& nsec3_rr_uses_params(rr, zone)) {
		/* added NSEC3 into the chain */
		nsec3_precompile_nsec3rr(db, rr->owner, zone);
		/* the domain has become an NSEC3-domain, if it was precompiled
		 * previously, remove that, neatly done in routine above */
		nsec3_rrsets_changed_remove_prehash(rr->owner, zone);
		/* set this NSEC3 to prehash */
		prehash_add(db->domains, rr->owner);
	} else if(!zone->nsec3_param && rr->type == TYPE_NSEC3PARAM) {
		/* see if this means NSEC3 chain can be used */
		nsec3_find_zone_param(db, zone, udbz);
		if(!zone->nsec3_param)
			return;
		nsec3_zone_trees_create(db->region, zone);
		nsec3_precompile_newparam(db, zone);
	}
}

/* see if nsec3 rrset-addition triggers need action */
static void
nsec3_add_rrset_trigger(namedb_type* db, domain_type* domain, zone_type* zone,
	uint16_t type)
{
	/* the rrset has been added so we can inspect it */
	if(!zone->nsec3_param)
		return;
	/* because the rrset is added we can check conditions easily.
	 * check if domain needs to become precompiled now */
	nsec3_rrsets_changed_add_prehash(db, domain, zone);
	/* if a delegation, it changes from normal name to unhashed referral */
	if(type == TYPE_NS || type == TYPE_DS) {
		nsec3_rrsets_changed_remove_prehash(domain, zone);
	}
	/* if delegation or DNAME added, then some RRs may get obscured */
	if(type == TYPE_NS || type == TYPE_DS || type == TYPE_DNAME) {
		/* walk over subdomains and check them each */
		domain_type *d;
		for(d=domain_next(domain); d && domain_is_subdomain(d, domain);
			d=domain_next(d)) {
			nsec3_rrsets_changed_remove_prehash(d, zone);
		}
	}
}
#endif /* NSEC3 */

/* fixup usage lower for domain names in the rdata */
static void
rr_lower_usage(namedb_type* db, rr_type* rr)
{
	unsigned i;
	for(i=0; i<rr->rdata_count; i++) {
		if(rdata_atom_is_domain(rr->type, i)) {
			assert(rdata_atom_domain(rr->rdatas[i])->usage > 0);
			rdata_atom_domain(rr->rdatas[i])->usage --;
			if(rdata_atom_domain(rr->rdatas[i])->usage == 0)
				domain_table_deldomain(db,
					rdata_atom_domain(rr->rdatas[i]));
		}
	}
}

static void
rrset_lower_usage(namedb_type* db, rrset_type* rrset)
{
	unsigned i;
	for(i=0; i<rrset->rr_count; i++)
		rr_lower_usage(db, &rrset->rrs[i]);
}

int
d403 1
d405 1
a405 1
	region_type* temp_region, udb_ptr* udbz)
d439 1
a439 1
		rrnum = find_rr_num(rrset, type, klass, rdatas, rdata_num, 0);
a444 2
		/* delete the normalized RR from the udb */
		udb_del_rr(db->udb, udbz, &rrset->rrs[rrnum]);
d446 16
a461 6
		/* process triggers for RR deletions */
		nsec3_delete_rr_trigger(db, &rrset->rrs[rrnum], zone, udbz);
#endif
		/* lower usage (possibly deleting other domains, and thus
		 * invalidating the current RR's domain pointers) */
		rr_lower_usage(db, &rrset->rrs[rrnum]);
d464 5
a468 7
			rrset_delete(db, domain, rrset);
#ifdef NSEC3
			/* cleanup nsec3 */
			nsec3_delete_rrset_trigger(db, domain, zone, type);
#endif
			/* see if the domain can be deleted (and inspect parents) */
			domain_table_deldomain(db, domain);
a484 17
#ifdef NSEC3
			if(type == TYPE_NSEC3PARAM && zone->nsec3_param) {
				/* fixup nsec3_param pointer to same RR */
				assert(zone->nsec3_param >= rrs_orig &&
					zone->nsec3_param <=
					rrs_orig+rrset->rr_count);
				/* last moved to rrnum, others at same index*/
				if(zone->nsec3_param == &rrs_orig[
					rrset->rr_count-1])
					zone->nsec3_param = &rrset->rrs[rrnum];
				else
					zone->nsec3_param =
						(void*)zone->nsec3_param
						-(void*)rrs_orig +
						(void*)rrset->rrs;
			}
#endif /* NSEC3 */
a485 7
#ifdef NSEC3
			/* for type nsec3, the domain may have become a
			 * 'normal' domain with its remaining data now */
			if(type == TYPE_NSEC3)
				nsec3_rrsets_changed_add_prehash(db, domain,
					zone);
#endif /* NSEC3 */
d491 1
a491 1
int
d494 2
a495 1
	buffer_type* packet, size_t rdatalen, zone_type *zone, udb_ptr* udbz)
a502 1
	int rrset_added = 0;
a519 1
		rrset_added = 1;
d532 1
a532 1
	rrnum = find_rr_num(rrset, type, klass, rdatas, rdata_num, 1);
d539 8
d570 43
a612 10
		apex_rrset_checks(db, rrset, domain);
#ifdef NSEC3
		if(type == TYPE_NSEC3PARAM && zone->nsec3_param) {
			/* the pointer just changed, fix it up to point
			 * to the same record */
			assert(zone->nsec3_param >= rrs_old &&
				zone->nsec3_param < rrs_old+rrset->rr_count);
			/* in this order to make sure no overflow/underflow*/
			zone->nsec3_param = (void*)zone->nsec3_param - 
				(void*)rrs_old + (void*)rrset->rrs;
a613 1
#endif /* NSEC3 */
d616 7
a622 4
	/* write the just-normalized RR to the udb */
	if(!udb_write_rr(db->udb, udbz, &rrset->rrs[rrset->rr_count - 1])) {
		log_msg(LOG_ERR, "could not add RR to nsd.db, disk-space?");
		return 0;
d624 7
a630 10
#ifdef NSEC3
	if(rrset_added) {
		domain_type* p = domain->parent;
		nsec3_add_rrset_trigger(db, domain, zone, type);
		/* go up and process (possibly created) empty nonterminals, 
		 * until we hit the apex or root */
		while(p && p->rrsets == NULL && !p->is_apex) {
			nsec3_rrsets_changed_add_prehash(db, p, zone);
			p = p->parent;
		}
d632 3
a634 1
	nsec3_add_rr_trigger(db, &rrset->rrs[rrset->rr_count - 1], zone, udbz);
d636 1
d641 2
a642 2
find_or_create_zone(namedb_type* db, const dname_type* zone_name,
	nsd_options_t* opt, const char* zstr, const char* patname)
d644 1
d646 61
a706 29
	zone_options_t* zopt;
	zone = namedb_find_zone(db, zone_name);
	if(zone) {
		return zone;
	}
	zopt = zone_options_find(opt, zone_name);
	if(!zopt) {
		/* if _implicit_ then insert as _part_of_config */
		if(strncmp(patname, PATTERN_IMPLICIT_MARKER,
			strlen(PATTERN_IMPLICIT_MARKER)) == 0) {
			zopt = zone_options_create(opt->region);
			if(!zopt) return 0;
			zopt->part_of_config = 1;
			zopt->name = region_strdup(opt->region, zstr);
			zopt->pattern = pattern_options_find(opt, patname);
			if(!zopt->name || !zopt->pattern) return 0;
			if(!nsd_options_insert_zone(opt, zopt)) {
				log_msg(LOG_ERR, "bad domain name or duplicate zone '%s' "
					"pattern %s", zstr, patname);
			}
		} else {
			/* create zone : presumably already added to zonelist
			 * by xfrd, who wrote the AXFR or IXFR to disk, so we only
			 * need to add it to our config.
			 * This process does not need linesize and offset zonelist */
			zopt = zone_list_zone_insert(opt, zstr, patname, 0, 0);
			if(!zopt)
				return 0;
		}
d708 6
a713 1
	zone = namedb_zone_create(db, zone_name, zopt);
d717 1
a717 1
void
d721 9
a729 1
	domain_type *domain = zone->apex, *next;
d731 2
a732 1
	while(domain && domain_is_subdomain(domain, zone->apex))
d735 1
a735 1
			domain_to_string(domain)));
d738 1
a738 4
			/* lower usage can delete other domains */
			rrset_lower_usage(db, rrset);
			/* rrset del does not delete our domain(yet) */
			rrset_delete(db, domain, rrset);
a739 2
		/* the delete upcoming could delete parents, but nothing next
		 * or after the domain so store next ptr */
d741 1
a741 2
		/* see if the domain can be deleted (and inspect parents) */
		domain_table_deldomain(db, domain);
d744 10
d763 1
a763 1
	/* keep zone->soa_nx_rrset alloced: it is reused */
d766 14
d784 3
a786 2
apply_ixfr(namedb_type* db, FILE *in, const char* zone, uint32_t serialno,
	nsd_options_t* opt, uint32_t seq_nr, uint32_t seq_total,
d788 1
a788 1
	udb_ptr* udbz, struct zone** zone_res, const char* patname, int* bytes)
d790 1
a790 1
	uint32_t msglen, checklen, pkttype;
d798 12
d811 1
a811 7
	/* note that errors could not really happen due to format of the
	 * packet since xfrd has checked all dnames and RRs before commit,
	 * this is why the errors are fatal (exit process), it must be
	 * something internal or a bad disk or something. */

	/* read ixfr packet RRs and apply to in memory db */
	if(!diff_read_32(in, &pkttype) || pkttype != DIFF_PART_XXFR) {
d815 5
d821 1
a821 1
	if(!diff_read_32(in, &msglen)) {
d826 2
a827 1
	if(msglen < QHEADERSZ) {
d837 19
d857 9
a878 17
	/* see if check on data fails: checks that we are not reading
	 * random garbage */
	if(!diff_read_32(in, &checklen) || checklen != msglen) {
		log_msg(LOG_ERR, "transfer part has incorrect checkvalue");
		return 0;
	}
	*bytes += msglen;

	dname_zone = dname_parse(region, zone);
	zone_db = find_or_create_zone(db, dname_zone, opt, zone, patname);
	if(!zone_db) {
		log_msg(LOG_ERR, "could not create zone %s %s", zone, patname);
		region_destroy(region);
		return 0;
	}
	*zone_res = zone_db;

d934 2
a935 2
			log_msg(LOG_ERR, "SOA serial %u different from commit %u",
				(unsigned)buffer_read_u32(packet), (unsigned)serialno);
d944 1
d950 1
a980 3
#ifdef NSEC3
			nsec3_hash_tree_clear(zone_db);
#endif
a981 5
			udb_zone_clear(db->udb, udbz);
#ifdef NSEC3
			nsec3_clear_precompile(db, zone_db);
			zone_db->nsec3_param = NULL;
#endif /* NSEC3 */
a1002 3
#ifdef NSEC3
				nsec3_hash_tree_clear(zone_db);
#endif
a1003 5
				udb_zone_clear(db->udb, udbz);
#ifdef NSEC3
				nsec3_clear_precompile(db, zone_db);
				zone_db->nsec3_param = NULL;
#endif /* NSEC3 */
d1043 2
a1044 2
			if(!delete_RR(db, dname, type, klass, packet,
				rrlen, zone_db, region, udbz)) {
d1048 3
d1056 1
a1056 1
				rrlen, zone_db, udbz)) {
d1062 1
d1092 127
d1220 3
a1222 3
apply_ixfr_for_zone(nsd_type* nsd, zone_type* zonedb, FILE* in,
	nsd_options_t* opt, udb_base* taskudb, udb_ptr* last_task,
	uint32_t xfrfilenr)
d1226 2
a1227 5
	char patname_buf[2048];

	uint32_t old_serial, new_serial, num_parts, type;
	uint64_t time_end_0, time_start_0;
	uint32_t time_end_1, time_start_1;
d1229 1
d1231 3
a1233 1
	int num_bytes = 0;
d1236 6
a1241 2
	if(!diff_read_32(in, &type)) {
		log_msg(LOG_ERR, "diff file too short");
d1244 3
a1246 2
	if(type != DIFF_PART_XFRF) {
		log_msg(LOG_ERR, "xfr file has wrong format");
a1247 1

a1248 4
	/* committed and num_parts are first because they need to be
	 * updated once the rest is written.  The log buf is not certain
	 * until its done, so at end of file.  The patname is in case a
	 * new zone is created, we know what the options-pattern is */
d1250 2
a1251 9
		!diff_read_32(in, &num_parts) ||
		!diff_read_64(in, &time_end_0) ||
		!diff_read_32(in, &time_end_1) ||
		!diff_read_32(in, &old_serial) ||
		!diff_read_32(in, &new_serial) ||
		!diff_read_64(in, &time_start_0) ||
		!diff_read_32(in, &time_start_1) ||
		!diff_read_str(in, zone_buf, sizeof(zone_buf)) ||
		!diff_read_str(in, patname_buf, sizeof(patname_buf))) {
d1256 13
d1270 6
a1275 4
	if(strcmp(zone_buf, dname_to_string(zonedb->apex->dname,0)) != 0) {
		log_msg(LOG_ERR, "file %s does not match task %s",
			zone_buf, dname_to_string(zonedb->apex->dname,0));
		return 0;
d1277 8
a1284 3
	if(!committed) {
		log_msg(LOG_ERR, "diff file %s was not committed", zone_buf);
		return 0;
d1286 5
a1290 3
	if(num_parts == 0) {
		log_msg(LOG_ERR, "diff file %s was not completed", zone_buf);
		return 0;
d1292 1
a1292 1
	if(check_for_bad_serial(nsd->db, zone_buf, old_serial)) {
d1294 3
a1296 2
			"skipping diff file commit with bad serial"));
		return 1;
d1299 1
a1299 1
	if(committed)
d1302 1
a1302 2
		const dname_type* apex = zonedb->apex->dname;
		udb_ptr z;
d1304 29
a1332 5
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "processing xfr: %s", zone_buf));
		if(udb_base_get_userflags(nsd->db->udb) != 0) {
			log_msg(LOG_ERR, "database corrupted, cannot update");
			xfrd_unlink_xfrfile(nsd, xfrfilenr);
			exit(1);
d1334 9
a1342 11
		/* all parts were checked by xfrd before commit */
		if(!udb_zone_search(nsd->db->udb, &z, dname_name(apex),
			apex->name_size)) {
			/* create it */
			if(!udb_zone_create(nsd->db->udb, &z, dname_name(apex),
				apex->name_size)) {
				/* out of disk space perhaps */
				log_msg(LOG_ERR, "could not udb_create_zone "
					"%s, disk space full?", log_buf);
				return 0;
			}
a1343 3
		/* set the udb dirty until we are finished applying changes */
		udb_base_set_userflags(nsd->db->udb, 1);
		/* read and apply all of the parts */
d1345 1
d1348 3
a1350 3
			ret = apply_ixfr(nsd->db, in, zone_buf, new_serial, opt,
				i, num_parts, &is_axfr, &delete_mode,
				&rr_count, &z, &zonedb, patname_buf, &num_bytes);
d1352 3
a1354 4
				log_msg(LOG_ERR, "bad ixfr packet part %d in diff file for %s", (int)i, zone_buf);
				xfrd_unlink_xfrfile(nsd, xfrfilenr);
				/* the udb is still dirty, it is bad */
				exit(1);
a1358 7
		udb_base_set_userflags(nsd->db->udb, 0);
		/* read the final log_str: but do not fail on it */
		if(!diff_read_str(in, log_buf, sizeof(log_buf))) {
			log_msg(LOG_ERR, "could not read log for transfer %s",
				zone_buf);
			snprintf(log_buf, sizeof(log_buf), "error reading log");
		}
d1360 6
a1365 1
		if(zonedb) prehash_zone(nsd->db, zonedb);
d1367 4
a1370 13
		zonedb->is_changed = 1;
		ZONE(&z)->is_changed = 1;
		ZONE(&z)->mtime = time_end_0;
		udb_zone_set_log_str(nsd->db->udb, &z, log_buf);
		udb_ptr_unlink(&z, nsd->db->udb);
		if(taskudb) task_new_soainfo(taskudb, last_task, zonedb);

		if(1 <= verbosity) {
			double elapsed = (double)(time_end_0 - time_start_0)+
				(double)((double)time_end_1
				-(double)time_start_1) / 1000000.0;
			VERBOSITY(2, (LOG_INFO, "zone %s %s of %d bytes in %g seconds",
				zone_buf, log_buf, num_bytes, elapsed));
d1376 4
a1382 5
struct udb_base* task_file_create(const char* file)
{
        return udb_base_create_new(file, &namedb_walkfunc, NULL);
}

d1384 1
a1384 2
task_create_new_elem(struct udb_base* udb, udb_ptr* last, udb_ptr* e,
	size_t sz, const dname_type* zname)
d1386 23
a1408 2
	if(!udb_ptr_alloc_space(e, udb, udb_chunk_type_task, sz)) {
		return 0;
d1410 2
a1411 16
	if(udb_ptr_is_null(last)) {
		udb_base_set_userdata(udb, e->data);
	} else {
		udb_rptr_set_ptr(&TASKLIST(last)->next, udb, e);
	}
	udb_ptr_set_ptr(last, udb, e);

	/* fill in tasklist item */
	udb_rel_ptr_init(&TASKLIST(e)->next);
	TASKLIST(e)->size = sz;
	TASKLIST(e)->oldserial = 0;
	TASKLIST(e)->newserial = 0;
	TASKLIST(e)->yesno = 0;

	if(zname) {
		memmove(TASKLIST(e)->zname, zname, dname_total_size(zname));
d1413 3
d1419 4
a1422 1
void task_new_soainfo(struct udb_base* udb, udb_ptr* last, struct zone* z)
d1424 1
a1424 22
	/* calculate size */
	udb_ptr e;
	size_t sz;
	const dname_type* apex, *ns, *em;
	if(!z || !z->apex || !domain_dname(z->apex))
		return; /* safety check */

	DEBUG(DEBUG_IPC,1, (LOG_INFO, "nsd: add soa info for zone %s",
		domain_to_string(z->apex)));
	apex = domain_dname(z->apex);
	sz = sizeof(struct task_list_d) + dname_total_size(apex);
	if(z->soa_rrset) {
		ns = domain_dname(rdata_atom_domain(
			z->soa_rrset->rrs[0].rdatas[0]));
		em = domain_dname(rdata_atom_domain(
			z->soa_rrset->rrs[0].rdatas[1]));
		sz += sizeof(uint32_t)*6 + sizeof(uint8_t)*2
			+ ns->name_size + em->name_size;
	} else {
		ns = 0;
		em = 0;
	}
d1426 8
a1433 4
	/* create new task_list item */
	if(!task_create_new_elem(udb, last, &e, sz, apex)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add SOAINFO");
		return;
d1435 7
a1441 30
	TASKLIST(&e)->task_type = task_soa_info;

	if(z->soa_rrset) {
		uint32_t ttl = htonl(z->soa_rrset->rrs[0].ttl);
		uint8_t* p = (uint8_t*)TASKLIST(&e)->zname;
		p += dname_total_size(apex);
		memmove(p, &ttl, sizeof(uint32_t));
		p += sizeof(uint32_t);
		memmove(p, &ns->name_size, sizeof(uint8_t));
		p += sizeof(uint8_t);
		memmove(p, dname_name(ns), ns->name_size);
		p += ns->name_size;
		memmove(p, &em->name_size, sizeof(uint8_t));
		p += sizeof(uint8_t);
		memmove(p, dname_name(em), em->name_size);
		p += em->name_size;
		memmove(p, rdata_atom_data(z->soa_rrset->rrs[0].rdatas[2]),
			sizeof(uint32_t));
		p += sizeof(uint32_t);
		memmove(p, rdata_atom_data(z->soa_rrset->rrs[0].rdatas[3]),
			sizeof(uint32_t));
		p += sizeof(uint32_t);
		memmove(p, rdata_atom_data(z->soa_rrset->rrs[0].rdatas[4]),
			sizeof(uint32_t));
		p += sizeof(uint32_t);
		memmove(p, rdata_atom_data(z->soa_rrset->rrs[0].rdatas[5]),
			sizeof(uint32_t));
		p += sizeof(uint32_t);
		memmove(p, rdata_atom_data(z->soa_rrset->rrs[0].rdatas[6]),
			sizeof(uint32_t));
d1443 7
a1449 1
	udb_ptr_unlink(&e, udb);
d1452 6
a1457 1
void task_process_sync(struct udb_base* taskudb)
d1459 4
a1462 5
	/* need to sync before other process uses the mmap? */
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "task procsync %s size %d",
		taskudb->fname, (int)taskudb->base_size));
	(void)taskudb;
}
d1464 9
a1472 6
void task_remap(struct udb_base* taskudb)
{
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "task remap %s size %d",
		taskudb->fname, (int)taskudb->glob_data->fsize));
	udb_base_remap_process(taskudb);
}
d1474 2
a1475 15
void task_clear(struct udb_base* taskudb)
{
	udb_ptr t, n;
	udb_ptr_new(&t, taskudb, udb_base_get_userdata(taskudb));
	udb_base_set_userdata(taskudb, 0);
	udb_ptr_init(&n, taskudb);
	while(!udb_ptr_is_null(&t)) {
		udb_ptr_set_rptr(&n, taskudb, &TASKLIST(&t)->next);
		udb_rptr_zero(&TASKLIST(&t)->next, taskudb);
		udb_ptr_free_space(&t, taskudb, TASKLIST(&t)->size);
		udb_ptr_set_ptr(&t, taskudb, &n);
	}
	udb_ptr_unlink(&t, taskudb);
	udb_ptr_unlink(&n, taskudb);
}
d1477 7
a1483 11
void task_new_expire(struct udb_base* udb, udb_ptr* last,
	const struct dname* z, int expired)
{
	udb_ptr e;
	if(!z) return;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add expire info for zone %s",
		dname_to_string(z,NULL)));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)+
		dname_total_size(z), z)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add expire");
		return;
a1484 4
	TASKLIST(&e)->task_type = task_expire;
	TASKLIST(&e)->yesno = expired;
	udb_ptr_unlink(&e, udb);
}
d1486 1
a1486 13
void task_new_check_zonefiles(udb_base* udb, udb_ptr* last,
	const dname_type* zone)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task checkzonefiles"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d) +
		(zone?dname_total_size(zone):0), zone)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add check_zones");
		return;
	}
	TASKLIST(&e)->task_type = task_check_zonefiles;
	TASKLIST(&e)->yesno = (zone!=NULL);
	udb_ptr_unlink(&e, udb);
d1489 2
a1490 31
void task_new_write_zonefiles(udb_base* udb, udb_ptr* last,
	const dname_type* zone)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task writezonefiles"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d) +
		(zone?dname_total_size(zone):0), zone)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add writezones");
		return;
	}
	TASKLIST(&e)->task_type = task_write_zonefiles;
	TASKLIST(&e)->yesno = (zone!=NULL);
	udb_ptr_unlink(&e, udb);
}

void task_new_set_verbosity(udb_base* udb, udb_ptr* last, int v)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task set_verbosity"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d),
		NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add set_v");
		return;
	}
	TASKLIST(&e)->task_type = task_set_verbosity;
	TASKLIST(&e)->yesno = v;
	udb_ptr_unlink(&e, udb);
}

#ifdef BIND8_STATS
void* task_new_stat_info(udb_base* udb, udb_ptr* last, struct nsdst* stat,
d1493 12
a1504 7
	void* p;
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task stat_info"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)+
		sizeof(*stat) + sizeof(stc_t)*child_count, NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add stati");
		return NULL;
a1505 7
	TASKLIST(&e)->task_type = task_stat_info;
	p = TASKLIST(&e)->zname;
	memcpy(p, stat, sizeof(*stat));
	udb_ptr_unlink(&e, udb);
	return p + sizeof(*stat);
}
#endif /* BIND8_STATS */
d1507 17
a1523 13
void
task_new_add_zone(udb_base* udb, udb_ptr* last, const char* zone,
	const char* pattern)
{
	size_t zlen = strlen(zone);
	size_t plen = strlen(pattern);
	void *p;
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task addzone %s %s", zone, pattern));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)+
		zlen + 1 + plen + 1, NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add addz");
		return;
d1525 15
a1539 16
	TASKLIST(&e)->task_type = task_add_zone;
	p = TASKLIST(&e)->zname;
	memcpy(p, zone, zlen+1);
	memmove(p+zlen+1, pattern, plen+1);
	udb_ptr_unlink(&e, udb);
}

void
task_new_del_zone(udb_base* udb, udb_ptr* last, const dname_type* dname)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task delzone %s", dname_to_string(dname, 0)));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+dname_total_size(dname), dname)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add delz");
		return;
a1540 3
	TASKLIST(&e)->task_type = task_del_zone;
	udb_ptr_unlink(&e, udb);
}
d1542 7
a1548 11
void task_new_add_key(udb_base* udb, udb_ptr* last, key_options_t* key)
{
	char* p;
	udb_ptr e;
	assert(key->name && key->algorithm && key->secret);
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task addkey"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+strlen(key->name)+1+strlen(key->algorithm)+1+
		strlen(key->secret)+1, NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add addk");
		return;
d1550 7
a1556 74
	TASKLIST(&e)->task_type = task_add_key;
	p = (char*)TASKLIST(&e)->zname;
	memmove(p, key->name, strlen(key->name)+1);
	p+=strlen(key->name)+1;
	memmove(p, key->algorithm, strlen(key->algorithm)+1);
	p+=strlen(key->algorithm)+1;
	memmove(p, key->secret, strlen(key->secret)+1);
	udb_ptr_unlink(&e, udb);
}

void task_new_del_key(udb_base* udb, udb_ptr* last, const char* name)
{
	char* p;
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task delkey"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+strlen(name)+1, NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add delk");
		return;
	}
	TASKLIST(&e)->task_type = task_del_key;
	p = (char*)TASKLIST(&e)->zname;
	memmove(p, name, strlen(name)+1);
	udb_ptr_unlink(&e, udb);
}

void task_new_add_pattern(udb_base* udb, udb_ptr* last, pattern_options_t* p)
{
	region_type* temp;
	buffer_type* buffer;
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task addpattern %s", p->pname));
	temp = region_create(xalloc, free);
	buffer = buffer_create(temp, 4096);
	pattern_options_marshal(buffer, p);
	buffer_flip(buffer);
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+ buffer_limit(buffer), NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add addp");
		region_destroy(temp);
		return;
	}
	TASKLIST(&e)->task_type = task_add_pattern;
	TASKLIST(&e)->yesno = buffer_limit(buffer);
	memmove(TASKLIST(&e)->zname, buffer_begin(buffer),
		buffer_limit(buffer));
	udb_ptr_unlink(&e, udb);
	region_destroy(temp);
}

void task_new_del_pattern(udb_base* udb, udb_ptr* last, const char* name)
{
	char* p;
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task delpattern %s", name));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+strlen(name)+1, NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add delp");
		return;
	}
	TASKLIST(&e)->task_type = task_del_pattern;
	p = (char*)TASKLIST(&e)->zname;
	memmove(p, name, strlen(name)+1);
	udb_ptr_unlink(&e, udb);
}

void task_new_opt_change(udb_base* udb, udb_ptr* last, nsd_options_t* opt)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task opt_change"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d),
		NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add o_c");
		return;
a1557 10
	TASKLIST(&e)->task_type = task_opt_change;
#ifdef RATELIMIT
	TASKLIST(&e)->oldserial = opt->rrl_ratelimit;
	TASKLIST(&e)->newserial = opt->rrl_whitelist_ratelimit;
	TASKLIST(&e)->yesno = (uint64_t) opt->rrl_slip;
#else
	(void)opt;
#endif
	udb_ptr_unlink(&e, udb);
}
d1559 5
a1563 9
int
task_new_apply_xfr(udb_base* udb, udb_ptr* last, const dname_type* dname,
	uint32_t old_serial, uint32_t new_serial, uint64_t filenumber)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task apply_xfr"));
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d)
		+dname_total_size(dname), dname)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add applyxfr");
a1565 7
	TASKLIST(&e)->oldserial = old_serial;
	TASKLIST(&e)->newserial = new_serial;
	TASKLIST(&e)->yesno = filenumber;
	TASKLIST(&e)->task_type = task_apply_xfr;
	udb_ptr_unlink(&e, udb);
	return 1;
}
d1567 5
a1571 24
void
task_process_expire(namedb_type* db, struct task_list_d* task)
{
	uint8_t ok;
	zone_type* z = namedb_find_zone(db, task->zname);
	assert(task->task_type == task_expire);
	if(!z) {
		DEBUG(DEBUG_IPC, 1, (LOG_WARNING, "zone %s %s but not in zonetree",
			dname_to_string(task->zname, NULL),
			task->yesno?"expired":"unexpired"));
		return;
	}
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: expire task zone %s %s",
		dname_to_string(task->zname,0),
		task->yesno?"expired":"unexpired"));
	/* find zone, set expire flag */
	ok = !task->yesno;
	/* only update zone->is_ok if needed to minimize copy-on-write
	 * of memory pages shared after fork() */
	if(ok && !z->is_ok)
		z->is_ok = 1;
	else if(!ok && z->is_ok)
		z->is_ok = 0;
}
d1573 9
a1581 6
static void
task_process_set_verbosity(struct task_list_d* task)
{
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "verbosity task %d", (int)task->yesno));
	verbosity = task->yesno;
}
d1583 15
a1597 14
static void
task_process_checkzones(struct nsd* nsd, udb_base* udb, udb_ptr* last_task,
	struct task_list_d* task)
{
	/* on SIGHUP check if zone-text-files changed and if so,
	 * reread.  When from xfrd-reload, no need to fstat the files */
	if(task->yesno) {
		zone_options_t* zo = zone_options_find(nsd->options,
			task->zname);
		if(zo)
			namedb_check_zonefile(nsd->db, udb, last_task, zo);
	} else {
		/* check all zones */
		namedb_check_zonefiles(nsd->db, nsd->options, udb, last_task);
d1599 1
a1599 1
}
d1601 4
a1604 8
static void
task_process_writezones(struct nsd* nsd, struct task_list_d* task)
{
	if(task->yesno) {
		zone_options_t* zo = zone_options_find(nsd->options,
			task->zname);
		if(zo)
			namedb_write_zonefile(nsd->db, zo);
d1606 9
a1614 1
		namedb_write_zonefiles(nsd->db, nsd->options);
a1615 1
}
d1617 3
a1619 26
static void
task_process_add_zone(struct nsd* nsd, udb_base* udb, udb_ptr* last_task,
	struct task_list_d* task)
{
	zone_type* z;
	const dname_type* zdname;
	const char* zname = (const char*)task->zname;
	const char* pname = zname + strlen(zname)+1;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "addzone task %s %s", zname, pname));
	zdname = dname_parse(nsd->db->region, zname);
	if(!zdname) {
		log_msg(LOG_ERR, "can not parse zone name %s", zname);
		return;
	}
	/* create zone */
	z = find_or_create_zone(nsd->db, zdname, nsd->options, zname, pname);
	if(!z) {
		region_recycle(nsd->db->region, (void*)zdname,
			dname_total_size(zdname));
		log_msg(LOG_ERR, "can not add zone %s %s", zname, pname);
		return;
	}
	/* if zone is empty, attempt to read the zonefile from disk (if any) */
	if(!z->soa_rrset && z->opts->pattern->zonefile) {
		namedb_read_zonefile(nsd->db, z, udb, last_task);
	}
d1622 1
a1622 2
static void
task_process_del_zone(struct nsd* nsd, struct task_list_d* task)
d1624 2
a1625 8
	udb_ptr udbz;
	zone_type* zone;
	zone_options_t* zopt;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "delzone task %s", dname_to_string(
		task->zname, NULL)));
	zone = namedb_find_zone(nsd->db, task->zname);
	if(!zone)
		return;
d1627 22
a1648 8
#ifdef NSEC3
	nsec3_hash_tree_clear(zone);
#endif
	delete_zone_rrs(nsd->db, zone);
	if(udb_zone_search(nsd->db->udb, &udbz, dname_name(task->zname),
		task->zname->name_size)) {
		udb_zone_delete(nsd->db->udb, &udbz);
		udb_ptr_unlink(&udbz, nsd->db->udb);
d1650 1
a1650 22
#ifdef NSEC3
	nsec3_clear_precompile(nsd->db, zone);
	zone->nsec3_param = NULL;
#endif /* NSEC3 */

	/* remove from zonetree, apex, soa */
	zopt = zone->opts;
	namedb_zone_delete(nsd->db, zone);
	/* remove from options (zone_list already edited by xfrd) */
	zone_options_delete(nsd->options, zopt);
}

static void
task_process_add_key(struct nsd* nsd, struct task_list_d* task)
{
	key_options_t key;
	key.name = (char*)task->zname;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "addkey task %s", key.name));
	key.algorithm = key.name + strlen(key.name)+1;
	key.secret = key.algorithm + strlen(key.algorithm)+1;
	key_options_add_modify(nsd->options, &key);
	memset(key.secret, 0xdd, strlen(key.secret)); /* wipe secret */
d1653 1
a1653 2
static void
task_process_del_key(struct nsd* nsd, struct task_list_d* task)
d1655 3
a1657 5
	char* name = (char*)task->zname;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "delkey task %s", name));
	/* this is reload and nothing is using the TSIG key right now */
	key_options_remove(nsd->options, name);
}
d1659 5
a1663 50
static void
task_process_add_pattern(struct nsd* nsd, struct task_list_d* task)
{
	region_type* temp = region_create(xalloc, free);
	buffer_type buffer;
	pattern_options_t *pat;
	buffer_create_from(&buffer, task->zname, task->yesno);
	pat = pattern_options_unmarshal(temp, &buffer);
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "addpattern task %s", pat->pname));
	pattern_options_add_modify(nsd->options, pat);
	region_destroy(temp);
}

static void
task_process_del_pattern(struct nsd* nsd, struct task_list_d* task)
{
	char* name = (char*)task->zname;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "delpattern task %s", name));
	pattern_options_remove(nsd->options, name);
}

static void
task_process_opt_change(struct nsd* nsd, struct task_list_d* task)
{
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "optchange task"));
#ifdef RATELIMIT
	nsd->options->rrl_ratelimit = task->oldserial;
	nsd->options->rrl_whitelist_ratelimit = task->newserial;
	nsd->options->rrl_slip = task->yesno;
	rrl_set_limit(nsd->options->rrl_ratelimit, nsd->options->rrl_whitelist_ratelimit,
		nsd->options->rrl_slip);
#else
	(void)nsd; (void)task;
#endif
}

static void
task_process_apply_xfr(struct nsd* nsd, udb_base* udb, udb_ptr *last_task,
	udb_ptr* task)
{
	/* we have to use an udb_ptr task here, because the apply_xfr procedure
	 * appends soa_info which may remap and change the pointer. */
	zone_type* zone;
	FILE* df;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "applyxfr task %s", dname_to_string(
		TASKLIST(task)->zname, NULL)));
	zone = namedb_find_zone(nsd->db, TASKLIST(task)->zname);
	if(!zone) {
		/* assume the zone has been deleted and a zone transfer was
		 * still waiting to be processed */
d1666 9
a1674 8
	/* apply the XFR */
	/* oldserial, newserial, yesno is filenumber */
	df = xfrd_open_xfrfile(nsd, TASKLIST(task)->yesno, "r");
	if(!df) {
		/* could not open file to update */
		/* there is no reply to xfrd failed-update,
		 * because xfrd has a scan for apply-failures. */
		return;
d1676 10
a1685 5
	/* read and apply zone transfer */
	if(!apply_ixfr_for_zone(nsd, zone, df, nsd->options, udb,
		last_task, TASKLIST(task)->yesno)) {
		/* there is no reply to xfrd failed-update,
		 * because xfrd has a scan for apply-failures. */
a1688 50
	xfrd_unlink_xfrfile(nsd, TASKLIST(task)->yesno);
}


void task_process_in_reload(struct nsd* nsd, udb_base* udb, udb_ptr *last_task,
        udb_ptr* task)
{
	switch(TASKLIST(task)->task_type) {
	case task_expire:
		task_process_expire(nsd->db, TASKLIST(task));
		break;
	case task_check_zonefiles:
		task_process_checkzones(nsd, udb, last_task, TASKLIST(task));
		break;
	case task_write_zonefiles:
		task_process_writezones(nsd, TASKLIST(task));
		break;
	case task_set_verbosity:
		task_process_set_verbosity(TASKLIST(task));
		break;
	case task_add_zone:
		task_process_add_zone(nsd, udb, last_task, TASKLIST(task));
		break;
	case task_del_zone:
		task_process_del_zone(nsd, TASKLIST(task));
		break;
	case task_add_key:
		task_process_add_key(nsd, TASKLIST(task));
		break;
	case task_del_key:
		task_process_del_key(nsd, TASKLIST(task));
		break;
	case task_add_pattern:
		task_process_add_pattern(nsd, TASKLIST(task));
		break;
	case task_del_pattern:
		task_process_del_pattern(nsd, TASKLIST(task));
		break;
	case task_opt_change:
		task_process_opt_change(nsd, TASKLIST(task));
		break;
	case task_apply_xfr:
		task_process_apply_xfr(nsd, udb, last_task, task);
		break;
	default:
		log_msg(LOG_WARNING, "unhandled task in reload type %d",
			(int)TASKLIST(task)->task_type);
		break;
	}
	udb_ptr_free_space(task, udb, TASKLIST(task)->size);
@


1.1.1.13
log
@update to NSD 4.0.1, ok sthen@@
@
text
@a474 1
		(!domain->parent || nsec3_domain_part_of_zone(domain->parent, zone)) &&
d609 1
a609 1
	region_type* temp_region, udb_ptr* udbz, int* softfail)
a617 1
		*softfail = 1;
a624 1
		*softfail = 1;
a643 3
		if(rrnum == -1 && type == TYPE_SOA && domain == zone->apex
			&& rrset->rr_count != 0)
			rrnum = 0; /* replace existing SOA if no match */
a646 1
			*softfail = 1;
d716 1
a716 2
	buffer_type* packet, size_t rdatalen, zone_type *zone, udb_ptr* udbz,
	int* softfail)
a759 1
		*softfail = 1;
d902 1
a902 2
	udb_ptr* udbz, struct zone** zone_res, const char* patname, int* bytes,
	int* softfail)
d1117 1
a1117 1
				log_msg(LOG_ERR, "%s SOA serial %u is not "
d1149 1
a1149 1
				rrlen, zone_db, region, udbz, softfail)) {
d1158 1
a1158 1
				rrlen, zone_db, udbz, softfail)) {
d1259 1
a1259 1
		int is_axfr=0, delete_mode=0, rr_count=0, softfail=0;
d1289 1
a1289 2
				&rr_count, &z, &zonedb, patname_buf, &num_bytes,
				&softfail);
d1314 1
a1314 11
		if(softfail && taskudb && !is_axfr) {
			log_msg(LOG_ERR, "Failed to apply IXFR cleanly "
				"(deletes nonexistent RRs, adds existing RRs). "
				"Zone %s contents is different from master, "
				"starting AXFR. Transfer %s", zone_buf, log_buf);
			/* add/del failures in IXFR, get an AXFR */
			task_new_soainfo(taskudb, last_task, zonedb, 1);
		} else {
			if(taskudb)
				task_new_soainfo(taskudb, last_task, zonedb, 0);
		}
d1362 1
a1362 2
void task_new_soainfo(struct udb_base* udb, udb_ptr* last, struct zone* z,
	int gone)
d1375 1
a1375 1
	if(z->soa_rrset && !gone) {
d1394 1
a1394 1
	if(z->soa_rrset && !gone) {
d1732 1
a1732 1
			namedb_check_zonefile(nsd, udb, last_task, zo);
d1735 1
a1735 1
		namedb_check_zonefiles(nsd, nsd->options, udb, last_task);
d1746 1
a1746 1
			namedb_write_zonefile(nsd, zo);
d1748 1
a1748 1
		namedb_write_zonefiles(nsd, nsd->options);
d1776 1
a1776 1
		namedb_read_zonefile(nsd, z, udb, last_task);
@


1.1.1.14
log
@update to NSD 4.0.2, ok sthen@@
@
text
@d303 2
a304 8
	int k, start, end;
	start = 0;
	end = num;
	if (type == TYPE_SOA) {
		start = 2;
		end = 2;
	}
	for(k = start; k < end; k++)
d1188 1
a1188 1
		zone = domain_find_zone(db, domain);
a1323 1
		udb_zone_set_file_str(nsd->db->udb, &z, NULL);
@


1.1.1.15
log
@update to NSD 4.1.0, ok sthen@@
@
text
@a237 22
/** check if domain with 0 rrsets has become empty (nonexist) */
static void
rrset_zero_nonexist_check(domain_type* domain)
{
	/* is the node now an empty node (completely deleted) */
	if(domain->rrsets == 0) {
		/* if there is no data below it, it becomes non existing.
		   also empty nonterminals above it become nonexisting */
		/* check for data below this node. */
		if(!has_data_below(domain)) {
			/* nonexist this domain and all parent empty nonterminals */
			domain_type* p = domain;
			while(p != NULL && p->rrsets == 0) {
				if(has_data_below(p))
					break;
				p->is_existing = 0;
				p = p->parent;
			}
		}
	}
}

d280 17
a305 4
	/**
	 * SOA RDATA comparisons in XFR are more lenient,
	 * only serial rdata is checked.
	 **/
d308 1
a308 1
		end = 3;
d450 2
a451 2
		/* pick up new nsec3param (from udb, or avoid deleted rr) */
		nsec3_find_zone_param(db, zone, udbz, rr);
d553 1
a553 1
		nsec3_find_zone_param(db, zone, udbz, NULL);
d663 1
a663 2
		if(db->udb)
			udb_del_rr(db->udb, udbz, &rrset->rrs[rrnum]);
a673 2
			/* check if domain is now nonexisting (or parents) */
			rrset_zero_nonexist_check(domain);
d815 3
a817 5
	if(db->udb) {
		if(!udb_write_rr(db->udb, udbz, &rrset->rrs[rrset->rr_count - 1])) {
			log_msg(LOG_ERR, "could not add RR to nsd.db, disk-space?");
			return 0;
		}
a878 1
	int nonexist_check = 0;
a889 3
			/* no rrset_zero_nonexist_check, do that later */
			if(domain->rrsets == 0)
				nonexist_check = 1;
a898 17
	/* check if data deleteions have created nonexisting domain entries,
	 * but after deleting domains so the checks are faster */
	if(nonexist_check) {
		DEBUG(DEBUG_XFRD, 1, (LOG_INFO, "axfrdel: zero rrset check"));
		domain = zone->apex;
		while(domain && domain_is_subdomain(domain, zone->apex))
		{
			/* the interesting domains should be existing==1
			 * and rrsets==0, speeding up out processing of
			 * sub-zones, since we only spuriously check empty
			 * nonterminals */
			if(domain->is_existing)
				rrset_zero_nonexist_check(domain);
			domain = domain_next(domain);
		}
	}

d902 1
a902 1
	if(nsd_debug_level >= 2)
d1090 1
a1090 2
			if(db->udb)
				udb_zone_clear(db->udb, udbz);
d1120 1
a1120 2
				if(db->udb)
					udb_zone_clear(db->udb, udbz);
d1280 10
a1289 8
		if(nsd->db->udb) {
			if(udb_base_get_userflags(nsd->db->udb) != 0) {
				log_msg(LOG_ERR, "database corrupted, cannot update");
				xfrd_unlink_xfrfile(nsd, xfrfilenr);
				exit(1);
			}
			/* all parts were checked by xfrd before commit */
			if(!udb_zone_search(nsd->db->udb, &z, dname_name(apex),
d1291 4
a1294 8
				/* create it */
				if(!udb_zone_create(nsd->db->udb, &z, dname_name(apex),
					apex->name_size)) {
					/* out of disk space perhaps */
					log_msg(LOG_ERR, "could not udb_create_zone "
						"%s, disk space full?", log_buf);
					return 0;
				}
a1295 2
			/* set the udb dirty until we are finished applying changes */
			udb_base_set_userflags(nsd->db->udb, 1);
d1297 2
d1305 2
a1306 2
				&rr_count, (nsd->db->udb?&z:NULL), &zonedb,
				patname_buf, &num_bytes, &softfail);
d1316 1
a1316 2
		if(nsd->db->udb)
			udb_base_set_userflags(nsd->db->udb, 0);
d1327 5
a1331 17
		if(nsd->db->udb) {
			ZONE(&z)->is_changed = 1;
			ZONE(&z)->mtime = time_end_0;
			udb_zone_set_log_str(nsd->db->udb, &z, log_buf);
			udb_zone_set_file_str(nsd->db->udb, &z, NULL);
			udb_ptr_unlink(&z, nsd->db->udb);
		} else {
			zonedb->mtime = time_end_0;
			if(zonedb->logstr)
				region_recycle(nsd->db->region, zonedb->logstr,
					strlen(zonedb->logstr)+1);
			zonedb->logstr = region_strdup(nsd->db->region, log_buf);
			if(zonedb->filename)
				region_recycle(nsd->db->region, zonedb->filename,
					strlen(zonedb->filename)+1);
			zonedb->filename = NULL;
		}
d1812 1
d1825 4
a1828 7
	if(nsd->db->udb) {
		udb_ptr udbz;
		if(udb_zone_search(nsd->db->udb, &udbz, dname_name(task->zname),
			task->zname->name_size)) {
			udb_zone_delete(nsd->db->udb, &udbz);
			udb_ptr_unlink(&udbz, nsd->db->udb);
		}
a1912 1
		xfrd_unlink_xfrfile(nsd, TASKLIST(task)->yesno);
a1921 1
		xfrd_unlink_xfrfile(nsd, TASKLIST(task)->yesno);
@


1.1.1.16
log
@update to NSD 4.1.1, ok sthen@@
@
text
@d239 2
a240 2
static domain_type*
rrset_zero_nonexist_check(domain_type* domain, domain_type* ce)
d251 2
a252 2
				if(p == ce || has_data_below(p))
					return p;
a253 4
				/* fixup wildcard child of parent */
				if(p->parent &&
					p->parent->wildcard_child_closest_match == p)
					p->parent->wildcard_child_closest_match = domain_previous_existing_child(p);
a257 1
	return NULL;
d685 1
a685 1
			rrset_zero_nonexist_check(domain, NULL);
d917 1
a917 1
	/* check if data deletions have created nonexisting domain entries,
a919 1
		domain_type* ce = NULL; /* for speeding up has_data_below */
d929 1
a929 1
				ce = rrset_zero_nonexist_check(domain, ce);
d1621 1
a1621 1
	const char* pattern, unsigned zonestatid)
a1633 1
	TASKLIST(&e)->yesno = zonestatid;
a1751 16
void task_new_zonestat_inc(udb_base* udb, udb_ptr* last, unsigned sz)
{
	udb_ptr e;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "add task zonestat_inc"));
	if(sz == 0)
		return; /* no need to decrease to 0 */
	if(!task_create_new_elem(udb, last, &e, sizeof(struct task_list_d),
		NULL)) {
		log_msg(LOG_ERR, "tasklist: out of space, cannot add z_i");
		return;
	}
	TASKLIST(&e)->task_type = task_zonestat_inc;
	TASKLIST(&e)->oldserial = (uint32_t)sz;
	udb_ptr_unlink(&e, udb);
}

a1854 1
	z->zonestatid = (unsigned)task->yesno;
a1952 12
#ifdef USE_ZONE_STATS
static void
task_process_zonestat_inc(struct nsd* nsd, udb_base* udb, udb_ptr *last_task,
	struct task_list_d* task)
{
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "zonestat_inc task %u", (unsigned)task->oldserial));
	nsd->zonestatdesired = (unsigned)task->oldserial;
	/* send echo to xfrd to increment on its end */
	task_new_zonestat_inc(udb, last_task, nsd->zonestatdesired);
}
#endif

a2028 5
#ifdef USE_ZONE_STATS
	case task_zonestat_inc:
		task_process_zonestat_inc(nsd, udb, last_task, TASKLIST(task));
		break;
#endif
@


1.1.1.17
log
@update to NSD 4.1.3, ok florian@@, also tested by brad
@
text
@d705 2
a706 2
			rrset->rrs = region_alloc_array_init(db->region, rrs_orig,
				(rrset->rr_count-1), sizeof(rr_type));
a793 5
	if(rrset->rr_count == 65535) {
		log_msg(LOG_ERR, "diff: too many RRs at %s",
			dname_to_string(dname,0));
		return 0;
	}
d797 2
a798 2
	rrset->rrs = region_alloc_array(db->region,
		(rrset->rr_count+1), sizeof(rr_type));
d1406 1
a1406 1
			VERBOSITY(1, (LOG_INFO, "zone %s %s of %d bytes in %g seconds",
@


