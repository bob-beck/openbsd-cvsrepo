head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.8
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.10
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	NSD_4_1_6:1.1.1.10
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	NSD_4_1_3:1.1.1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	NSD_4_1_1:1.1.1.9
	NSD_4_1_0:1.1.1.8
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	NSD_4_0_3:1.1.1.7
	NSD_4_0_2:1.1.1.7
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	NSD_4_0_1:1.1.1.7
	NSD_4_0_0:1.1.1.7
	NSD_3_2_16:1.1.1.6
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	NSD_3_2_15:1.1.1.5
	NSD_3_2_14:1.1.1.5
	NSD_3_2_13:1.1.1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	NSD_3_2_11:1.1.1.5
	NSD_3_2_10:1.1.1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	NSD_3_2_9:1.1.1.4
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	NSD_3_2_8:1.1.1.3
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	NSD_3_2_6:1.1.1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	NSD_3_2_5:1.1.1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.07.17.17.36.33;	author sthen;	state Exp;
branches;
next	1.10;
commitid	2WtkENMkCz3GhSbE;

1.10
date	2015.02.03.10.40.02;	author brad;	state Exp;
branches;
next	1.9;
commitid	MI9j0d0LR8Dk9lnd;

1.9
date	2014.09.16.17.01.38;	author brad;	state Exp;
branches;
next	1.8;
commitid	5uD1zN2z8VskC3BN;

1.8
date	2013.11.26.12.53.58;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2013.09.03.09.26.50;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.23.20.30.26;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.09.21.56.41;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.29.11.23.24;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.21.18.29.56;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.17.20.44.59;	author chl;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.15.19.24.51;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.51;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.04.15.20.56.56;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.05.21.18.17.16;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.01.29.11.15.35;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.09.03.09.21.33;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.11.26.12.50.20;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.09.16.16.54.04;	author brad;	state Exp;
branches;
next	1.1.1.9;
commitid	BWSdZeElrpYSRdME;

1.1.1.9
date	2015.02.03.10.24.32;	author brad;	state Exp;
branches;
next	1.1.1.10;
commitid	yn8l9RVkmdMVYIfl;

1.1.1.10
date	2015.07.17.17.36.01;	author sthen;	state Exp;
branches;
next	;
commitid	Jeq5uGP63ff7nS9K;


desc
@@


1.11
log
@merge conflicts
@
text
@/*
 * dname.c -- Domain name handling.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */


#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

#include "dns.h"
#include "dname.h"
#include "query.h"

const dname_type *
dname_make(region_type *region, const uint8_t *name, int normalize)
{
	size_t name_size = 0;
	uint8_t label_offsets[MAXDOMAINLEN];
	uint8_t label_count = 0;
	const uint8_t *label = name;
	dname_type *result;
	ssize_t i;

	assert(name);

	while (1) {
		if (label_is_pointer(label))
			return NULL;

		label_offsets[label_count] = (uint8_t) (label - name);
		++label_count;
		name_size += label_length(label) + 1;

		if (label_is_root(label))
			break;

		label = label_next(label);
	}

	if (name_size > MAXDOMAINLEN)
		return NULL;

	assert(label_count <= MAXDOMAINLEN / 2 + 1);

	/* Reverse label offsets.  */
	for (i = 0; i < label_count / 2; ++i) {
		uint8_t tmp = label_offsets[i];
		label_offsets[i] = label_offsets[label_count - i - 1];
		label_offsets[label_count - i - 1] = tmp;
	}

	result = (dname_type *) region_alloc(
		region,
		(sizeof(dname_type)
		 + (((size_t)label_count) + ((size_t)name_size)) * sizeof(uint8_t)));
	result->name_size = name_size;
	result->label_count = label_count;
	memcpy((uint8_t *) dname_label_offsets(result),
	       label_offsets,
	       label_count * sizeof(uint8_t));
	if (normalize) {
		uint8_t *dst = (uint8_t *) dname_name(result);
		const uint8_t *src = name;
		while (!label_is_root(src)) {
			ssize_t len = label_length(src);
			*dst++ = *src++;
			for (i = 0; i < len; ++i) {
				*dst++ = DNAME_NORMALIZE((unsigned char)*src++);
			}
		}
		*dst = *src;
	} else {
		memcpy((uint8_t *) dname_name(result),
		       name,
		       name_size * sizeof(uint8_t));
	}
	return result;
}


const dname_type *
dname_make_from_packet(region_type *region, buffer_type *packet,
		       int allow_pointers, int normalize)
{
	uint8_t buf[MAXDOMAINLEN + 1];
	if(!dname_make_wire_from_packet(buf, packet, allow_pointers))
		return 0;
	return dname_make(region, buf, normalize);
}

int
dname_make_wire_from_packet(uint8_t *buf, buffer_type *packet,
                       int allow_pointers)
{
	int done = 0;
	uint8_t visited[(MAX_PACKET_SIZE+7)/8];
	size_t dname_length = 0;
	const uint8_t *label;
	ssize_t mark = -1;

	memset(visited, 0, (buffer_limit(packet)+7)/8);

	while (!done) {
		if (!buffer_available(packet, 1)) {
/* 			error("dname out of bounds"); */
			return 0;
		}

		if (get_bit(visited, buffer_position(packet))) {
/* 			error("dname loops"); */
			return 0;
		}
		set_bit(visited, buffer_position(packet));

		label = buffer_current(packet);
		if (label_is_pointer(label)) {
			size_t pointer;
			if (!allow_pointers) {
				return 0;
			}
			if (!buffer_available(packet, 2)) {
/* 				error("dname pointer out of bounds"); */
				return 0;
			}
			pointer = label_pointer_location(label);
			if (pointer >= buffer_limit(packet)) {
/* 				error("dname pointer points outside packet"); */
				return 0;
			}
			buffer_skip(packet, 2);
			if (mark == -1) {
				mark = buffer_position(packet);
			}
			buffer_set_position(packet, pointer);
		} else if (label_is_normal(label)) {
			size_t length = label_length(label) + 1;
			done = label_is_root(label);
			if (!buffer_available(packet, length)) {
/* 				error("dname label out of bounds"); */
				return 0;
			}
			if (dname_length + length >= MAXDOMAINLEN+1) {
/* 				error("dname too large"); */
				return 0;
			}
			buffer_read(packet, buf + dname_length, length);
			dname_length += length;
		} else {
/* 			error("bad label type"); */
			return 0;
		}
	}

	if (mark != -1) {
		buffer_set_position(packet, mark);
	}

	return dname_length;
}

const dname_type *
dname_parse(region_type *region, const char *name)
{
	uint8_t dname[MAXDOMAINLEN];
	if(!dname_parse_wire(dname, name))
		return 0;
	return dname_make(region, dname, 1);
}

int dname_parse_wire(uint8_t* dname, const char* name)
{
	const uint8_t *s = (const uint8_t *) name;
	uint8_t *h;
	uint8_t *p;
	uint8_t *d = dname;
	size_t label_length;

	if (strcmp(name, ".") == 0) {
		/* Root domain.  */
		dname[0] = 0;
		return 1;
	}

	for (h = d, p = h + 1; *s; ++s, ++p) {
		if (p - dname >= MAXDOMAINLEN) {
			return 0;
		}

		switch (*s) {
		case '.':
			if (p == h + 1) {
				/* Empty label.  */
				return 0;
			} else {
				label_length = p - h - 1;
				if (label_length > MAXLABELLEN) {
					return 0;
				}
				*h = label_length;
				h = p;
			}
			break;
		case '\\':
			/* Handle escaped characters (RFC1035 5.1) */
			if (isdigit((unsigned char)s[1]) && isdigit((unsigned char)s[2]) && isdigit((unsigned char)s[3])) {
				int val = (hexdigit_to_int(s[1]) * 100 +
					   hexdigit_to_int(s[2]) * 10 +
					   hexdigit_to_int(s[3]));
				if (0 <= val && val <= 255) {
					s += 3;
					*p = val;
				} else {
					*p = *++s;
				}
			} else if (s[1] != '\0') {
				*p = *++s;
			}
			break;
		default:
			*p = *s;
			break;
		}
	}

	if (p != h + 1) {
		/* Terminate last label.  */
		label_length = p - h - 1;
		if (label_length > MAXLABELLEN) {
			return 0;
		}
		*h = label_length;
		h = p;
	}

	/* Add root label.  */
	if (h - dname >= MAXDOMAINLEN) {
		return 0;
	}
	*h = 0;

	return p-dname;
}


const dname_type *
dname_copy(region_type *region, const dname_type *dname)
{
	return (dname_type *) region_alloc_init(
		region, dname, dname_total_size(dname));
}


const dname_type *
dname_partial_copy(region_type *region, const dname_type *dname, uint8_t label_count)
{
	if (!dname)
		return NULL;

	if (label_count == 0) {
		/* Always copy the root label.  */
		label_count = 1;
	}

	assert(label_count <= dname->label_count);

	return dname_make(region, dname_label(dname, label_count - 1), 0);
}


const dname_type *
dname_origin(region_type *region, const dname_type *dname)
{
	return dname_partial_copy(region, dname, dname->label_count - 1);
}


int
dname_is_subdomain(const dname_type *left, const dname_type *right)
{
	uint8_t i;

	if (left->label_count < right->label_count)
		return 0;

	for (i = 1; i < right->label_count; ++i) {
		if (label_compare(dname_label(left, i),
				  dname_label(right, i)) != 0)
			return 0;
	}

	return 1;
}


int
dname_compare(const dname_type *left, const dname_type *right)
{
	int result;
	uint8_t label_count;
	uint8_t i;

	assert(left);
	assert(right);

	if (left == right) {
		return 0;
	}

	label_count = (left->label_count <= right->label_count
		       ? left->label_count
		       : right->label_count);

	/* Skip the root label by starting at label 1.  */
	for (i = 1; i < label_count; ++i) {
		result = label_compare(dname_label(left, i),
				       dname_label(right, i));
		if (result) {
			return result;
		}
	}

	/* Dname with the fewest labels is "first".  */
	/* the subtraction works because the size of int is much larger than
	 * the label count and the values won't wrap around */
	return (int) left->label_count - (int) right->label_count;
}


int
label_compare(const uint8_t *left, const uint8_t *right)
{
	int left_length;
	int right_length;
	size_t size;
	int result;

	assert(left);
	assert(right);

	assert(label_is_normal(left));
	assert(label_is_normal(right));

	left_length = label_length(left);
	right_length = label_length(right);
	size = left_length < right_length ? left_length : right_length;

	result = memcmp(label_data(left), label_data(right), size);
	if (result) {
		return result;
	} else {
		/* the subtraction works because the size of int is much
		 * larger than the lengths and the values won't wrap around */
		return (int) left_length - (int) right_length;
	}
}


uint8_t
dname_label_match_count(const dname_type *left, const dname_type *right)
{
	uint8_t i;

	assert(left);
	assert(right);

	for (i = 1; i < left->label_count && i < right->label_count; ++i) {
		if (label_compare(dname_label(left, i),
				  dname_label(right, i)) != 0)
		{
			return i;
		}
	}

	return i;
}

const char *
dname_to_string(const dname_type *dname, const dname_type *origin)
{
	static char buf[MAXDOMAINLEN * 5];
	size_t i;
	size_t labels_to_convert = dname->label_count - 1;
	int absolute = 1;
	char *dst;
	const uint8_t *src;

	if (dname->label_count == 1) {
		strlcpy(buf, ".", sizeof(buf));
		return buf;
	}

	if (origin && dname_is_subdomain(dname, origin)) {
		int common_labels = dname_label_match_count(dname, origin);
		labels_to_convert = dname->label_count - common_labels;
		absolute = 0;
	}

	dst = buf;
	src = dname_name(dname);
	for (i = 0; i < labels_to_convert; ++i) {
		size_t len = label_length(src);
		size_t j;
		++src;
		for (j = 0; j < len; ++j) {
			uint8_t ch = *src++;
			if (isalnum((unsigned char)ch) || ch == '-' || ch == '_') {
				*dst++ = ch;
			} else if (ch == '.' || ch == '\\') {
				*dst++ = '\\';
				*dst++ = ch;
			} else {
				snprintf(dst, 5, "\\%03u", (unsigned int)ch);
				dst += 4;
			}
		}
		*dst++ = '.';
	}
	if (absolute) {
		*dst = '\0';
	} else {
		*--dst = '\0';
	}
	return buf;
}


const dname_type *
dname_make_from_label(region_type *region,
		      const uint8_t *label, const size_t length)
{
	uint8_t temp[MAXLABELLEN + 2];

	assert(length > 0 && length <= MAXLABELLEN);

	temp[0] = length;
	memcpy(temp + 1, label, length * sizeof(uint8_t));
	temp[length + 1] = '\000';

	return dname_make(region, temp, 1);
}


const dname_type *
dname_concatenate(region_type *region,
		  const dname_type *left,
		  const dname_type *right)
{
	uint8_t temp[MAXDOMAINLEN];

	assert(left->name_size + right->name_size - 1 <= MAXDOMAINLEN);

	memcpy(temp, dname_name(left), left->name_size - 1);
	memcpy(temp + left->name_size - 1, dname_name(right), right->name_size);

	return dname_make(region, temp, 0);
}


const dname_type *
dname_replace(region_type* region,
		const dname_type* name,
		const dname_type* src,
		const dname_type* dest)
{
	/* nomenclature: name is said to be <x>.<src>. x can be null. */
	dname_type* res;
	int x_labels = name->label_count - src->label_count;
	int x_len = name->name_size - src->name_size;
	int i;
	assert(dname_is_subdomain(name, src));

	/* check if final size is acceptable */
	if(x_len+dest->name_size > MAXDOMAINLEN)
		return NULL;

	res = (dname_type*)region_alloc(region, sizeof(dname_type) +
		(x_labels+((int)dest->label_count) + x_len+((int)dest->name_size))
		*sizeof(uint8_t));
	res->name_size = x_len+dest->name_size;
	res->label_count = x_labels+dest->label_count;
	for(i=0; i<dest->label_count; i++)
		((uint8_t*)dname_label_offsets(res))[i] =
			dname_label_offsets(dest)[i] + x_len;
	for(i=dest->label_count; i<res->label_count; i++)
		((uint8_t*)dname_label_offsets(res))[i] =
			dname_label_offsets(name)[i - dest->label_count +
				src->label_count];
	memcpy((uint8_t*)dname_name(res), dname_name(name), x_len);
	memcpy((uint8_t*)dname_name(res)+x_len, dname_name(dest), dest->name_size);
	assert(dname_is_subdomain(res, dest));
	return res;
}

char* wirelabel2str(const uint8_t* label)
{
	static char buf[MAXDOMAINLEN*5+3];
	char* p = buf;
	uint8_t lablen;
	lablen = *label++;
	while(lablen--) {
		uint8_t ch = *label++;
		if (isalnum((unsigned char)ch) || ch == '-' || ch == '_') {
			*p++ = ch;
		} else if (ch == '.' || ch == '\\') {
			*p++ = '\\';
			*p++ = ch;
		} else {
			snprintf(p, 5, "\\%03u", (unsigned int)ch);
			p += 4;
		}
	}
	*p++ = 0;
	return buf;
}

char* wiredname2str(const uint8_t* dname)
{
	static char buf[MAXDOMAINLEN*5+3];
	char* p = buf;
	uint8_t lablen;
	if(*dname == 0) {
		strlcpy(buf, ".", sizeof(buf));
		return buf;
	}
	lablen = *dname++;
	while(lablen) {
		while(lablen--) {
			uint8_t ch = *dname++;
			if (isalnum((unsigned char)ch) || ch == '-' || ch == '_' || ch == '*') {
				*p++ = ch;
			} else if (ch == '.' || ch == '\\') {
				*p++ = '\\';
				*p++ = ch;
			} else {
				snprintf(p, 5, "\\%03u", (unsigned int)ch);
				p += 4;
			}
		}
		lablen = *dname++;
		*p++ = '.';
	}
	*p++ = 0;
	return buf;
}

int dname_equal_nocase(uint8_t* a, uint8_t* b, uint16_t len)
{
	uint8_t i, lablen;
	while(len > 0) {
		/* check labellen */
		if(*a != *b)
			return 0;
		lablen = *a++;
		b++;
		len--;
		/* malformed or compression ptr; we stop scanning */
		if((lablen & 0xc0) || len < lablen)
			return (memcmp(a, b, len) == 0);
		/* check the label, lowercased */
		for(i=0; i<lablen; i++) {
			if(DNAME_NORMALIZE((unsigned char)*a++) != DNAME_NORMALIZE((unsigned char)*b++))
				return 0;
		}
		len -= lablen;
	}
	return 1;
}
@


1.10
log
@merge conflicts
@
text
@d66 1
a66 1
		 + (label_count + name_size) * sizeof(uint8_t)));
d247 3
d488 1
a488 1
		(x_labels+dest->label_count + x_len+dest->name_size)
@


1.9
log
@merge conflicts
@
text
@d79 1
a79 1
				*dst++ = DNAME_NORMALIZE(*src++);
d216 1
a216 1
			if (isdigit(s[1]) && isdigit(s[2]) && isdigit(s[3])) {
d331 2
d359 2
d414 1
a414 1
			if (isalnum(ch) || ch == '-' || ch == '_') {
d510 1
a510 1
		if (isalnum(ch) || ch == '-' || ch == '_') {
d537 1
a537 1
			if (isalnum(ch) || ch == '-' || ch == '_' || ch == '*') {
d569 1
a569 1
			if(DNAME_NORMALIZE(*a++) != DNAME_NORMALIZE(*b++))
@


1.8
log
@merge conflicts
@
text
@d533 1
a533 1
			if (isalnum(ch) || ch == '-' || ch == '_') {
@


1.7
log
@merge NSD 3.2.16
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
a19 1
#include <errno.h>
a24 7
/**
 * The maximum number of labels is the maximum domain name, less 1 for
 * the root (len == 0) label, divided by two (minimum non-root label of
 * one character + length byte), then add back in one for the root label.
 */
#define	MAXLABELS	(((MAXDOMAINLEN - 1) / 2) + 1)

d304 1
a304 1
dname_compare(const void *vleft, const void *vright)
a305 2
	const dname_type* left = (const dname_type*) vleft;
	const dname_type* right = (const dname_type*) vright;
a384 7
	return dname_to_string_r(dname, origin, buf);
}

const char *
dname_to_string_r(const dname_type *dname, const dname_type *origin,
	char* buf)
{
d386 1
a386 1
	size_t labels_to_convert = 0;
d390 1
a390 5
	if (!dname) {
		*buf = '\0';
		return buf;
	}
	dst = buf;
d392 1
a392 2
		*dst++ = '.';
		*dst = '\0';
a394 1
	labels_to_convert = dname->label_count - 1;
d402 1
d498 23
a520 9
#ifndef FULL_PREHASH
/**
 * Make wildcard synthesis.
 *
 */
int
dname_make_wildcard(struct region *region,
		    struct dname const *dname,
		    struct dname const **wildcard)
d522 26
a547 44
	uint8_t name_size;
	uint8_t label_count;
	uint8_t *names;
	uint8_t *labels;
	struct dname *new_dname;
	unsigned int i;
	/*
	 * Checks:
	 *	dname label_count + 1 < MAXLABELS
	 * 	dname size + 2 < MAXDOMAINLEN
	 */
	if (dname->label_count > (MAXLABELS - 1)) {
		return EINVAL;
	}
	if (dname->name_size > (MAXDOMAINLEN - 2)) {
		return EINVAL;
	}

	label_count = dname->label_count + 1;
	name_size = dname->name_size + 2;
	new_dname = (struct dname *) region_alloc(region,
						  sizeof(dname_type) +
						  (label_count * sizeof(uint8_t)) +
						  (name_size * sizeof(uint8_t)));
	if (new_dname == NULL) {
		return ENOMEM;
	}
	new_dname->label_count = label_count;
	new_dname->name_size = name_size;
	labels = (uint8_t *) dname_label_offsets(new_dname);
	memcpy(labels, dname_label_offsets(dname),
	       dname->label_count * sizeof(uint8_t));
	for (i = 0; i < dname->label_count; i++) {
		labels[i] += 2;
	}
	labels[i] = 0;

	names = (uint8_t *) dname_name(new_dname);
	*names++ = '\001';
	*names++ = '*';
	memcpy(names, dname_name(dname),
	       dname->name_size * sizeof(uint8_t));
	*wildcard = new_dname;
	return 0;
a548 1
#endif
d550 22
@


1.6
log
@resolve conflicts
@
text
@d411 1
d413 2
a414 1
		strlcpy(buf, ".", sizeof(buf));
a424 1
	dst = buf;
d576 1
@


1.5
log
@resolve conflicts
@
text
@d574 1
a574 1
#endif@


1.4
log
@resolve conflicts
@
text
@d11 1
a11 1
#include <config.h>
@


1.3
log
@resolve conflicts and regen configure using autoconf-2.65
@
text
@d20 1
d26 7
d312 1
a312 1
dname_compare(const dname_type *left, const dname_type *right)
d314 2
d395 7
d403 1
a403 1
	size_t labels_to_convert = dname->label_count - 1;
d407 4
a410 1

d415 1
d519 56
@


1.2
log
@strcpy/strncat/sprintf --> strlcpy/strlcat/snprintf

ok jakob@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
@


1.1
log
@Initial revision
@
text
@d392 1
a392 1
		strcpy(buf, ".");
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.5
@
text
@d392 1
a392 1
		strlcpy(buf, ".", sizeof(buf));
@


1.1.1.3
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.4
log
@NSD v3.2.9
@
text
@a19 1
#include <errno.h>
a24 7
/**
 * The maximum number of labels is the maximum domain name, less 1 for
 * the root (len == 0) label, divided by two (minimum non-root label of
 * one character + length byte), then add back in one for the root label.
 */
#define	MAXLABELS	(((MAXDOMAINLEN - 1) / 2) + 1)

d304 1
a304 1
dname_compare(const void *vleft, const void *vright)
a305 2
	const dname_type* left = (const dname_type*) vleft;
	const dname_type* right = (const dname_type*) vright;
a384 7
	return dname_to_string_r(dname, origin, buf);
}

const char *
dname_to_string_r(const dname_type *dname, const dname_type *origin,
	char* buf)
{
d386 1
a386 1
	size_t labels_to_convert = 0;
d390 1
a390 4
	if (!dname) {
		*buf = '\0';
		return buf;
	}
a394 1
	labels_to_convert = dname->label_count - 1;
a497 56
#ifndef FULL_PREHASH
/**
 * Make wildcard synthesis.
 *
 */
int
dname_make_wildcard(struct region *region,
		    struct dname const *dname,
		    struct dname const **wildcard)
{
	uint8_t name_size;
	uint8_t label_count;
	uint8_t *names;
	uint8_t *labels;
	struct dname *new_dname;
	unsigned int i;
	/*
	 * Checks:
	 *	dname label_count + 1 < MAXLABELS
	 * 	dname size + 2 < MAXDOMAINLEN
	 */
	if (dname->label_count > (MAXLABELS - 1)) {
		return EINVAL;
	}
	if (dname->name_size > (MAXDOMAINLEN - 2)) {
		return EINVAL;
	}

	label_count = dname->label_count + 1;
	name_size = dname->name_size + 2;
	new_dname = (struct dname *) region_alloc(region,
						  sizeof(dname_type) +
						  (label_count * sizeof(uint8_t)) +
						  (name_size * sizeof(uint8_t)));
	if (new_dname == NULL) {
		return ENOMEM;
	}
	new_dname->label_count = label_count;
	new_dname->name_size = name_size;
	labels = (uint8_t *) dname_label_offsets(new_dname);
	memcpy(labels, dname_label_offsets(dname),
	       dname->label_count * sizeof(uint8_t));
	for (i = 0; i < dname->label_count; i++) {
		labels[i] += 2;
	}
	labels[i] = 0;

	names = (uint8_t *) dname_name(new_dname);
	*names++ = '\001';
	*names++ = '*';
	memcpy(names, dname_name(dname),
	       dname->name_size * sizeof(uint8_t));
	*wildcard = new_dname;
	return 0;
}
#endif@


1.1.1.5
log
@NSD v3.2.11, ok phessler@@
@
text
@d11 1
a11 1
#include "config.h"
@


1.1.1.6
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@a410 1
	dst = buf;
d412 1
a412 2
		*dst++ = '.';
		*dst = '\0';
d423 1
d574 1
a574 2
#endif

@


1.1.1.7
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d20 1
d26 7
d312 1
a312 1
dname_compare(const dname_type *left, const dname_type *right)
d314 2
d395 7
d403 1
a403 1
	size_t labels_to_convert = dname->label_count - 1;
d407 5
a411 1

d413 2
a414 1
		strlcpy(buf, ".", sizeof(buf));
d417 1
a424 1
	dst = buf;
d520 9
a528 1
char* wirelabel2str(const uint8_t* label)
d530 44
a573 48
	static char buf[MAXDOMAINLEN*5+3];
	char* p = buf;
	uint8_t lablen;
	lablen = *label++;
	while(lablen--) {
		uint8_t ch = *label++;
		if (isalnum(ch) || ch == '-' || ch == '_') {
			*p++ = ch;
		} else if (ch == '.' || ch == '\\') {
			*p++ = '\\';
			*p++ = ch;
		} else {
			snprintf(p, 5, "\\%03u", (unsigned int)ch);
			p += 4;
		}
	}
	*p++ = 0;
	return buf;
}

char* wiredname2str(const uint8_t* dname)
{
	static char buf[MAXDOMAINLEN*5+3];
	char* p = buf;
	uint8_t lablen;
	if(*dname == 0) {
		strlcpy(buf, ".", sizeof(buf));
		return buf;
	}
	lablen = *dname++;
	while(lablen) {
		while(lablen--) {
			uint8_t ch = *dname++;
			if (isalnum(ch) || ch == '-' || ch == '_') {
				*p++ = ch;
			} else if (ch == '.' || ch == '\\') {
				*p++ = '\\';
				*p++ = ch;
			} else {
				snprintf(p, 5, "\\%03u", (unsigned int)ch);
				p += 4;
			}
		}
		lablen = *dname++;
		*p++ = '.';
	}
	*p++ = 0;
	return buf;
d575 1
a576 22
int dname_equal_nocase(uint8_t* a, uint8_t* b, uint16_t len)
{
	uint8_t i, lablen;
	while(len > 0) {
		/* check labellen */
		if(*a != *b)
			return 0;
		lablen = *a++;
		b++;
		len--;
		/* malformed or compression ptr; we stop scanning */
		if((lablen & 0xc0) || len < lablen)
			return (memcmp(a, b, len) == 0);
		/* check the label, lowercased */
		for(i=0; i<lablen; i++) {
			if(DNAME_NORMALIZE(*a++) != DNAME_NORMALIZE(*b++))
				return 0;
		}
		len -= lablen;
	}
	return 1;
}
@


1.1.1.8
log
@update to NSD 4.1.0, ok sthen@@
@
text
@d533 1
a533 1
			if (isalnum(ch) || ch == '-' || ch == '_' || ch == '*') {
@


1.1.1.9
log
@update to NSD 4.1.1, ok sthen@@
@
text
@d79 1
a79 1
				*dst++ = DNAME_NORMALIZE((unsigned char)*src++);
d216 1
a216 1
			if (isdigit((unsigned char)s[1]) && isdigit((unsigned char)s[2]) && isdigit((unsigned char)s[3])) {
a330 2
	/* the subtraction works because the size of int is much larger than
	 * the label count and the values won't wrap around */
a356 2
		/* the subtraction works because the size of int is much
		 * larger than the lengths and the values won't wrap around */
d410 1
a410 1
			if (isalnum((unsigned char)ch) || ch == '-' || ch == '_') {
d506 1
a506 1
		if (isalnum((unsigned char)ch) || ch == '-' || ch == '_') {
d533 1
a533 1
			if (isalnum((unsigned char)ch) || ch == '-' || ch == '_' || ch == '*') {
d565 1
a565 1
			if(DNAME_NORMALIZE((unsigned char)*a++) != DNAME_NORMALIZE((unsigned char)*b++))
@


1.1.1.10
log
@update to NSD 4.1.3, ok florian@@, also tested by brad
@
text
@d66 1
a66 1
		 + (((size_t)label_count) + ((size_t)name_size)) * sizeof(uint8_t)));
a246 3
	if (h - dname >= MAXDOMAINLEN) {
		return 0;
	}
d485 1
a485 1
		(x_labels+((int)dest->label_count) + x_len+((int)dest->name_size))
@


