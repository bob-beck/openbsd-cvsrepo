head	1.19;
access;
symbols
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	NSD_4_1_6:1.1.1.12
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	NSD_4_1_3:1.1.1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	NSD_4_1_1:1.1.1.10
	NSD_4_1_0:1.1.1.9
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	NSD_4_0_3:1.1.1.8
	NSD_4_0_2:1.1.1.8
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	NSD_4_0_1:1.1.1.8
	NSD_4_0_0:1.1.1.8
	NSD_3_2_16:1.1.1.7
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	NSD_3_2_15:1.1.1.6
	NSD_3_2_14:1.1.1.5
	NSD_3_2_13:1.1.1.5
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	NSD_3_2_11:1.1.1.5
	NSD_3_2_10:1.1.1.4
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	NSD_3_2_9:1.1.1.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	NSD_3_2_8:1.1.1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	NSD_3_2_6:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.2
	OPENBSD_4_8_BASE:1.1.1.2
	NSD_3_2_5:1.1.1.2
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2017.04.15.09.15.45;	author florian;	state Exp;
branches;
next	1.18;
commitid	fXBqT4bSlfjTKAVE;

1.18
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.17;
commitid	WmSuN5M3Jbe54113;

1.17
date	2016.10.24.09.44.43;	author florian;	state Exp;
branches;
next	1.16;
commitid	g3wASIhTcujU0LFi;

1.16
date	2016.08.31.07.31.20;	author florian;	state Exp;
branches;
next	1.15;
commitid	1gMwFuybgH2l617m;

1.15
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.14;
commitid	Z9jVKJJMPmC3zw2t;

1.14
date	2015.12.11.12.28.49;	author sthen;	state Exp;
branches;
next	1.13;
commitid	e67Hx722TeF4XpDl;

1.13
date	2015.11.05.21.21.59;	author sthen;	state Exp;
branches;
next	1.12;
commitid	EVDZ1z8bzmTorwSZ;

1.12
date	2015.07.17.17.36.33;	author sthen;	state Exp;
branches;
next	1.11;
commitid	2WtkENMkCz3GhSbE;

1.11
date	2015.02.03.10.40.02;	author brad;	state Exp;
branches;
next	1.10;
commitid	MI9j0d0LR8Dk9lnd;

1.10
date	2014.09.16.17.01.38;	author brad;	state Exp;
branches;
next	1.9;
commitid	5uD1zN2z8VskC3BN;

1.9
date	2013.11.26.12.53.58;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.03.09.26.52;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2013.02.18.10.18.39;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2012.07.09.21.56.41;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2012.01.29.11.23.24;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.21.18.29.56;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.27.12.29.14;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.24.00.00.41;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.15.19.24.58;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.58;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.04.15.20.57.08;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.05.21.18.17.22;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.01.29.11.15.39;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.02.18.10.17.40;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.09.03.09.21.33;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.11.26.12.50.15;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.09.16.16.54.01;	author brad;	state Exp;
branches;
next	1.1.1.10;
commitid	BWSdZeElrpYSRdME;

1.1.1.10
date	2015.02.03.10.24.30;	author brad;	state Exp;
branches;
next	1.1.1.11;
commitid	yn8l9RVkmdMVYIfl;

1.1.1.11
date	2015.07.17.17.36.01;	author sthen;	state Exp;
branches;
next	1.1.1.12;
commitid	Jeq5uGP63ff7nS9K;

1.1.1.12
date	2015.11.05.21.21.04;	author sthen;	state Exp;
branches;
next	;
commitid	RXfGmPAh2IZTjnIf;


desc
@@


1.19
log
@update to 4.1.16rc1
tests & OK sthen

(if there are more changes coming for 4.1.16 release we will just
commit them on top)
@
text
@/*
 * checkconf - Read and repeat configuration file to output.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <limits.h>
#include "tsig.h"
#include "options.h"
#include "util.h"
#include "dname.h"
#include "rrl.h"

extern char *optarg;
extern int optind;

#define ZONE_GET_ACL(NAME, VAR, PATTERN) 		\
	if (strcasecmp(#NAME, (VAR)) == 0) { 	\
		quote_acl(PATTERN->NAME); 	\
		return; 			\
	}

#define ZONE_GET_OUTGOING(NAME, VAR, PATTERN)			\
	if (strcasecmp(#NAME, (VAR)) == 0) {		\
		acl_options_type* acl; 			\
		for(acl=PATTERN->NAME; acl; acl=acl->next)	\
			quote(acl->ip_address_spec);	\
		return; 				\
	}

#define ZONE_GET_STR(NAME, VAR, PATTERN) 		\
	if (strcasecmp(#NAME, (VAR)) == 0) { 	\
		quote(PATTERN->NAME); 		\
		return; 			\
	}

#define ZONE_GET_PATH(FINAL, NAME, VAR, PATTERN) 	\
	if (strcasecmp(#NAME, (VAR)) == 0) { 		\
		quotepath(opt, FINAL, PATTERN->NAME); 	\
		return; 				\
	}

#define ZONE_GET_BIN(NAME, VAR, PATTERN) 			\
	if (strcasecmp(#NAME, (VAR)) == 0) { 		\
		printf("%s\n", (PATTERN->NAME)?"yes":"no"); 	\
		return;					\
	}

#define ZONE_GET_RRL(NAME, VAR, PATTERN) 			\
	if (strcasecmp(#NAME, (VAR)) == 0) { 		\
		zone_print_rrl_whitelist("", PATTERN->NAME);	\
		return;					\
	}

#define ZONE_GET_INT(NAME, VAR, PATTERN) 		\
	if (strcasecmp(#NAME, (VAR)) == 0) { 	\
		printf("%d\n", (int) PATTERN->NAME); 	\
		return; 			\
	}

#define SERV_GET_BIN(NAME, VAR) 			\
	if (strcasecmp(#NAME, (VAR)) == 0) { 		\
		printf("%s\n", opt->NAME?"yes":"no"); 	\
		return;					\
	}

#define SERV_GET_STR(NAME, VAR) 		\
	if (strcasecmp(#NAME, (VAR)) == 0) { 	\
		quote(opt->NAME); 		\
		return; 			\
	}

#define SERV_GET_PATH(FINAL, NAME, VAR) 	\
	if (strcasecmp(#NAME, (VAR)) == 0) { 	\
		quotepath(opt, FINAL, opt->NAME); 	\
		return; 			\
	}

#define SERV_GET_INT(NAME, VAR) 		\
	if (strcasecmp(#NAME, (VAR)) == 0) { 	\
		printf("%d\n", (int) opt->NAME); 	\
		return; 			\
	}

#define SERV_GET_IP(NAME, MEMBER, VAR) 				\
	if (strcasecmp(#NAME, (VAR)) == 0) { 		\
		for(ip = opt->MEMBER; ip; ip=ip->next)	\
		{						\
			quote(ip->address);			\
		}						\
		return;						\
	}

#ifdef RATELIMIT
static void zone_print_rrl_whitelist(const char* s, uint16_t w)
{
	int i;
	if(w==rrl_type_all) {
		printf("%sall\n", s);
		return;
	}
	for(i=0x01; i <= 0x80; i<<=1) {
		if( (w&i) )
			printf("%s%s\n", s, rrltype2str(i));
	}
}
#endif /* RATELIMIT */

static char buf[BUFSIZ];

static char *
underscore(const char *s) {
	const char *j = s;
	size_t i = 0;

	while(j && *j) {
		if (*j == '-') {
			buf[i++] = '_';
		} else {
			buf[i++] = *j;
		}
		j++;
		if (i >= BUFSIZ) {
			return NULL;
		}
	}
	buf[i] = '\0';
	return buf;
}

static void
usage(void)
{
	fprintf(stderr, "usage: nsd-checkconf [-v|-h] [-o option] [-z zonename]\n");
	fprintf(stderr, "                     [-s keyname] <configfilename>\n");
	fprintf(stderr, "       Checks NSD configuration file for errors.\n");
	fprintf(stderr, "       Version %s. Report bugs to <%s>.\n\n",
		PACKAGE_VERSION, PACKAGE_BUGREPORT);
	fprintf(stderr, "Use with a configfile as argument to check syntax.\n");
	fprintf(stderr, "Use with -o, -z or -s options to query the configuration.\n\n");
	fprintf(stderr, "-v		Verbose, echo settings that take effect to std output.\n");
	fprintf(stderr, "-h		Print this help information.\n");
	fprintf(stderr, "-f		Use with -o to print final pathnames, ie. with chroot.\n");
	fprintf(stderr, "-o option	Print value of the option specified to stdout.\n");
	fprintf(stderr, "-p pattern	Print option value for the pattern given.\n");
	fprintf(stderr, "-z zonename	Print option value for the zone given.\n");
	fprintf(stderr, "-a keyname	Print algorithm name for the TSIG key.\n");
	fprintf(stderr, "-s keyname	Print base64 secret blob for the TSIG key.\n");
	exit(1);
}

static void
print_string_var(const char* varname, const char* value)
{
	if (!value) {
		printf("\t#%s\n", varname);
	} else {
		printf("\t%s \"%s\"\n", varname, value);
	}
}

static void
quote(const char *v)
{
	if(v==NULL)
		printf("\n");
	else
		printf("%s\n", v);
}

static void
quotepath(nsd_options_type* opt, int final, const char *f)
{
	const char* chr = opt->chroot;
#ifdef CHROOTDIR
	if(chr == 0) chr = CHROOTDIR;
#endif
	if(f == 0 || f[0] == '/' || !final || !chr || chr[0]==0) {
		quote(f);
		return;
	}
	/* chroot has had trailing slash applied in check part of checkconf */
	printf("%s%s\n", chr, f);
}

static void
quote_acl(acl_options_type* acl)
{
	while(acl)
	{
		printf("%s %s\n", acl->ip_address_spec,
			acl->nokey?"NOKEY":(acl->blocked?"BLOCKED":
			(acl->key_name?acl->key_name:"(null)")));
		acl=acl->next;
	}
}

static void
print_acl(const char* varname, acl_options_type* acl)
{
	while(acl)
	{
		printf("\t%s ", varname);
		if(acl->use_axfr_only)
			printf("AXFR ");
		if(acl->allow_udp)
			printf("UDP ");
		printf("%s %s\n", acl->ip_address_spec,
			acl->nokey?"NOKEY":(acl->blocked?"BLOCKED":
			(acl->key_name?acl->key_name:"(null)")));
		if(verbosity>1) {
			printf("\t# %s", acl->is_ipv6?"ip6":"ip4");
			if(acl->port == 0) printf(" noport");
			else printf(" port=%d", acl->port);
			if(acl->rangetype == acl_range_single) printf(" single");
			if(acl->rangetype == acl_range_mask)   printf(" masked");
			if(acl->rangetype == acl_range_subnet) printf(" subnet");
			if(acl->rangetype == acl_range_minmax) printf(" minmax");
			if(acl->is_ipv6) {
#ifdef INET6
				char dest[128];
				inet_ntop(AF_INET6, &acl->addr.addr6, dest, sizeof(dest));
				printf(" addr=%s", dest);
				if(acl->rangetype != acl_range_single) {
					inet_ntop(AF_INET6, &acl->range_mask.addr6, dest, sizeof(dest));
					printf(" rangemask=%s", dest);
				}
#else
				printf(" ip6addr-noip6defined");
#endif
			} else {
				char dest[128];
				inet_ntop(AF_INET, &acl->addr.addr, dest, sizeof(dest));
				printf(" addr=%s", dest);
				if(acl->rangetype != acl_range_single) {
					inet_ntop(AF_INET, &acl->range_mask.addr, dest, sizeof(dest));
					printf(" rangemask=%s", dest);
				}
			}
			printf("\n");
		}
		acl=acl->next;
	}
}

static void
print_acl_ips(const char* varname, acl_options_type* acl)
{
	while(acl)
	{
		printf("\t%s %s\n", varname, acl->ip_address_spec);
		acl=acl->next;
	}
}

void
config_print_zone(nsd_options_type* opt, const char* k, int s, const char *o,
	const char *z, const char* pat, int final)
{
	ip_address_option_type* ip;

	if (k) {
		/* find key */
		key_options_type* key = key_options_find(opt, k);
		if(key) {
			if (s) {
				quote(key->secret);
			} else {
				quote(key->algorithm);
			}
			return;
		}
		printf("Could not find key %s\n", k);
		return;
	}

	if (!o) {
		return;
	}

	if (z) {
		zone_options_type* zone;
		const dname_type *dname = dname_parse(opt->region, z);
		if(!dname) {
			printf("Could not parse zone name %s\n", z);
			exit(1);
		}
		zone = zone_options_find(opt, dname);
		if(!zone) {
			printf("Zone does not exist: %s\n", z);
			exit(1);
		}
		ZONE_GET_STR(name, o, zone);
		if(strcasecmp("pattern", o)==0) {
			quote(zone->pattern->pname);
			return;
		}
		ZONE_GET_BIN(part_of_config, o, zone);
		ZONE_GET_PATH(final, zonefile, o, zone->pattern);
		ZONE_GET_ACL(request_xfr, o, zone->pattern);
		ZONE_GET_ACL(provide_xfr, o, zone->pattern);
		ZONE_GET_ACL(allow_notify, o, zone->pattern);
		ZONE_GET_ACL(notify, o, zone->pattern);
		ZONE_GET_BIN(notify_retry, o, zone->pattern);
		ZONE_GET_STR(zonestats, o, zone->pattern);
		ZONE_GET_OUTGOING(outgoing_interface, o, zone->pattern);
		ZONE_GET_BIN(allow_axfr_fallback, o, zone->pattern);
		ZONE_GET_INT(max_refresh_time, o, zone->pattern);
		ZONE_GET_INT(min_refresh_time, o, zone->pattern);
		ZONE_GET_INT(max_retry_time, o, zone->pattern);
		ZONE_GET_INT(min_retry_time, o, zone->pattern);
		ZONE_GET_INT(size_limit_xfr, o, zone->pattern);
#ifdef RATELIMIT
		ZONE_GET_RRL(rrl_whitelist, o, zone->pattern);
#endif
		ZONE_GET_BIN(multi_master_check, o, zone->pattern);
		printf("Zone option not handled: %s %s\n", z, o);
		exit(1);
	} else if(pat) {
		pattern_options_type* p = pattern_options_find(opt, pat);
		if(!p) {
			printf("Pattern does not exist: %s\n", pat);
			exit(1);
		}
		if(strcasecmp("name", o)==0) {
			quote(p->pname);
			return;
		}
		ZONE_GET_STR(zonefile, o, p);
		ZONE_GET_PATH(final, zonefile, o, p);
		ZONE_GET_ACL(request_xfr, o, p);
		ZONE_GET_ACL(provide_xfr, o, p);
		ZONE_GET_ACL(allow_notify, o, p);
		ZONE_GET_ACL(notify, o, p);
		ZONE_GET_BIN(notify_retry, o, p);
		ZONE_GET_STR(zonestats, o, p);
		ZONE_GET_OUTGOING(outgoing_interface, o, p);
		ZONE_GET_BIN(allow_axfr_fallback, o, p);
		ZONE_GET_INT(max_refresh_time, o, p);
		ZONE_GET_INT(min_refresh_time, o, p);
		ZONE_GET_INT(max_retry_time, o, p);
		ZONE_GET_INT(min_retry_time, o, p);
		ZONE_GET_INT(size_limit_xfr, o, p);
#ifdef RATELIMIT
		ZONE_GET_RRL(rrl_whitelist, o, p);
#endif
		ZONE_GET_BIN(multi_master_check, o, p);
		printf("Pattern option not handled: %s %s\n", pat, o);
		exit(1);
	} else {
		/* look in the server section */
		SERV_GET_IP(ip_address, ip_addresses, o);
		/* bin */
		SERV_GET_BIN(ip_transparent, o);
		SERV_GET_BIN(ip_freebind, o);
		SERV_GET_BIN(debug_mode, o);
		SERV_GET_BIN(do_ip4, o);
		SERV_GET_BIN(do_ip6, o);
		SERV_GET_BIN(reuseport, o);
		SERV_GET_BIN(hide_version, o);
		SERV_GET_BIN(zonefiles_check, o);
		SERV_GET_BIN(log_time_ascii, o);
		SERV_GET_BIN(round_robin, o);
		SERV_GET_BIN(minimal_responses, o);
		/* str */
		SERV_GET_PATH(final, database, o);
		SERV_GET_STR(identity, o);
		SERV_GET_STR(version, o);
		SERV_GET_STR(nsid, o);
		SERV_GET_PATH(final, logfile, o);
		SERV_GET_PATH(final, pidfile, o);
		SERV_GET_STR(chroot, o);
		SERV_GET_STR(username, o);
		SERV_GET_PATH(final, zonesdir, o);
		SERV_GET_PATH(final, xfrdfile, o);
		SERV_GET_PATH(final, xfrdir, o);
		SERV_GET_PATH(final, zonelistfile, o);
		SERV_GET_STR(port, o);
		/* int */
		SERV_GET_INT(server_count, o);
		SERV_GET_INT(tcp_count, o);
		SERV_GET_INT(tcp_query_count, o);
		SERV_GET_INT(tcp_timeout, o);
		SERV_GET_INT(tcp_mss, o);
		SERV_GET_INT(outgoing_tcp_mss, o);
		SERV_GET_INT(ipv4_edns_size, o);
		SERV_GET_INT(ipv6_edns_size, o);
		SERV_GET_INT(statistics, o);
		SERV_GET_INT(xfrd_reload_timeout, o);
		SERV_GET_INT(verbosity, o);
#ifdef RATELIMIT
		SERV_GET_INT(rrl_size, o);
		SERV_GET_INT(rrl_ratelimit, o);
		SERV_GET_INT(rrl_slip, o);
		SERV_GET_INT(rrl_ipv4_prefix_length, o);
		SERV_GET_INT(rrl_ipv6_prefix_length, o);
		SERV_GET_INT(rrl_whitelist_ratelimit, o);
#endif
		SERV_GET_INT(zonefiles_write, o);
		/* remote control */
		SERV_GET_BIN(control_enable, o);
		SERV_GET_IP(control_interface, control_interface, o);
		SERV_GET_INT(control_port, o);
		SERV_GET_STR(server_key_file, o);
		SERV_GET_STR(server_cert_file, o);
		SERV_GET_STR(control_key_file, o);
		SERV_GET_STR(control_cert_file, o);

		if(strcasecmp(o, "zones") == 0) {
			zone_options_type* zone;
			RBTREE_FOR(zone, zone_options_type*, opt->zone_options)
				quote(zone->name);
			return;
		}
		if(strcasecmp(o, "patterns") == 0) {
			pattern_options_type* p;
			RBTREE_FOR(p, pattern_options_type*, opt->patterns)
				quote(p->pname);
			return;
		}
		printf("Server option not handled: %s\n", o);
		exit(1);
	}
}

/* print zone content items */
static void print_zone_content_elems(pattern_options_type* pat)
{
	if(pat->zonefile)
		print_string_var("zonefile:", pat->zonefile);
#ifdef RATELIMIT
	zone_print_rrl_whitelist("\trrl-whitelist: ", pat->rrl_whitelist);
#endif
	print_acl("allow-notify:", pat->allow_notify);
	print_acl("request-xfr:", pat->request_xfr);
	if(pat->multi_master_check)
		printf("\tmulti-master-check: %s\n", pat->multi_master_check?"yes":"no");
	if(!pat->notify_retry_is_default)
		printf("\tnotify-retry: %d\n", pat->notify_retry);
	print_acl("notify:", pat->notify);
	print_acl("provide-xfr:", pat->provide_xfr);
	if(pat->zonestats)
		print_string_var("zonestats:", pat->zonestats);
	print_acl_ips("outgoing-interface:", pat->outgoing_interface);
	if(!pat->allow_axfr_fallback_is_default)
		printf("\tallow-axfr-fallback: %s\n",
			pat->allow_axfr_fallback?"yes":"no");
	if(!pat->max_refresh_time_is_default)
		printf("\tmax-refresh-time: %d\n", pat->max_refresh_time);
	if(!pat->min_refresh_time_is_default)
		printf("\tmin-refresh-time: %d\n", pat->min_refresh_time);
	if(!pat->max_retry_time_is_default)
		printf("\tmax-retry-time: %d\n", pat->max_retry_time);
	if(!pat->min_retry_time_is_default)
		printf("\tmin-retry-time: %d\n", pat->min_retry_time);
	if(pat->size_limit_xfr != 0)
		printf("\tsize-limit-xfr: %llu\n",
			(long long unsigned)pat->size_limit_xfr);
}

void
config_test_print_server(nsd_options_type* opt)
{
	ip_address_option_type* ip;
	key_options_type* key;
	zone_options_type* zone;
	pattern_options_type* pat;

	printf("# Config settings.\n");
	printf("server:\n");
	printf("\tdebug-mode: %s\n", opt->debug_mode?"yes":"no");
	printf("\tip-transparent: %s\n", opt->ip_transparent?"yes":"no");
	printf("\tip-freebind: %s\n", opt->ip_freebind?"yes":"no");
	printf("\treuseport: %s\n", opt->reuseport?"yes":"no");
	printf("\tdo-ip4: %s\n", opt->do_ip4?"yes":"no");
	printf("\tdo-ip6: %s\n", opt->do_ip6?"yes":"no");
	printf("\thide-version: %s\n", opt->hide_version?"yes":"no");
	print_string_var("database:", opt->database);
	print_string_var("identity:", opt->identity);
	print_string_var("version:", opt->version);
	print_string_var("nsid:", opt->nsid);
	print_string_var("logfile:", opt->logfile);
	printf("\tserver-count: %d\n", opt->server_count);
	printf("\ttcp-count: %d\n", opt->tcp_count);
	printf("\ttcp-query-count: %d\n", opt->tcp_query_count);
	printf("\ttcp-timeout: %d\n", opt->tcp_timeout);
	printf("\ttcp-mss: %d\n", opt->tcp_mss);
	printf("\toutgoing-tcp-mss: %d\n", opt->outgoing_tcp_mss);
	printf("\tipv4-edns-size: %d\n", (int) opt->ipv4_edns_size);
	printf("\tipv6-edns-size: %d\n", (int) opt->ipv6_edns_size);
	print_string_var("pidfile:", opt->pidfile);
	print_string_var("port:", opt->port);
	printf("\tstatistics: %d\n", opt->statistics);
	print_string_var("chroot:", opt->chroot);
	print_string_var("username:", opt->username);
	print_string_var("zonesdir:", opt->zonesdir);
	print_string_var("xfrdfile:", opt->xfrdfile);
	print_string_var("zonelistfile:", opt->zonelistfile);
	print_string_var("xfrdir:", opt->xfrdir);
	printf("\txfrd-reload-timeout: %d\n", opt->xfrd_reload_timeout);
	printf("\tlog-time-ascii: %s\n", opt->log_time_ascii?"yes":"no");
	printf("\tround-robin: %s\n", opt->round_robin?"yes":"no");
	printf("\tminimal-responses: %s\n", opt->minimal_responses?"yes":"no");
	printf("\tverbosity: %d\n", opt->verbosity);
	for(ip = opt->ip_addresses; ip; ip=ip->next)
	{
		print_string_var("ip-address:", ip->address);
	}
#ifdef RATELIMIT
	printf("\trrl-size: %d\n", (int)opt->rrl_size);
	printf("\trrl-ratelimit: %d\n", (int)opt->rrl_ratelimit);
	printf("\trrl-slip: %d\n", (int)opt->rrl_slip);
	printf("\trrl-ipv4-prefix-length: %d\n", (int)opt->rrl_ipv4_prefix_length);
	printf("\trrl-ipv6-prefix-length: %d\n", (int)opt->rrl_ipv6_prefix_length);
	printf("\trrl-whitelist-ratelimit: %d\n", (int)opt->rrl_whitelist_ratelimit);
#endif
	printf("\tzonefiles-check: %s\n", opt->zonefiles_check?"yes":"no");
	printf("\tzonefiles-write: %d\n", opt->zonefiles_write);

	printf("\nremote-control:\n");
	printf("\tcontrol-enable: %s\n", opt->control_enable?"yes":"no");
	for(ip = opt->control_interface; ip; ip=ip->next)
		print_string_var("control-interface:", ip->address);
	printf("\tcontrol-port: %d\n", opt->control_port);
	print_string_var("server-key-file:", opt->server_key_file);
	print_string_var("server-cert-file:", opt->server_cert_file);
	print_string_var("control-key-file:", opt->control_key_file);
	print_string_var("control-cert-file:", opt->control_cert_file);

	RBTREE_FOR(key, key_options_type*, opt->keys)
	{
		printf("\nkey:\n");
		print_string_var("name:", key->name);
		print_string_var("algorithm:", key->algorithm);
		print_string_var("secret:", key->secret);
	}
	RBTREE_FOR(pat, pattern_options_type*, opt->patterns)
	{
		if(pat->implicit) continue;
		printf("\npattern:\n");
		print_string_var("name:", pat->pname);
		print_zone_content_elems(pat);
	}
	RBTREE_FOR(zone, zone_options_type*, opt->zone_options)
	{
		if(!zone->part_of_config)
			continue;
		printf("\nzone:\n");
		print_string_var("name:", zone->name);
		print_zone_content_elems(zone->pattern);
	}

}

static void
append_trailing_slash(const char** dirname, region_type* region)
{
	int l = strlen(*dirname);
	if (l>0 && (*dirname)[l-1] != '/' && l < 0xffffff) {
		char *dirname_slash = region_alloc(region, l+2);
		memcpy(dirname_slash, *dirname, l+1);
		strlcat(dirname_slash, "/", l+2);
		*dirname = dirname_slash;
	}
}

static int
file_inside_chroot(const char* fname, const char* chr)
{
	/* true if filename starts with chroot or is not absolute */
	return ((fname && fname[0] && strncmp(fname, chr, strlen(chr)) == 0) ||
		(fname && fname[0] != '/'));
}

static int
additional_checks(nsd_options_type* opt, const char* filename)
{
	zone_options_type* zone;
	int errors = 0;

	RBTREE_FOR(zone, zone_options_type*, opt->zone_options)
	{
		const dname_type* dname = dname_parse(opt->region, zone->name); /* memory leak. */
		if(!dname) {
			fprintf(stderr, "%s: cannot parse zone name syntax for zone %s.\n", filename, zone->name);
			errors ++;
		}
#ifndef ROOT_SERVER
		/* Is it a root zone? Are we a root server then? Idiot proof. */
		if(dname->label_count == 1) {
			fprintf(stderr, "%s: not configured as a root server.\n", filename);
			errors ++;
		}
#endif
		if(zone->pattern->allow_notify && !zone->pattern->request_xfr) {
			fprintf(stderr, "%s: zone %s has allow-notify but no request-xfr"
				" items. Where can it get a zone transfer when a notify "
				"is received?\n", filename, zone->name);
			errors ++;
		}
		if(!zone_is_slave(zone) && (!zone->pattern->zonefile ||
			zone->pattern->zonefile[0] == 0)) {
			fprintf(stderr, "%s: zone %s is a master zone but has "
				"no zonefile. Where can the data come from?\n",
				filename, zone->name);
			errors ++;
		}
	}

#ifndef BIND8_STATS
	if(opt->statistics > 0)
	{
		fprintf(stderr, "%s: 'statistics: %d' but BIND 8 statistics feature not enabled.\n",
			filename, opt->statistics);
		errors ++;
	}
#endif
#ifndef HAVE_CHROOT
	if(opt->chroot != 0)
	{
		fprintf(stderr, "%s: chroot %s given. chroot not supported on this platform.\n",
			filename, opt->chroot);
		errors ++;
	}
#endif
	if (opt->identity && strlen(opt->identity) > UCHAR_MAX) {
                fprintf(stderr, "%s: server identity too long (%u characters)\n",
                      filename, (unsigned) strlen(opt->identity));
		errors ++;
        }
	if (opt->version && strlen(opt->version) > UCHAR_MAX) {
                fprintf(stderr, "%s: server version too long (%u characters)\n",
                      filename, (unsigned) strlen(opt->version));
		errors ++;
        }

	/* not done here: parsing of ip-address. parsing of username. */

        if (opt->chroot && opt->chroot[0]) {
		/* append trailing slash for strncmp checking */
		append_trailing_slash(&opt->chroot, opt->region);
		append_trailing_slash(&opt->xfrdir, opt->region);
		append_trailing_slash(&opt->zonesdir, opt->region);

		/* zonesdir must be absolute and within chroot,
		 * all other pathnames may be relative to zonesdir */
		if (strncmp(opt->zonesdir, opt->chroot, strlen(opt->chroot)) != 0) {
			fprintf(stderr, "%s: zonesdir %s has to be an absolute path that starts with the chroot path %s\n",
				filename, opt->zonesdir, opt->chroot);
			errors ++;
                }
		if (!file_inside_chroot(opt->pidfile, opt->chroot)) {
			fprintf(stderr, "%s: pidfile %s is not relative to chroot %s.\n",
				filename, opt->pidfile, opt->chroot);
			errors ++;
                }
		if (!file_inside_chroot(opt->database, opt->chroot)) {
			fprintf(stderr, "%s: database %s is not relative to chroot %s.\n",
				filename, opt->database, opt->chroot);
			errors ++;
                }
		if (!file_inside_chroot(opt->xfrdfile, opt->chroot)) {
			fprintf(stderr, "%s: xfrdfile %s is not relative to chroot %s.\n",
				filename, opt->xfrdfile, opt->chroot);
			errors ++;
                }
		if (!file_inside_chroot(opt->zonelistfile, opt->chroot)) {
			fprintf(stderr, "%s: zonelistfile %s is not relative to chroot %s.\n",
				filename, opt->zonelistfile, opt->chroot);
			errors ++;
                }
		if (!file_inside_chroot(opt->xfrdir, opt->chroot)) {
			fprintf(stderr, "%s: xfrdir %s is not relative to chroot %s.\n",
				filename, opt->xfrdir, opt->chroot);
			errors ++;
                }
	}

	if (atoi(opt->port) <= 0) {
		fprintf(stderr, "%s: port number '%s' is not a positive number.\n",
			filename, opt->port);
		errors ++;
	}
	if(errors != 0) {
		fprintf(stderr, "%s: %d semantic errors in %d zones, %d keys.\n",
			filename, errors, (int)nsd_options_num_zones(opt),
			(int)opt->keys->count);
	}

	return (errors == 0);
}

int
main(int argc, char* argv[])
{
	int c;
	int verbose = 0;
	int key_sec = 0;
	int final = 0;
	const char * conf_opt = NULL; /* what option do you want? Can be NULL -> print all */
	const char * conf_zone = NULL; /* what zone are we talking about */
	const char * conf_key = NULL; /* what key is needed */
	const char * conf_pat = NULL; /* what pattern is talked about */
	const char* configfile;
	nsd_options_type *options;

	log_init("nsd-checkconf");

	/* Parse the command line... */
	while ((c = getopt(argc, argv, "vfo:a:p:s:z:")) != -1) {
		switch (c) {
		case 'v':
			verbose = 1;
			verbosity++;
			break;
		case 'o':
			conf_opt = optarg;
			break;
		case 'f':
			final = 1;
			break;
		case 'p':
			conf_pat = optarg;
			break;
		case 'a':
			if (conf_key) {
				fprintf(stderr, "Error: cannot combine -a with -s or other -a.\n");
				exit(1);
			}
			conf_key = optarg;
			break;
		case 's':
			if (conf_key) {
				fprintf(stderr, "Error: cannot combine -s with -a or other -s.\n");
				exit(1);
			}
			conf_key = optarg;
			key_sec = 1;
			break;
		case 'z':
			conf_zone = optarg;
			break;
		default:
			usage();
		};
	}
        argc -= optind;
        argv += optind;
        if (argc == 0 || argc>=2) {
		usage();
	}
	configfile = argv[0];

	/* read config file */
	options = nsd_options_create(region_create(xalloc, free));
	tsig_init(options->region);
	if (!parse_options_file(options, configfile, NULL, NULL) ||
	   !additional_checks(options, configfile)) {
		exit(2);
	}
	if (conf_opt || conf_key) {
		config_print_zone(options, conf_key, key_sec,
			underscore(conf_opt), conf_zone, conf_pat, final);
	} else {
		if (verbose) {
			printf("# Read file %s: %d patterns, %d fixed-zones, "
				"%d keys.\n",
				configfile,
				(int)options->patterns->count,
				(int)nsd_options_num_zones(options),
				(int)options->keys->count);
			config_test_print_server(options);
		}
	}
	return 0;
}
@


1.18
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@d371 1
d510 1
@


1.17
log
@Update to 4.1.13
Testing millert, brad and myself.
OK millert@@
@
text
@d32 1
a32 1
		acl_options_t* acl; 			\
d179 1
a179 1
quotepath(nsd_options_t* opt, int final, const char *f)
d194 1
a194 1
quote_acl(acl_options_t* acl)
d206 1
a206 1
print_acl(const char* varname, acl_options_t* acl)
d254 1
a254 1
print_acl_ips(const char* varname, acl_options_t* acl)
d264 1
a264 1
config_print_zone(nsd_options_t* opt, const char* k, int s, const char *o,
d267 1
a267 1
	ip_address_option_t* ip;
d271 1
a271 1
		key_options_t* key = key_options_find(opt, k);
d289 1
a289 1
		zone_options_t* zone;
d327 1
a327 1
		pattern_options_t* p = pattern_options_find(opt, pat);
d416 2
a417 2
			zone_options_t* zone;
			RBTREE_FOR(zone, zone_options_t*, opt->zone_options)
d422 2
a423 2
			pattern_options_t* p;
			RBTREE_FOR(p, pattern_options_t*, opt->patterns)
d433 1
a433 1
static void print_zone_content_elems(pattern_options_t* pat)
d468 1
a468 1
config_test_print_server(nsd_options_t* opt)
d470 4
a473 4
	ip_address_option_t* ip;
	key_options_t* key;
	zone_options_t* zone;
	pattern_options_t* pat;
d535 1
a535 1
	RBTREE_FOR(key, key_options_t*, opt->keys)
d542 1
a542 1
	RBTREE_FOR(pat, pattern_options_t*, opt->patterns)
d549 1
a549 1
	RBTREE_FOR(zone, zone_options_t*, opt->zone_options)
d581 1
a581 1
additional_checks(nsd_options_t* opt, const char* filename)
d583 1
a583 1
	zone_options_t* zone;
d586 1
a586 1
	RBTREE_FOR(zone, zone_options_t*, opt->zone_options)
d710 1
a710 1
	nsd_options_t *options;
@


1.16
log
@update to 4.1.11
"Working fine here." millert@@
OK dlg, sthen
@
text
@d323 1
d354 1
d442 2
@


1.15
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@d62 6
d315 5
d345 5
d450 11
d589 7
@


1.14
log
@update to NSD 4.1.7, ok florian@@
@
text
@d344 1
d372 2
d448 1
d458 6
a463 4
	printf("\tserver_count: %d\n", opt->server_count);
	printf("\ttcp_count: %d\n", opt->tcp_count);
	printf("\ttcp_query_count: %d\n", opt->tcp_query_count);
	printf("\ttcp_timeout: %d\n", opt->tcp_timeout);
d475 1
a475 1
	printf("\txfrd_reload_timeout: %d\n", opt->xfrd_reload_timeout);
@


1.13
log
@merge
@
text
@d355 1
d451 1
d590 5
@


1.12
log
@merge conflicts
@
text
@d347 1
d444 1
a543 1
	ip_address_option_t* ip = opt->ip_addresses;
a544 1
	int num = 0;
a545 8
	while(ip) {
		num++;
		ip = ip->next;
	}
	if(num > MAX_INTERFACES) {
		fprintf(stderr, "%s: too many interfaces (ip-address:) specified.\n", filename);
		errors ++;
	}
d558 7
@


1.11
log
@merge conflicts
@
text
@d523 1
a523 1
	if (l>0 && (*dirname)[l-1] != '/') {
@


1.10
log
@merge conflicts
@
text
@d44 6
d74 6
d144 1
d173 15
d259 1
a259 1
	const char *z, const char* pat)
d300 1
a300 1
		ZONE_GET_STR(zonefile, o, zone->pattern);
d306 1
d325 1
d331 1
d352 1
a352 1
		SERV_GET_STR(database, o);
d355 2
a356 2
		SERV_GET_STR(logfile, o);
		SERV_GET_STR(pidfile, o);
d359 4
a362 4
		SERV_GET_STR(zonesdir, o);
		SERV_GET_STR(xfrdfile, o);
		SERV_GET_STR(xfrdir, o);
		SERV_GET_STR(zonelistfile, o);
d423 2
d603 1
a603 1
			fprintf(stderr, "%s: zonesdir %s is not relative to chroot %s.\n",
d654 1
d665 1
a665 1
	while ((c = getopt(argc, argv, "vo:a:p:s:z:")) != -1) {
d674 3
d718 1
a718 1
			underscore(conf_opt), conf_zone, conf_pat);
@


1.9
log
@merge conflicts
@
text
@d318 2
d351 1
d433 2
d449 1
@


1.8
log
@merge NSD 3.2.16
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
d24 1
a24 1
#define ZONE_GET_ACL(NAME, VAR) 		\
d26 1
a26 1
		quote_acl((zone->NAME)); 	\
d30 1
a30 1
#define ZONE_GET_OUTGOING(NAME, VAR)			\
d33 1
a33 1
		for(acl=zone->NAME; acl; acl=acl->next)	\
d38 1
a38 1
#define ZONE_GET_STR(NAME, VAR) 		\
d40 1
a40 1
		quote(zone->NAME); 		\
d44 1
a44 1
#define ZONE_GET_BIN(NAME, VAR) 			\
d46 2
a47 1
		printf("%s\n", zone->NAME?"yes":"no"); 	\
d74 1
a74 1
#define SERV_GET_IP(NAME, VAR) 				\
d76 1
a76 1
		for(ip = opt->ip_addresses; ip; ip=ip->next)	\
d133 1
d184 1
a184 1
		if(1) {
d230 2
a231 1
config_print_zone(nsd_options_t* opt, const char* k, int s, const char *o, const char *z)
a232 1
	zone_options_t* zone;
d237 6
a242 9
		key_options_t* key = opt->keys;
		for( ; key ; key=key->next) {
			if(strcmp(key->name, k) == 0) {
				if (s) {
					quote(key->secret);
				} else {
					quote(key->algorithm);
				}
				return;
d244 1
d255 1
d261 19
a279 14
		/* look per zone */
		RBTREE_FOR(zone, zone_options_t*, opt->zone_options)
		{
			if (dname_compare(dname, zone->node.key) == 0) {
				/* -z matches, return are in the defines */
				ZONE_GET_STR(name, o);
				ZONE_GET_STR(zonefile, o);
				ZONE_GET_ACL(request_xfr, o);
				ZONE_GET_ACL(provide_xfr, o);
				ZONE_GET_ACL(allow_notify, o);
				ZONE_GET_ACL(notify, o);
				ZONE_GET_BIN(notify_retry, o);
				ZONE_GET_OUTGOING(outgoing_interface, o);
				ZONE_GET_BIN(allow_axfr_fallback, o);
d281 1
a281 1
				ZONE_GET_RRL(rrl_whitelist, o, zone);
d283 11
a293 3
				printf("Zone option not handled: %s %s\n", z, o);
				exit(1);
			}
d295 12
a306 1
		printf("Zone does not exist: %s\n", z);
d310 1
a310 1
		SERV_GET_IP(ip_address, o);
d314 2
a315 2
		SERV_GET_BIN(ip4_only, o);
		SERV_GET_BIN(ip6_only, o);
d317 1
a326 1
		SERV_GET_STR(difffile, o);
d328 2
a330 3
#if defined(BIND8_STATS) && defined(USE_ZONE_STATS)
		SERV_GET_STR(zonestatsfile, o);
#endif
d349 8
d359 1
d364 6
d375 20
d401 1
d407 2
a408 2
	printf("\tip4-only: %s\n", opt->ip4_only?"yes":"no");
	printf("\tip6-only: %s\n", opt->ip6_only?"yes":"no");
a422 3
#if defined(BIND8_STATS) && defined(USE_ZONE_STATS)
	printf("\tzone-stats-file: %s\n", opt->zonestatsfile);
#endif
a425 1
	print_string_var("difffile:", opt->difffile);
d427 2
d431 4
d443 1
d445 11
a455 5
	for(ip = opt->ip_addresses; ip; ip=ip->next)
	{
		print_string_var("ip-address:", ip->address);
	}
	for(key = opt->keys; key; key=key->next)
d462 7
d471 2
d475 14
a488 11
		print_string_var("zonefile:", zone->zonefile);
#ifdef RATELIMIT
		zone_print_rrl_whitelist("\trrl-whitelist: ", zone->rrl_whitelist);
#endif
		print_acl("allow-notify:", zone->allow_notify);
		print_acl("request-xfr:", zone->request_xfr);
		printf("\tnotify-retry: %d\n", zone->notify_retry);
		print_acl("notify:", zone->notify);
		print_acl("provide-xfr:", zone->provide_xfr);
		print_acl_ips("outgoing-interface:", zone->outgoing_interface);
		printf("\tallow-axfr-fallback: %s\n", zone->allow_axfr_fallback?"yes":"no");
d490 1
d492 6
a504 1
	key_options_t* key;
d523 1
a523 1
		if(zone->allow_notify && !zone->request_xfr) {
a530 23
	for(key = opt->keys; key; key=key->next)
	{
		const dname_type* dname = dname_parse(opt->region, key->name); /* memory leak. */
		uint8_t data[4000];
		int size;

		if(!dname) {
			fprintf(stderr, "%s: cannot parse tsig name syntax for key %s.\n", filename, key->name);
			errors ++;
		}
		size = b64_pton(key->secret, data, sizeof(data));
		if(size == -1) {
			fprintf(stderr, "%s: cannot base64 decode tsig secret: for key %s.\n", filename, key->name);
			errors ++;
		}
		if(tsig_get_algorithm_by_name(key->algorithm) == NULL)
		{
			fprintf(stderr, "%s: bad tsig algorithm %s: for key \
%s.\n", filename, key->algorithm, key->name);
			errors ++;
		}
	}

a537 8
#  ifndef USE_ZONE_STATS
	if(opt->zonestatsfile)
	{
		fprintf(stderr, "%s: 'zone-stats-file: %s' but per zone BIND 8 statistics feature not enabled.\n",
			filename, opt->zonestatsfile);
		errors ++;
	}
#  endif
a538 1

d555 14
a568 4
        if (opt->chroot) {
                int l = strlen(opt->chroot);

                if (strncmp(opt->chroot, opt->pidfile, l) != 0) {
d573 2
a574 2
		if (strncmp(opt->chroot, opt->database, l) != 0) {
			fprintf(stderr, "%s: databasefile %s is not relative to chroot %s.\n",
d578 8
a585 3
		if (strncmp(opt->chroot, opt->difffile, l) != 0) {
			fprintf(stderr, "%s: difffile %s is not relative to chroot %s.\n",
				filename, opt->difffile, opt->chroot);
d588 3
a590 3
		if (strncmp(opt->chroot, opt->xfrdfile, l) != 0) {
			fprintf(stderr, "%s: xfrdfile %s is not relative to chroot %s.\n",
				filename, opt->xfrdfile, opt->chroot);
d593 2
a594 1
        }
d603 1
a603 1
			(int)opt->numkeys);
d618 1
d625 1
a625 1
	while ((c = getopt(argc, argv, "vo:a:s:z:")) != -1) {
d629 1
d634 3
d669 1
a669 1
	if (!parse_options_file(options, configfile) ||
d674 2
a675 1
		config_print_zone(options, conf_key, key_sec, underscore(conf_opt), conf_zone);
d678 2
a679 1
			printf("# Read file %s: %d zones, %d keys.\n",
d681 1
d683 1
a683 1
				(int)options->numkeys);
@


1.7
log
@resolve conflicts
@
text
@d58 1
d287 1
d320 3
d346 1
d376 3
d552 2
a553 3

        /* Parse the command line... */
        while ((c = getopt(argc, argv, "vo:a:s:z:")) != -1) {
@


1.6
log
@resolve conflicts
@
text
@d9 1
a9 1
#include <config.h>
d19 1
d49 6
d81 15
d273 3
d315 5
d367 5
d389 3
@


1.5
log
@resolve conflicts
@
text
@d277 3
d327 3
d427 8
d436 1
@


1.4
log
@resolve conflicts and regen configure using autoconf-2.65
@
text
@d406 1
a406 1
		if(tsig_get_algorithm_by_name(key->algorithm) != NULL)
d531 1
@


1.3
log
@upgrade to NSD 3.2.7; ok sthen@@, tested by multiple people
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d29 8
d194 9
d249 1
a249 1
				ZONE_GET_ACL(outgoing_interface, o);
d353 1
a353 1
		print_acl("outgoing-interface:", zone->outgoing_interface);
@


1.2
log
@fix a overflow found by parfait
ok jakob@@
@
text
@d102 1
d188 1
a188 1
config_print_zone(nsd_options_t* opt, const char* k, const char *o, const char *z)
d198 5
a202 1
				quote(key->secret);
d464 1
d471 3
d475 1
a475 1
        while ((c = getopt(argc, argv, "vo:s:z:")) != -1) {
d483 7
d491 4
d496 1
d519 1
a519 1
		config_print_zone(options, conf_key, underscore(conf_opt), conf_zone);
@


1.1
log
@Initial revision
@
text
@d80 1
a80 1
		if (i > BUFSIZ) {
d246 1
d291 1
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.5
@
text
@a245 1
		SERV_GET_STR(nsid, o);
a289 1
	print_string_var("nsid:", opt->nsid);
@


1.1.1.3
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
a28 8
#define ZONE_GET_OUTGOING(NAME, VAR)			\
	if (strcasecmp(#NAME, (VAR)) == 0) {		\
		acl_options_t* acl; 			\
		for(acl=zone->NAME; acl; acl=acl->next)	\
			quote(acl->ip_address_spec);	\
		return; 				\
	}

d80 1
a80 1
		if (i >= BUFSIZ) {
a101 1
	fprintf(stderr, "-a keyname	Print algorithm name for the TSIG key.\n");
a184 9
static void
print_acl_ips(const char* varname, acl_options_t* acl)
{
	while(acl)
	{
		printf("\t%s %s\n", varname, acl->ip_address_spec);
		acl=acl->next;
	}
}
d187 1
a187 1
config_print_zone(nsd_options_t* opt, const char* k, int s, const char *o, const char *z)
d197 1
a197 5
				if (s) {
					quote(key->secret);
				} else {
					quote(key->algorithm);
				}
d227 1
a227 1
				ZONE_GET_OUTGOING(outgoing_interface, o);
d331 1
a331 1
		print_acl_ips("outgoing-interface:", zone->outgoing_interface);
a458 1
	int key_sec = 0;
a464 3
	log_init("nsd-checkconf");


d466 1
a466 1
        while ((c = getopt(argc, argv, "vo:a:s:z:")) != -1) {
a473 7
		case 'a':
			if (conf_key) {
				fprintf(stderr, "Error: cannot combine -a with -s or other -a.\n");
				exit(1);
			}
			conf_key = optarg;
			break;
a474 4
			if (conf_key) {
				fprintf(stderr, "Error: cannot combine -s with -a or other -s.\n");
				exit(1);
			}
a475 1
			key_sec = 1;
d498 1
a498 1
		config_print_zone(options, conf_key, key_sec, underscore(conf_opt), conf_zone);
@


1.1.1.4
log
@NSD v3.2.9
@
text
@d406 1
a406 1
		if(tsig_get_algorithm_by_name(key->algorithm) == NULL)
a530 1
	tsig_init(options->region);
@


1.1.1.5
log
@NSD v3.2.11, ok phessler@@
@
text
@a276 3
#if defined(BIND8_STATS) && defined(USE_ZONE_STATS)
		SERV_GET_STR(zonestatsfile, o);
#endif
a323 3
#if defined(BIND8_STATS) && defined(USE_ZONE_STATS)
	printf("\tzone-stats-file: %s\n", opt->zonestatsfile);
#endif
a420 8
#  ifndef USE_ZONE_STATS
	if(opt->zonestatsfile)
	{
		fprintf(stderr, "%s: 'zone-stats-file: %s' but per zone BIND 8 statistics feature not enabled.\n",
			filename, opt->zonestatsfile);
		errors ++;
	}
#  endif
a421 1

@


1.1.1.6
log
@Update to NSD 3.2.15, ok brad@@ phessler@@ deraadt@@ also tested by okan@@
@
text
@d9 1
a9 1
#include "config.h"
a18 1
#include "rrl.h"
a47 6
#define ZONE_GET_RRL(NAME, VAR, PATTERN) 			\
	if (strcasecmp(#NAME, (VAR)) == 0) { 		\
		zone_print_rrl_whitelist("", PATTERN->NAME);	\
		return;					\
	}

a73 15
#ifdef RATELIMIT
static void zone_print_rrl_whitelist(const char* s, uint16_t w)
{
	int i;
	if(w==rrl_type_all) {
		printf("%sall\n", s);
		return;
	}
	for(i=0x01; i <= 0x80; i<<=1) {
		if( (w&i) )
			printf("%s%s\n", s, rrltype2str(i));
	}
}
#endif /* RATELIMIT */

a250 3
#ifdef RATELIMIT
				ZONE_GET_RRL(rrl_whitelist, o, zone);
#endif
a289 5
#ifdef RATELIMIT
		SERV_GET_INT(rrl_size, o);
		SERV_GET_INT(rrl_ratelimit, o);
		SERV_GET_INT(rrl_whitelist_ratelimit, o);
#endif
a336 5
#ifdef RATELIMIT
	printf("\trrl-size: %d\n", (int)opt->rrl_size);
	printf("\trrl-ratelimit: %d\n", (int)opt->rrl_ratelimit);
	printf("\trrl-whitelist-ratelimit: %d\n", (int)opt->rrl_whitelist_ratelimit);
#endif
a353 3
#ifdef RATELIMIT
		zone_print_rrl_whitelist("\trrl-whitelist: ", zone->rrl_whitelist);
#endif
@


1.1.1.7
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@a57 1
		return;					\
a285 1
		SERV_GET_BIN(ip_transparent, o);
a317 3
		SERV_GET_INT(rrl_slip, o);
		SERV_GET_INT(rrl_ipv4_prefix_length, o);
		SERV_GET_INT(rrl_ipv6_prefix_length, o);
a340 1
	printf("\tip-transparent: %s\n", opt->ip_transparent?"yes":"no");
a369 3
	printf("\trrl-slip: %d\n", (int)opt->rrl_slip);
	printf("\trrl-ipv4-prefix-length: %d\n", (int)opt->rrl_ipv4_prefix_length);
	printf("\trrl-ipv6-prefix-length: %d\n", (int)opt->rrl_ipv6_prefix_length);
d543 3
a545 2
	/* Parse the command line... */
	while ((c = getopt(argc, argv, "vo:a:s:z:")) != -1) {
@


1.1.1.8
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d24 1
a24 1
#define ZONE_GET_ACL(NAME, VAR, PATTERN) 		\
d26 1
a26 1
		quote_acl(PATTERN->NAME); 	\
d30 1
a30 1
#define ZONE_GET_OUTGOING(NAME, VAR, PATTERN)			\
d33 1
a33 1
		for(acl=PATTERN->NAME; acl; acl=acl->next)	\
d38 1
a38 1
#define ZONE_GET_STR(NAME, VAR, PATTERN) 		\
d40 1
a40 1
		quote(PATTERN->NAME); 		\
d44 1
a44 1
#define ZONE_GET_BIN(NAME, VAR, PATTERN) 			\
d46 1
a46 2
		printf("%s\n", (PATTERN->NAME)?"yes":"no"); 	\
		return;					\
d73 1
a73 1
#define SERV_GET_IP(NAME, MEMBER, VAR) 				\
d75 1
a75 1
		for(ip = opt->MEMBER; ip; ip=ip->next)	\
a131 1
	fprintf(stderr, "-p pattern	Print option value for the pattern given.\n");
d182 1
a182 1
		if(verbosity>1) {
d228 1
a228 2
config_print_zone(nsd_options_t* opt, const char* k, int s, const char *o,
	const char *z, const char* pat)
d230 1
d235 9
a243 6
		key_options_t* key = key_options_find(opt, k);
		if(key) {
			if (s) {
				quote(key->secret);
			} else {
				quote(key->algorithm);
a244 1
			return;
a254 1
		zone_options_t* zone;
d260 14
a273 19
		zone = zone_options_find(opt, dname);
		if(!zone) {
			printf("Zone does not exist: %s\n", z);
			exit(1);
		}
		ZONE_GET_STR(name, o, zone);
		if(strcasecmp("pattern", o)==0) {
			quote(zone->pattern->pname);
			return;
		}
		ZONE_GET_BIN(part_of_config, o, zone);
		ZONE_GET_STR(zonefile, o, zone->pattern);
		ZONE_GET_ACL(request_xfr, o, zone->pattern);
		ZONE_GET_ACL(provide_xfr, o, zone->pattern);
		ZONE_GET_ACL(allow_notify, o, zone->pattern);
		ZONE_GET_ACL(notify, o, zone->pattern);
		ZONE_GET_BIN(notify_retry, o, zone->pattern);
		ZONE_GET_OUTGOING(outgoing_interface, o, zone->pattern);
		ZONE_GET_BIN(allow_axfr_fallback, o, zone->pattern);
d275 1
a275 1
		ZONE_GET_RRL(rrl_whitelist, o, zone->pattern);
d277 3
a279 11
		printf("Zone option not handled: %s %s\n", z, o);
		exit(1);
	} else if(pat) {
		pattern_options_t* p = pattern_options_find(opt, pat);
		if(!p) {
			printf("Pattern does not exist: %s\n", pat);
			exit(1);
		}
		if(strcasecmp("name", o)==0) {
			quote(p->pname);
			return;
d281 1
a281 12
		ZONE_GET_STR(zonefile, o, p);
		ZONE_GET_ACL(request_xfr, o, p);
		ZONE_GET_ACL(provide_xfr, o, p);
		ZONE_GET_ACL(allow_notify, o, p);
		ZONE_GET_ACL(notify, o, p);
		ZONE_GET_BIN(notify_retry, o, p);
		ZONE_GET_OUTGOING(outgoing_interface, o, p);
		ZONE_GET_BIN(allow_axfr_fallback, o, p);
#ifdef RATELIMIT
		ZONE_GET_RRL(rrl_whitelist, o, p);
#endif
		printf("Pattern option not handled: %s %s\n", pat, o);
d285 1
a285 1
		SERV_GET_IP(ip_address, ip_addresses, o);
d289 2
a290 2
		SERV_GET_BIN(do_ip4, o);
		SERV_GET_BIN(do_ip6, o);
a291 1
		SERV_GET_BIN(zonefiles_check, o);
d301 1
a302 2
		SERV_GET_STR(xfrdir, o);
		SERV_GET_STR(zonelistfile, o);
d304 3
a324 8
		/* remote control */
		SERV_GET_BIN(control_enable, o);
		SERV_GET_IP(control_interface, control_interface, o);
		SERV_GET_INT(control_port, o);
		SERV_GET_STR(server_key_file, o);
		SERV_GET_STR(server_cert_file, o);
		SERV_GET_STR(control_key_file, o);
		SERV_GET_STR(control_cert_file, o);
a326 1
			zone_options_t* zone;
a330 6
		if(strcasecmp(o, "patterns") == 0) {
			pattern_options_t* p;
			RBTREE_FOR(p, pattern_options_t*, opt->patterns)
				quote(p->pname);
			return;
		}
a335 20
/* print zone content items */
static void print_zone_content_elems(pattern_options_t* pat)
{
	if(pat->zonefile)
		print_string_var("zonefile:", pat->zonefile);
#ifdef RATELIMIT
	zone_print_rrl_whitelist("\trrl-whitelist: ", pat->rrl_whitelist);
#endif
	print_acl("allow-notify:", pat->allow_notify);
	print_acl("request-xfr:", pat->request_xfr);
	if(!pat->notify_retry_is_default)
		printf("\tnotify-retry: %d\n", pat->notify_retry);
	print_acl("notify:", pat->notify);
	print_acl("provide-xfr:", pat->provide_xfr);
	print_acl_ips("outgoing-interface:", pat->outgoing_interface);
	if(!pat->allow_axfr_fallback_is_default)
		printf("\tallow-axfr-fallback: %s\n",
			pat->allow_axfr_fallback?"yes":"no");
}

a341 1
	pattern_options_t* pat;
d347 2
a348 2
	printf("\tdo-ip4: %s\n", opt->do_ip4?"yes":"no");
	printf("\tdo-ip6: %s\n", opt->do_ip6?"yes":"no");
d363 3
d369 1
a370 2
	print_string_var("zonelistfile:", opt->zonelistfile);
	print_string_var("xfrdir:", opt->xfrdir);
a372 4
	for(ip = opt->ip_addresses; ip; ip=ip->next)
	{
		print_string_var("ip-address:", ip->address);
	}
a380 1
	printf("\tzonefiles-check: %s\n", opt->zonefiles_check?"yes":"no");
d382 5
a386 11
	printf("\nremote-control:\n");
	printf("\tcontrol-enable: %s\n", opt->control_enable?"yes":"no");
	for(ip = opt->control_interface; ip; ip=ip->next)
		print_string_var("control-interface:", ip->address);
	printf("\tcontrol-port: %d\n", opt->control_port);
	print_string_var("server-key-file:", opt->server_key_file);
	print_string_var("server-cert-file:", opt->server_cert_file);
	print_string_var("control-key-file:", opt->control_key_file);
	print_string_var("control-cert-file:", opt->control_cert_file);

	RBTREE_FOR(key, key_options_t*, opt->keys)
a392 7
	RBTREE_FOR(pat, pattern_options_t*, opt->patterns)
	{
		if(pat->implicit) continue;
		printf("\npattern:\n");
		print_string_var("name:", pat->pname);
		print_zone_content_elems(pat);
	}
a394 2
		if(!zone->part_of_config)
			continue;
d397 11
a407 1
		print_zone_content_elems(zone->pattern);
a411 20
static void
append_trailing_slash(const char** dirname, region_type* region)
{
	int l = strlen(*dirname);
	if (l>0 && (*dirname)[l-1] != '/') {
		char *dirname_slash = region_alloc(region, l+2);
		memcpy(dirname_slash, *dirname, l+1);
		strlcat(dirname_slash, "/", l+2);
		*dirname = dirname_slash;
	}
}

static int
file_inside_chroot(const char* fname, const char* chr)
{
	/* true if filename starts with chroot or is not absolute */
	return ((fname && fname[0] && strncmp(fname, chr, strlen(chr)) == 0) ||
		(fname && fname[0] != '/'));
}

d417 1
d436 1
a436 1
		if(zone->pattern->allow_notify && !zone->pattern->request_xfr) {
d444 23
d474 8
d483 1
d500 4
a503 14
        if (opt->chroot && opt->chroot[0]) {
		/* append trailing slash for strncmp checking */
		append_trailing_slash(&opt->chroot, opt->region);
		append_trailing_slash(&opt->xfrdir, opt->region);
		append_trailing_slash(&opt->zonesdir, opt->region);

		/* zonesdir must be absolute and within chroot,
		 * all other pathnames may be relative to zonesdir */
		if (strncmp(opt->zonesdir, opt->chroot, strlen(opt->chroot)) != 0) {
			fprintf(stderr, "%s: zonesdir %s is not relative to chroot %s.\n",
				filename, opt->zonesdir, opt->chroot);
			errors ++;
                }
		if (!file_inside_chroot(opt->pidfile, opt->chroot)) {
d508 2
a509 2
		if (!file_inside_chroot(opt->database, opt->chroot)) {
			fprintf(stderr, "%s: database %s is not relative to chroot %s.\n",
d513 6
a518 1
		if (!file_inside_chroot(opt->xfrdfile, opt->chroot)) {
d523 1
a523 12
		if (!file_inside_chroot(opt->zonelistfile, opt->chroot)) {
			fprintf(stderr, "%s: zonelistfile %s is not relative to chroot %s.\n",
				filename, opt->zonelistfile, opt->chroot);
			errors ++;
                }
		if (!file_inside_chroot(opt->xfrdir, opt->chroot)) {
			fprintf(stderr, "%s: xfrdir %s is not relative to chroot %s.\n",
				filename, opt->xfrdir, opt->chroot);
			errors ++;
                }
	}

d532 1
a532 1
			(int)opt->keys->count);
a546 1
	const char * conf_pat = NULL; /* what pattern is talked about */
d553 1
a553 1
	while ((c = getopt(argc, argv, "vo:a:p:s:z:")) != -1) {
a556 1
			verbosity++;
a560 3
		case 'p':
			conf_pat = optarg;
			break;
d593 1
a593 1
	if (!parse_options_file(options, configfile, NULL, NULL) ||
d598 1
a598 2
		config_print_zone(options, conf_key, key_sec,
			underscore(conf_opt), conf_zone, conf_pat);
d601 1
a601 2
			printf("# Read file %s: %d patterns, %d fixed-zones, "
				"%d keys.\n",
a602 1
				(int)options->patterns->count,
d604 1
a604 1
				(int)options->keys->count);
@


1.1.1.9
log
@update to NSD 4.1.0, ok sthen@@
@
text
@a317 2
		SERV_GET_BIN(log_time_ascii, o);
		SERV_GET_BIN(round_robin, o);
a348 1
		SERV_GET_INT(zonefiles_write, o);
a429 2
	printf("\tlog-time-ascii: %s\n", opt->log_time_ascii?"yes":"no");
	printf("\tround-robin: %s\n", opt->round_robin?"yes":"no");
a443 1
	printf("\tzonefiles-write: %d\n", opt->zonefiles_write);
@


1.1.1.10
log
@update to NSD 4.1.1, ok sthen@@
@
text
@a43 6
#define ZONE_GET_PATH(FINAL, NAME, VAR, PATTERN) 	\
	if (strcasecmp(#NAME, (VAR)) == 0) { 		\
		quotepath(opt, FINAL, PATTERN->NAME); 	\
		return; 				\
	}

a67 6
#define SERV_GET_PATH(FINAL, NAME, VAR) 	\
	if (strcasecmp(#NAME, (VAR)) == 0) { 	\
		quotepath(opt, FINAL, opt->NAME); 	\
		return; 			\
	}

a131 1
	fprintf(stderr, "-f		Use with -o to print final pathnames, ie. with chroot.\n");
a159 15
quotepath(nsd_options_t* opt, int final, const char *f)
{
	const char* chr = opt->chroot;
#ifdef CHROOTDIR
	if(chr == 0) chr = CHROOTDIR;
#endif
	if(f == 0 || f[0] == '/' || !final || !chr || chr[0]==0) {
		quote(f);
		return;
	}
	/* chroot has had trailing slash applied in check part of checkconf */
	printf("%s%s\n", chr, f);
}

static void
d231 1
a231 1
	const char *z, const char* pat, int final)
d272 1
a272 1
		ZONE_GET_PATH(final, zonefile, o, zone->pattern);
a277 1
		ZONE_GET_STR(zonestats, o, zone->pattern);
a295 1
		ZONE_GET_PATH(final, zonefile, o, p);
a300 1
		ZONE_GET_STR(zonestats, o, p);
d321 1
a321 1
		SERV_GET_PATH(final, database, o);
d324 2
a325 2
		SERV_GET_PATH(final, logfile, o);
		SERV_GET_PATH(final, pidfile, o);
d328 4
a331 4
		SERV_GET_PATH(final, zonesdir, o);
		SERV_GET_PATH(final, xfrdfile, o);
		SERV_GET_PATH(final, xfrdir, o);
		SERV_GET_PATH(final, zonelistfile, o);
a391 2
	if(pat->zonestats)
		print_string_var("zonestats:", pat->zonestats);
d570 1
a570 1
			fprintf(stderr, "%s: zonesdir %s has to be an absolute path that starts with the chroot path %s\n",
a620 1
	int final = 0;
d631 1
a631 1
	while ((c = getopt(argc, argv, "vfo:a:p:s:z:")) != -1) {
a639 3
		case 'f':
			final = 1;
			break;
d681 1
a681 1
			underscore(conf_opt), conf_zone, conf_pat, final);
@


1.1.1.11
log
@update to NSD 4.1.3, ok florian@@, also tested by brad
@
text
@d523 1
a523 1
	if (l>0 && (*dirname)[l-1] != '/' && l < 0xffffff) {
@


1.1.1.12
log
@update to NSD 4.1.6, ok millert@@ florian@@
@
text
@a346 1
		SERV_GET_BIN(reuseport, o);
a442 1
	printf("\treuseport: %s\n", opt->reuseport?"yes":"no");
d542 1
d544 1
d546 8
a565 7
			errors ++;
		}
		if(!zone_is_slave(zone) && (!zone->pattern->zonefile ||
			zone->pattern->zonefile[0] == 0)) {
			fprintf(stderr, "%s: zone %s is a master zone but has "
				"no zonefile. Where can the data come from?\n",
				filename, zone->name);
@


