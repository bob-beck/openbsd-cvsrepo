head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.2
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	NSD_4_1_6:1.1.1.16
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	NSD_4_1_3:1.1.1.15
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	NSD_4_1_1:1.1.1.14
	NSD_4_1_0:1.1.1.13
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	NSD_4_0_3:1.1.1.12
	NSD_4_0_2:1.1.1.12
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	NSD_4_0_1:1.1.1.12
	NSD_4_0_0:1.1.1.11
	NSD_3_2_16:1.1.1.10
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	NSD_3_2_15:1.1.1.9
	NSD_3_2_14:1.1.1.8
	NSD_3_2_13:1.1.1.7
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	NSD_3_2_11:1.1.1.7
	NSD_3_2_10:1.1.1.6
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	NSD_3_2_9:1.1.1.5
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	NSD_3_2_8:1.1.1.4
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	NSD_3_2_6:1.1.1.3
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	NSD_3_2_5:1.1.1.2
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.27;
commitid	WmSuN5M3Jbe54113;

1.27
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.26;
commitid	Z9jVKJJMPmC3zw2t;

1.26
date	2015.12.12.16.06.43;	author sthen;	state Exp;
branches;
next	1.25;
commitid	aGDFhqDRbaLemAyH;

1.25
date	2015.12.11.12.28.49;	author sthen;	state Exp;
branches;
next	1.24;
commitid	e67Hx722TeF4XpDl;

1.24
date	2015.11.21.21.12.46;	author florian;	state Exp;
branches;
next	1.23;
commitid	bnZGtyogtzopELoz;

1.23
date	2015.11.05.21.21.59;	author sthen;	state Exp;
branches;
next	1.22;
commitid	EVDZ1z8bzmTorwSZ;

1.22
date	2015.07.17.17.36.33;	author sthen;	state Exp;
branches;
next	1.21;
commitid	2WtkENMkCz3GhSbE;

1.21
date	2015.02.03.10.40.02;	author brad;	state Exp;
branches;
next	1.20;
commitid	MI9j0d0LR8Dk9lnd;

1.20
date	2015.01.12.14.36.48;	author millert;	state Exp;
branches;
next	1.19;
commitid	CE66UGc2yuwK21ce;

1.19
date	2014.09.16.17.01.38;	author brad;	state Exp;
branches;
next	1.18;
commitid	5uD1zN2z8VskC3BN;

1.18
date	2014.02.04.03.07.25;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2013.11.26.12.53.58;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2013.09.04.12.24.35;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2013.09.03.09.26.54;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2013.02.18.10.18.39;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2012.11.23.20.30.26;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2012.07.09.21.56.41;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2012.03.02.08.40.57;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2012.01.29.11.23.24;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.21.18.29.56;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	2011.02.21.20.40.04;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2010.08.22.09.24.28;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.15.21.14.56;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.24.14.03.31;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.24.07.36.03;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.17.20.44.59;	author chl;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.17.19.32.40;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.15.19.24.58;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.58;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.04.15.20.57.13;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.08.22.09.21.42;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.05.21.18.17.24;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.01.29.11.15.41;	author jakob;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.03.02.08.38.56;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2012.07.09.21.55.08;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2012.11.23.20.29.16;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.02.18.10.17.43;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.09.03.09.21.36;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.11.26.12.50.14;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.02.04.01.54.02;	author brad;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.09.16.16.54.00;	author brad;	state Exp;
branches;
next	1.1.1.14;
commitid	BWSdZeElrpYSRdME;

1.1.1.14
date	2015.02.03.10.24.29;	author brad;	state Exp;
branches;
next	1.1.1.15;
commitid	yn8l9RVkmdMVYIfl;

1.1.1.15
date	2015.07.17.17.36.01;	author sthen;	state Exp;
branches;
next	1.1.1.16;
commitid	Jeq5uGP63ff7nS9K;

1.1.1.16
date	2015.11.05.21.21.04;	author sthen;	state Exp;
branches;
next	;
commitid	RXfGmPAh2IZTjnIf;


desc
@@


1.28
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * nsd.c -- nsd(8)
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include "config.h"

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#ifdef HAVE_GRP_H
#include <grp.h>
#endif /* HAVE_GRP_H */
#ifdef HAVE_SETUSERCONTEXT
#include <login_cap.h>
#endif /* HAVE_SETUSERCONTEXT */

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "nsd.h"
#include "options.h"
#include "tsig.h"
#include "remote.h"
#include "xfrd-disk.h"

/* The server handler... */
struct nsd nsd;
static char hostname[MAXHOSTNAMELEN];
extern config_parser_state_type* cfg_parser;

static void error(const char *format, ...) ATTR_FORMAT(printf, 1, 2);

/*
 * Print the help text.
 *
 */
static void
usage (void)
{
	fprintf(stderr, "Usage: nsd [OPTION]...\n");
	fprintf(stderr, "Name Server Daemon.\n\n");
	fprintf(stderr,
		"Supported options:\n"
		"  -4                   Only listen to IPv4 connections.\n"
		"  -6                   Only listen to IPv6 connections.\n"
		"  -a ip-address[@@port] Listen to the specified incoming IP address (and port)\n"
		"                       May be specified multiple times).\n"
		"  -c configfile        Read specified configfile instead of %s.\n"
		"  -d                   do not fork as a daemon process.\n"
#ifndef NDEBUG
		"  -F facilities        Specify the debug facilities.\n"
#endif /* NDEBUG */
		"  -f database          Specify the database to load.\n"
		"  -h                   Print this help information.\n"
		, CONFIGFILE);
	fprintf(stderr,
		"  -i identity          Specify the identity when queried for id.server CHAOS TXT.\n"
		"  -I nsid              Specify the NSID. This must be a hex string.\n"
#ifndef NDEBUG
		"  -L level             Specify the debug level.\n"
#endif /* NDEBUG */
		"  -l filename          Specify the log file.\n"
		"  -N server-count      The number of servers to start.\n"
		"  -n tcp-count         The maximum number of TCP connections per server.\n"
		"  -P pidfile           Specify the PID file to write.\n"
		"  -p port              Specify the port to listen to.\n"
		"  -s seconds           Dump statistics every SECONDS seconds.\n"
		"  -t chrootdir         Change root to specified directory on startup.\n"
		);
	fprintf(stderr,
		"  -u user              Change effective uid to the specified user.\n"
		"  -V level             Specify verbosity level.\n"
		"  -v                   Print version information.\n"
		);
	fprintf(stderr, "Version %s. Report bugs to <%s>.\n",
		PACKAGE_VERSION, PACKAGE_BUGREPORT);
}

/*
 * Print the version exit.
 *
 */
static void
version(void)
{
	fprintf(stderr, "%s version %s\n", PACKAGE_NAME, PACKAGE_VERSION);
	fprintf(stderr, "Written by NLnet Labs.\n\n");
	fprintf(stderr,
		"Copyright (C) 2001-2006 NLnet Labs.  This is free software.\n"
		"There is NO warranty; not even for MERCHANTABILITY or FITNESS\n"
		"FOR A PARTICULAR PURPOSE.\n");
	exit(0);
}

/*
 * Something went wrong, give error messages and exit.
 *
 */
static void
error(const char *format, ...)
{
	va_list args;
	va_start(args, format);
	log_vmsg(LOG_ERR, format, args);
	va_end(args);
	exit(1);
}

static void
append_trailing_slash(const char** dirname, region_type* region)
{
	int l = strlen(*dirname);
	if (l>0 && (*dirname)[l-1] != '/' && l < 0xffffff) {
		char *dirname_slash = region_alloc(region, l+2);
		memcpy(dirname_slash, *dirname, l+1);
		strlcat(dirname_slash, "/", l+2);
		/* old dirname is leaked, this is only used for chroot, once */
		*dirname = dirname_slash;
	}
}

static int
file_inside_chroot(const char* fname, const char* chr)
{
	/* true if filename starts with chroot or is not absolute */
	return ((fname && fname[0] && strncmp(fname, chr, strlen(chr)) == 0) ||
		(fname && fname[0] != '/'));
}

void
get_ip_port_frm_str(const char* arg, const char** hostname,
        const char** port)
{
        /* parse src[@@port] option */
        char* delim = NULL;
	if (arg) {
		delim = strchr(arg, '@@');
	}

        if (delim) {
                *delim = '\0';
                *port = delim+1;
        }
        *hostname = arg;
}

/* append interface to interface array (names, udp, tcp) */
void
add_interface(char*** nodes, struct nsd* nsd, char* ip)
{
	/* realloc the arrays */
	if(nsd->ifs == 0) {
		*nodes = xalloc_zero(sizeof(*nodes));
		nsd->udp = xalloc_zero(sizeof(*nsd->udp));
		nsd->tcp = xalloc_zero(sizeof(*nsd->udp));
	} else {
		*nodes = xrealloc(*nodes, (nsd->ifs+1)*sizeof(*nodes));
		nsd->udp = xrealloc(nsd->udp, (nsd->ifs+1)*sizeof(*nsd->udp));
		nsd->tcp = xrealloc(nsd->tcp, (nsd->ifs+1)*sizeof(*nsd->udp));
		(*nodes)[nsd->ifs] = NULL;
		memset(&nsd->udp[nsd->ifs], 0, sizeof(*nsd->udp));
		memset(&nsd->tcp[nsd->ifs], 0, sizeof(*nsd->tcp));
	}

	/* add it */
	(*nodes)[nsd->ifs] = ip;
	++nsd->ifs;
}

/*
 * Fetch the nsd parent process id from the nsd pidfile
 *
 */
pid_t
readpid(const char *file)
{
	int fd;
	pid_t pid;
	char pidbuf[16];
	char *t;
	int l;

	if ((fd = open(file, O_RDONLY)) == -1) {
		return -1;
	}

	if (((l = read(fd, pidbuf, sizeof(pidbuf)))) == -1) {
		close(fd);
		return -1;
	}

	close(fd);

	/* Empty pidfile means no pidfile... */
	if (l == 0) {
		errno = ENOENT;
		return -1;
	}

	pid = (pid_t) strtol(pidbuf, &t, 10);

	if (*t && *t != '\n') {
		return -1;
	}
	return pid;
}

/*
 * Store the nsd parent process id in the nsd pidfile
 *
 */
int
writepid(struct nsd *nsd)
{
	FILE * fd;
	char pidbuf[32];

	snprintf(pidbuf, sizeof(pidbuf), "%lu\n", (unsigned long) nsd->pid);

	if ((fd = fopen(nsd->pidfile, "w")) ==  NULL ) {
		log_msg(LOG_ERR, "cannot open pidfile %s: %s",
			nsd->pidfile, strerror(errno));
		return -1;
	}

	if (!write_data(fd, pidbuf, strlen(pidbuf))) {
		log_msg(LOG_ERR, "cannot write pidfile %s: %s",
			nsd->pidfile, strerror(errno));
		fclose(fd);
		return -1;
	}
	fclose(fd);

	if (chown(nsd->pidfile, nsd->uid, nsd->gid) == -1) {
		log_msg(LOG_ERR, "cannot chown %u.%u %s: %s",
			(unsigned) nsd->uid, (unsigned) nsd->gid,
			nsd->pidfile, strerror(errno));
		return -1;
	}

	return 0;
}

void
unlinkpid(const char* file)
{
	int fd = -1;

	if (file) {
		/* truncate pidfile */
		fd = open(file, O_WRONLY | O_TRUNC, 0644);
		if (fd == -1) {
			/* Truncate the pid file.  */
			log_msg(LOG_ERR, "can not truncate the pid file %s: %s", file, strerror(errno));
		} else 
			close(fd);

		/* unlink pidfile */
		if (unlink(file) == -1)
			log_msg(LOG_WARNING, "failed to unlink pidfile %s: %s",
				file, strerror(errno));
	}
}

/*
 * Incoming signals, set appropriate actions.
 *
 */
void
sig_handler(int sig)
{
	/* To avoid race cond. We really don't want to use log_msg() in this handler */

	/* Are we a child server? */
	if (nsd.server_kind != NSD_SERVER_MAIN) {
		switch (sig) {
		case SIGCHLD:
			nsd.signal_hint_child = 1;
			break;
		case SIGALRM:
			break;
		case SIGINT:
		case SIGTERM:
			nsd.signal_hint_quit = 1;
			break;
		case SIGILL:
		case SIGUSR1:	/* Dump stats on SIGUSR1.  */
			nsd.signal_hint_statsusr = 1;
			break;
		default:
			break;
		}
		return;
	}

	/* We are the main process */
	switch (sig) {
	case SIGCHLD:
		nsd.signal_hint_child = 1;
		return;
	case SIGHUP:
		nsd.signal_hint_reload_hup = 1;
		return;
	case SIGALRM:
		nsd.signal_hint_stats = 1;
		break;
	case SIGILL:
		/*
		 * For backwards compatibility with BIND 8 and older
		 * versions of NSD.
		 */
		nsd.signal_hint_statsusr = 1;
		break;
	case SIGUSR1:
		/* Dump statistics.  */
		nsd.signal_hint_statsusr = 1;
		break;
	case SIGINT:
	case SIGTERM:
	default:
		nsd.signal_hint_shutdown = 1;
		break;
	}
}

/*
 * Statistic output...
 *
 */
#ifdef BIND8_STATS
void
bind8_stats (struct nsd *nsd)
{
	char buf[MAXSYSLOGMSGLEN];
	char *msg, *t;
	int i, len;

	/* Current time... */
	time_t now;
	if(!nsd->st.period)
		return;
	time(&now);

	/* NSTATS */
	t = msg = buf + snprintf(buf, MAXSYSLOGMSGLEN, "NSTATS %lld %lu",
				 (long long) now, (unsigned long) nsd->st.boot);
	for (i = 0; i <= 255; i++) {
		/* How much space left? */
		if ((len = buf + MAXSYSLOGMSGLEN - t) < 32) {
			log_msg(LOG_INFO, "%s", buf);
			t = msg;
			len = buf + MAXSYSLOGMSGLEN - t;
		}

		if (nsd->st.qtype[i] != 0) {
			t += snprintf(t, len, " %s=%lu", rrtype_to_string(i), nsd->st.qtype[i]);
		}
	}
	if (t > msg)
		log_msg(LOG_INFO, "%s", buf);

	/* XSTATS */
	/* Only print it if we're in the main daemon or have anything to report... */
	if (nsd->server_kind == NSD_SERVER_MAIN
	    || nsd->st.dropped || nsd->st.raxfr || (nsd->st.qudp + nsd->st.qudp6 - nsd->st.dropped)
	    || nsd->st.txerr || nsd->st.opcode[OPCODE_QUERY] || nsd->st.opcode[OPCODE_IQUERY]
	    || nsd->st.wrongzone || nsd->st.ctcp + nsd->st.ctcp6 || nsd->st.rcode[RCODE_SERVFAIL]
	    || nsd->st.rcode[RCODE_FORMAT] || nsd->st.nona || nsd->st.rcode[RCODE_NXDOMAIN]
	    || nsd->st.opcode[OPCODE_UPDATE]) {

		log_msg(LOG_INFO, "XSTATS %lld %lu"
			" RR=%lu RNXD=%lu RFwdR=%lu RDupR=%lu RFail=%lu RFErr=%lu RErr=%lu RAXFR=%lu"
			" RLame=%lu ROpts=%lu SSysQ=%lu SAns=%lu SFwdQ=%lu SDupQ=%lu SErr=%lu RQ=%lu"
			" RIQ=%lu RFwdQ=%lu RDupQ=%lu RTCP=%lu SFwdR=%lu SFail=%lu SFErr=%lu SNaAns=%lu"
			" SNXD=%lu RUQ=%lu RURQ=%lu RUXFR=%lu RUUpd=%lu",
			(long long) now, (unsigned long) nsd->st.boot,
			nsd->st.dropped, (unsigned long)0, (unsigned long)0, (unsigned long)0, (unsigned long)0,
			(unsigned long)0, (unsigned long)0, nsd->st.raxfr, (unsigned long)0, (unsigned long)0,
			(unsigned long)0, nsd->st.qudp + nsd->st.qudp6 - nsd->st.dropped, (unsigned long)0,
			(unsigned long)0, nsd->st.txerr,
			nsd->st.opcode[OPCODE_QUERY], nsd->st.opcode[OPCODE_IQUERY], nsd->st.wrongzone,
			(unsigned long)0, nsd->st.ctcp + nsd->st.ctcp6,
			(unsigned long)0, nsd->st.rcode[RCODE_SERVFAIL], nsd->st.rcode[RCODE_FORMAT],
			nsd->st.nona, nsd->st.rcode[RCODE_NXDOMAIN],
			(unsigned long)0, (unsigned long)0, (unsigned long)0, nsd->st.opcode[OPCODE_UPDATE]);
	}

}
#endif /* BIND8_STATS */

extern char *optarg;
extern int optind;

int
main(int argc, char *argv[])
{
	/* Scratch variables... */
	int c;
	pid_t	oldpid;
	size_t i;
	struct sigaction action;
#ifdef HAVE_GETPWNAM
	struct passwd *pwd = NULL;
#endif /* HAVE_GETPWNAM */

	struct addrinfo hints[2];
	int hints_in_use = 1;
	char** nodes = NULL; /* array of address strings, size nsd.ifs */
	const char *udp_port = 0;
	const char *tcp_port = 0;

	const char *configfile = CONFIGFILE;

	char* argv0 = (argv0 = strrchr(argv[0], '/')) ? argv0 + 1 : argv[0];

	log_init(argv0);

	/* Initialize the server handler... */
	memset(&nsd, 0, sizeof(struct nsd));
	nsd.region      = region_create(xalloc, free);
	nsd.dbfile	= 0;
	nsd.pidfile	= 0;
	nsd.server_kind = NSD_SERVER_MAIN;
	memset(&hints, 0, sizeof(*hints)*2);
	hints[0].ai_family = DEFAULT_AI_FAMILY;
	hints[0].ai_flags = AI_PASSIVE;
	hints[1].ai_family = DEFAULT_AI_FAMILY;
	hints[1].ai_flags = AI_PASSIVE;
	nsd.identity	= 0;
	nsd.version	= VERSION;
	nsd.username	= 0;
	nsd.chrootdir	= 0;
	nsd.nsid 	= NULL;
	nsd.nsid_len 	= 0;

	nsd.child_count = 0;
	nsd.maximum_tcp_count = 0;
	nsd.current_tcp_count = 0;
	nsd.grab_ip6_optional = 0;
	nsd.file_rotation_ok = 0;

	/* Set up our default identity to gethostname(2) */
	if (gethostname(hostname, MAXHOSTNAMELEN) == 0) {
		nsd.identity = hostname;
	} else {
		log_msg(LOG_ERR,
			"failed to get the host name: %s - using default identity",
			strerror(errno));
		nsd.identity = IDENTITY;
	}

	/* Parse the command line... */
	while ((c = getopt(argc, argv, "46a:c:df:hi:I:l:N:n:P:p:s:u:t:X:V:v"
#ifndef NDEBUG /* <mattthijs> only when configured with --enable-checking */
		"F:L:"
#endif /* NDEBUG */
		)) != -1) {
		switch (c) {
		case '4':
			hints[0].ai_family = AF_INET;
			break;
		case '6':
#ifdef INET6
			hints[0].ai_family = AF_INET6;
#else /* !INET6 */
			error("IPv6 support not enabled.");
#endif /* INET6 */
			break;
		case 'a':
			add_interface(&nodes, &nsd, optarg);
			break;
		case 'c':
			configfile = optarg;
			break;
		case 'd':
			nsd.debug = 1;
			break;
		case 'f':
			nsd.dbfile = optarg;
			break;
		case 'h':
			usage();
			exit(0);
		case 'i':
			nsd.identity = optarg;
			break;
		case 'I':
			if (nsd.nsid_len != 0) {
				/* can only be given once */
				break;
			}
			if (strncasecmp(optarg, "ascii_", 6) == 0) {
				nsd.nsid = xalloc(strlen(optarg+6));
				nsd.nsid_len = strlen(optarg+6);
				memmove(nsd.nsid, optarg+6, nsd.nsid_len);
			} else {
				if (strlen(optarg) % 2 != 0) {
					error("the NSID must be a hex string of an even length.");
				}
				nsd.nsid = xalloc(strlen(optarg) / 2);
				nsd.nsid_len = strlen(optarg) / 2;
				if (hex_pton(optarg, nsd.nsid, nsd.nsid_len) == -1) {
					error("hex string cannot be parsed '%s' in NSID.", optarg);
				}
			}
			break;
		case 'l':
			nsd.log_filename = optarg;
			break;
		case 'N':
			i = atoi(optarg);
			if (i <= 0) {
				error("number of child servers must be greater than zero.");
			} else {
				nsd.child_count = i;
			}
			break;
		case 'n':
			i = atoi(optarg);
			if (i <= 0) {
				error("number of concurrent TCP connections must greater than zero.");
			} else {
				nsd.maximum_tcp_count = i;
			}
			break;
		case 'P':
			nsd.pidfile = optarg;
			break;
		case 'p':
			if (atoi(optarg) == 0) {
				error("port argument must be numeric.");
			}
			tcp_port = optarg;
			udp_port = optarg;
			break;
		case 's':
#ifdef BIND8_STATS
			nsd.st.period = atoi(optarg);
#else /* !BIND8_STATS */
			error("BIND 8 statistics not enabled.");
#endif /* BIND8_STATS */
			break;
		case 't':
#ifdef HAVE_CHROOT
			nsd.chrootdir = optarg;
#else /* !HAVE_CHROOT */
			error("chroot not supported on this platform.");
#endif /* HAVE_CHROOT */
			break;
		case 'u':
			nsd.username = optarg;
			break;
		case 'V':
			verbosity = atoi(optarg);
			break;
		case 'v':
			version();
			/* version exits */
#ifndef NDEBUG
		case 'F':
			sscanf(optarg, "%x", &nsd_debug_facilities);
			break;
		case 'L':
			sscanf(optarg, "%d", &nsd_debug_level);
			break;
#endif /* NDEBUG */
		case '?':
		default:
			usage();
			exit(1);
		}
	}
	argc -= optind;
	argv += optind;

	/* Commandline parse error */
	if (argc != 0) {
		usage();
		exit(1);
	}

	if (strlen(nsd.identity) > UCHAR_MAX) {
		error("server identity too long (%u characters)",
		      (unsigned) strlen(nsd.identity));
	}
	if(!tsig_init(nsd.region))
		error("init tsig failed");

	/* Read options */
	nsd.options = nsd_options_create(region_create_custom(xalloc, free,
		DEFAULT_CHUNK_SIZE, DEFAULT_LARGE_OBJECT_SIZE,
		DEFAULT_INITIAL_CLEANUP_SIZE, 1));
	if(!parse_options_file(nsd.options, configfile, NULL, NULL)) {
		error("could not read config: %s\n", configfile);
	}
	if(!parse_zone_list_file(nsd.options)) {
		error("could not read zonelist file %s\n",
			nsd.options->zonelistfile);
	}
	if(nsd.options->do_ip4 && !nsd.options->do_ip6) {
		hints[0].ai_family = AF_INET;
	}
#ifdef INET6
	if(nsd.options->do_ip6 && !nsd.options->do_ip4) {
		hints[0].ai_family = AF_INET6;
	}
#endif /* INET6 */
	if(nsd.options->ip_addresses)
	{
		ip_address_option_type* ip = nsd.options->ip_addresses;
		while(ip) {
			add_interface(&nodes, &nsd, ip->address);
			ip = ip->next;
		}
	}
	if (verbosity == 0)
		verbosity = nsd.options->verbosity;
#ifndef NDEBUG
	if (nsd_debug_level > 0 && verbosity == 0)
		verbosity = nsd_debug_level;
#endif /* NDEBUG */
	if(nsd.options->debug_mode) nsd.debug=1;
	if(!nsd.dbfile)
	{
		if(nsd.options->database)
			nsd.dbfile = nsd.options->database;
		else
			nsd.dbfile = DBFILE;
	}
	if(!nsd.pidfile)
	{
		if(nsd.options->pidfile)
			nsd.pidfile = nsd.options->pidfile;
		else
			nsd.pidfile = PIDFILE;
	}
	if(strcmp(nsd.identity, hostname)==0 || strcmp(nsd.identity,IDENTITY)==0)
	{
		if(nsd.options->identity)
			nsd.identity = nsd.options->identity;
	}
	if(nsd.options->version) {
		nsd.version = nsd.options->version;
	}
	if (nsd.options->logfile && !nsd.log_filename) {
		nsd.log_filename = nsd.options->logfile;
	}
	if(nsd.child_count == 0) {
		nsd.child_count = nsd.options->server_count;
	}
#ifdef SO_REUSEPORT
	if(nsd.options->reuseport && nsd.child_count > 1) {
		nsd.reuseport = nsd.child_count;
	}
#endif /* SO_REUSEPORT */
	if(nsd.maximum_tcp_count == 0) {
		nsd.maximum_tcp_count = nsd.options->tcp_count;
	}
	nsd.tcp_timeout = nsd.options->tcp_timeout;
	nsd.tcp_query_count = nsd.options->tcp_query_count;
	nsd.tcp_mss = nsd.options->tcp_mss;
	nsd.outgoing_tcp_mss = nsd.options->outgoing_tcp_mss;
	nsd.ipv4_edns_size = nsd.options->ipv4_edns_size;
	nsd.ipv6_edns_size = nsd.options->ipv6_edns_size;

	if(udp_port == 0)
	{
		if(nsd.options->port != 0) {
			udp_port = nsd.options->port;
			tcp_port = nsd.options->port;
		} else {
			udp_port = UDP_PORT;
			tcp_port = TCP_PORT;
		}
	}
#ifdef BIND8_STATS
	if(nsd.st.period == 0) {
		nsd.st.period = nsd.options->statistics;
	}
#endif /* BIND8_STATS */
#ifdef HAVE_CHROOT
	if(nsd.chrootdir == 0) nsd.chrootdir = nsd.options->chroot;
#ifdef CHROOTDIR
	/* if still no chrootdir, fallback to default */
	if(nsd.chrootdir == 0) nsd.chrootdir = CHROOTDIR;
#endif /* CHROOTDIR */
#endif /* HAVE_CHROOT */
	if(nsd.username == 0) {
		if(nsd.options->username) nsd.username = nsd.options->username;
		else nsd.username = USER;
	}
	if(nsd.options->zonesdir && nsd.options->zonesdir[0]) {
		if(chdir(nsd.options->zonesdir)) {
			error("cannot chdir to '%s': %s",
				nsd.options->zonesdir, strerror(errno));
		}
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "changed directory to %s",
			nsd.options->zonesdir));
	}

	/* EDNS0 */
	edns_init_data(&nsd.edns_ipv4, nsd.options->ipv4_edns_size);
#if defined(INET6)
#if defined(IPV6_USE_MIN_MTU) || defined(IPV6_MTU)
	edns_init_data(&nsd.edns_ipv6, nsd.options->ipv6_edns_size);
#else /* no way to set IPV6 MTU, send no bigger than that. */
	if (nsd.options->ipv6_edns_size < IPV6_MIN_MTU)
		edns_init_data(&nsd.edns_ipv6, nsd.options->ipv6_edns_size);
	else
		edns_init_data(&nsd.edns_ipv6, IPV6_MIN_MTU);
#endif /* IPV6 MTU) */
#endif /* defined(INET6) */

	if (nsd.nsid_len == 0 && nsd.options->nsid) {
		if (strlen(nsd.options->nsid) % 2 != 0) {
			error("the NSID must be a hex string of an even length.");
		}
		nsd.nsid = xalloc(strlen(nsd.options->nsid) / 2);
		nsd.nsid_len = strlen(nsd.options->nsid) / 2;
		if (hex_pton(nsd.options->nsid, nsd.nsid, nsd.nsid_len) == -1) {
			error("hex string cannot be parsed '%s' in NSID.", nsd.options->nsid);
		}
	}
	edns_init_nsid(&nsd.edns_ipv4, nsd.nsid_len);
#if defined(INET6)
	edns_init_nsid(&nsd.edns_ipv6, nsd.nsid_len);
#endif /* defined(INET6) */

	/* Number of child servers to fork.  */
	nsd.children = (struct nsd_child *) region_alloc_array(
		nsd.region, nsd.child_count, sizeof(struct nsd_child));
	for (i = 0; i < nsd.child_count; ++i) {
		nsd.children[i].kind = NSD_SERVER_BOTH;
		nsd.children[i].pid = -1;
		nsd.children[i].child_fd = -1;
		nsd.children[i].parent_fd = -1;
		nsd.children[i].handler = NULL;
		nsd.children[i].need_to_send_STATS = 0;
		nsd.children[i].need_to_send_QUIT = 0;
		nsd.children[i].need_to_exit = 0;
		nsd.children[i].has_exited = 0;
	}

	nsd.this_child = NULL;

	/* We need at least one active interface */
	if (nsd.ifs == 0) {
		add_interface(&nodes, &nsd, NULL);

		/*
		 * With IPv6 we'd like to open two separate sockets,
		 * one for IPv4 and one for IPv6, both listening to
		 * the wildcard address (unless the -4 or -6 flags are
		 * specified).
		 *
		 * However, this is only supported on platforms where
		 * we can turn the socket option IPV6_V6ONLY _on_.
		 * Otherwise we just listen to a single IPv6 socket
		 * and any incoming IPv4 connections will be
		 * automatically mapped to our IPv6 socket.
		 */
#ifdef INET6
		if (hints[0].ai_family == AF_UNSPEC) {
#ifdef IPV6_V6ONLY
			add_interface(&nodes, &nsd, NULL);
			hints[0].ai_family = AF_INET6;
			hints[1].ai_family = AF_INET;
			hints_in_use = 2;
			nsd.grab_ip6_optional = 1;
#else /* !IPV6_V6ONLY */
			hints[0].ai_family = AF_INET6;
#endif	/* IPV6_V6ONLY */
		}
#endif /* INET6 */
	}

	/* Set up the address info structures with real interface/port data */
	for (i = 0; i < nsd.ifs; ++i) {
		int r;
		const char* node = NULL;
		const char* service = NULL;
		int h = ((hints_in_use == 1)?0:i%hints_in_use);

		/* We don't perform name-lookups */
		if (nodes[i] != NULL)
			hints[h].ai_flags |= AI_NUMERICHOST;
		get_ip_port_frm_str(nodes[i], &node, &service);

		hints[h].ai_socktype = SOCK_DGRAM;
		if ((r=getaddrinfo(node, (service?service:udp_port), &hints[h], &nsd.udp[i].addr)) != 0) {
#ifdef INET6
			if(nsd.grab_ip6_optional && hints[0].ai_family == AF_INET6) {
				log_msg(LOG_WARNING, "No IPv6, fallback to IPv4. getaddrinfo: %s",
				r==EAI_SYSTEM?strerror(errno):gai_strerror(r));
				continue;
			}
#endif
			error("cannot parse address '%s': getaddrinfo: %s %s",
				nodes[i]?nodes[i]:"(null)",
				gai_strerror(r),
				r==EAI_SYSTEM?strerror(errno):"");
		}

		hints[h].ai_socktype = SOCK_STREAM;
		if ((r=getaddrinfo(node, (service?service:tcp_port), &hints[h], &nsd.tcp[i].addr)) != 0) {
			error("cannot parse address '%s': getaddrinfo: %s %s",
				nodes[i]?nodes[i]:"(null)",
				gai_strerror(r),
				r==EAI_SYSTEM?strerror(errno):"");
		}
	}

	/* Parse the username into uid and gid */
	nsd.gid = getgid();
	nsd.uid = getuid();
#ifdef HAVE_GETPWNAM
	/* Parse the username into uid and gid */
	if (*nsd.username) {
		if (isdigit((unsigned char)*nsd.username)) {
			char *t;
			nsd.uid = strtol(nsd.username, &t, 10);
			if (*t != 0) {
				if (*t != '.' || !isdigit((unsigned char)*++t)) {
					error("-u user or -u uid or -u uid.gid");
				}
				nsd.gid = strtol(t, &t, 10);
			} else {
				/* Lookup the group id in /etc/passwd */
				if ((pwd = getpwuid(nsd.uid)) == NULL) {
					error("user id %u does not exist.", (unsigned) nsd.uid);
				} else {
					nsd.gid = pwd->pw_gid;
				}
			}
		} else {
			/* Lookup the user id in /etc/passwd */
			if ((pwd = getpwnam(nsd.username)) == NULL) {
				error("user '%s' does not exist.", nsd.username);
			} else {
				nsd.uid = pwd->pw_uid;
				nsd.gid = pwd->pw_gid;
			}
		}
	}
	/* endpwent(); */
#endif /* HAVE_GETPWNAM */

#if defined(HAVE_SSL)
	key_options_tsig_add(nsd.options);
#endif

	append_trailing_slash(&nsd.options->xfrdir, nsd.options->region);
	/* Check relativity of pathnames to chroot */
	if (nsd.chrootdir && nsd.chrootdir[0]) {
		/* existing chrootdir: append trailing slash for strncmp checking */
		append_trailing_slash(&nsd.chrootdir, nsd.region);
		append_trailing_slash(&nsd.options->zonesdir, nsd.options->region);

		/* zonesdir must be absolute and within chroot,
		 * all other pathnames may be relative to zonesdir */
		if (strncmp(nsd.options->zonesdir, nsd.chrootdir, strlen(nsd.chrootdir)) != 0) {
			error("zonesdir %s has to be an absolute path that starts with the chroot path %s",
				nsd.options->zonesdir, nsd.chrootdir);
		} else if (!file_inside_chroot(nsd.pidfile, nsd.chrootdir)) {
			error("pidfile %s is not relative to %s: chroot not possible",
				nsd.pidfile, nsd.chrootdir);
		} else if (!file_inside_chroot(nsd.dbfile, nsd.chrootdir)) {
			error("database %s is not relative to %s: chroot not possible",
				nsd.dbfile, nsd.chrootdir);
		} else if (!file_inside_chroot(nsd.options->xfrdfile, nsd.chrootdir)) {
			error("xfrdfile %s is not relative to %s: chroot not possible",
				nsd.options->xfrdfile, nsd.chrootdir);
		} else if (!file_inside_chroot(nsd.options->zonelistfile, nsd.chrootdir)) {
			error("zonelistfile %s is not relative to %s: chroot not possible",
				nsd.options->zonelistfile, nsd.chrootdir);
		} else if (!file_inside_chroot(nsd.options->xfrdir, nsd.chrootdir)) {
			error("xfrdir %s is not relative to %s: chroot not possible",
				nsd.options->xfrdir, nsd.chrootdir);
		}
	}

	/* Set up the logging */
	log_open(LOG_PID, FACILITY, nsd.log_filename);
	if (!nsd.log_filename)
		log_set_log_function(log_syslog);
	else if (nsd.uid && nsd.gid) {
		if(chown(nsd.log_filename, nsd.uid, nsd.gid) != 0)
			VERBOSITY(2, (LOG_WARNING, "chown %s failed: %s",
				nsd.log_filename, strerror(errno)));
	}
	log_msg(LOG_NOTICE, "%s starting (%s)", argv0, PACKAGE_STRING);

	/* Do we have a running nsd? */
	if ((oldpid = readpid(nsd.pidfile)) == -1) {
		if (errno != ENOENT) {
			log_msg(LOG_ERR, "can't read pidfile %s: %s",
				nsd.pidfile, strerror(errno));
		}
	} else {
		if (kill(oldpid, 0) == 0 || errno == EPERM) {
			log_msg(LOG_WARNING,
				"%s is already running as %u, continuing",
				argv0, (unsigned) oldpid);
		} else {
			log_msg(LOG_ERR,
				"...stale pid file from process %u",
				(unsigned) oldpid);
		}
	}

	/* Setup the signal handling... */
	action.sa_handler = sig_handler;
	sigfillset(&action.sa_mask);
	action.sa_flags = 0;
	sigaction(SIGTERM, &action, NULL);
	sigaction(SIGHUP, &action, NULL);
	sigaction(SIGINT, &action, NULL);
	sigaction(SIGILL, &action, NULL);
	sigaction(SIGUSR1, &action, NULL);
	sigaction(SIGALRM, &action, NULL);
	sigaction(SIGCHLD, &action, NULL);
	action.sa_handler = SIG_IGN;
	sigaction(SIGPIPE, &action, NULL);

	/* Initialize... */
	nsd.mode = NSD_RUN;
	nsd.signal_hint_child = 0;
	nsd.signal_hint_reload = 0;
	nsd.signal_hint_reload_hup = 0;
	nsd.signal_hint_quit = 0;
	nsd.signal_hint_shutdown = 0;
	nsd.signal_hint_stats = 0;
	nsd.signal_hint_statsusr = 0;
	nsd.quit_sync_done = 0;

	/* Initialize the server... */
	if (server_init(&nsd) != 0) {
		error("server initialization failed, %s could "
			"not be started", argv0);
	}
#if defined(HAVE_SSL)
	if(nsd.options->control_enable) {
		/* read ssl keys while superuser and outside chroot */
		if(!(nsd.rc = daemon_remote_create(nsd.options)))
			error("could not perform remote control setup");
	}
#endif /* HAVE_SSL */

	/* Unless we're debugging, fork... */
	if (!nsd.debug) {
		int fd;

		/* Take off... */
		switch ((nsd.pid = fork())) {
		case 0:
			/* Child */
			break;
		case -1:
			error("fork() failed: %s", strerror(errno));
		default:
			/* Parent is done */
			server_close_all_sockets(nsd.udp, nsd.ifs);
			server_close_all_sockets(nsd.tcp, nsd.ifs);
			exit(0);
		}

		/* Detach ourselves... */
		if (setsid() == -1) {
			error("setsid() failed: %s", strerror(errno));
		}

		if ((fd = open("/dev/null", O_RDWR, 0)) != -1) {
			(void)dup2(fd, STDIN_FILENO);
			(void)dup2(fd, STDOUT_FILENO);
			(void)dup2(fd, STDERR_FILENO);
			if (fd > 2)
				(void)close(fd);
		}
	}

	/* Get our process id */
	nsd.pid = getpid();

	/* Set user context */
#ifdef HAVE_GETPWNAM
	if (*nsd.username) {
#ifdef HAVE_SETUSERCONTEXT
		/* setusercontext does initgroups, setuid, setgid, and
		 * also resource limits from login config, but we
		 * still call setresuid, setresgid to be sure to set all uid */
		if (setusercontext(NULL, pwd, nsd.uid,
			LOGIN_SETALL & ~LOGIN_SETUSER & ~LOGIN_SETGROUP) != 0)
			log_msg(LOG_WARNING, "unable to setusercontext %s: %s",
				nsd.username, strerror(errno));
#endif /* HAVE_SETUSERCONTEXT */
	}
#endif /* HAVE_GETPWNAM */

	/* Chroot */
#ifdef HAVE_CHROOT
	if (nsd.chrootdir && nsd.chrootdir[0]) {
		int l = strlen(nsd.chrootdir)-1; /* ends in trailing slash */

		if (file_inside_chroot(nsd.log_filename, nsd.chrootdir))
			nsd.file_rotation_ok = 1;

		/* strip chroot from pathnames if they're absolute */
		nsd.options->zonesdir += l;
		if (nsd.log_filename){
			if (nsd.log_filename[0] == '/')
				nsd.log_filename += l;
		}
		if (nsd.pidfile[0] == '/')
			nsd.pidfile += l;
		if (nsd.dbfile[0] == '/')
			nsd.dbfile += l;
		if (nsd.options->xfrdfile[0] == '/')
			nsd.options->xfrdfile += l;
		if (nsd.options->zonelistfile[0] == '/')
			nsd.options->zonelistfile += l;
		if (nsd.options->xfrdir[0] == '/')
			nsd.options->xfrdir += l;

		/* strip chroot from pathnames of "include:" statements
		 * on subsequent repattern commands */
		cfg_parser->chroot = nsd.chrootdir;

#ifdef HAVE_TZSET
		/* set timezone whilst not yet in chroot */
		tzset();
#endif
		if (chroot(nsd.chrootdir)) {
			error("unable to chroot: %s", strerror(errno));
		}
		if (chdir("/")) {
			error("unable to chdir to chroot: %s", strerror(errno));
		}
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "changed root directory to %s",
			nsd.chrootdir));
		/* chdir to zonesdir again after chroot */
		if(nsd.options->zonesdir && nsd.options->zonesdir[0]) {
			if(chdir(nsd.options->zonesdir)) {
				error("unable to chdir to '%s': %s",
					nsd.options->zonesdir, strerror(errno));
			}
			DEBUG(DEBUG_IPC,1, (LOG_INFO, "changed directory to %s",
				nsd.options->zonesdir));
		}
	}
	else
#endif /* HAVE_CHROOT */
		nsd.file_rotation_ok = 1;

	DEBUG(DEBUG_IPC,1, (LOG_INFO, "file rotation on %s %sabled",
		nsd.log_filename, nsd.file_rotation_ok?"en":"dis"));

	/* Write pidfile */
	if (writepid(&nsd) == -1) {
		log_msg(LOG_ERR, "cannot overwrite the pidfile %s: %s",
			nsd.pidfile, strerror(errno));
	}

	/* Drop the permissions */
#ifdef HAVE_GETPWNAM
	if (*nsd.username) {
#ifdef HAVE_INITGROUPS
		if(initgroups(nsd.username, nsd.gid) != 0)
			log_msg(LOG_WARNING, "unable to initgroups %s: %s",
				nsd.username, strerror(errno));
#endif /* HAVE_INITGROUPS */
		endpwent();

#ifdef HAVE_SETRESGID
		if(setresgid(nsd.gid,nsd.gid,nsd.gid) != 0)
#elif defined(HAVE_SETREGID) && !defined(DARWIN_BROKEN_SETREUID)
			if(setregid(nsd.gid,nsd.gid) != 0)
#else /* use setgid */
				if(setgid(nsd.gid) != 0)
#endif /* HAVE_SETRESGID */
					error("unable to set group id of %s: %s",
						nsd.username, strerror(errno));

#ifdef HAVE_SETRESUID
		if(setresuid(nsd.uid,nsd.uid,nsd.uid) != 0)
#elif defined(HAVE_SETREUID) && !defined(DARWIN_BROKEN_SETREUID)
			if(setreuid(nsd.uid,nsd.uid) != 0)
#else /* use setuid */
				if(setuid(nsd.uid) != 0)
#endif /* HAVE_SETRESUID */
					error("unable to set user id of %s: %s",
						nsd.username, strerror(errno));

		DEBUG(DEBUG_IPC,1, (LOG_INFO, "dropped user privileges, run as %s",
			nsd.username));
	}
#endif /* HAVE_GETPWNAM */

	if (pledge("stdio rpath wpath cpath dns inet proc", NULL) == -1)
		error("pledge");

	xfrd_make_tempdir(&nsd);
#ifdef USE_ZONE_STATS
	options_zonestatnames_create(nsd.options);
	server_zonestat_alloc(&nsd);
#endif /* USE_ZONE_STATS */

	if(nsd.server_kind == NSD_SERVER_MAIN) {
		server_prepare_xfrd(&nsd);
		/* xfrd forks this before reading database, so it does not get
		 * the memory size of the database */
		server_start_xfrd(&nsd, 0, 0);
	}
	if (server_prepare(&nsd) != 0) {
		unlinkpid(nsd.pidfile);
		error("server preparation failed, %s could "
			"not be started", argv0);
	}
	if(nsd.server_kind == NSD_SERVER_MAIN) {
		server_send_soa_xfrd(&nsd, 0);
	}

	/* Really take off */
	log_msg(LOG_NOTICE, "%s started (%s), pid %d",
		argv0, PACKAGE_STRING, (int) nsd.pid);

	if (nsd.server_kind == NSD_SERVER_MAIN) {
		server_main(&nsd);
	} else {
		server_child(&nsd);
	}

	/* NOTREACH */
	exit(0);
}
@


1.27
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@d52 1
a52 1
extern config_parser_state_t* cfg_parser;
d633 1
a633 1
		ip_address_option_t* ip = nsd.options->ip_addresses;
@


1.26
log
@zap surplus blank line
@
text
@d684 2
d914 1
@


1.25
log
@update to NSD 4.1.7, ok florian@@
@
text
@a1120 1

@


1.24
log
@pledge for nsd.

The main process handles zone transfers (inet, dns), writing and
creating of zone files (wpath, cpath) and starting of child
processes (proc).

Child processes answer queries from the internet.

"Looks good" to deraadt@@
@
text
@d665 3
@


1.23
log
@merge
@
text
@d1114 5
@


1.22
log
@merge conflicts
@
text
@d170 22
d429 3
a431 4
	/* For initialising the address info structures */
	/* static so it can get very big without overflowing the stack */
	static struct addrinfo hints[MAX_INTERFACES];
	static const char *nodes[MAX_INTERFACES];
d447 5
a451 8

	for (i = 0; i < MAX_INTERFACES; i++) {
		memset(&hints[i], 0, sizeof(hints[i]));
		hints[i].ai_family = DEFAULT_AI_FAMILY;
		hints[i].ai_flags = AI_PASSIVE;
		nodes[i] = NULL;
	}

a474 1

d483 1
a483 3
			for (i = 0; i < MAX_INTERFACES; ++i) {
				hints[i].ai_family = AF_INET;
			}
d487 1
a487 3
			for (i = 0; i < MAX_INTERFACES; ++i) {
				hints[i].ai_family = AF_INET6;
			}
d493 1
a493 6
			if (nsd.ifs < MAX_INTERFACES) {
				nodes[nsd.ifs] = optarg;
				++nsd.ifs;
			} else {
				error("too many interfaces ('-a') specified.");
			}
d624 1
a624 3
		for (i = 0; i < MAX_INTERFACES; ++i) {
			hints[i].ai_family = AF_INET;
		}
d628 1
a628 3
		for (i = 0; i < MAX_INTERFACES; ++i) {
			hints[i].ai_family = AF_INET6;
		}
d635 1
a635 8
			if (nsd.ifs < MAX_INTERFACES) {
				nodes[nsd.ifs] = ip->address;
				++nsd.ifs;
			} else {
				error("too many interfaces ('-a' + "
				      "'ip-address:') specified.");
				break;
			}
d671 5
d766 1
a766 1
		nsd.ifs = 1;
d783 1
d786 1
a786 1
			nsd.ifs = 2;
d800 1
d804 1
a804 1
			hints[i].ai_flags |= AI_NUMERICHOST;
d807 2
a808 2
		hints[i].ai_socktype = SOCK_DGRAM;
		if ((r=getaddrinfo(node, (service?service:udp_port), &hints[i], &nsd.udp[i].addr)) != 0) {
d822 2
a823 2
		hints[i].ai_socktype = SOCK_STREAM;
		if ((r=getaddrinfo(node, (service?service:tcp_port), &hints[i], &nsd.tcp[i].addr)) != 0) {
@


1.21
log
@merge conflicts
@
text
@d47 1
d136 1
a136 1
	if (l>0 && (*dirname)[l-1] != '/') {
d746 2
a747 2
	nsd.children = (struct nsd_child *) region_alloc(
		nsd.region, nsd.child_count * sizeof(struct nsd_child));
d1110 1
@


1.20
log
@Use proper casts for ctype functions.  This is already fixed in nsd
trunk.  OK doug@@
@
text
@d875 1
a875 1
			error("zonesdir %s is not relative to %s: chroot not possible",
d1109 4
@


1.19
log
@merge conflicts
@
text
@d832 1
a832 1
		if (isdigit((int)*nsd.username)) {
d836 1
a836 1
				if (*t != '.' || !isdigit((int)*++t)) {
@


1.18
log
@merge conflicts
@
text
@d49 1
a49 1
static struct nsd nsd;
@


1.17
log
@merge conflicts
@
text
@d506 13
a518 7
			if (strlen(optarg) % 2 != 0) {
				error("the NSID must be a hex string of an even length.");
			}
			nsd.nsid = xalloc(strlen(optarg) / 2);
			nsd.nsid_len = strlen(optarg) / 2;
			if (hex_pton(optarg, nsd.nsid, nsd.nsid_len) == -1) {
				error("hex string cannot be parsed '%s' in NSID.", optarg);
@


1.16
log
@time_t and random fixes from NSD upstream, ok deraadt@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
a43 1
#include "namedb.h"
d46 1
d51 1
d71 1
a71 1
		"  -d                   Enable debug mode (do not fork as a daemon process).\n"
d111 1
a111 1
		"Copyright (C) 2001-2011 NLnet Labs.  This is free software.\n"
d131 13
d147 3
a149 9
#ifdef NDEBUG
	assert(chr);
#endif /* NDEBUG */
	/* filename and chroot the same? */
	if (fname && fname[0] && chr[0] && !strncmp(fname, chr, strlen(chr)))
		return 2; /* strip chroot, file rotation ok */
	else if (fname && fname[0] != '/')
		return 1; /* don't strip, file rotation ok */
	return 0; /* don't strip, don't try file rotation */
d302 1
a302 1
		nsd.signal_hint_reload = 1;
a318 3
		/* Silent shutdown... */
		nsd.signal_hint_quit = 1;
		break;
a330 54

#ifdef USE_ZONE_STATS
static void
fprintf_zone_stats(FILE* fd, zone_type* zone, time_t now)
{
	int i;

	/* NSTATS */
	fprintf(fd, "NSTATS %s %lu",
		dname_to_string(domain_dname(zone->apex),0),
		(unsigned long) now);

	for (i = 0; i <= 255; i++) {
		if (zone->st.qtype[i] != 0) {
			fprintf(fd, " %s=%lu", rrtype_to_string(i),
				zone->st.qtype[i]);
		}
	}
	fprintf(fd, "\n");

	/* XSTATS */
	fprintf(fd, "XSTATS %s %lu"
		" RR=%lu RNXD=%lu RFwdR=%lu RDupR=%lu RFail=%lu RFErr=%lu RErr=%lu RAXFR=%lu"
		" RLame=%lu ROpts=%lu SSysQ=%lu SAns=%lu SFwdQ=%lu SDupQ=%lu SErr=%lu RQ=%lu"
		" RIQ=%lu RFwdQ=%lu RDupQ=%lu RTCP=%lu SFwdR=%lu SFail=%lu SFErr=%lu SNaAns=%lu"
		" SNXD=%lu RUQ=%lu RURQ=%lu RUXFR=%lu RUUpd=%lu\n",
		dname_to_string(domain_dname(zone->apex),0),
		(unsigned long) now,
		zone->st.dropped,
		(unsigned long)0, (unsigned long)0,
		(unsigned long)0, (unsigned long)0,
		(unsigned long)0, (unsigned long)0,
		zone->st.raxfr,
		(unsigned long)0, (unsigned long)0,
		(unsigned long)0,
		zone->st.qudp + zone->st.qudp6 - zone->st.dropped,
		(unsigned long)0, (unsigned long)0,
		zone->st.txerr,
		zone->st.opcode[OPCODE_QUERY],
		zone->st.opcode[OPCODE_IQUERY],
		zone->st.wrongzone,
		(unsigned long)0,
		zone->st.ctcp + zone->st.ctcp6,
		(unsigned long)0,
		zone->st.rcode[RCODE_SERVFAIL],
		zone->st.rcode[RCODE_FORMAT],
		zone->st.nona,
		zone->st.rcode[RCODE_NXDOMAIN],
		(unsigned long)0, (unsigned long)0,
		(unsigned long)0,
		zone->st.opcode[OPCODE_UPDATE]);
}
#endif

a333 4
#ifdef USE_ZONE_STATS
	FILE* fd;
	zone_type* zone;
#endif
a387 17
#ifdef USE_ZONE_STATS
	/* ZSTATS */
	log_msg(LOG_INFO, "ZSTATS %s", nsd->zonestatsfile);
	if ((fd = fopen(nsd->zonestatsfile, "a")) ==  NULL ) {
		log_msg(LOG_ERR, "cannot open zone statsfile %s: %s",
			nsd->zonestatsfile, strerror(errno));
		return;
	}
	/* Write stats per zone */
	zone = nsd->db->zones;
	while (zone) {
		fprintf_zone_stats(fd, zone, now);
		zone = zone->next;
	}
	fclose(fd);
#endif

a401 1
	FILE* dbfd;
a424 3
#ifdef USE_ZONE_STATS
	nsd.zonestatsfile = 0;
#endif
d594 2
d598 4
a601 2
	nsd.options = nsd_options_create(region_create(xalloc, free));
	if(!parse_options_file(nsd.options, configfile)) {
d604 5
a608 1
	if(nsd.options->ip4_only) {
d614 1
a614 1
	if(nsd.options->ip6_only) {
a688 5
#ifdef USE_ZONE_STATS
	if (nsd.zonestatsfile == 0) {
		nsd.zonestatsfile = nsd.options->zonestatsfile;
	}
#endif /* USE_ZONE_STATS */
a750 2
		nsd.children[i].dirty_zones = stack_create(nsd.region,
			nsd_options_num_zones(nsd.options));
a854 2
	if(!tsig_init(nsd.region))
		error("init tsig failed");
d859 3
a861 4
	/* Relativize the pathnames for chroot... */
	if (nsd.chrootdir) {
		int l = strlen(nsd.chrootdir);

d863 2
a864 7
		if (l>0 && strncmp(nsd.chrootdir + (l-1), "/", 1) != 0) {
			char *chroot_slash = region_alloc(nsd.region, sizeof(char)*(l+2));
			memcpy(chroot_slash, nsd.chrootdir, sizeof(char)*(l+1));
			strlcat(chroot_slash, "/", sizeof(char)*(l+2));
			nsd.chrootdir = chroot_slash;
			++l;
		}
d866 7
a872 2
		if (strncmp(nsd.chrootdir, nsd.pidfile, l) != 0) {
			error("%s is not relative to %s: chroot not possible",
d874 2
a875 2
		} else if (strncmp(nsd.chrootdir, nsd.dbfile, l) != 0) {
			error("%s is not relative to %s: chroot not possible",
d877 2
a878 2
		} else if (strncmp(nsd.chrootdir, nsd.options->xfrdfile, l) != 0) {
			error("%s is not relative to %s: chroot not possible",
d880 6
a885 6
		} else if (strncmp(nsd.chrootdir, nsd.options->difffile, l) != 0) {
			error("%s is not relative to %s: chroot not possible",
				nsd.options->difffile, nsd.chrootdir);
		} else if (strncmp(nsd.chrootdir, nsd.options->zonesdir, l) != 0) {
			error("%s is not relative to %s: chroot not possible",
				nsd.options->zonesdir, nsd.chrootdir);
d935 1
d944 1
a944 1
		log_msg(LOG_ERR, "server initialization failed, %s could "
a945 1
		exit(1);
d947 7
d965 1
a965 4
			log_msg(LOG_ERR, "fork() failed: %s", strerror(errno));
			server_close_all_sockets(nsd.udp, nsd.ifs);
			server_close_all_sockets(nsd.tcp, nsd.ifs);
			exit(1);
d975 1
a975 2
			log_msg(LOG_ERR, "setsid() failed: %s", strerror(errno));
			exit(1);
d1007 4
a1010 10
	if (nsd.chrootdir && strlen(nsd.chrootdir)) {
		int l = strlen(nsd.chrootdir);
		int ret = 0;

		while (l>0 && nsd.chrootdir[l-1] == '/')
			--l;

		/* filename after chroot */
		ret = file_inside_chroot(nsd.log_filename, nsd.chrootdir);
		if (ret) {
d1012 5
a1016 1
			if (ret == 2) /* also strip chroot */
d1019 14
a1032 5
		nsd.dbfile += l;
		nsd.pidfile += l;
		nsd.options->xfrdfile += l;
		nsd.options->difffile += l;
		nsd.options->zonesdir += l;
d1039 1
a1039 2
			log_msg(LOG_ERR, "unable to chroot: %s", strerror(errno));
			exit(1);
d1042 1
a1042 2
			log_msg(LOG_ERR, "unable to chdir to chroot: %s", strerror(errno));
			exit(1);
a1062 7
	/* Check if nsd.db exists */
	if ((dbfd = fopen(nsd.dbfile, "r")) == NULL) {
		log_msg(LOG_ERR, "unable to open %s for reading: %s", nsd.dbfile, strerror(errno));
		exit(1);
	}
	fclose(dbfd);

d1104 6
d1111 2
a1112 1
		log_msg(LOG_ERR, "server preparation failed, %s could "
d1114 3
a1116 2
		unlinkpid(nsd.pidfile);
		exit(1);
@


1.15
log
@merge NSD 3.2.16
@
text
@d398 2
a399 2
	t = msg = buf + snprintf(buf, MAXSYSLOGMSGLEN, "NSTATS %lu %lu",
				 (unsigned long) now, (unsigned long) nsd->st.boot);
d424 1
a424 1
		log_msg(LOG_INFO, "XSTATS %lu %lu"
d429 1
a429 1
			(unsigned long) now, (unsigned long) nsd->st.boot,
@


1.14
log
@resolve conflicts
@
text
@d244 4
a247 1
		if (fd != -1)
d249 1
d393 2
d488 1
a488 1
	log_init("nsd");
d959 3
d993 31
d1035 2
d1040 2
a1059 14
	/* Setup the signal handling... */
	action.sa_handler = sig_handler;
	sigfillset(&action.sa_mask);
	action.sa_flags = 0;
	sigaction(SIGTERM, &action, NULL);
	sigaction(SIGHUP, &action, NULL);
	sigaction(SIGINT, &action, NULL);
	sigaction(SIGILL, &action, NULL);
	sigaction(SIGUSR1, &action, NULL);
	sigaction(SIGALRM, &action, NULL);
	sigaction(SIGCHLD, &action, NULL);
	action.sa_handler = SIG_IGN;
	sigaction(SIGPIPE, &action, NULL);

a1062 17
	/* Initialize... */
	nsd.mode = NSD_RUN;
	nsd.signal_hint_child = 0;
	nsd.signal_hint_reload = 0;
	nsd.signal_hint_quit = 0;
	nsd.signal_hint_shutdown = 0;
	nsd.signal_hint_stats = 0;
	nsd.signal_hint_statsusr = 0;
	nsd.quit_sync_done = 0;

	/* Initialize the server... */
	if (server_init(&nsd) != 0) {
		log_msg(LOG_ERR, "server initialization failed, %s could "
			"not be started", argv0);
		exit(1);
	}

d1098 1
d1114 9
@


1.13
log
@resolve conflicts
@
text
@d468 1
a468 1
	struct passwd *pwd;
@


1.12
log
@resolve conflicts
@
text
@d192 1
a192 1
	pid = strtol(pidbuf, &t, 10);
d1086 4
d1092 4
@


1.11
log
@resolve conflicts
@
text
@d10 1
a10 1
#include <config.h>
d44 1
d322 54
d379 4
d435 17
d490 3
d749 5
@


1.10
log
@resolve conflicts
@
text
@d238 12
a249 3
	if (file && unlink(file) == -1)
		log_msg(LOG_ERR, "failed to unlink pidfile %s: %s",
			file, strerror(errno));
d396 3
a398 2
	struct addrinfo hints[MAX_INTERFACES];
	const char *nodes[MAX_INTERFACES];
@


1.9
log
@resolve conflicts and regen configure using autoconf-2.65
@
text
@d493 1
a493 1
                       break;
d866 5
a870 2
	else if (nsd.uid && nsd.gid)
		(void) chown(nsd.log_filename, nsd.uid, nsd.gid);
@


1.8
log
@call setusercontext(3) before chroot. ok miod@@ sthen@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d109 1
a109 1
		"Copyright (C) 2001-2006 NLnet Labs.  This is free software.\n"
d957 3
a959 1
		/* setusercontext sets resource limits from login config */
d968 1
a969 1
	/* Chroot */
d1019 1
a1019 1
 #ifdef HAVE_INITGROUPS
d1023 1
a1023 1
 #endif /* HAVE_INITGROUPS */
d1048 1
a1048 1
    }
@


1.7
log
@merge
@
text
@d953 13
a1016 8
#ifdef HAVE_SETUSERCONTEXT
		/* setusercontext does initgroups, setuid, setgid, and
		 * also resource limits from login config, but we
		 * still call setresuid, setresgid to be sure to set all uid */
		if (setusercontext(NULL, pwd, nsd.uid, LOGIN_SETALL) != 0)
			log_msg(LOG_WARNING, "unable to setusercontext %s: %s",
				nsd.username, strerror(errno));
#else /* !HAVE_SETUSERCONTEXT */
a1021 1
#endif /* HAVE_SETUSERCONTEXT */
@


1.6
log
@resolve conflicts from import of v3.2.5
@
text
@a44 1
#ifdef TSIG
a45 1
#endif /* TSIG */
d64 6
a69 6
		"  -4              Only listen to IPv4 connections.\n"
		"  -6              Only listen to IPv6 connections.\n"
		"  -a ip-address   Listen to the specified incoming IP address (may be\n"
		"                  specified multiple times).\n"
		"  -c configfile   Read specified configfile instead of %s.\n"
		"  -d              Enable debug mode (do not fork as a daemon process).\n"
d71 1
a71 1
		"  -F facilities   Specify the debug facilities.\n"
d73 2
a74 2
		"  -f database     Specify the database to load.\n"
		"  -h              Print this help information.\n"
d77 2
a78 4
		"  -i identity     Specify the identity when queried for id.server CHAOS TXT.\n"
#ifdef NSID
		"  -I nsid         Specify the NSID. This must be a hex string.\n"
#endif /* NSID */
d80 1
a80 1
		"  -L level        Specify the debug level.\n"
d82 7
a88 7
		"  -l filename     Specify the log file.\n"
		"  -N server-count The number of servers to start.\n"
		"  -n tcp-count    The maximum number of TCP connections per server.\n"
		"  -P pidfile      Specify the PID file to write.\n"
		"  -p port         Specify the port to listen to.\n"
		"  -s seconds      Dump statistics every SECONDS seconds.\n"
		"  -t chrootdir    Change root to specified directory on startup.\n"
d91 3
a93 3
		"  -u user         Change effective uid to the specified user.\n"
		"  -V level        Specify verbosity level.\n"
		"  -v              Print version information.\n"
d143 17
a480 1
#ifdef NSID
a492 1
#endif /* NSID */
a693 1
#ifdef NSID
a703 1

d708 1
a708 1
#endif /* NSID */
d761 2
d767 1
d770 1
a770 1
		if ((r=getaddrinfo(nodes[i], udp_port, &hints[i], &nsd.udp[i].addr)) != 0) {
d785 1
a785 1
		if ((r=getaddrinfo(nodes[i], tcp_port, &hints[i], &nsd.tcp[i].addr)) != 0) {
a827 1
#ifdef TSIG
d830 1
d832 1
a832 1
#endif /* TSIG */
@


1.5
log
@exit if paths are not relative to chroot
@
text
@d489 1
a489 1
				error("number of child servers must be greather than zero.");
d653 2
a654 1
	if(nsd.chrootdir == 0) nsd.chrootdir = strdup(CHROOTDIR);
d683 11
a694 2

#ifdef NSID
a821 7
	/* Set up the logging */
	log_open(LOG_PID, FACILITY, nsd.log_filename);
	if (!nsd.log_filename)
		log_set_log_function(log_syslog);
	else if (nsd.uid && nsd.gid)
		(void) chown(nsd.log_filename, nsd.uid, nsd.gid);

d849 7
@


1.4
log
@better default chroot
@
text
@d833 1
a833 1
			log_msg(LOG_ERR, "%s is not relative to %s: will not chroot",
a834 1
			nsd.chrootdir = NULL;
d836 1
a836 1
			log_msg(LOG_ERR, "%s is not relative to %s: will not chroot",
a837 1
			nsd.chrootdir = NULL;
d839 1
a839 1
			log_msg(LOG_ERR, "%s is not relative to %s: will not chroot",
a840 1
			nsd.chrootdir = NULL;
d842 1
a842 1
			log_msg(LOG_ERR, "%s is not relative to %s: will not chroot",
a843 1
			nsd.chrootdir = NULL;
@


1.3
log
@strcpy/strncat/sprintf --> strlcpy/strlcat/snprintf

ok jakob@@
@
text
@d652 1
d654 1
@


1.2
log
@add --with-chroot option to set default chroot directory
@
text
@d825 1
a825 1
			strncat(chroot_slash, "/", 1);
@


1.1
log
@Initial revision
@
text
@d652 1
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.5
@
text
@d489 1
a489 1
				error("number of child servers must be greater than zero.");
a651 4
#ifdef CHROOTDIR
	/* if still no chrootdir, fallback to default */
	if(nsd.chrootdir == 0) nsd.chrootdir = CHROOTDIR;
#endif /* CHROOTDIR */
d679 2
a681 11
	if (nsd.nsid_len == 0 && nsd.options->nsid) {
		if (strlen(nsd.options->nsid) % 2 != 0) {
			error("the NSID must be a hex string of an even length.");
		}
		nsd.nsid = xalloc(strlen(nsd.options->nsid) / 2);
		nsd.nsid_len = strlen(nsd.options->nsid) / 2;
		if (hex_pton(nsd.options->nsid, nsd.nsid, nsd.nsid_len) == -1) {
			error("hex string cannot be parsed '%s' in NSID.", nsd.options->nsid);
		}
	}

d809 7
d824 1
a824 1
			strlcat(chroot_slash, "/", sizeof(char)*(l+2));
d830 1
a830 1
			error("%s is not relative to %s: chroot not possible",
d832 1
d834 1
a834 1
			error("%s is not relative to %s: chroot not possible",
d836 1
d838 1
a838 1
			error("%s is not relative to %s: chroot not possible",
d840 1
d842 1
a842 1
			error("%s is not relative to %s: chroot not possible",
d844 1
a846 7

	/* Set up the logging */
	log_open(LOG_PID, FACILITY, nsd.log_filename);
	if (!nsd.log_filename)
		log_set_log_function(log_syslog);
	else if (nsd.uid && nsd.gid)
		(void) chown(nsd.log_filename, nsd.uid, nsd.gid);
@


1.1.1.3
log
@NSD v3.2.6
@
text
@d45 1
d47 1
d66 6
a71 6
		"  -4                   Only listen to IPv4 connections.\n"
		"  -6                   Only listen to IPv6 connections.\n"
		"  -a ip-address[@@port] Listen to the specified incoming IP address (and port)\n"
		"                       May be specified multiple times).\n"
		"  -c configfile        Read specified configfile instead of %s.\n"
		"  -d                   Enable debug mode (do not fork as a daemon process).\n"
d73 1
a73 1
		"  -F facilities        Specify the debug facilities.\n"
d75 2
a76 2
		"  -f database          Specify the database to load.\n"
		"  -h                   Print this help information.\n"
d79 4
a82 2
		"  -i identity          Specify the identity when queried for id.server CHAOS TXT.\n"
		"  -I nsid              Specify the NSID. This must be a hex string.\n"
d84 1
a84 1
		"  -L level             Specify the debug level.\n"
d86 7
a92 7
		"  -l filename          Specify the log file.\n"
		"  -N server-count      The number of servers to start.\n"
		"  -n tcp-count         The maximum number of TCP connections per server.\n"
		"  -P pidfile           Specify the PID file to write.\n"
		"  -p port              Specify the port to listen to.\n"
		"  -s seconds           Dump statistics every SECONDS seconds.\n"
		"  -t chrootdir         Change root to specified directory on startup.\n"
d95 3
a97 3
		"  -u user              Change effective uid to the specified user.\n"
		"  -V level             Specify verbosity level.\n"
		"  -v                   Print version information.\n"
a146 17
void
get_ip_port_frm_str(const char* arg, const char** hostname,
        const char** port)
{
        /* parse src[@@port] option */
        char* delim = NULL;
	if (arg) {
		delim = strchr(arg, '@@');
	}

        if (delim) {
                *delim = '\0';
                *port = delim+1;
        }
        *hostname = arg;
}

d468 1
d481 1
d683 1
d694 1
d699 1
a699 1

a751 2
		const char* node = NULL;
		const char* service = NULL;
a755 1
		get_ip_port_frm_str(nodes[i], &node, &service);
d758 1
a758 1
		if ((r=getaddrinfo(node, (service?service:udp_port), &hints[i], &nsd.udp[i].addr)) != 0) {
d773 1
a773 1
		if ((r=getaddrinfo(node, (service?service:tcp_port), &hints[i], &nsd.tcp[i].addr)) != 0) {
d816 1
a818 1
#if defined(HAVE_SSL)
d820 1
a820 1
#endif
@


1.1.1.4
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
d109 1
a109 1
		"Copyright (C) 2001-2011 NLnet Labs.  This is free software.\n"
d953 1
a953 15
	/* Set user context */
#ifdef HAVE_GETPWNAM
	if (*nsd.username) {
#ifdef HAVE_SETUSERCONTEXT
		/* setusercontext does initgroups, setuid, setgid, and
		 * also resource limits from login config, but we
		 * still call setresuid, setresgid to be sure to set all uid */
		if (setusercontext(NULL, pwd, nsd.uid,
			LOGIN_SETALL & ~LOGIN_SETUSER & ~LOGIN_SETGROUP) != 0)
			log_msg(LOG_WARNING, "unable to setusercontext %s: %s",
				nsd.username, strerror(errno));
#endif /* HAVE_SETUSERCONTEXT */
	}
#endif /* HAVE_GETPWNAM */

a954 1
#ifdef HAVE_CHROOT
d1004 9
a1012 1
#ifdef HAVE_INITGROUPS
d1016 2
a1017 1
#endif /* HAVE_INITGROUPS */
d1042 1
a1042 1
	}
@


1.1.1.5
log
@NSD v3.2.9
@
text
@d493 1
a493 1
			break;
d866 2
a867 5
	else if (nsd.uid && nsd.gid) {
		if(chown(nsd.log_filename, nsd.uid, nsd.gid) != 0)
			VERBOSITY(2, (LOG_WARNING, "chown %s failed: %s",
				nsd.log_filename, strerror(errno)));
	}
@


1.1.1.6
log
@import nsd 3.2.10, "cool" jakob@@, also looked over by Brad
@
text
@d238 3
a240 12
	int fd = -1;

	if (file) {
		/* truncate pidfile */
		fd = open(file, O_WRONLY | O_TRUNC, 0644);
		if (fd != -1)
			close(fd);
		/* unlink pidfile */
		if (unlink(file) == -1)
			log_msg(LOG_WARNING, "failed to unlink pidfile %s: %s",
				file, strerror(errno));
	}
d387 2
a388 3
	/* static so it can get very big without overflowing the stack */
	static struct addrinfo hints[MAX_INTERFACES];
	static const char *nodes[MAX_INTERFACES];
@


1.1.1.7
log
@NSD v3.2.11, ok phessler@@
@
text
@d10 1
a10 1
#include "config.h"
a43 1
#include "namedb.h"
a320 54

#ifdef USE_ZONE_STATS
static void
fprintf_zone_stats(FILE* fd, zone_type* zone, time_t now)
{
	int i;

	/* NSTATS */
	fprintf(fd, "NSTATS %s %lu",
		dname_to_string(domain_dname(zone->apex),0),
		(unsigned long) now);

	for (i = 0; i <= 255; i++) {
		if (zone->st.qtype[i] != 0) {
			fprintf(fd, " %s=%lu", rrtype_to_string(i),
				zone->st.qtype[i]);
		}
	}
	fprintf(fd, "\n");

	/* XSTATS */
	fprintf(fd, "XSTATS %s %lu"
		" RR=%lu RNXD=%lu RFwdR=%lu RDupR=%lu RFail=%lu RFErr=%lu RErr=%lu RAXFR=%lu"
		" RLame=%lu ROpts=%lu SSysQ=%lu SAns=%lu SFwdQ=%lu SDupQ=%lu SErr=%lu RQ=%lu"
		" RIQ=%lu RFwdQ=%lu RDupQ=%lu RTCP=%lu SFwdR=%lu SFail=%lu SFErr=%lu SNaAns=%lu"
		" SNXD=%lu RUQ=%lu RURQ=%lu RUXFR=%lu RUUpd=%lu\n",
		dname_to_string(domain_dname(zone->apex),0),
		(unsigned long) now,
		zone->st.dropped,
		(unsigned long)0, (unsigned long)0,
		(unsigned long)0, (unsigned long)0,
		(unsigned long)0, (unsigned long)0,
		zone->st.raxfr,
		(unsigned long)0, (unsigned long)0,
		(unsigned long)0,
		zone->st.qudp + zone->st.qudp6 - zone->st.dropped,
		(unsigned long)0, (unsigned long)0,
		zone->st.txerr,
		zone->st.opcode[OPCODE_QUERY],
		zone->st.opcode[OPCODE_IQUERY],
		zone->st.wrongzone,
		(unsigned long)0,
		zone->st.ctcp + zone->st.ctcp6,
		(unsigned long)0,
		zone->st.rcode[RCODE_SERVFAIL],
		zone->st.rcode[RCODE_FORMAT],
		zone->st.nona,
		zone->st.rcode[RCODE_NXDOMAIN],
		(unsigned long)0, (unsigned long)0,
		(unsigned long)0,
		zone->st.opcode[OPCODE_UPDATE]);
}
#endif

a323 4
#ifdef USE_ZONE_STATS
	FILE* fd;
	zone_type* zone;
#endif
a375 17
#ifdef USE_ZONE_STATS
	/* ZSTATS */
	log_msg(LOG_INFO, "ZSTATS %s", nsd->zonestatsfile);
	if ((fd = fopen(nsd->zonestatsfile, "a")) ==  NULL ) {
		log_msg(LOG_ERR, "cannot open zone statsfile %s: %s",
			nsd->zonestatsfile, strerror(errno));
		return;
	}
	/* Write stats per zone */
	zone = nsd->db->zones;
	while (zone) {
		fprintf_zone_stats(fd, zone, now);
		zone = zone->next;
	}
	fclose(fd);
#endif

a413 3
#ifdef USE_ZONE_STATS
	nsd.zonestatsfile = 0;
#endif
a669 5
#ifdef USE_ZONE_STATS
	if (nsd.zonestatsfile == 0) {
		nsd.zonestatsfile = nsd.options->zonestatsfile;
	}
#endif /* USE_ZONE_STATS */
@


1.1.1.8
log
@update to NSD 3.2.14, requested by/ok brad@@
@
text
@d192 1
a192 1
	pid = (pid_t) strtol(pidbuf, &t, 10);
a1085 4
#ifdef HAVE_TZSET
		/* set timezone whilst not yet in chroot */
		tzset();
#endif
a1087 4
			exit(1);
		}
		if (chdir("/")) {
			log_msg(LOG_ERR, "unable to chdir to chroot: %s", strerror(errno));
@


1.1.1.9
log
@Update to NSD 3.2.15, ok brad@@ phessler@@ deraadt@@ also tested by okan@@
@
text
@d468 1
a468 1
	struct passwd *pwd = NULL;
@


1.1.1.10
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@d244 1
a244 4
		if (fd == -1) {
			/* Truncate the pid file.  */
			log_msg(LOG_ERR, "can not truncate the pid file %s: %s", file, strerror(errno));
		} else 
a245 1

a388 2
	if(!nsd->st.period)
		return;
d482 1
a482 1
	log_init(argv0);
a952 3
		} else if (strncmp(nsd.chrootdir, nsd.options->zonesdir, l) != 0) {
			error("%s is not relative to %s: chroot not possible",
				nsd.options->zonesdir, nsd.chrootdir);
a983 31
	/* Setup the signal handling... */
	action.sa_handler = sig_handler;
	sigfillset(&action.sa_mask);
	action.sa_flags = 0;
	sigaction(SIGTERM, &action, NULL);
	sigaction(SIGHUP, &action, NULL);
	sigaction(SIGINT, &action, NULL);
	sigaction(SIGILL, &action, NULL);
	sigaction(SIGUSR1, &action, NULL);
	sigaction(SIGALRM, &action, NULL);
	sigaction(SIGCHLD, &action, NULL);
	action.sa_handler = SIG_IGN;
	sigaction(SIGPIPE, &action, NULL);

	/* Initialize... */
	nsd.mode = NSD_RUN;
	nsd.signal_hint_child = 0;
	nsd.signal_hint_reload = 0;
	nsd.signal_hint_quit = 0;
	nsd.signal_hint_shutdown = 0;
	nsd.signal_hint_stats = 0;
	nsd.signal_hint_statsusr = 0;
	nsd.quit_sync_done = 0;

	/* Initialize the server... */
	if (server_init(&nsd) != 0) {
		log_msg(LOG_ERR, "server initialization failed, %s could "
			"not be started", argv0);
		exit(1);
	}

a994 2
			server_close_all_sockets(nsd.udp, nsd.ifs);
			server_close_all_sockets(nsd.tcp, nsd.ifs);
a997 2
			server_close_all_sockets(nsd.udp, nsd.ifs);
			server_close_all_sockets(nsd.tcp, nsd.ifs);
d1016 14
d1033 17
a1084 1
		nsd.options->zonesdir += l;
a1099 9
		/* chdir to zonesdir again after chroot */
		if(nsd.options->zonesdir && nsd.options->zonesdir[0]) {
			if(chdir(nsd.options->zonesdir)) {
				error("unable to chdir to '%s': %s",
					nsd.options->zonesdir, strerror(errno));
			}
			DEBUG(DEBUG_IPC,1, (LOG_INFO, "changed directory to %s",
				nsd.options->zonesdir));
		}
@


1.1.1.11
log
@import NSD 4.0.0, tests from Dorian Bttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d44 1
a46 1
#include "remote.h"
a50 1
extern config_parser_state_t* cfg_parser;
d70 1
a70 1
		"  -d                   do not fork as a daemon process.\n"
d110 1
a110 1
		"Copyright (C) 2001-2006 NLnet Labs.  This is free software.\n"
a129 13
static void
append_trailing_slash(const char** dirname, region_type* region)
{
	int l = strlen(*dirname);
	if (l>0 && (*dirname)[l-1] != '/') {
		char *dirname_slash = region_alloc(region, l+2);
		memcpy(dirname_slash, *dirname, l+1);
		strlcat(dirname_slash, "/", l+2);
		/* old dirname is leaked, this is only used for chroot, once */
		*dirname = dirname_slash;
	}
}

d133 9
a141 3
	/* true if filename starts with chroot or is not absolute */
	return ((fname && fname[0] && strncmp(fname, chr, strlen(chr)) == 0) ||
		(fname && fname[0] != '/'));
d294 1
a294 1
		nsd.signal_hint_reload_hup = 1;
d311 3
d326 54
d383 4
d398 2
a399 2
	t = msg = buf + snprintf(buf, MAXSYSLOGMSGLEN, "NSTATS %lld %lu",
				 (long long) now, (unsigned long) nsd->st.boot);
d424 1
a424 1
		log_msg(LOG_INFO, "XSTATS %lld %lu"
d429 1
a429 1
			(long long) now, (unsigned long) nsd->st.boot,
d441 17
d472 1
d496 3
a667 2
	if(!tsig_init(nsd.region))
		error("init tsig failed");
d670 2
a671 4
	nsd.options = nsd_options_create(region_create_custom(xalloc, free,
		DEFAULT_CHUNK_SIZE, DEFAULT_LARGE_OBJECT_SIZE,
		DEFAULT_INITIAL_CLEANUP_SIZE, 1));
	if(!parse_options_file(nsd.options, configfile, NULL, NULL)) {
d674 1
a674 5
	if(!parse_zone_list_file(nsd.options)) {
		error("could not read zonelist file %s\n",
			nsd.options->zonelistfile);
	}
	if(nsd.options->do_ip4 && !nsd.options->do_ip6) {
d680 1
a680 1
	if(nsd.options->do_ip6 && !nsd.options->do_ip4) {
d755 5
d822 2
d928 2
d934 4
a937 3
	append_trailing_slash(&nsd.options->xfrdir, nsd.options->region);
	/* Check relativity of pathnames to chroot */
	if (nsd.chrootdir && nsd.chrootdir[0]) {
d939 7
a945 2
		append_trailing_slash(&nsd.chrootdir, nsd.region);
		append_trailing_slash(&nsd.options->zonesdir, nsd.options->region);
d947 2
a948 7
		/* zonesdir must be absolute and within chroot,
		 * all other pathnames may be relative to zonesdir */
		if (strncmp(nsd.options->zonesdir, nsd.chrootdir, strlen(nsd.chrootdir)) != 0) {
			error("zonesdir %s is not relative to %s: chroot not possible",
				nsd.options->zonesdir, nsd.chrootdir);
		} else if (!file_inside_chroot(nsd.pidfile, nsd.chrootdir)) {
			error("pidfile %s is not relative to %s: chroot not possible",
d950 2
a951 2
		} else if (!file_inside_chroot(nsd.dbfile, nsd.chrootdir)) {
			error("database %s is not relative to %s: chroot not possible",
d953 2
a954 2
		} else if (!file_inside_chroot(nsd.options->xfrdfile, nsd.chrootdir)) {
			error("xfrdfile %s is not relative to %s: chroot not possible",
d956 6
a961 6
		} else if (!file_inside_chroot(nsd.options->zonelistfile, nsd.chrootdir)) {
			error("zonelistfile %s is not relative to %s: chroot not possible",
				nsd.options->zonelistfile, nsd.chrootdir);
		} else if (!file_inside_chroot(nsd.options->xfrdir, nsd.chrootdir)) {
			error("xfrdir %s is not relative to %s: chroot not possible",
				nsd.options->xfrdir, nsd.chrootdir);
a1010 1
	nsd.signal_hint_reload_hup = 0;
d1019 1
a1019 1
		error("server initialization failed, %s could "
d1021 1
a1022 7
#if defined(HAVE_SSL)
	if(nsd.options->control_enable) {
		/* read ssl keys while superuser and outside chroot */
		if(!(nsd.rc = daemon_remote_create(nsd.options)))
			error("could not perform remote control setup");
	}
#endif /* HAVE_SSL */
d1034 4
a1037 1
			error("fork() failed: %s", strerror(errno));
d1047 2
a1048 1
			error("setsid() failed: %s", strerror(errno));
d1080 10
a1089 4
	if (nsd.chrootdir && nsd.chrootdir[0]) {
		int l = strlen(nsd.chrootdir)-1; /* ends in trailing slash */

		if (file_inside_chroot(nsd.log_filename, nsd.chrootdir))
d1091 1
a1091 5

		/* strip chroot from pathnames if they're absolute */
		nsd.options->zonesdir += l;
		if (nsd.log_filename){
			if (nsd.log_filename[0] == '/')
d1094 5
a1098 14
		if (nsd.pidfile[0] == '/')
			nsd.pidfile += l;
		if (nsd.dbfile[0] == '/')
			nsd.dbfile += l;
		if (nsd.options->xfrdfile[0] == '/')
			nsd.options->xfrdfile += l;
		if (nsd.options->zonelistfile[0] == '/')
			nsd.options->zonelistfile += l;
		if (nsd.options->xfrdir[0] == '/')
			nsd.options->xfrdir += l;

		/* strip chroot from pathnames of "include:" statements
		 * on subsequent repattern commands */
		cfg_parser->chroot = nsd.chrootdir;
d1105 2
a1106 1
			error("unable to chroot: %s", strerror(errno));
d1109 2
a1110 1
			error("unable to chdir to chroot: %s", strerror(errno));
d1131 7
a1178 6
	if(nsd.server_kind == NSD_SERVER_MAIN) {
		server_prepare_xfrd(&nsd);
		/* xfrd forks this before reading database, so it does not get
		 * the memory size of the database */
		server_start_xfrd(&nsd, 0, 0);
	}
d1180 2
d1183 1
a1183 5
		error("server preparation failed, %s could "
			"not be started", argv0);
	}
	if(nsd.server_kind == NSD_SERVER_MAIN) {
		server_send_soa_xfrd(&nsd, 0);
@


1.1.1.12
log
@update to NSD 4.0.1, ok sthen@@
@
text
@d506 7
a512 13
			if (strncasecmp(optarg, "ascii_", 6) == 0) {
				nsd.nsid = xalloc(strlen(optarg+6));
				nsd.nsid_len = strlen(optarg+6);
				memmove(nsd.nsid, optarg+6, nsd.nsid_len);
			} else {
				if (strlen(optarg) % 2 != 0) {
					error("the NSID must be a hex string of an even length.");
				}
				nsd.nsid = xalloc(strlen(optarg) / 2);
				nsd.nsid_len = strlen(optarg) / 2;
				if (hex_pton(optarg, nsd.nsid, nsd.nsid_len) == -1) {
					error("hex string cannot be parsed '%s' in NSID.", optarg);
				}
@


1.1.1.13
log
@update to NSD 4.1.0, ok sthen@@
@
text
@d49 1
a49 1
struct nsd nsd;
@


1.1.1.14
log
@update to NSD 4.1.1, ok sthen@@
@
text
@d832 1
a832 1
		if (isdigit((unsigned char)*nsd.username)) {
d836 1
a836 1
				if (*t != '.' || !isdigit((unsigned char)*++t)) {
d875 1
a875 1
			error("zonesdir %s has to be an absolute path that starts with the chroot path %s",
a1108 4
#ifdef USE_ZONE_STATS
	options_zonestatnames_create(nsd.options);
	server_zonestat_alloc(&nsd);
#endif /* USE_ZONE_STATS */
@


1.1.1.15
log
@update to NSD 4.1.3, ok florian@@, also tested by brad
@
text
@a46 1
#include "xfrd-disk.h"
d135 1
a135 1
	if (l>0 && (*dirname)[l-1] != '/' && l < 0xffffff) {
d745 2
a746 2
	nsd.children = (struct nsd_child *) region_alloc_array(
		nsd.region, nsd.child_count, sizeof(struct nsd_child));
a1108 1
	xfrd_make_tempdir(&nsd);
@


1.1.1.16
log
@update to NSD 4.1.6, ok millert@@ florian@@
@
text
@a169 22
/* append interface to interface array (names, udp, tcp) */
void
add_interface(char*** nodes, struct nsd* nsd, char* ip)
{
	/* realloc the arrays */
	if(nsd->ifs == 0) {
		*nodes = xalloc_zero(sizeof(*nodes));
		nsd->udp = xalloc_zero(sizeof(*nsd->udp));
		nsd->tcp = xalloc_zero(sizeof(*nsd->udp));
	} else {
		*nodes = xrealloc(*nodes, (nsd->ifs+1)*sizeof(*nodes));
		nsd->udp = xrealloc(nsd->udp, (nsd->ifs+1)*sizeof(*nsd->udp));
		nsd->tcp = xrealloc(nsd->tcp, (nsd->ifs+1)*sizeof(*nsd->udp));
		(*nodes)[nsd->ifs] = NULL;
		memset(&nsd->udp[nsd->ifs], 0, sizeof(*nsd->udp));
		memset(&nsd->tcp[nsd->ifs], 0, sizeof(*nsd->tcp));
	}

	/* add it */
	(*nodes)[nsd->ifs] = ip;
	++nsd->ifs;
}
d407 4
a410 3
	struct addrinfo hints[2];
	int hints_in_use = 1;
	char** nodes = NULL; /* array of address strings, size nsd.ifs */
d426 8
a433 5
	memset(&hints, 0, sizeof(*hints)*2);
	hints[0].ai_family = DEFAULT_AI_FAMILY;
	hints[0].ai_flags = AI_PASSIVE;
	hints[1].ai_family = DEFAULT_AI_FAMILY;
	hints[1].ai_flags = AI_PASSIVE;
d457 1
d466 3
a468 1
			hints[0].ai_family = AF_INET;
d472 3
a474 1
			hints[0].ai_family = AF_INET6;
d480 6
a485 1
			add_interface(&nodes, &nsd, optarg);
d616 3
a618 1
		hints[0].ai_family = AF_INET;
d622 3
a624 1
		hints[0].ai_family = AF_INET6;
d631 8
a638 1
			add_interface(&nodes, &nsd, ip->address);
a673 5
#ifdef SO_REUSEPORT
	if(nsd.options->reuseport && nsd.child_count > 1) {
		nsd.reuseport = nsd.child_count;
	}
#endif /* SO_REUSEPORT */
d764 1
a764 1
		add_interface(&nodes, &nsd, NULL);
a780 1
			add_interface(&nodes, &nsd, NULL);
d783 1
a783 1
			hints_in_use = 2;
a796 1
		int h = ((hints_in_use == 1)?0:i%hints_in_use);
d800 1
a800 1
			hints[h].ai_flags |= AI_NUMERICHOST;
d803 2
a804 2
		hints[h].ai_socktype = SOCK_DGRAM;
		if ((r=getaddrinfo(node, (service?service:udp_port), &hints[h], &nsd.udp[i].addr)) != 0) {
d818 2
a819 2
		hints[h].ai_socktype = SOCK_STREAM;
		if ((r=getaddrinfo(node, (service?service:tcp_port), &hints[h], &nsd.tcp[i].addr)) != 0) {
@


