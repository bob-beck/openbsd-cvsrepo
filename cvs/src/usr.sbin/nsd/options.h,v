head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.2
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.4.0.2
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	NSD_4_1_6:1.1.1.13
	OPENBSD_5_8:1.1.1.12.0.6
	OPENBSD_5_8_BASE:1.1.1.12
	NSD_4_1_3:1.1.1.12
	OPENBSD_5_7:1.1.1.12.0.2
	OPENBSD_5_7_BASE:1.1.1.12
	NSD_4_1_1:1.1.1.12
	NSD_4_1_0:1.1.1.11
	OPENBSD_5_6:1.1.1.10.0.6
	OPENBSD_5_6_BASE:1.1.1.10
	NSD_4_0_3:1.1.1.10
	NSD_4_0_2:1.1.1.10
	OPENBSD_5_5:1.1.1.10.0.4
	OPENBSD_5_5_BASE:1.1.1.10
	NSD_4_0_1:1.1.1.10
	NSD_4_0_0:1.1.1.9
	NSD_3_2_16:1.1.1.8
	OPENBSD_5_4:1.1.1.7.0.4
	OPENBSD_5_4_BASE:1.1.1.7
	OPENBSD_5_3:1.1.1.7.0.2
	OPENBSD_5_3_BASE:1.1.1.7
	NSD_3_2_15:1.1.1.7
	NSD_3_2_14:1.1.1.6
	NSD_3_2_13:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.2
	OPENBSD_5_2_BASE:1.1.1.5
	NSD_3_2_11:1.1.1.5
	NSD_3_2_10:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.4
	NSD_3_2_9:1.1.1.4
	OPENBSD_5_0:1.1.1.4.0.2
	OPENBSD_5_0_BASE:1.1.1.4
	NSD_3_2_8:1.1.1.4
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	NSD_3_2_6:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.2
	OPENBSD_4_8_BASE:1.1.1.2
	NSD_3_2_5:1.1.1.2
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.6;
commitid	WmSuN5M3Jbe54113;

1.6
date	2016.10.24.09.44.43;	author florian;	state Exp;
branches;
next	1.5;
commitid	g3wASIhTcujU0LFi;

1.5
date	2016.08.31.07.31.20;	author florian;	state Exp;
branches;
next	1.4;
commitid	1gMwFuybgH2l617m;

1.4
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.3;
commitid	Z9jVKJJMPmC3zw2t;

1.3
date	2015.12.11.12.28.49;	author sthen;	state Exp;
branches;
next	1.2;
commitid	e67Hx722TeF4XpDl;

1.2
date	2015.12.09.00.36.26;	author sthen;	state Exp;
branches;
next	1.1;
commitid	oFaRJS86oPhcC6P7;

1.1
date	2010.01.15.19.24.53;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.53;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.04.15.20.56.49;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.08.22.09.21.36;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.05.21.18.17.10;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.07.09.21.55.06;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.11.23.20.29.16;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.02.18.10.17.41;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.09.03.09.21.33;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.11.26.12.50.18;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.02.04.01.54.06;	author brad;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.09.16.16.54.02;	author brad;	state Exp;
branches;
next	1.1.1.12;
commitid	BWSdZeElrpYSRdME;

1.1.1.12
date	2015.02.03.10.24.31;	author brad;	state Exp;
branches;
next	1.1.1.13;
commitid	yn8l9RVkmdMVYIfl;

1.1.1.13
date	2015.11.05.21.21.05;	author sthen;	state Exp;
branches;
next	;
commitid	RXfGmPAh2IZTjnIf;


desc
@@


1.7
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * options.h -- nsd.conf options definitions and prototypes
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#ifndef OPTIONS_H
#define OPTIONS_H

#include "config.h"
#include <stdarg.h>
#include "region-allocator.h"
#include "rbtree.h"
struct query;
struct dname;
struct tsig_key;
struct buffer;
struct nsd;

typedef struct nsd_options nsd_options_type;
typedef struct pattern_options pattern_options_type;
typedef struct zone_options zone_options_type;
typedef struct ip_address_option ip_address_option_type;
typedef struct acl_options acl_options_type;
typedef struct key_options key_options_type;
typedef struct config_parser_state config_parser_state_type;
/*
 * Options global for nsd.
 */
struct nsd_options {
	/* config file name */
	char* configfile;
	/* options for zones, by apex, contains zone_options */
	rbtree_type* zone_options;
	/* patterns, by name, contains pattern_options */
	rbtree_type* patterns;

	/* free space in zonelist file, contains zonelist_bucket */
	rbtree_type* zonefree;
	/* number of free space lines in zonelist file */
	size_t zonefree_number;
	/* zonelist file if open */
	FILE* zonelist;
	/* last offset in file (or 0 if none) */
	off_t zonelist_off;

	/* tree of zonestat names and their id values, entries are struct
	 * zonestatname with malloced key=stringname. The number of items
	 * is the max statnameid, no items are freed from this. 
	 * kept correct in the xfrd process, and on startup. */
	rbtree_type* zonestatnames;

	/* rbtree of keys defined, by name */
	rbtree_type* keys;

	/* list of ip addresses to bind to (or NULL for all) */
	struct ip_address_option* ip_addresses;

	int ip_transparent;
	int ip_freebind;
	int debug_mode;
	int verbosity;
	int hide_version;
	int do_ip4;
	int do_ip6;
	const char* database;
	const char* identity;
	const char* version;
	const char* logfile;
	int server_count;
	int tcp_count;
	int tcp_query_count;
	int tcp_timeout;
	int tcp_mss;
	int outgoing_tcp_mss;
	size_t ipv4_edns_size;
	size_t ipv6_edns_size;
	const char* pidfile;
	const char* port;
	int statistics;
	const char* chroot;
	const char* username;
	const char* zonesdir;
	const char* xfrdfile;
	const char* xfrdir;
	const char* zonelistfile;
	const char* nsid;
	int xfrd_reload_timeout;
	int zonefiles_check;
	int zonefiles_write;
	int log_time_ascii;
	int round_robin;
	int reuseport;

        /** remote control section. enable toggle. */
	int control_enable;
	/** the interfaces the remote control should listen on */
	struct ip_address_option* control_interface;
	/** port number for the control port */
	int control_port;
	/** private key file for server */
	char* server_key_file;
	/** certificate file for server */
	char* server_cert_file;
	/** private key file for nsd-control */
	char* control_key_file;
	/** certificate file for nsd-control */
	char* control_cert_file;

#ifdef RATELIMIT
	/** number of buckets in rrl hashtable */
	size_t rrl_size;
	/** max qps for queries, 0 is nolimit */
	size_t rrl_ratelimit;
	/** ratio of slipped responses, 0 is noslip */
	size_t rrl_slip;
	/** ip prefix length */
	size_t rrl_ipv4_prefix_length;
	size_t rrl_ipv6_prefix_length;
	/** max qps for whitelisted queries, 0 is nolimit */
	size_t rrl_whitelist_ratelimit;
#endif

	region_type* region;
};

struct ip_address_option {
	struct ip_address_option* next;
	char* address;
};

/*
 * Pattern of zone options, used to contain options for zone(s).
 */
struct pattern_options {
	rbnode_type node;
	const char* pname; /* name of the pattern, key of rbtree */
	const char* zonefile;
	struct acl_options* allow_notify;
	struct acl_options* request_xfr;
	struct acl_options* notify;
	struct acl_options* provide_xfr;
	struct acl_options* outgoing_interface;
	const char* zonestats;
#ifdef RATELIMIT
	uint16_t rrl_whitelist; /* bitmap with rrl types */
#endif
	uint8_t allow_axfr_fallback;
	uint8_t allow_axfr_fallback_is_default;
	uint8_t notify_retry;
	uint8_t notify_retry_is_default;
	uint8_t implicit; /* pattern is implicit, part_of_config zone used */
	uint8_t xfrd_flags;
	uint32_t max_refresh_time;
	uint8_t max_refresh_time_is_default;
	uint32_t min_refresh_time;
	uint8_t min_refresh_time_is_default;
	uint32_t max_retry_time;
	uint8_t max_retry_time_is_default;
	uint32_t min_retry_time;
	uint8_t min_retry_time_is_default;
	uint64_t size_limit_xfr;
	uint8_t multi_master_check;
};

#define PATTERN_IMPLICIT_MARKER "_implicit_"

/*
 * Options for a zone
 */
struct zone_options {
	/* key is dname of apex */
	rbnode_type node;

	/* is apex of the zone */
	const char* name;
	/* if not part of config, the offset and linesize of zonelist entry */
	off_t off;
	int linesize;
	/* pattern for the zone options, if zone is part_of_config, this is
	 * a anonymous pattern created in-place */
	struct pattern_options* pattern;
	/* zone is fixed into the main config, not in zonelist, cannot delete */
	uint8_t part_of_config;
};

union acl_addr_storage {
#ifdef INET6
	struct in_addr addr;
	struct in6_addr addr6;
#else
	struct in_addr addr;
#endif
};

/*
 * Access control list element
 */
struct acl_options {
	struct acl_options* next;

	/* options */
	time_t ixfr_disabled;
	int bad_xfr_count;
	uint8_t use_axfr_only;
	uint8_t allow_udp;

	/* ip address range */
	const char* ip_address_spec;
	uint8_t is_ipv6;
	unsigned int port;	/* is 0(no port) or suffix @@port value */
	union acl_addr_storage addr;
	union acl_addr_storage range_mask;
	enum {
		acl_range_single = 0,	/* single address */
		acl_range_mask = 1,	/* 10.20.30.40&255.255.255.0 */
		acl_range_subnet = 2,	/* 10.20.30.40/28 */
		acl_range_minmax = 3	/* 10.20.30.40-10.20.30.60 (mask=max) */
	} rangetype;

	/* key */
	uint8_t nokey;
	uint8_t blocked;
	const char* key_name;
	struct key_options* key_options;
};

/*
 * Key definition
 */
struct key_options {
	rbnode_type node; /* key of tree is name */
	char* name;
	char* algorithm;
	char* secret;
	struct tsig_key* tsig_key;
};

/** zone list free space */
struct zonelist_free {
	struct zonelist_free* next;
	off_t off;
};
/** zonelist free bucket for a particular line length */
struct zonelist_bucket {
	rbnode_type node; /* key is ptr to linesize */
	int linesize;
	struct zonelist_free* list;
};

/* default zonefile write interval if database is "", in seconds */
#define ZONEFILES_WRITE_INTERVAL 3600

struct zonestatname {
	rbnode_type node; /* key is malloced string with cooked zonestat name */
	unsigned id; /* index in nsd.zonestat array */
};

/*
 * Used during options parsing
 */
struct config_parser_state {
	char* filename;
	const char* chroot;
	int line;
	int errors;
	int server_settings_seen;
	struct nsd_options* opt;
	struct pattern_options* current_pattern;
	struct zone_options* current_zone;
	struct key_options* current_key;
	struct ip_address_option* current_ip_address_option;
	struct acl_options* current_allow_notify;
	struct acl_options* current_request_xfr;
	struct acl_options* current_notify;
	struct acl_options* current_provide_xfr;
	struct acl_options* current_outgoing_interface;
	void (*err)(void*,const char*);
	void* err_arg;
};

extern config_parser_state_type* cfg_parser;

/* region will be put in nsd_options struct. Returns empty options struct. */
struct nsd_options* nsd_options_create(region_type* region);
/* the number of zones that are configured */
static inline size_t nsd_options_num_zones(struct nsd_options* opt)
{ return opt->zone_options->count; }
/* insert a zone into the main options tree, returns 0 on error */
int nsd_options_insert_zone(struct nsd_options* opt, struct zone_options* zone);
/* insert a pattern into the main options tree, returns 0 on error */
int nsd_options_insert_pattern(struct nsd_options* opt,
	struct pattern_options* pat);

/* parses options file. Returns false on failure. callback, if nonNULL,
 * gets called with error strings, default prints. */
int parse_options_file(struct nsd_options* opt, const char* file,
	void (*err)(void*,const char*), void* err_arg);
struct zone_options* zone_options_create(region_type* region);
void zone_options_delete(struct nsd_options* opt, struct zone_options* zone);
/* find a zone by apex domain name, or NULL if not found. */
struct zone_options* zone_options_find(struct nsd_options* opt,
	const struct dname* apex);
struct pattern_options* pattern_options_create(region_type* region);
struct pattern_options* pattern_options_find(struct nsd_options* opt, const char* name);
int pattern_options_equal(struct pattern_options* p, struct pattern_options* q);
void pattern_options_remove(struct nsd_options* opt, const char* name);
void pattern_options_add_modify(struct nsd_options* opt,
	struct pattern_options* p);
void pattern_options_marshal(struct buffer* buffer, struct pattern_options* p);
struct pattern_options* pattern_options_unmarshal(region_type* r,
	struct buffer* b);
struct key_options* key_options_create(region_type* region);
void key_options_insert(struct nsd_options* opt, struct key_options* key);
struct key_options* key_options_find(struct nsd_options* opt, const char* name);
void key_options_remove(struct nsd_options* opt, const char* name);
int key_options_equal(struct key_options* p, struct key_options* q);
void key_options_add_modify(struct nsd_options* opt, struct key_options* key);
/* read in zone list file. Returns false on failure */
int parse_zone_list_file(struct nsd_options* opt);
/* create zone entry and add to the zonelist file */
struct zone_options* zone_list_add(struct nsd_options* opt, const char* zname,
	const char* pname);
/* create zonelist entry, do not insert in file (called by _add) */
struct zone_options* zone_list_zone_insert(struct nsd_options* opt,
	const char* nm, const char* patnm, int linesize, off_t off);
void zone_list_del(struct nsd_options* opt, struct zone_options* zone);
void zone_list_compact(struct nsd_options* opt);
void zone_list_close(struct nsd_options* opt);

/* create zonestat name tree , for initially created zones */
void options_zonestatnames_create(struct nsd_options* opt);
/* Get zonestat id for zone options, add new entry if necessary.
 * instantiates the pattern's zonestat string */
unsigned getzonestatid(struct nsd_options* opt, struct zone_options* zopt);
/* create string, same options as zonefile but no chroot changes */
const char* config_cook_string(struct zone_options* zone, const char* input);

#if defined(HAVE_SSL)
/* tsig must be inited, adds all keys in options to tsig. */
void key_options_tsig_add(struct nsd_options* opt);
#endif

/* check acl list, acl number that matches if passed(0..),
 * or failure (-1) if dropped */
/* the reason why (the acl) is returned too (or NULL) */
int acl_check_incoming(struct acl_options* acl, struct query* q,
	struct acl_options** reason);
int acl_addr_matches_host(struct acl_options* acl, struct acl_options* host);
int acl_addr_matches(struct acl_options* acl, struct query* q);
int acl_key_matches(struct acl_options* acl, struct query* q);
int acl_addr_match_mask(uint32_t* a, uint32_t* b, uint32_t* mask, size_t sz);
int acl_addr_match_range(uint32_t* minval, uint32_t* x, uint32_t* maxval, size_t sz);

/* returns true if acls are both from the same host */
int acl_same_host(struct acl_options* a, struct acl_options* b);
/* find acl by number in the list */
struct acl_options* acl_find_num(struct acl_options* acl, int num);

/* see if two acl lists are the same (same elements in same order, or empty) */
int acl_list_equal(struct acl_options* p, struct acl_options* q);
/* see if two acl are the same */
int acl_equal(struct acl_options* p, struct acl_options* q);

/* see if a zone is a slave or a master zone */
int zone_is_slave(struct zone_options* opt);
/* create zonefile name, returns static pointer (perhaps to options data) */
const char* config_make_zonefile(struct zone_options* zone, struct nsd* nsd);

#define ZONEC_PCT_TIME 5 /* seconds, then it starts to print pcts */
#define ZONEC_PCT_COUNT 100000 /* elements before pct check is done */

/* parsing helpers */
void c_error(const char* msg);
void c_error_msg(const char* fmt, ...) ATTR_FORMAT(printf, 1, 2);
struct acl_options* parse_acl_info(region_type* region, char* ip,
	const char* key);
/* true if ipv6 address, false if ipv4 */
int parse_acl_is_ipv6(const char* p);
/* returns range type. mask is the 2nd part of the range */
int parse_acl_range_type(char* ip, char** mask);
/* parses subnet mask, fills 0 mask as well */
void parse_acl_range_subnet(char* p, void* addr, int maxbits);
/* clean up options */
void nsd_options_destroy(struct nsd_options* opt);
/* replace occurrences of one with two in buf, pass length of buffer */
void replace_str(char* buf, size_t len, const char* one, const char* two);
/* apply pattern to the existing pattern in the parser */
void config_apply_pattern(const char* name);

#endif /* OPTIONS_H */
@


1.6
log
@Update to 4.1.13
Testing millert, brad and myself.
OK millert@@
@
text
@d23 7
a29 7
typedef struct nsd_options nsd_options_t;
typedef struct pattern_options pattern_options_t;
typedef struct zone_options zone_options_t;
typedef struct ipaddress_option ip_address_option_t;
typedef struct acl_options acl_options_t;
typedef struct key_options key_options_t;
typedef struct config_parser_state config_parser_state_t;
d36 4
a39 4
	/* options for zones, by apex, contains zone_options_t */
	rbtree_t* zone_options;
	/* patterns, by name, contains pattern_options_t */
	rbtree_t* patterns;
d42 1
a42 1
	rbtree_t* zonefree;
d54 1
a54 1
	rbtree_t* zonestatnames;
d57 1
a57 1
	rbtree_t* keys;
d60 1
a60 1
	ip_address_option_t* ip_addresses;
d101 1
a101 1
	ip_address_option_t* control_interface;
d130 2
a131 2
struct ipaddress_option {
	ip_address_option_t* next;
d139 1
a139 1
	rbnode_t node;
d142 5
a146 5
	acl_options_t* allow_notify;
	acl_options_t* request_xfr;
	acl_options_t* notify;
	acl_options_t* provide_xfr;
	acl_options_t* outgoing_interface;
d176 1
a176 1
	rbnode_t node;
d185 1
a185 1
	pattern_options_t* pattern;
d203 1
a203 1
	acl_options_t* next;
d228 1
a228 1
	key_options_t* key_options;
d235 1
a235 1
	rbnode_t node; /* key of tree is name */
d249 1
a249 1
	rbnode_t node; /* key is ptr to linesize */
d258 1
a258 1
	rbnode_t node; /* key is malloced string with cooked zonestat name */
d271 10
a280 10
	nsd_options_t* opt;
	pattern_options_t* current_pattern;
	zone_options_t* current_zone;
	key_options_t* current_key;
	ip_address_option_t* current_ip_address_option;
	acl_options_t* current_allow_notify;
	acl_options_t* current_request_xfr;
	acl_options_t* current_notify;
	acl_options_t* current_provide_xfr;
	acl_options_t* current_outgoing_interface;
d285 1
a285 1
extern config_parser_state_t* cfg_parser;
d288 1
a288 1
nsd_options_t* nsd_options_create(region_type* region);
d290 1
a290 1
static inline size_t nsd_options_num_zones(nsd_options_t* opt)
d293 1
a293 1
int nsd_options_insert_zone(nsd_options_t* opt, zone_options_t* zone);
d295 2
a296 1
int nsd_options_insert_pattern(nsd_options_t* opt, pattern_options_t* pat);
d300 1
a300 1
int parse_options_file(nsd_options_t* opt, const char* file,
d302 2
a303 2
zone_options_t* zone_options_create(region_type* region);
void zone_options_delete(nsd_options_t* opt, zone_options_t* zone);
d305 17
a321 14
zone_options_t* zone_options_find(nsd_options_t* opt, const struct dname* apex);
pattern_options_t* pattern_options_create(region_type* region);
pattern_options_t* pattern_options_find(nsd_options_t* opt, const char* name);
int pattern_options_equal(pattern_options_t* p, pattern_options_t* q);
void pattern_options_remove(nsd_options_t* opt, const char* name);
void pattern_options_add_modify(nsd_options_t* opt, pattern_options_t* p);
void pattern_options_marshal(struct buffer* buffer, pattern_options_t* p);
pattern_options_t* pattern_options_unmarshal(region_type* r, struct buffer* b);
key_options_t* key_options_create(region_type* region);
void key_options_insert(nsd_options_t* opt, key_options_t* key);
key_options_t* key_options_find(nsd_options_t* opt, const char* name);
void key_options_remove(nsd_options_t* opt, const char* name);
int key_options_equal(key_options_t* p, key_options_t* q);
void key_options_add_modify(nsd_options_t* opt, key_options_t* key);
d323 1
a323 1
int parse_zone_list_file(nsd_options_t* opt);
d325 1
a325 1
zone_options_t* zone_list_add(nsd_options_t* opt, const char* zname,
d328 5
a332 5
zone_options_t* zone_list_zone_insert(nsd_options_t* opt, const char* nm,
	const char* patnm, int linesize, off_t off);
void zone_list_del(nsd_options_t* opt, zone_options_t* zone);
void zone_list_compact(nsd_options_t* opt);
void zone_list_close(nsd_options_t* opt);
d335 1
a335 1
void options_zonestatnames_create(nsd_options_t* opt);
d338 1
a338 1
unsigned getzonestatid(nsd_options_t* opt, zone_options_t* zopt);
d340 1
a340 1
const char* config_cook_string(zone_options_t* zone, const char* input);
d344 1
a344 1
void key_options_tsig_add(nsd_options_t* opt);
d350 5
a354 5
int acl_check_incoming(acl_options_t* acl, struct query* q,
	acl_options_t** reason);
int acl_addr_matches_host(acl_options_t* acl, acl_options_t* host);
int acl_addr_matches(acl_options_t* acl, struct query* q);
int acl_key_matches(acl_options_t* acl, struct query* q);
d359 1
a359 1
int acl_same_host(acl_options_t* a, acl_options_t* b);
d361 1
a361 1
acl_options_t* acl_find_num(acl_options_t* acl, int num);
d364 1
a364 1
int acl_list_equal(acl_options_t* p, acl_options_t* q);
d366 1
a366 1
int acl_equal(acl_options_t* p, acl_options_t* q);
d369 1
a369 1
int zone_is_slave(zone_options_t* opt);
d371 1
a371 1
const char* config_make_zonefile(zone_options_t* zone, struct nsd* nsd);
d379 2
a380 1
acl_options_t* parse_acl_info(region_type* region, char* ip, const char* key);
d388 1
a388 1
void nsd_options_destroy(nsd_options_t* opt);
@


1.5
log
@update to 4.1.11
"Working fine here." millert@@
OK dlg, sthen
@
text
@d166 1
@


1.4
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@d157 9
@


1.3
log
@update to NSD 4.1.7, ok florian@@
@
text
@d63 1
d77 2
@


1.2
log
@comment typo fixes, from nsd 4.1.7rc1
@
text
@d70 1
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
#include <config.h>
d20 2
d24 1
d34 2
d38 2
d41 14
a54 3
	/* list of keys defined */
	key_options_t* keys;
	size_t numkeys;
d56 4
a59 1
	/* list of ip adresses to bind to (or NULL for all) */
d62 1
d66 2
a67 2
	int ip4_only;
	int ip6_only;
a82 1
	const char* difffile;
d84 3
d88 34
d132 1
a132 1
 * Options for a zone
d134 1
a134 2
struct zone_options {
	/* key is dname of apex */
d136 1
a136 3

	/* is apex of the zone */
	const char* name;
d143 4
d148 1
d150 24
d192 2
a195 1
	time_t ixfr_disabled;
d204 1
a204 1
		acl_range_single = 0,	/* single adress */
d221 4
a224 5
	key_options_t* next;
	const char* name;
	const char* algorithm;
	const char* secret;
#ifdef TSIG
d226 20
a245 1
#endif
d252 2
a253 1
	const char* filename;
d256 1
d258 1
d267 2
d280 2
d283 4
a286 2
/* parses options file. Returns false on failure */
int parse_options_file(nsd_options_t* opt, const char* file);
d288 1
d291 7
d299 1
d301 24
d327 1
d334 1
d345 5
d352 5
d370 4
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.5
@
text
@a62 1
	const char* nsid;
@


1.1.1.3
log
@NSD v3.2.6
@
text
@d141 1
d143 1
a180 2

#if defined(HAVE_SSL)
a182 1
#endif
@


1.1.1.4
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.5
log
@NSD v3.2.11, ok phessler@@
@
text
@d13 1
a13 1
#include "config.h"
a57 1
	const char* zonestatsfile;
@


1.1.1.6
log
@update to NSD 3.2.14, requested by/ok brad@@
@
text
@a190 1
int acl_addr_matches_host(acl_options_t* acl, acl_options_t* host);
@


1.1.1.7
log
@Update to NSD 3.2.15, ok brad@@ phessler@@ deraadt@@ also tested by okan@@
@
text
@a66 9
#ifdef RATELIMIT
	/** number of buckets in rrl hashtable */
	size_t rrl_size;
	/** max qps for queries, 0 is nolimit */
	size_t rrl_ratelimit;
	/** max qps for whitelisted queries, 0 is nolimit */
	size_t rrl_whitelist_ratelimit;
#endif

a89 3
#ifdef RATELIMIT
	uint16_t rrl_whitelist; /* bitmap with rrl types */
#endif
@


1.1.1.8
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@a40 1
	int ip_transparent;
a71 5
	/** ratio of slipped responses, 0 is noslip */
	size_t rrl_slip;
	/** ip prefix length */
	size_t rrl_ipv4_prefix_length;
	size_t rrl_ipv6_prefix_length;
a124 1
	int bad_xfr_count;
@


1.1.1.9
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
a19 1
struct buffer;
a21 1
typedef struct pattern_options pattern_options_t;
a30 2
	/* config file name */
	char* configfile;
a32 2
	/* patterns, by name, contains pattern_options_t */
	rbtree_t* patterns;
d34 3
a36 11
	/* free space in zonelist file, contains zonelist_bucket */
	rbtree_t* zonefree;
	/* number of free space lines in zonelist file */
	size_t zonefree_number;
	/* zonelist file if open */
	FILE* zonelist;
	/* last offset in file (or 0 if none) */
	off_t zonelist_off;

	/* rbtree of keys defined, by name */
	rbtree_t* keys;
d45 2
a46 2
	int do_ip4;
	int do_ip6;
d59 1
d63 1
a64 2
	const char* xfrdir;
	const char* zonelistfile;
a66 16
	int zonefiles_check;

        /** remote control section. enable toggle. */
	int control_enable;
	/** the interfaces the remote control should listen on */
	ip_address_option_t* control_interface;
	/** port number for the control port */
	int control_port;
	/** private key file for server */
	char* server_key_file;
	/** certificate file for server */
	char* server_cert_file;
	/** private key file for nsd-control */
	char* control_key_file;
	/** certificate file for nsd-control */
	char* control_cert_file;
d91 1
a91 1
 * Pattern of zone options, used to contain options for zone(s).
d93 2
a94 1
struct pattern_options {
d96 3
a98 1
	const char* pname; /* name of the pattern, key of rbtree */
a108 1
	uint8_t allow_axfr_fallback_is_default;
a109 24
	uint8_t notify_retry_is_default;
	uint8_t implicit; /* pattern is implicit, part_of_config zone used */
	uint8_t xfrd_flags;
};

#define PATTERN_IMPLICIT_MARKER "_implicit_"

/*
 * Options for a zone
 */
struct zone_options {
	/* key is dname of apex */
	rbnode_t node;

	/* is apex of the zone */
	const char* name;
	/* if not part of config, the offset and linesize of zonelist entry */
	off_t off;
	int linesize;
	/* pattern for the zone options, if zone is part_of_config, this is
	 * a anonymous pattern created in-place */
	pattern_options_t* pattern;
	/* zone is fixed into the main config, not in zonelist, cannot delete */
	uint8_t part_of_config;
d128 2
a131 2
	uint8_t use_axfr_only;
	uint8_t allow_udp;
d157 4
a160 4
	rbnode_t node; /* key of tree is name */
	char* name;
	char* algorithm;
	char* secret;
a163 12
/** zone list free space */
struct zonelist_free {
	struct zonelist_free* next;
	off_t off;
};
/** zonelist free bucket for a particular line length */
struct zonelist_bucket {
	rbnode_t node; /* key is ptr to linesize */
	int linesize;
	struct zonelist_free* list;
};

a168 1
	const char* chroot;
a170 1
	int server_settings_seen;
a171 1
	pattern_options_t* current_pattern;
a179 2
	void (*err)(void*,const char*);
	void* err_arg;
a190 2
/* insert a pattern into the main options tree, returns 0 on error */
int nsd_options_insert_pattern(nsd_options_t* opt, pattern_options_t* pat);
d192 2
a193 4
/* parses options file. Returns false on failure. callback, if nonNULL,
 * gets called with error strings, default prints. */
int parse_options_file(nsd_options_t* opt, const char* file,
	void (*err)(void*,const char*), void* err_arg);
a194 1
void zone_options_delete(nsd_options_t* opt, zone_options_t* zone);
a196 7
pattern_options_t* pattern_options_create(region_type* region);
pattern_options_t* pattern_options_find(nsd_options_t* opt, const char* name);
int pattern_options_equal(pattern_options_t* p, pattern_options_t* q);
void pattern_options_remove(nsd_options_t* opt, const char* name);
void pattern_options_add_modify(nsd_options_t* opt, pattern_options_t* p);
void pattern_options_marshal(struct buffer* buffer, pattern_options_t* p);
pattern_options_t* pattern_options_unmarshal(region_type* r, struct buffer* b);
a197 1
void key_options_insert(nsd_options_t* opt, key_options_t* key);
a198 14
void key_options_remove(nsd_options_t* opt, const char* name);
int key_options_equal(key_options_t* p, key_options_t* q);
void key_options_add_modify(nsd_options_t* opt, key_options_t* key);
/* read in zone list file. Returns false on failure */
int parse_zone_list_file(nsd_options_t* opt);
/* create zone entry and add to the zonelist file */
zone_options_t* zone_list_add(nsd_options_t* opt, const char* zname,
	const char* pname);
/* create zonelist entry, do not insert in file (called by _add) */
zone_options_t* zone_list_zone_insert(nsd_options_t* opt, const char* nm,
	const char* patnm, int linesize, off_t off);
void zone_list_del(nsd_options_t* opt, zone_options_t* zone);
void zone_list_compact(nsd_options_t* opt);
void zone_list_close(nsd_options_t* opt);
a220 5
/* see if two acl lists are the same (same elements in same order, or empty) */
int acl_list_equal(acl_options_t* p, acl_options_t* q);
/* see if two acl are the same */
int acl_equal(acl_options_t* p, acl_options_t* q);

a222 5
/* create zonefile name, returns static pointer (perhaps to options data) */
const char* config_make_zonefile(zone_options_t* zone);

#define ZONEC_PCT_TIME 5 /* seconds, then it starts to print pcts */
#define ZONEC_PCT_COUNT 100000 /* elements before pct check is done */
a235 4
/* replace occurrences of one with two in buf, pass length of buffer */
void replace_str(char* buf, size_t len, const char* one, const char* two);
/* apply pattern to the existing pattern in the parser */
void config_apply_pattern(const char* name);
@


1.1.1.10
log
@update to NSD 4.0.1, ok sthen@@
@
text
@a20 1
struct nsd;
d325 1
a325 1
const char* config_make_zonefile(zone_options_t* zone, struct nsd* nsd);
@


1.1.1.11
log
@update to NSD 4.1.0, ok sthen@@
@
text
@a82 3
	int zonefiles_write;
	int log_time_ascii;
	int round_robin;
a228 3
/* default zonefile write interval if database is "", in seconds */
#define ZONEFILES_WRITE_INTERVAL 3600

d233 1
a233 1
	char* filename;
@


1.1.1.12
log
@update to NSD 4.1.1, ok sthen@@
@
text
@a49 6
	/* tree of zonestat names and their id values, entries are struct
	 * zonestatname with malloced key=stringname. The number of items
	 * is the max statnameid, no items are freed from this. 
	 * kept correct in the xfrd process, and on startup. */
	rbtree_t* zonestatnames;

a135 1
	const char* zonestats;
a234 5
struct zonestatname {
	rbnode_t node; /* key is malloced string with cooked zonestat name */
	unsigned id; /* index in nsd.zonestat array */
};

a301 8

/* create zonestat name tree , for initially created zones */
void options_zonestatnames_create(nsd_options_t* opt);
/* Get zonestat id for zone options, add new entry if necessary.
 * instantiates the pattern's zonestat string */
unsigned getzonestatid(nsd_options_t* opt, zone_options_t* zopt);
/* create string, same options as zonefile but no chroot changes */
const char* config_cook_string(zone_options_t* zone, const char* input);
@


1.1.1.13
log
@update to NSD 4.1.6, ok millert@@ florian@@
@
text
@a91 1
	int reuseport;
@


