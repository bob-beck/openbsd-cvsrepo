head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.8.0.10
	OPENBSD_6_1_BASE:1.1.1.8
	OPENBSD_6_0:1.1.1.8.0.6
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.2
	OPENBSD_5_9_BASE:1.1.1.8
	NSD_4_1_6:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.4
	OPENBSD_5_8_BASE:1.1.1.8
	NSD_4_1_3:1.1.1.8
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	NSD_4_1_1:1.1.1.7
	NSD_4_1_0:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.6
	OPENBSD_5_6_BASE:1.1.1.6
	NSD_4_0_3:1.1.1.6
	NSD_4_0_2:1.1.1.6
	OPENBSD_5_5:1.1.1.6.0.4
	OPENBSD_5_5_BASE:1.1.1.6
	NSD_4_0_1:1.1.1.6
	NSD_4_0_0:1.1.1.5
	NSD_3_2_16:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.4
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.2
	OPENBSD_5_3_BASE:1.1.1.4
	NSD_3_2_15:1.1.1.4
	NSD_3_2_14:1.1.1.3
	NSD_3_2_13:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.4
	OPENBSD_5_2_BASE:1.1.1.3
	NSD_3_2_11:1.1.1.3
	NSD_3_2_10:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.2
	NSD_3_2_9:1.1.1.3
	OPENBSD_5_0:1.1.1.2.0.2
	OPENBSD_5_0_BASE:1.1.1.2
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2010.01.15.19.24.53;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.53;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.24;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.01.29.11.15.41;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.02.18.10.17.43;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.11.26.12.50.17;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.02.04.01.54.05;	author brad;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.09.16.16.54.02;	author brad;	state Exp;
branches;
next	1.1.1.8;
commitid	BWSdZeElrpYSRdME;

1.1.1.8
date	2015.07.17.17.36.01;	author sthen;	state Exp;
branches;
next	;
commitid	Jeq5uGP63ff7nS9K;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * packet.c -- low-level DNS packet encoding and decoding functions.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include <config.h>

#include <string.h>

#include "packet.h"
#include "query.h"
#include "rdata.h"

static void
encode_dname(query_type *q, domain_type *domain)
{
	while (domain->parent && query_get_dname_offset(q, domain) == 0) {
		query_put_dname_offset(q, domain, buffer_position(q->packet));
		DEBUG(DEBUG_NAME_COMPRESSION, 2,
		      (LOG_INFO, "dname: %s, number: %lu, offset: %u\n",
		       dname_to_string(domain_dname(domain), NULL),
		       (unsigned long) domain->number,
		       query_get_dname_offset(q, domain)));
		buffer_write(q->packet, dname_name(domain_dname(domain)),
			     label_length(dname_name(domain_dname(domain))) + 1U);
		domain = domain->parent;
	}
	if (domain->parent) {
		DEBUG(DEBUG_NAME_COMPRESSION, 2,
		      (LOG_INFO, "dname: %s, number: %lu, pointer: %u\n",
		       dname_to_string(domain_dname(domain), NULL),
		       (unsigned long) domain->number,
		       query_get_dname_offset(q, domain)));
		assert(query_get_dname_offset(q, domain) <= MAX_COMPRESSION_OFFSET);
		buffer_write_u16(q->packet,
				 0xc000 | query_get_dname_offset(q, domain));
	} else {
		buffer_write_u8(q->packet, 0);
	}
}

int
packet_encode_rr(query_type *q, domain_type *owner, rr_type *rr)
{
	size_t truncation_mark;
	uint16_t rdlength = 0;
	size_t rdlength_pos;
	uint16_t j;

	assert(q);
	assert(owner);
	assert(rr);

	/*
	 * If the record does not in fit in the packet the packet size
	 * will be restored to the mark.
	 */
	truncation_mark = buffer_position(q->packet);

	encode_dname(q, owner);
	buffer_write_u16(q->packet, rr->type);
	buffer_write_u16(q->packet, rr->klass);
	buffer_write_u32(q->packet, rr->ttl);

	/* Reserve space for rdlength. */
	rdlength_pos = buffer_position(q->packet);
	buffer_skip(q->packet, sizeof(rdlength));

	for (j = 0; j < rr->rdata_count; ++j) {
		switch (rdata_atom_wireformat_type(rr->type, j)) {
		case RDATA_WF_COMPRESSED_DNAME:
			encode_dname(q, rdata_atom_domain(rr->rdatas[j]));
			break;
		case RDATA_WF_UNCOMPRESSED_DNAME:
		{
			const dname_type *dname = domain_dname(
				rdata_atom_domain(rr->rdatas[j]));
			buffer_write(q->packet,
				     dname_name(dname), dname->name_size);
			break;
		}
		default:
			buffer_write(q->packet,
				     rdata_atom_data(rr->rdatas[j]),
				     rdata_atom_size(rr->rdatas[j]));
			break;
		}
	}

	if (!query_overflow(q)) {
		rdlength = (buffer_position(q->packet) - rdlength_pos
			    - sizeof(rdlength));
		buffer_write_u16_at(q->packet, rdlength_pos, rdlength);
		return 1;
	} else {
		buffer_set_position(q->packet, truncation_mark);
		query_clear_dname_offsets(q, truncation_mark);
		assert(!query_overflow(q));
		return 0;
	}
}

int
packet_encode_rrset(query_type *query,
		    domain_type *owner,
		    rrset_type *rrset,
		    int section)
{
	uint16_t i;
	size_t truncation_mark;
	uint16_t added = 0;
	int all_added = 1;
	int truncate_rrset = (section == ANSWER_SECTION ||
							section == AUTHORITY_SECTION);
	rrset_type *rrsig;

	assert(rrset->rr_count > 0);

	truncation_mark = buffer_position(query->packet);

	for (i = 0; i < rrset->rr_count; ++i) {
		if (packet_encode_rr(query, owner, &rrset->rrs[i])) {
			++added;
		} else {
			all_added = 0;
			break;
		}
	}

	if (all_added &&
	    query->edns.dnssec_ok &&
	    zone_is_secure(rrset->zone) &&
	    rrset_rrtype(rrset) != TYPE_RRSIG &&
	    (rrsig = domain_find_rrset(owner, rrset->zone, TYPE_RRSIG)))
	{
		for (i = 0; i < rrsig->rr_count; ++i) {
			if (rr_rrsig_type_covered(&rrsig->rrs[i])
			    == rrset_rrtype(rrset))
			{
				if (packet_encode_rr(query, owner,
						     &rrsig->rrs[i]))
				{
					++added;
				} else {
					all_added = 0;
					break;
				}
			}
		}
	}

	if (!all_added && truncate_rrset) {
		/* Truncate entire RRset and set truncate flag. */
		buffer_set_position(query->packet, truncation_mark);
		query_clear_dname_offsets(query, truncation_mark);
		TC_SET(query->packet);
		added = 0;
	}

	return added;
}

int
packet_skip_dname(buffer_type *packet)
{
	while (1) {
		uint8_t label_size;
		if (!buffer_available(packet, 1))
			return 0;

		label_size = buffer_read_u8(packet);
		if (label_size == 0) {
			return 1;
		} else if ((label_size & 0xc0) != 0) {
			if (!buffer_available(packet, 1))
				return 0;
			buffer_skip(packet, 1);
			return 1;
		} else if (!buffer_available(packet, label_size)) {
			return 0;
		} else {
			buffer_skip(packet, label_size);
		}
	}
}

int
packet_skip_rr(buffer_type *packet, int question_section)
{
	if (!packet_skip_dname(packet))
		return 0;

	if (question_section) {
		if (!buffer_available(packet, 4))
			return 0;
		buffer_skip(packet, 4);
	} else {
		uint16_t rdata_size;
		if (!buffer_available(packet, 10))
			return 0;
		buffer_skip(packet, 8);
		rdata_size = buffer_read_u16(packet);
		if (!buffer_available(packet, rdata_size))
			return 0;
		buffer_skip(packet, rdata_size);
	}

	return 1;
}

rr_type *
packet_read_rr(region_type *region, domain_table_type *owners,
	       buffer_type *packet, int question_section)
{
	const dname_type *owner;
	uint16_t rdlength;
	ssize_t rdata_count;
	rdata_atom_type *rdatas;
	rr_type *result = (rr_type *) region_alloc(region, sizeof(rr_type));

	owner = dname_make_from_packet(region, packet, 1, 1);
	if (!owner || !buffer_available(packet, 2*sizeof(uint16_t))) {
		return NULL;
	}

	result->owner = domain_table_insert(owners, owner);
	result->type = buffer_read_u16(packet);
	result->klass = buffer_read_u16(packet);

	if (question_section) {
		result->ttl = 0;
		result->rdata_count = 0;
		result->rdatas = NULL;
		return result;
	} else if (!buffer_available(packet, sizeof(uint32_t) + sizeof(uint16_t))) {
		return NULL;
	}

	result->ttl = buffer_read_u32(packet);
	rdlength = buffer_read_u16(packet);

	if (!buffer_available(packet, rdlength)) {
		return NULL;
	}

	rdata_count = rdata_wireformat_to_rdata_atoms(
		region, owners, result->type, rdlength, packet, &rdatas);
	if (rdata_count == -1) {
		return NULL;
	}
	result->rdata_count = rdata_count;
	result->rdatas = rdatas;

	return result;
}

int packet_read_query_section(buffer_type *packet,
	uint8_t* dst, uint16_t* qtype, uint16_t* qclass)
{
	uint8_t *query_name = buffer_current(packet);
	uint8_t *src = query_name;
	size_t len;

	while (*src) {
		/*
		 * If we are out of buffer limits or we have a pointer
		 * in question dname or the domain name is longer than
		 * MAXDOMAINLEN ...
		 */
		if ((*src & 0xc0) ||
		    (src + *src + 2 > buffer_end(packet)) ||
		    (src + *src + 2 > query_name + MAXDOMAINLEN))
		{
			return 0;
		}
		memcpy(dst, src, *src + 1);
		dst += *src + 1;
		src += *src + 1;
	}
	*dst++ = *src++;

	/* Make sure name is not too long or we have stripped packet... */
	len = src - query_name;
	if (len > MAXDOMAINLEN ||
	    (src + 2*sizeof(uint16_t) > buffer_end(packet)))
	{
		return 0;
	}
	buffer_set_position(packet, src - buffer_begin(packet));

	*qtype = buffer_read_u16(packet);
	*qclass = buffer_read_u16(packet);
	return 1;
}
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.3
log
@NSD v3.2.9
@
text
@d111 1
a111 8
		    int section,
#ifdef MINIMAL_RESPONSES
		    size_t minimal_respsize,
		    int* done)
#else
		    size_t ATTR_UNUSED(minimal_respsize),
		    int* ATTR_UNUSED(done))
#endif
a116 2
#ifdef MINIMAL_RESPONSES
	int minimize_response = (section >= OPTIONAL_AUTHORITY_SECTION);
d118 1
a118 6
				section == AUTHORITY_SECTION);
#else
	int truncate_rrset = (section == ANSWER_SECTION ||
				section == AUTHORITY_SECTION ||
				section == OPTIONAL_AUTHORITY_SECTION);
#endif
a154 11

#ifdef MINIMAL_RESPONSES
	if ((!all_added || buffer_position(query->packet) > minimal_respsize)
	    && !query->tcp && minimize_response) {
		/* Truncate entire RRset. */
		buffer_set_position(query->packet, truncation_mark);
		query_clear_dname_offsets(query, truncation_mark);
		added = 0;
		*done = 1;
	}
#endif
@


1.1.1.4
log
@Update to NSD 3.2.15, ok brad@@ phessler@@ deraadt@@ also tested by okan@@
@
text
@d10 1
a10 1
#include "config.h"
@


1.1.1.5
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d25 1
a25 1
		       domain_to_string(domain),
d35 1
a35 1
		       domain_to_string(domain),
@


1.1.1.6
log
@update to NSD 4.0.1, ok sthen@@
@
text
@d47 1
a47 1
packet_encode_rr(query_type *q, domain_type *owner, rr_type *rr, uint32_t ttl)
d67 1
a67 1
	buffer_write_u32(q->packet, ttl);
d140 1
a140 2
		if (packet_encode_rr(query, owner, &rrset->rrs[i],
			rrset->rrs[i].ttl)) {
d159 1
a159 2
					&rrsig->rrs[i],
					rrset_rrtype(rrset)==TYPE_SOA?rrset->rrs[0].ttl:rrsig->rrs[i].ttl))
@


1.1.1.7
log
@update to NSD 4.1.0, ok sthen@@
@
text
@a17 2
int round_robin = 0;

a132 4
	static int round_robin_off = 0;
	int do_robin = (round_robin && section == ANSWER_SECTION &&
		query->qtype != TYPE_AXFR && query->qtype != TYPE_IXFR);
	uint16_t start;
d139 1
a139 14
	if(do_robin && rrset->rr_count)
		start = (uint16_t)(round_robin_off++ % rrset->rr_count);
	else	start = 0;
	for (i = start; i < rrset->rr_count; ++i) {
		if (packet_encode_rr(query, owner, &rrset->rrs[i],
			rrset->rrs[i].ttl)) {
			++added;
		} else {
			all_added = 0;
			start = 0;
			break;
		}
	}
	for (i = 0; i < start; ++i) {
@


1.1.1.8
log
@update to NSD 4.1.3, ok florian@@, also tested by brad
@
text
@a344 54

int packet_find_notify_serial(buffer_type *packet, uint32_t* serial)
{
	size_t saved_position = buffer_position(packet);
	/* count of further RRs after question section */
	size_t rrcount = ANCOUNT(packet) + NSCOUNT(packet) + ARCOUNT(packet);
	size_t i;
	buffer_set_position(packet, QHEADERSZ);

	/* skip all question RRs */
	for (i = 0; i < QDCOUNT(packet); ++i) {
		if (!packet_skip_rr(packet, 1)) {
			buffer_set_position(packet, saved_position);
			return 0;
		}
	}

	/* Find the SOA RR */
	for(i = 0; i < rrcount; i++) {
		uint16_t rdata_size;
		if (!packet_skip_dname(packet))
			break;
		/* check length available for type,class,ttl,rdatalen */
		if (!buffer_available(packet, 10))
			break;
		/* check type, class */
		if(buffer_read_u16(packet) == TYPE_SOA) {
			if(buffer_read_u16(packet) != CLASS_IN)
				break;
			buffer_skip(packet, 4); /* skip ttl */
			rdata_size = buffer_read_u16(packet);
			if (!buffer_available(packet, rdata_size))
				break;
			/* skip two dnames, then serial */
			if (!packet_skip_dname(packet) ||
				!packet_skip_dname(packet))
				break;
			if (!buffer_available(packet, 4))
				break;
			*serial = buffer_read_u32(packet);
			buffer_set_position(packet, saved_position);
			return 1;
		}
		/* continue to next RR */
		buffer_skip(packet, 6);
		rdata_size = buffer_read_u16(packet);
		if (!buffer_available(packet, rdata_size))
			break;
		buffer_skip(packet, rdata_size);
	}
	/* failed to find SOA */
	buffer_set_position(packet, saved_position);
	return 0;
}
@


