head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.6
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.3.0.8
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	NSD_4_1_6:1.1.1.10
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	NSD_4_1_3:1.1.1.10
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	NSD_4_1_1:1.1.1.10
	NSD_4_1_0:1.1.1.9
	OPENBSD_5_6:1.1.1.8.0.4
	OPENBSD_5_6_BASE:1.1.1.8
	NSD_4_0_3:1.1.1.8
	NSD_4_0_2:1.1.1.8
	OPENBSD_5_5:1.1.1.7.0.4
	OPENBSD_5_5_BASE:1.1.1.7
	NSD_4_0_1:1.1.1.7
	NSD_4_0_0:1.1.1.7
	NSD_3_2_16:1.1.1.6
	OPENBSD_5_4:1.1.1.5.0.4
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.2
	OPENBSD_5_3_BASE:1.1.1.5
	NSD_3_2_15:1.1.1.5
	NSD_3_2_14:1.1.1.5
	NSD_3_2_13:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.2
	OPENBSD_5_2_BASE:1.1.1.4
	NSD_3_2_11:1.1.1.4
	NSD_3_2_10:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.4
	NSD_3_2_9:1.1.1.3
	OPENBSD_5_0:1.1.1.3.0.2
	OPENBSD_5_0_BASE:1.1.1.3
	NSD_3_2_8:1.1.1.3
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	NSD_3_2_6:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.5;
commitid	WmSuN5M3Jbe54113;

1.5
date	2017.01.17.06.21.41;	author florian;	state Exp;
branches;
next	1.4;
commitid	6d948iJ1oT7IPB23;

1.4
date	2016.10.24.09.44.43;	author florian;	state Exp;
branches;
next	1.3;
commitid	g3wASIhTcujU0LFi;

1.3
date	2015.02.03.10.40.02;	author brad;	state Exp;
branches;
next	1.2;
commitid	MI9j0d0LR8Dk9lnd;

1.2
date	2014.12.18.23.26.13;	author brad;	state Exp;
branches;
next	1.1;
commitid	rBaz3dZHAQwIDT3j;

1.1
date	2010.01.15.19.24.57;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.57;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.08.22.09.21.45;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.05.21.18.17.24;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.11.23.20.29.20;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.09.03.09.21.37;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.11.26.12.50.15;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.13.02.00.25;	author brad;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.09.16.16.54.01;	author brad;	state Exp;
branches;
next	1.1.1.10;
commitid	BWSdZeElrpYSRdME;

1.1.1.10
date	2015.02.03.10.24.29;	author brad;	state Exp;
branches;
next	;
commitid	yn8l9RVkmdMVYIfl;


desc
@@


1.6
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * xfrd.h - XFR (transfer) Daemon header file. Coordinates SOA updates.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#ifndef XFRD_H
#define XFRD_H

#ifndef USE_MINI_EVENT
#  ifdef HAVE_EVENT_H
#    include <event.h>
#  else
#    include <event2/event.h>
#    include "event2/event_struct.h"
#    include "event2/event_compat.h"
#  endif
#else
#  include "mini_event.h"
#endif
#include "rbtree.h"
#include "namedb.h"
#include "options.h"
#include "dns.h"
#include "tsig.h"

struct nsd;
struct region;
struct buffer;
struct xfrd_tcp;
struct xfrd_tcp_set;
struct notify_zone;
struct udb_ptr;
typedef struct xfrd_state xfrd_state_type;
typedef struct xfrd_zone xfrd_zone_type;
typedef struct xfrd_soa xfrd_soa_type;
/*
 * The global state for the xfrd daemon process.
 * The time_t times are epochs in secs since 1970, absolute times.
 */
struct xfrd_state {
	/* time when daemon was last started */
	time_t xfrd_start_time;
	struct region* region;
	struct event_base* event_base;
	struct nsd* nsd;

	struct xfrd_tcp_set* tcp_set;
	/* packet buffer for udp packets */
	struct buffer* packet;
	/* udp waiting list, double linked list */
	struct xfrd_zone *udp_waiting_first, *udp_waiting_last;
	/* number of udp sockets (for sending queries) in use */
	size_t udp_use_num;
	/* activated waiting list, double linked list */
	struct xfrd_zone *activated_first;

	/* current time is cached */
	uint8_t got_time;
	time_t current_time;

	/* counter for xfr file numbers */
	uint64_t xfrfilenumber;

	/* the zonestat array size that we last saw and is safe to use */
	unsigned zonestat_safe;
	/* size currently of the clear array */
	size_t zonestat_clear_num;
	/* array of malloced entries with cumulative cleared stat values */
	struct nsdst** zonestat_clear;

	/* timer for NSD reload */
	struct timeval reload_timeout;
	struct event reload_handler;
	int reload_added;
	/* last reload must have caught all zone updates before this time */
	time_t reload_cmd_last_sent;
	uint8_t can_send_reload;
	pid_t reload_pid;
	/* timeout for lost sigchild and reaping children */
	struct event child_timer;
	int child_timer_added;

	/* timeout event for zonefiles_write events */
	struct event write_timer;
	/* set to 1 if zones have received xfrs since the last write_timer */
	int write_zonefile_needed;

	/* communication channel with server_main */
	struct event ipc_handler;
	int ipc_handler_flags;
	struct xfrd_tcp *ipc_conn;
	struct buffer* ipc_pass;
	/* sending ipc to server_main */
	uint8_t need_to_send_shutdown;
	uint8_t need_to_send_reload;
	uint8_t need_to_send_stats;
	uint8_t need_to_send_quit;
	uint8_t	ipc_send_blocked;
	struct udb_ptr* last_task;

	/* xfrd shutdown flag */
	uint8_t shutdown;

	/* tree of zones, by apex name, contains xfrd_zone_type*. Only secondary zones. */
	rbtree_type *zones;

	/* tree of zones, by apex name, contains notify_zone*. All zones. */
	rbtree_type *notify_zones;
	/* number of notify_zone active using UDP socket */
	int notify_udp_num;
	/* first and last notify_zone* entries waiting for a UDP socket */
	struct notify_zone *notify_waiting_first, *notify_waiting_last;
};

/*
 * XFR daemon SOA information kept in network format.
 * This is in packet order.
 */
struct xfrd_soa {
	/* name of RR is zone apex dname */
	uint16_t type; /* = TYPE_SOA */
	uint16_t klass; /* = CLASS_IN */
	uint32_t ttl;
	uint16_t rdata_count; /* = 7 */
	/* format is 1 octet length, + wireformat dname.
	   one more octet since parse_dname_wire_from_packet needs it.
	   maximum size is allocated to avoid memory alloc/free. */
	uint8_t prim_ns[MAXDOMAINLEN + 2];
	uint8_t email[MAXDOMAINLEN + 2];
	uint32_t serial;
	uint32_t refresh;
	uint32_t retry;
	uint32_t expire;
	uint32_t minimum;
};


/*
 * XFRD state for a single zone
 */
struct xfrd_zone {
	rbnode_type node;

	/* name of the zone */
	const dname_type* apex;
	const char* apex_str;

	/* Three types of soas:
	 * NSD: in use by running server
	 * disk: stored on disk in db/diff file
	 * notified: from notification, could be available on a master.
	 * And the time the soa was acquired (start time for timeouts).
	 * If the time==0, no SOA is available.
	 */
	xfrd_soa_type soa_nsd;
	time_t soa_nsd_acquired;
	xfrd_soa_type soa_disk;
	time_t soa_disk_acquired;
	xfrd_soa_type soa_notified;
	time_t soa_notified_acquired;

	enum xfrd_zone_state {
		xfrd_zone_ok,
		xfrd_zone_refreshing,
		xfrd_zone_expired
	} state;

	/* master to try to transfer from, number for persistence */
	struct acl_options* master;
	int master_num;
	int next_master; /* -1 or set by notify where to try next */
	/* round of xfrattempts, -1 is waiting for timeout */
	int round_num;
	struct zone_options* zone_options;
	int fresh_xfr_timeout;

	/* handler for timeouts */
	struct timeval timeout;
	struct event zone_handler;
	int zone_handler_flags;
	int event_added;

	/* tcp connection zone is using, or -1 */
	int tcp_conn;
	/* zone is waiting for a tcp connection */
	uint8_t tcp_waiting;
	/* next zone in waiting list */
	xfrd_zone_type* tcp_waiting_next;
	xfrd_zone_type* tcp_waiting_prev;
	/* zone is in its tcp send queue */
	uint8_t in_tcp_send;
	/* next zone in tcp send queue */
	xfrd_zone_type* tcp_send_next;
	xfrd_zone_type* tcp_send_prev;
	/* zone is waiting for a udp connection (tcp is preferred) */
	uint8_t udp_waiting;
	/* next zone in waiting list for UDP */
	xfrd_zone_type* udp_waiting_next;
	xfrd_zone_type* udp_waiting_prev;
	/* zone has been activated to run now (after the other events
	 * but before blocking in select again) */
	uint8_t is_activated;
	xfrd_zone_type* activated_next;
	xfrd_zone_type* activated_prev;

	/* xfr message handling data */
	/* query id */
	uint16_t query_id;
	uint32_t msg_seq_nr; /* number of messages already handled */
	uint32_t msg_old_serial, msg_new_serial; /* host byte order */
	size_t msg_rr_count;
	uint8_t msg_is_ixfr; /* 1:IXFR detected. 2:middle IXFR SOA seen. */
	tsig_record_type tsig; /* tsig state for IXFR/AXFR */
	uint64_t xfrfilenumber; /* identifier for file to store xfr into,
				valid if msg_seq_nr nonzero */
	int multi_master_first_master; /* >0: first check master_num */
	int multi_master_update_check; /* -1: not update >0: last update master_num */
};

enum xfrd_packet_result {
	xfrd_packet_bad, /* drop the packet/connection */
	xfrd_packet_drop, /* drop the connection, but not report bad */
	xfrd_packet_more, /* more packets to follow on tcp */
	xfrd_packet_notimpl, /* server responded with NOTIMPL or FORMATERR */
	xfrd_packet_tcp, /* try tcp connection */
	xfrd_packet_transfer, /* server responded with transfer*/
	xfrd_packet_newlease /* no changes, soa OK */
};

/*
   Division of the (portably: 1024) max number of sockets that can be open.
   The sum of the below numbers should be below the user limit for sockets
   open, or you see errors in your logfile.
   And it should be below FD_SETSIZE, to be able to select() on replies.
   Note that also some sockets are used for writing the ixfr.db, xfrd.state
   files and for the pipes to the main parent process.
*/
#define XFRD_MAX_TCP 32 /* max number of TCP AXFR/IXFR concurrent connections.*/
			/* Each entry has 64Kb buffer preallocated.*/
#define XFRD_MAX_UDP 64 /* max number of UDP sockets at a time for IXFR */
#define XFRD_MAX_UDP_NOTIFY 64 /* max concurrent UDP sockets for NOTIFY */

#define XFRD_TRANSFER_TIMEOUT_START 10 /* empty zone timeout is between x and 2*x seconds */
#define XFRD_TRANSFER_TIMEOUT_MAX 86400 /* empty zone timeout max expbackoff */

extern xfrd_state_type* xfrd;

/* start xfrd, new start. Pass socket to server_main. */
void xfrd_init(int socket, struct nsd* nsd, int shortsoa, int reload_active,
	pid_t nsd_pid);

/* add new slave zone, dname(from zone_opt) and given options */
void xfrd_init_slave_zone(xfrd_state_type* xfrd, struct zone_options* zone_opt);

/* delete slave zone */
void xfrd_del_slave_zone(xfrd_state_type* xfrd, const dname_type* dname);

/* disable ixfr for a while for zone->master */
void xfrd_disable_ixfr(xfrd_zone_type* zone);

/* get the current time epoch. Cached for speed. */
time_t xfrd_time(void);

/*
 * Handle final received packet from network.
 * returns enum of packet discovery results
 */
enum xfrd_packet_result xfrd_handle_received_xfr_packet(
	xfrd_zone_type* zone, buffer_type* packet);

/* set timer to specific value */
void xfrd_set_timer(xfrd_zone_type* zone, time_t t);
/* set refresh timer of zone to refresh at time now */
void xfrd_set_refresh_now(xfrd_zone_type* zone);
/* unset the timer - no more timeouts, for when zone is queued */
void xfrd_unset_timer(xfrd_zone_type* zone);
/* remove the 'refresh now', remove it from the activated list */
void xfrd_deactivate_zone(xfrd_zone_type* z);

/*
 * Make a new request to next master server.
 * uses next_master if set (and a fresh set of rounds).
 * otherwised, starts new round of requests if none started already.
 * starts next round of requests if at last master.
 * if too many rounds of requests, sets timer for next retry.
 */
void xfrd_make_request(xfrd_zone_type* zone);

/*
 * send packet via udp (returns UDP fd source socket) to acl addr.
 * returns -1 on failure.
 */
int xfrd_send_udp(struct acl_options* acl, buffer_type* packet,
	struct acl_options* ifc);

/*
 * read from udp port packet into buffer, returns 0 on failure
 */
int xfrd_udp_read_packet(buffer_type* packet, int fd);

/*
 * Release udp socket that a zone is using
 */
void xfrd_udp_release(xfrd_zone_type* zone);

/*
 * Get a static buffer for temporary use (to build a packet).
 */
struct buffer* xfrd_get_temp_buffer(void);

/*
 * TSIG sign outgoing request. Call if acl has a key.
 */
void xfrd_tsig_sign_request(buffer_type* packet, struct tsig_record* tsig,
        struct acl_options* acl);

/* handle incoming soa information (NSD is running it, time acquired=guess).
   Pass soa=NULL,acquired=now if NSD has nothing loaded for the zone
   (i.e. zonefile was deleted). */
void xfrd_handle_incoming_soa(xfrd_zone_type* zone, xfrd_soa_type* soa,
	time_t acquired);
/* handle a packet passed along ipc route. acl is the one that accepted
   the packet. The packet is the network blob received. acl_xfr is 
   provide-xfr acl matching notify sender or -1 */
void xfrd_handle_passed_packet(buffer_type* packet,
	int acl_num, int acl_xfr);

/* try to reopen the logfile. */
void xfrd_reopen_logfile(void);

/* free namedb for xfrd usage */
void xfrd_free_namedb(struct nsd* nsd);

/* copy SOA info from rr to soa struct. */
void xfrd_copy_soa(xfrd_soa_type* soa, rr_type* rr);

/* check for failed updates - it is assumed that now the reload has
   finished, and all zone SOAs have been sent. */
void xfrd_check_failed_updates(void);

/*
 * Prepare zones for a reload, this sets the times on the zones to be
 * before the current time, so the reload happens after.
 */
void xfrd_prepare_zones_for_reload(void);

/* Bind a local interface to a socket descriptor, return 1 on success */
int xfrd_bind_local_interface(int sockd, struct acl_options* ifc,
	struct acl_options* acl, int tcp);

/* process results and soa info from reload */
void xfrd_process_task_result(xfrd_state_type* xfrd, struct udb_base* taskudb);

/* set to reload right away (for user controlled reload events) */
void xfrd_set_reload_now(xfrd_state_type* xfrd);

/* send expiry notifications to nsd */
void xfrd_send_expire_notification(xfrd_zone_type* zone);

/* handle incoming notify (soa or NULL) and start zone xfr if necessary */
void xfrd_handle_notify_and_start_xfr(xfrd_zone_type* zone, xfrd_soa_type* soa);

/* handle zone timeout, event */
void xfrd_handle_zone(int fd, short event, void* arg);

const char* xfrd_pretty_time(time_t v);

#endif /* XFRD_H */
@


1.5
log
@Update to nsd 4.1.14
OK sthen@@
@
text
@d35 1
a35 1
struct notify_zone_t;
d37 3
a39 3
typedef struct xfrd_state xfrd_state_t;
typedef struct xfrd_zone xfrd_zone_t;
typedef struct xfrd_soa xfrd_soa_t;
d108 2
a109 2
	/* tree of zones, by apex name, contains xfrd_zone_t*. Only secondary zones. */
	rbtree_t *zones;
d111 3
a113 3
	/* tree of zones, by apex name, contains notify_zone_t*. All zones. */
	rbtree_t *notify_zones;
	/* number of notify_zone_t active using UDP socket */
d115 2
a116 2
	/* first and last notify_zone_t* entries waiting for a UDP socket */
	struct notify_zone_t *notify_waiting_first, *notify_waiting_last;
d146 1
a146 1
	rbnode_t node;
d159 1
a159 1
	xfrd_soa_t soa_nsd;
d161 1
a161 1
	xfrd_soa_t soa_disk;
d163 1
a163 1
	xfrd_soa_t soa_notified;
d173 1
a173 1
	acl_options_t* master;
d178 1
a178 1
	zone_options_t* zone_options;
d192 2
a193 2
	xfrd_zone_t* tcp_waiting_next;
	xfrd_zone_t* tcp_waiting_prev;
d197 2
a198 2
	xfrd_zone_t* tcp_send_next;
	xfrd_zone_t* tcp_send_prev;
d202 2
a203 2
	xfrd_zone_t* udp_waiting_next;
	xfrd_zone_t* udp_waiting_prev;
d207 2
a208 2
	xfrd_zone_t* activated_next;
	xfrd_zone_t* activated_prev;
d250 1
a250 1
extern xfrd_state_t* xfrd;
d257 1
a257 1
void xfrd_init_slave_zone(xfrd_state_t* xfrd, zone_options_t* zone_opt);
d260 1
a260 1
void xfrd_del_slave_zone(xfrd_state_t* xfrd, const dname_type* dname);
d263 1
a263 1
void xfrd_disable_ixfr(xfrd_zone_t* zone);
d273 1
a273 1
	xfrd_zone_t* zone, buffer_type* packet);
d276 1
a276 1
void xfrd_set_timer(xfrd_zone_t* zone, time_t t);
d278 1
a278 1
void xfrd_set_refresh_now(xfrd_zone_t* zone);
d280 1
a280 1
void xfrd_unset_timer(xfrd_zone_t* zone);
d282 1
a282 1
void xfrd_deactivate_zone(xfrd_zone_t* z);
d291 1
a291 1
void xfrd_make_request(xfrd_zone_t* zone);
d297 2
a298 1
int xfrd_send_udp(acl_options_t* acl, buffer_type* packet, acl_options_t* ifc);
d308 1
a308 1
void xfrd_udp_release(xfrd_zone_t* zone);
d319 1
a319 1
        acl_options_t* acl);
d324 1
a324 1
void xfrd_handle_incoming_soa(xfrd_zone_t* zone, xfrd_soa_t* soa,
d339 1
a339 1
void xfrd_copy_soa(xfrd_soa_t* soa, rr_type* rr);
d352 2
a353 2
int xfrd_bind_local_interface(int sockd, acl_options_t* ifc,
	acl_options_t* acl, int tcp);
d356 1
a356 1
void xfrd_process_task_result(xfrd_state_t* xfrd, struct udb_base* taskudb);
d359 1
a359 1
void xfrd_set_reload_now(xfrd_state_t* xfrd);
d362 1
a362 1
void xfrd_send_expire_notification(xfrd_zone_t* zone);
d365 1
a365 1
void xfrd_handle_notify_and_start_xfr(xfrd_zone_t* zone, xfrd_soa_t* soa);
@


1.4
log
@Update to 4.1.13
Testing millert, brad and myself.
OK millert@@
@
text
@d247 3
d261 3
@


1.3
log
@merge conflicts
@
text
@d220 2
@


1.2
log
@Merge in some commits from upstream..

- Fix that failure to add tcp to tcp base does not leak the socket.
- Fixes for wildcard addition and deletion, speedup for some cases.
- Fix that queries for noname CH TXT are REFUSED instead of nodata.
- Fix #616: retry xfer for zones with no content after command.
- Fix that expired zones stay expired after a server restart.
- RFC 7344: CDS and CDNSKEY (read in).

ok sthen@@
@
text
@d68 7
@


1.1
log
@Initial revision
@
text
@d13 11
a23 2
#include <config.h>
#include "netio.h"
d36 1
d48 1
a48 1
	netio_type* netio;
d54 1
a54 1
	/* udp waiting list */
d58 2
d65 3
d69 3
a71 2
	struct timespec reload_timeout;
	netio_handler_type reload_handler;
d75 9
d86 2
a87 3
	netio_handler_type ipc_handler;
	uint8_t ipc_is_soa;
	uint8_t parent_soa_info_pass;
d91 1
a91 1
	struct xfrd_tcp *ipc_conn_write;
d93 1
a94 1
	uint8_t sending_zone_state;
d96 1
a96 1
	stack_type* dirty_zones; /* stack of xfrd_zone* */
a164 4
	/* if state is dirty it needs to be sent to server_main.
	 * it is also on the dirty_stack. Not saved on disk. */
	uint8_t dirty;

d175 4
a178 2
	struct timespec timeout;
	netio_handler_type zone_handler;
d186 6
d196 6
a209 1
#ifdef TSIG
d211 2
a212 1
#endif
d217 1
d233 1
a233 1
#define XFRD_MAX_TCP 50 /* max number of TCP AXFR/IXFR concurrent connections.*/
d235 2
a236 2
#define XFRD_MAX_UDP 100 /* max number of UDP sockets at a time for IXFR */
#define XFRD_MAX_UDP_NOTIFY 50 /* max concurrent UDP sockets for NOTIFY */
d241 8
a248 1
void xfrd_init(int socket, struct nsd* nsd);
d251 1
a251 1
time_t xfrd_time();
d266 2
d297 1
a297 1
struct buffer* xfrd_get_temp_buffer();
a301 1
#ifdef TSIG
a303 1
#endif
d311 4
a314 2
   the packet. The packet is the network blob received. */
void xfrd_handle_passed_packet(buffer_type* packet, int acl_num);
d316 2
a317 2
/* send expiry notify for all zones to nsd (sets all dirty). */
void xfrd_send_expy_all_zones();
d319 2
a320 2
/* try to reopen the logfile. */
void xfrd_reopen_logfile();
d327 1
a327 1
void xfrd_check_failed_updates();
d333 1
a333 1
void xfrd_prepare_zones_for_reload();
d338 17
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.6
@
text
@d176 1
d178 1
d258 1
d261 1
@


1.1.1.3
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.4
log
@NSD v3.2.11, ok phessler@@
@
text
@d13 1
a13 1
#include "config.h"
@


1.1.1.5
log
@update to NSD 3.2.14, requested by/ok brad@@
@
text
@d265 2
a266 4
   the packet. The packet is the network blob received. acl_xfr is 
   provide-xfr acl matching notify sender or -1 */
void xfrd_handle_passed_packet(buffer_type* packet,
	int acl_num, int acl_xfr);
@


1.1.1.6
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@a180 1
	xfrd_packet_drop, /* drop the connection, but not report bad */
@


1.1.1.7
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d13 2
a14 5
#ifndef USE_MINI_EVENT
#include <event.h>
#else
#include "mini_event.h"
#endif
a26 1
struct udb_ptr;
d38 1
a38 1
	struct event_base* event_base;
d44 1
a44 1
	/* udp waiting list, double linked list */
a47 2
	/* activated waiting list, double linked list */
	struct xfrd_zone *activated_first;
a52 3
	/* counter for xfr file numbers */
	uint64_t xfrfilenumber;

d54 2
a55 3
	struct timeval reload_timeout;
	struct event reload_handler;
	int reload_added;
a58 1
	pid_t reload_pid;
d61 3
a63 2
	struct event ipc_handler;
	int ipc_handler_flags;
d67 1
a67 1
	uint8_t need_to_send_shutdown;
a68 1
	uint8_t need_to_send_stats;
d70 1
d72 1
a72 1
	struct udb_ptr* last_task;
d141 4
d155 2
a156 4
	struct timeval timeout;
	struct event zone_handler;
	int zone_handler_flags;
	int event_added;
a163 6
	xfrd_zone_t* tcp_waiting_prev;
	/* zone is in its tcp send queue */
	uint8_t in_tcp_send;
	/* next zone in tcp send queue */
	xfrd_zone_t* tcp_send_next;
	xfrd_zone_t* tcp_send_prev;
a167 6
	xfrd_zone_t* udp_waiting_prev;
	/* zone has been activated to run now (after the other events
	 * but before blocking in select again) */
	uint8_t is_activated;
	xfrd_zone_t* activated_next;
	xfrd_zone_t* activated_prev;
a176 2
	uint64_t xfrfilenumber; /* identifier for file to store xfr into,
				valid if msg_seq_nr nonzero */
d197 1
a197 1
#define XFRD_MAX_TCP 32 /* max number of TCP AXFR/IXFR concurrent connections.*/
d199 2
a200 2
#define XFRD_MAX_UDP 64 /* max number of UDP sockets at a time for IXFR */
#define XFRD_MAX_UDP_NOTIFY 64 /* max concurrent UDP sockets for NOTIFY */
d205 1
a205 7
void xfrd_init(int socket, struct nsd* nsd, int shortsoa, int reload_active);

/* add new slave zone, dname(from zone_opt) and given options */
void xfrd_init_slave_zone(xfrd_state_t* xfrd, zone_options_t* zone_opt);

/* delete slave zone */
void xfrd_del_slave_zone(xfrd_state_t* xfrd, const dname_type* dname);
d208 1
a208 1
time_t xfrd_time(void);
a222 2
/* remove the 'refresh now', remove it from the activated list */
void xfrd_deactivate_zone(xfrd_zone_t* z);
d252 1
a252 1
struct buffer* xfrd_get_temp_buffer(void);
d271 3
d275 1
a275 4
void xfrd_reopen_logfile(void);

/* free namedb for xfrd usage */
void xfrd_free_namedb(struct nsd* nsd);
d282 1
a282 1
void xfrd_check_failed_updates(void);
d288 1
a288 1
void xfrd_prepare_zones_for_reload(void);
a292 14

/* process results and soa info from reload */
void xfrd_process_task_result(xfrd_state_t* xfrd, struct udb_base* taskudb);

/* set to reload right away (for user controlled reload events) */
void xfrd_set_reload_now(xfrd_state_t* xfrd);

/* handle incoming notify (soa or NULL) and start zone xfr if necessary */
void xfrd_handle_notify_and_start_xfr(xfrd_zone_t* zone, xfrd_soa_t* soa);

/* handle zone timeout, event */
void xfrd_handle_zone(int fd, short event, void* arg);

const char* xfrd_pretty_time(time_t v);
@


1.1.1.8
log
@update to NSD 4.0.2, ok sthen@@
@
text
@d14 1
a14 7
#  ifdef HAVE_EVENT_H
#    include <event.h>
#  else
#    include <event2/event.h>
#    include "event2/event_struct.h"
#    include "event2/event_compat.h"
#  endif
d16 1
a16 1
#  include "mini_event.h"
@


1.1.1.9
log
@update to NSD 4.1.0, ok sthen@@
@
text
@a75 8
	/* timeout for lost sigchild and reaping children */
	struct event child_timer;
	int child_timer_added;

	/* timeout event for zonefiles_write events */
	struct event write_timer;
	/* set to 1 if zones have received xfrs since the last write_timer */
	int write_zonefile_needed;
d233 1
a233 2
void xfrd_init(int socket, struct nsd* nsd, int shortsoa, int reload_active,
	pid_t nsd_pid);
@


1.1.1.10
log
@update to NSD 4.1.1, ok sthen@@
@
text
@a67 7
	/* the zonestat array size that we last saw and is safe to use */
	unsigned zonestat_safe;
	/* size currently of the clear array */
	size_t zonestat_clear_num;
	/* array of malloced entries with cumulative cleared stat values */
	struct nsdst** zonestat_clear;

a343 3

/* send expiry notifications to nsd */
void xfrd_send_expire_notification(xfrd_zone_t* zone);
@


