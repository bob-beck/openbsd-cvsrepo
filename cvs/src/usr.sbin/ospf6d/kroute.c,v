head	1.51;
access;
symbols
	OPENBSD_6_1:1.50.0.4
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.48.0.6
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.36.0.6
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.4
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7;
locks; strict;
comment	@ * @;


1.51
date	2017.05.30.12.42.31;	author friehm;	state Exp;
branches;
next	1.50;
commitid	aUDKS9b7zHFzXmWv;

1.50
date	2016.12.27.17.18.56;	author jca;	state Exp;
branches;
next	1.49;
commitid	04ojC2souZ1MiFQA;

1.49
date	2016.12.22.23.01.58;	author jca;	state Exp;
branches;
next	1.48;
commitid	kRM98tyJ670zNBJX;

1.48
date	2015.07.17.20.12.38;	author claudio;	state Exp;
branches;
next	1.47;
commitid	l7zBBrmfgGrfaTew;

1.47
date	2015.02.11.05.58.57;	author claudio;	state Exp;
branches;
next	1.46;
commitid	bH0ZvKDJTDEpVtlz;

1.46
date	2015.02.10.05.39.10;	author claudio;	state Exp;
branches;
next	1.45;
commitid	LcINzHD3xxMOidFk;

1.45
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	Uu5nFG3wCl0LACBb;

1.44
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.43;
commitid	uXnRK9VvnFZsAqfW;

1.43
date	2013.10.30.17.24.34;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.22.13.17.54;	author sthen;	state Exp;
branches;
next	1.41;

1.41
date	2013.01.14.14.39.38;	author florian;	state Exp;
branches;
next	1.40;

1.40
date	2012.10.21.21.30.44;	author bluhm;	state Exp;
branches;
next	1.39;

1.39
date	2012.09.20.17.39.08;	author bluhm;	state Exp;
branches;
next	1.38;

1.38
date	2012.09.19.19.20.34;	author bluhm;	state Exp;
branches;
next	1.37;

1.37
date	2012.09.17.13.49.27;	author bluhm;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.07.18.39.11;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2011.07.07.17.10.48;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2011.07.07.17.06.51;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.07.03.56.59;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.07.00.36.13;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2011.03.07.07.43.02;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2010.10.14.07.38.05;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.22.21.15.25;	author bluhm;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.14.17.09.13;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.12.14.35.13;	author bluhm;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.06.13.24.35;	author bluhm;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.01.19.47.04;	author bluhm;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.01.18.57.21;	author bluhm;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.28.15.06.00;	author bluhm;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.12.10.03.38;	author bluhm;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.09.17.46.42;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.23.16.22.57;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.23.15.11.41;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.22.19.44.52;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.22.19.32.36;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.21.18.35.43;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.21.18.29.31;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.20.20.27.53;	author stsp;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.05.22.40.24;	author chris;	state Exp;
branches;
next	1.11;

1.11
date	2009.04.09.19.03.10;	author stsp;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.03.14.06.18;	author stsp;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.04.18.20.22;	author stsp;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.09.12.55.48;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2008.02.11.13.48.39;	author norby;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.13.08.54.05;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.17.20.54.41;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.16.08.41.56;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.11.21.29.53;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.10.14.06.03;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.50;	author norby;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Adding multipath route support to ospf6d. Almost copied from ospfd.

OK bluhm@@
@
text
@/*	$OpenBSD: kroute.c,v 1.50 2016/12/27 17:18:56 jca Exp $ */

/*
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/tree.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "ospf6d.h"
#include "ospfe.h"
#include "log.h"

struct {
	u_int32_t		rtseq;
	pid_t			pid;
	int			fib_sync;
	int			fd;
	struct event		ev;
} kr_state;

struct kroute_node {
	RB_ENTRY(kroute_node)	 entry;
	struct kroute_node	*next;
	struct kroute		 r;
};

void	kr_redist_remove(struct kroute_node *, struct kroute_node *);
int	kr_redist_eval(struct kroute *, struct kroute *);
void	kr_redistribute(struct kroute_node *);
int	kroute_compare(struct kroute_node *, struct kroute_node *);
int	kr_change_fib(struct kroute_node *, struct kroute *, int, int);
int	kr_delete_fib(struct kroute_node *);

struct kroute_node	*kroute_find(const struct in6_addr *, u_int8_t);
struct kroute_node	*kroute_matchgw(struct kroute_node *,
			    struct in6_addr *, unsigned int);
int			 kroute_insert(struct kroute_node *);
int			 kroute_remove(struct kroute_node *);
void			 kroute_clear(void);

struct iface		*kif_update(u_short, int, struct if_data *,
			   struct sockaddr_dl *);
int			 kif_validate(u_short);

struct kroute_node	*kroute_match(struct in6_addr *);

int		protect_lo(void);
void		get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
void		if_change(u_short, int, struct if_data *);
void		if_newaddr(u_short, struct sockaddr_in6 *,
		    struct sockaddr_in6 *, struct sockaddr_in6 *);
void		if_deladdr(u_short, struct sockaddr_in6 *,
		    struct sockaddr_in6 *, struct sockaddr_in6 *);
void		if_announce(void *);

int		send_rtmsg(int, int, struct kroute *);
int		dispatch_rtmsg(void);
int		fetchtable(void);

RB_HEAD(kroute_tree, kroute_node)	krt;
RB_PROTOTYPE(kroute_tree, kroute_node, entry, kroute_compare)
RB_GENERATE(kroute_tree, kroute_node, entry, kroute_compare)

int
kr_init(int fs)
{
	int		opt = 0, rcvbuf, default_rcvbuf;
	socklen_t	optlen;

	kr_state.fib_sync = fs;

	if ((kr_state.fd = socket(AF_ROUTE,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK, 0)) == -1) {
		log_warn("kr_init: socket");
		return (-1);
	}

	/* not interested in my own messages */
	if (setsockopt(kr_state.fd, SOL_SOCKET, SO_USELOOPBACK,
	    &opt, sizeof(opt)) == -1)
		log_warn("kr_init: setsockopt");	/* not fatal */

	/* grow receive buffer, don't wanna miss messages */
	optlen = sizeof(default_rcvbuf);
	if (getsockopt(kr_state.fd, SOL_SOCKET, SO_RCVBUF,
	    &default_rcvbuf, &optlen) == -1)
		log_warn("kr_init getsockopt SOL_SOCKET SO_RCVBUF");
	else
		for (rcvbuf = MAX_RTSOCK_BUF;
		    rcvbuf > default_rcvbuf &&
		    setsockopt(kr_state.fd, SOL_SOCKET, SO_RCVBUF,
		    &rcvbuf, sizeof(rcvbuf)) == -1 && errno == ENOBUFS;
		    rcvbuf /= 2)
			;	/* nothing */

	kr_state.pid = getpid();
	kr_state.rtseq = 1;

	RB_INIT(&krt);

	if (fetchtable() == -1)
		return (-1);

	if (protect_lo() == -1)
		return (-1);

	event_set(&kr_state.ev, kr_state.fd, EV_READ | EV_PERSIST,
	    kr_dispatch_msg, NULL);
	event_add(&kr_state.ev, NULL);

	return (0);
}

int
kr_change_fib(struct kroute_node *kr, struct kroute *kroute, int krcount,
    int action)
{
	int			 i;
	struct kroute_node	*kn, *nkn;

	if (action == RTM_ADD) {
		/*
		 * First remove all stale multipath routes.
		 * This step must be skipped when the action is RTM_CHANGE
		 * because it is already a single path route that will be
		 * changed.
		 */
		for (kn = kr; kn != NULL; kn = nkn) {
			for (i = 0; i < krcount; i++) {
				if (kn->r.scope == kroute[i].scope &&
				    IN6_ARE_ADDR_EQUAL(&kn->r.nexthop,
				    &kroute[i].nexthop))
					break;
			}
			nkn = kn->next;
			if (i == krcount) {
				/* stale route */
				if (kr_delete_fib(kn) == -1)
					log_warnx("kr_delete_fib failed");
				/*
				 * if head element was removed we need to adjust
				 * the head
				 */
				if (kr == kn)
					kr = nkn;
			}
		}
	}

	/*
	 * now add or change the route
	 */
	for (i = 0; i < krcount; i++) {
		/* nexthop ::1 -> ignore silently */
		if (IN6_IS_ADDR_LOOPBACK(&kroute[i].nexthop))
			continue;

		if (action == RTM_ADD && kr) {
			for (kn = kr; kn != NULL; kn = kn->next) {
				if (kn->r.scope == kroute[i].scope &&
				    IN6_ARE_ADDR_EQUAL(&kn->r.nexthop,
				    &kroute[i].nexthop))
					break;
			}

			if (kn != NULL)
				/* nexthop already present, skip it */
				continue;
		} else
			/* modify first entry */
			kn = kr;

		/* send update */
		if (send_rtmsg(kr_state.fd, action, &kroute[i]) == -1)
			return (-1);

		/* create new entry unless we are changing the first entry */
		if (action == RTM_ADD)
			if ((kn = calloc(1, sizeof(*kn))) == NULL)
				fatal(NULL);

		kn->r.prefix = kroute[i].prefix;
		kn->r.prefixlen = kroute[i].prefixlen;
		kn->r.nexthop = kroute[i].nexthop;
		kn->r.scope = kroute[i].scope;
		kn->r.flags = kroute[i].flags | F_OSPFD_INSERTED;
		kn->r.ext_tag = kroute[i].ext_tag;
		rtlabel_unref(kn->r.rtlabel);	/* for RTM_CHANGE */
		kn->r.rtlabel = kroute[i].rtlabel;

		if (action == RTM_ADD)
			if (kroute_insert(kn) == -1) {
				log_debug("kr_update_fib: cannot insert %s",
				    log_in6addr(&kn->r.nexthop));
				free(kn);
			}
		action = RTM_ADD;
	}
	return  (0);
}

int
kr_change(struct kroute *kroute, int krcount)
{
	struct kroute_node	*kr;
	int			 action = RTM_ADD;

	kroute->rtlabel = rtlabel_tag2id(kroute->ext_tag);

	kr = kroute_find(&kroute->prefix, kroute->prefixlen);
	if (kr != NULL) {
		if (kr->r.flags & F_KERNEL) {
			/* a non-ospf route already exists. not a problem */
			if (!(kr->r.flags & F_BGPD_INSERTED)) {
				do {
					kr->r.flags |= F_OSPFD_INSERTED;
					kr = kr->next;
				} while (kr);
				return (0);
			}
			/*
			 * XXX as long as there is no multipath support in
			 * bgpd this is safe else we end up in a bad situation.
			 */
			/*
			 * ospf route has higher pref
			 * - reset flags to the ospf ones
			 * - use RTM_CHANGE
			 * - zero out ifindex (this is no longer relevant)
			 */
			action = RTM_CHANGE;
		} else if (kr->next == NULL)	/* single path OSPF route */
			action = RTM_CHANGE;
	}

	return (kr_change_fib(kr, kroute, krcount, action));
}

int
kr_delete_fib(struct kroute_node *kr)
{
	if (!(kr->r.flags & F_OSPFD_INSERTED))
		return 0;

	if (kr->r.flags & F_KERNEL) {
		/* remove F_OSPFD_INSERTED flag, route still exists in kernel */
		kr->r.flags &= ~F_OSPFD_INSERTED;
		return (0);
	}

	if (send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r) == -1)
		return (-1);

	if (kroute_remove(kr) == -1)
		return (-1);

	return (0);
}

int
kr_delete(struct kroute *kroute)
{
	struct kroute_node	*kr, *nkr;

	if ((kr = kroute_find(&kroute->prefix, kroute->prefixlen)) ==
	    NULL)
		return (0);

	while (kr != NULL) {
		nkr = kr->next;
		if (kr_delete_fib(kr) == -1)
			return (-1);
		kr = nkr;
	}

	return (0);
}

void
kr_shutdown(void)
{
	kr_fib_decouple();
	kroute_clear();
}

void
kr_fib_couple(void)
{
	struct kroute_node	*kr;
	struct kroute_node	*kn;

	if (kr_state.fib_sync == 1)	/* already coupled */
		return;

	kr_state.fib_sync = 1;

	RB_FOREACH(kr, kroute_tree, &krt)
		if (!(kr->r.flags & F_KERNEL))
			for (kn = kr; kn != NULL; kn = kn->next) {
				send_rtmsg(kr_state.fd, RTM_ADD, &kn->r);
			}

	log_info("kernel routing table coupled");
}

void
kr_fib_decouple(void)
{
	struct kroute_node	*kr;
	struct kroute_node	*kn;

	if (kr_state.fib_sync == 0)	/* already decoupled */
		return;

	RB_FOREACH(kr, kroute_tree, &krt) {
		if (!(kr->r.flags & F_KERNEL))
			for (kn = kr; kn != NULL; kn = kn->next) {
				send_rtmsg(kr_state.fd, RTM_DELETE, &kn->r);
			}
	}

	kr_state.fib_sync = 0;

	log_info("kernel routing table decoupled");
}

/* ARGSUSED */
void
kr_dispatch_msg(int fd, short event, void *bula)
{
	dispatch_rtmsg();
}

void
kr_show_route(struct imsg *imsg)
{
	struct kroute_node	*kr;
	struct kroute_node	*kn;
	int			 flags;
	struct in6_addr		 addr;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(flags)) {
			log_warnx("kr_show_route: wrong imsg len");
			return;
		}
		memcpy(&flags, imsg->data, sizeof(flags));
		RB_FOREACH(kr, kroute_tree, &krt)
			if (!flags || kr->r.flags & flags) {
				kn = kr;
				do {
					main_imsg_compose_ospfe(IMSG_CTL_KROUTE,
					    imsg->hdr.pid,
					    &kn->r, sizeof(kn->r));
				} while ((kn = kn->next) != NULL);
			}
		break;
	case IMSG_CTL_KROUTE_ADDR:
		if (imsg->hdr.len != IMSG_HEADER_SIZE +
		    sizeof(struct in6_addr)) {
			log_warnx("kr_show_route: wrong imsg len");
			return;
		}
		memcpy(&addr, imsg->data, sizeof(addr));
		kr = NULL;
		kr = kroute_match(&addr);
		if (kr != NULL)
			main_imsg_compose_ospfe(IMSG_CTL_KROUTE, imsg->hdr.pid,
			    &kr->r, sizeof(kr->r));
		break;
	default:
		log_debug("kr_show_route: error handling imsg");
		break;
	}

	main_imsg_compose_ospfe(IMSG_CTL_END, imsg->hdr.pid, NULL, 0);
}

void
kr_redist_remove(struct kroute_node *kh, struct kroute_node *kn)
{
	struct kroute	 *kr;

	/* was the route redistributed? */
	if ((kn->r.flags & F_REDISTRIBUTED) == 0)
		return;

	/* remove redistributed flag */
	kn->r.flags &= ~F_REDISTRIBUTED;
	kr = &kn->r;

	/* probably inform the RDE (check if no other path is redistributed) */
	for (kn = kh; kn; kn = kn->next)
		if (kn->r.flags & F_REDISTRIBUTED)
			break;

	if (kn == NULL)
		main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, kr,
		    sizeof(struct kroute));
}

int
kr_redist_eval(struct kroute *kr, struct kroute *new_kr)
{
	u_int32_t	 metric = 0;

	/* Only non-ospfd routes are considered for redistribution. */
	if (!(kr->flags & F_KERNEL))
		goto dont_redistribute;

	/* Dynamic routes are not redistributable. */
	if (kr->flags & F_DYNAMIC)
		goto dont_redistribute;

	/* interface is not up and running so don't announce */
	if (kr->flags & F_DOWN)
		goto dont_redistribute;

	/*
	 * We consider loopback, multicast, link- and site-local,
	 * IPv4 mapped and IPv4 compatible addresses as not redistributable.
	 */
	if (IN6_IS_ADDR_LOOPBACK(&kr->prefix) ||
	    IN6_IS_ADDR_MULTICAST(&kr->prefix) ||
	    IN6_IS_ADDR_LINKLOCAL(&kr->prefix) ||
	    IN6_IS_ADDR_SITELOCAL(&kr->prefix) ||
	    IN6_IS_ADDR_V4MAPPED(&kr->prefix) ||
	    IN6_IS_ADDR_V4COMPAT(&kr->prefix))
		goto dont_redistribute;
	/*
	 * Consider networks with nexthop loopback as not redistributable
	 * unless it is a reject or blackhole route.
	 */
	if (IN6_IS_ADDR_LOOPBACK(&kr->nexthop) &&
	    !(kr->flags & (F_BLACKHOLE|F_REJECT)))
		goto dont_redistribute;

	/* Should we redistribute this route? */
	if (!ospf_redistribute(kr, &metric))
		goto dont_redistribute;

	/* prefix should be redistributed */
	kr->flags |= F_REDISTRIBUTED;
	/*
	 * only one of all multipath routes can be redistributed so
	 * redistribute the best one.
	 */
	if (new_kr->metric > metric) {
		*new_kr = *kr;
		new_kr->metric = metric;
	}

	return (1);

dont_redistribute:
	/* was the route redistributed? */
	if ((kr->flags & F_REDISTRIBUTED) == 0)
		return (0);

	kr->flags &= ~F_REDISTRIBUTED;
	return (1);
}

void
kr_redistribute(struct kroute_node *kh)
{
	struct kroute_node	*kn;
	struct kroute		 kr;
	int			 redistribute = 0;

	bzero(&kr, sizeof(kr));
	kr.metric = UINT_MAX;
	for (kn = kh; kn; kn = kn->next)
		if (kr_redist_eval(&kn->r, &kr))
			redistribute = 1;

	if (!redistribute)
		return;

	if (kr.flags & F_REDISTRIBUTED) {
		main_imsg_compose_rde(IMSG_NETWORK_ADD, 0, &kr,
		    sizeof(struct kroute));
	} else {
		kr = kh->r;
		main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, &kr,
		    sizeof(struct kroute));
	}
}

void
kr_reload(void)
{
	struct kroute_node	*kr, *kn;
	u_int32_t		 dummy;
	int			 r;

	RB_FOREACH(kr, kroute_tree, &krt) {
		for (kn = kr; kn; kn = kn->next) {
			r = ospf_redistribute(&kn->r, &dummy);
			/*
			 * if it is redistributed, redistribute again metric
			 * may have changed.
			 */
			if ((kn->r.flags & F_REDISTRIBUTED && !r) || r)
				break;
		}
		if (kn) {
			/*
			 * kr_redistribute copes with removes and RDE with
			 * duplicates
			 */
			kr_redistribute(kr);
		}
	}
}

/* rb-tree compare */
int
kroute_compare(struct kroute_node *a, struct kroute_node *b)
{
	int	i;

	/* XXX maybe switch a & b */
	i = memcmp(&a->r.prefix, &b->r.prefix, sizeof(a->r.prefix));
	if (i)
		return (i);
	if (a->r.prefixlen < b->r.prefixlen)
		return (-1);
	if (a->r.prefixlen > b->r.prefixlen)
		return (1);
	return (0);
}

/* tree management */
struct kroute_node *
kroute_find(const struct in6_addr *prefix, u_int8_t prefixlen)
{
	struct kroute_node	s;

	s.r.prefix = *prefix;
	s.r.prefixlen = prefixlen;

	return (RB_FIND(kroute_tree, &krt, &s));
}

struct kroute_node *
kroute_matchgw(struct kroute_node *kr, struct in6_addr *nh, unsigned int scope)
{
	while (kr) {
		if (scope == kr->r.scope &&
		    IN6_ARE_ADDR_EQUAL(&kr->r.nexthop, nh))
			return (kr);
		kr = kr->next;
	}

	return (NULL);
}

int
kroute_insert(struct kroute_node *kr)
{
	struct kroute_node	*krm, *krh;

	if ((krh = RB_INSERT(kroute_tree, &krt, kr)) != NULL) {
		/*
		 * Multipath route, add at end of list and clone the
		 * ospfd inserted flag.
		 */
		krm = krh;
		kr->r.flags |= krm->r.flags & F_OSPFD_INSERTED;
		while (krm->next != NULL)
			krm = krm->next;
		krm->next = kr;
		kr->next = NULL; /* to be sure */
	} else
		krh = kr;

	if (!(kr->r.flags & F_KERNEL)) {
		/* don't validate or redistribute ospf route */
		kr->r.flags &= ~F_DOWN;
		return (0);
	}

	if (kif_validate(kr->r.ifindex))
		kr->r.flags &= ~F_DOWN;
	else
		kr->r.flags |= F_DOWN;

	kr_redistribute(krh);
	return (0);
}

int
kroute_remove(struct kroute_node *kr)
{
	struct kroute_node	*krm;

	if ((krm = RB_FIND(kroute_tree, &krt, kr)) == NULL) {
		log_warnx("kroute_remove failed to find %s/%u",
		    log_in6addr(&kr->r.prefix), kr->r.prefixlen);
		return (-1);
	}

	if (krm == kr) {
		/* head element */
		if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
			log_warnx("kroute_remove failed for %s/%u",
			    log_in6addr(&kr->r.prefix), kr->r.prefixlen);
			return (-1);
		}
		if (kr->next != NULL) {
			if (RB_INSERT(kroute_tree, &krt, kr->next) != NULL) {
				log_warnx("kroute_remove failed to add %s/%u",
				    log_in6addr(&kr->r.prefix),
				    kr->r.prefixlen);
				return (-1);
			}
		}
	} else {
		/* somewhere in the list */
		while (krm->next != kr && krm->next != NULL)
			krm = krm->next;
		if (krm->next == NULL) {
			log_warnx("kroute_remove multipath list corrupted "
			    "for %s/%u", log_in6addr(&kr->r.prefix),
			    kr->r.prefixlen);
			return (-1);
		}
		krm->next = kr->next;
	}

	kr_redist_remove(krm, kr);
	rtlabel_unref(kr->r.rtlabel);

	free(kr);
	return (0);
}

void
kroute_clear(void)
{
	struct kroute_node	*kr;

	while ((kr = RB_MIN(kroute_tree, &krt)) != NULL)
		kroute_remove(kr);
}

struct iface *
kif_update(u_short ifindex, int flags, struct if_data *ifd,
    struct sockaddr_dl *sdl)
{
	struct iface	*iface;
	char		 ifname[IF_NAMESIZE];

	if ((iface = if_find(ifindex)) == NULL) {
		bzero(ifname, sizeof(ifname));
		if (sdl && sdl->sdl_family == AF_LINK) {
			if (sdl->sdl_nlen >= sizeof(ifname))
				memcpy(ifname, sdl->sdl_data,
				    sizeof(ifname) - 1);
			else if (sdl->sdl_nlen > 0)
				memcpy(ifname, sdl->sdl_data, sdl->sdl_nlen);
			else
				return (NULL);
		} else
			return (NULL);
		if ((iface = if_new(ifindex, ifname)) == NULL)
			return (NULL);
		iface->cflags |= F_IFACE_AVAIL;
	}

	if_update(iface, ifd->ifi_mtu, flags, ifd->ifi_type,
	    ifd->ifi_link_state, ifd->ifi_baudrate);

	return (iface);
}

int
kif_validate(u_short ifindex)
{
	struct iface	*iface;

	if ((iface = if_find(ifindex)) == NULL) {
		log_warnx("interface with index %u not found", ifindex);
		return (-1);
	}

	return ((iface->flags & IFF_UP) && LINK_STATE_IS_UP(iface->linkstate));
}

struct kroute_node *
kroute_match(struct in6_addr *key)
{
	int			 i;
	struct kroute_node	*kr;
	struct in6_addr		 ina;

	/* we will never match the default route */
	for (i = 128; i > 0; i--) {
		inet6applymask(&ina, key, i);
		if ((kr = kroute_find(&ina, i)) != NULL)
			return (kr);
	}

	/* if we don't have a match yet, try to find a default route */
	if ((kr = kroute_find(&in6addr_any, 0)) != NULL)
			return (kr);

	return (NULL);
}

/* misc */
int
protect_lo(void)
{
	struct kroute_node	*kr;

	/* special protection for loopback */
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
		log_warn("protect_lo");
		return (-1);
	}
	memcpy(&kr->r.prefix, &in6addr_loopback, sizeof(kr->r.prefix));
	kr->r.prefixlen = 128;
	kr->r.flags = F_KERNEL|F_CONNECTED;

	if (RB_INSERT(kroute_tree, &krt, kr) != NULL)
		free(kr);	/* kernel route already there, no problem */

	return (0);
}

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		} else
			rti_info[i] = NULL;
	}
}

void
if_change(u_short ifindex, int flags, struct if_data *ifd)
{
	struct kroute_node	*kr, *tkr;
	struct iface		*iface;
	u_int8_t		 wasvalid, isvalid;

	wasvalid = kif_validate(ifindex);

	if ((iface = kif_update(ifindex, flags, ifd, NULL)) == NULL) {
		log_warn("if_change: kif_update(%u)", ifindex);
		return;
	}

	/* inform engine and rde about state change if interface is used */
	if (iface->cflags & F_IFACE_CONFIGURED) {
		main_imsg_compose_ospfe(IMSG_IFINFO, 0, iface,
		    sizeof(struct iface));
		main_imsg_compose_rde(IMSG_IFINFO, 0, iface,
		    sizeof(struct iface));
	}

	isvalid = (iface->flags & IFF_UP) &&
	    LINK_STATE_IS_UP(iface->linkstate);

	if (wasvalid == isvalid)
		return;		/* nothing changed wrt validity */

	/* update redistribute list */
	RB_FOREACH(kr, kroute_tree, &krt) {
		for (tkr = kr; tkr != NULL; tkr = tkr->next) {
			if (tkr->r.ifindex == ifindex) {
				if (isvalid)
					tkr->r.flags &= ~F_DOWN;
				else
					tkr->r.flags |= F_DOWN;

			}
		}
		kr_redistribute(kr);
	}
}

void
if_newaddr(u_short ifindex, struct sockaddr_in6 *ifa, struct sockaddr_in6 *mask,
    struct sockaddr_in6 *brd)
{
	struct iface		*iface;
	struct iface_addr	*ia;
	struct ifaddrchange	 ifc;

	if (ifa == NULL || ifa->sin6_family != AF_INET6)
		return;
	if ((iface = if_find(ifindex)) == NULL) {
		log_warnx("if_newaddr: corresponding if %d not found", ifindex);
		return;
	}

	/* We only care about link-local and global-scope. */
	if (IN6_IS_ADDR_UNSPECIFIED(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_LOOPBACK(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_MULTICAST(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_SITELOCAL(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_V4MAPPED(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_V4COMPAT(&ifa->sin6_addr))
		return;

	clearscope(&ifa->sin6_addr);

	if (IN6_IS_ADDR_LINKLOCAL(&ifa->sin6_addr) ||
	    iface->flags & IFF_LOOPBACK)
		iface->addr = ifa->sin6_addr;

	if ((ia = calloc(1, sizeof(struct iface_addr))) == NULL)
		fatal("if_newaddr");

	ia->addr = ifa->sin6_addr;

	if (mask)
		ia->prefixlen = mask2prefixlen(mask);
	else
		ia->prefixlen = 0;
	if (brd && brd->sin6_family == AF_INET6)
		ia->dstbrd = brd->sin6_addr;
	else
		bzero(&ia->dstbrd, sizeof(ia->dstbrd));

	switch (iface->type) {
	case IF_TYPE_BROADCAST:
	case IF_TYPE_NBMA:
		log_debug("if_newaddr: ifindex %u, addr %s/%d",
		    ifindex, log_in6addr(&ia->addr), ia->prefixlen);
		break;
	case IF_TYPE_VIRTUALLINK:	/* FIXME */
		break;
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_POINTOMULTIPOINT:
		log_debug("if_newaddr: ifindex %u, addr %s/%d, "
		    "dest %s", ifindex, log_in6addr(&ia->addr),
		    ia->prefixlen, log_in6addr(&ia->dstbrd));
		break;
	default:
		fatalx("if_newaddr: unknown interface type");
	}

	TAILQ_INSERT_TAIL(&iface->ifa_list, ia, entry);
	/* inform engine and rde if interface is used */
	if (iface->cflags & F_IFACE_CONFIGURED) {
		ifc.addr = ia->addr;
		ifc.dstbrd = ia->dstbrd;
		ifc.prefixlen = ia->prefixlen;
		ifc.ifindex = ifindex;
		main_imsg_compose_ospfe(IMSG_IFADDRNEW, 0, &ifc, sizeof(ifc));
		main_imsg_compose_rde(IMSG_IFADDRNEW, 0, &ifc, sizeof(ifc));
	}
}

void
if_deladdr(u_short ifindex, struct sockaddr_in6 *ifa, struct sockaddr_in6 *mask,
    struct sockaddr_in6 *brd)
{
	struct iface		*iface;
	struct iface_addr	*ia, *nia;
	struct ifaddrchange	 ifc;

	if (ifa == NULL || ifa->sin6_family != AF_INET6)
		return;
	if ((iface = if_find(ifindex)) == NULL) {
		log_warnx("if_deladdr: corresponding if %d not found", ifindex);
		return;
	}

	/* We only care about link-local and global-scope. */
	if (IN6_IS_ADDR_UNSPECIFIED(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_LOOPBACK(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_MULTICAST(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_SITELOCAL(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_V4MAPPED(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_V4COMPAT(&ifa->sin6_addr))
		return;

	clearscope(&ifa->sin6_addr);

	for (ia = TAILQ_FIRST(&iface->ifa_list); ia != NULL; ia = nia) {
		nia = TAILQ_NEXT(ia, entry);

		if (IN6_ARE_ADDR_EQUAL(&ia->addr, &ifa->sin6_addr)) {
			log_debug("if_deladdr: ifindex %u, addr %s/%d",
			    ifindex, log_in6addr(&ia->addr), ia->prefixlen);
			TAILQ_REMOVE(&iface->ifa_list, ia, entry);
			/* inform engine and rde if interface is used */
			if (iface->cflags & F_IFACE_CONFIGURED) {
				ifc.addr = ia->addr;
				ifc.dstbrd = ia->dstbrd;
				ifc.prefixlen = ia->prefixlen;
				ifc.ifindex = ifindex;
				main_imsg_compose_ospfe(IMSG_IFADDRDEL, 0, &ifc,
				    sizeof(ifc));
				main_imsg_compose_rde(IMSG_IFADDRDEL, 0, &ifc,
				    sizeof(ifc));
			}
			free(ia);
			return;
		}
	}
}

void
if_announce(void *msg)
{
	struct if_announcemsghdr	*ifan;
	struct iface			*iface;

	ifan = msg;

	switch (ifan->ifan_what) {
	case IFAN_ARRIVAL:
		if ((iface = if_new(ifan->ifan_index, ifan->ifan_name)) == NULL)
			fatal("if_announce failed");
		iface->cflags |= F_IFACE_AVAIL;
		break;
	case IFAN_DEPARTURE:
		iface = if_find(ifan->ifan_index);
		if (iface->cflags & F_IFACE_CONFIGURED) {
			main_imsg_compose_rde(IMSG_IFDELETE, 0,
			    &iface->ifindex, sizeof(iface->ifindex));
			main_imsg_compose_ospfe(IMSG_IFDELETE, 0,
			    &iface->ifindex, sizeof(iface->ifindex));
		}
		if_del(iface);
		break;
	}
}

/* rtsock */
int
send_rtmsg(int fd, int action, struct kroute *kroute)
{
	struct iovec		iov[5];
	struct rt_msghdr	hdr;
	struct pad {
		struct sockaddr_in6	addr;
		char			pad[sizeof(long)]; /* thank you IPv6 */
	} prefix, nexthop, mask;
	struct {
		struct sockaddr_dl	addr;
		char			pad[sizeof(long)];
	} ifp;
	struct sockaddr_rtlabel	sa_rl;
	int			iovcnt = 0;
	const char		*label;

	if (kr_state.fib_sync == 0)
		return (0);

	/* initialize header */
	bzero(&hdr, sizeof(hdr));
	hdr.rtm_version = RTM_VERSION;
	hdr.rtm_type = action;
	hdr.rtm_flags = RTF_UP|RTF_MPATH;
	hdr.rtm_priority = RTP_OSPF;
	if (action == RTM_CHANGE)
		hdr.rtm_fmask = RTF_REJECT|RTF_BLACKHOLE;
	hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	hdr.rtm_hdrlen = sizeof(hdr);
	hdr.rtm_msglen = sizeof(hdr);
	/* adjust iovec */
	iov[iovcnt].iov_base = &hdr;
	iov[iovcnt++].iov_len = sizeof(hdr);

	bzero(&prefix, sizeof(prefix));
	prefix.addr.sin6_len = sizeof(struct sockaddr_in6);
	prefix.addr.sin6_family = AF_INET6;
	prefix.addr.sin6_addr = kroute->prefix;
	/* adjust header */
	hdr.rtm_addrs |= RTA_DST;
	hdr.rtm_msglen += ROUNDUP(sizeof(struct sockaddr_in6));
	/* adjust iovec */
	iov[iovcnt].iov_base = &prefix;
	iov[iovcnt++].iov_len = ROUNDUP(sizeof(struct sockaddr_in6));

	if (!IN6_IS_ADDR_UNSPECIFIED(&kroute->nexthop)) {
		bzero(&nexthop, sizeof(nexthop));
		nexthop.addr.sin6_len = sizeof(struct sockaddr_in6);
		nexthop.addr.sin6_family = AF_INET6;
		nexthop.addr.sin6_addr = kroute->nexthop;
		nexthop.addr.sin6_scope_id = kroute->scope;
		/*
		 * XXX we should set the sin6_scope_id but the kernel
		 * XXX does not expect it that way. It must be fiddled
		 * XXX into the sin6_addr. Welcome to the typical
		 * XXX IPv6 insanity and all without wine bottles.
		 */
		embedscope(&nexthop.addr);

		/* adjust header */
		hdr.rtm_flags |= RTF_GATEWAY;
		hdr.rtm_addrs |= RTA_GATEWAY;
		hdr.rtm_msglen += ROUNDUP(sizeof(struct sockaddr_in6));
		/* adjust iovec */
		iov[iovcnt].iov_base = &nexthop;
		iov[iovcnt++].iov_len = ROUNDUP(sizeof(struct sockaddr_in6));
	} else if (kroute->ifindex) {
		/*
		 * We don't have an interface address in that network,
		 * so we install a cloning route.  The kernel will then
		 * do neigbor discovery.
		 */
		bzero(&ifp, sizeof(ifp));
		ifp.addr.sdl_len = sizeof(struct sockaddr_dl);
		ifp.addr.sdl_family = AF_LINK;

		ifp.addr.sdl_index  = kroute->ifindex;
		/* adjust header */
		hdr.rtm_flags |= RTF_CLONING;
		hdr.rtm_addrs |= RTA_GATEWAY;
		hdr.rtm_msglen += ROUNDUP(sizeof(struct sockaddr_dl));
		/* adjust iovec */
		iov[iovcnt].iov_base = &ifp;
		iov[iovcnt++].iov_len = ROUNDUP(sizeof(struct sockaddr_dl));
	}

	bzero(&mask, sizeof(mask));
	mask.addr.sin6_len = sizeof(struct sockaddr_in6);
	mask.addr.sin6_family = AF_INET6;
	mask.addr.sin6_addr = *prefixlen2mask(kroute->prefixlen);
	/* adjust header */
	if (kroute->prefixlen == 128)
		hdr.rtm_flags |= RTF_HOST;
	hdr.rtm_addrs |= RTA_NETMASK;
	hdr.rtm_msglen += ROUNDUP(sizeof(struct sockaddr_in6));
	/* adjust iovec */
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = ROUNDUP(sizeof(struct sockaddr_in6));

	if (kroute->rtlabel != 0) {
		sa_rl.sr_len = sizeof(sa_rl);
		sa_rl.sr_family = AF_UNSPEC;
		label = rtlabel_id2name(kroute->rtlabel);
		if (strlcpy(sa_rl.sr_label, label,
		    sizeof(sa_rl.sr_label)) >= sizeof(sa_rl.sr_label)) {
			log_warnx("send_rtmsg: invalid rtlabel");
			return (-1);
		}
		/* adjust header */
		hdr.rtm_addrs |= RTA_LABEL;
		hdr.rtm_msglen += sizeof(sa_rl);
		/* adjust iovec */
		iov[iovcnt].iov_base = &sa_rl;
		iov[iovcnt++].iov_len = sizeof(sa_rl);
	}

retry:
	if (writev(fd, iov, iovcnt) == -1) {
		if (errno == ESRCH) {
			if (hdr.rtm_type == RTM_CHANGE) {
				hdr.rtm_type = RTM_ADD;
				goto retry;
			} else if (hdr.rtm_type == RTM_DELETE) {
				log_info("route %s/%u vanished before delete",
				    log_sockaddr(&prefix), kroute->prefixlen);
				return (0);
			}
		}
		log_warn("send_rtmsg: action %u, prefix %s/%u", hdr.rtm_type,
		    log_sockaddr(&prefix), kroute->prefixlen);
		return (0);
	}

	return (0);
}

int
fetchtable(void)
{
	size_t			 len;
	int			 mib[7];
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in6	*sa_in6;
	struct sockaddr_rtlabel	*label;
	struct kroute_node	*kr;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET6;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
	mib[6] = 0;	/* rtableid */

	if (sysctl(mib, 7, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchtable");
		return (-1);
	}
	if (sysctl(mib, 7, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		if ((sa = rti_info[RTAX_DST]) == NULL)
			continue;

		/* Skip ARP/ND cache and broadcast routes. */
		if (rtm->rtm_flags & (RTF_LLINFO|RTF_BROADCAST))
			continue;

		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("fetchtable");
			free(buf);
			return (-1);
		}

		kr->r.flags = F_KERNEL;

		switch (sa->sa_family) {
		case AF_INET6:
			kr->r.prefix =
			    ((struct sockaddr_in6 *)sa)->sin6_addr;
			sa_in6 = (struct sockaddr_in6 *)rti_info[RTAX_NETMASK];
			if (rtm->rtm_flags & RTF_STATIC)
				kr->r.flags |= F_STATIC;
			if (rtm->rtm_flags & RTF_BLACKHOLE)
				kr->r.flags |= F_BLACKHOLE;
			if (rtm->rtm_flags & RTF_REJECT)
				kr->r.flags |= F_REJECT;
			if (rtm->rtm_flags & RTF_DYNAMIC)
				kr->r.flags |= F_DYNAMIC;
			if (rtm->rtm_flags & RTF_PROTO1)
				kr->r.flags |= F_BGPD_INSERTED;
			if (sa_in6 != NULL) {
				if (sa_in6->sin6_len == 0)
					break;
				kr->r.prefixlen =
				    mask2prefixlen(sa_in6);
			} else if (rtm->rtm_flags & RTF_HOST)
				kr->r.prefixlen = 128;
			else
				fatalx("classful IPv6 route?!!");
			break;
		default:
			free(kr);
			continue;
		}

		kr->r.ifindex = rtm->rtm_index;
		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
			case AF_INET6:
				if (rtm->rtm_flags & RTF_CONNECTED) {
					kr->r.flags |= F_CONNECTED;
					break;
				}

				sa_in6 = (struct sockaddr_in6 *)sa;
				/*
				 * XXX The kernel provides the scope via the
				 * XXX kame hack instead of the scope_id field.
				 */
				recoverscope(sa_in6);
				kr->r.nexthop = sa_in6->sin6_addr;
				kr->r.scope = sa_in6->sin6_scope_id;
				break;
			case AF_LINK:
				/*
				 * Traditional BSD connected routes have
				 * a gateway of type AF_LINK.
				 */
				kr->r.flags |= F_CONNECTED;
				break;
			}

		if (rtm->rtm_flags & RTF_PROTO2)  {
			send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);
			free(kr);
		} else {
			if ((label = (struct sockaddr_rtlabel *)
			    rti_info[RTAX_LABEL]) != NULL) {
				kr->r.rtlabel =
				    rtlabel_name2id(label->sr_label);
				kr->r.ext_tag =
				    rtlabel_id2tag(kr->r.rtlabel);
			}
			kroute_insert(kr);
		}

	}
	free(buf);
	return (0);
}

int
fetchifs(u_short ifindex)
{
	size_t			 len;
	int			 mib[6];
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct ifa_msghdr	*ifam;
	struct iface		*iface;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET6;
	mib[4] = NET_RT_IFLIST;
	mib[5] = ifindex;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchifs");
		return (-1);
	}
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		switch (rtm->rtm_type) {
		case RTM_IFINFO:
			bcopy(rtm, &ifm, sizeof ifm);
			sa = (struct sockaddr *)(next + sizeof(ifm));
			get_rtaddrs(ifm.ifm_addrs, sa, rti_info);

			if ((iface = kif_update(ifm.ifm_index,
			    ifm.ifm_flags, &ifm.ifm_data,
			    (struct sockaddr_dl *)rti_info[RTAX_IFP])) == NULL)
			break;
		case RTM_NEWADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);

			if_newaddr(ifam->ifam_index,
			    (struct sockaddr_in6 *)rti_info[RTAX_IFA],
			    (struct sockaddr_in6 *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in6 *)rti_info[RTAX_BRD]);
			break;
		}
	}
	free(buf);
	return (0);
}

int
dispatch_rtmsg(void)
{
	char			 buf[RT_BUF_SIZE];
	ssize_t			 n;
	char			*next, *lim;
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct ifa_msghdr	*ifam;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in6	*sa_in6;
	struct sockaddr_rtlabel	*label;
	struct kroute_node	*kr, *okr;
	struct in6_addr		 prefix, nexthop;
	u_int8_t		 prefixlen;
	int			 flags, mpath;
	unsigned int		 scope;
	u_short			 ifindex = 0;

	if ((n = read(kr_state.fd, &buf, sizeof(buf))) == -1) {
		if (errno == EAGAIN || errno == EINTR)
			return (0);
		log_warn("dispatch_rtmsg: read error");
		return (-1);
	}

	if (n == 0) {
		log_warnx("routing socket closed");
		return (-1);
	}

	lim = buf + n;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (lim < next + sizeof(u_short) ||
		    lim < next + rtm->rtm_msglen)
			fatalx("dispatch_rtmsg: partial rtm in buffer");
		if (rtm->rtm_version != RTM_VERSION)
			continue;

		bzero(&prefix, sizeof(prefix));
		bzero(&nexthop, sizeof(nexthop));
		scope = 0;
		prefixlen = 0;
		flags = F_KERNEL;
		mpath = 0;

		if (rtm->rtm_type == RTM_ADD || rtm->rtm_type == RTM_CHANGE ||
		    rtm->rtm_type == RTM_DELETE) {
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

			if (rtm->rtm_tableid != 0)
				continue;

			if (rtm->rtm_pid == kr_state.pid) /* caused by us */
				continue;

			if (rtm->rtm_errno)		/* failed attempts... */
				continue;

			/* Skip ARP/ND cache and broadcast routes. */
			if (rtm->rtm_flags & (RTF_LLINFO|RTF_BROADCAST))
				continue;

#ifdef RTF_MPATH
			if (rtm->rtm_flags & RTF_MPATH)
				mpath = 1;
#endif
			switch (sa->sa_family) {
			case AF_INET6:
				prefix =
				    ((struct sockaddr_in6 *)sa)->sin6_addr;
				sa_in6 = (struct sockaddr_in6 *)
				    rti_info[RTAX_NETMASK];
				if (sa_in6 != NULL) {
					if (sa_in6->sin6_len != 0)
						prefixlen = mask2prefixlen(
						    sa_in6);
				} else if (rtm->rtm_flags & RTF_HOST)
					prefixlen = 128;
				else
					fatalx("classful IPv6 address?!!");
				if (rtm->rtm_flags & RTF_STATIC)
					flags |= F_STATIC;
				if (rtm->rtm_flags & RTF_BLACKHOLE)
					flags |= F_BLACKHOLE;
				if (rtm->rtm_flags & RTF_REJECT)
					flags |= F_REJECT;
				if (rtm->rtm_flags & RTF_DYNAMIC)
					flags |= F_DYNAMIC;
				if (rtm->rtm_flags & RTF_PROTO1)
					flags |= F_BGPD_INSERTED;
				break;
			default:
				continue;
			}

			ifindex = rtm->rtm_index;
			if ((sa = rti_info[RTAX_GATEWAY]) != NULL) {
				switch (sa->sa_family) {
				case AF_INET6:
					sa_in6 = (struct sockaddr_in6 *)sa;
					/*
					 * XXX The kernel provides the scope
					 * XXX via the kame hack instead of
					 * XXX the scope_id field.
					 */
					recoverscope(sa_in6);
					nexthop = sa_in6->sin6_addr;
					scope = sa_in6->sin6_scope_id;
					break;
				case AF_LINK:
					flags |= F_CONNECTED;
					break;
				}
			}
		}

		switch (rtm->rtm_type) {
		case RTM_ADD:
		case RTM_CHANGE:
			if (IN6_IS_ADDR_UNSPECIFIED(&nexthop) &&
			    !(flags & F_CONNECTED)) {
				log_warnx("dispatch_rtmsg no nexthop for %s/%u",
				    log_in6addr(&prefix), prefixlen);
				continue;
			}

			if ((okr = kroute_find(&prefix, prefixlen)) !=
			    NULL) {
				/* just add new multipath routes */
				if (mpath && rtm->rtm_type == RTM_ADD)
					goto add;
				/* get the correct route */
				kr = okr;
				if (mpath && (kr = kroute_matchgw(okr,
				    &nexthop, scope)) == NULL) {
					log_warnx("dispatch_rtmsg mpath route"
					    " not found");
					/* add routes we missed out earlier */
					goto add;
				}

				/*
				 * ospf route overridden by kernel. Preference
				 * of the route is not checked because this is
				 * forced -- most probably by a user.
				 */
				if (kr->r.flags & F_OSPFD_INSERTED)
					flags |= F_OSPFD_INSERTED;
				if (kr->r.flags & F_REDISTRIBUTED)
					flags |= F_REDISTRIBUTED;
				kr->r.nexthop = nexthop;
				kr->r.scope = scope;
				kr->r.flags = flags;
				kr->r.ifindex = ifindex;

				rtlabel_unref(kr->r.rtlabel);
				kr->r.rtlabel = 0;
				kr->r.ext_tag = 0;
				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL) {
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);
					kr->r.ext_tag =
					    rtlabel_id2tag(kr->r.rtlabel);
				}

				if (kif_validate(kr->r.ifindex))
					kr->r.flags &= ~F_DOWN;
				else
					kr->r.flags |= F_DOWN;

				/* just readd, the RDE will care */
				kr_redistribute(okr);
			} else {
add:
				if ((kr = calloc(1,
				    sizeof(struct kroute_node))) == NULL) {
					log_warn("dispatch_rtmsg");
					return (-1);
				}
				kr->r.prefix = prefix;
				kr->r.prefixlen = prefixlen;
				kr->r.nexthop = nexthop;
				kr->r.scope = scope;
				kr->r.flags = flags;
				kr->r.ifindex = ifindex;

				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL) {
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);
					kr->r.ext_tag =
					    rtlabel_id2tag(kr->r.rtlabel);
				}

				kroute_insert(kr);
			}
			break;
		case RTM_DELETE:
			if ((kr = kroute_find(&prefix, prefixlen)) ==
			    NULL)
				continue;
			if (!(kr->r.flags & F_KERNEL))
				continue;
			/* get the correct route */
			okr = kr;
			if (mpath && (kr = kroute_matchgw(kr, &nexthop,
			    scope)) == NULL) {
				log_warnx("dispatch_rtmsg mpath route"
				    " not found");
				return (-1);
			}
			/*
			 * last route is getting removed request the
			 * ospf route from the RDE to insert instead
			 */
			if (okr == kr && kr->next == NULL &&
			    kr->r.flags & F_OSPFD_INSERTED)
				main_imsg_compose_rde(IMSG_KROUTE_GET, 0,
				    &kr->r, sizeof(struct kroute));
			if (kroute_remove(kr) == -1)
				return (-1);
			break;
		case RTM_IFINFO:
			memcpy(&ifm, next, sizeof(ifm));
			if_change(ifm.ifm_index, ifm.ifm_flags,
			    &ifm.ifm_data);
			break;
		case RTM_NEWADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);

			if_newaddr(ifam->ifam_index,
			    (struct sockaddr_in6 *)rti_info[RTAX_IFA],
			    (struct sockaddr_in6 *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in6 *)rti_info[RTAX_BRD]);
			break;
		case RTM_DELADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);

			if_deladdr(ifam->ifam_index,
			    (struct sockaddr_in6 *)rti_info[RTAX_IFA],
			    (struct sockaddr_in6 *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in6 *)rti_info[RTAX_BRD]);
			break;
		case RTM_IFANNOUNCE:
			if_announce(next);
			break;
		default:
			/* ignore for now */
			break;
		}
	}
	return (0);
}
@


1.50
log
@Replace struct rroute with struct kroute, as done in ospfd

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.49 2016/12/22 23:01:58 jca Exp $ */
d62 2
d146 89
a234 1
kr_change(struct kroute *kroute)
d241 4
a244 5
	if ((kr = kroute_find(&kroute->prefix, kroute->prefixlen)) !=
	    NULL) {
		if (!(kr->r.flags & F_KERNEL))
			action = RTM_CHANGE;
		else {	/* a non-ospf route already exists. not a problem */
d263 2
a264 6
			kr->r.flags = kroute->flags | F_OSPFD_INSERTED;
			kr->r.ifindex = 0;
			rtlabel_unref(kr->r.rtlabel);
			kr->r.ext_tag = kroute->ext_tag;
			kr->r.rtlabel = kroute->rtlabel;
		}
d267 8
a274 3
	/* nexthop within 127/8 -> ignore silently */
	if (kr && IN6_IS_ADDR_LOOPBACK(&kr->r.nexthop))
		return (0);
d276 3
a278 6
	/*
	 * Ingnore updates that did not change the route.
	 * Currently only the nexthop can change.
	 */
	if (kr && kr->r.scope == kroute->scope &&
	    IN6_ARE_ADDR_EQUAL(&kr->r.nexthop, &kroute->nexthop))
d280 1
d282 1
a282 1
	if (send_rtmsg(kr_state.fd, action, kroute) == -1)
d285 2
a286 19
	if (action == RTM_ADD) {
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("kr_change");
			return (-1);
		}
		kr->r.prefix = kroute->prefix;
		kr->r.prefixlen = kroute->prefixlen;
		kr->r.nexthop = kroute->nexthop;
		kr->r.scope = kroute->scope;
		kr->r.flags = kroute->flags | F_OSPFD_INSERTED;
		kr->r.ext_tag = kroute->ext_tag;
		kr->r.rtlabel = kroute->rtlabel;

		if (kroute_insert(kr) == -1)
			free(kr);
	} else if (kr) {
		kr->r.nexthop = kroute->nexthop;
		kr->r.scope = kroute->scope;
	}
d294 1
a294 1
	struct kroute_node	*kr;
d300 5
a304 10
	if (!(kr->r.flags & F_OSPFD_INSERTED))
		return (0);

	if (kr->r.flags & F_KERNEL) {
		/* remove F_OSPFD_INSERTED flag, route still exists in kernel */
		do {
			kr->r.flags &= ~F_OSPFD_INSERTED;
			kr = kr->next;
		} while (kr);
		return (0);
a306 6
	if (send_rtmsg(kr_state.fd, RTM_DELETE, kroute) == -1)
		return (-1);

	if (kroute_remove(kr) == -1)
		return (-1);

d321 1
d330 3
a332 1
			send_rtmsg(kr_state.fd, RTM_ADD, &kr->r);
d341 1
d346 1
a346 1
	RB_FOREACH(kr, kroute_tree, &krt)
d348 4
a351 1
			send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);
d1002 1
a1002 1
	hdr.rtm_flags = RTF_UP;
@


1.49
log
@Let rde and ospfe know about all IFINFO messages (eg an interface MTU change).

The parent now passes all IFINFO messages down to the children, then
looks whether he has any work to do.  Same idea as ospfd.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.48 2015/07/17 20:12:38 claudio Exp $ */
d54 1
a55 1
	struct kroute_node	*next;
d59 1
a59 1
int	kr_redist_eval(struct kroute *, struct rroute *);
d347 1
a347 1
	struct rroute	 rr;
d355 1
a355 2
	rr.kr = kn->r;
	rr.metric = DEFAULT_REDIST_METRIC;	/* some dummy value */
d363 2
a364 2
		main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, &rr,
		    sizeof(struct rroute));
d368 1
a368 1
kr_redist_eval(struct kroute *kr, struct rroute *rr)
d413 3
a415 3
	if (rr->metric > metric) {
		rr->kr = *kr;
		rr->metric = metric;
d433 1
a433 1
	struct rroute		 rr;
d436 2
a437 2
	bzero(&rr, sizeof(rr));
	rr.metric = UINT_MAX;
d439 1
a439 1
		if (kr_redist_eval(&kn->r, &rr))
d445 3
a447 3
	if (rr.kr.flags & F_REDISTRIBUTED) {
		main_imsg_compose_rde(IMSG_NETWORK_ADD, 0, &rr,
		    sizeof(struct rroute));
d449 3
a451 4
		rr.metric = DEFAULT_REDIST_METRIC;	/* some dummy value */
		rr.kr = kh->r;
		main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, &rr,
		    sizeof(struct rroute));
@


1.48
log
@Similar to bgpd and ospfd skip broadcast (should not happen) and llinfo
routes also adjust the tracking of connected routes to the new way.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.47 2015/02/11 05:58:57 claudio Exp $ */
a731 6
	isvalid = (iface->flags & IFF_UP) &&
	    LINK_STATE_IS_UP(iface->linkstate);

	if (wasvalid == isvalid)
		return;		/* nothing changed wrt validity */

d739 6
@


1.47
log
@Use sizeof(u_short) in the first check since there are RT messages that
are less then sizeof(*rtm) bytes long (e.g. interface announcements).
Found the hard way by phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.46 2015/02/10 05:39:10 claudio Exp $ */
d1095 2
a1096 1
		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
d1141 5
d1156 4
d1311 2
a1312 1
			if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
@


1.46
log
@Same session_socket_blockmode() changes as done to ospfd. Also do the same
kroute change (make socket non-blocking and add trigger for partial reads).
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.45 2015/01/16 06:40:19 deraadt Exp $ */
d1274 1
a1274 1
		if (lim < next + sizeof(*rtm) ||
@


1.45
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.44 2014/06/23 03:46:17 guenther Exp $ */
d101 2
a102 1
	if ((kr_state.fd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1) {
d1260 2
d1274 3
@


1.44
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.43 2013/10/30 17:24:34 deraadt Exp $ */
a19 1
#include <sys/param.h>
d38 1
@


1.43
log
@another simple %i to %d conversion for obviousness
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.42 2013/03/22 13:17:54 sthen Exp $ */
d1062 1
a1062 1
	mib[1] = AF_ROUTE;
d1185 1
a1185 1
	mib[1] = AF_ROUTE;
@


1.42
log
@sync comment typos/whitespace with ospfd
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.41 2013/01/14 14:39:38 florian Exp $ */
d771 1
a771 1
		log_warnx("if_newaddr: corresponding if %i not found", ifindex);
d845 1
a845 1
		log_warnx("if_deladdr: corresponding if %i not found", ifindex);
@


1.41
log
@kroute.c rev 1.69 of ospfd for ospf6d
------------------------------------------------------------------------
date: 2009/06/02 20:16:59;  author: claudio;  state: Exp;  lines: +13 -3
Track reject and blackhole routes and allow them to be redistributed even
though they point to the loopback. Mainly used for redistribute default since
on default free routers we need to have a fake route now.
After discussion with Tonnerre Lombard, idea OK henning@@
------------------------------------------------------------------------
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.40 2012/10/21 21:30:44 bluhm Exp $ */
d403 1
a403 1
	/* Should we redistrubute this route? */
d410 1
a410 1
	 * only on of all multipath routes can be redistributed so
d417 1
@


1.40
log
@Move common ospf6d functions for ipv6 address manipulation into
util.c to reuse them in ospf6ctl.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.39 2012/09/20 17:39:08 bluhm Exp $ */
d396 2
a397 1
	 * Consider networks with nexthop loopback as not redistributable.
d399 2
a400 1
	if (IN6_IS_ADDR_LOOPBACK(&kr->nexthop))
d1111 4
d1317 4
@


1.39
log
@The current code in ospf6d kroute tries to read the scope of the
route from the gateway's scope id.  That does not work as the kernel
provides the scope id via the kame hack instead of the sin6_scope_id
field of the sockaddr_in6.  Call recoverscope() to fix that.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.38 2012/09/19 19:20:34 bluhm Exp $ */
a693 132
}

#define IN6_IS_SCOPE_EMBED(a)   \
	((IN6_IS_ADDR_LINKLOCAL(a)) ||  \
	 (IN6_IS_ADDR_MC_LINKLOCAL(a)) || \
	 (IN6_IS_ADDR_MC_INTFACELOCAL(a)))

void
embedscope(struct sockaddr_in6 *sin6)
{
	u_int16_t	 tmp16;

	if (IN6_IS_SCOPE_EMBED(&sin6->sin6_addr)) {
		bcopy(&sin6->sin6_addr.s6_addr[2], &tmp16, sizeof(tmp16));
		if (tmp16 != 0) {
			log_warnx("embedscope: address %s already has embeded "
			    "scope %u", log_sockaddr(sin6), ntohs(tmp16));
		}
		tmp16 = htons(sin6->sin6_scope_id);
		bcopy(&tmp16, &sin6->sin6_addr.s6_addr[2], sizeof(tmp16));
		sin6->sin6_scope_id = 0;
	}
}

void
recoverscope(struct sockaddr_in6 *sin6)
{
	u_int16_t	 tmp16;

	if (sin6->sin6_scope_id != 0) {
		log_warnx("recoverscope: address %s already has scope id %u",
		    log_sockaddr(sin6), sin6->sin6_scope_id);
	}

	if (IN6_IS_SCOPE_EMBED(&sin6->sin6_addr)) {
		bcopy(&sin6->sin6_addr.s6_addr[2], &tmp16, sizeof(tmp16));
		sin6->sin6_scope_id = ntohs(tmp16);
		sin6->sin6_addr.s6_addr[2] = 0;
		sin6->sin6_addr.s6_addr[3] = 0;
	}
}

void
clearscope(struct in6_addr *in6)
{
	if (IN6_IS_SCOPE_EMBED(in6)) {
		in6->s6_addr[2] = 0;
		in6->s6_addr[3] = 0;
	}
}

#undef IN6_IS_SCOPE_EMBED

u_int8_t
mask2prefixlen(struct sockaddr_in6 *sa_in6)
{
	u_int8_t	l = 0, *ap, *ep;

	/*
	 * sin6_len is the size of the sockaddr so substract the offset of
	 * the possibly truncated sin6_addr struct.
	 */
	ap = (u_int8_t *)&sa_in6->sin6_addr;
	ep = (u_int8_t *)sa_in6 + sa_in6->sin6_len;
	for (; ap < ep; ap++) {
		/* this "beauty" is adopted from sbin/route/show.c ... */
		switch (*ap) {
		case 0xff:
			l += 8;
			break;
		case 0xfe:
			l += 7;
			return (l);
		case 0xfc:
			l += 6;
			return (l);
		case 0xf8:
			l += 5;
			return (l);
		case 0xf0:
			l += 4;
			return (l);
		case 0xe0:
			l += 3;
			return (l);
		case 0xc0:
			l += 2;
			return (l);
		case 0x80:
			l += 1;
			return (l);
		case 0x00:
			return (l);
		default:
			fatalx("non contiguous inet6 netmask");
		}
	}

	return (l);
}

struct in6_addr *
prefixlen2mask(u_int8_t prefixlen)
{
	static struct in6_addr	mask;
	int			i;

	bzero(&mask, sizeof(mask));
	for (i = 0; i < prefixlen / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

	return (&mask);
}

void
inet6applymask(struct in6_addr *dest, const struct in6_addr *src, int prefixlen)
{
	struct in6_addr	mask;
	int		i;

	bzero(&mask, sizeof(mask));
	for (i = 0; i < prefixlen / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

	for (i = 0; i < 16; i++)
		dest->s6_addr[i] = src->s6_addr[i] & mask.s6_addr[i];
@


1.38
log
@Instead of fiddling about the kame hack here and there, implement
the functions embedscope(), recoverscope(), clearscope().
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.37 2012/09/17 13:49:27 bluhm Exp $ */
d1264 8
a1271 4
				kr->r.nexthop =
				    ((struct sockaddr_in6 *)sa)->sin6_addr;
				kr->r.scope =
				    ((struct sockaddr_in6 *)sa)->sin6_scope_id;
d1456 9
a1464 4
					nexthop = ((struct sockaddr_in6 *)
					    sa)->sin6_addr;
					scope = ((struct sockaddr_in6 *)
					    sa)->sin6_scope_id;
@


1.37
log
@Fix trailing whitespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.36 2011/07/07 18:39:11 claudio Exp $ */
d696 51
d913 1
a913 5
	/* XXX thanks, KAME, for this ugliness... adopted from route/show.c */
	if (IN6_IS_ADDR_LINKLOCAL(&ifa->sin6_addr)) {
		ifa->sin6_addr.s6_addr[2] = 0;
		ifa->sin6_addr.s6_addr[3] = 0;
	}
d987 1
a987 5
	/* XXX thanks, KAME, for this ugliness... adopted from route/show.c */
	if (IN6_IS_ADDR_LINKLOCAL(&ifa->sin6_addr)) {
		ifa->sin6_addr.s6_addr[2] = 0;
		ifa->sin6_addr.s6_addr[3] = 0;
	}
d1092 1
d1099 2
a1100 7
		if (IN6_IS_ADDR_LINKLOCAL(&nexthop.addr.sin6_addr)) {
			/* nexthop.addr.sin6_scope_id = kroute->scope; */
			nexthop.addr.sin6_addr.s6_addr[2] =
			    (kroute->scope >> 8) & 0xff;
			nexthop.addr.sin6_addr.s6_addr[3] =
			    kroute->scope & 0xff;
		}
@


1.36
log
@It helps to set the sdl_family so that the kernel knows what this is.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.35 2011/07/07 17:10:48 claudio Exp $ */
d1078 1
a1078 1
		
@


1.35
log
@Rework the distribution of link state and iface FSM state changes.
Link state changes are sent from the parent to both childs and
iface FSM state changes are sent from the ospfe to the rde.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.34 2011/07/07 17:06:51 claudio Exp $ */
d1077 1
@


1.34
log
@Only send interface address changes to the ospfe/rde if the interface
is actually used by the config. This should fix the exits caused when
interfaces are dynamically added to the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.33 2011/07/07 03:56:59 claudio Exp $ */
d815 2
a816 2
	/* notify ospfe about interface link state */
	if (iface->cflags & F_IFACE_CONFIGURED)
d819 3
@


1.33
log
@Commit stuff that I added to another tree eventhough it should have
been in the last commit. I should not work on multiple laptops at
the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.32 2011/07/07 00:36:13 claudio Exp $ */
d902 9
a910 6
	ifc.addr = ia->addr;
	ifc.dstbrd = ia->dstbrd;
	ifc.prefixlen = ia->prefixlen;
	ifc.ifindex = ifindex;
	main_imsg_compose_ospfe(IMSG_IFADDRNEW, 0, &ifc, sizeof(ifc));
	main_imsg_compose_rde(IMSG_IFADDRNEW, 0, &ifc, sizeof(ifc));
d950 11
a960 8
			ifc.addr = ia->addr;
			ifc.dstbrd = ia->dstbrd;
			ifc.prefixlen = ia->prefixlen;
			ifc.ifindex = ifindex;
			main_imsg_compose_ospfe(IMSG_IFADDRDEL, 0, &ifc,
			    sizeof(ifc));
			main_imsg_compose_rde(IMSG_IFADDRDEL, 0, &ifc,
			    sizeof(ifc));
@


1.32
log
@Kill nh_reachable. Link state checking is so easy now that it does not
matter anymore to cache this value for ospf6d.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.31 2011/07/04 04:34:14 claudio Exp $ */
d648 1
a648 1
		return (1);
d1268 1
a1268 1
		log_warn("fetchif");
@


1.31
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.30 2011/03/07 07:43:02 henning Exp $ */
d651 1
a651 1
	return (iface->nh_reachable);
d800 3
a802 1
	u_int8_t		 reachable;
d809 1
a809 1
	reachable = (iface->flags & IFF_UP) &&
d812 2
a813 4
	if (reachable == iface->nh_reachable)
		return;		/* nothing changed wrt nexthop validity */

	iface->nh_reachable = reachable;
d824 1
a824 1
				if (reachable)
d1068 1
a1068 1
		ifp.addr.sdl_family = AF_LINK;
a1290 4
				fatal("fetchifs");

			iface->nh_reachable = (iface->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(ifm.ifm_data.ifi_link_state);
@


1.30
log
@continguous -> contiguous
From: "Anthony J. Bentley" <anthonyjbentley at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.29 2010/10/14 07:38:05 claudio Exp $ */
d808 1
a808 3
	    (LINK_STATE_IS_UP(iface->linkstate) ||
	    (iface->linkstate == LINK_STATE_UNKNOWN &&
	    iface->media_type != IFT_CARP));
d1294 1
a1294 4
			    (LINK_STATE_IS_UP(ifm.ifm_data.ifi_link_state) ||
			    (ifm.ifm_data.ifi_link_state ==
			    LINK_STATE_UNKNOWN &&
			    ifm.ifm_data.ifi_type != IFT_CARP));
@


1.29
log
@Same fix as previously commited to ospfd. Ensure that kr_redistribute()
is called with the head node of a multipath chain.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.28 2010/08/22 21:15:25 bluhm Exp $ */
d737 1
a737 1
			fatalx("non continguous inet6 netmask");
@


1.28
log
@Redistributing the default route with ospf6d did not work correctly.
- kroute.c may not ignore the default route.
- Use the ROUNDUP macro from route/show.c as this one is also correct
  for netmask with prefixlen 0.
- Implement ospf_redistribute and the redistribute parser like
  ospfd.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.27 2010/07/14 17:09:13 claudio Exp $ */
d525 1
a525 1
	struct kroute_node	*krm;
d527 1
a527 1
	if ((krm = RB_INSERT(kroute_tree, &krt, kr)) != NULL) {
d532 1
d539 1
a539 1
		krm = kr;
d552 1
a552 1
	kr_redistribute(krm);
@


1.27
log
@Another hand knitted offsetof() that needs to die. This time steal the
mask2prefixlen6 version from bgpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.26 2010/07/12 14:35:13 bluhm Exp $ */
d385 1
a385 1
	 * We consider unspecified, loopback, multicast, link- and site-local,
d388 1
a388 2
	if (IN6_IS_ADDR_UNSPECIFIED(&kr->prefix) ||
	    IN6_IS_ADDR_LOOPBACK(&kr->prefix) ||
d776 2
a777 2
#define	ROUNDUP(a)	\
    (((a) & (sizeof(long) - 1)) ? (1 + ((a) | (sizeof(long) - 1))) : (a))
@


1.26
log
@Merge duplicate log messages into one log_warn().
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.25 2010/07/06 13:24:35 bluhm Exp $ */
d699 1
a699 1
	u_int8_t	l = 0, i, len;
d705 3
a707 3
	len = sa_in6->sin6_len -
	    (u_int8_t)(&((struct sockaddr_in6 *)NULL)->sin6_addr);
	for (i = 0; i < len; i++) {
d709 1
a709 1
		switch (sa_in6->sin6_addr.s6_addr[i]) {
@


1.25
log
@Update the interfaces changes from kroute to rde via imsg.  This
is needed to orginate correct intra-area-prefix-lsas.
ok claudio@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.24 2010/07/01 19:47:04 bluhm Exp $ */
d1113 1
a1113 2
		switch (errno) {
		case ESRCH:
a1120 5
			} else {
				log_warn("send_rtmsg: action %u, "
				    "prefix %s/%u", hdr.rtm_type,
				    log_sockaddr(&prefix), kroute->prefixlen);
				return (0);
a1121 6
			break;
		default:
			log_warn("send_rtmsg: action %u, prefix %s/%u",
			    hdr.rtm_type, log_sockaddr(&prefix),
			    kroute->prefixlen);
			return (0);
d1123 3
@


1.24
log
@Fix all white space bugs in ospf6d at once.  No binary change.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.23 2010/07/01 18:57:21 bluhm Exp $ */
d909 1
d954 2
@


1.23
log
@The prefixes of interface addresses of an ospf link have to be
advertised as link-lsa and intra-area-prefix-lsa when they change
dynamically.  Handle RTM_NEWADDR and RTM_DELADDR in kroute by sending
an imsg to ospfe.  Upon this event, originate a new link-lsa in
ospfe.  In rde a new intra-area-prefix-lsa is generated when a
link-lsa appears or goes away.
ok claudio@@; ok and test stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.22 2010/06/28 15:06:00 bluhm Exp $ */
d859 1
a859 1
	    	return;
d902 1
a902 1
		
d933 1
a933 1
	    	return;
@


1.22
log
@If there is no next hop but an interface index, create a cloning
route.  This happens when we learn from another router that a
directly attached link has a prefix for which we have no address
configured at the interface.  In this case, we should do neighbor
discovery to directly reach the hosts with that prefix on the link.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.21 2010/06/12 10:03:38 bluhm Exp $ */
d81 2
d843 1
d904 54
d1551 13
@


1.21
log
@The "dispatch_rtmsg no nexthop" error was emitted in wrong cases
and prevented dynamic route redistribution.  Fix the logic bug that
was introduced during IPv4 to IPv6 conversion.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.20 2010/06/09 17:46:42 claudio Exp $ */
d940 4
d1002 17
@


1.20
log
@Only embed the interface scope for link local nexthops. AS-ext LSA have
an optional non link local forwarding address so we need to be a bit more
careful here. Problem found and analyzed by Martin Pelikn.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.19 2010/02/23 16:22:57 claudio Exp $ */
d1355 1
a1355 1
			if (!IN6_IS_ADDR_UNSPECIFIED(&nexthop) &&
@


1.19
log
@This is a total dejavu of bgpd/kroute.c 1.165. Because IPv6 fucked up and
created a badly sized struct sockaddr_in6 we need to add some magic pading
on 64bit archs.
Code stolen from bgpd after a painful afternoon of bug hunting, head
scratching and violent cursing.  Now ospf6d works on 64bit archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.18 2009/12/23 15:11:41 claudio Exp $ */
d984 7
a990 3
		/* nexthop.addr.sin6_scope_id = kroute->scope; */
		nexthop.addr.sin6_addr.s6_addr[2] = (kroute->scope >> 8) & 0xff;
		nexthop.addr.sin6_addr.s6_addr[3] = kroute->scope & 0xff;
@


1.18
log
@Loopback interface don't have link local addresses so use the real IPv6
address for so that the device is no considered unnumbered.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.17 2009/12/22 19:44:52 claudio Exp $ */
d775 2
a776 2
#define	ROUNDUP(a, size)	\
    (((a) & ((size) - 1)) ? (1 + ((a) | ((size) - 1))) : (a))
d787 1
a787 1
			    ROUNDUP(sa->sa_len, sizeof(long)));
d936 4
a939 3
	struct sockaddr_in6	prefix;
	struct sockaddr_in6	nexthop;
	struct sockaddr_in6	mask;
d951 1
a951 1
	hdr.rtm_flags = RTF_UP|RTF_PROTO2;
d953 2
a954 2
	if (action == RTM_CHANGE)	/* force PROTO2 reset the other flags */
		hdr.rtm_fmask = RTF_PROTO2|RTF_PROTO1|RTF_REJECT|RTF_BLACKHOLE;
d956 1
d963 3
a965 3
	prefix.sin6_len = sizeof(prefix);
	prefix.sin6_family = AF_INET6;
	prefix.sin6_addr = kroute->prefix;
d968 1
a968 1
	hdr.rtm_msglen += sizeof(prefix);
d971 1
a971 1
	iov[iovcnt++].iov_len = sizeof(prefix);
d975 3
a977 3
		nexthop.sin6_len = sizeof(nexthop);
		nexthop.sin6_family = AF_INET6;
		nexthop.sin6_addr = kroute->nexthop;
d984 3
a986 3
		/* nexthop.sin6_scope_id = kroute->scope; */
		nexthop.sin6_addr.s6_addr[2] = (kroute->scope >> 8) & 0xff;
		nexthop.sin6_addr.s6_addr[3] = kroute->scope & 0xff;
d990 1
a990 1
		hdr.rtm_msglen += sizeof(nexthop);
d993 1
a993 1
		iov[iovcnt++].iov_len = sizeof(nexthop);
d997 3
a999 3
	mask.sin6_len = sizeof(mask);
	mask.sin6_family = AF_INET6;
	mask.sin6_addr = *prefixlen2mask(kroute->prefixlen);
d1004 1
a1004 1
	hdr.rtm_msglen += sizeof(mask);
d1007 1
a1007 1
	iov[iovcnt++].iov_len = sizeof(mask);
@


1.17
log
@Holy inconsitancy Batman! While it is impossible to use embeded scope ids
in almost all sockaddr_in6 addresses it is required for the nexthop and
sin6_scope_id is actually ignored there.
This needs to be fixed but my quota of IPv6 insanity is already used for today.
Workaround for now. My simple testsetup is now actually able to install
the first ospf6d learned routes in the kernel. Weeee!
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.16 2009/12/22 19:32:36 claudio Exp $ */
d864 2
a865 1
	if (IN6_IS_ADDR_LINKLOCAL(&ifa->sin6_addr))
@


1.16
log
@Add interface index aka. scope id to struct kroute so that the rde can pass
this information to kroute and kroute can use that information to fill in
the various sin6_scope_id fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.15 2009/12/21 18:35:43 claudio Exp $ */
d975 9
a983 1
		nexthop.sin6_scope_id = kroute->scope;
@


1.15
log
@Another AF_INET that should be an AF_INET6.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.14 2009/12/21 18:29:31 claudio Exp $ */
d65 1
a65 1
			    struct in6_addr *);
d187 2
a188 1
	if (kr && IN6_ARE_ADDR_EQUAL(&kr->r.nexthop, &kroute->nexthop))
d202 1
d209 1
a209 1
	} else if (kr)
d211 2
d509 1
a509 1
kroute_matchgw(struct kroute_node *kr, struct in6_addr *nh)
d512 2
a513 1
		if (IN6_ARE_ADDR_EQUAL(&kr->r.nexthop, nh))
d949 1
a949 1
	hdr.rtm_flags = RTF_PROTO2;
d975 1
d990 2
d1132 2
d1249 1
d1270 1
d1327 2
d1340 1
a1340 1
			if (IN6_IS_ADDR_UNSPECIFIED(&nexthop) == 0 &&
d1355 1
a1355 1
				    &nexthop)) == NULL) {
d1372 1
d1404 1
d1427 2
a1428 2
			if (mpath &&
			    (kr = kroute_matchgw(kr, &nexthop)) == NULL) {
@


1.14
log
@Doh! It helps to load the IPv6 routing table into kroute instead of IPv4.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.13 2009/09/20 20:27:53 stsp Exp $ */
d1312 1
a1312 1
				case AF_INET:
@


1.13
log
@In kif_update(), the ifname array could be used uninitialised if the
caller passed NULL for the sdl parameter.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.12 2009/06/05 22:40:24 chris Exp $ */
d1051 1
a1051 1
	mib[3] = AF_INET;
@


1.12
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.11 2009/04/09 19:03:10 stsp Exp $ */
d612 1
a613 1
			bzero(ifname, sizeof(ifname));
d619 4
a622 2
		}

@


1.11
log
@Don't dereference NULL pointers. This crash wasn't found yet because
we never entered this code path before. This is just a temporary fix.
The kroute code desperately needs a sync to ospfd.

"Looks sensible to me" jsing@@, "Yes and yes" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.10 2009/02/03 14:06:18 stsp Exp $ */
d1073 1
a1073 1
		sa = (struct sockaddr *)(rtm + 1);
d1263 1
a1263 1
			sa = (struct sockaddr *)(rtm + 1);
@


1.10
log
@We don't need anything other than link-local addresses and
global-scope prefixes in iface->ifa_list.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.9 2009/01/04 18:20:22 stsp Exp $ */
d180 1
a180 1
	if (IN6_IS_ADDR_LOOPBACK(&kr->r.nexthop))
d207 1
a207 1
	} else
@


1.9
log
@if_newaddr() was hard-coding all interface prefixes to /64.
Make it smarter so that ospf6d knows the actual prefix length
configured on an interface.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.8 2008/05/09 12:55:48 claudio Exp $ */
d841 10
d852 1
a852 2
	if (IN6_IS_ADDR_LINKLOCAL(&ifa->sin6_addr) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&ifa->sin6_addr)) {
@


1.8
log
@Henning forgot ospf6d. Add priority to ospf6d as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.7 2008/02/11 13:48:39 norby Exp $ */
d857 1
a857 1
		ia->prefixlen = 64; // XXX mask2prefixlen(&mask->sin6_addr);
d860 2
a861 3
#if 0 /* XXX fix me */
	if (brd)
		ka->dstbrd = brd->sin6_addr;
d863 1
a863 2
		bzero(&ka->dstbrd, sizeof(ka->dstbrd));
#endif
d865 18
a882 2
	log_debug("if_newaddr: ifindex %u, addr %s", ifindex,
	    log_in6addr(&ia->addr));
@


1.7
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.6 2007/12/13 08:54:05 claudio Exp $ */
d920 1
@


1.6
log
@Monster commit of stuff I did mostly last month. What it does:
 * removes kif and uses iface for everything interface related.
   This removes unneeded data redundancy which makes the code more complex.
 * adds the link local prefix to struct iface and attaches a list with
   the other prefixes to the struct iface. This is needed to generate the
   link LSA.
 * disconnects struct iface from struct area (the backpointer is gone)
   this will make the reload code a bit easier.
norby@@ agrees with the direction we're heading with this
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.5 2007/10/17 20:54:41 claudio Exp $ */
d794 1
a794 1
		log_warn("if_change:  kif_update(%u)", ifindex);
d883 1
a883 1
			fatal("if_new failed");
@


1.5
log
@From ripd: Add missing RTM_VERSION checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.4 2007/10/16 08:41:56 claudio Exp $ */
d41 1
a57 6
struct kif_node {
	RB_ENTRY(kif_node)	 entry;
	TAILQ_HEAD(, kif_addr)	 addrs;
	struct kif		 k;
};

a61 1
int	kif_compare(struct kif_node *, struct kif_node *);
d70 2
a71 6
struct kif_node		*kif_find(u_short);
struct kif_node		*kif_insert(u_short);
int			 kif_remove(struct kif_node *);
void			 kif_clear(void);
struct kif		*kif_update(u_short, int, struct if_data *,
			    struct sockaddr_dl *);
a85 1
int		fetchifs(u_short);
a90 15
RB_HEAD(kif_tree, kif_node)		kit;
RB_PROTOTYPE(kif_tree, kif_node, entry, kif_compare)
RB_GENERATE(kif_tree, kif_node, entry, kif_compare)

int
kif_init(void)
{
	RB_INIT(&kit);

	if (fetchifs(0) == -1)
		return (-1);

	return (0);
}

a247 1
	kif_clear();
a337 14
kr_ifinfo(char *ifname, pid_t pid)
{
	struct kif_node	*kif;

	RB_FOREACH(kif, kif_tree, &kit)
		if (ifname == NULL || !strcmp(ifname, kif->k.ifname)) {
			main_imsg_compose_ospfe(IMSG_CTL_IFINFO,
			    pid, &kif->k, sizeof(kif->k));
		}

	main_imsg_compose_ospfe(IMSG_CTL_END, pid, NULL, 0);
}

void
a491 6
int
kif_compare(struct kif_node *a, struct kif_node *b)
{
	return (b->k.ifindex - a->k.ifindex);
}

d604 3
a606 2
struct kif_node *
kif_find(u_short ifindex)
d608 2
a609 1
	struct kif_node	s;
d611 8
a618 18
	bzero(&s, sizeof(s));
	s.k.ifindex = ifindex;

	return (RB_FIND(kif_tree, &kit, &s));
}

struct kif *
kif_findname(char *ifname, struct kif_addr **kap)
{
	struct kif_node	*kif;
	struct kif_addr	*ka;

	RB_FOREACH(kif, kif_tree, &kit)
		if (!strcmp(ifname, kif->k.ifname)) {
			ka = TAILQ_FIRST(&kif->addrs);
			if (kap != NULL)
				*kap = ka;
			return (&kif->k);
d621 3
a623 33
	return (NULL);
}

struct kif_node *
kif_insert(u_short ifindex)
{
	struct kif_node	*kif;

	if ((kif = calloc(1, sizeof(struct kif_node))) == NULL)
		return (NULL);

	kif->k.ifindex = ifindex;
	TAILQ_INIT(&kif->addrs);

	if (RB_INSERT(kif_tree, &kit, kif) != NULL)
		fatalx("kif_insert: RB_INSERT");

	return (kif);
}

int
kif_remove(struct kif_node *kif)
{
	struct kif_addr	*ka;

	if (RB_REMOVE(kif_tree, &kit, kif) == NULL) {
		log_warnx("RB_REMOVE(kif_tree, &kit, kif)");
		return (-1);
	}

	while ((ka = TAILQ_FIRST(&kif->addrs)) != NULL) {
		TAILQ_REMOVE(&kif->addrs, ka, entry);
		free(ka);
a624 3
	free(kif);
	return (0);
}
d626 2
a627 4
void
kif_clear(void)
{
	struct kif_node	*kif;
d629 1
a629 31
	while ((kif = RB_MIN(kif_tree, &kit)) != NULL)
		kif_remove(kif);
}

struct kif *
kif_update(u_short ifindex, int flags, struct if_data *ifd,
    struct sockaddr_dl *sdl)
{
	struct kif_node		*kif;

	if ((kif = kif_find(ifindex)) == NULL)
		if ((kif = kif_insert(ifindex)) == NULL)
			return (NULL);

	kif->k.flags = flags;
	kif->k.link_state = ifd->ifi_link_state;
	kif->k.media_type = ifd->ifi_type;
	kif->k.baudrate = ifd->ifi_baudrate;
	kif->k.mtu = ifd->ifi_mtu;

	if (sdl && sdl->sdl_family == AF_LINK) {
		if (sdl->sdl_nlen >= sizeof(kif->k.ifname))
			memcpy(kif->k.ifname, sdl->sdl_data,
			    sizeof(kif->k.ifname) - 1);
		else if (sdl->sdl_nlen > 0)
			memcpy(kif->k.ifname, sdl->sdl_data,
			    sdl->sdl_nlen);
		/* string already terminated via calloc() */
	}

	return (&kif->k);
d635 1
a635 1
	struct kif_node		*kif;
d637 1
a637 1
	if ((kif = kif_find(ifindex)) == NULL) {
d642 1
a642 1
	return (kif->k.nh_reachable);
d790 1
a790 1
	struct kif		*kif;
d793 1
a793 1
	if ((kif = kif_update(ifindex, flags, ifd, NULL)) == NULL) {
d798 4
a801 4
	reachable = (kif->flags & IFF_UP) &&
	    (LINK_STATE_IS_UP(kif->link_state) ||
	    (kif->link_state == LINK_STATE_UNKNOWN &&
	    kif->media_type != IFT_CARP));
d803 1
a803 1
	if (reachable == kif->nh_reachable)
d806 1
a806 1
	kif->nh_reachable = reachable;
d809 3
a811 1
	main_imsg_compose_ospfe(IMSG_IFINFO, 0, kif, sizeof(struct kif));
d832 2
a833 2
	struct kif_node *kif;
	struct kif_addr *ka;
d837 1
a837 1
	if ((kif = kif_find(ifindex)) == NULL) {
d841 11
a851 1
	if ((ka = calloc(1, sizeof(struct kif_addr))) == NULL)
a852 1
	ka->addr = ifa->sin6_addr;
d854 1
a854 6
	/* XXX thanks, KAME, for this ugliness... adopted from route/show.c */
	if (IN6_IS_ADDR_LINKLOCAL(&ka->addr) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&ka->addr)) {
		ka->addr.s6_addr[2] = 0;
		ka->addr.s6_addr[3] = 0;
	}
d857 1
a857 1
		ka->mask = mask->sin6_addr;
d859 2
a860 1
		bzero(&ka->mask, sizeof(ka->mask));
d865 1
d868 2
a869 2
	    log_in6addr(&ka->addr));
	TAILQ_INSERT_TAIL(&kif->addrs, ka, entry);
d876 1
a876 1
	struct kif_node			*kif;
d882 3
a884 2
		kif = kif_insert(ifan->ifan_index);
		strlcpy(kif->k.ifname, ifan->ifan_name, sizeof(kif->k.ifname));
d887 8
a894 2
		kif = kif_find(ifan->ifan_index);
		kif_remove(kif);
d1132 1
a1132 1
	struct kif		*kif = NULL;
d1167 1
a1167 1
			if ((kif = kif_update(ifm.ifm_index,
d1172 1
a1172 1
			kif->nh_reachable = (kif->flags & IFF_UP) &&
@


1.4
log
@First step at making kroute IPv6 aware. This resulted in many additional
changes -- some are so hairy that I left them out for later by commenting out
larger blocks of code (just grep for XXX if you like to help).
Get it in early so that we can work on.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.3 2007/10/11 21:29:53 claudio Exp $ */
d1152 2
d1333 2
@


1.3
log
@There is no need to support interface em0:<IP> anymore. Remove most of the
code the rest will be reused somehow.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.2 2007/10/10 14:06:03 claudio Exp $ */
d69 3
a71 2
struct kroute_node	*kroute_find(in_addr_t, u_int8_t);
struct kroute_node	*kroute_matchgw(struct kroute_node *, struct in_addr);
d84 1
a84 1
struct kroute_node	*kroute_match(in_addr_t);
a86 1
u_int8_t	prefixlen_classful(in_addr_t);
d174 1
a174 1
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen)) !=
d206 1
a206 2
	if ((kroute->nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
	    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
d213 1
a213 1
	if (kr && kr->r.nexthop.s_addr == kroute->nexthop.s_addr)
d224 1
a224 1
		kr->r.prefix.s_addr = kroute->prefix.s_addr;
d226 1
a226 1
		kr->r.nexthop.s_addr = kroute->nexthop.s_addr;
d234 1
a234 1
		kr->r.nexthop.s_addr = kroute->nexthop.s_addr;
d244 1
a244 1
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen)) ==
d324 1
a324 1
	struct in_addr		 addr;
d345 1
a345 1
		    sizeof(struct in_addr)) {
d351 1
a351 1
		kr = kroute_match(addr.s_addr);
d405 1
a405 1
	u_int32_t	 a, metric = 0;
d420 2
a421 2
	 * We consider the loopback net, multicast and experimental addresses
	 * as not redistributable.
d423 7
a429 3
	a = ntohl(kr->prefix.s_addr);
	if (IN_MULTICAST(a) || IN_BADCLASS(a) ||
	    (a >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
d434 1
a434 1
	if (kr->nexthop.s_addr == htonl(INADDR_LOOPBACK))
d520 6
a525 4
	if (ntohl(a->r.prefix.s_addr) < ntohl(b->r.prefix.s_addr))
		return (-1);
	if (ntohl(a->r.prefix.s_addr) > ntohl(b->r.prefix.s_addr))
		return (1);
d541 1
a541 1
kroute_find(in_addr_t prefix, u_int8_t prefixlen)
d545 1
a545 1
	s.r.prefix.s_addr = prefix;
d552 1
a552 1
kroute_matchgw(struct kroute_node *kr, struct in_addr nh)
a553 4
	in_addr_t	nexthop;

	nexthop = nh.s_addr;

d555 1
a555 1
		if (kr->r.nexthop.s_addr == nexthop)
d603 1
a603 1
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
d611 1
a611 1
			    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
d617 2
a618 1
				    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
d628 1
a628 1
			    "for %s/%u", inet_ntoa(kr->r.prefix),
d766 1
a766 1
kroute_match(in_addr_t key)
d770 1
d773 3
a775 2
	for (i = 32; i > 0; i--)
		if ((kr = kroute_find(key & prefixlen2mask(i), i)) != NULL)
d777 1
d780 1
a780 1
	if ((kr = kroute_find(0, 0)) != NULL)
d792 1
a792 1
	/* special protection for 127/8 */
d797 2
a798 2
	kr->r.prefix.s_addr = htonl(INADDR_LOOPBACK);
	kr->r.prefixlen = 8;
d808 1
a808 1
prefixlen_classful(in_addr_t ina)
d810 41
a850 1
	/* it hurt to write this. */
d852 1
a852 10
	if (ina >= 0xf0000000U)		/* class E */
		return (32);
	else if (ina >= 0xe0000000U)	/* class D */
		return (4);
	else if (ina >= 0xc0000000U)	/* class C */
		return (24);
	else if (ina >= 0x80000000U)	/* class B */
		return (16);
	else				/* class A */
		return (8);
d855 2
a856 2
u_int8_t
mask2prefixlen(in_addr_t ina)
d858 11
a868 4
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
d871 2
a872 2
in_addr_t
prefixlen2mask(u_int8_t prefixlen)
d874 9
a882 2
	if (prefixlen == 0)
		return (0);
d884 2
a885 1
	return (htonl(0xffffffff << (32 - prefixlen)));
d1010 3
a1012 3
	struct sockaddr_in	prefix;
	struct sockaddr_in	nexthop;
	struct sockaddr_in	mask;
d1034 3
a1036 3
	prefix.sin_len = sizeof(prefix);
	prefix.sin_family = AF_INET;
	prefix.sin_addr.s_addr = kroute->prefix.s_addr;
d1044 1
a1044 1
	if (kroute->nexthop.s_addr != 0) {
d1046 3
a1048 3
		nexthop.sin_len = sizeof(nexthop);
		nexthop.sin_family = AF_INET;
		nexthop.sin_addr.s_addr = kroute->nexthop.s_addr;
d1059 3
a1061 3
	mask.sin_len = sizeof(mask);
	mask.sin_family = AF_INET;
	mask.sin_addr.s_addr = prefixlen2mask(kroute->prefixlen);
d1095 1
a1095 2
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen);
d1098 3
a1100 4
				log_warnx("send_rtmsg: action %u, "
				    "prefix %s/%u: %s", hdr.rtm_type,
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen, strerror(errno));
d1105 3
a1107 3
			log_warnx("send_rtmsg: action %u, prefix %s/%u: %s",
			    hdr.rtm_type, inet_ntoa(kroute->prefix),
			    kroute->prefixlen, strerror(errno));
d1123 1
a1123 1
	struct sockaddr_in	*sa_in;
d1170 4
a1173 4
		case AF_INET:
			kr->r.prefix.s_addr =
			    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
			sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
d1180 2
a1181 2
			if (sa_in != NULL) {
				if (sa_in->sin_len == 0)
d1184 1
a1184 1
				    mask2prefixlen(sa_in->sin_addr.s_addr);
d1186 1
a1186 1
				kr->r.prefixlen = 32;
d1188 1
a1188 2
				kr->r.prefixlen =
				    prefixlen_classful(kr->r.prefix.s_addr);
d1198 3
a1200 3
			case AF_INET:
				kr->r.nexthop.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
d1310 1
a1310 1
	struct sockaddr_in	*sa_in;
d1313 1
a1313 1
	struct in_addr		 prefix, nexthop;
d1332 2
a1333 1
		prefix.s_addr = 0;
a1335 1
		nexthop.s_addr = 0;
d1360 4
a1363 4
			case AF_INET:
				prefix.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				sa_in = (struct sockaddr_in *)
d1365 2
a1366 2
				if (sa_in != NULL) {
					if (sa_in->sin_len != 0)
d1368 1
a1368 1
						    sa_in->sin_addr.s_addr);
d1370 1
a1370 1
					prefixlen = 32;
d1372 1
a1372 2
					prefixlen =
					    prefixlen_classful(prefix.s_addr);
d1388 2
a1389 2
					nexthop.s_addr = ((struct
					    sockaddr_in *)sa)->sin_addr.s_addr;
d1401 2
a1402 1
			if (nexthop.s_addr == 0 && !(flags & F_CONNECTED)) {
d1404 1
a1404 1
				    inet_ntoa(prefix), prefixlen);
d1408 1
a1408 1
			if ((okr = kroute_find(prefix.s_addr, prefixlen)) !=
d1416 1
a1416 1
				    nexthop)) == NULL) {
d1432 1
a1432 1
				kr->r.nexthop.s_addr = nexthop.s_addr;
d1461 1
a1461 1
				kr->r.prefix.s_addr = prefix.s_addr;
d1463 1
a1463 1
				kr->r.nexthop.s_addr = nexthop.s_addr;
d1479 1
a1479 1
			if ((kr = kroute_find(prefix.s_addr, prefixlen)) ==
d1487 1
a1487 1
			    (kr = kroute_matchgw(kr, nexthop)) == NULL) {
@


1.2
log
@Address scope was probably the most stupid idea comming out of IPv6.
Abusing the 3rd and 4th byte of a ff02::/32 address to store the scope is
wrong wrong wrong. Depending on the calls it is not possible to compare
addresses with IN6_ARE_ADDR_EQUAL(). Remove the scope hack when fetching
interface addresses so that we never rely on that inside ospf6d.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.1 2007/10/08 10:44:50 norby Exp $ */
d661 1
a661 1
kif_findname(char *ifname, struct in6_addr *addr, struct kif_addr **kap)
a668 6
			if (!IN6_IS_ADDR_UNSPECIFIED(addr)) {
				TAILQ_FOREACH(ka, &kif->addrs, entry) {
					if (IN6_ARE_ADDR_EQUAL(addr, &ka->addr))
						break;
				}
			}
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.52 2007/07/23 12:21:35 pyr Exp $ */
d917 8
@

