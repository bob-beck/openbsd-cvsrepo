head	1.38;
access;
symbols
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.16
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.12
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.8
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.10
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.6
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.35.0.10
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.8
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.6
	OPENBSD_5_0:1.35.0.4
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10;
locks; strict;
comment	@ * @;


1.38
date	2013.10.18.11.16.52;	author sthen;	state Exp;
branches;
next	1.37;

1.37
date	2013.05.09.12.57.01;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.25.14.29.35;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.22.20.55.10;	author bluhm;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.01.19.47.04;	author bluhm;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.01.18.57.21;	author bluhm;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.12.10.12.41;	author bluhm;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.09.17.36.36;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2010.03.01.08.55.45;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2010.02.26.09.59.44;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2010.02.23.11.17.23;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2010.02.22.08.03.06;	author stsp;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.29.19.18.20;	author stsp;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.29.19.14.23;	author stsp;	state Exp;
branches;
next	1.24;

1.24
date	2009.03.29.19.11.11;	author stsp;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.12.01.21.49;	author stsp;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.10.17.36.39;	author stsp;	state Exp;
branches;
next	1.21;

1.21
date	2009.03.10.17.32.14;	author stsp;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.08.14.40.11;	author stsp;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.07.00.33.13;	author stsp;	state Exp;
branches;
next	1.18;

1.18
date	2009.02.12.16.54.31;	author stsp;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.29.18.52.17;	author stsp;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.29.16.39.24;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.28.22.47.36;	author stsp;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.03.00.23.50;	author stsp;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.30.22.24.34;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.30.21.31.54;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.28.21.20.34;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.11.13.48.39;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.13.08.54.05;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.27.12.23.06;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.27.11.29.34;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.24.16.42.58;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.16.21.58.17;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.16.21.02.26;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.16.13.01.07;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.16.12.05.52;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.51;	author norby;	state Exp;
branches;
next	;


desc
@@


1.38
log
@typo in function name in log message
@
text
@/*	$OpenBSD: rde_lsdb.c,v 1.37 2013/05/09 12:57:01 claudio Exp $ */

/*
 * Copyright (c) 2004, 2005 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/tree.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ospf6.h"
#include "ospf6d.h"
#include "rde.h"
#include "log.h"

struct vertex	*vertex_get(struct lsa *, struct rde_nbr *, struct lsa_tree *);

int		 lsa_link_check(struct lsa *, u_int16_t);
int		 lsa_intra_a_pref_check(struct lsa *, u_int16_t);
int		 lsa_asext_check(struct lsa *, u_int16_t);
void		 lsa_timeout(int, short, void *);
void		 lsa_refresh(struct vertex *);
int		 lsa_equal(struct lsa *, struct lsa *);
int		 lsa_get_prefix(void *, u_int16_t, struct rt_prefix *);

RB_GENERATE(lsa_tree, vertex, entry, lsa_compare)

extern struct ospfd_conf	*rdeconf;

void
lsa_init(struct lsa_tree *t)
{
	RB_INIT(t);
}

int
lsa_compare(struct vertex *a, struct vertex *b)
{
	if (a->type < b->type)
		return (-1);
	if (a->type > b->type)
		return (1);
	if (a->adv_rtr < b->adv_rtr)
		return (-1);
	if (a->adv_rtr > b->adv_rtr)
		return (1);
	if (a->ls_id < b->ls_id)
		return (-1);
	if (a->ls_id > b->ls_id)
		return (1);
	return (0);
}


struct vertex *
vertex_get(struct lsa *lsa, struct rde_nbr *nbr, struct lsa_tree *tree)
{
	struct vertex	*v;
	struct timespec	 tp;

	if ((v = calloc(1, sizeof(struct vertex))) == NULL)
		fatal(NULL);
	TAILQ_INIT(&v->nexthop);
	v->area = nbr->area;
	v->peerid = nbr->peerid;
	v->lsa = lsa;
	clock_gettime(CLOCK_MONOTONIC, &tp);
	v->changed = v->stamp = tp.tv_sec;
	v->cost = LS_INFINITY;
	v->ls_id = ntohl(lsa->hdr.ls_id);
	v->adv_rtr = ntohl(lsa->hdr.adv_rtr);
	v->type = ntohs(lsa->hdr.type);
	v->lsa_tree = tree;

	if (!nbr->self)
		v->flooded = 1; /* XXX fix me */
	v->self = nbr->self;

	evtimer_set(&v->ev, lsa_timeout, v);

	return (v);
}

void
vertex_free(struct vertex *v)
{
	RB_REMOVE(lsa_tree, v->lsa_tree, v);
	(void)evtimer_del(&v->ev);
	free(v->lsa);
	free(v);
}

/* returns -1 if a is older, 1 if newer and 0 if equal to b */
int
lsa_newer(struct lsa_hdr *a, struct lsa_hdr *b)
{
	int32_t		 a32, b32;
	u_int16_t	 a16, b16;
	int		 i;

	if (a == NULL)
		return (-1);
	if (b == NULL)
		return (1);

	/*
	 * The sequence number is defined as signed 32-bit integer,
	 * no idea how IETF came up with such a stupid idea.
	 */
	a32 = (int32_t)ntohl(a->seq_num);
	b32 = (int32_t)ntohl(b->seq_num);

	if (a32 > b32)
		return (1);
	if (a32 < b32)
		return (-1);

	a16 = ntohs(a->ls_chksum);
	b16 = ntohs(b->ls_chksum);

	if (a16 > b16)
		return (1);
	if (a16 < b16)
		return (-1);

	a16 = ntohs(a->age);
	b16 = ntohs(b->age);

	if (a16 >= MAX_AGE && b16 >= MAX_AGE)
		return (0);
	if (b16 >= MAX_AGE)
		return (-1);
	if (a16 >= MAX_AGE)
		return (1);

	i = b16 - a16;
	if (abs(i) > MAX_AGE_DIFF)
		return (i > 0 ? 1 : -1);

	return (0);
}

int
lsa_check(struct rde_nbr *nbr, struct lsa *lsa, u_int16_t len)
{
	u_int32_t	 metric;

	if (len < sizeof(lsa->hdr)) {
		log_warnx("lsa_check: bad packet size");
		return (0);
	}
	if (ntohs(lsa->hdr.len) != len) {
		log_warnx("lsa_check: bad packet size");
		return (0);
	}

	if (iso_cksum(lsa, len, 0)) {
		log_warnx("lsa_check: bad packet checksum");
		return (0);
	}

	/* invalid ages */
	if ((ntohs(lsa->hdr.age) < 1 && !nbr->self) ||
	    ntohs(lsa->hdr.age) > MAX_AGE) {
		log_warnx("lsa_check: bad age");
		return (0);
	}

	/* invalid sequence number */
	if (ntohl(lsa->hdr.seq_num) == RESV_SEQ_NUM) {
		log_warnx("lsa_check: bad seq num");
		return (0);
	}

	switch (ntohs(lsa->hdr.type)) {
	case LSA_TYPE_LINK:
		if (!lsa_link_check(lsa, len))
			return (0);
		break;
	case LSA_TYPE_ROUTER:
		if (len < sizeof(lsa->hdr) + sizeof(struct lsa_rtr)) {
			log_warnx("lsa_check: bad LSA rtr packet");
			return (0);
		}
		len -= sizeof(lsa->hdr) + sizeof(struct lsa_rtr);
		if (len % sizeof(struct lsa_rtr_link)) {
			log_warnx("lsa_check: bad LSA rtr packet");
			return (0);
		}
		break;
	case LSA_TYPE_NETWORK:
		if ((len % sizeof(u_int32_t)) ||
		    len < sizeof(lsa->hdr) + sizeof(u_int32_t)) {
			return (0);
		}
		break;
	case LSA_TYPE_INTER_A_PREFIX:
		if (len < sizeof(lsa->hdr) + sizeof(lsa->data.pref_sum)) {
			log_warnx("lsa_check: bad LSA prefix summary packet");
			return (0);
		}
		metric = ntohl(lsa->data.pref_sum.metric);
		if (metric & ~LSA_METRIC_MASK) {
			log_warnx("lsa_check: bad LSA summary metric");
			return (0);
		}
		if (lsa_get_prefix(((char *)lsa) + sizeof(lsa->hdr) +
		    sizeof(lsa->data.pref_sum),
		    len - sizeof(lsa->hdr) + sizeof(lsa->data.pref_sum),
		    NULL) == -1) {
			log_warnx("lsa_check: "
			    "invalid LSA prefix summary packet");
			return (0);
		}
		break;
	case LSA_TYPE_INTER_A_ROUTER:
		if (len < sizeof(lsa->hdr) + sizeof(lsa->data.rtr_sum)) {
			log_warnx("lsa_check: bad LSA router summary packet");
			return (0);
		}
		metric = ntohl(lsa->data.rtr_sum.metric);
		if (metric & ~LSA_METRIC_MASK) {
			log_warnx("lsa_check: bad LSA summary metric");
			return (0);
		}
		break;
	case LSA_TYPE_INTRA_A_PREFIX:
		if (!lsa_intra_a_pref_check(lsa, len))
			return (0);
		break;
	case LSA_TYPE_EXTERNAL:
		/* AS-external-LSA are silently discarded in stub areas */
		if (nbr->area->stub)
			return (0);
		if (!lsa_asext_check(lsa, len))
			return (0);
		break;
	default:
		log_warnx("lsa_check: unknown type %x", ntohs(lsa->hdr.type));
		return (0);
	}

	/* MaxAge handling */
	if (lsa->hdr.age == htons(MAX_AGE) && !nbr->self && lsa_find(nbr->iface,
	    lsa->hdr.type, lsa->hdr.ls_id, lsa->hdr.adv_rtr) == NULL &&
	    !rde_nbr_loading(nbr->area)) {
		/*
		 * if no neighbor in state Exchange or Loading
		 * ack LSA but don't add it. Needs to be a direct ack.
		 */
		rde_imsg_compose_ospfe(IMSG_LS_ACK, nbr->peerid, 0, &lsa->hdr,
		    sizeof(struct lsa_hdr));
		return (0);
	}

	return (1);
}

int
lsa_link_check(struct lsa *lsa, u_int16_t len)
{
	char			*buf = (char *)lsa;
	struct lsa_link		*llink;
	u_int32_t		 i, off, npref;
	int			 rv;

	llink = (struct lsa_link *)(buf + sizeof(lsa->hdr));
	off = sizeof(lsa->hdr) + sizeof(struct lsa_link);
	if (off > len) {
		log_warnx("lsa_link_check: invalid LSA link packet, "
		    "short header");
		return (0);
	}

	len -= off;
	npref = ntohl(llink->numprefix);

	for (i = 0; i < npref; i++) {
		rv = lsa_get_prefix(buf + off, len, NULL);
		if (rv == -1) {
			log_warnx("lsa_link_check: invalid LSA link packet");
			return (0);
		}
		off += rv;
		len -= rv;
	}

	return (1);
}

int
lsa_intra_a_pref_check(struct lsa *lsa, u_int16_t len)
{
	char			*buf = (char *)lsa;
	struct lsa_intra_prefix	*iap;
	u_int32_t		 i, off, npref;
	int			 rv;

	iap = (struct lsa_intra_prefix *)(buf + sizeof(lsa->hdr));
	off = sizeof(lsa->hdr) + sizeof(struct lsa_intra_prefix);
	if (off > len) {
		log_warnx("lsa_intra_a_pref_check: "
		    "invalid LSA intra area prefix packet, short header");
		return (0);
	}

	len -= off;
	npref = ntohs(iap->numprefix);

	for (i = 0; i < npref; i++) {
		rv = lsa_get_prefix(buf + off, len, NULL);
		if (rv == -1) {
			log_warnx("lsa_intra_a_pref_check: "
			    "invalid LSA intra area prefix packet");
			return (0);
		}
		off += rv;
		len -= rv;
	}

	return (1);
}

int
lsa_asext_check(struct lsa *lsa, u_int16_t len)
{
	char			*buf = (char *)lsa;
	struct lsa_asext	*asext;
	struct in6_addr		 fw_addr;
	u_int32_t		 metric;
	u_int16_t		 ref_ls_type;
	int			 rv;
	u_int16_t		 total_len;

	asext = (struct lsa_asext *)(buf + sizeof(lsa->hdr));

	if ((len % sizeof(u_int32_t)) ||
	    len < sizeof(lsa->hdr) + sizeof(*asext)) {
		log_warnx("lsa_asext_check: bad LSA as-external packet");
		return (0);
	}

	total_len = sizeof(lsa->hdr) + sizeof(*asext);
	rv = lsa_get_prefix(&asext->prefix, len, NULL);
	if (rv == -1) {
		log_warnx("lsa_asext_check: bad LSA as-external packet");
		return (0);
	}
	total_len += rv - sizeof(struct lsa_prefix);

	metric = ntohl(asext->metric);
	if (metric & LSA_ASEXT_F_FLAG) {
		if (total_len + sizeof(fw_addr) < len) {
			bcopy(buf + total_len, &fw_addr, sizeof(fw_addr));
			if (IN6_IS_ADDR_UNSPECIFIED(&fw_addr) ||
			    IN6_IS_ADDR_LINKLOCAL(&fw_addr)) {
				log_warnx("lsa_asext_check: bad LSA "
				    "as-external forwarding address");
				return (0);
			}
		}
		total_len += sizeof(fw_addr);
	}

	if (metric & LSA_ASEXT_T_FLAG)
		total_len += sizeof(u_int32_t);

	ref_ls_type = asext->prefix.metric;
	if (ref_ls_type != 0)
		total_len += sizeof(u_int32_t);

	if (len != total_len) {
		log_warnx("lsa_asext_check: bad LSA as-external length");
		return (0);
	}

	return (1);
}

int
lsa_self(struct lsa *lsa)
{
	return rde_router_id() == lsa->hdr.adv_rtr;
}

void
lsa_flush(struct rde_nbr *nbr, struct lsa *lsa)
{
	struct lsa	*copy;

	/*
	 * The LSA may not be altered because the caller may still
	 * use it, so a copy needs to be added to the LSDB.
	 * The copy will be reflooded via the default timeout handler.
	 */
	if ((copy = malloc(ntohs(lsa->hdr.len))) == NULL)
		fatal("lsa_flush");
	memcpy(copy, lsa, ntohs(lsa->hdr.len));
	copy->hdr.age = htons(MAX_AGE);
	(void)lsa_add(rde_nbr_self(nbr->area), copy);
}

void
lsa_reflood(struct vertex *v, struct lsa *new)
{
	/*
	 * We only need to create a new instance by setting the LSA
	 * sequence number equal to the one of 'new' and calling
	 * lsa_refresh(). Actual flooding will be done by the caller.
	 */
	v->lsa->hdr.seq_num = new->hdr.seq_num;
	lsa_refresh(v);
}

int
lsa_add(struct rde_nbr *nbr, struct lsa *lsa)
{
	struct lsa_tree	*tree;
	struct vertex	*new, *old;
	struct timeval	 tv, now, res;
	int		 update = 1;

	if (LSA_IS_SCOPE_AS(ntohs(lsa->hdr.type)))
		tree = &asext_tree;
	else if (LSA_IS_SCOPE_AREA(ntohs(lsa->hdr.type)))
		tree = &nbr->area->lsa_tree;
	else if (LSA_IS_SCOPE_LLOCAL(ntohs(lsa->hdr.type)))
		tree = &nbr->iface->lsa_tree;
	else
		fatalx("unknown scope type");

	new = vertex_get(lsa, nbr, tree);
	old = RB_INSERT(lsa_tree, tree, new);

	if (old != NULL) {
		if (old->deleted && evtimer_pending(&old->ev, &tv)) {
			/* new update added before hold time expired */
			gettimeofday(&now, NULL);
			timersub(&tv, &now, &res);

			/* remove old LSA and insert new LSA with delay */
			vertex_free(old);
			RB_INSERT(lsa_tree, tree, new);
			new->deleted = 1;

			if (evtimer_add(&new->ev, &res) != 0)
				fatal("lsa_add");
			return (1);
		}
		if (lsa_equal(new->lsa, old->lsa))
			update = 0;
		vertex_free(old);
		RB_INSERT(lsa_tree, tree, new);
	}

	if (update) {
		if (ntohs(lsa->hdr.type) == LSA_TYPE_LINK)
			orig_intra_area_prefix_lsas(nbr->area);
		if (ntohs(lsa->hdr.type) != LSA_TYPE_EXTERNAL)
			nbr->area->dirty = 1;
		start_spf_timer();
	}

	/* timeout handling either MAX_AGE or LS_REFRESH_TIME */
	timerclear(&tv);

	if (nbr->self && ntohs(new->lsa->hdr.age) == DEFAULT_AGE)
		tv.tv_sec = LS_REFRESH_TIME;
	else
		tv.tv_sec = MAX_AGE - ntohs(new->lsa->hdr.age);

	if (evtimer_add(&new->ev, &tv) != 0)
		fatal("lsa_add");
	return (0);
}

void
lsa_del(struct rde_nbr *nbr, struct lsa_hdr *lsa)
{
	struct vertex	*v;
	struct timeval	 tv;

	v = lsa_find(nbr->iface, lsa->type, lsa->ls_id, lsa->adv_rtr);
	if (v == NULL)
		return;

	v->deleted = 1;
	/* hold time to make sure that a new lsa is not added premature */
	timerclear(&tv);
	tv.tv_sec = MIN_LS_INTERVAL;
	if (evtimer_add(&v->ev, &tv) == -1)
		fatal("lsa_del");
}

void
lsa_age(struct vertex *v)
{
	struct timespec	tp;
	time_t		now;
	int		d;
	u_int16_t	age;

	clock_gettime(CLOCK_MONOTONIC, &tp);
	now = tp.tv_sec;

	d = now - v->stamp;
	/* set stamp so that at least new calls work */
	v->stamp = now;

	if (d < 0) {
		log_warnx("lsa_age: time went backwards");
		return;
	}

	age = ntohs(v->lsa->hdr.age);
	if (age + d > MAX_AGE)
		age = MAX_AGE;
	else
		age += d;

	v->lsa->hdr.age = htons(age);
}

struct vertex *
lsa_find(struct iface *iface, u_int16_t type, u_int32_t ls_id,
    u_int32_t adv_rtr)
{
	struct lsa_tree	*tree;

	if (LSA_IS_SCOPE_AS(ntohs(type)))
		tree = &asext_tree;
	else if (LSA_IS_SCOPE_AREA(ntohs(type))) {
		struct area	*area;

		if ((area = area_find(rdeconf, iface->area_id)) == NULL)
			fatalx("interface lost area");
		tree = &area->lsa_tree;
	} else if (LSA_IS_SCOPE_LLOCAL(ntohs(type)))
		tree = &iface->lsa_tree;
	else
		fatalx("unknown scope type");

	return lsa_find_tree(tree, type, ls_id, adv_rtr);

}

struct vertex *
lsa_find_tree(struct lsa_tree *tree, u_int16_t type, u_int32_t ls_id,
    u_int32_t adv_rtr)
{
	struct vertex	 key;
	struct vertex	*v;

	key.ls_id = ntohl(ls_id);
	key.adv_rtr = ntohl(adv_rtr);
	key.type = ntohs(type);

	v = RB_FIND(lsa_tree, tree, &key);

	/* LSA that are deleted are not findable */
	if (v && v->deleted)
		return (NULL);

	if (v)
		lsa_age(v);

	return (v);
}

struct vertex *
lsa_find_rtr(struct area *area, u_int32_t rtr_id)
{
	return lsa_find_rtr_frag(area, rtr_id, 0);
}

struct vertex *
lsa_find_rtr_frag(struct area *area, u_int32_t rtr_id, unsigned int n)
{
	struct vertex	*v;
	struct vertex	 key;
	unsigned int	 i;

	key.ls_id = 0;
	key.adv_rtr = ntohl(rtr_id);
	key.type = LSA_TYPE_ROUTER;

	i = 0;
	v = RB_NFIND(lsa_tree, &area->lsa_tree, &key);
	while (v) {
		if (v->type != LSA_TYPE_ROUTER ||
		    v->adv_rtr != ntohl(rtr_id)) {
			/* no more interesting LSAs */
			v = NULL;
			break;
		}
		if (!v->deleted) {
			if (i >= n)
				break;
			i++;
		}
		v = RB_NEXT(lsa_tree, &area->lsa_tree, v);
	}

	if (v) {
		if (i == n)
			lsa_age(v);
		else
			v = NULL;
	}

	return (v);
}

u_int32_t
lsa_find_lsid(struct lsa_tree *tree, u_int16_t type, u_int32_t adv_rtr,
    int (*cmp)(struct lsa *, struct lsa *), struct lsa *lsa)
{
#define MIN(x, y)	((x) < (y) ? (x) : (y))
	struct vertex	*v;
	struct vertex	 key;
	u_int32_t	 min, cur;

	key.ls_id = 0;
	key.adv_rtr = ntohl(adv_rtr);
	key.type = ntohs(type);

	cur = 0;
	min = 0xffffffffU;
	v = RB_NFIND(lsa_tree, tree, &key);
	while (v) {
		if (v->type != key.type ||
		    v->adv_rtr != key.adv_rtr) {
			/* no more interesting LSAs */
			min = MIN(min, cur + 1);
			return (htonl(min));
		}
		if (cmp(lsa, v->lsa) == 0) {
			/* match, return this ls_id */
			return (htonl(v->ls_id));
		}
		if (v->ls_id > cur + 1)
			min = cur + 1;
		cur = v->ls_id;
		if (cur + 1 < cur)
			fatalx("King Bula sez: somebody got to many LSA");
		v = RB_NEXT(lsa_tree, tree, v);
	}
	min = MIN(min, cur + 1);
	return (htonl(min));
#undef MIN
}

u_int16_t
lsa_num_links(struct vertex *v)
{
	unsigned int	 n = 1;
	u_int16_t	 nlinks = 0;

	switch (v->type) {
	case LSA_TYPE_ROUTER:
		do {
			nlinks += ((ntohs(v->lsa->hdr.len) -
			    sizeof(struct lsa_hdr) - sizeof(struct lsa_rtr)) /
			    sizeof(struct lsa_rtr_link));
			v = lsa_find_rtr_frag(v->area, htonl(v->adv_rtr), n++);
		} while (v);
		return nlinks;
	case LSA_TYPE_NETWORK:
		return ((ntohs(v->lsa->hdr.len) - sizeof(struct lsa_hdr) -
		    sizeof(struct lsa_net)) / sizeof(struct lsa_net_link));
	default:
		fatalx("lsa_num_links: invalid LSA type");
	}

	return (0);
}

void
lsa_snap(struct rde_nbr *nbr, u_int32_t peerid)
{
	struct lsa_tree	*tree = &nbr->area->lsa_tree;
	struct vertex	*v;

	do {
		RB_FOREACH(v, lsa_tree, tree) {
			if (v->deleted)
				continue;
			lsa_age(v);
			if (ntohs(v->lsa->hdr.age) >= MAX_AGE) {
				rde_imsg_compose_ospfe(IMSG_LS_SNAP, peerid,
				    0, &v->lsa->hdr, ntohs(v->lsa->hdr.len));
			} else {
				rde_imsg_compose_ospfe(IMSG_DB_SNAPSHOT, peerid,
				    0, &v->lsa->hdr, sizeof(struct lsa_hdr));
			}
		}
		if (tree == &asext_tree)
			break;
		if (tree == &nbr->area->lsa_tree)
			tree = &nbr->iface->lsa_tree;
		else
			tree = &asext_tree;
	} while (1);
}

void
lsa_dump(struct lsa_tree *tree, int imsg_type, pid_t pid)
{
	struct vertex	*v;

	RB_FOREACH(v, lsa_tree, tree) {
		if (v->deleted)
			continue;
		lsa_age(v);
		switch (imsg_type) {
		case IMSG_CTL_SHOW_DATABASE:
			rde_imsg_compose_ospfe(IMSG_CTL_SHOW_DATABASE, 0, pid,
			    &v->lsa->hdr, ntohs(v->lsa->hdr.len));
			continue;
		case IMSG_CTL_SHOW_DB_SELF:
			if (v->lsa->hdr.adv_rtr == rde_router_id())
				break;
			continue;
		case IMSG_CTL_SHOW_DB_EXT:
			if (v->type == LSA_TYPE_EXTERNAL)
				break;
			continue;
		case IMSG_CTL_SHOW_DB_LINK:
			if (v->type == LSA_TYPE_LINK)
				break;
			continue;
		case IMSG_CTL_SHOW_DB_NET:
			if (v->type == LSA_TYPE_NETWORK)
				break;
			continue;
		case IMSG_CTL_SHOW_DB_RTR:
			if (v->type == LSA_TYPE_ROUTER)
				break;
			continue;
		case IMSG_CTL_SHOW_DB_INTRA:
			if (v->type == LSA_TYPE_INTRA_A_PREFIX)
				break;
		case IMSG_CTL_SHOW_DB_SUM:
			if (v->type == LSA_TYPE_INTER_A_PREFIX)
				break;
			continue;
		case IMSG_CTL_SHOW_DB_ASBR:
			if (v->type == LSA_TYPE_INTER_A_ROUTER)
				break;
			continue;
		default:
			log_warnx("lsa_dump: unknown imsg type");
			return;
		}
		rde_imsg_compose_ospfe(imsg_type, 0, pid, &v->lsa->hdr,
		    ntohs(v->lsa->hdr.len));
	}
}

/* ARGSUSED */
void
lsa_timeout(int fd, short event, void *bula)
{
	struct vertex	*v = bula;
	struct timeval	 tv;

	lsa_age(v);

	if (v->deleted) {
		if (ntohs(v->lsa->hdr.age) >= MAX_AGE) {
			vertex_free(v);
		} else {
			v->deleted = 0;

			/* schedule recalculation of the RIB */
			if (ntohs(v->lsa->hdr.type) == LSA_TYPE_LINK)
				orig_intra_area_prefix_lsas(v->area);
			if (ntohs(v->lsa->hdr.type) != LSA_TYPE_EXTERNAL)
				v->area->dirty = 1;
			start_spf_timer();

			rde_imsg_compose_ospfe(IMSG_LS_FLOOD, v->peerid, 0,
			    v->lsa, ntohs(v->lsa->hdr.len));

			/* timeout handling either MAX_AGE or LS_REFRESH_TIME */
			timerclear(&tv);
			if (v->self)
				tv.tv_sec = LS_REFRESH_TIME;
			else
				tv.tv_sec = MAX_AGE - ntohs(v->lsa->hdr.age);

			if (evtimer_add(&v->ev, &tv) != 0)
				fatal("lsa_timeout");
		}
		return;
	}

	if (v->self && ntohs(v->lsa->hdr.age) < MAX_AGE)
		lsa_refresh(v);

	rde_imsg_compose_ospfe(IMSG_LS_FLOOD, v->peerid, 0,
	    v->lsa, ntohs(v->lsa->hdr.len));
}

void
lsa_refresh(struct vertex *v)
{
	struct timeval	 tv;
	struct timespec	 tp;
	u_int32_t	 seqnum;
	u_int16_t	 len;

	/* refresh LSA by increasing sequence number by one */
	if (v->self && ntohs(v->lsa->hdr.age) >= MAX_AGE)
		/* self originated network that is currently beeing removed */
		v->lsa->hdr.age = htons(MAX_AGE);
	else
		v->lsa->hdr.age = htons(DEFAULT_AGE);
	seqnum = ntohl(v->lsa->hdr.seq_num);
	if (seqnum++ == MAX_SEQ_NUM)
		/* XXX fix me */
		fatalx("sequence number wrapping");
	v->lsa->hdr.seq_num = htonl(seqnum);

	/* recalculate checksum */
	len = ntohs(v->lsa->hdr.len);
	v->lsa->hdr.ls_chksum = 0;
	v->lsa->hdr.ls_chksum = htons(iso_cksum(v->lsa, len, LS_CKSUM_OFFSET));

	clock_gettime(CLOCK_MONOTONIC, &tp);
	v->changed = v->stamp = tp.tv_sec;

	timerclear(&tv);
	tv.tv_sec = LS_REFRESH_TIME;
	if (evtimer_add(&v->ev, &tv) == -1)
		fatal("lsa_refresh");
}

void
lsa_merge(struct rde_nbr *nbr, struct lsa *lsa, struct vertex *v)
{
	struct timeval	tv;
	struct timespec	tp;
	time_t		now;
	u_int16_t	len;

	if (v == NULL) {
		if (lsa_add(nbr, lsa))
			/* delayed update */
			return;
		rde_imsg_compose_ospfe(IMSG_LS_FLOOD, nbr->peerid, 0,
		    lsa, ntohs(lsa->hdr.len));
		return;
	}

	/* set the seq_num to the current one. lsa_refresh() will do the ++ */
	lsa->hdr.seq_num = v->lsa->hdr.seq_num;
	/* recalculate checksum */
	len = ntohs(lsa->hdr.len);
	lsa->hdr.ls_chksum = 0;
	lsa->hdr.ls_chksum = htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	/* compare LSA most header fields are equal so don't check them */
	if (lsa_equal(lsa, v->lsa)) {
		free(lsa);
		return;
	}

	/* overwrite the lsa all other fields are unaffected */
	free(v->lsa);
	v->lsa = lsa;
	if (v->type == LSA_TYPE_LINK)
		orig_intra_area_prefix_lsas(nbr->area);
	if (v->type != LSA_TYPE_EXTERNAL)
		nbr->area->dirty = 1;
	start_spf_timer();

	/* set correct timeout for reflooding the LSA */
	clock_gettime(CLOCK_MONOTONIC, &tp);
	now = tp.tv_sec;
	timerclear(&tv);
	if (v->changed + MIN_LS_INTERVAL >= now)
		tv.tv_sec = MIN_LS_INTERVAL;
	if (evtimer_add(&v->ev, &tv) == -1)
		fatal("lsa_merge");
}

void
lsa_remove_invalid_sums(struct area *area)
{
	struct lsa_tree	*tree = &area->lsa_tree;
	struct vertex	*v, *nv;

	/* XXX speed me up */
	for (v = RB_MIN(lsa_tree, tree); v != NULL; v = nv) {
		nv = RB_NEXT(lsa_tree, tree, v);
		if ((v->type == LSA_TYPE_INTER_A_PREFIX ||
		    v->type == LSA_TYPE_INTER_A_ROUTER) &&
		    v->self && v->cost == LS_INFINITY &&
		    v->deleted == 0) {
			/*
			 * age the lsa and call lsa_timeout() which will
			 * actually remove it from the database.
			 */
			v->lsa->hdr.age = htons(MAX_AGE);
			lsa_timeout(0, 0, v);
		}
	}
}

int
lsa_equal(struct lsa *a, struct lsa *b)
{
	/*
	 * compare LSA that already have same type, adv_rtr and ls_id
	 * so not all header need to be compared
	 */
	if (a == NULL || b == NULL)
		return (0);
	if (a->hdr.len != b->hdr.len)
		return (0);
	/* LSAs with age MAX_AGE are never equal */
	if (a->hdr.age == htons(MAX_AGE) || b->hdr.age == htons(MAX_AGE))
		return (0);
	if (memcmp(&a->data, &b->data, ntohs(a->hdr.len) -
	    sizeof(struct lsa_hdr)))
		return (0);

	return (1);
}

int
lsa_get_prefix(void *buf, u_int16_t len, struct rt_prefix *p)
{
	struct lsa_prefix	*lp = buf;
	u_int32_t		*buf32, *addr = NULL;
	u_int8_t		 prefixlen;
	u_int16_t		 consumed;

	if (len < sizeof(*lp))
		return (-1);

	prefixlen = lp->prefixlen;

	if (p) {
		bzero(p, sizeof(*p));
		p->prefixlen = lp->prefixlen;
		p->options = lp->options;
		p->metric = ntohs(lp->metric);
		addr = (u_int32_t *)&p->prefix;
	}

	buf32 = (u_int32_t *)(lp + 1);
	consumed = sizeof(*lp);

	for (prefixlen = LSA_PREFIXSIZE(prefixlen) / sizeof(u_int32_t);
	    prefixlen > 0; prefixlen--) {
		if (len < consumed + sizeof(u_int32_t))
			return (-1);
		if (addr)
			*addr++ = *buf32++;
		consumed += sizeof(u_int32_t);
	}

	return (consumed);
}
@


1.37
log
@Simplify code, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.36 2013/03/25 14:29:35 markus Exp $ */
d185 1
a185 1
		log_warnx("ls_check: bad seq num");
@


1.36
log
@sync w/ospfd: improve snapshot handling; ok claudio, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.35 2010/08/22 20:55:10 bluhm Exp $ */
d713 1
a713 1
		if (tree == &nbr->area->lsa_tree) {
d715 1
a715 2
			continue;
		} else
a716 1

@


1.35
log
@When removing an announced prefix, inherit the metric and ext_tag
from the LSA that is currently in the tree.  Based on claudio@@'s
diff and his fix for ospfd.  Additionally originate an LSA with
external route tag correctly by writing the AS-external-LSA's bit
T into the correct field.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.34 2010/07/01 19:47:04 bluhm Exp $ */
d704 1
a704 1
				rde_imsg_compose_ospfe(IMSG_LS_UPD, peerid,
@


1.34
log
@Fix all white space bugs in ospf6d at once.  No binary change.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.33 2010/07/01 18:57:21 bluhm Exp $ */
d830 5
a834 1
	v->lsa->hdr.age = htons(DEFAULT_AGE);
d938 1
a938 1
	/* LSA with age MAX_AGE are never equal */
@


1.33
log
@The prefixes of interface addresses of an ospf link have to be
advertised as link-lsa and intra-area-prefix-lsa when they change
dynamically.  Handle RTM_NEWADDR and RTM_DELADDR in kroute by sending
an imsg to ospfe.  Upon this event, originate a new link-lsa in
ospfe.  In rde a new intra-area-prefix-lsa is generated when a
link-lsa appears or goes away.
ok claudio@@; ok and test stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.32 2010/06/12 10:12:41 bluhm Exp $ */
d344 2
a345 2
	u_int32_t	 	 metric;
	u_int16_t	 	 ref_ls_type;
d716 1
a716 1
		} else 
a978 1

@


1.32
log
@Add a missing ntohs() around hdr.type.  This fixes a segfault as
the area of an ASE LSA is NULL.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.31 2010/06/09 17:36:36 claudio Exp $ */
d435 1
d464 2
a465 5
		if (!lsa_equal(new->lsa, old->lsa)) {
			if (ntohs(lsa->hdr.type) != LSA_TYPE_EXTERNAL)
				nbr->area->dirty = 1;
			start_spf_timer();
		}
d468 5
a472 1
	} else {
d792 2
d884 2
a885 1
	start_spf_timer();
d888 1
@


1.31
log
@Correctly decode prefixes. Fixes an infinite loop hit when the prefixlen is
not devidable by 32.  Problem found and identified by Martin Pelikán.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.30 2010/03/01 08:55:45 claudio Exp $ */
d790 1
a790 1
			if (v->lsa->hdr.type != LSA_TYPE_EXTERNAL)
@


1.30
log
@Implement lsa_find_lsid(), a function that searches the LSDB for a LSA
specified by type, adv_rtr and an LSA to compare against. This is needed
to find either a free LS ID or the previously assigned LS ID of an AS-ext
LSA.  "looks like you know what you're doing" stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.29 2010/02/26 09:59:44 claudio Exp $ */
d944 1
a944 1
	u_int16_t		 consumed = 0;
d960 1
a960 1
	consumed += sizeof(*lp);
d962 2
a963 1
	for (; ((prefixlen + 31) / 32) > 0; prefixlen -= 32) {
@


1.29
log
@Swap order of RB tree sorting from type, ls_id, adv_rtr to type, adv_rtr,
ls_id. This is needed since sometimes the ls_id is not known and we need
to walk part of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.28 2010/02/23 11:17:23 claudio Exp $ */
d624 39
@


1.28
log
@Implement lsa_asext_check() to verify that type 5 LSA are correctly encoded.
Diff originally from stsp@@, some minor modifications by me.
First step to support type 5 LSA.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.27 2010/02/22 08:03:06 stsp Exp $ */
d57 4
a63 4
		return (1);
	if (a->adv_rtr < b->adv_rtr)
		return (-1);
	if (a->adv_rtr > b->adv_rtr)
@


1.27
log
@Treat multiple Router-LSAs originated by the same router as an
aggregate, as mandated by RFC5340.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.26 2009/03/29 19:18:20 stsp Exp $ */
d34 1
a245 10
		if ((len % (3 * sizeof(u_int32_t))) ||
		    len < sizeof(lsa->hdr) + sizeof(lsa->data.asext)) {
			log_warnx("lsa_check: bad LSA as-external packet");
			return (0);
		}
		metric = ntohl(lsa->data.asext.metric);
		if (metric & ~(LSA_METRIC_MASK | LSA_ASEXT_E_FLAG)) {
			log_warnx("lsa_check: bad LSA as-external metric");
			return (0);
		}
d249 2
d333 56
@


1.26
log
@Remove lsa_find_net(), it isn't needed for OSPFv3.

pointed out by and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.25 2009/03/29 19:14:23 stsp Exp $ */
d536 6
d543 2
a544 7
	struct vertex	*r;

	/* A router can originate multiple router LSAs,
	 * differentiated by link state ID. Our job is
	 * to find among those the LSA with the lowest
	 * link state ID, because this is where the options
	 * field and router-type bits come from. */
d546 26
a571 13
	r = NULL;
	/* XXX speed me up */
	RB_FOREACH(v, lsa_tree, &area->lsa_tree) {
		if (v->deleted)
			continue;

		if (v->type == LSA_TYPE_ROUTER &&
		    v->adv_rtr == ntohl(rtr_id)) {
			if (r == NULL)
				r = v;
			else if (v->ls_id < r->ls_id)
				r = v;
		}
d574 1
a574 4
	if (r)
		lsa_age(r);

	return (r);
d580 3
d585 7
a591 2
		return ((ntohs(v->lsa->hdr.len) - sizeof(struct lsa_hdr) -
		    sizeof(struct lsa_rtr)) / sizeof(struct lsa_rtr_link));
@


1.25
log
@Add lsa_find_rtr() function, which finds among multiple router
LSAs originated by the same router the one with the lowest link
state ID.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.24 2009/03/29 19:11:11 stsp Exp $ */
a563 21
}

struct vertex *
lsa_find_net(struct area *area, u_int32_t ls_id)
{
	struct lsa_tree	*tree = &area->lsa_tree;
	struct vertex	*v;

	/* XXX speed me up */
	RB_FOREACH(v, lsa_tree, tree) {
		if (v->lsa->hdr.type == LSA_TYPE_NETWORK &&
		    v->lsa->hdr.ls_id == ls_id) {
			/* LSA that are deleted are not findable */
			if (v->deleted)
				return (NULL);
			lsa_age(v);
			return (v);
		}
	}

	return (NULL);
@


1.24
log
@In lsa_num_links(), be more obvious about what parts of the LSA
are subtracted from the total length.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.23 2009/03/12 01:21:49 stsp Exp $ */
d531 33
@


1.23
log
@lsa_self() did too many things at once, and had too much logic
buried inside of it that its caller relied on.

So split it up as follows:
lsa_self()    Check whether an LSA is self-originated.
lsa_flush()   Flush an LSA from the LSDB.
lsa_reflood() Prepare an LSA for reflooding (actual reflooding currently
              requires sending an imsg which must be done by the caller).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.22 2009/03/10 17:36:39 stsp Exp $ */
d559 2
a560 2
		return ((ntohs(v->lsa->hdr.len) - sizeof(struct lsa_hdr)
		    - sizeof(u_int32_t)) / sizeof(struct lsa_rtr_link));
d562 2
a563 2
		return ((ntohs(v->lsa->hdr.len) - sizeof(struct lsa_hdr)
		    - sizeof(u_int32_t)) / sizeof(struct lsa_net_link));
@


1.22
log
@Revert previous, I committed the wrong file, should have been rde_spf.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.20 2009/03/08 14:40:11 stsp Exp $ */
d346 1
a346 1
lsa_self(struct rde_nbr *nbr, struct lsa *new, struct vertex *v)
d348 2
a349 1
	struct lsa	*dummy;
d351 4
a354 2
	if (nbr->self)
		return (0);
d356 11
a366 21
	if (rde_router_id() != new->hdr.adv_rtr)
		return (0);

	if (v == NULL) {
		/*
		 * LSA is no longer announced, remove by premature aging.
		 * The problem is that new may not be altered so a copy
		 * needs to be added to the LSA DB first.
		 */
		if ((dummy = malloc(ntohs(new->hdr.len))) == NULL)
			fatal("lsa_self");
		memcpy(dummy, new, ntohs(new->hdr.len));
		dummy->hdr.age = htons(MAX_AGE);
		/*
		 * The clue is that by using the remote nbr as originator
		 * the dummy LSA will be reflooded via the default timeout
		 * handler.
		 */
		(void)lsa_add(rde_nbr_self(nbr->area), dummy);
		return (1);
	}
d368 3
d372 3
a374 4
	 * LSA is still originated, just reflood it. But we need to create
	 * a new instance by setting the LSA sequence number equal to the
	 * one of new and calling lsa_refresh(). Flooding will be done by the
	 * caller.
a377 1
	return (1);
@


1.21
log
@The linked() function had an identity crisis and referred to itself
as "spf_calc" in fatal error messages.
@
text
@d346 1
a346 1
lsa_self(struct lsa *lsa)
d348 1
a348 3
	/* Determine if LSA is self-originated. */
	return rde_router_id() == lsa->hdr.adv_rtr;
}
d350 2
a351 4
void
lsa_flush(struct rde_nbr *nbr, struct lsa *lsa)
{
	struct lsa	*copy;
d353 21
a373 11
	/*
	 * The LSA may not be altered because the caller may still use it,
	 * so a copy needs to be added to the LSDB first.
	 * The copy will be reflooded via the default timeout handler.
	 */
	if ((copy = malloc(ntohs(lsa->hdr.len))) == NULL)
		fatal("lsa_flush");
	memcpy(copy, lsa, ntohs(lsa->hdr.len));
	copy->hdr.age = htons(MAX_AGE);
	(void)lsa_add(rde_nbr_self(nbr->area), copy);
}
a374 3
void
lsa_reflood(struct vertex *v, struct lsa *new)
{
d376 4
a379 3
	 * We need to create a new instance by setting the LSA sequence
	 * number equal to the one of 'new' and calling lsa_refresh().
	 * The LSA will be reflooded via the default timeout handler.
d383 1
a564 1
		/* TODO: multiple router LSAs */
@


1.20
log
@Remove #ifdef'd code which had a TODO comment essentially asking
"Do we need anything fancy to determine whether *-prefix-LSAs
are self-originated?"
The answer is "No, we don't, see section 4.6 of RFC5340."
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.19 2009/03/07 00:33:13 stsp Exp $ */
d346 1
a346 1
lsa_self(struct rde_nbr *nbr, struct lsa *new, struct vertex *v)
d348 3
a350 1
	struct lsa	*dummy;
d352 4
a355 2
	if (nbr->self)
		return (0);
d357 11
a367 21
	if (rde_router_id() != new->hdr.adv_rtr)
		return (0);

	if (v == NULL) {
		/*
		 * LSA is no longer announced, remove by premature aging.
		 * The problem is that new may not be altered so a copy
		 * needs to be added to the LSA DB first.
		 */
		if ((dummy = malloc(ntohs(new->hdr.len))) == NULL)
			fatal("lsa_self");
		memcpy(dummy, new, ntohs(new->hdr.len));
		dummy->hdr.age = htons(MAX_AGE);
		/*
		 * The clue is that by using the remote nbr as originator
		 * the dummy LSA will be reflooded via the default timeout
		 * handler.
		 */
		(void)lsa_add(rde_nbr_self(nbr->area), dummy);
		return (1);
	}
d369 3
d373 3
a375 4
	 * LSA is still originated, just reflood it. But we need to create
	 * a new instance by setting the LSA sequence number equal to the
	 * one of new and calling lsa_refresh(). Flooding will be done by the
	 * caller.
a378 1
	return (1);
d560 1
@


1.19
log
@Add lsa_find_tree() to allow searching for LSAs in a specific LSA tree.
We had code marked XXX searching an LSA tree manually using RB_FIND(),
switch it over to lsa_find_tree().
Make lsa_find() use the new function, too, to avoid code duplication.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.18 2009/02/12 16:54:31 stsp Exp $ */
a348 3
#if 0
	struct iface	*iface;
#endif
d353 2
a354 10
	if (rde_router_id() == new->hdr.adv_rtr)
		goto self;

#if 0
	/* TODO: Do we need something like this for *-prefix-LSAs? */
	if (ntohs(new->hdr.type) == LSA_TYPE_NETWORK)
		LIST_FOREACH(iface, &nbr->area->iface_list, entry)
			if (iface->addr.s_addr == new->hdr.ls_id)
				goto self;
#endif
a355 2
	return (0);
self:
@


1.18
log
@Make vertex_free() correctly free LSAs in per-interface LSA trees.

Save a pointer to the right LSA tree in new member v->lsa_tree.
This saves us the hassle of finding the right tree in vertex_free(),
we already know it at creation time so why not tuck it in there?

This might cause problems if the ospfe side ever decides to call
area_del() with a non-empty area->lsa_tree, without correctly
initialising v->lsa_tree. But grep shows that the area's lsa_tree
is currently just initialized on the ospfe side, but never modified.

ospf6d daemons which crashed after about 1 min with malloc options
FGJ are now happy.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.17 2009/01/29 18:52:17 stsp Exp $ */
a509 2
	struct vertex	 key;
	struct vertex	*v;
d512 1
a512 5
	key.ls_id = ntohl(ls_id);
	key.adv_rtr = ntohl(adv_rtr);
	key.type = ntohs(type);

	if (LSA_IS_SCOPE_AS(key.type))
d514 1
a514 1
	else if (LSA_IS_SCOPE_AREA(key.type)) {
d520 1
a520 1
	} else if (LSA_IS_SCOPE_LLOCAL(key.type))
d524 15
@


1.17
log
@In Link LSAs, #prefixes is a 32bit value.
But in Intra-Area-Prefix LSAs, #prefixes is a 16bit value.
lsa_intra_a_pref_check() was failing on little-endian machines because
it was trying to byte-swap a 32bit value.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.16 2009/01/29 16:39:24 claudio Exp $ */
d30 1
a30 1
struct vertex	*vertex_get(struct lsa *, struct rde_nbr *);
d69 1
a69 1
vertex_get(struct lsa *lsa, struct rde_nbr *nbr)
d86 1
d100 1
a100 5
	if (v->type == LSA_TYPE_EXTERNAL)
		RB_REMOVE(lsa_tree, &asext_tree, v);
	else
		RB_REMOVE(lsa_tree, &v->area->lsa_tree, v);

d415 1
a415 1
	new = vertex_get(lsa, nbr);
@


1.16
log
@lsa_get_prefix() should return the number of bytes consumed and not the
number of bytes left in the buffer. OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.15 2009/01/28 22:47:36 stsp Exp $ */
d332 1
a332 1
	npref = ntohl(iap->numprefix);
@


1.15
log
@Teach ospf6d to originate Intra-Area-Prefix LSAs, which associate a list
of IPv6 prefixes with a Network LSA (there's another type of this LSA which
associates prefixes with a Router LSA -- this remains to be done).
Add what is necessary to allow ospf6ctl to read the new LSA type via IMSG.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.14 2009/01/03 00:23:50 stsp Exp $ */
d838 1
d854 1
a854 1
	len -= sizeof(*lp);
d857 1
a857 1
		if (len < sizeof(u_int32_t))
d861 1
a861 1
		len -= sizeof(u_int32_t);
d864 1
a864 1
	return (len);
@


1.14
log
@Since link LSAs live in iface->lsa_tree and not in area->lsa_tree,
we had better include LSAs from iface->lsa_tree when sending
DB summaries. Fixes initial flood of link LSAs.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.13 2008/12/30 22:24:34 claudio Exp $ */
d648 3
@


1.13
log
@lsa_get_prefix() needs to use something else then struct lsa_prefix to
store the prefix to because the onwire format has the prefix compressed and
so struct lsa_prefix will no longer carry the prefix in it. Use rt_prefix
instead which is the expanded and host-byte-order version of the former.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.12 2008/12/30 21:31:54 claudio Exp $ */
d585 1
a585 1
lsa_snap(struct area *area, u_int32_t peerid)
d587 1
a587 1
	struct lsa_tree	*tree = &area->lsa_tree;
d603 1
a603 1
		if (tree != &area->lsa_tree)
d605 6
a610 1
		tree = &asext_tree;
@


1.12
log
@First try at originating Link (type-8) LSA. Code is wrong and the initial
LSA is lost in lsa_flood. Put this in because it goes in the right direction
and ospf6d is work in progress. Add necessary framework so that we can print
Link LSA in ospf6ctl.
Diff mostly from stsp@@ ospf6ctl part by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.11 2008/12/28 21:20:34 claudio Exp $ */
d37 1
a37 1
int		 lsa_get_prefix(void *, u_int16_t, struct lsa_prefix *);
d825 1
a825 1
lsa_get_prefix(void *buf, u_int16_t len, struct lsa_prefix *p)
d827 3
a829 3
	u_int32_t	*buf32 = buf;
	u_int32_t	*addr = NULL;
	u_int8_t	 prefixlen;
d831 1
a831 1
	if (len < sizeof(u_int32_t))
d834 1
a834 1
	prefixlen = ntohl(*buf32) >> 24;
d838 3
a840 3
		p->prefixlen = prefixlen;
		p->options = (ntohl(*buf32) >> 16) & 0xff;
		p->metric = *buf32 & 0xffff;
d843 3
a845 2
	buf32++;
	len -= sizeof(u_int32_t);
@


1.11
log
@Part of lsa_self() works at least everything with us as adv_rtr should be
killed. From Stefan Sperling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.10 2008/02/11 13:48:39 norby Exp $ */
d629 4
@


1.10
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.9 2007/12/13 08:54:05 claudio Exp $ */
d351 1
a352 1
	struct lsa	*dummy;
d354 1
d362 2
d366 3
a368 2
		    if (iface->addr.s_addr == new->hdr.ls_id)
			    goto self;
a399 2
#endif
	return (0);
@


1.9
log
@Monster commit of stuff I did mostly last month. What it does:
 * removes kif and uses iface for everything interface related.
   This removes unneeded data redundancy which makes the code more complex.
 * adds the link local prefix to struct iface and attaches a list with
   the other prefixes to the struct iface. This is needed to generate the
   link LSA.
 * disconnects struct iface from struct area (the backpointer is gone)
   this will make the reload code a bit easier.
norby@@ agrees with the direction we're heading with this
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.8 2007/11/27 12:23:06 claudio Exp $ */
d685 1
a685 1
				fatal("lsa_add");
@


1.8
log
@Make lsa_find() find link local LSA by passing the interface instead of the
area as lookup point. Additionally make lsa_dump or actually the code around
it pass all LSA to ospf6ctl. The rde_spf.c are not final.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.7 2007/11/27 11:29:34 claudio Exp $ */
d41 2
d521 7
a527 3
	else if (LSA_IS_SCOPE_AREA(key.type))
		tree = &iface->area->lsa_tree;
	else if (LSA_IS_SCOPE_LLOCAL(key.type))
@


1.7
log
@Monster diff to bring us a bit on track again.
a) implement all (or at least most) lsa_check() cases.
b) classify the LSA scope correctly and add a per interface lsa_tree for
   the link local stuff.
c) implement a function to parse a prefix.

There is still a lot missing currently link local LSA are added to the
interface tree but nothing can access them (lsa_find() and a few friends
need some changes).
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.6 2007/11/24 16:42:58 claudio Exp $ */
a159 1
	struct area	*area = nbr->area;
d257 1
a257 1
		if (area->stub)
d266 1
a266 1
	if (lsa->hdr.age == htons(MAX_AGE) && !nbr->self && lsa_find(area,
d268 1
a268 1
	    !rde_nbr_loading(area)) {
d464 1
a464 1
	v = lsa_find(nbr->area, lsa->type, lsa->ls_id, lsa->adv_rtr);
d506 2
a507 1
lsa_find(struct area *area, u_int16_t type, u_int32_t ls_id, u_int32_t adv_rtr)
d517 1
a517 1
	if (type == LSA_TYPE_EXTERNAL)
d519 4
d524 1
a524 1
		tree = &area->lsa_tree;
@


1.6
log
@lsa_self() is completely busted at the moment, so just ignore it.
Currently ospf6d is unable to announce a thing so there is no need to cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.5 2007/10/16 21:58:17 claudio Exp $ */
d32 2
a33 1
int		 lsa_router_check(struct lsa *, u_int16_t);
d37 1
d192 2
a193 1
		/* XXX */
d196 7
a202 1
		if (!lsa_router_check(lsa, len))
d204 1
a208 1
			log_warnx("lsa_check: bad LSA network packet");
d213 18
d232 2
a233 3
		if ((len % sizeof(u_int32_t)) ||
		    len < sizeof(lsa->hdr) + sizeof(lsa->data.sum)) {
			log_warnx("lsa_check: bad LSA summary packet");
d236 1
a236 1
		metric = ntohl(lsa->data.sum.metric);
d243 2
a244 1
		/* XXX */
d262 1
a262 1
		log_warnx("lsa_check: unknown type %u", ntohs(lsa->hdr.type));
d283 1
a283 1
lsa_router_check(struct lsa *lsa, u_int16_t len)
a284 1
	struct lsa_rtr_link	*rtr_link;
d286 3
a288 1
	u_int16_t		 i, off, nlinks;
d290 2
a291 1
	off = sizeof(lsa->hdr) + sizeof(struct lsa_rtr);
d293 2
a294 1
		log_warnx("lsa_check: invalid LSA router packet");
d298 2
a299 5
	nlinks = (len - off) / 16;		/* XXX way to go ? */

	for (i = 0; i < nlinks; i++) {
		rtr_link = (struct lsa_rtr_link *)(buf + off);
		off += sizeof(struct lsa_rtr_link);
d301 4
a304 2
		if (off > len) {
			log_warnx("lsa_check: invalid LSA router packet");
d307 2
d311 16
a326 2
	if (i != nlinks) {
		log_warnx("lsa_check: invalid LSA router packet");
d329 15
d406 1
a406 1
	if (ntohs(lsa->hdr.type) == LSA_TYPE_EXTERNAL)
d408 4
d413 1
a413 1
		tree = &nbr->area->lsa_tree;
d583 1
a583 1
			if (ntohs(v->lsa->hdr.age) >= MAX_AGE)
d586 1
a586 1
			else
d589 1
d806 33
@


1.5
log
@Make struct lsa_rtr a better match of the reality. Still not happy because
some people had the great idea to make the OSPF options 24bits. Still undecided
if a u_int32_t should be used or 4 u_int8_t both is gross.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.4 2007/10/16 21:02:26 claudio Exp $ */
d290 1
a291 1
#if 0
a306 1
#endif
d335 2
@


1.4
log
@Big round of lsa type cleanup. Moving from u_int8_t to u_int16_t made a lot
of ntohs() necessary. Nota bene the lsa type is cached in the vertex node in
host byte order. Additionally the defines are in host byte order so sprinkle
some ntohs() over rde_lsdb.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.3 2007/10/16 13:01:07 norby Exp $ */
d495 2
a496 1
		return (ntohs(v->lsa->data.rtr.nlinks));
@


1.3
log
@Make ospf6d(8) not throw up on Router LSAs.

Initial step towards actually storing real LSAs.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.2 2007/10/16 12:05:52 norby Exp $ */
d81 1
a81 1
	v->type = lsa->hdr.type;
d190 1
a190 1
			/* XXX */
d235 1
a235 1
		log_warnx("lsa_check: unknown type %u", lsa->hdr.type);
d300 1
a300 1
	if (new->hdr.type == LSA_TYPE_NETWORK)
d345 1
a345 1
	if (lsa->hdr.type == LSA_TYPE_EXTERNAL)
d369 1
a369 1
			if (lsa->hdr.type != LSA_TYPE_EXTERNAL)
d376 1
a376 1
		if (lsa->hdr.type != LSA_TYPE_EXTERNAL)
d450 1
a450 1
	key.type = type;
d684 1
a684 1
	if (lsa->hdr.type != LSA_TYPE_EXTERNAL)
d706 2
a707 2
		if ((v->lsa->hdr.type == LSA_TYPE_INTER_A_PREFIX ||
		    v->lsa->hdr.type == LSA_TYPE_INTER_A_ROUTER) &&
@


1.2
log
@In OSPFv3 the LSA type is a 16 bit value, furthermore it uses different
values than the v2 counterpart.

Change to u_int16_t and define new LSA types.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.1 2007/10/08 10:44:51 norby Exp $ */
d268 2
a269 1
	nlinks = ntohs(lsa->data.rtr.nlinks);
d273 1
a273 5
		if (off > len) {
			log_warnx("lsa_check: invalid LSA router packet");
			return (0);
		}
		off += rtr_link->num_tos * sizeof(u_int32_t);
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.38 2007/04/10 13:26:39 claudio Exp $ */
d188 4
a191 1
	switch (lsa->hdr.type) {
d203 2
a204 2
	case LSA_TYPE_SUM_NETWORK:
	case LSA_TYPE_SUM_ROUTER:
d216 3
d445 1
a445 1
lsa_find(struct area *area, u_int8_t type, u_int32_t ls_id, u_int32_t adv_rtr)
d564 1
a564 1
			if (v->type == LSA_TYPE_SUM_NETWORK)
d568 1
a568 1
			if (v->type == LSA_TYPE_SUM_ROUTER)
d709 2
a710 2
		if ((v->lsa->hdr.type == LSA_TYPE_SUM_NETWORK ||
		    v->lsa->hdr.type == LSA_TYPE_SUM_ROUTER) &&
@

